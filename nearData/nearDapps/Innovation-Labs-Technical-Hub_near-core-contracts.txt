*GitHub Repository "Innovation-Labs-Technical-Hub/near-core-contracts"*

'''--- .buildkite/pipeline.yml ---
steps:
  - label: "check artifacts"
    command: |
      source ~/.cargo/env
      rustup default 1.59.0
      rustup target add wasm32-unknown-unknown
      ./scripts/build_all_docker.sh --check

  - label: "cargo test"
    command: |
      source ~/.cargo/env
      rustup default 1.59.0
      rustup target add wasm32-unknown-unknown
      ./scripts/test_all.sh

'''
'''--- README.md ---
# Core contracts

- [Lockup / Vesting contract](./lockup/)
- [Lockup Factory](./lockup-factory/)
- [Multisig contract](./multisig/)
- [Staking Pool / Delegation contract](./staking-pool/)
- [Staking Pool Factory](./staking-pool-factory/)
- [Voting Contract](./voting/)
- [Whitelist Contract](./whitelist/)

## Building and deploying

See [scripts](./scripts/) folder for details.

## Initializing Contracts with near-shell

When setting up the contract creating the contract account, deploying the binary, and initializing the state must all be done as an atomic step.  For example, in our tests for the lockup contract we initialize it like this:

```rust
pub fn init_lockup(
        &self,
        runtime: &mut RuntimeStandalone,
        args: &InitLockupArgs,
        amount: Balance,
    ) -> TxResult {
        let tx = self
            .new_tx(runtime, LOCKUP_ACCOUNT_ID.into())
            .create_account()
            .transfer(ntoy(35) + amount)
            .deploy_contract(LOCKUP_WASM_BYTES.to_vec())
            .function_call(
                "new".into(),
                serde_json::to_vec(args).unwrap(),
                200000000000000,
                0,
            )
            .sign(&self.signer);
        let res = runtime.resolve_tx(tx).unwrap();
        runtime.process_all().unwrap();
        outcome_into_result(res)
    }
```

To do this with near shell, first add a script like `deploy.js`:

```js
const fs = require('fs');
const account = await near.account("foundation");
const contractName = "lockup-owner-id";
const newArgs = {
  "lockup_duration": "31536000000000000",
  "lockup_start_information": {
    "TransfersDisabled": {
        "transfer_poll_account_id": "transfers-poll"
    }
  },
  "vesting_schedule": {
    "start_timestamp": "1535760000000000000",
    "cliff_timestamp": "1567296000000000000",
    "end_timestamp": "1661990400000000000"
  },
  "staking_pool_whitelist_account_id": "staking-pool-whitelist",
  "initial_owners_main_public_key": "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7",
  "foundation_account_id": "near"
}
const result = account.signAndSendTransaction(
    contractName,
    [
        nearAPI.transactions.createAccount(),
        nearAPI.transactions.transfer("100000000000000000000000000"),
        nearAPI.transactions.deployContract(fs.readFileSync("res/lockup_contract.wasm")),
        nearAPI.transactions.functionCall("new", Buffer.from(JSON.stringify(newArgs)), 100000000000000, "0"),
    ]);
```

Then use the `near repl` command. Once at the command prompt, load the script:

```js
> .load deploy.js
```

Note: `nearAPI` and `near` are both preloaded to the repl's context.

'''
'''--- lockup-factory/Cargo.toml ---
[package]
name = "lockup-factory"
version = "0.2.1"
authors = ["Angelblock <angelblock@starduststaking.com>"]
edition = "2018"
publish = false

[lib]
crate-type = ["cdylib", "rlib"]

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[dependencies]
near-sdk = "3.1.0"
hex = "0.4"

'''
'''--- lockup-factory/README.md ---
# Lockup Factory Contract

This contract deploys lockup contracts. 
It allows any user to create and fund the lockup contract.
The lockup factory contract packages the binary of the 
<a href="https://github.com/near/core-contracts/tree/master/lockup">lockup 
contract</a> within its own binary.

To create a new lockup contract a user should issue a transaction and 
attach the required minimum deposit. The entire deposit will be transferred to 
the newly created lockup contract including to cover the storage.

The benefits: 
1. Lockups can be funded from any account.
2. No need to have access to the foundation keys to create lockup.
3. Auto-generates the lockup from the owner account.
4. Refund deposit on errors.

# Deployment & Usage

## TestNet

near dev-deploy --wasmFile=res/lockup_factory.wasm

# Initialize the factory.
near call lockup.nearnet new '{"whitelist_account_id":"whitelist.nearnet","foundation_account_id":"nearnet","master_account_id":"nearnet","lockup_master_account_id":"lockup.nearnet"}' --accountId lockup.nearnet     

# Create a new lockup with the given parameters.
near call lockup.nearnet create '{"owner_account_id":"lockup_owner.testnet","lockup_duration":"63036000000000000"}' --accountId funding_account.testnet --amount 50000

# Create a new lockup with the vesting schedule.
near call lockup.nearnet create '{"owner_account_id":"lockup_owner.testnet","lockup_duration":"31536000000000000","vesting_schedule": { "VestingSchedule": {"start_timestamp": "1535760000000000000", "cliff_timestamp": "1567296000000000000", "end_timestamp": "1661990400000000000"}}}' --accountId funding_account.testnet --amount 50000 --gas 110000000000000

'''
'''--- lockup-factory/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/lockup_factory.wasm ./res/

'''
'''--- lockup-factory/rustfmt.toml ---
use_small_heuristics = "Max"
reorder_imports = true
edition = "2018"
# fn_args_density = "Compressed"
# overflow_delimited_expr = "true"

'''
'''--- lockup-factory/src/lib.rs ---
mod types;
mod utils;

pub use crate::types::*;
use crate::utils::*;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::{ValidAccountId, U128};
use near_sdk::serde::Serialize;
use near_sdk::{env, ext_contract, near_bindgen, AccountId, Balance, Promise};

/// There is no deposit balance attached.
const NO_DEPOSIT: Balance = 0;
const TRANSFERS_STARTED: u64 = 1602614338293769340; /* 13 October 2020 18:38:58.293 */

#[global_allocator]
static ALLOC: near_sdk::wee_alloc::WeeAlloc<'_> = near_sdk::wee_alloc::WeeAlloc::INIT;

const CODE: &[u8] = include_bytes!("../../lockup/res/lockup_contract.wasm");

pub mod gas {
    use near_sdk::Gas;

    /// The base amount of gas for a regular execution.
    const BASE: Gas = 25_000_000_000_000;

    /// The amount of Gas the contract will attach to the promise to create the lockup.
    pub const LOCKUP_NEW: Gas = BASE;

    /// The amount of Gas the contract will attach to the callback to itself.
    /// The base for the execution and the base for cash rollback.
    pub const CALLBACK: Gas = BASE;
}

const MIN_ATTACHED_BALANCE: Balance = 3_500_000_000_000_000_000_000_000;

/// External interface for the callbacks to self.
#[ext_contract(ext_self)]
pub trait ExtSelf {
    fn on_lockup_create(
        &mut self,
        lockup_account_id: AccountId,
        attached_deposit: U128,
        predecessor_account_id: AccountId,
    ) -> bool;
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct LockupFactory {
    whitelist_account_id: AccountId,
    foundation_account_id: AccountId,
}

#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct LockupArgs {
    owner_account_id: ValidAccountId,
    lockup_duration: WrappedDuration,
    lockup_timestamp: Option<WrappedTimestamp>,
    transfers_information: TransfersInformation,
    vesting_schedule: Option<VestingScheduleOrHash>,
    release_duration: Option<WrappedDuration>,
    staking_pool_whitelist_account_id: AccountId,
    foundation_account_id: Option<AccountId>,
}

impl Default for LockupFactory {
    fn default() -> Self {
        env::panic(b"LockupFactory should be initialized before usage")
    }
}

#[near_bindgen]
impl LockupFactory {
    #[init]
    pub fn new(
        whitelist_account_id: ValidAccountId,
        foundation_account_id: ValidAccountId,
    ) -> Self {
        assert!(!env::state_exists(), "The contract is already initialized");
        assert!(
            env::current_account_id().len() <= 23,
            "The account ID of this contract can't be more than 23 characters"
        );

        Self {
            whitelist_account_id: whitelist_account_id.into(),
            foundation_account_id: foundation_account_id.into(),
        }
    }

    /// Returns the foundation account id.
    pub fn get_foundation_account_id(&self) -> AccountId {
        self.foundation_account_id.clone()
    }

    /// Returns the lockup master account id.
    pub fn get_lockup_master_account_id(&self) -> AccountId {
        env::current_account_id()
    }

    /// Returns minimum attached balance.
    pub fn get_min_attached_balance(&self) -> U128 {
        MIN_ATTACHED_BALANCE.into()
    }

    #[payable]
    pub fn create(
        &mut self,
        owner_account_id: ValidAccountId,
        lockup_duration: WrappedDuration,
        lockup_timestamp: Option<WrappedTimestamp>,
        vesting_schedule: Option<VestingScheduleOrHash>,
        release_duration: Option<WrappedDuration>,
    ) -> Promise {
        assert!(env::attached_deposit() >= MIN_ATTACHED_BALANCE, "Not enough attached deposit");

        let byte_slice = env::sha256(owner_account_id.as_ref().as_bytes());
        let lockup_account_id =
            format!("{}.{}", hex::encode(&byte_slice[..20]), env::current_account_id());

        let mut foundation_account: Option<AccountId> = None;
        if vesting_schedule.is_some() {
            foundation_account = Some(self.foundation_account_id.clone());
        };

        let transfers_enabled: WrappedTimestamp = TRANSFERS_STARTED.into();
        Promise::new(lockup_account_id.clone())
            .create_account()
            .deploy_contract(CODE.to_vec())
            .transfer(env::attached_deposit())
            .function_call(
                b"new".to_vec(),
                near_sdk::serde_json::to_vec(&LockupArgs {
                    owner_account_id,
                    lockup_duration,
                    lockup_timestamp,
                    transfers_information: TransfersInformation::TransfersEnabled {
                        transfers_timestamp: transfers_enabled,
                    },
                    vesting_schedule,
                    release_duration,
                    staking_pool_whitelist_account_id: self.whitelist_account_id.clone(),
                    foundation_account_id: foundation_account,
                })
                    .unwrap(),
                NO_DEPOSIT,
                gas::LOCKUP_NEW,
            )
            .then(ext_self::on_lockup_create(
                lockup_account_id,
                env::attached_deposit().into(),
                env::predecessor_account_id(),
                &env::current_account_id(),
                NO_DEPOSIT,
                gas::CALLBACK,
            ))
    }

    /// Callback after a lockup was created.
    /// Returns the promise if the lockup creation succeeded.
    /// Otherwise refunds the attached deposit and returns `false`.
    pub fn on_lockup_create(
        &mut self,
        lockup_account_id: AccountId,
        attached_deposit: U128,
        predecessor_account_id: AccountId,
    ) -> bool {
        assert_self();

        let lockup_account_created = is_promise_success();

        if lockup_account_created {
            env::log(
                format!("The lockup contract {} was successfully created.", lockup_account_id)
                    .as_bytes(),
            );
            true
        } else {
            env::log(
                format!(
                    "The lockup {} creation has failed. Returning attached deposit of {} to {}",
                    lockup_account_id, attached_deposit.0, predecessor_account_id
                )
                    .as_bytes(),
            );
            Promise::new(predecessor_account_id).transfer(attached_deposit.0);
            false
        }
    }
}

#[cfg(test)]
mod tests {
    mod test_utils;

    use super::*;
    use near_sdk::{testing_env, MockedBlockchain, PromiseResult};
    use test_utils::*;

    fn new_vesting_schedule(offset_in_days: u64) -> VestingSchedule {
        VestingSchedule {
            start_timestamp: to_ts(GENESIS_TIME_IN_DAYS - YEAR + offset_in_days).into(),
            cliff_timestamp: to_ts(GENESIS_TIME_IN_DAYS + offset_in_days).into(),
            end_timestamp: to_ts(GENESIS_TIME_IN_DAYS + YEAR * 3 + offset_in_days).into(),
        }
    }

    #[test]
    fn test_get_factory_vars() {
        let mut context = VMContextBuilder::new()
            .current_account_id(account_factory())
            .predecessor_account_id(account_near())
            .finish();
        testing_env!(context.clone());

        let contract = LockupFactory::new(
            whitelist_account_id(),
            foundation_account_id(),
        );

        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(contract.get_min_attached_balance().0, MIN_ATTACHED_BALANCE);
        assert_eq!(
            contract.get_foundation_account_id(),
            foundation_account_id().as_ref().to_string()
        );
        println!("{}", contract.get_lockup_master_account_id());
        assert_eq!(
            contract.get_lockup_master_account_id(),
            lockup_master_account_id().as_ref().to_string()
        );
    }

    #[test]
    fn test_create_lockup_success() {
        let mut context = VMContextBuilder::new()
            .current_account_id(account_factory())
            .predecessor_account_id(account_near())
            .finish();
        testing_env!(context.clone());

        let mut contract = LockupFactory::new(
            whitelist_account_id(),
            foundation_account_id(),
        );

        const LOCKUP_DURATION: u64 = 63036000000000000; /* 24 months */
        let lockup_duration: WrappedTimestamp = LOCKUP_DURATION.into();

        context.is_view = false;
        context.predecessor_account_id = String::from(account_tokens_owner());
        context.attached_deposit = ntoy(35);
        testing_env!(context.clone());
        contract.create(account_tokens_owner(), lockup_duration, None, None, None);

        context.predecessor_account_id = account_factory();
        context.attached_deposit = ntoy(0);
        testing_env_with_promise_results(context.clone(), PromiseResult::Successful(vec![]));
        println!("{}", lockup_account());
        contract.on_lockup_create(
            lockup_account(),
            ntoy(30).into(),
            String::from(account_tokens_owner()),
        );
    }

    #[test]
    fn test_create_lockup_with_vesting_success() {
        let mut context = VMContextBuilder::new()
            .current_account_id(account_factory())
            .predecessor_account_id(account_near())
            .finish();
        testing_env!(context.clone());

        let mut contract = LockupFactory::new(
            whitelist_account_id(),
            foundation_account_id(),
        );

        const LOCKUP_DURATION: u64 = 63036000000000000; /* 24 months */
        const LOCKUP_TIMESTAMP: u64 = 1661990400000000000; /* 1 September 2022 00:00:00 */
        let lockup_duration: WrappedTimestamp = LOCKUP_DURATION.into();
        let lockup_timestamp: WrappedTimestamp = LOCKUP_TIMESTAMP.into();

        let vesting_schedule = Some(new_vesting_schedule(10));

        let vesting_schedule = vesting_schedule.map(|vesting_schedule| {
            VestingScheduleOrHash::VestingHash(
                VestingScheduleWithSalt { vesting_schedule, salt: SALT.to_vec().into() }
                    .hash()
                    .into(),
            )
        });

        context.is_view = false;
        context.predecessor_account_id = String::from(account_tokens_owner());
        context.attached_deposit = ntoy(35);
        testing_env!(context.clone());
        contract.create(
            account_tokens_owner(),
            lockup_duration,
            Some(lockup_timestamp),
            vesting_schedule,
            None,
        );

        context.predecessor_account_id = account_factory();
        context.attached_deposit = ntoy(0);
        testing_env_with_promise_results(context.clone(), PromiseResult::Successful(vec![]));
        contract.on_lockup_create(
            lockup_account(),
            ntoy(30).into(),
            String::from(account_tokens_owner()),
        );
    }

    #[test]
    #[should_panic(expected = "Not enough attached deposit")]
    fn test_create_lockup_not_enough_deposit() {
        let mut context = VMContextBuilder::new()
            .current_account_id(account_factory())
            .predecessor_account_id(account_near())
            .finish();
        testing_env!(context.clone());

        let mut contract = LockupFactory::new(
            whitelist_account_id(),
            foundation_account_id(),
        );

        const LOCKUP_DURATION: u64 = 63036000000000000; /* 24 months */
        let lockup_duration: WrappedTimestamp = LOCKUP_DURATION.into();

        context.is_view = false;
        context.predecessor_account_id = String::from(account_tokens_owner());
        context.attached_deposit = ntoy(1); /* Storage reduced to 3.5 NEAR */
        testing_env!(context.clone());
        contract.create(account_tokens_owner(), lockup_duration, None, None, None);
    }

    #[test]
    fn test_create_lockup_rollback() {
        let mut context = VMContextBuilder::new()
            .current_account_id(account_factory())
            .predecessor_account_id(account_near())
            .finish();
        testing_env!(context.clone());

        let mut contract = LockupFactory::new(
            whitelist_account_id(),
            foundation_account_id(),
        );

        const LOCKUP_DURATION: u64 = 63036000000000000; /* 24 months */
        let lockup_duration: WrappedTimestamp = LOCKUP_DURATION.into();

        context.is_view = false;
        context.predecessor_account_id = String::from(account_tokens_owner());
        context.attached_deposit = ntoy(35);
        testing_env!(context.clone());
        contract.create(account_tokens_owner(), lockup_duration, None, None, None);

        context.predecessor_account_id = account_factory();
        context.attached_deposit = ntoy(0);
        context.account_balance += ntoy(35);
        testing_env_with_promise_results(context.clone(), PromiseResult::Failed);
        let res = contract.on_lockup_create(
            lockup_account(),
            ntoy(35).into(),
            String::from(account_tokens_owner()),
        );

        match res {
            true => panic!("Unexpected result, should return false"),
            false => assert!(true),
        };
    }
}

'''
'''--- lockup-factory/src/tests/test_utils.rs ---
use near_sdk::json_types::ValidAccountId;
use near_sdk::{env, Balance, BlockHeight, EpochHeight};
use near_sdk::{AccountId, MockedBlockchain, PromiseResult, VMContext};
use std::convert::TryInto;

pub const GENESIS_TIME_IN_DAYS: u64 = 500;
pub const YEAR: u64 = 365;
pub const SALT: [u8; 3] = [1, 2, 3];

pub fn to_ts(num_days: u64) -> u64 {
    // 2018-08-01 UTC in nanoseconds
    1533081600_000_000_000 + to_nanos(num_days)
}

pub fn to_nanos(num_days: u64) -> u64 {
    num_days * 86400_000_000_000
}

pub fn account_near() -> AccountId {
    "nearnet".to_string()
}

pub fn account_factory() -> AccountId {
    "lockup.nearnet".to_string()
}

pub fn lockup_master_account_id() -> ValidAccountId {
    "lockup.nearnet".try_into().unwrap()
}

pub fn whitelist_account_id() -> ValidAccountId {
    "whitelist.nearnet".try_into().unwrap()
}

pub fn foundation_account_id() -> ValidAccountId {
    "nearnet".try_into().unwrap()
}

pub fn account_tokens_owner() -> ValidAccountId {
    "tokenowner.testnet".try_into().unwrap()
}

pub fn ntoy(near_amount: Balance) -> Balance {
    near_amount * 10u128.pow(24)
}

pub fn lockup_account() -> AccountId {
    let byte_slice = env::sha256(account_tokens_owner().as_ref().as_bytes());
    let lockup_account_id = format!(
        "{}.{}",
        hex::encode(&byte_slice[..20]),
        &lockup_master_account_id().as_ref().to_string()
    );
    return lockup_account_id;
}

pub fn testing_env_with_promise_results(context: VMContext, promise_result: PromiseResult) {
    let storage = near_sdk::env::take_blockchain_interface()
        .unwrap()
        .as_mut_mocked_blockchain()
        .unwrap()
        .take_storage();

    near_sdk::env::set_blockchain_interface(Box::new(MockedBlockchain::new(
        context,
        Default::default(),
        Default::default(),
        vec![promise_result],
        storage,
        Default::default(),
        None
    )));
}

pub struct VMContextBuilder {
    context: VMContext,
}

impl VMContextBuilder {
    pub fn new() -> Self {
        Self {
            context: VMContext {
                current_account_id: "".to_string(),
                signer_account_id: "".to_string(),
                signer_account_pk: vec![0, 1, 2],
                predecessor_account_id: "".to_string(),
                input: vec![],
                epoch_height: 0,
                block_index: 0,
                block_timestamp: 0,
                account_balance: 0,
                account_locked_balance: 0,
                storage_usage: 10u64.pow(6),
                attached_deposit: 0,
                prepaid_gas: 10u64.pow(18),
                random_seed: vec![0, 1, 2],
                is_view: false,
                output_data_receivers: vec![],
            },
        }
    }

    #[allow(dead_code)]
    pub fn current_account_id(mut self, account_id: AccountId) -> Self {
        self.context.current_account_id = account_id;
        self
    }

    #[allow(dead_code)]
    pub fn signer_account_id(mut self, account_id: AccountId) -> Self {
        self.context.signer_account_id = account_id;
        self
    }

    #[allow(dead_code)]
    pub fn predecessor_account_id(mut self, account_id: AccountId) -> Self {
        self.context.predecessor_account_id = account_id;
        self
    }

    #[allow(dead_code)]
    pub fn block_index(mut self, block_index: BlockHeight) -> Self {
        self.context.block_index = block_index;
        self
    }

    #[allow(dead_code)]
    pub fn epoch_height(mut self, epoch_height: EpochHeight) -> Self {
        self.context.epoch_height = epoch_height;
        self
    }

    #[allow(dead_code)]
    pub fn attached_deposit(mut self, amount: Balance) -> Self {
        self.context.attached_deposit = amount;
        self
    }

    #[allow(dead_code)]
    pub fn account_balance(mut self, amount: Balance) -> Self {
        self.context.account_balance = amount;
        self
    }

    #[allow(dead_code)]
    pub fn account_locked_balance(mut self, amount: Balance) -> Self {
        self.context.account_locked_balance = amount;
        self
    }

    pub fn finish(self) -> VMContext {
        self.context
    }
}

'''
'''--- lockup-factory/src/types.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::{Base64VecU8, U128, U64};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{env, AccountId, Balance};

/// Raw type for duration in nanoseconds
pub type Duration = u64;
/// Raw type for timestamp in nanoseconds
pub type Timestamp = u64;

/// Duration in nanosecond wrapped into a struct for JSON serialization as a string.
pub type WrappedDuration = U64;

/// Timestamp in nanosecond wrapped into a struct for JSON serialization as a string.
pub type WrappedTimestamp = U64;
/// Duration in nanosecond wrapped into a struct for JSON serialization as a string.
pub type WrappedBalance = U128;

/// Hash of Vesting schedule.
pub type Hash = Vec<u8>;

/// Contains information about token lockups.
#[derive(BorshDeserialize, BorshSerialize)]
pub struct LockupInformation {
    /// The amount in yocto-NEAR tokens locked for this account.
    pub lockup_amount: Balance,
    /// The amount of tokens that were withdrawn by NEAR foundation due to early termination
    /// of vesting.
    /// This amount has to be accounted separately from the lockup_amount to make sure
    /// linear release is not being affected.
    pub termination_withdrawn_tokens: Balance,
    /// The lockup duration in nanoseconds from the moment when transfers are enabled to unlock the
    /// lockup amount of tokens.
    pub lockup_duration: Duration,
    /// If present, the duration when the full lockup amount will be available. The tokens are
    /// linearly released from the moment transfers are enabled.
    pub release_duration: Option<Duration>,
    /// The optional absolute lockup timestamp in nanoseconds which locks the tokens until this
    /// timestamp passes.
    pub lockup_timestamp: Option<Timestamp>,
    /// The information to indicate when the lockup period starts.
    pub transfers_information: TransfersInformation,
}

/// Contains information about the transfers. Whether transfers are enabled or disabled.
#[derive(BorshDeserialize, BorshSerialize, Deserialize, Serialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub enum TransfersInformation {
    /// The timestamp when the transfers were enabled. The lockup period starts at this timestamp.
    TransfersEnabled { transfers_timestamp: WrappedTimestamp },
    /// The account ID of the transfers poll contract, to check if the transfers are enabled.
    /// The lockup period will start when the transfer voted to be enabled.
    /// At the launch of the network transfers are disabled for all lockup contracts, once transfers
    /// are enabled, they can't be disabled and don't need to be checked again.
    TransfersDisabled { transfer_poll_account_id: AccountId },
}

/// Describes the status of transactions with the staking pool contract or terminated unvesting
/// amount withdrawal.
#[derive(BorshDeserialize, BorshSerialize, Deserialize, Serialize, PartialEq)]
#[serde(crate = "near_sdk::serde")]
pub enum TransactionStatus {
    /// There are no transactions in progress.
    Idle,
    /// There is a transaction in progress.
    Busy,
}

/// Contains information about current stake and delegation.
#[derive(BorshDeserialize, BorshSerialize)]
pub struct StakingInformation {
    /// The Account ID of the staking pool contract.
    pub staking_pool_account_id: AccountId,

    /// Contains status whether there is a transaction in progress.
    pub status: TransactionStatus,

    /// The amount of tokens that were deposited from this account to the staking pool.
    /// NOTE: The unstaked amount on the staking pool might be higher due to staking rewards.
    pub deposit_amount: WrappedBalance,
}

/// Contains information about vesting schedule.
#[derive(BorshDeserialize, BorshSerialize, Deserialize, Serialize, Clone, PartialEq, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct VestingSchedule {
    /// The timestamp in nanosecond when the vesting starts. E.g. the start date of employment.
    pub start_timestamp: WrappedTimestamp,
    /// The timestamp in nanosecond when the first part of lockup tokens becomes vested.
    /// The remaining tokens will vest continuously until they are fully vested.
    /// Example: a 1 year of employment at which moment the 1/4 of tokens become vested.
    pub cliff_timestamp: WrappedTimestamp,
    /// The timestamp in nanosecond when the vesting ends.
    pub end_timestamp: WrappedTimestamp,
}

impl VestingSchedule {
    pub fn assert_valid(&self) {
        assert!(
            self.start_timestamp.0 <= self.cliff_timestamp.0,
            "Cliff timestamp can't be earlier than vesting start timestamp"
        );
        assert!(
            self.cliff_timestamp.0 <= self.end_timestamp.0,
            "Cliff timestamp can't be later than vesting end timestamp"
        );
        assert!(
            self.start_timestamp.0 < self.end_timestamp.0,
            "The total vesting time should be positive"
        );
    }
}

/// Initialization argument type to define the vesting schedule
#[derive(Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub enum VestingScheduleOrHash {
    /// The vesting schedule is private and this is a hash of (vesting_schedule, salt).
    /// In JSON, the hash has to be encoded with base64 to a string.
    VestingHash(Base64VecU8),
    /// The vesting schedule (public)
    VestingSchedule(VestingSchedule),
}

/// Contains information about vesting that contains vesting schedule and termination information.
#[derive(Serialize, BorshDeserialize, BorshSerialize, PartialEq, Clone, Debug)]
#[serde(crate = "near_sdk::serde")]
pub enum VestingInformation {
    None,
    /// Vesting schedule is hashed for privacy and only will be revealed if the NEAR foundation
    /// has to terminate vesting.
    /// The contract assume the vesting schedule doesn't affect lockup release and duration, because
    /// the vesting started before transfers were enabled and the duration is shorter or the same.
    VestingHash(Base64VecU8),
    /// Explicit vesting schedule.
    VestingSchedule(VestingSchedule),
    /// The information about the early termination of the vesting schedule.
    /// It means the termination of the vesting is currently in progress.
    /// Once the unvested amount is transferred out, `VestingInformation` is removed.
    Terminating(TerminationInformation),
}

/// Describes the status of transactions with the staking pool contract or terminated unvesting
/// amount withdrawal.
#[derive(
    BorshDeserialize, BorshSerialize, Deserialize, Serialize, PartialEq, Copy, Clone, Debug,
)]
#[serde(crate = "near_sdk::serde")]
pub enum TerminationStatus {
    /// Initial stage of the termination in case there are deficit on the account.
    VestingTerminatedWithDeficit,
    /// A transaction to unstake everything is in progress.
    UnstakingInProgress,
    /// The transaction to unstake everything from the staking pool has completed.
    EverythingUnstaked,
    /// A transaction to withdraw everything from the staking pool is in progress.
    WithdrawingFromStakingPoolInProgress,
    /// Everything is withdrawn from the staking pool. Ready to withdraw out of the account.
    ReadyToWithdraw,
    /// A transaction to withdraw tokens from the account is in progress.
    WithdrawingFromAccountInProgress,
}

/// Contains information about early termination of the vesting schedule.
#[derive(BorshDeserialize, BorshSerialize, Deserialize, Serialize, PartialEq, Clone, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct TerminationInformation {
    /// The amount of tokens that are unvested and has to be transferred back to NEAR Foundation.
    /// These tokens are effectively locked and can't be transferred out and can't be restaked.
    pub unvested_amount: WrappedBalance,

    /// The status of the withdrawal. When the unvested amount is in progress of withdrawal the
    /// status will be marked as busy, to avoid withdrawing the funds twice.
    pub status: TerminationStatus,
}

/// The result of the transfer poll.
/// Contains The timestamp when the proposal was voted in.
pub type PollResult = Option<WrappedTimestamp>;

/// Contains a vesting schedule with a salt.
#[derive(BorshSerialize, Deserialize, Serialize, Clone, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct VestingScheduleWithSalt {
    /// The vesting schedule
    pub vesting_schedule: VestingSchedule,
    /// Salt to make the hash unique
    pub salt: Base64VecU8,
}

impl VestingScheduleWithSalt {
    pub fn hash(&self) -> Hash {
        env::sha256(&self.try_to_vec().expect("Failed to serialize"))
    }
}

'''
'''--- lockup-factory/src/utils.rs ---
use near_sdk::{env, PromiseResult};

pub fn assert_self() {
    assert_eq!(env::predecessor_account_id(), env::current_account_id());
}

pub fn is_promise_success() -> bool {
    assert_eq!(env::promise_results_count(), 1, "Contract expected a result on the callback");
    match env::promise_result(0) {
        PromiseResult::Successful(_) => true,
        _ => false,
    }
}

'''
'''--- lockup/Cargo.toml ---
[package]
name = "lockup-contract"
version = "3.1.0"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"
uint = { version = "0.8.3", default-features = false }

[dev-dependencies]
near-sdk-sim = "3.2.0"
quickcheck = "0.9"
quickcheck_macros = "0.9"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "s"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- lockup/README.md ---
# Lockup / Vesting contract

## Overview

This contract acts as an escrow that locks and holds an owner's tokens for a lockup period.
The contract consists of lockup and vesting processes that go simultaneously.
A high-level overview could be found [in NEAR documentation](https://docs.near.org/docs/tokens/lockup).

A lockup period starts from the specified timestamp and lasts for the specified duration.
Tokens will be unlocked linearly.

Vesting is an additional mechanism. It also locks the tokens, and it allows to configure 2 more options:
1. Ability to terminate tokens vesting and refund non-vested tokens back.
2. Cliff vesting period.

The owner can add a full access key to the account if all conditions are met:
- No transaction is in progress;
- Vesting and lockup processes finished;
- The termination process is ended (if applicable). If there’s a termination process started, it has to finish;
- [Transfers are enabled](https://near.org/blog/near-mainnet-is-now-community-operated/) ([Phase II launch on MainNet enabled transfers](https://near.org/blog/near-mainnet-phase-2-unrestricted-decentralized/)).

This will allow the owner to turn this contract account into a regular account, claim the remaining tokens, and remove the contract or delete the account.

### Lockup schedule

Lockup is a mechanism of linear unlocking of tokens that could not be terminated.
It is described by the following fields:
- `lockup_timestamp` - The moment when tokens start linearly unlocking;
- `lockup_duration` - [deprecated] Alternative way to set the moment when the tokens become unlock.
  The duration from [the moment transfers were enabled](https://near.org/blog/near-mainnet-phase-2-unrestricted-decentralized/) to the moment when linear unlocking begins;
- `release_duration` - The length of the unlocking schedule during which tokens are linearly unlocked.
  By the end of this duration all tokens are unlocked.
  `finish_timestamp = lockup_timestamp + release_duration`.

If `lockup_timestamp` and `lockup_duration` are not specified, the lockup starts from the timestamp from [`transfers_information`](https://github.com/near/core-contracts/blob/master/lockup/src/lib.rs#L187) field.
It's usually the moment when [transfers were enabled by voting](https://near.org/blog/near-mainnet-phase-2-unrestricted-decentralized/) in the system: 2020-10-13, 18:38:58 UTC or `1602614338293769340` nanoseconds unix time.

### Vesting schedule

The contract can contain a vesting schedule and serve as a vesting agreement between the foundation and an employee (owner of the contract).
The foundation is set at the moment of initializing the contract by the `foundation_account_id` field.

A vesting schedule is described by three timestamps in nanoseconds:
- `start_timestamp` - When the vesting starts. E.g. the start date of employment;
- `cliff_timestamp` - When the first part of lockup tokens becomes vested.
  The remaining tokens will vest continuously until they are fully vested.
  Assume we have a 4-year contract with a 1-year cliff.
  In the first year, nothing is vested, then 25% is vested, then we have linear vesting till the end of the contract.
  25% is the number calculated by the formula:
  ```
  cliff_tokens_percentage = (cliff_timestamp - start_timestamp) / (end_timestamp - start_timestamp)
  ```
- `end_timestamp` -  When the vesting ends.

Once the `cliff_timestamp` passed, the tokens are vested on a pro-rata basis from the `start_timestamp` to the `end_timestamp`.

### Combining lockup and vesting

The contract could have both lockup and vesting schedules.

The tokens start to become liquid at the timestamp:
```
liquidity_timestamp = max(max(transfers_enabled_timestamp + lockup_duration, lockup_timestamp), cliff_timestamp)
```

The current amount of non-liquid tokens are calculated as the maximum between lockup and vesting logic.
If at least one mechanism said the tokens are locked, then they are still locked.

The contract could also have only one of these mechanisms.
When initializing, it's possible to pass empty vesting information, then we use a lockup schedule.
It's also possible not to provide `release_duration`, it means that we use a vesting schedule.
If neither of the mechanisms is initialized, the tokens will become liquid after transfers enabled moment ([`transfers_information`](https://github.com/near/core-contracts/blob/master/lockup/src/lib.rs#L187) field).

### Staking

NEAR is the proof of stake network. The owner of the lockup contract might hold a large percentage of the network tokens.
The owner may want to stake these tokens (including locked/unvested tokens) to help secure the network and also earn staking rewards that are distributed to the network validator.
This contract doesn't allow to directly stake from this account, so the owner can delegate tokens to a [staking pool contract](https://github.com/near/initial-contracts/tree/master/staking-pool).

The owner can choose the staking pool for delegating tokens.
The staking pool contract and the account have to be approved by the whitelisting contract to prevent tokens from being lost, locked, or stolen.
Whitelisting contract is set at the moment of initializing the Lockup contract by [`staking_pool_whitelist_account_id`](https://github.com/near/core-contracts/blob/master/lockup/src/lib.rs#L190) field.
Once the staking pool holds tokens, the owner of the staking pool can use them to vote on the network governance issues, such as enabling transfers.
So the owner needs to pick the staking pool that fits the best.

### Early Vesting Termination

In the case of the vesting schedule, the contract supports the ability for the foundation to terminate vesting at any point before it completes.
If the vesting is terminated before the cliff all tokens are refunded to the foundation. Otherwise, the remaining unvested tokens are refunded.

In the event of termination, the vesting stops, and the remaining unvested tokens are locked until they are withdrawn by the foundation.
During termination, the owner can't issue any action towards the staking pool or issue transfers.
If the amount of tokens on the contract account is less than the remaining unvested balance, the foundation will try to unstake and withdraw everything from the staking pool.
Once the tokens are withdrawn from the staking pool, the foundation will proceed with withdrawing the unvested balance from the contract.
Once the unvested balance is withdrawn completely, the contract returns to the regular state, and the owner can stake and transfer again.

The amount withdrawn in the event of termination by the foundation may be lower than the initial contract amount.
It's because the contract has to maintain the minimum required balance to cover storage of the contract code and contract state.

### Guarantees

With the guarantees from the staking pool contracts, whitelist, and voting contract, the lockup contract provides the following guarantees:
- The owner can not lose tokens or block contract operations by using methods under the staking section.
- The owner can not prevent the foundation from withdrawing the unvested balance in case of termination.
- The owner can not withdraw tokens locked due to lockup period, disabled transfers, or vesting schedule.
- The owner can withdraw rewards from the staking pool before tokens are unlocked unless the vesting termination prevents it.
- The owner should be able to add a full access key to the account, once all tokens are vested, unlocked and transfers are enabled.

### Contributing

We use Docker to build the contract.
Configuration could be found [here](https://github.com/near/near-sdk-rs/tree/master/contract-builder).
Please make sure that Docker is given at least 4Gb of RAM.

### [Deprecated] Private vesting schedule

Since the vesting schedule usually starts at the date of employment it allows to de-anonymize the owner of the lockup contract.
To keep the identity private, the contract allows to hash the vesting schedule with some random salt and keep store the hash instead of the raw vesting schedule information.
In case the foundation has to terminate the vesting schedule, it will provide the raw vesting schedule and the salt, effectively revealing the vesting schedule.
The contract then will compare the hash with the internal hash and if they match proceed with the termination.

**NOTE**: The private vesting schedule can only be used if the lockup release period and the lockup duration are effectively shadowing the vesting duration.
Meaning that the lockup release ends later than the vesting release and the lockup duration ends after the vesting cliff.
Once the lockup schedule starts before the vesting schedule (e.g. employment starts after the transfers are enabled), the vesting schedule can't be kept private anymore.

## Interface

Here are some useful links to the documented codebase:
- [The initialization method](https://github.com/near/core-contracts/blob/master/lockup/src/lib.rs#L151-L190);
- [Basic types](https://github.com/near/core-contracts/blob/master/lockup/src/types.rs#L12);
- [Owner's methods](https://github.com/near/core-contracts/blob/master/lockup/src/owner.rs);
- [Foundation methods](https://github.com/near/core-contracts/blob/master/lockup/src/foundation.rs);
- [View methods](https://github.com/near/core-contracts/blob/master/lockup/src/getters.rs).

## API examples

### Initialization

Initialize contract, assuming it's called from `near` account.
The lockup contract account ID is `lockup1`.
The owner account ID is `owner1`.
Lockup Duration is 365 days, starting from `2018-09-01` (`lockup_timestamp` and `release_duration` args).
Release duration is 4 years (or 1461 days including leap year).
Transfers are enabled `2020-10-13`.
Vesting is 4 years starting from `2018-09-01` to `2022-09-01` Pacific time.
Staking pool whitelist contract is at `staking-pool-whitelist`.
The foundation account ID that can terminate vesting is `near`.

Arguments in JSON format

```json
{
    "owner_account_id": "owner1",
    "lockup_duration": "0",
    "lockup_timestamp": "1535760000000000000",
    "release_duration": "126230400000000000",
    "transfers_information": {
        "TransfersEnabled": {
            "transfers_timestamp": "1602614338293769340"
        }
    },
    "vesting_schedule": {
        "VestingSchedule": {
            "start_timestamp": "1535760000000000000",
            "cliff_timestamp": "1567296000000000000",
            "end_timestamp": "1661990400000000000"
        }
    },
    "staking_pool_whitelist_account_id": "staking-pool-whitelist",
    "foundation_account_id": "near"
}
```

Command

```bash
near call lockup1 new '{"owner_account_id": "owner1", "lockup_duration": "0", "lockup_timestamp": "1535760000000000000", "release_duration": "126230400000000000", "transfers_information": {"TransfersEnabled": {"transfers_timestamp": "1602614338293769340"}}, "vesting_schedule": {"VestingSchedule": {"start_timestamp": "1535760000000000000", "cliff_timestamp": "1567296000000000000", "end_timestamp": "1661990400000000000"}}, "staking_pool_whitelist_account_id": "staking-pool-whitelist", "foundation_account_id": "near"}' --accountId=near --gas=25000000000000
```

If you need to use only lockup logic, change `vesting_schedule` parameter:
```
"vesting_schedule": None
```

If you need to use only vesting logic, change these parameters as follows:
```
"lockup_duration": 0,
"lockup_timestamp": None,
"release_duration": None
```

### Staking flow

#### Select staking pool

```bash
near call lockup1 select_staking_pool '{"staking_pool_account_id": "staking_pool_pro"}' --accountId=owner1 --gas=75000000000000
```

#### Deposit and stake to the staking pool

Deposit and stake `1000` NEAR tokens.

```bash
near call lockup1 deposit_and_stake '{"amount": "1000000000000000000000000000"}' --accountId=owner1 --gas=125000000000000
```

#### Refresh the current total balance on the staking pool

When the owner has accumulated some rewards on the staking pool, the contract doesn't let the owner withdraw them yet.
It's because the contract doesn't know about the accumulated rewards.
To get the new total balance for the contract, the owner has to call `refresh_staking_pool_balance`.

```bash
near call lockup1 refresh_staking_pool_balance '{}' --accountId=owner1 --gas=75000000000000
```

#### Checking owner's balance

If the owner has accumulated 10 NEAR in the rewards, after refreshing the staking pool balance, the owner should see
the local balance to increase as well.

```bash
near view lockup1 get_owners_balance '{}'
```

#### Unstake from the staking pool

Let's say the owner checked staked balance by calling the view method on the staking pool directly and decided to unstake everything.

```bash
near call lockup1 unstake_all '{}' --accountId=owner1 --gas=125000000000000
```

#### Withdraw from the staking pool

Wait for 4 epochs (about 48 hours) and withdraw all NEAR tokens from the staking pool.

```bash
near call lockup1 withdraw_all_from_staking_pool '{}' --accountId=owner1 --gas=175000000000000
```

#### Check transfers vote

```bash
near call lockup1 check_transfers_vote '{}' --accountId=owner1 --gas=75000000000000
```

Let's assume transfers are enabled now.

#### Check liquid balance and transfer 10 NEAR

```bash
near view lockup1 get_liquid_owners_balance '{}'
```

Transfer 10 NEAR to `owner-sub-account`.

```bash
near call lockup1 transfer '{"amount": "10000000000000000000000000", "receiver_id": "owner-sub-account"}' --accountId=owner1 --gas=50000000000000
```

#### Adding full access key

Once everything is unlocked and vested, the owner can add a full access key to the lockup account.
This allows the withdrawal of remaining tokens locked due to contract storage.
The owner first should generate a new key-pair (private and public keys).
Then the owner should pass the public key from this key-pair.

```bash
near call lockup1 add_full_access_key '{"new_public_key": "CE3QAXyVLeScmY9YeEyR3Tw9yXfjBPzFLzroTranYtVb"}' --accountId=owner1 --gas=50000000000000
```

Now the owner can delete this account and claim all tokens in a single operation.
WARNING: This should only be done if there are no tokens delegated to a staking pool.
Otherwise, those tokens will be lost.

This command will delete `lockup1` and transfer all remaining tokens from the lockup account to `owner1`.

```bash
near delete lockup1 owner1
```

### Vesting termination by Foundation

#### Initiate termination

To initiate termination the Foundation has to issue the following command:

```bash
near call lockup1 terminate_vesting '' --accountId=near --gas=25000000000000
```

This will block the account until the termination process is completed.

If the vesting schedule was private, the Foundation has to pass the vesting schedule, and the salt, to reveal it:

```bash
near call lockup1 terminate_vesting '"vesting_schedule_with_salt": {"vesting_schedule": {"start_timestamp": "1535760000000000000", "cliff_timestamp": "1567296000000000000", "end_timestamp": "1661990400000000000"}, salt: "cmVhbGx5X2xvbmdfYW5kX3Zlcnlfc2VjcmV0X2hhc2g="}' --accountId=near --gas=25000000000000
```

#### Monitoring status

To check the current status of the termination process, the Foundation and the owner can call:

```bash
near view lockup1 get_termination_status '{}'
```

#### Withdrawing deficit from the staking pool

If the owner staked with some staking pool and the unvested amount is larger than the current liquid balance, then it creates the deficit (otherwise the Foundation can proceed with withdrawal).

The current termination status should be `VestingTerminatedWithDeficit`.

The Foundation needs to first unstake tokens in the staking pool.
Then, once tokens become liquid, the Foundation withdraws them from the staking pool to the contract.
This is done by calling `termination_prepare_to_withdraw`.

```bash
near call lockup1 termination_prepare_to_withdraw '{}' --accountId=near --gas=175000000000000
```

The first invocation will unstake everything from the staking pool.
This should advance the termination status to `EverythingUnstaked`.
In 4 epochs, or about 48 hours, the Foundation can call the same command again:

```bash
near call lockup1 termination_prepare_to_withdraw '{}' --accountId=near --gas=175000000000000
```

If everything went okay, the status should be advanced to `ReadyToWithdraw`.

### Withdrawing from the account

Once the termination status is `ReadyToWithdraw`, the Foundation can proceed with withdrawing the unvested balance.

```bash
near call lockup1 termination_withdraw '{"receiver_id": "near"}' --accountId=near --gas=75000000000000
```

In case of successful withdrawal, the unvested balance will become `0` and the owner can use this contract again.

## Change Log

### `3.1.0`

- Reduced minimum required balance for the lockups from 35 NEAR to 3.5 NEAR;
- Improved the documentation.

### `3.0.0`

- Release duration now starts from the moment the tokens are unlocked.
  The tokens are unlocked at the following timestamp `max(transfers_enabled_timestamp + lockup_duration, lockup_timestamp)`.
  NOTE: If the `lockup_timestamp` is not specified, the tokens are unlocked at `transfers_enabled_timestamp + lockup_duration`.

### `2.0.0`

- Changed `vesting_schedule` initialization argument to allow it to hide the vesting schedule behind a hash to keep it private.
- Added view method `get_vesting_information` to view internal vesting information.

### `1.0.0`

- Make `release_duration` independent from the `vesting_schedule`. They are not allowed to be used simultaneously.
- Internal. Remove some JSON serialization on inner structures.
- Fix a bug with the prepaid gas exceeded during the foundation callback by increasing base gas.
- Include the minimum amount of gas needed for every call.
- Add new helper methods for the owner for staking.
  - `deposit_and_stake`, `unstake_all`, `withdraw_all_from_staking_pool`
- Add a new view method to `get_balance` of the account, that includes all tokens on this account and all tokens deposited to a staking pool.
- Cover foundation termination flow with the integration tests.
- Cover release schedule flow with integration tests.
- Updated `near-sdk` to `2.0.0`

### `0.3.0`

- Introduced optional release duration
- Introduced optional absolute lockup timestamp.
- Updated `init` arguments
  - Added optional absolute `lockup_timestamp`.
  - Renamed `lockup_start_information` to `transfers_information`. Also renamed internal timestamp to `transfers_timestamp`.
  - Added optional `release_duration` to linearly release tokens.

### `0.2.0`

- Replaced owner's access keys with the owner's account. The access is now controlled through the predecessor account ID similar to NEAR foundation access.
  This allows being more flexible with the account access including multi-sig implementation.
- The lockup contract account should not have any access keys until the account is fully vested and unlocked.
  Only then the owner can add the full access key.
- Removed methods for adding and removing staking/main access keys.
- Added a view method to get the account ID of the owner.

'''
'''--- lockup/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/lockup_contract.wasm res/

'''
'''--- lockup/src/foundation.rs ---
use near_sdk::{near_bindgen, AccountId, Promise};

use crate::*;

#[near_bindgen]
impl LockupContract {
    /// FOUNDATION'S METHOD
    ///
    /// Requires 25 TGas (1 * BASE_GAS)
    ///
    /// Terminates vesting schedule and locks the remaining unvested amount.
    /// If the lockup contract was initialized with the private vesting schedule, then
    /// this method expects to receive a `VestingScheduleWithSalt` to reveal the vesting schedule,
    /// otherwise it expects `None`.
    pub fn terminate_vesting(
        &mut self,
        vesting_schedule_with_salt: Option<VestingScheduleWithSalt>,
    ) {
        self.assert_called_by_foundation();
        let vesting_schedule = self.assert_vesting(vesting_schedule_with_salt);
        let unvested_amount = self.get_unvested_amount(vesting_schedule);
        assert!(unvested_amount.0 > 0, "The account is fully vested");

        env::log(
            format!(
                "Terminating vesting. The remaining unvested balance is {}",
                unvested_amount.0
            )
            .as_bytes(),
        );

        let deficit = unvested_amount
            .0
            .saturating_sub(self.get_account_balance().0);
        // If there is deficit of liquid balance and also there is a staking pool selected, then the
        // contract will try to withdraw everything from this staking pool to cover deficit.
        let status = if deficit > 0 && self.staking_information.is_some() {
            TerminationStatus::VestingTerminatedWithDeficit
        } else {
            TerminationStatus::ReadyToWithdraw
        };

        self.vesting_information = VestingInformation::Terminating(TerminationInformation {
            unvested_amount,
            status,
        });
    }

    /// FOUNDATION'S METHOD
    ///
    /// Requires 175 TGas (7 * BASE_GAS)
    ///
    /// When the vesting is terminated and there are deficit of the tokens on the account, the
    /// deficit amount of tokens has to be unstaked and withdrawn from the staking pool.
    /// Should be invoked twice:
    /// 1. First, to unstake everything from the staking pool;
    /// 2. Second, after 4 epochs (48 hours) to prepare to withdraw.
    pub fn termination_prepare_to_withdraw(&mut self) -> Promise {
        self.assert_called_by_foundation();
        self.assert_staking_pool_is_idle();

        let status = self.get_termination_status();

        match status {
            None => {
                env::panic(b"There is no termination in progress");
            }
            Some(TerminationStatus::UnstakingInProgress)
            | Some(TerminationStatus::WithdrawingFromStakingPoolInProgress)
            | Some(TerminationStatus::WithdrawingFromAccountInProgress) => {
                env::panic(b"Another transaction is already in progress.");
            }
            Some(TerminationStatus::ReadyToWithdraw) => {
                env::panic(b"The account is ready to withdraw unvested balance.")
            }
            Some(TerminationStatus::VestingTerminatedWithDeficit) => {
                // Need to unstake
                self.set_termination_status(TerminationStatus::UnstakingInProgress);
                self.set_staking_pool_status(TransactionStatus::Busy);
                env::log(b"Termination Step: Going to unstake everything from the staking pool");

                ext_staking_pool::get_account_staked_balance(
                    env::current_account_id(),
                    &self
                        .staking_information
                        .as_ref()
                        .unwrap()
                        .staking_pool_account_id,
                    NO_DEPOSIT,
                    gas::staking_pool::GET_ACCOUNT_STAKED_BALANCE,
                )
                .then(
                    ext_self_foundation::on_get_account_staked_balance_to_unstake(
                        &env::current_account_id(),
                        NO_DEPOSIT,
                        gas::foundation_callbacks::ON_GET_ACCOUNT_STAKED_BALANCE_TO_UNSTAKE,
                    ),
                )
            }
            Some(TerminationStatus::EverythingUnstaked) => {
                // Need to withdraw everything
                self.set_termination_status(
                    TerminationStatus::WithdrawingFromStakingPoolInProgress,
                );
                self.set_staking_pool_status(TransactionStatus::Busy);
                env::log(b"Termination Step: Going to withdraw everything from the staking pool");

                ext_staking_pool::get_account_unstaked_balance(
                    env::current_account_id(),
                    &self
                        .staking_information
                        .as_ref()
                        .unwrap()
                        .staking_pool_account_id,
                    NO_DEPOSIT,
                    gas::staking_pool::GET_ACCOUNT_UNSTAKED_BALANCE,
                )
                .then(
                    ext_self_foundation::on_get_account_unstaked_balance_to_withdraw(
                        &env::current_account_id(),
                        NO_DEPOSIT,
                        gas::foundation_callbacks::ON_GET_ACCOUNT_UNSTAKED_BALANCE_TO_WITHDRAW,
                    ),
                )
            }
        }
    }

    /// FOUNDATION'S METHOD
    ///
    /// Requires 75 TGas (3 * BASE_GAS)
    ///
    /// Withdraws the unvested amount from the early termination of the vesting schedule.
    pub fn termination_withdraw(&mut self, receiver_id: AccountId) -> Promise {
        self.assert_called_by_foundation();
        assert!(
            env::is_valid_account_id(receiver_id.as_bytes()),
            "The receiver account ID is invalid"
        );
        assert_eq!(
            self.get_termination_status(),
            Some(TerminationStatus::ReadyToWithdraw),
            "Termination status is not ready to withdraw"
        );

        let amount = std::cmp::min(
            self.get_terminated_unvested_balance().0,
            self.get_account_balance().0,
        );
        assert!(
            amount > 0,
            "The account doesn't have enough liquid balance to withdraw any amount"
        );

        env::log(
            format!(
                "Termination Step: Withdrawing {} of terminated unvested balance to account @{}",
                amount, receiver_id
            )
            .as_bytes(),
        );

        self.set_termination_status(TerminationStatus::WithdrawingFromAccountInProgress);

        Promise::new(receiver_id.clone()).transfer(amount).then(
            ext_self_foundation::on_withdraw_unvested_amount(
                amount.into(),
                receiver_id,
                &env::current_account_id(),
                NO_DEPOSIT,
                gas::foundation_callbacks::ON_WITHDRAW_UNVESTED_AMOUNT,
            ),
        )
    }
}

'''
'''--- lockup/src/foundation_callbacks.rs ---
use crate::*;
use near_sdk::{near_bindgen, PromiseOrValue, assert_self, is_promise_success};
use std::convert::Into;

#[near_bindgen]
impl LockupContract {
    /// Called after the request to get the current staked balance to unstake everything for vesting
    /// schedule termination.
    pub fn on_get_account_staked_balance_to_unstake(
        &mut self,
        #[callback] staked_balance: WrappedBalance,
    ) -> PromiseOrValue<bool> {
        assert_self();
        if staked_balance.0 > 0 {
            // Need to unstake
            env::log(
                format!(
                    "Termination Step: Unstaking {} from the staking pool @{}",
                    staked_balance.0,
                    self.staking_information
                        .as_ref()
                        .unwrap()
                        .staking_pool_account_id
                )
                .as_bytes(),
            );

            ext_staking_pool::unstake(
                staked_balance,
                &self
                    .staking_information
                    .as_ref()
                    .unwrap()
                    .staking_pool_account_id,
                NO_DEPOSIT,
                gas::staking_pool::UNSTAKE,
            )
            .then(
                ext_self_foundation::on_staking_pool_unstake_for_termination(
                    staked_balance,
                    &env::current_account_id(),
                    NO_DEPOSIT,
                    gas::foundation_callbacks::ON_STAKING_POOL_UNSTAKE_FOR_TERMINATION,
                ),
            )
            .into()
        } else {
            env::log(b"Termination Step: Nothing to unstake. Moving to the next status.");
            self.set_staking_pool_status(TransactionStatus::Idle);
            self.set_termination_status(TerminationStatus::EverythingUnstaked);
            PromiseOrValue::Value(true)
        }
    }

    /// Called after the given amount is unstaked from the staking pool contract due to vesting
    /// termination.
    pub fn on_staking_pool_unstake_for_termination(&mut self, amount: WrappedBalance) -> bool {
        assert_self();

        let unstake_succeeded = is_promise_success();
        self.set_staking_pool_status(TransactionStatus::Idle);

        if unstake_succeeded {
            self.set_termination_status(TerminationStatus::EverythingUnstaked);
            env::log(
                format!(
                    "Termination Step: Unstaking of {} at @{} succeeded",
                    amount.0,
                    self.staking_information
                        .as_ref()
                        .unwrap()
                        .staking_pool_account_id
                )
                .as_bytes(),
            );
        } else {
            self.set_termination_status(TerminationStatus::VestingTerminatedWithDeficit);
            env::log(
                format!(
                    "Termination Step: Unstaking {} at @{} has failed",
                    amount.0,
                    self.staking_information
                        .as_ref()
                        .unwrap()
                        .staking_pool_account_id
                )
                .as_bytes(),
            );
        }
        unstake_succeeded
    }

    /// Called after the request to get the current unstaked balance to withdraw everything for
    /// vesting schedule termination.
    pub fn on_get_account_unstaked_balance_to_withdraw(
        &mut self,
        #[callback] unstaked_balance: WrappedBalance,
    ) -> PromiseOrValue<bool> {
        assert_self();
        if unstaked_balance.0 > 0 {
            // Need to withdraw
            env::log(
                format!(
                    "Termination Step: Withdrawing {} from the staking pool @{}",
                    unstaked_balance.0,
                    self.staking_information
                        .as_ref()
                        .unwrap()
                        .staking_pool_account_id
                )
                .as_bytes(),
            );

            ext_staking_pool::withdraw(
                unstaked_balance,
                &self
                    .staking_information
                    .as_ref()
                    .unwrap()
                    .staking_pool_account_id,
                NO_DEPOSIT,
                gas::staking_pool::WITHDRAW,
            )
            .then(
                ext_self_foundation::on_staking_pool_withdraw_for_termination(
                    unstaked_balance,
                    &env::current_account_id(),
                    NO_DEPOSIT,
                    gas::foundation_callbacks::ON_STAKING_POOL_WITHDRAW_FOR_TERMINATION,
                ),
            )
            .into()
        } else {
            env::log(b"Termination Step: Nothing to withdraw from the staking pool. Ready to withdraw from the account.");
            self.set_staking_pool_status(TransactionStatus::Idle);
            self.set_termination_status(TerminationStatus::ReadyToWithdraw);
            PromiseOrValue::Value(true)
        }
    }

    /// Called after the given amount is unstaked from the staking pool contract due to vesting
    /// termination.
    pub fn on_staking_pool_withdraw_for_termination(&mut self, amount: WrappedBalance) -> bool {
        assert_self();

        let withdraw_succeeded = is_promise_success();
        self.set_staking_pool_status(TransactionStatus::Idle);

        if withdraw_succeeded {
            self.set_termination_status(TerminationStatus::ReadyToWithdraw);
            {
                let staking_information = self.staking_information.as_mut().unwrap();
                // Due to staking rewards the deposit amount can become negative.
                staking_information.deposit_amount.0 = staking_information
                    .deposit_amount
                    .0
                    .saturating_sub(amount.0);
            }
            env::log(
                format!(
                    "Termination Step: The withdrawal of {} from @{} succeeded",
                    amount.0,
                    self.staking_information
                        .as_ref()
                        .unwrap()
                        .staking_pool_account_id
                )
                .as_bytes(),
            );
        } else {
            self.set_termination_status(TerminationStatus::EverythingUnstaked);
            env::log(
                format!(
                    "Termination Step: The withdrawal of {} from @{} failed",
                    amount.0,
                    self.staking_information
                        .as_ref()
                        .unwrap()
                        .staking_pool_account_id
                )
                .as_bytes(),
            );
        }
        withdraw_succeeded
    }

    /// Called after the foundation tried to withdraw the terminated unvested balance.
    pub fn on_withdraw_unvested_amount(
        &mut self,
        amount: WrappedBalance,
        receiver_id: AccountId,
    ) -> bool {
        assert_self();

        let withdraw_succeeded = is_promise_success();
        if withdraw_succeeded {
            env::log(
                format!(
                    "Termination Step: The withdrawal of the terminated unvested amount of {} to @{} succeeded.",
                    amount.0, receiver_id
                )
                    .as_bytes(),
            );
            // Decreasing lockup amount after withdrawal.
            self.lockup_information.termination_withdrawn_tokens += amount.0;
            let unvested_amount = self.get_terminated_unvested_balance().0;
            if unvested_amount > amount.0 {
                // There is still unvested balance remaining.
                let remaining_balance = unvested_amount - amount.0;
                self.vesting_information =
                    VestingInformation::Terminating(TerminationInformation {
                        unvested_amount: remaining_balance.into(),
                        status: TerminationStatus::ReadyToWithdraw,
                    });
                env::log(
                    format!(
                        "Termination Step: There is still terminated unvested balance of {} remaining to be withdrawn",
                        remaining_balance
                    )
                        .as_bytes(),
                );
                if self.get_account_balance().0 == 0 {
                    env::log(b"The withdrawal is completed: no more balance can be withdrawn in a future call");
                }
            } else {
                self.foundation_account_id = None;
                self.vesting_information = VestingInformation::None;
                env::log(b"Vesting schedule termination and withdrawal are completed");
            }
        } else {
            self.set_termination_status(TerminationStatus::ReadyToWithdraw);
            env::log(
                format!(
                    "Termination Step: The withdrawal of the terminated unvested amount of {} to @{} failed",
                    amount.0, receiver_id,
                )
                .as_bytes(),
            );
        }
        withdraw_succeeded
    }
}

'''
'''--- lockup/src/gas.rs ---
const BASE_GAS: u64 = 25_000_000_000_000;

pub mod whitelist {
    /// Gas attached to the promise to check whether the given staking pool Account ID is
    /// whitelisted.
    /// Requires BASE (no external calls).
    pub const IS_WHITELISTED: u64 = super::BASE_GAS;
}

pub mod staking_pool {
    /// Gas attached to deposit call on the staking pool contract.
    /// Requires BASE for local updates + BASE potentially restake.
    pub const DEPOSIT: u64 = super::BASE_GAS * 2;

    /// Gas attached to deposit call on the staking pool contract.
    /// Requires BASE for local updates + 2 * BASE for staking call.
    pub const DEPOSIT_AND_STAKE: u64 = super::BASE_GAS * 3;

    /// Gas attached to withdraw call on the staking pool contract.
    /// Requires BASE for execution + 2 * BASE for transferring amount to us and potentially restake.
    pub const WITHDRAW: u64 = super::BASE_GAS * 3;

    /// Gas attached to stake call on the staking pool contract.
    /// Requires BASE for execution + 2 * BASE for staking call.
    pub const STAKE: u64 = super::BASE_GAS * 3;

    /// Gas attached to unstake call on the staking pool contract.
    /// Requires BASE for execution + 2 * BASE for staking call.
    pub const UNSTAKE: u64 = super::BASE_GAS * 3;

    /// Gas attached to unstake all call on the staking pool contract.
    /// Requires BASE for execution + 2 * BASE for staking call.
    pub const UNSTAKE_ALL: u64 = super::BASE_GAS * 3;

    /// The amount of gas required to get the current staked balance of this account from the
    /// staking pool.
    /// Requires BASE for local processing.
    pub const GET_ACCOUNT_STAKED_BALANCE: u64 = super::BASE_GAS;

    /// The amount of gas required to get current unstaked balance of this account from the
    /// staking pool.
    /// Requires BASE for local processing.
    pub const GET_ACCOUNT_UNSTAKED_BALANCE: u64 = super::BASE_GAS;

    /// The amount of gas required to get the current total balance of this account from the
    /// staking pool.
    /// Requires BASE for local processing.
    pub const GET_ACCOUNT_TOTAL_BALANCE: u64 = super::BASE_GAS;
}

pub mod transfer_poll {
    /// Gas attached to the promise to check whether transfers were enabled on the transfer poll
    /// contract.
    /// Requires BASE (no external calls).
    pub const GET_RESULT: u64 = super::BASE_GAS;
}

pub mod owner_callbacks {
    /// Gas attached to the inner callback for processing whitelist check results.
    /// Requires BASE for local execution.
    pub const ON_WHITELIST_IS_WHITELISTED: u64 = super::BASE_GAS;

    /// Gas attached to the inner callback for processing result of the deposit call to the
    /// staking pool.
    /// Requires BASE for local updates.
    pub const ON_STAKING_POOL_DEPOSIT: u64 = super::BASE_GAS;

    /// Gas attached to the inner callback for processing result of the deposit and stake call to
    /// the staking pool.
    /// Requires BASE for local updates.
    pub const ON_STAKING_POOL_DEPOSIT_AND_STAKE: u64 = super::BASE_GAS;

    /// Gas attached to the inner callback for processing result of the withdraw call to the
    /// staking pool.
    /// Requires BASE for local updates.
    pub const ON_STAKING_POOL_WITHDRAW: u64 = super::BASE_GAS;

    /// Gas attached to the inner callback for processing result of the stake call to the
    /// staking pool.
    pub const ON_STAKING_POOL_STAKE: u64 = super::BASE_GAS;

    /// Gas attached to the inner callback for processing result of the unstake call to the
    /// staking pool.
    /// Requires BASE for local updates.
    pub const ON_STAKING_POOL_UNSTAKE: u64 = super::BASE_GAS;

    /// Gas attached to the inner callback for processing result of the unstake all call to the
    /// staking pool.
    /// Requires BASE for local updates.
    pub const ON_STAKING_POOL_UNSTAKE_ALL: u64 = super::BASE_GAS;

    /// Gas attached to the inner callback for processing result of the checking result for
    /// transfer voting call to the voting contract.
    /// Requires BASE for local updates.
    pub const ON_VOTING_GET_RESULT: u64 = super::BASE_GAS;

    /// Gas attached to the inner callback for processing result of the call to get the current
    /// total balance from the staking pool.
    /// Requires BASE for local updates.
    pub const ON_GET_ACCOUNT_TOTAL_BALANCE: u64 = super::BASE_GAS;

    /// Gas attached to the inner callback for processing result of the call to get the current
    /// unstaked balance from the staking pool.
    /// The callback might proceed with withdrawing this amount.
    /// Requires BASE for local updates + gas for withdraw + gas for another callback.
    pub const ON_GET_ACCOUNT_UNSTAKED_BALANCE_TO_WITHDRAW_BY_OWNER: u64 =
        super::BASE_GAS + super::staking_pool::WITHDRAW + ON_STAKING_POOL_WITHDRAW;
}

pub mod foundation_callbacks {
    /// Gas attached to the inner callback for processing result of the call to get the current
    /// staked balance from the staking pool.
    /// The callback might proceed with unstaking.
    /// Requires BASE for local updates + gas for unstake + gas for another callback.
    pub const ON_GET_ACCOUNT_STAKED_BALANCE_TO_UNSTAKE: u64 =
        super::BASE_GAS + super::staking_pool::UNSTAKE + ON_STAKING_POOL_UNSTAKE_FOR_TERMINATION;

    /// Gas attached to the inner callback for processing result of the unstake call  to the
    /// staking pool.
    /// Requires BASE for local updates.
    pub const ON_STAKING_POOL_UNSTAKE_FOR_TERMINATION: u64 = super::BASE_GAS;

    /// Gas attached to the inner callback for processing result of the call to get the current
    /// unstaked balance from the staking pool.
    /// The callback might proceed with withdrawing this amount.
    /// Requires BASE for local updates + gas for withdraw + gas for another callback.
    pub const ON_GET_ACCOUNT_UNSTAKED_BALANCE_TO_WITHDRAW: u64 =
        super::BASE_GAS + super::staking_pool::WITHDRAW + ON_STAKING_POOL_WITHDRAW_FOR_TERMINATION;

    /// Gas attached to the inner callback for processing result of the withdraw call to the
    /// staking pool.
    /// Requires BASE for local updates.
    pub const ON_STAKING_POOL_WITHDRAW_FOR_TERMINATION: u64 = super::BASE_GAS;

    /// Gas attached to the inner callback for processing result of the withdrawal of the
    /// terminated unvested balance.
    /// Requires BASE for local updates.
    pub const ON_WITHDRAW_UNVESTED_AMOUNT: u64 = super::BASE_GAS;
}

'''
'''--- lockup/src/getters.rs ---
use near_sdk::json_types::U128;
use near_sdk::near_bindgen;

use crate::*;

#[near_bindgen]
impl LockupContract {
    /// Returns the account ID of the owner.
    pub fn get_owner_account_id(&self) -> AccountId {
        self.owner_account_id.clone()
    }

    /// Returns the account ID of the selected staking pool.
    pub fn get_staking_pool_account_id(&self) -> Option<AccountId> {
        self.staking_information
            .as_ref()
            .map(|info| info.staking_pool_account_id.clone())
    }

    /// Returns the amount of tokens that were deposited to the staking pool.
    /// NOTE: The actual balance can be larger than this known deposit balance due to staking
    /// rewards acquired on the staking pool.
    /// To refresh the amount the owner can call `refresh_staking_pool_balance`.
    pub fn get_known_deposited_balance(&self) -> WrappedBalance {
        self.staking_information
            .as_ref()
            .map(|info| info.deposit_amount.0)
            .unwrap_or(0)
            .into()
    }

    /// Returns the current termination status or `None` in case of no termination.
    pub fn get_termination_status(&self) -> Option<TerminationStatus> {
        if let VestingInformation::Terminating(termination_information) = &self.vesting_information
        {
            Some(termination_information.status)
        } else {
            None
        }
    }

    /// Returns the amount of tokens that are not going to be vested, because the vesting schedule
    /// was terminated earlier.
    pub fn get_terminated_unvested_balance(&self) -> WrappedBalance {
        if let VestingInformation::Terminating(TerminationInformation {
            unvested_amount, ..
        }) = &self.vesting_information
        {
            *unvested_amount
        } else {
            0.into()
        }
    }

    /// Returns the amount of tokens missing from the account balance that are required to cover
    /// the unvested balance from the early-terminated vesting schedule.
    pub fn get_terminated_unvested_balance_deficit(&self) -> WrappedBalance {
        self.get_terminated_unvested_balance()
            .0
            .saturating_sub(self.get_account_balance().0)
            .into()
    }

    /// Returns the amount of tokens that are locked in the account due to lockup or vesting.
    pub fn get_locked_amount(&self) -> WrappedBalance {
        let lockup_amount = self.lockup_information.lockup_amount;
        if let TransfersInformation::TransfersEnabled {
            transfers_timestamp,
        } = &self.lockup_information.transfers_information
        {
            let lockup_timestamp = std::cmp::max(
                transfers_timestamp
                    .0
                    .saturating_add(self.lockup_information.lockup_duration),
                self.lockup_information.lockup_timestamp.unwrap_or(0),
            );
            let block_timestamp = env::block_timestamp();
            if lockup_timestamp <= block_timestamp {
                let unreleased_amount =
                    if let &Some(release_duration) = &self.lockup_information.release_duration {
                        let end_timestamp = lockup_timestamp.saturating_add(release_duration);
                        if block_timestamp >= end_timestamp {
                            // Everything is released
                            0
                        } else {
                            let time_left = U256::from(end_timestamp - block_timestamp);
                            let unreleased_amount = U256::from(lockup_amount) * time_left
                                / U256::from(release_duration);
                            // The unreleased amount can't be larger than lockup_amount because the
                            // time_left is smaller than total_time.
                            unreleased_amount.as_u128()
                        }
                    } else {
                        0
                    };

                let unvested_amount = match &self.vesting_information {
                    VestingInformation::VestingSchedule(vs) => self.get_unvested_amount(vs.clone()),
                    VestingInformation::Terminating(terminating) => terminating.unvested_amount,
                    // Vesting is private, so we can assume the vesting started before lockup date.
                    _ => U128(0),
                };
                return std::cmp::max(
                    unreleased_amount
                        .saturating_sub(self.lockup_information.termination_withdrawn_tokens),
                    unvested_amount.0,
                )
                .into();
            }
        }
        // The entire balance is still locked before the lockup timestamp.
        (lockup_amount - self.lockup_information.termination_withdrawn_tokens).into()
    }

    /// Returns the amount of tokens that are already vested, but still locked due to lockup.
    /// Takes raw vesting schedule, in case the internal vesting schedule is private.
    pub fn get_locked_vested_amount(&self, vesting_schedule: VestingSchedule) -> WrappedBalance {
        (self.get_locked_amount().0 - self.get_unvested_amount(vesting_schedule).0).into()
    }

    /// Returns the amount of tokens that are locked in this account due to vesting schedule.
    /// Takes raw vesting schedule, in case the internal vesting schedule is private.
    pub fn get_unvested_amount(&self, vesting_schedule: VestingSchedule) -> WrappedBalance {
        let block_timestamp = env::block_timestamp();
        let lockup_amount = self.lockup_information.lockup_amount;
        match &self.vesting_information {
            VestingInformation::Terminating(termination_information) => {
                termination_information.unvested_amount
            }
            VestingInformation::None => U128::from(0),
            _ => {
                if block_timestamp < vesting_schedule.cliff_timestamp.0 {
                    // Before the cliff, nothing is vested
                    lockup_amount.into()
                } else if block_timestamp >= vesting_schedule.end_timestamp.0 {
                    // After the end, everything is vested
                    0.into()
                } else {
                    // cannot overflow since block_timestamp < vesting_schedule.end_timestamp
                    let time_left = U256::from(vesting_schedule.end_timestamp.0 - block_timestamp);
                    // The total time is positive. Checked at the contract initialization.
                    let total_time = U256::from(
                        vesting_schedule.end_timestamp.0 - vesting_schedule.start_timestamp.0,
                    );
                    let unvested_amount = U256::from(lockup_amount) * time_left / total_time;
                    // The unvested amount can't be larger than lockup_amount because the
                    // time_left is smaller than total_time.
                    unvested_amount.as_u128().into()
                }
            }
        }
    }

    /// Returns the internal vesting information.
    pub fn get_vesting_information(&self) -> VestingInformation {
        self.vesting_information.clone()
    }

    /// Returns the balance of the account owner. It includes vested and extra tokens that
    /// may have been deposited to this account, but excludes locked tokens.
    /// NOTE: Some of this tokens may be deposited to the staking pool.
    /// This method also doesn't account for tokens locked for the contract storage.
    pub fn get_owners_balance(&self) -> WrappedBalance {
        (env::account_balance() + self.get_known_deposited_balance().0)
            .saturating_sub(self.get_locked_amount().0)
            .into()
    }

    /// Returns total balance of the account including tokens deposited to the staking pool.
    pub fn get_balance(&self) -> WrappedBalance {
        (env::account_balance() + self.get_known_deposited_balance().0).into()
    }

    /// Returns the amount of tokens the owner can transfer from the account.
    /// Transfers have to be enabled.
    pub fn get_liquid_owners_balance(&self) -> WrappedBalance {
        std::cmp::min(self.get_owners_balance().0, self.get_account_balance().0).into()
    }

    /// Returns `true` if transfers are enabled, `false` otherwise.
    pub fn are_transfers_enabled(&self) -> bool {
        match &self.lockup_information.transfers_information {
            TransfersInformation::TransfersEnabled { .. } => true,
            TransfersInformation::TransfersDisabled { .. } => false,
        }
    }
}

'''
'''--- lockup/src/internal.rs ---
use crate::*;

/********************/
/* Internal methods */
/********************/

impl LockupContract {
    /// The balance of the account excluding the storage staking balance.
    /// NOTE: The storage staking balance can't be transferred out without deleting this contract.
    pub fn get_account_balance(&self) -> WrappedBalance {
        env::account_balance()
            .saturating_sub(MIN_BALANCE_FOR_STORAGE)
            .into()
    }

    pub fn set_staking_pool_status(&mut self, status: TransactionStatus) {
        self.staking_information
            .as_mut()
            .expect("Staking pool should be selected")
            .status = status;
    }

    pub fn set_termination_status(&mut self, status: TerminationStatus) {
        if let VestingInformation::Terminating(termination_information) =
            &mut self.vesting_information
        {
            termination_information.status = status;
        } else {
            unreachable!("The vesting information is not at the terminating stage");
        }
    }

    pub fn assert_vesting(
        &self,
        vesting_schedule_with_salt: Option<VestingScheduleWithSalt>,
    ) -> VestingSchedule {
        match &self.vesting_information {
            VestingInformation::VestingHash(hash) => {
                if let Some(vesting_schedule_with_salt) = vesting_schedule_with_salt {
                    assert_eq!(
                        &vesting_schedule_with_salt.hash(),
                        &hash.0,
                        "Presented vesting schedule and salt don't match the hash"
                    );
                    vesting_schedule_with_salt.vesting_schedule
                } else {
                    env::panic(b"Expected vesting schedule and salt, but it was not provided")
                }
            }
            VestingInformation::VestingSchedule(vesting_schedule) => {
                assert!(
                    vesting_schedule_with_salt.is_none(),
                    "Explicit vesting schedule exists"
                );
                vesting_schedule.clone()
            }
            VestingInformation::Terminating(_) => env::panic(b"Vesting was terminated"),
            VestingInformation::None => env::panic(b"Vesting is None"),
        }
    }

    pub fn assert_no_termination(&self) {
        if let VestingInformation::Terminating(_) = &self.vesting_information {
            env::panic(b"All operations are blocked until vesting termination is completed");
        }
    }

    pub fn assert_transfers_enabled(&self) {
        assert!(self.are_transfers_enabled(), "Transfers are disabled");
    }

    pub fn assert_transfers_disabled(&self) {
        assert!(
            !self.are_transfers_enabled(),
            "Transfers are already enabled"
        );
    }

    pub fn assert_no_staking_or_idle(&self) {
        if let Some(staking_information) = &self.staking_information {
            match staking_information.status {
                TransactionStatus::Idle => (),
                TransactionStatus::Busy => {
                    env::panic(b"Contract is currently busy with another operation")
                }
            };
        }
    }

    pub fn assert_staking_pool_is_idle(&self) {
        assert!(
            self.staking_information.is_some(),
            "Staking pool is not selected"
        );
        match self.staking_information.as_ref().unwrap().status {
            TransactionStatus::Idle => (),
            TransactionStatus::Busy => {
                env::panic(b"Contract is currently busy with another operation")
            }
        };
    }

    pub fn assert_staking_pool_is_not_selected(&self) {
        assert!(
            self.staking_information.is_none(),
            "Staking pool is already selected"
        );
    }

    pub fn assert_called_by_foundation(&self) {
        if let Some(foundation_account_id) = &self.foundation_account_id {
            assert_eq!(
                &env::predecessor_account_id(),
                foundation_account_id,
                "Can only be called by NEAR Foundation"
            )
        } else {
            env::panic(b"No NEAR Foundation account is specified in the contract");
        }
    }

    pub fn assert_owner(&self) {
        assert_eq!(
            &env::predecessor_account_id(),
            &self.owner_account_id,
            "Can only be called by the owner"
        )
    }
}

'''
'''--- lockup/src/lib.rs ---
//! A smart contract that allows tokens to be locked up.

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::Base58PublicKey;
use near_sdk::{env, ext_contract, near_bindgen, AccountId};

pub use crate::foundation::*;
pub use crate::foundation_callbacks::*;
pub use crate::getters::*;
pub use crate::internal::*;
pub use crate::owner::*;
pub use crate::owner_callbacks::*;
pub use crate::types::*;

pub mod foundation;
pub mod foundation_callbacks;
pub mod gas;
pub mod owner_callbacks;
pub mod types;

pub mod getters;
pub mod internal;
pub mod owner;

#[global_allocator]
static ALLOC: near_sdk::wee_alloc::WeeAlloc = near_sdk::wee_alloc::WeeAlloc::INIT;

/// Indicates there are no deposit for a cross contract call for better readability.
const NO_DEPOSIT: u128 = 0;

/// The contract keeps at least 3.5 NEAR in the account to avoid being transferred out to cover
/// contract code storage and some internal state.
pub const MIN_BALANCE_FOR_STORAGE: u128 = 3_500_000_000_000_000_000_000_000;

#[ext_contract(ext_staking_pool)]
pub trait ExtStakingPool {
    fn get_account_staked_balance(&self, account_id: AccountId) -> WrappedBalance;

    fn get_account_unstaked_balance(&self, account_id: AccountId) -> WrappedBalance;

    fn get_account_total_balance(&self, account_id: AccountId) -> WrappedBalance;

    fn deposit(&mut self);

    fn deposit_and_stake(&mut self);

    fn withdraw(&mut self, amount: WrappedBalance);

    fn stake(&mut self, amount: WrappedBalance);

    fn unstake(&mut self, amount: WrappedBalance);

    fn unstake_all(&mut self);
}

#[ext_contract(ext_whitelist)]
pub trait ExtStakingPoolWhitelist {
    fn is_whitelisted(&self, staking_pool_account_id: AccountId) -> bool;
}

#[ext_contract(ext_transfer_poll)]
pub trait ExtTransferPoll {
    fn get_result(&self) -> Option<PollResult>;
}

#[ext_contract(ext_self_owner)]
pub trait ExtLockupContractOwner {
    fn on_whitelist_is_whitelisted(
        &mut self,
        #[callback] is_whitelisted: bool,
        staking_pool_account_id: AccountId,
    ) -> bool;

    fn on_staking_pool_deposit(&mut self, amount: WrappedBalance) -> bool;

    fn on_staking_pool_deposit_and_stake(&mut self, amount: WrappedBalance) -> bool;

    fn on_staking_pool_withdraw(&mut self, amount: WrappedBalance) -> bool;

    fn on_staking_pool_stake(&mut self, amount: WrappedBalance) -> bool;

    fn on_staking_pool_unstake(&mut self, amount: WrappedBalance) -> bool;

    fn on_staking_pool_unstake_all(&mut self) -> bool;

    fn on_get_result_from_transfer_poll(&mut self, #[callback] poll_result: PollResult) -> bool;

    fn on_get_account_total_balance(&mut self, #[callback] total_balance: WrappedBalance);

    fn on_get_account_unstaked_balance_to_withdraw_by_owner(
        &mut self,
        #[callback] unstaked_balance: WrappedBalance,
    );
}

#[ext_contract(ext_self_foundation)]
pub trait ExtLockupContractFoundation {
    fn on_withdraw_unvested_amount(
        &mut self,
        amount: WrappedBalance,
        receiver_id: AccountId,
    ) -> bool;

    fn on_get_account_staked_balance_to_unstake(
        &mut self,
        #[callback] staked_balance: WrappedBalance,
    );

    fn on_staking_pool_unstake_for_termination(&mut self, amount: WrappedBalance) -> bool;

    fn on_get_account_unstaked_balance_to_withdraw(
        &mut self,
        #[callback] unstaked_balance: WrappedBalance,
    );

    fn on_staking_pool_withdraw_for_termination(&mut self, amount: WrappedBalance) -> bool;
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct LockupContract {
    /// The account ID of the owner.
    pub owner_account_id: AccountId,

    /// Information about lockup schedule and the amount.
    pub lockup_information: LockupInformation,

    /// Information about vesting including schedule or termination status.
    pub vesting_information: VestingInformation,

    /// Account ID of the staking pool whitelist contract.
    pub staking_pool_whitelist_account_id: AccountId,

    /// Information about staking and delegation.
    /// `Some` means the staking information is available and the staking pool contract is selected.
    /// `None` means there is no staking pool selected.
    pub staking_information: Option<StakingInformation>,

    /// The account ID that the NEAR Foundation, that has the ability to terminate vesting.
    pub foundation_account_id: Option<AccountId>,
}

impl Default for LockupContract {
    fn default() -> Self {
        env::panic(b"The contract is not initialized.");
    }
}

#[near_bindgen]
impl LockupContract {
    /// Requires 25 TGas (1 * BASE_GAS)
    ///
    /// Initializes lockup contract.
    /// - `owner_account_id` - the account ID of the owner. Only this account can call owner's
    ///    methods on this contract.
    /// - `lockup_duration` [deprecated] - the duration in nanoseconds of the lockup period from
    ///    the moment the transfers are enabled. During this period tokens are locked and
    ///    the release doesn't start. Instead of this, use `lockup_timestamp` and `release_duration`
    /// - `lockup_timestamp` - the optional absolute lockup timestamp in nanoseconds which locks
    ///    the tokens until this timestamp passes. Until this moment the tokens are locked and the
    ///    release doesn't start.
    /// - `transfers_information` - the information about the transfers. Either transfers are
    ///    already enabled, then it contains the timestamp when they were enabled. Or the transfers
    ///    are currently disabled and it contains the account ID of the transfer poll contract.
    /// - `vesting_schedule` - If provided, then it's either a base64 encoded hash of vesting
    ///    schedule with salt or an explicit vesting schedule.
    ///    Vesting schedule affects the amount of tokens the NEAR Foundation will get in case of
    ///    employment termination as well as the amount of tokens available for transfer by
    ///    the employee. If Hash provided, it's expected that vesting started before lockup and
    ///    it only needs to be revealed in case of termination.
    /// - `release_duration` - is the duration when the full lockup amount will be available.
    ///    The tokens are linearly released from the moment tokens are unlocked.
    ///    The unlocking happens at the timestamp defined by:
    ///    `max(transfers_timestamp + lockup_duration, lockup_timestamp)`.
    ///    If it's used in addition to the vesting schedule, then the amount of tokens available to
    ///    transfer is subject to the minimum between vested tokens and released tokens.
    /// - `staking_pool_whitelist_account_id` - the Account ID of the staking pool whitelist contract.
    /// - `foundation_account_id` - the account ID of the NEAR Foundation, that has the ability to
    ///    terminate vesting schedule.
    #[init]
    pub fn new(
        owner_account_id: AccountId,
        lockup_duration: WrappedDuration,
        lockup_timestamp: Option<WrappedTimestamp>,
        transfers_information: TransfersInformation,
        vesting_schedule: Option<VestingScheduleOrHash>,
        release_duration: Option<WrappedDuration>,
        staking_pool_whitelist_account_id: AccountId,
        foundation_account_id: Option<AccountId>,
    ) -> Self {
        assert!(
            env::is_valid_account_id(owner_account_id.as_bytes()),
            "The account ID of the owner is invalid"
        );
        assert!(
            env::is_valid_account_id(staking_pool_whitelist_account_id.as_bytes()),
            "The staking pool whitelist account ID is invalid"
        );
        if let TransfersInformation::TransfersDisabled {
            transfer_poll_account_id,
        } = &transfers_information
        {
            assert!(
                env::is_valid_account_id(transfer_poll_account_id.as_bytes()),
                "The transfer poll account ID is invalid"
            );
        }
        let lockup_information = LockupInformation {
            lockup_amount: env::account_balance(),
            termination_withdrawn_tokens: 0,
            lockup_duration: lockup_duration.0,
            release_duration: release_duration.map(|d| d.0),
            lockup_timestamp: lockup_timestamp.map(|d| d.0),
            transfers_information,
        };
        let vesting_information = match vesting_schedule {
            None => {
                assert!(
                    foundation_account_id.is_none(),
                    "Foundation account can't be added without vesting schedule"
                );
                VestingInformation::None
            }
            Some(VestingScheduleOrHash::VestingHash(hash)) => VestingInformation::VestingHash(hash),
            Some(VestingScheduleOrHash::VestingSchedule(vs)) => {
                VestingInformation::VestingSchedule(vs)
            }
        };
        assert!(
            vesting_information == VestingInformation::None ||
                env::is_valid_account_id(foundation_account_id.as_ref().unwrap().as_bytes()),
            "Foundation account should be added for vesting schedule"
        );

        Self {
            owner_account_id,
            lockup_information,
            vesting_information,
            staking_information: None,
            staking_pool_whitelist_account_id,
            foundation_account_id,
        }
    }
}

#[cfg(not(target_arch = "wasm32"))]
#[cfg(test)]
mod tests {
    use std::convert::TryInto;

    use near_sdk::{testing_env, MockedBlockchain, PromiseResult, VMContext};

    use test_utils::*;

    use super::*;

    mod test_utils;

    pub type AccountId = String;

    const SALT: [u8; 3] = [1, 2, 3];

    fn basic_context() -> VMContext {
        get_context(
            system_account(),
            to_yocto(LOCKUP_NEAR),
            0,
            to_ts(GENESIS_TIME_IN_DAYS),
            false,
        )
    }

    fn new_vesting_schedule(offset_in_days: u64) -> VestingSchedule {
        VestingSchedule {
            start_timestamp: to_ts(GENESIS_TIME_IN_DAYS - YEAR + offset_in_days).into(),
            cliff_timestamp: to_ts(GENESIS_TIME_IN_DAYS + offset_in_days).into(),
            end_timestamp: to_ts(GENESIS_TIME_IN_DAYS + YEAR * 3 + offset_in_days).into(),
        }
    }

    fn no_vesting_schedule() -> VestingSchedule {
        VestingSchedule {
            start_timestamp: to_ts(0).into(),
            cliff_timestamp: to_ts(0).into(),
            end_timestamp: to_ts(0).into(),
        }
    }

    fn new_contract_with_lockup_duration(
        transfers_enabled: bool,
        vesting_schedule: Option<VestingSchedule>,
        release_duration: Option<WrappedDuration>,
        foundation_account: bool,
        lockup_duration: Duration,
    ) -> LockupContract {
        let lockup_start_information = if transfers_enabled {
            TransfersInformation::TransfersEnabled {
                transfers_timestamp: to_ts(GENESIS_TIME_IN_DAYS).into(),
            }
        } else {
            TransfersInformation::TransfersDisabled {
                transfer_poll_account_id: AccountId::from("transfers"),
            }
        };
        let foundation_account_id = if foundation_account {
            Some(account_foundation())
        } else {
            None
        };
        let vesting_schedule = vesting_schedule.map(|vesting_schedule| {
            VestingScheduleOrHash::VestingHash(
                VestingScheduleWithSalt {
                    vesting_schedule,
                    salt: SALT.to_vec().into(),
                }
                    .hash()
                    .into(),
            )
        });
        LockupContract::new(
            account_owner(),
            lockup_duration.into(),
            None,
            lockup_start_information,
            vesting_schedule,
            release_duration,
            AccountId::from("whitelist"),
            foundation_account_id,
        )
    }

    fn new_contract(
        transfers_enabled: bool,
        vesting_schedule: Option<VestingSchedule>,
        release_duration: Option<WrappedDuration>,
        foundation_account: bool,
    ) -> LockupContract {
        new_contract_with_lockup_duration(
            transfers_enabled,
            vesting_schedule,
            release_duration,
            foundation_account,
            to_nanos(YEAR),
        )
    }

    fn lockup_only_setup() -> (VMContext, LockupContract) {
        let context = basic_context();
        testing_env!(context.clone());
        let contract = new_contract(true, None, None, false);
        (context, contract)
    }

    #[test]
    fn test_lockup_only_basic() {
        let (mut context, contract) = lockup_only_setup();
        // Checking initial values at genesis time
        context.is_view = true;
        testing_env!(context.clone());

        assert_eq!(contract.get_owners_balance().0, 0);
        assert_eq!(
            contract.get_locked_vested_amount(no_vesting_schedule()).0,
            to_yocto(LOCKUP_NEAR)
        );

        // Checking values in 1 day after genesis time
        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + 1);

        assert_eq!(contract.get_owners_balance().0, 0);

        // Checking values next day after lockup timestamp
        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + YEAR + 1);
        testing_env!(context.clone());

        assert_almost_eq(contract.get_owners_balance().0, to_yocto(LOCKUP_NEAR));
    }

    #[test]
    fn test_add_full_access_key() {
        let (mut context, mut contract) = lockup_only_setup();
        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + YEAR);
        context.predecessor_account_id = account_owner();
        context.signer_account_id = account_owner();
        context.signer_account_pk = public_key(1).try_into().unwrap();
        testing_env!(context.clone());

        contract.add_full_access_key(public_key(4));
    }

    #[test]
    #[should_panic(expected = "Tokens are still locked/unvested")]
    fn test_add_full_access_key_when_vesting_is_not_finished() {
        let mut context = basic_context();
        testing_env!(context.clone());
        let vesting_schedule = new_vesting_schedule(YEAR);
        let mut contract = new_contract(true, Some(vesting_schedule), None, true);

        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + YEAR - 10);
        context.predecessor_account_id = account_owner();
        context.signer_account_id = account_owner();
        context.signer_account_pk = public_key(1).try_into().unwrap();
        testing_env!(context.clone());

        contract.add_full_access_key(public_key(4));
    }

    #[test]
    #[should_panic(expected = "Tokens are still locked/unvested")]
    fn test_add_full_access_key_when_lockup_is_not_finished() {
        let mut context = basic_context();
        testing_env!(context.clone());
        let mut contract = new_contract(true, None, Some(to_nanos(YEAR).into()), false);

        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + YEAR - 10);
        context.predecessor_account_id = account_owner();
        context.signer_account_id = account_owner();
        context.signer_account_pk = public_key(1).try_into().unwrap();
        testing_env!(context.clone());

        contract.add_full_access_key(public_key(4));
    }

    #[test]
    #[should_panic(expected = "Can only be called by the owner")]
    fn test_call_by_non_owner() {
        let (mut context, mut contract) = lockup_only_setup();
        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + YEAR);
        context.predecessor_account_id = non_owner();
        context.signer_account_id = non_owner();
        testing_env!(context.clone());

        contract.select_staking_pool(AccountId::from("staking_pool"));
    }

    #[test]
    #[should_panic(expected = "Presented vesting schedule and salt don't match the hash")]
    fn test_vesting_doesnt_match() {
        let mut context = basic_context();
        testing_env!(context.clone());
        let vesting_schedule = new_vesting_schedule(5);
        let mut contract = new_contract(true, Some(vesting_schedule), None, true);
        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + YEAR);
        context.predecessor_account_id = account_foundation();
        context.signer_account_id = non_owner();
        testing_env!(context.clone());

        let not_real_vesting = new_vesting_schedule(100);
        contract.terminate_vesting(Some(VestingScheduleWithSalt {
            vesting_schedule: not_real_vesting,
            salt: SALT.to_vec().into(),
        }));
    }

    #[test]
    #[should_panic(expected = "Expected vesting schedule and salt, but it was not provided")]
    fn test_vesting_schedule_and_salt_not_provided() {
        let mut context = basic_context();
        testing_env!(context.clone());
        let vesting_schedule = new_vesting_schedule(5);
        let mut contract = new_contract(true, Some(vesting_schedule), None, true);
        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + YEAR);
        context.predecessor_account_id = account_foundation();
        context.signer_account_id = non_owner();
        testing_env!(context.clone());

        contract.terminate_vesting(None);
    }

    #[test]
    #[should_panic(expected = "Explicit vesting schedule exists")]
    fn test_explicit_vesting() {
        let mut context = basic_context();
        testing_env!(context.clone());
        let vesting_schedule = new_vesting_schedule(5);
        let mut contract = LockupContract::new(
            account_owner(),
            to_nanos(YEAR).into(),
            None,
            TransfersInformation::TransfersEnabled {
                transfers_timestamp: to_ts(GENESIS_TIME_IN_DAYS).into(),
            },
            Some(VestingScheduleOrHash::VestingSchedule(
                vesting_schedule.clone(),
            )),
            None,
            AccountId::from("whitelist"),
            Some(account_foundation()),
        );
        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + YEAR);
        context.predecessor_account_id = account_foundation();
        context.signer_account_id = non_owner();
        testing_env!(context.clone());

        contract.terminate_vesting(Some(VestingScheduleWithSalt {
            vesting_schedule,
            salt: SALT.to_vec().into(),
        }));
    }

    #[test]
    #[should_panic(expected = "Foundation account can't be added without vesting schedule")]
    fn test_init_foundation_key_no_vesting() {
        let context = basic_context();
        testing_env!(context.clone());
        new_contract(true, None, None, true);
    }

    #[test]
    #[should_panic(expected = "Foundation account can't be added without vesting schedule")]
    fn test_init_foundation_key_no_vesting_with_release() {
        let context = basic_context();
        testing_env!(context.clone());
        new_contract(true, None, Some(to_nanos(YEAR).into()), true);
    }

    #[test]
    #[should_panic(expected = "Can only be called by NEAR Foundation")]
    fn test_call_by_non_foundation() {
        let mut context = basic_context();
        testing_env!(context.clone());
        let vesting_schedule = new_vesting_schedule(0);
        let mut contract = new_contract(true, Some(vesting_schedule.clone()), None, true);
        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + YEAR);
        context.predecessor_account_id = non_owner();
        context.signer_account_id = non_owner();
        testing_env!(context.clone());

        contract.terminate_vesting(None);
    }

    #[test]
    #[should_panic(expected = "Transfers are disabled")]
    fn test_transfers_not_enabled() {
        let mut context = basic_context();
        testing_env!(context.clone());
        let mut contract = new_contract(false, None, None, false);
        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + YEAR + 1);
        context.predecessor_account_id = account_owner();
        context.signer_account_id = account_owner();
        context.signer_account_pk = public_key(1).try_into().unwrap();
        context.is_view = false;
        testing_env!(context.clone());

        contract.transfer(to_yocto(100).into(), non_owner());
    }

    #[test]
    fn test_enable_transfers() {
        let mut context = basic_context();
        testing_env!(context.clone());
        let mut contract = new_contract(false, None, None, false);
        context.is_view = true;
        testing_env!(context.clone());
        assert!(!contract.are_transfers_enabled());

        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + YEAR + 1);
        context.predecessor_account_id = account_owner();
        context.signer_account_id = account_owner();
        context.signer_account_pk = public_key(1).try_into().unwrap();
        context.is_view = false;
        testing_env!(context.clone());

        contract.check_transfers_vote();

        let poll_result = Some(to_ts(GENESIS_TIME_IN_DAYS + 10).into());
        context.predecessor_account_id = lockup_account();
        // NOTE: Unit tests don't need to read the content of the promise result. So here we don't
        // have to pass serialized result from the transfer poll.
        testing_env_with_promise_results(context.clone(), PromiseResult::Successful(vec![]));
        assert!(contract.on_get_result_from_transfer_poll(poll_result));

        context.is_view = true;
        testing_env!(context.clone());
        // Not unlocked yet
        assert_eq!(contract.get_owners_balance().0, 0);
        assert!(contract.are_transfers_enabled());
        assert_eq!(contract.get_vesting_information(), VestingInformation::None);

        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + YEAR + 10);
        testing_env!(context.clone());
        // Unlocked yet
        assert_eq!(
            contract.get_owners_balance().0,
            to_yocto(LOCKUP_NEAR).into()
        );

        context.is_view = false;
        context.predecessor_account_id = account_owner();
        testing_env!(context.clone());
        contract.transfer(to_yocto(100).into(), non_owner());
    }

    #[test]
    fn test_check_transfers_vote_false() {
        let mut context = basic_context();
        testing_env!(context.clone());
        let mut contract = new_contract(false, None, None, false);
        context.is_view = true;
        testing_env!(context.clone());
        assert!(!contract.are_transfers_enabled());

        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + YEAR + 1);
        context.predecessor_account_id = account_owner();
        context.signer_account_id = account_owner();
        context.signer_account_pk = public_key(1).try_into().unwrap();
        context.is_view = false;
        testing_env!(context.clone());

        contract.check_transfers_vote();

        let poll_result = None;
        // NOTE: Unit tests don't need to read the content of the promise result. So here we don't
        // have to pass serialized result from the transfer poll.
        context.predecessor_account_id = lockup_account();
        testing_env_with_promise_results(context.clone(), PromiseResult::Successful(vec![]));
        assert!(!contract.on_get_result_from_transfer_poll(poll_result));

        context.is_view = true;
        testing_env!(context.clone());
        // Not enabled
        assert!(!contract.are_transfers_enabled());
    }

    #[test]
    fn test_lockup_only_transfer_call_by_owner() {
        let (mut context, mut contract) = lockup_only_setup();
        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + YEAR + 1);
        context.is_view = true;
        testing_env!(context.clone());
        assert_almost_eq(contract.get_owners_balance().0, to_yocto(LOCKUP_NEAR));

        context.predecessor_account_id = account_owner();
        context.signer_account_id = account_owner();
        context.signer_account_pk = public_key(1).try_into().unwrap();
        context.is_view = false;
        testing_env!(context.clone());

        assert_eq!(env::account_balance(), to_yocto(LOCKUP_NEAR));
        contract.transfer(to_yocto(100).into(), non_owner());
        assert_almost_eq(env::account_balance(), to_yocto(LOCKUP_NEAR - 100));
    }

    #[test]
    #[should_panic(expected = "Staking pool is not selected")]
    fn test_staking_pool_is_not_selected() {
        let (mut context, mut contract) = lockup_only_setup();
        context.predecessor_account_id = account_owner();
        context.signer_account_id = account_owner();
        context.signer_account_pk = public_key(2).try_into().unwrap();

        let amount = to_yocto(LOCKUP_NEAR - 100);
        testing_env!(context.clone());
        contract.deposit_to_staking_pool(amount.into());
    }

    #[test]
    fn test_staking_pool_success() {
        let (mut context, mut contract) = lockup_only_setup();
        context.predecessor_account_id = account_owner();
        context.signer_account_id = account_owner();
        context.signer_account_pk = public_key(2).try_into().unwrap();

        // Selecting staking pool
        let staking_pool = "staking_pool".to_string();
        testing_env!(context.clone());
        contract.select_staking_pool(staking_pool.clone());

        context.predecessor_account_id = lockup_account();
        testing_env_with_promise_results(
            context.clone(),
            PromiseResult::Successful(b"true".to_vec()),
        );
        contract.on_whitelist_is_whitelisted(true, staking_pool.clone());

        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(contract.get_staking_pool_account_id(), Some(staking_pool));
        assert_eq!(contract.get_known_deposited_balance().0, 0);
        context.is_view = false;

        // Deposit to the staking_pool
        let amount = to_yocto(LOCKUP_NEAR - 100);
        context.predecessor_account_id = account_owner();
        testing_env!(context.clone());
        contract.deposit_to_staking_pool(amount.into());
        context.account_balance = env::account_balance();
        assert_eq!(context.account_balance, to_yocto(LOCKUP_NEAR) - amount);

        context.predecessor_account_id = lockup_account();
        testing_env_with_promise_results(context.clone(), PromiseResult::Successful(vec![]));
        contract.on_staking_pool_deposit(amount.into());
        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(contract.get_known_deposited_balance().0, amount);
        context.is_view = false;

        // Staking on the staking pool
        context.predecessor_account_id = account_owner();
        testing_env!(context.clone());
        contract.stake(amount.into());

        context.predecessor_account_id = lockup_account();
        testing_env_with_promise_results(context.clone(), PromiseResult::Successful(vec![]));
        contract.on_staking_pool_stake(amount.into());

        // Assuming there are 20 NEAR tokens in rewards. Unstaking.
        let unstake_amount = amount + to_yocto(20);
        context.predecessor_account_id = account_owner();
        testing_env!(context.clone());
        contract.unstake(unstake_amount.into());

        context.predecessor_account_id = lockup_account();
        testing_env_with_promise_results(context.clone(), PromiseResult::Successful(vec![]));
        contract.on_staking_pool_unstake(unstake_amount.into());

        // Withdrawing
        context.predecessor_account_id = account_owner();
        testing_env!(context.clone());
        contract.withdraw_from_staking_pool(unstake_amount.into());
        context.account_balance += unstake_amount;

        context.predecessor_account_id = lockup_account();
        testing_env_with_promise_results(context.clone(), PromiseResult::Successful(vec![]));
        contract.on_staking_pool_withdraw(unstake_amount.into());
        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(contract.get_known_deposited_balance().0, 0);
        context.is_view = false;

        // Unselecting staking pool
        context.predecessor_account_id = account_owner();
        testing_env!(context.clone());
        contract.unselect_staking_pool();
        assert_eq!(contract.get_staking_pool_account_id(), None);
    }

    #[test]
    fn test_staking_pool_refresh_balance() {
        let (mut context, mut contract) = lockup_only_setup();
        context.predecessor_account_id = account_owner();
        context.signer_account_id = account_owner();
        context.signer_account_pk = public_key(2).try_into().unwrap();

        // Selecting staking pool
        let staking_pool = "staking_pool".to_string();
        testing_env!(context.clone());
        contract.select_staking_pool(staking_pool.clone());

        context.predecessor_account_id = lockup_account();
        testing_env_with_promise_results(
            context.clone(),
            PromiseResult::Successful(b"true".to_vec()),
        );
        contract.on_whitelist_is_whitelisted(true, staking_pool.clone());

        // Deposit to the staking_pool
        let amount = to_yocto(LOCKUP_NEAR - 100);
        context.predecessor_account_id = account_owner();
        testing_env!(context.clone());
        contract.deposit_to_staking_pool(amount.into());
        context.account_balance = env::account_balance();
        assert_eq!(context.account_balance, to_yocto(LOCKUP_NEAR) - amount);

        context.predecessor_account_id = lockup_account();
        testing_env_with_promise_results(context.clone(), PromiseResult::Successful(vec![]));
        contract.on_staking_pool_deposit(amount.into());

        // Staking on the staking pool
        context.predecessor_account_id = account_owner();
        testing_env!(context.clone());
        contract.stake(amount.into());

        context.predecessor_account_id = lockup_account();
        testing_env_with_promise_results(context.clone(), PromiseResult::Successful(vec![]));
        contract.on_staking_pool_stake(amount.into());

        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(contract.get_owners_balance().0, 0);
        assert_eq!(contract.get_liquid_owners_balance().0, 0);
        assert_eq!(contract.get_known_deposited_balance().0, amount);
        context.is_view = false;

        // Assuming there are 20 NEAR tokens in rewards. Refreshing balance.
        let total_balance = amount + to_yocto(20);
        context.predecessor_account_id = account_owner();
        testing_env!(context.clone());
        contract.refresh_staking_pool_balance();

        // In unit tests, the following call ignores the promise value, because it's passed directly.
        context.predecessor_account_id = lockup_account();
        testing_env_with_promise_results(context.clone(), PromiseResult::Successful(vec![]));
        contract.on_get_account_total_balance(total_balance.into());

        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(contract.get_known_deposited_balance().0, total_balance);
        assert_eq!(contract.get_owners_balance().0, to_yocto(20));
        assert_eq!(contract.get_liquid_owners_balance().0, to_yocto(20));
        context.is_view = false;

        // Withdrawing these tokens
        context.predecessor_account_id = account_owner();
        testing_env!(context.clone());
        let transfer_amount = to_yocto(15);
        contract.transfer(transfer_amount.into(), non_owner());
        context.account_balance = env::account_balance();

        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(contract.get_known_deposited_balance().0, total_balance);
        assert_eq!(contract.get_owners_balance().0, to_yocto(5));
        assert_eq!(contract.get_liquid_owners_balance().0, to_yocto(5));
        context.is_view = false;
    }

    #[test]
    #[should_panic(expected = "Staking pool is already selected")]
    fn test_staking_pool_selected_again() {
        let (mut context, mut contract) = lockup_only_setup();
        context.predecessor_account_id = account_owner();
        context.signer_account_id = account_owner();
        context.signer_account_pk = public_key(2).try_into().unwrap();

        // Selecting staking pool
        let staking_pool = "staking_pool".to_string();
        testing_env!(context.clone());
        contract.select_staking_pool(staking_pool.clone());

        context.predecessor_account_id = lockup_account();
        testing_env_with_promise_results(
            context.clone(),
            PromiseResult::Successful(b"true".to_vec()),
        );
        contract.on_whitelist_is_whitelisted(true, staking_pool.clone());

        // Selecting another staking pool
        context.predecessor_account_id = account_owner();
        testing_env!(context.clone());
        contract.select_staking_pool("staking_pool_2".to_string());
    }

    #[test]
    #[should_panic(expected = "The given staking pool account ID is not whitelisted")]
    fn test_staking_pool_not_whitelisted() {
        let (mut context, mut contract) = lockup_only_setup();
        context.predecessor_account_id = account_owner();
        context.signer_account_id = account_owner();
        context.signer_account_pk = public_key(2).try_into().unwrap();

        // Selecting staking pool
        let staking_pool = "staking_pool".to_string();
        testing_env!(context.clone());
        contract.select_staking_pool(staking_pool.clone());

        context.predecessor_account_id = lockup_account();
        context.predecessor_account_id = lockup_account();
        testing_env_with_promise_results(
            context.clone(),
            PromiseResult::Successful(b"false".to_vec()),
        );
        contract.on_whitelist_is_whitelisted(false, staking_pool.clone());
    }

    #[test]
    #[should_panic(expected = "Staking pool is not selected")]
    fn test_staking_pool_unselecting_non_selected() {
        let (mut context, mut contract) = lockup_only_setup();
        context.predecessor_account_id = account_owner();
        context.signer_account_id = account_owner();
        context.signer_account_pk = public_key(2).try_into().unwrap();

        // Unselecting staking pool
        testing_env!(context.clone());
        contract.unselect_staking_pool();
    }

    #[test]
    #[should_panic(expected = "There is still a deposit on the staking pool")]
    fn test_staking_pool_unselecting_with_deposit() {
        let (mut context, mut contract) = lockup_only_setup();
        context.predecessor_account_id = account_owner();
        context.signer_account_id = account_owner();
        context.signer_account_pk = public_key(2).try_into().unwrap();

        // Selecting staking pool
        let staking_pool = "staking_pool".to_string();
        testing_env!(context.clone());
        contract.select_staking_pool(staking_pool.clone());

        context.predecessor_account_id = lockup_account();
        testing_env_with_promise_results(
            context.clone(),
            PromiseResult::Successful(b"true".to_vec()),
        );
        contract.on_whitelist_is_whitelisted(true, staking_pool.clone());

        // Deposit to the staking_pool
        let amount = to_yocto(LOCKUP_NEAR - 100);
        context.predecessor_account_id = account_owner();
        testing_env!(context.clone());
        contract.deposit_to_staking_pool(amount.into());
        context.account_balance = env::account_balance();

        context.predecessor_account_id = lockup_account();
        testing_env_with_promise_results(context.clone(), PromiseResult::Successful(vec![]));
        contract.on_staking_pool_deposit(amount.into());

        // Unselecting staking pool
        context.predecessor_account_id = account_owner();
        testing_env!(context.clone());
        contract.unselect_staking_pool();
    }

    #[test]
    fn test_staking_pool_owner_balance() {
        let (mut context, mut contract) = lockup_only_setup();
        context.predecessor_account_id = account_owner();
        context.signer_account_id = account_owner();
        context.signer_account_pk = public_key(2).try_into().unwrap();
        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + YEAR + 1);

        let lockup_amount = to_yocto(LOCKUP_NEAR);
        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(contract.get_owners_balance().0, lockup_amount);
        context.is_view = false;

        // Selecting staking pool
        let staking_pool = "staking_pool".to_string();
        testing_env!(context.clone());
        contract.select_staking_pool(staking_pool.clone());

        context.predecessor_account_id = lockup_account();
        testing_env_with_promise_results(
            context.clone(),
            PromiseResult::Successful(b"true".to_vec()),
        );
        contract.on_whitelist_is_whitelisted(true, staking_pool.clone());

        // Deposit to the staking_pool
        let mut total_amount = 0;
        let amount = to_yocto(100);
        for _ in 1..=5 {
            total_amount += amount;
            context.predecessor_account_id = account_owner();
            testing_env!(context.clone());
            contract.deposit_to_staking_pool(amount.into());
            context.account_balance = env::account_balance();
            assert_eq!(context.account_balance, lockup_amount - total_amount);

            context.predecessor_account_id = lockup_account();
            testing_env_with_promise_results(context.clone(), PromiseResult::Successful(vec![]));
            contract.on_staking_pool_deposit(amount.into());
            context.is_view = true;
            testing_env!(context.clone());
            assert_eq!(contract.get_known_deposited_balance().0, total_amount);
            assert_eq!(contract.get_owners_balance().0, lockup_amount);
            assert_eq!(
                contract.get_liquid_owners_balance().0,
                lockup_amount - total_amount - MIN_BALANCE_FOR_STORAGE
            );
            context.is_view = false;
        }

        // Withdrawing from the staking_pool. Plus one extra time as a reward
        let mut total_withdrawn_amount = 0;
        for _ in 1..=6 {
            total_withdrawn_amount += amount;
            context.predecessor_account_id = account_owner();
            testing_env!(context.clone());
            contract.withdraw_from_staking_pool(amount.into());
            context.account_balance += amount;
            assert_eq!(
                context.account_balance,
                lockup_amount - total_amount + total_withdrawn_amount
            );

            context.predecessor_account_id = lockup_account();
            testing_env_with_promise_results(context.clone(), PromiseResult::Successful(vec![]));
            contract.on_staking_pool_withdraw(amount.into());
            context.is_view = true;
            testing_env!(context.clone());
            assert_eq!(
                contract.get_known_deposited_balance().0,
                total_amount.saturating_sub(total_withdrawn_amount)
            );
            assert_eq!(
                contract.get_owners_balance().0,
                lockup_amount + total_withdrawn_amount.saturating_sub(total_amount)
            );
            assert_eq!(
                contract.get_liquid_owners_balance().0,
                lockup_amount - total_amount + total_withdrawn_amount - MIN_BALANCE_FOR_STORAGE
            );
            context.is_view = false;
        }
    }

    #[test]
    fn test_lock_timestmap() {
        let mut context = basic_context();
        testing_env!(context.clone());
        let contract = LockupContract::new(
            account_owner(),
            0.into(),
            Some(to_ts(GENESIS_TIME_IN_DAYS + YEAR).into()),
            TransfersInformation::TransfersDisabled {
                transfer_poll_account_id: AccountId::from("transfers"),
            },
            None,
            None,
            AccountId::from("whitelist"),
            None,
        );

        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(contract.get_owners_balance().0, 0);
        assert_eq!(contract.get_liquid_owners_balance().0, 0);
        assert_eq!(
            contract.get_locked_vested_amount(no_vesting_schedule()).0,
            to_yocto(1000)
        );
        assert_eq!(contract.get_locked_amount().0, to_yocto(1000));
        assert_eq!(
            contract.get_unvested_amount(no_vesting_schedule()).0,
            to_yocto(0)
        );
        assert!(!contract.are_transfers_enabled());

        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + YEAR);
        testing_env!(context.clone());
        assert_eq!(contract.get_owners_balance().0, 0);
        assert_eq!(contract.get_liquid_owners_balance().0, 0);
        assert_eq!(
            contract.get_locked_vested_amount(no_vesting_schedule()).0,
            to_yocto(1000)
        );
        assert_eq!(contract.get_locked_amount().0, to_yocto(1000));
        assert_eq!(
            contract.get_unvested_amount(no_vesting_schedule()).0,
            to_yocto(0)
        );
    }

    #[test]
    fn test_lock_timestmap_transfer_enabled() {
        let mut context = basic_context();
        testing_env!(context.clone());
        let contract = LockupContract::new(
            account_owner(),
            0.into(),
            Some(to_ts(GENESIS_TIME_IN_DAYS + YEAR).into()),
            TransfersInformation::TransfersEnabled {
                transfers_timestamp: to_ts(GENESIS_TIME_IN_DAYS + YEAR / 2).into(),
            },
            None,
            None,
            AccountId::from("whitelist"),
            None,
        );

        context.is_view = true;
        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + YEAR);
        testing_env!(context.clone());
        assert_eq!(contract.get_owners_balance().0, to_yocto(1000));
        assert_eq!(
            contract.get_liquid_owners_balance().0,
            to_yocto(1000) - MIN_BALANCE_FOR_STORAGE
        );
        assert_eq!(
            contract.get_locked_vested_amount(no_vesting_schedule()).0,
            to_yocto(0)
        );
        assert_eq!(contract.get_locked_amount().0, to_yocto(0));
        assert_eq!(
            contract.get_unvested_amount(no_vesting_schedule()).0,
            to_yocto(0)
        );
    }

    #[test]
    fn test_termination_no_staking() {
        let mut context = basic_context();
        testing_env!(context.clone());
        let vesting_schedule = new_vesting_schedule(0);
        let mut contract = LockupContract::new(
            account_owner(),
            to_nanos(YEAR).into(),
            None,
            TransfersInformation::TransfersEnabled {
                transfers_timestamp: to_ts(GENESIS_TIME_IN_DAYS).into(),
            },
            Some(VestingScheduleOrHash::VestingSchedule(
                vesting_schedule.clone(),
            )),
            None,
            AccountId::from("whitelist"),
            Some(account_foundation()),
        );

        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(
            contract.get_vesting_information(),
            VestingInformation::VestingSchedule(vesting_schedule.clone())
        );
        assert_eq!(contract.get_owners_balance().0, 0);
        assert_eq!(contract.get_liquid_owners_balance().0, 0);
        assert_eq!(
            contract
                .get_locked_vested_amount(vesting_schedule.clone())
                .0,
            to_yocto(250)
        );
        assert_eq!(contract.get_locked_amount().0, to_yocto(1000));
        assert_eq!(
            contract.get_unvested_amount(vesting_schedule.clone()).0,
            to_yocto(750)
        );

        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + YEAR);
        testing_env!(context.clone());
        assert_eq!(contract.get_owners_balance().0, to_yocto(500));
        assert_eq!(contract.get_liquid_owners_balance().0, to_yocto(500));
        assert_eq!(
            contract
                .get_locked_vested_amount(vesting_schedule.clone())
                .0,
            to_yocto(0)
        );
        assert_eq!(contract.get_locked_amount().0, to_yocto(500));
        assert_eq!(
            contract.get_unvested_amount(vesting_schedule.clone()).0,
            to_yocto(500)
        );

        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + 2 * YEAR);
        testing_env!(context.clone());
        assert_eq!(contract.get_owners_balance().0, to_yocto(750));
        assert_eq!(contract.get_liquid_owners_balance().0, to_yocto(750));
        assert_eq!(contract.get_locked_amount().0, to_yocto(250));
        assert_eq!(
            contract.get_unvested_amount(vesting_schedule.clone()).0,
            to_yocto(250)
        );

        // Terminating
        context.is_view = false;
        context.predecessor_account_id = account_foundation();
        context.signer_account_pk = public_key(3).into();
        testing_env!(context.clone());
        contract.terminate_vesting(None);

        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(
            contract.get_vesting_information(),
            VestingInformation::Terminating(TerminationInformation {
                unvested_amount: to_yocto(250).into(),
                status: TerminationStatus::ReadyToWithdraw,
            })
        );
        assert_eq!(contract.get_owners_balance().0, to_yocto(750));
        assert_eq!(contract.get_liquid_owners_balance().0, to_yocto(750));
        assert_eq!(contract.get_locked_amount().0, to_yocto(250));
        assert_eq!(
            contract.get_unvested_amount(vesting_schedule.clone()).0,
            to_yocto(250)
        );
        assert_eq!(contract.get_terminated_unvested_balance().0, to_yocto(250));
        assert_eq!(
            contract.get_terminated_unvested_balance_deficit().0,
            to_yocto(0)
        );
        assert_eq!(
            contract.get_termination_status(),
            Some(TerminationStatus::ReadyToWithdraw)
        );

        // Withdrawing
        context.is_view = false;
        testing_env!(context.clone());
        let receiver_id = "near".to_string();
        contract.termination_withdraw(receiver_id.clone());
        context.account_balance = env::account_balance();

        context.predecessor_account_id = lockup_account();
        testing_env_with_promise_results(context.clone(), PromiseResult::Successful(vec![]));
        contract.on_withdraw_unvested_amount(to_yocto(250).into(), receiver_id);

        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(contract.get_owners_balance().0, to_yocto(750));
        assert_eq!(
            contract.get_liquid_owners_balance().0,
            to_yocto(750) - MIN_BALANCE_FOR_STORAGE
        );
        assert_eq!(
            contract.get_unvested_amount(vesting_schedule.clone()).0,
            to_yocto(0)
        );
        assert_eq!(contract.get_terminated_unvested_balance().0, to_yocto(0));
        assert_eq!(contract.get_termination_status(), None);
        assert_eq!(contract.get_vesting_information(), VestingInformation::None);
    }

    #[test]
    fn test_release_duration() {
        let mut context = basic_context();
        testing_env!(context.clone());
        let contract = new_contract(true, None, Some(to_nanos(4 * YEAR).into()), false);

        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(contract.get_owners_balance().0, 0);
        assert_eq!(contract.get_liquid_owners_balance().0, 0);
        assert_eq!(
            contract.get_locked_vested_amount(no_vesting_schedule()).0,
            to_yocto(1000)
        );
        assert_eq!(contract.get_locked_amount().0, to_yocto(1000));
        assert_eq!(
            contract.get_unvested_amount(no_vesting_schedule()).0,
            to_yocto(0)
        );

        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + YEAR);
        testing_env!(context.clone());
        assert_eq!(contract.get_owners_balance().0, to_yocto(0));
        assert_eq!(contract.get_liquid_owners_balance().0, to_yocto(0));
        assert_eq!(
            contract.get_locked_vested_amount(no_vesting_schedule()).0,
            to_yocto(1000)
        );
        assert_eq!(contract.get_locked_amount().0, to_yocto(1000));

        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + 2 * YEAR);
        testing_env!(context.clone());
        assert_eq!(contract.get_owners_balance().0, to_yocto(250));
        assert_eq!(contract.get_liquid_owners_balance().0, to_yocto(250));
        assert_eq!(
            contract.get_locked_vested_amount(no_vesting_schedule()).0,
            to_yocto(750)
        );
        assert_eq!(contract.get_locked_amount().0, to_yocto(750));

        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + 3 * YEAR);
        testing_env!(context.clone());
        assert_eq!(contract.get_owners_balance().0, to_yocto(500));
        assert_eq!(contract.get_liquid_owners_balance().0, to_yocto(500));
        assert_eq!(
            contract.get_locked_vested_amount(no_vesting_schedule()).0,
            to_yocto(500)
        );
        assert_eq!(contract.get_locked_amount().0, to_yocto(500));

        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + 4 * YEAR);
        testing_env!(context.clone());
        assert_eq!(contract.get_owners_balance().0, to_yocto(750));
        assert_eq!(contract.get_liquid_owners_balance().0, to_yocto(750));
        assert_eq!(contract.get_locked_amount().0, to_yocto(250));
    }

    #[test]
    fn test_vesting_and_release_duration() {
        let mut context = basic_context();
        testing_env!(context.clone());
        let vesting_schedule = new_vesting_schedule(0);
        let contract = new_contract_with_lockup_duration(
            true,
            Some(vesting_schedule.clone()),
            Some(to_nanos(4 * YEAR).into()),
            true,
            0,
        );

        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(contract.get_owners_balance().0, 0);
        assert_eq!(contract.get_liquid_owners_balance().0, 0);
        assert_eq!(
            contract
                .get_locked_vested_amount(vesting_schedule.clone())
                .0,
            to_yocto(250)
        );
        assert_eq!(contract.get_locked_amount().0, to_yocto(1000));
        assert_eq!(
            contract.get_unvested_amount(vesting_schedule.clone()).0,
            to_yocto(750)
        );

        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + YEAR);
        testing_env!(context.clone());
        assert_eq!(contract.get_owners_balance().0, to_yocto(250));
        assert_eq!(contract.get_liquid_owners_balance().0, to_yocto(250));
        assert_eq!(
            contract
                .get_locked_vested_amount(vesting_schedule.clone())
                .0,
            to_yocto(250)
        );
        assert_eq!(contract.get_locked_amount().0, to_yocto(750));
        assert_eq!(
            contract.get_unvested_amount(vesting_schedule.clone()).0,
            to_yocto(500)
        );

        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + 2 * YEAR);
        testing_env!(context.clone());
        assert_eq!(contract.get_owners_balance().0, to_yocto(500));
        assert_eq!(contract.get_liquid_owners_balance().0, to_yocto(500));
        assert_eq!(
            contract
                .get_locked_vested_amount(vesting_schedule.clone())
                .0,
            to_yocto(250)
        );
        assert_eq!(contract.get_locked_amount().0, to_yocto(500));
        assert_eq!(
            contract.get_unvested_amount(vesting_schedule.clone()).0,
            to_yocto(250)
        );

        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + 3 * YEAR);
        testing_env!(context.clone());
        assert_eq!(contract.get_owners_balance().0, to_yocto(750));
        assert_eq!(contract.get_liquid_owners_balance().0, to_yocto(750));
        assert_eq!(
            contract
                .get_locked_vested_amount(vesting_schedule.clone())
                .0,
            to_yocto(250)
        );
        assert_eq!(contract.get_locked_amount().0, to_yocto(250));
        assert_eq!(
            contract.get_unvested_amount(vesting_schedule.clone()).0,
            to_yocto(0)
        );

        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + 4 * YEAR);
        testing_env!(context.clone());
        assert_eq!(contract.get_owners_balance().0, to_yocto(1000));
        assert_eq!(
            contract.get_liquid_owners_balance().0,
            to_yocto(1000) - MIN_BALANCE_FOR_STORAGE
        );
        assert_eq!(
            contract
                .get_locked_vested_amount(vesting_schedule.clone())
                .0,
            to_yocto(0)
        );
        assert_eq!(contract.get_locked_amount().0, to_yocto(0));
        assert_eq!(
            contract.get_unvested_amount(vesting_schedule.clone()).0,
            to_yocto(0)
        );
    }

    // Vesting post transfers is not supported by Hash vesting.
    #[test]
    fn test_vesting_post_transfers_and_release_duration() {
        let mut context = basic_context();
        testing_env!(context.clone());
        let vesting_schedule = new_vesting_schedule(YEAR * 2);
        let contract = LockupContract::new(
            account_owner(),
            to_nanos(YEAR).into(),
            None,
            TransfersInformation::TransfersEnabled {
                transfers_timestamp: to_ts(GENESIS_TIME_IN_DAYS).into(),
            },
            Some(VestingScheduleOrHash::VestingSchedule(
                vesting_schedule.clone(),
            )),
            Some(to_nanos(4 * YEAR).into()),
            AccountId::from("whitelist"),
            Some(account_foundation()),
        );

        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(contract.get_owners_balance().0, 0);
        assert_eq!(contract.get_liquid_owners_balance().0, 0);
        assert_eq!(
            contract.get_unvested_amount(vesting_schedule.clone()).0,
            to_yocto(1000)
        );
        assert_eq!(
            contract
                .get_locked_vested_amount(vesting_schedule.clone())
                .0,
            to_yocto(0)
        );
        assert_eq!(contract.get_locked_amount().0, to_yocto(1000));

        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + YEAR);
        testing_env!(context.clone());
        assert_eq!(contract.get_owners_balance().0, to_yocto(0));
        assert_eq!(contract.get_liquid_owners_balance().0, to_yocto(0));
        assert_eq!(
            contract
                .get_locked_vested_amount(vesting_schedule.clone())
                .0,
            to_yocto(0)
        );
        assert_eq!(contract.get_locked_amount().0, to_yocto(1000));
        assert_eq!(
            contract.get_unvested_amount(vesting_schedule.clone()).0,
            to_yocto(1000)
        );

        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + 2 * YEAR);
        testing_env!(context.clone());
        assert_eq!(contract.get_owners_balance().0, to_yocto(250));
        assert_eq!(contract.get_liquid_owners_balance().0, to_yocto(250));
        assert_eq!(
            contract
                .get_locked_vested_amount(vesting_schedule.clone())
                .0,
            to_yocto(0)
        );
        assert_eq!(contract.get_locked_amount().0, to_yocto(750));
        assert_eq!(
            contract.get_unvested_amount(vesting_schedule.clone()).0,
            to_yocto(750)
        );

        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + 3 * YEAR);
        testing_env!(context.clone());
        assert_eq!(contract.get_owners_balance().0, to_yocto(500));
        assert_eq!(contract.get_liquid_owners_balance().0, to_yocto(500));
        assert_eq!(
            contract
                .get_locked_vested_amount(vesting_schedule.clone())
                .0,
            to_yocto(0)
        );
        assert_eq!(contract.get_locked_amount().0, to_yocto(500));
        assert_eq!(
            contract.get_unvested_amount(vesting_schedule.clone()).0,
            to_yocto(500)
        );

        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + 4 * YEAR);
        testing_env!(context.clone());
        assert_eq!(contract.get_owners_balance().0, to_yocto(750));
        assert_eq!(contract.get_liquid_owners_balance().0, to_yocto(750));
        assert_eq!(
            contract
                .get_locked_vested_amount(vesting_schedule.clone())
                .0,
            to_yocto(0)
        );
        assert_eq!(contract.get_locked_amount().0, to_yocto(250));
        assert_eq!(
            contract.get_unvested_amount(vesting_schedule.clone()).0,
            to_yocto(250)
        );

        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + 5 * YEAR);
        testing_env!(context.clone());
        assert_eq!(contract.get_owners_balance().0, to_yocto(1000));
        assert_eq!(
            contract.get_liquid_owners_balance().0,
            to_yocto(1000) - MIN_BALANCE_FOR_STORAGE
        );
        assert_eq!(
            contract
                .get_locked_vested_amount(vesting_schedule.clone())
                .0,
            to_yocto(0)
        );
        assert_eq!(contract.get_locked_amount().0, to_yocto(0));
        assert_eq!(
            contract.get_unvested_amount(vesting_schedule.clone()).0,
            to_yocto(0)
        );
    }

    #[test]
    fn test_termination_no_staking_with_release_duration() {
        let mut context = basic_context();
        testing_env!(context.clone());
        let vesting_schedule = new_vesting_schedule(0);
        let mut contract = new_contract_with_lockup_duration(
            true,
            Some(vesting_schedule.clone()),
            Some(to_nanos(4 * YEAR).into()),
            true,
            0,
        );

        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(contract.get_owners_balance().0, 0);
        assert_eq!(contract.get_liquid_owners_balance().0, 0);
        assert_eq!(
            contract
                .get_locked_vested_amount(vesting_schedule.clone())
                .0,
            to_yocto(250)
        );
        assert_eq!(contract.get_locked_amount().0, to_yocto(1000));
        assert_eq!(
            contract.get_unvested_amount(vesting_schedule.clone()).0,
            to_yocto(750)
        );

        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + 2 * YEAR);
        testing_env!(context.clone());
        assert_eq!(contract.get_owners_balance().0, to_yocto(500));
        assert_eq!(contract.get_liquid_owners_balance().0, to_yocto(500));
        assert_eq!(
            contract
                .get_locked_vested_amount(vesting_schedule.clone())
                .0,
            to_yocto(250)
        );
        assert_eq!(contract.get_locked_amount().0, to_yocto(500));
        assert_eq!(
            contract.get_unvested_amount(vesting_schedule.clone()).0,
            to_yocto(250)
        );

        // Terminating
        context.is_view = false;
        context.predecessor_account_id = account_foundation();
        context.signer_account_pk = public_key(3).into();
        testing_env!(context.clone());
        contract.terminate_vesting(Some(VestingScheduleWithSalt {
            vesting_schedule: vesting_schedule.clone(),
            salt: SALT.to_vec().into(),
        }));

        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(contract.get_owners_balance().0, to_yocto(500));
        assert_eq!(contract.get_liquid_owners_balance().0, to_yocto(500));
        assert_eq!(
            contract
                .get_locked_vested_amount(vesting_schedule.clone())
                .0,
            to_yocto(250)
        );
        assert_eq!(contract.get_locked_amount().0, to_yocto(500));
        assert_eq!(
            contract.get_unvested_amount(vesting_schedule.clone()).0,
            to_yocto(250)
        );
        assert_eq!(contract.get_terminated_unvested_balance().0, to_yocto(250));
        assert_eq!(
            contract.get_terminated_unvested_balance_deficit().0,
            to_yocto(0)
        );
        assert_eq!(
            contract.get_termination_status(),
            Some(TerminationStatus::ReadyToWithdraw)
        );

        // Withdrawing
        context.is_view = false;
        testing_env!(context.clone());
        let receiver_id = "near".to_string();
        contract.termination_withdraw(receiver_id.clone());
        context.account_balance = env::account_balance();

        context.predecessor_account_id = lockup_account();
        testing_env_with_promise_results(context.clone(), PromiseResult::Successful(vec![]));
        contract.on_withdraw_unvested_amount(to_yocto(250).into(), receiver_id);

        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(contract.get_owners_balance().0, to_yocto(500));
        assert_eq!(contract.get_liquid_owners_balance().0, to_yocto(500));
        assert_eq!(
            contract
                .get_locked_vested_amount(vesting_schedule.clone())
                .0,
            to_yocto(250)
        );
        assert_eq!(
            contract.get_unvested_amount(vesting_schedule.clone()).0,
            to_yocto(0)
        );
        assert_eq!(contract.get_terminated_unvested_balance().0, to_yocto(0));
        assert_eq!(contract.get_termination_status(), None);

        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + 3 * YEAR);
        testing_env!(context.clone());
        assert_eq!(contract.get_owners_balance().0, to_yocto(750));
        assert_eq!(
            contract.get_liquid_owners_balance().0,
            to_yocto(750) - MIN_BALANCE_FOR_STORAGE
        );
        assert_eq!(
            contract
                .get_locked_vested_amount(vesting_schedule.clone())
                .0,
            to_yocto(0)
        );
    }

    #[test]
    fn test_termination_before_cliff() {
        let lockup_amount = to_yocto(1000);
        let mut context = basic_context();
        testing_env!(context.clone());
        let vesting_schedule = new_vesting_schedule(YEAR);
        let mut contract = new_contract(true, Some(vesting_schedule.clone()), None, true);

        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(
            contract.get_vesting_information(),
            VestingInformation::VestingHash(
                VestingScheduleWithSalt {
                    vesting_schedule: vesting_schedule.clone(),
                    salt: SALT.to_vec().into(),
                }
                    .hash()
                    .into()
            )
        );
        assert_eq!(contract.get_owners_balance().0, 0);
        assert_eq!(contract.get_liquid_owners_balance().0, 0);
        assert_eq!(contract.get_locked_amount().0, lockup_amount);
        assert_eq!(
            contract.get_unvested_amount(vesting_schedule.clone()).0,
            lockup_amount
        );
        assert_eq!(
            contract
                .get_locked_vested_amount(vesting_schedule.clone())
                .0,
            0
        );

        // Terminating
        context.is_view = false;
        context.predecessor_account_id = account_foundation();
        context.signer_account_pk = public_key(3).into();
        testing_env!(context.clone());
        contract.terminate_vesting(Some(VestingScheduleWithSalt {
            vesting_schedule: vesting_schedule.clone(),
            salt: SALT.to_vec().into(),
        }));

        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(
            contract.get_vesting_information(),
            VestingInformation::Terminating(TerminationInformation {
                unvested_amount: lockup_amount.into(),
                status: TerminationStatus::ReadyToWithdraw,
            })
        );
        assert_eq!(contract.get_owners_balance().0, 0);
        assert_eq!(contract.get_liquid_owners_balance().0, 0);
        assert_eq!(contract.get_locked_amount().0, lockup_amount);
        assert_eq!(
            contract.get_unvested_amount(vesting_schedule.clone()).0,
            lockup_amount
        );
        assert_eq!(
            contract
                .get_locked_vested_amount(vesting_schedule.clone())
                .0,
            0
        );
        assert_eq!(contract.get_terminated_unvested_balance().0, lockup_amount);
        assert_eq!(
            contract.get_terminated_unvested_balance_deficit().0,
            MIN_BALANCE_FOR_STORAGE
        );
        assert_eq!(
            contract.get_termination_status(),
            Some(TerminationStatus::ReadyToWithdraw)
        );

        // Withdrawing
        context.is_view = false;
        testing_env!(context.clone());
        let receiver_id = account_foundation();
        contract.termination_withdraw(receiver_id.clone());
        context.account_balance = env::account_balance();
        assert_eq!(context.account_balance, MIN_BALANCE_FOR_STORAGE);

        context.predecessor_account_id = lockup_account();
        testing_env_with_promise_results(context.clone(), PromiseResult::Successful(vec![]));
        contract.on_withdraw_unvested_amount(
            (lockup_amount - MIN_BALANCE_FOR_STORAGE).into(),
            receiver_id,
        );

        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(
            contract.get_unvested_amount(vesting_schedule.clone()).0,
            MIN_BALANCE_FOR_STORAGE
        );
        assert_eq!(contract.get_owners_balance().0, 0);
        assert_eq!(contract.get_liquid_owners_balance().0, 0);
        assert_eq!(
            contract
                .get_locked_vested_amount(vesting_schedule.clone())
                .0,
            0
        );
        assert_eq!(
            contract.get_terminated_unvested_balance().0,
            MIN_BALANCE_FOR_STORAGE
        );
        assert_eq!(
            contract.get_terminated_unvested_balance_deficit().0,
            MIN_BALANCE_FOR_STORAGE
        );
        assert_eq!(
            contract.get_termination_status(),
            Some(TerminationStatus::ReadyToWithdraw)
        );
    }

    #[test]
    fn test_termination_with_staking() {
        let lockup_amount = to_yocto(1000);
        let mut context = basic_context();
        testing_env!(context.clone());
        let vesting_schedule = new_vesting_schedule(0);
        let mut contract = new_contract(true, Some(vesting_schedule.clone()), None, true);

        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(contract.get_owners_balance().0, to_yocto(0));
        assert_eq!(contract.get_liquid_owners_balance().0, to_yocto(0));
        assert_eq!(contract.get_locked_amount().0, lockup_amount);
        assert_eq!(
            contract.get_unvested_amount(vesting_schedule.clone()).0,
            to_yocto(750)
        );
        assert_eq!(
            contract
                .get_locked_vested_amount(vesting_schedule.clone())
                .0,
            to_yocto(250)
        );
        context.is_view = false;

        context.predecessor_account_id = account_owner();
        context.signer_account_pk = public_key(2).into();
        testing_env!(context.clone());

        // Selecting staking pool
        let staking_pool = "staking_pool".to_string();
        testing_env!(context.clone());
        contract.select_staking_pool(staking_pool.clone());

        context.predecessor_account_id = lockup_account();
        testing_env_with_promise_results(
            context.clone(),
            PromiseResult::Successful(b"true".to_vec()),
        );
        contract.on_whitelist_is_whitelisted(true, staking_pool.clone());

        // Deposit to the staking_pool
        let stake_amount = to_yocto(LOCKUP_NEAR - 100);
        context.predecessor_account_id = account_owner();
        testing_env!(context.clone());
        contract.deposit_to_staking_pool(stake_amount.into());
        context.account_balance = env::account_balance();

        context.predecessor_account_id = lockup_account();
        testing_env_with_promise_results(context.clone(), PromiseResult::Successful(vec![]));
        contract.on_staking_pool_deposit(stake_amount.into());

        // Staking on the staking pool
        context.predecessor_account_id = account_owner();
        testing_env!(context.clone());
        contract.stake(stake_amount.into());

        context.predecessor_account_id = lockup_account();
        testing_env_with_promise_results(context.clone(), PromiseResult::Successful(vec![]));
        contract.on_staking_pool_stake(stake_amount.into());

        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(contract.get_owners_balance().0, to_yocto(0));
        assert_eq!(contract.get_liquid_owners_balance().0, to_yocto(0));
        assert_eq!(contract.get_known_deposited_balance().0, stake_amount);
        assert_eq!(contract.get_locked_amount().0, lockup_amount);
        assert_eq!(
            contract
                .get_locked_vested_amount(vesting_schedule.clone())
                .0,
            to_yocto(250)
        );
        assert_eq!(
            contract.get_unvested_amount(vesting_schedule.clone()).0,
            to_yocto(750)
        );
        context.is_view = false;

        // Foundation terminating
        context.is_view = false;
        context.predecessor_account_id = account_foundation();
        context.signer_account_pk = public_key(3).into();
        testing_env!(context.clone());
        contract.terminate_vesting(Some(VestingScheduleWithSalt {
            vesting_schedule: vesting_schedule.clone(),
            salt: SALT.to_vec().into(),
        }));

        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(contract.get_owners_balance().0, to_yocto(0));
        assert_eq!(contract.get_liquid_owners_balance().0, to_yocto(0));
        assert_eq!(contract.get_locked_amount().0, lockup_amount);
        assert_eq!(
            contract.get_unvested_amount(vesting_schedule.clone()).0,
            to_yocto(750)
        );
        assert_eq!(
            contract
                .get_locked_vested_amount(vesting_schedule.clone())
                .0,
            to_yocto(250)
        );
        assert_eq!(contract.get_terminated_unvested_balance().0, to_yocto(750));
        assert_eq!(
            contract.get_terminated_unvested_balance_deficit().0,
            to_yocto(650) + MIN_BALANCE_FOR_STORAGE
        );
        assert_eq!(
            contract.get_termination_status(),
            Some(TerminationStatus::VestingTerminatedWithDeficit)
        );

        // Proceeding with unstaking from the pool due to termination.
        context.is_view = false;
        testing_env!(context.clone());
        contract.termination_prepare_to_withdraw();
        assert_eq!(
            contract.get_termination_status(),
            Some(TerminationStatus::UnstakingInProgress)
        );

        let stake_amount_with_rewards = stake_amount + to_yocto(50);
        context.predecessor_account_id = lockup_account();
        testing_env_with_promise_results(
            context.clone(),
            PromiseResult::Successful(format!("{}", stake_amount_with_rewards).into_bytes()),
        );
        contract.on_get_account_staked_balance_to_unstake(stake_amount_with_rewards.into());

        testing_env_with_promise_results(context.clone(), PromiseResult::Successful(vec![]));
        contract.on_staking_pool_unstake_for_termination(stake_amount_with_rewards.into());

        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(
            contract.get_termination_status(),
            Some(TerminationStatus::EverythingUnstaked)
        );

        // Proceeding with withdrawing from the pool due to termination.
        context.is_view = false;
        context.predecessor_account_id = account_foundation();
        testing_env!(context.clone());
        contract.termination_prepare_to_withdraw();
        assert_eq!(
            contract.get_termination_status(),
            Some(TerminationStatus::WithdrawingFromStakingPoolInProgress)
        );

        let withdraw_amount_with_extra_rewards = stake_amount_with_rewards + to_yocto(1);
        context.predecessor_account_id = lockup_account();
        testing_env_with_promise_results(
            context.clone(),
            PromiseResult::Successful(
                format!("{}", withdraw_amount_with_extra_rewards).into_bytes(),
            ),
        );
        contract
            .on_get_account_unstaked_balance_to_withdraw(withdraw_amount_with_extra_rewards.into());
        context.account_balance += withdraw_amount_with_extra_rewards;

        testing_env_with_promise_results(context.clone(), PromiseResult::Successful(vec![]));
        contract
            .on_staking_pool_withdraw_for_termination(withdraw_amount_with_extra_rewards.into());

        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(contract.get_owners_balance().0, to_yocto(51));
        assert_eq!(contract.get_liquid_owners_balance().0, to_yocto(51));
        assert_eq!(contract.get_locked_amount().0, lockup_amount);
        assert_eq!(
            contract.get_unvested_amount(vesting_schedule.clone()).0,
            to_yocto(750)
        );
        assert_eq!(contract.get_terminated_unvested_balance().0, to_yocto(750));
        assert_eq!(
            contract
                .get_locked_vested_amount(vesting_schedule.clone())
                .0,
            to_yocto(250)
        );
        assert_eq!(contract.get_terminated_unvested_balance_deficit().0, 0);
        assert_eq!(contract.get_known_deposited_balance().0, 0);
        assert_eq!(
            contract.get_termination_status(),
            Some(TerminationStatus::ReadyToWithdraw)
        );

        // Withdrawing
        context.is_view = false;
        context.predecessor_account_id = account_foundation();
        testing_env!(context.clone());
        let receiver_id = account_foundation();
        contract.termination_withdraw(receiver_id.clone());
        context.account_balance = env::account_balance();
        assert_eq!(context.account_balance, to_yocto(250 + 51));

        context.predecessor_account_id = lockup_account();
        testing_env_with_promise_results(context.clone(), PromiseResult::Successful(vec![]));
        contract.on_withdraw_unvested_amount(to_yocto(750).into(), receiver_id);

        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(contract.get_owners_balance().0, to_yocto(51));
        assert_eq!(contract.get_liquid_owners_balance().0, to_yocto(51));
        assert_eq!(contract.get_locked_amount().0, to_yocto(250));
        assert_eq!(
            contract
                .get_locked_vested_amount(vesting_schedule.clone())
                .0,
            to_yocto(250)
        );
        assert_eq!(contract.get_unvested_amount(vesting_schedule.clone()).0, 0);
        assert_eq!(contract.get_terminated_unvested_balance().0, 0);
        assert_eq!(contract.get_terminated_unvested_balance_deficit().0, 0);
        assert_eq!(contract.get_termination_status(), None);

        // Checking the balance becomes unlocked later
        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + YEAR + 1);
        testing_env!(context.clone());
        assert_eq!(contract.get_owners_balance().0, to_yocto(301));
        assert_eq!(
            contract.get_liquid_owners_balance().0,
            to_yocto(301) - MIN_BALANCE_FOR_STORAGE
        );
        assert_eq!(
            contract
                .get_locked_vested_amount(vesting_schedule.clone())
                .0,
            0
        );
        assert_eq!(contract.get_locked_amount().0, 0);
    }
}

'''
'''--- lockup/src/owner.rs ---
use crate::*;
use near_sdk::{near_bindgen, AccountId, Promise, PublicKey};

#[near_bindgen]
impl LockupContract {
    /// OWNER'S METHOD
    ///
    /// Requires 75 TGas (3 * BASE_GAS)
    ///
    /// Selects staking pool contract at the given account ID. The staking pool first has to be
    /// checked against the staking pool whitelist contract.
    pub fn select_staking_pool(&mut self, staking_pool_account_id: AccountId) -> Promise {
        self.assert_owner();
        assert!(
            env::is_valid_account_id(staking_pool_account_id.as_bytes()),
            "The staking pool account ID is invalid"
        );
        self.assert_staking_pool_is_not_selected();
        self.assert_no_termination();

        env::log(
            format!(
                "Selecting staking pool @{}. Going to check whitelist first.",
                staking_pool_account_id
            )
            .as_bytes(),
        );

        ext_whitelist::is_whitelisted(
            staking_pool_account_id.clone(),
            &self.staking_pool_whitelist_account_id,
            NO_DEPOSIT,
            gas::whitelist::IS_WHITELISTED,
        )
        .then(ext_self_owner::on_whitelist_is_whitelisted(
            staking_pool_account_id,
            &env::current_account_id(),
            NO_DEPOSIT,
            gas::owner_callbacks::ON_WHITELIST_IS_WHITELISTED,
        ))
    }

    /// OWNER'S METHOD
    ///
    /// Requires 25 TGas (1 * BASE_GAS)
    ///
    /// Unselects the current staking pool.
    /// It requires that there are no known deposits left on the currently selected staking pool.
    pub fn unselect_staking_pool(&mut self) {
        self.assert_owner();
        self.assert_staking_pool_is_idle();
        self.assert_no_termination();
        // NOTE: This is best effort checks. There is still some balance might be left on the
        // staking pool, but it's up to the owner whether to unselect the staking pool.
        // The contract doesn't care about leftovers.
        assert_eq!(
            self.staking_information.as_ref().unwrap().deposit_amount.0,
            0,
            "There is still a deposit on the staking pool"
        );

        env::log(
            format!(
                "Unselected current staking pool @{}.",
                self.staking_information
                    .as_ref()
                    .unwrap()
                    .staking_pool_account_id
            )
            .as_bytes(),
        );

        self.staking_information = None;
    }

    /// OWNER'S METHOD
    ///
    /// Requires 100 TGas (4 * BASE_GAS)
    ///
    /// Deposits the given extra amount to the staking pool
    pub fn deposit_to_staking_pool(&mut self, amount: WrappedBalance) -> Promise {
        self.assert_owner();
        assert!(amount.0 > 0, "Amount should be positive");
        self.assert_staking_pool_is_idle();
        self.assert_no_termination();
        assert!(
            self.get_account_balance().0 >= amount.0,
            "The balance that can be deposited to the staking pool is lower than the extra amount"
        );

        env::log(
            format!(
                "Depositing {} to the staking pool @{}",
                amount.0,
                self.staking_information
                    .as_ref()
                    .unwrap()
                    .staking_pool_account_id
            )
            .as_bytes(),
        );

        self.set_staking_pool_status(TransactionStatus::Busy);

        ext_staking_pool::deposit(
            &self
                .staking_information
                .as_ref()
                .unwrap()
                .staking_pool_account_id,
            amount.0,
            gas::staking_pool::DEPOSIT,
        )
        .then(ext_self_owner::on_staking_pool_deposit(
            amount,
            &env::current_account_id(),
            NO_DEPOSIT,
            gas::owner_callbacks::ON_STAKING_POOL_DEPOSIT,
        ))
    }

    /// OWNER'S METHOD
    ///
    /// Requires 125 TGas (5 * BASE_GAS)
    ///
    /// Deposits and stakes the given extra amount to the selected staking pool
    pub fn deposit_and_stake(&mut self, amount: WrappedBalance) -> Promise {
        self.assert_owner();
        assert!(amount.0 > 0, "Amount should be positive");
        self.assert_staking_pool_is_idle();
        self.assert_no_termination();
        assert!(
            self.get_account_balance().0 >= amount.0,
            "The balance that can be deposited to the staking pool is lower than the extra amount"
        );

        env::log(
            format!(
                "Depositing and staking {} to the staking pool @{}",
                amount.0,
                self.staking_information
                    .as_ref()
                    .unwrap()
                    .staking_pool_account_id
            )
            .as_bytes(),
        );

        self.set_staking_pool_status(TransactionStatus::Busy);

        ext_staking_pool::deposit_and_stake(
            &self
                .staking_information
                .as_ref()
                .unwrap()
                .staking_pool_account_id,
            amount.0,
            gas::staking_pool::DEPOSIT_AND_STAKE,
        )
        .then(ext_self_owner::on_staking_pool_deposit_and_stake(
            amount,
            &env::current_account_id(),
            NO_DEPOSIT,
            gas::owner_callbacks::ON_STAKING_POOL_DEPOSIT_AND_STAKE,
        ))
    }

    /// OWNER'S METHOD
    ///
    /// Requires 75 TGas (3 * BASE_GAS)
    ///
    /// Retrieves total balance from the staking pool and remembers it internally.
    /// This method is helpful when the owner received some rewards for staking and wants to
    /// transfer them back to this account for withdrawal. In order to know the actual liquid
    /// balance on the account, this contract needs to query the staking pool.
    pub fn refresh_staking_pool_balance(&mut self) -> Promise {
        self.assert_owner();
        self.assert_staking_pool_is_idle();
        self.assert_no_termination();

        env::log(
            format!(
                "Fetching total balance from the staking pool @{}",
                self.staking_information
                    .as_ref()
                    .unwrap()
                    .staking_pool_account_id
            )
            .as_bytes(),
        );

        self.set_staking_pool_status(TransactionStatus::Busy);

        ext_staking_pool::get_account_total_balance(
            env::current_account_id(),
            &self
                .staking_information
                .as_ref()
                .unwrap()
                .staking_pool_account_id,
            NO_DEPOSIT,
            gas::staking_pool::GET_ACCOUNT_TOTAL_BALANCE,
        )
        .then(ext_self_owner::on_get_account_total_balance(
            &env::current_account_id(),
            NO_DEPOSIT,
            gas::owner_callbacks::ON_GET_ACCOUNT_TOTAL_BALANCE,
        ))
    }

    /// OWNER'S METHOD
    ///
    /// Requires 125 TGas (5 * BASE_GAS)
    ///
    /// Withdraws the given amount from the staking pool
    pub fn withdraw_from_staking_pool(&mut self, amount: WrappedBalance) -> Promise {
        self.assert_owner();
        assert!(amount.0 > 0, "Amount should be positive");
        self.assert_staking_pool_is_idle();
        self.assert_no_termination();

        env::log(
            format!(
                "Withdrawing {} from the staking pool @{}",
                amount.0,
                self.staking_information
                    .as_ref()
                    .unwrap()
                    .staking_pool_account_id
            )
            .as_bytes(),
        );

        self.set_staking_pool_status(TransactionStatus::Busy);

        ext_staking_pool::withdraw(
            amount,
            &self
                .staking_information
                .as_ref()
                .unwrap()
                .staking_pool_account_id,
            NO_DEPOSIT,
            gas::staking_pool::WITHDRAW,
        )
        .then(ext_self_owner::on_staking_pool_withdraw(
            amount,
            &env::current_account_id(),
            NO_DEPOSIT,
            gas::owner_callbacks::ON_STAKING_POOL_WITHDRAW,
        ))
    }

    /// OWNER'S METHOD
    ///
    /// Requires 175 TGas (7 * BASE_GAS)
    ///
    /// Tries to withdraws all unstaked balance from the staking pool
    pub fn withdraw_all_from_staking_pool(&mut self) -> Promise {
        self.assert_owner();
        self.assert_staking_pool_is_idle();
        self.assert_no_termination();

        env::log(
            format!(
                "Going to query the unstaked balance at the staking pool @{}",
                self.staking_information
                    .as_ref()
                    .unwrap()
                    .staking_pool_account_id
            )
            .as_bytes(),
        );

        self.set_staking_pool_status(TransactionStatus::Busy);

        ext_staking_pool::get_account_unstaked_balance(
            env::current_account_id(),
            &self
                .staking_information
                .as_ref()
                .unwrap()
                .staking_pool_account_id,
            NO_DEPOSIT,
            gas::staking_pool::GET_ACCOUNT_UNSTAKED_BALANCE,
        )
        .then(
            ext_self_owner::on_get_account_unstaked_balance_to_withdraw_by_owner(
                &env::current_account_id(),
                NO_DEPOSIT,
                gas::owner_callbacks::ON_GET_ACCOUNT_UNSTAKED_BALANCE_TO_WITHDRAW_BY_OWNER,
            ),
        )
    }

    /// OWNER'S METHOD
    ///
    /// Requires 125 TGas (5 * BASE_GAS)
    ///
    /// Stakes the given extra amount at the staking pool
    pub fn stake(&mut self, amount: WrappedBalance) -> Promise {
        self.assert_owner();
        assert!(amount.0 > 0, "Amount should be positive");
        self.assert_staking_pool_is_idle();
        self.assert_no_termination();

        env::log(
            format!(
                "Staking {} at the staking pool @{}",
                amount.0,
                self.staking_information
                    .as_ref()
                    .unwrap()
                    .staking_pool_account_id
            )
            .as_bytes(),
        );

        self.set_staking_pool_status(TransactionStatus::Busy);

        ext_staking_pool::stake(
            amount,
            &self
                .staking_information
                .as_ref()
                .unwrap()
                .staking_pool_account_id,
            NO_DEPOSIT,
            gas::staking_pool::STAKE,
        )
        .then(ext_self_owner::on_staking_pool_stake(
            amount,
            &env::current_account_id(),
            NO_DEPOSIT,
            gas::owner_callbacks::ON_STAKING_POOL_STAKE,
        ))
    }

    /// OWNER'S METHOD
    ///
    /// Requires 125 TGas (5 * BASE_GAS)
    ///
    /// Unstakes the given amount at the staking pool
    pub fn unstake(&mut self, amount: WrappedBalance) -> Promise {
        self.assert_owner();
        assert!(amount.0 > 0, "Amount should be positive");
        self.assert_staking_pool_is_idle();
        self.assert_no_termination();

        env::log(
            format!(
                "Unstaking {} from the staking pool @{}",
                amount.0,
                self.staking_information
                    .as_ref()
                    .unwrap()
                    .staking_pool_account_id
            )
            .as_bytes(),
        );

        self.set_staking_pool_status(TransactionStatus::Busy);

        ext_staking_pool::unstake(
            amount,
            &self
                .staking_information
                .as_ref()
                .unwrap()
                .staking_pool_account_id,
            NO_DEPOSIT,
            gas::staking_pool::UNSTAKE,
        )
        .then(ext_self_owner::on_staking_pool_unstake(
            amount,
            &env::current_account_id(),
            NO_DEPOSIT,
            gas::owner_callbacks::ON_STAKING_POOL_UNSTAKE,
        ))
    }

    /// OWNER'S METHOD
    ///
    /// Requires 125 TGas (5 * BASE_GAS)
    ///
    /// Unstakes all tokens from the staking pool
    pub fn unstake_all(&mut self) -> Promise {
        self.assert_owner();
        self.assert_staking_pool_is_idle();
        self.assert_no_termination();

        env::log(
            format!(
                "Unstaking all tokens from the staking pool @{}",
                self.staking_information
                    .as_ref()
                    .unwrap()
                    .staking_pool_account_id
            )
            .as_bytes(),
        );

        self.set_staking_pool_status(TransactionStatus::Busy);

        ext_staking_pool::unstake_all(
            &self
                .staking_information
                .as_ref()
                .unwrap()
                .staking_pool_account_id,
            NO_DEPOSIT,
            gas::staking_pool::UNSTAKE_ALL,
        )
        .then(ext_self_owner::on_staking_pool_unstake_all(
            &env::current_account_id(),
            NO_DEPOSIT,
            gas::owner_callbacks::ON_STAKING_POOL_UNSTAKE_ALL,
        ))
    }

    /// OWNER'S METHOD
    ///
    /// Requires 75 TGas (3 * BASE_GAS)
    /// Not intended to hand over the access to someone else except the owner
    ///
    /// Calls voting contract to validate if the transfers were enabled by voting. Once transfers
    /// are enabled, they can't be disabled anymore.
    pub fn check_transfers_vote(&mut self) -> Promise {
        self.assert_owner();
        self.assert_transfers_disabled();
        self.assert_no_termination();

        let transfer_poll_account_id = match &self.lockup_information.transfers_information {
            TransfersInformation::TransfersDisabled {
                transfer_poll_account_id,
            } => transfer_poll_account_id,
            _ => unreachable!(),
        };

        env::log(
            format!(
                "Checking that transfers are enabled at the transfer poll contract @{}",
                transfer_poll_account_id,
            )
            .as_bytes(),
        );

        ext_transfer_poll::get_result(
            &transfer_poll_account_id,
            NO_DEPOSIT,
            gas::transfer_poll::GET_RESULT,
        )
        .then(ext_self_owner::on_get_result_from_transfer_poll(
            &env::current_account_id(),
            NO_DEPOSIT,
            gas::owner_callbacks::ON_VOTING_GET_RESULT,
        ))
    }

    /// OWNER'S METHOD
    ///
    /// Requires 50 TGas (2 * BASE_GAS)
    /// Not intended to hand over the access to someone else except the owner
    ///
    /// Transfers the given amount to the given receiver account ID.
    /// This requires transfers to be enabled within the voting contract.
    pub fn transfer(&mut self, amount: WrappedBalance, receiver_id: AccountId) -> Promise {
        self.assert_owner();
        assert!(amount.0 > 0, "Amount should be positive");
        assert!(
            env::is_valid_account_id(receiver_id.as_bytes()),
            "The receiver account ID is invalid"
        );
        self.assert_transfers_enabled();
        self.assert_no_staking_or_idle();
        self.assert_no_termination();
        assert!(
            self.get_liquid_owners_balance().0 >= amount.0,
            "The available liquid balance {} is smaller than the requested transfer amount {}",
            self.get_liquid_owners_balance().0,
            amount.0,
        );

        env::log(format!("Transferring {} to account @{}", amount.0, receiver_id).as_bytes());

        Promise::new(receiver_id).transfer(amount.0)
    }

    /// OWNER'S METHOD
    ///
    /// Requires 50 TGas (2 * BASE_GAS)
    /// Not intended to hand over the access to someone else except the owner
    ///
    /// Adds full access key with the given public key to the account.
    /// The following requirements should be met:
    /// - The contract is fully vested;
    /// - Lockup duration has expired;
    /// - Transfers are enabled;
    /// - If there’s a termination made by foundation, it has to be finished.
    /// Full access key will allow owner to use this account as a regular account and remove
    /// the contract.
    pub fn add_full_access_key(&mut self, new_public_key: Base58PublicKey) -> Promise {
        self.assert_owner();
        self.assert_transfers_enabled();
        self.assert_no_staking_or_idle();
        self.assert_no_termination();
        assert_eq!(self.get_locked_amount().0, 0, "Tokens are still locked/unvested");

        env::log(b"Adding a full access key");

        let new_public_key: PublicKey = new_public_key.into();

        Promise::new(env::current_account_id()).add_full_access_key(new_public_key)
    }
}

'''
'''--- lockup/src/owner_callbacks.rs ---
use crate::*;
use near_sdk::{near_bindgen, PromiseOrValue, assert_self, is_promise_success};

#[near_bindgen]
impl LockupContract {
    /// Called after a given `staking_pool_account_id` was checked in the whitelist.
    pub fn on_whitelist_is_whitelisted(
        &mut self,
        #[callback] is_whitelisted: bool,
        staking_pool_account_id: AccountId,
    ) -> bool {
        assert_self();
        assert!(
            is_whitelisted,
            "The given staking pool account ID is not whitelisted"
        );
        self.assert_staking_pool_is_not_selected();
        self.assert_no_termination();
        self.staking_information = Some(StakingInformation {
            staking_pool_account_id,
            status: TransactionStatus::Idle,
            deposit_amount: 0.into(),
        });
        true
    }

    /// Called after a deposit amount was transferred out of this account to the staking pool.
    /// This method needs to update staking pool status.
    pub fn on_staking_pool_deposit(&mut self, amount: WrappedBalance) -> bool {
        assert_self();

        let deposit_succeeded = is_promise_success();
        self.set_staking_pool_status(TransactionStatus::Idle);

        if deposit_succeeded {
            self.staking_information.as_mut().unwrap().deposit_amount.0 += amount.0;
            env::log(
                format!(
                    "The deposit of {} to @{} succeeded",
                    amount.0,
                    self.staking_information
                        .as_ref()
                        .unwrap()
                        .staking_pool_account_id
                )
                .as_bytes(),
            );
        } else {
            env::log(
                format!(
                    "The deposit of {} to @{} has failed",
                    amount.0,
                    self.staking_information
                        .as_ref()
                        .unwrap()
                        .staking_pool_account_id
                )
                .as_bytes(),
            );
        }
        deposit_succeeded
    }

    /// Called after a deposit amount was transferred out of this account to the staking pool and it
    /// was staked on the staking pool.
    /// This method needs to update staking pool status.
    pub fn on_staking_pool_deposit_and_stake(&mut self, amount: WrappedBalance) -> bool {
        assert_self();

        let deposit_and_stake_succeeded = is_promise_success();
        self.set_staking_pool_status(TransactionStatus::Idle);

        if deposit_and_stake_succeeded {
            self.staking_information.as_mut().unwrap().deposit_amount.0 += amount.0;
            env::log(
                format!(
                    "The deposit and stake of {} to @{} succeeded",
                    amount.0,
                    self.staking_information
                        .as_ref()
                        .unwrap()
                        .staking_pool_account_id
                )
                .as_bytes(),
            );
        } else {
            env::log(
                format!(
                    "The deposit and stake of {} to @{} has failed",
                    amount.0,
                    self.staking_information
                        .as_ref()
                        .unwrap()
                        .staking_pool_account_id
                )
                .as_bytes(),
            );
        }
        deposit_and_stake_succeeded
    }

    /// Called after the given amount was requested to transfer out from the staking pool to this
    /// account.
    /// This method needs to update staking pool status.
    pub fn on_staking_pool_withdraw(&mut self, amount: WrappedBalance) -> bool {
        assert_self();

        let withdraw_succeeded = is_promise_success();
        self.set_staking_pool_status(TransactionStatus::Idle);

        if withdraw_succeeded {
            {
                let staking_information = self.staking_information.as_mut().unwrap();
                // Due to staking rewards the deposit amount can become negative.
                staking_information.deposit_amount.0 = staking_information
                    .deposit_amount
                    .0
                    .saturating_sub(amount.0);
            }
            env::log(
                format!(
                    "The withdrawal of {} from @{} succeeded",
                    amount.0,
                    self.staking_information
                        .as_ref()
                        .unwrap()
                        .staking_pool_account_id
                )
                .as_bytes(),
            );
        } else {
            env::log(
                format!(
                    "The withdrawal of {} from @{} failed",
                    amount.0,
                    self.staking_information
                        .as_ref()
                        .unwrap()
                        .staking_pool_account_id
                )
                .as_bytes(),
            );
        }
        withdraw_succeeded
    }

    /// Called after the extra amount stake was staked in the staking pool contract.
    /// This method needs to update staking pool status.
    pub fn on_staking_pool_stake(&mut self, amount: WrappedBalance) -> bool {
        assert_self();

        let stake_succeeded = is_promise_success();
        self.set_staking_pool_status(TransactionStatus::Idle);

        if stake_succeeded {
            env::log(
                format!(
                    "Staking of {} at @{} succeeded",
                    amount.0,
                    self.staking_information
                        .as_ref()
                        .unwrap()
                        .staking_pool_account_id
                )
                .as_bytes(),
            );
        } else {
            env::log(
                format!(
                    "Staking {} at @{} has failed",
                    amount.0,
                    self.staking_information
                        .as_ref()
                        .unwrap()
                        .staking_pool_account_id
                )
                .as_bytes(),
            );
        }
        stake_succeeded
    }

    /// Called after the given amount was unstaked at the staking pool contract.
    /// This method needs to update staking pool status.
    pub fn on_staking_pool_unstake(&mut self, amount: WrappedBalance) -> bool {
        assert_self();

        let unstake_succeeded = is_promise_success();
        self.set_staking_pool_status(TransactionStatus::Idle);

        if unstake_succeeded {
            env::log(
                format!(
                    "Unstaking of {} at @{} succeeded",
                    amount.0,
                    self.staking_information
                        .as_ref()
                        .unwrap()
                        .staking_pool_account_id
                )
                .as_bytes(),
            );
        } else {
            env::log(
                format!(
                    "Unstaking {} at @{} has failed",
                    amount.0,
                    self.staking_information
                        .as_ref()
                        .unwrap()
                        .staking_pool_account_id
                )
                .as_bytes(),
            );
        }
        unstake_succeeded
    }

    /// Called after all tokens were unstaked at the staking pool contract
    /// This method needs to update staking pool status.
    pub fn on_staking_pool_unstake_all(&mut self) -> bool {
        assert_self();

        let unstake_all_succeeded = is_promise_success();
        self.set_staking_pool_status(TransactionStatus::Idle);

        if unstake_all_succeeded {
            env::log(
                format!(
                    "Unstaking all at @{} succeeded",
                    self.staking_information
                        .as_ref()
                        .unwrap()
                        .staking_pool_account_id
                )
                .as_bytes(),
            );
        } else {
            env::log(
                format!(
                    "Unstaking all at @{} has failed",
                    self.staking_information
                        .as_ref()
                        .unwrap()
                        .staking_pool_account_id
                )
                .as_bytes(),
            );
        }
        unstake_all_succeeded
    }

    /// Called after the transfer voting contract was checked for the vote result.
    pub fn on_get_result_from_transfer_poll(
        &mut self,
        #[callback] poll_result: PollResult,
    ) -> bool {
        assert_self();
        self.assert_transfers_disabled();

        if let Some(transfers_timestamp) = poll_result {
            env::log(
                format!(
                    "Transfers were successfully enabled at {}",
                    transfers_timestamp.0
                )
                .as_bytes(),
            );
            self.lockup_information.transfers_information =
                TransfersInformation::TransfersEnabled {
                    transfers_timestamp,
                };
            true
        } else {
            env::log(b"The transfers are not enabled yet");
            false
        }
    }

    /// Called after the request to get the current total balance from the staking pool.
    pub fn on_get_account_total_balance(&mut self, #[callback] total_balance: WrappedBalance) {
        assert_self();
        self.set_staking_pool_status(TransactionStatus::Idle);

        env::log(
            format!(
                "The current total balance on the staking pool is {}",
                total_balance.0
            )
            .as_bytes(),
        );

        self.staking_information.as_mut().unwrap().deposit_amount = total_balance;
    }

    /// Called after the request to get the current unstaked balance to withdraw everything by th
    /// owner.
    pub fn on_get_account_unstaked_balance_to_withdraw_by_owner(
        &mut self,
        #[callback] unstaked_balance: WrappedBalance,
    ) -> PromiseOrValue<bool> {
        assert_self();
        if unstaked_balance.0 > 0 {
            // Need to withdraw
            env::log(
                format!(
                    "Withdrawing {} from the staking pool @{}",
                    unstaked_balance.0,
                    self.staking_information
                        .as_ref()
                        .unwrap()
                        .staking_pool_account_id
                )
                .as_bytes(),
            );

            ext_staking_pool::withdraw(
                unstaked_balance,
                &self
                    .staking_information
                    .as_ref()
                    .unwrap()
                    .staking_pool_account_id,
                NO_DEPOSIT,
                gas::staking_pool::WITHDRAW,
            )
            .then(ext_self_owner::on_staking_pool_withdraw(
                unstaked_balance,
                &env::current_account_id(),
                NO_DEPOSIT,
                gas::owner_callbacks::ON_STAKING_POOL_WITHDRAW,
            ))
            .into()
        } else {
            env::log(b"No unstaked balance on the staking pool to withdraw");
            self.set_staking_pool_status(TransactionStatus::Idle);
            PromiseOrValue::Value(true)
        }
    }
}

'''
'''--- lockup/src/tests/test_utils.rs ---
use near_sdk::json_types::Base58PublicKey;
use near_sdk::{AccountId, MockedBlockchain, PromiseResult, VMContext};

pub const LOCKUP_NEAR: u128 = 1000;
pub const GENESIS_TIME_IN_DAYS: u64 = 500;
pub const YEAR: u64 = 365;

pub fn lockup_account() -> AccountId {
    "lockup".to_string()
}

pub fn system_account() -> AccountId {
    "system".to_string()
}

pub fn account_owner() -> AccountId {
    "account_owner".to_string()
}

pub fn non_owner() -> AccountId {
    "non_owner".to_string()
}

pub fn account_foundation() -> AccountId {
    "near".to_string()
}

pub fn to_yocto(near_balance: u128) -> u128 {
    near_balance * 10u128.pow(24)
}

pub fn to_nanos(num_days: u64) -> u64 {
    num_days * 86400_000_000_000
}

pub fn to_ts(num_days: u64) -> u64 {
    // 2018-08-01 UTC in nanoseconds
    1533081600_000_000_000 + to_nanos(num_days)
}

pub fn assert_almost_eq_with_max_delta(left: u128, right: u128, max_delta: u128) {
    assert!(
        std::cmp::max(left, right) - std::cmp::min(left, right) < max_delta,
        "{}",
        format!(
            "Left {} is not even close to Right {} within delta {}",
            left, right, max_delta
        )
    );
}

pub fn assert_almost_eq(left: u128, right: u128) {
    assert_almost_eq_with_max_delta(left, right, to_yocto(10));
}

pub fn get_context(
    predecessor_account_id: AccountId,
    account_balance: u128,
    account_locked_balance: u128,
    block_timestamp: u64,
    is_view: bool,
) -> VMContext {
    VMContext {
        current_account_id: lockup_account(),
        signer_account_id: predecessor_account_id.clone(),
        signer_account_pk: vec![0, 1, 2],
        predecessor_account_id,
        input: vec![],
        block_index: 1,
        block_timestamp,
        epoch_height: 1,
        account_balance,
        account_locked_balance,
        storage_usage: 10u64.pow(6),
        attached_deposit: 0,
        prepaid_gas: 10u64.pow(15),
        random_seed: vec![0, 1, 2],
        is_view,
        output_data_receivers: vec![],
    }
}

pub fn testing_env_with_promise_results(context: VMContext, promise_result: PromiseResult) {
    let storage = near_sdk::env::take_blockchain_interface()
        .unwrap()
        .as_mut_mocked_blockchain()
        .unwrap()
        .take_storage();

    near_sdk::env::set_blockchain_interface(Box::new(MockedBlockchain::new(
        context,
        Default::default(),
        Default::default(),
        vec![promise_result],
        storage,
        Default::default(),
        None,
    )));
}

pub fn public_key(byte_val: u8) -> Base58PublicKey {
    let mut pk = vec![byte_val; 33];
    pk[0] = 0;
    Base58PublicKey(pk)
}

'''
'''--- lockup/src/types.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::{Base64VecU8, U128, U64};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{env, AccountId, Balance};
use uint::construct_uint;

construct_uint! {
    /// 256-bit unsigned integer.
    pub struct U256(4);
}

/// Raw type for duration in nanoseconds
pub type Duration = u64;
/// Raw type for timestamp in nanoseconds
pub type Timestamp = u64;

/// Timestamp in nanosecond wrapped into a struct for JSON serialization as a string.
pub type WrappedTimestamp = U64;
/// Duration in nanosecond wrapped into a struct for JSON serialization as a string.
pub type WrappedDuration = U64;
/// Balance wrapped into a struct for JSON serialization as a string.
pub type WrappedBalance = U128;

/// Hash of Vesting schedule.
pub type Hash = Vec<u8>;

/// Contains information about token lockups.
#[derive(BorshDeserialize, BorshSerialize)]
pub struct LockupInformation {
    /// The amount in yocto-NEAR tokens locked for this account.
    pub lockup_amount: Balance,
    /// The amount of tokens that were withdrawn by NEAR foundation due to early termination
    /// of vesting.
    /// This amount has to be accounted separately from the lockup_amount to make sure
    /// linear release is not being affected.
    pub termination_withdrawn_tokens: Balance,
    /// [deprecated] - the duration in nanoseconds of the lockup period from
    /// the moment the transfers are enabled. During this period tokens are locked and
    /// the release doesn't start. Instead of this, use `lockup_timestamp` and `release_duration`
    pub lockup_duration: Duration,
    /// If present, it is the duration when the full lockup amount will be available. The tokens
    /// are linearly released from the moment tokens are unlocked, defined by:
    /// `max(transfers_timestamp + lockup_duration, lockup_timestamp)`.
    /// If not present, the tokens are not locked (though, vesting logic could be used).
    pub release_duration: Option<Duration>,
    /// The optional absolute lockup timestamp in nanoseconds which locks the tokens until this
    /// timestamp passes. Until this moment the tokens are locked and the release doesn't start.
    /// If not present, `transfers_timestamp` will be used.
    pub lockup_timestamp: Option<Timestamp>,
    /// The information about the transfers. Either transfers are already enabled, then it contains
    /// the timestamp when they were enabled. Or the transfers are currently disabled and
    /// it contains the account ID of the transfer poll contract.
    pub transfers_information: TransfersInformation,
}

/// Contains information about the transfers. Whether transfers are enabled or disabled.
#[derive(BorshDeserialize, BorshSerialize, Deserialize, Serialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub enum TransfersInformation {
    /// The timestamp when the transfers were enabled.
    TransfersEnabled {
        transfers_timestamp: WrappedTimestamp,
    },
    /// The account ID of the transfers poll contract, to check if the transfers are enabled.
    /// The lockup period can start only after the transfer voted to be enabled.
    /// At the launch of the network transfers are disabled for all lockup contracts, once transfers
    /// are enabled, they can't be disabled and don't need to be checked again.
    TransfersDisabled { transfer_poll_account_id: AccountId },
}

/// Describes the status of transactions with the staking pool contract or terminated unvesting
/// amount withdrawal.
#[derive(BorshDeserialize, BorshSerialize, Deserialize, Serialize, PartialEq)]
#[serde(crate = "near_sdk::serde")]
pub enum TransactionStatus {
    /// There are no transactions in progress.
    Idle,
    /// There is a transaction in progress.
    Busy,
}

/// Contains information about current stake and delegation.
#[derive(BorshDeserialize, BorshSerialize)]
pub struct StakingInformation {
    /// The Account ID of the staking pool contract.
    pub staking_pool_account_id: AccountId,

    /// Contains status whether there is a transaction in progress.
    pub status: TransactionStatus,

    /// The amount of tokens that were deposited from this account to the staking pool.
    /// NOTE: The unstaked amount on the staking pool might be higher due to staking rewards.
    pub deposit_amount: WrappedBalance,
}

/// Contains information about vesting schedule.
#[derive(BorshDeserialize, BorshSerialize, Deserialize, Serialize, Clone, PartialEq, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct VestingSchedule {
    /// The timestamp in nanosecond when the vesting starts. E.g. the start date of employment.
    pub start_timestamp: WrappedTimestamp,
    /// The timestamp in nanosecond when the first part of lockup tokens becomes vested.
    /// The remaining tokens will vest continuously until they are fully vested.
    /// Example: a 1 year of employment at which moment the 1/4 of tokens become vested.
    pub cliff_timestamp: WrappedTimestamp,
    /// The timestamp in nanosecond when the vesting ends.
    pub end_timestamp: WrappedTimestamp,
}

impl VestingSchedule {
    pub fn assert_valid(&self) {
        assert!(
            self.start_timestamp.0 <= self.cliff_timestamp.0,
            "Cliff timestamp can't be earlier than vesting start timestamp"
        );
        assert!(
            self.cliff_timestamp.0 <= self.end_timestamp.0,
            "Cliff timestamp can't be later than vesting end timestamp"
        );
        assert!(
            self.start_timestamp.0 < self.end_timestamp.0,
            "The total vesting time should be positive"
        );
    }
}

/// Initialization argument type to define the vesting schedule
#[derive(Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub enum VestingScheduleOrHash {
    /// [deprecated] After transfers are enabled, only public schedule is used.
    /// The vesting schedule is private and this is a hash of (vesting_schedule, salt).
    /// In JSON, the hash has to be encoded with base64 to a string.
    VestingHash(Base64VecU8),
    /// The vesting schedule (public)
    VestingSchedule(VestingSchedule),
}

/// Contains information about vesting that contains vesting schedule and termination information.
#[derive(Serialize, BorshDeserialize, BorshSerialize, PartialEq, Clone, Debug)]
#[serde(crate = "near_sdk::serde")]
pub enum VestingInformation {
    None,
    /// [deprecated] After transfers are enabled, only public schedule is used.
    /// Vesting schedule is hashed for privacy and only will be revealed if the NEAR foundation
    /// has to terminate vesting.
    /// The contract assume the vesting schedule doesn't affect lockup release and duration, because
    /// the vesting started before transfers were enabled and the duration is shorter or the same.
    VestingHash(Base64VecU8),
    /// Explicit vesting schedule.
    VestingSchedule(VestingSchedule),
    /// The information about the early termination of the vesting schedule.
    /// It means the termination of the vesting is currently in progress.
    /// Once the unvested amount is transferred out, `VestingInformation` is removed.
    Terminating(TerminationInformation),
}

/// Describes the status of transactions with the staking pool contract or terminated unvesting
/// amount withdrawal.
#[derive(
    BorshDeserialize, BorshSerialize, Deserialize, Serialize, PartialEq, Copy, Clone, Debug,
)]
#[serde(crate = "near_sdk::serde")]
pub enum TerminationStatus {
    /// Initial stage of the termination in case there are deficit on the account.
    VestingTerminatedWithDeficit,
    /// A transaction to unstake everything is in progress.
    UnstakingInProgress,
    /// The transaction to unstake everything from the staking pool has completed.
    EverythingUnstaked,
    /// A transaction to withdraw everything from the staking pool is in progress.
    WithdrawingFromStakingPoolInProgress,
    /// Everything is withdrawn from the staking pool. Ready to withdraw out of the account.
    ReadyToWithdraw,
    /// A transaction to withdraw tokens from the account is in progress.
    WithdrawingFromAccountInProgress,
}

/// Contains information about early termination of the vesting schedule.
#[derive(BorshDeserialize, BorshSerialize, Deserialize, Serialize, PartialEq, Clone, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct TerminationInformation {
    /// The amount of tokens that are unvested and has to be transferred back to NEAR Foundation.
    /// These tokens are effectively locked and can't be transferred out and can't be restaked.
    pub unvested_amount: WrappedBalance,

    /// The status of the withdrawal. When the unvested amount is in progress of withdrawal the
    /// status will be marked as busy, to avoid withdrawing the funds twice.
    pub status: TerminationStatus,
}

/// The result of the transfer poll.
/// Contains The timestamp when the proposal was voted in.
pub type PollResult = Option<WrappedTimestamp>;

/// Contains a vesting schedule with a salt.
#[derive(BorshSerialize, Deserialize, Serialize, Clone, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct VestingScheduleWithSalt {
    /// The vesting schedule
    pub vesting_schedule: VestingSchedule,
    /// Salt to make the hash unique
    pub salt: Base64VecU8,
}

impl VestingScheduleWithSalt {
    pub fn hash(&self) -> Hash {
        env::sha256(&self.try_to_vec().expect("Failed to serialize"))
    }
}

'''
'''--- lockup/tests/spec.rs ---
use lockup_contract::{
    LockupContractContract, TerminationStatus, TransfersInformation, VestingSchedule,
    VestingScheduleOrHash, VestingScheduleWithSalt, WrappedBalance, MIN_BALANCE_FOR_STORAGE
};
use near_sdk::borsh::BorshSerialize;
use near_sdk::json_types::{Base58PublicKey, U128};
use near_sdk::serde_json::json;
use near_sdk::{AccountId, Balance};
use near_sdk_sim::runtime::GenesisConfig;
use near_sdk_sim::{deploy, init_simulator, to_yocto, UserAccount};
use quickcheck_macros::quickcheck;
use std::convert::TryInto;

pub const MAX_GAS: u64 = 300000000000000;
pub const NO_DEPOSIT: Balance = 0;
pub const LOCKUP_ACCOUNT_ID: &str = "lockup";

const STAKING_POOL_WHITELIST_ACCOUNT_ID: &str = "staking-pool-whitelist";
const STAKING_POOL_ACCOUNT_ID: &str = "staking-pool";
const TRANSFER_POLL_ACCOUNT_ID: &str = "transfer-poll";

pub fn public_key(byte_val: u8) -> Base58PublicKey {
    let mut pk = vec![byte_val; 33];
    pk[0] = 0;
    Base58PublicKey(pk)
}

pub fn assert_almost_eq_with_max_delta(left: u128, right: u128, max_delta: u128) {
    assert!(
        std::cmp::max(left, right) - std::cmp::min(left, right) <= max_delta,
        "{}",
        format!(
            "Left {} is not even close to Right {} within delta {}",
            left, right, max_delta
        )
    );
}

pub fn assert_eq_with_gas(left: u128, right: u128) {
    assert_almost_eq_with_max_delta(left, right, to_yocto("0.005"));
}

pub fn assert_yocto_eq(left: u128, right: u128) {
    assert_almost_eq_with_max_delta(left, right, 1);
}

near_sdk_sim::lazy_static_include::lazy_static_include_bytes! {
    LOCKUP_WASM_BYTES => "res/lockup_contract.wasm",
    STAKING_POOL_WASM_BYTES => "../staking-pool/res/staking_pool.wasm",
    FAKE_VOTING_WASM_BYTES => "tests/res/fake_voting.wasm",
    WHITELIST_WASM_BYTES => "../whitelist/res/whitelist.wasm",
}

#[quickcheck]
fn lockup(lockup_amount: Balance, lockup_duration: u64, lockup_timestamp: u64) {
    let (root, _foundation, owner, _staking_pool) = basic_setup();

    let lockup = deploy!(
        contract: LockupContractContract,
        contract_id: LOCKUP_ACCOUNT_ID.to_string(),
        bytes: &LOCKUP_WASM_BYTES,
        signer_account: root,
        deposit: MIN_BALANCE_FOR_STORAGE + lockup_amount,
        gas: MAX_GAS,
        init_method: new(
            owner.account_id.clone(),
            lockup_duration.into(),
            None,
            TransfersInformation::TransfersEnabled {
                transfers_timestamp: lockup_timestamp.saturating_add(1).into(),
            },
            None,
            None,
            STAKING_POOL_WHITELIST_ACCOUNT_ID.to_string(),
            None
        )
    );

    root.borrow_runtime_mut().cur_block.block_timestamp = lockup_timestamp
        .saturating_add(lockup_duration)
        .saturating_sub(1);

    let locked_amount: U128 = owner
        .view_method_call(lockup.contract.get_locked_amount())
        .unwrap_json();
    assert_eq!(locked_amount.0, MIN_BALANCE_FOR_STORAGE + lockup_amount);

    let block_timestamp = root.borrow_runtime().cur_block.block_timestamp;
    root.borrow_runtime_mut().cur_block.block_timestamp = block_timestamp.saturating_add(2);

    let locked_amount: U128 = owner
        .view_method_call(lockup.contract.get_locked_amount())
        .unwrap_json();
    assert_eq!(locked_amount.0, 0);
}

#[test]
fn staking() {
    let lockup_amount = to_yocto("1000");
    let (root, foundation, owner, staking_pool) = basic_setup();

    let lockup = deploy!(
        contract: LockupContractContract,
        contract_id: LOCKUP_ACCOUNT_ID.to_string(),
        bytes: &LOCKUP_WASM_BYTES,
        signer_account: root,
        deposit: MIN_BALANCE_FOR_STORAGE + lockup_amount,
        gas: MAX_GAS,
        init_method: new(
            owner.account_id.clone(),
            1000000000.into(),
            None,
            TransfersInformation::TransfersDisabled {
                transfer_poll_account_id: "transfer-poll".to_string(),
            },
            None,
            None,
            STAKING_POOL_WHITELIST_ACCOUNT_ID.to_string(),
            None
        )
    );

    let owner_staking_account = &owner;

    let res: Option<AccountId> = owner
        .view_method_call(lockup.contract.get_staking_pool_account_id())
        .unwrap_json();
    assert_eq!(res, None);

    // Selecting staking pool
    owner_staking_account
        .function_call(
            lockup
                .contract
                .select_staking_pool(STAKING_POOL_ACCOUNT_ID.to_string()),
            MAX_GAS,
            0,
        )
        .assert_success();

    let res: Option<AccountId> = owner
        .view_method_call(lockup.contract.get_staking_pool_account_id())
        .unwrap_json();
    assert_eq!(res, Some(STAKING_POOL_ACCOUNT_ID.to_string()));
    let res: U128 = owner
        .view_method_call(lockup.contract.get_known_deposited_balance())
        .unwrap_json();
    assert_eq!(res.0, 0);

    // Depositing to the staking pool
    let staking_amount = lockup_amount - to_yocto("100");
    owner_staking_account
        .function_call(
            lockup
                .contract
                .deposit_to_staking_pool(U128(staking_amount)),
            MAX_GAS,
            0,
        )
        .assert_success();

    let res: U128 = owner
        .view_method_call(lockup.contract.get_known_deposited_balance())
        .unwrap_json();
    assert_eq!(res.0, staking_amount);

    // Staking on the staking pool
    owner_staking_account
        .function_call(lockup.contract.stake(U128(staking_amount)), MAX_GAS, 0)
        .assert_success();

    let res: U128 = owner
        .view(
            STAKING_POOL_ACCOUNT_ID.to_string(),
            "get_account_staked_balance",
            &json!({ "account_id": LOCKUP_ACCOUNT_ID.to_string() })
                .to_string()
                .into_bytes(),
        )
        .unwrap_json();
    assert_yocto_eq(res.0, staking_amount);

    // Refreshing staking balance. Should be NOOP
    owner_staking_account
        .function_call(lockup.contract.refresh_staking_pool_balance(), MAX_GAS, 0)
        .assert_success();

    let res: U128 = owner
        .view_method_call(lockup.contract.get_known_deposited_balance())
        .unwrap_json();
    assert_yocto_eq(res.0, staking_amount);

    // Simulating rewards
    foundation
        .transfer(STAKING_POOL_ACCOUNT_ID.to_string(), to_yocto("10"))
        .assert_success();

    // Pinging the staking pool
    foundation
        .call(STAKING_POOL_ACCOUNT_ID.to_string(), "ping", b"", MAX_GAS, 0)
        .assert_success();

    let res: U128 = owner
        .view(
            STAKING_POOL_ACCOUNT_ID.to_string(),
            "get_account_staked_balance",
            &json!({ "account_id": LOCKUP_ACCOUNT_ID.to_string() })
                .to_string()
                .into_bytes(),
        )
        .unwrap_json();
    let new_stake_amount = res.0;
    assert!(new_stake_amount > staking_amount);

    // Refresh staking balance again
    owner_staking_account
        .function_call(lockup.contract.refresh_staking_pool_balance(), MAX_GAS, 0)
        .assert_success();

    let res: U128 = owner
        .view_method_call(lockup.contract.get_known_deposited_balance())
        .unwrap_json();
    let new_total_balance = res.0;
    assert!(new_total_balance >= new_stake_amount);

    let res: U128 = owner
        .view_method_call(lockup.contract.get_owners_balance())
        .unwrap_json();
    // Account for gas rewards
    assert_eq_with_gas(res.0, new_total_balance - staking_amount);

    // Unstaking everything
    let res: bool = owner_staking_account
        .function_call(lockup.contract.unstake(U128(new_stake_amount)), MAX_GAS, 0)
        .unwrap_json();
    assert!(res);

    let res: U128 = owner
        .view(
            STAKING_POOL_ACCOUNT_ID.to_string(),
            "get_account_staked_balance",
            &json!({ "account_id": LOCKUP_ACCOUNT_ID.to_string() })
                .to_string()
                .into_bytes(),
        )
        .unwrap_json();
    assert_eq_with_gas(res.0, 0);

    let res: U128 = owner
        .view(
            STAKING_POOL_ACCOUNT_ID.to_string(),
            "get_account_unstaked_balance",
            &json!({ "account_id": LOCKUP_ACCOUNT_ID.to_string() })
                .to_string()
                .into_bytes(),
        )
        .unwrap_json();
    assert!(res.0 >= new_total_balance);

    root.borrow_runtime_mut().cur_block.block_height += 40;
    root.borrow_runtime_mut().cur_block.epoch_height += 4;

    // The standalone runtime doesn't unlock locked balance. Need to manually intervene.
    let mut pool = staking_pool.account().unwrap();
    pool.amount += pool.locked;
    pool.locked = 0;
    staking_pool
        .borrow_runtime_mut()
        .force_account_update(STAKING_POOL_ACCOUNT_ID.to_string(), &pool);

    // Withdrawing everything from the staking pool
    let res: bool = owner_staking_account
        .function_call(
            lockup
                .contract
                .withdraw_from_staking_pool(U128(new_total_balance)),
            MAX_GAS,
            0,
        )
        .unwrap_json();
    assert!(res);

    let res: U128 = owner
        .view_method_call(lockup.contract.get_known_deposited_balance())
        .unwrap_json();
    assert_eq!(res.0, 0);

    let res: U128 = owner
        .view_method_call(lockup.contract.get_owners_balance())
        .unwrap_json();
    assert_eq_with_gas(res.0, new_stake_amount - staking_amount);

    // Unselecting the staking pool
    owner_staking_account
        .function_call(lockup.contract.unselect_staking_pool(), MAX_GAS, 0)
        .assert_success();

    let res: Option<AccountId> = owner
        .view_method_call(lockup.contract.get_staking_pool_account_id())
        .unwrap_json();
    assert_eq!(res, None);
}

#[test]
fn staking_with_helpers() {
    let lockup_amount = to_yocto("1000");
    let (root, foundation, owner, staking_pool) = basic_setup();

    let lockup = deploy!(
        contract: LockupContractContract,
        contract_id: LOCKUP_ACCOUNT_ID.to_string(),
        bytes: &LOCKUP_WASM_BYTES,
        signer_account: root,
        deposit: MIN_BALANCE_FOR_STORAGE + lockup_amount,
        gas: MAX_GAS,
        init_method: new(
            owner.account_id.clone(),
            1000000000.into(),
            None,
            TransfersInformation::TransfersDisabled {
                transfer_poll_account_id: "transfer-poll".to_string(),
            },
            None,
            None,
            STAKING_POOL_WHITELIST_ACCOUNT_ID.to_string(),
            None
        )
    );

    let owner_staking_account = &owner;

    let res: Option<AccountId> = owner
        .view_method_call(lockup.contract.get_staking_pool_account_id())
        .unwrap_json();
    assert_eq!(res, None);

    // Selecting staking pool
    owner_staking_account
        .function_call(
            lockup
                .contract
                .select_staking_pool(STAKING_POOL_ACCOUNT_ID.to_string()),
            MAX_GAS,
            0,
        )
        .assert_success();

    let res: Option<AccountId> = owner
        .view_method_call(lockup.contract.get_staking_pool_account_id())
        .unwrap_json();
    assert_eq!(res, Some(STAKING_POOL_ACCOUNT_ID.to_string()));
    let res: U128 = owner
        .view_method_call(lockup.contract.get_known_deposited_balance())
        .unwrap_json();
    assert_eq!(res.0, 0);

    // Depositing and staking on the staking pool
    let staking_amount = lockup_amount - to_yocto("100");
    owner_staking_account
        .function_call(
            lockup.contract.deposit_and_stake(U128(staking_amount)),
            MAX_GAS,
            0,
        )
        .assert_success();

    let res: U128 = owner
        .view_method_call(lockup.contract.get_known_deposited_balance())
        .unwrap_json();
    assert_eq!(res.0, staking_amount);

    let res: U128 = owner
        .view(
            STAKING_POOL_ACCOUNT_ID.to_string(),
            "get_account_staked_balance",
            &json!({ "account_id": LOCKUP_ACCOUNT_ID.to_string() })
                .to_string()
                .into_bytes(),
        )
        .unwrap_json();
    assert_yocto_eq(res.0, staking_amount);

    // Refreshing staking balance. Should be NOOP
    owner_staking_account
        .function_call(lockup.contract.refresh_staking_pool_balance(), MAX_GAS, 0)
        .assert_success();

    let res: U128 = owner
        .view_method_call(lockup.contract.get_known_deposited_balance())
        .unwrap_json();
    assert_yocto_eq(res.0, staking_amount);

    // Simulating rewards
    foundation
        .transfer(STAKING_POOL_ACCOUNT_ID.to_string(), to_yocto("10"))
        .assert_success();

    // Pinging the staking pool
    foundation
        .call(STAKING_POOL_ACCOUNT_ID.to_string(), "ping", b"", MAX_GAS, 0)
        .assert_success();

    let res: U128 = owner
        .view(
            STAKING_POOL_ACCOUNT_ID.to_string(),
            "get_account_staked_balance",
            &json!({ "account_id": LOCKUP_ACCOUNT_ID.to_string() })
                .to_string()
                .into_bytes(),
        )
        .unwrap_json();
    let new_stake_amount = res.0;
    assert!(new_stake_amount > staking_amount);

    // Refresh staking balance again
    owner_staking_account
        .function_call(lockup.contract.refresh_staking_pool_balance(), MAX_GAS, 0)
        .assert_success();

    let res: U128 = owner
        .view_method_call(lockup.contract.get_known_deposited_balance())
        .unwrap_json();
    let new_total_balance = res.0;
    assert!(new_total_balance >= new_stake_amount);

    let res: U128 = owner
        .view_method_call(lockup.contract.get_owners_balance())
        .unwrap_json();
    // Account for gas rewards
    assert_eq_with_gas(res.0, new_total_balance - staking_amount);

    // Unstaking everything
    let res: bool = owner_staking_account
        .function_call(lockup.contract.unstake_all(), MAX_GAS, 0)
        .unwrap_json();
    assert!(res);

    let res: U128 = owner
        .view(
            STAKING_POOL_ACCOUNT_ID.to_string(),
            "get_account_staked_balance",
            &json!({ "account_id": LOCKUP_ACCOUNT_ID.to_string() })
                .to_string()
                .into_bytes(),
        )
        .unwrap_json();
    assert_eq_with_gas(res.0, 0);

    let res: U128 = owner
        .view(
            STAKING_POOL_ACCOUNT_ID.to_string(),
            "get_account_unstaked_balance",
            &json!({ "account_id": LOCKUP_ACCOUNT_ID.to_string() })
                .to_string()
                .into_bytes(),
        )
        .unwrap_json();
    let new_unstaked_amount = res.0;
    assert!(new_unstaked_amount >= new_total_balance);

    root.borrow_runtime_mut().cur_block.block_height += 40;
    root.borrow_runtime_mut().cur_block.epoch_height += 4;

    // The standalone runtime doesn't unlock locked balance. Need to manually intervene.
    let mut pool = staking_pool.account().unwrap();
    pool.amount += pool.locked;
    pool.locked = 0;
    staking_pool
        .borrow_runtime_mut()
        .force_account_update(STAKING_POOL_ACCOUNT_ID.to_string(), &pool);

    // Withdrawing everything from the staking pool
    let res: bool = owner_staking_account
        .function_call(lockup.contract.withdraw_all_from_staking_pool(), MAX_GAS, 0)
        .unwrap_json();
    assert!(res);

    let res: U128 = owner
        .view_method_call(lockup.contract.get_known_deposited_balance())
        .unwrap_json();
    assert_eq!(res.0, 0);

    let res: U128 = owner
        .view_method_call(lockup.contract.get_owners_balance())
        .unwrap_json();
    assert_eq_with_gas(res.0, new_stake_amount - staking_amount);

    // Unselecting the staking pool
    owner_staking_account
        .function_call(lockup.contract.unselect_staking_pool(), MAX_GAS, 0)
        .assert_success();

    let res: Option<AccountId> = owner
        .view_method_call(lockup.contract.get_staking_pool_account_id())
        .unwrap_json();
    assert_eq!(res, None);
}

#[test]
fn termination_with_staking_hashed() {
    let lockup_amount = to_yocto("1000");
    let (root, foundation, owner, staking_pool) = basic_setup();

    let start_timestamp = root.borrow_runtime().cur_block.block_timestamp;

    let vesting_schedule = VestingSchedule {
        start_timestamp: start_timestamp.into(),
        cliff_timestamp: (start_timestamp + 1000).into(),
        end_timestamp: (start_timestamp + 4000).into(),
    };
    let salt: Vec<u8> = [vec![1, 2, 3], b"VERY_LONG_SALT".to_vec()].concat();

    let lockup = deploy!(
        contract: LockupContractContract,
        contract_id: LOCKUP_ACCOUNT_ID.to_string(),
        bytes: &LOCKUP_WASM_BYTES,
        signer_account: root,
        deposit: MIN_BALANCE_FOR_STORAGE + lockup_amount,
        gas: MAX_GAS,
        init_method: new(
            owner.account_id.clone(),
            1000000000.into(),
            None,
            TransfersInformation::TransfersDisabled {
                transfer_poll_account_id: "transfer-poll".to_string(),
            },
            Some(VestingScheduleOrHash::VestingHash(
                near_sdk_sim::hash::hash(
                    &VestingScheduleWithSalt {
                        vesting_schedule: vesting_schedule.clone(),
                        salt: salt.clone().into(),
                    }
                    .try_to_vec()
                    .unwrap(),
                )
                .as_ref()
                .to_vec()
                .into(),
            )),
            None,
            STAKING_POOL_WHITELIST_ACCOUNT_ID.to_string(),
            Some(foundation.account_id.clone())
        )
    );

    let owner_staking_account = &owner;

    let res: Option<AccountId> = owner
        .view_method_call(lockup.contract.get_staking_pool_account_id())
        .unwrap_json();
    assert_eq!(res, None);

    // Selecting staking pool
    owner_staking_account
        .function_call(
            lockup
                .contract
                .select_staking_pool(STAKING_POOL_ACCOUNT_ID.to_string()),
            MAX_GAS,
            0,
        )
        .assert_success();

    let res: Option<AccountId> = owner
        .view_method_call(lockup.contract.get_staking_pool_account_id())
        .unwrap_json();
    assert_eq!(res, Some(STAKING_POOL_ACCOUNT_ID.to_string()));
    let res: U128 = owner
        .view_method_call(lockup.contract.get_known_deposited_balance())
        .unwrap_json();
    assert_eq!(res.0, 0);

    // Depositing and staking on the staking pool
    let staking_amount = lockup_amount - to_yocto("100");
    owner_staking_account
        .function_call(
            lockup.contract.deposit_and_stake(U128(staking_amount)),
            MAX_GAS,
            0,
        )
        .assert_success();

    let res: U128 = owner
        .view_method_call(lockup.contract.get_known_deposited_balance())
        .unwrap_json();
    assert_eq!(res.0, staking_amount);

    // Simulating rewards
    foundation
        .transfer(STAKING_POOL_ACCOUNT_ID.to_string(), to_yocto("10"))
        .assert_success();

    // Pinging the staking pool
    foundation
        .call(STAKING_POOL_ACCOUNT_ID.to_string(), "ping", b"", MAX_GAS, 0)
        .assert_success();

    let res: U128 = owner
        .view_method_call(
            lockup
                .contract
                .get_locked_vested_amount(vesting_schedule.clone()),
        )
        .unwrap_json();
    assert_eq!(res.0, 0);

    // Updating the timestamp to simulate some vesting
    root.borrow_runtime_mut().cur_block.block_timestamp = start_timestamp + 1500;

    let res: U128 = owner
        .view_method_call(
            lockup
                .contract
                .get_locked_vested_amount(vesting_schedule.clone()),
        )
        .unwrap_json();
    assert_eq!(res.0, (lockup_amount + MIN_BALANCE_FOR_STORAGE) * 3 / 8);

    let res: U128 = owner
        .view_method_call(
            lockup
                .contract
                .get_unvested_amount(vesting_schedule.clone()),
        )
        .unwrap_json();
    assert_eq!(res.0, (lockup_amount + MIN_BALANCE_FOR_STORAGE) * 5 / 8);

    // Terminating the vesting schedule

    let res: Option<TerminationStatus> = owner
        .view_method_call(lockup.contract.get_termination_status())
        .unwrap_json();
    assert!(res.is_none());

    let res: WrappedBalance = owner
        .view_method_call(lockup.contract.get_terminated_unvested_balance())
        .unwrap_json();
    assert_eq!(res.0, 0);

    foundation
        .function_call(
            lockup
                .contract
                .terminate_vesting(Some(VestingScheduleWithSalt {
                    vesting_schedule: vesting_schedule.clone(),
                    salt: salt.clone().into(),
                })),
            MAX_GAS,
            0,
        )
        .assert_success();

    let res: Option<TerminationStatus> = owner
        .view_method_call(lockup.contract.get_termination_status())
        .unwrap_json();
    assert_eq!(res, Some(TerminationStatus::VestingTerminatedWithDeficit));

    let res: WrappedBalance = owner
        .view_method_call(lockup.contract.get_terminated_unvested_balance())
        .unwrap_json();
    let unvested_balance = (lockup_amount + MIN_BALANCE_FOR_STORAGE) * 5 / 8;
    assert_eq!(res.0, unvested_balance);

    let res: WrappedBalance = owner
        .view_method_call(lockup.contract.get_terminated_unvested_balance_deficit())
        .unwrap_json();
    // The rest of the tokens are on the staking pool.
    assert_eq_with_gas(res.0, unvested_balance - to_yocto("100"));

    let res: U128 = owner
        .view(
            STAKING_POOL_ACCOUNT_ID.to_string(),
            "get_account_staked_balance",
            &json!({ "account_id": LOCKUP_ACCOUNT_ID.to_string() })
                .to_string()
                .into_bytes(),
        )
        .unwrap_json();
    assert!(res.0 > 0);

    foundation
        .function_call(
            lockup.contract.termination_prepare_to_withdraw(),
            MAX_GAS,
            0,
        )
        .assert_success();

    let res: Option<TerminationStatus> = owner
        .view_method_call(lockup.contract.get_termination_status())
        .unwrap_json();
    assert_eq!(res, Some(TerminationStatus::EverythingUnstaked));

    let res: WrappedBalance = owner
        .view_method_call(lockup.contract.get_terminated_unvested_balance_deficit())
        .unwrap_json();
    assert_eq_with_gas(res.0, unvested_balance - to_yocto("100"));

    let res: U128 = owner
        .view(
            STAKING_POOL_ACCOUNT_ID.to_string(),
            "get_account_staked_balance",
            &json!({ "account_id": LOCKUP_ACCOUNT_ID.to_string() })
                .to_string()
                .into_bytes(),
        )
        .unwrap_json();
    assert_eq_with_gas(res.0, 0);

    let res: U128 = owner
        .view(
            STAKING_POOL_ACCOUNT_ID.to_string(),
            "get_account_unstaked_balance",
            &json!({ "account_id": LOCKUP_ACCOUNT_ID.to_string() })
                .to_string()
                .into_bytes(),
        )
        .unwrap_json();
    assert!(res.0 > 0);

    let res: bool = foundation
        .function_call(
            lockup.contract.termination_prepare_to_withdraw(),
            MAX_GAS,
            0,
        )
        .unwrap_json();
    // Need to wait 4 epochs
    assert!(!res);

    let res: Option<TerminationStatus> = owner
        .view_method_call(lockup.contract.get_termination_status())
        .unwrap_json();
    assert_eq!(res, Some(TerminationStatus::EverythingUnstaked));

    root.borrow_runtime_mut().cur_block.block_height += 40;
    root.borrow_runtime_mut().cur_block.epoch_height += 4;

    // The standalone runtime doesn't unlock locked balance. Need to manually intervene.
    let mut pool = staking_pool.account().unwrap();
    pool.amount += pool.locked;
    pool.locked = 0;
    staking_pool
        .borrow_runtime_mut()
        .force_account_update(STAKING_POOL_ACCOUNT_ID.to_string(), &pool);

    let res: U128 = owner
        .view(
            STAKING_POOL_ACCOUNT_ID.to_string(),
            "get_account_unstaked_balance",
            &json!({ "account_id": LOCKUP_ACCOUNT_ID.to_string() })
                .to_string()
                .into_bytes(),
        )
        .unwrap_json();
    let received_reward = res.0 - staking_amount;

    let res: bool = foundation
        .function_call(
            lockup.contract.termination_prepare_to_withdraw(),
            MAX_GAS,
            0,
        )
        .unwrap_json();
    assert!(res);

    let res: WrappedBalance = owner
        .view_method_call(lockup.contract.get_terminated_unvested_balance_deficit())
        .unwrap_json();
    assert_eq!(res.0, 0);

    let res: Option<TerminationStatus> = owner
        .view_method_call(lockup.contract.get_termination_status())
        .unwrap_json();
    assert_eq!(res, Some(TerminationStatus::ReadyToWithdraw));

    let res: U128 = owner
        .view(
            STAKING_POOL_ACCOUNT_ID.to_string(),
            "get_account_unstaked_balance",
            &json!({ "account_id": LOCKUP_ACCOUNT_ID.to_string() })
                .to_string()
                .into_bytes(),
        )
        .unwrap_json();
    assert_eq!(res.0, 0);

    let res: U128 = owner
        .view_method_call(lockup.contract.get_known_deposited_balance())
        .unwrap_json();
    assert_eq!(res.0, 0);

    let foundation_balance = foundation.account().unwrap().amount;

    let res: bool = foundation
        .function_call(
            lockup
                .contract
                .termination_withdraw(foundation.account_id.clone()),
            MAX_GAS,
            0,
        )
        .unwrap_json();
    assert!(res);

    let res: Option<TerminationStatus> = owner
        .view_method_call(lockup.contract.get_termination_status())
        .unwrap_json();
    assert_eq!(res, None);

    let res: WrappedBalance = owner
        .view_method_call(lockup.contract.get_terminated_unvested_balance())
        .unwrap_json();
    assert_eq!(res.0, 0);

    let new_foundation_balance = foundation.account().unwrap().amount;
    assert_eq_with_gas(
        new_foundation_balance,
        foundation_balance + unvested_balance,
    );

    let res: WrappedBalance = owner
        .view_method_call(lockup.contract.get_locked_amount())
        .unwrap_json();
    assert_eq!(res.0, (lockup_amount + MIN_BALANCE_FOR_STORAGE) - unvested_balance);

    let res: WrappedBalance = owner
        .view_method_call(lockup.contract.get_liquid_owners_balance())
        .unwrap_json();
    assert_eq_with_gas(res.0, received_reward);

    let res: WrappedBalance = owner
        .view_method_call(lockup.contract.get_balance())
        .unwrap_json();
    assert_eq_with_gas(
        res.0,
        (lockup_amount + MIN_BALANCE_FOR_STORAGE) - unvested_balance + received_reward,
    );
}

#[test]
fn termination_with_staking() {
    let lockup_amount = to_yocto("1000");
    let (root, foundation, owner, staking_pool) = basic_setup();

    let start_timestamp = root.borrow_runtime().cur_block.block_timestamp;

    let vesting_schedule = VestingSchedule {
        start_timestamp: start_timestamp.into(),
        cliff_timestamp: (start_timestamp + 1000).into(),
        end_timestamp: (start_timestamp + 4000).into(),
    };

    let lockup = deploy!(
        contract: LockupContractContract,
        contract_id: LOCKUP_ACCOUNT_ID.to_string(),
        bytes: &LOCKUP_WASM_BYTES,
        signer_account: root,
        deposit: MIN_BALANCE_FOR_STORAGE + lockup_amount,
        gas: MAX_GAS,
        init_method: new(
            owner.account_id.clone(),
            1000000000.into(),
            None,
            TransfersInformation::TransfersDisabled {
                transfer_poll_account_id: "transfer-poll".to_string(),
            },
            Some(VestingScheduleOrHash::VestingSchedule(
                vesting_schedule.clone(),
            )),
            None,
            STAKING_POOL_WHITELIST_ACCOUNT_ID.to_string(),
            Some(foundation.account_id.clone())
        )
    );

    let owner_staking_account = &owner;

    let res: Option<AccountId> = owner
        .view_method_call(lockup.contract.get_staking_pool_account_id())
        .unwrap_json();
    assert_eq!(res, None);

    // Selecting staking pool
    owner_staking_account
        .function_call(
            lockup
                .contract
                .select_staking_pool(STAKING_POOL_ACCOUNT_ID.to_string()),
            MAX_GAS,
            0,
        )
        .assert_success();

    let res: Option<AccountId> = owner
        .view_method_call(lockup.contract.get_staking_pool_account_id())
        .unwrap_json();
    assert_eq!(res, Some(STAKING_POOL_ACCOUNT_ID.to_string()));
    let res: U128 = owner
        .view_method_call(lockup.contract.get_known_deposited_balance())
        .unwrap_json();
    assert_eq!(res.0, 0);

    // Depositing and staking on the staking pool
    let staking_amount = lockup_amount - to_yocto("100");
    owner_staking_account
        .function_call(
            lockup.contract.deposit_and_stake(U128(staking_amount)),
            MAX_GAS,
            0,
        )
        .assert_success();

    let res: U128 = owner
        .view_method_call(lockup.contract.get_known_deposited_balance())
        .unwrap_json();
    assert_eq!(res.0, staking_amount);

    // Simulating rewards
    foundation
        .transfer(STAKING_POOL_ACCOUNT_ID.to_string(), to_yocto("10"))
        .assert_success();

    // Pinging the staking pool
    foundation
        .call(STAKING_POOL_ACCOUNT_ID.to_string(), "ping", b"", MAX_GAS, 0)
        .assert_success();

    let res: U128 = owner
        .view_method_call(
            lockup
                .contract
                .get_locked_vested_amount(vesting_schedule.clone()),
        )
        .unwrap_json();
    assert_eq!(res.0, 0);

    // Updating the timestamp to simulate some vesting
    root.borrow_runtime_mut().cur_block.block_timestamp = start_timestamp + 1500;

    let res: U128 = owner
        .view_method_call(
            lockup
                .contract
                .get_locked_vested_amount(vesting_schedule.clone()),
        )
        .unwrap_json();
    assert_eq!(res.0, (lockup_amount + MIN_BALANCE_FOR_STORAGE) * 3 / 8);

    let res: U128 = owner
        .view_method_call(
            lockup
                .contract
                .get_unvested_amount(vesting_schedule.clone()),
        )
        .unwrap_json();
    assert_eq!(res.0, (lockup_amount + MIN_BALANCE_FOR_STORAGE) * 5 / 8);

    // Terminating the vesting schedule

    let res: Option<TerminationStatus> = owner
        .view_method_call(lockup.contract.get_termination_status())
        .unwrap_json();
    assert!(res.is_none());

    let res: WrappedBalance = owner
        .view_method_call(lockup.contract.get_terminated_unvested_balance())
        .unwrap_json();
    assert_eq!(res.0, 0);

    foundation
        .function_call(lockup.contract.terminate_vesting(None), MAX_GAS, 0)
        .assert_success();

    let res: Option<TerminationStatus> = owner
        .view_method_call(lockup.contract.get_termination_status())
        .unwrap_json();
    assert_eq!(res, Some(TerminationStatus::VestingTerminatedWithDeficit));

    let res: WrappedBalance = owner
        .view_method_call(lockup.contract.get_terminated_unvested_balance())
        .unwrap_json();
    let unvested_balance = (lockup_amount + MIN_BALANCE_FOR_STORAGE) * 5 / 8;
    assert_eq!(res.0, unvested_balance);

    let res: WrappedBalance = owner
        .view_method_call(lockup.contract.get_terminated_unvested_balance_deficit())
        .unwrap_json();
    // The rest of the tokens are on the staking pool.
    assert_eq_with_gas(res.0, unvested_balance - to_yocto("100"));

    let res: U128 = owner
        .view(
            STAKING_POOL_ACCOUNT_ID.to_string(),
            "get_account_staked_balance",
            &json!({ "account_id": LOCKUP_ACCOUNT_ID.to_string() })
                .to_string()
                .into_bytes(),
        )
        .unwrap_json();
    assert!(res.0 > 0);

    foundation
        .function_call(
            lockup.contract.termination_prepare_to_withdraw(),
            MAX_GAS,
            0,
        )
        .assert_success();

    let res: Option<TerminationStatus> = owner
        .view_method_call(lockup.contract.get_termination_status())
        .unwrap_json();
    assert_eq!(res, Some(TerminationStatus::EverythingUnstaked));

    let res: WrappedBalance = owner
        .view_method_call(lockup.contract.get_terminated_unvested_balance_deficit())
        .unwrap_json();
    assert_eq_with_gas(res.0, unvested_balance - to_yocto("100"));

    let res: U128 = owner
        .view(
            STAKING_POOL_ACCOUNT_ID.to_string(),
            "get_account_staked_balance",
            &json!({ "account_id": LOCKUP_ACCOUNT_ID.to_string() })
                .to_string()
                .into_bytes(),
        )
        .unwrap_json();
    assert_eq_with_gas(res.0, 0);

    let res: U128 = owner
        .view(
            STAKING_POOL_ACCOUNT_ID.to_string(),
            "get_account_unstaked_balance",
            &json!({ "account_id": LOCKUP_ACCOUNT_ID.to_string() })
                .to_string()
                .into_bytes(),
        )
        .unwrap_json();
    assert!(res.0 > 0);

    let res: bool = foundation
        .function_call(
            lockup.contract.termination_prepare_to_withdraw(),
            MAX_GAS,
            0,
        )
        .unwrap_json();
    // Need to wait 4 epochs
    assert!(!res);

    let res: Option<TerminationStatus> = owner
        .view_method_call(lockup.contract.get_termination_status())
        .unwrap_json();
    assert_eq!(res, Some(TerminationStatus::EverythingUnstaked));

    root.borrow_runtime_mut().cur_block.block_height += 40;
    root.borrow_runtime_mut().cur_block.epoch_height += 4;

    // The standalone runtime doesn't unlock locked balance. Need to manually intervene.
    let mut pool = staking_pool.account().unwrap();
    pool.amount += pool.locked;
    pool.locked = 0;
    staking_pool
        .borrow_runtime_mut()
        .force_account_update(STAKING_POOL_ACCOUNT_ID.to_string(), &pool);

    let res: U128 = owner
        .view(
            STAKING_POOL_ACCOUNT_ID.to_string(),
            "get_account_unstaked_balance",
            &json!({ "account_id": LOCKUP_ACCOUNT_ID.to_string() })
                .to_string()
                .into_bytes(),
        )
        .unwrap_json();
    let received_reward = res.0 - staking_amount;

    let res: bool = foundation
        .function_call(
            lockup.contract.termination_prepare_to_withdraw(),
            MAX_GAS,
            0,
        )
        .unwrap_json();
    assert!(res);

    let res: WrappedBalance = owner
        .view_method_call(lockup.contract.get_terminated_unvested_balance_deficit())
        .unwrap_json();
    assert_eq!(res.0, 0);

    let res: Option<TerminationStatus> = owner
        .view_method_call(lockup.contract.get_termination_status())
        .unwrap_json();
    assert_eq!(res, Some(TerminationStatus::ReadyToWithdraw));

    let res: U128 = owner
        .view(
            STAKING_POOL_ACCOUNT_ID.to_string(),
            "get_account_unstaked_balance",
            &json!({ "account_id": LOCKUP_ACCOUNT_ID.to_string() })
                .to_string()
                .into_bytes(),
        )
        .unwrap_json();
    assert_eq!(res.0, 0);

    let res: U128 = owner
        .view_method_call(lockup.contract.get_known_deposited_balance())
        .unwrap_json();
    assert_eq!(res.0, 0);

    let foundation_balance = foundation.account().unwrap().amount;

    let res: bool = foundation
        .function_call(
            lockup
                .contract
                .termination_withdraw(foundation.account_id.clone()),
            MAX_GAS,
            0,
        )
        .unwrap_json();
    assert!(res);

    let res: Option<TerminationStatus> = owner
        .view_method_call(lockup.contract.get_termination_status())
        .unwrap_json();
    assert_eq!(res, None);

    let res: WrappedBalance = owner
        .view_method_call(lockup.contract.get_terminated_unvested_balance())
        .unwrap_json();
    assert_eq!(res.0, 0);

    let new_foundation_balance = foundation.account().unwrap().amount;
    assert_eq_with_gas(
        new_foundation_balance,
        foundation_balance + unvested_balance,
    );

    let res: WrappedBalance = owner
        .view_method_call(lockup.contract.get_locked_amount())
        .unwrap_json();
    assert_eq!(res.0, (lockup_amount + MIN_BALANCE_FOR_STORAGE) - unvested_balance);

    let res: WrappedBalance = owner
        .view_method_call(lockup.contract.get_liquid_owners_balance())
        .unwrap_json();
    assert_eq_with_gas(res.0, received_reward);

    let res: WrappedBalance = owner
        .view_method_call(lockup.contract.get_balance())
        .unwrap_json();
    assert_eq_with_gas(
        res.0,
        (lockup_amount + MIN_BALANCE_FOR_STORAGE) - unvested_balance + received_reward,
    );
}

#[test]
fn test_release_schedule_unlock_transfers() {
    let lockup_amount = to_yocto("1000");
    let (root, foundation, owner, _staking_pool) = basic_setup();

    // Initializing fake voting contract
    let _voting = root.deploy(
        &FAKE_VOTING_WASM_BYTES,
        TRANSFER_POLL_ACCOUNT_ID.to_string(),
        to_yocto("30"),
    );

    // Unlock timestamp from fake voting contract.
    let unlock_timestamp = 1535760000000000000u64;
    root.borrow_runtime_mut().cur_block.block_timestamp = unlock_timestamp + 1000;

    let lockup = deploy!(
        contract: LockupContractContract,
        contract_id: LOCKUP_ACCOUNT_ID.to_string(),
        bytes: &LOCKUP_WASM_BYTES,
        signer_account: root,
        deposit: MIN_BALANCE_FOR_STORAGE + lockup_amount,
        gas: MAX_GAS,
        init_method: new(
            owner.account_id.clone(),
            0.into(),
            None,
            TransfersInformation::TransfersDisabled {
                transfer_poll_account_id: TRANSFER_POLL_ACCOUNT_ID.to_string(),
            },
            None,
            Some(1000000000000.into()),
            STAKING_POOL_WHITELIST_ACCOUNT_ID.to_string(),
            None
        )
    );

    let owner_staking_account = &owner;

    let res: Option<AccountId> = owner
        .view_method_call(lockup.contract.get_staking_pool_account_id())
        .unwrap_json();
    assert_eq!(res, None);

    // Selecting staking pool
    owner_staking_account
        .function_call(
            lockup
                .contract
                .select_staking_pool(STAKING_POOL_ACCOUNT_ID.to_string()),
            MAX_GAS,
            0,
        )
        .assert_success();

    let res: Option<AccountId> = owner
        .view_method_call(lockup.contract.get_staking_pool_account_id())
        .unwrap_json();
    assert_eq!(res, Some(STAKING_POOL_ACCOUNT_ID.to_string()));
    let res: U128 = owner
        .view_method_call(lockup.contract.get_known_deposited_balance())
        .unwrap_json();
    assert_eq!(res.0, 0);

    // Depositing and staking on the staking pool
    let staking_amount = lockup_amount - to_yocto("100");
    owner_staking_account
        .function_call(
            lockup.contract.deposit_and_stake(U128(staking_amount)),
            MAX_GAS,
            0,
        )
        .assert_success();

    let res: U128 = owner
        .view_method_call(lockup.contract.get_known_deposited_balance())
        .unwrap_json();
    assert_eq!(res.0, staking_amount);

    // Simulating rewards
    foundation
        .transfer(STAKING_POOL_ACCOUNT_ID.to_string(), to_yocto("10"))
        .assert_success();

    // Pinging the staking pool
    foundation
        .call(STAKING_POOL_ACCOUNT_ID.to_string(), "ping", b"", MAX_GAS, 0)
        .assert_success();

    let res: U128 = owner
        .view(
            STAKING_POOL_ACCOUNT_ID.to_string(),
            "get_account_staked_balance",
            &json!({ "account_id": LOCKUP_ACCOUNT_ID.to_string() })
                .to_string()
                .into_bytes(),
        )
        .unwrap_json();
    let received_reward = res.0 - staking_amount;

    owner_staking_account
        .function_call(lockup.contract.refresh_staking_pool_balance(), MAX_GAS, 0)
        .assert_success();

    let full_lockup_amount = lockup_amount + MIN_BALANCE_FOR_STORAGE;

    // Reset timestamp to 0, to avoid any release
    root.borrow_runtime_mut().cur_block.block_timestamp = unlock_timestamp;

    let res: WrappedBalance = owner
        .view_method_call(lockup.contract.get_locked_amount())
        .unwrap_json();
    assert_eq!(res.0, full_lockup_amount);

    let res: U128 = owner
        .view_method_call(lockup.contract.get_known_deposited_balance())
        .unwrap_json();
    assert_eq_with_gas(res.0, staking_amount + received_reward);

    let res: bool = owner
        .view_method_call(lockup.contract.are_transfers_enabled())
        .unwrap_json();
    assert!(!res);

    let res: WrappedBalance = owner
        .view_method_call(lockup.contract.get_liquid_owners_balance())
        .unwrap_json();
    assert_eq_with_gas(res.0, received_reward);

    let res: WrappedBalance = owner
        .view_method_call(lockup.contract.get_owners_balance())
        .unwrap_json();
    assert_eq_with_gas(res.0, received_reward);

    let res: WrappedBalance = owner
        .view_method_call(lockup.contract.get_balance())
        .unwrap_json();
    assert_eq_with_gas(res.0, full_lockup_amount + received_reward);

    let transfer_amount = to_yocto("5");
    assert!(transfer_amount < received_reward);
    let owner_balance = owner.account().unwrap().amount;

    assert!(!owner_staking_account
        .function_call(
            lockup
                .contract
                .transfer(U128(transfer_amount), owner.account_id.clone()),
            MAX_GAS,
            0,
        )
        .is_ok());

    let new_owner_balance = owner.account().unwrap().amount;
    assert_eq_with_gas(new_owner_balance, owner_balance);

    let res: bool = owner_staking_account
        .function_call(lockup.contract.check_transfers_vote(), MAX_GAS, 0)
        .unwrap_json();
    assert!(res);

    let res: WrappedBalance = owner
        .view_method_call(lockup.contract.get_locked_amount())
        .unwrap_json();
    assert_eq!(res.0, lockup_amount + MIN_BALANCE_FOR_STORAGE);

    let res: bool = owner
        .view_method_call(lockup.contract.are_transfers_enabled())
        .unwrap_json();
    assert!(res);

    let res: WrappedBalance = owner
        .view_method_call(lockup.contract.get_liquid_owners_balance())
        .unwrap_json();
    assert_eq_with_gas(res.0, received_reward);

    let res: WrappedBalance = owner
        .view_method_call(lockup.contract.get_owners_balance())
        .unwrap_json();
    assert_eq_with_gas(res.0, received_reward);

    let res: WrappedBalance = owner
        .view_method_call(lockup.contract.get_balance())
        .unwrap_json();
    assert_eq_with_gas(res.0, full_lockup_amount + received_reward);

    owner_staking_account
        .function_call(
            lockup
                .contract
                .transfer(U128(transfer_amount), owner.account_id.clone()),
            MAX_GAS,
            0,
        )
        .assert_success();

    let new_owner_balance = owner.account().unwrap().amount;
    assert_eq_with_gas(new_owner_balance, owner_balance + transfer_amount);

    let liquid_balance = received_reward - transfer_amount;

    let res: WrappedBalance = owner
        .view_method_call(lockup.contract.get_locked_amount())
        .unwrap_json();
    assert_eq!(res.0, full_lockup_amount);

    let res: WrappedBalance = owner
        .view_method_call(lockup.contract.get_liquid_owners_balance())
        .unwrap_json();
    assert_eq_with_gas(res.0, liquid_balance);

    let res: WrappedBalance = owner
        .view_method_call(lockup.contract.get_owners_balance())
        .unwrap_json();
    assert_eq_with_gas(res.0, liquid_balance);

    let res: WrappedBalance = owner
        .view_method_call(lockup.contract.get_balance())
        .unwrap_json();
    assert_eq_with_gas(res.0, full_lockup_amount + liquid_balance);

    let transfer_amount = to_yocto("15");
    assert!(transfer_amount > liquid_balance);

    let owner_balance = new_owner_balance;

    assert!(!owner_staking_account
        .function_call(
            lockup
                .contract
                .transfer(U128(transfer_amount), owner.account_id.clone()),
            MAX_GAS,
            0,
        )
        .is_ok());

    let new_owner_balance = owner.account().unwrap().amount;
    assert_eq_with_gas(new_owner_balance, owner_balance);

    // At this timestamp only 1/1000 of the lockup_amount is released.
    root.borrow_runtime_mut().cur_block.block_timestamp = unlock_timestamp + 1000000000;

    let res: WrappedBalance = owner
        .view_method_call(lockup.contract.get_locked_amount())
        .unwrap_json();
    assert_eq!(res.0, full_lockup_amount - full_lockup_amount / 1000);

    let res: WrappedBalance = owner
        .view_method_call(lockup.contract.get_liquid_owners_balance())
        .unwrap_json();
    assert_eq_with_gas(res.0, liquid_balance + full_lockup_amount / 1000);

    let res: WrappedBalance = owner
        .view_method_call(lockup.contract.get_owners_balance())
        .unwrap_json();
    assert_eq_with_gas(res.0, liquid_balance + full_lockup_amount / 1000);

    let res: WrappedBalance = owner
        .view_method_call(lockup.contract.get_balance())
        .unwrap_json();
    assert_eq_with_gas(res.0, full_lockup_amount + liquid_balance);

    // Adding more time. So 50/1000 is unlocked
    root.borrow_runtime_mut().cur_block.block_timestamp = unlock_timestamp + 50_000_000_000;

    let res: WrappedBalance = owner
        .view_method_call(lockup.contract.get_locked_amount())
        .unwrap_json();
    assert_eq!(res.0, full_lockup_amount - 50 * full_lockup_amount / 1000);

    let res: WrappedBalance = owner
        .view_method_call(lockup.contract.get_liquid_owners_balance())
        .unwrap_json();
    assert_eq_with_gas(res.0, liquid_balance + 50 * full_lockup_amount / 1000);

    let res: WrappedBalance = owner
        .view_method_call(lockup.contract.get_owners_balance())
        .unwrap_json();
    assert_eq_with_gas(res.0, liquid_balance + 50 * full_lockup_amount / 1000);

    let res: WrappedBalance = owner
        .view_method_call(lockup.contract.get_balance())
        .unwrap_json();
    assert_eq_with_gas(res.0, full_lockup_amount + liquid_balance);

    // Transferring 15 more
    owner_staking_account
        .function_call(
            lockup
                .contract
                .transfer(U128(transfer_amount), owner.account_id.clone()),
            MAX_GAS,
            0,
        )
        .assert_success();

    let new_owner_balance = owner.account().unwrap().amount;
    assert_eq_with_gas(new_owner_balance, owner_balance + transfer_amount);

    let full_balance = full_lockup_amount + liquid_balance - transfer_amount;
    let liquid_balance = liquid_balance + 51 * full_lockup_amount / 1000 - transfer_amount;

    // Setting time to 51/1000 to have round numbers
    root.borrow_runtime_mut().cur_block.block_timestamp = unlock_timestamp + 51_000_000_000;

    let res: WrappedBalance = owner
        .view_method_call(lockup.contract.get_locked_amount())
        .unwrap_json();
    assert_eq!(res.0, full_lockup_amount - 51 * full_lockup_amount / 1000);

    let res: WrappedBalance = owner
        .view_method_call(lockup.contract.get_liquid_owners_balance())
        .unwrap_json();
    assert_eq_with_gas(res.0, liquid_balance);

    let res: WrappedBalance = owner
        .view_method_call(lockup.contract.get_owners_balance())
        .unwrap_json();
    assert_eq_with_gas(res.0, liquid_balance);

    let res: WrappedBalance = owner
        .view_method_call(lockup.contract.get_balance())
        .unwrap_json();
    assert_eq_with_gas(res.0, full_balance);

    // Setting time to 200/1000 to check liquid balance, because majority of balance is still staked.
    root.borrow_runtime_mut().cur_block.block_timestamp = unlock_timestamp + 200_000_000_000;
    let owners_balance = liquid_balance + 149 * full_lockup_amount / 1000;

    let res: WrappedBalance = owner
        .view_method_call(lockup.contract.get_locked_amount())
        .unwrap_json();
    assert_eq!(res.0, full_lockup_amount - 200 * full_lockup_amount / 1000);

    let res: WrappedBalance = owner
        .view_method_call(lockup.contract.get_liquid_owners_balance())
        .unwrap_json();
    // The account balance is `100`. `+3.5` for storage and `-20` for transfers.
    assert_eq_with_gas(res.0, to_yocto("80"));

    let res: WrappedBalance = owner
        .view_method_call(lockup.contract.get_owners_balance())
        .unwrap_json();
    assert_eq_with_gas(res.0, owners_balance);

    let res: WrappedBalance = owner
        .view_method_call(lockup.contract.get_balance())
        .unwrap_json();
    assert_eq_with_gas(res.0, full_balance);

    let public_key: Base58PublicKey = owner_staking_account
        .signer
        .public_key
        .try_to_vec()
        .unwrap()
        .try_into()
        .unwrap();

    // Trying to add full access key.
    assert!(!owner_staking_account
        .function_call(
            lockup.contract.add_full_access_key(public_key.clone()),
            MAX_GAS,
            0
        )
        .is_ok());

    // Setting time to full release.
    root.borrow_runtime_mut().cur_block.block_timestamp = unlock_timestamp + 1100_000_000_000;

    let res: WrappedBalance = owner
        .view_method_call(lockup.contract.get_locked_amount())
        .unwrap_json();
    assert_eq!(res.0, 0);

    let res: WrappedBalance = owner
        .view_method_call(lockup.contract.get_liquid_owners_balance())
        .unwrap_json();
    assert_eq_with_gas(res.0, to_yocto("80"));

    let res: WrappedBalance = owner
        .view_method_call(lockup.contract.get_owners_balance())
        .unwrap_json();
    assert_eq_with_gas(res.0, full_balance);

    let res: WrappedBalance = owner
        .view_method_call(lockup.contract.get_balance())
        .unwrap_json();
    assert_eq_with_gas(res.0, full_balance);

    // Adding full access key
    owner_staking_account
        .function_call(
            lockup.contract.add_full_access_key(public_key.clone()),
            MAX_GAS,
            0,
        )
        .assert_success();

    let mut lockup_account = root.create_user("tmp".to_string(), to_yocto("100"));
    lockup_account.account_id = LOCKUP_ACCOUNT_ID.to_string();
    lockup_account.signer = owner.signer.clone();

    // Testing direct transfer
    let owner_balance = owner.account().unwrap().amount;
    lockup_account
        .transfer(owner.account_id.clone(), transfer_amount)
        .assert_success();

    let new_owner_balance = owner.account().unwrap().amount;
    assert_eq!(new_owner_balance, owner_balance + transfer_amount);
}

fn basic_setup() -> (UserAccount, UserAccount, UserAccount, UserAccount) {
    let mut genesis_config = GenesisConfig::default();
    genesis_config.block_prod_time = 0;
    let root = init_simulator(Some(genesis_config));

    let foundation = root.create_user("foundation".to_string(), to_yocto("10000"));

    let owner = root.create_user("owner".to_string(), to_yocto("30"));

    // Creating whitelist account
    let _whitelist = root.deploy_and_init(
        &WHITELIST_WASM_BYTES,
        STAKING_POOL_WHITELIST_ACCOUNT_ID.to_string(),
        "new",
        &json!({
            "foundation_account_id": foundation.valid_account_id(),
        })
        .to_string()
        .into_bytes(),
        to_yocto("30"),
        MAX_GAS,
    );

    // Whitelisting staking pool
    foundation
        .call(
            STAKING_POOL_WHITELIST_ACCOUNT_ID.to_string(),
            "add_staking_pool",
            &json!({
                "staking_pool_account_id": STAKING_POOL_ACCOUNT_ID.to_string(),
            })
            .to_string()
            .into_bytes(),
            MAX_GAS,
            NO_DEPOSIT,
        )
        .assert_success();

    // Creating staking pool
    let staking_pool = root.deploy_and_init(
        &STAKING_POOL_WASM_BYTES,
        STAKING_POOL_ACCOUNT_ID.to_string(),
        "new",
        &json!({
            "owner_id": foundation.valid_account_id(),
            "stake_public_key": "ed25519:3tysLvy7KGoE8pznUgXvSHa4vYyGvrDZFcT8jgb8PEQ6",
            "reward_fee_fraction": {
                "numerator": 10,
                "denominator": 100
            }
        })
        .to_string()
        .into_bytes(),
        to_yocto("40"),
        MAX_GAS,
    );

    (root, foundation, owner, staking_pool)
}

'''
'''--- multisig-factory/Cargo.toml ---
[package]
name = "multisig-factory"
version = "0.1.0"
authors = ["Near Inc <hello@near.org>"]
edition = "2018"
publish = false

[lib]
crate-type = ["cdylib"]

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[dependencies]
near-sdk = "2.0.0"

'''
'''--- multisig-factory/README.md ---
# Multisig Factory

Allows to create new [Multisig contracts](../multisig) just by sending a transactions with the required configuration and funds.
E.g. Removes need for using `near repl` and having wasm file available.

# Deployment & Usage

## TestNet

Deploy to new developer account on TestNet:

```
near dev-deploy --wasmFile=res/multisig_factory.wasm
```

Setup variable for the contract to use commands below easier:

```
# bash
CONTRACT_ID="dev-1608694678554-8567049"

# fish
set CONTRACT_ID "dev-1608694678554-8567049"
```

Create a new multisig with the given parameters and attached amount (50N) passed to multisig contract:

```
near call $CONTRACT_ID create '{"name": "test", "members": [{"account_id": "illia"}, {"account_id": "testmewell.testnet"}, {"public_key": "ed25519:Eg2jtsiMrprn7zgKKUk79qM1hWhANsFyE6JSX4txLEuy"}], "num_confirmations": 1}'  --accountId $CONTRACT_ID --amount 50 --gas 100000000000000
```

'''
'''--- multisig-factory/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo +stable build --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/multisig_factory.wasm ./res/

'''
'''--- multisig-factory/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::Base58PublicKey;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::serde_json::json;
use near_sdk::{env, near_bindgen, AccountId, Promise};

#[global_allocator]
static ALLOC: near_sdk::wee_alloc::WeeAlloc<'_> = near_sdk::wee_alloc::WeeAlloc::INIT;

const CODE: &[u8] = include_bytes!("../../multisig2/res/multisig2.wasm");

/// This gas spent on the call & account creation, the rest goes to the `new` call.
const CREATE_CALL_GAS: u64 = 50_000_000_000_000;

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde", untagged)]
pub enum MultisigMember {
    AccessKey { public_key: Base58PublicKey },
    Account { account_id: AccountId },
}

#[near_bindgen]
#[derive(BorshSerialize, BorshDeserialize, Default)]
pub struct MultisigFactory {}

#[near_bindgen]
impl MultisigFactory {
    #[payable]
    pub fn create(
        &mut self,
        name: AccountId,
        members: Vec<MultisigMember>,
        num_confirmations: u64,
    ) -> Promise {
        let account_id = format!("{}.{}", name, env::current_account_id());
        Promise::new(account_id)
            .create_account()
            .deploy_contract(CODE.to_vec())
            .transfer(env::attached_deposit())
            .function_call(
                b"new".to_vec(),
                json!({ "members": members, "num_confirmations": num_confirmations })
                    .to_string()
                    .as_bytes()
                    .to_vec(),
                0,
                env::prepaid_gas() - CREATE_CALL_GAS,
            )
    }
}

'''
'''--- multisig/Cargo.toml ---
[package]
name = "multisig"
version = "0.2.0"
authors = ["Near Inc <hello@near.org>"]
edition = "2018"
publish = false

[lib]
crate-type = ["cdylib", "rlib"]

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "s"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[dependencies]
near-sdk = "2.0.0"

[dev-dependencies]
lazy_static = "1.4.0"
near-test = { git = "https://github.com/ilblackdragon/balancer-near" }
near-crypto = { git = "https://github.com/nearprotocol/nearcore.git" }
near-primitives = { git = "https://github.com/nearprotocol/nearcore.git" }

'''
'''--- multisig/README.md ---
# Basic Multisig contract

This contract provides:
 - Set K out of N multi sig scheme
 - Request to sign transfers, function calls, adding and removing keys.
 - Any of the access keys can confirm, until the required number of confirmation achieved.

## Multisig implementation details

Mutlisig uses set of `FunctionCall` `AccessKey`s as a set of allowed N keys. 
When contract is being setup, it should be initialized with set of keys that will be initially managing this account.
All operations going forward will require `K` signatures to be performed.

### Initialization

### Request

There are number of different request types that multisig can confirm and execute:
```rust
/// Lowest level action that can be performed by the multisig contract.
pub enum MultiSigRequestAction {
    /// Transfers given amount to receiver.
    Transfer {
        amount: U128,
    },
    /// Create a new account.
    CreateAccount,
    /// Deploys contract to receiver's account. Can upgrade given contract as well.
    DeployContract { code: Base64VecU8 },
    /// Adds key, either new key for multisig or full access key to another account.
    AddKey {
        public_key: Base58PublicKey,
        #[serde(skip_serializing_if = "Option::is_none")]
        permission: Option<FunctionCallPermission>,
    },
    /// Deletes key, either one of the keys from multisig or key from another account.
    DeleteKey {
        public_key: Base58PublicKey,
    },
    /// Call function on behalf of this contract.
    FunctionCall {
        method_name: String,
        args: Base64VecU8,
        deposit: U128,
        gas: U64,
    },
    /// Sets number of confirmations required to authorize requests.
    /// Can not be bundled with any other actions or transactions.
    SetNumConfirmations {
        num_confirmations: u32,
    },
    /// Sets number of active requests (unconfirmed requests) per access key
    /// Default is 12 unconfirmed requests at a time
    /// The REQUEST_COOLDOWN for requests is 15min
    /// Worst gas attack a malicious keyholder could do is 12 requests every 15min
    SetActiveRequestsLimit {
        active_requests_limit: u32,
    },
}

/// Permission for an access key, scoped to receiving account and method names with allowance to add when key is added to accoount
pub struct FunctionCallPermission {
    allowance: Option<U128>,
    receiver_id: AccountId,
    method_names: Vec<String>,
}

// The request the user makes specifying the receiving account and actions they want to execute (1 tx)
pub struct MultiSigRequest {
    receiver_id: AccountId,
    actions: Vec<MultiSigRequestAction>,
}

// An internal request wrapped with the signer_pk and added timestamp to determine num_requests_pk and prevent against malicious key holder gas attacks
pub struct MultiSigRequestWithSigner {
    request: MultiSigRequest,
    signer_pk: PublicKey,
    added_timestamp: u64,
}
```

### Methods

```rust
/// Add request for multisig.
pub fn add_request(&mut self, request: MultiSigRequest) -> RequestId {

/// Add request for multisig and confirm right away with the key that is adding the request.
pub fn add_request_and_confirm(&mut self, request: MultiSigRequest) -> RequestId {

/// Remove given request and associated confirmations.
pub fn delete_request(&mut self, request_id: RequestId) {

/// Confirm given request with given signing key.
/// If with this, there has been enough confirmation, a promise with request will be scheduled.
pub fn confirm(&mut self, request_id: RequestId) -> PromiseOrValue<bool> {
```

### View Methods
```rust
pub fn get_request(&self, request_id: RequestId) -> MultiSigRequest
pub fn get_num_requests_pk(&self, public_key: Base58PublicKey) -> u32
pub fn list_request_ids(&self) -> Vec<RequestId>
pub fn get_confirmations(&self, request_id: RequestId) -> Vec<Base58PublicKey>
pub fn get_num_confirmations(&self) -> u32
pub fn get_request_nonce(&self) -> u32
```

### State machine

Per each request, multisig maintains next state machine:
 - `add_request` adds new request with empty list of confirmations.
 - `add_request_and_confirm` adds new request with 1 confirmation from the adding key.
 - `delete_request` deletes request and ends state machine.
 - `confirm` either adds new confirmation to list of confirmations or if there is more than `num_confirmations` confirmations with given call - switches to execution of request. `confirm` fails if request is already has been confirmed and already is executing which is determined if `confirmations` contain given `request_id`.
 - each step of execution, schedules a promise of given set of actions on `receiver_id` and puts a callback.
 - when callback executes, it checks if promise executed successfully: if no - stops executing the request and return failure. If yes - execute next transaction in the request if present.
 - when all transactions are executed, remove request from `requests` and with that finish the execution of the request.   

### Gotchas
 
User can delete access keys on the multisig such that total number of different access keys will fall below `num_confirmations`, rendering contract locked.
This is due to not having a way to query blockchain for current number of access keys on the account. See discussion here - https://github.com/nearprotocol/NEPs/issues/79.
 
## Pre-requisites

To develop Rust contracts you would need to:
* Install [Rustup](https://rustup.rs/):
```bash
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
```
* Add wasm target to your toolchain:
```bash
rustup target add wasm32-unknown-unknown
```

## Building the contract

```bash
./build.sh
```

## Usage

Before deploying the contract, you need to collect all public keys that it will be initialized with.

Commands to deploy and initialize a 2 out of 3 multisig contract via `near repl`:

```javascript
const fs = require('fs');
const account = await near.account("illia");
const contractName = "multisig.illia";
const methodNames = ["add_request","delete_request","confirm"];
const newArgs = {"num_confirmations": 2};
const result = account.signAndSendTransaction(
    contractName,
    [
        nearAPI.transactions.createAccount(),
        nearAPI.transactions.transfer("100000000000000000000000000"),  
        nearAPI.transactions.addKey(
            nearAPI.utils.PublicKey.from("Eg2jtsiMrprn7zgKKUk79qM1hWhANsFyE6JSX4txLEuy"),
            nearAPI.transactions.functionCallAccessKey(contractName, methodNames, null)),
        nearAPI.transactions.addKey(
            nearAPI.utils.PublicKey.from("HghiythFFPjVXwc9BLNi8uqFmfQc1DWFrJQ4nE6ANo7R"),
            nearAPI.transactions.functionCallAccessKey(contractName, methodNames, null)),
        nearAPI.transactions.addKey(
            nearAPI.utils.PublicKey.from("2EfbwnQHPBWQKbNczLiVznFghh9qs716QT71zN6L1D95"),
            nearAPI.transactions.functionCallAccessKey(contractName, methodNames, null)),
        nearAPI.transactions.deployContract(fs.readFileSync("res/multisig.wasm")),
        nearAPI.transactions.functionCall("new", Buffer.from(JSON.stringify(newArgs)), 10000000000000, "0"),
    ]);
```

### Create request

To create request for transfer funds:
```bash
near call multisig.illia add_request '{"request": {"receiver_id": "illia", "actions": [{"type": "Transfer", "amount": "1000000000000000000000"}]}}' --accountId multisig.illia
```

Add another key to multisig:
```bash
near call multisig.illia add_request '{"request": {"receiver_id": "multisig.illia", "actions": [{"type": "AddKey", "public_key": "<base58 of the key>"}]}}' --accountId multisig.illia
```

Change number of confirmations required to approve multisig:
```bash
near call multisig.illia add_request '{"request": {"receiver_id": "multisig.illia", "actions": [{"type": "SetNumConfirmations", "num_confirmations": 2}]}}' --accountId multisig.illia
```

Returns the `request_id` of this request that can be used to confirm or see details.

As a side note, for this to work one of the keys from multisig should be available in your `~/.near-credentials/<network>/<multisig-name>.json` or use `--useLedgerKey` to sign with Ledger.

You can also create a way more complex call that chains calling multiple different contracts:

### Confirm request

To confirm a specific request:
```bash
near call multisig.illia confirm '{"request_id": 0}' --accountId multisig.illia
```

### View requests

To list all requests ids:
```bash
near view multisig.illia list_request_ids
```

To see information about specific request:
```bash
near view multisig.illia get_request '{"request_id": 0}'
```

To see confirmations for specific request:
```bash
near view multisig.illia get_confirmations '{"request_id": 0}'
```

Total confirmations required for any request:
```
near view multisig.illia get_num_confirmations
```

### Upgrade given multisig with new code

Create a request that deploys new contract code on the given account.
Be careful about data and requiring migrations (contract updates should include data migrations going forward). 

```javascript
const fs = require('fs');
const account = await near.account("multisig.illia");
const contractName = "multisig.illia";
const requestArgs = {"request": [
    {"receiver_id": "multisig.illia", "actions": [{"type": "DeployContract", "code": fs.readFileSync("res/multisig.wasm")}]}
]};
const result = account.signAndSendTransaction(
    contractName,
    [
        nearAPI.transactions.functionCall("add_request", Buffer.from(JSON.stringify(requestArgs)), 10000000000000, "0"),
    ]);
```

After this, still will need to confirm this with `num_confirmations` you have setup for given contract.

### Common commands for multisig

__Create an account__

```
near call illia.near add_request '{"request": {"receiver_id": "new_account.near", "actions": [{"type", "CreateAccount"}, {"type": "Transfer", "amount": "1000000000000000000000"}, {"type": "AddKey", "public_key": "<public key for the new account>"}]}}' --accountId illia.near
near call illia.near confirm '{"request_id": <request number from previous line>}'
```

'''
'''--- multisig/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/multisig.wasm ./res/

'''
'''--- multisig/src/lib.rs ---
use std::collections::HashSet;
use std::convert::TryFrom;

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::UnorderedMap;
use near_sdk::json_types::{Base58PublicKey, Base64VecU8, U128, U64};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{env, near_bindgen, AccountId, Promise, PromiseOrValue, PublicKey};

/// Unlimited allowance for multisig keys.
const DEFAULT_ALLOWANCE: u128 = 0;

// Request cooldown period (time before a request can be deleted)
const REQUEST_COOLDOWN: u64 = 900_000_000_000;

pub type RequestId = u32;

/// Permissions for function call access key.
#[derive(Clone, PartialEq, BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct FunctionCallPermission {
    allowance: Option<U128>,
    receiver_id: AccountId,
    method_names: Vec<String>,
}

/// Lowest level action that can be performed by the multisig contract.
#[derive(Clone, PartialEq, BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(tag = "type", crate = "near_sdk::serde")]
pub enum MultiSigRequestAction {
    /// Transfers given amount to receiver.
    Transfer { amount: U128 },
    /// Create a new account.
    CreateAccount,
    /// Deploys contract to receiver's account. Can upgrade given contract as well.
    DeployContract { code: Base64VecU8 },
    /// Adds key, either new key for multisig or full access key to another account.
    AddKey {
        public_key: Base58PublicKey,
        #[serde(skip_serializing_if = "Option::is_none")]
        permission: Option<FunctionCallPermission>,
    },
    /// Deletes key, either one of the keys from multisig or key from another account.
    DeleteKey { public_key: Base58PublicKey },
    /// Call function on behalf of this contract.
    FunctionCall {
        method_name: String,
        args: Base64VecU8,
        deposit: U128,
        gas: U64,
    },
    /// Sets number of confirmations required to authorize requests.
    /// Can not be bundled with any other actions or transactions.
    SetNumConfirmations { num_confirmations: u32 },
    /// Sets number of active requests (unconfirmed requests) per access key
    /// Default is 12 unconfirmed requests at a time
    /// The REQUEST_COOLDOWN for requests is 15min
    /// Worst gas attack a malicious keyholder could do is 12 requests every 15min
    SetActiveRequestsLimit { active_requests_limit: u32 },
}

// The request the user makes specifying the receiving account and actions they want to execute (1 tx)
#[derive(Clone, PartialEq, BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct MultiSigRequest {
    receiver_id: AccountId,
    actions: Vec<MultiSigRequestAction>,
}

// An internal request wrapped with the signer_pk and added timestamp to determine num_requests_pk and prevent against malicious key holder gas attacks
#[derive(Clone, PartialEq, BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct MultiSigRequestWithSigner {
    request: MultiSigRequest,
    signer_pk: PublicKey,
    added_timestamp: u64,
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct MultiSigContract {
    num_confirmations: u32,
    request_nonce: RequestId,
    requests: UnorderedMap<RequestId, MultiSigRequestWithSigner>,
    confirmations: UnorderedMap<RequestId, HashSet<PublicKey>>,
    num_requests_pk: UnorderedMap<PublicKey, u32>,
    // per key
    active_requests_limit: u32,
}

// If you haven't initialized the contract with new(num_confirmations: u32)
impl Default for MultiSigContract {
    fn default() -> Self {
        env::panic(b"Multisig contract should be initialized before usage")
    }
}

#[near_bindgen]
impl MultiSigContract {
    /// Initialize multisig contract.
    /// @params num_confirmations: k of n signatures required to perform operations.
    #[init]
    pub fn new(num_confirmations: u32) -> Self {
        assert!(!env::state_exists(), "Already initialized");
        Self {
            num_confirmations,
            request_nonce: 0,
            requests: UnorderedMap::new(b"r".to_vec()),
            confirmations: UnorderedMap::new(b"c".to_vec()),
            num_requests_pk: UnorderedMap::new(b"k".to_vec()),
            active_requests_limit: 12,
        }
    }

    /// Add request for multisig.
    pub fn add_request(&mut self, request: MultiSigRequest) -> RequestId {
        assert_eq!(
            env::current_account_id(),
            env::predecessor_account_id(),
            "Predecessor account must much current account"
        );
        // track how many requests this key has made
        let num_requests = self
            .num_requests_pk
            .get(&env::signer_account_pk())
            .unwrap_or(0)
            + 1;
        assert!(
            num_requests <= self.active_requests_limit,
            "Account has too many active requests. Confirm or delete some."
        );
        self.num_requests_pk
            .insert(&env::signer_account_pk(), &num_requests);
        // add the request
        let request_added = MultiSigRequestWithSigner {
            signer_pk: env::signer_account_pk(),
            added_timestamp: env::block_timestamp(),
            request: request,
        };
        self.requests.insert(&self.request_nonce, &request_added);
        let confirmations = HashSet::new();
        self.confirmations
            .insert(&self.request_nonce, &confirmations);
        self.request_nonce += 1;
        self.request_nonce - 1
    }

    /// Add request for multisig and confirm with the pk that added.
    pub fn add_request_and_confirm(&mut self, request: MultiSigRequest) -> RequestId {
        let request_id = self.add_request(request);
        self.confirm(request_id);
        request_id
    }

    /// Remove given request and associated confirmations.
    pub fn delete_request(&mut self, request_id: RequestId) -> MultiSigRequest {
        self.assert_valid_request(request_id);
        let request_with_signer = self.requests.get(&request_id).expect("No such request");
        // can't delete requests before 15min
        assert!(
            env::block_timestamp() > request_with_signer.added_timestamp + REQUEST_COOLDOWN,
            "Request cannot be deleted immediately after creation."
        );
        self.remove_request(request_id)
    }

    fn execute_request(&mut self, request: MultiSigRequest) -> PromiseOrValue<bool> {
        let mut promise = Promise::new(request.receiver_id.clone());
        let receiver_id = request.receiver_id.clone();
        let num_actions = request.actions.len();
        for action in request.actions {
            promise = match action {
                MultiSigRequestAction::Transfer { amount } => promise.transfer(amount.into()),
                MultiSigRequestAction::CreateAccount => promise.create_account(),
                MultiSigRequestAction::DeployContract { code } => {
                    promise.deploy_contract(code.into())
                }
                MultiSigRequestAction::AddKey {
                    public_key,
                    permission,
                } => {
                    self.assert_self_request(receiver_id.clone());
                    if let Some(permission) = permission {
                        promise.add_access_key(
                            public_key.into(),
                            permission
                                .allowance
                                .map(|x| x.into())
                                .unwrap_or(DEFAULT_ALLOWANCE),
                            permission.receiver_id,
                            permission.method_names.join(",").into_bytes(),
                        )
                    } else {
                        // wallet UI should warn user if receiver_id == env::current_account_id(), adding FAK will render multisig useless
                        promise.add_full_access_key(public_key.into())
                    }
                }
                MultiSigRequestAction::DeleteKey { public_key } => {
                    self.assert_self_request(receiver_id.clone());
                    let pk: PublicKey = public_key.into();
                    // delete outstanding requests by public_key
                    let request_ids: Vec<u32> = self
                        .requests
                        .iter()
                        .filter(|(_k, r)| r.signer_pk == pk)
                        .map(|(k, _r)| k)
                        .collect();
                    for request_id in request_ids {
                        // remove confirmations for this request
                        self.confirmations.remove(&request_id);
                        self.requests.remove(&request_id);
                    }
                    // remove num_requests_pk entry for public_key
                    self.num_requests_pk.remove(&pk);
                    promise.delete_key(pk)
                }
                MultiSigRequestAction::FunctionCall {
                    method_name,
                    args,
                    deposit,
                    gas,
                } => promise.function_call(
                    method_name.into_bytes(),
                    args.into(),
                    deposit.into(),
                    gas.into(),
                ),
                // the following methods must be a single action
                MultiSigRequestAction::SetNumConfirmations { num_confirmations } => {
                    self.assert_one_action_only(receiver_id, num_actions);
                    self.num_confirmations = num_confirmations;
                    return PromiseOrValue::Value(true);
                }
                MultiSigRequestAction::SetActiveRequestsLimit {
                    active_requests_limit,
                } => {
                    self.assert_one_action_only(receiver_id, num_actions);
                    self.active_requests_limit = active_requests_limit;
                    return PromiseOrValue::Value(true);
                }
            };
        }
        promise.into()
    }

    /// Confirm given request with given signing key.
    /// If with this, there has been enough confirmation, a promise with request will be scheduled.
    pub fn confirm(&mut self, request_id: RequestId) -> PromiseOrValue<bool> {
        self.assert_valid_request(request_id);
        let mut confirmations = self.confirmations.get(&request_id).unwrap();
        assert!(
            !confirmations.contains(&env::signer_account_pk()),
            "Already confirmed this request with this key"
        );
        if confirmations.len() as u32 + 1 >= self.num_confirmations {
            let request = self.remove_request(request_id);
            /********************************
            NOTE: If the tx execution fails for any reason, the request and confirmations are removed already, so the client has to start all over
            ********************************/
            self.execute_request(request)
        } else {
            confirmations.insert(env::signer_account_pk());
            self.confirmations.insert(&request_id, &confirmations);
            PromiseOrValue::Value(true)
        }
    }

    /********************************
    Helper methods
    ********************************/
    // removes request, removes confirmations and reduces num_requests_pk - used in delete, delete_key, and confirm
    fn remove_request(&mut self, request_id: RequestId) -> MultiSigRequest {
        // remove confirmations for this request
        self.confirmations.remove(&request_id);
        // remove the original request
        let request_with_signer = self
            .requests
            .remove(&request_id)
            .expect("Failed to remove existing element");
        // decrement num_requests for original request signer
        let original_signer_pk = request_with_signer.signer_pk;
        let mut num_requests = self.num_requests_pk.get(&original_signer_pk).unwrap_or(0);
        // safety check for underrun (unlikely since original_signer_pk must have num_requests_pk > 0)
        if num_requests > 0 {
            num_requests = num_requests - 1;
        }
        self.num_requests_pk
            .insert(&original_signer_pk, &num_requests);
        // return request
        request_with_signer.request
    }
    // Prevents access to calling requests and make sure request_id is valid - used in delete and confirm
    fn assert_valid_request(&mut self, request_id: RequestId) {
        // request must come from key added to contract account
        assert_eq!(
            env::current_account_id(),
            env::predecessor_account_id(),
            "Predecessor account must much current account"
        );
        // request must exist
        assert!(
            self.requests.get(&request_id).is_some(),
            "No such request: either wrong number or already confirmed"
        );
        // request must have
        assert!(
            self.confirmations.get(&request_id).is_some(),
            "Internal error: confirmations mismatch requests"
        );
    }
    // Prevents request from approving tx on another account
    fn assert_self_request(&mut self, receiver_id: AccountId) {
        assert_eq!(
            receiver_id,
            env::current_account_id(),
            "This method only works when receiver_id is equal to current_account_id"
        );
    }
    // Prevents a request from being bundled with other actions
    fn assert_one_action_only(&mut self, receiver_id: AccountId, num_actions: usize) {
        self.assert_self_request(receiver_id);
        assert_eq!(num_actions, 1, "This method should be a separate request");
    }
    /********************************
    View methods
    ********************************/
    pub fn get_request(&self, request_id: RequestId) -> MultiSigRequest {
        (self.requests.get(&request_id).expect("No such request")).request
    }

    pub fn get_num_requests_pk(&self, public_key: Base58PublicKey) -> u32 {
        self.num_requests_pk.get(&public_key.into()).unwrap_or(0)
    }

    pub fn list_request_ids(&self) -> Vec<RequestId> {
        self.requests.keys().collect()
    }

    pub fn get_confirmations(&self, request_id: RequestId) -> Vec<Base58PublicKey> {
        self.confirmations
            .get(&request_id)
            .expect("No such request")
            .into_iter()
            .map(|key| Base58PublicKey::try_from(key).expect("Failed to covert key to base58"))
            .collect()
    }

    pub fn get_num_confirmations(&self) -> u32 {
        self.num_confirmations
    }

    pub fn get_request_nonce(&self) -> u32 {
        self.request_nonce
    }
}

#[cfg(test)]
mod tests {
    use std::fmt::{Debug, Error, Formatter};

    use near_sdk::{testing_env, MockedBlockchain};
    use near_sdk::{AccountId, VMContext};
    use near_sdk::{Balance, BlockHeight, EpochHeight};

    use super::*;

    /// Used for asserts_eq.
    /// TODO: replace with derive when https://github.com/near/near-sdk-rs/issues/165
    impl Debug for MultiSigRequest {
        fn fmt(&self, _f: &mut Formatter<'_>) -> Result<(), Error> {
            panic!("Should not trigger");
        }
    }

    pub fn alice() -> AccountId {
        "alice".to_string()
    }
    pub fn bob() -> AccountId {
        "bob".to_string()
    }

    pub struct VMContextBuilder {
        context: VMContext,
    }

    impl VMContextBuilder {
        pub fn new() -> Self {
            Self {
                context: VMContext {
                    current_account_id: "".to_string(),
                    signer_account_id: "".to_string(),
                    signer_account_pk: vec![0, 1, 2],
                    predecessor_account_id: "".to_string(),
                    input: vec![],
                    epoch_height: 0,
                    block_index: 0,
                    block_timestamp: 0,
                    account_balance: 0,
                    account_locked_balance: 0,
                    storage_usage: 10u64.pow(6),
                    attached_deposit: 0,
                    prepaid_gas: 10u64.pow(18),
                    random_seed: vec![0, 1, 2],
                    is_view: false,
                    output_data_receivers: vec![],
                },
            }
        }

        pub fn current_account_id(mut self, account_id: AccountId) -> Self {
            self.context.current_account_id = account_id;
            self
        }

        pub fn block_timestamp(mut self, time: u64) -> Self {
            self.context.block_timestamp = time;
            self
        }

        #[allow(dead_code)]
        pub fn signer_account_id(mut self, account_id: AccountId) -> Self {
            self.context.signer_account_id = account_id;
            self
        }

        pub fn signer_account_pk(mut self, signer_account_pk: PublicKey) -> Self {
            self.context.signer_account_pk = signer_account_pk;
            self
        }

        pub fn predecessor_account_id(mut self, account_id: AccountId) -> Self {
            self.context.predecessor_account_id = account_id;
            self
        }

        #[allow(dead_code)]
        pub fn block_index(mut self, block_index: BlockHeight) -> Self {
            self.context.block_index = block_index;
            self
        }

        #[allow(dead_code)]
        pub fn epoch_height(mut self, epoch_height: EpochHeight) -> Self {
            self.context.epoch_height = epoch_height;
            self
        }

        #[allow(dead_code)]
        pub fn attached_deposit(mut self, amount: Balance) -> Self {
            self.context.attached_deposit = amount;
            self
        }

        pub fn account_balance(mut self, amount: Balance) -> Self {
            self.context.account_balance = amount;
            self
        }

        #[allow(dead_code)]
        pub fn account_locked_balance(mut self, amount: Balance) -> Self {
            self.context.account_locked_balance = amount;
            self
        }

        pub fn finish(self) -> VMContext {
            self.context
        }
    }

    fn context_with_key(key: PublicKey, amount: Balance) -> VMContext {
        VMContextBuilder::new()
            .current_account_id(alice())
            .predecessor_account_id(alice())
            .signer_account_id(alice())
            .signer_account_pk(key)
            .account_balance(amount)
            .finish()
    }

    fn context_with_key_future(key: PublicKey, amount: Balance) -> VMContext {
        VMContextBuilder::new()
            .current_account_id(alice())
            .block_timestamp(REQUEST_COOLDOWN + 1)
            .predecessor_account_id(alice())
            .signer_account_id(alice())
            .signer_account_pk(key)
            .account_balance(amount)
            .finish()
    }

    #[test]
    fn test_multi_3_of_n() {
        let amount = 1_000;
        testing_env!(context_with_key(
            Base58PublicKey::try_from("Eg2jtsiMrprn7zgKKUk79qM1hWhANsFyE6JSX4txLEuy")
                .unwrap()
                .into(),
            amount
        ));
        let mut c = MultiSigContract::new(3);
        let request = MultiSigRequest {
            receiver_id: bob(),
            actions: vec![MultiSigRequestAction::Transfer {
                amount: amount.into(),
            }],
        };
        let request_id = c.add_request(request.clone());
        assert_eq!(c.get_request(request_id), request);
        assert_eq!(c.list_request_ids(), vec![request_id]);
        c.confirm(request_id);
        assert_eq!(c.requests.len(), 1);
        assert_eq!(c.confirmations.get(&request_id).unwrap().len(), 1);
        testing_env!(context_with_key(
            Base58PublicKey::try_from("HghiythFFPjVXwc9BLNi8uqFmfQc1DWFrJQ4nE6ANo7R")
                .unwrap()
                .into(),
            amount
        ));
        c.confirm(request_id);
        assert_eq!(c.confirmations.get(&request_id).unwrap().len(), 2);
        assert_eq!(c.get_confirmations(request_id).len(), 2);
        testing_env!(context_with_key(
            Base58PublicKey::try_from("2EfbwnQHPBWQKbNczLiVznFghh9qs716QT71zN6L1D95")
                .unwrap()
                .into(),
            amount
        ));
        c.confirm(request_id);
        // TODO: confirm that funds were transferred out via promise.
        assert_eq!(c.requests.len(), 0);
    }

    #[test]
    fn test_multi_add_request_and_confirm() {
        let amount = 1_000;
        testing_env!(context_with_key(
            Base58PublicKey::try_from("Eg2jtsiMrprn7zgKKUk79qM1hWhANsFyE6JSX4txLEuy")
                .unwrap()
                .into(),
            amount
        ));
        let mut c = MultiSigContract::new(3);
        let request = MultiSigRequest {
            receiver_id: bob(),
            actions: vec![MultiSigRequestAction::Transfer {
                amount: amount.into(),
            }],
        };
        let request_id = c.add_request_and_confirm(request.clone());
        assert_eq!(c.get_request(request_id), request);
        assert_eq!(c.list_request_ids(), vec![request_id]);
        // c.confirm(request_id);
        assert_eq!(c.requests.len(), 1);
        assert_eq!(c.confirmations.get(&request_id).unwrap().len(), 1);
        testing_env!(context_with_key(
            Base58PublicKey::try_from("HghiythFFPjVXwc9BLNi8uqFmfQc1DWFrJQ4nE6ANo7R")
                .unwrap()
                .into(),
            amount
        ));
        c.confirm(request_id);
        assert_eq!(c.confirmations.get(&request_id).unwrap().len(), 2);
        assert_eq!(c.get_confirmations(request_id).len(), 2);
        testing_env!(context_with_key(
            Base58PublicKey::try_from("2EfbwnQHPBWQKbNczLiVznFghh9qs716QT71zN6L1D95")
                .unwrap()
                .into(),
            amount
        ));
        c.confirm(request_id);
        // TODO: confirm that funds were transferred out via promise.
        assert_eq!(c.requests.len(), 0);
    }

    #[test]
    fn add_key_delete_key_storage_cleared() {
        let amount = 1_000;
        testing_env!(context_with_key(
            Base58PublicKey::try_from("Eg2jtsiMrprn7zgKKUk79qM1hWhANsFyE6JSX4txLEuy")
                .unwrap()
                .into(),
            amount
        ));
        let mut c = MultiSigContract::new(1);
        let new_key: Base58PublicKey =
            Base58PublicKey::try_from("HghiythFFPjVXwc9BLNi8uqFmfQc1DWFrJQ4nE6ANo7R")
                .unwrap()
                .into();
        // vm current_account_id is alice, receiver_id must be alice
        let request = MultiSigRequest {
            receiver_id: alice(),
            actions: vec![MultiSigRequestAction::AddKey {
                public_key: new_key.clone(),
                permission: None,
            }],
        };
        // make request
        c.add_request_and_confirm(request.clone());
        // should be empty now
        assert_eq!(c.requests.len(), 0);
        // switch accounts
        testing_env!(context_with_key(
            Base58PublicKey::try_from("HghiythFFPjVXwc9BLNi8uqFmfQc1DWFrJQ4nE6ANo7R")
                .unwrap()
                .into(),
            amount
        ));
        let request2 = MultiSigRequest {
            receiver_id: alice(),
            actions: vec![MultiSigRequestAction::Transfer {
                amount: amount.into(),
            }],
        };
        // make request but don't confirm
        c.add_request(request2.clone());
        // should have 1 request now
        assert_eq!(c.requests.len(), 1);
        assert_eq!(c.get_num_requests_pk(new_key.clone()), 1);
        // self delete key
        let request3 = MultiSigRequest {
            receiver_id: alice(),
            actions: vec![MultiSigRequestAction::DeleteKey {
                public_key: new_key.clone(),
            }],
        };
        // make request and confirm
        c.add_request_and_confirm(request3.clone());
        // should be empty now
        assert_eq!(c.requests.len(), 0);
        assert_eq!(c.get_num_requests_pk(new_key.clone()), 0);
    }

    #[test]
    #[should_panic]
    fn test_panics_add_key_different_account() {
        let amount = 1_000;
        testing_env!(context_with_key(
            Base58PublicKey::try_from("Eg2jtsiMrprn7zgKKUk79qM1hWhANsFyE6JSX4txLEuy")
                .unwrap()
                .into(),
            amount
        ));
        let mut c = MultiSigContract::new(1);
        let new_key: Base58PublicKey =
            Base58PublicKey::try_from("HghiythFFPjVXwc9BLNi8uqFmfQc1DWFrJQ4nE6ANo7R")
                .unwrap()
                .into();
        // vm current_account_id is alice, receiver_id must be alice
        let request = MultiSigRequest {
            receiver_id: bob(),
            actions: vec![MultiSigRequestAction::AddKey {
                public_key: new_key.clone(),
                permission: None,
            }],
        };
        // make request
        c.add_request_and_confirm(request);
    }

    #[test]
    fn test_change_num_confirmations() {
        let amount = 1_000;
        testing_env!(context_with_key(vec![1, 2, 3], amount));
        let mut c = MultiSigContract::new(1);
        let request_id = c.add_request(MultiSigRequest {
            receiver_id: alice(),
            actions: vec![MultiSigRequestAction::SetNumConfirmations {
                num_confirmations: 2,
            }],
        });
        c.confirm(request_id);
        assert_eq!(c.num_confirmations, 2);
    }

    #[test]
    #[should_panic]
    fn test_panics_on_second_confirm() {
        let amount = 1_000;
        testing_env!(context_with_key(vec![5, 7, 9], amount));
        let mut c = MultiSigContract::new(3);
        let request_id = c.add_request(MultiSigRequest {
            receiver_id: bob(),
            actions: vec![MultiSigRequestAction::Transfer {
                amount: amount.into(),
            }],
        });
        assert_eq!(c.requests.len(), 1);
        assert_eq!(c.confirmations.get(&request_id).unwrap().len(), 0);
        c.confirm(request_id);
        assert_eq!(c.confirmations.get(&request_id).unwrap().len(), 1);
        c.confirm(request_id);
    }

    #[test]
    #[should_panic]
    fn test_panics_delete_request() {
        let amount = 1_000;
        testing_env!(context_with_key(vec![5, 7, 9], amount));
        let mut c = MultiSigContract::new(3);
        let request_id = c.add_request(MultiSigRequest {
            receiver_id: bob(),
            actions: vec![MultiSigRequestAction::Transfer {
                amount: amount.into(),
            }],
        });
        c.delete_request(request_id);
        assert_eq!(c.requests.len(), 0);
        assert_eq!(c.confirmations.len(), 0);
    }

    #[test]
    fn test_delete_request_future() {
        let amount = 1_000;
        testing_env!(context_with_key(vec![5, 7, 9], amount));
        let mut c = MultiSigContract::new(3);
        let request_id = c.add_request(MultiSigRequest {
            receiver_id: bob(),
            actions: vec![MultiSigRequestAction::Transfer {
                amount: amount.into(),
            }],
        });
        testing_env!(context_with_key_future(vec![5, 7, 9], amount));
        c.delete_request(request_id);
        assert_eq!(c.requests.len(), 0);
        assert_eq!(c.confirmations.len(), 0);
    }

    #[test]
    #[should_panic]
    fn test_delete_request_panic_wrong_key() {
        let amount = 1_000;
        testing_env!(context_with_key(vec![5, 7, 9], amount));
        let mut c = MultiSigContract::new(3);
        let request_id = c.add_request(MultiSigRequest {
            receiver_id: bob(),
            actions: vec![MultiSigRequestAction::Transfer {
                amount: amount.into(),
            }],
        });
        testing_env!(context_with_key(vec![1, 2, 3], amount));
        c.delete_request(request_id);
    }

    #[test]
    #[should_panic]
    fn test_too_many_requests() {
        let amount = 1_000;
        testing_env!(context_with_key(vec![5, 7, 9], amount));
        let mut c = MultiSigContract::new(3);
        for _i in 0..16 {
            c.add_request(MultiSigRequest {
                receiver_id: bob(),
                actions: vec![MultiSigRequestAction::Transfer {
                    amount: amount.into(),
                }],
            });
        }
    }
}

'''
'''--- multisig/tests/general.rs ---
use near_crypto::{InMemorySigner, KeyType, Signer};
use near_primitives::account::{AccessKey};
use near_sdk::serde_json::json;
use near_test::test_user::{init_test_runtime, to_yocto};

const DEFAULT_GAS: u64 = 300_000_000_000_000;

lazy_static::lazy_static! {
    static ref MULTISIG_WASM_BYTES: &'static [u8] = include_bytes!("../res/multisig.wasm").as_ref();
}

fn accounts(num: usize) -> String {
    ["root", "multisig"][num].to_string()
}

#[test]
fn setup_and_remove_multisig() {
    let mut runtime = init_test_runtime();
    let signer = InMemorySigner::from_seed(&accounts(0), KeyType::ED25519, "test");
    let _ = runtime.submit_transaction(
        runtime.transaction(accounts(0), accounts(1))
            .create_account()
            .transfer(to_yocto("100"))
            .deploy_contract(MULTISIG_WASM_BYTES.to_vec())
            .add_key(signer.public_key(), AccessKey::full_access())
            .function_call(
                "new".to_string(),
                json!({"num_confirmations": 1}).to_string().as_bytes().to_vec(),
                DEFAULT_GAS,
                0)).unwrap();
    let signer2 = InMemorySigner::from_seed(&accounts(1), KeyType::ED25519, "qqq");
    let args = json!({"request": {"receiver_id": accounts(1), "actions": [
        {"type": "AddKey", "public_key": signer2.public_key()},
        {"type": "DeployContract", "code": ""},
    ]}});
    let _ = runtime.call(accounts(1), accounts(1), "add_request", args, 0).unwrap();
    runtime.call(accounts(1), accounts(1), "confirm", json!({"request_id": 0}), 0).unwrap();
}

'''
'''--- multisig2/Cargo.toml ---
[package]
name = "multisig2"
version = "0.4.0"
authors = ["Near Inc <hello@near.org>"]
edition = "2018"
publish = false

[lib]
# Below is used for production
# crate-type = ["cdylib"]
# Below used when running simulation tests
crate-type = ["cdylib", "rlib"]

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "s"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[dependencies]
near-sdk = "4.0.0-pre.4"

[dev-dependencies]
near-sdk-sim = "3.2.0"
near-primitives-core = "0.4.0"

'''
'''--- multisig2/README.md ---
# Multisig contract

*Please do your own due diligence before using this contract. There is no guarantee that this contract doesn't have issues.*

This contract provides:
 - Set K out of N multi sig scheme
 - Request to sign transfers, function calls, adding and removing keys.
 - Any of the access keys or set of specified accounts can confirm, until the required number of confirmation achieved.

## Multisig implementation details

Multisig uses set of `FunctionCall` `AccessKey`s and account ids as a set of allowed N members. 
When contract is being setup, it should be initialized with set of members that will be initially managing this account.
All operations going forward will require `K` members to call `confirm` to be executed.

### Initialization

### Request

There are number of different request types that multisig can confirm and execute:
```rust
/// Lowest level action that can be performed by the multisig contract.
pub enum MultiSigRequestAction {
    /// Transfers given amount to receiver.
    Transfer {
        amount: U128,
    },
    /// Create a new account.
    CreateAccount,
    /// Deploys contract to receiver's account. Can upgrade given contract as well.
    DeployContract { code: Base64VecU8 },
    /// Adds new member to multisig, either public key or account.
    AddMember {
        member: MultisigMember,
    },
    /// Delete existing member from multisig, either public key or account.
    DeleteMember {
        member: MultisigMember,
    },
    /// Adds key, either new key for multisig or full access key to another account.
    AddKey {
        public_key: Base58PublicKey,
        #[serde(skip_serializing_if = "Option::is_none")]
        permission: Option<FunctionCallPermission>,
    },
    /// Call function on behalf of this contract.
    FunctionCall {
        method_name: String,
        args: Base64VecU8,
        deposit: U128,
        gas: U64,
    },
    /// Sets number of confirmations required to authorize requests.
    /// Can not be bundled with any other actions or transactions.
    SetNumConfirmations {
        num_confirmations: u32,
    },
    /// Sets number of active requests (unconfirmed requests) per access key
    /// Default is 12 unconfirmed requests at a time
    /// The REQUEST_COOLDOWN for requests is 15min
    /// Worst gas attack a malicious keyholder could do is 12 requests every 15min
    SetActiveRequestsLimit {
        active_requests_limit: u32,
    },
}

/// Permission for an access key, scoped to receiving account and method names with allowance to add when key is added to accoount
pub struct FunctionCallPermission {
    allowance: Option<U128>,
    receiver_id: AccountId,
    method_names: Vec<String>,
}

/// The request the user makes specifying the receiving account and actions they want to execute (1 tx)
pub struct MultiSigRequest {
    receiver_id: AccountId,
    actions: Vec<MultiSigRequestAction>,
}

/// An internal request wrapped with the signer_pk and added timestamp to determine num_requests_pk and prevent against malicious key holder gas attacks
pub struct MultiSigRequestWithSigner {
    request: MultiSigRequest,
    member: MultisigMember,
    added_timestamp: u64,
}

/// Represents member of the multsig: either account or access key to given account.
pub enum MultisigMember {
    AccessKey { public_key: Base58PublicKey },
    Account { account_id: AccountId },
}
```

### Methods

```rust
/// Add request for multisig.
pub fn add_request(&mut self, request: MultiSigRequest) -> RequestId {

/// Add request for multisig and confirm right away with the key that is adding the request.
pub fn add_request_and_confirm(&mut self, request: MultiSigRequest) -> RequestId {

/// Remove given request and associated confirmations.
pub fn delete_request(&mut self, request_id: RequestId) {

/// Confirm given request with given signing key.
/// If with this, there has been enough confirmation, a promise with request will be scheduled.
pub fn confirm(&mut self, request_id: RequestId) -> PromiseOrValue<bool> {
```

### View Methods
```rust
pub fn get_request(&self, request_id: RequestId) -> MultiSigRequest
pub fn get_num_requests_per_member(&self, member: MultisigMember) -> u32
pub fn list_request_ids(&self) -> Vec<RequestId>
pub fn get_confirmations(&self, request_id: RequestId) -> Vec<MultisigMember>
pub fn get_num_confirmations(&self) -> u32
pub fn get_request_nonce(&self) -> u32
```

### State machine

Per each request, multisig maintains next state machine:
 - `add_request` adds new request with empty list of confirmations.
 - `add_request_and_confirm` adds new request with 1 confirmation from the adding key.
 - `delete_request` deletes request and ends state machine.
 - `confirm` either adds new confirmation to list of confirmations or if there is more than `num_confirmations` confirmations with given call - switches to execution of request. `confirm` fails if request is already has been confirmed and already is executing which is determined if `confirmations` contain given `request_id`.
 - each step of execution, schedules a promise of given set of actions on `receiver_id` and puts a callback.
 - when callback executes, it checks if promise executed successfully: if no - stops executing the request and return failure. If yes - execute next transaction in the request if present.
 - when all transactions are executed, remove request from `requests` and with that finish the execution of the request.   
 
## Pre-requisites

To develop Rust contracts you would need to:
* Install [Rustup](https://rustup.rs/):
```bash
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
```
* Add wasm target to your toolchain:
```bash
rustup target add wasm32-unknown-unknown
```

## Building the contract

```bash
./build.sh
```

## Usage

Before deploying the contract, you need to collect all public keys that it will be initialized with.

Commands to deploy and initialize a 2 out of 3 multisig contract via `near repl`:

```javascript
const fs = require('fs');
const account = await near.account("illia");
const contractName = "multisig.illia";
const methodNames = ["add_request","delete_request","confirm"];
const newArgs = {"num_confirmations": 2, "members": [
        { "public_key": "ed25519:Eg2jtsiMrprn7zgKKUk79qM1hWhANsFyE6JSX4txLEuy" },
        { "public_key": "ed25519:HghiythFFPjVXwc9BLNi8uqFmfQc1DWFrJQ4nE6ANo7R" },
        { "public_key": "ed25519:2EfbwnQHPBWQKbNczLiVznFghh9qs716QT71zN6L1D95" },
        { "account_id": "illia" },
    ]};
const result = account.signAndSendTransaction(
    contractName,
    [
        nearAPI.transactions.createAccount(),
        nearAPI.transactions.transfer("100000000000000000000000000"),
        nearAPI.transactions.deployContract(fs.readFileSync("res/multisig.wasm")),
        nearAPI.transactions.functionCall("new", Buffer.from(JSON.stringify(newArgs)), 10000000000000, "0"),
    ]);
```

### Create request

To create request for transfer funds:
```bash
near call multisig.illia add_request '{"request": {"receiver_id": "illia", "actions": [{"type": "Transfer", "amount": "1000000000000000000000"}]}}' --accountId multisig.illia
```

Add another key to multisig:
```bash
near call multisig.illia add_request '{"request": {"receiver_id": "multisig.illia", "actions": [{"type": "AddMember", "member": {"public_key": "ed25519:<base58 of the key>"}}]}}' --accountId multisig.illia
```

Change number of confirmations required to approve multisig:
```bash
near call multisig.illia add_request '{"request": {"receiver_id": "multisig.illia", "actions": [{"type": "SetNumConfirmations", "num_confirmations": 2}]}}' --accountId multisig.illia
```

Returns the `request_id` of this request that can be used to confirm or see details.

As a side note, for this to work one of the keys from multisig should be available in your `~/.near-credentials/<network>/<multisig-name>.json` or use `--useLedgerKey` to sign with Ledger.

You can also create a way more complex call that chains calling multiple different contracts:

### Confirm request

To confirm a specific request:
```bash
near call multisig.illia confirm '{"request_id": 0}' --accountId multisig.illia
```

### View requests

To list all requests ids:
```bash
near view multisig.illia list_request_ids
```

To see information about specific request:
```bash
near view multisig.illia get_request '{"request_id": 0}'
```

To see confirmations for specific request:
```bash
near view multisig.illia get_confirmations '{"request_id": 0}'
```

Total confirmations required for any request:
```
near view multisig.illia get_num_confirmations
```

### Upgrade given multisig with new code

Create a request that deploys new contract code on the given account.
Be careful about data and requiring migrations (contract updates should include data migrations going forward). 

```javascript
const fs = require('fs');
const account = await near.account("multisig.illia");
const contractName = "multisig.illia";
const requestArgs = {"request": [
    {"receiver_id": "multisig.illia", "actions": [{"type": "DeployContract", "code": fs.readFileSync("res/multisig.wasm")}]}
]};
const result = account.signAndSendTransaction(
    contractName,
    [
        nearAPI.transactions.functionCall("add_request", Buffer.from(JSON.stringify(requestArgs)), 10000000000000, "0"),
    ]);
```

After this, still will need to confirm this with `num_confirmations` you have setup for given contract.

### Common commands for multisig

__Create an account__

```
near call illia.near add_request '{"request": {"receiver_id": "new_account.near", "actions": [{"type", "CreateAccount"}, {"type": "Transfer", "amount": "1000000000000000000000"}, {"type": "AddKey", "public_key": "<public key for the new account>"}]}}' --accountId illia.near
near call illia.near confirm '{"request_id": <request number from previous line>}'
```

## Deploying and building

This repository has simulation tests, which can offer more advanced testing functionality than unit tests. However, this means the manifest (`Cargo.toml`) should be modified to reduce the contract size when building for production.

Remove the `rlib` like shown here:

```diff
[lib]
# Below is used for production
+crate-type = ["cdylib"]
# Below used when running simulation tests
+# crate-type = ["cdylib", "rlib"]
```
'''
'''--- multisig2/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo +stable build --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/multisig2.wasm ./res/

'''
'''--- multisig2/src/lib.rs ---
use std::collections::HashSet;
use std::convert::TryInto;

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LookupMap, UnorderedMap, UnorderedSet};
use near_sdk::json_types::{Base64VecU8, U128, U64};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{
    env, near_bindgen, serde_json, AccountId, BorshStorageKey, Gas, PanicOnDefault, Promise,
    PromiseOrValue, PublicKey,
};

/// Unlimited allowance for multisig keys.
const DEFAULT_ALLOWANCE: u128 = 0;

/// Request cooldown period (time before a request can be deleted)
const REQUEST_COOLDOWN: u64 = 900_000_000_000;

/// Default limit of active requests.
const ACTIVE_REQUESTS_LIMIT: u32 = 12;

/// Default set of methods that access key should have.
const MULTISIG_METHOD_NAMES: &str = "add_request,delete_request,confirm,add_and_confirm_request";

pub type RequestId = u32;

/// Permissions for function call access key.
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[cfg_attr(test, derive(PartialEq, Clone))]
#[serde(crate = "near_sdk::serde")]
pub struct FunctionCallPermission {
    allowance: Option<U128>,
    receiver_id: AccountId,
    method_names: Vec<String>,
}

/// Lowest level action that can be performed by the multisig contract.
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[cfg_attr(test, derive(PartialEq, Clone))]
#[serde(tag = "type", crate = "near_sdk::serde")]
pub enum MultiSigRequestAction {
    /// Transfers given amount to receiver.
    Transfer { amount: U128 },
    /// Create a new account.
    CreateAccount,
    /// Deploys contract to receiver's account. Can upgrade given contract as well.
    DeployContract { code: Base64VecU8 },
    /// Add new member of the multisig.
    AddMember { member: MultisigMember },
    /// Remove existing member of the multisig.
    DeleteMember { member: MultisigMember },
    /// Adds full access key to another account.
    AddKey {
        public_key: PublicKey,
        #[serde(skip_serializing_if = "Option::is_none")]
        permission: Option<FunctionCallPermission>,
    },
    /// Call function on behalf of this contract.
    FunctionCall {
        method_name: String,
        args: Base64VecU8,
        deposit: U128,
        gas: U64,
    },
    /// Sets number of confirmations required to authorize requests.
    /// Can not be bundled with any other actions or transactions.
    SetNumConfirmations { num_confirmations: u32 },
    /// Sets number of active requests (unconfirmed requests) per access key
    /// Default is 12 unconfirmed requests at a time
    /// The REQUEST_COOLDOWN for requests is 15min
    /// Worst gas attack a malicious keyholder could do is 12 requests every 15min
    SetActiveRequestsLimit { active_requests_limit: u32 },
}

/// The request the user makes specifying the receiving account and actions they want to execute (1 tx)
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[cfg_attr(test, derive(PartialEq, Clone))]
#[serde(crate = "near_sdk::serde")]
pub struct MultiSigRequest {
    receiver_id: AccountId,
    actions: Vec<MultiSigRequestAction>,
}

/// An internal request wrapped with the signer_pk and added timestamp to determine num_requests_pk and prevent against malicious key holder gas attacks
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[cfg_attr(test, derive(PartialEq, Clone))]
#[serde(crate = "near_sdk::serde")]
pub struct MultiSigRequestWithSigner {
    request: MultiSigRequest,
    member: MultisigMember,
    added_timestamp: u64,
}

/// Represents member of the multsig: either account or access key to given account.
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone, PartialEq, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde", untagged)]
pub enum MultisigMember {
    AccessKey { public_key: PublicKey },
    Account { account_id: AccountId },
}

impl ToString for MultisigMember {
    fn to_string(&self) -> String {
        serde_json::to_string(&self).unwrap_or_else(|_| env::panic_str("Failed to serialize"))
    }
}

#[derive(BorshStorageKey, BorshSerialize)]
pub enum StorageKeys {
    Members,
    Requests,
    Confirmations,
    NumRequestsPk,
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct MultiSigContract {
    /// Members of the multisig.
    members: UnorderedSet<MultisigMember>,
    /// Number of confirmations required.
    num_confirmations: u32,
    /// Latest request nonce.
    request_nonce: RequestId,
    /// All active requests.
    requests: UnorderedMap<RequestId, MultiSigRequestWithSigner>,
    /// All confirmations for active requests.
    confirmations: LookupMap<RequestId, HashSet<String>>,
    /// Number of requests per member.
    num_requests_pk: LookupMap<String, u32>,
    /// Limit number of active requests per member.
    active_requests_limit: u32,
}

#[inline]
fn assert(condition: bool, error: &str) {
    if !condition {
        env::panic_str(error);
    }
}

#[near_bindgen]
impl MultiSigContract {
    /// Initialize multisig contract.
    /// @params members: list of {"account_id": "name"} or {"public_key": "key"} members.
    /// @params num_confirmations: k of n signatures required to perform operations.
    #[init]
    pub fn new(members: Vec<MultisigMember>, num_confirmations: u32) -> Self {
        assert(
            members.len() >= num_confirmations as usize,
            "Members list must be equal or larger than number of confirmations",
        );
        let mut multisig = Self {
            members: UnorderedSet::new(StorageKeys::Members),
            num_confirmations,
            request_nonce: 0,
            requests: UnorderedMap::new(StorageKeys::Requests),
            confirmations: LookupMap::new(StorageKeys::Confirmations),
            num_requests_pk: LookupMap::new(StorageKeys::NumRequestsPk),
            active_requests_limit: ACTIVE_REQUESTS_LIMIT,
        };
        let mut promise = Promise::new(env::current_account_id());
        for member in members {
            promise = multisig.add_member(promise, member);
        }
        multisig
    }

    /// Add request for multisig.
    pub fn add_request(&mut self, request: MultiSigRequest) -> RequestId {
        let current_member = self.current_member().unwrap_or_else(|| {
            env::panic_str(
                "Predecessor must be a member or transaction signed with key of given account",
            )
        });
        // track how many requests this key has made
        let num_requests = self
            .num_requests_pk
            .get(&current_member.to_string())
            .unwrap_or(0)
            + 1;
        assert(
            num_requests <= self.active_requests_limit,
            "Account has too many active requests. Confirm or delete some.",
        );
        self.num_requests_pk
            .insert(&current_member.to_string(), &num_requests);
        // add the request
        let request_added = MultiSigRequestWithSigner {
            member: current_member,
            added_timestamp: env::block_timestamp(),
            request,
        };
        self.requests.insert(&self.request_nonce, &request_added);
        let confirmations = HashSet::new();
        self.confirmations
            .insert(&self.request_nonce, &confirmations);
        self.request_nonce += 1;
        self.request_nonce - 1
    }

    /// Add request for multisig and confirm with the pk that added.
    pub fn add_request_and_confirm(&mut self, request: MultiSigRequest) -> RequestId {
        let request_id = self.add_request(request);
        self.confirm(request_id);
        request_id
    }

    /// Remove given request and associated confirmations.
    pub fn delete_request(&mut self, request_id: RequestId) {
        self.assert_valid_request(request_id);
        let request_with_signer = self
            .requests
            .get(&request_id)
            .unwrap_or_else(|| env::panic_str("No such request"));
        // can't delete requests before 15min
        assert(
            env::block_timestamp() > request_with_signer.added_timestamp + REQUEST_COOLDOWN,
            "Request cannot be deleted immediately after creation.",
        );
        self.remove_request(request_id);
    }

    fn execute_request(&mut self, request: MultiSigRequest) -> PromiseOrValue<bool> {
        let mut promise = Promise::new(request.receiver_id.clone());
        let receiver_id = request.receiver_id.clone();
        let num_actions = request.actions.len();
        for action in request.actions {
            promise = match action {
                MultiSigRequestAction::Transfer { amount } => promise.transfer(amount.into()),
                MultiSigRequestAction::CreateAccount => promise.create_account(),
                MultiSigRequestAction::DeployContract { code } => {
                    promise.deploy_contract(code.into())
                }
                MultiSigRequestAction::AddMember { member } => {
                    self.assert_self_request(receiver_id.clone());
                    self.add_member(promise, member)
                }
                MultiSigRequestAction::DeleteMember { member } => {
                    self.assert_self_request(receiver_id.clone());
                    self.delete_member(promise, member)
                }
                MultiSigRequestAction::AddKey {
                    public_key,
                    permission,
                } => {
                    self.assert_self_request(receiver_id.clone());
                    if let Some(permission) = permission {
                        promise.add_access_key(
                            public_key.into(),
                            permission
                                .allowance
                                .map(|x| x.into())
                                .unwrap_or(DEFAULT_ALLOWANCE),
                            permission.receiver_id,
                            permission.method_names.join(","),
                        )
                    } else {
                        // wallet UI should warn user if receiver_id == env::current_account_id(), adding FAK will render multisig useless
                        promise.add_full_access_key(public_key.into())
                    }
                }
                MultiSigRequestAction::FunctionCall {
                    method_name,
                    args,
                    deposit,
                    gas,
                } => promise.function_call(
                    method_name,
                    args.into(),
                    deposit.into(),
                    Gas::from(gas.0),
                ),
                // the following methods must be a single action
                MultiSigRequestAction::SetNumConfirmations { num_confirmations } => {
                    self.assert_one_action_only(receiver_id, num_actions);
                    self.num_confirmations = num_confirmations;
                    return PromiseOrValue::Value(true);
                }
                MultiSigRequestAction::SetActiveRequestsLimit {
                    active_requests_limit,
                } => {
                    self.assert_one_action_only(receiver_id, num_actions);
                    self.active_requests_limit = active_requests_limit;
                    return PromiseOrValue::Value(true);
                }
            };
        }
        promise.into()
    }

    /// Confirm given request with given signing key.
    /// If with this, there has been enough confirmation, a promise with request will be scheduled.
    pub fn confirm(&mut self, request_id: RequestId) -> PromiseOrValue<bool> {
        self.assert_valid_request(request_id);
        let member = self
            .current_member()
            .unwrap_or_else(|| env::panic_str("Must be validated above"));
        let mut confirmations = self.confirmations.get(&request_id).unwrap();
        assert(
            !confirmations.contains(&member.to_string()),
            "Already confirmed this request with this key",
        );
        if confirmations.len() as u32 + 1 >= self.num_confirmations {
            let request = self.remove_request(request_id);
            /********************************
            NOTE: If the tx execution fails for any reason, the request and confirmations are removed already, so the client has to start all over
            ********************************/
            self.execute_request(request)
        } else {
            confirmations.insert(member.to_string());
            self.confirmations.insert(&request_id, &confirmations);
            PromiseOrValue::Value(true)
        }
    }

    /********************************
    Helper methods
    ********************************/

    /// Returns current member: either predecessor as account or if it's the same as current account - signer.
    fn current_member(&self) -> Option<MultisigMember> {
        let member = if env::current_account_id() == env::predecessor_account_id() {
            MultisigMember::AccessKey {
                public_key: env::signer_account_pk()
                    .try_into()
                    .unwrap_or_else(|_| env::panic_str("Failed to deserialize public key")),
            }
        } else {
            MultisigMember::Account {
                account_id: env::predecessor_account_id(),
            }
        };
        if self.members.contains(&member) {
            Some(member)
        } else {
            None
        }
    }

    /// Add member to the list. Adds access key if member is key based.
    fn add_member(&mut self, promise: Promise, member: MultisigMember) -> Promise {
        self.members.insert(&member.clone().into());
        match member {
            MultisigMember::AccessKey { public_key } => promise.add_access_key(
                public_key.into(),
                DEFAULT_ALLOWANCE,
                env::current_account_id(),
                MULTISIG_METHOD_NAMES.to_string(),
            ),
            MultisigMember::Account { account_id: _ } => promise,
        }
    }

    /// Delete member from the list. Removes access key if the member is key based.
    fn delete_member(&mut self, promise: Promise, member: MultisigMember) -> Promise {
        assert(
            self.members.len() - 1 >= self.num_confirmations as u64,
            "Removing given member will make total number of members below number of confirmations",
        );
        // delete outstanding requests by public_key
        let request_ids: Vec<u32> = self
            .requests
            .iter()
            .filter_map(|(k, r)| if r.member == member { Some(k) } else { None })
            .collect();
        for request_id in request_ids {
            // remove confirmations for this request
            self.confirmations.remove(&request_id);
            self.requests.remove(&request_id);
        }
        // remove num_requests_pk entry for member
        self.num_requests_pk.remove(&member.to_string());
        self.members.remove(&member);
        match member {
            MultisigMember::AccessKey { public_key } => promise.delete_key(public_key.into()),
            MultisigMember::Account { account_id: _ } => promise,
        }
    }

    /// Removes request, removes confirmations and reduces num_requests_pk - used in delete, delete_key, and confirm
    fn remove_request(&mut self, request_id: RequestId) -> MultiSigRequest {
        // remove confirmations for this request
        self.confirmations.remove(&request_id);
        // remove the original request
        let request_with_signer = self
            .requests
            .remove(&request_id)
            .unwrap_or_else(|| env::panic_str("Failed to remove existing element"));
        // decrement num_requests for original request signer
        let original_member = request_with_signer.member;
        let mut num_requests = self
            .num_requests_pk
            .get(&original_member.to_string())
            .unwrap_or(0);
        // safety check for underrun (unlikely since original_signer_pk must have num_requests_pk > 0)
        if num_requests > 0 {
            num_requests = num_requests - 1;
        }
        self.num_requests_pk
            .insert(&original_member.to_string(), &num_requests);
        // return request
        request_with_signer.request
    }

    /// Prevents access to calling requests and make sure request_id is valid - used in delete and confirm
    fn assert_valid_request(&mut self, request_id: RequestId) {
        // request must come from key added to contract account
        assert(
            self.current_member().is_some(),
            "Caller (predecessor or signer) is not a member of this multisig",
        );
        // request must exist
        assert(
            self.requests.get(&request_id).is_some(),
            "No such request: either wrong number or already confirmed",
        );
        // request must have
        assert(
            self.confirmations.get(&request_id).is_some(),
            "Internal error: confirmations mismatch requests",
        );
    }

    /// Prevents request from approving tx on another account
    fn assert_self_request(&mut self, receiver_id: AccountId) {
        assert(
            receiver_id == env::current_account_id(),
            "This method only works when receiver_id is equal to current_account_id",
        );
    }

    /// Prevents a request from being bundled with other actions
    fn assert_one_action_only(&mut self, receiver_id: AccountId, num_actions: usize) {
        self.assert_self_request(receiver_id);
        assert(num_actions == 1, "This method should be a separate request");
    }

    /********************************
    View methods
    ********************************/

    /// Returns members of the multisig.
    pub fn get_members(&self) -> Vec<MultisigMember> {
        self.members.to_vec()
    }

    pub fn get_request(&self, request_id: RequestId) -> MultiSigRequest {
        (self
            .requests
            .get(&request_id)
            .unwrap_or_else(|| env::panic_str("No such request")))
        .request
    }

    pub fn get_num_requests_per_member(&self, member: MultisigMember) -> u32 {
        self.num_requests_pk.get(&member.to_string()).unwrap_or(0)
    }

    pub fn list_request_ids(&self) -> Vec<RequestId> {
        self.requests.keys().collect()
    }

    pub fn get_confirmations(&self, request_id: RequestId) -> Vec<String> {
        self.confirmations
            .get(&request_id)
            .unwrap_or_else(|| env::panic_str("No such request"))
            .into_iter()
            .collect()
    }

    pub fn get_num_confirmations(&self) -> u32 {
        self.num_confirmations
    }

    pub fn get_request_nonce(&self) -> u32 {
        self.request_nonce
    }
}

#[cfg(test)]
mod tests {
    use std::convert::TryFrom;
    use std::fmt::{Debug, Error, Formatter};

    use near_sdk::test_utils::VMContextBuilder;
    use near_sdk::Balance;
    use near_sdk::{testing_env, PublicKey};
    use near_sdk::{AccountId, VMContext};

    use super::*;

    /// Used for asserts_eq.
    /// TODO: replace with derive when https://github.com/near/near-sdk-rs/issues/165
    impl Debug for MultiSigRequest {
        fn fmt(&self, _f: &mut Formatter<'_>) -> Result<(), Error> {
            panic!("Should not trigger");
        }
    }

    pub fn alice() -> AccountId {
        AccountId::new_unchecked("alice".to_string())
    }
    pub fn bob() -> AccountId {
        AccountId::new_unchecked("bob".to_string())
    }

    const TEST_KEY: [u8; 33] = [
        0, 247, 230, 176, 93, 224, 175, 33, 211, 72, 124, 12, 163, 219, 7, 137, 3, 37, 162, 199,
        181, 38, 90, 244, 111, 207, 37, 216, 79, 84, 50, 83, 164,
    ];

    fn members() -> Vec<MultisigMember> {
        vec![
            MultisigMember::Account {
                account_id: alice(),
            },
            MultisigMember::Account { account_id: bob() },
            MultisigMember::AccessKey {
                public_key: PublicKey::from(
                    "ed25519:Eg2jtsiMrprn7zgKKUk79qM1hWhANsFyE6JSX4txLEuy"
                        .parse()
                        .unwrap(),
                ),
            },
            MultisigMember::AccessKey {
                public_key: PublicKey::try_from(TEST_KEY.to_vec()).unwrap(),
            },
        ]
    }

    fn context_with_key(key: PublicKey, amount: Balance) -> VMContext {
        context_with_account_key(alice(), key, amount)
    }

    fn context_with_account(account_id: AccountId, amount: Balance) -> VMContext {
        context_with_account_key(
            account_id,
            PublicKey::try_from(vec![
                0, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,
                24, 25, 26, 27, 28, 29, 30, 31, 32, 33,
            ])
            .unwrap(),
            amount,
        )
    }

    fn context_with_account_key(
        account_id: AccountId,
        key: PublicKey,
        amount: Balance,
    ) -> VMContext {
        VMContextBuilder::new()
            .current_account_id(alice())
            .predecessor_account_id(account_id.clone())
            .signer_account_id(account_id.clone())
            .signer_account_pk(key)
            .account_balance(amount)
            .build()
    }

    fn context_with_key_future(key: PublicKey, amount: Balance) -> VMContext {
        VMContextBuilder::new()
            .current_account_id(alice())
            .block_timestamp(REQUEST_COOLDOWN + 1)
            .predecessor_account_id(alice())
            .signer_account_id(alice())
            .signer_account_pk(key)
            .account_balance(amount)
            .build()
    }

    #[test]
    fn test_multi_3_of_n() {
        let amount = 1_000;
        testing_env!(context_with_key(
            PublicKey::from(
                "Eg2jtsiMrprn7zgKKUk79qM1hWhANsFyE6JSX4txLEuy"
                    .parse()
                    .unwrap()
            ),
            amount
        ));
        let mut c = MultiSigContract::new(members(), 3);
        let request = MultiSigRequest {
            receiver_id: bob(),
            actions: vec![MultiSigRequestAction::Transfer {
                amount: amount.into(),
            }],
        };
        let request_id = c.add_request(request.clone());
        assert_eq!(c.get_request(request_id), request);
        assert_eq!(c.list_request_ids(), vec![request_id]);
        c.confirm(request_id);
        assert_eq!(c.requests.len(), 1);
        assert_eq!(c.confirmations.get(&request_id).unwrap().len(), 1);
        testing_env!(context_with_key(
            PublicKey::from(
                "HghiythFFPjVXwc9BLNi8uqFmfQc1DWFrJQ4nE6ANo7R"
                    .parse()
                    .unwrap()
            ),
            amount
        ));
        c.confirm(request_id);
        assert_eq!(c.confirmations.get(&request_id).unwrap().len(), 2);
        assert_eq!(c.get_confirmations(request_id).len(), 2);
        testing_env!(context_with_account(bob(), amount));
        c.confirm(request_id);
        // TODO: confirm that funds were transferred out via promise.
        assert_eq!(c.requests.len(), 0);
    }

    #[test]
    fn test_multi_add_request_and_confirm() {
        let amount = 1_000;
        testing_env!(context_with_key(
            PublicKey::from(
                "Eg2jtsiMrprn7zgKKUk79qM1hWhANsFyE6JSX4txLEuy"
                    .parse()
                    .unwrap()
            ),
            amount
        ));
        let mut c = MultiSigContract::new(members(), 3);
        let request = MultiSigRequest {
            receiver_id: bob(),
            actions: vec![MultiSigRequestAction::Transfer {
                amount: amount.into(),
            }],
        };
        let request_id = c.add_request_and_confirm(request.clone());
        assert_eq!(c.get_request(request_id), request);
        assert_eq!(c.list_request_ids(), vec![request_id]);
        // c.confirm(request_id);
        assert_eq!(c.requests.len(), 1);
        assert_eq!(c.confirmations.get(&request_id).unwrap().len(), 1);
        testing_env!(context_with_key(
            PublicKey::from(
                "HghiythFFPjVXwc9BLNi8uqFmfQc1DWFrJQ4nE6ANo7R"
                    .parse()
                    .unwrap()
            ),
            amount
        ));
        c.confirm(request_id);
        assert_eq!(c.confirmations.get(&request_id).unwrap().len(), 2);
        assert_eq!(c.get_confirmations(request_id).len(), 2);
        testing_env!(context_with_account(bob(), amount));
        c.confirm(request_id);
        // TODO: confirm that funds were transferred out via promise.
        assert_eq!(c.requests.len(), 0);
    }

    #[test]
    fn add_key_delete_key_storage_cleared() {
        let amount = 1_000;
        testing_env!(context_with_key(
            PublicKey::from(
                "ed25519:Eg2jtsiMrprn7zgKKUk79qM1hWhANsFyE6JSX4txLEuy"
                    .parse()
                    .unwrap()
            ),
            amount
        ));
        let mut c = MultiSigContract::new(members(), 1);
        let new_key: PublicKey = PublicKey::from(
            "HghiythFFPjVXwc9BLNi8uqFmfQc1DWFrJQ4nE6ANo7R"
                .parse()
                .unwrap(),
        );
        // vm current_account_id is alice, receiver_id must be alice
        let request = MultiSigRequest {
            receiver_id: alice(),
            actions: vec![MultiSigRequestAction::AddKey {
                public_key: new_key.clone(),
                permission: None,
            }],
        };
        // make request
        c.add_request_and_confirm(request.clone());
        // should be empty now
        assert_eq!(c.requests.len(), 0);
        // switch accounts
        testing_env!(context_with_key(
            PublicKey::from(
                "HghiythFFPjVXwc9BLNi8uqFmfQc1DWFrJQ4nE6ANo7R"
                    .parse()
                    .unwrap()
            ),
            amount
        ));
        let request2 = MultiSigRequest {
            receiver_id: alice(),
            actions: vec![MultiSigRequestAction::Transfer {
                amount: amount.into(),
            }],
        };
        // make request but don't confirm
        c.add_request(request2.clone());
        // should have 1 request now
        let new_member = MultisigMember::AccessKey {
            public_key: new_key.clone(),
        };
        assert_eq!(c.requests.len(), 1);
        assert_eq!(c.get_num_requests_per_member(new_member.clone()), 1);
        // self delete key
        let request3 = MultiSigRequest {
            receiver_id: alice(),
            actions: vec![MultiSigRequestAction::DeleteMember {
                member: new_member.clone(),
            }],
        };
        // make request and confirm
        c.add_request_and_confirm(request3.clone());
        // should be empty now
        assert_eq!(c.requests.len(), 0);
        assert_eq!(c.get_num_requests_per_member(new_member), 0);
    }

    #[test]
    #[should_panic]
    fn test_panics_add_key_different_account() {
        let amount = 1_000;
        testing_env!(context_with_key(
            PublicKey::try_from(Vec::from("Eg2jtsiMrprn7zgKKUk79qM1hWhANsFyE6JSX4txLEuy")).unwrap(),
            amount
        ));
        let mut c = MultiSigContract::new(members(), 1);
        let new_key: PublicKey =
            PublicKey::try_from(Vec::from("HghiythFFPjVXwc9BLNi8uqFmfQc1DWFrJQ4nE6ANo7R"))
                .unwrap()
                .into();
        // vm current_account_id is alice, receiver_id must be alice
        let request = MultiSigRequest {
            receiver_id: bob(),
            actions: vec![MultiSigRequestAction::AddKey {
                public_key: new_key.clone(),
                permission: None,
            }],
        };
        // make request
        c.add_request_and_confirm(request);
    }

    #[test]
    fn test_change_num_confirmations() {
        let amount = 1_000;
        testing_env!(context_with_key(
            PublicKey::try_from(TEST_KEY.to_vec()).unwrap(),
            amount
        ));
        let mut c = MultiSigContract::new(members(), 1);
        let request_id = c.add_request(MultiSigRequest {
            receiver_id: alice(),
            actions: vec![MultiSigRequestAction::SetNumConfirmations {
                num_confirmations: 2,
            }],
        });
        c.confirm(request_id);
        assert_eq!(c.num_confirmations, 2);
    }

    #[test]
    #[should_panic]
    fn test_panics_on_second_confirm() {
        let amount = 1_000;
        testing_env!(context_with_key(
            PublicKey::try_from(TEST_KEY.to_vec()).unwrap(),
            amount
        ));
        let mut c = MultiSigContract::new(members(), 3);
        let request_id = c.add_request(MultiSigRequest {
            receiver_id: bob(),
            actions: vec![MultiSigRequestAction::Transfer {
                amount: amount.into(),
            }],
        });
        assert_eq!(c.requests.len(), 1);
        assert_eq!(c.confirmations.get(&request_id).unwrap().len(), 0);
        c.confirm(request_id);
        assert_eq!(c.confirmations.get(&request_id).unwrap().len(), 1);
        c.confirm(request_id);
    }

    #[test]
    #[should_panic]
    fn test_panics_delete_request() {
        let amount = 1_000;
        testing_env!(context_with_key(
            PublicKey::try_from(TEST_KEY.to_vec()).unwrap(),
            amount
        ));
        let mut c = MultiSigContract::new(members(), 3);
        let request_id = c.add_request(MultiSigRequest {
            receiver_id: bob(),
            actions: vec![MultiSigRequestAction::Transfer {
                amount: amount.into(),
            }],
        });
        c.delete_request(request_id);
    }

    #[test]
    fn test_delete_request_future() {
        let amount = 1_000;
        testing_env!(context_with_key(
            PublicKey::try_from(TEST_KEY.to_vec()).unwrap(),
            amount
        ));
        let mut c = MultiSigContract::new(members(), 3);
        let request_id = c.add_request(MultiSigRequest {
            receiver_id: bob(),
            actions: vec![MultiSigRequestAction::Transfer {
                amount: amount.into(),
            }],
        });
        c.confirm(request_id);
        testing_env!(context_with_key_future(
            PublicKey::try_from(TEST_KEY.to_vec()).unwrap(),
            amount
        ));
        c.delete_request(request_id);
        assert_eq!(c.requests.len(), 0);
        assert!(c.confirmations.get(&request_id).is_none());
    }

    #[test]
    #[should_panic]
    fn test_delete_request_panic_wrong_key() {
        let amount = 1_000;
        testing_env!(context_with_key(
            PublicKey::try_from(TEST_KEY.to_vec()).unwrap(),
            amount
        ));
        let mut c = MultiSigContract::new(members(), 3);
        let request_id = c.add_request(MultiSigRequest {
            receiver_id: bob(),
            actions: vec![MultiSigRequestAction::Transfer {
                amount: amount.into(),
            }],
        });
        testing_env!(context_with_key(
            PublicKey::try_from(TEST_KEY.to_vec()).unwrap(),
            amount
        ));
        c.delete_request(request_id);
    }

    #[test]
    #[should_panic]
    fn test_too_many_requests() {
        let amount = 1_000;
        testing_env!(context_with_key(
            PublicKey::try_from(TEST_KEY.to_vec()).unwrap(),
            amount
        ));
        let mut c = MultiSigContract::new(members(), 3);
        for _i in 0..16 {
            c.add_request(MultiSigRequest {
                receiver_id: bob(),
                actions: vec![MultiSigRequestAction::Transfer {
                    amount: amount.into(),
                }],
            });
        }
    }

    #[test]
    #[should_panic]
    fn test_too_many_confirmations() {
        testing_env!(context_with_key(
            PublicKey::try_from(TEST_KEY.to_vec()).unwrap(),
            1_000
        ));
        let _ = MultiSigContract::new(members(), 5);
    }
}

'''
'''--- multisig2/test.sh ---
#!/bin/bash

./build.sh
cargo +stable test -- --nocapture

'''
'''--- multisig2/tests/general.rs ---
use std::cell::RefCell;
use std::rc::Rc;
use near_sdk::serde_json::json;
use near_sdk_sim::{to_yocto, DEFAULT_GAS, UserAccount};
use near_sdk_sim::account::AccessKey;
use near_sdk_sim::near_crypto::{InMemorySigner, KeyType, Signer};
use near_sdk_sim::runtime::{GenesisConfig, RuntimeStandalone};
use near_sdk_sim::state_record::StateRecord;
use near_primitives_core::account::Account as PrimitiveAccount;
use multisig2::MultisigMember;

near_sdk_sim::lazy_static_include::lazy_static_include_bytes! {
    MULTISIG_WASM_BYTES => "res/multisig2.wasm",
}

fn accounts(num: usize) -> String {
    ["root", "multisig"][num].to_string()
}

#[test]
fn setup_and_remove_multisig() {
    let mut genesis = GenesisConfig::default();

    // Set up signers for root and multisig
    let root_signer = genesis.init_root_signer(&accounts(0));
    let multisig_signer = InMemorySigner::from_seed(&accounts(1), KeyType::ED25519, &accounts(1));

    // Push multisig account to state_records
    genesis.state_records.push(StateRecord::Account {
        account_id: accounts(1),
        account: PrimitiveAccount {
            amount: to_yocto("100"),
            locked: 0,
            code_hash: Default::default(),
            storage_usage: 0,
        },
    });
    genesis.state_records.push(StateRecord::AccessKey {
        account_id: accounts(1),
        public_key: multisig_signer.clone().public_key(),
        access_key: AccessKey::full_access(),
    });

    let runtime = RuntimeStandalone::new_with_store(genesis);
    let runtime_rc = &Rc::new(RefCell::new(runtime));

    // Set up proper UserAccount objects for root and multisig
    let root_account = UserAccount::new(runtime_rc, accounts(0), root_signer.clone());
    let multisig_account = UserAccount::new(runtime_rc, accounts(1), multisig_signer.clone());

    // Set up arguments that will be passed into the "new" function
    let new_args = json!(
        {
            "members": [
                { "public_key": multisig_signer.public_key() }
            ],
            "num_confirmations": 1}
        ).to_string();

    // Deploy multisig contract to the account
    let deploy_tx = multisig_account.create_transaction(accounts(1));
    deploy_tx.deploy_contract(
        MULTISIG_WASM_BYTES.to_vec(),
    ).submit().assert_success();

    // Call the "new" initialization method
    multisig_account.call(
        accounts(1),
        "new",
        new_args.as_bytes(),
        DEFAULT_GAS,
        0
    ).assert_success();

    // Ensure that the new member is added
    let members: Vec<MultisigMember> = root_account.view(accounts(1), "get_members", &[]).unwrap_json();
    assert_eq!(members.len(), 1);

    // Set up arguments for "add_request" and call it
    let add_request_args = json!({"request": {"receiver_id": accounts(1), "actions": [
        {"type": "AddKey", "public_key": root_signer.public_key()},
        {"type": "DeployContract", "code": ""},
    ]}}).to_string();
    multisig_account.call(
        accounts(1),
        "add_request",
        add_request_args.as_bytes(),
        DEFAULT_GAS,
        0
    ).assert_success();
    // assert!(1 == 2, "aloha ");

    // Call "confirm"
    multisig_account.call(
        accounts(1),
        "confirm",
        json!({"request_id": 0}).to_string().as_bytes(),
        DEFAULT_GAS,
        0
    ).assert_success();
}

'''
'''--- scripts/README.md ---
# Setup scripts

## Rebuild all contracts

```bash
./build_all_docker.sh
```

## Deploy core contracts using master account

### Set master account

```bash
export MASTER_ACCOUNT_ID=near
```

### Set network environment

```bash
export NEAR_ENV=testnet
```

### Deploy

This will deploy the following contracts:

- Voting contract at `vote.<MASTER_ACCOUNT_ID>` with `15` NEAR tokens
- Whitelist contract at `whitelist.<MASTER_ACCOUNT_ID>` with `15` NEAR tokens
- Staking pool factory contract at `pool.<MASTER_ACCOUNT_ID>` with `50` NEAR tokens

It will whitelist the staking pool factory account.

It requires total `80` NEAR tokens + gas fees.

```bash
./deploy_core.sh
```

## Deploying lockup contract

NOTE: This flow is mostly for testnet and is not recommended for production use.

### Set lockup root account

This account will be used as a suffix to deploy lockup contracts.
Also this account will fund the newly created lockup contracts.

```bash
export LOCKUP_MASTER_ACCOUNT_ID=lockup.near
```

### Deploying

To deploy a lockup call the script. It has interactive interface to provide details.

```bash
./deploy_lockup.sh
```

Once the amount (in NEAR) is provided, the lockup contract will be deployed.

## Notes

For rebuilding contracts, make sure you have `rust` with `wasm32` target installed.

For deploying, you need to have `near-shell` installed and be logged in with the master account ID.

'''
'''--- scripts/build_all.sh ---
#!/usr/bin/env bash
set -ex

CHECK=0

# Loop through arguments and process them
for arg in "$@"
do
    case $arg in
        -c|--check)
        CHECK=1
        shift 
        ;;
    esac
done

# Note: `staking-pool` has to be built before `staking-pool-factory`
jq -c '.[]' scripts/contracts.json | while read i; do
  CONTRACT_DIR=$(echo $i | jq -r '.contract_dir')
 (cd $CONTRACT_DIR && ./build.sh)
done

if [ $CHECK == 1 ] && [ ! -z "$(git diff --exit-code)" ] ; then
	echo "Repository is dirty, please make sure you have committed all contract wasm files"
	exit 1
fi

'''
'''--- scripts/build_all_docker.sh ---
#!/usr/bin/env bash
set -ex

CHECK=0

# Loop through arguments and process them
for arg in "$@"
do
    case $arg in
        -c|--check)
        CHECK=1
        shift 
        ;;
    esac
done

# Note: `staking-pool` has to be built before `staking-pool-factory`
jq -c '.[]' scripts/contracts.json | while read i; do
  CONTRACT_DIR=$(echo $i | jq -r '.contract_dir')
  CONTRACT_NAME=$(echo $i | jq -r '.contract_name')
	(./scripts/build_docker.sh $CONTRACT_DIR $CONTRACT_NAME)
done

if [ $CHECK == 1 ] && [ ! -z "$(git diff --exit-code)" ] ; then
	echo "Repository is dirty, please make sure you have committed all contract wasm files"
	exit 1
fi

'''
'''--- scripts/build_docker.sh ---
#!/usr/bin/env bash

# Exit script as soon as a command fails.
set -ex

NAME="$1"
CONTRACT_WASM_NAME="$2"

if docker ps -a --format '{{.Names}}' | grep -Eq "^build_${NAME}\$"; then
    echo "Container exists"
else
docker create \
     --mount type=bind,source=$(pwd),target=/host \
     --cap-add=SYS_PTRACE --security-opt seccomp=unconfined \
     --name=build_$NAME \
     -w /host/$NAME \
     -e RUSTFLAGS='-C link-arg=-s' \
     -it nearprotocol/contract-builder \
     /bin/bash
fi

docker start build_$NAME
docker exec build_$NAME /bin/bash -c "rustup toolchain install stable-2020-10-08; rustup default stable-2020-10-08; rustup target add wasm32-unknown-unknown; cargo build --target wasm32-unknown-unknown --release"

mkdir -p res
cp $NAME/target/wasm32-unknown-unknown/release/$CONTRACT_WASM_NAME.wasm $NAME/res/$CONTRACT_WASM_NAME.wasm

'''
'''--- scripts/contracts.json ---
[{
        "contract_dir": "lockup",
        "contract_name": "lockup_contract"
    },
    {
        "contract_dir": "lockup-factory",
        "contract_name": "lockup_factory"
    },
    {
        "contract_dir": "voting",
        "contract_name": "voting_contract"
    },
    {
        "contract_dir": "whitelist",
        "contract_name": "whitelist"
    },
    {
        "contract_dir": "w-near",
        "contract_name": "w_near"
    },
    {
        "contract_dir": "multisig2",
        "contract_name": "multisig2"
    },
    {
        "contract_dir": "multisig-factory",
        "contract_name": "multisig_factory"
    }
]

'''
'''--- scripts/deploy/deploy_staking_pool_factory.sh ---
#!/bin/bash
set -e

WHITELIST_ACCOUNT_ID="lockup-whitelist.${MASTER_ACCOUNT_ID}"
ACCOUNT_ID="poolv1.${MASTER_ACCOUNT_ID}"

echo "Deploying staking pool factory contract to $ACCOUNT_ID with 50 NEAR"

REPL=$(cat <<-END
await new Promise(resolve => setTimeout(resolve, 100));
const fs = require('fs');
const account = await near.account("$MASTER_ACCOUNT_ID");
const contractName = "$ACCOUNT_ID";
const newArgs = {staking_pool_whitelist_account_id: "$WHITELIST_ACCOUNT_ID"};
await account.signAndSendTransaction(
    contractName,
    [
        nearAPI.transactions.createAccount(),
        nearAPI.transactions.transfer("50000000000000000000000000"),
        nearAPI.transactions.deployContract(fs.readFileSync("../../staking-pool-factory/res/staking_pool_factory.wasm")),
        nearAPI.transactions.functionCall("new", Buffer.from(JSON.stringify(newArgs)), 10000000000000, "0"),
    ]);
END
)

echo $REPL | near repl

echo "Whitelisting staking pool factory $ACCOUNT_ID on whitelist contract $WHITELIST_ACCOUNT_ID"

REPL=$(cat <<-END
await new Promise(resolve => setTimeout(resolve, 100));
const account = await near.account("$FOUNDATION_ACCOUNT_ID");
const contractName = "$WHITELIST_ACCOUNT_ID";
const args = {factory_account_id: "$ACCOUNT_ID"};
await account.signAndSendTransaction(
    contractName,
    [
        nearAPI.transactions.functionCall("add_factory", Buffer.from(JSON.stringify(args)), 10000000000000, "0"),
    ]);
END
)

echo $REPL | near repl

'''
'''--- scripts/deploy/deploy_voting.sh ---
#!/bin/bash
set -e

ACCOUNT_ID="transfer-vote.${MASTER_ACCOUNT_ID}"

echo "Deploying voting contract to $ACCOUNT_ID with 15 NEAR"

REPL=$(cat <<-END
await new Promise(resolve => setTimeout(resolve, 100));
const fs = require('fs');
const account = await near.account("$MASTER_ACCOUNT_ID");
const contractName = "$ACCOUNT_ID";
const newArgs = {};
await account.signAndSendTransaction(
    contractName,
    [
        nearAPI.transactions.createAccount(),
        nearAPI.transactions.transfer("15000000000000000000000000"),
        nearAPI.transactions.deployContract(fs.readFileSync("../../voting/res/voting_contract.wasm")),
        nearAPI.transactions.functionCall("new", Buffer.from(JSON.stringify(newArgs)), 10000000000000, "0"),
    ]);
END
)

echo $REPL | near repl

'''
'''--- scripts/deploy/deploy_whitelist.sh ---
#!/bin/bash
set -e

ACCOUNT_ID="lockup-whitelist.${MASTER_ACCOUNT_ID}"

echo "Deploying whitelist contract to $ACCOUNT_ID with 15 NEAR"

REPL=$(cat <<-END
await new Promise(resolve => setTimeout(resolve, 100));
const fs = require('fs');
const account = await near.account("$MASTER_ACCOUNT_ID");
const contractName = "$ACCOUNT_ID";
const newArgs = {foundation_account_id: "$FOUNDATION_ACCOUNT_ID"};
await account.signAndSendTransaction(
    contractName,
    [
        nearAPI.transactions.createAccount(),
        nearAPI.transactions.transfer("15000000000000000000000000"),
        nearAPI.transactions.deployContract(fs.readFileSync("../../whitelist/res/whitelist.wasm")),
        nearAPI.transactions.functionCall("new", Buffer.from(JSON.stringify(newArgs)), 10000000000000, "0"),
    ]);
END
)

echo $REPL | near repl

'''
'''--- scripts/deploy_core.sh ---
#!/bin/bash
set -e

if [ -z "${NEAR_ENV}" ]; then
  echo "NEAR_ENV is required, e.g. \`export NEAR_ENV=testnet\`"
  exit 1
fi

if [ -z "${MASTER_ACCOUNT_ID}" ]; then
  echo "MASTER_ACCOUNT_ID is required, e.g. \`export MASTER_ACCOUNT_ID=near\`"
  exit 1
fi

if [ -z "${FOUNDATION_ACCOUNT_ID}"]; then
  echo "FOUNDATION_ACCOUNT_ID is required, e.g. \`export FOUNDATION_ACCOUNT_ID=foundation.near\`"
fi

echo "Using NEAR_ENV=${NEAR_ENV}"
echo "Using MASTER_ACCOUNT_ID=${MASTER_ACCOUNT_ID}"
echo "Using FOUNDATION_ACCOUNT_ID=${FOUNDATION_ACCOUNT_ID}"

# Verifying master account exist
AMOUNT=$(near state $MASTER_ACCOUNT_ID | grep "amount")
if [ -z "$AMOUNT" ]; then
  echo "Can't get state for master account ${MASTER_ACCOUNT_ID}. Maybe the account doesn't exist."
  exit 1
fi

# Verifying foundation account exist
AMOUNT=$(near state $FOUNDATION_ACCOUNT_ID | grep "amount")
if [ -z "$AMOUNT" ]; then
  echo "Can't get state for foundation account ${FOUNDATION_ACCOUNT_ID}. Maybe the account doesn't exist."
  exit 1
fi

pushd deploy

./deploy_voting.sh
./deploy_whitelist.sh
./deploy_staking_pool_factory.sh

popd

'''
'''--- scripts/deploy_lockup.sh ---
#!/bin/bash
set -e

if [ -z "${NEAR_ENV}" ]; then
  echo "NEAR_ENV is required, e.g. \`export NEAR_ENV=testnet\`"
  exit 1
fi

if [ -z "${MASTER_ACCOUNT_ID}" ]; then
  echo "MASTER_ACCOUNT_ID is required, e.g. \`export MASTER_ACCOUNT_ID=near\`"
  exit 1
fi

if [ -z "${LOCKUP_MASTER_ACCOUNT_ID}" ]; then
  echo "LOCKUP_MASTER_ACCOUNT_ID is required, e.g. \`export LOCKUP_MASTER_ACCOUNT_ID=lockup\`"
  exit 1
fi

echo "Using NEAR_ENV=${NEAR_ENV}"
echo "Using MASTER_ACCOUNT_ID=${MASTER_ACCOUNT_ID}"
echo "Using LOCKUP_MASTER_ACCOUNT_ID=${LOCKUP_MASTER_ACCOUNT_ID}"

# Verifying master account exist
RES=$(near state $LOCKUP_MASTER_ACCOUNT_ID | grep "amount" && echo "OK" || echo "BAD")
if [ "$RES" = "BAD" ]; then
  echo "Can't get state for ${LOCKUP_MASTER_ACCOUNT_ID}. Maybe the account doesn't exist."
  exit 1
fi

read -p "Enter account ID (prefix) to create: " ACCOUNT_PREFIX

PREFIX_RE=$(grep -qE '^([a-z0-9]+[-_])*[a-z0-9]+$' <<< "$ACCOUNT_PREFIX" && echo "OK" || echo "BAD")

if [ "$PREFIX_RE" = "OK" ]; then
  ACCOUNT_ID="$ACCOUNT_PREFIX.${LOCKUP_MASTER_ACCOUNT_ID}"
else
  echo "Invalid new account prefix."
  exit 1
fi

LOCKUP_ACCOUNT_ID=$ACCOUNT_ID

echo "Lockup account ID is $LOCKUP_ACCOUNT_ID"

if [ ${#LOCKUP_ACCOUNT_ID} -gt "64" ]; then
  echo "The legnth of the lockup account is longer than 64 characters"
  exit 1
fi

# Verifying the new account doesn't exist
RES=$(near state $ACCOUNT_ID | grep "amount" && echo "BAD" || echo "OK")
if [ "$RES" = "BAD" ]; then
  echo "The account ${ACCOUNT_ID} already exist."
  exit 1
fi

while true; do
  read -p "Enter OWNER_ACCOUNT_ID: " OWNER_ACCOUNT_ID

  # Verifying master account exist
  RES=$(near state $OWNER_ACCOUNT_ID | grep "amount" && echo "OK" || echo "BAD")
  if [ "$RES" = "BAD" ]; then
    echo "Can't get state for ${OWNER_ACCOUNT_ID}. Maybe the account doesn't exist."
  else
    echo "Using owner's account ID $OWNER_ACCOUNT_ID"
    break;
  fi
done

MINIMUM_BALANCE="35"
while true; do
  read -p "Enter the amount in NEAR tokens (not yocto) to deposit on lockup contract (min $MINIMUM_BALANCE): " LOCKUP_BALANCE
  if [ "$LOCKUP_BALANCE" -ge "$MINIMUM_BALANCE" ]; then
    echo "Going to deposit $LOCKUP_BALANCE tokens or ${LOCKUP_BALANCE}000000000000000000000000 yocto NEAR"
    break;
  else
    echo "The lockup balance has to be at least $MINIMUM_BALANCE NEAR tokens. Try again."
  fi
done

VOTE_ACCOUNT_ID="vote.${MASTER_ACCOUNT_ID}"
WHITELIST_ACCOUNT_ID="whitelist.${MASTER_ACCOUNT_ID}"

REPL=$(cat <<-END
await new Promise(resolve => setTimeout(resolve, 100));
const fs = require('fs');
const account = await near.account("$LOCKUP_MASTER_ACCOUNT_ID");
const contractName = "$ACCOUNT_ID";
const newArgs = {
    "owner_account_id": "$OWNER_ACCOUNT_ID",
    "lockup_duration": "259200000000000",
    "transfers_information": {
        "TransfersDisabled": {
            "transfer_poll_account_id": "$VOTE_ACCOUNT_ID"
        }
    },
    "release_duration": "2592000000000000",
    "staking_pool_whitelist_account_id": "$WHITELIST_ACCOUNT_ID",
};
await account.signAndSendTransaction(
    contractName,
    [
        nearAPI.transactions.createAccount(),
        nearAPI.transactions.transfer("${LOCKUP_BALANCE}000000000000000000000000"),
        nearAPI.transactions.deployContract(fs.readFileSync("../lockup/res/lockup_contract.wasm")),
        nearAPI.transactions.functionCall("new", Buffer.from(JSON.stringify(newArgs)), 10000000000000, "0"),
    ]);
END
)

#
#REPL=$(cat <<-END
#await new Promise(resolve => setTimeout(resolve, 100));
#const fs = require('fs');
#const account = await near.account("$LOCKUP_MASTER_ACCOUNT_ID");
#const contractName = "$ACCOUNT_ID";
#const newArgs = {
#    "owner_account_id": "$OWNER_ACCOUNT_ID",
#    "lockup_duration": "259200000000000",
#    "transfers_information": {
#        "TransfersEnabled": {
#            "transfers_timestamp": "1597600995135000000"
#        }
#    },
#    "release_duration": "2592000000000000",
#    "staking_pool_whitelist_account_id": "$WHITELIST_ACCOUNT_ID",
#};
#await account.signAndSendTransaction(
#    contractName,
#    [
#        nearAPI.transactions.createAccount(),
#        nearAPI.transactions.transfer("${LOCKUP_BALANCE}000000000000000000000000"),
#        nearAPI.transactions.deployContract(fs.readFileSync("../lockup/res/lockup_contract.wasm")),
#        nearAPI.transactions.functionCall("new", Buffer.from(JSON.stringify(newArgs)), 10000000000000, "0"),
#    ]);
#END
#)

echo $REPL | near repl

'''
'''--- scripts/deploy_old_lockup.sh ---
#!/bin/bash
set -e

if [ -z "${NEAR_ENV}" ]; then
  echo "NEAR_ENV is required, e.g. \`export NEAR_ENV=testnet\`"
  exit 1
fi

if [ -z "${MASTER_ACCOUNT_ID}" ]; then
  echo "MASTER_ACCOUNT_ID is required, e.g. \`export MASTER_ACCOUNT_ID=near\`"
  exit 1
fi

echo "Using NEAR_ENV=${NEAR_ENV}"
echo "Using MASTER_ACCOUNT_ID=${MASTER_ACCOUNT_ID}"

# Verifying master account exist
RES=$(near state $MASTER_ACCOUNT_ID | grep "amount" && echo "OK" || echo "BAD")
if [ "$RES" = "BAD" ]; then
  echo "Can't get state for ${MASTER_ACCOUNT_ID}. Maybe the account doesn't exist."
  exit 1
fi

read -p "Enter account ID (prefix) to create: " ACCOUNT_PREFIX

PREFIX_RE=$(grep -qE '^([a-z0-9]+[-_])*[a-z0-9]+$' <<< "$ACCOUNT_PREFIX" && echo "OK" || echo "BAD")

if [ "$PREFIX_RE" = "OK" ]; then
  ACCOUNT_ID="$ACCOUNT_PREFIX.${MASTER_ACCOUNT_ID}"
else
  echo "Invalid new account prefix."
  exit 1
fi

LOCKUP_ACCOUNT_ID="lockup.$ACCOUNT_ID"

echo "Multi-sig account ID is $ACCOUNT_ID"
echo "Lockup account ID is $LOCKUP_ACCOUNT_ID"

if [ ${#LOCKUP_ACCOUNT_ID} -gt "64" ]; then
  echo "The legnth of the lockup account is longer than 64 characters"
  exit 1
fi

# Verifying the new account doesn't exist
RES=$(near state $ACCOUNT_ID | grep "amount" && echo "BAD" || echo "OK")
if [ "$RES" = "BAD" ]; then
  echo "The account ${ACCOUNT_ID} already exist."
  exit 1
fi

PUBLIC_KEYS=()

for i in {1..3}; do
  while true; do
    read -p "New account multisig public key in base58 format ($i/3): " KEY
    REPL=$(echo "nearAPI.utils.key_pair.PublicKey.fromString('$KEY').data.length == 32")
    RES=$(echo "$REPL" | near repl | grep -q "true" && echo "OK" || echo "BAD")
    if [ "$RES" = "OK" ]; then
      break;
    else
      echo "Invalid public key. Try again."
    fi
  done
  PUBLIC_KEYS+=( $KEY )
done

MINIMUM_BALANCE="35"
while true; do
  read -p "Enter the amount in NEAR tokens to deposit on lockup contract (min $MINIMUM_BALANCE): " LOCKUP_BALANCE
  if [ "$LOCKUP_BALANCE" -ge "$MINIMUM_BALANCE" ]; then
    break;
  else
    echo "The minimum balance has to be $MINIMUM_BALANCE. Try again."
  fi
done

#
#if
#
#echo "Deploying staking pool factory contract to $ACCOUNT_ID with 50 NEAR"
#
#
#REPL=$(cat <<-END
#const fs = require('fs');
#const account = await near.account("$MASTER_ACCOUNT_ID");
#const contractName = "$ACCOUNT_ID";
#const newArgs = {staking_pool_whitelist_account_id: "$WHITELIST_ACCOUNT_ID"};
#await account.signAndSendTransaction(
#    contractName,
#    [
#        nearAPI.transactions.createAccount(),
#        nearAPI.transactions.transfer("50000000000000000000000000"),
#        nearAPI.transactions.deployContract(fs.readFileSync("../../staking-pool-factory/res/staking_pool_factory.wasm")),
#        nearAPI.transactions.functionCall("new", Buffer.from(JSON.stringify(newArgs)), 10000000000000, "0"),
#    ]);
#END
#)
#
#echo $REPL | near repl
#
#echo "Whetelisting staking pool factory $ACCOUNT_ID on whitelist contract $WHITELIST_ACCOUNT_ID"
#
#REPL=$(cat <<-END
#const account = await near.account("$MASTER_ACCOUNT_ID");
#const contractName = "$WHITELIST_ACCOUNT_ID";
#const args = {factory_account_id: "$ACCOUNT_ID"};
#await account.signAndSendTransaction(
#    contractName,
#    [
#        nearAPI.transactions.functionCall("add_factory", Buffer.from(JSON.stringify(args)), 10000000000000, "0"),
#    ]);
#END
#)
#
#echo $REPL | near repl

'''
'''--- scripts/test_all.sh ---
#!/usr/bin/env bash
set -ex -o pipefail

# Note: `staking-pool` has to be built before `staking-pool-factory`
jq -c '.[]' scripts/contracts.json | while read i; do
  CONTRACT_DIR=$(echo $i | jq -r '.contract_dir')
  (cd $CONTRACT_DIR && RUSTFLAGS='-D warnings' cargo test)
done

'''
'''--- scripts/tests/test_voting.sh ---
#!/bin/bash
set -e

# nearup localnet --num-nodes 5 --docker-image "nearprotocol/nearcore:master" --overwrite
nearup localnet --num-nodes 5 --binary-path /Users/ekwork/code/nearcore/target/debug/ --overwrite

export MASTER_ACCOUNT_ID=node0
export NEAR_ENV=local

stop_nodes() {
  echo "STOOOP THE NODES!"
  nearup stop
}

trap "stop_nodes" ERR

LAST_NODE=4
NODES_TO_VOTE=3

echo "Awaiting for network to start"
sleep 3

echo "Current validator should be the $LAST_NODE + 1 nodes"
near validators current

for (( i=0; i<=$LAST_NODE; i++ )); do
  cp ~/.near/localnet/node$i/node_key.json ~/.near-credentials/local/node$i.json
done;

OWNER_ACCOUNT_ID="owner.$MASTER_ACCOUNT_ID"
near create-account $OWNER_ACCOUNT_ID --masterAccount=$MASTER_ACCOUNT_ID --initialBalance=10000

echo "Deploying core accounts/"
(cd .. && ./deploy_core.sh)

for (( i=1; i<=$LAST_NODE; i++ )); do
  ACCOUNT_ID="node${i}"
  near stake $ACCOUNT_ID "ed25519:7PGseFbWxvYVgZ89K1uTJKYoKetWs7BJtbyXDzfbAcqX" 0
done;

NODE0_PUBLIC_KEY=$(grep -oE 'ed25519:[^"]+' ~/.near/localnet/node0/validator_key.json | head -1)
echo "Staking close to 1B NEAR by node0, to avoid it being kicked out too fast."
near stake node0 "$NODE0_PUBLIC_KEY" 999000000

echo "Sleeping 3+ minutes (for 3+ epochs)"
sleep 200

echo "The only current validator should be the node0"
near validators current

for (( i=1; i<=$LAST_NODE; i++ )); do
  ACCOUNT_ID="node${i}"
  near deploy --wasmFile="../../staking-pool/res/staking_pool.wasm" --accountId=$ACCOUNT_ID
  PUBLIC_KEY=$(grep -oE 'ed25519:[^"]+' ~/.near/localnet/node$i/validator_key.json | head -1)
  near call $ACCOUNT_ID new "{\"owner_id\": \"$OWNER_ACCOUNT_ID\", \"stake_public_key\": \"$PUBLIC_KEY\", \"reward_fee_fraction\": {\"numerator\": 10, \"denominator\": 100}}" --accountId=$OWNER_ACCOUNT_ID
  sleep 1
done;

echo "Deployed pools and staked a lot. Sleep for 1 minute."
sleep 70

echo "Going to ping pools in case the stake was lost due to seat assignment"

for (( i=1; i<=$LAST_NODE; i++ )); do
  ACCOUNT_ID="node${i}"
  near call $ACCOUNT_ID ping "{}" --accountId=$OWNER_ACCOUNT_ID
  sleep 1
done;

echo "Unstaking for node0"
near stake node0 "$NODE0_PUBLIC_KEY" 0

echo "Sleeping 3+ minutes (for 3+ epochs)"
sleep 200

echo "Current validators should be the $LAST_NODE nodes with the staking pools only"
near validators current
near validators current | grep "Validators (total: $LAST_NODE,"

VOTE_ACCOUNT_ID="vote.$MASTER_ACCOUNT_ID"

check_votes() {
  echo "Checking votes"
  near view $VOTE_ACCOUNT_ID get_total_voted_stake
  near view $VOTE_ACCOUNT_ID get_votes
  echo "Checking result"
  near view $VOTE_ACCOUNT_ID get_result

}

vote() {
  ACCOUNT_ID="node${1}"
  echo "Voting through the pool to node $ACCOUNT_ID"
  near call $ACCOUNT_ID vote "{\"voting_account_id\": \"$VOTE_ACCOUNT_ID\", \"is_vote\": true}" --accountId=$OWNER_ACCOUNT_ID --gas=200000000000000

  check_votes
}

vote 1
vote 2

echo "Going to kick out node1. And restake with node0"
near call node1 pause_staking --accountId=$OWNER_ACCOUNT_ID
sleep 1
near stake node0 "$NODE0_PUBLIC_KEY" 999000000

echo "Sleeping 3+ minutes (for 3+ epochs)"
sleep 200

echo "Current validators should be the 3 nodes with the staking pools and node0"
near validators current
near validators current | grep "Validators (total: 4,"

check_votes

vote 3
vote 4

stop_nodes

'''
'''--- staking-pool-factory/Cargo.toml ---
[package]
name = "staking-pool-factory"
version = "0.1.5"
authors = ["Near Inc <hello@near.org>"]
edition = "2018"
publish = false

[lib]
crate-type = ["cdylib", "rlib"]

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "s"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[dependencies]
near-sdk = "2.0.0"

[dev-dependencies]
lazy_static = "1.4.0"
quickcheck = "0.9"
quickcheck_macros = "0.9"
log = "0.4"
env_logger = { version = "0.7.1", default-features = false }
near-crypto = { git = "https://github.com/nearprotocol/nearcore.git" }
near-primitives = { git = "https://github.com/nearprotocol/nearcore.git" }
near-runtime-standalone = { git = "https://github.com/nearprotocol/nearcore.git" }

'''
'''--- staking-pool-factory/README.md ---
# Staking Pool Factory Contract

This contract deploys and automatically whitelists new staking pool contracts.
It allows any user to create a new whitelisted staking pool.

The staking pool factory contract packages the binary of the staking pool contract within its own binary.
To create a new staking pool a user should issue a function call transaction and attach the required minimum deposit.
The entire deposit will be transferred to the newly created staking pool contract in order to cover the required storage.

When a user issues a function call towards the factory to create a new staking pool the factory internally checks that
the staking pool account ID does not exists, validates arguments for the staking pool initialization and then issues a
receipt that creates the staking pool. Once the receipt executes, the factory checks the status of the execution in the
callback. If the staking pool was created successfully, the factory then whitelists the newly created staking pool.
Otherwise, the factory returns the attached deposit back the users and returns `false`.

## Changelog

### `0.1.1`

- Rebuild with the staking pool contract version of `0.2.1`.

## API

```rust
/// Initializes the staking pool factory with the given account ID of the staking pool whitelist
/// contract.
#[init]
pub fn new(staking_pool_whitelist_account_id: AccountId) -> Self;

/// Returns the minimum amount of tokens required to attach to the function call to
/// create a new staking pool.
pub fn get_min_attached_balance(&self) -> U128;

/// Returns the total number of the staking pools created from this factory.
pub fn get_number_of_staking_pools_created(&self) -> u64;

/// Creates a new staking pool.
/// - `staking_pool_id` - the prefix of the account ID that will be used to create a new staking
///    pool account. It'll be prepended to the staking pool factory account ID separated by dot.
/// - `owner_id` - the account ID of the staking pool owner. This account will be able to
///    control the staking pool, set reward fee, update staking key and vote on behalf of the
///     pool.
/// - `stake_public_key` - the initial staking key for the staking pool.
/// - `reward_fee_fraction` - the initial reward fee fraction for the staking pool.
#[payable]
pub fn create_staking_pool(
    &mut self,
    staking_pool_id: String,
    owner_id: AccountId,
    stake_public_key: Base58PublicKey,
    reward_fee_fraction: RewardFeeFraction,
) -> Promise;

/// Callback after a staking pool was created.
/// Returns the promise to whitelist the staking pool contract if the pool creation succeeded.
/// Otherwise refunds the attached deposit and returns `false`.
pub fn on_staking_pool_create(
    &mut self,
    staking_pool_account_id: AccountId,
    attached_deposit: U128,
    predecessor_account_id: AccountId,
) -> PromiseOrValue<bool>;
```

'''
'''--- staking-pool-factory/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/staking_pool_factory.wasm ./res/

'''
'''--- staking-pool-factory/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::UnorderedSet;
use near_sdk::json_types::{Base58PublicKey, U128};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{env, ext_contract, near_bindgen, AccountId, Balance, Promise, PromiseOrValue};

mod utils;
use crate::utils::*;

/// The 30 NEAR tokens required for the storage of the staking pool.
const MIN_ATTACHED_BALANCE: Balance = 30_000_000_000_000_000_000_000_000;

pub mod gas {
    use near_sdk::Gas;

    /// The base amount of gas for a regular execution.
    const BASE: Gas = 25_000_000_000_000;

    /// The amount of Gas the contract will attach to the promise to create the staking pool.
    /// The base for the execution and the base for staking action to verify the staking key.
    pub const STAKING_POOL_NEW: Gas = BASE * 2;

    /// The amount of Gas the contract will attach to the callback to itself.
    /// The base for the execution and the base for whitelist call or cash rollback.
    pub const CALLBACK: Gas = BASE * 2;

    /// The amount of Gas the contract will attach to the promise to the whitelist contract.
    /// The base for the execution.
    pub const WHITELIST_STAKING_POOL: Gas = BASE;
}

/// There is no deposit balance attached.
const NO_DEPOSIT: Balance = 0;

#[global_allocator]
static ALLOC: near_sdk::wee_alloc::WeeAlloc = near_sdk::wee_alloc::WeeAlloc::INIT;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct StakingPoolFactory {
    /// Account ID of the staking pool whitelist contract.
    staking_pool_whitelist_account_id: AccountId,

    /// The account ID of the staking pools created.
    staking_pool_account_ids: UnorderedSet<AccountId>,
}

impl Default for StakingPoolFactory {
    fn default() -> Self {
        env::panic(b"The contract should be initialized before usage")
    }
}

/// Rewards fee fraction structure for the staking pool contract.
#[derive(Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct RewardFeeFraction {
    pub numerator: u32,
    pub denominator: u32,
}

impl RewardFeeFraction {
    pub fn assert_valid(&self) {
        assert_ne!(self.denominator, 0, "Denominator must be a positive number");
        assert!(
            self.numerator <= self.denominator,
            "The reward fee must be less or equal to 1"
        );
    }
}

#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct StakingPoolArgs {
    /// Owner account ID of the staking pool.
    owner_id: AccountId,
    /// The initial staking key.
    stake_public_key: Base58PublicKey,
    /// The initial reward fee fraction.
    reward_fee_fraction: RewardFeeFraction,
}

/// External interface for the callbacks to self.
#[ext_contract(ext_self)]
pub trait ExtSelf {
    fn on_staking_pool_create(
        &mut self,
        staking_pool_account_id: AccountId,
        attached_deposit: U128,
        predecessor_account_id: AccountId,
    ) -> Promise;
}

/// External interface for the whitelist contract.
#[ext_contract(ext_whitelist)]
pub trait ExtWhitelist {
    fn add_staking_pool(&mut self, staking_pool_account_id: AccountId) -> bool;
}

#[near_bindgen]
impl StakingPoolFactory {
    /// Initializes the staking pool factory with the given account ID of the staking pool whitelist
    /// contract.
    #[init]
    pub fn new(staking_pool_whitelist_account_id: AccountId) -> Self {
        assert!(!env::state_exists(), "The contract is already initialized");
        assert!(
            env::is_valid_account_id(staking_pool_whitelist_account_id.as_bytes()),
            "The staking pool whitelist account ID is invalid"
        );
        Self {
            staking_pool_whitelist_account_id,
            staking_pool_account_ids: UnorderedSet::new(b"s".to_vec()),
        }
    }

    /// Returns the minimum amount of tokens required to attach to the function call to
    /// create a new staking pool.
    pub fn get_min_attached_balance(&self) -> U128 {
        MIN_ATTACHED_BALANCE.into()
    }

    /// Returns the total number of the staking pools created from this factory.
    pub fn get_number_of_staking_pools_created(&self) -> u64 {
        self.staking_pool_account_ids.len()
    }

    /// Creates a new staking pool.
    /// - `staking_pool_id` - the prefix of the account ID that will be used to create a new staking
    ///    pool account. It'll be prepended to the staking pool factory account ID separated by dot.
    /// - `owner_id` - the account ID of the staking pool owner. This account will be able to
    ///    control the staking pool, set reward fee, update staking key and vote on behalf of the
    ///     pool.
    /// - `stake_public_key` - the initial staking key for the staking pool.
    /// - `reward_fee_fraction` - the initial reward fee fraction for the staking pool.
    #[payable]
    pub fn create_staking_pool(
        &mut self,
        staking_pool_id: String,
        owner_id: AccountId,
        stake_public_key: Base58PublicKey,
        reward_fee_fraction: RewardFeeFraction,
    ) -> Promise {
        assert!(
            env::attached_deposit() >= MIN_ATTACHED_BALANCE,
            "Not enough attached deposit to complete staking pool creation"
        );

        assert!(
            staking_pool_id.find('.').is_none(),
            "The staking pool ID can't contain `.`"
        );

        let staking_pool_account_id = format!("{}.{}", staking_pool_id, env::current_account_id());
        assert!(
            env::is_valid_account_id(staking_pool_account_id.as_bytes()),
            "The staking pool account ID is invalid"
        );

        assert!(
            env::is_valid_account_id(owner_id.as_bytes()),
            "The owner account ID is invalid"
        );
        reward_fee_fraction.assert_valid();

        assert!(
            self.staking_pool_account_ids
                .insert(&staking_pool_account_id),
            "The staking pool account ID already exists"
        );

        Promise::new(staking_pool_account_id.clone())
            .create_account()
            .transfer(env::attached_deposit())
            .deploy_contract(include_bytes!("../../staking-pool/res/staking_pool.wasm").to_vec())
            .function_call(
                b"new".to_vec(),
                near_sdk::serde_json::to_vec(&StakingPoolArgs {
                    owner_id,
                    stake_public_key,
                    reward_fee_fraction,
                })
                .unwrap(),
                NO_DEPOSIT,
                gas::STAKING_POOL_NEW,
            )
            .then(ext_self::on_staking_pool_create(
                staking_pool_account_id,
                env::attached_deposit().into(),
                env::predecessor_account_id(),
                &env::current_account_id(),
                NO_DEPOSIT,
                gas::CALLBACK,
            ))
    }

    /// Callback after a staking pool was created.
    /// Returns the promise to whitelist the staking pool contract if the pool creation succeeded.
    /// Otherwise refunds the attached deposit and returns `false`.
    pub fn on_staking_pool_create(
        &mut self,
        staking_pool_account_id: AccountId,
        attached_deposit: U128,
        predecessor_account_id: AccountId,
    ) -> PromiseOrValue<bool> {
        assert_self();

        let staking_pool_created = is_promise_success();

        if staking_pool_created {
            env::log(
                format!(
                    "The staking pool @{} was successfully created. Whitelisting...",
                    staking_pool_account_id
                )
                .as_bytes(),
            );
            ext_whitelist::add_staking_pool(
                staking_pool_account_id,
                &self.staking_pool_whitelist_account_id,
                NO_DEPOSIT,
                gas::WHITELIST_STAKING_POOL,
            )
            .into()
        } else {
            self.staking_pool_account_ids
                .remove(&staking_pool_account_id);
            env::log(
                format!(
                    "The staking pool @{} creation has failed. Returning attached deposit of {} to @{}",
                    staking_pool_account_id,
                    attached_deposit.0,
                    predecessor_account_id
                ).as_bytes()
            );
            Promise::new(predecessor_account_id).transfer(attached_deposit.0);
            PromiseOrValue::Value(false)
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use near_sdk::{testing_env, MockedBlockchain, PromiseResult};

    mod test_utils;
    use std::convert::TryInto;
    use test_utils::*;

    #[test]
    fn test_create_staking_pool_success() {
        let mut context = VMContextBuilder::new()
            .current_account_id(account_factory())
            .predecessor_account_id(account_near())
            .finish();
        testing_env!(context.clone());

        let mut contract = StakingPoolFactory::new(account_whitelist());

        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(contract.get_min_attached_balance().0, MIN_ATTACHED_BALANCE);
        assert_eq!(contract.get_number_of_staking_pools_created(), 0);

        context.is_view = false;
        context.predecessor_account_id = account_tokens_owner();
        context.attached_deposit = ntoy(31);
        testing_env!(context.clone());
        contract.create_staking_pool(
            staking_pool_id(),
            account_pool_owner(),
            "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7"
                .try_into()
                .unwrap(),
            RewardFeeFraction {
                numerator: 10,
                denominator: 100,
            },
        );

        context.predecessor_account_id = account_factory();
        context.attached_deposit = ntoy(0);
        testing_env_with_promise_results(context.clone(), PromiseResult::Successful(vec![]));
        contract.on_staking_pool_create(account_pool(), ntoy(31).into(), account_tokens_owner());

        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(contract.get_number_of_staking_pools_created(), 1);
    }

    #[test]
    #[should_panic(expected = "Not enough attached deposit to complete staking pool creation")]
    fn test_create_staking_pool_not_enough_deposit() {
        let mut context = VMContextBuilder::new()
            .current_account_id(account_factory())
            .predecessor_account_id(account_near())
            .finish();
        testing_env!(context.clone());

        let mut contract = StakingPoolFactory::new(account_whitelist());

        // Checking the pool is still whitelisted
        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(contract.get_min_attached_balance().0, MIN_ATTACHED_BALANCE);
        assert_eq!(contract.get_number_of_staking_pools_created(), 0);

        context.is_view = false;
        context.predecessor_account_id = account_tokens_owner();
        context.attached_deposit = ntoy(20);
        testing_env!(context.clone());
        contract.create_staking_pool(
            staking_pool_id(),
            account_pool_owner(),
            "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7"
                .try_into()
                .unwrap(),
            RewardFeeFraction {
                numerator: 10,
                denominator: 100,
            },
        );
    }

    #[test]
    fn test_create_staking_pool_rollback() {
        let mut context = VMContextBuilder::new()
            .current_account_id(account_factory())
            .predecessor_account_id(account_near())
            .finish();
        testing_env!(context.clone());

        let mut contract = StakingPoolFactory::new(account_whitelist());

        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(contract.get_min_attached_balance().0, MIN_ATTACHED_BALANCE);
        assert_eq!(contract.get_number_of_staking_pools_created(), 0);

        context.is_view = false;
        context.predecessor_account_id = account_tokens_owner();
        context.attached_deposit = ntoy(31);
        testing_env!(context.clone());
        contract.create_staking_pool(
            staking_pool_id(),
            account_pool_owner(),
            "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7"
                .try_into()
                .unwrap(),
            RewardFeeFraction {
                numerator: 10,
                denominator: 100,
            },
        );

        context.predecessor_account_id = account_factory();
        context.attached_deposit = ntoy(0);
        context.account_balance += ntoy(31);
        testing_env_with_promise_results(context.clone(), PromiseResult::Failed);
        let res = contract.on_staking_pool_create(
            account_pool(),
            ntoy(31).into(),
            account_tokens_owner(),
        );
        match res {
            PromiseOrValue::Promise(_) => panic!("Unexpected result, should return Value(false)"),
            PromiseOrValue::Value(value) => assert!(!value),
        };

        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(contract.get_number_of_staking_pools_created(), 0);
    }
}

'''
'''--- staking-pool-factory/src/tests/test_utils.rs ---
use near_sdk::{AccountId, MockedBlockchain, PromiseResult, VMContext};
use near_sdk::{Balance, BlockHeight, EpochHeight};

pub fn account_near() -> AccountId {
    "near".to_string()
}
pub fn account_whitelist() -> AccountId {
    "whitelist".to_string()
}
pub fn staking_pool_id() -> AccountId {
    "pool".to_string()
}
pub fn account_pool() -> AccountId {
    "pool.factory".to_string()
}
pub fn account_factory() -> AccountId {
    "factory".to_string()
}
pub fn account_tokens_owner() -> AccountId {
    "tokens-owner".to_string()
}
pub fn account_pool_owner() -> AccountId {
    "pool-owner".to_string()
}

pub fn ntoy(near_amount: Balance) -> Balance {
    near_amount * 10u128.pow(24)
}

pub fn testing_env_with_promise_results(context: VMContext, promise_result: PromiseResult) {
    let storage = near_sdk::env::take_blockchain_interface()
        .unwrap()
        .as_mut_mocked_blockchain()
        .unwrap()
        .take_storage();

    near_sdk::env::set_blockchain_interface(Box::new(MockedBlockchain::new(
        context,
        Default::default(),
        Default::default(),
        vec![promise_result],
        storage,
        Default::default(),
    )));
}

pub struct VMContextBuilder {
    context: VMContext,
}

impl VMContextBuilder {
    pub fn new() -> Self {
        Self {
            context: VMContext {
                current_account_id: "".to_string(),
                signer_account_id: "".to_string(),
                signer_account_pk: vec![0, 1, 2],
                predecessor_account_id: "".to_string(),
                input: vec![],
                epoch_height: 0,
                block_index: 0,
                block_timestamp: 0,
                account_balance: 0,
                account_locked_balance: 0,
                storage_usage: 10u64.pow(6),
                attached_deposit: 0,
                prepaid_gas: 10u64.pow(18),
                random_seed: vec![0, 1, 2],
                is_view: false,
                output_data_receivers: vec![],
            },
        }
    }

    #[allow(dead_code)]
    pub fn current_account_id(mut self, account_id: AccountId) -> Self {
        self.context.current_account_id = account_id;
        self
    }

    #[allow(dead_code)]
    pub fn signer_account_id(mut self, account_id: AccountId) -> Self {
        self.context.signer_account_id = account_id;
        self
    }

    #[allow(dead_code)]
    pub fn predecessor_account_id(mut self, account_id: AccountId) -> Self {
        self.context.predecessor_account_id = account_id;
        self
    }

    #[allow(dead_code)]
    pub fn block_index(mut self, block_index: BlockHeight) -> Self {
        self.context.block_index = block_index;
        self
    }

    #[allow(dead_code)]
    pub fn epoch_height(mut self, epoch_height: EpochHeight) -> Self {
        self.context.epoch_height = epoch_height;
        self
    }

    #[allow(dead_code)]
    pub fn attached_deposit(mut self, amount: Balance) -> Self {
        self.context.attached_deposit = amount;
        self
    }

    #[allow(dead_code)]
    pub fn account_balance(mut self, amount: Balance) -> Self {
        self.context.account_balance = amount;
        self
    }

    #[allow(dead_code)]
    pub fn account_locked_balance(mut self, amount: Balance) -> Self {
        self.context.account_locked_balance = amount;
        self
    }

    pub fn finish(self) -> VMContext {
        self.context
    }
}

'''
'''--- staking-pool-factory/src/utils.rs ---
use near_sdk::{env, PromiseResult};

pub fn assert_self() {
    assert_eq!(env::predecessor_account_id(), env::current_account_id());
}

pub fn is_promise_success() -> bool {
    assert_eq!(
        env::promise_results_count(),
        1,
        "Contract expected a result on the callback"
    );
    match env::promise_result(0) {
        PromiseResult::Successful(_) => true,
        _ => false,
    }
}

'''
'''--- staking-pool-factory/test.sh ---
#!/bin/bash

./build.sh
cargo test
'''
'''--- staking-pool-factory/tests/spec.rs ---
mod utils;

use crate::utils::{call_view, new_root, ntoy, view_factory, ExternalUser, FACTORY_ACCOUNT_ID};
use near_primitives::transaction::ExecutionStatus;
use near_runtime_standalone::RuntimeStandalone;
use near_sdk::borsh::BorshSerialize;
use near_sdk::json_types::{Base58PublicKey, U128};
use near_sdk::serde_json::{self, json};
use std::convert::TryInto;

const STAKING_POOL_WHITELIST_ACCOUNT_ID: &str = "staking-pool-whitelist";
const STAKING_POOL_ID: &str = "pool";
const STAKING_POOL_ACCOUNT_ID: &str = "pool.factory";
const OWNER_STAKING_ACCOUNT_ID: &str = "owner-staking";

#[test]
fn create_staking_pool_success() {
    let (mut r, foundation, owner) = setup_factory();

    let res: U128 = view_factory(&r, "get_min_attached_balance", "");
    assert_eq!(res.0, ntoy(30));

    let res: u64 = view_factory(&r, "get_number_of_staking_pools_created", "");
    assert_eq!(res, 0);

    let owner_staking_account = foundation
        .create_external(&mut r, OWNER_STAKING_ACCOUNT_ID.to_string(), ntoy(30))
        .unwrap();
    let staking_key: Base58PublicKey = owner_staking_account
        .signer()
        .public_key
        .try_to_vec()
        .unwrap()
        .try_into()
        .unwrap();

    let owner_balance = owner.account(&r).amount;

    owner
        .function_call(
            &mut r,
            FACTORY_ACCOUNT_ID,
            "create_staking_pool",
            &serde_json::to_vec(&json!({
                "staking_pool_id": STAKING_POOL_ID.to_string(),
                "owner_id": OWNER_STAKING_ACCOUNT_ID.to_string(),
                "stake_public_key": staking_key.clone(),
                "reward_fee_fraction": {
                    "numerator": 10,
                    "denominator": 100,
                }
            }))
            .unwrap(),
            ntoy(31),
        )
        .unwrap();

    // The factory remembered the pool
    let res: u64 = view_factory(&r, "get_number_of_staking_pools_created", "");
    assert_eq!(res, 1);

    // The pool was whitelisted
    let is_whitelisted: bool = call_view(
        &r,
        &STAKING_POOL_WHITELIST_ACCOUNT_ID,
        "is_whitelisted",
        &serde_json::to_string(
            &json!({ "staking_pool_account_id": STAKING_POOL_ACCOUNT_ID.to_string() }),
        )
        .unwrap(),
    );
    assert!(is_whitelisted);

    // The owner was charged the amount
    let new_owner_balance = owner.account(&r).amount;
    assert_eq!(new_owner_balance, owner_balance - ntoy(31));

    // Pool account was created and attached deposit was transferred.
    let pool_account = r.view_account(&STAKING_POOL_ACCOUNT_ID.to_string());
    assert!(pool_account.is_some());
    let pool_account = pool_account.unwrap();
    assert_eq!(pool_account.amount + pool_account.locked, ntoy(31));

    // The staking key on the pool matches the one that was given.
    let actual_staking_key: Base58PublicKey =
        call_view(&r, &STAKING_POOL_ACCOUNT_ID, "get_staking_key", "");
    assert_eq!(actual_staking_key.0, staking_key.0);
}

#[test]
fn create_staking_pool_bad_staking_key() {
    let (mut r, foundation, owner) = setup_factory();

    let res: U128 = view_factory(&r, "get_min_attached_balance", "");
    assert_eq!(res.0, ntoy(30));

    let res: u64 = view_factory(&r, "get_number_of_staking_pools_created", "");
    assert_eq!(res, 0);

    let _owner_staking_account = foundation
        .create_external(&mut r, OWNER_STAKING_ACCOUNT_ID.to_string(), ntoy(30))
        .unwrap();
    let bad_staking_key: Base58PublicKey = vec![0; 33].try_into().unwrap();

    let owner_balance = owner.account(&r).amount;

    let res = owner
        .function_call(
            &mut r,
            FACTORY_ACCOUNT_ID,
            "create_staking_pool",
            &serde_json::to_vec(&json!({
                "staking_pool_id": STAKING_POOL_ID.to_string(),
                "owner_id": OWNER_STAKING_ACCOUNT_ID.to_string(),
                "stake_public_key": bad_staking_key.clone(),
                "reward_fee_fraction": {
                    "numerator": 10,
                    "denominator": 100,
                }
            }))
            .unwrap(),
            ntoy(31),
        )
        .unwrap();
    assert_eq!(res.status, ExecutionStatus::SuccessValue(b"false".to_vec()));

    // Check the factory didn't store the pool.
    let res: u64 = view_factory(&r, "get_number_of_staking_pools_created", "");
    assert_eq!(res, 0);

    // Check the pool was not whitelisted.
    let is_whitelisted: bool = call_view(
        &r,
        &STAKING_POOL_WHITELIST_ACCOUNT_ID,
        "is_whitelisted",
        &serde_json::to_string(
            &json!({ "staking_pool_account_id": STAKING_POOL_ACCOUNT_ID.to_string() }),
        )
        .unwrap(),
    );
    assert!(!is_whitelisted);

    // Check the amount was refunded
    let new_owner_balance = owner.account(&r).amount;
    assert_eq!(new_owner_balance, owner_balance);

    // Pool account was not created
    let pool_account = r.view_account(&STAKING_POOL_ACCOUNT_ID.to_string());
    assert_eq!(pool_account, None);
}

fn setup_factory() -> (RuntimeStandalone, ExternalUser, ExternalUser) {
    let (mut r, foundation) = new_root("foundation".into());

    let owner = foundation
        .create_external(&mut r, "owner".into(), ntoy(100))
        .unwrap();

    // Creating whitelist account
    foundation
        .init_whitelist(&mut r, STAKING_POOL_WHITELIST_ACCOUNT_ID.to_string())
        .unwrap();
    let is_pool_whitelisted: bool = call_view(
        &r,
        &STAKING_POOL_WHITELIST_ACCOUNT_ID,
        "is_whitelisted",
        &serde_json::to_string(
            &json!({ "staking_pool_account_id": STAKING_POOL_ACCOUNT_ID.to_string() }),
        )
        .unwrap(),
    );
    assert!(!is_pool_whitelisted);
    let is_factory_whitelisted: bool = call_view(
        &r,
        &STAKING_POOL_WHITELIST_ACCOUNT_ID,
        "is_factory_whitelisted",
        &serde_json::to_string(&json!({ "factory_account_id": FACTORY_ACCOUNT_ID.to_string() }))
            .unwrap(),
    );
    assert!(!is_factory_whitelisted);
    // Whitelisting staking pool
    foundation
        .function_call(
            &mut r,
            &STAKING_POOL_WHITELIST_ACCOUNT_ID,
            "add_factory",
            &serde_json::to_vec(&json!({"factory_account_id": FACTORY_ACCOUNT_ID.to_string()}))
                .unwrap(),
            0,
        )
        .unwrap();
    let is_pool_whitelisted: bool = call_view(
        &r,
        &STAKING_POOL_WHITELIST_ACCOUNT_ID,
        "is_whitelisted",
        &serde_json::to_string(
            &json!({ "staking_pool_account_id": STAKING_POOL_ACCOUNT_ID.to_string() }),
        )
        .unwrap(),
    );
    assert!(!is_pool_whitelisted);
    let is_factory_whitelisted: bool = call_view(
        &r,
        &STAKING_POOL_WHITELIST_ACCOUNT_ID,
        "is_factory_whitelisted",
        &serde_json::to_string(&json!({ "factory_account_id": FACTORY_ACCOUNT_ID.to_string() }))
            .unwrap(),
    );
    assert!(is_factory_whitelisted);
    // Creating staking pool
    foundation
        .init_factory(&mut r, &STAKING_POOL_WHITELIST_ACCOUNT_ID)
        .unwrap();
    (r, foundation, owner)
}

'''
'''--- staking-pool-factory/tests/utils.rs ---
#![allow(dead_code)]

use near_crypto::{InMemorySigner, KeyType, Signer};
use near_primitives::{
    account::{AccessKey, Account},
    errors::{RuntimeError, TxExecutionError},
    hash::CryptoHash,
    transaction::{ExecutionOutcome, ExecutionStatus, Transaction},
    types::{AccountId, Balance},
};
use near_runtime_standalone::{init_runtime_and_signer, RuntimeStandalone};
use near_sdk::serde::de::DeserializeOwned;
use near_sdk::serde_json::{self, json};

pub const FACTORY_ACCOUNT_ID: &str = "factory";
const MAX_GAS: u64 = 300000000000000;

pub fn ntoy(near_amount: Balance) -> Balance {
    near_amount * 10u128.pow(24)
}

lazy_static::lazy_static! {
    static ref FACTORY_WASM_BYTES: &'static [u8] = include_bytes!("../res/staking_pool_factory.wasm").as_ref();
    static ref WHITELIST_WASM_BYTES: &'static [u8] = include_bytes!("../../whitelist/res/whitelist.wasm").as_ref();
}

type TxResult = Result<ExecutionOutcome, ExecutionOutcome>;

fn outcome_into_result(outcome: ExecutionOutcome) -> TxResult {
    match outcome.status {
        ExecutionStatus::SuccessValue(_) => Ok(outcome),
        ExecutionStatus::Failure(_) => Err(outcome),
        ExecutionStatus::SuccessReceiptId(_) => panic!("Unresolved ExecutionOutcome run runitme.resolve(tx) to resolve the filnal outcome of tx"),
        ExecutionStatus::Unknown => unreachable!()
    }
}

pub struct ExternalUser {
    pub account_id: AccountId,
    pub signer: InMemorySigner,
}

impl ExternalUser {
    pub fn new(account_id: AccountId, signer: InMemorySigner) -> Self {
        Self { account_id, signer }
    }

    #[allow(dead_code)]
    pub fn account_id(&self) -> &AccountId {
        &self.account_id
    }

    #[allow(dead_code)]
    pub fn signer(&self) -> &InMemorySigner {
        &self.signer
    }

    pub fn account(&self, runtime: &RuntimeStandalone) -> Account {
        runtime
            .view_account(&self.account_id)
            .expect("Account should be there")
    }

    pub fn create_external(
        &self,
        runtime: &mut RuntimeStandalone,
        new_account_id: AccountId,
        amount: Balance,
    ) -> Result<ExternalUser, ExecutionOutcome> {
        let new_signer =
            InMemorySigner::from_seed(&new_account_id, KeyType::ED25519, &new_account_id);
        let tx = self
            .new_tx(runtime, new_account_id.clone())
            .create_account()
            .add_key(new_signer.public_key(), AccessKey::full_access())
            .transfer(amount)
            .sign(&self.signer);
        let res = runtime.resolve_tx(tx);

        // TODO: this temporary hack, must be rewritten
        if let Err(err) = res.clone() {
            if let RuntimeError::InvalidTxError(tx_err) = err {
                let mut out = ExecutionOutcome::default();
                out.status = ExecutionStatus::Failure(TxExecutionError::InvalidTxError(tx_err));
                return Err(out);
            } else {
                unreachable!();
            }
        } else {
            outcome_into_result(res.unwrap())?;
            runtime.process_all().unwrap();
            Ok(ExternalUser {
                account_id: new_account_id,
                signer: new_signer,
            })
        }
    }

    pub fn transfer(
        &self,
        runtime: &mut RuntimeStandalone,
        receiver_id: &str,
        amount: Balance,
    ) -> TxResult {
        let tx = self
            .new_tx(runtime, receiver_id.to_string())
            .transfer(amount)
            .sign(&self.signer);
        let res = runtime.resolve_tx(tx).unwrap();
        runtime.process_all().unwrap();
        outcome_into_result(res)
    }

    pub fn function_call(
        &self,
        runtime: &mut RuntimeStandalone,
        receiver_id: &str,
        method: &str,
        args: &[u8],
        deposit: u128,
    ) -> TxResult {
        let tx = self
            .new_tx(runtime, receiver_id.to_string())
            .function_call(method.into(), args.to_vec(), MAX_GAS, deposit)
            .sign(&self.signer);
        let res = runtime.resolve_tx(tx).unwrap();
        runtime.process_all().unwrap();
        outcome_into_result(res)
    }

    pub fn init_factory(
        &self,
        runtime: &mut RuntimeStandalone,
        staking_pool_whitelist_account_id: &str,
    ) -> TxResult {
        let tx = self
            .new_tx(runtime, FACTORY_ACCOUNT_ID.into())
            .create_account()
            .transfer(ntoy(60))
            .deploy_contract(FACTORY_WASM_BYTES.to_vec())
            .function_call(
                "new".into(),
                serde_json::to_vec(&json!({"staking_pool_whitelist_account_id": staking_pool_whitelist_account_id.to_string()})).unwrap(),
                MAX_GAS,
                0,
            )
            .sign(&self.signer);
        let res = runtime.resolve_tx(tx).unwrap();
        runtime.process_all().unwrap();
        outcome_into_result(res)
    }

    pub fn init_whitelist(
        &self,
        runtime: &mut RuntimeStandalone,
        staking_pool_whitelist_account_id: AccountId,
    ) -> TxResult {
        let tx = self
            .new_tx(runtime, staking_pool_whitelist_account_id)
            .create_account()
            .transfer(ntoy(30))
            .deploy_contract(WHITELIST_WASM_BYTES.to_vec())
            .function_call(
                "new".into(),
                serde_json::to_vec(&json!({"foundation_account_id": self.account_id()})).unwrap(),
                MAX_GAS,
                0,
            )
            .sign(&self.signer);
        let res = runtime.resolve_tx(tx).unwrap();
        runtime.process_all().unwrap();
        outcome_into_result(res)
    }

    fn new_tx(&self, runtime: &RuntimeStandalone, receiver_id: AccountId) -> Transaction {
        let nonce = runtime
            .view_access_key(&self.account_id, &self.signer.public_key())
            .unwrap()
            .nonce
            + 1;
        Transaction::new(
            self.account_id.clone(),
            self.signer.public_key(),
            receiver_id,
            nonce,
            CryptoHash::default(),
        )
    }
}

pub fn wait_epoch(runtime: &mut RuntimeStandalone) {
    let epoch_height = runtime.current_block().epoch_height;
    while epoch_height == runtime.current_block().epoch_height {
        runtime.produce_block().unwrap();
    }
}

pub fn view_factory<I: ToString, O: DeserializeOwned>(
    runtime: &RuntimeStandalone,
    method: &str,
    args: I,
) -> O {
    call_view(runtime, &FACTORY_ACCOUNT_ID, method, args)
}

pub fn call_view<I: ToString, O: DeserializeOwned>(
    runtime: &RuntimeStandalone,
    account_id: &str,
    method: &str,
    args: I,
) -> O {
    let args = args.to_string();
    let result = runtime
        .view_method_call(&account_id.to_string(), method, args.as_bytes())
        .unwrap()
        .0;
    let output: O = serde_json::from_reader(result.as_slice()).unwrap();
    output
}

pub fn new_root(account_id: AccountId) -> (RuntimeStandalone, ExternalUser) {
    let (runtime, signer) = init_runtime_and_signer(&account_id);
    (runtime, ExternalUser { account_id, signer })
}

'''
'''--- staking-pool/Cargo.toml ---
[package]
name = "staking-pool"
version = "0.4.1"
authors = ["Near Inc <hello@near.org>"]
edition = "2018"
publish = false

[lib]
crate-type = ["cdylib", "rlib"]

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "s"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[dependencies]
near-sdk = "2.0.0"
uint = { version = "0.8.3", default-features = false }

[dev-dependencies]
lazy_static = "1.4.0"
quickcheck = "0.9"
quickcheck_macros = "0.9"
log = "0.4"
env_logger = { version = "0.7.1", default-features = false }
near-crypto = { git = "https://github.com/nearprotocol/nearcore.git" }
near-primitives = { git = "https://github.com/nearprotocol/nearcore.git" }
near-runtime-standalone = { git = "https://github.com/nearprotocol/nearcore.git" }

'''
'''--- staking-pool/README.md ---
# Staking / Delegation contract

This contract provides a way for other users to delegate funds to a single validation node.

Implements the https://github.com/nearprotocol/NEPs/pull/27 standard.

There are three different roles:
- The staking pool contract account `my_validator`. A key-less account with the contract that pools funds.
- The owner of the staking contract `owner`. Owner runs the validator node on behalf of the staking pool account.
- Delegator accounts `user1`, `user2`, etc. Accounts that want to stake their funds with the pool.

The owner can setup such contract and validate on behalf of this contract in their node.
Any other user can send their tokens to the contract, which will be pooled together and increase the total stake.
These users accrue rewards (subtracted fees set by the owner).
Then they can unstake and withdraw their balance after some unlocking period.

## Staking pool implementation details

For secure operation of the staking pool, the contract should not have any access keys.
Otherwise the contract account may issue a transaction that can violate the contract guarantees.

After users deposit tokens to the contract, they can stake some or all of them to receive "stake" shares.
The price of a "stake" share can be defined as the total amount of staked tokens divided by the the total amount of "stake" shares.
The number of "stake" shares is always less than the number of the staked tokens, so the price of single "stake" share is not less than `1`.

### Initialization

A contract has to be initialized with the following parameters:
- `owner_id` - `string` the account ID of the contract owner. This account will be able to call owner-only methods. E.g. `owner`
- `stake_public_key` - `string` the initial public key that will be used for staking on behalf of the contract's account in base58 ED25519 curve. E.g. `KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7`
- `reward_fee_fraction` - `json serialized object` the initial value of the fraction of the reward that the owner charges delegators for running the node.
The fraction is defined by the numerator and denumerator with `u32` types. E.g. `{numerator: 10, denominator: 100}` defines `10%` reward fee.
The fraction can be at most `1`. The denumerator can't be `0`.

During the initialization the contract checks validity of the input and initializes the contract.
The contract shouldn't have locked balance during the initialization.

At the initialization the contract allocates one trillion yocto NEAR tokens towards "stake" share price guarantees.
This fund is later used to adjust the the amount of staked and unstaked tokens due to rounding error.
For each stake and unstake action, the contract may spend at most 1 yocto NEAR from this fund (implicitly).

The current total balance (except for the "stake" share price guarantee amount) is converted to shares and will be staked (after the next action).
This balance can never be unstaked or withdrawn from the contract.
It's used to maintain the minimum number of shares, as well as help pay for the potentially growing contract storage.

### Delegator accounts

The contract maintains account information per delegator associated with the hash of the delegator's account ID.

The information contains:
- Unstaked balance of the account.
- Number of "stake" shares.
- The minimum epoch height when the unstaked balance can be withdrawn. Initially zero.

A delegator can do the following actions:

#### Deposit

When a delegator account first deposits funds to the contract, the internal account is created and credited with the
attached amount of unstaked tokens.

#### Stake

When an account wants to stake a given amount, the contract calculates the number of "stake" shares (`num_shares`) and the actual rounded stake amount (`amount`).
The unstaked balance of the account is decreased by `amount`, the number of "stake" shares of the account is increased by `num_shares`.
The contract increases the total number of staked tokens and the total number of "stake" shares. Then the contract restakes.

#### Unstake

When an account wants to unstake a given amount, the contract calculates the number of "stake" shares needed (`num_shares`) and
the actual required rounded unstake amount (`amount`). It's calculated based on the current total price of "stake" shares.
The unstaked balance of the account is increased by `amount`, the number of "stake" shares of the account is decreased by `num_shares`.
The minimum epoch height when the account can withdraw is set to the current epoch height increased by `4`.
The contract decreases the total number of staked tokens and the total number of "stake" shares. Then the contract restakes.

#### Withdraw

When an account wants to withdraw, the contract checks the minimum epoch height of this account and checks the amount.
Then sends the transfer and decreases the unstaked balance of the account.

#### Ping

Calls the internal function to distribute rewards if the blockchain epoch switched. The contract will restake in this case.

### Reward distribution

Before every action the contract calls method `internal_ping`.
This method distributes rewards towards active delegators when the blockchain epoch switches.
The rewards might be given due to staking and also because the contract earns gas fee rebates for every function call.
Note, the if someone accidentally (or intentionally) transfers tokens to the contract (without function call), then
tokens from the transfer will be distributed to the active stake participants of the contract in the next epoch.
Note, in a rare scenario, where the owner withdraws tokens and while the call is being processed deletes their account, the
withdraw transfer will fail and the tokens will be returned to the staking pool. These tokens will also be distributed as
a reward in the next epoch.

The method first checks that the current epoch is different from the last epoch, and if it's not changed exits the method.

The reward are computed the following way. The contract keeps track of the last known total account balance.
This balance consist of the initial contract balance, and all delegator account balances (including the owner) and all accumulated rewards.
(Validation rewards are added automatically at the beginning of the epoch, while contract execution gas rebates are added after each transaction)

When the method is called the contract uses the current total account balance (without attached deposit) and the subtracts the last total account balance.
The difference is the total reward that has to be distributed.

The fraction of the reward is awarded to the contract owner. The fraction is configurable by the owner, but can't exceed 100%.
Note, that it might be unfair for the participants of the pool if the owner changes reward fee. But this owner will lose trust of the
participants and it will lose future revenue in the long term. This should be enough to prevent owner from abusing reward fee.
It could also be the case that they could change the reward fee to make their pool more attractive.

The remaining part of the reward is added to the total staked balance. This action increases the price of each "stake" share without
changing the amount of "stake" shares owned by different accounts. Which is effectively distributing the reward based on the number of shares.

The owner's reward is converted into "stake" shares at the new price and added to the owner's account.
It's done similarly to `stake` method but without debiting the unstaked balance of owner's account.

Once the rewards are distributed the contract remembers the new total balance.

## Owner-only methods

Contract owner can do the following:
- Change public staking key. This action restakes with the new key.
- Change reward fee fraction.
- Vote on behalf of the pool. This is needed for the NEAR chain governance, and can be discussed in the following NEP: https://github.com/nearprotocol/NEPs/pull/62
- Pause and resume staking. When paused, the pool account unstakes everything (stakes 0) and doesn't restake.
It doesn't affect the staking shares or reward distribution. Pausing is useful for node maintenance. Note, the contract is not paused by default.

## Staking pool contract guarantees and invariants

This staking pool implementation guarantees the required properties of the staking pool standard:

- The contract can't lose or lock tokens of users.
- If a user deposited X, the user should be able to withdraw at least X.
- If a user successfully staked X, the user can unstake at least X.
- The contract should not lock unstaked funds for longer than 4 epochs after unstake action.

It also has inner invariants:

- The staking pool contract is secure if it doesn't have any access keys.
- The price of a "stake" is always at least `1`.
- The price of a "stake" share never decreases.
- The reward fee is a fraction be from `0` to `1` inclusive.
- The owner can't withdraw funds from other delegators.
- The owner can't delete the staking pool account.

NOTE: Guarantees are based on the no-slashing condition. Once slashing is introduced, the contract will no longer
provide some guarantees. Read more about slashing in [Nightshade paper](https://near.ai/nightshade).

## Changelog

### `0.4.0`

- Internal refactoring. Moving internal methods to `internal.rs`
- Added 4 new delegator methods:
    - `deposit_and_stake` - to deposit and stake attached balance in one call.
    - `stake_all` - to stake all unstaked balance.
    - `unstake_all` - to unstake all staked balance.
    - `withdraw_all` - to withdraw all unstaked balance.

### `0.3.0`

- Inner implementation has changed from using the hash of the account ID to use unmodified account ID as a key.
- Added 3 new view methods:
    - `get_account` - Returns human readable representation of the account for the given account ID
    - `get_number_of_accounts` - returns the total number of accounts that have positive balance in this staking pool.
    - `get_accounts` - Returns up to the limit of accounts starting from the given offset

### `0.2.1`

- Update `vote` interface to match the voting contract interface.

### `0.2.0`

- Added new owners methods: `pause_staking` and `resume_staking`. Allows pool owner to unstake everything from the pool for node maintenance.
- Added a new view method `is_staking_paused` to check whether the pool has paused staking.

## Pre-requisites

To develop Rust contracts you would need to:
* Install [Rustup](https://rustup.rs/):
```bash
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
```
* Add wasm target to your toolchain:
```bash
rustup target add wasm32-unknown-unknown
```

## Building the contract

```bash
./build.sh
```

## Usage

Commands to deploy and initialize a staking contract:

```bash
near create_account my_validator --masterAccount=owner
near deploy --accountId=my_validator --wasmFile=res/staking_pool.wasm
# Initialize staking pool at account `my_validator` for the owner account ID `owner`, given staking pool and 10% reward fee.
near call my_validator new '{"owner_id": "owner", "stake_public_key": "CE3QAXyVLeScmY9YeEyR3Tw9yXfjBPzFLzroTranYtVb", "reward_fee_fraction": {"numerator": 10, "denominator": 100}}' --account_id owner
# TODO: Delete all access keys from the `my_validator` account
```

As a user, to delegate money:

```bash
near call my_validator deposit '{}' --accountId user1 --amount 100
near call my_validator stake '{"amount": "100000000000000000000000000"}' --accountId user1
```

To update current rewards:

```bash
near call my_validator ping '{}' --accountId user1
```

View methods:

```bash
# User1 total balance
near view my_validator get_account_total_balance '{"account_id": "user1"}'

# User1 staked balance
near view my_validator get_account_staked_balance '{"account_id": "user1"}'

# User1 unstaked balance
near view my_validator get_account_unstaked_balance '{"account_id": "user1"}'

# Whether user1 can withdraw now
near view my_validator is_account_unstaked_balance_available '{"account_id": "user1"}'

# Total staked balance of the entire pool
near view my_validator get_total_staked_balance '{}'

# Owner of the staking pool
near view my_validator get_owner_id '{}'

# Current reward fee
near view my_validator get_reward_fee_fraction '{}'

# Owners balance
near view my_validator get_account_total_balance '{"account_id": "owner"}'

# Staking key
near view my_validator get_staking_key '{}'
```

To un-delegate, first run `unstake`:

```bash
near call my_validator unstake '{"amount": "100000000000000000000000000"}' --accountId user1
```

And after 3 epochs, run `withdraw`:

```bash
near call my_validator withdraw '{"amount": "100000000000000000000000000"}' --accountId user1
```

## Interface

```rust
pub struct RewardFeeFraction {
    pub numerator: u32,
    pub denominator: u32,
}

/// Initializes the contract with the given owner_id, initial staking public key (with ED25519
/// curve) and initial reward fee fraction that owner charges for the validation work.
#[init]
pub fn new(
    owner_id: AccountId,
    stake_public_key: Base58PublicKey,
    reward_fee_fraction: RewardFeeFraction,
);

/// Distributes rewards and restakes if needed.
pub fn ping(&mut self);

/// Deposits the attached amount into the inner account of the predecessor.
#[payable]
pub fn deposit(&mut self);

 /// Deposits the attached amount into the inner account of the predecessor and stakes it.
#[payable]
pub fn deposit_and_stake(&mut self);

/// Withdraws the non staked balance for given account.
/// It's only allowed if the `unstake` action was not performed in the four most recent epochs.
pub fn withdraw(&mut self, amount: U128);

/// Withdraws the entire unstaked balance from the predecessor account.
/// It's only allowed if the `unstake` action was not performed in the four most recent epochs.
pub fn withdraw_all(&mut self);

/// Stakes the given amount from the inner account of the predecessor.
/// The inner account should have enough unstaked balance.
pub fn stake(&mut self, amount: U128);

/// Stakes all available unstaked balance from the inner account of the predecessor.
pub fn stake_all(&mut self);

/// Unstakes the given amount from the inner account of the predecessor.
/// The inner account should have enough staked balance.
/// The new total unstaked balance will be available for withdrawal in four epochs.
pub fn unstake(&mut self, amount: U128);

/// Unstakes all staked balance from the inner account of the predecessor.
/// The new total unstaked balance will be available for withdrawal in four epochs.
pub fn unstake_all(&mut self);

/****************/
/* View methods */
/****************/

/// Returns the unstaked balance of the given account.
pub fn get_account_unstaked_balance(&self, account_id: AccountId) -> U128;

/// Returns the staked balance of the given account.
/// NOTE: This is computed from the amount of "stake" shares the given account has and the
/// current amount of total staked balance and total stake shares on the account.
pub fn get_account_staked_balance(&self, account_id: AccountId) -> U128;

/// Returns the total balance of the given account (including staked and unstaked balances).
pub fn get_account_total_balance(&self, account_id: AccountId) -> U128;

/// Returns `true` if the given account can withdraw tokens in the current epoch.
pub fn is_account_unstaked_balance_available(&self, account_id: AccountId) -> bool;

/// Returns the total staking balance.
pub fn get_total_staked_balance(&self) -> U128;

/// Returns account ID of the staking pool owner.
pub fn get_owner_id(&self) -> AccountId;

/// Returns the current reward fee as a fraction.
pub fn get_reward_fee_fraction(&self) -> RewardFeeFraction;

/// Returns the staking public key
pub fn get_staking_key(&self) -> Base58PublicKey;

/// Returns true if the staking is paused
pub fn is_staking_paused(&self) -> bool;

/// Returns human readable representation of the account for the given account ID.
pub fn get_account(&self, account_id: AccountId) -> HumanReadableAccount;

/// Returns the number of accounts that have positive balance on this staking pool.
pub fn get_number_of_accounts(&self) -> u64;

/// Returns the list of accounts
pub fn get_accounts(&self, from_index: u64, limit: u64) -> Vec<HumanReadableAccount>;

/*******************/
/* Owner's methods */
/*******************/

/// Owner's method.
/// Updates current public key to the new given public key.
pub fn update_staking_key(&mut self, stake_public_key: Base58PublicKey);

/// Owner's method.
/// Updates current reward fee fraction to the new given fraction.
pub fn update_reward_fee_fraction(&mut self, reward_fee_fraction: RewardFeeFraction);

/// Owner's method.
/// Calls `vote(is_vote)` on the given voting contract account ID on behalf of the pool.
pub fn vote(&mut self, voting_account_id: AccountId, is_vote: bool) -> Promise;

/// Owner's method.
/// Pauses pool staking.
pub fn pause_staking(&mut self);

/// Owner's method.
/// Resumes pool staking.
pub fn resume_staking(&mut self);
```

## Migrating from an existing validator or contract
This provides instructions to migrate your staked validator or a validator contract to a new contract

#### Upgrade to the latest near-shell:
```bash
npm install -g near-shell
```
#### Set Environment and Login:

##### If not logged into the browser, recover your account with the seed phrase first
https://wallet.betanet.nearprotocol.com/create/

```bash
#Set the NEAR environment to the target network (betanet,testnet,mainnet)
export NEAR_ENV=betanet

near login
```

#### Unstake and Withdraw:
```bash
#If you staked to your validator unstake, there is no withdraw
near stake nearkat.betanet <staking public key> 0

#If you staked to a contract get the staked balance
near view my_validator get_account_staked_balance '{"account_id": "user1"}'

#Unsake by copying and pasting the staked balance
near call my_validator unstake '{"amount": "100000000000000000000000000"}' --accountId user1

#Wait 4 epochs (12 hours) to withdraw and check if balance is available to withdraw
near view my_validator is_account_unstaked_balance_available '{"account_id": "user1"}'

#If is_account_unstaked_balance_available returns "true" withdraw
near call my_validator withdraw '{"amount": "100000000000000000000000000"}' --accountId user1
```
#### Download new contract with Git:
```bash
mkdir staking-pool

cd staking-pool

git clone https://github.com/near/initial-contracts

cd initial-contracts

cd staking-pool
```
#### Build contract with Rust (This step is optional since the contract is compiled):
##### Install Rust:
```bash
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

#Add rust to current shell path
source $HOME/.cargo/env
```
##### Add wasm target to your toolchain:
```bash
rustup target add wasm32-unknown-unknown
```
##### Build:
```bash
./build.sh
```
#### Create a new account to deploy contract to
- Set my_validator to the name you want publicly displayed
- --masterAccount is your account you signed up to StakeWars2 with
```bash
near create_account my_validator --masterAccount=owner
```
#### Deploy the contract to the new account
```bash
near deploy --accountId=my_validator --wasmFile=res/staking_pool.wasm
```
#### Create a new node:

**Note** after you NEAR is unstaked stop your node and create a new one to run as the contract account

##### Stop your node
```bash
nearup stop
```
##### Move your ~/.near/betanet folder, to remove references to any previous validator node
```bash
mv ~/.near/betanet ~/.near/betanet_old
```
##### Launch your new node
With the command nearup betanet. Modify the launch command according to your actual validator configuration (e.g. using --nodocker and --binary-path)

##### Set your validator ID.
Put your staking pool account (the one we called my_validator in the steps above)

##### Copy your validator public key, or issue the command (before the next step)
```bash
cat ~/.near/betanet/validator_key.json |grep "public_key"
```
#### Initialize staking pool at account `my_validator` for the owner account ID `owner`, given staking pool and 10% reward fee
```bash
near call my_validator new '{"owner_id": "owner", "stake_public_key": "CE3QAXyVLeScmY9YeEyR3Tw9yXfjBPzFLzroTranYtVb", "reward_fee_fraction": {"numerator": 10, "denominator": 100}}' --account_id owner
```
#### Check the current `seat price` to transfer the correct amount to your delegator(s)
```bash
near validators next| grep "seat price"
```
#### Register a delegator account (repeat these steps for additional delegators)
-- https://wallet.betanet.near.org
-- backup your seed phrase
-- transfer NEAR from your MasterAccount to the delegator account

#### Login and authorize the delegator
```bash
near login
```
#### Deposit NEAR from the delegator account to the valdiator contract
```bash
near call my_validator deposit '{}' --accountId user1 --amount 100
```
#### Stake the deposited amount to the validator contract
```bash
near call my_validator stake '{"amount": "100000000000000000000000000"}' --accountId user1
```
#### Check that your validator proposal was (Accepted) or deposit and stake more NEAR
```bash
near proposals | grep my_validator
#After some time check to make sure you're listed
near validators next | grep my_validator
```
## Common errors and resolutions

#### ERROR while adding wasm32 to toolchain: error[E0463]: can't find crate for `core`
You might have a nightly version of cargo, rustc, rustup, update to stable
```bash
rustup update stable

#Install target with stable version of Rustup
rustup +stable target add wasm32-unknown-unknown
```

#### Error:  TypedError: [-32000] Server error: account <accountId> does not exist while viewing
You are not logged in
```bash
near login
```

#### Error:  GasExceeded [Error]: Exceeded the prepaid gas
Add additional gas by adding the parameter: --gas 10000000000000000

#### Error: "wasm execution failed with error: FunctionCallError(MethodResolveError(MethodNotFound))"
Your function call is incorrect or your contract is not updated

'''
'''--- staking-pool/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/staking_pool.wasm ./res/

'''
'''--- staking-pool/src/internal.rs ---
use crate::*;

impl StakingContract {
    /********************/
    /* Internal methods */
    /********************/

    /// Restakes the current `total_staked_balance` again.
    pub(crate) fn internal_restake(&mut self) {
        if self.paused {
            return;
        }
        // Stakes with the staking public key. If the public key is invalid the entire function
        // call will be rolled back.
        Promise::new(env::current_account_id())
            .stake(self.total_staked_balance, self.stake_public_key.clone())
            .then(ext_self::on_stake_action(
                &env::current_account_id(),
                NO_DEPOSIT,
                ON_STAKE_ACTION_GAS,
            ));
    }

    pub(crate) fn internal_deposit(&mut self) -> u128 {
        let account_id = env::predecessor_account_id();
        let mut account = self.internal_get_account(&account_id);
        let amount = env::attached_deposit();
        account.unstaked += amount;
        self.internal_save_account(&account_id, &account);
        self.last_total_balance += amount;

        env::log(
            format!(
                "@{} deposited {}. New unstaked balance is {}",
                account_id, amount, account.unstaked
            )
            .as_bytes(),
        );
        amount
    }

    pub(crate) fn internal_withdraw(&mut self, amount: Balance) {
        assert!(amount > 0, "Withdrawal amount should be positive");

        let account_id = env::predecessor_account_id();
        let mut account = self.internal_get_account(&account_id);
        assert!(
            account.unstaked >= amount,
            "Not enough unstaked balance to withdraw"
        );
        assert!(
            account.unstaked_available_epoch_height <= env::epoch_height(),
            "The unstaked balance is not yet available due to unstaking delay"
        );
        account.unstaked -= amount;
        self.internal_save_account(&account_id, &account);

        env::log(
            format!(
                "@{} withdrawing {}. New unstaked balance is {}",
                account_id, amount, account.unstaked
            )
            .as_bytes(),
        );

        Promise::new(account_id).transfer(amount);
        self.last_total_balance -= amount;
    }

    pub(crate) fn internal_stake(&mut self, amount: Balance) {
        assert!(amount > 0, "Staking amount should be positive");

        let account_id = env::predecessor_account_id();
        let mut account = self.internal_get_account(&account_id);

        // Calculate the number of "stake" shares that the account will receive for staking the
        // given amount.
        let num_shares = self.num_shares_from_staked_amount_rounded_down(amount);
        assert!(
            num_shares > 0,
            "The calculated number of \"stake\" shares received for staking should be positive"
        );
        // The amount of tokens the account will be charged from the unstaked balance.
        // Rounded down to avoid overcharging the account to guarantee that the account can always
        // unstake at least the same amount as staked.
        let charge_amount = self.staked_amount_from_num_shares_rounded_down(num_shares);
        assert!(
            charge_amount > 0,
            "Invariant violation. Calculated staked amount must be positive, because \"stake\" share price should be at least 1"
        );

        assert!(
            account.unstaked >= charge_amount,
            "Not enough unstaked balance to stake"
        );
        account.unstaked -= charge_amount;
        account.stake_shares += num_shares;
        self.internal_save_account(&account_id, &account);

        // The staked amount that will be added to the total to guarantee the "stake" share price
        // never decreases. The difference between `stake_amount` and `charge_amount` is paid
        // from the allocated STAKE_SHARE_PRICE_GUARANTEE_FUND.
        let stake_amount = self.staked_amount_from_num_shares_rounded_up(num_shares);

        self.total_staked_balance += stake_amount;
        self.total_stake_shares += num_shares;

        env::log(
            format!(
                "@{} staking {}. Received {} new staking shares. Total {} unstaked balance and {} staking shares",
                account_id, charge_amount, num_shares, account.unstaked, account.stake_shares
            )
                .as_bytes(),
        );
        env::log(
            format!(
                "Contract total staked balance is {}. Total number of shares {}",
                self.total_staked_balance, self.total_stake_shares
            )
            .as_bytes(),
        );
    }

    pub(crate) fn inner_unstake(&mut self, amount: u128) {
        assert!(amount > 0, "Unstaking amount should be positive");

        let account_id = env::predecessor_account_id();
        let mut account = self.internal_get_account(&account_id);

        assert!(
            self.total_staked_balance > 0,
            "The contract doesn't have staked balance"
        );
        // Calculate the number of shares required to unstake the given amount.
        // NOTE: The number of shares the account will pay is rounded up.
        let num_shares = self.num_shares_from_staked_amount_rounded_up(amount);
        assert!(
            num_shares > 0,
            "Invariant violation. The calculated number of \"stake\" shares for unstaking should be positive"
        );
        assert!(
            account.stake_shares >= num_shares,
            "Not enough staked balance to unstake"
        );

        // Calculating the amount of tokens the account will receive by unstaking the corresponding
        // number of "stake" shares, rounding up.
        let receive_amount = self.staked_amount_from_num_shares_rounded_up(num_shares);
        assert!(
            receive_amount > 0,
            "Invariant violation. Calculated staked amount must be positive, because \"stake\" share price should be at least 1"
        );

        account.stake_shares -= num_shares;
        account.unstaked += receive_amount;
        account.unstaked_available_epoch_height = env::epoch_height() + NUM_EPOCHS_TO_UNLOCK;
        self.internal_save_account(&account_id, &account);

        // The amount tokens that will be unstaked from the total to guarantee the "stake" share
        // price never decreases. The difference between `receive_amount` and `unstake_amount` is
        // paid from the allocated STAKE_SHARE_PRICE_GUARANTEE_FUND.
        let unstake_amount = self.staked_amount_from_num_shares_rounded_down(num_shares);

        self.total_staked_balance -= unstake_amount;
        self.total_stake_shares -= num_shares;

        env::log(
            format!(
                "@{} unstaking {}. Spent {} staking shares. Total {} unstaked balance and {} staking shares",
                account_id, receive_amount, num_shares, account.unstaked, account.stake_shares
            )
                .as_bytes(),
        );
        env::log(
            format!(
                "Contract total staked balance is {}. Total number of shares {}",
                self.total_staked_balance, self.total_stake_shares
            )
            .as_bytes(),
        );
    }

    /// Asserts that the method was called by the owner.
    pub(crate) fn assert_owner(&self) {
        assert_eq!(
            env::predecessor_account_id(),
            self.owner_id,
            "Can only be called by the owner"
        );
    }

    /// Distributes rewards after the new epoch. It's automatically called before every action.
    /// Returns true if the current epoch height is different from the last epoch height.
    pub(crate) fn internal_ping(&mut self) -> bool {
        let epoch_height = env::epoch_height();
        if self.last_epoch_height == epoch_height {
            return false;
        }
        self.last_epoch_height = epoch_height;

        // New total amount (both locked and unlocked balances).
        // NOTE: We need to subtract `attached_deposit` in case `ping` called from `deposit` call
        // since the attached deposit gets included in the `account_balance`, and we have not
        // accounted it yet.
        let total_balance =
            env::account_locked_balance() + env::account_balance() - env::attached_deposit();

        assert!(
            total_balance >= self.last_total_balance,
            "The new total balance should not be less than the old total balance"
        );
        let total_reward = total_balance - self.last_total_balance;
        if total_reward > 0 {
            // The validation fee that the contract owner takes.
            let owners_fee = self.reward_fee_fraction.multiply(total_reward);

            // Distributing the remaining reward to the delegators first.
            let remaining_reward = total_reward - owners_fee;
            self.total_staked_balance += remaining_reward;

            // Now buying "stake" shares for the contract owner at the new share price.
            let num_shares = self.num_shares_from_staked_amount_rounded_down(owners_fee);
            if num_shares > 0 {
                // Updating owner's inner account
                let owner_id = self.owner_id.clone();
                let mut account = self.internal_get_account(&owner_id);
                account.stake_shares += num_shares;
                self.internal_save_account(&owner_id, &account);
                // Increasing the total amount of "stake" shares.
                self.total_stake_shares += num_shares;
            }
            // Increasing the total staked balance by the owners fee, no matter whether the owner
            // received any shares or not.
            self.total_staked_balance += owners_fee;

            env::log(
                format!(
                    "Epoch {}: Contract received total rewards of {} tokens. New total staked balance is {}. Total number of shares {}",
                    epoch_height, total_reward, self.total_staked_balance, self.total_stake_shares,
                )
                    .as_bytes(),
            );
            if num_shares > 0 {
                env::log(format!("Total rewards fee is {} stake shares.", num_shares).as_bytes());
            }
        }

        self.last_total_balance = total_balance;
        true
    }

    /// Returns the number of "stake" shares rounded down corresponding to the given staked balance
    /// amount.
    ///
    /// price = total_staked / total_shares
    /// Price is fixed
    /// (total_staked + amount) / (total_shares + num_shares) = total_staked / total_shares
    /// (total_staked + amount) * total_shares = total_staked * (total_shares + num_shares)
    /// amount * total_shares = total_staked * num_shares
    /// num_shares = amount * total_shares / total_staked
    pub(crate) fn num_shares_from_staked_amount_rounded_down(
        &self,
        amount: Balance,
    ) -> NumStakeShares {
        assert!(
            self.total_staked_balance > 0,
            "The total staked balance can't be 0"
        );
        (U256::from(self.total_stake_shares) * U256::from(amount)
            / U256::from(self.total_staked_balance))
        .as_u128()
    }

    /// Returns the number of "stake" shares rounded up corresponding to the given staked balance
    /// amount.
    ///
    /// Rounding up division of `a / b` is done using `(a + b - 1) / b`.
    pub(crate) fn num_shares_from_staked_amount_rounded_up(
        &self,
        amount: Balance,
    ) -> NumStakeShares {
        assert!(
            self.total_staked_balance > 0,
            "The total staked balance can't be 0"
        );
        ((U256::from(self.total_stake_shares) * U256::from(amount)
            + U256::from(self.total_staked_balance - 1))
            / U256::from(self.total_staked_balance))
        .as_u128()
    }

    /// Returns the staked amount rounded down corresponding to the given number of "stake" shares.
    pub(crate) fn staked_amount_from_num_shares_rounded_down(
        &self,
        num_shares: NumStakeShares,
    ) -> Balance {
        assert!(
            self.total_stake_shares > 0,
            "The total number of stake shares can't be 0"
        );
        (U256::from(self.total_staked_balance) * U256::from(num_shares)
            / U256::from(self.total_stake_shares))
        .as_u128()
    }

    /// Returns the staked amount rounded up corresponding to the given number of "stake" shares.
    ///
    /// Rounding up division of `a / b` is done using `(a + b - 1) / b`.
    pub(crate) fn staked_amount_from_num_shares_rounded_up(
        &self,
        num_shares: NumStakeShares,
    ) -> Balance {
        assert!(
            self.total_stake_shares > 0,
            "The total number of stake shares can't be 0"
        );
        ((U256::from(self.total_staked_balance) * U256::from(num_shares)
            + U256::from(self.total_stake_shares - 1))
            / U256::from(self.total_stake_shares))
        .as_u128()
    }

    /// Inner method to get the given account or a new default value account.
    pub(crate) fn internal_get_account(&self, account_id: &AccountId) -> Account {
        self.accounts.get(account_id).unwrap_or_default()
    }

    /// Inner method to save the given account for a given account ID.
    /// If the account balances are 0, the account is deleted instead to release storage.
    pub(crate) fn internal_save_account(&mut self, account_id: &AccountId, account: &Account) {
        if account.unstaked > 0 || account.stake_shares > 0 {
            self.accounts.insert(account_id, &account);
        } else {
            self.accounts.remove(account_id);
        }
    }
}

'''
'''--- staking-pool/src/lib.rs ---
use std::convert::TryInto;

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::UnorderedMap;
use near_sdk::json_types::{Base58PublicKey, U128};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{
    env, ext_contract, near_bindgen, AccountId, Balance, EpochHeight, Promise, PromiseResult,
    PublicKey,
};
use uint::construct_uint;

mod internal;

/// The amount of gas given to complete `vote` call.
const VOTE_GAS: u64 = 100_000_000_000_000;

/// The amount of gas given to complete internal `on_stake_action` call.
const ON_STAKE_ACTION_GAS: u64 = 20_000_000_000_000;

/// The amount of yocto NEAR the contract dedicates to guarantee that the "share" price never
/// decreases. It's used during rounding errors for share -> amount conversions.
const STAKE_SHARE_PRICE_GUARANTEE_FUND: Balance = 1_000_000_000_000;

/// There is no deposit balance attached.
const NO_DEPOSIT: Balance = 0;

/// A type to distinguish between a balance and "stake" shares for better readability.
pub type NumStakeShares = Balance;

construct_uint! {
    /// 256-bit unsigned integer.
    pub struct U256(4);
}

#[cfg(test)]
mod test_utils;

#[global_allocator]
static ALLOC: near_sdk::wee_alloc::WeeAlloc = near_sdk::wee_alloc::WeeAlloc::INIT;

/// Inner account data of a delegate.
#[derive(BorshDeserialize, BorshSerialize, Debug, PartialEq)]
pub struct Account {
    /// The unstaked balance. It represents the amount the account has on this contract that
    /// can either be staked or withdrawn.
    pub unstaked: Balance,
    /// The amount of "stake" shares. Every stake share corresponds to the amount of staked balance.
    /// NOTE: The number of shares should always be less or equal than the amount of staked balance.
    /// This means the price of stake share should always be at least `1`.
    /// The price of stake share can be computed as `total_staked_balance` / `total_stake_shares`.
    pub stake_shares: NumStakeShares,
    /// The minimum epoch height when the withdrawn is allowed.
    /// This changes after unstaking action, because the amount is still locked for 3 epochs.
    pub unstaked_available_epoch_height: EpochHeight,
}

/// Represents an account structure readable by humans.
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct HumanReadableAccount {
    pub account_id: AccountId,
    /// The unstaked balance that can be withdrawn or staked.
    pub unstaked_balance: U128,
    /// The amount balance staked at the current "stake" share price.
    pub staked_balance: U128,
    /// Whether the unstaked balance is available for withdrawal now.
    pub can_withdraw: bool,
}

impl Default for Account {
    fn default() -> Self {
        Self {
            unstaked: 0,
            stake_shares: 0,
            unstaked_available_epoch_height: 0,
        }
    }
}

/// The number of epochs required for the locked balance to become unlocked.
/// NOTE: The actual number of epochs when the funds are unlocked is 3. But there is a corner case
/// when the unstaking promise can arrive at the next epoch, while the inner state is already
/// updated in the previous epoch. It will not unlock the funds for 4 epochs.
const NUM_EPOCHS_TO_UNLOCK: EpochHeight = 4;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct StakingContract {
    /// The account ID of the owner who's running the staking validator node.
    /// NOTE: This is different from the current account ID which is used as a validator account.
    /// The owner of the staking pool can change staking public key and adjust reward fees.
    pub owner_id: AccountId,
    /// The public key which is used for staking action. It's the public key of the validator node
    /// that validates on behalf of the pool.
    pub stake_public_key: PublicKey,
    /// The last epoch height when `ping` was called.
    pub last_epoch_height: EpochHeight,
    /// The last total balance of the account (consists of staked and unstaked balances).
    pub last_total_balance: Balance,
    /// The total amount of shares. It should be equal to the total amount of shares across all
    /// accounts.
    pub total_stake_shares: NumStakeShares,
    /// The total staked balance.
    pub total_staked_balance: Balance,
    /// The fraction of the reward that goes to the owner of the staking pool for running the
    /// validator node.
    pub reward_fee_fraction: RewardFeeFraction,
    /// Persistent map from an account ID to the corresponding account.
    pub accounts: UnorderedMap<AccountId, Account>,
    /// Whether the staking is paused.
    /// When paused, the account unstakes everything (stakes 0) and doesn't restake.
    /// It doesn't affect the staking shares or reward distribution.
    /// Pausing is useful for node maintenance. Only the owner can pause and resume staking.
    /// The contract is not paused by default.
    pub paused: bool,
}

impl Default for StakingContract {
    fn default() -> Self {
        env::panic(b"Staking contract should be initialized before usage")
    }
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct RewardFeeFraction {
    pub numerator: u32,
    pub denominator: u32,
}

impl RewardFeeFraction {
    pub fn assert_valid(&self) {
        assert_ne!(self.denominator, 0, "Denominator must be a positive number");
        assert!(
            self.numerator <= self.denominator,
            "The reward fee must be less or equal to 1"
        );
    }

    pub fn multiply(&self, value: Balance) -> Balance {
        (U256::from(self.numerator) * U256::from(value) / U256::from(self.denominator)).as_u128()
    }
}

/// Interface for a voting contract.
#[ext_contract(ext_voting)]
pub trait VoteContract {
    /// Method for validators to vote or withdraw the vote.
    /// Votes for if `is_vote` is true, or withdraws the vote if `is_vote` is false.
    fn vote(&mut self, is_vote: bool);
}

/// Interface for the contract itself.
#[ext_contract(ext_self)]
pub trait SelfContract {
    /// A callback to check the result of the staking action.
    /// In case the stake amount is less than the minimum staking threshold, the staking action
    /// fails, and the stake amount is not changed. This might lead to inconsistent state and the
    /// follow withdraw calls might fail. To mitigate this, the contract will issue a new unstaking
    /// action in case of the failure of the first staking action.
    fn on_stake_action(&mut self);
}

#[near_bindgen]
impl StakingContract {
    /// Initializes the contract with the given owner_id, initial staking public key (with ED25519
    /// curve) and initial reward fee fraction that owner charges for the validation work.
    ///
    /// The entire current balance of this contract will be used to stake. This allows contract to
    /// always maintain staking shares that can't be unstaked or withdrawn.
    /// It prevents inflating the price of the share too much.
    #[init]
    pub fn new(
        owner_id: AccountId,
        stake_public_key: Base58PublicKey,
        reward_fee_fraction: RewardFeeFraction,
    ) -> Self {
        assert!(!env::state_exists(), "Already initialized");
        reward_fee_fraction.assert_valid();
        assert!(
            env::is_valid_account_id(owner_id.as_bytes()),
            "The owner account ID is invalid"
        );
        let account_balance = env::account_balance();
        let total_staked_balance = account_balance - STAKE_SHARE_PRICE_GUARANTEE_FUND;
        assert_eq!(
            env::account_locked_balance(),
            0,
            "The staking pool shouldn't be staking at the initialization"
        );
        let mut this = Self {
            owner_id,
            stake_public_key: stake_public_key.into(),
            last_epoch_height: env::epoch_height(),
            last_total_balance: account_balance,
            total_staked_balance,
            total_stake_shares: NumStakeShares::from(total_staked_balance),
            reward_fee_fraction,
            accounts: UnorderedMap::new(b"u".to_vec()),
            paused: false,
        };
        // Staking with the current pool to make sure the staking key is valid.
        this.internal_restake();
        this
    }

    /// Distributes rewards and restakes if needed.
    pub fn ping(&mut self) {
        if self.internal_ping() {
            self.internal_restake();
        }
    }

    /// Deposits the attached amount into the inner account of the predecessor.
    #[payable]
    pub fn deposit(&mut self) {
        let need_to_restake = self.internal_ping();

        self.internal_deposit();

        if need_to_restake {
            self.internal_restake();
        }
    }

    /// Deposits the attached amount into the inner account of the predecessor and stakes it.
    #[payable]
    pub fn deposit_and_stake(&mut self) {
        self.internal_ping();

        let amount = self.internal_deposit();
        self.internal_stake(amount);

        self.internal_restake();
    }

    /// Withdraws the entire unstaked balance from the predecessor account.
    /// It's only allowed if the `unstake` action was not performed in the four most recent epochs.
    pub fn withdraw_all(&mut self) {
        let need_to_restake = self.internal_ping();

        let account_id = env::predecessor_account_id();
        let account = self.internal_get_account(&account_id);
        self.internal_withdraw(account.unstaked);

        if need_to_restake {
            self.internal_restake();
        }
    }

    /// Withdraws the non staked balance for given account.
    /// It's only allowed if the `unstake` action was not performed in the four most recent epochs.
    pub fn withdraw(&mut self, amount: U128) {
        let need_to_restake = self.internal_ping();

        let amount: Balance = amount.into();
        self.internal_withdraw(amount);

        if need_to_restake {
            self.internal_restake();
        }
    }

    /// Stakes all available unstaked balance from the inner account of the predecessor.
    pub fn stake_all(&mut self) {
        // Stake action always restakes
        self.internal_ping();

        let account_id = env::predecessor_account_id();
        let account = self.internal_get_account(&account_id);
        self.internal_stake(account.unstaked);

        self.internal_restake();
    }

    /// Stakes the given amount from the inner account of the predecessor.
    /// The inner account should have enough unstaked balance.
    pub fn stake(&mut self, amount: U128) {
        // Stake action always restakes
        self.internal_ping();

        let amount: Balance = amount.into();
        self.internal_stake(amount);

        self.internal_restake();
    }

    /// Unstakes all staked balance from the inner account of the predecessor.
    /// The new total unstaked balance will be available for withdrawal in four epochs.
    pub fn unstake_all(&mut self) {
        // Unstake action always restakes
        self.internal_ping();

        let account_id = env::predecessor_account_id();
        let account = self.internal_get_account(&account_id);
        let amount = self.staked_amount_from_num_shares_rounded_down(account.stake_shares);
        self.inner_unstake(amount);

        self.internal_restake();
    }

    /// Unstakes the given amount from the inner account of the predecessor.
    /// The inner account should have enough staked balance.
    /// The new total unstaked balance will be available for withdrawal in four epochs.
    pub fn unstake(&mut self, amount: U128) {
        // Unstake action always restakes
        self.internal_ping();

        let amount: Balance = amount.into();
        self.inner_unstake(amount);

        self.internal_restake();
    }

    /****************/
    /* View methods */
    /****************/

    /// Returns the unstaked balance of the given account.
    pub fn get_account_unstaked_balance(&self, account_id: AccountId) -> U128 {
        self.get_account(account_id).unstaked_balance
    }

    /// Returns the staked balance of the given account.
    /// NOTE: This is computed from the amount of "stake" shares the given account has and the
    /// current amount of total staked balance and total stake shares on the account.
    pub fn get_account_staked_balance(&self, account_id: AccountId) -> U128 {
        self.get_account(account_id).staked_balance
    }

    /// Returns the total balance of the given account (including staked and unstaked balances).
    pub fn get_account_total_balance(&self, account_id: AccountId) -> U128 {
        let account = self.get_account(account_id);
        (account.unstaked_balance.0 + account.staked_balance.0).into()
    }

    /// Returns `true` if the given account can withdraw tokens in the current epoch.
    pub fn is_account_unstaked_balance_available(&self, account_id: AccountId) -> bool {
        self.get_account(account_id).can_withdraw
    }

    /// Returns the total staking balance.
    pub fn get_total_staked_balance(&self) -> U128 {
        self.total_staked_balance.into()
    }

    /// Returns account ID of the staking pool owner.
    pub fn get_owner_id(&self) -> AccountId {
        self.owner_id.clone()
    }

    /// Returns the current reward fee as a fraction.
    pub fn get_reward_fee_fraction(&self) -> RewardFeeFraction {
        self.reward_fee_fraction.clone()
    }

    /// Returns the staking public key
    pub fn get_staking_key(&self) -> Base58PublicKey {
        self.stake_public_key.clone().try_into().unwrap()
    }

    /// Returns true if the staking is paused
    pub fn is_staking_paused(&self) -> bool {
        self.paused
    }

    /// Returns human readable representation of the account for the given account ID.
    pub fn get_account(&self, account_id: AccountId) -> HumanReadableAccount {
        let account = self.internal_get_account(&account_id);
        HumanReadableAccount {
            account_id,
            unstaked_balance: account.unstaked.into(),
            staked_balance: self
                .staked_amount_from_num_shares_rounded_down(account.stake_shares)
                .into(),
            can_withdraw: account.unstaked_available_epoch_height <= env::epoch_height(),
        }
    }

    /// Returns the number of accounts that have positive balance on this staking pool.
    pub fn get_number_of_accounts(&self) -> u64 {
        self.accounts.len()
    }

    /// Returns the list of accounts
    pub fn get_accounts(&self, from_index: u64, limit: u64) -> Vec<HumanReadableAccount> {
        let keys = self.accounts.keys_as_vector();

        (from_index..std::cmp::min(from_index + limit, keys.len()))
            .map(|index| self.get_account(keys.get(index).unwrap()))
            .collect()
    }

    /*************/
    /* Callbacks */
    /*************/

    pub fn on_stake_action(&mut self) {
        assert_eq!(
            env::current_account_id(),
            env::predecessor_account_id(),
            "Can be called only as a callback"
        );

        assert_eq!(
            env::promise_results_count(),
            1,
            "Contract expected a result on the callback"
        );
        let stake_action_succeeded = match env::promise_result(0) {
            PromiseResult::Successful(_) => true,
            _ => false,
        };

        // If the stake action failed and the current locked amount is positive, then the contract
        // has to unstake.
        if !stake_action_succeeded && env::account_locked_balance() > 0 {
            Promise::new(env::current_account_id()).stake(0, self.stake_public_key.clone());
        }
    }

    /*******************/
    /* Owner's methods */
    /*******************/

    /// Owner's method.
    /// Updates current public key to the new given public key.
    pub fn update_staking_key(&mut self, stake_public_key: Base58PublicKey) {
        self.assert_owner();
        // When updating the staking key, the contract has to restake.
        let _need_to_restake = self.internal_ping();
        self.stake_public_key = stake_public_key.into();
        self.internal_restake();
    }

    /// Owner's method.
    /// Updates current reward fee fraction to the new given fraction.
    pub fn update_reward_fee_fraction(&mut self, reward_fee_fraction: RewardFeeFraction) {
        self.assert_owner();
        reward_fee_fraction.assert_valid();

        let need_to_restake = self.internal_ping();
        self.reward_fee_fraction = reward_fee_fraction;
        if need_to_restake {
            self.internal_restake();
        }
    }

    /// Owner's method.
    /// Calls `vote(is_vote)` on the given voting contract account ID on behalf of the pool.
    pub fn vote(&mut self, voting_account_id: AccountId, is_vote: bool) -> Promise {
        self.assert_owner();
        assert!(
            env::is_valid_account_id(voting_account_id.as_bytes()),
            "Invalid voting account ID"
        );

        ext_voting::vote(is_vote, &voting_account_id, NO_DEPOSIT, VOTE_GAS)
    }

    /// Owner's method.
    /// Pauses pool staking.
    pub fn pause_staking(&mut self) {
        self.assert_owner();
        assert!(!self.paused, "The staking is already paused");

        self.internal_ping();
        self.paused = true;
        Promise::new(env::current_account_id()).stake(0, self.stake_public_key.clone());
    }

    /// Owner's method.
    /// Resumes pool staking.
    pub fn resume_staking(&mut self) {
        self.assert_owner();
        assert!(self.paused, "The staking is not paused");

        self.internal_ping();
        self.paused = false;
        self.internal_restake();
    }
}

#[cfg(test)]
mod tests {
    use std::convert::TryFrom;

    use near_sdk::{serde_json, testing_env, MockedBlockchain, VMContext};

    use crate::test_utils::*;

    use super::*;

    struct Emulator {
        pub contract: StakingContract,
        pub epoch_height: EpochHeight,
        pub amount: Balance,
        pub locked_amount: Balance,
        last_total_staked_balance: Balance,
        last_total_stake_shares: Balance,
        context: VMContext,
    }

    fn zero_fee() -> RewardFeeFraction {
        RewardFeeFraction {
            numerator: 0,
            denominator: 1,
        }
    }

    impl Emulator {
        pub fn new(
            owner: String,
            stake_public_key: String,
            reward_fee_fraction: RewardFeeFraction,
        ) -> Self {
            let context = VMContextBuilder::new()
                .current_account_id(owner.clone())
                .account_balance(ntoy(30))
                .finish();
            testing_env!(context.clone());
            let contract = StakingContract::new(
                owner,
                Base58PublicKey::try_from(stake_public_key).unwrap(),
                reward_fee_fraction,
            );
            let last_total_staked_balance = contract.total_staked_balance;
            let last_total_stake_shares = contract.total_stake_shares;
            Emulator {
                contract,
                epoch_height: 0,
                amount: ntoy(30),
                locked_amount: 0,
                last_total_staked_balance,
                last_total_stake_shares,
                context,
            }
        }

        fn verify_stake_price_increase_guarantee(&mut self) {
            let total_staked_balance = self.contract.total_staked_balance;
            let total_stake_shares = self.contract.total_stake_shares;
            assert!(
                U256::from(total_staked_balance) * U256::from(self.last_total_stake_shares)
                    >= U256::from(self.last_total_staked_balance) * U256::from(total_stake_shares),
                "Price increase guarantee was violated."
            );
            self.last_total_staked_balance = total_staked_balance;
            self.last_total_stake_shares = total_stake_shares;
        }

        pub fn update_context(&mut self, predecessor_account_id: String, deposit: Balance) {
            self.verify_stake_price_increase_guarantee();
            self.context = VMContextBuilder::new()
                .current_account_id(staking())
                .predecessor_account_id(predecessor_account_id.clone())
                .signer_account_id(predecessor_account_id)
                .attached_deposit(deposit)
                .account_balance(self.amount)
                .account_locked_balance(self.locked_amount)
                .epoch_height(self.epoch_height)
                .finish();
            testing_env!(self.context.clone());
            println!(
                "Epoch: {}, Deposit: {}, amount: {}, locked_amount: {}",
                self.epoch_height, deposit, self.amount, self.locked_amount
            );
        }

        pub fn simulate_stake_call(&mut self) {
            let total_stake = self.contract.total_staked_balance;
            // Stake action
            self.amount = self.amount + self.locked_amount - total_stake;
            self.locked_amount = total_stake;
            // Second function call action
            self.update_context(staking(), 0);
        }

        pub fn skip_epochs(&mut self, num: EpochHeight) {
            self.epoch_height += num;
            self.locked_amount = (self.locked_amount * (100 + u128::from(num))) / 100;
        }
    }

    #[test]
    fn test_restake_fail() {
        let mut emulator = Emulator::new(
            owner(),
            "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7".to_string(),
            zero_fee(),
        );
        emulator.update_context(bob(), 0);
        emulator.contract.internal_restake();
        let receipts = env::created_receipts();
        assert_eq!(receipts.len(), 2);
        // Mocked Receipt fields are private, so can't check directly.
        assert!(serde_json::to_string(&receipts[0])
            .unwrap()
            .contains("\"actions\":[{\"Stake\":{\"stake\":29999999999999000000000000,"));
        assert!(serde_json::to_string(&receipts[1])
            .unwrap()
            .contains("\"method_name\":\"on_stake_action\""));
        emulator.simulate_stake_call();

        emulator.update_context(staking(), 0);
        testing_env_with_promise_results(emulator.context.clone(), PromiseResult::Failed);
        emulator.contract.on_stake_action();
        let receipts = env::created_receipts();
        assert_eq!(receipts.len(), 1);
        assert!(serde_json::to_string(&receipts[0])
            .unwrap()
            .contains("\"actions\":[{\"Stake\":{\"stake\":0,"));
    }

    #[test]
    fn test_deposit_withdraw() {
        let mut emulator = Emulator::new(
            owner(),
            "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7".to_string(),
            zero_fee(),
        );
        let deposit_amount = ntoy(1_000_000);
        emulator.update_context(bob(), deposit_amount);
        emulator.contract.deposit();
        emulator.amount += deposit_amount;
        emulator.update_context(bob(), 0);
        assert_eq!(
            emulator.contract.get_account_unstaked_balance(bob()).0,
            deposit_amount
        );
        emulator.contract.withdraw(deposit_amount.into());
        assert_eq!(
            emulator.contract.get_account_unstaked_balance(bob()).0,
            0u128
        );
    }

    #[test]
    fn test_stake_with_fee() {
        let mut emulator = Emulator::new(
            owner(),
            "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7".to_string(),
            RewardFeeFraction {
                numerator: 10,
                denominator: 100,
            },
        );
        let deposit_amount = ntoy(1_000_000);
        emulator.update_context(bob(), deposit_amount);
        emulator.contract.deposit();
        emulator.amount += deposit_amount;
        emulator.update_context(bob(), 0);
        emulator.contract.stake(deposit_amount.into());
        emulator.simulate_stake_call();
        assert_eq!(
            emulator.contract.get_account_staked_balance(bob()).0,
            deposit_amount
        );

        let locked_amount = emulator.locked_amount;
        let n_locked_amount = yton(locked_amount);
        emulator.skip_epochs(10);
        // Overriding rewards (+ 100K reward)
        emulator.locked_amount = locked_amount + ntoy(100_000);
        emulator.update_context(bob(), 0);
        emulator.contract.ping();
        let expected_amount = deposit_amount
            + ntoy((yton(deposit_amount) * 90_000 + n_locked_amount / 2) / n_locked_amount);
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(bob()).0,
            expected_amount
        );
        // Owner got 10% of the rewards
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(owner()).0,
            ntoy(10_000)
        );

        let locked_amount = emulator.locked_amount;
        let n_locked_amount = yton(locked_amount);
        emulator.skip_epochs(10);
        // Overriding rewards (another 100K reward)
        emulator.locked_amount = locked_amount + ntoy(100_000);

        emulator.update_context(bob(), 0);
        emulator.contract.ping();
        // previous balance plus (1_090_000 / 1_100_030)% of the 90_000 reward (rounding to nearest).
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(bob()).0,
            expected_amount
                + ntoy((yton(expected_amount) * 90_000 + n_locked_amount / 2) / n_locked_amount)
        );
        // owner earns 10% with the fee and also small percentage from restaking.
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(owner()).0,
            ntoy(10_000)
                + ntoy(10_000)
                + ntoy((10_000u128 * 90_000 + n_locked_amount / 2) / n_locked_amount)
        );

        assert_eq!(emulator.contract.get_number_of_accounts(), 2);
    }

    #[test]
    fn test_stake_unstake() {
        let mut emulator = Emulator::new(
            owner(),
            "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7".to_string(),
            zero_fee(),
        );
        let deposit_amount = ntoy(1_000_000);
        emulator.update_context(bob(), deposit_amount);
        emulator.contract.deposit();
        emulator.amount += deposit_amount;
        emulator.update_context(bob(), 0);
        emulator.contract.stake(deposit_amount.into());
        emulator.simulate_stake_call();
        assert_eq!(
            emulator.contract.get_account_staked_balance(bob()).0,
            deposit_amount
        );
        let locked_amount = emulator.locked_amount;
        // 10 epochs later, unstake half of the money.
        emulator.skip_epochs(10);
        // Overriding rewards
        emulator.locked_amount = locked_amount + ntoy(10);
        emulator.update_context(bob(), 0);
        emulator.contract.ping();
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(bob()).0,
            deposit_amount + ntoy(10)
        );
        emulator.contract.unstake((deposit_amount / 2).into());
        emulator.simulate_stake_call();
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(bob()).0,
            deposit_amount / 2 + ntoy(10)
        );
        assert_eq_in_near!(
            emulator.contract.get_account_unstaked_balance(bob()).0,
            deposit_amount / 2
        );
        let acc = emulator.contract.get_account(bob());
        assert_eq!(acc.account_id, bob());
        assert_eq_in_near!(acc.unstaked_balance.0, deposit_amount / 2);
        assert_eq_in_near!(acc.staked_balance.0, deposit_amount / 2 + ntoy(10));
        assert!(!acc.can_withdraw);

        assert!(!emulator
            .contract
            .is_account_unstaked_balance_available(bob()),);
        emulator.skip_epochs(4);
        emulator.update_context(bob(), 0);
        assert!(emulator
            .contract
            .is_account_unstaked_balance_available(bob()),);
    }

    #[test]
    fn test_stake_all_unstake_all() {
        let mut emulator = Emulator::new(
            owner(),
            "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7".to_string(),
            zero_fee(),
        );
        let deposit_amount = ntoy(1_000_000);
        emulator.update_context(bob(), deposit_amount);
        emulator.contract.deposit_and_stake();
        emulator.amount += deposit_amount;
        emulator.simulate_stake_call();
        assert_eq!(
            emulator.contract.get_account_staked_balance(bob()).0,
            deposit_amount
        );
        assert_eq_in_near!(emulator.contract.get_account_unstaked_balance(bob()).0, 0);
        let locked_amount = emulator.locked_amount;

        // 10 epochs later, unstake all.
        emulator.skip_epochs(10);
        // Overriding rewards
        emulator.locked_amount = locked_amount + ntoy(10);
        emulator.update_context(bob(), 0);
        emulator.contract.ping();
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(bob()).0,
            deposit_amount + ntoy(10)
        );
        emulator.contract.unstake_all();
        emulator.simulate_stake_call();
        assert_eq_in_near!(emulator.contract.get_account_staked_balance(bob()).0, 0);
        assert_eq_in_near!(
            emulator.contract.get_account_unstaked_balance(bob()).0,
            deposit_amount + ntoy(10)
        );
    }

    /// Test that two can delegate and then undelegate their funds and rewards at different time.
    #[test]
    fn test_two_delegates() {
        let mut emulator = Emulator::new(
            owner(),
            "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7".to_string(),
            zero_fee(),
        );
        emulator.update_context(alice(), ntoy(1_000_000));
        emulator.contract.deposit();
        emulator.amount += ntoy(1_000_000);
        emulator.update_context(alice(), 0);
        emulator.contract.stake(ntoy(1_000_000).into());
        emulator.simulate_stake_call();
        emulator.skip_epochs(3);
        emulator.update_context(bob(), ntoy(1_000_000));

        emulator.contract.deposit();
        emulator.amount += ntoy(1_000_000);
        emulator.update_context(bob(), 0);
        emulator.contract.stake(ntoy(1_000_000).into());
        emulator.simulate_stake_call();
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(bob()).0,
            ntoy(1_000_000)
        );
        emulator.skip_epochs(3);
        emulator.update_context(alice(), 0);
        emulator.contract.ping();
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(alice()).0,
            ntoy(1_060_900) - 1
        );
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(bob()).0,
            ntoy(1_030_000)
        );

        // Checking accounts view methods
        // Should be 2, because the pool has 0 fee.
        assert_eq!(emulator.contract.get_number_of_accounts(), 2);
        let accounts = emulator.contract.get_accounts(0, 10);
        assert_eq!(accounts.len(), 2);
        assert_eq!(accounts[0].account_id, alice());
        assert_eq!(accounts[1].account_id, bob());

        let accounts = emulator.contract.get_accounts(1, 10);
        assert_eq!(accounts.len(), 1);
        assert_eq!(accounts[0].account_id, bob());

        let accounts = emulator.contract.get_accounts(0, 1);
        assert_eq!(accounts.len(), 1);
        assert_eq!(accounts[0].account_id, alice());

        let accounts = emulator.contract.get_accounts(2, 10);
        assert_eq!(accounts.len(), 0);
    }

    #[test]
    fn test_low_balances() {
        let mut emulator = Emulator::new(
            owner(),
            "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7".to_string(),
            zero_fee(),
        );
        let initial_balance = 100;
        emulator.update_context(alice(), initial_balance);
        emulator.contract.deposit();
        emulator.amount += initial_balance;
        let mut remaining = initial_balance;
        let mut amount = 1;
        while remaining >= 4 {
            emulator.update_context(alice(), 0);
            amount = 2 + (amount - 1) % 3;
            emulator.contract.stake(amount.into());
            emulator.simulate_stake_call();
            remaining -= amount;
        }
    }

    #[test]
    fn test_rewards() {
        let mut emulator = Emulator::new(
            owner(),
            "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7".to_string(),
            zero_fee(),
        );
        let initial_balance = ntoy(100);
        emulator.update_context(alice(), initial_balance);
        emulator.contract.deposit();
        emulator.amount += initial_balance;
        let mut remaining = 100;
        let mut amount = 1;
        while remaining >= 4 {
            emulator.skip_epochs(3);
            emulator.update_context(alice(), 0);
            emulator.contract.ping();
            emulator.update_context(alice(), 0);
            amount = 2 + (amount - 1) % 3;
            emulator.contract.stake(ntoy(amount).into());
            emulator.simulate_stake_call();
            remaining -= amount;
        }
    }
}

'''
'''--- staking-pool/src/test_utils.rs ---
use near_sdk::{AccountId, MockedBlockchain, PromiseResult, VMContext};
use near_sdk::{Balance, BlockHeight, EpochHeight};

pub fn staking() -> AccountId {
    "staking".to_string()
}

pub fn alice() -> AccountId {
    "alice".to_string()
}
pub fn bob() -> AccountId {
    "bob".to_string()
}
pub fn owner() -> AccountId {
    "owner".to_string()
}

pub fn ntoy(near_amount: Balance) -> Balance {
    near_amount * 10u128.pow(24)
}

/// Rounds to nearest
pub fn yton(yocto_amount: Balance) -> Balance {
    (yocto_amount + (5 * 10u128.pow(23))) / 10u128.pow(24)
}

#[macro_export]
macro_rules! assert_eq_in_near {
    ($a:expr, $b:expr) => {
        assert_eq!(yton($a), yton($b))
    };
    ($a:expr, $b:expr, $c:expr) => {
        assert_eq!(yton($a), yton($b), $c)
    };
}

pub struct VMContextBuilder {
    context: VMContext,
}

impl VMContextBuilder {
    pub fn new() -> Self {
        Self {
            context: VMContext {
                current_account_id: "".to_string(),
                signer_account_id: "".to_string(),
                signer_account_pk: vec![0, 1, 2],
                predecessor_account_id: "".to_string(),
                input: vec![],
                epoch_height: 0,
                block_index: 0,
                block_timestamp: 0,
                account_balance: 0,
                account_locked_balance: 0,
                storage_usage: 10u64.pow(6),
                attached_deposit: 0,
                prepaid_gas: 10u64.pow(18),
                random_seed: vec![0, 1, 2],
                is_view: false,
                output_data_receivers: vec![],
            },
        }
    }

    pub fn current_account_id(mut self, account_id: AccountId) -> Self {
        self.context.current_account_id = account_id;
        self
    }

    #[allow(dead_code)]
    pub fn signer_account_id(mut self, account_id: AccountId) -> Self {
        self.context.signer_account_id = account_id;
        self
    }

    pub fn predecessor_account_id(mut self, account_id: AccountId) -> Self {
        self.context.predecessor_account_id = account_id;
        self
    }

    #[allow(dead_code)]
    pub fn block_index(mut self, block_index: BlockHeight) -> Self {
        self.context.block_index = block_index;
        self
    }

    pub fn epoch_height(mut self, epoch_height: EpochHeight) -> Self {
        self.context.epoch_height = epoch_height;
        self
    }

    pub fn attached_deposit(mut self, amount: Balance) -> Self {
        self.context.attached_deposit = amount;
        self
    }

    pub fn account_balance(mut self, amount: Balance) -> Self {
        self.context.account_balance = amount;
        self
    }

    pub fn account_locked_balance(mut self, amount: Balance) -> Self {
        self.context.account_locked_balance = amount;
        self
    }

    pub fn finish(self) -> VMContext {
        self.context
    }
}

pub fn testing_env_with_promise_results(context: VMContext, promise_result: PromiseResult) {
    let storage = near_sdk::env::take_blockchain_interface()
        .unwrap()
        .as_mut_mocked_blockchain()
        .unwrap()
        .take_storage();

    near_sdk::env::set_blockchain_interface(Box::new(MockedBlockchain::new(
        context,
        Default::default(),
        Default::default(),
        vec![promise_result],
        storage,
        Default::default(),
    )));
}

'''
'''--- staking-pool/test.sh ---
#!/bin/bash

./build.sh
cargo test
'''
'''--- staking-pool/tests/general.rs ---
mod utils;

use crate::utils::{is_pool_paused, reward_pool, POOL_ACCOUNT_ID};
use near_primitives::types::Balance;
use utils::{init_pool, ntoy, pool_account, wait_epoch, ExternalUser};

#[test]
fn multi_accounts_max_roundtrip() {
    struct AccountStake {
        pub account: ExternalUser,
        pub staked: Balance,
    };
    let initial_pool_balance = ntoy(100);
    let (ref mut runtime, ref root) = init_pool(initial_pool_balance);
    assert_eq!(
        pool_account(runtime).amount + pool_account(runtime).locked,
        initial_pool_balance
    );
    let mut accounts: Vec<AccountStake> = vec![];
    let mut to_spend = 1;
    let mut spent_total = 0;
    let mut acc_no = 0;
    loop {
        to_spend = to_spend * 2;

        acc_no += 1;
        let acc = if let Ok(acc) =
            root.create_external(runtime, format!("account_{}", acc_no), ntoy(30) + to_spend)
        {
            acc
        } else {
            break;
        };
        acc.pool_deposit(runtime, to_spend).unwrap();
        spent_total += to_spend;
        dbg!(spent_total);
        let pool_acc = runtime.view_account(&"pool".into()).unwrap();
        assert_eq!(
            pool_acc.amount + pool_acc.locked,
            initial_pool_balance + spent_total
        );
        acc.pool_stake(runtime, to_spend).unwrap();
        accounts.push(AccountStake {
            account: acc,
            staked: to_spend,
        });
    }

    for AccountStake { account, staked } in &accounts {
        account.pool_unstake(runtime, *staked).unwrap();
    }
    wait_epoch(runtime);
    runtime.produce_block().unwrap();
    for AccountStake { account, staked } in &accounts {
        account.pool_withdraw(runtime, *staked).unwrap();
        assert_eq!(
            account.account(runtime).amount,
            ntoy(30) + *staked,
            "Account: {:?}, staked: {:?}",
            account.account_id(),
            staked
        );
    }

    assert_eq!(
        pool_account(runtime).amount + pool_account(runtime).locked,
        initial_pool_balance
    );
}

#[test]
fn test_pause_resume() {
    let deposit_amount = ntoy(40);
    let (mut runtime, root) = init_pool(ntoy(100));
    let bob = root
        .create_external(&mut runtime, "bob".into(), ntoy(100))
        .unwrap();

    assert!(!is_pool_paused(&mut runtime));

    root.pool_pause(&mut runtime).unwrap();

    assert!(is_pool_paused(&mut runtime));

    for _ in 0..4 {
        wait_epoch(&mut runtime);
    }

    let mut pool = runtime.view_account(&POOL_ACCOUNT_ID.into()).unwrap();
    pool.amount += pool.locked;
    pool.locked = 0;
    runtime.force_account_update(POOL_ACCOUNT_ID.into(), &pool);

    bob.pool_deposit(&mut runtime, deposit_amount).unwrap();

    let res = bob.get_account_unstaked_balance(&runtime);
    assert_eq!(res, deposit_amount);

    bob.pool_stake(&mut runtime, deposit_amount).unwrap();

    let res = bob.get_account_staked_balance(&runtime);
    assert_eq!(res, deposit_amount);

    for _ in 0..4 {
        wait_epoch(&mut runtime);
    }

    bob.pool_ping(&mut runtime).unwrap();

    assert_eq!(pool_account(&mut runtime).locked, 0);

    let res = bob.get_account_staked_balance(&runtime);
    assert_eq!(res, deposit_amount);

    root.pool_resume(&mut runtime).unwrap();

    assert!(!is_pool_paused(&mut runtime));

    assert_ne!(pool_account(&mut runtime).locked, 0);

    for _ in 0..4 {
        wait_epoch(&mut runtime);
        reward_pool(&mut runtime, ntoy(1));
    }

    bob.pool_ping(&mut runtime).unwrap();

    let res = bob.get_account_staked_balance(&runtime);
    assert!(res > deposit_amount);
}

'''
'''--- staking-pool/tests/quickcheck.rs ---
extern crate env_logger;
#[allow(unused_imports)]
#[macro_use]
extern crate log;
extern crate quickcheck;
#[macro_use(quickcheck)]
extern crate quickcheck_macros;
mod utils;

use near_primitives::types::{AccountId, Balance};
use near_sdk::json_types::U128;
use near_sdk::serde_json::{self, json};
use utils::{call_pool, init_pool, ntoy, wait_epoch};

use near_runtime_standalone::RuntimeStandalone;

#[allow(dead_code)]
fn check_invariants(_runtime: &mut RuntimeStandalone, _users: &[AccountId]) {}

#[quickcheck]
fn qc_should_stake(initial_balance: Balance) -> bool {
    let (mut runtime, root) = init_pool(ntoy(30));
    let bob = root
        .create_external(&mut runtime, "bob".into(), ntoy(100))
        .unwrap();

    let initial_balance = initial_balance + 1;

    bob.pool_deposit(&mut runtime, initial_balance).unwrap();
    bob.pool_stake(&mut runtime, initial_balance).unwrap();
    let bob_stake: U128 = call_pool(
        &mut runtime,
        "get_account_staked_balance",
        json!({"account_id": "bob"}),
    );

    assert_eq!(bob_stake, initial_balance.into());

    bob.pool_unstake(&mut runtime, initial_balance).unwrap();
    for _ in 0..4 {
        wait_epoch(&mut runtime);
    }
    runtime.produce_block().unwrap();
    let outcome = bob.pool_withdraw(&mut runtime, initial_balance);
    if let Err(outcome) = outcome {
        if initial_balance != 0 {
            panic!("{:?}", outcome);
        }
    };
    assert_eq!(bob.account(&mut runtime).amount, ntoy(100));
    return true;
}

#[quickcheck]
fn qc_test_deposit_withdraw_standalone(inital_balance: Balance) -> bool {
    let deposit_amount = ntoy(inital_balance);
    let (mut runtime, root) = init_pool(ntoy(100));
    let bob = root
        .create_external(&mut runtime, "bob".into(), ntoy(100))
        .unwrap();
    bob.pool_deposit(&mut runtime, deposit_amount).unwrap();
    let _res = bob.get_account_unstaked_balance(&runtime);

    assert_eq!(_res, deposit_amount);
    let outcome = bob.pool_withdraw(&mut runtime, deposit_amount);
    if let Err(outcome) = outcome {
        if deposit_amount != 0 {
            panic!("{:?}", outcome);
        }
    };
    bob.get_account_unstaked_balance(&runtime) == 0u128
}

'''
'''--- staking-pool/tests/utils.rs ---
#![allow(dead_code)]
extern crate staking_pool;

use near_crypto::{InMemorySigner, KeyType, Signer};
use near_primitives::{
    account::{AccessKey, Account},
    errors::{RuntimeError, TxExecutionError},
    hash::CryptoHash,
    transaction::{ExecutionOutcome, ExecutionStatus, Transaction},
    types::{AccountId, Balance},
};
use near_runtime_standalone::{init_runtime_and_signer, RuntimeStandalone};
use near_sdk::json_types::U128;
use near_sdk::serde::de::DeserializeOwned;
use near_sdk::serde_json::{self, json};
use staking_pool::RewardFeeFraction;

pub const POOL_ACCOUNT_ID: &str = "pool";
pub const MAX_GAS: u64 = 300_000_000_000_000;

pub fn ntoy(near_amount: Balance) -> Balance {
    near_amount * 10u128.pow(24)
}

lazy_static::lazy_static! {
    static ref POOL_WASM_BYTES: &'static [u8] = include_bytes!("../res/staking_pool.wasm").as_ref();
}

type TxResult = Result<ExecutionOutcome, ExecutionOutcome>;

fn outcome_into_result(outcome: ExecutionOutcome) -> TxResult {
    match outcome.status {
        ExecutionStatus::SuccessValue(_) => Ok(outcome),
        ExecutionStatus::Failure(_) => Err(outcome),
        ExecutionStatus::SuccessReceiptId(_) => panic!("Unresolved ExecutionOutcome run runitme.resolve(tx) to resolve the filnal outcome of tx"),
        ExecutionStatus::Unknown => unreachable!()
    }
}
pub struct ExternalUser {
    account_id: AccountId,
    signer: InMemorySigner,
}

impl ExternalUser {
    pub fn new(account_id: AccountId, signer: InMemorySigner) -> Self {
        Self { account_id, signer }
    }

    #[allow(dead_code)]
    pub fn account_id(&self) -> &AccountId {
        &self.account_id
    }

    #[allow(dead_code)]
    pub fn signer(&self) -> &InMemorySigner {
        &self.signer
    }

    pub fn account(&self, runtime: &mut RuntimeStandalone) -> Account {
        runtime
            .view_account(&self.account_id)
            .expect("Account should be there")
    }

    pub fn create_external(
        &self,
        runtime: &mut RuntimeStandalone,
        new_account_id: AccountId,
        amount: Balance,
    ) -> Result<ExternalUser, ExecutionOutcome> {
        let new_signer =
            InMemorySigner::from_seed(&new_account_id, KeyType::ED25519, &new_account_id);
        let tx = self
            .new_tx(runtime, new_account_id.clone())
            .create_account()
            .add_key(new_signer.public_key(), AccessKey::full_access())
            .transfer(amount)
            .sign(&self.signer);
        let res = runtime.resolve_tx(tx);

        // TODO: this temporary hack, must be rewritten
        if let Err(err) = res.clone() {
            if let RuntimeError::InvalidTxError(tx_err) = err {
                let mut out = ExecutionOutcome::default();
                out.status = ExecutionStatus::Failure(TxExecutionError::InvalidTxError(tx_err));
                return Err(out);
            } else {
                unreachable!();
            }
        } else {
            outcome_into_result(res.unwrap())?;
            runtime.process_all().unwrap();
            Ok(ExternalUser {
                account_id: new_account_id,
                signer: new_signer,
            })
        }
    }

    pub fn pool_init_new(
        &self,
        runtime: &mut RuntimeStandalone,
        amount: Balance,
        reward_fee_fraction: RewardFeeFraction,
    ) -> TxResult {
        let args = json!({
            "owner_id": self.account_id,
            "stake_public_key": "ed25519:3tysLvy7KGoE8pznUgXvSHa4vYyGvrDZFcT8jgb8PEQ6", // not relevant for now
            "reward_fee_fraction": reward_fee_fraction
        })
        .to_string()
        .as_bytes()
        .to_vec();

        let tx = self
            .new_tx(runtime, POOL_ACCOUNT_ID.into())
            .create_account()
            .transfer(amount)
            .deploy_contract(POOL_WASM_BYTES.to_vec())
            .function_call("new".into(), args, MAX_GAS, 0)
            .sign(&self.signer);
        let res = runtime.resolve_tx(tx).unwrap();
        runtime.process_all().unwrap();
        outcome_into_result(res)
    }

    pub fn pool_deposit(&self, runtime: &mut RuntimeStandalone, amount: Balance) -> TxResult {
        let tx = self
            .new_tx(runtime, POOL_ACCOUNT_ID.into())
            .function_call("deposit".into(), vec![], MAX_GAS, amount)
            .sign(&self.signer);
        let res = runtime.resolve_tx(tx).unwrap();
        runtime.process_all().unwrap();
        outcome_into_result(res)
    }

    pub fn pool_ping(&self, runtime: &mut RuntimeStandalone) -> TxResult {
        let tx = self
            .new_tx(runtime, POOL_ACCOUNT_ID.into())
            .function_call("ping".into(), vec![], MAX_GAS, 0)
            .sign(&self.signer);
        let res = runtime.resolve_tx(tx).unwrap();
        runtime.process_all().unwrap();
        outcome_into_result(res)
    }

    pub fn pool_stake(&self, runtime: &mut RuntimeStandalone, amount: u128) -> TxResult {
        let args = json!({ "amount": format!("{}", amount) })
            .to_string()
            .as_bytes()
            .to_vec();
        let tx = self
            .new_tx(runtime, POOL_ACCOUNT_ID.into())
            .function_call("stake".into(), args, MAX_GAS, 0)
            .sign(&self.signer);
        let res = runtime.resolve_tx(tx).unwrap();
        runtime.process_all().unwrap();
        outcome_into_result(res)
    }

    pub fn pool_unstake(&self, runtime: &mut RuntimeStandalone, amount: u128) -> TxResult {
        let args = json!({ "amount": format!("{}", amount) })
            .to_string()
            .as_bytes()
            .to_vec();
        let tx = self
            .new_tx(runtime, POOL_ACCOUNT_ID.into())
            .function_call("unstake".into(), args, MAX_GAS, 0)
            .sign(&self.signer);
        let res = runtime.resolve_tx(tx).unwrap();
        runtime.process_all().unwrap();
        let outcome_res = outcome_into_result(res);
        if outcome_res.is_ok() {
            wait_epoch(runtime);
            let total_stake: U128 = call_pool(runtime, "get_total_staked_balance", "");
            let mut pool_account = runtime.view_account(&POOL_ACCOUNT_ID.into()).unwrap();
            pool_account.amount += pool_account.locked - total_stake.0;
            pool_account.locked = total_stake.0;
            runtime.force_account_update(POOL_ACCOUNT_ID.into(), &pool_account);
        }
        outcome_res
    }

    pub fn pool_withdraw(&self, runtime: &mut RuntimeStandalone, amount: u128) -> TxResult {
        let args = json!({ "amount": format!("{}", amount) })
            .to_string()
            .as_bytes()
            .to_vec();
        let tx = self
            .new_tx(runtime, POOL_ACCOUNT_ID.into())
            .function_call("withdraw".into(), args, MAX_GAS, 0)
            .sign(&self.signer);
        let res = runtime.resolve_tx(tx).unwrap();
        runtime.process_all().unwrap();
        outcome_into_result(res)
    }

    pub fn pool_pause(&self, runtime: &mut RuntimeStandalone) -> TxResult {
        let tx = self
            .new_tx(runtime, POOL_ACCOUNT_ID.into())
            .function_call("pause_staking".into(), vec![], MAX_GAS, 0)
            .sign(&self.signer);
        let res = runtime.resolve_tx(tx).unwrap();
        runtime.process_all().unwrap();
        outcome_into_result(res)
    }

    pub fn pool_resume(&self, runtime: &mut RuntimeStandalone) -> TxResult {
        let tx = self
            .new_tx(runtime, POOL_ACCOUNT_ID.into())
            .function_call("resume_staking".into(), vec![], MAX_GAS, 0)
            .sign(&self.signer);
        let res = runtime.resolve_tx(tx).unwrap();
        runtime.process_all().unwrap();
        outcome_into_result(res)
    }

    #[allow(dead_code)]
    pub fn pool_vote(&self, runtime: &mut RuntimeStandalone, amount: u128) -> TxResult {
        let args = json!({ "amount": format!("{}", amount) })
            .to_string()
            .as_bytes()
            .to_vec();
        let tx = self
            .new_tx(runtime, POOL_ACCOUNT_ID.into())
            .function_call("withdraw".into(), args, MAX_GAS, 0)
            .sign(&self.signer);
        let res = runtime.resolve_tx(tx).unwrap();
        runtime.process_all().unwrap();
        outcome_into_result(res)
    }

    #[allow(dead_code)]
    pub fn get_account_staked_balance(&self, runtime: &RuntimeStandalone) -> Balance {
        let balance = runtime
            .view_method_call(
                &POOL_ACCOUNT_ID.into(),
                "get_account_staked_balance",
                json!({"account_id": self.account_id})
                    .to_string()
                    .as_bytes(),
            )
            .unwrap()
            .0;
        u128::from(serde_json::from_slice::<U128>(balance.as_slice()).unwrap())
    }

    pub fn get_account_unstaked_balance(&self, runtime: &RuntimeStandalone) -> Balance {
        let balance = runtime
            .view_method_call(
                &POOL_ACCOUNT_ID.into(),
                "get_account_unstaked_balance",
                json!({"account_id": self.account_id})
                    .to_string()
                    .as_bytes(),
            )
            .unwrap()
            .0;
        u128::from(serde_json::from_slice::<U128>(balance.as_slice()).unwrap())
    }

    fn new_tx(&self, runtime: &RuntimeStandalone, receiver_id: AccountId) -> Transaction {
        let nonce = runtime
            .view_access_key(&self.account_id, &self.signer.public_key())
            .unwrap()
            .nonce
            + 1;
        Transaction::new(
            self.account_id.clone(),
            self.signer.public_key(),
            receiver_id,
            nonce,
            CryptoHash::default(),
        )
    }
}

pub fn init_pool(initial_transfer: Balance) -> (RuntimeStandalone, ExternalUser) {
    let (mut runtime, signer) = init_runtime_and_signer(&"root".into());
    let root = ExternalUser::new("root".into(), signer);

    root.pool_init_new(
        &mut runtime,
        initial_transfer,
        RewardFeeFraction {
            numerator: 10,
            denominator: 100,
        },
    )
    .unwrap();
    return (runtime, root);
}

pub fn is_pool_paused(runtime: &mut RuntimeStandalone) -> bool {
    call_view(runtime, &POOL_ACCOUNT_ID.into(), "is_staking_paused", "{}")
}

pub fn reward_pool(runtime: &mut RuntimeStandalone, amount: Balance) {
    let mut pool_account = runtime.view_account(&POOL_ACCOUNT_ID.into()).unwrap();
    pool_account.locked += amount;
    runtime.force_account_update(POOL_ACCOUNT_ID.into(), &pool_account);
}

pub fn wait_epoch(runtime: &mut RuntimeStandalone) {
    let epoch_height = runtime.current_block().epoch_height;
    while epoch_height == runtime.current_block().epoch_height {
        runtime.produce_block().unwrap();
    }
}

pub fn call_pool<I: ToString, O: DeserializeOwned>(
    runtime: &mut RuntimeStandalone,
    method: &str,
    args: I,
) -> O {
    call_view(runtime, &POOL_ACCOUNT_ID.into(), method, args)
}

pub fn pool_account(runtime: &mut RuntimeStandalone) -> Account {
    runtime.view_account(&POOL_ACCOUNT_ID.into()).unwrap()
}

fn call_view<I: ToString, O: DeserializeOwned>(
    runtime: &mut RuntimeStandalone,
    account_id: &AccountId,
    method: &str,
    args: I,
) -> O {
    let args = args.to_string();
    let result = runtime
        .view_method_call(account_id, method, args.as_bytes())
        .unwrap()
        .0;
    let output: O = serde_json::from_reader(result.as_slice()).unwrap();
    output
}

'''
'''--- state-cleanup/Cargo.toml ---
[package]
name = "state-cleanup"
version = "0.1.0"
authors = ["Near Inc <hello@near.org>"]
edition = "2018"
publish = false

[lib]
crate-type = ["cdylib"]

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "s"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[dependencies]
near-sdk = "3.1.0"

'''
'''--- state-cleanup/README.md ---
# State Cleanup contract

This contract has been designed to clear account without deleting it.

Deploy this contract into the account that already has another contract deployed to it.
This contract on call `clean` will remove any items of the state specified (keys should be specified in base64).

Usage example to remove "STATE" item:

```bash
near deploy l.testmewell.testnet --wasmFile=res/state_cleanup.wasm
near call l.testmewell.testnet clean '{"keys": ["U1RBVEU="]}' --accountId testmewell.testnet
```

To check which keys to remove and later check that everything has been removed use this command:
```
near view-state l.testmewell.testnet --finality final
```

'''
'''--- state-cleanup/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/state_cleanup.wasm ./res/

'''
'''--- state-cleanup/src/lib.rs ---
use near_sdk::base64;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::serde_json;
use near_sdk::{env, near_bindgen};

#[allow(dead_code)]
#[near_bindgen]
struct Contract {}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
struct Args {
    pub keys: Vec<String>,
}

#[no_mangle]
pub extern "C" fn clean() {
    env::setup_panic_hook();
    env::set_blockchain_interface(Box::new(near_blockchain::NearBlockchain {}));

    let input = env::input().unwrap();
    let args: Args = serde_json::from_slice(&input).unwrap();
    for key in args.keys.iter() {
        env::storage_remove(&base64::decode(key).unwrap());
    }
}

'''
'''--- voting/Cargo.toml ---
[package]
name = "voting-contract"
version = "0.2.0"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "2.0.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "s"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[workspace]
members = []

'''
'''--- voting/README.md ---
# Voting Contract

The purpose of this contract is solely for validators to vote on whether to unlock
token transfer. Validators can call `vote` to vote for yes with the amount of stake they wish
to put on the vote. If there are more than 2/3 of the stake at any given moment voting for yes, the voting is done.
After the voting is finished, no one can further modify the contract.

'''
'''--- voting/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/voting_contract.wasm ./res/

'''
'''--- voting/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::{U128, U64};
use near_sdk::{env, near_bindgen, AccountId, Balance, EpochHeight};
use std::collections::HashMap;

#[global_allocator]
static ALLOC: near_sdk::wee_alloc::WeeAlloc = near_sdk::wee_alloc::WeeAlloc::INIT;

type WrappedTimestamp = U64;

/// Voting contract for unlocking transfers. Once the majority of the stake holders agree to
/// unlock transfer, the time will be recorded and the voting ends.
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct VotingContract {
    /// How much each validator votes
    votes: HashMap<AccountId, Balance>,
    /// Total voted balance so far.
    total_voted_stake: Balance,
    /// When the voting ended. `None` means the poll is still open.
    result: Option<WrappedTimestamp>,
    /// Epoch height when the contract is touched last time.
    last_epoch_height: EpochHeight,
}

impl Default for VotingContract {
    fn default() -> Self {
        env::panic(b"Voting contract should be initialized before usage")
    }
}

#[near_bindgen]
impl VotingContract {
    #[init]
    pub fn new() -> Self {
        assert!(!env::state_exists(), "The contract is already initialized");
        VotingContract {
            votes: HashMap::new(),
            total_voted_stake: 0,
            result: None,
            last_epoch_height: 0,
        }
    }

    /// Ping to update the votes according to current stake of validators.
    pub fn ping(&mut self) {
        assert!(self.result.is_none(), "Voting has already ended");
        let cur_epoch_height = env::epoch_height();
        if cur_epoch_height != self.last_epoch_height {
            let votes = std::mem::take(&mut self.votes);
            self.total_voted_stake = 0;
            for (account_id, _) in votes {
                let account_current_stake = env::validator_stake(&account_id);
                self.total_voted_stake += account_current_stake;
                if account_current_stake > 0 {
                    self.votes.insert(account_id, account_current_stake);
                }
            }
            self.check_result();
            self.last_epoch_height = cur_epoch_height;
        }
    }

    /// Check whether the voting has ended.
    fn check_result(&mut self) {
        assert!(
            self.result.is_none(),
            "check result is called after result is already set"
        );
        let total_stake = env::validator_total_stake();
        if self.total_voted_stake > 2 * total_stake / 3 {
            self.result = Some(U64::from(env::block_timestamp()));
        }
    }

    /// Method for validators to vote or withdraw the vote.
    /// Votes for if `is_vote` is true, or withdraws the vote if `is_vote` is false.
    pub fn vote(&mut self, is_vote: bool) {
        self.ping();
        if self.result.is_some() {
            return;
        }
        let account_id = env::predecessor_account_id();
        let account_stake = if is_vote {
            let stake = env::validator_stake(&account_id);
            assert!(stake > 0, "{} is not a validator", account_id);
            stake
        } else {
            0
        };
        let voted_stake = self.votes.remove(&account_id).unwrap_or_default();
        assert!(
            voted_stake <= self.total_voted_stake,
            "invariant: voted stake {} is more than total voted stake {}",
            voted_stake,
            self.total_voted_stake
        );
        self.total_voted_stake = self.total_voted_stake + account_stake - voted_stake;
        if account_stake > 0 {
            self.votes.insert(account_id, account_stake);
            self.check_result();
        }
    }

    /// Get the timestamp of when the voting finishes. `None` means the voting hasn't ended yet.
    pub fn get_result(&self) -> Option<WrappedTimestamp> {
        self.result.clone()
    }

    /// Returns current a pair of `total_voted_stake` and the total stake.
    /// Note: as a view method, it doesn't recompute the active stake. May need to call `ping` to
    /// update the active stake.
    pub fn get_total_voted_stake(&self) -> (U128, U128) {
        (
            self.total_voted_stake.into(),
            env::validator_total_stake().into(),
        )
    }

    /// Returns all active votes.
    /// Note: as a view method, it doesn't recompute the active stake. May need to call `ping` to
    /// update the active stake.
    pub fn get_votes(&self) -> HashMap<AccountId, U128> {
        self.votes
            .iter()
            .map(|(account_id, stake)| (account_id.clone(), (*stake).into()))
            .collect()
    }
}

#[cfg(not(target_arch = "wasm32"))]
#[cfg(test)]
mod tests {
    use super::*;
    use near_sdk::MockedBlockchain;
    use near_sdk::{testing_env, VMContext};
    use std::collections::HashMap;
    use std::iter::FromIterator;

    fn get_context(predecessor_account_id: AccountId) -> VMContext {
        get_context_with_epoch_height(predecessor_account_id, 0)
    }

    fn get_context_with_epoch_height(
        predecessor_account_id: AccountId,
        epoch_height: EpochHeight,
    ) -> VMContext {
        VMContext {
            current_account_id: "alice_near".to_string(),
            signer_account_id: "bob_near".to_string(),
            signer_account_pk: vec![0, 1, 2],
            predecessor_account_id,
            input: vec![],
            block_index: 0,
            block_timestamp: 0,
            account_balance: 0,
            account_locked_balance: 0,
            storage_usage: 1000,
            attached_deposit: 0,
            prepaid_gas: 2 * 10u64.pow(14),
            random_seed: vec![0, 1, 2],
            is_view: false,
            output_data_receivers: vec![],
            epoch_height,
        }
    }

    #[test]
    #[should_panic(expected = "is not a validator")]
    fn test_nonvalidator_cannot_vote() {
        let context = get_context("bob.near".to_string());
        let validators = HashMap::from_iter(
            vec![
                ("alice_near".to_string(), 100),
                ("bob_near".to_string(), 100),
            ]
            .into_iter(),
        );
        testing_env!(context, Default::default(), Default::default(), validators);
        let mut contract = VotingContract::new();
        contract.vote(true);
    }

    #[test]
    #[should_panic(expected = "Voting has already ended")]
    fn test_vote_again_after_voting_ends() {
        let context = get_context("alice.near".to_string());
        let validators = HashMap::from_iter(vec![("alice.near".to_string(), 100)].into_iter());
        testing_env!(context, Default::default(), Default::default(), validators);
        let mut contract = VotingContract::new();
        contract.vote(true);
        assert!(contract.result.is_some());
        contract.vote(true);
    }

    #[test]
    fn test_voting_simple() {
        let context = get_context("test0".to_string());
        let validators = (0..10)
            .map(|i| (format!("test{}", i), 10))
            .collect::<HashMap<_, _>>();
        testing_env!(
            context,
            Default::default(),
            Default::default(),
            validators.clone()
        );
        let mut contract = VotingContract::new();

        for i in 0..7 {
            let mut context = get_context(format!("test{}", i));
            testing_env!(
                context.clone(),
                Default::default(),
                Default::default(),
                validators.clone()
            );
            contract.vote(true);
            context.is_view = true;
            testing_env!(
                context,
                Default::default(),
                Default::default(),
                validators.clone()
            );
            assert_eq!(
                contract.get_total_voted_stake(),
                (U128::from(10 * (i + 1)), U128::from(100))
            );
            assert_eq!(
                contract.get_votes(),
                (0..=i)
                    .map(|i| (format!("test{}", i), U128::from(10)))
                    .collect::<HashMap<_, _>>()
            );
            assert_eq!(contract.votes.len() as u128, i + 1);
            if i < 6 {
                assert!(contract.result.is_none());
            } else {
                assert!(contract.result.is_some());
            }
        }
    }

    #[test]
    fn test_voting_with_epoch_change() {
        let validators = (0..10)
            .map(|i| (format!("test{}", i), 10))
            .collect::<HashMap<_, _>>();
        let context = get_context("test0".to_string());
        testing_env!(
            context,
            Default::default(),
            Default::default(),
            validators.clone()
        );
        let mut contract = VotingContract::new();

        for i in 0..7 {
            let context = get_context_with_epoch_height(format!("test{}", i), i);
            testing_env!(
                context,
                Default::default(),
                Default::default(),
                validators.clone()
            );
            contract.vote(true);
            assert_eq!(contract.votes.len() as u64, i + 1);
            if i < 6 {
                assert!(contract.result.is_none());
            } else {
                assert!(contract.result.is_some());
            }
        }
    }

    #[test]
    fn test_validator_stake_change() {
        let mut validators = HashMap::from_iter(vec![
            ("test1".to_string(), 40),
            ("test2".to_string(), 10),
            ("test3".to_string(), 10),
        ]);
        let context = get_context_with_epoch_height("test1".to_string(), 1);
        testing_env!(
            context,
            Default::default(),
            Default::default(),
            validators.clone()
        );

        let mut contract = VotingContract::new();
        contract.vote(true);
        validators.insert("test1".to_string(), 50);
        let context = get_context_with_epoch_height("test2".to_string(), 2);
        testing_env!(
            context,
            Default::default(),
            Default::default(),
            validators.clone()
        );
        contract.ping();
        assert!(contract.result.is_some());
    }

    #[test]
    fn test_withdraw_votes() {
        let validators =
            HashMap::from_iter(vec![("test1".to_string(), 10), ("test2".to_string(), 10)]);
        let context = get_context_with_epoch_height("test1".to_string(), 1);
        testing_env!(
            context,
            Default::default(),
            Default::default(),
            validators.clone()
        );
        let mut contract = VotingContract::new();
        contract.vote(true);
        assert_eq!(contract.votes.len(), 1);
        let context = get_context_with_epoch_height("test1".to_string(), 2);
        testing_env!(
            context,
            Default::default(),
            Default::default(),
            validators.clone()
        );
        contract.vote(false);
        assert!(contract.votes.is_empty());
    }

    #[test]
    fn test_validator_kick_out() {
        let mut validators = HashMap::from_iter(vec![
            ("test1".to_string(), 40),
            ("test2".to_string(), 10),
            ("test3".to_string(), 10),
        ]);
        let context = get_context_with_epoch_height("test1".to_string(), 1);
        testing_env!(
            context,
            Default::default(),
            Default::default(),
            validators.clone()
        );

        let mut contract = VotingContract::new();
        contract.vote(true);
        assert_eq!((contract.get_total_voted_stake().0).0, 40);
        validators.remove(&"test1".to_string());
        let context = get_context_with_epoch_height("test2".to_string(), 2);
        testing_env!(
            context,
            Default::default(),
            Default::default(),
            validators.clone()
        );
        contract.ping();
        assert_eq!((contract.get_total_voted_stake().0).0, 0);
    }
}

'''
'''--- w-near/Cargo.toml ---
[package]
name = "w_near"
version = "1.0.0"
authors = ["Near Inc <hello@nearprotocol.com>", "Vincent <vincent@decentralisedengineeringltd.co.uk>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"
near-contract-standards = "3.1.0"

[dev-dependencies]
near-sdk-sim = "3.1.0"

[profile.release]
codegen-units=1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- w-near/README.md ---
# TBD

'''
'''--- w-near/build.sh ---
#!/bin/bash
set -e
cd "`dirname $0`"
RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/w_near.wasm ./res/

'''
'''--- w-near/src/legacy_storage.rs ---
use crate::*;

#[near_bindgen]
impl Contract {
    pub fn storage_minimum_balance(&self) -> U128 {
        self.ft.storage_balance_bounds().min
    }
}

'''
'''--- w-near/src/lib.rs ---
/*!
* wNear NEP-141 Token contract
*
* The aim of the contract is to enable the wrapping of the native NEAR token into a NEP-141 compatible token.
* It supports methods `near_deposit` and `near_withdraw` that wraps and unwraps NEAR tokens.
* They are effectively mint and burn underlying wNEAR tokens.
*
* lib.rs is the main entry point.
* w_near.rs contains interfaces for depositing and withdrawing
*/
use near_contract_standards::fungible_token::metadata::{
    FungibleTokenMetadata, FungibleTokenMetadataProvider, FT_METADATA_SPEC,
};
use near_contract_standards::fungible_token::FungibleToken;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::{ValidAccountId, U128};
// Needed by `impl_fungible_token_core` for old Rust.
#[allow(unused_imports)]
use near_sdk::env;
use near_sdk::{near_bindgen, AccountId, PanicOnDefault, PromiseOrValue};

mod legacy_storage;
mod w_near;

near_sdk::setup_alloc!();

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    pub ft: FungibleToken,
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new() -> Self {
        Self {
            ft: FungibleToken::new(b"a".to_vec()),
        }
    }
}

near_contract_standards::impl_fungible_token_core!(Contract, ft);
near_contract_standards::impl_fungible_token_storage!(Contract, ft);

#[near_bindgen]
impl FungibleTokenMetadataProvider for Contract {
    fn ft_metadata(&self) -> FungibleTokenMetadata {
        FungibleTokenMetadata {
            spec: FT_METADATA_SPEC.to_string(),
            name: String::from("Wrapped NEAR fungible token"),
            symbol: String::from("wNEAR"),
            icon: None,
            reference: None,
            reference_hash: None,
            decimals: 24,
        }
    }
}

'''
'''--- w-near/src/w_near.rs ---
use crate::*;
use near_sdk::json_types::U128;
use near_sdk::{assert_one_yocto, env, log, Promise};

#[near_bindgen]
impl Contract {
    /// Deposit NEAR to mint wNEAR tokens to the predecessor account in this contract.
    /// Requirements:
    /// * The predecessor account doesn't need to be registered.
    /// * Requires positive attached deposit.
    /// * If account is not registered will fail if attached deposit is below registration limit.
    #[payable]
    pub fn near_deposit(&mut self) {
        let mut amount = env::attached_deposit();
        assert!(amount > 0, "Requires positive attached deposit");
        let account_id = env::predecessor_account_id();
        if !self.ft.accounts.contains_key(&account_id) {
            // Not registered, register if enough $NEAR has been attached.
            // Subtract registration amount from the account balance.
            assert!(
                amount >= self.ft.storage_balance_bounds().min.0,
                "ERR_DEPOSIT_TOO_SMALL"
            );
            self.ft.internal_register_account(&account_id);
            amount -= self.ft.storage_balance_bounds().min.0;
        }
        self.ft.internal_deposit(&account_id, amount);
        log!("Deposit {} NEAR to {}", amount, account_id);
    }

    /// Withdraws wNEAR and send NEAR back to the predecessor account.
    /// Requirements:
    /// * The predecessor account should be registered.
    /// * `amount` must be a positive integer.
    /// * The predecessor account should have at least the `amount` of wNEAR tokens.
    /// * Requires attached deposit of exactly 1 yoctoNEAR.
    #[payable]
    pub fn near_withdraw(&mut self, amount: U128) -> Promise {
        assert_one_yocto();
        let account_id = env::predecessor_account_id();
        let amount = amount.into();
        self.ft.internal_withdraw(&account_id, amount);
        log!("Withdraw {} yoctoNEAR from {}", amount, account_id);
        // Transferring NEAR and refunding 1 yoctoNEAR.
        Promise::new(account_id).transfer(amount + 1)
    }
}

'''
'''--- w-near/tests/mod.rs ---
use near_sdk::json_types::U128;
use near_sdk::serde_json::json;
use near_sdk::Balance;
use near_sdk_sim::{
    call, deploy, init_simulator, to_yocto, view, ContractAccount, ExecutionResult, UserAccount,
    DEFAULT_GAS,
};
use w_near::ContractContract as Contract;

near_sdk_sim::lazy_static_include::lazy_static_include_bytes! {
    W_NEAR_WASM_BYTES => "res/w_near.wasm",
    LEGACY_W_NEAR_WASM_BYTES => "res/legacy_w_near.wasm",
}

const CONTRACT_ID: &str = "wrapnear";
const LEGACY_BYTE_COST: Balance = 10_000_000_000_000_000_000;

const STORAGE_BALANCE: Balance = 125 * LEGACY_BYTE_COST;

// Register the given `user` with Legacy wNEAR contract
fn legacy_register_user(user: &UserAccount) {
    user.call(
        CONTRACT_ID.to_string(),
        "storage_deposit",
        &json!({
            "account_id": user.valid_account_id()
        })
        .to_string()
        .into_bytes(),
        DEFAULT_GAS / 2,
        125 * LEGACY_BYTE_COST, // attached deposit
    )
    .assert_success();
}

fn wrap_near(user: &UserAccount, amount: Balance) -> ExecutionResult {
    user.call(
        CONTRACT_ID.to_string(),
        "near_deposit",
        &json!({
            "account_id": user.valid_account_id()
        })
        .to_string()
        .into_bytes(),
        DEFAULT_GAS / 2,
        amount, // attached deposit
    )
}

fn deploy_legacy() -> (UserAccount, ContractAccount<Contract>) {
    let root = init_simulator(None);
    let w_near = deploy!(
        contract: Contract,
        contract_id: CONTRACT_ID.to_string(),
        bytes: &LEGACY_W_NEAR_WASM_BYTES,
        signer_account: root,
        init_method: new()
    );
    (root, w_near)
}

fn deploy_w_near() -> (UserAccount, ContractAccount<Contract>) {
    let root = init_simulator(None);
    let w_near = deploy!(
        contract: Contract,
        contract_id: CONTRACT_ID.to_string(),
        bytes: &W_NEAR_WASM_BYTES,
        signer_account: root,
        init_method: new()
    );
    (root, w_near)
}

#[test]
pub fn test_upgrade() {
    let (root, w_near) = deploy_legacy();

    let legacy_storage_minimum_balance: U128 =
        view!(w_near.storage_minimum_balance()).unwrap_json();
    assert_eq!(legacy_storage_minimum_balance.0, STORAGE_BALANCE);

    let alice = root.create_user("alice".to_string(), to_yocto("100"));
    legacy_register_user(&alice);

    wrap_near(&alice, to_yocto("10")).assert_success();

    let alice_balance: U128 = view!(w_near.ft_balance_of(alice.valid_account_id())).unwrap_json();
    assert_eq!(alice_balance.0, to_yocto("10"));

    w_near
        .user_account
        .create_transaction(CONTRACT_ID.to_string())
        .deploy_contract(W_NEAR_WASM_BYTES.to_vec())
        .submit()
        .assert_success();

    let storage_minimum_balance: U128 = view!(w_near.storage_minimum_balance()).unwrap_json();
    assert_eq!(storage_minimum_balance.0, STORAGE_BALANCE);

    let alice_balance: U128 = view!(w_near.ft_balance_of(alice.valid_account_id())).unwrap_json();
    assert_eq!(alice_balance.0, to_yocto("10"));

    let bob = root.create_user("bob".to_string(), to_yocto("100"));
    legacy_register_user(&bob);

    wrap_near(&bob, to_yocto("15")).assert_success();

    let bob_balance: U128 = view!(w_near.ft_balance_of(bob.valid_account_id())).unwrap_json();
    assert_eq!(bob_balance.0, to_yocto("15"));

    call!(
        alice,
        w_near.ft_transfer(bob.valid_account_id(), to_yocto("5").into(), None),
        deposit = 1
    )
    .assert_success();

    let bob_balance: U128 = view!(w_near.ft_balance_of(bob.valid_account_id())).unwrap_json();
    assert_eq!(bob_balance.0, to_yocto("20"));
}

#[test]
pub fn test_legacy_ft_transfer() {
    let (root, w_near) = deploy_legacy();

    let alice = root.create_user("alice".to_string(), to_yocto("100"));
    legacy_register_user(&alice);

    wrap_near(&alice, to_yocto("10")).assert_success();

    let alice_balance: U128 = view!(w_near.ft_balance_of(alice.valid_account_id())).unwrap_json();
    assert_eq!(alice_balance.0, to_yocto("10"));

    let bob = root.create_user("bob".to_string(), to_yocto("100"));
    legacy_register_user(&bob);

    call!(
        alice,
        w_near.ft_transfer(bob.valid_account_id(), to_yocto("5").into(), None),
        deposit = 1
    )
    .assert_success();

    let bob_balance: U128 = view!(w_near.ft_balance_of(bob.valid_account_id())).unwrap_json();
    assert_eq!(bob_balance.0, to_yocto("5"));
}

#[test]
pub fn test_ft_transfer() {
    let (root, w_near) = deploy_w_near();

    let alice = root.create_user("alice".to_string(), to_yocto("100"));
    legacy_register_user(&alice);

    wrap_near(&alice, to_yocto("10")).assert_success();

    let alice_balance: U128 = view!(w_near.ft_balance_of(alice.valid_account_id())).unwrap_json();
    assert_eq!(alice_balance.0, to_yocto("10"));

    let bob = root.create_user("bob".to_string(), to_yocto("100"));
    legacy_register_user(&bob);

    call!(
        alice,
        w_near.ft_transfer(bob.valid_account_id(), to_yocto("5").into(), None),
        deposit = 1
    )
    .assert_success();

    let bob_balance: U128 = view!(w_near.ft_balance_of(bob.valid_account_id())).unwrap_json();
    assert_eq!(bob_balance.0, to_yocto("5"));
}

#[test]
pub fn test_legacy_wrap_fail() {
    let (root, _w_near) = deploy_legacy();

    let alice = root.create_user("alice".to_string(), to_yocto("100"));

    let status = wrap_near(&alice, to_yocto("10"));
    assert!(!status.is_ok())
}

#[test]
pub fn test_wrap_without_storage_deposit() {
    let (root, w_near) = deploy_w_near();

    let alice = root.create_user("alice".to_string(), to_yocto("100"));

    wrap_near(&alice, to_yocto("10")).assert_success();

    let alice_balance: U128 = view!(w_near.ft_balance_of(alice.valid_account_id())).unwrap_json();
    assert_eq!(alice_balance.0, to_yocto("10") - STORAGE_BALANCE);
}

'''
'''--- whitelist/Cargo.toml ---
[package]
name = "whitelist"
version = "0.2.0"
authors = ["Near Inc <hello@near.org>"]
edition = "2018"
publish = false

[lib]
crate-type = ["cdylib", "rlib"]

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "s"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[dependencies]
near-sdk = "2.0.0"

'''
'''--- whitelist/README.md ---
# Whitelist contract for staking pools

The purpose of this contract is to maintain the whitelist of the staking pool contracts account IDs that are approved
by NEAR Foundation.

In order for the lockup contracts to be able delegate to a staking pool, the staking pool should faithfully implement the spec.
The staking pool should guarantee that the delegated tokens can not be lost or locked, such as the lockup contract should be
able to recover delegated tokens back to the lockup from a staking pool. In order to enforce this, only approved (whitelisted)
accounts of staking pool contracts can receive delegated tokens from lockup contracts.

If NEAR Foundation has to approve every single staking pool account it might lead to a bottleneck and centralization
To address this NEAR Foundation can whitelist the account IDs of staking pool factory contracts.

The whitelisted staking pool factory contract will be able to whitelist accounts of staking pool contracts.
A factory contract creates and initializes a staking pool contract in a secure and permissionless way.
This allows anyone on the network to be able to create a staking pool contract for themselves without needing approval from the NEAR
Foundation. This is important to maintain the decentralization of the decision making and network governance.

To be able to address mistakes, NEAR Foundation has the ability to remove staking pools and staking pool factories from the whitelists.

## Requirements and guarantees

- The account of the whitelist contract should not contain any access keys, to avoid it from being deleted.
- If the account runs out of tokens for storage, any account can fund it. In theory the gas rebates may cover the storage in the long term.
- `is_whitelisted` call doesn't panic, unless it's given insufficient amount of gas or the invalid account ID.
- The contract maintains two separate whitelists, one for staking pools and one for factories.

## API

The methods are split into Getters (view methods), the method that can be called by both an approved factory and the foundation,
and methods that can only be called by the foundation.

## Changelog

### `0.2.0`

- Internally updated to use `LockupSet` instead of `UnorderedSet`.

```rust
/// Initializes the contract with the given NEAR foundation account ID.
#[init]
pub fn new(foundation_account_id: AccountId) -> Self;

/***********/
/* Getters */
/***********/

/// Returns `true` if the given staking pool account ID is whitelisted.
pub fn is_whitelisted(&self, staking_pool_account_id: AccountId) -> bool;

/// Returns `true` if the given factory contract account ID is whitelisted.
pub fn is_factory_whitelisted(&self, factory_account_id: AccountId) -> bool;

/************************/
/* Factory + Foundation */
/************************/

/// Adds the given staking pool account ID to the whitelist.
/// Returns `true` if the staking pool was not in the whitelist before, `false` otherwise.
/// This method can be called either by the NEAR foundation or by a whitelisted factory.
pub fn add_staking_pool(&mut self, staking_pool_account_id: AccountId) -> bool;

/**************/
/* Foundation */
/**************/

/// Removes the given staking pool account ID from the whitelist.
/// Returns `true` if the staking pool was present in the whitelist before, `false` otherwise.
/// This method can only be called by the NEAR foundation.
pub fn remove_staking_pool(&mut self, staking_pool_account_id: AccountId) -> bool;

/// Adds the given staking pool factory contract account ID to the factory whitelist.
/// Returns `true` if the factory was not in the whitelist before, `false` otherwise.
/// This method can only be called by the NEAR foundation.
pub fn add_factory(&mut self, factory_account_id: AccountId) -> bool;

/// Removes the given staking pool factory account ID from the factory whitelist.
/// Returns `true` if the factory was present in the whitelist before, `false` otherwise.
/// This method can only be called by the NEAR foundation.
pub fn remove_factory(&mut self, factory_account_id: AccountId) -> bool;
```

'''
'''--- whitelist/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/whitelist.wasm ./res/

'''
'''--- whitelist/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LookupSet;
use near_sdk::{env, near_bindgen, AccountId};

#[global_allocator]
static ALLOC: near_sdk::wee_alloc::WeeAlloc = near_sdk::wee_alloc::WeeAlloc::INIT;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct WhitelistContract {
    /// The account ID of the NEAR Foundation. It allows to whitelist new staking pool accounts.
    /// It also allows to whitelist new Staking Pool Factories, which can whitelist staking pools.
    pub foundation_account_id: AccountId,

    /// The whitelisted account IDs of approved staking pool contracts.
    pub whitelist: LookupSet<AccountId>,

    /// The whitelist of staking pool factories. Any account from this list can whitelist staking
    /// pools.
    pub factory_whitelist: LookupSet<AccountId>,
}

impl Default for WhitelistContract {
    fn default() -> Self {
        env::panic(b"The contract should be initialized before usage")
    }
}

#[near_bindgen]
impl WhitelistContract {
    /// Initializes the contract with the given NEAR foundation account ID.
    #[init]
    pub fn new(foundation_account_id: AccountId) -> Self {
        assert!(!env::state_exists(), "Already initialized");
        assert!(
            env::is_valid_account_id(foundation_account_id.as_bytes()),
            "The NEAR Foundation account ID is invalid"
        );
        Self {
            foundation_account_id,
            whitelist: LookupSet::new(b"w".to_vec()),
            factory_whitelist: LookupSet::new(b"f".to_vec()),
        }
    }

    /***********/
    /* Getters */
    /***********/

    /// Returns `true` if the given staking pool account ID is whitelisted.
    pub fn is_whitelisted(&self, staking_pool_account_id: AccountId) -> bool {
        assert!(
            env::is_valid_account_id(staking_pool_account_id.as_bytes()),
            "The given account ID is invalid"
        );
        self.whitelist.contains(&staking_pool_account_id)
    }

    /// Returns `true` if the given factory contract account ID is whitelisted.
    pub fn is_factory_whitelisted(&self, factory_account_id: AccountId) -> bool {
        assert!(
            env::is_valid_account_id(factory_account_id.as_bytes()),
            "The given account ID is invalid"
        );
        self.factory_whitelist.contains(&factory_account_id)
    }

    /************************/
    /* Factory + Foundation */
    /************************/

    /// Adds the given staking pool account ID to the whitelist.
    /// Returns `true` if the staking pool was not in the whitelist before, `false` otherwise.
    /// This method can be called either by the NEAR foundation or by a whitelisted factory.
    pub fn add_staking_pool(&mut self, staking_pool_account_id: AccountId) -> bool {
        assert!(
            env::is_valid_account_id(staking_pool_account_id.as_bytes()),
            "The given account ID is invalid"
        );
        // Can only be called by a whitelisted factory or by the foundation.
        if !self
            .factory_whitelist
            .contains(&env::predecessor_account_id())
        {
            self.assert_called_by_foundation();
        }
        self.whitelist.insert(&staking_pool_account_id)
    }

    /**************/
    /* Foundation */
    /**************/

    /// Removes the given staking pool account ID from the whitelist.
    /// Returns `true` if the staking pool was present in the whitelist before, `false` otherwise.
    /// This method can only be called by the NEAR foundation.
    pub fn remove_staking_pool(&mut self, staking_pool_account_id: AccountId) -> bool {
        self.assert_called_by_foundation();
        assert!(
            env::is_valid_account_id(staking_pool_account_id.as_bytes()),
            "The given account ID is invalid"
        );
        self.whitelist.remove(&staking_pool_account_id)
    }

    /// Adds the given staking pool factory contract account ID to the factory whitelist.
    /// Returns `true` if the factory was not in the whitelist before, `false` otherwise.
    /// This method can only be called by the NEAR foundation.
    pub fn add_factory(&mut self, factory_account_id: AccountId) -> bool {
        assert!(
            env::is_valid_account_id(factory_account_id.as_bytes()),
            "The given account ID is invalid"
        );
        self.assert_called_by_foundation();
        self.factory_whitelist.insert(&factory_account_id)
    }

    /// Removes the given staking pool factory account ID from the factory whitelist.
    /// Returns `true` if the factory was present in the whitelist before, `false` otherwise.
    /// This method can only be called by the NEAR foundation.
    pub fn remove_factory(&mut self, factory_account_id: AccountId) -> bool {
        self.assert_called_by_foundation();
        assert!(
            env::is_valid_account_id(factory_account_id.as_bytes()),
            "The given account ID is invalid"
        );
        self.factory_whitelist.remove(&factory_account_id)
    }

    /************/
    /* Internal */
    /************/

    /// Internal method to verify the predecessor was the NEAR Foundation account ID.
    fn assert_called_by_foundation(&self) {
        assert_eq!(
            &env::predecessor_account_id(),
            &self.foundation_account_id,
            "Can only be called by NEAR Foundation"
        );
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use near_sdk::{testing_env, MockedBlockchain};

    mod test_utils;
    use test_utils::*;

    #[test]
    fn test_whitelist() {
        let mut context = VMContextBuilder::new()
            .current_account_id(account_whitelist())
            .predecessor_account_id(account_near())
            .finish();
        testing_env!(context.clone());

        let mut contract = WhitelistContract::new(account_near());

        // Check initial whitelist
        context.is_view = true;
        testing_env!(context.clone());
        assert!(!contract.is_whitelisted(account_pool()));

        // Adding to whitelist by foundation
        context.is_view = false;
        testing_env!(context.clone());
        assert!(contract.add_staking_pool(account_pool()));

        // Checking it's whitelisted now
        context.is_view = true;
        testing_env!(context.clone());
        assert!(contract.is_whitelisted(account_pool()));

        // Adding again. Should return false
        context.is_view = false;
        testing_env!(context.clone());
        assert!(!contract.add_staking_pool(account_pool()));

        // Checking the pool is still whitelisted
        context.is_view = true;
        testing_env!(context.clone());
        assert!(contract.is_whitelisted(account_pool()));

        // Removing from the whitelist.
        context.is_view = false;
        testing_env!(context.clone());
        assert!(contract.remove_staking_pool(account_pool()));

        // Checking the pool is not whitelisted anymore
        context.is_view = true;
        testing_env!(context.clone());
        assert!(!contract.is_whitelisted(account_pool()));

        // Removing again from the whitelist, should return false.
        context.is_view = false;
        testing_env!(context.clone());
        assert!(!contract.remove_staking_pool(account_pool()));

        // Checking the pool is still not whitelisted
        context.is_view = true;
        testing_env!(context.clone());
        assert!(!contract.is_whitelisted(account_pool()));

        // Adding again after it was removed. Should return true
        context.is_view = false;
        testing_env!(context.clone());
        assert!(contract.add_staking_pool(account_pool()));

        // Checking the pool is now whitelisted again
        context.is_view = true;
        testing_env!(context.clone());
        assert!(contract.is_whitelisted(account_pool()));
    }

    #[test]
    #[should_panic(expected = "Can only be called by NEAR Foundation")]
    fn test_factory_whitelist_fail() {
        let mut context = VMContextBuilder::new()
            .current_account_id(account_whitelist())
            .predecessor_account_id(account_near())
            .finish();
        testing_env!(context.clone());

        let mut contract = WhitelistContract::new(account_near());

        // Trying ot add to the whitelist by NOT whitelisted factory.
        context.is_view = false;
        context.predecessor_account_id = account_factory();
        testing_env!(context.clone());
        assert!(contract.add_staking_pool(account_pool()));
    }

    #[test]
    #[should_panic(expected = "Can only be called by NEAR Foundation")]
    fn test_trying_to_whitelist_factory() {
        let mut context = VMContextBuilder::new()
            .current_account_id(account_whitelist())
            .predecessor_account_id(account_near())
            .finish();
        testing_env!(context.clone());

        let mut contract = WhitelistContract::new(account_near());

        // Trying ot whitelist the factory not by the NEAR Foundation.
        context.is_view = false;
        context.predecessor_account_id = account_factory();
        testing_env!(context.clone());
        assert!(contract.add_factory(account_factory()));
    }

    #[test]
    #[should_panic(expected = "Can only be called by NEAR Foundation")]
    fn test_trying_to_remove_by_factory() {
        let mut context = VMContextBuilder::new()
            .current_account_id(account_whitelist())
            .predecessor_account_id(account_near())
            .finish();
        testing_env!(context.clone());

        let mut contract = WhitelistContract::new(account_near());

        // Adding factory
        context.is_view = false;
        testing_env!(context.clone());
        assert!(contract.add_factory(account_factory()));

        // Trying to remove the pool by the factory.
        context.predecessor_account_id = account_factory();
        testing_env!(context.clone());
        assert!(contract.remove_staking_pool(account_pool()));
    }

    #[test]
    fn test_whitelist_factory() {
        let mut context = VMContextBuilder::new()
            .current_account_id(account_whitelist())
            .predecessor_account_id(account_near())
            .finish();
        testing_env!(context.clone());

        let mut contract = WhitelistContract::new(account_near());

        // Check the factory is not whitelisted
        context.is_view = true;
        testing_env!(context.clone());
        assert!(!contract.is_factory_whitelisted(account_factory()));

        // Whitelisting factory
        context.is_view = false;
        testing_env!(context.clone());
        assert!(contract.add_factory(account_factory()));

        // Check the factory is whitelisted now
        context.is_view = true;
        testing_env!(context.clone());
        assert!(contract.is_factory_whitelisted(account_factory()));
        // Check the pool is not whitelisted
        assert!(!contract.is_whitelisted(account_pool()));

        // Adding to whitelist by foundation
        context.is_view = false;
        context.predecessor_account_id = account_factory();
        testing_env!(context.clone());
        assert!(contract.add_staking_pool(account_pool()));

        // Checking it's whitelisted now
        context.is_view = true;
        testing_env!(context.clone());
        assert!(contract.is_whitelisted(account_pool()));

        // Removing the pool from the whitelisted by the NEAR foundation.
        context.is_view = false;
        context.predecessor_account_id = account_near();
        testing_env!(context.clone());
        assert!(contract.remove_staking_pool(account_pool()));

        // Checking the pool is not whitelisted anymore
        context.is_view = true;
        testing_env!(context.clone());
        assert!(!contract.is_whitelisted(account_pool()));

        // Removing the factory
        context.is_view = false;
        testing_env!(context.clone());
        assert!(contract.remove_factory(account_factory()));

        // Check the factory is not whitelisted anymore
        context.is_view = true;
        testing_env!(context.clone());
        assert!(!contract.is_factory_whitelisted(account_factory()));
    }
}

'''
'''--- whitelist/src/tests/test_utils.rs ---
use near_sdk::{AccountId, VMContext};
use near_sdk::{Balance, BlockHeight, EpochHeight};

pub fn account_near() -> AccountId {
    "near".to_string()
}
pub fn account_whitelist() -> AccountId {
    "whitelist".to_string()
}
pub fn account_pool() -> AccountId {
    "pool".to_string()
}
pub fn account_factory() -> AccountId {
    "factory".to_string()
}

pub struct VMContextBuilder {
    context: VMContext,
}

impl VMContextBuilder {
    pub fn new() -> Self {
        Self {
            context: VMContext {
                current_account_id: "".to_string(),
                signer_account_id: "".to_string(),
                signer_account_pk: vec![0, 1, 2],
                predecessor_account_id: "".to_string(),
                input: vec![],
                epoch_height: 0,
                block_index: 0,
                block_timestamp: 0,
                account_balance: 0,
                account_locked_balance: 0,
                storage_usage: 10u64.pow(6),
                attached_deposit: 0,
                prepaid_gas: 10u64.pow(18),
                random_seed: vec![0, 1, 2],
                is_view: false,
                output_data_receivers: vec![],
            },
        }
    }

    #[allow(dead_code)]
    pub fn current_account_id(mut self, account_id: AccountId) -> Self {
        self.context.current_account_id = account_id;
        self
    }

    #[allow(dead_code)]
    pub fn signer_account_id(mut self, account_id: AccountId) -> Self {
        self.context.signer_account_id = account_id;
        self
    }

    #[allow(dead_code)]
    pub fn predecessor_account_id(mut self, account_id: AccountId) -> Self {
        self.context.predecessor_account_id = account_id;
        self
    }

    #[allow(dead_code)]
    pub fn block_index(mut self, block_index: BlockHeight) -> Self {
        self.context.block_index = block_index;
        self
    }

    #[allow(dead_code)]
    pub fn epoch_height(mut self, epoch_height: EpochHeight) -> Self {
        self.context.epoch_height = epoch_height;
        self
    }

    #[allow(dead_code)]
    pub fn attached_deposit(mut self, amount: Balance) -> Self {
        self.context.attached_deposit = amount;
        self
    }

    #[allow(dead_code)]
    pub fn account_balance(mut self, amount: Balance) -> Self {
        self.context.account_balance = amount;
        self
    }

    #[allow(dead_code)]
    pub fn account_locked_balance(mut self, amount: Balance) -> Self {
        self.context.account_locked_balance = amount;
        self
    }

    pub fn finish(self) -> VMContext {
        self.context
    }
}

'''