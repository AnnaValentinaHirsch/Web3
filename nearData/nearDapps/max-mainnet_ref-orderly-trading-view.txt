*GitHub Repository "max-mainnet/ref-orderly-trading-view"*

'''--- README.md ---
# REF <> ORDERLY

'''
'''--- package.json ---
{
  "name": "ref-orderly-test",
  "version": "0.1.0",
  "dependencies": {
    "@near-wallet-selector/core": "^7.0.0",
    "@near-wallet-selector/modal-ui": "^7.0.0",
    "@near-wallet-selector/my-near-wallet": "^7.0.0",
    "@near-wallet-selector/near-wallet": "^7.0.0",
    "@testing-library/jest-dom": "^5.16.5",
    "@testing-library/react": "^13.4.0",
    "@testing-library/user-event": "^14.4.3",
    "@types/bn.js": "^5.1.1",
    "@types/jest": "^28.1.8",
    "@types/node": "^18.11.9",
    "@types/react": "18.0.25",
    "@types/react-dom": "18.0.9",
    "autoprefixer": "^10.4.13",
    "big.js": "^6.1.1",
    "bs58": "^5.0.0",
    "elliptic": "^6.5.4",
    "keccak256": "^1.0.6",
    "lodash": "4.17.21",
    "mathjs": "^9.3.0",
    "moment": "^2.29.4",
    "near-api-js": "0.44.2",
    "postcss": "^8.4.20",
    "postcss-cli": "^9.1.0",
    "postcss-preset-env": "^7.8.3",
    "react": "^18.2.0",
    "react-circular-progressbar": "^2.1.0",
    "react-dom": "^18.2.0",
    "react-icons": "^4.7.1",
    "react-micro-modal": "^2.0.2",
    "react-modal": "^3.13.1",
    "react-router-dom": "^5.2.0",
    "react-scripts": "^5.0.1",
    "react-toastify": "^9.1.1",
    "react-tooltip": "^4.2.17",
    "react-use-websocket": "4.0.0",
    "socket.io-client": "^4.5.4",
    "tailwindcss": "^3.2.4",
    "typescript": "^4.9.4"
  },
  "devDependencies": {
    "@types/big.js": "^6.1.2",
    "@types/elliptic": "^6.4.14",
    "@types/lodash": "^4.14.191",
    "@types/react-copy-to-clipboard": "^5.0.4",
    "@types/react-modal": "^3.12.0",
    "@types/react-router-dom": "^5.1.7",
    "@types/react-toastify": "^4.1.0",
    "buffer": "^5.5.0",
    "process": "0.11.10",
    "react-copy-to-clipboard": "^5.1.0"
  },
  "scripts": {
    "start:testnet": "REACT_APP_NEAR_ENV=testnet NEAR_ENV=testnet react-scripts start",
    "start:pub-testnet": "REACT_APP_NEAR_ENV=pub-testnet NEAR_ENV=pub-testnet react-scripts start",
    "start:mainnet": "REACT_APP_NEAR_ENV=mainnet NEAR_ENV=mainnet react-scripts start",
    "build:testnet": "REACT_APP_NEAR_ENV=testnet NEAR_ENV=testnet react-scripts build",
    "build:mainnet": "REACT_APP_NEAR_ENV=mainnet react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": "react-app"
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}

'''
'''--- postcss.config.js ---
module.exports = {
  plugins: {
    tailwindcss: {},
    "postcss-preset-env": {},
  },
};

'''
'''--- public/index.html ---
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <!-- <script src="%PUBLIC_URL%/datafeeds/udf/dist/bundle.js"></script> -->
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta name="description" content="Web site created using create-react-app" />
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <link href="https://fonts.cdnfonts.com/css/gotham" rel="stylesheet" />

    <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
    <title>React App</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root" class="h-full"></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
  </body>
</html>

'''
'''--- public/manifest.json ---
{
  "short_name": "React App",
  "name": "Create React App Sample",
  "icons": [
    {
      "src": "favicon.ico",
      "sizes": "64x64 32x32 24x24 16x16",
      "type": "image/x-icon"
    },
    {
      "src": "logo192.png",
      "type": "image/png",
      "sizes": "192x192"
    },
    {
      "src": "logo512.png",
      "type": "image/png",
      "sizes": "512x512"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#000000",
  "background_color": "#ffffff"
}

'''
'''--- public/robots.txt ---
# https://www.robotstxt.org/robotstxt.html
User-agent: *

'''
'''--- src/App.css ---
@import url('https://fonts.cdnfonts.com/css/gotham');

.App {
  text-align: center;
  font-family: 'Gotham', sans-serif;
  font-weight: 400;
}

html {
  background: rgb(19, 33, 42);
  overflow: hidden;
}

::-webkit-scrollbar {
  width: 9px;
  /* height: 4px; */
  border-radius: 2px;
}

::-webkit-scrollbar-track {
  box-shadow: inset 0 0 6px rgba(0, 0, 0, 0);
  background: rgb(25, 34, 41);
  border-radius: 2px;
}

::-webkit-scrollbar-thumb {
  background: rgb(38, 46, 53);
  border-radius: 2px;
}

.App-header {
  display: flex;
  justify-content: center;
  align-items: center;
  padding: 10px 0;
  background-color: #222;
  color: #fff;
}

.App-tv-logo {
  height: 45px;
}

.App-react-logo {
  display: block;
  height: 62px;
}

.App-title {
  display: block;
  font-size: 1.5em;
}

.__react_component_tooltip::before,
.__react_component_tooltip::after {
  content: none !important;
}
.__react_component_tooltip {
  z-index: 99999;
}

.reactTip {
  border-radius: 0.375rem !important;
  padding: 0.44rem 0.75rem !important;
  min-width: 7rem !important;
  opacity: 1 !important;
}

th {
  font-weight: normal;
}

'''
'''--- src/components/AllOrders/state.ts ---
import React, { useState, useEffect } from 'react';
import { SymbolInfo } from '../../orderly/type';
import { getOrderlyConfig } from '../../config';

export function useAllSymbolInfo() {
  const [availableSymbols, setAvailableSymbols] = useState<SymbolInfo[]>();
  useEffect(() => {
    fetch(`${getOrderlyConfig().OFF_CHAIN_END_POINT}/v1/public/info`).then((res) => {
      res.json().then((data) => {
        setAvailableSymbols(data.data.rows);
      });
    });
  }, []);

  return availableSymbols;
}

'''
'''--- src/components/AssetModal/state.ts ---
import React, { useEffect, useState } from 'react';
import { TokenInfo, TokenMetadata } from '../../orderly/type';
import { useTokensBalances } from '../UserBoard/state';

export interface OrderAsset {
  near: string;
  'in-order': string;
  available: string;

  tokenMeta: TokenMetadata;
}

export function useOrderAssets(tokenInfo: TokenInfo[] | undefined) {
  const tokens = tokenInfo
    ? tokenInfo.map((t) => ({
        id: t.token_account_id,
        decimals: t.decimals,
      }))
    : [];

  const balances = useTokensBalances(tokens, tokenInfo);

  const displayBalances = balances.map((b, i) => {
    return {
      near: b.wallet_balance,
      'in-order': Math.abs(b['in-order']).toString(),
      available: b.holding.toString(),
      tokenMeta: b.meta,
    };
  });

  return displayBalances;
}

'''
'''--- src/components/ChartHeader/state.ts ---
import React, { useState, useEffect } from 'react';
import { TokenInfo, TokenMetadata } from '../../orderly/type';
import { getFTmetadata } from '../../near';

export function useTokenMetaFromSymbol(symbol: string, tokenInfo: TokenInfo[] | undefined) {
  const [tokenMetadata, setTokenMetadata] = useState<TokenMetadata>();

  useEffect(() => {
    if (!symbol || !tokenInfo) return;

    const token = tokenInfo && tokenInfo.find((t) => t.token === symbol);

    if (!token?.token_account_id) return;

    getFTmetadata(token.token_account_id).then((t) => {
      setTokenMetadata({
        ...t,
        ...token,
      });
    });
  }, [symbol, tokenInfo]);

  return tokenMetadata;
}

export function useBatchTokenMetaFromSymbols(symbols: string[] | null, tokenInfo: TokenInfo[] | undefined) {
  const [tokenMetadata, setTokenMetadata] = useState<TokenMetadata[]>([]);

  useEffect(() => {
    if (!symbols || !tokenInfo) return;

    const tokens = tokenInfo && tokenInfo.filter((t) => symbols.includes(t.token));

    if (!tokens) return;

    Promise.all(
      tokens.map((t, i) =>
        getFTmetadata(t.token_account_id).then((meta) => {
          return {
            ...meta,
            ...t,
            symbol: tokens[i].token,
          };
        })
      )
    ).then((res) => {
      setTokenMetadata(res);
    });
  }, [symbols?.join('|'), tokenInfo]);

  return tokenMetadata.reduce((acc, cur) => {
    if (cur) {
      acc[cur.symbol] = cur;
    }
    return acc;
  }, {} as { [key: string]: TokenMetadata });
}

'''
'''--- src/components/UserBoard/state.ts ---
import React, { useEffect, useState } from 'react';
import { nearMetadata, getFTmetadata, ftGetBalance } from '../../near';
import { toReadableNumber } from '../../orderly/utils';
import { Holding, TokenInfo, TokenMetadata } from '../../orderly/type';
import { getCurrentHolding } from '../../orderly/off-chain-api';
import { useWalletSelectorWindow } from '../../WalletSelectorContext';

export function useTokenBalance(tokenId: string | undefined) {
  console.log('tokenId: ', tokenId);
  const [tokenMeta, setTokenMeta] = useState<TokenMetadata>();
  const [walletBalance, setWalletBalance] = useState<string>('');

  useEffect(() => {
    if (!tokenId) return;

    getFTmetadata(tokenId).then((meta) => {
      setTokenMeta(meta);
    });
  }, [tokenId]);

  useEffect(() => {
    if (!tokenId || !tokenMeta) return;
    ftGetBalance(tokenMeta?.id).then((balance) => {
      console.log('token meta', tokenMeta, tokenId);

      setWalletBalance(toReadableNumber(tokenMeta.decimals, balance));
    });
  }, [tokenId, tokenMeta?.id]);

  return !tokenMeta || !tokenId ? '0' : walletBalance;
}

interface TokenWithDecimals {
  id: string;
  decimals: number;
}

interface BalanceType {
  meta: TokenMetadata;
  holding: number;
  wallet_balance: string;
  id: string;
  name: string;
  'in-order': number;
}

export function useTokensBalances(tokens: TokenWithDecimals[] | undefined, tokenInfo: TokenInfo[] | undefined) {
  const [showbalances, setShowBalances] = useState<BalanceType[]>([]);

  const { accountId } = useWalletSelectorWindow();

  const getBalanceAndMeta = async (token: TokenWithDecimals) => {
    const balance = await ftGetBalance(token.id).then((balance) => {
      return toReadableNumber(token.decimals, balance);
    });

    const meta = await getFTmetadata(token.id);

    return {
      balance,
      meta,
    };
  };

  useEffect(() => {
    if (!tokens || !tokenInfo || !accountId) return;

    Promise.all(
      tokenInfo.map((t) =>
        getBalanceAndMeta({
          id: t.token_account_id,
          decimals: t.decimals,
        })
      )
    )
      .then((balances) => {
        const showbalances = balances.map((b, i) => {
          const wallet_balance = b.balance;

          return {
            meta: b.meta,
            wallet_balance,
            id: tokenInfo[i].token_account_id,
            name: tokenInfo[i].token,
          };
        });

        return showbalances;
      })
      .then(async (res) => {
        const response = await getCurrentHolding({ accountId });

        const holdings = response?.data?.holding as Holding[];

        const resMap = res.reduce(
          (acc, cur) => {
            const id = cur.id;

            const holding = holdings?.find((h: Holding) => h.token === cur.name);
            const displayHolding = holding ? holding.holding + holding.pending_short : 0;

            acc[id] = {
              ...cur,
              holding: displayHolding,
              'in-order': holding?.pending_short || 0,
            };
            return acc;
          },
          {} as {
            [key: string]: BalanceType;
          }
        );

        setShowBalances(Object.values(resMap));
      });
  }, [tokens?.map((t) => t.id).join('|'), tokenInfo, accountId]);

  return showbalances;
}

'''
'''--- src/config.ts ---
// @ts-nocheck

export function getExtendConfig(env: string = process.env.NEAR_ENV || process.env.REACT_APP_NEAR_ENV) {
  switch (env) {
    case 'production':
    case 'mainnet':
      return {
        RPC_LIST: {
          defaultRpc: {
            url: 'https://near-testnet.infura.io/v3/388c72223585424086eea3872bb0ba2c',
            simpleName: 'official rpc',
          },
          publicRpc: {
            url: 'https://public-rpc.blockpi.io/http/near',
            simpleName: 'blockpi rpc',
          },
          // infuraRpc: {
          //   url: 'https://near-mainnet.infura.io/v3/391d915322284599936f0ee962399dc1',
          //   simpleName: 'infura rpc',
          // },
          ankrRpc: {
            url: 'https://rpc.ankr.com/near',
            simpleName: 'ankr rpc',
          },
        },
        pool_protocol: 'indexer',
      };
    case 'development':
    case 'pub-testnet':
      return {
        RPC_LIST: {
          defaultRpc: {
            url: 'https://rpc.testnet.near.org',
            simpleName: 'official rpc',
          },
          publicRpc: {
            url: 'https://public-rpc.blockpi.io/http/near-testnet',
            simpleName: 'blockpi rpc',
          },
        },
        pool_protocol: 'indexer',
      };
    case 'testnet':
      return {
        RPC_LIST: {
          defaultRpc: {
            url: 'https://near-testnet.infura.io/v3/388c72223585424086eea3872bb0ba2c',
            simpleName: 'official rpc',
          },
          publicRpc: {
            url: 'https://public-rpc.blockpi.io/http/near-testnet',
            simpleName: 'blockpi rpc',
          },
        },
        pool_protocol: 'indexer',
      };
    default:
      return {
        RPC_LIST: {
          defaultRpc: {
            url: 'https://rpc.mainnet.near.org',
            simpleName: 'official rpc',
          },
          publicRpc: {
            url: 'https://public-rpc.blockpi.io/http/near',
            simpleName: 'blockpi rpc',
          },
          // infuraRpc: {
          //   url: 'https://near-mainnet.infura.io/v3/391d915322284599936f0ee962399dc1',
          //   simpleName: 'infura rpc',
          // },
          ankrRpc: {
            url: 'https://rpc.ankr.com/near',
            simpleName: 'ankr rpc',
          },
        },
        pool_protocol: 'indexer',
      };
  }
}
export function getCustomConfig() {
  let customRpcMapStr;
  try {
    customRpcMapStr = window.localStorage.getItem('customRpcList');
  } catch (error) {}

  let customRpcMap = {};
  if (customRpcMapStr) {
    try {
      customRpcMap = JSON.parse(customRpcMapStr);
    } catch (error) {}
  }
  return customRpcMap;
}
export default function getConfig(env: string = process.env.NEAR_ENV || process.env.REACT_APP_NEAR_ENV) {
  console.log('env: ', env, process.env.NEAR_ENV, process.env.REACT_APP_NEAR_ENV);

  const RPC_LIST_system = getExtendConfig().RPC_LIST;
  const RPC_LIST_custom = getCustomConfig();
  const RPC_LIST = Object.assign(RPC_LIST_system, RPC_LIST_custom);
  let endPoint = 'defaultRpc';
  try {
    endPoint = window.localStorage.getItem('endPoint') || endPoint;
    if (!RPC_LIST[endPoint]) {
      endPoint = 'defaultRpc';
      localStorage.removeItem('endPoint');
    }
  } catch (error) {}
  switch (env) {
    case 'production':
    case 'mainnet':
      return {
        networkId: 'mainnet',
        nodeUrl: RPC_LIST[endPoint].url,
        walletUrl: 'https://wallet.near.org',
        myNearWalletUrl: 'https://app.mynearwallet.com/',

        helperUrl: 'https://api.kitwallet.app',
        explorerUrl: 'https://nearblocks.io',
        indexerUrl: 'https://mainnet-indexer.ref-finance.com',
        sodakiApiUrl: 'https://api.stats.ref.finance/api',
        blackList: process.env.FARM_BLACK_LIST || ['1371#3', '2769#2'],
        REF_FI_CONTRACT_ID: process.env.REF_FI_CONTRACT_ID || 'v2.ref-finance.near',
        WRAP_NEAR_CONTRACT_ID: process.env.WRAP_NEAR_CONTRACT_ID || 'wrap.near',
        REF_ADBOARD_CONTRACT_ID: 'ref-adboard.near',
        REF_FARM_CONTRACT_ID: process.env.REF_FARM_CONTRACT_ID || 'v2.ref-farming.near',
        REF_TOKEN_ID: 'token.v2.ref-finance.near',
        XREF_TOKEN_ID: 'xtoken.ref-finance.near',
        REF_AIRDROP_CONTRACT_ID: 's01.ref-airdrop.near',
        TOP_POOLS_TOKEN_REFRESH_INTERVAL: process.env.POOL_TOKEN_REFRESH_INTERVAL || 60,
        POOL_TOKEN_REFRESH_INTERVAL: process.env.POOL_TOKEN_REFRESH_INTERVAL || 20,
        STABLE_POOL_USN_ID: process.env.STABLE_POOL_USN_ID || 3020,
        STABLE_TOKEN_USN_IDS: ['usn', 'dac17f958d2ee523a2206206994597c13d831ec7.factory.bridge.near'],
        STABLE_TOKEN_USN_INDEX: {
          usn: 0,
          'dac17f958d2ee523a2206206994597c13d831ec7.factory.bridge.near': 1,
        },
        STABLE_POOL_ID: process.env.STABLE_POOL_ID || 1910,
        STABLE_POOL_IDS: process.env.STABLE_POOL_IDS || ['1910', '3020', '3364', '3433'],
        STABLE_TOKEN_IDS: [
          'dac17f958d2ee523a2206206994597c13d831ec7.factory.bridge.near',
          'a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48.factory.bridge.near',
          '6b175474e89094c44da98b954eedeac495271d0f.factory.bridge.near',
        ],
        STABLE_TOKEN_INDEX: {
          'dac17f958d2ee523a2206206994597c13d831ec7.factory.bridge.near': 0,
          'a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48.factory.bridge.near': 1,
          '6b175474e89094c44da98b954eedeac495271d0f.factory.bridge.near': 2,
        },
        USN_ID: 'usn',
        TOTAL_PLATFORM_FEE_REVENUE: process.env.TOTAL_PLATFORM_FEE_REVENUE || '987635.62',
        CUMULATIVE_REF_BUYBACK: process.env.CUMULATIVE_REF_BUYBACK || '1308109.404',
        BLACKLIST_POOL_IDS: ['3689', '3699'],
        FARM_LOCK_SWITCH: process.env.FARM_LOCK_SWITCH || 0,
        VotingGauge: ['10%', '10%'],
        REF_FARM_BOOST_CONTRACT_ID: process.env.REF_FARM_BOOST_CONTRACT_ID || 'boostfarm.ref-labs.near',
        FARM_BLACK_LIST_V2: process.env.FARM_BLACK_LIST_V2 || ['3612'],
        boostBlackList: process.env.FARM__BOOST_BLACK_LIST || ['3699#0', '3612#0', '3612#1'],
        ORDERLY_ASSET_MANAGER: 'asset-manager.orderly-network.near',
      };
    case 'pub-testnet':
      return {
        networkId: 'testnet',
        nodeUrl: RPC_LIST[endPoint].url,
        walletUrl: 'https://wallet.testnet.near.org',
        myNearWalletUrl: 'https://testnet.mynearwallet.com/',
        helperUrl: 'https://testnet-api.kitwallet.app',
        explorerUrl: 'https://testnet.nearblocks.io',
        indexerUrl: 'https://testnet-indexer.ref-finance.com',
        sodakiApiUrl: 'https://api.stats.ref.finance/api',
        blackList: process.env.FARM_BLACK_LIST || ['1371#3'],
        REF_FI_CONTRACT_ID: process.env.REF_FI_CONTRACT_ID || 'ref-finance-101.testnet',
        WRAP_NEAR_CONTRACT_ID: process.env.WRAP_NEAR_CONTRACT_ID || 'wrap.testnet',
        REF_ADBOARD_CONTRACT_ID: 'ref-adboard.near',
        REF_FARM_CONTRACT_ID: process.env.REF_FARM_CONTRACT_ID || 'v2.ref-farming.testnet',
        REF_TOKEN_ID: 'ref.fakes.testnet',
        XREF_TOKEN_ID: 'xref.ref-finance.testnet',
        REF_VE_CONTRACT_ID: 'v010.refve.testnet',
        REF_AIRDROP_CONTRACT_ID: 'locker002.ref-dev.testnet',
        TOP_POOLS_TOKEN_REFRESH_INTERVAL: process.env.POOL_TOKEN_REFRESH_INTERVAL || 60,
        POOL_TOKEN_REFRESH_INTERVAL: process.env.POOL_TOKEN_REFRESH_INTERVAL || 20,
        STABLE_POOL_ID: process.env.STABLE_POOL_ID || 218,
        STABLE_POOL_IDS: process.env.STABLE_POOL_IDS || ['218', '356', '456', '494'],
        USN_ID: 'usdn.testnet',
        STABLE_POOL_USN_ID: process.env.STABLE_POOL_USN_ID || 356,
        STABLE_TOKEN_IDS: ['usdt.fakes.testnet', 'usdc.fakes.testnet', 'dai.fakes.testnet'],
        STABLE_TOKEN_USN_IDS: ['usdn.testnet', 'usdt.fakes.testnet'],
        STABLE_TOKEN_USN_INDEX: {
          'usdn.testnet': 0,
          'usdt.fakes.testnet': 1,
        },
        STABLE_TOKEN_INDEX: {
          'usdt.fakes.testnet': 0,
          'usdc.fakes.testnet': 1,
          'dai.fakes.testnet': 2,
        },
        TOTAL_PLATFORM_FEE_REVENUE: process.env.TOTAL_PLATFORM_FEE_REVENUE || '987635.62',
        CUMULATIVE_REF_BUYBACK: process.env.CUMULATIVE_REF_BUYBACK || '1308109.404',
        BLACKLIST_POOL_IDS: ['1752', '1760'],
        REF_FARM_BOOST_CONTRACT_ID: process.env.REF_FARM_BOOST_CONTRACT_ID || 'boostfarm.ref-finance.testnet',
        FARM_LOCK_SWITCH: process.env.FARM_LOCK_SWITCH || 0,
        VotingGauge: ['10%', '10%'],
        kitWalletOn: true,
        REF_UNI_V3_SWAP_CONTRACT_ID: process.env.REF_UNI_V3_SWAP_CONTRACT_ID || 'dcl.ref-dev.testnet',
        FARM_BLACK_LIST_V2: process.env.FARM_BLACK_LIST_V2 || ['571'],
        boostBlackList: process.env.FARM__BOOST_BLACK_LIST || ['1760#0', '1760#1'],
        ORDERLY_ASSET_MANAGER: 'asset-manager.orderly.testnet',
      };
    case 'testnet':
      return {
        networkId: 'testnet',
        nodeUrl: RPC_LIST[endPoint].url,
        walletUrl: 'https://wallet.testnet.near.org',
        myNearWalletUrl: 'https://testnet.mynearwallet.com/',
        helperUrl: 'https://testnet-api.kitwallet.app',
        explorerUrl: 'https://testnet.nearblocks.io',
        indexerUrl: 'https://dev-indexer.ref-finance.com',
        sodakiApiUrl: 'https://api.stats.ref.finance/api',
        blackList: process.env.FARM_BLACK_LIST || ['1371#3'],
        REF_FI_CONTRACT_ID: process.env.REF_FI_CONTRACT_ID || 'exchange.ref-dev.testnet',
        WRAP_NEAR_CONTRACT_ID: process.env.WRAP_NEAR_CONTRACT_ID || 'wrap.testnet',
        REF_ADBOARD_CONTRACT_ID: 'ref-adboard.near',
        REF_FARM_CONTRACT_ID: process.env.REF_FARM_CONTRACT_ID || 'farm-dev.ref-dev.testnet',
        // REF_VE_CONTRACT_ID: 'dev-20220623151446-29039416013661',
        REF_TOKEN_ID: 'ref.fakes.testnet',
        XREF_TOKEN_ID: 'xref.ref-dev.testnet',
        REF_AIRDROP_CONTRACT_ID: 'locker002.ref-dev.testnet',
        TOP_POOLS_TOKEN_REFRESH_INTERVAL: process.env.POOL_TOKEN_REFRESH_INTERVAL || 60,
        POOL_TOKEN_REFRESH_INTERVAL: process.env.POOL_TOKEN_REFRESH_INTERVAL || 20,
        STABLE_POOL_ID: process.env.STABLE_POOL_ID || 79,
        STABLE_POOL_IDS: process.env.STABLE_POOL_IDS || ['79', '603', '604', '608'],
        USN_ID: 'usdn.testnet',
        STABLE_POOL_USN_ID: process.env.STABLE_POOL_USN_ID || 603,
        STABLE_TOKEN_IDS: ['usdt.fakes.testnet', 'usdc.fakes.testnet', 'dai.fakes.testnet'],
        STABLE_TOKEN_USN_IDS: ['usdn.testnet', 'usdt.fakes.testnet'],
        STABLE_TOKEN_USN_INDEX: {
          'usdn.testnet': 0,
          'usdt.fakes.testnet': 1,
        },
        STABLE_TOKEN_INDEX: {
          'usdt.fakes.testnet': 0,
          'usdc.fakes.testnet': 1,
          'dai.fakes.testnet': 2,
        },
        TOTAL_PLATFORM_FEE_REVENUE: process.env.TOTAL_PLATFORM_FEE_REVENUE || '987635.62',
        CUMULATIVE_REF_BUYBACK: process.env.CUMULATIVE_REF_BUYBACK || '1308109.404',
        BLACKLIST_POOL_IDS: ['686'],
        REF_FARM_BOOST_CONTRACT_ID: process.env.REF_FARM_BOOST_CONTRACT_ID || 'boostfarm024.ref-dev.testnet',
        FARM_LOCK_SWITCH: process.env.FARM_LOCK_SWITCH || 0,
        VotingGauge: ['5%', '10%'],
        REF_UNI_V3_SWAP_CONTRACT_ID: process.env.REF_UNI_V3_SWAP_CONTRACT_ID || 'mock-dcl.ref-dev.testnet',
        kitWalletOn: true,
        FARM_BLACK_LIST_V2: process.env.FARM_BLACK_LIST_V2 || ['666'],
        boostBlackList: process.env.FARM__BOOST_BLACK_LIST || [''],
        ORDERLY_ASSET_MANAGER: 'asset-manager.orderly.testnet',
      };
    default:
      return {
        networkId: 'mainnet',
        nodeUrl: RPC_LIST[endPoint].url,
        walletUrl: 'https://wallet.near.org',
        myNearWalletUrl: 'https://app.mynearwallet.com/',
        helperUrl: 'https://api.kitwallet.app',
        explorerUrl: 'https://nearblocks.io',
        indexerUrl: 'https://indexer.ref.finance',
        sodakiApiUrl: 'https://api.stats.ref.finance/api',
        blackList: process.env.FARM_BLACK_LIST || ['1371#3', '2769#2'],
        REF_FI_CONTRACT_ID: process.env.REF_FI_CONTRACT_ID || 'v2.ref-finance.near',
        WRAP_NEAR_CONTRACT_ID: process.env.WRAP_NEAR_CONTRACT_ID || 'wrap.near',
        REF_ADBOARD_CONTRACT_ID: 'ref-adboard.near',
        REF_FARM_CONTRACT_ID: process.env.REF_FARM_CONTRACT_ID || 'v2.ref-farming.near',
        REF_TOKEN_ID: 'token.v2.ref-finance.near',
        XREF_TOKEN_ID: 'xtoken.ref-finance.near',
        REF_AIRDROP_CONTRACT_ID: 's01.ref-airdrop.near',
        TOP_POOLS_TOKEN_REFRESH_INTERVAL: process.env.POOL_TOKEN_REFRESH_INTERVAL || 60,
        POOL_TOKEN_REFRESH_INTERVAL: process.env.POOL_TOKEN_REFRESH_INTERVAL || 20,
        BTC_POOL_ID: '3364',
        BTCIDS: ['2260fac5e5542a773aa44fbcfedf7c193bc2c599.factory.bridge.near', '0316eb71485b0ab14103307bf65a021042c6d380.factory.bridge.near'],
        BTC_IDS_INDEX: {
          '2260fac5e5542a773aa44fbcfedf7c193bc2c599.factory.bridge.near': 0,
          '0316eb71485b0ab14103307bf65a021042c6d380.factory.bridge.near': 1,
        },
        STABLE_POOL_USN_ID: process.env.STABLE_POOL_USN_ID || 3020,
        STABLE_TOKEN_USN_IDS: ['usn', 'dac17f958d2ee523a2206206994597c13d831ec7.factory.bridge.near'],
        STABLE_TOKEN_USN_INDEX: {
          usn: 0,
          'dac17f958d2ee523a2206206994597c13d831ec7.factory.bridge.near': 1,
        },
        STABLE_POOL_ID: process.env.STABLE_POOL_ID || 1910,
        STABLE_POOL_IDS: process.env.STABLE_POOL_IDS || ['1910', '3020', '3364', '3433'],
        STABLE_TOKEN_IDS: [
          'dac17f958d2ee523a2206206994597c13d831ec7.factory.bridge.near',
          'a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48.factory.bridge.near',
          '6b175474e89094c44da98b954eedeac495271d0f.factory.bridge.near',
        ],
        STABLE_TOKEN_INDEX: {
          'dac17f958d2ee523a2206206994597c13d831ec7.factory.bridge.near': 0,
          'a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48.factory.bridge.near': 1,
          '6b175474e89094c44da98b954eedeac495271d0f.factory.bridge.near': 2,
        },
        USN_ID: 'usn',
        TOTAL_PLATFORM_FEE_REVENUE: process.env.TOTAL_PLATFORM_FEE_REVENUE || '987635.62',
        CUMULATIVE_REF_BUYBACK: process.env.CUMULATIVE_REF_BUYBACK || '1308109.404',
        BLACKLIST_POOL_IDS: ['3689', '3699'],
        FARM_LOCK_SWITCH: process.env.FARM_LOCK_SWITCH || 0,
        VotingGauge: ['10%', '10%'],
        REF_FARM_BOOST_CONTRACT_ID: process.env.REF_FARM_BOOST_CONTRACT_ID || 'boostfarm.ref-labs.near',
        FARM_BLACK_LIST_V2: process.env.FARM_BLACK_LIST_V2 || ['3612'],
        boostBlackList: process.env.FARM__BOOST_BLACK_LIST || ['3699#0', '3612#0', '3612#1'],
        ORDERLY_ASSET_MANAGER: 'asset-manager.orderly-network.near',
      };
  }
}

export function getExtraStablePoolConfig(env: string = process.env.NEAR_ENV || process.env.REACT_APP_NEAR_ENV) {
  switch (env) {
    case 'production':
    case 'mainnet':
      return {
        BTCIDS: ['2260fac5e5542a773aa44fbcfedf7c193bc2c599.factory.bridge.near', '0316eb71485b0ab14103307bf65a021042c6d380.factory.bridge.near'],
        BTC_STABLE_POOL_INDEX: {
          '2260fac5e5542a773aa44fbcfedf7c193bc2c599.factory.bridge.near': 0,
          '0316eb71485b0ab14103307bf65a021042c6d380.factory.bridge.near': 1,
        },
        BTC_STABLE_POOL_ID: '3364',
        CUSDIDS: ['usn', 'cusd.token.a11bd.near'],
        CUSD_STABLE_POOL_INDEX: {
          usn: 0,
          'cusd.token.a11bd.near': 1,
        },
        CUSD_STABLE_POOL_ID: '3433',
        STNEAR_POOL_ID: '3514',
        LINEAR_POOL_ID: '3515',
        STNEARIDS: ['meta-pool.near', 'wrap.near'],
        LINEARIDS: ['linear-protocol.near', 'wrap.near'],
        STNEAR_POOL_INDEX: {
          'meta-pool.near': 0,
          'wrap.near': 1,
        },
        LINEAR_POOL_INDEX: {
          'linear-protocol.near': 0,
          'wrap.near': 1,
        },
        NEARX_POOL_ID: '3612',
        NEARXIDS: ['nearx.stader-labs.near', 'wrap.near'],
        NEARX_POOL_INDEX: {
          'nearx.stader-labs.near': 0,
          'wrap.near': 1,
        },
        NEW_NEARX_POOL_ID: '3688',
        NEW_NEARXIDS: ['v2-nearx.stader-labs.near', 'wrap.near'],
        NEW_NEARX_POOL_INDEX: {
          'v2-nearx.stader-labs.near': 0,
          'wrap.near': 1,
        },
        USDT_POOL_ID: '3689',
        USDTIDS: ['dac17f958d2ee523a2206206994597c13d831ec7.factory.bridge.near', 'usdt.tether-token.near'],
        USDT_POOL_INDEX: {
          'dac17f958d2ee523a2206206994597c13d831ec7.factory.bridge.near': 0,
          'usdt.tether-token.near': 1,
        },

        RATED_POOLS_IDS: ['3514', '3515', '3612', '3688', '3689'],
      };
    case 'development':
    case 'pub-testnet':
      return {
        BTCIDS: ['wbtc.fakes.testnet', 'hbtc.fakes.testnet'],
        BTC_STABLE_POOL_INDEX: {
          'wbtc.fakes.testnet': 0,
          'hbtc.fakes.testnet': 1,
        },
        BTC_STABLE_POOL_ID: '456',
        CUSDIDS: ['usdn.testnet', 'cusd.fakes.testnet'],
        CUSD_STABLE_POOL_INDEX: {
          'usdn.testnet': 0,
          'cusd.fakes.testnet': 1,
        },
        CUSD_STABLE_POOL_ID: '494',
        STNEAR_POOL_ID: '568',
        LINEAR_POOL_ID: '571',
        STNEARIDS: ['meta-v2.pool.testnet', 'wrap.testnet'],
        LINEARIDS: ['linear-protocol.testnet', 'wrap.testnet'],
        STNEAR_POOL_INDEX: {
          'meta-v2.pool.testnet': 0,
          'wrap.testnet': 1,
        },
        LINEAR_POOL_INDEX: {
          'linear-protocol.testnet': 0,
          'wrap.testnet': 1,
        },
        NEARXIDS: ['nearx.staderlabs.testnet', 'wrap.testnet'],
        NEARX_POOL_ID: '1044',
        NEARX_POOL_INDEX: {
          'nearx.staderlabs.testnet': 0,
          'wrap.testnet': 1,
        },
        NEW_NEARX_POOL_ID: '1751',
        NEW_NEARXIDS: ['v2-nearx.staderlabs.testnet', 'wrap.testnet'],
        NEW_NEARX_POOL_INDEX: {
          'v2-nearx.staderlabs.testnet': 0,
          'wrap.testnet': 1,
        },

        RATED_POOLS_IDS: ['568', '571', '1044', '1751'],
      };
    case 'testnet':
      return {
        BTCIDS: ['wbtc.fakes.testnet', 'hbtc.fakes.testnet'],
        BTC_STABLE_POOL_INDEX: {
          'wbtc.fakes.testnet': 0,
          'hbtc.fakes.testnet': 1,
        },
        BTC_STABLE_POOL_ID: '604',
        CUSDIDS: ['usdn.testnet', 'cusd.fakes.testnet'],
        CUSD_STABLE_POOL_INDEX: {
          'usdn.testnet': 0,
          'cusd.fakes.testnet': 1,
        },
        CUSD_STABLE_POOL_ID: '608',
        STNEAR_POOL_ID: '621',
        LINEAR_POOL_ID: '622',
        NEARX_POOL_ID: '666',
        STNEARIDS: ['meta-v2.pool.testnet', 'wrap.testnet'],
        LINEARIDS: ['linear-protocol.testnet', 'wrap.testnet'],
        NEARXIDS: ['nearx.staderlabs.testnet', 'wrap.testnet'],
        STNEAR_POOL_INDEX: {
          'meta-v2.pool.testnet': 0,
          'wrap.testnet': 1,
        },
        LINEAR_POOL_INDEX: {
          'linear-protocol.testnet': 0,
          'wrap.testnet': 1,
        },
        NEARX_POOL_INDEX: {
          'nearx.staderlabs.testnet': 0,
          'wrap.testnet': 1,
        },
        NEW_NEARX_POOL_ID: '685',
        NEW_NEARXIDS: ['v2-nearx.staderlabs.testnet', 'wrap.testnet'],
        NEW_NEARX_POOL_INDEX: {
          'v2-nearx.staderlabs.testnet': 0,
          'wrap.testnet': 1,
        },

        RATED_POOLS_IDS: ['621', '622', '666', '685'],
      };
    default:
      return {
        BTCIDS: ['2260fac5e5542a773aa44fbcfedf7c193bc2c599.factory.bridge.near', '0316eb71485b0ab14103307bf65a021042c6d380.factory.bridge.near'],
        BTC_STABLE_POOL_INDEX: {
          '2260fac5e5542a773aa44fbcfedf7c193bc2c599.factory.bridge.near': 0,
          '0316eb71485b0ab14103307bf65a021042c6d380.factory.bridge.near': 1,
        },
        BTC_STABLE_POOL_ID: '3364',
        CUSDIDS: ['usn', 'cusd.token.a11bd.near'],
        CUSD_STABLE_POOL_INDEX: {
          usn: 0,
          'cusd.token.a11bd.near': 1,
        },
        CUSD_STABLE_POOL_ID: '3433',
        STNEAR_POOL_ID: '3514',
        LINEAR_POOL_ID: '3515',
        STNEARIDS: ['meta-pool.near', 'wrap.near'],
        LINEARIDS: ['linear-protocol.near', 'wrap.near'],
        STNEAR_POOL_INDEX: {
          'meta-pool.near': 0,
          'wrap.near': 1,
        },
        LINEAR_POOL_INDEX: {
          'linear-protocol.near': 0,
          'wrap.near': 1,
        },
        NEARX_POOL_ID: '3612',
        NEARXIDS: ['nearx.stader-labs.near', 'wrap.near'],
        NEARX_POOL_INDEX: {
          'nearx.stader-labs.near': 0,
          'wrap.near': 1,
        },
        NEW_NEARX_POOL_ID: '3688',
        NEW_NEARXIDS: ['v2-nearx.stader-labs.near', 'wrap.near'],
        NEW_NEARX_POOL_INDEX: {
          'v2-nearx.stader-labs.near': 0,
          'wrap.near': 1,
        },
        USDT_POOL_ID: '3689',
        USDTIDS: ['dac17f958d2ee523a2206206994597c13d831ec7.factory.bridge.near', 'usdt.tether-token.near'],
        USDT_POOL_INDEX: {
          'dac17f958d2ee523a2206206994597c13d831ec7.factory.bridge.near': 0,
          'usdt.tether-token.near': 1,
        },

        RATED_POOLS_IDS: ['3514', '3515', '3612', '3688', '3689'],
      };
  }
}
export function getTransakConfig(accountId: string, env: string = process.env.NEAR_ENV || process.env.REACT_APP_NEAR_ENV) {
  switch (env) {
    case 'production':
    case 'mainnet':
      return {
        apiKey: 'bf2238a1-ff5d-4a8f-9e1b-af7892ed0123',
        environment: 'PRODUCTION',
        widgetWidth: `500px`,
        widgetHeight: `600px`,
        themeColor: `#00C6A2`,
        hostURL: typeof window !== 'undefined' ? window.location.origin : ``,
        defaultCryptoCurrency: 'NEAR',
        cryptoCurrencyCode: 'NEAR',
        walletAddress: accountId || '',
      };
    case 'development':
    case 'pub-testnet':
      return {
        apiKey: '538c522e-474e-4d3b-a7a2-38a736cea747',
        environment: 'STAGING',
        widgetWidth: `500px`,
        widgetHeight: `600px`,
        themeColor: `#00C6A2`,
        hostURL: typeof window !== 'undefined' ? window.location.origin : ``,
        defaultCryptoCurrency: 'NEAR',
        cryptoCurrencyCode: 'NEAR',
        walletAddress: accountId || '',
      };
    case 'testnet':
      return {
        apiKey: '538c522e-474e-4d3b-a7a2-38a736cea747',
        environment: 'STAGING',
        widgetWidth: `500px`,
        widgetHeight: `600px`,
        themeColor: `#00C6A2`,
        cryptoCurrencyCode: 'NEAR',
        hostURL: typeof window !== 'undefined' ? window.location.origin : ``,
        defaultCryptoCurrency: 'NEAR',
        walletAddress: accountId || '',
      };
    default:
      return {
        apiKey: 'bf2238a1-ff5d-4a8f-9e1b-af7892ed0123',
        environment: 'PRODUCTION',
        widgetWidth: `500px`,
        widgetHeight: `600px`,
        themeColor: `#00C6A2`,
        hostURL: typeof window !== 'undefined' ? window.location.origin : ``,
        defaultCryptoCurrency: 'NEAR',
        cryptoCurrencyCode: 'NEAR',
        walletAddress: accountId || '',
      };
  }
}

export function getOrderlyConfig(env: string = process.env.NEAR_ENV || process.env.REACT_APP_NEAR_ENV) {
  switch (env) {
    case 'production':
    case 'mainnet':
      return {
        ORDERLY_ASSET_MANAGER: 'asset-manager.orderly-network.near',
        OFF_CHAIN_END_POINT: 'https://api.orderly.org',
        ORDERLY_WS_ENDPOINT: 'wss://ws.orderly.org/ws/stream',
        ORDERLY_WS_ENDPOINT_PRIVATE: 'wss://ws-private.orderly.org/v2/ws/private/stream',
      };
    case 'development':
    case 'pub-testnet':
      return {
        ORDERLY_ASSET_MANAGER: 'asset-manager.orderly.testnet',
        OFF_CHAIN_END_POINT: 'https://testnet-api.orderly.org',
        ORDERLY_WS_ENDPOINT: 'wss://testnet-ws.orderly.org/ws/stream',
        ORDERLY_WS_ENDPOINT_PRIVATE: 'wss://testnet-ws-private.orderly.org/v2/ws/private/stream',
      };
    case 'testnet':
      return {
        ORDERLY_ASSET_MANAGER: 'asset-manager.orderly.testnet',
        OFF_CHAIN_END_POINT: 'https://testnet-api.orderly.org',
        ORDERLY_WS_ENDPOINT: 'wss://testnet-ws.orderly.org/ws/stream',
        ORDERLY_WS_ENDPOINT_PRIVATE: 'wss://testnet-ws-private.orderly.org/v2/ws/private/stream',
      };
    default:
      return {
        ORDERLY_ASSET_MANAGER: 'asset-manager.orderly-network.near',
        OFF_CHAIN_END_POINT: 'https://api.orderly.org',
        ORDERLY_WS_ENDPOINT: 'wss://ws.orderly.org/ws/stream',
        ORDERLY_WS_ENDPOINT_PRIVATE: 'wss://ws-private.orderly.org/v2/ws/private/stream',
      };
  }
}

'''
'''--- src/datafeed/helpers.ts ---
// Make requests to CryptoCompare API

import { getOrderlyConfig } from '../config';

export async function makePublicApiRequest(path: string) {
  try {
    const response = await fetch(`${getOrderlyConfig().OFF_CHAIN_END_POINT}/${path}`);
    return response.json();
  } catch {
    throw new Error(`Symbol request Error`);
  }
}

// Generate a symbol ID from a pair of the coins
export function generateSymbol(exchange: string, fromSymbol: string, toSymbol: string) {
  const short = `${fromSymbol}/${toSymbol}`;
  return {
    short,
    full: `${exchange}:${short}`,
  };
}

export function parseFullSymbol(fullSymbol: string) {
  console.log('fullSymbol: ', fullSymbol);

  const symbolName = fullSymbol.split(':')[1];

  return {
    exchange: 'Orderly',
    fromSymbol: symbolName.split('/')[0],
    toSymbol: symbolName.split('/')[1],
  };
}

export function ResolutionToSeconds(resolution: string) {
  const min_time = 60;

  if (resolution.includes('D')) {
    return min_time * 60 * 24;
  } else if (resolution.includes('W')) {
    return min_time * 60 * 24 * 7;
  } else if (resolution.includes('H')) {
    return min_time * 60;
  }

  return min_time * Number(resolution);
}

export function parseResolution(resolution: string) {
  if (resolution.includes('D')) {
    return resolution.replace('D', 'd');
  } else if (resolution.includes('W')) {
    return resolution.replace('W', 'w');
  } else if (resolution.includes('H')) {
    return resolution.replace('H', 'h');
  }

  return resolution + 'm';
}

'''
'''--- src/datafeed/index.ts ---
//@ts-nocheck

import { makePublicApiRequest, generateSymbol, parseFullSymbol } from './helpers';
import { subscribeOnStream, unsubscribeFromStream } from './streaming';

interface OrderlyPair {
  symbol: string;
  quote_min: number;
  quote_max: number;
  quote_tick: number;
  base_min: number;
  base_max: number;
  base_tick: number;
  min_notional: number;
  price_range: number;
  created_time: number;
  updated_time: number;
}

const lastBarsCache = new Map();

const configurationData = {
  supported_resolutions: ['1', '5', '15', '30', '1H', '1D', '1W', '1M'],
  exchanges: [
    {
      value: 'Orderly',
      name: 'Orderly',
      desc: 'Orderly',
    },
  ],
  // symbols_types: [
  //   {
  //     name: 'crypto',

  //     // `symbolType` argument for the `searchSymbols` method, if a user selects this symbol type
  //     value: 'crypto',
  //   },
  // ...
  // ],
};

async function getAllSymbols() {
  const data = await makePublicApiRequest('v1/public/info');

  const pairs: OrderlyPair[] = data.data.rows;

  const symbols = pairs.map((p) => {
    return {
      symbol: p.symbol.split('_').slice(1, undefined).join('/'),
      full_name: p.symbol,
      description: p.symbol,
      exchange: 'Orderly',
      type: 'crypto',
    };
  });

  return symbols;

  // for (const leftPairPart of Object.keys(pairs)) {
  //   const symbols = pairs[leftPairPart].map((rightPairPart) => {
  //     const symbol = generateSymbol(exchange.value, leftPairPart, rightPairPart);
  //     return {
  //       symbol: symbol.short,
  //       full_name: symbol.full,
  //       description: symbol.short,
  //       exchange: exchange.value,
  //       type: 'crypto',
  //     };
  //   });
  //   allSymbols = [...allSymbols, ...symbols];
}

const datafeed = {
  onReady: (callback) => {
    console.log('[onReady]: Method call');
    setTimeout(() => callback(configurationData));
  },

  searchSymbols: async (userInput, exchange, symbolType, onResultReadyCallback) => {
    console.log('[searchSymbols]: Method call');
    const symbols = await getAllSymbols();
    const newSymbols = symbols.filter((symbol) => {
      const isExchangeValid = exchange === '' || symbol.exchange === exchange;
      const isFullSymbolContainsInput = symbol.full_name.toLowerCase().indexOf(userInput.toLowerCase()) !== -1;
      return isExchangeValid && isFullSymbolContainsInput;
    });
    onResultReadyCallback(newSymbols);
  },

  resolveSymbol: async (symbolName, onSymbolResolvedCallback, onResolveErrorCallback, extension) => {
    console.log('[resolveSymbol]: Method call', symbolName);
    const symbols = await getAllSymbols();
    const symbolItem = symbols.find(({ full_name }) => full_name === symbolName);
    console.log('symbolItem: ', symbolItem);
    if (!symbolItem) {
      console.log('[resolveSymbol]: Cannot resolve symbol', symbolName);
      onResolveErrorCallback('cannot resolve symbol');
      return;
    }

    const symbolInfo = {
      ticker: symbolItem.full_name,
      name: symbolItem.symbol,
      description: symbolItem.description,
      type: symbolItem.type,
      session: '24x7',
      timezone: 'Etc/UTC',
      exchange: symbolItem.exchange,
      minmov: 1,
      pricescale: 100,
      has_intraday: true,
      has_no_volume: true,
      has_weekly_and_monthly: false,
      supported_resolutions: configurationData.supported_resolutions,
      volume_precision: 2,
      data_status: 'streaming',
    };
    console.log('symbolInfo: ', symbolInfo);
    console.log('[resolveSymbol]: Symbol resolved', symbolName);
    onSymbolResolvedCallback(symbolInfo);
  },

  getBars: async (symbolInfo, resolution, periodParams, onHistoryCallback, onErrorCallback) => {
    const { from, to, firstDataRequest } = periodParams;
    console.log('[getBars]: Method call', symbolInfo, resolution, from, to);
    const parsedSymbol = parseFullSymbol(symbolInfo.full_name);
    console.log('parsedSymbol: ', parsedSymbol);
    const urlParameters = {
      symbol: `SPOT_${parsedSymbol?.fromSymbol}_${parsedSymbol?.toSymbol}`,
      resolution,
      from,
      to,
    };
    const query = Object.keys(urlParameters)
      .map((name) => `${name}=${encodeURIComponent(urlParameters[name])}`)
      .join('&');
    try {
      const data = await makePublicApiRequest(`tv/history/?${query}`);
      console.log('data: ', data);
      if (!data || data['s'] !== 'ok') {
        // "noData" should be set if there is no data in the requested period.
        onHistoryCallback([], {
          noData: true,
        });
        return;
      }

      let bars = [];

      data['a'].forEach((bar, i) => {
        if (data['t'][i] >= from && data['t'][i] < to) {
          bars = [
            ...bars,
            {
              time: data['t'][i] * 1000,
              low: data['l'][i],
              high: data['h'][i],
              open: data['o'][i],
              close: data['c'][i],
            },
          ];
        }
      });
      if (firstDataRequest) {
        lastBarsCache.set(symbolInfo.full_name, {
          ...bars[bars.length - 1],
        });
      }
      console.log('bars: ', bars);
      console.log(`[getBars]: returned ${bars.length} bar(s)`);
      onHistoryCallback(bars, {
        noData: false,
      });
    } catch (error) {
      console.log('[getBars]: Get error', error);
      onErrorCallback(error);
    }
  },

  subscribeBars: (symbolInfo, resolution, onRealtimeCallback, subscriberUID, onResetCacheNeededCallback) => {
    console.log('[subscribeBars]: Method call with subscriberUID:', subscriberUID);
    subscribeOnStream(symbolInfo, resolution, onRealtimeCallback, subscriberUID, onResetCacheNeededCallback, lastBarsCache.get(symbolInfo.full_name));
  },

  unsubscribeBars: (subscriberUID) => {
    console.log('[unsubscribeBars]: Method call with subscriberUID:', subscriberUID);
    unsubscribeFromStream(subscriberUID);
  },
};

export default datafeed;

'''
'''--- src/datafeed/streaming.ts ---
// @ts-noCheck

import { config } from '../near';

import { getOrderlyConfig } from '../config';
import { ResolutionToSeconds, parseFullSymbol, parseResolution } from './helpers';

// import { WebSocket } from 'ws';
import { getOrderlyWss } from '../orderly/constant';

const channelToSubscription = new Map();

export const ws = new WebSocket(getOrderlyWss(false));

function sendPing() {
  ws.send(
    JSON.stringify({
      event: 'ping',
      ts: Date.now(),
    })
  );
}

function sendPong() {
  ws.send(
    JSON.stringify({
      event: 'pong',
      ts: Date.now(),
    })
  );
}

ws.onopen = () => {
  sendPing();
};

ws.onmessage = (event) => {
  const { event: data_event } = JSON.parse(event.data);

  if (data_event) {
    if (data_event === 'ping') {
      sendPong();
      sendPing();
    }
  }
};

ws.onclose = (event) => {};

ws.onerror = (event) => {
  // alert('error ');
};

ws.onmessage = (event) => {
  const { data, topic, event: dataEvent } = JSON.parse(event.data);

  if (dataEvent === 'ping') {
    sendPong();
    return;
  }

  if (!topic || topic.indexOf('kline') === -1) {
    return;
  }

  const { high, low, open, startTime, close } = data;

  const subscriptionItem = channelToSubscription.get(topic);
  if (subscriptionItem === undefined) {
    return;
  }

  const lastBar = subscriptionItem.lastBar;

  const nextDailyBarTime = getNextBarTime(lastBar.time, subscriptionItem.resolution);

  let bar;
  if (startTime >= nextDailyBarTime) {
    bar = {
      time: nextDailyBarTime,
      open: open,
      high: high,
      low: low,
      close: close,
    };
  } else {
    bar = {
      ...lastBar,
      high: Math.max(lastBar.high, high),
      low: Math.min(lastBar.low, low),
      close: close,
    };
  }
  subscriptionItem.lastBar = bar;

  // send data to every subscriber of that symbol
  subscriptionItem.handlers.forEach((handler) => handler.callback(bar));
};

function getNextBarTime(barTime: number, resolution: string) {
  return barTime + ResolutionToSeconds(resolution) * 1000;
}

export function subscribeOnStream(symbolInfo, resolution, onRealtimeCallback, subscriberUID, onResetCacheNeededCallback, lastBar) {
  const parsedSymbol = parseFullSymbol(symbolInfo.full_name);
  const channelString = `0~${parsedSymbol.exchange}~${parsedSymbol.fromSymbol}~${parsedSymbol.toSymbol}`;

  const topic = `SPOT_${parsedSymbol.fromSymbol}_${parsedSymbol.toSymbol}@kline_${parseResolution(resolution)}`;

  const handler = {
    id: subscriberUID,
    callback: onRealtimeCallback,
    topic,
  };

  const msg = {
    event: 'subscribe',
    topic,
    id: topic,
    ts: Date.now(),
  };
  let subscriptionItem = channelToSubscription.get(topic);

  console.log('subscriptionItem: ', subscriptionItem);
  if (subscriptionItem) {
    // already subscribed to the channel, use the existing subscription

    subscriptionItem.handlers.push(handler);
    return;
  }

  subscriptionItem = {
    subscriberUID,
    resolution,
    lastBar,
    handlers: [handler],
  };

  console.log('subscriptionItem: ', subscriptionItem);

  console.log('[subscribeBars]: Subscribe to streaming. Channel:', channelString);

  channelToSubscription.set(topic, subscriptionItem);

  ws.send(JSON.stringify(msg));
}

export function unsubscribeFromStream(subscriberUID) {
  // find a subscription with id === subscriberUID
  for (const topic of channelToSubscription.keys()) {
    const subscriptionItem = channelToSubscription.get(topic);
    const handlerIndex = subscriptionItem.handlers.findIndex((handler) => handler.id === subscriberUID);

    if (handlerIndex !== -1) {
      // remove from handlers

      const tmpHandler = subscriptionItem.handlers[handlerIndex];

      subscriptionItem.handlers.splice(handlerIndex, 1);
      if (subscriptionItem.handlers.length === 0) {
        // unsubscribe from the channel, if it was the last handler
        // socket.emit('SubRemove', { subs: [channelString] });
        const msg = {
          event: 'unsubscribe',
          topic: tmpHandler.topic,
          id: tmpHandler.topic,
        };

        ws.send(JSON.stringify(msg));

        channelToSubscription.delete(topic);
        break;
      }
    }
  }
}

'''
'''--- src/near.ts ---
// @ts-nocheck

import getConfig from './config';
import { Near, keyStores, utils, WalletConnection, providers } from 'near-api-js';
import { Transaction as WSTransaction, AddKeyAction, AddKeyPermission } from '@near-wallet-selector/core';
import * as math from 'mathjs';

import BN from 'bn.js';
import { getOrderlyConfig } from './config';
import { NotSignInError } from './orderly/error';
import { TokenMetadata } from './orderly/type';
export interface ViewFunctionOptions {
  methodName: string;
  args?: object;
}

export const getGas = (gas: string) => (gas ? new BN(gas) : new BN('100000000000000'));

export const getAmount = (amount: string) => (amount ? new BN(utils.format.parseNearAmount(amount)) : new BN('0'));

export const ONE_YOCTO_NEAR = '0.000000000000000000000001';
export interface FunctionCallOptions extends ViewFunctionOptions {
  gas?: string;
  amount?: string;
}

export interface Transaction {
  receiverId: string;
  functionCalls: FunctionCallOptions[];
}

export const keyStore = new keyStores.BrowserLocalStorageKeyStore();

export const config = getConfig();

export const near = new Near({
  keyStore,
  headers: {},
  ...config,
});

export const ORDERLY_ASSET_MANAGER = getOrderlyConfig().ORDERLY_ASSET_MANAGER;

export const orderlyViewFunction = async ({ methodName, args }: ViewFunctionOptions) => {
  const nearConnection = await near.account(ORDERLY_ASSET_MANAGER);

  return nearConnection.viewFunction(ORDERLY_ASSET_MANAGER, methodName, args);
};

export const executeMultipleTransactions = async (transactions: Transaction[], callbackUrl?: string) => {
  const wallet = await window.selector.wallet();

  const wsTransactions: WSTransaction[] = [];

  transactions.forEach((transaction) => {
    wsTransactions.push({
      signerId: wallet.getAccounts()?.[0]!,
      receiverId: transaction.receiverId,
      actions: transaction.functionCalls.map((fc) => {
        return {
          type: 'FunctionCall',
          params: {
            methodName: fc.methodName,
            args: fc.args,
            gas: getGas(fc.gas).toNumber().toFixed(),
            deposit: utils.format.parseNearAmount(fc.amount || '0')!,
          },
        };
      }),
    });
  });

  return wallet
    .signAndSendTransactions({
      transactions: wsTransactions,
      callbackUrl,
    })
    .then((res) => {
      console.log(res);
    })
    .catch(() => {
      alert('fail');
    });
};

export const getFunctionCallTransaction = async (transactions: Transaction[]) => {
  const signerId = await window.selector?.store?.getState()?.accounts[0]?.accountId;

  const wsTransactions: WSTransaction[] = [];

  transactions.forEach((transaction) => {
    wsTransactions.push({
      signerId: signerId!,
      receiverId: transaction.receiverId,
      actions: transaction.functionCalls.map((fc) => {
        return {
          type: 'FunctionCall',
          params: {
            methodName: fc.methodName,
            args: fc.args || [],
            gas: getGas(fc.gas).toNumber().toFixed(),
            deposit: utils.format.parseNearAmount(fc.amount || '0')!,
          },
        };
      }),
    });
  });

  return wsTransactions;
};

export const getAddFunctionCallKeyTransaction = async ({ receiverId, publicKey }: { receiverId: string; publicKey: string }) => {
  const signerId = await window.selector?.store?.getState()?.accounts[0]?.accountId;

  if (!signerId) throw Error('Please sign in first.');

  const wsTransactions: WSTransaction[] = [];
  wsTransactions.push({
    signerId: signerId!,
    receiverId: signerId,
    actions: [
      {
        type: 'AddKey',
        params: {
          publicKey,
          accessKey: {
            permission: {
              receiverId,
            },
          },
        },
      },
    ],
  });

  return wsTransactions;
};

export const getFTmetadata = async (token: string): Promise<TokenMetadata> => {
  if (token === 'near' || token === 'NEAR') return nearMetadata;

  const account = await near.account(ORDERLY_ASSET_MANAGER);

  const data = await account.viewFunction(token, 'ft_metadata');

  return {
    ...data,
    id: token,
  };
};

export const nearMetadata = {
  id: 'NEAR',
  name: 'NEAR',
  symbol: 'NEAR',
  decimals: 24,
  icon: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA2AAAANgCAIAAADF8JzzAAAACXBIWXMAABYlAAAWJQFJUiTwAAAgAElEQVR4nO3d7VXb2rqw4eQd57/cgZ0KLCqwVwWIChAVYCrAqQBTgUUFERVEVBBTwTYdmArWO/by3uzMfBA+bHlK87r+nTP2WBFSjO/o8SN//Pvvvz8AAMB//T9nAgCA7wlEAAACAhEAgIBABAAgIBABAAgIRAAAAgIRAICAQAQAICAQAQAICEQAAAICEQCAgEAEACAgEAEACAhEAAACAhEAgIBABAAgIBABAAgIRAAAAgIRAICAQAQAICAQAQAICEQAAAICEQCAgEAEACAgEAEACAhEAAACAhEAgIBABAAgIBABAAgIRAAAAgIRAICAQAQAICAQAQAICEQAAAICEQCAgEAEACAgEAEACAhEAAACAhEAgIBABAAgIBABAAgIRAAAAgIRAICAQAQAICAQAQAICEQAAAICEQCAgEAEACAgEAEACAhEAAACAhEAgIBABAAgIBABAAgIRAAAAgIRAICAQAQAICAQAQAICEQAAAICEQCAgEAEACAgEAEACAhEAAACAhEAgIBABAAgIBABAAgIRAAAAgIRAICAQAQAICAQAQAICEQAAAICEQCAgEAEACAgEAEACAhEAAACAhEAgIBABAAgIBABAAgIRAAAAgIRAICAQAQAICAQAQAICEQAAAICEQCAgEAEACAgEAEACAhEAAACAhEAgIBABAAgIBABAAgIRAAAAgIRAICAQAQAICAQAQAICEQAAAICEQCAgEAEACAgEAEACAhEAAACAhEAgIBABAAgIBABAAgIRAAAAgIRAICAQAQAICAQAQAICEQAAAICEQCAgEAEACAgEAEACAhEAAACAhEAgIBABAAgIBABAAgIRAAAAgIRAICAQAQAICAQAQAICEQAAAICEQCAgEAEACAgEAEACAhEAAACAhEAgIBABAAgIBABAAgIRAAAAgIRAICAQAQAICAQAQAICEQAAAICEQCAgEAEACAgEAEACAhEAAACAhEAgIBABAAgIBABAAgIRAAAAgIRAICAQAQAICAQAQAICEQAAAICEQCAgEAEACAgEAEACAhEAAACAhEAgIBABAAgIBABAAgIRAAAAgIRAICAQAQAICAQAQAICEQAAAICEQCAgEAEACAgEAEACAhEAAAC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ICAQAQAICEQAAAICEQCAgEAEACAgEAEACAhEAAACAhEAgIBABAAgIBABAAgIRAAAAgIRAICAQAQAICAQAQAICEQAAAICEQCAgEAEACAgEAEACAhEAAACAhEAgIBABAAgIBABAAgIRAAAAgIRAICAQAQAICAQAQAICEQAAAICEQCAgEAEACAgEAEACAhEAAACAhEAgIBABAAgIBABAAgIRAAAAgIRAICAQAQAICAQAQAICEQAAAICEQCAgEAEACAgEAEACAhEAAACAhEAgIBABAAgIBABAAgIRAAAAgIRAICAQAQAICAQAQAICEQAAAICEQCAgEAEACAgEAEACAhEAAACAhEAgIBABAAgIBABAAgIRAAAAgIRAICAQAQAICAQAQAICEQAAAICEQCAgEAEACAgEAEACAhEAAACAhEAgIBABAAgIBABAAgIRAAAAgIRAICAQAQAICAQAQAICEQAAAICEQCAgEAEACAgEAEACAhEAAACAhEAgIBABAAgIBABAAgIRAAAAgIRAICAQAQAICAQAQAICEQAAAICEQCAgEAEACAgEAEACAhEAAACAhEAgIBABAAgIBABAAgIRAAAAgIRAICAQAQAICAQAQAICEQAAAICEQCAgEAEACAgEAEACAhEAAACAhEAgIBABAAgIBABAAgIRAAAAgIRAICAQAQAICAQAQAICEQAAAICEQCAgEAEACAgEAEACAhEAAACAhEAgIBABAAgIBABAAgIRAAAAgIRAICAQAQAICAQAQAICEQAAAICEQCAgEAEACAgEAEACAhEAAACAhEAgIBABAAgIBABAAgIRAAAAgIRAICAQAQAICAQAQAICEQAAAICEQCAgEAEACAgEAEACAhEAAACAhEAgIBABAAgIBABAAgIRAAAAgIRAICAQAQAICAQAQAICEQAAAICEQCAgEAEACAgEAEACAhEAAACAhEAgIBABAAgIBABAAgIRAAAAgIRAICAQAQAICAQAQAICEQAAAICEQCAgEAEACAgEAEACAhEAAACAhEAgIBABAAgIBABAAgIRAAAAgIRAID/+fDhw/8H0I0VimXUJpsAAAAASUVORK5CYII=',
};

export const ftGetBalance = async (tokenId: string) => {
  const account_id = window.selectorAccountId;
  if (!account_id) throw NotSignInError;

  const nearConnection = await near.account(account_id);

  if (tokenId === 'NEAR' || tokenId === 'near') {
    return nearConnection.getAccountBalance().then(({ available }) => available);
  }

  return nearConnection
    .viewFunction(tokenId, 'ft_balance_of', {
      account_id: account_id,
    })
    .catch(() => '0');
};

export const toPrecision = (number: string, precision: number, withCommas: boolean = false, atLeastOne: boolean = true): string => {
  if (typeof number === 'undefined') return '0';

  const [whole, decimal = ''] = number.split('.');

  let str = `${withCommas ? formatWithCommas(whole) : whole}.${decimal.slice(0, precision)}`.replace(/\.$/, '');
  if (atLeastOne && Number(str) === 0 && str.length > 1) {
    var n = str.lastIndexOf('0');
    str = str.slice(0, n) + str.slice(n).replace('0', '1');
  }

  return str;
};

export const percent = (numerator: string, denominator: string) => {
  return math.evaluate(`(${numerator} / ${denominator}) * 100`);
};

export function scientificNotationToString(strParam: string) {
  let flag = /e/.test(strParam);
  if (!flag) return strParam;

  let sysbol = true;
  if (/e-/.test(strParam)) {
    sysbol = false;
  }

  const negative = Number(strParam) < 0 ? '-' : '';

  let index = Number(strParam.match(/\d+$/)[0]);

  let basis = strParam.match(/[\d\.]+/)[0];

  const ifFraction = basis.includes('.');

  let wholeStr;
  let fractionStr;

  if (ifFraction) {
    wholeStr = basis.split('.')[0];
    fractionStr = basis.split('.')[1];
  } else {
    wholeStr = basis;
    fractionStr = '';
  }

  if (sysbol) {
    if (!ifFraction) {
      return negative + wholeStr.padEnd(index + wholeStr.length, '0');
    } else {
      if (fractionStr.length <= index) {
        return negative + wholeStr + fractionStr.padEnd(index, '0');
      } else {
        return negative + wholeStr + fractionStr.substring(0, index) + '.' + fractionStr.substring(index);
      }
    }
  } else {
    if (!ifFraction) return negative + wholeStr.padStart(index + wholeStr.length, '0').replace(/^0/, '0.');
    else {
      return negative + wholeStr.padStart(index + wholeStr.length, '0').replace(/^0/, '0.') + fractionStr;
    }
  }
}

export const percentOfBigNumber = (percent: number, num: number | string, precision: number) => {
  const valueBig = math.bignumber(num);
  const percentBig = math.bignumber(percent).div(100);

  return toPrecision(scientificNotationToString(valueBig.mul(percentBig).toString()), precision);
};

'''
'''--- src/orderly/api.ts ---
import {
  get_storage_deposit_amount,
  orderly_storage_deposit,
  user_deposit_native_token,
  deposit_exact_token,
  user_request_withdraw,
  storage_balance_of,
  storage_balance_bounds,
  get_cost_of_announce_key,
  user_account_exists,
  is_orderly_key_announced,
} from './on-chain-api';
import { Transaction as WSTransaction } from '@near-wallet-selector/core';

import { utils } from 'near-api-js';

import { find_orderly_functionCall_key, getNormalizeTradingKey, toNonDivisibleNumber } from './utils';
import { getAddFunctionCallKeyTransaction, ORDERLY_ASSET_MANAGER } from '../near';
import { Transaction, getFunctionCallTransaction, near, getGas, getAmount } from '../near';

import { REGISTER_DEPOSIT_AMOUNT } from './on-chain-api';
import { getFTmetadata } from '../near';
import Big from 'big.js';

const signAndSendTransactions = async (transactions: Transaction[]) => {
  const wsTransactions = await getFunctionCallTransaction(transactions);

  const wallet = await window.selector.wallet();

  await wallet
    .signAndSendTransactions({
      transactions: wsTransactions,
    })
    .then((res) => {
      console.log(res);
    });
};

const signAndSendTransaction = async (wsTransaction: WSTransaction) => {
  const wallet = await window.selector.wallet();

  await wallet.signAndSendTransaction(wsTransaction).then((res) => {
    console.log(res);
  });
};

// account_exist = await user_account_exists(accountId);
// no account_exist to call registerOrderly.

const announceKey = async (accountId: string) => {
  const account = await near.account(accountId);

  await account.functionCall(ORDERLY_ASSET_MANAGER, 'user_announce_key', {});
};

const setTradingKey = async (accountId: string) => {
  const account = await near.account(accountId);

  await account.functionCall(ORDERLY_ASSET_MANAGER, 'user_request_set_trading_key', {
    key: getNormalizeTradingKey(),
  });
};

const storageDeposit = async (accountId: string) => {
  // const storage_amount = await get_storage_deposit_amount(accountId);

  const functionCallList = [];

  const user_exists = await user_account_exists(accountId);

  const storage_balance = await storage_balance_of(accountId);

  const min_amount = await storage_balance_bounds();

  const announce_key_amount = await get_cost_of_announce_key();

  // if (storage_amount !== null) {
  const deposit_functionCall_register = orderly_storage_deposit(accountId, utils.format.formatNearAmount(min_amount.min));

  const deposit_functionCall_announce_key = orderly_storage_deposit(accountId, utils.format.formatNearAmount(announce_key_amount));

  // await account.functionCall(ORDERLY_ASSET_MANAGER, 'storage_deposit', {}, new BN(deposit_functionCall.gas), new BN(deposit_functionCall.));

  if (!user_exists) {
    functionCallList.push(deposit_functionCall_register);
  }

  if (!user_exists || new Big(storage_balance?.available || '0').lt(new Big(announce_key_amount))) {
    functionCallList.push(deposit_functionCall_announce_key);
  }

  if (functionCallList.length === 0) return;

  const transaction: Transaction = {
    receiverId: ORDERLY_ASSET_MANAGER,
    functionCalls: functionCallList,
  };

  return signAndSendTransactions([transaction]);
};

const checkStorageDeposit = async (accountId: string) => {
  // const storage_amount = await get_storage_deposit_amount(accountId);

  // const storage_amount = await get_storage_deposit_amount(accountId);

  const functionCallList = [];

  const user_exists = await user_account_exists(accountId);

  const storage_balance = await storage_balance_of(accountId);

  const min_amount = await storage_balance_bounds();

  const isAnnounceKey = await is_orderly_key_announced(accountId);

  const isTradingKeySet = await is_orderly_key_announced(accountId);

  if (isAnnounceKey && isTradingKeySet) return true;

  const announce_key_amount = await get_cost_of_announce_key();

  // if (storage_amount !== null) {
  const deposit_functionCall_register = orderly_storage_deposit(accountId, utils.format.formatNearAmount(min_amount.min));

  const deposit_functionCall_announce_key = orderly_storage_deposit(accountId, utils.format.formatNearAmount(announce_key_amount));

  // await account.functionCall(ORDERLY_ASSET_MANAGER, 'storage_deposit', {}, new BN(deposit_functionCall.gas), new BN(deposit_functionCall.));

  if (!user_exists) {
    functionCallList.push(deposit_functionCall_register);
  }

  if (!user_exists || new Big(storage_balance?.available || '0').lt(new Big(announce_key_amount))) {
    functionCallList.push(deposit_functionCall_announce_key);
  }

  if (functionCallList.length === 0) return true;

  return false;
};

const registerOrderly = async (accountId: string) => {
  // let wsTransactions: WSTransaction[] = [];

  const account = await near.account(accountId);

  await account.functionCall(ORDERLY_ASSET_MANAGER, 'user_announce_key', {});

  await account.functionCall(ORDERLY_ASSET_MANAGER, 'user_request_set_trading_key', {
    key: getNormalizeTradingKey(),
  });
};

const depositNEAR = async (amount: string) => {
  const transactions: Transaction[] = [];
  const account_id = window.selectorAccountId;
  if (!account_id) return;

  const storageBound = await storage_balance_bounds();

  const balance = await storage_balance_of(account_id);

  if (balance === null || new Big(storageBound.min).gt(new Big(balance.available))) {
    transactions.push({
      receiverId: ORDERLY_ASSET_MANAGER,
      functionCalls: [orderly_storage_deposit(account_id, utils.format.formatNearAmount(storageBound.min), false)],
    });
  }
  transactions.push({
    receiverId: ORDERLY_ASSET_MANAGER,
    functionCalls: [await user_deposit_native_token(amount)],
  });

  return signAndSendTransactions(transactions);
};

const depositFT = async (token: string, amount: string) => {
  const transactions: Transaction[] = [];

  const metaData = await getFTmetadata(token);

  const account_id = window.selectorAccountId;
  if (!account_id) return;

  const storageBound = await storage_balance_bounds();

  const balance = await storage_balance_of(account_id);

  if (balance === null || new Big(storageBound.min).gt(new Big(balance.available))) {
    transactions.push({
      receiverId: ORDERLY_ASSET_MANAGER,
      functionCalls: [orderly_storage_deposit(account_id, utils.format.formatNearAmount(storageBound.min), false)],
    });
  }

  transactions.push({
    receiverId: token,
    functionCalls: [await deposit_exact_token(toNonDivisibleNumber(metaData.decimals, amount))],
  });

  return signAndSendTransactions(transactions);
};

const depositOrderly = async (token: string, amount: string) => {
  if (token === 'near') {
    return depositNEAR(amount);
  } else {
    return depositFT(token, amount);
  }
};

const withdrawOrderly = async (token: string, amount: string) => {
  const transactions: Transaction[] = [];

  const metaData = await getFTmetadata(token);

  transactions.push({
    receiverId: token,
    functionCalls: [await user_request_withdraw(token, toNonDivisibleNumber(metaData.decimals, amount))],
  });

  return signAndSendTransactions(transactions);
};

export {
  signAndSendTransactions,
  withdrawOrderly,
  depositOrderly,
  registerOrderly,
  announceKey,
  storageDeposit,
  depositNEAR,
  depositFT,
  signAndSendTransaction,
  checkStorageDeposit,
  setTradingKey,
};

'''
'''--- src/orderly/constant.ts ---
import { getOrderlyConfig } from '../config';

// export const getOrderlyWss = () =>
//   `${getOrderlyConfig().ORDERLY_WS_ENDPOINT}/${
//     !!window.selector && window.selector.isSignedIn() ? window.selectorAccountId : 'OqdphuyCtYWxwzhxyLLjOWNdFP7sQt8RPWzmb5xY'
//   }`;

export const getOrderlyWss = (accountValid: boolean) =>
  `${getOrderlyConfig().ORDERLY_WS_ENDPOINT}/${accountValid ? window.selectorAccountId : 'OqdphuyCtYWxwzhxyLLjOWNdFP7sQt8RPWzmb5xY'}`;

'''
'''--- src/orderly/error.ts ---
export const NotSignInError = new Error('Please sign in first. ');

'''
'''--- src/orderly/off-chain-api.ts ---
import { getOrderlyConfig } from '../config';
import { getPublicKey, generateRequestSignatureHeader, get_orderly_public_key_path, formateParamsNoSorting } from './utils';
import { OrderlyOrder, EditOrderlyOrder, ClientInfo, orderStatus, Balance } from './type';
import { get_user_trading_key } from './on-chain-api';
import { ec } from 'elliptic';
import { generateOrderSignature, OFF_CHAIN_METHOD, formateParams, tradingKeyMap } from './utils';

// get

export const getOrderlyHeaders = async ({
  url,
  accountId,
  trading,
  method,
  param,
  contentType,
}: {
  url?: string;
  accountId: string;
  trading?: boolean;
  method: OFF_CHAIN_METHOD;
  param?: object;
  contentType?: string;
}) => {
  const time_stamp = Date.now();

  const headers: Record<string, any> = {
    'Content-Type': contentType || 'application/x-www-form-urlencoded',
    'orderly-timestamp': `${time_stamp}`,
    'orderly-account-id': accountId,
    'orderly-key': await getPublicKey(accountId),
    'orderly-signature': await generateRequestSignatureHeader({
      accountId,
      time_stamp,
      url: url || '',
      body: param || null,
      method,
    }),
  };

  if (trading) {
    const storedPublicKey = localStorage.getItem(get_orderly_public_key_path());

    if (!storedPublicKey) {
      localStorage.setItem(get_orderly_public_key_path(), tradingKeyMap.get(get_orderly_public_key_path()) || '');
    }

    const orderly_trading_key = tradingKeyMap.get(get_orderly_public_key_path()) || localStorage.getItem(get_orderly_public_key_path());
    console.log('orderly_trading_key: ', orderly_trading_key);

    headers['orderly-trading-key'] = orderly_trading_key;
  }

  return headers;
};

export const requestOrderly = async ({ ct, url, accountId, param }: { url?: string; accountId: string; param?: object; ct?: string }) => {
  const headers = await getOrderlyHeaders({
    url,
    accountId,
    trading: false,
    method: 'GET',
    param,
    contentType: ct,
  });

  return await fetch(`${getOrderlyConfig().OFF_CHAIN_END_POINT}${url || ''}`, {
    method: 'GET',

    headers,
  }).then((res) => {
    return res.json();
  });
};

export const tradingOrderly = async ({
  url,
  accountId,
  body,
  method,
}: {
  url?: string;
  accountId: string;
  body: object;
  method?: 'POST' | 'PUT';
}) => {
  const headers = await getOrderlyHeaders({
    url,
    accountId,
    trading: true,
    method: method || 'POST',
    param: body,
    contentType: 'application/json',
  });
  return await fetch(`${getOrderlyConfig().OFF_CHAIN_END_POINT}${url || ''}`, {
    method: method || 'POST',
    headers,
    body: JSON.stringify(body),
  }).then((res) => {
    return res.json();
  });
};

export const deleteOrderly = async ({ url, accountId, param }: { url?: string; accountId: string; param?: object }) => {
  const headers = await getOrderlyHeaders({
    url,
    accountId,
    trading: true,
    method: 'DELETE',
    contentType: 'application/x-www-form-urlencoded',
  });
  return await fetch(`${getOrderlyConfig().OFF_CHAIN_END_POINT}${url || ''}`, {
    method: 'DELETE',
    headers,
  }).then((res) => {
    return res.json();
  });
};

export const createOrder = async (props: { accountId: string; orderlyProps: OrderlyOrder }) => {
  const { accountId } = props;

  const { symbol, client_order_id, order_type, order_price, order_quantity, order_amount, side, broker_id, visible_quantity } = props.orderlyProps;

  //Note for DELETE requests, the parameters are not in the json body.
  // const message = Object.entries(props.orderlyProps)
  //   .filter(([k, v], i) => {
  //     return v !== undefined && v !== null;
  //   })
  //   .map(([k, v], i) => {
  //     if (typeof v === 'number') {
  //       return `${k}=${parseFloat(v.toString())}`;
  //     }
  //     return `${k}=${v}`;
  //   })
  //   .sort()
  //   .join('&');

  const message = formateParams(props.orderlyProps);

  const signature = generateOrderSignature(accountId, message);

  const body = {
    symbol,
    client_order_id,
    order_type,
    order_price,
    order_quantity,
    order_amount,
    side,
    broker_id,
    visible_quantity,
    signature,
  };

  return await tradingOrderly({
    accountId,
    url: '/v1/order',
    body,
  });
};

export const getAccountInformation = async (props: { accountId: string }): Promise<ClientInfo> => {
  const url = '/v1/client/info';

  const res = await requestOrderly({
    url,
    accountId: props.accountId,
  });

  return res.data;
};

export const getCurrentHolding = async (props: { accountId: string }) => {
  const url = '/v1/client/holding';

  const res = await requestOrderly({
    url,
    accountId: props.accountId,
  });

  return res;
};

export const getAssetHistory = async (props: {
  accountId: string;
  HistoryParam: {
    token?: string;
    side?: 'DEPOSIT' | 'WITHDRAW';
    status?: 'NEW' | 'CONFIRM' | 'PROCESSING' | 'COMPLETED' | 'FAILED';
    page: number;
  };
}) => {
  const url = `/balance/asset/history?${formateParams(props.HistoryParam || {})}`;

  const res = requestOrderly({
    url,
    accountId: props.accountId,
    ct: 'application/json;charset=utf-8',
  });

  return res;
};

export const getOpenOrders = async (props: {
  accountId: string;
  // OrderProps?: {
  //   symbol?: string;
  //   side?: 'BUY' | 'SELL';
  //   order_type?: 'LIMIT' | 'MARKET';
  //   order_tag?: string;
  //   status?: 'NEW' | 'CANCELLED' | 'REJECTED' | 'COMPLETED' | 'FILLED' | 'PARTIAL_FILLED' | 'INCOMPLETE';
  //   start_t?: number;
  //   end_t?: number;
  //   page?: number;
  //   size?: number;
  // };
}) => {
  const url = `/orderservice/v1/merge/orders/pending`;

  const res = requestOrderly({
    url,
    accountId: props.accountId,
    ct: 'application/json;charset=utf-8',
  });

  return res;
};

export const getOrderTrades = async (props: { accountId: string; order_id: string | number }) => {
  const url = `/v1/order/${props.order_id}/trades`;

  const res = requestOrderly({
    url,
    accountId: props.accountId,
  });

  return res;
};

export const getOrders = async (props: {
  accountId: string;
  OrderProps?: {
    symbol?: string;
    side?: 'BUY' | 'SELL';
    order_type?: 'LIMIT' | 'MARKET';
    order_tag?: string;
    status?: orderStatus;
    start_t?: number;
    end_t?: number;
    page?: number;
    size?: number;
  };
}) => {
  const url = `/v1/orders?${formateParams(props.OrderProps || {})}`;

  const res = requestOrderly({
    url,
    accountId: props.accountId,
    ct: 'application/json;charset=utf-8',
  });

  return res;
};

export const getAllOrders = async (props: {
  accountId: string;
  OrderProps?: {
    symbol?: string;
    // side?: 'BUY' | 'SELL';
    // order_type?: 'LIMIT' | 'MARKET';
    // order_tag?: string;
    // status?: 'NEW' | 'CANCELLED' | 'REJECTED' | 'COMPLETED' | 'FILLED' | 'PARTIAL_FILLED' | 'INCOMPLETE';
    // start_t?: number;
    // end_t?: number;
    page?: number;
    size?: number;
  };
}) => {
  const pageOne = await getOrders({
    accountId: props.accountId,
    OrderProps: {
      ...props.OrderProps,
      page: 1,
      size: 500,
    },
  });

  console.log('pageOne: ', pageOne);

  const total = pageOne.data.meta.total;
  console.log('total: ', total);

  const pageSize = Math.ceil(total / 500);

  const pages = Array.from({ length: pageSize }, (v, k) => k + 1);

  pages.shift();
  console.log('pages: ', pages);

  const leftOrders = await Promise.all(
    pages.map(async (page) => {
      const res = await getOrders({
        accountId: props.accountId,
        OrderProps: {
          ...props.OrderProps,
          page,
          size: 500,
        },
      });

      return res.data.rows;
    })
  );

  console.log('rows', pageOne.data.rows);

  const allOrders = pageOne.data.rows.concat(...leftOrders);
  console.log('allOrders: ', allOrders);

  return allOrders;
};

export const getOrderByClientId = async (props: { accountId: string; client_order_id: string }) => {
  const url = `/v1/client/order/${props.client_order_id}`;

  const res = requestOrderly({
    url,
    accountId: props.accountId,
  });

  return res;
};

export const getOrderByOrderId = async (props: { accountId: string; order_id: number }) => {
  const url = `/v1/order/${props.order_id}`;

  const res = requestOrderly({
    url,
    accountId: props.accountId,
  });

  return res;
};

export const getKline = async (props: {
  accountId: string;
  KlineParams: {
    symbol: string;
    type: '1m' | '5m' | '15m' | '30m' | '1h' | '4h' | '12h' | '1d' | '1w' | '1mon' | '1y';
    limit?: number; //Maximum of 1000 klines.
  };
}) => {
  const url = `/v1/kline?${formateParams(props.KlineParams)}`;

  const res = requestOrderly({
    url,
    accountId: props.accountId,
  });

  return res;
};

export const getOrderBook = async (props: { accountId: string; symbol: string }) => {
  const url = `/v1/orderbook/${props.symbol}`;

  const res = requestOrderly({
    url,
    accountId: props.accountId,
  });

  return res;
};

export const cancelOrder = async (props: {
  accountId: string;
  DeleteParams: {
    symbol: string;
    order_id: number;
  };
}) => {
  const { accountId, DeleteParams } = props;

  const message = formateParams(DeleteParams);

  const signature = generateOrderSignature(accountId, message);

  const url = `/v1/order?${message}&signature=${signature}`;

  return deleteOrderly({
    url,
    accountId,
  });
};

export const cancelOrders = async (props: {
  accountId: string;
  DeleteParams: {
    symbol: string;
  };
}) => {
  const { accountId, DeleteParams } = props;

  const message = formateParams(DeleteParams);

  const signature = generateOrderSignature(accountId, message);

  const url = `/v1/orders?${message}&signature=${signature}`;

  return deleteOrderly({
    url,
    accountId,
  });
};

export const cancelOrderByClientId = async (props: {
  accountId: string;
  DeleteParams: {
    symbol: string;
    client_order_id: string;
  };
}) => {
  const { accountId, DeleteParams } = props;

  const message = formateParams(DeleteParams);

  const signature = generateOrderSignature(accountId, message);

  const url = `/v1/client/order?${message}&signature=${signature}`;

  return deleteOrderly({
    url,
    accountId,
  });
};

export const editOrder = async (props: { accountId: string; orderlyProps: EditOrderlyOrder }) => {
  const { accountId } = props;

  const { symbol, client_order_id, order_type, order_price, order_quantity, order_amount, side, broker_id, visible_quantity, order_id } =
    props.orderlyProps;

  const message = formateParams(props.orderlyProps);

  const signature = generateOrderSignature(accountId, message);

  const body = {
    symbol,
    client_order_id,
    order_type,
    order_price,
    order_quantity,
    order_amount,
    side,
    order_id,
    broker_id,
    visible_quantity,
    signature,
  };

  return await tradingOrderly({
    accountId,
    url: '/v1/order',
    body,
    method: 'PUT',
  });
};

export const batchCreateOrder = async (props: { accountId: string; orderlyProps: OrderlyOrder[] }) => {
  const { accountId } = props;

  //Note for DELETE requests, the parameters are not in the json body.
  // const message = Object.entries(props.orderlyProps)
  //   .filter(([k, v], i) => {
  //     return v !== undefined && v !== null;
  //   })
  //   .map(([k, v], i) => {
  //     if (typeof v === 'number') {
  //       return `${k}=${parseFloat(v.toString())}`;
  //     }
  //     return `${k}=${v}`;
  //   })
  //   .sort()
  //   .join('&');

  const messages = props.orderlyProps.map((p: OrderlyOrder) => formateParams(p));

  const body = messages.map((message, i) => {
    const signature = generateOrderSignature(accountId, message);

    return {
      ...props.orderlyProps[i],
      signature,
    };
  });

  return await tradingOrderly({
    accountId,
    url: '/v1/batch-order',
    body: {
      orders: body,
    },
    method: 'POST',
  });
};

export const getOrderlyPublic = async (url?: string) => {
  return await fetch(`${getOrderlyConfig().OFF_CHAIN_END_POINT}${url || ''}`, {
    method: 'GET',
  })
    .then((res) => {
      return res.json();
    })
    .catch((e) => {
      return e;
    });
};

export const getMarketTrades = async ({ symbol, limit }: { symbol: string; limit: number }) => {
  return await getOrderlyPublic(`/v1/public/market_trades?symbol=${symbol}&limit=${limit}`);
};

'''
'''--- src/orderly/off-chain-ws.ts ---
import useWebSocket, { ReadyState } from 'react-use-websocket';
import React, { useState, useCallback, useEffect, useRef, useMemo, StrictMode } from 'react';
import { OrderlyWSConnection, Orders, MarketTrade, Ticker, MarkPrice, Balance } from './type';
import { getOrderlyConfig } from '../config';
import { useWalletSelectorWindow } from '../WalletSelectorContext';
import { getPublicKey, generateRequestSignatureHeader, toNonDivisibleNumber } from './utils';
import { NotSignInError } from './error';
import { getOrderlyWss } from './constant';
import { parseSymbol } from '../components/RecentTrade/index';
import { useTokenInfo } from './state';
import { getFTmetadata } from '../near';

export const REF_ORDERLY_WS_ID_PREFIX = 'orderly_ws_';

export const useOrderlyWS = () => {
  const [socketUrl, setSocketUrl] = useState(getOrderlyWss(false));

  const [messageHistory, setMessageHistory] = useState<any>([]);

  const { lastMessage, readyState, lastJsonMessage, sendMessage } = useWebSocket(socketUrl);

  useEffect(() => {
    if (lastMessage !== null) {
      setMessageHistory((prev: any) => prev.concat(lastMessage));
    }
  }, [lastMessage, setMessageHistory]);

  const connectionStatus = {
    [ReadyState.CONNECTING]: 'Connecting',
    [ReadyState.OPEN]: 'Open',
    [ReadyState.CLOSING]: 'Closing',
    [ReadyState.CLOSED]: 'Closed',
    [ReadyState.UNINSTANTIATED]: 'Uninstantiated',
  }[readyState];

  return {
    connectionStatus,
    messageHistory,
    lastMessage,
    sendMessage,
    lastJsonMessage,
  };
};
export const usePrivateOrderlyWS = () => {
  const { accountId } = useWalletSelectorWindow();
  const [socketUrl, setSocketUrl] = useState(getOrderlyConfig().ORDERLY_WS_ENDPOINT_PRIVATE + `/${accountId}`);

  useEffect(() => {
    if (!accountId) {
      return;
    } else {
      setSocketUrl(getOrderlyConfig().ORDERLY_WS_ENDPOINT_PRIVATE + `/${accountId}`);
    }
  }, [accountId]);

  const [messageHistory, setMessageHistory] = useState<any>([]);

  const { lastMessage, readyState, lastJsonMessage, sendMessage } = useWebSocket(!accountId ? null : socketUrl);

  useEffect(() => {
    if (lastMessage !== null) {
      setMessageHistory((prev: any) => prev.concat(lastMessage));
    }
  }, [lastMessage, setMessageHistory]);

  const connectionStatus = {
    [ReadyState.CONNECTING]: 'Connecting',
    [ReadyState.OPEN]: 'Open',
    [ReadyState.CLOSING]: 'Closing',
    [ReadyState.CLOSED]: 'Closed',
    [ReadyState.UNINSTANTIATED]: 'Uninstantiated',
  }[readyState];

  return {
    connectionStatus,
    messageHistory,
    lastMessage,
    sendMessage,
    lastJsonMessage,
  };
};

export const generateMarketDataFlow = ({ symbol }: { symbol: string }) => {
  const data: OrderlyWSConnection[] = [
    {
      id: `request-order-${symbol}`,
      event: 'request',
      params: {
        symbol,
        type: 'orderbook',
      },
    },
    {
      id: `${symbol}@orderbookupdate`,
      event: 'subscribe',
      topic: `${symbol}@orderbookupdate`,
    },
    {
      id: `${symbol}@trade-sub`,
      event: 'subscribe',
      topic: `${symbol}@trade`,
    },
    {
      id: `${symbol}@trade-req`,
      event: 'request',
      topic: `${symbol}@trade`,
      params: {
        type: 'trade',
        symbol,
        limit: 50,
      },
    },
    {
      id: `markprices`,
      event: 'subscribe',
      topic: `markprices`,
      ts: Date.now(),
    },
    {
      id: `tickers`,
      event: 'subscribe',
      topic: `tickers`,
    },
  ];

  return data;
};
export const initDataFlow = ({ symbol }: { symbol: string }) => {
  let data: OrderlyWSConnection[] = [
    {
      id: `request-order-${symbol}`,
      event: 'request',
      params: {
        symbol,
        type: 'orderbook',
      },
    },
    {
      topic: `${symbol}@kline_1m`,
      event: 'subscribe',
      id: `${symbol}@kline_1m`,
    },
  ];

  return data;
};

const preSubScription = new Map<string, OrderlyWSConnection>();

export const useOrderlyMarketData = ({ symbol }: { symbol: string }) => {
  const { lastJsonMessage, sendMessage } = useOrderlyWS();

  const [orders, setOrders] = useState<Orders>();

  const [ticker, setTicker] = useState<Ticker>();

  const [allTickers, setAllTickers] = useState<Ticker[]>();

  const [marketTrade, setMarketTrade] = useState<MarketTrade>();

  const [markPrices, setMarkPrices] = useState<MarkPrice[]>();

  // subscribe
  useEffect(() => {
    const msgFlow = generateMarketDataFlow({
      symbol,
    });

    msgFlow.forEach((msg) => {
      const id = msg.id;

      if (!id) return;

      if (preSubScription.has(id + '|' + symbol)) {
        // unsubscribe

        if ('unsubscribe' in msg) {
          sendMessage(
            JSON.stringify({
              ...msg,
              event: 'unsubscribe',
            })
          );
          preSubScription.delete(id + '|' + symbol);
        }
      }

      preSubScription.set(id + '|' + symbol, msg);

      sendMessage(JSON.stringify(msg));
    });
  }, [symbol]);

  // onmessage
  useEffect(() => {
    // update orderbook

    if (lastJsonMessage?.event === 'ping') {
      sendMessage(JSON.stringify({ event: 'pong', ts: Date.now() + 500 }));
    }

    if (lastJsonMessage?.id === `request-order-${symbol}` && lastJsonMessage?.event === 'request') {
      setOrders(lastJsonMessage.data);
    }

    // process orderbook update
    if (lastJsonMessage?.topic === `${symbol}@orderbookupdate` && !!orders) {
      console.log('lastJsonMessage: ', lastJsonMessage);
      // setOrders(lastJsonMessage.data);

      let asks = orders.asks;
      console.log('asks11111: ', asks);

      lastJsonMessage.data.asks.forEach((ask: number[]) => {
        const price = ask[0];
        const quantity = ask[1];
        const index = asks.findIndex((a) => a[0] === price);

        if (index === -1) {
          asks.push(ask);
        } else {
          if (quantity === 0) {
            asks.splice(index, 1);
          } else {
            asks[index] = ask;
          }
        }
      });

      let bids = orders.bids;

      lastJsonMessage.data.bids.forEach((bid: number[]) => {
        const price = bid[0];
        const quantity = bid[1];
        const index = bids.findIndex((a) => a[0] === price);

        if (index === -1) {
          bids.push(bid);
        } else {
          if (quantity === 0) {
            bids.splice(index, 1);
          } else {
            bids[index] = bid;
          }
        }
      });

      setOrders({
        ...orders,
        asks: asks.sort((a1, a2) => a1[0] - a2[0]),
        bids: bids.sort((b1, b2) => b2[0] - b1[0]),
        ts: lastJsonMessage.ts,
      });
    }

    //  process trade
    if ((lastJsonMessage?.id && lastJsonMessage?.id.includes(`${symbol}@trade`)) || lastJsonMessage?.topic === `${symbol}@trade`) {
      if (lastJsonMessage?.event === 'request') {
        setMarketTrade({ ...lastJsonMessage.data[0], symbol });
      } else
        setMarketTrade({
          ...lastJsonMessage.data,
          symbol,
        });
    }

    if (lastJsonMessage?.topic === 'tickers') {
      const tickers = lastJsonMessage.data;

      setAllTickers(tickers);

      const ticker = tickers.find((t: Ticker) => t.symbol === symbol);

      if (ticker) setTicker(ticker);
    }

    if (lastJsonMessage?.topic === 'markprices') {
      const markPrices = lastJsonMessage.data;

      setMarkPrices(markPrices);
    }
  }, [lastJsonMessage, symbol]);

  return {
    lastJsonMessage,
    marketTrade,
    orders,
    ticker,
    markPrices,
    allTickers,
  };
};

export const useOrderlyPrivateData = ({ validAccountSig }: { validAccountSig: boolean }) => {
  const { connectionStatus, messageHistory, lastMessage, sendMessage, lastJsonMessage } = usePrivateOrderlyWS();

  const [authPass, setAuthPass] = useState(false);
  const { accountId } = useWalletSelectorWindow();

  const [balances, setBalances] = useState<Record<string, Balance>>({});

  const [orderlyKey, setOrderlyKey] = useState('');

  const [requestSignature, setRequestSignature] = useState('');

  const time_stamp = useMemo(() => Date.now(), []);

  useEffect(() => {
    if (!accountId || !validAccountSig) return;

    generateRequestSignatureHeader({
      accountId,
      time_stamp,
      url: null,
      body: null,
    }).then(setRequestSignature);
  }, [accountId, validAccountSig]);

  useEffect(() => {
    if (!accountId) return;

    getPublicKey(accountId).then((res) => {
      setOrderlyKey(res);
    });
  }, [accountId]);

  useEffect(() => {
    if (!orderlyKey || !requestSignature || !validAccountSig) return;

    const authData = {
      id: 'auth',
      event: 'auth',
      params: {
        timestamp: time_stamp,
        sign: requestSignature,
        orderly_key: orderlyKey,
      },
    };

    sendMessage(JSON.stringify(authData));
  }, [orderlyKey, requestSignature, accountId, validAccountSig]);

  useEffect(() => {
    if (lastJsonMessage && lastJsonMessage.event === 'auth' && lastJsonMessage.success === true) {
      setAuthPass(true);
    }

    if (lastJsonMessage?.event === 'ping') {
      sendMessage(JSON.stringify({ event: 'pong', ts: Date.now() + 500 }));
    }

    if (lastJsonMessage?.topic === 'balance') {
      setBalances(lastJsonMessage.data.balances);
    }
  }, [lastJsonMessage]);

  useEffect(() => {
    if (!authPass) return;

    sendMessage(
      JSON.stringify({
        id: 'balance',
        topic: 'balance',
        event: 'subscribe',
      })
    );
  }, [authPass]);

  return {
    balances,
  };
};

'''
'''--- src/orderly/on-chain-api.ts ---
import { providers, KeyPair, connect, WalletConnection } from 'near-api-js';

import { addKey, AddKey, functionCallAccessKey } from 'near-api-js/lib/transaction';

import { PublicKey } from 'near-api-js/lib/utils';
import { near, orderlyViewFunction, config, ORDERLY_ASSET_MANAGER, keyStore } from '../near';
import { getNormalizeTradingKey, getPublicKey } from './utils';
import { find_orderly_functionCall_key, STORAGE_TO_REGISTER_WITH_MFT } from './utils';
import getConfig from '../config';
import { BN } from 'bn.js';
import { ONE_YOCTO_NEAR } from '../near';
import { formatNearAmount, parseNearAmount } from 'near-api-js/lib/utils/format';

export const REGISTER_DEPOSIT_AMOUNT = '0.05';

const is_token_listed = async (token: string) => {
  return orderlyViewFunction({
    methodName: 'is_token_listed',
    args: {
      token,
    },
  });
};

//retrieve a list of whitelisted tokens supported by Orderly use the following method
const get_listed_tokens = async () => {
  return orderlyViewFunction({
    methodName: 'get_listed_tokens',
  });
};

const user_account_exists = async (user: string) => {
  return orderlyViewFunction({
    methodName: 'user_account_exists',
    args: {
      user,
    },
  });
};

const is_orderly_key_announced = async (user: string) => {
  const orderly_key = await getPublicKey(user);

  return orderlyViewFunction({
    methodName: 'is_orderly_key_announced',
    args: {
      user,
      orderly_key,
    },
  });
};

const is_trading_key_set = async (user: string) => {
  const orderly_key = await getPublicKey(user);

  return orderlyViewFunction({
    methodName: 'is_trading_key_set',
    args: {
      user,
      orderly_key,
    },
  });
};

const is_symbol_listed = async (pair_symbol: string) => {
  return orderlyViewFunction({
    methodName: 'is_symbol_listed',
    args: {
      pair_symbol,
    },
  });
};

const get_user_trading_key = async (user: string) => {
  const orderly_key = (await keyStore.getKey(getConfig().networkId, user)).getPublicKey().toString();

  if (!orderly_key) throw new Error('Orderly key not found while viewing get_user_trading_key');

  return orderlyViewFunction({
    methodName: 'get_user_trading_key',
    args: {
      user,
      orderly_key: orderly_key,
    },
  });
};

const orderly_storage_deposit = (account_id: string, amount: string = '0.05', registration_only: boolean = false) => {
  return {
    methodName: 'storage_deposit',
    args: {
      registration_only,
      account_id,
    },
    gas: '30000000000000',
    amount,
  };
};

const user_announce_key = () => {
  return {
    methodName: 'user_announce_key',
    gas: '30000000000000',
  };
};

const user_request_set_trading_key = () => {
  const key = getNormalizeTradingKey();

  return {
    methodName: 'user_request_set_trading_key',
    args: {
      key,
    },
    gas: '30000000000000',
  };
};

const storage_withdraw = async (amount: string) => {
  return {
    methodName: 'storage_withdraw',
    args: {
      amount,
    },
    gas: '30000000000000',
  };
};

const storage_balance_bounds = async () => {
  return orderlyViewFunction({
    methodName: 'storage_balance_bounds',
  });
};

const storage_balance_of = async (account_id: string) => {
  return orderlyViewFunction({
    methodName: 'storage_balance_of',
    args: {
      account_id,
    },
  });
};

const get_cost_of_announce_key = () => {
  return orderlyViewFunction({
    methodName: 'storage_cost_of_announce_key',
  });
};

const get_storage_deposit_amount = async (accountId: string) => {
  // const min_amount = (await storage_balance_bounds()).min;

  const my_storage_balance = (await storage_balance_of(accountId)) || '0';

  const to_be_added_amount = new BN(parseNearAmount('0.05') || '0').sub(new BN(my_storage_balance?.available || '0'));

  if (to_be_added_amount.lte(new BN(0))) return null;

  return to_be_added_amount.toString();
};

// deposit near into a wallet
const user_deposit_native_token = async (amount: string) => {
  return {
    methodName: 'user_deposit_native_token',
    args: {},
    gas: '30000000000000',
    amount,
  };
};

const deposit_exact_token = async (amount: string) => {
  return {
    methodName: 'ft_transfer_call',
    args: {
      receiver_id: ORDERLY_ASSET_MANAGER,
      msg: '',
      amount,
    },
    gas: '300000000000000',
    amount: ONE_YOCTO_NEAR,
  };
};

const user_request_withdraw = async (token: string, amount: string) => {
  return {
    methodName: 'user_request_withdraw',
    args: {
      amount,
      token,
    },
    gas: '30000000000000',
  };
};

export {
  get_user_trading_key,
  get_listed_tokens,
  is_symbol_listed,
  is_token_listed,
  user_account_exists,
  orderly_storage_deposit,
  user_announce_key,
  user_request_set_trading_key,
  storage_balance_bounds,
  storage_balance_of,
  storage_withdraw,
  user_deposit_native_token,
  deposit_exact_token,
  user_request_withdraw,
  get_storage_deposit_amount,
  get_cost_of_announce_key,
  is_orderly_key_announced,
  is_trading_key_set,
};

'''
'''--- src/orderly/state.ts ---
import React, { useState, useEffect, useRef, useCallback } from 'react';
import { Trade, TokenInfo, MyOrder, MarketTrade, Orders } from './type';
import { getMarketTrades, getOrderlyPublic, getOpenOrders, getAllOrders } from './off-chain-api';
import { useWalletSelectorWindow } from '../WalletSelectorContext';
import { checkStorageDeposit } from './api';
import { is_orderly_key_announced, is_trading_key_set } from './on-chain-api';

export function useMarketTrades({ symbol, limit, marketTrade }: { symbol: string; limit: number; marketTrade: MarketTrade | undefined }) {
  console.log('marketTrade111: ', marketTrade);
  const [trades, setTrades] = useState<Trade[]>([]);

  const setFunc = useCallback(async () => {
    try {
      const res = await getMarketTrades({ symbol, limit });
      setTrades(res?.data?.rows);
    } catch (error) {}
  }, [symbol, limit]);

  useEffect(() => {
    setFunc();
  }, [setFunc, marketTrade]);

  return trades;
}

export function usePendingOrders({ symbol, refreshingTag }: { symbol: string; refreshingTag: boolean }) {
  const [liveOrders, setLiveOrders] = useState<MyOrder[]>([]);

  const { accountId } = useWalletSelectorWindow();

  const setFunc = useCallback(async () => {
    if (accountId === null) return;
    try {
      const pendingOrders = await getOpenOrders({
        accountId,
      });

      setLiveOrders(pendingOrders.data.rows);
    } catch (error) {}
  }, [refreshingTag, symbol]);

  useEffect(() => {
    setFunc();
  }, [refreshingTag, symbol, setFunc]);

  return liveOrders.filter((o) => o.symbol === symbol);
}

export function useAllOrdersSymbol({ symbol, refreshingTag }: { symbol: string; refreshingTag: boolean }) {
  const [liveOrders, setLiveOrders] = useState<MyOrder[]>();

  const { accountId } = useWalletSelectorWindow();

  const setFunc = useCallback(async () => {
    if (accountId === null) return;
    try {
      const allOrders = await getAllOrders({
        accountId,
        OrderProps: {
          size: 200,
          symbol,
        },
      });

      setLiveOrders(allOrders);
    } catch (error) {}
  }, [refreshingTag, symbol]);

  useEffect(() => {
    setFunc();
  }, [refreshingTag, symbol, setFunc]);

  return liveOrders;
}

export function useAllOrders({ refreshingTag }: { refreshingTag: boolean }) {
  const [liveOrders, setLiveOrders] = useState<MyOrder[]>();

  const { accountId } = useWalletSelectorWindow();

  const setFunc = useCallback(async () => {
    if (accountId === null) return;
    try {
      const allOrders = await getAllOrders({
        accountId,
        OrderProps: {
          size: 200,
        },
      });

      setLiveOrders(allOrders);
    } catch (error) {}
  }, [refreshingTag]);

  useEffect(() => {
    setFunc();
  }, [refreshingTag, setFunc]);

  return liveOrders;
}

export function useTokenInfo() {
  const [tokenInfo, setTokenInfo] = useState<TokenInfo[]>();

  useEffect(() => {
    getOrderlyPublic('/v1/public/token').then((res) => {
      setTokenInfo(res?.data?.rows);
    });
  }, []);

  return tokenInfo;
}

export function useStorageEnough() {
  const { accountId } = useWalletSelectorWindow();

  const [storageEnough, setStorageEnough] = useState<boolean | undefined>(undefined);

  useEffect(() => {
    if (!accountId) setStorageEnough(false);
    else {
      checkStorageDeposit(accountId).then(setStorageEnough);
    }
  }, [accountId]);

  return storageEnough;
}

export function useOrderlyRegistered() {
  const { accountId } = useWalletSelectorWindow();

  const [registered, setRegistered] = useState<{
    key_announce: boolean;
    trading_key_set: boolean;
  }>({
    key_announce: false,
    trading_key_set: false,
  });

  useEffect(() => {
    if (!accountId) return;
    is_orderly_key_announced(accountId)
      .then((key_announce) => {
        return key_announce;
      })
      .then((key_announce) => {
        is_trading_key_set(accountId).then((trading_key_set) => {
          setRegistered({
            key_announce,
            trading_key_set,
          });
        });
      });
  }, [accountId]);

  return registered;
}

'''
'''--- src/orderly/type.ts ---
export type orderStatus = 'NEW' | 'CANCELLED' | 'REJECTED' | 'COMPLETED' | 'FILLED' | 'PARTIAL_FILLED' | 'INCOMPLETE';

export interface OrderlyOrder {
  symbol: string;
  client_order_id?: string;
  order_type: 'LIMIT' | 'MARKET' | 'IOC' | 'FOK' | 'POST_ONLY' | 'ASK' | 'BID';
  order_price?: string | number;
  order_quantity?: string | number;
  order_amount?: number;
  side: 'BUY' | 'SELL';
  broker_id?: string;
  visible_quantity?: number;
}

export interface MyOrder {
  order_id: number;
  user_id: number;
  price: number;
  type: 'LIMIT' | 'MARKET';
  quantity: number;
  amount?: any;
  executed: number;
  visible: number;
  symbol: string;
  side: 'BUY' | 'SELL';
  status: orderStatus;
  total_fee: number;
  fee_asset: string;
  client_order_id?: any;
  average_executed_price: number;
  broker_id: string;
  created_time: number;
  updated_time: number;
}

export interface EditOrderlyOrder extends OrderlyOrder {
  order_id: number;
}

export interface OrderlyWSConnection extends Record<string, any> {
  id?: string;
  event: 'ping' | 'auth' | 'request' | 'subscribe' | 'unsubscribe';
  topic?: string;
  params?: any;
}

export interface Orders {
  symbol: string;
  ts: number;
  asks: number[][];
  bids: number[][];
}

export interface MarketTrade {
  symbol: string;
  price: number;
  size: number;
  side: 'BUY' | 'SELL';
  ts: number;
}

export interface Trade {
  symbol: string;
  side: 'BUY' | 'SELL';
  executed_price: number;
  executed_quantity: number;
  executed_timestamp: number;
}

export interface TokenMetadata {
  id: string;
  name: string;
  symbol: string;
  decimals: number;
  icon: string;
}

export interface Ticker {
  symbol: string;
  open: number;
  close: number;
  high: number;
  low: number;
  volume: number;
  amount: number;
  count: number;
  symbol_from_token_meta?: TokenMetadata;
  symbol_to_token_meta?: TokenMetadata;
}

export interface TokenInfo {
  token: string;
  token_account_id: string;
  decimals: number;
  minimum_increment: number;
}

export interface Holding {
  token: string;
  holding: number;
  frozen: number;
  pending_short: number;
  updated_time: number;
}

export interface ClientInfo {
  account_id: string;
  email: string;
  account_mode: string;
  tier: string;
  taker_fee_rate: number;
  maker_fee_rate: number;
  maintenance_cancel_orders: boolean;
}

export interface MarkPrice {
  symbol: string;
  price: number;
}

export interface Balance {
  holding: number;
  frozen: number;
  interest: number;
  pendingShortQty: number;
  pendingExposure: number;
  pendingLongQty: number;
  pendingLongExposure: number;
  version: number;
  staked: number;
  unbonding: number;
  vault: number;
  averageOpenPrice: number;
  pnl24H: number;
  fee24H: number;
  markPrice: number;
}

export interface OrderTrade {
  id: number;
  symbol: string;
  fee: number;
  fee_asset: string;
  side: string;
  order_id: number;
  executed_price: number;
  executed_quantity: number;
  executed_timestamp: number;
  is_maker: number;
}

export interface SymbolInfo {
  created_time: number;
  updated_time: number;
  symbol: string;
  quote_min: number;
  quote_max: number;
  quote_tick: number;
  base_min: number;
  base_max: number;
  base_tick: number;
  min_notional: number;
  price_range: number;
}
export interface OrderlyBalance {
  holding: number;
  frozen: number;
  interest: number;
  pendingShortQty: number;
  pendingExposure: number;
  pendingLongQty: number;
  pendingLongExposure: number;
  version: number;
  staked: number;
  unbonding: number;
  vault: number;
  averageOpenPrice: number;
  pnl24H: number;
  fee24H: number;
  markPrice: number;
}

export interface UserRecord {
  id: string;
  uuid: string;
  token: string;
  side: 'DEPOSIT' | 'WITHDRAW';
  amount: number;
  tx_id: string;
  fee: number;
  trans_status: string;
  created_time: number;
  updated_time: number;
}

'''
'''--- src/orderly/utils.ts ---
import { ec } from 'elliptic';
import { near, config, orderlyViewFunction, keyStore } from '../near';
import getConfig from '../config';
import bs58 from 'bs58';
import { base_decode, base_encode } from 'near-api-js/lib/utils/serialize';
import keccak256 from 'keccak256';
import { Buffer } from 'buffer';
import { KeyPair, keyStores } from 'near-api-js';
import { NotSignInError } from './error';

export const tradingKeyMap = new Map();

export const get_orderly_private_key_path = () => `orderly-trading-key-private:${getConfig().networkId}`;

export const get_orderly_public_key_path = () => `orderly-trading-key-public:${getConfig().networkId}`;

export const STORAGE_TO_REGISTER_WITH_MFT = '0.1';

export type OFF_CHAIN_METHOD = 'POST' | 'GET' | 'DELETE' | 'PUT';

export const generateTradingKeyPair = () => {
  const EC = new ec('secp256k1');

  const accountId = window.selectorAccountId;

  if (!accountId) throw NotSignInError;

  const keyPair = EC.genKeyPair();

  const privateKey = keyPair.getPrivate().toString('hex');

  const publicKey = keyPair.getPublic().encode('hex', false).replace('04', '');

  localStorage.setItem(get_orderly_private_key_path(), privateKey);

  localStorage.setItem(get_orderly_public_key_path(), publicKey);

  tradingKeyMap.set(get_orderly_private_key_path(), privateKey);

  tradingKeyMap.set(get_orderly_public_key_path(), publicKey);

  return {
    privateKey,
    publicKey,
    keyPair,
  };
};

export const getNormalizeTradingKey = () => {
  const tradingKeyPair = generateTradingKeyPair();

  const pubKeyAsHex = tradingKeyPair.publicKey.replace('04', '');
  const normalizeTradingKey = window.btoa(keccak256(pubKeyAsHex).toString('hex'));

  return normalizeTradingKey;
};

// call to set trading_key
// await contract.user_request_set_trading_key({ key: normalizeTradingKey });

export const find_orderly_functionCall_key = async (accountId: string) => {
  const nearConnection = await near.account(accountId);

  const allKeys = await nearConnection.getAccessKeys();

  const orderlyKey = allKeys.find(
    (key) => key.access_key.permission !== 'FullAccess' && key.access_key.permission.FunctionCall.receiver_id === config.ORDERLY_ASSET_MANAGER
  );

  return orderlyKey;
};

export const getPublicKey = async (accountId: string) => {
  const publicKey = (await keyStore.getKey(getConfig().networkId, accountId)).getPublicKey().toString();

  return publicKey;
};

export const getLocalPrivateKey = (accountId: string, prefix: string = 'near-api-js') => {
  return localStorage.getItem(`${prefix}:keystore:${accountId}:${getConfig().networkId}`);
};

// get signature function

export const generateMessage = (time_stamp: number, method: OFF_CHAIN_METHOD | undefined, url: string | null, body: object | null) => {
  return !!body ? `${time_stamp}${method || ''}${url || ''}${JSON.stringify(body)}` : `${time_stamp}${method || ''}${url || ''}`;
};

export const generateRequestSignatureHeader = async ({
  accountId,
  time_stamp,
  url,
  body,
  method,
}: {
  accountId: string;
  time_stamp: number;
  url: string | null;
  body: object | null;
  method?: OFF_CHAIN_METHOD;
}) => {
  const message = generateMessage(time_stamp, method, url, body);

  const keyStore = new keyStores.BrowserLocalStorageKeyStore();

  const keyPair = await keyStore.getKey(getConfig().networkId, accountId);

  const signature = keyPair.sign(Buffer.from(message)).signature;

  // return atob(signature.toString());

  return new Buffer(signature).toString('base64').replace(/\+/g, '-').replace(/\//g, '_');
};

export const generateOrderSignature = (accountId: string, message: string) => {
  const msgHash = new Buffer(keccak256(message)).toString('hex');

  const storedPrivateKey = localStorage.getItem(get_orderly_private_key_path());

  if (!storedPrivateKey) {
    localStorage.setItem(get_orderly_private_key_path(), tradingKeyMap.get(get_orderly_private_key_path()) || '');
  }

  const priKey = tradingKeyMap.get(get_orderly_private_key_path()) || localStorage.getItem(get_orderly_private_key_path());

  if (!priKey) {
    alert('Please generate trading key first');
    return;
  }

  const EC = new ec('secp256k1');

  const keyPair = EC.keyFromPrivate(priKey, 'hex');

  // console.log(pubKey, keyPair.getPublic().encode('hex', false));

  const signature = keyPair.sign(msgHash, 'hex', { canonical: true });

  const finalSignature = signature.r.toString('hex', 64) + signature.s.toString('hex', 64) + '0' + signature.recoveryParam;

  return finalSignature;
};

export const formateParams = (props: object) => {
  const message = Object.entries(props)
    .filter(([k, v], i) => {
      return v !== undefined && v !== null;
    })
    .map(([k, v], i) => {
      if (typeof v === 'number') {
        return `${k}=${parseFloat(v.toString())}`;
      }
      return `${k}=${v}`;
    })
    .sort()
    .join('&');

  return message;
};

export const formateParamsNoSorting = (props: object) => {
  const message = Object.entries(props)
    .filter(([k, v], i) => {
      return v !== undefined && v !== null;
    })
    .map(([k, v], i) => {
      if (typeof v === 'number') {
        return `${k}=${parseFloat(v.toString())}`;
      }
      return `${k}=${v}`;
    })
    .join('&');

  return message;
};

export const toReadableNumber = (decimals: number, number: string = '0'): string => {
  if (!decimals) return number;

  const wholeStr = number.substring(0, number.length - decimals) || '0';
  const fractionStr = number
    .substring(number.length - decimals)
    .padStart(decimals, '0')
    .substring(0, decimals);

  return `${wholeStr}.${fractionStr}`.replace(/\.?0+$/, '');
};

export const toNonDivisibleNumber = (decimals: number, number: string): string => {
  if (decimals === null || decimals === undefined) return number;
  const [wholePart, fracPart = ''] = number.split('.');

  return `${wholePart}${fracPart.padEnd(decimals, '0').slice(0, decimals)}`.replace(/^0+/, '').padStart(1, '0');
};

export const getAccountName = (accountId: string) => {
  const [account, network] = accountId.split('.');
  const niceAccountId = `${account.slice(0, 10)}...${network || ''}`;

  return account.length > 10 ? niceAccountId : accountId;
};

'''
'''--- src/react-app-env.d.ts ---
/// <reference types="react-scripts" />

'''
'''--- src/serviceWorker.ts ---
// This optional code is used to register a service worker.
// register() is not called by default.

// This lets the app load faster on subsequent visits in production, and gives
// it offline capabilities. However, it also means that developers (and users)
// will only see deployed updates on subsequent visits to a page, after all the
// existing tabs open on the page have been closed, since previously cached
// resources are updated in the background.

// To learn more about the benefits of this model and instructions on how to
// opt-in, read https://bit.ly/CRA-PWA

const isLocalhost = Boolean(
  window.location.hostname === 'localhost' ||
  // [::1] is the IPv6 localhost address.
  window.location.hostname === '[::1]' ||
  // 127.0.0.0/8 are considered localhost for IPv4.
  window.location.hostname.match(
    /^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/
  )
);

type Config = {
  onSuccess?: (registration: ServiceWorkerRegistration) => void;
  onUpdate?: (registration: ServiceWorkerRegistration) => void;
};

export function register(config?: Config) {
  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {
    // The URL constructor is available in all browsers that support SW.
    const publicUrl = new URL(
      process.env.PUBLIC_URL,
      window.location.href
    );
    if (publicUrl.origin !== window.location.origin) {
      // Our service worker won't work if PUBLIC_URL is on a different origin
      // from what our page is served on. This might happen if a CDN is used to
      // serve assets; see https://github.com/facebook/create-react-app/issues/2374
      return;
    }

    window.addEventListener('load', () => {
      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;

      if (isLocalhost) {
        // This is running on localhost. Let's check if a service worker still exists or not.
        checkValidServiceWorker(swUrl, config);

        // Add some additional logging to localhost, pointing developers to the
        // service worker/PWA documentation.
        navigator.serviceWorker.ready.then(() => {
          console.log(
            'This web app is being served cache-first by a service ' +
            'worker. To learn more, visit https://bit.ly/CRA-PWA'
          );
        });
      } else {
        // Is not localhost. Just register service worker
        registerValidSW(swUrl, config);
      }
    });
  }
}

function registerValidSW(swUrl: string, config?: Config) {
  navigator.serviceWorker
    .register(swUrl)
    .then(registration => {
      registration.onupdatefound = () => {
        const installingWorker = registration.installing;
        if (installingWorker == null) {
          return;
        }
        installingWorker.onstatechange = () => {
          if (installingWorker.state === 'installed') {
            if (navigator.serviceWorker.controller) {
              // At this point, the updated precached content has been fetched,
              // but the previous service worker will still serve the older
              // content until all client tabs are closed.
              console.log(
                'New content is available and will be used when all ' +
                'tabs for this page are closed. See https://bit.ly/CRA-PWA.'
              );

              // Execute callback
              if (config && config.onUpdate) {
                config.onUpdate(registration);
              }
            } else {
              // At this point, everything has been precached.
              // It's the perfect time to display a
              // "Content is cached for offline use." message.
              console.log('Content is cached for offline use.');

              // Execute callback
              if (config && config.onSuccess) {
                config.onSuccess(registration);
              }
            }
          }
        };
      };
    })
    .catch(error => {
      console.error('Error during service worker registration:', error);
    });
}

function checkValidServiceWorker(swUrl: string, config?: Config) {
  // Check if the service worker can be found. If it can't reload the page.
  fetch(swUrl, {
    headers: { 'Service-Worker': 'script' }
  })
    .then(response => {
      // Ensure service worker exists, and that we really are getting a JS file.
      const contentType = response.headers.get('content-type');
      if (
        response.status === 404 ||
        (contentType != null && contentType.indexOf('javascript') === -1)
      ) {
        // No service worker found. Probably a different app. Reload the page.
        navigator.serviceWorker.ready.then(registration => {
          registration.unregister().then(() => {
            window.location.reload();
          });
        });
      } else {
        // Service worker found. Proceed as normal.
        registerValidSW(swUrl, config);
      }
    })
    .catch(() => {
      console.log(
        'No internet connection found. App is running in offline mode.'
      );
    });
}

export function unregister() {
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.ready
      .then(registration => {
        registration.unregister();
      })
      .catch(error => {
        console.error(error.message);
      });
  }
}
'''
'''--- src/setupTests.ts ---
// jest-dom adds custom jest matchers for asserting on DOM nodes.
// allows you to do things like:
// expect(element).toHaveTextContent(/react/i)
// learn more: https://github.com/testing-library/jest-dom
import '@testing-library/jest-dom/extend-expect';
'''
'''--- src/styles/tailwind.css ---
@tailwind base;

/* Your own custom base styles */

/* Start purging... */
@tailwind components;
/* Stop purging. */

/* Your own custom component styles */

/* Start purging... */
@tailwind utilities;
/* Stop purging. */

/* Your own custom utilities */

'''
'''--- src/utiles.ts ---
import { toPrecision } from './near';
export function digitWrapper(digit: string, precision: number) {
  const minStr = '0.' + '0'.repeat(precision - 1) + '1';

  if (Number(digit) < Number(minStr) && Number(digit) > 0) {
    return '< ' + minStr;
  } else return toPrecision(digit, precision);
}

'''
'''--- tailwind.config.js ---
/** @type {import('tailwindcss').Config} */
module.exports = {
  theme: {
    screens: {
      xs: { min: '300px', max: '600px' },
      xsm: { min: '300px', max: '1023px' },
      md: { min: '600px', max: '1023px' },
      lg: { min: '1024px' },
      lg2: { min: '1092px' },
      xl: { min: '1280px' },
      '2xl': { min: '1536px' },
      '3xl': { min: '1792px' },
    },
    extend: {
      backgroundImage: (theme) => ({
        farmSearch: 'linear-gradient(106.25deg, #00FFD1 6.88%, #00BA98 81.93%)',
        veCardGradient: 'linear-gradient(0deg, #001320 -2.77%, #1D2932 100%)',
        poolDaoBanner: 'linear-gradient(0deg, #1D2932 0%, #00A385 100%)',
        redGradient: 'linear-gradient(270deg, #7F43FF 0%, #FF8B8B 97.06%)',
        sellGradientRed: 'linear-gradient(180deg, #944A8C 0%, #D26060 100%)',
        buyGradientGreen: 'linear-gradient(180deg, #00C6A2 0%, #008B72 100%)',
        buyGradientGreenOpacity: 'linear-gradient(180deg,rgba(0,198,162,0.3) 0%, rgba(0,139,114,0.3) 100%)',
        greenPopUpGradient: 'linear-gradient(180deg, #5EFFEC 0%, #9CFFE7 100%)',
        RedPopUpGradient: 'linear-gradient(180deg, #FFA5DB 0%, #FFDCF1 100%);',
        veReverseGradient: 'linear-gradient(270deg, rgba(127, 67, 255, 0.3) 0%, rgba(0, 198, 162, 0.3) 97.06%)',
        veCardGradientRight: 'linear-gradient(270deg, #001320 0%, #1D2932 95.06%)',
        veUserCard: 'linear-gradient(270deg, #001320 0%, #1D2932 95.06%);',
        veVotingPowerCard: 'linear-gradient(90deg, #00FFD1 0%, #009277 100%)',
        veFarmBoostCard: 'linear-gradient(90deg, #7C47FD 0%, #34177C 100%)',
        veGradient: 'linear-gradient(270deg, #7F43FF 0%, #00977C 97.06%);',
        stableTab: 'linear-gradient(180deg, #00C6A2 0%, #008B72 100%)',
        primaryGradient: 'linear-gradient(180deg, #00C6A2 0%, #008B72 100%)',
        buttonGradientBg: 'linear-gradient(180deg, #00C6A2 0%, #008B72 100%)',
        buttonGradientBgOpacity: 'linear-gradient(180deg, rgba(0,198,162,0.8) 0%, rgba(0,139,114,0.8) 100%)',
        limitOrderButtonHover: 'linear-gradient(180deg, #2F404D 0%, #233039 100%)',
        darkGradientBg: 'linear-gradient(180deg, #1D2932 0%, #001320 100%)',
        orderGradient: 'linear-gradient(180deg, #455765 0%, #223746 100%)',
        orderGraidentHover: 'linear-gradient(180deg, #62798A 0%, #334B5E 100%)',
        grayBoderGradient: 'linear-gradient(180deg, rgba(126, 138, 147, 0.2) 0%, rgba(3, 5, 5, 0.2) 100%)',
        grayBoderGradientReverse: 'linear-gradient(0deg, rgba(126, 138, 147, 0.2) 0%, rgba(3, 5, 5, 0.2) 100%)',
        greenPurpleGradient: 'linear-gradient(270deg, #7F43FF 0%, #00C6A2 97.06%)',
        darkGradientHoverBg: 'linear-gradient(180deg, #24313A 0%, #14212B 100%)',
        switchButtonGradientBg: 'linear-gradient(90deg, #00C6A2 24.14%, #008B72 72.41%)',
        unLockedbg: 'linear-gradient(180deg, #FFB36D 0%, #D27E00 100%)',
        boostBg: 'linear-gradient(180deg, rgba(0, 0, 0, 0.2) 0%, rgba(0, 0, 0, 0) 100%)',
        v2boostBg: 'linear-gradient(360deg, rgba(0, 19, 32, 0) 6.2%, #1D2932 100%)',
        boostUpBoxBg: 'linear-gradient(0deg, #273A46 0%, #15232D 100%)',
        bgGreyDefault: 'linear-gradient(180deg, #C0B1A3 0%, #92877D 100%)',
        bgGreyHover: 'linear-gradient(180deg, #E6D6C7 0%, #92877D 100%)',
        swapCardGradient: 'linear-gradient(180deg, #222F37 0%, #192229 100%)',
        orderMobileTop: 'linear-gradient(180deg, #1D2933 0%, #283A46 100%)',
        switchIconBgColor: 'linear-gradient(180deg, #222F37 0%, #192229 100%)',
        unLoginButtonBgColor: 'linear-gradient(rgba(0, 198, 162, 0.3) 0%, rgba(0, 139, 114, 0.3) 100%)',
        starPoolBg: 'linear-gradient(180deg, #374F5E 0%, #1D2932 100%)',
        poolBanner: 'linear-gradient(180deg, #001320 0%, #142B38 100%)',
      }),
      colors: {
        boxBorder: '#1D2932',
        orderTipBg: 'rgba(29, 41, 50, 1)',
        primary: '#7E8A93',
        sellRed: '#F96767',

        buyGreen: '#90E3B9',
        cardBg: '#101D26',
        orderTypeBg: '#344B5C',
        border2: '#25323C',
        border3: '#293844',
        border4: 'rgba(23, 35, 39, 1)',
        withdrawPurple: '#4627FF',
        warn: '#FFA24D',
        darkBg: '#222F38',
        borderC: '#304352',
        greenLight: '#00FFD1',
        redLight: '#FF9FD8',
        symbolHover: 'rgba(126, 138, 147, 0.15)',
        grayBgLight: 'rgba(126, 138, 147, 0.5)',
        symbolHover2: '#1C272F',
        symbolHover3: 'rgba(126, 138, 147, 0.1)',
        feeColor: 'rgba(18, 34, 43, 1)',
        errorTip: 'rgba(249, 103, 103, 0.15)',
        textRed: '#FF7575',
        baseGreen: '#00C6A2',
        orderLineHover: '#14222D',
        dark2: '#071C2B',
        dark3: '#39454E',
        dark4: '#2B3A45',
        dark5: '#273640',
        light1: ' rgba(126, 138, 147, 0.5)',
        allOrderHeader: '#26333E',
        withdrawPurple2: '#443F67',
        gray1: '#23313C',
        gray2: '#91A2AE',
        txBlue: '#5285DF',
        withdrawPurple3: '#8883D7',
      },
      width: {
        '25vw': '25vw',
        '35vw': '35vw',
        '40vw': '40vw',
        '50vw': '50vw',
        '60vw': '60vw',
        '95vw': '95vw',
        '580px': '580px',
        '560px': '560px',
        '1024px': '1024px',
        '360px': '360px',
        p200: '200px',
        p240: '240px',
        '80vw': '80vw',
        '90vw': '90vw',
        '30vw': '30vw',
        '480px': '480px',
        smartRoute: '292px',
        '1000px': '1000px',
        '1024px': '1024px',
        p70: '70px',
        p869: '869px',
        '1050px': '1050px',
        54: '13.5rem',
        34: '8.5rem',
      },
      height: {
        vh90: '90vh',
        p560: '560px',
        vh65: '65vh',
      },
      maxWidth: {
        '200px': '200px',
        24: '6rem',
        28: '7rem',
        p240: '240px',
      },
      minHeight: {
        8: '2rem',
      },
      maxHeight: {
        p360: '360px',
        vh65: '65vh',
      },
      minWidth: {
        p72: '72px',
        20: '5rem',
        28: '7rem',
        72: '18rem',
        36: '9rem',
        24: '6rem',
        40: '10rem',
        32: '8rem',
        '420px': '420px',
        p90: '90px',
      },
      fontSize: {
        '13px': '13px',
        '10px': '10px',
      },
    },
  },
  plugins: [],
  content: ['./src/**/*.{js,jsx,ts,tsx,html}', './public/index.html'],
};

'''
'''--- tsconfig.json ---
{
  "compilerOptions": {
    "target": "es2015",
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noFallthroughCasesInSwitch": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx"
  },
  "include": [
    "src"
  ]
}

'''