*GitHub Repository "Learn-NEAR/json-to-md-helper"*

'''--- Cargo.toml ---
[package]
name = "presentation-formater"
version = "0.1.0"
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
serde= { version = "1" , features =["derive"]}
serde_json = "1.0.78"
regex = "1.5.4"
csv = "1.1"
clap = {version = "3.0.14", features =["derive"]}
reqwest ={version = "0.11.9", features =["blocking"]}
tokio = {version = "1.16.1" , features =["full"]}
pest = "2.1.3"
pest_derive = "2.1.0"
lazy_static = "1.4.0"
'''
'''--- README.md ---
# presentation-formater

## introduction
used to format input in json or csv or any other dotos (toml,yaml)
to [hackmd](https://hackmd.io/) or any other dotos for presentation. 

## how to use it
- clone the repo
- build using    `cargo build --release ,` or install it using `cargo install`
- run the executable as cli and for help `presentation-formatter --help` 
- check input.json file to see the josn format that is used.
- to generate hackmd file format from json use `presentation-formatter --input-format json --input-file ./input-files/input.json --output-format hackmd --output-file ./output.hackmd`

'''
'''--- input-files/cross-contract-low.json ---
{
    "title":"Learn rust with NEAR",
    "text"  : "[cross contract low](https://github.com/near/near-sdk-rs/tree/master/examples/cross-contract-low-level)",
    "sections":[
      {
        "title": "Variables and constant",
        "text":"Rust has variables like any other language such as [primative and non-primative](https://doc.rust-lang.org/book/ch03-02-data-types.html) and there are some special features we will disscus them one by one.",
        "pages" : [
            {
                "title": "primative types",
                 "code" : "https://github.com/near/near-sdk-rs/blob/801ef307ee66856b8a3572fbbd64ab82b8a186dc/examples/cross-contract-low-level/src/lib.rs#L81-L82",
                "text":  "here we are defining two variables of type [usize](https://doc.rust-lang.org/std/primitive.usize.html) and declare them as 'mut' to make the variable mutable and we will learrn about the mutablity in the next section"
            },
            {
              "title": "[struct](https://doc.rust-lang.org/book/ch05-01-defining-structs.html)",
               "code" :"https://github.com/near/near-sdk-rs/blob/801ef307ee66856b8a3572fbbd64ab82b8a186dc/examples/cross-contract-low-level/src/lib.rs#L11-L13",
              "text":  "Rust doesn't have classes but instead struct to define a container for data like in these line of code we define a struct with one variables 'checked_promise'."
            },
            {
                "title": "[const](https://doc.rust-lang.org/std/keyword.const.html)",
                "code" :"https://github.com/near/near-sdk-rs/blob/801ef307ee66856b8a3572fbbd64ab82b8a186dc/examples/cross-contract-low-level/src/lib.rs#L7", 
                "text": "Rust has compile time const that recommended to be used with values that used many times in addition to it gives readablity for the code, for example here we define a const for single call gas cost."
            }
        ]
          
      },
      {
        "title": "[control flow](https://doc.rust-lang.org/book/ch03-05-control-flow.html)",
        "text":"you can run some code repeatedly or according to a condition",
        "pages" : [
            {
                "title": "if condition",
                "code" : "https://github.com/near/near-sdk-rs/blob/801ef307ee66856b8a3572fbbd64ab82b8a186dc/examples/cross-contract-low-level/src/lib.rs#L93-L99",
                "text": "we comparing the data and accordingly we decide to execute code inside 'if' or 'else'"
            },
            {
                "title": "looping",
                "code" : "https://github.com/near/near-sdk-rs/blob/801ef307ee66856b8a3572fbbd64ab82b8a186dc/examples/cross-contract-low-level/src/lib.rs#L84-L100",
                "text": "here executing the code inside the loop infinitly or until breaking explicitly"
            }
        
        ]
          
      },
      {
        "title": "impl section, and static and instance functions",
        "text":"Rust is not object oriented language but you can define structs as data container and attach function to operate on this data, also you can do the same for enums.",
        "pages" : [
            {
                "title": "[impl](https://doc.rust-lang.org/std/keyword.impl.html)",
                "code" : "https://github.com/near/near-sdk-rs/blob/801ef307ee66856b8a3572fbbd64ab82b8a186dc/examples/cross-contract-low-level/src/lib.rs#L22",
                "text":  "here we start to write function to manipulate the derived type"
            },
            {
                "title": "impl [trait](https://doc.rust-lang.org/book/ch10-02-traits.html)",
                "code" : "https://github.com/near/near-sdk-rs/blob/801ef307ee66856b8a3572fbbd64ab82b8a186dc/examples/cross-contract-low-level/src/lib.rs#L15",
                "text" : "trait is an interface that forced a specific design, here we are implementing [Default](https://doc.rust-lang.org/std/default/trait.Default.html) trait for 'CrossContract' struct so we must implement all functions in this trait"
            },
            {
                "title": "[static function](https://turreta.com/2019/10/14/static-and-instance-methods-in-struct/)",
                "code" : "https://github.com/near/near-sdk-rs/blob/801ef307ee66856b8a3572fbbd64ab82b8a186dc/examples/cross-contract-low-level/src/lib.rs#L16-L18",
                "text": "inside impl block we can define a static function like this so it can be called from the type itself, here we return [Self](https://stackoverflow.com/questions/32304595/whats-the-difference-between-self-and-self) from the function so here we refere to the current type."
            },
            {
                "title": "[instance function](https://turreta.com/2019/10/14/static-and-instance-methods-in-struct/)",
                "code" : "https://github.com/near/near-sdk-rs/blob/801ef307ee66856b8a3572fbbd64ab82b8a186dc/examples/cross-contract-low-level/src/lib.rs#L155-L158",
                "text" : "inside impl block we can define instance function like this code defines function that takes parameters in addition to '& mut [self](https://doc.rust-lang.org/std/keyword.self.html)', rust introduce new concept called [mutability](https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html) so here we borrow mutable refrence for the current object so that the function can edit on it."
            },
            {
                "title": "instance function calling",
                "code" : "https://github.com/near/near-sdk-rs/blob/801ef307ee66856b8a3572fbbd64ab82b8a186dc/examples/cross-contract-low-level/src/lib.rs#L97",
                "text": "here we are calling a function called 'push' in variable called 'result' to push data into this [vector](https://doc.rust-lang.org/std/vec/struct.Vec.html)"
            },
            {
                "title": "instance function and immutable reference",
                "code" : "https://github.com/near/near-sdk-rs/blob/801ef307ee66856b8a3572fbbd64ab82b8a186dc/examples/cross-contract-low-level/src/lib.rs#L160-L162",
                "text" : "here we define an instance function with '&self' this means the function [borrows](https://doc.rust-lang.org/rust-by-example/scope/borrow.html) the current object for readonly like in first line we use it to get data from the current object"
            }
        ]
          
      },
      {
        "title": "[ownership](https://doc.rust-lang.org/rust-by-example/scope/move.html) and [borrowing](https://doc.rust-lang.org/rust-by-example/scope/borrow.html)",
        "text": "rust has unique concept called ownership and borrowing so when you assign variables to anther so most of the time instead of copying, the ownership taken by the second variable, so we can use borrowing and other things so keep the origin variable",
        "pages" : [
            {
                "title": "[Clone](https://doc.rust-lang.org/std/clone/trait.Clone.html) and ownership",
                "code" : "https://github.com/near/near-sdk-rs/blob/801ef307ee66856b8a3572fbbd64ab82b8a186dc/examples/cross-contract-low-level/src/lib.rs#L61-L62",
                "text":  "as we mention when we use a varable in passing to function or to assign anther variable so the ownership is transfered and the origin variable move and this exist with non-primative types unless they implement [Copy trait](https://doc.rust-lang.org/std/marker/trait.Copy.html), so here we use clone function to make a copy of data and so as not to be moved and reused after that"
            }
        ]
          
      },
      {
        "title": "[imports](https://doc.rust-lang.org/reference/items/use-declarations.html)",
        "text":"You can import some code from external library",
        "pages" : [
            {
                "title": "importing from other crates",
                "code" : "https://github.com/near/near-sdk-rs/blob/801ef307ee66856b8a3572fbbd64ab82b8a186dc/examples/cross-contract-low-level/src/lib.rs#L1-L4",
                "text": "these lines imports struct types from other crates that must be mentioned as a dependence in [Cargo.toml](https://doc.rust-lang.org/cargo/reference/manifest.html)."
            }
        ]
          
      },
      {
        "title": "[macros](https://doc.rust-lang.org/book/ch19-06-macros.html)",
        "text":"Macros are widly used in metaprogramming for generating code at compile time.",
        "pages" : [
            {
                "title": "[procedure macro](https://doc.rust-lang.org/reference/procedural-macros.html)",
                "code" : "https://github.com/near/near-sdk-rs/blob/801ef307ee66856b8a3572fbbd64ab82b8a186dc/examples/cross-contract-low-level/src/lib.rs#L9-L10",
                "text": "procedure macros allow creating syntax extentions like at first line we attribute the that this struct should generate some code for near, second line [derive-macro](https://doc.rust-lang.org/reference/attributes/derive.html) to generate implementation for these traits instead of making custom implementation for them.[BorshDeserialize](https://docs.rs/borsh/latest/borsh/de/trait.BorshDeserialize.html), [BorshSerialize](https://docs.rs/borsh/latest/borsh/de/trait.BorshSerialize.html) are used to convert to and from object and binary value but Serialize and Deserialize are used to convert to and from object and json value."
            },
            {
                "title": "[macro rules](https://doc.rust-lang.org/rust-by-example/macros.html)",
                "code" : "https://github.com/near/near-sdk-rs/blob/801ef307ee66856b8a3572fbbd64ab82b8a186dc/examples/cross-contract-low-level/src/lib.rs#L83",
                "text": "macro rules it is a macro like function but evaluated at compile time in addition to have ability to generate codes, this line call macro to create an empty vector"
            }
        ]
          
      }
    ]
  
  }
'''
'''--- input-files/fungable-token.json ---
{
    "title":"Learn rust with NEAR",
    "text"  : "[fungable token](https://github.com/near/near-sdk-rs/tree/master/examples/fungible-token): Example implementation of a Fungible Token contract which uses [near-contract-standards](https://github.com/near/near-sdk-rs/tree/master/near-contract-standards) and [simulation](https://github.com/near/near-sdk-rs/tree/master/near-sdk-sim).",
    "sections":[
      {
        "title": "Variables and constant",
        "text":"Rust has variables like any other language such as primative and non-primative and there are some special features we will disscus them one by one.",
        "pages" : [
            {
              "title": "[struct](https://doc.rust-lang.org/book/ch05-01-defining-structs.html)",
              "code":  "https://github.com/near/near-sdk-rs/blob/801ef307ee66856b8a3572fbbd64ab82b8a186dc/examples/fungible-token/ft/src/lib.rs#L32-L35",
              "text":  "Rust doesn't have classes but instead struct to define a container for data like in these line of code we define a struct with two variables 'token' and 'metadata'."
            },
            {
               "title":  "[enum](https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html)",
               "code" : "https://github.com/near/near-sdk-rs/blob/801ef307ee66856b8a3572fbbd64ab82b8a186dc/examples/fungible-token/ft/src/lib.rs#L40-L43",
               "text":  "Rust has enums to give names to const variables in additions other featurs we will explore them in next lessons like in this code we define new type called 'StorageKey' with two possibilities 'FungibleToken' and 'Metadata'."
            },
            {
                "title": "[const](https://doc.rust-lang.org/std/keyword.const.html)",
                 "code": "https://github.com/near/near-sdk-rs/blob/801ef307ee66856b8a3572fbbd64ab82b8a186dc/examples/fungible-token/ft/src/lib.rs#L37",
                 "text": "Rust has compile time const that recommended to be used with values that used many times in addition to it gives readablity for the code, for example here we define a const for image csv value that might be used many times in the program."
            }
        ]
          
      },
      {
        "title": "[strings](https://doc.rust-lang.org/rust-by-example/std/str.html)",
        "text":"rust has many types that represents sequence of characters",
        "pages" : [
            {
                "title": "[String](https://doc.rust-lang.org/std/string/index.html)",
                "code" : "https://github.com/near/near-sdk-rs/blob/801ef307ee66856b8a3572fbbd64ab82b8a186dc/examples/fungible-token/ft/src/lib.rs#L56",
                "text" : "String is a UTF-8 dynamic groupable list used to store sequence of chars, and we here we call [to_string](https://doc.rust-lang.org/std/string/trait.ToString.html) to get String from the variable of type '&str' we will check it next page"
            },
            {
                "title": "[&str](https://doc.rust-lang.org/std/primitive.str.html)",
                "code" : "https://github.com/near/near-sdk-rs/blob/801ef307ee66856b8a3572fbbd64ab82b8a186dc/examples/fungible-token/ft/src/lib.rs#L56",
                "text" : "it is slice version of String so it reference to other type of String ,here we are haveing a string literal of type '&'static str' and this mean it reference to a string with static lifetime which will live lone all program lifetime"
            }
        ]
          
      },
      {
        "title": "functions",
        "text":"like any other language you can define some reusable code and it is called function.",
        "pages" : [
            {
                "title": "function definition and calling",
                "code" : "https://github.com/near/near-sdk-rs/blob/801ef307ee66856b8a3572fbbd64ab82b8a186dc/examples/fungible-token/ft/src/lib.rs#L109-L116",
                "text" : "here we are defining a function with name 'get_context', parameter and return type, also at lines 111th to 114 we call functions in a variable called 'builder' and they are [instance functions](https://turreta.com/2019/10/14/static-and-instance-methods-in-struct/) but we will learn them in the next section."
            }
        ]
          
      },
      {
        "title": "impl section, and static and instance functions",
        "text":"Rust is not object oriented language but you can define structs as data container and attach function to operate on this data, also you can do the same for enums.",
        "pages" : [
            {
                "title": "[impl](https://doc.rust-lang.org/std/keyword.impl.html)",
                "code" : "https://github.com/near/near-sdk-rs/blob/801ef307ee66856b8a3572fbbd64ab82b8a186dc/examples/fungible-token/ft/src/lib.rs#L46",
                "text":  "here we start to write function to manipulate the derived type"
            },
            {
                "title": "[static function](https://turreta.com/2019/10/14/static-and-instance-methods-in-struct/)",
                "code" : "https://github.com/near/near-sdk-rs/blob/801ef307ee66856b8a3572fbbd64ab82b8a186dc/examples/fungible-token/ft/src/lib.rs#L69",
                "text": "inside impl block we can define a static function like this so it can be called from the type itself, here we return [Self](https://stackoverflow.com/questions/32304595/whats-the-difference-between-self-and-self) from the function so here we refere to the current type."
            },
            {
                "title": "[static function](https://turreta.com/2019/10/14/static-and-instance-methods-in-struct/) call",
                "code" : "https://github.com/near/near-sdk-rs/blob/801ef307ee66856b8a3572fbbd64ab82b8a186dc/examples/fungible-token/ft/src/lib.rs#L110",
                "text": "here we call a static function 'new' in the type 'VMContextBuilder' and this is widly used method to create a new instance because Rust doesn't have constractor."
            },
            {
                "title": "[instance function](https://turreta.com/2019/10/14/static-and-instance-methods-in-struct/)",
                "code" : "https://github.com/near/near-sdk-rs/blob/801ef307ee66856b8a3572fbbd64ab82b8a186dc/examples/fungible-token/ft/src/lib.rs#L81-L83",
                "text" : "inside impl block we can define instance function like this code defines function that takes parameters in addition to '& mut [self](https://doc.rust-lang.org/std/keyword.self.html)', rust introduce new concept called [mutability](https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html) so here we borrow mutable refrence for the current object so that the function can edit on it."
            },
            {
                "title": "instance function and immutable reference",
                "code" : "https://github.com/near/near-sdk-rs/blob/801ef307ee66856b8a3572fbbd64ab82b8a186dc/examples/fungible-token/ft/src/lib.rs#L95-L97",
                "text" : "here we define an instance function with '&self' this means the function [borrows](https://doc.rust-lang.org/rust-by-example/scope/borrow.html) the current object for readonly like in 96th line we use it to get data from 'metadata' variable."
            },
            {
                "title": "instance function calling",
                "code" : "https://github.com/near/near-sdk-rs/blob/801ef307ee66856b8a3572fbbd64ab82b8a186dc/examples/fungible-token/ft/src/lib.rs#L110-L114",
                "text": "line 112 to 114 calling instance function on the variable 'builder' and these lines follows [builder pattern](https://doc.rust-lang.org/1.0.0/style/ownership/builders.html)"
            }
        ]
          
      },
      {
        "title": "[ownership](https://doc.rust-lang.org/rust-by-example/scope/move.html) and [borrowing](https://doc.rust-lang.org/rust-by-example/scope/borrow.html)",
        "text": "rust has unique concept called ownership and borrowing so when you assign variables to anther so most of the time instead of copying, the ownership taken by the second variable, so we can use borrowing and other things so keep the origin variable",
        "pages" : [
            {
                "title": "[Clone](https://doc.rust-lang.org/std/clone/trait.Clone.html) and ownership",
                "code" : "https://github.com/near/near-sdk-rs/blob/801ef307ee66856b8a3572fbbd64ab82b8a186dc/examples/fungible-token/ft/src/lib.rs#L113-L114",
                "text": "as we mention when we use a varable in passing to function or to assign anther variable so the ownership is transfered and the origin variable move and this exist with non-primative types unless they implement [Copy trait](https://doc.rust-lang.org/std/marker/trait.Copy.html), so in line 13 we use clone function to make a copy of data and pass it so that we could use the original variable in the next line to be passed to the function."
            }
        ]
          
      },
      {
        "title": "[testing in rust](https://doc.rust-lang.org/book/ch11-01-writing-tests.html)",
        "text":"Tests are Rust functions that verify that the non-test code is functioning in the expected manner.",
        "pages" : [
            {
                "title": "unit test",
                "code" : "https://github.com/near/near-sdk-rs/blob/801ef307ee66856b8a3572fbbd64ab82b8a186dc/examples/fungible-token/ft/src/lib.rs#L118-L126",
                "text": "so here we are writing a function and anntotate it as test like in line 118, and we use assertion funtions like at lines 124 and 125"
            }
        ]
          
      },
      {
        "title": "[modules](https://doc.rust-lang.org/rust-by-example/mod.html) and [imports](https://doc.rust-lang.org/reference/items/use-declarations.html)",
        "text":"Rust structure it's code in modules so you can have mutliple files in your projects.",
        "pages" : [
            {
                "title": "importing from other crates",
                "code" : "https://github.com/near/near-sdk-rs/blob/801ef307ee66856b8a3572fbbd64ab82b8a186dc/examples/fungible-token/ft/src/lib.rs#L18-L21",
                "text": "these lines imports struct types from other crates that must be mentioned as a dependence in [Cargo.toml](https://doc.rust-lang.org/cargo/reference/manifest.html)."
            },
            {
                "title": "modules",
                "code" : "https://github.com/near/near-sdk-rs/blob/801ef307ee66856b8a3572fbbd64ab82b8a186dc/examples/fungible-token/ft/src/lib.rs#L100-L101",
                "text": "we can define new module in rust to structure our code, here we declaring a module at line 101 ,and at line 100 we annotate that it is a test module and use a [compile time switch](https://doc.rust-lang.org/reference/conditional-compilation.html) to compile this module only at non-WASM platform."
            },
            {
                "title": "using code from other modules",
                "code" : "https://github.com/near/near-sdk-rs/blob/801ef307ee66856b8a3572fbbd64ab82b8a186dc/examples/fungible-token/ft/src/lib.rs#L142",
                "text": "to use code like function from other modules you can use full qualified name like in this code we call function from 'env' module"
            }
        ]
          
      },
      {
        "title": "[macros](https://doc.rust-lang.org/book/ch19-06-macros.html)",
        "text":"Macros are widly used in metaprogramming for generating code at compile time.",
        "pages" : [
            {
                "title": "[procedure macro](https://doc.rust-lang.org/reference/procedural-macros.html)",
                "code" : "https://github.com/near/near-sdk-rs/blob/801ef307ee66856b8a3572fbbd64ab82b8a186dc/examples/fungible-token/ft/src/lib.rs#L30-L31",
                "text": "procedure macros allow creating syntax extentions like at line 30 we attribute the that this struct should generate some code for near, at line 31 [derive-macro](https://doc.rust-lang.org/reference/attributes/derive.html) to generate implementation for these traits instead of making custom implementation for them.[BorshDeserialize](https://docs.rs/borsh/latest/borsh/de/trait.BorshDeserialize.html), [BorshSerialize](https://docs.rs/borsh/latest/borsh/de/trait.BorshSerialize.html) are used to convert to and from object and binary value but Serialize and Deserialize are used to convert to and from object and json value."
            },
            {
                "title": "[macro rules](https://doc.rust-lang.org/rust-by-example/macros.html)",
                 "code":"https://github.com/near/near-sdk-rs/blob/801ef307ee66856b8a3572fbbd64ab82b8a186dc/examples/fungible-token/ft/src/lib.rs#L82",
                "text": "macro rules it is a macro like function but evaluated at compile time in addition to have ability to generate codes, this line call macro and as we see it is like call but have '!' so here we call macro called 'log' to log some information to be traced later"
            }
        ]
          
      }
    ]
  
  }
'''
'''--- input-files/input.json ---
{
  "title":"hello rust",
  "text": "introduction",
  "sections":[
    {
      "title": "first section",
      "text":"first section description",
      "pages" : [
        {
          "title": "first page",
          "code": "https://github.com/abdelmonem17/presentation-formatter/blob/3e90ca7940feb272125d143ce19a064e9e9e8628/Cargo.toml#L6-L9",
          "text": "first page details"
        }
      ]

    },
    {
      "title": "second section",
      "text":"second section description",
      "pages" : [
        {
          "title": "first page",
          "code": "https://github.com/abdelmonem17/presentation-formatter/blob/3e90ca7940feb272125d143ce19a064e9e9e8628/Cargo.toml#L6-L9",
          "text": "first page details"
        },
        {
          "title": "second page",
          "code": "https://github.com/abdelmonem17/presentation-formatter/blob/3e90ca7940feb272125d143ce19a064e9e9e8628/Cargo.toml#L6-L9",
          "text": "second page details"
        },
        {
          "title": "third page",
          "code": "https://github.com/abdelmonem17/presentation-formatter/blob/3e90ca7940feb272125d143ce19a064e9e9e8628/Cargo.toml#L6-L9",
          "text": "third page details"
        }
      ]

    }
  ]

}
'''
'''--- input-files/input.txt ---
trait Future {
  type Output;
  fn poll(&mut self,walker:fn())->Poll<Self::Output>;
}

pub enum Poll<T>{
    Pending,
    Ready(T)
}

struct SocketStream<'a>{
    socket:&'a Socket,
}

impl Future for SocketStream<'_>{
    type Output=Vec<u8>;
    fn poll(&mut self, walker:fn())->Poll<Self::Output>{
        if let Some(data) = self.get_data(){
            Poll::Read(data)
        }else{
            self.set_call_back(walker);
            Poll::Pending;
        }
    }
}

struct TimerFuture{
    state:Arc<Mutex<SharedState>>,
}

#[derive(Default)]
struct SharedState{
    completed bool,
    waker: Option<Waker>,
}

impl Future for TimerFuture{
    Output= ();
    fn poll(self:Pin<&mut self> , context:&mut Context<'_>)->Poll<Self::Output>{
        let mut guard = self.state.lock().unwrap();
        if guard.completed{
            Poll::Ready(())
        }else{
            guard.waker = Some(context.waker());
            Poll::Pending
        }
    }
}

impl TimerFuture{
    pub fn new(duration:Duration)->Self{
        let state = Arc::new(Mutex::new(SharedState::default()));
        let state_copy = state.clone();
        let _= std::thread::spwan(move ||{
            std::thread::sleep(duration);
            let state_copy = state_copy.lock().unwrap();
            state_copy.completed = true;
            if let Some(waker) = state_copy.waker{
                waker.wake();
            }
            state.waker = None;
         });
    }
}
'''
'''--- input-files/lockable-fungable-token.json ---
{
    "title":"Learn rust with NEAR",
    "text"  : "[lockable fungable token](https://github.com/near/near-sdk-rs/blob/master/examples/lockable-fungible-token/src/lib.rs): Lockable Fungible token but designed for composability in the async runtime like NEAR.It's an extension of a Fungible Token Standard (NEP#21) with locks. Locks allow composability of the contracts, but require careful GAS management, because the token contract itself doesn't guarantee the automatic unlocking call. That's why it shouldn't be used in production until Safes are implemented from (NEP#26)",
    "sections":[
      {
        "title": "Variables and constant",
        "text":"Rust has variables like any other language such as primative and non-primative and there are some special features we will disscus them one by one, we just want to show that when you assigment like defining a variable the ownership transfered from the right handside to left handside hence the variable moved unless it define the [Copy](https://doc.rust-lang.org/std/marker/trait.Copy.html) trait",
        "pages" : [
            {
               "title": "primative types",
               "code" : "https://github.com/near/near-sdk-rs/blob/801ef307ee66856b8a3572fbbd64ab82b8a186dc/examples/cross-contract-low-level/src/lib.rs#L81-L82",
               "text":  "here we are defining a variable with value and cast it to type [u128](https://doc.rust-lang.org/std/primitive.u128.html) so the compiler bind the type to u128"
            },
            {
              "title": "[struct](https://doc.rust-lang.org/book/ch05-01-defining-structs.html)",
               "code" : "https://github.com/near/near-sdk-rs/blob/801ef307ee66856b8a3572fbbd64ab82b8a186dc/examples/lockable-fungible-token/src/lib.rs#L8-L15",
              "text":  "Rust doesn't have classes but instead struct to define a container for data like in these line of code we define a struct with it's variables."
            },
            {
                "title": "[vector](https://doc.rust-lang.org/std/vec/struct.Vec.html)",
                "code" : "https://github.com/near/near-sdk-rs/blob/801ef307ee66856b8a3572fbbd64ab82b8a186dc/examples/cross-contract-low-level/src/lib.rs#L41-L43",
                "text" : "vector is a dynamic list of homogeneous data stored in the heap, for example at first line we get the size of the list, second and third lines we are taking [range](https://doc.rust-lang.org/std/ops/struct.Range.html) of element from the vector and generate new vector with help of 'to_vec' function"
            },
            {
                "title": "[slice](https://doc.rust-lang.org/std/vec/struct.Vec.html)",
                "code" : "https://github.com/near/near-sdk-rs/blob/801ef307ee66856b8a3572fbbd64ab82b8a186dc/examples/cross-contract-low-level/src/lib.rs#L32",
                "text" : "slice lets you reference contiguous sequence of elements in a collection, here we call [macro](https://doc.rust-lang.org/rust-by-example/macros.html) that gets the bytes in slice with [static lifetime](https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html)"
            },
            {
                "title": "[hashmap](https://doc.rust-lang.org/std/collections/struct.HashMap.html)",
                "code" : "https://github.com/near/near-sdk-rs/blob/801ef307ee66856b8a3572fbbd64ab82b8a186dc/examples/lockable-fungible-token/src/lib.rs#L8-L15",
                "text" : "hashmap is non-primative buildin type in the standard library used to store key and value pairs values, so here at line 12 and 14 we declaring two variables with hashmap types for storing data to be searchable efficiently using hashing"
            }
        ]
          
      },
      {
        "title": "[strings](https://doc.rust-lang.org/rust-by-example/std/str.html)",
        "text":"rust has many types that represents sequence of characters",
        "pages" : [
            {
                "title": "[String](https://doc.rust-lang.org/std/string/index.html)",
                "code" : "https://github.com/near/near-sdk-rs/blob/801ef307ee66856b8a3572fbbd64ab82b8a186dc/examples/cross-contract-low-level/src/lib.rs#L49",
                "text" : "String is a UTF-8 dynamic groupable list used to store sequence of chars, and we here we call [to_string](https://doc.rust-lang.org/std/string/trait.ToString.html) on the variable to get String"
            },
            {
                "title": "[&str](https://doc.rust-lang.org/std/primitive.str.html)",
                "code" : "https://github.com/near/near-sdk-rs/blob/801ef307ee66856b8a3572fbbd64ab82b8a186dc/examples/cross-contract-low-level/src/lib.rs#L48",
                "text" : "it is slice version of String so it reference to other type of String ,here we are passing a string literal of type '&'static str' and this mean it reference to a string with static lifetime which will live lone all program lifetime"
            }
        ]
          
      },
      {
        "title": "functions",
        "text":"like any other language you can define some reusable code and it is called function.",
        "pages" : [
            {
                "title": "function definition",
                "code" : "https://github.com/near/near-sdk-rs/blob/801ef307ee66856b8a3572fbbd64ab82b8a186dc/examples/lockable-fungible-token/src/lib.rs#L216-L219",
                "text" : "here we are defining a function with name 'get_total_supply', parameter and return type"
            }
        ]
          
      },
      {
        "title": "impl section, and static and instance functions",
        "text":"Rust is not object oriented language but you can define structs as data container and attach function to operate on this data, also you can do the same for enums.",
        "pages" : [
            {
                "title": "[impl](https://doc.rust-lang.org/std/keyword.impl.html)",
                "code" : "https://github.com/near/near-sdk-rs/blob/801ef307ee66856b8a3572fbbd64ab82b8a186dc/examples/lockable-fungible-token/src/lib.rs#L58",
                "text":  "here we start to write function to manipulate the derived type"
            },
            {
                "title": "[static function](https://turreta.com/2019/10/14/static-and-instance-methods-in-struct/)",
                "code" : "https://github.com/near/near-sdk-rs/blob/801ef307ee66856b8a3572fbbd64ab82b8a186dc/examples/lockable-fungible-token/src/lib.rs#L60-L67",
                "text": "inside impl block we can define a static function like this so it can be called from the type itself, here we return [Self](https://stackoverflow.com/questions/32304595/whats-the-difference-between-self-and-self) from the function so here we refere to the current type."
            },
            {
                "title": "[static function](https://turreta.com/2019/10/14/static-and-instance-methods-in-struct/) call",
                "code" : "https://github.com/near/near-sdk-rs/blob/801ef307ee66856b8a3572fbbd64ab82b8a186dc/examples/lockable-fungible-token/src/lib.rs#L337",
                "text": "here we call a static function 'new' in the type 'FunToken' and this is widly used method to create a new instance because Rust doesn't have constractor."
            },
            {
                "title": "[instance function](https://turreta.com/2019/10/14/static-and-instance-methods-in-struct/)",
                "code" : "https://github.com/near/near-sdk-rs/blob/801ef307ee66856b8a3572fbbd64ab82b8a186dc/examples/lockable-fungible-token/src/lib.rs#L212-L214",
                "text" : "inside impl block we can define instance function like this code defines function that takes parameters in addition to '& mut [self](https://doc.rust-lang.org/std/keyword.self.html)', rust introduce new concept called [mutability](https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html) so here we borrow mutable refrence for the current object so that the function can edit on it."
            },
            {
                "title": "instance function and immutable reference",
                "code" : "https://github.com/near/near-sdk-rs/blob/801ef307ee66856b8a3572fbbd64ab82b8a186dc/examples/lockable-fungible-token/src/lib.rs#L242-L247",
                "text" : "here we define an instance function with '&self' this means the function [borrows](https://doc.rust-lang.org/rust-by-example/scope/borrow.html) the current object for readonly like in first line we use it to get data from the current object, also note that at last line in the function we omit the semicolon and this means implicit return from the function"
            },
            {
                "title": "instance function calling",
                "code" : "https://github.com/near/near-sdk-rs/blob/801ef307ee66856b8a3572fbbd64ab82b8a186dc/examples/lockable-fungible-token/src/lib.rs#L63",
                "text": "we call an instance function on variable of type 'FunToken' "
            }
        ]
          
      },
      {
        "title": "[ownership](https://doc.rust-lang.org/rust-by-example/scope/move.html) and [borrowing](https://doc.rust-lang.org/rust-by-example/scope/borrow.html)",
        "text": "rust has unique concept called ownership and borrowing so when you assign variables to anther so most of the time instead of copying, the ownership taken by the second variable, so we can use borrowing and other things so keep the origin variable",
        "pages" : [
            {
                "title": "[Clone](https://doc.rust-lang.org/std/clone/trait.Clone.html) and ownership",
                "code" : "https://github.com/near/near-sdk-rs/blob/801ef307ee66856b8a3572fbbd64ab82b8a186dc/examples/lockable-fungible-token/src/lib.rs#L20",
                "text" : "as we mention when we use a varable in passing to function or to assign anther variable so the ownership is transfered and the origin variable move and this exist with non-primative types unless they implement [Copy trait](https://doc.rust-lang.org/std/marker/trait.Copy.html), so here we use clone function to make a copy of data and so as not to be moved and reused after that"            }
        ]
          
      },
      {
        "title": "[testing in rust](https://doc.rust-lang.org/book/ch11-01-writing-tests.html)",
        "text":"Tests are Rust functions that verify that the non-test code is functioning in the expected manner.",
        "pages" : [
            {
                "title": "unit test",
                "code" : "https://github.com/near/near-sdk-rs/blob/801ef307ee66856b8a3572fbbd64ab82b8a186dc/examples/lockable-fungible-token/src/lib.rs#L262-L271",
                "text": "so here we writing a function and anntotate it as test like in first line, and we use assertion funtions like at last 3 lines of code so they must succeed other wise the test will fail"
            }
        ]
          
      },
      {
        "title": "[modules](https://doc.rust-lang.org/rust-by-example/mod.html) and [imports](https://doc.rust-lang.org/reference/items/use-declarations.html)",
        "text":"Rust structure it's code in modules so you can have mutliple files in your projects.",
        "pages" : [
            {
                "title": "importing from other crates",
                "code" : "https://github.com/near/near-sdk-rs/blob/801ef307ee66856b8a3572fbbd64ab82b8a186dc/examples/lockable-fungible-token/src/lib.rs#L1-L5",
                "text": "these lines imports struct types from other crates that must be mentioned as a dependence in [Cargo.toml](https://doc.rust-lang.org/cargo/reference/manifest.html)."
            },
            {
                "title": "modules",
                "code" : "https://github.com/near/near-sdk-rs/blob/801ef307ee66856b8a3572fbbd64ab82b8a186dc/examples/lockable-fungible-token/src/lib.rs#L49-L251",
                "text": "we can define new module in rust to structure our code, here we declaring a module at third line ,and at second line we annotate that it is a test module and at first line use a [compile time switch](https://doc.rust-lang.org/reference/conditional-compilation.html) to compile this module only at non-WASM platform."
            }
        ]
          
      },
      {
        "title": "[macros](https://doc.rust-lang.org/book/ch19-06-macros.html)",
        "text":"Macros are widly used in metaprogramming for generating code at compile time.",
        "pages" : [
            {
                "title": "[procedure macro](https://doc.rust-lang.org/reference/procedural-macros.html)",
                "code" : "https://github.com/near/near-sdk-rs/blob/801ef307ee66856b8a3572fbbd64ab82b8a186dc/examples/lockable-fungible-token/src/lib.rs#L7",
                "text": "procedure macros allow creating syntax extentions like at first line we attribute the that this struct should generate some code for near, second line [derive-macro](https://doc.rust-lang.org/reference/attributes/derive.html) to generate implementation for these traits instead of making custom implementation for them.[BorshDeserialize](https://docs.rs/borsh/latest/borsh/de/trait.BorshDeserialize.html), [BorshSerialize](https://docs.rs/borsh/latest/borsh/de/trait.BorshSerialize.html) are used to convert to and from object and binary value but Serialize and Deserialize are used to convert to and from object and json value and 'Default' to implement default trait for this type."
            },
            {
                "title": "[macro rules](https://doc.rust-lang.org/rust-by-example/macros.html)",
                "code" : "https://github.com/near/near-sdk-rs/blob/801ef307ee66856b8a3572fbbd64ab82b8a186dc/examples/lockable-fungible-token/src/lib.rs#L285",
                "text": "macro rules it is a macro like function but evaluated at compile time in addition to have ability to generate codes, this line call macro and as we see it is like call but have '!' so here we call macro called 'assert_eq' to assert that the right equals the left"
            }
        ]
          
      }
    ]
  
  }
'''
'''--- input-files/lockup.json ---
{
    "title":"Learn rust with NEAR",
    "text"  : "",
    "sections":[
        {
            "title": "Variables and constant",
            "text":"Rust has variables like any other language such as primative and non-primative and there are some special features we will disscus them one by one, we just want to show that when you assigment like defining a variable the ownership transfered from the right handside to left handside hence the variable moved unless it define the [Copy](https://doc.rust-lang.org/std/marker/trait.Copy.html) trait",
            "pages" : [
                {
                   "title": "primative types",
                   "code" :"https://github.com/near/core-contracts/blob/a11e6d4c97336aa47a871083e7b5cb238d3a0eb5/lockup/src/lib.rs#L290",
                   "text":  "here we are defining a variable as a parameter of type 'bool'"
                },
                {
                    "title": "[const](https://doc.rust-lang.org/std/keyword.const.html)",
                    "code" : "https://github.com/near/core-contracts/blob/a11e6d4c97336aa47a871083e7b5cb238d3a0eb5/lockup/src/lib.rs#L29", 
                    "text":  "Rust has compile time const that recommended to be used with values that used many times in addition to it gives readablity for the code, for example here we define a const for image csv value that might be used many times in the program."
                },
                {
                    "title": "[static](https://doc.rust-lang.org/reference/items/static-items.html)",
                    "code" : "https://github.com/near/core-contracts/blob/a11e6d4c97336aa47a871083e7b5cb238d3a0eb5/lockup/src/lib.rs#L26", 
                    "text": "Rust has runtime const ,it is static variable which all reference to this variable has static lifetime because it lives as long as program runs"
                },
                {
                  "title": "[struct](https://doc.rust-lang.org/book/ch05-01-defining-structs.html)",
                  "code" : "https://github.com/near/core-contracts/blob/a11e6d4c97336aa47a871083e7b5cb238d3a0eb5/lockup/src/lib.rs#L121-L126",
                  "text":  "Rust doesn't have classes but instead struct to define a container for data like in these line of code we define a struct with it's variables."
                },
                {
                    "title": "[vector](https://doc.rust-lang.org/std/vec/struct.Vec.html)",
                    "code" : "https://github.com/near/core-contracts/blob/a11e6d4c97336aa47a871083e7b5cb238d3a0eb5/lockup/src/lib.rs#L704",
                    "text" : "vector is a dynamic list of homogeneous data stored in the heap, so here we creating vector with no element with the help of macro `vec![]`"
                },
                {
                    "title": "[array](https://doc.rust-lang.org/rust-by-example/primitives/array.html)",
                    "code":"https://github.com/near/core-contracts/blob/a11e6d4c97336aa47a871083e7b5cb238d3a0eb5/lockup/src/lib.rs#L261",
                    "text" : "array is a collection of contiguous data with same type and it states as fixed size, and here we define array of 3 element of type 'u8'"
                }
            ]
              
      },
      {
        "title": "[strings](https://doc.rust-lang.org/rust-by-example/std/str.html)",
        "text":"rust has many types that represents sequence of characters",
        "pages" : [
            {
                "title": "[String](https://doc.rust-lang.org/std/string/index.html)",
                "code":"https://github.com/near/core-contracts/blob/a11e6d4c97336aa47a871083e7b5cb238d3a0eb5/lockup/src/lib.rs#L665",
                "text" : "String is a UTF-8 dynamic groupable list used to store sequence of chars, and we here we call [to_string](https://doc.rust-lang.org/std/string/trait.ToString.html) to get String from the variable of type '&str' we will check it next page"
            },
            {
                "title": "[&str](https://doc.rust-lang.org/std/primitive.str.html)",
                "code" : "https://github.com/near/core-contracts/blob/a11e6d4c97336aa47a871083e7b5cb238d3a0eb5/lockup/src/lib.rs#L746",
                "text" : "it is slice version of String so it reference to other type of String ,here we are haveing a string literal of type '&'static str' and this mean it reference to a string with static lifetime which will live lone all program lifetime"
            }
        ]
          
      },
      {
        "title": "functions",
        "text":"like any other language you can define some reusable code and it is called function.",
        "pages" : [
            {
                "title": "function definition and calling",
                "code" : "https://github.com/near/core-contracts/blob/a11e6d4c97336aa47a871083e7b5cb238d3a0eb5/lockup/src/lib.rs#L273-L279",
                "text" : "here we are defining a function with name 'new_vesting_schedule', parameter and return type, line 275 we call function and pass expression to it an argument"
            }
        ]
          
      },
      {
        "title": "impl section, and static and instance functions",
        "text":"Rust is not object oriented language but you can define structs as data container and attach function to operate on this data, also you can do the same for enums.",
        "pages" : [
            {
                "title": "[impl](https://doc.rust-lang.org/std/keyword.impl.html)",
                "code" : "https://github.com/near/core-contracts/blob/a11e6d4c97336aa47a871083e7b5cb238d3a0eb5/lockup/src/lib.rs#L150",
                "text":  "here we start to write function to manipulate the derived type"
            },
            {
                "title": "[static function](https://turreta.com/2019/10/14/static-and-instance-methods-in-struct/)",
                "code" : "https://github.com/near/core-contracts/blob/a11e6d4c97336aa47a871083e7b5cb238d3a0eb5/lockup/src/lib.rs#L181-L190",
                "text": "inside impl block we can define a static function like this so it can be called from the type itself, here we return [Self](https://stackoverflow.com/questions/32304595/whats-the-difference-between-self-and-self) from the function so here we refere to the current type."
            },
            {
                "title": "[static function](https://turreta.com/2019/10/14/static-and-instance-methods-in-struct/) call",
                "code" : "https://github.com/near/core-contracts/blob/a11e6d4c97336aa47a871083e7b5cb238d3a0eb5/lockup/src/lib.rs#L320-L329",
                "text": "here we call a static function 'new' in the type 'LockupContract' and this is widly used method to create a new instance because Rust doesn't have constractor."
            },
            {
                "title": "instance function calling",
                "code" : "https://github.com/near/core-contracts/blob/a11e6d4c97336aa47a871083e7b5cb238d3a0eb5/lockup/src/lib.rs#L219",
                "text": "[is_none](https://doc.rust-lang.org/beta/core/option/enum.Option.html) is an instance function used to check the type of option is None or else"
            }
        ]
          
      },
      {
        "title": "[ownership](https://doc.rust-lang.org/rust-by-example/scope/move.html) and [borrowing](https://doc.rust-lang.org/rust-by-example/scope/borrow.html)",
        "text": "rust has unique concept called ownership and borrowing so when you assign variables to anther so most of the time instead of copying, the ownership taken by the second variable, so we can use borrowing and other things so keep the origin variable",
        "pages" : [
            {
                "title": "[Clone](https://doc.rust-lang.org/std/clone/trait.Clone.html) and ownership",
                "code" : "https://github.com/near/core-contracts/blob/a11e6d4c97336aa47a871083e7b5cb238d3a0eb5/lockup/src/lib.rs#L855",
                "text" : "as we mention when we use a varable in passing to function or to assign anther variable so the ownership is transfered and the origin variable move and this exist with non-primative types unless they implement [Copy trait](https://doc.rust-lang.org/std/marker/trait.Copy.html), so here we use clone function to make a copy of data and so as not to be moved and reused after that"         
           }
        ]
          
      },
      {
        "title": "[Generic types](https://doc.rust-lang.org/book/ch10-00-generics.html)",
        "text":"Every programming language has tools for effectively handling the duplication of concepts and write extensible agnostic",
        "pages" : [
            {
                "title": "[trait](https://doc.rust-lang.org/book/ch10-02-traits.html)",
                "code":"https://github.com/near/core-contracts/blob/a11e6d4c97336aa47a871083e7b5cb238d3a0eb5/lockup/src/lib.rs#L57-L59",
                "text": "trait define shared behaviour between implementors and it is consider as a contract, here we define a trait 'ExtStakingPoolWhitelist' with it's abstracted functionality"
            },
            {
                "title": "[trait](https://doc.rust-lang.org/book/ch10-02-traits.html) impl",
                "code":"https://github.com/near/core-contracts/blob/a11e6d4c97336aa47a871083e7b5cb238d3a0eb5/lockup/src/lib.rs#L143-L147",
                "text": "here we impl [Default](https://doc.rust-lang.org/std/default/trait.Default.html) trait for 'LockupContract' type"
            }
        ]
          
      },
      {
        "title": "[testing in rust](https://doc.rust-lang.org/book/ch11-01-writing-tests.html)",
        "text":"Tests are Rust functions that verify that the non-test code is functioning in the expected manner.",
        "pages" : [
            {
                "title": "unit test",
                "code" : "https://github.com/near/core-contracts/blob/a11e6d4c97336aa47a871083e7b5cb238d3a0eb5/lockup/src/lib.rs#L379-L389",
                "text": "so here we are writing a function and anntotate it as test like in first line, and we use assertion funtions like at line number 386"
            },
            {
                "title": "unit test attribute",
                "code":"https://github.com/near/core-contracts/blob/a11e6d4c97336aa47a871083e7b5cb238d3a0eb5/lockup/src/lib.rs#L392",
                "text":"here we attribute the test function and expect it fail with this messasge"
            }

        ]
          
      },
      {
        "title": "[modules](https://doc.rust-lang.org/rust-by-example/mod.html) and [imports](https://doc.rust-lang.org/reference/items/use-declarations.html)",
        "text":"Rust structure it's code in modules so you can have mutliple files in your projects.",
        "pages" : [
            {
                "title": "importing from other crates",
                "code" : "https://github.com/near/core-contracts/blob/a11e6d4c97336aa47a871083e7b5cb238d3a0eb5/lockup/src/lib.rs#L3-L5",
                "text": "these lines imports struct types from other crates that must be mentioned as a dependence in [Cargo.toml](https://doc.rust-lang.org/cargo/reference/manifest.html)."
            },
            {
                "title": "modules",
                "code" : "https://github.com/near/core-contracts/blob/a11e6d4c97336aa47a871083e7b5cb238d3a0eb5/lockup/src/lib.rs#L15-L19",
                "text": "we can define new module in a new rust file to structure our code but here but we must refer these module to the root of the crate and it is 'lib.rs' file in our code but in binary crate 'main.rs' is the root of the crate."
            },
            {
                "title": "shorten the modules members' path",
                "code":"https://github.com/near/core-contracts/blob/a11e6d4c97336aa47a871083e7b5cb238d3a0eb5/lockup/src/lib.rs#L7-L10",
                "text": "we can use codes defined in other modules as it defined in the root file by using [use](https://doc.rust-lang.org/reference/items/use-declarations.html)"
            }
        ]
          
      },
      {
        "title": "[macros](https://doc.rust-lang.org/book/ch19-06-macros.html)",
        "text":"Macros are widly used in metaprogramming for generating code at compile time.",
        "pages" : [
            {
                "title": "[procedure macro](https://doc.rust-lang.org/reference/procedural-macros.html)",
                "code" : "https://github.com/near/core-contracts/blob/a11e6d4c97336aa47a871083e7b5cb238d3a0eb5/lockup/src/lib.rs#L246",
                "text": "procedure macro used here to make a compile time switch and compile this code if the target is not WASM "
            },
            {
                "title": "[derive macro](https://doc.rust-lang.org/reference/procedural-macros.html)",
                "code" : "https://github.com/near/core-contracts/blob/a11e6d4c97336aa47a871083e7b5cb238d3a0eb5/lockup/src/lib.rs#L119-L120",
                "text": "procedure macros allow creating syntax extentions like at first line we attribute the that this struct should generate some code for near, second line [derive-macro](https://doc.rust-lang.org/reference/attributes/derive.html) to generate implementation for these traits instead of making custom implementation for them.[BorshDeserialize](https://docs.rs/borsh/latest/borsh/de/trait.BorshDeserialize.html), [BorshSerialize](https://docs.rs/borsh/latest/borsh/de/trait.BorshSerialize.html) are used to convert to and from object and binary value but Serialize and Deserialize are used to convert to and from object and json value."
            },
            {
                "title": "[macro rules](https://doc.rust-lang.org/rust-by-example/macros.html)",
                "code" : "https://github.com/near/core-contracts/blob/a11e6d4c97336aa47a871083e7b5cb238d3a0eb5/lockup/src/lib.rs#L361",
                "text": "macro rules it is a macro like function but evaluated at compile time in addition to have ability to generate codes, this line call macro and as we see it is like call but have '!' so here we call macro called 'assert_eq' used to assert that right equals left"
            }
        ]
          
      }
    ]
  
  }
  
              
  
              
        
'''
'''--- input-files/presentation.json ---
{
  "title":"Learn rust with NEAR",
  "text": "Smart contracts are the back-end of your application that runs code and stores data on the blockchain. All smart contracts on NEAR must be compiled to [WebAssemble](https://webassembly.org/) or simply WASM. Currently, we support two languages [AssembleScript](https://www.assemblyscript.org/) and [Rust](https://www.rust-lang.org/) with custom software development kits (SDKs) to assist in their creation but you can use any programming language and compile it to wasm. But here we will use Rust as it is a powerful language with a great developer experience.",
  "sections":[
    {
      "title": "Your first contract",
      "text":"[status-message](https://github.com/near/near-sdk-rs/tree/master/examples/status-message): records the status messages of the accounts that call this contract.",
      "pages" : [
        {
          "title": "variables and functions",
          "code": "https://github.com/near/near-sdk-rs/blob/1c5106bf0b3380d66d2689174f5e50b612101331/examples/status-message/src/lib.rs#L16-L20",
          "text": "This is a defination for [function](https://doc.rust-lang.org/book/ch03-03-how-functions-work.html) in rust, so here specifing a function name and signatures, set_status is a function with [String](https://doc.rust-lang.org/std/string/struct.String.html) type as input and no return type . First line in the [function](https://doc.rust-lang.org/book/ch03-03-how-functions-work.html) here calls function and creates [variable](https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html) finally assigning the result to this variable, creating a varable in rust like any other language except the [mutability](https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html)."
        },
		{
          "title": "variables and functions",
          "code": "https://github.com/near/near-sdk-rs/blob/1c5106bf0b3380d66d2689174f5e50b612101331/examples/status-message/src/lib.rs#L22-L25",       
	      "text" : "at line 24 we omtted ';' because in rust you can return value implictly like this or using [return](https://doc.rust-lang.org/std/keyword.return.html) keyword like any statement."
		},
		{
          "title": "struct",
          "code": "https://github.com/near/near-sdk-rs/blob/1c5106bf0b3380d66d2689174f5e50b612101331/examples/status-message/src/lib.rs#L9-L11",       
	      "text" : "Rust is like any other other language has primative types like bool,i32,u32, [more types](https://doc.rust-lang.org/book/ch03-02-data-types.html), in addition to [user defined types](https://doc.rust-lang.org/rust-by-example/custom_types.html) like [struct](https://doc.rust-lang.org/rust-by-example/custom_types/structs.html).these lines define structure with name 'StatusMessage' with records as a [hashmap](https://doc.rust-lang.org/std/collections/struct.HashMap.html) member variable, hashmap is a custom variable that is built in the standard library of rust."
		},
		
		{
          "title": "impl for derived types",
          "code": "https://github.com/near/near-sdk-rs/blob/1c5106bf0b3380d66d2689174f5e50b612101331/examples/status-message/src/lib.rs#L14-L26",       
	      "text" : "in rust we can attach functions to the defined struct using [impl](https://doc.rust-lang.org/rust-by-example/generics/impl.html) so the [function](https://doc.rust-lang.org/rus-by-example/fn/methods.html) might be called from the instance or from the type itself, "
		},
		{
          "title": "ownership and borrowing",
          "code": "",       
	      "text" : " to make instance function you must use [self](https://doc.rust-lang.org/std/keyword.self.html), &mut self or &self to refer to the current object.Rust introduces new concept of [ownership](https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html) and [borrowing](https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html) for example when you make the function take 'self' as a prameter so here you give the function the ownership for the current object instead of take a copy of it, but when you pass '&self' or '&mut self' here you make the function borrow the current object for lifetime of the function,"
		},
		{
          "title": "ownership and borrowing",
          "code": "",       
	      "text" : " as we mentioned before declarations of the variable determines the [mutability](https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html) of the variable so '&self' borrows the current object immutable so that it can't be changed and in this case called view method in smart contract code but '&mut self' borrows the current object so that it can't be changed so it is called change in the smart contract code.for example at line 6 we call 'insert' function in 'records' member of the current StatusMessage object so 'insert’ is member function for type of ‘records’"
		},
		{
          "title": "ownership and borrowing",
          "code": "",       
	      "text" : " also we see that at this line we pass 'message' and 'account_id' to the function so here we give this function the ownership of these variable so you can't use them after this line but in other hand at line 11 we pass '&account_id' so it is called borrowing the variable to the function.anther user define type here is the [enum](https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html),enum in rust is like in other languages which represents named values except it can hold data,"
		},
		{
          "title": "ownership and borrowing",
          "code": "",       
	      "text" : " at line 9 we return '[Option](https://doc.rust-lang.org/std/option/)<[String](https://doc.rust-lang.org/std/string/struct.String.html)>' from the function so the function might return 'None' and it is equivalent to 'null' or return 'Some(String)' that has data."
		},
		{
          "title": "importing",
          "code": "https://github.com/near/near-sdk-rs/blob/1c5106bf0b3380d66d2689174f5e50b612101331/examples/status-message/src/lib.rs#L1-L4",       
	      "text" : "here,we are [importing](https://doc.rust-lang.org/reference/items/use-declarations.html) some structs,[traits](https://doc.rust-lang.org/book/ch10-02-traits.html) and other memebers from other libraries,also they are called crates, but to import crate you must mention it in [Cargo.toml](https://doc.rust-lang.org/cargo/guide/cargo-toml-vs-cargo-lock.html) file."
		},
		
		{
          "title": "continue importing and cargo",
          "code": "https://github.com/near/near-sdk-rs/blob/1c5106bf0b3380d66d2689174f5e50b612101331/examples/status-message/Cargo.toml#L1-L11",       
	      "text" : "[Cargo.toml](https://doc.rust-lang.org/cargo/reference/config.html) has configurations for the rust project, package section has fields that define metadata about the project.[depenedencies](https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html) section starting from line 10 has the external crates that used in the project,"
		},
		{
          "title": "continue importing and cargo",
          "code": "",       
	      "text" : " so in line 10 we import 'near-sdk' from this relative path.lib section has configuration for the current lib crate, and 'cdylib' means dynamic system library will be produced."
		}
		
      ]

    },
    {
      "title": "second Contract",
      "text":"[mission-control](https://github.com/near/near-sdk-rs/tree/master/examples/mission-control):implements simulation of a distributed network of drones interacting with the mission control system.",
      "pages" : [
        {
          "title": "if condition",
          "code": "https://github.com/near/near-sdk-rs/blob/1c5106bf0b3380d66d2689174f5e50b612101331/examples/mission-control/src/agent.rs#L32-L34",
          "text": "Rust has [if condition](https://doc.rust-lang.org/rust-by-example/flow_control/if_else.html) like other languages but the `()` is optional, but the strange in rust is if is and expression not statement as we well see."
        },
        {
          "title": "if as expression",
          "code": "https://github.com/near/near-sdk-rs/blob/1c5106bf0b3380d66d2689174f5e50b612101331/examples/mission-control/src/account.rs#L60-L64",
          "text": "as we see at 2th and 4th we didn't put ';' and as we mention previously it's explicit return data from the function so we could understand that 'if expression' returns value so it can be expression."
        },
        {
          "title": "looping",
          "code": "https://github.com/near/near-sdk-rs/blob/1c5106bf0b3380d66d2689174f5e50b612101331/examples/mission-control/src/account.rs#L139-L143",
          "text": "here we use [for](https://doc.rust-lang.org/rust-by-example/flow_control/for.html) to loop over keys, in rust we can loop over [iterators](https://doc.rust-lang.org/std/iter/trait.Iterator.html)"
        },
		 {
          "title": "enum",
          "code": "https://github.com/near/near-sdk-rs/blob/1c5106bf0b3380d66d2689174f5e50b612101331/examples/mission-control/src/account.rs#L28-L31",
          "text" : "here we define [enum](https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html) with two options.[enum](https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html) in rust is like in other languages is custome type which represents named values except it can hold data.[Result](https://doc.rust-lang.org/std/result/) and [Option](https://doc.rust-lang.org/std/option/) are the most important examples for enums and they are builtin the standard library"
        },
		 {
          "title": "match",
          "code": "https://github.com/near/near-sdk-rs/blob/1c5106bf0b3380d66d2689174f5e50b612101331/examples/mission-control/src/account.rs#L35-38",
		  "text" :"[match](https://doc.rust-lang.org/rust-by-example/flow_control/match.html) [expression](https://doc.rust-lang.org/reference/statements-and-expressions.html) in rust is used for pattern matching and here we use it to match againts options (Some('with data') or None)."
        },
		
		 {
          "title": "if let with enum",
          "code": "https://github.com/near/near-sdk-rs/blob/1c5106bf0b3380d66d2689174f5e50b612101331/examples/mission-control/src/agent.rs#L23-28",
          "text" :"[if let](https://doc.rust-lang.org/rust-by-example/flow_control/if_let.html) used in matching againest enums like 'match' expression but it's best practice to use it in case of match againest only one member other wise use 'match', and here is an example of how to uses it to match againest 'Option' enum type. line 3 learn us how to access enum type variabe and it's data."
		},
		{
          "title": "modules",
          "code": "https://github.com/near/near-sdk-rs/blob/1c5106bf0b3380d66d2689174f5e50b612101331/examples/mission-control/src/lib.rs#L1-L7",
          "text" :"This smart contract code is designed in multi[modules](https://doc.rust-lang.org/rust-by-example/mod.html) and the root of the crate is lib.rs combine them all."
		},
		{
          "title": "traits",
          "code": "https://github.com/near/near-sdk-rs/blob/1c5106bf0b3380d66d2689174f5e50b612101331/examples/mission-control/src/account.rs#L103",
          "text" :"rust is not object oriented language but has [traits](https://doc.rust-lang.org/book/ch10-02-traits.html) that can be used to define shared behavior.[PartialEq](https://doc.rust-lang.org/std/cmp/trait.PartialEq.html) is builtin trait for equality and it called operator overload in other languages and here we implement it for Account type by implemting all it's types, we can implment this trait and other operator overload automatically."
		},
		{
          "title": "operations with non-primative types",
          "code": "https://github.com/near/near-sdk-rs/blob/1c5106bf0b3380d66d2689174f5e50b612101331/examples/mission-control/src/account.rs#L42-L44",
          "text" :"here we are making arithmatic operations on non primative types, but we must implement [operator overloads](https://doc.rust-lang.org/rust-by-example/trait/ops.html) traits for them."
		},
		{
          "title": "generics",
          "code": "https://github.com/near/near-sdk-rs/blob/1c5106bf0b3380d66d2689174f5e50b612101331/examples/mission-control/src/account.rs#L82-L84",
          "text" :"here we define function with parameters which one of them is 'op:F' and it is a [generic](https://doc.rust-lang.org/rust-by-example/generics.html) type and here we bounded it with trait type which is [Fn](https://doc.rust-lang.org/std/ops/trait.Fn.html)."
		},
		{
          "title": "macros",
          "code": "https://github.com/near/near-sdk-rs/blob/1c5106bf0b3380d66d2689174f5e50b612101331/examples/mission-control/src/account.rs#L8-L22",
          "text" :"[macros](https://doc.rust-lang.org/rust-by-example/macros.html) in rust allows metaprogramming, there are macro rules and procudure macro and it is an advanced topic with alot of details and you  can read more from [here](http://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/macros.html)."
		},
		{
		  "title": "macros",
          "code": "",
          "text" :"first line use [derive-macro](https://doc.rust-lang.org/reference/attributes/derive.html) to generate implementation for these traits instead of making custom implementation for them.[BorshDeserialize](https://docs.rs/borsh/latest/borsh/de/trait.BorshDeserialize.html), [BorshSerialize](https://docs.rs/borsh/latest/borsh/de/trait.BorshSerialize.html) are used to convert to and from object and binary value but Serialize and Deserialize are used to convert to and from object and json value. "
		},
		{
		  "title": "Clone and Copy traits with macros",
          "code": "https://github.com/near/near-sdk-rs/blob/1c5106bf0b3380d66d2689174f5e50b612101331/examples/mission-control/src/account.rs#L77",
          "text" :"here we use the function 'clone' on the non-primitive variable to get a deplicate of it but this requires that the type of this variable implementing [Clone](https://doc.rust-lang.org/std/clone/trait.Clone.html) trait other wise to get the data you only can move it's ownership if it's not implemnting [Copy](https://doc.rust-lang.org/std/marker/trait.Copy.html) trait, and in the previous code we see that we implemented these traits using derive-macro."
		},
		{
		  "title": "calling macro",
          "code": "https://github.com/near/near-sdk-rs/blob/1c5106bf0b3380d66d2689174f5e50b612101331/examples/mission-control/src/mission_control.rs#L47-49",
          "text" :"It is a defintion for a private function, hashmap! it is [macro rules](https://doc.rust-lang.org/rust-by-example/macros.html) call with key=>value as input, this macro take pramaters and generate code to make a hashmap with this data."
		}
      ]

    },
	{
	   "title": "Learning with fixing errors and warnnings",
	    "text": "we will investigate smart contracts that has warrnings and errors appear when using [cargo check](https://doc.rust-lang.org/cargo/commands/cargo-check.html) then fixing them one by one.we will investigate [status message collection](https://github.com/near/near-sdk-rs/tree/master/examples/status-message-collections) :records the status messages of the accounts that call this contract.",
        "pages" : [
			{
			  "title": "the code with errors",
			  "code": "https://github.com/abdelmonem55/status-message-with-errors/blob/5285e3b77a159a947ddc77f14038205a947f67ee/src/lib.rs#L1-38",
			  "text" :""
			},
			{
			  "title": "missing to import error",
			  "code": "",
			  "rawData":[
			  "```",
			  "error: cannot find derive macro `BorshSerialize` in this scope",
			  "      --> src\\lib.rs:5:10",
			  "      |",
			  "    5 | #[derive(BorshSerialize, BorshStorageKey)]",
			  "      |          ^^^^^^^^^^^^^^",
			  "    error: cannot find derive macro `BorshDeserialize` in this scope",
			  "      --> src\\lib.rs:12:10",
			  "       |",
			  "```"
			  
			  ],
			  "text" :"the compiler here throws error that it can't find 'BorshDeserialize' and 'BorshSeserialize' so to solve it you must provide full path to these traits or include them at start of the file like ```use near_sdk::borsh::{BorshDeserialize, BorshSerialize};```"
			},
			{
			  "title": "mismatch parameter error",
			  "code": "",
			  "rawData":[
			  "```",
			  "      --> src\\lib.rs:32:42",
			  "      |",
			  "   32 |         self.records.insert(&account_id, message);",
			  "      |                                          ^^^^^^^",
			  "      |             expected `&std::string::String`,found struct `std::string::String`",
			  "      |             help: consider borrowing here: `&message`",
			  "      --> src\\lib.rs:12:10",
			  "      |",
			  "```"
			  ],
			  "text" :"Rust compiler is very helpful and lead you fix your error with some advisable messages so here you must pass a reference to the [string](https://doc.rust-lang.org/stable/std/string/struct.String.html) not the string it self"
			},
			{
			  "title": "mismatch return type error",
			  "code": "",
			  "rawData":[
			  "```",
			  "      error[E0308]: mismatched types",
			  "      --> src\\lib.rs:36:60",
			  "      |",
			  "   32 |         pub fn get_status(&mut self, account_id: AccountId) -> Option<String> {",
			  "      |                ----------                                      ^^^^^^^^^^^^^^expected enum `std::option::Option`, found `()`",
			  "      |                |",
			  "      |            implicitly returns `()` as its body has no tail or `return` expression",
			  "   37 |                                       self.records.get(&account_id);",
			  "      |                                      - help: consider removing this semicolon",
			  "      |",
			  "      = note:   expected enum `std::option::Option<std::string::String>`",
			  "                      found unit type `()`",
			  "```"
			  ],
			  "text": "in rust you can return data from the function simply by put the value at the end of the function without a semicolon or put semicolon but use [return](https://doc.rust-lang.org/std/keyword.return.html) keyword, "
			},
			{
			  "title": "continue mismatch return type errors",
			  "code": "",
			  "text" :"so here the compiler says that you return nothing but it function wants [Option](https://doc.rust-lang.org/std/option/) of string to be returned, so fix it by removing the semicolon at the last line in the function so that the return from calling 'get' function could be returned,'error[E0308]' this number could be helpful and you can search with it to get the full details and examples for this error."
			},
			{
			  "title": "mutablity error",
			  "code": "",
			  "rawData":[
			  "```",
			  "      error[E0596]: cannot borrow `self.records` as mutable, as it is behind a `&` reference",
			  "      --> src\\lib.rs:32:9",
			  "      |",
			  "   30 |         pub fn set_status(&self, message: String) -> bool {",
			  "      |                           ----- help: consider changing this to be a mutable reference: `&mut self`",
			  "   31 |         let account_id = env::signer_account_id();",
			  "   32 |         self.records.insert(&account_id, &message);",
			  "      |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^`self` is a `&` reference, so the data it refers to cannot be borrowed as mutable",
			  "```"
			  ],
			  "text" : "in rust in order to modify a variable you must define at as a mutable, so here to here to update in current object you must declare it as [mutable reference](https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html)."
			}
		   
		]
	}
  ]

}

			

			
					   

'''
'''--- input-files/starter.json ---
{
    "title":"Learn rust with NEAR",
    "text"  : "",
    "sections":[
      {
        "title": "Variables and constant",
        "text":"Rust has variables like any other language such as primative and non-primative and there are some special features we will disscus them one by one.",
        "pages" : [
            {
                "title": "primative types",
                "code" :"https://github.com/near/core-contracts/blob/a11e6d4c97336aa47a871083e7b5cb238d3a0eb5/lockup/src/lib.rs#L290",
                "text":  "here we are defining a variable as a parameter of type 'bool'"
             },
            {
                "title": "[const](https://doc.rust-lang.org/std/keyword.const.html)",
                "code" :"", 
                "text": "Rust has compile time const that recommended to be used with values that used many times in addition to it gives readablity for the code, for example here we define a const for image csv value that might be used many times in the program."
            },
            {
                "title": "[static](https://doc.rust-lang.org/reference/items/static-items.html)",
                "code" :"", 
                "text": "Rust has compile time const that recommended to be used with values that used many times in addition to it gives readablity for the code, for example here we define a const for image csv value that might be used many times in the program."
            },
            {
              "title": "[struct](https://doc.rust-lang.org/book/ch05-01-defining-structs.html)",
               "code" :"",
              "text":  "Rust doesn't have classes but instead struct to define a container for data like in these line of code we define a struct with two variables 'token' and 'metadata'."
            },
            {
               "title":  "[enum](https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html)",
               "code" :"",                 
               "text":  "Rust has enums to give names to const variables in additions other featurs we will explore them in next lessons like in this code we define new type called 'StorageKey' with two possibilities 'FungibleToken' and 'Metadata'."
            },
            {
                "title": "[vector](https://doc.rust-lang.org/std/vec/struct.Vec.html)",
                "code":"",
                "text" : "vector is a dynamic list of homogeneous data stored in the heap, so here we creating vector with no element with the help of macro `vec![]`"
            },
            {
                "title": "[array](https://doc.rust-lang.org/rust-by-example/primitives/array.html)",
                "code":"",
                "text" : "array is a collection of contiguous data with same type and it states as fixed size, and here we define array of 3 element of type 'u8'"
            }
           
        ]
          
      },
      {
        "title": "[strings](https://doc.rust-lang.org/rust-by-example/std/str.html)",
        "text":"rust has many types that represents sequence of characters",
        "pages" : [
            {
                "title": "[String](https://doc.rust-lang.org/std/string/index.html)",
                "code" : "",
                "text" : "String is a UTF-8 dynamic groupable list used to store sequence of chars, and we here we call [to_string](https://doc.rust-lang.org/std/string/trait.ToString.html) to get String from the variable of type '&str' we will check it next page"
            },
            {
                "title": "[&str](https://doc.rust-lang.org/std/primitive.str.html)",
                "code" : "",
                "text" : "it is slice version of String so it reference to other type of String ,here we are haveing a string literal of type '&'static str' and this mean it reference to a string with static lifetime which will live lone all program lifetime"
            }
        ]
          
      },
      {
        "title": "functions",
        "text":"like any other language you can define some reusable code and it is called function.",
        "pages" : [
            {
                "title": "function definition and calling",
                "code" : "",
                "text" : "here we are defining a function with name 'get_context', parameter and return type, also at lines 111th to 114 we call functions in a variable called 'builder' and they are [instance functions](https://turreta.com/2019/10/14/static-and-instance-methods-in-struct/) but we will learn them in the next section."
            }
        ]
          
      },
      {
        "title": "impl section, and static and instance functions",
        "text":"Rust is not object oriented language but you can define structs as data container and attach function to operate on this data, also you can do the same for enums.",
        "pages" : [
            {
                "title": "[impl](https://doc.rust-lang.org/std/keyword.impl.html)",
                "code" : "",
                "text":  "here we start to write function to manipulate the derived type"
            },
            {
                "title": "[static function](https://turreta.com/2019/10/14/static-and-instance-methods-in-struct/)",
                "code" : "",
                "text": "inside impl block we can define a static function like this so it can be called from the type itself, here we return [Self](https://stackoverflow.com/questions/32304595/whats-the-difference-between-self-and-self) from the function so here we refere to the current type."
            },
            {
                "title": "[static function](https://turreta.com/2019/10/14/static-and-instance-methods-in-struct/) call",
                "code" : "",
                "text": "here we call a static function 'new' in the type 'VMContextBuilder' and this is widly used method to create a new instance because Rust doesn't have constractor."
            },
            {
                "title": "[instance function](https://turreta.com/2019/10/14/static-and-instance-methods-in-struct/)",
                "code" : "",
                "text" : "inside impl block we can define instance function like this code defines function that takes parameters in addition to '& mut [self](https://doc.rust-lang.org/std/keyword.self.html)', rust introduce new concept called [mutability](https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html) so here we borrow mutable refrence for the current object so that the function can edit on it."
            },
            {
                "title": "instance function and immutable reference",
                "code" : "",
                "text" : "here we define an instance function with '&self' this means the function [borrows](https://doc.rust-lang.org/rust-by-example/scope/borrow.html) the current object for readonly like in first line we use it to get data from the current object"
            },
            {
                "title": "instance function calling",
                "code" : "",
                "text": "line 112 to 114 calling instance function on the variable 'builder' and these lines follows [builder pattern](https://doc.rust-lang.org/1.0.0/style/ownership/builders.html)"
            }
        ]
          
      },
      {
        "title": "[ownership](https://doc.rust-lang.org/rust-by-example/scope/move.html) and [borrowing](https://doc.rust-lang.org/rust-by-example/scope/borrow.html)",
        "text": "rust has unique concept called ownership and borrowing so when you assign variables to anther so most of the time instead of copying, the ownership taken by the second variable, so we can use borrowing and other things so keep the origin variable",
        "pages" : [
            {
                "title": "[Clone](https://doc.rust-lang.org/std/clone/trait.Clone.html) and ownership",
                "code" : "",
                "text" : "as we mention when we use a varable in passing to function or to assign anther variable so the ownership is transfered and the origin variable move and this exist with non-primative types unless they implement [Copy trait](https://doc.rust-lang.org/std/marker/trait.Copy.html), so here we use clone function to make a copy of data and so as not to be moved and reused after that"            }
        ]
          
      },
      {
        "title": "[testing in rust](https://doc.rust-lang.org/book/ch11-01-writing-tests.html)",
        "text":"Tests are Rust functions that verify that the non-test code is functioning in the expected manner.",
        "pages" : [
            {
                "title": "unit test",
                "code" : "",
                "text": "so here we are writing a function and anntotate it as test like in line 118, and we use assertion funtions like at lines 124 and 125"
            }
        ]
          
      },
      {
        "title": "[modules](https://doc.rust-lang.org/rust-by-example/mod.html) and [imports](https://doc.rust-lang.org/reference/items/use-declarations.html)",
        "text":"Rust structure it's code in modules so you can have mutliple files in your projects.",
        "pages" : [
            {
                "title": "importing from other crates",
                "code" : "",
                "text": "these lines imports struct types from other crates that must be mentioned as a dependence in [Cargo.toml](https://doc.rust-lang.org/cargo/reference/manifest.html)."
            },
            {
                "title": "modules",
                "code" : "",
                "text": "we can define new module in rust to structure our code, here we declaring a module at line 101 ,and at line 100 we annotate that it is a test module and use a [compile time switch](https://doc.rust-lang.org/reference/conditional-compilation.html) to compile this module only at non-WASM platform."
            }
        ]
          
      },
      {
        "title": "[macros](https://doc.rust-lang.org/book/ch19-06-macros.html)",
        "text":"Macros are widly used in metaprogramming for generating code at compile time.",
        "pages" : [
            {
                "title": "[procedure macro](https://doc.rust-lang.org/reference/procedural-macros.html)",
                "code" : "",
                "text": "procedure macros allow creating syntax extentions like at first line we attribute the that this struct should generate some code for near, second line [derive-macro](https://doc.rust-lang.org/reference/attributes/derive.html) to generate implementation for these traits instead of making custom implementation for them.[BorshDeserialize](https://docs.rs/borsh/latest/borsh/de/trait.BorshDeserialize.html), [BorshSerialize](https://docs.rs/borsh/latest/borsh/de/trait.BorshSerialize.html) are used to convert to and from object and binary value but Serialize and Deserialize are used to convert to and from object and json value."
            },
            {
                "title": "[macro rules](https://doc.rust-lang.org/rust-by-example/macros.html)",
                "code" : "",
                "text": "macro rules it is a macro like function but evaluated at compile time in addition to have ability to generate codes, this line call macro and as we see it is like call but have '!' so here we call macro called 'log' to log some information to be traced later"
            }
        ]
          
      }
    ]
  
  }
  
              
  
              
                         
  
'''
'''--- output.md ---
<style>
    .present p {
        text-align: left;

    }
</style>

# Learn rust with NEAR

Smart contracts are the back-end of your application that runs code and stores data on the blockchain. All smart contracts on NEAR must be compiled to [WebAssemble](https://webassembly.org/) or simply WASM. Currently, we support two languages [AssembleScript](https://www.assemblyscript.org/) and [Rust](https://www.rust-lang.org/) with custom software development 

---

kits (SDKs) to assist in their creation but you can use any programming language and compile it to wasm. But here we will use Rust as it is a powerful language with a great developer experience.

---

## Your first contract

[status-message](https://github.com/near/near-sdk-rs/tree/master/examples/status-message): records the status messages of the accounts that call this contract.

----

### variables and functions

```rs=16
 pub fn set_status(&mut self, message: String) {
     let account_id = env::signer_account_id();
     log!("{} set_status with message {}", account_id, message);
     self.records.insert(account_id, message);
 }
```

This is a definition for [function](https://doc.rust-lang.org/book/ch03-03-how-functions-work.html) in rust, so here specifing a function name and signatures, set_status is a function with [String](https://doc.rust-lang.org/std/string/struct.String.html) type as input and no return type . First line in the [function](https://doc.rust-lang.org/book/ch03-03-how-functions-work.html) here calls function and creates [variable](https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html) finally assigning the result to this variable, creating a varable in rust like any other language except the [mutability](https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html).

----

### variables and functions

```rs=22
 pub fn get_status(&self, account_id: AccountId) -> Option::<String> {
     log!("get_status for account_id {}", account_id);
     self.records.get(&account_id).cloned()
 }
```

at line 24 we omtted ';' because in rust you can return value implictly like this or using [return](https://doc.rust-lang.org/std/keyword.return.html) keyword like any statement.

----

### struct

```rs=9
pub struct StatusMessage {
    records: HashMap<AccountId, String>,
}
```

Rust is like any other other language has primative types like bool,i32,u32, [more types](https://doc.rust-lang.org/book/ch03-02-data-types.html), in addition to [user defined types](https://doc.rust-lang.org/rust-by-example/custom_types.html) like [struct](https://doc.rust-lang.org/rust-by-example/custom_types/structs.html).these lines define structure with name 'StatusMessage' with records as a [hashmap](https://doc.rust-lang.org/std/collections/struct.HashMap.html) member variable, hashmap is a custom variable that is built in the standard library of rust.

----

### impl for derived types

```rs=14
impl StatusMessage {
    #[payable]
    pub fn set_status(&mut self, message: String) {
        let account_id = env::signer_account_id();
        log!("{} set_status with message {}", account_id, message);
        self.records.insert(account_id, message);
    }

    pub fn get_status(&self, account_id: AccountId) -> Option::<String> {
        log!("get_status for account_id {}", account_id);
        self.records.get(&account_id).cloned()
    }
}
```

in rust we can attach functions to the defined struct using [impl](https://doc.rust-lang.org/rust-by-example/generics/impl.html) so the [function](https://doc.rust-lang.org/rus-by-example/fn/methods.html) might be called from the instance or from the type itself, 

----

### ownership and borrowing

 to make instance function you must use [self](https://doc.rust-lang.org/std/keyword.self.html), &mut self or &self to refer to the current object.Rust introduces new concept of [ownership](https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html) and [borrowing](https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html) for example when you make the function take 'self' as a prameter so here you give the function the ownership for the current object instead of take a copy of it, but when you pass '&self' or '&mut self' here you make the function borrow the current object for lifetime of the function,

----

### ownership and borrowing

 as we mentioned before declarations of the variable determines the [mutability](https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html) of the variable so '&self' borrows the current object immutable so that it can't be changed and in this case called view method in smart contract code but '&mut self' borrows the current object so that it can't be changed so it is called change in the smart contract code.for example at line 6 we call 'insert' function in 'records' member of the current StatusMessage object so 'insert’ is member function for type of ‘records’

----

### ownership and borrowing

 also we see that at this line we pass 'message' and 'account_id' to the function so here we give this function the ownership of these variable so you can't use them after this line but in other hand at line 11 we pass '&account_id' so it is called borrowing the variable to the function.anther user define type here is the [enum](https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html),enum in rust is like in other languages which represents named values except it can hold data,

----

### ownership and borrowing

 at line 9 we return '[Option](https://doc.rust-lang.org/std/option/)<[String](https://doc.rust-lang.org/std/string/struct.String.html)>' from the function so the function might return 'None' and it is equivalent to 'null' or return 'Some(String)' that has data.

----

### importing

```rs=1
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{env, log, metadata, near_bindgen, AccountId};

use std::collections::HashMap;
```

here,we are [importing](https://doc.rust-lang.org/reference/items/use-declarations.html) some structs,[traits](https://doc.rust-lang.org/book/ch10-02-traits.html) and other memebers from other libraries,also they are called crates, but to import crate you must mention it in [Cargo.toml](https://doc.rust-lang.org/cargo/guide/cargo-toml-vs-cargo-lock.html) file.

----

### continue importing and cargo

```rs=1
[package]
name = "status-message"
version = "0.1.0"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2018"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = { path = "../../near-sdk" }
```

[Cargo.toml](https://doc.rust-lang.org/cargo/reference/config.html) has configurations for the rust project, package section has fields that define metadata about the project.[depenedencies](https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html) section starting from line 10 has the external crates that used in the project,

----

### continue importing and cargo

 so in line 10 we import 'near-sdk' from this relative path.lib section has configuration for the current lib crate, and 'cdylib' means dynamic system library will be produced.

---

## second Contract

[mission-control](https://github.com/near/near-sdk-rs/tree/master/examples/mission-control):implements simulation of a distributed network of drones interacting with the mission control system.

----

### if condition

```rs=32
 if lifetime_after <= lifetime_before {
     self.is_alive = false;
 }
```

Rust has [if condition](https://doc.rust-lang.org/rust-by-example/flow_control/if_else.html) like other languages but the `()` is optional, but the strange in rust is if is and expression not statement as we well see.

----

### if as expression

```rs=60
 if success {
     Tranx::Approved(buyer, seller)
 } else {
     Tranx::Denied(deficit)
 }
```

as we see at 2th and 4th we didn't put ';' and as we mention previously it's explicit return data from the function so we could understand that 'if expression' returns value so it can be expression.

----

### looping

```rs=139
 for key in keys {
     let q = lhs.entry(key.clone()).or_insert(Quantity(0));
     let Quantity(lhs_quantity) = *q;
     *q = Quantity(lhs_quantity * rhs_quantity);
 }
```

here we use [for](https://doc.rust-lang.org/rust-by-example/flow_control/for.html) to loop over keys, in rust we can loop over [iterators](https://doc.rust-lang.org/std/iter/trait.Iterator.html)

----

### enum

```rs=28
pub enum Tranx {
    Approved(Account, Account),
    Denied(HashMap<Asset, Quantity>),
}
```

here we define [enum](https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html) with two options.[enum](https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html) in rust is like in other languages is custome type which represents named values except it can hold data.[Result](https://doc.rust-lang.org/std/result/) and [Option](https://doc.rust-lang.org/std/option/) are the most important examples for enums and they are builtin the standard library

----

### match

```rs=35
 match self.0.get(asset) {
     Some(quantity) => quantity.clone(),
     None => Quantity(0),
 }
```

[match](https://doc.rust-lang.org/rust-by-example/flow_control/match.html) [expression](https://doc.rust-lang.org/reference/statements-and-expressions.html) in rust is used for pattern matching and here we use it to match againts options (Some('with data') or None).

----

### if let with enum

```rs=23
 if let Some(Tranx::Approved(buyer, _)) = exs.iter().find_map(|ex| {
     match Account::exchange(rates.get(ex).unwrap(), Quantity(1), &self.account, mission) {
         Tranx::Denied(_) => None,
         tranx => Some(tranx),
     }
 }) {
```

[if let](https://doc.rust-lang.org/rust-by-example/flow_control/if_let.html) used in matching againest enums like 'match' expression but it's best practice to use it in case of match againest only one member other wise use 'match', and here is an example of how to uses it to match againest 'Option' enum type. line 3 learn us how to access enum type variabe and it's data.

----

### modules

```rs=1
mod account;
mod agent;
mod asset;
#[macro_use]
mod macros;
mod mission_control;
mod rate;
```

This smart contract code is designed in multi[modules](https://doc.rust-lang.org/rust-by-example/mod.html) and the root of the crate is lib.rs combine them all.

----

### traits

```rs=103
impl PartialEq for Account {
```

rust is not object oriented language but has [traits](https://doc.rust-lang.org/book/ch10-02-traits.html) that can be used to define shared behavior.[PartialEq](https://doc.rust-lang.org/std/cmp/trait.PartialEq.html) is builtin trait for equality and it called operator overload in other languages and here we implement it for Account type by implemting all it's types, we can implment this trait and other operator overload automatically.

----

### operations with non-primative types

```rs=42
 let credit = &Account(rate.credit.clone()) * quantity;
 let debit = &Account(rate.debit.clone()) * quantity;
 let (buyer, seller) = (&(buyer - &debit) + &credit, &(seller - &credit) + &debit);
```

here we are making arithmatic operations on non primative types, but we must implement [operator overloads](https://doc.rust-lang.org/rust-by-example/trait/ops.html) traits for them.

----

### generics

```rs=82
 fn op<F>(lhs: &Account, rhs: &Account, op: F) -> Account
 where
     F: Fn(&Quantity, &Quantity) -> Quantity,
```

here we define function with parameters which one of them is 'op:F' and it is a [generic](https://doc.rust-lang.org/rust-by-example/generics.html) type and here we bounded it with trait type which is [Fn](https://doc.rust-lang.org/std/ops/trait.Fn.html).

----

### macros

```rs=8
#[derive(
    PartialEq,
    Eq,
    PartialOrd,
    Hash,
    Clone,
    Copy,
    Serialize,
    Deserialize,
    Debug,
    BorshDeserialize,
    BorshSerialize,
)]
#[serde(crate = "near_sdk::serde")]
pub struct Quantity(pub i32);
```

[macros](https://doc.rust-lang.org/rust-by-example/macros.html) in rust allows metaprogramming, there are macro rules and procudure macro and it is an advanced topic with alot of details and you  can read more from [here](http://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/macros.html).

----

### macros

first line use [derive-macro](https://doc.rust-lang.org/reference/attributes/derive.html) to generate implementation for these traits instead of making custom implementation for them.[BorshDeserialize](https://docs.rs/borsh/latest/borsh/de/trait.BorshDeserialize.html), [BorshSerialize](https://docs.rs/borsh/latest/borsh/de/trait.BorshSerialize.html) are used to convert to and from object and binary value but Serialize and Deserialize are used to convert to and from object and json value. 

----

### Clone and Copy traits with macros

```rs=77
 lhs.insert(rhs_key.clone(), Quantity(0));
```

here we use the function 'clone' on the non-primitive variable to get a deplicate of it but this requires that the type of this variable implementing [Clone](https://doc.rust-lang.org/std/clone/trait.Clone.html) trait other wise to get the data you only can move it's ownership if it's not implemnting [Copy](https://doc.rust-lang.org/std/marker/trait.Copy.html) trait, and in the previous code we see that we implemented these traits using derive-macro.

----

### calling macro

```rs=47
 Account(hashmap![
     Asset::MissionTime => Quantity(1000000),
 ])
```

It is a defintion for a private function, hashmap! it is [macro rules](https://doc.rust-lang.org/rust-by-example/macros.html) call with key=>value as input, this macro take pramaters and generate code to make a hashmap with this data.

---

## Learning with fixing errors and warnnings

we will investigate smart contracts that has warrnings and errors appear when using [cargo check](https://doc.rust-lang.org/cargo/commands/cargo-check.html) then fixing them one by one.we will investigate [status message collection](https://github.com/near/near-sdk-rs/tree/master/examples/status-message-collections) :records the status messages of the accounts that call this contract.

----

### the code with errors

```rs=1
use near_sdk::collections::{LookupMap, LookupSet};
use near_sdk::{env, near_bindgen, BorshStorageKey, AccountId};

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
    Records,
    UniqueValues,
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct StatusMessage {
    pub records: LookupMap<AccountId, String>,
    pub unique_values: LookupSet<String>,
}

impl Default for StatusMessage {
    fn default() -> self {
        self {
            records: LookupMap::new(StorageKey::Records),
            unique_values: LookupSet::new(StorageKey::UniqueValues),
        }
    }
}

#[near_bindgen]
impl StatusMessage {
    /// Returns true if the message is unique
    pub fn set_status(&self, message: String) -> bool {
        let account_id = env::signer_account_id();
        self.records.insert(&account_id, message);
        self.unique_values.insert(&message)
    }

    pub fn get_status(&self, account_id: AccountId) -> Option<String> {
        self.records.get(&account_id);
    }
}
```

----

### missing to import error

```
error: cannot find derive macro `BorshSerialize` in this scope
      --> src\lib.rs:5:10
      |
    5 | #[derive(BorshSerialize, BorshStorageKey)]
      |          ^^^^^^^^^^^^^^
    error: cannot find derive macro `BorshDeserialize` in this scope
      --> src\lib.rs:12:10
       |
```

the compiler here throws error that it can't find 'BorshDeserialize' and 'BorshSeserialize' so to solve it you must provide full path to these traits or include them at start of the file like ```use near_sdk::borsh::{BorshDeserialize, BorshSerialize};```

----

### mismatch parameter error

```
      --> src\lib.rs:32:42
      |
   32 |         self.records.insert(&account_id, message);
      |                                          ^^^^^^^
      |             expected `&std::string::String`,found struct `std::string::String`
      |             help: consider borrowing here: `&message`
      --> src\lib.rs:12:10
      |
```

Rust compiler is very helpful and lead you fix your error with some advisable messages so here you must pass a reference to the [string](https://doc.rust-lang.org/stable/std/string/struct.String.html) not the string it self

----

### mismatch return type error

```
      error[E0308]: mismatched types
      --> src\lib.rs:36:60
      |
   32 |         pub fn get_status(&mut self, account_id: AccountId) -> Option<String> {
      |                ----------                                      ^^^^^^^^^^^^^^expected enum `std::option::Option`, found `()`
      |                |
      |            implicitly returns `()` as its body has no tail or `return` expression
   37 |                                       self.records.get(&account_id);
      |                                      - help: consider removing this semicolon
      |
      = note:   expected enum `std::option::Option<std::string::String>`
                      found unit type `()`
```

in rust you can return data from the function simply by put the value at the end of the function without a semicolon or put semicolon but use [return](https://doc.rust-lang.org/std/keyword.return.html) keyword, 

----

### continue mismatch return type errors

so here the compiler says that you return nothing but it function wants [Option](https://doc.rust-lang.org/std/option/) of string to be returned, so fix it by removing the semicolon at the last line in the function so that the return from calling 'get' function could be returned,'error[E0308]' this number could be helpful and you can search with it to get the full details and examples for this error.

----

### mutablity error

```
      error[E0596]: cannot borrow `self.records` as mutable, as it is behind a `&` reference
      --> src\lib.rs:32:9
      |
   30 |         pub fn set_status(&self, message: String) -> bool {
      |                           ----- help: consider changing this to be a mutable reference: `&mut self`
   31 |         let account_id = env::signer_account_id();
   32 |         self.records.insert(&account_id, &message);
      |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^`self` is a `&` reference, so the data it refers to cannot be borrowed as mutable
```

in rust in order to modify a variable you must define at as a mutable, so here to here to update in current object you must declare it as [mutable reference](https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html).

'''
'''--- src/csv_format.rs ---
use crate::{FormatReader, UserData, CodeReader};
use std::error::Error;
use crate::Section;

pub struct CSVFormat;

impl CodeReader for CSVFormat {

}
impl FormatReader for CSVFormat{
    fn read(&self, path: &str) -> Result<UserData, Box<dyn Error>> {
        let mut rdr = csv::Reader::from_reader(std::fs::File::open(path)?);
        let mut data = UserData{ title: "".to_string(), text: "".to_string(), sections: vec![] };

        for result in rdr.deserialize() {
            // Notice that we need to provide a type hint for automatic
            // deserialization.
            let section: Section = result?;
            data.sections.push(section);
            //println!("{:?}", record);
        }

        Ok(data)
    }
}
'''
'''--- src/formatter.rs ---
use serde::{Serialize,Deserialize};
use std::error::Error;
use crate::get_code_from_link;

///green field data to be formatted to presentation
#[derive(Serialize,Deserialize,Default,Debug)]
#[serde(default)]
pub struct UserData{
    pub(crate) title:String,
    pub(crate) text :String,
    pub(crate) sections:Vec<Section>
}

///section that has code and description for this code
#[derive(Serialize,Deserialize,Default,Debug)]
#[serde(default)]
pub struct Section{
    pub(crate) title:String,
    pub(crate) text:String,
    pub(crate) pages:Vec<Page>,
}

///section that has code and description for this code
#[derive(Serialize,Deserialize,Default,Debug)]
#[serde(default)]
pub struct Page{
    pub(crate) title:String,
    pub(crate) code :String,
    ///data that separated into multiple lines
    #[serde(rename="rawData")]
    pub(crate) raw_data :Vec<String>,
    pub(crate) text:String,
}

pub trait CodeReader{
    //returns code and start line number of code
    fn read_code(&self,path:&str)->Result<(String,(usize,usize)),Box<dyn Error>>{
        get_code_from_link(path)
    }
}
pub trait FormatReader:{
    fn read(&self,path: &str) ->Result<UserData,Box<dyn Error>>;
}

pub trait FormatWriter{
    fn writer(&self,path: &str,data:&UserData) ->Result<(),Box<dyn Error>>;
}

'''
'''--- src/hackmd_formatter.rs ---
use crate::{FormatWriter, UserData, Section, get_code_from_link, Page, get_links};
use std::io::Write;
use std::error::Error;

//main page : words 365 at most
//line can hold 53
//we have 13 line in page
//8 lines in main page

const MAIN_PAGE_CHARS:usize = 365;
const LINE_CHARS:usize = 49;
//const PAGE_LINES:usize = 13;
const PAGE_CHARS:usize = 630;
//const PAGE_CHARS:usize = 1188;
const PAGE_HEADLINE_LINES:usize = 1;
//const MAIN_PAGE_HEADLINE_LINES:usize = 3;
///hackmd formatter
pub struct HackMDFormatter;

impl FormatWriter for HackMDFormatter {
    fn writer(&self,path: &str,data:&UserData) ->Result<(),Box<dyn Error>>{
        let mut file_content = String::from("<style>
    .present p {
        text-align: left;

    }
</style>\n\n");
        if !data.title.is_empty(){
            file_content = file_content +"# "+ data.title.as_str() + "\n\n";
        }
        if !data.text.is_empty() {
            let mut txt = data.text.as_str();
            let current_idx = MAIN_PAGE_CHARS;

            //to split intro to many pages
            //todo handle special cases like split at in middle of a word
            loop {
                if txt.len() > current_idx {
                    let (current,change) = txt.split_at(current_idx);
                    file_content.push_str(current);
                    file_content.push_str("\n\n---\n\n");

                    txt = change;
                    //eprintln!("main page data must be {} char at most and this equal 8 lines",MAIN_PAGE_CHARS);
                }else{
                    file_content.push_str(txt);
                    file_content.push_str("\n\n");
                    break;
                }

            }
        }

        let mut file = std::fs::File::create(path)?;
        file_content.push_str(&*format_sections_for_hackmd(&data.sections)?);
        file.write_all(file_content.as_bytes())?;
        Ok(())
    }
}

fn format_pages_for_hackmd(pages:&Vec<Page>) ->Result<String,Box<dyn Error>>{
    let mut str = String::new();
    // if let Some(first_pg) =pages.get(0){
    //     //str.push_str("---\n\n");
    //     format_page_for_hackmd(first_pg,&mut str)?
    // }
    for i in 0..pages.len(){
        str.push_str("----\n\n");
        str.push('#');
        format_page_for_hackmd(&pages[i],&mut str)?;
    }
    Ok(str)
}

fn get_represented_text_count(str:&str)->usize{
    //'[ , ']'  start and end of the link title, in addition to '(' and ')'
    const ADDITION_CHARS_COUNT:usize = 4;
    let links_data = get_links(str);
    let links_text_count = links_data.iter().fold(0,|acc,(_,link)|{
        acc + link.len() + ADDITION_CHARS_COUNT
    });
    str.len() - links_text_count
}
fn format_page_for_hackmd(page:&Page,data:&mut String)->Result<(),Box<dyn Error>>{
    const MAX_CODE_LINES_BEFORE_SCROLL:usize = 7;
    //let mut data = String::new();
    //write the title
    let title_count = if !page.title.is_empty(){
        *data = data.to_owned() + "## " + page.title.as_str() + "\n\n";
        1
    }else{
        0
    };

    //write the code
    let code_lines_count = if !page.code.is_empty(){
        let (code,(start,end)) = get_code_from_link(page.code.as_str())?;
        if !code.is_empty() {
            *data = data.to_string() + &*format!("```rs={}\n",start) + code.as_str() + "\n```\n\n";
        }
        //lines number
        //5/8 gotten from try and error
        let lines_counts =  ( (end +1 - start)/2)+1;
        if lines_counts > MAX_CODE_LINES_BEFORE_SCROLL{
            MAX_CODE_LINES_BEFORE_SCROLL
        }else {
            lines_counts
        }
    }else{
        0
    };
    //todo handle count of previous lines
    let raw_data_lines_count = if !page.raw_data.is_empty(){
        //let (code,(start,end)) = get_code_from_link(page.code.as_str())?;
            *data = data.to_string() + &*page.raw_data.join("\n") + "\n\n";
        //1/2 gotten from try and error
       let size = (page.raw_data.len() / 2) + 1;
        if size > MAX_CODE_LINES_BEFORE_SCROLL{
            MAX_CODE_LINES_BEFORE_SCROLL
        }else {
            size
        }
    }else{
        0
    };
    let used_chars = (code_lines_count + title_count + raw_data_lines_count) * LINE_CHARS  ;
 //   println!("used {:?} ,{} {} {}",used_chars, code_lines_count,title_count,page.text.len());
 //   println!("{:?}",page.text);
    let change_size:isize = PAGE_CHARS as isize - used_chars as isize;
   // let change_size = 350;
    if !page.text.is_empty() {
        let represented_text_len = get_represented_text_count(page.text.as_str());
        if PAGE_CHARS <= used_chars{
            eprintln!("page text with title:{} must be shifted to the next page",page.title)
        }
        else if represented_text_len as isize > change_size{
            eprintln!("page text with title:{} must be {} at most but you enter {}",page.title,change_size,represented_text_len);
        }
        data.push_str(page.text.as_str());
        data.push_str("\n\n");
    }
    Ok(())
}
fn format_sections_for_hackmd(sections:&Vec<Section>)->Result<String,Box<dyn Error>>{
    let mut data = String::new();
    for section in sections{
        data.push_str("---\n\n");
        if !section.title.is_empty(){
            data = data + "## " + section.title.as_str() + "\n\n";
        }
        if !section.text.is_empty(){
            let head_chars = if !section.text.is_empty(){
                PAGE_HEADLINE_LINES * LINE_CHARS
            }else{
                0
            };
            let txt_chars:isize = PAGE_CHARS as isize - head_chars as isize;
            if section.text.len() as isize > txt_chars{
                eprintln!("section text with title:'{}' must be {} at most",section.title,txt_chars);
                
            }
            data = data + section.text.as_str() + "\n\n";
        }
        data.push_str(&*format_pages_for_hackmd(&section.pages)?);
    }
    Ok(data)
}
'''
'''--- src/json_format.rs ---
use crate::{FormatReader, UserData, CodeReader};
use std::error::Error;

pub struct JsonFormat;

impl CodeReader for JsonFormat {

}
impl FormatReader for JsonFormat {
    fn read(&self,path: &str) ->Result<UserData,Box<dyn Error>> {
        let data = std::fs::read_to_string(path)?;
        let data:UserData = serde_json::from_str(data.as_str())?;
        //todo use get_code_from_link() after handling vertical and horizontal
        Ok(data)
    }
}

'''
'''--- src/main.rs ---
mod formatter;
mod json_format;
mod hackmd_formatter;
mod csv_format;
mod util;

pub use formatter::*;
pub use json_format::*;
pub use hackmd_formatter::*;
pub use csv_format::*;
pub use util::*;

// fn main() {
//     //let format = JsonFormat;
//     let hackmd = HackMDFormatter;
//     let csv = CSVFormat;
//     let data = csv.read("./input.csv").unwrap();
//     let str = hackmd.writer("./readme.md",&data);
//     println!("{:?}",str);
//     println!("Hello, world!");
// }

use clap::Parser;
use std::error::Error;

/// Simple program to greet a person
#[derive(Parser, Debug)]
#[clap(author, version, about, long_about = None)]
struct Args {
    /// input file path
    #[clap(long)]
    input_file:String,
    /// output file path
    #[clap( long,default_value="./output.md")]
    output_file:String,
    /// input file format
    #[clap(long,default_value="json")]
    input_format:String,
    /// output file format
    #[clap(long,default_value="hackmd")]
    output_format:String,
}

//#[tokio::main]
fn main()->Result<(),Box<dyn Error>> {
    // let data = get_code_from_link(
    //     "https://github.com/abdelmonem17/presentation-formatter/blob/3e90ca7940feb272125d143ce19a064e9e9e8628/Cargo.toml#L6-L9");
    // println!("{:?}",data);
    // return Ok(());
    let args = Args::parse();
    let input_format:Box<dyn FormatReader> = match args.input_format.as_str(){
        "json"=>Box::new(JsonFormat),
        "csv"=>Box::new(CSVFormat),
        _=>unimplemented!()
    };
    let formatter:Box<dyn FormatWriter> = match args.output_format.as_str(){
        "hackmd"=>Box::new(HackMDFormatter),
        _=>unimplemented!()
    };
    let data = input_format.read(args.input_file.as_str()).unwrap();
    formatter.writer(args.output_file.as_str(),&data).unwrap();
    println!("done!!");
    Ok(())

}
'''
'''--- src/util.rs ---
use std::error::Error;
//use std::collections::HashMap;
//use std::sync::Mutex;

//use lazy_static::lazy_static;
//use std::cell::RefCell;
use std::io;
use std::io::ErrorKind;
// use std::thread_local;
// thread_local! {
//  pub static CODES:RefCell<HashMap<String,String>> = RefCell::new(HashMap::new());
// }

#[derive(Debug)]
pub struct LinkInfo{
    line_number: String,
    raw_link: String
}
fn get_raw_link_and_line_number(link:&str)->Result<LinkInfo,Box<dyn Error>>{
    //old
    //https://github.com/abdelmonem17/starter-rs/main/Cargo.toml
    //new
    //https://raw.githubusercontent.com/abdelmonem17/starter-rs/main/Cargo.toml
    let link = link.replace("https://github.com/","https://raw.githubusercontent.com/");
    let hash_position = link.rfind("#")
        .ok_or(std::io::Error::new(ErrorKind::InvalidData
                                   ,"the url format must be like: https://github.com/path-to-file#line_number"))?;
    let (raw_link,line_number,) = link.split_at(hash_position);
    Ok(LinkInfo{ line_number:line_number.replace('#',""),raw_link:raw_link.replace("/blob","") })
}

///get line of codes that determined in the url and (start,end) of the lines
pub fn get_code_from_link(url:&str) ->Result<(String,(usize,usize)),Box<dyn Error>>{
    let info = get_raw_link_and_line_number(url)?;
  //  println!("{:?}",info);
    //todo use async version
    let response =  reqwest::blocking::get(info.raw_link.as_str())?;
    let body = response.bytes()?;
    let code = String::from_utf8_lossy(body.as_ref());
    //let mut space_count = 0;
    let (lines,lines_info) = get_lines_from_code(code.as_ref(),info.line_number.as_str())?;
    Ok((lines,lines_info))
}

///returns (code,(start_line_number,end))
fn get_lines_from_code<'s>(code:&'s str,code_line:&str)->Result<(String,(usize,usize)),Box<dyn Error>>{
    let lines = code_line.split('-').map(|st|
        st.trim_start_matches('L')
            .parse()
            .map_err(|_e| io::Error::new(ErrorKind::InvalidData,format!("can't parse line number {}",st)) )

    ).collect::<Result<Vec<usize>,io::Error>>()?;
    let end = lines.get(1).unwrap_or(&lines[0]);
   Ok((get_line_by_numbers(code,lines[0],*end)?,(lines[0],*end) ))
}

fn get_line_by_numbers(code:&str,start:usize,end:usize)->Result<String,Box<dyn Error>>{
   // let mut space_count = 0;
    /*let mut spaces = String::new();
    for ch in code.as_ref().chars(){
        if space_count == 0{
            println!("start char '{}' and {}",ch,ch as u8);
            space_count =1;
        }
        if ch == ' '{
            //   space_count +=1;
            spaces.push(' ');
        }else{
            break;
        }
    }
    let code:String = code.as_ref().split('\n').map(|line:&str| {
        println!("before '{}'",line);
        let str = line.replacen(spaces.as_str(), "",1);
        println!("after '{}'",str);
        str
    })
        .collect::<Vec<String>>().join("\n");*/
    let lines = code.split('\n')
        .skip(start - 1).take(end - start + 1)
        .collect::<Vec<_>>();
    let  first_line = lines[0].chars();
    let mut spaces = String::new();
    for ch in first_line{
        // if space_count == 0{
        //     println!("start char '{}' and {}",ch,ch as u8);
        //     space_count =1;
        // }
        if ch == ' '{
            //   space_count +=1;
            spaces.push(' ');
        }else{
            break;
        }
    }
    spaces.pop();
   // println!("line:{:?}\nspaces :{:?}",lines[0],spaces);
    let lines:String = lines.iter().map(|line| line.replacen(spaces.as_str(),"",1))
        .collect::<Vec<_>>().join("\n");
    Ok(lines)
}

///returns Vec<(Title,link)>
pub fn get_links(data:&str)->Vec<(String,String)> {
    let mut out = Vec::new();
    let regex = regex::Regex::new(r"\[(?P<title>.+?)\]\((?P<link>.+?)\)").unwrap();
    let matches = regex.captures_iter(data);
    for mat in matches{
        out.push((mat.name("title").unwrap().as_str().to_string()
                  , mat.name("link").unwrap().as_str().to_string()))
    }
    out
}
'''