*GitHub Repository "LastDarkNes/simple-rust-game"*

'''--- .gitpod.yml ---
image:
  file: .gitpod.Dockerfile
# Options to prebuild the image after github events and set notifications/badges
github:
  prebuilds:
    # enable for the master/default branch (defaults to true)
    master: true
    # enable for all branches in this repo (defaults to false)
    branches: true
    # enable for pull requests coming from this repo (defaults to true)
    pullRequests: true
    # enable for pull requests coming from forks (defaults to false)
    pullRequestsFromForks: true
    # add a check to pull requests (defaults to true)
    addCheck: true
    # add a "Review in Gitpod" button as a comment to pull requests (defaults to false)
    addComment: true
    # add a "Review in Gitpod" button to the pull request's description (defaults to false)
    addBadge: false
    # add a label once the prebuild is ready to pull requests (defaults to false)
    addLabel: false

# List the start up tasks. You can start them in parallel in multiple terminals. See https://www.gitpod.io/docs/config-start-tasks/
tasks:
  - before: echo "nvm use 14.19.3" >> ~/.bashrc && npm install -g near-cli && nvm use 14.19.3
    init: yarn
    command: source ~/.bashrc; gp open README-Gitpod.md && yarn dev

ports:
  - port: 1234
    onOpen: open-browser
  - port: 5000
    onOpen: ignore

'''
'''--- .theia/settings.json ---
{
    "editor.wordWrap": "on",
    "editor.fontSize": 19,
    "terminal.integrated.fontSize": 17,
    "editor.suggestFontSize": 16
}

'''
'''--- .travis.yml ---
language: rust
rust:
  - stable
os:
  - linux
  - osx
  - windows
env:
  - NODE_ENV=ci YARN_GPG=no
cache: cargo
before_install:
  - rustup target add wasm32-unknown-unknown
  - if [[ "$TRAVIS_OS_NAME" == "windows" ]]; then HOME="/c/Users/travis" && export NVS_HOME=$ProgramData/nvs && git clone --single-branch https://github.com/jasongin/nvs $NVS_HOME && source $NVS_HOME/nvs.sh && nvs --version && nvs add 12 && nvs use 12; fi
  - if [[ ! "$TRAVIS_OS_NAME" == "windows" ]]; then nvm install 12 && nvm use 12; fi
  - npm install -g yarn
  - yarn
git:
  autocrlf: false
script:
  - yarn test
'''
'''--- README.md ---
Simple blockcain entity game
=================================

<!-- MAGIC COMMENT: DO NOT DELETE! Everything above this line is hidden on NEAR Examples page -->

## Description

This contract implements simple  entity game backed by storage on blockchain.
Contract in `contract/src/lib.rs` provides methods to increment / decrement counter and get it's current value or reset.

Plus and minus buttons increase and decrease value correspondingly. When button L is toggled, a little light turns on, just for fun. RS button is for reset. LE and RE buttons to let the robot wink at you.

## To Run
Open in the Gitpod link above or clone the repository.

```
git clone https://github.com/near-examples/rust-counter
```

## Setup [Or skip to Login if in Gitpod](#login)
Install dependencies:

```
yarn
```

If you don't have `Rust` installed, complete the following 3 steps:

1) Install Rustup by running:

```
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
```

([Taken from official installation guide](https://www.rust-lang.org/tools/install))

2) Configure your current shell by running:

```
source $HOME/.cargo/env
```

3) Add wasm target to your toolchain by running:

```
rustup target add wasm32-unknown-unknown
```

Next, make sure you have `near-cli` by running:

```
near --version
```

If you need to install `near-cli`:

```
npm install near-cli -g
```

## Login
If you do not have a NEAR account, please create one with [NEAR Wallet](https://wallet.testnet.near.org).

In the project root, login with `near-cli` by following the instructions after this command:

```
near login
```

Modify the top of `src/config.js`, changing the `CONTRACT_NAME` to be the NEAR account that was just used to log in.

```javascript
…
const CONTRACT_NAME = 'YOUR_ACCOUNT_NAME_HERE'; /* TODO: fill this in! */
…
```

Start the example!

```
yarn start
```

## To Test

```
yarn test
```

## To Explore

- `contract/src/lib.rs` for the contract code
- `src/index.html` for the front-end HTML
- `src/main.js` for the JavaScript front-end code and how to integrate contracts
- `src/test.js` for the JS tests for the contract

## To Build the Documentation

```
cd contract
cargo doc --no-deps --open
```

'''
'''--- contract/Cargo.toml ---
[package]
name = "counter_contract"
version = "1.0.0"
authors = ["Near Inc <hello@near.org>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0"
uint = { version = "0.9.3", default-features = false }

[dev-dependencies]
near-sdk-sim = "3.2.0"

[profile.release]
codegen-units = 1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true
'''
'''--- contract/src/lib.rs ---
//! This contract implements simple counter backed by storage on blockchain.
//!
//! The contract provides methods to [increment] / [decrement] counter and
//! get it's current value [get_num] or [reset].
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{log, near_bindgen};
use near_sdk::env::{block_timestamp, predecessor_account_id};
use std::collections::{HashMap};
// use near_sdk::collections::{LookupMap};
    

#[derive(BorshDeserialize, BorshSerialize)]
pub struct Game {
    balance: u64,
    entity_stack: [u8; 12],
    last_click: u64,
    current_click: u64,
}
    

impl Game {
    pub fn new() -> Game {
        Game {
            balance: 1000u64,
            entity_stack: [0; 12],
            last_click: 0u64,
            current_click: 0u64,
        }
    }
}

#[near_bindgen]
#[derive(Default, BorshDeserialize, BorshSerialize)]
pub struct Main {
    max_entity_level: u8,
    max_user_balance: u64,
    users: HashMap<String, Game>,
}

#[near_bindgen]
impl Main {
    // self.max_user_balance = 20_000;
    // self.max_entity_level = 10;

    /// Support methods:

    pub fn validate_user(&mut self, user: String) {
        if !self.users.contains_key(&user) {
            self.users.insert(user, Game::new());
        }
    }

    // Returns players balance
    pub fn get_balance(&self) -> u64 {
        let user = predecessor_account_id().to_string();
        self.validate_user(user);
        let mut user_data = self.users.get(&user);

        return user_data.balance;
    }

    // Returns players entity_stack
    pub fn get_entity_stack(&self) -> [u8; 12]  {
        let user = predecessor_account_id().to_string();
        self.validate_user(user);
        let mut user_data = self.users.get(&user);

        return user_data.entity_stack;
    }

    // Returns max entity tier from players stack
    pub fn get_max_tier_entity(&self) -> u8{
        let user = predecessor_account_id().to_string();
        self.validate_user(user);
        let mut user_data = self.users.get(&user);

        let mut max = 0u8;

        for i in user_data.entity_stack {

            if i > max {
                max = i;
            }
        }

        return max;
    }

    // Adds new entity to players stack
    // !!!PRIVATE METHOD!!!
    fn add_entity(&mut self, tier: u8, slot: usize) {
        let user = predecessor_account_id().to_string();
        self.validate_user(user);
        let mut user_data = self.users.get(&user);

        user_data.entity_stack[slot] = tier; 
    }

    // Players methods:

    //Buyes new entities by players balance
    pub fn buy_entity(&mut self, tier: u8) {
        let user = predecessor_account_id().to_string();
        self.validate_user(user);
        let mut user_data = self.users.get(&user);

        let mut index = 0usize;
        let max_tier_entity = self.get_max_tier_entity();
        let cost = u64::from(tier) * 1000;

        if max_tier_entity < tier {
            panic!("Your max entity tier is {}, you need at least one {} tier entity", max_tier_entity, tier);

        } else if self.balance < cost {
            panic!("You are not enough money");

        } else if tier > self.max_entity_level {
            panic!("Requested entity tier greater than maximum");
        }

        for i in user_data.entity_stack {
            index += 1;

            if i == 0 {
                self.add_entity(tier, index - 1);
                user_data.balance -= cost;
                break;

            }
       
        }
        panic!("You are hasn't empety slots");
    }

    // Merging two same tier entities from players stack
    pub fn merge_entities(&mut self, st_slot: usize, nd_slot: usize) {
        let user = predecessor_account_id().to_string();
        self.validate_user(user);
        let mut user_data = self.users.get(&user);

        let st_entity = user_data.entity_stack[st_slot]; 
        let nd_entity = user_data.entity_stack[nd_slot];

        if st_entity != nd_entity {

            panic!("You can merge only same tier entities");

        } else {

            user_data.entity_stack[nd_slot] = nd_entity + 1;
            user_data.entity_stack[st_slot] = 0;
        }
    }

    // By clicking gives to player 100*sum_all_tiers scores and returns new balance
    // P.S Work every 5 min
    pub fn click(&mut self) {
        let user = predecessor_account_id().to_string();
        self.validate_user(user);
        let mut user_data = self.users.get(&user);

        let mut summ = 0u64;
        user_data.current_click = block_timestamp();

        
        if user_data.current_click - user_data.last_click >= 60000000000 || user_data.last_click == 0 {

            for i in user_data.entity_stack{
                summ += i;
            }
            user_data.balance += summ * 100;
            user_data.last_click = user_data.current_click;
            
        } else {
            panic!("You can't click now");    
        }
        
    }

    
}

/*
 * the rest of this file sets up unit tests
 * to run these, the command will be: `cargo test`
 * Note: 'rust-counter-tutorial' comes from cargo.toml's 'name' key
 */

// use the attribute below for unit tests
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn get_balance() {
        let game = Game {
            balance: 1000,
            entity_stack: [0; 12],
            last_click: 0,
            current_click: 0,
        };

        assert_eq!(1000, game.balance);
    }

    #[test]
    fn get_entity_stack() {
        let game = Game {
            balance: 1000,
            entity_stack: [0; 12],
            last_click: 0,
            current_click: 0,
        };
        
        assert_eq!([0; 12], game.entity_stack);
    }

    #[test]
    fn buy_entity() {
        let mut game = Game {
            balance: 3000,
            entity_stack: [0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            last_click: 0,
            current_click: 0,
        };

        game.buy_entity(2);
        assert_eq!(2, game.entity_stack[0]);

    }

    #[test]
    #[should_panic]
    fn buy_entity2() {
        let mut game = Game {
            balance: 2000,
            entity_stack: [1, 1, 2, 2, 3, 4, 5, 1, 1, 2, 3, 4],
            last_click: 0,
            current_click: 0,
        };

        
        game.buy_entity(1)

    }

 
}

'''
'''--- integration-tests/README.md ---

'''
'''--- integration-tests/rs/Cargo.toml ---
[package]
name = "integration-tests"
version = "1.0.0"
publish = false
edition = "2018"

[dev-dependencies]
anyhow = "1.0"
borsh = "0.9"
maplit = "1.0"
near-units = "0.2.0"
# arbitrary_precision enabled for u128 types that workspaces requires for Balance types
serde_json = { version = "1.0", features = ["arbitrary_precision"] }
tokio = { version = "1.18.1", features = ["full"] }
tracing = "0.1"
tracing-subscriber = { version = "0.3.11", features = ["env-filter"] }
workspaces = "0.2.1"
pkg-config = "0.3.1"

[[example]]
name = "integration-tests"
path = "src/tests.rs"
'''
'''--- integration-tests/rs/src/tests.rs ---
use near_units::parse_near;
use serde_json::json;
use workspaces::prelude::*;
use workspaces::{network::Sandbox, sandbox, Account, Contract, Worker};

const WASM_FILEPATH: &str = "../../out/main.wasm";

// #[tokio::main]
// async fn main() -> anyhow::Result<()> {
//   let sandbox = sandbox().await?;
//   let wasm = std::fs::read(WASM_FILEPATH)?;
//   let contract = sandbox.dev_deploy(&wasm).await?;

//   // create accounts
//   let owner = sandbox.root_account();
//   let user = owner
//     .create_subaccount(&sandbox, "user")
//     .initial_balance(parse_near!("30 N"))
//     .transact()
//     .await?
//     .into_result()?;

//   test_increment(&user, &contract, &sandbox).await?;
//   test_decrement(&user, &contract, &sandbox).await?;
//   test_reset(&user, &contract, &sandbox).await?;

//   Ok(())
// }

// async fn test_increment(
//   user: &Account,
//   contract: &Contract,
//   sandbox: &Worker<Sandbox>,
// ) -> anyhow::Result<()> {
//   let start_counter: u64 = user
//     .call(&sandbox, contract.id(), "get_num")
//     .args_json(json!({}))?
//     .transact()
//     .await?
//     .json()?;

//   user
//     .call(&sandbox, contract.id(), "increment")
//     .args_json(json!({}))?
//     .transact()
//     .await?;

//   let end_counter: u64 = user
//     .call(&sandbox, contract.id(), "get_num")
//     .args_json(json!({}))?
//     .transact()
//     .await?
//     .json()?;

//   assert_eq!(end_counter, start_counter + 1);
//   println!("Increment ✅");
//   Ok(())
// }

// async fn test_decrement(
//   user: &Account,
//   contract: &Contract,
//   sandbox: &Worker<Sandbox>,
// ) -> anyhow::Result<()> {
//   user
//     .call(&sandbox, contract.id(), "increment")
//     .args_json(json!({}))?
//     .transact()
//     .await?;

//   let start_counter: u64 = user
//     .call(&sandbox, contract.id(), "get_num")
//     .args_json(json!({}))?
//     .transact()
//     .await?
//     .json()?;

//   user
//     .call(&sandbox, contract.id(), "decrement")
//     .args_json(json!({}))?
//     .transact()
//     .await?;

//   let end_counter: u64 = user
//     .call(&sandbox, contract.id(), "get_num")
//     .args_json(json!({}))?
//     .transact()
//     .await?
//     .json()?;

//   assert_eq!(end_counter, start_counter - 1);
//   println!("Decrement ✅");
//   Ok(())
// }

// async fn test_reset(
//   user: &Account,
//   contract: &Contract,
//   sandbox: &Worker<Sandbox>,
// ) -> anyhow::Result<()> {
//   user
//     .call(&sandbox, contract.id(), "increment")
//     .args_json(json!({}))?
//     .transact()
//     .await?;

//   user
//     .call(&sandbox, contract.id(), "increment")
//     .args_json(json!({}))?
//     .transact()
//     .await?;

//   user
//     .call(&sandbox, contract.id(), "reset")
//     .args_json(json!({}))?
//     .transact()
//     .await?;

//   let end_counter: u64 = user
//     .call(&sandbox, contract.id(), "get_num")
//     .args_json(json!({}))?
//     .transact()
//     .await?
//     .json()?;

//   assert_eq!(end_counter, 0);
//   println!("Reset ✅");
//   Ok(())
// }

'''
'''--- integration-tests/ts/main.ava.ts ---
import { Worker, NEAR, NearAccount } from "near-workspaces";
import anyTest, { TestFn } from "ava";

const test = anyTest as TestFn<{
  worker: Worker;
  accounts: Record<string, NearAccount>;
}>;

test.beforeEach(async (t) => {
  // Init the worker and start a Sandbox server
  const worker = await Worker.init();
  const root = worker.rootAccount;

  // deploy contract
  const contract = await root.createAndDeploy(
    root.getSubAccount("rust-counter").accountId,
    "./out/main.wasm",
    { initialBalance: NEAR.parse("30 N").toJSON() }
  );

  // some test accounts
  const alice = await root.createSubAccount("alice", {
    initialBalance: NEAR.parse("30 N").toJSON(),
  });
  const bob = await root.createSubAccount("bob", {
    initialBalance: NEAR.parse("30 N").toJSON(),
  });
  const charlie = await root.createSubAccount("charlie", {
    initialBalance: NEAR.parse("30 N").toJSON(),
  });

  // Save state for test runs, it is unique for each test
  t.context.worker = worker;
  t.context.accounts = { root, contract, alice, bob, charlie };
});

test.afterEach(async (t) => {
  // Stop Sandbox server
  await t.context.worker.tearDown().catch((error) => {
    console.log("Failed to stop the Sandbox:", error);
  });
});

test("can be incremented", async (t) => {
  const { root, contract } = t.context.accounts;
  const startCounter: number = await contract.view("get_num", {});
  await root.call(contract, "increment", {});
  const endCounter = await contract.view("get_num", {});
  t.is(endCounter, startCounter + 1);
});

test("can be decremented", async (t) => {
  const { root, contract } = t.context.accounts;
  await root.call(contract, "increment", {});
  const startCounter: number = await contract.view("get_num", {});
  await root.call(contract, "decrement", {});
  const endCounter = await contract.view("get_num", {});
  t.is(endCounter, startCounter - 1);
});

test("can be reset", async (t) => {
  const { root, contract } = t.context.accounts;
  await root.call(contract, "increment", {});
  await root.call(contract, "increment", {});
  await root.call(contract, "reset", {});
  const endCounter = await contract.view("get_num", {});
  t.is(endCounter, 0);
});

'''
'''--- package.json ---
{
  "name": "counter",
  "description": "A Rust counter that lives in the NEAR blockchain.",
  "version": "1.0.0",
  "license": "(MIT AND Apache-2.0)",
  "scripts": {
    "build": "npm run build:rustup && npm run build:cpwasm",
    "build:rustup": "cd contract && rustup target add wasm32-unknown-unknown && cargo build --all --target wasm32-unknown-unknown --release",
    "build:cpwasm": "mkdir -p out && rm -f ./out/main.wasm && cp ./contract/target/wasm32-unknown-unknown/release/counter_contract.wasm ./out/main.wasm",
    "deploy": "npm run build && near dev-deploy",
    "start": "npm run deploy && echo The app is starting! && env-cmd -f ./neardev/dev-account.env parcel frontend/index.html --open",
    "dev": "nodemon --watch contract -e ts --exec \"npm run start\"",
    "test": "npm run build && npm run test:unit && npm run test:integration",
    "test:unit": "cd contract && cargo test",
    "test:integration": "npm run test:integration:ts && npm run test:integration:rs",
    "test:integration:ts": "ava --verbose",
    "test:integration:rs": "cd integration-tests/rs && cargo run --example integration-tests"
  },
  "devDependencies": {
    "ava": "^4.2.0",
    "env-cmd": "^10.1.0",
    "near-cli": "^3.2.0",
    "near-workspaces": "^2.0.0",
    "nodemon": "~2.0.15",
    "parcel-bundler": "~1.12.5",
    "ts-node": "^10.7.0",
    "typescript": "^4.6.4"
  },
  "dependencies": {
    "near-api-js": "^0.44.2",
    "regenerator-runtime": "^0.13.9"
  },
  "main": "index.js",
  "repository": "https://github.com/near-examples/rust-counter",
  "author": "LastDarkNeS <shark6399@gmail.com>"
}

'''