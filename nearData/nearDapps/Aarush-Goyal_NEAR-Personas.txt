*GitHub Repository "Aarush-Goyal/NEAR-Personas"*

'''--- contract/as-pect.config.js ---
module.exports = require('near-sdk-as/imports')
'''
'''--- contract/compile.js ---
// This file does two things:
//
// 1. Compile the AssemblyScript contract using the scripts in package.json
//    (see buildCmd below). This will create a wasm file in the 'build' folder.
// 2. Create a symbolic link (symlink) to the generated wasm file in the root
//    project's `out` folder, for easy use with near-cli.
//
// First, import some helper libraries. `shelljs` is included in the
// devDependencies of the root project, which is why it's available here. It
// makes it easy to use *NIX-style scripting (which works on Linux distros,
// macOS, and Unix systems) on Windows as well.
const sh = require('shelljs')
const path = require('path')

// Figure out which directory the user called this script from, which we'll use
// later to set up the symlink.
const calledFromDir = sh.pwd().toString()

// For the duration of this script, we want to operate from within the
// AssemblyScript project's folder. Let's change into that directory.
sh.cd(__dirname)

// You can call this script with `node compile.js` or `node compile.js --debug`.
// Let's set a variable to track whether `--debug` was used.
const debug = process.argv.pop() === '--debug'

// Use the correct build command based on the `--debug` flag
const buildCmd = debug
  ? 'npm run build:debug'
  : 'npm run build'

// Execute the build command, storing exit code for later use
const { code } = sh.exec(buildCmd)

// Assuming this is compiled from the root project directory, link the compiled
// contract to the `out` folder –
// When running commands like `near deploy`, near-cli looks for a contract at
// <CURRENT_DIRECTORY>/out/main.wasm
if (code === 0 && calledFromDir !== __dirname) {
  const linkDir = `${calledFromDir}/out`
  const link = `${calledFromDir}/out/main.wasm`
  const packageName = require(`${__dirname}/package.json`).name
  const outFile = `./build/${debug ? 'debug' : 'release'}/${packageName}.wasm`
  sh.mkdir('-p', linkDir)
  sh.rm('-f', link)
  const linkPath = path.relative(linkDir, outFile)
  sh.ln('-s', linkPath, link)
}

// exit script with the same code as the build command
process.exit(code)

'''
'''--- server.js ---
const express = require('express')
const bodyParser = require('body-parser')
const path = require('path')
const app = express()

app.use(express.static(path.join(__dirname, 'dist')));

app.get('/', function (req, res) {
  res.sendFile(path.join(__dirname, 'dist', 'index.html'));
});

app.listen(process.env.PORT || 8080);
'''
'''--- src/App.js ---
import React, { useContext, useEffect } from 'react';
import { appStore, onAppMount } from './state/app';

import { Container } from './components/Container'
import { Receiver } from './components/Receiver'
import { Giver } from './components/Giver'
import { CircularProgress } from '@material-ui/core';

// helpers
export const btnClass = 'btn btn-sm btn-outline-primary mb-3 '
export const flexClass = 'd-flex justify-content-evenly align-items-center '
export const qs = (s) => document.querySelector(s)

const App = () => {
    const { state, dispatch, update } = useContext(appStore);

    const onMount = () => {
        dispatch(onAppMount());
    };
    useEffect(onMount, []);

    window.onerror = function (message, url, lineNo) {
        alert('Error: ' + message + 
       '\nUrl: ' + url + 
       '\nLine Number: ' + lineNo);
    return true;   
    }
    
    const {
        accountData, funding, wallet
    } = state
    
    let children = null

    if (!accountData || !wallet) {
        children = <CircularProgress />
    }

    if (accountData) {
        children = <Receiver {...{ state, dispatch }} />
    }

    if (funding) {
        children = <div class="container container-custom">
            <h2>DO NOT CLOSE OR REFRESH THIS PAGE</h2>
            <h2>Creating Persona...</h2>
        </div>
    }

    if (wallet) {
        children = <Giver {...{ state, dispatch, update }} />
    }
    
    return <Container state={state}>{ children }</Container>
}

export default App;

'''
'''--- src/components/AddPersona/addPersona.js ---
import React, { useState, useEffect } from 'react'
import { useForm } from 'react-hook-form'
import { makeStyles } from '@material-ui/core/styles'

import { nameSuffix } from '../../state/near'
import { qs } from '../../App'

// Material UI components
import Button from '@material-ui/core/Button'
import TextField from '@material-ui/core/TextField'
import Dialog from '@material-ui/core/Dialog'
import DialogActions from '@material-ui/core/DialogActions'
import DialogContent from '@material-ui/core/DialogContent'
import DialogTitle from '@material-ui/core/DialogTitle'
import LinearProgress from '@material-ui/core/LinearProgress'
import Divider from '@material-ui/core/Divider'
import InputAdornment from '@material-ui/core/InputAdornment'

const useStyles = makeStyles((theme) => ({
   
  progress: {
    width: '100%',
    '& > * + *': {
      marginTop: theme.spacing(2),
    },
  },
  }));

export default function AddPersonaForm(props) {
    const [open, setOpen] = useState(true)
    const [finished, setFinished] = useState(true)
    const [id, setId] = useState('')
    const [amount, setAmount] = useState('')
    const [clicked, setClicked] = useState(false)

    const { register, handleSubmit, watch, errors, transform } = useForm()

    const {
       state,
       handleAddPersonaClick
    } = props
    
    const classes = useStyles()

    useEffect(() => {
        
    },[])

    const handleClose = () => {
        handleAddPersonaClick(false)
        setOpen(!open)
    }
    
        return (
            <div>
            <Dialog open={open} onClose={handleClose} aria-labelledby="form-dialog-title">
              <DialogTitle id="form-dialog-title">Create Persona</DialogTitle>
              <DialogContent>
                    <div>
                        <TextField
                            id="accountName"
                            required
                            placeholder=" "
                            autoFocus
                            margin="dense"
                            variant="outlined"
                            name="id"
                            label="Account Name"
                            helperText="2-48 characters, no spaces, no symbols (except -)"
                            minLength={state.app.accountTaken ? 999999 : 2}
                            maxLength={48}
                            pattern="^(([a-z\d]+[\-_])*[a-z\d]+$"
                            value={id}
                            inputRef={register({
                                validate: {
                                notTaken: value => !state.app.accountTaken
                                }        
                            })}
                            InputProps={{
                                endAdornment: <><InputAdornment position="end">{nameSuffix}</InputAdornment></>,
                            }}
                            onChange={(e) => {
                                const v = e.target.value.toLowerCase()
                                setId(v)
                                state.wallet.isAccountTaken(v)
                            }}
                        />
                    {errors.id && <p style={{color: 'red'}}>You must provide an account name.</p>}
                    <div>
                        {state.app.accountTaken ? 'Account name is already taken' : null}
                    </div>
                  </div>
                  
                  <div class="form-floating mb-3">
                        <input type="number" class="form-control" id="fundingAmount" placeholder=" " required 
                            min={0.1} step={0.00001}  value={amount} onChange={(e) => {
                                const x = e.target.value
                                setAmount(x)
                            }}
                        />
                        <label for="fundingAmount">Initial Deposit Ⓝ</label>
                        <div class="invalid-feedback">
                            Please enter an amount of NEAR {'>='} 0.1
                        </div>
                    </div>
                   
                  <div>
                    <TextField
                        id="personaName"
                        name="personaName"
                        placeholder=" "
                        label="Persona Name"
                        inputRef={register({
                            required: true,
                            minimum: 1,
                            maximum: 64           
                        })} 
                    />
                    {errors.personaName && <p style={{color: 'red'}}>Please enter a Persona name.</p>}
                  </div>
     
                </DialogContent>
              {!finished ? <LinearProgress className={classes.progress} style={{marginBottom: '25px' }}/> : (
              <DialogActions>
              <Button
                disabled={state.app.accountTaken || clicked}
                variant="contained"
                color="primary"
                onClick={() => {state.wallet.fundAccount(amount.toString(), id, qs('#personaName').value, state.accountId); setFinished(false)}}>
                CREATE PERSONA
              </Button>
              
                <Button onClick={handleClose} color="primary">
                  Cancel
                </Button>
              </DialogActions>)}
              <Divider style={{marginBottom: 10}}/>
              
           
            </Dialog>
          </div>
        )
}
'''
'''--- src/components/Container.js ---
import React, { useState, useEffect, useContext } from 'react';
import { flexClass } from '../App'
import SignIn from '../components/SignIn/signIn'
import LogoutButton from '../components/LogoutButton/logoutButton'
import Persona from '../components/Persona/persona'
import AddPersonaForm from '../components/AddPersona/addPersona'

// Material UI
import { makeStyles } from '@material-ui/core/styles'
import Grid from '@material-ui/core/Grid'
import AppBar from '@material-ui/core/AppBar';
import Toolbar from '@material-ui/core/Toolbar';
import Typography from '@material-ui/core/Typography';
import IconButton from '@material-ui/core/IconButton';
import MenuIcon from '@material-ui/icons/Menu';
import Paper from '@material-ui/core/Paper';
import Menu from '@material-ui/core/Menu';
import MenuItem from '@material-ui/core/MenuItem';
import { CircularProgress } from '@material-ui/core';

const useStyles = makeStyles((theme) => ({
    root: {
        flexGrow: 1,
        maxWidth: 640,
        margin: 'auto',
        marginTop: 50,
        marginBottom: 50,
        minHeight: 550,
    },
    paper: {
        padding: theme.spacing(2),
        textAlign: 'center',
        color: theme.palette.text.secondary,
    },
    menuButton: {
      marginRight: theme.spacing(0),
    },
    title: {
      flexGrow: 1,
      textAlign: 'left'
    },
  }));

export const Container = ({ children, state }) => {

    const classes = useStyles();

    const [anchorEl, setAnchorEl] = useState(null);
    const [addPersonaClicked, setAddPersonaClicked] = useState(false)
   

    const {
        app, wallet, links, claimed, accountId, curInfo
    } = state

    useEffect(
        () => {        
    }, []
    )

    const handleClick = (event) => {
        setAnchorEl(event.currentTarget);
    };

    const handleClose = () => {
        setAnchorEl(null);
    };

    function handleAddPersonaClick(property){
        setAddPersonaClicked(property)
    }

    const addPersonaClick = () => {
        setAddPersonaClicked(true)
        handleClose()
    }

    return (
        <>
        <div class="background"></div>
        <div className={classes.root}>
        <Paper className={classes.paper}>
        <AppBar position="static" style={{marginBottom: '20px'}}>
        <Toolbar>
            <IconButton edge="start" className={classes.menuButton} color="inherit" aria-label="menu" onClick={handleClick}>
            <MenuIcon />
            </IconButton>
            <Menu
                id="simple-menu"
                anchorEl={anchorEl}
                keepMounted
                open={Boolean(anchorEl)}
                onClose={handleClose}
            >
                <MenuItem onClick={addPersonaClick}>Create Persona</MenuItem>
               
            </Menu>

            <Typography variant="h6" className={classes.title} >
            <a href="/" style={{color: 'white'}}>NEAR PERSONAS (TestNet)</a>
            </Typography>
            {wallet && wallet.signedIn ? <LogoutButton wallet={wallet} /> : null }
        </Toolbar>
        </AppBar>
        <Grid container spacing={1}>
            <Grid item xs={12} sm={12} md={12} lg={12} xl={12} >
               {wallet && wallet.signedIn ? <Persona state={state} accountId={wallet.getAccountId()} balance={wallet.balance} /> : null}
            </Grid>
        </Grid>

        {addPersonaClicked ? <AddPersonaForm
            state={state}
            handleAddPersonaClick={handleAddPersonaClick}
            /> : null }

        <div class={flexClass}>
            {state.finished ? (
                <div class="container container-custom">
                {wallet && wallet.signedIn ? children : <SignIn wallet={wallet}/>}
                </div>
                ) : state.accountData ? (
                <div class="container container-custom">
                {children}
                </div>
                ) : <CircularProgress/> }
                
        </div>
        </Paper>
        { state.app.alert &&
            <div class="container-alert">
                <div class={flexClass + ' mt-0'}>
                    <div class="container container-custom mt-0">
                        <div class="alert alert-primary mt-0" role="alert">
                            {state.app.alert}
                        </div>
                    </div>
                </div>
            </div>
        }
        </div>
    </>
    )
}
'''
'''--- src/components/EditPersona/editPersona.js ---
import React, { useState, useEffect } from 'react';
import { useForm, Controller } from 'react-hook-form'
import { makeStyles } from '@material-ui/core/styles'
import FileUpload from '../IPFSupload/ipfsUpload'
import { flexClass } from '../../App'

// Material UI components
import Button from '@material-ui/core/Button'
import TextField from '@material-ui/core/TextField'
import Dialog from '@material-ui/core/Dialog'
import DialogActions from '@material-ui/core/DialogActions'
import DialogContent from '@material-ui/core/DialogContent'
import DialogContentText from '@material-ui/core/DialogContentText'
import DialogTitle from '@material-ui/core/DialogTitle'
import LinearProgress from '@material-ui/core/LinearProgress'
import Avatar from '@material-ui/core/Avatar'
import Grid from '@material-ui/core/Grid'
import Typography from '@material-ui/core/Typography'
import Divider from '@material-ui/core/Divider'

// ReactQuill Component
import ReactQuill from 'react-quill';

// CSS Styles
import '../../../node_modules/react-quill/dist/quill.snow.css'
import { CircularProgress } from '@material-ui/core';

const useStyles = makeStyles((theme) => ({
    progress: {
      width: '100%',
      '& > * + *': {
        marginTop: theme.spacing(2),
      },
    },
    large: {
        width: theme.spacing(7),
        height: theme.spacing(7),
        textAlign: 'center'
    },
    waiting: {
      minWidth: '100%',
      minHeight: '100%',
      overflow: 'hidden',
      padding: '20px'
    }
    }));

const imageName = require('../../img/default-profile.png') // default no-image avatar

export default function EditPersonaForm(props) {
    const [open, setOpen] = useState(true)
    const [finished, setFinished] = useState(true)
    const [loaded, setLoaded] = useState(false)
    const [date, setDate] = useState('')
    const [name, setName] = useState('')
    const [avatar, setAvatar] = useState(imageName)
    const [shortBio, setShortBio] = useState('')

    const { register, handleSubmit, watch, errors } = useForm()

    const {
        state,
        handleUpdate,
        handleEditPersonaClickState,
        accountId,
        curPersonaIdx
    } = props
    
    const classes = useStyles()

    useEffect(() => {
        async function fetchData() {
          setLoaded(false)
           // Set Card Persona Idx       
           if(accountId){
              let result = await curPersonaIdx.get('profile', curPersonaIdx.id)

              if(result) {
                result.date ? setDate(result.date) : setDate('')
                result.avatar ? setAvatar(result.avatar) : setAvatar(imageName)
                result.shortBio ? setShortBio(result.shortBio) : setShortBio('')
                result.name ? setName(result.name) : setName('')
              }
           }
        }
       
        fetchData()
          .then((res) => {
            setLoaded(true)
          })
    },[])

    function handleFileHash(hash) {
      setAvatar(process.env.IPFS_PROVIDER + hash)
    }

    const handleClose = () => {
        handleEditPersonaClickState(false)
        setOpen(false)
    }

    const handleNameChange = (event) => {
        let value = event.target.value;
        setName(value)
    }

    function formatDate(timestamp) {
      let intDate = parseInt(timestamp)
      let options = {year: 'numeric', month: 'long', day: 'numeric'}
      return new Date(intDate).toLocaleString('en-US', options)
    }

    const handleShortBioChange = (content, delta, source, editor) => {
        
        setShortBio(content)
    }

    const onSubmit = async (values) => {
        event.preventDefault();
        setFinished(false)
        let now = new Date().getTime()
       
        let formattedDate = formatDate(now)
    
        let record = {
            date: formattedDate,
            owner: state.accountId,
            name: name,
            avatar: avatar,
            shortBio: shortBio
        }
     
        let result = await curPersonaIdx.set('profile', record)
     

      setFinished(true)
      handleUpdate(true)
      setOpen(false)
      handleClose()
    }

    const modules = {
        toolbar: [
          [{ 'header': [1, 2, 3, 4, 5, 6, false] }],
          ['bold', 'italic', 'underline','strike', 'blockquote', 'code', 'code-block'],
          [{'list': 'ordered'}, {'list': 'bullet'}, {'indent': '-1'}, {'indent': '+1'}, {'align': []}],
          ['link', 'image', 'video'],
          ['clean']
        ],
    };
    
    const formats = [
        'header',
        'bold', 'italic', 'underline', 'strike', 'blockquote', 'code', 'code-block',
        'list', 'bullet', 'indent','align',
        'link', 'image', 'video'
    ];
    
        return (
           
            <div>
       
            <Dialog open={open} onClose={handleClose} aria-labelledby="form-dialog-title">
            { loaded ? (<>
              <DialogTitle id="form-dialog-title">Profile Data</DialogTitle>
              <DialogContent>
                  <DialogContentText style={{marginBottom: 10}}>
                  Provide as much detail as you'd like.
                  </DialogContentText>
                    <div>
                      <TextField
                          autoFocus
                          margin="dense"
                          id="profile-name"
                          variant="outlined"
                          name="name"
                          label="Name"
                          placeholder="Billy Jo Someone"
                          value={name}
                          onChange={handleNameChange}
                          inputRef={register({
                              required: false                              
                          })}
                      />
                    {errors.name && <p style={{color: 'red'}}>You must provide a name.</p>}
                  </div>
                  <div>
                  <ReactQuill
                    theme="snow"
                    modules={modules}
                    formats={formats}
                    name="shortBio"
                    value={shortBio}
                    onChange={handleShortBioChange}
                    style={{height:'200px', marginBottom:'100px'}}
                    inputRef={register({
                        required: false
                    })}
                  />
                  </div>
                  
                  <Grid container spacing={1}>
                    <Grid item xs={2} sm={2} md={2} lg={2} xl={2}>
                        <Avatar src={avatar} className={classes.large} />
                    </Grid>
                    <Grid item xs={10} sm={10} md={10} lg={10} xl={10}>
                      <Typography align="center" variant="h5">Upload an Avatar</Typography>
                      <FileUpload handleFileHash={handleFileHash}/>
                    </Grid>
                  </Grid>
                 
                  <div>
               
                  </div>
                </DialogContent>
               
              {!finished ? <LinearProgress className={classes.progress} style={{marginBottom: '25px' }}/> : (
              <DialogActions>
              <Button onClick={handleSubmit(onSubmit)} color="primary" type="submit">
                  Submit Details
                </Button>
                <Button onClick={handleClose} color="primary">
                  Cancel
                </Button>
              </DialogActions>)}
              <Divider style={{marginBottom: 10}}/>
              
              </>) : <><div className={classes.waiting}><div class={flexClass}><CircularProgress/></div><Grid container spacing={1} alignItems="center" justify="center" >
              <Grid item xs={12} sm={12} md={12} lg={12} xl={12}>
                <Typography variant="h5" align="center">Loading Persona Data</Typography>
              </Grid>
              </Grid></div></> }
            </Dialog>
           
          </div>
        
        )
}
'''
'''--- src/components/Giver.js ---
import React, { useEffect, useState } from 'react';
import { MemoryRouter as Router } from 'react-router';
import PersonaCard from '../components/PersonaCard/personaCard'

const forExample = `(for example: "bestie.near" or "squad.near")`
const baseUrl = window.location.href.substr(0, window.location.href.lastIndexOf('/'))
const getLink = (accountId, key, wallet, recipientName, owner) => `?accountId=${accountId}&key=${key}&from=${wallet.getAccountId()}&recipientName=${recipientName}&owner=${owner}`

// Material UI
import { makeStyles } from '@material-ui/core/styles'
import Grid from '@material-ui/core/Grid'
import Divider from '@material-ui/core/Divider'
import Typography from '@material-ui/core/Typography';

const useStyles = makeStyles((theme) => ({
    root: {
        flexGrow: 1,
        maxWidth: 640,
        margin: 'auto',
        marginTop: 50,
        minHeight: 550,
    },
    paper: {
        padding: theme.spacing(2),
        textAlign: 'center',
        color: theme.palette.text.secondary,
    },
    menuButton: {
      marginRight: theme.spacing(0),
    },
    title: {
      flexGrow: 1,
      textAlign: 'left'
    },
  }));

export const Giver = ({ state, update, dispatch }) => {

    const classes = useStyles();

    const {
        app, wallet, links, claimed, accountId
    } = state

    const [editPersonaClicked, setEditPersonaClicked] = useState(false)
    const [countOfClaims, setCountOfClaims] = useState()
    const [countOfLinks, setCountOfLinks] = useState()

    useEffect(
        () => {
  
        async function fetchData() {
            let i = 0
            let countClaim = 0
            while (i < claimed.length ){
                if(claimed[i].owner == accountId){
                    countClaim++
                }
                i++
            }
            setCountOfClaims(countClaim)

            let j = 0
            let countLinks = 0
            while (j < links.length ){
                if(links[j].owner == accountId){
                    countLinks++
                }
                j++
            }
            setCountOfLinks(countLinks)
          
        }
        
        fetchData()
            .then((res) => {
      
            })
        
    }, [countOfClaims, countOfLinks]
    )

    function handleEditPersonaClick(property){
        setEditPersonaClicked(property)
    }

    return (
        <Router>
        <>
        <Grid container alignItems="center" justify="space-evenly" spacing={2} style={{marginBottom: '20px'}}>
            {countOfLinks > 0 ? 
                (<> <Grid item xs={12} sm={12} md={12} lg={12} xl={12} >
                        <Typography variant="h5" style={{marginBottom: '20px'}}>Reserved Personas</Typography>
                    </Grid>
                    {links.filter(person => person.owner == accountId).map(({ key, accountId, recipientName = '', owner }) =>
                        <PersonaCard
                            key={key}
                            accountId={accountId}
                            owner={owner}
                            link={getLink(accountId, key, wallet, recipientName, owner)}
                            state={state}
                            handleEditPersonaClick={handleEditPersonaClick}
                            />
                
                    )}
                </>)
                : (<>
                    <Grid item xs={12} sm={12} md={12} lg={12} xl={12} >
                        <Typography variant="overline" style={{marginBottom: '20px'}}>No Personas Waiting to Be Claimed.</Typography>
                    </Grid>
                    <Grid item xs={12} sm={12} md={12} lg={12} xl={12} >
                        <Typography variant="overline" style={{marginBottom: '20px'}}>Select Create Persona from menu to make one.</Typography>
                    </Grid>
                    </>
                    )
            }
        </Grid>
        <Divider variant="middle" style={{marginBottom: '20px'}}/>
        <Grid container alignItems="center" justify="space-evenly" spacing={2}>
            { countOfClaims > 0 ? 
                (<>
                    <Grid item xs={12} sm={12} md={12} lg={12} xl={12} >
                        <Typography variant="h5" style={{marginBottom: '20px'}}>Claimed Personas</Typography>
                    </Grid>
                {claimed.filter(person => person.owner == accountId).map(({ key, accountId, recipientName = '', owner }) =>
                    <PersonaCard
                        key={key}
                        name={recipientName}
                        accountId={accountId}
                        owner={owner}
                        link={''}
                        state={state}
                        handleEditPersonaClick={handleEditPersonaClick}
                    />              
                )}
            </>)
            : null
            } 
        </Grid>
    </>
    </Router>
    )
}
'''
'''--- src/components/IPFSupload/ipfsUpload.js ---
import React, { useState } from 'react'
const ipfsAPI = require('ipfs-http-client')
import { makeStyles } from '@material-ui/core/styles';

const useStyles = makeStyles((theme) => ({
    root: {
      
      '& > *': {
        margin: theme.spacing(1),
      },
    },
    square: {
     
    },
     logo: {
        maxWidth: '150px',
        border: '1px solid',
      width: theme.spacing(12),
    },
  }));

export default function FileUpload(props) {

    const[addedFileHash, setAddedFileHash] = useState('QmZsKcVEwj9mvGfA7w7wUS1f2fLqcfzqdCnEGtdq6MBR7P')

    const {
        handleFileHash
    } = props

    const classes = useStyles();

    const ipfsApi = ipfsAPI('https://ipfs.infura.io:5001')
  
    const captureFile = (event) => {
        event.stopPropagation()
        event.preventDefault()
        const file = event.target.files[0]
        let reader = new window.FileReader()
        reader.onloadend = () => saveToIpfs(reader)
        reader.readAsArrayBuffer(file)
    }

    const saveToIpfs = (reader) => {
        let ipfsId
        const buffer = Buffer.from(reader.result)
        ipfsApi.add(buffer)
        .then((response) => {
        ipfsId = response.path
        setAddedFileHash(ipfsId)
        handleFileHash(ipfsId)
        }).catch((err) => {
        console.error(err)
        })
    }

  const arrayBufferToString = (arrayBuffer) => {
    return String.fromCharCode.apply(null, new Uint16Array(arrayBuffer))
  }

  const handleSubmit = (event) => {
    event.preventDefault()
  }

    return (
        <div>
        <form id="captureMedia" onSubmit={handleSubmit}>
            <input type="file" onChange={captureFile} />
        </form>
      </div>
    )
  }

'''
'''--- src/components/LogoutButton/logoutButton.js ---
import React from 'react'
import { makeStyles } from '@material-ui/core/styles'
import { logout } from '../../state/near'

// Material UI components
import Button from '@material-ui/core/Button'
import LockTwoToneIcon from '@material-ui/icons/LockTwoTone'

const useStyles = makeStyles((theme) => ({
  button: {
    margin: theme.spacing(0),
    float: 'right'
  },
  accountButton: {
    margin: theme.spacing(0),
    float: 'right',
    borderTopRightRadius: 0,
    borderBottomRightRadius: 0
  },
  }));

export default function LogoutButton(props) {

    const classes = useStyles()
    const { accountId, balance, wallet } = props

    return (
        <> 
        <Button
        variant="contained"
        color="primary"
        className={classes.button}
        startIcon={<LockTwoToneIcon />}
        onClick={logout}
        >Sign Out</Button>
           
      </>
    )
}
'''
'''--- src/components/Persona/persona.js ---
import React, { useState, useEffect } from 'react'
import { get, set, del } from '../../utils/storage'
import EditPersonaForm from '../../components/EditPersona/editPersona'
import { makeStyles } from '@material-ui/core/styles'
import { ceramic } from '../../utils/ceramic'

// Material UI Components
import Avatar from '@material-ui/core/Avatar'
import Grid from '@material-ui/core/Grid'
import Typography from '@material-ui/core/Typography';
import Tooltip from '@material-ui/core/Tooltip';
import Zoom from '@material-ui/core/Zoom';
import InfoIcon from '@material-ui/icons/Info';

const useStyles = makeStyles((theme) => ({
    root: {
        flexGrow: 1,
        maxWidth: 300,
        margin: 'auto',
        marginTop: 50,
        minHeight: 550,
    },
    paper: {
        padding: theme.spacing(2),
        textAlign: 'center',
        color: theme.palette.text.secondary,
    },
    customCard: {
        maxWidth: 600,
        minWidth: 275,
        margin: 'auto',
        padding: 20
    },
    small: {
        width: theme.spacing(3),
        height: theme.spacing(3),
        float: 'right',
      },
    media: {
        height: 140,
      },
    button: {
        margin: theme.spacing(1),
      },
    }));

const imageName = require('../../img/default-profile.png') // default no-image avatar

export default function Persona(props) {
    const [profileExists, setProfileExists] = useState(false)
    const [editPersonaClicked, setEditPersonaClicked] = useState(false)
    const [anchorEl, setAnchorEl] = useState(null)
    const [isUpdated, setIsUpdated] = useState(false)
    const [finished, setFinished] = useState()
    const [avatar, setAvatar] = useState(props.avatar)

    const {
        state,
        accountId,
        balance
    } = props

    useEffect(
        () => {
  
        async function fetchData() {
            if(state) {
             
                if (state.curUserIdx){
                    let result = await state.curUserIdx.get('profile', state.curUserIdx.id)
                  
                
                    if(result){
                        result.avatar ? setAvatar(result.avatar) : setAvatar(imageName)
                    }
                }
                if((state.links && state.links.length > 0) || (state.claimed && state.claimed.length > 0)){
                        return true
                }
            }
        }

        fetchData()
            .then((res) => {
             res ? setProfileExists(true) : null
             setFinished(true)
            })
        
    }, [state.curUserIdx, state.links, state.claimed, isUpdated]
    )

const classes = useStyles()

function handleUpdate(property){
    setIsUpdated(property)
  }

const handleEditPersonaClick = () => {
    handleExpanded()
    handleEditPersonaClickState(true)
  }

  function handleEditPersonaClickState(property){
    setEditPersonaClicked(property)
  }

  function handleExpanded() {
    setAnchorEl(null)
  }

    return (
        <Grid container justify="space-between" alignItems="flex-start" spacing={1}>
            <Grid item xs={12} sm={5} md={5} lg={5} xl={5}>
                {profileExists ? (<><Typography variant="overline" display="block"><Tooltip TransitionComponent={Zoom} title="This is the total number of personas you have created across all your accounts, not just this one.">
                <InfoIcon fontSize="small" style={{marginRight:'5px', marginTop:'-3px'}} />
                </Tooltip>All Your Personas: {state.links.length + state.claimed.length}
                </Typography></>) : (<><Typography variant="overline" display="block"> <Tooltip TransitionComponent={Zoom} title="This is the total number of personas you have created across all your accounts, not just this one.">
                <InfoIcon fontSize="small" style={{marginRight:'5px', marginTop:'-3px'}} />
            </Tooltip>All Your Personas: 0</Typography></>)}
            </Grid>
            <Grid item xs={12} sm={7} md={7} lg={7} xl={7}>
            <Typography variant="overline" display="block" onClick={handleEditPersonaClick} style={{float:'right', marginLeft:'10px'}}>{accountId}: {balance} Ⓝ</Typography><Avatar src={avatar} className={classes.small} onClick={handleEditPersonaClick}/><br></br>
            </Grid>
            {editPersonaClicked ? <EditPersonaForm
                state={state}
                handleEditPersonaClickState={handleEditPersonaClickState}
                curPersonaIdx={state.curUserIdx}
                handleUpdate={handleUpdate}
                accountId={accountId}
                /> : null }
        </Grid>
    )
}
'''
'''--- src/components/PersonaCard/personaCard.js ---
import React, { useState, useEffect, useContext } from 'react'
import { appStore, onAppMount } from '../../state/app';
import { get, set, del } from '../../utils/storage'
import { ceramic } from '../../utils/ceramic'
import { IDX } from '@ceramicstudio/idx'
import EditPersonaForm from '../EditPersona/editPersona'
import * as nearAPI from 'near-api-js'

// Material UI Components
import { makeStyles } from '@material-ui/core/styles'
import Card from '@material-ui/core/Card'
import CardContent from '@material-ui/core/CardContent'
import CardActions from '@material-ui/core/CardActions'
import Avatar from '@material-ui/core/Avatar'
import Typography from '@material-ui/core/Typography'
import Link from '@material-ui/core/Link'
import { red } from '@material-ui/core/colors'
import Button from '@material-ui/core/Button'
import { CardHeader, LinearProgress } from '@material-ui/core'

import { config } from '../../state/config'

export const {
    ACCOUNT_LINKS
} = config

const useStyles = makeStyles((theme) => ({
    pos: {
        marginTop: 0,
    },
    card: {
      marginTop: '10px',
      maxWidth: '200px'
    },
    avatar: {
      backgroundColor: red[500],
    },
  }));

const imageName = require('../../img/default-profile.png') // default no-image avatar

export default function PersonaCard(props) {

  const { state, dispatch, update } = useContext(appStore);

    const [date, setDate] = useState('')
    const [name, setName] = useState('')
    const [avatar, setAvatar] = useState(imageName)
    const [shortBio, setShortBio] = useState('')
    const [editPersonaClicked, setEditPersonaClicked] = useState(false)
    const [claimed, setClaimed] = useState(false)
    const [curUserIdx, setCurUserIdx] = useState()
    const [display, setDisplay] = useState(false)
    const [isUpdated, setIsUpdated] = useState(false)
    const [anchorEl, setAnchorEl] = useState(null);
    const [did, setDid] = useState()
    const [finished, setFinished] = useState()

    const classes = useStyles();

    const { 
      owner,
      accountId,
      link
   } = props

    useEffect(
      () => {

      async function fetchData() {
              if(owner == state.accountId){
                setDisplay(true)
              }
              setFinished(false)
             
              // Set Card Persona Idx
              if(accountId){
                  let existingDid = await state.didRegistryContract.hasDID({accountId: accountId})
                
                  if(existingDid){
                      let thisDid = await state.didRegistryContract.getDID({
                          accountId: accountId
                      })
                      setDid(thisDid)
                     
                      let personaAccount = new nearAPI.Account(state.near.connection, accountId)

                      let ownerAccounts = get(ACCOUNT_LINKS, [])
                      let b = 0
                      let owner
                      while(b < ownerAccounts.length) {
                          if(ownerAccounts[b].accountId == accountId){
                          owner = ownerAccounts[b].owner
                          break
                          }
                      b++
                      }
                      const ownerAccount = new nearAPI.Account(state.near.connection, owner)
                      const ownerIdx = await ceramic.getCurrentUserIdx(ownerAccount, state.appIdx, state.didRegistryContract, owner)
                      let curPersonaIdx = await ceramic.getCurrentUserIdx(personaAccount, state.appIdx, state.didRegistryContract, owner, ownerIdx)
                      setCurUserIdx(curPersonaIdx)
                     
                      let i = 0
                      while (i < state.claimed.length) {
                        if(state.claimed[i].accountId == accountId){
                          setClaimed(true)
                          break
                        }
                        i++
                      }
                  
                      let result = await curPersonaIdx.get('profile', curPersonaIdx.id)
                      
                      if(result){
                        result.date ? setDate(result.date) : setDate('')
                        result.avatar ? setAvatar(result.avatar) : setAvatar(imageName)
                        result.shortBio ? setShortBio(result.shortBio) : setShortBio('')
                        result.name ? setName(result.name) : setName('')
                        return true
                      }
                      return true
                  }
              }
            }

      fetchData()
          .then((res) => {
            setFinished(true)
          })
      
  }, [isUpdated]
  )

  function handleUpdate(property){
    setIsUpdated(property)
  }

  const handleEditPersonaClick = () => {
    handleExpanded()
    handleEditPersonaClickState(true)
  }

  function handleEditPersonaClickState(property){
    setEditPersonaClicked(property)
  }

  function handleExpanded() {
    setAnchorEl(null)
  }
    

    return(
        <>
        {display ? (
          <Card className={classes.card}>
            <CardHeader
              title={name}
              subheader={date}
              avatar = {<Avatar variant="square" src={avatar} className={classes.square} />}
           />
              <CardContent>
                <Typography gutterBottom variant="h6" noWrap={true}>
                  {accountId}
                </Typography>
              </CardContent>
      
            { finished ? ( <CardActions>
          
              {!claimed ? (
                  <Link color="primary" href={link}>
                    Claim
                  </Link>
              ) : null }

              {claimed ? (
                <Button onClick={handleEditPersonaClick} >
                    Edit Persona
                </Button>
              ) : null }
           

              {editPersonaClicked ? <EditPersonaForm
                state={state}
                handleEditPersonaClickState={handleEditPersonaClickState}
                curPersonaIdx={curUserIdx}
                handleUpdate={handleUpdate}
                did={did}
                accountId={accountId}
                /> : null }

            </CardActions> ) : <LinearProgress /> }
          </Card>) : null  }
         
        </>
       
    )
}
'''
'''--- src/components/Receiver.js ---
import React, { useEffect, useState, useContext } from 'react';
import { keyRotation, walletUrl, SEED_PHRASE_LOCAL_COPY } from '../state/near';
import { appStore, onAppMount } from '../state/app';

import { makeStyles } from '@material-ui/core/styles';

// Material UI Components
import Button from '@material-ui/core/Button'
import Card from '@material-ui/core/Card';
import CardContent from '@material-ui/core/CardContent';
import CardHeader from '@material-ui/core/CardHeader'
import Grid from '@material-ui/core/Grid'
import Typography from '@material-ui/core/Typography';
import { red } from '@material-ui/core/colors';
import Divider from '@material-ui/core/Divider'

const useStyles = makeStyles((theme) => ({
    root: {
      maxWidth: '95%',
      margin: 'auto'
    },
    media: {
      height: 0,
      paddingTop: '56.25%', // 16:9
    },
    expand: {
      transform: 'rotate(0deg)',
      marginLeft: 'auto',
      transition: theme.transitions.create('transform', {
        duration: theme.transitions.duration.shortest,
      }),
    },
    expandOpen: {
      transform: 'rotate(180deg)',
    },
    avatar: {
      backgroundColor: red[500],
    },
  }));

export const Receiver = ({ dispatch }) => {
    const { state, update } = useContext(appStore);
    const { accountId, from, seedPhrase, message, link, keyExists } = state.accountData

    const classes = useStyles();

    const [claiming, setClaiming] = useState(false)
    const [success, setSuccess] = useState(0)
    const [seedHidden, setSeedHidden] = useState(true)

    useEffect(() => {
       
    }, [])

    if (claiming) {
        return (
            <Card className={classes.root}>
                <CardHeader
                    title="DO NOT CLOSE OR REFRESH THIS PAGE"
                    subheader="Claiming your persona..."
                />
                <CardContent>
                    
                </CardContent>
            </Card> 
        )
    }

    if (!keyExists || success === 1) {
        return (<>
            <Grid container spacing={1}>
                <Grid item xs={12} sm={12} md={12} lg={12} xl={12} >
                    <Card className={classes.root}>
                    <CardHeader
                        title="Congratulations!"
                    />
                    <CardContent>
                        <Typography variant="h5" gutterBottom style={{marginBottom:'20px'}}>{accountId} is ready to go.</Typography>
                        <Divider variant="middle" />
                        <a href={'/'}><Button>Go To Personas</Button></a>
                    </CardContent>
                    </Card> 
                </Grid>
            </Grid>
        </>
        )
    }

    return (<>
        <Grid container spacing={1}>
            <Grid item xs={12} sm={12} md={12} lg={12} xl={12} >
            <Card className={classes.root}>
            <CardHeader
                title="Your new NEAR Persona is almost ready!"
                subheader={`${from} created this persona with the account name:`}
            />
            <CardContent>
                <Typography variant="h5" gutterBottom style={{marginBottom:'20px'}}>{accountId}</Typography>
                <Divider variant="middle" />
                <Typography variant="h5" gutterBottom >IMPORTANT!</Typography>
                <Typography variant="body1" gutterBottom>Your seed phrase is like an account password. 
                We <b>do not store it for you and can't recover it</b>.  If you lose it, 
                you can not access the account.</Typography>
                <Typography variant="body1">It's a good idea to write it down and store it somewhere safe (offline) and <b>do not share it with anyone.</b></Typography>
            </CardContent>
            </Card> 
            </Grid>
           
            <Grid item xs={12} sm={12} md={12} lg={12} xl={12} >
                {seedHidden && <Button color="primary" style={{marginBottom: '10px'}} onClick={() => {
                    setSeedHidden(!seedHidden)
                }}>
                    REVEAL MY SECRET SEED PHRASE
                </Button>}
                <div class="form-floating mb-3" align="center">
                    <textarea readonly class="form-control" id="seedPhrase" value={seedHidden ? `************` : seedPhrase} />
                </div>
                {!seedHidden && <>
                    <Button color="primary" onClick={async () => {
                        setClaiming(true)
                        try {
                            await dispatch(keyRotation())
                            setSuccess(1)
                        } catch (e) {
                            if (e.message.indexOf('Can not sign transactions') > -1) {
                                alert('It looks like the account has already been claimed!')
                                setSuccess(1)
                            } else {
                                alert('There was an error claiming your account. Please try again.')
                                console.error(e)
                            }
                        }
                        setClaiming(false)
                    }}>
                        I Wrote It Down! CLAIM MY ACCOUNT NOW!
                </Button>
                </>}
            </Grid>
        </Grid>
    </>
    )
}
'''
'''--- src/components/SignIn/signIn.js ---
import React from 'react'
import { makeStyles } from '@material-ui/core/styles'
import { login } from '../../state/near'

// Material UI Components
import Button from '@material-ui/core/Button'
import Card from '@material-ui/core/Card'
import CardMedia from '@material-ui/core/CardMedia'
import CardHeader from '@material-ui/core/CardHeader'
import CardContent from '@material-ui/core/CardContent'
import Grid from '@material-ui/core/Grid'
import Typography from '@material-ui/core/Typography';
import LockOpenTwoToneIcon from '@material-ui/icons/LockOpenTwoTone';

const useStyles = makeStyles((theme) => ({
    root: {
        flexGrow: 1,
        maxWidth: '95%',
        margin: 'auto',
        marginTop: 50,
        minHeight: 550,
    },
    customCard: {
        maxWidth: '95%',
        minWidth: 275,
        margin: 'auto',
        padding: 20
    },
    button: {
        margin: theme.spacing(1),
      },
    }));

export default function SignIn(props) {

  const {
    wallet
  } = props

const classes = useStyles()

    return (
        <Grid container spacing={3}>
          <Grid item xs={12}>
          
                <div className={classes.root}>
                  <Card className={classes.customCard}>
                    <CardMedia
                        component="img"
                        image={require("../../img/near_logo.png")}
                        title="Near Logo"
                    />
                    <CardHeader title="Ready To Create a NEAR Persona?"></CardHeader>
                    <CardContent>
                    <Typography variant="body2" color="textPrimary" component="p" style={{marginBottom: 20}}>
                    To do so, you need to sign in with an existing NEAR account. The button below will sign you in using NEAR Wallet.</Typography>
                    <Typography variant="body2" color="textSecondary" component="p" style={{marginBottom: 20}}>
                    Go ahead and click the button below to get started:</Typography>
                    <Button
                      variant="contained"
                      color="primary"
                      className={classes.button}
                      startIcon={<LockOpenTwoToneIcon />}
                      onClick={login}
                    >Sign In</Button>
                    </CardContent>
                  </Card>
                </div>
         
          </Grid>
        </Grid>
    )
}
'''
'''--- src/index.html ---
<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta property="og:title" content="NEAR Personas" />
    <meta property="og:image" content="./img/persona-preview.png" />
    <meta property="og:image:width" content="1200"/>
    <meta property="og:image:height" content="628"/>
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://near-examples.github.io/account-gifter/" />
    <meta property="og:description" content="Build Digital Identities on the NEAR blockchain!" />
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@Aaron_Luhning">
    <meta name="twitter:creator" content="@Aaron_Luhning">
    <meta property="twitter:image:alt" content="vitalpointai.near">

    <title>NEAR Personas</title>

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta1/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-giJF6kkoqNQ00vy+HMDP7azOuL0xtbfIcaT9wjKHr8RbDVddVHyTfAAsrekwKmP1" crossorigin="anonymous">

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap" />

    <link rel="stylesheet" type="text/css" href="./App.css">

</head>

<body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <script src="./index.js"></script>
</body>

</html>

'''
'''--- src/index.js ---
import React from 'react';
import ReactDOM from 'react-dom';
import App from './App';
import { AppProvider } from './state/app.js'

ReactDOM.render(
	<AppProvider>
		<App />
	</AppProvider>,
	document.getElementById('root')
);

'''
'''--- src/schemas/accountKeys.js ---
export const accountKeysSchema = {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "type": "object",
    "title": "AccountKeys",
    "properties": {
      "seeds": {
        "type": "array",
        "items": { "$ref": "#/definitions/AccountKeys" }
      }
    },
    "additionalProperties": false,
    "required": [ "seeds" ],
    "definitions": {
      "AccountKeys": {
        "type": "object",
        "properties": {
          "protected": { "type": "string" },
          "iv": { "type": "string" },
          "ciphertext": { "type": "string" },
          "tag": { "type": "string" },
          "aad": { "type": "string" },
          "recipients": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "header": { "type": "object" },
                "encrypted_key": { "type": "string" }
              },
              "required": [ "header", "encrypted_key" ]
            }
          }
        },
        "required": [ "protected", "iv", "ciphertext", "tag" ]
      }
    }
  }
'''
'''--- src/schemas/definitions.js ---
export const definitionsSchema = {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "type": "object",
    "title": "Definitions",
    "properties": {
      "defs": {
        "type": "array",
        "items": { "$ref": "#/definitions/Definitions" }
      }
    },
    "additionalProperties": false,
    "required": [ "defs" ],
    "definitions": {
      "Definitions": {
        "type": "object",
        "properties": {
          "accountId": { "type": "string" },
          "alias": { "type": "string" },
          "def": { "type": "string" },
        },
        "required": [ "accountId", "alias", "def" ]
      }
    }
}
'''
'''--- src/schemas/personaSeeds.js ---
export const personaSeedsSchema = {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "type": "object",
    "title": "SecretSeeds",
    "properties": {
      "seeds": {
        "type": "array",
        "items": { "$ref": "#/definitions/SeedsJWE" }
      }
    },
    "additionalProperties": false,
    "required": [ "seeds" ],
    "definitions": {
      "SeedsJWE": {
        "type": "object",
        "properties": {
          "protected": { "type": "string" },
          "iv": { "type": "string" },
          "ciphertext": { "type": "string" },
          "tag": { "type": "string" },
          "aad": { "type": "string" },
          "recipients": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "header": { "type": "object" },
                "encrypted_key": { "type": "string" }
              },
              "required": [ "header", "encrypted_key" ]
            }
          }
        },
        "required": [ "protected", "iv", "ciphertext", "tag" ]
      }
    }
  }
'''
'''--- src/schemas/profile.js ---
export const profileSchema = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    title: 'Profile',
    type: 'object',
    properties: {
      date: {
        type: 'string',
      },
      owner: {
        type: 'string',
      },
      name: {
          type: 'string',
      },
      avatar: {
        type: 'string',
      },
      shortBio: {
        type: 'string',
        title: 'text',
        maxLength: 4000,
      },
    },
  }
'''
'''--- src/schemas/schemas.js ---
export const schemaSchema = {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "type": "object",
    "title": "Schemas",
    "properties": {
      "schemas": {
        "type": "array",
        "items": { "$ref": "#/definitions/Schemas" }
      }
    },
    "additionalProperties": false,
    "required": [ "schemas" ],
    "definitions": {
      "Schemas": {
        "type": "object",
        "properties": {
          "accountId": { "type": "string" },
          "name": { "type": "string" },
          "url": { "type": "string" },
        },
        "required": [ "accountId", "name", "url" ]
      },
    }
}
'''
'''--- src/state/app.js ---
import anime from 'animejs/lib/anime.es.js';
import { generateSeedPhrase } from 'near-seed-phrase'
import { State } from '../utils/state';
import { initNear, hasKey } from './near';

const initialState = {
	app: {
        mounted: false,
        wasValidated: false,
        accountTaken: false,
        alert: null,
    },
    links: []
};

export const { appStore, AppProvider } = State(initialState, 'app');

let alertAnimation
export const onAlert = (message) => async ({update}) => {
    await update('app.alert', message)
    if (alertAnimation) {
        alertAnimation.pause()
    }
    alertAnimation = anime({
        targets: '.alert',
        easing: 'easeOutElastic',
        keyframes: [
            {scaleX: 0, scaleY: 0, duration: 0},
            {scaleX: 1, scaleY: 1, duration: 500},
            {duration: 2000},
            {scaleX: 0, scaleY: 0, duration: 500, easing: 'easeInCubic'},
        ],
        complete: function () {
            update('app.alert', null)
        }
    });
}

export const onAppMount = () => async ({ update, getState, dispatch }) => {
    update('app', { mounted: true });

    const url = new URL(window.location.href)
    const key = url.searchParams.get('key')
    const from = url.searchParams.get('from')
    const message = decodeURIComponent(url.searchParams.get('message') || '')
    const link = url.searchParams.get('link') || ''
    const accountId = url.searchParams.get('accountId')
    const recipientName = url.searchParams.get('recipientName')
    const owner = url.searchParams.get('owner')

    if (key && accountId) {
        const { seedPhrase, publicKey } = generateSeedPhrase()
        const keyExists = await hasKey(key, accountId)
        update('accountData', { key, from, message, link, accountId, seedPhrase, publicKey, keyExists, recipientName, owner })
    } else {
        dispatch(initNear());
    }
};

'''
'''--- src/state/config.js ---
import { BN } from 'bn.js'

// testnet / default
let config = {
    SEED_PHRASE_LOCAL_COPY: '__SEED_PHRASE_LOCAL_COPY',
    FUNDING_DATA: '__FUNDING_DATA',
    ACCOUNT_LINKS: '__ACCOUNT_LINKS',
    GAS: '200000000000000',
    networkId: 'default',
    nodeUrl: 'https://rpc.testnet.near.org',
    walletUrl: 'https://wallet.testnet.near.org',
    nameSuffix: '.testnet',
    contractName: 'testnet',
    didRegistryContractName: 'dids.vitalpointai.testnet',
}

if (process.env.REACT_APP_ENV === 'prod') {
    config = {
        ...config,
        networkId: 'mainnet',
        nodeUrl: 'https://rpc.mainnet.near.org',
        walletUrl: 'https://wallet.near.org',
        nameSuffix: '.near',
        contractName: 'near',
        didRegistryContractName: 'did.near',
    }
}

export { config }

'''
'''--- src/state/near.js ---
import * as nearAPI from 'near-api-js'
import { get, set, del } from '../utils/storage'
import { ceramic } from '../utils/ceramic'

import { config } from './config'

export const {
    FUNDING_DATA, FUNDING_DATA_BACKUP, ACCOUNT_LINKS, GAS, SEED_PHRASE_LOCAL_COPY,
    networkId, nodeUrl, walletUrl, nameSuffix,
    contractName, didRegistryContractName
} = config

const {
    KeyPair,
    InMemorySigner,
    transactions: {
        addKey, deleteKey, fullAccessKey
    },
    utils: {
        PublicKey,
        format: {
            parseNearAmount, formatNearAmount
        }
    }
} = nearAPI

export const initNear = () => async ({ update, getState, dispatch }) => {

    let finished = false

    const near = await nearAPI.connect({
        networkId, nodeUrl, walletUrl, deps: { keyStore: new nearAPI.keyStores.BrowserLocalStorageKeyStore() },
    });

    const isAccountTaken = async (accountId) => {
        const account = new nearAPI.Account(near.connection, accountId);
        try {
            await account.state()
        } catch(e) {
            console.warn(e)
            if (/does not exist while viewing/.test(e.toString())) {
                return false
            }
        }
        return true
    }

    // resume wallet / contract flow
    const wallet = new nearAPI.WalletAccount(near);

    wallet.signIn = () => {
        wallet.requestSignIn(contractName, 'Blah Blah')
    }

    wallet.signedIn = wallet.isSignedIn()
    if (wallet.signedIn) {
        wallet.balance = formatNearAmount((await wallet.account().getAccountBalance()).available, 2)
    }

    const contract = new nearAPI.Contract(wallet.account(), contractName, {
        changeMethods: ['send', 'create_account', 'create_account_and_claim'],
    })

    wallet.isAccountTaken = async (accountId) => {
        const accountTaken = await isAccountTaken(accountId + nameSuffix)
        update('app', { accountTaken, wasValidated: true })
    }

    wallet.fundAccount = async (amount, accountId, recipientName, owner) => {
        
        if (accountId.indexOf(nameSuffix) > -1 || accountId.indexOf('.') > -1) {
            alert(nameSuffix + ' is added automatically and no "." is allowed. Please remove and try again.')
            return update('app.wasValidated', true)
        }
        accountId = accountId + nameSuffix
        if (parseFloat(amount, 10) < 0.1 || accountId.length < 2 || accountId.length > 48) {
            return update('app.wasValidated', true)
        }
        const keyPair = KeyPair.fromRandom('ed25519')

        let state = getState()

        const links = get(ACCOUNT_LINKS, [])
        let c = 0
        let accountExists
        while(c < links.length) {
            if(links[c].accountId == accountId){
                accountExists = true
                alert('This account already exists in local storage, it will be updated.')
                links[c] = { key: keyPair.secretKey, accountId: accountId, recipientName: recipientName, owner: owner, keyStored: Date.now() }
                break
            } else {
                accountExists = false
            }
        c++
        }
        if(!accountExists){
            links.push({ key: keyPair.secretKey, accountId, recipientName, owner, keyStored: Date.now() })
            await ceramic.storeKeysSecret(state.curUserIdx, links, 'accountsKeys')
            set(ACCOUNT_LINKS, links)
        
            await contract.create_account({ new_account_id: accountId, new_public_key: keyPair.publicKey.toString() }, GAS, parseNearAmount(amount))
        }
    }

    if(wallet.signedIn){

    // ********* Initiate Dids Registry Contract ************

    const account = wallet.account()
    const accountId = account.accountId
    const didRegistryContract = await ceramic.initiateDidRegistryContract(account)

    // ******** IDX Initialization *********

    //Initiate App Ceramic Components
    
    const appIdx = await ceramic.getAppIdx(didRegistryContract)

    // Set Current User Ceramic Client

    let curUserIdx
    let did
   
    let existingDid = await didRegistryContract.hasDID({accountId: accountId})
   
    if(existingDid){
        did = await didRegistryContract.getDID({
            accountId: accountId
        })
        let ownerAccounts = get(ACCOUNT_LINKS, [])
       
        let b = 0
        let owner
        while(b < ownerAccounts.length) {
            if(ownerAccounts[b].accountId == accountId){
                owner = ownerAccounts[b].owner
                break
            }
        b++
        }
       
        if(owner != undefined){
            const ownerAccount = new nearAPI.Account(near.connection, owner)
            const ownerIdx = await ceramic.getCurrentUserIdx(ownerAccount, appIdx, didRegistryContract, owner)
            curUserIdx = await ceramic.getCurrentUserIdx(account, appIdx, didRegistryContract, owner, ownerIdx)
        } else {
            curUserIdx = await ceramic.getCurrentUserIdx(account, appIdx, didRegistryContract)
        }
        
    }
    if(!existingDid){
        curUserIdx = await ceramic.getCurrentUserIdxNoDid(appIdx, didRegistryContract, account)
    }
    
    // Set Current User's Info
    const curInfo = await curUserIdx.get('profile')

    //synch local links with what's stored for the account in ceramic
    let allAccounts = await ceramic.downloadKeysSecret(curUserIdx, 'accountsKeys')
    
    const storageLinks = get(ACCOUNT_LINKS, [])
    
    if(allAccounts.length != storageLinks.length){
        if(allAccounts.length < storageLinks.length){
            await ceramic.storeKeysSecret(curUserIdx, storageLinks, 'accountsKeys')
        }
        if(allAccounts.length > storageLinks.length){
            set(ACCOUNT_LINKS, allAccounts)
        }
    }
    
    update('', { didRegistryContract, appIdx, accountId, curUserIdx, wallet, curInfo })
    }
    // check localLinks, see if they're still valid

    const localLinks = get(ACCOUNT_LINKS, []).sort((a) => a.claimed ? 1 : -1)
    for (let i = 0; i < localLinks.length; i++) {
        const { key, accountId, keyStored = 0, claimed } = localLinks[i]
        const exists = await isAccountTaken(accountId)
        if (!exists) {
            localLinks.splice(i, 1)
            continue
        }
        if (!!claimed || Date.now() - keyStored < 5000) {
            continue
        }
        const keyExists = await hasKey(key, accountId, near)
        if (!keyExists) {
            localLinks[i].claimed = true
        }
    }
    set(ACCOUNT_LINKS, localLinks)

    const claimed = localLinks.filter(({claimed}) => !!claimed)
    const links = localLinks.filter(({claimed}) => !claimed)
  
    finished = true

    update('', { near, wallet, links, claimed, finished })
}

export async function login() {
    const near = await nearAPI.connect({
        networkId, nodeUrl, walletUrl, deps: { keyStore: new nearAPI.keyStores.BrowserLocalStorageKeyStore() },
    });
    const connection = new nearAPI.WalletConnection(near)
    connection.requestSignIn(contractName, 'Near Personas')
}

export async function logout() {
    const near = await nearAPI.connect({
        networkId, nodeUrl, walletUrl, deps: { keyStore: new nearAPI.keyStores.BrowserLocalStorageKeyStore() },
    });
    const connection = new nearAPI.WalletConnection(near)
    connection.signOut()
    window.location.replace(window.location.origin)
}

export const unclaimLink = (keyToFind) => async ({ update }) => {
    let links = get(ACCOUNT_LINKS, [])
    const link = links.find(({ key }) => key === keyToFind)
    if (!link) {
        alert('cannot find link')
        return
    }
    link.claimed = false
    set(ACCOUNT_LINKS, links)

    const claimed = links.filter(({claimed}) => claimed === true)
    links = links.filter(({claimed}) => !claimed)
    
    update('', { links, claimed })
}

export const keyRotation = () => async ({ update, getState, dispatch }) => {
    const state = getState()
   
    const { key, accountId, publicKey, seedPhrase, recipientName, owner } = state.accountData

    const keyPair = KeyPair.fromString(key)
    const signer = await InMemorySigner.fromKeyPair(networkId, accountId, keyPair)
    const near = await nearAPI.connect({
        networkId, nodeUrl, walletUrl, deps: { keyStore: signer.keyStore },
    });
    const account = new nearAPI.Account(near.connection, accountId);
    const accessKeys = await account.getAccessKeys()

    const didContract = await ceramic.initiateDidRegistryContract(account)

    const appIdx = await ceramic.getAppIdx(didContract)

    const ownerAccount = new nearAPI.Account(near.connection, owner);

    let ownerAccounts = get(ACCOUNT_LINKS, [])
  
    let b = 0
    let ownersowner
    while(b < ownerAccounts.length) {
        if(ownerAccounts[b].accountId == owner){
            ownersowner = ownerAccounts[b].owner
            break
        }
    b++
    }
    
    const ownerIdx = await ceramic.getCurrentUserIdx(ownerAccount, appIdx, ownersowner)
   
    await ceramic.getCurrentUserIdxNoDid(appIdx, didContract, account, keyPair, recipientName, owner, ownerIdx)                 
    
    const actions = [
        deleteKey(PublicKey.from(accessKeys[0].public_key)),
        addKey(PublicKey.from(publicKey), fullAccessKey())
    ]

    set(SEED_PHRASE_LOCAL_COPY, seedPhrase)

    const result = await account.signAndSendTransaction(accountId, actions)

    fetch('https://hooks.zapier.com/hooks/catch/6370559/ocibjmr/', {
        method: 'POST',
        body: JSON.stringify({
            account_id: accountId,
            time_claimed: Date.now()
        })
    })
    
    return result
}

export const hasKey = async (key, accountId, near) => {
    const keyPair = KeyPair.fromString(key)
    const pubKeyStr = keyPair.publicKey.toString()

    if (!near) {
        const signer = await InMemorySigner.fromKeyPair(networkId, accountId, keyPair)
        near = await nearAPI.connect({
            networkId, nodeUrl, walletUrl, deps: { keyStore: signer.keyStore },
        });
    }
    const account = new nearAPI.Account(near.connection, accountId);
    try {
        const accessKeys = await account.getAccessKeys()
        if (accessKeys.length > 0 && accessKeys.find(({ public_key }) => public_key === pubKeyStr)) {
            return true
        }
    } catch (e) {
        console.warn(e)
    }
    return false
}
'''
'''--- src/utils/ceramic.js ---
import CeramicClient from '@ceramicnetwork/http-client'
import * as nearApiJs from 'near-api-js'
import { get, set, del } from './storage'
import { IDX } from '@ceramicstudio/idx'
import { createDefinition, publishSchema } from '@ceramicstudio/idx-tools'
import { Ed25519Provider } from 'key-did-provider-ed25519'

// schemas
import { profileSchema } from '../schemas/profile'
import { accountKeysSchema } from '../schemas/accountKeys'
import { definitionsSchema } from '../schemas/definitions'
import { schemaSchema } from '../schemas/schemas'

import { config } from '../state/config'
const axios = require('axios').default;

export const {
    FUNDING_DATA, FUNDING_DATA_BACKUP, ACCOUNT_LINKS, GAS, SEED_PHRASE_LOCAL_COPY,
    networkId, nodeUrl, walletUrl, nameSuffix,
    contractName, didRegistryContractName
} = config

const {
  KeyPair,
  InMemorySigner,
  transactions: {
      addKey
  },
  utils: {
      PublicKey,
      format: {
          parseNearAmount, formatNearAmount
      }
  }
} = nearApiJs

class Ceramic {

  async storeSeedSecret(idx, payload, key, did) {
    let record = await idx.get(key, idx._ceramic.did.id)
    if(!record){
      record = { seeds: [] }
    }
   
    const secretData = { did, payload }
   
    let access = [idx._ceramic.did.id]
    if(did) access.push(did)
    const jwe = await idx._ceramic.did.createDagJWE(secretData, access)
  
    record.seeds.push(jwe)
  
    await idx.set(key, record)
  }

  async storeKeysSecret(idx, payload, key, did) {

    let record = await idx.get(key)
    
    if(!record){
      record = { seeds: [] }
    }
   
    let access = [idx._ceramic.did.id]
    if(did) access.push(did)
    const jwe = await idx._ceramic.did.createDagJWE(payload, access)
  
    record = { seeds: [jwe] }
  
    await idx.set(key, record)
  }
  
  async downloadSecret(idx, key, did) {
  
    let records = await idx.get(key)
   
    if(records){
      let i = 0
  
      while(i < records.seeds.length) {
        let record = await idx._ceramic.did.decryptDagJWE(records.seeds[i])
        if (record.did == did) {
          return record.payload
        }
        i++
      }
    }
    return false
  }

  async downloadKeysSecret(idx, key) {
    let records = await idx.get(key)
    if(records){
      return await idx._ceramic.did.decryptDagJWE(records.seeds[0])
    }
    return []
  }

  async getSeed(account) {
    const secretKey = localStorage.getItem('nearprofile:seed:'+account.accountId)
    if(secretKey != undefined){
      let seed = Buffer.from(secretKey.slice(0, 32))
      return seed
    }
    return false
  }

  async getLocalAccountSeed(accountId){
    let accounts = get(ACCOUNT_LINKS, [])
    let i = 0
    while (i < accounts.length){
      if(accounts[i].accountId == accountId){
        let seed = Buffer.from((accounts[i].key).slice(0,32))
        return seed
      }
      i++
    }
    return false
  }

async makeSeed(account){
    let keyPair = KeyPair.fromRandom('ed25519')
    let recipientName = ''
    let owner = ''
    const links = get(ACCOUNT_LINKS, [])
    let c = 0
    let accountExists
    while(c < links.length) {
        if(links[c].accountId == account.accountId){
            accountExists = true
            links[c] = { key: keyPair.secretKey, accountId: account.accountId, recipientName: recipientName, owner: owner, keyStored: Date.now() }
            set(ACCOUNT_LINKS, links)
            break
        } else {
            accountExists = false
        }
    c++
    }
    if(!accountExists){
      links.push({ key: keyPair.secretKey, accountId: account.accountId, recipientName: recipientName, owner: owner, keyStored: Date.now() })
      set(ACCOUNT_LINKS, links)
    }
}

  async getCeramic(account, seed) {
  
    if(seed == false || seed == undefined) {
      seed = await this.getSeed(account)
      if (seed == undefined || seed == false){
        await this.makeSeed(account)
        seed = await this.getLocalAccountSeed(account.accountId)
      }
    }
    const API_URL = 'https://ceramic-clay.3boxlabs.com'
    const ceramic = new CeramicClient(API_URL, {cacheDocCommits: true, docSyncEnabled: false, docSynchInterval: 30000})
    const provider = new Ed25519Provider(seed)
    await ceramic.setDIDProvider(provider)
    return ceramic
  }

  async getAppCeramic() {
    let retrieveSeed = await axios.get('https://vpbackend.azurewebsites.net/appseed')
    const seed = Buffer.from((retrieveSeed.data).slice(0, 32))
    const API_URL = 'https://ceramic-clay.3boxlabs.com'
    const ceramic = new CeramicClient(API_URL, {docSyncEnabled: false, docSynchInterval: 30000})
    const provider = new Ed25519Provider(seed)
    await ceramic.setDIDProvider(provider)
    return ceramic
  }

  async associateDID(accountId, contract, ceramic) {

    // ensure it's registered in the contract, if not, put it back there
    let exists = await contract.hasDID({accountId: accountId})

    if(exists) return ceramic.did.id
    
    if(!exists){
      try {
        let didContract = await this.useDidContractFullAccessKey()
          await didContract.putDID({
            accountId: accountId,
            did: ceramic.did.id
          }, process.env.DEFAULT_GAS_VALUE)
          // cache the new DID in localstorage
          localStorage.setItem('nearprofile:' + accountId + ':', ceramic.did.id)
          return ceramic.did.id
      } catch (err) {
        console.log(err)
      }
    }
  }

  async associateAppDID(accountId, contract, ceramic) {
  
    /** Try and retrieve did from  contract if it exists */
      let did
        let didPresent = await contract.hasDID({accountId: accountId})
          if(didPresent) {   
          try {
              did = await contract.getDID({accountId: accountId});
              if(did) {
                return did
              }           
          } catch (err) {
              console.log('no DID retrievable', err)
          }
        }

        /** No DID, so create a new one and store it in the contract */
        if (ceramic.did.id) {
          try{
            let didContract = await this.useDidContractFullAccessKey()
            did = await didContract.putDID({
              accountId: accountId,
              did: ceramic.did.id
            }, process.env.DEFAULT_GAS_VALUE)
          } catch (err) {
            console.log('problem storing DID', err)
          }
        }
      return did
  }

  async initiateDidRegistryContract(account) {    
   
    // initiate the contract so its associated with this current account and exposing all the methods
    let didRegistryContract = new nearApiJs.Contract(account, didRegistryContractName, {
      viewMethods: [
          'getDID',
          'getSchemas',
          'findSchema',
          'getDefinitions',
          'findDefinition',
          'findAlias',
          'getAliases',
          'hasDID',
          'retrieveAlias',
          'hasAlias'
      ],
      // Change methods can modify the state. But you don't receive the returned value when called.
      changeMethods: [
          'putDID',
          'initialize',
          'addSchema',
          'addDefinition',
          'addAlias',
          'storeAlias'
      ],
  })
    return didRegistryContract
  }

  async useDidContractFullAccessKey() {    

    // Step 1:  get the keypair from the contract's full access private key
    let retrieveKey = await axios.get('https://vpbackend.azurewebsites.net/didkey')
    let keyPair = KeyPair.fromString(retrieveKey.data)

    // Step 2:  load up an inMemorySigner using the keyPair for the account
    let signer = await InMemorySigner.fromKeyPair(networkId, didRegistryContractName, keyPair)

    // Step 3:  create a connection to the network using the signer's keystore and default config for testnet
    const near = await nearApiJs.connect({
      networkId, nodeUrl, walletUrl, deps: { keyStore: signer.keyStore },
    })

    // Step 4:  get the account object of the currentAccount.  At this point, we should have full control over the account.
    let account = new nearApiJs.Account(near.connection, didRegistryContractName)

    // initiate the contract so its associated with this current account and exposing all the methods
    let didRegistryContract = new nearApiJs.Contract(account, didRegistryContractName, {
      viewMethods: [
          'getDID',
          'getSchemas',
          'findSchema',
          'getDefinitions',
          'findDefinition',
          'findAlias',
          'getAliases',
          'hasDID',
          'retrieveAlias',
          'hasAlias'
      ],
      // Change methods can modify the state. But you don't receive the returned value when called.
      changeMethods: [
          'putDID',
          'initialize',
          'addSchema',
          'addDefinition',
          'addAlias',
          'storeAlias'
      ],
  })
    return didRegistryContract
  }

  async getAlias(accountId, aliasName, client, schema, description, contract) {
    try {
      let aliasExists = await contract.hasAlias({alias: accountId+':'+aliasName})
      if(aliasExists){
        let alias = await contract.retrieveAlias({alias: accountId+':'+aliasName})
        return alias
      }
      if(!aliasExists){
        let schemaURL = await publishSchema(client, {content: schema})
        let definition = await createDefinition(client, {
          name: aliasName,
          description: description,
          schema: schemaURL.commitId.toUrl()
        })
        let didContract = await this.useDidContractFullAccessKey()
        await didContract.storeAlias({alias: accountId+':'+aliasName, definition: definition.id.toString()})
        return definition.id.toString()
      }
    } catch (err) {
      console.log('problem retrieving alias', err)
      return false
    }
  }

  async aliasSetup(idx, accountId, aliasName, defDesc, schemaFormat, ceramicClient) {
    const currentDefinitions = await idx.get('definitions', idx.id)

    let defExists
    if(currentDefinitions != null){
      let m = 0
        while (m < currentDefinitions.defs.length) {
            if (currentDefinitions.defs[m].accountId == accountId && currentDefinitions.defs[m].alias == aliasName){
              defExists = true
              return true
            }
        m++
      }
    } else {
      defExists = false
    }
    
    if(!defExists) {

      const currentSchemas = await idx.get('schemas', idx.id)

      // check for existing schema for this account from it's owner's account idx
      let schemaExists
      if(currentSchemas != null ){
        let k = 0
        while (k < currentSchemas.schemas.length) {
            if (currentSchemas.schemas[k].accountId == accountId && currentSchemas.schemas[k].name == aliasName){
            schemaExists = true
            break
            }
            k++
        }
      } else {
        schemaExists = false
      }

      let schemaURL
      if(!schemaExists){
          // create a new Schema
          
          let schemaURL = await publishSchema(ceramicClient, {content: schemaFormat})

          let schemaRecords = await idx.get('schemas', idx.id)
        
  
          if(schemaRecords == null){
            schemaRecords = { schemas: [] }
          }
         
          let record = {
              accountId: accountId,
              name: aliasName,
              url: schemaURL.commitId.toUrl()
            }
            
          schemaRecords.schemas.push(record)
          let result = await idx.set('schemas', schemaRecords)
      }

      let updatedSchemas = await idx.get('schemas', idx.id)
      
      let n = 0
      while (n < updatedSchemas.schemas.length) {
        if(updatedSchemas.schemas[n].accountId == accountId && updatedSchemas.schemas[n].name == aliasName){
            schemaURL = updatedSchemas.schemas[n].url
            break
        }
        n++
      }

      // create a new profile definition
      let definition
      try {
        definition = await createDefinition(ceramicClient, {
          name: aliasName,
          description: defDesc,
          schema: schemaURL
        })
      } catch (err) {
        console.log('definition issue', err)
      }

      let defRecords = await idx.get('definitions', idx.id)

      if(defRecords == null){
        defRecords = { defs: [] }
      }

      let record = {
          accountId: accountId,
          alias: aliasName,
          def: definition.id.toString()
        }

      defRecords.defs.push(record)

      let result = await idx.set('definitions', defRecords)
      
      return true
    }
    return true
  }

  async getAliases(idx, accountId) {
    
    let aliases = {}
    
    let allAliases = await idx.get('definitions', idx.id)
    
    if(allAliases != null) {

      //retrieve aliases for each definition
      let i = 0
      
      while (i < allAliases.defs.length) {
          if(allAliases.defs[i].accountId == accountId){
            let alias = {[allAliases.defs[i].alias]: allAliases.defs[i].def}
            aliases = {...aliases, ...alias}
          }
          i++
      }
      return aliases
    } else {
    return {}
    }
  }

  // application IDX - maintains most up to date schemas and definitions ensuring chain always has the most recent commit
  async getAppIdx(contract){

    const appClient = await this.getAppCeramic()

    const appDid = this.associateAppDID(process.env.APP_OWNER_ACCOUNT, contract, appClient)
    const definitions = this.getAlias(process.env.APP_OWNER_ACCOUNT, 'Definitions', appClient, definitionsSchema, 'alias definitions', contract)
    const schemas = this.getAlias(process.env.APP_OWNER_ACCOUNT, 'Schemas', appClient, schemaSchema, 'user schemas', contract)
    const done = await Promise.all([appDid, definitions, schemas])
    
    let rootAliases = {
      definitions: done[1],
      schemas: done[2]
    }
    const appIdx = new IDX({ ceramic: appClient, aliases: rootAliases})
   
    return appIdx
  }

  // owner IDX (account currently logged in and for which new Personas are made)
  async getCurrentUserIdx(account, appIdx, contract, owner, ownerIdx){
    
      let seed = await this.getLocalAccountSeed(account.accountId)
      let currentUserCeramicClient = await this.getCeramic(account, seed)

      if(owner != undefined) {
      let ownerSeed = await this.getLocalAccountSeed(owner)
        if(!ownerSeed){
          ownerIdx = appIdx
        } else {
          let ownerClient = await this.getCeramic(owner, ownerSeed)
          const definitions = await this.getAlias(owner, 'Definitions', ownerClient, definitionsSchema, 'alias definitions', contract)
          const schemas = await this.getAlias(owner, 'Schemas', ownerClient, schemaSchema, 'user schemas', contract)
          let ownerAliases = {
            definitions: definitions,
            schemas: schemas
          }
          ownerIdx = new IDX({ ceramic: ownerClient, aliases: ownerAliases})
        }
      } else {
        ownerIdx = appIdx
      }
      
      let currentAliases = await this.getAliases(ownerIdx, account.accountId)

      let curUserIdx = new IDX({ ceramic: currentUserCeramicClient, aliases: currentAliases})
  
      //initialize aliases if required
      const profileAlias = await this.aliasSetup(ownerIdx, account.accountId, 'profile', 'user profile data', profileSchema, currentUserCeramicClient)
      const accountsKeysAlias = await this.aliasSetup(ownerIdx, account.accountId, 'accountsKeys', 'user account info', accountKeysSchema, currentUserCeramicClient)
      currentAliases = await this.getAliases(ownerIdx, account.accountId)
      curUserIdx = new IDX({ ceramic: currentUserCeramicClient, aliases: currentAliases})
  
      return curUserIdx
  }

  async getCurrentUserIdxNoDid (appIdx, contract, account, keyPair, recipientName, owner, ownerIdx) {
  
    if(keyPair == undefined){
    keyPair = KeyPair.fromRandom('ed25519')   
    const links = get(ACCOUNT_LINKS, [])
    let c = 0
    let accountExists
    while(c < links.length) {
        if(links[c].accountId == account.accountId){
            accountExists = true
            links[c] = { key: keyPair.secretKey, accountId: account.accountId, recipientName: recipientName, owner: owner, keyStored: Date.now() }
            set(ACCOUNT_LINKS, links)
            break
        } else {
            accountExists = false
        }
    c++
    }
    if(!accountExists){
      links.push({ key: keyPair.secretKey, accountId: account.accountId, recipientName: recipientName, owner: owner, keyStored: Date.now() })
      set(ACCOUNT_LINKS, links)
    }
    } else {
      const links = get(ACCOUNT_LINKS, [])
      let c = 0
      let accountExists
      while(c < links.length) {
          if(links[c].accountId == account.accountId){
              accountExists = true
              links[c] = { key: keyPair.secretKey, accountId: account.accountId, recipientName: recipientName, owner: owner, keyStored: Date.now() }
              break
          } else {
              accountExists = false
          }
      c++
      }
      if(!accountExists){
        links.push({ key: keyPair.secretKey, accountId: account.accountId, recipientName: recipientName, owner: owner, keyStored: Date.now() })
        set(ACCOUNT_LINKS, links)
      }
    }

    //retrieve seed for newly created account
    let seed = await this.getLocalAccountSeed(account.accountId)

    // Initiate new User Ceramic Client
    let newUserCeramicClient = await this.getCeramic(account, seed)
    
    if(owner != '') {
    let ownerSeed = await this.getLocalAccountSeed(owner)
      if(!ownerSeed){
        ownerIdx = appIdx
      } else {
        let ownerClient = await this.getCeramic(owner, ownerSeed)
        const definitions = await this.getAlias(owner+':Definitions', ownerClient, definitionsSchema, 'alias definitions', contract)
        const schemas = await this.getAlias(owner+':Schemas', ownerClient, schemaSchema, 'user schemas', contract)
       
        let ownerAliases = {
          definitions: definitions,
          schemas: schemas
        }
        ownerIdx = new IDX({ ceramic: ownerClient, aliases: ownerAliases})
      }
    } else {
      ownerIdx = appIdx
    }
   
    
    // Associate current user NEAR account with DID and store in contract
    let associate = this.associateDID(account.accountId, contract, newUserCeramicClient)
    let profileAlias = await this.aliasSetup(ownerIdx, account.accountId, 'profile', 'user profile data', profileSchema, newUserCeramicClient)
    let accountsKeysAlias = await this.aliasSetup(ownerIdx, account.accountId, 'accountsKeys', 'user account info', accountKeysSchema, newUserCeramicClient)
    const done = await Promise.all([associate])
  
    let currentAliases = await this.getAliases(ownerIdx, account.accountId)
    const curUserIdx = new IDX({ ceramic: newUserCeramicClient, aliases: currentAliases})

    // Store it's new seed/list of accounts for later retrieval
    const updatedLinks = get(ACCOUNT_LINKS, [])
    await this.storeKeysSecret(curUserIdx, updatedLinks, 'accountsKeys')
    return curUserIdx
  }

}

export const ceramic = new Ceramic()
'''
'''--- src/utils/mobile.js ---

import copy from 'copy-to-clipboard';

export const share = (text) => {
    if (navigator.share) {
        navigator.share({
            text
        }).catch((e) => {
            copy(text)
        });
    } else {
        copy(text)
    }
}
'''
'''--- src/utils/state.js ---
import React, { createContext, useReducer } from 'react';

export const State = (initialState, prefix) => {
	let updatedState;
	const getState = () => updatedState;
	const store = createContext(initialState);
	const { Provider: InnerProvider } = store;

	const updateState = (state, path = '', newState = {}) => {
		// console.log('updateState', state, path, newState) // debugging

		if (path.length === 0) {
			return { ...state, ...newState };
		}
		const pathArr = path.split('.');
		const first = pathArr[0];
    
		state = { ...state };
		if (!state[first]) {
			state[first] = {};
        }

		if (pathArr.length === 1) {
			state[first] = typeof newState === 'object' && newState !== null && !Array.isArray(newState) ? {
				...state[first],
				...newState
			} : newState;
		} else {
			state[first] = {
				...state[first],
				...updateState(state[first], pathArr.slice(1).join('.'), newState)
			};
		}

		return state;
	};

	const Provider = ({ children }) => {
		const [state, dispatch] = useReducer((state, payload) => {
			const { path, newState } = payload;
			if (path === undefined) {
				return state;
			}
			updatedState = updateState(state, path, newState);
			return updatedState;
		}, initialState);

		const update = (path, newState) => {
			dispatch({ path, newState });
		};
		const wrappedDispatch = (fn) => fn({ update, getState, dispatch: wrappedDispatch });

		return <InnerProvider value={{ update, state, dispatch: wrappedDispatch }}>{children}</InnerProvider>;
	};

	if (prefix) {
		return {
			[prefix + 'Store']: store,
			[prefix.substr(0, 1).toUpperCase() + prefix.substr(1) + 'Provider']: Provider,
		};
	}
    
	return { store, Provider };
};

'''
'''--- src/utils/storage.js ---
export const get = (k, d = {}) => {
    let v = localStorage.getItem(k)
    try {
        return JSON.parse(v || JSON.stringify(d))
    } catch (e) {
        return v
    }
}
export const set = (k, v) => localStorage.setItem(k, typeof v === 'string' ? v : JSON.stringify(v))
export const del = (k) => localStorage.removeItem(k)
'''