*GitHub Repository "patronus5/simple-amm-near"*

'''--- .cargo/config.toml ---
[build]
rustflags = ["-C", "link-args=-s"]

'''
'''--- Cargo.toml ---
[workspace]
members = [
    "contract",
    "test-token"
]
resolver = "2"

[profile]
[profile.release]
codegen-units = 1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- README.md ---
# Simple AMM

This is a simple Automated Market Maker (AMM) Smart Contract that supports swapping two tokens.
The owner of the Smart Contract can add liquidity via sending the appropriate token.
All other users can then swap via sending one of the respective token.

## Building

- Install Rust via [Rustup](https://rustup.rs/)
- Add WebAssembly tookchain: `rustup target add wasm32-unknown-unknown`
- Compile this Smart Contract: `./build.sh`

## Deployment

Make sure to have [Near CLI](https://github.com/near/near-cli) installed: `npm install -g near-cli`.
We will create a subaccount where we deploy the contract.

```bash
# setup
NEAR_ENV=testnet # change this to mainnet for prod
MASTER_ACCOUNT=
CONTRACT_ID=amm.$MASTER_ACCOUNT
# the contract owner will be the only one who can add liquidity
OWNER_ID=

# Login
near login

# create subaccount with 10 Near initially
near create-account $CONTRACT_ID --masterAccount $MASTER_ACCOUNT --initialBalance 10

# deploy contract
near deploy --wasmFile res/orderly_contract.wasm --accountId $CONTRACT_ID
```

## Test tokens

There are plenty of test tokens on [Ref Finance](https://testnet.ref.finance/), that you can use.
If you want to you can also deploy your own test tokens, which are also used in integration tests.
We can also freely mint these tokens, which makes testing easy.

```bash
TOKEN_ID1=token-a.$MASTER_ACCOUNT
TOKEN_ID2=token-b.$MASTER_ACCOUNT

near create-account $TOKEN_ID1 --masterAccount $MASTER_ACCOUNT --initialBalance 2
near deploy --wasmFile res/test_token.wasm --accountId $TOKEN_ID1
near call $TOKEN_ID1 new '{ "name": "TokenA", "symbol": "TKNA" }' --accountId $TOKEN_ID1
near call $TOKEN_ID1 mint '{ "account_id": "'$OWNER_ID'", "amount": "1000000" }' --accountId $TOKEN_ID1

near create-account $TOKEN_ID2 --masterAccount $MASTER_ACCOUNT --initialBalance 2
near deploy --wasmFile res/test_token.wasm --accountId $TOKEN_ID2
near call $TOKEN_ID2 new '{ "name": "TokenB", "symbol": "TKNB" }' --accountId $TOKEN_ID2
near call $TOKEN_ID2 mint '{ "account_id": "'$OWNER_ID'", "amount": "1000000" }' --accountId $TOKEN_ID2
```

## Initialization

```bash
# we now initialize amm contract
near call $CONTRACT_ID new '{ "owner": "'$OWNER_ID'" }' --accountId $CONTRACT_ID

# we also need to setup the two tokens, that will be used in the liquidity pool for swapping
near call $CONTRACT_ID init '{ "token_a": "'$TOKEN_ID1'", "token_b": "'$TOKEN_ID2'" }' --accountId $CONTRACT_ID

# and register contract for these tokens
near call $TOKEN_ID1 storage_deposit '{ "account_id": "'$CONTRACT_ID'" }' --accountId $CONTRACT_ID --deposit 1
near call $TOKEN_ID2 storage_deposit '{ "account_id": "'$CONTRACT_ID'" }' --accountId $CONTRACT_ID --deposit 1

# owner now needs to add liquidity for both tokens
near call $TOKEN_ID1 ft_transfer_call '{ "receiver_id": "'$CONTRACT_ID'", "amount": "1000000", "msg": "" }' --accountId $OWNER_ID --depositYocto 1 --gas 300000000000000
near call $TOKEN_ID2 ft_transfer_call '{ "receiver_id": "'$CONTRACT_ID'", "amount": "1000000", "msg": "" }' --accountId $OWNER_ID --depositYocto 1 --gas 300000000000000
```

## Testing

The contract has various integration tests for testing the cross contract interactions.
These can be executed via `cargo test`.

Since we now set up everything, we can also do manual testing of swap:

```bash
# let's do a quick check, if the contract set up the two tokens
near view $CONTRACT_ID get_contract_info
# it should return metadata about the contract and the tokens with accountId, name, supply, symbol, decimals

# setup swap user
TEST_USER=user.$MASTER_ACCOUNT
near create-account $TEST_USER --masterAccount $MASTER_ACCOUNT --initialBalance 2
near call $TOKEN_ID1 mint '{ "account_id": "'$TEST_USER'", "amount": "1000000" }' --accountId $TOKEN_ID1
near call $TOKEN_ID1 mint '{ "account_id": "'$TEST_USER'", "amount": "1000000" }' --accountId $TOKEN_ID2

# swap token-a for token-b
near call $TOKEN_ID1 ft_transfer_call '{ "receiver_id": "'$CONTRACT_ID'", "amount": "1000", "msg": "" }' --accountId $TEST_USER --depositYocto 1 --gas 300000000000000

# check token balance
near view $TOKEN_ID1 ft_balance_of '{ "account_id": "'$TEST_USER'" }'
near view $TOKEN_ID2 ft_balance_of '{ "account_id": "'$TEST_USER'" }'
```

'''
'''--- build.sh ---
#!/bin/bash
set -e
cd "`dirname $0`"
cargo build --all --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/*.wasm ./res/

'''
'''--- contract/Cargo.toml ---
[package]
name = "orderly-contract"
version = "1.0.0"
authors = ["Mario Reder <mario.reder@pm.me>"]
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4"
near-contract-standards = "4"
serde = "1"
serde_json = "1"

[dev-dependencies]
anyhow = "1"
test-token = { path = "../test-token" }
tokio = { version = "1", features = ["full"] }
workspaces = "0.3"

'''
'''--- contract/src/lib.rs ---
use near_contract_standards::fungible_token::{
    metadata::FungibleTokenMetadata, receiver::FungibleTokenReceiver,
};
use near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize},
    collections::LazyOption,
    env, ext_contract,
    json_types::U128,
    log, near_bindgen,
    serde::{Deserialize, Serialize},
    AccountId, PanicOnDefault, Promise, PromiseOrValue,
};

#[ext_contract]
pub trait ExtFungibleToken {
    fn ft_metadata(&self) -> FungibleTokenMetadata;
    fn ft_transfer(&mut self, receiver_id: AccountId, amount: U128, memo: Option<String>);
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct OrderlyContract {
    owner: AccountId,
    token_a: LazyOption<TokenPair>,
    token_b: LazyOption<TokenPair>,
}

#[derive(BorshDeserialize, BorshSerialize)]
struct TokenPair {
    pub account_id: AccountId,
    pub metadata: FungibleTokenMetadata,
    pub supply: U128,
}

#[near_bindgen]
impl OrderlyContract {
    #[init]
    pub fn new(owner: AccountId) -> Self {
        assert!(!env::state_exists(), "Already initialized");
        log!("Contract initialized with {} as owner", owner);
        Self {
            owner,
            token_a: LazyOption::new(StorageKey::TokenA.try_to_vec().unwrap(), None),
            token_b: LazyOption::new(StorageKey::TokenB.try_to_vec().unwrap(), None),
        }
    }

    #[private]
    pub fn init(&mut self, token_a: AccountId, token_b: AccountId) -> Promise {
        assert!(self.token_a.get().is_none(), "Already initialized");
        ext_fungible_token::ext(token_a.clone())
            .ft_metadata()
            .and(ext_fungible_token::ext(token_b.clone()).ft_metadata())
            .then(Self::ext(env::current_account_id()).handle_init(token_a, token_b))
    }

    #[private]
    pub fn handle_init(
        &mut self,
        token_a: AccountId,
        token_b: AccountId,
        #[callback_unwrap] token_a_metadata: FungibleTokenMetadata,
        #[callback_unwrap] token_b_metadata: FungibleTokenMetadata,
    ) {
        self.token_a.set(&TokenPair {
            account_id: token_a,
            metadata: token_a_metadata,
            supply: U128::from(0),
        });
        self.token_b.set(&TokenPair {
            account_id: token_b,
            metadata: token_b_metadata,
            supply: U128::from(0),
        });
    }

    pub fn get_contract_info(&self) -> Option<ContractInfo> {
        if let (Some(token_a), Some(token_b)) = (self.token_a.get(), self.token_b.get()) {
            Some(ContractInfo {
                token_a_id: token_a.account_id,
                token_a_name: token_a.metadata.name,
                token_a_symbol: token_a.metadata.symbol,
                token_a_supply: token_a.supply,
                token_a_decimals: token_a.metadata.decimals,
                token_b_id: token_b.account_id,
                token_b_name: token_b.metadata.name,
                token_b_symbol: token_b.metadata.symbol,
                token_b_supply: token_b.supply,
                token_b_decimals: token_b.metadata.decimals,
            })
        } else {
            None
        }
    }
}

#[near_bindgen]
impl FungibleTokenReceiver for OrderlyContract {
    fn ft_on_transfer(
        &mut self,
        sender_id: AccountId,
        amount: U128,
        #[allow(unused_variables)] msg: String,
    ) -> PromiseOrValue<U128> {
        let (mut pair_a, mut pair_b) = (
            self.token_a.get().expect("Contract uninitialized"),
            self.token_b.get().expect("Contract uninitialized"),
        );

        let prod = pair_a.supply.0 * pair_b.supply.0;
        if prod == 0 && sender_id != self.owner {
            log!("Not enough liquidity available for swap");
            return PromiseOrValue::Value(amount);
        }
        let (in_pair, in_token, out_pair, out_token) =
            if env::predecessor_account_id() == pair_a.account_id {
                (
                    &mut pair_a,
                    &mut self.token_a,
                    &mut pair_b,
                    &mut self.token_b,
                )
            } else if env::predecessor_account_id() == pair_b.account_id {
                (
                    &mut pair_b,
                    &mut self.token_b,
                    &mut pair_a,
                    &mut self.token_a,
                )
            } else {
                log!("Deposited token address does not belong to liquidity pool");
                return PromiseOrValue::Value(amount);
            };
        in_pair.supply.0 += amount.0;
        in_token.set(in_pair);
        if sender_id != self.owner {
            let out_pair_supply = out_pair.supply.0;
            // this will truncate the remainder, thus resulting in a loss of lp token.
            // in a real world solution, this would need to be addressed.
            out_pair.supply.0 = prod / in_pair.supply.0;
            let out_pair_diff = out_pair_supply - out_pair.supply.0;
            log!(
                "User {} swapping {} of token {} for {} of token {}",
                &sender_id,
                amount.0,
                in_pair.account_id,
                out_pair_diff,
                out_pair.account_id
            );
            out_token.set(out_pair);

            ext_fungible_token::ext(out_pair.account_id.clone())
                .with_attached_deposit(1)
                .with_static_gas(10_000_000_000_000.into())
                .ft_transfer(sender_id, out_pair_diff.into(), Some("swap".to_string())); // .then(Self::ext(env::current_account_id()).handle_swap(token_a, token_b)),
            PromiseOrValue::Value(0.into())
        } else {
            PromiseOrValue::Value(0.into())
        }
    }
}

#[derive(Deserialize, Serialize, Eq, PartialEq, Debug)]
pub struct ContractInfo {
    pub token_a_id: AccountId,
    pub token_a_name: String,
    pub token_a_symbol: String,
    pub token_a_supply: U128,
    pub token_a_decimals: u8,
    pub token_b_id: AccountId,
    pub token_b_name: String,
    pub token_b_symbol: String,
    pub token_b_supply: U128,
    pub token_b_decimals: u8,
}

#[derive(BorshSerialize)]
enum StorageKey {
    TokenA,
    TokenB,
}

#[cfg(all(test, not(target_arch = "wasm32")))]
mod tests {
    use super::*;

    use near_sdk::{
        test_utils::{accounts, VMContextBuilder},
        testing_env,
    };

    fn get_context(predecessor_account_id: AccountId) -> VMContextBuilder {
        let mut builder = VMContextBuilder::new();
        builder
            .current_account_id(accounts(0))
            .signer_account_id(predecessor_account_id.clone())
            .predecessor_account_id(predecessor_account_id);
        builder
    }

    #[test]
    fn test_new() {
        let context = get_context(accounts(1));
        testing_env!(context.build());
        OrderlyContract::new(accounts(1));
    }
}

'''
'''--- contract/tests/contract.rs ---
use near_sdk::json_types::U128;
use orderly_contract::ContractInfo;
use tokio::fs;
use workspaces::{
    network::Sandbox,
    prelude::*,
    result::{CallExecutionDetails, ViewResultDetails},
    Account, AccountId, Contract, Worker,
};

#[tokio::test]
async fn test_init() -> anyhow::Result<()> {
    let (worker, _, contract, token_a, token_b) = initialize_contracts().await?;

    contract_init(&worker, &contract, token_a.id(), token_b.id()).await?;

    Ok(())
}

#[tokio::test]
async fn test_get_contract_info() -> anyhow::Result<()> {
    let (worker, _, contract, token_a, token_b) = initialize_contracts().await?;

    contract_init(&worker, &contract, token_a.id(), token_b.id()).await?;

    assert_token_supplies(
        &worker,
        &contract,
        token_a.id(),
        0.into(),
        token_b.id(),
        0.into(),
    )
    .await?;

    Ok(())
}

#[tokio::test]
async fn test_get_contract_info_no_init() -> anyhow::Result<()> {
    let (worker, _, contract, _, _) = initialize_contracts().await?;

    let res = contract.call(&worker, "get_contract_info").view().await?;
    assert_eq!(res.json::<Option<ContractInfo>>()?, None);

    Ok(())
}

#[tokio::test]
async fn test_deposit_owner() -> anyhow::Result<()> {
    let (worker, owner, contract, token_a, token_b) = initialize_contracts().await?;

    contract_init(&worker, &contract, token_a.id(), token_b.id()).await?;
    storage_deposit(&worker, &token_a, contract.id()).await?;
    mint_tokens(&worker, &token_a, owner.id(), 1_000_000).await?;

    transfer_tokens(&worker, &owner, contract.id(), token_a.id(), 1_000.into()).await?;

    let res = ft_balance_of(&worker, &token_a, owner.id()).await?;
    assert_eq!(res.json::<U128>()?, U128::from(999_000));
    assert_token_supplies(
        &worker,
        &contract,
        token_a.id(),
        1_000.into(),
        token_b.id(),
        0.into(),
    )
    .await?;

    Ok(())
}

#[tokio::test]
async fn test_deposit_owner_2() -> anyhow::Result<()> {
    let (worker, owner, contract, token_a, token_b) = initialize_contracts().await?;

    contract_init(&worker, &contract, token_a.id(), token_b.id()).await?;
    storage_deposit(&worker, &token_a, contract.id()).await?;
    mint_tokens(&worker, &token_a, owner.id(), 1_000_000).await?;
    storage_deposit(&worker, &token_b, contract.id()).await?;
    mint_tokens(&worker, &token_b, owner.id(), 1_000_000).await?;

    transfer_tokens(&worker, &owner, contract.id(), token_a.id(), 1_000.into()).await?;
    transfer_tokens(&worker, &owner, contract.id(), token_b.id(), 69_000.into()).await?;
    transfer_tokens(&worker, &owner, contract.id(), token_b.id(), 42.into()).await?;

    let res = ft_balance_of(&worker, &token_a, owner.id()).await?;
    assert_eq!(res.json::<U128>()?, U128::from(999_000));
    let res = ft_balance_of(&worker, &token_b, owner.id()).await?;
    assert_eq!(res.json::<U128>()?, U128::from(1_000_000 - 69_000 - 42));
    assert_token_supplies(
        &worker,
        &contract,
        token_a.id(),
        1_000.into(),
        token_b.id(),
        69_042.into(),
    )
    .await?;

    Ok(())
}

#[tokio::test]
async fn test_deposit_owner_no_init_should_refund() -> anyhow::Result<()> {
    let (worker, owner, contract, token_a, _) = initialize_contracts().await?;

    storage_deposit(&worker, &token_a, contract.id()).await?;
    mint_tokens(&worker, &token_a, owner.id(), 1_000_000).await?;

    transfer_tokens(&worker, &owner, contract.id(), token_a.id(), 1_000.into()).await?;

    let res = ft_balance_of(&worker, &token_a, owner.id()).await?;
    assert_eq!(res.json::<U128>()?, U128::from(1_000_000));

    Ok(())
}

#[tokio::test]
async fn test_swap() -> anyhow::Result<()> {
    let (worker, owner, contract, token_a, token_b) = initialize_contracts().await?;
    let user = worker.dev_create_account().await?;

    contract_init(&worker, &contract, token_a.id(), token_b.id()).await?;
    storage_deposit(&worker, &token_a, contract.id()).await?;
    mint_tokens(&worker, &token_a, owner.id(), 1_000_000).await?;
    mint_tokens(&worker, &token_a, user.id(), 1_000_000).await?;
    storage_deposit(&worker, &token_b, contract.id()).await?;
    mint_tokens(&worker, &token_b, owner.id(), 1_000_000).await?;
    mint_tokens(&worker, &token_b, user.id(), 1_000_000).await?;
    transfer_tokens(&worker, &owner, contract.id(), token_a.id(), 1_000.into()).await?;
    transfer_tokens(&worker, &owner, contract.id(), token_b.id(), 1_000.into()).await?;

    transfer_tokens(&worker, &user, contract.id(), token_a.id(), 100.into()).await?;

    let res = ft_balance_of(&worker, &token_a, user.id()).await?;
    assert_eq!(res.json::<U128>()?, U128::from(999_900));
    let res = ft_balance_of(&worker, &token_b, user.id()).await?;
    assert_eq!(res.json::<U128>()?, U128::from(1_000_091));
    assert_token_supplies(
        &worker,
        &contract,
        token_a.id(),
        1_100.into(),
        token_b.id(),
        909.into(),
    )
    .await?;

    Ok(())
}

#[tokio::test]
async fn test_swap_2() -> anyhow::Result<()> {
    let (worker, owner, contract, token_a, token_b) = initialize_contracts().await?;
    let user = worker.dev_create_account().await?;

    contract_init(&worker, &contract, token_a.id(), token_b.id()).await?;
    storage_deposit(&worker, &token_a, contract.id()).await?;
    mint_tokens(&worker, &token_a, owner.id(), 1_000_000).await?;
    mint_tokens(&worker, &token_a, user.id(), 1_000_000).await?;
    storage_deposit(&worker, &token_b, contract.id()).await?;
    mint_tokens(&worker, &token_b, owner.id(), 1_000_000).await?;
    mint_tokens(&worker, &token_b, user.id(), 1_000_000).await?;
    transfer_tokens(&worker, &owner, contract.id(), token_a.id(), 1_000.into()).await?;
    transfer_tokens(&worker, &owner, contract.id(), token_b.id(), 1_000.into()).await?;

    transfer_tokens(&worker, &user, contract.id(), token_a.id(), 50.into()).await?;
    transfer_tokens(&worker, &user, contract.id(), token_b.id(), 150.into()).await?;
    transfer_tokens(&worker, &user, contract.id(), token_a.id(), 200.into()).await?;

    let res = ft_balance_of(&worker, &token_a, user.id()).await?;
    assert_eq!(res.json::<U128>()?, U128::from(999_893));
    let res = ft_balance_of(&worker, &token_b, user.id()).await?;
    assert_eq!(res.json::<U128>()?, U128::from(1_000_098));
    assert_token_supplies(
        &worker,
        &contract,
        token_a.id(),
        1_107.into(),
        token_b.id(),
        902.into(),
    )
    .await?;

    Ok(())
}

#[tokio::test]
async fn test_swap_all() -> anyhow::Result<()> {
    let (worker, owner, contract, token_a, token_b) = initialize_contracts().await?;
    let user = worker.dev_create_account().await?;

    contract_init(&worker, &contract, token_a.id(), token_b.id()).await?;
    storage_deposit(&worker, &token_a, contract.id()).await?;
    mint_tokens(&worker, &token_a, owner.id(), 1_000_000).await?;
    mint_tokens(&worker, &token_a, user.id(), 1_000_000).await?;
    storage_deposit(&worker, &token_b, contract.id()).await?;
    mint_tokens(&worker, &token_b, owner.id(), 1_000_000).await?;
    mint_tokens(&worker, &token_b, user.id(), 1_000_000).await?;
    transfer_tokens(&worker, &owner, contract.id(), token_a.id(), 1_000.into()).await?;
    transfer_tokens(&worker, &owner, contract.id(), token_b.id(), 1_000.into()).await?;

    transfer_tokens(
        &worker,
        &user,
        contract.id(),
        token_a.id(),
        1_000_000.into(),
    )
    .await?;

    let res = ft_balance_of(&worker, &token_a, user.id()).await?;
    assert_eq!(res.json::<U128>()?, U128::from(0));
    let res = ft_balance_of(&worker, &token_b, user.id()).await?;
    assert_eq!(res.json::<U128>()?, U128::from(1_001_000));
    assert_token_supplies(
        &worker,
        &contract,
        token_a.id(),
        1_001_000.into(),
        token_b.id(),
        0.into(),
    )
    .await?;

    Ok(())
}

#[tokio::test]
async fn test_swap_not_enough_liquidity() -> anyhow::Result<()> {
    let (worker, owner, contract, token_a, token_b) = initialize_contracts().await?;
    let user = worker.dev_create_account().await?;

    contract_init(&worker, &contract, token_a.id(), token_b.id()).await?;
    storage_deposit(&worker, &token_a, contract.id()).await?;
    mint_tokens(&worker, &token_a, owner.id(), 1_000_000).await?;
    mint_tokens(&worker, &token_a, user.id(), 1_000_000).await?;
    storage_deposit(&worker, &token_b, contract.id()).await?;
    mint_tokens(&worker, &token_b, owner.id(), 1_000_000).await?;
    mint_tokens(&worker, &token_b, user.id(), 1_000_000).await?;
    transfer_tokens(&worker, &owner, contract.id(), token_a.id(), 1_000.into()).await?;

    transfer_tokens(&worker, &user, contract.id(), token_a.id(), 10.into()).await?;

    let res = ft_balance_of(&worker, &token_a, user.id()).await?;
    assert_eq!(res.json::<U128>()?, U128::from(1_000_000));
    let res = ft_balance_of(&worker, &token_b, user.id()).await?;
    assert_eq!(res.json::<U128>()?, U128::from(1_000_000));
    assert_token_supplies(
        &worker,
        &contract,
        token_a.id(),
        1_000.into(),
        token_b.id(),
        0.into(),
    )
    .await?;

    Ok(())
}

async fn initialize_contracts(
) -> anyhow::Result<(Worker<Sandbox>, Account, Contract, Contract, Contract)> {
    let worker = workspaces::sandbox().await?;

    let owner = worker.dev_create_account().await?;

    let contract = worker
        .dev_deploy(&fs::read("../res/orderly_contract.wasm").await?)
        .await?;
    contract
        .call(&worker, "new")
        .args_json((owner.id(),))?
        .max_gas()
        .transact()
        .await?;

    let token_a_contract = worker
        .dev_deploy(&fs::read("../res/test_token.wasm").await?)
        .await?;
    token_a_contract
        .call(&worker, "new")
        .args_json(("TokenA", "TKNA"))?
        .transact()
        .await?;

    let token_b_contract = worker
        .dev_deploy(&fs::read("../res/test_token.wasm").await?)
        .await?;
    token_b_contract
        .call(&worker, "new")
        .args_json(("TokenB", "TKNB"))?
        .transact()
        .await?;

    Ok((worker, owner, contract, token_a_contract, token_b_contract))
}

async fn contract_init(
    worker: &Worker<Sandbox>,
    contract: &Contract,
    token_a: &AccountId,
    token_b: &AccountId,
) -> anyhow::Result<()> {
    let res = contract
        .call(worker, "init")
        .args_json((token_a, token_b))?
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success());
    Ok(())
}

async fn storage_deposit(
    worker: &Worker<Sandbox>,
    token: &Contract,
    receiver: &AccountId,
) -> anyhow::Result<()> {
    let res = token
        .call(worker, "storage_deposit")
        .args_json((receiver, Option::<bool>::None))?
        .deposit(1_000_000_000_000_000_000_000_000)
        .transact()
        .await?;
    assert!(res.is_success());
    Ok(())
}

async fn mint_tokens(
    worker: &Worker<Sandbox>,
    token: &Contract,
    receiver: &AccountId,
    amount: u128,
) -> anyhow::Result<()> {
    let res = token
        .call(worker, "mint")
        .args_json((receiver, U128::from(amount)))?
        .transact()
        .await?;
    assert!(res.is_success());
    Ok(())
}

async fn transfer_tokens(
    worker: &Worker<Sandbox>,
    sender: &Account,
    receiver: &AccountId,
    token: &AccountId,
    amount: U128,
) -> anyhow::Result<CallExecutionDetails> {
    let res = sender
        .call(worker, token, "ft_transfer_call")
        .args_json((receiver, amount, Option::<String>::None, "".to_string()))?
        .max_gas()
        .deposit(1)
        .transact()
        .await?;
    assert!(res.is_success());
    Ok(res)
}

async fn ft_balance_of(
    worker: &Worker<Sandbox>,
    token: &Contract,
    account_id: &AccountId,
) -> anyhow::Result<ViewResultDetails> {
    let res = token
        .call(worker, "ft_balance_of")
        .args_json((account_id,))?
        .view()
        .await?;
    Ok(res)
}

async fn assert_token_supplies(
    worker: &Worker<Sandbox>,
    contract: &Contract,
    token_a: &AccountId,
    token_a_supply: U128,
    token_b: &AccountId,
    token_b_supply: U128,
) -> anyhow::Result<()> {
    let res = contract.call(worker, "get_contract_info").view().await?;
    assert_eq!(
        res.json::<ContractInfo>()?,
        ContractInfo {
            token_a_id: token_a.to_string().parse().unwrap(),
            token_a_name: "TokenA".to_string(),
            token_a_symbol: "TKNA".to_string(),
            token_a_supply,
            token_a_decimals: 12,
            token_b_id: token_b.to_string().parse().unwrap(),
            token_b_name: "TokenB".to_string(),
            token_b_symbol: "TKNB".to_string(),
            token_b_supply,
            token_b_decimals: 12
        }
    );
    Ok(())
}

'''
'''--- test-token/Cargo.toml ---
[package]
name = "test-token"
version = "0.1.0"
authors = ["Mario Reder <mario.reder@pm.me>"]
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4"
near-contract-standards = "4"
'''
'''--- test-token/src/lib.rs ---
use near_contract_standards::fungible_token::metadata::{
    FungibleTokenMetadata, FungibleTokenMetadataProvider,
};
use near_contract_standards::fungible_token::FungibleToken;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::U128;
use near_sdk::{near_bindgen, AccountId, PanicOnDefault, PromiseOrValue};

#[near_bindgen]
#[derive(BorshSerialize, BorshDeserialize, PanicOnDefault)]
pub struct Contract {
    name: String,
    symbol: String,
    token: FungibleToken,
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new(name: String, symbol: String) -> Self {
        Self {
            name,
            symbol,
            token: FungibleToken::new(b"t".to_vec()),
        }
    }

    pub fn mint(&mut self, account_id: AccountId, amount: U128) {
        self.token.internal_register_account(&account_id);
        self.token.internal_deposit(&account_id, amount.into());
    }

    pub fn burn(&mut self, account_id: AccountId, amount: U128) {
        self.token.internal_withdraw(&account_id, amount.into());
    }
}

near_contract_standards::impl_fungible_token_core!(Contract, token);
near_contract_standards::impl_fungible_token_storage!(Contract, token);

#[near_bindgen]
impl FungibleTokenMetadataProvider for Contract {
    fn ft_metadata(&self) -> FungibleTokenMetadata {
        FungibleTokenMetadata {
            spec: "ft-1.0.0".to_string(),
            name: self.name.clone(),
            symbol: self.symbol.clone(),
            icon: None,
            reference: None,
            reference_hash: None,
            decimals: 12,
        }
    }
}

#[cfg(test)]
mod tests {
    use near_sdk::test_utils::{accounts, VMContextBuilder};
    use near_sdk::{env, testing_env};

    use super::*;

    #[test]
    fn test_basics() {
        let mut context = VMContextBuilder::new();
        testing_env!(context.build());
        let mut contract = Contract::new("token".to_string(), "TKN".to_string());
        testing_env!(context
            .attached_deposit(125 * env::storage_byte_cost())
            .build());
        contract.mint(accounts(0), 1_000_000.into());
        assert_eq!(contract.ft_balance_of(accounts(0)), 1_000_000.into());

        testing_env!(context
            .attached_deposit(125 * env::storage_byte_cost())
            .build());
        contract.storage_deposit(Some(accounts(1)), None);
        testing_env!(context
            .attached_deposit(1)
            .predecessor_account_id(accounts(0))
            .build());
        contract.ft_transfer(accounts(1), 1_000.into(), None);
        assert_eq!(contract.ft_balance_of(accounts(1)), 1_000.into());

        contract.burn(accounts(1), 500.into());
        assert_eq!(contract.ft_balance_of(accounts(1)), 500.into());
    }
}

'''