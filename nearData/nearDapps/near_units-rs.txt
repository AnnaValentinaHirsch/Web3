*GitHub Repository "near/units-rs"*

'''--- .github/workflows/test.yml ---
name: Test Core
on:
  push:
    branches:
      - master
  pull_request:
jobs:
  test:
    runs-on: ${{ matrix.platform }}
    name: "${{ matrix.platform }} ${{ matrix.toolchain }}"
    strategy:
      matrix:
        platform: [ubuntu-latest, macos-latest]
        toolchain: [stable]
    steps:
      - uses: actions/checkout@v2
      - name: "${{ matrix.toolchain }} with rustfmt"
        uses: actions-rs/toolchain@v1
        with:
          profile: minimal
          toolchain: ${{ matrix.toolchain }}
      - uses: Swatinem/rust-cache@v1
      - name: Test
        run: cargo test
  lint:
    name: Clippy and fmt
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Install stable toolchain
        uses: actions-rs/toolchain@v1
        with: 
          profile: minimal
          toolchain: stable
          components: rustfmt, clippy
      - uses: Swatinem/rust-cache@v1
      - name: Test Format
        run: cargo fmt -- --check
      - run: cargo clippy --tests -- -Dclippy::all

'''
'''--- Cargo.toml ---
# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[workspace]
members = ["crates/*"]

'''
'''--- README.md ---
NEAR Units
==========

> Note: It is recommended to use [near-gas](https://crates.io/crates/near-gas) and [near-token](https://crates.io/crates/near-token) crates instead of near-units, as those crates provide strict type wrappers, const constructors, and overall extremely lightweight.

Rust tools to help parse and format NEAR units. For now, this means NEAR tokens and [gas units](https://docs.near.org/docs/concepts/gas).

# Install

```toml
near-units="0.1.0"
```

# Parsing strings

'''
'''--- crates/core/Cargo.toml ---
[package]
name = "near-units-core"
version = "0.2.0"
authors = ["Near Inc <team@near.org>"]
edition = "2018"
license = "GPL-3.0"
categories = ["near"]
repository = "https://github.com/near/units-rs"
description = """
Core Rust library for parsing and displaying NEAR units.
"""

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
regex = "1.5"
num-format = "0.4.0"
'''
'''--- crates/core/src/gas.rs ---
use regex::Regex;
use std::num::ParseIntError;

fn parse_str(from: &str) -> Option<String> {
    let gas = Regex::new(r"(?i:gas)\s*")
        .unwrap()
        .replace_all(from, "")
        .to_string();
    crate::util::parse(&gas, 0)
}

pub fn parse(input: &str) -> Result<u128, ParseIntError> {
    parse_str(input)
        .expect("Cannot parse string")
        .parse::<u128>()
}

pub fn to_human(input: u128) -> String {
    crate::util::to_human(input, "gas", 12, 12)
}

#[cfg(test)]
mod tests {
    use super::*;
    const DATA: [[&str; 3]; 7] = [
        ["1", "1", "1 gas"],
        ["1,000", "1000", "1 kgas"],
        ["1,000,000", "1000000", "1 Mgas"],
        ["1,000,000,000", "1000000000", "1 Ggas"],
        ["1,000,000,000,000", "1000000000000", "1 Tgas"],
        ["1Tgas", "1000000000000", "1 Tgas"],
        ["1Ggas", "1000000000", "1 Ggas"],
    ];

    #[test]
    fn it_works() {
        for line in &DATA {
            let parsed = parse(line[0]).unwrap();
            let expected = line[1];
            assert_eq!(parsed.to_string(), expected);
            assert_eq!(to_human(parsed), line[2]);
        }
    }
}

'''
'''--- crates/core/src/lib.rs ---
pub mod gas;
pub mod near;
pub mod prefixes;
pub mod util;

'''
'''--- crates/core/src/near.rs ---
use std::num::ParseIntError;

use regex::Regex;

fn parse_str(input: &str) -> Option<String> {
    let near = Regex::new(r"(?i:n(?i:ear)?)\s*$")
        .unwrap()
        .replace_all(input, "")
        .to_string();
    crate::util::parse(&near, 24)
}

pub fn parse(input: &str) -> Result<u128, ParseIntError> {
    parse_str(input)
        .expect("Cannot parse string")
        .parse::<u128>()
}

pub fn to_human(input: u128) -> String {
    crate::util::to_human(input, "N", 24, 0)
}

#[cfg(test)]
mod tests {
    use super::*;
    const DATA: [[&str; 3]; 26] = [
        ["1", "1000000000000000000000000", "1 N"],
        [".1000000000000", "100000000000000000000000", "100 mN"],
        ["1,000", "1000000000000000000000000000", "1,000 N"],
        ["1.0", "1000000000000000000000000", "1 N"],
        [
            "1,000,000",
            "1000000000000000000000000000000",
            "1,000,000 N",
        ],
        [
            "1,000,000.000_000_01   ",
            "1000000000000010000000000000000",
            "1,000,000.00000001 N",
        ],
        ["1MN", "1000000000000000000000000000000", "1,000,000 N"],
        ["1kN   ", "1000000000000000000000000000", "1,000 N"],
        ["0.001_101", "1101000000000000000000", "1.101 mN"],
        ["0.000,101", "101000000000000000000", "101 μN"],
        ["1mN", "1000000000000000000000", "1 mN"],
        ["1 milliN", "1000000000000000000000", "1 mN"],
        [" 001      m N    ", "1000000000000000000000", "1 mN"],
        ["1 milliNEAR", "1000000000000000000000", "1 mN"],
        ["1 milliN", "1000000000000000000000", "1 mN"],
        ["1 millinear", "1000000000000000000000", "1 mN"],
        ["1 milli   ", "1000000000000000000000", "1 mN"],
        ["1 m", "1000000000000000000000", "1 mN"],
        ["1μ", "1000000000000000000", "1 μN"],
        ["1micro", "1000000000000000000", "1 μN"],
        ["1nN", "1000000000000000", "1 nN"],
        ["1p", "1000000000000", "1 pN"],
        ["1f", "1000000000", "1 fN"],
        ["1a", "1000000", "1 aN"],
        ["1z", "1000", "1 zN"],
        ["1y", "1", "1 yN"],
    ];

    #[test]
    fn it_works() {
        for line in &DATA {
            let parsed = parse(line[0]).unwrap();
            let expected = line[1];
            assert_eq!(parsed.to_string(), expected);
            assert_eq!(to_human(parsed), line[2]);
        }
    }
}

'''
'''--- crates/core/src/prefixes.rs ---
pub const YOTTA: &str = r"yotta|Y$";
pub const ZETTA: &str = r"zetta|Z$";
pub const EXA: &str = r"exa|E$";
pub const PETA: &str = r"peta|P$";
pub const TERRA: &str = r"terra|T$";
pub const GIGA: &str = r"giga|G$";
pub const MEGA: &str = r"mega|M$";
pub const KILO: &str = r"kilo|k$";
pub const HECTO: &str = r"hecto|h$";
pub const DEKA: &str = r"deka|da$";
pub const DECI: &str = r"deci|d$";
pub const CENTI: &str = r"centi|c$";
pub const MILLI: &str = r"milli|m$";
pub const MICRO: &str = r"micro|μ$";
pub const NANO: &str = r"nano|n$";
pub const PICO: &str = r"pico|p$";
pub const FEMTO: &str = r"femto|f$";
pub const ATTO: &str = r"atto|a$";
pub const ZEPTO: &str = r"zepto|z$";
pub const YOCTO: &str = r"yocto|y$";

pub const PATTERNS: [&str; 20] = [
    YOTTA, ZETTA, EXA, PETA, TERRA, GIGA, MEGA, KILO, HECTO, DEKA, DECI, CENTI, MILLI, MICRO, NANO,
    PICO, FEMTO, ATTO, ZEPTO, YOCTO,
];
pub static MAGNITUDES: [i8; 20] = [
    24, 21, 18, 15, 12, 9, 6, 3, 2, 1, -1, -2, -3, -6, -9, -12, -15, -18, -21, -24,
];

pub const fn from_magnitude(magnitude: i8) -> Option<&'static str> {
    match magnitude {
        24 => Some("Y"),
        21 => Some("Z"),
        18 => Some("E"),
        15 => Some("P"),
        12 => Some("T"),
        9 => Some("G"),
        6 => Some("M"),
        3 => Some("k"),
        0 => Some(""),
        -3 => Some("m"),
        -6 => Some("μ"),
        -9 => Some("n"),
        -12 => Some("p"),
        -15 => Some("f"),
        -18 => Some("a"),
        -21 => Some("z"),
        -24 => Some("y"),
        _ => None,
    }
}

'''
'''--- crates/core/src/util.rs ---
use crate::prefixes::{from_magnitude, MAGNITUDES, PATTERNS};
use num_format::{Locale, ToFormattedString};
use regex::{Regex, RegexSet};

pub fn get_match(s: &str) -> Option<usize> {
    let set = RegexSet::new(&PATTERNS).unwrap();
    let matches: Vec<usize> = set.matches(s.trim_end()).into_iter().collect();
    if matches.len() != 1 {
        return None;
    }
    matches.get(0).copied()
}

pub fn get_magnitude(s: &str) -> i8 {
    get_match(s).map_or(0, |m| MAGNITUDES[m])
}

pub fn clean(x: &str) -> String {
    Regex::new(r"(?:[,_])|^(0|\s)+\b|(?i:\s|[μa-z])+$")
        .unwrap()
        .replace_all(x, "")
        .to_string()
}

pub fn parse(with_units: &str, magnitude: i8) -> Option<String> {
    let maginitude = magnitude + get_magnitude(with_units);
    let num_str = clean(with_units);
    let mut parts = num_str.split('.');
    let whole_part = parts.next().unwrap();
    let fraction_part = parts.next().unwrap_or("");

    // For now these are options but will be refactor into errors
    // Means more than one `.`s
    if parts.next().is_some() {
        return None;
    }
    if maginitude == 0 && !fraction_part.is_empty() {
        return None;
    }
    if fraction_part.len() as i8 > maginitude {
        return None;
    }

    return Some(format!(
        "{}{}{}",
        whole_part,
        fraction_part,
        "0".repeat(maginitude as usize - fraction_part.len())
    ));
}

pub fn to_human(num: u128, base_unit: &str, maginitude: i8, adjust_magnitude: i8) -> String {
    let nomination = u128::pow(10, maginitude as u32);
    let quotient = num / nomination;
    let remainder = num % nomination;

    if quotient > 0 {
        let int = quotient.to_formatted_string(&Locale::en);
        let remainder_str = remainder.to_string();
        let fraction = if remainder == 0 {
            "".to_string()
        } else {
            let pad = (maginitude as isize - remainder_str.len() as isize).max(0) as usize;
            format!(".{}{}", "0".repeat(pad), remainder_str)
                .trim_end_matches('0')
                .to_string()
        };
        let prefix = from_magnitude(adjust_magnitude).unwrap();
        return format!("{}{} {}{}", int, fraction, prefix, base_unit);
    }

    to_human(num, base_unit, maginitude - 3, adjust_magnitude - 3)
}

#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn it_works() {
        assert_eq!(get_match("y").unwrap(), 19);
        assert_eq!(get_magnitude("y"), -24);
        assert_eq!(get_match("yocto").unwrap(), 19);
        assert_eq!(get_magnitude("yocto"), -24);
        assert_eq!(get_magnitude("1yocto"), -24);
    }

    #[test]
    fn parse_test() {
        assert_eq!(parse("1000m", 24).unwrap(), "1000000000000000000000000");
    }
}

'''
'''--- crates/macro/Cargo.toml ---
[package]
name = "near-units-macro"
version = "0.2.0"
authors = ["Willem Wyndham <wyndham@cs.unc.edu>"]
edition = "2018"
license = "GPL-3.0"
categories = ["near"]
repository = "https://github.com/near/units-rs"
description = """
Macro for parsing strings literals of NEAR units.
"""

[lib]
proc-macro = true

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
proc-macro2 = "1.0"
syn = {version = "1", features = ["full", "fold", "extra-traits"] }
quote = "1.0"

near-units-core = { path = "../core", version = "0.2.0" }
'''
'''--- crates/macro/src/lib.rs ---
extern crate proc_macro;
use std::num::ParseIntError;

use near_units_core::{gas, near};
use proc_macro::TokenStream;
use proc_macro2::Span;
use quote::quote;
use syn::{ExprLit, Lit};

fn parse_knobs<F>(item: TokenStream, parse: F) -> TokenStream
where
    F: FnOnce(&str) -> Result<u128, ParseIntError>,
{
    match syn::parse::<ExprLit>(item) {
        Ok(ExprLit {
            lit: Lit::Str(str), ..
        }) => {
            let str = parse(&str.value()).unwrap();
            TokenStream::from(quote! {#str})
        }
        _ => TokenStream::from(
            syn::Error::new(
                Span::call_site(),
                "parse can only be used with string literals",
            )
            .to_compile_error(),
        ),
    }
}

#[proc_macro]
pub fn parse_near(item: TokenStream) -> TokenStream {
    parse_knobs(item, near::parse)
}

#[proc_macro]
pub fn parse_gas(item: TokenStream) -> TokenStream {
    parse_knobs(item, |x| gas::parse(x))
}

'''
'''--- crates/units/Cargo.toml ---
[package]
name = "near-units"
version = "0.2.0"
authors = ["Near Inc <team@near.org>"]
edition = "2018"
license = "GPL-3.0"
categories = ["near"]
repository = "https://github.com/near/units-rs"
description = """
Rust library for parsing and displaying NEAR units.
"""

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
near-units-core = { path = "../core", version = "0.2.0"}
near-units-macro = { path = "../macro", version = "0.2.0"}

'''
'''--- crates/units/src/lib.rs ---
pub use near_units_core::*;
pub use near_units_macro::*;

#[cfg(test)]
mod tests {
    use super::*;
    const ONE_NEAR: u128 = 1_000_000_000_000_000_000_000_000;
    const ONE_TGAS: u128 = 1_000_000_000_000;
    const ONE_PARSED_NEAR: u128 = parse_near!("1 N");
    const ONE_PARSED_TGAS: u128 = parse_gas!("1 TGas");

    #[test]
    fn const_parse_near() {
        assert_eq!(near::parse("1N").unwrap(), ONE_NEAR);
        assert_eq!(ONE_PARSED_NEAR, ONE_NEAR);
    }

    #[test]
    fn const_parse_gas() {
        assert_eq!(gas::parse("1 TGas").unwrap(), ONE_TGAS);
        assert_eq!(ONE_PARSED_TGAS, ONE_TGAS);
    }
}

'''