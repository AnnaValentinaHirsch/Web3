*GitHub Repository "open-web-academy/NCAR-Example"*

'''--- Cargo.toml ---
[package]
name = "products"
version = "0.1.0"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "=4.0.0-pre.5"
serde_json = "1.0"
near-sys = "0.1.0"

[profile.release]
codegen-units=1
opt-level = "s"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- README.md ---
ID=dev-1651864499848-99321882647793

echo $ID

Inicializar contrato:

near call $ID init_contract '{"owner_id":"'$ID'"}' --accountId $ID

Obtener producto

    near view $ID get_products '{"address":"0x1"}'
    near view $ID get_products '{"address":"0x2"}'
    near view $ID get_products '{"address":"0x3"}'

Guardar producto

    near call $ID set_products '{"address":"0x1", "name":"zapatos", "price": 250, "stock":5}' --accountId yairnava.testnet
    near call $ID set_products '{"address":"0x2", "name":"botas", "price": 450, "stock":10}' --accountId yairnava.testnet
    near call $ID set_products '{"address":"0x3", "name":"tenis", "price": 300, "stock":7}' --accountId yairnava.testnet

Eliminar producto

    near call $ID delete_products '{"address":"0x3"}' --accountId yairnava.testnet
'''
'''--- src/lib.rs ---
use std::collections::HashMap;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LazyOption, LookupMap, UnorderedMap, UnorderedSet};
use near_sdk::json_types::{Base64VecU8, U128};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{
    env, log, near_bindgen, AccountId, Balance, CryptoHash, PanicOnDefault, Promise, PromiseOrValue,
    PromiseResult, Gas, require, serde_json::json
};

#[derive(Serialize, Deserialize, BorshDeserialize, BorshSerialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct Item {
    address: String,
    name: String,
    price: u64,
    stock: u64,
    enabled: bool
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    pub owner_id: AccountId,
    pub records: LookupMap<String, Item>,
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn init_contract(owner_id: AccountId) -> Self {
        //calls the other function "new: with some default metadata and the owner_id passed in 
        Self::new(
            owner_id
        )
    }

    #[init]
    pub fn new(owner_id: AccountId) -> Self {
        //create a variable of type Self with all the fields initialized. 
        let this = Self {
            owner_id,
            records: LookupMap::new(b"a".to_vec()),
        };

        //return the Contract object
        this
    }

    // Guardar producto
    pub fn set_products(&mut self, address:String, name:String, price:u64, stock:u64) -> Item {
        //validate sender has permition of ROLE_SET_PRODUCT
        let item = Item {
            address : address.to_string(),
            name : name.to_string(),
            price : price,
            stock : stock,
            enabled : true
        };

        self.records.insert(&address, &item);

        item
    }

    // Eliminar producto
    pub fn delete_products(&mut self, address:String) {
        //validate sender has permition of ROLE_DELETE_PRODUCT
       
        // Use env::log to record logs permanently to the blockchain!
        let delete_product = self.records.get(&address);

        self.records.remove(&address);

        env::log(
            json!(delete_product.clone())
            .to_string()
            .as_bytes(),
        );
   }

    // Consultar producto
    pub fn get_products(&self, address:String) -> Option<Item>{
        self.records.get(&address)
   }

}
'''