*GitHub Repository "js13kGames/hades-defence"*

'''--- .eslintrc.json ---
{
  "env": {
    "browser": true,
    "es2021": true,
    "node": true
  },
  "extends": "eslint:recommended",
  "overrides": [
  ],
  "parserOptions": {
    "ecmaVersion": "latest",
    "sourceType": "module"
  },
  "rules": {
    "indent": [
      "error",
      2
    ],
    "linebreak-style": [
      "error",
      "unix"
    ],
    "quotes": [
      "error",
      "single"
    ],
    "semi": [
      "error",
      "always"
    ]
  }
}

'''
'''--- README.md ---
# Hades Defence

Entry for JS13k 2022 contest. Theme: **Death** 

[Play online](https://vilpy.github.io/hades-defence/)

![img/screenshot.png](img/screenshot.png)

You are Hades - greek god of the dead and the king of the underworld. 
Your duty is to build underworld defence to protect yourself from enemies. 
Monsters of the underworld and pesky bandits will try to tackle you. 
Don't be fooled by first waves. Pressure will only increase over time.

Create barricades to block their way, build magic altars which will burn them down, and spawn skeletons who will protect you. Those building can be upgraded to improve their stats.

You are also not worthless and able to throw fireballs.

While not in battle, you would also need to tidy and expand your underworld in order to get more money from arriving souls and boost your mood.
Charon will lead them in his fancy boat.

Adding value to the underworld will increase the money flow, while improving the mood will make you more powerful. 
But be aware that everyone likes personal space, so each arrived soul will increase the hustle and decrease your stats a bit.

## Gameplay
- Character can be controlled with arrow keys. Use mouse for interaction. 
- ðŸ‘‘ Value stat increases the amount of arriving souls and hence money inflow.
- ðŸ’€ Mood stat improves character attack speed and damage
- Both stats are slightly reduced when additional souls arrive

## Near Wallet Integration
You can connect with your **testnet** Near (https://near.org/) wallet in order to buy **_ðŸ’¸âœ¨premium tierâœ¨ðŸ’¸_** and receive more money at the beginning of each new game. This would also unlock fancy rainbow wall and floor tiles.

You can also try to play on other players maps simply by using their Near wallet id since all data is visible in blockchain. Changes in this case won't be saved into other players state and will be available only for you. 

## Arcadians NFT
Arcadians avatars from https://arcadians.io/ can be used to improve aesthetics of your underworld. Simply pick it in build menu, enter ID and enjoy a new painting. Those would be cropped to include only the head tho.

## License
- Code: GPLv3
- Gfx assets: CC BY 4.0

## Credits
- Characters: https://opengameart.org/content/bw-surreal-office-rpg-1-bit-sprites-and-tiles (CC BY 4.0)
  - Sdivi Lee Hall @anactualpokemon
- Items and icons: https://kenney.nl/assets/bit-pack (CC0 1.0)

'''
'''--- contract/build.sh ---
#!/bin/bash
TARGET="${CARGO_TARGET_DIR:-target}"
set -e
cd "`dirname $0`/near-hades-contract"
USER_DIR=$(eval echo ~$user)
RUSTFLAGS="--remap-path-prefix ${USER_DIR}=~ -C link-arg=-s" cargo build --target wasm32-unknown-unknown --release
cp $TARGET/wasm32-unknown-unknown/release/near_hades_contract.wasm ./res/

'''
'''--- contract/deploy.sh ---
#!/bin/bash
near deploy --accountId hades-dev.vilpy.testnet --wasmFile ./near-hades-contract/res/near_hades_contract.wasm

'''
'''--- contract/near-hades-contract/Cargo.toml ---
[package]
name = "near-hades-contract"
version = "0.1.0"
edition = "2021"

[dependencies]
near-sdk = "4.0.0"

[lib]
crate-type = ["cdylib"]

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- contract/near-hades-contract/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LookupMap};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{env, near_bindgen, AccountId, BorshStorageKey, Balance};

const PREMIUM_MIN: Balance = 500000000000000000000000;

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
  Records
}

#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct UserState {
  pub last_saved_map: String,
  pub premium_user: bool
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct NearRawLedger {
  records: LookupMap<AccountId, UserState>,
}

impl Default for NearRawLedger {
  fn default() -> Self {
    Self {
      records: LookupMap::new(StorageKey::Records)
    }
  }
}

#[near_bindgen]
impl NearRawLedger {
  #[payable]
  pub fn new(&mut self) -> UserState {
    let account_id = env::signer_account_id();
    if self.records.get(&account_id).is_some() {
      env::panic_str("Record already created")
    }

    let state = UserState {
      last_saved_map: "".to_string(),
      premium_user: false
    };

    self.records.insert(&account_id, &state);
    state
  }

  #[payable]
  pub fn save_map(&mut self, data: String) -> UserState {
    let account_id = env::signer_account_id();
    let state = self.records.get(&account_id);
    if state.is_none() {
      env::panic_str("Can't save for uninitialized state");
    }

    let unwrapped_state = state.unwrap();

    let state = UserState {
      premium_user: unwrapped_state.premium_user,
      last_saved_map: data
    };

    self.records.insert(&account_id, &state);

    return state;
  }

  #[payable]
  pub fn buy_premium(&mut self) -> UserState {
    let account_id = env::signer_account_id();
    let is_premium = env::attached_deposit() >= PREMIUM_MIN;
    let state = self.records.get(&account_id);
    if state.is_none() {
      env::panic_str("Can't save for uninitialized state");
    }

    let unwrapped_state = state.unwrap();

    let state = UserState {
      premium_user: is_premium,
      last_saved_map: unwrapped_state.last_saved_map
    };

    self.records.insert(&account_id, &state);

    return state;
  }

  pub fn get_state(&self, account_id: AccountId) -> Option<UserState> {
    let state = self.records.get(&account_id);
    return state;
  }
}

'''
'''--- docs/index.html ---
<html><head><meta charset="utf-8"><title>Hades Defence</title><script src="https://js13kgames.com/src/near-api-js.js" type="text/javascript"></script><style>body,html{height:100%;margin:0;padding:0}body{background-color:#262626;font-family:Papyrus,phantasy,sans-serif;display:grid;place-content:center}*{transition:all ease 1s}canvas{image-rendering:pixelated}.renderer{width:1056px;height:640px}</style></head><body><canvas id="game" width="528" height="320" class="renderer"></canvas><script>eval(Function("[M='G]uNWTkEw[}KIn_Tj_xLv|edcBISzsH~QmxJWOtRZuFrsIriBeERipe|hMqEoQSdrw_izanbUmTDIE`PfE_sEupdYQ]BB~AZbTLiivfy{SiAUZiPf}]QQyEZQNU^YJvSnKfqGCNpeuDTrGEJQbM]Y@mpYl|DWcoaCzKcdwo?HX{FQDyhuZxLVTM_z|]JHYztTBQQbHjFr?VLgFGAGnW_N|Se[RGow@kG]nPnW~EpfbdwxW[x}oJsX@EKcynWawUIGtqat~mCbdWSKEiB|I@qr@uzJ_eKYFdkVGoeQWiNmk{RrAO]lrzgutVPsiwuxp}XoxKCgpEkOKj[dYC}F|bUTlcD~cKyI`[qBNoemaCADGmqNwMX`_ejeos@u?sgMMV`TLV}JaVwXjluIU{vKddU~E}Indzwe|IwXKQMRFQP^uEqnb|DdJQJDgR~bbrrgmL~SjV]?M_]Vm{{VolUF]Mp{~{VTzYhGbIAQoBFxuaYLXXwEG[`@eoDzexsIjIJMLYqTR_Lw[e~H?eJGfUo[[rzUx|^Dzhjj~eqzA[yy}khIBnGbuLXQUjKZ{jYrbG}xpkz|KgCclHGUN[GeQazYdLp^QjoZfxGbCXpZ}]KCYngZ^XDw|]Hs_cdutzIqxdfdmgbuD[y]i}b[Ct|bmQnvjO[rmbPV_vheGOBhv^fhj@?wAkoeR?XGHp[SrkXfsBrccbIWBcLiG{YA_muUuM?NI`f{|AzfVAjVM?Xv[op^H[ep{WqZDTQx^~amF}lPhYPi|}DwBVc[}@jvapiy@qI|pKWx^@YgE^bdDVIViMK^oD]AFrUO~J[}qbLIxE|OGo@_r@Fcwt_vTh{ZCUstGp|EOk]Mrtv~Ag_NiVA@sFDz|Af}NZN`umYi`id|rUK|JXRRhl~gqr[XvTfB~Z`h}rzYIdUrbeLetiTwDDIlT]VF{yhQphIHyro]anOrHA]zkom}s`xPTeafcvK}kndslvXVTTtjwF}]CmASwItGWEB^cpfuYbG_bPGxCrjy`hSqEZhgffboofANt[s~ZoiZMjNFji~Ah{~KOdfB_{ysfHt_OJcMVtOdSW}n}^Z?qya`dxwUUh@e|c~wwXz`Q^`vbD|OsQKM^|w@nm^fYD_Sir?RvO~|KV_Cwcp^fOaarVVD|su]Hw]Bftdw]JCW}k{vQICe_NeKBvojQwwySjiqKwQCcKKkZ]VrhMFzS]xvt{U}Iy~P|[XHb[aIxfRVzzfORBy[~XR`ccBcudBBCkDP@PE?LAW|E^hYkZ}oDKCxQjSVCYJTeMZjNn_FrYjVVU{s@DcAnquxeBO?@Yw?FSpnBjMamdZVVFp~OYp{feP_]GL_cjhXQTn`nzmWnYv[p~h_FZu[GTqjrj[cOJfD@CEwq``J]H^@[]tdaWZTiMsfk~NY_y^ZTriiNReZu?xchf{}WCiqKK~RqZWmSXmVrHczdsLB~YfsRAdKCYCAu}TYXqy[jnDE`kSIDHrGxgNRRyu}OHhEiREI@xfldxT]H{]VBuTePgRl~ApyxMj?qXyp@XAGm^d{LkqS@ZxMfHJWq~KJ{ESVgcy@Les_fdJ?MTaZIJ@^Ibt^qz{?FQTXfMJs`cYD|QK}aodc@G@lTHK{YTnQMmY|hec{Y}Pg}]bzoHzwNETOCsoQ`OkIi^MpTB@yXNitZoy_zfQHAVGaCdwK[DdK|yxvEaDo_]rpO@@mOZvuF`Qcff[oJGZaMHQz}J~BPRfgtFx~wwgNYFtRiYElP@MJFHNNytLiTdYyByYI`sUqArsizgGkHvRdCHsB}FUK{]NNRSEd`n[Ea@^ej?X]k}`|f^]]o^tt[KVARUCUlcsVc[b_JpSS_HQ[QnAHGrdJ{?DQGAACxlFlzT_uosrfdG{RyOtIiTPeV^ibxHvbSP[lnjwQNWlPNK}tcf_heiae[^qENSJH|hicfFrn}@tIYRHSy]^pIYOzw{Uai]q`HaBJiPnr}C~SpW^AHNdlSLM@N?lLbk_DHISfhmnhwLO~_eGjrC]^zOLsVVzlr@nAI?LyG~mJqwK^xuOA_rWa|[@b[a[v`cBPQHbAy]I_cm]oW`HWx[BXykRCYEuEM}dF~`KhlcP[@cwzYazEtw^yZaqqz{@ZbvXwrvNFaZ}txqolnI[DDb@H@XLpZy`E|sbuDV~sd`TG[d|QxkXAjUsK_}QiUi~jyLuSJerryq``U?gaPois~jXV?{@rq`BnNJR[`YSlVc}uf?H^EwTC{OOEOiBoEC~e`FXqkGcudrXJGki?TovxV~pXAKvLF`fnk[McXiD|~wewWWbh|tsia^b?BnjUKL}y[TCJEW?n?iCIe]VbqY?pufNLc`@eRgETjv]VeUWiNAPD`Yc^JFoCWQbNVEwjrTPHL@lbra|iOMtlayS^zwMUzGbyvphIQPtnFneRxmmt_lvwEDFSMfx^fe?TY~JkQyp@e|ROCu]P}}mu{vOMk]M`IhtQAR?mMQLkHGj}to?vSu]J`gehoKTnEAw]n~WOSLI[taQd]MF]JPPfoA`AIis_K}PBsAde{LTigZFy`f[GEMtom@cyQAynLXInP`dWb]tZOfm]gvRbWkQewgnuJyFPwX`Im~`UTc]Sxduz}Nsui{ppCGKoc?hah[MwJz_MpXCjyX[YwZW~}mgvKZdNdYmbbqj?ZRNjFKUxUvgU^WtpYeCv^[Hp[]ZZZqMWSjEHd]mIWMOi^yhrButhr`s@A_tgta{LSzR?rYVTfQngQ`JEXt^es^NNX`cTTkiwcVNtfus@mf_}lrsqRV[@oxvz_Rp]F^aZzNC_pEctDVtiem^BflgZ|Z^KJLV^YqxH^BnSv~^?jrqjKkRLspLWKNPK|qYDubu_{U?j}iTnwlsaZusTE@zEH[zj]E@?k^EnsF@M}f?Its||tiPSAqLJcDEGvGZ}fzZtSBVA}Qk}]CysOcemlUt?pc{QeGJEIZQjTfuiuLrJark{z_vV{{nen@uia]JCoAOItlkVjX[VI[bIOVfgunynlczdgg}EmfH[QQ~GXN^I~_DvTKixnO~ULL^j|DBoYnVduIgkyAcAw@~jZUv?KFHGXxEXYUBPB[lNbL?[vUs^ozLK]WONzpqBjoF|A_A?lpTGqrVeEK|xHCeleIUU]@l{qZPCfZ}y{jqe^gCSqmS|~Psg^F@T~ipJaUluDNGvjr?aa|`HVBXTyT@Q[eHwtKG^hLECoxbQk|?{_~}[|`?FzS`pkRiN|AU^?qOEECeQSr_Wm?[^I}aXfOc}hZ~q@{b|pk[CQZIovCrwLXdgxod}Z~iQtrN_ceERsQxlZ^@CMLFuPpuUyMCYM@GN]GB]ul}kgf]BmxogCEKp{NX}XS_GzwoTBu{gM{M_zUoH|Vyc_cCmMpxxTfnWVjkTGzBA_qWSualHmOWsov|uKbdEb}yAe?kHczifc~Wtr`NCIyHoRah^Q?`Drubl^xcP~HNwP@DVd~zzIGl]I|ych|{YvxpLrbkTFGaom?UqvMp`]`[}AZH`UY}s~BNR@t]mZBwF~^lOoaLjy?R^ef|l@YgA^tgDekQGZUqmptBfy`s{D@rsKThV`ltKiJBOSZx}evLA?YhW{v|PQXXwKgPxNSCbW_vIPwCZVp@PaSojsjNRFCKwg@?HsEkoK}DGoIgRkuFgDqxJQdpl@reUvGp`|x]~OCM|q@TqGlW}eM_Wrv]Qco{oXTr{nZvgP~o`GmZ?piHQZjGwmNPiqVxtkt]|mwPxVQqD[PUsqfZRYg[gdWmZG_Cf`nwPYGKNAOexVcvP~uMjXpbbLN`iWUDMBFSt|F|hm?Uri`Nm?[Rkc{ykjDEu{`r{fe`TWgznB`oiuh]q{wQqwaFuTcFihqC``G]oLNTFfeW`ZXllS@dLPTBEwVNAuWaSXBgVIGOx{V{{pE_ti^zgQXe_MWZu~UZ~Oa]cfPVqMbNI`@^?e|ZSubX^yUOFEGiVGLCfXHRhM~fCZLh]`czIcvAse?irJz?DkCINiQdBN[YUEloF[V`xSrrzopzjlgX|?I|JYyFk_Q@nVx[dAl]Kq`zdbvc_T^g?pEtXuwfGT^[vkowloxSvIiy~Xpze_MXEZd[hNCqmeXRcBhmvVJ[hjARlzmMihEmZDxpu[gXiKhjGZ|OqOY~u^rRqkV{l_QSNxWzuREYQgR@~zRUFPC}[HP[_|PsRVIzXdV_rF{jhFFKA`EcuvtlEwSNrLxV{[BHDbOqQFAkt||^?CNWYEN_ZXoyBlM]fGso@?Hw_PMDbr{PgM[{Wp?ql]UCKbIqYiqZPi}[K`R@|DRUO}Bb_MOkznc{pKH?qa]`K`}rxQ?Sddzus^yfek{`vbNRJGI]~pj{WxLAiKKO^VsfYIVcCntwowYR@jymJNMJcQQ}a{ojgDnyWzfLYYiY{~?LowuVd}tMx[lL|UkAGyVyXkqKlL[dMuu}hvttti`^l`KBUdXqsUkDNtJ{ZJgNPj{ppmt?VyyWAyJNNZASqbwtQKE^cv}tx{[RJhneJbFuda|^alf_b_CF^hlo^pvcIiuZM^GMLlq`ekCF^RkeFdizzDDfe[t{bz`_?tN_ktgxZB`qFFjYx`]Pq~j}OzvUP|bxua{~`ZsKkQKCuMo`EUkfrOcFo{idMg_vPjLKH]Kqe{On_rthW]R^mjGLJzthGy{KklImRbULKY^eKVM__dJb~jxmTn}ae]rADmzYOvWXtvx@fbpJIe^~ozgENSW^cDgbTYpct`mOo_R@O`rh@SrvnlMgSmmwsM[]YlB{PXGA?BAx[i`KFUXTwB@WVhej]}HRYR[iSJWW{kq_Ri~_VhrARtbozDhuUBuX|beXqkCrUadKRdZGQl[yJb^b}CEnLzVz{Xph@dMyPIIvXVUjitYEHjojVPz{RwScTMC}TxgSPKpkYcQ{qJUyDnQ@TNxS]ErNKz^Cqn~YjRhiJFx@UULZdaOhpbJ]C~RFW`hslAsLHBCqjSDnrT?n[HjUE|hY][~lBkszVmwY]fylUBhhk_GOv?CSuP|`uk@JHcq[yQ~@not]GYieXaPi@ko]]vOyw|qRuVdwTJYzLPQXHw_oaY@R@U}AfPnxQ?k^hZnN@^Kye}gFNHZApIGnzyXvKIM^[pJlQx`SEXbWgfaScCgJz[MzwkkDcEndHsJKmTR^xKdh`DmDirteqYwX~B|MY?TxxUWhKJyPo]PjwiwQi}bqGioExahNzbWXbzhl_}Qigv@oLG^Ne{^cyVkoi?ejCnZtQ@j@o]aBKiUbltFWqFy`veXroXk?eeTrgbts_{}TElMjpA?Z{`dWSk__VHs`u]WnOQ{uiZZzZDKXUukK_CEwOCGVXPn~_GGpj^WFprbqXfXWDRIEPND`llwvm^lbwPSW}?Clapwxb]_TtmLKqZce}TWCURSNP|SHqZdgRoESqGpXcLvUo^gsz^aFsuh}I]?`qGLd`iRDHSV~i_}NQFPTwXAMBPiyEH~nP{DaK}?QAECdB_{?~gKwKi[BMv@ycyh}?WEjHn[B{BoGYr^xMiDVmrEhD~WhjJrdqJwKigajaqAhuYpAcRNUc~SGGmU^UvHFbiLbIxJUPHAOqQWzpWXHedPV_Eu{jBklVeV]uWkBNXnCV}xklTUuAB`eJSEQZKr{ocE{]^PyXg{gGC]zSQ_og|ssuiL{zHR{Ggc?oz~RohTqsTHzUbDbvELVkVB{PQ?Tmds}PMUYAs~l]iJicwlP_|Owxh`QZ_EBY]_h{irbKdd|LISxGFlho{sy@^Y|vWAbfNzRtHIC@GSKbkrlOZAX?igQtScCSouv`XcmIsZ@QbHGi{Hlo[spPIpB[d{xGQFu|Xt}uYK__KcFkSvmY^|lFEvJo]HtKHhHxjAe}WLeynJvfAbwYSiLZQOv^H@izws][JNavysxsxZJoO|NvZDDQm?zEnsFCWbLkqsJ?FQUU`x?nQnc?x}^RlKiYsBz{IMh[Z^HwVrIMgkNWK`gveSE?hrGj{fBdS[jldxRUkI{Yz`QapUIG_|bO?IL{SVQooGFMbR|pA{detjTZyNt^BTfr_gUOBxGfRg^CmRLAA_jLS}SIwdJTuDYOmpYd@jiPWl^xwvUtKBsQ?jnYzKJuYPPtQrGOJeshif[I`WG}FruWWHnrBIgzz{lAdtebjSMXUYTQ_qsnmEGUjP~ErK]rwou^ChDDa[pMrob``z}jNEQPSJGwnRBSnq]MS_CPGa~QV`ci_RrLncNU[|B`rn{gU|ruqHds{hXpZUYuVg[`VdblLk~Ii@gtTBWIY|v^YJZIFvAqAGJBlWixVvQX{MumE[LipUcYCE`zURng]|]wxlSC|s_{qFFbvJjgCJZCXsdUX`l[HUgokmGGQm@ftOUPuQ^cHX_HrPFCbo_@]krK^}||BkLIFLkkUqp_juUuvBaegFrD^FhnG`oU__RQ^?D_TzjgC^o{LRuorTHOoOl_c?WhLuw_{fjXpZF|{yzv]}CzUT{wSDvDMSNTA{Kxo?KfQuWh?SkyJOHgEuGDn^I}ut{qffXeAeO@idufcWAl|uWXD}x^ejiL_fLL?A`]kdrFwrXSsoHtqbXjAqOsALCIU@|fK`pz^S@Fq^aXCbbcEePIhsVmTvkWduzHRCm{[rN~[VLEblpCE[b|BF?fh~U}_Y|YnIEaWifN`Mpubs?kRd^_vB?lkHJNF}koCqAQQ[z|lSWGLxRJJqIEC}gVy{zfqLqX}?iMOwE`KAp?qgOH^bMvTJ[|w`zbminQixhKOxWJugchXz?Jm{PEgJmDVf@a|FR|_Xh]COdvxFBaYGNhhwfOscv{`OwOxub_DcliuPpuBOmIKqOy`wt[FW@qrJCAfIUy@lZ{YjSm~AHkYb~lB[|JX{eOuXQROCYzdReFcXB?inQPOvzcFUMCT^wMLQ^TEswxP_R`peyfuklR_kzWnR^uQ{bpN`?W|@ZlsVYRzi|z`rWOrJH`sYgea{XVElb_t^}mwCqi[LuBDy_R}f{mpxgPlSIGJIxNZ@yb?@qGIxsDgg_}[~hRkbqYa`mcgfYf^HRw|ZUhYyx~MmBg~cpM}Mplzq[syX?w|veu^CoysxPN_i[yWbhOlxrLExOQwlKP_Tjh?BPP_oTl]}rVJvFUqIH^sQTmO|JUrZUQwwbXuBw@JZFozBM?hRTO}CudUYUmkcJ_Avhi{@dOeFstd?bmsR?UCS^YIV_KAtMF`B@GyNE}vzAXERohImapTuQaSM?PESW|O~_rn{OWNsLOK|m?hCuh|V_}huMbr{goJy[n~asuiL`oCpzrL?Y~CtuBw@^bd}RSDtfh[v}Gn_NVEnG}wCoaxTsLTxwgnz^vliBChV[zcU{DADXgeuZkkzJzfZU|]auJaa{RahAKPoJHM}nuGATC[rvz}SZj[^kt^w^wg|wmzqCnDZRgI~dF|wK`OQjtyMZfxvX{nh]xy}Whokc_q@GZxOePw]W~DAOP_EPCbGSBHuKMh[d^ZC_[e`GBp~JQ}]Z_DaQ[v_Buincq]PQOOMpy}feGVU`o@Jbk_l}xYPlbkuXzoxSa|iTG}AwcOMq{?@XcrTJw}EyKaPLmQApU_[IWFXnE_sSm^siJVL?jNk}fGSx{j_P_qa@~Dv`~b`CvmDRAIFyZ[SbXZ~qMZwl]PYqFNWhChU~dFGQu?vYSWDQb~w?Ub`EBRVQCBEWTEFBfAq?PvbuP`dEb}Fa]wLRfWS?hbjhrJbezh`Y{JGJ`Ah@yp[UOWAHcmDPYGJs_kqLJBeAyqdqna@Vo`RZAjz]|xsclN?[FFz_z?FCsPeWaqiYVosjWOt]_p?DAmLb]Z|RAN^FAm^BsBRmQV}ixScPdlEwrmuvv[?FCKMVXfXBfwzNC~bA[J[xl[hUPhJsjbbJQSMWuEw|nFdSqPZGHflRp[GuCtPefq`LwlNPME?izIaggUle`_QGFTweftwqPmRcZ?{[Hqzinxhl`_yWGmNIuM@FStV^kWpzu}KnWSz]XB`PmZg}F_iVPzUJHYp]tWA{K{T]dIioMG_MZQrKHftS{v{~BRgJWf|@gpXJlJUVHP]t?E^qLEIvX}x{i@oRGYl|`Dkla|gDU[rBmv_ZE|qnbfYhMy|O@Jo]jdkG?Gwozgey|zXyoWgqpkU@T}noz~]DX^m?|dw_CgictRcGhahfminpF[Ex]|uGpHnoUgrrtpFLKSLaUkU^wxAvczFbHJ]xI{UX^Wb_auLMAj]zhpwkXVLyS]{NKdUVpA?rvn]zD{jtjEmYNqraCpiLDdeQ{{ga~dmrMHIYw[EBFkWNsmMFIoLDhU?uXkaoniZ{YPRVMmEukK~~wbBrlMZquuE_NrKyJ^KTjxcAsLxccZvp}UmF]oNMjzQzqUctMy[NgeR?TbcDPy}X[]GTUItRrXlFKANhOrhU{IxsPa~^@YkRM^YcLaKsSF^M_^DckC]PtaLByAt|ieM}q[?OdOG[ODsv}WSqyEltHI{Q_GyJ@KixFaMk_UzLPa`BAy{SWZqU_A[brYNpMmmVgwIKa|~@[jmR?AZjS~fDlWk]RCh@Q^~g^nBM][qdL?gQ`vE{R`FthbGwonVrdgFo]XdwFkNcIGkVoFqiuxZr~SKs}nvPRDDYosJ@VY?cJRL{Sd|GgthzI@DbqUY~hr]CTgrGTEnFbRt}JprK}||Ov_M~UBhLGZssd?khZYJIoKrnpWpi_{H^TOfzrOM}SibcAxPvXWZHp{^sc?_gr}AOuvUffxg[yf^EbtA^ni@gC`zrCRhKP]Ht`cwxrA[aMZoKwdH@@^nYRGjVCqxtrC~neh?kC_dxPJu_knVt}hHMIx?sLSmGsfeOs@t{U`NkAapc]HbjmdiC_NKZkZTahEPRuqzxXEXJ_hJHxyugb~KuaO_ACxUTSVXEz]pBuMPucyaPhd`bWkPIs}~MkgXVPg@^|RxGPQK{?XmM]}MtPLZC^wBSzRBA{DZR^|OheyNxek~PfYpITynlwYHsNnzZUs}rwVjvZdloS[JPu_r`_jJA{tJCCCnQRFjxH|XkcUmzmCMRKwPo@XBMJhAyZI|eiJGF^TGJk~JBZrdAdmzmHmlgLL@{WMggVjUJz|]^vSwicaXUWISzIjODrav|YxFRDK[^JuW|JsTA`i|VhdSzGqCUxCSE~d`OaVH[mcTl~EckNt{UulCYINM{F|s_Z@scqMwNqWYZmPhb|ikaaEzvGeOyUbPXzgTQHnWrpybyCUhAkr{pe}H{bSZhgZdVWREWr]@Gi?LVzMdiYruJHzp`X^mRu`uy_XF_jkvacYD`RBEa`KPgO|knw{}_OLrDREcIrmAAtR{Ou[Lbz|Ujbf~]u^CdNVg_^@QtfGtJdneAlj`AK_sgw}YRlowfaHT?~tW_@@WqrZp?TbH}LedeifAcDCyNLjLspmNbAHhtiAAZii{sJyeDL[SXS]bIGqnWxxFrVoc~ZQxz}pmfphhmTMB?xSYaRxcUbGfWHxih^_GGib?Fv|z]`eeYnIaffYrtAWRGKZFcI|RMdlMCDzJivOZdWxn~Hu[KbkaiKfJDPqh{s{HNgxYXD~[Az}jmHLebCrvrwiE|P{bFpN{WDQ]}DK}W|}ur]tSPJTXqUaNaFSZ`Ht@zSizgsLaIlHzeJBk?nvQjK`v{dDTqnYz`Jmkz_{WDdBELfyPKopsCTrxqgxo_zfa^bUu]UX{qxMoUlmYXvzIMKoob|B^vtjMD]uHbINMXa[mx~UuIKAwYq~[JPQly|R?svMCHF[KKeLJ|d]t~qoCjybKbd}voNLeSaCwxuO[cMZibOrFA^bED]SPu[EoX{aMkpOuWhqdeMn^G`aQATqkxj~@`jOFHBwiLiARDG^hl|UYxOp~_XGEh[AgBE^MzEW|UTUMxfWy{nJQQR]Ox`Au`]XwemMWgAH{@tqeZIxEUB]ZIV`E?H_uuEwcJ}AbPZlm}mpE`[sCOB^lLAuRE[GaPTte`sMBfQsF]}Y~vQTO_cZYBDO|M{Xxp@QE^vZ_rpfxvGDPij?zMzFW}kYZRgco_FkEWbfgez}uwnOSZD`eeXbXPmbOPQcB{oqcQD^|zwJA^UPzl`hZ~Rt}F_x[dE``^NLyaI?M`SFqZ_RdUZobmPoDcU?~TH_aZWmvemD`xG}p?HKz?[D}Dq`ielzSldDTq_QYWLgnzYQF{JUVHW{_ld|lQmLjRzgOwLhDBT]v^|aT~GqXAhm@YklimXfJ_x``RJx[cNyKX@m@oLPRsFLk@DqpZklkqgpmb@NVY{zk?YjHjJXK`_iBiMd[hJPs`vsTLZjgmxUojNBG@ptfP@@kDVNXZ@JcwmmWOktY^p}SaK^JK{Fv}AijLmEh}xfu@vKaC@?PwZSRP]QMMGyuQmB~t?AqufquXt_d~}MHRPZn[MWiqvfZR`rLcBT]jWZgl_{F{HWWpZVxNg]kohJZJJALJlSF[?sjBrlFDokPfVlfoA]mPTWNLBNitztaa|qqgnbezscR?rFun?A`^r?lNWKGYogoknJAz~GimhU`?zW^NkkgpGJYyTbDwc_q~T^[QAGcYlnEpCIH}ZN|eFuDdCYgm{a?mEzm|Q|McdZjCcvo]|PkUTpRZ?EkQI`SNOkODF]YZnZcq{AOO_inNFaZml~uCJVI_DrLPBTFio]V]uiNEK_zXhqRISih]kkq[BiNh^uFCN]nKUcCuMVhJw|oJRbNWexolN]qK]f{LgB|oYJ@ksjiGPCITW]aUMBWvPutN@~hlArOlGgA~lWSHxrPN{iJthy?cTGu]{v`NPmcsSyETZeb~]AwBt[QjZWeyGJu}Vhl|}wKp|x|TsabZnoaq}_j^JeR~BrvswFf}QgS~YAJE|v?zrnjek|EMrRKHqtwR^|fTtxC|]JHmlT`GDOP`YjRl}]f^?UnN_?iR~fD^UG]oAB^BQ`YTZ^oYdZVCfUkTTHTwqdl]msCMAY?FA?XrmKISgMG{hui{K]xZk?TTY?PuKQGkW}YHeZjDPJp}yWQQxYWYUxyuy`O~zmksRNv[NNaIie{oWcYAfAc@}`wqOKgltKjiCabzhaXmTygy@bdJyIOSSmkJcii}o}gq?Cur`pyVX~e^|CTVqq}MjugI~B^l?N]v@}nGxHb_Qoj~OQCmNyQIlJjDbStChfNI|Z^GKuGsYcRGx`WsBNSVpjIHW?swO|Dd[idgVokgMJRGfPPJuHdO]rVkSHIJTeosIAlQQc{gaZc}qzNSIqHdXqGzGIRs_j^~weQFS?wI@bQF?QO}sfWB?uKWTP~ngspzcXlMkCvuwPztnFadFNeYcnqQHZ@TRKPyDzCZNtFdKtMW`szqMH[bW?vK{]Wka{FvTNSYoDFq@C|yoEO}{tx|n]r}YMlhHN{baqVtzId~_ntLG{gk^SrS_]UP~ivRfPG^bPYp]UpEthloiLEv@vbF_sXIYOxLSiGurOljO`FLch`gd{CUnZj|VXfUGb]OHM@EdZKA^}HMFSGYiQzNLzY|baZqCgGbDBoHNGpvt_dGU|Bd@uVJbUNRqRRajcxxzQ^HoeCgWPOx`R`[fD^n]aIjFE@OLtoVPKfHx{UwzinP}pswBKlnLtAFTUBS]QHyWjy^lO_ZEQigAXhhaPDviu[uIXXsaA^otA|Z}PaGl`XCKxH@qB`Qs{EfsxCDItSsCGvQx{ukOtIC][s}L@mqxlykXQjWcT`FOVIGby?BUPxJyyHUDj?VZ[DUHOrwaji^vxp[^]Z^mxrPQtoIjwYUKNrOiwbdx]hI`CGyQGEDkH]RixUNUPanDLGCajGSsc@ATJhVpzrxBFVgB?DaRQM`]@A?|KBKrH[UHyhzp_hWrZXAD?^Oqp?aFs`T{Pri@`_IsXncxZTsKPDWRdPxUXr|emh?B}CktamybsG~dSe~^{DXJtwJLvVzg??JXrSF|PswwFJXZBJfWVgOHMp[FhHJoFWsh~?EZ~[X^{[{@L}yq}`fQv_{domH{yX`xwB_scuAtQ?hsnO^qd?`wZ^_QEx}|S^p[rk?mKjRC|B|hRoZ@k}DBqGFjG~CDLZwY^qOTgPdhXgNQftRGkRMO?gxbpI{RUZTJW|Npr_mIthZdd_~]Fqfr_nAn?W|PNZD~fMMzuWCbc~w_sk|[uOd|zPiR`g^TArEQQog_umljtibJHG|so{IG[hdu]MGcidsMEctxa@}H]uOOmF^X{Eyq]U|ajyfukYbUvxZeb}PgBQgvgE@CnqWZ~hgzeAETKH@EGC`{VBy^cy^z[}[c@s_V{fsE?ycHpc}AfkxzKChGGs?BUr^gl@HiwH]tLltykBzIu@TbUzZLwGPgZs?[cmWwlvP}NlhXW]Traqyu]]{u[tOeQQvMFCjwrBOmv|SrfrvJ@phVmUWb|R?egOZvV}LE]LAgh_iT[bukDTHsfi^^cMeCwsN]KoHgje]YWYz~|vxNh@QxLOA{ZoHDZQq~e^KcjDdAYz^i}xfue]wdUxYleVF^qXCQKrgLumq{EZIgrA@?`bJlnErKC?lI^SsY@mi~}oGHpOddlY}a{~bl|zhrVe^LogWhgSDWS@^@f]ld_cXKHAYUI[wdMvN[mXmjpAX[whXNKZl~e~oGifiWMI~}F]cUxOpUJOmyw}~N?nZwMc?FsooZ`gzcCLOPwK|t~XteD{]MeBBt[}qmu}enQXwPgA`|Js}wBK?vXNpxWCWMHTUZGLz_??e{~?sp[_qV?BDOx_yfEVz~hYVeDzjUl}wKVZfj@qTYvtiRc`L^BihSKhAnWOmYGQ_{oaaMbq~z}meLB?]?Wa~?mnrOQXZNTbus^usjr{dhTAwomdGBy@Cm}yvPkh~q[pJp[ye]Lu^]Wy]rJnRXqqXINU@izdkopLaVa`Emn`fVgmGXQyhgJcBAbGV|MR]}Wfwt}BSM~iVMOqRcIQdnQRqqKD^HISpHD}QbVOCZVPP[dsVzJ]J^d[{k_@QoHmUadE^Tf}e]ooVKfAtLifte^ED@Y{klgStAwzQbFuV^`PP_ErOX_QYEWNoxGqe]fymnv}MZ~H~KIZnJvaBBlxQzkifZs~y~^bIezzaGsJg{?fOh}zfGZnVHBySbUqeEnNYBonhBZkwklTUAvMhnn]Y~VDp`Y}R{QxhrKEZ}H[Ab`JVdFv}YDX@OVb``fnw`pwOYaI[OHDluSp^DQ}aW^fzoJApYEd`Khk_Uq?_H{sA?|[njkD]]fZlYSGXVmbgFv{^GqcW`{P{BIi}hdkQOMqQS`[ePYl]DImujGba}XLxrZVICrmxNiNZ?OQLiNZfPR]IVCgEmnT@YoQEVBXe{FMx?AKPagl^@qyE_xQUP^W^fvpt|J`@CK{UEz@vO[XKynJeDntuB~LQ|HyeTeoeP[qv~LyG~c|wDkrfJ^^AG~rFZ}SoLpqStOGpheiqybSEBifq~LM|RSYhFpMUkEr}skTN@uEIt^?{DQeu@oO~]VhSFY]OrHmPz`uIiRKIxSCYdSGgyYs@ZAf^kSO][m{j_Ga?R{?[J]sMkYjoqYKABcyMo?}ARsp@DHcT}Yurx^l|k^BbPOSZqsXIZ]UaZKI@OpfhrZSSG~FwrYaSLSukQ]V|bfGu_~X~fVjNMwMVdrMXFNAUWTbJd_jJIPVVRfnuMy?jwJgjywEGATCP[rTgZdhjN}iwiINYZq}K~QNPFKRphV^vvGtGOvFtcn?}PHid^L}m]dqZgWKgJVOP[i}oyYqT[Uvf[dfEkfPeFMkJHqr@[@c~u?HZLDA}zKspVTcc[ZRo]rwWaXbXYvs]_j@Lp}HTTOgFubTqNQ@OgO}jbLkisCPm^CAlpC~VbLVWwvQN_zRXVIUVonOba^astnGCxBrfiKOtMnoiLcw[?eYy{]@|II^uwKtYj~hRky@spHf}{E?|SOl{Vm_tJATOFjJabXaSPEaHSDWwwYEywWhasWvEGwG[wa@DpUZCOeQtejUtSR]C}`lhGaGTMC]PpT@Z`'",...']charCodeAtUinyxpf',"for(;e<31048;c[e++]=p-=128,A=A?p-A&&A:(p==34|p==96)&&p)for(p=1;p<128;y=f.map((n,x)=>(U=r[n]*2+1,U=Math.log(U/(h-U)),t-=a[x]*U,U/1250)),t=~-h/(1+Math.exp(t))|1,i=o%h<t,o=o%h+(i?t:h-t)*(o>>15)-!i*t,f.map((n,x)=>(U=r[n]+=(i*h/2-r[n]<<15)/((C[n]+=C[n]<4)+1/20)>>15,a[x]+=y[x]*(i-t/h))),p=p*2+i)for(f='010202103203210431053106420652065410862'.split(t=0).map((n,x)=>(U=0,[...n].map((n,x)=>(U=U*997+(c[e-n]|0)|0)),h*128-1&U*997+p+!!A*129)*12+x);o<h*128;o=o*64|M.charCodeAt(d++)&63);for(C=String.fromCharCode(...c);r=/[\0-	-@]/.exec(C);)with(C.split(r))C=join(shift());return C")([],[],1<<15,[0,0,0,0,0,0,0,0,0,0,0,0],new Uint16Array(51e6).fill(1<<13),new Uint8Array(51e6),0,0,0,0))</script></body></html>
'''
'''--- gulpfile.js ---
const gulp = require('gulp');
const fs = require('fs');
const child_process = require('child_process');
const compiler = require('google-closure-compiler').gulp();
const zip = require('gulp-zip');
const replace = require('gulp-replace');
const htmlmin = require('gulp-htmlmin');
const cleanCSS = require('gulp-clean-css');
const checkFilesize = require('gulp-check-filesize');
const {Packer} = require('roadroller');
const glob = require('glob');
const {createCanvas, loadImage} = require('canvas');
const {execSync} = require('child_process');

function init(cb) {
  if (!fs.existsSync('./tmp/gfx')) {
    fs.mkdirSync('./tmp/gfx');
  }
  cb();
}

function writeJS(data) {
  const js = `
/**
 * @type {Array<{w: number, x: number, h: number, y: number, n: string}>}
 */
export const spriteData = ${data};
  `;
  fs.writeFileSync('./src/generated/sprite-data.js', js);
}

async function packImages(cb) {
  const input = glob.sync('./gfx/**/*.png');
  const size = Math.ceil(Math.sqrt(input.length));
  const data = [];

  const images = input.map((path, index) => new Promise((res) => {
    loadImage(path).then((img) => {
      const name = path.replace('./gfx/', '').replaceAll('/', '-').replace('.png', '');
      const x = (index % size) * 17;
      const y = Math.floor(index / size) * 17;
      data.push({n: name, x, y});
      res({
        img, x, y
      });
    });
  }));

  const imgData = await Promise.all(images);
  const canvas = createCanvas(size * 17, size * 17);
  const ctx = canvas.getContext('2d');
  imgData.forEach((entry) => {
    ctx.drawImage(entry.img, entry.x, entry.y, 16, 16);
  });

  writeJS(JSON.stringify(data));
  const out = fs.createWriteStream('./tmp/hades.png');
  const stream = canvas.createPNGStream();
  stream.pipe(out);
  out.on('finish', () => {
    execSync('cwebp ./tmp/hades.png -lossless -m 6 -q 100 -o ./docs/hades.webp');
    cb();
  });
}

function optimize() {
  return gulp.src(['./src/js/**/*.js', './src/generated/*.js'], {base: './'})
    .pipe(compiler({
      compilation_level: 'ADVANCED',
      //compilation_level: 'SIMPLE',
      warning_level: 'VERBOSE',
      language_in: 'ECMASCRIPT_NEXT',
      language_out: 'ECMASCRIPT_2020',
      js_output_file: 'main.js',
      rewrite_polyfills: 'false',
      module_resolution: 'NODE'
    }, {
      platform: ['native', 'javascript']
    }))
    .pipe(gulp.dest('tmp/'));
}

async function roadroll(cb) {
  if (!process.env.USE_RR) {
    const jsFile = fs.readFileSync('./tmp/main.js');
    fs.writeFileSync('./tmp/main.rr.js', jsFile);
    cb();
    return;
  }

  const jsFile = fs.readFileSync('./tmp/main.js');
  const inputs = [
    {
      data: jsFile.toString(),
      type: 'js',
      action: 'eval',
    },
  ];

  const options = {
    optimize: 2
  };
  const packer = new Packer(inputs, options);
  await packer.optimize();
  const {firstLine, secondLine} = packer.makeDecoder();
  fs.writeFileSync('./tmp/main.rr.js', firstLine + secondLine);

  cb();
}

function compileCSS() {
  return gulp.src('src/main.css')
    .pipe(cleanCSS())
    .pipe(gulp.dest('tmp/'));
}

function ship() {
  return gulp.src(['src/index.html'])
    .pipe(replace('<style/>', `<style>${fs.readFileSync('./tmp/main.css')}</style>`))
    .pipe(replace('<script/>', `<script>${fs.readFileSync('./tmp/main.rr.js')}</script>`))
    .pipe(htmlmin({collapseWhitespace: true}))
    .pipe(gulp.dest('docs'));
}

function zipDocs() {
  return gulp.src('docs/**/*.*')
    .pipe(zip('submission.zip'))
    .pipe(gulp.dest('./'));
}

function advzip(cb) {
  child_process.exec('advzip -4 -z submission.zip', (error) => {
    if (error) {
      console.error(`exec error: ${error}`);
      return;
    }

    cb();
  });
}

function checkZip() {
  return gulp.src('submission.zip')
    .pipe(checkFilesize({
      fileSizeLimit: 13312 // 13312 === 13kb
    }));
}

const baseFullBuild = gulp.series(
  init,
  packImages,
  gulp.parallel(compileCSS, optimize),
  roadroll,
  ship
);

function watch() {
  gulp.watch('src/js/**/*.js', {ignoreInitial: true}, baseFullBuild);
  gulp.watch('src/**/*.css', {ignoreInitial: true}, baseFullBuild);
  gulp.watch('src/**/*.html', {ignoreInitial: true}, baseFullBuild);
}

exports.watch = gulp.series(baseFullBuild, watch);

exports.default = gulp.series(
  baseFullBuild,
  zipDocs,
  advzip,
  checkZip
);

'''
'''--- package.json ---
{
  "name": "hades-defence",
  "version": "1.0.0",
  "private": true,
  "description": "JS13k 2022 entry",
  "scripts": {
    "dist": "NODE_ENV=production USE_RR=1 gulp",
    "lint": "eslint ./src",
    "lint:fix": "eslint --fix ./src",
    "serve": "http-server -a 127.0.0.1 ./docs/",
    "start": "gulp watch"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/ViLPy/hades-defence.git"
  },
  "author": "Vitalii Liapin",
  "license": "GPL-3.0",
  "bugs": {
    "url": "https://github.com/ViLPy/hades-defence/issues"
  },
  "devDependencies": {
    "eslint": "8.22.0",
    "glob": "8.0.3",
    "google-closure-compiler": "20220803.0.0",
    "gulp": "4.0.2",
    "gulp-check-filesize": "2.0.1",
    "gulp-clean-css": "4.3.0",
    "gulp-htmlmin": "5.0.1",
    "gulp-replace": "1.1.3",
    "gulp-zip": "5.1.0",
    "http-server": "14.1.1"
  },
  "dependencies": {
    "canvas": "2.9.3",
    "roadroller": "2.1.0"
  }
}

'''
'''--- src/generated/sprite-data.js ---

/**
 * @type {Array<{w: number, x: number, h: number, y: number, n: string}>}
 */
export const spriteData = [{"n":"bld","x":0,"y":0},{"n":"brd3","x":17,"y":0},{"n":"brd4","x":34,"y":0},{"n":"brick","x":51,"y":0},{"n":"ch-i0","x":68,"y":0},{"n":"ch-i1","x":85,"y":0},{"n":"crn1","x":102,"y":0},{"n":"crn4","x":119,"y":0},{"n":"crown","x":0,"y":17},{"n":"expnd","x":17,"y":17},{"n":"flame-i0","x":34,"y":17},{"n":"flame-i1","x":51,"y":17},{"n":"flame-i2","x":68,"y":17},{"n":"flame-i3","x":85,"y":17},{"n":"flame-i4","x":102,"y":17},{"n":"flame-i5","x":119,"y":17},{"n":"flr-i0","x":0,"y":34},{"n":"flr-i1","x":17,"y":34},{"n":"flr-i2","x":34,"y":34},{"n":"flr-i3","x":51,"y":34},{"n":"gate","x":68,"y":34},{"n":"grad","x":85,"y":34},{"n":"hds-i0","x":102,"y":34},{"n":"hds-i1","x":119,"y":34},{"n":"hds-i2","x":0,"y":51},{"n":"hp","x":17,"y":51},{"n":"hpup","x":34,"y":51},{"n":"hr-i0","x":51,"y":51},{"n":"hr-i1","x":68,"y":51},{"n":"hr-i2","x":85,"y":51},{"n":"light-i0","x":102,"y":51},{"n":"light-i1","x":119,"y":51},{"n":"light-i2","x":0,"y":68},{"n":"lmp","x":17,"y":68},{"n":"m-i0","x":34,"y":68},{"n":"m-i1","x":51,"y":68},{"n":"m-i2","x":68,"y":68},{"n":"menu","x":85,"y":68},{"n":"money","x":102,"y":68},{"n":"ob-i0","x":119,"y":68},{"n":"ob-i1","x":0,"y":85},{"n":"ob-i2","x":17,"y":85},{"n":"pnt","x":34,"y":85},{"n":"sk-i0","x":51,"y":85},{"n":"sk-i1","x":68,"y":85},{"n":"sk-i2","x":85,"y":85},{"n":"skull","x":102,"y":85},{"n":"soul","x":119,"y":85},{"n":"stones","x":0,"y":102},{"n":"up","x":17,"y":102},{"n":"water","x":34,"y":102},{"n":"wl-i0","x":51,"y":102},{"n":"wl-i1","x":68,"y":102},{"n":"wl-i2","x":85,"y":102},{"n":"wl-i3","x":102,"y":102}];
  
'''
'''--- src/index.html ---
<html>
<head>
  <meta charset="utf-8">
  <title>Hades Defence</title>
  <script src="https://js13kgames.com/src/near-api-js.js" type="text/javascript"></script>
  <style/>
</head>
<body>
<canvas id="game" width="528" height="320" class="renderer"></canvas>
<script/>
</body>
</html>

'''
'''--- src/js/bg.js ---
import {drawImage, width, height, canvasCtx} from './canvas';

export function renderBg() {
  canvasCtx.fillStyle = 'rgb(56,56,56)';
  canvasCtx.fillRect(0, 0, width, height);

  drawBorder(0, 0, 32, 19, 'brd1-b-');
}

export function drawBorder(x, y, w, h, prefix) {
  drawImage(prefix + 'i0', x, y);
  for (let i = 0; i < (w - 1); i++) {
    drawImage(prefix + 'i1', x + (i + 1) * 16, y);
  }
  drawImage(prefix + 'i2', x + 16 * w, y);

  for (let i = 0; i < (h - 1); i++) {
    drawImage(prefix + 'i3', x, y + (i + 1) * 16);
    drawImage(prefix + 'i5', x + 16 * w, y + (i + 1) * 16);
  }

  drawImage(prefix + 'i6', x, y + 16 * h);
  for (let i = 0; i < (w - 1); i++) {
    drawImage(prefix + 'i7', x + (i + 1) * 16, y + 16 * h);
  }
  drawImage(prefix + 'i8', x + 16 * w, y + 16 * h);
}

'''
'''--- src/js/button.js ---
import {canvasCtx, drawText} from './canvas';
import {drawBorder} from './bg';
import {mx, my, isPressed} from './input';
import {Sprite} from './sprite';
import {playClick} from './sound';

export class UITextButton {
  constructor(text, x, y, width, onClick) {
    this.text = text;
    this.x = x;
    this.y = y;
    this.width = width;
    this.isPressedOver = false;
    this.onClick = onClick;
  }

  isMouseOver() {
    const x = this.x - 16 * this.width / 2;
    const y = this.y - 16;
    const w = this.width * 16;
    const h = 2 * 16;

    return (mx > x && mx < x + w && my > y && my < y + h);
  }

  render() {
    const isOver = this.isMouseOver();
    if (isOver) {
      if (isPressed && !this.isPressedOver) {
        playClick();
        this.isPressedOver = true;
      }
      if (!isPressed && this.isPressedOver) {
        this.isPressedOver = false;
        this.onClick();
      }
    } else {
      this.isPressedOver = false;
    }

    drawBorder(
      this.x - 16 * this.width / 2 - 8,
      this.y - 16 * 1.5,
      this.width, 2,
      (isOver) ? 'brd2-p-' : 'brd2-b-'
    );
    drawText(this.text, this.x, this.y, 17, '#f0f0f0');
  }
}

export class UISpriteButton {
  constructor(text, sprite, x, y, width, onClick) {
    this.text = text;
    this.spr = new Sprite([sprite], x - 8, y - 13);
    this.x = x;
    this.y = y;
    this.width = width;
    this.isPressedOver = false;
    this.onClick = onClick;
  }

  isMouseOver() {
    const x = this.x - 16 * this.width / 2;
    const y = this.y - 16;
    const w = this.width * 16;
    const h = 2 * 16;

    return (mx > x && mx < x + w && my > y && my < y + h);
  }

  render(isForceOver) {
    const isOver = this.isMouseOver();
    if (isOver) {
      if (isPressed && !this.isPressedOver) {
        playClick();
        this.isPressedOver = true;
      }
      if (!isPressed && this.isPressedOver) {
        this.isPressedOver = false;
        this.onClick();
      }
    } else {
      this.isPressedOver = false;
    }

    canvasCtx.strokeStyle = (isOver || isForceOver) ? '#f00000' : '#f0f0f0';
    canvasCtx.beginPath();
    canvasCtx.rect(this.x - 16 * this.width / 2, this.y - 16, this.width * 16, 2 * 16);
    canvasCtx.stroke();

    this.spr.render(0);
    drawText(this.text, this.x, this.y + 8, 10, '#f0f0f0', true, 'monospace');
  }
}

'''
'''--- src/js/canvas.js ---
import {appResourceLoader} from './resources';

export const canvas = document.getElementById('game');
export const width = canvas.width;
export const height = canvas.height;

/** @type {CanvasRenderingContext2D} */
export const canvasCtx = canvas.getContext('2d');
canvasCtx.imageSmoothingEnabled = false;

export function drawImage(name, x, y, flipX = false, flipY = false, alpha = 1) {
  const spr = appResourceLoader.getImage(name);
  if (!spr) {
    console.warn(name, 'not found');
    return;
  }
  if (flipX || flipY || alpha !== 1) {
    canvasCtx.save();
    canvasCtx.globalAlpha = alpha;
    canvasCtx.translate(x + spr.w / 2, y + spr.h / 2);
    canvasCtx.scale(flipX ? -1 : 1, flipY ? -1 : 1);
    canvasCtx.drawImage(spr.img, spr.x, spr.y, spr.w, spr.h, -spr.w / 2, -spr.h / 2, spr.w, spr.h);
    canvasCtx.restore();
  } else {
    canvasCtx.drawImage(spr.img, spr.x, spr.y, spr.w, spr.h, x, y, spr.w, spr.h);
  }
}

export function drawText(text, x, y, size = 16, color = '#f0f0f0', isCentred = true, font = 'Papyrus') {
  canvasCtx.font = `${size}px ${font}, fantasy, sans-serif`;
  canvasCtx.textBaseline = 'middle';
  canvasCtx.textAlign = isCentred ? 'center' : 'left';
  canvasCtx.fillStyle = color;
  canvasCtx.fillText(text, x, y);
}

'''
'''--- src/js/config.js ---
import {TileGrade} from './tiles';

export const GlobalConfig = {
  INVASION_WAVE_MULTIPLIER: 1.045,
  PLAYER_HEAL_RATE: 0.1,

  SOUL_VALUE_MULTIPLIER: 1,
  SOUL_VALUE_DROP: 0.5,
  SOUL_MOOD_DROP: 0.45,
  MOOD_DAMAGE_MULTIPLIER: 0.2,
  MOOD_RECHARGE_MULTIPLIER: 0.3,
  MOOD_HEALTH_MULTIPLIER: 0.2,
  TILE_GRADE_MULTIPLIER: {
    [TileGrade.NORMAL]: 1,
    [TileGrade.DARK]: 2,
    [TileGrade.LIGHT]: 3,
    [TileGrade.GREEN]: 4,
    [TileGrade.HELLISH]: 5,
    [TileGrade.SHINING]: 6,
    [TileGrade.PONY]: 7,
  },
  SKELETON_RECHARGE_TIME: 2,
  SKELETON_DAMAGE: 2.7,

  ENEMY_HERO_HP: 10,
  ENEMY_HERO_DAMAGE: 2,
  ENEMY_HERO_RECHARGE: 2,
  ENEMY_MONSTER_HP: 15,
  ENEMY_MONSTER_DAMAGE: 1.5,
  ENEMY_MONSTER_RECHARGE: 2,

  MAX_NORMIES: 15
};

'''
'''--- src/js/director.js ---
import {Sprite, SpriteGroup} from './sprite';
import {Walker} from './walker';
import {gameState} from './state';
import {gameSkeletons} from './objects/skeletons';
import {Enemy, EnemyState} from './enemy';
import {GlobalConfig} from './config';
import {playElevate, playWave} from './sound';

/**
 * @enum {number}
 */
export const CharonStage = {
  NONE: -1,
  ENTRY: 1,
  WAIT: 2,
  EXIT: 3,
};

const CHARON_TRANSITION_TIME = 3;

/**
 * @enum {number}
 */
export const NormieState = {
  DISEMBARK: 1,
  WANDERING: 2,
  WAITING: 3,
  BLEND: 4
};

class Normie {
  constructor(x, level, targetX, targetLevel, speed = 24) {
    this.x = x;
    this.time = 0;
    this.waitTimer = 0;

    this.state = NormieState.DISEMBARK;
    this.target = targetX;
    this.targetLevel = targetLevel;
    this.sprite = new Walker(
      ['soul-base'],
      x, level, speed
    );
    this.sprite.sprite.setAlpha(0);
  }

  setTarget(x, level) {
    this.target = x;
    this.targetLevel = level;
  }

  update(dt) {
    this.time += dt;
    this.waitTimer += dt;
    if (this.state === NormieState.DISEMBARK) {
      if (this.sprite.sprite.alpha < 1) {
        this.sprite.sprite.alpha += dt;
      } else {
        this.state = NormieState.WANDERING;
      }
    } else if (this.state === NormieState.WAITING) {
      if (this.waitTimer > 3) {
        this.state = NormieState.WANDERING;
      }
    } else if (this.state === NormieState.BLEND) {
      this.sprite.sprite.alpha -= dt * 0.2;
    }
  }

  render(dt) {
    this.update(dt);
    if (this.state === NormieState.WANDERING) {
      this.sprite.walkTo(this.target, this.targetLevel);
    }
    this.sprite.render(dt);
    if (this.state !== NormieState.BLEND && this.sprite.targetLevel === this.targetLevel && Math.abs(this.target - this.sprite.x) < 10) {
      const levelMax = [
        gameState.maxElysiumArea,
        gameState.maxAsphodelArea,
        gameState.maxTartarArea
      ];

      const levelMin = [0, 4, 0];
      const level = this.targetLevel;

      let dx = (levelMin[level] + Math.random() * (levelMax[level] - levelMin[level])) * 16;
      this.setTarget(dx, this.targetLevel);
      this.state = NormieState.WAITING;
      this.waitTimer = 0;
    }
  }
}

export class Director {
  constructor() {
    this.time = 0;
    this.timeSinceLastInvasion = 0;

    // charon
    this.charon = new SpriteGroup(24, 8 * 16);
    this.charon.addSprite(new Sprite(['chA'], 0, 0), -8, 0);
    this.charon.addSprite(new Sprite(['chB'], 0, 0), 8, 0);

    this.charonState = CharonStage.ENTRY;
    this.charonTime = 0;
    this.timeSinceLastArrival = 0;

    /**
     * @type {Array<Normie>}
     */
    this.normies = [];
  }

  reassignSkeletons() {
    const assignedEnemyIds = new Set();
    gameSkeletons.skeletons.forEach((sk) => {
      if (sk.enemy) {
        assignedEnemyIds.add(sk.enemy.id);
      }
    });

    gameSkeletons.skeletons.forEach((sk) => {
      if (sk.hp > 0 && (!sk.enemy || sk.enemy.health <= 0)) {
        sk.enemy = gameState.enemies.find((enemy) => {
          return enemy.state !== EnemyState.APPEAR
            && enemy.state !== EnemyState.BLEND
            && enemy.sprite.currentLevel === sk.level
            && Math.abs(enemy.sprite.x - sk.startX) < 64
            && !assignedEnemyIds.has(enemy.id);
        });
        if (sk.enemy) {
          assignedEnemyIds.add(sk.enemy.id);
        }
      }
    });
  }

  update(dt) {
    this.time += dt;
    this.timeSinceLastInvasion += dt;

    // charon
    this.charonTime += dt;
    this.timeSinceLastArrival += dt;

    if (this.timeSinceLastArrival > 10 && this.charonState === CharonStage.NONE) {
      this.charonState = CharonStage.ENTRY;
      this.charon.setFlip(false);
      this.charonTime = 0;
      this.timeSinceLastArrival = 0;
    }

    if (this.charonState === CharonStage.ENTRY) {
      this.charon.x = (Math.min(this.charonTime, CHARON_TRANSITION_TIME) / CHARON_TRANSITION_TIME) * 48 - 10;
      if (this.charonTime > CHARON_TRANSITION_TIME) {
        const levelMax = [
          gameState.maxElysiumArea,
          gameState.maxAsphodelArea,
          gameState.maxTartarArea
        ];

        const levelMin = [0, 4, 0];

        this.charonTime = 0;
        const addedSouls = 1 + Math.round(GlobalConfig.SOUL_VALUE_MULTIPLIER * gameState.value / 100);
        playElevate();
        gameState.state.money += addedSouls;
        this.charonState = CharonStage.WAIT;
        for (let i = 0; i < addedSouls; i++) {
          gameState.state.score++;
          gameState.state.souls++;
          const level = Math.floor(Math.random() * 3);
          let dx = (levelMin[level] + Math.random() * (levelMax[level] - levelMin[level])) * 16;
          this.normies.push(
            new Normie(
              64 + Math.random() * 10 - 5,
              1,
              dx,
              level,
              Math.random() * 10 + 14
            )
          );
        }
        const normiesToHide = Math.max(0, this.normies.length - GlobalConfig.MAX_NORMIES);
        for (let i = 0; i < normiesToHide; i++) {
          this.normies[i].state = NormieState.BLEND;
        }
      }
    }

    if (this.charonState === CharonStage.WAIT && this.charonTime > 3) {
      this.charon.setFlip(true);
      this.charonTime = 0;
      this.charonState = CharonStage.EXIT;
    }

    if (this.charonState === CharonStage.EXIT) {
      this.charon.x = ((CHARON_TRANSITION_TIME - Math.min(this.charonTime, CHARON_TRANSITION_TIME)) / CHARON_TRANSITION_TIME) * 48 - 10;
      if (this.charonTime > CHARON_TRANSITION_TIME) {
        this.charonTime = 0;
        this.charonState = CharonStage.NONE;
      }
    }

    // invasions
    if (gameState.enemies.length === 0 && this.timeSinceLastInvasion > 15) {
      this.timeSinceLastInvasion = 0;
      playWave();

      const totalAmount = Math.ceil(Math.pow(GlobalConfig.INVASION_WAVE_MULTIPLIER, gameState.state.monsterInvasions));
      gameState.state.monsterInvasions++;
      for (let i = 0; i < totalAmount; i++) {
        const enemy = new Enemy(32 * 16 + Math.random() * 20, Math.random() >= 0.5 ? 0 : 2, 18 + Math.random() * 10);
        gameState.enemies.push(enemy);
      }
    }

    this.reassignSkeletons();
  }

  render(dt) {
    this.update(dt);
    this.charon.render(dt);
    this.normies = this.normies.filter((normie) => {
      normie.render(dt);
      const canBeRemoved = normie.state === NormieState.BLEND && normie.sprite.sprite.alpha <= 0;
      return !canBeRemoved;
    });
    const startEnemies = gameState.enemies.length;
    gameState.enemies = gameState.enemies.filter((enemy) => {
      enemy.render(dt);
      const isDead = enemy.state === EnemyState.BLEND && enemy.sprite.sprite.alpha <= 0;
      if (isDead) {
        gameState.state.score++;
      }
      return !isDead;
    });
    const endEnemies = gameState.enemies.length;
    if (endEnemies === 0 && startEnemies !== 0) {
      this.timeSinceLastInvasion = 0;
    }
  }
}

'''
'''--- src/js/enemy.js ---
import {Walker} from './walker';
import {gameState} from './state';
import {MapArea, sortObject} from './utils';
import {Skeleton, Skeletons} from './objects/skeletons';
import {Barricade} from './objects/barricade';
import {canvasCtx} from './canvas';
import {GlobalConfig} from './config';

/**
 * @enum {number}
 */
export const EnemyState = {
  APPEAR: 1,
  MOVE: 2,
  ATTACK: 3,
  BLEND: 4
};

let nextEnemyId = 1;

export class Enemy {
  constructor(x, level, speed = 24) {
    this.isHero = level === 0;

    this.id = nextEnemyId++;
    this.health = this.isHero ? GlobalConfig.ENEMY_HERO_HP : GlobalConfig.ENEMY_MONSTER_HP;
    this.maxHealth = this.health;
    this.time = 0;
    this.waitTimer = 0;
    this.attackCycle = 0;
    this.rechargeTime = this.isHero ? GlobalConfig.ENEMY_HERO_RECHARGE : GlobalConfig.ENEMY_MONSTER_RECHARGE;
    this.damage = this.isHero ? GlobalConfig.ENEMY_HERO_DAMAGE : GlobalConfig.ENEMY_MONSTER_DAMAGE;

    this.state = EnemyState.APPEAR;
    this.target = 64;
    this.targetLevel = 1;

    const prefix = this.isHero ? 'hr-c-i' : 'm-c-i';

    this.sprite = new Walker(
      [prefix + '1', prefix + '2', prefix + '0'],
      x, level, speed
    );

    const levelMax = [
      gameState.maxElysiumArea,
      gameState.maxAsphodelArea,
      gameState.maxTartarArea
    ];

    this.setTarget(levelMax[this.sprite.currentLevel] * 16, level);
  }

  setTarget(x, level) {
    this.target = x;
    this.targetLevel = level;
  }

  update(dt) {
    if (this.health <= 0) {
      this.state = EnemyState.BLEND;
      this.sprite.stop();
    }

    const levelMax = [
      gameState.maxElysiumArea,
      gameState.maxAsphodelArea,
      gameState.maxTartarArea
    ];

    this.time += dt;
    this.waitTimer += dt;
    this.attackCycle -= dt;

    const isWithinRange = gameState.state.playerPosition.y === this.sprite.currentLevel && Math.abs(gameState.state.playerPosition.x - this.sprite.x) < 8;
    /**
     * @type {(Skeleton|undefined)}
     */
    let targetSkeleton = undefined;
    /**
     * @type {(Barricade|undefined)}
     */
    let targetBarricade = undefined;
    [
      ...gameState.state.area[MapArea.ELYSIUM].objects,
      ...gameState.state.area[MapArea.ASPHODEL].objects,
      ...gameState.state.area[MapArea.TARTAR].objects
    ].forEach((obj) => {
      if (
        !targetSkeleton
        && obj instanceof Skeletons
        && obj.level === this.sprite.currentLevel
      ) {
        targetSkeleton = obj.skeletons
          .find(({spr, enemy}) =>
            Math.abs(spr.sprite.x - this.sprite.x) < 6
            && enemy?.id === this.id
          );
      }

      if (
        !targetBarricade
        && obj instanceof Barricade
        && obj.level === this.sprite.currentLevel
        && obj.x < this.sprite.x
        && Math.abs(obj.x - this.sprite.x) < 14
      ) {
        targetBarricade = obj;
      }
    });

    const [nearestBlocked] = [targetSkeleton, targetBarricade].filter(Boolean).sort(sortObject);

    if (this.state === EnemyState.BLEND) {
      this.sprite.sprite.alpha -= dt;
    } else if (this.state === EnemyState.APPEAR) {
      if (Math.abs(this.sprite.sprite.x - levelMax[this.sprite.currentLevel] * 16) < 10) {
        this.state = EnemyState.MOVE;
      }
    } else if (this.state === EnemyState.MOVE) {
      if (isWithinRange || nearestBlocked) {
        if (nearestBlocked instanceof Skeleton) {
          this.setTarget(targetSkeleton.spr.sprite.x, this.sprite.currentLevel);
        } else if (nearestBlocked instanceof Barricade) {
          this.setTarget(targetBarricade.x, this.sprite.currentLevel);
        }
        this.state = EnemyState.ATTACK;
        this.attackCycle = 0;
        this.sprite.stop();
      } else {
        this.setTarget(gameState.state.playerPosition.x, gameState.state.playerPosition.y);
      }
    } else if (this.state === EnemyState.ATTACK) {
      if (isWithinRange || nearestBlocked) {
        if (this.attackCycle <= 0) {
          this.attackCycle = this.rechargeTime;
          if (nearestBlocked instanceof Skeleton) {
            targetSkeleton.hp -= this.damage;
          } else if (nearestBlocked instanceof Barricade) {
            targetBarricade.hp -= this.damage;
          } else {
            gameState.state.playerHealth -= this.damage;
          }
        }
      } else {
        this.state = EnemyState.MOVE;
      }
    }
  }

  render(dt) {
    this.update(dt);
    this.sprite.render(dt);
    if (this.state !== EnemyState.ATTACK && this.state !== EnemyState.BLEND) {
      this.sprite.walkTo(this.target, this.targetLevel);
    }
    const healthPercentage = Math.max(0, this.health / this.maxHealth);
    if (healthPercentage < 1) {
      if (healthPercentage > 0.7) {
        canvasCtx.fillStyle = '#0f0';
      } else if (healthPercentage > 0.3) {
        canvasCtx.fillStyle = '#ff0';
      } else {
        canvasCtx.fillStyle = '#f00';
      }
      canvasCtx.fillRect(this.sprite.sprite.x + 3, this.sprite.sprite.y, Math.max(1, ~~(10 * healthPercentage)), 1);
    }
  }
}

'''
'''--- src/js/fire.js ---
import {AnimationMode, Sprite} from './sprite';

export class Fire {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.lightSpr = new Sprite(['lgth-c-i0', 'lgth-c-i1', 'lgth-c-i2'], x, y - 3, 10, AnimationMode.RANDOM);
    this.flameSpr = new Sprite(['flm-c-i0', 'flm-c-i1', 'flm-c-i2', 'flm-c-i3', 'flm-c-i4', 'flm-c-i5'], x, y, 10);
  }

  render(dt) {
    this.lightSpr.render(dt);
    this.flameSpr.render(dt);
  }
}

'''
'''--- src/js/game.js ---
import {drawBorder} from './bg';
import {canvasCtx, drawImage, drawText, width, height} from './canvas';
import {Sprite} from './sprite';
import {Director} from './director';
import {Walker} from './walker';
import {mx, my, pressedKeys, setClickHandler} from './input';
import {renderMap} from './map';
import {GameState, gameState} from './state';
import {UISpriteButton, UITextButton} from './button';
import {getMapDY, MapArea, sortDist} from './utils';
import {createObject, Objects, TileGrade, Tiles} from './tiles';
import {particleManager} from './particles';
import {gameSkeletons, Skeletons} from './objects/skeletons';
import {EnemyState} from './enemy';
import {Barricade} from './objects/barricade';
import {isSoundOn, playBuildSound, playClick, playGameOver, playShoot, toggleSound} from './sound';
import {isLoggedInWithNear, isPremiumNear} from './near';
import {GlobalConfig} from './config';

/**
 * @enum {number}
 */
export const GameMode = {
  DEFAULT: 0,
  PAINT: 10,
  PAINT_SELECT: 11,
  BUILD: 20,
  BUILD_SELECT: 21,
  EXTEND: 3,
  UPGRADE: 4,
  MENU: 5,
  GAME_OVER: 6,
};

const GradeOrder = [
  TileGrade.NORMAL,
  TileGrade.DARK,
  TileGrade.LIGHT,
  TileGrade.GREEN,
  TileGrade.HELLISH,
  TileGrade.SHINING,
  TileGrade.PONY,
];

const GradeMinScore = [
  0,
  30,
  100,
  250,
  400,
  700,
  0
];

export class Game {
  constructor() {
    this.handleSelect = this.handleSelect.bind(this);
    this.handleSelectObject = this.handleSelectObject.bind(this);
    this.handleConfirm = this.handleConfirm.bind(this);
    this.selectedTile = -1;
    this.selectedTileGrade = -1;
    this.selectedTileType = '';
    this.hoverTile = -1;
    this.hoverTileGrade = -1;
    this.hoverTileType = '';
    this.hoverObject = -1;
    this.selectedObject = -1;
    this.selectedArcadianId = undefined;

    this.recalcMapValueIn = 0;

    this.director = new Director();

    this.player = new Walker(
      ['hds-i1', 'hds-i2', 'hds-i0'],
      gameState.state.playerPosition.x, gameState.state.playerPosition.y, 30
    );
    this.playerRecharge = 0;

    this.mode = GameMode.DEFAULT;

    this.gateEl = new Sprite(['gate-c'], 16 * 5, 16 * 3);
    this.gateAs = new Sprite(['gate-c'], 16 * 5, 16 * 8);
    this.gateTa = new Sprite(['gate-c'], 16 * 5, 16 * 13);

    this.buttons = [
      new UISpriteButton('Expand', 'expnd-c', 145, 17 * 16, 3, () => {
        this.mode = GameMode.EXTEND;
      }),
      new UISpriteButton('Paint', 'pnt-c', 200, 17 * 16, 3, () => {
        this.mode = GameMode.PAINT_SELECT;
      }),
      new UISpriteButton('Build', 'bld-c', 255, 17 * 16, 3, () => {
        this.mode = GameMode.BUILD_SELECT;
      }),
      new UISpriteButton('Upgrade', 'up-c', 310, 17 * 16, 3, () => {
        this.mode = GameMode.UPGRADE;
      }),
      new UISpriteButton('Menu', 'menu', 365, 17 * 16, 3, () => {
        this.mode = GameMode.MENU;
      }),
    ];
    this.confirm = new UITextButton('Confirm', 380, 17 * 16, 4, () => {
      this.handleConfirm();
    });
    this.cancel = new UITextButton('Cancel', 460, 17 * 16, 4, () => {
      this.handleCancel();
    });

    this.saveBtn = new UITextButton('Save', width / 3, 8 * 16, 8, () => {
      gameState.saveLocal();
      this.handleCancel();
    });
    this.saveNearBtn = new UITextButton('Save to Near', 2 * width / 3, 8 * 16, 8, async () => {
      this.saveNearBtn.text = 'Saving...';
      gameState.saveLocal();
      await gameState.saveNear();
      this.handleCancel();
      this.saveNearBtn.text = 'Save to Near';
    });
    this.soundBtn = new UITextButton('Sound (' + (isSoundOn() ? 'On' : 'Off') + ')', width / 3, 12 * 16, 8, () => {
      toggleSound();
      this.soundBtn.text = 'Sound (' + (isSoundOn() ? 'On' : 'Off') + ')';
    });
    this.exitToMainBtn = new UITextButton('Exit to Main', 2 * width / 3, 12 * 16, 8, () => {
      gameState.gameState = GameState.MENU;
    });

    this.exitToMainGameOverBtn = new UITextButton('Exit to Main menu', width / 2, 17 * 16, 10, () => {
      gameState.gameState = GameState.MENU;
    });

    this.objectsPreview = Objects.map((obj, index) => createObject(obj, 30 + index * 40, 30, true));

    gameSkeletons.skeletons = [];
  }

  handleCancel() {
    this.mode = GameMode.DEFAULT;
  }

  handleConfirm() {
    if (this.mode === GameMode.PAINT_SELECT) {
      this.mode = GameMode.PAINT;
    } else if (this.mode === GameMode.BUILD_SELECT) {
      this.mode = GameMode.BUILD;
    }
  }

  handlePaint(x, y, level) {
    const map = gameState.state.area[level].map;
    const [type] = (map[y][x] ?? '').split('|');
    if (type === this.selectedTileType) {
      let tile = undefined;
      const grade = GradeOrder[this.selectedTileGrade];
      if (this.selectedTileType === 'f') {
        tile = Tiles.FLOORS[this.selectedTile];
        drawImage('flr-i' + tile.id + '-' + grade, 20, 150);
      } else {
        tile = Tiles.WALLS[this.selectedTile];
        drawImage('wl-i' + tile.id + '-' + grade, 20, 150);
      }

      const tileId = tile.id;
      const baseCost = (grade === TileGrade.NORMAL) ? tile.basePrice : Math.max(tile.basePrice, 0.1);
      const cost = baseCost * GlobalConfig.TILE_GRADE_MULTIPLIER[grade];
      if (gameState.state.money >= cost) {
        playBuildSound();
        gameState.state.money -= cost;
        map[y][x] = [this.selectedTileType, tileId, GradeOrder[this.selectedTileGrade]].join('|');
        gameState.updateMoodAndValue();
      }
    }
  }

  handleBuild(x, y, level) {
    const map = gameState.state.area[level].objects;
    const objDef = Objects[this.selectedObject];
    if (objDef && gameState.state.money >= objDef.cost) {
      gameState.state.money -= objDef.cost;
      const current = map[x];
      if (current instanceof Skeletons) {
        // cleanup old skeletons
        current.skeletons.forEach((sk) => sk.hp = -10);
      }

      playBuildSound();

      map[x] = createObject(
        Objects[this.selectedObject],
        x * 16 + 16,
        getMapDY(level) + 2 * 16,
        false,
        this.selectedArcadianId
      );
      gameState.updateMoodAndValue();
    }
  }

  update(dt) {
    if (pressedKeys.has('ArrowDown')) {
      this.player.gate(-1);
    }
    if (pressedKeys.has('ArrowUp')) {
      this.player.gate(1);
    }

    if (pressedKeys.has('ArrowLeft')) {
      this.player.walkTo(this.player.x - 20);
    } else if (pressedKeys.has('ArrowRight')) {
      this.player.walkTo(this.player.x + 20);
    } else {
      this.player.stop();
    }

    const levelMin = [16, 4 * 16, 16];
    const levelMax = [
      31 * 16,
      gameState.maxAsphodelArea * 16,
      31 * 16
    ];
    this.player.x = Math.max(Math.min(this.player.x, levelMax[this.player.currentLevel]), levelMin[this.player.currentLevel]);

    gameState.state.playerPosition.x = this.player.x;
    gameState.state.playerPosition.y = this.player.currentLevel;

    if (gameState.state.playerHealth < gameState.playerMaxHealth) {
      gameState.state.playerHealth += dt * GlobalConfig.PLAYER_HEAL_RATE;
    }

    if (gameState.state.playerHealth <= 0) {
      playGameOver();
      this.mode = GameMode.GAME_OVER;
    }

    const closestEnemies = gameState.enemies.filter(enemy => {
      if (enemy.sprite.currentLevel === this.player.currentLevel && enemy.state !== EnemyState.BLEND) {
        return Math.abs(enemy.sprite.x - this.player.x + 16) < 70;
      }
      return false;
    });
    const [closestEnemy] = closestEnemies.sort((a, b) => sortDist(this.player.sprite.x, a, b));
    this.playerRecharge -= dt;
    if (closestEnemy && this.playerRecharge <= 0) {
      this.playerRecharge = gameState.playerRechargeTime;
      playShoot();
      particleManager.add(
        this.player.sprite.x + 8,
        this.player.sprite.y + 8,
        closestEnemy,
        '#f00000',
        gameState.playerDamage
      );
    }
  }

  renderElysium() {
    renderMap(16, 16, gameState.state.area[MapArea.ELYSIUM].map);
    for (let x = 0; x < 31; x++) {
      drawImage('brick-b', x * 16 + 16, 5 * 16);
    }
  }

  renderAsphodelMeadows() {
    renderMap(16, 6 * 16, gameState.state.area[MapArea.ASPHODEL].map);
    for (let x = 0; x < 31; x++) {
      drawImage('brick-b', x * 16 + 16, 10 * 16);
    }
    for (let x = 0; x < 3; x++) {
      drawImage('water-c', x * 16 + 16, 9 * 16);
    }
  }

  renderTartar() {
    renderMap(16, 11 * 16, gameState.state.area[MapArea.TARTAR].map);
  }

  /**
   * @param {MapArea} area
   */
  extendArea(area) {
    const price = gameState.getExtendPrice(area);
    if (gameState.state.money >= price) {
      playClick();
      gameState.state.money -= price;
      gameState.extend(area);
    }
  }

  isCursorInElysium() {
    return mx > 16 && mx < 32 * 16 && my > 16 && my < 5 * 16;
  }

  isCursorInAsphodel() {
    return mx > 16 && mx < 32 * 16 && my > 6 * 16 && my < 10 * 16;
  }

  isCursorInTartar() {
    return mx > 16 && mx < 32 * 16 && my > 11 * 16 && my < 15 * 16;
  }

  handleSelect() {
    if (this.hoverTile !== -1) {
      this.selectedTile = this.hoverTile;
      this.selectedTileGrade = this.hoverTileGrade;
      this.selectedTileType = this.hoverTileType;
    }
  }

  handleSelectObject() {
    if (this.hoverObject !== -1) {
      this.selectedObject = this.hoverObject;
      const obj = Objects[this.selectedObject];
      if (obj.isArcadian) {
        const id = window.prompt('Enter Arcadian NFT id (1 ~ 3732)') || '-1';
        this.selectedArcadianId = parseInt(id, 10);
        const current = this.objectsPreview[this.selectedObject];
        this.objectsPreview[this.selectedObject] = createObject(obj, current.x, current.y, true, this.selectedArcadianId);
      } else {
        this.selectedArcadianId = undefined;
      }
    }
  }

  renderObjectSelect(dt) {
    this.hoverObject = -1;
    setClickHandler(this.handleSelectObject);

    drawBorder(0, 0, 32, 19, 'brd1-b-');
    this.objectsPreview.forEach((preview, index) => {
      const x = preview.x;
      const y = preview.y;
      preview.render(dt);

      if (mx > x - 8 && mx < x + 30 && my > y - 8 && my < y + 30) {
        this.hoverObject = index;
        canvasCtx.strokeStyle = '#f00000';
        canvasCtx.beginPath();
        canvasCtx.rect(x - 8, y - 8, 30, 30);
        canvasCtx.stroke();
      }

      if (this.selectedObject === index) {
        canvasCtx.strokeStyle = '#f0f000';
        canvasCtx.beginPath();
        canvasCtx.rect(x - 8, y - 8, 30, 30);
        canvasCtx.stroke();
      }
    });

    this.cancel.render();
    if (this.hoverObject !== -1 || this.selectedObject !== -1) {
      const object = Objects[this.hoverObject === -1 ? this.selectedObject : this.hoverObject];
      drawText(object.name, 32, 70, 18, '#fff0a0', false);
      const lines = object.description.split('\n');
      lines.forEach((line, index) => {
        drawText(line, 32, 90 + index * 20, 16, '#f0f0f0', false);
      });

      drawText('Base price: ' + object.cost, 32, 120 + lines.length * 20, 16, '#f0f0f0', false);
      if (object.upgradeCost) {
        drawText('Upgrade costs multiplier: ' + object.upgradeCost + '%', 32, 140 + lines.length * 20, 16, '#f0f0f0', false);
      }

      let mvDx = 0;
      if (object.mood) {
        mvDx = 70;

        drawImage('skull', 32, 150 + lines.length * 20);
        drawText(object.mood > 0 ? '+' + object.mood : object.mood, 48, 160 + lines.length * 20, 16, '#f0f0f0', false);
      }

      if (object.value) {
        drawImage('crown-c', 32 + mvDx, 150 + lines.length * 20);
        drawText(object.value > 0 ? '+' + object.value : object.value, 48 + mvDx, 160 + lines.length * 20, 16, '#f0f0f0', false);
      }

      if (this.selectedObject !== -1) {
        this.confirm.render();
      }
    } else {
      drawText('Pick object above', 32, 70, 18, '#fff0a0', false);
    }
  }

  renderTileSelect() {
    this.hoverTile = -1;
    this.hoverTileGrade = -1;
    this.hoverTileType = '';
    setClickHandler(this.handleSelect);
    drawBorder(0, 0, 32, 19, 'brd1-b-');

    const openGrades = GradeMinScore.map((min) => gameState.state.score >= min);

    drawText('Floor tiles', 20, 28, 14, '#fff', false);
    Tiles.FLOORS.forEach((tile, tileIndex) => {
      GradeOrder.forEach((grade, gradeIndex) => {
        if (!openGrades[gradeIndex]) {
          return;
        }
        if (grade === TileGrade.PONY && !isPremiumNear) {
          return;
        }

        const x = 20 + gradeIndex * 20;
        const y = 40 + tileIndex * 20;

        drawImage('flr-i' + tile.id + '-' + grade, x, y);

        const isSelected = this.selectedTileType === 'f' && this.selectedTile === tileIndex && this.selectedTileGrade === gradeIndex;
        const isOver = (mx > x && mx < x + 16 && my > y && my < y + 16);

        if (isOver) {
          this.hoverTile = tileIndex;
          this.hoverTileGrade = gradeIndex;
          this.hoverTileType = 'f';
        }

        if (isSelected || isOver) {
          canvasCtx.strokeStyle = '#f00000';
          canvasCtx.beginPath();
          canvasCtx.rect(x - 2, y - 2, 20, 20);
          canvasCtx.stroke();
        }
      });
    });

    drawText('Wall tiles', 220, 28, 14, '#fff', false);
    Tiles.WALLS.forEach((tile, tileIndex) => {
      GradeOrder.forEach((grade, gradeIndex) => {
        if (!openGrades[gradeIndex]) {
          return;
        }
        if (grade === TileGrade.PONY && !isPremiumNear) {
          return;
        }

        const x = 220 + gradeIndex * 20;
        const y = 40 + tileIndex * 20;

        drawImage('wl-i' + tile.id + '-' + grade, x, y);

        const isSelected = this.selectedTileType === 'w' && this.selectedTile === tileIndex && this.selectedTileGrade === gradeIndex;
        const isOver = (mx > x && mx < x + 16 && my > y && my < y + 16);
        if (isOver) {
          this.hoverTile = tileIndex;
          this.hoverTileGrade = gradeIndex;
          this.hoverTileType = 'w';
        }

        if (isSelected || isOver) {
          canvasCtx.strokeStyle = '#f00000';
          canvasCtx.beginPath();
          canvasCtx.rect(x - 2, y - 2, 20, 20);
          canvasCtx.stroke();
        }
      });
    });

    if (this.selectedTile !== -1 || this.hoverTile !== -1) {
      let tile = undefined;
      const tileId = this.hoverTile === -1 ? this.selectedTile : this.hoverTile;
      const tileType = this.hoverTile === -1 ? this.selectedTileType : this.hoverTileType;
      const tileGrade = this.hoverTile === -1 ? this.selectedTileGrade : this.hoverTileGrade;
      const grade = GradeOrder[tileGrade];
      if (tileType === 'f') {
        tile = Tiles.FLOORS[tileId];
        drawImage('flr-i' + tile.id + '-' + grade, 20, 150);
      } else if (tileType === 'w') {
        tile = Tiles.WALLS[tileId];
        drawImage('wl-i' + tile.id + '-' + grade, 20, 150);
      }

      drawImage('money-c', 20, 170);
      drawImage('skull', 120, 170);
      drawImage('crown-c', 220, 170);

      const cost = (grade === TileGrade.NORMAL) ? tile.basePrice : Math.max(tile.basePrice, 0.1);
      const mood = (grade === TileGrade.NORMAL) ? tile.mood : Math.max(tile.mood, 0.5);
      const value = (grade === TileGrade.NORMAL) ? tile.value : Math.max(tile.value, 0.5);
      drawText('-' + (cost * GlobalConfig.TILE_GRADE_MULTIPLIER[grade]).toFixed(1), 40, 180, 16, '#fff', false);
      drawText('+' + (mood * GlobalConfig.TILE_GRADE_MULTIPLIER[grade]).toFixed(1), 140, 180, 16, '#fff', false);
      drawText('+' + (value * GlobalConfig.TILE_GRADE_MULTIPLIER[grade]).toFixed(1), 240, 180, 16, '#fff', false);
    } else {
      drawText('Pick object above', 20, 150, 18, '#fff0a0', false);
      drawText('Extra tiles will be opened later in the game', 20, 180, 16, '#fff', false);
    }

    this.cancel.render();
    if (this.selectedTile !== -1) {
      this.confirm.render();
    }
  }

  renderMenu() {
    setClickHandler(this.handleSelect);
    drawBorder(0, 0, 32, 19, 'brd1-b-');
    drawText('Hades Defence', width / 2, 40, 25, '#f0f0f0');

    drawText('Score', width / 2, 65, 20, '#f0f0f0');
    drawText(gameState.state.score, width / 2, 85, 20, '#f0f0f0');

    this.saveBtn.render();
    if (isLoggedInWithNear()) {
      this.saveNearBtn.render();
    }
    this.soundBtn.render();
    this.exitToMainBtn.render();
    this.cancel.render();
  }

  renderGameOver() {
    setClickHandler(this.handleSelect);
    drawBorder(0, 0, 32, 19, 'brd1-b-');
    drawText('Game Over', width / 2, 60, 40, '#b90000');

    for (let i = 0; i < 5; i++) {
      drawImage('skull', (i + 3) * width / 10, 100);
    }

    drawText('Your score', width / 2, 150, 30, '#f0f0f0');
    drawText(gameState.getScore(), width / 2, 180, 20, '#f0f0f0');
    this.exitToMainGameOverBtn.render();
  }

  render(dt) {
    if (this.recalcMapValueIn <= 0) {
      gameState.updateMoodAndValue();
      this.recalcMapValueIn = 1;
    }
    this.recalcMapValueIn -= dt;
    gameSkeletons.cleanup();
    canvasCtx.clearRect(0, 0, width, height);
    setClickHandler(undefined);

    if (this.mode === GameMode.PAINT_SELECT) {
      this.renderTileSelect();
      return;
    } else if (this.mode === GameMode.BUILD_SELECT) {
      this.renderObjectSelect(dt);
      return;
    } else if (this.mode === GameMode.MENU) {
      this.renderMenu();
      return;
    } else if (this.mode === GameMode.GAME_OVER) {
      this.renderGameOver();
      return;
    }
    this.update(dt);

    this.renderTartar();
    this.renderAsphodelMeadows();
    this.renderElysium();

    this.gateEl.render(dt);
    this.gateAs.render(dt);
    this.gateTa.render(dt);

    gameState.state.area[MapArea.TARTAR].objects.forEach((obj, index) => {
      obj?.render(dt);
      if (obj instanceof Barricade && obj.hp <= 0) {
        gameState.state.area[MapArea.TARTAR].objects[index] = undefined;
      }
    });
    gameState.state.area[MapArea.ASPHODEL].objects.forEach((obj, index) => {
      obj?.render(dt);
      if (obj instanceof Barricade && obj.hp <= 0) {
        gameState.state.area[MapArea.ASPHODEL].objects[index] = undefined;
      }
    });
    gameState.state.area[MapArea.ELYSIUM].objects.forEach((obj, index) => {
      obj?.render(dt);
      if (obj instanceof Barricade && obj.hp <= 0) {
        gameState.state.area[MapArea.ELYSIUM].objects[index] = undefined;
      }
    });

    this.player.render(dt);
    this.director.render(dt);
    particleManager.render(dt);

    drawBorder(0, 0, 32, 19, 'brd1-b-');
    drawBorder(16, 15 * 16, 30, 3, 'brd2-b-');

    const moneyText = gameState.state.money > 100000 ? '99999+' : (gameState.state.money).toFixed(1);
    drawImage('money-c', 24, 16 * 16 - 5);
    drawText(moneyText, 42, 17 * 16 - 10, 16, '#fff', false);

    drawImage('hp-c', 24, 17 * 16 + 5);
    drawText(Math.ceil(gameState.state.playerHealth), 42, 18 * 16 - 1, 16, '#fff', false);

    drawImage('crown-c', 25 * 16 - 5, 16 * 16 - 5);
    drawText('Value: ' + Math.round(gameState.value) + '%', 26 * 16 - 2, 17 * 16 - 10, 14, '#fff', false);

    drawImage('skull', 25 * 16 - 5, 17 * 16 + 5);
    drawText('Mood: ' + Math.round(gameState.mood) + '%', 26 * 16 - 2, 18 * 16 - 1, 14, '#fff', false);

    const forceMode = [
      this.mode === GameMode.EXTEND,
      this.mode === GameMode.PAINT,
      this.mode === GameMode.BUILD,
      this.mode === GameMode.UPGRADE
    ];
    this.buttons.forEach((btn, index) => btn.render(forceMode[index]));

    const maxTartarArea = gameState.maxTartarArea;
    const maxAsphodelArea = gameState.maxAsphodelArea;
    const maxElysiumArea = gameState.maxElysiumArea;

    if (this.mode === GameMode.EXTEND) {
      let y = 0;
      let w = 0;

      if (this.isCursorInTartar() && maxTartarArea < 31) {
        setClickHandler(() => this.extendArea(MapArea.TARTAR));
        y = 11 * 16;
        w = (maxTartarArea + 1) * 16;
        drawText(`-${gameState.getExtendPrice(MapArea.TARTAR)}$`, mx, my - 14, 16);
      } else if (this.isCursorInAsphodel() && maxAsphodelArea < 31) {
        setClickHandler(() => this.extendArea(MapArea.ASPHODEL));
        y = 6 * 16;
        w = (maxAsphodelArea + 1) * 16;
        drawText(`-${gameState.getExtendPrice(MapArea.ASPHODEL)}$`, mx, my - 14, 16);
      } else if (this.isCursorInElysium() && maxElysiumArea < 31) {
        setClickHandler(() => this.extendArea(MapArea.ELYSIUM));
        y = 16;
        w = (maxElysiumArea + 1) * 16;
        drawText(`-${gameState.getExtendPrice(MapArea.ELYSIUM)}$`, mx, my - 14, 16);
      }

      if (w) {
        canvasCtx.strokeStyle = '#a0a000';
        canvasCtx.beginPath();
        canvasCtx.rect(16, y, w, 4 * 16);
        canvasCtx.stroke();
      }
    } else if (this.mode === GameMode.PAINT) {
      let dx = 16;
      let area;
      let dy = 0;
      let maxLen = 0;

      if (this.isCursorInTartar()) {
        dy = 11 * 16;
        area = MapArea.TARTAR;
        maxLen = maxTartarArea;
      } else if (this.isCursorInAsphodel()) {
        dy = 6 * 16;
        area = MapArea.ASPHODEL;
        maxLen = maxAsphodelArea;
      } else if (this.isCursorInElysium()) {
        dy = 16;
        area = MapArea.ELYSIUM;
        maxLen = maxElysiumArea;
      }

      if (dy) {
        let px = ~~((mx - dx) / 16);
        let py = ~~((my - dy) / 16);
        const [type, entity] = (gameState.state.area[area].map[py][px] ?? '').split('|');
        const isMatchingType = (this.selectedTileType === 'f' && py === 3) || (this.selectedTileType === 'w' && py !== 3);

        if (isMatchingType && entity !== 'x' && type !== '-' && px < maxLen) {
          canvasCtx.strokeStyle = '#a00000';
          canvasCtx.beginPath();
          canvasCtx.rect(dx + px * 16, dy + py * 16, 16, 16);
          canvasCtx.stroke();

          setClickHandler(() => this.handlePaint(px, py, area));
        }
      }
    } else if (this.mode === GameMode.BUILD) {
      let dx = 16;
      let area;
      let dy = 0;
      let maxLen = 0;
      let minX = 5;

      if (this.isCursorInTartar()) {
        dy = 11 * 16;
        minX = 0;
        area = MapArea.TARTAR;
        maxLen = maxTartarArea;
      } else if (this.isCursorInAsphodel()) {
        dy = 6 * 16;
        area = MapArea.ASPHODEL;
        maxLen = maxAsphodelArea;
      } else if (this.isCursorInElysium()) {
        dy = 16;
        minX = 0;
        area = MapArea.ELYSIUM;
        maxLen = maxElysiumArea;
      }

      if (dy) {
        let px = ~~((mx - dx) / 16);
        let py = ~~((my - dy) / 16);
        if (px < maxLen && px >= minX && px !== 4) {
          canvasCtx.strokeStyle = 'rgb(178,220,239)';
          canvasCtx.beginPath();
          canvasCtx.rect(dx + px * 16, dy, 16, 16 * 3);
          canvasCtx.stroke();

          const objDef = Objects[this.selectedObject];
          drawText(`-${objDef.cost}$`, mx, my - 14, 16);

          setClickHandler(() => this.handleBuild(px, py, area));
        }
      }
    } else if (this.mode === GameMode.UPGRADE) {
      let area;
      let dy = 0;
      let dx = 16;

      if (this.isCursorInTartar()) {
        dy = 11 * 16;
        area = MapArea.TARTAR;
      } else if (this.isCursorInAsphodel()) {
        dy = 6 * 16;
        area = MapArea.ASPHODEL;
      } else if (this.isCursorInElysium()) {
        dy = 16;
        area = MapArea.ELYSIUM;
      }

      if (dy) {
        let px = ~~((mx - dx) / 16);
        const object = gameState.state.area[area].objects[px];
        if (object && object.canUpgrade) {
          canvasCtx.strokeStyle = '#00a000';
          canvasCtx.beginPath();
          canvasCtx.rect(dx + px * 16, dy, 16, 16 * 3);
          canvasCtx.stroke();

          drawText(`-${object.getUpgradeCost()}$`, mx, my - 14, 16);

          setClickHandler(() => object.upgrade());
        }
      }
    }
  }
}

'''
'''--- src/js/index.js ---
import {renderBg} from './bg';
import {Menu} from './menu';
import {Game} from './game';
import {prepareSprites} from './sprite-prep';
import {GameState, gameState} from './state';
import {initNearWallet} from './near';

async function init() {
  await prepareSprites();
  await initNearWallet();

  start();
}

function start() {
  
  let time = 0;
  renderBg();
  let game = new Game();
  const menu = new Menu(() => {
    game = new Game();
  });

  requestAnimationFrame(raf);

  function raf(now) {
    const newTime = now / 1000;
    const dt = newTime - time;
    time = newTime;

    if (gameState.gameState === GameState.MENU) {
      menu.render();
    } else if (gameState.gameState === GameState.GAME) {
      game.render(dt);
    }

    requestAnimationFrame(raf);
  }
}

document.addEventListener('DOMContentLoaded', () => {
  setTimeout(init, 100);
});

'''
'''--- src/js/input.js ---
import {canvas} from './canvas';

export const pressedKeys = new Set();

function handleMouseMove(evt) {
  mx = evt.offsetX / 2;
  my = evt.offsetY / 2;
}

function handleMouseUp() {
  isPressed = false;
}

function handleMouseDown() {
  isPressed = true;
}

/**
 * @type {(Function|undefined)}
 */
let clickHandler = undefined;

function handleClick() {
  if (clickHandler && typeof clickHandler === 'function') {
    clickHandler();
  }
}

/**
 * @param {(Function|undefined)} handler
 */
export function setClickHandler(handler) {
  clickHandler = handler;
}

canvas.addEventListener('mousemove', handleMouseMove);
canvas.addEventListener('mouseup', handleMouseUp);
canvas.addEventListener('mousedown', handleMouseDown);
canvas.addEventListener('click', handleClick);

document.addEventListener('keydown', (evt) => {
  pressedKeys.add(evt.code);
});
document.addEventListener('keyup', (evt) => {
  pressedKeys.delete(evt.code);
});

export let mx = 0;
export let my = 0;
export let isPressed = false;

'''
'''--- src/js/map.js ---
import {drawImage} from './canvas';

export function renderMap(sx, sy, map) {
  for (let y = 0; y < map.length; y++) {
    const row = map[y];
    for (let x = 0; x < row.length; x++) {
      const [type, element, color] = row[x].split('|');
      if (type === '-') {
        continue;
      }
      if (element === 'x') {
        // default stones
        if (type === 'f') {
          // floor
          drawImage('stones-grad', sx + x * 16, sy + y * 16);
        } else {
          drawImage('stones-d', sx + x * 16, sy + y * 16);
        }
        continue;
      }

      if (type === 'w') {
        // walls
        drawImage('wl-i' + element + '-' + color, sx + x * 16, sy + y * 16);
      }
      if (type === 'f') {
        // floor
        drawImage('flr-i' + element + '-' + color, sx + x * 16, sy + y * 16);
      }
    }
  }
}

'''
'''--- src/js/menu.js ---
import {renderBg} from './bg';
import {drawImage, drawText, width} from './canvas';
import {UITextButton} from './button';
import {GameState, gameState} from './state';
import {
  buyPremium,
  getUsersNearState,
  initNearGame,
  isLoggedInWithNear, isPremiumNear,
  loginWithNear, logoutNear
} from './near';
import {isSoundOn, toggleSound} from './sound';

/**
 * @enum {number}
 */
const MenuState = {
  DEFAULT: 0,
  NEAR: 10
};

export class Menu {
  constructor(onGameReset) {
    this.state = MenuState.DEFAULT;

    this.start = new UITextButton('Start New Game', width / 2, 120, 12, () => {
      gameState.reset();
      this.onGameReset();
      gameState.gameState = GameState.GAME;
    });
    this.continue = new UITextButton('Continue locally', width / 2, 170, 12, () => {
      gameState.reset();
      gameState.loadLocal();
      this.onGameReset();
      gameState.gameState = GameState.GAME;
    });

    this.loginAndContinue = new UITextButton('Login with NEAR', width / 2, 220, 12, async () => {
      await loginWithNear();
      if (isLoggedInWithNear()) {
        this.state = MenuState.NEAR;
      }
    });

    this.continueWithNear = new UITextButton('Continue with NEAR', width / 2, 220, 12, () => {
      this.state = MenuState.NEAR;
    });

    this.toggleSound = new UITextButton('Sound (' + (isSoundOn() ? 'On' : 'Off') + ')', width / 2, 270, 12, () => {
      toggleSound();
      this.toggleSound.text = 'Sound (' + (isSoundOn() ? 'On' : 'Off') + ')';
    });

    this.nearNew = new UITextButton('New Game', width / 3 - 30, 120, 12, () => {
      gameState.reset();
      this.onGameReset();
      gameState.gameState = GameState.GAME;
      this.state = MenuState.DEFAULT;
    });
    this.nearLoad = new UITextButton('Load Game from Near', width / 3 - 30, 180, 12, async () => {
      gameState.reset();
      await initNearGame();
      this.onGameReset();
      gameState.gameState = GameState.GAME;
      this.state = MenuState.DEFAULT;
    });
    this.localLoad = new UITextButton('Load locally saved', width / 3 - 30, 240, 12, async () => {
      gameState.reset();
      gameState.loadLocal();
      this.onGameReset();
      gameState.gameState = GameState.GAME;
    });
    this.buyPremium = new UITextButton('Go Premium', 2 * width / 3 + 30, 120, 12, async () => {
      await buyPremium();
      this.state = MenuState.DEFAULT;
    });

    this.nearView = new UITextButton('Try other player base', 2 * width / 3 + 30, 180, 12, async () => {
      try {
        const id = prompt('Enter wallet ID to load:');
        if (id) {
          const data = await getUsersNearState(id);
          if (data) {
            gameState.reset();
            gameState.loadFromNearState(data);
            this.onGameReset();
            gameState.gameState = GameState.GAME;
            this.state = MenuState.DEFAULT;
          } else {
            alert('No state found for ' + id);
          }
        }
      } catch (err) {
        console.warn(err);
      }
    });

    this.logout = new UITextButton('Logout', 2 * width / 3 + 30, 240, 12, () => {
      logoutNear();
    });

    this.onGameReset = onGameReset;

    this.hasStored = gameState.hasLocalStore();
  }

  renderNearSubMenu() {
    renderBg();
    drawText('Hades Defence', width / 2, 65, 40, '#f0f0f0');

    if (isPremiumNear) {
      drawImage('crown-c', width / 2 + 30, 110);
      drawText('Premium Tier', width / 2 + 50, 120, 16, '#fff', false);
    } else {
      this.buyPremium.render();
    }
    this.nearNew.render();
    this.nearLoad.render();
    this.nearView.render();
    this.localLoad.render();
    this.logout.render();
  }

  render() {
    if (this.state === MenuState.NEAR) {
      this.renderNearSubMenu();
      return;
    }

    renderBg();
    drawText('Hades Defence', width / 2, 65, 40, '#f0f0f0');

    this.toggleSound.render();
    this.start.render();
    if (this.hasStored) {
      this.continue.render();
    }
    if (isLoggedInWithNear()) {
      this.continueWithNear.render();
    } else {
      this.loginAndContinue.render();
    }
  }
}

'''
'''--- src/js/near.js ---
import {gameState} from './state';

const BrowserLocalStorageKeyStore = window['nearApi']?.['keyStores']?.['BrowserLocalStorageKeyStore'];

const config = {
  'networkId': 'testnet',
  'keyStore': BrowserLocalStorageKeyStore ? new BrowserLocalStorageKeyStore() : undefined,
  'nodeUrl': 'https://rpc.testnet.near.org',
  'walletUrl': 'https://wallet.testnet.near.org',
  'helperUrl': 'https://helper.testnet.near.org',
  'headers': {}
};

let near;
let wallet;
let contract;
export let isPremiumNear = false;

export async function initNearWallet() {
  try {
    near = await window['nearApi']['connect'](config);
    wallet = new window['nearApi']['WalletConnection'](near, null);
    contract = new window['nearApi']['Contract'](
      wallet['account'](), // the account object that is connecting
      'hades-dev.vilpy.testnet',
      {
        // name of contract you're connecting to
        'viewMethods': ['get_state'], // view methods do not change state but usually return a value
        'changeMethods': ['new', 'save_map', 'buy_premium'] // change methods modify state
      }
    );
    isPremiumNear = (await getCurrentNearState())?.['premium_user'] ?? false;
  } catch (e) {
    console.warn(e);
  }
}

export async function loginWithNear() {
  try {
    if (!isLoggedInWithNear()) {
      await wallet?.['requestSignIn']('hades-dev.vilpy.testnet', 'Hades Defence');
    }
  } catch (e) {
    console.warn(e);
  }
}

export function logoutNear() {
  try {
    wallet?.['signOut']();
    window.location.reload();
  } catch (e) {
    console.warn(e);
  }
}

export function isLoggedInWithNear() {
  return Boolean(wallet?.['isSignedIn']());
}

export async function getCurrentNearState() {
  if (!isLoggedInWithNear()) {
    return undefined;
  }
  return contract['get_state']({'account_id': wallet?.['getAccountId']()});
}

export async function getUsersNearState(userId) {
  if (!isLoggedInWithNear()) {
    return undefined;
  }
  return contract['get_state']({'account_id': userId});
}

export async function initNearGame() {
  let state = await getCurrentNearState();
  if (!state) {
    state = await contract['new']();
  }

  gameState.loadFromNearState(state);
}

export async function saveStateToNear(data) {
  await contract['save_map']({'data': data});
}

export async function buyPremium() {
  await contract['buy_premium']({}, undefined, '500000000000000000000000');
}

'''
'''--- src/js/objects/arcadian.js ---
import {Sprite} from '../sprite';
import {createArcadian} from '../texture-gen';

export class Arcadian {
  constructor(def, x, y, isPreview, id = -1) {
    this.def = def;
    this.x = x;
    this.y = y;
    this.arcadianId = id;
    createArcadian(id);

    const dy = isPreview ? 0 : -15;

    this.spr = new Sprite(['arcadian' + id], x - 5, y - 5 + dy);
  }

  render(dt) {
    this.spr.render(dt);
  }
}

'''
'''--- src/js/objects/barricade.js ---
import {Sprite} from '../sprite';
import {canvasCtx} from '../canvas';
import {upgradeMarkers} from '../utils';
import {gameState} from '../state';
import {playBuildSound} from '../sound';

export class Barricade {
  constructor(def, x, y) {
    this.def = def;
    this.x = x;
    this.y = y;
    this.level = Math.round((this.y - 16 * 3) / (16 * 5));
    this.spr = new Sprite(['ob-i1-c'], x, y);
    this.hp = 10;
    this.maxHp = this.hp;

    this.upgradeLevel = 1;
    this.maxUpgradeLevel = 6;

    this.canUpgrade = true;
  }

  getUpgradeCost() {
    const baseUpgradeCost = (this.def.upgradeCost ?? 30) / 100;
    return Number((this.def.cost * Math.pow(1 + baseUpgradeCost, this.upgradeLevel)).toFixed(1));
  }

  upgrade(isLoad = false) {
    const upgradeCost = this.getUpgradeCost();
    if (gameState.state.money < upgradeCost && !isLoad) {
      return;
    }
    if (!isLoad) {
      gameState.state.money -= upgradeCost;
      playBuildSound();
      gameState.updateMoodAndValue();
    }
    this.upgradeLevel++;
    this.canUpgrade = this.maxUpgradeLevel > this.upgradeLevel;
    this.hp += 8;
    this.maxHp += 8;
  }

  render(dt) {
    this.spr.render(dt);

    for (let i = 0; i < this.upgradeLevel - 1; i++) {
      const sx = this.x + 8 + upgradeMarkers[i][0];
      const sy = this.y + upgradeMarkers[i][1];
      canvasCtx.fillStyle = '#f0f000';
      canvasCtx.fillRect(sx, sy - 1, 1, 3);
      canvasCtx.fillRect(sx - 1, sy, 3, 1);
    }

    const healthPercentage = Math.max(0, this.hp / this.maxHp);
    if (healthPercentage < 1) {
      if (healthPercentage > 0.7) {
        canvasCtx.fillStyle = '#0f0';
      } else if (healthPercentage > 0.3) {
        canvasCtx.fillStyle = '#ff0';
      } else {
        canvasCtx.fillStyle = '#f00';
      }
      canvasCtx.fillRect(this.x + 3, this.y + 4, ~~(10 * healthPercentage), 1);
    }
  }
}

'''
'''--- src/js/objects/hpup.js ---
import {Sprite} from '../sprite';
import {gameSkeletons} from './skeletons';
import {gameState} from '../state';
import {upgradeMarkers} from '../utils';
import {canvasCtx} from '../canvas';
import {playBuildSound} from '../sound';

export class HPUp {
  constructor(def, x, y) {
    this.def = def;
    this.x = x;
    this.y = y;
    this.level = Math.round((this.y - 16 * 3) / (16 * 5));

    this.spr = new Sprite(['hpup-c'], x, y);

    this.upgradeLevel = 1;
    this.maxUpgradeLevel = 6;

    this.canUpgrade = true;
  }

  getUpgradeCost() {
    const baseUpgradeCost = (this.def.upgradeCost ?? 30) / 100;
    return Number((this.def.cost * Math.pow(1 + baseUpgradeCost, this.upgradeLevel)).toFixed(1));
  }

  upgrade(isLoad = false) {
    const upgradeCost = this.getUpgradeCost();
    if (gameState.state.money < upgradeCost && !isLoad) {
      return;
    }
    if (!isLoad) {
      gameState.state.money -= upgradeCost;
      playBuildSound();
      gameState.updateMoodAndValue();
    }
    this.upgradeLevel++;
    this.canUpgrade = this.maxUpgradeLevel > this.upgradeLevel;
  }

  update(dt) {
    gameSkeletons.skeletons.forEach((sk) => {
      if (sk.level === this.level && sk.hp > 0 && sk.hp < sk.maxHp && Math.abs(sk.spr.x - this.x) < 32) {
        sk.hp = Math.min(sk.maxHp, sk.hp + dt * 0.1 * this.upgradeLevel);
      }
    });

    if (gameState.state.playerPosition.y === this.level) {
      if (Math.abs(gameState.state.playerPosition.x - this.x) < 32) {
        gameState.state.playerHealth = Math.min(gameState.playerMaxHealth, gameState.state.playerHealth + dt * this.upgradeLevel / 2);
      }
    }
  }

  render(dt) {
    this.update(dt);
    this.spr.render(dt);

    for (let i = 0; i < this.upgradeLevel - 1; i++) {
      const sx = this.x + 8 + upgradeMarkers[i][0];
      const sy = this.y + upgradeMarkers[i][1];
      canvasCtx.fillStyle = '#f0f000';
      canvasCtx.fillRect(sx, sy - 1, 1, 3);
      canvasCtx.fillRect(sx - 1, sy, 3, 1);
    }
  }
}

'''
'''--- src/js/objects/lamp.js ---
import {AnimationMode, Sprite} from '../sprite';

export class Lamp {
  constructor(def, x, y, isPreview) {
    this.def = def;
    this.x = x;
    this.y = y;

    const dy = isPreview ? 0 : -16 * 2;

    this.lightSpr = new Sprite(['lgth-c-i0', 'lgth-c-i1', 'lgth-c-i2'], x - 1, y + dy - 5, 10, AnimationMode.RANDOM);
    this.fl = new Sprite(['lmp-c'], x - 1, y + dy + 1);
  }

  render(dt) {
    this.lightSpr.render(dt);
    this.fl.render(dt);
  }
}

'''
'''--- src/js/objects/light.js ---
import {Fire} from '../fire';

export class Light {
  constructor(def, x, y, isPreview) {
    this.def = def;
    this.x = x;
    this.y = y;

    const dy = isPreview ? 0 : -15;

    this.fl = new Fire(x, y + dy);
  }

  render(dt) {
    this.fl.render(dt);
  }
}

'''
'''--- src/js/objects/painting.js ---
import {Sprite} from '../sprite';

export class SoulPainting {
  constructor(def, x, y, isPreview, sprite) {
    this.def = def;
    this.x = x;
    this.y = y;

    const dy = isPreview ? 0 : -15;

    this.spr = new Sprite([sprite], x - 5, y - 5 + dy);
  }

  render(dt) {
    this.spr.render(dt);
  }
}

'''
'''--- src/js/objects/skeletons.js ---
import {Sprite} from '../sprite';
import {Walker} from '../walker';
import {canvasCtx} from '../canvas';
import {Enemy} from '../enemy';
import {upgradeMarkers} from '../utils';
import {GlobalConfig} from '../config';
import {gameState} from '../state';
import {playBuildSound} from '../sound';

export class Skeleton {
  constructor(x, level) {
    this.startX = x;
    this.dx = this.startX + Math.random() * 32 - 16;
    this.level = level;
    this.hp = 10;
    this.maxHp = 10;
    this.spr = new Walker(['sk-i1', 'sk-i2', 'sk-i0'], x, this.level, 32);
    this.spr.walkTo(this.dx);
    this.recharge = 0;
    /**
     * @type {(Enemy|undefined)}
     */
    this.enemy = undefined;
  }

  update(dt) {
    if (this.enemy && (this.enemy.health <= 0 || this.enemy.sprite.currentLevel !== this.level)) {
      this.enemy = undefined;
    }

    this.recharge -= dt;
    if (this.enemy) {
      const isNear = Math.abs(this.spr.x - this.enemy.sprite.x) < 6;
      const canAttack = this.recharge <= 0;
      if (isNear && canAttack) {
        this.enemy.health -= GlobalConfig.SKELETON_DAMAGE;
        this.recharge = GlobalConfig.SKELETON_RECHARGE_TIME;
      }
      if (isNear) {
        this.spr.stop();
      } else {
        this.spr.walkTo(this.enemy.sprite.x);
      }
    } else {
      this.spr.walkTo(this.dx);
    }
  }

  render(dt) {
    this.update(dt);
    this.spr.render(dt);
    const healthPercentage = Math.max(0, this.hp / this.maxHp);
    if (healthPercentage < 1) {
      if (healthPercentage > 0.7) {
        canvasCtx.fillStyle = '#0f0';
      } else if (healthPercentage > 0.3) {
        canvasCtx.fillStyle = '#ff0';
      } else {
        canvasCtx.fillStyle = '#f00';
      }
      canvasCtx.fillRect(this.spr.sprite.x + 3, this.spr.sprite.y, ~~(10 * healthPercentage), 1);
    }
  }
}

export class SkeletonManager {
  constructor() {
    /** @type {Array<Skeleton>} */
    this.skeletons = [];
  }

  add(x, level) {
    const newSkeleton = new Skeleton(x, level);
    this.skeletons.push(newSkeleton);
    return newSkeleton;
  }

  cleanup() {
    this.skeletons = this.skeletons.filter((s) => s.hp > 0);
  }
}

export const gameSkeletons = new SkeletonManager();

export class Skeletons {
  constructor(def, x, y, isPreview) {
    this.def = def;
    this.isPreview = isPreview;
    this.x = x;
    this.y = y;
    this.level = Math.round((this.y - 16 * 3) / (16 * 5));

    this.hp = [];

    this.base = new Sprite(['ob-i2'], x, y);
    /**
     * @type {Array<Skeleton>}
     */
    this.skeletons = [];
    this.skeletonRecharges = [];

    this.upgradeLevel = 1;
    this.maxUpgradeLevel = 6;

    this.canUpgrade = true;
  }

  getUpgradeCost() {
    const baseUpgradeCost = (this.def.upgradeCost ?? 30) / 100;
    return Number((this.def.cost * Math.pow(1 + baseUpgradeCost, this.upgradeLevel)).toFixed(1));
  }

  upgrade(isLoad = false) {
    const upgradeCost = this.getUpgradeCost();
    if (gameState.state.money < upgradeCost && !isLoad) {
      return;
    }
    if (!isLoad) {
      gameState.state.money -= upgradeCost;
      playBuildSound();
      gameState.updateMoodAndValue();
    }
    this.upgradeLevel++;
    this.canUpgrade = this.maxUpgradeLevel > this.upgradeLevel;
  }

  render(dt) {
    this.base.render(dt);
    for (let i = 0; i < this.upgradeLevel - 1; i++) {
      const sx = this.x + 8 + upgradeMarkers[i][0];
      const sy = this.y + upgradeMarkers[i][1];
      canvasCtx.fillStyle = '#f0f000';
      canvasCtx.fillRect(sx, sy - 1, 1, 3);
      canvasCtx.fillRect(sx - 1, sy, 3, 1);
    }

    if (this.isPreview) {
      return;
    }

    this.skeletons.forEach(sk => {
      sk.render(dt);
    });
    const init = this.skeletons.length;
    this.skeletons = this.skeletons.filter((sk) => sk.hp > 0);
    const newLength = this.skeletons.length;
    for (let i = 0; i < init - newLength; i++) {
      this.skeletonRecharges.push(50);
    }

    const maxSkeletons = this.upgradeLevel;
    const canAddSkeletons = Math.max(0, maxSkeletons - this.skeletons.length - this.skeletonRecharges.length);
    for (let i = 0; i < canAddSkeletons; i++) {
      const sk = gameSkeletons.add(this.x, this.level);
      this.skeletons.push(sk);
    }

    for (let i = 0; i < this.skeletonRecharges.length; i++) {
      this.skeletonRecharges[i] -= dt;
    }
    this.skeletonRecharges = this.skeletonRecharges.filter((r) => r >= 0);
  }
}

'''
'''--- src/js/objects/tower-a.js ---
import {Fire} from '../fire';
import {Sprite} from '../sprite';
import {gameState} from '../state';
import {EnemyState} from '../enemy';
import {particleManager} from '../particles';
import {playBuildSound, playShoot} from '../sound';
import {sortDist, upgradeMarkers} from '../utils';
import {canvasCtx} from '../canvas';

const distDelta = [0, 0, 32, 32, 64, 80];
const rechargeDelta = [1, 2, 2, 3, 3, 5];

export class TowerA {
  constructor(def, x, y) {
    this.def = def;
    this.x = x;
    this.y = y;
    this.level = Math.round((this.y - 16 * 3) / (16 * 5));
    this.base = new Sprite(['ob-i0-c'], x, y);
    this.fire = new Fire(x - 1, y - 2);

    this.recharge = 0;

    this.upgradeLevel = 1;
    this.maxUpgradeLevel = 6;

    this.canUpgrade = true;
  }

  getUpgradeCost() {
    const baseUpgradeCost = (this.def.upgradeCost ?? 30) / 100;
    return Number((this.def.cost * Math.pow(1 + baseUpgradeCost, this.upgradeLevel)).toFixed(1));
  }

  upgrade(isLoad = false) {
    const upgradeCost = this.getUpgradeCost();
    if (gameState.state.money < upgradeCost && !isLoad) {
      return;
    }
    if (!isLoad) {
      gameState.state.money -= upgradeCost;
      playBuildSound();
      gameState.updateMoodAndValue();
    }
    this.upgradeLevel = Math.min(this.upgradeLevel + 1, this.maxUpgradeLevel);
    this.canUpgrade = this.maxUpgradeLevel > this.upgradeLevel;
  }

  update(dt) {
    this.recharge -= dt;

    const dist = 64 + distDelta[this.upgradeLevel - 1];

    const targets = gameState.enemies.filter((enemy) => {
      return enemy.state !== EnemyState.APPEAR
        && enemy.state !== EnemyState.BLEND
        && enemy.sprite.currentLevel === this.level
        && Math.abs(enemy.sprite.x + 8 - this.x + 8) < dist;
    });
    const [target] = targets.sort((a, b) => sortDist(this.x, a, b));
    if (this.recharge <= 0 && target) {
      this.recharge = 1 / rechargeDelta[this.upgradeLevel - 1];
      playShoot();
      particleManager.add(this.x + 7, this.y + 2, target, '#fff000', 2);
    }
  }

  render(dt) {
    this.update(dt);

    this.base.render(dt);
    this.fire.render(dt);

    for (let i = 0; i < this.upgradeLevel - 1; i++) {
      const sx = this.x + 8 + upgradeMarkers[i][0];
      const sy = this.y + upgradeMarkers[i][1];
      canvasCtx.fillStyle = '#f0f000';
      canvasCtx.fillRect(sx, sy - 1, 1, 3);
      canvasCtx.fillRect(sx - 1, sy, 3, 1);
    }
  }
}

'''
'''--- src/js/particles.js ---
import {canvasCtx} from './canvas';

export class Particles {
  constructor() {
    this.particles = [];
  }

  add(x, y, target, color, dmg) {
    this.particles.push({
      sx: x, sy: y, x, y, target, color, dmg, lvl: Math.round((y - 16 * 3) / (16 * 5))
    });
  }

  render(dt) {
    this.particles = this.particles.filter((p) => {
      const tx = p.target.sprite.x + 8;
      const ty = p.target.sprite.y + 8;
      const distSq = Math.pow(p.x - tx, 2) + Math.pow(p.y - ty, 2);
      const isHit = distSq < 9;
      canvasCtx.fillStyle = p.color;
      canvasCtx.fillRect(p.x - 1, p.y - 1, 2, 2);
      const perc = Math.abs(p.x - tx) / Math.abs(p.sx - tx);
      p.x += dt * Math.sign(tx - p.x) * 64;
      p.y = p.sy + (ty - p.sy) * (1 - perc);

      const differentLevels = p.lvl !== p.target.sprite.currentLevel;
      const isDead = p.target.health <= 0;

      if (isHit) {
        p.target.health -= p.dmg;
      }

      return !isHit && !differentLevels && !isDead;
    });
  }
}

export const particleManager = new Particles();

'''
'''--- src/js/resources.js ---
/**
 * @typedef {{
 *   img: (HTMLImageElement|HTMLCanvasElement),
 *   x: number,
 *   y: number,
 *   w: number,
 *   h: number,
 * }}
 */
var ImageResource;

class ResourceLoader {

  constructor() {
    /** @private Map<string, ImageResource> */
    this.images = new Map();
  }

  /**
   * @param {string} path
   * @param {Array<{n: string, x: number, y: number, w: number, h: number}>} data
   */
  loadImages(path, data) {
    return new Promise((res) => {
      const img = new Image();
      img.onload = () => {
        data.forEach((entry) => {
          const {x, y} = entry;
          this.images.set(entry.n, {img, x, y, w: 16, h: 16});
        });
        res();
      };
      img.src = path;
    });
  }

  /**
   * @param {string} path
   * @param {CanvasImageSource} image
   * @param {number} x
   * @param {number} y
   * @param {number} w
   * @param {number} h
   */
  addImage(path, image, x, y, w, h) {
    this.images.set(path, {img: image, x, y, w, h});
  }

  /**
   * @param {string} path
   */
  getImage(path) {
    return this.images.get(path);
  }

}

export const appResourceLoader = new ResourceLoader();

'''
'''--- src/js/sound.js ---
import {zzfx} from './zzfx';

const SOUND_LOCAL_KEY = 'hades_sound';

export function isSoundOn() {
  const current = window.localStorage.getItem(SOUND_LOCAL_KEY);
  return !current || current === 'true';
}

export function toggleSound() {
  window.localStorage.setItem(SOUND_LOCAL_KEY, (!isSoundOn()).toString());
}

export function playShoot() {
  if (!isSoundOn()) return;
  zzfx(...[0.4, , 71, .01, .07, .05, 1, 1.92, -7.9, -0.7, , , , , , , .08, .98, .04]);
}

export function playElevate() {
  if (!isSoundOn()) return;
  zzfx(...[0.2,,905,.01,,.23,,1.11,,,,,,.1,-0.1,,,.18,.01]);
}

export function playGameOver() {
  if (!isSoundOn()) return;
  zzfx(...[,,570,.05,.22,.3,,1.11,-5.5,,-75,.1,.07,,,,,.54,.16]);
}

export function playBuildSound() {
  if (!isSoundOn()) return;
  zzfx(...[0.2,,42,,.02,.05,3,.15,3.6,,,,,2,,,,.78,.08]);
}

export function playWave() {
  if (!isSoundOn()) return;
  zzfx(...[0.7,,386,.06,.19,.35,2,1.56,4.1,-2.3,,,.14,,,,.01,.97,.1,.48]);
}

export function playClick() {
  if (!isSoundOn()) return;
  zzfx(...[0.5,,521,.01,.01,.01,2,.75,12,34,-262,,,,,,,,.01,.05]);
}

'''
'''--- src/js/sprite-prep.js ---
import {loadSpriteSet} from './spriteset';
import {blendSprites, colorPattern, createPainting, flipSprite, rainbowSprite} from './texture-gen';
import {TileGrade} from './tiles';

function prepareFrames() {
  [['b', 'rgb(247,226,107)'], ['p', 'rgb(190,38,51)']].forEach(([name, color]) => {
    colorPattern('brd4', `brd2-${name}-i1`, color);
    flipSprite(`brd2-${name}-i1`, false, true, 0, `brd2-${name}-i7`);
    flipSprite(`brd2-${name}-i1`, false, false, -Math.PI / 2, `brd2-${name}-i3`);
    flipSprite(`brd2-${name}-i1`, false, false, Math.PI / 2, `brd2-${name}-i5`);

    [0, 2, 6, 8].forEach((i) => {
      colorPattern('crn4', `brd2-${name}-i${i}`, color);
    });
    flipSprite(`brd2-${name}-i2`, false, false, Math.PI / 2, `brd2-${name}-i2`);
    flipSprite(`brd2-${name}-i2`, false, false, Math.PI / 2, `brd2-${name}-i8`);
    flipSprite(`brd2-${name}-i8`, false, false, Math.PI / 2, `brd2-${name}-i6`);
  });

  [0, 2, 6, 8].forEach((i) => {
    colorPattern('crn1', `brd1-b-i${i}`, 'rgb(247,226,107)', 'rgb(38,38,38)');
  });
  colorPattern('brd3', 'brd1-b-i1', 'rgb(247,226,107)', 'rgb(38,38,38)');
  colorPattern('brd3', 'brd1-b-i7', 'rgb(247,226,107)', 'rgb(38,38,38)');
  flipSprite('brd1-b-i1', false, false, Math.PI / 2, 'brd1-b-i3');
  flipSprite('brd1-b-i1', false, false, -Math.PI / 2, 'brd1-b-i5');
}

function prepareCharacters() {
  // Charon
  colorPattern('ch-i0', 'chA', 'rgb(142,168,185)', undefined, 0.5);
  colorPattern('ch-i1', 'chB', 'rgb(142,168,185)', undefined, 0.5);

  // Base soul
  colorPattern('soul', 'soul-base', 'rgb(213,213,213)', undefined, 0.3);

  // hero
  for (let i = 0; i < 3; i++) {
    colorPattern('hr-i' + i, 'hr-c-i' + i, 'rgb(255,231,231)');
  }

  // monster
  for (let i = 0; i < 3; i++) {
    colorPattern('m-i' + i, 'm-c-i' + i, 'rgb(255,0,0)');
  }
}

function prepareObjects() {
  // Light
  for (let i = 0; i < 3; i++) {
    colorPattern(`light-i${i}`, `lgth-c-i${i}`, 'rgb(247,226,107)', undefined, 0.15);
  }

  // Flame
  for (let i = 0; i < 6; i++) {
    colorPattern(`flame-i${i}`, `flm-c-i${i}`, 'rgb(190,38,51)');
  }

  // Gate
  colorPattern('gate', 'gate-c', 'rgb(164,100,34)');

  // Water
  colorPattern('water', 'water-c', 'rgb(0,87,132)', 'rgb(178,220,239)');
  blendSprites('water-c', 'grad', 'water-c');

  // tower A
  colorPattern('ob-i0', 'ob-i0-c', 'rgb(164,100,34)');
  // block A
  colorPattern('ob-i1', 'ob-i1-c', 'rgb(100,67,58)');

  colorPattern('lmp', 'lmp-c', 'rgb(247,226,107)');
  colorPattern('hpup', 'hpup-c', 'rgb(142,168,185)');

  colorPattern('crown', 'crown-c', 'rgb(247,226,107)');
  colorPattern('money', 'money-c', 'rgb(247,226,107)');
  colorPattern('hp', 'hp-c', 'rgb(190,38,51)');
  colorPattern('expnd', 'expnd-c', 'rgb(247,226,107)');
  colorPattern('pnt', 'pnt-c', 'rgb(255,52,69)');
  colorPattern('bld', 'bld-c', 'rgb(178,220,239)');
  colorPattern('up', 'up-c', 'rgb(93,253,0)');

  createPainting('soul', 'soul-paint');
  createPainting('sk-i1', 'sk-paint');
  createPainting('hds-i1', 'hds-paint');
}

export async function prepareSprites() {
  await loadSpriteSet();

  prepareFrames();
  prepareCharacters();
  prepareObjects();

  colorPattern('stones', 'stones-d', 'rgb(86,86,86)');
  colorPattern('brick', 'brick-b', 'rgb(58,58,58)', 'rgb(86,86,86)');
  colorPattern('brick', 'brick-d', 'rgb(33,33,33)', 'rgb(86,86,86)');

  blendSprites('stones-d', 'grad', 'stones-grad');

  const wallPallets = [
    [TileGrade.NORMAL, 'rgb(201,201,201)', 0.1],
    [TileGrade.DARK, 'rgb(164,100,34)', 0.2],
    [TileGrade.LIGHT, 'rgb(59,197,255)', 0.2],
    [TileGrade.HELLISH, 'rgb(255,52,69)', 0.2],
    [TileGrade.SHINING, 'rgb(255,242,0)', 0.3],
    [TileGrade.GREEN, 'rgb(93,253,0)', 0.2],
    [TileGrade.PONY, '', 0.3]
  ];
  wallPallets.forEach(([type, color, alpha]) => {
    for (let i = 0; i < 4; i++) {
      if (type === TileGrade.PONY) {
        rainbowSprite('wl-i' + i, 'wl-i' + i + '-' + type, alpha);
      } else {
        colorPattern('wl-i' + i, 'wl-i' + i + '-' + type, color, undefined, alpha);
      }
    }
  });

  const floorPallets = [
    [TileGrade.NORMAL, 'rgb(107,107,107)'],
    [TileGrade.DARK, 'rgb(73,60,43)'],
    [TileGrade.LIGHT, 'rgb(49,162,242)'],
    [TileGrade.HELLISH, 'rgb(190,38,51)'],
    [TileGrade.SHINING, 'rgb(247,226,107)'],
    [TileGrade.GREEN, 'rgb(68,137,26)'],
    [TileGrade.PONY, '']
  ];
  floorPallets.forEach(([type, color]) => {
    for (let i = 0; i < 4; i++) {
      const tname = 'flr-i' + i + '-' + type;
      if (type === TileGrade.PONY) {
        rainbowSprite('flr-i' + i, tname);
      } else {
        colorPattern('flr-i' + i, tname, color);
      }

    }
  });
} 

'''
'''--- src/js/sprite.js ---
import {drawImage} from './canvas';
import {shuffle} from './utils';

/**
 * @enum {number}
 */
export const AnimationMode = {
  CONT: 1,
  CONT_PING: 2,
  RANDOM: 3
};

export class Sprite {
  /**
   * @param {Array<string>} frames
   * @param {number} x
   * @param {number} y
   * @param {number} animSpeed
   * @param {AnimationMode} mode
   */
  constructor(frames, x, y, animSpeed = 1, mode = AnimationMode.CONT) {
    this.frames = frames;
    this.x = x;
    this.y = y;
    this.currentFrame = 0;

    this.isAnimated = true;

    this.frameIdx = [0];
    this.mode = mode;
    this.animSpeed = animSpeed;

    this.setAnimation();

    this.isFlipped = false;

    this.alpha = 1;
  }

  startAnimation() {
    this.isAnimated = true;
  }

  stopAnimation() {
    this.isAnimated = false;
    this.currentFrame = 0;
  }

  setAlpha(alpha) {
    this.alpha = alpha;
  }

  setFlip(flip) {
    this.isFlipped = flip;
  }

  setAnimation() {
    switch (this.mode) {
    case AnimationMode.CONT: {
      this.frameIdx = this.frames.map((_, index) => index);
      break;
    }
    case AnimationMode.CONT_PING: {
      const indices = this.frames.map((_, index) => index);
      this.frameIdx = [...indices, [...indices].reverse()];
      break;
    }
    case AnimationMode.RANDOM: {
      const indices = this.frames.map((_, index) => index);
      shuffle(indices);
      this.frameIdx = indices;
      break;
    }
    }
  }

  update(dt) {
    if (this.frameIdx.length === 1) {
      return;
    }

    if (this.isAnimated) {
      this.currentFrame += this.animSpeed * dt;
      if (this.currentFrame >= this.frameIdx.length) {
        this.currentFrame = 0;
        if (this.mode === AnimationMode.RANDOM) {
          this.setAnimation();
        }
      }
    }
  }

  render(dt) {
    this.update(dt);
    if (this.alpha <= 0) {
      return;
    }
    const spr = this.frames[this.frameIdx[~~this.currentFrame]];
    drawImage(spr, ~~this.x, ~~this.y, this.isFlipped, undefined, this.alpha);
  }
}

export class SpriteGroup {
  /**
   * @param {number} x
   * @param {number} y
   */
  constructor(x, y) {
    /**
     * @type {number}
     */
    this.x = x;

    /**
     * @type {number}
     */
    this.y = y;

    /**
     * @type {Array<{spr: Sprite, x: number, y: number}>}
     */
    this.sprites = [];

    /**
     * @type {boolean}
     */
    this.isFlipped = false;
  }

  setFlip(flag) {
    this.isFlipped = flag;
    this.sprites.forEach((spr) => spr.spr.setFlip(flag));
  }

  addSprite(spr, x, y) {
    this.sprites.push({
      spr, x, y
    });
  }

  render(dt) {
    this.sprites.forEach((entry) => {
      if (this.isFlipped) {
        entry.spr.x = this.x - entry.x;
        entry.spr.y = this.y - entry.y;
        entry.spr.render(dt);
      } else {
        entry.spr.x = this.x + entry.x;
        entry.spr.y = this.y + entry.y;
        entry.spr.render(dt);
      }
    });
  }
}

'''
'''--- src/js/spriteset.js ---
import {appResourceLoader} from './resources';
import {spriteData} from '../generated/sprite-data';

export async function loadSpriteSet() {
  return appResourceLoader.loadImages('./hades.webp', spriteData);
}

'''
'''--- src/js/state-ext.js ---
import {genDefaultMap, MapArea} from './utils';
import {Arcadian} from './objects/arcadian';
import {createObject, Objects} from './tiles';
import {isPremiumNear, saveStateToNear} from './near';

export const LOCAL_STORAGE_KEY = 'hades_state';

function mapObject(obj) {
  if (!obj) {
    return [];
  }
  if (obj instanceof Arcadian) {
    return [obj.def.id, obj.x, obj.y, obj.arcadianId];
  } else {
    return [obj.def.id, obj.x, obj.y, obj.upgradeLevel ?? 0];
  }
}

function parseObject(obj) {
  const [id, x, y, meta] = obj;
  const def = Objects.find((def) => def.id === id);
  if (!def) {
    return null;
  }

  if (def.isArcadian) {
    return createObject(def, x, y, false, meta);
  } else {
    const newObject = createObject(def, x, y, false);
    if (newObject.canUpgrade) {
      for (let i = 1; i < meta; i++) {
        newObject.upgrade(true);
      }
    }
    return newObject;
  }
}

export class StateExt {
  constructor() {
    const tartarDefMap = genDefaultMap(31, 4);
    const elysiumDefMap = genDefaultMap(31, 4);
    const asphodelDefMap = genDefaultMap(31, 4);

    const cleanArea = 10;

    for (let y = 0; y < 4; y++) {
      for (let x = 0; x < cleanArea; x++) {
        if (y === 3) {
          elysiumDefMap[y][x] = 'f|0|n';
          tartarDefMap[y][x] = 'f|0|n';
          asphodelDefMap[y][x] = 'f|0|n';
        } else {
          elysiumDefMap[y][x] = 'w|0|n';
          tartarDefMap[y][x] = 'w|0|n';
          asphodelDefMap[y][x] = 'w|0|n';
        }
      }
    }

    for (let x = cleanArea; x < 31; x++) {
      elysiumDefMap[2][x] = 'w|0|n';
      tartarDefMap[2][x] = 'w|0|n';
    }

    for (let x = 0; x < 3; x++) {
      asphodelDefMap[3][x] = '-';
    }

    this.playerPosition = {x: 64, y: 1};
    this.score = 0;
    this.souls = 0;
    this.playerHealth = 100;
    this.time = 0;
    this.money = isPremiumNear ? 100 : 10;
    this.monsterInvasions = 0;
    this.area = {
      [MapArea.TARTAR]: {
        souls: 0, map: tartarDefMap, objects: tartarDefMap[0].map(() => null)
      }, [MapArea.ASPHODEL]: {
        souls: 0, map: asphodelDefMap, objects: asphodelDefMap[0].map(() => null)
      }, [MapArea.ELYSIUM]: {
        souls: 0, map: elysiumDefMap, objects: asphodelDefMap[0].map(() => null)
      }
    };
  }

  stringify() {
    return JSON.stringify({
      'pp': {'x': this.playerPosition.x, 'y': this.playerPosition.y},
      'score': this.score,
      'ph': this.playerHealth,
      'time': this.time,
      'money': this.money,
      'souls': this.souls,
      'mi': this.monsterInvasions,
      [MapArea.TARTAR]: {
        'map': this.area[MapArea.TARTAR].map,
        'obj': this.area[MapArea.TARTAR].objects.map(mapObject)
      },
      [MapArea.ASPHODEL]: {
        'map': this.area[MapArea.ASPHODEL].map,
        'obj': this.area[MapArea.ASPHODEL].objects.map(mapObject)
      },
      [MapArea.ELYSIUM]: {
        'map': this.area[MapArea.ELYSIUM].map,
        'obj': this.area[MapArea.ELYSIUM].objects.map(mapObject)
      }
    });
  }

  restoreFromString(dataStr) {
    if (!dataStr) {
      return;
    }

    try {
      const json = JSON.parse(dataStr);
      this.playerPosition.x = json['pp']['x'];
      this.playerPosition.y = json['pp']['y'];
      this.score = json['score'] ?? 0;
      this.playerHealth = json['ph'] ?? 100;
      this.time = json['time'] ?? 0;
      this.souls = json['souls'] ?? 0;
      this.money = json['money'] ?? 10;
      this.monsterInvasions = json['mi'] ?? 0;
      this.area[MapArea.TARTAR].map = json[MapArea.TARTAR]['map'];
      this.area[MapArea.TARTAR].objects = json[MapArea.TARTAR]['obj'].map(parseObject);
      this.area[MapArea.ASPHODEL].map = json[MapArea.ASPHODEL]['map'];
      this.area[MapArea.ASPHODEL].objects = json[MapArea.ASPHODEL]['obj'].map(parseObject);
      this.area[MapArea.ELYSIUM].map = json[MapArea.ELYSIUM]['map'];
      this.area[MapArea.ELYSIUM].objects = json[MapArea.ELYSIUM]['obj'].map(parseObject);
    } catch (err) {
      console.warn('Tried to load broken state');
    }
  }

  saveLocal() {
    window.localStorage.setItem(LOCAL_STORAGE_KEY, this.stringify());
  }

  loadLocal() {
    const storedState = window.localStorage.getItem(LOCAL_STORAGE_KEY);
    if (storedState) {
      this.restoreFromString(storedState);
    }
  }

  saveNear() {
    return saveStateToNear(this.stringify());
  }
}

'''
'''--- src/js/state.js ---
import {MapArea} from './utils';
import {Enemy} from './enemy';
import {TileGrade, Tiles} from './tiles';
import {GlobalConfig} from './config';
import {StateExt, LOCAL_STORAGE_KEY} from './state-ext';

/**
 * @enum {number}
 */
export const GameState = {
  MENU: 0,
  GAME: 10,
};

class State {
  constructor() {
    this.gameState = GameState.MENU;

    this.state = this.getEmptyState();
    this.maxTartarArea = this.getMapMaxLen(MapArea.TARTAR);
    this.maxAsphodelArea = this.getMapMaxLen(MapArea.ASPHODEL);
    this.maxElysiumArea = this.getMapMaxLen(MapArea.ELYSIUM);

    this.sound = true;

    /**
     * @type {Array<Enemy>}
     */
    this.enemies = [];

    this.mood = 0;
    this.value = 0;
    this.playerMaxHealth = 100;
    this.playerRechargeTime = 1;
    this.playerDamage = 2;
  }

  reset() {
    this.gameState = GameState.MENU;

    this.state = this.getEmptyState();
    this.maxTartarArea = this.getMapMaxLen(MapArea.TARTAR);
    this.maxAsphodelArea = this.getMapMaxLen(MapArea.ASPHODEL);
    this.maxElysiumArea = this.getMapMaxLen(MapArea.ELYSIUM);

    this.enemies = [];

    this.mood = 0;
    this.value = 0;
    this.playerMaxHealth = 100;
    this.playerRechargeTime = 1;
    this.playerDamage = 2;
  }

  getScore() {
    return 0;
  }

  getMapMaxLen(area) {
    const index = this.state.area[area].map[0].findIndex(entry => entry.split('|')[1] === 'x');
    if (index === -1) {
      return this.state.area[area].map[0].length;
    }
    return index;
  }

  recalc() {
    this.maxTartarArea = this.getMapMaxLen(MapArea.TARTAR);
    this.maxAsphodelArea = this.getMapMaxLen(MapArea.ASPHODEL);
    this.maxElysiumArea = this.getMapMaxLen(MapArea.ELYSIUM);
  }

  getEmptyState() {
    return new StateExt();
  }

  updateMoodAndValue() {
    let totalObjectValue = 0;
    let totalObjectMood = 0;
    [
      ...this.state.area[MapArea.ELYSIUM].objects,
      ...this.state.area[MapArea.ASPHODEL].objects,
      ...this.state.area[MapArea.TARTAR].objects
    ].forEach((obj) => {
      totalObjectValue += obj?.def?.value ?? 0;
      totalObjectMood += obj?.def?.mood ?? 0;
    });

    let totalTilesValue = 0;
    let totalTilesMood = 0;
    [
      ...this.state.area[MapArea.ELYSIUM].map,
      ...this.state.area[MapArea.ASPHODEL].map,
      ...this.state.area[MapArea.TARTAR].map
    ].flat().forEach(entry => {
      const [type, id, grade] = (entry ?? '').split('|');
      if (id === 'x' || type === '-') {
        return;
      }

      let tile = undefined;
      if (type === 'w') {
        tile = Tiles.WALLS[id];
      } else {
        tile = Tiles.FLOORS[id];
      }

      const mood = (grade === TileGrade.NORMAL) ? tile.mood : Math.max(tile.mood, 0.5);
      const value = (grade === TileGrade.NORMAL) ? tile.value : Math.max(tile.value, 0.5);
      const tileBaseValue = (GlobalConfig.TILE_GRADE_MULTIPLIER[grade] ?? 0) * (value ?? 0);
      totalTilesValue += tileBaseValue ?? 0;
      const tileBaseMood = (GlobalConfig.TILE_GRADE_MULTIPLIER[grade] ?? 0) * (mood ?? 0);
      totalTilesMood += tileBaseMood ?? 0;
    });

    this.value = totalObjectValue + totalTilesValue;
    this.mood = totalObjectMood + totalTilesMood;
    this.value -= Math.min(this.state.souls * GlobalConfig.SOUL_VALUE_DROP, 3000);
    this.mood -= Math.min(this.state.souls * GlobalConfig.SOUL_MOOD_DROP, 3000);

    if (this.mood < 0) {
      this.playerMaxHealth = 100 / (1 + (Math.abs(this.mood) / 100) * GlobalConfig.MOOD_HEALTH_MULTIPLIER);
      this.playerRechargeTime = 1 * (1 + (Math.abs(this.mood) / 100) * GlobalConfig.MOOD_RECHARGE_MULTIPLIER);
      this.playerDamage = 2 / (1 + (Math.abs(this.mood) / 100) * GlobalConfig.MOOD_DAMAGE_MULTIPLIER);
    } else {
      this.playerMaxHealth = 100 * (1 + (this.mood / 100) * GlobalConfig.MOOD_HEALTH_MULTIPLIER);
      this.playerRechargeTime = 1 / (1 + (this.mood / 100) * GlobalConfig.MOOD_RECHARGE_MULTIPLIER);
      this.playerDamage = 2 * (1 + (this.mood / 100) * GlobalConfig.MOOD_DAMAGE_MULTIPLIER);
    }
  }

  getExtendPrice(area) {
    const x = this.getMapMaxLen(area);
    return Math.floor(2 * Math.pow(1.2, x - 10));
  }

  extend(area) {
    const x = this.getMapMaxLen(area);
    for (let y = 0; y < 4; y++) {
      if (y === 3) {
        this.state.area[area].map[y][x] = 'f|0|n';
      } else {
        this.state.area[area].map[y][x] = 'w|0|n';
      }
    }
    this.recalc();
  }

  saveLocal() {
    this.state.saveLocal();
  }

  hasLocalStore() {
    return Boolean(window.localStorage.getItem(LOCAL_STORAGE_KEY));
  }

  loadLocal() {
    this.state.loadLocal();
    this.updateMoodAndValue();
    this.recalc();
  }

  loadFromNearState(data) {
    this.state.restoreFromString(data['last_saved_map']);
    this.updateMoodAndValue();
    this.recalc();
  }

  saveNear() {
    return this.state.saveNear();
  }
}

export const gameState = new State();

'''
'''--- src/js/texture-gen.js ---
import {appResourceLoader} from './resources';

function createCanvas(width, height) {
  const canvas = document.createElement('canvas');
  canvas.width = width;
  canvas.height = height;
  const ctx = canvas.getContext('2d');
  ctx.imageSmoothingEnabled = false;

  return [canvas, ctx];
}

/**
 * @param {string} name
 * @param {string} targetName
 * @param {string} fgColor
 * @param {string=} bgColor
 * @param {number=} alpha
 * @return {HTMLCanvasElement}
 */
export function colorPattern(name, targetName, fgColor, bgColor, alpha = 1) {
  const fg = fgColor.replace(/[^\d,]/g, '').split(',').map(n => +n);
  const bg = bgColor ? bgColor.replace(/[^\d,]/g, '').split(',').map(n => +n) : undefined;

  const sprite = appResourceLoader.getImage(name);
  const img = sprite.img;

  const [canvas, targetCtx] = createCanvas(sprite.w, sprite.h);
  if (bg) {
    const [r, g, b] = bg;
    targetCtx.fillStyle = `rgb(${r},${g},${b})`;
    targetCtx.fillRect(0, 0, sprite.w, sprite.h);
  }
  const targetDataObj = targetCtx.getImageData(0, 0, sprite.w, sprite.h);
  const targetData = targetDataObj.data;

  const [, originalCtx] = createCanvas(sprite.w, sprite.h);
  originalCtx.drawImage(img, sprite.x, sprite.y, sprite.w, sprite.h, 0, 0, sprite.w, sprite.h);
  const originalData = originalCtx.getImageData(0, 0, sprite.w, sprite.h).data;

  for (let i = 0; i < originalData.length; i += 4) {
    if (bg) {
      const originalAlpha = originalData[i + 3] / 255;
      targetData[i] = originalAlpha * originalData[i] / 255 * fg[0] + (1 - originalAlpha) * targetData[i];
      targetData[i + 1] = originalAlpha * originalData[i] / 255 * fg[1] + (1 - originalAlpha) * targetData[i];
      targetData[i + 2] = originalAlpha * originalData[i] / 255 * fg[2] + (1 - originalAlpha) * targetData[i];
      targetData[i + 3] = 255 * alpha;
    } else {
      targetData[i] = originalData[i] / 255 * fg[0];
      targetData[i + 1] = originalData[i + 1] / 255 * fg[1];
      targetData[i + 2] = originalData[i + 2] / 255 * fg[2];
      targetData[i + 3] = originalData[i + 3] * alpha;
    }
  }
  targetCtx.putImageData(targetDataObj, 0, 0);
  appResourceLoader.addImage(targetName, canvas, 0, 0, sprite.w, sprite.h);

  return canvas;
}

export function rainbowSprite(name, targetName, alpha = 1) {
  const hsl = [[255, 0, 0], [255, 98, 0], [255, 191, 0], [221, 255, 0], [128, 255, 0], [30, 255, 0], [0, 255, 64], [0, 255, 162], [0, 255, 255], [0, 157, 255], [0, 64, 255], [34, 0, 255], [127, 0, 255], [225, 0, 255], [255, 0, 191], [255, 0, 93]];
  const sprite = appResourceLoader.getImage(name);
  const img = sprite.img;

  const [canvas, targetCtx] = createCanvas(sprite.w, sprite.h);
  const targetDataObj = targetCtx.getImageData(0, 0, sprite.w, sprite.h);
  const targetData = targetDataObj.data;

  const [, originalCtx] = createCanvas(sprite.w, sprite.h);
  originalCtx.drawImage(img, sprite.x, sprite.y, sprite.w, sprite.h, 0, 0, sprite.w, sprite.h);
  const originalData = originalCtx.getImageData(0, 0, sprite.w, sprite.h).data;

  for (let i = 0; i < originalData.length; i += 4) {
    const x = Math.floor((i / 4) / sprite.h);
    targetData[i] = originalData[i] / 255 * hsl[x][0];
    targetData[i + 1] = originalData[i + 1] / 255 * hsl[x][1];
    targetData[i + 2] = originalData[i + 2] / 255 * hsl[x][2];
    targetData[i + 3] = originalData[i + 3] * alpha;
  }
  targetCtx.putImageData(targetDataObj, 0, 0);
  appResourceLoader.addImage(targetName, canvas, 0, 0, sprite.w, sprite.h);

  return canvas;
}

export function blendSprites(a, b, targetName, mode = 'destination-out') {
  const sprA = appResourceLoader.getImage(a);
  const sprB = appResourceLoader.getImage(b);

  const [result, ctx] = createCanvas(sprA.w, sprA.h);

  ctx.drawImage(sprA.img, sprA.x, sprA.y, sprA.w, sprA.h, 0, 0, sprA.w, sprA.h);
  ctx.save();
  ctx.globalCompositeOperation = mode;
  ctx.drawImage(sprB.img, sprB.x, sprB.y, sprB.w, sprB.h, 0, 0, sprB.w, sprB.h);
  ctx.restore();

  appResourceLoader.addImage(targetName, result, 0, 0, sprA.w, sprA.h);
}

export function flipSprite(name, hor, vert, rotate, targetName) {
  const spr = appResourceLoader.getImage(name);
  const w = spr.w;
  const h = spr.h;

  const [result, ctx] = createCanvas(spr.w, spr.h);
  ctx.translate(w / 2, h / 2);
  ctx.rotate(rotate);
  ctx.scale((hor) ? -1 : 1, (vert) ? -1 : 1);

  ctx.drawImage(spr.img, spr.x, spr.y, spr.w, spr.h, -w / 2, -h / 2, spr.w, spr.h);

  appResourceLoader.addImage(targetName, result, 0, 0, spr.w, spr.h);
}

function drawPaintingBorder(ctx, w, h) {
  ctx.strokeStyle = 'rgb(100,67,58)';
  ctx.beginPath();
  ctx.rect(0, 0, w, h);
  ctx.stroke();
  ctx.strokeStyle = 'rgb(247,226,107)';
  ctx.beginPath();
  ctx.rect(1, 1, w - 2, h - 2);
  ctx.stroke();
}

async function fetchArcadian(id, targetName) {
  try {
    const url = 'https://api.arcadians.io/' + id;
    const req = await fetch(url);
    const data = await req.json();

    const w = 25;
    const h = 25;
    const [result, ctx] = createCanvas(w, h);

    const img = new Image();
    img.onload = () => {
      ctx.drawImage(img, 140, 110, 100, 100, 0, 0, w, h);
      drawPaintingBorder(ctx, w, h);

      appResourceLoader.addImage(targetName, result, 0, 0, w, h);
    };
    img.src = data.image;
  } catch (err) {
    console.warn('Failed to fetch arcadian id', id, err);
  }
}

export function createArcadian(id) {
  const targetName = 'arcadian' + id;

  if (appResourceLoader.getImage(targetName)) {
    return;
  }

  const w = 25;
  const h = 25;
  const [result, ctx] = createCanvas(w, h);
  ctx.fillStyle = 'rgb(213,213,213)';
  ctx.fillRect(0, 0, w, h);
  drawPaintingBorder(ctx, w, h);
  ctx.font = '20px Papyrus, fantasy, sans-serif';
  ctx.textBaseline = 'middle';
  ctx.textAlign = 'center';
  ctx.fillStyle = '#303030';
  ctx.fillText('A', 12, 15);

  if (id !== -1) {
    fetchArcadian(id, targetName);
  }

  appResourceLoader.addImage(targetName, result, 0, 0, w, h);
}

export function createPainting(baseSpr, targetName) {
  const w = 25;
  const h = 25;
  const [result, ctx] = createCanvas(w, h);
  ctx.fillStyle = 'rgb(38,50,50)';
  ctx.fillRect(0, 0, w, h);
  drawPaintingBorder(ctx, w, h);

  const spr = appResourceLoader.getImage(baseSpr);
  ctx.drawImage(spr.img, spr.x, spr.y, spr.w, spr.h, 4, 4, spr.w, spr.h);

  appResourceLoader.addImage(targetName, result, 0, 0, w, h);
}

'''
'''--- src/js/tiles.js ---
import {TowerA} from './objects/tower-a';
import {Skeletons} from './objects/skeletons';
import {Barricade} from './objects/barricade';
import {Arcadian} from './objects/arcadian';
import {Light} from './objects/light';
import {Lamp} from './objects/lamp';
import {SoulPainting} from './objects/painting';
import {HPUp} from './objects/hpup';

/**
 * @enum {string}
 */
export const TileGrade = {
  HELLISH: 'h',
  DARK: 'd',
  NORMAL: 'n',
  LIGHT: 'l',
  SHINING: 's',
  GREEN: 'g',
  PONY: 'p',
};

export const Tiles = {
  WALLS: [
    {
      id: 0,
      basePrice: 0,
      mood: 0,
      value: 0,
    },
    {
      id: 1,
      basePrice: 0.1,
      mood: 0.5,
      value: 0.5,
    },
    {
      id: 2,
      basePrice: 0.1,
      mood: 0.5,
      value: 0.5,
    },
    {
      id: 3,
      basePrice: 0.1,
      mood: 0.5,
      value: 0.5,
    }
  ],
  FLOORS: [
    {
      id: 0,
      basePrice: 0,
      mood: 0,
      value: 0,
    },
    {
      id: 1,
      basePrice: 0.1,
      mood: 0.5,
      value: 0.5,
    },
    {
      id: 2,
      basePrice: 0.1,
      mood: 0.5,
      value: 0.5,
    },
    {
      id: 3,
      basePrice: 0.1,
      mood: 0.5,
      value: 0.5,
    }
  ]
};

export const Objects = [
  {
    id: 0,
    name: 'Defensive altar',
    description: 'Launches fire charges into enemies\nEach upgrade increase either recharge rate or targeting distance',
    cost: 15,
    upgradeCost: 30,
    mood: 30,
    value: 20,
    ctor: TowerA
  }, {
    id: 1,
    name: 'Barricade',
    description: 'Can block enemies. Each upgrade increases durability\nCheap and sturdy',
    cost: 3,
    upgradeCost: 15,
    mood: 0,
    value: 10,
    ctor: Barricade
  }, {
    id: 2,
    name: 'Grave',
    description: 'Spawns skeletons who can block and attack enemies\nEach upgrade adds skeleton and increases their health\nDestroyed skeletons respawn over time',
    cost: 12,
    upgradeCost: 10,
    mood: 10,
    value: 30,
    ctor: Skeletons
  },
  {
    id: 9,
    name: 'Potion station',
    description: 'Automatically heals you and skeletons around',
    upgradeCost: 30,
    cost: 30,
    mood: 20,
    value: 10,
    ctor: HPUp
  },
  {
    id: 4,
    name: 'Wall light',
    description: 'Improves overall mood and adds some value',
    cost: 5,
    mood: 30,
    value: 5,
    ctor: Light
  },
  {
    id: 5,
    name: 'Chandelier',
    description: 'Improves overall mood and adds some value',
    cost: 15,
    mood: 10,
    value: 80,
    ctor: Lamp
  },
  {
    id: 6,
    name: 'Painting of an ordinary soul',
    description: 'Improves overall mood and adds some value',
    cost: 10,
    mood: 40,
    value: 40,
    ctor: SoulPainting,
    meta: 'soul-paint'
  },
  {
    id: 7,
    name: 'Painting of a skeleton',
    description: 'Improves overall mood and adds some value',
    cost: 20,
    mood: 80,
    value: 50,
    ctor: SoulPainting,
    meta: 'sk-paint'
  },
  {
    id: 8,
    name: 'Painting of a you',
    description: 'You look nice',
    cost: 30,
    mood: 150,
    value: 100,
    ctor: SoulPainting,
    meta: 'hds-paint'
  },
  {
    id: 900,
    isArcadian: true,
    name: 'Arcadian NFT',
    description: 'Improves overall mood and adds some value.\nID can be selected',
    cost: 10,
    mood: 40,
    value: 40,
    ctor: Arcadian
  }
];

export function createObject(def, x, y, isPreview = false, meta = undefined) {
  return new def.ctor(def, x, y, isPreview, meta || def.meta);
}

'''
'''--- src/js/utils.js ---
/**
 * @enum {string}
 */
export const MapArea = {
  ELYSIUM: 'elysium',
  ASPHODEL: 'asphodel',
  TARTAR: 'tartar',
};

/**
 * Shuffle array in place
 * @param {Array} a
 */
export function shuffle(a) {
  for (let i = 0, l = a.length; i < l; i++) {
    const j = ~~(Math.random() * l);
    const x = a[i];
    a[i] = a[j];
    a[j] = x;
  }
}

export function getMapDY(area) {
  if (area === MapArea.TARTAR) {
    return 11 * 16;
  } else if (area === MapArea.ASPHODEL) {
    return 6 * 16;
  } else {
    return 16;
  }
}

export function sortObject(objA, objB) {
  try {
    if (objA.spr.x === objB.spr.x) return 0;
    return objA.spr.x > objB.spr.x ? 1 : -1;
  } catch (err) {
    return 0;
  }
}

export function sortDist(x, objA, objB) {
  if (objA.sprite.x === objB.sprite.x) return 0;
  return Math.abs(x - objA.sprite.x) > Math.abs(x - objB.sprite.x) ? 1 : -1;
}

export const upgradeMarkers = [
  [-3, 0], [3, 0],
  [-3, -5], [3, -5],
  [0, -10]
];

export function genDefaultMap(w, h) {
  const res = [];
  for (let y = 0; y < h; y++) {
    let prefix = 'w';
    if (y === 0) {
      prefix = 'c';
    } else if (y === 3) {
      prefix = 'f';
    }
    res[y] = [];
    for (let x = 0; x < w; x++) {
      res[y][x] = [prefix, 'x'].join('|');
    }
  }
  return res;
}

'''
'''--- src/js/walker.js ---
import {Sprite} from './sprite';

/**
 * @enum {number}
 */
export const PlayerTransferState = {
  DEFAULT: 0,
  IN: 2,
  OUT: 1,
};

export class Walker {
  constructor(spriteBase, x, level, speed = 24) {
    this.currentLevel = level;
    this.x = x;
    this.y = this.currentLevel * (16 * 5) + 16 * 3;
    this.target = x;
    this.speed = speed;
    this.sprite = new Sprite(spriteBase, this.x, this.y, 10);
    this.sprite.stopAnimation();
    this.canMove = true;
    this.isWalking = false;
    this.targetLevel = level;

    this.currentLevelDelta = 0;
    this.playerTransferState = PlayerTransferState.DEFAULT;
  }

  stop() {
    this.target = this.x;
    this.targetLevel = this.currentLevel;
    this.sprite.stopAnimation();
    this.isWalking = false;
  }

  /**
   * @param {number} dx
   * @param {number=} level
   */
  walkTo(dx, level) {
    if (this.playerTransferState !== PlayerTransferState.DEFAULT) {
      this.canMove = false;
      this.stop();
      return;
    }

    this.canMove = true;
    this.target = dx;
    this.targetLevel = level;
    if (!this.isWalking) {
      this.isWalking = true;
      this.sprite.startAnimation();
    }
  }

  gate(dy) {
    const isNearGate = Math.abs(this.x - 16 * 5) < 8;
    const canTransfer = this.playerTransferState === PlayerTransferState.DEFAULT && isNearGate;

    if (dy < 0 && canTransfer && this.currentLevel < 2) {
      this.currentLevelDelta = 1;
      this.playerTransferState = PlayerTransferState.OUT;
    }
    if (dy > 0 && canTransfer && this.currentLevel > 0) {
      this.currentLevelDelta = -1;
      this.playerTransferState = PlayerTransferState.OUT;
    }
  }

  render(dt) {
    if (this.playerTransferState === PlayerTransferState.OUT && this.sprite.alpha > 0) {
      this.sprite.alpha -= dt * 3;
    } else if (this.playerTransferState === PlayerTransferState.OUT && this.sprite.alpha <= 0) {
      this.sprite.alpha = 0;
      this.currentLevel += this.currentLevelDelta;
      this.playerTransferState = PlayerTransferState.IN;
    }

    if (this.playerTransferState === PlayerTransferState.IN && this.sprite.alpha < 1) {
      this.sprite.alpha += dt * 3;
    } else if (this.playerTransferState === PlayerTransferState.IN && this.sprite.alpha >= 1) {
      this.sprite.alpha = 1;
      this.playerTransferState = PlayerTransferState.DEFAULT;
    }

    let xTarget = this.target;
    if (this.targetLevel !== undefined && this.currentLevel !== this.targetLevel) {
      xTarget = 16 * 5;
      this.gate(Math.sign(this.currentLevel - this.targetLevel));
    }

    if (this.x !== this.target) {
      this.sprite.setFlip(this.x > xTarget);
    }

    if (this.canMove && this.x > xTarget) {
      this.x -= dt * this.speed;
    }
    if (this.canMove && this.x < xTarget) {
      this.x += dt * this.speed;
    }
    this.y = this.currentLevel * (16 * 5) + 16 * 3;
    this.sprite.x = this.x;
    this.sprite.y = this.y + 1;

    if (Math.abs(this.x - this.target) < 2) {
      this.stop();
    }

    this.sprite.render(dt);
  }
}

'''
'''--- src/js/zzfx.js ---
// ZzFX - Zuper Zmall Zound Zynth - Micro Edition
// MIT License - Copyright 2019 Frank Force
// https://github.com/KilledByAPixel/ZzFX

// This is a tiny build of zzfx with only a zzfx function to play sounds.
// You can use zzfxV to set volume.
// Feel free to minify it further for your own needs!

'use strict';let zzfx,zzfxV,zzfxX

// ZzFXMicro - Zuper Zmall Zound Zynth - v1.1.8 ~ 884 bytes minified
zzfxV=.3    // volume
zzfx=       // play sound
  (p=1,k=.05,b=220,e=0,r=0,t=.1,q=0,D=1,u=0,y=0,v=0,z=0,l=0,E=0,A=0,F=0,c=0,w=1,m=0,B=0)=>{let
    M=Math,R=44100,d=2*M.PI,G=u*=500*d/R/R,C=b*=(1-k+2*k*M.random(k=[]))*d/R,g=0,H=0,a=0,n=1,I=0
    ,J=0,f=0,x,h;e=R*e+9;m*=R;r*=R;t*=R;c*=R;y*=500*d/R**3;A*=d/R;v*=d/R;z*=R;l=R*l|0;for(h=e+m+
    r+t+c|0;a<h;k[a++]=f)++J%(100*F|0)||(f=q?1<q?2<q?3<q?M.sin((g%d)**3):M.max(M.min(M.tan(g),1)
    ,-1):1-(2*g/d%2+2)%2:1-4*M.abs(M.round(g/d)-g/d):M.sin(g),f=(l?1-B+B*M.sin(d*a/l):1)*(0<f?1:
    -1)*M.abs(f)**D*p*zzfxV*(a<e?a/e:a<e+m?1-(a-e)/m*(1-w):a<e+m+r?w:a<h-c?(h-a-c)/t*w:0),f=c?f/
    2+(c>a?0:(a<h-c?1:(h-a)/c)*k[a-c|0]/2):f),x=(b+=u+=y)*M.cos(A*H++),g+=x-x*E*(1-1E9*(M.sin(a)
    +1)%2),n&&++n>z&&(b+=v,C+=v,n=0),!l||++I%l||(b=C,u=G,n=n||1);p=zzfxX.createBuffer(1,h,R);p.
  getChannelData(0).set(k);b=zzfxX.createBufferSource();b.buffer=p;b.connect(zzfxX.destination
  );b.start();return b};zzfxX=new (window.AudioContext||webkitAudioContext) // audio context

export {zzfx}

'''
'''--- src/main.css ---
html,body {
  height: 100%;
  margin: 0;
  padding: 0;
}

body {
  background-color: #262626;
  font-family: Papyrus, phantasy, sans-serif;
  display: grid;
  place-content: center;
}

* {
  transition: all ease 1s;
}

canvas {
  image-rendering: pixelated;
}

.renderer {
  width: 1056px;
  height: 640px;
}

'''