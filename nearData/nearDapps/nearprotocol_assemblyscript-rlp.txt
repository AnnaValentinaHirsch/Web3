*GitHub Repository "nearprotocol/assemblyscript-rlp"*

'''--- .gitlab-ci.yml ---
image: node:latest

stages:
  - build
  - test

cache:
  paths:
    - node_modules/

install_dependencies:
  stage: build
  script:
    - npm install
    - npm run asbuild
  artifacts:
    paths:
      - node_modules/

run_tests:
  stage: test
  script: npm run test

'''
'''--- .travis.yml ---
language: node_js
node_js:
  - 12

before_script:
  - "curl -H 'Cache-Control: no-cache' https://raw.githubusercontent.com/fossas/fossa-cli/master/install.sh | sudo bash"
  - "npm install --g lerna"

script:
  - fossa init
  - fossa analyze --server-scan
  - fossa test

'''
'''--- README.md ---
# assemblyscript-rlp

Assemblyscript implmementation of [RLP](https://github.com/ethereum/wiki/wiki/RLP) base on the [typescript implementation](https://github.com/ethereumjs/rlp). Mostly work in progress.

## Development

To build the project, run 
```bash
npm install && npm run asbuild
```

To test, run
```bash
npm run test
```

Tests are written using [as-pect](https://github.com/jtenner/as-pect).

'''
'''--- as-pect.config.js ---
module.exports = {
  /**
   * A set of globs passed to the glob package that qualify typescript files for testing.
   */
  include: ["assembly/__tests__/**/*.spec.ts"],
  /**
   * A set of globs passed to the glob package that quality files to be added to each test.
   */
  add: ["assembly/__tests__/**/*.include.ts"],
  /**
   * All the compiler flags needed for this test suite. Make sure that a binary file is output.
   */
  flags: {
    "--validate": [],
    "--debug": [],
    /** This is required. Do not change this. The filename is ignored, but required by the compiler. */
    "--binaryFile": ["output.wasm"],
    /** To enable wat file output, use the following flag. The filename is ignored, but required by the compiler. */
    // "--textFile": ["output.wat"],
  },
  /**
   * A set of regexp that will disclude source files from testing.
   */
  disclude: [/node_modules/],
  /**
   * Add your required AssemblyScript imports here.
   */
  imports: {},
  /**
   * All performance statistics reporting can be configured here.
   */
  performance: {
    /** Enable performance statistics gathering. */
    enabled: false,
    /** Set the maximum number of samples to run for each test. */
    maxSamples: 10000,
    /** Set the maximum test run time in milliseconds. */
    maxTestRunTime: 2000,
    /** Set the number of decimal places to round to. */
    roundDecimalPlaces: 3,
    /** Report the median time in the default reporter. */
    reportMedian: true,
    /** Report the average time in milliseconds. */
    reportAverage: true,
    /** Report the standard deviation. */
    reportStandardDeviation: false,
    /** Report the maximum run time in milliseconds. */
    reportMax: false,
    /** Report the minimum run time in milliseconds. */
    reportMin: false,
    /** Report the variance. */
    reportVariance: false,
  },
  /**
   * Add a custom reporter here if you want one. The following example is in typescript.
   *
   * @example
   * import { TestReporter, TestGroup, TestResult, TestContext } from "as-pect";
   *
   * export class CustomReporter extends TestReporter {
   *   // implement each abstract method here
   *   public abstract onStart(suite: TestContext): void;
   *   public abstract onGroupStart(group: TestGroup): void;
   *   public abstract onGroupFinish(group: TestGroup): void;
   *   public abstract onTestStart(group: TestGroup, result: TestResult): void;
   *   public abstract onTestFinish(group: TestGroup, result: TestResult): void;
   *   public abstract onFinish(suite: TestContext): void;
   * }
   */
  // reporter: new CustomReporter(),
};

'''
'''--- assembly/__tests__/as-pect.d.ts ---
/**
 * This function creates a test group in the test loader.
 *
 * @param {string} description  - This is the name of the test group.
 * @param {() => void} callback - A function that contains all of the closures for this test group.
 *
 * @example
 * describe("my test suite", (): void => {
 *   // put your tests here
 * });
 */
declare function describe(description: string, callback: () => void): void;

/**
 * This function creates a test inside the given test group. It must be placed inside a describe
 * block.
 *
 * @param {string} description - This is the name of the test, and should describe a behavior.
 * @param {() => void} callback - A function that contains a set of expectations for this test.
 *
 * @example
 * describe("the meaning of life", (): void => {
 *   it("should be 42", (): void => {
 *     // put your expectations here
 *     expect<i32>(29 + 13).toBe(42);
 *   });
 * });
 */
declare function it(description: string, callback: () => void): void;

/**
 * A test that does not run, and is longhand equivalent to using todo function without a
 * callback. This test does not get run and is reported like a todo.
 *
 * @param {string} description - This is the name of the test, and should describe a behavior.
 * @param {() => void} callback - A function that contains a set of expectations for this test.
 */
declare function xit(description: string, callback: () => void): void;

/**
 * A test that does not run, and is longhand equivalent to using todo function without a
 * callback. This test does not get run and is reported like a todo.
 *
 * @param {string} description - This is the name of the test, and should describe a behavior.
 * @param {() => void} callback - A function that contains a set of expectations for this test.
 */
declare function xtest(description: string, callback: () => void): void;

/**
 * This function creates a test inside the given test group. It must be placed inside a describe
 * block.
 *
 * @param {string} description - This is the name of the test, and should describe a behavior.
 * @param {() => void} callback - A function that contains a set of expectations for this test.
 *
 * @example
 * describe("the meaning of life", (): void => {
 *   test("the value should be 42", (): void => {
 *     // put your expectations here
 *     expect<i32>(29 + 13).toBe(42);
 *   });
 * });
 */
declare function test(description: string, callback: () => void): void;

/**
 * This function creates a test that is expected to fail. This is useful to verify if a given
 * behavior is expected to throw.
 *
 * @param {string} description - This is the name of the test, and should describe a behavior.
 * @param {() => void} callback - A function that contains a set of expectations for this test.
 * @param {string?} message - A message that describes why the test should fail.
 * @example
 * describe("the meaning of life", (): void => {
  *   throws("the value should be 42", (): void => {
  *     // put your expectations here
  *     expect<i32>(29 + 13).toBe(42);
  *   });
  * });
  */
 declare function throws(description: string, callback: () => void, message?: string): void;

/**
 * This function creates a callback that is called before each individual test is run in this test
 * group.
 *
 * @param {function} callback - The function to be run before each test in the current test group.
 *
 * @example
 * // create a global
 * var cat: Cat = new Cat();
 *
 * describe("cats", (): void => {
 *   beforeEach((): void => {
 *     cat.meow(1); // meow once per test
 *   });
 * });
 */
declare function beforeEach(callback: () => void): void;

/**
 * This function creates a callback that is called before the whole test group is run, and only
 * once.
 *
 * @param {function} callback - The function to be run before each test in the current test group.
 *
 * @example
 * // create a global
 * var dog: Dog = null;
 * describe("dogs", (): void => {
 *   beforeAll((): void => {
 *     dog = new Dog(); // create a single dog once before the tests start
 *   });
 * });
 */
declare function beforeAll(callback: () => void): void;

/**
 * This function creates a callback that is called after each individual test is run in this test
 * group.
 *
 * @param {function} callback - The function to be run after each test in the current test group.
 *
 * @example
 * // create a global
 * var cat: Cat = new Cat();
 *
 * describe("cats", (): void => {
 *   afterEach((): void => {
 *     cat.sleep(12); // cats sleep a lot
 *   });
 * });
 */
declare function afterEach(callback: () => void): void;

/**
 * This function creates a callback that is called after the whole test group is run, and only
 * once.
 *
 * @param {function} callback - The function to be run after each test in the current test group.
 *
 * @example
 * // create a global
 * var dog: Dog = null;
 * describe("dogs", (): void => {
 *   afterAll((): void => {
 *     memory.free(changetype<usize>(dog)); // free some memory
 *   });
 * });
 */
declare function afterAll(callback: () => void): void;

/**
 * Describes a value and returns an expectation to test the value.
 *
 * @type {T} - The test's type
 * @param {T} actual - The value being tested.
 *
 * @example
 * expect<i32>(42).not.toBe(-1, "42 should not be -1");
 * expect<i32>(19 + 23).toBe(42, "19 + 23 should equal 42");
 */
declare function expect<T>(actual: T | null): Expectation<T>;

/**
 * Describes a function and returns an expectation to test the function.
 *
 * @param {() => void} callback - The callback being tested.
 *
 * @example
 * expectFn((): void => unreachable()).toThrow("unreachables do not throw");
 * expectFn((): void => {
 *   cat.meow();
 * }).not.toThrow("Uhoh, cats can't meow!");;
 */
declare function expectFn(cb: () => void): Expectation<() => void>;

/**
 * Describes a test that needs to be written.
 *
 * @param {string} description - The description of the test that needs to be written.
 */
declare function todo(description: string): void;

/**
 * Logs a single value to the logger, and is stringified. It works for references, values, and
 * strings.
 *
 * @type {T} - The type to be logged.
 * @param {T | null} value - The value to be logged.
 * @example
 * log<string>("This is a logged value.");
 * log<i32>(42);
 * log<Vec3>(new Vec(1, 2, 3));
 * log<Vec3>(null);
 */
declare function log<T>(value: T | null): void;

/**
* An expectation for a value.
*/
declare class Expectation<T> {

  /**
   * Create a new expectation.
   *
   * @param {T | null} actual - The actual value of the expectation.
   */
  constructor(actual: T | null);

  /**
   * This expectation performs a strict equality on value types and reference types.
   *
   * @param {T | null} expected - The value to be compared.
   * @param {string} message - The optional message that describes the expectation.
   *
   * @example
   * expect<i32>(42).not.toBe(-1, "42 should not be -1");
   * expect<i32>(19 + 23).toBe(42, "19 + 23 should equal 42");
   */
  toBe(expected: T | null, message?: string): void;

  /**
   * This expectation performs a strict equality on value types and performs a memcompare on
   * reference types. If the reference type T has reference types as properties, the comparison does
   * not perform property traversal. It will only compare the pointer values in the memory block.
   *
   * @param {T | null} expected - The value to be compared.
   * @param {string} message - The optional message that describes the expectation.
   *
   * @example
   * expect<Vec3>(new Vec3(1, 2, 3)).toStrictEqual(new Vec(1, 2, 3), "Vectors of the same shape should be equal");
   */
  toStrictEqual(expected: T | null, message?: string): void;

  /**
   * If the value is callable, it calls the function, and fails the expectation if it throws, or hits
   * an unreachable().
   *
   * @param {string} message - The optional message that describes the expectation.
   *
   * @example
   * expectFn((): void => unreachable()).toThrow("unreachable() should throw.");
   * expectFn((): void => {
   *   cat.sleep(100); // cats can sleep quite a lot
   * }).not.toThrow("cats should sleep, not throw");
   */
  toThrow(message?: string): void;

  /**
   * This expecation asserts that the value is truthy, like in javascript. If the value is a string,
   * then strings of length 0 are not truthy.
   *
   * @param {string} message - The optional message that describes the expectation.
   *
   * @example
   * expect<bool>(true).toBeTruthy("true is truthy.");
   * expect<i32>(1).toBeTruthy("numeric values that are not 0 are truthy.");
   * expect<Vec3>(new Vec3(1, 2, 3)).toBeTruthy("reference types that aren't null are truthy.");
   * expect<bool>(false).not.toBeTruthy("false is not truthy.");
   * expect<i32>(0).not.toBeTruthy("0 is not truthy.");
   * expect<Vec3>(null).not.toBeTruthy("null is not truthy.");
   */
  toBeTruthy(message?: string): void;

  /**
   * This expectation tests the value to see if it is null. If the value is a value type, it is
   * never null. If the value is a reference type, it performs a strict null comparison.
   *
   * @param {string} message - The optional message that describes the expectation.
   *
   * @example
   * expect<i32>(0).not.toBeNull("numbers are never null");
   * expect<Vec3>(null).toBeNull("null reference types are null.");
   */
  toBeNull(message?: string): void;

  /**
   * This expecation assert that the value is falsy, like in javascript. If the value is a string,
   * then strings of length 0 are falsy.
   *
   * @param {string} message - The optional message that describes the expectation.
   *
   * @example
   * expect<bool>(false).toBeFalsy("false is falsy.");
   * expect<i32>(0).toBeFalsy("0 is falsy.");
   * expect<Vec3>(null).toBeFalsy("null is falsy.");
   * expect<bool>(true).not.toBeFalsy("true is not falsy.");
   * expect<i32>(1).not.toBeFalsy("numeric values that are not 0 are not falsy.");
   * expect<Vec3>(new Vec3(1, 2, 3)).not.toBeFalsy("reference types that aren't null are not falsy.");
   */
  toBeFalsy(message?: string): void;

  /**
   * This expectation asserts that the value is greater than the expected value. Since operators can
   * be overloaded in assemblyscript, it's possible for this to work on reference types.
   *
   * @param {T | null} expected - The expected value that the actual value should be greater than.
   * @param {string} message - The optional message that describes this expectation.
   *
   * @example
   * expect<i32>(10).toBeGreaterThan(4);
   * expect<i32>(12).not.toBeGreaterThan(42);
   */
  toBeGreaterThan(expected: T | null, message?: string): void;

  /**
   * This expectation asserts that the value is less than the expected value. Since operators can
   * be overloaded in assemblyscript, it's possible for this to work on reference types.
   *
   * @param {T | null} value - The expected value that the actual value should be less than.
   * @param {string} message - The optional message that describes this expectation.
   *
   * @example
   * expect<i32>(10).not.toBeLessThan(4);
   * expect<i32>(12).toBeLessThan(42);
   */
  toBeLessThan(expected: T | null, message?: string): void;

  /**
   * This expectation asserts that the value is greater than or equal to the expected value. Since
   * operators can be overloaded in assemblyscript, it's possible for this to work on reference
   * types.
   *
   * @param {T | null} value - The expected value that the actual value should be greater than or
   * equal to.
   * @param {string} message - The optional message that describes this expectation.
   *
   * @example
   * expect<i32>(42).toBeGreaterThanOrEqualTo(42);
   * expect<i32>(10).toBeGreaterThanOrEqualTo(4);
   * expect<i32>(12).not.toBeGreaterThanOrEqualTo(42);
   */
  toBeGreaterThanOrEqualTo(expected: T | null, message?: string): void;

  /**
   * This expectation asserts that the value is less than or equal to the expected value. Since
   * operators can be overloaded in assemblyscript, it's possible for this to work on reference
   * types.
   *
   * @param {T | null} value - The expected value that the actual value should be less than or equal
   * to.
   * @param {string} message - The optional message that describes this expectation.
   *
   * @example
   * expect<i32>(42).toBeLessThanOrEqualTo(42);
   * expect<i32>(10).not.toBeLessThanOrEqualTo(4);
   * expect<i32>(12).toBeLessThanOrEqualTo(42);
   */
  toBeLessThanOrEqualTo(expected: T | null, message?: string): void;

  /**
   * This expectation asserts that the value is close to another value. Both numbers must be finite,
   * and T must extend f64 or f32.
   *
   * @param {T extends f64 | f32} value - The expected value to be close to.
   * @param {i32} decimalPlaces - The number of decimal places used to calculate epsilon. Default is
   * 2.
   * @param {string} message - The optional message that describes this expectation.
   */
  toBeCloseTo(expected: T, decimalPlaces?: number, message?: string): void;

  /**
   * This function asserts the float type value is NaN.
   *
   * @param {string} message - The optional message the describes this expectation.
   * @example
   * expect<f64>(NaN).toBeNaN();
   * expect<f32>(42).not.toBeNaN();
   */
  toBeNaN(message?: string): void;

  /**
   * This function asserts a float is finite.
   *
   * @param {string} message - The optional message the describes this expectation.
   * @example
   * expect<f32>(42).toBeFinite();
   * expect<f64>(Infinity).not.toBeFinite();
   */
  toBeFinite(message?: string): void;

  /**
   * This method asserts the item has the expected length.
   *
   * @param {i32} expected - The expected length.
   * @param {string} message - The optional message the describes this expectation.
   */
  toHaveLength(expected: i32, message?: string): void;

  /**
   * This computed property is chainable, and negates the existing expectation. It returns itself.
   *
   * @type {Expectation<T>}
   */
  not: Expectation<T>;

  /**
   * The actual value of the expectation.
   */
  actual: T | null;
  private _not: boolean;
}

/**
 * This is called to stop the debugger.  e.g. `node --inspect-brk asp`.
 */
declare function debug(): void;

/**
 * This function call enables performance statistics gathering for the following test.
 *
 * @param {bool} enabled - The bool to indicate if performance statistics should be gathered.
 */
declare function performanceEnabled(enabled: bool): void;

/**
 * This function call sets the maximum number of samples to complete the following test.
 *
 * @param {f64} count - The maximum number of samples required.
 */
declare function maxSamples(count: f64): void;

/**
 * This function call sets the number of decimal places to round to for the following test.
 *
 * @param {i32} deicmalPlaces - The number of decimal places to round to
 */
declare function roundDecimalPlaces(count: i32): void;

/**
 * This function call will set the maximum amount of time that should pass before it can stop
 * gathering samples for the following test.
 *
 * @param {f64} time - The ammount of time in milliseconds.
 */
declare function maxTestRunTime(time: f64): void;

/**
 * This function call enables gathering the average/mean run time of each sample for the following
 * test.
 *
 * @param {bool} enabled - The bool to indicate if the average/mean should be gathered.
 */
declare function reportAverage(enabled: bool): void;

/**
 * This function call enables gathering the median run time of each sample for the following test.
 *
 * @param {bool} enabled - The bool to indicate if the median should be gathered.
 */
declare function reportMedian(value: bool): void;

/**
 * This function call enables gathering the standard deviation of the run times of the samples
 * collected for the following test.
 *
 * @param {bool} enabled - The bool to indicate if the standard deviation should be gathered.
 */
declare function reportStdDev(value: bool): void;

/**
 * This function call enables gathering the largest run time of the samples collected for the
 * following test.
 *
 * @param {bool} enabled - The bool to indicate if the max should be gathered.
 */
declare function reportMax(value: bool): void;

/**
 * This function call enables gathering the smallest run time of the samples collected for the
 * following test.
 *
 * @param {bool} enabled - The bool to indicate if the min should be gathered.
 */
declare function reportMin(value: bool): void;

/**
 * This function call enables gathering the varaince of the samples collected for the following test.
 *
 * @param {bool} enabled - The bool to indicate if the variance should be calculated.
 */
declare function reportVariance(value: bool): void;
'''
'''--- assembly/__tests__/dataTypes.spec.ts ---
import * as RLP from '../index';
import {RLPData} from "../type";

function arrayToUint8Array(array: u8[]): Uint8Array {
    let len = array.length;
    let res = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
        res[i] = array[i];
    }
    return res;
}

function bytesToString(bytes: Uint8Array): string {
    return String.fromUTF8((bytes.buffer.data + bytes.byteOffset) as usize, bytes.byteLength);
}

function stringToBytes(s: string): Uint8Array {
    let len = s.lengthUTF8 - 1;
    let bytes = new Uint8Array(len);
    memory.copy(bytes.buffer.data, s.toUTF8(), len);
    return bytes;
}

// describe('random test', (): void => {
//     it('dog', (): void => {
//         let byteArray = new Uint8Array(4);
//         byteArray[0] = 131;
//         byteArray[1] = 100;
//         byteArray[2] = 111;
//         byteArray[3] = 103;
//         let bytes = byteArray.subarray(1);
//         let s1 = bytesToString(bytes);
//         let s2 = String.fromUTF8(bytes.buffer as usize, bytes.byteLength);
//         expect<string>(s1).toBe(s2);
//     });
// });

describe('RLP encoding (string):', (): void => {
    it('should return itself if single byte and less than 0x7f:', (): void => {
        let encodedSelf = RLP.encode(new RLPData(stringToBytes('a'), null));
        expect<string>(bytesToString(encodedSelf)).toBe('a');
        expect<usize>(encodedSelf.length).toBe(1);
    });

    it('length of string 0-55 should return (0x80+len(data)) plus data', (): void => {
        let rlpData = new RLPData(stringToBytes('dog'), null);
        let encodedDog = RLP.encode(rlpData);
        expect<usize>(encodedDog.length).toBe(4);
        // assert.equal(RLP.getLength(encodedDog), 4)
        expect<u8>(encodedDog[0]).toBe(131);
        expect<u8>(encodedDog[1]).toBe(100);
        expect<u8>(encodedDog[2]).toBe(111);
        expect<u8>(encodedDog[3]).toBe(103);
    });

    it('length of string >55 should return 0xb7+len(len(data)) plus len(data) plus data', (): void => {
        let rlpData = new RLPData(stringToBytes('zoo255zoo255zzzzzzzzzzzzssssssssssssssssssssssssssssssssssssssssssssss'), null);
        let encodedLongString = RLP.encode(rlpData);
        // assert.equal(RLP.getLength(encodedLongString), 2)
        expect<u8>(encodedLongString[0]).toBe(184);
        expect<u8>(encodedLongString[1]).toBe(70);
        expect<u8>(encodedLongString[2]).toBe(122);
        expect<u8>(encodedLongString[3]).toBe(111);
        expect<u8>(encodedLongString[12]).toBe(53);
    });
});

describe('RLP encoding (list):', function() {
    it('length of list 0-55 should return (0xc0+len(data)) plus data', (): void => {
        let dog = new RLPData(stringToBytes('dog'), null);
        let god = new RLPData(stringToBytes('god'), null);
        let cat = new RLPData(stringToBytes('cat'), null);
        let rlpData = new RLPData(null, [dog, god, cat]);
        let encodedArrayOfStrings = RLP.encode(rlpData);
        expect<usize>(encodedArrayOfStrings.length).toBe(13);
        expect<u8>(encodedArrayOfStrings[0]).toBe(204);
        expect<u8>(encodedArrayOfStrings[1]).toBe(131);
        expect<u8>(encodedArrayOfStrings[11]).toBe(97);
        expect<u8>(encodedArrayOfStrings[12]).toBe(116);
    });

    it('combined length of list >55 should return 0xf7+len(len(data)) plus len(data) plus data', (): void => {
        let dog = new RLPData(stringToBytes('dog'), null);
        let longString = new RLPData(stringToBytes('this is a string that is very very very very very long'), null);
        let rlpData = new RLPData(null, [dog, longString]);
        let encodedArrayOfStrings = RLP.encode(rlpData);
        expect<usize>(encodedArrayOfStrings.length).toBe(61);
        expect<u8>(encodedArrayOfStrings[0]).toBe(248);
        expect<u8>(encodedArrayOfStrings[1]).toBe(59);
        expect<u8>(encodedArrayOfStrings[2]).toBe(131);
        expect<u8>(encodedArrayOfStrings[6]).toBe(182);
    });
});

describe('RLP decoding:', function() {
    it('first byte < 0x7f, return byte itself', (): void => {
        let decoded = RLP.decode(arrayToUint8Array([97]));
        expect<usize>(decoded.buffer.length).toBe(1);
        expect<RLPData[]>(decoded.children).toBeNull();
        expect<string>(bytesToString(decoded.buffer)).toBe('a');
    });

    it('first byte < 0xb7, data is everything except first byte', (): void => {
        let decoded = RLP.decode(arrayToUint8Array([131, 100, 111, 103]));
        expect<usize>(decoded.buffer.length).toBe(3);
        expect<RLPData[]>(decoded.children).toBeNull();
        expect<string>(bytesToString(decoded.buffer)).toBe('dog');
    });

    it('strings over 55 bytes long', (): void => {
        let testString = 'This function takes in a data, convert it to buffer if not, and a length for recursion';
        let encoded = RLP.encode(new RLPData(stringToBytes(testString), null));
        let decoded = RLP.decode(encoded);
        expect<RLPData[]>(decoded.children).toBeNull();
        expect<string>(bytesToString(decoded.buffer)).toBe(testString);
    });

    it('list of items', (): void => {
        let decodedBufferArray = RLP.decode(arrayToUint8Array([204, 131, 100, 111, 103, 131, 103, 111, 100, 131, 99, 97, 116]));
        expect<Uint8Array>(decodedBufferArray.buffer).toBeNull();
        expect<usize>(decodedBufferArray.children.length).toBe(3);
        // as-pect does not support deep equal due to lack of metadata support from assemblyscript.
        expect<string>(bytesToString(decodedBufferArray.children[0].buffer)).toBe('dog');
        expect<string>(bytesToString(decodedBufferArray.children[1].buffer)).toBe('god');
        expect<string>(bytesToString(decodedBufferArray.children[2].buffer)).toBe('cat');
    });

    it('list over 55 bytes long', (): void => {
        let testString: string[] = ['This', 'function', 'takes', 'in', 'a', 'data', 'convert', 'it', 'to', 'buffer', 'if', 'not', 'and', 'a', 'length', 'for', 'recursion', 'a1', 'a2', 'a3', 'ia4', 'a5', 'a6', 'a7', 'a8', 'ba9'];
        let rlpData = new RLPData(null, testString.map<RLPData>(s => new RLPData(stringToBytes(s), null)));
        let encoded = RLP.encode(rlpData);
        expect<usize>(encoded.length).toBe(114);
        let decoded = RLP.decode(encoded);
        expect<Uint8Array>(decoded.buffer).toBeNull();
        expect<usize>(decoded.children.length).toBe(testString.length);
        for (let i = 0; i < testString.length; i++) {
            expect<string>(bytesToString(decoded.children[i].buffer)).toBe(testString[i]);
        }
    });
});

describe('null values', function() {
    it('encode a null array', function() {
        let encoded = RLP.encode(new RLPData(new Uint8Array(0), null));
        expect<u8>(encoded[0]).toBe(0x80);
        expect<usize>(encoded.length).toBe(1);
    });

    it('should decode a null value', function() {
        let decoded = RLP.decode(arrayToUint8Array([0x80]));
        expect<usize>(decoded.buffer.length).toBe(0);
        expect<RLPData[]>(decoded.children).toBeNull();
    });
});

describe('zero values', function() {
    it('encode a zero', function() {
        let rlpData = new RLPData(arrayToUint8Array([0]), null);
        let encoded = RLP.encode(rlpData);
        expect<u8>(encoded[0]).toBe(0);
        expect<usize>(encoded.length).toBe(1);
    });

    it('decode a zero', function() {
        let decoded = RLP.decode(arrayToUint8Array([0]));
        expect<u8>(decoded.buffer[0]).toBe(0);
        expect<usize>(decoded.buffer.length).toBe(1);
        expect<RLPData[]>(decoded.children).toBeNull();
    })
});

'''
'''--- assembly/index.ts ---
import { RLPData } from "./type";

const hexAlphabet = '0123456789abcdef';

class Decoded {
    data: RLPData;
    remainder: Uint8Array;

    constructor(data: RLPData, remainder: Uint8Array) {
        this.data = data;
        this.remainder = remainder;
    }
}

/**
 * Parse integers. Check if there is no leading zeros
 * Note that this is NOT safe in assemblyscript due to
 * the lack of error handling.
 * @param v The value to parse
 * @param base The base to parse the integer into
 */
function safeParseInt(v: string, base: u32): u32 {
    if (v.slice(0, 2) == '00') {
        throw new Error('invalid RLP: extra zeros');
    }
    return parseI32(v, base) as u32;
}

/** Transform an integer into its hexadecimal value */
function intToHex(integer: u32): string {
    let res = new Array<string>();
    do {
        let t = integer / 16;
        let r = integer % 16;
        integer = t;
        res.push(hexAlphabet[r]);
    } while (integer);
    let hex = res.reverse().join('');
    return hex.length % 2 ? "0" + hex : hex;
}

function bytesToHex(bytes: Uint8Array): string {
    let res = new Uint8Array(bytes.length * 2);
    for (let i = 0; i < bytes.length; i++) {
        let hex = intToHex(bytes[i]);
        res[i*2] = hex.charCodeAt(0);
        res[i*2+1] = hex.charCodeAt(1);
    }
    return String.fromUTF8(res.buffer.data, res.byteLength);
}

function hexToBytes(hex: string): Uint8Array {
    if (!hex.length) {
        return null;
    }
    assert(hex.length % 2 == 0);
    let byteLength = hex.length / 2;
    let res = new Uint8Array(byteLength);
    for (let i = 0; i < byteLength; i++) {
        res[i] = parseI32(hex.substr(i*2, 2), 16) as u8;
    }
    return res;
}

function concatUint8Array(arr1: Uint8Array, arr2: Uint8Array): Uint8Array {
    let len = arr1.byteLength + arr2.byteLength;
    let res = new Uint8Array(len);
    memory.copy(res.buffer.data, arr1.buffer.data + arr1.byteOffset, arr1.byteLength);
    memory.copy(res.buffer.data + arr1.length, arr2.buffer.data + arr2.byteOffset, arr2.byteLength);
    return res;
}

function concatUint8Arrays(arrays: Array<Uint8Array>): Uint8Array {
    let len = arrays.reduce<u32>(((acc, x) => acc + x.byteLength), 0);
    let res = new Uint8Array(len);
    let counter = 0;
    for (let i = 0; i < arrays.length; i++) {
        memory.copy(res.buffer.data + counter, arrays[i].buffer.data + arrays[1].byteOffset, arrays[i].byteLength);
        counter += arrays[i].byteLength;
    }
    return res;
}

/**
 * RLP Encoding based on: https://github.com/ethereum/wiki/wiki/%5BEnglish%5D-RLP
 * This function takes in an argument of type Input and returns the rlp encoding of it.
 * @param input: a Uint8Array or an array of inputs.
 * @returns returns rlp encoded byte array.
 **/
export function encode(input: RLPData): Uint8Array {
    if (input.children) {
        let output = new Array<Uint8Array>();
        for (let i = 0; i < input.children.length; i++) {
            output.push(encode(input.children[i]));
        }
        let buf = concatUint8Arrays(output);
        return concatUint8Array(encodeLength(buf.length, 192), buf);
    } else {
        if (input.buffer.length == 1 && input.buffer[0] < 128) {
            return input.buffer;
        }
        return concatUint8Array(encodeLength(input.buffer.length, 128), input.buffer);
    }
}

function encodeLength(len: u32, offset: u32): Uint8Array {
    if (len < 56) {
        return hexToBytes(intToHex(len + offset));
    } else {
        let hexLength = intToHex(len);
        let lLength = hexLength.length / 2;
        let firstByte = intToHex(offset + 55 + lLength);
        return concatUint8Array(hexToBytes(firstByte), hexToBytes(hexLength));
    }
}

/**
 * RLP Decoding based on: {@link https://github.com/ethereum/wiki/wiki/%5BEnglish%5D-RLP|RLP}
 * @param input - Uint8Array
 * @returns - returns RLPData containing the original message
 **/
export function decode(input: Uint8Array): RLPData {
    let res = _decode(input);
    if (res.remainder.length != 0) {
        throw new Error('invalid remainder');
    }
    return res.data;
}

export function _decode(input: Uint8Array): Decoded {
    let length: u32;
    if (!input.length) {
        throw new Error('invalid input: cannot be empty');
    }
    let firstByte = input[0];
    if (firstByte <= 0x7f) {
        // a single byte whose value is in the [0x00, 0x7f] range, that byte is its own RLP encoding.
        return new Decoded(new RLPData(input.subarray(0, 1),null), input.subarray(1));
    } else if (firstByte <= 0xb7) {
        length = firstByte - 0x7f;
        if (firstByte == 0x80) {
            return new Decoded(new RLPData(new Uint8Array(0), null), new Uint8Array(0));
        }
        let data = input.subarray(1, length);
        if (length == 2 && data[0] < 0x80) {
            throw new Error('invalid rlp encoding: byte must be less 0x80');
        }
        return new Decoded(new RLPData(data, null), input.subarray(length));
    } else if (firstByte <= 0xbf) {
        let llength = firstByte - 0xb6;
        length = safeParseInt(bytesToHex(input.subarray(1, llength)), 16);
        let data = input.subarray(llength, length + llength);
        if ((data.length as u32) < length) {
            throw new Error('invalid RLP');
        }
        return new Decoded(new RLPData(data, null), input.subarray(length + llength));
    } else if (firstByte <= 0xf7) {
        length = firstByte - 0xbf;
        let remainder = input.subarray(1, length);
        let decoded: RLPData[] = [];
        while (remainder.length) {
            let d = _decode(remainder);
            decoded.push(d.data);
            remainder = d.remainder;
        }
        return new Decoded(new RLPData(null, decoded), input.subarray(length));
    } else {
        // a list over 55 bytes long
        let llength = firstByte - 0xf6;
        length = safeParseInt(bytesToHex(input.subarray(1, llength)), 16);
        let totalLength = llength + length;
        if (totalLength > (input.length as u32)) {
            throw new Error('invalid rlp: total length is larger than the data');
        }

        let remainder = input.subarray(llength, totalLength);
        if (remainder.length == 0) {
            throw new Error('invalid rlp, List has a invalid length');
        }
        let decoded: RLPData[] = [];
        while (remainder.length) {
            let d = _decode(remainder);
            decoded.push(d.data);
            remainder = d.remainder;
        }
        return new Decoded(new RLPData(null, decoded), input.subarray(totalLength));
    }
}

'''
'''--- assembly/type.ts ---
/**
 * class that represents data in rlp format. Due to the lack of support for recursive
 * data types, we have to use a class instead.
 */
export class RLPData {
    buffer: Uint8Array;
    children: RLPData[];

    constructor(input: Uint8Array, children: RLPData[]) {
        this.buffer = input;
        this.children = children;
    }
}

'''
'''--- package.json ---
{
  "name": "assemblyscript-rlp",
  "version": "0.0.1",
  "description": "RLP encoding in assemblyscript",
  "scripts": {
    "asbuild:untouched": "asc assembly/index.ts -b build/untouched.wasm -t build/untouched.wat --sourceMap --validate --debug",
    "asbuild:optimized": "asc assembly/index.ts -b build/optimized.wasm -t build/optimized.wat --sourceMap --validate --optimize",
    "asbuild": "npm run asbuild:untouched && npm run asbuild:optimized",
    "test": "asp"
  },
  "dependencies": {},
  "devDependencies": {
    "assemblyscript": "assemblyscript/assemblyscript",
    "typescript": "^3.1.6",
    "as-pect": "jtenner/as-pect"
  }
}

'''