*GitHub Repository "lightsea90/token-factory"*

'''--- README.md ---
Token Factory
==================

This is a smart contract running on NEAR Protocol. It could be used to issue a fungible token with a simple tokenomic.

# Token factory demo
```
$ near create-account treasury.tokenhub.testnet --masterAccount tokenhub.testnet --initialBalance 2
$ near call tokenhub.testnet --accountId harrynguyen006.testnet new '{"owner_id": "harrynguyen.testnet"}'

# register
export current=$(date +%s) test_id=test001
$ near call tokenhub.testnet --accountId harrynguyen005.testnet register '{
    "ft_contract": "'${test_id}'.tokenhub.testnet", 
    "deployer_contract": "'${test_id}'-deployer.tokenhub.testnet",
    "total_supply": "100000000000000000",
    "token_name": "'${test_id}' name",
    "symbol": "'${test_id}'",
    "decimals": 8,
    "allocations": {
        "treasury.tokenhub.testnet": {
            "allocated_percent": 800,
            "initial_release": 0,
            "vesting_start_time": "'$((current+5*60))000000'",
            "vesting_end_time": "'$((current+15*60))000000'",
            "vesting_interval": "'$((5*60))00000'"
        },
        "trietnguyen.testnet": {
            "allocated_percent": 9200,
            "initial_release": 1500,
            "vesting_start_time": "'$((current+5*60))00000'",
            "vesting_end_time": "'$((current+15*60))00000'",
            "vesting_interval": "'$((5*60))00000'"
        }
    }
}' --deposit 8

$ near view tokenhub.testnet list_token_states '{"token_contracts": ["test001.tokenhub.testnet"]}'
View call: tokenhub.testnet.list_token_states({"token_contracts": ["test001.tokenhub.testnet"]})
[
  {
    ft_contract: 'test001.tokenhub.testnet',
    ft_deployer: 'test001-deployer.tokenhub.testnet',
    creator: 'harrynguyen005.testnet',
    ft_contract_deployed: 0,
    deployer_contract_deployed: 0,
    ft_issued: 0,
    allocation_initialized: 0
  }
]
[2022-02-19T08:16:02+07:00] harryng@harryng-desktop:/stuffs/projects/token-factory [*main]
$ near view tokenhub.testnet list_all_token_contracts
View call: tokenhub.testnet.list_all_token_contracts()
[ 'test001.tokenhub.testnet' ]

# deploy ft contract
$ near call tokenhub.testnet --accountId harrynguyen005.testnet create_ft_contract '{
    "ft_contract": "'${test_id}'.tokenhub.testnet"
}' --gas 60000000000000

# deploy ft deployer contract
$ near call tokenhub.testnet --accountId harrynguyen005.testnet create_deployer_contract '{
    "ft_contract": "'${test_id}'.tokenhub.testnet"
}' --gas 60000000000000

# issue token
$ near call tokenhub.testnet --accountId harrynguyen005.testnet issue_ft '{
    "ft_contract": "'${test_id}'.tokenhub.testnet"
}' --gas 60000000000000

# setup token allocation
$ near call tokenhub.testnet --accountId harrynguyen005.testnet init_token_allocation '{
    "ft_contract": "'${test_id}'.tokenhub.testnet"
}' --gas 60000000000000

# check token state
$ near view tokenhub.testnet get_token_state '{
    "ft_contract": "'${test_id}'.tokenhub.testnet"
}'

# storage deposit
near call ${test_id}.tokenhub.testnet storage_deposit '' --accountId harrynguyen005.testnet --amount 0.00125

# claim
$ near call ${test_id}-deployer.tokenhub.testnet claim --accountId harrynguyen005.testnet --gas 60000000000000
$ near call ${test_id}-deployer.tokenhub.testnet claim --accountId treasury.tokenhub.testnet --gas 60000000000000
```

Demo for new functions

```
$ near view tokenhub.testnet list_my_tokens '{"account_id": "harrynguyen.testnet"}'
View call: tokenhub.testnet.list_my_tokens({"account_id": "harrynguyen.testnet"})
[ 'test005_harryng.tokenhub.testnet' ]

$ near view tokenhub.testnet get_token_state '{"ft_contract": "test005_harryng.tokenhub.testnet"}'
View call: tokenhub.testnet.get_token_state({"ft_contract": "test005_harryng.tokenhub.testnet"})
{
  ft_contract: 'test005_harryng.tokenhub.testnet',
  total_supply: '100000000000000000',
  token_name: 'test005 token',
  symbol: 'TEST005_HARRYNG',
  decimals: 8,
  ft_deployer: 'test005_harryng-deployer.tokenhub.testnet',
  creator: 'harrynguyen.testnet',
  initial_release: '15000000000000000',
  vesting_start_time: '1638801669000000000',
  vesting_end_time: '1641393669000000000',
  vesting_interval: '86400000000000',
  treasury_allocation: '8000000000000000',
  ft_contract_deployed: 1,
  deployer_contract_deployed: 1,
  ft_issued: 1,
  allocation_initialized: 1
}

$ near view test005_harryng-deployer.tokenhub.testnet check_account '{"account_id": "harrynguyen.testnet"}'
View call: test005_harryng-deployer.tokenhub.testnet.check_account({"account_id": "harrynguyen.testnet"})
{
  allocated_num: '92000000000000000',
  initial_release: '15000000000000000',
  vesting_start_time: '1638801669000000000',
  vesting_end_time: '1641393669000000000',
  vesting_interval: '86400000000000',
  claimed: '0',
  claimable_amount: '15000000000000000'
}
```

'''
'''--- contract/Cargo.toml ---
[package]
name = "token_factory"
version = "0.0.1"
authors = ["Hai Minh Nguyen"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"
near-contract-standards = "3.1.1"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true

'''
'''--- contract/compile.js ---
// This file does two things:
//
// 1. Compile the Rust contract using cargo (see buildCmd below). This will
//    create a wasm file in the 'build' folder.
// 2. Create a symbolic link (symlink) to the generated wasm file in the root
//    project's `out` folder, for easy use with near-cli.
//
// First, import some helper libraries. `shelljs` is included in the
// devDependencies of the root project, which is why it's available here. It
// makes it easy to use *NIX-style scripting (which works on Linux distros,
// macOS, and Unix systems) on Windows as well.
const sh = require('shelljs')

// Figure out which directory the user called this script from, which we'll use
// later to set up the symlink.
const calledFromDir = sh.pwd().toString()

// For the duration of this script, we want to operate from within the
// Rust project's folder. Let's change into that directory.
sh.cd(__dirname)

// You can call this script with `node compile.js` or `node compile.js
// --debug`. Let's set a variable to track whether `--debug` was used.
const debug = process.argv.pop() === '--debug'

// You can call this script with `node compile.js` or `node compile.js --debug`.
// Let's set a variable to track whether `--debug` was used.
// Note: see other flags in ./cargo/config. Unfortunately, you cannot set the
// `--target option` in Cargo.toml.
const buildCmd = debug
  ? 'cargo build --target wasm32-unknown-unknown'
  : 'cargo build --target wasm32-unknown-unknown --release'

// Execute the build command, storing exit code for later use
const { code } = sh.exec(buildCmd)

// Assuming this is compiled from the root project directory, link the compiled
// contract to the `out` folder â€“
// When running commands like `near deploy`, near-cli looks for a contract at
// <CURRENT_DIRECTORY>/out/main.wasm
if (code === 0 && calledFromDir !== __dirname) {
  const linkDir = `${calledFromDir}/out`
  const link = `${calledFromDir}/out/main.wasm`
  const packageName = require('fs').readFileSync(`${__dirname}/Cargo.toml`).toString().match(/name = "([^"]+)"/)[1]
  const outFile = `./target/wasm32-unknown-unknown/${debug ? 'debug' : 'release'}/${packageName}.wasm`
  sh.mkdir('-p', linkDir)
  sh.rm('-f', link)
  //fixes #831: copy-update instead of linking .- sometimes sh.ln does not work on Windows
  sh.cp('-u',outFile,link)
}

// exit script with the same code as the build command
process.exit(code)

'''
'''--- contract/neardev/dev-account.env ---
CONTRACT_NAME=dev-1650803828099-10796611865441

'''
'''--- contract/neardev/neardev/dev-account.env ---
CONTRACT_NAME=dev-1650778748502-57785537831891
'''
'''--- contract/src/admins.rs ---
use crate::*;

#[near_bindgen]
impl TokenFactory {
    pub fn reset(&mut self) {
        assert!(env::state_exists(), "The contract is not initialized");
        self.assert_admin();
        self.tokens.clear();
    }

    pub fn unregister(&mut self, ft_contract: AccountId) {
        assert!(env::state_exists(), "The contract is not initialized");
        self.assert_admin();
        self.tokens.remove(&ft_contract);

        let state = self
            .tokens
            .get(&ft_contract)
            .expect("ft_contract not found!");

        for allocator in state.allocations.keys_as_vector().iter() {
            let mut user_tokens = self
                .user_token_map
                .get(&allocator)
                .expect("user_tokens not found");
            user_tokens.remove(&ft_contract);
            self.user_token_map.insert(&allocator, &user_tokens);
        }
    }

    pub fn clear_metadata(&mut self, ft_contract: AccountId) {
        assert!(env::state_exists(), "The contract is not initialized");
        self.assert_admin();
        let mut token = self.tokens.remove(&ft_contract).unwrap();
        token.ft_metadata = None;
        token.allocations.clear();
        self.tokens.insert(&ft_contract, &token);
    }

    fn assert_admin(&self) {
        assert!(
            self.admins.contains(&env::predecessor_account_id()),
            "Function called not from the contract admin",
        );
    }

    fn assert_owner_id(&self) {
        assert!(
            env::predecessor_account_id() == self.owner_id,
            "Function called not from the contract owner",
        );
    }

    pub fn add_admin(&mut self, account_id: AccountId) {
        self.assert_owner_id();
        self.admins.insert(&account_id);
    }

    pub fn remove_admin(&mut self, account_id: AccountId) {
        self.assert_owner_id();
        self.admins.remove(&account_id);
    }

    //Update user_tokens_map for existing tokens
    #[private]
    #[init(ignore_state)]
    pub fn migrate() -> Self {
        let old_state: OldTokenFactory = env::state_read().expect("failed");
        let new_state = Self {
            owner_id: old_state.owner_id,
            admins: old_state.admins,
            tokens: old_state.tokens,
            user_token_map: LookupMap::new(b"tokenmap".to_vec()),
        };

        new_state
    }

    pub fn migrate_data(&mut self, from_index: u64, limit: u64) {
        self.assert_admin();
        let contract_ids = self.tokens.keys_as_vector();
        for index in from_index..std::cmp::min(from_index + limit, contract_ids.len()) {
            let contract_id = contract_ids.get(index).unwrap();
            let state = self.tokens.get(&contract_id).unwrap();
            for (allocator, _) in state.allocations.to_vec() {
                let mut tokens = self
                    .user_token_map
                    .get(&allocator)
                    .unwrap_or(UnorderedSet::new(
                        format!("{}#{}", allocator, env::block_timestamp()).as_bytes(),
                    ));

                tokens.insert(&contract_id);
                env::log(
                    format!("account_id: {:#?} tokens {:#?}", allocator, tokens.to_vec())
                        .as_bytes(),
                );
                self.user_token_map.insert(&allocator, &tokens);
            }
        }
    }

    pub fn internal_add_user_token(&mut self, account_id: AccountId, token_id: TokenId) {
        let mut tokens = self
            .user_token_map
            .get(&account_id)
            .unwrap_or(UnorderedSet::new(
                format!("{}#{}", account_id, env::block_timestamp()).as_bytes(),
            ));

        tokens.insert(&token_id);
        env::log(
            format!(
                "account_id: {:#?} tokens {:#?}",
                account_id,
                tokens.to_vec()
            )
            .as_bytes(),
        );
        self.user_token_map.insert(&account_id, &tokens);
    }
}

'''
'''--- contract/src/callbacks.rs ---
use near_sdk::ext_contract;

use crate::*;

#[ext_contract(ext_self)]
pub trait ExtTokenFactory {
    fn on_ft_contract_deployed(&mut self, ft_contract: AccountId) -> bool;
    fn on_ft_deployer_deployed(&mut self, ft_contract: AccountId) -> bool;
    fn on_token_issued(&mut self, ft_contract: AccountId) -> bool;
    fn on_allocation_init(&mut self, ft_contract: AccountId) -> bool;
}

#[near_bindgen]
impl TokenFactory {
    #[private]
    pub fn on_ft_contract_deployed(&mut self, ft_contract: AccountId) -> bool {
        env::log(format!("promise_result_count = {}", env::promise_results_count()).as_bytes());
        match env::promise_result(0) {
            PromiseResult::Successful(_) => {
                let mut token = self.tokens.remove(&ft_contract).unwrap_or_default();
                assert!(
                    token.ft_contract_deployed == 0,
                    "State ft_contract_deployed is invalid",
                );
                token.ft_contract_deployed = 1;
                self.tokens.insert(&ft_contract, &token);
                true
            }
            _ => false,
        }
    }

    #[private]
    pub fn on_ft_deployer_deployed(&mut self, ft_contract: AccountId) -> bool {
        env::log(format!("promise_result_count = {}", env::promise_results_count()).as_bytes());
        // format!("fasfas");
        match env::promise_result(0) {
            PromiseResult::Successful(_) => {
                let mut token = self.tokens.remove(&ft_contract).unwrap_or_default();
                assert!(
                    token.deployer_contract_deployed == 0,
                    "State deployer_contract_deployed is invalid",
                );
                token.deployer_contract_deployed = 1;
                self.tokens.insert(&ft_contract, &token);
                true
            }
            _ => false,
        }
    }

    #[private]
    pub fn on_token_issued(&mut self, ft_contract: AccountId) -> bool {
        env::log(format!("promise_result_count = {}", env::promise_results_count()).as_bytes());
        match env::promise_result(0) {
            PromiseResult::Successful(_) => {
                let mut token = self.tokens.remove(&ft_contract).unwrap_or_default();
                assert!(token.ft_issued == 0, "State ft_issued is invalid",);
                token.ft_issued = 1;
                self.tokens.insert(&ft_contract, &token);
                true
            }
            _ => false,
        }
    }

    #[private]
    pub fn on_allocation_init(&mut self, ft_contract: AccountId) -> bool {
        env::log(format!("promise_result_count = {}", env::promise_results_count()).as_bytes());
        match env::promise_result(0) {
            PromiseResult::Successful(_) => {
                let mut token = self.tokens.remove(&ft_contract).unwrap_or_default();
                assert!(
                    token.allocation_initialized == 0,
                    "State allocation_initialized is invalid",
                );
                token.allocation_initialized = 1;
                // TODO: this is temporary. It needs to be uncommented at some point
                // token.ft_metadata = None;
                // token.allocations.clear();
                self.tokens.insert(&ft_contract, &token);
                true
            }
            _ => false,
        }
    }
}

'''
'''--- contract/src/lib.rs ---
/*
Functions:

 */

// To conserve gas, efficient serialization is achieved through Borsh (http://borsh.io/)
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LookupMap, UnorderedMap, UnorderedSet};
use near_sdk::json_types::{Base64VecU8, WrappedBalance, WrappedDuration, WrappedTimestamp};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::serde_json::{json, Value};
use near_sdk::{env, near_bindgen, PanicOnDefault};
use near_sdk::{AccountId, Balance, Duration, Gas, Timestamp};
use near_sdk::{Promise, PromiseResult};
use std::collections::HashMap;

use crate::callbacks::ext_self;

mod admins;
mod callbacks;
mod views;

near_sdk::setup_alloc!();
pub type TokenId = AccountId;

const DEFAULT_GAS_FEE: Gas = 20_000_000_000_000;
const TOKENHUB_TREASURY: &str = "treasury.tokenhub.testnet";
const FT_WASM_CODE: &[u8] = include_bytes!("../../static/fungible_token.wasm");
const DEPLOYER_WASM_CODE: &[u8] = include_bytes!("../../static/token_deployer.wasm");
const MAX_SUPPLY_PERCENT: u64 = 10000; // Decimal: 2

pub type TokenAllocationInput = HashMap<AccountId, WrappedTokenAllocation>;

#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct WrappedTokenAllocation {
    allocated_percent: u64,
    initial_release: u64,
    vesting_start_time: WrappedTimestamp,
    vesting_end_time: WrappedTimestamp,
    vesting_interval: WrappedDuration,
}

#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct TokenAllocation {
    allocated_percent: u64, // Decimal: 2
    initial_release: u64,
    vesting_start_time: Timestamp,
    vesting_end_time: Timestamp,
    vesting_interval: Duration,
    claimed: u64,
}

#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct FTMetadata {
    total_supply: Balance,
    token_name: String,
    symbol: String,
    icon: Option<String>,
    reference: Option<String>,
    reference_hash: Option<Base64VecU8>,
    decimals: u8,
}

#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct WrappedFTMetadata {
    total_supply: WrappedBalance,
    token_name: String,
    symbol: String,
    icon: Option<String>,
    reference: Option<String>,
    reference_hash: Option<Base64VecU8>,
    decimals: u8,
}

impl From<FTMetadata> for WrappedFTMetadata {
    fn from(ft_metadata: FTMetadata) -> Self {
        WrappedFTMetadata {
            total_supply: WrappedBalance::from(ft_metadata.total_supply),
            token_name: ft_metadata.token_name,
            symbol: ft_metadata.symbol,
            icon: ft_metadata.icon,
            reference: ft_metadata.reference,
            reference_hash: ft_metadata.reference_hash,
            decimals: ft_metadata.decimals,
        }
    }
}

#[derive(BorshDeserialize, BorshSerialize)]
pub struct State {
    // token info
    ft_contract: AccountId,
    ft_metadata: Option<FTMetadata>,

    // creator and deployer
    ft_deployer: AccountId,
    creator: AccountId,

    // Multiple tokenomics
    allocations: UnorderedMap<AccountId, TokenAllocation>, // => None after deploy token

    // issuance states
    ft_contract_deployed: u8,
    deployer_contract_deployed: u8,
    ft_issued: u8,
    allocation_initialized: u8,
}

#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct WrappedState {
    // token info
    ft_contract: AccountId,
    ft_metadata: Option<WrappedFTMetadata>,

    // creator and deployer
    ft_deployer: AccountId,
    creator: AccountId,

    // Multiple tokenomics
    allocations: Vec<(AccountId, TokenAllocation)>, // => None after deploy token

    // issuance states
    ft_contract_deployed: u8,
    deployer_contract_deployed: u8,
    ft_issued: u8,
    allocation_initialized: u8,
}

impl From<State> for WrappedState {
    fn from(state: State) -> Self {
        WrappedState {
            ft_contract: state.ft_contract,
            ft_metadata: match state.ft_metadata {
                None => None,
                Some(d) => Some(WrappedFTMetadata::from(d)),
            },
            // Some(WrappedFTMetadata::from(state.ft_metadata.expect("ft metadata not found!"))),

            // creator and deployer
            ft_deployer: state.ft_deployer,
            creator: state.creator,

            // Multiple tokenomics
            allocations: state.allocations.to_vec(), // => None after deploy token

            // issuance states
            ft_contract_deployed: state.ft_contract_deployed,
            deployer_contract_deployed: state.deployer_contract_deployed,
            ft_issued: state.ft_issued,
            allocation_initialized: state.allocation_initialized,
        }
    }
}

impl Default for State {
    fn default() -> Self {
        let default_string_value = String::from("__default_value__");
        Self {
            ft_contract: default_string_value.clone(),
            ft_metadata: Some(FTMetadata {
                total_supply: 0,
                token_name: default_string_value.clone(),
                symbol: default_string_value.clone(),
                icon: Some(default_string_value.clone()),
                reference: None,
                reference_hash: None,
                decimals: 0,
            }),

            ft_deployer: default_string_value.clone(),
            creator: default_string_value.clone(),

            allocations: UnorderedMap::new(b"tokennomics".to_vec()),

            ft_contract_deployed: 0,
            deployer_contract_deployed: 0,
            ft_issued: 0,
            allocation_initialized: 0,
        }
    }
}
//TODO: Delete this struct
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct OldTokenFactory {
    owner_id: AccountId,
    admins: UnorderedSet<AccountId>,
    tokens: UnorderedMap<TokenId, State>,
    user_token_map: LookupMap<AccountId, UnorderedSet<TokenId>>,
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct TokenFactory {
    owner_id: AccountId,
    admins: UnorderedSet<AccountId>,
    tokens: UnorderedMap<TokenId, State>,
    user_token_map: LookupMap<AccountId, UnorderedSet<TokenId>>,
}

#[near_bindgen]
impl TokenFactory {
    #[init]
    pub fn new(owner_id: AccountId) -> Self {
        return Self {
            owner_id: String::from(owner_id),
            admins: UnorderedSet::new(b"admins".to_vec()),
            tokens: UnorderedMap::new(b"tokenspec".to_vec()),
            user_token_map: LookupMap::new(b"tokenmap".to_vec()),
        };
    }

    #[payable]
    pub fn register(
        &mut self,
        ft_contract: AccountId,
        deployer_contract: AccountId,
        total_supply: WrappedBalance,
        token_name: String,
        symbol: String,
        icon: Option<String>,
        reference: Option<String>,
        reference_hash: Option<Base64VecU8>,
        allocations: TokenAllocationInput,
        decimals: u8,
    ) {
        assert!(
            env::attached_deposit() >= 4_000_000_000_000_000_000_000_000,
            "Minimum deposit is 4 NEAR",
        );

        let mut allocation_prefix = Vec::with_capacity(33);
        // Adding unique prefix.
        allocation_prefix.push(b'a');
        // Adding the hash of the account_id (key of the outer map) to the prefix.
        // This is needed to differentiate across accounts.
        allocation_prefix.extend(env::sha256(
            format!("{}@{}", ft_contract, env::block_timestamp()).as_bytes(),
        ));

        let mut state_allocations: UnorderedMap<AccountId, TokenAllocation> =
            UnorderedMap::new(allocation_prefix);

        let mut treasury_exist = false;

        for (account_id, alloc) in &allocations {
            let a = TokenAllocation {
                allocated_percent: alloc.allocated_percent.into(),
                initial_release: alloc.initial_release,
                vesting_start_time: alloc.vesting_start_time.into(),
                vesting_end_time: alloc.vesting_end_time.into(),
                vesting_interval: alloc.vesting_interval.into(),
                claimed: 0,
            };

            if account_id == TOKENHUB_TREASURY && a.allocated_percent > 0 {
                treasury_exist = true;
            }

            self.assert_invalid_allocation(a.clone());
            state_allocations.insert(account_id, &a);

            let total_allocs: u64 = state_allocations
                .values()
                .map(|v: TokenAllocation| v.allocated_percent)
                .sum();

            assert!(
                total_allocs <= MAX_SUPPLY_PERCENT,
                "Total allocations is greater than total supply"
            );
        }

        let total_allocs: u64 = state_allocations
            .values()
            .map(|v: TokenAllocation| v.allocated_percent)
            .sum();
        assert!(
            total_allocs == MAX_SUPPLY_PERCENT,
            "Total allocations is not 100%"
        );

        assert!(treasury_exist, "Treasury allocation must exist!");

        let token = State {
            ft_contract: ft_contract.clone(),
            ft_metadata: Some(FTMetadata {
                total_supply: total_supply.into(),
                token_name,
                symbol,
                icon,
                reference,
                reference_hash,
                decimals,
            }),

            ft_deployer: deployer_contract,
            creator: env::signer_account_id(),

            allocations: state_allocations,

            ft_contract_deployed: 0,
            deployer_contract_deployed: 0,
            ft_issued: 0,
            allocation_initialized: 0,
        };

        assert!(
            token
                .ft_metadata
                .as_ref()
                .expect("Not found ft_metadata")
                .total_supply
                > 0,
            "total_supply must be greater than 0",
        );
        assert!(
            env::is_valid_account_id(token.ft_contract.as_bytes()),
            "ft_contract is not valid",
        );
        assert!(
            env::is_valid_account_id(token.ft_deployer.as_bytes()),
            "ft_deployer is not valid",
        );
        if let Some(_) = self.tokens.get(&token.ft_contract) {
            std::panic!("ft_contract already registered");
        }

        // TODO: validate more?
        self.tokens.insert(&ft_contract, &token);
    }

    pub fn create_ft_contract(&mut self, ft_contract: AccountId) -> Promise {
        let token = self.tokens.get(&ft_contract.clone()).unwrap_or_default();
        self.assert_creator(token.creator);

        return Promise::new(ft_contract.parse().unwrap())
            .create_account()
            //Disable this line in production
            .add_full_access_key(env::signer_account_pk())
            .transfer(4_000_000_000_000_000_000_000_000)
            .deploy_contract(FT_WASM_CODE.to_vec())
            .then(ext_self::on_ft_contract_deployed(
                ft_contract,
                &env::current_account_id(),
                0,
                DEFAULT_GAS_FEE,
            ));
    }

    pub fn create_deployer_contract(&mut self, ft_contract: AccountId) -> Promise {
        let token = self.tokens.get(&ft_contract).unwrap_or_default();
        self.assert_creator(token.creator);

        return Promise::new(token.ft_deployer.parse().unwrap())
            .create_account()
            // .add_full_access_key(env::signer_account_pk())
            .transfer(4_000_000_000_000_000_000_000_000)
            .deploy_contract(DEPLOYER_WASM_CODE.to_vec())
            .then(ext_self::on_ft_deployer_deployed(
                ft_contract,
                &env::current_account_id(),
                0,
                DEFAULT_GAS_FEE,
            ));
    }

    pub fn issue_ft(&mut self, ft_contract: AccountId) -> Promise {
        let token = self.tokens.get(&ft_contract).unwrap_or_default();
        self.assert_creator(token.creator);

        let ft_metadata = token.ft_metadata.expect("Not found ft_metadata");

        return Promise::new(ft_contract.parse().unwrap())
            .function_call(
                b"new".to_vec(),
                json!({
                    "owner_id": token.ft_deployer,
                    "total_supply": WrappedBalance::from(
                            ft_metadata
                            .total_supply
                    ),
                    "metadata": {
                        "spec": "ft-1.0.0",
                        "name": ft_metadata.token_name,
                        "symbol": ft_metadata.symbol,
                        "icon": ft_metadata.icon,
                        "reference": ft_metadata.reference,
                        "reference_hash": ft_metadata.reference,
                        "decimals": ft_metadata.decimals,
                    }
                })
                .to_string()
                .as_bytes()
                .to_vec(),
                0,
                DEFAULT_GAS_FEE,
            )
            .then(ext_self::on_token_issued(
                ft_contract,
                &env::current_account_id(),
                0,
                DEFAULT_GAS_FEE,
            ));
    }

    pub fn init_token_allocation(&mut self, ft_contract: AccountId) -> Promise {
        let token = self.tokens.get(&ft_contract).unwrap_or_default();
        self.assert_creator(token.creator);

        let mut allocations: HashMap<AccountId, WrappedTokenAllocation> = HashMap::new();

        for k in token.allocations.keys() {
            //Add allocators to user_tokens_map
            self.internal_add_user_token(k.clone(), ft_contract.clone());

            allocations.insert(
                k.clone(),
                token
                    .allocations
                    .get(&k.clone())
                    .map(|v| WrappedTokenAllocation {
                        allocated_percent: v.allocated_percent,
                        initial_release: v.initial_release,
                        vesting_start_time: WrappedTimestamp::from(v.vesting_start_time),
                        vesting_end_time: WrappedTimestamp::from(v.vesting_end_time),
                        vesting_interval: WrappedTimestamp::from(v.vesting_interval),
                    })
                    .expect("Allocation not found"),
            );
        }

        return Promise::new(token.ft_deployer.parse().unwrap())
            .function_call(
                b"new".to_vec(),
                json!({
                    "ft_contract_name": ft_contract,
                    "total_supply": WrappedBalance::from(
                        token
                            .ft_metadata
                            .expect("Not found ft_metadata")
                            .total_supply
                    ),
                    "allocations": allocations
                })
                .to_string()
                .as_bytes()
                .to_vec(),
                0,
                DEFAULT_GAS_FEE,
            )
            .then(ext_self::on_allocation_init(
                ft_contract,
                &env::current_account_id(),
                0,
                DEFAULT_GAS_FEE,
            ));
    }

    /// Utils
    //Get total allocations
    pub fn assert_invalid_allocations(&self, ft_contract: AccountId) {
        let token = self.tokens.get(&ft_contract).unwrap_or_default();

        env::log(
            format!(
                "total supply: {}, allocation length: {}",
                token.ft_metadata.as_ref().expect("fadfa").total_supply,
                token.allocations.values_as_vector().len(),
            )
            .as_bytes(),
        );

        assert!(
            token
                .ft_metadata
                .as_ref()
                .expect("Not found ft_metadata")
                .total_supply
                > 0
                && token.allocations.values_as_vector().len() > 0,
            "Token is not register"
        );

        let total_allocations: u64 = token
            .allocations
            .values()
            .map(|a| {
                self.assert_invalid_allocation(a.clone());
                a.allocated_percent
            })
            .sum();

        assert!(
            total_allocations == MAX_SUPPLY_PERCENT,
            "Total allocations is not equal to total supply"
        );
    }

    fn assert_invalid_allocation(&self, allocation: TokenAllocation) {
        //TODO: Allocation > 0
        assert!(
            allocation.allocated_percent >= allocation.claimed,
            "Allocation is smaller than the total claimable",
        );
        assert!(
            allocation.vesting_interval
                <= allocation.vesting_end_time - allocation.vesting_start_time,
            "Vesting interval is larger than vesting time",
        );
    }

    fn assert_creator(&self, creator: AccountId) {
        assert!(
            env::predecessor_account_id() == creator,
            "Only creator is allowed to execute the function",
        );
    }
}

/*
 * The rest of this file holds the inline tests for the code above
 * Learn more about Rust tests: https://doc.rust-lang.org/book/ch11-01-writing-tests.html
 *
 * To run from contract directory:
 * cargo test -- --nocapture
 *
 * From project root, to run in combination with frontend tests:
 * yarn test
 *
 */

#[cfg(test)]
mod tests {
    use super::*;
    use near_sdk::MockedBlockchain;
    use near_sdk::{testing_env, VMContext};

    // mock the context for testing, notice "signer_account_id" that was accessed above from env::
    fn get_context(input: Vec<u8>, is_view: bool) -> VMContext {
        VMContext {
            current_account_id: "tokensale_near".to_string(),
            signer_account_id: "harrynguyen_near".to_string(),
            signer_account_pk: vec![0, 1, 2],
            predecessor_account_id: "harrynguyen_near".to_string(),
            input,
            block_index: 0,
            block_timestamp: 0,
            account_balance: 0,
            account_locked_balance: 0,
            storage_usage: 0,
            attached_deposit: 1_000_000_000_000_000_000_000_000,
            prepaid_gas: 10u64.pow(18),
            random_seed: vec![0, 1, 2],
            is_view,
            output_data_receivers: vec![],
            epoch_height: 19,
        }
    }
}

'''
'''--- contract/src/views.rs ---
use crate::*;

#[near_bindgen]
impl TokenFactory {
    pub fn get_token_state(self, ft_contract: AccountId) -> WrappedState {
        let token = self.tokens.get(&ft_contract).unwrap_or_default();
        assert!(
            token.ft_contract != String::from("__default_value__"),
            "Token is not registered",
        );
        WrappedState::from(token)
    }

    pub fn list_tokens_by_account_id(&self, account_id: AccountId) -> Vec<TokenId> {
        assert!(env::state_exists(), "The contract is not initialized");

        if let Some(token_ids) = self.user_token_map.get(&account_id) {
            return token_ids.to_vec();
        }
        vec![]
    }

    pub fn list_token_contracts(&self, from_index: u64, limit: u64) -> Vec<WrappedState> {
        assert!(env::state_exists(), "The contract is not initialized");

        let keys = self.tokens.keys_as_vector();

        let from = if keys.len() > (limit + from_index) {
            keys.len() - limit - from_index
        } else {
            0
        };

        let to = if keys.len() > from_index {
            keys.len() - from_index
        } else {
            0
        };

        (from..to)
            .map(|index| {
                let key = keys.get(index).unwrap();
                let state = self.tokens.get(&key).unwrap();
                WrappedState::from(state)
            })
            .rev()
            .collect()
    }

    pub fn list_token_states(&self, token_contracts: Vec<AccountId>) -> Vec<WrappedState> {
        assert!(env::state_exists(), "The contract is not initialized");
        let mut result = vec![];
        for token in token_contracts.iter() {
            let state = self.tokens.get(&token).unwrap_or_default();

            result.push(WrappedState::from(state));
        }
        return result;
    }

    //NOTE: Use for the old version
    pub fn list_all_tokens(&self) -> Vec<WrappedState> {
        assert!(env::state_exists(), "The contract is not initialized");

        let token_list = self.tokens.keys_as_vector();
        let mut result = vec![];

        for token in token_list.iter() {
            let state = self.tokens.get(&token).unwrap_or_default();
            // let e = json!({state.ft_contract});
            let e = WrappedState::from(state);
            result.push(e);
        }

        return result;
    }

    pub fn list_all_token_contracts(self) -> Value {
        assert!(env::state_exists(), "The contract is not initialized");

        let token_list = self.tokens.keys_as_vector();
        let mut result: Value = json!([]);

        for token in token_list.iter() {
            result.as_array_mut().unwrap().push(json!(token));
        }
        return result;
    }

    pub fn list_my_tokens(&self, account_id: AccountId) -> Vec<WrappedState> {
        assert!(env::state_exists(), "The contract is not initialized");

        let token_list = self.tokens.keys_as_vector();
        let mut result = vec![];

        for token in token_list.iter() {
            let state = self.tokens.get(&token).unwrap_or_default();
            if state.creator.eq(&account_id) {
                // let e = json!({state.ft_contract});
                let e = WrappedState::from(state);
                result.push(e);
            }
        }

        return result;
    }
}

'''
'''--- package.json ---
{
  "name": "token-sale-001",
  "version": "0.0.1",
  "license": "CC0 1.0 Universal",
  "scripts": {
    "build": "npm run build:contract && npm run build:web",
    "build:contract": "node contract/compile.js",
    "build:contract:debug": "node contract/compile.js --debug",
    "build:web": "parcel build src/index.html --public-url ./",
    "dev:deploy:contract": "near dev-deploy",
    "deploy:contract": "near deploy",
    "deploy:pages": "gh-pages -d dist/",
    "deploy": "npm run build && npm run deploy:contract && npm run deploy:pages",
    "prestart": "npm run build:contract:debug && npm run dev:deploy:contract",
    "start": "echo The app is starting! It will automatically open in your browser when ready && env-cmd -f ./neardev/dev-account.env parcel src/index.html --open",
    "dev": "nodemon --watch contract/src -e rs --exec \"npm run start\"",
    "test": "npm run build:contract:debug && cd contract && cargo test -- --nocapture && cd .. && jest test --runInBand"
  },
  "devDependencies": {
    "env-cmd": "~10.1.0",
    "gh-pages": "~3.1.0",
    "jest": "~26.6.2",
    "jest-environment-node": "~26.6.2",
    "near-cli": "~1.6.0",
    "nodemon": "~2.0.3",
    "parcel-bundler": "~1.12.4",
    "shelljs": "~0.8.4"
  },
  "dependencies": {
    "moment": "^2.29.1",
    "near-api-js": "~0.41.0",
    "regenerator-runtime": "^0.13.9"
  },
  "jest": {
    "testEnvironment": "near-cli/test_environment",
    "testPathIgnorePatterns": [
      "<rootDir>/contract/",
      "<rootDir>/node_modules/"
    ]
  }
}

'''