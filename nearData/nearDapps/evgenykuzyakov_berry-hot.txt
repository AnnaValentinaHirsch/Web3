*GitHub Repository "evgenykuzyakov/berry-hot"*

'''--- README.md ---
# TBD

'''
'''--- contract/Cargo.toml ---
[package]
name = "berry-hot"
version = "0.1.0"
authors = ["Evgeny Kuzyakov <ek@near.org>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "=3.0.0-pre.2"

[profile.release]
codegen-units=1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- contract/build.sh ---
#!/bin/bash
set -e
cd "`dirname $0`"
RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/berry_hot.wasm ./res/

'''
'''--- contract/src/account.rs ---
use crate::*;
use near_sdk::json_types::WrappedBalance;
use near_sdk::Balance;

#[derive(BorshDeserialize, BorshSerialize)]
pub struct Account {
    pub requests: Vec<ReviewRequest>,

    pub cards: UnorderedSet<CardId>,

    pub purchase_volume: Balance,

    pub num_purchases: u64,

    pub sale_profit: Balance,

    pub num_sales: u64,

    pub num_votes: u64,
}

#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct AccountView {
    pub requests: Vec<ReviewRequest>,

    pub num_cards: u64,

    pub purchase_volume: WrappedBalance,

    pub num_purchases: u64,

    pub sale_profit: WrappedBalance,

    pub num_sales: u64,

    pub num_votes: u64,
}

impl From<&Account> for AccountView {
    fn from(a: &Account) -> Self {
        Self {
            requests: a.requests.clone(),
            num_cards: a.cards.len(),
            purchase_volume: a.purchase_volume.into(),
            num_purchases: a.num_purchases,
            sale_profit: a.sale_profit.into(),
            num_sales: a.num_sales,
            num_votes: a.num_votes,
        }
    }
}

#[near_bindgen]
impl Contract {
    pub fn get_account(&self, account_id: ValidAccountId) -> Option<AccountView> {
        self.accounts.get(account_id.as_ref()).map(|a| (&a).into())
    }

    pub fn register_account(&mut self) -> AccountView {
        let account_id = env::predecessor_account_id();
        let account = self.get_account_or_create(&account_id);
        self.save_account(&account_id, &account);
        (&account).into()
    }

    pub fn get_num_accounts(&self) -> u64 {
        self.accounts.len()
    }

    pub fn get_accounts(&self, from_index: u64, limit: u64) -> Vec<(AccountId, AccountView)> {
        let account_ids = self.accounts.keys_as_vector();
        let accounts = self.accounts.values_as_vector();
        (from_index..std::cmp::min(from_index + limit, account_ids.len()))
            .map(|index| {
                let account_id = account_ids.get(index).unwrap();
                let account_view = (&accounts.get(index).unwrap()).into();
                (account_id, account_view)
            })
            .collect()
    }

    pub fn get_account_cards(
        &self,
        account_id: ValidAccountId,
        from_index: u64,
        limit: u64,
    ) -> Vec<(CardId, Rating)> {
        let account = self
            .accounts
            .get(account_id.as_ref())
            .expect("Account not found");
        let card_ids = account.cards.as_vector();
        (from_index..std::cmp::min(from_index + limit, card_ids.len()))
            .filter_map(|index| {
                card_ids
                    .get(index)
                    .map(|card_id| (card_id, self.rating.get(&card_id).unwrap_or(0).into()))
            })
            .collect()
    }
}

impl Contract {
    pub(crate) fn get_account_or_create(&self, account_id: &AccountId) -> Account {
        self.accounts.get(&account_id).unwrap_or_else(|| {
            let mut prefix = Vec::with_capacity(33);
            prefix.push(b'u');
            prefix.extend(env::sha256(account_id.as_bytes()));
            Account {
                requests: self.generate_requests(REQUEST_QUEUE_LEN),
                cards: UnorderedSet::new(prefix),
                purchase_volume: 0,
                num_purchases: 0,
                sale_profit: 0,
                num_sales: 0,
                num_votes: 0,
            }
        })
    }

    pub(crate) fn save_account(&mut self, account_id: &AccountId, account: &Account) {
        self.accounts.insert(account_id, account);
    }
}

'''
'''--- contract/src/card.rs ---
use crate::*;
use near_sdk::BlockHeight;

pub type CardId = BlockHeight;

#[near_bindgen]
impl Contract {
    pub fn get_num_cards(&self) -> u64 {
        self.rating.len()
    }

    pub fn get_top(&self, from_key: Option<(Rating, CardId)>, limit: u64) -> Vec<(Rating, CardId)> {
        if let Some((r, b)) = from_key {
            self.leaders
                .iter_rev_from((r.into(), b))
                .take(limit as usize)
                .map(|((r, b), _)| (r.into(), b))
                .collect()
        } else {
            self.leaders
                .iter_rev()
                .take(limit as usize)
                .map(|((r, b), _)| (r.into(), b))
                .collect()
        }
    }

    pub fn get_rating(&self, card_id: CardId) -> Rating {
        self.rating.get(&card_id).unwrap_or_default().into()
    }

    pub fn get_recent_cards(
        &self,
        offset: Option<u64>,
        limit: Option<u64>,
    ) -> Vec<(Rating, CardId)> {
        if self.recent_buys_end == 0 {
            return Vec::new();
        }
        let offset = offset.unwrap_or(0);
        let limit = limit.unwrap_or(RECENT_BUY_LIMIT);
        (offset..std::cmp::min(limit, self.recent_buys_end))
            .filter_map(|index| {
                self.recent_buys
                    .get(&(self.recent_buys_end - index - 1))
                    .map(|card_id| (self.rating.get(&card_id).unwrap_or(0).into(), card_id))
            })
            .collect()
    }
}

'''
'''--- contract/src/lib.rs ---
mod account;
mod card;
mod rating;
mod request;
mod trade;

use crate::account::*;
use crate::card::*;
use crate::rating::*;
use crate::request::*;
use crate::trade::*;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LookupMap, TreeMap, UnorderedMap, UnorderedSet};
use near_sdk::json_types::ValidAccountId;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{env, near_bindgen, AccountId, PanicOnDefault};

near_sdk::setup_alloc!();

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    pub leaders: TreeMap<(u128, CardId), ()>,

    pub accounts: UnorderedMap<AccountId, Account>,

    pub rating: UnorderedMap<CardId, u128>,

    pub num_votes: u64,

    pub recent_buys: LookupMap<u64, CardId>,

    pub recent_buys_end: u64,
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new(app_owner_id: ValidAccountId, art_dao_id: ValidAccountId) -> Self {
        let mut this = Self {
            leaders: TreeMap::new(b"t".to_vec()),
            accounts: UnorderedMap::new(b"a".to_vec()),
            rating: UnorderedMap::new(b"r".to_vec()),
            num_votes: 0,
            recent_buys: LookupMap::new(b"b".to_vec()),
            recent_buys_end: 0,
        };

        this.save_trade_data(&TradeData::new(app_owner_id.into(), art_dao_id.into()));

        this
    }

    #[private]
    #[init(ignore_state)]
    pub fn migrate() -> Self {
        #[derive(BorshDeserialize)]
        pub struct OldContract {
            pub leaders: TreeMap<(u128, CardId), ()>,

            pub accounts: UnorderedMap<AccountId, Account>,

            pub rating: UnorderedMap<CardId, u128>,

            pub num_votes: u64,
        }

        let state: OldContract = env::state_read().unwrap();

        Self {
            leaders: state.leaders,
            accounts: state.accounts,
            rating: state.rating,
            num_votes: state.num_votes,
            recent_buys: LookupMap::new(b"b".to_vec()),
            recent_buys_end: 0,
        }
    }
}

'''
'''--- contract/src/rating.rs ---
use crate::*;
use near_sdk::json_types::U128;

pub type Rating = U128;

pub const INFLATION_TIMESTAMP: u64 = 1621623768597000000;
pub const HALFLIFE_DURATION: f64 = 2628000000000000.0;

impl Contract {
    pub(crate) fn update_rating(&mut self, winner_id: CardId, loser_id: CardId) -> Option<CardId> {
        let mut new_card = None;
        let winner_rating = self.rating.remove(&winner_id).unwrap_or_default();
        if winner_rating > 0 {
            self.leaders.remove(&(winner_rating, winner_id));
        } else {
            new_card = Some(winner_id);
        }
        let loser_rating = self.rating.remove(&loser_id).unwrap_or_default();
        if loser_rating > 0 {
            self.leaders.remove(&(loser_rating, loser_id));
        }
        let bet = loser_rating / 10;
        let winner_rating = (winner_rating + bet + Self::win_bonus()).into();
        let loser_rating = (loser_rating - bet).into();
        self.num_votes += 1;
        self.rating.insert(&winner_id, &winner_rating);
        self.leaders.insert(&(winner_rating, winner_id), &());
        if loser_rating > 0 {
            self.rating.insert(&loser_id, &loser_rating);
        }
        if loser_rating >= Self::min_rating() {
            self.leaders.insert(&(loser_rating, loser_id), &());
        }
        new_card
    }

    pub(crate) fn set_rating(&mut self, card_id: CardId, old_rating: u128, new_rating: u128) {
        self.leaders.remove(&(old_rating, card_id));
        if old_rating != self.rating.insert(&card_id, &new_rating).unwrap() {
            env::panic(b"Internal rating mismatch");
        }
        if new_rating >= Self::min_rating() {
            self.leaders.insert(&(new_rating, card_id), &());
        }
    }

    pub(crate) fn multiplier() -> f64 {
        let duration = (env::block_timestamp() - INFLATION_TIMESTAMP) as f64;
        2f64.powf(duration / HALFLIFE_DURATION)
    }

    pub(crate) fn min_rating() -> u128 {
        (1e24 * Self::multiplier()) as u128
    }

    pub(crate) fn win_bonus() -> u128 {
        (1e24 * Self::multiplier()) as u128
    }
}

'''
'''--- contract/src/request.rs ---
use crate::*;
use std::convert::TryInto;

#[derive(Copy, Clone, BorshDeserialize, BorshSerialize, Serialize, Deserialize, PartialEq)]
#[serde(crate = "near_sdk::serde")]
pub struct ReviewRequest {
    pub left: CardId,
    pub right: CardId,
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub enum ReviewResponse {
    SelectedLeft,
    SelectedRight,
    Skipped,
}

const FIRST_BERRY_BLOCK: u64 = 21793900;
const MIN_CARDS_FOR_FIGHTS: u64 = 10;

pub const REQUEST_QUEUE_LEN: usize = 3;

#[near_bindgen]
impl Contract {
    pub fn vote(&mut self, request: ReviewRequest, response: ReviewResponse) -> ReviewRequest {
        let account_id = env::predecessor_account_id();
        let mut account = self.get_account_or_create(&account_id);
        if account.requests[0] != request {
            env::panic(b"Voted on the invalid request");
        }
        account.requests.remove(0);
        account.requests.extend(self.generate_requests(1));

        if let Some(card_id) = self.resolve_request(&request, response) {
            let purchase_info = CardInfo {
                owner_id: account_id.clone(),
                purchase_price: 0.into(),
                purchase_time: env::block_timestamp().into(),
                num_trades: 0,
                volume: 0.into(),
                art_dao_profit: 0.into(),
            };

            let mut trade_data = self.load_trade_data();
            assert!(trade_data.cards.insert(&card_id, &purchase_info).is_none());
            self.save_trade_data(&trade_data);

            account.cards.insert(&card_id);

            self.insert_recent_buy(card_id);
        }

        account.num_votes += 1;

        self.save_account(&account_id, &account);
        account.requests.pop().unwrap()
    }
}

impl Contract {
    pub(crate) fn generate_requests(&self, num_requests: usize) -> Vec<ReviewRequest> {
        let mut seed = env::random_seed();
        (0..num_requests)
            .map(|_| self.random_request(&mut seed))
            .collect()
    }

    fn random_request(&self, seed: &mut Vec<u8>) -> ReviewRequest {
        loop {
            *seed = env::sha256(&seed);
            let request = ReviewRequest {
                left: self.random_card(u128::from_le_bytes((&seed[..16]).try_into().unwrap())),
                right: self.random_card(u128::from_le_bytes((&seed[16..]).try_into().unwrap())),
            };
            if request.left != request.right {
                break request;
            }
        }
    }

    fn random_card(&self, r: u128) -> CardId {
        if (r & (1u128 << 64)) > 0 && self.rating.len() > MIN_CARDS_FOR_FIGHTS {
            self.rating
                .keys_as_vector()
                .get((r % (self.rating.len() as u128)) as u64)
                .unwrap()
        } else {
            let num_blocks = (env::block_index() - FIRST_BERRY_BLOCK) as u128;
            // let num_blocks = (37950489 - FIRST_BERRY_BLOCK) as u128;
            let sqr = r % (num_blocks * num_blocks);
            let sq = (sqr as f64).sqrt() as u64;
            FIRST_BERRY_BLOCK + sq
        }
    }

    fn resolve_request(
        &mut self,
        old_request: &ReviewRequest,
        response: ReviewResponse,
    ) -> Option<CardId> {
        match response {
            ReviewResponse::SelectedLeft => self.update_rating(old_request.left, old_request.right),
            ReviewResponse::SelectedRight => {
                self.update_rating(old_request.right, old_request.left)
            }
            ReviewResponse::Skipped => None,
        }
    }
}

'''
'''--- contract/src/trade.rs ---
use crate::*;
use near_sdk::json_types::{WrappedBalance, WrappedTimestamp};
use near_sdk::{env, log, Balance, Promise};

const TRADE_DATA_KEY: &[u8] = b"d";
pub(crate) const RECENT_BUY_LIMIT: u64 = 1000;

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct CardInfo {
    pub owner_id: AccountId,
    pub purchase_price: WrappedBalance,
    pub purchase_time: WrappedTimestamp,
    pub num_trades: u64,
    pub volume: WrappedBalance,
    pub art_dao_profit: WrappedBalance,
}

#[derive(BorshDeserialize, BorshSerialize)]
pub struct TradeData {
    pub cards: LookupMap<CardId, CardInfo>,

    pub num_purchases: u64,

    pub num_unique_cards_bought: u64,

    pub near_volume: Balance,

    pub app_owner_profit: Balance,

    pub art_dao_profit: Balance,

    pub app_owner_id: AccountId,

    pub art_dao_id: AccountId,
}

#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct TradeDataView {
    pub num_purchases: u64,

    pub num_unique_cards_bought: u64,

    pub near_volume: Balance,

    pub app_owner_profit: Balance,

    pub art_dao_profit: Balance,

    pub app_owner_id: AccountId,

    pub art_dao_id: AccountId,

    pub total_votes: u64,
}

impl From<&TradeData> for TradeDataView {
    fn from(t: &TradeData) -> Self {
        Self {
            num_purchases: t.num_purchases,
            num_unique_cards_bought: t.num_unique_cards_bought,
            near_volume: t.near_volume.into(),
            app_owner_profit: t.app_owner_profit.into(),
            art_dao_profit: t.art_dao_profit.into(),
            app_owner_id: t.app_owner_id.clone(),
            art_dao_id: t.art_dao_id.clone(),
            total_votes: 0,
        }
    }
}

impl TradeData {
    pub fn new(app_owner_id: AccountId, art_dao_id: AccountId) -> Self {
        Self {
            cards: LookupMap::new(b"o".to_vec()),
            num_purchases: 0,
            num_unique_cards_bought: 0,
            near_volume: 0,
            app_owner_profit: 0,
            art_dao_profit: 0,
            app_owner_id,
            art_dao_id,
        }
    }
}

impl Contract {
    pub(crate) fn save_trade_data(&mut self, trade_data: &TradeData) {
        env::storage_write(TRADE_DATA_KEY, &trade_data.try_to_vec().unwrap());
    }

    pub(crate) fn load_trade_data(&self) -> TradeData {
        TradeData::try_from_slice(&env::storage_read(TRADE_DATA_KEY).unwrap()).unwrap()
    }
}

#[near_bindgen]
impl Contract {
    /// Buying a given card at the attached deposit price. This attached deposit price should be
    /// not lower than the current card price.
    /// The new card price will be 120% of the purchase price.
    /// 1% of the sale goes to the app.
    /// If the card was owned by someone, they will get 90% of the purchase price and Art DAO will
    /// get 10% of the purchase price.
    /// If the card was not by anyone, then 99% will go to the Art DAO.
    #[payable]
    pub fn buy_card(&mut self, card_id: CardId) -> CardInfo {
        let new_owner_id = env::predecessor_account_id();
        let card_rating = self.rating.get(&card_id).expect("The card is not active");
        let card_price = (card_rating as f64 / Self::multiplier()) as u128;
        let buy_price = env::attached_deposit();
        if buy_price < card_price {
            env::panic(
                format!(
                    "The card price {} exceeds attached deposit of {}",
                    card_price, buy_price
                )
                .as_bytes(),
            );
        }
        let mut art_dao_profit = buy_price / 100;
        let app_owner_profit = buy_price / 100;
        let owner_profit = buy_price - art_dao_profit - app_owner_profit;
        let mut trade_data = self.load_trade_data();

        let mut purchase_info = CardInfo {
            owner_id: new_owner_id,
            purchase_price: buy_price.into(),
            purchase_time: env::block_timestamp().into(),
            num_trades: 1,
            volume: buy_price.into(),
            art_dao_profit: art_dao_profit.into(),
        };

        if let Some(previous_info) = trade_data.cards.remove(&card_id) {
            let mut account = self.get_account_or_create(&previous_info.owner_id);
            account.cards.remove(&card_id);
            log!(
                "Transferring {} NEAR to the previous owner @{} for card #{}",
                owner_profit,
                previous_info.owner_id,
                card_id,
            );
            purchase_info.volume.0 += previous_info.volume.0;
            purchase_info.art_dao_profit.0 += previous_info.art_dao_profit.0;
            purchase_info.num_trades += previous_info.num_trades;
            account.num_sales += 1;
            account.sale_profit += owner_profit;
            self.save_account(&previous_info.owner_id, &account);
            Promise::new(previous_info.owner_id).transfer(owner_profit);
        } else {
            trade_data.num_unique_cards_bought += 1;
            // all profit goes to the art DAO.
            art_dao_profit += owner_profit;
            purchase_info.art_dao_profit.0 += owner_profit;
        }

        trade_data.cards.insert(&card_id, &purchase_info);
        trade_data.near_volume += buy_price;
        trade_data.art_dao_profit += art_dao_profit;
        trade_data.app_owner_profit += app_owner_profit;
        trade_data.num_purchases += 1;

        self.save_trade_data(&trade_data);

        log!(
            "Transferring {} NEAR to the Art DAO @{} for card #{}",
            art_dao_profit,
            trade_data.art_dao_id,
            card_id,
        );
        Promise::new(trade_data.art_dao_id).transfer(art_dao_profit);

        let new_rating = ((buy_price as f64 * Self::multiplier()) * 1.2) as u128;
        self.set_rating(card_id, card_rating, new_rating);

        let mut account = self.get_account_or_create(&purchase_info.owner_id);
        account.cards.insert(&card_id);
        account.num_purchases += 1;
        account.purchase_volume += buy_price;
        self.save_account(&purchase_info.owner_id, &account);

        self.insert_recent_buy(card_id);

        purchase_info
    }

    pub fn get_trade_data(&self) -> TradeDataView {
        let mut view: TradeDataView = (&self.load_trade_data()).into();
        view.total_votes = self.num_votes;
        view
    }

    pub fn get_card_info(&self, card_id: CardId) -> Option<CardInfo> {
        self.load_trade_data().cards.get(&card_id)
    }

    pub fn update_art_dao_id(&mut self, new_art_dao_id: ValidAccountId) {
        let mut trade_data = self.load_trade_data();
        assert_eq!(
            trade_data.app_owner_id,
            env::predecessor_account_id(),
            "Can only be updated by the owner"
        );
        trade_data.art_dao_id = new_art_dao_id.into();
        self.save_trade_data(&trade_data);
    }
}

impl Contract {
    pub(crate) fn insert_recent_buy(&mut self, card_id: CardId) {
        self.recent_buys.insert(&self.recent_buys_end, &card_id);
        if self.recent_buys_end >= RECENT_BUY_LIMIT {
            self.recent_buys
                .remove(&(self.recent_buys_end - RECENT_BUY_LIMIT));
        }
        self.recent_buys_end += 1;
    }
}

'''
'''--- frontend/package.json ---
{
  "name": "frontend",
  "version": "0.1.0",
  "homepage": "https://near.fm",
  "private": true,
  "dependencies": {
    "@testing-library/jest-dom": "^4.2.4",
    "@testing-library/react": "^9.3.2",
    "@testing-library/user-event": "^7.1.2",
    "big.js": "^6.1.1",
    "bn.js": "^5.1.1",
    "bootstrap": "^5.0.0-beta2",
    "collections": "^5.1.12",
    "error-polyfill": "^0.1.2",
    "local-storage": "^2.0.0",
    "near-api-js": "^0.41.0",
    "node-sass": "^4.0.0",
    "react": "^16.13.1",
    "react-dom": "^16.13.1",
    "react-infinite-scroller": "^1.2.4",
    "react-markdown": "^5.0.3",
    "react-router-dom": "^5.2.0",
    "react-scripts": "3.4.0",
    "react-tooltip": "^4.2.13",
    "react-uuid": "^1.0.2",
    "remark-gfm": "^1.0.0",
    "timeago-react": "^3.0.2"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject",
    "deploy": "yarn build && gh-pages -d build"
  },
  "eslintConfig": {
    "extends": "react-app"
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  },
  "devDependencies": {
    "gh-pages": "^2.2.0"
  }
}

'''
'''--- frontend/public/index.html ---
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.png" />

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Berry Berry Hot"
    />
    <meta name="twitter:card" content="summary_large_image" />
    <meta property="og:image" content="https://berry.cards/peppers.jpg"/>
    <meta property="og:url" content="https://berry.cards/" />
    <meta property="og:title" content="[BETA] Berry Cards" />
    <meta property="og:description" content="Berry Berry Hot" />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/favicon.png" />
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
    <title>Berry Cards - Hot</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
  </body>
</html>

'''
'''--- frontend/public/manifest.json ---
{
  "short_name": "Berry Cards",
  "name": "Berry Cards - Berry Hot",
  "icons": [
    {
      "src": "favicon.png",
      "sizes": "256x256",
      "type": "image/png"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#000000",
  "background_color": "#ffffff"
}

'''
'''--- frontend/public/robots.txt ---
# https://www.robotstxt.org/robotstxt.html
User-agent: *
Disallow:

'''
'''--- frontend/src/App.js ---
import React from 'react';
import "error-polyfill";
import 'bootstrap/dist/js/bootstrap.bundle';
import 'bootstrap/dist/css/bootstrap.min.css';
import "./App.scss";
import './gh-fork-ribbon.css';
import * as nearAPI from 'near-api-js'
import Logo from "./images/logo.png"
import DiscoverPage from "./pages/Discover";
import HomePage from "./pages/Home";
import {HashRouter as Router, Link, Route, Switch} from 'react-router-dom'
import {fromNear} from "./components/BuyButton";
import ls from "local-storage";
import CardPage from "./pages/Card";
import AccountPage from "./pages/Account";
import StatsPage from "./pages/Stats";
import RecentPage from "./pages/Recent";

const IsMainnet = window.location.hostname === "berry.cards";
const TestNearConfig = {
  networkId: 'testnet',
  nodeUrl: 'https://rpc.testnet.near.org',
  archivalNodeUrl: 'https://rpc.testnet.internal.near.org',
  contractName: 'dev-1621626423763-23601795253740',
  walletUrl: 'https://wallet.testnet.near.org',
};
const MainNearConfig = {
  networkId: 'mainnet',
  nodeUrl: 'https://rpc.mainnet.near.org',
  archivalNodeUrl: 'https://rpc.mainnet.internal.near.org',
  contractName: 'cards.berryclub.ek.near',
  walletUrl: 'https://wallet.near.org',
};

const NearConfig = IsMainnet ? MainNearConfig : TestNearConfig;

const FetchLimit = 50;

const mapAccount = (a) => {
  return {
    requests: a.requests,
    numCards: a.num_cards,
    purchaseVolume: fromNear(a.purchase_volume),
    numPurchases: a.num_purchases,
    saleProfit: fromNear(a.sale_profit),
    numSales: a.num_sales,
    numVotes: a.num_votes,
  };
}

class App extends React.Component {
  constructor(props) {
    super(props);

    this._near = {};

    this._near.lsKey = NearConfig.contractName + ':v01:';
    this._near.lsKeyRecentCards = this._near.lsKey + "recentCards";

    this.state = {
      connected: false,
      isNavCollapsed: true,
      account: null,
      requests: null,
      recentCards: ls.get(this._near.lsKeyRecentCards) || [],
    };

    this._initNear().then(() => {
      this.setState({
        signedIn: !!this._near.accountId,
        signedAccountId: this._near.accountId,
        connected: true,
      });
    });
  }

  async _initNear() {
    const keyStore = new nearAPI.keyStores.BrowserLocalStorageKeyStore();
    const near = await nearAPI.connect(Object.assign({deps: {keyStore}}, NearConfig));
    this._near.keyStore = keyStore;
    this._near.near = near;

    this._near.walletConnection = new nearAPI.WalletConnection(near, NearConfig.contractName);
    this._near.accountId = this._near.walletConnection.getAccountId();

    this._near.account = this._near.walletConnection.account();
    this._near.contract = new nearAPI.Contract(this._near.account, NearConfig.contractName, {
      viewMethods: ['get_account', 'get_num_accounts', 'get_accounts', 'get_num_cards', 'get_top', 'get_rating', 'get_trade_data', 'get_card_info', 'get_account_cards', 'get_recent_cards'],
      changeMethods: ['register_account', 'vote', 'buy_card'],
    });

    this._near.accounts = {};

    this._near.getAccount = (accountId) => {
      if (accountId in this._near.accounts) {
        return this._near.accounts[accountId];
      }
      return this._near.accounts[accountId] = Promise.resolve((async () => {
        const a = await this._near.contract.get_account({account_id: accountId});
        const account = a ? mapAccount(a) : null;
        if (account) {
          account.fetchCards = () => {
            if (account.cardFetching) {
              return account.cardFetching;
            }
            const promises = [];
            for (let i = 0; i < account.numCards; i += FetchLimit) {
              promises.push(this._near.contract.get_account_cards({
                account_id: accountId,
                from_index: i,
                limit: FetchLimit,
              }));
            }
            return account.cardFetching = Promise.resolve((async () => {
              return (await Promise.all(promises)).flat();
            })());
          };
        }
        return account;
      })());
    };

    if (this._near.accountId) {
      let account = await this._near.getAccount(this._near.accountId);
      if (account === null) {
        await this._near.contract.register_account();
        delete this._near.accounts[this._near.accountId];
        account = await this._near.getAccount(this._near.accountId);
      }
      this.setState({
        account,
        requests: account.requests,
      });
    }
  }

  async requestSignIn(e) {
    e && e.preventDefault();
    const appTitle = 'Berry Cards';
    await this._near.walletConnection.requestSignIn(
      NearConfig.contractName,
      appTitle
    )
    return false;
  }

  async logOut() {
    this._near.walletConnection.signOut();
    this._near.accountId = null;
    this.setState({
      signedIn: !!this._accountId,
      signedAccountId: this._accountId,
    })
  }

  popRequest(c) {
    const requests = this.state.requests.slice(1);
    this.setState({
      requests,
    }, c);
  }

  addRequest(r, c) {
    const requests = this.state.requests.slice(0);
    requests.push(r);
    this.setState({
      requests,
    }, c);
  }

  addRecentCard(cardId) {
    let recentCards = this.state.recentCards.slice(0);
    const index = recentCards.indexOf(cardId);
    if (index !== -1) {
      recentCards.splice(index, 1);
    }
    recentCards.unshift(cardId);
    recentCards = recentCards.slice(0, 5);
    ls.set(this._near.lsKeyRecentCards, recentCards);
    this.setState({
      recentCards
    })
  }

  async refreshAllowance() {
    alert("You're out of access key allowance. Need sign in again to refresh it");
    await this.logOut();
    await this.requestSignIn();
  }

  render() {
    const passProps = {
      _near: this._near,
      updateState: (s, c) => this.setState(s, c),
      popRequest: (c) => this.popRequest(c),
      addRequest: (r, c) => this.addRequest(r, c),
      addRecentCard: (cardId) => this.addRecentCard(cardId),
      refreshAllowance: () => this.refreshAllowance(),
      ...this.state
    };
    const header = !this.state.connected ? (
      <div>Connecting... <span className="spinner-grow spinner-grow-sm" role="status" aria-hidden="true"></span></div>
    ) : (this.state.signedIn ? (
      <div>
        <button
          className="btn btn-outline-secondary"
          onClick={() => this.logOut()}>Sign out ({this.state.signedAccountId})</button>
      </div>
    ) : (
      <div>
        <button
          className="btn btn-primary"
          onClick={(e) => this.requestSignIn(e)}>Sign in with NEAR Wallet</button>
      </div>
    ));

    return (
      <div className="App">
        <Router basename={process.env.PUBLIC_URL}>
          <nav className="navbar navbar-expand-lg navbar-light bg-light mb-3">
            <div className="container-fluid">
              <Link className="navbar-brand" to="/" title="NEAR.fm">
                <img src={Logo} alt="Berry Cards" className="d-inline-block align-middle" />
                Berry Cards
              </Link>
              <button className="navbar-toggler" type="button" data-bs-toggle="collapse"
                      data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent"
                      aria-expanded="false" aria-label="Toggle navigation">
                <span className="navbar-toggler-icon"></span>
              </button>
              <div className="collapse navbar-collapse" id="navbarSupportedContent">
                <ul className="navbar-nav me-auto mb-2 mb-lg-0">
                  <li className="nav-item">
                    <Link className="nav-link" aria-current="page" to="/">Home</Link>
                  </li>
                  <li className="nav-item">
                    <Link className="nav-link" aria-current="page" to="/recent">Recent</Link>
                  </li>
                  {this.state.signedIn && (
                    <li className="nav-item">
                      <Link className="nav-link" aria-current="page" to="/top">Top</Link>
                    </li>
                  )}
                  {this.state.signedIn && (
                    <li className="nav-item">
                      <Link className="nav-link" aria-current="page"
                            to={`/a/${this.state.signedAccountId}`}>Profile</Link>
                    </li>
                  )}
                  <li className="nav-item">
                    <Link className="nav-link" aria-current="page" to="/stats">Stats</Link>
                  </li>
                </ul>
                <form className="d-flex">
                  {header}
                </form>
              </div>
            </div>
          </nav>

          <a className="github-fork-ribbon right-bottom fixed" href="https://github.com/evgenykuzyakov/berry-hot" data-ribbon="Fork me on GitHub"
             title="Fork me on GitHub">Fork me on GitHub</a>

          <Switch>
            <Route exact path={"/"}>
              {this.state.signedIn ? (
                <HomePage {...passProps}/>
              ) : (
                <DiscoverPage {...passProps}/>
              )}
            </Route>
            <Route exact path={"/recent"}>
              <RecentPage {...passProps}/>
            </Route>
            <Route exact path={"/top"}>
              <DiscoverPage {...passProps}/>
            </Route>
            <Route exact path={"/stats"}>
              <StatsPage {...passProps}/>
            </Route>
            <Route exact path={"/a/:accountId"}>
              <AccountPage {...passProps} />
            </Route>
            <Route exact path={"/c/:cardId"}>
              <CardPage {...passProps} />
            </Route>
          </Switch>
        </Router>
      </div>
    )
  }
}

export default App;

'''
'''--- frontend/src/components/BuyButton.js ---
import React from 'react';
import {multiplier} from "./common";
import Big from "big.js";

const fromNear = (s) => parseFloat(s) / 1e24;

function BuyButton(props) {
  const price = fromNear(props.price / multiplier() * 1.0001);

  async function buyCard(e) {
    e.preventDefault();
    await props._near.contract.buy_card({card_id: props.cardId}, "200000000000000", Big(props.price / multiplier() * 1.0001).toFixed(0));
  }

  const appCommission = price / 100;
  let artDaoProfit = price / 100;
  let ownerPrice = price - appCommission - artDaoProfit;
  if (!props.ownerId) {
    artDaoProfit += ownerPrice;
    ownerPrice = 0;
  }

  const newPrice = price * 1.2;

  return (
    <div>
      <button
        className="btn btn-success"
        disabled={!props.signedIn}
        onClick={(e) => buyCard(e)}
      >
        Buy for {price.toFixed(2)} NEAR
      </button>
      <div className="text-muted text-start">
        Price breakdown:
        <ul>
          {props.ownerId && (
            <li>Owner @{props.ownerId} will get {ownerPrice.toFixed(2)} NEAR</li>
          )}
          <li>Art DAO will get {artDaoProfit.toFixed(2)} NEAR</li>
          <li>1% App commission is {appCommission.toFixed(2)} NEAR</li>
        </ul>
        <p>
          The new price will be {newPrice.toFixed(2)} NEAR
        </p>
      </div>
    </div>
  );
}

export { fromNear, BuyButton };

'''
'''--- frontend/src/components/Card.js ---
import React, {useCallback, useEffect, useState} from 'react';
import {BuyButton, fromNear} from "./BuyButton";
import {CardImage, preloadCard} from "./CardImage";
import TimeAgo from "timeago-react";
import {Link} from "react-router-dom";
import PriceButton from "./PriceButton";

const mapCardInfo = (c) => {
  return c ? {
    ownerId: c.owner_id,
    purchasePrice: fromNear(c.purchase_price),
    purchaseTime: new Date(parseFloat(c.purchase_time) / 1e6),
    volume: fromNear(c.volume),
    artDaoProfit: fromNear(c.art_dao_profit),
    numTrades: c.num_trades,
  } : {
    ownerId: null,
    purchasePrice: 0,
    purchaseTime: null,
    volume: 0,
    artDaoProfit: 0,
    numTrades: 0,
  };
}

function Card(props) {
  const [cardInfo, setCardInfo] = useState(null);
  const cardId = props.cardId;
  const refreshTime = props.refreshTime;
  const hidden = props.hidden;

  const fetchInfo = useCallback(async () => {
    const rating = await props._near.contract.get_rating({
      card_id: cardId,
    })
    const cardInfo = mapCardInfo(await props._near.contract.get_card_info({
      card_id: cardId,
    }));
    cardInfo.refreshTime = refreshTime;
    cardInfo.rating = rating;
    return cardInfo;
  }, [props._near, cardId, refreshTime])

  useEffect(() => {
    if (props.connected && !hidden) {
      preloadCard(cardId);
      fetchInfo().then(setCardInfo)
    }
  }, [props.connected, fetchInfo, cardId, hidden])

  return cardInfo ? (
    <div className="card m-2">
      <CardImage className="card-img-top" cardId={cardId} cardReady={() => false}/>
      <div className="card-body text-start">
        <h3>#{cardId}</h3>
        {cardInfo.ownerId ? (
          <div>
            <p>
              Owned by {cardInfo.ownerId === props.signedAccountId ? "you" : (
                <Link to={`/a/${cardInfo.ownerId}`}>@{cardInfo.ownerId}</Link>
              )}<br/>
              Purchased <TimeAgo datetime={cardInfo.purchaseTime} /> for {cardInfo.purchasePrice.toFixed(2)} NEAR<br/>
            </p>
            <p>
              Total card volume {cardInfo.volume.toFixed(2)} NEAR<br/>
              Art DAO got {cardInfo.artDaoProfit.toFixed(2)} NEAR<br/>
            </p>
          </div>
        ) : (
          <div>
            <p>
              Not owned by anyone.
            </p>
          </div>
        )}
      </div>
      <div className="card-footer text-center">
        {cardInfo.ownerId === props.signedAccountId ? (
          <PriceButton {...props} cardId={cardId} price={cardInfo.rating} />
        ) : (
          <BuyButton {...props} cardId={cardId} price={cardInfo.rating} ownerId={cardInfo.ownerId} />
        )}
      </div>
    </div>
  ) : (
    <div className="card m-2">
      <div className="d-flex justify-content-center">
        <div className="spinner-grow" role="status">
          <span className="visually-hidden">Loading...</span>
        </div>
      </div>
    </div>
  );
}

export default Card;

'''
'''--- frontend/src/components/CardImage.js ---
import React, {useEffect, useRef, useState} from 'react';
import BrokenCard from "../images/tomato.png"
import LoadingCard from "../images/avocado.gif"

const loadedCards = {};
const loadedImages = {};
const cardPreloading = {};

function preloadCard(cardId) {
  if (cardId in cardPreloading) {
    return cardPreloading[cardId];
  }
  return cardPreloading[cardId] = new Promise((resolve) => {
    loadedImages[cardId] = new Image();
    loadedImages[cardId].onload = () => {
      loadedCards[cardId] = true;
      resolve()
    }
    loadedImages[cardId].onerror = (e) => {
      loadedCards[cardId] = false;
      resolve()
    }
    loadedImages[cardId].src = `https://i.berry.cards/${cardId}`;
  });

}

function CardImage(props) {
  const [cardImage, setCardImage] = useState(null);
  const [loading, setLoading] = useState(true);
  const [badCard, setBadCard] = useState(false);
  const canvasEl = useRef(null);

  const cardReady = props.cardReady;
  const cardId = props.cardId;

  useEffect(() => {
    setLoading(true);
    setCardImage(null);
    cardReady(false);
    setBadCard(false);
    preloadCard(cardId).then(() => {
      setBadCard(!loadedCards[cardId]);
      setLoading(false);
      if (loadedCards[cardId]) {
        cardReady(true);
        setCardImage(loadedImages[cardId]);
      }
    });
  }, [cardId, cardReady, canvasEl])

  useEffect(() => {
    if (canvasEl.current && cardImage) {
      const ctx = canvasEl.current.getContext('2d');
      ctx.drawImage(cardImage, 0, 0);
    }
  }, [cardImage])

  return (
    <div>
      {loading ? (
        <img className={props.className} src={LoadingCard} alt={`The card #${cardId} is loading`}/>
      ) : badCard ? (
        <img className={props.className} src={BrokenCard} alt={`The card #${cardId} is broken`}/>
      ): ("")}
      <canvas
        className={`${props.className}${(!cardImage || loading || badCard) ? " d-none": ""}`}
        ref={canvasEl}
        width={400}
        height={400}
        alt={`Card #${cardId}`}
      />
    </div>
  )
}

export { preloadCard, CardImage };

'''
'''--- frontend/src/components/CardPreview.js ---
import "./CardPreview.scss"
import React, {useCallback, useEffect, useState} from 'react';
import {CardImage} from "./CardImage";
import {Link} from "react-router-dom";
import PriceButton from "./PriceButton";

function CardPreview(props) {
  const [rating, setRating] = useState(props.rating);
  const cardId = props.cardId;
  const propsRating = props.rating;

  const fetchRating = useCallback(async () => {
    return await props._near.contract.get_rating({
      card_id: cardId,
    })
  }, [props._near, cardId])

  useEffect(() => {
    if (props.connected) {
      if (!propsRating) {
        fetchRating().then(setRating)
      } else {
        setRating(propsRating)
      }
    }
  }, [props.connected, propsRating, fetchRating])

  return props.cardId ? (
    <div className="card card-preview m-2">
      <Link to={`/c/${cardId}`}>
        <CardImage className="card-img-top" cardId={cardId} cardReady={() => false}/>
      </Link>
      <div className="card-body">
        #{cardId}
      </div>
      <div className="card-footer text-center">
        <PriceButton {...props} cardId={cardId} price={rating} />
      </div>
    </div>
  ) : (
    <div className="card card-preview m-2">
     <div className="d-flex justify-content-center">
        <div className="spinner-grow" role="status">
          <span className="visually-hidden">Loading...</span>
        </div>
      </div>
    </div>
  );
}

export default CardPreview;

'''
'''--- frontend/src/components/PriceButton.js ---
import React from 'react';
import {fromNear} from "./BuyButton";
import {Link} from "react-router-dom";
import {multiplier} from "./common";

function PriceButton(props) {
  return (
    <div>
      <Link
        to={`/c/${props.cardId}`}
        className="btn btn-success" disabled={!props.signedIn}
      >
        {fromNear(props.price / multiplier()).toFixed(2)} NEAR
      </Link>
    </div>
  );
}

export default PriceButton;

'''
'''--- frontend/src/components/common.js ---
const InflationTimestamp = 1621623768597;
const HalflifeDuration = 2628000000;

export const multiplier = () => {
  const timestamp = new Date().getTime();
  const duration = timestamp - InflationTimestamp;
  return Math.pow(2, duration / HalflifeDuration);
}

'''
'''--- frontend/src/gh-fork-ribbon.css ---
/*!
 * "Fork me on GitHub" CSS ribbon v0.2.3 | MIT License
 * https://github.com/simonwhitaker/github-fork-ribbon-css
*/

.github-fork-ribbon {
  width: 12.1em;
  height: 12.1em;
  position: absolute;
  overflow: hidden;
  top: 0;
  right: 0;
  z-index: 9999;
  pointer-events: none;
  font-size: 13px;
  text-decoration: none;
  text-indent: -999999px;
}

.github-fork-ribbon.fixed {
  position: fixed;
}

.github-fork-ribbon:hover, .github-fork-ribbon:active {
  background-color: rgba(0, 0, 0, 0.0);
}

.github-fork-ribbon:before, .github-fork-ribbon:after {
  /* The right and left classes determine the side we attach our banner to */
  position: absolute;
  display: block;
  width: 15.38em;
  height: 1.54em;

  top: 3.23em;
  right: -3.23em;

  -webkit-box-sizing: content-box;
  -moz-box-sizing: content-box;
  box-sizing: content-box;

  -webkit-transform: rotate(45deg);
  -moz-transform: rotate(45deg);
  -ms-transform: rotate(45deg);
  -o-transform: rotate(45deg);
  transform: rotate(45deg);
}

.github-fork-ribbon:before {
  content: "";

  /* Add a bit of padding to give some substance outside the "stitching" */
  padding: .38em 0;

  /* Set the base colour */
  background-color: #a00;

  /* Set a gradient: transparent black at the top to almost-transparent black at the bottom */
  background-image: -webkit-gradient(linear, left top, left bottom, from(rgba(0, 0, 0, 0)), to(rgba(0, 0, 0, 0.15)));
  background-image: -webkit-linear-gradient(top, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
  background-image: -moz-linear-gradient(top, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
  background-image: -ms-linear-gradient(top, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
  background-image: -o-linear-gradient(top, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
  background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));

  /* Add a drop shadow */
  -webkit-box-shadow: 0 .15em .23em 0 rgba(0, 0, 0, 0.5);
  -moz-box-shadow: 0 .15em .23em 0 rgba(0, 0, 0, 0.5);
  box-shadow: 0 .15em .23em 0 rgba(0, 0, 0, 0.5);

  pointer-events: auto;
}

.github-fork-ribbon:after {
  /* Set the text from the data-ribbon attribute */
  content: attr(data-ribbon);

  /* Set the text properties */
  color: #fff;
  font: 700 1em "Helvetica Neue", Helvetica, Arial, sans-serif;
  line-height: 1.54em;
  text-decoration: none;
  text-shadow: 0 -.08em rgba(0, 0, 0, 0.5);
  text-align: center;
  text-indent: 0;

  /* Set the layout properties */
  padding: .15em 0;
  margin: .15em 0;

  /* Add "stitching" effect */
  border-width: .08em 0;
  border-style: dotted;
  border-color: #fff;
  border-color: rgba(255, 255, 255, 0.7);
}

.github-fork-ribbon.left-top, .github-fork-ribbon.left-bottom {
  right: auto;
  left: 0;
}

.github-fork-ribbon.left-bottom, .github-fork-ribbon.right-bottom {
  top: auto;
  bottom: 0;
}

.github-fork-ribbon.left-top:before, .github-fork-ribbon.left-top:after, .github-fork-ribbon.left-bottom:before, .github-fork-ribbon.left-bottom:after {
  right: auto;
  left: -3.23em;
}

.github-fork-ribbon.left-bottom:before, .github-fork-ribbon.left-bottom:after, .github-fork-ribbon.right-bottom:before, .github-fork-ribbon.right-bottom:after {
  top: auto;
  bottom: 3.23em;
}

.github-fork-ribbon.left-top:before, .github-fork-ribbon.left-top:after, .github-fork-ribbon.right-bottom:before, .github-fork-ribbon.right-bottom:after {
  -webkit-transform: rotate(-45deg);
  -moz-transform: rotate(-45deg);
  -ms-transform: rotate(-45deg);
  -o-transform: rotate(-45deg);
  transform: rotate(-45deg);
}

'''
'''--- frontend/src/index.css ---

'''
'''--- frontend/src/index.js ---
import React from 'react';
import ReactDOM from 'react-dom';
import './index.css';
import App from './App';

ReactDOM.render(<App />, document.getElementById('root'));

'''
'''--- frontend/src/pages/Account.js ---
import React, {useCallback, useEffect, useState} from 'react';
import {useParams} from "react-router";
import CardPreview from "../components/CardPreview";
import uuid from "react-uuid";

function AccountPage(props) {
  const { accountId } = useParams();
  const [account, setAccount] = useState(null);
  const [loading, setLoading] = useState(true);
  const [cardIds, setCardsIds] = useState([]);
  const [gkey] = useState(uuid());

  const fetchCards = useCallback(async () => {
    const account = await props._near.getAccount(accountId);
    if (!account) {
      return;
    }
    setAccount(account);
    return await account.fetchCards();
  }, [props._near, accountId])

  useEffect(() => {
    if (props.connected) {
      fetchCards().then((cardIds) => {
        cardIds.sort((a, b) => b[1] - a[1]);
        setCardsIds(cardIds);
        setLoading(false);
      })
    }
  }, [props.connected, fetchCards])

  const cards = cardIds.map(([cardId, rating]) => {
    const key = `${gkey}-${cardId}`;
    return (
      <CardPreview {...props} key={key} cardId={cardId} rating={rating} />
    );
  })

  return (
    <div className="container">
      <div className="row justify-content-md-center">
        {loading ? (
          <div className="col">
            <div className="d-flex justify-content-center">
              <div className="spinner-grow" role="status">
                <span className="visually-hidden">Loading...</span>
              </div>
            </div>
          </div>
        ) : (
          <div className="col ">
            <h3>{accountId === props.signedAccountId ? "Your cards" : `Cards owned by @${accountId}`}</h3>
            <div>
              {cards}
            </div>
          </div>
        )}
        {!account ? (
          <div className="col col-12 col-lg-8 col-xl-6">
            <div className="d-flex justify-content-center">
              <div className="spinner-grow" role="status">
                <span className="visually-hidden">Loading...</span>
              </div>
            </div>
          </div>
        ) : (
          <div className="col col-12 col-lg-4 col-xl-4">
            <h3>Stats</h3>
            <ul>
              <li>Num cards: {account.numCards}</li>
              <li>Purchase volume: {account.purchaseVolume.toFixed(2)} NEAR</li>
              <li>Num purchases: {account.numPurchases}</li>
              <li>Sale profit: {account.saleProfit.toFixed(2)} NEAR</li>
              <li>Num sales: {account.numSales}</li>
              <li>Num votes: {account.numVotes}</li>
            </ul>
          </div>
        )}
      </div>
    </div>
  );
}

export default AccountPage;

'''
'''--- frontend/src/pages/Card.js ---
import React from 'react';
import {useParams} from "react-router";
import Card from "../components/Card";

function CardPage(props) {
  const { cardId } = useParams();

  return (
    <div className="container">
      <div className="row">
        <div className="col col-12 col-lg-8 col-xl-6">
          <Card {...props} cardId={parseInt(cardId)} />
        </div>
      </div>
    </div>
  );
}

export default CardPage;

'''
'''--- frontend/src/pages/Discover.js ---
import "./Discover.scss";
import React, { useEffect, useState} from 'react';
import uuid from "react-uuid";
import CardPreview from "../components/CardPreview";
import InfiniteScroll from 'react-infinite-scroller';

const FetchLimit = 25;

function DiscoverPage(props) {
  const [feed, setFeed] = useState([]);
  const [hasMore, setHasMore] = useState(false);
  const [gkey] = useState(uuid())

  const fetchMore = async () => {
    const f = [...feed];
    const lastKey = f.length > 0 ? f[f.length - 1] : null
    const fetched = await props._near.contract.get_top({
      from_key: lastKey,
      limit: FetchLimit,
    });
    f.push(...fetched);
    if (fetched.length === 0) {
      setHasMore(false);
    }
    setFeed(f);
  };

  useEffect(() => {
    if (props.connected) {
      setHasMore(true);
    }
  }, [props.connected])

  const cards = feed.map(([rating, cardId]) => {
    const key = `${gkey}-${cardId}`;
    return (
      <CardPreview {...props} key={key} cardId={cardId} rating={rating} />
    );
  })

  const loader = (
    <div className="d-flex justify-content-center" key={`${gkey}-loader`}>
      <div className="spinner-grow" role="status">
        <span className="visually-hidden">Loading...</span>
      </div>
    </div>
  );

  return (
    <div>
      <div className="container">
        <div className="row justify-content-md-center">
          <div className="col">
            <InfiniteScroll
              pageStart={0}
              loadMore={fetchMore}
              hasMore={hasMore}
              loader={loader}
            >
              {cards}
            </InfiniteScroll>
          </div>
        </div>
      </div>
    </div>
  );
}

export default DiscoverPage;

'''
'''--- frontend/src/pages/Home.js ---
import "./Home.scss";
import React, {useState} from 'react';
import { CardImage, preloadCard } from "../components/CardImage";
import CardPreview from "../components/CardPreview";
import uuid from "react-uuid";

const SelectedLeft = "SelectedLeft";
const SelectedRight = "SelectedRight";
const Skipped = "Skipped";

const DefaultTGas = 100;
const ExtraTGas = 50;
const NumIter = 5;
let votingPromise = Promise.resolve();

function HomePage(props) {
  const [leftReady, setLeftReady] = useState(false);
  const [rightReady, setRightReady] = useState(false);
  const [gkey] = useState(uuid())

  const voteRequest = props.requests ? props.requests[0] : null;

  if (props.requests) {
    props.requests.slice(1).forEach((nextRequest) => {
      preloadCard(nextRequest.left);
      preloadCard(nextRequest.right);
    });
  }

  const vote = async (e, voteRequest, response) => {
    e.preventDefault();
    if (response === SelectedLeft && !leftReady) {
      return;
    }
    if (response === SelectedRight && !rightReady) {
      return;
    }
    props.popRequest();
    const nextPromise = async () => {
      let tgas = DefaultTGas;
      let newRequest = null
      for (let iter = 0; iter < NumIter; ++iter) {
        try {
          newRequest = await props._near.contract.vote({
            request: voteRequest,
            response,
          }, tgas.toString() + "000000000000");
        } catch (e) {
          const msg = e.toString();
          console.warn(msg);
          if (msg.indexOf("prepaid gas") !== -1) {
            tgas += ExtraTGas;
            continue
          }
          if (msg.indexOf("does not have enough balance") !== -1) {
            await props.refreshAllowance();
            return;
          }
        }
        break;
      }
      if (newRequest) {
        if (response === SelectedLeft || response === SelectedRight) {
          const cardId = response === SelectedLeft ? voteRequest.left : voteRequest.right;
          props.addRecentCard(cardId);
        }
        props.addRequest(newRequest);
      }
    };

    votingPromise = votingPromise.then(nextPromise);
    // setVotingPromise(nextPromise);
  }

  const cards = props.recentCards.map((cardId) => {
    const key = `${gkey}-${cardId}`;
    return (
      <CardPreview {...props} key={key} cardId={cardId} />
    );
  })

  return (
    <div>
      <div className="container">
        {voteRequest ? (
          <div>
            <h3>Vote</h3>
            <div className="row justify-content-md-center mb-3">
              <div className="col col-sm-6">
                <div
                  className={`card-picker${!leftReady ? " disabled": ""}`}
                  onClick={(e) => vote(e, voteRequest, SelectedLeft)}
                >
                  <CardImage className="img-fluid" cardId={voteRequest.left} cardReady={setLeftReady}/>
                </div>
              </div>
              <div className="col col-sm-6">
                <div
                  className={`card-picker${!rightReady ? " disabled": ""}`}
                  onClick={(e) => vote(e, voteRequest, SelectedRight)}
                >
                  <CardImage className="img-fluid" cardId={voteRequest.right} cardReady={setRightReady}/>
                </div>
              </div>
            </div>
            <div className="row justify-content-md-center mb-3">
              <button
                className="btn btn-lg btn-danger"
                onClick={(e) => vote(e, voteRequest, Skipped)}
              >Skip both cards</button>
            </div>
          </div>
        ) : (
          <div className="d-flex justify-content-center">
            <div className="spinner-grow" role="status">
              <span className="visually-hidden">Loading...</span>
            </div>
          </div>
        )}
        <div className="row justify-content-md-center mb-3">
          {(cards.length > 0) && (
            <div>
              <h3>Recent votes</h3>
              {cards}
            </div>
          )}
        </div>
      </div>
    </div>
  );
}

export default HomePage;

'''
'''--- frontend/src/pages/Recent.js ---
import "./Discover.scss";
import React, { useEffect, useState} from 'react';
import uuid from "react-uuid";
import CardPreview from "../components/CardPreview";
import InfiniteScroll from 'react-infinite-scroller';

const FetchLimit = 100;

function RecentPage(props) {
  const [feed, setFeed] = useState([]);
  const [hasMore, setHasMore] = useState(false);
  const [gkey] = useState(uuid())

  const fetchMore = async () => {
    const f = [...feed];
    const offset = f.length;
    const fetched = await props._near.contract.get_recent_cards({
      offset,
      limit: FetchLimit,
    });
    f.push(...fetched);
    if (fetched.length === 0) {
      setHasMore(false);
    }
    setFeed(f);
  };

  useEffect(() => {
    if (props.connected) {
      setHasMore(true);
    }
  }, [props.connected])

  const seen = {};

  const cards = feed.filter(([rating, cardId]) => {
    if (cardId in seen) {
      return false;
    }
    seen[cardId] = true;
    return true;
  }).map(([rating, cardId]) => {
    const key = `${gkey}-${cardId}`;
    return (
      <CardPreview {...props} key={key} cardId={cardId} rating={rating} />
    );
  })

  const loader = (
    <div className="d-flex justify-content-center" key={`${gkey}-loader`}>
      <div className="spinner-grow" role="status">
        <span className="visually-hidden">Loading...</span>
      </div>
    </div>
  );

  return (
    <div>
      <div className="container">
        <div className="row justify-content-md-center">
          <div className="col">
            <InfiniteScroll
              pageStart={0}
              loadMore={fetchMore}
              hasMore={hasMore}
              loader={loader}
            >
              {cards}
            </InfiniteScroll>
          </div>
        </div>
      </div>
    </div>
  );
}

export default RecentPage;

'''
'''--- frontend/src/pages/Stats.js ---
import React, {useCallback, useEffect, useState} from 'react';
import {fromNear} from "../components/BuyButton";

function StatsPage(props) {
  const [stats, setStats] = useState(null);
  const [loading, setLoading] = useState(true);

  const fetchStats = useCallback(async () => {
    const [t, numAccounts] = await Promise.all([
      props._near.contract.get_trade_data(),
      props._near.contract.get_num_accounts(),
    ]);
    return {
      numAccounts,
      numPurchases: t.num_purchases,
      numUniqueCardsBought: t.num_unique_cards_bought,
      nearVolume: fromNear(t.near_volume),
      appCommission: fromNear(t.app_owner_profit),
      artDaoProfit: fromNear(t.art_dao_profit),
      appOwnerId: t.app_owner_id,
      artDaoId: t.art_dao_id,
      totalVotes: t.total_votes,
    };
  }, [props._near])

  useEffect(() => {
    if (props.connected) {
      fetchStats().then((stats) => {
        setStats(stats);
        setLoading(false);
      })
    }
  }, [props.connected, fetchStats])

  return (
    <div className="container">
      <div className="row">
        {loading ? (
          <div className="col">
            <div className="d-flex justify-content-center">
              <div className="spinner-grow" role="status">
                <span className="visually-hidden">Loading...</span>
              </div>
            </div>
          </div>
        ) : (
          <div className="col col-12 col-lg-6 col-xl-6">
            <h3>Global Stats</h3>
            <ul>
              <li>Num accounts: {stats.numAccounts}</li>
              <li>Total votes: {stats.totalVotes}</li>
              <li>Total purchases: {stats.numPurchases}</li>
              <li>Total unique purchases: {stats.numUniqueCardsBought}</li>
              <li>Total volume: {stats.nearVolume.toFixed(2)} NEAR</li>
              <li>Total Art DAO profit: {stats.artDaoProfit.toFixed(2)} NEAR</li>
              <li>Art DAO account ID: <a href={`https://explorer.near.org/accounts/${stats.artDaoId}`}>@{stats.artDaoId}</a></li>
              <li>Total App commission: {stats.appCommission.toFixed(2)} NEAR</li>
            </ul>
          </div>
        )}
      </div>
    </div>
  );
}

export default StatsPage;

'''