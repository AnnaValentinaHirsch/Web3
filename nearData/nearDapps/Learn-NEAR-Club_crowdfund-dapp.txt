*GitHub Repository "Learn-NEAR-Club/crowdfund-dapp"*

'''--- Cargo.toml ---
[package]
name = "near-starter-contract"
version = "0.1.0"
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"

[profile.release]
codegen-units=1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true
'''
'''--- README.md ---
# Rust Smart Contract Template

## Getting started

To get started with this template:

1. Click the "Use this template" button to create a new repo based on this template
2. Update line 2 of `Cargo.toml` with your project name
3. Update line 4 of `Cargo.toml` with your project author names
4. Set up the [prerequisites](https://github.com/near/near-sdk-rs#pre-requisites)
5. Begin writing your smart contract in `src/lib.rs`
6. Test the contract 

    `cargo test -- --nocapture`

8. Build the contract

    `RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release`

**Get more info at:**

* [Rust Smart Contract Quick Start](https://docs.near.org/docs/develop/contracts/rust/intro)
* [Rust SDK Book](https://www.near-sdk.io/)

'''
'''--- src/core.rs ---
use crate::*;

#[near_bindgen]
impl Contract {

    #[payable]
    pub fn create_project(&mut self, project_id: ProjectId, mut metadata: ProjectMetadata, project_owner_id: AccountId) {
        let before_storage_usage = env::storage_usage();

        let project = Project {
            owner_id: project_owner_id
        };

        assert!(
            self.projects_by_id.insert(&project_id, &project).is_none(),
            "Project already exsits"
        );

        metadata.started_at = Some(env::block_timestamp());

        self.project_metadata_by_id.insert(&project_id, &metadata);

        // set project per owner
        self.internal_add_project_to_owner(&project_id, &project.owner_id);

        let project_create_log: EventLog = EventLog {
            version: "1.0.0".to_string(),
            event: EventLogVariant::ProjectCreate(vec![ ProjectCreateLog {
                owner_id: project.owner_id.to_string(),
                project_ids: vec![project_id.to_string()],
                memo: None
            } ])
        };
        env::log(&project_create_log.to_string().as_bytes());

        let after_storage_usage = env::storage_usage();
        // Refund near
        refund_deposit(after_storage_usage - before_storage_usage);
    }

    #[payable]
    pub fn donate_project(&mut self, project_id: ProjectId) {
        let amount = env::attached_deposit();
        // let amount = deposit.clone() as u128;
        // let before_storage_usage = env::storage_usage();

        let supporter_id = env::predecessor_account_id();

        let project = self.projects_by_id.get(&project_id);
        // get funded captial of project
        if let Some(project) = project {
            let mut metadata = self.project_metadata_by_id.get(&project_id).unwrap();

            let project_owner_id = project.owner_id;
            let mut funded = u128::from(metadata.funded.unwrap_or(U128(0)));
            let target = u128::from(metadata.target);
            let minimum_pledge = u128::from(metadata.minimum_pledge);
            
            // make sure funded capital < target
            assert!(funded < target, "Project's target already reached!");

            // make sure amount must be >= minimum_pledge
            assert!(amount >= minimum_pledge, "Donation must greater than or equal to {}", minimum_pledge);

            funded = funded + amount;
            metadata.funded = Some(U128(funded));
            self.project_metadata_by_id.insert(&project_id, &metadata);

            if funded >= target {
                // transfer 95% of donation (funded) from contract account to project owner account
                let transfer_capital = 95 * funded / 100; 
                let real_transfer = transfer_capital as u128;
                Promise::new(project_owner_id).transfer(Balance::from(real_transfer));
            }

            // set supporter per project
            self.internal_add_supporter_to_project(&supporter_id, &project_id);

        } else {
            panic!("Project doesn't exist!");
        }

        // let after_storage_usage = env::storage_usage();
        // Refund near
        // refund_deposit(after_storage_usage - before_storage_usage);
    }

    pub fn vote_project(&mut self, project_id: ProjectId) {
        let voter_id = env::predecessor_account_id();
        let project = self.projects_by_id.get(&project_id);

        if let Some(project) = project {
            self.internal_add_voter_to_project(&voter_id, &project_id);
        } else {
            panic!("Project doesn't exist!");
        }
    }
}
'''
'''--- src/enumeration.rs ---
use crate::*;

#[near_bindgen]
impl Contract {

    // lấy tổng số dự án có trong contract
    pub fn get_number_of_projects(&self) -> U128 {
        U128(self.project_metadata_by_id.len() as u128)
    }

    // lấy ra thông tin một project
    pub fn get_project_info(&self, project_id: ProjectId) -> Option<JsonProject> {
        let project = self.projects_by_id.get(&project_id);

        if let Some(project) = project {
            let metadata = self.project_metadata_by_id.get(&project_id).unwrap();

            Some(JsonProject {
                owner_id: project.owner_id,
                project_id,
                metadata
            })
        } else {
            None
        }
    }

    // lấy danh sách supporters của một project
    pub fn get_project_supporters(&self, project_id: ProjectId) -> Vec<AccountId> {
        let supporters = self.supporters_per_project.get(&project_id);
        if let Some(supporters) = supporters {
            supporters.to_vec()
        } else {
            return vec![];
        }
        
    }

    // lấy danh sách voters của một project
    pub fn get_project_voters(&self, project_id: ProjectId) -> Vec<AccountId> {
        let voters = self.voters_per_project.get(&project_id);
        if let Some(voters) = voters {
            voters.to_vec()
        } else {
            return vec![];
        }
        
    }

    pub fn get_project_funded(&self, project_id: ProjectId) -> Option<u128> {
        let project = self.projects_by_id.get(&project_id);

        if let Some(project) = project {
            let metadata = self.project_metadata_by_id.get(&project_id).unwrap();
            let funded = u128::from(metadata.funded.unwrap());
            Some(funded)
        } else {
            None
        }
    }

    pub fn get_project_target(&self, project_id: ProjectId) -> Option<u128> {
        let project = self.projects_by_id.get(&project_id);

        if let Some(project) = project {
            let metadata = self.project_metadata_by_id.get(&project_id).unwrap();

            Some(u128::from(metadata.target))
        } else {
            None
        }
    }

    // lấy ra danh sách các dự án có paging
    pub fn get_projects_info(&self, from_index: Option<U128>, limit: Option<u64>) -> Vec<JsonProject> {
        let project_keys = self.project_metadata_by_id.keys_as_vector();

        let start = u128::from(from_index.unwrap_or(U128(0)));

        project_keys.iter()
        .skip(start as usize)
        .take(limit.unwrap_or(0) as usize)
        .map(|project_id| self.get_project_info(project_id.clone()).unwrap() )
        .collect()
    }

    // Lấy danh sách project của một chủ dự án có account_id tương ứng (có paging)
    pub fn get_projects_by_owner(&self, account_id: AccountId, from_index: Option<U128>, limit: Option<u64>) -> Vec<JsonProject> {
        let projects = self.projects_per_owner.get(&account_id);

        let keys = if let Some(projects) = projects {
            projects
        } else {
            return vec![];
        };

        let start = u128::from(from_index.unwrap_or(U128(0)));

        keys.as_vector()
        .iter()
        .skip(start as usize)
        .take(limit.unwrap_or(0) as usize)
        .map(|project_id| self.get_project_info(project_id.clone()).unwrap() )
        .collect()
    }

    pub fn get_project_started_time(&self, project_id: ProjectId) -> Option<u64> {
        let project = self.projects_by_id.get(&project_id);

        if let Some(project) = project {
            let metadata = self.project_metadata_by_id.get(&project_id).unwrap();

            metadata.started_at
        } else {
            None
        }
    }

    // check if specific project was over deadline
    pub fn is_project_ended(&self, project_id: ProjectId) -> Option<bool> {
        let project = self.projects_by_id.get(&project_id);

        if let Some(project) = project {
            let metadata = self.project_metadata_by_id.get(&project_id).unwrap();
            let ended_time = metadata.ended_at.unwrap();
            let is_ended = ended_time < env::block_timestamp();
            Some(is_ended)
        } else {
            None
        }
    }
}
'''
'''--- src/events.rs ---
use std::fmt;

use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::serde_json;

/// Enum that represents the data type of the EventLog.
#[derive(Serialize, Deserialize, Debug)]
#[serde(tag = "event", content = "data")]
#[serde(rename_all = "snake_case")]
#[serde(crate = "near_sdk::serde")]
#[non_exhaustive]
pub enum EventLogVariant {
    ProjectCreate(Vec<ProjectCreateLog>)
}

/// Interface to capture data about an event
///
/// Arguments:
/// * `version`: e.g. 1.0.0
/// * `event`: associate event data
#[derive(Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct EventLog {
    pub version: String,

    // `flatten` to not have "event": {<EventLogVariant>} in the JSON, just have the contents of {<EventLogVariant>}.
    #[serde(flatten)]
    pub event: EventLogVariant,
}

impl fmt::Display for EventLog {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_fmt(format_args!(
            "EVENT_JSON:{}",
            &serde_json::to_string(self).map_err(|_| fmt::Error)?
        ))
    }
}

/// An event log to capture token minting
///
/// Arguments
/// * `owner_id`: "account.near"
/// * `project_ids`: ["1", "abc"]
/// * `memo`: optional message
#[derive(Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct ProjectCreateLog {
    pub owner_id: String,
    pub project_ids: Vec<String>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub memo: Option<String>,
}
'''
'''--- src/internal.rs ---
use crate::*;

#[near_bindgen]
impl Contract {
    pub(crate) fn internal_add_project_to_owner(&mut self, project_id: &ProjectId, account_id: &AccountId) {

        let mut projects_set = self.projects_per_owner.get(account_id).unwrap_or_else(|| {
            UnorderedSet::new(hash_account_id(account_id).to_vec())
        });

        projects_set.insert(project_id);

        self.projects_per_owner.insert(account_id, &projects_set);
    }

    pub(crate) fn internal_add_supporter_to_project(&mut self, supporter_id: &AccountId, project_id: &ProjectId) {
        let mut supporters_set = self.supporters_per_project.get(project_id).unwrap_or_else(|| {
            UnorderedSet::new(hash_project_id(project_id).to_vec())
        });

        supporters_set.insert(supporter_id);

        self.supporters_per_project.insert(project_id, &supporters_set);
    }

    pub(crate) fn internal_add_voter_to_project(&mut self, voter_id: &AccountId, project_id: &ProjectId) {
        let mut voters_set = self.voters_per_project.get(project_id).unwrap_or_else(|| {
            UnorderedSet::new(hash_project_id(project_id).to_vec())
        });

        voters_set.insert(voter_id);

        self.voters_per_project.insert(project_id, &voters_set);
    }
}
'''
'''--- src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::json_types::{Base64VecU8, U128};
use near_sdk::{env, near_bindgen, setup_alloc, Balance, CryptoHash, Promise, PanicOnDefault, Timestamp};
use near_sdk::collections::{UnorderedSet, UnorderedMap, LookupMap};
use near_sdk::AccountId;

setup_alloc!();

use crate::utils::*;
pub use crate::metadata::*;
pub use crate::internal::*;
pub use crate::enumeration::*;
pub use crate::core::*;
pub use crate::events::*;

mod utils;
mod metadata;
mod internal;
mod enumeration;
mod core;
mod events;

pub type ProjectId = String;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    pub owner_id: AccountId,
    // mapping user ID với danh sách dự án của người này
    pub projects_per_owner: LookupMap<AccountId, UnorderedSet<ProjectId>>,
    // mapping project ID với project struct tương ứng (có thể lưu metadata của project struct off-chain)
    pub projects_by_id: LookupMap<ProjectId, Project>,
    // mapping project ID với project metadata
    pub project_metadata_by_id: UnorderedMap<ProjectId, ProjectMetadata>,
    // mapping project ID với danh sách supporters
    pub supporters_per_project: LookupMap<ProjectId, UnorderedSet<AccountId>>,
    // mapping project ID với danh sách voters
    pub voters_per_project: LookupMap<ProjectId, UnorderedSet<AccountId>>
}

#[near_bindgen]
impl Contract {
    #[init]

    pub fn new(owner_id: AccountId) -> Self {
        Self {
            owner_id,
            projects_per_owner: LookupMap::new(b"a".to_vec()),
            projects_by_id: LookupMap::new(b"b".to_vec()),
            project_metadata_by_id: UnorderedMap::new(b"c".to_vec()),
            supporters_per_project: LookupMap::new(b"d".to_vec()),
            voters_per_project: LookupMap::new(b"e".to_vec())
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    use near_sdk::test_utils::{VMContextBuilder, accounts};
    use near_sdk::{testing_env};
    use near_sdk::MockedBlockchain;

    const CREATE_PROJECT_STORAGE_COST: u128 = 60000000000000000000000;
    const DONATE_PROJECT_AMOUNT: u128 = 3000_000_000_000_000_000_000_000;
    const TARGET: u128 = 10_000_000_000_000_000_000_000_000;
    const MINIMUM_PLEDGE: u128 = 1_000_000_000_000_000_000_000_000;
    // const DONATE_PROJECT_DEPOSIT: u128 = 10000000000000000000000000;

    fn get_context(is_view: bool) -> VMContextBuilder {
        let mut builder = VMContextBuilder::new();
        builder.
        current_account_id(accounts(0))
        .signer_account_id(accounts(0))
        .predecessor_account_id(accounts(0))
        .is_view(is_view);

        builder
    }

    fn get_sample_metadata() -> ProjectMetadata {
        ProjectMetadata { 
            title: String::from("PROJECT_TEST"), 
            description: String::from("PROJECT_DESCRIPTION"), 
            target: TARGET,
            minimum_pledge: MINIMUM_PLEDGE,
            started_at: env::block_timestamp(),
            ended_at: env::block_timestamp() + 2000_000_000 as u64,
            funded: Some(0 as u128),
            media: None, 
            media_hash: None, 
            extra: None, 
            reference: None, 
            reference_hash: None
         }
    }

    #[test]
    fn test_create_project() {
        let mut context = get_context(false);
        testing_env!(context.build());
        
        // Init contract
        let mut contract = Contract::new(accounts(0).to_string());

        testing_env!(
            context.storage_usage(env::storage_usage())
            .attached_deposit(CREATE_PROJECT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build()
        );

        let project_id = "VBI_FUND".to_string();
        contract.create_project(project_id.clone(), get_sample_metadata(), accounts(0).to_string());

        let project = contract.get_project_info(project_id.clone()).unwrap();

        assert_eq!(accounts(0).to_string(), project.owner_id);
        assert_eq!(project_id.clone(), project.project_id);
        assert_eq!(project.metadata, get_sample_metadata());
        assert_eq!(contract.get_number_of_projects(), U128(1));
    }

    #[test]
    fn test_get_target() {
        let mut context = get_context(false);
        testing_env!(context.build());
        
        // Init contract
        let mut contract = Contract::new(accounts(0).to_string());

        testing_env!(
            context.storage_usage(env::storage_usage())
            .attached_deposit(CREATE_PROJECT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build()
        );

        let project_id = "VBI_FUND".to_string();
        contract.create_project(project_id.clone(), get_sample_metadata(), accounts(0).to_string());

        assert_eq!(contract.get_project_target(project_id.clone()), Some(10));
    }

    #[test]
    fn test_get_funded() {
        let mut context = get_context(false);
        testing_env!(context.build());
        
        // Init contract
        let mut contract = Contract::new(accounts(0).to_string());

        testing_env!(
            context.storage_usage(env::storage_usage())
            .attached_deposit(CREATE_PROJECT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build()
        );

        let project_id = "VBI_FUND".to_string();
        contract.create_project(project_id.clone(), get_sample_metadata(), accounts(0).to_string());

        assert_eq!(contract.get_project_funded(project_id.clone()), Some(0));
    }

    #[test]
    fn test_donate() {
        let mut context = get_context(false);
        testing_env!(context.build());
        
        // Init contract
        let mut contract = Contract::new(accounts(0).to_string());

        testing_env!(
            context.storage_usage(env::storage_usage())
            .attached_deposit(CREATE_PROJECT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build()
        );

        let project_id = "VBI_FUND".to_string();
        contract.create_project(project_id.clone(), get_sample_metadata(), accounts(0).to_string());

        contract.donate_project(project_id.clone());
        assert_eq!(contract.get_project_voters(project_id.clone()).len(), 1);
    }

    #[test]
    fn test_vote() {
        let mut context = get_context(false);
        testing_env!(context.build());
        
        // Init contract
        let mut contract = Contract::new(accounts(0).to_string());

        testing_env!(
            context.storage_usage(env::storage_usage())
            .attached_deposit(CREATE_PROJECT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build()
        );

        let project_id = "VBI_FUND".to_string();
        contract.create_project(project_id.clone(), get_sample_metadata(), accounts(0).to_string());

        contract.vote_project(project_id.clone());
        assert_eq!(contract.get_project_voters(project_id.clone()).len(), 1);
    }

}

'''
'''--- src/metadata.rs ---
use crate::*;
use std::fmt;

#[derive(BorshDeserialize, BorshSerialize)]
pub struct Project {
    pub owner_id: AccountId
}

#[derive(Serialize, Deserialize, BorshDeserialize, BorshSerialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct JsonProject {
    pub owner_id: AccountId,
    pub project_id: ProjectId,
    pub metadata: ProjectMetadata,
}

impl fmt::Display for JsonProject {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "owner_id: {}\nproject_id: {}\n, metadata: {}\n", self.owner_id, self.project_id, self.metadata)
    }
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, PartialEq, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct ProjectMetadata {
    pub title: String, // tên dự án
    pub description: String, // miêu tả dự án
    pub target: U128, // số tiền muốn gọi vốn
    pub minimum_pledge: U128, // số tiền tối thiểu một người có thể góp fund
    pub started_at: Option<Timestamp>, // project created time
    pub ended_at: Option<Timestamp>, // project deadline
    pub funded: Option<U128>, // số tiền đã gọi vốn
    pub media: Option<String>, // URL to associated media, preferably to decentralized, content-addressed storage
    pub media_hash: Option<Base64VecU8>, // Base64-encoded sha256 hash of content referenced by the `media` field. Required if `media` is included.
    pub extra: Option<String>, // anything extra the Project object wants to store on-chain. Can be stringified JSON.
    pub reference: Option<String>, // URL to an off-chain JSON file with more info.
    pub reference_hash: Option<Base64VecU8>, // Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included.
}

impl fmt::Display for ProjectMetadata {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "title: {}\ndescription: {}\ntarget: {}\nminimum_pledge: {}\nfunded: {:#?}\nmedia: {:#?}\n",
            self.title, self.description, u128::from(self.target), u128::from(self.minimum_pledge), self.funded, self.media)
    }
}
'''
'''--- src/utils.rs ---
use crate::*;

pub(crate) fn assert_one_yocto() {
    assert_eq!(env::attached_deposit(), 1,
    "Require attached deposit of exactly 1 yoctoNear")
}

pub(crate) fn assert_at_least_one_yocto() {
    assert!(env::attached_deposit() >= 1,
    "Require attached deposit of at least 1 yoctoNear")
}

pub(crate) fn hash_account_id(account_id: &AccountId) -> CryptoHash {
    //get the default hash
    let mut hash = CryptoHash::default();
    //we hash the account ID and return it
    hash.copy_from_slice(&env::sha256(account_id.as_bytes()));
    hash
}

pub(crate) fn hash_project_id(project_id: &ProjectId) -> CryptoHash {
    //get the default hash
    let mut hash = CryptoHash::default();
    //we hash the project ID and return it
    hash.copy_from_slice(&env::sha256(project_id.as_bytes()));
    hash
}

pub(crate) fn refund_deposit(storage_used: u64) {
    // Tính lượng tiền cần nạp để cover storage
    let required_cost = env::storage_byte_cost() * Balance::from(storage_used);
    let attached_deposit = env::attached_deposit();

    assert!(
        required_cost <= attached_deposit,
        "Must attach {} yoctoNear to cover storage", required_cost
    );

    let refund = attached_deposit - required_cost;

    if refund > 1 {
        Promise::new(env::predecessor_account_id()).transfer(refund);
    }
}
'''