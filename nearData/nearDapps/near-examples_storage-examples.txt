*GitHub Repository "near-examples/storage-examples"*

'''--- README.md ---
# Docs Snippets

This repository holds all the code snippets that are displayed in [near-docs.io](near-docs.io).

'''
'''--- storage-js/README.md ---
# Cross-Contract JavaScript

An example on how to write JS cross-contract code

'''
'''--- storage-js/babel.config.json ---
{
    "plugins": ["near-sdk-js/lib/build-tools/near-bindgen-exporter", ["@babel/plugin-proposal-decorators", { "version": "legacy" }]],
    "presets": ["@babel/preset-typescript"]
}

'''
'''--- storage-js/integration/test-storage.ava.js ---
import { Worker } from "near-workspaces";
import test from "ava";

test.beforeEach(async (t) => {
  // Init the worker and start a Sandbox server
  const worker = await Worker.init();

  // Prepare sandbox for tests, create accounts, deploy contracts, etx.
  const root = worker.rootAccount;
  const contract = await root.createSubAccount('storage')
  await contract.deploy("./build/storage.wasm");

  // Initialize storage
  await contract.call(contract, "init", { "demo_string": "hi" });

  // Save state for test runs, it is unique for each test
  t.context.worker = worker;
  t.context.accounts = { contract };
});

test.afterEach(async (t) => {
  await t.context.worker.tearDown().catch((error) => {
    console.log("Failed tear down the worker:", error);
  });
});

test("vector_ops works", async (t) => {
  const { contract } = t.context.accounts;
  await contract.call(contract, "vector_ops", { value: 1 }, { gas: 200000000000000 });
  t.pass()
});

test("map_ops works", async (t) => {
  const { contract } = t.context.accounts;
  await contract.call(contract, "map_ops", { key: "key", value: 1 }, { gas: 200000000000000 });
  t.pass()
});

test("set_ops works", async (t) => {
  const { contract } = t.context.accounts;
  await contract.call(contract, "set_ops", { value: 1 }, { gas: 200000000000000 });
  t.pass()
});
'''
'''--- storage-js/package.json ---
{
  "name": "standalone-examples",
  "version": "1.0.0",
  "description": "Cross-contract example with near-sdk-js",
  "main": "index.js",
  "type": "module",
  "scripts": {
    "build": "near-sdk-js build src/index.ts build/storage.wasm",
    "rebuild": "rm -rf node_modules && rm -rf build && npm i && npm run build",
    "test": "ava --verbose --timeout=10m"
  },
  "author": "Near Inc <hello@nearprotocol.com>",
  "license": "MIT",
  "dependencies": {
    "lodash-es": "^4.17.21",
    "near-sdk-js": "0.6.0"
  },
  "devDependencies": {
    "typescript": "^4.8.4",
    "ts-morph": "^16.0.0",
    "ava": "^4.3.1",
    "near-workspaces": "^3.1.0"
  }
}
'''
'''--- storage-js/src/index.ts ---
import { NearBindgen, call, near, LookupSet, UnorderedMap, Vector, initialize } from "near-sdk-js";

// Constants
const ONE_NEAR = BigInt("1000000000000000000000000");

@NearBindgen({})
class CollectionsContract {
  avector: Vector<number> = new Vector<number>('unique-id-vector1');
  amap: UnorderedMap<number> = new UnorderedMap<number>('unique-id-map1');
  aset: LookupSet<number> = new LookupSet<number>('unique-id-set1');
  demo_string: String = "";

  @initialize({})
  init({demo_string}: {demo_string: string}) {
    this.demo_string = demo_string;
  }

  @call({})
  vector_ops({value}:{value:number}) {
    this.avector.push(value);
    assert(this.avector.length == 1, "Incorrect length")
    const _value = this.avector.pop()
    assert(_value == value, "Error popping value")
  }

  @call({})
  map_ops({key, value}:{key:string, value:number}) {
    this.amap.set(key, value);
    assert(this.amap.get(key) == value, "Error saving value")
  
    this.amap.remove(key)
    assert(this.amap.get(key) === null, "Error removing value")
  }

  @call({})
  set_ops({value}:{value:number}) {
    this.aset.set(value);
    assert(this.aset.contains(value), "Error saving value")
  
    this.aset.remove(value)
    assert(!this.aset.contains(value), "Error removing value")
  }
}

function assert(condition, message) { if(!condition) throw Error(message); }
'''
'''--- storage-rs/README.md ---
# Donation in RUST

An example contract writen in RUST

'''
'''--- storage-rs/contract/Cargo.toml ---
[package]
name = "donation_contract"
version = "1.0.0"
authors = ["Guillermo Gallardo <guillermo@near.org>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0-pre.7"
uint = { version = "0.8.3", default-features = false }

[profile.release]
codegen-units = 1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true
'''
'''--- storage-rs/contract/README.md ---
Storage Smart Contract
======================

A [smart contract] written in [RUST] 

Exploring The Code
==================

1. The main smart contract code lives in `src/lib.rs`. You can compile
   by running `cargo build`.
2. Tests: You can run smart contract tests by doing `cargo test`.

  [smart contract]: https://docs.near.org/
  [RUST]: https://doc.rust-lang.org/book/title-page.html
'''
'''--- storage-rs/contract/src/lib.rs ---
pub mod storage;
pub mod vector;
pub mod map;
pub mod set;
pub mod tree;

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{env, near_bindgen, PanicOnDefault};
use near_sdk::collections::{LookupMap, Vector, UnorderedSet, TreeMap};

// Constants
const ONE_NEAR: u128 = 1_000_000_000_000_000_000_000_000;

// Contract Structure
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
  pub vector: Vector<i32>,
  pub map: LookupMap<String, i32>,
  pub set: UnorderedSet<i32>,
  pub tree: TreeMap<String, i32>,
  pub demo_u128: u128,
  pub demo_string: String,
}

#[near_bindgen]
impl Contract {
  #[init]
  #[private]
  pub fn new(demo_string: String) -> Self {
    assert!(!env::state_exists(), "Already initialized");
    Self {
      vector: Vector::new(b"vec-uid-1".to_vec()),
      map: LookupMap::new(b"map-uid-1".to_vec()),
      set: UnorderedSet::new(b"set-uid-1".to_vec()),
      tree: TreeMap::new(b"tree-uid-1".to_vec()),
      demo_u128: ONE_NEAR,
      demo_string: demo_string
    }
  }
}
'''
'''--- storage-rs/contract/src/map.rs ---
use crate::Contract;

#[cfg(test)]
mod tests {
  use super::*;

  #[test]
  fn test_map() {
    let mut contract = Contract::new("".to_string());
    let key: String = "key".to_string();
    let value: i32 = 1;

    contract.map.insert(&key, &value);
    assert!(contract.map.contains_key(&key), "Error saving value");

    let val = match contract.map.get(&key) {
      Some(x) => x,
      None => panic!("Error saving value"),
    };

    assert!(val == value, "Wrong value obtained");

    contract.map.remove(&key);
    assert!(!contract.map.contains_key(&key), "Error deleting")
  }
}

'''
'''--- storage-rs/contract/src/set.rs ---
use crate::Contract;

#[cfg(test)]
mod tests {
  use super::*;

  #[test]
  fn test_set() {
    let mut contract = Contract::new("".to_string());
    let value: i32 = 1;

    contract.set.insert(&value);
    assert!(contract.set.contains(&value), "Error adding value");

    contract.set.remove(&value);
    assert!(!contract.set.contains(&value), "Error removing value");
  }
}

'''
'''--- storage-rs/contract/src/storage.rs ---
use crate::{Contract, ONE_NEAR};

#[cfg(test)]
mod tests {
  use super::*;

  #[test]
  fn test_storage() {
    let mut contract = Contract::new("init value".to_string());

    assert!(contract.demo_u128 == ONE_NEAR, "Error in demo_u128");
    assert!(contract.demo_string == "init value".to_string(), "Error in demo_str");

    contract.demo_u128 = 0;
    assert!(contract.demo_u128 == 0, "Error in demo_u128");

    let another_string: String = "another string".to_string();
    contract.demo_string = another_string.clone();
    assert!(contract.demo_string == another_string, "Error in demo_str");
  }
}

'''
'''--- storage-rs/contract/src/tree.rs ---
use crate::Contract;

#[cfg(test)]
mod tests {
  use super::*;

  #[test]
  fn test_tree() {
    let mut contract = Contract::new("".to_string());
    let key: String = "key".to_string();
    let value: i32 = 1;

    contract.tree.insert(&key, &value);
    assert!(contract.tree.contains_key(&key), "Error saving value");

    let val = match contract.tree.get(&key) {
      Some(x) => x,
      None => panic!("Error saving value"),
    };

    assert!(val == value, "Wrong value obtained");

    contract.tree.remove(&key);
    assert!(!contract.tree.contains_key(&key), "Error deleting")
  }
}

'''
'''--- storage-rs/contract/src/vector.rs ---
use crate::Contract;

#[cfg(test)]
mod tests {
  use super::*;

  #[test]
  fn test_vector() {
    let mut contract = Contract::new("".to_string());
    let value: i32 = 1;

    contract.vector.push(&value);
    contract.vector.push(&1);

    assert!(contract.vector.len() == 2, "Incorrect length");

    let val = match contract.vector.get(0) {
      Some(x) => x,
      None => panic!("Error saving value"),
    };

    assert!(val == value, "Error saving value");

    contract.vector.replace(0, &3);
    let val2 = match contract.vector.get(0) {
      Some(x) => x,
      None => panic!("Error saving value"),
    };

    assert!(val2 == 3, "Error saving value")
  }
}

'''
'''--- storage-rs/package.json ---
{
  "name": "donation",
  "version": "1.0.0",
  "license": "UNLICENSED",
  "scripts": {
    "test": "cd contract && rustup override set nightly && cargo test"
  }
}

'''