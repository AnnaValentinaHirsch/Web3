*GitHub Repository "andrewwhitehouse/writing"*

'''--- 01-compass.md ---
**Compass**

I've found I have two primary ways of processing technical information that works for me. So that I can learn the technical skills that help me stay relevant and employed: write code to solve problms (and ideally keep using that language so that the newly acquired information doesn't become crowded out by other things) and write out things by hand. There is something about the analogue process of writing by hand which helps the information to stick. Abd tge distance between thought and written word seems shorter. One challenge I have with this approach is maintaining legible text; my word formation has become less rigorous over decades of keyboard use and sometimes I revert to not writing joined up if I'm lapsing into doctor's scrawl.

So for this book I thought I would experiment with hand-writing first to see how the result is different.

![image|375x500](upload://y29NsshW8VsQmgWae4HdSkk7YkE.jpeg)

It's slow. And for learning technical material painfully slow. I remember when I was learning Java from Bruce Eckel's book (back in 1997) that I write out key concepts by hand in order to remember them. Over the years and through my daughter's experience I suspect I have developed coping mechanisms for ADHD. (In my first degree ... Computer Science and Electronic Engineering I struggled to stay engaged as the course went on, so I didn't get the degree I was capable of. Sixteen years later, and £30K poorer, I took a a masters in information security and came out with a distinction.) 

I suspect there are other coders who experience some form of related challenge. And I think I can help those people. And there could be many of them; we're told everyone could benefit from being able to code. I also think about being a parent, losing my Dad when I was four. My Mum probably feeling overwhelmed most of the time. Being told aged 18 that it was time to leave. And developing coping mechanisms, and sheer bloody-minded persistence. No safety net.

I currently see two books. On the one hand I'm embracing the curiosity of the ADHD brain that jumps around and makes connections. There is a talent (or is it a skill) I have for identify similar song segments, or less well-known actors and what other thing they've acted in. I'm quite good at Name That Tune, particularly with 80's Pop, much to the consternation of my colleagues when that was our Zoom social activity. But I couldn't think of a way to monetize it. (I guess Shazam did.) I thought about doing something based on MP3 files in Dropbox and then building a playlist based on key and beat. But I don't think it's as useful a business as education. Education is the way people can better themselves and acquire resources for a better life. And making connections, between non-obvious related things, while learning technology could provide an interesting slant.

So, two books: 

1. teaching my children (and others) to code
2. Rust for centralised and de-centralised applications

The first one ... from Dad to my children. Teaching them how to code. At least one wants to. Maybe the others will read it too out of sheer curiosity to see if it's any good. My eldest daughter, who introduced me to ADHD has an internship coming up. So I'm writing it for her, and I hope my other children will read it too. I have a vague notion about abstractions ... layers (which ogres like Shrek have). 

My first coding language was C, which is _close to the metal_. You need to manage your own memory, and you build programmes that compile to native code which the machine can run directly. Then it was clear that managing your own memory is a real pain, and source of bugs. So garbage collection became more prevalent: you let the interpreter allocate and clean up the memory for you. And now we're again looking for performant languages like Rust which use less electricity so it's good for the planet. 

Is it helpful to introduce a beginner to abstractions? Electrons/transisters/binary/state/data types. I think so. I might borrow some of the ideas from SICP. (Hurray for Creative Commons.) Because we're dealing with ones and zeroes, but we want to represent decimal numbers, which can introduce some interesting issues. Or how do we represent non-Latin character sets. And what about sending text over a wire to another computer? Or large numbers ... what is the language requires you to say "how big" your numbers are, versus figuring it out for you. And data types that have a native representation are much faster than "big" integers for example. 

The other book is the Rust / blockchain book. What a bumpy ride it's been this week with the collapse of Luna, which had a market capitalisation of $50Bn. (Lehman Brothers was $60Bn.) Rust is a modern successor to C, And it will be popular in performance-critical applications: Web augmented reality. Cloud applications that are billed based on memory and CPU usage. But it's non-trivial.

Actually there's a third book I've been thinking about. How to migrate from the stack I currently use in my day job to a stack that validates my ability to keep earning good money. The contract market has taken a battering after the IR35 rules were changed last year. I think I can hang in there long enough to get my crypto credentials bolstered sufficiently. I don't think Bitcoin or Ethereum are going away.

And maybe the coding programme for the easily distracted will take off.

![image|375x500](upload://hJdrrQnybrneGLpfPAuvVCm66W3.jpeg)

P.S. There's another project I've been thinking of. My Dad built me a plywood box on which he mounted an assortment of (slider, toggle and rocker) switches and lamps. In the four years we overlapped it's one of the visceral things I remember. I want to explore something similar with my children, or others. Like a combination of hardware and software. 

For the Rust book, I've registered _rustychain.xyz_. I'm musing on the other title.

@Beaver

'''
'''--- 02-attention.md ---
**Attention**

It's Saturday, and I woke up early. So I thought I would do some writing, which I did by hand. And that worked pretty well. And then the house started to wake up and I found it harder to concentrate. I want to be present for my family _and_ I want (need) to write too. In software delivery we have people, scope and time that we can vary. Applying this to writing, scope can be variable. One side of A4, or a particular concept. Time is a function of the difficulty, and how much preparation is needed. And people is me.

I don't like the term, but you could describe me as a highly sensitive person. I get really easily distracted by noise. And seeing other people being unkind or inconsiderate pisses me off. Working in a consulting role means I need to temper my natural inclination to immediately intervene and possibly damage relationships. So I need to be calm. But in a noisy world I often don't feel calm. And others don't take it well if my bucket is full at the end of the day and they want to talk. Taking the dogs out helps. As long as they don't run off across the field, or poo too much. We have three of them. We had the mum. Decided to keep one of the girls. And then Charyl Baker https://www.youtube.com/watch?v=RO-mxo-14H4 was going to take the boy and then she had a job come up. He's a great dog though. Taking out three of them together is quite hectic.

(Coincidentally the Eurovision is on again tonight. It's a melting pot of geopolitical point scoring. The UK is an outsider in Europe now, and last year we received [nul points](https://www.walesonline.co.uk/lifestyle/tv/what-eurovision-2021-uk-entry-23926857). Who knows if we'll do any better this year. Here is a history of the Russia-Ukraine [through Eurovision](https://qz.com/2164505/the-russia-ukraine-conflict-as-told-through-eurovision-songs/).)

And my wife's been away this week with friends so I've been spinning more plates. 

And one of the recent joiners in our team at work has a way of interacting that didn't work for me: commenting on "being of a certain age", code that makes him "shudder", and in a retro telling our scrum master that she missed an opportunity to call me "pig ignorant". So I had to prepare myself for addressing this behaviour calmly and constructively. And it was really tiring. And I honestly resented having to invest my energy in that, frankly.

I was reminded of Seth's comment that he doesn't manage people because he finds it stressful. And neither does [Dharmesh Shah](https://podnote.io/20210707-dharmesh-shah-mfm.html), Hubspot founder. Hmm ... I see that idea about the community for remote work. Has anyone done that yet?

Steven Pressfield talks about a practice having a place and a time. I struggle to maintain this, based on what else is going on at the time. I find the morning works best for me, before the unpredictable nature of the day frazzles my nerves, and I'm not calm enough to write. Fitting that into the day job can be a challenge. I already have a pomodoro timer, as suggested by Ken. I need to use it more. Even finding half an hour to hand-write something could work. 

Interested to hear what routines work for you.

'''
'''--- 03-data-engineering.md ---
* [How To Break Into Data Engineering And Why It’s So Hard](https://medium.com/coriers/how-to-break-into-data-engineering-and-why-its-so-hard-afe023922ef6)
* [5 things you should know for a career in data engineering](https://www.stitchdata.com/blog/5-things-you-should-know-for-career-in-data-engineering/)
* [A Data Engineering Perspective on Go vs. Python (Part 1)](https://chollinger.com/blog/2020/06/a-data-engineering-perspective-on-go-vs.-python-part-1/)
* [Python Data Science Handbook](https://www.amazon.co.uk/Python-Data-Science-Handbook-Essential-ebook/dp/B01N2JT3ST/ref=tmm_kin_swatch_0?_encoding=UTF8&qid=&sr=)
* [The Battle for Data Engineer’s Favorite Programming Language Is Not Over Yet](https://betterprogramming.pub/the-battle-for-data-engineers-favorite-programming-language-is-not-over-yet-bb3cd07b14a0)

'''
'''--- 04-elements-of-programming.md ---
[_My brain has been jumping around this morning. I started off thinking about what I can do to support my daughter in preparing for her summer internship. And then I thought I'm second-guessing this and I should do the simplest thing and have sessions with her and talk through what she wants to learn. And I have this book I want to write, which could be helpful to her, and to others. And leverage the work I've already done ..._]

**The Elements of Programming**

The Structure and Interpretation of Computer Programmes is one of the first texts I read, and the one book I kept from my university study. It was written in Scheme, which is a form of LISP.

I've decided to keep one eye on this book, cherry-picking, and updating the examples to align with modern languages currently in use.

From [SICP](https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book.html):

> A powerful programming language is more than just a means for instructing a computer to perform tasks. The language also serves as a framework within which we organise our idas about processes. Thus, when we describe a language, we should pay particular attention to the means that the language provides for combining simple ideas to form more complex ideas. 
>
>Every powerful language has three mechanisms for accomplishing this:
>
>- primitive expressions, which represent the simplest entities with which the language is concerned
>
>- means of combination, by which compound expressions are built from simpler ones, and
>
>- means of abstraction, by which compound objects can be named and manipulating as units.
>
>In programming we deal with two kinds of objects: procedures and data. [...] Thus, any powerful programming language should be able to describe primitive data and primitive procedures and should have methods for combining and abstracting procedures and data.
>
>In this chapter we will deal only with simple numerical data, so that we can focus on the rules for building procedures.

I've spent more than 30 years working as a software developer. I've read a lot of books, which tell you lots of stuff and get you to write code. I rarely feel that these get to the essence of what it is we're doing ... why a particular language was designed the way it was and what are the pros and cons of doing it that way. So rather than just following a series of steps with some overly simplified statement "comments are useful", I want to avoid wasting people's time _and_ not mislead them.

As David Foster Wallace reminds us in [This Is Water](https://fs.blog/david-foster-wallace-this-is-water/) it's helpful to acknowledge what ocean you're swimming in.

[This may belong in an introduction ...]

One of the things I remember my Dad making for me  was a ply wood box on which were mounted lots of different types of switches (push and release, sliding, chrome toggle switches) and lamps like you might find in an aircraft cockpit. After playing with it for a while I opened it up to see how it works. 

This was the analogue world, which obeys the laws of physics. If the battery started to drain the bulb glowed less brightly. But it was "on" or "off". 

In the "digital" world we map those analogue voltages to binary 1s (on) and 0s (off): on is represented as 5 volts usually, and off is zero. You'll see that your phone charger delivers 5 volts.

These electrical signals were initially manipulated by valves and then transistors. To increase the speed and capability of the processors, chip manufacturers packed more and more transistors on to the silicon wafer. Until the laws of physics meant that they couldn't do that reliably on a single processor. So now we have multiple processors.

Our primary school headmaster suggested that a boarding school in our county might be a good option. I continued my interest in electronics, buying books and the magazine Everyday Electronics, and figuring out how to organise components on veroboard to match the circuit diagram.

At boarding school there was a minicomputer which ran a version of Unix. The programming language was C, and so I bought a copy of the (pre-ANSI) "C Programming Language" and worked through the examples.

This book is useful because it gives you experience coding closer to the hardware. 

As coders we operate some way up the stack, and we don’t usually need to think about the details of what the hardware is doing to make our programme run.

We can write code that uses the fewest possible machine instructions to achieve the result, if performance is really critical. But that requires an investment in understanding how our chosen language maps to machine instructions. And that may not be the most valuable use of our developers’ time compared to shipping features for our customers who pay the bills.

Our programme runs on a computer that has a finite amount of memory to store its working calculations. If we exceed that memory our programme will stop working properly. So something, or someone, needs to clean up the unused memory. Garbage collectors do this in many language runtimes. Or you can avoid the overhead of the cleanup and write code that is careful to allocate only what is needed, and clean it up.

The instruction, or word size, affects the data types that are available to you as a coder.

We used to have “32-bit” computers which referred to the instruction size. The maximum number that you can natively represent in the hardware was 2^32, which is 4,294,967,296. So 32 bit computers could not have more than 4GB (4 gigabytes … giga is 10^9). Now that we have 64-bit machines, the hardware can support much larger amounts of memory.

(Note: calculate 2^64 in the next REPL session. And note that Python doesn’t limit integers to this size.)

In the course of your coding you will create variables to represent the data concepts you are modelling. A statically typed language like Rust requires you to specify up-front what the type is, including how big you need it to be. A dynamically typed language infers the type, which means you as the coder don’t need to think about this too much.

It's helpful to remembers that we have data abstractions built on top of the ones and zeroes recognised at the hardware level. Because sometimes those abstractions are "leaky" and we need to deal with that (example: how to represent floating point numbers).

To compare and contrast language styles we'll be covering examples in Python, Clojure and Rust.

'''
'''--- 05-sicp-in-python.md ---
**SICP in Python**

In SICP one of the early [examples](https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-10.html#%_sec_1.1.1) given is calculating the circumference of a circle.

The approach taken (in Scheme) is an interactive one, and here's what it looks like in Python:

```
$ python
Python 3.6.10 (default, Feb  6 2020, 15:10:56) 
[GCC 4.2.1 Compatible Apple LLVM 10.0.0 (clang-1000.10.44.4)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
>>> radius = 10
>>> type(radius)
<class 'int'>
>>> import math
>>> circumference = 2 * math.pi * radius
>>> circumference
62.83185307179586
>>> 
```

Running Python without an argument opens it in interactive mode, which is known as the REPL. `REPL` is short for Read-Eval-Print-Loop; you are given a Python runtime where you can add definitions and try things out, for quick feedback. So it's a good way to explore the language.

However, once you close the REPL your code is gone. (Although you can cycle through the history and execute the commands again.) So it makes sense to save your code in more persistent form, such as a local file. (And keep it under version control like _git_, but that's a topic for a different post.)

And writing automated tests allow you to check quickly that your code is still working.

I followed [this example](https://realpython.com/python-testing/) for setting up the tests.

Here are the initial folder contents: 

```
.
├── chapter1
│   ├── __init__.py
│   └── chapter1.py
└── test_chapter1.py
```

`chapter1/__init__.py`

```
import math
  
def circumference(radius):
  return 2 * math.pi * radius
```

`test_chapter1.py`

```
import unittest
from chapter1 import circumference

class TestChapter1(unittest.TestCase):

    def test_circumference(self):
        self.assertEqual(circumference(10), 62.8318)

if __name__ == '__main__':
    unittest.main()
```

We have created a function called `circumference` which takes a parameter called `radius`, and that parameter is then used in a calculation. The function isn't stating what the type of `radius` is; if the operations we use in the function are defined for the parameter we specify then we will receive a meaningful resulti when we run the code; otherwise we will receive an error. 

A function is a type of abstraction, where we can give a name to a procedure or behaviour that allows us to communicate the intent of our code. The function takes input data through its parameters and returns a value. 

Writing small functions with well-chosen names helps to create readable code, which is important for us if we're returning to our code after six months, or for another team member trying to understand what our code does.

You'll see function names given as nouns, as we have here, or verbs, such as _calculate\_circumference_. The Python Style Guide [recommends](https://peps.python.org/pep-0008/#function-and-variable-names) that function names are lower case, with words separated by underscores. Other languages use [Camel Case](https://en.wikipedia.org/wiki/Camel_case) or Caps Case.

```
$ python test_chapter1.py 
F
======================================================================
FAIL: test_circumference (__main__.TestChapter1)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "test_chapter1.py", line 7, in test_circumference
    self.assertEqual(circumference(10), 62.8318)
AssertionError: 62.83185307179586 != 62.8318

----------------------------------------------------------------------
Ran 1 test in 0.001s

FAILED (failures=1)
Andrews-MacBook-Pro:python andrewwhitehouse$ 
```

You can't compare decimals directly because their representations are not exact. 

So, change the test assertion:

```
self.assertAlmostEqual(circumference(10), 62.8318, places=3)
```

```
$ python test_chapter1.py 
.
----------------------------------------------------------------------
Ran 1 test in 0.000s

OK
$
```

:tada:

'''
'''--- 06-type-conversion.md ---
Let's define a function to perform a simple calculation, and give it some values:

```
$ python
Python 3.6.10 (default, Feb  6 2020, 15:10:56) 
[GCC 4.2.1 Compatible Apple LLVM 10.0.0 (clang-1000.10.44.4)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
>>> def square(x):
  return x*x
... 
>>> result = square(2)
>>> result
4
>>> type(result)
<class 'int'>
>>> result2 = square(2.0)
>>> result2
4.0
>>> type(result2)
<class 'float'>
>>> 
```

Our function returns the square of its argument. if we pass it the value 2, which is an `integer` (a number with no fractional part), we receive an integer back.

In the second case, we call the function with a decimal number which happens to have the same value, but because we add the ".0" Python knows to treat it as a float, and so it returns the result of modifying two floats. Multiplication is defines for integers and floats.

What if we try a non-numeric value?

```
>>> square("hello")
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 1, in square
TypeError: can't multiply sequence by non-int of type 'str'
>>> 
```

So Python will attempt to apply the operations in your function to the data types you give it. 

What if we change the definition slightly?

```
>>> def multiply(x,y):
...   return x*y
... 
>>> multiply(2,2)
4
>>> multiply(2.0, 2)
4.0
>>> multiply("hello", 2)
'hellohello'
>>> 
```

You can see that the result of multiplying a float and an integer is a float. Python [converts](https://docs.python.org/3/reference/expressions.html#arithmetic-conversions) the values to a common type. And the `*` operator works with a string and a number to repeat that string.

'''
'''--- 07-sicp-in-go.md ---
[_I've been mulling over what direction to take this in. Comparing two languages gives a useful concrete way to compare and contrast the design. So what would that look like? For blockchain it's Solidity vs Rust. For building an MVP application it's probably Clojure vs Kotlin. For moving from legacy to a newer stack it's Java vs Clojure or Kotlin. For centralised vs decentralied it could be serverless Rust vs blockchain Rust. And I looked at what I was planning to do ... start with Python and introduce elements of Rust (which I'm learning) and Clojure (which I know), or possibly Java (which I also know) and I thought _this is too much_. For me, and the person who's learning it. So let's focus on the audience, which is my daughter right now. And the skills that she'll need for a data engineering job. I don't know the specifics of the data engineering part yet, so I'll focus on the language.

I have some FOMO about leaving the other topics, and whether this is a market of one. But I'm OK with that. And it's doubling down on some of the non-technical issues: what are some of the things you would have likes to know when starting your career; what are the ways that men can help to make technology a good place to work; where are the boundaries of what makes a reasonable code review versus something else. I think I also need to be careful not to spoon feed. Because there is satisfaction in learning the meta tools, like figuring out an answer when you don't have someone standing behind you telling you what to do._]

We have explored writing a function in Python to calculate the square of a number. 

The other language we're going to use in this book, which is statically typed, meaning that we specify in our code what types we are using and -- depending on whether we compile the code first -- either the runtime, or the compiler, checks that our usage of those types makes sense.

Those types are like extra scaffolding, which invovle more up-front work, but they help you to see how the pieces fit together, like lego.

For a small project [[reference](https://www.reddit.com/r/golang/comments/qwyk3k/what_is_the_best_way_to_organize_code_within_a_go/)] we can create a `main` file in a sub-directory.

`mkdir -p go/chapter`
`cd go/chapter`

In code/go/chapter1

Create main.go with a "hello world" to get started.

```
package main
  
import "fmt"

func main() {
    fmt.Println("hello world")
}
```

We have various integer and decimal [numeric types](https://tip.golang.org/ref/spec) available.

We can interrogae the [math](https://pkg.go.dev/math) package to see what the maximum possible integer value is.

```
import "fmt"
import "math"

func main() {
    fmt.Println(math.MaxInt64);
}
```

(Note that it's "math" singular ... spelling of elements shipped with the language tend to follow the American form, like `color`. In the programmes we write, we can use whatever dialect works for those maintaining the code.)

```
$ go run main.go 
9223372036854775807
$
```

OK that's for a signed integer. 

```
fmt.Println(math.MaxUint64);
```    
    
gives

```
$ go run main.go 
# command-line-arguments
./main.go:7:16: constant 18446744073709551615 overflows int
$ 
```

Googling: <https://stackoverflow.com/questions/16474594/how-can-i-print-out-an-constant-uint64-in-go-using-fmt> it turns out the type used depends on the context. We need to explicitly convert the `MaxUint64` constant in our code.

```
fmt.Println(uint64(math.MaxUint64));
```
    
Multiping the maximum signed integer by itself is greater than the maximum (64-bit) integer. Is that an issue for us? Is it important to be able to work with large numbers? In this example we can make up our own requirements. For now, let's restrict the types of the square function so that we don't encounter these issues.

```
func square(x int32) int64 {
    return x*x
}

func main() {
    fmt.Println(square(math.MaxInt32));
}
```

```
$ go run main.go 
# command-line-arguments
./main.go:7:13: cannot use x * x (type int32) as type int64 in return argument
$
```

Still not happy.

```
func square(x int32) int64 {
    return int64(x) * int64(x)
}
```

```
$ go run main.go
4611686014132420609
$
```

Does that look right? Let's do a sanity check ... 2x10^9  times itself is 4 x 10^18.

So far we've limited ourselves to numbers that are integers. But we want to handle decimals too. Let's change the implementation.

```
func square(x float64) float64 {
    return x*x
}

func main() {
    fmt.Printf("Max float64 %f\n", math.MaxFloat64);
}
```
```
$ go run main.go
Max float64 179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
$

```

You can see that our statically typed language is requireing us to be more intentional about the types we choose to use in our code. 

Not all code involves mathematical calculations. But there is plenty of counting. 

We need someone to tell us when constraints we are working in (if they know) and otherwise make sensible assumptions. In a project team that person is often a Business Analysit or Product Owner or Product Manager

Let's suppose we were creating a business that sold triangular gardens with a right angle in Central London (based on a quirky medieval layout -- no tidy grids here). We want to calculate the length of the longest side, in millimetres.

Realistically, a 32-bit integer is going to suffice because that's around 4 billion millimeters, or 4 million metres. Quite a large garden.

```
package main
  
import "fmt"
import "math"

func longestWallLength(x, y uint32) uint32 {
  return uint32(math.Sqrt(float64(x*x + y*y)))
}

func main() {
    fmt.Printf("Longest wall %dmm\n", longestWallLength(10 * 1000, 4950));
}
```

```
$ go run main.go
Longest wall 11158mm
$
```

(We can debate whether it makes sense to measure inner city triangular gardens in millimeters.) 

You can see that the static typing in Go required us to be quite deliberate about the type conversions in the Pythagorean triangle calculation. Static typing doesn't prevent all bugs, but it helps to make assumptions explicit.

@beaver

'''
'''--- 08-comparison.md ---
We've introduced functions in Python and Go. Functions are a form of abstraction which allows us to group a set of operations together in a logical unit of code. Writing small well-named functions helps to improve the readability of our code.

In Go we wrote:

```
func square(x float64) float64 {
    return x*x
}
```

and in Python:

```
def square(x):
    return x*x
```

Let's compare and contrast the language features so far.

Both functions have a name, which is to be associated with the function definition in the environment.

Languages tend to standardise on a set of coding guidelines so that stylistic issues don't become a point of contention in a team. Python has its own [style guide](https://peps.python.org/pep-0008/#function-and-variable-names) while Go has it's own `go fmt <filename>` command to fix formatting issues, and there are various style guides that a team can adopt for code reviews ([example](https://github.com/golang/go/wiki/CodeReviewComments#gofmt)).

The function `parameters` are the names used within the body of the function to refer to the corresponding arguments of the function. The parameters in both Python and Go are grouped within parentheses and separated by commas.

In the simplest form, the `body` of the function declaration has a single `return` statement which concists of the keyword `return` followed by the `return` expression that will yield the value of the function application.

In Go, the function body is enclosed by braces `{` and `}`. 

Python ends the first line of a function definition with a colon `:` and subsequent lines are indented. A blank line separates the function body from the rest of the programme.

Go types are specific after the function parameters, and the function return type comes after the parameters. Specifying the parameter type _after_ the parameter names allows parameters of the same type to be grouped.

Both definitions are OK:

```
func multiply1(x, y float64) float64 {
        return x * y
}

func multiple2(x float64, y float64) float64 {
        return x * y
}
```

Having a single return point from a function can make it easier to reason about and debug, particularly if your language doesn't come with a debugger to step through the programme, and you debug your programmes by adding temporary print statements (as we did in the olden days of C programming before Test-Driven Development came along).

Python infers the types in your programme from the content of your programme. It's possible to call a function with an integer _or_ a float type without explicitly saying which it is, and as long as the operation is defined, it will run. Go will enforce the type constraints you define. So for example, running this:

```
import "fmt"

func identity(x int32) int32 {
        return x
}

func main() {
        var age int64 = 22
        fmt.Println(identity(age))
}
```

will produce

```
$ go run main.go
# command-line-arguments
./main.go:11:22: cannot use age (type int64) as type int32 in argument to identity
$ 
```

The `identity` function doesn't seem very useful since it simply returns the supplied parameter. However there are cases where we may want to perform a transformation on a value in some cases and not others, and we do that by passing a function as a function parameter. We'll cover this in [a future chapter].

even though the assigned value will happily fit in a 32-bit integer. (Intuitively, if age is representing years then an unsigned 8-bit integer is a better choice.)

In the next section we're going to cover combining functions ...

Exercise: 
1. What is the maximum value of an unsigned 8-bit integer? 
2. Why wouldn't we opt to represent age in years as a signed 8-bit integer?

[details="Answers"]
Answers:
1. 255
2. Ages can't be negative; 127
[/details]

'''
'''--- 09-sicp-in-clojure.md ---
I'm experimenting with another language to compare with the Python interpretation of SICP. (If you didn't read the previous post(s), SICP is a classic work of computer science called Structure and Interpretation of Computer Programs [sic] :) )

Also there is a Clojure contract role coming up, and I've been thinking why am I not making more of all the effort I've taken to learn Clojure.

And ... back to the code ...

---

We've previously seen a Python implementation of a square function. 

```
def square(x):
  return x*x
```

Thie code calls the multiply operator on x with the argument of x, again. When called with an integer, like `123`, the function will return an integer. When called with a float, like `123.4` the function will return a float.

Down at the hardware level data types are represented as 1s and 0s, and we can't represent all decimal values precisely. 

For example:

```
$ python
Python 3.6.10 (default, Feb  6 2020, 15:10:56) 
[GCC 4.2.1 Compatible Apple LLVM 10.0.0 (clang-1000.10.44.4)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
>>> 0.1 + 0.2
0.30000000000000004
>>> 
```

So when comparing float values we need to check that their difference is smaller than our allowed tolerance. In this case you could check that the difference is less than 0.000001. Actually you could do more, but do you really want to be managing constants in your code like 0.000000000000001. How many zeroes is that?

A language that has similar semantics to both Python and Scheme is Clojure.

The Clojure interpreter and compiler runs on top of either the Java Virtual Machine or the JavaScript V8 runtime used by Nodejs.

We're using the Java runtime.

Let's create a project:

`lein new sicp`

By default we get this directory structure:

```
.
└── sicp
    ├── CHANGELOG.md
    ├── LICENSE
    ├── README.md
    ├── doc
    │   └── intro.md
    ├── project.clj
    ├── resources
    ├── src
    │   └── sicp
    │       └── core.clj
    └── test
        └── sicp
            └── core_test.clj
```

Because we're organising our code in chapters I'll be renaming those core files.

The `lein` tool is actually called Leiningen. This is a literary reference to a Carl Stephenson work "Leiningen Versus the Ants". Ant is also a build tool that many of us has encountered in our careers.

`src/sicp/chapter1.clj`

```
(ns sicp.chapter1)
  
(defn square [x]
  (* x x))
```

This file defines a namespace within which any functions and other values are defined. We use `defn` to define a function, and function parameters are enclosed in square brackets.

I can load this file in a REPL by first tweaking my project.clj:

```
  :repl-options {:init-ns sicp.chapter1} 
```

```
$ lein repl
nREPL server started on port 56605 on host 127.0.0.1 - nrepl://127.0.0.1:56605
REPL-y 0.4.3, nREPL 0.6.0
Clojure 1.10.0
OpenJDK 64-Bit Server VM 11.0.7+10-LTS
    Docs: (doc function-name-here)
          (find-doc "part-of-name-here")
  Source: (source function-name-here)
 Javadoc: (javadoc java-object-or-class-here)
    Exit: Control+D or (exit) or (quit)
 Results: Stored in vars *1, *2, *3, an exception in *e

sicp.chapter1=> (square 2)
4
sicp.chapter1=> (square 2.2)
4.840000000000001
sicp.chapter1=> (type (square 2))
java.lang.Long
sicp.chapter1=> (type (square 2.2))
java.lang.Double
sicp.chapter1=> 
```  

To answer the question "is it (still) working" we can add a couple of tests.

`test/sicp/chapter1_test.clj`

```
(ns sicp.chapter1-test
  (:require [clojure.test :refer :all]
            [sicp.chapter1 :refer :all]))

(defn is-close [a b tolerance]
  (< (Math/abs (- a b)) tolerance))

(deftest test-square
  (testing "square integer."
    (is (= 9 (square 3))))
  (testing "square decimal"
    (is (is-close (square 2.2) 4.84 0.001))))
```

The namespace definition pulls in the libraries from the `clojure.test` namespace as well as the `sicp.chapter1` namespace where we've defined our square function. Because the functions are required with `:refer :all` the square function can be called directly. It also means we couldn't define a test with the same name (e.g. `deftest square`) because the names would clash.

I tend to prefix test names with `test-` which can end up being redundant.

The alternative is to change the way we reference the namespace being tested:

```
(ns sicp.chapter1-test
  (:require [clojure.test :refer :all]
            [sicp.chapter1 :as ch1]))

(defn is-close [a b tolerance]
  (< (Math/abs (- a b)) tolerance))

(deftest test-square
  (testing "square integer."
    (is (= 9 (ch1/square 3))))
  (testing "square decimal"
    (is (is-close (ch1/square 2.2) 4.84 0.001))))
```

I borrowed the `is-close` definition from [Python](https://stackoverflow.com/questions/558216/function-to-determine-if-two-numbers-are-nearly-equal-when-rounded-to-n-signific).

Note that Clojure tends to adopt lower case names for functions, and separates works with hyphens: this is called "kebab case".

Let's run the tests:

```
$ lein test

lein test sicp.chapter1-test

Ran 1 tests containing 2 assertions.
0 failures, 0 errors.
$
```        

Writing Clojure actually makes me happy; I can get a lot done with a small amount of code. It is elegant, expressive and concise. It's like a superpower. The language is beautifully designed. And Rich Hickey who designed it is a genius. It hasn't gained the widespread adoption that some other languages have; for large projects companies tend to prefer static typing, which makes refactoring easier. And because there are fewer people with the skill, fewer companies use it. 

You can mitigage the static typing issue with more tests. But that requires discipline, which requires experience. (See above point.)

I've heard it said that some of the community can be quite opinionated, to the point of being prickly, which has made it less accessible. 

Paul Graham, of Y Combinator, has written about [LISP](http://www.paulgraham.com/diff.html) and its [suitability for startups](http://www.paulgraham.com/avg.html).

@beaver
'''
'''--- 10-clojure-macros.md ---
The book has a [section](https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-10.html#%_sec_1.1.5) on applicative versus normal order evaluation.

Clojure takes the "applicative order" approach which is to evalute the arguments first and then apply.

```
(defn p [] (p))

(defn test [x y]
  (if (= x 0) 0 y))

(test 0 (p))
```

In this code, the `p` function calls itself unconditionally. And later we call the test function with its first argument as zero, and the second argument as a call the the p function.

Executing this code causes the second argument to test to be evaluated, which calls itself going into an infinite loop and eventually falling over with a stack overflow error, since the call stack has a finite capacity.

```
sicp.chapter1=> (test 0 (p))
Execution error (StackOverflowError) at sicp.chapter1/p (form-init3631130360703580959.clj:1).
null

sicp.chapter1=>
```

There are a couple of ways we can work around this issue in Clojure.

The first is with Clojure _macros_.

The Clojure interpreter involves a [Reader](https://clojure.org/reference/reader) which can apply code transformations through macros. These transformations allow us to define new features.

In the above example we can define test as a macro instead:

```
(defmacro test [x y]
   `(if (= ~x 0) 0 ~y))
```          

Macros highlight a significant benefit in Clojure of code and data having the same representation. We can use code (macros) to manipulate data through the Reader, to produce code which is then executed. 

The Reader applies this as a transformation  

```
sicp.chapter1=> (defmacro test [x y]
           #_=>    `(if (= ~x 0) 0 ~y))
#'sicp.chapter1/test
sicp.chapter1=> (macroexpand-1 '(test 0 (p)))
(if (clojure.core/= 0 0) 0 (p))
sicp.chapter1=>
```

The macros effectively applies a substitution on its arguments, and it is the result that is actually executed. So in this case the code no longer executes the `p` function, avoiding the infinite loop.

A second way we can defer execution is by passing the second argument as a function to be executed from `test` only when needed:

```
sicp.chapter1=> (defn p [] (p))
#'sicp.chapter1/p
sicp.chapter1=> (defn test [x y]
           #_=>   (if (= x 0) 0 (y)))
#'sicp.chapter1/test
sicp.chapter1=> (test 0 p)
0
sicp.chapter1=>
```

Passing around a function that loops infinitely is not going to be very useful in practice. However it is feasible that a function argument leads to an operation that has an overhead, and we want to evaluate only in some cases.

'''
'''--- 11-clojure-ex1.3.md ---
**Exercise 1.3 in Clojure**  

> Define a procedure that takes three numbers as arguments and returns the sum of the squares of the two larger numbers.

I'm going to focus on the code to identify the two largest numbers.

Here was my first attempt, using named elements in a map.

```
;; First attempt
(defn two-largest [a b c]
  (let [first-pair (if (> a b) {:larger a :smaller b} {:larger b :smaller a})
        remaining-result (if (> c (:larger first-pair))
                           {:first c :second (:larger first-pair)}
                           (if (> c (:smaller first-pair) )
                             {:first (:larger first-pair) :second c}
                             {:first (:larger first-pair) :second (:smaller first-pair)}))]
    [(:first remaining-result) (:second remaining-result)]))
```

which is fairly gnarly and unreadable.

The key point is we need to identify which is the larger of the comparison in the first pair, and then compare that with the remaining value.

Oh, and I have written some tests:

```
(deftest test-two-largest
  (testing "all different"
    (is (= [3 2] (ch1/two-largest 1 2 3))))
  (testing "two equal"
    (is (= [2 1] (ch1/two-largest 1 2 1)))
    (is (= [2 1] (ch1/two-largest 1 1 2))))
  (testing "all equal"
    (is (= [3 3] (ch1/two-largest 3 3 3)))))
```

Let's try it using vectors.

```
;; Second attempt
(defn two-largest [a b c]
  (let [a-b-comparison (if (> a b) [a b] [b a])]
    (if (> c (first a-b-comparison))
      [c (first a-b-comparison)]
      (if (> c (second a-b-comparison))
        [(first a-b-comparison) c]
        a-b-comparison))))
```

I like this better, but there is still plenty of repetition that makes it harder to read.

Clojure has a `max` function which we can use:

```
;; Third ...
(defn two-largest [a b c]
  (let [max-a-b (max a b)]
     (if (> c max-a-b)
       [c max-a-b]
       [max-a-b (max (min a b) c)])))
```         

But I keep thinking we can improve the readability further by sorting the elements in descending order:

```
;; Fourth ...
(defn two-largest [& nums]
  (let [sorted (sort > nums)]
    [(first sorted) (second sorted)]))
```

There are a few things going on here. The ampersand in the arguments converts our parameters into a sequence.

```
sicp.chapter1=> (defn foo [& args] args)
#'sicp.chapter1/foo
sicp.chapter1=> (foo 1 2 3)
(1 2 3)
sicp.chapter1=>
```

We then sort that sequence and create a (scoped) let binding; the first element of the result is the largest and the second is the next largest. We ignore the other elements.

There are a couple of small improvements we could make. It's subjective how helpful these are:

```
;; Fifth
(defn two-largest [& nums]
  (let [first-two-values (fn [[a b]] [a b])]
    (first-two-values (sort > nums))))
```

This creates a local function that takes a collection and uses a technique called [destructuring](https://clojure.org/guides/destructuring) to bind the collection elements to specific variables. Note that the function arguments have an extra bracket.

```
sicp.chapter1=> (defn first-two-values [[a b]] [a b])
#'sicp.chapter1/first-two-values
sicp.chapter1=> (first-two-values [5 4 3 2 1])
[5 4]
sicp.chapter1=>
```

We can also bypass the local function by using a "thread-right" macro. This modifies the execution order of the expression.

The thread-right [macro](https://clojure.org/guides/threading_macros) takes the first item in the list and "threads" it as the last element of the next list (which it creates if needed), and then threads that result as the last element of the next list.

For example:

```
sicp.chapter1=> (macroexpand-1 '(->> '1 '2 '3))
(quote 3 (quote 2 (quote 1)))
sicp.chapter1=>
```

So the thread-right macro performs a code translation in the Reader step. Whether or not the result makes any sense when it comes to be executed is another matter.

Here's our version using the thread-right macro:

```
;; Sixth attempt
(defn two-largest [& nums]
  (->> (sort > nums)
       ((fn [[a b]] [a b]))))
```

This takes the result of sorting the numbers and then passes that as the argument to the function we've defined which returns a vector of the first two elements.

`macroexpand-1` is our friend again.

```
sicp.chapter1=> (macroexpand-1 '(->> (sort > nums) ((fn [[a b]] [a b]))))
((fn [[a b]] [a b]) (sort > nums))
sicp.chapter1=>
```     

The first part of the expression is an anonymous function which we call with the result of the sorting operation.

As I've been accumlating potential solutions I've been using a feature of Clojure: comment blocks.

```
(comment defn two-largest [& nums]
  (let [first-two-values (fn [[a b]] [a b])]
    (first-two-values (sort > nums))))

(defn two-largest [& nums]
  (->> (sort > nums)
       ((fn [[a b]] [a b]))))
```

The bracketed constructs are referred to as Clojure _forms_ and we can comment out an entire form by using the comment macro; this causes the entire form to evaluate to nil.

How do I know? Because Clojure lets us look at the source code.

```
user=> (source comment)
(defmacro comment
  "Ignores body, yields nil"
  {:added "1.0"}
  [& body])
nil
user=>
```

I think it's a close call as to which of the solutions is preferable. Some may feel that sorting the elements is over-engineering, but it's a standard operation and I believe it improves readability. I like the fourth and fifth because the intent is clear. And the last one wins for conciseness but it's easy to miss the extra define-and-call-function bracket, and the destructuring.

When I'm being paid to deliver functionality for a client I tend to stop at "it's readable, not over-engineered, and it works". These exercises allow us to go further and explore the trade offs.

@beaver
'''
'''--- 12-tdd-in-python.md ---
**Test-Driven Development in Python**

It's time to create a Python version of the exercise we wrote in Clojure.

First let's create the library with a failing test:

```
├── test_two_largest.py
└── two_largest
    ├── __init__.py
```

Unrelated files have been removed.

Here are the files:

```
import unittest
from two_largest import *

class TestTwoLargest(unittest.TestCase):

    def test_two_largest(self):
        self.assertEqual([3,2], two_largest(3,2,1))

if __name__ == '__main__':
    unittest.main()
```

```
def two_largest(*nums):
  return [0,0]
```

Running the tests:

```
Andrews-MacBook-Pro:python andrewwhitehouse$ python -m unittest test_two_largest.py 
F
======================================================================
FAIL: test_two_largest (test_two_largest.TestTwoLargest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/Users/andrewwhitehouse/code/writing/code/python/test_two_largest.py", line 7, in test_two_largest
    self.assertEqual([3,2], two_largest(3,2,1))
AssertionError: Lists differ: [3, 2] != [0, 0]

```  
              
For this exercise we're taking a test-first approach, also known as _Test-Driven Development_.

We start with a deliberately failing test, first it, refactor if needed, and add another test scenario until we've covered sufficient scenarios.

First fix.

```
def two_largest(*nums):
  return [nums[0], nums[1]]
```

It's hard-coded and is only going to work for the specific test case.

What is the first two numbers are in the wrong order?

```
    def test_first_two(self):
        self.assertEqual([3,2], two_largest(3,2,1))

    def test_first_two_out_of_order(self):
        self.assertEqual([3,2], two_largest(2,3,1))
```

Re-run the tests 

`$ python -m unittest test_two_largest.py `

```
Andrews-MacBook-Pro:python andrewwhitehouse$ python -m unittest test_two_largest.py 
.F
======================================================================
FAIL: test_first_two_out_of_order (test_two_largest.TestTwoLargest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/Users/andrewwhitehouse/code/writing/code/python/test_two_largest.py", line 10, in test_first_two_out_of_order
    self.assertEqual([3,2], two_largest(2,3,1))
AssertionError: Lists differ: [3, 2] != [2, 3]
```
  
Fix it

```
def two_largest(*nums):
  if nums[1] > nums[0]:
    return [nums[1], nums[0]]
  else:
    return [nums[0], nums[1]]
```

```
$ python -m unittest test_two_largest.py 
..
----------------------------------------------------------------------
Ran 2 tests in 0.000s

OK
$ 
```

The next test case involves the largest numbers being the second and third. Let's change the values used to show that we can handle values other than 1, 2 and 3.

```
    def test_last_two_largest_in_order(self):
        self.assertEqual([6,5], two_largest(4,6,5))
```
  
(Run tests again; newly added test fais)

```
def two_largest(*nums):
  if nums[1] > nums[0]:
    return [max(nums[1], nums[2]), max(nums[2], nums[0])]
  else:
    return [nums[0], nums[1]]
```

The nested 'ifs' are starting to become more difficult to reason about so it makes sense to use the max function to figure out the correct ordering.

I started to use the max function in both elements of the returned value. But on running the test I realised this wouldn't work. We're returning a two-element array and the first element is the maximum of nums[1] and nums[2]. If nums[2] is larger, then the second element should be nums[1]; if nums[1] is greater then the second element is the larger of nums[2] and nums[0]. As it's written, the code doesn't reflect that dependency between the elements.

New failing test ...

```
    def test_last_two_out_of_order(self):
        self.assertEqual([9,8], two_largest(7,8,9))
```

Make the change ...

```
def two_largest(*nums):
  if nums[1] > nums[0]:
    if nums[2] > nums[1]:
      return [nums[2], nums[1]]
    else:
      return [nums[1], max(nums[2], nums[0])]
  else:
    return [nums[0], nums[1]]
```

Next failing test ...

```
    def test_first_and_last_in_order(self):
        self.assertEqual([102, 101], two_largest(102, 100, 101))
```

First attempt failed an earlier test:

```
def two_largest(*nums):
  if nums[1] > nums[0]:
    if nums[2] > nums[1]:
      return [nums[2], nums[1]]
    else:
      return [nums[1], max(nums[2], nums[0])]
  else:
    if nums[0] > nums[2]:
      return [nums[0], nums[2]]
    else:
      return [nums[0], nums[1]]
```

```
Traceback (most recent call last):
  File "/Users/andrewwhitehouse/code/writing/code/python/test_two_largest.py", line 7, in test_first_two
    self.assertEqual([3,2], two_largest(3,2,1))
AssertionError: Lists differ: [3, 2] != [3, 1]
```

This is better:

```
def two_largest(*nums):
  if nums[1] > nums[0]:
    if nums[2] > nums[1]:
      return [nums[2], nums[1]]
    else:
      return [nums[1], max(nums[2], nums[0])]
  else:
    if nums[0] > nums[2]:
      return [nums[0], max(nums[2], nums[1])]
    else:
      return [nums[0], nums[1]]
```            
    
We have a couple of branches which are not doing a max in the second argument. Is that right? :thinking: 

On line 4, what test case could we select to make it fail?

num1 > num0, and num2 > num1, but the result should be num2, num0. Hmm. That looks like a well-defined ordering num2 > num1 > num0.

What about the last line:

num0 >= num1, and num2 >= num0

so num2 >= num0 >= num1.

So it _should_ be num2, num0.

Let's add a test case 501,500,502. This is the case where it's the first and third and they are out of order.

```
    def test_first_and_last_out_of_order(self):
        self.assertEqual([502, 501], two_largest(501, 500, 502))
```

This test fails (which is good):

```      
Traceback (most recent call last):
  File "/Users/andrewwhitehouse/code/writing/code/python/test_two_largest.py", line 22, in test_first_and_last_out_of_order
    self.assertEqual([502, 501], two_largest(501, 500, 502))
AssertionError: Lists differ: [502, 501] != [501, 500]
```

Correct the last line:

```
def two_largest(*nums):
  if nums[1] > nums[0]:
    if nums[2] > nums[1]:
      return [nums[2], nums[1]]
    else:
      return [nums[1], max(nums[2], nums[0])]
  else:
    if nums[0] > nums[2]:
      return [nums[0], max(nums[2], nums[1])]
    else:
      return [nums[2], nums[0]]
```

This solution has evolved differently to the Clojure solution where we didn't use test-driven development.

```
(defn two-largest [a b c]
  (let [max-a-b (max a b)]
     (if (> c max-a-b)
       [c max-a-b]
       [max-a-b (max (min a b) c)])))
```

In the Clojure example the use of the `max-a-b` changes how we would reason about the correctness of the code.

Let's finish this exercise by adding some more cases.

```
    def test_all_equal(self):
        self.assertEqual([123, 123], two_largest(123, 123, 123))

    def test_negative_numbers(self):
        self.assertEqual([-10, -20], two_largest(-10, -20, -30))
```

The test with negative numbers checks that we're not using the absolute values. (This is a regression test, really, as the code was already doing that. The regression test stops someone breaking it later.)

One more case:

```
    def test_decimals(self):
        self.assertEqual([2.001, 2.0003], two_largest(2.001, 2.0002, 2.0003))
```

Note that the first number is actually larger than the second.

Here is our final set of tests:

`test_two_largest.py `

```
import unittest
from two_largest import *

class TestTwoLargest(unittest.TestCase):

    def test_first_two(self):
        self.assertEqual([3,2], two_largest(3,2,1))

    def test_first_two_out_of_order(self):
        self.assertEqual([3,2], two_largest(2,3,1))

    def test_last_two_largest_in_order(self):
        self.assertEqual([6,5], two_largest(4,6,5))

    def test_last_two_out_of_order(self):
        self.assertEqual([9,8], two_largest(7,8,9))

    def test_first_and_last_in_order(self):
        self.assertEqual([102, 101], two_largest(102, 100, 101))

    def test_first_and_last_out_of_order(self):
        self.assertEqual([502, 501], two_largest(501, 500, 502))

    def test_all_equal(self):
        self.assertEqual([123, 123], two_largest(123, 123, 123))

    def test_negative_numbers(self):
        self.assertEqual([-10, -20], two_largest(-10, -20, -30))

    def test_decimals(self):
        self.assertEqual([2.001, 2.0003], two_largest(2.001, 2.0002, 2.0003))
          
if __name__ == '__main__':
    unittest.main() 
```    

and the implementation:

`two_largest/__init__.py`

```
def two_largest(*nums):
  if nums[1] > nums[0]:
    if nums[2] > nums[1]:
      return [nums[2], nums[1]]
    else:
      return [nums[1], max(nums[2], nums[0])]
  else:
    if nums[0] > nums[2]:
      return [nums[0], max(nums[2], nums[1])]
    else:
      return [nums[2], nums[0]]
```      

and passing tests

```
$ python -m unittest test_two_largest.py 
.........
----------------------------------------------------------------------
Ran 9 tests in 0.000s

OK
$ 
```

@beaver

P.S. Possible feedback points:

1. how engaging is it?
2. does the iterative development process come through clearly?
3. is there enough detail or too much?
4. would it benefit from simplification?
5. what questions does it raise?
'''
'''--- 13-reflection.md ---
**Reflections**

Prompted by @dougmay I have some further reflections on this exercise. 

First of all, how I came up with the scenarios isn't clear.

I'm trying to avoid too much up-front explanation. I find myself reading tech books and getting frustrated. It is the architecture, design and implementation that leads to creating a concrete set of code that delivers value. I understand that authors need to provide some background; I also believe that there is a tendency to pad books with unnecessary detail that wastes the reader's time in the name of adding to the page count.

So I'm figuring out what that balance is.

First of all, let's re-consider the problem statement:

> Define a procedure that takes three numbers as arguments and returns the sum of the squares of the two larger numbers.

So ... three numbers, not an arbitrary number. Also note that there are two main steps in this problem:
1. find two largest numbers
2. return the sum of the square of those numbers

Because the order of values does not matter in addition (they are commutative), it's actually possible to do a simplified solution: remove the smallest number, and sum the other two squared.

By focusing only on the first step, with 3 inputs and a result with a well-defined order (largest first) I've actually introduced more precision than is necessary.

In terms of breaking down the problem

Given a function `two_largest(a,b,c)` we want to return the two largest values like this [largest, second_largest].

To find the largest and second largest we can look at the pairs.

For example:

If a is larger than b, then the largest is either a or c. The second largest depends on the result of the first calculation.

For such a simple problem statement, the number of possible ways of tackling this is surprising.

As I mentioned, there is a solution that involves simply removing the smallest value, and accepting that the order of the two largest items may vary. In that case, a different representation may be needed (a set) I'll explore that in the next post.

I also realised yesterday that Clojure, with its prefix notation, has an elegant way of enumerating the possible solutions:

```
(defn two-largest [a b c]
  (cond
    (>= a b c) [a b]
    (>= b a c) [b a]
    (>= c b a) [a c]
    (>= a c b) [a c]
    (>= b c a) [b c]
    (>= c a b) [c a]))
```

It's easier to check this solution by inspection: are the parameters use in all different permutations, and are we always picking the first two values.

As I was saving this I see a copy-paste error in the third condition. My approaching to test maintenance for this example was less rigorous than the Python example. (I didn't save the tests.) We can guard against that in a long-lived software project by including "quality gates" to ensure that a sufficient portion of our code is actually being exercised by tests.

It's good practice, when you find a bug, to write a test for that code which fails, and then fix it.

Here is the corrected code:

```
(defn two-largest [a b c]
  (cond
    (>= a b c) [a b]
    (>= b a c) [b a]
    (>= c b a) [c b] ; << correction
    (>= a c b) [a c]
    (>= b c a) [b c]
    (>= c a b) [c a]))
```

There are 6 possible ways of organising the 3 variables; by looking at the inequality parameters we see each parameter appears in each "column" twice.

I'll come back to the unordered solution later.

@Beaver

'''
'''--- 14-sicp-in-rust.md ---
[_Background: I'm exploring where my priorities are for this book. It should be able learning to code by solving problems. Getting code working early and then iterating on the solution. And writing tests to help the reader think about the domain, what are good test cases, and break down the problem/solution into small steps so that it doesn't become overwhemling. There is also an opportunity to discover trade offs with different data structures and algorithsm. Also I think that the combination of a "classic" text which avoids focusing on syntax through the use of LISP, with a contemporary language like Rust whose syntax can be quite intimidating but can be tackled bit by bit, could be interesting. I'm not abandoning the Python or Clojure approaches ... simply focusing on this for now. I'm planning on being around for a while!_]

Learning to code by solving problems is an enjoyable way to explore different aspects of a language.

Here is the problem statement from the [Structure and Interpretation of Computer Programmes](https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book.html):

> Exercise 1.3.  Define a procedure that takes three numbers as arguments and returns the sum of the squares of the two larger numbers.

A few initial thoughts come to mind.

Firstly, there are two steps to this, which might be expressed in functions like this:

`sum_of_squares(two_largest(a,b,c))`

Let's tackle the two_largest function first.

In Rust, we have a choice of data structure to return; we could use an array, a tuple, or a set.

What do these look like?

[The principle in this book is to get something working quickly and then iterate on it ... and using tests as guard rails along the way.]

`$ cargo new --lib ex1_3`
`$ cd ex1_3`

`lib.rs`

```
fn two_largest(_a: i32, _b: i32, _c: i32) -> [i32; 2] {
    [0, 0]
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn should_return_first_two_if_in_descending_order() {
        assert_eq!([3, 2], two_largest(3, 2, 1));
    }
}
```

We start with a failing test. [_Add explanation of Test-Driven Development cycle, if this is the first time._]

The Rust compiler complained about our not using the arguments to the function, so we prefix them with an underscore to indicate that we're ignoring them intentionally. The function uses 32-bit integers _i32_; the problem statement doesn't say how large the numbers can be, or whether we would allow float values. Let's assume we're OK with integers for now.

`$ cargo test`

```
$ cargo test --lib
    Finished test [unoptimized + debuginfo] target(s) in 0.00s
     Running unittests (/Users/andrewwhitehouse/code/writing/code/rust/ex1_3/target/debug/deps/ex1_3-dabf7430ba925b35)

running 1 test
test tests::should_return_first_two_if_in_descending_order ... FAILED

failures:

---- tests::should_return_first_two_if_in_descending_order stdout ----
thread 'tests::should_return_first_two_if_in_descending_order' panicked at 'assertion failed: `(left == right)`
  left: `[3, 2]`,
 right: `[0, 0]`', src/lib.rs:11:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

failures:
    tests::should_return_first_two_if_in_descending_order

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
$
```

Starting with a test that fails deliberately helps us to see that changes we have made have fixed the code.

Let's commit our changes [_assume we've already set up git_]

`$ git add .`

`$ git commit -m "Failing test"`

Now we can fix the test in the simplest way possible, by returning the expected values:

```
fn two_largest(_a: i32, _b: i32, _c: i32) -> [i32; 2] {
    [3, 2]
}
```

```
$ cargo test --lib
   Compiling ex1_3 v0.1.0 (/Users/andrewwhitehouse/code/writing/code/rust/ex1_3)
    Finished test [unoptimized + debuginfo] target(s) in 1.53s
     Running unittests (target/debug/deps/ex1_3-dabf7430ba925b35)

running 1 test
test tests::should_return_first_two_if_in_descending_order ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

$
```

Commit the change (`git commit -am "First test passing.`)

Let's add another test case to make our function slightly more flexible:

```
#[test]
fn should_return_first_two_if_in_ascending_order() {
    assert_eq!([3, 2], two_largest(2, 3, 1));
}
```    

Write a failing test, and check that it fails (`cargo test --lib`).

Now add an if condition:

```
fn two_largest(a: i32, b: i32, _c: i32) -> [i32; 2] {
    if a > b { [a, b] } else { [b, a] }
}
```

Rust has optional parentheses around the condition `a > b`, but requires them around the result.

[_to be continued._]

> Other possible options to explore:
- sorting
- have the two_largest function return a set
- don't separate the functions, and observe opportunity for simplificaiton
- how does the solution change if we introduce floats
- note how types (e.g. i32, u32, u128, f64) affect the test cases
- using match in the solution
- using tuples in the solution

> Note to come back to ...

> We could use a `match` in Rust, which some other languages refer to as a switch statement. There are only three numbers so we could enumerate all the possible [permutations](https://en.wikipedia.org/wiki/Permutation) (of which there are 6, or 3 _factorial_, for 3 numbers). 

> Exercises:

> 1. If there were 5 numbers, what would the possible number of permutations be? Which of the solutions would become less appealing?

@beaver
'''
'''--- 15-sicp-clojure-replit.md ---
Square Roots using Newton's Method in Clojure

[_Still practising my Clojure chops as there is a possible interview looming._]

First of all, it's worth noting that Clojure already has a sqrt function available, which is available through Java or [JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math) interop. (We'll cover more in Java interop in a later chapter.)

The purpose of this chapter is to explore building up a solution by composing functions, and to introduce some mathematical [history](https://en.wikipedia.org/wiki/Newton%27s_method#History) through code.

```
$ lein repl
nREPL server started on port 55041 on host 127.0.0.1 - nrepl://127.0.0.1:55041
<snip>

user=> Math/PI
3.141592653589793
user=> (Math/sqrt 2)
1.4142135623730951
user=> ```
```

[_Note, would it be easier if I did these examples in repl.it? Let's try that._]

Go to https://replit.com/~ and sign up (you can login with a Google or other account).

Add image here..

Click Create, search for "clojure" in the search box, and "Create Repl".

You're given a main.clj to work with, which is good for us.

SICP describes it's approach top-down ... in other words by referring to functions that don't yet exist.

Let's do ours bottom up; define functions that we can interact with in the REPL.

Repl.it's approach, as an online tool, is actually a little different to how you would interact with a REPL on your local machine, but it works for our example.

Type in the following code:

```
(defn average [x y]
  (/ (+ x y) 2))

(println (average 3 4))
```

You're about to run this code, but before you do ask yourself what you would expect to see ... hopefully 3.5(?).

When you click the green Run button the REPL will take some time to download dependencies and start the runtime environment; then you should see:

```
> clojure -M main.clj
7/2
> 
```

Hmm. What's going on here?

Let's replace our print line:

```
(def result (average 3 4))

(println (type result) result)
```

Try it. What do you see? 

There are a couple of things going on here.

Clojure is running on top of the Java runtime.

If we were to calculate the average in Java it would look something like this:

```
class Main {
  public static void main(String[] args) {
    System.out.println((3 + 4) / 2);
  }
}
```

If you use integer values in a calculation, Java infers that you want an integer result, and so drops any fractional part. You can correct this by converting one of the values to a float, and then Java implicitly converts the expression to use floats.

```
class Main {
  public static void main(String[] args) {
    System.out.println((3 + 4) / 2.0);
  }
}
```

Clojure takes a different approach, and returns a [Ratio](https://clojure.org/reference/data_structures) of the integers, reduced to it's simpest form.

[_As an aside, note that we need the extra brackets in the calculation `(3+4)/2` because the `/` operator has higher precedence than '+'. Without the brackets, the calculation `3+4/2` would be intrepreted as '4/2' plus '3', or '5'_]

To obtain the result as a float, you convert one of the values to a float as in Java:

```
(defn average [x y]
  (/ (+ x y) 2.0))

(def result (average 3 4))

(println (type result) result)
```

In your Repl.it console you should see:

```
> clojure -M main.clj
java.lang.Double 3.5
> 
```

The `good-enough` function uses abs and square.

Let's define these and call them.

```
(defn average [x y]
  (/ (+ x y) 2.0))

(def result (average 3 4))

(println (Math/abs 2.3) (Math/abs -2))

(defn square [x] (* x x))

(println (square 2.2) (square 5))

(println (type result) result)
```

Output:

```
> clojure -M main.clj
2.3 2
4.840000000000001 25
java.lang.Double 3.5
> 
```

```
(defn good-enough? [guess x]
  (< (Math/abs (- (square guess) x)) 0.001))
```

[_Note that LISP functions allow the use of question marks, which are useful when defining functions that provide some sort of conditional logic, known as a "predicate"_]

How can we call this function? We want to know if the guess is good enough as an approximation for the square root of x.

```
(defn average [x y]
  (/ (+ x y) 2.0))

(def result (average 3 4))

(comment println (Math/abs 2.3) (Math/abs -2))

(defn square [x] (* x x))

(comment println (square 2.2) (square 5))

(comment println (type result) result)

(defn good-enough? [guess x]
  (< (Math/abs (- (square guess) x)) 0.001))

(println (good-enough? 2.2 4.84))
```

I've commented out some of the unused code to reduce the noise in the output. You can delete it too. Repl.it supports Control-Z (or CMD-Z on a Mac) for undo, and Shift-Control-Z for redo.

Call your function with different parameters to make it return both true and false.

Here's how my REPL looks at the end of this session.

![REPL view](./images/15-repl.png)

TODO:

- 
[_Update this example to demonstrate REPL-driven development._]
'''
'''--- 16-clojure-wallet.md ---
**Domain-Driven Design in Clojure**

and possibly Rust 

for Fun and Profit.

I took a tech test a while ago. I didn't get the role because I haven't been doing the specific things they wanted me to do. Afterwards I thought that it was harder work that it needed to be and the framework (Java/Spring) feels rather dogmatic to me.

As you may have noticed there's some tension between my maintaining the skills I need to do my day job (supporting a family as a fairly well paid developer) and the things that indulge my playful side.

I tried the Advent of Code problems. They're OK, but I don't think developers are looking to those as a way of gaining job-relevant skills. (Maybe they are, but there's the competitive coding side which is somewhat of a distraction.)

I use domain-driven design in my day job. So it seems logical to use that. 

I also thought how I can frame this project. Blockchain is an area I see growing and I want to get up to speed with that ... aiming for where people are heading.

And I thought: Clojure and Rust are the two [most loved](https://insights.stackoverflow.com/survey/2021#technology-most-loved-dreaded-and-wanted) languages on Stack Overflow. I know one, and I'm learning the other.

Perhaps it's a centralised vs decentralised theme.

I considered a word guessing game like Wordle: centralised and decentralised.

Or I could look at the blockchain applications people have built and build a server-based version first.

For now, I'm going to focus on a wallet implementation. I might do this in Clojure and Spring Boot to show those Java people (and I have a foot in that camp) what a great language and ecosystem Clojure is.

---

Create a sample app.

`lein new compojure wallet`

With the default Compojure app, you start it with `lein ring server`. I want to run it as a main function, so I'm going to add [Jetty](https://www.eclipse.org/jetty/).

Project dependencies live in `project.clj` so update this to include the Jetty adapter.

```
(defproject wallet "0.1.0-SNAPSHOT"
  :description "FIXME: write description"
  :url "http://example.com/FIXME"
  :min-lein-version "2.0.0"
  :dependencies [[org.clojure/clojure "1.10.0"]
                 [compojure "1.6.1"]
                 [ring/ring-defaults "0.3.2"]
                 [ring/ring-jetty-adapter "1.9.5"]]
  :plugins [[lein-ring "0.12.5"]]
  :ring {:handler wallet.handler/app}
  :main wallet.core
  :profiles
  {:dev {:dependencies [[javax.servlet/servlet-api "2.5"]
                        [ring/ring-mock "0.3.2"]]}})
```
        
Create a `core.clj` which is where our main usually lives:

```
(ns wallet.core
  (:require [wallet.handler :refer [app]]
            [ring.adapter.jetty :as jetty]))

(defn -main
  [& args]
  (let [port (or (System/getenv "PORT") 3000)]
    (log/info "Listening on port" port)
    (jetty/run-jetty app
                     {:port port
                      :join? true})))
```

Note that I added code which allows you to set the port on which the server listens.

```
$ PORT=8000 lein run
2022-05-31 19:29:22.948:INFO::main: Logging initialized @3612ms to org.eclipse.jetty.util.log.StdErrLog
Listening on port 8000
2022-05-31 19:29:23.036:INFO:oejs.Server:main: jetty-9.4.44.v20210927; built: 2021-09-27T23:02:44.612Z; git: 8da83308eeca865e495e53ef315a249d63ba9332; jvm 11.0.7+10-LTS
2022-05-31 19:29:23.102:INFO:oejs.AbstractConnector:main: Started ServerConnector@55d776ac{HTTP/1.1, (http/1.1)}{0.0.0.0:8000}
2022-05-31 19:29:23.103:INFO:oejs.Server:main: Started @3767ms
```

This is the existing request handler

```
(ns wallet.handler
  (:require [compojure.core :refer :all]
            [compojure.route :as route]
            [ring.middleware.defaults :refer [wrap-defaults site-defaults]]))

(defroutes app-routes
  (GET "/" [] "Hello World")
  (route/not-found "Not Found"))

(def app
  (wrap-defaults app-routes site-defaults))
```

Let's use Heroku to deploy it for now. [Instructions](https://devcenter.heroku.com/articles/getting-started-with-clojure?singlepage=true).

Follow the instructions to install Heroku and login.

Create an app on Heroku

`$ heroku create`

```
$ heroku create
Creating app... done, ⬢ protected-reef-78839
https://protected-reef-78839.herokuapp.com/ | https://git.heroku.com/protected-reef-78839.git
$ 
```

```
$ git remote -v
heroku	https://git.heroku.com/protected-reef-78839.git (fetch)
heroku	https://git.heroku.com/protected-reef-78839.git (push)
. . .
```

```
$ git push heroku main
Enumerating objects: 22, done.
Counting objects: 100% (22/22), done.
Delta compression using up to 8 threads
Compressing objects: 100% (16/16), done.
Writing objects: 100% (22/22), 2.54 KiB | 1.27 MiB/s, done.
Total 22 (delta 3), reused 0 (delta 0)
remote: Compressing source files... done.
remote: Building source:
remote: 
remote: -----> Building on the Heroku-20 stack

. . .

remote:        Retrieving ring/ring-servlet/1.9.5/ring-servlet-1.9.5.jar from clojars
remote:        Compiling wallet.core
remote:        2022-05-31 18:35:47.001:INFO::main: Logging initialized @5712ms to org.eclipse.jetty.util.log.StdErrLog
remote:        Compiling wallet.handler
remote: -----> Discovering process types
remote:        Procfile declares types     -> (none)
remote:        Default types for buildpack -> web
remote: 
remote: -----> Compressing...
remote:        Done: 94M
remote: -----> Launching...
remote:        Released v3
remote:        https://protected-reef-78839.herokuapp.com/ deployed to Heroku
remote: 
remote: Verifying deploy... done.
To https://git.heroku.com/protected-reef-78839.git
 * [new branch]      main -> main
$
```

If you browse to the page, you should see "Hello World".

and you would see "Hello World".

But it's not very impressive yet. Let's make the message more relatable.

When I run locally I don't always want to specify the port, and my logic wasn't quite right for when I run it locally.

```
(defn -main
  [& args]
  (let [env-port (System/getenv "PORT")
        selected-port (if env-port (Integer/parseInt env-port) 3000)]
    (println "Listening on port" selected-port)
    (jetty/run-jetty app
                     {:port selected-port
                      :join? true})))
```

And change the handler.

```
(defn wallet-markup []
  (let [url "https://www.fjallraven.com/496026/globalassets/catalogs/fjallraven/f7/f773/f77307/f249/7323450091569_ss18_a_oevik_wallet_21.jpg?width=120&height=120&mode=BoxPad&bgcolor=fff&quality=80"]
    (str
      "<img src=\"" url "\" alt=\"This is not a wallet\">"
      "<p>This is not a wallet</p>")))

(defroutes app-routes
  (GET "/" [] (wallet-markup))
  (route/not-found "Not Found"))
```

I tested it locally.

Let's push to Heroku.  And browse to the [application page](https://protected-reef-78839.herokuapp.com/). Hat tip to René Magritte.

@Beaver
'''
'''--- 17-pairing-exercise.md ---
**Pairing Exercise: The Berlin Clock.**

Here is the [description](https://en.wikipedia.org/wiki/Mengenlehreuhr) of the clock's behaviour. 

>**Example:** Two fields are lit in the first row (five hours multiplied by two, i.e. ten hours), but no fields are lit in the second row; therefore the hour value is 10. 
Six fields are lit in the third row (five minutes multiplied by six, i.e. thirty minutes), while the bottom row has one field on (plus one minute). Hence, the lights of the clock altogether tell the time as 10:31. (Source: Wikipedia: https://en.wikipedia.org/wiki/Mengenlehreuhr)
>
>**Task**: Write a function that takes in a particular time as 24h format ('hh:mm:ss') and outputs a string that reproduces the Berlin Clock. The parameters should be as follows:
>
>“O” = Light off
>“R” = Red light
>“Y” = Yellow light
>
>**Example Test Case** (this does not correspond to the image above)
Input String:  12:56:01
>
>Output String: O RROO RROO YYRYYRYYRYY YOOO

The interviewer didn't state what the process should be. But test-driven development is a good way to identify scenarios and then implement them progressively.

Let's create a project:

`lein new berlin-clock`

This is the project structure:

```
.
└── berlin-clock
    ├── CHANGELOG.md
    ├── LICENSE
    ├── README.md
    ├── doc
    │   └── intro.md
    ├── project.clj
    ├── resources
    ├── src
    │   └── berlin_clock
    │       └── core.clj
    └── test
        └── berlin_clock
            └── core_test.clj
```

Leiningen gives you one source file to start with (core.clj) and one test. That works for us, since we're required to implement a single function.

Based on the problem statement, our function takes an input string, and outputs a string too.

Let's creating a failing test based on the example:

`core.clj`

```
(defn berlin-clock [time] "")
```

`core_test.clj`

```
(deftest test-initial-case
  (testing "12:56:01"
    (is (= "O RROO RROO YYRYYRYYRYY YOOO" (berlin-clock "12:56:01")))))
```

`$ lein test`

```
$ lein test

lein test berlin-clock.core-test

lein test :only berlin-clock.core-test/test-initial-case

FAIL in (test-initial-case) (core_test.clj:7)
12:56:01
expected: (= "O RROO RROO YYRYYRYYRYY YOOO" (berlin-clock "12:56:01"))
  actual: (not (= "O RROO RROO YYRYYRYYRYY YOOO" ""))

Ran 1 tests containing 1 assertions.
1 failures, 0 errors.
Tests failed.
$ 
```
           
Now let's fix it.

I decided that it wouldn't be sensible to try an implement all the logic in the test case, as it could be challenging to accomplish that within the 45 minutes.

So I opted for a simpler test case.

`core_test.clj`

```
(deftest test-initial-case
  (comment testing "12:56:01"
    (is (= "O RROO RROO YYRYYRYYRYY YOOO" (berlin-clock "12:56:01"))))

  ( testing "midnight"
    (is (= "O OOOO OOOO OOOOOOOOOOO OOOO" (berlin-clock "00:00:00"))))
```

Lining up my new test case with the original I can see that I have the right number of characters. I did initially type zeroes instead of oh's, which one of my "buddies" helpfully pointed out. 

The simplest way to get this passing is to hard-code the return value.

```
(defn berlin-clock [time]
  "O OOOO OOOO OOOOOOOOOOO OOOO")
```

Test passes ...

![Screenshot 2022-06-04 at 08.53.10|690x392](upload://6u6YEekkgJgiHUSIUfnoIOzw6lF.png)

Right now we have a function that works, but only for a _very_ limited set of inputs; if our requirement was to implement a Berlin Clock that returns the correct value for midnight, then we would be done. But it would be correct only once per day (for a second).

(By the way, I commit the updates to version control after every cycle of add failing test / make test pass. Possibly after a refactor too so I can see if I've broken something (and perhaps missed a test case which didn't highlight the issue).

I added a comment at the top of the file to remind me which block is which:

```
;; O OOOO OOOO OOOOOOOOOOO OOOO
;; ^ seconds
;;   ^^^^ every 5 hours
;;        ^^^^ single hours
;;             ^^^^^^^^^^^ minutes
;; 
```

(actually the last line should say "every 5 minutes")

Initially I thought I could simply add an `if` to the implementation:

```
(defn berlin-clock [time]
  (if (= "00:00:00" time)
    "O OOOO OOOO OOOOOOOOOOO OOOO"
    nil))
```

to create a place for the alternate logic.

Here is the test:

```
( testing "5 hours blocks"
    (is (= "O ROOO OOOO OOOOOOOOOOO OOOO" (berlin-clock "05:00:00"))))
```

An a possible implementation:    

```
(defn time-to-clock [:keys [seconds ]]
  {})

(defn berlin-clock [time]
  (let [[hours mins seconds] (map #(Integer/parseInt %) (str/split time #":"))]
    (cond
      (and (zero? hours) (zero? mins) (zero? seconds))
        "O OOOO OOOO OOOOOOOOOOO OOOO"
      (= hours 5)
        "O ROOO OOOO OOOOOOOOOOO OOOO")))
```

Running the test showed me that I had a syntax error in the time-to-clock function, and I wasn't using it, so I deleted it.

```
(ns berlin-clock.core
  (:require [clojure.string :as str]))

(defn berlin-clock [time]
  (let [[hours mins seconds] (map #(Integer/parseInt %) (str/split time #":"))]
    (cond
      (and (zero? hours) (zero? mins) (zero? seconds))
      "O OOOO OOOO OOOOOOOOOOO OOOO"
      (= hours 5)
      "O ROOO OOOO OOOOOOOOOOO OOOO")))
```

I realised that I was going to need to do some conditional logic based on the elements of the time, and having them as numeric (integer) values would be most helpful.

So I imported the `clojure.string` library for the `split` funciton, using the `:` as the separator. 

_As this point, I was around 20 minutes into the pairing exercise, including a few minutes at the beginning to scan the problem statement. Having figured out a sensible structure for the implementation, and seeing that you having misunderstood the problem statement, it becomes easier to add more test cases._ 

**Explanation** This will return a vector of 3 elements

```
berlin-clock.core=> (require '[clojure.string :as str])
nil
berlin-clock.core=> (str/split "12:56:01" #":")
["12" "56" "01"]
berlin-clock.core=> 
```

which we can then map over to convert to integers.

```
berlin-clock.core=> (map #(Integer/parseInt %) (str/split "12:56:01" #":"))
(12 56 1)
berlin-clock.core=>
```

Lastly we can destructure the list elements returned by map:

```
berlin-clock.core=>   (def time "12:56:01")
#'berlin-clock.core/time
berlin-clock.core=>   (let [[hours mins seconds] (map #(Integer/parseInt %) (str/split time #":"))]
               #_=>     (println "hours" hours "minutes" mins "seconds" seconds))
hours 12 minutes 56 seconds 1
nil
berlin-clock.core=>
```

I keep this REPL code in a comment block in the implementation file as it's more convenient for editing.

```
(comment

  (def time "12:56:01")
  (let [[hours mins seconds] (map #(Integer/parseInt %) (str/split time #":"))]
    (println "hours" hours "minutes" mins "seconds" seconds))

  )
```

While coding this, I updated the comment in the implementation file to correct it:

```
;; O OOOO OOOO OOOOOOOOOOO OOOO
;; ^ seconds
;;   ^^^^ every 5 hours
;;        ^^^^ single hours
;;             ^^^^^^^^^^^ 5 minute blocks
;;                         ^^^^ single minutes
```

Now let's add the other 5-hour test cases:

```
( testing "5 hours blocks"
    (is (= "O ROOO OOOO OOOOOOOOOOO OOOO" (berlin-clock "05:00:00")))
    (is (= "O RROO OOOO OOOOOOOOOOO OOOO" (berlin-clock "10:00:00")))
    (is (= "O RRRO OOOO OOOOOOOOOOO OOOO" (berlin-clock "15:00:00")))
    (is (= "O RRRR OOOO OOOOOOOOOOO OOOO" (berlin-clock "20:00:00"))))
```

I recognises that it would be useful to have a function to convert the hour value to the possible 5-hour values: "OOOO", "ROOO", "RROO", "RRRO" and "RRRR".

Here was my first stab:

```
(defn to-clock-5-hour-segments [hour]
  (str
    (if (>= hour 5) "R" "O")
    (if (>= hour 10) "R" "O")
    (if (>= hour 15) "R" "O")
    (if (>= hour 10) "R" "O")))
```

One of my buddies pointed out the copy-and-paste error on the last line. I fixed the 15 case, but not the 20.

This is combining four single-letter strings whose values are based on whether we have crossed a particular threshold.

I knew this wasn't the "best" implementation, as it's fairly repetitive, but it is clear. And I could come back and refactor later (which I vocalized during the interview).

Here is the updated implementation which makes the tests pass:

```
(defn to-clock-5-hour-segments [hour]
  (str
    (if (>= hour 5) "R" "O")
    (if (>= hour 10) "R" "O")
    (if (>= hour 15) "R" "O")
    (if (>= hour 20) "R" "O")))

(defn berlin-clock [time]
  (let [[hours mins seconds] (map #(Integer/parseInt %) (str/split time #":"))]
    (cond
      (and (zero? hours) (zero? mins) (zero? seconds))
      "O OOOO OOOO OOOOOOOOOOO OOOO"
      :else
      (str "O" " "
           (to-clock-5-hour-segments hours) " "
           "OOOO OOOOOOOOOOO OOOO"))))
```               

The new function is generating part of the output string dynamically, and we are using `str` to combine it with the other hard-coded parts of the string.

_Roughly 30 minutes elapsed._

I'm taking a break now, and will add the rest in my next post.

@beaver
'''
'''--- 18-aoc2021-in-go.md ---
**Advent of Code in Go**

I'm looking at Go for my next language. It seems to hit the sweet spot of performance and simplicity. Also I see more startups using it as a pragmatic way to get stuff delivered, and the contract market is reasonable.

My current go-to challenges are Advent of Code.

Let's start with Day 1, which is about a submarine, and counting increasing depths.

[If you don't already have go installed, follow the [online instructions](https://go.dev/doc/install). 

The setup is minimal: create a directory.

`$ mkdir aoc2021`

[_Note to self: be clear on typographical conventions so I don't have too much re-work later. e.g. the O'Reilly books tend to get this out of the way early on and I skip over it generally, but it's helpful to have clarity._]

I'm going to launch into the code, and avoid too much pre-amble.

Start with a failing test.

I'm assuming it's OK to organise the code as a package for each day.

The AOC page provides a sample set of input data, and the expected output. 

`day1_test.go`

```
package day1
  
import "testing"

func TestSum(t *testing.T) {
    depths := []int16{199, 200, 208, 210, 200, 207, 240, 269, 260, 263}
    expected := 7
    actual := CountIncreases(depths)
    if expected != actual {
       t.Errorf("CountIncreases was incorrect, got: %d, want: %d.", actual, expected)
    }
}
```

`day1.go`

```
package day1
  
func CountIncreases(depths []int16) int {
    return 0
}
```

[_Things that stang out: exported functions are written in _CapsCase_, and the type declaration comes after the variable or function definition, although array brackets come before. Using `go fmt` provides consistency of formatting, and seems to prefer using tabs for indentation. So set your tabstop to something sensible. I'm more accustomed to using spaces in my code, actually, and configure the editor to convert tabs to spaces._]

Related:

https://www.youtube.com/watch?v=SsoOG6ZeyUI

```
$ go test
--- FAIL: TestSum (0.00s)
    day1_test.go:10: CountIncreases was incorrect, got: 0, want: 7.
FAIL
exit status 1
FAIL	_/Users/andrewwhitehouse/code/active-projects/writing/code/go/aoc2021	0.005s
$
```

Implementation:

```
func CountIncreases(depths []int16) int {
    var increases int = 0
    for i := 1; i < len(depths); i++ {
        if depths[i] > depths[i-1] {
            increases++
        }
    }
    return increases
}
```

Run the test again, and you should see that it passes.

Array indices start at 0. We start at index 1 (the second element) and compare each element with the previous one; if it's greater we increment our `increases` counter.

**Exercises:**

1. Go has a form of [short variable declaration](https://go.dev/ref/spec#Short_variable_declarations). Replace the declaration starting with `var` with its short form equivalent.

2. What are range of values you can store in an int16?

This programme may help:

```
package main
  
import (
        "fmt"
        "math"
)

func main() {
        fmt.Println(math.MaxInt16)
        fmt.Println(math.MinInt16)
}
```

Run it with `go run <filename.go>`

3. Can you think of a better return type for `CountIncreases` assuming that the function will never receive an array with fewer than 10,000 elements? Hint: can the return value ever be negative? 

Change the implementation and re-run the test with `go test`.

[details="Answer"]

1. `increases := 0`

2. 32767, -32768

3.

```
func CountIncreases(depths []int16) uint16 {
    var increases uint16 = 0
    for i := 1; i < len(depths); i++ {
        if depths[i] > depths[i-1] {
            increases++
        }
    }
    return increases
}
```

```
func TestSum(t *testing.T) {
    depths := []int16{199, 200, 208, 210, 200, 207, 240, 269, 260, 263}
    var expected uint16 = 7
    actual := CountIncreases(depths)
    if expected != actual {
       t.Errorf("CountIncreases was incorrect, got: %d, want: %d.", actual, expected)
    }
}
```

[/details]

**Note**: I had some strange goings on while exploring this problem. In my normal terminal window running the tests works fine. But when I fire it up from a terminal window within *Golang* (Jetbrain's Go IDE) I see an error.

```
$ go test
go: cannot find main module, but found .git/config in /Users/andrewwhitehouse/code/active-projects/writing/code/go/aoc2021
        to create a module there, run:
        go mod init
$
```

It seems to be related to the environment variables:

In Goland:

```
$ which go
/usr/local/opt/go/libexec/bin/go
$ 
```

```
$ env | grep go
PATH=/usr/local/opt/go/libexec/bin:/Users/andrewwhitehouse/go/bin:...
. . .
GOROOT=/usr/local/opt/go/libexec
GOPATH=/Users/andrewwhitehouse/go
$ 
```

Outside of Goland:

```
$ which go
/usr/local/bin/go
$

I'm not yet sure why this is happening, or what the "correct" settings should be.

@beaver
'''
'''--- 19-project-organisation.md ---
**Project Oroganisation**

When I started solving the Advent of Code problems in Rust I organised the directory like this:

```
.
├── Cargo.toml
├── input
│   ├── day1.txt
│   └── day2.txt
└── src
    ├── day1.rs
    ├── day2.rs
    ├── day3.rs
    └── main.rs
```

I see there are being two sets of executable deliverables here: the daily implementation files (day1.rs, day2.rs, ...) each with its own tests, and the `main.rs` which brings all the implementations together and runs them on the actual problem data set.

It helps that the Rust tests and implementation are combined into the single file, as it simplifies code organisation.

[_I was reviewing the previous Rust code I wrote and I think it's harder to follow when showing only the code fragments; I need to remember to show the directory structure, and also (probably) to show the full set of code at the end._]

Go's organisation is different.

I battled with this for a while. Go enforces a directory structure that matches your package naming. 

To illustrate this let's setup a project, following [How to Write Go Code](https://go.dev/doc/code).

Go now uses the concept of modules for code organisation.

To start with you need your Go environment set up; there are three key variables that apply:

**GOROOT** is set to where Go is installed on your machine (mine is `/usr/local/go/`).

**GOPATH** is the locally of your locally built Go files. Actually, you don't have to set this; [since Go 1.11 this is defaulted](https://stackoverflow.com/questions/21001387/how-do-i-set-the-gopath-environment-variable-on-ubuntu-what-file-must-i-edit/53026674#53026674) to your home directory.

**Project Setup**

`$ mkdir aoc2021`

`$ cd aoc2021`

`$ go mod init aoc2021`

```
$ cat go.mod
module aoc2021

go 1.18
$
```

Some of the examples use project locations that reference github, like `github.com/andrewwhitehouse/aoc2021`; this seems excessive to me. I understand that it's helpful to have a uniform way of accessing all of your stuff, but I see this as a self-contained project which -- right now -- isn't likely to be imported into other projects. So I'm going to keep the names shorter and skip the `github.com/username` part.

Create a main "hello world" file:

`main.go`

```
package main

import "fmt"

func main() {
    fmt.Println("Hello, world.")
}
```

```
$ go run main.go
Hello, world.
$
```

For each daily challenge, I'm going to create a test file and an implementation file in Go.

To start with I tried putting these at the top-level of the project.

`day1.go`

```
package day1

func CountIncreases(depths []int16) uint16 {
    return 0 // Not yet implemented
}
```

`day1_test.go`

```
```

When I run my tests I see:

```
$ go test
found packages day1 (day1.go) and main (main.go) in . . ./code/go/aoc2021
$
```

Then I tried putting them in the `main` package.

That exercises the tests correctly

```
$ go test
--- FAIL: TestCountIncreases (0.00s)
    day1_test.go:10: CountIncreases was incorrect, got: 0, want: 7.
FAIL
exit status 1
FAIL	aoc2021	0.005s
$ 
```

If we update main.go to call the function:

```
package main
  
import "fmt"

func main() {
    fmt.Println(CountIncreases([]int16{1,2,3}))
}
```

This works (adding the directory name):

```
$ go run .
0
$
```

but this doesn't

```
$ go run main.go
# command-line-arguments
./main.go:6:17: undefined: CountIncreases
$
```

With all of the functions in the `main` package I can see that it could become hard to follow which functions are for which day (unless I include the day name in the function name, e.g. `Day1CountIncreases`. 

But I think using packages is better.

To fix the earlier issue we put the different packages in their own folder.

```
.
├── day1
│   ├── day1.go
│   └── day1_test.go
├── go.mod
└── main.go
```

`day1.go`

```
package day1
  
func CountIncreases(depths []int16) uint16 {
    return 0 // Not yet implemented
}
```

`day1_test.go`

```
package day1
  
import "testing"

func TestCountIncreases(t *testing.T) {
        depths := []int16{199, 200, 208, 210, 200, 207, 240, 269, 260, 263}
        var expected uint16 = 7
        actual := CountIncreases(depths)
        if expected != actual {
                t.Errorf("CountIncreases was incorrect, got: %d, want: %d.", actual, expected)
        }
}
```

`main.go`

```
package main
  
import (
        "fmt"
        "aoc2021/day1"
)

func main() {
    fmt.Println(day1.CountIncreases([]int16{1,2,3}))
}
```

To run the tests, you need to be in the sub-folder.

```
$ go test
?   	aoc2021	[no test files]
You have mail in /var/mail/andrewwhitehouse
Andrews-MacBook-Pro:tmp andrewwhitehouse$
```

```
$ cd day1
$ go test
--- FAIL: TestCountIncreases (0.00s)
    day1_test.go:10: CountIncreases was incorrect, got: 0, want: 7.
FAIL
exit status 1
FAIL	aoc2021/day1	0.005s
$ 
```

Here are the files now:

`main.go`

```
package main
  
import (
    "aoc2021/day1"
    "fmt"
)

func main() {
    fmt.Println(day1.CountIncreases([]int16{1, 2, 3}))
}
```

`day1/day1.go`

```
package day1
  
func CountIncreases(depths []int16) uint16 {
    return 0 // Not yet implemented
}
```

`day1/day1_test.go`

```
package day1
  
import "testing"

func TestCountIncreases(t *testing.T) {
    depths := []int16{199, 200, 208, 210, 200, 207, 240, 269, 260, 263}
    var expected uint16 = 7 
    actual := CountIncreases(depths)
    if expected != actual {
        t.Errorf("CountIncreases was incorrect, got: %d, want: %d.", actual, expected)
    }   
}
```

I'm running `go fmt` regularly on the files to make sure that the formatting is consitent. It uses tabs for indentation, and then I set my `tabstop` to 4 in the editor.

[_With this arrangement I want a way to run all the tests, and am still figuring ouw how to do this._]

```
$ go run .
0
$ go run main.go
0
$
```

Fix the implementation:

```
package day1
  
func CountIncreases(depths []int16) uint16 {
    var increases uint16 = 0
    for i := 1; i < len(depths); i++ {
        if depths[i] > depths[i-1] {
            increases++
        }
    }
    return increases
}
```

In the day1 folder ...

```
$ go test
PASS
ok  	aoc2021/day1	0.005s
$
```

In the top-level project folder ...

```
$ go run main.go
2
$
```

'''
'''--- 20-designing-incentives.md ---
**Designing Incentives**

We converted one of the downstairs room to add a bed, which will help to ease pressure when the younger family members are back from university.

An ad hoc gathering this morning of me, three daughters and my partner started off talking about uni exploits and ended up talking about career choices.

Topics covered: how tech companies do a good or not-so-good job of making their companies appealing places for women to work. And how to promote cross-team engagement. It's harder now when more people are remote.

And how managers need to know the law. A company I worked for ended up paying an employee £30 to leave after his initial manager didn't perform regular performance assesments and when, his new manager became more proctive he went off sick and claimed he was being discriminated against

And taking time off work to have children could put you at a disadvantage. 

And being in a minority can be harder when you encounter unacceptable behaviour. But there are companies who do it better, so look out for those.

For our daughter studying psychology who is doing an internship in a tech company, I asked her what might interest her in clinicical psychology versus the work experience she's doing.

And we talked about how tech products are designed, and alignment of incentives.

This is more a reminder of themses that I will likely come back to.

* [Center for Humane Technology](https://www.humanetech.com/course)
* [80,000 hours](https://80000hours.org/)
* [Hooked: How to build habit-forming producys](https://www.nirandfar.com/hooked/) - important to do this in the right way

Reading List:

* [Tokenising behaviour change: optimising blockchain
technology for sustainable transport interventions](https://arxiv.org/pdf/2104.01852.pdf)
* [Tokenizing Behavior Change: A Pathway for the Sustainable Development Goals](https://www.frontiersin.org/articles/10.3389/fbloc.2021.730101/full)
* [Blockchain Adoption and Digital Privacy](https://medium.com/mit-cryptoeconomics-lab/blockchain-adoption-and-digital-privacy-b94210122021)
* [The Cold Start Problem: How to Start and Scale Network Effects
](https://a16z.com/book/the-cold-start-problem/)

'''
'''--- 21-completing-part1.md ---
**Parsing a file, and Completing Part 1**

The Advent of Code puzzles each follow a particular pattern:

- there is some domain logic to solve the puzzle based on a set of rules that have been provided for us
- input data is provided in a file 
- there are two parts to each day's puzzle; the second part isn't revealed until you have solved the first part and so it may involve some refactoring (that's one of the reasons why having tests is a good idea)

Currently we have a unit test which exercises our CountIncreases function.

We need to add some parsing logic to take the input and convert it to a form that is useful for our domain logic.

Add the following files:

`day1/parse.go`

```
package day1

import (
	"strconv"
	"strings"
)

func sliceAtoi(sa []string) ([]uint16, error) {
	si := make([]uint16, 0, len(sa))
	for _, a := range sa {
		i, err := strconv.Atoi(a)
		if err != nil {
			return si, err
		}
		si = append(si, uint16(i))
	}
	return si, nil
}

func Parse(content string) ([]uint16, error) {
	sliceData := strings.Split(strings.TrimSpace(content), "\n")
	return sliceAtoi(sliceData)
}
```

`day1/parse_test.go`

```
package day1

import (
	"reflect"
	"testing"
)

func TestParseInput(t *testing.T) {
	actual, err := Parse("11\n13\n17\n19\n301")
	expected := []uint16{11, 13, 17, 19, 301}
	if err != nil {
		t.Error(err)
	}
	if !reflect.DeepEqual(actual, expected) {
		t.Errorf("Parse was incorrect, got: %v, want: %v.", actual, expected)
	}
}
```

Run the tests with `go test`.

The parse function takes as its parameter the input, and returns an array of uint16 integers, as well as an error.

Create a function in `day1.go` that brings the pieces together:

`day1.go`

```
func Part1(content string) (uint16, error) {
	values, err := Parse(content)
	if err != nil {
		return 0, err
	}
	return CountIncreases(values), nil
}
```

`day1_test.go`

```
func TestIntegration(t *testing.T) {
	actual, _ := Part1("199\n200\n208\n210\n200\n207\n240\n269\n260\n263")
	expected := uint16(7)
	if expected != actual {
		t.Errorf("Part1 was incorrect, got: %d, want: %d.", actual, expected)
	}
}
```

Starting a function name with a capital letter exports it so that it can be imported by other packages.

This test checks that the two components -- parsing and domain logic -- work together correctly.

These tests actually overlap. To see this, temporarily change the result from `CountIncreases` to return an invalid value (for example: 0). How many tests fail?

Ideally we would want a test failure to help us identify where the issue is, but right now it could be in two places. (In this case, I would think about the dependencies -- what is calling what -- and start debugging the code that is common to both.)

There are other ways of writing tests that allow us to be more targeted, and we'll look at those in future chapters.

To finish part 1, we want to load the input data that has been provided for us.

The file contains 2000 lines, and starts like this:

```
176
184
196
199
204
206
```

Create a directory called `input` under the top level of your project directory, and save `day1.txt` into it.

Then add a helper function in `main.go` to load the file:

```
func loadContent(fileName string) string {
	fileBytes, err := ioutil.ReadFile(fileName)

	if err != nil {
		fmt.Println(err)
		os.Exit(1)
	}

	return string(fileBytes)
}
```

I also added a function to contain the logic for solving day 1

```
func solveDay1() {
	content := loadContent("input/day1.txt")
	part1Result, err := day1.Part1(content)
	if err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
	fmt.Printf("Day 1 Part 1 %d\n", part1Result)
}
```

It's possible that the day 1 processing could fail, if we accidentally corrupted the input data, so we should check the return value (and even add a test for it if this code is going to be long-lived or shared with others).

The imports need to be updated too:

```
import (
	"aoc2021/day1"
	"fmt"
	"io/ioutil"
	"os"
)
```

Finally update your main function in `main.go` to call `solveDay1()`.

In the top level directory of your project run the code:

```
$ go run main.go
Day 1 Part 1 <result>
$ 
```

**Exercises**

1. Change the input data, temporarily, by adding a line containing a non-numeric value. What happens? 
2. What happens if you make one of the values a non-integer value, like `123.456`? 
3. Change the name of the file loaded in `solveDay1()` and see what happens when you run the programme.
4. What does the call to `strings.TrimSpace(content)` do in `Parse()`? What happens if you replace that with `content` and add some blank lines to the end of `day1.txt`?

[details="Answer"]

1. You should see an error complaining about the value you have added
2. Another error reporting on the bad value
3. A different error indicating that the programme cannot find the file
4. It removes leading and trailing spaces (see the [Go docs](https://pkg.go.dev/strings#TrimSpace).
[/details]

Observations:

- Go returns success and error results explicitly from functions; you should generally check for errors especially if your input data is going to vary
- Exported functions begin with a capital letter
- Running `go test -test.v` prints the test names as they are run

@beaver
'''
'''--- 22-sliding-window.md ---
**Sliding Windows**

For part 2 we are asked to adapt the solution to use a sliding window.

>Considering every single measurement isn't as useful as you expected: there's just too much noise in the data.
>
>Instead, consider sums of a three-measurement sliding window. Again considering the above example:
>
```
199  A      
200  A B    
208  A B C  
210    B C D
200  E   C D
207  E F   D
240  E F G  
269    F G H
260      G H
263        H
```
>Start by comparing the first and second three-measurement windows. The measurements in the first window are marked A (199, 200, 208); their sum is 199 + 200 + 208 = 607. The second window is marked B (200, 208, 210); its sum is 618. The sum of measurements in the second window is larger than the sum of the first, so this first comparison increased.
>
>Your goal now is to count the number of times the sum of measurements in this sliding window increases from the previous sum. So, compare A with B, then compare B with C, then C with D, and so on. Stop when there aren't enough measurements left to create a new three-measurement sum.

We have the opportunity to implement this by reusing code from part 1.

For part 1 we calculate the result with `CountIncreases(Parse(input))`.

We are using functions as a means of abstraction to break our solution down into well-defined pieces.

Part 2 introduces the concept of a sliding window. We can calculate this by progressively summing triplets of the original array.

So the calculation for part 2 will look like this: `CountIncreases(SlidingWindow(Parse(input))`.

Here is the code:

`day1_test.go`

```
func TestSlidingWindow(t *testing.T) {
	depths := []uint16{199, 200, 208, 210, 200, 207, 240, 269, 260, 263}
	expected := []uint16{607, 618, 618, 617, 647, 716, 769, 792}
	actual := SlidingWindow(depths)
	if !reflect.DeepEqual(actual, expected) {
		t.Errorf("SlidingWindow was incorrect, got: %d, want: %d.", actual, expected)
	}
}
```

(again, I'm using the test case example from the problem statement.)

And the implementation:

```
func SlidingWindow(depths []uint16) []uint16 {
	ret := make([]uint16, len(depths)-2)
	for i := 2; i < len(depths); i++ {
		ret[i-2] = depths[i] + depths[i-1] + depths[i-2]
	}
	return ret
}
```

@beaver

'''
'''--- 23-day1-done.md ---
This part 1 seems to be taking a while.

We already have the `SlidingWindow` function so it's time to join the pieces together:

`day1.go`

```
func Part2(content string) (uint16, error) {
	return 0, nil
}
```

Make it fail first. I don't always do this, but it's useful to remember and the feeling of satisfaction going from failing test to passing test gives closure.

`day1_test.go`

Rename the first test, and add another based on the example given.

```
func TestPart1Integration(t *testing.T) {
	actual, _ := Part1("199\n200\n208\n210\n200\n207\n240\n269\n260\n263")
	expected := uint16(7)
	if expected != actual {
		t.Errorf("Part1 was incorrect, got: %d, want: %d.", actual, expected)
	}
}

func TestPart2Integration(t *testing.T) {
	actual, _ := Part2("199\n200\n208\n210\n200\n207\n240\n269\n260\n263")
	expected := uint16(5)
	if expected != actual {
		t.Errorf("Part2 was incorrect, got: %d, want: %d.", actual, expected)
	}
}
```

```
$ go test -test.v
=== RUN   TestCountIncreases
--- PASS: TestCountIncreases (0.00s)
=== RUN   TestPart1Integration
--- PASS: TestPart1Integration (0.00s)
=== RUN   TestPart2Integration
    day1_test.go:29: Part2 was incorrect, got: 0, want: 5.
--- FAIL: TestPart2Integration (0.00s)
=== RUN   TestSlidingWindow
--- PASS: TestSlidingWindow (0.00s)
=== RUN   TestParseInput
--- PASS: TestParseInput (0.00s)
FAIL
exit status 1
FAIL    aoc2021/day1    0.009s
$ 
```

Fix the implementation

```
func Part2(content string) (uint16, error) {
	values, err := Parse(content)
	if err != nil {
		return 0, err
	}
	return CountIncreases(SlidingWindow(values)), nil
}
```

Update main.go

```
func solveDay1() {
	content := loadContent("input/day1.txt")
	part1Result, err := day1.Part1(content)
	if err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
	part2Result, err := day1.Part2(content)
	if err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
	fmt.Printf("Day 1 Part 1 %d\n", part1Result)
	fmt.Printf("Day 1 Part 2 %d\n", part2Result)
}
```

For me, I see:

```
$ go run main.go
Day 1 Part 1 1342
Day 1 Part 2 1378
$
```

The repeated error checking feels like it could do with some improvement.

Here are a couple of articles I found to mull over:

* [Error Handling in Go that Every Beginner should Know](https://hussachai.medium.com/error-handling-in-go-a-quick-opinionated-guide-9199dd7c7f76)
* [Avoid checking if error is nil repetition?](https://stackoverflow.com/questions/18771569/avoid-checking-if-error-is-nil-repetition) (8 years old)

'''
'''--- 24-language-evolution.md ---
**Language Evolution**

[_I've been watching The Staircase. I noted how the film makers collected a load of footage and then debated at length what to leave in and what to leave out ... whether it make him seem more or less guilty. This writing process feels like that. There are a couple of things I want to address in this post and I don't feel like I've nailed it yet: how programming languages and their adoption evolves ... from assembly to C to high level languages; and also abstractions ... while the focus is on a specific language it's important to teach transferable principles, like abstactions, which can still be applied when the reader learns a different programming language._]

I wrote my first substantial programme when I was 15.

With my Dad having passed away when I was four, and coming from a single parent family, my Mum decided it would be better for us to go to a boarding school.

I had an interest in electrical and electronic things early on. I used to buy the magazines Practical Electronics and Everyday Electronics and make some of the sample circuits. 

And the school had early computers, including that accepted their programmes via punched cards. The hole (or absence of a hole) represents a binary 1 or 0 and when there are eight of them you can represent up to 2^8 or 256 values. The values can represent a type of instruction (like "increment") and a memory location, or register, to operate on.

Assembly code runs quickly; you are coding very close to the hardware and so there is no extra work to be done. But coding at this low level requires you to think at this low level, and write (and maintain) lots of code. Conditional logic is achieved by "jumping" to different parts of the programme, and you may need to specify those locations directly. So when you add or remove code you need to adjust the "distances".

My first language was C, which is also a "low-level" language. C introduces the data types, conditional logic and [add other things] which allow the developer to express the programme at a higher than assembly language. But one thing that C requires you to do is manage your own memory. As your programme runs you create temporary data and if your programme is running for long enough you need to make sure you clean up when you've finished using that memory. Otherwise you will eventally run out of available memory. It's also up to you to ensure that memory is allocated before you use it. If you try to access memory that hasn't been allocated correctly your programme will fail.

Programming languages come in and out of fashion. Some are long-lived, particularly if they have a strong community around them, and an effective way of deciding how to evolve. 

The challenges of memory management in C have given rise to other languages. Java has similar syntax to C, and (mostly) takes care of the memory managament for you. It is still widely used in business applications. Some have seen ways that it can be improved, by being more concise, and not requiring an object-oriented style of programming. And while the automatic garbage collection takes away the overhead from the programmer, it can introduce latency (delay) in executing your programme.

Go is a modern language that was designed at Google by Robert Griesemer, Rob Pike, and Ken Thompson. Ken Thompson was also one of the designers of the C language.

[Add more justification for Go here.]

Go is the lanugage we're going to use in this introduction to coding. 

We're going to focus on the code ... more showing and less telling. 

One of my favourite places to visit when I was young (and now) is the science museum. I love the interactive element of the science museum where you pressed a button and could observe the result. Sound doesn't travel through a vacuum, and you can see it for yourself.

For those of us who prefer to learn kinaesthetically, this book will give you plenty of examples as a way to building mental models about coding, and show the abstractions that we use to construct software systems.

'''
'''--- 25-integers.md ---
**Numbers**

The first abstraction we're going to explore are numbers, one of the common data types.

That box on your desk, or in the cloud, deals in ones and zeros; base 2. 

The base of a number determines the number of possible values each element can contain: the base minus one.

So base 2 numbers can have the value 1 or 8.

Base 8 (also known as "octal") digits have the values 0 to 7.

Decimal numbers, containing digits from zero to nine, are base 10.

And hexadecimal values, contains characters that can have the value 0-9 and A-F, giving 16 possible values.

But under the covers it's stlil a combination of ones and zeros.

Other bases are possible, including Base 64; this is used for safely sending data over networks by encoding it first.

There are schemes called _big endian_ and _little endian_ which indicate the order in which bits are stored.

If the number 65 is stored as 00...001000001 this is _big endian_ because the higher value bits are stored first, and the lower value bits last.

This represents 65 because the different binary digits (bits) correspond to a particular power of two.

```
64 32 16  8  4  2  1
 1  0  0  0  0  0  1
```

So the value is 64 + 1 = 65.

Counting these ones and zeros can be challenging, but is easier if you treat them as groups of the same value.

If you need to store only positive numbers then the maximum value you can store in 4 bits, for example, is 1+2+4+8 = 15, which is 2^4-1. (2^4 is two the power 4, or 2*2*2*4 = 16).

So the maximum value you can store in 32 bits is 2^32-1.

As a useful shortcut, 2^10 is 1024 (or approximately 10^3). 

2^20 = 2^(10+10) = 2^10 * 2^10 which is approximately 1,000,000.

So every increase in power of 10 multiplies the result by 1,000. This can be useful to know when sanity checking your work.

If you want to store negative numbers, the maximum value you can store is roughly halved because one of the bits is used to indicate whether the number is positive or negative.

The [Fibonacci sequence](https://en.wikipedia.org/wiki/Fibonacci_number) is defined as:

```
F(0) = 0
F(1) = 1
F(n) = F(n-1) + F(n-2)
```

Some people incorrectly start the sequence from 1.

This number grows rather large rather quickly.

Here is the code:

```
package fib
  
func Fibonnacci(n uint16) uint64 {
        if n < 2 {
                return uint64(n)
        } else {
                var a, b uint64 = 0, 1
                for i := uint16(1); i < n; i++ {
                        b, a = a+b, b
                }
                return b
        }
}
```

and tests

```
package fib
  
import (
    "testing"
    "aoc2021/fib"
)

func TestCountIncreases(t *testing.T) {
    n := []uint16{0,1,2,3,4,5,6};
    expected := []uint64{0,1,1,2,3,5,8};
        for i := 0; i < len(n); i++ {
        actual := fib.Fibonnacci(n[i])
        if expected[i] != actual {
            t.Errorf("Fibonacci was incorrect, got: %d, want: %d.", actual, expected[i])
        }
        }       
}
```

Exercises:

What is the largest value you can store in a 64 bit unsigned integer?

And what is the value of n for which our function will correctly calculate the Fibonacci value?

What happens if you increase the value of n by 1 beyond this value

Can you add validation to the function so that it returns an error value if the parameter exceeds the maximum supported value?

'''
'''--- 26-day2-part1.md ---
*Advent of Code Day 2**

Navigating the depths.

Day 2 involves processing a series of navigation for our fictitious submarine in order to determine its eventual location.

For example, after the submarine follows these instructions

```
forward 5
down 5
forward 8
up 3
down 8
forward 2
```

It has a horizontal position of 5+8+2=15, and a depth of 5-3+8=10.

The example raises a couple of initial questions:
- can we go backwards? (We'll assume now.)
- if the "up" command is given a value that is greater than our current depth, what should we do? (Again, we'll assume it can't happen until we see evidence to the contrary.)
- could we encounter any other commands in the full data set other than forward, down or up? (We'll code for the three we're given and adapt when we see the the real example.)

Let's lay the groundwork.

What would be good terminology to use for our solution?

Here's a clue:

>It seems like the submarine can take a series of commands like forward 1, down 2, or up 3:

So each of those lines in the example represents a "command", and we want a term to represent the associated value; "distance" seems good enough since that can represent horizontal or vertical movement.

`day2/command.go`

```
package day2

type Direction uint16

const (
	Forward Direction = 0
	Up      Direction = 1
	Down              = 2
)

type Command struct {
	direction Direction
	distance  uint16
}

func newCommand(direction Direction, distance uint16) *Command {
	c := Command{direction: direction, distance: distance}
	return &c
}
```

Write a test that checks the `newCommand` function.

`day2/command_test.go`

```
package day2

import (
	"testing"
)

func TestNewCommand(t *testing.T) {
	command := newCommand(Up, 20)
	actualDirection := command.direction
	expectedDirection := Up
	if actualDirection != expectedDirection {
		t.Errorf("Command direction was incorrect, got: %d, want: %d.", actualDirection, expectedDirection)
	}
	expectedDistance := uint16(20)
	actualDistance := command.distance
	if actualDistance != expectedDistance {
		t.Errorf("Command distance was incorrect, got: %d, want: %d.", actualDirection, expectedDirection)
	}
}
```

We also need to parse the input data into a form that is usable by our domain logic. We're choosing an array of Command objects (actually, pointers to them).

`day2/parse.go`

```
package day2

func Parse(s string) []Command {
	return make([]Command, 0)
}
```

`day2/parse_test.go`

```
package day2

import (
	"reflect"
	"testing"
)

func TestParseInput(t *testing.T) {
	input := "forward 5\ndown 5\nforward 8\nup 3\ndown 8"
	actual := Parse(input)
	expected := []*Command{
		newCommand(Forward, 5),
		newCommand(Down, 5),
		newCommand(Forward, 8),
		newCommand(Up, 3),
		newCommand(Down, 8),
	}
	if !reflect.DeepEqual(actual, expected) {
		t.Errorf("Parse was incorrect, got: %v, want: %v.", actual, expected)
	}
}
```

[_To do: Go by default is pass by value, which is why we pass around pointers -- I believe -- to prevent copying objets. I need to dig into this more._]

```
$ go test -test.v
=== RUN   TestNewCommand
--- PASS: TestNewCommand (0.00s)
=== RUN   TestParseInput
    parse_test.go:19: Parse was incorrect, got: [], want: [0xc0001220c8 0xc0001220cc 0xc0001220d0 0xc0001220d4 0xc0001220d8].
--- FAIL: TestParseInput (0.00s)
FAIL
exit status 1
FAIL    aoc2021/day2    0.007s
$ 
```

Now we need to make the parsing work.

'''
'''--- 27-relections-part1.md ---
**Reflections Part 1 (October 2021)**

I thought it would be helpful to review my posts in WC3 to see what I was focusing on, how those choices were supporting or undermining my goals, and have a look at what might be usable.

I started off by [musing](https://wc3.akimbo.com/t/andrew-whitehouse-dailies/61070?u=andrewwhitehouse) on Naval Ravikant's almanac (and I reminded of spending time thinking on what it is you should be working on). Ikigai. 

And being comfortable with curating; finding other people's stuff and combining it with my own experience to create something sufficiently new, so it isn't plagiarism. (And I keep coming back to _Steal Like an Artist_.)

I still have this podcast annotation itch that I haven't scratched yet. But I don't know how to make that into a book. Perhaps I could build it and write a book about it. I'm not sure. But there is this other movement of decentralised applications, and aligning incentives so that the business model doesn't have to be advertising with all its optimising for rage and anxiety.

I references my journey dabbling with electriciy early on, and then computers. And the impact of losing my Dad early on, and the box of lights and switches that he made me (and I took apart to see how it worked).

And the person who supported me financially through school, and how there is a strong ethic that we carry with us of remembering the support we have received and in turn helping others.

And maintaining good mental health is important. Because bad things can happen if you don't. And that involves staying open to other people, being _open, generous, and connected_. Often not easy.

Is it necessary to decide up front what is the change you seek to make[?](https://wc3.akimbo.com/t/andrew-whitehouse-dailies/61070/8?u=andrewwhitehouse).

I hypothesized that my audience might be my children, or someone earlier in their career who wants to know how to navigate the tech industry.  I'm providing support in particular to one of my children as she undertakes an internship, and have a project lined up for my son.

My focus now has shifted to _people who want to learn X_ (and I'm still refining what _X_ is).

And Liz Gilbert's words of guidance

1. Tell your story TO someone. Pick one person you love or admire or want to connect with, and write the whole thing directly to them —like you’re writing a letter. This will bring forth your natural voice. Whatever you do, do NOT write to a demographic. Ugh.
2. Start at the beginning of the story, write what happened, and keep going until you get to the end.
3. Use radically simple sentences.
4. Don’t worry if it’s good; just finish it. Whether or not your project is good, you’ll be a different person at the end of it, and that’s always worth doing.
5. Don’t write with the aim of changing anybody’s life. That will lead to heavy, irritating prose. Just share what delights or enrages or fascinates you. If somebody’s life is changed by it, that’s a bonus.
6. Whenever you can, tell stories instead of explaining stuff. Humans love stories, and we hate having stuff explained to us. Use Jesus as an example: He spoke almost exclusively in parables, and allowed everybody to draw their own lessons from his great storytelling. And he did very well.
7. Your work doesn’t have to be any particular length, or written for any particular market. It doesn’t have to even be seen by another human being. How and if to publish your work is a problem for another day. For today, just write.
8. Remember that you’ve been doing research your whole life, merely by existing. You are the only expert in your own experience. Embrace this as your supreme qualification.
9. Every writer starts in the same place on Day One: Super excited, and ready for greatness. On Day Two, every writer looks at what she wrote on Day One and hates herself. What separates working writers from non-working writers is that working writers return to their task on Day Three. What gets you there is not pride but mercy. Show yourself forgiveness, for not being good enough. Then keep going
10. Be willing to let it be easy. You might be surprised. ❤️ LG

Also [this](https://www.elizabethgilbert.com/thoughts-on-writing/) and this video ...

And whatever I do, it helps for it to be [sustainable, relevant and differentiated](https://wc3.akimbo.com/t/andrew-whitehouse-dailies/61070/11?u=andrewwhitehouse).

(I also have an idea for organising my MP3s that are stored in Dropbox into a sensible playlist, but I keep coming up with reasons not to do it, mainly "no-one will pay for it".)

I started to get some sense of what the writing might look like when I considered accessibility. I find reading hard work. I suspect I have some form of ADHD. So if I'm learning something new, what I want is something that tells me "do this" and then gives just enough explanation after. I get really frustrated with books that waffle on taking up my brain capacity, probably because they want to increase their page count.

And I like small paragraphs with whitespace between them because I find it easier to track the paragraphs then.

And during WC3 I've attended a few different interviews that for differeing reasons haven't resulted in an offer. But it's helped me gauge what people are looking for. And I wonder if I'm trying too much to fit into what other people say I should do for a career (Seth wrote a post called "fitting in, but not too much" somewhere, which resonates on this point.)

And I think I do better creative work in the morning. If it's bashing out code it's more deterministic and so the "next step" is well defined.

And this, from Naval Ravikant:

> Follow your intellectual curiosity more than whatever is 'hot right now'. If your curiosity ever leads you to a place where society eventually wants to go, you'll get paid extremely well.
> 
> You're more likely to have skills society does not yet know how to train other people to do. If someone can train other people how to do something, then they can replace you. If they can replace you, then they don't have to pay you. You want to know how to do something other people don't know how to do at the time period when those skills are in demaind.
> 
> You get rewarded by society for giving it what it wants and doesn't know how to get elsewhere. A lot of people think you can go to school and study for how to make money, but the reality is, there's no skill called "business".
> 
> Think about what product or service society wants but does not yet know how to get. You want to become the person who delivers it and delivers it at scale. This is really the challenge of how to make money.
>
> What you want in life is to be in control of your time. You want to get into a leveraged job where you control your own time and you're tracked on the outputs. 

I did an [exericse](https://wc3.akimbo.com/t/andrew-whitehouse-dailies/61070/19?u=andrewwhitehouse) on my values, which I identified as "freedom, family and connection". Marc Benioff asks what's your highest value, the thing that you won't compromise on? I think Marc Benioff is someone whose way of being I can relate to.

The Stay at Home Choir actually [released](https://www.youtube.com/watch?v=3VEkry3JLek) Home this week. The [submission](https://wc3.akimbo.com/t/andrew-whitehouse-dailies/61070/25?u=andrewwhitehouse) was back in October. I'm in there somewhere, but it feels like an advanced-level Where's Wally.

I found some useful [advice](https://www.entrepreneur.com/article/252231) on building a business which I haven't followed yet. And maybe mentors [aren't that important](https://wc3.akimbo.com/t/andrew-whitehouse-dailies/61070/33?u=andrewwhitehouse).

I [mused](https://wc3.akimbo.com/t/andrew-whitehouse-dailies/61070/39?u=andrewwhitehouse) on the importance of timing, how Gates, Jobs, Zuckerberg and others were all at a particular point in their careers to take advantage of technology inflexion points (the PC, the mobile phone).

Still in October 2021, I covered some of my journey working in payment systems where the Cloud wasn't even a glint in Jeff Bezos's eye. But now it's a thing and making Amazon and co very wealthy thank you very much. 

And blockchain. That's one of the current inflexion points because the banks have proven 

>Education, distraction, coding and problems worth solving: related to the above, I see lots of coding bootcamps that are teaching the skills that are useful to get hired. How can we do better? Make it easier for people with diverse background, and ways of interacting, to get into technology so that we build products that meet the needs of a wider audience. And traditional schooling is still geared towards passing through the gates the lead to an expensive university education. Especially state-funded education. That model is obviously broken. And our attention is greatly in demand from those whose business models want us to see ads. So we're more distracted. Which makes it harder to sustain the continuous learning that we need to adapt. What are the foundational skills that we need, especially as technology use is increasing in some historically highly paid professionals (like [law](https://www.ft.com/content/66853b7c-b62a-461e-9d85-bb805e8dff97)). As Mike Maples put it [in my partially finished [podcast notes](https://idealog.co/20210621-mike-maples-mfm.html)]:

>>If the twentieth century was about being the 'organisation' man, and following the rules and progressing up the hierarchy (it doesn't exist any more), now you have to take agency for your own life and own your comparative advantage and understand that is your responsibility as a free person in this world.

[ADHD can be a gift](https://wc3.akimbo.com/t/andrew-whitehouse-dailies/61070/47?u=andrewwhitehouse).

At the end of October when the clocks go back, we took part in the [CALM walk](https://www.justgiving.com/fundraising/andrew-whitehouse13) again. It's a reminder of the significance of mental health to our family.

I spent some of the early posts looking at "serverless" as a model for building applications. It's useful as a way of saving money, but I'm not sure it needs to be the primary focus. As I've been looking at Golang recently, I see that another model is picking something that runs very quickly and sticking it on a server.

I spent more time thinking about [who this project is for](https://wc3.akimbo.com/t/andrew-whitehouse-dailies/61070/55?u=andrewwhitehouse). It could be for those who find working in tech more difficult because they have cognitive challenges, or those who want an alternative to universities, or those who don't want to fit in too much in a corporate role.

Some guidance from Louise:

>this is a book writing course
>
>choose to write a book
>
>choose now
>
>write what you wish existed
>
>it will resonate with people like you
>
>make it small
>
>make it manageable
>
>sounds like you have five books in you
>
>start with the easiest one so you get your training wheels
>
><https://adhdatwork.add.org/adhd-accommodation-guide/>

I came up with a "who is it for" list for the kindling. These are the ones that still resonate.

>* My children [_I've relaxed on this one and will keep suggesting things but be led by them_]
>* My 22 year old self; a.k.a. things I wish I’d know when I started out
>* People working on tech who are looking for a change of direction
>* Developers who aren’t sure how to do product validation
>* Software developers who want to make sense of blockchain

@beaver
'''
'''--- 28-near-example.md ---
**NEAR Protocol Notes**

[_There are a number of programmable blockchain contenders swirling about currently. The "main" one is Ethereum but the gas fees are ridiculous, it's not clear how the move from a different "proof" mechanism is going to work, and whether or not Ether is treated as a security with all the associated regulation is an open question. There is plenty of unruly behaviour going on. I'm not seeing any particularly useful things being done: swapping tokens, and creating collectible images seem to be the main activities. I'm more interested in how tokens can be used to incentivise behaviour that makes an application valuable; addressing the cold-start problem that affects networks when they're starting out._

_So I'm exploring the different blockchains, and this may lead to a thread through the book. The NEAR procotol uses Rust, like Solana, but has a different approach to scaling, which may be significant if and when adoption grows._ 

_These are written in note form. Not quite book-ready yet, but I'm still making sense of it myself._]

Building a sample appliation on NEAR

There are a few blockchain that I think have potential.

For Ethereum, the gas fees are currently too high. So you need to use a level 2 blockchain like Arbitrum.

There is also Polygon, which has its own MATIC token. I haven't looked at that in detail yet.

I'm not ready to use that yet.

So I'm going to look at NEAR and Solana instead.

This is me following the process to get an example application working with NEAR. (I did setup Solana in the past and it was fiddly.)

[Basic setup skeleton](https://www.near-sdk.io/zero-to-hero/basics/set-up-skeleton)

```
$ npm install -g near-cli
npm WARN config global `--global`, `--local` are deprecated. Use `--location=global` instead.
npm WARN deprecated @ledgerhq/hw-transport-u2f@5.36.0-deprecated: @ledgerhq/hw-transport-u2f is deprecated. Please use @ledgerhq/hw-transport-webusb or @ledgerhq/hw-transport-webhid. https://github.com/LedgerHQ/ledgerjs/blob/master/docs/migrate_webusb.md

added 304 packages, and audited 305 packages in 44s

25 packages are looking for funding
  run `npm fund` for details

4 moderate severity vulnerabilities

To address all issues (including breaking changes), run:
  npm audit fix --force

Run `npm audit` for details.
$ 
```

It seemed to work.

```
$ near
Usage: near <command> [options]

Commands:
  near create-account <accountId>                                                                        create a new developer account (subaccount of the masterAccount, ex: app.alice.test)
  near state <accountId>                                                                                 view account state

. . .
```

I already have awhitehouse.testnet set up.

https://examples.near.org/rust-counter

panic profit flower mobile thing use example soft sing pizza clump purity

awhitehouse.testnet

Now I'm logged in

```
$ near login

Please authorize NEAR CLI on at least one of your accounts.

If your browser doesn't automatically open, please visit this URL
https://wallet.testnet.near.org/login/?referrer=NEAR+CLI&public_key=ed25519%3A76wh6QA8ZCLYLY9Y2hkWEVvHdEpLKaGXfUxEAkJPw4op&success_url=http%3A%2F%2F127.0.0.1%3A5000
Please authorize at least one account at the URL above.

Which account did you authorize for use with NEAR CLI?
Enter it here (if not redirected automatically):
Logged in as [ awhitehouse.testnet ] with public key [ ed25519:76wh6Q... ] successfully
$
```

```
$ near keys awhitehouse.testnet
Keys for account awhitehouse.testnet
[
  {
    access_key: { nonce: 86198558000004, permission: 'FullAccess' },
    public_key: 'ed25519:3UsvjSDjYnQ361mUGHY8m84PdjtQjA7ShN9bju5cjkBy'
  },
  {
    access_key: { nonce: 86158837000000, permission: 'FullAccess' },
    public_key: 'ed25519:3hdhYJA29cHHBkYih51J1x2rLW1cxRD2h1u61Dc7VUy7'
  },
  {
    access_key: { nonce: 86158744000004, permission: 'FullAccess' },
    public_key: 'ed25519:4datLDvthG1e2ePQQVruTUxTmwJQLFGyRwHyhGtuvCnd'
  },
  {
    access_key: { nonce: 93802546000000, permission: 'FullAccess' },
    public_key: 'ed25519:76wh6QA8ZCLYLY9Y2hkWEVvHdEpLKaGXfUxEAkJPw4op'
  },
  {
    access_key: { nonce: 86158738000002, permission: 'FullAccess' },
    public_key: 'ed25519:9u1QXyrPRFhBcGbVfM46jgqvVGq1KL6kbQZs9u9HBURo'
  },
  {
    access_key: { nonce: 86198444000001, permission: 'FullAccess' },
    public_key: 'ed25519:A1dyYPPp9duzvHLyogvxWumG5AbNKQSvD6rxBxGYcHaD'
  },
  {
    access_key: { nonce: 93802465000001, permission: 'FullAccess' },
    public_key: 'ed25519:AdDrUvREPy2Bp4L23XLtv5msDMgNX327GE61dSAmPmYk'
  },
  {
    access_key: { nonce: 86158785000000, permission: 'FullAccess' },
    public_key: 'ed25519:C3EPPhDRNLNWZbAEA18ZcKndBhaq8mt4AFHcZGpGMKon'
  }
]
Andrews-MBP:reflections andrewwhitehouse$
```

I already have Rust setup so am skipping the next section.

```
$ rustup target add wasm32-unknown-unknown
info: component 'rust-std' for target 'wasm32-unknown-unknown' is up to date
$ 
```

Clone the template

```
$ git clone https://github.com/near-examples/rust-template
Cloning into 'rust-template'...
remote: Enumerating objects: 55, done.
remote: Counting objects: 100% (2/2), done.
remote: Total 55 (delta 1), reused 1 (delta 1), pack-reused 53
Unpacking objects: 100% (55/55), 13.47 KiB | 229.00 KiB/s, done.
$
```

```
$ cargo test
  Downloaded libc v0.2.99
  Downloaded serde_json v1.0.66
  Downloaded proc-macro2 v1.0.28
  Downloaded typenum v1.13.0
  Downloaded near-sys v0.1.0
  Downloaded near-sdk v4.0.0-pre.4
  Downloaded near-sdk-macros v4.0.0-pre.4
  Downloaded indexmap v1.7.0
  Downloaded cpufeatures v0.1.5
  Downloaded sha2 v0.9.5
  Downloaded derive_more v0.99.16
  Downloaded 11 crates (961.1 KB) in 2.50s
   Compiling proc-macro2 v1.0.28
   Compiling autocfg v1.0.1
   Compiling unicode-xid v0.2.2
   Compiling syn v1.0.57
   Compiling serde_derive v1.0.118
   Compiling serde v1.0.118
   Compiling typenum v1.13.0
   Compiling version_check v0.9.3
   Compiling ryu v1.0.5
   Compiling serde_json v1.0.66
   Compiling hashbrown v0.11.2
   Compiling memchr v2.4.1
   Compiling itoa v0.4.7
   Compiling block-padding v0.2.1
   Compiling ahash v0.4.7
   Compiling opaque-debug v0.3.0
   Compiling hex v0.4.3
   Compiling regex-syntax v0.6.25
   Compiling convert_case v0.4.0
   Compiling cfg-if v1.0.0
   Compiling cpufeatures v0.1.5
   Compiling libc v0.2.99
   Compiling lazy_static v1.4.0
   Compiling keccak v0.1.0
   Compiling wee_alloc v0.4.5
   Compiling bs58 v0.4.0
   Compiling base64 v0.13.0
   Compiling memory_units v0.4.0
   Compiling cfg-if v0.1.10
   Compiling byteorder v1.4.3
   Compiling Inflector v0.11.4
   Compiling near-sys v0.1.0
   Compiling generic-array v0.14.4
   Compiling indexmap v1.7.0
   Compiling num-traits v0.2.14
   Compiling num-integer v0.1.44
   Compiling num-bigint v0.3.2
   Compiling num-rational v0.3.2
   Compiling hashbrown v0.9.1
   Compiling aho-corasick v0.7.18
   Compiling quote v1.0.9
   Compiling regex v1.5.4
   Compiling digest v0.9.0
   Compiling block-buffer v0.9.0
   Compiling sha2 v0.9.5
   Compiling sha3 v0.9.1
   Compiling near-runtime-utils v4.0.0-pre.1
   Compiling borsh-derive-internal v0.8.2
   Compiling borsh-schema-derive-internal v0.8.2
   Compiling derive_more v0.99.16
   Compiling near-sdk-macros v4.0.0-pre.4
   Compiling toml v0.5.8
   Compiling proc-macro-crate v0.1.5
   Compiling near-rpc-error-core v0.1.0
   Compiling near-rpc-error-macro v0.1.0
   Compiling borsh-derive v0.8.2
   Compiling borsh v0.8.2
   Compiling near-primitives-core v0.4.0
   Compiling near-vm-errors v4.0.0-pre.1
   Compiling near-vm-logic v4.0.0-pre.1
   Compiling near-sdk v4.0.0-pre.4
   Compiling my-crossword v0.1.0 (/Users/andrewwhitehouse/code/active-projects/rust-template)
warning: unused import: `super::*`
  --> src/lib.rs:25:9
   |
25 |     use super::*;
   |         ^^^^^^^^
   |
   = note: `#[warn(unused_imports)]` on by default
help: consider adding a `#[cfg(test)]` to the containing module
  --> src/lib.rs:24:1
   |
24 | mod tests {
   | ^^^^^^^^^

warning: unused import: `get_logs`
  --> src/lib.rs:26:32
   |
26 |     use near_sdk::test_utils::{get_logs, VMContextBuilder};
   |                                ^^^^^^^^
   |
help: consider adding a `#[cfg(test)]` to the containing module
  --> src/lib.rs:24:1
   |
24 | mod tests {
   | ^^^^^^^^^

warning: unused import: `testing_env`
  --> src/lib.rs:27:20
   |
27 |     use near_sdk::{testing_env, AccountId};
   |                    ^^^^^^^^^^^
   |
help: consider adding a `#[cfg(test)]` to the containing module
  --> src/lib.rs:24:1
   |
24 | mod tests {
   | ^^^^^^^^^

warning: function is never used: `get_context`
  --> src/lib.rs:31:8
   |
31 |     fn get_context(predecessor: AccountId) -> VMContextBuilder {
   |        ^^^^^^^^^^^
   |
   = note: `#[warn(dead_code)]` on by default

warning: `my-crossword` (lib test) generated 4 warnings
    Finished test [unoptimized + debuginfo] target(s) in 3m 12s
     Running unittests (target/debug/deps/my_crossword-77d530044811f886)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

You have mail in /var/mail/andrewwhitehouse
Andrews-MBP:rust-template andrewwhitehouse$ 
```

No tests yet.

[Altering the smart contract](https://www.near-sdk.io/zero-to-hero/basics/add-functions-call)

> This section will modify the smart contract skeleton from the previous section. This tutorial will start by writing a contract in a somewhat useless way in order to learn the basics. Once we've got a solid understanding, we'll iterate until we have a crossword puzzle.

I like the approach.

Update the puzzle

```
const PUZZLE_NUMBER: u8 = 1;

#[near_bindgen]
#[derive(Default, BorshDeserialize, BorshSerialize)]
pub struct Contract {
    crossword_solution: String
}

#[near_bindgen]
impl Contract {
    pub fn get_puzzle_number(&self) -> u8 {
        PUZZLE_NUMBER
    }

    pub fn set_solution(&mut self, solution: String) {
        self.crossword_solution = solution;
    }

    pub fn guess_solution(&mut self, solution: String) {
        if solution == self.crossword_solution {
            env::log_str("You guessed right!")
        } else {
            env::log_str("Try again.")
        }
    }
}
```

```
$ ./build.sh
```

Create a subaccount

```
$ near create-account crossword.awhitehouse.testnet --masterAccount awhitehouse.testnet --initialBalance 1
Saving key to '/Users/andrewwhitehouse/.near-credentials/testnet/crossword.awhitehouse.testnet.json'
Account crossword.awhitehouse.testnet for network "testnet" was created.
$
```

Now that we have a key pair for our subaccount, we can deploy the contract to testnet and interact with it!

```
$ near state crossword.awhitehouse.testnet
Account crossword.awhitehouse.testnet
{
  amount: '1000000000000000000000000',
  block_hash: 'DgT2AYqtVeqnfC2pmPg9VefpBkAfnYtGvihX8j32LKXq',
  block_height: 93803952,
  code_hash: '11111111111111111111111111111111',
  locked: '0',
  storage_paid_at: 0,
  storage_usage: 182,
  formattedAmount: '1'
}
$ 
```

Note the code_hash here is all ones. This indicates that there is no contract deployed to this account.

```
$ near deploy crossword.awhitehouse.testnet --wasmFile res/my_crossword.wasm
Starting deployment. Account id: crossword.awhitehouse.testnet, node: https://rpc.testnet.near.org, helper: https://helper.testnet.near.org, file: res/my_crossword.wasm
Transaction Id 2TJehwkVuRnLEiy1xpwi1NMwKsgRQHVH3SfFK3ikmchW
To see the transaction in the transaction explorer, please open this url in your browser
https://explorer.testnet.near.org/transactions/2TJehwkVuRnLEiy1xpwi1NMwKsgRQHVH3SfFK3ikmchW
Done deploying to crossword.awhitehouse.testnet
$ 
```

```
near state crossword.friend.testnet
```

After deployment the code hash has changed:

```
$ near state crossword.awhitehouse.testnet
Account crossword.awhitehouse.testnet
{
  amount: '999246714091318300000000',
  block_hash: 'EvS9xfJG9NoppUfC3vfyd5JVQwkKbZV1zjJtVdSKRTCr',
  block_height: 93804095,
  code_hash: '8nnhpFmmCN25ft5iNPVwtk5igZd2vbtBNdbfxKD2xGBV',
  locked: '0',
  storage_paid_at: 0,
  storage_usage: 97501,
  formattedAmount: '0.9992467140913183'
}
Andrews-MBP:rust-template andrewwhitehouse$
```

```
$ near view crossword.awhitehouse.testnet get_puzzle_number
View call: crossword.awhitehouse.testnet.get_puzzle_number()
1
Andrews-MBP:rust-template andrewwhitehouse$
```

Set a solution:

```
$ near call crossword.awhitehouse.testnet set_solution '{"solution": "near nomicon ref finance"}' --accountId awhitehouse.testnet
Scheduling a call: crossword.awhitehouse.testnet.set_solution({"solution": "near nomicon ref finance"})
Doing account.functionCall()
Transaction Id D241jMtB17w5SmRcxRajTPyCjXNRURBGVx4PQZ3KJjLF
To see the transaction in the transaction explorer, please open this url in your browser
https://explorer.testnet.near.org/transactions/D241jMtB17w5SmRcxRajTPyCjXNRURBGVx4PQZ3KJjLF
''
Andrews-MBP:rust-template andrewwhitehouse$ 
```

```
$ near call crossword.awhitehouse.testnet guess_solution '{"solution": "near nomicon ref finance"}' --accountId awhitehouse.testnet
Scheduling a call: crossword.awhitehouse.testnet.guess_solution({"solution": "near nomicon ref finance"})
Doing account.functionCall()
Receipt: 8PyBbPLzpEPXbKM8VW11M7djDy4U5mW92pSbVA5Y8CW2
	Log [crossword.awhitehouse.testnet]: You guessed right!
Transaction Id 61315nTU9iWmVbCRVa2S7xUTq5yLZA3DM4j1jVL2KPHv
To see the transaction in the transaction explorer, please open this url in your browser
https://explorer.testnet.near.org/transactions/61315nTU9iWmVbCRVa2S7xUTq5yLZA3DM4j1jVL2KPHv
''
Andrews-MBP:rust-template andrewwhitehouse$ 
```

Now we clear down the subaccount.

```
near delete crossword.awhitehouse.testnet awhitehouse.testnet
near create-account crossword.awhitehouse.testnet --masterAccount awhitehouse.testnet
```

Next steps: <https://www.near-sdk.io/zero-to-hero/basics/hashing-and-unit-tests>

**Reflection**: This tools actually did what the tutorial said they would. That is quite encouraging. Generally the NEAR team seem to put a good amount of effort into making decent docs. Solana seems to be further ahead in adoption in some ways, but platform builders need to make their tools friendly to the people who are going to build on the platform.

@Beaver 

'''
'''--- 29-near-part2.md ---
NEAR continued

[link](https://www.near-sdk.io/zero-to-hero/basics/add-functions-call)

Remember that blockchain is an open ledger, meaning everyone can see the state of smart contracts and transactions taking place.

There is an endpoint that allows you to query the state of the blockchain:

```
$ curl -d '{"jsonrpc": "2.0", "method": "query", "id": "see-state", "params": {"request_type": "view_state", "finality": "final", "account_id": "crossword.awhitehouse.testnet", "prefix_base64": ""}}' -H 'Content-Type: application/json' https://rpc.testnet.near.org
{"jsonrpc":"2.0","result":{"block_hash":"WQ6uiPB1JqBSvPZS1w1QySrSWurhnxNCMrT5nrYkPPq","block_height":93884705,"proof":[],"values":[]},"id":"see-state"}
$
```

There's nothing in there currently because I cleared it down at the end of the last session.

Redeploy:

```
$ near deploy crossword.awhitehouse.testnet --wasmFile res/my_crossword.wasm
Starting deployment. Account id: crossword.awhitehouse.testnet, node: https://rpc.testnet.near.org, helper: https://helper.testnet.near.org, file: res/my_crossword.wasm
Transaction Id 4WwaJqMDDTyyRxMyQ8SXi9ybGZKZtxCswQeSaotspXX9
To see the transaction in the transaction explorer, please open this url in your browser
https://explorer.testnet.near.org/transactions/4WwaJqMDDTyyRxMyQ8SXi9ybGZKZtxCswQeSaotspXX9
Done deploying to crossword.awhitehouse.testnet
$
```

```
$ curl -d '{"jsonrpc": "2.0", "method": "query", "id": "see-state", "params": {"request_type": "view_state", "finality": "final", "account_id": "crossword.awhitehouse.testnet", "prefix_base64": ""}}' -H 'Content-Type: application/json' https://rpc.testnet.near.org
{"jsonrpc":"2.0","result":{"block_hash":"6nN7c67VSPW4D6sEk4djvpnKgnKePZ6ALyzRNQkjUTES","block_height":93885392,"proof":[],"values":[]},"id":"see-state"}Andrews-MBP:rust-template andrewwhitehouse$
```

```
$ near view crossword.awhitehouse.testnet get_puzzle_number
View call: crossword.awhitehouse.testnet.get_puzzle_number()
1
$
```

Set the solution:

```
$ near call crossword.awhitehouse.testnet set_solution "{\"solution\": \"near nomicon ref finance\"}" --accountId awhitehouse.testnet
Scheduling a call: crossword.awhitehouse.testnet.set_solution({"solution": "near nomicon ref finance"})
Doing account.functionCall()
Transaction Id 8sZAarSqNvzXyJTm3QTfjMHSqkytFkzvmsAzay78T3o7
To see the transaction in the transaction explorer, please open this url in your browser
https://explorer.testnet.near.org/transactions/8sZAarSqNvzXyJTm3QTfjMHSqkytFkzvmsAzay78T3o7
''
$
```

Now we see some values ...

```
$ curl -d '{"jsonrpc": "2.0", "method": "query", "id": "see-state", "params": {"request_type": "view_state", "finality": "final", "account_id": "crossword.awhitehouse.testnet", "prefix_base64": ""}}' -H 'Content-Type: application/json' https://rpc.testnet.near.org
{"jsonrpc":"2.0","result":{"block_hash":"6ZKNbW79yWst7DKc5y3yHykq4eSLuvUpbBTH9z5Z24by","block_height":93885558,"proof":[],"values":[{"key":"U1RBVEU=","proof":[],"value":"GAAAAG5lYXIgbm9taWNvbiByZWYgZmluYW5jZQ=="}]},"id":"see-state"}
$
```

```
$ base64 --decode <<< GAAAAG5lYXIgbm9taWNvbiByZWYgZmluYW5jZQ==
near nomicon ref finance
$
```

## Hash the solution, add basic unit tests

[link](https://www.near-sdk.io/zero-to-hero/basics/hashing-and-unit-tests)

The solution that we stored will be public to anyone who looks at the state of the contract. We can hide this by using a one-way function called a hash; we store the hash and then perform the same function on any solution attempt we receive. If the solution matches the guess is correct (it is extremely unlikely that another solution attempt will create the same hash, given the number of possible values, which is 2^256).

It isn't possible to reverse-engineer the hash input (i.e. the solution) from the stored hash, without trying every possible input, which would take an infeasibly long time. If you could check 1 million hashes every second, it would take you around 10^71 seconds. There are approximately 3 x 10^9 seconds in 100 years.

This assumes that the hash function doesn't have any flaws, which is why you should use tried and tested cryptographic libraries for your operations.

The NEAR tutorial links to this [video](https://www.youtube.com/watch?v=PfabikgnD08&feature=youtu.be) which explains more about hashing functions. And here is [MIT Open Courseware](https://www.youtube.com/watch?v=KqqOXndnvic).

## Helper unit test during rapid iteration

We don't have a "main" function in our smart contract to interact with from the command line (through "cargo run") but we do have tests.

Let's add a test.

Update Cargo.toml for dependencies:

```
near-sdk = "4.0.0"
hex = "0.4.3"
```

`src/lib.rs` add this at the end of the file

```
#[cfg(test)]
mod tests {
    use super::*;
    use near_sdk::test_utils::VMContextBuilder;
    use near_sdk::testing_env;

    #[test]
    fn debug_get_hash() {
        // Basic set up for a unit test
        testing_env!(VMContextBuilder::new().build());

        // Using a unit test to rapidly debug and iterate
        let debug_solution = "near nomicon ref finance";
        let debug_hash_bytes = env::sha256(debug_solution.as_bytes());
        let debug_hash_string = hex::encode(debug_hash_bytes);
        println!("Let's debug: {:?}", debug_hash_string);
    }
}
```

```
$ cargo test
. . .
running 1 test
test tests::debug_get_hash ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

$
```

Let's add another unit test.

```
// part of writing unit tests is setting up a mock context
// provide a `predecessor` here, it'll modify the default context
fn get_context(predecessor: AccountId) -> VMContextBuilder {
    let mut builder = VMContextBuilder::new();
    builder.predecessor_account_id(predecessor);
    builder
}

#[test]
fn check_guess_solution() {
    // Get Alice as an account ID
    let alice = AccountId::new_unchecked("alice.testnet".to_string());
    // Set up the testing context and unit test environment
    let context = get_context(alice);
    testing_env!(context.build());

    // Set up contract object and call the new method
    let mut contract = Contract::new(
        "69c2feb084439956193f4c21936025f14a5a5a78979d67ae34762e18a7206a0f".to_string(),
    );
    let mut guess_result = contract.guess_solution("wrong answer here".to_string());
    assert!(!guess_result, "Expected a failure from the wrong guess");
    assert_eq!(get_logs(), ["Try again."], "Expected a failure log.");
    guess_result = contract.guess_solution("near nomicon ref finance".to_string());
    assert!(guess_result, "Expected the correct answer to return true.");
    assert_eq!(
        get_logs(),
        ["Try again.", "You guessed right!"],
        "Expected a successful log after the previous failed log."
    );
}
```

Actually to get this working, I had to modify it, compared to the [online docs](https://www.near-sdk.io/zero-to-hero/basics/hashing-and-unit-tests):

```
#[near_bindgen]
impl Contract {
    pub fn get_puzzle_number(&self) -> u8 {
        PUZZLE_NUMBER
    }

    pub fn set_solution(&mut self, solution: String) {
        self.crossword_solution = solution;
    }

    pub fn guess_solution(&mut self, solution: String) -> bool {
        let hashed_attempt = hex::encode(env::sha256(solution.as_bytes()));
        if hashed_attempt == self.crossword_solution {
            env::log_str("You guessed right!")
        } else {
            env::log_str("Try again.")
        }
        hashed_attempt == self.crossword_solution
    }
}
```

```
#[test]
    fn check_guess_solution() {
        // Get Alice as an account ID
        let alice = AccountId::new_unchecked("alice.testnet".to_string());
        // Set up the testing context and unit test environment
        let context = get_context(alice);
        testing_env!(context.build());

        // Set up contract object and call the new method
        let mut contract = Contract {
            crossword_solution: "69c2feb084439956193f4c21936025f14a5a5a78979d67ae34762e18a7206a0f".to_string()
        };
        let mut guess_result = contract.guess_solution("wrong answer here".to_string());
        assert!(!guess_result, "Expected a failure from the wrong guess");
        assert_eq!(get_logs(), ["Try again."], "Expected a failure log.");
        guess_result = contract.guess_solution("near nomicon ref finance".to_string());
        assert!(guess_result, "Expected the correct answer to return true.");
        assert_eq!(
            get_logs(),
            ["Try again.", "You guessed right!"],
            "Expected a successful log after the previous failed log."
        );
    }
```

which was rather disappointing.

'''
'''--- 31-aoc-day2-part1.md ---
**Advent of Code in Go, Day 1 Part 1**

[_Well, our Prime Minister has very reluctantly resigned but he's talking about staying around until October so he and his partner can use the official residence for their summer hols._]

This post has been a long time coming.

This is continued from [15 days ago](https://wc3.akimbo.com/t/andrew-whitehouse-dailies/61070/495?u=andrewwhitehouse).

There was something that was bothering me about the previous post; there are a number of points in the code where we encounter a possible error condition. 

The function signature looks like this:

```
func Parse(s string) ([]Command, error) {
```

which returns a tuple consisting of a Command array, and an error. If the function succeeds, the error is _nil_ which means "no value". If the function encounters an error, we want to return a non-value" for the command array. (The same issue applies for the individual commands, too).

Golang parameters are passed by value, which means the parameter value is copied. Changing the passed value inside the function doesn't change the value in the caller.

If we pass a pointer, we can use the nil value to represent "no value", like this `func Parse(s string) ([]*Command, error) {`

But this seems like an unnecessary use of points.

On further [reading](https://medium.com/@annapeterson89/whats-the-point-of-golang-pointers-everything-you-need-to-know-ac5e40581d4d) I concluded that using pointers isn't appropriate, so I needed to define another non-value.

I did it like this:

`command.go`

```
const (
	None    Direction = 0
	Forward Direction = 1
	Up      Direction = 2
	Down    Direction = 3
)
```

`parse.go`

```
func parseLine(s string) (Command, error) {
	parts := strings.Split(strings.TrimSpace(s), " ")
	var direction Direction
	noCommand := newCommand(None, 0)
	switch {
	case parts[0] == "forward":
		direction = Forward
	case parts[0] == "up":
		direction = Up
	case parts[0] == "down":
		direction = Down
	default:
		return noCommand, fmt.Errorf("unrecognised direction %s", s)
	}
	distance, err := strconv.Atoi(parts[1])
	if err != nil {
		return noCommand, err
	}
	result := newCommand(direction, uint16(distance))
	return result, nil
}
```

I updated the tests too.

Having done this, I then wrote the Day2 (part 1) logic:

`day2.go`

```
type Position struct {
	distance uint16
	depth    uint16
}

func Navigate(commands []Command) Position {
	position := Position{0, 0}
	for _, command := range commands {
		switch command.direction {
		case Forward:
			position.distance += command.distance
		case Down:
			position.depth += command.distance
		case Up:
			position.depth -= command.distance
		}
	}
	return position
}

func Part1(content string) (uint64, error) {
	commands, err := Parse(content)
	if err != nil {
		return 0, err
	}
	position := Navigate(commands)
	return uint64(position.depth) * uint64(position.distance), nil
}
```

The original uint16 type may not be too small to handle an arbitrarily long list of positions, and then multiply them at the end. uint32 _may_ be big enough but I opted to 64 bits instead to be safe. Frankly I'm guessing on how big the values should be without looking at the test data and considering what the eventual value should be. 32 bits probably would have been enough, actually.

Here's the function in `main.go` that brings it together for part 1:

```
func solveDay2() {
	content := loadContent("input/day2.txt")
	part1Result, _ := day2.Part1(content)
	fmt.Printf("Day 2 Part 1 %d\n", part1Result)
}
```

And the result ...

```
$ go run main.go
Day 1 Part 1 1342
Day 1 Part 2 1378
Day 2 Part 1 1636725
$ 
```

@beaver

'''
'''--- code/clojure/sicp/CHANGELOG.md ---
# Change Log
All notable changes to this project will be documented in this file. This change log follows the conventions of [keepachangelog.com](http://keepachangelog.com/).

## [Unreleased]
### Changed
- Add a new arity to `make-widget-async` to provide a different widget shape.

## [0.1.1] - 2022-05-20
### Changed
- Documentation on how to make the widgets.

### Removed
- `make-widget-sync` - we're all async, all the time.

### Fixed
- Fixed widget maker to keep working when daylight savings switches over.

## 0.1.0 - 2022-05-20
### Added
- Files from the new template.
- Widget maker public API - `make-widget-sync`.

[Unreleased]: https://github.com/your-name/sicp/compare/0.1.1...HEAD
[0.1.1]: https://github.com/your-name/sicp/compare/0.1.0...0.1.1

'''
'''--- code/clojure/sicp/README.md ---
# sicp

A Clojure library designed to ... well, that part is up to you.

## Usage

FIXME

## License

Copyright © 2022 FIXME

This program and the accompanying materials are made available under the
terms of the Eclipse Public License 2.0 which is available at
http://www.eclipse.org/legal/epl-2.0.

This Source Code may also be made available under the following Secondary
Licenses when the conditions for such availability set forth in the Eclipse
Public License, v. 2.0 are satisfied: GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or (at your
option) any later version, with the GNU Classpath Exception which is available
at https://www.gnu.org/software/classpath/license.html.

'''
'''--- code/clojure/sicp/doc/intro.md ---
# Introduction to sicp

TODO: write [great documentation](http://jacobian.org/writing/what-to-write/)

'''
'''--- code/go/aoc2021/.idea/workspace.xml ---
<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="AutoImportSettings">
    <option name="autoReloadType" value="ALL" />
  </component>
  <component name="ChangeListManager">
    <list default="true" id="59e070d5-c62a-4a6a-93be-16a426c39755" name="Changes" comment="" />
    <option name="SHOW_DIALOG" value="false" />
    <option name="HIGHLIGHT_CONFLICTS" value="true" />
    <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
    <option name="LAST_RESOLUTION" value="IGNORE" />
  </component>
  <component name="GOROOT" url="file:///usr/local/go" />
  <component name="Git.Settings">
    <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$" />
  </component>
  <component name="MarkdownSettingsMigration">
    <option name="stateVersion" value="1" />
  </component>
  <component name="ProjectId" id="2AHuOCghnAEy8rvFFkNYXQf2zGc" />
  <component name="ProjectViewState">
    <option name="hideEmptyMiddlePackages" value="true" />
    <option name="showLibraryContents" value="true" />
  </component>
  <component name="PropertiesComponent"><![CDATA[{
  "keyToString": {
    "RunOnceActivity.OpenProjectViewOnStart": "true",
    "RunOnceActivity.ShowReadmeOnStart": "true",
    "RunOnceActivity.go.format.on.save.advertiser.fired": "true",
    "RunOnceActivity.go.formatter.settings.were.checked": "true",
    "RunOnceActivity.go.migrated.go.modules.settings": "true",
    "RunOnceActivity.go.modules.go.list.on.any.changes.was.set": "true",
    "RunOnceActivity.go.watchers.conflict.with.on.save.actions.check.performed": "true",
    "WebServerToolWindowFactoryState": "false",
    "go.import.settings.migrated": "true",
    "go.sdk.automatically.set": "true",
    "last_opened_file_path": "/Users/andrewwhitehouse/code/active-projects/writing/code/go/aoc2021",
    "settings.editor.selected.configurable": "go.sdk"
  }
}]]></component>
  <component name="RunManager" selected="Go Test.TestCountIncreases in aoc2021/day1">
    <configuration name="go build main.go" type="GoApplicationRunConfiguration" factoryName="Go Application" temporary="true" nameIsGenerated="true">
      <module name="aoc2021" />
      <working_directory value="$PROJECT_DIR$" />
      <kind value="FILE" />
      <directory value="$PROJECT_DIR$" />
      <filePath value="$PROJECT_DIR$/main.go" />
      <method v="2" />
    </configuration>
    <configuration name="TestCountIncreases in aoc2021/day1" type="GoTestRunConfiguration" factoryName="Go Test" temporary="true" nameIsGenerated="true">
      <module name="aoc2021" />
      <working_directory value="$PROJECT_DIR$/day1" />
      <root_directory value="$PROJECT_DIR$" />
      <kind value="PACKAGE" />
      <package value="aoc2021/day1" />
      <directory value="$PROJECT_DIR$" />
      <filePath value="$PROJECT_DIR$" />
      <framework value="gotest" />
      <pattern value="^\QTestCountIncreases\E$" />
      <method v="2" />
    </configuration>
    <configuration name="TestSum in aoc2021/day1" type="GoTestRunConfiguration" factoryName="Go Test" temporary="true" nameIsGenerated="true">
      <module name="aoc2021" />
      <working_directory value="$PROJECT_DIR$/day1" />
      <root_directory value="$PROJECT_DIR$" />
      <kind value="PACKAGE" />
      <package value="aoc2021/day1" />
      <directory value="$PROJECT_DIR$" />
      <filePath value="$PROJECT_DIR$" />
      <framework value="gotest" />
      <pattern value="^\QTestSum\E$" />
      <method v="2" />
    </configuration>
    <configuration name="day1_test.go (1)" type="GoTestRunConfiguration" factoryName="Go Test" temporary="true" nameIsGenerated="true">
      <module name="aoc2021" />
      <working_directory value="$PROJECT_DIR$/day1" />
      <kind value="FILE" />
      <directory value="$PROJECT_DIR$" />
      <filePath value="$PROJECT_DIR$/day1/day1_test.go" />
      <framework value="gotest" />
      <method v="2" />
    </configuration>
    <configuration name="day1_test.go" type="GoTestRunConfiguration" factoryName="Go Test" temporary="true" nameIsGenerated="true">
      <module name="aoc2021" />
      <working_directory value="$PROJECT_DIR$" />
      <kind value="FILE" />
      <directory value="$PROJECT_DIR$" />
      <filePath value="$PROJECT_DIR$/day1_test.go" />
      <framework value="gotest" />
      <method v="2" />
    </configuration>
    <recent_temporary>
      <list>
        <item itemvalue="Go Test.TestCountIncreases in aoc2021/day1" />
        <item itemvalue="Go Test.TestSum in aoc2021/day1" />
        <item itemvalue="Go Build.go build main.go" />
        <item itemvalue="Go Test.day1_test.go" />
        <item itemvalue="Go Test.day1_test.go (1)" />
      </list>
    </recent_temporary>
  </component>
  <component name="SpellCheckerSettings" RuntimeDictionaries="0" Folders="0" CustomDictionaries="0" DefaultDictionary="application-level" UseSingleDictionary="true" transferred="true" />
  <component name="TypeScriptGeneratedFilesManager">
    <option name="version" value="3" />
  </component>
  <component name="VgoProject">
    <settings-migrated>true</settings-migrated>
  </component>
</project>
'''
'''--- code/go/aoc2021/day1/day1.go ---
package day1

func CountIncreases(depths []uint16) uint16 {
	var increases uint16 = 0
	for i := 1; i < len(depths); i++ {
		if depths[i] > depths[i-1] {
			increases++
		}
	}
	return increases
}

func SlidingWindow(depths []uint16) []uint16 {
	ret := make([]uint16, len(depths)-2)
	for i := 2; i < len(depths); i++ {
		ret[i-2] = depths[i] + depths[i-1] + depths[i-2]
	}
	return ret
}

func Part2(content string) (uint16, error) {
	values, err := Parse(content)
	if err != nil {
		return 0, err
	}
	return CountIncreases(SlidingWindow(values)), nil
}

func Part1(content string) (uint16, error) {
	values, err := Parse(content)
	if err != nil {
		return 0, err
	}
	return CountIncreases(values), nil
}

'''
'''--- code/go/aoc2021/day1/day1_test.go ---
package day1

import (
	"reflect"
	"testing"
)

func TestCountIncreases(t *testing.T) {
	depths := []uint16{199, 200, 208, 210, 200, 207, 240, 269, 260, 263}
	var expected uint16 = 7
	actual := CountIncreases(depths)
	if expected != actual {
		t.Errorf("CountIncreases was incorrect, got: %d, want: %d.", actual, expected)
	}
}

func TestPart1Integration(t *testing.T) {
	actual, _ := Part1("199\n200\n208\n210\n200\n207\n240\n269\n260\n263")
	expected := uint16(7)
	if expected != actual {
		t.Errorf("Part1 was incorrect, got: %d, want: %d.", actual, expected)
	}
}

func TestPart2Integration(t *testing.T) {
	actual, _ := Part2("199\n200\n208\n210\n200\n207\n240\n269\n260\n263")
	expected := uint16(5)
	if expected != actual {
		t.Errorf("Part2 was incorrect, got: %d, want: %d.", actual, expected)
	}
}

func TestSlidingWindow(t *testing.T) {
	depths := []uint16{199, 200, 208, 210, 200, 207, 240, 269, 260, 263}
	expected := []uint16{607, 618, 618, 617, 647, 716, 769, 792}
	actual := SlidingWindow(depths)
	if !reflect.DeepEqual(actual, expected) {
		t.Errorf("SlidingWindow was incorrect, got: %d, want: %d.", actual, expected)
	}
}

'''
'''--- code/go/aoc2021/day1/parse.go ---
package day1

import (
	"strconv"
	"strings"
)

func sliceAtoi(sa []string) ([]uint16, error) {
	si := make([]uint16, 0, len(sa))
	for _, a := range sa {
		i, err := strconv.Atoi(a)
		if err != nil {
			return si, err
		}
		si = append(si, uint16(i))
	}
	return si, nil
}

func Parse(content string) ([]uint16, error) {
	sliceData := strings.Split(strings.TrimSpace(content), "\n")
	return sliceAtoi(sliceData)
}

'''
'''--- code/go/aoc2021/day1/parse_test.go ---
package day1

import (
	"reflect"
	"testing"
)

func TestParseInput(t *testing.T) {
	actual, err := Parse("11\n13\n17\n19\n301")
	expected := []uint16{11, 13, 17, 19, 301}
	if err != nil {
		t.Error(err)
	}
	if !reflect.DeepEqual(actual, expected) {
		t.Errorf("Parse was incorrect, got: %v, want: %v.", actual, expected)
	}
}

'''
'''--- code/go/aoc2021/day2/command.go ---
package day2

type Direction uint16

const (
	None    Direction = 0
	Forward Direction = 1
	Up      Direction = 2
	Down    Direction = 3
)

type Command struct {
	direction Direction
	distance  uint16
}

func newCommand(direction Direction, distance uint16) Command {
	return Command{direction: direction, distance: distance}
}

'''
'''--- code/go/aoc2021/day2/command_test.go ---
package day2

import (
	"testing"
)

func TestNewCommand(t *testing.T) {
	command := newCommand(Up, 20)
	actualDirection := command.direction
	expectedDirection := Up
	if actualDirection != expectedDirection {
		t.Errorf("Command direction was incorrect, got: %d, want: %d.", actualDirection, expectedDirection)
	}
	expectedDistance := uint16(20)
	actualDistance := command.distance
	if actualDistance != expectedDistance {
		t.Errorf("Command distance was incorrect, got: %d, want: %d.", actualDirection, expectedDirection)
	}
}

'''
'''--- code/go/aoc2021/day2/day2.go ---
package day2

type Position struct {
	distance uint16
	depth    uint16
}

func Navigate(commands []Command) Position {
	position := Position{0, 0}
	for _, command := range commands {
		switch command.direction {
		case Forward:
			position.distance += command.distance
		case Down:
			position.depth += command.distance
		case Up:
			position.depth -= command.distance
		}
	}
	return position
}

func Part1(content string) (uint64, error) {
	commands, err := Parse(content)
	if err != nil {
		return 0, err
	}
	position := Navigate(commands)
	return uint64(position.depth) * uint64(position.distance), nil
}

'''
'''--- code/go/aoc2021/day2/day2_test.go ---
package day2

import (
	"reflect"
	"testing"
)

func TestNavigation(t *testing.T) {
	commands := []Command{
		newCommand(Forward, 5),
		newCommand(Down, 5),
		newCommand(Forward, 8),
		newCommand(Up, 3),
		newCommand(Down, 8),
		newCommand(Forward, 2),
	}
	position := Navigate(commands)
	expected := Position{distance: 15, depth: 10}
	if !reflect.DeepEqual(position, expected) {
		t.Errorf("End position was incorrect, got: %v, want: %v.", position, expected)
	}
}

func TestPart1Integration(t *testing.T) {
	expected := uint64(150)
	actual, _ := Part1("forward 5\ndown 5\nforward 8\nup 3\ndown 8\nforward 2")
	if actual != expected {
		t.Errorf("Part1 result was incorrect, got: %d, want: %d.", actual, expected)
	}
}

'''
'''--- code/go/aoc2021/day2/parse.go ---
package day2

import (
	"fmt"
	"strconv"
	"strings"
)

func parseLine(s string) (Command, error) {
	parts := strings.Split(strings.TrimSpace(s), " ")
	var direction Direction
	noCommand := newCommand(None, 0)
	switch {
	case parts[0] == "forward":
		direction = Forward
	case parts[0] == "up":
		direction = Up
	case parts[0] == "down":
		direction = Down
	default:
		return noCommand, fmt.Errorf("unrecognised direction %s", s)
	}
	distance, err := strconv.Atoi(parts[1])
	if err != nil {
		return noCommand, err
	}
	result := newCommand(direction, uint16(distance))
	return result, nil
}

func Parse(s string) ([]Command, error) {
	lines := strings.Split(strings.TrimSpace(s), "\n")
	ret := make([]Command, len(lines))
	for i := 0; i < len(ret); i++ {
		command, err := parseLine(lines[i])
		if err != nil {
			return nil, err
		}
		ret[i] = command
	}
	return ret, nil
}

'''
'''--- code/go/aoc2021/day2/parse_test.go ---
package day2

import (
	"reflect"
	"testing"
)

func TestParseInput(t *testing.T) {
	input := "forward 5\ndown 5\nforward 8\nup 3\ndown 8"
	actual, err := Parse(input)
	if err != nil {
		t.Fatal(err)
	}
	expected := []Command{
		newCommand(Forward, 5),
		newCommand(Down, 5),
		newCommand(Forward, 8),
		newCommand(Up, 3),
		newCommand(Down, 8),
	}
	if !reflect.DeepEqual(actual, expected) {
		t.Errorf("Parse was incorrect, got: %v, want: %v.", actual, expected)
	}
}

'''
'''--- code/go/aoc2021/input/day1.txt ---
176
184
196
199
204
206
219
215
216
217
218
230
231
214
210
189
174
170
162
167
173
182
177
179
180
182
198
201
200
207
203
213
231
222
223
224
209
217
228
236
243
241
260
262
258
260
254
270
271
278
264
263
262
260
261
234
229
233
208
210
211
210
206
207
209
199
201
218
210
206
207
218
221
229
233
234
235
246
253
254
260
259
253
254
275
277
295
296
299
333
334
336
337
339
347
374
369
371
376
371
374
375
371
374
381
383
384
395
396
400
395
397
399
389
396
390
404
411
412
428
424
433
431
437
473
489
486
488
479
480
484
474
475
471
492
493
501
512
509
506
519
523
522
521
535
548
531
519
523
522
516
512
522
547
581
582
580
579
580
600
595
592
587
588
591
592
583
586
584
597
610
592
581
583
578
575
582
579
587
594
592
593
599
605
609
610
609
601
604
608
609
613
614
612
614
626
627
636
656
652
655
656
678
680
686
687
654
663
669
664
668
647
652
659
653
654
656
637
638
621
620
621
609
604
612
616
612
617
614
610
607
608
613
617
624
625
622
604
606
610
609
607
605
618
622
635
636
640
667
668
664
674
675
682
694
698
704
717
723
724
699
695
693
674
670
683
685
683
676
675
678
677
675
657
670
675
673
658
660
673
685
675
676
677
671
689
688
690
691
692
709
713
712
715
739
731
734
762
764
746
728
729
727
730
745
773
781
787
806
807
808
815
822
837
844
842
841
850
853
838
841
845
846
844
849
846
847
859
851
854
857
873
882
892
896
883
896
895
886
879
878
877
878
881
891
898
913
914
920
922
928
929
915
917
918
913
926
929
937
939
940
936
938
939
948
946
951
950
918
917
924
917
918
921
919
917
929
950
985
988
991
996
1002
995
990
999
989
990
991
992
991
992
993
991
994
996
997
989
993
975
973
972
973
971
969
976
983
980
987
1003
1002
1000
993
994
993
972
970
991
988
989
993
996
1002
1003
1008
1007
1014
1015
1022
1012
1029
1030
1029
1030
1025
1026
1010
1006
1008
1006
1012
1015
1029
1067
1102
1107
1108
1103
1108
1103
1120
1119
1118
1119
1118
1119
1132
1137
1148
1150
1153
1166
1169
1199
1205
1208
1216
1210
1217
1216
1217
1218
1198
1199
1197
1198
1193
1202
1241
1242
1239
1241
1238
1233
1234
1235
1237
1228
1229
1235
1218
1236
1237
1208
1246
1251
1246
1248
1242
1241
1243
1231
1226
1224
1221
1220
1224
1219
1227
1214
1237
1261
1271
1268
1292
1304
1303
1312
1287
1286
1292
1295
1297
1304
1311
1312
1309
1314
1307
1316
1320
1319
1316
1333
1332
1316
1315
1320
1321
1335
1355
1353
1356
1325
1333
1335
1339
1360
1361
1362
1364
1361
1363
1362
1363
1364
1392
1397
1398
1405
1406
1408
1406
1394
1391
1407
1413
1415
1413
1419
1422
1416
1422
1421
1431
1433
1437
1439
1443
1446
1449
1439
1444
1452
1460
1468
1469
1486
1500
1507
1513
1512
1511
1531
1532
1541
1550
1557
1561
1557
1560
1563
1564
1565
1588
1589
1592
1591
1593
1598
1603
1590
1604
1608
1610
1623
1598
1592
1601
1598
1600
1601
1599
1609
1607
1608
1613
1605
1601
1605
1610
1611
1609
1608
1615
1620
1629
1628
1641
1632
1630
1635
1634
1629
1630
1632
1630
1641
1661
1655
1657
1653
1619
1629
1607
1600
1603
1591
1596
1599
1601
1582
1591
1593
1596
1597
1600
1596
1597
1603
1624
1630
1628
1626
1628
1631
1628
1629
1625
1627
1620
1613
1614
1638
1637
1626
1624
1623
1621
1620
1621
1598
1610
1611
1622
1629
1646
1655
1677
1678
1679
1699
1702
1715
1710
1722
1719
1715
1716
1724
1735
1734
1727
1743
1748
1745
1742
1755
1754
1734
1738
1729
1732
1733
1726
1723
1744
1745
1746
1748
1778
1777
1780
1792
1798
1799
1800
1793
1794
1797
1802
1796
1800
1820
1823
1824
1823
1828
1827
1824
1847
1842
1846
1847
1844
1833
1826
1834
1839
1846
1854
1842
1845
1860
1874
1869
1871
1869
1870
1874
1875
1891
1893
1894
1886
1885
1853
1871
1868
1866
1875
1885
1882
1883
1879
1884
1893
1918
1919
1932
1933
1930
1949
1952
1949
1945
1944
1930
1950
1952
1951
1981
1980
1992
1993
1981
1979
2007
1989
1987
1996
2006
2012
2028
2037
2041
2039
2046
2047
2055
2058
2079
2086
2087
2088
2079
2080
2079
2082
2089
2092
2097
2113
2115
2119
2109
2111
2110
2108
2100
2099
2107
2103
2104
2115
2110
2116
2117
2113
2120
2128
2129
2115
2114
2125
2148
2145
2147
2160
2159
2162
2155
2161
2162
2160
2162
2149
2150
2152
2170
2171
2172
2171
2186
2187
2186
2188
2196
2185
2195
2196
2200
2197
2195
2190
2191
2189
2199
2200
2208
2204
2203
2209
2231
2234
2247
2245
2277
2279
2281
2282
2279
2294
2296
2304
2287
2294
2293
2297
2311
2339
2343
2344
2323
2360
2369
2371
2372
2373
2372
2384
2383
2390
2412
2419
2421
2432
2428
2427
2449
2459
2456
2457
2459
2469
2472
2474
2472
2475
2487
2479
2481
2482
2481
2502
2492
2493
2496
2522
2529
2550
2551
2549
2547
2546
2551
2553
2555
2552
2547
2536
2534
2518
2517
2513
2511
2495
2508
2500
2501
2514
2524
2551
2552
2561
2563
2571
2573
2565
2559
2564
2565
2568
2570
2556
2546
2552
2554
2581
2574
2573
2572
2575
2577
2578
2579
2580
2579
2589
2586
2587
2611
2615
2614
2618
2619
2618
2626
2630
2623
2627
2628
2627
2628
2657
2658
2672
2673
2685
2668
2658
2660
2668
2669
2671
2673
2669
2668
2675
2668
2669
2652
2672
2675
2678
2677
2699
2700
2701
2712
2710
2712
2711
2710
2721
2722
2727
2731
2733
2731
2734
2738
2751
2745
2744
2750
2765
2767
2773
2771
2770
2773
2778
2782
2792
2796
2794
2806
2807
2820
2823
2836
2834
2827
2826
2830
2828
2829
2831
2838
2845
2846
2863
2860
2862
2861
2862
2863
2864
2871
2873
2874
2875
2893
2892
2893
2898
2924
2942
2956
2950
2952
2990
2993
2994
3001
3017
3022
3017
3016
3017
3012
3018
3019
3018
3048
3058
3059
3062
3072
3073
3071
3072
3065
3093
3094
3095
3094
3100
3101
3084
3085
3079
3077
3099
3100
3117
3118
3121
3122
3137
3108
3110
3109
3108
3113
3102
3103
3119
3122
3126
3132
3137
3132
3152
3153
3163
3164
3176
3175
3181
3190
3191
3198
3195
3177
3178
3177
3183
3202
3203
3192
3184
3185
3191
3196
3195
3173
3183
3182
3184
3185
3193
3210
3208
3207
3214
3221
3234
3233
3263
3284
3283
3284
3270
3259
3268
3253
3259
3246
3251
3246
3251
3256
3249
3251
3261
3260
3259
3267
3277
3273
3282
3286
3284
3285
3288
3295
3270
3269
3277
3276
3281
3280
3292
3293
3301
3306
3335
3336
3310
3309
3312
3318
3324
3340
3368
3371
3369
3370
3368
3367
3386
3388
3416
3420
3423
3433
3427
3438
3457
3469
3474
3479
3489
3507
3471
3468
3480
3486
3490
3493
3495
3496
3495
3479
3480
3485
3490
3489
3491
3488
3494
3493
3515
3517
3526
3519
3520
3525
3515
3516
3517
3508
3510
3512
3515
3536
3535
3530
3540
3542
3550
3530
3550
3553
3537
3536
3542
3547
3544
3562
3561
3551
3546
3547
3562
3561
3586
3593
3582
3586
3589
3600
3604
3605
3607
3608
3613
3624
3626
3652
3668
3669
3666
3674
3677
3668
3671
3673
3675
3657
3666
3655
3658
3662
3659
3660
3657
3655
3662
3657
3660
3661
3664
3675
3677
3661
3663
3669
3645
3646
3644
3645
3666
3677
3685
3686
3689
3697
3694
3703
3672
3676
3675
3706
3726
3742
3744
3765
3792
3793
3802
3805
3813
3816
3817
3826
3827
3828
3830
3826
3825
3824
3816
3821
3820
3821
3825
3846
3848
3847
3846
3849
3854
3844
3860
3859
3861
3863
3848
3845
3846
3853
3851
3850
3863
3865
3885
3912
3913
3914
3913
3901
3897
3927
3928
3927
3929
3931
3925
3912
3915
3919
3920
3896
3900
3904
3909
3919
3922
3923
3925
3944
3938
3937
3936
3944
3943
3942
3955
3944
3945
3948
3946
3939
3955
3957
3951
3950
3954
3966
3974
3987
3991
3987
3985
3981
3983
3986
3996
4002
4012
4031
4030
4031
4034
4018
4020
4007
4009
4019
4006
4011
4018
4022
4012
4014
4012
4013
4031
4046
4051
4054
4065
4070
4074
4080
4081
4080
4051
4058
4056
4054
4049
4054
4048
4065
4078
4082
4086
4099
4100
4106
4126
4118
4145
4141
4142
4153
4168
4176
4168
4167
4171
4172
4173
4137
4154
4150
4134
4137
4138
4137
4148
4151
4129
4131
4130
4132
4129
4155
4156
4157
4162
4179
4185
4187
4186
4177
4167
4174
4178
4176
4174
4177
4180
4192
4206
4212
4192
4201
4193
4213
4194
4201
4181
4184
4181
4192
4195
4205
4209
4199
4201
4200
4201
4219
4218
4220
4221
4235
4236
4229
4235
4233
4234
4240
4239
4211
4216
4223
4210
4224
4225
4223
4224
4223
4233
4232
4240
4248
4240
4241
4246
4247
4244
4245
4246
4256
4261
4274
4268
4288
4289
4290
4301
4299
4303
4304
4303
4297
4299
4288
4296
4293
4296
4295
4302
4303
4319
4313
4315
4320
4322
4326
4328
4337
4338
4351
4370
4381
4388
4413
4418
4417
4416
4415
4436
4440
4441
4464
4461
4468
4469
4471
4480
4496
4495
4496
4497
4494
4461
4462
4461
4462
4461
4457
4466
4467
4468
4469
4491
4497
4510
4500
4485
4497
4508
4506
4500
4501
4514
4516
4517
4516
4543
4549
4529
4523
4522
4540
4539
4540
4543
4545
4530
4532
4531
4533
4535
4511
4517
4520
4521
4523
4517
4525
4526
4538
4566
4567
4564
4575
4577
4576
4574
4580
4594
4595
4596
4621
4622
4629
4632
4641
4642
4658
4659
4660
4685
4687
4708
4727
4735
4739
4745
4744
4753
4755
4757
4759
4782
4785
4777
4783
4786
4789
4794
4802
4803
4833
4849
4857
4865
4866
4872
4869
4876
4874
4877
4899
4900
4901
4893
4892
4904
4907
4900
4907
4908
4903
4890
4895
4896
4876
4880
4888
4889
4894
4893
4924
4927
4922
4893
4901
4891
4908
4916
4915
4920
4931
4954
4943
4953
4954
4959
4949
4952
4936
4935
4916
4922
4923
4922
4928
4929
4930
4927
4923
4926
4924
4931
4935
4955
4966
4987
4988
4990
4992
4991
4999
5001
5006
5007
5021
5034
5047
5050
5055
5091
5096
5101
5100
5105
5108
5117
5114
5127
5129
5127
5153
5152
5154
5155
5156
5142
5154
5180
5177
5183
5184
5201
5204
5205
5222
5212
5217
5222
5251
5278
5277
5302
5319
5326
5333
5327
5321
5337
5361
5362
5368
5369
5366
5368
5385
5383
5384
5393
5403
5427
5428
5429
5428
5459
5442
5441
5433
5436
5428
5429
5428
5427
5433
5418
5419
5421
5425
5426
5435
5441
5445
5442
5446
5454
5458
5454
5456
5452
5423
5426
5425
5418
5417
5420
5425
5420
5438
5447
5450
5451
5453
5450
5453
5449
5457
5464
5455
5460
5443
5439
5425
5423
5434
5438
5437
5412
5408
5405
5407
5420
5426
5452
5459
5460
5490
5498
5508
5528
5531
5516
5517
5512
5524
5529
5511
5525
5527
5538
5539
5546
5550
5549
5552
5554
5559
5551
5552
5556
5559
5579
5584
5590
5593
5592
5595
5604
5600
5586
5591
5572
5571
5583
5584
5578
5579
5580
5579
5570
5571
5574
5577
5583
5584
5569
5586
5582
5561
5550
5554
5544
5550
5529
5538
5551
5569
5570
5584
5588
5596
'''
'''--- code/go/aoc2021/input/day2.txt ---
forward 5
forward 2
forward 9
down 2
forward 9
forward 3
forward 2
down 6
forward 3
forward 3
down 3
down 3
forward 8
down 5
forward 7
forward 9
forward 9
forward 6
forward 9
forward 3
forward 3
forward 1
forward 7
down 6
forward 7
forward 4
down 3
down 1
forward 4
down 7
down 2
down 8
forward 9
down 5
down 2
forward 6
up 4
down 3
down 1
down 6
down 7
forward 6
up 2
forward 2
down 9
down 3
forward 7
up 3
up 7
forward 8
forward 7
down 4
up 8
up 1
forward 4
down 6
forward 9
forward 3
down 1
down 1
forward 2
forward 4
forward 3
up 2
forward 1
down 8
forward 4
down 5
forward 9
up 1
forward 3
forward 6
up 8
forward 1
forward 7
up 9
down 3
up 7
down 1
forward 5
forward 3
forward 7
down 5
down 1
down 2
down 4
down 5
down 5
down 8
up 9
down 7
down 7
down 6
forward 3
forward 5
forward 1
forward 8
up 4
down 8
down 3
down 1
down 9
down 3
down 9
down 8
down 2
forward 1
forward 7
forward 1
down 3
down 1
up 3
down 6
forward 6
forward 6
down 8
forward 3
down 1
forward 2
down 4
down 7
up 8
forward 4
down 4
up 1
forward 6
down 6
forward 5
forward 9
up 5
down 3
up 9
down 6
up 3
down 9
down 4
down 2
forward 3
down 6
down 7
down 9
forward 7
forward 2
forward 5
up 6
down 8
forward 1
down 2
forward 8
down 5
down 2
up 4
forward 9
up 4
down 4
down 2
forward 3
up 2
down 5
down 9
up 4
forward 9
down 5
down 2
down 2
forward 9
up 9
forward 6
up 7
down 2
forward 8
down 1
forward 2
down 3
up 6
down 4
forward 5
up 4
forward 5
forward 9
forward 9
forward 5
down 1
down 7
forward 6
forward 9
forward 3
forward 4
up 8
down 1
up 1
down 3
up 1
down 5
forward 6
up 5
up 6
down 9
forward 7
down 7
forward 1
forward 2
up 4
forward 4
down 9
up 4
down 6
forward 1
up 9
forward 2
down 8
forward 6
forward 6
down 6
forward 5
forward 9
up 8
down 4
forward 8
up 6
down 4
up 9
forward 2
down 8
down 6
forward 2
down 3
forward 1
forward 3
forward 2
up 4
down 6
up 6
down 4
down 2
forward 1
up 7
forward 9
forward 9
forward 7
down 1
down 9
forward 5
forward 4
forward 1
forward 4
down 5
forward 6
forward 8
down 5
down 7
up 2
up 1
forward 5
down 5
down 1
down 5
down 8
down 8
down 5
forward 7
down 6
down 2
forward 9
forward 1
forward 3
forward 4
up 3
down 4
up 7
forward 8
forward 7
up 4
down 9
forward 7
forward 6
up 1
down 1
up 6
down 5
up 1
forward 2
down 2
forward 3
down 6
up 5
up 4
down 8
down 5
down 3
down 4
up 3
down 3
down 2
down 7
up 2
down 8
forward 5
up 1
forward 9
down 6
down 6
down 8
up 4
forward 9
forward 8
up 7
down 9
down 4
forward 9
forward 9
up 2
down 1
forward 1
forward 4
forward 2
forward 9
down 1
down 3
down 1
down 3
up 5
down 2
forward 4
down 2
forward 1
down 6
up 9
down 3
forward 1
forward 5
forward 8
down 5
down 6
down 9
forward 4
down 7
up 8
forward 8
down 9
forward 6
down 8
up 3
forward 4
up 9
down 7
up 7
forward 6
forward 1
up 9
down 7
up 7
down 5
forward 6
up 7
down 8
down 8
forward 4
up 4
forward 1
forward 6
down 4
up 9
forward 4
up 1
up 8
up 6
forward 9
forward 4
forward 7
up 1
down 5
up 5
up 5
forward 4
down 9
up 8
down 6
down 3
down 6
forward 2
up 1
forward 3
up 8
down 1
forward 5
down 9
forward 4
up 5
forward 3
forward 2
down 8
down 9
up 6
down 9
down 7
forward 5
forward 4
forward 9
up 8
forward 3
down 7
forward 9
down 8
forward 4
forward 8
up 9
up 9
down 6
forward 5
forward 5
forward 5
up 2
up 2
up 1
down 6
forward 2
forward 2
down 8
down 6
up 2
forward 1
down 1
up 5
forward 7
down 2
forward 1
forward 3
down 5
down 7
forward 8
forward 4
forward 9
up 1
up 7
up 9
forward 3
up 1
forward 6
forward 3
forward 9
up 9
down 6
forward 8
up 6
down 9
forward 3
forward 7
down 9
forward 4
forward 5
forward 7
down 1
down 4
down 3
forward 6
down 3
forward 7
forward 8
down 1
forward 3
down 4
up 7
forward 2
forward 8
down 6
up 3
down 2
forward 9
forward 5
forward 7
up 2
up 6
down 9
forward 1
up 5
forward 1
up 6
up 2
up 1
forward 6
down 8
forward 7
down 5
forward 3
down 9
down 4
forward 3
down 1
up 1
up 7
forward 4
down 6
forward 3
forward 2
down 8
forward 9
forward 6
up 3
down 3
down 1
down 7
up 8
up 2
up 8
forward 6
forward 8
forward 6
forward 4
down 6
forward 6
forward 6
forward 1
down 2
forward 2
forward 6
down 1
up 6
forward 3
forward 9
forward 6
down 2
forward 2
up 4
down 2
up 4
forward 2
forward 2
forward 3
up 1
forward 8
forward 3
forward 3
forward 1
down 5
down 9
forward 4
down 1
forward 5
forward 2
down 5
forward 6
forward 3
up 3
forward 6
forward 9
forward 5
down 2
down 2
down 7
forward 8
down 1
down 5
down 9
up 3
up 5
up 4
forward 3
down 9
down 2
down 8
down 5
down 2
forward 4
up 3
down 5
up 3
down 8
down 7
up 1
forward 2
forward 1
down 2
up 1
up 5
down 8
down 3
up 9
forward 2
down 8
down 4
down 3
forward 3
forward 7
up 1
down 9
forward 1
down 6
up 3
up 5
down 6
up 4
forward 7
up 4
forward 9
up 4
forward 4
down 7
down 2
down 8
up 3
down 7
down 4
up 5
forward 8
down 8
down 1
forward 7
up 9
down 5
up 8
down 1
up 3
forward 8
up 4
down 1
up 1
up 7
forward 3
forward 6
forward 5
forward 2
down 4
forward 2
down 7
up 7
up 6
down 4
forward 4
forward 9
forward 7
down 4
down 6
forward 5
down 2
down 6
down 2
down 2
forward 9
up 5
forward 9
down 3
down 6
down 1
forward 5
down 5
forward 7
forward 9
up 8
forward 6
down 6
down 2
forward 8
forward 5
up 9
up 4
forward 1
forward 2
forward 2
up 9
down 6
forward 6
forward 8
up 5
up 7
forward 4
down 3
forward 1
up 6
up 9
forward 6
up 8
forward 5
down 4
forward 1
down 3
forward 1
forward 6
forward 2
up 4
down 6
forward 9
down 2
forward 4
down 4
forward 3
down 5
down 2
forward 2
forward 2
up 1
forward 1
down 7
down 8
up 6
forward 8
forward 5
forward 8
down 6
forward 5
down 3
up 3
forward 4
up 9
forward 8
forward 4
down 3
forward 6
up 6
down 2
down 7
down 3
down 2
down 8
forward 5
down 9
up 6
down 6
forward 8
down 1
forward 8
down 1
down 1
forward 3
forward 9
down 6
forward 7
down 4
forward 1
forward 4
forward 3
down 6
forward 5
down 5
forward 1
forward 3
forward 8
down 9
up 8
up 6
up 6
forward 2
forward 9
down 4
down 8
forward 6
up 1
down 2
down 6
forward 6
forward 2
up 8
forward 6
down 9
down 1
forward 7
forward 6
forward 5
forward 6
down 6
up 7
down 9
forward 9
forward 3
forward 5
down 4
down 1
down 7
up 3
up 7
forward 6
forward 8
down 7
down 4
forward 7
down 6
up 1
forward 4
down 2
forward 4
forward 3
forward 4
forward 4
up 3
down 8
down 4
down 1
down 8
down 3
up 9
down 4
forward 7
down 6
up 2
down 8
up 9
down 6
forward 1
down 3
forward 9
down 9
forward 1
down 5
up 5
up 1
forward 8
down 8
down 9
down 5
down 2
down 5
forward 3
down 9
forward 4
forward 4
up 2
forward 8
forward 4
forward 1
down 5
forward 5
down 5
forward 6
forward 4
up 5
down 9
up 3
up 8
forward 5
forward 9
up 6
forward 6
down 5
forward 7
down 8
down 7
down 9
forward 4
down 8
forward 4
down 5
forward 6
forward 4
down 7
down 5
forward 4
down 3
up 4
forward 3
up 9
down 8
forward 9
forward 6
forward 9
down 1
forward 2
up 5
down 9
down 2
down 9
up 8
forward 7
forward 8
forward 4
down 1
up 8
forward 8
down 8
down 4
forward 9
down 3
forward 7
forward 9
down 5
forward 7
forward 1
forward 5
forward 2
down 4
forward 7
down 6
forward 3
down 9
forward 3
down 5
up 6
up 3
forward 1
up 9
down 1
forward 2
down 8
down 7
up 9
up 2
down 5
up 9
forward 9
forward 9
down 1
forward 5
up 5
forward 1
up 1
down 3
forward 3
down 3
forward 3
up 5
up 4
down 7
down 7
down 4
forward 7
down 6
forward 1
up 1
down 8
forward 4
down 3
forward 9
up 6
forward 6
forward 3
up 9
down 9
forward 4
up 5
down 3
down 8
down 3
down 3
forward 4
forward 6
forward 4
up 2
up 3
up 5
down 5
down 6
forward 5
forward 4
down 1
down 2
up 8
down 2
down 1
up 4
forward 5
forward 8
forward 8
forward 5
down 3
forward 4
up 8
forward 7
forward 4
down 9
down 6
forward 2
down 7
forward 6
up 7
up 1
up 4
forward 2
forward 9
forward 7
up 5
forward 2
up 5
forward 1
forward 2
forward 4
down 6
forward 2
up 6
up 7
forward 3
forward 2
forward 6
forward 4
forward 9
forward 6
up 6
forward 5
up 7
up 5
down 6
down 2
down 1
forward 7
down 5
down 1
down 7
forward 8
forward 8
forward 5
down 9
forward 6
'''
'''--- code/go/aoc2021/main.go ---
package main

import (
	"aoc2021/day1"
	"aoc2021/day2"
	"fmt"
	"io/ioutil"
	"os"
)

func loadContent(fileName string) string {
	fileBytes, err := ioutil.ReadFile(fileName)

	if err != nil {
		fmt.Println(err)
		os.Exit(1)
	}

	return string(fileBytes)
}

func solveDay1() {
	content := loadContent("input/day1.txt")
	part1Result, err := day1.Part1(content)
	if err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
	part2Result, err := day1.Part2(content)
	if err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
	fmt.Printf("Day 1 Part 1 %d\n", part1Result)
	fmt.Printf("Day 1 Part 2 %d\n", part2Result)
}

func solveDay2() {
	content := loadContent("input/day2.txt")
	part1Result, _ := day2.Part1(content)
	fmt.Printf("Day 2 Part 1 %d\n", part1Result)
}

func main() {
	solveDay1()
	solveDay2()
}

'''
'''--- code/go/chapter1/README.md ---
# Learning Go

Test refernece:

* https://blog.alexellis.io/golang-writing-unit-tests/

'''
'''--- code/go/chapter1/main.go ---
package main

import "fmt"

func Sum(x int, y int) int {
    return x + y
}

func main() {
    var x int = 5
    var y int = 10
    fmt.Printf("Sum of %d and %d is %d\n", x, y, Sum(x, y))
}

'''
'''--- code/go/chapter1/sum_test.go ---
package main

import "testing"

func TestSum(t *testing.T) {
    total := Sum(5, 5)
    if total != 10 {
       t.Errorf("Sum was incorrect, got: %d, want: %d.", total, 10)
    }
}

'''
'''--- code/python/README.md ---
# Python code samples

## Run All Tests

`python -m unittest discover -s . -p 'test_*.py'`

'''
'''--- code/python/chapter1/__init__.py ---
import math

def circumference(radius):
  return 2 * math.pi * radius

def square(x):
  return x*x

'''
'''--- code/python/test_chapter1.py ---
import unittest
from chapter1 import circumference

class TestChapter1(unittest.TestCase):

    def test_circumference(self):
        self.assertAlmostEqual(circumference(10), 62.8318, places=3)

if __name__ == '__main__':
    unittest.main()

'''
'''--- code/python/test_two_largest.py ---
import unittest
from two_largest import *

class TestTwoLargest(unittest.TestCase):

    def test_first_two(self):
        self.assertEqual([3,2], two_largest(3,2,1))

    def test_first_two_out_of_order(self):
        self.assertEqual([3,2], two_largest(2,3,1))

    def test_last_two_largest_in_order(self):
        self.assertEqual([6,5], two_largest(4,6,5))

    def test_last_two_out_of_order(self):
        self.assertEqual([9,8], two_largest(7,8,9))

    def test_first_and_last_in_order(self):
        self.assertEqual([102, 101], two_largest(102, 100, 101))

    def test_first_and_last_out_of_order(self):
        self.assertEqual([502, 501], two_largest(501, 500, 502))

    def test_all_equal(self):
        self.assertEqual([123, 123], two_largest(123, 123, 123))

    def test_negative_numbers(self):
        self.assertEqual([-10, -20], two_largest(-10, -20, -30))

    def test_decimals(self):
        self.assertEqual([2.001, 2.0003], two_largest(2.001, 2.0002, 2.0003))

if __name__ == '__main__':
    unittest.main()

'''
'''--- code/python/two_largest/__init__.py ---
def two_largest(*nums):
  if nums[1] > nums[0]:
    if nums[2] > nums[1]:
      return [nums[2], nums[1]]
    else:
      return [nums[1], max(nums[2], nums[0])]
  else:
    if nums[0] > nums[2]:
      return [nums[0], max(nums[2], nums[1])]
    else:
      return [nums[2], nums[0]]

'''
'''--- code/rust/ex1_3/Cargo.toml ---
[package]
name = "ex1_3"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]

'''
'''--- code/rust/ex1_3/src/lib.rs ---
fn two_largest(a: i32, b: i32, _c: i32) -> [i32; 2] {
    if a > b { [a, b] } else { [b, a] }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn should_return_first_two_if_in_descending_order() {
        assert_eq!([3, 2], two_largest(3, 2, 1));
    }

    #[test]
    fn should_return_first_two_if_in_ascending_order() {
        assert_eq!([3, 2], two_largest(2, 3, 1));
    }
}

'''
'''--- code/rust/sicp/Cargo.toml ---
[package]
name = "sicp"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
float_eq = "0.7"

'''
'''--- code/rust/sicp/src/lib.rs ---
use float_eq::assert_float_eq;

fn square(x: f64) -> f64 {
    x*x
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_squares() {
        assert_float_eq!(4.0, square(2.0), abs <= 0.000_1);
    }
}

'''