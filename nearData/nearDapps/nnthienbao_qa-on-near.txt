*GitHub Repository "nnthienbao/qa-on-near"*

'''--- .gitpod.yml ---
tasks:
  - init: yarn
    command: yarn dev
ports:
  - port: 1234
    onOpen: open-browser

'''
'''--- README.md ---
qa-on-near
==================

This [React] app was initialized with [create-near-app]

Quick Start
===========

To run this project locally:

1. Prerequisites: Make sure you've installed [Node.js] ≥ 12
2. Install dependencies: `yarn install`
3. Run the local development server: `yarn dev` (see `package.json` for a
   full list of `scripts` you can run with `yarn`)

Now you'll have a local development environment backed by the NEAR TestNet!

Go ahead and play with the app and the code. As you make code changes, the app will automatically reload.

Exploring The Code
==================

1. The "backend" code lives in the `/contract` folder. See the README there for
   more info.
2. The frontend code lives in the `/src` folder. `/src/index.html` is a great
   place to start exploring. Note that it loads in `/src/index.js`, where you
   can learn how the frontend connects to the NEAR blockchain.
3. Tests: there are different kinds of tests for the frontend and the smart
   contract. See `contract/README` for info about how it's tested. The frontend
   code gets tested with [jest]. You can run both of these at once with `yarn
   run test`.

Deploy
======

Every smart contract in NEAR has its [own associated account][NEAR accounts]. When you run `yarn dev`, your smart contract gets deployed to the live NEAR TestNet with a throwaway account. When you're ready to make it permanent, here's how.

Step 0: Install near-cli (optional)
-------------------------------------

[near-cli] is a command line interface (CLI) for interacting with the NEAR blockchain. It was installed to the local `node_modules` folder when you ran `yarn install`, but for best ergonomics you may want to install it globally:

    yarn install --global near-cli

Or, if you'd rather use the locally-installed version, you can prefix all `near` commands with `npx`

Ensure that it's installed with `near --version` (or `npx near --version`)

Step 1: Create an account for the contract
------------------------------------------

Each account on NEAR can have at most one contract deployed to it. If you've already created an account such as `your-name.testnet`, you can deploy your contract to `qa-on-near.your-name.testnet`. Assuming you've already created an account on [NEAR Wallet], here's how to create `qa-on-near.your-name.testnet`:

1. Authorize NEAR CLI, following the commands it gives you:

      near login

2. Create a subaccount (replace `YOUR-NAME` below with your actual account name):

      near create-account qa-on-near.YOUR-NAME.testnet --masterAccount YOUR-NAME.testnet

Step 2: set contract name in code
---------------------------------

Modify the line in `src/config.js` that sets the account name of the contract. Set it to the account id you used above.

    const CONTRACT_NAME = process.env.CONTRACT_NAME || 'qa-on-near.YOUR-NAME.testnet'

Step 3: deploy!
---------------

One command:

    yarn deploy

As you can see in `package.json`, this does two things:

1. builds & deploys smart contract to NEAR TestNet
2. builds & deploys frontend code to GitHub using [gh-pages]. This will only work if the project already has a repository set up on GitHub. Feel free to modify the `deploy` script in `package.json` to deploy elsewhere.

Troubleshooting
===============

On Windows, if you're seeing an error containing `EPERM` it may be related to spaces in your path. Please see [this issue](https://github.com/zkat/npx/issues/209) for more details.

  [React]: https://reactjs.org/
  [create-near-app]: https://github.com/near/create-near-app
  [Node.js]: https://nodejs.org/en/download/package-manager/
  [jest]: https://jestjs.io/
  [NEAR accounts]: https://docs.near.org/docs/concepts/account
  [NEAR Wallet]: https://wallet.testnet.near.org/
  [near-cli]: https://github.com/near/near-cli
  [gh-pages]: https://github.com/tschaub/gh-pages

'''
'''--- babel.config.js ---
module.exports = {
  presets: ['@babel/preset-env', '@babel/preset-react'],
}

'''
'''--- cmd.txt ---
near create-account qa.rubikone.testnet --masterAccount rubikone.testnet --initialBalance 10
near deploy --accountId qa.rubikone.testnet --wasmFile out/example.wasm

near delete qa.rubikone.testnet rubikone.testnet

dev-1638288482433-31324609140057

export ACCOUNT_ID=rubikone.testnet

near call qa.rubikone.testnet create_question '{"question":{"title":"Price of NEAR at the end of the year","content":"What is the price of NEAR at the end of the year?"}}' --accountId $ACCOUNT_ID
https://explorer.testnet.near.org/transactions/Bbu7Jftc1JBE8Ctdn1P26rSEPsv1j2eYc41MJjaAhrqU

near call qa.rubikone.testnet create_answer '{"answer":{"question_id":"1638371106338209321","content":"I am sure over 30 usd"}}' --accountId $ACCOUNT_ID
https://explorer.testnet.near.org/transactions/Gntr7x2Q3BR3WCzrpcabLCJmievj3Defm7P3jPf7uDqa

near call qa.rubikone.testnet vote_question '{"question_id":"1638371106338209321"}' --accountId $ACCOUNT_ID
https://explorer.testnet.near.org/transactions/8ooZ3SjW1XnhHe2EfdXan3SGAbgv1fLTTRFC8NHnZCh

near call qa.rubikone.testnet vote_answer '{"answer_id":"1638371162028607310"}' --accountId $ACCOUNT_ID
https://explorer.testnet.near.org/transactions/6KJjvQkPq52Z1yGedFH5gxdzKpBKnUyCzkYtWkBzFxeT

near call qa.rubikone.testnet donate '{"donation":{"answer_id":"1638371162028607310","amount":5}}' --accountId $ACCOUNT_ID
https://explorer.testnet.near.org/transactions/ELYGGd63Zr4ZstAKD4hwfnJ3EHkF8gWMwEVSm3KrT2XH

near view qa.rubikone.testnet get_list_question '' --accountId $ACCOUNT_ID

near view qa.rubikone.testnet get_question_detail '{"question_id": "1638371106338209321"}' --accountId $ACCOUNT_ID

near view qa.rubikone.testnet get_answer_detail '{"answer_id": "1638371162028607310"}' --accountId $ACCOUNT_ID

near view qa.rubikone.testnet get_list_answer_for_question '{"question_id": "1638371106338209321"}' --accountId $ACCOUNT_ID

near view qa.rubikone.testnet get_donate_history '{"answer_id": "1638371162028607310"}' --accountId $ACCOUNT_ID
'''
'''--- contract/Cargo.toml ---
[package]
name = "greeter"
version = "0.1.0"
authors = ["Near Inc <hello@near.org>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true

[workspace]
members = []

'''
'''--- contract/README.md ---
qa-on-near Smart Contract
==================

A [smart contract] written in [Rust] for an app initialized with [create-near-app]

Quick Start
===========

Before you compile this code, you will need to install Rust with [correct target]

Exploring The Code
==================

1. The main smart contract code lives in `src/lib.rs`. You can compile it with
   the `./compile` script.
2. Tests: You can run smart contract tests with the `./test` script. This runs
   standard Rust tests using [cargo] with a `--nocapture` flag so that you
   can see any debug info you print to the console.

  [smart contract]: https://docs.near.org/docs/develop/contracts/overview
  [Rust]: https://www.rust-lang.org/
  [create-near-app]: https://github.com/near/create-near-app
  [correct target]: https://github.com/near/near-sdk-rs#pre-requisites
  [cargo]: https://doc.rust-lang.org/book/ch01-03-hello-cargo.html

'''
'''--- contract/compile.js ---
// This file does two things:
//
// 1. Compile the Rust contract using cargo (see buildCmd below). This will
//    create a wasm file in the 'build' folder.
// 2. Create a symbolic link (symlink) to the generated wasm file in the root
//    project's `out` folder, for easy use with near-cli.
//
// First, import some helper libraries. `shelljs` is included in the
// devDependencies of the root project, which is why it's available here. It
// makes it easy to use *NIX-style scripting (which works on Linux distros,
// macOS, and Unix systems) on Windows as well.
const sh = require('shelljs')

// Figure out which directory the user called this script from, which we'll use
// later to set up the symlink.
const calledFromDir = sh.pwd().toString()

// For the duration of this script, we want to operate from within the
// Rust project's folder. Let's change into that directory.
sh.cd(__dirname)

// You can call this script with `node compile.js` or `node compile.js
// --debug`. Let's set a variable to track whether `--debug` was used.
const debug = process.argv.pop() === '--debug'

// You can call this script with `node compile.js` or `node compile.js --debug`.
// Let's set a variable to track whether `--debug` was used.
// Note: see other flags in ./cargo/config. Unfortunately, you cannot set the
// `--target option` in Cargo.toml.
const buildCmd = debug
  ? 'cargo build --target wasm32-unknown-unknown'
  : 'cargo build --target wasm32-unknown-unknown --release'

// Execute the build command, storing exit code for later use
const { code } = sh.exec(buildCmd)

// Assuming this is compiled from the root project directory, link the compiled
// contract to the `out` folder –
// When running commands like `near deploy`, near-cli looks for a contract at
// <CURRENT_DIRECTORY>/out/main.wasm
if (code === 0 && calledFromDir !== __dirname) {
  const linkDir = `${calledFromDir}/out`
  const link = `${calledFromDir}/out/main.wasm`
  const packageName = require('fs').readFileSync(`${__dirname}/Cargo.toml`).toString().match(/name = "([^"]+)"/)[1]
  const outFile = `./target/wasm32-unknown-unknown/${debug ? 'debug' : 'release'}/${packageName}.wasm`
  sh.mkdir('-p', linkDir)
  sh.rm('-f', link)
  //fixes #831: copy-update instead of linking .- sometimes sh.ln does not work on Windows
  sh.cp('-u',outFile,link)
}

// exit script with the same code as the build command
process.exit(code)

'''
'''--- contract/src/lib.rs ---
/*
 * This is an example of a Rust smart contract with two simple, symmetric functions:
 *
 * 1. set_greeting: accepts a greeting, such as "howdy", and records it for the user (account_id)
 *    who sent the request
 * 2. get_greeting: accepts an account_id and returns the greeting saved for it, defaulting to
 *    "Hello"
 *
 * Learn more about writing NEAR smart contracts with Rust:
 * https://github.com/near/near-sdk-rs
 *
 */

// To conserve gas, efficient serialization is achieved through Borsh (http://borsh.io/)
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LookupMap, UnorderedMap, UnorderedSet};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{env, near_bindgen, setup_alloc};

setup_alloc!();

#[derive(BorshDeserialize, BorshSerialize, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Question {
  question_id: String,
  title: String,
  content: String,
  total_vote: i32,
  total_answer: i32,
  created_time: i64,
  creator_id: String,
}

#[derive(BorshDeserialize, BorshSerialize, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Answer {
  answer_id: String,
  question_id: String,
  content: String,
  total_vote: i32,
  total_amount_donate: u64,
  created_time: i64,
  creator_id: String,
}

#[derive(BorshDeserialize, BorshSerialize, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct DonateInfo {
  donate_info_id: String,
  answer_id: String,
  donate_creator_id: String,
  created_time: i64,
  amount: u64,
}

#[derive(BorshDeserialize, BorshSerialize, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct QuestionCreateDto {
  title: String,
  content: String,
}

#[derive(BorshDeserialize, BorshSerialize, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct AnswerCreateDto {
  question_id: String,
  content: String,
}

#[derive(BorshDeserialize, BorshSerialize, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct DonationCreateDto {
  answer_id: String,
  amount: u64,
}

// Structs in Rust are similar to other languages, and may include impl keyword as shown below
// Note: the names of the structs are not important when calling the smart contract, but the function names are
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct QAndANear {
  map_question: UnorderedMap<String, Question>,
  map_answer: LookupMap<String, Answer>,
  map_donation_info: LookupMap<String, DonateInfo>,
  map_question_answer: LookupMap<String, UnorderedSet<String>>, // question_id => list answers id
  map_answer_donation: LookupMap<String, UnorderedSet<String>>, // answer_id => list donation id info
}

impl Default for QAndANear {
  fn default() -> Self {
    Self {
      map_question: UnorderedMap::new(b"mq".to_vec()),
      map_answer: LookupMap::new(b"ma".to_vec()),
      map_donation_info: LookupMap::new(b"md".to_vec()),
      map_question_answer: LookupMap::new(b"mqa".to_vec()),
      map_answer_donation: LookupMap::new(b"mad".to_vec()),
    }
  }
}

#[near_bindgen]
impl QAndANear {
  pub fn create_question(&mut self, question: QuestionCreateDto) -> Option<Question> {
    let creator_id = env::signer_account_id();
    let question_save = Question {
      question_id: self.generate_id(),
      title: question.title,
      content: question.content,
      total_vote: 0,
      total_answer: 0,
      created_time: self.get_current_timestamp_in_millis(),
      creator_id: creator_id,
    };
    self.map_question_answer.insert(
      &question_save.question_id,
      &UnorderedSet::new(env::sha256(&question_save.question_id.as_bytes())),
    );
    self
      .map_question
      .insert(&question_save.question_id, &question_save);
    return self.map_question.get(&question_save.question_id);
  }

  pub fn create_answer(&mut self, answer: AnswerCreateDto) -> Option<Answer> {
    let creator_id = env::signer_account_id();
    let answer_save = Answer {
      answer_id: self.generate_id(),
      question_id: answer.question_id.clone(),
      content: answer.content,
      total_vote: 0,
      total_amount_donate: 0,
      created_time: self.get_current_timestamp_in_millis(),
      creator_id: creator_id,
    };
    match self.map_question.get(&answer.question_id.clone()) {
      Some(mut question) => match self.map_question_answer.get(&answer.question_id.clone()) {
        Some(mut set_question_answer) => {
          question.total_answer += 1;
          self
            .map_question
            .insert(&answer.question_id.clone(), &question);
          set_question_answer.insert(&answer_save.answer_id);
          self
            .map_question_answer
            .insert(&answer.question_id, &set_question_answer);
          self.map_answer_donation.insert(
            &answer_save.answer_id,
            &UnorderedSet::new(env::sha256(&answer_save.answer_id.as_bytes())),
          );
          self.map_answer.insert(&answer_save.answer_id, &answer_save);
          return self.map_answer.get(&answer_save.answer_id);
        }
        None => {
          env::panic(
            format!(
              "Set_question_answer not found for question_id {}",
              answer.question_id
            )
            .as_bytes(),
          );
        }
      },
      None => {
        env::panic(format!("Question not found for question_id {}", answer.question_id).as_bytes());
      }
    }
  }

  pub fn donate(&mut self, donation: DonationCreateDto) -> Option<DonateInfo> {
    let creator_id = env::signer_account_id();
    let answer_id = donation.answer_id.clone();
    let donation_save = DonateInfo {
      donate_info_id: self.generate_id(),
      answer_id: answer_id.clone(),
      donate_creator_id: creator_id,
      created_time: self.get_current_timestamp_in_millis(),
      amount: donation.amount,
    };
    // update answer total donate
    match self.map_answer.get(&answer_id) {
      Some(mut answer) => {
        // update map map_answer_donation
        match self.map_answer_donation.get(&answer_id) {
          Some(mut set_donation) => {
            if !(set_donation.insert(&donation_save.donate_info_id)) {
              env::panic(
                format!(
                  "Set donation has contain for donate_info_id {}",
                  donation_save.donate_info_id
                )
                .as_bytes(),
              );
            }
            answer.total_amount_donate += donation.amount;
            self.map_answer.insert(&answer.answer_id, &answer);
            self.map_answer_donation.insert(&answer_id, &set_donation);
            self
              .map_donation_info
              .insert(&donation_save.donate_info_id, &donation_save);
            return self.map_donation_info.get(&donation_save.donate_info_id);
          }
          None => {
            env::panic(
              format!("Map answer donation for answer_id {} not found", answer_id).as_bytes(),
            );
          }
        }
      }
      None => {
        env::panic(format!("Map answer for answer_id {} not found", answer_id).as_bytes());
      }
    }
  }

  pub fn get_list_question(&self) -> Vec<Question> {
    let mut vec_ret = <Vec<Question>>::new();
    for (_, question) in self.map_question.iter() {
      vec_ret.push(question);
    }
    return vec_ret;
  }

  pub fn get_question_detail(&self, question_id: String) -> Option<Question> {
    return self.map_question.get(&question_id);
  }

  pub fn get_answer_detail(&self, answer_id: String) -> Option<Answer> {
    return self.map_answer.get(&answer_id);
  }

  pub fn get_list_answer_for_question(&self, question_id: String) -> Vec<Answer> {
    let mut vec_ret = <Vec<Answer>>::new();
    match self.map_question_answer.get(&question_id) {
      Some(set_answer) => {
        for answer_id in set_answer.iter() {
          match self.map_answer.get(&answer_id) {
            Some(answer) => {
              vec_ret.push(answer);
            }
            None => {}
          }
        }
        return vec_ret;
      }
      None => {
        env::panic(format!("Question with question_id {} not found", question_id).as_bytes());
      }
    }
  }

  pub fn get_donate_history(&self, answer_id: String) -> Vec<DonateInfo> {
    let mut vec_ret = <Vec<DonateInfo>>::new();
    match self.map_answer_donation.get(&answer_id) {
      Some(set_donation) => {
        for donation_id in set_donation.iter() {
          match self.map_donation_info.get(&donation_id) {
            Some(donation) => {
              vec_ret.push(donation);
            }
            None => {}
          }
        }
        return vec_ret;
      }
      None => {
        env::panic(format!("Answer with answer_id {} not found", answer_id).as_bytes());
      }
    }
  }

  pub fn vote_question(&mut self, question_id: String) -> Option<Question> {
    match self.map_question.get(&question_id) {
      Some(mut question) => {
        question.total_vote += 1;
        return self.map_question.insert(&question_id, &question);
      }
      None => {
        env::panic(format!("Question with question_id {} not found", question_id).as_bytes());
      }
    }
  }

  pub fn vote_answer(&mut self, answer_id: String) -> Option<Answer> {
    match self.map_answer.get(&answer_id) {
      Some(mut answer) => {
        answer.total_vote += 1;
        return self.map_answer.insert(&answer_id, &answer);
      }
      None => {
        env::panic(format!("Answer with answer_id {} not found", answer_id).as_bytes());
      }
    }
  }

  #[private]
  pub fn generate_id(&self) -> String {
    return env::block_timestamp().to_string();
  }

  #[private]
  pub fn get_current_timestamp_in_millis(&self) -> i64 {
    return ((env::block_timestamp() / (86400 * 1000000000)) as i64) * (86400 * 1000);
  }
}

/*
 * The rest of this file holds the inline tests for the code above
 * Learn more about Rust tests: https://doc.rust-lang.org/book/ch11-01-writing-tests.html
 *
 * To run from contract directory:
 * cargo test -- --nocapture
 *
 * From project root, to run in combination with frontend tests:
 * yarn test
 *
 */
#[cfg(test)]
mod tests {
  use super::*;
  use near_sdk::MockedBlockchain;
  use near_sdk::{testing_env, VMContext};

  // mock the context for testing, notice "signer_account_id" that was accessed above from env::
  fn get_context(input: Vec<u8>, is_view: bool) -> VMContext {
    VMContext {
      current_account_id: "alice_near".to_string(),
      signer_account_id: "bob_near".to_string(),
      signer_account_pk: vec![0, 1, 2],
      predecessor_account_id: "carol_near".to_string(),
      input,
      block_index: 0,
      block_timestamp: 0,
      account_balance: 0,
      account_locked_balance: 0,
      storage_usage: 0,
      attached_deposit: 0,
      prepaid_gas: 10u64.pow(18),
      random_seed: vec![0, 1, 2],
      is_view,
      output_data_receivers: vec![],
      epoch_height: 19,
    }
  }

  #[test]
  fn test_default() {
    let context = get_context(vec![], false);
    testing_env!(context);
    QAndANear::default();
  }

  #[test]
  fn test_generate_id() {
    let context = get_context(vec![], false);
    testing_env!(context);
    let contract = QAndANear::default();
    let id1 = contract.generate_id();
    println!("{}", id1);
    let id2 = contract.generate_id();
    println!("{}", id2);
    assert_ne!(id1, id2);
  }

  #[test]
  fn should_create_question_success() {
    let context = get_context(vec![], false);
    testing_env!(context);
    let mut contract = QAndANear::default();
    let question_dto = QuestionCreateDto {
      title: "Test tiele".to_string(),
      content: "Test content".to_string(),
    };
    let ret = contract.create_question(question_dto);
    assert_eq!(ret.is_some(), true);
    let question_created = ret.unwrap();
    assert_eq!(question_created.title, "Test tiele".to_string());
    assert_eq!(question_created.content, "Test content".to_string());
    assert_eq!(question_created.question_id.is_empty(), false);
    assert_eq!(question_created.creator_id, "bob_near".to_string());
    assert_eq!(question_created.total_answer, 0);
    assert_eq!(question_created.total_vote, 0);
  }

  #[test]
  fn should_create_answer_success() {
    let context = get_context(vec![], false);
    testing_env!(context);
    let mut contract = QAndANear::default();
    let question_dto = QuestionCreateDto {
      title: "Test tiele".to_string(),
      content: "Test content".to_string(),
    };
    let question_created = contract.create_question(question_dto).unwrap();
    let answer_dto = AnswerCreateDto {
      question_id: question_created.question_id.clone(),
      content: "Answer content".to_string(),
    };
    let ret = contract.create_answer(answer_dto);
    assert_eq!(ret.is_some(), true);
    let answer_created = ret.unwrap();
    assert_eq!(answer_created.answer_id.is_empty(), false);
    assert_eq!(answer_created.content.is_empty(), false);
    assert_eq!(answer_created.creator_id, "bob_near".to_string());
    assert_eq!(
      answer_created.question_id.clone(),
      question_created.question_id.clone()
    );
    assert_eq!(answer_created.total_amount_donate, 0);
    assert_eq!(answer_created.total_vote, 0);

    let ret_op_question_after = contract.get_question_detail(question_created.question_id);
    assert_eq!(ret_op_question_after.is_some(), true);
    let question_after = ret_op_question_after.unwrap();
    assert_eq!(question_after.total_answer, 1);
  }

  #[test]
  fn should_donation_success() {
    let context = get_context(vec![], false);
    testing_env!(context);
    let mut contract = QAndANear::default();
    let question_dto = QuestionCreateDto {
      title: "Test tiele".to_string(),
      content: "Test content".to_string(),
    };
    let question_created = contract.create_question(question_dto).unwrap();
    let answer_dto = AnswerCreateDto {
      question_id: question_created.question_id.clone(),
      content: "Answer content".to_string(),
    };
    let answer_created = contract.create_answer(answer_dto).unwrap();

    let donation_dto = DonationCreateDto {
      answer_id: answer_created.answer_id.clone(),
      amount: 10,
    };
    let ret_op_donation_created = contract.donate(donation_dto);
    assert_eq!(ret_op_donation_created.is_some(), true);
    let donation_created = ret_op_donation_created.unwrap();
    assert_eq!(donation_created.donate_info_id.is_empty(), false);
    assert_eq!(
      donation_created.answer_id.clone(),
      answer_created.answer_id.clone()
    );
    assert_eq!(
      donation_created.donate_creator_id.clone(),
      "bob_near".to_string()
    );
    assert_eq!(donation_created.amount, 10);

    let ret_op_answer_after_donate = contract.get_answer_detail(answer_created.answer_id.clone());
    assert_eq!(ret_op_answer_after_donate.is_some(), true);
    let answer_after_donate = ret_op_answer_after_donate.unwrap();
    assert_eq!(answer_after_donate.total_amount_donate, 10);

    let donation_dto_2 = DonationCreateDto {
      answer_id: answer_created.answer_id.clone(),
      amount: 4,
    };
    contract.donate(donation_dto_2);
    let ret_op_answer_after_donate = contract.get_answer_detail(answer_created.answer_id.clone());
    assert_eq!(ret_op_answer_after_donate.is_some(), true);
    let answer_after_donate = ret_op_answer_after_donate.unwrap();
    assert_eq!(answer_after_donate.total_amount_donate, 14);
  }

  #[test]
  fn should_get_list_question_success() {
    let context = get_context(vec![], false);
    testing_env!(context);
    let mut contract = QAndANear::default();
    let question_dto = QuestionCreateDto {
      title: "Test tiele".to_string(),
      content: "Test content".to_string(),
    };
    contract.create_question(question_dto);
    let question_dto_2 = QuestionCreateDto {
      title: "Test tiele 2".to_string(),
      content: "Test content 2".to_string(),
    };
    contract.create_question(question_dto_2);
    let list_questions = contract.get_list_question();
    assert_eq!(list_questions.len(), 2);
  }

  #[test]
  fn should_get_list_answer_for_question_success() {
    let context = get_context(vec![], false);
    testing_env!(context);
    let mut contract = QAndANear::default();
    let question_dto = QuestionCreateDto {
      title: "Test tiele".to_string(),
      content: "Test content".to_string(),
    };
    let question_created = contract.create_question(question_dto).unwrap();
    let answer_dto = AnswerCreateDto {
      question_id: question_created.question_id.clone(),
      content: "Answer content".to_string(),
    };
    contract.create_answer(answer_dto);

    let answer_dto_2 = AnswerCreateDto {
      question_id: question_created.question_id.clone(),
      content: "Answer content_2".to_string(),
    };
    contract.create_answer(answer_dto_2);

    let list_answers = contract.get_list_answer_for_question(question_created.question_id.clone());
    assert_eq!(list_answers.len(), 2);
  }

  #[test]
  fn should_get_donate_history_success() {
    let context = get_context(vec![], false);
    testing_env!(context);
    let mut contract = QAndANear::default();
    let question_dto = QuestionCreateDto {
      title: "Test tiele".to_string(),
      content: "Test content".to_string(),
    };
    let question_created = contract.create_question(question_dto).unwrap();
    let answer_dto_1 = AnswerCreateDto {
      question_id: question_created.question_id.clone(),
      content: "Answer content".to_string(),
    };
    let answer_created_1 = contract.create_answer(answer_dto_1).unwrap();

    let answer_dto_2 = AnswerCreateDto {
      question_id: question_created.question_id.clone(),
      content: "Answer content_2".to_string(),
    };
    let answer_created_2 = contract.create_answer(answer_dto_2).unwrap();

    let donation_dto_1 = DonationCreateDto {
      answer_id: answer_created_1.answer_id.clone(),
      amount: 10,
    };
    contract.donate(donation_dto_1);
    let donation_dto_1_1 = DonationCreateDto {
      answer_id: answer_created_1.answer_id.clone(),
      amount: 14,
    };
    contract.donate(donation_dto_1_1);

    let donation_dto_2 = DonationCreateDto {
      answer_id: answer_created_2.answer_id.clone(),
      amount: 1,
    };
    contract.donate(donation_dto_2);

    let list_donation_1 = contract.get_donate_history(answer_created_1.answer_id.clone());
    assert_eq!(list_donation_1.len(), 2);

    let list_donation_2 = contract.get_donate_history(answer_created_2.answer_id.clone());
    assert_eq!(list_donation_2.len(), 1);
  }
}

'''
'''--- mention.md ---
- Người dùng có thể tạo 1 câu hỏi và người khác có thể trả lời, mỗi người chỉ được trả lời 1 lần cho 1 câu hỏi. 1 câu hỏi bao gồm title và nội dung. 1 câu hỏi có thể được vote hoặc không (vote nhiều sẽ được xếp lên đầu). Yêu cầu list câu hỏi hiển thị title, content được cắt ngắn, số lượng người vote, số câu trả lời, thời gian tạo câu hỏi và người tạo câu hỏi
- 1 câu trả lời có thể được nhiều người khác hữu ích hoặc không (1 người chỉ có thể chọn 1 trong 2). 1 câu trả lời cũng có thể được donate bằng NEAR (1 người có thể donate nhiều lần, số tiền donate sẽ được chuyển vào ví của người trả lời). Câu trả lời càng được hữu ích nhiều sẽ được xếp lên đầu. Yêu cầu hiển thị bao gồm số câu trả lời, mỗi câu trả lời hiển thị nội dung, số lượt 'hữu ích', số tiền donate, thời gian trả lời và địa chỉ người trả lời, có thể xem lịch sử donate cho câu trả lời đó

Data struct

Question {
    question_id: String,
    title: String,
    content: String,
    total_vote: Number,
    total_answer: Number,
    created_time: Number (timestamp),
    creator_id: String (address)
}

Answer {
    answer_id: String,
    question_id: String,
    content: String,
    total_useful: Number,
    total_amount_donate: Number,
    created_time: Number (timestamp),
    creator_id: String (address)
}

DonateInfo {
    donate_info_id: String,
    answer_id: String,
    donate_creator_id: String,
    created_time: Number (timestamp),
    amount: Number
}

Map<String, Question> mapQuestion;
Map<String, Answer> mapAnswer;
Map<String, DonateInfo> mapDonateInfo;
Map<String, Set<String>> mapQuestionUserId; track user answer only one
Map<String, Set<String>> mapQuestionAnswer; quesion_id => list answer id
Map<String, Set<String>> mapAnswerDonation; answer_id => list donate id;

dto:
    QuestionCreateDto {
        title: String,
        content: String,
    }
    AnswerCreateDto {
        question_id: String,
        content: String,
    }
    DonationCreateDto {
        answer_id: String,
        amount: Number
    }
method:
    call
        + create_question(questionCreateDto: QuestionCreateDto) : Question
        + create_answer(answerCreateDto: AnswerCreateDto) : Answer
        + donate(donationCreateDto: DonationCreateDto) : DonateInfo

    view
        + get_list_question() : List<Question>
        + get_question_detail(question_id: String) : Question
        + get_list_answer_for_question(question_id: String) : List<Answer>
        + get_donate_history(answer_id: String) : List<>

'''
'''--- package.json ---
{
  "name": "qa-on-near",
  "version": "0.1.0",
  "license": "UNLICENSED",
  "scripts": {
    "build": "npm run build:contract && npm run build:web",
    "build:contract": "node contract/compile.js",
    "build:contract:debug": "node contract/compile.js --debug",
    "build:web": "parcel build src/index.html --public-url ./",
    "dev:deploy:contract": "near dev-deploy",
    "deploy:contract": "near deploy",
    "deploy:pages": "gh-pages -d dist/",
    "deploy": "npm run build && npm run deploy:contract && npm run deploy:pages",
    "prestart": "npm run build:contract:debug && npm run dev:deploy:contract",
    "start": "echo The app is starting! It will automatically open in your browser when ready && env-cmd -f ./neardev/dev-account.env parcel src/index.html --open",
    "dev": "nodemon --watch contract/src -e rs --exec \"npm run start\"",
    "test": "npm run build:contract:debug && cd contract && cargo test -- --nocapture && cd .. && jest test --runInBand"
  },
  "devDependencies": {
    "@babel/core": "~7.14.0",
    "@babel/preset-env": "~7.14.0",
    "@babel/preset-react": "~7.13.13",
    "babel-jest": "~26.6.2",
    "env-cmd": "~10.1.0",
    "gh-pages": "~3.1.0",
    "jest": "~26.6.2",
    "jest-environment-node": "~26.6.2",
    "near-cli": "~2.1.1",
    "nodemon": "~2.0.3",
    "parcel-bundler": "~1.12.4",
    "react-test-renderer": "~17.0.1",
    "shelljs": "~0.8.4"
  },
  "dependencies": {
    "@emotion/react": "^11.7.0",
    "@emotion/styled": "^11.6.0",
    "@mui/icons-material": "^5.2.0",
    "@mui/material": "^5.0.0",
    "@types/react": "^16.8.6 || ^17.0.0",
    "near-api-js": "~0.43.1",
    "react": "^17.0.2",
    "react-dom": "~17.0.1",
    "react-router-dom": "^6.0.2",
    "regenerator-runtime": "~0.13.5"
  },
  "resolutions": {
    "@babel/preset-env": "7.13.8"
  },
  "jest": {
    "moduleNameMapper": {
      "\\.(jpg|ico|jpeg|png|gif|eot|otf|webp|svg|ttf|woff|woff2|mp4|webm|wav|mp3|m4a|aac|oga)$": "<rootDir>/src/__mocks__/fileMock.js",
      "\\.(css|less)$": "<rootDir>/src/__mocks__/fileMock.js"
    },
    "setupFiles": [
      "<rootDir>/src/jest.init.js"
    ],
    "testEnvironment": "near-cli/test_environment",
    "testPathIgnorePatterns": [
      "<rootDir>/contract/",
      "<rootDir>/node_modules/"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}

'''
'''--- src/App.js ---
import "regenerator-runtime/runtime";
import React, { useState, useEffect } from "react";
import { Routes, Route, Link, Switch } from 'react-router-dom';
import AppBar from "@mui/material/AppBar";
import Toolbar from "@mui/material/Toolbar";
import Typography from "@mui/material/Typography";
import Button from "@mui/material/Button";
import IconButton from "@mui/material/IconButton";
import MenuIcon from "@mui/icons-material/Menu";
import Grid from "@mui/material/Grid";
import { login, logout } from "./utils";
import HomePage from "./pages/HomePage";
import DetailQuestionPage from "./pages/DetailQuestionPage";

import getConfig from "./config";
const { networkId } = getConfig(process.env.NODE_ENV || "development");

export default function App({ walletConnection, accountId, contract }) {
  const [isSignIn, setIsSignIn] = useState(false);
  useEffect(() => {
    // in this case, we only care to query the contract when signed in
    if (walletConnection.isSignedIn()) {
      setIsSignIn(true);
    }
  }, []);
  return (
    <>
      <AppBar position="static">
        <Toolbar>
          <IconButton
            size="large"
            edge="start"
            color="inherit"
            aria-label="menu"
            sx={{ mr: 2 }}
          >
            <MenuIcon />
          </IconButton>
          <Typography variant="h6" component="div" sx={{ flexGrow: 1 }}>
            <h3>Q&A on NEAR</h3>
          </Typography>
          {isSignIn ? (
            <Button color="inherit" onClick={logout}>
              Logout
            </Button>
          ) : (
            <Button color="inherit" onClick={login}>
              Login
            </Button>
          )}
        </Toolbar>
      </AppBar>
      <Grid
        container
        spacing={2}
        direction="column"
        alignItems="center"
        justifyContent="center"
      >
        <Routes>
          <Route path="/" element={<HomePage />} />
          <Route path="/detail" element={<DetailQuestionPage />} />
        </Routes>
      </Grid>
    </>
  );
}

'''
'''--- src/__mocks__/fileMock.js ---
// NOTE: This is used to mock resource imports in JSX for tests
module.exports = '' 

'''
'''--- src/assets/logo-black.svg ---
<svg viewBox="0 0 288 288" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><linearGradient id="a" gradientUnits="userSpaceOnUse" x1="76.81" x2="211.16" y1="211.17" y2="76.81"><stop offset=".21" stop-color="#24272a"/><stop offset=".42" stop-color="#24272a" stop-opacity="0"/><stop offset=".59" stop-color="#24272a" stop-opacity="0"/><stop offset=".81" stop-color="#24272a"/></linearGradient><path d="m88.46 216a16.45 16.45 0 0 0 12.46-5.71l112.56-130.57a16.42 16.42 0 0 0 -13.94-7.72 16.46 16.46 0 0 0 -12.41 5.65l-113.13 129.8a16.46 16.46 0 0 0 14.46 8.55z" fill="url(#a)"/><path d="m88.46 216a16.46 16.46 0 0 0 7.54-1.83v-109l87.45 104.94a16.44 16.44 0 0 0 12.64 5.89h3.45a16.46 16.46 0 0 0 16.46-16.46v-111.08a16.46 16.46 0 0 0 -16.46-16.46 16.36 16.36 0 0 0 -7.54 1.81v109.05l-87.45-104.94a16.44 16.44 0 0 0 -12.64-5.92h-3.45a16.46 16.46 0 0 0 -16.46 16.46v111.08a16.46 16.46 0 0 0 16.46 16.46z" fill="#24272a"/></svg>
'''
'''--- src/assets/logo-white.svg ---
<svg viewBox="0 0 288 288" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><linearGradient id="a" gradientUnits="userSpaceOnUse" x1="76.81" x2="211.16" y1="211.17" y2="76.81"><stop offset=".21" stop-color="#fff"/><stop offset=".42" stop-color="#fff" stop-opacity="0"/><stop offset=".59" stop-color="#fff" stop-opacity="0"/><stop offset=".81" stop-color="#fff"/></linearGradient><path d="m88.46 216a16.45 16.45 0 0 0 12.46-5.71l112.56-130.57a16.42 16.42 0 0 0 -13.94-7.72 16.46 16.46 0 0 0 -12.41 5.65l-113.13 129.8a16.46 16.46 0 0 0 14.46 8.55z" fill="url(#a)"/><path d="m88.46 216a16.46 16.46 0 0 0 7.54-1.83v-109l87.45 104.94a16.44 16.44 0 0 0 12.64 5.89h3.45a16.46 16.46 0 0 0 16.46-16.46v-111.08a16.46 16.46 0 0 0 -16.46-16.46 16.36 16.36 0 0 0 -7.54 1.81v109.05l-87.45-104.94a16.44 16.44 0 0 0 -12.64-5.92h-3.45a16.46 16.46 0 0 0 -16.46 16.46v111.08a16.46 16.46 0 0 0 16.46 16.46z" fill="#fff"/></svg>
'''
'''--- src/config.js ---
const CONTRACT_NAME = process.env.CONTRACT_NAME ||'qa-on-near'

function getConfig(env) {
  switch (env) {

  case 'production':
  case 'mainnet':
    return {
      networkId: 'mainnet',
      nodeUrl: 'https://rpc.mainnet.near.org',
      contractName: CONTRACT_NAME,
      walletUrl: 'https://wallet.near.org',
      helperUrl: 'https://helper.mainnet.near.org',
      explorerUrl: 'https://explorer.mainnet.near.org',
    }
  case 'development':
  case 'testnet':
    return {
      networkId: 'testnet',
      nodeUrl: 'https://rpc.testnet.near.org',
      contractName: CONTRACT_NAME,
      walletUrl: 'https://wallet.testnet.near.org',
      helperUrl: 'https://helper.testnet.near.org',
      explorerUrl: 'https://explorer.testnet.near.org',
    }
  case 'betanet':
    return {
      networkId: 'betanet',
      nodeUrl: 'https://rpc.betanet.near.org',
      contractName: CONTRACT_NAME,
      walletUrl: 'https://wallet.betanet.near.org',
      helperUrl: 'https://helper.betanet.near.org',
      explorerUrl: 'https://explorer.betanet.near.org',
    }
  case 'local':
    return {
      networkId: 'local',
      nodeUrl: 'http://localhost:3030',
      keyPath: `${process.env.HOME}/.near/validator_key.json`,
      walletUrl: 'http://localhost:4000/wallet',
      contractName: CONTRACT_NAME,
    }
  case 'test':
  case 'ci':
    return {
      networkId: 'shared-test',
      nodeUrl: 'https://rpc.ci-testnet.near.org',
      contractName: CONTRACT_NAME,
      masterAccount: 'test.near',
    }
  case 'ci-betanet':
    return {
      networkId: 'shared-test-staging',
      nodeUrl: 'https://rpc.ci-betanet.near.org',
      contractName: CONTRACT_NAME,
      masterAccount: 'test.near',
    }
  default:
    throw Error(`Unconfigured environment '${env}'. Can be configured in src/config.js.`)
  }
}

module.exports = getConfig

'''
'''--- src/global.css ---
* {
  box-sizing: border-box;
}

html {
  --bg: #efefef;
  --fg: #1e1e1e;
  --gray: #555;
  --light-gray: #ccc;
  --shadow: #e6e6e6;
  --success: rgb(90, 206, 132);
  --primary: #FF585D;
  --secondary: #0072CE;

  background-color: var(--bg);
  color: var(--fg);
  font-family: -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
  font-size: calc(0.9em + 0.5vw);
  line-height: 1.3;
}

body {
  margin: 0;
  padding: 1em;
}

main {
  margin: 0 auto;
  max-width: 25em;
}

h1 {
  background-image: url(assets/logo-black.svg);
  background-position: center 1em;
  background-repeat: no-repeat;
  background-size: auto 1.5em;
  margin-top: 0;
  padding: 3.5em 0 0.5em;
  text-align: center;
}

a,
.link {
  color: var(--primary);
  text-decoration: none;
}
a:hover,
a:focus,
.link:hover,
.link:focus {
  text-decoration: underline;
}
a:active,
.link:active {
  color: var(--secondary);
}

button, input {
  font: inherit;
  outline: none;
}

button {
  background-color: var(--secondary);
  border-radius: 5px;
  border: none;
  color: #efefef;
  cursor: pointer;
  padding: 0.3em 0.75em;
  transition: transform 30ms;
}
button:hover, button:focus {
  box-shadow: 0 0 10em rgba(255, 255, 255, 0.2) inset;
}
button:active {
  box-shadow: 0 0 10em rgba(0, 0, 0, 0.1) inset;
}
button.link {
  background: none;
  border: none;
  box-shadow: none;
  display: inline;
}
[disabled] button, button[disabled] {
  box-shadow: none;
  background-color: var(--light-gray);
  color: gray;
  cursor: not-allowed;
  transform: none;
}
[disabled] button {
  text-indent: -900em;
  width: 2em;
  position: relative;
}
[disabled] button:after {
  content: " ";
  display: block;
  width: 0.8em;
  height: 0.8em;
  border-radius: 50%;
  border: 2px solid #fff;
  border-color: var(--fg) transparent var(--fg) transparent;
  animation: loader 1.2s linear infinite;
  position: absolute;
  top: 0.45em;
  right: 0.5em;
}
@keyframes loader {
  0% { transform: rotate(0deg) }
  100% { transform: rotate(360deg) }
}

fieldset {
  border: none;
  padding: 2em 0;
}

input {
  background-color: var(--shadow);
  border: none;
  border-radius: 5px 0 0 5px;
  caret-color: var(--primary);
  color: inherit;
  padding: 0.25em 1em;
}
input::selection {
  background-color: var(--secondary);
  color: #efefef;
}
input:focus {
  box-shadow: 0 0 10em rgba(0, 0, 0, 0.02) inset;
}

code {
  color: var(--gray);
}

li {
  padding-bottom: 1em;
}

aside {
  animation: notify ease-in-out 10s;
  background-color: var(--shadow);
  border-radius: 5px;
  bottom: 0;
  font-size: 0.8em;
  margin: 1em;
  padding: 1em;
  position: fixed;
  transform: translateY(10em);
  right: 0;
}
aside footer {
  display: flex;
  font-size: 0.9em;
  justify-content: space-between;
  margin-top: 0.5em;
}
aside footer *:first-child {
  color: var(--success);
}
aside footer *:last-child {
  color: var(--gray);
}
@keyframes notify {
  0% { transform: translateY(10em) }
  5% { transform: translateY(0) }
  95% { transform: translateY(0) }
  100% { transform: translateY(10em) }
}

@media (prefers-color-scheme: dark) {
  html {
    --bg: #1e1e1e;
    --fg: #efefef;
    --gray: #aaa;
    --shadow: #2a2a2a;
    --light-gray: #444;
  }
  h1 {
    background-image: url(assets/logo-white.svg);
  }
  input:focus {
    box-shadow: 0 0 10em rgba(255, 255, 255, 0.02) inset;
  }
}

'''
'''--- src/index.html ---
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="./assets/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="apple-touch-icon" href="./assets/favicon.ico" />
    <title>Welcome to NEAR with React</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
    <script src="./index.js"></script>
  </body>
</html>

'''
'''--- src/index.js ---
import React from "react";
import ReactDOM from "react-dom";
import { BrowserRouter as Router } from "react-router-dom";
import App from "./App";
import { initContract } from "./utils";

window.nearInitPromise = initContract()
  .then(() => {
    ReactDOM.render(
      <Router>
        <App
          walletConnection={window.walletConnection}
          accountId={window.accountId}
          contract={window.contract}
        />
      </Router>,
      document.querySelector("#root")
    );
  })
  .catch(console.error);

'''
'''--- src/jest.init.js ---
import 'regenerator-runtime/runtime'

'''
'''--- src/main.test.js ---
beforeAll(async function () {
  // NOTE: nearlib and nearConfig are made available by near-cli/test_environment
  const near = await nearlib.connect(nearConfig)
  window.accountId = nearConfig.contractName
  window.contract = await near.loadContract(nearConfig.contractName, {
    viewMethods: ['get_greeting'],
    changeMethods: [],
    sender: window.accountId
  })

  window.walletConnection = {
    requestSignIn() {
    },
    signOut() {
    },
    isSignedIn() {
      return true
    },
    getAccountId() {
      return window.accountId
    }
  }
})

test('get_greeting', async () => {
  const message = await window.contract.get_greeting({ account_id: window.accountId })
  expect(message).toEqual('Hello')
})

'''
'''--- src/pages/DetailQuestionPage.js ---
import React, {useState, useEffect} from "react";

export default function DetailQuestionPage({ }) {
    return (
        <h1>DetailQuestionPage</h1>
    )
}
'''
'''--- src/pages/HomePage.js ---
import React, {useState, useEffect} from "react";

export default function HomePage({ }) {
    return (
        <h1>Home page</h1>
    )
}
'''
'''--- src/utils.js ---
import { connect, Contract, keyStores, WalletConnection } from 'near-api-js'
import getConfig from './config'

const nearConfig = getConfig(process.env.NODE_ENV || 'development')

// Initialize contract & set global variables
export async function initContract() {
  // Initialize connection to the NEAR testnet
  const near = await connect(Object.assign({ deps: { keyStore: new keyStores.BrowserLocalStorageKeyStore() } }, nearConfig))

  // Initializing Wallet based Account. It can work with NEAR testnet wallet that
  // is hosted at https://wallet.testnet.near.org
  window.walletConnection = new WalletConnection(near)

  // Getting the Account ID. If still unauthorized, it's just empty string
  window.accountId = window.walletConnection.getAccountId()

  // Initializing our contract APIs by contract name and configuration
  window.contract = await new Contract(window.walletConnection.account(), nearConfig.contractName, {
    // View methods are read only. They don't modify the state, but usually return some value.
    viewMethods: ['get_greeting'],
    // Change methods can modify the state. But you don't receive the returned value when called.
    changeMethods: ['set_greeting'],
  })
}

export function logout() {
  window.walletConnection.signOut()
  // reload page
  window.location.replace(window.location.origin + window.location.pathname)
}

export function login() {
  // Allow the current app to make calls to the specified contract on the
  // user's behalf.
  // This works by creating a new access key for the user's account and storing
  // the private key in localStorage.
  window.walletConnection.requestSignIn(nearConfig.contractName)
}

'''
'''--- src/wallet/login/index.html ---
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.2.1/css/bootstrap.min.css" integrity="sha384-GJzZqFGwb1QTTN6wy59ffF1BuGJpLSa9DkKMp0DgiMDm4iYMj70gZWKYbI706tWS" crossorigin="anonymous">
</head>
<body style="background: #fff; margin-top: 3em">
  <div>For local account login, Please run the following command in NEAR CLI, then enter account id here.
  </div>
  <div>
      <code id="shell-command"></code>
  </div>
  <input type="text" id="accountId" name="accountId" placeholder="Account id"></input>
  <button type="button" onClick="done()">done</button>
  <script>
    const currentUrl = new URL(window.location.href);
    const message = `NODE_ENV=local near create_account {newAccountId} --masterAccount {masterAccountId} --publicKey ${currentUrl.searchParams.get('public_key')} --initialAmount 10000000000000000000`;
    document.getElementById('shell-command').innerText = message;

    function done() {
      const successUrl = new URL(currentUrl.searchParams.get('success_url'));
      successUrl.searchParams.set('account_id', document.getElementById('accountId').value);
      successUrl.searchParams.set('public_key', currentUrl.searchParams.get('public_key'));
      window.location.assign(successUrl.toString());
    }
  </script>
</body>
</html>
'''