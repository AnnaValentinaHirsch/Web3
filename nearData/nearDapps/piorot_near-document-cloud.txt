*GitHub Repository "piorot/near-document-cloud"*

'''--- README.md ---
# NEAR Document Cloud
**Robust and trustless solution to use NEAR blockchain for managing and signing documents**

*project created form template `near-sdk-as` Starter Kit*

## Problem Description
Everyday we sign agreements with various companies like financial institutions, mobile operators and other individuals like real-estate agents and landlords. Similarily comapnies need to have thousands of various agreements, policies and docs signed by consumers, contractors, business partners.

In many cases storing and tracking those documents is cumbersome. Not to mention several documents versions for a single topic like for instance fluctating bank fees that each of us need to sign on regular basis.

For this reason individuals & companies seek solution to manage their agreements with various parties in easy, managable and **trustless** way.

## Solution Description

### Solution Requirements:
* List all agreements user has signed and has issued to be signed by someone else.  
* Allow to add revisions (documents versions)
* Allow to sign documents
* Documents should be stored in ipfs; link should be stored on-chain

### Solution UI concept

*Since I believe image is best explainer I added those wireframes to make the reader get the whole idea quiclky. The UI layer is not implemented, however the smart-contract itself has already most of needed code. So to have it fully working one will only need to add some (view) filtering capabilities and do the UI layer*

### Listing all agreements

Project should potentially allow to show all agreements (especially all agreements related to logged user). There should be clear distinction for:
* `Issued by others` - agreements the user is supposed to sign or has already signed (top row)
* `Issued by You` - agreements user has issued and expects someone to sign (bottom row)

![List of all agreements of particular user](./docs/list-of-agreements.png)

### Ading new agreement 
Any user can add an agreement. Adding agreement requires to input at least ipfs link to initial document version and intended signer. All remaining details are a matter of potential extension and decision where to store these (on-chain vs off-chain).

![Adding new revision](./docs/add-agreement.png)

Agreements are immutable with exception to adding new agreement revision and signing it

### Signing agreement

User can sign agreement only if it has been issued with explicit indication he/she is intended signer. Trying to sign agreement that has not been issued for acting user will throw (reject tx).

![An agreement that can be signed](./docs/signing.png)

In the image above we can see Agreement with credit cart operator is `not signed` because it has been updated - issuer has added `revision two` and to formaly be in force this agreement needs to be signed again. This can be easily achieved by clicking sign with wallet button and acknowledging the tx.

### Adding new revision

User can only add revision for those agreements he/she has issued. Trying to add revision to agreement issued by someone else will result in transaction rejection.

![Adding new revision](./docs/adding-revision.png)

Adding new revision could potentially be achieved on separate screen and require just entering `ipfs link` to new document. All other details of agreement like previous links, signing history, or other details should be read only at this stage.

Adding new revision sets the whole agreement in `isSigned : false` state, no matter if it has been already signed or not. Conditions have changed and the agreement can not be automatically in force/signed without signer explicitly signing it again.

## Usage

### Unit tests

Whole business logic of Agreement has been covered with unit tests. Run unit tests by: `yarn test`
### Getting started

(see below for video recordings of each of the following steps)

INSTALL `NEAR CLI` first like this: `npm i -g near-cli`

1. clone this repo to a local folder
2. run `yarn`
3. run `yarn build`
4. run `./scripts/1.dev-deploy.sh`
5. run `./scripts/2.use-contract.sh`
6. run `./scripts/2.use-contract.sh` (yes, run it to see changes)
7. run `./scripts/3.cleanup.sh`

### Videos

https://www.loom.com/share/b2c007bbf766468bb6d8cdaa402ffadf

'''
'''--- as-pect.config.js ---
module.exports = require("near-sdk-as/imports");
module.exports.include.push("**/*.unit.spec.ts");

'''
'''--- asconfig.json ---
{
  "workspaces": [
    "src/agreement"

  ]
}

'''
'''--- config.js ---
const CONTRACT_NAME = process.env.CONTRACT_NAME;

function getConfig(env) {
  switch (env) {
    case "production":
    case "mainnet":
      return {
        networkId: "mainnet",
        nodeUrl: "https://rpc.mainnet.near.org",
        contractName: CONTRACT_NAME,
        walletUrl: "https://wallet.mainnet.near.org",
        helperUrl: "https://helper.mainnet.near.org",
      };
    case "development":
    case "testnet":
      return {
        networkId: "default",
        nodeUrl: "https://rpc.testnet.near.org",
        contractName: CONTRACT_NAME,
        walletUrl: "https://wallet.testnet.near.org",
        helperUrl: "https://helper.testnet.near.org",
      };
    case "betanet":
      return {
        networkId: "betanet",
        nodeUrl: "https://rpc.betanet.near.org",
        contractName: CONTRACT_NAME,
        walletUrl: "https://wallet.betanet.near.org",
        helperUrl: "https://helper.betanet.near.org",
      };
    case "local":
      return {
        networkId: "local",
        nodeUrl: "http://localhost:3030",
        keyPath: `${process.env.HOME}/.near/validator_key.json`,
        walletUrl: "http://localhost:4000/wallet",
        contractName: CONTRACT_NAME,
      };
    case "test":
    case "ci":
      return {
        networkId: "shared-test",
        nodeUrl: "https://rpc.ci-testnet.near.org",
        contractName: CONTRACT_NAME,
        masterAccount: "test.near",
      };
    case "ci-betanet":
      return {
        networkId: "shared-test-staging",
        nodeUrl: "https://rpc.ci-betanet.near.org",
        contractName: CONTRACT_NAME,
        masterAccount: "test.near",
      };
    default:
      throw Error(
        `Unconfigured environment '${env}'. Can be configured in src/config.js.`
      );
  }
}

module.exports = getConfig;

'''
'''--- lib/utils.js ---
const fs = require("fs");
const path = require("path");
const got = require("got");
const api = require("near-api-js");

const keystore = new api.keyStores.InMemoryKeyStore();

const DEFAULT_CONFIG = getConfig(process.env.NEAR_ENV);

function getConfig(network = "testnet") {
  const pwd = process.cwd();
  return require(`${pwd}/config`)(network);
}

async function isValid(account, network = "testnet") {
  try {
    await fetchState(account, getConfig(network));
    return true;
  } catch (error) {
    if (/does not exist while viewing/.test(error)) {
      // invalid account
    } else {
      console.log(error);
    }
    return false;
  }
}

async function fetchStorage(account, network = "testnet") {
  if (!(await isValid(account, network))) return {};

  url = network === 'local' ? 'http://localhost:3030' : `https://rpc.${network}.near.org`

  const { body } = await got.post(`${url}`, {
    json: {
      jsonrpc: "2.0",
      id: "dontcare",
      method: "query",
      params: {
        request_type: "view_state",
        finality: "final",
        account_id: account,
        prefix_base64: "",
      },
    },
  });

  return body;
}

function hasContract(state) {
  if (state.code_hash === "11111111111111111111111111111111") {
    return false;
  } else {
    return state.code_hash.substring(0, 6);
  }
}

async function fetchAccessKeys(accountName, config = DEFAULT_CONFIG) {
  const near = await api.connect({ ...config, deps: { keystore } });
  const account = await near.account(accountName);
  return await account.getAccessKeys();
}

async function fetchState(accountName, config = DEFAULT_CONFIG) {
  const near = await api.connect({ ...config, deps: { keystore } });
  const account = await near.account(accountName);
  const state = await account.state();
  Object.assign(state, {
    formattedAmount: api.utils.format.formatNearAmount(state.amount),
  });
  return state;
}

function privateKeyFromFile(file) {
  const contents = fs.readFileSync(file);
  return JSON.parse(contents).private_key;
}

function publicKeyFromPrivate(sk) {
  return keysFromString(sk).publicKey;
}

function publicKeyFromFile(file) {
  return publicKeyFromPrivate(privateKeyFromFile(file));
}

function keysFromString(privateKey) {
  const keys = api.utils.key_pair.KeyPairEd25519.fromString(privateKey);
  // const keys = utils.key_pair.KeyPairEd25519.fromRandom()

  return {
    publicKey: keys.publicKey.toString(),
    secretKey: keys.secretKey,
  };
}

function fetchAccounts(credentialStore, network = "testnet") {
  return fetchLocalKeys(credentialStore, network).reduce(
    (results, keyFilePath) => {
      const account = keyFilePath.split("/").slice(-1)[0].replace(".json", "");
      results[account] = keyFilePath;
      return results;
    },
    {}
  );
}

function fetchLocalKeys(credentialStore, network = "default") {
  if (!credentialStore) {
    throw new Error("Missing entry level folder for NEAR account credentials");
  }

  const networkFilter = RegExp(network);

  return readDirR(credentialStore)
    .filter((entry) => networkFilter.test(entry))
    .filter((entry) => typeof entry == "string");
}

// prettier-ignore
function readDirR(dir) {
  return fs.statSync(dir).isDirectory()
    ? [Array.prototype].concat(...fs.readdirSync(dir).map(f => readDirR(path.join(dir, f))))
    : dir;
}

module.exports = {
  hasContract,
  fetchState,
  keysFromString,
  privateKeyFromFile,
  publicKeyFromPrivate,
  publicKeyFromFile,
  fetchAccounts,
  fetchLocalKeys,
  fetchAccessKeys,
  fetchStorage,
};

'''
'''--- package.json ---
{
  "name": "starter--near-sdk-as",
  "version": "0.0.1",
  "description": "Start with a basic project",
  "scripts": {
    "dev": "watch -d -n 1 'clear && yarn test'",
    "test": "yarn asp -f unit.spec",
    "clean": "./scripts/3.cleanup.sh && rm -rf ./build && rm -rf ./neardev",
    "build": "asb --target debug",
    "build:release": "asb",
    "asp": "asp --verbose --nologo",
    "storage": "./bin/storage-report", 
    "storage:watch": " watch -d -n 1 yarn storage $CONTRACT",
    "demo" : "./scripts/2.use-contract.sh",
    "deploy" : "./scripts/1.dev-deploy.sh"
  },
  "keywords": [],
  "author": "hello@near.org",
  "license": "ISC",
  "devDependencies": {
    "near-sdk-as": "^3.1.0",
    "chalk": "^4.0.0",
    "chardet": "^1.1.0",
    "got": "^11.1.3",
    "near-api-js": "^0.25.1",
    "table": "^5.4.6"
  }
}

'''
'''--- scripts/1.dev-deploy.sh ---
#!/usr/bin/env bash

# exit on first error after this point to avoid redeploying with successful build
set -e

echo
echo ---------------------------------------------------------
echo "Step 1: Build the contract (may take a few seconds)"
echo ---------------------------------------------------------
echo

yarn build

echo
echo
echo ---------------------------------------------------------
echo "Step 2: Deploy the contract"
echo
echo "(edit scripts/1.dev-deploy.sh to deploy other contract)"
echo ---------------------------------------------------------
echo

# uncomment out the line below to deploy the other example contract
# near dev-deploy ./build/debug/simple.wasm

# comment the line below to deploy the other example contract
near dev-deploy ./build/debug/agreement.wasm

echo
echo
echo ---------------------------------------------------------
echo "Step 3: Prepare your environment for next steps"
echo
echo "(a) find the contract (account) name in the message above"
echo "    it will look like this: [ Account id: dev-###-### ]"
echo
echo "(b) set an environment variable using this account name"
echo "    see example below (this may not work on Windows)"
echo
echo ---------------------------------------------------------
echo 'export CONTRACT=<dev-123-456>'
# uncomment this line for a useful hint when using the singleton style
# echo "near call \$CONTRACT init --accountId \$CONTRACT"
echo ---------------------------------------------------------
echo

exit 0

'''
'''--- scripts/2.use-contract.sh ---
#!/usr/bin/env bash

# exit on first error after this point to avoid redeploying with successful build
set -e

echo
echo ---------------------------------------------------------
echo "Step 0: Check for environment variable with contract name"
echo ---------------------------------------------------------
echo

[ -z "$CONTRACT" ] && echo "Missing \$CONTRACT environment variable" && exit 1
[ -z "$CONTRACT" ] || echo "Found it! \$CONTRACT is set to [ $CONTRACT ]"

echo
echo
echo ---------------------------------------------------------
echo "Step 1: Call 'addAgreement' function on the contract"
echo
echo ---------------------------------------------------------
echo
read -p "Press enter to continue"

near call $CONTRACT addAgreement '{"uri": "uri1", "signer": "piorot.testnet"}' --accountId $CONTRACT

echo
echo
echo ---------------------------------------------------------
echo "Step 2: Call 'signAgreement' function on the contract"
echo
echo ---------------------------------------------------------
echo
read -p "Press enter to continue"

near call $CONTRACT signAgreementByUri '{"uri": "uri1"}' --accountId piorot.testnet

echo
echo
echo ---------------------------------------------------------
echo "Step 3: Call 'addRevision' function on the contract"
echo
echo ---------------------------------------------------------
echo
read -p "Press enter to continue"

near call $CONTRACT addRevision '{"uri": "uri1", "newUri": "uri1.updated1"}' --accountId $CONTRACT

echo
echo
echo ---------------------------------------------------------
echo "Step 4: Call 'signAgreement' function on the contract"
echo
echo ---------------------------------------------------------
echo
read -p "Press enter to continue"

near call $CONTRACT signAgreementByUri '{"uri": "uri1"}' --accountId piorot.testnet

'''
'''--- scripts/3.cleanup.sh ---
#!/usr/bin/env bash

# exit on first error after this point to avoid redeploying with successful build
set -e

echo
echo ---------------------------------------------------------
echo "Step 0: Check for required environment variables"
echo ---------------------------------------------------------
echo

[ -z "$CONTRACT" ] && echo "Missing \$CONTRACT environment variable" && exit 1
# [ -z "$BENEFICIARY" ] && echo "Missing \$BENEFICIARY environment variable" && exit 1
[ -z "$CONTRACT" ] || echo "Found it! \$CONTRACT is set to [ $CONTRACT ]"
# [ -z "$BENEFICIARY" ] || echo "Found it! \$BENEFICIARY is set to [ $BENEFICIARY ]"

echo
echo
echo ---------------------------------------------------------
echo "Step 1: Delete $CONTRACT, setting $BENEFICIARY as beneficiary"
echo ---------------------------------------------------------
echo
near delete $CONTRACT $CONTRACT

echo
echo ---------------------------------------------------------
echo "Step 2: Clean up project folders"
echo ---------------------------------------------------------
echo
yarn clean

exit 0

'''
'''--- scripts/README.md ---
## Setting up your terminal

The scripts in this folder are designed to help you demonstrate the behavior of the contract(s) in this project.

It uses the following setup:

```sh
# set your terminal up to have 2 windows, A and B like this:
┌─────────────────────────────────┬─────────────────────────────────┐
│                                 │                                 │
│                                 │                                 │
│                A                │                B                │
│                                 │                                 │
│                                 │                                 │
└─────────────────────────────────┴─────────────────────────────────┘
```

### Terminal **A**

*This window is used to compile, deploy and control the contract*
- Environment
  ```sh
  export CONTRACT=        # depends on deployment
  export OWNER=           # any account you control

  # for example
  # export CONTRACT=dev-1615190770786-2702449
  # export OWNER=sherif.testnet
  ```

- Commands

  _helper scripts_
  ```sh
  1.dev-deploy.sh                # helper: build and deploy contracts
  2.use-contract.sh              # helper: call methods on ContractPromise
  3.cleanup.sh                   # helper: delete build and deploy artifacts
  ```

### Terminal **B**

*This window is used to render the contract account storage*
- Environment
  ```sh
  export CONTRACT=               # depends on deployment

  # for example
  # export CONTRACT=dev-1615190770786-2702449
  ```

- Commands
  ```sh
  # monitor contract storage using near-account-utils
  # https://github.com/near-examples/near-account-utils
  watch -d -n 1 yarn storage $CONTRACT
  ```
---

## OS Support

### Linux

- The `watch` command is supported natively on Linux
- To learn more about any of these shell commands take a look at [explainshell.com](https://explainshell.com)

### MacOS

- Consider `brew info visionmedia-watch` (or `brew install watch`)

### Windows

- Consider this article: [What is the Windows analog of the Linux watch command?](https://superuser.com/questions/191063/what-is-the-windows-analog-of-the-linuo-watch-command#191068)

'''
'''--- src/agreement/__tests__/index.unit.spec.ts ---
import { VMContext } from "near-sdk-as";
import { Agreement } from "../assembly";

const signer = "piorot.testnet";
const issuer = "Big Company Selling Electricity inc";

let contract: Agreement;

beforeEach(() => {
  VMContext.setSigner_account_id(issuer);
  contract = new Agreement("ipfs://doc1", signer);
});

describe("Agreement", () => {
  describe("Agreement initialization", () => {
    it("agreement issuer should be set", () => {
      expect(contract.issuer).toStrictEqual(issuer);
    });

    it("signer should be set", () => {
      expect(contract.signer).toStrictEqual(signer);
    });

    it("document uri should be set", () => {
      expect(contract.uri).toStrictEqual("ipfs://doc1");
    });

    it("agreement should not be signes after initialization", () => {
      expect(contract.isSigned).toStrictEqual(false);
    });

    it("agreement should have first doc in versions collection", () => {
      expect(contract.versions).toHaveLength(1);
      expect(contract.versions.first).toStrictEqual(contract.uri);
    });
  });

  describe("Agreement signing", () => {
    it("should throw when signer is not inteded signer", () => {
      VMContext.setSigner_account_id("hacker");
      expect(() => {
        contract.signAgreement();
      }).toThrow();
    });

    it("should not throw when signer is intended signer", () => {
      VMContext.setSigner_account_id("piorot.testnet");
      expect(() => {
        contract.signAgreement();
      }).not.toThrow();
    });

    it("agreement should be signed ", () => {
      VMContext.setSigner_account_id("piorot.testnet");
      contract.signAgreement();
      expect(contract.isSigned).toBeTruthy();
    });
  });

  describe("Adding Agreement Docs", () => {
    it("only issuer can add new version of docs", () => {
      VMContext.setSigner_account_id("hacker");
      expect(() => {
        contract.addAgreementVersion("ipfs://doc2");
      }).toThrow();
    });

    it("addnind new version resets isSigned flag", () => {
      contract.addAgreementVersion("ipfs://doc2");
      expect(contract.isSigned).toBeFalsy();
    });

    it("addnind new version push new doc link to versions vector", () => {
      contract.addAgreementVersion("ipfs://doc2");
      expect(contract.versions.length).toBe(2);
      expect(contract.versions.last).toBe("ipfs://doc2");
    });
  });
});

'''
'''--- src/agreement/asconfig.json ---
{
  "extends": "near-sdk-as/asconfig.json"
}

'''
'''--- src/agreement/assembly/index.ts ---
import { Context, PersistentVector, storage } from 'near-sdk-as'

export function addAgreement(uri: string, signer: string): void {
  assert(!storage.get<Agreement>(uri), "Agreement already exists");
  storage.set<Agreement>(uri, new Agreement(uri, signer));
}

export function signAgreementByUri(uri: string): void {
  assert(storage.get<Agreement>(uri), "Agreement doesn't exist");
  let agreenemtnToSign = storage.getSome<Agreement>(uri)
  agreenemtnToSign.signAgreement();
  storage.set<Agreement>(uri, agreenemtnToSign);
}

export function addRevision(uri: string, newUri: string): void {
  assert(storage.get<Agreement>(uri), "Agreement doesn't exist");
  assert(Context.sender == storage.getSome<Agreement>(uri).issuer, "Only issuer can update agreement");
  let agreenemtnToUpdate = storage.getSome<Agreement>(uri);
  agreenemtnToUpdate.addAgreementVersion(newUri);
  storage.set<Agreement>(uri, agreenemtnToUpdate);
}

@nearBindgen
export class Agreement {
  issuer: string;
  isSigned: boolean;
  versions: PersistentVector<string>;
  constructor(public uri: string, public signer: string) {
    this.issuer = Context.sender;
    this.isSigned = false;
    this.versions = new PersistentVector<string>(`${uri}-v`);
    this.versions.push(uri);
    this.uri = uri;
  }

  @mutateState()
  addAgreementVersion(version: string): void{
    assert(Context.sender == this.issuer, "Only issuer can update agreement");
    this.versions.push(version);
    this.isSigned = false;
  }

  @mutateState()
  signAgreement(): void{
    assert(Context.sender == this.signer, "You're not allowed to sign this");
    this.isSigned = true;
  }

}
'''
'''--- src/as_types.d.ts ---
/// <reference types="near-sdk-as/assembly/as_types" />
'''
'''--- src/tsconfig.json ---
{
  "extends": "../node_modules/assemblyscript/std/assembly.json",
  "include": ["./**/*.ts"]
}

'''
'''--- src/utils.ts ---
import { u128, Context, ContractPromise } from "near-sdk-as";

/**
 * == TYPES ====================================================================
 */

/**
 * Account IDs in NEAR are just strings.
 */
export type AccountId = string;

/**
 * Gas is u64
 */
export type Gas = u64;

/**
 * Amounts, Balances, and Money in NEAR is are u128.
 */

export type Amount = u128;

export type Balance = Amount;

export type Money = Amount;

/**
 * Timestamp in NEAR is a number.
 */
export type Timestamp = u64;

/**
 * == CONSTANTS ================================================================
 *
 * ONE_NEAR = unit of NEAR token in yocto Ⓝ (1e24)
 * XCC_GAS = gas for cross-contract calls, ~5 Tgas (teragas = 1e12) per "hop"
 * MIN_ACCOUNT_BALANCE = 3 NEAR min to keep account alive via storage staking
 *
 * TODO: revist MIN_ACCOUNT_BALANCE after some real data is included b/c this
 *  could end up being much higher
 */

export const ONE_NEAR = u128.from("1000000000000000000000000");
export const XCC_GAS: Gas = 20_000_000_000_000;
export const MIN_ACCOUNT_BALANCE: u128 = u128.mul(ONE_NEAR, u128.from(3));

/**
 * == FUNCTIONS ================================================================
 */

/**
 * @function asNEAR
 * @param amount {u128} - Yocto Ⓝ token quantity as an unsigned 128-bit integer
 * @returns {string}    - Amount in NEAR, as a string
 *
 * @example
 *
 *    asNEAR(7000000000000000000000000)
 *    // => '7'
 */
export function asNEAR(amount: u128): string {
  return u128.div(amount, ONE_NEAR).toString();
}

/**
 * @function toYocto
 * @param amount {number} - Integer to convert
 * @returns {u128}        - Amount in yocto Ⓝ as an unsigned 128-bit integer
 *
 * @example
 *
 *    toYocto(7)
 *    // => 7000000000000000000000000
 */
export function toYocto(amount: number): u128 {
  return u128.mul(ONE_NEAR, u128.from(amount))
}

/**
 * Function to assert that the contract has called itself
 */
export function assert_self(): void {
  const caller = Context.predecessor
  const self = Context.contractName
  assert(caller == self, "Only this contract may call itself");
}

export function assert_single_promise_success(): void {
  const x = ContractPromise.getResults()
  assert(x.length == 1, "Expected exactly one promise result")
  assert(x[0].succeeded, "Expected PromiseStatus to be successful")
}

'''