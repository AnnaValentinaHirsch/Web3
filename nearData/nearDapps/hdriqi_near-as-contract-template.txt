*GitHub Repository "hdriqi/near-as-contract-template"*

'''--- as-pect.config.js ---
module.exports = require('near-sdk-as/imports');
'''
'''--- asconfig.json ---
{
  "extends": "near-sdk-as/asconfig.json", 
  "entry": "assembly/main.ts",
  "options": {
    "binaryFile": "out/main.wasm"
  }
}
'''
'''--- assembly/__tests__/as-pect.d.ts ---
/// <reference types="@as-pect/assembly/types/as-pect" />
'''
'''--- assembly/__tests__/main.spec.ts ---
import { Memento, Img, Post, Content } from '../model'
import { createPost, createMemento, init, balanceOf, piecePost } from '../main'
import { u128 } from 'near-sdk-as'

var memento: Memento

describe('Memento ', () => {
  beforeEach(() => {
    const name = 'Hello World'
    const category = 'art'
    const img = new Img()
    const desc = 'Memento test'
    const type = 'personal'
    memento = createMemento(name, category, img, desc, type)

    init('bob')

    for (let i = 0; i < 5; i++) {
      const contentList: Content[] = []
      const mementoId = memento.id
      createPost(contentList, mementoId)
    }
  })
  afterEach(() => {

  })

  it('should create published post', () => {
    const contentList: Content[] = []
    const mementoId = memento.id
    const p = createPost(contentList, mementoId)
    expect(p instanceof Post).toBeTruthy()
  })

  it('should get balance', () => {
    const balance = balanceOf('bob')
    log(balance.toString())
  })

  it('should piecePost', () => {
    const contentList: Content[] = []
    const mementoId = memento.id
    const p = createPost(contentList, mementoId)
    if (p) {
      piecePost(p.id, "10")
    }
  })
})

'''
'''--- assembly/__tests__/memento.spec.ts ---
import { createMemento, updateMemento } from '../main'
import { Memento, mementoCollection, Img } from '../model'

describe('Memento ', () => {
  afterEach( () => {
    mementoCollection.delete('list')
  })

  it('should create memento', () => {
    const name = 'Hello World'
    const category = 'tech'
    const img: Img = {
      url: 'test',
      type: 'ipfs'
    }
    const desc = 'Memento test'
    const type = 'public'
    const m = createMemento(name, category, img, desc, type)

    const newM = mementoCollection.getSome(m.id)
    expect(m.id).toBe(newM.id)
  })

  it('should update memento', () => {
    const name = 'Hello World'
    const category = 'tech'
    const img: Img = {
      url: 'test',
      type: 'ipfs'
    }
    const desc = 'Memento test'
    const type = 'public'
    const m = createMemento(name, category, img, desc, type)

    const newDesc = 'Hello world'
    updateMemento(m.id, m.img, newDesc)

    const newM = mementoCollection.get(m.id)
    if(newM) {
      expect(newM.desc).toBe(newDesc)  
    }
  })

  // itThrows('should throw error Memento type', () => {
  //   const name = 'Hello World'
  //   const desc = 'Memento test'
  //   const descRaw = 'Memento test raw'
  //   const type = 'random'
  //   createMemento(name, desc, descRaw, type)
  // })

  // it('should get all memento list', () => {
  //   const len = 10
  //   for (let i = 0; i < len; i++) {
  //     const name = 'Hello World'
  //     const desc = 'Memento test'
  //     const descRaw = 'Memento test raw'
  //     const type = 'public'
  //     createMemento(name, desc, descRaw, type)
  //   }
  //   const result = getMementoList()
  //   expect(result.length).toBe(len)
  // })

  // it('should get memento list by name', () => {
  //   for (let i = 0; i < 3; i++) {
  //     const name = 'Hello World'
  //     const desc = 'Memento test'
  //     const descRaw = 'Memento test raw'
  //     const type = 'public'
  //     createMemento(name, desc, descRaw, type)
  //   }
  //   for (let i = 0; i < 5; i++) {
  //     const name = 'Another World'
  //     const desc = 'Memento test'
  //     const descRaw = 'Memento test raw'
  //     const type = 'public'
  //     createMemento(name, desc, descRaw, type)
  //   }
  //   const result = getMementoList(['name:=Hello World'])
  //   expect(result.length).toBe(3)
  // })

  // it('should get memento list by name like', () => {
  //   for (let i = 0; i < 3; i++) {
  //     const name = 'Hello World'
  //     const desc = 'Memento test'
  //     const descRaw = 'Memento test raw'
  //     const type = 'public'
  //     createMemento(name, desc, descRaw, type)
  //   }
  //   for (let i = 0; i < 3; i++) {
  //     const name = 'Another World'
  //     const desc = 'Memento test'
  //     const descRaw = 'Memento test raw'
  //     const type = 'public'
  //     createMemento(name, desc, descRaw, type)
  //   }
  //   const result = getMementoList(['name_like:=worl'])
  //   expect(result.length).toBe(6)
  // })

  // it('should get memento list by owner', () => {
  //   for (let i = 0; i < 3; i++) {
  //     const name = 'Hello World'
  //     const desc = 'Memento test'
  //     const descRaw = 'Memento test raw'
  //     const type = 'public'
  //     createMemento(name, desc, descRaw, type)
  //   }
  //   const result = getMementoList(['owner:='.concat(context.sender)])
  //   expect(result.length).toBe(3)
  // })

  // it('should get memento list with sort by desc', () => {
  //   for (let i = 0; i < 3; i++) {
  //     const name = 'Hello World'
  //     const desc = 'Memento test'
  //     const descRaw = 'Memento test raw'
  //     const type = 'public'
  //     createMemento(name, desc, descRaw, type)
  //   }
  //   const result = getMementoList([], {
  //     _embed: true,
  //     _order: 'createdAt',
  //     _sort: 'desc',
  //     _limit: 10
  //   })
  //   expect(result[0].createdAt).toBeGreaterThanOrEqual(result[1].createdAt)
  // })

  // it('should get memento list with limit', () => {
  //   for (let i = 0; i < 10; i++) {
  //     const name = 'Hello World'
  //     const desc = 'Memento test'
  //     const descRaw = 'Memento test raw'
  //     const type = 'public'
  //     createMemento(name, desc, descRaw, type)
  //   }
  //   const result = getMementoList([], {
  //     _embed: true,
  //     _order: 'createdAt',
  //     _sort: 'desc',
  //     _limit: 3
  //   })
  //   expect(result.length).toBe(3)
  // })

  // it('should get memento by id', () => {
  //   const name = 'Hello World'
  //   const desc = 'Memento test'
  //   const descRaw = 'Memento test raw'
  //   const type = 'public'
  //   const m = createMemento(name, desc, descRaw, type)
  //   const result = getMementoById(m.id)
  //   if(result) {
  //     expect(result.name).toBe(m.name)
  //   }
  //   else {
  //     expect(result).toBe(null)
  //   }
  // })

  // it('should delete memento by id', () => {
  //   const name = 'Hello World'
  //   const desc = 'Memento test'
  //   const descRaw = 'Memento test raw'
  //   const type = 'public'
  //   createMemento(name, desc, descRaw, type)

  //   const list = mementoCollection.get('list')
  //   if(list) {
  //     const id = list.data[0].id
  //     deleteMementoById(id)
  //     const mementoList = getMementoList()
  //     expect(mementoList.length).toBe(0)
  //   }
  // })
})

'''
'''--- assembly/__tests__/user.spec.ts ---
// import { createUser, getUserList, getUserById, getUserByUsername, updateUserById, getPostListByUserFollowing } from '../main'
// import { Img, User, userCollection } from '../model'

// let newUser: User = <User>{}

// describe('User ', () => {
//   beforeEach(() => {
//     const imgAvatar = new Img()
//     imgAvatar.url = 'asdf'
//     imgAvatar.type = 'ipfs'
//     const bio = 'test'
//     const bioRaw = 'test'

//     newUser = createUser(imgAvatar, bio, bioRaw)
//   })
//   afterEach(() => {
//     userCollection.delete('list')
//   })

//   it('should create new user', () => {
//     userCollection.delete('list')
    
//     const imgAvatar = new Img()
//     imgAvatar.url = 'asdf'
//     imgAvatar.type = 'ipfs'
//     const bio = 'test'
//     const bioRaw = 'test'

//     const newUser = createUser(imgAvatar, bio, bioRaw)
//     expect(newUser instanceof User).toBeTruthy()
//     const userList = userCollection.get('list')
//     if(userList) {
//       expect(userList.data.length).toBe(1)
//     }
//   })

//   it('should get all users', () => {
//     const userList = getUserList()
//     expect(userList.length).toBe(1)
//   })

//   it('should get users by id', () => {
//     const userList = getUserList(['id:='.concat(newUser.id)])
//     expect(userList.length).toBe(1)
//   })

//   it('should get users by username', () => {
//     const userList = getUserList(['username:=bo'])
//     expect(userList.length).toBe(0)
//   })

//   it('should get users by username_like', () => {
//     const userList = getUserList(['username_like:=bo'])
//     expect(userList.length).toBe(1)
//   })

//   it('should get user by id', () => {
//     const user = getUserById(newUser.id)
//     if(user) expect(user.id).toBe(newUser.id)
//   })

//   it('should get user by username', () => {
//     const user = getUserByUsername(newUser.username)
//     if(user) expect(user.username).toBe(newUser.username)
//   })

//   it('should update user', () => {
//     const newImgAvatar = new Img()
//     newImgAvatar.url = 'new avatar'
//     newImgAvatar.type = 'ipfs'
//     const newBio = 'new bio'
//     const newBioRaw = 'new bio'
//     const nUser = updateUserById(newUser.id, newImgAvatar, newBio, newBioRaw)
//     if(nUser) {
//       expect(nUser.imgAvatar.url).toBe(newImgAvatar.url)
//       expect(nUser.bio).toBe(newBio)
//       expect(nUser.bioRaw).toBe(newBioRaw)
//     }
//   })

//   it('should get postlist by user following', () => {
//     const postList = getPostListByUserFollowing('bob')
//     expect(postList.length).toBe(0)
//   })
// })

'''
'''--- assembly/as_types.d.ts ---
/// <reference types="near-sdk-as/assembly/as_types" />
'''
'''--- assembly/main.ts ---
import { context, storage, u128 } from 'near-sdk-as'
import { Memento, Img, mementoCollection, User, userCollection, Post, Content, postCollection, Comment, commentCollection, balances, approves, transactionCollection, Transaction, Event, events } from './model'

const NAME: string = 'Paras Action Coin'
const SYMBOL: string = 'PAC'
const DECIMALS: u8 = 18
const TOTAL_SUPPLY: u128 = u128.fromString("230000000000000000000000000")

export function name(): string {
	return NAME
}

export function symbol(): string {
	return SYMBOL
}

export function decimals(): u8 {
	return DECIMALS
}

export function totalSupply(): u128 {
	return TOTAL_SUPPLY
}

export function init(initialOwner: string): void {
	assert(storage.get<string>("init") == null, "Already initialized token supply");
	balances.set(initialOwner, TOTAL_SUPPLY);
	const tx = new Transaction("0x", initialOwner, TOTAL_SUPPLY, 'Initial Supply')
	transactionCollection.set(tx.id, tx)
	const ev = new Event('transaction_create', tx.id)
	events.push(ev)
	storage.set("init", "done");
}

export function balanceOf(tokenOwner: string): u128 {
	if (!balances.contains(tokenOwner)) {
		return u128.fromI32(0);
	}
	const result = balances.getSome(tokenOwner);
	return result;
}

export function allowance(tokenOwner: string, spender: string): u128 {
	const key = tokenOwner + ":" + spender;
	if (!approves.contains(key)) {
		return u128.fromI32(0);
	}
	return approves.getSome(key);
}

export function transfer(to: string, tokens: u128, msg: string = ''): boolean {
	const fromAmount = getBalance(context.sender);
	assert(fromAmount >= tokens, "not enough tokens on account");
	assert(getBalance(to) <= u128.add(getBalance(to), tokens), "overflow at the receiver side");
	balances.set(context.sender, u128.sub(fromAmount, tokens));
	balances.set(to, u128.add(getBalance(to), tokens));
	const tx = new Transaction(context.sender, to, tokens, msg)
	transactionCollection.set(tx.id, tx)
	const ev = new Event('transaction_create', tx.id)
	events.push(ev)
	return true;
}

export function approve(spender: string, tokens: u128): boolean {
	approves.set(context.sender + ":" + spender, tokens);
	return true;
}

export function transferFrom(from: string, to: string, tokens: u128, msg: string = ''): boolean {
	const fromAmount = getBalance(from);
	assert(fromAmount >= tokens, "not enough tokens on account");
	const approvedAmount = allowance(from, to);
	assert(tokens <= approvedAmount, "not enough tokens approved to transfer");
	assert(getBalance(to) <= u128.add(getBalance(to), tokens), "overflow at the receiver side");
	balances.set(from, u128.sub(fromAmount, tokens));
	balances.set(to, u128.add(getBalance(to), tokens));
	const tx = new Transaction(from, to, tokens, msg)
	transactionCollection.set(tx.id, tx)
	const ev = new Event('transaction_create', tx.id)
	events.push(ev)
	return true;
}

function getBalance(owner: string): u128 {
	return balances.contains(owner) ? balances.getSome(owner) : u128.fromI32(0);
}

function _percent(value: u128, percent: u32): u128 {
	return u128.div(u128.mul(value, u128.from(percent)), u128.from(100))
}

export function piecePost(
	postId: string,
	value: string
): u128 {
	const tokens = u128.fromString(value)
	const senderBalance = getBalance(context.sender)
	assert(senderBalance >= tokens, 'not enough tokens on account')
	const post = getPostById(postId)
	if (!!post && tokens > u128.from(0)) {
		const memento = getMementoById(post.mementoId)
		const originalPost = getPostById(post.originalId)
		let originalMemento: Memento | null = null

		let postOwnerQuota = 100
		let postMementoQuota = 0
		let postOriginalOwnerQuota = 0
		let postOriginalMementoQuota = 0
		if (memento) {
			postOwnerQuota = 90
			postMementoQuota = 10
			if (post.id != post.originalId) {
				if (originalPost) {
					postOwnerQuota = 5
					postMementoQuota = 5
					postOriginalOwnerQuota = 90
					originalMemento = getMementoById(originalPost.id)
					if (originalMemento) {
						postOriginalOwnerQuota = 80
						postOriginalMementoQuota = 10
					}
				}
			}
		}
		const forPostOwner = _percent(tokens, postOwnerQuota)
		if (forPostOwner > u128.from(0)) {
			// log(forPostOwner)
			transfer(post.owner, forPostOwner, '[Piece] For Post Owner')
		}
		const forMementoOwner = _percent(tokens, postMementoQuota)
		if (!!memento && forMementoOwner > u128.from(0)) {
			// log(forMementoOwner)
			transfer(memento.owner, forMementoOwner, '[Piece] For Memento Owner')
		}
		const forOriginalOwner = _percent(tokens, postOriginalOwnerQuota)
		if (!!originalPost && forOriginalOwner > u128.from(0)) {
			// log(forOriginalOwner)
			transfer(originalPost.owner, forOriginalOwner, '[Piece] For Original Post Owner')
		}
		const forOriginalMemento = _percent(tokens, postOriginalMementoQuota)
		if (!!originalPost && !!originalMemento && forOriginalMemento > u128.from(0)) {
			// log(forOriginalMemento)
			transfer(originalMemento.owner, forOriginalMemento, '[Piece] For Original Memento Owner')
		}
	}
	const latestBalance = getBalance(context.sender)
	return latestBalance
}

export function createMemento(
	name: string,
	category: string,
	img: Img,
	desc: string,
	type: string
): Memento {
	assert(
		type == 'public' || type == 'personal',
		'Memento type must be public or personal'
	)
	const cleanedName = name.replaceAll(' ', '').replaceAll('::', '').toLowerCase()
	const memento = new Memento(cleanedName, category, img, desc, type)

	// check if memento id already taken
	const exist = getMementoById(memento.id)
	assert(
		!exist,
		'Memento id already taken'
	)

	mementoCollection.set(memento.id, memento)
	memento.user = getUserById(memento.owner)

	const ev = new Event('memento_create', memento.id)
	events.push(ev)

	return memento
}

export function getMementoById(
	id: string
): Memento | null {
	const memento = mementoCollection.get(id)
	if (memento) {
		return memento
	}
	return null
}

export function updateMemento(
	id: string,
	img: Img,
	desc: string
): Memento | null {
	const memento = getMementoById(id)
	if (memento) {
		assert(
			memento.owner == context.sender,
			'Memento can only be updated by owner'
		)
		memento.img = img
		memento.desc = desc

		mementoCollection.set(id, memento)
		memento.user = getUserById(memento.owner)

		const ev = new Event('memento_update', memento.id)
		events.push(ev)

		return memento
	}
	return null
}

export function archiveMemento(
	id: string
): Memento | null {
	const memento = getMementoById(id)
	if (memento) {
		assert(
			memento.owner == context.sender,
			'Memento can only be archieved by owner'
		)
		memento.isArchive = true

		mementoCollection.set(id, memento)
		memento.user = getUserById(memento.owner)

		const ev = new Event('memento_update', memento.id)
		events.push(ev)

		return memento
	}
	return null
}

export function unarchiveMemento(
	id: string
): Memento | null {
	const memento = getMementoById(id)
	if (memento) {
		assert(
			memento.owner == context.sender,
			'Memento can only be unarchieved by owner'
		)
		memento.isArchive = false

		mementoCollection.set(id, memento)
		memento.user = getUserById(memento.owner)

		const ev = new Event('memento_update', memento.id)
		events.push(ev)

		return memento
	}
	return null
}

export function deleteMemento(
	id: string
): Memento | null {
	const memento = getMementoById(id)
	if (memento) {
		assert(
			memento.owner == context.sender,
			'Memento can only be deleted by owner'
		)

		mementoCollection.delete(memento.id)
		memento.user = getUserById(memento.owner)

		const ev = new Event('memento_delete', memento.id)
		events.push(ev)

		return memento
	}
	return null
}

export function createPost(
	contentList: Content[],
	mementoId: string
): Post | null {
	const memento = getMementoById(mementoId)
	if (memento) {
		assert(
			!memento.isArchive,
			'Cannot write to archived Memento'
		)
		assert(
			memento.type == 'public' || memento.type == 'personal' && memento.owner == context.sender,
			'Sender does not have access to write to this memento'
		)
		const post = new Post(contentList, mementoId, null)

		postCollection.set(post.id, post)
		post.memento = memento
		post.user = getUserById(post.owner)

		const ev = new Event('post_create', post.id)
		events.push(ev)

		return post
	}
	return null
}

export function transmitPost(
	id: string,
	mementoId: string
): Post | null {
	const post = getPostById(id)
	const memento = getMementoById(mementoId)
	if (post && memento) {
		assert(
			!memento.isArchive,
			'Cannot write to archived Memento'
		)
		assert(
			memento.type == 'public' || memento.type == 'personal' && memento.owner == context.sender,
			'Sender does not have access to write to this memento'
		)

		const newPost = new Post(post.contentList, mementoId, post.originalId)

		postCollection.set(newPost.id, newPost)
		newPost.memento = getMementoById(newPost.mementoId)
		newPost.user = getUserById(newPost.owner)

		const ev = new Event('post_create', newPost.id)
		events.push(ev)

		return newPost
	}
	return null
}

export function updatePost(
	id: string,
	contentList: Content[],
	mementoId: string
): Post | null {
	const post = getPostById(id)
	const memento = getMementoById(mementoId)
	if (!!post && !!memento) {
		assert(
			!memento.isArchive,
			'Cannot write to archived Memento'
		)
		assert(
			memento.type == 'public' || memento.type == 'personal' && memento.owner == context.sender,
			'Sender does not have access to write to this memento'
		)
		assert(
			post.owner == context.sender,
			'Post can only be updated by owner'
		)
		post.contentList = contentList
		post.mementoId = mementoId

		postCollection.set(post.id, post)
		post.memento = memento
		post.user = getUserById(post.owner)

		const ev = new Event('post_update', post.id)
		events.push(ev)

		return post
	}
	return null
}

export function redactPost(
	id: string
): Post | null {
	const post = getPostById(id)
	if (post) {
		const memento = getMementoById(post.mementoId)
		assert(
			!!memento && memento.owner == context.sender,
			'Post can only be redacted by memento owner'
		)

		if (memento) {
			post.mementoId = ''
			postCollection.set(post.id, post)
			post.user = getUserById(post.owner)
	
			const params = [post.id, memento.id]
			const ev = new Event('post_update_redact', params.join('_'))
			events.push(ev)
	
			return post
		}
	}
	return null
}

export function getPostById(
	id: string
): Post | null {
	const post = postCollection.get(id)
	if (post) {
		return post
	}
	return null
}

export function deletePost(
	id: string
): Post | null {
	const post = getPostById(id)
	if (post) {
		assert(
			post.owner == context.sender,
			'Post can only be deleted by post owner'
		)

		postCollection.delete(post.id)

		const ev = new Event('post_delete', post.id)
		events.push(ev)

		return post
	}
	return null
}

export function getUserById(id: string): User | null {
	const user = userCollection.get(id)
	if (user) {
		return user
	}
	return null
}

export function createUser(imgAvatar: Img, bio: string): User {
	const userExist = getUserById(context.sender)
	assert(
		!userExist,
		'User already exist'
	)

	const newUser = new User(imgAvatar, bio)

	userCollection.set(newUser.id, newUser)

	const ev = new Event('user_create', newUser.id)
	events.push(ev)

	return newUser
}

export function updateUser(
	imgAvatar: Img,
	bio: string
): User | null {
	const user = getUserById(context.sender)
	if (user) {
		user.imgAvatar = imgAvatar
		user.bio = bio

		userCollection.set(context.sender, user)

		const ev = new Event('user_update', user.id)
		events.push(ev)

		return user
	}
	return null
}

export function createComment(
	postId: string,
	body: string
): Comment {
	const c = new Comment(postId, body)

	commentCollection.set(c.id, c)

	const ev = new Event('comment_create', c.id)
	events.push(ev)

	return c
}

export function getCommentById(id: string): Comment | null {
	const comment = commentCollection.get(id)
	if (comment) {
		return comment
	}
	return null
}

export function deleteComment(
	id: string
): Comment | null {
	const comment = getCommentById(id)
	if (comment) {
		const post = getPostById(comment.postId)
		assert(
			comment.owner == context.sender || !!post && post.owner == context.sender,
			'Comment can only be deleted by comment owner or post owner'
		)

		commentCollection.delete(comment.id)

		const ev = new Event('comment_delete', comment.id)
		events.push(ev)

		return comment
	}
	return null
}

export function getTransactionById(
	id: string
): Transaction | null {
	const tx = transactionCollection.get(id)
	if (tx) {
		return tx
	}
	return null
}

export function getEventLength(): u64 {
	return events.length
}

export function getEvents(start: i32): Event[] {
	const maxLen = events.length
	assert(
		maxLen > start,
		"Start index is more than current length"
	)
	// only get at most 10 new events
	const diff = min(maxLen - start, 10)
	const result: Event[] = []
	for (let i = start; i < (start + diff); i++) {
		const ev = events[i]
		result.push(ev)
	}
	return result
}
'''
'''--- assembly/model.ts ---
import { context, PersistentMap, PersistentVector, u128 } from 'near-sdk-as'
import { generateId } from './utils'

@nearBindgen
export class Img {
  url: string
  type: string
}

@nearBindgen
export class Link {
  img: Img
  title: string
  desc: string
  url: string
}

@nearBindgen
export class Content {
  type: string
  body: string
}

@nearBindgen
export class Memento {
  id: string
  name: string
  category: string
  img: Img
  desc: string
  type: string
  owner: string
  isArchive: bool
  createdAt: u64
  user: User | null

  constructor(name: string, category: string, img: Img, desc: string, type: string) {
    const tail = type == 'personal' ? context.sender.split('.')[0] : category

    this.id = name.concat('.').concat(tail)
    this.name = name
    this.category = category
    this.img = img
    this.desc = desc
    this.type = type
    this.owner = context.sender
    this.isArchive = false
    this.createdAt = context.blockTimestamp
  }
}

@nearBindgen
export class Post {
  id: string
  originalId: string
  contentList: Content[]
  owner: string
  mementoId: string
  createdAt: u64
  user: User | null
  memento: Memento | null

  constructor(contentList: Content[], mementoId: string, originalId: string | null) {
    const id = generateId()

    this.id = id
    this.originalId = originalId ? originalId : id
    this.contentList = contentList
    this.mementoId = mementoId
    this.owner = context.sender
    this.createdAt = context.blockTimestamp
  }
}

@nearBindgen
export class Comment {
  id: string
  postId: string
  body: string
  owner: string
  createdAt: u64
  user: User | null

  constructor(postId: string, body: string) {
    this.id = generateId()
    this.postId = postId
    this.body = body
    this.owner = context.sender
    this.createdAt = context.blockTimestamp
  }
}

@nearBindgen
export class User {
  id: string
  imgAvatar: Img
  bio: string
  createdAt: u64

  constructor(imgAvatar: Img, bio: string) {
    this.id = context.sender
    this.imgAvatar = imgAvatar
    this.bio = bio
    this.createdAt = context.blockTimestamp
  }
}

@nearBindgen
export class Transaction {
  id: string
  from: string
  to: string
  value: u128
  msg: string
  createdAt: u64

  constructor(from: string, to: string, value: u128, msg: string) {
    this.id = generateId()
    this.from = from
    this.to = to
    this.value = value
    this.msg = msg
    this.createdAt = context.blockTimestamp
  }
}

@nearBindgen
export class Event {
  id: string
  msg: string
  params: string
  createdAt: u64

  constructor(msg: string, params: string) {
    this.id = events.length.toString()
    this.msg = msg
    this.params = params
    this.createdAt = context.blockTimestamp
  }
}

export const mementoCollection = new PersistentMap<string, Memento>('memento')
export const postCollection = new PersistentMap<string, Post>('post')
export const userCollection = new PersistentMap<string, User>('user')
export const commentCollection = new PersistentMap<string, Comment>('comment')
export const transactionCollection = new PersistentMap<string, Transaction>('pac:tx')
export const balances = new PersistentMap<string, u128>("pac:b")
export const approves = new PersistentMap<string, u128>("pac:a")
export const events = new PersistentVector<Event>('event')
'''
'''--- assembly/tsconfig.json ---
{
  "extends": "assemblyscript/std/assembly.json",
  "include": [
    "./**/*.ts"
  ]
}
'''
'''--- assembly/utils.ts ---
import { math, base58 } from 'near-sdk-as'

export function generateId(): string {
	const buff = math.randomBuffer(8)

	var randomId = base58.encode(buff)
	return randomId.replaceAll('/', '')
}
'''
'''--- config.js ---
function getConfig(env) {
  if (!process.env.CONTRACT_NAME) {
    throw "[env] CONTRACT_NAME not found"
  }
  switch (env) {
    case 'production':
    case 'mainnet':
      return {
        networkId: 'mainnet',
        nodeUrl: 'https://rpc.mainnet.near.org',
        contractName: process.env.CONTRACT_NAME,
        walletUrl: 'https://wallet.mainnet.near.org',
        helperUrl: 'https://helper.mainnet.near.org',
      }
    case 'development':
    case 'testnet':
      return {
        networkId: 'default',
        nodeUrl: 'https://rpc.testnet.near.org',
        contractName: process.env.CONTRACT_NAME,
        walletUrl: 'https://wallet.testnet.near.org',
        helperUrl: 'https://helper.testnet.near.org',
      }
    case 'devnet':
      return {
        networkId: 'devnet',
        nodeUrl: 'https://rpc.devnet.near.org',
        contractName: process.env.CONTRACT_NAME,
        walletUrl: 'https://wallet.devnet.near.org',
        helperUrl: 'https://helper.devnet.near.org',
      }
    case 'betanet':
      return {
        networkId: 'betanet',
        nodeUrl: 'https://rpc.betanet.near.org',
        contractName: process.env.CONTRACT_NAME,
        walletUrl: 'https://wallet.betanet.near.org',
        helperUrl: 'https://helper.betanet.near.org',
      }
    case 'local':
      return {
        networkId: 'local',
        nodeUrl: 'http://localhost:3030',
        keyPath: `${process.env.HOME}/.near/validator_key.json`,
        walletUrl: 'http://localhost:4000/wallet',
        contractName: process.env.CONTRACT_NAME,
      }
    case 'test':
    case 'ci':
      return {
        networkId: 'shared-test',
        nodeUrl: 'https://rpc.ci-testnet.near.org',
        contractName: process.env.CONTRACT_NAME,
        masterAccount: 'test.near',
      }
    case 'ci-betanet':
      return {
        networkId: 'shared-test-staging',
        nodeUrl: 'https://rpc.ci-betanet.near.org',
        contractName: process.env.CONTRACT_NAME,
        masterAccount: 'test.near',
      }
    default:
      throw Error(`Unconfigured environment '${env}'. Can be configured in src/config.js.`)
  }
}

module.exports = getConfig

'''
'''--- package.json ---
{
  "name": "near-contract-template",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "dev:contract": "NODE_ENV=development nodemon --watch assembly -e ts --exec asp",
    "build:contract": "asb",
    "deploy:contract": "NODE_ENV=development npm run build:contract && near dev-deploy"
  },
  "dependencies": {
    "near-api-js": "^0.29.0"
  },
  "devDependencies": {
    "near-sdk-as": "^1.0.1",
    "near-shell": "^0.24.9",
    "nodemon": "^2.0.4"
  },
  "author": "Rahmat Albariqi",
  "license": "MIT"
}

'''