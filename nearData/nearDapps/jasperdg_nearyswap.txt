*GitHub Repository "jasperdg/nearyswap"*

'''--- Cargo.toml ---
[package]
name = "nearyswap"
version = "0.1.0"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "2.0.0"
num-integer = "0.1.43"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"

[workspace]
members = []
'''
'''--- build.sh ---

#!/bin/bash
set -e
cargo build --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/status_message.wasm ./res/
'''
'''--- src/lib.rs ---
#[global_allocator]
static ALLOC: near_sdk::wee_alloc::WeeAlloc<'_> = near_sdk::wee_alloc::WeeAlloc::INIT;

mod mintable_fungible_token;
mod pool;

#[cfg(not(target_arch = "wasm32"))]
#[cfg(test)]
mod tests {
    use super::*;
    use near_sdk::MockedBlockchain;
    use near_sdk::json_types::U128;
    use near_sdk::{testing_env, VMContext};

    fn alice() -> String {
        "alice.near".to_string()
    }
    fn bob() -> String {
        "bob.near".to_string()
    }
    fn carol() -> String {
        "carol.near".to_string()
    }

    fn min_liq() -> u128 {
        return 1000;
    }

    fn get_context(predecessor_account_id: String) -> VMContext {
        VMContext {
            current_account_id: alice(),
            signer_account_id: bob(),
            signer_account_pk: vec![0, 1, 2],
            predecessor_account_id,
            input: vec![],
            block_index: 0,
            block_timestamp: 0,
            account_balance: 1_000_000_000_000_000_000_000_000_000u128,
            account_locked_balance: 0,
            storage_usage: 10u64.pow(6),
            attached_deposit: 0,
            prepaid_gas: 10u64.pow(18),
            random_seed: vec![0, 1, 2],
            is_view: false,
            output_data_receivers: vec![],
            epoch_height: 0,
        }
    }

    mod pool_test;
}
'''
'''--- src/mintable_fungible_token.rs ---
/**
* Fungible Token implementation with JSON serialization.
* NOTES:
*  - The maximum balance value is limited by U128 (2**128 - 1).
*  - JSON calls should pass U128 as a base-10 string. E.g. "100".
*  - The contract optimizes the inner trie structure by hashing account IDs. It will prevent some
*    abuse of deep tries. Shouldn't be an issue, once NEAR clients implement full hashing of keys.
*  - The contract tracks the change in storage before and after the call. If the storage increases,
*    the contract requires the caller of the contract to attach enough deposit to the function call
*    to cover the storage cost.
*    This is done to prevent a denial of service attack on the contract by taking all available storage.
*    If the storage decreases, the contract will issue a refund for the cost of the released storage.
*    The unused tokens from the attached deposit are also refunded, so it's safe to
*    attach more deposit than required.
*  - To prevent the deployed contract from being modified or deleted, it should not have any access
*    keys on its account.
*/
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LookupMap;
use near_sdk::json_types::U128;
use near_sdk::{env, near_bindgen, AccountId, Balance, Promise, StorageUsage};

/// Price per 1 byte of storage from mainnet genesis config.
const STORAGE_PRICE_PER_BYTE: Balance = 100000000000000000000;

/// Contains balance and allowances information for one account.
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Account {
    /// Current account balance.
    pub balance: Balance,
    /// Escrow Account ID hash to the allowance amount.
    /// Allowance is the amount of tokens the Escrow Account ID can spent on behalf of the account
    /// owner.
    pub allowances: LookupMap<Vec<u8>, Balance>,
    /// The number of allowances
    pub num_allowances: u32,
}

impl Account {
    /// Initializes a new Account with 0 balance and no allowances for a given `account_hash`.
    pub fn new(account_hash: Vec<u8>) -> Self {
        Self { balance: 0, allowances: LookupMap::new(account_hash), num_allowances: 0 }
    }

    /// Sets allowance for account `escrow_account_id` to `allowance`.
    pub fn set_allowance(&mut self, escrow_account_id: &AccountId, allowance: Balance) {
        let escrow_hash = env::sha256(escrow_account_id.as_bytes());
        if allowance > 0 {
            if self.allowances.insert(&escrow_hash, &allowance).is_none() {
                self.num_allowances += 1;
            }
        } else {
            if self.allowances.remove(&escrow_hash).is_some() {
                self.num_allowances -= 1;
            }
        }
    }

    /// Returns the allowance of account `escrow_account_id`.
    pub fn get_allowance(&self, escrow_account_id: &AccountId) -> Balance {
        let escrow_hash = env::sha256(escrow_account_id.as_bytes());
        self.allowances.get(&escrow_hash).unwrap_or(0)
    }
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct MintableFungibleToken {
    /// sha256(AccountID) -> Account details.
    pub accounts: LookupMap<Vec<u8>, Account>,

    /// Total supply of the all token.
    pub total_supply: Balance,
}

impl Default for MintableFungibleToken {
    fn default() -> Self {
        panic!("Fun token should be initialized before usage")
    }
}

#[near_bindgen]
impl MintableFungibleToken {
    /// Initializes the contract with the given total supply owned by the given `owner_id`.
    #[init]
    pub fn new() -> Self {
        let total_supply = 0;
        assert!(!env::state_exists(), "Already initialized");
        Self { accounts: LookupMap::new(b"a".to_vec()), total_supply }
    }

    /// Increments the `allowance` for `escrow_account_id` by `amount` on the account of the caller of this contract
    /// (`predecessor_id`) who is the balance owner.
    /// Requirements:
    /// * Caller of the method has to attach deposit enough to cover storage difference at the
    ///   fixed storage price defined in the contract.
    #[payable]
    pub fn inc_allowance(&mut self, escrow_account_id: AccountId, amount: U128) {
        let initial_storage = env::storage_usage();
        assert!(
            env::is_valid_account_id(escrow_account_id.as_bytes()),
            "Escrow account ID is invalid"
        );
        let owner_id = env::predecessor_account_id();
        if escrow_account_id == owner_id {
            env::panic(b"Can not increment allowance for yourself");
        }
        let mut account = self.get_account(&owner_id);
        let current_allowance = account.get_allowance(&escrow_account_id);
        account.set_allowance(&escrow_account_id, current_allowance.saturating_add(amount.0));
        self.set_account(&owner_id, &account);
        self.refund_storage(initial_storage);
    }

    /// Decrements the `allowance` for `escrow_account_id` by `amount` on the account of the caller of this contract
    /// (`predecessor_id`) who is the balance owner.
    /// Requirements:
    /// * Caller of the method has to attach deposit enough to cover storage difference at the
    ///   fixed storage price defined in the contract.
    #[payable]
    pub fn dec_allowance(&mut self, escrow_account_id: AccountId, amount: U128) {
        let initial_storage = env::storage_usage();
        assert!(
            env::is_valid_account_id(escrow_account_id.as_bytes()),
            "Escrow account ID is invalid"
        );
        let owner_id = env::predecessor_account_id();
        if escrow_account_id == owner_id {
            env::panic(b"Can not decrement allowance for yourself");
        }
        let mut account = self.get_account(&owner_id);
        let current_allowance = account.get_allowance(&escrow_account_id);
        account.set_allowance(&escrow_account_id, current_allowance.saturating_sub(amount.0));
        self.set_account(&owner_id, &account);
        self.refund_storage(initial_storage);
    }

    /// Transfers the `amount` of tokens from `owner_id` to the `new_owner_id`.
    /// Requirements:
    /// * `amount` should be a positive integer.
    /// * `owner_id` should have balance on the account greater or equal than the transfer `amount`.
    /// * If this function is called by an escrow account (`owner_id != predecessor_account_id`),
    ///   then the allowance of the caller of the function (`predecessor_account_id`) on
    ///   the account of `owner_id` should be greater or equal than the transfer `amount`.
    /// * Caller of the method has to attach deposit enough to cover storage difference at the
    ///   fixed storage price defined in the contract.
    #[payable]
    pub fn transfer_from(&mut self, owner_id: AccountId, new_owner_id: AccountId, amount: U128) {
        let initial_storage = env::storage_usage();
        assert!(
            env::is_valid_account_id(new_owner_id.as_bytes()),
            "New owner's account ID is invalid"
        );
        let amount = amount.into();
        if amount == 0 {
            env::panic(b"Can't transfer 0 tokens");
        }
        assert_ne!(
            owner_id, new_owner_id,
            "The new owner should be different from the current owner"
        );
        // Retrieving the account from the state.
        let mut account = self.get_account(&owner_id);

        // Checking and updating unlocked balance
        if account.balance < amount {
            env::panic(b"Not enough balance");
        }
        account.balance -= amount;

        // If transferring by escrow, need to check and update allowance.
        let escrow_account_id = env::predecessor_account_id();
        if escrow_account_id != owner_id {
            let allowance = account.get_allowance(&escrow_account_id);
            if allowance < amount {
                env::panic(b"Not enough allowance");
            }
            account.set_allowance(&escrow_account_id, allowance - amount);
        }

        // Saving the account back to the state.
        self.set_account(&owner_id, &account);

        // Deposit amount to the new owner and save the new account to the state.
        let mut new_account = self.get_account(&new_owner_id);
        new_account.balance += amount;
        self.set_account(&new_owner_id, &new_account);
        self.refund_storage(initial_storage);
    }

    /// Transfer `amount` of tokens from the caller of the contract (`predecessor_id`) to
    /// `new_owner_id`.
    /// Act the same was as `transfer_from` with `owner_id` equal to the caller of the contract
    /// (`predecessor_id`).
    /// Requirements:
    /// * Caller of the method has to attach deposit enough to cover storage difference at the
    ///   fixed storage price defined in the contract.
    #[payable]
    pub fn transfer(&mut self, new_owner_id: AccountId, amount: U128) {
        // NOTE: New owner's Account ID checked in transfer_from.
        // Storage fees are also refunded in transfer_from.
        self.transfer_from(env::predecessor_account_id(), new_owner_id, amount);
    }

    /// Returns total supply of tokens.
    pub fn get_total_supply(&self) -> U128 {
        self.total_supply.into()
    }

    /// Returns balance of the `owner_id` account.
    pub fn get_balance(&self, owner_id: AccountId) -> U128 {
        self.get_account(&owner_id).balance.into()
    }

    /// Returns current allowance of `escrow_account_id` for the account of `owner_id`.
    ///
    /// NOTE: Other contracts should not rely on this information, because by the moment a contract
    /// receives this information, the allowance may already be changed by the owner.
    /// So this method should only be used on the front-end to see the current allowance.
    pub fn get_allowance(&self, owner_id: AccountId, escrow_account_id: AccountId) -> U128 {
        assert!(
            env::is_valid_account_id(escrow_account_id.as_bytes()),
            "Escrow account ID is invalid"
        );
        self.get_account(&owner_id).get_allowance(&escrow_account_id).into()
    }

    pub fn mint (&mut self, owner_id: &AccountId, amount: u128) {
        let cur_balance: u128 = self.get_balance(owner_id.to_string()).into();
        let new_balance = cur_balance + amount;

        let mut account = self.get_account(owner_id);
        account.balance += amount;
        self.set_account(&owner_id, &account);

        self.total_supply += amount;
    }
    
    pub fn burn (&mut self, owner_id: &AccountId, amount: u128) {
        let cur_balance: u128 = self.get_balance(owner_id.to_string()).into();
        assert!(cur_balance > amount, "user doesn't have enough balance to burn");
        let new_balance = cur_balance + amount;

        let mut account = self.get_account(owner_id);
        account.balance -= amount;
        self.set_account(&owner_id, &account);

        self.total_supply -= amount;
    }
}

impl MintableFungibleToken {
    /// Helper method to get the account details for `owner_id`.
    fn get_account(&self, owner_id: &AccountId) -> Account {
        assert!(env::is_valid_account_id(owner_id.as_bytes()), "Owner's account ID is invalid");
        let account_hash = env::sha256(owner_id.as_bytes());
        self.accounts.get(&account_hash).unwrap_or_else(|| Account::new(account_hash))
    }

    /// Helper method to set the account details for `owner_id` to the state.
    fn set_account(&mut self, owner_id: &AccountId, account: &Account) {
        let account_hash = env::sha256(owner_id.as_bytes());
        if account.balance > 0 || account.num_allowances > 0 {
            self.accounts.insert(&account_hash, &account);
        } else {
            self.accounts.remove(&account_hash);
        }
    }

    fn refund_storage(&self, initial_storage: StorageUsage) {
        let current_storage = env::storage_usage();
        let attached_deposit = env::attached_deposit();
        let refund_amount = if current_storage > initial_storage {
            let required_deposit =
                Balance::from(current_storage - initial_storage) * STORAGE_PRICE_PER_BYTE;
            assert!(
                required_deposit <= attached_deposit,
                "The required attached deposit is {}, but the given attached deposit is is {}",
                required_deposit,
                attached_deposit,
            );
            attached_deposit - required_deposit
        } else {
            attached_deposit
                + Balance::from(initial_storage - current_storage) * STORAGE_PRICE_PER_BYTE
        };
        if refund_amount > 0 {
            env::log(format!("Refunding {} tokens for storage", refund_amount).as_bytes());
            Promise::new(env::predecessor_account_id()).transfer(refund_amount);
        }
    }
}
'''
'''--- src/pool.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{env, near_bindgen, AccountId};
use near_sdk::collections::{UnorderedMap, Vector};
use near_sdk::json_types::U128;
use num_integer::Roots;
use std::cmp;
use crate::mintable_fungible_token;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Pool {
    token0: AccountId,
    token1: AccountId,
    reserve0: u128,
    reserve1: u128,
    min_liquidity: u128,

    // TODO: all these attributes will be moved to fungible token
    token: mintable_fungible_token::MintableFungibleToken,
    // total_supply: u128,
    // balances: UnorderedMap<AccountId, u128>
}

impl Default for Pool {
    fn default() -> Self {
        panic!("Fun token should be initialized before usage")
    }
}

#[near_bindgen]
impl Pool {

    #[init]
    pub fn new(token0: AccountId, token1: AccountId) -> Self {
        Self {
            token0,
            token1,
            reserve0: 0,
            reserve1: 0,
            min_liquidity: (10 as u128).pow(3),
            token: mintable_fungible_token::MintableFungibleToken::new(),
        }
    }

    fn update(&mut self, new_balance0: u128, new_balance1: u128) {
        self.reserve0 = new_balance0;
        self.reserve1 = new_balance1;
    }

    pub fn add_liquidity(&mut self, amount0: U128, amount1: U128) {
        let mut liquidity;
        let amount0: u128 = amount0.into();
        let amount1: u128 = amount1.into();

        // TODO: transfer tokens to this contract
        assert!((amount0 * amount1).sqrt() > self.min_liquidity);

        if self.token.total_supply == 0 {
            liquidity = (amount0 * amount1).sqrt() - self.min_liquidity;
            self.token.mint(&("null_address.near".to_string()), self.min_liquidity);
        } else {
            liquidity = cmp::min(
                amount0 * self.token.total_supply / self.reserve0, 
                amount1 * self.token.total_supply / self.reserve1
            );
        }

        assert!(liquidity >  0, "not enough liquidity suplied");

        self.token.mint(&env::predecessor_account_id(), liquidity);
        self.update(self.reserve0 + amount0, self.reserve1 + amount1);
    }

    pub fn remove_liquidity(&mut self) {
        let liquidity: u128 = self.token.get_balance(env::predecessor_account_id()).into();
        assert!(liquidity > 0, "user has no liquidity to remove");

        let amount0 = liquidity * self.reserve0 / self.token.total_supply;
        let amount1 = liquidity * self.reserve1 / self.token.total_supply;

        assert!(amount0 > 0 && amount1 > 0, "not enough liquidity burned");

        // TODO transfer t0 and t1 to user

        self.update(self.reserve0 - amount0, self.reserve1 - amount1);
        self.token.burn(&env::predecessor_account_id(), liquidity);
    }

    pub fn swap_t0_for_t1(&mut self, amount_out: U128) {
        let amount_out: u128 = amount_out.into();
        assert!(amount_out < self.reserve1, "not enough liquidity");
        assert!(amount_out > 0, "invalid output amount");

        let r0 = self.reserve0;
        let r1 = self.reserve1;
        let k = r0 * r1;

        let cost_numerator = r0 * amount_out * 1000;
        let cost_denom = (r1 - amount_out) * 997;
        let cost = cost_numerator / cost_denom + 1;
        let new_r0 = r0 + cost;
        let new_r1 = r1 - amount_out;

        println!("cost: {} new_r1 {} new_r2 {} old_k: {} new_k {} ", cost, new_r0, new_r1, k, new_r0 * new_r1);

        // TODO: transfer cost of r0 to contract
        // TODO: transfer amount_out to sender

        self.update(new_r0, new_r1);
    }
    
    pub fn swap_t1_for_t0(&mut self, amount_out: U128) {
        let amount_out: u128 = amount_out.into();
        assert!(amount_out < self.reserve0, "not enough liquidity");
        assert!(amount_out > 0, "invalid output amount");

        let r0 = self.reserve0;
        let r1 = self.reserve1;
        let k = r0 * r1;

        let cost_numerator = r1 * amount_out * 1000;
        let cost_denom = (r0 - amount_out) * 997;
        let cost = cost_numerator / cost_denom + 1;
        let new_r0 = r0 - amount_out;
        let new_r1 = r1 + cost; 

        println!("cost: {} new_r1 {} new_r2 {} old_k: {} new_k {} ", cost, new_r0, new_r1, k, new_r0 * new_r1);
        // TODO: transfer cost of r0 to contract
        // TODO: transfer amount_out to sender

        self.update(new_r0, new_r1);
    }

    pub fn get_balance(&self, owner: AccountId) -> U128 {
        return self.token.get_balance(owner);
    }

    // getter functions

    //  pub fn get_curr_price_t0(&self) -> u128 {
    //     self.
    //  }

    // TODO: expose standard erc20 interface so that pool tokens can be transfered etc.
}

'''
'''--- src/tests/pool_test.rs ---
use super::*;

#[test]
fn init() {
    let context = get_context(carol());
    testing_env!(context);
    
    let mut contract = pool::Pool::new("t1".to_string(), "t2".to_string());
    
    contract.add_liquidity(U128(100000000), U128(100000000));
    let balance = contract.get_balance(carol());
    assert_eq!(balance, U128(100000000 - min_liq()));
    
    // let context = get_context(alice());
    // testing_env!(context);
    // contract.add_liquidity(U128(10000), U128(10000));
    // let balance = contract.get_balance(alice());
    // assert_eq!(balance, U128(10000));
    
    contract.swap_t0_for_t1(U128(100));
    contract.swap_t0_for_t1(U128(100));
    contract.swap_t0_for_t1(U128(100));
    contract.swap_t1_for_t0(U128(100));
}
'''
'''--- test.sh ---
cargo test -p nearyswap -- --nocapture
'''