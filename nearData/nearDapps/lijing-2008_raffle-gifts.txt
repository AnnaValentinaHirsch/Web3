*GitHub Repository "lijing-2008/raffle-gifts"*

'''--- README.md ---
<div align="center">
  <h1 align="center">Raffle Gifts</h1>
  <a href="https://blog.rust-lang.org/2022/07/19/Rust-1.62.1.html"><img alt="Rust Version" src="https://img.shields.io/badge/rust-1.62%2B-blue" /></a>  
    <a href="https://react.docschina.org/versions"><img alt="Rust Version" src="https://img.shields.io/badge/react-v18.2.0-ff69b4" /></a>
    <a href="https://cn.vitejs.dev/"><img alt="Rust Version" src="https://img.shields.io/badge/vite-v3.0.7-brightgreen" /></a>
  <img alt="Github stars" src="https://img.shields.io/github/stars/lijing-2008/raffle-gifts?color=56BEB8" />
  <img alt="Github forks" src="https://img.shields.io/github/forks/lijing-2008/raffle-gifts?color=56BEB8" />
  </div>

<h4 align="center"> 
	üöß üöÄ Under construction... üöÄ üöß
</h4>

<hr>

<p align="center">
  <a href="#dart-about">About</a> &#xa0; | &#xa0; 
  <a href="#sparkles-features">Features</a> &#xa0; | &#xa0;
  <a href="#rocket-technologies">Technologies</a> &#xa0; | &#xa0;
  <a href="#white_check_mark-requirements">Requirements</a> &#xa0; | &#xa0;
  <a href="#checkered_flag-starting">Starting</a> &#xa0; | &#xa0;
  <a href="#tada-usage">Usage</a> &#xa0; | &#xa0;
  <a href="#memo-license">License</a> &#xa0; | &#xa0;
  <a href="https://github.com/lijing-2008" target="_blank">Author</a>
</p>

## :dart: About

Welcome to Raffle Gifts, it is a NFT game inspired by Asphalt 8, and developed on NEAR Blockchain. The game offers two user roles. As an Administrator, you can mint NFTs into the prize pool. As a normal user, you can draw NFTs with spending some NEARs.

## :sparkles: Features

:heavy_check_mark: **Role:** Admin & normal user

:heavy_check_mark: Smart Contract built with NEAR + RUST

:heavy_check_mark: Frontend built with React + Vite + unocss + Antd

:heavy_check_mark: NFTs provide 4 levels: **N** & **R** & **SR** & **SSR**

:heavy_check_mark: Raffle spending provide 3 levels: 0.1 ‚ìÉ / 0.2 ‚ìÉ / 0.5 ‚ìÉ

:heavy_check_mark: Odds of winning

| NEAR Cost |  N  |  R  | SR  | SSR |
| :-------: | :-: | :-: | :-: | :-: |
|   0.1 ‚ìÉ   | 40% | 30% | 25% | 5%  |
|   0.2 ‚ìÉ   | 25% | 35% | 30% | 10% |
|   0.5 ‚ìÉ   | 10% | 40% | 35% | 15% |

## :rocket: Technologies

- [NEAR](https://docs.near.org/)
- [Rust](https://www.rust-lang.org/zh-CN/)
- [React](https://pt-br.reactjs.org/)
- [Vite](https://cn.vitejs.dev/)
- [Unocss](https://github.com/unocss/unocss)
- [Antd](https://ant.design/index-cn)

## :white_check_mark: Requirements

Before starting :checkered_flag:, you need do some preparations.

- [NEAR Wallet Account](https://wallet.testnet.near.org)
- [Rust Toolchain](https://docs.near.org/develop/prerequisites)
- [Node](https://nodejs.org/en/)
- [Web3.storage](https://web3.storage/)

## :checkered_flag: Starting

### Deploy Smart Contract

```bash
# Compile WASM file
cd nft-contract
./build.sh

# Deploy
export NFT_CONTRACT_ID=Your_Account_id
near deploy --wasmFile res/main.wasm --accountId $NFT_CONTRACT_ID --nodeUrl https://public-rpc.blockpi.io/http/near-testnet
```

### Start Frontend UI

```bash
cd react-vite
npm install
npm run dev
```

## :tada: Usage

At first, you need to connect to your NEAR wallet just by click the Connect Wallets button.

![login.png](https://tva1.sinaimg.cn/large/e6c9d24egy1h5olzdi35dj217r0u0ach.jpg)

### üå¥ Mint NFTs

You need to login with administrator account id

![mintNFT.png](https://tva1.sinaimg.cn/large/e6c9d24egy1h5qvoeo90vj21440u0q7i.jpg)

Select your NFT image from local directory, its media url will input automatically. Then input other necessary info. At last, click the Mint button to redirect to connect your wallet and confirm your transaction.
if you haven't set your web3.storage token, you need to set it at first, when you select a pic there is a modal offer you for setting.

![setWebToken.png](https://img1.imgtp.com/2022/09/01/lPlmMHzu.png)

### ‚òòÔ∏è Raffle NFTs

You need to login with regular user account id

![raffleNFT.png](https://tva1.sinaimg.cn/large/e6c9d24egy1h5qvot2p5yj218a0u0dl8.jpg)

Make your choise how much would you spend to raffle NFTs, the most recently raffle NFT will show on your right side, and all your NTFs will show.

### ‚úåÔ∏è Transfer NFTs

You can transfer your NFT to anyone else, but the owner must be yourself.

![transferNFT.png](https://tva1.sinaimg.cn/large/e6c9d24egy1h5pq1u6j7qj21470u0dls.jpg)

when your cursor hover the NFT you will get a tooltip, which show you some details, and offer the ability to transfer your NFT, you just need to input the account name who you want to transfer to.

### üåà Account Management

You can view your Account Balance Details when hover the avatar, and you can logout by click the logout button. If you are the contract owner, you will see a button named "Manage admins", click it to manage Administrators, you can add and delete administrator for now.

![userManage.png](https://tva1.sinaimg.cn/large/e6c9d24egy1h5qvqknuyxj225p0u0jwy.jpg)

Account details contain below:

- total
- available
- stateStaked
- staked
- total NFTs (owned by your account)

## :memo: License

This project is under license from MIT. For more details, see the [LICENSE](LICENSE.md) file.

Made with :heart: by <a href="https://github.com/lijing-2008" target="_blank">Crazy Coder LJ</a>

## ü•∑üèª Just enjoy yourself

You can deploy the contract in your account, and play with it!

'''
'''--- nft-contract/Cargo.toml ---
[package]
name = "nft-contract"
version = "0.1.0"
authors = ["Near <jingli14@tsinghua.org.cn>"]
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk="4.0"
serde_json="1.0"

[profile.release]
codegen-units=1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[dev-dependencies]
anyhow = "1.0"
borsh = "0.9"
maplit = "1.0"
near-units = "0.2.0"
# arbitrary_precision enabled for u128 types that workspaces requires for Balance types
serde_json = { version = "1.0", features = ["arbitrary_precision"] }
tokio = { version = "1.18.1", features = ["full"] }
tracing = "0.1"
tracing-subscriber = { version = "0.3.11", features = ["env-filter"] }
workspaces = "0.4.1"
pkg-config = "0.3.1"

[[example]]
name="tests"
path="tests/integration-tests.rs"
'''
'''--- nft-contract/build.sh ---
set -e && RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release && mkdir -p ./res && cp target/wasm32-unknown-unknown/release/*.wasm ./res/main.wasm
'''
'''--- nft-contract/src/admin.rs ---
use crate::*;

pub trait AdminCore {
    // add admin
    fn admin_add(&mut self, account_id: AccountId);
    // remove admin
    fn admin_remove(&mut self, account_id: AccountId);
}

#[near_bindgen]
impl AdminCore for Contract {
    // add admin
    #[payable]
    fn admin_add(&mut self, account_id: AccountId) {
        assert_at_least_one_yocto();
        let caller_id = env::predecessor_account_id();
        assert_eq!(
            caller_id, self.owner_id,
            "Only the contract owner can add admin user."
        );
        // measure the initial storage being used on the contract
        let initial_storage_usage = env::storage_usage();
        // insert admin account.
        self.admins.insert(&account_id);
        // calculate required_storage
        let required_storage_in_bytes = env::storage_usage() - initial_storage_usage;
        refund_deposit(required_storage_in_bytes);
    }
    // remove admin
    #[payable]
    fn admin_remove(&mut self, account_id: AccountId) {
        assert_at_least_one_yocto();
        let caller_id = env::predecessor_account_id();
        // make sure only contract owner can remove admin
        assert_eq!(
            caller_id, self.owner_id,
            "Only the contract owner can add admin user."
        );
        // make sure account to be removed is not the contract owner
        assert_ne!(caller_id, account_id, "Can not remove conatract owner");
        self.admins.remove(&account_id);
        // refund removed account storage and send near to the contract owner
        refund_account_id(caller_id, account_id);
    }
}

'''
'''--- nft-contract/src/enumeration.rs ---
use crate::*;

#[near_bindgen]
impl Contract {
    // query all admins
    pub fn admins(&self) -> Vec<AccountId> {
        self.admins.to_vec()
    }
    // check account is admin or not
    pub fn is_admin(&self, account_id: AccountId) -> u8 {
        match self.admins.contains(&account_id) {
            true => 1,
            false => 0,
        }
    }

    //Query for the total supply of NFTs on the contract
    pub fn nft_total_supply(&self) -> U128 {
        U128(self.token_metadata_by_id.len() as u128)
    }

    //Query for nft tokens on the contract regardless of the owner using pagination
    pub fn nft_tokens(&self, from_index: Option<U128>, limit: Option<u64>) -> Vec<JsonToken> {
        let start = u128::from(from_index.unwrap_or(U128(0)));
        self.token_metadata_by_id
            .keys()
            .skip(start as usize)
            .take(limit.unwrap_or(50) as usize)
            .map(|token_id| self.nft_token(token_id.clone()).unwrap())
            .collect()
    }

    //get the total supply of NFTs for a given owner
    pub fn nft_supply_for_owner(&self, account_id: AccountId) -> U128 {
        let tokens_set_owner_id = self.tokens_per_owner.get(&account_id);
        if let Some(tokens_set) = tokens_set_owner_id {
            U128(tokens_set.len() as u128)
        } else {
            U128(0)
        }
    }

    //Query for all the tokens for an owner
    pub fn nft_tokens_for_owner(
        &self,
        account_id: AccountId,
        from_index: Option<U128>,
        limit: Option<u64>,
    ) -> Vec<JsonToken> {
        // get the set of tokens for the passed in owner
        let tokens_for_owner_set = self.tokens_per_owner.get(&account_id);
        // if there is some set of tokens,set the tokens variable equal to that set
        let tokens = if let Some(tokens_set) = tokens_for_owner_set {
            tokens_set
        } else {
            // if there is no set of tokens,simply return an empty vector
            return vec![];
        };

        // where to start pagination - if we have a from_index,we'll use that - otherwise start from 0 index
        let start = u128::from(from_index.unwrap_or(U128(0)));
        // iterate through the keys vector
        tokens
            .iter()
            .skip(start as usize)
            .take(limit.unwrap_or(50) as usize)
            .map(|token_id| self.nft_token(token_id.clone()).unwrap())
            .collect()
    }

    // Query for all the raffle tokens for a given token leve
    pub fn nft_raffle_tokens_by_level(
        &self,
        from_index: Option<U128>,
        limit: Option<u64>,
        level: TokenLevel,
    ) -> Vec<JsonToken> {
        let tokens_for_raffle_vector =
            self.raffle_tokens_per_level.get(&level).unwrap_or_else(|| {
                // if the level doesn't have any tokens, we create a new vector
                Vector::new(
                    StorageKey::RaffleTokensPerLevelInner {
                        level_hash: hash_level(&level),
                    }
                    .try_to_vec()
                    .unwrap(),
                )
            });
        let start = u128::from(from_index.unwrap_or(U128(0)));
        if tokens_for_raffle_vector.is_empty() {
            vec![]
        } else {
            tokens_for_raffle_vector
                .iter()
                .skip(start as usize)
                .take(limit.unwrap_or(50) as usize)
                .map(|token_id| self.nft_token(token_id).unwrap())
                .collect()
        }
    }

    pub fn nft_raffle_total_by_level(&self, level: TokenLevel) -> u64 {
        let tokens_for_raffle_vector =
            self.raffle_tokens_per_level.get(&level).unwrap_or_else(|| {
                // if the level doesn't have any tokens, we create a new vector
                Vector::new(
                    StorageKey::RaffleTokensPerLevelInner {
                        level_hash: hash_level(&level),
                    }
                    .try_to_vec()
                    .unwrap(),
                )
            });
        tokens_for_raffle_vector.len()
    }
}

'''
'''--- nft-contract/src/events.rs ---
use std::fmt;

use near_sdk::serde::{Deserialize, Serialize};

/// Enum that represents the data type of the EventLog.
/// The enum can either be an NftMint or an NftTransfer.
#[derive(Serialize, Deserialize, Debug)]
#[serde(tag = "event", content = "data")]
#[serde(rename_all = "snake_case")]
#[serde(crate = "near_sdk::serde")]
#[non_exhaustive]
pub enum EventLogVariant {
    NftMint(Vec<NftMintLog>),
    NftTransfer(Vec<NftTransferLog>),
}

/// Interface to capture data about an event
///
/// Arguments:
/// * `standard`: name of standard e.g. nep171
/// * `version`: e.g. 1.0.0
/// * `event`: associate event data
#[derive(Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct EventLog {
    pub standard: String,
    pub version: String,

    // `flatten` to not have "event": {<EventLogVariant>} in the JSON, just have the contents of {<EventLogVariant>}.
    #[serde(flatten)]
    pub event: EventLogVariant,
}

impl fmt::Display for EventLog {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_fmt(format_args!(
            "EVENT_JSON:{}",
            &serde_json::to_string(self).map_err(|_| fmt::Error)?
        ))
    }
}

/// An event log to capture token minting
///
/// Arguments
/// * `owner_id`: "account.near"
/// * `token_ids`: ["1", "abc"]
/// * `memo`: optional message
#[derive(Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct NftMintLog {
    pub owner_id: String,
    pub token_ids: Vec<String>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub memo: Option<String>,
}

/// An event log to capture token transfer
///
/// Arguments
/// * `authorized_id`: approved account to transfer
/// * `old_owner_id`: "owner.near"
/// * `new_owner_id`: "receiver.near"
/// * `token_ids`: ["1", "12345abc"]
/// * `memo`: optional message
#[derive(Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct NftTransferLog {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub authorized_id: Option<String>,

    pub old_owner_id: String,
    pub new_owner_id: String,
    pub token_ids: Vec<String>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub memo: Option<String>,
}

'''
'''--- nft-contract/src/internal.rs ---
use crate::Contract;
use crate::*;
use std::mem::size_of;

// calculate how many bytes the account ID is taking up
pub(crate) fn bytes_for_account_id(account_id: &AccountId) -> u64 {
    // the extra 4 bytes are coming from Borsh serialization to store the lenth of the string
    account_id.as_str().len() as u64 + 4 + size_of::<u64>() as u64
}

// refund removed account storage and send the funds to the passed in account ID
pub(crate) fn refund_account_id(account_id: AccountId, removed_account_id: AccountId) -> Promise {
    let storage_released: u64 = bytes_for_account_id(&removed_account_id);
    Promise::new(account_id).transfer(Balance::from(storage_released) * env::storage_byte_cost())
}

// calculate hash
pub(crate) fn hash_account_id(account_id: &AccountId) -> CryptoHash {
    // get the default hash
    let mut hash = CryptoHash::default();
    // we hash the accountID and return it
    hash.copy_from_slice(&env::sha256(account_id.as_bytes()));
    hash
}
pub(crate) fn hash_level(level: &TokenLevel) -> CryptoHash {
    // get the default hash
    let mut hash = CryptoHash::default();
    // we hash the accountID and return it
    hash.copy_from_slice(&env::sha256(level.as_bytes()));
    hash
}

// refund the initial deposit based on the amount of storage that  was used up
pub(crate) fn refund_deposit(storage_used: u64) {
    // get how much it would cost to store the information
    let required_cost = env::storage_byte_cost() * Balance::from(storage_used);
    // get the attached deposit
    let attached_deposit = env::attached_deposit();
    // make sure that the attached deposit is greater than or equal to the required cost
    assert!(
        required_cost <= attached_deposit,
        "Must attach {} yoctoNEAR to cover storage",
        required_cost
    );
    // get the refund amount from the attached deposit - required cost
    let refund = attached_deposit - required_cost;
    // if the refund is greater than 1 yoctoNEAR, we refund the predecessor that amount
    if refund > 1 {
        Promise::new(env::predecessor_account_id()).transfer(refund);
    }
}
// used to make sure the user attached exactly 1 yoctoNEAR
pub(crate) fn assert_one_yocto() {
    assert_eq!(
        env::attached_deposit(),
        1,
        "Rqueries attached deposit of exactly 1 yoctoNEAR",
    )
}
// used to make sure the user attached exactly 1 yoctoNEAR
pub(crate) fn assert_at_least_one_yocto() {
    assert!(
        env::attached_deposit() >= 1,
        "Rqueries attached deposit of at least 1 yoctoNEAR",
    )
}
// assert that the user has attached at least 1 yoctoNEAR(for security reasons and to pay for storage)
pub(crate) fn assert_at_least_one_near() {
    assert!(
        env::attached_deposit() >= ONE_NEAR,
        "Requires attached deposit of at least 0.1 NEAR.",
    )
}

impl Contract {
    // add a token to the set of tokens an owner has
    pub(crate) fn internal_add_token_to_owner(
        &mut self,
        account_id: &AccountId,
        token_id: &TokenId,
    ) {
        // get the set of tokens for the given account
        let mut tokens_set = self.tokens_per_owner.get(account_id).unwrap_or_else(|| {
            // if the account doesn't have any tokens,we create a new unordered set
            UnorderedSet::new(
                StorageKey::TokenPerOwnerInner {
                    account_id_hash: hash_account_id(&account_id),
                }
                .try_to_vec()
                .unwrap(),
            )
        });

        // insert the token ID into the set
        tokens_set.insert(token_id);

        // insert that set for the given account ID
        self.tokens_per_owner.insert(account_id, &tokens_set);
    }

    pub(crate) fn internal_add_token_to_raffle(
        &mut self,
        token_level: &TokenLevel,
        token_id: &TokenId,
    ) {
        let mut raffle_token_level_set = self
            .raffle_tokens_per_level
            .get(token_level)
            .unwrap_or_else(|| {
                // if the level doesn't have any tokens, we create a new vector
                Vector::new(
                    StorageKey::RaffleTokensPerLevelInner {
                        level_hash: hash_level(token_level),
                    }
                    .try_to_vec()
                    .unwrap(),
                )
            });
        raffle_token_level_set.push(&token_id);
        self.raffle_tokens_per_level
            .insert(token_level, &raffle_token_level_set);
    }

    // remove a token from owner
    pub(crate) fn internal_remove_token_from_owner(
        &mut self,
        account_id: &AccountId,
        token_id: &TokenId,
    ) {
        // we get the set of tokens that the owner has
        let mut tokens_set = self
            .tokens_per_owner
            .get(&account_id)
            .expect("token should be owned by the sender.");
        //remove the token_id from the set of tokens
        tokens_set.remove(token_id);
        // if token set is now empty, we remove the owner from the tokens_per_owner collection
        if tokens_set.is_empty() {
            self.tokens_per_owner.remove(account_id);
        } else {
            self.tokens_per_owner.insert(account_id, &tokens_set);
        }
    }

    // remove a token from raffle
    pub(crate) fn internal_remove_token_from_raffle(
        &mut self,
        token_id: &TokenId,
        token_index: u64,
    ) {
        // get the token object by the passing token_id
        let token = self.tokens_by_id.get(&token_id).expect("No token");
        let token_level = token.level;
        let mut raffle_token_vector = self
            .raffle_tokens_per_level
            .get(&token_level)
            .expect("token should in the given level");
        assert_eq!(
            *token_id,
            raffle_token_vector.get(token_index).unwrap(),
            "token id to be removed is not equal to the given index value"
        );
        raffle_token_vector.swap_remove(token_index);
        self.raffle_tokens_per_level
            .insert(&token_level, &raffle_token_vector);
    }

    pub(crate) fn internal_raffle(
        &mut self,
        receiver_id: &AccountId,
        token_id: &TokenId,
        token_index: u64,
    ) -> Token {
        // get the token object by the passing token_id
        let token = self.tokens_by_id.get(&token_id).expect("No token");

        // make sure that the sender isn't sending the token to themselves
        assert_ne!(
            &(token.owner_id),
            receiver_id,
            "the token sender and the receiver should be different."
        );

        // remove the token from it's current owner's set
        self.internal_remove_token_from_owner(&token.owner_id, token_id);
        // add the token to the receiver
        self.internal_add_token_to_owner(receiver_id, token_id);
        // remove the token from raffle
        self.internal_remove_token_from_raffle(token_id, token_index);

        let new_token = Token {
            owner_id: receiver_id.clone(),
            level: token.clone().level,
        };
        self.tokens_by_id.insert(token_id, &new_token);
        // send near to the old ownder
        Promise::new(token.clone().owner_id).transfer(env::attached_deposit());

        // Construct the transfer log as per the events standard.
        let nft_transfer_log: EventLog = EventLog {
            // Standard name ("nep171").
            standard: NFT_STANDARD_NAME.to_string(),
            // Version of the standard ("nft-1.0.0").
            version: NFT_METADATA_SPEC.to_string(),
            // The data related with the event stored in a vector.
            event: EventLogVariant::NftTransfer(vec![NftTransferLog {
                // The optional authorized account ID to transfer the token on behalf of the old owner.
                authorized_id: Some(token.owner_id.to_string()),
                // The old owner's account ID.
                old_owner_id: token.owner_id.to_string(),
                // The account ID of the new owner of the token.
                new_owner_id: receiver_id.to_string(),
                // A vector containing the token IDs as strings.
                token_ids: vec![token_id.to_string()],
                // An optional memo to include.
                memo: None,
            }]),
        };

        // Log the serialized json.
        env::log_str(&nft_transfer_log.to_string());

        token
    }

    pub(crate) fn internal_transfer(
        &mut self,
        sender_id: &AccountId,
        receiver_id: &AccountId,
        token_id: &TokenId,
    ) {
        // get the token object by passing token_id
        let token = self.tokens_by_id.get(&token_id).expect("No token");
        assert_eq!(
            &token.owner_id, sender_id,
            "sender id must equal to the owner id"
        );

        // remove the token from it's current owner's set
        self.internal_remove_token_from_owner(&token.owner_id, token_id);
        // add the token to the receiver
        self.internal_add_token_to_owner(receiver_id, token_id);
        // if the token'owner is an administrator,and the receiver is not an administrator
        // remove the token from raffle collection
        if self.admins().contains(&token.owner_id) {
            if !self.admins().contains(receiver_id) {
                let tokens_set = self
                    .raffle_tokens_per_level
                    .get(&token.level)
                    .expect("No token.");
                let mut token_index = None;
                for i in 0..tokens_set.len() {
                    if tokens_set.get(i).unwrap() == *token_id {
                        token_index = Some(i)
                    } else {
                        continue;
                    }
                }
                // if token in the prize pool, remove from the the prize pool
                if let Some(index) = token_index {
                    self.internal_remove_token_from_raffle(token_id, index);
                }
            }
        } else {
            // if sender_id is not admin, but the receiver_id is admin
            // add the token to the raffle prize pool
            if self.admins().contains(receiver_id) {
                self.internal_add_token_to_raffle(&(token.level), token_id)
            }
        }

        let new_token = Token {
            owner_id: receiver_id.clone(),
            level: token.clone().level,
        };
        self.tokens_by_id.insert(token_id, &new_token);

        // Construct the transfer log as per the events standard.
        let nft_transfer_log: EventLog = EventLog {
            // Standard name ("nep171").
            standard: NFT_STANDARD_NAME.to_string(),
            // Version of the standard ("nft-1.0.0").
            version: NFT_METADATA_SPEC.to_string(),
            // The data related with the event stored in a vector.
            event: EventLogVariant::NftTransfer(vec![NftTransferLog {
                // The optional authorized account ID to transfer the token on behalf of the old owner.
                authorized_id: Some(token.owner_id.to_string()),
                // The old owner's account ID.
                old_owner_id: token.owner_id.to_string(),
                // The account ID of the new owner of the token.
                new_owner_id: receiver_id.to_string(),
                // A vector containing the token IDs as strings.
                token_ids: vec![token_id.to_string()],
                // An optional memo to include.
                memo: None,
            }]),
        };

        // Log the serialized json.
        env::log_str(&nft_transfer_log.to_string());
    }
}

'''
'''--- nft-contract/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LazyOption, LookupMap, UnorderedMap, UnorderedSet, Vector};
use near_sdk::json_types::{Base64VecU8, U128};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{env, near_bindgen, AccountId, Balance, CryptoHash, PanicOnDefault, Promise};

pub use admin::*;
pub use enumeration::*;
pub use events::*;
pub use internal::*;
pub use metadata::*;
pub use mint::*;
pub use nft_core::*;
pub use util::*;

mod admin;
mod enumeration;
mod events;
mod internal;
mod metadata;
mod mint;
mod nft_core;
mod util;

/// This spec can be treated like a version of the standard
pub const NFT_METADATA_SPEC: &str = "1.0.0";
/// This is the name of the NFT standard we're using
pub const NFT_STANDARD_NAME: &str = "nep171";

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    // contract owner
    pub owner_id: AccountId,

    // keeps track of all the raffle token ID for given token level
    pub raffle_tokens_per_level: LookupMap<TokenLevel, Vector<TokenId>>,

    // admins, who have the ablity to mint nfts
    pub admins: UnorderedSet<AccountId>,

    // keeps track of all the token IDs for a given account
    pub tokens_per_owner: LookupMap<AccountId, UnorderedSet<TokenId>>,

    //keeps track of the token struct for a given token ID
    pub tokens_by_id: LookupMap<TokenId, Token>,

    //keeps track of the token metadata for a given token ID
    pub token_metadata_by_id: UnorderedMap<TokenId, TokenMetadata>,

    // keeps track of the metadata for the contract
    pub metadata: LazyOption<NFTContractMetadata>,
}
#[derive(BorshSerialize)]
pub enum StorageKey {
    Admins,
    RaffleTokensPerLevel,
    RaffleTokensPerLevelInner { level_hash: CryptoHash },
    TokensPerOwner,
    TokenPerOwnerInner { account_id_hash: CryptoHash },
    TokensById,
    TokenMetadataById,
    NFTContractMetadata,

    TokensPerType,
    TokensPerTypeInner { token_type_hash: CryptoHash },
    TokenTypesLocked,
}

#[near_bindgen]
impl Contract {
    /*
        initialization function (can only be called once).
        this initializes the contract with default metadata so the
        user doesn't have to manually type metadata.
    */
    #[init]
    pub fn new_default_meta(owner_id: AccountId) -> Self {
        Self::new(
            owner_id,
            NFTContractMetadata {
                spec: "nft-1.0.0".to_string(),
                name: "Raffle gifts Contract".to_string(),
                symbol: "RaffleGifts".to_string(),
                icon: None,
                base_uri: None,
                reference: None,
                reference_hash: None,
            },
        )
    }

    /*
        initialization function (can only be called once).
        this initializes the contract with metadata that was passed in and
        the owner_id.
    */
    #[init]
    pub fn new(owner_id: AccountId, metadata: NFTContractMetadata) -> Self {
        let mut admins = UnorderedSet::new(StorageKey::Admins.try_to_vec().unwrap());
        // insert owner_id as an administrator
        admins.insert(&owner_id);
        Self {
            raffle_tokens_per_level: LookupMap::new(
                StorageKey::RaffleTokensPerLevel.try_to_vec().unwrap(),
            ),
            admins,
            tokens_per_owner: LookupMap::new(StorageKey::TokensPerOwner.try_to_vec().unwrap()),
            tokens_by_id: LookupMap::new(StorageKey::TokensById.try_to_vec().unwrap()),
            token_metadata_by_id: UnorderedMap::new(
                StorageKey::TokenMetadataById.try_to_vec().unwrap(),
            ),
            owner_id,
            metadata: LazyOption::new(
                StorageKey::NFTContractMetadata.try_to_vec().unwrap(),
                Some(&metadata),
            ),
        }
    }
}

#[cfg(test)]
mod tests {
    use std::vec;

    use near_sdk::{test_utils::VMContextBuilder, testing_env};

    use super::*;

    const TESTACCOUNTID: &str = "test.testnet";
    const NEAR: u128 = 1000000000000000000000000;

    #[test]
    fn initializes() {
        let metadata = NFTContractMetadata {
            spec: "nft-1.0.0".to_string(),
            name: "Raffle gifts Contract".to_string(),
            symbol: "RaffleGifts".to_string(),
            icon: None,
            base_uri: None,
            reference: None,
            reference_hash: None,
        };
        let contract = Contract::new(TESTACCOUNTID.parse().unwrap(), metadata);
        assert_eq!(contract.owner_id, TESTACCOUNTID.parse().unwrap());
    }

    #[test]
    fn nft() {
        let nft_metadata = NFTContractMetadata {
            spec: "nft-1.0.0".to_string(),
            name: "Raffle gifts Contract".to_string(),
            symbol: "RaffleGifts".to_string(),
            icon: None,
            base_uri: None,
            reference: None,
            reference_hash: None,
        };
        let mut contract = Contract::new(TESTACCOUNTID.parse().unwrap(), nft_metadata);
        set_context(TESTACCOUNTID, 1 * NEAR);
        let token_metadata1 = TokenMetadata {
            title: Some("default title1".to_string()),
            description: Some("an special NFT".to_string()),
            media: Some("".to_string()),
            media_hash: Some(Base64VecU8::from(vec![])),
            copies: Some(1),
            issued_at: Some(1),
            expires_at: Some(1),
            starts_at: Some(1),
            updated_at: Some(1),
            extra: Some("".to_string()),
            reference: Some("".to_string()),
            reference_hash: Some(Base64VecU8::from(vec![])),
        };

        //mint_nft
        contract.nft_mint(token_metadata1, "SSR".to_string());
        let token_set = contract
            .tokens_per_owner
            .get(&(TESTACCOUNTID.parse().unwrap()))
            .unwrap();
        // println!("{:?}", token_set);
        assert!(!token_set.is_empty(), "token_set should not be empty");
        assert_eq!(token_set.len(), 1);
        let ssr_raffle_set = contract
            .raffle_tokens_per_level
            .get(&("SSR".to_string()))
            .unwrap();
        assert_eq!(ssr_raffle_set.len(), 1);

        let sr_raffle_set = contract.raffle_tokens_per_level.get(&("SR".to_string()));
        assert!(sr_raffle_set.is_none());

        // test admin_add
        contract.admin_add(AccountId::try_from("li.testnet".to_string()).unwrap());
        assert_eq!(
            contract.admins(),
            vec![
                AccountId::try_from(TESTACCOUNTID.to_string()).unwrap(),
                AccountId::try_from("li.testnet".to_string()).unwrap(),
            ]
        );
        // test admin_remove
        contract.admin_remove(AccountId::try_from("li.testnet".to_string()).unwrap());
        assert_eq!(
            contract.admins(),
            vec![AccountId::try_from(TESTACCOUNTID.to_string()).unwrap(),]
        );

        // contract.admin_remove(AccountId::try_from(TESTACCOUNTID.to_string()).unwrap());
        let res = contract.is_admin(AccountId::try_from(TESTACCOUNTID.to_string()).unwrap());
        let res2 = contract.is_admin(AccountId::try_from("li.testnet".to_string()).unwrap());
        assert_eq!(res, 1);
        assert_eq!(res2, 0);
    }

    fn set_context(predecessor: &str, amount: Balance) {
        let mut builder = VMContextBuilder::new();
        builder.predecessor_account_id(predecessor.parse().unwrap());
        builder.attached_deposit(amount);
        testing_env!(builder.build());
    }
}

'''
'''--- nft-contract/src/metadata.rs ---
pub type TokenId = u64;
pub type TokenLevel = String;
use crate::*;

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct NFTContractMetadata {
    pub spec: String,         // required, essentially a version like "nft-1.0.0"
    pub name: String,         // required, ex. "Mosaics"
    pub symbol: String,       // required, ex. "MOSAIC"
    pub icon: Option<String>, // Data URL

    pub base_uri: Option<String>, // Centralized gateway known to have reliable access to decentralized storage
    // assets referenced by 'reference' or 'media' URLs
    pub reference: Option<String>, // URL to a JSON file with more info
    pub reference_hash: Option<Base64VecU8>, // Base64-encoded sha256 hash of Json from reference field.
                                             // Required if 'reference' is included.
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct TokenMetadata {
    pub title: Option<String>, // ex. "Arch Nemesis:Mail Carrier" or "Parcel #5505"
    pub description: Option<String>, // free-form description
    pub media: Option<String>, // URL to associated media, preferably to decentralized, cotent-addressed storage
    pub media_hash: Option<Base64VecU8>, // Base64-encoded sha256 hash of content referenced by the 'media' feild. Required if 'media' is included.
    pub copies: Option<u64>, // number of copies of this set of metadata in existence when token was minted.
    pub issued_at: Option<u64>, // When token was issued or minted, Unix epoch in milliseconds
    pub expires_at: Option<u64>, // When token expires, Unix epoch in milliseconds
    pub starts_at: Option<u64>, // When token starts being valid, Unix epoch in milliseconds
    pub updated_at: Option<u64>, // When token was last updated, Unix epoch in milliseconds
    pub extra: Option<String>, // anything extra the NFT wants to store on-chain, can be stringified Json
    pub reference: Option<String>, // URL to an off-chain JSON file with more info
    pub reference_hash: Option<Base64VecU8>, // Base64-encoded sha256 hash of JSON from reference field. Required if 'reference' is included.
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct Token {
    // owner of the token
    pub owner_id: AccountId,
    // level of the token
    pub level: TokenLevel,
}

//The Json token is what will be returned from view calls.
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct JsonToken {
    // token ID
    pub token_id: TokenId,
    // owner of the token
    pub owner_id: AccountId,
    // token metadata
    pub metadata: TokenMetadata,
    // token level
    pub level: TokenLevel,
}

// #[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone)]
// #[serde(crate = "near_sdk::serde")]
// pub enum TokenLevel {
//     N,
//     R,
//     SR,
//     SSR,
// }

pub trait NonFungibleTokenMetadata {
    //view call for returning the contract metadata
    fn nft_metadata(&self) -> NFTContractMetadata;
}

#[near_bindgen]
impl NonFungibleTokenMetadata for Contract {
    fn nft_metadata(&self) -> NFTContractMetadata {
        self.metadata.get().unwrap()
    }
}
// impl TryFrom<&str> for TokenLevel {
//     type Error = &'static str;

//     fn try_from(value: &str) -> Result<Self, Self::Error> {
//         match value {
//             "N" => Ok(TokenLevel::N),
//             "R" => Ok(TokenLevel::R),
//             "SR" => Ok(TokenLevel::SR),
//             "SSR" => Ok(TokenLevel::SSR),
//             _ => Err("wrong input token level, must be one of 'n','r','sr','ssr'"),
//         }
//     }
// }

'''
'''--- nft-contract/src/mint.rs ---
use crate::*;

#[near_bindgen]
impl Contract {
    #[payable]
    pub fn nft_mint(&mut self, metadata: TokenMetadata, token_level: String) {
        // make sure only administrator can mint nft
        let account_id = env::predecessor_account_id();
        assert!(
            self.admins.contains(&account_id),
            "Only administrator can mint NFT."
        );

        // measure the initial storage being used on the contract
        let initial_storage_usage = env::storage_usage();

        let token = Token {
            owner_id: account_id.clone(),
            level: token_level.clone(),
        };

        // insert the token ID and token struct and make sure that the token doesn't exist
        let token_id = env::block_height();
        assert!(
            self.tokens_by_id.insert(&token_id, &token).is_none(),
            "Token already exists."
        );

        // insert the token ID and metadata
        self.token_metadata_by_id.insert(&token_id, &metadata);

        // call the internal method for adding the token to the level
        self.internal_add_token_to_raffle(&token_level, &token_id);

        // call the internal method for adding the token to the owner
        self.internal_add_token_to_owner(&account_id, &token_id);

        // Construct the mint log as per the events standard.
        let nft_mint_log: EventLog = EventLog {
            // Standard name ("nep171").
            standard: NFT_STANDARD_NAME.to_string(),
            // Version of the standard ("nft-1.0.0").
            version: NFT_METADATA_SPEC.to_string(),
            // The data related with the event stored in a vector.
            event: EventLogVariant::NftMint(vec![NftMintLog {
                // Owner of the token.
                owner_id: token.owner_id.to_string(),
                // Vector of token IDs that were minted.
                token_ids: vec![token_id.to_string()],
                // An optional memo to include.
                memo: None,
            }]),
        };

        // Log the serialized json.
        env::log_str(&nft_mint_log.to_string());

        // calculate required_storage
        let required_storage_in_bytes = env::storage_usage() - initial_storage_usage;

        // refund any excess storage if the user attached too much.
        // Panic if they didn't attach enough to cover the required.
        refund_deposit(required_storage_in_bytes)
    }
}

'''
'''--- nft-contract/src/nft_core.rs ---
use crate::*;

pub trait NonFungibleTokenCore {
    //transfers an NFT to a receiver ID
    fn nft_raffle(&mut self);
    fn nft_transfer(&mut self, receiver_id: AccountId, token_id: TokenId);
    fn nft_token(&self, token_id: TokenId) -> Option<JsonToken>;
}

#[near_bindgen]
impl NonFungibleTokenCore for Contract {
    //implementation of the nft_transfer method. This transfers the NFT from the current owner to the receiver.
    #[payable]
    fn nft_raffle(&mut self) {
        assert_at_least_one_near();
        let raffle_id = env::predecessor_account_id();
        let attached_deposit = env::attached_deposit();
        let raffle_token_level = get_random_token_level_by_deposit(attached_deposit);
        let raffle_token_level_vector = self.raffle_tokens_per_level.get(&raffle_token_level);
        if let Some(raffle_token_level_vector) = raffle_token_level_vector {
            let raffle_token = get_random_token_id(&raffle_token_level_vector);
            if let Some(raffle_token) = raffle_token {
                // transfer
                self.internal_raffle(&raffle_id, &raffle_token.1, raffle_token.0);
            } else {
                Promise::new(raffle_id).transfer(attached_deposit);
            }
        } else {
            Promise::new(raffle_id).transfer(attached_deposit);
        }
    }

    #[payable]
    fn nft_transfer(&mut self, receiver_id: AccountId, token_id: TokenId) {
        assert_one_yocto();
        let sender_id = env::predecessor_account_id();
        self.internal_transfer(&sender_id, &receiver_id, &token_id)
    }

    //get the information for a specific token ID
    fn nft_token(&self, token_id: TokenId) -> Option<JsonToken> {
        if let Some(token) = self.tokens_by_id.get(&token_id) {
            let metadata = self.token_metadata_by_id.get(&token_id).unwrap();
            Some(JsonToken {
                token_id,
                owner_id: token.owner_id,
                metadata,
                level: token.level,
            })
        } else {
            None
        }
    }
}

'''
'''--- nft-contract/src/util.rs ---
use near_sdk::{collections::Vector, env, Balance};

use crate::{TokenId, TokenLevel};
pub const ONE_NEAR: Balance = 100_000_000_000_000_000_000_000u128;
pub const TWO_NEAR: Balance = 200_000_000_000_000_000_000_000u128;
pub const FIVE_NEAR: Balance = 500_000_000_000_000_000_000_000u128;
/// get a random number (u64)
pub fn get_random_number() -> u64 {
    let seed = env::random_seed();
    let mut arr: [u8; 8] = Default::default();
    arr.copy_from_slice(&seed[..8]);
    let seed_num = u64::from_le_bytes(arr);
    seed_num
}

pub fn get_random_token_id(raffle_vector: &Vector<u64>) -> Option<(u64, TokenId)> {
    let seed_num = get_random_number();
    let vec_len = raffle_vector.len();
    if vec_len > 0 {
        let index = seed_num % vec_len;
        let raffle_id = raffle_vector.get(index).unwrap();
        Some((index, raffle_id))
    } else {
        None
    }
}
// get the probabitlity for given attached deposit
pub fn get_probability_by_deposit(attached_deposit: Balance) -> (u64, u64, u64, u64) {
    if attached_deposit < ONE_NEAR {
        (0, 0, 0, 0)
    } else if attached_deposit >= ONE_NEAR && attached_deposit < TWO_NEAR {
        (40, 70, 95, 100)
    } else if attached_deposit >= TWO_NEAR && attached_deposit < FIVE_NEAR {
        (25, 60, 90, 100)
    } else {
        (10, 50, 85, 100)
    }
}
// get the probable token level according to the attached deposit
pub fn get_random_token_level_by_deposit(attached_deposit: Balance) -> TokenLevel {
    let probability = get_probability_by_deposit(attached_deposit);
    if probability.0 == 0 {
        panic!("attached deposit is to low.")
    }
    let seed_num = get_random_number();
    // let mut rng = rand::thread_rng();
    // let seed_num = rng.gen_range(0..128);

    // 0-99
    let raffle_num = seed_num % 100;
    if raffle_num < probability.0 {
        "N".to_string()
    } else if raffle_num >= probability.0 && raffle_num < probability.1 {
        "R".to_string()
    } else if raffle_num >= probability.1 && raffle_num < probability.2 {
        "SR".to_string()
    } else {
        "SSR".to_string()
    }
}

#[cfg(test)]
mod tests {
    use near_sdk::{
        collections::{LookupMap, Vector},
        env::log,
        Balance,
    };
    const ONE_NEAR: Balance = 100_000_000_000_000_000_000_000u128;
    const TWO_NEAR: Balance = 200_000_000_000_000_000_000_000u128;
    const FIVE_NEAR: Balance = 500_000_000_000_000_000_000_000u128;
    use crate::{get_random_number, get_random_token_id, get_random_token_level_by_deposit};

    #[test]
    pub fn test_get_random_number() {
        println!("{}", get_random_number())
    }

    #[test]
    pub fn test_vector() {
        let mut set: Vector<u64> = Vector::new(b"m");
        set.push(&10);
        set.push(&20);
        set.push(&33);
        set.push(&40);
        set.push(&50);
        // println!("init set: {:?}", set);
        // let len = set.len();
        // println!("len: {}", len);

        // let op = set.get(3);
        // println!("index 3 :{:?}", op);

        // let res = set.swap_remove(2);
        // println!("remove element: {}", res);
        // println!("after remove , set is: {:?}", set);
        // println!("index 2: {:?}", set.get(2));

        // let res = set.pop();
        // println!("pop element: {:?}", res);
        // println!("after pop , set is: {:?}", set);

        let id = get_random_token_id(&mut set);
        println!("random token: {:?}", id);
        println!("last element: ");
        for i in 0..5 {
            println!("index {}: {:?}", i, set.get(i))
        }
    }

    #[test]
    pub fn test_get_token_level_by_deposit() {
        let level1 = get_random_token_level_by_deposit(ONE_NEAR + 10);
        println!("{}", level1);
        let level2 = get_random_token_level_by_deposit(TWO_NEAR + 10);
        println!("{}", level2);
        let level5 = get_random_token_level_by_deposit(FIVE_NEAR + 10);
        println!("{}", level5);
    }

    #[test]
    pub fn test_swap_and_remove() {
        let mut raffle_collection: LookupMap<String, Vector<u32>> = LookupMap::new(b"r");

        let mut v = Vector::new(b"m");
        v.push(&32);
        raffle_collection.insert(&"SSR".into(), &v);
        let mut ele = raffle_collection.get(&"SSR".into()).unwrap();
        ele.swap_remove(0);

        raffle_collection.insert(&"SSR".into(), &ele);

        println!("{:?}", raffle_collection.get(&"SSR".into()).unwrap());
    }
}

'''
'''--- nft-contract/tests/integration-tests.rs ---
use near_sdk::__private::Metadata;
use near_sdk::json_types::Base64VecU8;
use near_units::parse_near;
use nft_contract::TokenMetadata;
use serde_json::json;
use workspaces::prelude::*;
use workspaces::{network::Sandbox, Account, Contract, Worker};
const WASM_FILEPATH: &str = "../res/main.wasm";
#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    let wasm = std::fs::read(WASM_FILEPATH)?;
    let contract = worker.dev_deploy(&wasm).await?;

    // create accounts
    let owner = worker.root_account()?;

    let jack = owner
        .create_subaccount(&worker, "jack")
        .initial_balance(parse_near!("30N"))
        .transact()
        .await?
        .into_result()?;

    let lucy = owner
        .create_subaccount(&worker, "lucy")
        .initial_balance(parse_near!("30N"))
        .transact()
        .await?
        .into_result()?;

    // Initialize contract
    contract
        .call(&worker, "new_default_meta")
        .args_json(json!({"owner_id": owner.id()}))?
        .transact()
        .await?;

    // begin tests
    // mint_nft
    test_mint_nft(&owner, &contract, &worker).await?;

    Ok(())
}

async fn test_mint_nft(
    owner: &Account,
    contract: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    owner
        .call(&worker, contract.id(), "nft_mint")
        .args_json(json!({
            "metadata":TokenMetadata{
                title: Some("default title1".to_string()),
                description: Some("an special NFT".to_string()),
                media: Some("".to_string()),
                media_hash: Some(Base64VecU8::from(vec![])),
                copies: Some(1),
                issued_at: Some(1),
                expires_at: Some(1),
                starts_at: Some(1),
                updated_at: Some(1),
                extra: Some("".to_string()),
                reference: Some("".to_string()),
                reference_hash: Some(Base64VecU8::from(vec![])),
            },
            "level": "SSR".to_string()
        }))?
        .transact()
        .await?;

    let balance = owner.view_account(&worker).await?.balance;
    println!("owner balance:{}", balance);

    Ok(())
}

'''
'''--- react-vite/index.html ---
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Raffle-Gifts</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>

'''
'''--- react-vite/package.json ---
{
    "name": "react-vite",
    "private": true,
    "version": "0.0.0",
    "type": "module",
    "scripts": {
        "dev": "vite",
        "build": "vite build",
        "preview": "vite preview"
    },
    "dependencies": {
        "@ant-design/icons": "^4.7.0",
        "@rollup/plugin-inject": "^4.0.4",
        "antd": "^4.22.8",
        "buffer": "^6.0.3",
        "dayjs": "^1.11.5",
        "near-api-js": "^1.0.0",
        "react": "^18.2.0",
        "react-dom": "^18.2.0",
        "web3.storage": "^4.4.0"
    },
    "devDependencies": {
        "@types/react": "^18.0.17",
        "@types/react-dom": "^18.0.6",
        "@vitejs/plugin-react": "^2.0.1",
        "unocss": "^0.45.13",
        "vite": "^3.0.7"
    }
}

'''
'''--- react-vite/public/vite.svg ---
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
'''
'''--- react-vite/src/assets/react.svg ---
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>
'''
'''--- react-vite/src/common/style/index.css ---
body {
  margin: 0;
}

'''
'''--- react-vite/src/config.js ---
import { keyStores } from 'near-api-js'
const CONTRACT_NAME = 'raffle.testnet'
export function getConfig() {
  return {
    networkId: 'testnet',
    nodeUrl: 'https://public-rpc.blockpi.io/http/near-testnet',
    contractName: CONTRACT_NAME,
    walletUrl: 'https://wallet.testnet.near.org',
    helperUrl: 'https://near-contract-helper.onrender.com',
    // deps: { keyStore: new keyStores.BrowserLocalStorageKeyStore() },
    keyStore: new keyStores.BrowserLocalStorageKeyStore(),
  }
}

'''
'''--- react-vite/src/near-api.js ---
import { connect, Contract, transactions, WalletConnection } from 'near-api-js'
import { getConfig } from './config'

const nearConfig = getConfig()
export const ONE_NEAR = '100000000000000000000000'
export const TWO_NEAR = '200000000000000000000000'
export const FIVE_NEAR = '500000000000000000000000'
// Initialize contract & set global variables
export async function initContract() {
  // Initialize connection to the NEAR testnet
  window.near = await connect(nearConfig)

  // Initializing Wallet based Accout. It can work with NEAR testnet wallet that
  // is hosted at https://wallet.testnet.near.org
  window.walletConnection = new WalletConnection(window.near)

  // Getting the Account ID. If still unauthorized, it's just empty string
  window.accountId = window.walletConnection.getAccountId()

  // Initializing our contract APIs by contract name and configuration
  window.contract = await new Contract(
    window.walletConnection.account(),
    nearConfig.contractName,
    {
      // View methods are read only. They don't modify the state, but usually return some value.
      viewMethods: [
        'is_admin',
        'admins',
        'nft_total_supply',
        'nft_token',
        'nft_tokens',
        'nft_supply_for_owner',
        'nft_tokens_for_owner',
        'nft_raffle_tokens_by_level',
        'nft_raffle_total_by_level',
      ],
      // Change methods can modify the state. But you don't receive the returned value when called.
      changeMethods: [
        'nft_mint',
        'nft_raffle',
        'nft_transfer',
        'admin_add',
        'admin_remove',
      ],
    }
  )
}
export function signOutNearWallet() {
  window.walletConnection.signOut()
  // reload page
  window.location.replace(window.location.origin + window.location.pathname)
}

export function signInWithNearWallet() {
  // Allow the current app to make calls to the specified contract on the
  // user's behalf.
  // This works by creating a new access key for the user's account and storing
  // the private key in localStorage.
  window.walletConnection.requestSignIn(nearConfig.contractName)
}
// get account balance
export async function getAccountBalance() {
  let amount = await window.walletConnection.account().getAccountBalance()
  return amount
}

// some action about admin
export async function isAdmin() {
  let response = await window.contract.is_admin({
    account_id: window.walletConnection.getAccountId(),
  })
  return response
}
export async function getAllAdmins() {
  let response = await window.contract.admins()
  return response
}
export async function addAdmin(accountId) {
  await window.contract.admin_add(
    {
      account_id: accountId,
    },
    '300000000000000', // attached GAS (optional)
    ONE_NEAR
  )
}
export async function removeAdmin(accountId) {
  await window.contract.admin_remove(
    {
      account_id: accountId,
    },
    '300000000000000', // attached GAS (optional)
    ONE_NEAR
  )
}

// get total NFTs supplied by the contract
export async function getTotalSupply() {
  let response = await window.contract.nft_total_supply()
  return response
}
export async function getNFTTokensFromContract(fromIndex, limit) {
  let response = await window.contract.nft_tokens({
    from_index: fromIndex,
    limit,
  })
  return response
}

export async function getNFTTokenByIdFromContract(tokenId) {
  let response = await window.contract.nft_token({
    token_id: tokenId,
  })
  return response
}
export async function getNFTTokenSupplyByOwner() {
  let response = await window.contract.nft_supply_for_owner({
    account_id: window.accountId,
  })
  return response
}
export async function getRaffleTokensTotalByLevel(level) {
  let response = await window.contract.nft_raffle_total_by_level({
    level,
  })
  return response
}

export async function getNFTTokenByLevelFromContract(
  fromIndex,
  limit,
  tokenLevel
) {
  let response = await window.contract.nft_raffle_tokens_by_level({
    from_index: fromIndex,
    limit,
    level: tokenLevel,
  })
  return response
}

export async function getNFTTokenByOwnerFromContract(
  accountId,
  fromIndex,
  limit
) {
  let response = await window.contract.nft_tokens_for_owner({
    account_id: accountId,
    from_index: fromIndex,
    limit,
  })
  return response
}

export async function raffleNFT(deposit) {
  await window.contract.nft_raffle(
    {},
    '300000000000000', // attached GAS (optional)
    deposit // attached deposit in yoctoNEAR (optional)
  )
}

export async function mintNft(metadata, tokenLevel) {
  await window.contract.nft_mint(
    {
      metadata,
      token_level: tokenLevel,
    },
    '300000000000000', // attached GAS (optional)
    ONE_NEAR // attached deposit in yoctoNEAR (optional)
  )
}

export async function transferNFT(tokenID, receiverID) {
  await window.contract.nft_transfer(
    {
      receiver_id: receiverID,
      token_id: tokenID,
    },
    '300000000000000', // attached GAS (optional)
    '1'
  )
}

'''
'''--- react-vite/src/util/utils.js ---
/**
 * Return an IPFS gateway URL for the given CID and path
 * @param {string} cid
 * @param {string} path
 * @returns {string}
 */
export function makeGatewayURL(cid, path) {
  return `https://${cid}.ipfs.dweb.link/${encodeURIComponent(path)}`
}

/**
 * Make a File object with the given filename, containing the given object (serialized to JSON).
 * @param {string} filename filename for the returned File object
 * @param {object} obj a JSON-serializable object
 * @returns {File}
 */
export function jsonFile(filename, obj) {
  return new File([JSON.stringify(obj)], filename)
}

/**
 * Get the Web3 storage token.
 *
 * @return {string}
 */
export function getSavedWebToken() {
  return localStorage.getItem('web3storage-token')
}

/**
 * saves token to local storage
 *
 * @export
 * @param {string} token
 */
export function saveWebToken(token) {
  localStorage.setItem('web3storage-token', token)
}
/**
 * Removes any saved token from local storage
 */
export function deleteSavedToken() {
  localStorage.removeItem('w3storage-token')
}

'''
'''--- react-vite/vite.config.js ---
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import inject from '@rollup/plugin-inject'
import Unocss from 'unocss/vite'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react(), Unocss({})],
  build: {
    rollupOptions: {
      plugins: [inject({ Buffer: ['buffer', 'Buffer'] })],
      output: {},
    },
    chunkSizeWarningLimit: 1000,
    // commonjsOptions: {
    //   include: [],
    // },
  },
  define: {
    'process.env': {},
  },
  //   optimizeDeps: {
  //     disabled: false,
  //   },
})

//inject({ Buffer: ['buffer', 'Buffer'] })

'''