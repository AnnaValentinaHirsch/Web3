*GitHub Repository "alenzer/Near_Poolbackend"*

'''--- constants.js ---
const crypto = require('crypto');

function encrypt3DES(data, key) {
 const md5Key = crypto.createHash('md5').update(key).digest("hex").substr(0, 24);
 const cipher = crypto.createCipheriv('des-ede3', md5Key, '');

 let encrypted = cipher.update(data, 'utf8', 'base64');
 encrypted += cipher.final('base64');
 return encrypted;
}

function decrypt3DES(data, key) {
 const md5Key = crypto.createHash('md5').update(key).digest("hex").substr(0, 24);
 const decipher = crypto.createDecipheriv('des-ede3', md5Key, '');

 let encrypted = decipher.update(data, 'base64', 'utf8');
 encrypted += decipher.final('utf8');
 return encrypted;
}

// const TERRA_SEED = decrypt3DES("wNGkDc9ZSAiWm4Y2L+Fog2xev8DC/hJLoiEWB7m01PGIYye/McmorgyAz1NiNiEZjRZXKY+Cd8Gut8pCIYMkZICPwohWzk0pwI9X/9xeR1j2Lh8y3ZmhP1o+/6huNG3LfDtECahzO0Ngnl2Xl2u2ugMYJgEIKYoZYZ7Yj16Pjhg8lnp5K+Ts/Pxj8Pyx3EMdQiHGRJa/X/fit+Sp58pJIA==", "Thisisaprettyquity");

const CONTRACT_NAME = 'staking1.alenzertest.testnet'; /* TODO: fill this in! */
function getConfig (env) {
  switch (env) {
    case 'production':
    case 'mainnet':
      return {
        networkId: 'mainnet',
        nodeUrl: 'https://rpc.mainnet.near.org',
        contractName: CONTRACT_NAME,
        walletUrl: 'https://wallet.near.org',
        helperUrl: 'https://helper.mainnet.near.org'
      }
    case 'development':
    case 'testnet':
      return {
        networkId: 'testnet',
        nodeUrl: 'https://rpc.testnet.near.org',
        contractName: CONTRACT_NAME,
        walletUrl: 'https://wallet.testnet.near.org',
        helperUrl: 'https://helper.testnet.near.org'
      }
    default:
      throw Error(`Unconfigured environment '${env}'. Can be configured in src/config.js.`)
  }
}

const StableCoins=[
  {
    name: 'USDC',
    id: 'usd-coin',
    description: 'USD Coin',
    avatar: 'Usdc.svg',
    apr: 23.97,
    decimals: 6,
    stable: true,
    upcoming: false
  },
  {
    name: 'USDT',
    id: 'tether',
    description: 'USD Tether',
    avatar: 'Usdt.svg',
    apr: 23.97,
    decimals: 6,
    stable: true,
    upcoming: false
  },
  {
    name: 'DAI',
    id: 'dai',
    description: 'Dai',
    avatar: 'Dai.svg',
    apr: 23.97,
    decimals: 18,
    stable: true,
    upcoming: false
  },
  {
    name: 'USN',
    id: 'usn',
    description: 'USD NEAR',
    avatar: 'Usn.svg',
    apr: 23.97,
    decimals: 18,
    stable: true,
    upcoming: false
  },
  {
    name: 'wBTC',
    id: 'wrapped-bitcoin',
    description: 'Wrapped Bitcoin',
    avatar: 'Wbtc.svg',
    apr: 9.15,
    decimals: 8,
    stable: false,
    upcoming: false
  },
  {
    name: 'ETH',
    id: 'ethereum',
    description: 'Ethereum',
    avatar: 'Eth.png',
    apr: 9.15,
    decimals: 18,
    stable: false,
    upcoming: false
  },
  {
    name: 'wNEAR',
    id: 'wrapped-near',
    description: 'Wrapped Near',
    avatar: 'Wnear.svg',
    apr: 14.61,
    decimals: 24,
    stable: false,
    upcoming: false
  },
  {
    name: 'NEARt',
    description: 'Near Treasury (Cooming Soon)',
    avatar: 'Neart.svg',
    apr: 0,
    decimals: 24,
    stable: false,
    upcoming: true
  }
];

const TOKEN_ADDRESSES_TESTNET = [
  "ft.alenzertest.testnet",
  "other.alenzertest.testnet",
  "other.alenzertest.testnet",
  "other.alenzertest.testnet",
  "other.alenzertest.testnet",
  "other.alenzertest.testnet",
  "wrap.testnet",
];
const TOKEN_ADDRESSES_MAINNET = [
  "ft.alenzertest.testnet",
  "ft.alenzertest.testnet",
  "ft.alenzertest.testnet",
  "ft.alenzertest.testnet",
  "ft.alenzertest.testnet",
  "ft.alenzertest.testnet",
  "ft.alenzertest.testnet",
];
const TOKEN_ADDRESS = TOKEN_ADDRESSES_TESTNET;

const getCoinId = (coin) => {
  // export type COINTYPE = 'USDC' | 'USDT' | 'DAI' | 'USN' | 'wBTC' | 'ETH' | 'wNEAR' | 'NEARt';
  switch (coin) {
    case 'USDC': return 0;
    case 'USDT': return 1;
    case 'DAI': return 2;
    case 'USN': return 3;
    case 'wBTC': return 4;
    case 'ETH': return 5;
    case 'wNEAR': return 6;
    case 'NEARt': return 7;
  }
  return 0;
}

module.exports = {
  CONTRACT_NAME,
  TOKEN_ADDRESS,
  StableCoins,
  getCoinId,
  getConfig,
  encrypt3DES,
  decrypt3DES
}

'''
'''--- index.js ---
const axios = require('axios');
const BigNumber = require('bignumber.js');

const CONTRACT_NAME = require("./constants").CONTRACT_NAME;
const StableCoins = require("./constants").StableCoins;
const getCoinId = require("./constants").getCoinId;
const getConfig = require("./constants").getConfig;

const encrypt3DES = require("./constants").encrypt3DES;
const decrypt3DES = require("./constants").decrypt3DES;

const port = process.env.PORT || 3001
const express = require("express");
const app = express();
const cors = require("cors");
const fs = require('fs');
const path = require("path");
const { keyStores, KeyPair, connect, Contract } = require("near-api-js");

let near;
var formidable = require('formidable');

app.use(express.json());
app.use(cors());

// const args = process.argv.slice(2)

// let encrypt = encrypt3DES(args[0], "Thisisaprettyquity");
// console.log(encrypt);

// let decrypt = decrypt3DES(encrypt, "Thisisaprettyquity");
// console.log(decrypt);

async function init() {
  const keyStore = new keyStores.InMemoryKeyStore();
  const PRIVATE_KEY =
    "2nYhYbV58SqjgpmD5QwCjg9EWFMS9P3JCap9U58Wn651cCPtxKxYHmSk6oSZh2SeYFohcyoe8zQBbGNvRNvdAQoz";
  const keyPair = KeyPair.fromString(PRIVATE_KEY);
  await keyStore.setKey("testnet", "staking_treasury.testnet", keyPair);

  // const nearConfig = getConfig("testnet");
  const config = {
    networkId: "testnet",
    keyStore,
    nodeUrl: "https://rpc.testnet.near.org",
    walletUrl: "https://wallet.testnet.near.org",
    helperUrl: "https://helper.testnet.near.org",
    explorerUrl: "https://explorer.testnet.near.org",
  };
  near = await connect(
    config
  );
  console.log(near)
}

async function getTVL(){
  let coins = StableCoins.filter((coin) => coin.upcoming == false);
  const price = ["1", "1", "1", "1", "1", "1", "1"];
  for (let i = 0; i < coins.length; i++) {
    let res
    try {
      res = await axios.get(
        `https://api.coingecko.com/api/v3/simple/price?ids=${coins[i].id}&vs_currencies=usd`
      );
    } catch (e) { }

    price[i] = Math.floor(res.data[`${coins[i].id}`]["usd"] * 100);
  }

  const account = await near.account("staking_treasury.testnet");
  const contract = new Contract(
    account, // the account object that is connecting
    CONTRACT_NAME,
    {
      viewMethods: ["get_amount_history"],
      changeMethods: ["rewards"],
    }
  );

  let totalUSD = new BigNumber(0);

  try {
    const amountHistory = await contract.get_amount_history();
    const index = amountHistory.length - 1;

    if (index >= 0) {
      for (let j = 0; j < coins.length; j++) {
        let usd = new BigNumber(amountHistory[index].amount[j] + amountHistory[index].reward[j]);

        usd = usd.multipliedBy(price[j]).dividedBy(10 ** coins[j].decimals);
        totalUSD = totalUSD.plus(usd);
      }
      totalUSD.dividedBy(100);
    }
  } catch (e) {
    console.log(e)
  }

  return totalUSD;
}
app.get("/treasury_tvl", async function (req, res) {
  const totalUSD = await getTVL();

  res.status(200).jsonp({
    TVL: totalUSD.toFixed()
  });
});

async function withdraw(sender, amount, coinType) {
  let coins = StableCoins.filter((coin) => coin.upcoming == false);
  const price = ["1", "1", "1", "1", "1", "1", "1"];
  for (let i = 0; i < coins.length; i++) {
    let res
    try {
      res = await axios.get(
        `https://api.coingecko.com/api/v3/simple/price?ids=${coins[i].id}&vs_currencies=usd`
      );
    } catch (e) { }

    price[i] = Math.floor(res.data[`${coins[i].id}`]["usd"] * 100);
  }

  const account = await near.account("staking_treasury.testnet");
  const tokenAddress = TOKEN_ADDRESS[getCoinId(coinType)];
  const contract = new Contract(
    account, // the account object that is connecting
    tokenAddress,
    {
      viewMethods: ["ft_balance_of"],
      changeMethods: ["ft_transfer_call"],
    }
  );

  let pool_msg = {
    account: sender,
    coin: coinType,
    price: price,
  };

  let token_msg = {
    receiver_id: CONTRACT_NAME,
    amount: amount,
    msg: JSON.stringify(pool_msg)
  }
  console.log(token_msg);
  try {
    await contract.ft_transfer_call(token_msg, 300000000000000, 1);
    return "success";
  }
  catch (e) {
    return "failed"
  }
}

app.post("/withdraw", async function (req, res) {
  var form = new formidable.IncomingForm();
  form.parse(req, async function (err, fields, files) {
    let count = 0;
    let result;
    do {
      result = await withdraw(fields.account, fields.amount, fields.coinType);
      console.log(result);
      await sleep(1000);
      count++;
    } while (result != 'success' && count < 10)

    if (result == 'success') {
      res.status(200).jsonp({
        data: "success"
      });
    } else {
      res.status(500).jsonp({
        data: result
      })
    }
  })
});

async function payReward() {
  const account = await near.account("staking_treasury.testnet");
  const contract = new Contract(
    account, // the account object that is connecting
    CONTRACT_NAME,
    {
      viewMethods: ["get_status"],
      changeMethods: ["rewards"],
    }
  );

  try {
    await contract.rewards();
    console.log("reward success")
    return "success";
  }
  catch (e) {
    console.log("reward failed");
    return "failed"
  }
}

async function farm() {
  let coins = StableCoins.filter((coin) => coin.upcoming == false);
  const price = [1, 1, 1, 1, 1, 1, 1];
  for (let i = 0; i < coins.length; i++) {
    let res
    try {
      res = await axios.get(
        `https://api.coingecko.com/api/v3/simple/price?ids=${coins[i].id}&vs_currencies=usd`
      );
    } catch (e) { }

    price[i] = Math.floor(res.data[`${coins[i].id}`]["usd"] * 100);
  }
  const account = await near.account("staking_treasury.testnet");
  const contract = new Contract(
    account, // the account object that is connecting
    CONTRACT_NAME,
    {
      viewMethods: ["get_status"],
      changeMethods: ["farm"],
    }
  );

  try {
    await contract.farm({ price: price });
    console.log("farm success");
    return "success";
  }
  catch (e) {
    console.log("farm failed");
    return "failed"
  }
}

const nodeCron = require("node-cron");
const { TOKEN_ADDRESS } = require('./constants');
var job = nodeCron.schedule('*/10 * * * *', async function () {//m h day month dayOfweek
  console.log("pay reward start")
  let res = 'success';
  let count = 0;
  do {
    res = await payReward();
    await sleep(6000);
    count++;
  } while (res != 'success' && count < 10)

  console.log("community farm start")
  res = 'success';
  count = 0;
  do {
    res = await farm();
    await sleep(6000);
    count++;
  } while (res != 'success' && count < 10)
}, { timezone: "UTC" });

async function potProcess() {
  const account = await near.account("staking_treasury.testnet");
  const contract = new Contract(
    account, // the account object that is connecting
    CONTRACT_NAME,
    {
      viewMethods: ["get_status"],
      changeMethods: ["pot_process"],
    }
  );

  try {
    await contract.pot_process();
    console.log("pot process success")
    return "success";
  }
  catch (e) {
    console.log("pot process failed");
    return "failed"
  }
}

var job2 = nodeCron.schedule('0 0 * * * *', async function () {//s m h day month dayOfweek
  console.log("Pot process start")
  let res = 'success';
  let count = 0;
  do {
    res = await potProcess();
    await sleep(6000);
    count++;
  } while (res != 'success' && count < 10)
}, { timezone: "UTC" });

init();
getTVL();
// setTimeout(() => potProcess(), 5000);

app.get('/', (req, res) => res.send("success v1"))

app.listen(port, () => console.log(`Server listening on port ${port}!`))

function sleep(ms) {
  return new Promise((resolve) => {
    setTimeout(resolve, ms);
  });
}

'''