*GitHub Repository "nearvndev/nft-marketplace-tutorial"*

'''--- market-contract/Cargo.toml ---
[package]
name = "market-contract"
version = "0.1.0"
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"

[profile.release]
codegen-units=1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true
'''
'''--- market-contract/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
mkdir -p ../out
cp target/wasm32-unknown-unknown/release/*.wasm ../out/market-contract.wasm
'''
'''--- market-contract/src/ft_callback.rs ---
use crate::*;
use near_sdk::promise_result_as_success;

//GAS constants to attach to calls
const GAS_FOR_ROYALTIES: Gas = 115_000_000_000_000;
const GAS_FOR_NFT_TRANSFER: Gas = 15_000_000_000_000;
const GAS_FOR_FT_TRANSFER: Gas = 15_000_000_000_000;
//constant used to attach 0 NEAR to a call
const NO_DEPOSIT: Balance = 0;

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct FTSaleArgs {
    pub nft_contract_id: AccountId,
    pub token_id: TokenId
}

pub trait FungibleTokenReceiver {
    fn ft_on_transfer(&mut self, sender_id: AccountId, amount: U128, msg: String) -> PromiseOrValue<U128>;
}

#[ext_contract(ext_ft_contract)]
pub trait FungibleTokenCore {
    fn ft_transfer(&mut self, receiver_id: AccountId, amount: U128, memo: Option<String>);
}

#[near_bindgen]
impl FungibleTokenReceiver for Contract {
    fn ft_on_transfer(&mut self, sender_id: AccountId, amount: U128, msg: String) -> PromiseOrValue<U128> {
        let ft_contract_id = env::predecessor_account_id();

        let FTSaleArgs { nft_contract_id, token_id } = near_sdk::serde_json::from_str(&msg).expect("Not valid FT Sale args");
        let contract_and_token_id: ContractAndTokenId = format!("{}{}{}", nft_contract_id, ".", token_id);
        let sale = self.sales.get(&contract_and_token_id).expect("Not found sale");

        let price = sale.sale_conditions;
        assert!(amount.0 >= price.amount.0, "Amount should be greater than NFT price");
        assert_ne!(sender_id, sale.owner_id, "Can not bid on your own sale");
        assert_eq!(ft_contract_id, price.contract_id, "Payout same token in sale");

        self.ft_process_purchase(
            nft_contract_id, 
            token_id, 
            price, 
            sender_id
        )
    }
}

#[near_bindgen]
impl Contract {
    pub(crate) fn ft_process_purchase(&mut self, nft_contract_id: AccountId, token_id: TokenId, price: SalePrice, buyer_id: AccountId) -> PromiseOrValue<U128> {
        let sale = self.internal_remove_sale(nft_contract_id.clone(), token_id.clone());

        ext_nft_contract::nft_transfer_payout(
            buyer_id.clone(), 
            token_id, 
            sale.approval_id, 
            "Payout from market contract".to_string(), 
            price.amount, 
            10, 
            &nft_contract_id, 
            1, 
            GAS_FOR_NFT_TRANSFER
        ).then(ext_self::ft_resolve_purchase(
            buyer_id, 
            price,
            &env::current_account_id(), 
            NO_DEPOSIT, 
            GAS_FOR_ROYALTIES
        )).into()
    }

    pub fn ft_resolve_purchase(&mut self, buyer_id: AccountId, price: SalePrice) -> U128 {
        let payout_option = promise_result_as_success().and_then(| value | {
            let payout_object: Payout = near_sdk::serde_json::from_slice::<Payout>(&value).expect("Invalid payout object");

            if payout_object.payout.len() > 10 || payout_object.payout.is_empty() {
                env::log("Cannot have more than 10 royalities".as_bytes());
                None
            } else {
                let mut remainder = price.amount.0;

                for &value in payout_object.payout.values() {
                    remainder = remainder.checked_sub(value.0)?;
                }

                if remainder == 0 || remainder == 1 {
                    Some(payout_object.payout)
                } else {
                    None
                }
            }
        });

        let payout = if let Some(payout_option) = payout_option {
            payout_option
        } else {
              ext_ft_contract::ft_transfer(
                buyer_id.clone(),
                price.amount,
                None,
                &price.contract_id,
                1,
                GAS_FOR_FT_TRANSFER
            );
            
            return U128(0);
        };

        for (reciver_id, amount) in payout {
            ext_ft_contract::ft_transfer(
                reciver_id.clone(),
                amount,
                None,
                &price.contract_id,
                1,
                GAS_FOR_FT_TRANSFER
            );
        }

        U128(0)
    }
}
'''
'''--- market-contract/src/internal.rs ---
use crate::*;

#[near_bindgen]
impl Contract {
    pub(crate) fn internal_remove_sale(&mut self, nft_contract_id: AccountId, token_id: TokenId) -> Sale {
        let contract_and_token_id = format!("{}{}{}", nft_contract_id, ".", token_id);

        let sale = self.sales.remove(&contract_and_token_id).expect("Not found sale");

        let mut by_owner_id = self.by_owner_id.get(&sale.owner_id).expect("Not found sale by owner_id");
        by_owner_id.remove(&contract_and_token_id);
    
        if by_owner_id.is_empty() {
            self.by_owner_id.remove(&sale.owner_id);
        } else {
            self.by_owner_id.insert(&sale.owner_id, &by_owner_id);
        }

        let mut by_contract_id = self.by_contract_id.get(&nft_contract_id).expect("Not found sale by contract_id");
        by_contract_id.remove(&token_id);
        if by_contract_id.is_empty() {
            self.by_contract_id.remove(&nft_contract_id);
        } else {
            self.by_contract_id.insert(&nft_contract_id, &by_contract_id);
        }

        sale
    }
}
'''
'''--- market-contract/src/lib.rs ---
use near_sdk::{AccountId, near_bindgen, PanicOnDefault, Balance, env, Promise, CryptoHash, ext_contract, Gas, PromiseOrValue};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::{U128, U64};
use near_sdk::serde::{Serialize, Deserialize};
use near_sdk::collections::{LookupMap, UnorderedSet, UnorderedMap};

pub use crate::sale_view::*;
pub use crate::utils::*;
pub use crate::nft_callback::*;
pub use crate::sale::*;
pub use crate::ft_callback::*;

const STORAGE_PER_SALE: u128 = 1000 * env::STORAGE_PRICE_PER_BYTE;

mod sale_view;
mod utils;
mod sale;
mod nft_callback;
mod internal;
mod ft_callback;

pub type TokenId = String;
pub type NFTContractId = String;
pub type ContractAndTokenId = String; //nft-tutorial.vbidev.testnet.VBI_NFT#01

#[derive(Deserialize, Serialize, BorshSerialize, BorshDeserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct SalePrice {
    is_native: bool,
    contract_id: AccountId,
    decimals: U64,
    amount: U128
}

#[derive(Deserialize, Serialize, BorshSerialize, BorshDeserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct SaleV1 {
    pub owner_id: AccountId,
    pub approval_id: u64,
    pub nft_contract_id: NFTContractId,
    pub token_id: TokenId,
    pub sale_conditions: U128
}

#[derive(Deserialize, Serialize, BorshSerialize, BorshDeserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Sale {
    pub owner_id: AccountId,
    pub approval_id: u64,
    pub nft_contract_id: NFTContractId,
    pub token_id: TokenId,
    pub sale_conditions: SalePrice
}

#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct ContractV1 {
    // Owner of contract
    pub owner_id: AccountId,

    // Sales của token
    pub sales: UnorderedMap<ContractAndTokenId, SaleV1>,

    // Danh sách sales theo account id
    pub by_owner_id: LookupMap<AccountId, UnorderedSet<ContractAndTokenId>>,

    // Danh sách token_id đang được đăng bán của 1 nft contract
    pub by_contract_id: LookupMap<NFTContractId, UnorderedSet<TokenId>>,

    // Danh sách account deposit để cover storage
    pub storage_deposit: LookupMap<AccountId, Balance>
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    // Owner of contract
    pub owner_id: AccountId,

    // Sales của token
    pub sales: UnorderedMap<ContractAndTokenId, Sale>,

    // Danh sách sales theo account id
    pub by_owner_id: LookupMap<AccountId, UnorderedSet<ContractAndTokenId>>,

    // Danh sách token_id đang được đăng bán của 1 nft contract
    pub by_contract_id: LookupMap<NFTContractId, UnorderedSet<TokenId>>,

    // Danh sách account deposit để cover storage
    pub storage_deposit: LookupMap<AccountId, Balance>
}

impl From<ContractV1> for Contract {
    fn from(contract: ContractV1) -> Self {
        // Remove all old sale type
        let sales = UnorderedMap::new(StorageKey::SaleKey.try_to_vec().unwrap());
        Self {
            owner_id: contract.owner_id,
            by_owner_id: contract.by_owner_id,
            by_contract_id: contract.by_contract_id,
            storage_deposit: contract.storage_deposit,
            sales
        }
    }
}

#[derive(BorshDeserialize, BorshSerialize)]
pub enum StorageKey {
    SaleKey,
    ByOwnerIdKey,
    InnterByOwnerIdKey {
        account_id_hash: CryptoHash
    },
    ByContractIdKey,
    InnerByContractIdKey {
        account_id_hash: CryptoHash
    },
    StorageDepositKey
}

#[near_bindgen]
impl Contract {

    #[init]
    pub fn new(owner_id: AccountId) -> Self {
        Self {
            owner_id,
            sales: UnorderedMap::new(StorageKey::SaleKey.try_to_vec().unwrap()),
            by_owner_id: LookupMap::new(StorageKey::ByOwnerIdKey.try_to_vec().unwrap()),
            by_contract_id: LookupMap::new(StorageKey::ByContractIdKey.try_to_vec().unwrap()),
            storage_deposit: LookupMap::new(StorageKey::StorageDepositKey.try_to_vec().unwrap())
        }
    }

    #[payable]
    pub fn storage_deposit(&mut self, account_id: Option<AccountId>) {
        let storage_account_id = account_id.unwrap_or(env::predecessor_account_id());
        let deposit = env::attached_deposit();

        assert!(deposit >= STORAGE_PER_SALE, "Requires deposit minimum of {}", STORAGE_PER_SALE);

        let mut balance = self.storage_deposit.get(&storage_account_id).unwrap_or(0);
        balance += deposit;

        self.storage_deposit.insert(&storage_account_id, &balance);
    }

    #[payable]
    pub fn storage_withdraw(&mut self) {
        assert_one_yocto();
        let owner_id = env::predecessor_account_id();

        let amount = self.storage_deposit.remove(&owner_id).unwrap_or(0);
        let sales = self.by_owner_id.get(&owner_id);
        
        let len = sales.map(| s | s.len()).unwrap_or_default();

        let storage_required = u128::from(len) * STORAGE_PER_SALE;

        assert!(amount >= storage_required);

        let diff = amount - storage_required;

        if diff > 0 {
            Promise::new(owner_id.clone()).transfer(diff);
        }

        if storage_required > 0 {
            self.storage_deposit.insert(&owner_id, &storage_required);
        }
    }

    pub fn storage_minimum_balance(&self) -> U128 {
        U128(STORAGE_PER_SALE)
    }

    pub fn storage_balance_of(&self, account_id: AccountId) -> U128 {
        U128(self.storage_deposit.get(&account_id).unwrap_or(0))
    }

    #[private]
    #[init(ignore_state)]
    pub fn migrate() -> Self {
        let old_data: ContractV1 = env::state_read().expect("Not read state");
        Self::from(old_data)
    }
}
'''
'''--- market-contract/src/nft_callback.rs ---
use crate::*;

pub trait NonFungibleTokenApprovalReceiver {
    fn nft_on_approve(&mut self, token_id: TokenId, owner_id: AccountId, approval_id: u64, msg: String);
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct SaleArgs {
    pub sale_conditions: SalePrice
}

#[near_bindgen]
impl NonFungibleTokenApprovalReceiver for Contract {
    fn nft_on_approve(&mut self, token_id: TokenId, owner_id: AccountId, approval_id: u64, msg: String) {
        // User => NFT contract => Market Contract
        // Signer account => Predecessor account => Current account

        let nft_contract_id = env::predecessor_account_id();
        let signer_id = env::signer_account_id();

        assert_ne!(nft_contract_id, signer_id, "nft_on_approve should only called via cross contract call");
        assert_eq!(signer_id, owner_id, "owner_id should be signer_id");

        // Check cover storage

        let storage_balance = self.storage_deposit.get(&signer_id).unwrap_or(0);
        let storage_minimum_amount = self.storage_minimum_balance().0;
        let storage_required = (self.get_supply_by_owner_id(signer_id.clone()).0 + 1) * storage_minimum_amount;

        assert!(storage_balance >= storage_required, "Storage balance not enough for cover storage staking");

        let SaleArgs { sale_conditions } = near_sdk::serde_json::from_str(&msg).expect("Not valid Sale Args");

        let contract_and_token_id = format!("{}{}{}", nft_contract_id.clone(), ".", token_id.clone());

        // Thêm sales collections
        self.sales.insert(&contract_and_token_id, &Sale {
            owner_id: owner_id.clone(),
            approval_id,
            nft_contract_id: nft_contract_id.clone(),
            token_id: token_id.clone(),
            sale_conditions
        });

        let mut by_owner_id = self.by_owner_id.get(&owner_id).unwrap_or_else(|| {
            UnorderedSet::new(
                StorageKey::InnterByOwnerIdKey {
                    account_id_hash: hash_account_id(&owner_id)
                }.try_to_vec().unwrap()
            )
        });

        by_owner_id.insert(&contract_and_token_id);
        self.by_owner_id.insert(&owner_id, &by_owner_id);

        let mut by_contract_id = self.by_contract_id.get(&nft_contract_id).unwrap_or_else(|| {
            UnorderedSet::new(
                StorageKey::InnerByContractIdKey {
                    account_id_hash: hash_account_id(&nft_contract_id)
                }.try_to_vec().unwrap()
            )
        });

        by_contract_id.insert(&token_id);
        self.by_contract_id.insert(&nft_contract_id, &by_contract_id);
    }
}
'''
'''--- market-contract/src/sale.rs ---
use crate::*;
use std::collections::HashMap;
use near_sdk::promise_result_as_success;

//GAS constants to attach to calls
const GAS_FOR_ROYALTIES: Gas = 115_000_000_000_000;
const GAS_FOR_NFT_TRANSFER: Gas = 15_000_000_000_000;

//constant used to attach 0 NEAR to a call
const NO_DEPOSIT: Balance = 0;

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Payout {
    pub payout: HashMap<AccountId, U128>,
} 

#[ext_contract(ext_nft_contract)]
pub trait NFTContract {
    fn nft_transfer_payout(
        &mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        approval_id: u64,
        memo: String,
        balance: U128,
        max_len_payout: u32,
    ) -> Payout;
}

#[ext_contract(ext_self)]
pub trait MarketContract {
    fn resolve_purchase(&mut self, buyer_id: AccountId, price: U128) -> Promise;
    fn ft_resolve_purchase(&mut self, buyer_id: AccountId, price: SalePrice) -> Promise;
}

#[near_bindgen]
impl Contract {

    #[payable]
    pub fn remove_sale(&mut self, nft_contract_id: AccountId, token_id: TokenId) {
        assert_one_yocto();

        // Xoá sale
        let sale = self.internal_remove_sale(nft_contract_id, token_id);
        
        assert_eq!(env::predecessor_account_id(), sale.owner_id, "Must be owner id");
    }

    #[payable]
    pub fn update_price(&mut self, nft_contract_id: AccountId, token_id: TokenId, price: SalePrice) {
        assert_one_yocto();

        let contract_and_token_id = format!("{}{}{}", nft_contract_id.clone(), ".", token_id.clone());

        let mut sale = self.sales.get(&contract_and_token_id).expect("Not found sale");
        assert_eq!(env::predecessor_account_id(), sale.owner_id, "Must be sale owner");
        sale.sale_conditions = price;

        self.sales.insert(&contract_and_token_id, &sale);
    }

    #[payable]
    pub fn offer(&mut self, nft_contract_id: AccountId, token_id: TokenId) {
        let deposit = env::attached_deposit();
        assert!(deposit > 0, "Attached deposit must be greater than 0");

        let contract_and_token_id = format!("{}{}{}", nft_contract_id.clone(), ".", token_id.clone());

        let sale = self.sales.get(&contract_and_token_id).expect("Not found sale");

        let buyer_id = env::predecessor_account_id();
        assert_ne!(buyer_id, sale.owner_id, "Can not bid on your own sale");

        let price = sale.sale_conditions.amount.0;
        assert!(deposit >= price, "Attached deposit must be greater than or equal current price: {}", price);

        // Check sale conditions
        assert!(sale.sale_conditions.is_native, "Only accept payout with NEAR");

        self.process_purchase(
            nft_contract_id,
            token_id,
            U128(deposit),
            buyer_id
        );
    }

    #[private]
    pub fn process_purchase(&mut self, nft_contract_id: AccountId, token_id: TokenId, price: U128, buyer_id: AccountId) -> Promise {
        let sale = self.internal_remove_sale(nft_contract_id.clone(), token_id.clone());

        // Cross contract call
        ext_nft_contract::nft_transfer_payout(
            buyer_id.clone(), 
            token_id, 
            sale.approval_id, 
            "Payout from market contract".to_string(), 
            price, 
            10, 
            &nft_contract_id, 
            1, 
            GAS_FOR_NFT_TRANSFER
        ).then(ext_self::resolve_purchase(
            buyer_id, 
            price, 
            &env::current_account_id(), 
            NO_DEPOSIT, 
            GAS_FOR_ROYALTIES
        ))
    }

    pub fn resolve_purchase(&mut self, buyer_id: AccountId, price: U128) -> U128 {
        let payout_option = promise_result_as_success().and_then(| value | {
            let payout_object: Payout = near_sdk::serde_json::from_slice::<Payout>(&value).expect("Invalid payout object");

            if payout_object.payout.len() > 10 || payout_object.payout.is_empty() {
                env::log("Cannot have more than 10 royalities".as_bytes());
                None
            } else {
                let mut remainder = price.0;

                for &value in payout_object.payout.values() {
                    remainder = remainder.checked_sub(value.0)?;
                }

                if remainder == 0 || remainder == 1 {
                    Some(payout_object.payout)
                } else {
                    None
                }
            }
        });

        let payout = if let Some(payout_option) = payout_option {
            payout_option
        } else {
            Promise::new(buyer_id).transfer(u128::from(price));
            return price;
        };

        for (reciver_id, amount) in payout {
            Promise::new(reciver_id).transfer(u128::from(amount));
        }
        price
    }
}
'''
'''--- market-contract/src/sale_view.rs ---
use crate::*;

#[near_bindgen]
impl Contract {
    // Lấy tổng số sale đang đăng bán trên market
    pub fn get_supply_sales(&self) -> U128 {
        U128(self.sales.len() as u128)
    }

    // Lấy tổng số sale đang đăng bán theo owner_id
    pub fn get_supply_by_owner_id(&self, account_id: AccountId) -> U128 {
        let sales_by_owner_id = self.by_owner_id.get(&account_id);
        if let Some(sales_by_owner_id) = sales_by_owner_id {
            U128(sales_by_owner_id.len() as u128)
        } else {
            U128(0)
        }
    }

    // Lấy tổng số sale đang đăng bán theo contract_id
    pub fn get_suppy_by_contract_id(&self, contract_id: NFTContractId) -> U128 {
        let tokens_by_contract_id = self.by_contract_id.get(&contract_id);
        if let Some(tokens_by_contract_id) = tokens_by_contract_id {
            U128(tokens_by_contract_id.len() as u128)
        } else {
            U128(0)
        }
    }

    pub fn get_sales(&self, from_index: Option<U128>, limit: Option<u64>) -> Vec<Sale> {
        let start = u128::from(from_index.unwrap_or(U128(0)));

         self.sales.values()
         .skip(start as usize)
         .take(limit.unwrap_or(0) as usize)
         .collect()
    }

    pub fn get_sales_by_owner_id(&self, account_id: AccountId, from_index: Option<U128>, limit: Option<u64>) -> Vec<Sale> {
        let by_owner_id = self.by_owner_id.get(&account_id);
        let contract_token_ids = if let Some(by_owner_id) = by_owner_id {
            by_owner_id
        } else {
            return vec![];
        };
        let start = u128::from(from_index.unwrap_or(U128(0)));

        contract_token_ids.as_vector()
        .iter()
        .skip(start as usize)
        .take(limit.unwrap_or(0) as usize)
        .map( | contract_token_id | self.sales.get(&contract_token_id).unwrap() )
        .collect()
    }

    pub fn get_sales_by_contract_id(&self, contract_id: NFTContractId, from_index: Option<U128>, limit: Option<u64>) -> Vec<Sale> {
        let tokens_by_contract_id = self.by_contract_id.get(&contract_id);

        let token_ids = if let Some(tokens_by_contract_id) = tokens_by_contract_id {
            tokens_by_contract_id
        } else {
            return vec![];
        };

        let start = u128::from(from_index.unwrap_or(U128(0)));
        token_ids.iter()
        .skip(start as usize)
        .take(limit.unwrap_or(0) as usize)
        .map(|token_id| self.sales.get(&format!("{}{}{}", contract_id, ".", token_id)).unwrap())
        .collect()
    }

}
'''
'''--- market-contract/src/utils.rs ---
use crate::*;
/// Assert that 1 yoctoNEAR was attached.
pub fn assert_one_yocto() {
    assert!(env::attached_deposit() == 1, "Requires attached deposit of exactly 1 yoctoNEAR")
}

pub(crate) fn hash_account_id(account_id: &AccountId) -> CryptoHash {
    //get the default hash
    let mut hash = CryptoHash::default();
    //we hash the account ID and return it
    hash.copy_from_slice(&env::sha256(account_id.as_bytes()));
    hash
}
'''
'''--- nft-contract/Cargo.toml ---
[package]
name = "nft-contract"
version = "0.1.0"
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"

[profile.release]
codegen-units=1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true
'''
'''--- nft-contract/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
mkdir -p ../out
cp target/wasm32-unknown-unknown/release/*.wasm ../out/nft-contract.wasm
'''
'''--- nft-contract/src/approval.rs ---
use crate::*;

const GAS_FOR_NFT_APPROVE: Gas = 10_000_000_000_000;
const NO_DEPOSIT: Balance = 0;

pub trait NonFungibleTokenApproval {
    fn nft_approve(&mut self, token_id: TokenId, account_id: AccountId, msg: Option<String>);
    fn nft_is_approved(&self, token_id: TokenId, approved_account_id: AccountId, approval_id: Option<u64>) -> bool;
    fn nft_revoke(&mut self, token_id: TokenId, account_id: AccountId);
    fn nft_revoke_all(&mut self, token_id: TokenId);
}

#[ext_contract(ext_non_fungible_token_approval_receiver)]
pub trait NonFungibleTokenApprovalReceiver {
    fn nft_on_approve(
        &mut self,
        token_id: TokenId,
        owner_id: AccountId,
        approval_id: u64,
        msg: String
    );
}

#[near_bindgen]
impl NonFungibleTokenApproval for Contract {

    #[payable]
    fn nft_approve(&mut self, token_id: TokenId, account_id: AccountId, msg: Option<String>) {
        assert_at_least_one_yocto();

        let mut token = self.tokens_by_id.get(&token_id).expect("Not found token");

        assert_eq!(&env::predecessor_account_id(), &token.owner_id, "Predecessor must be the token owner");

        let approval_id = token.next_approval_id;
        let is_new_approval = token.approved_account_ids.insert(account_id.clone(), approval_id).is_none();

        let storage_used = if is_new_approval {
            bytes_for_approved_account_id(&account_id)
        } else {
            0
        };

        token.next_approval_id += 1;
        self.tokens_by_id.insert(&token_id, &token);

        refund_deposit(storage_used);

        if let Some(msg) = msg {
            ext_non_fungible_token_approval_receiver::nft_on_approve(
                token_id, 
                token.owner_id, 
                approval_id, 
                msg, 
                &account_id, 
                NO_DEPOSIT, 
                env::prepaid_gas() - GAS_FOR_NFT_APPROVE,
            ).as_return();
        }
    }

    fn nft_is_approved(&self, token_id: TokenId, approved_account_id: AccountId, approval_id: Option<u64>) -> bool {
    
        let token = self.tokens_by_id.get(&token_id).expect("Token not found");
        let approval = token.approved_account_ids.get(&approved_account_id);

        if let Some(approval) = approval {
            if approval == &approval_id.unwrap() {
                true
            } else {
                false
            }
        } else {
            false
        }
    }

    #[payable]
    fn nft_revoke(&mut self, token_id: TokenId, account_id: AccountId) {
        assert_one_yocto();

        let mut token = self.tokens_by_id.get(&token_id).expect("Not found token");
        let sender_id = env::predecessor_account_id();
        assert_eq!(&sender_id, &token.owner_id);

        if token.approved_account_ids.remove(&account_id).is_some() {
            // refund 
            refund_approved_account_ids_iter(sender_id, [account_id].iter());
            self.tokens_by_id.insert(&token_id, &token);
        }
    }

    #[payable]
    fn nft_revoke_all(&mut self, token_id: TokenId) {
        assert_one_yocto();

        let mut token = self.tokens_by_id.get(&token_id).expect("Not found token");
        let sender_id = env::predecessor_account_id();
        assert_eq!(&sender_id, &token.owner_id);

        if !token.approved_account_ids.is_empty() {
            refund_approved_account_ids(sender_id, &token.approved_account_ids);
            token.approved_account_ids.clear();

            self.tokens_by_id.insert(&token_id, &token);
        }
    }
}
'''
'''--- nft-contract/src/enumeration.rs ---
use crate::*;

#[near_bindgen]
impl Contract {
    // Lấy tổng số token đang có trong contract
    pub fn nft_total_supply(&self) -> U128 {
        U128(self.token_metadata_by_id.len() as u128)
    }

    // Lấy tổng số token đang có của account_id
    pub fn nft_supply_for_owner(&self, account_id: AccountId) -> U128 {
        let tokens_for_owner_set = self.tokens_per_owner.get(&account_id);
        if let Some(tokens_for_owner_set) = tokens_for_owner_set {
            U128(tokens_for_owner_set.len() as u128)
        } else {
            U128(0)
        }
    }

    // Lấy danh sách token có paging
    pub fn nft_tokens(&self, from_index: Option<U128>, limit: Option<u64>) -> Vec<JsonToken> {
        let token_keys = self.token_metadata_by_id.keys_as_vector();

        let start = u128::from(from_index.unwrap_or(U128(0)));

        token_keys.iter()
        .skip(start as usize)
        .take(limit.unwrap_or(0) as usize)
        .map(|token_id| self.nft_token(token_id.clone()).unwrap() )
        .collect()
    }

    // Lấy danh sach token của account_id
    pub fn nft_tokens_for_owner(&self, account_id: AccountId, from_index: Option<U128>, limit: Option<u64>) -> Vec<JsonToken> {
        let token_keys = self.tokens_per_owner.get(&account_id);

        let keys = if let Some(token_keys) = token_keys {
            token_keys
        } else {
            return vec![];
        };

        let start = u128::from(from_index.unwrap_or(U128(0)));

        keys.as_vector()
        .iter()
        .skip(start as usize)
        .take(limit.unwrap_or(0) as usize)
        .map(|token_id| self.nft_token(token_id.clone()).unwrap() )
        .collect()
    }
}
'''
'''--- nft-contract/src/event.rs ---
use std::fmt;

use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::serde_json;

/// Enum that represents the data type of the EventLog.
/// The enum can either be an NftMint or an NftTransfer.
#[derive(Serialize, Deserialize, Debug)]
#[serde(tag = "event", content = "data")]
#[serde(rename_all = "snake_case")]
#[serde(crate = "near_sdk::serde")]
#[non_exhaustive]
pub enum EventLogVariant {
    NftMint(Vec<NftMintLog>),
    NftTransfer(Vec<NftTransferLog>),
}

/// Interface to capture data about an event
///
/// Arguments:
/// * `standard`: name of standard e.g. nep171
/// * `version`: e.g. 1.0.0
/// * `event`: associate event data
#[derive(Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct EventLog {
    pub standard: String,
    pub version: String,

    // `flatten` to not have "event": {<EventLogVariant>} in the JSON, just have the contents of {<EventLogVariant>}.
    #[serde(flatten)]
    pub event: EventLogVariant,
}

impl fmt::Display for EventLog {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_fmt(format_args!(
            "EVENT_JSON:{}",
            &serde_json::to_string(self).map_err(|_| fmt::Error)?
        ))
    }
}

/// An event log to capture token minting
///
/// Arguments
/// * `owner_id`: "account.near"
/// * `token_ids`: ["1", "abc"]
/// * `memo`: optional message
#[derive(Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct NftMintLog {
    pub owner_id: String,
    pub token_ids: Vec<String>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub memo: Option<String>,
}

/// An event log to capture token transfer
///
/// Arguments
/// * `authorized_id`: approved account to transfer
/// * `old_owner_id`: "owner.near"
/// * `new_owner_id`: "receiver.near"
/// * `token_ids`: ["1", "12345abc"]
/// * `memo`: optional message
#[derive(Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct NftTransferLog {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub authorized_id: Option<String>,

    pub old_owner_id: String,
    pub new_owner_id: String,
    pub token_ids: Vec<String>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub memo: Option<String>,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn nep_format_vector() {
        let expected = r#"EVENT_JSON:{"standard":"nep171","version":"1.0.0","event":"nft_mint","data":[{"owner_id":"foundation.near","token_ids":["aurora","proximitylabs"]},{"owner_id":"user1.near","token_ids":["meme"]}]}"#;
        let log = EventLog {
            standard: "nep171".to_string(),
            version: "1.0.0".to_string(),
            event: EventLogVariant::NftMint(vec![
                NftMintLog {
                    owner_id: "foundation.near".to_owned(),
                    token_ids: vec!["aurora".to_string(), "proximitylabs".to_string()],
                    memo: None,
                },
                NftMintLog {
                    owner_id: "user1.near".to_owned(),
                    token_ids: vec!["meme".to_string()],
                    memo: None,
                },
            ]),
        };
        assert_eq!(expected, log.to_string());
    }

    #[test]
    fn nep_format_mint() {
        let expected = r#"EVENT_JSON:{"standard":"nep171","version":"1.0.0","event":"nft_mint","data":[{"owner_id":"foundation.near","token_ids":["aurora","proximitylabs"]}]}"#;
        let log = EventLog {
            standard: "nep171".to_string(),
            version: "1.0.0".to_string(),
            event: EventLogVariant::NftMint(vec![NftMintLog {
                owner_id: "foundation.near".to_owned(),
                token_ids: vec!["aurora".to_string(), "proximitylabs".to_string()],
                memo: None,
            }]),
        };
        assert_eq!(expected, log.to_string());
    }

    #[test]
    fn nep_format_transfer_all_fields() {
        let expected = r#"EVENT_JSON:{"standard":"nep171","version":"1.0.0","event":"nft_transfer","data":[{"authorized_id":"market.near","old_owner_id":"user1.near","new_owner_id":"user2.near","token_ids":["token"],"memo":"Go Team!"}]}"#;
        let log = EventLog {
            standard: "nep171".to_string(),
            version: "1.0.0".to_string(),
            event: EventLogVariant::NftTransfer(vec![NftTransferLog {
                authorized_id: Some("market.near".to_string()),
                old_owner_id: "user1.near".to_string(),
                new_owner_id: "user2.near".to_string(),
                token_ids: vec!["token".to_string()],
                memo: Some("Go Team!".to_owned()),
            }]),
        };
        assert_eq!(expected, log.to_string());
    }
} 
'''
'''--- nft-contract/src/internal.rs ---
use std::collections::HashMap;

use crate::*;

#[near_bindgen]
impl Contract {
    pub(crate) fn internal_add_token_to_owner(&mut self, token_id: &TokenId, account_id: &AccountId) {

        // Nếu account_id đã có ds token rồi, thì sẽ lấy ds token đang có
        // Nếu account_id chưa có trong tokens_per_owner thì tạo mới tokens_Set
        let mut tokens_set = self.tokens_per_owner.get(account_id).unwrap_or_else(|| {
            UnorderedSet::new(StorageKey::TokenPerOwnerInnerKey {
                account_id_hash: hash_account_id(account_id)
            }.try_to_vec().unwrap())
        });

        tokens_set.insert(token_id);

        self.tokens_per_owner.insert(account_id, &tokens_set);
    }

    pub(crate) fn internal_remove_token_from_owner(&mut self, token_id: &TokenId, account_id: &AccountId) {
        let mut tokens_set = self.tokens_per_owner.get(account_id).expect("Token should be owned by sender");

        tokens_set.remove(token_id);
        if tokens_set.is_empty() {
            self.tokens_per_owner.remove(account_id);
        } else {
            self.tokens_per_owner.insert(account_id, &tokens_set);
        }
    }

    // return lại data token cũ trước khi thực hiện transfer
    /**
     * - Kiểm tra token_id có tồn tại không?
     * - sender_id có phải là owner của token không?
     * - sender_id và receiver_id trùng nhau không?
     * - Xoá token khỏi owner cũ
     * - Thêm token cho receiver_id
     */
    pub(crate) fn internal_transfer(
        &mut self, 
        sender_id: &AccountId, 
        receiver_id: &AccountId, 
        token_id: &TokenId, 
        approval_id: Option<u64>,
        memo: Option<String>) -> Token {
            let token = self.tokens_by_id.get(token_id).expect("Not found token");
            // check owner
            if sender_id != &token.owner_id {
                if !token.approved_account_ids.contains_key(sender_id) {
                    env::panic("Sender must be the token owner".as_bytes());
                }

                if let Some(enforced_approval_id) = approval_id {
                    let actual_approval_id = token.approved_account_ids.get(sender_id).expect("Sender is not approved account");

                    assert_eq!(
                        actual_approval_id, &enforced_approval_id,
                        "The actual approval id {} is different from the given approval id {}",
                        actual_approval_id, enforced_approval_id
                    )
                }
            };

            assert_ne!(&token.owner_id, receiver_id, "The token owner and the receiver should be different");

            self.internal_remove_token_from_owner(&token_id, &token.owner_id);
            self.internal_add_token_to_owner(&token_id, receiver_id);

            let new_token = Token {
                owner_id: receiver_id.clone(),
                approved_account_ids: HashMap::default(),
                next_approval_id: token.next_approval_id,
                royalty: token.royalty.clone()
            };

            self.tokens_by_id.insert(token_id,&new_token);

            if let Some(memo) = memo.as_ref() {
                log!("Memo {}", memo);
            };

            // NFT TRANSFER LOG
            let mut authorized_id = None;
            if approval_id.is_some() {
                authorized_id = Some(sender_id.to_string());
            }

            let nft_transfer_log: EventLog = EventLog {
                standard: "nep171".to_string(),
                version: "1.0.0".to_string(),
                event: EventLogVariant::NftTransfer(vec![ NftTransferLog {
                    authorized_id,
                    old_owner_id: token.owner_id.to_string(),
                    new_owner_id: receiver_id.to_string(),
                    token_ids: vec![token_id.to_string()],
                    memo
                } ])
            };

            env::log(&nft_transfer_log.to_string().as_bytes());

            token
    }
}
'''
'''--- nft-contract/src/lib.rs ---
use near_sdk::collections::{LazyOption, UnorderedSet, UnorderedMap};
use near_sdk::{near_bindgen, CryptoHash, Balance, env, Promise, ext_contract, log, Gas, PromiseResult, PromiseOrValue, PanicOnDefault};
use near_sdk::{AccountId, collections::LookupMap};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::json_types::{Base64VecU8, U128};
use std::collections::HashMap;

pub type TokenId = String;

use crate::utils::*;
pub use crate::metadata::*;
pub use crate::mint::*;
pub use crate::enumeration::*;
pub use crate::nft_core::*;
pub use crate::approval::*;
pub use crate::event::*;
pub use crate::royalty::*;

mod metadata;
mod mint;
mod internal;
mod utils;
mod enumeration;
mod nft_core;
mod approval;
mod event;
mod royalty;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
struct Contract {
    pub owner_id: AccountId,

    pub tokens_per_owner: LookupMap<AccountId, UnorderedSet<TokenId>>, // Lưu danh sách token mà user sở hữu

    pub tokens_by_id: LookupMap<TokenId, Token>, // Mapping token id với các data mở rộng của token

    pub token_metadata_by_id: UnorderedMap<TokenId, TokenMetadata>, // Mapping token id với token metadata

    pub metadata: LazyOption<NFTContractMetadata>
}

#[derive(BorshDeserialize, BorshSerialize)]
pub enum StorageKey {
    TokenPerOwnerKey,
    ContractMetadataKey,
    TokenByIdKey,
    TokenMetadataByIdKey,
    TokenPerOwnerInnerKey {
        account_id_hash: CryptoHash
    }
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new(owner_id: AccountId, token_metadata: NFTContractMetadata) -> Self {
        Self {
            owner_id,
            metadata: LazyOption::new(
                StorageKey::ContractMetadataKey.try_to_vec().unwrap(),
                Some(&token_metadata)
            ),
            tokens_per_owner: LookupMap::new(StorageKey::TokenPerOwnerKey.try_to_vec().unwrap()),
            tokens_by_id: LookupMap::new(StorageKey::TokenByIdKey.try_to_vec().unwrap()),
            token_metadata_by_id: UnorderedMap::new(StorageKey::TokenMetadataByIdKey.try_to_vec().unwrap())
        }
    }

    #[init]
    pub fn new_default_metadata(owner_id: AccountId) -> Self {
        Self::new(
            owner_id, 
        NFTContractMetadata {
            spec: "nft-tutorial-1.0.0".to_string(),
            name: "VBI NFT Tutorial".to_string(),
            symbol: "VNFT".to_string(),
            icon: None,
            base_uri: None,
            reference: None,
            reference_hash: None
        })
    }
}

#[cfg(all(test, not(target_arch = "wasm32")))]
mod tests {
    use super::*;

    use near_sdk::test_utils::{VMContextBuilder, accounts};
    use near_sdk::{testing_env};
    use near_sdk::MockedBlockchain;

    const MINT_STORAGE_COST: u128 = 58700000000000000000000;

    fn get_context(is_view: bool) -> VMContextBuilder {
        let mut builder = VMContextBuilder::new();
        builder.
        current_account_id(accounts(0))
        .signer_account_id(accounts(0))
        .predecessor_account_id(accounts(0))
        .is_view(is_view);

        builder
    }

    fn get_sample_metadata() -> TokenMetadata {
        TokenMetadata { 
            title: Some("TOKEN_TEST".to_owned()), 
            description: Some("Description".to_owned()), 
            media: None, 
            media_hash: None, 
            copies: None, 
            issued_at: None, 
            expires_at: None, 
            starts_at: None, 
            updated_at: None, 
            extra: None, 
            reference: None, 
            reference_hash: None
         }
    }

    #[test]
    fn test_mint_token() {
        let mut context = get_context(false);
        testing_env!(context.build());
        
        // Init contract
        let mut contract = Contract::new_default_metadata(accounts(0).to_string());

        testing_env!(
            context.storage_usage(env::storage_usage())
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build()
        );

        let token_id = "VBI_NFT".to_string();
        contract.nft_mint(token_id.clone(), get_sample_metadata(), accounts(0).to_string());

        let token = contract.nft_token(token_id.clone()).unwrap();

        assert_eq!(accounts(0).to_string(), token.owner_id);
        assert_eq!(token_id.clone(), token.token_id);
        assert_eq!(token.metadata, get_sample_metadata());
    }

    #[test]
    fn test_transfer_nft() {
        let mut context = get_context(false);
        testing_env!(context.build());
        let mut contract = Contract::new_default_metadata(accounts(0).to_string());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build()
        );
        let token_id = "vbi_nft".to_owned();
        contract.nft_mint(token_id.clone(), get_sample_metadata(), accounts(0).to_string());

        let token = contract.nft_token(token_id.clone()).unwrap();
        assert_eq!(token.owner_id, accounts(0).to_string());
        assert_eq!(token.token_id, token_id);
        assert_eq!(get_sample_metadata(), token.metadata);

        testing_env!(context.attached_deposit(1).build());

        contract.nft_transfer(accounts(1).to_string(), token_id.clone(), 0,None);
        
        let new_token = contract.nft_token(token_id.clone()).unwrap();
        assert_eq!(new_token.owner_id, accounts(1).to_string());
        assert_eq!(new_token.token_id, token_id);
        assert_eq!(get_sample_metadata(), new_token.metadata);
    }
}
'''
'''--- nft-contract/src/metadata.rs ---
use crate::*;
use std::collections::HashMap;

#[derive(BorshDeserialize, BorshSerialize)]
pub struct Token {
    pub owner_id: AccountId,
    pub approved_account_ids: HashMap<AccountId, u64>,
    pub next_approval_id: u64,
    pub royalty: HashMap<AccountId, u32>
}

#[derive(Serialize, Deserialize, BorshDeserialize, BorshSerialize)]
#[serde(crate = "near_sdk::serde")]
pub struct JsonToken {
    pub owner_id: AccountId,
    pub token_id: TokenId,
    pub metadata: TokenMetadata,
    pub approved_account_ids: HashMap<AccountId, u64>,
    pub royalty: HashMap<AccountId, u32>
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct NFTContractMetadata {
    pub spec: String,              // required, essentially a version like "nft-1.0.0"
    pub name: String,              // required, ex. "Mosaics"
    pub symbol: String,            // required, ex. "MOSIAC"
    pub icon: Option<String>,      // Data URL
    pub base_uri: Option<String>, // Centralized gateway known to have reliable access to decentralized storage assets referenced by `reference` or `media` URLs
    pub reference: Option<String>, // URL to a JSON file with more info
    pub reference_hash: Option<Base64VecU8>, // Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included.
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, PartialEq, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct TokenMetadata {
    pub title: Option<String>, // ex. "Arch Nemesis: Mail Carrier" or "Parcel #5055"
    pub description: Option<String>, // free-form description
    pub media: Option<String>, // URL to associated media, preferably to decentralized, content-addressed storage
    pub media_hash: Option<Base64VecU8>, // Base64-encoded sha256 hash of content referenced by the `media` field. Required if `media` is included.
    pub copies: Option<u64>, // number of copies of this set of metadata in existence when token was minted.
    pub issued_at: Option<u64>, // When token was issued or minted, Unix epoch in milliseconds
    pub expires_at: Option<u64>, // When token expires, Unix epoch in milliseconds
    pub starts_at: Option<u64>, // When token starts being valid, Unix epoch in milliseconds
    pub updated_at: Option<u64>, // When token was last updated, Unix epoch in milliseconds
    pub extra: Option<String>, // anything extra the NFT wants to store on-chain. Can be stringified JSON.
    pub reference: Option<String>, // URL to an off-chain JSON file with more info.
    pub reference_hash: Option<Base64VecU8>, // Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included.
}

pub trait NonFungibleTokenMetadata {
    fn nft_metadata(&self) -> NFTContractMetadata;
}

#[near_bindgen]
impl NonFungibleTokenMetadata for Contract {
    fn nft_metadata(&self) -> NFTContractMetadata {
        self.metadata.get().unwrap()
    }
}
'''
'''--- nft-contract/src/mint.rs ---
use std::collections::HashMap;

use near_sdk::env;

use crate::*;

#[near_bindgen]
impl Contract {
    /**
     * - Yêu cầu user nạp tiền để cover phí lưu trữ
     * - Thêm token vào token_by_id
     * - Thêm token metadata
     * - Thêm token vào ds sở hữu bởi owner
     * - Refund lại NEAR user deposit thừa
     */
    #[payable]
    pub fn nft_mint(&mut self, token_id: TokenId, metadata: TokenMetadata, receiver_id: AccountId, perpetual_royalties: Option<HashMap<AccountId, u32>>) {
        let before_storage_usage = env::storage_usage();

        let mut royalty = HashMap::new();

        // if perpetual royalties were passed into the function: 
        if let Some(perpetual_royalties) = perpetual_royalties {
            //make sure that the length of the perpetual royalties is below 7 since we won't have enough GAS to pay out that many people
            assert!(perpetual_royalties.len() < 7, "Cannot add more than 6 perpetual royalty amounts");

            //iterate through the perpetual royalties and insert the account and amount in the royalty map
            for (account, amount) in perpetual_royalties {
                royalty.insert(account, amount);
            }
        }

        let token = Token {
            owner_id: receiver_id,
            approved_account_ids: HashMap::default(),
            next_approval_id: 0,
            royalty
        };

        assert!(
            self.tokens_by_id.insert(&token_id, &token).is_none(),
            "Token already exsits"
        );

        self.token_metadata_by_id.insert(&token_id, &metadata);

        // set token per owner
        self.internal_add_token_to_owner(&token_id, &token.owner_id);

        // NFT MINT LOG
        let nft_mint_log: EventLog = EventLog {
            standard: "nep171".to_string(),
            version: "1.0.0".to_string(),
            event: EventLogVariant::NftMint(vec![ NftMintLog {
                owner_id: token.owner_id.to_string(),
                token_ids: vec![token_id.to_string()],
                memo: None
            } ])
        };
        env::log(&nft_mint_log.to_string().as_bytes());

        let after_storage_usage = env::storage_usage();
        // Refund near
        refund_deposit(after_storage_usage - before_storage_usage);
    }

    pub fn nft_token(&self, token_id: TokenId) -> Option<JsonToken> {
        let token = self.tokens_by_id.get(&token_id);

        if let Some(token) = token {
            let metadata = self.token_metadata_by_id.get(&token_id).unwrap();

            Some(JsonToken {
                owner_id: token.owner_id,
                token_id,
                metadata,
                approved_account_ids: token.approved_account_ids,
                royalty: token.royalty
            })
        } else {
            None
        }
    }
}
'''
'''--- nft-contract/src/nft_core.rs ---
use crate::*;

const GAS_FOR_RESOLVE_TRANSFER: Gas = 10_000_000_000_000;
const GAS_FOR_NFT_TRANSFER_CALL: Gas = 25_000_000_000_000 + GAS_FOR_RESOLVE_TRANSFER;
const NO_DEPOSIT: Balance = 0;

pub trait NonFungibleTokenCore {
    fn nft_transfer(&mut self, receiver_id: AccountId, token_id: TokenId, approval_id: u64, memo: Option<String>);

    // return true nếu transfer NFT được thực hiện thành công
    fn nft_transfer_call(&mut self, receiver_id: AccountId, token_id: TokenId, approval_id: u64, memo: Option<String>, msg: String) -> PromiseOrValue<bool>;
}

#[ext_contract(ext_non_fungible_token_receiver)]
trait NonFungibleTokenReceiver {
    // Method lưu trên Contract B, A thực cross contract call nft_on_transfer
    // return true nếu như NFT cần được rollback lại cho owner cũ
    fn nft_on_transfer(&mut self, sender_id: AccountId, previous_owner_id: AccountId, token_id: TokenId, msg: String) -> Promise;
}

#[ext_contract(ext_self)]
trait NonFungibleTokenResolver {
    // Nếu contract B yêu cầu rollback lại cho owner cũ => A sẽ rollback lại data trong nft_resolve_transfer
    fn nft_resolve_transfer(
        &mut self, 
        authorized_id: Option<AccountId>,
        owner_id: AccountId, 
        receiver_id: AccountId, 
        token_id: TokenId, 
        approved_account_ids: HashMap<AccountId, u64>,
        memo: Option<String>
    ) -> bool;
}

trait NonFungibleTokenResolver {
    fn nft_resolve_transfer(
        &mut self, 
        authorized_id: Option<AccountId>,
        owner_id: AccountId, 
        receiver_id: AccountId, 
        token_id: TokenId, 
        approved_account_ids: HashMap<AccountId, u64>,
        memo: Option<String>
    ) -> bool;
}
#[near_bindgen]
impl NonFungibleTokenCore for Contract {
    // Yêu cầu deposit 1 yoctoNear để bảo mật cho user
    #[payable]
    fn nft_transfer(&mut self, receiver_id: AccountId, token_id: TokenId, approval_id: u64, memo: Option<String>) {
        assert_one_yocto();
        let sender_id = env::predecessor_account_id();

        let previous_token = self.internal_transfer(
            &sender_id,
            &receiver_id,
            &token_id,
            Some(approval_id),
            memo
        );

        refund_approved_account_ids(sender_id, &previous_token.approved_account_ids);
    }

    #[payable]
    fn nft_transfer_call(&mut self, receiver_id: AccountId , token_id: TokenId, approval_id: u64, memo: Option<String>, msg: String) -> PromiseOrValue<bool> {
        assert_one_yocto();
        let sender_id = env::predecessor_account_id();

        let previous_token = self.internal_transfer(
            &sender_id,
            &receiver_id,
            &token_id,
            Some(approval_id),
            memo.clone()
        );

        let mut authorized_id = None;
        if sender_id != previous_token.owner_id {
            authorized_id = Some(sender_id.to_string());
        }

        ext_non_fungible_token_receiver::nft_on_transfer(
            sender_id.clone(), 
            previous_token.owner_id.clone(), 
            token_id.clone(), 
            msg, 
            &receiver_id, 
            NO_DEPOSIT, 
            env::prepaid_gas() - GAS_FOR_NFT_TRANSFER_CALL
        ).then(ext_self::nft_resolve_transfer(
            authorized_id,
            previous_token.owner_id, 
            receiver_id, 
            token_id, 
            previous_token.approved_account_ids,
            memo,
            &env::current_account_id(), 
            NO_DEPOSIT, 
        GAS_FOR_RESOLVE_TRANSFER
        )).into()
    }
}

#[near_bindgen]
impl NonFungibleTokenResolver for Contract {
    fn nft_resolve_transfer(
        &mut self,
        authorized_id: Option<AccountId>,
         owner_id: AccountId, 
         receiver_id: AccountId, 
         token_id: TokenId, 
         approved_account_ids: HashMap<AccountId, u64>, 
         memo: Option<String>
        ) -> bool {
        if let PromiseResult::Successful(value) = env::promise_result(0) {
            if let Ok(is_rollback_token) = near_sdk::serde_json::from_slice::<bool>(&value) {
                return !is_rollback_token;
            }
        }

        let mut token = if let Some(token) = self.tokens_by_id.get(&token_id) {
            if token.owner_id != receiver_id {

                refund_approved_account_ids(owner_id, &approved_account_ids);
                return true;
            }
            token
        } else {
            refund_approved_account_ids(owner_id, &approved_account_ids);
            return true;
        };

        log!("Rollback {} from @{} to @{}", token_id, receiver_id, owner_id);
    
        self.internal_remove_token_from_owner(&token_id, &receiver_id);
        self.internal_add_token_to_owner(&token_id, &owner_id);

        token.owner_id = owner_id.clone();

        refund_approved_account_ids(receiver_id.clone(), &token.approved_account_ids);
        token.approved_account_ids = approved_account_ids;

        self.tokens_by_id.insert(&token_id, &token);

        // NFT TRANSFER LOG
        let nft_transfer_log = EventLog {
            standard: "nep171".to_string(),
            version: "1.0.0".to_string(),
            event: EventLogVariant::NftTransfer(vec![ NftTransferLog {
                authorized_id,
                old_owner_id: receiver_id.to_string(),
                new_owner_id: owner_id.to_string(),
                token_ids: vec![token_id.to_string()],
                memo
            } ])
        };

        env::log(&nft_transfer_log.to_string().as_bytes());

        false
    }
}
'''
'''--- nft-contract/src/royalty.rs ---
use crate::*;

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Payout {
    pub payout: HashMap<AccountId, U128>,
} 
pub trait NonFungibleTokenCore {
    fn nft_payout(&self, token_id: String, balance: U128, max_len_payout: u32) -> Payout;
    
    fn nft_transfer_payout(
        &mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        approval_id: u64,
        memo: String,
        balance: U128,
        max_len_payout: u32,
    ) -> Payout;
}

#[near_bindgen]
impl NonFungibleTokenCore for Contract {

    fn nft_payout(&self, token_id: String, balance: U128, max_len_payout: u32) -> Payout {
		let token = self.tokens_by_id.get(&token_id).expect("Not found token");

        let owner_id = token.owner_id;
        let mut total_perpetual = 0;
        let balance_u128 = u128::from(balance);
        let mut payout_object = Payout {
            payout: HashMap::new()
        };
		let royalty = token.royalty;
		assert!(royalty.len() as u32 <= max_len_payout, "Market cannot payout to that many receivers");

		for (k, v) in royalty.iter() {
			let key = k.clone();

			if key != owner_id {
                //
				payout_object.payout.insert(key, royalty_to_payout(*v, balance_u128));
				total_perpetual += *v;
			}
		}

		payout_object.payout.insert(owner_id, royalty_to_payout(10000 - total_perpetual, balance_u128));

		payout_object
	}

    #[payable]
    fn nft_transfer_payout(
        &mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        approval_id: u64,
        memo: String,
        balance: U128,
        max_len_payout: u32,
    ) -> Payout { 
        assert_one_yocto();

        let sender_id = env::predecessor_account_id();
        let previous_token = self.internal_transfer(
            &sender_id,
            &receiver_id,
            &token_id,
            Some(approval_id),
            Some(memo),
        );
        refund_approved_account_ids(
            previous_token.owner_id.clone(),
            &previous_token.approved_account_ids,
        );
        let owner_id = previous_token.owner_id;
        let mut total_perpetual = 0;
        let balance_u128 = u128::from(balance);
        let mut payout_object = Payout {
            payout: HashMap::new()
        };

		let royalty = previous_token.royalty;
		assert!(royalty.len() as u32 <= max_len_payout, "Market cannot payout to that many receivers");

		for (k, v) in royalty.iter() {
            //get the key
			let key = k.clone();
			if key != owner_id {
                //
				payout_object.payout.insert(key, royalty_to_payout(*v, balance_u128));
				total_perpetual += *v;
			}
		}
		payout_object.payout.insert(owner_id, royalty_to_payout(10000 - total_perpetual, balance_u128));

		payout_object
    }
}
'''
'''--- nft-contract/src/utils.rs ---
use std::{mem::size_of, collections::HashMap};

use crate::*;

pub(crate) fn hash_account_id(account_id: &AccountId) -> CryptoHash {
    //get the default hash
    let mut hash = CryptoHash::default();
    //we hash the account ID and return it
    hash.copy_from_slice(&env::sha256(account_id.as_bytes()));
    hash
}

pub(crate) fn refund_deposit(storage_used: u64) {
    // Tính lượng tiền cần nạp để cover storage
    let required_cost = env::storage_byte_cost() * Balance::from(storage_used);
    let attached_deposit = env::attached_deposit();

    assert!(
        required_cost <= attached_deposit,
        "Must attach {} yoctoNear to cover storage", required_cost
    );

    let refund = attached_deposit - required_cost;

    if refund > 1 {
        Promise::new(env::predecessor_account_id()).transfer(refund);
    }
}

pub(crate) fn assert_one_yocto() {
    assert_eq!(env::attached_deposit(), 1,
    "Require attached deposit of exactly 1 yoctoNear")
}

pub(crate) fn assert_at_least_one_yocto() {
    assert!(env::attached_deposit() >= 1,
    "Require attached deposit of at least 1 yoctoNear")
}

pub(crate) fn bytes_for_approved_account_id(account_id: &AccountId) -> u64 {
    account_id.as_str().len() as u64 + 4 + size_of::<u64>() as u64
}

pub(crate) fn refund_approved_account_ids_iter<'a, I>(sender_id: AccountId, approved_account_ids: I)
    where 
        I: Iterator<Item = &'a AccountId>,
{
    let storage_released: u64 = approved_account_ids.map(bytes_for_approved_account_id).sum();

    Promise::new(sender_id).transfer(Balance::from(storage_released) * env::storage_byte_cost());
}

pub(crate) fn refund_approved_account_ids(sender_id: AccountId, approved_account_ids: &HashMap<AccountId, u64>) {
    refund_approved_account_ids_iter(sender_id, approved_account_ids.keys());
}

pub(crate) fn royalty_to_payout(royalty_percentage: u32, amount_to_pay: Balance) -> U128 {
    U128(royalty_percentage as u128 * amount_to_pay / 10_000u128)
}
'''
'''--- package.json ---
{
  "name": "nft-marketplace-tutorial",
  "version": "1.0.0",
  "main": "index.js",
  "license": "MIT",
  "scripts": {
    "build": "cd nft-contract && ./build.sh && cd ../.."
  }
}

'''