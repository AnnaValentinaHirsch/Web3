*GitHub Repository "AhaLabs/witme"*

'''--- crates/gen-ts-near/.eslintrc.js ---
module.exports = {
    "env": {
        "browser": true,
        "es2021": true,
        "node": true
    },
    "extends": "eslint:recommended",
    "parserOptions": {
        "ecmaVersion": 12,
        "sourceType": "module"
    },
    "rules": {
      // allow this since we generate `const {} = e;` for empty structs
      "no-empty-pattern": 0,
      // TODO: we generate some unused functions by accident, let's fix that later
      "no-unused-vars": 0,
    }
};

'''
'''--- examples/rust-status-message-advanced/dist/helper.js ---
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BN = exports.DEFAULT_FUNCTION_CALL_GAS = exports.providers = exports.transactions = exports.Account = void 0;
//@ts-ignore
var near_api_js_1 = require("near-api-js");
Object.defineProperty(exports, "Account", { enumerable: true, get: function () { return near_api_js_1.Account; } });
Object.defineProperty(exports, "transactions", { enumerable: true, get: function () { return near_api_js_1.transactions; } });
Object.defineProperty(exports, "providers", { enumerable: true, get: function () { return near_api_js_1.providers; } });
Object.defineProperty(exports, "DEFAULT_FUNCTION_CALL_GAS", { enumerable: true, get: function () { return near_api_js_1.DEFAULT_FUNCTION_CALL_GAS; } });
//@ts-ignore
var bn_js_1 = __importDefault(require("bn.js"));
exports.BN = bn_js_1.default;

'''
'''--- examples/rust-status-message-advanced/dist/index.js ---
"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Contract = void 0;
var helper_1 = require("./helper"); /**
* StorageUsage is used to count the amount of storage used by a contract.
*/
var Contract = /** @class */ (function () {
    function Contract(account, contractId) {
        this.account = account;
        this.contractId = contractId;
    }
    /**
    * Retreive a message for a given account id
    */
    Contract.prototype.get_status = function (args, options) {
        return this.account.viewFunction(this.contractId, "get_status", args, options);
    };
    /**
    * Store a message for current signer account
    */
    Contract.prototype.set_status = function (args, options) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _b = (_a = helper_1.providers).getTransactionLastResult;
                        return [4 /*yield*/, this.set_statusRaw(args, options)];
                    case 1: return [2 /*return*/, _b.apply(_a, [_c.sent()])];
                }
            });
        });
    };
    /**
    * Store a message for current signer account
    */
    Contract.prototype.set_statusRaw = function (args, options) {
        return this.account.functionCall(__assign({ contractId: this.contractId, methodName: "set_status", args: args }, options));
    };
    /**
    * Store a message for current signer account
    */
    Contract.prototype.set_statusTx = function (args, options) {
        var _a, _b;
        return helper_1.transactions.functionCall("set_status", args, (_a = options === null || options === void 0 ? void 0 : options.gas) !== null && _a !== void 0 ? _a : helper_1.DEFAULT_FUNCTION_CALL_GAS, (_b = options === null || options === void 0 ? void 0 : options.attachedDeposit) !== null && _b !== void 0 ? _b : new helper_1.BN(0));
    };
    return Contract;
}());
exports.Contract = Contract;

'''
'''--- examples/rust-status-message/dist/helper.js ---
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BN = exports.DEFAULT_FUNCTION_CALL_GAS = exports.providers = exports.transactions = exports.Account = void 0;
//@ts-ignore
var near_api_js_1 = require("near-api-js");
Object.defineProperty(exports, "Account", { enumerable: true, get: function () { return near_api_js_1.Account; } });
Object.defineProperty(exports, "transactions", { enumerable: true, get: function () { return near_api_js_1.transactions; } });
Object.defineProperty(exports, "providers", { enumerable: true, get: function () { return near_api_js_1.providers; } });
Object.defineProperty(exports, "DEFAULT_FUNCTION_CALL_GAS", { enumerable: true, get: function () { return near_api_js_1.DEFAULT_FUNCTION_CALL_GAS; } });
//@ts-ignore
var bn_js_1 = __importDefault(require("bn.js"));
exports.BN = bn_js_1.default;

'''
'''--- examples/rust-status-message/dist/index.js ---
"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Contract = void 0;
var helper_1 = require("./helper"); /**
* StorageUsage is used to count the amount of storage used by a contract.
*/
var Contract = /** @class */ (function () {
    function Contract(account, contractId) {
        this.account = account;
        this.contractId = contractId;
    }
    /**
    * Retreive a message for a given account id
    */
    Contract.prototype.get_status = function (args, options) {
        return this.account.viewFunction(this.contractId, "get_status", args, options);
    };
    /**
    * Store a message for current signer account
    */
    Contract.prototype.set_status = function (args, options) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _b = (_a = helper_1.providers).getTransactionLastResult;
                        return [4 /*yield*/, this.set_statusRaw(args, options)];
                    case 1: return [2 /*return*/, _b.apply(_a, [_c.sent()])];
                }
            });
        });
    };
    /**
    * Store a message for current signer account
    */
    Contract.prototype.set_statusRaw = function (args, options) {
        return this.account.functionCall(__assign({ contractId: this.contractId, methodName: "set_status", args: args }, options));
    };
    /**
    * Store a message for current signer account
    */
    Contract.prototype.set_statusTx = function (args, options) {
        var _a, _b;
        return helper_1.transactions.functionCall("set_status", args, (_a = options === null || options === void 0 ? void 0 : options.gas) !== null && _a !== void 0 ? _a : helper_1.DEFAULT_FUNCTION_CALL_GAS, (_b = options === null || options === void 0 ? void 0 : options.attachedDeposit) !== null && _b !== void 0 ? _b : new helper_1.BN(0));
    };
    return Contract;
}());
exports.Contract = Contract;

'''
'''--- npm/dist/getBinary.js ---
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBinary = exports.AWSUrl = void 0;
const _1 = require(".");
const path_1 = require("path");
const os = require("os");
const { version } = require("../package.json");
function getPlatform() {
    const type = os.type();
    const arch = os.arch();
    let typeDict = {
        "Darwin": "apple-darwin",
        "Linux": "unknown-linux-gnu",
        "Windows_NT": "pc-windows-msvc"
    };
    let archDict = {
        "x64": "x86_64",
        "arm64": "aarch64"
    };
    //@ts-ignore 
    let rust_type = typeDict[type];
    //@ts-ignore 
    let rust_arch = archDict[arch];
    if (rust_type && rust_arch) {
        return [rust_type, rust_arch];
    }
    throw new Error(`Unsupported platform: ${type} ${arch}`);
}
function AWSUrl() {
    const [platform, arch] = getPlatform();
    return `https://github.com/AhaLabs/witme/releases/download/v${version}/witme-v${version}-${arch}-${platform}.tar.gz`;
}
exports.AWSUrl = AWSUrl;
function getBinary(name = "witme") {
    if (!process.env["WITME_BIN_PATH"]) {
        process.env["WITME_BINARY_PATH"] = (0, path_1.join)(os.homedir(), ".witme", "witme");
    }
    // Will use version after publishing to AWS
    // const version = require("./package.json").version;
    const fromEnv = process.env["WITME_ARTIFACT_URL"];
    const urls = [AWSUrl()];
    if (fromEnv) {
        urls.unshift(fromEnv);
    }
    return _1.Binary.create(name, urls);
}
exports.getBinary = getBinary;

'''
'''--- npm/dist/index.js ---
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Binary = void 0;
const fs = require("fs/promises");
const url_1 = require("url");
const path_1 = require("path");
const tar = require("tar");
const got_1 = require("got");
const utils_1 = require("./utils");
const child_process_1 = require("child_process");
const stream = require("stream");
const util_1 = require("util");
const pipeline = (0, util_1.promisify)(stream.pipeline);
class Binary {
    constructor(name, url, installDir = Binary.DEFAULT_INSTALL_DIR) {
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: name
        });
        Object.defineProperty(this, "installDir", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: installDir
        });
        Object.defineProperty(this, "urls", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        let errors = [];
        let urls = [];
        if (typeof url === "string" || url instanceof url_1.URL) {
            urls.push(url);
        }
        else {
            if (url.length == 0) {
                throw new Error("No URL provided got empty array");
            }
            urls = url;
        }
        if (!name || typeof name !== "string") {
            errors.push("You must specify the name of your binary as a string");
        }
        try {
            this.urls = urls.map((path) => typeof path === "string" ? new url_1.URL(path) : path);
        }
        catch (e) {
            errors.push(e);
        }
        if (errors.length > 0) {
            errors.push('\nCorrect usage: new Binary("my-binary", "https://example.com/binary/download.tar.gz"');
            errors.unshift("One or more of the parameters you passed to the Binary constructor are invalid:\n");
            throw new Error(errors.join("\n"));
        }
    }
    /**
     *
     * @param name binary name, e.g. 'git'
     * @param path URL of where to find binary
     * @param destination Directory to put the binary
     * @returns
     */
    static async create(name, path, destination) {
        const bin = new Binary(name, path, destination !== null && destination !== void 0 ? destination : (await (0, utils_1.searchPath)(name)));
        if (destination === bin.installDir) {
            await fs.mkdir(bin.installDir, { recursive: true });
        }
        return bin;
    }
    get binPath() {
        return (0, path_1.join)(this.installDir, this.name);
    }
    download(url) {
        return pipeline(got_1.default.stream(url), new stream.PassThrough(), tar.x({ strip: 1, C: this.installDir }));
    }
    async install() {
        for (let url of this.urls) {
            try {
                await this.download(url);
                return true;
            }
            catch (error) { }
        }
        throw new Error(`Failed to download from: \n${this.urls.join("\n")}`);
    }
    async exists() {
        return await (0, utils_1.fileExists)(this.binPath);
    }
    async run(cliArgs, options = { stdio: [null, utils_1.inherit, utils_1.inherit] }) {
        if (!(await this.exists())) {
            try {
                await this.install();
            }
            catch (err) {
                console.error(err);
                return 1;
            }
        }
        const args = cliArgs !== null && cliArgs !== void 0 ? cliArgs : process.argv.slice(2);
        const result = (0, child_process_1.spawn)(this.binPath, args, options);
        result.on("error", (error) => {
            console.log(error);
        });
        return new Promise((resolve, reject) => {
            result.on("close", (code) => {
                if (!code) {
                    resolve(code !== null && code !== void 0 ? code : 0);
                }
                reject(code);
            });
        });
    }
    async runAndExit(cliArgs, options = { stdio: [null, utils_1.inherit, utils_1.inherit] }) {
        process.exit(await this.run(cliArgs, options));
    }
    async uninstall() {
        if (this.installDir === Binary.DEFAULT_INSTALL_DIR &&
            (await this.exists())) {
            await (0, utils_1.rm)(this.binPath);
            if (await this.exists()) {
                throw new Error(`Failed to remove binary located ${this.binPath}`);
            }
        }
    }
}
exports.Binary = Binary;
Object.defineProperty(Binary, "DEFAULT_INSTALL_DIR", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: (0, path_1.join)(__dirname, "..", "bin")
});

'''
'''--- npm/dist/install.js ---
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const getBinary_1 = require("./getBinary");
(0, getBinary_1.getBinary)().then(async (bin) => {
    if (!(await bin.exists())) {
        await bin.install();
    }
});

'''
'''--- npm/dist/run.js ---
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const getBinary_1 = require("./getBinary");
async function run() {
    try {
        const bin = await (0, getBinary_1.getBinary)();
        if (process.argv.length < 3) {
            process.argv.push("--help");
        }
        bin.runAndExit();
    }
    catch (err) {
        console.error(err);
        process.exit(1);
    }
}
run();

'''
'''--- npm/dist/uninstall.js ---
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const getBinary_1 = require("./getBinary");
(0, getBinary_1.getBinary)().then(async (bin) => await bin.uninstall());

'''
'''--- npm/dist/utils.js ---
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.rm = exports.inherit = exports.searchPath = exports.fileExists = void 0;
const promises_1 = require("fs/promises");
const path_1 = require("path");
async function fileExists(s) {
    try {
        const f = await (0, promises_1.stat)(s);
        return f.isFile();
    }
    catch {
        return false;
    }
}
exports.fileExists = fileExists;
async function searchPath(filename) {
    const binPath = process.env["WITME_BINARY_PATH"];
    if (binPath &&
        binPath.length > 0 &&
        (await fileExists((0, path_1.join)(binPath, filename)))) {
        return binPath;
    }
    return undefined;
}
exports.searchPath = searchPath;
exports.inherit = "inherit";
async function rm(path) {
    try {
        await (0, promises_1.rm)(path);
    }
    catch (e) { }
}
exports.rm = rm;

'''
'''--- npm/getBinary.js ---
module.exports = require("./dist/getBinary");

'''
'''--- npm/install.js ---
module.exports = require("./dist/install");

'''
'''--- npm/run.js ---
#!/usr/bin/env node
module.exports = require("./dist/run");
'''
'''--- npm/uninstall.js ---
try {
  module.exports = require("./dist/uninstall");
} catch {}

'''