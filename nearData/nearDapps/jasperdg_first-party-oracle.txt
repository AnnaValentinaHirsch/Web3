*GitHub Repository "jasperdg/first-party-oracle"*

'''--- Cargo.toml ---
[package]
name = "request-interface"
version = "0.2.1"
authors = ["Flux Contributors <contributors@flux.xyz>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"
flux-sdk = { git = "https://github.com/fluxprotocol/flux-sdk-rs.git", rev="58ccd8e43701079937956c193749881b4fcfd7b0" }
serde = "1.0.118"

'''
'''--- build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release

if [ ! -d ./res ]; then
    mkdir ./res
fi

cp ./target/wasm32-unknown-unknown/release/request_interface.wasm ./res

'''
'''--- scripts/deploy_requester.sh ---
#!/bin/bash

# default params
network=${network:-testnet}
accountId=${accountId:-account.testnet}
oracle=${oracle:-07.oracle.flux-dev}
paymentToken=${paymentToken:-v2.wnear.flux-dev}

while [ $# -gt 0 ]; do

   if [[ $1 == *"--"* ]]; then
        param="${1/--/}"
        declare $param="$2"
        # echo $1 $2 // Optional to see the parameter:value result
   fi

  shift
done

# Register account with wNEAR contract and Oracle contract, give 1 NEAR to store with oracle to allow for multiple Data Requests to be made
near call $paymentToken storage_deposit "{\"account_id\": \"$accountId\"}" --accountId $accountId --amount 0.00125 --gas=300000000000000
near call $oracle storage_deposit "{\"account_id\": \"$accountId\"}" --accountId $accountId --amount 1 --gas=300000000000000

# Deposit 2 NEAR to get 2 wNEAR tokens to use in your contract
near call $paymentToken near_deposit "{}" --accountId $accountId --amount 2 --gas=300000000000000

NEAR_ENV=$network near deploy --accountId $accountId --wasmFile ./res/request_interface.wasm --initFunction new --initArgs '{"oracle": "'$oracle'", "payment_token": "'$paymentToken'"}'
'''
'''--- scripts/get_request.sh ---
#!/bin/bash

[[ -z "$1" ]] && echo "Expected syntax: $0 YOUR_REQUESTER_ID YOUR_REQUEST_ID" >&2 && exit 1
[[ -z "$2" ]] && echo "Expected syntax: $0 YOUR_REQUESTER_ID YOUR_REQUEST_ID" >&2 && exit 1

near call $1 get_data_request "{\"request_id\": \"$2\"}" --accountId $1

'''
'''--- scripts/new_request.sh ---
#!/bin/bash

[[ -z "$1" ]] && echo "Expected syntax: $0 YOUR_REQUESTER_ID" >&2 && exit 1

JSON="{\"sources\": [],\"tags\":[\"sports\",\"nfl\"],\"description\":\"Which team won the NFL Super Bowl in 1996?\",\"outcomes\":[\"Cowboys\",\"Steelers\"],\"challenge_period\":\"120000000000\",\"settlement_time\":\"1\",\"data_type\":\"String\",\"creator\":\"your_account_id.flux-dev\"}"
env NEAR_ENV=testnet near call $1 create_data_request "{\"amount\": \"1000000000000000000000000\", \"payload\": $JSON}" --accountId $1 --amount 0.000000000000000000000001 --gas=300000000000000
'''
'''--- scripts/reset_account.sh ---
#!/bin/bash

# default params
network=${network:-testnet}
accountId=${accountId:-flux-dev}
master=${master:-flux-dev}
initialBalance=${initialBalance:-5}

while [ $# -gt 0 ]; do

   if [[ $1 == *"--"* ]]; then
        param="${1/--/}"
        declare $param="$2"
        # echo $1 $2 // Optional to see the parameter:value result
   fi

  shift
done

NEAR_ENV=$network near delete $accountId $master
NEAR_ENV=$network near create-account $accountId --masterAccount $master --initialBalance $initialBalance
'''
'''--- src/README.md ---
# Requester Sample Contract

Interested in integrating with the Flux Oracle? **Requester Contracts** can be used to create and submit data requests to the Flux Oracle -- here you will find a sample contract to get you started!

On the testnet deployment, anyone can test their own Request Contract with the testnet oracle. When the Oracle is deployed to mainnet, each Requester will require a successful proposal and execution by the Flux DAO. Any protocol or user-deployed smart contract can experiment directly with the Flux Oracle as a data requester and put any kind of data on-chain to be resolved by our pool of testnet validators.

[Please visit the documentation](https://docs.fluxprotocol.org/docs/getting-started/data-requesters) for more information on getting set up as a data requester! Also see [flux-sdk-rs](https://github.com/fluxprotocol/flux-sdk-rs) for types used inside this contract.

## Building and deploying

```bash
# set vars
REQUESTER=requester.account.testnet
ACCOUNT=account.testnet

# create requester account (or use `scripts/reset_account.sh`)
NEAR_ENV=testnet near create-account $REQUESTER --masterAccount $ACCOUNT --initialBalance 5

sh build.sh

bash scripts/deploy_requester.sh --accountId $REQUESTER

bash scripts/reset_account.sh --master $ACCOUNT --account $REQUESTER
```

## Sending your 1st request

```bash
# set vars
REQUESTER=requester.account.testnet

# send an example arbitrator request at the requester contract that you just deployed
sh scripts/new_request.sh $REQUESTER

# retrieve the details of the request that you just created (request at index 0)
sh scripts/get_request.sh $REQUESTER 0

# once you've sent more requests, you can call the `get_request` script with the
# exact index number you're interested in to view the details of the request at
# that specific index
```

## Options

### Whitelist

Requesters are encouraged to create mechanisms to ensure domain-specific and high-quality (with definite answers, not spammy, etc.) requests are sent to the Flux Oracle to encourage validators to participate in data resolution.

One option is to whitelist the account(s) allowed to call `create_data_request()` by deploying the contract with an array of account IDs for the `whitelist` parameter in the `init()` method. If left empty, any account will be able to call `create_data_request()`, so another mechanism to limit the number of requests sent to the oracle (e.g. time-based limits, governance controls) is encouraged.

'''
'''--- src/helpers.rs ---
use near_sdk::{env, StorageUsage, Balance, AccountId, Promise};

pub fn refund_storage(initial_storage: StorageUsage, sender_id: AccountId) {
    let current_storage = env::storage_usage();
    let attached_deposit = env::attached_deposit();
    let refund_amount = if current_storage > initial_storage {
        let required_deposit =
            Balance::from(current_storage - initial_storage) * env::storage_byte_cost();
        assert!(
            required_deposit <= attached_deposit,
            "The required attached deposit is {}, but the given attached deposit is is {}",
            required_deposit,
            attached_deposit,
        );
        attached_deposit - required_deposit
    } else {
        attached_deposit + Balance::from(initial_storage - current_storage) * env::storage_byte_cost()
    };
    if refund_amount > 0 {
        Promise::new(sender_id).transfer(refund_amount);
    }
}
'''
'''--- src/lib.rs ---
mod helpers;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::collections::LookupMap;
use near_sdk::json_types::{WrappedTimestamp, U128};
use near_sdk::{env, near_bindgen, AccountId, BorshStorageKey, PanicOnDefault};
near_sdk::setup_alloc!();

#[derive(BorshDeserialize, BorshSerialize, Deserialize, Serialize)]
pub struct PriceEntry {
    price: U128,                   // Last reported price
    decimals: u16,                 // Amount of decimals (e.g. if 2, 100 = 1.00)
    last_update: WrappedTimestamp, // Time or report
}

#[derive(BorshDeserialize, BorshSerialize)]
pub struct Provider {
    pub query_fee: u128,
    pub pairs: LookupMap<String, PriceEntry>, // Maps "{TICKER_1}/{TICKER_2}" => PriceEntry - e.g.: ETHUSD => PriceEntry
}

impl Provider {
    pub fn new(account_id: &AccountId) -> Self {
        Self {
            query_fee: 0,
            pairs: LookupMap::new(format!("p_{}", account_id).as_bytes().to_vec()),
        }
    }

    pub fn get_entry_expect(&self, pair: &String) -> PriceEntry {
        self.pairs
            .get(pair)
            .expect("no price available for this pair")
    }

    pub fn set_fee(&mut self, fee: u128) {
        self.query_fee = fee
    }

    pub fn set_price(&mut self, pair: String, price: U128) {
        let mut entry = self.pairs.get(&pair).expect("pair does not exist yet");
        entry.last_update = env::block_timestamp().into();
        entry.price = price;

        self.pairs.insert(&pair, &entry);
    }
}

#[derive(BorshStorageKey, BorshSerialize)]
enum StorageKeys {
    Providers,
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct RequesterContract {
    pub providers: LookupMap<AccountId, Provider>, // maps:  AccountId => Provider
}

#[near_bindgen]
impl RequesterContract {
    #[init]
    pub fn new() -> Self {
        Self {
            providers: LookupMap::new(StorageKeys::Providers),
        }
    }

    #[payable]
    pub fn create_pair(&mut self, pair: String, decimals: u16, initial_price: U128) {
        let initial_storage_usage = env::storage_usage();
        let mut provider = self
            .providers
            .get(&env::predecessor_account_id())
            .unwrap_or_else(|| Provider::new(&env::predecessor_account_id()));

        assert!(provider.pairs.get(&pair).is_none(), "pair already exists");

        provider.pairs.insert(
            &pair,
            &PriceEntry {
                price: initial_price,
                decimals,
                last_update: env::block_timestamp().into(),
            },
        );

        self.providers
            .insert(&env::predecessor_account_id(), &provider);

        helpers::refund_storage(initial_storage_usage, env::predecessor_account_id());
    }

    pub fn pair_exists(&self, pair: String, provider: AccountId) -> bool {
        self.get_provider_expect(&provider)
            .pairs
            .get(&pair)
            .is_some()
    }

    #[payable]
    pub fn push_data(&mut self, pair: String, price: U128) {
        let initial_storage_usage = env::storage_usage();

        let mut provider = self.get_provider_expect(&env::predecessor_account_id());
        provider.set_price(pair, price);
        self.providers
            .insert(&env::predecessor_account_id(), &provider);
        
        helpers::refund_storage(initial_storage_usage, env::predecessor_account_id());
    }

    pub fn get_entry(&self, pair: String, provider: AccountId) -> PriceEntry {
        self.get_provider_expect(&provider).get_entry_expect(&pair)
    }

    pub fn aggregate_avg(
        &self,
        pairs: Vec<String>,
        providers: Vec<AccountId>,
        min_last_update: WrappedTimestamp,
    ) -> U128 {
        assert_eq!(
            pairs.len(),
            providers.len(),
            "pairs and provider should be of equal length"
        );
        let min_last_update: u64 = min_last_update.into();
        let mut amount_of_providers = providers.len();

        let cum = pairs.iter().enumerate().fold(0, |s, (i, account_id)| {
            let provider = self.get_provider_expect(&account_id);
            let entry = provider.get_entry_expect(&pairs[i]);

            // If this entry was updated after the min_last_update take it out of the average
            if u64::from(entry.last_update) < min_last_update {
                amount_of_providers -= 1;
                return s;
            } else {
                return s + u128::from(entry.price);
            }
        });

        U128(cum / amount_of_providers as u128)
    }

    pub fn aggregate_collect(
        &self,
        pairs: Vec<String>,
        providers: Vec<AccountId>,
        min_last_update: WrappedTimestamp,
    ) -> Vec<Option<U128>> {
        assert_eq!(
            pairs.len(),
            providers.len(),
            "pairs and provider should be of equal length"
        );
        let min_last_update: u64 = min_last_update.into();
        pairs
            .iter()
            .enumerate()
            .map(|(i, account_id)| {
                let provider = self
                    .providers
                    .get(&account_id)
                    .expect("no provider with account id");
                let entry = provider.get_entry_expect(&pairs[i]);

                // If this entry was updated after the min_last_update take it out of the average
                if u64::from(entry.last_update) < min_last_update {
                    return None;
                } else {
                    return Some(entry.price);
                }
            })
            .collect()
    }

    fn get_provider_expect(&self, account_id: &AccountId) -> Provider {
        self.providers
            .get(account_id)
            .expect("no provider with this account id")
    }
}

// #[cfg(not(target_arch = "wasm32"))]
// #[cfg(test)]
// mod tests {
//     use super::*;
//     use flux_sdk::DataRequestDataType;
//     use near_sdk::json_types::U128;
//     use near_sdk::serde_json;
//     use near_sdk::MockedBlockchain;
//     use near_sdk::{testing_env, VMContext};

//     fn alice() -> AccountId {
//         "alice.near".to_string()
//     }

//     fn oracle() -> AccountId {
//         "oracle.near".to_string()
//     }

//     fn token() -> AccountId {
//         "token.near".to_string()
//     }

//     fn get_context(input: Vec<u8>, is_view: bool) -> VMContext {
//         VMContext {
//             current_account_id: alice(),
//             signer_account_id: alice(),
//             signer_account_pk: vec![0, 1, 2],
//             predecessor_account_id: alice(),
//             input,
//             block_index: 0,
//             block_timestamp: 0,
//             account_balance: 10000 * 10u128.pow(24),
//             account_locked_balance: 0,
//             storage_usage: 0,
//             attached_deposit: 0,
//             prepaid_gas: 10u64.pow(18),
//             random_seed: vec![0, 1, 2],
//             is_view,
//             output_data_receivers: vec![],
//             epoch_height: 0,
//         }
//     }

//     #[test]
//     #[should_panic(expected = "ERR_INVALID_ORACLE_ADDRESS")]
//     fn ri_not_oracle() {
//         // let context = get_context(vec![], false);
//         // testing_env!(context);
//         // let contract = RequesterContract::new(oracle(), token(), None);
//         // contract.request_ft_transfer(token(), 100, alice());
//     }

// }

'''