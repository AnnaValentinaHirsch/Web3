*GitHub Repository "On0n0k1/Tutorial_NEAR_Rust"*

'''--- EN/README.md ---
# Tutorial_NEAR_Rust

[back](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/)

A step-by-step course for learning Smart Contract development using Rust. In this set of lessons, we will discuss the main features of the Rust language, 
as well as going over the NEAR platform. 

---

## Contact

[top](#tutorial_near_rust)

For any questions, complaints or suggestions, look me up on Discord On0n0k1#3800. If this course makes your life easier, feel free to buy me a cup of coffe by sending a bit of $NEAR to stiltztinkerstein.near . Thank you!

---

## Topics

[top](#tutorial_near_rust)

 - [What is the Rust language](#what-is-the-rust-language)
 - [Using Rust](#using-rust)
 - [Learning Rust](#learning-rust)
 - [Comparing Rust to Javascript and Python](#comparing-rust-to-javascript-and-python)
 - [Installing](#installing)
 - [Lessons](#lessons)

---

## What is the Rust language

[topo](#tutorial_near_rust)

In short, Rust is a low-level systems programming language with the following features:

 - Execution time in the likes of C or C++.
 - Doesn't have the risk involved with memory management as other low-level languages.
 - It has a steep learning curve (but is is well worth it!).
 - Doesn't have and doesn't need garbage collection. At compile time, the compiler can determine when variables are created and freed. 
 - Easy to do parallel programming. 
 - Async programming has about the same level of difficult as other popular languages.
 - Project and Dependency management is way easier than Python or JavaScript.
 - Has been, for years, the most loved language by the developer community!

---

## Using Rust

[top](#tutorial_near_rust)

A Rust developer can:

 - Create web3 applications using decentralized platforms such as NEAR.
 - Create applications that don't need a virtual machine to run them. Only the compiler is needed to produce an executable.
 - Create fast and compact server software hosted in Docker containers.
 - Create robust applications like Lambda functions that can be hosted on AWS (better web3 performance).
 - Create dynamic libs that can used from C.
 - Compile modules to WebAssembly, which can then be imported in a browser that supports javascript or a runtime (like node.js).
 - Compile robust and fast modules for Python using the PyO3 crate.
 - Compile code that target Embedded systems.
 - Have an edge in the job market where there's very few Rust developers worlwide.

---

## Learning Rust
[top](#tutorial_near_rust)

In my opinion, learning Rust is similar to taming a dragon in a fantasy-world. It is slow, difficult, with a lot of different, and simpler, alternatives. 
But if you do tame it, you will have a **powerful** dragon by your side.

Studies show that it takes as much as 30 times more to write code in a low-level language (like C), than in a higher lever language (like Python or JavaScript). 
It is my experience that for a newcomer learning Rust, it is even slower than writing C. 

But, with practice, we get better at everything. With time, we learn what the compiler expects from us. We can leverage code snippets to generate "boilerplate" code automatically. Then, for the developer, everything just becomes a matter of understanding, memory and patience. There were times when I wrote 800 lines of Rust code
in just 2 days. 

We must always take a break to assess our process and make sure we are making the right calls. if we do, every future step will be easier than the one that came before it. 

---

## Comparing Rust to Javascript and Python

[top](#tutorial_near_rust)

A clever person might ask: "Why would I learn a difficult language if I can already solve the same problems in another language I already know?"... and that is a good question! if I already get good results writing a few lines of code in Python, why would I learn Rust? 

Easy of use and quick problem solving: that is the main focus of those languages. How to get to a solution for our problem the most easiest way. 
Processors were getting faster with each generation, so you could just buy new hardware that was faster and better and increase performance. 

But Moore's Law doesn't apply anymore. So, developers are needing better and more efficient algorithms. This need makes them take a closer look at the code and ask
"What is this instruction doing, exactly?". 

When we write `"a = 3"` in Python, a virtual machine is creating a number object, which entails creating a pointer to that number and then associating variable `a` to that pointer. That's why Python is generally limited to one processor core. When we want to take advantage of larger processing power on our machine, the code complexity increases exponentially in both JavaScript and Python.

Rust's focus isn't about the final result of that execution. It is about the path the processor and memory take to reach that result. An experienced Rust developer can take a look at a block of code and say: 
 - "That memory is going to be freed at this point in code";
 - "The processor is going to request freeing memory here and create a shallow copy of that variable here.";
 - "This function is going to borrow this address, use the value in this part of the code, and then give back that address to the owner.";

---

## Installing

[top](#tutorial_near_rust)

You need to install the following before starting the lessons:

 - Install [near-cli](https://github.com/On0n0k1/Tutorial_NEAR_Rust/blob/main/PT-BR/static/tutorials/setup-nearcli.md) to interact with the NEAR platform.
 - Install [rust](https://github.com/On0n0k1/Tutorial_NEAR_Rust/blob/main/PT-BR/static/tutorials/rust.md) to be able to compile and test projects.

---

## Lessons

[top](#tutorial_near_rust)

 - [Lesson 1: Smart Contracts](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/EN/lesson_1_contract)
 - [Lesson 2: Ownership](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/EN/lesson_2_ownership)
 - [Lesson 3: Structs](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/EN/lesson_3_structs)
 - [Lesson 4: Modules](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/EN/lesson_4_modules)
 - [Lesson 5: Using Macros](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/EN/lesson_5_macro_usage)
 - [Lesson 6: Enums](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/EN/lesson_6_enums)

'''
'''--- EN/lesson_1_contract/Cargo.toml ---
[package]
name = "lesson_1_contract"
version = "0.1.0"
license = "MIT"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- EN/lesson_1_contract/Readme.md ---
# Lesson 1: Smart Contracts

[back](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/EN/)

Also see:
 - Using [cargo](https://github.com/On0n0k1/Tutorial_NEAR_Rust/blob/main/PT-BR/static/tutorials/cargo.md).
 - Using [near-cli](https://github.com/On0n0k1/Tutorial_NEAR_Rust/blob/main/PT-BR/static/tutorials/nearcli.md).

---

## Topics
 - [Structure of a NEAR Smart Contract](#structure-of-a-near-smart-contract)
 - [Importing Dependencies](#importing-dependencies)
 - [Allocation macro](#allocation-macro)
 - [Smart Contract declaration](#smart-contract-declaration)
 - [Smart Contract API](#smart-contract-api)
 - [Unit tests](#unit-tests)

---

### Structure of a NEAR Smart Contract
[top](#topics)

Creating a NEAR Smart Contract in Rust can be summarized as:
 - Import crates, modules and other needed dependencies.
 - Allocation Macro (sdk 3.x, but not 4.x)
 - Smart Contract code.
 - Smart Contract API.
 - Unit tests.

The developer is free to add anything to the above list as needed; the steps outlined are just to help memorize the basic steps required to start.

---

### Importing Dependencies
[top](#topics)

Explained in detail in Lesson 4, we need at this point to know the differences between `use` and `mod`. 

```rust
use near_sdk::near_bindgen;
```

Access the `near_sdk` crate and include the macro `near_bindgen` in this namespace. Without this, we would need to write `near_sdk::near_bindgen` every time we needed the macro! Now, we can just write instead a shorter `near_bindgen`. 

Now, let's go over `mod`: 

```rust
mod another_module;
```

This statement means there's a file called "another_module.rs" or a directory with a name "another_module", located in the same place as this Rust file.

If you see a `pub` modifier before the statement, like this:

```rust
pub mod another_module;
```

Or this:

```rust
mod another_module;

pub use another_module::some_dependency;
```

Then it means "another_module" or "some_dependency" can be imported by another external module or crate. 
Importing and Exporting modules is a Rust feature and doesn't have anything to do with the NEAR platform per-se. 

As for Smart Contracts: 

```rust
use near_sdk::{
    borsh::{
        self,
        BorshDeserialize,
        BorshSerialize,
    },
    near_bindgen,
};
```

We are accessing a crate `near_sdk` declared in `Cargo.toml`, and then we're importing `self`, `BorshDeserialize` and `BorshSerialize` from the borsh module. We're also importing `near_bindgen`. 

 - `self`: Needed for BorshDeserialize and BorshSerialize to work correctly.
 - `BorshDeserialize`: When we call a function in our Smart Contract, we sometimes need to provide arguments. Unless they are an empty JSON, these arguments need to be deserialized. This is what BorshDeserialize does: converts from JSON to an actual type we can use.
 - `BorshSerialize`: The reverse of BorshDeserialize. When we want to send back a result, we need to convert from a type or value to valid JSON. 
 - `near_bindgen`: An annotation (actually, a macro) used on a struct to indicate that **"This is a Smart Contract"**. We need to have at least one `struct` annotated with `near_bindgen` for each contract.

---

### Allocation Macro
[top](#topics)

```rust
near_sdk::setup_alloc!(); // (sdk v.3.x)
```

Macros look like functions, however, they are not executed prior to compilation, but rather used as code generators that can be given configuration arguments. Macros don't exist on the program's final binary output. 

In this case, `setup_alloc` generates the necessary boilerplate code so our Smart Contract can work. This macro only runs once, before the Smart Contract declaration.

:warning: **Heads up**: Adding `setup_alloc` applies to **version 3.x** of the NEAR SDK. Starting from v.4.x you might not need it. Be sure to double check the official NEAR SDK documentation.

---

### Smart Contract declaration
[top](#topics)

```rust
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Contract{
    counter: i32,
}
```
This code might be easier to explain from the inside-out: 
 - `counter`: is a number. the "i" in i32 means "signed", so it can be either positive or negative. 32 in this case is the number of bits it has.
 - `pub struct Contract`: a struct declaration that specifies the name of the Smart Contract. "pub" means this Smart Contract is publicly accessible.
 - `#[derive(BorshDeserialize, BorshSerialize)]`: Apply the _traits_ BorshDeserialize and BorshSerialize to this struct. Think for now of _traits_ as similar to the concept of interfaces (behavior-wise).
 - `[near_bindgen]`: An annotation that indicates "this is a Smart Contract". The functions on this struct are also Smart Contract functions. When we execute a Smart Contract function, we are basically executing a function on this struct. 

Next, we have: 
```rust
impl Default for Contract{
    fn default() -> Self{
        Contract { counter: 0 }
    }
}
```

`Default` is a "pattern" trait. Think of it as a default constructor (a constructor without parameters) for our struct. `Default` is there to provide a type with a useful default value. `near_sdk` implements this trait for our Smart Contracts, so we need to apply it or we might run into a compilation error. 

`default` is a function of the `Default` trait that returns a struct of the same type. _`Self`_ refers to the Smart Contract itself. The functions return an instance of `Contract` with a `counter` value of `0`.

If we deploy this contract to a NEAR Account, and then we execute a contract function (one that is not an initializer), NEAR's virtual machine would initialize the contract using `default` before executing our contract's function.

---

### Smart Contract API
[top](#topics)

Now, we've come to the actual functions of our Smart Contract.

```rust
#[near_bindgen]
impl Contract{

    pub fn get(&self) -> i32 {
        self.counter
    }

    pub fn increment(&mut self) -> i32 {
        self.counter += 1;
        self.counter
    }

    pub fn decrement(&mut self) -> i32 {
        self.counter -= 1;
        self.counter
    }
}
```

 - `#[near_bindgen]` is an annotation that indicates "these are the functions of the contract".
 - `impl Contract` is where we declare the functions for our Smart Contract.
 - `&self` and `&mut self` are described in the next lesson. For now, we just need to know that for this type of function that follows the "dot call convention" of `struct_name.function_name`, _`self`_ refers to an instance of the struct.
 - `-> i32` means the return value is a signed 32-bit integer.
 - At the end of the function, the **last line** `self.counter` doesnt end with `;`. the Rust compiler knows how to handle this, as it is the same as having a complete `return self.counter;` statement.

We can now see that the function `get` returns the actual value of `counter` which is being stored on the Smart Contract's `struct` data structure. As for our two contract functions, `increment` adds one to the counter's value, while `decrement` subtracts one from the counter's value.

---

### Unit tests
[top](#topics)

We'll deep dive in more detail in Lesson 4, as we don't need to have all our unit tests for now. We can include unit tests at the end of each Rust module. We can also create a directory `tests`, where all files ending in `.rs` will be considered tests in a test module. 

```rust
#[cfg(test)]
mod tests {
```

`mod tests` is simply a module with a name of `tests`. Nothing special!

`#[cfg(test)]` is quite interesting. `cfg` is a compiler instruction that tells it to "compile the following module if the condition between parenthesis is true". In our case, `(test)` will be true when we run `cargo test`. If we are not running unit tests, this module won't be compiled. 

if, instead of `#[cfg(test)]`, we had:

```rust
#[cfg(not(test))]
mod another_module {
```
Then we would have the opposite scenario, where `another_module` won't be compiled when doing unit testing.

Let's see how we go about unit testing: 
```rust
use super::*;
use near_sdk::{
    AccountId,
    env,
    MockedBlockchain,
    testing_env,
    test_utils::VMContextBuilder,
    json_types::ValidAccountId,
};
```
We first need to import the above dependencies for our unit tests. And now:   

```rust
fn env_setup(){
    let mut builder: VMContextBuilder = VMContextBuilder::new();
    let account_id: AccountId = String::from("stiltztinkerstein");

    builder.current_account_id(
        ValidAccountId::try_from(
            account_id.clone()
        ).unwrap()
    );

    testing_env!(builder.build());

    assert_eq!(
        env::current_account_id(),
        account_id, 
        "Error.\n env: {}\naccount: {}\n", 
        env::current_account_id(), 
        &account_id,
    );
}
```

Before each unit test, we need to set up a mock blockchain environment. One way is to use `VMContextBuilder`, as we just use it to create and configure the desired mock environment, and then use `builder` (which is a VMContextBuilder instance) as an argument to the `testing_env` macro. 

So we don't have to write this code on each test, we can create a function that is re-used.

`assert_eq` isn't really necessary. It just checks the environment variable `env::current_account_id` is the same as the account id specified for the `builder`.

We have three tests:
```rust
#[test]
pub fn get() {
    env_setup();

    let contract: Contract = Contract::default();
    
    assert_eq!(
        contract.get(),
        0
    );
}

#[test]
pub fn increment() {
    env_setup();

    let mut contract: Contract = Contract::default();

    contract.increment();

    assert_eq!(
        contract.get(),
        1
    );
}

#[test]
pub fn decrement() {
    env_setup();

    let mut contract: Contract = Contract::default();

    contract.decrement();

    assert_eq!(
        contract.get(),
        -1
    );
}
```

You can probably see there's a pattern in these tests: 
 - Set up the environment.
 - Initialize the contract. 
 - Execute (exercise) the function we want to test. 
 - Confirm that the function returns the value we expected (or not). 

The function `get` was tested first and this is because it will be used in the following tests. If this function would have not passed the test, we would have to fix it first, before moving on to the other functions. 

---
Lesson 1 :white_check_mark: ... **Done! Congratulations!**

Our [next lesson](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/EN/lesson_2_ownership) will be about Rust's concept of **Ownership**.

'''
'''--- EN/lesson_1_contract/src/lib.rs ---
//! Source <https://github.com/near-examples/rust-counter>
//! 
//! 
//! 

// Documentation Tips:
// Double-slash comments // don't show up in documentation.
// Three-slash comments /// show un as description for what comes next (mod, fn, struct, enum, trait...)
// Bang comments //! can appear at the beginning of the file, and they provide documentation about the entire module.

// imports
use near_sdk::{
    // Arguments received and return values will be converted to/from JSON with borsh
    borsh::{
        self,
        BorshDeserialize,
        BorshSerialize,
    },
    // env,
    // Creates boilerplatecode needed for NEAR virtual machine
    near_bindgen,
};

near_sdk::setup_alloc!();

/// Smart Contract. This struct contains the state in the VM.
/// Functions here are Smart Contract functions.
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Contract{
    /// Counter.
    counter: i32
}

// Default is used for auto-initialization
impl Default for Contract{
    fn default() -> Self{
        Contract { counter: 0 }
    }
}

#[near_bindgen]
impl Contract{

    /// Returns the counter value
    pub fn get(&self) -> i32 {
        // return self.counter;
        self.counter
    }

    /// Increments the counter by 1
    pub fn increment(&mut self) -> i32 {
        self.counter += 1;
        self.counter
    }

    /// Decreases the counter by 1
    pub fn decrement(&mut self) -> i32 {
        self.counter -= 1;
        self.counter
    }
}

// Unit tests go here
// cfg(test) means this mod will be compiled when doing unit testings
#[cfg(test)]
mod tests{
    // super::* imports all modules
    use super::*;
    // import some near_sdk modules needed for these tests 
    use near_sdk::{
        // an account id, like "stiltztinkerstein.near"
        AccountId,
        // has functions related to the execution environment
        // e.g.: we wanted to know the user account that executed this contract
        // we would use a function found here
        env,
        // Mocks (simulates) the Blockchain
        MockedBlockchain,
        // Macro that sets up the test environment with a valid context
        testing_env,
        // Used to create a test context
        test_utils::VMContextBuilder,
        // A valid account id
        // An account id is a string, but the entire string does not represent the actual valid id
        json_types::ValidAccountId,
    };

    /// This function is not a test. It is used by the tests to setup our mock test environment
    fn env_setup(){
        // Initializes a context builder for our tests 
        let mut builder: VMContextBuilder = VMContextBuilder::new();

        // attributes that can be modified using the builder
        // current_account_id
        // signer_account_id
        // signer_account_pk
        // precessor_account_id
        // block_index
        // block_timestamp
        // epoch_height
        // account_balance
        // account_locked_balance
        // storage_usage
        // attached_deposit
        // prepaid_gas
        // random_seed
        // is_view

        // account id string
        let account_id: AccountId = String::from("stiltztinkerstein");

        builder.current_account_id(
            // try_from tries to convert a string to a valid account id
            // panics if the id is invalid
            ValidAccountId::try_from(
                account_id.clone()
            ).unwrap()
        );

        // sets up the mock
        testing_env!(builder.build());

        // if the first two arguments are not equal, 
        // return the error message
        assert_eq!(
            env::current_account_id(),
            account_id, 
            "Erro assert.\n env: {}\naccount: {}\n", 
            env::current_account_id(), 
            &account_id,
        );
    }

    /// As it is annotated as #[test] this will execute automatically
    /// when we do unit testing
    #[test]
    pub fn get() {
        env_setup();

        let contract: Contract = Contract::default();
        
        assert_eq!(
            contract.get(),
            0
        );
    }

    #[test]
    pub fn increment() {
        env_setup();

        let mut contract: Contract = Contract::default();

        contract.increment();

        assert_eq!(
            contract.get(),
            1
        );
    }

    #[test]
    pub fn decrement() {
        env_setup();

        let mut contract: Contract = Contract::default();

        contract.decrement();

        assert_eq!(
            contract.get(),
            -1
        );
    }
}

'''
'''--- EN/lesson_2_ownership/Cargo.toml ---
[package]
name = "lesson_2_ownership"
version = "0.1.0"
authors = ["Lucas Lemos <stiltztinkerstein@gmail.com>"]
license = "MIT"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- EN/lesson_2_ownership/Readme.md ---
# Lesson 2: Ownership

[back](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/EN/)

Let's learn about Ownership in Rust!

---

## Topics
 - [Functions](#functions)
 - [Background](#background)
 - [Ownership](#ownership)
 - [References](#references)
 - [Using References](#using-references)
 - [Examples](#examples)
 - [Unit tests](#unit-tests)

---

### Functions
[top](#topics)

```rust
/// Returns the length of the string
pub fn get_length(&self) -> u32;

/// Returns the length of the string and changes `name` to another value.
pub fn get_length_again(&mut self) -> u32;
```

---

### Background
[top](#topics)

We'll explain the concept of **Ownership** in the next section, but let's first focus on the problem it solves. 

Consider the following statement:

```
A = B;
```

We know `A`  is equal to `B`, since `A` is being assigned the value of `B`. But what is really happening? 

Are we creating a copy of the value of `B`, and assigning `A` that value? Creating a copy means to allocate memory, get that memory's address and set that memory's address to the value of `B`.  For an integer that seems simple, but what about a 2.000 character string? 

And if we are using a variable as an argument to a function... are we creating a copy of the variable and then dropping it after the function finishes? 

You will realize we need a way to reuse the same memory address in different parts of our application. The C language solved this through the use of pointers. Instead of storing the value of a variable, we store the memory address for that type of variable. 

But that solutions brings another problem. If a function has access to the memory address of a very important variable, then this function has a lot of power. What if this function was implemented without thinking of potential security issues? A hacker could use an implementation flaw or bug to break the application or gain access to the system. 

 - We need a method of handling memory that avoids unnecessary overhead and provides safety. 
 - And, we need to avoid that our chosen memory handling strategy provides more power than it needs to. 

**:hand: NOTE:** Rust also has pointers, but there are different kinds of pointers, with different advantages and disadvantages. C style pointers can be used but the code where they're used (code block) **must** to be annotated as **"unsafe"** ([More](https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html)).

---

### Ownership
[top](#topics)

The following statement:

```
A = B;
```

Can be done in two ways: 
 - If `B` implements a `Copy` trait, it will create a copy automatically. 
 - If `B` doesn't implement `Copy`, `A` will **own** `B`. The compiler will restrict the use of `B`, because the value of `B` was **"moved"** to `A`. 

 - Numbers (`u32`, `f32`, `i32`, ...) implement `Copy` and `Clone`. 
 - String implements `Clone`, but **not** `Copy`.

**:hand: NOTE:** [What’s the difference between Copy and Clone?](https://doc.rust-lang.org/std/marker/trait.Copy.html#whats-the-difference-between-copy-and-clone)

So, in order to create a copy of a String, we need to do it explicitly. 

Ownership guarantees that a variable is the owner of ("owns") a memory address for that variable. Keep in mind, that ownership can be transfered, but to "share" a variable, we can just use pointers or references. 

---

### References
[top](#topics)

References, or borrowing ("borrow") are a way of sharing memory addresses with limited permissions. These references can be mutable or immutable, and are specified as: 

```rust
let a = 10; // Create a variable with a value of 10
let b = &a; // Create a variable b that references variable a
```

```rust
let mut a = 10; // Create a mutable variable with a value of 10
let b = &mut a; // Create a variable that is a mutable reference to variable a
```

Variables are, by default, immutable or more like constants. That's why you need to explicitly declare `a` as mutable. 

 - Immutable references can access a value, but they can't change it.
 - Mutable reference can access **and** change a value.

Here are some rules to remember:
 - You can't change the original value while there's still a reference to it.
 - You can have many immutable references.
 - There can be only **one** mutable reference. 
 - You can't have immutable references if there is one mutable reference.

When we create a reference, we're basically having an "owner" variable "borrow" its value to another variable The "borrowing" ends on the last line the variable is used. 

---

### :warning: Using References
[top](#topics)

**Don't return references just yet!** While returning them is possible, you have to specify the "lifetime" of the return value. You're beginning to learn Rust, and the whole concept of lifetimes can be avoided by simply returning copies when necessary. If you want to know more, then [learn more about lifetimes](https://doc.rust-lang.org/rust-by-example/scope/lifetime.html) first.

Lifetimes are a **powerful** concept if used correctly. Tools like `serde` and `borsh` use it to convert JSON to the type we need without any copying. That means, memory allocation is only made for our JSON string and for the type we need, nothing more. 

---

### Examples
[top](#topics)

This is our Smart Contract ...
```rust
#[near_bindgen]
#[derive(Clone, BorshDeserialize, BorshSerialize)]
pub struct Contract {
    name: String,
}

impl Default for Contract{
    fn default() -> Self {
        return Contract {
            name: String::from("A default string"),
        };
    }
}
```

... and here are the functions we will go over as we learn: 

```rust
fn this_takes_a_reference(name: &str) -> usize { 
        return name.len();
    }

fn this_takes_the_ownership(name: String) -> usize {
    name.len()
}

pub fn get_length(&self) -> u32 {
    let length_reference: usize = Self::this_takes_a_reference(&self.name);
    let length_ownership: usize = Self::this_takes_the_ownership(self.name.clone());

    assert_eq!(
        length_reference, 
        length_ownership, 
        "Both have the same size {} and {}", length_reference, length_ownership,
    );

    length_reference as u32
}

pub fn get_length_again(&mut self) -> u32 {
    let a_reference: &String = &self.name;
    let _another_reference: &String = &self.name;
    let _yet_another_reference: &String = &self.name;
    let length = Self::this_takes_a_reference(a_reference);
    self.name = String::from("Changed name");

    length as u32
}
```

But before getting into details, let's talk about `String` and `&str`.

---

### What is a `String`

A `String` is a variable that has an owner. It stores a string and will be freed from memory when the variable is dropped. Unlike other languages, keep in a mind a string in quotes, such as `"A text like this"` is not a String, but rather something called a string slice, or `&str`. A reference to a String is denoted as `&String` or `&mut String`.

---

### What is an `&str` (or string slice)

This type simplifies string use in our code. Think of it as an immutable reference to a String, but as it is allocated by the compiler, the compiler gets to decide how to best optimize its memory use.

---

### Using `String` in Functions

Let's take a look at an example of `String` and `&str`:

```rust
let variable: String = String::from("A Variable");
let reference: &str = "A Variable";
```

The function below takes a `&str` and returns its length. The "borrow" ends when the function finishes. 

```rust
fn this_takes_a_reference(name: &str) -> usize { 
    name.len()
}
```
Let's provide the function some arguments:

```rust
this_takes_a_reference(&variable);
this_takes_a_reference(reference);
```
The following functions takes a `String` as argument and returns its length. The functions becomes the **owner** of the memory and drops it when it finishes. 

```rust
fn this_takes_the_ownership(name: String) -> usize {
    name.len()
}
```
In order to use arguments with `this_takes_the_ownership` ...

```rust
this_takes_the_ownership(variable);
this_takes_the_ownership(String::from(reference));
```
... we need to convert `&str` to a `String` before passing it.  Also, this function acquired ownership but that wasn't really needed.

Both functions `this_takes_a_reference` and `this_takes_the_ownership` do the same thing, don't cause errors and return the same result. **But**, the first one is more efficient than the second one. Be mindful to prefer using `&str` instead of `String` on function declarations.

You also need to keep in mind that Smart Contract functions annotated with `#[near_bindgen]` need to use the `String` type in their arguments. That's only because the deserialization traits are implemented for `String`, but not for `&str`.

The following function ...

```rust
pub fn get_length(&self) -> u32 {
    let length_reference: usize = Self::this_takes_a_reference(&self.name);
    let length_ownership: usize = Self::this_takes_the_ownership(self.name.clone());

    assert_eq!(
        length_reference, 
        length_ownership, 
        "Both have the same length {} and {}", length_reference, length_ownership,
    );
}
```
... calls `this_takes_a_reference` and `this_takes_the_ownership`, making sure both return the same value (by ussing an `assert_eq`) before actually returning it. 

Let's take a look a another function:

```rust
pub fn get_length_again(&mut self) -> u32 {
    let a_reference: &String = &self.name;
    let _another_reference: &String = &self.name;
    let _yet_another_reference: &String = &self.name;
    let length = Self::this_takes_a_reference(a_reference);

    self.name = String::from("Changed name"); // change value of name

    length as u32
}
```
Calls `this_takes_a_reference` and changes the value of `name` stored in the Smart Contract. You can see that there can be many references to the same variable, but be sure to change these as specified [in the code's comments](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/EN/lesson_2_ownership/src/lib.rs) to see how the compiler reacts.

---
Lesson 2 :white_check_mark: ... **Done! Congratulations!**

Our [next lesson](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/EN/lesson_3_structs) will be about Rust's structs.

'''
'''--- EN/lesson_2_ownership/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
#[allow(unused_imports)]
use near_sdk::{env, near_bindgen};

// A Macro that generates boilerplate code for NEAR. For v.4 setup_alloc() will be deprecated. 
near_sdk::setup_alloc!();

#[near_bindgen]
#[derive(Clone, BorshDeserialize, BorshSerialize)]
pub struct Contract {
    name: String,
}

impl Default for Contract{
    fn default() -> Self {
        // Initialize name with a value of "A default string"
        return Contract {
            name: String::from("A default string"),
        };
    }
}

#[near_bindgen]
impl Contract{
    // &str is a string reference
    // strings between " " are string literals or 'static &str
    // and having a &str as a parameter allows for &String as well as String literals such as "a string like this"
    /// Returns the length of a string
    fn this_takes_a_reference(name: &str) -> usize { 
        return name.len();
    }

    // This functions does the same as the previous one, but uses a String parameter
    // We can create a String by using the function String::from("our text")
    /// Returns the size of a string
    fn this_takes_the_ownership(name: String) -> usize {
        // return usze, which is u32 in 32-bit systems, and u64 in 64-bit sytems
        name.len()
    }

    /// Returns the size of the string stored in the name variable
    pub fn get_length(&self) -> u32 {
        // Let's call both functions to show they do the same thing
        //
        // Borrowing: Adding & to each argument is allowing the function to use the variable's value, but not modify it
        let length_reference: usize = Self::this_takes_a_reference(&self.name);

        // Ownership: this function takes ownership of the string, and therefore we need to clone it 
        // notice there's no &
        let length_ownership: usize = Self::this_takes_the_ownership(self.name.clone());

        // Let's use assert_eq to test both functions returned the same value
        // if they are different, the code will panic
        assert_eq!(
            // first value to compare
            length_reference, 
            // second value to compare
            length_ownership, 
            // if they're not equal, panic with the provided message
            "The are not the same size {} and {}", length_reference, length_ownership,
        );

        // Convert to u32, this is simple format for json serialization
        // types can be converted using traits, by implementing "into" and "from"
        length_reference as u32
    }

    /// Return the size of the string stored in the name variable, but change its value
    pub fn get_length_again(&mut self) -> u32 {
        // we can declare variables that store references to another value
        let a_reference: &String = &self.name;
        let _another_reference: &String = &self.name;
        let _yet_another_reference: &String = &self.name;

        // We can have many immutable references
        // but we can't change a variable's value while these references exist
        // If we needed a mutable reference, you can't have any existing immutable references

        // Uncomment the following line to raise an error: existing borrow
        // self.name = String::from("Changed name");

        let length = Self::this_takes_a_reference(a_reference);

        // this next line is Ok, since a reference is no longer used (borrow)
        // and the compiler can drop the borrow
        self.name = String::from("Changed name");

        length as u32
    }
}

#[cfg(test)]
mod tests{
    use super::*;
    use near_sdk::{
        AccountId,
        env,
        MockedBlockchain,
        testing_env,
        test_utils::VMContextBuilder,
        json_types::ValidAccountId,
    };

    fn env_setup(){
        let mut builder: VMContextBuilder = VMContextBuilder::new();

        // fields that can be changed via the builder
        // current_account_id
        // signer_account_id
        // signer_account_pk
        // precessor_account_id
        // block_index
        // block_timestamp
        // epoch_height
        // account_balance
        // account_locked_balance
        // storage_usage
        // attached_deposit
        // prepaid_gas
        // random_seed
        // is_view

        let account_id: AccountId = String::from("stiltztinkerstein");

        builder.current_account_id(
            ValidAccountId::try_from(
                account_id.clone()
            ).unwrap()
        );

        testing_env!(builder.build());

        assert_eq!(
            env::current_account_id(),
            account_id, 
            "Erro assert. env: {} account: {}", 
            env::current_account_id(), 
            &account_id,
        );
    }

    #[test]
    pub fn get_length() {
        env_setup();
    
        let mut contract: Contract = Contract::default();
    
        // Both functions to the same thing, so both must return the same value
        assert_eq!(
            contract.get_length(),
            contract.get_length_again()
        );

        // get_length_again also modified the stored string value or the name field
        assert_eq!(
            contract.name,
            "Changed name"
        );
    }
}
'''
'''--- EN/lesson_3_structs/Cargo.toml ---
[package]
name = "lesson_3_structs"
version = "0.1.0"
authors = ["Lucas Lemos <stiltztinkerstein@gmail.com>"]
license = "MIT"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- EN/lesson_3_structs/Readme.md ---
# Lesson 3: Structs

[back](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/EN/)

Let's go over `struct` and how ownership is used in our struct functions.

---

## Topics

 - [Introduction](#introduction)
 - [Contract functions](#contract-functions)
 - [Project](#project)
   - [Contract Structure](#contract-structure)
   - [`Clone` trait](#clone-trait)
   - [`just_a_function`](#just_a_function)
   - [Macros](#macros)
   - [`take_ownership`](#take_ownership)

---

## Introduction
[back](#topics)

A `struct` is similar to a class in other object-oriented programming languages. The difference is that a `struct` doens't support inheritance, but we can implement one or more traits on them, and these traits specify behavior. 

We'll dive into traits in future lessons, but for now, consider traits as sets of functions that represent behavior supported by types. The trait `Clone` allows using the `.clone()` function to create copies of an instance. The trait `BorshDeserialize` lets you build an instance of a type by using a JSON formatted string. 

Later on, we'll learn how to create trait functions that can be applied to any type. For now, we'll just focus on structs.

---

## Smart Contract functions
[top](#topics)

```rust
// gets and sets
pub fn get_a_string(&self) -> String;

pub fn get_a_floating(&self) -> f32;

pub fn get_another_integer(&self) -> i32;

pub fn get_an_integer(&self) -> u32;

pub fn set_a_string(&mut self, a_string_arg: String);

pub fn set_a_floating(&mut self, a_floating: f32);

pub fn set_an_integer(&mut self, an_integer: u32);

pub fn set_another_integer(&mut self, another_integer: i32);

// A function that doesn't change the contract's state
pub fn just_a_function();

// A function using StructExample that takes ownership of itself and is dropped at the end
pub fn take_ownership(&self) -> u32;
```
See their implementations for details.

---

## Project

[top](#topics)

We'll first create a `struct` called `StructExample`.

```rust
pub struct StructExample{
    an_integer: u32,
    another_integer: i32,
    a_floating: f32,
    a_string: String,
}
```
This type has the following fields: 
 - `an_integer`: an unsigned 32-bit integer.
 - `another_integer`: a signed 32-bit integer.
 - `a_floating`: a floating 32-bit number.
 - `a_string`: a String, described in the previous lesson.

In other languages, we might have to write `long int` for i32, or `long long int` for i64. However, in Rust, we just need to specify the `i` for "signed" (positive or negative) and `u` for "unsigned" (positive). All types such as `u8`, `u16`, `u32`, `u64` and `u128` are all valid "unsigned" types.

---

### Contract Structure

[top](#topics)

Here's the Smart Contract code:

```rust
#[derive(BorshDeserialize, BorshSerialize, Default)]
pub struct Contract {
    struct_example: StructExample,
}
```
See how this Smart Contract is annotated with `derive`? When you `derive`, it means the compiler is able to provide a basic implementation for some traits, but you can manually implement them if more complex behavior is needed. Here, `derive` for `Default` will make sure **all fields** of `Contract` have a `.default()` function. This also means that `StructExample` must also implement the `Default` trait. 

:hand: Be sure to read about [Serialization Protocols](https://www.near-sdk.io/contract-interface/serialization-interface) if you want a deeper understanding of how BorshSerialize and BorshDeserialize works in NEAR. 

```rust
impl Default for StructExample{
    fn default() -> Self {
        let an_integer: u32 = 1;
        let a_floating: f32 = 0.5;

        StructExample {
            an_integer,
            another_integer: -1,
            a_floating,
            a_string: String::from("A default string"),
        }
    }
}
```
We used some random values for this example. We also don't need to specify `an_integer: an_integer` or `a_floating: a_floating` when the names of the variables are the same.

---

### `Clone` trait
[top](#topics)

Let's implement the `Clone` trait on our `StructExample`:

```rust
impl Clone for StructExample{
    // self is an instance of StructExample, Self (uppercase) is of type StructExample.
    fn clone(&self) -> Self {
        let an_integer: u32 = self.get_an_integer();
        let another_integer: i32 = self.get_another_integer();
        let a_floating: f32 = self.get_a_floating();
        let a_string: String = self.get_a_string();

        // Self and StructExample are the same
        Self {
            an_integer,
            another_integer,
            a_floating,
            a_string,
        }
    }
}
```
:hand: **NOTE:** Remember, I'm intentionally writing code in a more complex way just to show the different ways our implementation could be made. 

There really isn't much to say on `get` and `set` functions, you can just check the comments. 

Let's go over `just_a_function` and `take_ownership`:

---

### just_a_function

[top](#topics)

```rust
pub fn just_a_function() {
    env::log(b"You just called this function");
    env::log(format!("1 + 1 = {}", 1 + 1).as_bytes());
}
```
This function outputs two lines of text. 

The `log` function receives a sequence of bytes as an argument. 
So, in our first call, you can use "b" as a way to indicate that the following string should be treated as bytes. 

The second time, we use the macro `format!` to format a String. The String type has a function `.as_bytes()` that converts its value to bytes. If you want to learn more, then be sure to read about [as_bytes()](https://doc.rust-lang.org/std/string/struct.String.html#method.as_bytes).

---

### Macros
[top](#topics)

For now, let's consider a **macro** as a function that will execute prior to code being compiled. These functions generate code for you. After the code is generated, the compiler runs and error checking happens. The most common scenario for a **macro** is to allow for functions with a variable number of parameters. 

Another way to see macros would be as a way to trade code complexity for ease of use. 

---

### take_ownership
[top](#topics)

```rust
pub fn take_ownership(self) -> u32{
    env::log(b"Taking ownership of itself");

    let result = format!("an_integer is {}", self.an_integer);
    env::log(result.as_bytes());

    self.an_integer

    // self will be dropped / freed here
}
```

This is an interesting piece of code: 
 - Prints "Taking ownership of itself" on screen. 
 - Prints the value of `an_integer`, which is a contract variable. 
 - Finally, returns the value of `an_integer`.

However, as we used `self` instead of `&self`, as well as `&mut self` as an argument, this function will take ownership of itself and will "self-destruct" after finishing execution. 

:hand: **NOTE:** a beginner will probably get a confusing error from the compiler while attempting to write the code above, such as "value used here after move".

---
Lesson 3 :white_check_mark: ... **Done! Congratulations!**

Our [next lesson](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/EN/lesson_4_modules) will be about Rust's modules.
'''
'''--- EN/lesson_3_structs/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
#[allow(unused_imports)]
use near_sdk::{env, near_bindgen};

near_sdk::setup_alloc!();

// derive is a macro that generates code for the specifiec traits between ()
// we use it so the contract gets trait implementations of BorshDeserialize and BorshSerialize
// StructExample is the state of a contract, so we need these two traits in place
#[derive(BorshDeserialize, BorshSerialize)]
// A struct with primitive types
pub struct StructExample{
    an_integer: u32,
    another_integer: i32,
    a_floating: f32,
    a_string: String,
}

// default is executed when the code loads and prior to initialization
// it can be called manually to create an instance with default values
impl Default for StructExample{
    fn default() -> Self {
        // you can set field values using name: value
        let an_integer: u32 = 1;
        let a_floating: f32 = 0.5;

        // and here we return the struct with the default field values we specified
        StructExample {
            an_integer,
            another_integer: -1,
            a_floating,
            a_string: String::from("A default string"),
        }
    }
}

// Clone creates a copy of the struct
impl Clone for StructExample{
    // self is an instance of StructExample, and Self (uppercase) is the actual StructExample type.
    fn clone(&self) -> Self {
        let an_integer: u32 = self.get_an_integer();
        let another_integer: i32 = self.get_another_integer();
        let a_floating: f32 = self.get_a_floating();
        let a_string: String = self.get_a_string();

        // Self and StructExample are the same here
        Self {
            an_integer,
            another_integer,
            a_floating,
            a_string,
        }

    }
}

// Let's implement the functions for StructExample
impl StructExample{

    // &self means borrowing a StructExample instance, but it can't modify it
    /// Returns a String copy of the a_string field value
    pub fn get_a_string(&self) -> String {

        // String implements the Clone trait, but not Copy
        // Copy creates an instance (a copy) automatically with an instruction like a = b 
        // Clone creates an instance (a copy) when the code calls clone()
        let a_string: String = self.a_string.clone();

        return a_string;
    }

    pub fn get_a_floating(&self) -> f32 {
        // f32 implements Copy, so this will create a copy of a_floating automatically
        return self.a_floating;
    }

    pub fn get_another_integer(&self) -> i32 {
        // you dont' need to write the 'return' statement every time
        // if the line is the last one and it doesn't have ';' at the end, assume return
        self.another_integer
    }

    pub fn get_an_integer(&self) -> u32 {
        self.an_integer
    }

    // '&mut self' will borrow a StructExample instance and also make changes to it
    pub fn set_a_string(
        &mut self, 
        // For the following a_string_arg, the function will take ownership since we are not borrowing it using &
        // This means this function now owns this piece of memory and 
        // that code that called this function won't need this string again
        //
        // This is one of Rust's superpowers: It allows to minimze the amount of copies we need
        a_string_arg: String,
    ) {
        // as we borrow a mutable self, we can change its field values
        self.a_string = a_string_arg;
    }

    pub fn set_a_floating(&mut self, arg: f32) {
        self.a_floating = arg;
    }

    pub fn set_an_integer(&mut self, an_integer: u32) {
        // u32 is unsigned, only positive values
        self.an_integer = an_integer;
    }

    pub fn set_another_integer(&mut self, another_integer: i32){
        // i32 is signed, values can be positive or negative. This halves the max value allowed
        self.another_integer = another_integer;
    }

    // if the function doesn't have 'self', then it is a function associated with the type itself
    pub fn just_a_function() {
        env::log(b"You just called this function");
        env::log(format!("1 + 1 = {}", 1 + 1).as_bytes());
    }

    // if 'self' is an argument, the function will take ownership of the instance
    // this meand the struct will be dropped at the end of the function (unless we return it)
    // this is just an example, you probably won't ever need to do this
    pub fn take_ownership(self) -> u32{
        env::log(b"Taking ownership of itself");

        let result = format!("an_integer is {}", self.an_integer);
        env::log(result.as_bytes());

        self.an_integer

        // self will be dropped/free from memory here
    }
}

// #[near_bindgen] instructs near-sdk that this struct is the state of our Smart Contract
// we can use any name, but 'Contract' is easy to understand
#[near_bindgen]
// derive is a macro that generates the specified trait implementations on our StructExample
// we use it so our contract supports BorshDeserialize and BorshSerialize
// These traits define how data structures are translated into bytes which are needed for passing data
// into methods of the smart contract or storing data in state.
//
// For method parameters, JSON (default) and Borsh are supported.
// For storing data on-chain Borsh is used.
#[derive(BorshDeserialize, BorshSerialize, Default)]
pub struct Contract {
    struct_example: StructExample,
}

#[near_bindgen]
impl Contract{
    // The functions below redirect to the struct functions. 
    // The difference being is that these ones below, represent how we interact with the actual Smart Contract
    
    
    // get_* functions need &self, and set_* need to make changes so we use &mut self
    // using '&self' for get_* functions
    pub fn get_a_string(&self) -> String {
        self.struct_example.get_a_string()
    }

    pub fn get_a_floating(&self) -> f32 {
        self.struct_example.get_a_floating()
    }

    pub fn get_another_integer(&self) -> i32 {
        self.struct_example.get_another_integer()
    }

    pub fn get_an_integer(&self) -> u32 {
        self.struct_example.get_an_integer()
    }

    // using 'mut &self' for get_* functions
    pub fn set_a_string(&mut self, a_string_arg: String) {
        self.struct_example.set_a_string(a_string_arg);
    }

    pub fn set_a_floating(&mut self, a_floating: f32) {
        self.struct_example.set_a_floating(a_floating);
    }

    pub fn set_an_integer(&mut self, an_integer: u32) {
        self.struct_example.set_an_integer(an_integer);
    }

    pub fn set_another_integer(&mut self, another_integer: i32) {
        self.struct_example.set_another_integer(another_integer);
    }

    // just_a_function doesn't use '&self', '&mut self' or 'self'
    // so is is just a function in the same namespace as our struct
    pub fn just_a_function(){
        // you can use :: to reference items in namespaces. Our function here is not an instance of our struct. 
        StructExample::just_a_function();
    }

    pub fn take_ownership(&self) -> u32 {
        // A função take_ownership libera o objeto da memória.
        // The compiler will not let us call it directly when the owner is Contract.
        // O compilador não irá nos deixar chamar isso diretamente enquanto o dono for Contract.
        // Most of the issues of ownership can be solved by just cloning the object.
        // A maioria dos problemas de possessão (ownership) podem ser resolvidos apenas clonando objetos
        let a_copy: StructExample = self.struct_example.clone();

        // a_copy será removido no fim dessa função abaixo.
        let result = a_copy.take_ownership();

        // Descomente a linha abaixo e um erro de "move" irá aparecer.
        // Isso é porque chamamos uma função de uma instância que não existe mais.
        // env::log(format!("Essa linha de código irá gerar um erro {}", a_copy.get_a_floating()).as_bytes());

        result
    }
}

// cfg instructs the compiler to consider the 'tests' module as a test harness. You can then use 'cargo test' to use this module 
// for running functions with a #[test] attribute, automatically
#[cfg(test)]
mod tests{
    use super::*;
    use near_sdk::{
        AccountId,
        env,
        MockedBlockchain,
        testing_env,
        test_utils::VMContextBuilder,
        json_types::ValidAccountId,
    };

    fn env_setup(){
        let mut builder: VMContextBuilder = VMContextBuilder::new();

        // fields that can be changed via the builder
        // current_account_id
        // signer_account_id
        // signer_account_pk
        // precessor_account_id
        // block_index
        // block_timestamp
        // epoch_height
        // account_balance
        // account_locked_balance
        // storage_usage
        // attached_deposit
        // prepaid_gas
        // random_seed
        // is_view

        let account_id: AccountId = String::from("stiltztinkerstein");

        builder.current_account_id(
            ValidAccountId::try_from(
                account_id.clone()
            ).unwrap()
        );

        testing_env!(builder.build());

        assert_eq!(
            env::current_account_id(),
            account_id, 
            "Assert Error. env: {} account: {}
            ", 
            env::current_account_id(), 
            &account_id,
        );
    }

    #[test]
    pub fn get_a_string() {
        env_setup();
    
        let contract: Contract = Contract::default();
    
        // test Value from the default implementation
        assert_eq!(
            contract.get_a_string(),
            "A default string"
        );
    }

    #[test]
    pub fn get_a_floating(){
        env_setup();
    
        let contract: Contract = Contract::default();
    
        // test Value from the default implementation
        assert_eq!(
            contract.get_a_floating(),
            0.5,
        );

    }

    #[test]
    pub fn get_another_integer(){
        env_setup();
    
        let contract: Contract = Contract::default();
    
        // test Value from the default implementation
        assert_eq!(
            contract.get_another_integer(),
            -1,
        );

    }

    #[test]
    pub fn get_an_integer(){
        env_setup();
    
        let contract: Contract = Contract::default();
    
        // test Value from the default implementation
        assert_eq!(
            contract.get_an_integer(),
            1,
        );
    }

    #[test]
    pub fn set_a_string() {
        env_setup();

        let mut contract: Contract = Contract::default();

        contract.set_a_string(String::from("A new string"));

        assert_eq!(
            contract.get_a_string(),
            String::from("A new string"),
        );
    }

    #[test]
    pub fn set_a_floating() {
        env_setup();

        let mut contract: Contract = Contract::default();

        contract.set_a_floating(-10.5432);
        
        assert_eq!(
            contract.get_a_floating(),
            -10.5432,
        );
    }

    #[test]
    pub fn set_an_integer() {
        env_setup();

        let mut contract: Contract = Contract::default();

        contract.set_an_integer(5);

        assert_eq!(
            contract.get_an_integer(),
            5,
        );
    }

    #[test]
    pub fn set_another_integer() {
        env_setup();

        let mut contract: Contract = Contract::default();

        contract.set_another_integer(7);

        assert_eq!(
            contract.get_another_integer(),
            7
        );
    }

    #[test]
    pub fn just_a_function(){
        env_setup();

        // We declare a Contract instance with default field values
        // You can use an underscore _ in front of a variable name if you know in advance
        // you are not going to use it immediately (that way the compiler won't complain)
        let _contract: Contract = Contract::default();

        
        // Note we use :: since this function doesn't require state
        Contract::just_a_function();
    }

    #[test]
    // take_ownership is just an example of another way to do things in Rust
    pub fn take_ownership(){
        env_setup();

        let contract: Contract = Contract::default();

        let an_integer = contract.get_an_integer();

        assert_eq!(
            contract.take_ownership(),
            an_integer,
        );
    }

}

'''
'''--- EN/lesson_4_modules/Cargo.toml ---
[package]
name = "lesson_4_modules"
version = "0.1.0"
authors = ["Lucas Lemos <stiltztinkerstein@gmail.com>"]
license = "MIT"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- EN/lesson_4_modules/Readme.md ---
# Lesson 4: Modules

[back](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/EN/)

In this lesson we will talk about organizing our code and using modules.

We could have all our code in a single `lib.rs` file, but this would file would increase in size and complexity very fast, and it would also be very difficult to organize a large project around a single file with all our code in it.

Here's some ways we can organize our code: 

 - We can declare external modules; 
 - We can declare directories as modules;
 - We can control when our modules are public (can be used by anyone);
 - We can control the path for each public module;
 - We can put our tests in a `./tests/` directory. 

---

## Contract API

```rust
/// Returns the stored String
pub fn get_phrase(&self) -> String;

/// This function will print "Hello from crate::a_module"
/// and store that value
pub fn hello(&mut self);

/// This function will print "Hello from crate::a_module::specific_module"
/// and store that value
pub fn hello1(&mut self);

/// This function will print "Hello from another module" 
/// and store that value
pub fn hello2(&mut self);

/// This function will print "Hello from yet_another_module" 
/// and store that value
pub fn hello3(&mut self);

/// This function will print "Called a deep function"
/// and store that value
pub fn hello4(&mut self);

/// This function will panic and print "A panic just happened"
/// when called
pub fn this_will_panic();
```

---

## Topics
 - [How to declare an external module](#how-to-declare-an-external-module)
 - [How to use a file or directory as a module](#how-to-use-a-file-or-directory-as-a-module)
 - [Using or Importing modules](#using-or-importing-modules)
   - [Aliases](#aliases)
   - [Public access](#public-access)
 - [Tests](#tests)
   - [NEAR integration tests](#near-integration-tests)
   - [Rust tests](#rust-integration-tests)
  - [Disable compiler warnings](#disable-compiler-warnings)
  - [Testing errors](#testing-errors)

---

## How to declare an external module

[top](#topics)

An external module must be declared prior to using or importing it.

```rust
mod yet_another_module;
```

This declaration tells the compiler there is a module with this name in the same directory. There are three ways to declare a module. If two or more modules with the same name are found, an ambiguity error will be raised.

The module above is private, so it can be used where it was declared. We can turn it public by using:

```rust
pub mod a_module;
```

`a_module` is now public... this means that it can be imported by other code, including external crates.
If you want to restrict that, you can write:

```rust
pub(crate) fn hello() -> String{
    String::from("Hello from crate::a_module::specific_module")
}
```
`pub(crate)` means this function will only be public in this crate. This means that if `lesson_4_modules` was a dependency of another project, that crate would not have access to this function.

---

## How to use a file or directory as a module

[top](#topics)

We can use a file or directory as a module, and there are two ways to do it. 

The first one: 
 - Create a directory with the name we want for our module.
 - Create a file with name `mod.rs` inside that directory. This file will be our module's implementation.

![Image of a directory with mod.rs file](../static/images/mod-diretorios.png)

 In the above image, directory `a_module` with a `mod.rs` is our module.

The second one:
  - Create a Rust file with the same name as our module. This file is the module's implementation.

![Image of a directory with a Rust file that is also a module](../static/images/mod-diretorios2.png)

`internal_module.rs` is our module and the file contains the module's implementation.

---

## Using or Importing modules

[top](#topics)

You can import modules, functions, structs, traits and enums by using the `use` keyword.

Let's look at an example: below, we are bringing both `env` and `near_bindgen` from `near_sdk` (which happens to be a crate in this case) into scope. 

```rust
use near_sdk::{env, near_bindgen};
```
Just keep in mind that you actually don't have to use `use` (pun intended). If we wanted to, we could access `env` by writing `near_sdk::env` every time we needed it (meaning, write the full path).

---

### Aliases

[top](#topics)

We can use the `as` keyword to alias an import to another name:

```rust
use a_module::specific_module::hello as hello1;
```
There are a few `hello` functions in this example. Let's alias their names using the `as` keyword. In the above example, calling `hello1()` will be the same as calling `a_module::specific_module::hello()`.

---

### Public access

[top](#topics)

Let's see some ways to organize access to modules and functions:

```rust
pub use another_module::hello as hello2;
pub use yet_another_module::hello as hello3;
```

The above will bring both `hello` functions into scope, aliasing `hello2` and `hello3` while making them public; just as-if they were declared in this module. 

If we had a file `yet_another_module.rs` with:
```rust
mod internal_module;

pub use internal_module::a_deep_module::a_deep_function;
```
We are declaring `internal_module` exists and is private. However, we are also bringing `a_deep_function` into scope **and** making it public; and so, you can access this function using the path `yet_another_module::a_deep_function` without even knowing (or caring) that function resides in a completely different directory. 

Organize your modules (and directories) according to your project's needs, and then use `pub use` to export or make items available for external users. 

:hand: `pub use` and `pub mod` are used for public modules and crates when using them as libraries in other projects. These are language features and have no relation to NEAR contracts. 

:warning: Remember Rust changes often, so be sure to keep up-to-date. You can always check the docs for the [Rust Editions](https://doc.rust-lang.org/edition-guide/rust-2018/path-changes.html).

---

## Tests

[top](#topics)

NEAR has its own way to do testing which is different than Rust's tests; the former are more so integration tests while the latter are unit tests. This is because NEAR's tests are more about simulating interaction between different smart contracts on the blockchain.

---

### NEAR integration tests

[top](#topics)

The testing tool commonly used for testing NEAR Smart Contracts is called [workspaces-rs](https://github.com/near/workspaces-rs).

But just to complicate things, there's _also_ something called **workspaces** in Rust, but they are very different things. A [Workspace](https://doc.rust-lang.org/cargo/reference/workspaces.html) in Rust is a collection of one or more packages that share dependencies, target and other settings such as profiles.

Integration testing was done with the crate [near-sdk-sim](https://www.near-sdk.io/testing/simulation-tests), but this tool will deprecated in favor of the [sandbox](https://docs.near.org/docs/develop/contracts/sandbox).

---

### Rust integration tests

[top](#topics)

We usually declare our tests in the same file: 

```rust
#[cfg(test)]
mod tests{
    // load everything from this module
    use super::*;

    #[test]
    fn hello_test(){
```

But most of the time, we declare tests in their own directory and with their own file structure. 
We can create a directory `tests` alongside `src`.

![Image of root directory with directory "tests" highlighted](../static/images/testsdirectory.png)

We can then execute `cargo test`, and every `.rs` file will be treated as a test. All functions with an attribute of `#[test]` will be executed automatically. You can just place tests in `.rs` files, there's no need to create a `mod` for them. 

For our lesson, the directory `tests` acts as a separate crate. Let's import the `common` module found under `tests`, and bring it into scope in `contract.rs`.

```rust
mod common;

use common::env_setup;
```
To import modules in the same create, we can use the crate's name: 

```rust
use lesson_4_modules::Contract;
```

---

## Disable compiler warnings

[top](#topics)

Warnings are sometimes generated during compilation, but you can opt-out of them by using attributes before code: 

```rust
#[allow(unused)]
```
The above attribute would allow unused code to exist following the attribute and not generate a compiler warning.

However, you should always fix any compiler warnings and not ignore them. But here's an example when these attributes come in handy: the naming convention for JavaScript is to use `CamelCase`, while the naming convention for Rust is `snake_case`. If we are interacting with a contract using near-api-js, readability could be improved by using JavaScript's naming convention. 

```rust
#[allow(non_snake_case)]
pub fn ACamelCaseFunction() {    
```

We could also allow to ignore any warnings related to imports not being used:

```rust
#[allow(unused_imports)]
use near_sdk::{env, near_bindgen};
```
While these can sometimes be useful, **please** get into the habit of **fixing any warnings**, and do not ignore or hide them from the compiler by using attributes.

---

## Testing errors

[top](#topics)

We can also create tests that expect an error, and therefore testing in this manner guarantees that we are also taking care of any possible (expected) errors in our functions. 

```rust
    #[test]
    #[should_panic(expected = "A panic has just happened")]
    fn this_will_panic_test() {
        this_will_panic();
    }
```

The function above is **expected** to panic, and therefore when it does, our test passes.

On the flip side, if our functions doesn't panic or does so with a different message that the one we specified, our test will fail. 

---
Lesson 4 :white_check_mark: ... **Done! Congratulations!**

Our [next lesson](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/EN/lesson_5_macro_usage) will be about Rust's modules.
'''
'''--- EN/lesson_4_modules/src/a_module/mod.rs ---
//! Declaring modules:
//! Use a directory name for the module you want and put a mod.rs file in it, 
//! or create a .rs file with the same filename as the module you want
pub mod specific_module;

pub fn hello() -> String {
    String::from("Hello from crate::a_module")
}

'''
'''--- EN/lesson_4_modules/src/a_module/specific_module.rs ---
// Specifying (crate) after pub allows a function (or module, trait, etc) to be available to 
// other local modules (the same crate), but not to external crates
pub(crate) fn hello() -> String{
    String::from("Hello from crate::a_module::specific_module")
}

/// use the panic! macro to raise an error and halt/terminate the application
/// we can call panic! whenever we need it
pub fn this_will_panic() {
    panic!("A panic has just happened");
}

// cfg(test) tells the compiler these is a module with tests (test harness)
// and you can then use 'cargo test'
#[cfg(test)]
mod tests{
    // load everything 
    use super::*;

    #[test]
    fn hello_test(){
        // hello() is public for modules in the same crate
        // we'll try to import it from the test directory, which would cause an error
        // the test directory is its own crate
        assert_eq!(
            hello(),
            "Hello from crate::a_module::specific_module",
        );
    }

    #[test]
    // we can also test scenarios where an error is raised (panic)
    // and so we can ensure we panic for the right reason
    #[should_panic(expected = "A panic has just happened")]
    fn this_will_panic_test() {
        this_will_panic();
    }
}
'''
'''--- EN/lesson_4_modules/src/another_module.rs ---
pub fn hello() -> String {
    String::from("Hello from another_module")
}

// A função abaixo é privada.
// this is a private function
// #[allow(unused)] tells the compiler to ignore this 'unused code' warning (no warning)
// Comment #[allow(unused)] so the compiler raises a warning
#[allow(unused)]
fn this_is_private() -> String {
    String::from("This will never be used because it's private")
}

'''
'''--- EN/lesson_4_modules/src/lib.rs ---
//! This example focused on module management
//! 
//! 
//!
//! The search order for crates and modules is normally:
//! 
//!  - default (std), 
//!  - other crates (like near-sdk), 
//!  - crates in the workspace, 
//!  - local modules.
//!
//! 
//! 'mod modname' tells the compiler to compile files in the directory, or file, with that name
//! and to use bring into scope the module we then use the keyword 'use'
//! 
//! 'pub mod' allows other modules to access and use the module
//! 'pub use' works like the above (bring into scope)

// Here we declare there's a module called 'a_module' and it is public
// (which can be either a file with that name, or a directory with that name and a mod.rs file inside the directory)
pub mod a_module;
// Here we declare 'another_module' (in our example, a file called 'another_module.rs')
mod another_module;

// and one more file based module
mod yet_another_module;

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
#[allow(unused_imports)]
use near_sdk::{env, near_bindgen};

// we can use the 'as' keyword to alias functions
use a_module::hello as hello;
use a_module::specific_module::hello as hello1;

// and we can use 'pub use' to export function as public to external crates
pub use another_module::hello as hello2;
pub use yet_another_module::hello as hello3;

// the actual location (path) of 'a_deep_function' is 'yet_another_module::internal_module::a_deep_module::a_deep_function'
// but this full path is private. 
// however, remember we used 'pub use' for this function on 'yet_another_module' and so we can use that shorter path 
use yet_another_module::a_deep_function as hello4;

// uncomment the following line to get a compiler error (private access)
// use another_module::this_is_private;

pub use a_module::specific_module::this_will_panic;

near_sdk::setup_alloc!();

// this function will help to keep cleaner code
pub fn log(message: &str) {
    env::log(message.as_bytes());
}

#[near_bindgen]
#[derive(Clone, Default, BorshDeserialize, BorshSerialize)]
pub struct Contract {
    stored_phrase: String,
}

#[near_bindgen]
impl Contract{
    /// Returns the stored string value
    pub fn get_phrase(&self) -> String {
        self.stored_phrase.clone()
    }

    /// Logs "Hello from crate::a_module" and 
    /// stores that string value 
    pub fn hello(&mut self) {        
        self.stored_phrase = hello();
        log(&hello());
    }

    /// Logs "Hello from crate::a_module::specific_module" and 
    /// stores that string value 
    pub fn hello1(&mut self) {
        self.stored_phrase = hello1();
        log(&hello1());
    }

    /// Logs "Hello from another module" and 
    /// stores that string value 
    pub fn hello2(&mut self) {
        self.stored_phrase = hello2();
        log(&hello2());
    }

    /// Logs "Hello from yet_another_module" and 
    /// stores that string value 
    pub fn hello3(&mut self) {
        self.stored_phrase = hello3();
        log(&hello3());
    }

    /// Logs "Called a deep function" and 
    /// stores that string value 
    pub fn hello4(&mut self) {
        self.stored_phrase = hello4();
        log(&hello4());
    }

    /// this function will panic when called, with a message "A panic just happened"
    pub fn this_will_panic() {    
        this_will_panic();
    }
}

// Tests can be found in the 'tests' directory. This best practice helps with keeping our code organized. 

'''
'''--- EN/lesson_4_modules/src/yet_another_module.rs ---
// internal_module is private
// no access by external modules
mod internal_module;

// we export a_deep_function as public so other modules can access it
pub use internal_module::a_deep_module::a_deep_function;

pub fn hello() -> String {
    String::from("Hello from yet_another_module")
}

'''
'''--- EN/lesson_4_modules/src/yet_another_module/internal_module.rs ---
// export a_deep_module as public
pub mod a_deep_module;

'''
'''--- EN/lesson_4_modules/src/yet_another_module/internal_module/a_deep_module.rs ---
/// a public function found in a_deep_module
pub fn a_deep_function() -> String {
    String::from("Called a deep function")
}

'''
'''--- EN/lesson_4_modules/tests/another.rs ---
//! Each rust file in the tests directory will be run individually

// Uncomment the line below to get a 'private' warning from the compiler
// this happens because this module is public within the same crate, but 'tests' is its own crate
// use lesson_4_modules::a_module::specific_module::hello;

#[test]
fn oneplusone() {
    assert_eq!(1 + 1, 2);
}

'''
'''--- EN/lesson_4_modules/tests/common/mod.rs ---
use near_sdk::{
    AccountId,
    env,
    MockedBlockchain,
    testing_env,
    test_utils::VMContextBuilder,
    json_types::ValidAccountId,
};

pub fn env_setup(){
    let mut builder: VMContextBuilder = VMContextBuilder::new();

    // fields than can be set with the builder
    // current_account_id
    // signer_account_id
    // signer_account_pk
    // precessor_account_id
    // block_index
    // block_timestamp
    // epoch_height
    // account_balance
    // account_locked_balance
    // storage_usage
    // attached_deposit
    // prepaid_gas
    // random_seed
    // is_view

    let account_id: AccountId = String::from("stiltztinkerstein");

    builder.current_account_id(
        ValidAccountId::try_from(
            account_id.clone()
        ).unwrap()
    );

    testing_env!(builder.build());

    assert_eq!(
        env::current_account_id(),
        account_id, 
        "Assert Error. env: {} account: {}", 
        env::current_account_id(), 
        &account_id,
    );
}

'''
'''--- EN/lesson_4_modules/tests/contract.rs ---
//! This module tests the Smart Contract

// the 'common' module contains utility functions to be used in all our tests
mod common;

// The 'test' directory is its own crate, 
// So when we import our own modules we need to refer to them as
// "lesson_4_modules::" instead of "crates::"
use lesson_4_modules::Contract;

use common::env_setup;

#[test]
pub fn get_phrase() {
    env_setup();

    let contract: Contract = Contract::default();

    // we used derive(Default) in our contract
    // and the default for String is an empty string
    assert_eq!(contract.get_phrase(), "");
}

/// Assigns "Hello from crate::a_module" to phrase and test the value afterwards
#[test]
pub fn hello() {
    env_setup();

    let mut contract: Contract = Contract::default();

    contract.hello();

    assert_eq!(
        contract.get_phrase(),
        "Hello from crate::a_module",
    );
}

/// Assigns "Hello from crate::a_module::specific_module"  to phrase and test the value afterwards
#[test]
pub fn hello1() {
    env_setup();

    let mut contract: Contract = Contract::default();

    contract.hello1();

    assert_eq!(
        contract.get_phrase(),
        "Hello from crate::a_module::specific_module",
    );
}

/// Assigns "Hello from another_module"  to phrase and test the value afterwards
#[test]
pub fn hello2() {
    env_setup();

    let mut contract: Contract = Contract::default();

    contract.hello2();

    assert_eq!(
        contract.get_phrase(),
        "Hello from another_module",
    );
}

/// Assigns "Hello from yet_another_module"  to phrase and test the value afterwards
#[test]
pub fn hello3() {
    env_setup();

    let mut contract: Contract = Contract::default();

    contract.hello3();

    assert_eq!(
        contract.get_phrase(),
        "Hello from yet_another_module",
    );
}

/// Assigns "Called a deep function"  to phrase and test the value afterwards
#[test]
pub fn hello4() {
    env_setup();

    let mut contract: Contract = Contract::default();

    contract.hello4();

    assert_eq!(
        contract.get_phrase(),
        "Called a deep function",
    );
}

// We can also test error situations, known as 'panic'
// This function will raise an error (panic) with the message "A panic just happened"
// Our test checks if indeed panic happened, and will pass if this was the case
#[test]
#[should_panic(expected = "A panic has just happened")]
pub fn this_will_panic() {
    env_setup();

    // Embora não utilizemos o state, é bom inicializar antes de cada teste.
    let _contract: Contract = Contract::default();

    Contract::this_will_panic();
}

'''
'''--- EN/lesson_5_macro_usage/Cargo.toml ---
[package]
name = "lesson_5_macro_usage"
version = "0.1.0"
authors = ["Lucas Lemos <stiltztinkerstein@gmail.com>"]
license = "MIT"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- EN/lesson_5_macro_usage/Readme.md ---
# Lesson 5 - Macros

[back](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/EN/)

Macros are a fundamental tool if you want to be an effective Rust developer. While it is not necessary to learn how to create them, you definitely need to learn how to use them.

---

## Smart Contract API

```rust
/// This function shows the differences between println and env::log
/// Run `cargo test -- --nocapture`, compile, deploy and run in NEAR.
/// Note how some messages will show up and some will not. 
pub fn print_examples();

/// Format examples. Check the output depending on how it is implemented.
pub fn format_examples();

/// Panic examples.
pub fn panic_example();

/// Using Vec (vectors) examples
pub fn vec_examples();
```

## Topics

 - [What is a Macro?](#what-is-a-macro)
 - ["function-like" Macros](#"function-like"-macros)
 - [Advantages](#advantages)
 - [Disadvantages](#disadvantages)
 - [Useful Macros](#useful-macros)
   - [format, println and panic](#format-println-and-panic)
   - [Compound types](#compound-types)
   - [setup_alloc](#setup_alloc)
 - [Extra: String and str](#extra-string-and-str) 

---

## What is a Macro?

[top](#topics)

Quite simply, a **macro** is a tool run at compile time that generates code. They're part of something called _metaprogramming_, which helps you write less code, which in turn also decreases the amount of code you have to maintain down the road.

The annotation `derive` is a Macro: 

```rust
#[derive(Clone, Default, BorshDeserialize, BorshSerialize)]
pub struct Contract {
```
In this case, the `derive` annotation is used to apply a trait to new types. 

There's another type of Macro, in which you annotate types with "attributes":

```rust
#[near_bindgen]
impl Contract{
```

Finally, let's go over some "function-like" macros. As the name implies, these resemble a function call where you can even provide arguments. Some examples would be:

```rust
// Prints a string using the provided format pattern
println!("{}", message);

// Format arguments as a String
format!("7");

// Panic and provide an error message formatted to match the given pattern
panic!("Panic with arguments: {} {} {}", 1, second, 3);

// Creates a Vec with the the list of arguments
vec![1, 2, 3, 4];

// Create boilerplate code for Smart Contract
near_sdk::setup_alloc!();

// Used in Tests.
// Uses the builder argument to create a Context for the virtual machine environment
testing_env!(builder.build());

``` 
---

## "function-like" Macros

[top](#topics)

These macros are used like functions, but there are some differences between them. For one, they are more flexible since they can take an unknown number of arguments. 

Let's use `vec` to see another difference: 

```rust
vec![1, 2, 3, 4];
```
`Vec!` uses square brackets `[]` instead of parentheses `()`, but remember that macros also use curly brackets `{}` in their definition. Macros can use any type of text inside these delimiters, and a developer can pass anything as an argument as long as the macro implementation understands it. 

---

## Advantages

[top](#topics)

 - Simplifies code.
 - They're run at compilation time, so if they are well implemented, they are very efficient and carry little or no overhead. 

---

## Disadvantages

[top](#topics)

 - A developer need to take a close look at the documentation for each macro that is in the code. 
 - They can make debugging harder. 
 - They increase overall compilation time.
 - They can "blow up" your code base with "ghost" (invisible) code. 

---

## Useful Macros

Here are some macros we find very useful.

### `format!`, `println!` and `panic!`

[top](#topics)

 - `format!` returns a formatted String.
 - `println!` prints a String using a formatting pattern.
 - `panic!` stops execution and prints a String as an error message.

```rust
println!("This is println!, it wont show up in the virtual machine");

// We create a "message" variable of type String with a value of "format returns a formatted string."
let message: String = format!("remember format {}", "returns a formatted string");

// Stops execution with an error message "Panic with some arguments: 1 2 3"
let second = 2;
panic!("Panic with some arguments: {} {} {}", 1, second, 3);

```
Using these macros is quite simple: your first argument would be a formatting string, which includes placeholders "{}" for arguments you'll be providing as arguments later. 

You can customize string formatting in several ways, so be sure to learn more about [formatting](https://doc.rust-lang.org/std/fmt/index.html). Here are some examples:

```rust
// format Examples
log("\n\nformat_examples:\n");
 
let message: String = format!("Format returns a formatted string");

let an_arg = "third";

// format! can receive sequential arguments using {}. 
let message = format!("format can receive argument using {{}}: {}, {}, {}.", 1, "second", an_arg);

let (first, second, third) = (1, "second", an_arg);

// we can specify arguments by using their names
let message = format!("We can also specify argument by variable names: {first}, {second}, {third}.");

// we can also specify them by position
let message = format!("We can also specify them by position: {1}, {2}, {0}.", third, first, second);

let (first, second, third) = (1, 2, 3);
// we can also specify formatting options, in this case, number-formatting (digits)
let message = format!("We can specify digits for numbers: {:02}, {:04}, {:6}.", first, second, third);

// specifying position and number-formatting
let message = format!("And specify digits and ordering: {2:02}, {0:4}, {1:06}.", second, third, first);

let (first, second, third) = (0.1, 1.23, -2.45);
// we can also specify precision for floating points
let message = format!("We can specify precision for floating points: {:.2}, {:.4}, {:.6}", first, second, third);

// specify precision and number of digits
let message = format!("And specify precision and number of digits: {:2.2}, {:04.4}, {:06.6}", first, second, third);

// specify precision, number of digits and argument position
let message = format!("We can specify precision, digits and ordering of arguments: {1:02.2}, {2:4.4}, {0:06.6}", third, first, second);

// same as the previous one, but using argument names
let message = format!("Same as the previous one, but using argument names: {first:2.2}, {second:04.4}, {third:6.6}");

```

---

### Compound types

[top](#topics)

Let's go over some ways to group data (formally called compound types).

Tuples are fixed-length (they cannot grow or shrink):

```rust
// an integer tuple
// you can have different types for each of the tuple's elements
// tuples use ()
let a_tuple: (u32, u32, u32) = (0, 1, 4);

// we can access tuple values by index number
println!("The 2nd value is {}", a_tuple.1);
```

Arrays are also fixed-length, and are stored on the stack. 
Unlike tuples, every element of an array must have the same type.

```rust
// declaring an array
// arrays use []
let an_array = [0, 1, 2];

// we access array values using indices
// remember we start at 0
println!("The 3rd value is {}", an_array[2]);

// here we declare an array with 10 integers that have a default value of 0
let mut another_array: [i32; 10] = [0; 10];

// let's change the first element, at index 0
another_array[0] = -1;

// let's get the first element's value, which we changed from 0 to -1 above
println!("The first element's value is {}", another_array[0]);
```
Arrays and Tuples are primitive types, and always keep in mind that these are fixed length. If we needed more flexibility, we can use collections. We have Rust collections and NEAR collections; the former are a part of the language, while the latter are stored on a data structure called a ["trie"](https://en.wikipedia.org/wiki/Trie). You need to learn about Rust collections in order to come up with quality code and logic, and you need to learn NEAR collections to come up with the most efficient way to save state on the blockchain.

 - Learn about [Rust collections]((https://doc.rust-lang.org/std/collections/)).
 - Learn about [NEAR collections](https://docs.rs/near-sdk/latest/near_sdk/collections/index.html) (use these when developing Smart Contracts).

Probably the most useful (and used) collection in Rust is `Vec`. [Learn more](https://doc.rust-lang.org/std/vec/struct.Vec.html) about it. Using this type, we can store data, known as elements, count them, access and change them too. 

:hand: **NOTE:** lowercase `vec!` is a macro to generate vectors (note the ! at the end), while uppercase `Vec` is a type (a struct actually).

We can create a vector specifying explicit values: 
```rust
// Vec with integers 1 2 3 4
let example = vec![1, 2, 3, 4];
```

We can also create a vector specifying the default value and the quantity of elements we want:
```rust
// Vec with 5 elements, default value of 0, which is then vector [0, 0, 0, 0, 0]
let example = vec![0;5];
```
Formatting and printing values can be a bother, but Rust comes to our rescue by providing out-of-the-box solutions with Debug and Pretty-print formatting utilities that work with `println!`, `format!` and `panic!`. 

```rust
let example = vec![1, 2, 3, 4];

// using debug formatting
log(&format!("Let's print a vector with debug formatting:\n{:?}\n\n", example));
// using pretty-print formatting
log(&format!("Let's print it using \"pretty print\":\n{:#?}\n\n", example));

// using debug formatting
log(&format!("We can do the same with tuples:\n{:#?}\n\n", (1, 2, 3)));
// using debug formatting
log(&format!("Let's create vectors with default values:\n{:?}\n\n", vec![0;5]));
```

When you specify `{:?}`, that means apply debug formatting.
You can also use `{:#?}` for pretty-print formatting, which makes the values more legible. Most of the time pretty-print will output an element per line.

Feel free to learn more about [module std::fmt](https://doc.rust-lang.org/std/fmt/index.html), and deep dive into utilities for formatting and printing strings.

You can also learn more about implementing the [Debug trait](https://doc.rust-lang.org/std/fmt/trait.Debug.html) on structs or enums.

---

### setup_alloc

[top](#topics)

This macro needs to be placed prior to declaring a Smart Contract. Its will generate the boilerplate code needed for everthing to work. 

```rust
near_sdk::setup_alloc!();
```

:warning: **NOTE:** Starting from version 4.x of the NEAR SDK, this macro will be deprecated. However, adding the `setup_alloc!()` macro is needed for version 3.x.

---

## Extra: `String` and `str`

[top](#topics)

`String` e `str` are two very different types. `String` is a type which keeps ownership of a string, but `str` (known as a string slice), is commonly used to keep references to strings; this type exists to minimize string copies at runtime. 

:warning: **Remember:**
 - The `str` type will be used as `&str`. This applies to a "string like this one in quotes" but also `&String`.
 - Anytime you need a reference to a `String` in a function, use `&str` and not `&String`. 
 - String literals like "this one in quotes" are actually `&'static str`. If this looks complicated, don't worry, you'll learn all about this when we discuss Lifetimes. In theory, this type of strings will never be dropped from memory, but that behavior will actually depend on optimizations done by the compiler. 

--- 
Lesson 5 :white_check_mark: ... **Done! Congratulations!**

Our [next lesson](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/EN/lesson_6_enums) will be about Enums.

'''
'''--- EN/lesson_5_macro_usage/src/lib.rs ---
//! Examples for the following macros:
//! - format!
//! - println!
//! - panic!
//! - vec!
//! - setup_alloc!
//! 
//! 
//! 

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
#[allow(unused_imports)]
use near_sdk::{env, near_bindgen};

near_sdk::setup_alloc!();

/// This function is used in print_examples and compiled when test option is used.
#[cfg(test)]
pub fn log(message: &str) {
    println!("{}", message);
}

/// This function is used in print_examples and NOT compiled when test option is used.
#[cfg(not(test))]
pub fn log(message: &str) {
    env::log(message.as_bytes());
}

#[near_bindgen]
#[derive(Clone, Default, BorshDeserialize, BorshSerialize)]
pub struct Contract {
    // This smart contract doesn't have state
}

#[near_bindgen]
impl Contract{
    /// This function shows differences between println! and env::log
    /// Run with `cargo test -- --nocapture`, compile, deply and execute on NEAR
    /// You'll notice some of these will print out, but others will not
    pub fn print_examples() {
        log("\n\nprint_examples:\n");
        println!("This println! will not output in the virtual machine");
        let a = String::from("something");
        println!("Another println! with some arguments, {}, {}, {}", 1, "thingy", a);

        env::log(b"This is a log, it will not output in test.");
        env::log("another log".as_bytes());

        env::log(
            format!("A log with some arguments: {}, {}, {}", 1, 2, "3")
            .as_bytes()
        );

        log("A message that shows up in the virtual machine during when testing.");

        log(
            &format!("Another message with arguments, {}, {}, {}.",
                5,
                "6",
                format!("7"),
            )
        );
        
        log("\n\n---------------------------------------------------------------------------------\n\n");
    }

    /// examples for format!
    /// check the message output for each format! use
    pub fn format_examples() {
        log("\n\nformat_examples:\n");
        let message: String = format!("format returns a formatted string");
        log(&message);

        let an_arg ="third";
        let message = format!("format can receive argument using {{}}: {}, {}, {}.", 1, "second", an_arg);
    
        log(&message);

        let (first, second, third) = (1, "segundo", an_arg);
        let message = format!("We can specify arguments by variable name: {first}, {second}, {third}.");

        log(&message);

        let message = format!("We can specify the ordering of arguments for format: {1}, {2}, {0}.", third, first, second);

        log(&message);

        let (first, second, third) = (1, 2, 3);
        let message = format!("We can show integers with specified digits: {:02}, {:04}, {:6}.", first, second, third);
        log(&message);

        let message = format!("Specifying digits and argument ordering: {2:02}, {0:4}, {1:06}.", second, third, first);
        log(&message);

        let (first, second, third) = (0.1, 1.23, -2.45);
        let message = format!("Specify precision for floating points: {:.2}, {:.4}, {:.6}", first, second, third);
        log(&message);

        let message = format!("Specifying both precision and digits: {:2.2}, {:04.4}, {:06.6}", first, second, third);
        log(&message);

        let message = format!("Specify precision, digits and ordering of arguments: {1:02.2}, {2:4.4}, {0:06.6}", third, first, second);
        log(&message);

        let message = format!("Same as previous one but with variable names: {first:2.2}, {second:04.4}, {third:6.6}");

        log(&message);

        log("\n\n----------------------------------------------------------------------\n\n");
    }

    /// Example for panic!
    pub fn panic_example() {
        log("\n\npanic_example:\n\n\n");

        log("The panic! macro is used just like println! and format!");

        let second = 2;
        panic!("panic! with arguments: {} {} {}", 1, second, 3);

    }

    /// Example for vec!
    pub fn vec_examples() {
        log("\n\nvec_examples:\n");

        let example = vec![1, 2, 3, 4];

        log(&format!("Let's print a vector with debug formatting:\n{:?}\n\n", example));
        
        log(&format!("Let's print it using \"pretty print\":\n{:#?}\n\n", example));

        log(&format!("We can do the same with tuples:\n{:#?}\n\n", (1, 2, 3)));

        log(&format!("Let's create vectors with default values:\n{:?}\n\n", vec![0;5]));

        log("\n\n-------------------------------------------------------------------------------\n\n");
    }
}

// Run test with this command
// cargo test -- --nocapture --test-threads=1
//
//
// --nocapture will print everything as output, 
// Without --test-threads, all tests will run async and so output will be confusing
#[cfg(test)]
mod tests{
    use super::*;
    use near_sdk::{
        MockedBlockchain,
        testing_env,
        test_utils::VMContextBuilder,
    };

    fn env_setup(){
        let builder: VMContextBuilder = VMContextBuilder::new();
        testing_env!(builder.build());

        // our contract is stateless, we declare it but we don't use it
        let _contract: Contract = Contract::default();
    }

    #[test]
    pub fn print_examples() {
        env_setup();
    
        Contract::print_examples();
    }

    #[test]
    pub fn format_examples() {
        env_setup();
    
        Contract::format_examples();
    }

    #[test]
    pub fn vec_examples() {
        env_setup();
    
        Contract::vec_examples();
    }

    #[test]
    #[should_panic(expected = "Pânico com alguns argumentos: 1 2 3")]
    pub fn panic_example() {
        env_setup();

        Contract::panic_example();
    }
}

'''
'''--- EN/lesson_6_enums/Cargo.toml ---
[workspace]
members=[
    "lesson_6_1_simple", 
    "lesson_6_2_thermometer",
    "lesson_6_3_game_score"
]

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- EN/lesson_6_enums/Readme.md ---
# Lesson 6 - Enums

[back](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/EN/)

This lesson is sub-divided into four sessions. As each session will be a crate of its own, we will take the time to learn about workspaces and how to use them.

Here's a quick overview of sessions:
 - [Session 1 - Declaring and using Enums](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/EN/lesson_6_enums/lesson_6_1_simple/).
 - [Session 2 - Implementing a Thermometer using Enums](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/EN/lesson_6_enums/lesson_6_2_thermometer/).
 - [Session 3 - Pragmatic and Efficient error handling.](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/EN/lesson_6_enums/lesson_6_3_game_score/).
 
---

## Workspaces

A workspace is, quite simply, a directory shared by a set of packages. At compile time, all packages share the same target directory and Cargo.lock file, with each package compiling to a crate in that shared target directory. 

Here are some features of workspaces: 
 - Local dependencies: We create a package for our project, and then add packages our project depends on. 
 - Project management: we can compile and execute testing of all related packages and/or projects in one place. 
 - Smart Contract orchestration: A project usually has multiple smart contracts that handle different concerns (responsibilites). A workspace can include Smart Contracts in a test crate for testing cross-contract calls. There's such a test tool called [workspaces-rs](https://github.com/near/workspaces-rs) which can help you quite a lot when developing your own Smart Contracts.
 

---

## Cargo.toml
[top](#workspaces)

You need to add a special section called `[workspace]`.

```toml
[workspace]
members = [
    "lesson_6_1_simple",
]
```

`members` is a list of packages (projects) managed in this workspace.

:hand: **NOTE:** every package found in the workspace directory, will be included in the workspace. You can also leave packages out, using the `exclude` key in the `[workspace]` section. [Learn more](https://doc.rust-lang.org/cargo/reference/workspaces.html#the-workspace-section) about it. 

```toml
[workspace]
members = ["member1", "path/to/member2", "crates/*"]
exclude = ["crates/foo", "path/to/other"]
```
In the example above, we included 3 paths, and excluded 2. There's support for wildcards, called [globs](https://docs.rs/glob/0.3.0/glob/struct.Pattern.html) (or Unix shell style patterns), to match multiple paths. 

---

## Using the CLI with workspaces
[top](#workspaces)

If we execute the command `cargo build` and `cargo test` in a package that is a member of a workspace, that command will apply to all other packages that are members of that workspace. 

If we want to limit the command's execution to a single package, we can add the flag `-p` / `--package` or `--workspace` to the command. 

Let's test `lesson_6_1_simple` by running the following command:

```bash
cargo test -p lesson_6_1_simple -- --nocapture --test-threads=1
```

`--nocapture` will print all output.

`--test-threads=1` will run all tests in one thread, making the output legible.

Now, let's compile our package to our wasm target and a (fully optimized) **release** version, by running: 

```bash
cargo build -p lesson_6_1_simple --target wasm32-unknown-unknown --release
```
WASM (WebAssembly) files will be located in './lesson_6_enums/target/wasm32-unknown-unknown/release/'.

Finally, let's generate our documentation. Let's run: 
```bash
cargo doc --lib --document-private-items -p lesson_6_1_simple --open
```
This will generate all documentation, and open it in the default browser. 

 - `--lib` specifies this is a library.
 - `--document-private-items` generates documentation for all items.
 - `--open` will open the default browser pointing to the generated documentation. 

All documentation will be located in './target/doc/lesson_6_1_simple/index.html'.

---

Lesson 6 - Intro :white_check_mark: ... **Done! Congratulations!**

Let's move on to the next section to learn more about [declaring and using Enums](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/EN/lesson_6_enums/lesson_6_1_simple/).

'''
'''--- EN/lesson_6_enums/lesson_6_1_simple/Cargo.toml ---
[package]
name = "lesson_6_1_simple"
version = "0.1.0"
authors = ["Lucas Lemos <stiltztinkerstein@gmail.com>"]
license = "MIT"
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"

'''
'''--- EN/lesson_6_enums/lesson_6_1_simple/Readme.md ---
# Lesson 6 - Using Enums

[back](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/EN/lesson_6_enums/)

In this lesson, we will learn all about enums and the ```match``` keyword.

---

## Contract API

```rust
// /src/lib.rs

/// We can use this function to match Strings and string slices &str
/// return 1, 2, 3, 4, 5, if the parameter given is one of those values
/// otherwise, panic!
pub fn string_match_example(&self, arg: String) -> u32;

/// Returns example_0.
pub fn get_example_0(&self) -> Example0;

/// Returns example_1.
pub fn get_example_1(&self) -> Example1;

/// Returns example_2.
pub fn get_example_2(&self) -> Example2User;

/// Calls Example0::get_number.
pub fn example_0_get_number(&self) -> u32;

/// Calls Example0::is_third.
pub fn example_0_is_third(&self) -> bool;

/// Calls Example1::get.
pub fn example_1_get(&self) -> String;

/// Calls Example1::is_novalue.
pub fn example_1_is_novalue(&self) -> bool;

/// Calls Example1::get_an_integer.
pub fn example_1_get_an_integer(&self) -> String;

/// Calls Example1::has_an_odd_number.
pub fn example_1_has_an_odd_number(&self) -> bool;

/// Calls Example2User::get_name.
pub fn example_2_get_name(&self) -> String;

/// Calls Example2User::has_permission.
pub fn example_2_has_permission(&self, permission: String) -> bool;

/// Calls Example2User::get_actions.
/// 
/// When we return a Vec, the serialiyer will try to use serde::json.
/// Using #[result_serializer] allows to specify borsh as the serializer.
#[result_serializer(borsh)]
pub fn example_2_get_actions(&self) -> Vec<String>;
```

---

## Compiling and testing

This crate belongs to the Lesson 6 workspace. You can find how to compile and test it in the [intro page for the lesson](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/EN/lesson_6_enums/lesson_6_1_simple/).

:hand: **NOTE:**  All commands like `cargo test` and `cargo build` will affect all crates in the workspace, unless you provide a specific crate. 

---

## Topics

 - [What are enums](#what-are-enums)
 - [The `match` keyword](#the-match-keyword)
   - [String patterns](#string-patterns)
   - [`match` needs to match on all patterns](#match-needs-to-match-on-all-patterns)
   - [Using just one enum value](#using-just-one-enum-value)
 - [Enums that "box" values](#enums-that-box-values)
 - [Functions must specify return type](#functions-must-specify-return-type)
   - [Function is_no_value](#function-is_no_value)
   - [Function get_an_integer](#function-get_an_integer)
   - [Function has_an_odd_number](#function-has_an_odd_number)
 - [Usage scenario: user](#usage-scenario-user)
   - [Enums limit choices](#enums-limit-choices)
   - [Function get_name](#function-get_name)
   - [Function has_permission](#function-has_permission)
   - [Function get_actions](#function-get_actions)
   - [Choosing a serializer](#choosing-a-serializer)
 
---

## What are enums

[top](#topics)

While `Structs` are a type *composed* of other types, `Enums` are a type that can have only *one value at a time*. The values an enum can take are specified in its definition.

Here's an example of a simple `enum`:
```rust
pub enum Example0{
    First,
    Second,
    Third,
    Fourth,
    Fifth,
}
```
 - `pub` allows an enum to be used in external modules.
 - `Example0` is the name of the `enum`.
 - `First`, `Second`, `Third`, `Fourth` and `Fifth` are the actual values this `enum` can have. 

So now that we have declared an `enum`, how do we create an instance? Here's an example for each possible value: 

```rust
let a = Example0::First;
let b = Example0::Second;
let c = Example0::Third;
let d = Example0::Fourth;
let e = Example0::Fifth;
```
In order to check for a value, we could use `if | else` but Rust provide a much powerful tool. Let's learn about the `match` keywork next. 

---

## The `match` keyword

[top](#topics)
The `match` keyword allows to compare a value with all possible values for an enum.

```rust
// /src/model.rs
impl Example0{

    /// Check its assigned value and returns a number between 1 and 5.
    /// 
    /// Note the &self reference, meaning this function access its value 
    /// but it doesnt modify it (mutate)
    /// 
    pub fn get_number(&self) -> u32 {
        log("Calling Example0::get_number");

        // Here we match all possible enum values and 
        // return something, based on the enum value
        // remember: since this is the last statement of the function,
        // a return is implicit, you don't have to use the return keyword
        match self {
            Example0::First => {1},
            Example0::Second => {2},
            Example0::Third => {3},
            Example0::Fourth => {4},
            Example0::Fifth => {5},
        }
    }
```
The example above simply matches an enum value to a number, and returns the matching number (an integer in this case)

 - `Example0::First` returns 1;
 - `Example0::Second` returns 2;
 - `Example0::Third` returns 3;
 - `Example0::Fourth` returns 4;
 - `Example0::Fifth` returns 5;

`match` is similar a `switch` in other languages like C, Python, Java and Javascript, however, while `switch` compares for booleans, Rust's `match` compares against patterns.

---

### String patterns

[top](#topics)

We can use `match` on `String` and `&str`: 

```rust
// /src/lib.rs

impl Contract{
    /// We can use this function to match Strings and string slices &str
    /// return 1, 2, 3, 4, 5, if the parameter given is one of those values
    /// otherwise, panic!
    pub fn string_match_example(&self, arg: String) -> u32 {

        // treat &String as &str
        match &arg as &str {
            "1" => 1,
            "2" => 2,
            "3" => 3,
            "4" => 4,
            "5" => 5,
            value => panic!("Received {}. Must be 1, 2, 3, 4 or 5.", value),
        }
    }
```
In the example above, `match` goes over each pattern in order.
 - &arg is "1"? No.
 - &arg is "2"? No.
 - &arg is "3"? No.
 - &arg is "4"? No.
 - &arg is "5"? No.
 - `value` is a variable whose value will be any other value not matching the above cases.
 You can think of it as the last case in the match, which actually will match anything.
 Any string that isn't "1", "2", "3", "4" or "5", will be `value`, and so the function will panic.

---

### `match` needs to match on all patterns

[top](#topics)

On our first example, our enaum had 5 possible values. If you comment out one, the compiler will complain! (throw an error)

```rust
match self {
    Example0::First => {1},
    Example0::Second => {2},
    Example0::Third => {3},
    Example0::Fourth => {4},
    // if we comment the last possible value for the Example0 enum, 
    // the compiler will error out!
    // match needs to account for ALL possible values for the enum
    // Example0::Fifth => {5},
}
```

Our second examples compares a String. As a String can have basically any value, we need to have a 'last resort' case which matches 'any other value given', like so: 

```rust
value => panic!("Received {}. Must be 1, 2, 3, 4 or 5.", value),
```

You can have any variable name, it doesn't have to be `value`. It is also the case that sometimes you don't care for the actual value of the varibale but you **do** have to account for this 'whatever else' case when using `match`. In Rust, you'll see the underscore `_` being used as a variable name in those cases. Also, any variable that starts with an underscore `_` tells the compiler that we might not even use that variable later on (so the compiler will ignore its non-usage and not give you a *not used warning*, which is how it behaves by default). 

Let's say we write our `match` like this:

```rust
// /src/model.rs
pub fn string_match_example(&self, arg: String) -> u32 {

    match &arg as &str {
        "1" => 1,
        "2" => 2,
        "3" => 3,
        "4" => 4,
        "5" => 5,
        value => {
            // We are not using our value in panic! below
            // so the compiler will warn you that value is not being used
            panic!("Invalid value. Must be 1, 2, 3, 4 or 5.");
        },
    }
}
```
To avoid the warning, we just need to modify things a bit... by adding an underscore: 

```rust
// /src/model.rs
pub fn string_match_example(&self, arg: String) -> u32 {

    match &arg as &str {
        "1" => 1,
        "2" => 2,
        "3" => 3,
        "4" => 4,
        "5" => 5,
        _value => {
            // see? we added a _ , making it _value and not just value
            // we are STILL not using it in our panic! below
            panic!("Invalid value. Must be 1, 2, 3, 4 or 5.");
        },
    }
}
```

Do bear in mind that convention is imnportant, so we use "_" for patterns where we truly don't care about the 'whatever else' value: 

```rust
// /src/model.rs
pub fn string_match_example(&self, arg: String) -> u32 {

    match &arg as &str {
        "1" => 1,
        "2" => 2,
        "3" => 3,
        "4" => 4,
        "5" => 5,
        _ => {
            // see? we used the _ for anything
            panic!("Invalid value. Must be 1, 2, 3, 4 or 5.");
        },
    }
}
```

---

### Using just one enum value

[top](#topics)

Sometimes we have a function that only needs to do something based on just one case or value of our `enum`. We can also use `match`! 

In the following example, we only match `true` when our enum is `Example0::Third`. 

```rust
// /src/model.rs
/// true but checking only for Example0::Third
pub fn is_third(&self) -> bool {
    log("Calling Example0::is_third");

    match self {
        Example0::Third => true,
        _ => false,
    }
}
```

---

## Enums that "box" values

[top](#topics)

This is a powerful fact you need to keep in mind... in Rust, `enum` can also have different underlying types; all possible enum values don't have to be same type!

```rust
// /src/model.rs
pub enum Example1{
    NoValue,
    AnInteger(i32),
    AFloat(f32),
    AString(String),
    ATuple(i32, u32),
    ACLikeStruct{first: u32, second: String},
}
```
:hand: **NOTE:** Read the above carefully. We have primitive types (i32, f32, String) as `enum` choices, as well as tuples, **and** we can also have a C-like `struct`. All of these are part of one `enum`, `Example1`.

---

## Functions must specify return type

[top](#topics)

Functions that use enums can sometimes be difficult to implement, due to static typing. 

- Argument types must be specified.
- Return type must be specified.
 
That also includes generic functions. The compiler **must** know the argument types as well as the return type. Generic function are but a way to create function that also follow those rules.

For our enum, a developer might run into trouble with the compiler, since we have different underlying types for our enum choices (an integer, a string, a struct).
However, we can certainly implement functions! We just need to focus on thing: what type should we choose for our return value? 

In our case, let's choose a String:

```rust
// /src/model.rs

// Our method returns a String
pub fn get(&self) -> String {
    log("Calling Example1::get");

    match self{
        Example1::NoValue => String::from(""),
        Example1::AnInteger(value) => format!("{}", value),
        Example1::AFloat(value) => format!("{}", value),
        Example1::AString(value) => format!("{}", value),
        Example1::ATuple(value0, value1) => format!("({}, {})", value0, value1),
        Example1::ACLikeStruct { first, second } => format!("{{\nfirst: {},\nsecond: \"{}\",\n}}\n", first, second),
    }
}
```

`format!` is a macro that creates a String. We went over macros in [Lesson #5](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/EN/lesson_5_macro_usage/), so feel free to go back if you need a recap. Anyway, since we only want to print a value on screen, we can simply return a String.

In our lesson about Traits, we wil go over how to use borsh and serde. We use these to convert a struct into bytes, as well as convert from bytes or a string, into a struct (if they are compatible). In that lesson, we wil also cover how to use Generics, which allows to write functions that work for multiple types.

---

### Function is_no_value
[top](#topics)
Sometimes, we need to only check for one value. This function returns true if the enum value is `NoValue`.
```rust
// /src/model.rs
/// true if enum is Example1::NoValue.
pub fn is_no_value(&self) -> bool{
    log("Calling Example1::is_no_value");

    match self{
        Example1::NoValue => true,
        _ => false,
    }
}
```
---

### Function get_an_integer
[top](#topics)
Returns an integer if the enum's value is `Example1::AnInteger`.

```rust
// /src/model.rs
pub fn get_an_integer(&self) -> Option<i32>{
    log("Calling Example1::get_an_integer");

    match self{
        Example1::AnInteger(valor) => Some(valor.clone()),
        _ => None
    }
}
```
:hand: **NOTE:** if you looked at the code above you'll see the return value is actually something called an `Option`. We'll learn more about `Option` later on, but you can think of right now as an enum that *can* have a value, *or not*. If there is a value, you can retrieve it using `Some(value)` (where `value` is just a variable name), and if there is no value, then Option would be set to `None` (`Option::None`).
There is no **NULL** in Rust. 

By the way, take a look at this code:

```rust
match self {
```

Shouldn't this code be taking ownership of itself, and if not, why is that?

Well, that's because of how this argument is being passed:

```rust
pub fn get_an_integer(&self) -> Option<i32>{
```
As `&self` is being used, the compiler knows this value is just a reference (or borrow).

So, in summary:

```rust
match self{
    Example1::AnInteger(valor) => Some(valor.clone()),
    _ => None
}
```
The functions returns `Option<i32>` and therefore, our `match` must provide a return of either `Some(value)` or `None`. 

---

### Function has_an_odd_number

[top](#topics)
Returns true only if the argument is an odd integer.
Take a closer look at the code, since this is a more detailed usage scenario for `match`.

```rust
// /src/model.rs
/// Returns true only if the argument is an odd integer.
pub fn has_an_odd_number(&self) -> bool {
    log("Calling Example1::has_an_odd_number");

    match self {
        Example1::NoValue => false,
        Example1::AnInteger(valor) => {
            if valor%2 == 1{
                return true;
            }
                
            return false;
        },
        Example1::AFloat(_valor) => false,
        Example1::AString(_valor) => false,
        Example1::ATuple(valor0, valor1) => {
            return (valor0%2 == 1) || (valor1%2 == 1);
        },
        Example1::ACLikeStruct { first, second: _ } => {
            // we don't care about 'second' since it is a string
            first%2 == 1
        },
    }
}
```
So, the only alternatives that have integers are `Example1::AnInteger`, `Example1::ATuple` and `Example1::ACLikeStruct`. All other return false.

:warning: Variables starting with an underscore `_`, such as `_value` and `_`, hold **values** we don't really care about. The convention is to just an underscore `_`, but any variable names starting with an underscore will be ignored by the compiler when checking and raising any 'unused variable' warnings.

---

## Usage scenario: User

[top](#topics)
Let's see how we could use an enum in an application.

```rust
// /src/model.rs
pub enum Example2User {
    Admin { name: String, id: u32, pass: String, actions: Vec<String> },
    Client{ name: String, id: u32, orders: Vec<String> },
    Employee( Employee ),
}

pub struct Employee{
    pub name: String,
    pub id: u32,
    pub pass: String,
    pub permissions: Vec<String>,
    pub actions: Vec<String>,
}
```
We have three types of people who can access our system:
 - Employees: they can access the system and make limited modifications to data but can't alter business or system rules.
 - Admins: they have permissions to alter any business or system rules (basically do anything).
 - Clients: they can't change any system data, but are allowed to change their own data.
 
Employees, Admins and Clients are different types, and have different functions and data. But in the context of a User, they can be thought of in a similar manner.

You can group types using Enums but also Traits; however, consider that:
 - You use enums for grouping different types as a single concept or entity that will be used by a function.
 - You use traits for applying a single set of behaviors to different types. 

---

### Enums limit choices

[top](#topics)
Restricting choices can be good or bad depending on the case, so let's consider a few examples in order to get a grasp of the concepts.

Think about Chess. There are different pieces on the board, and so we made an enum for all the piece names:

```rust
// https://github.com/On0n0k1/NCD.L1--Chess/blob/main/src/pieces/piece.rs
pub enum Piece {
    BISHOP( Bishop ),
    EMPTY(  Empty  ),
    KING(   King   ),
    KNIGHT( Knight ),
    PAWN(   Pawn   ),
    QUEEN(  Queen  ),
    ROOK(   Rook   ),
}
```
Each piece has its own behavior, but the board itself doesn't care about it. However, the board does need to know each piece's possible movement in order to know if there's a check-mate. 

In this case, the restriction imposed by using enums is useful, since there are only so many piece types, plus one for empty space, and this will never change (so there won't be a need to add to the enum).

Enums are also useful for error handling. Let's think about an application used in a library. A function that retrieves information about a book could also return the following errors:

```rust
pub enum MessageError{
    BookNotFound(String),
    InvalidArg(String),
    MissingArg(String),
    NoPermission,
}
```
The errors are: 
 - `BookNotFound`: book not found, with the string being the name of the book that was not found.
 - `InvalidArg`: an argument was not recognized, with the string being the argument. 
 - `MissingArg`: a mandatory argument is needed but wasn't provided. The string is the required argument.
 - `NoPermission`: You don't have permission to access this book. Maybe the user is underage, and this book has adult content.

It becomes apparent that an advantage of restrictions imposed by enums is that a developer can well know all of the errors that can or should occur when calling a function.

---

### Function get_name

[top](#topics)
The function get_name of `Example2User` simply returns the 'name' of the user (which is a String). Remember, the underscores are values we choose to ignore. 

```rust
// /src/model.rs
/// returns the name of the user
pub fn get_name(&self) -> String {
    log("Calling Example2User::get_name");

    match self {
        Example2User::Admin { name, id: _, pass: _, actions: _ } => { name.clone() },
        Example2User::Client { name, id: _, orders: _ } => { name.clone() },
        Example2User::Employee( employee ) => { employee.name.clone() },
    }
}
```
Also, when there are multiple fields that have values you don't care about, you can simply use '`..`', like so: 
```rust
pub fn get_name(&self) -> String {
    log("Calling Example2User::get_name");

    match self {
        Example2User::Admin { name, .. } => { name.clone() },
        Example2User::Client { name, .. } => { name.clone() },
        Example2User::Employee( employee ) => { employee.name.clone() },
    }
}
```
---
### Function has_permission

[top](#topics)
Returns true if a user has permissions for an action in the application.
 - Admins always have all permissions granted.
 - Clients never have them.
 - Employees are granted permissions. Granted permissions are stored in a list.

:warning: Using String is never a good idea for permissions. This would be an ideal use case for enums, but we are doing it this way to keep complexity low.

```rust
// /src/model.rs
pub fn has_permission(&self, permission: String) -> bool{
    log("Calling Example2User::has_permission");

    match self{
        Example2User::Client { name: _, id: _, orders: _ } => { false },
        Example2User::Admin { name: _, id: _, pass: _, actions: _ } => { true },
        Example2User::Employee(employee) => {

            // Vec implements the Iterator trait, which means we have 
            // the .iter() function available to go over all 
            // value in the Vec, without needing to copy them
            for employee_permission in employee.permissions.iter(){
                if permission == *employee_permission {
                    return true;
                }
            }

            false
        }
    }
}
```
Employees have a `Vec` (vector) of strings where permissions are stored. We'll get to `Vec` when learn more about collections, but think of Vec (vector) as a modifiable list.

We already learned about `Clone` and `Copy`, so it is time to introduce [iterators](https://doc.rust-lang.org/std/iter/trait.Iterator.html) and iter(). This trait allows us to go over each value in a vector using `for`.

The `iter()` function generates a reference iterator. That means, that each `employee_permission` is a reference to an element contained in `Vec`. We **can't alter or modify** the values, but we also don't waste computing resources generating any copies of these values. 

Take a look at this code, and keep an eye out for the * operator:
```rust
if permission == *employee_permission {
    return true;
}
```
`employee_permission` is a &String (remember, iter() provides references) but we need to access the **actual** value of the string, not its reference. So, we use the * operator to *de-reference* the variable to get the actual value. 

Going back to the function, the argument `permission` will be compared to the permissions found in vec and if there's a match, the function returns true immediately. 

---

### Function get_actions

[top](#topic)
The function `get_actions` return a list of actions recently performed by the user. 

We'll use this function to introduce the `Result` enum, which we'll go in-depth in the next lesson, but for now think of `Result` as an action outcome that may have also caused an error. 

In our example, let's make this function return an error if the user is of type Client.

```rust
// /src/model.rs
pub fn get_actions(&self) -> Result<Vec<String>, String> {
    log("Calling Example2User::get_actions");
    
    // If Client, return an error.
    // If admin or employee, we can return a reference to the vec actions
    let actions = match self {
        Example2User::Client { name: _, id: _, orders: _ } => { 
                return Err(format!("User is Client")); 
        },
        Example2User::Admin { name: _, id: _, pass: _, actions, } => { actions },
        Example2User::Employee( employee ) => { &employee.actions },
    };

    // create an empty, but mutable vector
    let mut result: Vec<String> = Vec::new();
    // let's create a copy of Vec with the actions from our last match
    for action in actions {
        result.push(action.clone());
    }

    Ok(result)
}
```
:hand:**NOTE:** The function returns `Result<Vec<String>, String>`. The first type `Vec<String>` is what we choose to be the return of a sucessful outcome. The second type, `String`, is what we choose to return if there was an error (note we say error, not panic, they are very different). 

There's code to return an error, as a String (the second type): 
```rust
return Err(format!("User is Client"));
```

And there's code to return a `Vec<String>` if everything went OK:

```rust
Ok(result)
```
:warning: **REMEMBER:** `Result::Ok(value)` or simply `Ok(value)` is for a succesful outcome, and `Result::Err(err)` or just `Err(err)` is used when an error occurred. 
Also note that the variable names for these don't have to be `value` or `err`, that's just a convention when using `Result`.

---

:hand:**NOTE:** in our example we can't just return the found vec, as it is owned by the enum. So, we have to create a copy: 

```rust
let mut result: Vec<String> = Vec::new();

for action in actions{
    result.push(action.clone());
}
```

 - Create an empty `Vec<String>`. 
 - We iterate over the elements in the `actions` vec.
 - In each iteration, we create a copy of the element using `action.clone()`, and we append this to our new vec using `result.push();`.

---

### Choosing a serializer

[top](#topics)

Our `example_2_get_actions` function has something different about it, can you see it? 
```rust
// /src/lib.rs
#[result_serializer(borsh)]
pub fn example_2_get_actions(&self) -> Vec<String>{
```
I hope you spotted `#[result_serializer(borsh)]`. By using it, we're being explicit that we want to use `borsh` as our serializer for our function return. 

There are two options available for the near_sdk when it comes to serialization/deserialization: `serde` and `borsh`. If you want to use `serde`, then you need to implement the traits `Serialize` and `Deserialize` in your Smart Contract. However, if choosing `borsh`, you don't have to, and `borsh` has higher performance. 

Why not take a small detour from the lessons, and learn more about them? The best way is to read about [serialization protocols](https://www.near-sdk.io/contract-interface/serialization-interface) in the NEAR docs. 

---

Lesson 6 - Using Enums :white_check_mark: ... **Done! Congratulations!**

Let's put everything we've learned into developing an app on our [next lesson](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/EN/lesson_6_enums/lesson_6_2_thermometer/).
'''
'''--- EN/lesson_6_enums/lesson_6_1_simple/src/lib.rs ---
use near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize},
    serde::{Deserialize, Serialize},
};
#[allow(unused_imports)]
use near_sdk::{env, near_bindgen};

near_sdk::setup_alloc!();

mod model;

use model::{
    Example0,
    Example1,
    Example2User,
    log,
};

/// logs the function being called
pub fn log_call(name: &str){
    log(&format!("Calling {}", name));
}

#[near_bindgen]
#[derive(Clone, Default, BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Contract {
    example_0: Example0,
    example_1: Example1,
    example_2_user: Example2User,
}

#[near_bindgen]
impl Contract{
    /// We can use this function to match Strings and string slices &str
    /// return 1, 2, 3, 4, 5, if the parameter given is one of those values
    /// otherwise, panic!
    pub fn string_match_example(&self, arg: String) -> u32 {

        // Handle &String as &str
        return match &arg as &str {
            "1" => 1,
            "2" => 2,
            "3" => 3,
            "4" => 4,
            "5" => 5,
            value => panic!("Received {}. Must be 1, 2, 3, 4 or 5.", value),
        }
    }

    /// Returns example_0.
    pub fn get_example_0(&self) -> Example0 {
        log_call("get_example_0");
        self.example_0.clone()
    }

    /// Returns example_1.
    pub fn get_example_1(&self) -> Example1 {
        log_call("get_example_1");
        self.example_1.clone()
    }

    /// Returns example_2.
    pub fn get_example_2(&self) -> Example2User {
        log_call("get_example_2");
        self.example_2_user.clone()
    }

    /// Call Example0::get_number.
    pub fn example_0_get_number(&self) -> u32 {
        log_call("get_example_0_get_number");
        self.example_0.get_number()
    }

    /// Call Example0::is_third.
    pub fn example_0_is_third(&self) -> bool {
        log_call("get_example_0_is_third");
        self.example_0.is_third()
    }

    /// Call Example1::get.
    pub fn example_1_get(&self) -> String {
        log_call("get_example_1_get");
        self.example_1.get()
    }

    /// Call Example1::is_novalue.
    pub fn example_1_is_novalue(&self) -> bool {
        log_call("get_example_1_is_novalue");
        self.example_1.is_no_value()
    }

    /// Call Example1::get_an_integer.
    pub fn example_1_get_an_integer(&self) -> String {
        log_call("get_example_1_get_an_integer");
        let the_integer : Option<i32> = self.example_1.get_an_integer();

        match the_integer {
            Some(value) => {
                format!("{}", value)
            },
            None => {
                String::from("")
            }
        }
    }

    /// Calls Example1::has_an_odd_number.
    pub fn example_1_has_an_odd_number(&self) -> bool {
        log_call("get_example_1_has_an_odd_number");
        self.example_1.has_an_odd_number()
    }

    /// Calls Example2User::get_name.
    pub fn example_2_get_name(&self) -> String {
        log_call("get_example_2_get_name");
        self.example_2_user.get_name()
    }

    /// Calls Example2User::has_permission.
    pub fn example_2_has_permission(&self, permission: String) -> bool {
        log_call("get_example_2_has_permission");
        self.example_2_user.has_permission(permission)
    }

    /// Calls Example2User::get_actions.
    /// 
    /// 
    /// When returing vec, the default serializer is serde (serde::json).
    /// So let's be explicit about using borsh.
    #[result_serializer(borsh)]
    pub fn example_2_get_actions(&self) -> Vec<String>{
        log_call("get_example_2_get_actions");

        let result = self.example_2_user.get_actions();

        let result: Vec<String> = match result {
            Err(err) => panic!("Error: {}\n", err),
            Ok(value) => value,
        };

        result
    }
}

#[cfg(test)]
mod tests{
    use super::*;
    use near_sdk::{
        AccountId,
        env,
        MockedBlockchain,
        testing_env,
        test_utils::VMContextBuilder,
        json_types::ValidAccountId,
    };

    fn env_setup(){
        let mut builder: VMContextBuilder = VMContextBuilder::new();

        // attributes we can set with the builder:
        // current_account_id
        // signer_account_id
        // signer_account_pk
        // precessor_account_id
        // block_index
        // block_timestamp
        // epoch_height
        // account_balance
        // account_locked_balance
        // storage_usage
        // attached_deposit
        // prepaid_gas
        // random_seed
        // is_view

        let account_id: AccountId = String::from("stiltztinkerstein");

        builder.current_account_id(
            ValidAccountId::try_from(
                account_id.clone()
            ).unwrap()
        );

        testing_env!(builder.build());

        assert_eq!(
            env::current_account_id(),
            account_id, 
            "Assert Error. env: {} account: {}", 
            env::current_account_id(), 
            &account_id,
        );
    }

    #[test]
    fn string_match_example(){
        let (a1, a2, a3, a4, a5) = (
            String::from("1"),
            String::from("2"),
            String::from("3"),
            String::from("4"),
            String::from("5"),
        );

        env_setup();

        let contract = Contract::default();

        // string_match_example(&self, arg: String)
        assert_eq!(contract.string_match_example(a1), 1);
        assert_eq!(contract.string_match_example(a2), 2);
        assert_eq!(contract.string_match_example(a3), 3);
        assert_eq!(contract.string_match_example(a4), 4);
        assert_eq!(contract.string_match_example(a5), 5);
    }

    /// Test an error using argument with 0
    #[test]
    #[should_panic(expected="Received 0. Must be 1, 2, 3, 4 or 5.")]
    fn string_match_example_error(){
        env_setup();
        let contract = Contract::default();

        contract.string_match_example(String::from("0"));
    }
}
'''
'''--- EN/lesson_6_enums/lesson_6_1_simple/src/model.rs ---
use near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize},
    serde::{ Serialize, Deserialize },
};    

// As duas funções a seguir são declaradas para
// termos duas implementações diferentes de uma mesma função "log".
// As mensagens chamadas com essa função log aparecerão 
// em testes e na máquina virtual.

#[cfg(test)]
pub fn log(message: &str){
    println!("{}", message);
}

#[cfg(not(test))]
pub fn log(message: &str){
    near_sdk::env::log(message.as_bytes());
}

/// Um struct possui varios valores diferentes simultâneos, um enum só pode possuir um valor.
/// Os possiveis valores de um enum são descritos em sua declaração.
/// 
/// Os possiveis valores de Exemplo0 são:
///  - Example0::FIRST
///  - Example0::SECOND
///  - Example0::THIRD
///  - Example0::FOURTH
///  - Example0::FIFTH
/// 
#[derive(BorshDeserialize, BorshSerialize, Clone, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub enum Example0{
    First,
    Second,
    Third,
    Fourth,
    Fifth,
}

impl Default for Example0{
    fn default() -> Self {
        Example0::First
    }
}

// Similar to structs, let's implement some function on our enum Example0
impl Example0{

    /// Check its own value and returns a number from 1..5.
    /// 
    /// We use a reference &self, meaning we only access the value, not modify it
    /// 
    pub fn get_number(&self) -> u32 {
        log("Calling Example0::get_number");

        // and here we match enum choices/options to return values
        match self {
            Example0::First => {1},
            Example0::Second => {2},
            Example0::Third => {3},
            Example0::Fourth => {4},
            Example0::Fifth => {5},
        }
    }

    /// true if own enum value is set to Example0::Third
    pub fn is_third(&self) -> bool {

        log("Calling Example0::is_third");

        // match compares value in the order specified, 
        // and if assign a variable to a match, that variable will have the return value
        // of the match block.
        //
        // A variable starting with an underscore, is a variable whose value we don't care about
        // and that we will probably not be using later on
        //
        // So, a _ for our last case, as seen below, will match to anything else
        match self {
            Example0::Third => true,
            _ => false,
            // Exemplo0::SECOND => {
            //     // uncomment the above
            //     // and you'll get an error beause _ is above it 
            //     // and that means this SECOND enum option will never be reached
            //     false
            // },
        }
    }
}

/// An enum allows different typs to be grouped into a single concept or entity
/// 
/// This example shows that using enums for complex types (composability) is not really a good idea.
/// 
/// Function in enums should return simple results.
/// Having to 'extract' the underlying values in enums so they can be used only adds complexity.
/// 
/// Use enums to group different types that seem to share similar concepts.
/// 
#[derive(Clone, BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub enum Example1{
    NoValue,
    AnInteger(i32),
    AFloat(f32),
    AString(String),
    ATuple(i32, u32),
    ACLikeStruct{first: u32, second: String},
}

impl Default for Example1{
    fn default() -> Self {
        Example1::NoValue
    }
}

impl Example1{
    // Remember that functions must return one specific result type
    //
    // A developer might be tempted to create a get function to return the stored value but that 
    // can be difficult to implement.
    // 
    // The simplest way to go about it is to have your function convert enum options as needed into a single (common) return type
    // Here are some examples:
    //  - Return a value as a String
    //  - Use borsh or serde to serialize the value to bytes, to later deserialize after receiving the result
    //  - Implement generic. We'll go over this in a future lesson.
    //  - Return a "pointer"? There's a VERY low probability that is really necessary, and the complexity increases a lot.
    // 

    // Our function will return just a String type 
    pub fn get(&self) -> String {
        log("Calling Example1::get");

        match self{
            Example1::NoValue => String::from(""),
            Example1::AnInteger(valor) => format!("{}", valor),
            Example1::AFloat(valor) => format!("{}", valor),
            Example1::AString(valor) => format!("{}", valor),
            Example1::ATuple(valor0, valor1) => format!("({}, {})", valor0, valor1),
            Example1::ACLikeStruct { first, second } => format!("{{\nfirst: {},\nsecond: \"{}\",\n}}\n", first, second),
        }
    }

    /// true if enum is Example1::NoValue.
    pub fn is_no_value(&self) -> bool{
        log("Calling Example1::is_no_value");

        match self{
            Example1::NoValue => true,
            _ => false,
        }
    }

    /// Return an integer, if the enum value is that choice
    ///
    /// Option will be exlained in a future lesson. 
    ///
    /// Option is an enum of the std library.
    /// It means that we can have a value or not
    /// Option could be Option::Some(value) or Option::None.
    /// There's no NULL in Rust!
    pub fn get_an_integer(&self) -> Option<i32>{
        log("Calling Example1::get_an_integer");

        // value is a reference, so we clone the value to return an actual value and not a reference.
        match self{
            Example1::AnInteger(valor) => Some(valor.clone()),
            _ => None
        }
    }

    /// Returns true if the enum represents an odd number
    pub fn has_an_odd_number(&self) -> bool {
        log("Calling Example1::has_an_odd_number");

        match self {
            Example1::NoValue => false,
            Example1::AnInteger(valor) => {
                if valor%2 == 1{
                    return true;
                }
                    
                return false;
            },
            Example1::AFloat(_valor) => false,
            Example1::AString(_valor) => false,
            Example1::ATuple(valor0, valor1) => {
                return (valor0%2 == 1) || (valor1%2 == 1);
            },
            Example1::ACLikeStruct { first, second: _ } => {
                // We don't care about the second value, so we use an underscore
                first%2 == 1
            },
        }
    }
}

/// A simple struct with Default
/// 
#[derive(BorshDeserialize, BorshSerialize, Clone, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Employee{
    pub name: String,
    pub id: u32,
    pub pass: String,
    pub permissions: Vec<String>,
    pub actions: Vec<String>,
}

impl Default for Employee{
    fn default() -> Self {
        log("Calling Employee::default");

        Employee { 
            name: String::from("a name"), 
            id: 11, 
            pass: String::from("some random pass"), 
            permissions: vec![
                String::from("Can access google"),
                format!("Can access 9gag"),
            ], 
            actions: vec![
                String::from("Did something"),
                String::from("Did something else"),
            ],
        }
    }
}

/// A user for an application.
/// 
/// A user can be any of these three:
///  - Client
///  - Employee
///  - Administrator
/// 
/// We cantrol permission of each of them using enums
/// 
/// All have name and id, and each has in addition:
///  - Admin: password (encrypted) and  a list of action they can do in the app. 
///  - Employee: password (encrypted), a list of actions they can do and a list of permissions for the app.
///  - Client: only list of orders.
/// 
#[derive(BorshDeserialize, BorshSerialize, Clone, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub enum Example2User{
    Admin{ name: String, id: u32, pass: String, actions: Vec<String> },
    Client{ name: String, id: u32, orders: Vec<String> },
    Employee( Employee ),
}

impl Default for Example2User{
    fn default() -> Self {
        log("Calling Example2User::default");

        Example2User::Employee(Employee::default())
    }
}

impl Example2User{
    /// Returns the user name
    /// 
    /// The caller doesn't need to know the type of the user.
    pub fn get_name(&self) -> String {
        log("Calling Example2User::get_name");

        match self {
            Example2User::Admin { name, id: _, pass: _, actions: _ } => { name.clone() },
            Example2User::Client { name, id: _, orders: _ } => { name.clone() },
            Example2User::Employee( employee ) => { employee.name.clone() },
        }
    }

    /// Check if an user has a permission.
    /// 
    /// Having Strings to keep permissions is not a good idea, due to possible errors. A better choice would be enums
    /// 
    ///  - Clientes don't have permissions. Always return false.
    ///  - Administrators have all permissions (can do anything). Always returns true.
    ///  - Employees might have the permission. 
    /// 
    pub fn has_permission(&self, permission: String) -> bool{
        log("Calling Example2User::has_permission");

        match self{
            Example2User::Client { name: _, id: _, orders: _ } => { false },
            Example2User::Admin { name: _, id: _, pass: _, actions: _ } => { true },
            Example2User::Employee(employee) => {

                // Vec implement the Iterator trait, 
                // so we have the iter() function available.
                // This functions allows to iterate over references to strings,
                // but no copies are made while iterating 
                for employee_permission in employee.permissions.iter(){
                    if permission == *employee_permission {
                        return true;
                    }
                }

                false
            }
        }
    }

    /// Returns a list of actions for Admin or Employee. 
    /// 
    /// Result is similar to Option, but is used to provide more detail into the outcome while also accounting for errors
    pub fn get_actions(&self) -> Result<Vec<String>, String> {
        log("Calling Example2User::get_actions");
        
        // If user is Client, return error Err()
        // If user is Admin or Employee, return reference to Vec.
        let actions = match self{
            Example2User::Client { name: _, id: _, orders: _ } => { return Err(format!("User is Client")); },
            Example2User::Admin { name: _, id: _, pass: _, actions, } => { actions },
            Example2User::Employee( employee ) => { &employee.actions },
        };

        let mut result: Vec<String> = Vec::new();
        // Create a copy of vec, using references
        for action in actions{
            result.push(action.clone());
        }

        Ok(result)
    }
}

#[cfg(test)]
mod tests{
    // use std::result;

    use super::*;

    #[test]
    fn example0() {
        let first = Example0::First;
        let second = Example0::Second;
        let third = Example0::Third;
        let fourth = Example0::Fourth;
        let fifth = Example0::Fifth;

        assert_eq!(first.get_number(), 1);
        assert_eq!(second.get_number(), 2);
        assert_eq!(third.get_number(), 3);
        assert_eq!(fourth.get_number(), 4);
        assert_eq!(fifth.get_number(), 5);

        assert_eq!(first.is_third(), false);
        assert_eq!(second.is_third(), false);
        assert_eq!(third.is_third(), true);
        assert_eq!(fourth.is_third(), false);
        assert_eq!(fifth.is_third(), false);
    }

    // NoValue,
    // AnInteger(i32),
    // AFloat(f32),
    // AString(String),
    // ATuple(i32, u32),
    // ACLikeStruct{first: u32, second: String},

    /// Create some instance to test
    fn example1_create() -> (
        Example1,
        Example1,
        Example1,
        Example1,
        Example1,
        Example1,
    ){
        // Return a tuple with different types available
        (
            Example1::NoValue,
            Example1::AnInteger(10),
            Example1::AFloat(3.5),
            Example1::AString(String::from("A String")),
            Example1::ATuple(-5, 5),
            Example1::ACLikeStruct{first: 1, second: String::from("second")},
        )
    }

    #[test]
    /// Check for valid return strings
    fn example1_get(){
        let (
            no_value,
            an_integer,
            a_float,
            a_string,
            a_tuple,
            a_c_like_struct
        ) = example1_create();

        let no_value = no_value.get();
        let an_integer = an_integer.get();
        let a_float = a_float.get();
        let a_string = a_string.get();
        let a_tuple = a_tuple.get();
        let a_c_like_struct = a_c_like_struct.get();
        

        assert!(no_value.eq_ignore_ascii_case(""));
        assert!(an_integer.eq_ignore_ascii_case("10"));
        assert!(a_float.eq_ignore_ascii_case("3.5"));
        assert!(a_string.eq_ignore_ascii_case("A String"));
        assert!(a_tuple.eq_ignore_ascii_case("(-5, 5)"));
        assert!(a_c_like_struct.eq_ignore_ascii_case(&format!("{{\nfirst: 1,\nsecond: \"second\",\n}}\n")));
    }

    `   
    /// Check that only true is returned for no_value
    #[test]
    fn example1_is_novalue(){
        let (
            no_value,
            an_integer,
            a_float,
            a_string,
            a_tuple,
            a_c_like_struct
        ) = example1_create();

        let no_value = no_value.is_no_value();
        let an_integer = an_integer.is_no_value();
        let a_float = a_float.is_no_value();
        let a_string = a_string.is_no_value();
        let a_tuple = a_tuple.is_no_value();
        let a_c_like_struct = a_c_like_struct.is_no_value();

        assert_eq!(no_value, true);
        assert_eq!(an_integer, false);
        assert_eq!(a_float, false);
        assert_eq!(a_string, false);
        assert_eq!(a_tuple, false);
        assert_eq!(a_c_like_struct, false);
    }

    #[test]
    fn example1_get_an_integer(){

        fn asserting(value: Option<i32>, expected: Option<i32>){
            let comparison = match (value, expected){
                (None, None) => true,
                (Some(first), Some(second)) => first == second,
                _ => false,
            };

            assert_eq!(comparison, true, "Failed comparison between {:?} == {:?}\n", value, expected);
        }

        let (
            no_value,
            an_integer,
            a_float,
            a_string,
            a_tuple,
            a_c_like_struct
        ) = example1_create();

        let no_value = no_value.get_an_integer();
        let an_integer = an_integer.get_an_integer();
        let a_float = a_float.get_an_integer();
        let a_string = a_string.get_an_integer();
        let a_tuple = a_tuple.get_an_integer();
        let a_c_like_struct = a_c_like_struct.get_an_integer();

        asserting(no_value, None);
        asserting(an_integer, Some(10));
        asserting(a_float, None);
        asserting(a_string, None);
        asserting(a_tuple, None);
        asserting(a_c_like_struct, None);
    }

    // Admin{ name: String, id: u32, pass: String, actions: Vec<String> },
    // Client{ name: String, id: u32, orders: Vec<String> },
    // Employee( Employee ),

    /// Create 3 instances of Example2User for our tests
    fn example2_user_create() -> [Example2User; 3] {
        [
            Example2User::Admin { 
                name: String::from("Lucas"), 
                id: 0, 
                pass: String::from("12345"), 
                actions: vec![
                    String::from("Signed in 24 dec 2022, 06h33m49.67s"),
                    String::from("Logged off 24 dec 2022, 09h22m01.18s"),
                ]
            },
            Example2User::Employee(Employee {
                 name: String::from("Lucas"), 
                 id: 1, 
                 pass: String::from("123456"), 
                 permissions: vec![
                     String::from("Access client logs"),
                     String::from("Access stock"),
                 ], 
                 actions : vec![
                    String::from("Signed in 25 dec 2022, 08h11m32.01s"),
                    format!("Accessed Logs from {} {} {} {}, {:02}h{:02}m{:02}.{:02}s", "Lucas", 25, "dec", 2022, 09, 45, 19, 05),
                    String::from("Logged off 25 dec 2022, 11h44m51.92s"),
                ]
            }),
            Example2User::Client { 
                name: String::from("Lucas"), 
                id: 3, 
                orders: Vec::from([
                    format!("Successful transaction. ID: {}.", 4241235)
                ]) 
            }
        ]
    }

    #[test]
    fn example2_user_get_name(){
        // Create three users for testing below
        let [admin, employee, client] = example2_user_create();

        // destructure names into variables
        let (result_admin, result_employee, result_client) = (
            admin.get_name(),
            employee.get_name(),
            client.get_name(),
        );

        // check all names are OK 
        // we are comparing a String against a &str
        // because we implemented the trait partial_eq
        assert_eq!(result_admin, "Lucas");
        assert_eq!(result_employee, "Lucas");
        assert_eq!(result_client, "Lucas");
    }

    #[test]
    fn example2_has_permission(){
        // Create three users for testing below
        let [admin, employee, client] = example2_user_create();

        // Check if users have the log permission
        let (result_admin, result_employee, result_client) = (
            admin.has_permission(String::from("Access client logs")),
            employee.has_permission(String::from("Access client logs")),
            client.has_permission(String::from("Access client logs")),
        );

        assert_eq!(result_admin, true);
        assert_eq!(result_employee, true);
        assert_eq!(result_client, false);
    }

    #[test]
    fn example2_get_actions(){

        // helper function to compare vectors
        fn vec_eq(first: Result<Vec<String>, String>, second: Result<Vec<String>, String>) -> bool {
            let (first, second) = match (first, second) {
                (Err(first), Err(second)) => {
                    return first == second;
                },
                (Ok(first), Ok(second)) => {
                    (first.clone(), second.clone())
                },
                (_, _) => {
                    return false;
                }
            };

            // vectors must have the same number of elements
            assert_eq!(first.len(), second.len(), "len is different");

            let length: usize = first.len();

            for counter in 0..length {
                assert_eq!(first[counter], second[counter], "Failed comparison between {} and {}", first[counter], second[counter]);
            }

            return true;
        }

        // Create three users for testing below
        let [admin, employee, client] = example2_user_create();

        // get actions for each user
        let (result_admin, result_employee, result_client) = (
            admin.get_actions(),
            employee.get_actions(),
            client.get_actions(),
        );

        // check admin actions
        assert!(
            vec_eq(
                result_admin, 
                Ok(vec![
                    String::from("Signed in 24 dec 2022, 06h33m49.67s"),
                    String::from("Logged off 24 dec 2022, 09h22m01.18s"),
                ])
            )
        );

        // check employee actions
        assert!(
            vec_eq(
                result_employee,
                Ok(vec![
                    String::from("Signed in 25 dec 2022, 08h11m32.01s"),
                    format!("Accessed Logs from {} {} {} {}, {:02}h{:02}m{:02}.{:02}s", "Lucas", 25, "dec", 2022, 09, 45, 19, 05),
                    String::from("Logged off 25 dec 2022, 11h44m51.92s"),
                ]),
            )
        );

        // check client, and make sure it returns an error.
        assert!(
            vec_eq(
                result_client,
                Err(format!("User is Client")),
            )
        )

    }
}
'''
'''--- EN/lesson_6_enums/lesson_6_2_thermometer/Cargo.toml ---
[package]
name = "lesson_6_2_thermometer"
version = "0.1.0"
authors = ["Lucas Lemos <stiltztinkerstein@gmail.com>"]
license = "MIT"
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"

'''
'''--- EN/lesson_6_enums/lesson_6_2_thermometer/Readme.md ---
# Lesson 6 - Thermometer

[back](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/EN/lesson_6_enums/)

Time to build a Rust application with all of the concepts we have covered! We will also learn about: 

 - Project Documentation.
 - User Access Control.
 - Cross-Contract Calls.
 - Input Control.
 - Output Control.
 - Using Traits to convert types.

---

## Topics

 - [Overview](#overview)
 - [Pre-requisites](#pre-requisites)
   - [Rust](#rust)
   - [Visual Studio Code](#visual-studio-code)
   - [near-cli](#near-cli)
 - [Bash commands: compiling](#bash-commands-compiling)
   - [Documentation](#documentation)
   - [Tests](#tests)
   - [Creating a sub-account for the Smart Contract](#creating-a-sub-account-for-the-smart-contract)
   - [Creating sub-accounts for Sensors](#creating-sub-accounts-for-sensors)
   - [Deleting sub-accounts](#deleting-sub-accounts)
 - [Smart Contract](#smart-contract)
   - [Initialization](#initialization)
   - [Deployment](#deployment)
   - [allow_user](#allow_user)
   - [remove_user](#remove_user)
   - [set_format](#set_format)
   - [new_entry](#new_entry)
     - [Examples](#examples-new_entry)
   - [list_update_entries](#list_update_entries)
     - [Examples](#examples-list_update_entries)
   - [clear_entries](#clear_entries)
     - [Examples](#examples-clear_entries)
   - [view_get_format](#view_get_format)
   - [view_get](#view_get)
     - [Examples](#examples-view_get)
 - [Project Development](#project-development)
   - [Project Documentation](#project-documentation)
     - [File comments](#file-comments)
     - [Comments in code](#comments-in-code)
   - [Modules](#modules)
   - [User access control](#user-access-control)
   - [Cross-Contract calls](#cross-contract-calls)
   - [Handling Output](#handling-output)
   - [Handling Input](#handling-input)
   - [Implementing Traits](#implementing-traits)

---

## Overview

[top](#topics)
In our previous lesson, we learned about `enum` and how to use the `match` keyword. We can also use enums to handle I/O (input/output) of data.

Let's image we are an embedded developer working on a device that monitors temperature, and so we need input from several thermometers at the same time. We realized the following constraints: 

 - **Connecting** all devices to a single computer is impractical.  
 - **Keeping** a server up 24x7 receiving sensor data is also impractical.
 - **Have** a server up in the cloud is also impractical, because the developer doesn't want to pay a centralized entity (and give even **more** money to a billionarie).

So, the developer decides to create a smart contract to store the data. Some clear advantages are:

 - **Easy to implement**. The user only requires an account to store a smart contract, and so an account-per-sensor seems a good solution.
 - **Easy to automate**. The only thing that changes is the smart contract's name (per sensor). With a few scripts, a developer can have a fully working system in minutes.
 - **Easy to extend**. In this example we only focus on temperature readings but the smart contract can be easily changed to receive and save other data.

Now, does the contract only store data? There's no computation on the data received? Actually, computing could be made locally in the device, and there's no need to waste [gas](https://docs.near.org/concepts/basics/transactions/gas) on computing that can be done off-chain. Plus, there's a lot of libraries out there for data-science, no need to re-invent the wheel. 

:warning: **Always "think in gas" (gas usage) when it comes to on-chain data or computation**.

In summary, sensors send data to the smart contract, who stores on-chain the sensor name, temperature and date/time of the measurement. Then, any consumer (e.g. our own computer) can later on access on-demand this data from all contracts and do further processing and analysis. 

---

## Pre-requisites

[top](#topics)
 - Install Rust.
 - Download and Install Visual Studio Code.
 - Install near-cli.

### Rust
The easiest way to install Rust is to follow the steps in https://www.rust-lang.org/tools/install, where you'll find instructions for all major operating systems (even Windows Subsytem for Linux). There's also [other installation methods](https://forge.rust-lang.org/infra/other-installation-methods.html) available.

Once you have Rust installed, you'll need to add a target so you can compile to webassembly (WASM). Run the following command in your shell:

```bash
rustup target add wasm32-unknown-unknown
```
If you ever need to uninstall Rust, that's pretty easy too:
```bash
rustup self uninstall
```

### Visual Studio Code
 - Download and install from https://code.visualstudio.com
 - Once you have installed Visual Studio, add this extension to have additional tooling that will help you with Rust programming  https://marketplace.visualstudio.com/items?itemName=Zerotaskx.rust-extension-pack

:hand: **NOTE:** an old version of the extension mentioned above added a dependency (extension) called `rust` which has been deprecated in favor of `rust-analyzer`. You should always use `rust-analyzer` as it is kept up-to-date (and be sure **not** to have both `rust` and `rust-analyzer` installed and running!)

### near-cli
An npm-installable tool for interacting with the NEAR backend (RPC server). For near-cli to work, you need [node.js](https://nodejs.org/) and npm installed (npm is installed with node.js). If you need to learn more about node.js, be sure to visit their [guides](https://nodejs.org/en/docs/guides/), but in short, node.js is a javascript runtime environment (which lets you develop applications using javascript and run them outside of the browser as regular app). 

Once you have node (and npm) installed, you can install near-cli using npm: 

```bash
npm install -g near-cli
```
The `-g` option will install near-cli globally (for all users).

There's quite a lot of options that you **need** to learn in order to use near-cli, so be sure to [read the docs](https://docs.near.org/docs/tools/near-cli).

---

## Bash commands: compiling
[top](#topics)

You can compile the project using: 

```bash
cargo build --target wasm32-unknown-unknown --release -p lesson_6_2_thermometer
```
 - `--target wasm32-unknown-unknown`: Compile to webassembly.
 - `--release`: Output production-ready code; compile using most compiler optimizations.
 - `-p`: Remember this crate is part of the workspace defined as `lesson_6_enums`. Using the flag `-p` tells the compiler that only `lesson_6_2_thermometer` should be compiled.

---

### Documentation
[top](#topics)
Did you know you can generate documentation using cargo? This command will generate documentation (as a webiste) for all modules on this crate:

```bash
cargo doc --open -p lesson_6_2_thermometer
```
 - `-p`: Remember, you need to specify that only `lesson_6_2_thermometer` is the crate we want to generate documentation for.

---

### Tests

[top](#topics)
Execute tests (including those found in documentation) by running:

```bash
cargo test -p lesson_6_2_thermometer
```
Rust has a tool called `rustdoc` that extracts code samples from documentation comments and executes them. Learn more about [rustdoc](https://doc.rust-lang.org/rustdoc/) for more information on writing doc tests.

---

### Creating a sub-account for the Smart Contract

[top](#topics)
This is the account where the smart contract will be deployed. 

Let's use near-cli to create sub-accounts. Using the `near` command, you need to specify two options:
- your **existing** NEAR testnet account. So, replace `your-main-account.testnet` with **your testnet account name**.
- the name you want for the **new** sub-account where the smart contract will be deployed. So, replace `smart-contract-account-name` with the name you want.

```bash
near create-account smart-contract-account-name.your-main-account.testnet --masterAccount your-main-account.testnet --initialBalance 90
```
`--masterAccount`: master account, able to create sub-accounts. 
`--initialBalance`: amount of NEAR to be transferred to the sub-account from the master account. If you don't specify an amount, 100 NEAR will be sent from the master account. 

If you need a refresher about accounts on NEAR, be sure to [read the docs](https://docs.near.org/concepts/basics/account) once more.

---

### Creating sub-accounts for Sensors

[top](#topics)
We won't deploy any contracts to these sub-accounts but they will be used to sync with the master account.

You need to replace:

 - `sensor-sub-account`: account name for the sensor.
 - `smart-contract-account-name`: account name where the smart contract will be deployed.
 - `your-main-account`: master account name.

```bash
near create-account sensor-sub-account.smart-contract-account-name.your-main-account.testnet --masterAccount smart-contract-account-name.your-main-account.testnet --initialBalance 10
```
`--masterAccount`: master account, able to create sub-accounts. 
`--initialBalance`: amount of NEAR to be transferred to the sub-account from the master account. If you don't specify an amount, 100 NEAR will be sent from the master account. 

---

### Deleting sub-accounts

[top](#topics)
You need to delete sensor sub-accounts prior to deleting the smart contract account. You specify the account to delete, and also the account that will receive any NEAR found on the account to be deleted.

```bash
near delete sub-account-to-delete.testnet receiver-beneficiary.testnet
```

 - `sub-account-to-delete.testnet`: account name to delete
 - `receiver-beneficiary.testnet`: account name to receive any funds from the deleted account. If you specify an invalid name, any funds from the deleted account will be distributed among validators.

---

## Smart Contract
[top](#topics)

Before reviewing the code, keep in mind that just after being deployed, the only user than can "call" functions in the smart contract is its **owner** (the account where you deployed it). So, you need to specify that account for the first calls. 

Other users (sensors) can, and will, later be included on a list of allowed users, so that each user (sensor) will have their own data storage. 

---

### Initialization

[top](#topics)

The contract initializes using Kelvin (as temperature unit) and only a single user (the owner).

---

### Deployment
[top](#topics)

Deploy your contract to NEAR's testnet by running: 
```bash
near deploy --accountId smart-contract-account-name.your-main-account.testnet --wasmFile .\target\wasm32-unknown-unknown\release\lesson_6_2_thermometer.wasm
```
:hand: **NOTE:** depending on how you built your project, the path to the _.wasm_ file might be different on your machine. 

:warning: Remember that the account where you'll deploy your contract to has to have enough NEAR for storage. Read about [storage staking](https://docs.near.org/concepts/storage/storage-staking).

---

### add_user

[top](#topics)

```bash
near call my-contract add_user '{"account_id": "sensor-account-id.testnet"}' --accountId my-contract

```
Adds the specified user to the list of allowed users. Only the owner can call this function, and it cannot be used cross-contract.

Parameters:
 - account_id: String. Account name to add to the allowed user list.

Panics:
 - If cross-contract call.
 - If caller is not the owner.
 - If account name is invalid.
 - If account name already exists.

---

### remove_user

[top](#topics)

```bash
near call my-contract remove_user '{"account_id": "sensor-account-id.testnet"}' --accountId my-contract
```
Remove the specified user from the list of allowed users, all data stored for this user will be lost. You can't remove the owner. Only the owner can call this function, and it cannot be used cross-contract.

Parameters:
 - account_id: String. Account name to remove from the allowed user list.

Panics: 
 - If cross-contract call.
 - If the caller is not the owner.
 - If account name is invalid.
 - If account name doesn't exist.
 - If acount name to remove is the owner.

---

### set_default_temperature_unit

[top](#topics)

```bash
near call my-contract set_default_temperature_unit '{"unit_name": "Fahrenheit}' --accountId my-contract
```

```bash
near call my-contract set_default_temperature_unit '{"unit_name": "Kelvin}' --accountId my-contract
```

```bash
near call my-contract set_default_temperature_unit '{"unit_name": "Celsius}' --accountId my-contract
```
Changes the default temperature unit (Fahrenheit, Kelvin, Celius), but it will not update/convert any values previously stored.

All temperature readings are converted into an internal system unit (the default). That allows sensors with different temperature units to simply send their measurements. Only the owner can call this function, and it cannot be used cross-contract.

 - The **call** function `list_update_entries` converts all stored values to the new default temperature unit.
 - The **view** function `view_get` returns all stored values.

Panics:
 - If account name is invalid.
 - If cross-contract call.
 - If the caller is not the owner.

---

### new_entry

[top](#topics)

This **call** function stored a new temperature measurement from any allowed user (can be cross-contract call too). 

Parameters:
 - **time**: optional. A tuple `(u8, u8, f32)` representing hour, minute and second. If ommited, the default value will be the current time (UTC) when the function was called.
 - **date**: optional. A tuple `(i32, String, u8)` representing year, month and day. If ommited, the default value will be the current date when the function was called.
 - **temp_value**: A `f32`, which is the measured temperature value, which cannot be less than absolute zero. 
 - **temp_format**: Optional. A `String`, representing the temperature unit. If ommited, the default system unit will be used. If the unit is different to the default system unit, a conversion will be made to the default system unit prior to storing.

#### Examples new_entry

[top](#topics)

Store a new measurement of 100 using the default system temperature unit, and current date and time:
```bash
near call my-contract new_entry '{"temp_value": 100 }' --accountID my-sensor-id
```

Store a new measurement of 100 degrees Celsius, using the current date and time:
```bash
near call my-contract new_entry '{"temp_value": 100, "temp_format": "Celsius"}' --accountID my-sensor-id
```

Store a new measurement of 50.5 degrees Fahrenheit, using the provided date and the current time:
```bash
near call my-contract new_entry '{"temp_value": 50.5, "temp_format": "Fahrenheit", "date: [2022, "feb", 11]"}' --accountID my-sensor-id
```

Store a new measurement of 11.5 degrees Fahrenheit, using the provided date and the provided time:

```bash
near call my-contract new_entry '{"temp_value": 11.5, "temp_format": "f", "date": [2018, "mar", 27], "time": [10, 50, 9.3453]}' --accountID my-sensor-id
```

Store a new measurement of -45.4 degrees Celsius, using the current date and the provided time:

```bash
near call my-contract new_entry '{"temp_value": -45.4, "temp_format": "c", "time": [23, 41, 4.443]}' --accountID my-sensor-id
```

O comando abaixo armazena uma temperatura de 44.13 Kelvin. Horário do recebimento da mensagem. Data atual do recebimento da mensagem.

```bash
near call my-contract new_entry '{"temp_value": 44.13, "temp_format": "kelvin"}' --accountID my-sensor-id
```

### list_update_entries

[top](#topics)

This **call** fuction returns all temperature readings (measurements) for a specified account, converting to the default temperature unit, if needed.

All allowed users can access their own data, but only the owner can access other user's data. This restriction is in place to keep in check gas usage. Any user or account can still take advantage of **view** functions to gather all data. 

Parameters:
 - account_id: Optional. A `String` representing the account to retrieve data for. If not specified, it will return data for the caller account.

**Returns**: A `Vec` with all temperature readings (measurements) associated with a user.

#### Examples list_update_entries

[top](#topics)

This will return all temperature readings associated with the user (account) "my-sensor-id":

```bash
near call my-contract list_update_entries '{}' --accountID my-sensor-id
```

This will return all temperature readings associated with another user (specified with account_id). Only the owner can call retrieve data for another user:

```bash
near call my-contract list_update_entries '{"account_id": "my-sensor-id.testnet"}' --accountID my-contract
```

#### Panic list_update_entries

[top](#topics)

 - If the user is not on the allowed user list.
 - If the user is not owner and is trying to update other user's data.
 - If the user is not found.

---

### clear_entries

[top](#topics)

This **call** function clears all user data (temperature readings) for a user. Can be cross-contract call and only the owner can call this function.

The reason this function can be cross-contract is to make it easier for automation. Other contracts can't add or remove users, but they can add temperature readings and collect user data.

Users don't have permissions to use this function in order to increase security. If one sensor was hacked, the hacker would only have the most limited functionality. Sensors only exist to provide temperature readings. 

#### Parameters clear_entries

[top](#topics)

 - **account_id**: Optional. A `String`, representing the account to remove data from. If ommited, **all data for the owner** will be removed.

#### Examples clear_entries

[top](#topics)

This will remove all temperature readings (measurements) associated with the user "my-sensor-id".

```rust
near call my-contract clear_entries '{"account_id": "my-sensor-id.testnet"}' --accountID my-contract
```

#### Panic clear_entries

[top](#topics)

 - If user is not the owner.
 - If account is not found.

---

### view_get_format

[top](#topics)

A **view** function. Returns a `String` representing the default temperature unit.

```bash
near view my-contract view_get_format '{}'
```

--- 

### view_get

[top](#topics)

A **view** function. Returns temperature readings (measurements) associated with an account.

:hand: **NOTE:** this is a **view** function and so there's not gas involved. However, it can still return two different result types. Take a look at `ViewGet` in `./src/utils.rs`.

```rust
#[derive(Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
#[serde(untagged)]
pub enum ViewGet{
    Single(TemperatureReading),
    Multiple(Vec<TemperatureReading>),
}
```
Let's take a closer look at the declaration:
 - serde is used for JSON serialization and deserialization.
 - `#[serde(untagged)]` allows not using an explicit JSON tag for a type, and so we can have any type of variant in the enum. In our enum `ViewGet`, we can then have two variants:`Single(TemperatureReading)` and `Multiple(Vec<TemperatureReading>)`. 
 
 Learn about serde's [enum representations](https://serde.rs/enum-representations.html), or specifically more about [untagged](https://serde.rs/enum-representations.html#untagged).

This is a way to allow the developer to take advantage of enums to simply focus on getting a result.

:hand: **NOTE:**: this example was just made this way to show the possibility of returning different variants as a result. It could lead to increasing system complexity!

#### Parameters view_get

[top](#topics)

 - index: u64. Optional. The index for the temperature reading to return. If omitted, return all temperature readings. 
 - account_id: A `String` representing the account that has associated temperature readings to return.

#### Examples view_get

[top](#topics)

This will return the first (with an index of 0) temperature reading, if found, associated with the account "sensor-id":

```bash
near view my-contract view_get '{"index": 0, "account_id": "sensor-id.testnet"}'
```
This will return all temperature readings associated with the account "sensor-id":

```bash
near view my-contract view_get '{"account_id": "sensor-id.testnet"}'
```

---

## Project Development

[top](#topics)

In this section, let's explain how we developed this project by going over a checklist:

 - Project documentation.
 - Module organization.
 - Access control for users.
 - Cross-contract calls.
 - Handling input;
 - Handling output;
 - Implemmenting Traits.

---

### Project documentation

[top](#topics)
In order to create documentation, we can take advantage of `cargo` by running: 

```bash
cargo doc --open --lesson_6_2_thermometer
```
This will create a website with all documentation for our project.

However, there are some rules we need to follow. Let's go over them next:

#### File comments
Use `//!` at the beginning of files for module-level documentation.

Here's an example from our `Day` module, found in `./src/schedule/date/day.rs`.

```rust
//! Module with all functions related to a day
//! 
//! We use an u8 for the day, but we also need to 
//! check the day is valid. So, we'll need to make
//! day a struct Day(u8).
//! 
//! When serialized to JSON, the value would just be
//! an u8, so there won't be any additional complexity
//! for the user.
```
These comments should be a summary of module functionality and features.

#### Comments in code
Comments in code `//` are not included in the generated documentation. 
Comments using `///` are used to describe types following them.

As an example, here's the code for the function `Day::assert_valid` which is a private function:
```rust
/// # Panics
/// - if day is invalid
fn assert_valid(&self, current_month: &Month, current_year: &Year) {
    let &Day(day) = self;

    let mut current_year: i32 = current_year.get();

    // Se for negativo, converte para positivo
    if current_year < 0 {
        current_year = -current_year;
    }

    // true if "leap year".
    let leap_year: bool = (current_year % 4) == 0;
    // convert true = 1, false = 0.
    let leap_year: u8 = leap_year as u8;

    // source: https://www.rapidtables.com/calc/time/months-of-year.html
    let max_day: u8 = match current_month {
        &Month::January(_) => 31,
        &Month::February(_) => 28 + leap_year,
        &Month::March(_) => 31,
        &Month::April(_) => 30,
        &Month::May(_) => 31,
        &Month::June(_) => 30,
        &Month::July(_) => 31,
        &Month::August(_) => 31,
        &Month::September(_) => 30,
        &Month::October(_) => 31,
        &Month::November(_) => 30,
        &Month::December(_) => 31,
    };

    // check if day is within valid range
    assert!(day <= max_day,
        "Invalid values for day. Day: {}, Month: {}, Year: {}. Day for given month and year can not be higher than {}.",
            day,
            current_month,
            current_year,
            max_day,
    )
}
```
Comments using `//` provide insight into how the code is implemented, and they will not be included in the generated documentation.

Comments using `///` provide more information on the function's behavior. Here, we see the function can panic if the 
day is invalid. 

A seguir há um exemplo da função ```Month::new``` no caminho ```./src/entry/schedule/month/Month.rs```.

```rust
/// Create a month instance.
/// 
/// All possible values on the left are converted
/// to an enum value on the right:
/// 
///  - "january", "jan", "janeiro", "enero", "ene" => Month::January("January")
///  - "february", "feb", "fevereiro", "fev", "febrero" => Month::February("February")
///  - "march", "mar", "março", "marzo" => Month::March("March")
///  - "april", "apr", "abril", "abr" => Month::April("April")
///  - "may", "maio", "mayo" => Month::May("May")
///  - "june", "jun", "junho", "junio" => Month::June("June")
///  - "july", "jul", "julho", "julio" => Month::July("July")
///  - "august", "aug", "agosto", "ago" => Month::August("August")
///  - "september", "sep", "setembro", "set", "septiembre" => Month::September("September")
///  - "october", "octo", "oct", "outubro", "out", "octubre", "octu" => Month::October("October")
///  - "november", "nov", "novembro", "noviembre" => Month::November("November")
///  - "december", "dec", "dezembro", "dez", "diciembro", "dic" => Month::December("December")
/// 
/// # Panics
/// - if an invalid argument is provided. Month name is not valid.
/// 
pub fn new(month: &str) -> Self {
    let lower_case: String = month.to_ascii_lowercase();
    
    match &lower_case[..] {
        "january" | "jan" | "janeiro" | "enero" | "ene" => Month::January(String::from("January")),
        "february" | "feb" | "fevereiro" | "fev" | "febrero" => Month::February(String::from("February")),
        "march" | "mar" | "março" | "marzo" => Month::March(String::from("March")),
        "april" | "apr" | "abril" | "abr" => Month::April(String::from("April")),
        "may" | "maio" | "mayo" => Month::May(String::from("May")),
        "june" | "jun" | "junho" | "junio" => Month::June(String::from("June")),
        "july" | "jul" | "julho" | "julio" => Month::July(String::from("July")),
        "august" | "aug" | "agosto" | "ago" => Month::August(String::from("August")),
        "september" | "sep" | "setembro" | "set" | "septiembre" => Month::September(String::from("September")),
        "october" | "octo" | "oct" | "outubro" | "out" | "octubre" | "octu" => Month::October(String::from("October")),
        "november" | "nov" | "novembro" | "noviembre" => Month::November(String::from("November")),
        "december" | "dec" | "dezembro" | "dez" | "diciembre" | "dic" => Month::December(String::from("December")),
        invalid => panic!("Invalid value for month: {}.", invalid),
    }
}
```
The documentation above the function has a lot of details; the reason being that not only users need information about what the function does and the arguments it needs, but also to inform developers how they can change or modify the function to extend to other use cases.

---

### Modules

[top](#topics)

Modules in Rust can be a bit confusing... some directories have a `mod.rs` file while others do not. That's just because there is more than one way to declare a module in Rust. 

You declare a Rust module by either:
 - A rust file with a matching directory name on the level.
 - Having a `mod.rs` file inside a directory.

Examples:

 - Module `entry` is located in ```./src/entry/mod.rs```
 - Module `temperature` is defined by ```./src/temperature/mod.rs```
 - Module `date` is located in ```./src/schedule/date.rs```, inside a directory on the path ```./src/schedule/```
 - Module `time` is located in ```./src/schedule/time.rs```, inside a directory on the path ```./src/schedule/```

Learn more about [module organization](https://aloso.github.io/2021/03/28/module-system.html).

---

### User access control

[top](#topics)

Function calls needs to be mde from a NEAR account. We can control access by checking for the account's name who made the call. When the contract is initialized, only the owner can make calls. Additional accounts can be included using the function `Contract::add_user`. 

Each account we add does not have admin permissions, but they do have some storage space for data. It will also have the permission to add new entries, as well as the permission to update their values. 

A reason for limiting access by account is due to the possibility of a bad actor gaining acesss to a device and using them to also access the smart contract. If this happens, with the security put in place, that bad actor could only include new entries or update the values, which are very limited actions due to the amount of gas they spend for an account related to a sensor. 

Functions that control access are private functions: 
 - ```Contract::assert_owner_only```: panics if the caller is not the owner; the owner is the account that was used to deploy the smart contract.
 - ```Contract::assert_user_allowed```: panics if the caller is not a user in the allowed user list. Owner is, of course, on the allowed user list.

```rust
// assert the owner is the caller
fn assert_owner_only(&self){
    let predecessor: AccountId = env::predecessor_account_id();
    let owner_id: AccountId = AccountId::from(env::current_account_id());

    assert_eq!(predecessor, owner_id, "Only owner's account is allowed to make this function call.");
}

// check user permissions
fn assert_user_allowed(&self) {
    let predecessor_id: AccountId = env::predecessor_account_id();
    let owner_id: AccountId = env::current_account_id();

    // is the caller the owner? call assert_owner_only
    if owner_id == predecessor_id {
        return;
    }

    // check if user is in the allowed list
    assert!(self.users.contains(&predecessor_id), "User not allowed to make this call.");
}
```

The module `near_sdk::env` provides all the information related to the virtual machine's environment as well as all the message details. Here's a quick glance at some of the information available: 

 - `env::predecessor_account_id`: Id of the account who is _currently_ calling the function.
 - `env::signer_account_id`: Id of the account who _first signed_ the transaction that initiated the call(s).
 - `env::current_account_id`: Id of the current account, who is the owner of the _currently executing_ smart contract.

In the most simple scenarios, `predecessor_account_id` and `signer_account_id` are the same. However, do keep in mind that smart contracts can call other contract's functions (in a chain like manner); when this happens, we call them _cross contract calls_. 

Let's say account **A** calls contract **B**, and contract **B** calls contract **C**, who in turn, calls yet another contract **D**:

```
A -> B -> C -> D
```

In the scenario above, the `signer_account_id` will always be **Account A**. 
Let's find out who is the `predecessor_account_id`: 
 
 - For **B**, the `predecessor_account_id` is **A**.
 - For **C**, the `predecessor_account_id` is **B**.
 - For **D**, the `predecessor_account_id` is **C**.

In our contract, we check if the `owner_account_id` and `predecessor_account_id` are the same. If they are, then the function caller is the **owner**; otherwise, we check if `predecessor_account_id` is included in the allowed user list. 

We could have used the `signer_account_id` but that will rule out any possibility of cross contract calls. A developer could add more features to this contract, so we have to keep our smart contract flexible (yet secure). 

[Learn more](https://docs.near.org/tutorials/crosswords/beginner/actions#predecessor-signer-and-current-account) about predecessor, signer, and current account. 

---

### Cross-Contract calls

[top](#topics)
A "cross contract call" is when a smart contract calls another smart contract's function. Sometimes, you want to prevent cross contract calls, such as when having function that make critical changes to the system. 

For our smart contract, we have implemented a function called `Contract::no_cross_contract`: 

```rust
// don't allow cross-contract calls
fn assert_no_cross_contract(&self){
    let signer_id: AccountId = env::signer_account_id();
    let predecessor_id: AccountId = env::predecessor_account_id();
    assert_eq!(signer_id, predecessor_id, "Cross-contract calls not allowed.");
}
```

Our check simply compaers if the `signer_account_id` is the same as `predecessor_account_id`.

We prevent cross contract calls in some of our functions, such as `Contract::add_user`, `Contract::remove_user` and `Contract::set_default_temperature_unit` since these are admin operations that could add or remove users, as well as affect our system's data.
 
 - `Contract::set_default_temperature_unit`: could result in high gas use due to changing a lot of data.
 - `Contract::add_user`: could include unneeded users to the system.
 - `Contract::remove_user`: could remove users as well as their data. Unproper usage of this function could bring the whole system down.

---

### Handling Output

[top](#topics)
The same function can return diferent data types if we handle them using `enums`. We first need to create an enum that has all the variants:

```rust
// ./src/utils.rs
use near_sdk::serde::{
    Deserialize, Serialize,
};

use crate::entry::Entry;

#[derive(Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
#[serde(untagged)]
pub enum ViewGet{
    Single(Entry),
    Multiple(Vec<Entry>),
}
```

 - `#[derive(Deserialize, Serialize)]` implements the traits `near_sdk::serde::Deserialize` and `near_sdk::serde::Serialize` on our enum. These are needed to serialize and deserialize to and from JSON.
 - `#[serde(crate) = "near_sdk::serde"]` hints to the compiler to use the serde crate found in the NEAR SDK.
 - `#[serde(untagged)]` is an attribute that hints serde  **not** to use JSON tags such as `{ Single: value }` or `{ Multiple: [value1, value2, ...] }`, but just use the actual values like so: `value`, and `[value1, value2, ...]`.

[Learn more](https://serde.rs/enum-representations.html) about using Serde and enums. 

Com o enum declarado e configurado. Basta retornar o tipo em uma função de contrato:
Since we declared and decorated our enum with the proper attributes, we can simply return it from our functions:

```rust
pub fn view_get(
    &self, 
    index: Option<u64>, 
    account_id: String,
) -> ViewGet {
    match index{
        None => {
            let result = self.entries.get(&account_id)
                .unwrap()
                .to_vec();

            ViewGet::Multiple(result)
        },
        Some(index) => {
            let result = self.entries.get(&account_id)
                .unwrap()
                .get(index)
                .unwrap();

            ViewGet::Single(result)
        }
    }
}
```
:warning: **NOTE:** The function above is a **view** function which is free to call (doesn't use gas).

The function just returns a `ViewGet` variant. If the `index` argument is found we will return a `ViewGet::Single(result)` with the value found. If no `index` was specified, then we'll return a list of values found as a `ViewGet::Multiple(result)`.

---

### Handling Input

[top](#topics)

Let's see how we can use the `Option` type. Let's review the following function:

```rust
pub fn new_entry(
    &mut self, 
    time: Option<(u8, u8, f32)>,
    date: Option<(i32, String, u8)>,
    temp_value: f32, 
    temp_format: Option<String>,
) {
    self.assert_user_allowed();
    let user: AccountId = env::predecessor_account_id();

    log("Called new_entry.");

    log("Creating Entry.");
    let entry: TemperatureReading = TemperatureReading::new(time, date, &self.temp_format, temp_value, temp_format);

    log("Acquiring entries for this user.");
    let mut entries = match self.entries.get(&user){
        None => panic!("Unexpected Behavior: Failed to find entries for this user."),
        Some(value) => value,
    };
    
    log("Pushing entry to Vector.");
    entries.push(&entry);
    assert!(self.entries.insert(&user, &entries).is_some(), "Failed to replace vector");

    log("Operation Successful.");
}
```

`Option` is a type that allows having optional values or alternatives, such as `Some(value)` or `None`. 
 - If there is a value, we can wrap it as `Some(value)`.
 - If there is none, then we can just `None`.

:hand: There are no **nulls** in Rust. [Here's](https://www.kirillvasiltsov.com/writing/optional-arguments-in-rust/) an interesting and quick read about optional arguments in Rust. 

In order to check our option, we use the `match` keyword, which forces us to consider all possibilities. 

```rust
pub fn list_update_entries(
    &mut self, 
    account_id: Option<String>,
) -> Vec<TemperatureReading> {
    self.assert_user_allowed();

    // let account_id: AccountId = env::predecessor_account_id();
    let account_id = match account_id {
        None => {
            env::predecessor_account_id()
        },
        Some(value) => {
            let predecessor = env::predecessor_account_id();

            if predecessor != value {
                let signer_id: AccountId = env::signer_account_id();
                let owner_id: AccountId = env::current_account_id();

                assert_eq!(signer_id, owner_id, "Only owner's account is allowed to check entries of others.");
            }

            value
        }
    };    
```

You can see above how we specify our `account_id` as `Option<String>`. 

If an `account_id` is indeed provided, we do some checking and if everything is ok, we assign its value to `account_id` But, if we didn't specify it (we specified `None` as the argument) then we just assign `account_id` to whoever called this function (by know you should read that `predecessor_account_id` as second nature!).

---

### Implementing Traits

[top](#topics)

A `Day`, which is part of a `Date`, belongs to a `Timestamp`. Here's how we implemented them:

```rust
#[derive(BorshDeserialize, BorshSerialize, Clone, Copy, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Day(u8);
```

So `Day` is just an `u8`. However, we do want to put in place some additional behavior that has to do with a `Day`, so let's implement some traits:

```rust
/// Convert to u8 from Day
impl From<&Day> for u8 {
    fn from(day: &Day) -> u8 {
        let &Day(result) = day;

        result
    }
}

/// Convert to String from Day
impl From<&Day> for String{
    fn from(day: &Day) -> String {
        u8::from(day).to_string()
    }
}

// Convert struct to String. Implementing this trait allows using Day in format!, println! and panic!
impl std::fmt::Display for Day {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", String::from(self))
    }
}
```

The `From` trait allows converting from one type to another. Having implemented the traits above, we can now convert to and from `u8` as well as `String`, by using `u8::from(&day)` and `String::from(&day)`. 

The trait `Display` seems complex, but it simply allows that macros such as `panic!`, `format!` and `println!` can be used with the type implementing the trait. If you don't implement `Display`, then something simple like `println!("The day is {}", day)` would panic. 

---

Lesson 6 - Thermometer :white_check_mark: ... **Done! Congratulations!**

Let's learn next all we can about `Result` on our [next lesson](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/EN/lesson_6_enums/lesson_6_3_game_score/).

'''
'''--- EN/lesson_6_enums/lesson_6_2_thermometer/src/contract.rs ---
//! Smart Contract module

use near_sdk::{
    AccountId,
    BorshStorageKey,
    borsh::{self, BorshDeserialize, BorshSerialize},
    collections::{
        Vector,
        LookupMap, 
        UnorderedSet,
    },
    env,
    json_types::ValidAccountId,
    near_bindgen,
};

near_sdk::setup_alloc!();

use crate::{
    temperature::temp_format::TemperatureUnit,
    utils::{
        log,
        ViewGet,
    },
    entry::TemperatureReading,
};

/// Used to access smart contract blockchain data
/// 
/// Each Vector, LookupMap or UnderorderedSet needs a unique key.
/// So we use this enum as key.
/// 
#[derive(BorshStorageKey, BorshSerialize)]
enum StorageKey {
    Entries,
    Users,
    UserEntry(String),
}

/// Smrart Contract API
/// 
/// Only owner or allowed user can use call functions
///
/// Functions:
///  - **add_user**: add user to allowed user list.
///  - **remove_user**: remove user from allowed user list.
///  - **set_default_temperature_unit**: converts from one temperature unit to another.
///  - **new_entry**: add a new temperature measurement.
///  - **list_update_entries**: updates all measurements for a user (converting from/to units if necessary).
///  - **clear_entries**: clear all temperature measurements for a user.
///  - **view_get_format**: view function. Returns default temperature unit.
///  - **view_get**: view function. If given an index returns a specific measurement, if not returns all measurements
/// 
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Contract {
    temp_format: TemperatureUnit,
    entries: LookupMap<AccountId, Vector<TemperatureReading>>,
    users: UnorderedSet<AccountId>,
    temp_length: u32,
}

// initialize smart contract
impl Default for Contract {
    fn default() -> Self {        
        let mut entries = LookupMap::new(StorageKey::Entries);

        let owner_account: String = env::current_account_id();
        let temperature_readings: Vector<TemperatureReading> = Vector::new(StorageKey::UserEntry(String::from(&owner_account)));
        let inserting = entries.insert(&owner_account, &temperature_readings);

        assert!(inserting.is_none(), "Something impossible just happened. Created a LookupMap that already had a value stored.");

        Contract {
            temp_format: TemperatureUnit::default(),
            entries,
            users: UnorderedSet::new(StorageKey::Users),
            temp_length: 0,
        }
    }
}

#[near_bindgen]
impl Contract{
    // assert the owner is the caller
    fn assert_owner_only(&self) {
        let predecessor: AccountId = env::predecessor_account_id();
        let owner_id: AccountId = env::current_account_id();

        assert_eq!(predecessor, owner_id, "Only owner's account is allowed to make this function call.");
    }

    // don't allow cross-contract calls
    fn assert_no_cross_contract(&self) {
        let signer_id: AccountId = env::signer_account_id();
        let predecessor_id: AccountId = env::predecessor_account_id();
        assert_eq!(signer_id, predecessor_id, "Cross-contract calls not allowed.");
    }

    // check user permissions
    fn assert_user_allowed(&self) {
        let predecessor_id: AccountId = env::predecessor_account_id();
        let owner_id: AccountId = env::current_account_id();

        // is the caller the owner? call assert_owner_only
        if owner_id == predecessor_id {
            return;
        }

        // check if user is in the allowed list
        assert!(self.users.contains(&predecessor_id), "User not allowed to make this call.");
    }

    /// Add user to allowed user list.
    /// 
    /// Only owner can call this function.
    /// 
    /// # Panics
    ///  - If cross-contract call.
    ///  - If caller is not owner.
    ///  - If invalid account name.
    ///  - If user already in the allowed user list.
    /// 
    pub fn add_user(&mut self, account_id: String){
        self.assert_no_cross_contract();
        self.assert_owner_only();

        log("Called add_user.");

        // test if account has a well formed format and follows some simple rules... this doesn't mean it ACTUALLY EXISTS in the blockchain!!
        log("Validating Account ID.");
        let account_id = match ValidAccountId::try_from(account_id){
            Ok(value) => String::from(value),
            Err(err) => panic!("Invalid user account id: {}.", err),
        };

        log("Checking if user already exists.");
        let contains: bool = self.users.contains(&account_id);
        assert!(!contains, "User {} is already included in allowed list.", &account_id);
        
        // Create vector for user data
        log("New user detected. Storing User.");
        let user_vector: Vector<TemperatureReading> = Vector::new(StorageKey::UserEntry(String::from(&account_id)));
        let inserting = self.entries.insert(&account_id, &user_vector);
        
        // last check for any implementation error
        assert!(inserting.is_none(), "Unexpected behavior. User is already included in entries.");

        // add user to list
        self.users.insert(&account_id);
    }

    /// Removes user from allowed list.
    /// 
    /// Only the owner can call this function.
    /// 
    /// # Panics
    ///  - If cross-contract call.
    ///  - If caller is not the owner.
    ///  - If invalid user name.
    /// 
    pub fn remove_user(&mut self, account_id: String){
        self.assert_no_cross_contract();
        self.assert_owner_only();

        // you can't remove the owner
        let owner_id: AccountId = env::current_account_id();
        assert_ne!(&owner_id[..], &account_id[..], "Owner account can't be removed from contract.");

        log("Called remove_user");

        log("Validating Account ID.");
        let account_id = match ValidAccountId::try_from(account_id){
            Ok(value) => String::from(value),
            Err(err) => panic!("Invalid user account id: {}.", err),
        };

        log("Checking if user exists.");
        let contains: bool = self.users.contains(&account_id);
        // panic if user not in list
        assert!(contains, "User {} not found.", &account_id);

        // remove vector for user data
        let entries: Option<Vector<TemperatureReading>> = self.entries.remove(&account_id);
        assert!(entries.is_some(), "Unexpected Behavior. Found user, but didn't find entry list for user.");

        // clear all user data (security)
        let mut entries: Vector<TemperatureReading> = entries.unwrap();
        entries.clear();

        match self.users.remove(&account_id){
            true => {
                log("User successfully removed.");
            },
            false => {
                log("Unexpected Behavior. Account exists in entries but doesn't exist in user list.");
            },
        };
    }

    
    /// Update default temperature unit (system default).
    /// Doesn't modify any existing entries (Data).
    /// Only owner can call this function.
    /// 
    /// # Panics
    ///  - If cross-contract call.
    ///  - If user not in allowed user list.
    ///  - If caller is not owner
    /// 
    pub fn set_default_temperature_unit(&mut self, unit_name: String) {
        self.assert_no_cross_contract();
        self.assert_owner_only();

        log("Called set_default_temperature_unit");

        let temperature_unit = TemperatureUnit::new(&unit_name);

        log(
            &format!("Setting default temperature unit to {}", &temperature_unit)
        );

        self.temp_format = temperature_unit;
    }
    

    /// Stores a new temperature measurement associated with a user.
    /// 
    /// time and date are optional. If not specified, these will be the current date and time. 
    /// format is optional. If not specified, the default temperature unit (system default) will be used.
    /// 
    /// # Panics
    ///  - If user is not on the allowed list
    ///  - If hour is negative or larger than 23.
    ///  - If minute is negative or larger than 59.
    ///  - If second is negative or larger than 59.9
    ///  - If day is invalid for year and month;
    ///  - If month name is an invalid String.
    ///  - If temp_format is an invalid String.
    /// 
    /// # Examples (bash)
    ///  - new_entry '{"temp_value": 100 }'
    ///  - new_entry '{"temp_value": 100, "temp_format": "Celsius"}'
    ///  - new_entry '{"temp_value": 50.5, "temp_format": "Fahrenheit", "date: [2022, "feb", 11]"}'
    ///  - new_entry '{"temp_value": 11.5, "temp_format": "f", "date": [2018, "mar", 27], "time": [10, 50, 9.3453]}'
    ///  - new_entry '{"temp_value": -45.4, "temp_format": "c", "time": [23, 41, 4.443]}'
    ///  - new_entry '{"temp_value": 44.13, "temp_format": "kelvin"}'
    /// 
    pub fn new_entry(
        &mut self, 
        time: Option<(u8, u8, f32)>,
        date: Option<(i32, String, u8)>,
        temp_value: f32, 
        temp_format: Option<String>,
    ){
        self.assert_user_allowed();
        let user: AccountId = env::predecessor_account_id();

        log("Called new_entry.");

        log("Creating Entry.");
        let entry: TemperatureReading = TemperatureReading::new(time, date, &self.temp_format, temp_value, temp_format);

        log("Acquiring entries for this user.");
        let mut entries = match self.entries.get(&user){
            None => panic!("Unexpected Behavior: Failed to find entries for this user."),
            Some(value) => value,
        };
        
        log("Pushing entry to Vector.");
        entries.push(&entry);
        assert!(self.entries.insert(&user, &entries).is_some(), "Failed to replace vector");

        log("Operation Successful.");
    }

    /// Return user data, updating the values to the default temperature unit.
    /// 
    /// If account_id not specified, return data for the caller account.
    /// 
    /// Only owner can change other user's data.
    /// 
    /// # Panics
    ///  - If user is not allowed.
    ///  - If caller is not owner.
    ///  - If user not found.
    /// 
    pub fn list_update_entries(
        &mut self, 
        account_id: Option<String>,
    ) -> Vec<TemperatureReading> {
        self.assert_user_allowed();

        // let account_id: AccountId = env::predecessor_account_id();
        let account_id = match account_id {
            None => {
                env::predecessor_account_id()
            },
            Some(value) => {
                let predecessor = env::predecessor_account_id();

                if predecessor != value {
                    let signer_id: AccountId = env::signer_account_id();
                    let owner_id: AccountId = env::current_account_id();

                    assert_eq!(signer_id, owner_id, "Only owner's account is allowed to check entries of others.");
                }

                value
            }
        };
        
        let mut entries: Vector<TemperatureReading> = match self.entries.get(&account_id){
            None => panic!("Couldn't find entries for user {}.", account_id),
            Some(value) => value,
        };

        let mut entries_vec = entries.to_vec();

        let temp_format: TemperatureUnit = self.temp_format.clone();
        let mut changed: bool = false;
        
        // MW: check index needed?
        let mut index: u64 = 0;

        // entries.to_vec()
        for entry in entries_vec.iter_mut(){
            if entry.update_temp_format(&temp_format) {
                changed = true;
                entries.replace(index, &entry);
            };

            index += 1;
        };

        if changed {
            self.entries.insert(&account_id, &entries);
        }
        
        entries_vec
    }

    /// Clears all user data.
    /// 
    /// If account_id not specified, clear all user data for the caller.
    /// 
    /// Only owner can call this function.
    /// 
    /// # Panics
    ///  - If user is not owner
    ///  - If specified user is not found (no data)
    /// 
    pub fn clear_entries(
        &mut self, 
        account_id: Option<String>,
    ){
        self.assert_owner_only();
        
        let account_id: String = match account_id {
            None => env::predecessor_account_id(),
            Some(value) => {
                log("Validating user account.");

                match ValidAccountId::try_from(value){
                    Ok(account_id) => String::from(account_id),
                    Err(err) => panic!("Invalid user account id: {}.", err),
                }
            }
        };

        assert!(self.users.contains(&account_id), "Account {} not found.", &account_id);
        
        // entries.remove: 
        // Removes a key from the map, returning the value at the key if the key was previously in the map
        let entries: Vector<TemperatureReading> = match self.entries.remove(&account_id) {
            None => panic!("Couldn't find entries for user {}.", account_id),
            Some(mut value) => {
                value.clear();
                value
            },
        };

        assert!(
            self.entries.insert(&account_id, &entries).is_none(),
            "Unexpected behavior, attempted to remove the vector for {}, but it still exists after removing.", 
            &account_id,
        );

        log(&format!("Successfully removed all entries for {}.", &account_id));
    }

    // View Functions

    /// Returns default temperature unit name
    pub fn view_get_format(&self) -> String {
        String::from(&self.temp_format)
    }

    /// Return user data for a given user.
    /// 
    /// If index not specified, return all temperature measurements for a user.
    /// 
    pub fn view_get(
        &self, 
        index: Option<u64>, 
        account_id: String,
    ) -> ViewGet {
        match index{
            None => {
                let result = self.entries
                    .get(&account_id)
                    .unwrap()
                    .to_vec();

                ViewGet::Multiple(result)
            },
            Some(index) => {
                let result = self.entries
                    .get(&account_id)
                    .unwrap()
                    .get(index)
                    .unwrap();

                ViewGet::Single(result)
            }
        }
    }
}

'''
'''--- EN/lesson_6_enums/lesson_6_2_thermometer/src/entry/mod.rs ---
//! Entry represents a single input value from a user
//! 
//! Periodically each sensor will send temperature readings. The Smart Contract will save these as it receives them.
//! 
//! Each temperature reading has the following attributes: 
//!  - temperature: a temperature value (f32) with a temperature unit (Kelvin, Celsius, Fahrenheit).
//!  - schedule: a timestamp when the the measurement was taken. UTC.
//! 

use near_sdk::{
    borsh::{ self, BorshDeserialize, BorshSerialize },
    serde::{ Deserialize, Serialize },
};

use crate::{
    schedule::Timestamp,
    temperature::{
        Temperature,
        temp_format::TemperatureUnit,
    }
};

/// Represents a temperature reading 
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct TemperatureReading {
    timestamp: Timestamp,
    measurement: Temperature,
}

impl TemperatureReading {
    /// Creates a temperature reading
    /// 
    ///  - If time is omitted, the call time will be used as default.
    ///  - Id date is omitted, the call date will be used as default.
    ///  - If temperature unit is ommited, the system's default will be used as default.
    ///  - Value represents the actual temperature value/measurement.
    /// 
    ///  # Panics
    ///  - if temperature below absolute zero.
    ///  - On invalid day.
    ///  - On invalid month.
    /// 
    pub fn new(
            time: Option<(u8, u8, f32)>,
            date: Option<(i32, String, u8)>,
            temperature_unit: &TemperatureUnit, 
            temperature_value: f32, 
            arg_temp: Option<String>,
        ) -> Self {
        
        TemperatureReading { 
            timestamp: Timestamp::new(date, time), 
            measurement: Temperature::new(temperature_value, temperature_unit, arg_temp),
        }
    }

    /// If there's a new temperature unit given, perform conversion
    pub fn update_temp_format(&mut self, new_format: &TemperatureUnit) -> bool {
        self.measurement.update_temp_format(new_format)
    }
}

'''
'''--- EN/lesson_6_enums/lesson_6_2_thermometer/src/lib.rs ---
// We don't want this module on the docs, so we make it public to our crate only.
pub(crate) mod contract;
pub mod entry;
pub mod schedule;
pub mod temperature;
pub mod utils;

pub use contract::Contract;

'''
'''--- EN/lesson_6_enums/lesson_6_2_thermometer/src/schedule/date.rs ---
//! Date module
//! 
//! Used by timestamp
//! contains day, month and year
//! 

use near_sdk::{
    borsh::{ self, BorshDeserialize, BorshSerialize },
    serde::{ Deserialize, Serialize },
};

pub mod day;
pub mod month;
pub mod year;

use day::Day;
use month::Month;
use year::Year;

/// Represents a Date (day, month, year).
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Date {
    day: Day,
    month: Month,
    year: Year,
}

impl Date{
    /// Creates a Date 
    /// 
    /// # Panics
    ///  - If day is negative.
    ///  - If day is higher than the max allowed for a particular month.
    ///  - If month is an invalid String.
    /// 
    pub fn new(day: u8, month: &str, year: i32) -> Date {
        // Creates a year 
        let year: Year = Year::new(year);
        // Creates a month
        let month: Month = Month::new(month);
        // Creates a day
        let day: Day = Day::new(day, &month, &year);

        Date{
            day,
            month,
            year,
        }
    }
}

'''
'''--- EN/lesson_6_enums/lesson_6_2_thermometer/src/schedule/date/day.rs ---
//! Module with all functions related to a day
//! 
//! We use an u8 for the day, but we also need to 
//! check the day is valid. So, we'll need to make
//! day a struct Day(u8).
//! 
//! When serialized to JSON, the value would just be
//! an u8, so there won't be any additional complexity
//! for the user.
//! 
//! You can build Day using Day::new. 
//! This function needs both month and year to know
//! the max value for day and if it is a leap year.
//! Other features:
//!  - u8::from(day) allows converting a Day to u8.
//!  - String::from(day) allows converting a Day to String.
//!  - std::fmt::Display is implemented, and so it allows to 
//! use Daz in macros println! and panic!
//! 
//! ## Examples
//! 
//! ```rust
//! # use lesson_6_2_thermometer::schedule::date::day::Day;
//! # use lesson_6_2_thermometer::schedule::date::month::Month;
//! # use lesson_6_2_thermometer::schedule::date::year::Year;
//! 
//! // not leap year
//! let month = Month::new("feb");
//! let year = Year::new(1971);
//! 
//! let day = Day::new(28, &month, &year);
//! assert_eq!(u8::from(&day), 28);
//! assert_eq!(format!("{}", day), "28");
//! assert_eq!(String::from(&day), "28");
//! 
//! // leap year
//! let month = Month::new("feb");
//! let year = Year::new(1972);
//! 
//! let day = Day::new(29, &month, &year);
//! assert_eq!(u8::from(&day), 29);
//! assert_eq!(format!("{}", day), "29");
//! assert_eq!(String::from(&day), "29");
//! 
//! ```
//! 

use near_sdk::{
    borsh::{ self, BorshDeserialize, BorshSerialize },
    serde::{ Serialize, Deserialize },
};

use crate::schedule::date::{
    month::Month,
    year::Year,
};

/// Represents a day
/// 
/// When serialized, it will become an u8.
/// 
#[derive(BorshDeserialize, BorshSerialize, Clone, Copy, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Day(u8);

impl Day{
    /// Creates an instance of Day.
    ///  - day: 1 to 31, depending on month and year.
    ///  - current_month: current month, for validation
    ///  - current_year: current year, for validation
    /// 
    /// # Panics
    /// - invalid day
    /// 
    pub fn new(day: u8, current_month: &Month, current_year: &Year) -> Self {
        let day = Day(day);
        day.assert_valid(current_month, current_year);

        day
    }

    /// # Panics
    /// - if day is invalid
    fn assert_valid(&self, current_month: &Month, current_year: &Year) {
        let &Day(day) = self;

        let mut current_year: i32 = current_year.get();

        // Se for negativo, converte para positivo
        if current_year < 0 {
            current_year = -current_year;
        }

        // true if "leap year".
        let leap_year: bool = (current_year % 4) == 0;
        // convert true = 1, false = 0.
        let leap_year: u8 = leap_year as u8;

        // source: https://www.rapidtables.com/calc/time/months-of-year.html
        let max_day: u8 = match current_month {
            &Month::January(_) => 31,
            &Month::February(_) => 28 + leap_year,
            &Month::March(_) => 31,
            &Month::April(_) => 30,
            &Month::May(_) => 31,
            &Month::June(_) => 30,
            &Month::July(_) => 31,
            &Month::August(_) => 31,
            &Month::September(_) => 30,
            &Month::October(_) => 31,
            &Month::November(_) => 30,
            &Month::December(_) => 31,
        };

        // check if day is within valid range
        assert!(day <= max_day,
            "Invalid values for day. Day: {}, Month: {}, Year: {}. Day for given month and year can not be higher than {}.",
                day,
                current_month,
                current_year,
                max_day,
        )
    }
}

/// Convert to u8 from Day
impl From<&Day> for u8{
    fn from(day: &Day) -> u8 {
        let &Day(result) = day;

        result
    }
}

/// Convert to String from Day
impl From<&Day> for String{
    fn from(day: &Day) -> String {
        u8::from(day).to_string()
    }
}

// Convert struct to String. Implementing this trait allows using Day in format!, println! and panic!
impl std::fmt::Display for Day {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", String::from(self))
    }
}

'''
'''--- EN/lesson_6_enums/lesson_6_2_thermometer/src/schedule/date/month.rs ---
//! Module with all functions related to a month
//! 
//! We'll use an enum with all possible month value
//! For JSON, it is better to use a string or a number.
//! 
//! Using serde, we can choose the best option. 
//! Let's first declare our enum.
//! 
//! ```
//!use near_sdk::{
//!    borsh::{ self, BorshDeserialize, BorshSerialize },
//!    serde::{ Deserialize, Serialize },
//!};
//! 
//! #[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
//! #[serde(crate = "near_sdk::serde")]
//! pub enum Month{
//!     January(String),
//!     February(String),
//!     March(String),
//!     April(String),
//!     May(String),
//!     June(String),
//!     July(String),
//!     August(String),
//!     September(String),
//!     October(String),
//!     November(String),
//!     December(String),
//! }
//! ```
//! 
//! If month is Month::December(String::from("December")), 
//! then our value JSON will be {December: "December"}.
//! 
//! But, if we use untagged, 
//! serde(untagged), 
//! 
//! ```
//!use near_sdk::{
//!    borsh::{ self, BorshDeserialize, BorshSerialize },
//!    serde::{ Deserialize, Serialize },
//!};
//! 
//! #[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
//! #[serde(crate = "near_sdk::serde")]
//! #[serde(untagged)]
//! pub enum Month{
//!     January(String),
//!     February(String),
//!     March(String),
//!     April(String),
//!     May(String),
//!     June(String),
//!     July(String),
//!     August(String),
//!     September(String),
//!     October(String),
//!     November(String),
//!     December(String),
//! }
//! ```
//! 
//! Then no tag will be used and so 
//! Month::december(String::from("December")), 
//! will be represented as month: "December". 
//! which is more user-friendly.
//! 

use near_sdk::{
    borsh::{ self, BorshDeserialize, BorshSerialize },
    serde::{ Deserialize, Serialize },
};

/// Represents a month
/// 
/// Using serde(untagged) this enum will
/// be represented as string (no tag)
/// 
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
#[serde(untagged)]
pub enum Month{
    January(String),
    February(String),
    March(String),
    April(String),
    May(String),
    June(String),
    July(String),
    August(String),
    September(String),
    October(String),
    November(String),
    December(String),
}

impl Month{
    /// Create a month instance.
    /// 
    /// All possible values on the left are converted
    /// to an enum value on the right:
    /// 
    ///  - "january", "jan", "janeiro", "enero", "ene" => Month::January("January")
    ///  - "february", "feb", "fevereiro", "fev", "febrero" => Month::February("February")
    ///  - "march", "mar", "março", "marzo" => Month::March("March")
    ///  - "april", "apr", "abril", "abr" => Month::April("April")
    ///  - "may", "maio", "mayo" => Month::May("May")
    ///  - "june", "jun", "junho", "junio" => Month::June("June")
    ///  - "july", "jul", "julho", "julio" => Month::July("July")
    ///  - "august", "aug", "agosto", "ago" => Month::August("August")
    ///  - "september", "sep", "setembro", "set", "septiembre" => Month::September("September")
    ///  - "october", "octo", "oct", "outubro", "out", "octubre", "octu" => Month::October("October")
    ///  - "november", "nov", "novembro", "noviembre" => Month::November("November")
    ///  - "december", "dec", "dezembro", "dez", "diciembro", "dic" => Month::December("December")
    /// 
    /// # Panics
    /// - if an invalid argument is provided. Month not valid.
    /// 
    pub fn new(month: &str) -> Self {
        let lower_case: String = month.to_ascii_lowercase();
        
        match &lower_case[..]{
            "january" | "jan" | "janeiro" | "enero" | "ene" => Month::January(String::from("January")),
            "february" | "feb" | "fevereiro" | "fev" | "febrero" => Month::February(String::from("February")),
            "march" | "mar" | "março" | "marzo" => Month::March(String::from("March")),
            "april" | "apr" | "abril" | "abr" => Month::April(String::from("April")),
            "may" | "maio" | "mayo" => Month::May(String::from("May")),
            "june" | "jun" | "junho" | "junio" => Month::June(String::from("June")),
            "july" | "jul" | "julho" | "julio" => Month::July(String::from("July")),
            "august" | "aug" | "agosto" | "ago" => Month::August(String::from("August")),
            "september" | "sep" | "setembro" | "set" | "septiembre" => Month::September(String::from("September")),
            "october" | "octo" | "oct" | "outubro" | "out" | "octubre" | "octu" => Month::October(String::from("October")),
            "november" | "nov" | "novembro" | "noviembre" => Month::November(String::from("November")),
            "december" | "dec" | "dezembro" | "dez" | "diciembre" | "dic" => Month::December(String::from("December")),
            invalid => panic!("Invalid value for month: {}.", invalid),
        }
    }

    // jan 31
    // feb 59
    // mar 90
    // apr 120
    // may 151
    // jun 181
    // jul 212
    // aug 243
    // sep 273
    // octo 304
    // nov 334
    // dec 365

    /// Value in range 0 and 365. 
    /// Return month and day, based on year
    /// 
    /// if is_leap_year then the range can be 0 to 366.
    /// 
    pub fn new_from_days(mut days: u64, is_leap_year: bool) -> (String, u8) {
        // 0 false 1 true
        let leap_year: u64 =  is_leap_year as u64;
        assert!(days < 365 + leap_year, "Unexpected Behavior. Days should be lower than {}. Got {}.", 365 + leap_year, days);
        // day 0 = jan 1
        days += 1;

        if days <= 31 {
            return (String::from("jan"), days as u8);
        }
        if days <= 59 + leap_year {
            // include feb 29 for leap year
            return (String::from("feb"), days as u8 - 31);
        }
        if days <= 90 + leap_year {
            return (String::from("mar"), (days - 59 - leap_year) as u8);
        }
        if days <= 120 + leap_year {
            return (String::from("apr"), (days - 90 - leap_year) as u8);
        }
        if days <= 151 + leap_year {
            return (String::from("may"), (days - 120 - leap_year) as u8);
        }
        if days <= 181 + leap_year {
            return (String::from("jun"), (days - 151 - leap_year) as u8);
        }
        if days <= 212 + leap_year {
            return (String::from("jul"), (days - 181 - leap_year) as u8);
        }
        if days <= 243 + leap_year {
            return (String::from("aug"), (days - 212 - leap_year) as u8);
        }
        if days <= 273 + leap_year {
            return (String::from("sep"), (days - 243 - leap_year) as u8);
        }
        if days <= 304 + leap_year {
            return (String::from("oct"), (days - 273 - leap_year) as u8);
        }
        if days <= 334 + leap_year {
            return (String::from("nov"), (days - 304 - leap_year) as u8);
        }

        (String::from("dec"), (days - 334 - leap_year) as u8)  
    }

    /// Returns month name as a String
    pub fn get(&self) -> String {
        match self {
            Month::January(value) => value.clone(),
            Month::February(value) => value.clone(),
            Month::March(value) => value.clone(),
            Month::April(value) => value.clone(),
            Month::May(value) => value.clone(),
            Month::June(value) => value.clone(),
            Month::July(value) => value.clone(),
            Month::August(value) => value.clone(),
            Month::September(value) => value.clone(),
            Month::October(value) => value.clone(),
            Month::November(value) => value.clone(),
            Month::December(value) => value.clone(),
        }
    }
}

/// Convert to u8 from month
impl From<&Month> for u8 {
    fn from(month: &Month) -> u8 {
        match month {
            Month::January(_) => 0,
            Month::February(_) => 1,
            Month::March(_) => 2,
            Month::April(_) => 3,
            Month::May(_) => 4,
            Month::June(_) => 5,
            Month::July(_) => 6,
            Month::August(_) => 7,
            Month::September(_) => 8,
            Month::October(_) => 9,
            Month::November(_) => 10,
            Month::December(_) => 11,
        }
    }
}

/// Convert to Month from u8
impl From<u8> for Month {
    fn from(month: u8) -> Month {
        match month{
            0 => Month::new("jan"),
            1 => Month::new("feb"),
            2 => Month::new("mar"),
            3 => Month::new("apr"),
            4 => Month::new("may"),
            5 => Month::new("jun"),
            6 => Month::new("jul"),
            7 => Month::new("aug"),
            8 => Month::new("sep"),
            9 => Month::new("oct"),
            10 => Month::new("nov"),
            11 => Month::new("dec"),
            invalid => panic!("Invalid value for month: {}. Number value must be positive, lower than 12.", invalid),
        }
    }
}

/// Convert to String from &Month
impl From<&Month> for String{
    fn from(month: &Month) -> String {
        month.get()
    }
}

/// Convert to String from Month
impl From<Month> for String{
    fn from(month: Month) -> String {
        String::from(&month)
    }
}

/// String representation, useful for using format!, println! and panic!
impl std::fmt::Display for Month {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", String::from(self))
    }
}

#[cfg(test)]
mod tests{
    use crate::utils::log;
    use crate::schedule::Month;

    #[test]
    /// Test Month::new_from_days 
    /// for all days of year and leap year 
    fn new_from_days(){

        /// testing year. parameters:
        ///  - days: range 0 to 365. 0 to 366 if is_leap_year = true.
        ///  - is_leap_year: true if leap year
        ///  - expected_month: range 0 to 12.
        ///  - expected_day: range 0 to 31, depending on month and if leap year
        /// 
        fn util_day_constructor(days: u64, is_leap_year: bool, expected_month: u8, expected_day: u8) {
            let (month_str, day) = Month::new_from_days(days, is_leap_year);
            let month_number = u8::from(&Month::new(&month_str));
    
            assert_eq!(
                month_number, 
                expected_month, 
                "Comparison error when constructing day. Expected month: {}, number: {}. Got {}.", 
                Month::from(expected_month), 
                expected_month, 
                month_number,
            );

            assert_eq!(
                day, 
                expected_day, 
                "Comparison error when constructing day. Expected day: {}. Got: {}.", 
                expected_day, 
                day,
            );
        }

        /// Use util_day_constructor to test all days of the year
        fn testing_year(is_leap_year: bool){
            let leap_year = is_leap_year as u64;

            #[allow(unused_mut)]
            let mut day_number;
            #[allow(unused_mut)]
            let mut month_number;

            for day in 0..(365 + leap_year) {
                if day < 31 { 
                    day_number = day;
                    month_number = 0; 
                } else if day < 59 + leap_year{ 
                    day_number = day - 31;
                    month_number = 1; 
                } else if day < 90 + leap_year { 
                    day_number = day - 59 - leap_year;
                    month_number = 2;  
                } else if day < 120 + leap_year{ 
                    day_number = day - 90 - leap_year;
                    month_number = 3; 
                } else if day < 151 + leap_year{ 
                    day_number = day - 120 - leap_year;
                    month_number = 4; 
                } else if day < 181 + leap_year { 
                    day_number = day - 151 - leap_year;
                    month_number = 5; 
                } else if day < 212 + leap_year{ 
                    day_number = day - 181 - leap_year;
                    month_number = 6; 
                } else if day < 243 + leap_year{ 
                    day_number = day - 212 - leap_year;
                    month_number = 7; 
                } else if day < 273 + leap_year{ 
                    day_number = day - 243 - leap_year;
                    month_number = 8; 
                } else if day < 304 + leap_year{ 
                    day_number = day - 273 - leap_year;
                    month_number = 9; 
                } else if day < 334 + leap_year{ 
                    day_number = day - 304 - leap_year;
                    month_number = 10; 
                } else { 
                    day_number = day - 334 - leap_year;
                    month_number = 11; 
                }

                // first day of month is 1
                util_day_constructor(day, is_leap_year, month_number, day_number as u8 + 1)
             }
        }

        log("Testing for non leap year.");
        testing_year(false);

        log("Testing for leap year.");
        testing_year(true);
    }
}

'''
'''--- EN/lesson_6_enums/lesson_6_2_thermometer/src/schedule/date/year.rs ---
//! Module with all functions related to a year
//! 
//! Year is represented as a tuple of an integer and string
//! 
use near_sdk::{
    borsh::{ self, BorshDeserialize, BorshSerialize },
    serde::{ Deserialize, Serialize },
};

/// Tuple representing a year. 
/// 
/// An integer representing the year. 
/// A String representing a formatted year.
/// 
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Year(i32, String);

impl Year{
    /// create an instance of year
    pub fn new(mut value: i32) -> Year {
        let is_negative = value < 0;
        if is_negative{
            value = -value;
        }

        let text: &str = match is_negative{
            true => {
                "BC"
            },
            false => {
                "AD"
            }
        };

        let text: String = format!("{} {}", value, text);
        if is_negative {
            value = -value;
        }

        Year(value, text)
    }

    /// Returns year
    pub fn get(&self) -> i32 {
        // Year is a tuple, so using .0 is the first value.
        // i32 implements copy, so there's no need to self.0.clone()
        self.0
    }
}

/// Convert to String from &Year
impl From<&Year> for String{
    fn from(year: &Year) -> String {
        year.1.clone()
    }
}

/// Convert to String from Year
impl From<Year> for String{
    fn from(year: Year) -> String {
        String::from(&year)
    }
}

// Convert struct to String. Implementing this trait allows using Year in format!, println! and panic!
impl std::fmt::Display for Year {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", String::from(self))
    }
}

'''
'''--- EN/lesson_6_enums/lesson_6_2_thermometer/src/schedule/mod.rs ---
//! Timestamp module
//! 
//! Um valor de temperatura não possui muita utilidade sem um tempo associado. Este é o objetivo desse tipo.
//! 
//! Contains Date and Time, both used to create a Timestamp type
//! 
//! Pode ser fornecido como parâmetro ou gerado automaticamente com o momento do sistema.
//! 

use near_sdk::{
    borsh::{ self, BorshDeserialize, BorshSerialize },
    env,
    serde::{ Deserialize, Serialize },
};

pub mod date;
pub mod time;

use date::Date;
use time::Time;

use self::date::month::Month;

use crate::utils::log;

/// Represents a timestamp
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Timestamp {
    date: Date,
    time: Time,
}

impl Timestamp {
    
    fn remainder_from_value(mut value: u64, max: u64) -> (u64, u64) {
        let remainder: u64 = value % max;
        value = (value - remainder) / max;

        (value, remainder)
    }

    fn time_from_nanoseconds(nano: u64) -> (u8, u8, f32) {
        let (_, remainder) = Self::remainder_from_value(nano, 24 * 60 * 60 * 1_000_000_000);
        let (hours, remainder) = Self::remainder_from_value(remainder, 60 * 60 * 1_000_000_000);
        let (minutes, seconds) = Self::remainder_from_value(remainder, 60 * 1_000_000_000);

        (hours as u8, minutes as u8, seconds as f32 / 1_000_000_000.)
    }

    fn date_from_nanoseconds(nano: u64) -> (i32, String, u8) {
        // add 2 years, account for leap years
        let nano: u64 = nano + 2 * 365 * 24 * 60 * 60 * 1_000_000_000;

        let max: u64 = (365.25 as f64 * 24. * 60. * 60. * 1_000_000_000.) as u64;
        let (year, remainder) = Self::remainder_from_value(nano, max);

        let is_leap_year = year % 4 == 0;

        let max = 24 * 60 * 60 * 1_000_000_000;

        // full days is numbers of days 0 - 360
        // the remainder is discarded
        let (full_days, _) = Self::remainder_from_value(remainder, max);
        let (month, day) = Month::new_from_days(full_days, is_leap_year);
        
        // No inicio do calculo de data por nanosegundos. Somamos 2 anos ao valor recebido, para garantir que está em sincronia com os leap years.
        (year as i32 + 1968, month, day)
    }

    /// Creates a Timestamp
    /// 
    /// date: (year, month, day) tuple.
    /// time: (hour, minute, second) tuple.
    /// 
    pub fn new(date: Option<(i32, String, u8)>, time: Option<(u8, u8, f32)>) -> Self {
        
        // block_timestamp() = transaction signature time 
        let block_time: u64 = env::block_timestamp();

        let (year, month, day) = match date{
            Some(value) => value,
            None => {
                log("Date wasn't specified, using current date.");
                Self::date_from_nanoseconds(block_time)
            },
        };
        
        let (hour, minute, second) = match time{
            Some(value) => value,
            None => {
                log("Time wasn't specified, using current time");
                Self::time_from_nanoseconds(block_time)
            }
        };

        log(&format!("Epoch time is {}.", block_time));
        log(&format!("Day: {}, Month: {}, Year: {}", day, &month, year));
        log(&format!("Hour: {}, Minute: {}, Second: {}", hour, minute, second));

        let date: Date = Date::new(day, &month, year);
        let time: Time = Time::new(hour, minute, second);

        Timestamp { 
            date,
            time,
        }
    }
}

'''
'''--- EN/lesson_6_enums/lesson_6_2_thermometer/src/schedule/time.rs ---
//! Time module
//! 
//! Used by timestamp
//! Contains Hour, Minute, Second
//! 

use near_sdk::{
    borsh::{ self, BorshDeserialize, BorshSerialize },
    serde::{ Deserialize, Serialize },
};

pub mod hour;
pub mod minute;
pub mod second;

use hour::Hour;
use minute::Minute;
use second::Second;

/// Represents Time (hour, minute, second)
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Time{
    hour: Hour,
    minute: Minute,
    second: Second,
}

impl Time {
    /// Creates a time instance
    /// 
    /// # Panics
    ///  - if hour >= 24;
    ///  - if minute >= 60;
    ///  - if second >= 60. ;
    ///  - if second < 0. ;
    /// 
    pub fn new(hour: u8, minute: u8, second: f32) -> Time{
        let hour: Hour = Hour::new(hour);
        let minute: Minute = Minute::new(minute);
        let second: Second = Second::new(second);

        Time{
            hour,
            minute,
            second
        }
    }
}

'''
'''--- EN/lesson_6_enums/lesson_6_2_thermometer/src/schedule/time/hour.rs ---
//! Hour module
//! 
//! This type is only an u8
//! 
//!  - u8::from(&hour) converts hour reference to u8 
//!  - u8::from(hour) converts hour value to u8
//!  - Hour::from(value u8) converts u8 value to Hour
//! 

use near_sdk::{
    borsh::{ self, BorshDeserialize, BorshSerialize },
    serde::{ Deserialize, Serialize },
};

/// A type represening an Hour
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Hour(u8);

impl Hour{
    pub fn new(hour: u8) -> Hour {
        assert!(hour < 24, "Invalid value for hour. Must be lower than 24. Current: {}.", hour);

        Hour(hour)
    }
}

/// Convert to u8 from &Hour
impl From<&Hour> for u8{
    fn from(hour: &Hour) -> u8 {
        let &Hour(result) = hour;

        result
    }
}

/// Convert to u8 from Hour
impl From<Hour> for u8{
    fn from(hour: Hour) -> u8 {
        u8::from(&hour)
    }
}

/// Convert to Hour from u8
impl From<u8> for Hour{
    fn from(hour: u8) -> Hour {
        Hour::new(hour)
    }
}

'''
'''--- EN/lesson_6_enums/lesson_6_2_thermometer/src/schedule/time/minute.rs ---
//! Minute module
//! 
//! This type is only an u8
//! 
//!  - u8::from(&minute) converts minute reference to u8 
//!  - u8::from(minute) converts minute to u8 
//!  - Minute::from(esteu8) converts u8 to Minute
//! 

use near_sdk::{
    borsh::{ self, BorshDeserialize, BorshSerialize },
    serde::{ Deserialize, Serialize },
};

/// Represents a minute
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Minute(u8);

impl Minute {
    /// Builds an instance of Minute
    /// 
    /// # Panics
    /// If value is less than 60
    /// 
    pub fn new(minute: u8) -> Minute{
        assert!(minute < 60, "Invalid value for minute. Must be lower than 60. Current: {}.", minute);

        Minute(minute)
    }
}

/// Convert to u8 from &minute
impl From<&Minute> for u8 {
    fn from(minute: &Minute) -> u8 {
        let &Minute(result) = minute;

        result
    }
}

/// Convert to u8 from minute
impl From<Minute> for u8{
    fn from(minute: Minute) -> u8 {
        u8::from(&minute)
    }
}

/// Convert to minute from u8
impl From<u8> for Minute{
    fn from(minute: u8) -> Minute {
        Minute::new(minute)
    }
}

'''
'''--- EN/lesson_6_enums/lesson_6_2_thermometer/src/schedule/time/second.rs ---
//! Second module
//! 
//! This type is only an f32
//! 
//!  - f32::from(&second) converts minute reference to f32.
//!  - f32::from(second) converts minute to f32.
//!  - Minute::from(value f32) converts f32 to Second
//! 

use near_sdk::{
    borsh::{ self, BorshDeserialize, BorshSerialize },
    serde::{ Deserialize, Serialize },
};

/// Represents a second
/// # Panics
///  - If value is higher than 60.
///  - If value is negative.
/// 
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Second(f32);

impl Second {
    pub fn new(second: f32) -> Second{
        assert!(second < 60., "Invalid value for second. Must be lower than 60. Current: {}.", second);
        assert!(second >= 0., "Invalid value for second. Can't be negative. Current: {}.", second);

        Second(second)
    }
}

/// Convert to f32 from &Second
impl From<&Second> for f32 {
    fn from(second: &Second) -> f32 {
        let &Second(result) = second;

        result
    }
}

/// Convert to f32 from Second
impl From<Second> for f32{
    fn from(second: Second) -> f32 {
        f32::from(&second)
    }
}

/// Convert to Second from f32
impl From<f32> for Second{
    fn from(second: f32) -> Second {
        Second::new(second)
    }
}

'''
'''--- EN/lesson_6_enums/lesson_6_2_thermometer/src/temperature/mod.rs ---
//! Module: temperature
//! Has a temperature value (value) an a temperature unit (temp_format).
//! 
//! Smart Contract has a default temperature unit.
//! If you don't specify a temperature unit, we use the default system unit.
//! 
//! If the temperature unit sent in a message is different from the system-specified one, 
//! we convert it to the system temperature unit
//! 
pub mod temp_format;

use near_sdk::{
    borsh::{ self, BorshDeserialize, BorshSerialize },
    serde::{ Deserialize, Serialize },
};

use temp_format::TemperatureUnit;
use crate::utils::log;

/// A Temperature.
/// temperature value is f32.
/// temperature unit can be Kelvin, Celsius or Fahrenheit.
/// 
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Temperature {
    degrees: f32,
    unit: TemperatureUnit,
}

impl Temperature {
    /// Create an instance of temperature
    /// 
    /// # Panic
    /// if temperature value is less than absolute 0
    /// 
    fn new_assert(temperature_value: f32, temperature_unit: TemperatureUnit) -> Self {
        let (min_allowed, name) = match &temperature_unit {
            TemperatureUnit::Celsius(unit_name) => {(-273.15, unit_name)},
            TemperatureUnit::Fahrenheit(unit_name) => {(-459.67, unit_name)},
            TemperatureUnit::Kelvin(unit_name) => {(0., unit_name)},
        };

        assert!(temperature_value >= min_allowed, "For temperature unit {}, temperature value can not be lower than {}. Temperature value passed: {}.", name, min_allowed, temperature_value);
        
        Temperature { 
            degrees: temperature_value, 
            unit: temperature_unit,
        }
    }

    /// Creates an instance of Temperature using the system temperature unit
    /// 
    /// "arg_temp" is a temperature unit
    /// 
    /// if arg_temp is different from temp_format:
    ///  - Creates a temperature instance in arg_temp unit.
    ///  - Converts to temp_format.
    ///  - Returns temperature.
    /// 
    pub fn new(temperature_value: f32, temperature_unit: &TemperatureUnit, arg_temp: Option<String>) -> Self {
        match arg_temp {
            None => {
                Temperature::new_assert(temperature_value, temperature_unit.clone())
            },
            Some(arg_string) => {
                let mut arg_temp = Temperature::new_assert(temperature_value, TemperatureUnit::new(&arg_string));

                // Convert temperature reading into system temperature unit
                arg_temp.convert(temperature_unit);
                arg_temp
            }
        }

    }

    /// Udpate temperature if different unit.
    /// 
    /// Returns true if conversion was needed.
    /// 
    pub fn update_temp_format(&mut self, temperature_unit: &TemperatureUnit) -> bool {
        let comparison = self.unit == *temperature_unit;

        if !comparison {
            self.convert(temperature_unit);
        }

        !comparison
    }
    
    /// Convert temperature units
    pub fn convert(&mut self, temperature_unit: &TemperatureUnit){
        let current_unit: TemperatureUnit = self.unit.clone();
        let current_value = self.degrees;
        
        log(&format!("Converting temperature to system format. System Unit: {}, Current Unit: {}.", temperature_unit, &current_unit));

        match (current_unit, temperature_unit) {
            (TemperatureUnit::Kelvin(_), &TemperatureUnit::Celsius(_)) => {
                // C = K − 273.15
                self.degrees = current_value - 273.15;    
                self.unit = TemperatureUnit::new("c");
            },
            (TemperatureUnit::Kelvin(_), &TemperatureUnit::Fahrenheit(_)) => {
                // F = (K – 273.15) × 9⁄5 + 32
                self.degrees = (current_value - 273.15) * 9.0 / 5.0 + 32.0;
                self.unit = TemperatureUnit::new("f");
            },
            (TemperatureUnit::Celsius(_), &TemperatureUnit::Kelvin(_)) => {
                // K = C + 273.15
                self.degrees = current_value + 273.15;
                self.unit = TemperatureUnit::new("k");
            },
            (TemperatureUnit::Celsius(_), &TemperatureUnit::Fahrenheit(_)) => {
                // F = C(9⁄5) + 32
                self.degrees = current_value * (9.0 / 5.0) + 32.0;
                self.unit = TemperatureUnit::new("f");
            },
            (TemperatureUnit::Fahrenheit(_), &TemperatureUnit::Kelvin(_)) => {
                // K = (F − 32) × 5⁄9 + 273.15
                self.degrees = (current_value - 32.0) * 5.0 / 9.0 + 273.15;
                self.unit = TemperatureUnit::new("k");
            },
            (TemperatureUnit::Fahrenheit(_), &TemperatureUnit::Celsius(_)) => {
                // C = (F − 32) × 5⁄9
                self.degrees = (current_value - 32.0) * 5.0 / 9.0;
                self.unit = TemperatureUnit::new("c");
            },
            (_, _) => {
                // all alternatives considered, therefore nothing to do
                return;
            }
        }
    }
}

'''
'''--- EN/lesson_6_enums/lesson_6_2_thermometer/src/temperature/temp_format.rs ---
//! Temperature Unit module
//! 
//! Unit can be Kelvin, Celsius or Fahrenheit.
//! The default is to use Kelvin.
//! 
//! Implemented TraitsÖ
//!  - Default. Default unit is Celsius::Kelvin.
//!  - PartialEq and Eq. Allows comparing between Units.
//!  - String::from(&temperature_unit) converts a &temperature_unit reference to String;
//!  - String::from(temperature_unit) converts temperature_unit to String;
//!  - TemperatureUnit::from("a str") converts an &str to TemperatureUnit;
//!  - TemperatureUnit::from(aString) converts a String to TemperatureUnit;
//!  - TemperatureUnit::from(&aString) converts a &String reference to TemperatureUnit;
//!  - std::fmt::Display. Allows display of value using macros like println!, format! e panic!;
//! 

use near_sdk::{
    borsh::{ self, BorshDeserialize, BorshSerialize },
    serde::{ Deserialize, Serialize },
};

/// Represents a TemperatureUnit (Kelvin, Celsius and Fahrenheit).
/// 
/// Temperature unit management, as we can have multiple sensors using different temperature units.
/// This guarantees all possibilities are in sync and correct.
/// 
/// This enum is seen a String when ser/deserialzing JSON.
/// 
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
#[serde(untagged)]
pub enum TemperatureUnit {
    Celsius(String),
    Fahrenheit(String),
    Kelvin(String),
}

impl TemperatureUnit {
    /// Creates a TemperatureUnit
    /// 
    /// Not case-sensitive. You can specify temperature units like:
    /// 
    ///  - "celsius", "c" => TempFormat::Celsius("Celsius")
    ///  - "fahrenheit", "f" => TempFormat::Fahrenheit("Fahrenheit")
    ///  - "kelvin", "k" => TempFormat::Kelvin("Kelvin")
    /// 
    /// # Panics
    /// - If unit name is invalid.
    /// 
    pub fn new(unit_name: &str) -> Self{
        // This conversion for &str to TemperatureUnit is possible due to From<&str> being implemented
        let lower_case: String = unit_name.to_ascii_lowercase();

        // let's return what matches OR panic!
        match &lower_case[..] {
            "celsius" | "c" => TemperatureUnit::Celsius(String::from("Celsius")),
            "fahrenheit" | "f" => TemperatureUnit::Fahrenheit(String::from("Fahrenheit")),
            "kelvin" | "k" => TemperatureUnit::Kelvin(String::from("Kelvin")),
            invalid_name => panic!("Invalid temperature unit name ({}). Valid args: ['Celsius', 'c', 'Fahrenheit', 'f', 'Kelvin', 'k']", invalid_name),
        }
    }
}

/// The default unit will set to Kelvin, but 
/// this can later be changed after contract initialization
/// 
impl Default for TemperatureUnit {
    fn default() -> Self {
        TemperatureUnit::new("k")
    }
}

// Allows partial comparison between temperate units
//
// A = B doesn't mean B = A
// A = B and A = C doesn't mean B = C
//
impl PartialEq for TemperatureUnit {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (TemperatureUnit::Celsius(_), TemperatureUnit::Celsius(_)) => true,
            (TemperatureUnit::Fahrenheit(_), TemperatureUnit::Fahrenheit(_)) => true,
            (TemperatureUnit::Kelvin(_), TemperatureUnit::Kelvin(_)) => true,
            (_, _) => false,
        }
    }
}

// This trait allows total comparison between temperature units
//
// A = B guarantees B = A
//
// A = B and A = C guarantees B = C
//
impl Eq for TemperatureUnit {}

/// Conversion to String fro &TemperatureUnit
impl From<&TemperatureUnit> for String{
    fn from(temperature_unit: &TemperatureUnit) -> String {
        match &temperature_unit {
            TemperatureUnit::Celsius(value) => (*value).clone(),
            TemperatureUnit::Kelvin(value) => (*value).clone(),
            TemperatureUnit::Fahrenheit(value) => (*value).clone(),
        }
    }
}

/// Conversion to String from TemperatureUnit
impl From<TemperatureUnit> for String {
    fn from(temperature_unit: TemperatureUnit) -> String {
        String::from(&temperature_unit)
    }
}

/// Conversion to TemperatureUnit from &str
impl From<&str> for TemperatureUnit{
    fn from(temperature_unit_name: &str) -> TemperatureUnit {
        TemperatureUnit::new(temperature_unit_name)
    }
}

/// Conversion to TemperatureUnit from &String
impl From<&String> for TemperatureUnit{
    fn from(temperature_unit_name: &String) -> TemperatureUnit {
        TemperatureUnit::from(&temperature_unit_name[..])
    }
}

/// Conversion to TemperatureUnit from String
impl From<String> for TemperatureUnit{
    fn from(temperature_unit_name: String) -> TemperatureUnit{
        TemperatureUnit::from(&temperature_unit_name[..])
    }
}

/// Allos displaying the enum as a String and is used by macros such as format!, println! and panic!.
impl std::fmt::Display for TemperatureUnit {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", String::from(self))
    }
}

'''
'''--- EN/lesson_6_enums/lesson_6_2_thermometer/src/utils.rs ---
//! Utilities module
//! 
//!  - log: print a message on testing or production environments (different target output)
//!  - ViewGet: allows having different return typs for the same function.
//! 

use near_sdk::serde::{
    Deserialize, Serialize,
};

use crate::entry::TemperatureReading;

#[allow(unused_imports)]
use near_sdk::env;

/// Prints using println when in a test environment. 
#[cfg(test)]
pub fn log(msg: &str){
    println!("{}", msg);
}

/// Prints using env::log when in a production environment. 
#[cfg(not(test))]
pub fn log(msg: &str) {
    env::log(msg.as_bytes());
}

/// Used as return type for view_get function
/// 
///  - If using an index returns a single temperature reading.
///  - If not using an index, then return a list of all temperature readings.
/// 
/// Not efficient when a contract has a lot of readings for a user/sensor, 
/// but best practice would be for the user to collect values locally and remove old ones
/// to save on both storage and computing fees
/// 
/// Using #[serde(untagged)] will keep our JSON very lean.
/// 
#[derive(Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
#[serde(untagged)]
pub enum ViewGet{
    Single(TemperatureReading),
    Multiple(Vec<TemperatureReading>),
}

'''
'''--- EN/lesson_6_enums/lesson_6_3_game_score/Cargo.toml ---
[package]
name = "lesson_6_3_game_score"
version = "0.1.0"
authors = ["Lucas Lemos <stiltztinkerstein@gmail.com>"]
license = "MIT"
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0"

'''
'''--- EN/lesson_6_enums/lesson_6_3_game_score/Readme.md ---
# Lesson 6 - 3 Game Score

[back](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/EN/lesson_6_enums/)

In this example, we will see how to easily escape errors using the ```#[handle_result]``` macro, and also a way to update data about several users at each update (in this case, highscores).

This lesson is a simple simulation of a possible browser "rogue-like" game. "Rogue-likes" are games where your character goes through a series of randomly generated arenas, with randomly generated rewards. A few examples of popular games like this are "The Binding of Isaac", by Edmund McMillen and Florian Himsl and "Hades", by Supergiant Games.

This contract can't be used _(yet)_ for running a real game. But it has much of the structure that could be used for such games. We will go over the structure of the contract, and I would love to have a feedback from readers about their thoughts about this example.

Each player stores information about their characters. There's information on each of their highscores, plus there's a global (limited) highscore that can be updated whenever a new one is achieved. How to best save gas doing these operations is still an open question, but I left my suggestions on this example.

---

## Topics

 - [Building](#building)
 - [Smart Contract API](#smart-contract-api)
 - [How the contract is intended to be used](#how-the-contract-is-intended-to-be-used)
 - [Error management](#error-management)
 - [What each module does](#what-each-module-does)
   - [Chapter](#chapter)
     - [Chapter Reward](#chapter-reward)
   - [Character](#character)
      - [Class](#class)
      - [Stats](#stats)
   - [Player](#player)
      - [View](#view)
    - [Score](#score)
      - [HighScore](#highscore)
      - [Ranking](#ranking)

---

## Building

[top](#topics)

This crate belongs to the workspace at lesson_6_enums. Cargo commands will affect all the crates of the workspace. To specify only this crate, include the option `-p lesson_6_3_game_score`.

Build with:

`cargo build -p lesson_6_3_game_score --target wasm32-unknown-unknown --release`

Test with:

`cargo test -p lesson_6_3_game_score --nocapture`, where `--nocapture` will show output of each test.

---

## Smart Contract API

[top](#topics)

```rust
/// Update the player state.
/// 
/// This is going to be replaced by direct pointer access later.
/// 
fn save_player(&mut self, player: &Player) -> Result<(), Errors>;

/// If a  user does not exist in the database redirect to registry
fn load_player(&self) -> Result<Player, Errors>;

/// A user that is not registered can't access the smart contract.
/// 
/// Add the predecessor to the smart contract.
#[handle_result]
pub fn register_user(&mut self) -> Result<(), Errors>

/// User must be registered before using this.
/// 
/// Create a character with given name and class.
/// 
/// classes: "Warrior" | "Druid" | "Rogue" | "Priest"
#[handle_result]
pub fn create_character(&mut self, name: String, class: String) -> Result<(), Errors>;

/// Loads and returns an instance of player.
#[handle_result]
pub fn check_status(&self) -> Result<player_view, Errors>;

/// Load a character with the given name and return it.
#[handle_result]
pub fn load_character(&self, name: String) -> Result<Character, Errors>;

/// Get current ranking.
pub fn get_ranking(&self) -> Ranking;

/// Get information about the next match.
#[handle_result]
pub fn start_match(&mut self) -> Result<Chapter, Errors>;

/// Report the match finished.
/// 
/// Some validations should be done about it.
/// 
/// Things like, you can't return a 10 minutes-long match if 10 minutes haven't gone through.
/// 
/// A report should be a replay of the entire match. Including the AI of non-player-characters.
/// 
#[handle_result]
pub fn report_match(
    &mut self, 
    character: CharacterName, 
    score: Score, 
    // validation_report: ValidationReport,
) -> Result<bool, Errors>;

/// Change how many players can be stored in the ranking. The larger the list, the more expensive sorting is.
#[handle_result]
pub fn set_max_highscore_players(&mut self, max_size: usize) -> Result<(), Errors>;
```

## How the contract is intended to be used

[top](#topics)

We're considering that the game is running on a users' browser. We can't update the game in real time, like most online games would, because of latency and costs. But, when it comes to rogue-like games, each arena is small, and is intended to be finished in a short time: 1 or 2 minutes for each arena. 

We could require, as in-game mechanics, for the arenas to run for a limited time. As the player completes each of these small chapters, the browsers sends a report, a small replay, to the smart contract. The smart contract validates this report, and only then, updates the player's state.

Since the game isn't developed yet our implementation will not receive a report for now and will always consider the validation successful. I encourage you to try implementing a simple game to check how expensive it can be. 

When it comes to ranking of players we'll store it as a small Vector. This is because computing the ranking will become exponentially more expensive the higher the number of players, so let's limit it to something like 100 or 1000 players, and sort the Vector whenever a new entry is achieved.

The first step a browser has to take is call `register_user` so the user is stored in the state. 

 - `check_status` returns information about the current player.
 - `get_ranking` returns the current ranking between players.
 - `create_character` creates a new character associated with that player.
 - `load_character` returns a character owned by that player, with the given name.
 - `start_match` returns information about the current chapter, then resets the timer.
 - `report_match` validates your replay and if successful, give rewards to your character, update highscores and moves to the next chapter.
 - The owner of the smart contract account can call `set_max_highscore_players` to change the max number of players that can exist in ranking.

## Error management

[top](#topics)

In ```/src/model/errors.rs``` we have this enum.

```rust
#[derive(FunctionError, BorshSerialize)]
pub enum Errors{
    AccountIsAlreadyRegistered(AccountId),
    AccountIsNotRegistered(AccountId),
    CharacterNotFound(String),
    CharacterAlreadyExists(String),
    InvalidChapterValidation,
    ChapterNotStarted,
    InvalidCharacterName(String),
    InvalidClassName(String),
    UserNotRegistered(AccountId),
    ExcessiveMaxRankingPlayers(usize, usize),
    OwnerOnly,
}

impl std::fmt::Display for Errors {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Errors::AccountIsAlreadyRegistered(user) => write!(f, "Username {} is already registered in the database.", user),
            Errors::AccountIsNotRegistered(user) => write!(f, "Tried to update {}, but account is not registered. This a server error, not a user error. Please report it.", user),
            Errors::CharacterNotFound(name) => write!(f, "Character with name {} not found in current account.", name),
            Errors::CharacterAlreadyExists(name) => write!(f, "A character with name {} already exists in this account.", name),
            Errors::InvalidChapterValidation => write!(f, "Failed to validate chapter report"),
            Errors::ChapterNotStarted => write!(f, "Can't attempt to validate chapter without first starting the match."),
            Errors::InvalidCharacterName(name) => write!(f, "Character name starts with an invalid character ({}).", name),
            Errors::InvalidClassName(name) => write!(f, "Invalid name ({}) for character class.", name),
            Errors::UserNotRegistered(user) => write!(f, "User {} needs to create an account before using this service.", user),
            Errors::ExcessiveMaxRankingPlayers(selected, maximum) => write!(f, "Computing ranking is expensive. Can't be higher than {}. Attempted {}.", maximum, selected),
            Errors::OwnerOnly => write!(f, "Only owner may call this function."),
        }
    }
}
```

Each possible value for this enum represents an error that might happen in our project. The trait `std::fmt::Display` is used for turning a type into a String when we use macros like `println!` and `format!`. 

We also derive a new trait called `FunctionError`, and thanks to this trait we don't need to manually call ```env::panic_str``` or assert statements whenever something in the code breaks; we just return the error and the deserializer will raise the error for us. 

```rust
/// User must be registered before using this.
/// 
/// Create a character with given name and class.
/// 
/// classes: "Warrior" | "Druid" | "Rogue" | "Priest"
/// 
#[handle_result]
pub fn create_character(&mut self, name: String, class: String) -> Result<(), Errors> {
    log!("Create Character function called.");
    
    let class: Class = Class::new(&class)?;
    let character: Character = Character::new(name, class)?;
    let mut player: Player = self.load_player()?;

    player.assign_character(character)?;

    self.save_player(&player)?;

    log!("Character successfully created.");

    Ok(())
}
```

In this example for creating characters, keep an eye out on three things:
 - The function returns `Result<(), Errors>`.
 - The `#[handle_result]` macro on top of the contract function.
 - `?` operators.

The `?` operator is useful for both Option and Result enums.
 - If we use it with `Option`, it unwraps the value or panics if it's `None`.
 - If we use it with `Result`, it unwraps the value or returns the error type as `Err`.

Notice that the return type of each of the functions with the `?` operator is a `Result` with the same `Err` type as this function (which is `Errors`).

This is a very clean way of handling errors. Don't you agree? We know where the errors are coming from. And we are not cluttering our code with error checking.

Having one enum to represent all the errors in the entire smart contract could easily get bloated in large projects. But that's easy to fix! Just have errors within errors, an enum that contains another enum. 
Create a method that wraps the smaller error into the larger error.

## What each module does

[top](#topics)

Some of these modules are very simple and can be easily expanded. The intention of this lesson is to offer an example of a game architecture, not the game itself. To offer inspiration on this uncharted web3 territory. The less specific the game mechanics are, the easier it is to incorporate to multiple different games.

### Chapter

[top](#topics)

This module represents a single chapter of the game. Each chapter is a small arena that the player stays for a limited time (e.g. 2 minutes). Rogue-like games include randomly generated elements in each chapter. Like random enemies, random bonuses for the player, random rewards, etc.

The `Chapter` type can be seen below: 

```rust
// Calculates score/rewards for each match (chapter)
/// This is meant to represent a game chapter. Each has it's own rewards. Each has it's own validation method.
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub enum Chapter{
    Chapter1(Option<u64>),
    Chapter2(Option<u64>),
    Chapter3(Option<u64>),
}
```

Each Chapter represents a unique "arena". The value within the tuple is used to count match length. 

When a player calls the function "start_match", the tuple stores when the match started. When the player calls "report_match", the chapter will calculater running time `(time_when_finished - time_when_started)` to make sure that the game wasn't run by a machine. 

Let's see how this works: imagine the player calls `start_match`, then, two seconds later, calls `validate_match` with a report that technically lasted two minutes.

The smart contract can't allow that. So, if the time in the report is greater than the time it took since the match started, the contract will panic. That's the only reason for storing time in a chapter.

If the validation is successful, then reward is awarded to the character.

#### Chapter reward

[top](#topics)

Chapter Reward calculates how much "EXP (experience)" was earned from a chapter. 

```rust
pub struct ChapterReward{
    /// Base exp reward.
    pub exp: EXP,
    /// More exp the higher the score.
    pub score_multiplier: f32,
    /// The level character is expected to be.
    pub expected_level: Level,
    /// Less exp the higher the level. More exp the lower the level.
    pub level_multiplier: f32,
}
```

 - `exp`: How much base EXP is earned from this match. Regardless of player performance, they will always receive at least this amount.
 - `expected_level`: What level the player is expected to be at, before starting this chapter. Lower levels means harder matches, so higher rewards.
 - `level_multiplier`: For each level of difference, this will be multiplied an extra time, up to 5 times. Check the values in the tests to see some examples.
 - `score_multiplier`: The higher the score, the more exp. This is a  multiplier that applies to the score.

Check the implementation of `Chapter::compute_reward` for more information on how the bonuses are implemented.

### Character

[top](#topics)

Contains basic information about a game character. Each player has their own list of characters.

```rust
// Attributes are ordered according to priority here, not alphabetic order

/// Represents a playable character in the game.
#[derive(Clone, BorshDeserialize, BorshSerialize, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Character{
    name: Name,
    class: Class,
    level: Level,
    xp: EXP,
    stats: Stats,
    high_score: Score,
}
```

 - `name`: character's name. Will be show on high scores.
 - `class`: class is a model for how a character is built and what it can do later.
 - `level`: character's progression is marked by it's level. Exp raises this value automatically.
 - `xp`: how much exp this character has. Each new level resets this value.
 - `stats`: character actions are determined by their stats. 
 - `high_score`: the highest score achieved by the player in any chapter. If a new highscore is achieved, it will be sent for a comparison with the ranking of players.

#### Class

[top](#topics)

A few examples of classes just to show how each could affect stats in a unique way.

```rust
/// classes: "Warrior" | "Druid" | "Rogue" | "Priest".
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub enum Class{
    Warrior,
    Druid,
    Rogue,
    Priest,
}
```

We implement a constructor:

```rust
impl Class{
    pub fn new(class: &str) -> Result<Class, Errors> {
        let class = match &class.to_ascii_lowercase()[..]{
            "warrior" => { Class::Warrior },
            "druid" => { Class::Druid },
            "rogue" => { Class::Rogue },
            "priest" => { Class::Priest },
            invalid => { return Err(Errors::InvalidClassName(String::from(invalid))) },
        };

        Ok(class)
    }
}
```

Notice how this returns a `Rethe where th; jrror is of type ``Erthe`. Thi; js because we use the `?` operator in the contract methods. There's no need to manually raise errors in the implementation; just return a `Result::Err` instead.

Some type conversions below:

```rust
impl From<&str> for Class{
    fn from(class: &str) -> Class{
        match Class::new(class) {
            Ok(valid) => valid,
            Err(err) => env::panic_str(&format!("{}", err)),
        }
    }
}

impl From<String> for Class{
    fn from(class: String) -> Class {
        Class::from(&class[..])
    }
}

impl From<&String> for Class{
    fn from(class: &String) -> Class{
        Class::from(&class[..])
    }
}

impl From<&Class> for String {
    fn from(class: &Class) -> String {
        let name = match *class{
            Class::Druid => "Druid",
            Class::Priest => "Priest",
            Class::Rogue => "Rogue",
            Class::Warrior => "Warrior",
        };

        String::from(name)
    }
}
```

These are trait implementations for converting one type to another.

`From<&String> for Class` will allow us to pick a string, then attempt to convert it into a class through the function `from`. Here is an example:

```rust
let a = "Druid";
let b: Class = Class::from(a);
```

In the example above we create a `&str` with value "Druid", then create a class using that string slice. 

We implement owned Strings, move on to references of String and finally we end up doing conversion from a reference Class to a String (the reverse way).

#### Stats

[top](#topics)

Stats represent what your character can do in the arena. The success rate of each of their actions. To be used in chapter validation.

Because of the classes shown above. We want to show that each affect the stats in a unique way. So we chose these 3 basic stats: dexterity, strength and inteligence.

```rust
/// The stats of the character that details how character behavior performs.
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Stats{
    dexterity: u32,
    // How much it increases each level
    dexterity_rate: u32,
    // The value at level 1
    dexterity_base: u32,
    strength: u32,    
    strength_rate: u32,
    strength_base: u32,
    intelligence: u32, 
    intelligence_rate: u32,
    intelligence_base: u32,
}
```

Base is the minimum value for that stat. Rate is how much that stat grows with each level. By calling the method `Stats::update` we update the value of each stat whenever the character levels up.

### Player

[top](#topics)

Each user represents one instance of `Player`.

```rust
/// Holds information pertaining to a single user.
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Player{
    name: Name,
    high_score: Option<HighScore>,
    // For storing and checking characters by name, doesn't supports iteration
    characters: LookupMap<character::Name, Character>,
    // For storing character names, supports iteration
    character_names: UnorderedSet<character::Name>,
    // With both those above, we can check characters O(1) and iterate through the characters at the same time.
    latest_chapter: Chapter,
}
```

 - `name`: name of the player;
 - `high_score`: high score achieved by the player. `None` if no chapter has been played yet.
 - `characters`: all characters owned by this player;
 - `character_names`: list of character names owned by the player;
 - `latest_chapter`: the next chapter the player is about to play;

The `LookupMap` is constant _O(1)_ for getting and inserting values. The ```UnorderedSet``` is used for iterating through the names. Both are updated simultaneously.

#### View

[top](#topics)

The collections for `characters` and `character_names` can't be serialized to readable json. So we create this type just to use as a return type.

```rust
/// This type exists only needs to be returned when player makes a GET request for their own data.
#[derive(Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct View {
    pub name: player::Name,
    pub high_score: Option<HighScore>,
    pub characters: Vec<Character>,
}
```

We only get player name, highscore and a list of characters for the view, which is all the player needs.

`Vec` is a collection that can be serialized with `serde`. It is updated every time the list of characters changes and its cost increases exponentially the higher the number of characters, so limiting the number of characters is recommended.

### Score

There are two types in this module: HighScore and Ranking.

#### HighScore

[top](#topics)

Represents a character or player's highscore.

```rust
/// Represents a highscore for a player or character.
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct HighScore{
    character: Character,
    score: Score,
    player: AccountId,
}
```

The most important topic to discuss for this type is the following method:

```rust
/// Makes a comparison between the new and old high scores. If a new high_score for the player is achieved
/// update current and return a copy.
pub fn update_highscore(
    current_highscore: &mut Option<HighScore>,
    new_high_score: Option<HighScore>,
) -> Result<Option<HighScore>, Errors> {

    // This match will stop assigning the new highscore if one has not been achieved.
    match (&current_highscore, &new_high_score) {
        (_, None) => { 
            // No highscore was achieved by the character.
            return Ok(None); 
        },
        (None, Some(_)) => {},
        (Some(old_high_score), Some(new_high_score)) => {
            // A character achieved a highscore
            // there is a highscore recorded.
            // makes a comparison and maintain the highest.
            if old_high_score > new_high_score {
                return Ok(None);
            }
        },
    }

    // assign the new highscore
    *current_highscore = new_high_score.clone();

    return Ok(new_high_score);
}
```

Both player and character store an `Option<HighScore>`. So, instead of making functions that pass `HighScore` as arguments we have just one that receives `Option<HighScore>` instead.

When a report is validated, a new highscore for the character may be achieved, so we check all the player's highscores, to confirm if a new highscore for the player was achieved. If this happened, we check if the player highscore is among the ranking of top highscores.

Notice how ranking is only calculated when players achieve their highest score. That saves a lot of computing.

So, `HighScore::update_highscore` receives the current highscore and the latest possible highscore. If latest is higher than the current, we update the current and return a copy.

There is also the possibility of any of these being `None`. Maybe no highscore was achieved. Maybe there were no highscores before this one. The function considers both cases.

#### Ranking

[top](#topics)

Ranking is stored as a vector of `HighScore`. The maximum number of elements stored is limited to reduce sorting costs.

```rust
/// Contains the top ranked matches stored in the smart contract.
/// 
/// It's just a vector. So to avoid high costs sorting.
/// 
/// We limit the max number of entries to RANKSIZE.
/// 
/// Suggestion for change. Store the score of the lowest highscore in the ranking. 
/// Only update and sort the list when a value higher than such is included.
#[derive(BorshDeserialize, BorshSerialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Ranking{
    values: Vec<HighScore>,
    max_size: usize,
    lowest_high_score: Option<HighScore>,
}
```

When a player achieves a new `HighScore`, this function runs: 

```rust
pub fn check_highscore(
    &mut self, 
    high_score: &Option<HighScore>,
) -> bool {
    match high_score {
        None => { 
            // Player didn't achieve a high score.
            false
        },
        Some(high_score) => {
            log!("New High Score for this Player.");

            // Compiler will apply branchless optimization to all these if/else statements.
            if self.lowest_high_score.is_none() {
                // This is the first entry, so just include it.
                self.new_entry(high_score.clone());

                return true;
            } else {
                // This is not the first entry.
                // The list may be full or not.
                let ranking_is_full: bool = self.values.len() == self.max_size;

                if !ranking_is_full {
                    // If the list is not full, just include it.
                    self.new_entry(high_score.to_owned());

                    return true;
                } else {
                    // .unwrap will never panic because of the first "if" above. It is always Some.
                    // We are cloning because unwrap will take ownership of this mutable reference.
                    let lowest_high_score = self.lowest_high_score
                        .clone()
                        .unwrap();

                    if lowest_high_score < *high_score {
                        self.new_entry(high_score.clone());

                        return true;
                    }
                    
                    false
                }
            }
        }
    }
}
```

In summary, what this method does is:
 - If a new HighScore is **not** achieved, do nothing.
 - If the list is empty, just include the entry.
 - If the list is not full, just include the entry.
 - If the list is full, before including the entry, only include if the value is higher than the lowest 
entry in the list.

Each inclusion in the list will result in the list being sorted. Comparison with the lowest entry helps reduce computing costs.

---

Lesson 6 - Game Score :white_check_mark: ... **Done! Congratulations!**

'''
'''--- EN/lesson_6_enums/lesson_6_3_game_score/src/lib.rs ---
use near_sdk::{
    AccountId,
    borsh::{self, BorshDeserialize, BorshSerialize},
    collections::{
        LookupMap, 
    },
    env,
    log,
    near_bindgen,
};

mod model;

use crate::{
    model::{
        character::{
            Character,
            Class,
            Name as CharacterName,
        },
        Errors,
        Chapter,
        player_view,
        Player,
        score::{
            HighScore,
            Score,
            Ranking,
        },
        StorageKey,
    }
};

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Contract {
    players: LookupMap<AccountId, Player>,

    ranking: Ranking,
}

// initialize colletions
impl Default for Contract {
    fn default() -> Self {
        let players: LookupMap<AccountId, Player> = LookupMap::new(StorageKey::Players);
        let ranking: Ranking = Ranking::default();

        Contract{
            players,
            ranking,
        }
    }
}

#[near_bindgen]
impl Contract{

    fn is_owner() -> bool {
        let predecessor_account_id: AccountId =  env::predecessor_account_id();
        let current_account_id: AccountId = env::current_account_id();

        predecessor_account_id == current_account_id
    }

    /// Guarantees that the user is not registered.
    fn assert_user_not_registered(&self) -> Result<(), Errors> {
        let predecessor_account_id = env::predecessor_account_id();

        if self.players.contains_key(&predecessor_account_id) ||  Self::is_owner() {
            // Panic because account already exists.
            return Err(Errors::AccountIsAlreadyRegistered(predecessor_account_id));
        }

        Ok(())
    }

    fn assert_user_registered(&self) -> Result<(), Errors> {
        if Self::is_owner(){
            return Ok(());
        }

        let predecessor_account_id = env::predecessor_account_id();

        if ! self.players.contains_key(&predecessor_account_id) {
            // Panic because account already exists.
            return Err(Errors::AccountIsNotRegistered(predecessor_account_id));
        }

        Ok(())
    }

    /// Update the player state.
    /// 
    /// This is going to be replaced by direct pointer access later.
    /// 
    fn save_player(&mut self, player: &Player) -> Result<(), Errors>{
        self.assert_user_registered()?;

        let predecessor_account_id: AccountId = env::predecessor_account_id();

        self.players.insert(&predecessor_account_id, player).unwrap();

        Ok(())
    }

    /// If user does not exist in the database. Ask for registry.
    fn load_player(&self) -> Result<Player, Errors>{
        let predecessor_account_id = env::predecessor_account_id();

        match self.players.get(&predecessor_account_id){
            None => Err(Errors::UserNotRegistered(predecessor_account_id)),
            Some(player) => Ok(player),
        }
    }

    

    /// A user that is not registered can't access the smart contract.
    /// 
    /// Add the predecessor to the smart contract.
    #[handle_result]
    pub fn register_user(&mut self) -> Result<(), Errors> {
        log!("Register User function called.");
        self.assert_user_not_registered()?;

        // While technically we are calling env::predecessor_account_id twice, LLVM compiler will optimize it away.
        // We can write both low level and high level code efficiently in rust. 
        // We just need to decide when a function represents a low level or high level need.
        let predecessor_account_id = env::predecessor_account_id();
        let player = Player::default();
        assert!(self.players.insert(&predecessor_account_id, &player).is_none(), "Smart contract error: Expected None after asserting user is not registered. Got some.");

        log!("User successfully registered.");
        
        Ok(())
    }

    /// User must be registered before using this.
    /// 
    /// Create a character with given name and class.
    /// 
    /// classes: "Warrior" | "Druid" | "Rogue" | "Priest"
    /// 
    #[handle_result]
    pub fn create_character(&mut self, name: String, class: String) -> Result<(), Errors> {
        log!("Create Character function called.");
        
        let class: Class = Class::new(&class)?;
        let character: Character = Character::new(name, class)?;
        let mut player: Player = self.load_player()?;

        player.assign_character(character)?;

        self.save_player(&player)?;

        log!("Character successfully created.");

        Ok(())
    }

    /// Loads and returns an instance of player.
    #[handle_result]
    pub fn check_status(&self) -> Result<player_view, Errors>{
        log!("Check Player Status function called.");

        Self::load_player(&self)?
            .get_view()
    }

    /// Load a character with the given name and return it.
    #[handle_result]
    pub fn load_character(&self, name: String) -> Result<Character, Errors> {
        let player = self.load_player()?;

        player.load_character(name)
    }

    /// Get current ranking.
    pub fn get_ranking(&self) -> Ranking {
        self.ranking.clone()
    }

    /// Get information about the next match.
    #[handle_result]
    pub fn start_match(&mut self) -> Result<Chapter, Errors> {
        log!("Start Match function called.");

        let mut player = self
            .load_player()?;

        let chapter = player.start_match();

        self.save_player(&player)?;

        Ok(chapter)
    }

    /// Report the match finished.
    /// 
    /// Some validations should be done about it.
    /// 
    /// Things like, you can't return a 10 minutes-long match if 10 minutes haven't gone through.
    /// 
    /// A report should be a replay of the entire match. Including the AI of non-player-characters.
    /// 
    #[handle_result]
    pub fn report_match(
        &mut self, 
        character: CharacterName, 
        score: Score, 
        // validation_report: ValidationReport,
    ) -> Result<bool, Errors>{
        log!("Report Match function called.");

        let mut player: Player = self.load_player()?;

        let high_score: Option<HighScore> = player.report_match(character, score)?;

        self.save_player(&player)?;

        // So, if player didn't achieve a highscore of their own, it won't checked in the rankings. 
        // This is to stop a few players from overwhelming the ranking with their name.
        Ok(self.ranking.check_highscore(&high_score))
    }

    /// Change how many players can be stored in the ranking. The larger the list, the more expensive sorting is.
    #[handle_result]
    pub fn set_max_highscore_players(&mut self, max_size: usize) -> Result<(), Errors> {
        if env::signer_account_id() != env::current_account_id() {
            return Result::Err(Errors::OwnerOnly);
        }

        self.ranking.set_max_highscore_players(max_size)?;

        Ok(())
    }
}
'''
'''--- EN/lesson_6_enums/lesson_6_3_game_score/src/model/chapter/mod.rs ---
mod reward;

use near_sdk::{
    borsh,
    borsh::{ BorshDeserialize, BorshSerialize },
    env,
    serde::{ Deserialize, Serialize },
};

pub use reward::ChapterReward;
use crate::model::{
    character::{
        Character,
        EXP,
    },
    score::Score,
    Errors,
};

// Calculates score/rewards for each match (chapter)
/// This is meant to represent a game chapter. Each has it's own rewards. Each has it's own validation method.
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub enum Chapter{
    Chapter1(Option<u64>),
    Chapter2(Option<u64>),
    Chapter3(Option<u64>),
}

impl Default for Chapter{
    fn default() -> Self {
        Chapter::Chapter1(None)
    }
}

impl Chapter {
    fn get_time(&self) -> Option<u64> {
        match self{
            Chapter::Chapter1(value) => value.clone(),
            Chapter::Chapter2(value) => value.clone(),
            Chapter::Chapter3(value) => value.clone(),
        }
    }

    /// Used by Self::clear_time and Self::start_time. Change the value of the last time a match was started.
    fn set_time(&mut self, value: Option<u64>) {
        *self = match self{
            Chapter::Chapter1(_) => Self::Chapter1(value),
            Chapter::Chapter2(_) => Self::Chapter2(value),
            Chapter::Chapter3(_) => Self::Chapter3(value),
        };
    }

    /// Used after reporting. Means that no match is going at the moment.
    fn stop_time(&mut self) {
        self.set_time(None);
    }

    /// Used when loading a chapter. Get the latest time for starting the match. Report can't have a longer time than this.
    fn start_time(&mut self) {
        let current_time_ms: u64 = env::block_timestamp_ms();

        self.set_time(Some(current_time_ms));
    }

    /// Returns the multipliers for each chapter reward.
    pub fn check_reward(&self) -> ChapterReward {
        match self {
            Chapter::Chapter1(_) => {
                ChapterReward::new(
                    10, 
                    0.9, 
                    1, 
                    0.9,
                )
            },
            Chapter::Chapter2(_) => {
                ChapterReward::new(
                    100, 
                    0.9, 
                    5, 
                    0.9,
                )
            },
            Chapter::Chapter3(_) => {
                ChapterReward::new(
                    1000, 
                    0.9, 
                    10, 
                    0.9,
                )
            },
        }
    }

    
    /// Doesn't do anything in this tutorial.
    /// 
    /// The idea is that the user will send a report that includes everything that happened during the match.
    /// 
    /// The contract guarantees that the user didn't attempt to cheat at the game.
    /// 
    fn validate_get_reward(
        &self,
        _character: &Character,
        _score: &Score,
        // Validation_report: EncryptedValidationType,
    ) -> Result<ChapterReward, Errors> {

        if self.get_time().is_none(){
            return Err(Errors::ChapterNotStarted);
        }

        // Do something with the validation_report and given character and score.
        // validation_report should be a block of bytes signed with a public key owned by the smart contract.
        // The report should have information about everything that happened in the match.
        // Since the gameplay happens in the browser. It's very easy for the user to cheat and send a fake report.
        // So maybe the report should be an entire replay of the match.
        //
        // One useful check that could be done is making sure that the match between start and report can't

        
        Result::Ok(
            Self::check_reward(&self)
        )
    }

    /// Can only be called after the timer has started (with Self::start_match). Receives a chapter report and validates it before returning rewards.
    pub fn validate_match(
        &mut self, 
        character: &Character, 
        score: &Score,
        // Validation_report: ValidationReport,
    ) -> Result<EXP, Errors> {
        let reward = self.validate_get_reward(character, score)?;

        self.stop_time();
        Ok(reward.compute_reward(character.get_level(), score))
    }

    /// Go to the next chapter and stop the timer.
    pub fn next_match(&mut self) {
        *self = match self {
            Chapter::Chapter1(_) => Chapter::Chapter2(None),
            Chapter::Chapter2(_) => Chapter::Chapter3(None),
            Chapter::Chapter3(_) => Chapter::Chapter1(None),
        };
    }

    /// Start match timer. Needed for validation.
    pub fn start_match(&mut self) -> Self {
        self.start_time();

        self.clone()
    }

}

#[cfg(test)]
mod tests{
    use super::Chapter;

    fn new_chapter_1() -> Chapter{
        Chapter::default()
    }

    fn new_chapter_2() -> Chapter {
        let mut chapter = Chapter::default();
        chapter.next_match();
        chapter
    }

    fn new_chapter_3() -> Chapter {
        let mut chapter = Chapter::default();
        chapter.next_match();
        chapter.next_match();
        chapter
    }

    fn assert_chapter_number(chapter: &Chapter, number: u8) {
        if number < 1 && number > 3 {
            panic!("Invalid argument for test. Chapter can only be 1, 2 or 3.")
        }

        match chapter {
            Chapter::Chapter1(_) => assert!(number == 1),
            Chapter::Chapter2(_) => assert!(number == 2),
            Chapter::Chapter3(_) => assert!(number == 3),
        }
    }

    #[test]
    fn chapter_next_chapter() {
        let (chapter1, chapter2, chapter3) = (
            new_chapter_1(),
            new_chapter_2(),
            new_chapter_3(),
        );

        assert_chapter_number(&chapter1, 1);
        assert_chapter_number(&chapter2, 2);
        assert_chapter_number(&chapter3, 3);
    }

    #[test]
    fn chapter_clear_timer() {
        
        let (mut chapter1, mut chapter2, mut chapter3) = (
            new_chapter_1(),
            new_chapter_2(),
            new_chapter_3(),
        );

        chapter1.start_match();
        chapter2.start_match();
        chapter3.start_match();

        assert!(chapter1.get_time().is_some());
        assert!(chapter2.get_time().is_some());
        assert!(chapter3.get_time().is_some());

        chapter1.stop_time();
        chapter2.stop_time();
        chapter3.stop_time();

        assert!(chapter1.get_time().is_none());
        assert!(chapter2.get_time().is_none());
        assert!(chapter3.get_time().is_none());
    }

}
'''
'''--- EN/lesson_6_enums/lesson_6_3_game_score/src/model/chapter/reward.rs ---
use crate::model::{
    character::{
        EXP,
        Level,
    },
    score::Score,
};

pub struct ChapterReward{
    /// Base exp reward.
    pub exp: EXP,
    /// More exp the higher the score.
    pub score_multiplier: f32,
    /// The level character is expected to be.
    pub expected_level: Level,
    /// Less exp the higher the level. More exp the lower the level.
    pub level_multiplier: f32,
}

impl ChapterReward{
    
    /// Returns the proportion of extra EXP based on level difference.
    /// 
    /// Max difference is 5.
    /// 
    /// If level is higher than expected, receive less EXP.
    /// 
    /// If level is lower, receive more EXP.
    /// 
    fn compute_level_multiplier(
        mut multiplier: f32, 
        level: Level, 
        expected_level: Level,
    ) -> f32{
        let mut difference = level as f32 - expected_level as f32;

        let result: f32 = 1.0;

        // As example, if proportion is 0.9, having a lower level will multiply the bonus by 1.1 per level (up to 5)
        // 0.8 would multiply the bonus by 1.2/level (up to 5).
        if difference < 0. {
            multiplier = 2. - multiplier;
            difference *= -1.;
        }

        if difference >= 5. {
            return result * multiplier * multiplier * multiplier * multiplier * multiplier
        }
        if difference >= 4. {
            return result * multiplier * multiplier * multiplier * multiplier
        }
        if difference >= 3. {
            return result * multiplier * multiplier * multiplier
        }
        if difference >= 2. {
            return result * multiplier * multiplier
        }

        if difference >= 1. {
            return result * multiplier
        }

        result
    }

    pub fn new(
        exp: EXP,
        score_multiplier: f32,
        expected_level: Level,
        level_multiplier: f32,
    ) -> Self {

        ChapterReward { 
            exp, 
            score_multiplier, 
            expected_level, 
            level_multiplier,
        }
    }

    pub fn compute_reward(
        &self, 
        character_level: Level,
        score: &Score,
    ) -> EXP {
        let exp = self.exp;
        let score_bonus = self.score_multiplier * *score as f32;

        let expected_level = self.expected_level;
        let level_multiplier = self.level_multiplier;

        let computed_multiplier = Self::compute_level_multiplier(
            level_multiplier, 
            character_level,
            expected_level,
        );

        ((exp as f32 + score_bonus as f32) * computed_multiplier) as EXP
    }
}

#[cfg(test)]
mod tests{
    use super::ChapterReward;

    fn setup_test() -> ChapterReward {
        let (
            exp,
            score_multiplier,
            expected_level,
            level_multiplier,
        ) = (10, 0.8, 10, 0.9);

        ChapterReward::new(exp, score_multiplier, expected_level, level_multiplier)
    }

    #[test]
    fn chapter_reward_new(){
        
        let chapter_reward: ChapterReward = setup_test();

        assert_eq!(chapter_reward.exp, 10);
        assert_eq!(chapter_reward.score_multiplier, 0.8);
        assert_eq!(chapter_reward.expected_level, 10);
        assert_eq!(chapter_reward.level_multiplier, 0.9);
    }

    #[test]
    fn chapter_reward_compute_reward(){
        let chapter_reward: ChapterReward = setup_test();

        // Lower level means more exp, up to 5 levels of difference.
        assert_eq!(chapter_reward.compute_reward(10, &100), 90);
        assert_eq!(chapter_reward.compute_reward(9, &100), 99);
        assert_eq!(chapter_reward.compute_reward(8, &100), 108);
        assert_eq!(chapter_reward.compute_reward(7, &100), 119);
        assert_eq!(chapter_reward.compute_reward(6, &100), 131);
        assert_eq!(chapter_reward.compute_reward(5, &100), 144);
        assert_eq!(chapter_reward.compute_reward(4, &100), 144);
        assert_eq!(chapter_reward.compute_reward(3, &100), 144);
        assert_eq!(chapter_reward.compute_reward(2, &100), 144);

        // Higher level means less exp, up to 5 levels of difference.
        assert_eq!(chapter_reward.compute_reward(10, &100), 90);
        assert_eq!(chapter_reward.compute_reward(11, &100), 81);
        assert_eq!(chapter_reward.compute_reward(12, &100), 72);
        assert_eq!(chapter_reward.compute_reward(13, &100), 65);
        assert_eq!(chapter_reward.compute_reward(14, &100), 59);
        assert_eq!(chapter_reward.compute_reward(15, &100), 53);
        assert_eq!(chapter_reward.compute_reward(16, &100), 53);
        assert_eq!(chapter_reward.compute_reward(17, &100), 53);
        assert_eq!(chapter_reward.compute_reward(18, &100), 53);
    }
}
'''
'''--- EN/lesson_6_enums/lesson_6_3_game_score/src/model/character/class.rs ---
use near_sdk::{
    borsh::{
        BorshDeserialize,
        BorshSerialize,
        self,
    },
    serde::{ Deserialize, Serialize },
};

use near_sdk::env;

use crate::model::{
    character::Stats,
    Errors,
};

/// classes: "Warrior" | "Druid" | "Rogue" | "Priest".
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub enum Class{
    Warrior,
    Druid,
    Rogue,
    Priest,
}

impl From<&str> for Class{
    fn from(class: &str) -> Class{
        match Class::new(class) {
            Ok(valid) => valid,
            Err(err) => env::panic_str(&format!("{}", err)),
        }
    }
}

impl From<String> for Class{
    fn from(class: String) -> Class {
        Class::from(&class[..])
    }
}

impl From<&String> for Class{
    fn from(class: &String) -> Class{
        Class::from(&class[..])
    }
}

impl From<&Class> for String {
    fn from(class: &Class) -> String {
        let name = match *class{
            Class::Druid => "Druid",
            Class::Priest => "Priest",
            Class::Rogue => "Rogue",
            Class::Warrior => "Warrior",
        };

        String::from(name)
    }
}

impl Class {
    pub fn new(class: &str) -> Result<Class, Errors> {
        let class = match &class.to_ascii_lowercase()[..]{
            "warrior" => { Class::Warrior },
            "druid" => { Class::Druid },
            "rogue" => { Class::Rogue },
            "priest" => { Class::Priest },
            invalid => { return Err(Errors::InvalidClassName(String::from(invalid))) },
        };

        Ok(class)
    }

    /// Return base stats for given class, used by Character;
    pub fn get_stats(&self) -> Stats {

        let (
            dexterity_base,
            strength_base,
            inteligence_base,
            strength_rate,
            dexterity_rate,
            inteligence_rate,
        ) = match self{
            Class::Druid => (
                5,
                7,
                7,
                1,
                2,
                2,
            ),
            Class::Priest => (
                4,
                5,
                7,
                1,
                2,
                1,
            ),
            Class::Rogue => (
                8,
                4,
                4,
                2,
                1,
                1,
            ),
            Class::Warrior => (
                4,
                8,
                4,
                1,
                2,
                1,
            ),
        };

        Stats::new(
            dexterity_base,
            dexterity_rate,
            strength_base,
            strength_rate,
            inteligence_base,
            inteligence_rate,
        )
    }
}

'''
'''--- EN/lesson_6_enums/lesson_6_3_game_score/src/model/character/mod.rs ---
use near_sdk::{
    borsh::{ BorshDeserialize, BorshSerialize, self,},
    env,
    serde::{ Deserialize, Serialize },
};

mod class;
mod stats;

pub(crate) use class::Class;
pub(crate) use stats::Stats;

use crate::model::{
    Errors,
    score::{
        Score,
        // HighScore,
    },
};

use super::score::HighScore;

pub type Name = String;
pub type EXP = u32;
pub type Level = u32;

// Attributes are ordered according to priority here, not alphabetic order

/// Represents a playable character in the game.
#[derive(Clone, BorshDeserialize, BorshSerialize, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Character{
    name: Name,
    class: Class,
    level: Level,
    xp: EXP,
    stats: Stats,
    high_score: Score,
}

impl Character {

    fn update_level(&mut self) {
        let level: u32 = self.level;

        // just an exponential function to work as an example of how level scaling could work.
        // It gets exponentially higher each level. Level 1 requirement is 100.
        let next_level: u32 = 100 + level * 10 + 3 * level * level;

        if self.xp >= next_level { 
            self.level += 1;
            self.xp -= next_level;
            self.stats.update(self.level);
        }
    }

    /// Create a new character to be used by the player.
    pub fn new(name: Name, class: Class) -> Result<Character, Errors> {
        let level: Level = 1;
        let xp: EXP = 0;
        let stats: Stats = Stats::from(&class);
        let high_score: Score = 0;

        let first_character = &name[0..1];
        match first_character{
            "" => Err(Errors::InvalidCharacterName(name)),
            _ => Ok(Character {
                name,
                class,
                level,
                xp,
                stats,
                high_score,
            })
        }

        
    }

    pub fn get_name(&self) -> Name {
        self.name.clone()
    }

    pub fn get_class(&self) -> Class {
        self.class.clone()
    }

    pub fn get_level(&self) -> Level {
        self.level.clone()
    }

    pub fn get_xp(&self) -> EXP {
        self.xp.clone()
    }

    pub fn get_stats(&self) -> Stats {
        self.stats.clone()
    }

    pub fn get_high_score(&self) -> Score {
        self.high_score.clone()
    }

    pub fn reward_exp(&mut self, exp: EXP) {
        self.xp += exp;
        self.update_level();
    }

    /// Makes a comparison with the highscore. 
    /// 
    /// 
    /// If a highscore is achieved, return it.
    /// 
    /// Else return None.
    /// 
    pub fn check_highscore(&mut self, score: Score) -> Option<HighScore> {

        if score > self.high_score {
            self.high_score = score;
            let player = env::predecessor_account_id();

            let high_score: HighScore = HighScore::new(score, &self, player);

            return Some(high_score);
        }

        None
    }

}

'''
'''--- EN/lesson_6_enums/lesson_6_3_game_score/src/model/character/stats.rs ---
use near_sdk::{
    borsh::{
        BorshDeserialize,
        BorshSerialize,
        self,
    },
    serde::{ Deserialize, Serialize },
};

use crate::model::character::Class;

/// The stats of the character that details how character behavior performs.
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Stats{
    dexterity: u32,
    // How much it increases each level
    dexterity_rate: u32,
    // The value at level 1
    dexterity_base: u32,
    strength: u32,    
    strength_rate: u32,
    strength_base: u32,
    intelligence: u32, 
    intelligence_rate: u32,
    intelligence_base: u32,
}

impl Stats{
    pub fn new(
        dexterity_base: u32,
        dexterity_rate: u32,
        strength_base: u32,
        strength_rate: u32,
        intelligence_base: u32,
        intelligence_rate: u32,
    ) -> Self {
        let (dexterity, strength, intelligence) = (dexterity_base, strength_base, intelligence_base);

        Stats { 
            dexterity, 
            dexterity_rate,
            dexterity_base,
            strength,
            strength_rate,
            strength_base,
            intelligence,
            intelligence_rate,
            intelligence_base,
        }
    }

    pub fn update(&mut self, level: u32) {
        // dexterity, strength, inteligence
        // all these temporary variables won't exist in the machine code.
        // LLVM compiler optimizes these things away.
        // So don't worry about making your code more readable.

        let dexterity: u32 = self.dexterity_base + self.dexterity_rate * level;
        let strength: u32 = self.strength_base + self.strength_rate * level;
        let inteligence: u32 = self.intelligence_base + self.intelligence_rate * level;

        self.dexterity = dexterity;
        self.strength = strength;
        self.intelligence = inteligence;
    }
}

impl From<&Class> for Stats {
    fn from(class: &Class) -> Stats {
        class.get_stats()
    }
}

impl From<Class> for Stats {
    fn from(class: Class) -> Stats {
        Stats::from(&class)
    }
}

'''
'''--- EN/lesson_6_enums/lesson_6_3_game_score/src/model/errors.rs ---
use near_sdk::{
    AccountId,
    borsh::{ self, BorshSerialize },
    FunctionError,
};

#[derive(FunctionError, BorshSerialize)]
pub enum Errors{
    AccountIsAlreadyRegistered(AccountId),
    AccountIsNotRegistered(AccountId),
    CharacterNotFound(String),
    CharacterAlreadyExists(String),
    InvalidChapterValidation,
    ChapterNotStarted,
    InvalidCharacterName(String),
    InvalidClassName(String),
    UserNotRegistered(AccountId),
    ExcessiveMaxRankingPlayers(usize, usize),
    OwnerOnly,
}

impl std::fmt::Display for Errors {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Errors::AccountIsAlreadyRegistered(user) => write!(f, "Username {} is already registered in the database.", user),
            Errors::AccountIsNotRegistered(user) => write!(f, "Tried to update {}, but account is not registered. This a server error, not a user error. Please report it.", user),
            Errors::CharacterNotFound(name) => write!(f, "Character with name {} not found in current account.", name),
            Errors::CharacterAlreadyExists(name) => write!(f, "A character with name {} already exists in this account.", name),
            Errors::InvalidChapterValidation => write!(f, "Failed to validate chapter report"),
            Errors::ChapterNotStarted => write!(f, "Can't attempt to validate chapter without first starting the match."),
            Errors::InvalidCharacterName(name) => write!(f, "Character name starts with an invalid character ({}).", name),
            Errors::InvalidClassName(name) => write!(f, "Invalid name ({}) for character class.", name),
            Errors::UserNotRegistered(user) => write!(f, "User {} needs to create an account before using this service.", user),
            Errors::ExcessiveMaxRankingPlayers(selected, maximum) => write!(f, "Computing ranking is expensive. Can't be higher than {}. Attempted {}.", maximum, selected),
            Errors::OwnerOnly => write!(f, "Only owner may call this function."),
        }
    }
}
'''
'''--- EN/lesson_6_enums/lesson_6_3_game_score/src/model/mod.rs ---

mod player;
mod chapter;
mod errors;
mod storage;

pub mod character;
pub mod score;

pub(crate) use player::Player;
pub(crate) use player::View as player_view;
pub(crate) use errors::Errors;
pub(crate) use chapter::Chapter;
pub(crate) use storage::StorageKey;

'''
'''--- EN/lesson_6_enums/lesson_6_3_game_score/src/model/player/mod.rs ---
use near_sdk::{
    AccountId,
    borsh::{
        BorshDeserialize,
        BorshSerialize,
        self,
    },
    collections::{
        LookupMap,
        UnorderedSet,
    },
    env,
};

mod view;

use crate::model::{
    chapter::Chapter,
    character,
    character::Character,
    score::HighScore,
    score::Score,
    Errors,
};

use crate::StorageKey;

pub type Name = AccountId;

pub use view::View;

/// Holds information pertaining to a single user.
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Player{
    name: Name,
    high_score: Option<HighScore>,
    // For storing and checking characters by name, can't iterate.
    characters: LookupMap<character::Name, Character>,
    // For storing character names, can iterate.
    character_names: UnorderedSet<character::Name>,
    // With both those above, we can check characters O(1) and iterate through the characters at the same time.

    latest_chapter: Chapter,
}

// Initial state of the player.
impl Default for Player{
    fn default() -> Self {
        let name = env::predecessor_account_id();

        let high_score = None;
        let characters = 
            LookupMap::new(
                StorageKey::Characters(name.clone())
            );

        let character_names: UnorderedSet<character::Name> = UnorderedSet::new(
            StorageKey::CharacterNames(name.clone())
        );

        let latest_chapter: Chapter = Chapter::default();
        
        Player{
            name,
            high_score,
            characters,
            character_names,
            latest_chapter,
        }
    }
}

impl Player{
    /// Will panic if a character with that name already exists.
    fn assert_character_doesnt_exist(&self, character_name: &character::Name) -> Result<(), Errors> {
        if self.characters.contains_key(character_name) {
            return Err(Errors::CharacterAlreadyExists(character_name.clone()));
        }

        Ok(())
    }

    fn assert_character_exists(&self, character_name: &character::Name) -> Result<(), Errors> {
        if !self.characters.contains_key(character_name) {
            return Err(Errors::CharacterNotFound(character_name.clone()));
        }

        Ok(())
    }

    /// Returns the character state. Should be replaced by pointer access later.
    pub fn load_character(&self, name: character::Name) -> Result<Character, Errors> {
        match self.characters.get(&name){
            None => Err(Errors::CharacterNotFound(name.to_string())),
            Some(character) => Ok(character),
        }
    }

    /// This should be replaced by pointer access later.
    fn save_character(&mut self, character: &Character) -> Result<(), Errors> {
        let character_name = character.get_name();

        self.assert_character_exists(&character_name)?;

        self.characters.insert(&character_name, character).unwrap();

        Ok(())
    }

    pub fn assign_character(&mut self, character: Character) -> Result<(), Errors> {
        let character_name = character.get_name();
        
        self.assert_character_doesnt_exist(&character_name)?;

        // If this error happens. It's an unexpected server error. That means that something else is going wrong.
        // It should be reported.
        assert!(self.characters.insert(&character_name, &character).is_none(), "Server error: Character doesn't exist. Please Report.");
        self.character_names.insert(&character_name);

        Ok(())
    }

    /// Move to the next chapter.
    pub fn next_match(&mut self){
        self.latest_chapter.next_match();
    }

    /// Start timer and return the current chapter.
    pub fn start_match(&mut self) -> Chapter {
        self.latest_chapter.start_match()
    }

    /// End the timer and reward the character. Then update highscores.
    /// 
    /// Returns a HighScore if it was achieved,
    pub fn report_match(
        &mut self,
        character: String,
        score: Score,
        // validation_report: ValidationReport,
    ) -> Result<Option<HighScore>, Errors> {
        let mut character: Character = self.load_character(character)?;

        let exp: character::EXP = self.latest_chapter.validate_match(
            &character, 
            &score,
        )?;

        let new_character_highscore: Option<HighScore> = character.check_highscore(score);

        let high_score: Option<HighScore> = HighScore::update_highscore(
            &mut self.high_score, 
            new_character_highscore,
        );

        character.reward_exp(exp);
        self.save_character(&character)?;

        Ok(high_score)
    }

    /// Get characters' name.
    pub fn get_name(&self) -> Name {
        self.name.clone()
    }

    /// Returns information about this player as json.
    /// 
    /// LookupMap and UnorderedSet can't be serialized into json. We create a View with serializable data types and return it instead.
    pub fn get_view(&self) -> Result<View, Errors> {
        let name: Name = self.name.clone();
        let high_score: Option<HighScore> = self.high_score.clone();
        let mut characters: Vec<Character> = Vec::with_capacity(self.character_names.len() as usize);

        for character_name in self.character_names.iter() {
            let character: Character = self.load_character(character_name)?;
            characters.push(character);
        };

        Ok(View { name, high_score, characters })
    }
}

'''
'''--- EN/lesson_6_enums/lesson_6_3_game_score/src/model/player/view.rs ---
//! When a user loads a player type. This type is what they will receive.
//! 
//! 

use near_sdk::{
    serde::{ Deserialize, Serialize },
};

use crate::model::{
    character::Character,
    player,
    score::HighScore,
};

/// This type exists only to be returned when player makes a GET request for their own data.
#[derive(Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct View {
    pub name: player::Name,
    pub high_score: Option<HighScore>,
    pub characters: Vec<Character>,
}

'''
'''--- EN/lesson_6_enums/lesson_6_3_game_score/src/model/score/high_score.rs ---
use near_sdk::{
    AccountId,
    borsh::{ BorshDeserialize, BorshSerialize, self },
    serde::{ Deserialize, Serialize },
};

use crate::model::{
    character::Character,
    score::Score,
};

/// Represents a highscore for a player or character.
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct HighScore{
    character: Character,
    score: Score,
    player: AccountId,
}

// Used for ordering HighScores within a Vec
impl Ord for HighScore {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.score.cmp(&other.score)
    }
}

// Required by Ord.
impl PartialOrd for HighScore {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        Some(self.cmp(other))
    }
}

// Used for partial comparisons between HighScores. Required by Ord and Eq.
//
// A = B sometimes doesn't mean B = A.
impl PartialEq for HighScore {
    fn eq(&self, other: &Self) -> bool {
        self.score == other.score
    }
}

// Used for comparisons between HighScores. Required by Ord.
//
// This implies that A = B means B = A.
impl Eq for HighScore {}

impl HighScore{
    /// Returns a new instance of Highscore.
    pub fn new(
        score: Score,
        character: &Character,
        player: AccountId,
    ) -> Self {

        HighScore{
            score,
            character: character.clone(),
            player,
        }
    }

    /// Makes a comparison between the new and old high scores. If a new high_score for the player is achieved, update current and return a copy.
    pub fn update_highscore(
        current_highscore: &mut Option<HighScore>,
        new_high_score: Option<HighScore>,
    ) -> Option<HighScore> {

        // This match will stop assigning the new highscore if one has not been achieved.
        match (&current_highscore, &new_high_score) {
            (_, None) => { 
                // No highscore was achieved by the character.
                return None; 
            },
            (None, Some(_)) => {},
            (Some(old_high_score), Some(new_high_score)) => {
                // A character achieved a highscore
                // there is a highscore recorded.
                // makes a comparison and maintain the highest.
                if old_high_score > new_high_score {
                    return None;
                }
            },
        }

        // assign the new highscore
        *current_highscore = new_high_score.clone();

        return new_high_score;
    }

    /// Returns score achieved.
    pub fn get_score(&self) -> Score {
        self.score
    }

    /// Returns character for this highscore.
    pub fn get_character(&self) -> Character {
        self.character.clone()
    }

}

'''
'''--- EN/lesson_6_enums/lesson_6_3_game_score/src/model/score/mod.rs ---
mod high_score;
mod ranking;

pub(crate) use high_score::HighScore;
pub(crate) use ranking::Ranking;
pub type Score = u32;

'''
'''--- EN/lesson_6_enums/lesson_6_3_game_score/src/model/score/ranking.rs ---
use near_sdk::{
    borsh::{ BorshDeserialize, BorshSerialize, self},
    env,
    log, 
    serde::{Deserialize, Serialize},
};

use crate::model::{
    score::HighScore,
    Errors,
    // StorageKey,
};

// Just for this exampĺe, we just want max 10 values in the ranking.
// const RANKSIZE: usize = 10;

/// Contains the top ranked matches stored in the smart contract.
/// 
/// It's just a vector. So to avoid high costs sorting.
/// 
/// We limit the max number of entries to RANKSIZE.
/// 
/// Suggestion for change. Store the score of the lowest highscore in the ranking. 
/// Only update and sort the list when a value higher than such is included.
#[derive(BorshDeserialize, BorshSerialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Ranking{
    values: Vec<HighScore>,
    max_size: usize,
    lowest_high_score: Option<HighScore>,
}

impl Serialize for Ranking {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: near_sdk::serde::Serializer {

        serializer.collect_seq(self.values.iter().map(|x| x))
    }
}

impl Default for Ranking{
    fn default() -> Self {
        // let values: Vec<HighScore> = Vector::new(StorageKey::Ranking);
        let max_size: usize = 10;
        let values: Vec<HighScore> = Vec::with_capacity(max_size);
        let lowest_high_score: Option<HighScore> = None;

        Self { 
            values,
            max_size,
            lowest_high_score,
        }
    }
}

impl Clone for Ranking{
    fn clone(&self) -> Self {
        let max_size: usize = self.max_size.clone();
        let mut values: Vec<HighScore> = Vec::with_capacity(max_size);
        let lowest_high_score: Option<HighScore> = self.lowest_high_score.clone();
        
        for value in self.values.iter(){
            values.push(value.clone());
        }

        Self { 
            values,
            max_size,
            lowest_high_score,
        }
    }
}

impl Ranking{

    fn sort_and_resize(&mut self) {
        self.values.sort();
        self.values.truncate(self.max_size);
    }

    /// This is only called when the ranking list is full.
    /// Add the entry to the list, sort it, then remove all the excess elements.
    /// Finally, set the lowest high score value to the element at the end of the list.
    fn new_entry(&mut self, entry: HighScore) {
        self.values.push(entry);

        // Sort the highscores and resize it to RANKSIZE (If it has more values than RANKSIZE)
        self.sort_and_resize();

        let lowest_high_score = self.values.last();

        match lowest_high_score {
            None => env::panic_str("Smart contract implementation error. This should never happen. Called Ranking::new_entry and got a None."),
            Some(lowest) => {
                self.lowest_high_score = Some(lowest.clone());
            }
        }
    }

    pub fn set_max_highscore_players(&mut self, max_size: usize) -> Result<(), Errors>{
        let limit = 1000;

        if max_size > limit {
            return Err(Errors::ExcessiveMaxRankingPlayers(limit, max_size));
        }

        self.max_size = max_size;

        Ok(())
    }

    pub fn check_highscore(
        &mut self, 
        high_score: &Option<HighScore>,
    ) -> bool {
        match high_score {
            None => { 
                // Player didn't achieve a high score.
                false
            },
            Some(high_score) => {
                log!("New High Score for this Player.");

                // Compiler will apply branchless optimization to all these if/else statements.
                if self.lowest_high_score.is_none() {
                    // This is the first entry, so just include it.
                    self.new_entry(high_score.clone());

                    return true;
                } else {
                    // This is not the first entry.
                    // The list may be full or not.
                    let ranking_is_full: bool = self.values.len() == self.max_size;

                    if !ranking_is_full {
                        // If the list is not full, just include it.
                        self.new_entry(high_score.to_owned());

                        return true;
                    } else {
                        // .unwrap will never panic because of the first "if" above. It is always Some.
                        // We are cloning because unwrap will take ownership of this mutable reference.
                        let lowest_high_score = self.lowest_high_score
                            .clone()
                            .unwrap();

                        if lowest_high_score < *high_score {
                            self.new_entry(high_score.clone());

                            return true;
                        }
                        
                        false
                    }
                }
            }
        }
    }

}
'''
'''--- EN/lesson_6_enums/lesson_6_3_game_score/src/model/storage.rs ---
use near_sdk::{
    AccountId,
    BorshStorageKey,
    borsh::{self, BorshSerialize},
};

/// Keys used for storing values in trie. Required for collections like UnorderedSet and LookupMap.
/// 
/// We have to make sure that each collection has a unique prefix.
#[derive(BorshStorageKey, BorshSerialize)]
pub enum StorageKey {
    // Holds no argument because only one LookupMap for Players in the entire smart contract.
    Players,
    
    // Holds an account Id because Each player has one UnorderedSet for the characters. The AccountId is used to tell these types apart.
    Characters(AccountId),

    // Same for character names. It's an UnorderedSet that is different between each player. 
    // So we use the AccountId (unique for each player) within the tuple.
    CharacterNames(AccountId),
}
'''
'''--- EN/static/Readme.md ---
Imagens e tutoriais.

'''
'''--- EN/static/tutorials/cargo.md ---
# Introdução a Cargo

Cargo é a ferramenta que usamos para administrar nossos projetos da linguagem rust. Documentação completa sobre Cargo no [livro Cargo](https://doc.rust-lang.org/cargo/).

 - [Cargo.toml](#cargotoml)
 - [O que é crate](#o-que-%C3%A9-crate)
   - [crates.io](#cratesio)
 - [Comandos Cargo](#comandos-cargo)
   - [cargo build](#cargo-build)
   - [cargo test](#cargo-test)
   - [cargo doc](#cargo-doc)

## Cargo.toml
[topo](#introdu%C3%A7%C3%A3o-a-cargo)

Semelhante a ```package.json``` para ```node.js```, este arquivo possui todas as informações meta sobre este diretório. Características como nome e versão, mas também configurações sobre como o projeto deve ser compilado.

![Imagem de um arquivo Cargo.toml padrão. Identico ao Cargo.toml da lição 1.](../images/cargo.png)

Não é necessário saber tudo sobre essas configurações. As configurações que precisaremos alterar são ```[package]``` e ```[dependencies``` de projeto em projeto. A seguir, descrevemos os tópicos principais:
 - **package**: Configurações sobre a crate. Nome, versão, licensa, edição do Rust, etc; 
 - **lib**: Isso determina que esta crate não é um executável. E sim é uma biblioteca que será acessada externamente. ```cdylib``` quer dizer "c dynamic library", ```rdylib``` quer dizer "rust dynamic library". Acho que o compilador webassembly precisa dessas configurações.
 - **dependencies**: Aqui declaramos nossas dependencias. Podemos incluir de varias formas. O padrão é vindo do site "crates.io", mas podemos também incluir crates locais; podemos incluir através de um link github, etc.
 - **profile.release**: Configuração para projetos compilados para "release". Não é necessário entender cada instrução. Simplesmente fala para o compilador tentar optimizar o máximo possivel, quando um erro (panic) acontece, finaliza o runtime, et cetera.

## O que é crate?
[topo](#introdu%C3%A7%C3%A3o-a-cargo)

**Crate** (caixa) representa um diretório com um arquivo "Cargo.toml".

Geralmente, cada crate gera um diretório "target" com o arquivo compilado. Mas se criarmos um workspace, que é um conjunto de várias crates compartilhando um "Cargo.toml", os arquivos compilados são todos agrupados na mesma pasta. Para mais detalhes, cheque a lição sobre workspaces.

Podemos publicar nossas crates no site [crates.io](https://crates.io/).

### Crates.io
[topo](#introdu%C3%A7%C3%A3o-a-cargo)

Dependências como ```near_sdk``` são baixadas deste site. Qualquer desenvolvedor rust pode compartilhar projetos neste site, com **uma condição**: Deve ser open-source.

O site intencionalmente não disponibiliza opção para compartilhar crates de forma privada.

![](../images/crates.io.png)

Para impedir que projetos quebrem de forma inesperada, se retirarmos uma versão do registry usando o comando "yank", projetos não poderão mais baixar a versão, mas ainda continuarão funcionando se tiverem a versão baixada.

## Comandos Cargo
[topo](#introdu%C3%A7%C3%A3o-a-cargo)

Segue uma lista simplificada de comandos cargo que podemos utilizar durante desenvolvimento de contratos NEAR.

 - build: compila o projeto.
 - test: executa testes de unidade.

Só isso. Existem vários outros comandos que podemos executar com cargo. Mas não são necessários para novos desenvolvedores. Cheque o [livro Cargo](https://doc.rust-lang.org/cargo/).

### Cargo build
[topo](#introdu%C3%A7%C3%A3o-a-cargo)

Precisamos compilar o projeto para webassembly, sem uma arquitetura especificada. Para isso usamos:

```bash
cargo build --release --target wasm32-unknown-unknown
```

 - ```release``` corta todas as partes da compilação feitas para auxiliar o debug e otimiza o código para produção
 - ```target``` determina a arquitetura alvo para o projeto. Escolhemos webassembly.

O arquivo webassembly estará no caminho '/target/wasm32-unknown-unknown/release/'.

**Aviso**: Essa instrução irá resultar em **erro** se não instalarmos ```wasm32-unknown-unknown``` na lista de alvos da linguagem rust. Para isto, basta executar a seguinte instrução (apenas uma vez para cada instalação de rust).

```bash
rustup target add wasm32-unknown-unknown
```

### Cargo test
[topo](#introdu%C3%A7%C3%A3o-a-cargo)

Realiza todos os testes de unidade no projeto. Se uma função possui o marcador ```#[test]```, essa função será executada.

Testes de unidade simplesmente procuram por situações de pânico. Se um pânico inesperado acontece, ou um pânico esperado não acontece, o teste falha.

Macros como panic, assert e assert_eq são usados para garantir nossas condições.
 - ```panic!("Mensagem");```: Causa pânico com a dada mensagem.
 - ```assert!(condicao, "Mensagem");```: Causa pânico se a condição for falsa. Está "garantindo" que a condição será verdadeira.
 - ```assert_eq!(primeiro, segundo, "Mensagem");```: Compara ```primeiro == segundo```. Se forem diferentes, causa pânico com a dada mensagem.

Exemplo de situação em que não esperamos panic:

```rust
#[test]
fn oneplusone() {
    assert_eq!(1 + 1, 2);
}
```

1+1 é sempre igual a 2. Então nunca haverá panic.

Exemplo de situação em que esperamos panic:

```rust
#[test]
#[should_panic(expected = "A panic has just happened")]
pub fn this_will_panic() {
    env_setup();

    let _contract: Contract = Contract::default();

    Contract::this_will_panic();
}
```

Este é um exemplo da "lição 4 - módulos". A função ```this_will_panic()``` é uma função que eu criei que sempre causa pânico.

```#[should_panic]``` significa que o teste vai falhar se não entrar em panic. ```expected``` especifica qual a mensagem de pânico esperada.

Isso é tudo sobre testes para contrato. Para simular a comunicação entre contratos, precisamos de utilizar workspaces-rs.

### Cargo doc
[topo](#introdu%C3%A7%C3%A3o-a-cargo)

Gera uma página de web com a documentação do projeto. Muito fácil de compartilhar. A pagina de web estará no caminho "/target/doc/nome_da_crate/".

```bash
cargo doc --open
```
Irá abrir a pagina de web no navegador padrão.

![](../images/cargodoc.png)

Clique em Contract para ver as funções implementadas:

![](../images/cargodoccontract.png)

Comentários com ```//``` não aparecem na documentação.

[Voltar](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/EN/)

'''
'''--- EN/static/tutorials/nearcli.md ---
# Introdução a near-cli

Near CLI ("command line interface") é a ferramenta que utilizamos para interagir com o protocolo blockchain. Documentação completa sobre near-cli no [tutorial](https://docs.near.org/docs/tools/near-cli).

## Conta NEAR (Simplificado)

Uma conta NEAR pode ser vista como uma carteira. Podemos transferir NEAR, receber, executar funções em contratos inteligentes de outras contas, criar chaves de acesso com certas permissões, etc.

Um smart contract pode ser implementado em uma conta NEAR, mas não é obrigatório para que essa exista. Cada conta ou sub-conta NEAR só pode ter um contrato de cada vez. Mas uma conta NEAR pode ser mestre (permissões administrativas) de várias sub-contas.

Ou seja, quando precisarmos de implementar vários contratos, podemos distribui-los em uma hierarquia de diversas contas com maior segurança. As subcontas só precisam das permissões necessárias para seus objetivos. As subcontas só precisam da quantidade de gas necessárias para se manterem em operação.

**gas**: É NEAR gasto para computação, armazenamento de dados, criação de contas, etc. A cada clock de computação, uma fração de NEAR é consumida da conta. As máquinas que mantém nosso sistema em funcionamento devem ser recompensadas, por isso utilizamos **gas** é consumido.

## Lista de Comandos

Discutiremos alguns comandos a seguir:
 - [Login](#login)
 - [Checar State](#checar-state-estado)
 - [Criar Sub-conta](#criar-sub-conta)
 - [Implantar Contrato](#implantar-contrato)
   - [Evitando Inicialização Sem argumentos](#evitando-inicializa%C3%A7%C3%A3o-sem-argumentos)
 - [Executar Funções de Contrato](#executando-funções-do-contrato)
   - [View](#view)
   - [Call](#call)
 - [Deletar Sub-Conta](#deletar-sub-conta)

## Login
[topo](#introdu%C3%A7%C3%A3o-a-near-cli)

```bash
near login
```

![Imagem de um navegador conectando à plataforma NEAR, ao lado um terminal com o comando near login.](../images/nearlogin.png)

Não é a nossa máquina que executa as funções de contrato descentralizadas. A nossa conta na blockchain que faz isso. Nós conectamos a uma conta testnet com este comando.

**testnet**: é uma plataforma de teste NEAR. Os tokens não tem valor e não é possivel comercializá-los. A plataforma oficial é a **mainnet**. Garanta que não há riscos no contrato antes de implementar para produção.

## Checar State (Estado)
[topo](#introdu%C3%A7%C3%A3o-a-near-cli)

```bash
near state stiltztinkerstein.testnet
```

Podemos checar o estado de qualquer conta na blockchain. É informação pública.

![Imagem de terminal após o uso do comando acima.](../images/nearstate.png)

Lembrar que esta é uma conta **testnet**. Não é dinheiro de verdade. Os atributos que conseguimos são estes:

 - **amount**: Quantidade de NEAR na conta em yocto Near. ```1 * 10²⁴ = 1 NEAR```.
 - **block_hash**: Hash do bloco;
 - **block_height**: Altura do bloco;
 - **code_hash**: Se o hash de código for uma sequência de "1", então nenhum smart contract foi implementado nesta conta;
 - **locked**: Quantidade de NEAR trancado?*;
 - **storage_paid_at**: Custo de armazenamento?*;
 - **storage_usage**: Uso de armazenamento?*;
 - **formattedAmount**: **amount** formatado para NEAR.

*: Quem tiver mais informações sobre os detalhes com *, agradeceria um pull-request.

## Criar sub-conta
[topo](#introdu%C3%A7%C3%A3o-a-near-cli)

Podemos criar uma subconta com um comando semelhante a este:

```bash
near create-account minha-subconta.minha-conta.testnet --masterAccount minha-conta.testnet --initialBalance 10
```

 - **nome-da-conta.minha-conta.testnet**: Nome da subconta que criei;
 - **minha-conta.testnet**: nome da conta mestre;
 - **masterAccount**: conta mestre;
 - **initialBalance 10**: Opcional. A conta mestre enviará 10 NEAR para a subconta;

Para criar uma conta de topo nível, use [near-api-js](https://docs.near.org/docs/api/naj-cookbook#create-account).

## Implantar Contrato
[topo](#introdu%C3%A7%C3%A3o-a-near-cli)

```bash
near deploy --accountId minha-subconta.minha-conta.testnet --wasmFile ./compilado.wasm
```

Após compilar nosso projeto (cheque o [tutorial cargo](https://github.com/On0n0k1/Tutorial_NEAR_Rust/blob/main/EN/static/tutorials/cargo.md)), usamos este comando para implantar o arquivo compilado em nossa subconta.

 - **accountId**: ID da conta em que implantaremos o contrato;
 - **wasmFile**: Caminho para o arquivo webassembly compilado;

O estado inicial deste contrato será a trait ```Default``` que implementamos no código rust. Essa trait não recebe parâmetros para inicialização. Se quisermos usar um construtor com parâmetros de inicialização, precisamos de seguir dois passos:

O primeiro passo é declarar um construtor com marcador ```#[init]```. Exemplo:

```rust
#[init]
pub fn new(title: String, data: String, category: i8) -> Self {
```

O nome da função ```new``` não é obrigatório. Mas é convenção criar construtores com este nome.

O segundo passo é incluir os parâmetros ```--initFunction``` e ```--initArgs``` para inicializar o contrato com a função e argumentos, respectivamente.

O comando de implantação poderia ser chamado da seguinte forma:

```bash
near deploy --accountId minha-subconta.minha-conta.testnet --wasmFile ./compilado.wasm --initFunction new --initArgs '{"title": "um-titulo", "data": "link-para-dados", "category": 3 }'
```

### Evitando inicialização sem argumentos
[topo](#introdu%C3%A7%C3%A3o-a-near-cli)

A trait ```Default``` é um requisito para o funcionamento do contrato, mesmo se não pretendermos utilizá-la. Se a inicialização com argumentos for essencial para o funcionamento do contrato, podemos fazer com que o processo entre em pânico caso o sistema tente inicializar com ```Default```.

Duas forma de causar "panic em ```Default```" são descritos a seguir:

Na implementação de ```Default```:
```rust
impl Default for Contract{
    fn default() -> Self{
        panic!("The contract is not initialized");
    }
}
```

Derivando ```PanicOnDefault``` na declaração de ```Contract```:

```rust
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract{
```

Ambas as alternativas fazem exatamente a mesma coisa.

## Executar funções do contrato
[topo](#introdu%C3%A7%C3%A3o-a-near-cli)

Existem dois tipos de funções de contrato:
 - **view**: Não realiza computação e não altera estado do contrato. Não consome gás. Ou seja, é de graça.
 - **call**: Todos os outros tipos de função. Consomem gás. Podem necessitar um pagamento. A implementação da função pode incluir outras restrições, como restrições de chave, restrições de usuário, et cetera.

### View
[topo](#introdu%C3%A7%C3%A3o-a-near-cli)

Para facilitar o entendimento, vale lembrar que o estado de todos os contratos são publicos.

Se uma função simplesmente retorna um valor armazenado no estado, então pode ser uma função view. Funções view não consomem gás, e não precisam de pagamento.

Funções view não podem realizar nenhum cálculo, e não podem alterar o estado do contrato.

Usaremos o contrato abaixo como exemplo:

```rust
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Contract{
    counter: i32,
    nome: String,
}
```

Os exemplos abaixo são exemplos válidos para funções view:

```rust
#[near_bindgen]
impl Contract{
    pub fn get_counter(&self) -> i32 {
        // i32 implementa Copy
        self.counter
    }

    pub fn get_counter1(&self) -> i32 {
        // O mesmo que get_counter
        return self.counter;
    }

    pub fn get_nome(&self) -> String {
        // String não implementa copy
        // Strign implementa Clone
        self.nome.clone()
    }

    pub fn get_nome1(&self) -> String {
        // O mesmo que get_nome
        return self.nome.clone();
    }
}
```

Uma breve explicação sobre alguns traits. Para um tipo implementar Copy, este precisa de implementar Clone.

Se um tipo implementar Clone, podemos criar uma cópia desse tipo com o método ```clone()```. Se um tipo implementar Copy, a cópía será feita automaticamente quando necessário. A instrução seguinte para i32:

```rust
return self.counter;
```

Se counter não implementasse ```Copy``` ou ```Clone```, teriamos um erro. Porque transferimos esse endereço de variável para outro lugar. Counter não teria um valor, pois a "ownership" foi perdida. O compilador não irá permitir essa transferência.

O exemplo a seguir **não** pode ser função view.

```rust
pub fn um_numero() -> i32 {
    5
}
```

Embora a função simplesmente retorna um número, é ainda considerada computação. Relembrando, funções view apenas retornam o valor de um estado do contrato (que é informação pública).

#### Executando uma função view
[topo](#introdu%C3%A7%C3%A3o-a-near-cli)

```bash
near view minha-subconta.minha-conta.testnet get_counter '{}'
```

### Call
[topo](#introdu%C3%A7%C3%A3o-a-near-cli)

Qualquer outro tipo de função que não é ```view```, é ```call```.

Para o contrato abaixo...

```rust
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Contract{
    counter: i32
}
```

... temos o exemplo de função ```call``` a seguir:

```rust
#[near_bindgen]
impl Contract{
    pub fn increment(&mut self) -> i32 {
        self.counter += 1;
        self.counter
    }
}
```

Exemplo retirado da "lição 1 - contratos". Incrementa counter em 1, e retorna o valor.

Podemos chamar a função da seguinte forma:

```bash
near call minha-subconta.minha-conta.testnet increment '{}' --account-id minha-conta.testnet
```

## Deletar Sub-Conta
[topo](#introdu%C3%A7%C3%A3o-a-near-cli)

```bash
near delete minha-subconta.minha-conta.testnet minha-conta.testnet
```

O primeiro argumento é o nome da sub-conta a deletar. O segundo argumento é o nome da conta que irá receber todo o NEAR armazenado.

'''
'''--- EN/static/tutorials/rust.md ---
# Instalação Rust

Este tutorial descreve a instalação das ferramentas recomendadas para criação de projetos NEAR em Rust.

 - [Scripts de Instalação](#scripts-de-instala%C3%A7%C3%A3o)
 - [Rustlings](#rustlings)
 - [Rust](#rust)

Instalaremos várias ferramentas diferentes com uma única linha de comando. Às que destacaremos nesse tutorial são: **rustup**, **cargo** e **rustc**.

 - **rustc**: compila o código rust para linguagem de máquina;
 - **cargo**: permite realizar comandos especificos para o projeto como compilar, criar documentação, realizar testes de unidade, executar projeto como binário.
 - **rustup**: existem varias diferentes formas de se compilar um projeto. Diversas arquiteturas diferentes. Diversas versões. rustup controla estas versões.

Uma analogia para desenvolvedores javascript:
 - rustup age de forma semelhante a nvm.
 - cargo age de forma semelhante a npm.
 - rustc age de forma semelhante a node.

É apenas uma analogia, existem algumas diferenças que serão encontradas em pratica.

## Scripts de instalação
[topo](#instala%C3%A7%C3%A3o-rust)

Recomendaremos duas alternativas para instalação de Rust. A primeira é recomendada para estudo, a segunda é recomendada para quem simplesmente quer instalar rustup.

 - rustlings: Instala rust e instala a ferramenta rustlings, que possui exercicios para desenvolvedores praticarem seu entendimento.
 - rust: Instala rust e todas as ferramentas necessárias para desenvolvimento.

## Rustlings
[topo](#instala%C3%A7%C3%A3o-rust)

Acesse o [repositório](https://github.com/rust-lang/rustlings) e siga as instruções de instalação.

![Pagina de web rust](../images/rustlings.png)

#### Rustlings para MacOS/Linux
[topo](#instala%C3%A7%C3%A3o-rust)

```bash
curl -L https://git.io/install-rustlings | bash
# Ou se quiser escolher o diretorio de instalação
curl -L https://git.io/install-rustlings | bash -s mypath/
```

### Rustlings para Windows
[topo](#instala%C3%A7%C3%A3o-rust)

Executar em um powershell com permissões de administrador.

```bash
Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser
```

E depois executar:

```bash
Start-BitsTransfer -Source https://git.io/JTL5v -Destination $env:TMP/install_rustlings.ps1; Unblock-File $env:TMP/install_rustlings.ps1; Invoke-Expression $env:TMP/install_rustlings.ps1
```

## Rust
[topo](#instala%C3%A7%C3%A3o-rust)

Acesse a [pagina oficial](https://www.rust-lang.org/tools/install) e execute o script. 

![Pagina de web rust](/static/images/rust.png)

```bash
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
```

Este comando detecta o sistema e instala todas as ferramentas necessárias.

'''
'''--- EN/static/tutorials/setup-nearcli.md ---
# Instalação NEAR CLI

NEAR CLI (NEAR Command Line Interface) é utilizado para fazer login e interagir com contas NEAR.

Uma explicação detalhada sobre a ferramenta pode ser encontrada no seguinte link: https://github.com/near/near-cli

Os passos são descritos e detalhados a seguir:

 - Instalar NPM (Node Package Manager)
 - Instalar NodeJs
 - Instalar NEAR CLI globalmente

## Windows

### Instalar NVM e NPM

Instale NPM de acordo com as descrições do [link](https://github.com/near/near-cli). Vou incluir os detalhes mais tarde. Agradeceria um pull request com o passo-a-passo para desenvolvedores Windows.

### Instalar NodeJs (versão 12+)

```bash
nvm install 12
nvm use 12
```

### Instalar NEAR CLI Globalmente

```bash
npm install -g near-cli
```

## Ubuntu

### Instalar NVM e NPM

[Link com Detalhes](https://linuxize.com/post/how-to-install-node-js-on-ubuntu-20-04/)

```bash
sudo apt update
sudo apt install nodejs npm
```

### Instalar NodeJs (versão 12+)

```bash
nvm install 12
nvm use 12
```

### Instalar NEAR CLI Globalmente

```bash
npm install -g near-cli
```

'''
'''--- ES/README.md ---
# Tutorial_NEAR_Rust

[voltar](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/)

Tutorial em etapas para desenvolvimento de contratos inteligentes em rust. Neste conjunto de tutoriais serão discutidos todas as principais características da linguagem, assim como seu uso na plataforma NEAR.

---

## Contato

[topo](#tutorial_near_rust)

Para dúvidas, reclamações ou sugestões, por favor me adicione no discord On0n0k1#3800. Se este tutorial facilitar a sua vida, considere comprar um café para mim enviando uma fração de NEAR para stiltztinkerstein.near .

---

## Tópicos

[topo](#tutorial_near_rust)

 - [O Que é a linguagem Rust](#o-que-é-a-linguagem-rust)
 - [Usos da linguagem Rust](#usos-da-linguagem-rust)
 - [Aprendendo a Linguagem Rust](#aprendendo-a-linguagem-rust)
 - [Comparações com Javascript e Python](#compara%C3%A7%C3%B5es-com-javascript-e-python)
 - [Instalação](#instala%C3%A7%C3%A3o)
 - [Lições](#li%C3%A7%C3%B5es)

---

## O que é a linguagem Rust

[topo](#tutorial_near_rust)

De forma bem resumida, é uma linguagem de programação de baixo nível com as seguintes características:

 - Execução aproximadamente tão rápida quanto linguagem c ou c++.
 - Não tem os riscos de vazamento de memória que outras linguagens de baixo nível possuem.
 - É dificil de começar a aprender.
 - Não **usa** e nem **precisa** de coleta de lixo de memória. Pois no periodo de compilação, o compilador sabe exatamente quando variáveis são criadas e liberadas.
 - Processamento em paralelo é fácil.
 - Processamento assíncrono é de dificuldade semelhante a outras linguagens populares.
 - Muito mais simples organização de projeto e dependências do que python e javascript.
 - Ganhou repetidos anos consecutivos como a linguagem mais popular do stackoverflow.

---

## Usos da linguagem Rust

[topo](#tutorial_near_rust)

Um desenvolvedor Rust pode:

 - Criar apps decentralizados em plataformas web3 como NEAR.
 - Pode criar aplicativos que não precisam de uma máquina virtual para serem executados. Precisa do compilador Rust para compilar, mas não precisa para executar.
 - Criar servidores compactos e rápidos em conteineres docker.
 - Criar aplicações potentes como funções lambda para serem implantados em servidores aws (web3 é melhor porém).
 - Usar o linker para criar bibliotecas que podem ser usadas por um compilador como c.
 - Compilar bibliotecas que podem ser importadas em um browser javascript ou em um runtime nodejs com o formato WebAssembly.
 - Compilar bibliotecas potentes e eficientes para Python usando a crate PyO3.
 - Compilar código para dispositivos embarcados (embedded).
 - Competir em um mercado de trabalho que possui 1 ou 2 inscritos por vaga (incluindo internacional).

---

## Aprendendo a linguagem Rust
[topo](#tutorial_near_rust)

No meu ponto de vista, aprender a linguagem rust é semelhante a idéia de domar um dragão em um mundo de fantasia. É demorado, é dificil, existem muitas alternativas diferentes e mais simples do que essa. Mas, se conseguir, você vai ter um terrível dragão ao seu lado.

Existem estudos que destacaram que o tempo para escrever uma certa quantidade de linhas de código em linguagens de baixo nível (como c) é até 30 vezes mais devagar do que as de alto nível (como python e javascript). Pela minha prática, é mais demorado ainda para uma pessoa aprendendo Rust escrever código do que c. 

Mas, com prática, ficamos mais ágeis em tudo. Com o tempo acostumamos com o que o compilador precisa e espera de nós. Podemos também configurar snippets para gerar códigos de "boilerplate" (forma) automaticamente. Então, é apenas uma questão de entendimento, memorização e paciência para o desenvolvedor. Houveram vezes em que eu escrevi 800 linhas de código Rust em 2 dias.

Quase sempre teremos que dar pausas para estudar o nosso método e garantir que estamos fazendo as decisões corretas. Porém, cada tentativa seguinte será mais fácil que a anterior.

---

## Comparações com javascript e Python

[topo](#tutorial_near_rust)

Porém uma pessoa astuta perguntaria "Porque eu iria aprender uma linguagem dessas se eu ja posso resolver os mesmos problemas com as linguagens que sei?" . É uma ótima pergunta, se eu ja posso conseguir o resultado escrevendo algumas linhas de código em python no terminal, porque eu iria querer aprender Rust?

Facilidade de uso e resolução de problemas. Este é o foco principal dessas linguagens. Como conseguir a solução para o nosso problema da forma mais simples possivel. Os processadores ficavam cada vez mais rápido cada geração, então bastava comprar as gerações de hardware mais recentes.

Porém a lei de Moore não se aplica mais. Os desenvolvedores estão precisando de algoritmos mais eficientes. Esta necessidade nos faz olhar para nossas linhas de código e perguntar "O que está instrução está fazendo exatamente?"

Quando escrevemos uma instrução em python "a = 3". A máquina virtual python está criando um objeto numero, criando um ponteiro mutex que aponta para o numero, e associando "a" a este ponteiro. Por isso que python normalmente é limitado a um core do processador. Quando tentamos aproveitar mais a capacidade de processamento de nossa máquina, a complexidade de código em javascript e python cresce exponencialmente.

O foco da linguagem Rust não é o resultado final dessa execução. E sim, o caminho que o processador e memória levam até alcançar este resultado. Um(a) desenvolvedor(a) rust experiente sabe olhar um bloco de código e dizer:
 - "Essa memória vai ser liberada nessa linha de código";
 - "O processador irá pedir pra liberar um espaço de memória nessa linha e criar uma cópia dessa variável aqui.";
 - "Essa função irá pegar esse endereço emprestado, usar este valor nessa parte, e retornar o endereço para o dono ao fim.";

---

## Instalação

[topo](#tutorial_near_rust)

Antes de começarmos, devemos realizar os seguintes passos:

 - Instalar [near-cli](https://github.com/On0n0k1/Tutorial_NEAR_Rust/blob/main/ES/static/tutorials/setup-nearcli.md) para interagir com a plataforma NEAR.
 - Instalar [rust](https://github.com/On0n0k1/Tutorial_NEAR_Rust/blob/main/ES/static/tutorials/rust.md) para compilar e testar os projetos.

---

## Lições

[topo](#tutorial_near_rust)

 - [Lição 1: Contratos](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/ES/lesson_1_contract)
 - [Lição 2: Ownership](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/ES/lesson_2_ownership)
 - [Lição 3: Structs](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/ES/lesson_3_structs)
 - [Lição 4: Módulos](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/ES/lesson_4_modules)
 - [Licão 5: Usando Macros](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/ES/lesson_5_macro_usage)
 - [Lição 6: Enums](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/ES/lesson_6_enums)
 - Lição 7: Traits
 - Lição 8: Coleções

'''
'''--- ES/lesson_1_contract/Cargo.toml ---
[package]
name = "lesson_1_contract"
version = "0.1.0"
license = "MIT"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- ES/lesson_1_contract/Readme.md ---
# Lição 1: Contrato

[voltar](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/ES/)

Veja também:
 - Usos da [ferramenta cargo](https://github.com/On0n0k1/Tutorial_NEAR_Rust/blob/main/ES/static/tutorials/cargo.md).
 - Usos da [ferramenta near-cli](https://github.com/On0n0k1/Tutorial_NEAR_Rust/blob/main/ES/static/tutorials/nearcli.md).

---

## Tópicos
 - [Estrutura de um contrato NEAR](#estrutura-de-um-contrato-near)
 - [Importar Dependências](#importar-depend%C3%AAncias)
 - [Macro de Alocação](#macro-de-aloca%C3%A7%C3%A3o)
 - [Declaração de Contrato](#declara%C3%A7%C3%A3o-de-contrato)
 - [Declaração de API do Contrato](#declara%C3%A7%C3%A3o-de-api-do-contrato)
 - [Testes de Unidade](#testes-de-unidade)

---

## Estrutura de um contrato NEAR
[topo](#li%C3%A7%C3%A3o-1-contrato)

Um contrato NEAR na linguagem Rust pode ser resumido aos seguintes passos:
 - Importar crates, módulos e outras dependências necessárias.
 - Macro de alocação.
 - Declaração de contrato.
 - Declaração de api do contrato.
 - Testes de unidade.

O desenvolvedor é livre para adicionar o que julgar necessário ao projeto. Os passos acima são apenas para acelerar a memorização.

---

### Importar Dependências
[topo](#li%C3%A7%C3%A3o-1-contrato)

Isto é explicado em detalhes na "lição 4 - módulos". Só precisamos saber sobre as diferenças entre mod e use. Por exemplo:

```rust
use near_sdk::near_bindgen;
```

Acessa a crate near_sdk e inclui o macro near_bindgen neste namespace. Sem isso, precisariamos escrever "near_sdk::near_bindgen" todas as vezes que precisarmos deste elemento. Mas agora podemos simplesmente escrever "near_bindgen".

Por outro lado, a instrução:

```rust
mod outro_modulo;
```

Significa que existe um arquivo de nome "outro_modulo.rs" ou um diretório com o nome "outro_modulo" no mesmo diretório deste arquivo rust. Para mais detalhes, procure por lesson_4_modules.

Se houvesse pub antes da instrução, como os exemplos:

```rust
pub mod outro_modulo;
```

Ou:

```rust
mod outro_modulo;

pub use outro_modulo::alguma_dependencia;
```

Demonstram que "outro_modulo" e "alguma_dependencia" podem ser importados por um outro módulo ou crate (projeto rust) externos. 

Para mais detalhes, procure por lesson_4_modules. Importar e exportar módulos é uma característica da linguagem Rust. Não tem nenhum efeito direto na plataforma NEAR.

Agora, referindo ao contrato:

```rust
use near_sdk::{
    borsh::{
        self,
        BorshDeserialize,
        BorshSerialize,
    },
    near_bindgen,
};
```

Estamos acessando a crate "near_sdk" declarado em "Cargo.toml". Importando self, BorshDeserialize e BorshSerialize no módulo borsh. E importando near_bindgen. Seguem as descrições simplificadas:

 - **self**: Nem eu sei exatamente o que isso faz, mas é necessário para BorshDeserialize e BorshSerialize funcionarem corretamente.
 - **BorshDeserialize**: Quando chamamos uma função do nosso contrato, devemos enviar parâmetros. Mesmo que estes parâmetros sejam um json vazio, este deve ser deserializado. Este é o objetivo de BorshDeserialize, recebe um json em texto, transforma nos tipos que precisamos.
 - **BorshSerialize**: Caminho inverso do BorshDeserialize. Quando vamos retornar um resultado para o usuário, devemos transformar aquele valor para um json em texto.
 - **near_bindgen**: Isso é um marcador para um struct que diz **"Este é o contrato principal do nosso projeto"**. Damos o nome "Contract" apenas para facilitar o entendimento, não é obrigatório. Porém deve-se ter pelo menos um struct com **near_bindgen** em cada contrato.

---

### Macro de alocação
[topo](#li%C3%A7%C3%A3o-1-contrato)

```rust
near_sdk::setup_alloc!();
```

Macros parecem com funções. Mas são executadas antes da compilação. São ferramentas para gerar código de acordo com os parâmetros. Macros não existem no runtime do programa.

Neste caso, "setup_alloc" gera o código "boilerplate" (forma) para o funcionamento do nosso contrato. Só deve ser executado uma vez, antes da declaração do contrato.

Aviso: Nas próximas versões esta instrução será deprecada. Não será necessário usar mais.

---

### Declaração de contrato
[topo](#li%C3%A7%C3%A3o-1-contrato)

```rust
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Contract{
    counter: i32,
}
```

Será mais fácil descrever de dentro para fora.
 - **counter**: é um número. i32 quer dizer que é "signed", pode ser positivo ou negativo. 32 quer dizer que é um número de 32 bits.
 - **pub struct Contract**: é a declaração de um struct de nome Contract. "pub" quer dizer que este struct é público.
 - **#[derive(BorshDeserialize, BorshSerialize)]**: Simplificando, aplica as traits BorshDeserialize e BorshSerialize neste struct. Descritos acima.
 - **[near_bindgen]**: É um marcador que diz "Este é o Contrato". As funções deste struct são as funções do contrato. Quando executamos uma função do contrato, executamos uma função deste struct.

Logo a seguir temos também:

```rust
impl Default for Contract{
    fn default() -> Self{
        Contract { counter: 0 }
    }
}
```

Default é uma trait (característica) de "padrão". É praticamente um construtor sem parâmetros para o nosso struct. Mas, Default é uma trait padronizada da linguagem Rust. near_sdk usa essa trait no funcionamento do nosso contrato. Então precisamos aplicar ao nosso contrato, senão teremos um erro de compilação.

default é uma função da trait Default que retorna um struct do mesmo tipo Self. Self nesta declaração é o mesmo que Contract. A função retorna uma instância de Contract com o valor de counter igual a 0.

Se implementarmos este contrato em uma conta NEAR, e depois executarmos uma primeira função que não seja de inicialização. A máquina irá inicializar o contrato com  default antes de executar nossa função.

---

### Declaração de API do contrato
[topo](#li%C3%A7%C3%A3o-1-contrato)

A seguir se encontram as funções do smart contract.

```rust
#[near_bindgen]
impl Contract{

    pub fn get(&self) -> i32 {
        self.counter
    }

    pub fn increment(&mut self) -> i32 {
        self.counter += 1;
        self.counter
    }

    pub fn decrement(&mut self) -> i32 {
        self.counter -= 1;
        self.counter
    }
}
```

 - ```#[near_bindgen]``` é um marcador que diz "estas são as funções do contrato".
 - ```impl Contract``` é onde declaramos as funções e métodos associados ao struct Contract.
 - ```&self``` e ```&mut self``` são descritos na lição seguinte. Só precisamos saber que esse tipo de função é invocada no formato ```nome_do_struct.nome_da_funcao```, self neste caso se refere a instância existente deste struct.
 - ```-> i32``` significa que a função retorna um inteiro i32.
 - No fim da função temos uma linha ```self.counter``` sem ponto-virgula ";". Isso é o mesmo que ```return self.counter```.

Com estes detalhes, vemos que a função ```get``` retorna o valor atual de counter armazenado no struct do contrato. ```increment``` incrementa o valor de counter em 1. ```decrement``` reduz o valor de counter em 1.

---

### Testes de unidade
[topo](#li%C3%A7%C3%A3o-1-contrato)

Descrito com mais detalhes na lição 4 - módulos, não é necessário ter todos os testes do projeto aqui. Podemos incluir testes no fim de cada módulo rust. Podemos também criar um diretório ```tests```. Todos os arquivos ".rs" na pasta ```tests``` será considerado um módulo de testes.

```rust
#[cfg(test)]
mod tests{
```

```mod tests``` é simplesmente um módulo local com nome tests. Nada de especial.

```#[cfg(test)]``` este é bem interessante. ```cfg``` é uma instrução que diz ao compilador "Compile o módulo abaixo de mim apenas se a condição entre parenteses for verdadeira.". ```(test)``` é verdadeiro quando executamos ```cargo test```. Se não estivermos realizando testes de unidade, este módulo não existe.

Se em vez de ```#[cfg(test)]``` tivéssemos:

```rust
#[cfg(not(test))]
mod another_module{
```

Teriamos a situação oposta, este módulo não seria compilado durante testes de unidade.

```rust
use super::*;
use near_sdk::{
    AccountId,
    env,
    MockedBlockchain,
    testing_env,
    test_utils::VMContextBuilder,
    json_types::ValidAccountId,
};
```
Acima importamos as dependências usadas nos testes abaixo.

```rust
fn env_setup(){
    let mut builder: VMContextBuilder = VMContextBuilder::new();
    let account_id: AccountId = String::from("stiltztinkerstein");

    builder.current_account_id(
        ValidAccountId::try_from(
            account_id.clone()
        ).unwrap()
    );

    testing_env!(builder.build());

    assert_eq!(
        env::current_account_id(),
        account_id, 
        "Erro assert.\n env: {}\naccount: {}\n", 
        env::current_account_id(), 
        &account_id,
    );
}
```

Antes de cada teste, precisamos iniciar uma simulação do ambiente de blockchain. Uma das formas de fazer isso é utilizando ```VMContextBuilder```. Basta criar uma instância desse tipo, alterar os atributos que queremos, e usar o builder como argumento para o macro ```testing_env```.

Para não termos que escrever estas linhas em cada teste, criamos uma função para ser usada.

```assert_eq``` não é necessário. Só mostra que o atributo de ambiente ```env::current_account_id``` é o mesmo id de conta que escolhi para o builder.

A seguir teremos os três testes: 

```rust
#[test]
pub fn get() {
    env_setup();

    let contract: Contract = Contract::default();
    
    assert_eq!(
        contract.get(),
        0
    );
}

#[test]
pub fn increment() {
    env_setup();

    let mut contract: Contract = Contract::default();

    contract.increment();

    assert_eq!(
        contract.get(),
        1
    );
}

#[test]
pub fn decrement() {
    env_setup();

    let mut contract: Contract = Contract::default();

    contract.decrement();

    assert_eq!(
        contract.get(),
        -1
    );
}
```

Percebe-se um padrão em cada um dos testes:
 - Inicializar o ambiente;
 - Inicializar o contrato;
 - Executar a função que queremos testar;
 - Confirmar que a função deu o resultado que esperamos;

A função ```get``` foi testada primeiro. Isto porque esta será usada nos testes seguidos. Se esta função não funcionasse da forma que esperassemos, temos que ver este erro primeiro na lista. Bom para evitar confusões nos testes. 

A [próxima lição](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/ES/lesson_2_ownership) será sobre ownership.

'''
'''--- ES/lesson_1_contract/src/lib.rs ---
//! Fonte <https://github.com/near-examples/rust-counter>
//! 
//! 
//! 

// Dicas sobre documentação:
// comentarios com // não aparecem na documentação.
// comentarios com /// aparecem como descrição para o que estiver a seguir (mod, fn, struct, enum, trait...)
// comentarios com //! podem apenas existir no inicio do arquivo, representam a descrição de todo o módulo.

// módulos importados
use near_sdk::{
    // Parâmetros recebidos e valores retornados são convertidos para json com esse módulo
    borsh::{
        self,
        BorshDeserialize,
        BorshSerialize,
    },
    // env,
    // Cria o boilerplate necessário para máquinas virtuais NEAR
    near_bindgen,
};

near_sdk::setup_alloc!();

/// Contrato. Este struct contém o estado (state) da máquina virtual.
/// As funções deste struct são as funções do contrato.
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Contract{
    /// Contador.
    counter: i32
}

// Default é executado quando o contrato não inicializado manualmente.
impl Default for Contract{
    fn default() -> Self{
        Contract { counter: 0 }
    }
}

#[near_bindgen]
impl Contract{

    /// Retorna o contador.
    pub fn get(&self) -> i32 {
        // return self.counter;
        self.counter
    }

    /// Incrementa o contador em 1.
    pub fn increment(&mut self) -> i32 {
        self.counter += 1;
        self.counter
    }

    /// Decrementa o contador em 1.
    pub fn decrement(&mut self) -> i32 {
        self.counter -= 1;
        self.counter
    }
}

// Nossos testes de unidade ficam aqui.
// cfg(test) quer dizer que esse mod só será compilado em ambientes de teste.
#[cfg(test)]
mod tests{
    // super::* importa todos os módulos acima.
    use super::*;
    // alguns módulos que só usaremos em situações de teste
    use near_sdk::{
        // um id de conta como por exemplo "stiltztinkerstein.near"
        AccountId,
        // possui métodos relacionados ao ambiente de execução.
        // por exemplo, se quisermos saber o nome do usuário que executou
        // esse contrato, usaremos uma função no módulo env.
        env,
        // Simula o blockchain
        MockedBlockchain,
        // Macro que inicializa o ambiente de text com o contexto informado.
        testing_env,
        // Usado para criar um contexto de teste.
        test_utils::VMContextBuilder,
        // Simplesmente representa um Id de Conta valido.
        // Um id de conta é um string, mas não é todo string que é um id válido.
        json_types::ValidAccountId,
    };

    /// Essa função não é um teste. É usada pelos testes para simular
    /// um ambiente de teste.
    fn env_setup(){
        // inicializa um construtor de contexto de teste.
        let mut builder: VMContextBuilder = VMContextBuilder::new();

        // atributos que podem ser editados com o builder:
        // current_account_id
        // signer_account_id
        // signer_account_pk
        // precessor_account_id
        // block_index
        // block_timestamp
        // epoch_height
        // account_balance
        // account_locked_balance
        // storage_usage
        // attached_deposit
        // prepaid_gas
        // random_seed
        // is_view

        // string com nome account_id
        let account_id: AccountId = String::from("stiltztinkerstein");

        builder.current_account_id(
            // try_from tenta converter o string acima para um id valido
            // panic se o id é invalido.
            ValidAccountId::try_from(
                account_id.clone()
            ).unwrap()
        );

        // inicializa simulação
        testing_env!(builder.build());

        // Se os dois primeiros parametros não são iguais, 
        // retorna a mensagem de erro seguinte.
        assert_eq!(
            env::current_account_id(),
            account_id, 
            "Erro assert.\n env: {}\naccount: {}\n", 
            env::current_account_id(), 
            &account_id,
        );
    }

    /// Como tem o marcador #[test] vai executar automaticamente
    /// quando realizarmos testes de unidade.
    #[test]
    pub fn get() {
        env_setup();

        let contract: Contract = Contract::default();
        
        assert_eq!(
            contract.get(),
            0
        );
    }

    #[test]
    pub fn increment() {
        env_setup();

        let mut contract: Contract = Contract::default();

        contract.increment();

        assert_eq!(
            contract.get(),
            1
        );
    }

    #[test]
    pub fn decrement() {
        env_setup();

        let mut contract: Contract = Contract::default();

        contract.decrement();

        assert_eq!(
            contract.get(),
            -1
        );
    }
}

'''
'''--- ES/lesson_2_ownership/Cargo.toml ---
[package]
name = "lesson_2_ownership"
version = "0.1.0"
authors = ["Lucas Lemos <stiltztinkerstein@gmail.com>"]
license = "MIT"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- ES/lesson_2_ownership/Readme.md ---
# Lição 2: Ownership

[voltar](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/ES/)

Este curto tutorial possui o objetivo de explicar sobre ownership.

---

## Funções de Contrato

```rust
/// Retorna o comprimento da String armazenada
pub fn get_length(&self) -> u32;

/// Retorna o comprimento da String e altera o nome armazenado para "Changed name"
pub fn get_length_again(&mut self) -> u32;
```

---

## Hipótese

Ownership é explicado na seção seguinte. Esta discute o problema que ownership soluciona.

Consideremos a instrução exemplo a seguir:

```
A = B;
```

Sabemos que A é igual a B. A recebe o valor de B. Mas o que está acontecendo? 

Estamos criando uma cópia do valor de B e associando A a este valor? Criar uma cópia significa requisitar alocação de memória, adiquirir o endereço da memória e igualar o valor desse endereço ao valor de B. Para um número inteiro isso parece simples, mas e se fosse uma string de 2 mil caracteres?

E se usarmos uma variável como parâmetro de função. Estariamos criando uma cópia da variável e depois apagando a cópia no fim da função?

Percebe-se que precisamos de uma forma de reutilizar o mesmo endereço de memória em várias partes diferentes do programa. A linguagem C solucionou isso através do uso de ponteiros. Em vez de armazenarmos o valor da variável, nós armazenamos o endereço de memória daquele tipo de variável.

Mas isso nos trás outro problema. Se uma função tem acesso ao endereço de memória de uma variável importante, essa função agora tem muito poder. E se o método foi implementado de uma forma insegura? Um hacker poderia aproveitar essa falha de segurança para acessar um sistema.

 - Precisamos de uma forma de reutilizar memória para evitar sobrecarregar o sistema com operações desnecessárias.
 - Mas precisamos evitar que esse uso de memória dê mais poder as instruções do que é necessário.

**Extra:** Ponteiros existem em Rust também. Mas existem vários tipos de ponteiros, com diferentes vantagens e desvantagens. Ponteiros semelhantes à linguagem C podem ser utilizados também, mas os blocos que os utilizam precisam ser marcados como "unsafe" ([Mais Informações](https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html)).

---

## Ownership

A instrução a seguir:

```
A = B;
```

Pode agir de duas formas diferentes:
 - Se **B** implementa a trait Copy, irá criar uma cópia automaticamente.
 - Se **B** não implementa Copy, **A** será dona de **B** agora. O compilador não deixará realizarmos instruções com **B**, porque o valor de **B** foi "movido" para **A**.

Dos tipos primitivos: 
 - Números (```u32```, ```f32```, ```i32```, ...) implementam ```Copy``` e ```Clone```. 
 - String implementa ```Clone```, mas não implementa ```Copy```. 

Em outras palavras, para criarmos uma cópia de um String, precisamos fazer isso manualmente.

Ownership garante que apenas uma variável é dona ("owns") de um endereço de váriável. Essa possessão pode ser transferida. Mas para compartilharmos uma variável, usamos ponteiros ou referências.

---

## Referências

Referências, ou empréstimos ("borrows") são uma forma de compartilhar um endereço de memória com permissões limitadas. As referências podem ser mutáveis ou imutáveis. São escritas, respectivamente, da seguinte forma:

```rust
let a = 10; // Criando uma variável com valor 10
let b = &a; // Criando uma variável que é uma referência à variavel a
```

```rust
let mut a = 10; // Criando uma variável mutável com valor 10
let b = &mut a; // Criando uma variável que é uma referência mutável à variavel a
```

Variáveis são, por padrão, imutáveis, constantes. Por isso declarei ```a``` mutavel no segundo exemplo.

 - Referências imutáveis permitem acessar o valor, mas não permitem alterá-lo.
 - Referências mutáveis permitem acessar o valor e permitem alterá-lo.

Algumas regras a considerar:
 - Não se pode alterar a variável original enquanto uma referência ainda existe.
 - Várias referências imutáveis podem existir.
 - Só uma referência mutável pode existir.
 - Não podem existir referências imutáveis se uma referência mutável existe.

Quando criamos uma referência, digamos que a variável dona está "emprestando" ("borrow") para a outra. A linha em que o empréstimo é utilizado por ultimo é a linha em que o empréstimo é devolvido.

---

## Importante

Não retorne referências. Retornar referências é possivel, mas é preciso marcar o tempo-de-vida (lifetime) do valor retornado. Não recomendamos estudar isso enquanto está aprendendo a linguagem rust. Todo o conceito de lifetimes pode ser evitado simplesmente retornando cópias quando necessário. Para os interessados, referências [aqui](https://doc.rust-lang.org/rust-by-example/scope/lifetime.html).

Lifetimes são um conceito bem poderoso quando usado corretamente. As ferramentas serde e borsh usam isso para converter texto json para o tipo que precisamos com zero cópia. Ou seja, existe alocação de memória para o String json, para o tipo que precisamos, e nada mais. O processador não precisa esperar alocação de memória, ou seja, muito rápido.

---

## Exemplos

Para o contrato descrito a seguir:

```rust
#[near_bindgen]
#[derive(Clone, BorshDeserialize, BorshSerialize)]
pub struct Contract {
    name: String,
}

impl Default for Contract{
    fn default() -> Self {
        return Contract {
            name: String::from("A default string"),
        };
    }
}
```

Temos os exemplos a seguir:

```rust
fn this_takes_a_reference(name: &str) -> usize { 
        return name.len();
    }

fn this_takes_the_ownership(name: String) -> usize {
    name.len()
}

pub fn get_length(&self) -> u32 {
    let length_reference: usize = Self::this_takes_a_reference(&self.name);
    let length_ownership: usize = Self::this_takes_the_ownership(self.name.clone());

    assert_eq!(
        length_reference, 
        length_ownership, 
        "Ambos tamanhos não são o mesmo {} e {}", length_reference, length_ownership,
    );

    length_reference as u32
}

pub fn get_length_again(&mut self) -> u32 {
    let a_reference: &String = &self.name;
    let _another_reference: &String = &self.name;
    let _yet_another_reference: &String = &self.name;
    let length = Self::this_takes_a_reference(a_reference);
    self.name = String::from("Changed name");

    length as u32
}
```

Antes de iniciarmos com os detalhes falaremos sobre String e &str.

---

### O que é String

Uma String é uma variável que possui dono. Armazena um "string" e irá ser liberado da memória quando a variável ser liberada. Mas "Um texto entre aspas como este não é um String, é um &str". Uma referência a um String é um &String ou &mut String.

---

### O que é &str

Isso é um tipo criado para simplificar o uso de Strings em nosso código. Age como uma referência imutável à um String. Mas este será alocado pelo compilador, e o compilador decide como melhor otimizá-lo na memória.

---

### Strings em Funções

Consideraremos as duas variáveis abaixo para o exemplo:

```rust
let variavel: String = String::from("Uma Variavel");
let referencia: &str = "Uma Variavel";
```

A função abaixo recebe um &str e retorna o comprimento da string. O empréstimo é devolvido no fim da função.

```rust
fn this_takes_a_reference(name: &str) -> usize { 
    return name.len();
}
```

Para utilizar a função com os parâmetros:

```rust
this_takes_a_reference(&variavel);
this_takes_a_reference(referencia);
```

A função abaixo recebe um String como parâmetro e retorna o comprimento. A função se torna dona do endereço de memória e o deleta no fim.

```rust
fn this_takes_the_ownership(name: String) -> usize {
    name.len()
}
```

Para utilizar a função com os parâmetros:

```rust
this_takes_the_ownership(variavel);
this_takes_the_ownership(String::from(referencia));
```

Precisamos de transformar o &str em um String antes de usar como parâmetro. A função adiquiriu ownership quando não precisava também.

Ambas as funções ```this_takes_a_reference``` e ```this_takes_the_ownership``` fazem a mesma coisa, não causam erros, e retornam o mesmo resultado. Mas a primeira é bem mais eficiente do que a segunda.

Por isso, é boa prática usar ```&str``` em vez de ```String``` nas declarações de função.

Eu lamento ter que adicionar mais um detalhe nessa explicação, mas funções de contrato, aquelas em que precisamos de marcar com ```#[near_bindgen]``` precisam de receber String como parâmetro. Isso é porque as traits de deserialização são implementadas para String, mas não são implementadas para referências de string.

A função:

```rust
pub fn get_length(&self) -> u32 {
    let length_reference: usize = Self::this_takes_a_reference(&self.name);
    let length_ownership: usize = Self::this_takes_the_ownership(self.name.clone());

    assert_eq!(
        length_reference, 
        length_ownership, 
        "Ambos tamanhos não são o mesmo {} e {}", length_reference, length_ownership,
    );
}
```

Chama ```this_takes_a_reference``` e ```this_takes_the_ownership```, garantindo que ambas retornam o mesmo valor antes de retorná-lo. Como ```this_takes_the_ownership``` não pega o valor emprestado, criamos uma cópia para ser usada como necessário.

A função:

```rust
pub fn get_length_again(&mut self) -> u32 {
    let a_reference: &String = &self.name;
    let _another_reference: &String = &self.name;
    let _yet_another_reference: &String = &self.name;
    let length = Self::this_takes_a_reference(a_reference);
    self.name = String::from("Changed name");

    length as u32
}
```

Simplesmente chama ```this_takes_a_reference``` e altera o "nome" armazenado no contrato. Este exemplo mostra que podem haver várias referências para uma variável. Faça as alterações recomendadas nos comentários para ver as reações do compilador.

A [próxima Lição](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/ES/lesson_3_structs) será sobre structs.

'''
'''--- ES/lesson_2_ownership/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
#[allow(unused_imports)]
use near_sdk::{env, near_bindgen};

// Macro que gera codigo boilerplate para o projeto. Vai ser deprecado nas proximas versões.
near_sdk::setup_alloc!();

#[near_bindgen]
#[derive(Clone, BorshDeserialize, BorshSerialize)]
pub struct Contract {
    name: String,
}

impl Default for Contract{
    fn default() -> Self {
        // Inicializar com a String "A default string" como exemplo
        return Contract {
            name: String::from("A default string"),
        };
    }
}

#[near_bindgen]
impl Contract{
    // &str é uma referencia para uma string
    // strings entre aspas " " são 'static &str
    // então ter &str como parâmetro permite ter tanto &String como "uma string estatica como essa"
    /// Retorna o tamanho da string.
    fn this_takes_a_reference(name: &str) -> usize { 
        return name.len();
    }

    // Essa função faz o mesmo que o de cima, mas recebe uma String como parâmetro.
    // Teriamos que converter para uma String dessa forma: String::from("essa")
    /// Retorna o tamanho da string.
    fn this_takes_the_ownership(name: String) -> usize {
        // retorna usize, usize é u32 em sistemas 32 bit, u64 em sistemas 64 bit
        name.len()
    }

    /// Retorna o tamanho da string armazenada.
    pub fn get_length(&self) -> u32 {
        // Irá chamar ambos os métodos para mostrar que ambos fazem a mesma coisa.
        //
        // Adicionando & antes de cada parametro é o mesmo que dizer:
        // "Estou dando permissão para esta função olhar o valor dessa variável, mas não estou dando permissão para modificá-lo".
        let length_reference: usize = Self::this_takes_a_reference(&self.name);

        // this_takes_the_ownership quer ter possessão de uma String, então precisamos criar uma cópia para essa.
        let length_ownership: usize = Self::this_takes_the_ownership(self.name.clone());

        // Chamando assert_eq para provar que ambas são iguais.
        // Se os valores são diferentes, o código entra em pânico.
        assert_eq!(
            // primeiro parâmetro para comparar
            length_reference, 
            // segundo parâmetro para comparar
            length_ownership, 
            // Se ambas não são iguais, entra em pânico com a mensagem de erro abaixo
            "Ambos tamanhos não são o mesmo {} e {}", length_reference, length_ownership,
        );

        // Converter para u32 porque é um formato simples para json
        // tipos podem ser convertidos usando as traits "into" e "from" também
        length_reference as u32
    }

    /// Retorna o tamanho da String armazenada. Também muda o nome para "Changed name"
    pub fn get_length_again(&mut self) -> u32 {
        // podemos declarar variaveis que armazenam referencias para um outro valor.
        let a_reference: &String = &self.name;
        let _another_reference: &String = &self.name;
        let _yet_another_reference: &String = &self.name;

        // Podemos ter varias referências imutaveis ao mesmo tempo.
        // Mas não podemos alterar uma variavel enquanto referências imutáveis existirem.
        // Se precisarmos tirar uma referência mutavel, não devem haver referências imutaveis existindo.

        // Descomente a linha adiante para receber um erro devido a referências existentes.
        // self.name = String::from("Changed name");

        let length = Self::this_takes_a_reference(a_reference);

        // A linha adiante é ok porém, porque as referências acima não são usadas novamente.
        // Como não são usadas novamente, o compilador sabe que pode liberá-las da memória.
        self.name = String::from("Changed name");

        length as u32
    }
}

#[cfg(test)]
mod tests{
    use super::*;
    use near_sdk::{
        AccountId,
        env,
        MockedBlockchain,
        testing_env,
        test_utils::VMContextBuilder,
        json_types::ValidAccountId,
    };

    fn env_setup(){
        let mut builder: VMContextBuilder = VMContextBuilder::new();

        // atributos que podemos modificar com o builder
        // current_account_id
        // signer_account_id
        // signer_account_pk
        // precessor_account_id
        // block_index
        // block_timestamp
        // epoch_height
        // account_balance
        // account_locked_balance
        // storage_usage
        // attached_deposit
        // prepaid_gas
        // random_seed
        // is_view

        let account_id: AccountId = String::from("stiltztinkerstein");

        builder.current_account_id(
            ValidAccountId::try_from(
                account_id.clone()
            ).unwrap()
        );

        testing_env!(builder.build());

        assert_eq!(
            env::current_account_id(),
            account_id, 
            "Erro assert. env: {} account: {}", 
            env::current_account_id(), 
            &account_id,
        );
    }

    #[test]
    pub fn get_length() {
        env_setup();
    
        let mut contract: Contract = Contract::default();
    
        // Ambas funções fazem a mesma coisa, então ambas devem retornar o mesmo valor.
        assert_eq!(
            contract.get_length(),
            contract.get_length_again()
        );

        // get_length_again também modifica a string armazenada.
        assert_eq!(
            contract.name,
            "Changed name"
        );
    }
}
'''
'''--- ES/lesson_3_structs/Cargo.toml ---
[package]
name = "lesson_3_structs"
version = "0.1.0"
authors = ["Lucas Lemos <stiltztinkerstein@gmail.com>"]
license = "MIT"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- ES/lesson_3_structs/Readme.md ---
# Lição 3 - Structs

[voltar](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/ES/)

Esta lição discute sobre o formato de structs e como ownership é usada nos métodos.

---

## Tópicos

 - [Descrição](#descri%C3%A7%C3%A3o)
 - [Funções de Contrato](#fun%C3%A7%C3%B5es-de-contrato)
 - [Projeto](#projeto)
   - [Estrutura de Contrato](#estrutura-de-contrato)
   - [Trait Clone](#trait-clone)
   - [just_a_function](#just_a_function)
   - [macros](#macros)
   - [take_ownership](#take_ownership)

---

## Descrição
[voltar](#li%C3%A7%C3%A3o-3---structs)

Structs são um pouco semelhantes a classes em algumas linguagens orientadas a objetos. A diferença é que ```structs``` não podem herdar outros ```structs```, só podem implementar ```traits```.

Aprofundaremos o conceito de traits em uma lição adiante. Mas considere traits como um conjunto de funções representando uma característica que vários tipos diferentes podem implementar. A trait ```Clone``` permite usar o método ```.clone()``` para criar uma cópia do elemento. A trait ```BorshDeserialize``` permite tentar construir uma instância do tipo utilizando um string no formato json.

Mais adiante aprenderemos a criar funções que aplicam a qualquer tipo de variável que implementa uma trait especifica. Porém, essa lição será apenas sobre structs.

---

## Funções de Contrato
[voltar](#li%C3%A7%C3%A3o-3---structs)

```rust
// gets e sets
pub fn get_a_string(&self) -> String;

pub fn get_a_floating(&self) -> f32;

pub fn get_another_integer(&self) -> i32;

pub fn get_an_integer(&self) -> u32;

pub fn set_a_string(&mut self, a_string_arg: String);

pub fn set_a_floating(&mut self, a_floating: f32);

pub fn set_an_integer(&mut self, an_integer: u32);

pub fn set_another_integer(&mut self, another_integer: i32);

// Uma função que não altera nem acessa o estado do contrato
pub fn just_a_function();

// Uma função StructExample que toma ownership de si mesmo, se deletando no final.
pub fn take_ownership(&self) -> u32;
```

Cheque a implementação para mais detalhes.

---

## Projeto

[voltar](#li%C3%A7%C3%A3o-3---structs)

Criamos um tipo de nome ```StructExample```.

```rust
pub struct StructExample{
    an_integer: u32,
    another_integer: i32,
    a_floating: f32,
    a_string: String,
}
```
O tipo possui os seguintes valores internos:
 - an_integer: um inteiro positivo de 32 bits;
 - another_integer: um inteiro positivo ou negativo de 32 bits;
 - a_floating: um número real de 32 bits;
 - a_string: um string, descrito na lição anterior;

Em muitas linguagens teriamos que escrever algo como ```long int``` para i32, ```long long int``` para i64. Em rust e assemblyscript, simplesmente usamos i para "signed" (positivo e negativo) e u para "unsigned" (positivo). u8, u16, u32, u64 e u128 são todos tipos válidos de inteiros "unsigned".

---

### Estrutura de Contrato

[voltar](#li%C3%A7%C3%A3o-3---structs)

O contrato possui a seguinte estrutura:

```rust
#[derive(BorshDeserialize, BorshSerialize, Default)]
pub struct Contract {
    struct_example: StructExample,
}
```

Este exemplo de contrato deriva a trait ```Default``` em vez de implementar manualmente. Essa forma de implementar executa o método ```.default()``` para todos os valores internos. Devido a isso, o tipo ```struct_example``` deve implementar ```Default``` também.

```rust
impl Default for StructExample{
    fn default() -> Self {
        let an_integer: u32 = 1;
        let a_floating: f32 = 0.5;

        StructExample {
            an_integer,
            another_integer: -1,
            a_floating,
            a_string: String::from("A default string"),
        }
    }
}
```

Escolhemos alguns valores aleatórios para servir de exemplo. Vemos que não é necessário escrever algo como ```an_integer: an_integer``` ou ```a_floating: a_floating``` quando os nomes são iguais.

---

### Trait Clone

[voltar](#li%C3%A7%C3%A3o-3---structs)

Implementamos a trait Clone para o tipo:

```rust
impl Clone for StructExample{
    // self é uma instancia de StructExample, Self (Letra maiúscula) é o tipo StructExample.
    fn clone(&self) -> Self {
        let an_integer: u32 = self.get_an_integer();
        let another_integer: i32 = self.get_another_integer();
        let a_floating: f32 = self.get_a_floating();
        let a_string: String = self.get_a_string();

        // Self e StructExample são a mesma coisa (Em qualquer impl de StructExample)
        Self {
            an_integer,
            another_integer,
            a_floating,
            a_string,
        }
    }
}
```

**Vale relembrar que estou intencionalmente escrevendo o código de forma mais complexa apenas para demonstrar as diversas liberdades que temos na implementação de nossos projetos.**

Não há muito o que adicionar sobre as implementações dos ```get```s e ```set```s. Recomendo checar os comentários. Mas discutiremos sobre ```just_a_function``` e ```take_ownership``` a seguir:

---

### just_a_function

[voltar](#li%C3%A7%C3%A3o-3---structs)

```rust
pub fn just_a_function() {
    env::log(b"You just called this function");
    env::log(format!("1 + 1 = {}", 1 + 1).as_bytes());
}
```
Esta função imprime duas linhas de texto. 

A função ```log``` recebe uma sequência de bytes como parâmetro. Devido a isso, a primeira linha mostra que podemos incluir a letra "b" antes das aspas para tratar a string como bytes.

Na segunda instrução usamos o macro ```format!``` para formatar uma String dinamicamente. O tipo String possui um método ```.as_bytes``` que converte o tipo para bytes. Para mais detalhes sobre String, cheque os [docs oficiais](https://doc.rust-lang.org/std/string/struct.String.html#method.as_bytes).

---

### Macros
[voltar](#li%C3%A7%C3%A3o-3---structs)

Serão explicados mais adiante. Para simplificar o entendimento inicial, considere **macros** como funções que são executadas antes do código ser compilado. São funções que geram código. Só depois do **macro** gerar código que o compilador checa por erros. O uso mais comum de **macros** é para agir como funções que recebem um número variado de parâmetros.

Outra forma de vermos **macros** é: uma forma de trocar complexidade de código por praticidade de uso.

---

### take_ownership
[voltar](#li%C3%A7%C3%A3o-3---structs)

```rust
pub fn take_ownership(self) -> u32{
    env::log(b"Taking ownership of itself");

    let result = format!("an_integer is {}", self.an_integer);
    env::log(result.as_bytes());

    self.an_integer

    // self será liberado da memória aqui
}
```

Acho esse exemplo interessante. 
 - Imprime "Taking ownership of itself" na tela. 
 - Imprime o valor de ```an_integer``` no contrato. 
 - E retorna o valor de ```an_integer```.

Mas como declaramos ```self``` em vez de ```&self``` ou ```&mut self``` como argumento, o método tomará possessão (ownership) de si mesmo e se auto-destruira no fim. 

Um usuário iniciante provavelmente receberá um aviso de erro muito confuso se tentar escrever o método dessa forma. Um erro similar a "valor não pode ser usado pois um move aconteceu aqui.".

A [próxima lição](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/ES/lesson_4_modules) será sobre módulos.

'''
'''--- ES/lesson_3_structs/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
#[allow(unused_imports)]
use near_sdk::{env, near_bindgen};

near_sdk::setup_alloc!();

// derive usa um macro para aplicar as traits no tipo StructExample.
// Implementamos isso porque o contrato precisa de BorshDeserialize e BorshSerialize.
// StructExample é um state do Contract, então declaramos derive aqui também.
#[derive(BorshDeserialize, BorshSerialize)]
// Um struct com tipos primitivos
pub struct StructExample{
    an_integer: u32,
    another_integer: i32,
    a_floating: f32,
    a_string: String,
}

// default é executado quando o codigo é carregado ao contrato e não é inicializado.
// Pode ser chamado manualmente para criar uma instância com valores padrão.
impl Default for StructExample{
    fn default() -> Self {
        // Cada atributo do StructExample é setado da forma Nome: Valor,
        // Não é preciso setar da forma nome: nome,
        let an_integer: u32 = 1;
        let a_floating: f32 = 0.5;

        StructExample {
            an_integer,
            another_integer: -1,
            a_floating,
            a_string: String::from("A default string"),
        }
    }
}

// Clone é uma forma de criar uma copia desse struct manualmente.
impl Clone for StructExample{
    // self é uma instancia de StructExample, Self (Letra maiúscula) é o Tipo StructExample.
    fn clone(&self) -> Self {
        let an_integer: u32 = self.get_an_integer();
        let another_integer: i32 = self.get_another_integer();
        let a_floating: f32 = self.get_a_floating();
        let a_string: String = self.get_a_string();

        // Self e StructExample são a mesma coisa (Em qualquer impl de StructExample)
        Self {
            an_integer,
            another_integer,
            a_floating,
            a_string,
        }

    }
}

// Aqui que métodos e funcões para o struct são implementados.
impl StructExample{

    // &self quer dizer que irá emprestar uma instância de StructExample, mas não irá alterá-la
    /// Retorna a copia de a_string
    pub fn get_a_string(&self) -> String {

        // Strings implementam a trait Clone mas não implementam Copy
        // Copy cria uma cópia da instância automaticamente quando ha uma instrução a = b
        // Clone cria uma cópia da instância quando o código chama clone()
        let a_string: String = self.a_string.clone();

        return a_string;
    }

    pub fn get_a_floating(&self) -> f32 {
        // f32 implementa Copy, então esta linha irá automaticamente criar uma copia de a_floating
        return self.a_floating;
    }

    pub fn get_another_integer(&self) -> i32 {
        // Não precisamos escrever "return" sempre.
        // Se a expressão não termina com ponto e virgula ";" retorna a expressão
        self.another_integer
    }

    pub fn get_an_integer(&self) -> u32 {
        self.an_integer
    }

    // &mut self quer dizer que irá emprestar uma instância de StructExample e fazer modificações a este.
    pub fn set_a_string(
        &mut self, 
        // detalhe importante: como não há referência & para a String, estamos tomando possessão (ownership) desta.
        // Quer dizer que a função é dona desta parte de memória.
        // Possessão de a_string_arg quer dizer que o código que o chamou não precisará usar a String novamente.
        //
        // Este é um dos superpoderes de Rust. Podemos criar código que cria o menor número de cópias possivel.
        a_string_arg: String,
    ) {
        // como emprestamos self mutavel, podemos alterar os valores internos
        self.a_string = a_string_arg;
    }

    pub fn set_a_floating(&mut self, arg: f32) {
        self.a_floating = arg;
    }

    pub fn set_an_integer(&mut self, an_integer: u32) {
        // u32 é unsigned, apenas valores positivos
        self.an_integer = an_integer;
    }

    pub fn set_another_integer(&mut self, another_integer: i32){
        // i32 é signed, pode ser positivo e negativo. Mas apenas metade do alcance máximo.
        self.another_integer = another_integer;
    }

    // Se o método não possui self, é apenas uma função comum associada ao tipo.
    pub fn just_a_function() {
        env::log(b"You just called this function");
        env::log(format!("1 + 1 = {}", 1 + 1).as_bytes());
    }

    // Se self está nos argumentos, a função toma possessão do tipo.
    // Quer dizer que o struct será deletado no fim da função (a não ser que retornemos ela).
    // É só um exemplo. Quase nunca terá que implementar uma função dessa forma.
    pub fn take_ownership(self) -> u32{
        env::log(b"Taking ownership of itself");

        let result = format!("an_integer is {}", self.an_integer);
        env::log(result.as_bytes());

        self.an_integer

        // self será liberado da memória aqui
    }
}

// #[near_bindgen] instrui near-sdk que esta struct representa o state principal do contrato.
// Podemos usar qualquer nome. Contract é só mais facil de entender.
#[near_bindgen]
// derive usa um macro para aplicar as traits no tipo StructExample.
// Implementamos isso porque o contrato precisa de BorshDeserialize e BorshSerialize.
// BorshSerialize converte o nosso tipo de retorno para json.
// BorshDeserialize converte os parâmetros em json para os tipos que nossa função chama.
#[derive(BorshDeserialize, BorshSerialize, Default)]
pub struct Contract {
    struct_example: StructExample,
}

#[near_bindgen]
impl Contract{
    // Abaixo são as mesmas funções do struct sendo chamadas aqui.
    // A diferença sendo que estas são como interagimos com o contrato.
    //
    // O método para get_a_string precisa de &self, então usamos &self ou &mut self
    pub fn get_a_string(&self) -> String {
        self.struct_example.get_a_string()
    }

    pub fn get_a_floating(&self) -> f32 {
        self.struct_example.get_a_floating()
    }

    pub fn get_another_integer(&self) -> i32 {
        self.struct_example.get_another_integer()
    }

    pub fn get_an_integer(&self) -> u32 {
        self.struct_example.get_an_integer()
    }

    // O método para set_a_string precisa de &mut self, então só podemos usar &mut self
    pub fn set_a_string(&mut self, a_string_arg: String) {
        self.struct_example.set_a_string(a_string_arg);
    }

    pub fn set_a_floating(&mut self, a_floating: f32) {
        self.struct_example.set_a_floating(a_floating);
    }

    pub fn set_an_integer(&mut self, an_integer: u32) {
        self.struct_example.set_an_integer(an_integer);
    }

    pub fn set_another_integer(&mut self, another_integer: i32) {
        self.struct_example.set_another_integer(another_integer);
    }

    // just_a_function não tem &self, &mut self nem self
    // É apenas uma função no namespace da struct. Não precisamos de usar self também.
    pub fn just_a_function(){
        // :: é usado para referenciar namespaces. Não é um metodo de uma instância de struct, apenas uma função.
        StructExample::just_a_function();
    }

    pub fn take_ownership(&self) -> u32 {
        // A função take_ownership libera o objeto da memória.
        // The compiler will not let us call it directly when the owner is Contract.
        // O compilador não irá nos deixar chamar isso diretamente enquanto o dono for Contract.
        // Most of the issues of ownership can be solved by just cloning the object.
        // A maioria dos problemas de possessão (ownership) podem ser resolvidos apenas clonando objetos
        let a_copy: StructExample = self.struct_example.clone();

        // a_copy será removido no fim dessa função abaixo.
        let result = a_copy.take_ownership();

        // Descomente a linha abaixo e um erro de "move" irá aparecer.
        // Isso é porque chamamos uma função de uma instância que não existe mais.
        // env::log(format!("Essa linha de código irá gerar um erro {}", a_copy.get_a_floating()).as_bytes());

        result
    }
}

// cfg diz ao compilador para considerar esse modulo apenas em um ambiente de teste. Este não existe fora dessas condições.
#[cfg(test)]
mod tests{
    use super::*;
    use near_sdk::{
        AccountId,
        env,
        MockedBlockchain,
        testing_env,
        test_utils::VMContextBuilder,
        json_types::ValidAccountId,
    };

    fn env_setup(){
        let mut builder: VMContextBuilder = VMContextBuilder::new();

        // atributos que podemos alterar com esse builder
        //
        // current_account_id
        // signer_account_id
        // signer_account_pk
        // precessor_account_id
        // block_index
        // block_timestamp
        // epoch_height
        // account_balance
        // account_locked_balance
        // storage_usage
        // attached_deposit
        // prepaid_gas
        // random_seed
        // is_view

        let account_id: AccountId = String::from("stiltztinkerstein");

        builder.current_account_id(
            ValidAccountId::try_from(
                account_id.clone()
            ).unwrap()
        );

        testing_env!(builder.build());

        assert_eq!(
            env::current_account_id(),
            account_id, 
            "Assert Error. env: {} account: {}
            ", 
            env::current_account_id(), 
            &account_id,
        );
    }

    #[test]
    pub fn get_a_string() {
        env_setup();
    
        let contract: Contract = Contract::default();
    
        // Este valor é da implementação padrão.
        assert_eq!(
            contract.get_a_string(),
            "A default string"
        );
    }

    #[test]
    pub fn get_a_floating(){
        env_setup();
    
        let contract: Contract = Contract::default();
    
        // Este valor é da implementação padrão.
        assert_eq!(
            contract.get_a_floating(),
            0.5,
        );

    }

    #[test]
    pub fn get_another_integer(){
        env_setup();
    
        let contract: Contract = Contract::default();
    
        // Este valor é da implementação padrão.
        assert_eq!(
            contract.get_another_integer(),
            -1,
        );

    }

    #[test]
    pub fn get_an_integer(){
        env_setup();
    
        let contract: Contract = Contract::default();
    
        // Este valor é da implementação padrão.
        assert_eq!(
            contract.get_an_integer(),
            1,
        );
    }

    #[test]
    pub fn set_a_string() {
        env_setup();

        let mut contract: Contract = Contract::default();

        contract.set_a_string(String::from("A new string"));

        assert_eq!(
            contract.get_a_string(),
            String::from("A new string"),
        );
    }

    #[test]
    pub fn set_a_floating() {
        env_setup();

        let mut contract: Contract = Contract::default();

        contract.set_a_floating(-10.5432);
        
        assert_eq!(
            contract.get_a_floating(),
            -10.5432,
        );
    }

    #[test]
    pub fn set_an_integer() {
        env_setup();

        let mut contract: Contract = Contract::default();

        contract.set_an_integer(5);

        assert_eq!(
            contract.get_an_integer(),
            5,
        );
    }

    #[test]
    pub fn set_another_integer() {
        env_setup();

        let mut contract: Contract = Contract::default();

        contract.set_another_integer(7);

        assert_eq!(
            contract.get_another_integer(),
            7
        );
    }

    #[test]
    pub fn just_a_function(){
        env_setup();

        // Declaramos isso no início do contrato, mas não precisamos de usa-lo aqui
        // Começar a variável com _ se não tiver intenção de usá-la
        let _contract: Contract = Contract::default();

        // Note o :: devido a função não precisar de um state.
        Contract::just_a_function();
    }

    #[test]
    // take_ownership é só um exemplo de uma gambiarra em rust. Não ha muito uso aqui.
    pub fn take_ownership(){
        env_setup();

        let contract: Contract = Contract::default();

        let an_integer = contract.get_an_integer();

        assert_eq!(
            contract.take_ownership(),
            an_integer,
        );
    }

}

'''
'''--- ES/lesson_4_modules/Cargo.toml ---
[package]
name = "lesson_4_modules"
version = "0.1.0"
authors = ["Lucas Lemos <stiltztinkerstein@gmail.com>"]
license = "MIT"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- ES/lesson_4_modules/Readme.md ---
# Lição 4 - Módulos

[voltar](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/ES/)

Esta lição discute sobre como módulos são importados. 

Podemos ter todo nosso código implementado no arquivo ```lib.rs```. Mas percebe-se como seria dificil de organizar um projeto grande dessa forma. 

 - Podemos declarar módulos externos; 
 - Declarar diretórios externos como módulos;
 - Controlar quais módulos são públicos;
 - Controlar o caminho para cada módulo público;
 - Também podemos organizar nossos testes no diretório ```./tests/```.

---

## API de Contrato

```rust
/// Retorna a String armazenada.
pub fn get_phrase(&self) -> String;

/// A função irá imprimir "Hello from crate::a_module" e 
/// atribuir essa string ao valor armazenado.
pub fn hello(&mut self);

/// A função irá imprimir "Hello from 
/// crate::a_module::specific_module" e atribuir essa string ao 
/// valor armazenado.
pub fn hello1(&mut self);

/// A função irá imprimir "Hello from another module" e 
/// atribuir essa string ao valor armazenado.
pub fn hello2(&mut self);

/// A função irá imprimir "Hello from yet_another_module" 
/// e atribuir essa string ao valor armazenado.
pub fn hello3(&mut self);

/// A função irá imprimir "Called a deep function" e 
/// atribuir essa string ao valor armazenado.
pub fn hello4(&mut self);

/// Esta função irá entrar em pânico com a mensagem "A panic 
/// just happened" quando chamado.
pub fn this_will_panic();
```

---

## Tópicos
 - [Como declarar um módulo externo](#como-declarar-um-m%C3%B3dulo-externo)
 - [Como declarar e usar diretórios](#como-declarar-e-usar-diret%C3%B3rios)
 - [Usando/importando módulos](#usandoimportando-m%C3%B3dulos)
   - [Apelidos](#apelidos)
   - [Usos públicos](#usos-p%C3%BAblicos)
 - [Testes de integração](#testes-de-integra%C3%A7%C3%A3o)
   - [Testes de integração NEAR](#testes-de-integra%C3%A7%C3%A3o-near)
   - [Testes de integração Rust](#testes-de-integra%C3%A7%C3%A3o-rust)
  - [Desativar avisos de compilador](#desativar-avisos-de-compilador)
  - [Testando Falhas](#testando-falhas)

---

## Como declarar um módulo externo

[topo](#li%C3%A7%C3%A3o-4---m%C3%B3dulos)

Um módulo externo deve ser declarado antes de usado/importado.

```rust
mod yet_another_module;
```

Essa linha diz ao compilador que existe um módulo com este nome no mesmo diretório. Existem três formas de se declarar um módulo. Se dois módulos ou mais com mesmo nome forem encontrados, um erro de ambiguidade será gerado.

O módulo acima é privado. Só pode ser usado onde foi declarado. O módulo abaixo é público:

```rust
pub mod a_module;
```

```a_module``` é público aqui. Ou seja, pode ser importado por outros. Isso inclui crates externas. O exemplo abaixo restringe isso.

```rust
pub(crate) fn hello() -> String{
    String::from("Hello from crate::a_module::specific_module")
}
```

```pub(crate)``` significa que esta função é pública apenas nessa crate. Ou seja, se ```lesson_4_modules``` for dependência de um outro projeto rust, o crate externo não terá acesso a essa função.

---

## Como declarar e usar diretórios

[topo](#li%C3%A7%C3%A3o-4---m%C3%B3dulos)

Podemos declarar diretórios como módulos também. Existem duas formas para isso. A primeira é:
 - Criar um diretório com o nome do seu módulo.
 - Criar um arquivo com nome ```mod.rs``` dentro desse diretório. Este arquivo possui a implementação do módulo.

![Imagem de um diretório com um arquivo mod.rs](../static/images/mod-diretorios.png)

```a_module``` é uma implementação de módulo. 

A segunda forma é:

 - Criar um diretório com o nome do seu módulo.
 - Criar um arquivo rust com o mesmo nome do seu módulo junto com o diretório. Este arquivo possui a implementação do módulo.

![Imagem de um diretório com um arquivo de mesmo nome ao lado](../static/images/mod-diretorios2.png)

```internal_module``` é outra implementação de módulo.

O arquivo rust fica dentro ou fora do diretório? Essa é a questão.

---

## Usando/Importando módulos

[topo](#li%C3%A7%C3%A3o-4---m%C3%B3dulos)

Qualquer item (módulos, funções, structs, traits, enums, et cetera) pode ser importado com a instrução use.

No exemplo abaixo, acessamos o caminho ```near_sdk``` (uma crate neste caso), e incluimos ```env``` e ```near_bindgen``` no nosso namespace.

```rust
use near_sdk::{env, near_bindgen};
```

Não é necessário usar a instrução use. Porém, se quiséssemos acessar o módulo ```env```, teriamos que escrever ```near_sdk::env``` todas as vezes.

---

### Apelidos

[topo](#li%C3%A7%C3%A3o-4---m%C3%B3dulos)

Podemos dar um apelido ao item importado:

```rust
use a_module::specific_module::hello as hello1;
```

Existem várias funções ```hello``` neste exemplo. Então alteramos o nome de cada uma com o operador ```as```. Ou seja, importando dessa forma, a instrução ```hello1()``` é o mesmo que ```a_module::specific_module::hello()```.

---

### Usos públicos

[topo](#li%C3%A7%C3%A3o-4---m%C3%B3dulos)

As instruções

```rust
pub use another_module::hello as hello2;
pub use yet_another_module::hello as hello3;
```

Trazem as duas funções hello para este namespace, alteram o nome para ```hello2``` e ```hello3```, e as tornam públicas, como se tivessem sido declaradas neste módulo. Isso é uma boa forma de organizar nosso projeto. Por exemplo, no arquivo ```yet_another_module```:

```rust
mod internal_module;

pub use internal_module::a_deep_module::a_deep_function;
```

Declaramos que o módulo ```internal_module``` existe, e é privado. Mas a função ```a_deep_function``` é pública. Um usuário pode acessar esse item pelo caminho ```yet_another_module::a_deep_function```. Sem saber que a função está em um diretório completamente diferente.

Organize módulos e diretórios de acordo com as necessidades do seu projeto. Use ```pub use``` para organizar os itens disponíveis de acordo com as necessidades dos usuários externos.

**Detalhe**: ```pub use``` e ```pub mod``` são usados para módulos públicos e crates feitos para serem importados (library) por outros projetos rust. Não possui nenhuma interação no contexto de contratos NEAR.

---

## Testes de Integração

[topo](#li%C3%A7%C3%A3o-4---m%C3%B3dulos)

A linguagem rust tem um formato para testes de integração, e o formato NEAR possui outro.

Isso porque testes de integração em NEAR consistem na interação entre diversos contratos em uma simulação de estrutura blockchain.

---

### Testes de Integração NEAR

[topo](#li%C3%A7%C3%A3o-4---m%C3%B3dulos)

Para isso usamos uma ferramenta chamada [workspaces-rs](https://github.com/near/workspaces-rs)

Agora, como se ja não estivesse confuso o suficiente, workspaces em rust e workspaces-rs são duas coisas diferentes. [Workspaces](https://doc.rust-lang.org/cargo/reference/workspaces.html) em rust são uma forma de organizar várias crates em um único pacote, todas compartilhando um diretório ```./target/``` e um arquivo ```Cargo.lock```. [workspaces-rs](https://github.com/near/workspaces-rs) é uma forma de realizar testes de integração de contratos NEAR utilizando a linguagem rust.

Testes de integração eram feitos com a crate [near-sdk-sim](https://www.near-sdk.io/testing/simulation-tests), mas esta ferramenta será deprecada pela [sandbox](https://docs.near.org/docs/develop/contracts/sandbox). Use a ferramenta que lhe servir melhor.

---

### Testes de integração Rust

[topo](#li%C3%A7%C3%A3o-4---m%C3%B3dulos)

Geralmente declaramos testes no mesmo arquivo. da seguinte forma:

```rust
#[cfg(test)]
mod tests{
    // carrega tudo que está neste arquivo, fora deste módulo.
    use super::*;

    #[test]
    fn hello_test(){
```

Mas as vezes, precisamos declarar testes em sua própria estrutura de arquivos e diretórios.

Podemos criar um diretório ```tests``` junto com o ```src```.

![Imagem do diretório root com destaque no diretório "tests"](../static/images/testsdirectory.png)

Quando executarmos o comando ```cargo test```, cada arquivo ```.rs``` será tratado como um módulo de teste. Todas as funções marcadas com ```#[test]``` serão executadas automaticamente.

Os arquivos ```.rs``` não precisam ser declarados com a instrução ```mod``` para serem compilados.

O diretório ```tests``` age como uma crate separada. Podemos importar módulos no mesmo diretório:

```rust
mod common;

use common::env_setup;
```

Para importarmos módulos na crate principal, referimos à essa pelo nome da crate:

```rust
use lesson_4_modules::Contract;
```

---

## Desativar avisos de compilador

[topo](#li%C3%A7%C3%A3o-4---m%C3%B3dulos)

Avisos ("warnings") são gerados durante a compilação. Podemos desativar avisos da seguinte forma:

```rust
#[allow(unused)]
```

O exemplo acima permite uma falha de código "não utilizado" na linha abaixo.

O recomendado é corrigir avisos do compilador. Mas existem situações em que talvez isso seja útil. Por exemplo, a convenção para funções javascript é ```CamelCase```, mas a convenção para funções em rust é ```snake_case```. Quando comunicarmos com o nosso contrato através do near-api-js, talvez seja melhor ter as funções na convenção javascript.

```rust
#[allow(non_snake_case)]
pub fn ACamelCaseFunction() {    
```

Podemos permitir avisos de imports não utilizados:

```rust
#[allow(unused_imports)]
use near_sdk::{env, near_bindgen};
```

Repetindo, avisos existem para nos ajudar. O recomendado é **corrigir** os avisos, não escondê-los.

---

## Testando falhas

[topo](#li%C3%A7%C3%A3o-4---m%C3%B3dulos)

Criamos testes para garantir que erros aconteçam quando erros devem acontecer também.

```rust
    #[test]
    #[should_panic(expected = "A panic has just happened")]
    fn this_will_panic_test() {
        this_will_panic();
    }
```

O teste acima irá causar pânico, mas esperamos pânico. Então o teste será um sucesso.

Se a operação não causar pânico, ou causar pânico com uma mensagem diferente do esperado ("expected"). O teste irá falhar.

A [próxima lição](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/ES/lesson_5_macro_usage) será sobre uso de macros.

'''
'''--- ES/lesson_4_modules/src/a_module/mod.rs ---
//! Entre usar mod.rs ou um arquivo rust com mesmo nome. 
//! É apenas uma questão de manter o arquivo rust no diretorio pai ou filho.
//! 
//! 

pub mod specific_module;

pub fn hello() -> String {
    String::from("Hello from crate::a_module")
}

'''
'''--- ES/lesson_4_modules/src/a_module/specific_module.rs ---
// Ter (crate) após pub torna a função (ou módulo, trait, ...) disponivel 
// para módulos locais, mas não para crates externos.
pub(crate) fn hello() -> String{
    String::from("Hello from crate::a_module::specific_module")
}

/// panic é quando algo de errado acontece e tudo deve parar imediatamente.
/// Podemos causar panic sob demanda.
pub fn this_will_panic() {
    panic!("A panic has just happened");
}

// cfg(test) diz ao compilador que isto apenas existe em ambientes de teste.
#[cfg(test)]
mod tests{
    // carrega tudo que está neste arquivo, fora deste módulo.
    use super::*;

    #[test]
    fn hello_test(){
        // Hello é público apenas para módulos desta crate.
        // Tentaremos importá-lo no diretório de tests, o que causará um erro.
        // Pois o diretório de testes atua como a própria crate.
        assert_eq!(
            hello(),
            "Hello from crate::a_module::specific_module",
        );
    }

    #[test]
    // Podemos testar em situações que causam panic.
    // expected garante que entraremos em pânico pelo motivo correto.
    #[should_panic(expected = "A panic has just happened")]
    fn this_will_panic_test() {
        this_will_panic();
    }
}
'''
'''--- ES/lesson_4_modules/src/another_module.rs ---
pub fn hello() -> String {
    String::from("Hello from another_module")
}

// A função abaixo é privada.
// #[allow(unused)] é uma forma de dizer ao compilador/linter para ignorar o aviso. Mesmo em um situação como essa, em que é uma má ideia. Pois esta função é inutil.
// Comente o #[allow(unused)] para ver o aviso
#[allow(unused)]
fn this_is_private() -> String {
    // Tradução: Esta função nunca será usada pois é privada.
    String::from("This will never be used because it's private")
}

'''
'''--- ES/lesson_4_modules/src/lib.rs ---
//! Este exemplo foca na administração de módulos.
//! 
//! 
//!
//! A ordem para importação de crates e modulos é, normalmente:
//! 
//!  - padrão (std), 
//!  - outras crates (como near-sdk), 
//!  - crates nesta workspace, 
//!  - e módulos locais.
//!
//! 
//! "mod file" diz ao compilador que o arquivo nesse diretório local deve ser compilado também.
//! Para usarmos o módulo utilizamos "use".
//! 
//! "pub mod" quer dizer que outros módulos podem usar dito módulo, senão é privado.
//! "pub use" pode ser usado para o mesmo propósito.
//! A diferença sendo que arquivos podem ser organizados de certa forma, e módulos de library em outra, mais conveniente.
//! 

// Esta linha está dizendo que existe um arquivo ou diretório com nome "a_module" e deve ser compilado.
// "mod.rs" é uma forma necessária de um diretório ser reconhecido como módulo.
pub mod a_module;
// Esta linha esta dizendo que o arquivo "another_module.rs" é parte deste projeto e deve ser compilado.
mod another_module;

// Esta linha é outra forma de declarar módulos, não precisa de "mod.rs", mas acho mais desorganizado.
mod yet_another_module;

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
#[allow(unused_imports)]
use near_sdk::{env, near_bindgen};

// Podemos usar "as" para dar apelidos a funções ou módulos importados.
use a_module::hello as hello;
use a_module::specific_module::hello as hello1;

// pub use torna a função disponível para crates externos.
pub use another_module::hello as hello2;
pub use yet_another_module::hello as hello3;

// A localização atual de "a_deep_function"  é "yet_another_module::internal_module::a_deep_module::a_deep_function."
// Mas este endereço é privado, e "yet_another_modulo" chamou "pub use" para a função. Em outras palavras, mais limpo.
use yet_another_module::a_deep_function as hello4;

// Descomente a linha adiante para receber um aviso de erro "isto é privado".
// use another_module::this_is_private;

pub use a_module::specific_module::this_will_panic;

near_sdk::setup_alloc!();

// Esta função irá fazer nosso código menos bagunçado.
pub fn log(message: &str) {
    env::log(message.as_bytes());
}

#[near_bindgen]
#[derive(Clone, Default, BorshDeserialize, BorshSerialize)]
pub struct Contract {
    stored_phrase: String,
}

#[near_bindgen]
impl Contract{
    /// Retorna a String armazenada.
    pub fn get_phrase(&self) -> String {
        self.stored_phrase.clone()
    }

    /// A função irá imprimir "Hello from crate::a_module" e 
    /// atribuir essa string ao valor armazenado.
    pub fn hello(&mut self) {        
        self.stored_phrase = hello();
        log(&hello());
    }

    /// A função irá imprimir "Hello from 
    /// crate::a_module::specific_module" e atribuir essa string ao 
    /// valor armazenado.
    pub fn hello1(&mut self) {
        self.stored_phrase = hello1();
        log(&hello1());
    }

    /// A função irá imprimir "Hello from another module" e 
    /// atribuir essa string ao valor armazenado.
    pub fn hello2(&mut self) {
        self.stored_phrase = hello2();
        log(&hello2());
    }

    /// A função irá imprimir "Hello from yet_another_module" 
    /// e atribuir essa string ao valor armazenado.
    pub fn hello3(&mut self) {
        self.stored_phrase = hello3();
        log(&hello3());
    }

    /// A função irá imprimir "Called a deep function" e 
    /// atribuir essa string ao valor armazenado.
    pub fn hello4(&mut self) {
        self.stored_phrase = hello4();
        log(&hello4());
    }

    /// Esta função irá entrar em pânico com a mensagem "A panic 
    /// just happened" quando chamado.
    pub fn this_will_panic() {    
        this_will_panic();
    }
}

// Testes estão no diretório tests. Muito útil para projetos grandes.

'''
'''--- ES/lesson_4_modules/src/yet_another_module.rs ---
// internal_module é privado para módulos externos.
mod internal_module;

// Mas fizemos a_deep_function publico para outros na declaração aqui.
// Bom para organizar código.
pub use internal_module::a_deep_module::a_deep_function;

pub fn hello() -> String {
    String::from("Hello from yet_another_module")
}

'''
'''--- ES/lesson_4_modules/src/yet_another_module/internal_module.rs ---
pub mod a_deep_module;

'''
'''--- ES/lesson_4_modules/src/yet_another_module/internal_module/a_deep_module.rs ---
/// Uma função profunda.
pub fn a_deep_function() -> String {
    String::from("Called a deep function")
}

'''
'''--- ES/lesson_4_modules/tests/another.rs ---
//! Cada arquivo rusts no diretório tests é testado individualmente.
//! Não há necessidade de incluí-los usando mod.

// Descomente a linha abaixo e verá um aviso de erro "privado".
// Isso é porque é público apenas dentro da crate. E "tests" age como a própria crate.
// use lesson_4_modules::a_module::specific_module::hello;

#[test]
fn oneplusone() {
    assert_eq!(1 + 1, 2);
}

'''
'''--- ES/lesson_4_modules/tests/common/mod.rs ---
use near_sdk::{
    AccountId,
    env,
    MockedBlockchain,
    testing_env,
    test_utils::VMContextBuilder,
    json_types::ValidAccountId,
};

pub fn env_setup(){
    let mut builder: VMContextBuilder = VMContextBuilder::new();

    // attributes we can set with the builder:
    // current_account_id
    // signer_account_id
    // signer_account_pk
    // precessor_account_id
    // block_index
    // block_timestamp
    // epoch_height
    // account_balance
    // account_locked_balance
    // storage_usage
    // attached_deposit
    // prepaid_gas
    // random_seed
    // is_view

    let account_id: AccountId = String::from("stiltztinkerstein");

    builder.current_account_id(
        ValidAccountId::try_from(
            account_id.clone()
        ).unwrap()
    );

    testing_env!(builder.build());

    assert_eq!(
        env::current_account_id(),
        account_id, 
        "Assert Error. env: {} account: {}", 
        env::current_account_id(), 
        &account_id,
    );
}

'''
'''--- ES/lesson_4_modules/tests/contract.rs ---
//! Este módulo irá testar a funcionalidade do contrato.

// common será um módulo com funções úteis para todos outros testes.
mod common;

// Diretório tests age como a própria crate.
// So when we import our own modules, 
// Então quando importamos nossos próprios módulos,
// referimos a estes como "lesson_4_modules::" em vez de "crates::"
use lesson_4_modules::Contract;

use common::env_setup;

#[test]
pub fn get_phrase() {
    env_setup();

    let contract: Contract = Contract::default();

    // Usamos derive(Default) para Contract.
    // o padrão derivado para String é uma string vazia.
    assert_eq!(contract.get_phrase(), "");
}

/// Esta função irá atribuir "Hello from crate::a_module".
#[test]
pub fn hello() {
    env_setup();

    let mut contract: Contract = Contract::default();

    contract.hello();

    assert_eq!(
        contract.get_phrase(),
        "Hello from crate::a_module",
    );
}

/// Esta função irá atribuir "Hello from crate::a_module::specific_module".
#[test]
pub fn hello1() {
    env_setup();

    let mut contract: Contract = Contract::default();

    contract.hello1();

    assert_eq!(
        contract.get_phrase(),
        "Hello from crate::a_module::specific_module",
    );
}

/// Esta função irá atribuir "Hello from another_module".
#[test]
pub fn hello2() {
    env_setup();

    let mut contract: Contract = Contract::default();

    contract.hello2();

    assert_eq!(
        contract.get_phrase(),
        "Hello from another_module",
    );
}

/// Esta função irá atribuir "Hello from yet_another_module".
#[test]
pub fn hello3() {
    env_setup();

    let mut contract: Contract = Contract::default();

    contract.hello3();

    assert_eq!(
        contract.get_phrase(),
        "Hello from yet_another_module",
    );
}

/// Esta função irá atribuir "Called a deep function".
#[test]
pub fn hello4() {
    env_setup();

    let mut contract: Contract = Contract::default();

    contract.hello4();

    assert_eq!(
        contract.get_phrase(),
        "Called a deep function",
    );
}

/// Esta função entrará em panico com a messagem "A panic has just happened" quando chamado.
// Podemos testar situações que causam pânico.
// expected garante que estamos entrando em pânico pelo motivo certo.
#[test]
#[should_panic(expected = "A panic has just happened")]
pub fn this_will_panic() {
    env_setup();

    // Embora não utilizemos o state, é bom inicializar antes de cada teste.
    let _contract: Contract = Contract::default();

    Contract::this_will_panic();
}

'''
'''--- ES/lesson_5_macro_usage/Cargo.toml ---
[package]
name = "lesson_5_macro_usage"
version = "0.1.0"
authors = ["Lucas Lemos <stiltztinkerstein@gmail.com>"]
license = "MIT"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- ES/lesson_5_macro_usage/Readme.md ---
# Lição 5 - Uso de Macros

[voltar](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/ES/)

Macros são a ferramenta principal para a utilização efetiva da linguagem rust. Não é necessário saber como criar macros. Mas é essencial entender o que são e como usá-los.

---

## API de Contrato

```rust
/// Esta função mostra as diferenças entre println e env::log
/// Execute com ```cargo test -- --nocapture```, compile, implante e execute em Near.
/// Note como algumas mensagens aparecem e outras não.
pub fn print_examples();

/// Exemplos de format. Compare o output com a implementação.
pub fn format_examples();

/// Exemplo de panico.
pub fn panic_example();

/// Exemplo de usos de vec.
pub fn vec_examples();
```

## Tópicos

 - [O que são macros](#o-que-são-macros)
 - [Macros "function-like"](#macros-"function-like")
 - [Vantagens](#vantagens)
 - [Desvantagens](#desvantagens)
 - [Exemplos](#exemplos)
   - [format, println e panic](#format-println-e-panic)
   - [vec](#vec)
   - [setup_alloc](#setup_alloc)
 - [Extra: String e str](#extra-string-e-str) 

---

## O que são macros

[topo](#lição-5---uso-de-macros)

Macros são ferramentas que geram código. Macros são executados em tempo de compilação. 

As instruções derive são um macro:

```rust
#[derive(Clone, Default, BorshDeserialize, BorshSerialize)]
pub struct Contract {
```

Instruções derive servem para aplicar traits a novos tipos. A instrução a seguir é outro tipo de macro chamado "atributo":

```rust
#[near_bindgen]
impl Contract{
```

Mas discutiremos macros "function-like" (semelhantes a funções). Como o nome descreve, são usados com a mesma lógica do chamado de funções. Alguns exemplos:

```rust
// Imprime o string formatado ao output padrão
println!("{}", message);

// Formata os argumentos em um String
format!("7");

// Formata uma String e entra em pânico com a mensagem formatada
// "Entrar em pânico" Encerra o runtime retornando uma mensagem de erro.
panic!("Panico com alguns argumentos: {} {} {}", 1, second, 3);

// Recebe uma lista de argumentos e retorna um Vec com os valores alocados.
vec![1, 2, 3, 4];

// Gera código de fôrma (boilerplate) necessário para o funcionamento do contrato
near_sdk::setup_alloc!();

// Usado em testes.
// Usa o argumento Context para gerar o contexto de ambiente da máquina virtual.
testing_env!(builder.build());

``` 

---

## Macros "function-like"

[topo](#lição-5---uso-de-macros)

Esses macros são usados como funções, mas existem algumas diferenças.

Podem ter um número variado de parâmetros. Rust é uma linguagem "statically typed", ou seja, o compilador precisa saber exatamente onde memória é criada e onde é liberada. Porém, macros podem retornar código. Ou seja, um macro como ```println``` ou ```format``` recebem os argumentos e montam um bloco de código antes do compilador checar por erros.

Outra diferença que pode ser vista com o exemplo de ```vec```:

```rust
vec![1, 2, 3, 4];
```

Esta implementação vec é demarcada com ``` [ ] ``` em vez de ``` ( ) ```, macros também podem ser demarcados com ``` { } ```. Macros podem ter literalmente qualquer tipo de texto dentro dos demarcadores. Um desenvolvedor pode escrever qualquer coisa como argumento macro, contanto que a implementação entenda os parâmetros.

---

## Vantagens

[topo](#lição-5---uso-de-macros)

 - Simplifica o código.
 - É executado durante compilação. Se bem implementado, macros podem ser eficientes com pouco ou nenhum overhead.

---

## Desvantagens

[topo](#lição-5---uso-de-macros)

 - Um desenvolvedor precisa pesquisar a documentação de cada novo macro que encontram.
 - Podem ser mais dificeis de "debugar".
 - Aumentam o tempo de compilação.
 - Podem "inflar" o código com implementação "invisivel".

---

## Exemplos

A seguir recomendamos alguns macros "function-like" úteis.

---

### format, println e panic

[topo](#lição-5---uso-de-macros)

Os macros ```panic```, ```println``` e ```format``` são escritos da mesma forma.

 - ```format``` retorna um String.
 - ```println``` imprime o String no output padrão.
 - ```panic``` encerra a execução e retorna o String como mensagem de erro.

```rust
println!("Isso é um println!, não aparece na máquina virtual");

// Criamos uma variavel "message" e associamos uma String de valor "format retorna uma String formatada".
let message: String = format!("format retorna uma string formatada.");

// Encerra execução com a mensagem de erro "Panico com alguns argumentos: 1 2 3"
let second = 2;
panic!("Panico com alguns argumentos: {} {} {}", 1, second, 3);

```

A utilização destes macros é bem simples. Um str como primeiro argumento ([detalhes](#extra-string-e-str)). Cada "{}" é substituido pelos argumentos após o primeiro.

Podemos customizar a formatação de diversas formas. Mais informações, cheque o [link de documentação sobre formatação](https://doc.rust-lang.org/std/fmt/index.html). Abaixo incluimos algumas úteis utilizações:

```rust
// Exemplos de format
log("\n\nformat_examples:\n");
 
let message: String = format!("Format retorna uma String formatada");

let an_arg = "third";

// format pode receber argumentos usando {} 1 second third
let message = format!("format pode receber argumentos usando {{}}: {}, {}, {}.", 1, "second", an_arg);

let (first, second, third) = (1, "second", an_arg);

// Podemos especificar argumentos dessa forma: 1 second third
let message = format!("Podemos especificar argumentos dessa forma: {first}, {second}, {third}.");

// Podemos especificar a ordem de argumentos de format: 1 second third
let message = format!("Podemos especificar a ordem de argumentos de format: {1}, {2}, {0}.", third, first, second);

let (first, second, third) = (1, 2, 3);
// Podemos fazer inteiros mostrarem um número arbitrário de digitos: 01 0002      3
let message = format!("Podemos fazer inteiros mostrarem um número arbitrário de digitos: {:02}, {:04}, {:6}.", first, second, third);

// Escolhendo número de digitos e ordem: 01    2 000003
let message = format!("Escolhendo número de digitos e ordem: {2:02}, {0:4}, {1:06}.", second, third, first);

let (first, second, third) = (0.1, 1.23, -2.45);
// Podemos escolhar a precisão de números racionais: 0.10 1.230 -2.450000
let message = format!("Podemos escolhar a precisão de números racionais: {:.2}, {:.4}, {:.6}", first, second, third);

// Podemos escolher a precisão e número de digitos: 0.10 0001.2300 -00002.450000
let message = format!("Podemos escolher a precisão e número de digitos: {:2.2}, {:04.4}, {:06.6}", first, second, third);

// Podemos escolher a precisão, o número de digitos e a ordem dos argumentos: 00.10    1.2300 -00002.450000
let message = format!("Podemos escolher a precisão, o número de digitos e a ordem dos argumentos: {1:02.2}, {2:4.4}, {0:06.6}", third, first, second);

// Mesmo que o acima:  0.10 0001.2300      -2.450000
let message = format!("Mesmo que o acima: {first:2.2}, {second:04.4}, {third:6.6}");

```

---

### vec

[topo](#lição-5---uso-de-macros)

Uma rápida discussão sobre algumas formas de agrupar valores. 

Tuplas possuem tamanho imutavel:

```rust
// Uma tupla com inteiros
let tupla: (u32, u32, u32) = (0, 1, 4);

// Acessando um valor
// O segundo valor é 1
println!("O segundo valor é {}", tupla.1);
```

Arrays possuem tamanho imutável, são armazenados na pilha (stack).

```rust
// Uma forma de declarar um array
let lista = [0, 1, 2];

// Acessando um valor
// O terceiro valor é 2
println!("O terceiro valor é {}", lista[2]);

// um array com 10 inteiros inicializados com 0.
// Esse método só permite inicializar com valores iguais, não tente inicializar com uma função.
let mut lista: [i32; 10] = [0; 10];

// Alterando um valor
lista[0] = -1;

// Acessando um valor
// O primeiro valor é -1
println!("O primeiro valor é {}", lista[0]);
```

Arrays e tuplas são primitivos. Não podemos alterar o número de elementos desses grupos. Para armazenar conjuntos de valores de forma mais prática usamos coleções. Temos coleções rust, que são mais generalizadas, e coleções Near, que são armazenadas na "trie". O entendimento de coleções rust é importante para uma boa lógica de funções. O entendimento de coleções Near é importante para armazenamento eficiente de estado.

 - [Detalhes](https://doc.rust-lang.org/std/collections/) sobre coleções Rust para bom funcionamento de métodos.
 - [Detalhes](https://docs.rs/near-sdk/latest/near_sdk/collections/index.html) sobre coleções Near para bom armazenamento de estado.

A coleção rust mais utilizada é ```Vec```([detalhes](https://doc.rust-lang.org/std/vec/struct.Vec.html)). Com este tipo, podemos armazenar dados, observar a quantidade de elementos, acessar e alterar os elementos. O que é uma boa solução para a maior parte dos casos.

**Detalhe:** ```vec``` (letra minuscula) é o macro para criação de vetores ```Vec```. ```Vec``` (letra maiuscula) refere-se ao tipo do vetor.

Podemos criar um ```Vec``` da seguinte forma:

```rust
// Vec com os números 1 2 3 4
let example = vec![1, 2, 3, 4];
```

Podemos criar um ```Vec``` com vários valores iguais:

```rust
// Vec com os números 0 0 0 0 0
let example = vec![0;5];
```

Imprimir valores de conjuntos pode demandar muito tempo de processamento. Devido a isso, para usar um conjunto de elementos em um ```println```, ```format``` ou ```panic```, precisamos explicitar que é impresso em modo debug.

```rust
let example = vec![1, 2, 3, 4];

log(&format!("Podemos imprimir vetores com modo debug:\n{:?}\n\n", example));

log(&format!("Podemos imprimir vetores em \"formato legivel\":\n{:#?}\n\n", example));

log(&format!("Podemos fazer o mesmo com tuplas:\n{:#?}\n\n", (1, 2, 3)));

log(&format!("Podemos criar vetores com valores padrão:\n{:?}\n\n", vec![0;5]));
```

Formatação ```{:?}``` é "formatação debug".

Formatação ```{:#?}``` é "formatação pretty print". É o mesmo que o acima, porém escrito de uma forma mais legivel para um usuário. Normalmente simplesmente significa um elemento por linha.

Para implementar formatação debug em um struct ou enum, cheque o [link sobre formatação](https://doc.rust-lang.org/std/fmt/trait.Debug.html).

---

### setup_alloc

[topo](#lição-5---uso-de-macros)

Deve ser usado antes da declaração do contrato. Gera código que deveria ser escrito repetidas vezes em cada contrato.

```rust
near_sdk::setup_alloc!();
```

É necessário na versão de near_sdk atual (```3.1.0```). Nas versões seguintes, será deprecado.

---

## Extra: String e str

[topo](#lição-5---uso-de-macros)

```String``` e ```str``` são dois tipos diferentes. String é um tipo que mantem ownership de uma string. ```str``` é um tipo usado para referências a strings. Estes tipos existem para minimizar cópias de strings durante o runtime.

Lembrar: 
 - ```str``` é sempre usado como ```&str```. ```&str``` aplica para "strings como essa" e ```&String```;
 - Sempre que for precisar de uma referência para uma ```String``` em uma função, use ```&str```. Não use ```&String```.
 - "Strings como essa" são do tipo ```&'static str```. Mais detalhes na seção sobre lifetimes. Teoricamente, são strings que nunca são removidas da memória, mas isso depende da otimização do compilador.

A [proxima lição](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/ES/lesson_6_enums) será sobre enums.

'''
'''--- ES/lesson_5_macro_usage/src/lib.rs ---
//! Exemplos para os seguintes macros:
//! - format!
//! - println!
//! - panic!
//! - vec!
//! - setup_alloc!
//! 
//! 
//! 

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
#[allow(unused_imports)]
use near_sdk::{env, near_bindgen};

near_sdk::setup_alloc!();

/// Esta função é usada em ```print_examples```.
/// É compilada em ambientes de teste.
#[cfg(test)]
pub fn log(message: &str) {
    println!("{}", message);
}

/// Esta função é usada em ```print_examples```.
/// É compilada fora de ambientes de teste.
#[cfg(not(test))]
pub fn log(message: &str) {
    env::log(message.as_bytes());
}

#[near_bindgen]
#[derive(Clone, Default, BorshDeserialize, BorshSerialize)]
pub struct Contract {
    // Este contrato não possui estado
}

#[near_bindgen]
impl Contract{

    /// Esta função mostra as diferenças entre println e env::log
    /// Execute com ```cargo test -- --nocapture```, compile, implante e execute em Near.
    /// Note como algumas mensagens aparecem e outras não.
    pub fn print_examples() {
        log("\n\nprint_examples:\n");
        println!("Isto é um println! Não aparece na máquina virtual");
        let a = String::from("algo");
        println!("Isso é outro println com diversos argumentos, {}, {}, {}", 1, "thingy", a);

        env::log(b"Isso e um log. Nao aparece em testes.");
        env::log("Isso é outro log".as_bytes());

        env::log(
            format!("Isso é outro log com diversos argumentos: {}, {}, {}", 1, 2, "3")
            .as_bytes()
        );

        log("Isso é uma mensagem que aparecem em testes e na máquina virtual.");

        log(
            &format!("Isso é outra mensagem com argumentos, {}, {}, {}.",
                5,
                "6",
                format!("7"),
            )
        );
        
        log("\n\n---------------------------------------------------------------------------------\n\n");
    }

    /// Exemplos de format. Compare o output com a implementação.
    pub fn format_examples() {
        log("\n\nformat_examples:\n");
        let message: String = format!("format retorna um String formatado");
        log(&message);

        let an_arg ="terceiro";
        let message = format!("format pode receber argumentos usando {{}}: {}, {}, {}.", 1, "second", an_arg);
    
        log(&message);

        let (first, second, third) = (1, "segundo", an_arg);
        let message = format!("Podemos especificar argumentos format da seguinte forma: {first}, {second}, {third}.");

        log(&message);

        let message = format!("Podemos especificar a ordem dos argumentos format: {1}, {2}, {0}.", third, first, second);

        log(&message);

        let (first, second, third) = (1, 2, 3);
        let message = format!("Podemos fazer inteiros mostrarem um número arbitrário de digitos: {:02}, {:04}, {:6}.", first, second, third);
        log(&message);

        let message = format!("Escolhendo um número de digitos e ordem: {2:02}, {0:4}, {1:06}.", second, third, first);
        log(&message);

        let (first, second, third) = (0.1, 1.23, -2.45);
        let message = format!("Podemos escolher a precisão de números racionais: {:.2}, {:.4}, {:.6}", first, second, third);
        log(&message);

        let message = format!("Podemos escolher a precisão e o número de digitos: {:2.2}, {:04.4}, {:06.6}", first, second, third);
        log(&message);

        let message = format!("Podemos escolher a precisão, o número de digitos e a ordem dos argumentos: {1:02.2}, {2:4.4}, {0:06.6}", third, first, second);
        log(&message);

        let message = format!("Mesmo que acima: {first:2.2}, {second:04.4}, {third:6.6}");

        log(&message);

        log("\n\n----------------------------------------------------------------------\n\n");
    }

    /// Exemplo de panico.
    pub fn panic_example() {
        log("\n\npanic_example:\n\n\n");

        log("Macros de pânico são escritos da mesma forma que println e format.");

        let second = 2;
        panic!("Pânico com alguns argumentos: {} {} {}", 1, second, 3);

    }

    /// Exemplo de usos de vec.
    pub fn vec_examples() {
        log("\n\nvec_examples:\n");

        let example = vec![1, 2, 3, 4];

        log(&format!("Podemos imprimir vetores com modo debug:\n{:?}\n\n", example));
        
        log(&format!("Podemos imprimir vetores em \"formato legivel\":\n{:#?}\n\n", example));

        log(&format!("Podemos fazer o mesmo com tuplas:\n{:#?}\n\n", (1, 2, 3)));

        log(&format!("Podemos criar vetores com valores padrão:\n{:?}\n\n", vec![0;5]));

        log("Mais informações na lição de coleções (\"collections\").");

        log("\n\n-------------------------------------------------------------------------------\n\n");
    }
}

// Execute testes com o comando a seguir:
// cargo test -- --nocapture --test-threads=1
//
//
// --nocapture faz imprimir todo o output, incluindo testes sucedidos.
// Sem o argumento --test-threads, todos os testes serão async. O que significa que o output será uma bagunça.
//
#[cfg(test)]
mod tests{
    use super::*;
    use near_sdk::{
        MockedBlockchain,
        testing_env,
        test_utils::VMContextBuilder,
    };

    fn env_setup(){
        let builder: VMContextBuilder = VMContextBuilder::new();
        testing_env!(builder.build());

        // O contrato é stateless. Declaramos, mas não usamos.
        let _contract: Contract = Contract::default();
    }

    #[test]
    pub fn print_examples() {
        env_setup();
    
        Contract::print_examples();
    }

    #[test]
    pub fn format_examples() {
        env_setup();
    
        Contract::format_examples();
    }

    #[test]
    pub fn vec_examples() {
        env_setup();
    
        Contract::vec_examples();
    }

    #[test]
    #[should_panic(expected = "Pânico com alguns argumentos: 1 2 3")]
    pub fn panic_example() {
        env_setup();

        Contract::panic_example();
    }
}

'''
'''--- ES/lesson_6_enums/Cargo.toml ---
[workspace]
members=["lesson_6_1_simple"]

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- ES/lesson_6_enums/Readme.md ---
# Lição 6 - Enums

[voltar](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/ES)

Esta lição é dividida em 4 partes relacionadas a enums. Cada tópico é uma crate. Aproveitaremos este momento para explicar sobre workspaces e como usá-los.

As sub-lições são as seguintes:
 - [Declarando e usando enums](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/ES/lesson_6_enums/lesson_6_1_simple/).
 - Enums da biblioteca standard, Option e Result.
 - Como implementar erros de forma prática e eficiente.
 - Como usar enums para agrupar diversos tipos em um único enum.

---

## Workspaces

[topo](#lição-6---enums)

Simplesmente, workspace é um diretório com várias crates. Quando compilados, todas as crates compartilham o mesmo diretório target. Mas cada crate resulta em um arquivo compilado.

Algumas utilidades para uso de workspaces são descritos a seguir:
 - Dependências locais. Criamos uma crate customizada para o nosso projeto, e outra crate depende dela.
 - Organização de projeto. Queremos executar testes e compilar todos os projetos simultaneamente.
 - Coordenação de contratos. Um projeto que consiste em vários contratos responsáveis por diferentes funções. Um workspace pode incluir os contratos e uma crate de testes cross-contract (exemplo: [workspaces-rs](https://github.com/near/workspaces-rs)).

---

## Cargo.toml

[topo](#lição-6---enums)

O manifest possui a seção ```[workspace]```.

```toml
[workspace]
members=["lesson_6_1_simple"]
```

```members``` descreve cada crate do projeto.

**Detalhe**: Se uma crate existir neste diretório, esta ainda será considerada. Para não incluir a crate, devemos incluir o atributo ```exclude```. Como no exemplo a seguir (fonte: https://doc.rust-lang.org/cargo/reference/workspaces.html, acesso em 17-mar-2022):

```toml
[workspace]
members = ["member1", "path/to/member2", "crates/*"]
exclude = ["crates/foo", "path/to/other"]
```

No exemplo acima, foram incluidos 3 caminhos, e excluidos 2.

---

## CLI em workspaces

[topo](#lição-6---enums)

Se executarmos comandos como ```cargo build``` ou ```cargo test``` em uma crate que pertence a uma workspace, todos as crates serão afetadas também.

Para especificar o comando para apenas uma crate, adicionamos a "flag" ``` -p ```, ```--package``` ou ```--workspace``` ao comando.

Para testar ```lesson_6_1_simple``` execute:

```bash
cargo test -p lesson_6_1_simple -- --nocapture --test-threads=1
```

```--nocapture``` faz imprimir o output de todos os testes.

```--test-threads=1``` faz todos os testes serem executados em um thread. Tornando o output legivel.

```bash
cargo build -p lesson_6_1_simple --target wasm32-unknown-unknown --release
```

Os arquivos '.wasm' estarão em './lesson_6_enums/target/wasm32-unknown-unknown/release/'.

```bash
cargo doc --lib --document-private-items -p lesson_6_1_simple --open
```

Gera documentação da sub-lição 6-1 e abre no browser padrão.

 - ```--lib``` especifica que a crate é um library.
 - ```--document-private-items``` pede para gerar documentação de todos os items.
 - ```--open``` abre o website no navegador padrão.

Documentação estará em './target/doc/lesson_6_1_simple/index.html'.

---

 - A proxima sub-seção será sobre [declaração e uso de enums](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/ES/lesson_6_enums/lesson_6_1_simple/).
 - A proxima lição será sobre traits.

'''
'''--- ES/lesson_6_enums/lesson_6_1_simple/Cargo.toml ---
[package]
name = "lesson_6_1_simple"
version = "0.1.0"
authors = ["Lucas Lemos <stiltztinkerstein@gmail.com>"]
license = "MIT"
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"

'''
'''--- ES/lesson_6_enums/lesson_6_1_simple/Readme.md ---
# Lição 6 - 1 Uso de Enums

[voltar](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/ES/lesson_6_enums/)

Essa lição descreve enums e instruções ```match```.

## API de contrato

```rust

/// Podemos usar instruções match para Strings e &str.
/// 
/// Esta função é um exemplo. 
/// 
/// Retorna 1, 2, 3, 4, 5, se o argumento for o número.
/// 
/// Causa panic se for outro valor.
pub fn string_match_example(&self, arg: String) -> u32;

/// Retorna example_0.
pub fn get_example_0(&self) -> Example0;

/// Retorna example_1.
pub fn get_example_1(&self) -> Example1;

/// Retorna example_2.
pub fn get_example_2(&self) -> Example2User;

/// Chama Example0::get_number.
pub fn example_0_get_number(&self) -> u32;

/// Chama Example0::is_third.
pub fn example_0_is_third(&self) -> bool;

/// Chama Example1::get.
pub fn example_1_get(&self) -> String;

/// Chama Example1::is_novalue.
pub fn example_1_is_novalue(&self) -> bool;

/// Chama Example1::get_an_integer.
pub fn example_1_get_an_integer(&self) -> String;

/// Chama Example1::has_an_odd_number.
pub fn example_1_has_an_odd_number(&self) -> bool;

/// Chama Example2User::get_name.
pub fn example_2_get_name(&self) -> String;

/// Chama Example2User::has_permission.
pub fn example_2_has_permission(&self, permission: String) -> bool;

/// Chama Example2User::get_actions.
/// 
/// Quando retornamos um Vec, o serializer tentará usar serde::json.
/// A instrução #[result_serializer] nos permite selecionar borsh como serializador.
#[result_serializer(borsh)]
pub fn example_2_get_actions(&self) -> Vec<String>;
```

## Compilando, testando

Essa crate pertence ao workspace da lição 6. Instruções sobre compilação e execução de testes na pagina [anterior](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/lesson_6_enums/lesson_6_1_simple/).

Executar comandos como ```cargo test``` e ```cargo build``` afetará todos as crates na workspace. A não ser que uma crate seja especificada.

## Tópicos

 - O que são enums.
 - Instruções match.
 - Exemplo 0: enums sem valores.
 - Exemplo 1: enums com primitivos.
 - Exemplo 2: usuários como enums.
 - Instruções match para strings.

## O que são enums

Enquanto Structs armazenam diversos valores simultaneamente. Enums armazenam um valor de cada vez. As alternativas que um enum pode representar são descritos na definição.

```rust
pub enum Example0{
    First,
    Second,
    Third,
    Fourth,
    Fifth,
}
```

Acima temos um exemplo de enum.
 - ```pub``` descreve que o enum está disponivel para ser usado em módulos externos.
 - ```Example0``` é o nome do enum.
 - ```First```, ```Second```, ```Third```, ```Fourth``` e ```Fifth``` são os nomes dos valores que este enum pode possuir.

Acima temos a declaração do enum, mas como criamos uma instância de enum? A seguir criamos um exemplo para os 5 valores possiveis.

```rust
let a = Example0::First;
let b = Example0::Second;
let c = Example0::Third;
let d = Example0::Fourth;
let e = Example0::Fifth;
```

## Instruções match

'''
'''--- ES/lesson_6_enums/lesson_6_1_simple/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
#[allow(unused_imports)]
use near_sdk::{env, near_bindgen};

near_sdk::setup_alloc!();

mod model;

use model::{
    Example0,
    Example1,
    Example2User,
    log,
};

/// Imprime a função sendo chamada.
pub fn log_call(name: &str){
    log(&format!("Calling {}", name));
}

#[near_bindgen]
#[derive(Clone, Default, BorshDeserialize, BorshSerialize)]
pub struct Contract {
    example_0: Example0,
    example_1: Example1,
    example_2_user: Example2User,
}

#[near_bindgen]
impl Contract{
    /// Podemos usar instruções match para Strings e &str.
    /// 
    /// Esta função é um exemplo. 
    /// 
    /// Retorna 1, 2, 3, 4, 5, se o argumento for o número.
    /// 
    /// Causa panic se for outro valor.
    pub fn string_match_example(&self, arg: String) -> u32 {

        // Trata a referencia &String como &str
        return match &arg as &str {
            "1" => 1,
            "2" => 2,
            "3" => 3,
            "4" => 4,
            "5" => 5,
            value => panic!("Received {}. Must be 1, 2, 3, 4 or 5.", value),
        }
    }

    /// Retorna example_0.
    pub fn get_example_0(&self) -> Example0 {
        log_call("get_example_0");
        self.example_0.clone()
    }

    /// Retorna example_1.
    pub fn get_example_1(&self) -> Example1 {
        log_call("get_example_1");
        self.example_1.clone()
    }

    /// Retorna example_2.
    pub fn get_example_2(&self) -> Example2User {
        log_call("get_example_2");
        self.example_2_user.clone()
    }

    /// Chama Example0::get_number.
    pub fn example_0_get_number(&self) -> u32 {
        log_call("get_example_0_get_number");
        self.example_0.get_number()
    }

    /// Chama Example0::is_third.
    pub fn example_0_is_third(&self) -> bool {
        log_call("get_example_0_is_third");
        self.example_0.is_third()
    }

    /// Chama Example1::get.
    pub fn example_1_get(&self) -> String {
        log_call("get_example_1_get");
        self.example_1.get()
    }

    /// Chama Example1::is_novalue.
    pub fn example_1_is_novalue(&self) -> bool {
        log_call("get_example_1_is_novalue");
        self.example_1.is_no_value()
    }

    /// Chama Example1::get_an_integer.
    pub fn example_1_get_an_integer(&self) -> String {
        log_call("get_example_1_get_an_integer");
        let the_integer : Option<i32> = self.example_1.get_an_integer();

        match the_integer {
            Some(value) => {
                format!("{}", value)
            },
            None => {
                String::from("")
            }
        }
    }

    /// Chama Example1::has_an_odd_number.
    pub fn example_1_has_an_odd_number(&self) -> bool {
        log_call("get_example_1_has_an_odd_number");
        self.example_1.has_an_odd_number()
    }

    /// Chama Example2User::get_name.
    pub fn example_2_get_name(&self) -> String {
        log_call("get_example_2_get_name");
        self.example_2_user.get_name()
    }

    /// Chama Example2User::has_permission.
    pub fn example_2_has_permission(&self, permission: String) -> bool {
        log_call("get_example_2_has_permission");
        self.example_2_user.has_permission(permission)
    }

    /// Chama Example2User::get_actions.
    /// 
    /// 
    /// Quando retornamos um Vec, o serializer tentará usar serde::json.
    /// A instrução #[result_serializer] nos permite selecionar borsh como serializador.
    #[result_serializer(borsh)]
    pub fn example_2_get_actions(&self) -> Vec<String>{
        log_call("get_example_2_get_actions");

        let result = self.example_2_user.get_actions();

        let result: Vec<String> = match result {
            Err(err) => panic!("Error: {}\n", err),
            Ok(value) => value,
        };

        result
    }
}

#[cfg(test)]
mod tests{
    use super::*;
    use near_sdk::{
        AccountId,
        env,
        MockedBlockchain,
        testing_env,
        test_utils::VMContextBuilder,
        json_types::ValidAccountId,
    };

    fn env_setup(){
        let mut builder: VMContextBuilder = VMContextBuilder::new();

        // attributes we can set with the builder:
        // current_account_id
        // signer_account_id
        // signer_account_pk
        // precessor_account_id
        // block_index
        // block_timestamp
        // epoch_height
        // account_balance
        // account_locked_balance
        // storage_usage
        // attached_deposit
        // prepaid_gas
        // random_seed
        // is_view

        let account_id: AccountId = String::from("stiltztinkerstein");

        builder.current_account_id(
            ValidAccountId::try_from(
                account_id.clone()
            ).unwrap()
        );

        testing_env!(builder.build());

        assert_eq!(
            env::current_account_id(),
            account_id, 
            "Assert Error. env: {} account: {}", 
            env::current_account_id(), 
            &account_id,
        );
    }

    #[test]
    fn string_match_example(){
        let (a1, a2, a3, a4, a5) = (
            String::from("1"),
            String::from("2"),
            String::from("3"),
            String::from("4"),
            String::from("5"),
        );

        env_setup();

        let contract = Contract::default();

        // string_match_example(&self, arg: String)
        assert_eq!(contract.string_match_example(a1), 1);
        assert_eq!(contract.string_match_example(a2), 2);
        assert_eq!(contract.string_match_example(a3), 3);
        assert_eq!(contract.string_match_example(a4), 4);
        assert_eq!(contract.string_match_example(a5), 5);
    }

    /// Testa situação de erro com argumento 0.
    #[test]
    #[should_panic(expected="Received 0. Must be 1, 2, 3, 4 or 5.")]
    fn string_match_example_error(){
        env_setup();
        let contract = Contract::default();

        contract.string_match_example(String::from("0"));
    }
}
'''
'''--- ES/lesson_6_enums/lesson_6_1_simple/src/model.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};

// As duas funções a seguir são declaradas para
// termos duas implementações diferentes de uma mesma função "log".
// As mensagens chamadas com essa função log aparecerão 
// em testes e na máquina virtual.

#[cfg(test)]
pub fn log(message: &str){
    println!("{}", message);
}

#[cfg(not(test))]
pub fn log(message: &str){
    near_sdk::env::log(message.as_bytes());
}

/// Um struct possui varios valores diferentes simultâneos, um enum só pode possuir um valor.
/// Os possiveis valores de um enum são descritos em sua declaração.
/// 
/// Os possiveis valores de Exemplo0 são:
///  - Example0::FIRST
///  - Example0::SECOND
///  - Example0::THIRD
///  - Example0::FOURTH
///  - Example0::FIFTH
/// 
#[derive(BorshDeserialize, BorshSerialize, Clone)]
pub enum Example0{
    First,
    Second,
    Third,
    Fourth,
    Fifth,
}

impl Default for Example0{
    fn default() -> Self {
        Example0::First
    }
}

// Semelhante a structs, implementamos métodos no namespace de Exemplo0 a seguir:
impl Example0{

    /// Observa o valor de si mesmo e retorna um número entre 1 e 5.
    /// 
    /// Note o &self, significando que a função acessa o valor, mas não altera.
    /// 
    pub fn get_number(&self) -> u32 {
        log("Calling Example0::get_number");

        // Instruções match são semelhantes a uma 
        match self {
            Example0::First => {1},
            Example0::Second => {2},
            Example0::Third => {3},
            Example0::Fourth => {4},
            Example0::Fifth => {5},
        }
    }

    /// true se o valor for Exemplo0::THIRD
    pub fn is_third(&self) -> bool {

        log("Calling Example0::is_third");

        // match compara os valores iniciando do topo
        // se colocarmos um nome de variavel, o branch acerta
        // e a variavel possui o valor no bloco associado.
        //
        // Uma variável que começa com o caracter _ é uma variável que
        // não pretendemos utilizar.
        //
        // Devido a isso, _ sempre será "matched", as alternativas
        // abaixo nunca serão acessadas.
        match self {
            Example0::Third => true,
            _ => false,
            // Exemplo0::SECOND => {
            //     // Descomente esse bloco e receberá um aviso
            //     // Essa branch nunca será alcançada
            //     // Porque a branch acima aplica a qualquer pattern.
            //     false
            // },
        }
    }
}

/// Um enum permite um objeto representar vários tipos diferentes:
/// 
/// Este exemplo possui o objetivo de mostrar que usar um enum como conteiner de valores não é uma boa ideia.
/// 
/// Os métodos de enum devem retornar resultados simples.
/// Tentar retirar os valores armazenados em enums para serem usados fora adiciona complexidade desnecessária ao código.
/// 
/// Use enums para agrupar tipos diferentes que compartilham uma funcionalidade semelhante.
/// 
/// 
#[derive(Clone, BorshDeserialize, BorshSerialize)]
pub enum Example1{
    NoValue,
    AnInteger(i32),
    AFloat(f32),
    AString(String),
    ATuple(i32, u32),
    ACLikeStruct{first: u32, second: String},
}

impl Default for Example1{
    fn default() -> Self {
        Example1::NoValue
    }
}

impl Example1{
    // Porem, vale lembrar que um método ou função deve retornar apenas um tipo de resultado especificado.
    //
    // Um desenvolvedor pode tentar criar uma função get que retorna o valor armazenado.
    // Isso será dificil de implementar.
    // 
    // A forma mais simples de uma função get seria converter para um mesmo tipo.
    // Seguem alguns exemplos:
    //  - Retornar o valor como String
    //  - Usar Borsh ou serde para serializar o valor para bytes, deserializando após o recebimento.
    //  - Implementar genéricos. serão explicados em outra lição.
    //  - Retornar um ponteiro? A possibilidade disso ser necessário é baixa. O custo de complexidade é muito alto.
    // 

    // O método a seguir retorna apenas um tipo, isso é aceitável para o compilador.
    pub fn get(&self) -> String {
        log("Calling Example1::get");

        match self{
            Example1::NoValue => String::from(""),
            Example1::AnInteger(valor) => format!("{}", valor),
            Example1::AFloat(valor) => format!("{}", valor),
            Example1::AString(valor) => format!("{}", valor),
            Example1::ATuple(valor0, valor1) => format!("({}, {})", valor0, valor1),
            Example1::ACLikeStruct { first, second } => format!("{{\nfirst: {},\nsecond: \"{}\",\n}}\n", first, second),
        }
    }

    // Também pode-se criar uma função para retornar cada tipo.

    /// true se o valor do enum
    pub fn is_no_value(&self) -> bool{
        log("Calling Example1::is_no_value");

        match self{
            Example1::NoValue => true,
            _ => false,
        }
    }

    /// Retorna um inteiro, se o enum for essa alternativa.
    ///
    /// Option será explicado em detalhes na próxima seção.
    ///
    /// Option é um enum da biblioteca padrão (standard).
    /// Representa a possibilidade de possuir um valor ou não.
    /// Option pode ser Option::Some(valor) ou Option::None.
    pub fn get_an_integer(&self) -> Option<i32>{
        log("Calling Example1::get_an_integer");

        // valor será uma referência, clonamos o valor para não retornar uma referência.
        match self{
            Example1::AnInteger(valor) => Some(valor.clone()),
            _ => None
        }
    }

    /// Retorna true se possui algum numero inteiro impar,
    pub fn has_an_odd_number(&self) -> bool {
        log("Calling Example1::has_an_odd_number");

        match self {
            Example1::NoValue => false,
            Example1::AnInteger(valor) => {
                if valor%2 == 1{
                    return true;
                }
                    
                return false;
            },
            Example1::AFloat(_valor) => false,
            Example1::AString(_valor) => false,
            Example1::ATuple(valor0, valor1) => {
                return (valor0%2 == 1) || (valor1%2 == 1);
            },
            Example1::ACLikeStruct { first, second: _ } => {
                // Não temos interesse no segundo valor que é String
                first%2 == 1
            },
        }
    }
}

/// Tipo criado para o exemplo abaixo.
/// 
/// Criado apenas para mostrar um exemplo de implementação de struct em match.
/// 
#[derive(BorshDeserialize, BorshSerialize, Clone)]
pub struct Employee{
    pub name: String,
    pub id: u32,
    pub pass: String,
    pub permissions: Vec<String>,
    pub actions: Vec<String>,
}

impl Default for Employee{
    fn default() -> Self {
        log("Calling Employee::default");

        Employee { 
            name: String::from("a name"), 
            id: 11, 
            pass: String::from("some random pass"), 
            permissions: vec![
                String::from("Can access google"),
                format!("Can access 9gag"),
            ], 
            actions: vec![
                String::from("Did something"),
                String::from("Did something else"),
            ],
        }
    }
}

/// Exemplo mais prático. 
/// 
/// Representa o Usuário de um aplicativo.
/// 
/// Digamos que um usuário possa ser os seguintes tipos:
///  - Cliente
///  - Funcionario
///  - Administrador
/// 
/// Podemos controlar as permissões de cada com um enum.
/// 
/// Seria melhor termos tipos struct pra cada valor, mas estamos com pressa.
/// 
/// Todos possuem nome e id, alem disso, cada um possui:
///  - Admin: passe (codificado, claro) para acesso. Lista de ações no sistema.
///  - Employee: passe (codificado) para acesso. Lista de ações. Lista de permissões no sistema.
///  - Client: apenas lista de pedidos.
/// 
#[derive(BorshDeserialize, BorshSerialize, Clone)]
pub enum Example2User{
    Admin{ name: String, id: u32, pass: String, actions: Vec<String> },
    Client{ name: String, id: u32, orders: Vec<String> },
    Employee( Employee ),
}

impl Default for Example2User{
    fn default() -> Self {
        log("Calling Example2User::default");

        Example2User::Employee(Employee::default())
    }
}

impl Example2User{

    /// Retorna nome do usuário.
    /// 
    /// O bloco que chama o método não precisa de saber o que o usuário é.
    pub fn get_name(&self) -> String {
        log("Calling Example2User::get_name");

        match self {
            Example2User::Admin { name, id: _, pass: _, actions: _ } => { name.clone() },
            Example2User::Client { name, id: _, orders: _ } => { name.clone() },
            Example2User::Employee( employee ) => { employee.name.clone() },
        }
    }

    /// Checa se usuário possui permissão para ação.
    /// 
    /// Não é uma boa ideia usar String para permissões. Devido a possivel erros de caracteres, etc. Enums seriam melhor.
    /// 
    /// Mas o código ja está complexo o suficiente.
    /// 
    /// Neste exempĺo:
    ///  - Clientes não possuem permissão. Sempre retorna falso.
    ///  - Administradores sempre possuem permissão. Sempre retorna true.
    ///  - Empregados podem ou não possuir permissão. Checa por permissões.
    /// 
    pub fn has_permission(&self, permission: String) -> bool{
        log("Calling Example2User::has_permission");

        match self{
            Example2User::Client { name: _, id: _, orders: _ } => { false },
            Example2User::Admin { name: _, id: _, pass: _, actions: _ } => { true },
            Example2User::Employee(employee) => {

                // Vec implementa a trait IntoIterator.
                // Isso disponibiliza o método .iter ao vetor.
                // Este método nos permite iterar referencias de String.
                // Nenhuma cópia de String é feita.
                for employee_permission in employee.permissions.iter(){
                    if permission == *employee_permission {
                        return true;
                    }
                }

                false
            }
        }
    }

    /// Retorna a lista de ações se for Admin ou Employee.
    /// 
    /// Como exemplo, digamos que o design de projeto necessita de retornar
    /// um erro, se o usuário for um Client.
    /// 
    /// Result é semelhante a Option. Mas é usado para representar ações que podem causar erros.
    /// Explicado na proxima sub-seção.
    pub fn get_actions(&self) -> Result<Vec<String>, String> {
        log("Calling Example2User::get_actions");
        
        // Se for client, retorna um erro (Como exemplo).
        // Se for admin ou employee, retorna referencia para o Vec.
        let actions = match self{
            Example2User::Client { name: _, id: _, orders: _ } => { return Err(format!("User is Client")); },
            Example2User::Admin { name: _, id: _, pass: _, actions, } => { actions },
            Example2User::Employee( employee ) => { &employee.actions },
        };

        let mut result: Vec<String> = Vec::new();
        // Usa a referência para criar uma cópia do Vec.
        for action in actions{
            result.push(action.clone());
        }

        Ok(result)
    }
}

#[cfg(test)]
mod tests{
    // use std::result;

    use super::*;

    #[test]
    fn example0() {
        let first = Example0::First;
        let second = Example0::Second;
        let third = Example0::Third;
        let fourth = Example0::Fourth;
        let fifth = Example0::Fifth;

        assert_eq!(first.get_number(), 1);
        assert_eq!(second.get_number(), 2);
        assert_eq!(third.get_number(), 3);
        assert_eq!(fourth.get_number(), 4);
        assert_eq!(fifth.get_number(), 5);

        assert_eq!(first.is_third(), false);
        assert_eq!(second.is_third(), false);
        assert_eq!(third.is_third(), true);
        assert_eq!(fourth.is_third(), false);
        assert_eq!(fifth.is_third(), false);
    }

    // NoValue,
    // AnInteger(i32),
    // AFloat(f32),
    // AString(String),
    // ATuple(i32, u32),
    // ACLikeStruct{first: u32, second: String},

    /// Cria 6 instâncias diferentes de Example1 para servir de exemplo.
    fn example1_create() -> (
        Example1,
        Example1,
        Example1,
        Example1,
        Example1,
        Example1,
    ){
        // Retorna uma tupla com um exemplo de cada um dos valores.
        (
            Example1::NoValue,
            Example1::AnInteger(10),
            Example1::AFloat(3.5),
            Example1::AString(String::from("A String")),
            Example1::ATuple(-5, 5),
            Example1::ACLikeStruct{first: 1, second: String::from("second")},
        )
    }

    #[test]
    /// Garante que a função get retorna as Strings esperadas.
    fn example1_get(){
        let (
            no_value,
            an_integer,
            a_float,
            a_string,
            a_tuple,
            a_c_like_struct
        ) = example1_create();

        let no_value = no_value.get();
        let an_integer = an_integer.get();
        let a_float = a_float.get();
        let a_string = a_string.get();
        let a_tuple = a_tuple.get();
        let a_c_like_struct = a_c_like_struct.get();
        

        assert!(no_value.eq_ignore_ascii_case(""));
        assert!(an_integer.eq_ignore_ascii_case("10"));
        assert!(a_float.eq_ignore_ascii_case("3.5"));
        assert!(a_string.eq_ignore_ascii_case("A String"));
        assert!(a_tuple.eq_ignore_ascii_case("(-5, 5)"));
        assert!(a_c_like_struct.eq_ignore_ascii_case(&format!("{{\nfirst: 1,\nsecond: \"second\",\n}}\n")));
    }

    /// Garante que apenas retorna true para no_value.
    #[test]
    fn example1_is_novalue(){
        let (
            no_value,
            an_integer,
            a_float,
            a_string,
            a_tuple,
            a_c_like_struct
        ) = example1_create();

        let no_value = no_value.is_no_value();
        let an_integer = an_integer.is_no_value();
        let a_float = a_float.is_no_value();
        let a_string = a_string.is_no_value();
        let a_tuple = a_tuple.is_no_value();
        let a_c_like_struct = a_c_like_struct.is_no_value();

        assert_eq!(no_value, true);
        assert_eq!(an_integer, false);
        assert_eq!(a_float, false);
        assert_eq!(a_string, false);
        assert_eq!(a_tuple, false);
        assert_eq!(a_c_like_struct, false);
    }

    #[test]
    fn example1_get_an_integer(){

        fn asserting(value: Option<i32>, expected: Option<i32>){
            let comparison = match (value, expected){
                (None, None) => true,
                (Some(first), Some(second)) => first == second,
                _ => false,
            };

            assert_eq!(comparison, true, "Failed comparison between {:?} == {:?}\n", value, expected);
        }

        let (
            no_value,
            an_integer,
            a_float,
            a_string,
            a_tuple,
            a_c_like_struct
        ) = example1_create();

        let no_value = no_value.get_an_integer();
        let an_integer = an_integer.get_an_integer();
        let a_float = a_float.get_an_integer();
        let a_string = a_string.get_an_integer();
        let a_tuple = a_tuple.get_an_integer();
        let a_c_like_struct = a_c_like_struct.get_an_integer();

        asserting(no_value, None);
        asserting(an_integer, Some(10));
        asserting(a_float, None);
        asserting(a_string, None);
        asserting(a_tuple, None);
        asserting(a_c_like_struct, None);
    }

    // Admin{ name: String, id: u32, pass: String, actions: Vec<String> },
    // Client{ name: String, id: u32, orders: Vec<String> },
    // Employee( Employee ),

    /// Cria 3 instâncias diferentes de Example2User para serem usadas nos testes.
    fn example2_user_create() -> [Example2User; 3] {
        [
            Example2User::Admin { 
                name: String::from("Lucas"), 
                id: 0, 
                pass: String::from("12345"), 
                actions: vec![
                    String::from("Signed in 24 dec 2022, 06h33m49.67s"),
                    String::from("Logged off 24 dec 2022, 09h22m01.18s"),
                ]
            },
            Example2User::Employee(Employee {
                 name: String::from("Lucas"), 
                 id: 1, 
                 pass: String::from("123456"), 
                 permissions: vec![
                     String::from("Access client logs"),
                     String::from("Access stock"),
                 ], 
                 actions : vec![
                    String::from("Signed in 25 dec 2022, 08h11m32.01s"),
                    format!("Accessed Logs from {} {} {} {}, {:02}h{:02}m{:02}.{:02}s", "Lucas", 25, "dec", 2022, 09, 45, 19, 05),
                    String::from("Logged off 25 dec 2022, 11h44m51.92s"),
                ]
            }),
            Example2User::Client { 
                name: String::from("Lucas"), 
                id: 3, 
                orders: Vec::from([
                    format!("Successful transaction. ID: {}.", 4241235)
                ]) 
            }
        ]
    }

    #[test]
    fn example2_user_get_name(){
        // Cria 3 instâncias de example2 e aplica-os aos 3 tipos abaixo.
        let [admin, employee, client] = example2_user_create();

        // Executa get_name para as 3 instâncias.
        let (result_admin, result_employee, result_client) = (
            admin.get_name(),
            employee.get_name(),
            client.get_name(),
        );

        // Garante que o valor adiquirido para os 3 é "Lucas"
        // Detalhe extra: Estamos comparando um String com um &str,
        // isso é possivel porque implementam a trait partial_eq para os tipos.
        assert_eq!(result_admin, "Lucas");
        assert_eq!(result_employee, "Lucas");
        assert_eq!(result_client, "Lucas");
    }

    #[test]
    fn example2_has_permission(){
        // Cria 3 instâncias de example2 e aplica-os aos 3 tipos abaixo.
        let [admin, employee, client] = example2_user_create();

        // Executa has_permission para as 3 instâncias.
        let (result_admin, result_employee, result_client) = (
            admin.has_permission(String::from("Access client logs")),
            employee.has_permission(String::from("Access client logs")),
            client.has_permission(String::from("Access client logs")),
        );

        assert_eq!(result_admin, true);
        assert_eq!(result_employee, true);
        assert_eq!(result_client, false);
    }

    // pub fn get_actions(&self) -> Result<Vec<String>, String> {
    
    #[test]
    fn example2_get_actions(){

        // Função para comparar vetores
        fn vec_eq(first: Result<Vec<String>, String>, second: Result<Vec<String>, String>) -> bool {
            let (first, second) = match (first, second) {
                (Err(first), Err(second)) => {
                    return first == second;
                },
                (Ok(first), Ok(second)) => {
                    (first.clone(), second.clone())
                },
                (_, _) => {
                    return false;
                }
            };

            // Ambos os vetores devem ter o mesmo número de elementos
            assert_eq!(first.len(), second.len(), "len is different");

            let length: usize = first.len();

            for counter in 0..length {
                assert_eq!(first[counter], second[counter], "Failed comparison between {} and {}", first[counter], second[counter]);
            }

            return true;
        }

        // Cria 3 instâncias de example2 e aplica-os aos 3 tipos abaixo.
        let [admin, employee, client] = example2_user_create();

        // Executa has_permission para as 3 instâncias.
        let (result_admin, result_employee, result_client) = (
            admin.get_actions(),
            employee.get_actions(),
            client.get_actions(),
        );

        // Garante que a função retorna um Ok contendo os respectivos valores.
        assert!(
            vec_eq(
                result_admin, 
                Ok(vec![
                    String::from("Signed in 24 dec 2022, 06h33m49.67s"),
                    String::from("Logged off 24 dec 2022, 09h22m01.18s"),
                ])
            )
        );

        // Mesmo para employee.
        assert!(
            vec_eq(
                result_employee,
                Ok(vec![
                    String::from("Signed in 25 dec 2022, 08h11m32.01s"),
                    format!("Accessed Logs from {} {} {} {}, {:02}h{:02}m{:02}.{:02}s", "Lucas", 25, "dec", 2022, 09, 45, 19, 05),
                    String::from("Logged off 25 dec 2022, 11h44m51.92s"),
                ]),
            )
        );

        // No caso de client, garante que retorna um erro.
        assert!(
            vec_eq(
                result_client,
                Err(format!("User is Client")),
            )
        )

    }
}
'''
'''--- ES/static/Readme.md ---
Imagens e tutoriais.

'''
'''--- ES/static/tutorials/cargo.md ---
# Introdução a Cargo

Cargo é a ferramenta que usamos para administrar nossos projetos da linguagem rust. Documentação completa sobre Cargo no [livro Cargo](https://doc.rust-lang.org/cargo/).

 - [Cargo.toml](#cargotoml)
 - [O que é crate](#o-que-%C3%A9-crate)
   - [crates.io](#cratesio)
 - [Comandos Cargo](#comandos-cargo)
   - [cargo build](#cargo-build)
   - [cargo test](#cargo-test)
   - [cargo doc](#cargo-doc)

## Cargo.toml
[topo](#introdu%C3%A7%C3%A3o-a-cargo)

Semelhante a ```package.json``` para ```node.js```, este arquivo possui todas as informações meta sobre este diretório. Características como nome e versão, mas também configurações sobre como o projeto deve ser compilado.

![Imagem de um arquivo Cargo.toml padrão. Identico ao Cargo.toml da lição 1.](../images/cargo.png)

Não é necessário saber tudo sobre essas configurações. As configurações que precisaremos alterar são ```[package]``` e ```[dependencies``` de projeto em projeto. A seguir, descrevemos os tópicos principais:
 - **package**: Configurações sobre a crate. Nome, versão, licensa, edição do Rust, etc; 
 - **lib**: Isso determina que esta crate não é um executável. E sim é uma biblioteca que será acessada externamente. ```cdylib``` quer dizer "c dynamic library", ```rdylib``` quer dizer "rust dynamic library". Acho que o compilador webassembly precisa dessas configurações.
 - **dependencies**: Aqui declaramos nossas dependencias. Podemos incluir de varias formas. O padrão é vindo do site "crates.io", mas podemos também incluir crates locais; podemos incluir através de um link github, etc.
 - **profile.release**: Configuração para projetos compilados para "release". Não é necessário entender cada instrução. Simplesmente fala para o compilador tentar optimizar o máximo possivel, quando um erro (panic) acontece, finaliza o runtime, et cetera.

## O que é crate?
[topo](#introdu%C3%A7%C3%A3o-a-cargo)

**Crate** (caixa) representa um diretório com um arquivo "Cargo.toml".

Geralmente, cada crate gera um diretório "target" com o arquivo compilado. Mas se criarmos um workspace, que é um conjunto de várias crates compartilhando um "Cargo.toml", os arquivos compilados são todos agrupados na mesma pasta. Para mais detalhes, cheque a lição sobre workspaces.

Podemos publicar nossas crates no site [crates.io](https://crates.io/).

### Crates.io
[topo](#introdu%C3%A7%C3%A3o-a-cargo)

Dependências como ```near_sdk``` são baixadas deste site. Qualquer desenvolvedor rust pode compartilhar projetos neste site, com **uma condição**: Deve ser open-source.

O site intencionalmente não disponibiliza opção para compartilhar crates de forma privada.

![](../images/crates.io.png)

Para impedir que projetos quebrem de forma inesperada, se retirarmos uma versão do registry usando o comando "yank", projetos não poderão mais baixar a versão, mas ainda continuarão funcionando se tiverem a versão baixada.

## Comandos Cargo
[topo](#introdu%C3%A7%C3%A3o-a-cargo)

Segue uma lista simplificada de comandos cargo que podemos utilizar durante desenvolvimento de contratos NEAR.

 - build: compila o projeto.
 - test: executa testes de unidade.

Só isso. Existem vários outros comandos que podemos executar com cargo. Mas não são necessários para novos desenvolvedores. Cheque o [livro Cargo](https://doc.rust-lang.org/cargo/).

### Cargo build
[topo](#introdu%C3%A7%C3%A3o-a-cargo)

Precisamos compilar o projeto para webassembly, sem uma arquitetura especificada. Para isso usamos:

```bash
cargo build --release --target wasm32-unknown-unknown
```

 - ```release``` corta todas as partes da compilação feitas para auxiliar o debug e otimiza o código para produção
 - ```target``` determina a arquitetura alvo para o projeto. Escolhemos webassembly.

O arquivo webassembly estará no caminho '/target/wasm32-unknown-unknown/release/'.

**Aviso**: Essa instrução irá resultar em **erro** se não instalarmos ```wasm32-unknown-unknown``` na lista de alvos da linguagem rust. Para isto, basta executar a seguinte instrução (apenas uma vez para cada instalação de rust).

```bash
rustup target add wasm32-unknown-unknown
```

### Cargo test
[topo](#introdu%C3%A7%C3%A3o-a-cargo)

Realiza todos os testes de unidade no projeto. Se uma função possui o marcador ```#[test]```, essa função será executada.

Testes de unidade simplesmente procuram por situações de pânico. Se um pânico inesperado acontece, ou um pânico esperado não acontece, o teste falha.

Macros como panic, assert e assert_eq são usados para garantir nossas condições.
 - ```panic!("Mensagem");```: Causa pânico com a dada mensagem.
 - ```assert!(condicao, "Mensagem");```: Causa pânico se a condição for falsa. Está "garantindo" que a condição será verdadeira.
 - ```assert_eq!(primeiro, segundo, "Mensagem");```: Compara ```primeiro == segundo```. Se forem diferentes, causa pânico com a dada mensagem.

Exemplo de situação em que não esperamos panic:

```rust
#[test]
fn oneplusone() {
    assert_eq!(1 + 1, 2);
}
```

1+1 é sempre igual a 2. Então nunca haverá panic.

Exemplo de situação em que esperamos panic:

```rust
#[test]
#[should_panic(expected = "A panic has just happened")]
pub fn this_will_panic() {
    env_setup();

    let _contract: Contract = Contract::default();

    Contract::this_will_panic();
}
```

Este é um exemplo da "lição 4 - módulos". A função ```this_will_panic()``` é uma função que eu criei que sempre causa pânico.

```#[should_panic]``` significa que o teste vai falhar se não entrar em panic. ```expected``` especifica qual a mensagem de pânico esperada.

Isso é tudo sobre testes para contrato. Para simular a comunicação entre contratos, precisamos de utilizar workspaces-rs.

### Cargo doc
[topo](#introdu%C3%A7%C3%A3o-a-cargo)

Gera uma página de web com a documentação do projeto. Muito fácil de compartilhar. A pagina de web estará no caminho "/target/doc/nome_da_crate/".

```bash
cargo doc --open
```
Irá abrir a pagina de web no navegador padrão.

![](../images/cargodoc.png)

Clique em Contract para ver as funções implementadas:

![](../images/cargodoccontract.png)

Comentários com ```//``` não aparecem na documentação.

[Voltar](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/ES/)

'''
'''--- ES/static/tutorials/nearcli.md ---
# Introdução a near-cli

Near CLI ("command line interface") é a ferramenta que utilizamos para interagir com o protocolo blockchain. Documentação completa sobre near-cli no [tutorial](https://docs.near.org/docs/tools/near-cli).

## Conta NEAR (Simplificado)

Uma conta NEAR pode ser vista como uma carteira. Podemos transferir NEAR, receber, executar funções em contratos inteligentes de outras contas, criar chaves de acesso com certas permissões, etc.

Um smart contract pode ser implementado em uma conta NEAR, mas não é obrigatório para que essa exista. Cada conta ou sub-conta NEAR só pode ter um contrato de cada vez. Mas uma conta NEAR pode ser mestre (permissões administrativas) de várias sub-contas.

Ou seja, quando precisarmos de implementar vários contratos, podemos distribui-los em uma hierarquia de diversas contas com maior segurança. As subcontas só precisam das permissões necessárias para seus objetivos. As subcontas só precisam da quantidade de gas necessárias para se manterem em operação.

**gas**: É NEAR gasto para computação, armazenamento de dados, criação de contas, etc. A cada clock de computação, uma fração de NEAR é consumida da conta. As máquinas que mantém nosso sistema em funcionamento devem ser recompensadas, por isso utilizamos **gas** é consumido.

## Lista de Comandos

Discutiremos alguns comandos a seguir:
 - [Login](#login)
 - [Checar State](#checar-state-estado)
 - [Criar Sub-conta](#criar-sub-conta)
 - [Implantar Contrato](#implantar-contrato)
   - [Evitando Inicialização Sem argumentos](#evitando-inicializa%C3%A7%C3%A3o-sem-argumentos)
 - [Executar Funções de Contrato](#executando-funções-do-contrato)
   - [View](#view)
   - [Call](#call)
 - [Deletar Sub-Conta](#deletar-sub-conta)

## Login
[topo](#introdu%C3%A7%C3%A3o-a-near-cli)

```bash
near login
```

![Imagem de um navegador conectando à plataforma NEAR, ao lado um terminal com o comando near login.](../images/nearlogin.png)

Não é a nossa máquina que executa as funções de contrato descentralizadas. A nossa conta na blockchain que faz isso. Nós conectamos a uma conta testnet com este comando.

**testnet**: é uma plataforma de teste NEAR. Os tokens não tem valor e não é possivel comercializá-los. A plataforma oficial é a **mainnet**. Garanta que não há riscos no contrato antes de implementar para produção.

## Checar State (Estado)
[topo](#introdu%C3%A7%C3%A3o-a-near-cli)

```bash
near state stiltztinkerstein.testnet
```

Podemos checar o estado de qualquer conta na blockchain. É informação pública.

![Imagem de terminal após o uso do comando acima.](../images/nearstate.png)

Lembrar que esta é uma conta **testnet**. Não é dinheiro de verdade. Os atributos que conseguimos são estes:

 - **amount**: Quantidade de NEAR na conta em yocto Near. ```1 * 10²⁴ = 1 NEAR```.
 - **block_hash**: Hash do bloco;
 - **block_height**: Altura do bloco;
 - **code_hash**: Se o hash de código for uma sequência de "1", então nenhum smart contract foi implementado nesta conta;
 - **locked**: Quantidade de NEAR trancado?*;
 - **storage_paid_at**: Custo de armazenamento?*;
 - **storage_usage**: Uso de armazenamento?*;
 - **formattedAmount**: **amount** formatado para NEAR.

*: Quem tiver mais informações sobre os detalhes com *, agradeceria um pull-request.

## Criar sub-conta
[topo](#introdu%C3%A7%C3%A3o-a-near-cli)

Podemos criar uma subconta com um comando semelhante a este:

```bash
near create-account minha-subconta.minha-conta.testnet --masterAccount minha-conta.testnet --initialBalance 10
```

 - **nome-da-conta.minha-conta.testnet**: Nome da subconta que criei;
 - **minha-conta.testnet**: nome da conta mestre;
 - **masterAccount**: conta mestre;
 - **initialBalance 10**: Opcional. A conta mestre enviará 10 NEAR para a subconta;

Para criar uma conta de topo nível, use [near-api-js](https://docs.near.org/docs/api/naj-cookbook#create-account).

## Implantar Contrato
[topo](#introdu%C3%A7%C3%A3o-a-near-cli)

```bash
near deploy --accountId minha-subconta.minha-conta.testnet --wasmFile ./compilado.wasm
```

Após compilar nosso projeto (cheque o [tutorial cargo](https://github.com/On0n0k1/Tutorial_NEAR_Rust/blob/main/ES/static/tutorials/cargo.md)), usamos este comando para implantar o arquivo compilado em nossa subconta.

 - **accountId**: ID da conta em que implantaremos o contrato;
 - **wasmFile**: Caminho para o arquivo webassembly compilado;

O estado inicial deste contrato será a trait ```Default``` que implementamos no código rust. Essa trait não recebe parâmetros para inicialização. Se quisermos usar um construtor com parâmetros de inicialização, precisamos de seguir dois passos:

O primeiro passo é declarar um construtor com marcador ```#[init]```. Exemplo:

```rust
#[init]
pub fn new(title: String, data: String, category: i8) -> Self {
```

O nome da função ```new``` não é obrigatório. Mas é convenção criar construtores com este nome.

O segundo passo é incluir os parâmetros ```--initFunction``` e ```--initArgs``` para inicializar o contrato com a função e argumentos, respectivamente.

O comando de implantação poderia ser chamado da seguinte forma:

```bash
near deploy --accountId minha-subconta.minha-conta.testnet --wasmFile ./compilado.wasm --initFunction new --initArgs '{"title": "um-titulo", "data": "link-para-dados", "category": 3 }'
```

### Evitando inicialização sem argumentos
[topo](#introdu%C3%A7%C3%A3o-a-near-cli)

A trait ```Default``` é um requisito para o funcionamento do contrato, mesmo se não pretendermos utilizá-la. Se a inicialização com argumentos for essencial para o funcionamento do contrato, podemos fazer com que o processo entre em pânico caso o sistema tente inicializar com ```Default```.

Duas forma de causar "panic em ```Default```" são descritos a seguir:

Na implementação de ```Default```:
```rust
impl Default for Contract{
    fn default() -> Self{
        panic!("The contract is not initialized");
    }
}
```

Derivando ```PanicOnDefault``` na declaração de ```Contract```:

```rust
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract{
```

Ambas as alternativas fazem exatamente a mesma coisa.

## Executar funções do contrato
[topo](#introdu%C3%A7%C3%A3o-a-near-cli)

Existem dois tipos de funções de contrato:
 - **view**: Não realiza computação e não altera estado do contrato. Não consome gás. Ou seja, é de graça.
 - **call**: Todos os outros tipos de função. Consomem gás. Podem necessitar um pagamento. A implementação da função pode incluir outras restrições, como restrições de chave, restrições de usuário, et cetera.

### View
[topo](#introdu%C3%A7%C3%A3o-a-near-cli)

Para facilitar o entendimento, vale lembrar que o estado de todos os contratos são publicos.

Se uma função simplesmente retorna um valor armazenado no estado, então pode ser uma função view. Funções view não consomem gás, e não precisam de pagamento.

Funções view não podem realizar nenhum cálculo, e não podem alterar o estado do contrato.

Usaremos o contrato abaixo como exemplo:

```rust
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Contract{
    counter: i32,
    nome: String,
}
```

Os exemplos abaixo são exemplos válidos para funções view:

```rust
#[near_bindgen]
impl Contract{
    pub fn get_counter(&self) -> i32 {
        // i32 implementa Copy
        self.counter
    }

    pub fn get_counter1(&self) -> i32 {
        // O mesmo que get_counter
        return self.counter;
    }

    pub fn get_nome(&self) -> String {
        // String não implementa copy
        // Strign implementa Clone
        self.nome.clone()
    }

    pub fn get_nome1(&self) -> String {
        // O mesmo que get_nome
        return self.nome.clone();
    }
}
```

Uma breve explicação sobre alguns traits. Para um tipo implementar Copy, este precisa de implementar Clone.

Se um tipo implementar Clone, podemos criar uma cópia desse tipo com o método ```clone()```. Se um tipo implementar Copy, a cópía será feita automaticamente quando necessário. A instrução seguinte para i32:

```rust
return self.counter;
```

Se counter não implementasse ```Copy``` ou ```Clone```, teriamos um erro. Porque transferimos esse endereço de variável para outro lugar. Counter não teria um valor, pois a "ownership" foi perdida. O compilador não irá permitir essa transferência.

O exemplo a seguir **não** pode ser função view.

```rust
pub fn um_numero() -> i32 {
    5
}
```

Embora a função simplesmente retorna um número, é ainda considerada computação. Relembrando, funções view apenas retornam o valor de um estado do contrato (que é informação pública).

#### Executando uma função view
[topo](#introdu%C3%A7%C3%A3o-a-near-cli)

```bash
near view minha-subconta.minha-conta.testnet get_counter '{}'
```

### Call
[topo](#introdu%C3%A7%C3%A3o-a-near-cli)

Qualquer outro tipo de função que não é ```view```, é ```call```.

Para o contrato abaixo...

```rust
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Contract{
    counter: i32
}
```

... temos o exemplo de função ```call``` a seguir:

```rust
#[near_bindgen]
impl Contract{
    pub fn increment(&mut self) -> i32 {
        self.counter += 1;
        self.counter
    }
}
```

Exemplo retirado da "lição 1 - contratos". Incrementa counter em 1, e retorna o valor.

Podemos chamar a função da seguinte forma:

```bash
near call minha-subconta.minha-conta.testnet increment '{}' --account-id minha-conta.testnet
```

## Deletar Sub-Conta
[topo](#introdu%C3%A7%C3%A3o-a-near-cli)

```bash
near delete minha-subconta.minha-conta.testnet minha-conta.testnet
```

O primeiro argumento é o nome da sub-conta a deletar. O segundo argumento é o nome da conta que irá receber todo o NEAR armazenado.

'''
'''--- ES/static/tutorials/rust.md ---
# Instalação Rust

Este tutorial descreve a instalação das ferramentas recomendadas para criação de projetos NEAR em Rust.

 - [Scripts de Instalação](#scripts-de-instala%C3%A7%C3%A3o)
 - [Rustlings](#rustlings)
 - [Rust](#rust)

Instalaremos várias ferramentas diferentes com uma única linha de comando. Às que destacaremos nesse tutorial são: **rustup**, **cargo** e **rustc**.

 - **rustc**: compila o código rust para linguagem de máquina;
 - **cargo**: permite realizar comandos especificos para o projeto como compilar, criar documentação, realizar testes de unidade, executar projeto como binário.
 - **rustup**: existem varias diferentes formas de se compilar um projeto. Diversas arquiteturas diferentes. Diversas versões. rustup controla estas versões.

Uma analogia para desenvolvedores javascript:
 - rustup age de forma semelhante a nvm.
 - cargo age de forma semelhante a npm.
 - rustc age de forma semelhante a node.

É apenas uma analogia, existem algumas diferenças que serão encontradas em pratica.

## Scripts de instalação
[topo](#instala%C3%A7%C3%A3o-rust)

Recomendaremos duas alternativas para instalação de Rust. A primeira é recomendada para estudo, a segunda é recomendada para quem simplesmente quer instalar rustup.

 - rustlings: Instala rust e instala a ferramenta rustlings, que possui exercicios para desenvolvedores praticarem seu entendimento.
 - rust: Instala rust e todas as ferramentas necessárias para desenvolvimento.

## Rustlings
[topo](#instala%C3%A7%C3%A3o-rust)

Acesse o [repositório](https://github.com/rust-lang/rustlings) e siga as instruções de instalação.

![Pagina de web rust](../images/rustlings.png)

#### Rustlings para MacOS/Linux
[topo](#instala%C3%A7%C3%A3o-rust)

```bash
curl -L https://git.io/install-rustlings | bash
# Ou se quiser escolher o diretorio de instalação
curl -L https://git.io/install-rustlings | bash -s mypath/
```

### Rustlings para Windows
[topo](#instala%C3%A7%C3%A3o-rust)

Executar em um powershell com permissões de administrador.

```bash
Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser
```

E depois executar:

```bash
Start-BitsTransfer -Source https://git.io/JTL5v -Destination $env:TMP/install_rustlings.ps1; Unblock-File $env:TMP/install_rustlings.ps1; Invoke-Expression $env:TMP/install_rustlings.ps1
```

## Rust
[topo](#instala%C3%A7%C3%A3o-rust)

Acesse a [pagina oficial](https://www.rust-lang.org/tools/install) e execute o script. 

![Pagina de web rust](/static/images/rust.png)

```bash
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
```

Este comando detecta o sistema e instala todas as ferramentas necessárias.

'''
'''--- ES/static/tutorials/setup-nearcli.md ---
# Instalação NEAR CLI

NEAR CLI (NEAR Command Line Interface) é utilizado para fazer login e interagir com contas NEAR.

Uma explicação detalhada sobre a ferramenta pode ser encontrada no seguinte link: https://github.com/near/near-cli

Os passos são descritos e detalhados a seguir:

 - Instalar NPM (Node Package Manager)
 - Instalar NodeJs
 - Instalar NEAR CLI globalmente

## Windows

### Instalar NVM e NPM

Instale NPM de acordo com as descrições do [link](https://github.com/near/near-cli). Vou incluir os detalhes mais tarde. Agradeceria um pull request com o passo-a-passo para desenvolvedores Windows.

### Instalar NodeJs (versão 12+)

```bash
nvm install 12
nvm use 12
```

### Instalar NEAR CLI Globalmente

```bash
npm install -g near-cli
```

## Ubuntu

### Instalar NVM e NPM

[Link com Detalhes](https://linuxize.com/post/how-to-install-node-js-on-ubuntu-20-04/)

```bash
sudo apt update
sudo apt install nodejs npm
```

### Instalar NodeJs (versão 12+)

```bash
nvm install 12
nvm use 12
```

### Instalar NEAR CLI Globalmente

```bash
npm install -g near-cli
```

'''
'''--- PT-BR/README.md ---
# Tutorial_NEAR_Rust

[voltar](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/)

Tutorial em etapas para desenvolvimento de contratos inteligentes em rust. Neste conjunto de tutoriais serão discutidos todas as principais características da linguagem, assim como seu uso na plataforma NEAR.

---

## Contato

[topo](#tutorial_near_rust)

Para dúvidas, reclamações ou sugestões, por favor me adicione no discord On0n0k1#3800. Se este tutorial facilitar a sua vida, considere comprar um café para mim enviando uma fração de NEAR para stiltztinkerstein.near .

---

## Tópicos

[topo](#tutorial_near_rust)

 - [O Que é a linguagem Rust](#o-que-é-a-linguagem-rust)
 - [Usos da linguagem Rust](#usos-da-linguagem-rust)
 - [Aprendendo a Linguagem Rust](#aprendendo-a-linguagem-rust)
 - [Comparações com Javascript e Python](#compara%C3%A7%C3%B5es-com-javascript-e-python)
 - [Instalação](#instala%C3%A7%C3%A3o)
 - [Lições](#li%C3%A7%C3%B5es)

---

## O que é a linguagem Rust

[topo](#tutorial_near_rust)

De forma bem resumida, é uma linguagem de programação de baixo nível com as seguintes características:

 - Execução aproximadamente tão rápida quanto linguagem c ou c++.
 - Não tem os riscos de vazamento de memória que outras linguagens de baixo nível possuem.
 - É dificil de começar a aprender.
 - Não **usa** e nem **precisa** de coleta de lixo de memória. Pois no periodo de compilação, o compilador sabe exatamente quando variáveis são criadas e liberadas.
 - Processamento em paralelo é fácil.
 - Processamento assíncrono é de dificuldade semelhante a outras linguagens populares.
 - Muito mais simples organização de projeto e dependências do que python e javascript.
 - Ganhou repetidos anos consecutivos como a linguagem mais popular do stackoverflow.

---

## Usos da linguagem Rust

[topo](#tutorial_near_rust)

Um desenvolvedor Rust pode:

 - Criar apps decentralizados em plataformas web3 como NEAR.
 - Pode criar aplicativos que não precisam de uma máquina virtual para serem executados. Precisa do compilador Rust para compilar, mas não precisa para executar.
 - Criar servidores compactos e rápidos em conteineres docker.
 - Criar aplicações potentes como funções lambda para serem implantados em servidores aws (web3 é melhor porém).
 - Usar o linker para criar bibliotecas que podem ser usadas por um compilador como c.
 - Compilar bibliotecas que podem ser importadas em um browser javascript ou em um runtime nodejs com o formato WebAssembly.
 - Compilar bibliotecas potentes e eficientes para Python usando a crate PyO3.
 - Compilar código para dispositivos embarcados (embedded).
 - Competir em um mercado de trabalho que possui 1 ou 2 inscritos por vaga (incluindo internacional).

---

## Aprendendo a linguagem Rust
[topo](#tutorial_near_rust)

No meu ponto de vista, aprender a linguagem rust é semelhante a idéia de domar um dragão em um mundo de fantasia. É demorado, é dificil, existem muitas alternativas diferentes e mais simples do que essa. Mas, se conseguir, você vai ter um terrível dragão ao seu lado.

Existem estudos que destacaram que o tempo para escrever uma certa quantidade de linhas de código em linguagens de baixo nível (como c) é até 30 vezes mais devagar do que as de alto nível (como python e javascript). Pela minha prática, é mais demorado ainda para uma pessoa aprendendo Rust escrever código do que c. 

Mas, com prática, ficamos mais ágeis em tudo. Com o tempo acostumamos com o que o compilador precisa e espera de nós. Podemos também configurar snippets para gerar códigos de "boilerplate" (forma) automaticamente. Então, é apenas uma questão de entendimento, memorização e paciência para o desenvolvedor. Houveram vezes em que eu escrevi 800 linhas de código Rust em 2 dias.

Quase sempre teremos que dar pausas para estudar o nosso método e garantir que estamos fazendo as decisões corretas. Porém, cada tentativa seguinte será mais fácil que a anterior.

---

## Comparações com javascript e Python

[topo](#tutorial_near_rust)

Porém uma pessoa astuta perguntaria "Porque eu iria aprender uma linguagem dessas se eu ja posso resolver os mesmos problemas com as linguagens que sei?" . É uma ótima pergunta, se eu ja posso conseguir o resultado escrevendo algumas linhas de código em python no terminal, porque eu iria querer aprender Rust?

Facilidade de uso e resolução de problemas. Este é o foco principal dessas linguagens. Como conseguir a solução para o nosso problema da forma mais simples possivel. Os processadores ficavam cada vez mais rápido cada geração, então bastava comprar as gerações de hardware mais recentes.

Porém a lei de Moore não se aplica mais. Os desenvolvedores estão precisando de algoritmos mais eficientes. Esta necessidade nos faz olhar para nossas linhas de código e perguntar "O que está instrução está fazendo exatamente?"

Quando escrevemos uma instrução em python "a = 3". A máquina virtual python está criando um objeto numero, criando um ponteiro mutex que aponta para o numero, e associando "a" a este ponteiro. Por isso que python normalmente é limitado a um core do processador. Quando tentamos aproveitar mais a capacidade de processamento de nossa máquina, a complexidade de código em javascript e python cresce exponencialmente.

O foco da linguagem Rust não é o resultado final dessa execução. E sim, o caminho que o processador e memória levam até alcançar este resultado. Um(a) desenvolvedor(a) rust experiente sabe olhar um bloco de código e dizer:
 - "Essa memória vai ser liberada nessa linha de código";
 - "O processador irá pedir pra liberar um espaço de memória nessa linha e criar uma cópia dessa variável aqui.";
 - "Essa função irá pegar esse endereço emprestado, usar este valor nessa parte, e retornar o endereço para o dono ao fim.";

---

## Instalação

[topo](#tutorial_near_rust)

Antes de começarmos, devemos realizar os seguintes passos:

 - Instalar [near-cli](https://github.com/On0n0k1/Tutorial_NEAR_Rust/blob/main/PT-BR/static/tutorials/setup-nearcli.md) para interagir com a plataforma NEAR.
 - Instalar [rust](https://github.com/On0n0k1/Tutorial_NEAR_Rust/blob/main/PT-BR/static/tutorials/rust.md) para compilar e testar os projetos.

---

## Lições

[topo](#tutorial_near_rust)

 - [Lição 1: Contratos](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/PT-BR/lesson_1_contract)
 - [Lição 2: Ownership](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/PT-BR/lesson_2_ownership)
 - [Lição 3: Structs](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/PT-BR/lesson_3_structs)
 - [Lição 4: Módulos](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/PT-BR/lesson_4_modules)
 - [Licão 5: Usando Macros](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/PT-BR/lesson_5_macro_usage)
 - [Lição 6: Enums](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/PT-BR/lesson_6_enums)
 - Lição 7: Traits
 - Lição 8: Coleções

'''
'''--- PT-BR/lesson_1_contract/Cargo.toml ---
[package]
name = "lesson_1_contract"
version = "0.1.0"
license = "MIT"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- PT-BR/lesson_1_contract/Readme.md ---
# Lição 1: Contrato

[voltar](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/PT-BR/)

Veja também:
 - Usos da [ferramenta cargo](https://github.com/On0n0k1/Tutorial_NEAR_Rust/blob/main/PT-BR/static/tutorials/cargo.md).
 - Usos da [ferramenta near-cli](https://github.com/On0n0k1/Tutorial_NEAR_Rust/blob/main/PT-BR/static/tutorials/nearcli.md).

---

## Tópicos
 - [Estrutura de um contrato NEAR](#estrutura-de-um-contrato-near)
 - [Importar Dependências](#importar-depend%C3%AAncias)
 - [Macro de Alocação](#macro-de-aloca%C3%A7%C3%A3o)
 - [Declaração de Contrato](#declara%C3%A7%C3%A3o-de-contrato)
 - [Declaração de API do Contrato](#declara%C3%A7%C3%A3o-de-api-do-contrato)
 - [Testes de Unidade](#testes-de-unidade)

---

## Estrutura de um contrato NEAR
[topo](#li%C3%A7%C3%A3o-1-contrato)

Um contrato NEAR na linguagem Rust pode ser resumido aos seguintes passos:
 - Importar crates, módulos e outras dependências necessárias.
 - Macro de alocação.
 - Declaração de contrato.
 - Declaração de api do contrato.
 - Testes de unidade.

O desenvolvedor é livre para adicionar o que julgar necessário ao projeto. Os passos acima são apenas para acelerar a memorização.

---

### Importar Dependências
[topo](#li%C3%A7%C3%A3o-1-contrato)

Isto é explicado em detalhes na "lição 4 - módulos". Só precisamos saber sobre as diferenças entre mod e use. Por exemplo:

```rust
use near_sdk::near_bindgen;
```

Acessa a crate near_sdk e inclui o macro near_bindgen neste namespace. Sem isso, precisariamos escrever "near_sdk::near_bindgen" todas as vezes que precisarmos deste elemento. Mas agora podemos simplesmente escrever "near_bindgen".

Por outro lado, a instrução:

```rust
mod outro_modulo;
```

Significa que existe um arquivo de nome "outro_modulo.rs" ou um diretório com o nome "outro_modulo" no mesmo diretório deste arquivo rust. Para mais detalhes, procure por lesson_4_modules.

Se houvesse pub antes da instrução, como os exemplos:

```rust
pub mod outro_modulo;
```

Ou:

```rust
mod outro_modulo;

pub use outro_modulo::alguma_dependencia;
```

Demonstram que "outro_modulo" e "alguma_dependencia" podem ser importados por um outro módulo ou crate (projeto rust) externos. 

Para mais detalhes, procure por lesson_4_modules. Importar e exportar módulos é uma característica da linguagem Rust. Não tem nenhum efeito direto na plataforma NEAR.

Agora, referindo ao contrato:

```rust
use near_sdk::{
    borsh::{
        self,
        BorshDeserialize,
        BorshSerialize,
    },
    near_bindgen,
};
```

Estamos acessando a crate "near_sdk" declarado em "Cargo.toml". Importando self, BorshDeserialize e BorshSerialize no módulo borsh. E importando near_bindgen. Seguem as descrições simplificadas:

 - **self**: Nem eu sei exatamente o que isso faz, mas é necessário para BorshDeserialize e BorshSerialize funcionarem corretamente.
 - **BorshDeserialize**: Quando chamamos uma função do nosso contrato, devemos enviar parâmetros. Mesmo que estes parâmetros sejam um json vazio, este deve ser deserializado. Este é o objetivo de BorshDeserialize, recebe um json em texto, transforma nos tipos que precisamos.
 - **BorshSerialize**: Caminho inverso do BorshDeserialize. Quando vamos retornar um resultado para o usuário, devemos transformar aquele valor para um json em texto.
 - **near_bindgen**: Isso é um marcador para um struct que diz **"Este é o contrato principal do nosso projeto"**. Damos o nome "Contract" apenas para facilitar o entendimento, não é obrigatório. Porém deve-se ter pelo menos um struct com **near_bindgen** em cada contrato.

---

### Macro de alocação
[topo](#li%C3%A7%C3%A3o-1-contrato)

```rust
near_sdk::setup_alloc!();
```

Macros parecem com funções. Mas são executadas antes da compilação. São ferramentas para gerar código de acordo com os parâmetros. Macros não existem no runtime do programa.

Neste caso, "setup_alloc" gera o código "boilerplate" (forma) para o funcionamento do nosso contrato. Só deve ser executado uma vez, antes da declaração do contrato.

Aviso: Nas próximas versões esta instrução será deprecada. Não será necessário usar mais.

---

### Declaração de contrato
[topo](#li%C3%A7%C3%A3o-1-contrato)

```rust
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Contract{
    counter: i32,
}
```

Será mais fácil descrever de dentro para fora.
 - **counter**: é um número. i32 quer dizer que é "signed", pode ser positivo ou negativo. 32 quer dizer que é um número de 32 bits.
 - **pub struct Contract**: é a declaração de um struct de nome Contract. "pub" quer dizer que este struct é público.
 - **#[derive(BorshDeserialize, BorshSerialize)]**: Simplificando, aplica as traits BorshDeserialize e BorshSerialize neste struct. Descritos acima.
 - **[near_bindgen]**: É um marcador que diz "Este é o Contrato". As funções deste struct são as funções do contrato. Quando executamos uma função do contrato, executamos uma função deste struct.

Logo a seguir temos também:

```rust
impl Default for Contract{
    fn default() -> Self{
        Contract { counter: 0 }
    }
}
```

Default é uma trait (característica) de "padrão". É praticamente um construtor sem parâmetros para o nosso struct. Mas, Default é uma trait padronizada da linguagem Rust. near_sdk usa essa trait no funcionamento do nosso contrato. Então precisamos aplicar ao nosso contrato, senão teremos um erro de compilação.

default é uma função da trait Default que retorna um struct do mesmo tipo Self. Self nesta declaração é o mesmo que Contract. A função retorna uma instância de Contract com o valor de counter igual a 0.

Se implementarmos este contrato em uma conta NEAR, e depois executarmos uma primeira função que não seja de inicialização. A máquina irá inicializar o contrato com  default antes de executar nossa função.

---

### Declaração de API do contrato
[topo](#li%C3%A7%C3%A3o-1-contrato)

A seguir se encontram as funções do smart contract.

```rust
#[near_bindgen]
impl Contract{

    pub fn get(&self) -> i32 {
        self.counter
    }

    pub fn increment(&mut self) -> i32 {
        self.counter += 1;
        self.counter
    }

    pub fn decrement(&mut self) -> i32 {
        self.counter -= 1;
        self.counter
    }
}
```

 - ```#[near_bindgen]``` é um marcador que diz "estas são as funções do contrato".
 - ```impl Contract``` é onde declaramos as funções e métodos associados ao struct Contract.
 - ```&self``` e ```&mut self``` são descritos na lição seguinte. Só precisamos saber que esse tipo de função é invocada no formato ```nome_do_struct.nome_da_funcao```, self neste caso se refere a instância existente deste struct.
 - ```-> i32``` significa que a função retorna um inteiro i32.
 - No fim da função temos uma linha ```self.counter``` sem ponto-virgula ";". Isso é o mesmo que ```return self.counter```.

Com estes detalhes, vemos que a função ```get``` retorna o valor atual de counter armazenado no struct do contrato. ```increment``` incrementa o valor de counter em 1. ```decrement``` reduz o valor de counter em 1.

---

### Testes de unidade
[topo](#li%C3%A7%C3%A3o-1-contrato)

Descrito com mais detalhes na lição 4 - módulos, não é necessário ter todos os testes do projeto aqui. Podemos incluir testes no fim de cada módulo rust. Podemos também criar um diretório ```tests```. Todos os arquivos ".rs" na pasta ```tests``` será considerado um módulo de testes.

```rust
#[cfg(test)]
mod tests{
```

```mod tests``` é simplesmente um módulo local com nome tests. Nada de especial.

```#[cfg(test)]``` este é bem interessante. ```cfg``` é uma instrução que diz ao compilador "Compile o módulo abaixo de mim apenas se a condição entre parenteses for verdadeira.". ```(test)``` é verdadeiro quando executamos ```cargo test```. Se não estivermos realizando testes de unidade, este módulo não existe.

Se em vez de ```#[cfg(test)]``` tivéssemos:

```rust
#[cfg(not(test))]
mod another_module{
```

Teriamos a situação oposta, este módulo não seria compilado durante testes de unidade.

```rust
use super::*;
use near_sdk::{
    AccountId,
    env,
    MockedBlockchain,
    testing_env,
    test_utils::VMContextBuilder,
    json_types::ValidAccountId,
};
```
Acima importamos as dependências usadas nos testes abaixo.

```rust
fn env_setup(){
    let mut builder: VMContextBuilder = VMContextBuilder::new();
    let account_id: AccountId = String::from("stiltztinkerstein");

    builder.current_account_id(
        ValidAccountId::try_from(
            account_id.clone()
        ).unwrap()
    );

    testing_env!(builder.build());

    assert_eq!(
        env::current_account_id(),
        account_id, 
        "Erro assert.\n env: {}\naccount: {}\n", 
        env::current_account_id(), 
        &account_id,
    );
}
```

Antes de cada teste, precisamos iniciar uma simulação do ambiente de blockchain. Uma das formas de fazer isso é utilizando ```VMContextBuilder```. Basta criar uma instância desse tipo, alterar os atributos que queremos, e usar o builder como argumento para o macro ```testing_env```.

Para não termos que escrever estas linhas em cada teste, criamos uma função para ser usada.

```assert_eq``` não é necessário. Só mostra que o atributo de ambiente ```env::current_account_id``` é o mesmo id de conta que escolhi para o builder.

A seguir teremos os três testes: 

```rust
#[test]
pub fn get() {
    env_setup();

    let contract: Contract = Contract::default();
    
    assert_eq!(
        contract.get(),
        0
    );
}

#[test]
pub fn increment() {
    env_setup();

    let mut contract: Contract = Contract::default();

    contract.increment();

    assert_eq!(
        contract.get(),
        1
    );
}

#[test]
pub fn decrement() {
    env_setup();

    let mut contract: Contract = Contract::default();

    contract.decrement();

    assert_eq!(
        contract.get(),
        -1
    );
}
```

Percebe-se um padrão em cada um dos testes:
 - Inicializar o ambiente;
 - Inicializar o contrato;
 - Executar a função que queremos testar;
 - Confirmar que a função deu o resultado que esperamos;

A função ```get``` foi testada primeiro. Isto porque esta será usada nos testes seguidos. Se esta função não funcionasse da forma que esperassemos, temos que ver este erro primeiro na lista. Bom para evitar confusões nos testes. 

A [próxima lição](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/PT-BR/lesson_2_ownership) será sobre ownership.

'''
'''--- PT-BR/lesson_1_contract/src/lib.rs ---
//! Fonte <https://github.com/near-examples/rust-counter>
//! 
//! 
//! 

// Dicas sobre documentação:
// comentarios com // não aparecem na documentação.
// comentarios com /// aparecem como descrição para o que estiver a seguir (mod, fn, struct, enum, trait...)
// comentarios com //! podem apenas existir no inicio do arquivo, representam a descrição de todo o módulo.

// módulos importados
use near_sdk::{
    // Parâmetros recebidos e valores retornados são convertidos para json com esse módulo
    borsh::{
        self,
        BorshDeserialize,
        BorshSerialize,
    },
    // env,
    // Cria o boilerplate necessário para máquinas virtuais NEAR
    near_bindgen,
};

near_sdk::setup_alloc!();

/// Contrato. Este struct contém o estado (state) da máquina virtual.
/// As funções deste struct são as funções do contrato.
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Contract{
    /// Contador.
    counter: i32
}

// Default é executado quando o contrato não inicializado manualmente.
impl Default for Contract{
    fn default() -> Self{
        Contract { counter: 0 }
    }
}

#[near_bindgen]
impl Contract{

    /// Retorna o contador.
    pub fn get(&self) -> i32 {
        // return self.counter;
        self.counter
    }

    /// Incrementa o contador em 1.
    pub fn increment(&mut self) -> i32 {
        self.counter += 1;
        self.counter
    }

    /// Decrementa o contador em 1.
    pub fn decrement(&mut self) -> i32 {
        self.counter -= 1;
        self.counter
    }
}

// Nossos testes de unidade ficam aqui.
// cfg(test) quer dizer que esse mod só será compilado em ambientes de teste.
#[cfg(test)]
mod tests{
    // super::* importa todos os módulos acima.
    use super::*;
    // alguns módulos que só usaremos em situações de teste
    use near_sdk::{
        // um id de conta como por exemplo "stiltztinkerstein.near"
        AccountId,
        // possui métodos relacionados ao ambiente de execução.
        // por exemplo, se quisermos saber o nome do usuário que executou
        // esse contrato, usaremos uma função no módulo env.
        env,
        // Simula o blockchain
        MockedBlockchain,
        // Macro que inicializa o ambiente de text com o contexto informado.
        testing_env,
        // Usado para criar um contexto de teste.
        test_utils::VMContextBuilder,
        // Simplesmente representa um Id de Conta valido.
        // Um id de conta é um string, mas não é todo string que é um id válido.
        json_types::ValidAccountId,
    };

    /// Essa função não é um teste. É usada pelos testes para simular
    /// um ambiente de teste.
    fn env_setup(){
        // inicializa um construtor de contexto de teste.
        let mut builder: VMContextBuilder = VMContextBuilder::new();

        // atributos que podem ser editados com o builder:
        // current_account_id
        // signer_account_id
        // signer_account_pk
        // precessor_account_id
        // block_index
        // block_timestamp
        // epoch_height
        // account_balance
        // account_locked_balance
        // storage_usage
        // attached_deposit
        // prepaid_gas
        // random_seed
        // is_view

        // string com nome account_id
        let account_id: AccountId = String::from("stiltztinkerstein");

        builder.current_account_id(
            // try_from tenta converter o string acima para um id valido
            // panic se o id é invalido.
            ValidAccountId::try_from(
                account_id.clone()
            ).unwrap()
        );

        // inicializa simulação
        testing_env!(builder.build());

        // Se os dois primeiros parametros não são iguais, 
        // retorna a mensagem de erro seguinte.
        assert_eq!(
            env::current_account_id(),
            account_id, 
            "Erro assert.\n env: {}\naccount: {}\n", 
            env::current_account_id(), 
            &account_id,
        );
    }

    /// Como tem o marcador #[test] vai executar automaticamente
    /// quando realizarmos testes de unidade.
    #[test]
    pub fn get() {
        env_setup();

        let contract: Contract = Contract::default();
        
        assert_eq!(
            contract.get(),
            0
        );
    }

    #[test]
    pub fn increment() {
        env_setup();

        let mut contract: Contract = Contract::default();

        contract.increment();

        assert_eq!(
            contract.get(),
            1
        );
    }

    #[test]
    pub fn decrement() {
        env_setup();

        let mut contract: Contract = Contract::default();

        contract.decrement();

        assert_eq!(
            contract.get(),
            -1
        );
    }
}

'''
'''--- PT-BR/lesson_2_ownership/Cargo.toml ---
[package]
name = "lesson_2_ownership"
version = "0.1.0"
authors = ["Lucas Lemos <stiltztinkerstein@gmail.com>"]
license = "MIT"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- PT-BR/lesson_2_ownership/Readme.md ---
# Lição 2: Ownership

[voltar](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/PT-BR/)

Este curto tutorial possui o objetivo de explicar sobre ownership.

---

## Funções de Contrato

```rust
/// Retorna o comprimento da String armazenada
pub fn get_length(&self) -> u32;

/// Retorna o comprimento da String e altera o nome armazenado para "Changed name"
pub fn get_length_again(&mut self) -> u32;
```

---

## Hipótese

Ownership é explicado na seção seguinte. Esta discute o problema que ownership soluciona.

Consideremos a instrução exemplo a seguir:

```
A = B;
```

Sabemos que A é igual a B. A recebe o valor de B. Mas o que está acontecendo? 

Estamos criando uma cópia do valor de B e associando A a este valor? Criar uma cópia significa requisitar alocação de memória, adiquirir o endereço da memória e igualar o valor desse endereço ao valor de B. Para um número inteiro isso parece simples, mas e se fosse uma string de 2 mil caracteres?

E se usarmos uma variável como parâmetro de função. Estariamos criando uma cópia da variável e depois apagando a cópia no fim da função?

Percebe-se que precisamos de uma forma de reutilizar o mesmo endereço de memória em várias partes diferentes do programa. A linguagem C solucionou isso através do uso de ponteiros. Em vez de armazenarmos o valor da variável, nós armazenamos o endereço de memória daquele tipo de variável.

Mas isso nos trás outro problema. Se uma função tem acesso ao endereço de memória de uma variável importante, essa função agora tem muito poder. E se o método foi implementado de uma forma insegura? Um hacker poderia aproveitar essa falha de segurança para acessar um sistema.

 - Precisamos de uma forma de reutilizar memória para evitar sobrecarregar o sistema com operações desnecessárias.
 - Mas precisamos evitar que esse uso de memória dê mais poder as instruções do que é necessário.

**Extra:** Ponteiros existem em Rust também. Mas existem vários tipos de ponteiros, com diferentes vantagens e desvantagens. Ponteiros semelhantes à linguagem C podem ser utilizados também, mas os blocos que os utilizam precisam ser marcados como "unsafe" ([Mais Informações](https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html)).

---

## Ownership

A instrução a seguir:

```
A = B;
```

Pode agir de duas formas diferentes:
 - Se **B** implementa a trait Copy, irá criar uma cópia automaticamente.
 - Se **B** não implementa Copy, **A** será dona de **B** agora. O compilador não deixará realizarmos instruções com **B**, porque o valor de **B** foi "movido" para **A**.

Dos tipos primitivos: 
 - Números (```u32```, ```f32```, ```i32```, ...) implementam ```Copy``` e ```Clone```. 
 - String implementa ```Clone```, mas não implementa ```Copy```. 

Em outras palavras, para criarmos uma cópia de um String, precisamos fazer isso manualmente.

Ownership garante que apenas uma variável é dona ("owns") de um endereço de váriável. Essa possessão pode ser transferida. Mas para compartilharmos uma variável, usamos ponteiros ou referências.

---

## Referências

Referências, ou empréstimos ("borrows") são uma forma de compartilhar um endereço de memória com permissões limitadas. As referências podem ser mutáveis ou imutáveis. São escritas, respectivamente, da seguinte forma:

```rust
let a = 10; // Criando uma variável com valor 10
let b = &a; // Criando uma variável que é uma referência à variavel a
```

```rust
let mut a = 10; // Criando uma variável mutável com valor 10
let b = &mut a; // Criando uma variável que é uma referência mutável à variavel a
```

Variáveis são, por padrão, imutáveis, constantes. Por isso declarei ```a``` mutavel no segundo exemplo.

 - Referências imutáveis permitem acessar o valor, mas não permitem alterá-lo.
 - Referências mutáveis permitem acessar o valor e permitem alterá-lo.

Algumas regras a considerar:
 - Não se pode alterar a variável original enquanto uma referência ainda existe.
 - Várias referências imutáveis podem existir.
 - Só uma referência mutável pode existir.
 - Não podem existir referências imutáveis se uma referência mutável existe.

Quando criamos uma referência, digamos que a variável dona está "emprestando" ("borrow") para a outra. A linha em que o empréstimo é utilizado por ultimo é a linha em que o empréstimo é devolvido.

---

## Importante

Não retorne referências. Retornar referências é possivel, mas é preciso marcar o tempo-de-vida (lifetime) do valor retornado. Não recomendamos estudar isso enquanto está aprendendo a linguagem rust. Todo o conceito de lifetimes pode ser evitado simplesmente retornando cópias quando necessário. Para os interessados, referências [aqui](https://doc.rust-lang.org/rust-by-example/scope/lifetime.html).

Lifetimes são um conceito bem poderoso quando usado corretamente. As ferramentas serde e borsh usam isso para converter texto json para o tipo que precisamos com zero cópia. Ou seja, existe alocação de memória para o String json, para o tipo que precisamos, e nada mais. O processador não precisa esperar alocação de memória, ou seja, muito rápido.

---

## Exemplos

Para o contrato descrito a seguir:

```rust
#[near_bindgen]
#[derive(Clone, BorshDeserialize, BorshSerialize)]
pub struct Contract {
    name: String,
}

impl Default for Contract{
    fn default() -> Self {
        return Contract {
            name: String::from("A default string"),
        };
    }
}
```

Temos os exemplos a seguir:

```rust
fn this_takes_a_reference(name: &str) -> usize { 
        return name.len();
    }

fn this_takes_the_ownership(name: String) -> usize {
    name.len()
}

pub fn get_length(&self) -> u32 {
    let length_reference: usize = Self::this_takes_a_reference(&self.name);
    let length_ownership: usize = Self::this_takes_the_ownership(self.name.clone());

    assert_eq!(
        length_reference, 
        length_ownership, 
        "Ambos tamanhos não são o mesmo {} e {}", length_reference, length_ownership,
    );

    length_reference as u32
}

pub fn get_length_again(&mut self) -> u32 {
    let a_reference: &String = &self.name;
    let _another_reference: &String = &self.name;
    let _yet_another_reference: &String = &self.name;
    let length = Self::this_takes_a_reference(a_reference);
    self.name = String::from("Changed name");

    length as u32
}
```

Antes de iniciarmos com os detalhes falaremos sobre String e &str.

---

### O que é String

Uma String é uma variável que possui dono. Armazena um "string" e irá ser liberado da memória quando a variável ser liberada. Mas "Um texto entre aspas como este não é um String, é um &str". Uma referência a um String é um &String ou &mut String.

---

### O que é &str

Isso é um tipo criado para simplificar o uso de Strings em nosso código. Age como uma referência imutável à um String. Mas este será alocado pelo compilador, e o compilador decide como melhor otimizá-lo na memória.

---

### Strings em Funções

Consideraremos as duas variáveis abaixo para o exemplo:

```rust
let variavel: String = String::from("Uma Variavel");
let referencia: &str = "Uma Variavel";
```

A função abaixo recebe um &str e retorna o comprimento da string. O empréstimo é devolvido no fim da função.

```rust
fn this_takes_a_reference(name: &str) -> usize { 
    return name.len();
}
```

Para utilizar a função com os parâmetros:

```rust
this_takes_a_reference(&variavel);
this_takes_a_reference(referencia);
```

A função abaixo recebe um String como parâmetro e retorna o comprimento. A função se torna dona do endereço de memória e o deleta no fim.

```rust
fn this_takes_the_ownership(name: String) -> usize {
    name.len()
}
```

Para utilizar a função com os parâmetros:

```rust
this_takes_the_ownership(variavel);
this_takes_the_ownership(String::from(referencia));
```

Precisamos de transformar o &str em um String antes de usar como parâmetro. A função adiquiriu ownership quando não precisava também.

Ambas as funções ```this_takes_a_reference``` e ```this_takes_the_ownership``` fazem a mesma coisa, não causam erros, e retornam o mesmo resultado. Mas a primeira é bem mais eficiente do que a segunda.

Por isso, é boa prática usar ```&str``` em vez de ```String``` nas declarações de função.

Eu lamento ter que adicionar mais um detalhe nessa explicação, mas funções de contrato, aquelas em que precisamos de marcar com ```#[near_bindgen]``` precisam de receber String como parâmetro. Isso é porque as traits de deserialização são implementadas para String, mas não são implementadas para referências de string.

A função:

```rust
pub fn get_length(&self) -> u32 {
    let length_reference: usize = Self::this_takes_a_reference(&self.name);
    let length_ownership: usize = Self::this_takes_the_ownership(self.name.clone());

    assert_eq!(
        length_reference, 
        length_ownership, 
        "Ambos tamanhos não são o mesmo {} e {}", length_reference, length_ownership,
    );
}
```

Chama ```this_takes_a_reference``` e ```this_takes_the_ownership```, garantindo que ambas retornam o mesmo valor antes de retorná-lo. Como ```this_takes_the_ownership``` não pega o valor emprestado, criamos uma cópia para ser usada como necessário.

A função:

```rust
pub fn get_length_again(&mut self) -> u32 {
    let a_reference: &String = &self.name;
    let _another_reference: &String = &self.name;
    let _yet_another_reference: &String = &self.name;
    let length = Self::this_takes_a_reference(a_reference);
    self.name = String::from("Changed name");

    length as u32
}
```

Simplesmente chama ```this_takes_a_reference``` e altera o "nome" armazenado no contrato. Este exemplo mostra que podem haver várias referências para uma variável. Faça as alterações recomendadas nos comentários para ver as reações do compilador.

A [próxima Lição](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/PT-BR/lesson_3_structs) será sobre structs.

'''
'''--- PT-BR/lesson_2_ownership/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
#[allow(unused_imports)]
use near_sdk::{env, near_bindgen};

// Macro que gera codigo boilerplate para o projeto. Vai ser deprecado nas proximas versões.
near_sdk::setup_alloc!();

#[near_bindgen]
#[derive(Clone, BorshDeserialize, BorshSerialize)]
pub struct Contract {
    name: String,
}

impl Default for Contract{
    fn default() -> Self {
        // Inicializar com a String "A default string" como exemplo
        return Contract {
            name: String::from("A default string"),
        };
    }
}

#[near_bindgen]
impl Contract{
    // &str é uma referencia para uma string
    // strings entre aspas " " são 'static &str
    // então ter &str como parâmetro permite ter tanto &String como "uma string estatica como essa"
    /// Retorna o tamanho da string.
    fn this_takes_a_reference(name: &str) -> usize { 
        return name.len();
    }

    // Essa função faz o mesmo que o de cima, mas recebe uma String como parâmetro.
    // Teriamos que converter para uma String dessa forma: String::from("essa")
    /// Retorna o tamanho da string.
    fn this_takes_the_ownership(name: String) -> usize {
        // retorna usize, usize é u32 em sistemas 32 bit, u64 em sistemas 64 bit
        name.len()
    }

    /// Retorna o tamanho da string armazenada.
    pub fn get_length(&self) -> u32 {
        // Irá chamar ambos os métodos para mostrar que ambos fazem a mesma coisa.
        //
        // Adicionando & antes de cada parametro é o mesmo que dizer:
        // "Estou dando permissão para esta função olhar o valor dessa variável, mas não estou dando permissão para modificá-lo".
        let length_reference: usize = Self::this_takes_a_reference(&self.name);

        // this_takes_the_ownership quer ter possessão de uma String, então precisamos criar uma cópia para essa.
        let length_ownership: usize = Self::this_takes_the_ownership(self.name.clone());

        // Chamando assert_eq para provar que ambas são iguais.
        // Se os valores são diferentes, o código entra em pânico.
        assert_eq!(
            // primeiro parâmetro para comparar
            length_reference, 
            // segundo parâmetro para comparar
            length_ownership, 
            // Se ambas não são iguais, entra em pânico com a mensagem de erro abaixo
            "Ambos tamanhos não são o mesmo {} e {}", length_reference, length_ownership,
        );

        // Converter para u32 porque é um formato simples para json
        // tipos podem ser convertidos usando as traits "into" e "from" também
        length_reference as u32
    }

    /// Retorna o tamanho da String armazenada. Também muda o nome para "Changed name"
    pub fn get_length_again(&mut self) -> u32 {
        // podemos declarar variaveis que armazenam referencias para um outro valor.
        let a_reference: &String = &self.name;
        let _another_reference: &String = &self.name;
        let _yet_another_reference: &String = &self.name;

        // Podemos ter varias referências imutaveis ao mesmo tempo.
        // Mas não podemos alterar uma variavel enquanto referências imutáveis existirem.
        // Se precisarmos tirar uma referência mutavel, não devem haver referências imutaveis existindo.

        // Descomente a linha adiante para receber um erro devido a referências existentes.
        // self.name = String::from("Changed name");

        let length = Self::this_takes_a_reference(a_reference);

        // A linha adiante é ok porém, porque as referências acima não são usadas novamente.
        // Como não são usadas novamente, o compilador sabe que pode liberá-las da memória.
        self.name = String::from("Changed name");

        length as u32
    }
}

#[cfg(test)]
mod tests{
    use super::*;
    use near_sdk::{
        AccountId,
        env,
        MockedBlockchain,
        testing_env,
        test_utils::VMContextBuilder,
        json_types::ValidAccountId,
    };

    fn env_setup(){
        let mut builder: VMContextBuilder = VMContextBuilder::new();

        // atributos que podemos modificar com o builder
        // current_account_id
        // signer_account_id
        // signer_account_pk
        // precessor_account_id
        // block_index
        // block_timestamp
        // epoch_height
        // account_balance
        // account_locked_balance
        // storage_usage
        // attached_deposit
        // prepaid_gas
        // random_seed
        // is_view

        let account_id: AccountId = String::from("stiltztinkerstein");

        builder.current_account_id(
            ValidAccountId::try_from(
                account_id.clone()
            ).unwrap()
        );

        testing_env!(builder.build());

        assert_eq!(
            env::current_account_id(),
            account_id, 
            "Erro assert. env: {} account: {}", 
            env::current_account_id(), 
            &account_id,
        );
    }

    #[test]
    pub fn get_length() {
        env_setup();
    
        let mut contract: Contract = Contract::default();
    
        // Ambas funções fazem a mesma coisa, então ambas devem retornar o mesmo valor.
        assert_eq!(
            contract.get_length(),
            contract.get_length_again()
        );

        // get_length_again também modifica a string armazenada.
        assert_eq!(
            contract.name,
            "Changed name"
        );
    }
}
'''
'''--- PT-BR/lesson_3_structs/Cargo.toml ---
[package]
name = "lesson_3_structs"
version = "0.1.0"
authors = ["Lucas Lemos <stiltztinkerstein@gmail.com>"]
license = "MIT"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- PT-BR/lesson_3_structs/Readme.md ---
# Lição 3 - Structs

[voltar](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/PT-BR/)

Esta lição discute sobre o formato de structs e como ownership é usada nos métodos.

---

## Tópicos

 - [Descrição](#descri%C3%A7%C3%A3o)
 - [Funções de Contrato](#fun%C3%A7%C3%B5es-de-contrato)
 - [Projeto](#projeto)
   - [Estrutura de Contrato](#estrutura-de-contrato)
   - [Trait Clone](#trait-clone)
   - [just_a_function](#just_a_function)
   - [macros](#macros)
   - [take_ownership](#take_ownership)

---

## Descrição
[voltar](#li%C3%A7%C3%A3o-3---structs)

Structs são um pouco semelhantes a classes em algumas linguagens orientadas a objetos. A diferença é que ```structs``` não podem herdar outros ```structs```, só podem implementar ```traits```.

Aprofundaremos o conceito de traits em uma lição adiante. Mas considere traits como um conjunto de funções representando uma característica que vários tipos diferentes podem implementar. A trait ```Clone``` permite usar o método ```.clone()``` para criar uma cópia do elemento. A trait ```BorshDeserialize``` permite tentar construir uma instância do tipo utilizando um string no formato json.

Mais adiante aprenderemos a criar funções que aplicam a qualquer tipo de variável que implementa uma trait especifica. Porém, essa lição será apenas sobre structs.

---

## Funções de Contrato
[voltar](#li%C3%A7%C3%A3o-3---structs)

```rust
// gets e sets
pub fn get_a_string(&self) -> String;

pub fn get_a_floating(&self) -> f32;

pub fn get_another_integer(&self) -> i32;

pub fn get_an_integer(&self) -> u32;

pub fn set_a_string(&mut self, a_string_arg: String);

pub fn set_a_floating(&mut self, a_floating: f32);

pub fn set_an_integer(&mut self, an_integer: u32);

pub fn set_another_integer(&mut self, another_integer: i32);

// Uma função que não altera nem acessa o estado do contrato
pub fn just_a_function();

// Uma função StructExample que toma ownership de si mesmo, se deletando no final.
pub fn take_ownership(&self) -> u32;
```

Cheque a implementação para mais detalhes.

---

## Projeto

[voltar](#li%C3%A7%C3%A3o-3---structs)

Criamos um tipo de nome ```StructExample```.

```rust
pub struct StructExample{
    an_integer: u32,
    another_integer: i32,
    a_floating: f32,
    a_string: String,
}
```
O tipo possui os seguintes valores internos:
 - an_integer: um inteiro positivo de 32 bits;
 - another_integer: um inteiro positivo ou negativo de 32 bits;
 - a_floating: um número real de 32 bits;
 - a_string: um string, descrito na lição anterior;

Em muitas linguagens teriamos que escrever algo como ```long int``` para i32, ```long long int``` para i64. Em rust e assemblyscript, simplesmente usamos i para "signed" (positivo e negativo) e u para "unsigned" (positivo). u8, u16, u32, u64 e u128 são todos tipos válidos de inteiros "unsigned".

---

### Estrutura de Contrato

[voltar](#li%C3%A7%C3%A3o-3---structs)

O contrato possui a seguinte estrutura:

```rust
#[derive(BorshDeserialize, BorshSerialize, Default)]
pub struct Contract {
    struct_example: StructExample,
}
```

Este exemplo de contrato deriva a trait ```Default``` em vez de implementar manualmente. Essa forma de implementar executa o método ```.default()``` para todos os valores internos. Devido a isso, o tipo ```struct_example``` deve implementar ```Default``` também.

```rust
impl Default for StructExample{
    fn default() -> Self {
        let an_integer: u32 = 1;
        let a_floating: f32 = 0.5;

        StructExample {
            an_integer,
            another_integer: -1,
            a_floating,
            a_string: String::from("A default string"),
        }
    }
}
```

Escolhemos alguns valores aleatórios para servir de exemplo. Vemos que não é necessário escrever algo como ```an_integer: an_integer``` ou ```a_floating: a_floating``` quando os nomes são iguais.

---

### Trait Clone

[voltar](#li%C3%A7%C3%A3o-3---structs)

Implementamos a trait Clone para o tipo:

```rust
impl Clone for StructExample{
    // self é uma instancia de StructExample, Self (Letra maiúscula) é o tipo StructExample.
    fn clone(&self) -> Self {
        let an_integer: u32 = self.get_an_integer();
        let another_integer: i32 = self.get_another_integer();
        let a_floating: f32 = self.get_a_floating();
        let a_string: String = self.get_a_string();

        // Self e StructExample são a mesma coisa (Em qualquer impl de StructExample)
        Self {
            an_integer,
            another_integer,
            a_floating,
            a_string,
        }
    }
}
```

**Vale relembrar que estou intencionalmente escrevendo o código de forma mais complexa apenas para demonstrar as diversas liberdades que temos na implementação de nossos projetos.**

Não há muito o que adicionar sobre as implementações dos ```get```s e ```set```s. Recomendo checar os comentários. Mas discutiremos sobre ```just_a_function``` e ```take_ownership``` a seguir:

---

### just_a_function

[voltar](#li%C3%A7%C3%A3o-3---structs)

```rust
pub fn just_a_function() {
    env::log(b"You just called this function");
    env::log(format!("1 + 1 = {}", 1 + 1).as_bytes());
}
```
Esta função imprime duas linhas de texto. 

A função ```log``` recebe uma sequência de bytes como parâmetro. Devido a isso, a primeira linha mostra que podemos incluir a letra "b" antes das aspas para tratar a string como bytes.

Na segunda instrução usamos o macro ```format!``` para formatar uma String dinamicamente. O tipo String possui um método ```.as_bytes``` que converte o tipo para bytes. Para mais detalhes sobre String, cheque os [docs oficiais](https://doc.rust-lang.org/std/string/struct.String.html#method.as_bytes).

---

### Macros
[voltar](#li%C3%A7%C3%A3o-3---structs)

Serão explicados mais adiante. Para simplificar o entendimento inicial, considere **macros** como funções que são executadas antes do código ser compilado. São funções que geram código. Só depois do **macro** gerar código que o compilador checa por erros. O uso mais comum de **macros** é para agir como funções que recebem um número variado de parâmetros.

Outra forma de vermos **macros** é: uma forma de trocar complexidade de código por praticidade de uso.

---

### take_ownership
[voltar](#li%C3%A7%C3%A3o-3---structs)

```rust
pub fn take_ownership(self) -> u32{
    env::log(b"Taking ownership of itself");

    let result = format!("an_integer is {}", self.an_integer);
    env::log(result.as_bytes());

    self.an_integer

    // self será liberado da memória aqui
}
```

Acho esse exemplo interessante. 
 - Imprime "Taking ownership of itself" na tela. 
 - Imprime o valor de ```an_integer``` no contrato. 
 - E retorna o valor de ```an_integer```.

Mas como declaramos ```self``` em vez de ```&self``` ou ```&mut self``` como argumento, o método tomará possessão (ownership) de si mesmo e se auto-destruira no fim. 

Um usuário iniciante provavelmente receberá um aviso de erro muito confuso se tentar escrever o método dessa forma. Um erro similar a "valor não pode ser usado pois um move aconteceu aqui.".

A [próxima lição](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/PT-BR/lesson_4_modules) será sobre módulos.

'''
'''--- PT-BR/lesson_3_structs/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
#[allow(unused_imports)]
use near_sdk::{env, near_bindgen};

near_sdk::setup_alloc!();

// derive usa um macro para aplicar as traits no tipo StructExample.
// Implementamos isso porque o contrato precisa de BorshDeserialize e BorshSerialize.
// StructExample é um state do Contract, então declaramos derive aqui também.
#[derive(BorshDeserialize, BorshSerialize)]
// Um struct com tipos primitivos
pub struct StructExample{
    an_integer: u32,
    another_integer: i32,
    a_floating: f32,
    a_string: String,
}

// default é executado quando o codigo é carregado ao contrato e não é inicializado.
// Pode ser chamado manualmente para criar uma instância com valores padrão.
impl Default for StructExample{
    fn default() -> Self {
        // Cada atributo do StructExample é setado da forma Nome: Valor,
        // Não é preciso setar da forma nome: nome,
        let an_integer: u32 = 1;
        let a_floating: f32 = 0.5;

        StructExample {
            an_integer,
            another_integer: -1,
            a_floating,
            a_string: String::from("A default string"),
        }
    }
}

// Clone é uma forma de criar uma copia desse struct manualmente.
impl Clone for StructExample{
    // self é uma instancia de StructExample, Self (Letra maiúscula) é o Tipo StructExample.
    fn clone(&self) -> Self {
        let an_integer: u32 = self.get_an_integer();
        let another_integer: i32 = self.get_another_integer();
        let a_floating: f32 = self.get_a_floating();
        let a_string: String = self.get_a_string();

        // Self e StructExample são a mesma coisa (Em qualquer impl de StructExample)
        Self {
            an_integer,
            another_integer,
            a_floating,
            a_string,
        }

    }
}

// Aqui que métodos e funcões para o struct são implementados.
impl StructExample{

    // &self quer dizer que irá emprestar uma instância de StructExample, mas não irá alterá-la
    /// Retorna a copia de a_string
    pub fn get_a_string(&self) -> String {

        // Strings implementam a trait Clone mas não implementam Copy
        // Copy cria uma cópia da instância automaticamente quando ha uma instrução a = b
        // Clone cria uma cópia da instância quando o código chama clone()
        let a_string: String = self.a_string.clone();

        return a_string;
    }

    pub fn get_a_floating(&self) -> f32 {
        // f32 implementa Copy, então esta linha irá automaticamente criar uma copia de a_floating
        return self.a_floating;
    }

    pub fn get_another_integer(&self) -> i32 {
        // Não precisamos escrever "return" sempre.
        // Se a expressão não termina com ponto e virgula ";" retorna a expressão
        self.another_integer
    }

    pub fn get_an_integer(&self) -> u32 {
        self.an_integer
    }

    // &mut self quer dizer que irá emprestar uma instância de StructExample e fazer modificações a este.
    pub fn set_a_string(
        &mut self, 
        // detalhe importante: como não há referência & para a String, estamos tomando possessão (ownership) desta.
        // Quer dizer que a função é dona desta parte de memória.
        // Possessão de a_string_arg quer dizer que o código que o chamou não precisará usar a String novamente.
        //
        // Este é um dos superpoderes de Rust. Podemos criar código que cria o menor número de cópias possivel.
        a_string_arg: String,
    ) {
        // como emprestamos self mutavel, podemos alterar os valores internos
        self.a_string = a_string_arg;
    }

    pub fn set_a_floating(&mut self, arg: f32) {
        self.a_floating = arg;
    }

    pub fn set_an_integer(&mut self, an_integer: u32) {
        // u32 é unsigned, apenas valores positivos
        self.an_integer = an_integer;
    }

    pub fn set_another_integer(&mut self, another_integer: i32){
        // i32 é signed, pode ser positivo e negativo. Mas apenas metade do alcance máximo.
        self.another_integer = another_integer;
    }

    // Se o método não possui self, é apenas uma função comum associada ao tipo.
    pub fn just_a_function() {
        env::log(b"You just called this function");
        env::log(format!("1 + 1 = {}", 1 + 1).as_bytes());
    }

    // Se self está nos argumentos, a função toma possessão do tipo.
    // Quer dizer que o struct será deletado no fim da função (a não ser que retornemos ela).
    // É só um exemplo. Quase nunca terá que implementar uma função dessa forma.
    pub fn take_ownership(self) -> u32{
        env::log(b"Taking ownership of itself");

        let result = format!("an_integer is {}", self.an_integer);
        env::log(result.as_bytes());

        self.an_integer

        // self será liberado da memória aqui
    }
}

// #[near_bindgen] instrui near-sdk que esta struct representa o state principal do contrato.
// Podemos usar qualquer nome. Contract é só mais facil de entender.
#[near_bindgen]
// derive usa um macro para aplicar as traits no tipo StructExample.
// Implementamos isso porque o contrato precisa de BorshDeserialize e BorshSerialize.
// BorshSerialize converte o nosso tipo de retorno para json.
// BorshDeserialize converte os parâmetros em json para os tipos que nossa função chama.
#[derive(BorshDeserialize, BorshSerialize, Default)]
pub struct Contract {
    struct_example: StructExample,
}

#[near_bindgen]
impl Contract{
    // Abaixo são as mesmas funções do struct sendo chamadas aqui.
    // A diferença sendo que estas são como interagimos com o contrato.
    //
    // O método para get_a_string precisa de &self, então usamos &self ou &mut self
    pub fn get_a_string(&self) -> String {
        self.struct_example.get_a_string()
    }

    pub fn get_a_floating(&self) -> f32 {
        self.struct_example.get_a_floating()
    }

    pub fn get_another_integer(&self) -> i32 {
        self.struct_example.get_another_integer()
    }

    pub fn get_an_integer(&self) -> u32 {
        self.struct_example.get_an_integer()
    }

    // O método para set_a_string precisa de &mut self, então só podemos usar &mut self
    pub fn set_a_string(&mut self, a_string_arg: String) {
        self.struct_example.set_a_string(a_string_arg);
    }

    pub fn set_a_floating(&mut self, a_floating: f32) {
        self.struct_example.set_a_floating(a_floating);
    }

    pub fn set_an_integer(&mut self, an_integer: u32) {
        self.struct_example.set_an_integer(an_integer);
    }

    pub fn set_another_integer(&mut self, another_integer: i32) {
        self.struct_example.set_another_integer(another_integer);
    }

    // just_a_function não tem &self, &mut self nem self
    // É apenas uma função no namespace da struct. Não precisamos de usar self também.
    pub fn just_a_function(){
        // :: é usado para referenciar namespaces. Não é um metodo de uma instância de struct, apenas uma função.
        StructExample::just_a_function();
    }

    pub fn take_ownership(&self) -> u32 {
        // A função take_ownership libera o objeto da memória.
        // The compiler will not let us call it directly when the owner is Contract.
        // O compilador não irá nos deixar chamar isso diretamente enquanto o dono for Contract.
        // Most of the issues of ownership can be solved by just cloning the object.
        // A maioria dos problemas de possessão (ownership) podem ser resolvidos apenas clonando objetos
        let a_copy: StructExample = self.struct_example.clone();

        // a_copy será removido no fim dessa função abaixo.
        let result = a_copy.take_ownership();

        // Descomente a linha abaixo e um erro de "move" irá aparecer.
        // Isso é porque chamamos uma função de uma instância que não existe mais.
        // env::log(format!("Essa linha de código irá gerar um erro {}", a_copy.get_a_floating()).as_bytes());

        result
    }
}

// cfg diz ao compilador para considerar esse modulo apenas em um ambiente de teste. Este não existe fora dessas condições.
#[cfg(test)]
mod tests{
    use super::*;
    use near_sdk::{
        AccountId,
        env,
        MockedBlockchain,
        testing_env,
        test_utils::VMContextBuilder,
        json_types::ValidAccountId,
    };

    fn env_setup(){
        let mut builder: VMContextBuilder = VMContextBuilder::new();

        // atributos que podemos alterar com esse builder
        //
        // current_account_id
        // signer_account_id
        // signer_account_pk
        // precessor_account_id
        // block_index
        // block_timestamp
        // epoch_height
        // account_balance
        // account_locked_balance
        // storage_usage
        // attached_deposit
        // prepaid_gas
        // random_seed
        // is_view

        let account_id: AccountId = String::from("stiltztinkerstein");

        builder.current_account_id(
            ValidAccountId::try_from(
                account_id.clone()
            ).unwrap()
        );

        testing_env!(builder.build());

        assert_eq!(
            env::current_account_id(),
            account_id, 
            "Assert Error. env: {} account: {}
            ", 
            env::current_account_id(), 
            &account_id,
        );
    }

    #[test]
    pub fn get_a_string() {
        env_setup();
    
        let contract: Contract = Contract::default();
    
        // Este valor é da implementação padrão.
        assert_eq!(
            contract.get_a_string(),
            "A default string"
        );
    }

    #[test]
    pub fn get_a_floating(){
        env_setup();
    
        let contract: Contract = Contract::default();
    
        // Este valor é da implementação padrão.
        assert_eq!(
            contract.get_a_floating(),
            0.5,
        );

    }

    #[test]
    pub fn get_another_integer(){
        env_setup();
    
        let contract: Contract = Contract::default();
    
        // Este valor é da implementação padrão.
        assert_eq!(
            contract.get_another_integer(),
            -1,
        );

    }

    #[test]
    pub fn get_an_integer(){
        env_setup();
    
        let contract: Contract = Contract::default();
    
        // Este valor é da implementação padrão.
        assert_eq!(
            contract.get_an_integer(),
            1,
        );
    }

    #[test]
    pub fn set_a_string() {
        env_setup();

        let mut contract: Contract = Contract::default();

        contract.set_a_string(String::from("A new string"));

        assert_eq!(
            contract.get_a_string(),
            String::from("A new string"),
        );
    }

    #[test]
    pub fn set_a_floating() {
        env_setup();

        let mut contract: Contract = Contract::default();

        contract.set_a_floating(-10.5432);
        
        assert_eq!(
            contract.get_a_floating(),
            -10.5432,
        );
    }

    #[test]
    pub fn set_an_integer() {
        env_setup();

        let mut contract: Contract = Contract::default();

        contract.set_an_integer(5);

        assert_eq!(
            contract.get_an_integer(),
            5,
        );
    }

    #[test]
    pub fn set_another_integer() {
        env_setup();

        let mut contract: Contract = Contract::default();

        contract.set_another_integer(7);

        assert_eq!(
            contract.get_another_integer(),
            7
        );
    }

    #[test]
    pub fn just_a_function(){
        env_setup();

        // Declaramos isso no início do contrato, mas não precisamos de usa-lo aqui
        // Começar a variável com _ se não tiver intenção de usá-la
        let _contract: Contract = Contract::default();

        // Note o :: devido a função não precisar de um state.
        Contract::just_a_function();
    }

    #[test]
    // take_ownership é só um exemplo de uma gambiarra em rust. Não ha muito uso aqui.
    pub fn take_ownership(){
        env_setup();

        let contract: Contract = Contract::default();

        let an_integer = contract.get_an_integer();

        assert_eq!(
            contract.take_ownership(),
            an_integer,
        );
    }

}

'''
'''--- PT-BR/lesson_4_modules/Cargo.toml ---
[package]
name = "lesson_4_modules"
version = "0.1.0"
authors = ["Lucas Lemos <stiltztinkerstein@gmail.com>"]
license = "MIT"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- PT-BR/lesson_4_modules/Readme.md ---
# Lição 4 - Módulos

[voltar](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/PT-BR/)

Esta lição discute sobre como módulos são importados. 

Podemos ter todo nosso código implementado no arquivo ```lib.rs```. Mas percebe-se como seria dificil de organizar um projeto grande dessa forma. 

 - Podemos declarar módulos externos; 
 - Declarar diretórios externos como módulos;
 - Controlar quais módulos são públicos;
 - Controlar o caminho para cada módulo público;
 - Também podemos organizar nossos testes no diretório ```./tests/```.

---

## API de Contrato

```rust
/// Retorna a String armazenada.
pub fn get_phrase(&self) -> String;

/// A função irá imprimir "Hello from crate::a_module" e 
/// atribuir essa string ao valor armazenado.
pub fn hello(&mut self);

/// A função irá imprimir "Hello from 
/// crate::a_module::specific_module" e atribuir essa string ao 
/// valor armazenado.
pub fn hello1(&mut self);

/// A função irá imprimir "Hello from another module" e 
/// atribuir essa string ao valor armazenado.
pub fn hello2(&mut self);

/// A função irá imprimir "Hello from yet_another_module" 
/// e atribuir essa string ao valor armazenado.
pub fn hello3(&mut self);

/// A função irá imprimir "Called a deep function" e 
/// atribuir essa string ao valor armazenado.
pub fn hello4(&mut self);

/// Esta função irá entrar em pânico com a mensagem "A panic 
/// just happened" quando chamado.
pub fn this_will_panic();
```

---

## Tópicos
 - [Como declarar um módulo externo](#como-declarar-um-m%C3%B3dulo-externo)
 - [Como declarar e usar diretórios](#como-declarar-e-usar-diret%C3%B3rios)
 - [Usando/importando módulos](#usandoimportando-m%C3%B3dulos)
   - [Apelidos](#apelidos)
   - [Usos públicos](#usos-p%C3%BAblicos)
 - [Testes de integração](#testes-de-integra%C3%A7%C3%A3o)
   - [Testes de integração NEAR](#testes-de-integra%C3%A7%C3%A3o-near)
   - [Testes de integração Rust](#testes-de-integra%C3%A7%C3%A3o-rust)
  - [Desativar avisos de compilador](#desativar-avisos-de-compilador)
  - [Testando Falhas](#testando-falhas)

---

## Como declarar um módulo externo

[topo](#li%C3%A7%C3%A3o-4---m%C3%B3dulos)

Um módulo externo deve ser declarado antes de usado/importado.

```rust
mod yet_another_module;
```

Essa linha diz ao compilador que existe um módulo com este nome no mesmo diretório. Existem três formas de se declarar um módulo. Se dois módulos ou mais com mesmo nome forem encontrados, um erro de ambiguidade será gerado.

O módulo acima é privado. Só pode ser usado onde foi declarado. O módulo abaixo é público:

```rust
pub mod a_module;
```

```a_module``` é público aqui. Ou seja, pode ser importado por outros. Isso inclui crates externas. O exemplo abaixo restringe isso.

```rust
pub(crate) fn hello() -> String{
    String::from("Hello from crate::a_module::specific_module")
}
```

```pub(crate)``` significa que esta função é pública apenas nessa crate. Ou seja, se ```lesson_4_modules``` for dependência de um outro projeto rust, o crate externo não terá acesso a essa função.

---

## Como declarar e usar diretórios

[topo](#li%C3%A7%C3%A3o-4---m%C3%B3dulos)

Podemos declarar diretórios como módulos também. Existem duas formas para isso. A primeira é:
 - Criar um diretório com o nome do seu módulo.
 - Criar um arquivo com nome ```mod.rs``` dentro desse diretório. Este arquivo possui a implementação do módulo.

![Imagem de um diretório com um arquivo mod.rs](../static/images/mod-diretorios.png)

```a_module``` é uma implementação de módulo. 

A segunda forma é:

 - Criar um diretório com o nome do seu módulo.
 - Criar um arquivo rust com o mesmo nome do seu módulo junto com o diretório. Este arquivo possui a implementação do módulo.

![Imagem de um diretório com um arquivo de mesmo nome ao lado](../static/images/mod-diretorios2.png)

```internal_module``` é outra implementação de módulo.

O arquivo rust fica dentro ou fora do diretório? Essa é a questão.

---

## Usando/Importando módulos

[topo](#li%C3%A7%C3%A3o-4---m%C3%B3dulos)

Qualquer item (módulos, funções, structs, traits, enums, et cetera) pode ser importado com a instrução use.

No exemplo abaixo, acessamos o caminho ```near_sdk``` (uma crate neste caso), e incluimos ```env``` e ```near_bindgen``` no nosso namespace.

```rust
use near_sdk::{env, near_bindgen};
```

Não é necessário usar a instrução use. Porém, se quiséssemos acessar o módulo ```env```, teriamos que escrever ```near_sdk::env``` todas as vezes.

---

### Apelidos

[topo](#li%C3%A7%C3%A3o-4---m%C3%B3dulos)

Podemos dar um apelido ao item importado:

```rust
use a_module::specific_module::hello as hello1;
```

Existem várias funções ```hello``` neste exemplo. Então alteramos o nome de cada uma com o operador ```as```. Ou seja, importando dessa forma, a instrução ```hello1()``` é o mesmo que ```a_module::specific_module::hello()```.

---

### Usos públicos

[topo](#li%C3%A7%C3%A3o-4---m%C3%B3dulos)

As instruções

```rust
pub use another_module::hello as hello2;
pub use yet_another_module::hello as hello3;
```

Trazem as duas funções hello para este namespace, alteram o nome para ```hello2``` e ```hello3```, e as tornam públicas, como se tivessem sido declaradas neste módulo. Isso é uma boa forma de organizar nosso projeto. Por exemplo, no arquivo ```yet_another_module```:

```rust
mod internal_module;

pub use internal_module::a_deep_module::a_deep_function;
```

Declaramos que o módulo ```internal_module``` existe, e é privado. Mas a função ```a_deep_function``` é pública. Um usuário pode acessar esse item pelo caminho ```yet_another_module::a_deep_function```. Sem saber que a função está em um diretório completamente diferente.

Organize módulos e diretórios de acordo com as necessidades do seu projeto. Use ```pub use``` para organizar os itens disponíveis de acordo com as necessidades dos usuários externos.

**Detalhe**: ```pub use``` e ```pub mod``` são usados para módulos públicos e crates feitos para serem importados (library) por outros projetos rust. Não possui nenhuma interação no contexto de contratos NEAR.

---

## Testes de Integração

[topo](#li%C3%A7%C3%A3o-4---m%C3%B3dulos)

A linguagem rust tem um formato para testes de integração, e o formato NEAR possui outro.

Isso porque testes de integração em NEAR consistem na interação entre diversos contratos em uma simulação de estrutura blockchain.

---

### Testes de Integração NEAR

[topo](#li%C3%A7%C3%A3o-4---m%C3%B3dulos)

Para isso usamos uma ferramenta chamada [workspaces-rs](https://github.com/near/workspaces-rs)

Agora, como se ja não estivesse confuso o suficiente, workspaces em rust e workspaces-rs são duas coisas diferentes. [Workspaces](https://doc.rust-lang.org/cargo/reference/workspaces.html) em rust são uma forma de organizar várias crates em um único pacote, todas compartilhando um diretório ```./target/``` e um arquivo ```Cargo.lock```. [workspaces-rs](https://github.com/near/workspaces-rs) é uma forma de realizar testes de integração de contratos NEAR utilizando a linguagem rust.

Testes de integração eram feitos com a crate [near-sdk-sim](https://www.near-sdk.io/testing/simulation-tests), mas esta ferramenta será deprecada pela [sandbox](https://docs.near.org/docs/develop/contracts/sandbox). Use a ferramenta que lhe servir melhor.

---

### Testes de integração Rust

[topo](#li%C3%A7%C3%A3o-4---m%C3%B3dulos)

Geralmente declaramos testes no mesmo arquivo. da seguinte forma:

```rust
#[cfg(test)]
mod tests{
    // carrega tudo que está neste arquivo, fora deste módulo.
    use super::*;

    #[test]
    fn hello_test(){
```

Mas as vezes, precisamos declarar testes em sua própria estrutura de arquivos e diretórios.

Podemos criar um diretório ```tests``` junto com o ```src```.

![Imagem do diretório root com destaque no diretório "tests"](../static/images/testsdirectory.png)

Quando executarmos o comando ```cargo test```, cada arquivo ```.rs``` será tratado como um módulo de teste. Todas as funções marcadas com ```#[test]``` serão executadas automaticamente.

Os arquivos ```.rs``` não precisam ser declarados com a instrução ```mod``` para serem compilados.

O diretório ```tests``` age como uma crate separada. Podemos importar módulos no mesmo diretório:

```rust
mod common;

use common::env_setup;
```

Para importarmos módulos na crate principal, referimos à essa pelo nome da crate:

```rust
use lesson_4_modules::Contract;
```

---

## Desativar avisos de compilador

[topo](#li%C3%A7%C3%A3o-4---m%C3%B3dulos)

Avisos ("warnings") são gerados durante a compilação. Podemos desativar avisos da seguinte forma:

```rust
#[allow(unused)]
```

O exemplo acima permite uma falha de código "não utilizado" na linha abaixo.

O recomendado é corrigir avisos do compilador. Mas existem situações em que talvez isso seja útil. Por exemplo, a convenção para funções javascript é ```CamelCase```, mas a convenção para funções em rust é ```snake_case```. Quando comunicarmos com o nosso contrato através do near-api-js, talvez seja melhor ter as funções na convenção javascript.

```rust
#[allow(non_snake_case)]
pub fn ACamelCaseFunction() {    
```

Podemos permitir avisos de imports não utilizados:

```rust
#[allow(unused_imports)]
use near_sdk::{env, near_bindgen};
```

Repetindo, avisos existem para nos ajudar. O recomendado é **corrigir** os avisos, não escondê-los.

---

## Testando falhas

[topo](#li%C3%A7%C3%A3o-4---m%C3%B3dulos)

Criamos testes para garantir que erros aconteçam quando erros devem acontecer também.

```rust
    #[test]
    #[should_panic(expected = "A panic has just happened")]
    fn this_will_panic_test() {
        this_will_panic();
    }
```

O teste acima irá causar pânico, mas esperamos pânico. Então o teste será um sucesso.

Se a operação não causar pânico, ou causar pânico com uma mensagem diferente do esperado ("expected"). O teste irá falhar.

A [próxima lição](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/PT-BR/lesson_5_macro_usage) será sobre uso de macros.

'''
'''--- PT-BR/lesson_4_modules/src/a_module/mod.rs ---
//! Entre usar mod.rs ou um arquivo rust com mesmo nome. 
//! É apenas uma questão de manter o arquivo rust no diretorio pai ou filho.
//! 
//! 

pub mod specific_module;

pub fn hello() -> String {
    String::from("Hello from crate::a_module")
}

'''
'''--- PT-BR/lesson_4_modules/src/a_module/specific_module.rs ---
// Ter (crate) após pub torna a função (ou módulo, trait, ...) disponivel 
// para módulos locais, mas não para crates externos.
pub(crate) fn hello() -> String{
    String::from("Hello from crate::a_module::specific_module")
}

/// panic é quando algo de errado acontece e tudo deve parar imediatamente.
/// Podemos causar panic sob demanda.
pub fn this_will_panic() {
    panic!("A panic has just happened");
}

// cfg(test) diz ao compilador que isto apenas existe em ambientes de teste.
#[cfg(test)]
mod tests{
    // carrega tudo que está neste arquivo, fora deste módulo.
    use super::*;

    #[test]
    fn hello_test(){
        // Hello é público apenas para módulos desta crate.
        // Tentaremos importá-lo no diretório de tests, o que causará um erro.
        // Pois o diretório de testes atua como a própria crate.
        assert_eq!(
            hello(),
            "Hello from crate::a_module::specific_module",
        );
    }

    #[test]
    // Podemos testar em situações que causam panic.
    // expected garante que entraremos em pânico pelo motivo correto.
    #[should_panic(expected = "A panic has just happened")]
    fn this_will_panic_test() {
        this_will_panic();
    }
}
'''
'''--- PT-BR/lesson_4_modules/src/another_module.rs ---
pub fn hello() -> String {
    String::from("Hello from another_module")
}

// A função abaixo é privada.
// #[allow(unused)] é uma forma de dizer ao compilador/linter para ignorar o aviso. Mesmo em um situação como essa, em que é uma má ideia. Pois esta função é inutil.
// Comente o #[allow(unused)] para ver o aviso
#[allow(unused)]
fn this_is_private() -> String {
    // Tradução: Esta função nunca será usada pois é privada.
    String::from("This will never be used because it's private")
}

'''
'''--- PT-BR/lesson_4_modules/src/lib.rs ---
//! Este exemplo foca na administração de módulos.
//! 
//! 
//!
//! A ordem para importação de crates e modulos é, normalmente:
//! 
//!  - padrão (std), 
//!  - outras crates (como near-sdk), 
//!  - crates nesta workspace, 
//!  - e módulos locais.
//!
//! 
//! "mod file" diz ao compilador que o arquivo nesse diretório local deve ser compilado também.
//! Para usarmos o módulo utilizamos "use".
//! 
//! "pub mod" quer dizer que outros módulos podem usar dito módulo, senão é privado.
//! "pub use" pode ser usado para o mesmo propósito.
//! A diferença sendo que arquivos podem ser organizados de certa forma, e módulos de library em outra, mais conveniente.
//! 

// Esta linha está dizendo que existe um arquivo ou diretório com nome "a_module" e deve ser compilado.
// "mod.rs" é uma forma necessária de um diretório ser reconhecido como módulo.
pub mod a_module;
// Esta linha esta dizendo que o arquivo "another_module.rs" é parte deste projeto e deve ser compilado.
mod another_module;

// Esta linha é outra forma de declarar módulos, não precisa de "mod.rs", mas acho mais desorganizado.
mod yet_another_module;

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
#[allow(unused_imports)]
use near_sdk::{env, near_bindgen};

// Podemos usar "as" para dar apelidos a funções ou módulos importados.
use a_module::hello as hello;
use a_module::specific_module::hello as hello1;

// pub use torna a função disponível para crates externos.
pub use another_module::hello as hello2;
pub use yet_another_module::hello as hello3;

// A localização atual de "a_deep_function"  é "yet_another_module::internal_module::a_deep_module::a_deep_function."
// Mas este endereço é privado, e "yet_another_modulo" chamou "pub use" para a função. Em outras palavras, mais limpo.
use yet_another_module::a_deep_function as hello4;

// Descomente a linha adiante para receber um aviso de erro "isto é privado".
// use another_module::this_is_private;

pub use a_module::specific_module::this_will_panic;

near_sdk::setup_alloc!();

// Esta função irá fazer nosso código menos bagunçado.
pub fn log(message: &str) {
    env::log(message.as_bytes());
}

#[near_bindgen]
#[derive(Clone, Default, BorshDeserialize, BorshSerialize)]
pub struct Contract {
    stored_phrase: String,
}

#[near_bindgen]
impl Contract{
    /// Retorna a String armazenada.
    pub fn get_phrase(&self) -> String {
        self.stored_phrase.clone()
    }

    /// A função irá imprimir "Hello from crate::a_module" e 
    /// atribuir essa string ao valor armazenado.
    pub fn hello(&mut self) {        
        self.stored_phrase = hello();
        log(&hello());
    }

    /// A função irá imprimir "Hello from 
    /// crate::a_module::specific_module" e atribuir essa string ao 
    /// valor armazenado.
    pub fn hello1(&mut self) {
        self.stored_phrase = hello1();
        log(&hello1());
    }

    /// A função irá imprimir "Hello from another module" e 
    /// atribuir essa string ao valor armazenado.
    pub fn hello2(&mut self) {
        self.stored_phrase = hello2();
        log(&hello2());
    }

    /// A função irá imprimir "Hello from yet_another_module" 
    /// e atribuir essa string ao valor armazenado.
    pub fn hello3(&mut self) {
        self.stored_phrase = hello3();
        log(&hello3());
    }

    /// A função irá imprimir "Called a deep function" e 
    /// atribuir essa string ao valor armazenado.
    pub fn hello4(&mut self) {
        self.stored_phrase = hello4();
        log(&hello4());
    }

    /// Esta função irá entrar em pânico com a mensagem "A panic 
    /// just happened" quando chamado.
    pub fn this_will_panic() {    
        this_will_panic();
    }
}

// Testes estão no diretório tests. Muito útil para projetos grandes.

'''
'''--- PT-BR/lesson_4_modules/src/yet_another_module.rs ---
// internal_module é privado para módulos externos.
mod internal_module;

// Mas fizemos a_deep_function publico para outros na declaração aqui.
// Bom para organizar código.
pub use internal_module::a_deep_module::a_deep_function;

pub fn hello() -> String {
    String::from("Hello from yet_another_module")
}

'''
'''--- PT-BR/lesson_4_modules/src/yet_another_module/internal_module.rs ---
pub mod a_deep_module;

'''
'''--- PT-BR/lesson_4_modules/src/yet_another_module/internal_module/a_deep_module.rs ---
/// Uma função profunda.
pub fn a_deep_function() -> String {
    String::from("Called a deep function")
}

'''
'''--- PT-BR/lesson_4_modules/tests/another.rs ---
//! Cada arquivo rusts no diretório tests é testado individualmente.
//! Não há necessidade de incluí-los usando mod.

// Descomente a linha abaixo e verá um aviso de erro "privado".
// Isso é porque é público apenas dentro da crate. E "tests" age como a própria crate.
// use lesson_4_modules::a_module::specific_module::hello;

#[test]
fn oneplusone() {
    assert_eq!(1 + 1, 2);
}

'''
'''--- PT-BR/lesson_4_modules/tests/common/mod.rs ---
use near_sdk::{
    AccountId,
    env,
    MockedBlockchain,
    testing_env,
    test_utils::VMContextBuilder,
    json_types::ValidAccountId,
};

pub fn env_setup(){
    let mut builder: VMContextBuilder = VMContextBuilder::new();

    // attributes we can set with the builder:
    // current_account_id
    // signer_account_id
    // signer_account_pk
    // precessor_account_id
    // block_index
    // block_timestamp
    // epoch_height
    // account_balance
    // account_locked_balance
    // storage_usage
    // attached_deposit
    // prepaid_gas
    // random_seed
    // is_view

    let account_id: AccountId = String::from("stiltztinkerstein");

    builder.current_account_id(
        ValidAccountId::try_from(
            account_id.clone()
        ).unwrap()
    );

    testing_env!(builder.build());

    assert_eq!(
        env::current_account_id(),
        account_id, 
        "Assert Error. env: {} account: {}", 
        env::current_account_id(), 
        &account_id,
    );
}

'''
'''--- PT-BR/lesson_4_modules/tests/contract.rs ---
//! Este módulo irá testar a funcionalidade do contrato.

// common será um módulo com funções úteis para todos outros testes.
mod common;

// Diretório tests age como a própria crate.
// So when we import our own modules, 
// Então quando importamos nossos próprios módulos,
// referimos a estes como "lesson_4_modules::" em vez de "crates::"
use lesson_4_modules::Contract;

use common::env_setup;

#[test]
pub fn get_phrase() {
    env_setup();

    let contract: Contract = Contract::default();

    // Usamos derive(Default) para Contract.
    // o padrão derivado para String é uma string vazia.
    assert_eq!(contract.get_phrase(), "");
}

/// Esta função irá atribuir "Hello from crate::a_module".
#[test]
pub fn hello() {
    env_setup();

    let mut contract: Contract = Contract::default();

    contract.hello();

    assert_eq!(
        contract.get_phrase(),
        "Hello from crate::a_module",
    );
}

/// Esta função irá atribuir "Hello from crate::a_module::specific_module".
#[test]
pub fn hello1() {
    env_setup();

    let mut contract: Contract = Contract::default();

    contract.hello1();

    assert_eq!(
        contract.get_phrase(),
        "Hello from crate::a_module::specific_module",
    );
}

/// Esta função irá atribuir "Hello from another_module".
#[test]
pub fn hello2() {
    env_setup();

    let mut contract: Contract = Contract::default();

    contract.hello2();

    assert_eq!(
        contract.get_phrase(),
        "Hello from another_module",
    );
}

/// Esta função irá atribuir "Hello from yet_another_module".
#[test]
pub fn hello3() {
    env_setup();

    let mut contract: Contract = Contract::default();

    contract.hello3();

    assert_eq!(
        contract.get_phrase(),
        "Hello from yet_another_module",
    );
}

/// Esta função irá atribuir "Called a deep function".
#[test]
pub fn hello4() {
    env_setup();

    let mut contract: Contract = Contract::default();

    contract.hello4();

    assert_eq!(
        contract.get_phrase(),
        "Called a deep function",
    );
}

/// Esta função entrará em panico com a messagem "A panic has just happened" quando chamado.
// Podemos testar situações que causam pânico.
// expected garante que estamos entrando em pânico pelo motivo certo.
#[test]
#[should_panic(expected = "A panic has just happened")]
pub fn this_will_panic() {
    env_setup();

    // Embora não utilizemos o state, é bom inicializar antes de cada teste.
    let _contract: Contract = Contract::default();

    Contract::this_will_panic();
}

'''
'''--- PT-BR/lesson_5_macro_usage/Cargo.toml ---
[package]
name = "lesson_5_macro_usage"
version = "0.1.0"
authors = ["Lucas Lemos <stiltztinkerstein@gmail.com>"]
license = "MIT"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- PT-BR/lesson_5_macro_usage/Readme.md ---
# Lição 5 - Uso de Macros

[voltar](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/PT-BR/)

Macros são a ferramenta principal para a utilização efetiva da linguagem rust. Não é necessário saber como criar macros. Mas é essencial entender o que são e como usá-los.

---

## API de Contrato

```rust
/// Esta função mostra as diferenças entre println e env::log
/// Execute com ```cargo test -- --nocapture```, compile, implante e execute em Near.
/// Note como algumas mensagens aparecem e outras não.
pub fn print_examples();

/// Exemplos de format. Compare o output com a implementação.
pub fn format_examples();

/// Exemplo de panico.
pub fn panic_example();

/// Exemplo de usos de vec.
pub fn vec_examples();
```

## Tópicos

 - [O que são macros](#o-que-são-macros)
 - [Macros "function-like"](#macros-"function-like")
 - [Vantagens](#vantagens)
 - [Desvantagens](#desvantagens)
 - [Exemplos](#exemplos)
   - [format, println e panic](#format-println-e-panic)
   - [vec](#vec)
   - [setup_alloc](#setup_alloc)
 - [Extra: String e str](#extra-string-e-str) 

---

## O que são macros

[topo](#lição-5---uso-de-macros)

Macros são ferramentas que geram código. Macros são executados em tempo de compilação. 

As instruções derive são um macro:

```rust
#[derive(Clone, Default, BorshDeserialize, BorshSerialize)]
pub struct Contract {
```

Instruções derive servem para aplicar traits a novos tipos. A instrução a seguir é outro tipo de macro chamado "atributo":

```rust
#[near_bindgen]
impl Contract{
```

Mas discutiremos macros "function-like" (semelhantes a funções). Como o nome descreve, são usados com a mesma lógica do chamado de funções. Alguns exemplos:

```rust
// Imprime o string formatado ao output padrão
println!("{}", message);

// Formata os argumentos em um String
format!("7");

// Formata uma String e entra em pânico com a mensagem formatada
// "Entrar em pânico" Encerra o runtime retornando uma mensagem de erro.
panic!("Panico com alguns argumentos: {} {} {}", 1, second, 3);

// Recebe uma lista de argumentos e retorna um Vec com os valores alocados.
vec![1, 2, 3, 4];

// Gera código de fôrma (boilerplate) necessário para o funcionamento do contrato
near_sdk::setup_alloc!();

// Usado em testes.
// Usa o argumento Context para gerar o contexto de ambiente da máquina virtual.
testing_env!(builder.build());

``` 

---

## Macros "function-like"

[topo](#lição-5---uso-de-macros)

Esses macros são usados como funções, mas existem algumas diferenças.

Podem ter um número variado de parâmetros. Rust é uma linguagem "statically typed", ou seja, o compilador precisa saber exatamente onde memória é criada e onde é liberada. Porém, macros podem retornar código. Ou seja, um macro como ```println``` ou ```format``` recebem os argumentos e montam um bloco de código antes do compilador checar por erros.

Outra diferença que pode ser vista com o exemplo de ```vec```:

```rust
vec![1, 2, 3, 4];
```

Esta implementação vec é demarcada com ``` [ ] ``` em vez de ``` ( ) ```, macros também podem ser demarcados com ``` { } ```. Macros podem ter literalmente qualquer tipo de texto dentro dos demarcadores. Um desenvolvedor pode escrever qualquer coisa como argumento macro, contanto que a implementação entenda os parâmetros.

---

## Vantagens

[topo](#lição-5---uso-de-macros)

 - Simplifica o código.
 - É executado durante compilação. Se bem implementado, macros podem ser eficientes com pouco ou nenhum overhead.

---

## Desvantagens

[topo](#lição-5---uso-de-macros)

 - Um desenvolvedor precisa pesquisar a documentação de cada novo macro que encontram.
 - Podem ser mais dificeis de "debugar".
 - Aumentam o tempo de compilação.
 - Podem "inflar" o código com implementação "invisivel".

---

## Exemplos

A seguir recomendamos alguns macros "function-like" úteis.

---

### format, println e panic

[topo](#lição-5---uso-de-macros)

Os macros ```panic```, ```println``` e ```format``` são escritos da mesma forma.

 - ```format``` retorna um String.
 - ```println``` imprime o String no output padrão.
 - ```panic``` encerra a execução e retorna o String como mensagem de erro.

```rust
println!("Isso é um println!, não aparece na máquina virtual");

// Criamos uma variavel "message" e associamos uma String de valor "format retorna uma String formatada".
let message: String = format!("format retorna uma string formatada.");

// Encerra execução com a mensagem de erro "Panico com alguns argumentos: 1 2 3"
let second = 2;
panic!("Panico com alguns argumentos: {} {} {}", 1, second, 3);

```

A utilização destes macros é bem simples. Um str como primeiro argumento ([detalhes](#extra-string-e-str)). Cada "{}" é substituido pelos argumentos após o primeiro.

Podemos customizar a formatação de diversas formas. Mais informações, cheque o [link de documentação sobre formatação](https://doc.rust-lang.org/std/fmt/index.html). Abaixo incluimos algumas úteis utilizações:

```rust
// Exemplos de format
log("\n\nformat_examples:\n");
 
let message: String = format!("Format retorna uma String formatada");

let an_arg = "third";

// format pode receber argumentos usando {} 1 second third
let message = format!("format pode receber argumentos usando {{}}: {}, {}, {}.", 1, "second", an_arg);

let (first, second, third) = (1, "second", an_arg);

// Podemos especificar argumentos dessa forma: 1 second third
let message = format!("Podemos especificar argumentos dessa forma: {first}, {second}, {third}.");

// Podemos especificar a ordem de argumentos de format: 1 second third
let message = format!("Podemos especificar a ordem de argumentos de format: {1}, {2}, {0}.", third, first, second);

let (first, second, third) = (1, 2, 3);
// Podemos fazer inteiros mostrarem um número arbitrário de digitos: 01 0002      3
let message = format!("Podemos fazer inteiros mostrarem um número arbitrário de digitos: {:02}, {:04}, {:6}.", first, second, third);

// Escolhendo número de digitos e ordem: 01    2 000003
let message = format!("Escolhendo número de digitos e ordem: {2:02}, {0:4}, {1:06}.", second, third, first);

let (first, second, third) = (0.1, 1.23, -2.45);
// Podemos escolhar a precisão de números racionais: 0.10 1.230 -2.450000
let message = format!("Podemos escolhar a precisão de números racionais: {:.2}, {:.4}, {:.6}", first, second, third);

// Podemos escolher a precisão e número de digitos: 0.10 0001.2300 -00002.450000
let message = format!("Podemos escolher a precisão e número de digitos: {:2.2}, {:04.4}, {:06.6}", first, second, third);

// Podemos escolher a precisão, o número de digitos e a ordem dos argumentos: 00.10    1.2300 -00002.450000
let message = format!("Podemos escolher a precisão, o número de digitos e a ordem dos argumentos: {1:02.2}, {2:4.4}, {0:06.6}", third, first, second);

// Mesmo que o acima:  0.10 0001.2300      -2.450000
let message = format!("Mesmo que o acima: {first:2.2}, {second:04.4}, {third:6.6}");

```

---

### vec

[topo](#lição-5---uso-de-macros)

Uma rápida discussão sobre algumas formas de agrupar valores. 

Tuplas possuem tamanho imutavel:

```rust
// Uma tupla com inteiros
let tupla: (u32, u32, u32) = (0, 1, 4);

// Acessando um valor
// O segundo valor é 1
println!("O segundo valor é {}", tupla.1);
```

Arrays possuem tamanho imutável, são armazenados na pilha (stack).

```rust
// Uma forma de declarar um array
let lista = [0, 1, 2];

// Acessando um valor
// O terceiro valor é 2
println!("O terceiro valor é {}", lista[2]);

// um array com 10 inteiros inicializados com 0.
// Esse método só permite inicializar com valores iguais, não tente inicializar com uma função.
let mut lista: [i32; 10] = [0; 10];

// Alterando um valor
lista[0] = -1;

// Acessando um valor
// O primeiro valor é -1
println!("O primeiro valor é {}", lista[0]);
```

Arrays e tuplas são primitivos. Não podemos alterar o número de elementos desses grupos. Para armazenar conjuntos de valores de forma mais prática usamos coleções. Temos coleções rust, que são mais generalizadas, e coleções Near, que são armazenadas na "trie". O entendimento de coleções rust é importante para uma boa lógica de funções. O entendimento de coleções Near é importante para armazenamento eficiente de estado.

 - [Detalhes](https://doc.rust-lang.org/std/collections/) sobre coleções Rust para bom funcionamento de métodos.
 - [Detalhes](https://docs.rs/near-sdk/latest/near_sdk/collections/index.html) sobre coleções Near para bom armazenamento de estado.

A coleção rust mais utilizada é ```Vec```([detalhes](https://doc.rust-lang.org/std/vec/struct.Vec.html)). Com este tipo, podemos armazenar dados, observar a quantidade de elementos, acessar e alterar os elementos. O que é uma boa solução para a maior parte dos casos.

**Detalhe:** ```vec``` (letra minuscula) é o macro para criação de vetores ```Vec```. ```Vec``` (letra maiuscula) refere-se ao tipo do vetor.

Podemos criar um ```Vec``` da seguinte forma:

```rust
// Vec com os números 1 2 3 4
let example = vec![1, 2, 3, 4];
```

Podemos criar um ```Vec``` com vários valores iguais:

```rust
// Vec com os números 0 0 0 0 0
let example = vec![0;5];
```

Imprimir valores de conjuntos pode demandar muito tempo de processamento. Devido a isso, para usar um conjunto de elementos em um ```println```, ```format``` ou ```panic```, precisamos explicitar que é impresso em modo debug.

```rust
let example = vec![1, 2, 3, 4];

log(&format!("Podemos imprimir vetores com modo debug:\n{:?}\n\n", example));

log(&format!("Podemos imprimir vetores em \"formato legivel\":\n{:#?}\n\n", example));

log(&format!("Podemos fazer o mesmo com tuplas:\n{:#?}\n\n", (1, 2, 3)));

log(&format!("Podemos criar vetores com valores padrão:\n{:?}\n\n", vec![0;5]));
```

Formatação ```{:?}``` é "formatação debug".

Formatação ```{:#?}``` é "formatação pretty print". É o mesmo que o acima, porém escrito de uma forma mais legivel para um usuário. Normalmente simplesmente significa um elemento por linha.

Para implementar formatação debug em um struct ou enum, cheque o [link sobre formatação](https://doc.rust-lang.org/std/fmt/trait.Debug.html).

---

### setup_alloc

[topo](#lição-5---uso-de-macros)

Deve ser usado antes da declaração do contrato. Gera código que deveria ser escrito repetidas vezes em cada contrato.

```rust
near_sdk::setup_alloc!();
```

É necessário na versão de near_sdk atual (```3.1.0```). Nas versões seguintes, será deprecado.

---

## Extra: String e str

[topo](#lição-5---uso-de-macros)

```String``` e ```str``` são dois tipos diferentes. String é um tipo que mantem ownership de uma string. ```str``` é um tipo usado para referências a strings. Estes tipos existem para minimizar cópias de strings durante o runtime.

Lembrar: 
 - ```str``` é sempre usado como ```&str```. ```&str``` aplica para "strings como essa" e ```&String```;
 - Sempre que for precisar de uma referência para uma ```String``` em uma função, use ```&str```. Não use ```&String```.
 - "Strings como essa" são do tipo ```&'static str```. Mais detalhes na seção sobre lifetimes. Teoricamente, são strings que nunca são removidas da memória, mas isso depende da otimização do compilador.

A [proxima lição](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/PT-BR/lesson_6_enums) será sobre enums.

'''
'''--- PT-BR/lesson_5_macro_usage/src/lib.rs ---
//! Exemplos para os seguintes macros:
//! - format!
//! - println!
//! - panic!
//! - vec!
//! - setup_alloc!
//! 
//! 
//! 

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
#[allow(unused_imports)]
use near_sdk::{env, near_bindgen};

near_sdk::setup_alloc!();

/// Esta função é usada em ```print_examples```.
/// É compilada em ambientes de teste.
#[cfg(test)]
pub fn log(message: &str) {
    println!("{}", message);
}

/// Esta função é usada em ```print_examples```.
/// É compilada fora de ambientes de teste.
#[cfg(not(test))]
pub fn log(message: &str) {
    env::log(message.as_bytes());
}

#[near_bindgen]
#[derive(Clone, Default, BorshDeserialize, BorshSerialize)]
pub struct Contract {
    // Este contrato não possui estado
}

#[near_bindgen]
impl Contract{

    /// Esta função mostra as diferenças entre println e env::log
    /// Execute com ```cargo test -- --nocapture```, compile, implante e execute em Near.
    /// Note como algumas mensagens aparecem e outras não.
    pub fn print_examples() {
        log("\n\nprint_examples:\n");
        println!("Isto é um println! Não aparece na máquina virtual");
        let a = String::from("algo");
        println!("Isso é outro println com diversos argumentos, {}, {}, {}", 1, "thingy", a);

        env::log(b"Isso e um log. Nao aparece em testes.");
        env::log("Isso é outro log".as_bytes());

        env::log(
            format!("Isso é outro log com diversos argumentos: {}, {}, {}", 1, 2, "3")
            .as_bytes()
        );

        log("Isso é uma mensagem que aparecem em testes e na máquina virtual.");

        log(
            &format!("Isso é outra mensagem com argumentos, {}, {}, {}.",
                5,
                "6",
                format!("7"),
            )
        );
        
        log("\n\n---------------------------------------------------------------------------------\n\n");
    }

    /// Exemplos de format. Compare o output com a implementação.
    pub fn format_examples() {
        log("\n\nformat_examples:\n");
        let message: String = format!("format retorna um String formatado");
        log(&message);

        let an_arg ="terceiro";
        let message = format!("format pode receber argumentos usando {{}}: {}, {}, {}.", 1, "second", an_arg);
    
        log(&message);

        let (first, second, third) = (1, "segundo", an_arg);
        let message = format!("Podemos especificar argumentos format da seguinte forma: {first}, {second}, {third}.");

        log(&message);

        let message = format!("Podemos especificar a ordem dos argumentos format: {1}, {2}, {0}.", third, first, second);

        log(&message);

        let (first, second, third) = (1, 2, 3);
        let message = format!("Podemos fazer inteiros mostrarem um número arbitrário de digitos: {:02}, {:04}, {:6}.", first, second, third);
        log(&message);

        let message = format!("Escolhendo um número de digitos e ordem: {2:02}, {0:4}, {1:06}.", second, third, first);
        log(&message);

        let (first, second, third) = (0.1, 1.23, -2.45);
        let message = format!("Podemos escolher a precisão de números racionais: {:.2}, {:.4}, {:.6}", first, second, third);
        log(&message);

        let message = format!("Podemos escolher a precisão e o número de digitos: {:2.2}, {:04.4}, {:06.6}", first, second, third);
        log(&message);

        let message = format!("Podemos escolher a precisão, o número de digitos e a ordem dos argumentos: {1:02.2}, {2:4.4}, {0:06.6}", third, first, second);
        log(&message);

        let message = format!("Mesmo que acima: {first:2.2}, {second:04.4}, {third:6.6}");

        log(&message);

        log("\n\n----------------------------------------------------------------------\n\n");
    }

    /// Exemplo de panico.
    pub fn panic_example() {
        log("\n\npanic_example:\n\n\n");

        log("Macros de pânico são escritos da mesma forma que println e format.");

        let second = 2;
        panic!("Pânico com alguns argumentos: {} {} {}", 1, second, 3);

    }

    /// Exemplo de usos de vec.
    pub fn vec_examples() {
        log("\n\nvec_examples:\n");

        let example = vec![1, 2, 3, 4];

        log(&format!("Podemos imprimir vetores com modo debug:\n{:?}\n\n", example));
        
        log(&format!("Podemos imprimir vetores em \"formato legivel\":\n{:#?}\n\n", example));

        log(&format!("Podemos fazer o mesmo com tuplas:\n{:#?}\n\n", (1, 2, 3)));

        log(&format!("Podemos criar vetores com valores padrão:\n{:?}\n\n", vec![0;5]));

        log("Mais informações na lição de coleções (\"collections\").");

        log("\n\n-------------------------------------------------------------------------------\n\n");
    }
}

// Execute testes com o comando a seguir:
// cargo test -- --nocapture --test-threads=1
//
//
// --nocapture faz imprimir todo o output, incluindo testes sucedidos.
// Sem o argumento --test-threads, todos os testes serão async. O que significa que o output será uma bagunça.
//
#[cfg(test)]
mod tests{
    use super::*;
    use near_sdk::{
        MockedBlockchain,
        testing_env,
        test_utils::VMContextBuilder,
    };

    fn env_setup(){
        let builder: VMContextBuilder = VMContextBuilder::new();
        testing_env!(builder.build());

        // O contrato é stateless. Declaramos, mas não usamos.
        let _contract: Contract = Contract::default();
    }

    #[test]
    pub fn print_examples() {
        env_setup();
    
        Contract::print_examples();
    }

    #[test]
    pub fn format_examples() {
        env_setup();
    
        Contract::format_examples();
    }

    #[test]
    pub fn vec_examples() {
        env_setup();
    
        Contract::vec_examples();
    }

    #[test]
    #[should_panic(expected = "Pânico com alguns argumentos: 1 2 3")]
    pub fn panic_example() {
        env_setup();

        Contract::panic_example();
    }
}

'''
'''--- PT-BR/lesson_6_enums/Cargo.toml ---
[workspace]
members=[
    "lesson_6_1_simple", 
    "lesson_6_2_thermometer",
    "lesson_6_3_game_score"
]

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- PT-BR/lesson_6_enums/Readme.md ---
# Lição 6 - Enums

[voltar](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/PT-BR/)

Esta lição é dividida em 4 partes relacionadas a enums. Cada tópico é uma crate. Aproveitaremos este momento para explicar sobre workspaces e como usá-los.

As sessões são as seguintes:
 - [Parte 1 - Declarando e usando enums](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/PT-BR/lesson_6_enums/lesson_6_1_simple/).
 - [Parte 2 - Termometro implementado com enums](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/PT-BR/lesson_6_enums/lesson_6_2_thermometer/).
 - [Parte 3 - Como implementar erros de forma prática e eficiente](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/PT-BR/lesson_6_enums/lesson_6_3_game_score/).

---

## Workspaces

[topo](#lição-6---enums)

Simplesmente, workspace é um diretório com várias crates. Quando compilados, todas as crates compartilham o mesmo diretório target. Mas cada crate resulta em um arquivo compilado.

Algumas utilidades para uso de workspaces são descritos a seguir:
 - Dependências locais. Criamos uma crate customizada para o nosso projeto, e outra crate depende dela.
 - Organização de projeto. Queremos executar testes e compilar todos os projetos simultaneamente.
 - Coordenação de contratos. Um projeto que consiste em vários contratos responsáveis por diferentes funções. Um workspace pode incluir os contratos e uma crate de testes cross-contract (exemplo: [workspaces-rs](https://github.com/near/workspaces-rs)).

---

## Cargo.toml

[topo](#lição-6---enums)

O manifest possui a seção ```[workspace]```.

```toml
[workspace]
members=["lesson_6_1_simple"]
```

```members``` descreve cada crate do projeto.

**Detalhe**: Se uma crate existir neste diretório, esta ainda será considerada. Para não incluir a crate, devemos incluir o atributo ```exclude```. Como no exemplo a seguir (fonte: https://doc.rust-lang.org/cargo/reference/workspaces.html, acesso em 17-mar-2022):

```toml
[workspace]
members = ["member1", "path/to/member2", "crates/*"]
exclude = ["crates/foo", "path/to/other"]
```

No exemplo acima, foram incluidos 3 caminhos, e excluidos 2.

---

## CLI em workspaces

[topo](#lição-6---enums)

Se executarmos comandos como ```cargo build``` ou ```cargo test``` em uma crate que pertence a uma workspace, todos as crates serão afetadas também.

Para especificar o comando para apenas uma crate, adicionamos a "flag" ``` -p ```, ```--package``` ou ```--workspace``` ao comando.

Para testar ```lesson_6_1_simple``` execute:

```bash
cargo test -p lesson_6_1_simple -- --nocapture --test-threads=1
```

```--nocapture``` faz imprimir o output de todos os testes.

```--test-threads=1``` faz todos os testes serem executados em um thread. Tornando o output legivel.

```bash
cargo build -p lesson_6_1_simple --target wasm32-unknown-unknown --release
```

Os arquivos '.wasm' estarão em './lesson_6_enums/target/wasm32-unknown-unknown/release/'.

```bash
cargo doc --lib --document-private-items -p lesson_6_1_simple --open
```

Gera documentação da sub-lição 6-1 e abre no browser padrão.

 - ```--lib``` especifica que a crate é um library.
 - ```--document-private-items``` pede para gerar documentação de todos os items.
 - ```--open``` abre o website no navegador padrão.

Documentação estará em './target/doc/lesson_6_1_simple/index.html'.

---

 - A proxima seção será sobre [declaração e uso de enums](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/PT-BR/lesson_6_enums/lesson_6_1_simple/).
 - A proxima lição será sobre traits.

'''
'''--- PT-BR/lesson_6_enums/lesson_6_1_simple/Cargo.toml ---
[package]
name = "lesson_6_1_simple"
version = "0.1.0"
authors = ["Lucas Lemos <stiltztinkerstein@gmail.com>"]
license = "MIT"
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"

'''
'''--- PT-BR/lesson_6_enums/lesson_6_1_simple/Readme.md ---
# Lição 6 - 1 Uso de Enums

[voltar](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/lesson_6_enums/)

Essa lição descreve enums e instruções ```match```.

---

## API de contrato

```rust
// /src/lib.rs

/// Podemos usar instruções match para Strings e &str.
/// 
/// Esta função é um exemplo. 
/// 
/// Retorna 1, 2, 3, 4, 5, se o argumento for o número.
/// 
/// Causa panic se for outro valor.
pub fn string_match_example(&self, arg: String) -> u32;

/// Retorna example_0.
pub fn get_example_0(&self) -> Example0;

/// Retorna example_1.
pub fn get_example_1(&self) -> Example1;

/// Retorna example_2.
pub fn get_example_2(&self) -> Example2User;

/// Chama Example0::get_number.
pub fn example_0_get_number(&self) -> u32;

/// Chama Example0::is_third.
pub fn example_0_is_third(&self) -> bool;

/// Chama Example1::get.
pub fn example_1_get(&self) -> String;

/// Chama Example1::is_novalue.
pub fn example_1_is_novalue(&self) -> bool;

/// Chama Example1::get_an_integer.
pub fn example_1_get_an_integer(&self) -> String;

/// Chama Example1::has_an_odd_number.
pub fn example_1_has_an_odd_number(&self) -> bool;

/// Chama Example2User::get_name.
pub fn example_2_get_name(&self) -> String;

/// Chama Example2User::has_permission.
pub fn example_2_has_permission(&self, permission: String) -> bool;

/// Chama Example2User::get_actions.
/// 
/// Quando retornamos um Vec, o serializer tentará usar serde::json.
/// A instrução #[result_serializer] nos permite selecionar borsh como serializador.
#[result_serializer(borsh)]
pub fn example_2_get_actions(&self) -> Vec<String>;
```

---

## Compilando, testando

[topo](#lição-6---1-uso-de-enums)

Essa crate pertence ao workspace da lição 6. Instruções sobre compilação e execução de testes na pagina [anterior](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/lesson_6_enums/lesson_6_1_simple/).

Executar comandos como ```cargo test``` e ```cargo build``` afetará todos as crates na workspace. A não ser que uma crate seja especificada.

---

## Tópicos

[topo](#lição-6---1-uso-de-enums)

 - [O que são enums](#o-que-são-enums)
 - [Instruções match](#instruções-match)
   - [String patterns](#string-patterns)
   - [Match precisa aplicar a todos possiveis patterns](#match-precisa-aplicar-a-todos-possiveis-patterns)
   - [Acessando apenas um valor de um enum](#acessando-apenas-um-valor-de-um-enum)
 - [Enums que "englobam" valores](#enums-que-"englobam"-valores)
 - [Funções devem especificar tipos](#funções-devem-especificar-tipos)
   - [Função is_no_value](#função-is_no_value)
   - [Função get_an_integer](#função-get_an_integer)
   - [Função has_an_odd_number](#função-hasanoddnumber)
 - [Exemplo de uso: Usuário](#exemplo-de-uso-usuário)
   - [Enums limitam as possibilidades](#enums-limitam-as-possibilidades)
   - [Função get_name](#função-get_name)
   - [Função has_permission](#função-has_permission)
   - [Função get_actions](#função-get_actions)
   - [Escolhendo serializador](#escolhendo-serializador)
 - [Proxima seção](#proxima-seção)

---

## O que são enums

[topo](#lição-6---1-uso-de-enums)

Enquanto Structs armazenam diversos valores simultaneamente. Enums armazenam um valor de cada vez. As alternativas que um enum pode representar são descritos na definição.

```rust
pub enum Example0{
    First,
    Second,
    Third,
    Fourth,
    Fifth,
}
```

Acima temos um exemplo de enum.
 - ```pub``` descreve que o enum está disponivel para ser usado em módulos externos.
 - ```Example0``` é o nome do enum.
 - ```First```, ```Second```, ```Third```, ```Fourth``` e ```Fifth``` são os nomes dos valores que este enum pode possuir.

Acima temos a declaração do enum, mas como criamos uma instância de enum? A seguir criamos um exemplo para os 5 valores possiveis.

```rust
let a = Example0::First;
let b = Example0::Second;
let c = Example0::Third;
let d = Example0::Fourth;
let e = Example0::Fifth;
```

Para implementar ações de acordo com os valores do enum. Poderiamos usar instruções ```if|else```. Mas existe uma ferramenta muito mais potente para isso. A seguir, discutiremos sobre instruções ```match```.

---

## Instruções match

[topo](#lição-6---1-uso-de-enums)

Instruções match comparam um valor com diversos possiveis valores.

```rust
// /src/model.rs
impl Example0{

    /// Observa o valor de si mesmo e retorna um número entre 1 e 5.
    /// 
    /// Note o &self, significando que a função acessa o valor, mas não altera.
    /// 
    pub fn get_number(&self) -> u32 {
        log("Calling Example0::get_number");

        // Instruções match são semelhantes a uma 
        match self {
            Example0::First => {1},
            Example0::Second => {2},
            Example0::Third => {3},
            Example0::Fourth => {4},
            Example0::Fifth => {5},
        }
    }
```

O exemplo acima simplesmente compara o valor do enum e retorna um inteiro.
 - ```Example0::First``` retorna 1;
 - ```Example0::Second``` retorna 2;
 - ```Example0::Third``` retorna 3;
 - ```Example0::Fourth``` retorna 4;
 - ```Example0::Fifth``` retorna 5;

É semelhante a uma instrução switch em linguagens como c, python, java e javascript. Porém, instruções ```switch``` comparavam ```booleans```, instruções ```match``` de rust comparam patterns.

---

### String patterns

[topo](#lição-6---1-uso-de-enums)

Podemos usar instruções match para ```String``` e ```&str```:

```rust
// /src/lib.rs

impl Contract{
    /// Podemos usar instruções match para Strings e &str.
    /// 
    /// Esta função é um exemplo. 
    /// 
    /// Retorna 1, 2, 3, 4, 5, se o argumento for o número.
    /// 
    /// Causa panic se for outro valor.
    pub fn string_match_example(&self, arg: String) -> u32 {

        // Trata a referencia &String como &str
        return match &arg as &str {
            "1" => 1,
            "2" => 2,
            "3" => 3,
            "4" => 4,
            "5" => 5,
            value => panic!("Received {}. Must be 1, 2, 3, 4 or 5.", value),
        }
    }
```

No exemplo acima, a instrução match compara os padrões de cima para baixo.
 - &arg é "1"? Não.
 - &arg é "2"? Não.
 - &arg é "3"? Não.
 - &arg é "4"? Não.
 - &arg é "5"? Não.
 - ```value``` é um nome de variável. Este pattern é sempre verdadeiro. Patterns serão explicados em detalhes na próxima lição.

Qualquer String que não seja "1", "2", "3", "4" ou "5", alcançará o ultimo branch. Ou seja, resultará em panic com o valor da String.

---

### match precisa aplicar a todos possiveis patterns

[topo](#lição-6---1-uso-de-enums)

No [primeiro exemplo](#instruções-match), o enum possui 5 possiveis valores. Apague um dos branches e o compilador resultará em erro.

```rust
match self {
    Example0::First => {1},
    Example0::Second => {2},
    Example0::Third => {3},
    Example0::Fourth => {4},
    // Branch apagada, resultará em erro.
    // Instruções match precisam considerar todos possiveis valores.
    // Example0::Fifth => {5},
}
```

O [segundo exemplo](#string-patterns) compara um String. Strings podem possuir infinitos valores. Por isso, a ultima branch é:

```rust
value => panic!("Received {}. Must be 1, 2, 3, 4 or 5.", value),
```

O pattern ```value``` pode ser qualquer nome de variável. Este pattern é o mais simples possivel. Portanto, este aplica para qualquer valor possivel. Muitas vezes este pattern é demonstrado com "underline" "_", iniciar o nome de uma variável com "underline" descreve ao compilador que não temos intenção de utiliza-la.

Um exemplo. Digamos que escrevamos o match de Strings da seguinte forma:

```rust
// /src/model.rs
pub fn string_match_example(&self, arg: String) -> u32 {

    // Mesmo que o exemplo anterior. Mas não utiliza value.
    return match &arg as &str {
        "1" => 1,
        "2" => 2,
        "3" => 3,
        "4" => 4,
        "5" => 5,
        value => {
            // Compilador irá enviar um aviso acima: "Variável não usada"
            panic!("Invalid value. Must be 1, 2, 3, 4 or 5.");
        },
    }
}
```

Para corrigir o aviso em "value". Basta fazer a modificação:

```rust
// /src/model.rs
pub fn string_match_example(&self, arg: String) -> u32 {

    // Mesmo que o exemplo anterior. Mas não utiliza _value.
    return match &arg as &str {
        "1" => 1,
        "2" => 2,
        "3" => 3,
        "4" => 4,
        "5" => 5,
        _value => {
            // Aviso corrigido.
            panic!("Invalid value. Must be 1, 2, 3, 4 or 5.");
        },
    }
}
```

Como convenção, simplesmente usamos "_" como o nome de patterns irrelevantes:

```rust
// /src/model.rs
pub fn string_match_example(&self, arg: String) -> u32 {

    // Mesmo que o exemplo anterior. Mas não utiliza _.
    return match &arg as &str {
        "1" => 1,
        "2" => 2,
        "3" => 3,
        "4" => 4,
        "5" => 5,
        _ => {
            // Aviso corrigido.
            panic!("Invalid value. Must be 1, 2, 3, 4 or 5.");
        },
    }
}
```

---

### Acessando apenas um valor de um enum

[topo](#lição-6---1-uso-de-enums)

Digamos que tenhamos uma função que só precisa aplicar a um enum. Instruções match podem ser usadas também. A função abaixo retorna verdadeiro apenas se o valor do enum for ```Example::Third```:

```rust
// /src/model.rs
/// true se o valor for Exemplo0::THIRD
pub fn is_third(&self) -> bool {
    log("Calling Example0::is_third");

    match self {
        Example0::Third => true,
        _ => false,
    }
}
```

---

## Enums que "englobam" valores

[topo](#lição-6---1-uso-de-enums)

Enums podem armazenar valores:

```rust
// /src/model.rs
pub enum Example1{
    NoValue,
    AnInteger(i32),
    AFloat(f32),
    AString(String),
    ATuple(i32, u32),
    ACLikeStruct{first: u32, second: String},
}
```

No exemplo acima. A primeira alternativa não tem valor, as 4 seguintes são tuplas com os respectivos tipos. A ultima alternativa é semelhante a um "struct da linguagem C".

---

## Funções devem especificar tipos

[topo](#lição-6---1-uso-de-enums)

Funções para enums podem ser dificeis de implementar, devido a uma regra de linguagens de programação de tipo estático "statically typed":

 - Os tipos de argumentos devem ser especificados.
 - Os tipos de retorno devem ser especificados.

Isso inclui funções genéricas. Que serão explicados adiante. O compilador **deve** saber qual o tipo do argumento que recebe e qual tipo de valor irá retornar. Funções genéricas são apenas uma forma de gerar funções que seguem essas regras.

Ao implementar uma simples função get ou set, um desenvolvedor pode ter dificuldades lidando com o compilador. A segunda alternativa é um inteiro, a terceira é um número real, a quarta é um string...

Porém, é possivel implementar estas funções. A pergunta que precisamos fazer é: Como usar o mesmo tipo para o argumento e retorno?

Explicaremos implementação de genéricos na lição sobre traits. No caso de uso adiante, podemos simplesmente retornar um String:

```rust
// /src/model.rs

// O método a seguir retorna apenas um tipo, isso é aceitável para o compilador.
pub fn get(&self) -> String {
    log("Calling Example1::get");

    match self{
        Example1::NoValue => String::from(""),
        Example1::AnInteger(valor) => format!("{}", valor),
        Example1::AFloat(valor) => format!("{}", valor),
        Example1::AString(valor) => format!("{}", valor),
        Example1::ATuple(valor0, valor1) => format!("({}, {})", valor0, valor1),
        Example1::ACLikeStruct { first, second } => format!("{{\nfirst: {},\nsecond: \"{}\",\n}}\n", first, second),
    }
}
```

```format!``` é um macro que formata uma String. Macros são explicados na lição 5. Como a intenção é simplesmente imprimir o valor na tela. Retornar um String é aceitável, neste caso de uso.

A lição sobre traits explicará como usar as traits borsh e serde. Podemos usar essas ferramentas para converter um struct para uma fatia (slice) de bytes. Podemos também converter uma fatia de bytes ou String para um struct (se compativel).

A lição sobre traits também explicará sobre como usar genéricos. Que é uma forma de implementar a mesma função para diversos tipos simultaneamente.

---

### Função is_no_value

[topo](#lição-6---1-uso-de-enums)

As vezes, precisamos checar apenas um valor. Retorna verdadeiro se o valor interno for ```NoValue```.

```rust
// /src/model.rs
/// true se o enum for Example1::NoValue.
pub fn is_no_value(&self) -> bool{
    log("Calling Example1::is_no_value");

    match self{
        Example1::NoValue => true,
        _ => false,
    }
}
```

---

### Função get_an_integer

[topo](#lição-6---1-uso-de-enums)

Retorna um inteiro, se a alternativa for ```Example1::AnInteger```.

Retorna um ```Option```, será explicado em detalhes na proxima seção. Simplificando, é um enum que representa um valor que pode existir ou não. Se o valor existir, é ```Option::Some(valor)``` ou simplesmente ```Some(valor)```. Se o valor não existir, é então ```Option::None``` ou simplesmente ```None```.

```rust
// /src/model.rs
pub fn get_an_integer(&self) -> Option<i32>{
    log("Calling Example1::get_an_integer");

    match self{
        Example1::AnInteger(valor) => Some(valor.clone()),
        _ => None
    }
}
```

Considere a instrução:

```rust
match self{
```

Esta instrução deveria estar coletando ```ownership``` de si mesmo, porque não está fazendo isso?

Isso é devido ao argumento:

```rust
pub fn get_an_integer(&self) -> Option<i32>{
```

Como apenas ```&self``` está sendo usado, o compilador entende que este valor é apenas uma referência.

Finalizando:

```rust
match self{
    Example1::AnInteger(valor) => Some(valor.clone()),
    _ => None
}
```

A função retorna ```Option<i32>```. Portanto, esta instrução ```match``` rust retorna ```Some(valor)``` ou ```None```. Representando se o valor foi encontrado ou não.

---

### Função has_an_odd_number

[topo](#lição-6---1-uso-de-enums)

Retorna verdadeiro se possui um inteiro impar.

O propósito desta função é demonstrar um uso mais detalhado de instruções match.

```rust
// /src/model.rs
/// Retorna true se possui algum numero inteiro impar,
pub fn has_an_odd_number(&self) -> bool {
    log("Calling Example1::has_an_odd_number");

    match self {
        Example1::NoValue => false,
        Example1::AnInteger(valor) => {
            if valor%2 == 1{
                return true;
            }
                
            return false;
        },
        Example1::AFloat(_valor) => false,
        Example1::AString(_valor) => false,
        Example1::ATuple(valor0, valor1) => {
            return (valor0%2 == 1) || (valor1%2 == 1);
        },
        Example1::ACLikeStruct { first, second: _ } => {
            // Não temos interesse no segundo valor que é String
            first%2 == 1
        },
    }
}
```

As únicas alternativas que possuem inteiros são ```Example1::AnInteger```, ```Example1::ATuple``` e ```Example1::ACLikeStruct```. Todas as outras alternativas retornam falso.

Note que variáveis com nome ```_valor``` e ```_``` são valores que não pretendemos usar. A convenção é simplesmente usar underline ```_```. Usando outro nome apenas para demonstrar que todas as variáveis que começam com o caractere underline ```_``` são variáveis que consideramos "irrelevantes". O compilador ignora avisos de "variável não utilizada" nestes casos.

---

## Exemplo de uso: Usuário

[topo](#lição-6---1-uso-de-enums)

O próximo exemplo descreve um exemplo de aplicação para um enum.

```rust
// /src/model.rs
pub enum Example2User{
    Admin{ name: String, id: u32, pass: String, actions: Vec<String> },
    Client{ name: String, id: u32, orders: Vec<String> },
    Employee( Employee ),
}

pub struct Employee{
    pub name: String,
    pub id: u32,
    pub pass: String,
    pub permissions: Vec<String>,
    pub actions: Vec<String>,
}
```

Neste caso, existem 3 tipos de pessoas que podem acessar o nosso sistema:
 - Funcionários que podem acessar o sistema, podem fazer algumas alterações limitadas, mas não podem alterar regras críticas.
 - Administradores que tem permissões para alterar regras críticas.
 - Clientes que não tem permissões para alterar dados do sistema. Mas podem alterar os próprios dados, além de acessar os serviços do sistema.

Como descrito acima, funcionarios, administradores e clientes são tipos/objetos diferentes. Possuem finalidades e estados diferentes. Mas, no contexto de usuário, são usados da mesma forma.

Traits também são usados para agrupamento. Também devem ser considerados no planejamento de projeto. Aqui está a diferença entre agrupamento com enums e agrupamento com traits:
 - Enums nos permitem agrupar diversos tipos diferentes para uma única funcionalidade.
 - Traits nos permitem agrupar uma funcionalidade para diversos tipos diferentes.

---

### Enums limitam as possibilidades

[topo](#lição-6---1-uso-de-enums)

Isso é bom em alguns casos, ruim em outros. Importante entender essa característica. 

Por exemplo, digamos que tenhamos um jogo de xadrez. Existem diversas peças diferentes no tabuleiro. Eu implementei o meu projeto de xadrez da seguinte forma:

```rust
// https://github.com/On0n0k1/NCD.L1--Chess/blob/main/src/pieces/piece.rs
pub enum Piece{
    BISHOP( Bishop ),
    EMPTY(  Empty  ),
    KING(   King   ),
    KNIGHT( Knight ),
    PAWN(   Pawn   ),
    QUEEN(  Queen  ),
    ROOK(   Rook   ),
}
```

Cada peça tem sua funcionalidade, mas o tabuleiro não tem interesse por isso. O tabuleiro precisa de receber uma lista de possiveis movimentos para calcular cheque-mate. Independente de qual peça esteja naquela posição.

Neste caso, a limitação de enums é util, porque sabemos que existem 6 peças de xadrez diferentes (mais um para espaço vazio), e nunca será necessário expandir este enum.

Enums também são úteis para erros. Consideremos, como exemplo, um app de uma biblioteca. Uma função para coletar informação sobre um livro retorna os seguintes erros:

```rust
pub enum MessageError{
    BookNotFound(String),
    InvalidArg(String),
    MissingArg(String),
    NoPermission,

}
```

Os erros são:
 - ```BookNotFound```: Livro não encontrado. O String é o nome do livro procurado.
 - ```InvalidArg```: Algum dos argumentos recebidos não pode ser reconhecido. O String é o argumento referido.
 - ```MissingArg```: Para o pedido especificado, um argumento necessário estava ausente. String é o argumento.
 - ```NoPermission```: Não possui permissão para acessar o livro. Talvez seja um caso do usuário ser menor de idade, e o livro possuir conteúdo adulto.

Isso é outra vantagem da "limitação" de enums. Um desenvolvedor sabe exatamente todos os erros possíveis que podem ocorrer com esse chamado de função.

---

### Função get_name

[topo](#lição-6---1-uso-de-enums)

A função get_name do ```Example2User``` simplesmente retorna o ```String``` "name" armazenado. As variáveis com nome "_" são variáveis que iremos ignorar.

```rust
// /src/model.rs
/// Retorna nome do usuário.
/// 
/// O bloco que chama o método não precisa de saber o que o usuário é.
pub fn get_name(&self) -> String {
    log("Calling Example2User::get_name");

    match self {
        Example2User::Admin { name, id: _, pass: _, actions: _ } => { name.clone() },
        Example2User::Client { name, id: _, orders: _ } => { name.clone() },
        Example2User::Employee( employee ) => { employee.name.clone() },
    }
}
```

---

### Função has_permission

[topo](#lição-6---1-uso-de-enums)

Esta função retorna se o usuário possui permissão ou não para uma dada ação no sistema.
 - Administradores sempre possuem permissão.
 - Clientes nunca possuem permissão.
 - Funcionários possuem uma lista alterável de permissões.

Usar Strings não é uma boa idéia para permissões. Enums seriam melhores, mas o exemplo já está complexo o suficiente.

```rust
// /src/model.rs
pub fn has_permission(&self, permission: String) -> bool{
    // imprime na tela que a função foi chamada
    log("Calling Example2User::has_permission");

    match self{
        Example2User::Client { name: _, id: _, orders: _ } => { false },
        Example2User::Admin { name: _, id: _, pass: _, actions: _ } => { true },
        Example2User::Employee(employee) => {

            // Vec implementa a trait Iterator.
            // Isso disponibiliza o método .iter ao vetor.
            // Este método nos permite iterar referencias de String.
            // Nenhuma cópia de String é feita.
            for employee_permission in employee.permissions.iter(){
                if permission == *employee_permission {
                    return true;
                }
            }

            false
        }
    }
}
```

Funcionário possui um ```Vec``` de Strings representando suas permissões. ```Vec``` será explicado em detalhes na lição sobre coleções. É uma lista alterável de valores.

Já explicamos sobre as traits ```Clone``` e ```Copy```. Agora explicaremos sobre a trait ```Iterator``` ([detalhes oficiais](https://doc.rust-lang.org/std/iter/trait.Iterator.html)). Esta trait nos permite usar o vetor em uma instrução ```for```.

O método ```iter()```, disponilizado pela trait ```Iterator```, gera um iterador de referências. Ou seja, cada ```employee_permission``` é uma referência a um elemento pertencente ao ```Vec```. Não podemos alterar os valores, mas não gastamos computação gerando cópias.

A instrução:

```rust
if permission == *employee_permission {
    return true;
}
```

Note o operador "*". ```employee_permission``` é do tipo ```&String```. Precisamos acessar o valor do String, não da referência. Se fosse ```&&String```, acessariamos o valor com ```**employee_permission```.

Ou seja, se o argumento da função ```permission``` for igual à String acessada, retorna verdadeiro. Senão, continua iterando.

---

### Função get_actions

[topo](#lição-6---1-uso-de-enums)

A função ```get_actions``` retorna a lista de ações mais recentes realizadas pelo usuário.

Essa função da uma breve introdução ao enum ```Result``` que será explicado em detalhes na proxima sub-lição. Simplificando, é um enum que representa uma ação que pode causar um erro.

Neste exemplo, decidimos que a função deve retornar um erro se o usuário for cliente.

```rust
// /src/model.rs
pub fn get_actions(&self) -> Result<Vec<String>, String> {
    log("Calling Example2User::get_actions");
    
    // Se for client, retorna um erro (Como exemplo).
    // Se for admin ou employee, retorna referencia para o Vec.
    let actions = match self{
        Example2User::Client { name: _, id: _, orders: _ } => { return Err(format!("User is Client")); },
        Example2User::Admin { name: _, id: _, pass: _, actions, } => { actions },
        Example2User::Employee( employee ) => { &employee.actions },
    };

    let mut result: Vec<String> = Vec::new();
    // Usa a referência para criar uma cópia do Vec.
    for action in actions{
        result.push(action.clone());
    }

    Ok(result)
}
```

Note que a função retorna ```Result<Vec<String>, String>```. O primeiro dos tipos ```Vec<String>``` é o que consideramos uma operação de sucesso. O segundo dos tipos ```String``` é o tipo que será retornado se a operação resultar em erro.

Note o bloco em que este erro é chamado:

```rust
return Err(format!("User is Client"));
```

E o bloco em que a operação é um sucesso:

```rust
Ok(result)
```

```Result::Ok(value)``` ou simplesmente ```Ok(value)``` é uma operação de sucesso. ```Result::Err(err)``` ou simplesmente ```Err(err)``` é uma operação de falha. 

---

**Detalhe**: o valor entre parènteses não precisa de ser ```value``` ou ```err```. 

```err``` é apenas convenção para erros em ```Result```.

---

**Outro detalhe**:

```rust
let mut result: Vec<String> = Vec::new();
// Usa a referência para criar uma cópia do Vec.
for action in actions{
    result.push(action.clone());
}
```

Não podemos simplesmente retornar o vetor encontrado. Este pertence ao enum. Neste caso, precisamos criar uma cópia. 
 - Criamos um ```Vec<String>``` vazio. 
 - Iteramos cada um dos valores.
 - Em cada iteração, cria uma cópia ```action.clone()``` de um elemento, e inclui este valor ao fim do vetor ```result.push(action.clone());```

---

### Escolhendo serializador

[topo](#lição-6---1-uso-de-enums)

Uma instrução diferente pode ser notada na implementação de ```example_2_get_actions``` do contrato:

```rust
// /src/lib.rs
#[result_serializer(borsh)]
pub fn example_2_get_actions(&self) -> Vec<String>{
```

Isso é para evitar um erro que irá confundir muitos desenvolvedores começando na plataforma. A instrução ```#[result_serializer(borsh)]``` diz ao near_sdk para usar o serializador borsh na saida dessa função.

Existem duas ferramentas de serialização/deserialização disponiveis para ```near_sdk```: serde e borsh. Como padrão, ```near_sdk``` usa serde para deserializar o coleções como Vec. Mas o problema é que, para isso não causar erros, precisamos implementar as traits ```Serialize``` e ```Deserialize``` ao nosso contrato.

Simplesmente selecionando borsh como serializador de resultado da função, evitamos diversos erros. ```borsh``` é mais rápido que ```serde```. Tente evitar usar ```serde``` o máximo possivel.

---

## Proxima Seção

[topo](#lição-6---1-uso-de-enums)

A [próxima seção](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/PT-BR/lesson_6_enums/lesson_6_2_thermometer) será um exemplo prático utilizando Todos os conceitos discutidos anteriormente, mais alguns extras.

A próxima lição será sobre Traits.

'''
'''--- PT-BR/lesson_6_enums/lesson_6_1_simple/src/lib.rs ---
use near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize},
    serde::{Deserialize, Serialize},
};
#[allow(unused_imports)]
use near_sdk::{env, near_bindgen};

near_sdk::setup_alloc!();

mod model;

use model::{
    Example0,
    Example1,
    Example2User,
    log,
};

/// Imprime a função sendo chamada.
pub fn log_call(name: &str){
    log(&format!("Calling {}", name));
}

#[near_bindgen]
#[derive(Clone, Default, BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Contract {
    example_0: Example0,
    example_1: Example1,
    example_2_user: Example2User,
}

#[near_bindgen]
impl Contract{
    /// Podemos usar instruções match para Strings e &str.
    /// 
    /// Esta função é um exemplo. 
    /// 
    /// Retorna 1, 2, 3, 4, 5, se o argumento for o número.
    /// 
    /// Causa panic se for outro valor.
    pub fn string_match_example(&self, arg: String) -> u32 {

        // Trata a referencia &String como &str
        return match &arg as &str {
            "1" => 1,
            "2" => 2,
            "3" => 3,
            "4" => 4,
            "5" => 5,
            value => panic!("Received {}. Must be 1, 2, 3, 4 or 5.", value),
        }
    }

    /// Retorna example_0.
    pub fn get_example_0(&self) -> Example0 {
        log_call("get_example_0");
        self.example_0.clone()
    }

    /// Retorna example_1.
    pub fn get_example_1(&self) -> Example1 {
        log_call("get_example_1");
        self.example_1.clone()
    }

    /// Retorna example_2.
    pub fn get_example_2(&self) -> Example2User {
        log_call("get_example_2");
        self.example_2_user.clone()
    }

    /// Chama Example0::get_number.
    pub fn example_0_get_number(&self) -> u32 {
        log_call("get_example_0_get_number");
        self.example_0.get_number()
    }

    /// Chama Example0::is_third.
    pub fn example_0_is_third(&self) -> bool {
        log_call("get_example_0_is_third");
        self.example_0.is_third()
    }

    /// Chama Example1::get.
    pub fn example_1_get(&self) -> String {
        log_call("get_example_1_get");
        self.example_1.get()
    }

    /// Chama Example1::is_novalue.
    pub fn example_1_is_novalue(&self) -> bool {
        log_call("get_example_1_is_novalue");
        self.example_1.is_no_value()
    }

    /// Chama Example1::get_an_integer.
    pub fn example_1_get_an_integer(&self) -> String {
        log_call("get_example_1_get_an_integer");
        let the_integer : Option<i32> = self.example_1.get_an_integer();

        match the_integer {
            Some(value) => {
                format!("{}", value)
            },
            None => {
                String::from("")
            }
        }
    }

    /// Chama Example1::has_an_odd_number.
    pub fn example_1_has_an_odd_number(&self) -> bool {
        log_call("get_example_1_has_an_odd_number");
        self.example_1.has_an_odd_number()
    }

    /// Chama Example2User::get_name.
    pub fn example_2_get_name(&self) -> String {
        log_call("get_example_2_get_name");
        self.example_2_user.get_name()
    }

    /// Chama Example2User::has_permission.
    pub fn example_2_has_permission(&self, permission: String) -> bool {
        log_call("get_example_2_has_permission");
        self.example_2_user.has_permission(permission)
    }

    /// Chama Example2User::get_actions.
    /// 
    /// 
    /// Quando retornamos um Vec, o serializer tentará usar serde::json.
    /// A instrução #[result_serializer] nos permite selecionar borsh como serializador.
    #[result_serializer(borsh)]
    pub fn example_2_get_actions(&self) -> Vec<String>{
        log_call("get_example_2_get_actions");

        let result = self.example_2_user.get_actions();

        let result: Vec<String> = match result {
            Err(err) => panic!("Error: {}\n", err),
            Ok(value) => value,
        };

        result
    }
}

#[cfg(test)]
mod tests{
    use super::*;
    use near_sdk::{
        AccountId,
        env,
        MockedBlockchain,
        testing_env,
        test_utils::VMContextBuilder,
        json_types::ValidAccountId,
    };

    fn env_setup(){
        let mut builder: VMContextBuilder = VMContextBuilder::new();

        // attributes we can set with the builder:
        // current_account_id
        // signer_account_id
        // signer_account_pk
        // precessor_account_id
        // block_index
        // block_timestamp
        // epoch_height
        // account_balance
        // account_locked_balance
        // storage_usage
        // attached_deposit
        // prepaid_gas
        // random_seed
        // is_view

        let account_id: AccountId = String::from("stiltztinkerstein");

        builder.current_account_id(
            ValidAccountId::try_from(
                account_id.clone()
            ).unwrap()
        );

        testing_env!(builder.build());

        assert_eq!(
            env::current_account_id(),
            account_id, 
            "Assert Error. env: {} account: {}", 
            env::current_account_id(), 
            &account_id,
        );
    }

    #[test]
    fn string_match_example(){
        let (a1, a2, a3, a4, a5) = (
            String::from("1"),
            String::from("2"),
            String::from("3"),
            String::from("4"),
            String::from("5"),
        );

        env_setup();

        let contract = Contract::default();

        // string_match_example(&self, arg: String)
        assert_eq!(contract.string_match_example(a1), 1);
        assert_eq!(contract.string_match_example(a2), 2);
        assert_eq!(contract.string_match_example(a3), 3);
        assert_eq!(contract.string_match_example(a4), 4);
        assert_eq!(contract.string_match_example(a5), 5);
    }

    /// Testa situação de erro com argumento 0.
    #[test]
    #[should_panic(expected="Received 0. Must be 1, 2, 3, 4 or 5.")]
    fn string_match_example_error(){
        env_setup();
        let contract = Contract::default();

        contract.string_match_example(String::from("0"));
    }
}
'''
'''--- PT-BR/lesson_6_enums/lesson_6_1_simple/src/model.rs ---
use near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize},
    serde::{ Serialize, Deserialize },
};    

// As duas funções a seguir são declaradas para
// termos duas implementações diferentes de uma mesma função "log".
// As mensagens chamadas com essa função log aparecerão 
// em testes e na máquina virtual.

#[cfg(test)]
pub fn log(message: &str){
    println!("{}", message);
}

#[cfg(not(test))]
pub fn log(message: &str){
    near_sdk::env::log(message.as_bytes());
}

/// Um struct possui varios valores diferentes simultâneos, um enum só pode possuir um valor.
/// Os possiveis valores de um enum são descritos em sua declaração.
/// 
/// Os possiveis valores de Exemplo0 são:
///  - Example0::FIRST
///  - Example0::SECOND
///  - Example0::THIRD
///  - Example0::FOURTH
///  - Example0::FIFTH
/// 
#[derive(BorshDeserialize, BorshSerialize, Clone, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub enum Example0{
    First,
    Second,
    Third,
    Fourth,
    Fifth,
}

impl Default for Example0{
    fn default() -> Self {
        Example0::First
    }
}

// Semelhante a structs, implementamos métodos no namespace de Exemplo0 a seguir:
impl Example0{

    /// Observa o valor de si mesmo e retorna um número entre 1 e 5.
    /// 
    /// Note o &self, significando que a função acessa o valor, mas não altera.
    /// 
    pub fn get_number(&self) -> u32 {
        log("Calling Example0::get_number");

        // Instruções match são semelhantes a uma 
        match self {
            Example0::First => {1},
            Example0::Second => {2},
            Example0::Third => {3},
            Example0::Fourth => {4},
            Example0::Fifth => {5},
        }
    }

    /// true se o valor for Exemplo0::THIRD
    pub fn is_third(&self) -> bool {

        log("Calling Example0::is_third");

        // match compara os valores iniciando do topo
        // se colocarmos um nome de variavel, o branch acerta
        // e a variavel possui o valor no bloco associado.
        //
        // Uma variável que começa com o caracter _ é uma variável que
        // não pretendemos utilizar.
        //
        // Devido a isso, _ sempre será "matched", as alternativas
        // abaixo nunca serão acessadas.
        match self {
            Example0::Third => true,
            _ => false,
            // Exemplo0::SECOND => {
            //     // Descomente esse bloco e receberá um aviso
            //     // Essa branch nunca será alcançada
            //     // Porque a branch acima aplica a qualquer pattern.
            //     false
            // },
        }
    }
}

/// Um enum permite um objeto representar vários tipos diferentes:
/// 
/// Este exemplo possui o objetivo de mostrar que usar um enum como conteiner de valores não é uma boa ideia.
/// 
/// Os métodos de enum devem retornar resultados simples.
/// Tentar retirar os valores armazenados em enums para serem usados fora adiciona complexidade desnecessária ao código.
/// 
/// Use enums para agrupar tipos diferentes que compartilham uma funcionalidade semelhante.
/// 
/// 
#[derive(Clone, BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub enum Example1{
    NoValue,
    AnInteger(i32),
    AFloat(f32),
    AString(String),
    ATuple(i32, u32),
    ACLikeStruct{first: u32, second: String},
}

impl Default for Example1{
    fn default() -> Self {
        Example1::NoValue
    }
}

impl Example1{
    // Porem, vale lembrar que um método ou função deve retornar apenas um tipo de resultado especificado.
    //
    // Um desenvolvedor pode tentar criar uma função get que retorna o valor armazenado.
    // Isso pode ser dificil de implementar.
    // 
    // A forma mais simples de uma função get seria converter para um mesmo tipo.
    // Seguem alguns exemplos:
    //  - Retornar o valor como String
    //  - Usar Borsh ou serde para serializar o valor para bytes, deserializando após o recebimento.
    //  - Implementar genéricos. serão explicados em outra lição.
    //  - Retornar um ponteiro? A possibilidade disso ser necessário é baixa. O custo de complexidade é muito alto.
    // 

    // O método a seguir retorna apenas um tipo, isso é aceitável para o compilador.
    pub fn get(&self) -> String {
        log("Calling Example1::get");

        match self{
            Example1::NoValue => String::from(""),
            Example1::AnInteger(valor) => format!("{}", valor),
            Example1::AFloat(valor) => format!("{}", valor),
            Example1::AString(valor) => format!("{}", valor),
            Example1::ATuple(valor0, valor1) => format!("({}, {})", valor0, valor1),
            Example1::ACLikeStruct { first, second } => format!("{{\nfirst: {},\nsecond: \"{}\",\n}}\n", first, second),
        }
    }

    /// true se o enum for Example1::NoValue.
    pub fn is_no_value(&self) -> bool{
        log("Calling Example1::is_no_value");

        match self{
            Example1::NoValue => true,
            _ => false,
        }
    }

    /// Retorna um inteiro, se o enum for essa alternativa.
    ///
    /// Option será explicado em detalhes na próxima seção.
    ///
    /// Option é um enum da biblioteca padrão (standard).
    /// Representa a possibilidade de possuir um valor ou não.
    /// Option pode ser Option::Some(valor) ou Option::None.
    pub fn get_an_integer(&self) -> Option<i32>{
        log("Calling Example1::get_an_integer");

        // valor será uma referência, clonamos o valor para não retornar uma referência.
        match self{
            Example1::AnInteger(valor) => Some(valor.clone()),
            _ => None
        }
    }

    /// Retorna true se possui algum numero inteiro impar,
    pub fn has_an_odd_number(&self) -> bool {
        log("Calling Example1::has_an_odd_number");

        match self {
            Example1::NoValue => false,
            Example1::AnInteger(valor) => {
                if valor%2 == 1{
                    return true;
                }
                    
                return false;
            },
            Example1::AFloat(_valor) => false,
            Example1::AString(_valor) => false,
            Example1::ATuple(valor0, valor1) => {
                return (valor0%2 == 1) || (valor1%2 == 1);
            },
            Example1::ACLikeStruct { first, second: _ } => {
                // Não temos interesse no segundo valor que é String
                first%2 == 1
            },
        }
    }
}

/// Tipo criado para o exemplo abaixo.
/// 
/// Criado apenas para mostrar um exemplo de implementação de struct em match.
/// 
#[derive(BorshDeserialize, BorshSerialize, Clone, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Employee{
    pub name: String,
    pub id: u32,
    pub pass: String,
    pub permissions: Vec<String>,
    pub actions: Vec<String>,
}

impl Default for Employee{
    fn default() -> Self {
        log("Calling Employee::default");

        Employee { 
            name: String::from("a name"), 
            id: 11, 
            pass: String::from("some random pass"), 
            permissions: vec![
                String::from("Can access google"),
                format!("Can access 9gag"),
            ], 
            actions: vec![
                String::from("Did something"),
                String::from("Did something else"),
            ],
        }
    }
}

/// Exemplo mais prático. 
/// 
/// Representa o Usuário de um aplicativo.
/// 
/// Digamos que um usuário possa ser os seguintes tipos:
///  - Cliente
///  - Funcionario
///  - Administrador
/// 
/// Podemos controlar as permissões de cada com um enum.
/// 
/// Seria melhor termos tipos struct pra cada valor, mas estamos com pressa.
/// 
/// Todos possuem nome e id, alem disso, cada um possui:
///  - Admin: passe (codificado, claro) para acesso. Lista de ações no sistema.
///  - Employee: passe (codificado) para acesso. Lista de ações. Lista de permissões no sistema.
///  - Client: apenas lista de pedidos.
/// 
#[derive(BorshDeserialize, BorshSerialize, Clone, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub enum Example2User{
    Admin{ name: String, id: u32, pass: String, actions: Vec<String> },
    Client{ name: String, id: u32, orders: Vec<String> },
    Employee( Employee ),
}

impl Default for Example2User{
    fn default() -> Self {
        log("Calling Example2User::default");

        Example2User::Employee(Employee::default())
    }
}

impl Example2User{

    /// Retorna nome do usuário.
    /// 
    /// O bloco que chama o método não precisa de saber o que o usuário é.
    pub fn get_name(&self) -> String {
        log("Calling Example2User::get_name");

        match self {
            Example2User::Admin { name, id: _, pass: _, actions: _ } => { name.clone() },
            Example2User::Client { name, id: _, orders: _ } => { name.clone() },
            Example2User::Employee( employee ) => { employee.name.clone() },
        }
    }

    /// Checa se usuário possui permissão para ação.
    /// 
    /// Não é uma boa ideia usar String para permissões. Devido a possivel erros de caracteres, etc. Enums seriam melhor.
    /// 
    /// Mas o código ja está complexo o suficiente.
    /// 
    /// Neste exempĺo:
    ///  - Clientes não possuem permissão. Sempre retorna falso.
    ///  - Administradores sempre possuem permissão. Sempre retorna true.
    ///  - Empregados podem ou não possuir permissão. Checa por permissões.
    /// 
    pub fn has_permission(&self, permission: String) -> bool{
        log("Calling Example2User::has_permission");

        match self{
            Example2User::Client { name: _, id: _, orders: _ } => { false },
            Example2User::Admin { name: _, id: _, pass: _, actions: _ } => { true },
            Example2User::Employee(employee) => {

                // Vec implementa a trait IntoIterator.
                // Isso disponibiliza o método .iter ao vetor.
                // Este método nos permite iterar referencias de String.
                // Nenhuma cópia de String é feita.
                for employee_permission in employee.permissions.iter(){
                    if permission == *employee_permission {
                        return true;
                    }
                }

                false
            }
        }
    }

    /// Retorna a lista de ações se for Admin ou Employee.
    /// 
    /// Como exemplo, digamos que o sistema precisa retornar
    /// um erro, se o usuário for um Client.
    /// 
    /// Result é semelhante a Option. Mas é usado para representar ações que podem causar erros.
    /// Explicado na proxima seção.
    pub fn get_actions(&self) -> Result<Vec<String>, String> {
        log("Calling Example2User::get_actions");
        
        // Se for client, retorna um erro (Como exemplo).
        // Se for admin ou employee, retorna referencia para o Vec.
        let actions = match self{
            Example2User::Client { name: _, id: _, orders: _ } => { return Err(format!("User is Client")); },
            Example2User::Admin { name: _, id: _, pass: _, actions, } => { actions },
            Example2User::Employee( employee ) => { &employee.actions },
        };

        let mut result: Vec<String> = Vec::new();
        // Usa a referência para criar uma cópia do Vec.
        for action in actions{
            result.push(action.clone());
        }

        Ok(result)
    }
}

#[cfg(test)]
mod tests{
    // use std::result;

    use super::*;

    #[test]
    fn example0() {
        let first = Example0::First;
        let second = Example0::Second;
        let third = Example0::Third;
        let fourth = Example0::Fourth;
        let fifth = Example0::Fifth;

        assert_eq!(first.get_number(), 1);
        assert_eq!(second.get_number(), 2);
        assert_eq!(third.get_number(), 3);
        assert_eq!(fourth.get_number(), 4);
        assert_eq!(fifth.get_number(), 5);

        assert_eq!(first.is_third(), false);
        assert_eq!(second.is_third(), false);
        assert_eq!(third.is_third(), true);
        assert_eq!(fourth.is_third(), false);
        assert_eq!(fifth.is_third(), false);
    }

    // NoValue,
    // AnInteger(i32),
    // AFloat(f32),
    // AString(String),
    // ATuple(i32, u32),
    // ACLikeStruct{first: u32, second: String},

    /// Cria 6 instâncias diferentes de Example1 para servir de exemplo.
    fn example1_create() -> (
        Example1,
        Example1,
        Example1,
        Example1,
        Example1,
        Example1,
    ){
        // Retorna uma tupla com um exemplo de cada um dos valores.
        (
            Example1::NoValue,
            Example1::AnInteger(10),
            Example1::AFloat(3.5),
            Example1::AString(String::from("A String")),
            Example1::ATuple(-5, 5),
            Example1::ACLikeStruct{first: 1, second: String::from("second")},
        )
    }

    #[test]
    /// Garante que a função get retorna as Strings esperadas.
    fn example1_get(){
        let (
            no_value,
            an_integer,
            a_float,
            a_string,
            a_tuple,
            a_c_like_struct
        ) = example1_create();

        let no_value = no_value.get();
        let an_integer = an_integer.get();
        let a_float = a_float.get();
        let a_string = a_string.get();
        let a_tuple = a_tuple.get();
        let a_c_like_struct = a_c_like_struct.get();
        

        assert!(no_value.eq_ignore_ascii_case(""));
        assert!(an_integer.eq_ignore_ascii_case("10"));
        assert!(a_float.eq_ignore_ascii_case("3.5"));
        assert!(a_string.eq_ignore_ascii_case("A String"));
        assert!(a_tuple.eq_ignore_ascii_case("(-5, 5)"));
        assert!(a_c_like_struct.eq_ignore_ascii_case(&format!("{{\nfirst: 1,\nsecond: \"second\",\n}}\n")));
    }

    /// Garante que apenas retorna true para no_value.
    #[test]
    fn example1_is_novalue(){
        let (
            no_value,
            an_integer,
            a_float,
            a_string,
            a_tuple,
            a_c_like_struct
        ) = example1_create();

        let no_value = no_value.is_no_value();
        let an_integer = an_integer.is_no_value();
        let a_float = a_float.is_no_value();
        let a_string = a_string.is_no_value();
        let a_tuple = a_tuple.is_no_value();
        let a_c_like_struct = a_c_like_struct.is_no_value();

        assert_eq!(no_value, true);
        assert_eq!(an_integer, false);
        assert_eq!(a_float, false);
        assert_eq!(a_string, false);
        assert_eq!(a_tuple, false);
        assert_eq!(a_c_like_struct, false);
    }

    #[test]
    fn example1_get_an_integer(){

        fn asserting(value: Option<i32>, expected: Option<i32>){
            let comparison = match (value, expected){
                (None, None) => true,
                (Some(first), Some(second)) => first == second,
                _ => false,
            };

            assert_eq!(comparison, true, "Failed comparison between {:?} == {:?}\n", value, expected);
        }

        let (
            no_value,
            an_integer,
            a_float,
            a_string,
            a_tuple,
            a_c_like_struct
        ) = example1_create();

        let no_value = no_value.get_an_integer();
        let an_integer = an_integer.get_an_integer();
        let a_float = a_float.get_an_integer();
        let a_string = a_string.get_an_integer();
        let a_tuple = a_tuple.get_an_integer();
        let a_c_like_struct = a_c_like_struct.get_an_integer();

        asserting(no_value, None);
        asserting(an_integer, Some(10));
        asserting(a_float, None);
        asserting(a_string, None);
        asserting(a_tuple, None);
        asserting(a_c_like_struct, None);
    }

    // Admin{ name: String, id: u32, pass: String, actions: Vec<String> },
    // Client{ name: String, id: u32, orders: Vec<String> },
    // Employee( Employee ),

    /// Cria 3 instâncias diferentes de Example2User para serem usadas nos testes.
    fn example2_user_create() -> [Example2User; 3] {
        [
            Example2User::Admin { 
                name: String::from("Lucas"), 
                id: 0, 
                pass: String::from("12345"), 
                actions: vec![
                    String::from("Signed in 24 dec 2022, 06h33m49.67s"),
                    String::from("Logged off 24 dec 2022, 09h22m01.18s"),
                ]
            },
            Example2User::Employee(Employee {
                 name: String::from("Lucas"), 
                 id: 1, 
                 pass: String::from("123456"), 
                 permissions: vec![
                     String::from("Access client logs"),
                     String::from("Access stock"),
                 ], 
                 actions : vec![
                    String::from("Signed in 25 dec 2022, 08h11m32.01s"),
                    format!("Accessed Logs from {} {} {} {}, {:02}h{:02}m{:02}.{:02}s", "Lucas", 25, "dec", 2022, 09, 45, 19, 05),
                    String::from("Logged off 25 dec 2022, 11h44m51.92s"),
                ]
            }),
            Example2User::Client { 
                name: String::from("Lucas"), 
                id: 3, 
                orders: Vec::from([
                    format!("Successful transaction. ID: {}.", 4241235)
                ]) 
            }
        ]
    }

    #[test]
    fn example2_user_get_name(){
        // Cria 3 instâncias de example2 e aplica-os aos 3 tipos abaixo.
        let [admin, employee, client] = example2_user_create();

        // Executa get_name para as 3 instâncias.
        let (result_admin, result_employee, result_client) = (
            admin.get_name(),
            employee.get_name(),
            client.get_name(),
        );

        // Garante que o valor adiquirido para os 3 é "Lucas"
        // Detalhe extra: Estamos comparando um String com um &str,
        // isso é possivel porque implementam a trait partial_eq para os tipos.
        assert_eq!(result_admin, "Lucas");
        assert_eq!(result_employee, "Lucas");
        assert_eq!(result_client, "Lucas");
    }

    #[test]
    fn example2_has_permission(){
        // Cria 3 instâncias de example2 e aplica-os aos 3 tipos abaixo.
        let [admin, employee, client] = example2_user_create();

        // Executa has_permission para as 3 instâncias.
        let (result_admin, result_employee, result_client) = (
            admin.has_permission(String::from("Access client logs")),
            employee.has_permission(String::from("Access client logs")),
            client.has_permission(String::from("Access client logs")),
        );

        assert_eq!(result_admin, true);
        assert_eq!(result_employee, true);
        assert_eq!(result_client, false);
    }

    // pub fn get_actions(&self) -> Result<Vec<String>, String> {
    
    #[test]
    fn example2_get_actions(){

        // Função para comparar vetores
        fn vec_eq(first: Result<Vec<String>, String>, second: Result<Vec<String>, String>) -> bool {
            let (first, second) = match (first, second) {
                (Err(first), Err(second)) => {
                    return first == second;
                },
                (Ok(first), Ok(second)) => {
                    (first.clone(), second.clone())
                },
                (_, _) => {
                    return false;
                }
            };

            // Ambos os vetores devem ter o mesmo número de elementos
            assert_eq!(first.len(), second.len(), "len is different");

            let length: usize = first.len();

            for counter in 0..length {
                assert_eq!(first[counter], second[counter], "Failed comparison between {} and {}", first[counter], second[counter]);
            }

            return true;
        }

        // Cria 3 instâncias de example2 e aplica-os aos 3 tipos abaixo.
        let [admin, employee, client] = example2_user_create();

        // Executa has_permission para as 3 instâncias.
        let (result_admin, result_employee, result_client) = (
            admin.get_actions(),
            employee.get_actions(),
            client.get_actions(),
        );

        // Garante que a função retorna um Ok contendo os respectivos valores.
        assert!(
            vec_eq(
                result_admin, 
                Ok(vec![
                    String::from("Signed in 24 dec 2022, 06h33m49.67s"),
                    String::from("Logged off 24 dec 2022, 09h22m01.18s"),
                ])
            )
        );

        // Mesmo para employee.
        assert!(
            vec_eq(
                result_employee,
                Ok(vec![
                    String::from("Signed in 25 dec 2022, 08h11m32.01s"),
                    format!("Accessed Logs from {} {} {} {}, {:02}h{:02}m{:02}.{:02}s", "Lucas", 25, "dec", 2022, 09, 45, 19, 05),
                    String::from("Logged off 25 dec 2022, 11h44m51.92s"),
                ]),
            )
        );

        // No caso de client, garante que retorna um erro.
        assert!(
            vec_eq(
                result_client,
                Err(format!("User is Client")),
            )
        )

    }
}
'''
'''--- PT-BR/lesson_6_enums/lesson_6_2_thermometer/Cargo.toml ---
[package]
name = "lesson_6_2_thermometer"
version = "0.1.0"
authors = ["Lucas Lemos <stiltztinkerstein@gmail.com>"]
license = "MIT"
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"

'''
'''--- PT-BR/lesson_6_enums/lesson_6_2_thermometer/Readme.md ---
# Lição 6 - 2 Termômetro

[voltar](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/lesson_6_enums/)

Neste exemplo, será visto uma aplicação prática para os conceitos descritos nas lições anteriores. Além dos conceitos anteriores, serão demonstrados tópicos como:

 - Documentação de projetos;
 - Controle de acesso de usuários;
 - Acesso cross-contract;
 - Controle de input;
 - Controle de output;
 - Traits para conversão de tipos;

---

## Indice

[topo](#lição-6---2-termômetro)

 - [Idéia](#idéia)
 - [Instalação](#instalação)
   - [Visual Studio Code](#visual-studio-code)
   - [Rust](#rust)
   - [Near-CLI](#near-cli)
 - [Comandos Bash: Compilação](#comandos-bash-compilação)
   - [Documentação](#documentação)
   - [Testes](#testes)
   - [Criação de Sub-contas para Smart Contracts](#criação-de-sub-contas-para-smart-contracts)
   - [Criação de Sub-contas para Sensores](#criação-de-sub-conta-para-sensores)
   - [Deletar Sub-conta](#deletar-sub-conta)
 - [Contrato](#contrato)
   - [Inicialização](#inicialização)
   - [allow_user](#allow_user)
   - [remove_user](#remove_user)
   - [set_format](#set_format)
   - [new_entry](#new_entry)
     - [Exemplos](#exemplos-new_entry)
     - [Pânico](#pânico-new_entry)
   - [list_update_entries](#list_update_entries)
     - [Exemplos](#exemplos-list_update_entries)
     - [Pânico](#pânico-list_update_entries)
   - [clear_entries](#clear_entries)
     - [Argumentos](#argumentos-clear_entries)
     - [Exemplo](#exemplo-clear_entries)
     - [Pânico](#pânico-clear_entries)
   - [view_get_format](#view_get_format)
   - [view_get](#view_get)
     - [Argumentos](#argumentos-view_get)
     - [Exemplo](#exemplo-view_get)
 - [Implementação](#implementação)
   - [Documentação de Projetos](#documentação-de-projetos)
     - [Comentários sobre Arquivo](#comentários-sobre-arquivo)
     - [Comentários e Documentação](#comentários-e-documentação)
     - [Exemplos/Testes em Documentação](#exemplostestes-em-documentação)
   - [Organização de Módulos](#organização-de-módulos)
   - [Controle de Acesso de Usuários](#controle-de-acesso-de-usuários)
   - [Acesso Cross-Contract](#acesso-cross-contract)
   - [Controle de Output](#controle-de-output)
   - [Controle de Input](#controle-de-input)
   - [Implementação de Traits](#implementação-de-traits)
 - [Fim](#fim)

---

## Idéia

[topo](#lição-6---2-termômetro)

Na seção anterior, foram descritos enums e como utilizar instruções match. Além das funcionalidades descritas, também podemos utilizar enums para controlar a entrada/saida de dados. 

Digamos que um desenvolvedor de aplicativos embarcados (embedded) quer monitorar os dados de diversos termômetros simultaneamente. Logo de início, foram notadas as seguintes restrições:

 - **Conectar** todos os dispositivos a um computador é inviável.
 - **Manter** a máquina como servidor 24 horas recebendo input dos sensores também é inviável.
 - **Criar** um servidor nuvem como aws também é inviável porque o desenvolvedor não quer patrocinar o foguete de algum bilhonário.

Portanto, o desenvolvedor decide criar um smart contract para armazenar os dados. A vantagem de uma alternativa dessas são:

 - **Fácil de implementar**. O usuário só precisa de uma conta para armazenar o smart contract. Uma conta para cada sensor utilizado.
 - **Fácil de automatizar**. A única coisa que muda entre cada aplicação é o nome dos contratos. Com bons scripts, desenvolvedores podem implementar o sistema em minutos.
 - **Fácil de expandir**. Este exemplo utiliza valores de temperatura. Mas o contrato pode ser facilmente alterado para receber qualquer tipo de dados.

Mas o contrato apenas coleta dados? Não executa nenhuma computação sobre os dados? A computação de dados pode ser executada localmente pelo desenvolvedor. Não há necessidade de desperdiçar gás em operações que podem ser facilmente executadas localmente.

O contrato resolve o problema de implantação e comunicação entre os dispositivos. Já existem bibliotecas eficientes para ciência de dados. Não há necessidade de reinventar a roda. 

Resumindo. Sensores enviam dados para o smart contract. O Smart Contract armazena os dados de acordo com o nome do sensor, formato de temperatura, data e tempo de recebimento. A máquina do usuário acessa o contrato e coleta os dados armazenados para processamento.

---

## Instalação

[topo](#lição-6---2-termômetro)

 - Visual Studio Code;
 - Rust;
 - Near-cli;

### Visual Studio Code

 - Link para instalação: https://code.visualstudio.com/ ;
 - Instale a extensão para rust: https://marketplace.visualstudio.com/items?itemName=Zerotaskx.rust-extension-pack ;

**Opcional**: O pacote de extensão acima instala uma extensão para a linguagem rust chamada ```Rust```. Esta extensão pode causar bugs de linting, principalmente quando analizando bibliotecas webassembly. Eu, pessoalmente, costumo desativar está extensão e ativar outra chamada ```rust-analyzer```.

**Extra**: Não tenha ```rust``` e ```rust-analyzer``` ativos simultaneamente. ```crates``` e ```Better Toml``` podem ser mantidos com ```rust-analyzer```, porém.

---

### Rust

Um script para instalação existe em: https://www.rust-lang.org/tools/install.

Após executar o script em um terminal, execute a seguinte instrução para permitir compilação para webassembly:

```bash
rustup target add wasm32-unknown-unknown
```

Para desinstalar rust e todas as ferramentas associadas:

```bash
rustup self uninstall
```

---

### Near-cli

[topo](#lição-6---2-termômetro)

[(Mais detalhes)](https://docs.near.org/docs/tools/near-cli)

É uma ferramenta npm. **Instale npm e node**. É recomendado instalar através da ferramenta **npx**, para manter controle sobre diversas versões no mesmo sistema. Existem diversos tutoriais para windows e linux. Não explicarei em mais detalhes.

Com **npm** e **node** instalado, instale **near-cli** globalmente com o seguinte comando:

```bash
npm install -g near-cli
```

---

## Comandos Bash: Compilação

[topo](#lição-6---2-termômetro)

Compile o projeto com o comando:

```bash
cargo build --target wasm32-unknown-unknown --release -p lesson_6_2_thermometer
```
 - ```--target wasm32-unknown-unknown```: Compila para webassembly;
 - ```--release```: Otimizado para produção;
 - ```-p```: Esta crate pertence ao workspace lesson_6_enums. Este comando especifica apenas lesson_6_2_thermometer para ser compilado;

---

### Documentação

[topo](#lição-6---2-termômetro)

Documentação sobre contrato implementada. Gere um website com todos os módulos executando o comando:

```bash
cargo doc --open -p lesson_6_2_thermometer
```

 - p: Como o projeto está incluido como componente de workspace da lição "lesson_6_enums". é necessário especificar a crate.

---

### Testes

[topo](#lição-6---2-termômetro)

Execute testes de unidade com a instrução:

```bash
cargo test -p lesson_6_2_thermometer
```

Isso irá testar os exemplos na documentação também.

---

### Criação de Sub-contas para Smart Contracts

[topo](#lição-6---2-termômetro)

Onde o contrato será implantado. Substitua ```your-main-account.testnet``` pelo nome de sua conta NEAR. Substitua ```your-account-name``` pelo nome da conta que quiser para armazenamento do seu contrato.

```bash
near create-account your-account-name.your-main-account.testnet --masterAccount your-main-account.testnet --initialBalance 90
```

 - ```--masterAccount```: Conta "mestre", que tem permissões administrativas sobre a sub-conta.
 - ```--initialBalance```: Quantidade de NEAR transferido pela conta "mestre" na criação desta sub-conta.

---

### Criação de sub-conta para Sensores

[topo](#lição-6---2-termômetro)

Não haverão contratos nessas sub-contas. Mas serão usadas pelos dispositivos para comunicar com a conta mestre. Substitua:

 - ```your-sub-account```: nome da conta do sensor;
 - ```your-account-name```: nome da sub-conta que possuirá o contrato;
 - ```your-main-account```: nome da sua conta mestre;

```bash
near create-account your-sub-account.your-account-name.your-main-account.testnet --masterAccount your-account-name.your-main-account.testnet --initialBalance 10
```

 - ```--masterAccount```: Conta "mestre", que tem permissões administrativas sobre a sub-conta.
 - ```--initialBalance```: Quantidade de NEAR transferido pela conta "mestre" na criação desta sub-conta.

**Recomendação**: Como exercício de prática, aprimore este contrato fazendo com que o contrato crie/delete as sub-contas automaticamente ao executar as funções ```allow_user```/```remove_user```. Não existe documentação sobre isso na versão "3.1.0". Terá que clonar manualmente o repositório, gerar documentação com o comando ```cargo doc --open``` e encontrar a seção do módulo ```env``` com detalhes sobre a instrução de criação de conta. Boa sorte!

---

### Deletar sub-conta

[topo](#lição-6---2-termômetro)

É recomendado deletar as sub-contas dos sensores antes do smart contract. O primeiro argumento é a conta a deletar, o segundo argumento é a conta que irá receber todo o NEAR armazenado.

```bash
near delete sub-conta-a-deletar.testnet conta-a-receber.testnet
```

 - ```sub-conta-a-deletar.testnet```: nome da sub-conta que pretende deletar;
 - ```conta-a-receber.testnet```: nome da sub-conta que irá receber os fundos. Se o nome for inválido, todos os fundos armazenados serão perdidos permanentemente;

---

## Contrato

[topo](#lição-6---2-termômetro)

Antes de observar o funcionamento das funções. Vale saber que após implantação, o contrato apenas permite execução de chamadas "call" para o dono (owner). Portanto, as chamadas call administrativas devem ser assinadas com o mesmo nome de conta do Smart Contract.

Outros usuários (os sensores) podem ser incluídos na lista de usuários permitidos. Cada usuário possuirá a própria lista de armazenamento de dados.

---

### Inicialização

[topo](#lição-6---2-termômetro)

O contrato inicializa automaticamente com o formato de temperatura Kelvin. O único usuário incluido na lista de permissões é o dono (owner).

---

### allow_user:

[topo](#lição-6---2-termômetro)

```bash
near call my-contract allow_user '{"account_id": "sensor-account-id.testnet"}' --accountId my-contract
```

Função call. Apenas owner tem permissão de executar esta função. Não pode ser cross-contract.

Inclui o id de conta informado na lista de usuários permitidos.

Argumentos:

 - account_id: String. Nome de usuário para incluir na lista de permissões.

Pânico:

 - Se for uma chamada cross-contract;
 - Se não for owner;
 - Se id de conta for um id inválido.
 - Se usuário ja estiver incluido.

---

### remove_user:

[topo](#lição-6---2-termômetro)

```bash
near call my-contract remove_user '{"account_id": "sensor-account-id.testnet"}' --accountId my-contract
```

Função call. Apenas owner tem permissão de executar esta função. Não pode ser cross-contract.

Exclui o id de conta informado da lista de usuários permitidos. Todos os dados armazenados relacionados a este usuário são perdidos.

Owner não pode ser removido.

Argumentos:

 - account_id: String. Nome de usuário para excluir da lista de permissões.

Pânico:
 
 - Se for uma chamada cross-contract;
 - Se o usuário chamando a função não for owner;
 - Se o nome de usuário for inválido;
 - Se o usuário informado não existir na lista de permissões;
 - Se o nome de usuário informado for o owner;

---

### set_format

[topo](#lição-6---2-termômetro)

```bash
near call my-contract set_format '{"temp_format": "Fahrenheit}' --accountId my-contract
```

```bash
near call my-contract set_format '{"temp_format": "Kelvin}' --accountId my-contract
```

```bash
near call my-contract set_format '{"temp_format": "Celsius}' --accountId my-contract
```

Função call. Apenas owner pode executar esta função. Não pode ser cross-contract.

Altera o formato de temperatura do sistema para o formado. 

Todo input de temperatura é convertido para o formato do sistema. Isso permite que diversos sensores diferentes podem ser usados simultaneamente.

Alterar o formato de temperatura não irá alterar os valores armazenados anteriormente.

 - A função call ```list_update_entries``` converte os valores armazenados antes de retornar.
 - A função de coleta view ```view_get``` retorna os valores armazenados sem conversão de valores.

Pânico:
 - Se o nome de usuário for inválido;
 - Se o usuário informado não existir na lista de permissões;
 - Se o nome de usuário informado for o owner;

---

### new_entry

[topo](#lição-6---2-termômetro)

Função call. Todos usuários permitidos podem executar esta função. Pode ser cross-contract. Adiciona um input de temperatura associado ao usuário que executou a função.

Argumentos:
 - **time**: Opcional. Tupla com estrutura ```(u8, u8, f32)``` com os valores para hora minuto e segundo, respectivamente. Se omitido, o contrato utilizará o valor do momento em que a função foi executada (UTC).
 - **date**: Opcional. Tupla com estrutura ```(i32, String, u8)``` com os valores para ano, mês e dia, respectivamente. Se omitido, o contrato utilizará o dia em que a função foi executada.
 - **temp_value**: f32, o valor de temperatura coletado. Não pode ser menor do que zero absoluto.
 - **temp_format**: Opcional, String. Se omitido, o contrato utilizará o formato de temperatura do sistema. Se o formato for diferente do formato do sistema, realizará conversão da temperatura antes de armazenar.

#### Exemplos new_entry

[topo](#lição-6---2-termômetro)

O comando abaixo armazena uma temperatura de 100.0 utilizando o formato de temperatura do sistema, no dia do sistema, no horário do sistema.

```bash
near call my-contract new_entry '{"temp_value": 100 }' --accountID my-sensor-id
```

O comando abaixo armazena uma temperatura de 100 Celsius. Utiliza o dia do recebimento da mensagem. Utiliza o horário do recebimento da mensagem.

```bash
near call my-contract new_entry '{"temp_value": 100, "temp_format": "Celsius"}' --accountID my-sensor-id
```

O comando abaixo armazena uma temperatura de 50.5 Fahrenheit. Dia 11 de fevereiro, 2022. Horário do recebimento da mensagem. **Não causará panic se a data for diferente da atual**.

```bash
near call my-contract new_entry '{"temp_value": 50.5, "temp_format": "Fahrenheit", "date: [2022, "feb", 11]"}' --accountID my-sensor-id
```

O comando abaixo armazena uma temperatura de 11.5 Fahrenheit. Data 27 de março, 2018. Horário 10:50:9.3453.

```bash
near call my-contract new_entry '{"temp_value": 11.5, "temp_format": "f", "date": [2018, "mar", 27], "time": [10, 50, 9.3453]}' --accountID my-sensor-id
```

O comando abaixo armazena uma temperatura de -45.4 Celsius. Horário 23:41:4.443. Data do recebimento da mensagem.

```bash
near call my-contract new_entry '{"temp_value": -45.4, "temp_format": "c", "time": [23, 41, 4.443]}' --accountID my-sensor-id
```

O comando abaixo armazena uma temperatura de 44.13 Kelvin. Horário do recebimento da mensagem. Data atual do recebimento da mensagem.

```bash
near call my-contract new_entry '{"temp_value": 44.13, "temp_format": "kelvin"}' --accountID my-sensor-id
```

#### Pânico new_entry

[topo](#lição-6---2-termômetro)

 - Se o **usuário** não tem permissão de acesso;
 - Se **hora** (time) não for um valor negativo ou maior do que 23;
 - Se **minuto** (time) não for um valor negativo ou maior do que 59;
 - Se **segundo** (time) for um valor negativo ou maior do que 59.9999...;
 - Se **dia** (date) for um valor inválido para o mês e ano;
 - Se **mês** (date) for um String inválido para mês;
 - Se **temp_format** for um String inválido;

---

### list_update_entries

[topo](#lição-6---2-termômetro)

Função call. Pode ser cross-contract. Retorna todas as entries associadas a um id de conta.

Todos os usuários permitidos podem acessar os próprios dados. Mas apenas owner tem permissão de acessar dados de outros usuários. Essa restrição existe para manter controle sobre consumo de gás no contrato. Outros usuários ainda podem coletar os dados utilizando a função view.

Argumentos:
 - account_id: Opcional. String. ID de usuário a ser coletado. Se omitido, retornará os dados do usuário que executou a função.

**Retorna**: Vec com todas as entries associadas ao id de conta.

#### Exemplos list_update_entries

[topo](#lição-6---2-termômetro)

O exemplo abaixo retorna todas as entries associadas ao usuário "my-sensor-id".

```bash
near call my-contract list_update_entries '{}' --accountID my-sensor-id
```

O exemplo abaixo retorna todas as entries associadas a outro usuário. Apenas owner tem permissão para isso.

```bash
near call my-contract list_update_entries '{"account_id": "my-sensor-id.testnet"}' --accountID my-contract
```

#### Pânico list_update_entries

[topo](#lição-6---2-termômetro)

 - Se usuário não tiver permissão de acesso;
 - Se usuário não for owner e estiver tentando atualizar as entries de outro usuário.
 - Se usuário não for encontrado;

---

### clear_entries

[topo](#lição-6---2-termômetro)

Função call. Apenas owner pode chamar esta função. Pode ser cross-contract. Apaga todas as entries associadas a um usuário.

O motivo da função permitir cross-contract é para facilitar automação de contrato. Contratos externos não podem incluir ou remover usuários permitidos. Mas podem adicionar entries, podem coletar dados e remover dados.

Usuários não tem permissão de utilizar essa função para evitar ações suspeitas. Caso um dos sensores for acessado por um terceiro, este terá o acesso mais limitado possivel ao sistema. Sensores deste projeto existem apenas para incluir entries. Nada mais.

#### Argumentos clear_entries

[topo](#lição-6---2-termômetro)

 - **account_id**: Opcional. String. ID de usuário para remover todas as entries. Se omitido, remove todas as entries do owner.

#### Exemplo clear_entries

[topo](#lição-6---2-termômetro)

O exemplo abaixo remove todas as entries associadas ao id "my-sensor-id".

```rust
near call my-contract clear_entries '{"account_id": "my-sensor-id.testnet"}' --accountID my-contract
```

#### Pânico clear_entries

[topo](#lição-6---2-termômetro)

 - Se o usuário não for owner;
 - Se id de conta não for encontrado;

---

### view_get_format

[topo](#lição-6---2-termômetro)

Função view. Retorna o formato de temperatura armazenado como String.

```bash
near view my-contract view_get_format '{}'
```

--- 

### view_get

[topo](#lição-6---2-termômetro)

Função view. Retorna um ou mais valores associados a um id de conta.

Note que esta função é uma função view. Não realiza computação. E ainda assim retorna dois tipos de resultado possiveis.

O tipo ```ViewGet``` é declarado em './src/utils.rs'.

```rust
#[derive(Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
#[serde(untagged)]
pub enum ViewGet{
    Single(Entry),
    Multiple(Vec<Entry>),
}
```

Com esta declaração, percebe-se:

 - serde é usado para serializar e deserializar o tipo para json;
 - ```#[serde(untagged)]``` faz a serialização mostrar os valores contidos nas tuplas no json. Neste caso ```Entry``` ou ```Vec<Entry>```.

Dessa forma, o desenvolvedor pode usar as vantagens de um enum sem afetar a experiência do usuário. Que apenas vê o resultado.

**Aviso**: Este exemplo existe apenas para demonstrar a possibilidade de retornar diversos tipos. Implementar isso em outras linguagens pode aumentar a complexidade de código desnecessariamente. Tome cuidado com as necessidades do sistema.

#### Argumentos view_get

[topo](#lição-6---2-termômetro)

 - index: u64. Opcional. Index da entry a ser retornada. Se omitida, retorna todas as entries.
 - account_id: String. ID de usuário para retornar entries.

#### Exemplo view_get

[topo](#lição-6---2-termômetro)

A instrução abaixo retorna o primeiro elemento (se existir) associado a conta de usuário "sensor-id".

```bash
near view my-contract view_get '{"index": 0, "account_id": "sensor-id.testnet"}'
```

A instrução abaixo retorna todas as entries associadas ao id de conta "sensor-id".

```bash
near view my-contract view_get '{"account_id": "sensor-id.testnet"}'
```

---

## Implementação

[topo](#lição-6---2-termômetro)

Esta seção explicará como as funcionalidades descritas acimas foram alcançadas.

 - Documentação de projetos;
 - Organização de módulos;
 - Controle de acesso de usuários;
 - Acesso cross-contract;
 - Controle de input;
 - Controle de output;
 - Implementação de traits;

---

### Documentação de projetos

[topo](#lição-6---2-termômetro)

Como descrito [acima](#documentação) o comando:

```bash
cargo doc --open --lesson_6_2_thermometer
```

Gera um website com a toda a documentação do nosso projeto. A seguir serão descritos alguns detalhes sobre documentação:

---

#### Comentários sobre arquivo

[topo](#lição-6---2-termômetro)

Se o comentário é iniciado com ```//! ```, a documentação descreve sobre todo o arquivo ```.rs```, ou seja, o módulo.

Abaixo vemos um fragmento do inicio do módulo ```Day```, localizado no caminho ```./src/entry/schedule/date/day.rs```.

```rust
//! Módulo com todas as funcionalidades necessárias para a 
//! representação de dia no contrato.
//! 
//! Usamos um inteiro u8 para representar um dia. Mas 
//! precisamos garantir que este valor é válido.
//! 
//! Devido a isso, o tipo Day é representado por um struct 
//! tupla Day(u8).
//! 
//! Quando serializado para json, o valor é visto como um 
//! número u8. Ou seja, o usuário não perceberá essa 
//! complexidade.
//! 
```

Comentários como este devem existir no início do arquivo.

Recomenda-se que estes comentários tenha um resumo sobre toda funcionalidade disponivel no módulo.

---

#### Comentários e Documentação

[topo](#lição-6---2-termômetro)

Comentários com "// " não são incluidos na documentação. Comentários com "/// " descrevem o tipo abaixo.

Como exemplo, abaixo está a implementação da função ```Day::assert_valid```, que é uma função privada.

```rust
/// # Panics
/// Se dia for invalido.
fn assert_valid(&self, current_month: &Month, current_year: &Year) {
    let &Day(day) = self;

    // Coleta o valor do ano.
    let mut current_year: i32 = current_year.get();

    // Se for negativo, converte para positivo
    if current_year < 0 {
        current_year = -current_year;
    }

    // A cada 4 anos, o mês de janeiro possui 29 dias, ao invez de 28.
    // true se for um "leap year".
    let leap_year: bool = (current_year % 4) == 0;
    // converte true para 1, false para 0.
    let leap_year: u8 = leap_year as u8;

    // source: https://www.rapidtables.com/calc/time/months-of-year.html
    let max_day: u8 = match current_month {
        &Month::January(_) => 31,
        &Month::February(_) => 28 + leap_year,
        &Month::March(_) => 31,
        &Month::April(_) => 30,
        &Month::May(_) => 31,
        &Month::June(_) => 30,
        &Month::July(_) => 31,
        &Month::August(_) => 31,
        &Month::September(_) => 30,
        &Month::October(_) => 31,
        &Month::November(_) => 30,
        &Month::December(_) => 31,
    };

    // panic se o valor do dia for maior que o valor referente ao mês.
    assert!(day <= max_day,
        "Invalid values for day. Day: {}, Month: {}, Year: {}. Day for given month and year can not be higher than {}.",
            day,
            current_month,
            current_year,
            max_day,
    )
}
```

A função acima impede que um usuário escolha um dia incorreto.

 - Se for informado o dia 31 para outubro, não ocorrerá erro;
 - Se for informado o dia 31 setembro, haverá erro. Pois não existe o dia 31 de setembro;
 - Se for informado o dia 29 de fevereiro em 2024, não haverá erro por ser ano bissexto (leap year);
 - Se for informado o dia 29 de fevereiro em 2025, haverá erro por não ser ano bissexto (leap year);

Note que os comentários escritos com "//" descrevem a implementação do código e não aparecem na documentação.

Note como os comentários escritos com "///" descrevem o elemento abaixo (neste caso, a função ```assert_valid```). Este exemplo apenas descreve que a função entra em pânico caso o dia seja inválido. Funções privadas não serão usadas por outros, então não há necessidade de documentar com extremo detalhe.

A seguir há um exemplo da função ```Month::new``` no caminho ```./src/entry/schedule/month/Month.rs```.

```rust
/// Constroi uma instância de Mês:
/// 
/// Os possiveis valores de String na esquerda são 
/// convertidos para os seguintes valores na direita:
/// 
///  - "january", "jan", "janeiro", "enero", "ene" => Month::January("January")
///  - "february", "feb", "fevereiro", "fev", "febrero" => Month::February("February")
///  - "march", "mar", "março", "marzo" => Month::March("March")
///  - "april", "apr", "abril", "abr" => Month::April("April")
///  - "may", "maio", "mayo" => Month::May("May")
///  - "june", "jun", "junho", "junio" => Month::June("June")
///  - "july", "jul", "julho", "julio" => Month::July("July")
///  - "august", "aug", "agosto", "ago" => Month::August("August")
///  - "september", "sep", "setembro", "set", "septiembre" => Month::September("September")
///  - "october", "octo", "oct", "outubro", "out", "octubre", "octu" => Month::October("October")
///  - "november", "nov", "novembro", "noviembre" => Month::November("November")
///  - "december", "dec", "dezembro", "dez", "diciembro", "dic" => Month::December("December")
/// 
/// # Panics
/// Se o argumento não for nenhum dos possiveis acima.
/// 
pub fn new(month: &str) -> Self {
    let lower_case: String = month.to_ascii_lowercase();
    
    match &lower_case[..]{
        "january" | "jan" | "janeiro" | "enero" | "ene" => Month::January(String::from("January")),
        "february" | "feb" | "fevereiro" | "fev" | "febrero" => Month::February(String::from("February")),
        "march" | "mar" | "março" | "marzo" => Month::March(String::from("March")),
        "april" | "apr" | "abril" | "abr" => Month::April(String::from("April")),
        "may" | "maio" | "mayo" => Month::May(String::from("May")),
        "june" | "jun" | "junho" | "junio" => Month::June(String::from("June")),
        "july" | "jul" | "julho" | "julio" => Month::July(String::from("July")),
        "august" | "aug" | "agosto" | "ago" => Month::August(String::from("August")),
        "september" | "sep" | "setembro" | "set" | "septiembre" => Month::September(String::from("September")),
        "october" | "octo" | "oct" | "outubro" | "out" | "octubre" | "octu" => Month::October(String::from("October")),
        "november" | "nov" | "novembro" | "noviembre" => Month::November(String::from("November")),
        "december" | "dec" | "dezembro" | "dez" | "diciembre" | "dic" => Month::December(String::from("December")),
        invalid => panic!("Invalid value for month: {}.", invalid),
    }
}
```

A documentação da função acima é detalhado. Isso porque, não apenas os usuários necessitam de informação sobre como mês é reconhecido como argumento, assim como é essencial que desenvolvedores tenham acesso ao máximo de informação possivel caso queiram modificar/adaptar este projeto para outros casos de uso.

Resumidamente, mês é convertido de uma String. Vários Strings são válidos para cada possivel valor. Por exemplo: "january", "jan", "JAN", "Janeiro", "enero" e "ene" são todos possiveis Strings que convertem para um ```Month::January(String::from("January"))```. Não é case-sensitive.

---

#### Exemplos/Testes em Documentação

[topo](#lição-6---2-termômetro)

Exemplos existentes em documentação são incluidos nos testes. Segue adiante um fragmento da documentação para o módulo no caminho "./src/entry/schedule/date/day.rs"

```rust

//! ## Examples
//! 
//! ```rust
//! # use lesson_6_2_thermometer::schedule::date::day::Day;
//! # use lesson_6_2_thermometer::schedule::date::month::Month;
//! # use lesson_6_2_thermometer::schedule::date::year::Year;
//! 
//! // not leap year
//! let month = Month::new("feb");
//! let year = Year::new(1971);
//! 
//! let day = Day::new(28, &month, &year);
//! assert_eq!(u8::from(&day), 28);
//! assert_eq!(format!("{}", day), "28");
//! assert_eq!(String::from(&day), "28");
//! 
//! // leap year
//! let month = Month::new("feb");
//! let year = Year::new(1972);
//! 
//! let day = Day::new(29, &month, &year);
//! assert_eq!(u8::from(&day), 29);
//! assert_eq!(format!("{}", day), "29");
//! assert_eq!(String::from(&day), "29");
//! 
//! ```
```

O bloco acima é testado sempre que testes de unidade são executados. 

O objetivo deste exemplo é demonstrar as implementações de traits implementadas ao tipo Day.

Linhas com "#" não aparecem na documentação. Existem para permitir o funcionamento correto dos testes. Assim como reduzem a complexidade do exemplo.

---

### Organização de Módulos

[topo](#lição-6---2-termômetro)

Ao analizar a organização dos arquivos. Um desenvolvedor pode ficar confuso sobre como os módulos foram organizados. Alguns diretórios possuem um arquivo de nome "mod.rs" e outros não. Isso é porque duas formas diferentes de declarar módulos foram usadas.

A pergunta a ser feita é "Como um diretório pode ser considerado um módulo?". Existem duas respostas:

 - Um arquivo rust com o nome do diretório existindo no mesmo caminho que o diretório.
 - O arquivo rust com nome "mod.rs" dentro do diretório.

Como exemplo:

 - O módulo "entry" se encontra no caminho ```./src/entry/mod.rs```;
 - O módulo "date" se encontra no caminho ```./src/schedule/date.rs```. O diretório se encontra no mesmo caminho ```./src/schedule/```;
 - O módulo "temperature" se encontra no caminho ```./src/temperature/mod.rs```;
 - O módulo "time" se encontra no caminho ```./src/schedule/time.rs```. O diretório se encontra no mesmo caminho;

---

### Controle de Acesso de Usuários

[topo](#lição-6---2-termômetro)

Funções call precisam ser assinadas por uma conta NEAR. Podemos controlar o acesso checando o nome da conta que fez a chamada. Quando o contrato é inicializado, apenas o owner tem permissão de acessar o contrato. Outras contas podem ser incluidas através da função ```Contract::allow_user```.

Cada conta adicionada não terá permissões administrativas. Mas terão o próprio espaço de armazenamento de dados. Terão permissão para incluir entries. E terão permissão para atualizar os valores armazenados em uma conta.

O motivo da limitação de acesso de outras contas é devido a possibilidade de terceiros conseguirem acesso aos dispositivos sem permissão e usá-los para acessar o smart contract. Caso isso aconteça, a unica ação que um dispositivo infringido pode fazer é incluir e listar entries. Uma ação que é limitada pela quantidade de gás disponível na conta do usuário sensor.

As funções que controlam acesso ao contrato são as funções privadas:

 - ```Contract::assert_owner_only```: Entra em pânico se o caller não for o owner. Owner é a mesma conta em que o contrato foi implantado (deployed).
 - ```Contract::assert_user_allowed```: Entra em pânico se o caller não for um usuário incluido na lista de permitidos. Owner se encontra na lista de permitidos.

```rust
// Garante que apenas owner está chamando a função.
fn assert_owner_only(&self){
    let predecessor: AccountId = env::predecessor_account_id();
    let owner_id: AccountId = AccountId::from(env::current_account_id());

    assert_eq!(predecessor, owner_id, "Only owner's account is allowed to make this function call.");
}

// Garante que apenas usuários permitidos podem chamar funções.
fn assert_user_allowed(&self) {
    let predecessor_id: AccountId = env::predecessor_account_id();
    let owner_id: AccountId = env::current_account_id();

    // Se a conta dono do contrato está chamando a função.
    if owner_id == predecessor_id {
        return;
    }

    // Se não for a conta dono, e não estiver incluido na lista de permitidos, causa panic.
    assert!(self.users.contains(&predecessor_id), "User not allowed to make this call.");
}
```

Através do módulo ```near_sdk::env```, temos acesso a informações relacionadas ao ambiente da máquina virtual, e informações sobre a mensagem recebida. Segue a descrição de alguns dados disponibilizados pelo módulo:

 - ```env::predecessor_account_id```: ID da ultima conta que assinou a chamada call;
 - ```env::signer_account_id```: ID da primeira conta que assinou a chamada call;
 - ```env::current_account_id```: ID da conta atual. A conta que possui o contrato;

Nas situações mais comuns, "**predecessor_account_id**" e "**signer_account_id**" são a mesma conta. Mas contratos podem chamar outros contratos (chamadas "cross-contract"), cada conta assina a chamada seguinte. Por exemplo, digamos que uma conta **A** chame um contrato **B**, que chama um contrato **C**, que chama um contrato **D**:

```
A -> B -> C -> D
```

Na situação acima. Para todas as chamadas, o "**signer_account_id**" é a conta A. 
O "**predecessor_account_id**" é:
 
 - Para o ambiente **B**, o "**predecessor_account_id**" é **A**;
 - Para o ambiente **C**, o "**predecessor_account_id**" é **B**;
 - Para o ambiente **D**, o "**predecessor_account_id**" é **C**;

Para ambos exemplos acimas. Coletamos "**owner_account_id**" e "**predecessor_account_id**". Se ambos são iguais, o **chamador** é o "**owner**". Se "**predecessor_account_id**" estiver incluido na lista de permitidos, então é um usuário permitido.

Poderiamos ter usado "**signer_account_id**". Mas isso anularia a possibilidade de chamadas cross-contract. Um desenvolvedor pode decidir adicionar mais funcionalidades a este contrato. Esta decisão manterá a oportunidade de integração com a funcionalidade de outros contratos.

---

### Acesso Cross-Contract

[topo](#lição-6---2-termômetro)

Como descrito acima. Chamada "cross-contract" é quando um contrato faz uma chamada "call" para um outro contrato. Cada conta assina a chamada seguinte. Em alguns casos isso não é desejado. Como funções que fazem alterações críticas ou caras no sistema. Funções em que o desenvolvedor não deseja que sejam chamadas automaticamente.

Isso é implementado através da função ```Contract::no_cross_contract```. Descrito a seguir:

```rust
// Garante que o chamado é direto. Não pode ser um contrato chamando outro contrato.
fn assert_no_cross_contract(&self){
    let signer_id: AccountId = env::signer_account_id();
    let predecessor_id: AccountId = env::predecessor_account_id();
    assert_eq!(signer_id, predecessor_id, "Cross-contract calls not allowed.");
}
```

Basta garantir que o "signer_account_id" é o mesmo que o "predecessor_account_id".

Isto é usado nas funções ```Contract::allow_user```, ```Contract::remove_user``` e ```Contract::set_format```. Usado na função ```Contract::set_format``` . As outras funções porque são operações administrativas que podem incluir usuários indesejados, ou remover usuários e grande quantidade de dados do sistema.
 
 - ```Contract::set_format```: pode resultar em altos consumos de gás para uma grande quantidade de dados;
 - ```Contract::allow_user```: pode incluir usuários indesejados ao sistema. É uma função pouco usada, mas essencial;
 - ```Contract::remove_user```: pode remover usuários e todos os dados associados a um respectivo usuário. Mal uso dessa função pode causar danos irreversiveis aos dados;

---

### Controle de Output

[topo](#lição-6---2-termômetro)

Uma mesma função pode retornar tipos diferentes através do uso de enums. Para isso, primeiro criamos o enum que representa todos os possiveis tipos que podem ser retornados:

```rust
// ./src/utils.rs
use near_sdk::serde::{
    Deserialize, Serialize,
};

use crate::entry::Entry;

#[derive(Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
#[serde(untagged)]
pub enum ViewGet{
    Single(Entry),
    Multiple(Vec<Entry>),
}
```

 - ```#[derive(Deserialize, Serialize)]``` aplica as traits ```near_sdk::serde::Deserialize``` e ```near_sdk::serde::Serialize``` ao enum. São necessárias para converter um json para o tipo (deserializar), e converter um tipo para json (serializar).
 - ```#[serde(crate) = "near_sdk::serde"]``` irá informar o compilador que a crate "serde" se encontra em "near_sdk::serde". Sem essa instrução, o compilador tentará encontrar "serde" em uma crate única.
 - ```#[serde(untagged)]``` é um atributo da crate "serde" que informa à crate para não usar tags para este enum. Sem este atributo, o valor é descrito como ```{ Single: valor }``` ou ```{ Multiple: [valor1, valor2, ...] }```. Com este atributo o valor é descrito como ```valor```, ou ```[valor1, valor2, ...]```, respectivamente.

Mais detalhes sobre serde e configurações no [site oficial](https://serde.rs/enum-representations.html) da crate.

Com o enum declarado e configurado. Basta retornar o tipo em uma função de contrato:

```rust
pub fn view_get(
    &self, 
    index: Option<u64>, 
    account_id: String,
) -> ViewGet {
    match index{
        None => {
            let result = self.entries
                .get(&account_id)
                .unwrap()
                .to_vec();

            ViewGet::Multiple(result)
        },
        Some(index) => {
            let result = self.entries
                .get(&account_id)
                .unwrap()
                .get(index)
                .unwrap();

            ViewGet::Single(result)
        }
    }
}
```

Note que a função acima é uma função view. Conversão de estado para json é preparado durante compilação. Ou seja, não consome gás.

A função simplesmente retorna o enum ```ViewGet``` declarado anteriormente. Se o argumento "index" existe no json, retorna ```ViewGet::Single(valor)``` com o "valor" encontrado. Se argumento "index" foi omitido, retorna ```ViewGet::Multiple(valores)``` com os "valores" encontrados.

Uso do tipo Option para argumentos é descrito logo a seguir.

---

### Controle de Input

[topo](#lição-6---2-termômetro)

Note a função abaixo. Existem vários argumentos da função do tipo ```Option```.

```rust
pub fn new_entry(
    &mut self, 
    time: Option<(u8, u8, f32)>,
    date: Option<(i32, String, u8)>,
    temp_value: f32, 
    temp_format: Option<String>,
){
    self.assert_user_allowed();
    let user: AccountId = env::predecessor_account_id();

    log("Called new_entry.");

    log("Creating Entry.");
    let entry: Entry = Entry::new(time, date, &self.temp_format, temp_value, temp_format);

    log("Acquiring entries for this user.");
    let mut entries = match self.entries.get(&user){
        None => panic!("Unexpected Behavior: Failed to find entries for this user."),
        Some(value) => value,
    };
    
    log("Pushing entry to Vector.");
    entries.push(&entry);
    assert!(self.entries.insert(&user, &entries).is_some(), "Failed to replace vector");

    log("Operation Successful.");
}
```

Option é um tipo da biblioteca standard que pode ter duas alternativas, ```Some(valor)``` ou ```None```. Se usarmos este tipo nos argumentos das nossas funções, o usuário não precisa incluir este argumento na chamada de função.

 - Se incluir, o valor do argumento é ```Some(valor)```;
 - Se não incluir, o valor do argumento é ```None```;

Usamos instruções match para considerar as duas possibilidades. Por exemplo, o ``` account_id``` é opcional para a maioria das funções de contrato.

```rust
// ./src/contract.rs

pub fn list_update_entries(
    &mut self, 
    account_id: Option<String>,
) -> Vec<Entry> {
    self.assert_user_allowed();

    // let account_id: AccountId = env::predecessor_account_id();
    let account_id = match account_id{
        None => {
            env::predecessor_account_id()
        },
        Some(value) => {
            let predecessor = env::predecessor_account_id();
```

O fragmento da função ```Contract::list_update_entries``` acima possui o argumento ```account_id``` que é um Option. Se o valor para ```account_id``` existir na mensagem, usa-o. Senão usa o ```account_id``` da conta que chamou o contrato. Essa operação é repetida em diversos outras funções.

No tópico sobre [controle de output](#controle-de-output) acima. Foi descrito como usar um enum para possuir diversos tipos diferentes para o mesmo retorno de função. Podemos usar um enum com as mesmas configurações para aceitar diversos tipos de input também. Não é necessário incluir nenhuma configuração serde adicional.

```rust
// ./src/utils.rs
use near_sdk::serde::{
    Deserialize, Serialize,
};

use crate::entry::Entry;

#[derive(Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
#[serde(untagged)]
pub enum ViewGet{
    Single(Entry),
    Multiple(Vec<Entry>),
}
```

Basta alterar os valores internos do enum de acordo com suas necessidades, e usar o tipo como argumento da função de contrato.

---

### Implementação de Traits

[topo](#lição-6---2-termômetro)

O "dia", contido em "data", contido em "schedule" é representado da seguinte forma.

```rust
// ./src/schedule/date/day.rs

#[derive(BorshDeserialize, BorshSerialize, Clone, Copy, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Day(u8);
```

É apenas um ```u8``` contido em um tipo próprio. Embora esse tipo tenha sido criado para aplicarmos as limitações que o valor de dia pode possuir. Queremos utilizar este valor como um número nos outros casos. Para isso, aplicamos as seguintes traits:

```rust
/// Nos permite usar u8::from(nossoDay)
impl From<&Day> for u8{
    fn from(day: &Day) -> u8 {
        let &Day(result) = day;

        result
    }
}

/// Nos permite usar u8::from(nossoDay)
impl From<&Day> for String{
    fn from(day: &Day) -> String {
        u8::from(day).to_string()
    }
}

// Usado para converter o struct para String. Se usarmos instruções como format!, println! ou panic!, esta trait é usada.
impl std::fmt::Display for Day {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", String::from(self))
    }
}
```

A trait ```From``` permite a conversão de um tipo para outro. Devido a essas implementações, para uma variável Day com nome day, é possivel converter para u8 e String, respectivamente, com ```u8::from(&day)``` e ```String::from(&day)```.

A trait ```std::fmt::Display``` parece complicado, mas simplesmente permite o uso do tipo em macros como ```panic```, ```format``` e ```println```. Sem esta implementação, uma instrução como ```println!("O valor de day é {}", day)``` resultaria em pânico.

---

## Fim

[topo](#lição-6---2-termômetro)

A [próxima seção](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/PT-BR/lesson_6_enums/lesson_6_3_game_score/) mostrará aplicações úteis para Result.

A próxima lição será sobre traits.

'''
'''--- PT-BR/lesson_6_enums/lesson_6_2_thermometer/src/contract.rs ---
//! Módulo de Contrato.
//! 
//! 

use near_sdk::{
    AccountId,
    BorshStorageKey,
    borsh::{self, BorshDeserialize, BorshSerialize},
    collections::{
        Vector,
        LookupMap, 
        UnorderedSet,
    },
    env,
    json_types::ValidAccountId,
    near_bindgen,
};

near_sdk::setup_alloc!();

use crate::{
    temperature::temp_format::TempFormat,
    utils::{
        log,
        ViewGet,
    },
    entry::Entry,
};

/// Utilizado para acessar o armazenamento do contrato.
/// 
/// Cada nova instância de Vector, LookupMap ou UnorderedSet precisa de um valor único de key.
/// 
/// Usamos este enum como key.
/// 
#[derive(BorshStorageKey, BorshSerialize)]
enum StorageKey {
    Entries,
    Users,
    UserEntry(String),
}

/// API de contrato:
/// 
/// Apenas usuários permitidos (ou owner) podem executar funções call ao contrato.
///
/// Funções:
///  - **allow_user**: inclui um usuário na lista de permissões de input;
///  - **remove_user**: exclui um usuário da lista de permissões de input;
///  - **set_format**: converte o formato de temperatura para outro;
///  - **new_entry**: inclui uma entry de temperatura;
///  - **list_update_entries**: atualiza todas as entries de um usuário ao formato do sistema, retornando os valores;
///  - **clear_entries**: apaga todas as entries associadas à um usuário;
///  - **view_get_format**: função view. Retorna formato armazenado;
///  - **view_get**: função view. Retorna uma entry se index especificado, retorna todos os valores armazenados por um usuário se não especificado;
/// 
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Contract {
    temp_format: TempFormat,
    entries: LookupMap<AccountId, Vector<Entry>>,
    users: UnorderedSet<AccountId>,
    temp_length: u32,
}

// Na inicialização de contrato,
// inclui dono na lista de usuários permitidos.
impl Default for Contract {
    fn default() -> Self {
        let temp_format = TempFormat::default();

        let mut entries = LookupMap::new(StorageKey::Entries);

        let owner_account: String = env::current_account_id();
        let owner_vector: Vector<Entry> = Vector::new(StorageKey::UserEntry(String::from(&owner_account)));
        let inserting = entries.insert(&owner_account, &owner_vector);
        assert!(inserting.is_none(), "Something impossible just happened. Created a LookupMap that already had a value stored.");

        let users: UnorderedSet<AccountId> = UnorderedSet::new(StorageKey::Users);

        Contract{
            temp_format,
            entries,
            users,
            temp_length: 0,
        }
    }
}

#[near_bindgen]
impl Contract{

    // Garante que apenas owner está chamando a função.
    fn assert_owner_only(&self){
        let predecessor: AccountId = env::predecessor_account_id();
        let owner_id: AccountId = AccountId::from(env::current_account_id());

        assert_eq!(predecessor, owner_id, "Only owner's account is allowed to make this function call.");
    }

    // Garante que o chamado é direto. Não pode ser um contrato chamando outro contrato.
    fn assert_no_cross_contract(&self){
        let signer_id: AccountId = env::signer_account_id();
        let predecessor_id: AccountId = env::predecessor_account_id();
        assert_eq!(signer_id, predecessor_id, "Cross-contract calls not allowed.");
    }

    // Garante que apenas usuários permitidos podem chamar funções.
    fn assert_user_allowed(&self) {
        let predecessor_id: AccountId = env::predecessor_account_id();
        let owner_id: AccountId = env::current_account_id();

        // Se a conta dono do contrato está chamando a função.
        if owner_id == predecessor_id {
            return;
        }

        // Se não for a conta dono, e não estiver incluido na lista de permitidos, causa panic.
        assert!(self.users.contains(&predecessor_id), "User not allowed to make this call.");
    }

    /// Inclui usuário na lista de permissões, cria um Vector para armazenamento de entries para este usuário.
    /// 
    /// Apenas owner tem permissão de chamar esta função.
    /// 
    /// # Panics
    ///  - Se for uma chamada cross-contract;
    ///  - Se não for owner;
    ///  - Se **account_id** for um ID de conta inválido;
    ///  - Se usuário ja estiver incluido;
    /// 
    pub fn allow_user(&mut self, account_id: String){
        self.assert_no_cross_contract();
        self.assert_owner_only();

        log("Called allow_user.");

        // Testa se o nome de usuario é válido.
        log("Validating Account ID.");
        let account_id = match ValidAccountId::try_from(account_id){
            Ok(value) => String::from(value),
            Err(err) => panic!("Invalid user account id: {}.", err),
        };

        // Se usuario ja estiver contido na lista de permissões, causa panic.
        log("Checking if user already exists.");
        let contains: bool = self.users.contains(&account_id);
        assert!(!contains, "User {} is already included in allowed list.", &account_id);
        
        // Cria um vetor para entries e inclui ao mapa.
        log("New user detected. Storing User.");
        let user_vector: Vector<Entry> = Vector::new(StorageKey::UserEntry(String::from(&account_id)));
        let inserting = self.entries.insert(&account_id, &user_vector);
        
        // A asserção abaixo deve ser impossivel de falhar. Se esta falhar, o código possui um erro de implementação.
        // Porque é esperado que a asserção acima sempre falhe antes desta.
        assert!(inserting.is_none(), "Unexpected behavior. User is already included in entries.");

        // Insere nome de usuário na lista de usuários permitidos.
        self.users.insert(&account_id);
    }

    /// Remove usuário da lista de permissões.
    /// 
    /// Apenas owner tem permissão de chamar esta função.
    /// 
    /// # Panics
    ///  - Se for cross-contract;
    ///  - Se não for owner;
    ///  - Se o nome de usuário for inválido;
    ///  - Se usuário informado não existir na lista de permissões;
    ///  - Se o nome de usuário informado for o owner;
    /// 
    pub fn remove_user(&mut self, account_id: String){
        self.assert_no_cross_contract();
        self.assert_owner_only();

        // Conta dono é criada na inicialização de contrato. A possibilidade de remover a conta dono seria um problema.
        let owner_id: AccountId = AccountId::from(env::current_account_id());
        assert_ne!(&owner_id[..], &account_id[..], "Owner account can't be removed from contract.");

        log("Called remove_user");

        log("Validating Account ID.");
        let account_id = match ValidAccountId::try_from(account_id){
            Ok(value) => String::from(value),
            Err(err) => panic!("Invalid user account id: {}.", err),
        };

        // Se usuario não estiver contido na lista de permissões, causa panic.
        log("Checking if user exists.");

        let contains: bool = self.users.contains(&account_id);
        assert!(contains, "User {} not found.", &account_id);

        // Remove vetor de entries referente ao usuario.
        let entries: Option<Vector<Entry>> = self.entries.remove(&account_id);
        assert!(entries.is_some(), "Unexpected Behavior. Found user, but didn't find entry list for user.");

        // Ownership do vetor veio do LookupMap para aqui.
        // Limpa o vetor para garantir segurança de memória.
        // Vetor será liberado da memória no fim desta função.
        let mut entries: Vector<Entry> = entries.unwrap();
        entries.clear();

        match self.users.remove(&account_id){
            true => {
                log("User successfully removed.");
            },
            false => {
                log("Unexpected Behavior. Account exists in entries but doesn't exist in user list.");
            },
        };
    }

    
    /// Altera formato de temperatura para o valor informado.
    /// 
    /// Não modifica entries armazenadas. Estas são alteradas quando retornadas pela função list_update_entries.
    /// 
    /// Apenas owner tem permissão de chamar esta função.
    /// 
    /// # Panics
    ///  - Se for cross-contract;
    ///  - Se o usuário informado não for encontrado na lista de permissões;
    ///  - Se o usuário não for owner;
    /// 
    pub fn set_format(&mut self, temp_format: String) {
        self.assert_no_cross_contract();
        self.assert_owner_only();

        log("Called set_format");

        let temp_format = TempFormat::new(&temp_format);

        log(
            &format!("Setting default temperature format to {}", &temp_format)
        );

        self.temp_format = temp_format;
    }
    

    // Exemplo de argumento para esta função: '{"time": [11, 32, 10, 0.85], "date": [2022, "feb", 11], "value": 127, "arg_temp": "k" }'

    /// Armazena um valor de temperatura associado à conta de usuário.
    /// 
    /// Date e time são opcionais. Caso não informados, o sistema usará a data e horários do recebimento da mensagem.
    /// 
    /// format é opcional. Se não informado, usará o formato de temperatura do sistema.
    /// 
    /// # Panics
    ///  - Se usuário não tem permissão de acesso;
    ///  - Se hora (time) for um valor negativo ou maior do que 23;
    ///  - Se minuto (time) for um valor negativo ou maior do que 59;
    ///  - Se segundo (time) for um valor negativo ou maior do que 59.99999....
    ///  - Se dia (date) for um valor inválido para o mês e ano;
    ///  - Se mês (date) for um String inválido para mês;
    ///  - Se temp_format for um String inválido;
    /// 
    /// # Exemplos (bash)
    ///  - new_entry '{"temp_value": 100 }'
    ///  - new_entry '{"temp_value": 100, "temp_format": "Celsius"}'
    ///  - new_entry '{"temp_value": 50.5, "temp_format": "Fahrenheit", "date: [2022, "feb", 11]"}'
    ///  - new_entry '{"temp_value": 11.5, "temp_format": "f", "date": [2018, "mar", 27], "time": [10, 50, 9.3453]}'
    ///  - new_entry '{"temp_value": -45.4, "temp_format": "c", "time": [23, 41, 4.443]}'
    ///  - new_entry '{"temp_value": 44.13, "temp_format": "kelvin"}'
    /// 
    pub fn new_entry(
        &mut self, 
        time: Option<(u8, u8, f32)>,
        date: Option<(i32, String, u8)>,
        temp_value: f32, 
        temp_format: Option<String>,
    ){
        self.assert_user_allowed();
        let user: AccountId = env::predecessor_account_id();

        log("Called new_entry.");

        log("Creating Entry.");
        let entry: Entry = Entry::new(time, date, &self.temp_format, temp_value, temp_format);

        log("Acquiring entries for this user.");
        let mut entries = match self.entries.get(&user){
            None => panic!("Unexpected Behavior: Failed to find entries for this user."),
            Some(value) => value,
        };
        
        log("Pushing entry to Vector.");
        entries.push(&entry);
        assert!(self.entries.insert(&user, &entries).is_some(), "Failed to replace vector");

        log("Operation Successful.");
    }

    /// Retorna a lista de entries associadas ao usuário, atualiza os valores com os do sistema, caso diferentes.
    /// 
    /// Se account_id for omitido, retorna as entries do usuário que chamou.
    /// 
    /// Apenas owner tem permissão de acessar e atualizar as entries de outros usuários.
    /// 
    /// # Panics
    ///  - Se usuário não tiver permissão de acesso;
    ///  - Se usuário não for owner e estiver tentando atualizar as entries de outros;
    ///  - Se usuário não for encontrado;
    /// 
    pub fn list_update_entries(
        &mut self, 
        account_id: Option<String>,
    ) -> Vec<Entry> {
        self.assert_user_allowed();

        // let account_id: AccountId = env::predecessor_account_id();
        let account_id = match account_id{
            None => {
                env::predecessor_account_id()
            },
            Some(value) => {
                let predecessor = env::predecessor_account_id();

                if predecessor != value {
                    let signer_id: AccountId = env::signer_account_id();
                    let owner_id: AccountId = AccountId::from(env::current_account_id());

                    assert_eq!(signer_id, owner_id, "Only owner's account is allowed to check entries of others.");
                }

                value
            }
        };
        
        let mut entries: Vector<Entry> = match self.entries.get(&account_id){
            None => panic!("Couldn't find entries for user {}.", account_id),
            Some(value) => value,
        };

        let mut entries_vec = entries.to_vec();

        let temp_format: TempFormat = self.temp_format.clone();
        let mut changed: bool = false;
        let mut index: u64 = 0;

        // entries.to_vec()
        for entry in entries_vec.iter_mut(){
            if entry.update_temp_format(&temp_format) {
                changed = true;
                entries.replace(index, &entry);
            };

            index += 1;
        };

        if changed {
            self.entries.insert(&account_id, &entries);
        }
        
        entries_vec
    }

    /// Apaga todas as entries associadas a um usuário.
    /// 
    /// Se account_id for omitido, apaga as entries do usuário que chamou a função.
    /// 
    /// Apenas owner tem permissão de chamar esta função.
    /// 
    /// # Panics
    ///  - Se usuário não for owner;
    ///  - Se id de conta não estiver na lista de permitidos;
    /// 
    pub fn clear_entries(
        &mut self, 
        account_id: Option<String>,
    ){
        self.assert_owner_only();
        
        let account_id: String = match account_id {
            None => env::predecessor_account_id(),
            Some(value) => {
                log("Validating user account.");

                match ValidAccountId::try_from(value){
                    Ok(account_id) => String::from(account_id),
                    Err(err) => panic!("Invalid user account id: {}.", err),
                }
            }
        };

        assert!(self.users.contains(&account_id), "Account {} not found.", &account_id);
        
        let entries: Vector<Entry> = match self.entries.remove(&account_id){
            None => panic!("Couldn't find entries for user {}.", account_id),
            Some(mut value) => {
                value.clear();
                value
            },
        };

        assert!(
            self.entries.insert(&account_id, &entries).is_none(),
            "Unexpected behavior, attempted to remove the vector for {}, but it still exists after removing.", 
            &account_id,
        );

        log(&format!("Successfully removed all entries for {}.", &account_id));
    }

    // View Functions

    /// Retorna formato de temperatura.
    pub fn view_get_format(&self) -> String {
        String::from(&self.temp_format)
    }

    /// Retorna Entry para usuario.
    /// 
    /// Se index não for especificado, retorna todos os valores associados ao usuário.
    /// 
    /// Não converte as temperaturas armazenadas (caso seja diferente do sistema.)
    /// 
    pub fn view_get(
        &self, 
        index: Option<u64>, 
        account_id: String,
    ) -> ViewGet {
        match index{
            None => {
                let result = self.entries
                    .get(&account_id)
                    .unwrap()
                    .to_vec();

                ViewGet::Multiple(result)
            },
            Some(index) => {
                let result = self.entries
                    .get(&account_id)
                    .unwrap()
                    .get(index)
                    .unwrap();

                ViewGet::Single(result)
            }
        }
    }
}

'''
'''--- PT-BR/lesson_6_enums/lesson_6_2_thermometer/src/entry/mod.rs ---
//! Entry representa um único input de um dos usuários.
//! 
//! Periodicamente cada sensor enviará o valor de temperatura coletado. O contrato armazenará cada entry associada ao tempo recebido.
//! 
//! Cada Entry possui os seguintes atributos:
//!  - temperature: Um valor de temperatura (f32), associado a um formato de temperatura (Kelvin, Celsius, Fahrenheit);
//!  - schedule: Momento de recebimento do input. Formato de tempo é UTC. Que tal implementar suporte a diversos fuso-horarios depois?
//! 

use near_sdk::{
    borsh::{ self, BorshDeserialize, BorshSerialize },
    serde::{ Deserialize, Serialize },
};

use crate::{
    schedule::Schedule,
    temperature::{
        Temperature,
        temp_format::TempFormat,
    }
};

/// Representa um momento de temperatura e tempo.
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Entry{
    schedule: Schedule,
    temperature: Temperature,
}

impl Entry{
    /// Constroi uma instância de Entry.
    /// 
    ///  - Se time (horario) for omitido. O valor será o momento da chamada da mensagem.
    ///  - Se date (data) for omitida. O valor será o dia da chamada da mensagem.
    ///  - Se o formato de temperatura for omitido, utilizará o formato de temperatura do sistema.
    ///  - value representa o valor de temperatura.
    /// 
    ///  # Panics
    ///  - se temperatura for menor que zero absoluto;
    ///  - se dia for inválido;
    ///  - se mês for inválido;
    /// 
    pub fn new(
            time: Option<(u8, u8, f32)>,
            date: Option<(i32, String, u8)>,
            temp_format: &TempFormat, 
            value: f32, 
            arg_temp: Option<String>,
        ) -> Self {
        
        let schedule: Schedule = Schedule::new(date, time);
        let temperature: Temperature = Temperature::new(value, temp_format, arg_temp);

        Entry { 
            schedule, 
            temperature,
        }
    }

    /// Se new_format for um formato de temperatura diferente do atual. Atualiza e realiza a conversão de valores.
    pub fn update_temp_format(&mut self, new_format: &TempFormat) -> bool{
        self.temperature.update_temp_format(new_format)
    }
}

'''
'''--- PT-BR/lesson_6_enums/lesson_6_2_thermometer/src/lib.rs ---
// Não queremos que este módulo apareça na documentação. Módulo é público apenas internamente.
pub(crate) mod contract;
pub mod entry;
pub mod schedule;
pub mod temperature;
pub mod utils;

pub use contract::Contract;

'''
'''--- PT-BR/lesson_6_enums/lesson_6_2_thermometer/src/schedule/date.rs ---
//! Módulo que representa data.
//! 
//! Usado por Schedule.
//! 
//! Composto por Day, Month e Year.
//! 

use near_sdk::{
    borsh::{ self, BorshDeserialize, BorshSerialize },
    serde::{ Deserialize, Serialize },
};

pub mod day;
pub mod month;
pub mod year;

use day::Day;
use month::Month;
use year::Year;

/// Representa uma data (Dia, Mês, Ano).
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Date{
    day: Day,
    month: Month,
    year: Year,
}

impl Date{
    /// Constrói uma instância de data.
    /// 
    /// # Panics
    ///  - Se Day for negativo;
    ///  - Se Day maior do que o limite para o mês e ano;
    ///  - Se Month for um String inválido;
    /// 
    pub fn new(day: u8, month: &str, year: i32) -> Date {
        // Cria uma instância de tipo representando ano.
        let year: Year = Year::new(year);
        // Cria uma instância de tipo representando mês.
        let month: Month = Month::new(month);
        // Cria uma instância de tipo representando dia.
        let day: Day = Day::new(day, &month, &year);

        Date{
            day,
            month,
            year,
        }
    }
}

'''
'''--- PT-BR/lesson_6_enums/lesson_6_2_thermometer/src/schedule/date/day.rs ---
//! Módulo com todas as funcionalidades necessárias para a 
//! representação de dia no contrato.
//! 
//! Usamos um inteiro u8 para representar um dia. Mas 
//! precisamos garantir que este valor é válido.
//! 
//! Devido a isso, o tipo Day é representado por um struct 
//! tupla Day(u8).
//! 
//! Quando serializado para json, o valor é visto como um 
//! número u8. Ou seja, o usuário não perceberá essa 
//! complexidade.
//! 
//! O tipo Day pode ser construido através da função 
//! associada Day::new. Esta função precisa do mês e ano 
//! para saber o limite máximo e se é leap year, 
//! respectivamente. Seguem outras utilidades:
//!  - u8::from(day) nos permite converter um Day para u8;
//!  - String::from(day) nos permite converter um Day para 
//! String;
//!  - std::fmt::Display é implementado, portanto podemos 
//! usar o tipo para macros como println!("{}", day) 
//! ou panic!("{}", day) .
//! 
//! ## Examples
//! 
//! ```rust
//! # use lesson_6_2_thermometer::schedule::date::day::Day;
//! # use lesson_6_2_thermometer::schedule::date::month::Month;
//! # use lesson_6_2_thermometer::schedule::date::year::Year;
//! 
//! // not leap year
//! let month = Month::new("feb");
//! let year = Year::new(1971);
//! 
//! let day = Day::new(28, &month, &year);
//! assert_eq!(u8::from(&day), 28);
//! assert_eq!(format!("{}", day), "28");
//! assert_eq!(String::from(&day), "28");
//! 
//! // leap year
//! let month = Month::new("feb");
//! let year = Year::new(1972);
//! 
//! let day = Day::new(29, &month, &year);
//! assert_eq!(u8::from(&day), 29);
//! assert_eq!(format!("{}", day), "29");
//! assert_eq!(String::from(&day), "29");
//! 
//! ```
//! 

use near_sdk::{
    borsh::{ self, BorshDeserialize, BorshSerialize },
    serde::{ Serialize, Deserialize },
};

use crate::schedule::date::{
    month::Month,
    year::Year,
};

/// Representa um valor de dia.
/// 
/// Quando serializado, este tipo é visto como um u8.
/// 
/// Garante que é um dia válido para o mês e ano.
/// 
/// Deve ser positivo e menor do que 28-31 dependendo do mês e ano.
/// 
#[derive(BorshDeserialize, BorshSerialize, Clone, Copy, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Day(u8);

impl Day{
    /// Constroi uma instância de dia.
    ///  - day: dia, valor entre 1 e 31, dependendo do mês/ano.
    ///  - current_month: mês atual, para validação.
    ///  - current_year: ano atual, para validação.
    /// 
    /// # Panics
    /// Se dia for inválido.
    /// 
    pub fn new(day: u8, current_month: &Month, current_year: &Year) -> Self {
        let day = Day(day);
        day.assert_valid(current_month, current_year);

        day
    }

    /// # Panics
    /// Se dia for invalido.
    fn assert_valid(&self, current_month: &Month, current_year: &Year) {
        let &Day(day) = self;

        // Coleta o valor do ano.
        let mut current_year: i32 = current_year.get();

        // Se for negativo, converte para positivo
        if current_year < 0 {
            current_year = -current_year;
        }

        // A cada 4 anos, o mês de janeiro possui 29 dias, ao invez de 28.
        // true se for um "leap year".
        let leap_year: bool = (current_year % 4) == 0;
        // converte true para 1, false para 0.
        let leap_year: u8 = leap_year as u8;

        // source: https://www.rapidtables.com/calc/time/months-of-year.html
        let max_day: u8 = match current_month {
            &Month::January(_) => 31,
            &Month::February(_) => 28 + leap_year,
            &Month::March(_) => 31,
            &Month::April(_) => 30,
            &Month::May(_) => 31,
            &Month::June(_) => 30,
            &Month::July(_) => 31,
            &Month::August(_) => 31,
            &Month::September(_) => 30,
            &Month::October(_) => 31,
            &Month::November(_) => 30,
            &Month::December(_) => 31,
        };

        // panic se o valor do dia for maior que o valor referente ao mês.
        assert!(day <= max_day,
            "Invalid values for day. Day: {}, Month: {}, Year: {}. Day for given month and year can not be higher than {}.",
                day,
                current_month,
                current_year,
                max_day,
        )
    }
}

/// Nos permite usar u8::from(nossoDay)
impl From<&Day> for u8{
    fn from(day: &Day) -> u8 {
        let &Day(result) = day;

        result
    }
}

/// Nos permite usar u8::from(nossoDay)
impl From<&Day> for String{
    fn from(day: &Day) -> String {
        u8::from(day).to_string()
    }
}

// Usado para converter o struct para String. Se usarmos instruções como format!, println! ou panic!, esta trait é usada.
impl std::fmt::Display for Day {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", String::from(self))
    }
}

'''
'''--- PT-BR/lesson_6_enums/lesson_6_2_thermometer/src/schedule/date/month.rs ---
//! Módulo com todas as funcionalidades necessárias para a 
//! representação de mês no contrato.
//! 
//! Para uma fácil implementação rust, utilizamos um enum 
//! com todos os possiveis valores de mês.
//! Mas para representação json, a melhor opção é utilizar 
//! um String, ou número.
//! 
//! Configurando serde, podemos utilizar o melhor de ambos 
//! os casos. Primeiro, declaramos o enum da seguinte forma:
//! 
//! ```
//!use near_sdk::{
//!    borsh::{ self, BorshDeserialize, BorshSerialize },
//!    serde::{ Deserialize, Serialize },
//!};
//! 
//! #[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
//! #[serde(crate = "near_sdk::serde")]
//! pub enum Month{
//!     January(String),
//!     February(String),
//!     March(String),
//!     April(String),
//!     May(String),
//!     June(String),
//!     July(String),
//!     August(String),
//!     September(String),
//!     October(String),
//!     November(String),
//!     December(String),
//! }
//! ```
//! 
//! Se o valor de Month for 
//! Month::December(String::from("December")), 
//! por exemplo, o valor de estado aparecerá 
//! como month: {December: "December"}.
//! 
//! Mas, se incluirmos o atributo macro 
//! serde(untagged), da seguinte forma:
//! 
//! ```
//!use near_sdk::{
//!    borsh::{ self, BorshDeserialize, BorshSerialize },
//!    serde::{ Deserialize, Serialize },
//!};
//! 
//! #[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
//! #[serde(crate = "near_sdk::serde")]
//! #[serde(untagged)]
//! pub enum Month{
//!     January(String),
//!     February(String),
//!     March(String),
//!     April(String),
//!     May(String),
//!     June(String),
//!     July(String),
//!     August(String),
//!     September(String),
//!     October(String),
//!     November(String),
//!     December(String),
//! }
//! ```
//! 
//! Um valor de mês 
//! Month::december(String::from("December")), 
//! irá aparecer simplesmente como month: "December". 
//! O que é muito mais user-friendly.
//! 
//!  - u8::from(&month) converte um mês para um inteiro 
//! de 0 a 11. Não consome o mês;
//!  - Month::from(a_u8_var) converte um valor u8 
//! informado para Month. Panic se não for um valor 
//! entre 0 a 11.
//!  - String::from(&month) constroi uma String com 
//! o mesmo valor de Month.
//!  - String::from(month) consome o Month, convertendo-o 
//! para um String.
//!  - std::fmt::Display é implementado para Month. 
//! Podendo ser utilizado em macros como println!, 
//! format! e panic!;
//! 

use near_sdk::{
    borsh::{ self, BorshDeserialize, BorshSerialize },
    serde::{ Deserialize, Serialize },
};

/// Representa um mês.
/// 
/// Devido a instrução "serde(untagged)" o valor deste 
/// enum é representado por um String.
/// 
/// Pode ser convertido de/para um String.
/// 
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
#[serde(untagged)]
pub enum Month{
    January(String),
    February(String),
    March(String),
    April(String),
    May(String),
    June(String),
    July(String),
    August(String),
    September(String),
    October(String),
    November(String),
    December(String),
}

impl Month{
    /// Constroi uma instância de Mês:
    /// 
    /// Os possiveis valores de String na esquerda são 
    /// convertidos para os seguintes valores na direita:
    /// 
    ///  - "january", "jan", "janeiro", "enero", "ene" => Month::January("January")
    ///  - "february", "feb", "fevereiro", "fev", "febrero" => Month::February("February")
    ///  - "march", "mar", "março", "marzo" => Month::March("March")
    ///  - "april", "apr", "abril", "abr" => Month::April("April")
    ///  - "may", "maio", "mayo" => Month::May("May")
    ///  - "june", "jun", "junho", "junio" => Month::June("June")
    ///  - "july", "jul", "julho", "julio" => Month::July("July")
    ///  - "august", "aug", "agosto", "ago" => Month::August("August")
    ///  - "september", "sep", "setembro", "set", "septiembre" => Month::September("September")
    ///  - "october", "octo", "oct", "outubro", "out", "octubre", "octu" => Month::October("October")
    ///  - "november", "nov", "novembro", "noviembre" => Month::November("November")
    ///  - "december", "dec", "dezembro", "dez", "diciembro", "dic" => Month::December("December")
    /// 
    /// # Panics
    /// Se o argumento não for nenhum dos possiveis acima.
    /// 
    pub fn new(month: &str) -> Self {
        let lower_case: String = month.to_ascii_lowercase();
        
        match &lower_case[..]{
            "january" | "jan" | "janeiro" | "enero" | "ene" => Month::January(String::from("January")),
            "february" | "feb" | "fevereiro" | "fev" | "febrero" => Month::February(String::from("February")),
            "march" | "mar" | "março" | "marzo" => Month::March(String::from("March")),
            "april" | "apr" | "abril" | "abr" => Month::April(String::from("April")),
            "may" | "maio" | "mayo" => Month::May(String::from("May")),
            "june" | "jun" | "junho" | "junio" => Month::June(String::from("June")),
            "july" | "jul" | "julho" | "julio" => Month::July(String::from("July")),
            "august" | "aug" | "agosto" | "ago" => Month::August(String::from("August")),
            "september" | "sep" | "setembro" | "set" | "septiembre" => Month::September(String::from("September")),
            "october" | "octo" | "oct" | "outubro" | "out" | "octubre" | "octu" => Month::October(String::from("October")),
            "november" | "nov" | "novembro" | "noviembre" => Month::November(String::from("November")),
            "december" | "dec" | "dezembro" | "dez" | "diciembre" | "dic" => Month::December(String::from("December")),
            invalid => panic!("Invalid value for month: {}.", invalid),
        }
    }

    // jan 31
    // feb 59
    // mar 90
    // apr 120
    // may 151
    // jun 181
    // jul 212
    // aug 243
    // sep 273
    // octo 304
    // nov 334
    // dec 365

    /// Recebe um valor entre 0 e 365. Retorna o mês e 
    /// dia do ano, baseado no dia do ano.
    /// 
    /// Se is_leap_year é true. Aceita uma valor entre 
    /// 0 e 366. 29 fev é uma possibilidade de data.
    /// 
    pub fn new_from_days(mut days: u64, is_leap_year: bool) -> (String, u8) {
        // 0 false 1 true
        let leap_year: u64 =  is_leap_year as u64;
        assert!(days < 365 + leap_year, "Unexpected Behavior. Days should be lower than {}. Got {}.", 365 + leap_year, days);
        // day 0 = jan 1
        days += 1;

        if days <= 31 {
            return (String::from("jan"), days as u8);
        }
        if days <= 59 + leap_year {
            // inclui feb 29 se for leap year
            return (String::from("feb"), days as u8 - 31);
        }
        if days <= 90 + leap_year {
            return (String::from("mar"), (days - 59 - leap_year) as u8);
        }
        if days <= 120 + leap_year {
            return (String::from("apr"), (days - 90 - leap_year) as u8);
        }
        if days <= 151 + leap_year {
            return (String::from("may"), (days - 120 - leap_year) as u8);
        }
        if days <= 181 + leap_year {
            return (String::from("jun"), (days - 151 - leap_year) as u8);
        }
        if days <= 212 + leap_year {
            return (String::from("jul"), (days - 181 - leap_year) as u8);
        }
        if days <= 243 + leap_year {
            return (String::from("aug"), (days - 212 - leap_year) as u8);
        }
        if days <= 273 + leap_year {
            return (String::from("sep"), (days - 243 - leap_year) as u8);
        }
        if days <= 304 + leap_year {
            return (String::from("oct"), (days - 273 - leap_year) as u8);
        }
        if days <= 334 + leap_year {
            return (String::from("nov"), (days - 304 - leap_year) as u8);
        }

        (String::from("dec"), (days - 334 - leap_year) as u8)  
    }

    /// Retorna uma representação String deste Mês.
    pub fn get(&self) -> String {
        match self {
            Month::January(value) => value.clone(),
            Month::February(value) => value.clone(),
            Month::March(value) => value.clone(),
            Month::April(value) => value.clone(),
            Month::May(value) => value.clone(),
            Month::June(value) => value.clone(),
            Month::July(value) => value.clone(),
            Month::August(value) => value.clone(),
            Month::September(value) => value.clone(),
            Month::October(value) => value.clone(),
            Month::November(value) => value.clone(),
            Month::December(value) => value.clone(),
        }
    }
}

/// Nos permite utilizar u8::from(&nossoMonth) para 
/// conver um mês para u8.
impl From<&Month> for u8 {
    fn from(month: &Month) -> u8 {
        match month {
            Month::January(_) => 0,
            Month::February(_) => 1,
            Month::March(_) => 2,
            Month::April(_) => 3,
            Month::May(_) => 4,
            Month::June(_) => 5,
            Month::July(_) => 6,
            Month::August(_) => 7,
            Month::September(_) => 8,
            Month::October(_) => 9,
            Month::November(_) => 10,
            Month::December(_) => 11,
        }
    }
}

/// Nos permite utilizar Month::from(nossou8) para 
/// converter um valor u8 para Month.
impl From<u8> for Month {
    fn from(month: u8) -> Month {
        match month{
            0 => Month::new("jan"),
            1 => Month::new("feb"),
            2 => Month::new("mar"),
            3 => Month::new("apr"),
            4 => Month::new("may"),
            5 => Month::new("jun"),
            6 => Month::new("jul"),
            7 => Month::new("aug"),
            8 => Month::new("sep"),
            9 => Month::new("oct"),
            10 => Month::new("nov"),
            11 => Month::new("dec"),
            invalid => panic!("Invalid value for month: {}. Number value must be positive, lower than 12.", invalid),
        }
    }
}

/// Nos permite usar String::from(nossoMonth)
impl From<&Month> for String{
    fn from(month: &Month) -> String {
        month.get()
    }
}

/// Nos permite usar String::from(nossoMonth)
impl From<Month> for String{
    fn from(month: Month) -> String {
        String::from(&month)
    }
}

/// Usado para converter o struct para String. Se 
/// usarmos instruções como format!, println! ou panic!, 
/// esta trait é usada.
impl std::fmt::Display for Month {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", String::from(self))
    }
}

#[cfg(test)]
mod tests{
    use crate::utils::log;
    use crate::schedule::Month;

    #[test]
    /// Testa a função Month::new_from_days para todos 
    /// os dias do ano, leap year e não leap year.
    fn new_from_days(){

        /// usado por testing year. Argumentos:
        ///  - days: valor entre 0 e 365. 0 e 366 se 
        /// is_leap_year = true.
        ///  - is_leap_year: true se for leap year
        ///  - expected_month: mes esperado, valor entre 
        /// 0 e 12.
        ///  - expected_day: dia esperado, valor entre 
        /// 0 e 31, depende do mês e leap year.
        /// 
        fn util_day_constructor(days: u64, is_leap_year: bool, expected_month: u8, expected_day: u8) {
            let (month_str, day) = Month::new_from_days(days, is_leap_year);
            let month_number = u8::from(&Month::new(&month_str));
    
            assert_eq!(
                month_number, 
                expected_month, 
                "Comparison error when constructing day. Expected month: {}, number: {}. Got {}.", 
                Month::from(expected_month), 
                expected_month, 
                month_number,
            );

            assert_eq!(
                day, 
                expected_day, 
                "Comparison error when constructing day. Expected day: {}. Got: {}.", 
                expected_day, 
                day,
            );
        }

        /// Usa util_day_constructor para testar todos 
        /// os dias do ano.
        fn testing_year(is_leap_year: bool){
            let leap_year = is_leap_year as u64;

            #[allow(unused_mut)]
            let mut day_number;
            #[allow(unused_mut)]
            let mut month_number;

            for day in 0..(365 + leap_year) {
                if day < 31 { 
                    day_number = day;
                    month_number = 0; 
                } else if day < 59 + leap_year{ 
                    day_number = day - 31;
                    month_number = 1; 
                } else if day < 90 + leap_year { 
                    day_number = day - 59 - leap_year;
                    month_number = 2;  
                } else if day < 120 + leap_year{ 
                    day_number = day - 90 - leap_year;
                    month_number = 3; 
                } else if day < 151 + leap_year{ 
                    day_number = day - 120 - leap_year;
                    month_number = 4; 
                } else if day < 181 + leap_year { 
                    day_number = day - 151 - leap_year;
                    month_number = 5; 
                } else if day < 212 + leap_year{ 
                    day_number = day - 181 - leap_year;
                    month_number = 6; 
                } else if day < 243 + leap_year{ 
                    day_number = day - 212 - leap_year;
                    month_number = 7; 
                } else if day < 273 + leap_year{ 
                    day_number = day - 243 - leap_year;
                    month_number = 8; 
                } else if day < 304 + leap_year{ 
                    day_number = day - 273 - leap_year;
                    month_number = 9; 
                } else if day < 334 + leap_year{ 
                    day_number = day - 304 - leap_year;
                    month_number = 10; 
                } else { 
                    day_number = day - 334 - leap_year;
                    month_number = 11; 
                }

                // Primeiro dia do mês é 1. 
                util_day_constructor(day, is_leap_year, month_number, day_number as u8 + 1)
             }
        }

        // Testa a construção de day para todos os dias do ano. Não é leap year.
        log("Testing for non leap year.");
        testing_year(false);

        // Testa a construção de day para todos os dias do ano. É leap year.
        log("Testing for leap year.");
        testing_year(true);
    }
}

'''
'''--- PT-BR/lesson_6_enums/lesson_6_2_thermometer/src/schedule/date/year.rs ---
//! Módulo com todas as funcionalidades necessárias para o 
//! funcionamento de um ano no contrato.
//! 
//! Ano é representado por uma tupla com um inteiro e um 
//! String.
//! 
//! - String::from(year) converte um Year para String;
//! - String::from(&year) converte uma referência para 
//! String;
//! - std::fmt::Display é implementado. Portanto pode 
//! ser usado em macros como format!, println! e panic!;
//! 

use near_sdk::{
    borsh::{ self, BorshDeserialize, BorshSerialize },
    serde::{ Deserialize, Serialize },
};

/// Tupla representando um valor de ano. 
/// 
/// O primeiro valor (i32) é um inteiro para computação.
///  
/// O segundo é um String representando o valor formatado.
/// 
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Year(i32, String);

impl Year{
    /// Constrói uma instância de Year.
    pub fn new(mut value: i32) -> Year {
        let is_negative = value < 0;
        if is_negative{
            value = -value;
        }

        let text: &str = match is_negative{
            false => {
                "BC"
            },
            true => {
                "AD"
            }
        };

        let text: String = format!("{} {}", value, text);
        if is_negative {
            value = -value;
        }

        Year(value, text)
    }

    /// Retorna ano como i32.
    pub fn get(&self) -> i32 {
        // Year é uma tupla, .0 acessa o primeiro valor da tupla.
        // i32 implementa copy, então não precisamos de escrever self.0.clone()
        self.0
    }
}

/// Nos permite usar String::from(&nossoYear)
impl From<&Year> for String{
    fn from(year: &Year) -> String {
        year.1.clone()
    }
}

/// Nos permite usar String::from(nossoYear)
impl From<Year> for String{
    fn from(year: Year) -> String {
        String::from(&year)
    }
}

// Usado para converter o struct para String. Se usarmos instruções como format!, println! ou panic!, esta trait é usada.
impl std::fmt::Display for Year {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", String::from(self))
    }
}

'''
'''--- PT-BR/lesson_6_enums/lesson_6_2_thermometer/src/schedule/mod.rs ---
//! Módulo para um schedule (cronograma).
//! 
//! Um valor de temperatura não possui muita utilidade sem um tempo associado. Este é o objetivo desse tipo.
//! 
//! Composto por Date e Time. Usado em Entry.
//! 
//! Pode ser fornecido como parâmetro ou gerado automaticamente com o momento do sistema.
//! 

use near_sdk::{
    borsh::{ self, BorshDeserialize, BorshSerialize },
    env,
    serde::{ Deserialize, Serialize },
};

pub mod date;
pub mod time;

use date::Date;
use time::Time;

use self::date::month::Month;

use crate::utils::log;

/// Representa o momento de recebimento da temperatura.
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Schedule{
    date: Date,
    time: Time,
}

impl Schedule{
    
    fn remainder_from_value(mut value: u64, max: u64) -> (u64, u64) {
        let remainder: u64 = value % max;
        value = (value - remainder) / max;

        (value, remainder)
    }

    fn time_from_nanoseconds(nano: u64) -> (u8, u8, f32) {
        // recolhe toda a porção menor do que um dia.
        let (_, remainder) = Self::remainder_from_value(nano, 24 * 60 * 60 * 1_000_000_000);
        let (hours, remainder) = Self::remainder_from_value(remainder, 60 * 60 * 1_000_000_000);
        let (minutes, seconds) = Self::remainder_from_value(remainder, 60 * 1_000_000_000);

        (hours as u8, minutes as u8, seconds as f32 / 1_000_000_000.)
    }

    fn date_from_nanoseconds(nano: u64) -> (i32, String, u8) {
        // Somamos 2 anos ao valor de nanosegundos. Dessa forma estará sincronizado com os leap years, em 1968, em vez de 1970.
        let nano: u64 = nano + 2 * 365 * 24 * 60 * 60 * 1_000_000_000;

        let max: u64 = (365.25 as f64 * 24. * 60. * 60. * 1_000_000_000.) as u64;
        let (year, remainder) = Self::remainder_from_value(nano, max);

        let is_leap_year = year % 4 == 0;

        let max = 24 * 60 * 60 * 1_000_000_000;

        // full_days é uma quantidade de dias entre 366 e 0.
        // O valor remainder (Horas, minutos, segundos) é descartado.
        let (full_days, _) = Self::remainder_from_value(remainder, max);
        let (month, day) = Month::new_from_days(full_days, is_leap_year);
        
        // No inicio do calculo de data por nanosegundos. Somamos 2 anos ao valor recebido, para garantir que está em sincronia com os leap years.
        (year as i32 + 1968, month, day)
    }

    /// Construtor de schedule (data e horario).
    /// 
    /// date: tupla com estrutura (year, month, day).
    /// time: tupla com estrutura (hour, minute, second).
    /// 
    pub fn new(date: Option<(i32, String, u8)>, time: Option<(u8, u8, f32)>) -> Self {
        
        // Retorna o momento exato da chamada dessa instrução.
        // Valor em nanosegundos. Quantos nanosegundos desde: 1, jan, 1970.
        let block_time: u64 = env::block_timestamp();
        let (year, month, day) = match date{
            Some(value) => value,
            None => {
                log("Date wasn't specified, using current date.");
                Self::date_from_nanoseconds(block_time)
            },
        };
        
        let (hour, minute, second) = match time{
            Some(value) => value,
            None => {
                log("Time wasn't specified, using current time");
                Self::time_from_nanoseconds(block_time)
            }
        };

        log(&format!("Epoch time is {}.", block_time));
        log(&format!("Day: {}, Month: {}, Year: {}", day, &month, year));
        log(&format!("Hour: {}, Minute: {}, Second: {}", hour, minute, second));

        let date: Date = Date::new(day, &month, year);
        let time: Time = Time::new(hour, minute, second);

        Schedule { 
            date,
            time,
        }
    }
}

'''
'''--- PT-BR/lesson_6_enums/lesson_6_2_thermometer/src/schedule/time.rs ---
//! Módulo que representa tempo.
//! 
//! Usado por Schedule.
//! 
//! Composto por por Hour, Minute, Second.
//! 

use near_sdk::{
    borsh::{ self, BorshDeserialize, BorshSerialize },
    serde::{ Deserialize, Serialize },
};

pub mod hour;
pub mod minute;
pub mod second;

use hour::Hour;
use minute::Minute;
use second::Second;

/// Representa tempo (hora, minuto, segundo).
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Time{
    hour: Hour,
    minute: Minute,
    second: Second,
}

impl Time {
    /// Constroi uma instância de Time.
    /// 
    /// # Panics
    ///  - se hora >= 24;
    ///  - se minute >= 60;
    ///  - se second >= 60. ;
    ///  - se second < 0. ;
    /// 
    pub fn new(hour: u8, minute: u8, second: f32) -> Time{
        let hour: Hour = Hour::new(hour);
        let minute: Minute = Minute::new(minute);
        let second: Second = Second::new(second);

        Time{
            hour,
            minute,
            second
        }
    }
}

'''
'''--- PT-BR/lesson_6_enums/lesson_6_2_thermometer/src/schedule/time/hour.rs ---
//! Módulo para hora.
//! 
//! O formato json desse tipo é apenas um u8.
//! 
//!  - u8::from(&hour) converte essa referência para um u8;
//!  - u8::from(hour) converte este Hour para um u8;
//!  - Hour::from(esteu8) converte um valor u8 para  Hour;
//! 

use near_sdk::{
    borsh::{ self, BorshDeserialize, BorshSerialize },
    serde::{ Deserialize, Serialize },
};

/// Tipo que representa hora.
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Hour(u8);

impl Hour{
    pub fn new(hour: u8) -> Hour {
        assert!(hour < 24, "Invalid value for hour. Must be lower than 24. Current: {}.", hour);

        Hour(hour)
    }
}

/// Nos permite usar u8::from(&nossoHour)
impl From<&Hour> for u8{
    fn from(hour: &Hour) -> u8 {
        let &Hour(result) = hour;

        result
    }
}

/// Nos permite usar u8::from(nossoHour)
impl From<Hour> for u8{
    fn from(hour: Hour) -> u8 {
        u8::from(&hour)
    }
}

/// Nos permite usar Hour::from(nossou8)
impl From<u8> for Hour{
    fn from(hour: u8) -> Hour {
        Hour::new(hour)
    }
}

'''
'''--- PT-BR/lesson_6_enums/lesson_6_2_thermometer/src/schedule/time/minute.rs ---
//! Módulo para minuto.
//! 
//! O formato json desse tipo é apenas um u8.
//! 
//!  - u8::from(&minute) converte essa referência para um u8;
//!  - u8::from(minute) converte este Minute para um u8;
//!  - Minute::from(esteu8) converte um valor u8 para Minute;
//! 

use near_sdk::{
    borsh::{ self, BorshDeserialize, BorshSerialize },
    serde::{ Deserialize, Serialize },
};

/// Representa um valor de minuto.
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Minute(u8);

impl Minute {
    /// Constrói uma instância de minuto.
    /// 
    /// # Panics
    /// 
    /// Se valor é menor do que 60.
    /// 
    pub fn new(minute: u8) -> Minute{
        assert!(minute < 60, "Invalid value for minute. Must be lower than 60. Current: {}.", minute);

        Minute(minute)
    }
}

/// Nos permite usar u8::from(&nossoMinute)
impl From<&Minute> for u8{
    fn from(minute: &Minute) -> u8 {
        let &Minute(result) = minute;

        result
    }
}

/// Nos permite usar u8::from(nossoMinute)
impl From<Minute> for u8{
    fn from(minute: Minute) -> u8 {
        u8::from(&minute)
    }
}

/// Nos permite usar Minute::from(nossou8)
impl From<u8> for Minute{
    fn from(minute: u8) -> Minute {
        Minute::new(minute)
    }
}

'''
'''--- PT-BR/lesson_6_enums/lesson_6_2_thermometer/src/schedule/time/second.rs ---
//! Módulo para segundo.
//! 
//! O formato json desse tipo é apenas um f32.
//! 
//!  - f32::from(&second) converte essa referência para um f32;
//!  - f32::from(second) converte este Minute para um f32;
//!  - Minute::from(estef32) converte um valor f32 para Second;
//! 

use near_sdk::{
    borsh::{ self, BorshDeserialize, BorshSerialize },
    serde::{ Deserialize, Serialize },
};

/// Representa um valor de segundo.
/// 
/// Serializado, este tipo é apenas um f32.
/// 
/// # Panics
/// 
///  - Se valor for maior ou igual a 60;
///  - Se o valor for negativo;
/// 
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Second(f32);

impl Second {
    pub fn new(second: f32) -> Second{
        assert!(second < 60., "Invalid value for second. Must be lower than 60. Current: {}.", second);
        assert!(second >= 0., "Invalid value for second. Can't be negative. Current: {}.", second);

        Second(second)
    }
}

/// Nos permite usar f32::from(&nossoSecond)
impl From<&Second> for f32{
    fn from(second: &Second) -> f32 {
        let &Second(result) = second;

        result
    }
}

/// Nos permite usar f32::from(nossoSecond)
impl From<Second> for f32{
    fn from(second: Second) -> f32 {
        f32::from(&second)
    }
}

/// Nos permite usar Second::from(nossof32)
impl From<f32> for Second{
    fn from(second: f32) -> Second {
        Second::new(second)
    }
}

'''
'''--- PT-BR/lesson_6_enums/lesson_6_2_thermometer/src/temperature/mod.rs ---
//! Módulo que representa temperatura.
//! 
//! Composto por um valor (value) e um formato de temperatura (temp_format).
//! 
//! O contrato armazena um formato de temperatura do sistema.
//! 
//! Se a mensagem não informar formato de temperatura, utiliza o do sistema.
//! 
//! Se o formato de temperatura for diferente do formato da mensagem, converte a temperatura da mensagem antes de armazenar/retornar.
//! 

pub mod temp_format;

use near_sdk::{
    borsh::{ self, BorshDeserialize, BorshSerialize },
    serde::{ Deserialize, Serialize },
};

use temp_format::TempFormat;
use crate::utils::log;

/// Representa temperatura.
/// 
/// Possui um valor f32 para valor.
/// 
/// Possui um TempFormat para formato (Kelvin, Celsius ou Fahrenheit).
/// 
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Temperature {
    value: f32,
    temp_format: TempFormat,
}

impl Temperature {
    /// Constrói uma instância de temperatura. 
    /// 
    /// # Panics
    /// Se o valor for menor do que zero absoluto.
    /// 
    fn new_assert_temp(value: f32, temp_format: TempFormat) -> Self {
        let (minimum, name) = match &temp_format {
            TempFormat::Celsius(t_format) => {(-273.15, t_format)},
            TempFormat::Fahrenheit(t_format) => {(-459.67, t_format)},
            TempFormat::Kelvin(t_format) => {(0., t_format)},
        };
        assert!(value >= minimum, "For temperature type {}, temperature value can not be lower than {}. Current: {}.", name, minimum, value);
        
        Temperature { 
            value, 
            temp_format,
        }
    }

    /// Cria uma instância de temperatura. O formato será definido pelo formato de sistema "temp_format".
    /// 
    /// "arg_temp" é o formato de temperatura da mensagem recebida.
    /// 
    /// Se arg_temp for diferente de temp_format. Seguirá estes passos:
    ///  - Cria uma instância de temperatura no formato de arg_temp;
    ///  - Converte seu formato para temp_format;
    ///  - Retorna a temperatura;
    /// 
    pub fn new(value: f32, temp_format: &TempFormat, arg_temp: Option<String>) -> Self {
        match arg_temp {
            None => {
                let temp_format = temp_format.clone();

                Temperature::new_assert_temp(value, temp_format)
            },
            Some(arg_string) => {
                let arg_format = TempFormat::new(&arg_string);

                let mut arg_temp = Temperature::new_assert_temp(value, arg_format);

                // Converte a temperatura da mensagem para a temperatura do sistema.
                arg_temp.convert(temp_format);
                arg_temp
            }
        }

    }

    /// Atualiza temperatura se o formato for diferente. 
    /// 
    /// Retorna true se houver mudança.
    /// 
    pub fn update_temp_format(&mut self, temp_format: &TempFormat) -> bool {
        let comparison = self.temp_format == *temp_format;

        if !comparison {
            self.convert(temp_format);
        }

        !comparison
    }
    
    /// Converte o formato de temperatura para o argumento.
    pub fn convert(&mut self, temp_format: &TempFormat){
        let current: TempFormat = self.temp_format.clone();

        let value = self.value;
        log(&format!("Converting temperature to system format. System: {}, Current: {}.", temp_format, &current));

        match (current, temp_format) {
            (TempFormat::Kelvin(_), &TempFormat::Celsius(_)) => {
                // C = K − 273.15
                self.value = value - 273.15;    
                self.temp_format = TempFormat::new("c");
            },
            (TempFormat::Kelvin(_), &TempFormat::Fahrenheit(_)) => {
                // F = (K – 273.15) × 9⁄5 + 32
                self.value = (value - 273.15) * 9.0 / 5.0 + 32.0;
                self.temp_format = TempFormat::new("f");
            },
            (TempFormat::Celsius(_), &TempFormat::Kelvin(_)) => {
                // K = C + 273.15
                self.value = value + 273.15;
                self.temp_format = TempFormat::new("k");
            },
            (TempFormat::Celsius(_), &TempFormat::Fahrenheit(_)) => {
                // F = C(9⁄5) + 32
                self.value = value * (9.0 / 5.0) + 32.0;
                self.temp_format = TempFormat::new("f");
            },
            (TempFormat::Fahrenheit(_), &TempFormat::Kelvin(_)) => {
                // K = (F − 32) × 5⁄9 + 273.15
                self.value = (value - 32.0) * 5.0 / 9.0 + 273.15;
                self.temp_format = TempFormat::new("k");
            },
            (TempFormat::Fahrenheit(_), &TempFormat::Celsius(_)) => {
                // C = (F − 32) × 5⁄9
                self.value = (value - 32.0) * 5.0 / 9.0;
                self.temp_format = TempFormat::new("c");
            },
            (_, _) => {
                // Todas alternativas diferentes foram consideradas. Isso considera todas as situações em que os tipos são iguais.
                // Portanto, não fazemos nada.
                return;
            }
        }
    }
}

'''
'''--- PT-BR/lesson_6_enums/lesson_6_2_thermometer/src/temperature/temp_format.rs ---
//! Módulo que representa formato de temperatura.
//! 
//! Pode ser Kelvin, Celsius ou Fahrenheit.
//! 
//! O contrato é inicializado com formato Kelvin.
//! 
//! A instrução #[serde(untagged)] faz com que o enum seja serializado como String em json.
//! 
//!  - Default é implementado. Valor inicial é Celsius::Kelvin;
//!  - PartialEq e Eq implementados. Permitindo comparações entre TempFormats a == b;
//!  - String::from(&formato) converte uma referência &TempFormat para String;
//!  - String::from(formato) converte um TempFormat para String;
//!  - TempFormat::from("a str") para converter um &str para TempFormat;
//!  - TempFormat::from(aString) para converter um String para TempFormat;
//!  - TempFormat::from(&aString) para converter uma referência &String para TempFormat;
//!  - std::fmt::Display implementado. Permitindo o uso desses tipos em macros como println!, format! e panic!;
//! 

use near_sdk::{
    borsh::{ self, BorshDeserialize, BorshSerialize },
    serde::{ Deserialize, Serialize },
};

/// Representa formato de temperatura (Kelvin, Celsius ou Fahrenheit).
/// 
/// Usado para controle de formato. Podemos ter diversos sensores com diferentes formatos.
/// 
/// Isso garante que todas as possibilidades são aceitas.
/// 
/// Este enum é visto como uma String no formato json.
/// 
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
#[serde(untagged)]
pub enum TempFormat{
    Celsius(String),
    Fahrenheit(String),
    Kelvin(String),
}

impl TempFormat{
    /// Constroi uma instância de TempFormat. 
    /// 
    /// Não é case-sensitive. Os valores de String (esquerda) resultam em (direita):
    /// 
    ///  - "celsius", "c" => TempFormat::Celsius("Celsius")
    ///  - "fahrenheit", "f" => TempFormat::Fahrenheit("Fahrenheit")
    ///  - "kelvin", "k" => TempFormat::Kelvin("Kelvin")
    /// 
    /// # Panics
    /// 
    /// Se argumento for inválido.
    /// 
    pub fn new(temp_format: &str) -> Self{
        // Essa conversão de &str para TempFormat é possivel devido a implementação "impl From<&str> for TempFormat{..." abaixo.
        // TempFormat::from(temp_format)

        let lower_case: String = temp_format.to_ascii_lowercase();
        
        let new_format: TempFormat = match &lower_case[..] {
            "celsius" | "c" => TempFormat::Celsius(String::from("Celsius")),
            "fahrenheit" | "f" => TempFormat::Fahrenheit(String::from("Fahrenheit")),
            "kelvin" | "k" => TempFormat::Kelvin(String::from("Kelvin")),
            invalid => panic!("Invalid String for temperature type ({}). Valid args: ['Celsius', 'c', 'Fahrenheit', 'f', 'Kelvin', 'k']", invalid),
        };

        new_format
    }
}

/// O formato padrão de contrato é inicializado como Kelvin. 
/// 
/// Pode ser alterado depois da inicialização de contrato.
/// 
impl Default for TempFormat{
    fn default() -> Self {
        TempFormat::new("k")
    }
}

// Permite comparação parcial entre os tipos TempFormat.
//
// A = B não Garante B = A
//
// A = B e A = C não garante B = C
//
impl PartialEq for TempFormat {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (TempFormat::Celsius(_), TempFormat::Celsius(_)) => true,
            (TempFormat::Fahrenheit(_), TempFormat::Fahrenheit(_)) => true,
            (TempFormat::Kelvin(_), TempFormat::Kelvin(_)) => true,
            (_, _) => false,
        }
    }
}

// Após implementação acima, esta trait permite comparação total entre os tipos TempFormat.
//
// A = B garante B = A
//
// A = B e A = C garante B = C
//
impl Eq for TempFormat {}

/// Nos permite utilizar String::from(&esteTipo) para converter o tipo para String.
impl From<&TempFormat> for String{
    fn from(temp_format: &TempFormat) -> String {
        match &temp_format{
            &TempFormat::Celsius(value) => (*value).clone(),
            &TempFormat::Kelvin(value) => (*value).clone(),
            &TempFormat::Fahrenheit(value) => (*value).clone(),
        }
    }
}

/// Nos permite utilizar String::from(esteTipo) para converter o tipo para String.
impl From<TempFormat> for String {
    fn from(temp_format: TempFormat) -> String {
        String::from(&temp_format)
    }
}

/// Nos permite utilizar TempFormat::from("estestr") para converter um &str para TempFormat.
impl From<&str> for TempFormat{
    fn from(temp_format: &str) -> TempFormat {
        TempFormat::new(temp_format)
    }
}

/// Nos permite utilizar Tempformat::from(&esteString) para converter uma referência &String para TempFormat.
impl From<&String> for TempFormat{
    fn from(temp_format: &String) -> TempFormat {
        TempFormat::from(&temp_format[..])
    }
}

/// Nos permite utilizar TempFormat::from(esteString) para converter um String para TempFormat.
impl From<String> for TempFormat{
    fn from(temp_format: String) -> TempFormat{
        TempFormat::from(&temp_format[..])
    }
}

/// Usado para converter o enum para String. Se usarmos macros como format!, println! ou panic!, esta trait é usada.
impl std::fmt::Display for TempFormat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let temp_format = String::from(self);

        write!(f, "{}", temp_format)
    }
}

'''
'''--- PT-BR/lesson_6_enums/lesson_6_2_thermometer/src/utils.rs ---
//! Módulo com ferramentas de suporte.
//! 
//!  - log: Imprime a mesma mensagem em ambientes de teste e em produção.
//!  - ViewGet: Um tipo de saida para a função de contrato view_get. Permite retorno de dois tipos diferentes na mesma função.
//! 

use near_sdk::serde::{
    Deserialize, Serialize,
};

use crate::entry::Entry;

#[allow(unused_imports)]
use near_sdk::env;

/// Imprime com env::log em produção. Imprime com println em testes.
#[cfg(test)]
pub fn log(msg: &str){
    println!("{}", msg);
}

/// Imprime com env::log em produção. Imprime com println em testes.
#[cfg(not(test))]
pub fn log(msg: &str) {
    env::log(msg.as_bytes());
}

/// Usado para saida da função de contrato view_get.
/// 
///  - Se argumento possuir um index. Retorna um Entry.
///  - Se index for omitido. Retorna um Vec com todas as Entries para aquele usuário.
/// 
/// Não é eficiente quando o contrato possuir muitas entries para cada usuário. 
/// 
/// Mas esperasse que o usuário colete localmente e remova valores antigos para evitar custos desnecessários de computação e armazenamento.
/// 
/// A instrução #[serde(untagged)] faz com que o enum não apareça no json de saida.
/// 
#[derive(Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
#[serde(untagged)]
pub enum ViewGet{
    Single(Entry),
    Multiple(Vec<Entry>),
}

'''
'''--- PT-BR/lesson_6_enums/lesson_6_3_game_score/Cargo.toml ---
[package]
name = "lesson_6_3_game_score"
version = "0.1.0"
authors = ["Lucas Lemos <stiltztinkerstein@gmail.com>"]
license = "MIT"
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0"

'''
'''--- PT-BR/lesson_6_enums/lesson_6_3_game_score/Readme.md ---
# Lesson 6 - 3 Game Score

[(Back)](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/PT-BR/lesson_6_enums/lesson_6_3_game_score/)

In this example, we will see how to easily escape errors using 
the macro ```#[handle_result]```, and a way to update data 
about several users at each update (highscores in this case).

This lesson is a simple simulation of a possible browser 
"rogue-like" game. "Rogue-likes" are games where your 
character goes through a series of randomly generated 
arenas, with randomly generated rewards. A few examples 
of popular games like this are "The Binding of Isaac", by 
Edmund McMillen and Florian Himsl and "Hades", by Supergiant 
Games.

This contract can't be used (yet) for running a real game. 
But it has much of the structure that could be used for a 
game as such. We will discuss the structure of this contract, 
and I would love to have a feedback from readers about their 
thoughts about this example.

Each player store each of their characters. Have information 
on each of their highscores, and there is a global (limited) 
highscore that can be updated whenever a new one is achieved. 
How to best save gas doing these operations is still an open 
question, but I left my suggestions on this example.

If you're interested only in the error Management part of this 
example. Please check it in the index below.

## Building

This crate belongs to the workspace at lesson_6_enums. Cargo commands will affect all the crates of the workspace. To specify only this crate, include the option ```-p lesson_6_3_game_score```.

Build with:

```cargo build -p lesson_6_3_game_score --target wasm32-unknown-unknown --release```

Test with:

```cargo test -p lesson_6_3_game_score --nocapture```

```--nocapture``` will show output of each test.

## Index

[(back to top)](#lesson-6---3-game-score)

 - [Contract Api](#contract-api)
 - [How the Contract is Intended to be Used](#how-the-contract-is-intended-to-be-used)
 - [Error Management](#error-management)
 - [What Each Module Does](#what-each-module-does)
   - [Chapter](#chapter)
     - [Chapter Reward](#chapter-reward)
   - [Character](#character)
     - [Class](#class)
     - [Stats](#stats)
   - [Player](#player)
     - [View](#view)
   - [Score](#score)
     - [HighScore](#highscore)
     - [Ranking](#ranking)
 - [Next Section](#next-section) 

## Contract API

[(back to top)](#lesson-6---3-game-score)

```rust
// /src/lib.rs

/// Update the player state.
/// 
/// This is going to be replaced by direct pointer access later.
/// 
fn save_player(&mut self, player: &Player) -> Result<(), Errors>;

/// If user does not exist in the database. Ask for registry.
fn load_player(&self) -> Result<Player, Errors>;

/// A user that is not registered can't access the smart contract.
/// 
/// Add the predecessor to the smart contract.
#[handle_result]
pub fn register_user(&mut self) -> Result<(), Errors>

/// User must be registered before using this.
/// 
/// Create a character with given name and class.
/// 
/// classes: "Warrior" | "Druid" | "Rogue" | "Priest"
#[handle_result]
pub fn create_character(&mut self, name: String, class: String) -> Result<(), Errors>;

/// Loads and returns an instance of player.
#[handle_result]
pub fn check_status(&self) -> Result<player_view, Errors>;

/// Load a character with the given name and return it.
#[handle_result]
pub fn load_character(&self, name: String) -> Result<Character, Errors>;

/// Get current ranking.
pub fn get_ranking(&self) -> Ranking;

/// Get information about the next match.
#[handle_result]
pub fn start_match(&mut self) -> Result<Chapter, Errors>;

/// Report the match finished.
/// 
/// Some validations should be done about it.
/// 
/// Things like, you can't return a 10 minutes-long match if 10 minutes haven't gone through.
/// 
/// A report should be a replay of the entire match. Including the AI of non-player-characters.
/// 
#[handle_result]
pub fn report_match(
    &mut self, 
    character: CharacterName, 
    score: Score, 
    // validation_report: ValidationReport,
) -> Result<bool, Errors>;

/// Change how many players can be stored in the ranking. The larger the list, the more expensive sorting is.
#[handle_result]
pub fn set_max_highscore_players(&mut self, max_size: usize) -> Result<(), Errors>;
```

## How the contract is intended to be used

[(back to top)](#lesson-6---3-game-score)

We're considering that the game is running on a users' 
browser. We can't update the game real time like most online 
games because of latency and costs. But, when it comes to 
rogue-like games, each arena is small, and is intended to be 
finished in a short time. Something like 1 minute or 2 for each 
arena. We could require, as in-game mechanics, for the arenas 
to run for a limited time. As the player completes each of 
these small chapters, the browsers sends a report, a small 
replay, to the smart contract. The smart contract validates this 
report, and only then, updates the player's state.

Since the game isn't developed yet. This implementation will 
not receive a report and will always consider the validation 
successful. Maybe in next chapter we can try implementing a 
simple game to check how expensive it can be. You're free to 
use this code in your own games. If it makes you rich, send me 
a couple of NEAR please xD.

When it comes to the ranking of players. I decided to store it 
as a small Vector. This is because computing the ranking will 
become exponentially more expensive the higher the number of 
players. So we limit it to something like 100 or 1000 players. 
And sort the Vector whenever a new entry is achieved.

The first step a browser has to take is call ```register_user``` 
so the user is included in the state. 

 - Calling ```check_status``` will return information about 
the current player.
 - Calling ```get_ranking``` will return the current ranking 
between players.
 - Calling ```create_character``` will create a new character 
associated with that player.
 - Calling ```load_character``` will return a character owned 
by that player, with the given name.
 - Calling ```start_match``` will return information about the 
current chapter, then reset a timer.
 - Calling ```report_match``` with your chapter report will 
validate your replay, if successful, give rewards to your 
character, update highscores and move to the next chapter.
 - The owner of the smart contract accound can call 
```set_max_highscore_players``` to change the max number of 
players that can exist in ranking.

## Error Management

[(back to top)](#lesson-6---3-game-score)

In ```/src/model/errors.rs``` we have this enum.

```rust
// /src/model/errors.rs

#[derive(FunctionError, BorshSerialize)]
pub enum Errors{
    AccountIsAlreadyRegistered(AccountId),
    AccountIsNotRegistered(AccountId),
    CharacterNotFound(String),
    CharacterAlreadyExists(String),
    InvalidChapterValidation,
    ChapterNotStarted,
    InvalidCharacterName(String),
    InvalidClassName(String),
    UserNotRegistered(AccountId),
    ExcessiveMaxRankingPlayers(usize, usize),
    OwnerOnly,
}

impl std::fmt::Display for Errors {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Errors::AccountIsAlreadyRegistered(user) => write!(f, "Username {} is already registered in the database.", user),
            Errors::AccountIsNotRegistered(user) => write!(f, "Tried to update {}, but account is not registered. This a server error, not a user error. Please report it.", user),
            Errors::CharacterNotFound(name) => write!(f, "Character with name {} not found in current account.", name),
            Errors::CharacterAlreadyExists(name) => write!(f, "A character with name {} already exists in this account.", name),
            Errors::InvalidChapterValidation => write!(f, "Failed to validate chapter report"),
            Errors::ChapterNotStarted => write!(f, "Can't attempt to validate chapter without first starting the match."),
            Errors::InvalidCharacterName(name) => write!(f, "Character name starts with an invalid character ({}).", name),
            Errors::InvalidClassName(name) => write!(f, "Invalid name ({}) for character class.", name),
            Errors::UserNotRegistered(user) => write!(f, "User {} needs to create an account before using this service.", user),
            Errors::ExcessiveMaxRankingPlayers(selected, maximum) => write!(f, "Computing ranking is expensive. Can't be higher than {}. Attempted {}.", maximum, selected),
            Errors::OwnerOnly => write!(f, "Only owner may call this function."),
        }
    }
}
```

Each possible value for this enum represents an error that 
might happen in our project. The trait ```std::fmt::Display``` 
is used for turning a type into a String when we use macros 
like ```println!``` and ```format!```. We also derive a new 
trait called ```FunctionError```.

Thanks to this type. We don't need to manually can 
```env::panic_str``` or assert statements whenever something 
in the code might break. We just return the error and the 
deserializer will raise the error for us. Here is how it is 
used.

```rust
// /src/lib.rs

/// User must be registered before using this.
/// 
/// Create a character with given name and class.
/// 
/// classes: "Warrior" | "Druid" | "Rogue" | "Priest"
/// 
#[handle_result]
pub fn create_character(&mut self, name: String, class: String) -> Result<(), Errors> {
    log!("Create Character function called.");
    
    let class: Class = Class::new(&class)?;
    let character: Character = Character::new(name, class)?;
    let mut player: Player = self.load_player()?;

    player.assign_character(character)?;

    self.save_player(&player)?;

    log!("Character successfully created.");

    Ok(())
}
```

In this example for creating character, notice these 3 things:
 - The function returns ```Result<(), Errors>```;
 - ```#[handle_result]``` macro on top of the contract function;
 - ```?``` operators;

The ```?``` operator is useful for both Option and Result enums.
 - If we use it in an ```Option```, unwrap the value or panic if 
it's ```None```.
 - If we use it in a ```Result```, unwrap the value or return the 
error type as ```Err```.

Notice that the return type of each of the functions with ```?``` 
operator is a ```Result``` with the same ```Err``` type as this 
function (which is ```Errors```).

This is a very clean way of handling errors. Don't you agree? We 
know where the errors are coming from. And we are not cluttering 
our code with error checking.

Having one enum to represent all the errors in the entire smart 
contract could easily get bloated in large projects. But that's 
easy to fix. Just have errors within errors. An enum that contains 
another enum. Create a method that wraps the smaller error into the 
larger error that encompasses all the others.

## What each module does

[(back to top)](#lesson-6---3-game-score)

To help users get to know what is happening in each module. I 
will offer a brief explanation of each of those ahead.

Some of these modules are very simple and can be easily 
expanded. The intention of this lesson is to offer an example 
of a game architecture. Not the game itself. To offer inspiration 
on this uncharted web3 territory. The less specific the game 
mechanics are, the easier it is to incorporate to multiple 
different games.

### Chapter

[(back to top)](#lesson-6---3-game-score)

This module represents a single chapter of the game. Each chapter 
should be a small arena that the player should stay for a 
limited time (e.g. 2 minutes). Rogue-like games include randomly 
generated elements in each chapter. Like random enemies, random 
bonuses for the player, random rewards...

The type Chapter can be seen below: 

```rust
// /src/model/chapter/mod.rs

// Calculates score/rewards for each match (chapter)
/// This is meant to represent a game chapter. Each has it's own rewards. Each has it's own validation method.
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub enum Chapter{
    Chapter1(Option<u64>),
    Chapter2(Option<u64>),
    Chapter3(Option<u64>),
}
```

Each possible for Chapter represents a unique "arena". The value 
within the tuple is used to count match length. 

When a player calls the function "start_match", the tuple stores 
when the match started. When the player calls "report_match", 
the chapter will use the 
```(time_when_finished - time_when_started)``` to make sure that 
the game wasn't run by a machine. Here is an example:

Imagine the player calls ```start_match``` then, 2 seconds later, 
call ```validate_match``` with a report that technically lasted 
2 minutes.

The smart contract can't allow that. So, if the time in the 
report is greater than the time it took since the match started, 
the contract will panic. That's the only reason for storing the 
time in chapter.

If the validation is successful. Returns the reward for the 
character.

#### Chapter Reward

[(back to top)](#lesson-6---3-game-score)

Chapter Reward is a calculator for how much "exp (experience)" 
was earned from a chapter. Each game is different, so you will 
probably change rewards to something more interesting than this.

```rust
// /src/model/chapter/reward.rs

pub struct ChapterReward{
    /// Base exp reward.
    pub exp: EXP,
    /// More exp the higher the score.
    pub score_multiplier: f32,
    /// The level character is expected to be.
    pub expected_level: Level,
    /// Less exp the higher the level. More exp the lower the level.
    pub level_multiplier: f32,
}
```

 - ```exp```: How much base EXP is earned from this match. Regardless
 of player performance, they will always receive at least this amount.
 - ```expected_level```: What level the player is expected to be 
before starting this chapter. Lower levels means harder matches, so
higher rewards.
 - ```level_multiplier```: For each level of difference, this will be 
multiplied an extra time. Up to 5 times. Check the values in the 
tests to see some examples.
 - ```score_multiplier```: The higher the score, more exp. This is a 
 multiplier that will apply to the achieved score.

Check the implementation of ```Chapter::compute_reward``` for more 
information on how the bonuses are implemented.

### Character

[(back to top)](#lesson-6---3-game-score)

Contains basic information about a game character. Each player has 
their own list of characters.

```rust
// /src/model/character/mods.rs

// Attributes are ordered according to priority here, not alphabetic order

/// Represents a playable character in the game.
#[derive(Clone, BorshDeserialize, BorshSerialize, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Character{
    name: Name,
    class: Class,
    level: Level,
    xp: EXP,
    stats: Stats,
    high_score: Score,
}
```

 - ```name```: character's name. Will be show on high scores.
 - ```class```: class is a model for how a character is built and 
what it can do later. We don't go deep into this topic here. It's 
just an example.
 - ```level```: character's progression is marked by it's level. Exp 
raises this value automatically.
 - ```xp```: how much exp this character has. Each new level resets 
this value.
 - ```stats```: character actions are determined by their stats. Class
has information on how stats increase based on level.
 - ```high_score```: the highest score achieved by the player in any 
chapter. If a new highscore is achieved, it will be sent for a 
comparison with the ranking of players.

#### Class

[(back to top)](#lesson-6---3-game-score)

A few examples of classes just to show how each could affect stats in 
a unique way.

```rust
// /src/model/character/class.rs

/// classes: "Warrior" | "Druid" | "Rogue" | "Priest".
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub enum Class{
    Warrior,
    Druid,
    Rogue,
    Priest,
}
```

We implement a constructor:

```rust
impl Class{
    pub fn new(class: &str) -> Result<Class, Errors> {
        let class = match &class.to_ascii_lowercase()[..]{
            "warrior" => { Class::Warrior },
            "druid" => { Class::Druid },
            "rogue" => { Class::Rogue },
            "priest" => { Class::Priest },
            invalid => { return Err(Errors::InvalidClassName(String::from(invalid))) },
        };

        Ok(class)
    }
}
```

Notice how this returns a Result where the error is of type 
```Errors```. This is because we use the ```?``` operator in the 
contract methods. There's no need to manually raise errors in the 
implementation. Just return a ```Result::Err``` instead.

Some type conversions below:

```rust
// /src/model/character/class.rs

impl From<&str> for Class{
    fn from(class: &str) -> Class{
        match Class::new(class) {
            Ok(valid) => valid,
            Err(err) => env::panic_str(&format!("{}", err)),
        }
    }
}

impl From<String> for Class{
    fn from(class: String) -> Class {
        Class::from(&class[..])
    }
}

impl From<&String> for Class{
    fn from(class: &String) -> Class{
        Class::from(&class[..])
    }
}

impl From<&Class> for String {
    fn from(class: &Class) -> String {
        let name = match *class{
            Class::Druid => "Druid",
            Class::Priest => "Priest",
            Class::Rogue => "Rogue",
            Class::Warrior => "Warrior",
        };

        String::from(name)
    }
}
```

These are trait implementations for converting one type to another.

```From<&String> for Class``` will allow us to pick a string, then 
attempt to convert it into a class through the function ```from```. 
Here is an example:

```rust
let a = "Druid";
let b: Class = Class::from(a);
```

The example above we create an ```&str``` with value "Druid" then 
create a class using that string as reference. We implement for 
owned Strings. Then references of String. Then we implement 
conversion from a reference Class to a String (the reverse way).

#### Stats

[(back to top)](#lesson-6---3-game-score)

Stats represent what your character can do in the arena. The success 
rate of each of their actions. To be used in chapter validation.

Because of the classes shown above. We want to show that each 
affect the stats in a unique way. So we chose these 3 basic 
stats: dexterity, strength and inteligence.

```rust
// /model/character/stats.rs

/// The stats of the character that details how character behavior performs.
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Stats{
    dexterity: u32,
    // How much it increases each level
    dexterity_rate: u32,
    // The value at level 1
    dexterity_base: u32,
    strength: u32,    
    strength_rate: u32,
    strength_base: u32,
    intelligence: u32, 
    intelligence_rate: u32,
    intelligence_base: u32,
}
```

Base is the minimum value for that stat. Rate is how much that stat 
grows with each level. By calling the method ```Stats::update``` we 
update the value of each stat whenever the character levels up.

### Player

[(back to top)](#lesson-6---3-game-score)

Each user represents one instance of ```Player```.

```rust
// /src/model/player/mod.rs

/// Holds information pertaining to a single user.
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Player{
    name: Name,
    high_score: Option<HighScore>,
    // For storing and checking characters by name, can't iterate.
    characters: LookupMap<character::Name, Character>,
    // For storing character names, can iterate.
    character_names: UnorderedSet<character::Name>,
    // With both those above, we can check characters O(1) and iterate through the characters at the same time.

    latest_chapter: Chapter,
}
```

 - ```name```: name of the player;
 - ```high_score```: high score achieved by the player. It is None 
 - if no chapter has been played yet;
 - ```characters```: all characters owned by this player;
 - ```character_names```: list of character names owned by the player;
 - ```latest_chapter```: the next chapter the player is about to play;

The ```LookupMap``` is O(1) for getting and inserting values. The ```UnorderedSet``` is used for iterating through the names. Both are updated simultaneously.

#### View

[(back to top)](#lesson-6---3-game-score)

The collections for ```characters``` and ```character_names``` 
can't be serialized to readable json. So we create this type 
just to use as a return type.

```rust
// /src/model/

/// This type exists only to be returned when player makes a GET request for their own data.
#[derive(Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct View {
    pub name: player::Name,
    pub high_score: Option<HighScore>,
    pub characters: Vec<Character>,
}
```

We only get player name, highscore and a list of characters for 
the view. Which is all the player will need.

Vec is a collection that can be serialized with serde. It is 
updated every time the list of characters change. It gets 
exponentially more expensive the higher the number of characters. 
So limiting the number of characters is recommended.

### Score

There are two types in this module: HighScore and Ranking.

#### HighScore

[(back to top)](#lesson-6---3-game-score)

Represents a character or player's highscore.

```rust
// /src/model/score/high_score.rs

/// Represents a highscore for a player or character.
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct HighScore{
    character: Character,
    score: Score,
    player: AccountId,
}
```

The most important topic to discuss for this type is the following method:

```rust
// /src/model/score/high_score.rs

/// Makes a comparison between the new and old high scores. If a new high_score for the player is achieved, update current and return a copy.
pub fn update_highscore(
    current_highscore: &mut Option<HighScore>,
    new_high_score: Option<HighScore>,
) -> Result<Option<HighScore>, Errors> {

    // This match will stop assigning the new highscore if one has not been achieved.
    match (&current_highscore, &new_high_score) {
        (_, None) => { 
            // No highscore was achieved by the character.
            return Ok(None); 
        },
        (None, Some(_)) => {},
        (Some(old_high_score), Some(new_high_score)) => {
            // A character achieved a highscore
            // there is a highscore recorded.
            // makes a comparison and maintain the highest.
            if old_high_score > new_high_score {
                return Ok(None);
            }
        },
    }

    // assign the new highscore
    *current_highscore = new_high_score.clone();

    return Ok(new_high_score);
}
```

So, this happens for player and character. Both store an 
```Option<HighScore>```. So, instead of making functions that 
receive ```HighScore``` as arguments. We have one that receives 
```Option<HighScore>``` instead.

When a report is validated. A highscore for the character may be 
achieved. 

If this happens, we make a comparison with all the player highscores 
to see if a highscore for the player was achieved.

If this happens as well, we check if the player highscore is among 
the ranking of top highscores.

Notice how ranking is only calculated when player achieve their 
highest score. That saves a lot of computing.

So, ```HighScore::update_highscore``` receives the current highscore 
and the latest possible highscore. If latest is higher than the 
current, updates the current, then return a copy of the same.

There is the possibility of any of the values being ```None```. 
Maybe no highscore was achieved. Maybe there were no highscores 
before this one. The function considers both cases.

#### Ranking

[(back to top)](#lesson-6---3-game-score)

Ranking is stored a vector of ```HighScore```. The maximum 
number of elements stored is limited to reduce sorting costs.

```rust
// /src/model/score/ranking.rs

/// Contains the top ranked matches stored in the smart contract.
/// 
/// It's just a vector. So to avoid high costs sorting.
/// 
/// We limit the max number of entries to RANKSIZE.
/// 
/// Suggestion for change. Store the score of the lowest highscore in the ranking. 
/// Only update and sort the list when a value higher than such is included.
#[derive(BorshDeserialize, BorshSerialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Ranking{
    values: Vec<HighScore>,
    max_size: usize,
    lowest_high_score: Option<HighScore>,
}
```

When a player achieves a new ```HighScore```, the following 
method is run:

```rust
// /src/model/score/ranking.rs

pub fn check_highscore(
    &mut self, 
    high_score: &Option<HighScore>,
) -> bool {
    match high_score {
        None => { 
            // Player didn't achieve a high score.
            false
        },
        Some(high_score) => {
            log!("New High Score for this Player.");

            // Compiler will apply branchless optimization to all these if/else statements.
            if self.lowest_high_score.is_none() {
                // This is the first entry, so just include it.
                self.new_entry(high_score.clone());

                return true;
            } else {
                // This is not the first entry.
                // The list may be full or not.
                let ranking_is_full: bool = self.values.len() == self.max_size;

                if !ranking_is_full {
                    // If the list is not full, just include it.
                    self.new_entry(high_score.to_owned());

                    return true;
                } else {
                    // .unwrap will never panic because of the first "if" above. It is always Some.
                    // We are cloning because unwrap will take ownership of this mutable reference.
                    let lowest_high_score = self.lowest_high_score
                        .clone()
                        .unwrap();

                    if lowest_high_score < *high_score {
                        self.new_entry(high_score.clone());

                        return true;
                    }
                    
                    false
                }
            }
        }
    }
}
```

In summary, what this method does is:
 - If a new HighScore is not achieved, do nothing.
 - If the list is empty, just include the entry.
 - If the list is not full, just include the entry.
 - If the list is full, before including the entry, 
only include if the value is higher than the lowest 
entry in the list.

Each inclusion in the list will result in the 
list being sorted. Comparison with the lowest entry 
helps reduce computing costs.

## Next Section

[(back to top)](#lesson-6---3-game-score)

The next lesson will be about traits.

'''
'''--- PT-BR/lesson_6_enums/lesson_6_3_game_score/src/lib.rs ---
use near_sdk::{
    AccountId,
    borsh::{self, BorshDeserialize, BorshSerialize},
    collections::{
        LookupMap, 
    },
    env,
    log,
    near_bindgen,
};

mod model;

use crate::{
    model::{
        character::{
            Character,
            Class,
            Name as CharacterName,
        },
        Errors,
        Chapter,
        player_view,
        Player,
        score::{
            HighScore,
            Score,
            Ranking,
        },
        StorageKey,
    }
};

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Contract {
    players: LookupMap<AccountId, Player>,

    ranking: Ranking,
}

// Na inicialização de contrato,
// inclui dono na lista de usuários permitidos.
impl Default for Contract {
    fn default() -> Self {
        let players: LookupMap<AccountId, Player> = LookupMap::new(StorageKey::Players);
        let ranking: Ranking = Ranking::default();

        Contract{
            players,
            ranking,
        }
    }
}

#[near_bindgen]
impl Contract{

    fn is_owner() -> bool {
        let predecessor_account_id: AccountId =  env::predecessor_account_id();
        let current_account_id: AccountId = env::current_account_id();

        predecessor_account_id == current_account_id
    }

    /// Guarantees that the user is not registered.
    fn assert_user_not_registered(&self) -> Result<(), Errors> {
        let predecessor_account_id = env::predecessor_account_id();

        if self.players.contains_key(&predecessor_account_id) ||  Self::is_owner() {
            // Panic because account already exists.
            return Err(Errors::AccountIsAlreadyRegistered(predecessor_account_id));
        }

        Ok(())
    }

    fn assert_user_registered(&self) -> Result<(), Errors> {
        if Self::is_owner(){
            return Ok(());
        }

        let predecessor_account_id = env::predecessor_account_id();

        if ! self.players.contains_key(&predecessor_account_id) {
            // Panic because account already exists.
            return Err(Errors::AccountIsNotRegistered(predecessor_account_id));
        }

        Ok(())
    }

    /// Update the player state.
    /// 
    /// This is going to be replaced by direct pointer access later.
    /// 
    fn save_player(&mut self, player: &Player) -> Result<(), Errors>{
        self.assert_user_registered()?;

        let predecessor_account_id: AccountId = env::predecessor_account_id();

        self.players.insert(&predecessor_account_id, player).unwrap();

        Ok(())
    }

    /// If user does not exist in the database. Ask for registry.
    fn load_player(&self) -> Result<Player, Errors>{
        let predecessor_account_id = env::predecessor_account_id();

        match self.players.get(&predecessor_account_id){
            None => Err(Errors::UserNotRegistered(predecessor_account_id)),
            Some(player) => Ok(player),
        }
    }

    

    /// A user that is not registered can't access the smart contract.
    /// 
    /// Add the predecessor to the smart contract.
    #[handle_result]
    pub fn register_user(&mut self) -> Result<(), Errors> {
        log!("Register User function called.");
        self.assert_user_not_registered()?;

        // While technically we are calling env::predecessor_account_id twice, LLVM compiler will optimize it away.
        // We can write both low level and high level code efficiently in rust. 
        // We just need to decide when a function represents a low level or high level need.
        let predecessor_account_id = env::predecessor_account_id();
        let player = Player::default();
        assert!(self.players.insert(&predecessor_account_id, &player).is_none(), "Smart contract error: Expected None after asserting user is not registered. Got some.");

        log!("User successfully registered.");
        
        Ok(())
    }

    /// User must be registered before using this.
    /// 
    /// Create a character with given name and class.
    /// 
    /// classes: "Warrior" | "Druid" | "Rogue" | "Priest"
    /// 
    #[handle_result]
    pub fn create_character(&mut self, name: String, class: String) -> Result<(), Errors> {
        log!("Create Character function called.");
        
        let class: Class = Class::new(&class)?;
        let character: Character = Character::new(name, class)?;
        let mut player: Player = self.load_player()?;

        player.assign_character(character)?;

        self.save_player(&player)?;

        log!("Character successfully created.");

        Ok(())
    }

    /// Loads and returns an instance of player.
    #[handle_result]
    pub fn check_status(&self) -> Result<player_view, Errors>{
        log!("Check Player Status function called.");

        Self::load_player(&self)?
            .get_view()
    }

    /// Load a character with the given name and return it.
    #[handle_result]
    pub fn load_character(&self, name: String) -> Result<Character, Errors> {
        let player = self.load_player()?;

        player.load_character(name)
    }

    /// Get current ranking.
    pub fn get_ranking(&self) -> Ranking {
        self.ranking.clone()
    }

    /// Get information about the next match.
    #[handle_result]
    pub fn start_match(&mut self) -> Result<Chapter, Errors> {
        log!("Start Match function called.");

        let mut player = self
            .load_player()?;

        let chapter = player.start_match();

        self.save_player(&player)?;

        Ok(chapter)
    }

    /// Report the match finished.
    /// 
    /// Some validations should be done about it.
    /// 
    /// Things like, you can't return a 10 minutes-long match if 10 minutes haven't gone through.
    /// 
    /// A report should be a replay of the entire match. Including the AI of non-player-characters.
    /// 
    #[handle_result]
    pub fn report_match(
        &mut self, 
        character: CharacterName, 
        score: Score, 
        // validation_report: ValidationReport,
    ) -> Result<bool, Errors>{
        log!("Report Match function called.");

        let mut player: Player = self.load_player()?;

        let high_score: Option<HighScore> = player.report_match(character, score)?;

        self.save_player(&player)?;

        // So, if player didn't achieve a highscore of their own, it won't checked in the rankings. 
        // This is to stop a few players from overwhelming the ranking with their name.
        Ok(self.ranking.check_highscore(&high_score))
    }

    /// Change how many players can be stored in the ranking. The larger the list, the more expensive sorting is.
    #[handle_result]
    pub fn set_max_highscore_players(&mut self, max_size: usize) -> Result<(), Errors> {
        if env::signer_account_id() != env::current_account_id() {
            return Result::Err(Errors::OwnerOnly);
        }

        self.ranking.set_max_highscore_players(max_size)?;

        Ok(())
    }
}
'''
'''--- PT-BR/lesson_6_enums/lesson_6_3_game_score/src/model/chapter/mod.rs ---
mod reward;

use near_sdk::{
    borsh,
    borsh::{ BorshDeserialize, BorshSerialize },
    env,
    serde::{ Deserialize, Serialize },
};

pub use reward::ChapterReward;
use crate::model::{
    character::{
        Character,
        EXP,
    },
    score::Score,
    Errors,
};

// Calculates score/rewards for each match (chapter)
/// This is meant to represent a game chapter. Each has it's own rewards. Each has it's own validation method.
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub enum Chapter{
    Chapter1(Option<u64>),
    Chapter2(Option<u64>),
    Chapter3(Option<u64>),
}

impl Default for Chapter{
    fn default() -> Self {
        Chapter::Chapter1(None)
    }
}

impl Chapter {
    fn get_time(&self) -> Option<u64> {
        match self{
            Chapter::Chapter1(value) => value.clone(),
            Chapter::Chapter2(value) => value.clone(),
            Chapter::Chapter3(value) => value.clone(),
        }
    }

    /// Used by Self::clear_time and Self::start_time. Change the value of the last time a match was started.
    fn set_time(&mut self, value: Option<u64>) {
        *self = match self{
            Chapter::Chapter1(_) => Self::Chapter1(value),
            Chapter::Chapter2(_) => Self::Chapter2(value),
            Chapter::Chapter3(_) => Self::Chapter3(value),
        };
    }

    /// Used after reporting. Means that no match is going at the moment.
    fn stop_time(&mut self) {
        self.set_time(None);
    }

    /// Used when loading a chapter. Get the latest time for starting the match. Report can't have a longer time than this.
    fn start_time(&mut self) {
        let current_time_ms: u64 = env::block_timestamp_ms();

        self.set_time(Some(current_time_ms));
    }

    /// Returns the multipliers for each chapter reward.
    pub fn check_reward(&self) -> ChapterReward {
        match self {
            Chapter::Chapter1(_) => {
                ChapterReward::new(
                    10, 
                    0.9, 
                    1, 
                    0.9,
                )
            },
            Chapter::Chapter2(_) => {
                ChapterReward::new(
                    100, 
                    0.9, 
                    5, 
                    0.9,
                )
            },
            Chapter::Chapter3(_) => {
                ChapterReward::new(
                    1000, 
                    0.9, 
                    10, 
                    0.9,
                )
            },
        }
    }

    
    /// Doesn't do anything in this tutorial.
    /// 
    /// The idea is that the user will send a report that includes everything that happened during the match.
    /// 
    /// The contract guarantees that the user didn't attempt to cheat at the game.
    /// 
    fn validate_get_reward(
        &self,
        _character: &Character,
        _score: &Score,
        // Validation_report: EncryptedValidationType,
    ) -> Result<ChapterReward, Errors> {

        if self.get_time().is_none(){
            return Err(Errors::ChapterNotStarted);
        }

        // Do something with the validation_report and given character and score.
        // validation_report should be a block of bytes signed with a public key owned by the smart contract.
        // The report should have information about everything that happened in the match.
        // Since the gameplay happens in the browser. It's very easy for the user to cheat and send a fake report.
        // So maybe the report should be an entire replay of the match.
        //
        // One useful check that could be done is making sure that the match between start and report can't

        
        Result::Ok(
            Self::check_reward(&self)
        )
    }

    /// Can only be called after the timer has started (with Self::start_match). Receives a chapter report and validates it before returning rewards.
    pub fn validate_match(
        &mut self, 
        character: &Character, 
        score: &Score,
        // Validation_report: ValidationReport,
    ) -> Result<EXP, Errors> {
        let reward = self.validate_get_reward(character, score)?;

        self.stop_time();
        Ok(reward.compute_reward(character.get_level(), score))
    }

    /// Go to the next chapter and stop the timer.
    pub fn next_match(&mut self) {
        *self = match self {
            Chapter::Chapter1(_) => Chapter::Chapter2(None),
            Chapter::Chapter2(_) => Chapter::Chapter3(None),
            Chapter::Chapter3(_) => Chapter::Chapter1(None),
        };
    }

    /// Start match timer. Needed for validation.
    pub fn start_match(&mut self) -> Self {
        self.start_time();

        self.clone()
    }

}

#[cfg(test)]
mod tests{
    use super::Chapter;

    fn new_chapter_1() -> Chapter{
        Chapter::default()
    }

    fn new_chapter_2() -> Chapter {
        let mut chapter = Chapter::default();
        chapter.next_match();
        chapter
    }

    fn new_chapter_3() -> Chapter {
        let mut chapter = Chapter::default();
        chapter.next_match();
        chapter.next_match();
        chapter
    }

    fn assert_chapter_number(chapter: &Chapter, number: u8) {
        if number < 1 && number > 3 {
            panic!("Invalid argument for test. Chapter can only be 1, 2 or 3.")
        }

        match chapter {
            Chapter::Chapter1(_) => assert!(number == 1),
            Chapter::Chapter2(_) => assert!(number == 2),
            Chapter::Chapter3(_) => assert!(number == 3),
        }
    }

    #[test]
    fn chapter_next_chapter() {
        let (chapter1, chapter2, chapter3) = (
            new_chapter_1(),
            new_chapter_2(),
            new_chapter_3(),
        );

        assert_chapter_number(&chapter1, 1);
        assert_chapter_number(&chapter2, 2);
        assert_chapter_number(&chapter3, 3);
    }

    #[test]
    fn chapter_clear_timer() {
        
        let (mut chapter1, mut chapter2, mut chapter3) = (
            new_chapter_1(),
            new_chapter_2(),
            new_chapter_3(),
        );

        chapter1.start_match();
        chapter2.start_match();
        chapter3.start_match();

        assert!(chapter1.get_time().is_some());
        assert!(chapter2.get_time().is_some());
        assert!(chapter3.get_time().is_some());

        chapter1.stop_time();
        chapter2.stop_time();
        chapter3.stop_time();

        assert!(chapter1.get_time().is_none());
        assert!(chapter2.get_time().is_none());
        assert!(chapter3.get_time().is_none());
    }

}
'''
'''--- PT-BR/lesson_6_enums/lesson_6_3_game_score/src/model/chapter/reward.rs ---
use crate::model::{
    character::{
        EXP,
        Level,
    },
    score::Score,
};

pub struct ChapterReward{
    /// Base exp reward.
    pub exp: EXP,
    /// More exp the higher the score.
    pub score_multiplier: f32,
    /// The level character is expected to be.
    pub expected_level: Level,
    /// Less exp the higher the level. More exp the lower the level.
    pub level_multiplier: f32,
}

impl ChapterReward{
    
    /// Returns the proportion of extra EXP based on level difference.
    /// 
    /// Max difference is 5.
    /// 
    /// If level is higher than expected, receive less EXP.
    /// 
    /// If level is lower, receive more EXP.
    /// 
    fn compute_level_multiplier(
        mut multiplier: f32, 
        level: Level, 
        expected_level: Level,
    ) -> f32{
        let mut difference = level as f32 - expected_level as f32;

        let result: f32 = 1.0;

        // As example, if proportion is 0.9, having a lower level will multiply the bonus by 1.1 per level (up to 5)
        // 0.8 would multiply the bonus by 1.2/level (up to 5).
        if difference < 0. {
            multiplier = 2. - multiplier;
            difference *= -1.;
        }

        if difference >= 5. {
            return result * multiplier * multiplier * multiplier * multiplier * multiplier
        }
        if difference >= 4. {
            return result * multiplier * multiplier * multiplier * multiplier
        }
        if difference >= 3. {
            return result * multiplier * multiplier * multiplier
        }
        if difference >= 2. {
            return result * multiplier * multiplier
        }

        if difference >= 1. {
            return result * multiplier
        }

        result
    }

    pub fn new(
        exp: EXP,
        score_multiplier: f32,
        expected_level: Level,
        level_multiplier: f32,
    ) -> Self {

        ChapterReward { 
            exp, 
            score_multiplier, 
            expected_level, 
            level_multiplier,
        }
    }

    pub fn compute_reward(
        &self, 
        character_level: Level,
        score: &Score,
    ) -> EXP {
        let exp = self.exp;
        let score_bonus = self.score_multiplier * *score as f32;

        let expected_level = self.expected_level;
        let level_multiplier = self.level_multiplier;

        let computed_multiplier = Self::compute_level_multiplier(
            level_multiplier, 
            character_level,
            expected_level,
        );

        ((exp as f32 + score_bonus as f32) * computed_multiplier) as EXP
    }
}

#[cfg(test)]
mod tests{
    use super::ChapterReward;

    fn setup_test() -> ChapterReward {
        let (
            exp,
            score_multiplier,
            expected_level,
            level_multiplier,
        ) = (10, 0.8, 10, 0.9);

        ChapterReward::new(exp, score_multiplier, expected_level, level_multiplier)
    }

    #[test]
    fn chapter_reward_new(){
        
        let chapter_reward: ChapterReward = setup_test();

        assert_eq!(chapter_reward.exp, 10);
        assert_eq!(chapter_reward.score_multiplier, 0.8);
        assert_eq!(chapter_reward.expected_level, 10);
        assert_eq!(chapter_reward.level_multiplier, 0.9);
    }

    #[test]
    fn chapter_reward_compute_reward(){
        let chapter_reward: ChapterReward = setup_test();

        // Lower level means more exp, up to 5 levels of difference.
        assert_eq!(chapter_reward.compute_reward(10, &100), 90);
        assert_eq!(chapter_reward.compute_reward(9, &100), 99);
        assert_eq!(chapter_reward.compute_reward(8, &100), 108);
        assert_eq!(chapter_reward.compute_reward(7, &100), 119);
        assert_eq!(chapter_reward.compute_reward(6, &100), 131);
        assert_eq!(chapter_reward.compute_reward(5, &100), 144);
        assert_eq!(chapter_reward.compute_reward(4, &100), 144);
        assert_eq!(chapter_reward.compute_reward(3, &100), 144);
        assert_eq!(chapter_reward.compute_reward(2, &100), 144);

        // Higher level means less exp, up to 5 levels of difference.
        assert_eq!(chapter_reward.compute_reward(10, &100), 90);
        assert_eq!(chapter_reward.compute_reward(11, &100), 81);
        assert_eq!(chapter_reward.compute_reward(12, &100), 72);
        assert_eq!(chapter_reward.compute_reward(13, &100), 65);
        assert_eq!(chapter_reward.compute_reward(14, &100), 59);
        assert_eq!(chapter_reward.compute_reward(15, &100), 53);
        assert_eq!(chapter_reward.compute_reward(16, &100), 53);
        assert_eq!(chapter_reward.compute_reward(17, &100), 53);
        assert_eq!(chapter_reward.compute_reward(18, &100), 53);
    }
}
'''
'''--- PT-BR/lesson_6_enums/lesson_6_3_game_score/src/model/character/class.rs ---
use near_sdk::{
    borsh::{
        BorshDeserialize,
        BorshSerialize,
        self,
    },
    serde::{ Deserialize, Serialize },
};

use near_sdk::env;

use crate::model::{
    character::Stats,
    Errors,
};

/// classes: "Warrior" | "Druid" | "Rogue" | "Priest".
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub enum Class{
    Warrior,
    Druid,
    Rogue,
    Priest,
}

impl From<&str> for Class{
    fn from(class: &str) -> Class{
        match Class::new(class) {
            Ok(valid) => valid,
            Err(err) => env::panic_str(&format!("{}", err)),
        }
    }
}

impl From<String> for Class{
    fn from(class: String) -> Class {
        Class::from(&class[..])
    }
}

impl From<&String> for Class{
    fn from(class: &String) -> Class{
        Class::from(&class[..])
    }
}

impl From<&Class> for String {
    fn from(class: &Class) -> String {
        let name = match *class{
            Class::Druid => "Druid",
            Class::Priest => "Priest",
            Class::Rogue => "Rogue",
            Class::Warrior => "Warrior",
        };

        String::from(name)
    }
}

impl Class {
    pub fn new(class: &str) -> Result<Class, Errors> {
        let class = match &class.to_ascii_lowercase()[..]{
            "warrior" => { Class::Warrior },
            "druid" => { Class::Druid },
            "rogue" => { Class::Rogue },
            "priest" => { Class::Priest },
            invalid => { return Err(Errors::InvalidClassName(String::from(invalid))) },
        };

        Ok(class)
    }

    /// Return base stats for given class, used by Character;
    pub fn get_stats(&self) -> Stats {

        let (
            dexterity_base,
            strength_base,
            inteligence_base,
            strength_rate,
            dexterity_rate,
            inteligence_rate,
        ) = match self{
            Class::Druid => (
                5,
                7,
                7,
                1,
                2,
                2,
            ),
            Class::Priest => (
                4,
                5,
                7,
                1,
                2,
                1,
            ),
            Class::Rogue => (
                8,
                4,
                4,
                2,
                1,
                1,
            ),
            Class::Warrior => (
                4,
                8,
                4,
                1,
                2,
                1,
            ),
        };

        Stats::new(
            dexterity_base,
            dexterity_rate,
            strength_base,
            strength_rate,
            inteligence_base,
            inteligence_rate,
        )
    }
}

'''
'''--- PT-BR/lesson_6_enums/lesson_6_3_game_score/src/model/character/mod.rs ---
use near_sdk::{
    borsh::{ BorshDeserialize, BorshSerialize, self,},
    env,
    serde::{ Deserialize, Serialize },
};

mod class;
mod stats;

pub(crate) use class::Class;
pub(crate) use stats::Stats;

use crate::model::{
    Errors,
    score::{
        Score,
        // HighScore,
    },
};

use super::score::HighScore;

pub type Name = String;
pub type EXP = u32;
pub type Level = u32;

// Attributes are ordered according to priority here, not alphabetic order

/// Represents a playable character in the game.
#[derive(Clone, BorshDeserialize, BorshSerialize, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Character{
    name: Name,
    class: Class,
    level: Level,
    xp: EXP,
    stats: Stats,
    high_score: Score,
}

impl Character {

    fn update_level(&mut self) {
        let level: u32 = self.level;

        // just an exponential function to work as an example of how level scaling could work.
        // It gets exponentially higher each level. Level 1 requirement is 100.
        let next_level: u32 = 100 + level * 10 + 3 * level * level;

        if self.xp >= next_level { 
            self.level += 1;
            self.xp -= next_level;
            self.stats.update(self.level);
        }
    }

    /// Create a new character to be used by the player.
    pub fn new(name: Name, class: Class) -> Result<Character, Errors> {
        let level: Level = 1;
        let xp: EXP = 0;
        let stats: Stats = Stats::from(&class);
        let high_score: Score = 0;

        let first_character = &name[0..1];
        match first_character{
            "" => Err(Errors::InvalidCharacterName(name)),
            _ => Ok(Character {
                name,
                class,
                level,
                xp,
                stats,
                high_score,
            })
        }

        
    }

    pub fn get_name(&self) -> Name {
        self.name.clone()
    }

    pub fn get_class(&self) -> Class {
        self.class.clone()
    }

    pub fn get_level(&self) -> Level {
        self.level.clone()
    }

    pub fn get_xp(&self) -> EXP {
        self.xp.clone()
    }

    pub fn get_stats(&self) -> Stats {
        self.stats.clone()
    }

    pub fn get_high_score(&self) -> Score {
        self.high_score.clone()
    }

    pub fn reward_exp(&mut self, exp: EXP) {
        self.xp += exp;
        self.update_level();
    }

    /// Makes a comparison with the highscore. 
    /// 
    /// 
    /// If a highscore is achieved, return it.
    /// 
    /// Else return None.
    /// 
    pub fn check_highscore(&mut self, score: Score) -> Option<HighScore> {

        if score > self.high_score {
            self.high_score = score;
            let player = env::predecessor_account_id();

            let high_score: HighScore = HighScore::new(score, &self, player);

            return Some(high_score);
        }

        None
    }

}

'''
'''--- PT-BR/lesson_6_enums/lesson_6_3_game_score/src/model/character/stats.rs ---
use near_sdk::{
    borsh::{
        BorshDeserialize,
        BorshSerialize,
        self,
    },
    serde::{ Deserialize, Serialize },
};

use crate::model::character::Class;

/// The stats of the character that details how character behavior performs.
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Stats{
    dexterity: u32,
    // How much it increases each level
    dexterity_rate: u32,
    // The value at level 1
    dexterity_base: u32,
    strength: u32,    
    strength_rate: u32,
    strength_base: u32,
    intelligence: u32, 
    intelligence_rate: u32,
    intelligence_base: u32,
}

impl Stats{
    pub fn new(
        dexterity_base: u32,
        dexterity_rate: u32,
        strength_base: u32,
        strength_rate: u32,
        intelligence_base: u32,
        intelligence_rate: u32,
    ) -> Self {
        let (dexterity, strength, intelligence) = (dexterity_base, strength_base, intelligence_base);

        Stats { 
            dexterity, 
            dexterity_rate,
            dexterity_base,
            strength,
            strength_rate,
            strength_base,
            intelligence,
            intelligence_rate,
            intelligence_base,
        }
    }

    pub fn update(&mut self, level: u32) {
        // dexterity, strength, inteligence
        // all these temporary variables won't exist in the machine code.
        // LLVM compiler optimizes these things away.
        // So don't worry about making your code more readable.

        let dexterity: u32 = self.dexterity_base + self.dexterity_rate * level;
        let strength: u32 = self.strength_base + self.strength_rate * level;
        let inteligence: u32 = self.intelligence_base + self.intelligence_rate * level;

        self.dexterity = dexterity;
        self.strength = strength;
        self.intelligence = inteligence;
    }
}

impl From<&Class> for Stats {
    fn from(class: &Class) -> Stats {
        class.get_stats()
    }
}

impl From<Class> for Stats {
    fn from(class: Class) -> Stats {
        Stats::from(&class)
    }
}

'''
'''--- PT-BR/lesson_6_enums/lesson_6_3_game_score/src/model/errors.rs ---
use near_sdk::{
    AccountId,
    borsh::{ self, BorshSerialize },
    FunctionError,
};

#[derive(FunctionError, BorshSerialize)]
pub enum Errors{
    AccountIsAlreadyRegistered(AccountId),
    AccountIsNotRegistered(AccountId),
    CharacterNotFound(String),
    CharacterAlreadyExists(String),
    InvalidChapterValidation,
    ChapterNotStarted,
    InvalidCharacterName(String),
    InvalidClassName(String),
    UserNotRegistered(AccountId),
    ExcessiveMaxRankingPlayers(usize, usize),
    OwnerOnly,
}

impl std::fmt::Display for Errors {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Errors::AccountIsAlreadyRegistered(user) => write!(f, "Username {} is already registered in the database.", user),
            Errors::AccountIsNotRegistered(user) => write!(f, "Tried to update {}, but account is not registered. This a server error, not a user error. Please report it.", user),
            Errors::CharacterNotFound(name) => write!(f, "Character with name {} not found in current account.", name),
            Errors::CharacterAlreadyExists(name) => write!(f, "A character with name {} already exists in this account.", name),
            Errors::InvalidChapterValidation => write!(f, "Failed to validate chapter report"),
            Errors::ChapterNotStarted => write!(f, "Can't attempt to validate chapter without first starting the match."),
            Errors::InvalidCharacterName(name) => write!(f, "Character name starts with an invalid character ({}).", name),
            Errors::InvalidClassName(name) => write!(f, "Invalid name ({}) for character class.", name),
            Errors::UserNotRegistered(user) => write!(f, "User {} needs to create an account before using this service.", user),
            Errors::ExcessiveMaxRankingPlayers(selected, maximum) => write!(f, "Computing ranking is expensive. Can't be higher than {}. Attempted {}.", maximum, selected),
            Errors::OwnerOnly => write!(f, "Only owner may call this function."),
        }
    }
}
'''
'''--- PT-BR/lesson_6_enums/lesson_6_3_game_score/src/model/mod.rs ---

mod player;
mod chapter;
mod errors;
mod storage;

pub mod character;
pub mod score;

pub(crate) use player::Player;
pub(crate) use player::View as player_view;
pub(crate) use errors::Errors;
pub(crate) use chapter::Chapter;
pub(crate) use storage::StorageKey;

'''
'''--- PT-BR/lesson_6_enums/lesson_6_3_game_score/src/model/player/mod.rs ---
use near_sdk::{
    AccountId,
    borsh::{
        BorshDeserialize,
        BorshSerialize,
        self,
    },
    collections::{
        LookupMap,
        UnorderedSet,
    },
    env,
};

mod view;

use crate::model::{
    chapter::Chapter,
    character,
    character::Character,
    score::HighScore,
    score::Score,
    Errors,
};

use crate::StorageKey;

pub type Name = AccountId;

pub use view::View;

/// Holds information pertaining to a single user.
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Player{
    name: Name,
    high_score: Option<HighScore>,
    // For storing and checking characters by name, can't iterate.
    characters: LookupMap<character::Name, Character>,
    // For storing character names, can iterate.
    character_names: UnorderedSet<character::Name>,
    // With both those above, we can check characters O(1) and iterate through the characters at the same time.

    latest_chapter: Chapter,
}

// Initial state of the player.
impl Default for Player{
    fn default() -> Self {
        let name = env::predecessor_account_id();

        let high_score = None;
        let characters = 
            LookupMap::new(
                StorageKey::Characters(name.clone())
            );

        let character_names: UnorderedSet<character::Name> = UnorderedSet::new(
            StorageKey::CharacterNames(name.clone())
        );

        let latest_chapter: Chapter = Chapter::default();
        
        Player{
            name,
            high_score,
            characters,
            character_names,
            latest_chapter,
        }
    }
}

impl Player{
    /// Will panic if a character with that name already exists.
    fn assert_character_doesnt_exist(&self, character_name: &character::Name) -> Result<(), Errors> {
        if self.characters.contains_key(character_name) {
            return Err(Errors::CharacterAlreadyExists(character_name.clone()));
        }

        Ok(())
    }

    fn assert_character_exists(&self, character_name: &character::Name) -> Result<(), Errors> {
        if !self.characters.contains_key(character_name) {
            return Err(Errors::CharacterNotFound(character_name.clone()));
        }

        Ok(())
    }

    /// Returns the character state. Should be replaced by pointer access later.
    pub fn load_character(&self, name: character::Name) -> Result<Character, Errors> {
        match self.characters.get(&name){
            None => Err(Errors::CharacterNotFound(name.to_string())),
            Some(character) => Ok(character),
        }
    }

    /// This should be replaced by pointer access later.
    fn save_character(&mut self, character: &Character) -> Result<(), Errors> {
        let character_name = character.get_name();

        self.assert_character_exists(&character_name)?;

        self.characters.insert(&character_name, character).unwrap();

        Ok(())
    }

    pub fn assign_character(&mut self, character: Character) -> Result<(), Errors> {
        let character_name = character.get_name();
        
        self.assert_character_doesnt_exist(&character_name)?;

        // If this error happens. It's an unexpected server error. That means that something else is going wrong.
        // It should be reported.
        assert!(self.characters.insert(&character_name, &character).is_none(), "Server error: Character doesn't exist. Please Report.");
        self.character_names.insert(&character_name);

        Ok(())
    }

    /// Move to the next chapter.
    pub fn next_match(&mut self){
        self.latest_chapter.next_match();
    }

    /// Start timer and return the current chapter.
    pub fn start_match(&mut self) -> Chapter {
        self.latest_chapter.start_match()
    }

    /// End the timer and reward the character. Then update highscores.
    /// 
    /// Returns a HighScore if it was achieved,
    pub fn report_match(
        &mut self,
        character: String,
        score: Score,
        // validation_report: ValidationReport,
    ) -> Result<Option<HighScore>, Errors> {
        let mut character: Character = self.load_character(character)?;

        let exp: character::EXP = self.latest_chapter.validate_match(
            &character, 
            &score,
        )?;

        let new_character_highscore: Option<HighScore> = character.check_highscore(score);

        let high_score: Option<HighScore> = HighScore::update_highscore(
            &mut self.high_score, 
            new_character_highscore,
        );

        character.reward_exp(exp);
        self.save_character(&character)?;

        Ok(high_score)
    }

    /// Get characters' name.
    pub fn get_name(&self) -> Name {
        self.name.clone()
    }

    /// Returns information about this player as json.
    /// 
    /// LookupMap and UnorderedSet can't be serialized into json. We create a View with serializable data types and return it instead.
    pub fn get_view(&self) -> Result<View, Errors> {
        let name: Name = self.name.clone();
        let high_score: Option<HighScore> = self.high_score.clone();
        let mut characters: Vec<Character> = Vec::with_capacity(self.character_names.len() as usize);

        for character_name in self.character_names.iter() {
            let character: Character = self.load_character(character_name)?;
            characters.push(character);
        };

        Ok(View { name, high_score, characters })
    }
}

'''
'''--- PT-BR/lesson_6_enums/lesson_6_3_game_score/src/model/player/view.rs ---
//! When a user loads a player type. This type is what they will receive.
//! 
//! 

use near_sdk::{
    serde::{ Deserialize, Serialize },
};

use crate::model::{
    character::Character,
    player,
    score::HighScore,
};

/// This type exists only to be returned when player makes a GET request for their own data.
#[derive(Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct View {
    pub name: player::Name,
    pub high_score: Option<HighScore>,
    pub characters: Vec<Character>,
}

'''
'''--- PT-BR/lesson_6_enums/lesson_6_3_game_score/src/model/score/high_score.rs ---
use near_sdk::{
    AccountId,
    borsh::{ BorshDeserialize, BorshSerialize, self },
    serde::{ Deserialize, Serialize },
};

use crate::model::{
    character::Character,
    score::Score,
};

/// Represents a highscore for a player or character.
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct HighScore{
    character: Character,
    score: Score,
    player: AccountId,
}

// Used for ordering HighScores within a Vec
impl Ord for HighScore {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.score.cmp(&other.score)
    }
}

// Required by Ord.
impl PartialOrd for HighScore {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        Some(self.cmp(other))
    }
}

// Used for partial comparisons between HighScores. Required by Ord and Eq.
//
// A = B sometimes doesn't mean B = A.
impl PartialEq for HighScore {
    fn eq(&self, other: &Self) -> bool {
        self.score == other.score
    }
}

// Used for comparisons between HighScores. Required by Ord.
//
// This implies that A = B means B = A.
impl Eq for HighScore {}

impl HighScore{
    /// Returns a new instance of Highscore.
    pub fn new(
        score: Score,
        character: &Character,
        player: AccountId,
    ) -> Self {

        HighScore{
            score,
            character: character.clone(),
            player,
        }
    }

    /// Makes a comparison between the new and old high scores. If a new high_score for the player is achieved, update current and return a copy.
    pub fn update_highscore(
        current_highscore: &mut Option<HighScore>,
        new_high_score: Option<HighScore>,
    ) -> Option<HighScore> {

        // This match will stop assigning the new highscore if one has not been achieved.
        match (&current_highscore, &new_high_score) {
            (_, None) => { 
                // No highscore was achieved by the character.
                return None; 
            },
            (None, Some(_)) => {},
            (Some(old_high_score), Some(new_high_score)) => {
                // A character achieved a highscore
                // there is a highscore recorded.
                // makes a comparison and maintain the highest.
                if old_high_score > new_high_score {
                    return None;
                }
            },
        }

        // assign the new highscore
        *current_highscore = new_high_score.clone();

        return new_high_score;
    }

    /// Returns score achieved.
    pub fn get_score(&self) -> Score {
        self.score
    }

    /// Returns character for this highscore.
    pub fn get_character(&self) -> Character {
        self.character.clone()
    }

}

'''
'''--- PT-BR/lesson_6_enums/lesson_6_3_game_score/src/model/score/mod.rs ---
mod high_score;
mod ranking;

pub(crate) use high_score::HighScore;
pub(crate) use ranking::Ranking;
pub type Score = u32;

'''
'''--- PT-BR/lesson_6_enums/lesson_6_3_game_score/src/model/score/ranking.rs ---
use near_sdk::{
    borsh::{ BorshDeserialize, BorshSerialize, self},
    env,
    log, 
    serde::{Deserialize, Serialize},
};

use crate::model::{
    score::HighScore,
    Errors,
    // StorageKey,
};

// Just for this exampĺe, we just want max 10 values in the ranking.
// const RANKSIZE: usize = 10;

/// Contains the top ranked matches stored in the smart contract.
/// 
/// It's just a vector. So to avoid high costs sorting.
/// 
/// We limit the max number of entries to RANKSIZE.
/// 
/// Suggestion for change. Store the score of the lowest highscore in the ranking. 
/// Only update and sort the list when a value higher than such is included.
#[derive(BorshDeserialize, BorshSerialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Ranking{
    values: Vec<HighScore>,
    max_size: usize,
    lowest_high_score: Option<HighScore>,
}

impl Serialize for Ranking {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: near_sdk::serde::Serializer {

        serializer.collect_seq(self.values.iter().map(|x| x))
    }
}

impl Default for Ranking{
    fn default() -> Self {
        // let values: Vec<HighScore> = Vector::new(StorageKey::Ranking);
        let max_size: usize = 10;
        let values: Vec<HighScore> = Vec::with_capacity(max_size);
        let lowest_high_score: Option<HighScore> = None;

        Self { 
            values,
            max_size,
            lowest_high_score,
        }
    }
}

impl Clone for Ranking{
    fn clone(&self) -> Self {
        let max_size: usize = self.max_size.clone();
        let mut values: Vec<HighScore> = Vec::with_capacity(max_size);
        let lowest_high_score: Option<HighScore> = self.lowest_high_score.clone();
        
        for value in self.values.iter(){
            values.push(value.clone());
        }

        Self { 
            values,
            max_size,
            lowest_high_score,
        }
    }
}

impl Ranking{

    fn sort_and_resize(&mut self) {
        self.values.sort();
        self.values.truncate(self.max_size);
    }

    /// This is only called when the ranking list is full.
    /// Add the entry to the list, sort it, then remove all the excess elements.
    /// Finally, set the lowest high score value to the element at the end of the list.
    fn new_entry(&mut self, entry: HighScore) {
        self.values.push(entry);

        // Sort the highscores and resize it to RANKSIZE (If it has more values than RANKSIZE)
        self.sort_and_resize();

        let lowest_high_score = self.values.last();

        match lowest_high_score {
            None => env::panic_str("Smart contract implementation error. This should never happen. Called Ranking::new_entry and got a None."),
            Some(lowest) => {
                self.lowest_high_score = Some(lowest.clone());
            }
        }
    }

    pub fn set_max_highscore_players(&mut self, max_size: usize) -> Result<(), Errors>{
        let limit = 1000;

        if max_size > limit {
            return Err(Errors::ExcessiveMaxRankingPlayers(limit, max_size));
        }

        self.max_size = max_size;

        Ok(())
    }

    pub fn check_highscore(
        &mut self, 
        high_score: &Option<HighScore>,
    ) -> bool {
        match high_score {
            None => { 
                // Player didn't achieve a high score.
                false
            },
            Some(high_score) => {
                log!("New High Score for this Player.");

                // Compiler will apply branchless optimization to all these if/else statements.
                if self.lowest_high_score.is_none() {
                    // This is the first entry, so just include it.
                    self.new_entry(high_score.clone());

                    return true;
                } else {
                    // This is not the first entry.
                    // The list may be full or not.
                    let ranking_is_full: bool = self.values.len() == self.max_size;

                    if !ranking_is_full {
                        // If the list is not full, just include it.
                        self.new_entry(high_score.to_owned());

                        return true;
                    } else {
                        // .unwrap will never panic because of the first "if" above. It is always Some.
                        // We are cloning because unwrap will take ownership of this mutable reference.
                        let lowest_high_score = self.lowest_high_score
                            .clone()
                            .unwrap();

                        if lowest_high_score < *high_score {
                            self.new_entry(high_score.clone());

                            return true;
                        }
                        
                        false
                    }
                }
            }
        }
    }

}
'''
'''--- PT-BR/lesson_6_enums/lesson_6_3_game_score/src/model/storage.rs ---
use near_sdk::{
    AccountId,
    BorshStorageKey,
    borsh::{self, BorshSerialize},
};

/// Keys used for storing values in trie. Required for collections like UnorderedSet and LookupMap.
/// 
/// We have to make sure that each collection has a unique prefix.
#[derive(BorshStorageKey, BorshSerialize)]
pub enum StorageKey {
    // Holds no argument because only one LookupMap for Players in the entire smart contract.
    Players,
    
    // Holds an account Id because Each player has one UnorderedSet for the characters. The AccountId is used to tell these types apart.
    Characters(AccountId),

    // Same for character names. It's an UnorderedSet that is different between each player. 
    // So we use the AccountId (unique for each player) within the tuple.
    CharacterNames(AccountId),
}
'''
'''--- PT-BR/static/Readme.md ---
Imagens e tutoriais.

'''
'''--- PT-BR/static/tutorials/cargo.md ---
# Introdução a Cargo

Cargo é a ferramenta que usamos para administrar nossos projetos da linguagem rust. Documentação completa sobre Cargo no [livro Cargo](https://doc.rust-lang.org/cargo/).

 - [Cargo.toml](#cargotoml)
 - [O que é crate](#o-que-%C3%A9-crate)
   - [crates.io](#cratesio)
 - [Comandos Cargo](#comandos-cargo)
   - [cargo build](#cargo-build)
   - [cargo test](#cargo-test)
   - [cargo doc](#cargo-doc)

## Cargo.toml
[topo](#introdu%C3%A7%C3%A3o-a-cargo)

Semelhante a ```package.json``` para ```node.js```, este arquivo possui todas as informações meta sobre este diretório. Características como nome e versão, mas também configurações sobre como o projeto deve ser compilado.

![Imagem de um arquivo Cargo.toml padrão. Identico ao Cargo.toml da lição 1.](../images/cargo.png)

Não é necessário saber tudo sobre essas configurações. As configurações que precisaremos alterar são ```[package]``` e ```[dependencies``` de projeto em projeto. A seguir, descrevemos os tópicos principais:
 - **package**: Configurações sobre a crate. Nome, versão, licensa, edição do Rust, etc; 
 - **lib**: Isso determina que esta crate não é um executável. E sim é uma biblioteca que será acessada externamente. ```cdylib``` quer dizer "c dynamic library", ```rdylib``` quer dizer "rust dynamic library". Acho que o compilador webassembly precisa dessas configurações.
 - **dependencies**: Aqui declaramos nossas dependencias. Podemos incluir de varias formas. O padrão é vindo do site "crates.io", mas podemos também incluir crates locais; podemos incluir através de um link github, etc.
 - **profile.release**: Configuração para projetos compilados para "release". Não é necessário entender cada instrução. Simplesmente fala para o compilador tentar optimizar o máximo possivel, quando um erro (panic) acontece, finaliza o runtime, et cetera.

## O que é crate?
[topo](#introdu%C3%A7%C3%A3o-a-cargo)

**Crate** (caixa) representa um diretório com um arquivo "Cargo.toml".

Geralmente, cada crate gera um diretório "target" com o arquivo compilado. Mas se criarmos um workspace, que é um conjunto de várias crates compartilhando um "Cargo.toml", os arquivos compilados são todos agrupados na mesma pasta. Para mais detalhes, cheque a lição sobre workspaces.

Podemos publicar nossas crates no site [crates.io](https://crates.io/).

### Crates.io
[topo](#introdu%C3%A7%C3%A3o-a-cargo)

Dependências como ```near_sdk``` são baixadas deste site. Qualquer desenvolvedor rust pode compartilhar projetos neste site, com **uma condição**: Deve ser open-source.

O site intencionalmente não disponibiliza opção para compartilhar crates de forma privada.

![](../images/crates.io.png)

Para impedir que projetos quebrem de forma inesperada, se retirarmos uma versão do registry usando o comando "yank", projetos não poderão mais baixar a versão, mas ainda continuarão funcionando se tiverem a versão baixada.

## Comandos Cargo
[topo](#introdu%C3%A7%C3%A3o-a-cargo)

Segue uma lista simplificada de comandos cargo que podemos utilizar durante desenvolvimento de contratos NEAR.

 - build: compila o projeto.
 - test: executa testes de unidade.

Só isso. Existem vários outros comandos que podemos executar com cargo. Mas não são necessários para novos desenvolvedores. Cheque o [livro Cargo](https://doc.rust-lang.org/cargo/).

### Cargo build
[topo](#introdu%C3%A7%C3%A3o-a-cargo)

Precisamos compilar o projeto para webassembly, sem uma arquitetura especificada. Para isso usamos:

```bash
cargo build --release --target wasm32-unknown-unknown
```

 - ```release``` corta todas as partes da compilação feitas para auxiliar o debug e otimiza o código para produção
 - ```target``` determina a arquitetura alvo para o projeto. Escolhemos webassembly.

O arquivo webassembly estará no caminho '/target/wasm32-unknown-unknown/release/'.

**Aviso**: Essa instrução irá resultar em **erro** se não instalarmos ```wasm32-unknown-unknown``` na lista de alvos da linguagem rust. Para isto, basta executar a seguinte instrução (apenas uma vez para cada instalação de rust).

```bash
rustup target add wasm32-unknown-unknown
```

### Cargo test
[topo](#introdu%C3%A7%C3%A3o-a-cargo)

Realiza todos os testes de unidade no projeto. Se uma função possui o marcador ```#[test]```, essa função será executada.

Testes de unidade simplesmente procuram por situações de pânico. Se um pânico inesperado acontece, ou um pânico esperado não acontece, o teste falha.

Macros como panic, assert e assert_eq são usados para garantir nossas condições.
 - ```panic!("Mensagem");```: Causa pânico com a dada mensagem.
 - ```assert!(condicao, "Mensagem");```: Causa pânico se a condição for falsa. Está "garantindo" que a condição será verdadeira.
 - ```assert_eq!(primeiro, segundo, "Mensagem");```: Compara ```primeiro == segundo```. Se forem diferentes, causa pânico com a dada mensagem.

Exemplo de situação em que não esperamos panic:

```rust
#[test]
fn oneplusone() {
    assert_eq!(1 + 1, 2);
}
```

1+1 é sempre igual a 2. Então nunca haverá panic.

Exemplo de situação em que esperamos panic:

```rust
#[test]
#[should_panic(expected = "A panic has just happened")]
pub fn this_will_panic() {
    env_setup();

    let _contract: Contract = Contract::default();

    Contract::this_will_panic();
}
```

Este é um exemplo da "lição 4 - módulos". A função ```this_will_panic()``` é uma função que eu criei que sempre causa pânico.

```#[should_panic]``` significa que o teste vai falhar se não entrar em panic. ```expected``` especifica qual a mensagem de pânico esperada.

Isso é tudo sobre testes para contrato. Para simular a comunicação entre contratos, precisamos de utilizar workspaces-rs.

### Cargo doc
[topo](#introdu%C3%A7%C3%A3o-a-cargo)

Gera uma página de web com a documentação do projeto. Muito fácil de compartilhar. A pagina de web estará no caminho "/target/doc/nome_da_crate/".

```bash
cargo doc --open
```
Irá abrir a pagina de web no navegador padrão.

![](../images/cargodoc.png)

Clique em Contract para ver as funções implementadas:

![](../images/cargodoccontract.png)

Comentários com ```//``` não aparecem na documentação.

[Voltar](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/PT-BR/)

'''
'''--- PT-BR/static/tutorials/nearcli.md ---
# Introdução a near-cli

Near CLI ("command line interface") é a ferramenta que utilizamos para interagir com o protocolo blockchain. Documentação completa sobre near-cli no [tutorial](https://docs.near.org/docs/tools/near-cli).

## Conta NEAR (Simplificado)

Uma conta NEAR pode ser vista como uma carteira. Podemos transferir NEAR, receber, executar funções em contratos inteligentes de outras contas, criar chaves de acesso com certas permissões, etc.

Um smart contract pode ser implementado em uma conta NEAR, mas não é obrigatório para que essa exista. Cada conta ou sub-conta NEAR só pode ter um contrato de cada vez. Mas uma conta NEAR pode ser mestre (permissões administrativas) de várias sub-contas.

Ou seja, quando precisarmos de implementar vários contratos, podemos distribui-los em uma hierarquia de diversas contas com maior segurança. As subcontas só precisam das permissões necessárias para seus objetivos. As subcontas só precisam da quantidade de gas necessárias para se manterem em operação.

**gas**: É NEAR gasto para computação, armazenamento de dados, criação de contas, etc. A cada clock de computação, uma fração de NEAR é consumida da conta. As máquinas que mantém nosso sistema em funcionamento devem ser recompensadas, por isso utilizamos **gas** é consumido.

## Lista de Comandos

Discutiremos alguns comandos a seguir:
 - [Login](#login)
 - [Checar State](#checar-state-estado)
 - [Criar Sub-conta](#criar-sub-conta)
 - [Implantar Contrato](#implantar-contrato)
   - [Evitando Inicialização Sem argumentos](#evitando-inicializa%C3%A7%C3%A3o-sem-argumentos)
 - [Executar Funções de Contrato](#executando-funções-do-contrato)
   - [View](#view)
   - [Call](#call)
 - [Deletar Sub-Conta](#deletar-sub-conta)

## Login
[topo](#introdu%C3%A7%C3%A3o-a-near-cli)

```bash
near login
```

![Imagem de um navegador conectando à plataforma NEAR, ao lado um terminal com o comando near login.](../images/nearlogin.png)

Não é a nossa máquina que executa as funções de contrato descentralizadas. A nossa conta na blockchain que faz isso. Nós conectamos a uma conta testnet com este comando.

**testnet**: é uma plataforma de teste NEAR. Os tokens não tem valor e não é possivel comercializá-los. A plataforma oficial é a **mainnet**. Garanta que não há riscos no contrato antes de implementar para produção.

## Checar State (Estado)
[topo](#introdu%C3%A7%C3%A3o-a-near-cli)

```bash
near state stiltztinkerstein.testnet
```

Podemos checar o estado de qualquer conta na blockchain. É informação pública.

![Imagem de terminal após o uso do comando acima.](../images/nearstate.png)

Lembrar que esta é uma conta **testnet**. Não é dinheiro de verdade. Os atributos que conseguimos são estes:

 - **amount**: Quantidade de NEAR na conta em yocto Near. ```1 * 10²⁴ = 1 NEAR```.
 - **block_hash**: Hash do bloco;
 - **block_height**: Altura do bloco;
 - **code_hash**: Se o hash de código for uma sequência de "1", então nenhum smart contract foi implementado nesta conta;
 - **locked**: Quantidade de NEAR trancado?*;
 - **storage_paid_at**: Custo de armazenamento?*;
 - **storage_usage**: Uso de armazenamento?*;
 - **formattedAmount**: **amount** formatado para NEAR.

*: Quem tiver mais informações sobre os detalhes com *, agradeceria um pull-request.

## Criar sub-conta
[topo](#introdu%C3%A7%C3%A3o-a-near-cli)

Podemos criar uma subconta com um comando semelhante a este:

```bash
near create-account minha-subconta.minha-conta.testnet --masterAccount minha-conta.testnet --initialBalance 10
```

 - **nome-da-conta.minha-conta.testnet**: Nome da subconta que criei;
 - **minha-conta.testnet**: nome da conta mestre;
 - **masterAccount**: conta mestre;
 - **initialBalance 10**: Opcional. A conta mestre enviará 10 NEAR para a subconta;

Para criar uma conta de topo nível, use [near-api-js](https://docs.near.org/docs/api/naj-cookbook#create-account).

## Implantar Contrato
[topo](#introdu%C3%A7%C3%A3o-a-near-cli)

```bash
near deploy --accountId minha-subconta.minha-conta.testnet --wasmFile ./compilado.wasm
```

Após compilar nosso projeto (cheque o [tutorial cargo](https://github.com/On0n0k1/Tutorial_NEAR_Rust/blob/main/PT-BR/static/tutorials/cargo.md)), usamos este comando para implantar o arquivo compilado em nossa subconta.

 - **accountId**: ID da conta em que implantaremos o contrato;
 - **wasmFile**: Caminho para o arquivo webassembly compilado;

O estado inicial deste contrato será a trait ```Default``` que implementamos no código rust. Essa trait não recebe parâmetros para inicialização. Se quisermos usar um construtor com parâmetros de inicialização, precisamos de seguir dois passos:

O primeiro passo é declarar um construtor com marcador ```#[init]```. Exemplo:

```rust
#[init]
pub fn new(title: String, data: String, category: i8) -> Self {
```

O nome da função ```new``` não é obrigatório. Mas é convenção criar construtores com este nome.

O segundo passo é incluir os parâmetros ```--initFunction``` e ```--initArgs``` para inicializar o contrato com a função e argumentos, respectivamente.

O comando de implantação poderia ser chamado da seguinte forma:

```bash
near deploy --accountId minha-subconta.minha-conta.testnet --wasmFile ./compilado.wasm --initFunction new --initArgs '{"title": "um-titulo", "data": "link-para-dados", "category": 3 }'
```

### Evitando inicialização sem argumentos
[topo](#introdu%C3%A7%C3%A3o-a-near-cli)

A trait ```Default``` é um requisito para o funcionamento do contrato, mesmo se não pretendermos utilizá-la. Se a inicialização com argumentos for essencial para o funcionamento do contrato, podemos fazer com que o processo entre em pânico caso o sistema tente inicializar com ```Default```.

Duas forma de causar "panic em ```Default```" são descritos a seguir:

Na implementação de ```Default```:
```rust
impl Default for Contract{
    fn default() -> Self{
        panic!("The contract is not initialized");
    }
}
```

Derivando ```PanicOnDefault``` na declaração de ```Contract```:

```rust
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract{
```

Ambas as alternativas fazem exatamente a mesma coisa.

## Executar funções do contrato
[topo](#introdu%C3%A7%C3%A3o-a-near-cli)

Existem dois tipos de funções de contrato:
 - **view**: Não realiza computação e não altera estado do contrato. Não consome gás. Ou seja, é de graça.
 - **call**: Todos os outros tipos de função. Consomem gás. Podem necessitar um pagamento. A implementação da função pode incluir outras restrições, como restrições de chave, restrições de usuário, et cetera.

### View
[topo](#introdu%C3%A7%C3%A3o-a-near-cli)

Para facilitar o entendimento, vale lembrar que o estado de todos os contratos são publicos.

Se uma função simplesmente retorna um valor armazenado no estado, então pode ser uma função view. Funções view não consomem gás, e não precisam de pagamento.

Funções view não podem realizar nenhum cálculo, e não podem alterar o estado do contrato.

Usaremos o contrato abaixo como exemplo:

```rust
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Contract{
    counter: i32,
    nome: String,
}
```

Os exemplos abaixo são exemplos válidos para funções view:

```rust
#[near_bindgen]
impl Contract{
    pub fn get_counter(&self) -> i32 {
        // i32 implementa Copy
        self.counter
    }

    pub fn get_counter1(&self) -> i32 {
        // O mesmo que get_counter
        return self.counter;
    }

    pub fn get_nome(&self) -> String {
        // String não implementa copy
        // Strign implementa Clone
        self.nome.clone()
    }

    pub fn get_nome1(&self) -> String {
        // O mesmo que get_nome
        return self.nome.clone();
    }
}
```

Uma breve explicação sobre alguns traits. Para um tipo implementar Copy, este precisa de implementar Clone.

Se um tipo implementar Clone, podemos criar uma cópia desse tipo com o método ```clone()```. Se um tipo implementar Copy, a cópía será feita automaticamente quando necessário. A instrução seguinte para i32:

```rust
return self.counter;
```

Se counter não implementasse ```Copy``` ou ```Clone```, teriamos um erro. Porque transferimos esse endereço de variável para outro lugar. Counter não teria um valor, pois a "ownership" foi perdida. O compilador não irá permitir essa transferência.

O exemplo a seguir **não** pode ser função view.

```rust
pub fn um_numero() -> i32 {
    5
}
```

Embora a função simplesmente retorna um número, é ainda considerada computação. Relembrando, funções view apenas retornam o valor de um estado do contrato (que é informação pública).

#### Executando uma função view
[topo](#introdu%C3%A7%C3%A3o-a-near-cli)

```bash
near view minha-subconta.minha-conta.testnet get_counter '{}'
```

### Call
[topo](#introdu%C3%A7%C3%A3o-a-near-cli)

Qualquer outro tipo de função que não é ```view```, é ```call```.

Para o contrato abaixo...

```rust
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Contract{
    counter: i32
}
```

... temos o exemplo de função ```call``` a seguir:

```rust
#[near_bindgen]
impl Contract{
    pub fn increment(&mut self) -> i32 {
        self.counter += 1;
        self.counter
    }
}
```

Exemplo retirado da "lição 1 - contratos". Incrementa counter em 1, e retorna o valor.

Podemos chamar a função da seguinte forma:

```bash
near call minha-subconta.minha-conta.testnet increment '{}' --account-id minha-conta.testnet
```

## Deletar Sub-Conta
[topo](#introdu%C3%A7%C3%A3o-a-near-cli)

```bash
near delete minha-subconta.minha-conta.testnet minha-conta.testnet
```

O primeiro argumento é o nome da sub-conta a deletar. O segundo argumento é o nome da conta que irá receber todo o NEAR armazenado.

'''
'''--- PT-BR/static/tutorials/rust.md ---
# Instalação Rust

Este tutorial descreve a instalação das ferramentas recomendadas para criação de projetos NEAR em Rust.

 - [Scripts de Instalação](#scripts-de-instala%C3%A7%C3%A3o)
 - [Rustlings](#rustlings)
 - [Rust](#rust)

Instalaremos várias ferramentas diferentes com uma única linha de comando. Às que destacaremos nesse tutorial são: **rustup**, **cargo** e **rustc**.

 - **rustc**: compila o código rust para linguagem de máquina;
 - **cargo**: permite realizar comandos especificos para o projeto como compilar, criar documentação, realizar testes de unidade, executar projeto como binário.
 - **rustup**: existem varias diferentes formas de se compilar um projeto. Diversas arquiteturas diferentes. Diversas versões. rustup controla estas versões.

Uma analogia para desenvolvedores javascript:
 - rustup age de forma semelhante a nvm.
 - cargo age de forma semelhante a npm.
 - rustc age de forma semelhante a node.

É apenas uma analogia, existem algumas diferenças que serão encontradas em pratica.

## Scripts de instalação
[topo](#instala%C3%A7%C3%A3o-rust)

Recomendaremos duas alternativas para instalação de Rust. A primeira é recomendada para estudo, a segunda é recomendada para quem simplesmente quer instalar rustup.

 - rustlings: Instala rust e instala a ferramenta rustlings, que possui exercicios para desenvolvedores praticarem seu entendimento.
 - rust: Instala rust e todas as ferramentas necessárias para desenvolvimento.

## Rustlings
[topo](#instala%C3%A7%C3%A3o-rust)

Acesse o [repositório](https://github.com/rust-lang/rustlings) e siga as instruções de instalação.

![Pagina de web rust](../images/rustlings.png)

#### Rustlings para MacOS/Linux
[topo](#instala%C3%A7%C3%A3o-rust)

```bash
curl -L https://git.io/install-rustlings | bash
# Ou se quiser escolher o diretorio de instalação
curl -L https://git.io/install-rustlings | bash -s mypath/
```

### Rustlings para Windows
[topo](#instala%C3%A7%C3%A3o-rust)

Executar em um powershell com permissões de administrador.

```bash
Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser
```

E depois executar:

```bash
Start-BitsTransfer -Source https://git.io/JTL5v -Destination $env:TMP/install_rustlings.ps1; Unblock-File $env:TMP/install_rustlings.ps1; Invoke-Expression $env:TMP/install_rustlings.ps1
```

## Rust
[topo](#instala%C3%A7%C3%A3o-rust)

Acesse a [pagina oficial](https://www.rust-lang.org/tools/install) e execute o script. 

![Pagina de web rust](/static/images/rust.png)

```bash
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
```

Este comando detecta o sistema e instala todas as ferramentas necessárias.

'''
'''--- PT-BR/static/tutorials/setup-nearcli.md ---
# Instalação NEAR CLI

NEAR CLI (NEAR Command Line Interface) é utilizado para fazer login e interagir com contas NEAR.

Uma explicação detalhada sobre a ferramenta pode ser encontrada no seguinte link: https://github.com/near/near-cli

Os passos são descritos e detalhados a seguir:

 - Instalar NPM (Node Package Manager)
 - Instalar NodeJs
 - Instalar NEAR CLI globalmente

## Windows

### Instalar NVM e NPM

Instale NPM de acordo com as descrições do [link](https://github.com/near/near-cli). Vou incluir os detalhes mais tarde. Agradeceria um pull request com o passo-a-passo para desenvolvedores Windows.

### Instalar NodeJs (versão 12+)

```bash
nvm install 12
nvm use 12
```

### Instalar NEAR CLI Globalmente

```bash
npm install -g near-cli
```

## Ubuntu

### Instalar NVM e NPM

[Link com Detalhes](https://linuxize.com/post/how-to-install-node-js-on-ubuntu-20-04/)

```bash
sudo apt update
sudo apt install nodejs npm
```

### Instalar NodeJs (versão 12+)

```bash
nvm install 12
nvm use 12
```

### Instalar NEAR CLI Globalmente

```bash
npm install -g near-cli
```

'''
'''--- Readme.md ---
# Rust tutorial

 - [Para Portugues](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/PT-BR)
 - [For English](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/EN)
 - [Para español](https://github.com/On0n0k1/Tutorial_NEAR_Rust/tree/main/ES)  -- WIP

'''