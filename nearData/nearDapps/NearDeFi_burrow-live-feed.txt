*GitHub Repository "NearDeFi/burrow-live-feed"*

'''--- package.json ---
{
  "name": "burrow-live-feed",
  "version": "0.2.0",
  "private": true,
  "dependencies": {
    "@testing-library/jest-dom": "^5.14.1",
    "@testing-library/react": "^12.0.0",
    "@testing-library/user-event": "^13.2.1",
    "big.js": "^6.1.1",
    "bootstrap": "^5.1.3",
    "error-polyfill": "^0.1.3",
    "local-storage": "^2.0.0",
    "near-api-js": "^0.44.2",
    "node-sass": "^4.0.0",
    "react": "^17.0.2",
    "react-dom": "^17.0.2",
    "react-scripts": "^4.0.0",
    "react-singleton-hook": "^3.2.3",
    "sass": "^1.50.0",
    "sass-loader": "^12.6.0",
    "swr": "^1.2.2",
    "timeago-react": "^3.0.4",
    "web-vitals": "^2.1.0"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject",
    "node_16_install": "CXXFLAGS=\"--std=c++17\" yarn install"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  },
  "devDependencies": {
    "prettier": "^2.2.1"
  }
}

'''
'''--- public/index.html ---
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Live feed of actions from Burrow on NEAR blockchain"
    />
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
    <title>Live Burrow feed (NEAR)</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
  </body>
</html>

'''
'''--- public/manifest.json ---
{
  "short_name": "Live Burrow Feed",
  "name": "Live Burrow feed (NEAR)",
  "icons": [
    {
      "src": "favicon.png",
      "type": "image/png",
      "sizes": "256x256"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#000000",
  "background_color": "#ffffff"
}

'''
'''--- public/robots.txt ---
# https://www.robotstxt.org/robotstxt.html
User-agent: *
Disallow:

'''
'''--- src/App.js ---
import "./App.scss";
import "error-polyfill";
import "bootstrap/dist/js/bootstrap.bundle";
import React, { useEffect, useState } from "react";
import TimeAgo from "timeago-react";
import SocialAccount from "./components/SocialAccount/SocialAccount";
import { keysToCamel } from "./data/utils";
import TokenBalance from "./components/token/TokenBalance";
import Big from "big.js";
import TokenBadge from "./components/token/TokenBadge";
import MutedDecimals from "./components/common/MutedDecimals";

let globalIndex = 0;

const ContractId = "contract.main.burrow.near";
const DefaultTokenId = "token.burrow.near";

const defaultBurrowFilter = {
  status: "SUCCESS",
  accountId: ContractId,
  event: {
    standard: "burrow",
  },
};

function makeFilter(filterAccountId, filterLiquidations) {
  if (filterAccountId) {
    let filter = [
      makeFilter(null, filterLiquidations),
      makeFilter(null, filterLiquidations),
    ];
    filter[0].event.data = [{ account_id: filterAccountId }];
    filter[1].event.data = [{ liquidation_account_id: filterAccountId }];
    return filter;
  } else {
    let filter = JSON.parse(JSON.stringify(defaultBurrowFilter));
    if (filterLiquidations) {
      filter.event.event = "liquidate";
    }
    return filter;
  }
}

let burrowFilter = makeFilter();

let reconnectTimeout = null;
let ws = null;

let filterTypingTimeout = null;

function listenToBurrow(processEvents) {
  const scheduleReconnect = (timeOut) => {
    if (reconnectTimeout) {
      clearTimeout(reconnectTimeout);
      reconnectTimeout = null;
    }
    reconnectTimeout = setTimeout(() => {
      listenToBurrow(processEvents);
    }, timeOut);
  };

  if (document.hidden) {
    scheduleReconnect(1000);
    return;
  }

  if (ws) {
    ws.close();
    return;
  }

  ws = new WebSocket("wss://events.near.stream/ws");
  // ws = new WebSocket("ws://localhost:3006/ws");

  ws.onopen = () => {
    console.log(`Connection to WS has been established`);
    ws.send(
      JSON.stringify({
        secret: "brrr",
        filter: burrowFilter,
        fetch_past_events: 500,
      })
    );
  };
  ws.onclose = () => {
    ws = null;
    console.log(`WS Connection has been closed`);
    scheduleReconnect(1);
  };
  ws.onmessage = (e) => {
    const data = JSON.parse(e.data);
    processEvents(data.events);
  };
  ws.onerror = (err) => {
    ws = null;
    console.log("WebSocket error", err);
  };
}

function processEvent(event) {
  return {
    index: globalIndex++,
    time: new Date(event.blockTimestampMs),
    accountId: event.event.data[0].accountId,
    event: event.event.event,
    data: event.event.data[0],
  };
}

function App() {
  const [burrowActions, setBurrowActions] = useState([]);

  const urlParams = new URLSearchParams(window.location.hash.replace("#", "?"));
  const [filterAccountId, setFilterAccountId] = useState(
    urlParams.get("account") || null
  );
  const [filterLiquidations, setFilterLiquidations] = useState(null);

  useEffect(() => {
    const processEvents = (events) => {
      events = events.map(keysToCamel).flatMap(processEvent);
      events.reverse();

      setBurrowActions((prevState) => {
        const newActions = [
          ...events.filter(
            (event) =>
              prevState.length === 0 ||
              event.time.getTime() > prevState[0].time.getTime()
          ),
          ...prevState,
        ];
        return newActions.slice(0, 500);
      });
    };

    listenToBurrow(processEvents);
  }, []);

  useEffect(() => {
    if (filterAccountId === null && filterLiquidations === null) {
      return;
    }
    burrowFilter = makeFilter(filterAccountId, filterLiquidations);
    if (filterTypingTimeout) {
      clearTimeout(filterTypingTimeout);
      filterTypingTimeout = null;
    }
    const accountId = filterAccountId;
    filterTypingTimeout = setTimeout(() => {
      if (!accountId) {
        window.location.href = "/#";
      } else {
        window.location.href = `/#account=${accountId}`;
      }
      if (ws) {
        setBurrowActions([]);
        ws.close();
      }
    }, 500);
  }, [filterAccountId, filterLiquidations]);

  const showAction = (action) => {
    switch (action.event) {
      case "liquidate":
        return (
          <>
            <div>
              Liquidation! Profit{" "}
              <span className="font-monospace fw-bold">
                <span className="text-secondary">$</span>
                <MutedDecimals
                  value={(
                    parseFloat(action.data.collateralSum) -
                    parseFloat(action.data.repaidSum)
                  ).toFixed(2)}
                />
              </span>
              {}
              :
              <br />
              <SocialAccount
                accountId={action.data.liquidationAccountId}
                clickable
                filterLink={setFilterAccountId}
              />
            </div>
          </>
        );
      case "force_close":
        return (
          <>
            <div>
              Force closing! Protocol loss:{" "}
              <span className="font-monospace fw-bold">
                <span className="text-secondary">$</span>
                <MutedDecimals
                  value={(
                    parseFloat(action.data.repaidSum) -
                    parseFloat(action.data.collateralSum)
                  ).toFixed(2)}
                />
              </span>
              {}
              :
              <br />
              <SocialAccount
                accountId={action.data.liquidationAccountId}
                clickable
                filterLink={setFilterAccountId}
              />
            </div>
          </>
        );
      default:
        return action.event;
    }
  };

  return (
    <div className="container">
      <a href="/#" onClick={() => setFilterAccountId("")}>
        <h1>Live Burrow feed</h1>
      </a>
      <div className="form-check">
        <input
          className="form-check-input"
          type="checkbox"
          id="liquidationsFilter"
          value={filterLiquidations || ""}
          onChange={(e) => setFilterLiquidations(e.currentTarget.checked)}
        />
        <label className="form-check-label" htmlFor="liquidationsFilter">
          Liquidations only
        </label>
      </div>
      <div className="row justify-content-md-center">
        <div className="col-auto">
          <label className="col-form-label" htmlFor="accountIdFilter">
            Filter by account ID:
          </label>
        </div>
        <div className="col">
          <input
            className="form-control"
            type="text"
            id="accountIdFilter"
            placeholder="Account ID"
            value={filterAccountId || ""}
            onChange={(e) => setFilterAccountId(e.target.value)}
          />
        </div>
      </div>
      <div className="table-responsive">
        <table className="table align-middle">
          <tbody>
            {burrowActions.map((action) => {
              const tokenAccountId = action.data?.tokenId || DefaultTokenId;
              return (
                <tr key={action.index}>
                  <td className="col-1">
                    <TimeAgo datetime={action.time} />
                  </td>
                  <td className="col-3">
                    <SocialAccount
                      accountId={action.accountId}
                      clickable
                      filterLink={setFilterAccountId}
                    />
                  </td>
                  <td className="col-3">{showAction(action)}</td>
                  <td className="col-1 text-end">
                    <TokenBalance
                      clickable
                      tokenAccountId={tokenAccountId}
                      adjustForBurrow
                      balance={Big(action.data?.amount || 0)}
                    />
                  </td>
                  <td className="col-3">
                    <TokenBadge tokenAccountId={tokenAccountId} />
                  </td>
                </tr>
              );
            })}
          </tbody>
        </table>
      </div>
    </div>
  );
}

export default App;

'''
'''--- src/App.test.js ---
import { render, screen } from '@testing-library/react';
import App from './App';

test('renders learn react link', () => {
  render(<App />);
  const linkElement = screen.getByText(/learn react/i);
  expect(linkElement).toBeInTheDocument();
});

'''
'''--- src/components/SocialAccount/SocialAccount.js ---
import React from "react";
import DefaultAvatar from "../../images/sasha_anon.png";
import { useSocialAccount } from "../../data/socialAccount";
import "./SocialAccount.scss";
import { accountTrim } from "../../data/utils";
import LinkToAccountPage from "../../images/link_to_account_page.png";

export default function SocialAccount(props) {
  const accountId = props.accountId;
  const clickable = props.clickable;
  const filterLink = props.filterLink;
  const socialAccount = useSocialAccount(accountId);
  const avatarUrl = socialAccount?.avatar?.url || DefaultAvatar;
  const shortenAccountId = accountTrim(accountId);
  const displayName = socialAccount?.displayName
    ? `${socialAccount.displayName} (${shortenAccountId})`
    : shortenAccountId;
  const accountUrl = `https://explorer.near.org/accounts/${accountId}`;
  const inner = (
    <div className="social-account">
      <img src={avatarUrl} title={accountId} alt={accountId} />
      <span title={accountId}>{displayName}</span>
    </div>
  );

  return (
    <>
      {clickable ? <a href={accountUrl}>{inner}</a> : inner}
      {filterLink && (
        <a
          href={`/#account=${accountId}`}
          onClick={() => filterLink(accountId)}
        >
          <img
            src={LinkToAccountPage}
            title={`Filter ${accountId} actions`}
            alt={`Filter ${accountId} actions`}
            style={{ paddingLeft: "5px" }}
          />
        </a>
      )}
    </>
  );
}

'''
'''--- src/components/common/MutedDecimals.js ---
import React from "react";

export default function MutedDecimals(props) {
  const value = props.value;

  const dotPos = value.indexOf(".");
  if (dotPos > 0) {
    return (
      <>
        {value.charAt(0) === "<" ? (
          <>
            <span className="text-secondary">{"<"}</span>
            {value.substring(1, dotPos)}
          </>
        ) : (
          value.substring(0, dotPos)
        )}
        <span className="text-secondary">{value.substring(dotPos)}</span>
      </>
    );
  }
  return value;
}

'''
'''--- src/components/token/TokenBadge.js ---
import "./TokenBadge.scss";
import React from "react";
import { useToken } from "../../data/token";

export default function TokenBadge(props) {
  const tokenAccountId = props.tokenAccountId;
  const token = useToken(tokenAccountId);
  const tokenOk = token && !token.invalidAccount && !token.notFound;
  const name = tokenOk ? token.metadata.name : "";
  const icon = tokenOk && token.metadata.icon;
  const symbol = tokenOk ? token.metadata.symbol : tokenAccountId;
  return (
    <div className="d-inline-block token-badge">
      <div className="token-name text-truncate" title={name}>
        {name}
      </div>
      <div title={tokenAccountId}>
        {icon && <img src={icon} alt="Token Icon" />}
        <span className="font-monospace align-middle text-truncate">
          {symbol}
        </span>
      </div>
    </div>
  );
}

'''
'''--- src/components/token/TokenBalance.js ---
import React, { useState } from "react";
import { useToken } from "../../data/token";
import {
  bigToString,
  computeUsdBalance,
  fromBurrowBalance,
  fromTokenBalance,
} from "../../data/utils";
import { useRefFinance } from "../../data/refFinance";
import MutedDecimals from "../common/MutedDecimals";

export default function TokenBalance(props) {
  const [showUsd, setShowUsd] = useState(props.showUsd);
  const tokenAccountId = props.tokenAccountId;
  const balance = props.balance;
  const adjustForBurrow = props.adjustForBurrow || false;
  const token = useToken(tokenAccountId);
  const refFinance = useRefFinance();
  const adjustedBalance = adjustForBurrow
    ? fromBurrowBalance(token, balance)
    : balance;
  const usdBalance = computeUsdBalance(
    refFinance,
    tokenAccountId,
    adjustedBalance
  );

  const clickable = props.clickable && usdBalance;

  return (
    <span
      className={`font-monospace ${clickable ? "pointer" : ""} ${
        props.className || "fw-bold"
      }`}
      onClick={(e) => {
        if (clickable) {
          e.stopPropagation();
          setShowUsd(!showUsd);
        }
      }}
    >
      {showUsd && <span className="text-secondary">~$</span>}
      <MutedDecimals
        value={
          showUsd
            ? bigToString(usdBalance)
            : bigToString(fromTokenBalance(token, adjustedBalance))
        }
      />
    </span>
  );
}

'''
'''--- src/components/token/TokenSymbol.js ---
import { useToken } from "../../data/token";

export default function TokenSymbol(props) {
  const tokenAccountId = props.tokenAccountId;
  const token = useToken(tokenAccountId);
  return !tokenAccountId
    ? "???"
    : !token
    ? tokenAccountId
    : token.invalidAccount
    ? `Invalid account Id ${tokenAccountId}`
    : token.notFound
    ? `Token Id ${tokenAccountId} not found`
    : token.metadata.symbol;
}

'''
'''--- src/data/account.js ---
import { singletonHook } from "react-singleton-hook";
import { useEffect, useState } from "react";
import { useNearPromise } from "./near";

const defaultAccount = {
  loading: true,
  accountId: null,
  state: null,
  near: null,
};

const loadAccount = async (near, setAccount) => {
  const accountId = near.accountId;
  const account = {
    loading: false,
    accountId,
    state: null,
    near,
    refresh: async () => await loadAccount(near, setAccount),
  };
  if (accountId) {
    account.state = await near.account.state();
  }

  setAccount(account);
};

export const useAccount = singletonHook(defaultAccount, () => {
  const [account, setAccount] = useState(defaultAccount);
  const _near = useNearPromise();

  useEffect(() => {
    _near.then(async (near) => {
      try {
        await loadAccount(near, setAccount);
      } catch (e) {
        console.error(e);
      }
    });
  }, [_near]);

  return account;
});

'''
'''--- src/data/near.js ---
import * as nearAPI from "near-api-js";
import { singletonHook } from "react-singleton-hook";
import Big from "big.js";
import { useEffect, useState } from "react";

export const TGas = Big(10).pow(12);
export const StorageCostPerByte = Big(10).pow(19);
// const isLocalhost = window.location.hostname === "localhost";

export const IsMainnet = true;
export const MainNearConfig = {
  networkId: "mainnet",
  nodeUrl: "https://rpc.mainnet.near.org",
  archivalNodeUrl: "https://rpc.mainnet.internal.near.org",
  walletUrl: "https://wallet.near.org",
  storageCostPerByte: StorageCostPerByte,
  wrapNearAccountId: "wrap.near",
  refContractAccountId: "v2.ref-finance.near",
};

export const NearConfig = MainNearConfig;
export const LsKey = ":burrow-live-feed:";

async function _initNear() {
  const keyStore = new nearAPI.keyStores.BrowserLocalStorageKeyStore();
  keyStore.reKey = () => {};
  const nearConnection = await nearAPI.connect(
    Object.assign({ deps: { keyStore } }, NearConfig)
  );
  const _near = {};

  _near.nearArchivalConnection = nearAPI.Connection.fromConfig({
    networkId: NearConfig.networkId,
    provider: {
      type: "JsonRpcProvider",
      args: { url: NearConfig.archivalNodeUrl },
    },
    signer: { type: "InMemorySigner", keyStore },
  });

  _near.keyStore = keyStore;
  _near.nearConnection = nearConnection;

  _near.walletConnection = new nearAPI.WalletConnection(
    nearConnection,
    NearConfig.contractName
  );
  _near.accountId = _near.walletConnection.getAccountId();
  _near.account = _near.walletConnection.account();

  _near.contract = new nearAPI.Contract(
    _near.account,
    NearConfig.contractName,
    {
      viewMethods: [],
      changeMethods: [],
    }
  );

  _near.fetchBlockHash = async () => {
    const block = await nearConnection.connection.provider.block({
      finality: "final",
    });
    return nearAPI.utils.serialize.base_decode(block.header.hash);
  };

  _near.fetchBlockHeight = async () => {
    const block = await nearConnection.connection.provider.block({
      finality: "final",
    });
    return block.header.height;
  };

  _near.fetchNextNonce = async () => {
    const accessKeys = await _near.account.getAccessKeys();
    return accessKeys.reduce(
      (nonce, accessKey) => Math.max(nonce, accessKey.access_key.nonce + 1),
      1
    );
  };

  _near.archivalViewCall = async (blockId, contractId, methodName, args) => {
    args = args || {};
    const result = await _near.nearArchivalConnection.provider.query({
      request_type: "call_function",
      account_id: contractId,
      method_name: methodName,
      args_base64: Buffer.from(JSON.stringify(args)).toString("base64"),
      block_id: blockId,
    });

    return (
      result.result &&
      result.result.length > 0 &&
      JSON.parse(Buffer.from(result.result).toString())
    );
  };

  _near.viewCall = async (contractId, methodName, args) => {
    args = args || {};
    const result = await nearConnection.connection.provider.query({
      request_type: "call_function",
      account_id: contractId,
      method_name: methodName,
      args_base64: Buffer.from(JSON.stringify(args)).toString("base64"),
      finality: "optimistic",
    });

    return (
      result.result &&
      result.result.length > 0 &&
      JSON.parse(Buffer.from(result.result).toString())
    );
  };

  return _near;
}

const defaultNearPromise = Promise.resolve(_initNear());
export const useNearPromise = singletonHook(defaultNearPromise, () => {
  return defaultNearPromise;
});

const defaultNear = null;
export const useNear = singletonHook(defaultNear, () => {
  const [near, setNear] = useState(defaultNear);
  const _near = useNearPromise();

  useEffect(() => {
    _near.then(setNear);
  }, [_near]);

  return near;
});

'''
'''--- src/data/refFinance.js ---
import { singletonHook } from "react-singleton-hook";
import { useEffect, useState } from "react";
import { NearConfig, useNear } from "./near";
import Big from "big.js";
import { OneNear } from "./utils";

const SimplePool = "SIMPLE_POOL";

const defaultRefFinance = {
  loading: true,
  pools: {},
  poolsByToken: {},
  poolsByPair: {},
  prices: {},
  balances: {},
  nearPrice: Big(0),
};

const usdTokens = {
  "6b175474e89094c44da98b954eedeac495271d0f.factory.bridge.near":
    Big(10).pow(18),
  "a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48.factory.bridge.near":
    Big(10).pow(6),
  "dac17f958d2ee523a2206206994597c13d831ec7.factory.bridge.near":
    Big(10).pow(6),
};

export function getRefReturn(pool, tokenIn, amountIn) {
  if (!amountIn || amountIn.eq(0)) {
    return Big(0);
  }
  const tokenOut = pool.ot[tokenIn];
  if (!tokenOut) {
    return null;
  }
  const balanceIn = pool.tokens[tokenIn];
  const balanceOut = pool.tokens[tokenOut];
  let amountWithFee = Big(amountIn).mul(Big(10000 - pool.fee));
  return amountWithFee
    .mul(balanceOut)
    .div(Big(10000).mul(balanceIn).add(amountWithFee))
    .round(0, 0);
}

export function getRefInverseReturn(pool, tokenOut, amountOut) {
  if (!amountOut || amountOut.eq(0)) {
    return Big(0);
  }
  const tokenIn = pool.ot[tokenOut];
  if (!tokenIn) {
    return null;
  }
  const balanceIn = pool.tokens[tokenIn];
  const balanceOut = pool.tokens[tokenOut];
  if (amountOut.gte(balanceOut)) {
    return null;
  }
  return Big(10000)
    .mul(balanceIn)
    .mul(amountOut)
    .div(Big(10000 - pool.fee).mul(balanceOut.sub(amountOut)))
    .round(0, 3);
}

const fetchRefData = async (near) => {
  const balances = {};

  const limit = 250;
  // Limit pools for now until we need other prices.
  const numPools = Math.min(
    10000,
    await near.viewCall(
      NearConfig.refContractAccountId,
      "get_number_of_pools",
      {}
    )
  );
  const promises = [];
  for (let i = 0; i < numPools; i += limit) {
    promises.push(
      await near.viewCall(NearConfig.refContractAccountId, "get_pools", {
        from_index: i,
        limit,
      })
    );
  }
  const rawPools = (await Promise.all(promises)).flat();

  const poolsByToken = {};
  const poolsByPair = {};

  const addPools = (token, pool) => {
    let ps = poolsByToken[token] || [];
    ps.push(pool);
    poolsByToken[token] = ps;

    const pair = `${token}:${pool.ot[token]}`;
    ps = poolsByPair[pair] || [];
    ps.push(pool);
    poolsByPair[pair] = ps;
  };

  const pools = {};
  rawPools.forEach((pool, i) => {
    if (pool.pool_kind === SimplePool) {
      const tt = pool.token_account_ids;
      const p = {
        index: i,
        tt,
        tokens: tt.reduce((acc, token, tokenIndex) => {
          acc[token] = Big(pool.amounts[tokenIndex]);
          return acc;
        }, {}),
        ot: tt.reduce((acc, token, tokenIndex) => {
          acc[token] = tt[1 - tokenIndex];
          return acc;
        }, {}),
        fee: pool.total_fee,
        shares: Big(pool.shares_total_supply),
      };
      if (p.shares.gt(0)) {
        pools[p.index] = p;
        addPools(p.tt[0], p);
        addPools(p.tt[1], p);
      }
    }
  });

  const wNEAR = NearConfig.wrapNearAccountId;
  const prices = {};

  Object.values(pools).forEach((pool) => {
    if (wNEAR in pool.tokens) {
      pool.otherToken = pool.ot[wNEAR];
      const p = prices[pool.otherToken] || {
        totalNear: Big(0),
        totalOther: Big(0),
      };
      p.totalNear = p.totalNear.add(pool.tokens[wNEAR]);
      p.totalOther = p.totalOther.add(pool.tokens[pool.otherToken]);
      if (p.totalNear.gt(0)) {
        prices[pool.otherToken] = p;
      }
    }
  });

  let totalNearInUsdPools = Big(0);
  let totalUsdInUsdPools = Big(0);

  Object.entries(usdTokens).forEach(([tokenId, one]) => {
    if (tokenId in prices) {
      const p = prices[tokenId];
      totalNearInUsdPools = totalNearInUsdPools.add(p.totalNear);
      totalUsdInUsdPools = totalUsdInUsdPools.add(
        p.totalOther.mul(OneNear).div(one)
      );
    }
  });

  const nearPrice = totalNearInUsdPools.gt(0)
    ? totalUsdInUsdPools.div(totalNearInUsdPools)
    : Big(0);

  return {
    loading: false,
    pools,
    poolsByToken,
    poolsByPair,
    nearPrice,
    prices,
    balances,
  };
};

let refRefreshTimer = null;

export const useRefFinance = singletonHook(defaultRefFinance, () => {
  const [refFinance, setRefFinance] = useState(defaultRefFinance);
  const near = useNear();

  useEffect(() => {
    if (near) {
      let scheduleRefresh;
      let refresh;

      const localMapRef = (ref) => {
        ref.scheduleRefresh = scheduleRefresh;
        ref.refresh = refresh;
        return ref;
      };

      refresh = async () => {
        const ref = await fetchRefData(near);
        setRefFinance(localMapRef(ref));
      };

      scheduleRefresh = (fast) => {
        clearTimeout(refRefreshTimer);
        refRefreshTimer = setTimeout(
          async () => {
            if (!document.hidden) {
              await refresh();
            } else {
              scheduleRefresh(fast);
            }
          },
          fast ? 5000 : 30000
        );
      };

      refresh().catch(console.error);
    }
  }, [near]);

  return refFinance;
});

'''
'''--- src/data/socialAccount.js ---
import useSWR from "swr";
import { keysToCamel } from "./utils";

const socialAccounts = {};

export const socialAccountFetcher = async (_key, accountId) => {
  if (accountId in socialAccounts) {
    return socialAccounts[accountId];
  }
  try {
    const res = await fetch(`https://api.near.social/account/${accountId}`);
    if (res.status === 404) {
      return (socialAccounts[accountId] = false);
    } else {
      return (socialAccounts[accountId] = keysToCamel(await res.json()));
    }
  } catch (e) {
    return (socialAccounts[accountId] = false);
  }
};

export const useSocialAccount = (accountId) => {
  const { data: socialAccount } = useSWR(
    ["social_account_id", accountId],
    socialAccountFetcher
  );
  return socialAccount;
};

'''
'''--- src/data/token.js ---
import Big from "big.js";
import ls from "local-storage";
import { isValidAccountId, keysToCamel } from "./utils";
import useSWR from "swr";
import { LsKey, NearConfig, useNear } from "./near";

const TokenExpirationDuration = 30 * 60 * 1000;

const tokens = {};

export const tokenMatches = (tokenAccountId, label) => {
  const token = tokens[tokenAccountId];
  if (!token || !label) {
    return false;
  }
  label = label.toLowerCase();
  if (token.metadata.symbol.toLowerCase().indexOf(label) >= 0) {
    return true;
  }
  return token.metadata.name.toLowerCase().indexOf(label) >= 0;
};

const hardcodedMetadata = (token, tokenAccountId) => {
  if (!token) {
    return token;
  }
  if (tokenAccountId === NearConfig.wrapNearAccountId) {
    token.metadata.symbol = "NEAR";
    token.metadata.icon =
      "data:image/svg+xml,%3Csvg width='32' height='32' viewBox='0 0 32 32' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Ccircle cx='16' cy='16' r='16' fill='%23111618'%3E%3C/circle%3E%3Cg clip-path='url(%23clip0000000003)'%3E%3Cpath d='M20.8422 8.84471L17.4978 13.776C17.4501 13.847 17.43 13.9328 17.4411 14.0174C17.4522 14.102 17.4938 14.1798 17.5582 14.2363C17.6225 14.2928 17.7053 14.3243 17.7913 14.3249C17.8772 14.3254 17.9604 14.2951 18.0256 14.2395L21.3178 11.4036C21.3371 11.3865 21.361 11.3753 21.3866 11.3714C21.4122 11.3675 21.4383 11.3711 21.4619 11.3818C21.4855 11.3924 21.5054 11.4096 21.5193 11.4314C21.5331 11.4531 21.5403 11.4783 21.54 11.504V20.3824C21.54 20.4095 21.5316 20.4361 21.5158 20.4583C21.5001 20.4806 21.4779 20.4975 21.4522 20.5068C21.4265 20.516 21.3985 20.5172 21.3721 20.5102C21.3456 20.5031 21.322 20.4882 21.3044 20.4673L11.3533 8.63726C11.1933 8.44956 10.994 8.29873 10.7693 8.19525C10.5446 8.09178 10.2999 8.03815 10.0522 8.03809H9.70444C9.2524 8.03809 8.81887 8.21642 8.49922 8.53386C8.17957 8.8513 8 9.28185 8 9.73078V22.2351C8 22.684 8.17957 23.1145 8.49922 23.432C8.81887 23.7494 9.2524 23.9277 9.70444 23.9277V23.9277C9.99591 23.9278 10.2825 23.8537 10.537 23.7125C10.7914 23.5713 11.0051 23.3677 11.1578 23.1211L14.5022 18.1898C14.5499 18.1188 14.57 18.033 14.5589 17.9484C14.5478 17.8638 14.5062 17.7861 14.4418 17.7295C14.3775 17.673 14.2947 17.6415 14.2087 17.641C14.1228 17.6404 14.0396 17.6707 13.9744 17.7264L10.6822 20.5622C10.6629 20.5794 10.639 20.5906 10.6134 20.5944C10.5878 20.5983 10.5617 20.5947 10.5381 20.5841C10.5145 20.5734 10.4946 20.5562 10.4807 20.5345C10.4669 20.5128 10.4597 20.4875 10.46 20.4618V11.5813C10.46 11.5541 10.4684 11.5276 10.4842 11.5053C10.4999 11.483 10.5221 11.4661 10.5478 11.4568C10.5735 11.4476 10.6015 11.4464 10.6279 11.4534C10.6544 11.4605 10.678 11.4755 10.6956 11.4963L20.6456 23.3286C20.8056 23.5163 21.0049 23.6671 21.2296 23.7706C21.4543 23.874 21.699 23.9277 21.9467 23.9277H22.2944C22.5184 23.9279 22.7401 23.8842 22.947 23.7992C23.154 23.7142 23.342 23.5895 23.5004 23.4324C23.6588 23.2752 23.7844 23.0885 23.8702 22.8831C23.9559 22.6776 24 22.4574 24 22.2351V9.73078C24 9.28185 23.8204 8.8513 23.5008 8.53386C23.1811 8.21642 22.7476 8.03809 22.2956 8.03809C22.0041 8.03801 21.7175 8.11211 21.4631 8.25332C21.2086 8.39453 20.9949 8.59814 20.8422 8.84471V8.84471Z' fill='white'%3E%3C/path%3E%3C/g%3E%3Cdefs%3E%3CclipPath id='clip00033'%3E%3Crect width='16' height='16' fill='white' transform='translate(8 7.9834)'%3E%3C/rect%3E%3C/clipPath%3E%3C/defs%3E%3C/svg%3E";
  }
  return token;
};

export const getTokenFetcher = async (_key, tokenAccountId, near) => {
  if (!isValidAccountId(tokenAccountId)) {
    return {
      invalidAccount: true,
    };
  }
  if (tokenAccountId in tokens) {
    return tokens[tokenAccountId];
  }
  const lsKey = LsKey + "tokens:" + tokenAccountId;
  const localToken = ls.get(lsKey);
  const time = new Date().getTime();

  const contract = {};

  if (localToken && localToken.expires > time) {
    const token = Object.assign({}, localToken.data, { contract });
    token.totalSupply = Big(token.totalSupply);

    return (tokens[tokenAccountId] = hardcodedMetadata(token, tokenAccountId));
  }

  if (!near) {
    return null;
  }

  let token = false;
  try {
    let [metadata, totalSupply] = await Promise.all([
      near.viewCall(tokenAccountId, "ft_metadata", {}),
      near.viewCall(tokenAccountId, "ft_total_supply", {}),
    ]);
    token = hardcodedMetadata(
      {
        contract,
        metadata: keysToCamel(metadata),
        totalSupply: Big(totalSupply),
      },
      tokenAccountId
    );
  } catch (e) {
    const errString = e.message.toString();
    if (errString.indexOf("does not exist while viewing") < 0) {
      console.error(e);
      return false;
    }
    token = {
      notFound: true,
    };
    return (tokens[tokenAccountId] = token);
  }
  ls.set(lsKey, {
    expires: time + TokenExpirationDuration,
    data: Object.assign({}, token, {
      totalSupply: token.totalSupply.toFixed(0),
    }),
  });
  return (tokens[tokenAccountId] = token);
};

export const useToken = (tokenAccountId) => {
  const { data: token } = useSWR(
    ["token_account_id", tokenAccountId, useNear()],
    getTokenFetcher
  );
  return token;
};

'''
'''--- src/data/utils.js ---
import Big from "big.js";
import { NearConfig } from "./near";
import React from "react";

const MinAccountIdLen = 2;
const MaxAccountIdLen = 64;
const ValidAccountRe = /^(([a-z\d]+[-_])*[a-z\d]+\.)*([a-z\d]+[-_])*[a-z\d]+$/;
export const OneNear = Big(10).pow(24);
export const OneEth = Big(10).pow(18);
const AccountSafetyMargin = OneNear.div(2);

export const Loading = (
  <span
    className="spinner-grow spinner-grow-sm me-1"
    role="status"
    aria-hidden="true"
  />
);

export function isValidAccountId(accountId) {
  return (
    accountId &&
    accountId.length >= MinAccountIdLen &&
    accountId.length <= MaxAccountIdLen &&
    accountId.match(ValidAccountRe)
  );
}

const toCamel = (s) => {
  return s.replace(/([-_][a-z])/gi, ($1) => {
    return $1.toUpperCase().replace("-", "").replace("_", "");
  });
};

const isArray = function (a) {
  return Array.isArray(a);
};

export const isObject = function (o) {
  return o === Object(o) && !isArray(o) && typeof o !== "function";
};

export const keysToCamel = function (o) {
  if (isObject(o)) {
    const n = {};

    Object.keys(o).forEach((k) => {
      n[toCamel(k)] = keysToCamel(o[k]);
    });

    return n;
  } else if (isArray(o)) {
    return o.map((i) => {
      return keysToCamel(i);
    });
  }

  return o;
};

export const bigMin = (a, b) => {
  if (a && b) {
    return a.lt(b) ? a : b;
  }
  return a || b;
};

export const bigToString = (b, p, len) => {
  if (b === null) {
    return "???";
  }
  let s = b.toFixed();
  let pos = s.indexOf(".");
  p = p || 6;
  len = len || 7;
  if (pos > 0) {
    let ap = Math.min(p, Math.max(len - pos, 0));
    if (ap > 0) {
      ap += 1;
    }
    if (pos + ap < s.length) {
      s = s.substring(0, pos + ap);
    }
  } else {
    pos = s.length;
  }
  for (let i = pos - 4; i >= 0; i -= 3) {
    s = s.slice(0, i + 1) + "," + s.slice(i + 1);
  }

  if (s === "0.000000" && p === 6 && len === 7) {
    return "<0.000001";
  }

  return s;
};

export const displayNear = (balance) =>
  balance ? (
    <>
      {bigToString(balance.div(OneNear))}{" "}
      <span className="text-secondary">NEAR</span>
    </>
  ) : (
    "???"
  );

export const dateToString = (d) => {
  return d.toLocaleString("en-us", {
    day: "numeric",
    month: "short",
    year: "numeric",
  });
};

export const displayTime = (d) => {
  return d.toLocaleString();
};

export const availableNearBalance = (account) => {
  if (account && !account.loading && account.state) {
    let balance = Big(account.state.amount).sub(
      Big(account.state.storage_usage).mul(Big(NearConfig.storageCostPerByte))
    );
    if (balance.gt(AccountSafetyMargin)) {
      return balance.sub(AccountSafetyMargin);
    }
  }
  return Big(0);
};

export const isoDate = (d) =>
  d ? new Date(d).toISOString().substring(0, 10) : "";

export function accountTrim(accountId) {
  return accountId && accountId.length > 14 + 14 + 1
    ? accountId.slice(0, 14) + "…" + accountId.slice(-14)
    : accountId;
}

export const computeUsdBalance = (refFinance, tokenAccountId, balance) => {
  if (refFinance && !refFinance.loading && balance) {
    if (tokenAccountId === NearConfig.wrapNearAccountId) {
      return balance.div(OneNear).mul(refFinance.nearPrice);
    } else if (
      tokenAccountId in refFinance.prices &&
      refFinance.nearPrice.gt(0)
    ) {
      const p = refFinance.prices[tokenAccountId];
      const balanceIn = p.totalOther;
      const balanceOut = p.totalNear;
      let amountWithFee = Big(balance.div(1000));
      const amountOut = amountWithFee
        .mul(balanceOut)
        .div(balanceIn.add(amountWithFee))
        .round(0, 0);

      return amountOut.mul(1000).div(OneNear).mul(refFinance.nearPrice);
    }
  }
  return null;
};

export const fromTokenBalance = (token, balance, adjustForBurrow) => {
  return !token || token.invalidAccount || token.notFound || !balance
    ? balance
    : balance.div(Big(10).pow(token.metadata.decimals));
};

export const toTokenBalance = (token, balance) => {
  return !token || token.invalidAccount || token.notFound || !balance
    ? balance
    : balance.mul(Big(10).pow(token.metadata.decimals));
};

export const fromBurrowBalance = (token, balance) => {
  return !token || token.invalidAccount || token.notFound || !balance
    ? balance
    : balance.div(Big(10).pow(Math.max(0, 18 - token.metadata.decimals)));
};

'''
'''--- src/index.css ---
body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}

'''
'''--- src/index.js ---
import React from "react";
import ReactDOM from "react-dom";
import "./index.css";
import App from "./App";

ReactDOM.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
  document.getElementById("root")
);

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
// reportWebVitals();

'''
'''--- src/setupTests.js ---
// jest-dom adds custom jest matchers for asserting on DOM nodes.
// allows you to do things like:
// expect(element).toHaveTextContent(/react/i)
// learn more: https://github.com/testing-library/jest-dom
import '@testing-library/jest-dom';

'''