*GitHub Repository "klimoza/lab2-klimoza-factory"*

'''--- Cargo.toml ---
[package]
name = "non-fungible-token-factory"
version = "1.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0"
near-contract-standards = "4.0.0"
chrono = "0.4"
'''
'''--- README.md ---
Factory NFT Collection
===================

This repository contains contract for NFT collection, allowing you to set the lifetime of each token using `expiration_period` field in `nft_mint` function. Also, metadata of each token can only be read by the owner of that token (as well as the owner of the contract). Besides that, the interface of the entire collection compiles with the [NEAR NFT standards](https://nomicon.io/Standards/Tokens/NonFungibleToken/).

Building this contract
======================
Run the following, and we'll build our rust project up via cargo. This will generate our WASM binaries into our `res/` directory. This is the smart contract we'll be deploying onto the NEAR blockchain later.
```bash
./scripts/build.sh
```

Testing this contract
=====================
We have some tests that you can run. For example, the following will run our simple tests to verify that our contract code is working.

*Unit Tests*
```bash
cargo test -- --nocapture
```

Using this contract
===================

### Working with new features
To set the lifetime of the token, you should pass an argument to the `expiration_period` during `nft_mint` function call in the following format:
```
expiration_period := <number><unit>
  where unit = s | m | h | d
```
For example:
```bash
near call factory.testnet nft_mint '{"token_id": "test_id", "receiver_id": "klimoza.testnet", "token_metadata": {"title": "TWITCH PRIME"}, "expiration_period": "12h"}' --accountId factory.testnet --amount 2
```

### Quickest deploy

You can build and deploy this smart contract to a development account. [Dev Accounts](https://docs.near.org/concepts/basics/account#dev-accounts) are auto-generated accounts to assist in developing and testing smart contracts. Please see the [Standard deploy](#standard-deploy) section for creating a more personalized account to deploy to.

```bash
near dev-deploy --wasmFile res/non_fungible_token_factory.wasm
```

Behind the scenes, this is creating an account and deploying a contract to it. On the console, notice a message like:

>Done deploying to dev-1234567890123

In this instance, the account is `dev-1234567890123`. A file has been created containing a key pair to
the account, located at `neardev/dev-account`. To make the next few steps easier, we're going to set an
environment variable containing this development account id and use that when copy/pasting commands.
Run this command to set the environment variable:

```bash
source neardev/dev-account.env
```

You can tell if the environment variable is set correctly if your command line prints the account name after this command:
```bash
echo $CONTRACT_NAME
```

The next command will initialize the contract using the `new` method:

```bash
near call $CONTRACT_NAME new_default_meta '{"owner_id": "'$CONTRACT_NAME'"}' --accountId $CONTRACT_NAME
```

To view the NFT metadata:

```bash
near view $CONTRACT_NAME nft_metadata
```

### Standard deploy

This smart contract will get deployed to your NEAR account. For this example, please create a new NEAR account. Because NEAR allows the ability to upgrade contracts on the same account, initialization functions must be cleared. If you'd like to run this example on a NEAR account that has had prior contracts deployed, please use the `near-cli` command `near delete`, and then recreate it in Wallet. To create (or recreate) an account, please follow the directions in [Test Wallet](https://wallet.testnet.near.org) or ([NEAR Wallet](https://wallet.near.org/) if we're using `mainnet`).

In the project root, log in to your newly created account with `near-cli` by following the instructions after this command.

    near login

To make this tutorial easier to copy/paste, we're going to set an environment variable for our account id. In the below command, replace `MY_ACCOUNT_NAME` with the account name we just logged in with, including the `.testnet` (or `.near` for `mainnet`):

    ID=MY_ACCOUNT_NAME

We can tell if the environment variable is set correctly if our command line prints the account name after this command:

    echo $ID

Now we can deploy the compiled contract in this example to your account:

    near deploy --wasmFile res/non_fungible_token_factory.wasm --accountId $ID

NFT contract should be initialized before usage. More info about the metadata at [nomicon.io](https://nomicon.io/Standards/NonFungibleToken/Metadata.html). But for now, we'll initialize with the default metadata.

    near call $ID new_default_meta '{"owner_id": "'$ID'"}' --accountId $ID

We'll be able to view our metadata right after:

    near view $ID nft_metadata

Then, let's mint our first token. This will create a NFT based on Olympus Mons where only one copy exists:

    near call $ID nft_mint '{"token_id": "0", "receiver_id": "'$ID'", "token_metadata": { "title": "Olympus Mons", "description": "Tallest mountain in charted solar system", "media": "https://upload.wikimedia.org/wikipedia/commons/thumb/0/00/Olympus_Mons_alt.jpg/1024px-Olympus_Mons_alt.jpg", "copies": 1}, "expiration_period": "5m"}' --accountId $ID --deposit 0.1

Transferring our NFT
====================

Let's set up an account to transfer our freshly minted token to. This account will be a sub-account of the NEAR account we logged in with originally via `near login`.

    near create-account alice.$ID --masterAccount $ID --initialBalance 10

Checking Alice's account for tokens:

    near view $ID nft_tokens_for_owner '{"account_id": "'alice.$ID'"}'

Then we'll transfer over the NFT into Alice's account. Exactly 1 yoctoNEAR of deposit should be attached:

    near call $ID nft_transfer '{"token_id": "0", "receiver_id": "alice.'$ID'", "memo": "transfer ownership"}' --accountId $ID --depositYocto 1

Checking Alice's account again shows us that she has the Olympus Mons token.

Notes
=====

* The maximum balance value is limited by U128 (2**128 - 1).
* JSON calls should pass U128 as a base-10 string. E.g. "100".
* This does not include escrow functionality, as ft_transfer_call provides a superior approach. An escrow system can, of course, be added as a separate contract or additional functionality within this contract.
'''
'''--- res/README.md ---
# Folder that contains wasm files
'''
'''--- scripts/build.sh ---
#!/bin/bash
set -e
cd "`dirname $0`"/..
source scripts/flags.sh
cargo build --all --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/*.wasm ./res/
'''
'''--- scripts/flags.sh ---
#!/bin/bash

if [ -z "$KEEP_NAMES" ]; then
  export RUSTFLAGS='-C link-arg=-s'
else
  export RUSTFLAGS=''
fi
'''
'''--- src/lib.rs ---
use near_contract_standards::non_fungible_token::metadata::{
    NFTContractMetadata, TokenMetadata, NFT_METADATA_SPEC,
};
use near_contract_standards::non_fungible_token::NonFungibleToken;
use near_contract_standards::non_fungible_token::TokenId;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LazyOption, LookupMap};
use near_sdk::serde::Serialize;
use near_sdk::{env, near_bindgen, AccountId, BorshStorageKey, PanicOnDefault, Promise};
use std::collections::HashMap;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    tokens: NonFungibleToken,
    metadata: LazyOption<NFTContractMetadata>,
    expiration_timestamp: LookupMap<TokenId, u64>,
    royalty: LookupMap<TokenId, HashMap<AccountId, u32>>,
}

const DATA_IMAGE_SVG_NEAR_ICON: &str = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 288 288'%3E%3Cg id='l' data-name='l'%3E%3Cpath d='M187.58,79.81l-30.1,44.69a3.2,3.2,0,0,0,4.75,4.2L191.86,103a1.2,1.2,0,0,1,2,.91v80.46a1.2,1.2,0,0,1-2.12.77L102.18,77.93A15.35,15.35,0,0,0,90.47,72.5H87.34A15.34,15.34,0,0,0,72,87.84V201.16A15.34,15.34,0,0,0,87.34,216.5h0a15.35,15.35,0,0,0,13.08-7.31l30.1-44.69a3.2,3.2,0,0,0-4.75-4.2L96.14,186a1.2,1.2,0,0,1-2-.91V104.61a1.2,1.2,0,0,1,2.12-.77l89.55,107.23a15.35,15.35,0,0,0,11.71,5.43h3.13A15.34,15.34,0,0,0,216,201.16V87.84A15.34,15.34,0,0,0,200.66,72.5h0A15.35,15.35,0,0,0,187.58,79.81Z'/%3E%3C/g%3E%3C/svg%3E";

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
    NonFungibleToken,
    Metadata,
    TokenMetadata,
    Enumeration,
    Approval,
    Timestamp,
    Royalty,
    TokensPerOwner { account_hash: Vec<u8> },
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new_default_meta(owner_id: AccountId) -> Self {
        Self::new(
            owner_id,
            NFTContractMetadata {
                spec: NFT_METADATA_SPEC.to_string(),
                name: "Example NEAR non-fungible token factory".to_string(),
                symbol: "EXAMPLE".to_string(),
                icon: Some(DATA_IMAGE_SVG_NEAR_ICON.to_string()),
                base_uri: None,
                reference: None,
                reference_hash: None,
            },
        )
    }

    #[init]
    pub fn new(owner_id: AccountId, metadata: NFTContractMetadata) -> Self {
        assert!(!env::state_exists(), "Already initialized");
        metadata.assert_valid();
        Self {
            tokens: NonFungibleToken::new(
                StorageKey::NonFungibleToken,
                owner_id,
                Some(StorageKey::TokenMetadata),
                Some(StorageKey::Enumeration),
                Some(StorageKey::Approval),
            ),
            metadata: LazyOption::new(StorageKey::Metadata, Some(&metadata)),
            expiration_timestamp: LookupMap::new(StorageKey::Timestamp),
            royalty: LookupMap::new(StorageKey::Royalty),
        }
    }
}

#[derive(Debug, Clone, Serialize, PartialEq)]
#[serde(crate = "near_sdk::serde")]
pub struct JsonToken {
    pub token_id: TokenId,
    pub owner_id: AccountId,
    pub metadata: Option<TokenMetadata>,
    pub approved_account_ids: Option<HashMap<AccountId, u64>>,
    pub expiration_date: Option<u64>,
    pub royalty: HashMap<AccountId, u32>,
}

near_contract_standards::impl_non_fungible_token_approval!(Contract, tokens);

pub mod my_core;
pub mod my_enumeration;
pub mod my_extra;
mod my_internal;
pub mod my_mint;
pub mod my_royalty;

#[cfg(all(test, not(target_arch = "wasm32")))]
mod tests {
    use near_sdk::json_types::U128;
    use near_sdk::test_utils::{accounts, VMContextBuilder};
    use near_sdk::testing_env;
    use std::collections::HashMap;

    use super::*;

    const MIN_REQUIRED_APPROVAL_YOCTO: u128 = 150000000000000000000;
    const MINT_STORAGE_COST: u128 = 6370000000000000000000;
    const MINT_WITH_DATE_STORAGE_COST: u128 = 6910000000000000000000;

    fn get_context(predecessor_account_id: AccountId) -> VMContextBuilder {
        let mut builder = VMContextBuilder::new();
        builder
            .current_account_id(accounts(0))
            .signer_account_id(predecessor_account_id.clone())
            .predecessor_account_id(predecessor_account_id);
        builder
    }

    fn sample_token_metadata() -> TokenMetadata {
        TokenMetadata {
            title: Some("Olympus Mons".into()),
            description: Some("The tallest mountain in the charted solar system".into()),
            media: None,
            media_hash: None,
            copies: Some(1u64),
            issued_at: None,
            expires_at: None,
            starts_at: None,
            updated_at: None,
            extra: None,
            reference: None,
            reference_hash: None,
        }
    }

    #[test]
    fn test_new() {
        let mut context = get_context(accounts(1));
        testing_env!(context.build());
        let contract = Contract::new_default_meta(accounts(1).into());
        testing_env!(context.is_view(true).build());
        assert_eq!(contract.nft_token("1".to_string()), None);
    }

    #[test]
    #[should_panic(expected = "The contract is not initialized")]
    fn test_default() {
        let context = get_context(accounts(1));
        testing_env!(context.build());
        let _contract = Contract::default();
    }

    #[test]
    fn test_mint_with_expiration_date() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(0).into());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_WITH_DATE_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .block_timestamp(0)
            .build());

        let token_id = "0".to_string();
        let expiration_time = 2;
        let token = contract.nft_mint(
            token_id.clone(),
            accounts(0),
            sample_token_metadata(),
            Some(String::from("2s")),
            None,
        );
        assert!(
            token.expiration_date.is_some(),
            "Expiration date shouldn't be None!"
        );
        assert_eq!(
            expiration_time as i64,
            token.expiration_date.unwrap() as i64 / 1_000_000_000
        );
        assert_eq!(token.token_id, token_id);
        assert_eq!(token.owner_id.to_string(), accounts(0).to_string());
        assert_eq!(token.metadata.unwrap(), sample_token_metadata());
        assert_eq!(token.approved_account_ids.unwrap(), HashMap::new());
    }

    #[test]
    fn test_mint_without_date() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(0).into());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build());

        let token_id = "0".to_string();
        let token = contract.nft_mint(
            token_id.clone(),
            accounts(0),
            sample_token_metadata(),
            None,
            None,
        );
        assert_eq!(token.token_id, token_id);
        assert_eq!(token.owner_id.to_string(), accounts(0).to_string());
        assert_eq!(token.metadata.unwrap(), sample_token_metadata());
        assert_eq!(token.approved_account_ids.unwrap(), HashMap::new());
    }

    #[test]
    fn test_get_token_by_owner() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(0).into());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_WITH_DATE_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .block_timestamp(0)
            .build());
        let token_id = "0".to_string();
        let token = contract.nft_mint(
            token_id.clone(),
            accounts(0),
            sample_token_metadata(),
            Some(String::from("5m")),
            None,
        );
        assert_eq!(Some(token), contract.nft_token(token_id.clone()));
    }

    #[test]
    fn test_get_token_not_by_owner() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(0).into());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_WITH_DATE_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .block_timestamp(0)
            .build());
        let token_id = "0".to_string();
        let token = contract.nft_mint(
            token_id.clone(),
            accounts(0),
            sample_token_metadata(),
            Some(String::from("5m")),
            None,
        );
        let new_token = JsonToken {
            metadata: None,
            ..token
        };
        testing_env!(context
            .storage_usage(env::storage_usage())
            .predecessor_account_id(accounts(1))
            .block_timestamp(0)
            .build());
        assert_eq!(Some(new_token), contract.nft_token(token_id.clone()));
    }

    #[test]
    fn test_get_expired_token() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(0).into());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_WITH_DATE_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .block_timestamp(0)
            .build());
        let token_id = "0".to_string();
        contract.nft_mint(
            token_id.clone(),
            accounts(0),
            sample_token_metadata(),
            Some(String::from("5m")),
            None,
        );

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_WITH_DATE_STORAGE_COST)
            .predecessor_account_id(accounts(1))
            .block_timestamp(6 * 60 * 1_000_000_000)
            .build());
        assert_eq!(None, contract.nft_token(token_id.clone()));
    }

    #[test]
    fn test_transfer() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(0).into());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_WITH_DATE_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .block_timestamp(0)
            .build());
        let token_id = "0".to_string();
        contract.nft_mint(
            token_id.clone(),
            accounts(0),
            sample_token_metadata(),
            Some(String::from("5m")),
            None,
        );

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(1)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_transfer(accounts(1), token_id.clone(), None, None);

        testing_env!(context
            .storage_usage(env::storage_usage())
            .account_balance(env::account_balance())
            .block_timestamp(0)
            .attached_deposit(0)
            .build());

        if let Some(token) = contract.nft_token(token_id.clone()) {
            assert!(token.expiration_date.is_some());
            assert_eq!(token.expiration_date.unwrap() / 1_000_000_000, 300);
            assert_eq!(token.token_id, token_id);
            assert_eq!(token.owner_id.to_string(), accounts(1).to_string());
            assert_eq!(token.metadata.unwrap(), sample_token_metadata());
            assert_eq!(token.approved_account_ids.unwrap(), HashMap::new());
        } else {
            panic!("token not correctly created, or not found by nft_token");
        }
    }

    #[test]
    fn test_nft_payout() {
        use crate::my_royalty::Payouts;
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(0).into());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build());
        let token_id = "0".to_string();
        contract.nft_mint(
            token_id.clone(),
            accounts(0),
            sample_token_metadata(),
            None,
            None,
        );

        // alice approves bob
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(150000000000000000000)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_approve(token_id.clone(), accounts(1), None);

        let payout = contract.nft_payout(token_id.clone(), U128(10), 1);
        let expected = HashMap::from([(accounts(0), U128(10))]);
        assert_eq!(payout.payout, expected);
    }

    #[test]
    fn test_nft_approve() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(0).into());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build());
        let token_id = "0".to_string();
        contract.nft_mint(
            token_id.clone(),
            accounts(0),
            sample_token_metadata(),
            None,
            None,
        );

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MIN_REQUIRED_APPROVAL_YOCTO)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_approve(token_id.clone(), accounts(1), None);

        testing_env!(context
            .storage_usage(env::storage_usage())
            .account_balance(env::account_balance())
            .is_view(true)
            .attached_deposit(0)
            .build());
        assert!(contract.nft_is_approved(token_id.clone(), accounts(1), None));
    }

    #[test]
    fn test_nft_revoke() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(0).into());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build());
        let token_id = "0".to_string();
        contract.nft_mint(
            token_id.clone(),
            accounts(0),
            sample_token_metadata(),
            None,
            None,
        );

        // alice approves bob
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MIN_REQUIRED_APPROVAL_YOCTO)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_approve(token_id.clone(), accounts(1), None);

        // alice revokes bob
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(1)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_revoke(token_id.clone(), accounts(1));
        testing_env!(context
            .storage_usage(env::storage_usage())
            .account_balance(env::account_balance())
            .is_view(true)
            .attached_deposit(0)
            .build());
        assert!(!contract.nft_is_approved(token_id.clone(), accounts(1), None));
    }

    #[test]
    fn test_revoke_all() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(0).into());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build());
        let token_id = "0".to_string();
        contract.nft_mint(
            token_id.clone(),
            accounts(0),
            sample_token_metadata(),
            None,
            None,
        );

        // alice approves bob
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MIN_REQUIRED_APPROVAL_YOCTO)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_approve(token_id.clone(), accounts(1), None);

        // alice revokes bob
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(1)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_revoke_all(token_id.clone());
        testing_env!(context
            .storage_usage(env::storage_usage())
            .account_balance(env::account_balance())
            .is_view(true)
            .attached_deposit(0)
            .build());
        assert!(!contract.nft_is_approved(token_id.clone(), accounts(1), Some(1)));
    }
}

'''
'''--- src/my_core.rs ---
use near_contract_standards::non_fungible_token::core::NonFungibleTokenCore;
use near_sdk::{env::log_str, require, PromiseOrValue};

use crate::*;

// impl NonFungibleTokenCore for Contract {
#[near_bindgen]
impl Contract {
    #[payable]
    pub fn nft_transfer(
        &mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        approval_id: Option<u64>,
        memo: Option<String>,
    ) {
        self.tokens
            .nft_transfer(receiver_id, token_id, approval_id, memo)
    }

    #[payable]
    pub fn nft_transfer_call(
        &mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        approval_id: Option<u64>,
        memo: Option<String>,
        msg: String,
    ) -> PromiseOrValue<bool> {
        self.tokens
            .nft_transfer_call(receiver_id, token_id, approval_id, memo, msg)
    }

    pub fn nft_token(&self, token_id: TokenId) -> Option<JsonToken> {
        if !self.tokens.owner_by_id.contains_key(&token_id) {
            return None;
        }
        if env::predecessor_account_id() != env::current_account_id()
            && !self.token_is_not_expired(&token_id)
        {
            log_str(&format!("Token is expired."));
            return None;
        }
        if self.tokens.owner_by_id.get(&token_id).unwrap() == env::predecessor_account_id()
            || env::predecessor_account_id() == env::current_account_id()
        {
            self.tokens.nft_token(token_id).map(|token| JsonToken {
                expiration_date: self.expiration_timestamp.get(&token.token_id),
                royalty: self.royalty.get(&token.token_id).unwrap(),
                token_id: token.token_id,
                owner_id: token.owner_id,
                metadata: token.metadata,
                approved_account_ids: token.approved_account_ids,
            })
        } else {
            self.tokens.nft_token(token_id).map(|token| JsonToken {
                expiration_date: self.expiration_timestamp.get(&token.token_id),
                royalty: self.royalty.get(&token.token_id).unwrap(),
                token_id: token.token_id,
                owner_id: token.owner_id,
                metadata: None,
                approved_account_ids: token.approved_account_ids,
            })
        }
    }
}

'''
'''--- src/my_enumeration.rs ---
use near_sdk::{json_types::U128, near_bindgen, require};

use crate::*;

// impl NonFungibleTokenEnumeration for Contract {
#[near_bindgen]
impl Contract {
    pub fn nft_tokens(&self, from_index: Option<U128>, limit: Option<u64>) -> Vec<JsonToken> {
        let start_index: u128 = from_index.map(From::from).unwrap_or_default();
        require!(
            (self.tokens.owner_by_id.len() as u128) >= start_index,
            "Out of bounds, please use a smaller from_index."
        );
        let limit = limit.map(|v| v as usize).unwrap_or(usize::MAX);
        require!(limit != 0, "Cannot provide limit of 0.");
        self.tokens
            .owner_by_id
            .iter()
            .filter(|(token_id, _)| self.token_is_not_expired(token_id))
            .skip(start_index as usize)
            .take(limit)
            .map(|(token_id, owner_id)| self.enum_get_token(owner_id, token_id))
            .collect()
    }

    pub fn nft_tokens_for_owner(
        &self,
        account_id: AccountId,
        from_index: Option<U128>,
        limit: Option<u64>,
    ) -> Vec<JsonToken> {
        let tokens_per_owner = self.tokens.tokens_per_owner.as_ref().unwrap_or_else(|| {
            env::panic_str(
                "Could not find tokens_per_owner when calling a method on the \
                enumeration standard.",
            )
        });
        let token_set = if let Some(token_set) = tokens_per_owner.get(&account_id) {
            token_set
        } else {
            return vec![];
        };
        let limit = limit.map(|v| v as usize).unwrap_or(usize::MAX);
        require!(limit != 0, "Cannot provide limit of 0.");
        let start_index: u128 = from_index.map(From::from).unwrap_or_default();
        require!(
            token_set.len() as u128 > start_index,
            "Out of bounds, please use a smaller from_index."
        );
        token_set
            .iter()
            .filter(|token_id| self.token_is_not_expired(token_id))
            .skip(start_index as usize)
            .take(limit)
            .map(|token_id| self.enum_get_token(account_id.clone(), token_id))
            .collect()
    }
}

'''
'''--- src/my_extra.rs ---
use near_contract_standards::non_fungible_token::{
    core::NonFungibleTokenResolver, metadata::NonFungibleTokenMetadataProvider,
};
use near_sdk::near_bindgen;

use crate::*;

#[near_bindgen]
impl NonFungibleTokenResolver for Contract {
    #[private]
    fn nft_resolve_transfer(
        &mut self,
        previous_owner_id: AccountId,
        receiver_id: AccountId,
        token_id: TokenId,
        approved_account_ids: Option<std::collections::HashMap<AccountId, u64>>,
    ) -> bool {
        self.tokens.nft_resolve_transfer(
            previous_owner_id,
            receiver_id,
            token_id,
            approved_account_ids,
        )
    }
}

#[near_bindgen]
impl NonFungibleTokenMetadataProvider for Contract {
    fn nft_metadata(&self) -> NFTContractMetadata {
        self.metadata.get().unwrap()
    }
}

'''
'''--- src/my_internal.rs ---
use near_sdk::{json_types::U128, require, Balance};

use crate::*;

pub(crate) fn royalty_to_payout(royalty_percentage: u32, amount_to_pay: Balance) -> U128 {
    U128(royalty_percentage as u128 * amount_to_pay / 10_000u128)
}

pub(crate) fn parse_time(time: &String) -> u64 {
    let n = time.len();
    let num = &time[..(n - 1)].parse::<u64>();
    let period = time.as_bytes()[n - 1];
    require!(
        period == b's' || period == b'm' || period == b'h' || period == b'd',
        "Wrong time format."
    );
    require!(num.is_ok(), "Wrong time format.");
    let time: u64 = match period {
        b's' => 1_000_000_000,
        b'm' => 60 * 1_000_000_000,
        b'h' => 60 * 60 * 1_000_000_000,
        _ => 24 * 60 * 60 * 1_000_000_000,
    };
    num.as_ref().unwrap() * time
}

impl Contract {
    pub(crate) fn token_is_not_expired(&self, token_id: &TokenId) -> bool {
        let timestamp = self.expiration_timestamp.get(&token_id);
        timestamp.is_none() || timestamp.unwrap() >= env::block_timestamp()
    }

    pub(crate) fn enum_get_token(&self, owner_id: AccountId, token_id: TokenId) -> JsonToken {
        let metadata = self
            .tokens
            .token_metadata_by_id
            .as_ref()
            .unwrap()
            .get(&token_id);
        let approved_account_ids = Some(
            self.tokens
                .approvals_by_id
                .as_ref()
                .unwrap()
                .get(&token_id)
                .unwrap_or_default(),
        );
        let expiration_date = self.expiration_timestamp.get(&token_id).map(|x| x as u64);
        let royalty = self.royalty.get(&token_id).unwrap();
        JsonToken {
            token_id,
            owner_id,
            metadata,
            approved_account_ids,
            expiration_date,
            royalty,
        }
    }
}

'''
'''--- src/my_mint.rs ---
use near_contract_standards::non_fungible_token::{
    events::NftMint, refund_deposit_to_account, Token,
};
use near_sdk::{collections::UnorderedSet, near_bindgen, require};

use crate::{my_internal::parse_time, *};

#[near_bindgen]
impl Contract {
    #[payable]
    pub fn nft_mint(
        &mut self,
        token_id: TokenId,
        receiver_id: AccountId,
        token_metadata: TokenMetadata,
        expiration_period: Option<String>,
        perpetual_royalties: Option<HashMap<AccountId, u32>>,
    ) -> JsonToken {
        require!(env::predecessor_account_id() == env::current_account_id());
        // self.expiration_timestamp[token_id] = parse_time(expiration_period.unwrap());
        // Remember current storage usage if refund_id is Some
        let initial_storage_usage = (env::predecessor_account_id(), env::storage_usage());

        if self.tokens.owner_by_id.get(&token_id).is_some() {
            env::panic_str("token_id must be unique");
        }

        // create a royalty map to store in the token
        let mut royalty = HashMap::new();

        // if perpetual royalties were passed into the function:
        if let Some(perpetual_royalties) = perpetual_royalties {
            //make sure that the length of the perpetual royalties is below 7 since we won't have enough GAS to pay out that many people
            assert!(
                perpetual_royalties.len() < 7,
                "Cannot add more than 6 perpetual royalty amounts"
            );

            //iterate through the perpetual royalties and insert the account and amount in the royalty map
            for (account, amount) in perpetual_royalties {
                royalty.insert(account, amount);
            }
        }
        self.royalty.insert(&token_id, &royalty);

        let owner_id: AccountId = receiver_id;

        // Core behavior: every token must have an owner
        self.tokens.owner_by_id.insert(&token_id, &owner_id);

        // Metadata extension: Save metadata, keep variable around to return later.
        // Note that check above already panicked if metadata extension in use but no metadata
        // provided to call.
        self.tokens
            .token_metadata_by_id
            .as_mut()
            .and_then(|by_id| by_id.insert(&token_id, &token_metadata));

        // Enumeration extension: Record tokens_per_owner for use with enumeration view methods.
        if let Some(tokens_per_owner) = &mut self.tokens.tokens_per_owner {
            let mut token_ids = tokens_per_owner.get(&owner_id).unwrap_or_else(|| {
                UnorderedSet::new(StorageKey::TokensPerOwner {
                    account_hash: env::sha256(owner_id.as_bytes()),
                })
            });
            token_ids.insert(&token_id);
            tokens_per_owner.insert(&owner_id, &token_ids);
        }

        // Approval Management extension: return empty HashMap as part of Token
        let approved_account_ids = if self.tokens.approvals_by_id.is_some() {
            Some(HashMap::new())
        } else {
            None
        };

        // Return any extra attached deposit not used for storage

        let token = Token {
            token_id,
            owner_id,
            metadata: Some(token_metadata),
            approved_account_ids,
        };
        NftMint {
            owner_id: &token.owner_id,
            token_ids: &[&token.token_id],
            memo: None,
        }
        .emit();
        if let Some(time) = expiration_period {
            self.expiration_timestamp.insert(
                &token.token_id,
                &(env::block_timestamp() + parse_time(&time)),
            );
        }

        let (id, storage_usage) = initial_storage_usage;
        refund_deposit_to_account(env::storage_usage() - storage_usage, id);
        JsonToken {
            expiration_date: self.expiration_timestamp.get(&token.token_id),
            royalty: royalty,
            token_id: token.token_id,
            owner_id: token.owner_id,
            metadata: token.metadata,
            approved_account_ids: token.approved_account_ids,
        }
    }
}

'''
'''--- src/my_royalty.rs ---
use near_sdk::{assert_one_yocto, json_types::U128, serde::Deserialize};

use crate::{my_internal::royalty_to_payout, *};

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Payout {
    pub payout: HashMap<AccountId, U128>,
}
pub trait Payouts {
    fn nft_payout(&self, token_id: TokenId, balance: U128, max_len_payout: u32) -> Payout;

    fn nft_transfer_payout(
        &mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        approval_id: u64,
        memo: Option<String>,
        balance: U128,
        max_len_payout: u32,
    ) -> Payout;
}

#[near_bindgen]
impl Payouts for Contract {
    fn nft_payout(&self, token_id: TokenId, balance: U128, max_len_payout: u32) -> Payout {
        //get the owner of the token
        let owner_id = self
            .tokens
            .owner_by_id
            .get(&token_id)
            .expect("Token doesn't exist.");
        //keep track of the total perpetual royalties
        let mut total_perpetual = 0;
        //get the u128 version of the passed in balance (which was U128 before)
        let balance_u128 = u128::from(balance);
        //keep track of the payout object to send back
        let mut payout_object = Payout {
            payout: HashMap::new(),
        };
        //get the royalty object from token
        let royalty = self.royalty.get(&token_id).unwrap();

        //make sure we're not paying out to too many people (GAS limits this)
        assert!(
            royalty.len() as u32 <= max_len_payout,
            "Market cannot payout to that many receivers"
        );

        //go through each key and value in the royalty object
        for (k, v) in royalty.iter() {
            //get the key
            let key = k.clone();
            //only insert into the payout if the key isn't the token owner (we add their payout at the end)
            if key != owner_id {
                payout_object
                    .payout
                    .insert(key, royalty_to_payout(*v, balance_u128));
                total_perpetual += *v;
            }
        }

        // payout to previous owner who gets 100% - total perpetual royalties
        payout_object.payout.insert(
            owner_id,
            royalty_to_payout(10000 - total_perpetual, balance_u128),
        );

        //return the payout object
        payout_object
    }

    #[payable]
    fn nft_transfer_payout(
        &mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        approval_id: u64,
        memo: Option<String>,
        balance: U128,
        max_len_payout: u32,
    ) -> Payout {
        assert_one_yocto();
        let payout = self.nft_payout(token_id.clone(), balance, max_len_payout);
        self.nft_transfer(receiver_id, token_id, Some(approval_id), memo);
        payout
    }
}

'''