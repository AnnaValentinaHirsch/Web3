*GitHub Repository "microchipgnu/minsta-contract-rs"*

'''--- Cargo.toml ---
[package]
name = "minsta_proxy_minter"
version = "0.0.1"
authors = ["microchipgnu"]
edition = "2018"

[dependencies]
near-sdk = "4.0.0-pre.4"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
near_groth16_verifier="1.0.1"

[lib]
crate-type = ["cdylib"]

[profile.release]
codegen-units = 1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true
'''
'''--- README.md ---
# Minsta Proxy Minter NEAR Contract

This smart contract on the NEAR network is designed to handle minting functionality through proxy minters. It provides a way to mint Non-Fungible Tokens (NFTs) through specified minters while keeping track of the latest minter for each NFT contract.

## Contract Structure

### MinstaProxyMinter

- `latest_minters`: Lookup map that keeps track of the latest minter for each NFT contract ID.
- `mint`: A method that takes metadata and NFT contract ID to mint NFTs, payable and callable.
- `cb_mint`: A private callback method for handling successful minting.
- `get_latest_minter`: A view method to get the latest minter for a given NFT contract ID.

# Quickstart

1. Make sure you Rust installed.
2. Install the [`NEAR CLI`](https://github.com/near/near-cli#setup)

<br />

## 1. Build and Deploy the Contract
Compile and deploy the contract in the NEAR testnet by running:

```bash
sh ./scripts/build

# cargo build --target wasm32-unknown-unknown --release
```

Check the `neardev/dev-account` file to find the address in which the contract was deployed:

```bash
cat ./neardev/dev-account
# e.g. dev-1659899566943-21539992274727
```

<br />

## 2. Minting an NFT
To mint an NFT, you will need to call the `mint` method. Make sure to specify the metadata and NFT contract ID:

```bash
# Use near-cli to mint an NFT
near call <dev-account> mint '{"metadata":"<metadata>","nft_contract_id":"<nft_contract_id>"}' --accountId <dev-account> --amount <amount>
```

<br />

## 3. Retrieve the Latest Minter
You can get the latest minter for a given NFT contract ID:

```bash
# Use near-cli to get the latest minter
near view <dev-account> get_latest_minter '{"nft_contract_id":"<nft_contract_id>"}'
```

<br />

## Note
Please replace `<dev-account>`, `<metadata>`, `<nft_contract_id>`, and `<amount>` with appropriate values as needed.

Ensure that the account calling the `mint` method has the necessary funds to cover the associated costs, as this is a payable function.

---
'''
'''--- neardev/dev-account.env ---
CONTRACT_NAME=dev-1697627954476-53761997077118
'''
'''--- scripts/build.sh ---
#!/usr/bin/env bash

cargo build --target wasm32-unknown-unknown --release
'''
'''--- src/lib.rs ---
use near_sdk::{
    borsh::{ self, BorshDeserialize, BorshSerialize },
    collections::LookupMap,
    env,
    near_bindgen,
    Promise,
    AccountId,
};
use serde::{ Serialize, Deserialize };

#[derive(Debug, Serialize, Deserialize)]
pub struct Metadata {
    title: Option<String>,
    description: Option<String>,
    media: Option<String>,
    media_hash: Option<String>,
    copies: Option<i32>,
    expires_at: Option<i64>,
    starts_at: Option<i64>,
    extra: Option<String>,
    reference: Option<String>,
    reference_hash: Option<String>,
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct MinstaProxyMinter {
    latest_minters: LookupMap<AccountId, AccountId>,
}

impl Default for MinstaProxyMinter {
    fn default() -> Self {
        Self {
            latest_minters: LookupMap::new(b"latest_minters".to_vec()),
        }
    }
}

#[near_bindgen]
impl MinstaProxyMinter {
    pub fn mint(&mut self, metadata: String, nft_contract_id: AccountId) -> Promise {
        let parsed_metadata: Result<Metadata, serde_json::Error> = serde_json::from_str(&metadata);

        match parsed_metadata {
            Ok(parsed) => {
                let minter_id = env::predecessor_account_id();
                let prev_minter_id = self.latest_minters
                    .get(&nft_contract_id)
                    .unwrap_or(minter_id.clone());
                let mut royalty_args = std::collections::HashMap::new();
                royalty_args.insert(minter_id.clone(), 10000);

                let args =
                    serde_json::json!({
                    "owner_id": prev_minter_id,
                    "metadata": parsed,
                    "num_to_mint": 1,
                    "royalty_args": {
                        "split_between": royalty_args,
                        "percentage": 1000
                    },
                    "split_owners": serde_json::Value::Null
                });

                Promise::new(nft_contract_id.clone())
                    .function_call(
                        "nft_batch_mint".to_string(),
                        args.to_string().into_bytes(),
                        (0 as u128).into(),
                        near_sdk::Gas(100_000_000_000_000)
                    )
                    .then(
                        Promise::new(env::current_account_id()).function_call(
                            "cb_mint".to_string(),
                            serde_json::json!({
                                "latest_minter_id": minter_id,
                                "nft_contract_id": nft_contract_id.clone()
                            })
                                .to_string()
                                .into_bytes(),
                            (0 as u128).into(),
                            near_sdk::Gas(50_000_000_000_000)
                        )
                    )
            }
            Err(_) => env::panic(b"Failed to parse metadata"),
        }
    }

    pub fn cb_mint(&mut self, latest_minter_id: AccountId, nft_contract_id: AccountId) -> bool {
        if env::promise_results_count() == 1 {
            self.latest_minters.insert(&nft_contract_id, &latest_minter_id);
            true
        } else {
            false
        }
    }

    pub fn get_latest_minter(&self, nft_contract_id: AccountId) -> Option<AccountId> {
        self.latest_minters.get(&nft_contract_id)
    }
}

#[cfg(test)]
mod tests {
    // TODO: Add tests here.
}

'''