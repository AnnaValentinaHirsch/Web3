*GitHub Repository "near-examples/indexer-tx-watcher-example-lake"*

'''--- Cargo.toml ---
[package]
name = "indexer-tx-watcher-example"
version = "0.1.0"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2021"

[dependencies]
base64 = "0.11"
clap = { version = "3.1.6", features = ["derive"] }
futures = "0.3.5"
serde = { version = "1", features = ["derive"] }
serde_json = "1.0.55"
itertools = "0.9.0"
tokio = { version = "1.1", features = ["sync", "time", "macros", "rt-multi-thread"] }
tokio-stream = { version = "0.1" }
tracing = "0.1.13"
tracing-subscriber = "0.2.4"

near-lake-framework = "0.4.0"

'''
'''--- README.md ---
Indexer that catches txs for specific contract(s)
=================================================

**This project is a copy of https://github.com/near-examples/indexer-tx-watcher-example but is migrated to [NEAR Lake Framework](https://github.com/near/near-lake-framework). We keep them both separately as they show different approaches to the same use case**

The most common use case for indexers is to react on a transaction sent to a specific contract or a list of contracts.

This project is trying to provide an example of the indexer described about. It's simple yet doing the necessary stuff. In this example we don't use any external storage (like database or files) to keep track for the transactions to keep the example as simple as possible.

We've tried to put the explanatory comments in the code to help developers to extend this example according to their needs.

> Please refer to [NEAR Indexer for Explorer](https://github.com/near/near-indexer-for-explorer) to find an inspiration for extending the indexer.

## How it works

Assuming we want to watch for transactions where a receiver account id is one of the provided in a list.
We pass the list of account ids (or contracts it is the same) via argument `--accounts`.
We want to catch all *successfull* transactions sent to one of the accounts from the list.
In the demo we'll just look for them and log them but it might and probably should be extended based on your needs.

---

## How to use

Before you proceed, make sure you have the following software installed:
* [rustup](https://rustup.rs/) or Rust version that is mentioned in `rust-toolchain` file in the root of [nearcore](https://github.com/nearprotocol/nearcore) project.

Clone this repository and open the project folder

```bash
$ git clone git@github.com:khorolets/indexer-tx-watcher-example.git
$ cd indexer-tx-watcher-example
```

### Run

```bash
$ cargo build --release
$ ./target/release/indexer-tx-watcher-example --accounts mycoolcontract.near,myanothercoolcontract.near --block-height 88088521 testnet
```

Provide your contracts list after `--accounts` key separated with comma (`,`) **avoid spaces**, pick a fresher block height on https://explorer.testnet.near.org/

---

Find more docs about indexers on https://near-indexers.io

'''
'''--- src/configs.rs ---
use clap::Parser;

use tracing_subscriber::EnvFilter;

/// NEAR Indexer Example
/// Watches for stream of blocks from the chain
#[derive(Parser, Debug, Clone)]
#[clap(version = "0.1", author = "Near Inc. <hello@nearprotocol.com>")]
pub(crate) struct Opts {
    /// block height to start indexing from
    #[clap(long)]
    pub block_height: u64,
    /// account ids to watch for
    #[clap(long)]
    pub accounts: String,
    #[clap(subcommand)]
    pub subcmd: SubCommand,
}

#[derive(Parser, Debug, Clone)]
pub(crate) enum SubCommand {
    Mainnet,
    Testnet,
}

pub(crate) fn init_logging() {
    let env_filter = EnvFilter::new("near_lake_framework=info");
    tracing_subscriber::fmt::Subscriber::builder()
        .with_env_filter(env_filter)
        .with_writer(std::io::stderr)
        .init();
}

impl From<Opts> for near_lake_framework::LakeConfig {
    fn from(opts: Opts) -> Self {
        let mut lake_config =
            near_lake_framework::LakeConfigBuilder::default().start_block_height(opts.block_height);

        match &opts.subcmd {
            SubCommand::Mainnet => {
                lake_config = lake_config.mainnet();
            }
            SubCommand::Testnet => {
                lake_config = lake_config.testnet();
            }
        };

        lake_config.build().expect("Failed to build LakeConfig")
    }
}

'''
'''--- src/main.rs ---
use std::str::FromStr;

use std::collections::{HashMap, HashSet};

use clap::Parser;
use tokio::sync::mpsc;
use tracing::info;

use near_lake_framework::near_indexer_primitives;
use near_lake_framework::LakeConfig;

use configs::{init_logging, Opts};

mod configs;

/// Assuming we want to watch for transactions where a receiver account id is one of the provided in a list
/// We pass the list of account ids (or contracts it is the same) via argument ``--accounts``
/// We want to catch all *successfull* transactions sent to one of the accounts from the list.
/// In the demo we'll just look for them and log them but it might and probably should be extended based on your needs.

#[tokio::main]
async fn main() -> Result<(), tokio::io::Error> {
    init_logging();

    let opts: Opts = Opts::parse();

    let config: LakeConfig = opts.clone().into();

    let (_, stream) = near_lake_framework::streamer(config);

    let watching_list = opts
        .accounts
        .split(',')
        .map(|elem| {
            near_indexer_primitives::types::AccountId::from_str(elem).expect("AccountId is invalid")
        })
        .collect();

    listen_blocks(stream, watching_list).await;

    Ok(())
}

/// The main listener function the will be reading the stream of blocks `StreamerMessage`
/// and perform necessary checks
async fn listen_blocks(
    mut stream: mpsc::Receiver<near_indexer_primitives::StreamerMessage>,
    watching_list: Vec<near_indexer_primitives::types::AccountId>,
) {
    eprintln!("listen_blocks");
    // This will be a map of correspondence between transactions and receipts
    let mut tx_receipt_ids = HashMap::<String, String>::new();
    // This will be a list of receipt ids we're following
    let mut wanted_receipt_ids = HashSet::<String>::new();

    // Boilerplate code to listen the stream
    while let Some(streamer_message) = stream.recv().await {
        eprintln!("Block height: {}", streamer_message.block.header.height);
        for shard in streamer_message.shards {
            let chunk = if let Some(chunk) = shard.chunk {
                chunk
            } else {
                continue;
            };

            for transaction in chunk.transactions {
                // Check if transaction receiver id is one of the list we are interested in
                if is_tx_receiver_watched(&transaction, &watching_list) {
                    // extract receipt_id transaction was converted into
                    let converted_into_receipt_id = transaction
                        .outcome
                        .execution_outcome
                        .outcome
                        .receipt_ids
                        .first()
                        .expect("`receipt_ids` must contain one Receipt Id")
                        .to_string();
                    // add `converted_into_receipt_id` to the list of receipt ids we are interested in
                    wanted_receipt_ids.insert(converted_into_receipt_id.clone());
                    // add key value pair of transaction hash and in which receipt id it was converted for further lookup
                    tx_receipt_ids.insert(
                        converted_into_receipt_id,
                        transaction.transaction.hash.to_string(),
                    );
                }
            }

            for execution_outcome in shard.receipt_execution_outcomes {
                if let Some(receipt_id) =
                    wanted_receipt_ids.take(&execution_outcome.receipt.receipt_id.to_string())
                {
                    // log the tx because we've found it
                    info!(
                        target: "indexer_example",
                        "Transaction hash {:?} related to {} executed with status {:?}",
                        tx_receipt_ids.get(receipt_id.as_str()),
                        &execution_outcome.receipt.receiver_id,
                        execution_outcome.execution_outcome.outcome.status
                    );
                    if let near_indexer_primitives::views::ReceiptEnumView::Action {
                        signer_id,
                        ..
                    } = &execution_outcome.receipt.receipt
                    {
                        eprintln!("{}", signer_id);
                    }

                    if let near_indexer_primitives::views::ReceiptEnumView::Action {
                        actions, ..
                    } = execution_outcome.receipt.receipt
                    {
                        for action in actions.iter() {
                            if let near_indexer_primitives::views::ActionView::FunctionCall {
                                args,
                                ..
                            } = action
                            {
                                if let Ok(decoded_args) = base64::decode(args) {
                                    if let Ok(args_json) =
                                        serde_json::from_slice::<serde_json::Value>(&decoded_args)
                                    {
                                        eprintln!("{:#?}", args_json);
                                    }
                                }
                            }
                        }
                    }
                    // remove tx from hashmap
                    tx_receipt_ids.remove(receipt_id.as_str());
                }
            }
        }
    }
}

fn is_tx_receiver_watched(
    tx: &near_indexer_primitives::IndexerTransactionWithOutcome,
    watching_list: &[near_indexer_primitives::types::AccountId],
) -> bool {
    watching_list.contains(&tx.transaction.receiver_id)
}

'''