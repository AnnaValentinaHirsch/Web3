*GitHub Repository "NEAR-Edu/contract-registry"*

'''--- .vscode/settings.json ---
{
  "editor.tabSize": 4
}

'''
'''--- Cargo.toml ---
[workspace]
members = [
  "model",
  "contract",
  "service",
]

'''
'''--- build.sh ---
#!/usr/bin/env bash

cargo build --target wasm32-unknown-unknown --release

'''
'''--- contract/Cargo.toml ---
[package]
name = "near-smart-contract-rust-template"
version = "0.1.0"
edition = "2021"
authors = ["Jacob Lindahl <jacob@near.foundation>"]

[dependencies]
model = { path="../model" }
near-sdk = "4.0.0-pre.7"
bs58 = "0.4.0"

[lib]
crate-type = ["cdylib"]

[profile.release]
codegen-units = 1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- contract/README.md ---
# NEAR Smart Contract Rust Template

Project structure for writing smart contracts in Rust for NEAR Protocol

# Dependencies

- Rust 1.56
- Node.js 14
- NEAR CLI 3.1

# Authors

- Jacob Lindahl <jacob@near.foundation> [@sudo_build](https://twitter.com/sudo_build)

'''
'''--- contract/src/contract.rs ---
use model::{
    code_hash::CodeHash,
    verification::{Verification, VerificationRequest, VerificationStatus},
};
use near_sdk::{
    assert_one_yocto,
    borsh::{self, BorshDeserialize, BorshSerialize},
    collections::{UnorderedMap, Vector},
    env,
    json_types::{U128, U64},
    near_bindgen, require, AccountId, BorshStorageKey, PanicOnDefault,
};

use crate::{
    impl_ownership,
    ownership::{Ownable, Ownership},
    utils::storage_refund,
};

#[derive(BorshStorageKey, BorshSerialize)]
enum StorageKey {
    OWNERSHIP,
    REQUESTS,
    VERIFICATIONS,
}

#[near_bindgen]
#[derive(PanicOnDefault, BorshDeserialize, BorshSerialize)]
pub struct Contract {
    pub ownership: Ownership,
    pub requests: Vector<VerificationRequest>,
    pub verifications: UnorderedMap<CodeHash, Verification>,
    pub verification_fee: u128,
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new(owner_id: AccountId, verification_fee: U128) -> Self {
        Self {
            ownership: Ownership::new(StorageKey::OWNERSHIP, owner_id),
            requests: Vector::new(StorageKey::REQUESTS),
            verifications: UnorderedMap::new(StorageKey::VERIFICATIONS),
            verification_fee: verification_fee.into(),
        }
    }

    pub fn get_verification_fee(&self) -> U128 {
        self.verification_fee.into()
    }

    #[payable]
    pub fn set_verification_fee(&mut self, verification_fee: U128) {
        assert_one_yocto();
        self.ownership.assert_owner();
        self.verification_fee = verification_fee.into();
    }

    pub fn get_verification_request(&self, id: U64) -> Option<VerificationRequest> {
        self.requests.get(id.into())
    }

    pub fn get_verification_result(&self, request_id: U64) -> Option<Verification> {
        let request_id = u64::from(request_id);
        self.verifications
            .values()
            .find(|v| v.request_id == request_id)
    }

    pub fn verify_code_hash(&self, code_hash: CodeHash) -> Option<Verification> {
        self.verifications.get(&code_hash)
    }

    pub fn get_pending_requests(&self) -> Vec<VerificationRequest> {
        self.requests
            .iter()
            .filter(|r| r.status == VerificationStatus::PENDING)
            .collect()
    }

    #[payable]
    pub fn request_verification(&mut self, repository: String, checkout: String, path: String, fee: U128) -> VerificationRequest {
        let attached_deposit = env::attached_deposit();
        require!(attached_deposit > 0, "Deposit required");

        let verification_fee: u128 = fee.into();
        require!(
            attached_deposit >= verification_fee,
            "Deposit less than indicated fee"
        );
        require!(
            verification_fee >= self.verification_fee,
            "Fee less than minimum requirement"
        );

        let storage_usage_start = env::storage_usage();

        let id = self.requests.len();
        let now = env::block_timestamp();

        let request = VerificationRequest {
            id,
            repository,
            checkout,
            path,
            fee: verification_fee.into(),
            status: VerificationStatus::PENDING,
            created_at: now,
            updated_at: now,
        };

        self.requests.push(&request);

        storage_refund(storage_usage_start, verification_fee);

        request
    }

    fn resolve(&mut self, id: u64, result: Option<Verification>) {
        let attached_deposit = env::attached_deposit();
        require!(attached_deposit > 0, "Deposit required");

        let storage_usage_start = env::storage_usage();

        self.ownership.assert_owner();

        let request = self
            .requests
            .get(id)
            .unwrap_or_else(|| env::panic_str("Request ID does not exist"));

        require!(
            request.status == VerificationStatus::PENDING,
            "Request already resolved"
        );

        let now = env::block_timestamp();
        if let Some(result) = &result {
            self.verifications.insert(&result.code_hash, &result);
            self.requests.replace(
                id,
                &VerificationRequest {
                    status: VerificationStatus::SUCCESS,
                    updated_at: now,
                    ..request
                },
            );
        } else {
            self.requests.replace(
                id,
                &VerificationRequest {
                    status: VerificationStatus::FAILURE,
                    updated_at: now,
                    ..request
                },
            );
        }

        storage_refund(storage_usage_start, 0);
    }

    #[payable]
    pub fn verification_success(&mut self, result: Verification) {
        self.resolve(result.request_id, Some(result));
    }

    #[payable]
    pub fn verification_failure(&mut self, id: U64) {
        self.resolve(id.into(), None);
    }
}

impl_ownership!(Contract, ownership);

'''
'''--- contract/src/lib.rs ---
mod ownership;
mod utils;

mod contract;
pub use contract::*;

#[cfg(test)]
mod tests {
    use model::verification::VerificationStatus;
    use near_sdk::{test_utils::*, testing_env, AccountId};

    use crate::{ownership::Ownable, Contract};

    const ONE_NEAR: u128 = u128::pow(10, 24);

    fn account_contract() -> AccountId {
        "contract".parse::<AccountId>().unwrap()
    }

    fn account_owner() -> AccountId {
        "owner".parse::<AccountId>().unwrap()
    }

    fn account_user1() -> AccountId {
        "alice".parse::<AccountId>().unwrap()
    }

    fn account_user2() -> AccountId {
        "bob".parse::<AccountId>().unwrap()
    }

    const VERIFICATION_FEE: u128 = ONE_NEAR * 1;
    const REPOSITORY_URL: &'static str = "https://github.com/NEAR-Edu/stats.gallery-dapp.git";
    const CHECKOUT: &'static str = "main";
    const PATH: &'static str = "";

    fn get_context(predecessor_account_id: AccountId) -> VMContextBuilder {
        let mut builder = VMContextBuilder::new();
        builder
            .current_account_id(account_contract())
            .account_balance(15 * ONE_NEAR)
            .signer_account_id(predecessor_account_id.clone())
            .predecessor_account_id(predecessor_account_id);
        builder
    }

    #[test]
    fn initialization() {
        let context = get_context(account_owner());
        testing_env!(context.build());

        let contract = Contract::new(account_owner(), VERIFICATION_FEE.into());

        assert_eq!(
            contract.own_get_owner(),
            Some(account_owner()),
            "Account owner set correctly"
        );

        assert_eq!(
            u128::from(contract.get_verification_fee()),
            VERIFICATION_FEE,
            "Verification fee set correctly"
        );

        assert_eq!(
            contract.get_pending_requests().len(),
            0,
            "Empty pending requests on init"
        );
    }

    #[test]
    fn create_request() {
        let context = get_context(account_owner());
        testing_env!(context.build());

        let mut contract = Contract::new(account_owner(), VERIFICATION_FEE.into());

        let mut context = get_context(account_user1());
        context.attached_deposit(VERIFICATION_FEE + u128::pow(10, 22) /* storage fee */);
        testing_env!(context.build());

        let request = contract.request_verification(
            REPOSITORY_URL.to_string(),
            CHECKOUT.to_string(),
            PATH.to_string(),
            VERIFICATION_FEE.into(),
        );

        assert_eq!(
            request.repository, REPOSITORY_URL,
            "Repository URL set correctly"
        );

        assert_eq!(
            u128::from(request.fee),
            VERIFICATION_FEE,
            "Fee set correctly"
        );

        assert_eq!(
            request.status,
            VerificationStatus::PENDING,
            "Status is pending"
        );

        let by_id = contract
            .get_verification_request(request.id.into())
            .expect("Can get request by ID");

        assert_eq!(by_id, request, "Request by ID matches");
    }

    #[test]
    #[should_panic(expected = "Insufficient deposit")]
    fn create_request_insufficient_deposit() {
        let context = get_context(account_owner());
        testing_env!(context.build());

        let mut contract = Contract::new(account_owner(), VERIFICATION_FEE.into());

        let mut context = get_context(account_user1());
        context.attached_deposit(VERIFICATION_FEE); // no storage fee
        testing_env!(context.build());

        contract.request_verification(
            REPOSITORY_URL.to_string(),
            CHECKOUT.to_string(),
            PATH.to_string(),
            VERIFICATION_FEE.into(),
        );
    }

    #[test]
    #[should_panic(expected = "Deposit required")]
    fn create_request_no_deposit() {
        let context = get_context(account_owner());
        testing_env!(context.build());

        let mut contract = Contract::new(account_owner(), VERIFICATION_FEE.into());

        let context = get_context(account_user1());
        // context.attached_deposit(...); // no deposit
        testing_env!(context.build());

        contract.request_verification(
            REPOSITORY_URL.to_string(),
            CHECKOUT.to_string(),
            PATH.to_string(),
            VERIFICATION_FEE.into(),
        );
    }
}

'''
'''--- contract/src/ownership.rs ---
use near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize},
    collections::LazyOption,
    env, require, AccountId, IntoStorageKey,
};

use crate::utils::prefix_key;

#[derive(BorshDeserialize, BorshSerialize)]
pub struct Ownership {
    pub owner: Option<AccountId>,
    pub proposed_owner: LazyOption<AccountId>,
}

impl Ownership {
    pub fn new<S>(storage_key_prefix: S, owner_id: AccountId) -> Self
    where
        S: IntoStorageKey,
    {
        let k = storage_key_prefix.into_storage_key();

        Self {
            owner: Some(owner_id),
            proposed_owner: LazyOption::new(prefix_key(&k, b"p"), None),
        }
    }

    pub fn assert_owner(&self) {
        require!(
            &env::predecessor_account_id()
                == self
                    .owner
                    .as_ref()
                    .unwrap_or_else(|| env::panic_str("No owner")),
            "Owner only"
        );
    }

    pub fn renounce_owner(&mut self) {
        self.assert_owner();
        self.owner = None;
        self.proposed_owner.remove();
    }

    pub fn propose_owner(&mut self, account_id: Option<AccountId>) {
        self.assert_owner();
        if let Some(a) = account_id {
            self.proposed_owner.set(&a);
        } else {
            self.proposed_owner.remove();
        }
    }

    pub fn accept_owner(&mut self) {
        let proposed_owner = self
            .proposed_owner
            .take()
            .unwrap_or_else(|| env::panic_str("No proposed owner"));
        require!(
            &env::predecessor_account_id() == &proposed_owner,
            "Proposed owner only"
        );
        self.owner = Some(proposed_owner);
    }
}

pub trait Ownable {
    fn own_get_owner(&self) -> Option<AccountId>;
    fn own_get_proposed_owner(&self) -> Option<AccountId>;
    fn own_renounce_owner(&mut self);
    fn own_propose_owner(&mut self, account_id: Option<AccountId>);
    fn own_accept_owner(&mut self);
}

#[macro_export]
macro_rules! impl_ownership {
    ($contract: ident, $ownership: ident) => {
        #[near_bindgen]
        impl Ownable for $contract {
            fn own_get_owner(&self) -> Option<AccountId> {
                self.$ownership.owner.clone()
            }

            fn own_get_proposed_owner(&self) -> Option<AccountId> {
                self.$ownership.proposed_owner.get()
            }

            #[payable]
            fn own_renounce_owner(&mut self) {
                assert_one_yocto();
                self.$ownership.renounce_owner()
            }

            #[payable]
            fn own_propose_owner(&mut self, account_id: Option<AccountId>) {
                assert_one_yocto();
                self.$ownership.propose_owner(account_id);
            }

            #[payable]
            fn own_accept_owner(&mut self) {
                assert_one_yocto();
                self.$ownership.accept_owner();
            }
        }
    };
}

'''
'''--- contract/src/utils.rs ---
use near_sdk::{env, log, require, Balance, Promise, StorageUsage};

pub(crate) fn prefix_key(prefix: &Vec<u8>, key: &[u8]) -> Vec<u8> {
    [prefix as &[u8], key].concat()
}

pub(crate) fn storage_refund(storage_usage_start: StorageUsage, other_fees: Balance) {
    let storage_usage_end = env::storage_usage();

    let storage_fee = Balance::from(storage_usage_end.saturating_sub(storage_usage_start))
        * env::storage_byte_cost();

    let total_required_deposit = storage_fee + other_fees;

    let attached_deposit = env::attached_deposit();

    require!(
        attached_deposit >= total_required_deposit,
        format!(
            "Insufficient deposit: required: {} yoctoNEAR; received: {} yoctoNEAR",
            &total_required_deposit, &attached_deposit
        )
    );

    let refund = attached_deposit - total_required_deposit;

    log!("storage fee: {} yoctoNEAR", &storage_fee);
    log!("refund: {} yoctoNEAR", &refund);

    if refund > 0 {
        Promise::new(env::predecessor_account_id()).transfer(refund);
    }
}

'''
'''--- deploy.sh ---
#!/usr/bin/env bash

WASM_PATH="$(find ./target/wasm32-unknown-unknown/release/ -maxdepth 1 -name "*.wasm")"

near deploy \
  --wasmFile $WASM_PATH \
  --accountId "$1" \
  --initFunction new \
  --initArgs "$(node ./init-args.js)"

'''
'''--- dev-deploy.sh ---
#!/usr/bin/env bash

WASM_PATH="$(find ./target/wasm32-unknown-unknown/release/ -maxdepth 1 -name "*.wasm")"

near dev-deploy \
  --wasmFile $WASM_PATH \
  "$@"

near call "$(<./neardev/dev-account)" new "$(node ./init-args.js)" \
  --accountId "$(<./neardev/dev-account)"

'''
'''--- docker-compose.yml ---
version: '3'
services:
  contract-registry-service:
    build:
      context: .
      dockerfile: ./service/Dockerfile
    ports:
     - "8000:8000"

'''
'''--- init-args.js ---
const ONE_DAY = 1_000_000_000 * 60 * 60 * 24;

// 1e24, calculated like this because JS numbers don't work that large
const ONE_NEAR = BigInt(1e12) ** 2n;

console.log(JSON.stringify({
    owner_id: "hatchet.testnet",
    verification_fee: ONE_NEAR / 100n + '',
}));

'''
'''--- model/Cargo.toml ---
[package]
name = "model"
version = "0.1.0"
edition = "2021"

[dependencies]
near-sdk = "4.0.0-pre.7"
bs58 = "0.4.0"
sha2 = "0.10.2"

'''
'''--- model/src/code_hash.rs ---
use std::{fmt::Display, str::FromStr};

use near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize},
    serde::{de::*, Serialize, Serializer},
    serde_json,
};
use sha2::{Digest, Sha256};

#[derive(BorshDeserialize, BorshSerialize, PartialEq, Clone, Debug)]
pub struct CodeHash(pub Vec<u8>); // vs [u8; 32] ?

impl CodeHash {
    pub fn hash_bytes(bytes: impl AsRef<[u8]>) -> Self {
        let mut hasher = Sha256::new();
        hasher.update(bytes);
        Self(hasher.finalize().to_vec())
    }
}

impl FromStr for CodeHash {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl<T: AsRef<[u8]>> From<&T> for CodeHash {
    fn from(bytes: &T) -> Self {
        Self(bytes.as_ref().to_vec())
    }
}

impl Display for CodeHash {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", bs58::encode(&self.0).into_string())
    }
}

impl Serialize for CodeHash {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let CodeHash(v) = self;
        let encoded = bs58::encode(v).into_string();
        serializer.serialize_str(&encoded)
    }
}

struct CodeHashVisitor;

impl<'de> Visitor<'de> for CodeHashVisitor {
    type Value = CodeHash;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("base58-encoded hash")
    }

    fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>
    where
        E: near_sdk::serde::de::Error,
    {
        bs58::decode(v)
            .into_vec()
            .map(|v| CodeHash(v))
            .map_err(|e| E::custom(format!("base58 decode error: {}", e)))
    }
}

impl<'de> Deserialize<'de> for CodeHash {
    fn deserialize<D>(deserializer: D) -> Result<CodeHash, D::Error>
    where
        D: Deserializer<'de>,
    {
        deserializer.deserialize_str(CodeHashVisitor)
    }
}

#[cfg(test)]
mod tests {
    use std::str::FromStr;

    use near_sdk::serde_json;

    use super::CodeHash;

    #[test]
    fn code_hash_serialize() {
        let expected = "\"2yGEbwRGRKr9Udf39\"";
        let actual = serde_json::to_string(&CodeHash("hello, world".as_bytes().to_vec()))
            .expect("Cannot serialize");
        assert_eq!(expected, actual);
    }

    #[test]
    fn code_hash_deserialize() {
        let expected = CodeHash("hello, world".as_bytes().to_vec());
        let actual: CodeHash =
            serde_json::from_str("\"2yGEbwRGRKr9Udf39\"").expect("Cannot deserialize");
        assert_eq!(expected, actual);
    }

    #[test]
    fn from_str() {
        let expected = CodeHash("hello, world".as_bytes().to_vec());
        let actual = CodeHash::from_str("\"2yGEbwRGRKr9Udf39\"").expect("Cannot deserialize");
        assert_eq!(expected, actual);
    }
}

'''
'''--- model/src/lib.rs ---
pub mod code_hash;
pub mod sequential_id;
pub mod verification;

#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        let result = 2 + 2;
        assert_eq!(result, 4);
    }
}

'''
'''--- model/src/sequential_id.rs ---
pub trait SequentialId<T: Ord> {
    fn seq_id(&self) -> T;
}

'''
'''--- model/src/verification.rs ---
use near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize},
    json_types::U128,
    serde::{Deserialize, Serialize},
};

use crate::{code_hash::CodeHash, sequential_id::SequentialId};

#[derive(BorshDeserialize, BorshSerialize, Deserialize, Serialize, PartialEq, Debug, Clone)]
#[serde(crate = "near_sdk::serde")]
pub enum VerificationStatus {
    PENDING,
    SUCCESS,
    FAILURE,
}

#[derive(BorshDeserialize, BorshSerialize, Deserialize, Serialize, PartialEq, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct Verification {
    pub id: u64,
    pub code_hash: CodeHash,
    pub code_url: String,
    pub repository: String,
    pub remote: String,
    pub branch: String,
    pub commit: String,
    pub request_id: u64,
}

#[derive(BorshDeserialize, BorshSerialize, Deserialize, Serialize, PartialEq, Debug, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct VerificationRequest {
    pub id: u64,
    pub repository: String,
    pub path: String,
    pub checkout: String,
    pub fee: U128,
    pub status: VerificationStatus,
    pub created_at: u64,
    pub updated_at: u64,
}

impl SequentialId<u64> for VerificationRequest {
    fn seq_id(&self) -> u64 {
        self.id
    }
}

#[cfg(test)]
mod tests {
    use near_sdk::{serde_json, };

    use super::VerificationRequest;

    #[test]
    fn test() {
        let s = serde_json::to_string(&VerificationRequest {
            id: 0,
            repository: "repository".to_string(),
            checkout: "main".to_string(),
            path: "".to_string(),
            fee: (3u128).into(),
            status: super::VerificationStatus::PENDING,
            created_at: 0,
            updated_at: 0,
        });
        println!("{:?}", s);
    }
}

'''
'''--- prettier.config.js ---
module.exports = {
  tabWidth: 2,
  singleQuote: true,
  trailingComma: 'all',
  arrowParens: 'avoid',
};

'''
'''--- rustfmt.toml ---
tab_spaces = 4

'''
'''--- service/Cargo.toml ---
[package]
name = "contract-registry-service"
version = "0.1.0"
edition = "2021"

[dependencies]
bs58 = "0.4.0"
dotenv = "0.15.0"
futures = "0.3.21"
git2 = "0.14.2"
hex = "0.4.3"
hmac = "0.12.0"
model = { path = "../model" }
near-crypto = "0.12.0"
near-jsonrpc-client = "0.3.0"
near-jsonrpc-primitives = "0.12.0"
near-primitives = "0.12.0"
reqwest = { version = "0.11", features = ["json"] }
serde = "1.0.136"
serde_json = "1.0.79"
sha2 = "0.10.1"
thiserror = "1.0.30"
tokio = { version = "1.16.1", features = ["full"] }
tracing = "0.1.30"
tracing-subscriber = { version = "0.3.8", features = ["env-filter"] }
warp = "0.3.2"

[features]

'''
'''--- service/network/mainnet.json ---
{
    "networkId": "mainnet",
    "nodeUrl": "https://rpc.mainnet.near.org",
    "archivalUrl": "https://archival-rpc.mainnet.near.org",
    "walletUrl": "https://wallet.mainnet.near.org",
    "helperUrl": "https://helper.mainnet.near.org",
    "explorerUrl": "https://explorer.mainnet.near.org"
}

'''
'''--- service/network/testnet.json ---
{
    "networkId": "testnet",
    "nodeUrl": "https://rpc.testnet.near.org",
    "archivalUrl": "https://archival-rpc.testnet.near.org",
    "walletUrl": "https://wallet.testnet.near.org",
    "helperUrl": "https://helper.testnet.near.org",
    "explorerUrl": "https://explorer.testnet.near.org"
}

'''
'''--- service/src/circleci/client.rs ---
use futures::{future, Future};
use model::code_hash::CodeHash;
use std::collections::HashMap;
use thiserror::Error;
use tokio::task::JoinError;
use warp::reject::Reject;

use reqwest::Client;

use super::error::CircleCiError;

pub async fn request_job(
    client: &Client,
    project_slug: String,
    job_number: String,
) -> Result<VerificationMetadata, ParallelError<CircleCiError>> {
    let artifacts = get_job_artifacts(client, &project_slug, &job_number).await?;
    let metadata = assemble(client, artifacts).await.map_err(|e| match e {
        ParallelError::TaskError(f) => ParallelError::TaskError(CircleCiError::ReqwestError(f)),
        ParallelError::JoinError(f) => ParallelError::JoinError(f),
    })?;
    Ok(metadata)
}

pub async fn get_job_artifacts(
    client: &Client,
    project_slug: &str,
    job_number: &str,
) -> Result<HashMap<String, String>, CircleCiError> {
    let json = client
        .get(format!(
            "https://circleci.com/api/v2/project/{}/{}/artifacts",
            project_slug, job_number
        ))
        .send()
        .await?
        .json::<serde_json::Value>()
        .await?;

    json.as_object()
        .and_then(|json_obj| json_obj.get("items"))
        .and_then(|items_value| items_value.as_array())
        .map(|items_arr| {
            items_arr
                .iter()
                .flat_map(|item_value| {
                    item_value.as_object().and_then(|item_obj| {
                        let path = item_obj
                            .get("path")
                            .and_then(|path_value| path_value.as_str());
                        let url = item_obj.get("url").and_then(|url_value| url_value.as_str());
                        path.zip(url)
                            .map(|(path, url)| (path.to_string(), url.to_string()))
                    })
                })
                .collect::<HashMap<String, String>>()
        })
        .ok_or(CircleCiError::JsonSchemaMismatch)
}

#[derive(Error, Debug)]
pub enum ParallelError<E: std::error::Error> {
    #[error("Join error: {0}")]
    JoinError(JoinError),
    #[error("Task error: {0}")]
    TaskError(#[from] E),
}

impl<E: std::error::Error + Send + Sync + 'static> Reject for ParallelError<E> {}

pub async fn parallel_map<T, I, F, O, V, E>(items: I, f: F) -> Result<Vec<V>, ParallelError<E>>
where
    T: Send + Sync + 'static,
    I: IntoIterator<Item = T>,
    F: Fn(T) -> O,
    O: Future<Output = Result<V, E>> + Send + Sync + 'static,
    V: Send + Sync + 'static,
    E: std::error::Error + Send + Sync + 'static,
{
    Ok(future::join_all(items.into_iter().map(|item| {
        let fut = f(item);
        tokio::spawn(async move { fut.await })
    }))
    .await
    .into_iter()
    .collect::<Result<Vec<_>, JoinError>>()
    .map_err(|e| ParallelError::JoinError(e))?
    .into_iter()
    .collect::<Result<Vec<_>, E>>()?)
}

pub async fn assemble(
    client: &Client,
    artifacts: HashMap<String, String>,
) -> Result<VerificationMetadata, ParallelError<reqwest::Error>> {
    let responses = parallel_map(
        vec![
            "git/repository.txt",
            "git/remote.txt",
            "git/branch.txt",
            "git/commit.txt",
        ],
        |path| {
            let url = &artifacts[path];
            client.get(url).send()
        },
    )
    .await?;
    let to_text = parallel_map(responses, |r| r.text()).await?;

    let (repository, remote, branch, commit) = match &to_text[..] {
        [a, b, c, d] => (a, b, c, d),
        _ => unreachable!(),
    };

    let code_url = (&artifacts["out/out.wasm"]).to_string();
    let wasm = client.get(&code_url).send().await?.bytes().await?;

    let code = wasm.as_ref().to_vec();
    let code_hash = CodeHash::hash_bytes(&code);
    Ok(VerificationMetadata {
        repo: repository.trim().to_string(),
        remote: remote.trim().to_string(),
        branch: branch.trim().to_string(),
        commit: commit.trim().to_string(),
        code_url,
        code_hash,
    })
}

#[derive(Debug)]
pub struct VerificationMetadata {
    pub repo: String,
    pub remote: String,
    pub branch: String,
    pub commit: String,
    pub code_url: String,
    pub code_hash: CodeHash,
}

'''
'''--- service/src/circleci/error.rs ---
use thiserror::Error;
use warp::reject::Reject;

#[derive(Error, Debug)]
pub enum CircleCiError {
    #[error("reqwest error: {0}")]
    ReqwestError(#[from] reqwest::Error),
    #[error("JSON did not match expected schema")]
    JsonSchemaMismatch,
}

impl Reject for CircleCiError {}

'''
'''--- service/src/circleci/mod.rs ---
pub mod client;
pub mod error;
pub mod signature;
pub mod webhook;

'''
'''--- service/src/circleci/signature.rs ---
/// https://circleci.com/docs/2.0/webhooks/#headers
use hex;
use hmac::{Hmac, Mac};
use sha2::Sha256;
use warp::{reject, Filter};

const SIGNATURE_VERSION: &'static str = "v1";
const SIGNATURE_HEADER: &'static str = "circleci-signature";

pub fn extract_compatible_signature(header: &str) -> Option<&str> {
    header
        .split(",")
        .find_map(|pair| match pair.split("=").collect::<Vec<&str>>()[..] {
            [v, sig] if v == SIGNATURE_VERSION => Some(sig),
            _ => None,
        })
}

pub fn verify_signature(secret: &str, signature: &str, body: &[u8]) -> bool {
    println!("Verifying signature");

    let mut h = Hmac::<Sha256>::new_from_slice(secret.as_bytes()).unwrap();
    h.update(body);
    h.verify(hex::decode(signature).unwrap().as_slice().into())
        .is_ok()
}

#[derive(Debug)]
struct InvalidSignature;
impl reject::Reject for InvalidSignature {}

#[derive(Debug)]
struct IncompatibleSignatureVersion;
impl reject::Reject for IncompatibleSignatureVersion {}

pub fn verify_filter(
    secret: String,
) -> impl Filter<Extract = (warp::hyper::body::Bytes,), Error = warp::Rejection> + Clone {
    warp::header::<String>(SIGNATURE_HEADER)
        .and(warp::body::bytes())
        .and_then(move |header: String, body: warp::hyper::body::Bytes| {
            let signature = extract_compatible_signature(&header);
            match signature {
                None => futures::future::err(reject::custom(IncompatibleSignatureVersion)),
                Some(signature) => {
                    if verify_signature(&secret, signature, &body) {
                        println!("Valid signature");
                        futures::future::ok(body)
                    } else {
                        println!("Invalid signature");
                        futures::future::err(reject::custom(InvalidSignature))
                    }
                }
            }
        })
}

'''
'''--- service/src/circleci/webhook.rs ---
use reqwest::Client;
use serde::{Deserialize, Serialize};
use thiserror::Error;
use warp::{reject::Reject, Rejection};

use super::client::request_job;

#[derive(Serialize, Deserialize)]
pub struct WebhookPayloadJob {
    pub name: String,
    pub status: String,
    pub number: u64,
}

#[derive(Serialize, Deserialize)]
pub struct JobCompletedWebhookPayload {
    pub job: WebhookPayloadJob,
}

#[derive(Debug, Error)]
pub enum WebhookError {
    #[error("Error parsing JSON body: {0}")]
    PayloadParseError(#[from] serde_json::Error),
}

impl Reject for WebhookError {}

pub async fn handler(
    client: Client,
    project_slug: String,
    body: warp::hyper::body::Bytes,
) -> Result<String, Rejection> {
    let payload = serde_json::from_slice::<JobCompletedWebhookPayload>(&body)
        .map_err(|e| WebhookError::from(e))?;
    let job_number = payload.job.number.to_string();
    println!("Webhook triggered for job {job_number}");
    let meta = request_job(&client, project_slug, job_number).await?;
    println!(
        "Webhook results:\n\tbranch: {}\n\tcommit: {}\n\tcode hash: {}\n\tcode url: {}",
        meta.branch, meta.commit, meta.code_hash, meta.code_url
    );
    Ok(format!("{}", meta.code_hash))
}

'''
'''--- service/src/contract_interaction/change.rs ---
use near_crypto::{InMemorySigner, Signer};
use near_jsonrpc_client::{methods, JsonRpcClient};

use near_primitives::{
    transaction::{Action, FunctionCallAction, Transaction},
    types::AccountId,
};

use super::{valid_for, wait_for_status};

pub async fn change(
    client: &JsonRpcClient,
    signer: &InMemorySigner,
    contract_id: &AccountId,
    method: &str,
    args: serde_json::Value,
    deposit: u128,
) -> Result<String, Box<dyn std::error::Error>> {
    let (nonce, block_hash) = valid_for(client, signer).await?;

    let tx = Transaction {
        signer_id: signer.account_id.clone(),
        public_key: signer.public_key.clone(),
        nonce: nonce + 1,
        receiver_id: contract_id.clone(),
        block_hash,
        actions: vec![Action::FunctionCall(FunctionCallAction {
            method_name: method.to_string(),
            args: args.to_string().into_bytes(),
            gas: 100_000_000_000_000, // 100 TGas
            deposit,
        })],
    };

    println!("Signing with {}", signer.public_key());
    let request = methods::broadcast_tx_async::RpcBroadcastTxAsyncRequest {
        signed_transaction: tx.sign(signer),
    };

    let tx_hash = client.call(request).await?;

    println!("Sent transaction {}", tx_hash);

    wait_for_status(client, &signer.account_id, tx_hash).await
}

'''
'''--- service/src/contract_interaction/mod.rs ---
use std::time;

use near_crypto::{InMemorySigner, Signer};
use near_jsonrpc_client::{
    methods::{
        self, broadcast_tx_commit::RpcTransactionError, query::RpcQueryRequest, tx::TransactionInfo, RpcHandlerError,
    },
    JsonRpcClient,
};
use near_jsonrpc_primitives::types::query::QueryResponseKind;

use near_primitives::{
    hash::CryptoHash,
    types::{AccountId, BlockReference},
    views::{FinalExecutionOutcomeView, FinalExecutionStatus, QueryRequest},
};
use thiserror::Error;

pub mod change;
pub mod view;
pub mod watch;

#[derive(Error, Debug)]
pub enum TransactionStatusError {
    #[error("JSON RPC error: {0}")]
    JsonRpcError(#[from] near_jsonrpc_client::errors::JsonRpcError<RpcTransactionError>),
    // #[error("RPC Handler Error: {0}")]
    // RpcHandlerError(#[from] Box<dyn RpcHandlerError>),
    #[error("Execution error: {0}")]
    ExecutionError(near_primitives::errors::TxExecutionError),
}

pub async fn valid_for(
    client: &JsonRpcClient,
    signer: &InMemorySigner,
) -> Result<(u64, CryptoHash), Box<dyn std::error::Error>> {
    let res = client
        .call(RpcQueryRequest {
            block_reference: BlockReference::latest(),
            request: QueryRequest::ViewAccessKey {
                account_id: signer.account_id.clone(),
                public_key: signer.public_key(),
            },
        })
        .await?;

    match res.kind {
        QueryResponseKind::AccessKey(key) => Ok((key.nonce, res.block_hash)),
        _ => Err("Failed to parse response")?,
    }
}

pub async fn wait_for_status(
    client: &JsonRpcClient,
    account_id: &AccountId,
    hash: CryptoHash,
) -> Result<String, Box<dyn std::error::Error>> {
    loop {
        let response = client
            .call(methods::tx::RpcTransactionStatusRequest {
                transaction_info: TransactionInfo::TransactionId {
                    hash,
                    account_id: account_id.clone(),
                },
            })
            .await;

        match response {
            Err(err) => match err.handler_error()? {
                methods::tx::RpcTransactionError::UnknownTransaction { .. } => {
                    tokio::time::sleep(time::Duration::from_secs(2)).await;
                    continue;
                }
                err => Err(err)?,
            },
            Ok(FinalExecutionOutcomeView {
                status: FinalExecutionStatus::Failure(e),
                ..
            }) => {
                return Err(Box::new(TransactionStatusError::ExecutionError(e)));
            }
            Ok(FinalExecutionOutcomeView {
                status: FinalExecutionStatus::SuccessValue(s),
                ..
            }) => {
                return Ok(s);
            }
            _ => {
                // Transaction is currently executing
                tokio::time::sleep(time::Duration::from_secs(2)).await;
                continue;
            }
        }
    }
}

#[derive(Debug, Error)]
pub enum ContractInteractionError {
    #[error("Incompatible response type from RPC {0:?}")]
    IncompatibleRpcResponseType(QueryResponseKind),
}

#[cfg(test)]
mod tests {
    use near_crypto::{KeyType, SecretKey};

    #[test]
    fn generate_ed25519_key() {
        let k = SecretKey::from_random(KeyType::ED25519);
        println!("Secret key: {}", k.to_string());
        println!("Verify key: {}", k.public_key().to_string());
    }
}

'''
'''--- service/src/contract_interaction/view.rs ---
use near_jsonrpc_client::{methods, JsonRpcClient};
use near_jsonrpc_primitives::types::query::QueryResponseKind;
use near_primitives::types::{AccountId, BlockReference, Finality, FunctionArgs};
use near_primitives::views::QueryRequest;

use serde_json::from_slice;

use crate::network_config::NetworkConfig;

use super::ContractInteractionError;

pub async fn view(
    network_config: &NetworkConfig,
    contract_id: AccountId,
    method_name: String,
    args: &serde_json::Value,
) -> Result<serde_json::Value, Box<dyn std::error::Error>> {
    let client = JsonRpcClient::connect(&network_config.node_url);

    let request = methods::query::RpcQueryRequest {
        block_reference: BlockReference::Finality(Finality::Final),
        request: QueryRequest::CallFunction {
            account_id: contract_id,
            method_name,
            args: FunctionArgs::from(args.to_string().into_bytes()),
        },
    };

    let response = client.call(request).await?;

    if let QueryResponseKind::CallResult(result) = response.kind {
        from_slice(&result.result[..]).map_err(|e| Box::new(e) as Box<dyn std::error::Error>)
    } else {
        Err(Box::new(
            ContractInteractionError::IncompatibleRpcResponseType(response.kind),
        ))
    }
}

'''
'''--- service/src/contract_interaction/watch.rs ---
use model::sequential_id::SequentialId;
use near_primitives::types::AccountId;

use serde::de::DeserializeOwned;
use tokio::sync::mpsc::{self, Receiver};
use tokio::time;

use crate::network_config::NetworkConfig;

use super::view::view;

pub fn list<T, U>(
    network_config: NetworkConfig,
    contract_id: AccountId,
    method_name: String,
    args: serde_json::Value,
    duration: time::Duration,
) -> Receiver<T>
where
    T: SequentialId<U> + DeserializeOwned + Send + 'static,
    U: Ord + Send + 'static,
{
    let (tx, rx) = mpsc::channel::<T>(16);

    tokio::spawn(async move {
        let mut interval = time::interval(duration);
        // To ensure unique items are delivered from array, keep track of the
        // "largest" item delivered thus far.
        // Assumes that new items will be "larger" than old items.
        let mut largest_overall: Option<U> = None;
        loop {
            interval.tick().await;
            let mut largest_in_round: Option<U> = None;
            let items = view(
                &network_config,
                contract_id.clone(),
                method_name.clone(),
                &args,
            )
            .await
            .ok()
            .as_ref()
            .and_then(|view| view.as_array())
            .map(|arr| {
                arr.into_iter()
                    .map(|item| serde_json::from_value::<T>(item.clone()))
                    .filter_map(|item| match item {
                        Err(ref e) => {
                            // May be intentional (e.g. filter by parse-ability)
                            println!("Error parsing item: {}", e);
                            None
                        }
                        Ok(i) => Some(i),
                    })
                    .filter(|item| {
                        // Only take items that are "larger" than those we've seen already
                        largest_overall
                            .as_ref()
                            .map_or(true, |largest_overall| &item.seq_id() > largest_overall)
                    })
                    .collect::<Vec<T>>()
            });

            if let Some(items) = items {
                for item in items {
                    // Update largest_in_round for every item
                    if let Some(ref l) = largest_in_round {
                        if &item.seq_id() > l {
                            largest_in_round = Some(item.seq_id());
                        }
                    } else {
                        largest_in_round = Some(item.seq_id());
                    }

                    match tx.send(item).await {
                        Ok(()) => {}
                        Err(e) => println!("Error sending across channel: {}", e),
                    }
                }
            }

            // Only update largest_overall after processing each new item
            if largest_in_round.is_some() {
                largest_overall = largest_in_round;
            }
        }
    });

    rx
}

'''
'''--- service/src/env.rs ---
#[allow(dead_code)]
pub const PORT: &'static str = "PORT";
#[allow(dead_code)]
pub const CIRCLECI_WEBHOOK_SECRET: &'static str = "CIRCLECI_WEBHOOK_SECRET";
#[allow(dead_code)]
pub const CIRCLECI_PROJECT_SLUG: &'static str = "CIRCLECI_PROJECT_SLUG";
#[allow(dead_code)]
pub const CIRCLECI_API_KEY: &'static str = "CIRCLECI_API_KEY";
#[allow(dead_code)]
pub const CIRCLECI_JOB_NAME: &'static str = "CIRCLECI_JOB_NAME";
#[allow(dead_code)]
pub const NETWORK_CONFIG: &'static str = "NETWORK_CONFIG";
#[allow(dead_code)]
pub const CONTRACT_ID: &'static str = "CONTRACT_ID";
#[allow(dead_code)]
pub const ACCOUNT_ID: &'static str = "ACCOUNT_ID";
#[allow(dead_code)]
pub const SECRET_KEY: &'static str = "SECRET_KEY";
#[allow(dead_code)]
pub const REPOSITORY_PATH: &'static str = "SECRET_KEY";

'''
'''--- service/src/main.rs ---
use dotenv;
use near_jsonrpc_client::header::HeaderValue;
use reqwest::{header::HeaderMap, Client};
use std::{convert::Infallible, env::var, str::FromStr};
use tracing_subscriber::fmt::format::FmtSpan;
use warp::Filter;

use crate::{
    circleci::{
        signature::verify_filter,
        webhook::{self, JobCompletedWebhookPayload},
    },
    env::CIRCLECI_WEBHOOK_SECRET,
};

mod circleci;
mod contract_interaction;
mod env;
mod network_config;
mod repository;

const TOKEN_HEADER: &'static str = "Circle-Token";

fn with<T: Clone + Send>(w: T) -> impl Filter<Extract = (T,), Error = Infallible> + Clone {
    warp::any().map(move || w.clone())
}

fn create_circleci_reqwest_client() -> Client {
    let api_key = std::env::var(env::CIRCLECI_API_KEY).unwrap();

    let mut headers = HeaderMap::new();
    let mut api_key_header_value = HeaderValue::from_str(&api_key).unwrap();
    api_key_header_value.set_sensitive(true);
    headers.insert(TOKEN_HEADER, api_key_header_value);
    let client = reqwest::Client::builder()
        .default_headers(headers)
        .build()
        .unwrap();

    client
}

#[tokio::main]
async fn main() {
    if let Err(_) = dotenv::dotenv() {
        println!("No .env file found.");
    }

    let network_config_path = std::env::var(env::NETWORK_CONFIG).unwrap();

    let network_config = network_config::load(&network_config_path);

    println!(
        "Connecting to {} at {}...",
        network_config.network_id, network_config.node_url
    );

    // let rpc_client = JsonRpcClient::connect(network_config.node_url);
    // let account_id: AccountId = std::env::var(env::ACCOUNT_ID).unwrap().parse().unwrap();
    // let contract_id: AccountId = std::env::var(env::CONTRACT_ID).unwrap().parse().unwrap();
    // let secret_key = SecretKey::from_str(&std::env::var(env::SECRET_KEY).unwrap()).unwrap();
    // let signer = InMemorySigner::from_secret_key(account_id, secret_key);

    // let value = change(
    //     &rpc_client,
    //     &signer,
    //     &contract_id,
    //     "verification_failure",
    //     json!({"id":"0"}),
    //     1,
    // )
    // .await;

    // println!("Value: {:?}", value);

    let project_slug = std::env::var(env::CIRCLECI_PROJECT_SLUG).unwrap();

    let circleci_reqwest_client = create_circleci_reqwest_client();

    let filter = std::env::var("RUST_LOG").unwrap_or_else(|_| "tracing=info,warp=debug".to_owned());

    tracing_subscriber::fmt()
        .with_env_filter(filter)
        .with_span_events(FmtSpan::CLOSE)
        .init();

    let circleci_webhook_secret = var(CIRCLECI_WEBHOOK_SECRET).unwrap();

    let guarded = warp::path!("webhook")
        .and(warp::body::content_length_limit(1024 * 32 /* 32kb */))
        .and(with(circleci_reqwest_client))
        .and(with(project_slug))
        .and(verify_filter(circleci_webhook_secret))
        .and_then(webhook::handler);

    let routes = guarded.with(warp::trace::request());

    warp::serve(routes)
        .run((
            [127, 0, 0, 1],
            std::env::var(env::PORT)
                .ok()
                .and_then(|s| u16::from_str(&s).ok())
                .unwrap_or(8000),
        ))
        .await;
}

'''
'''--- service/src/network_config.rs ---
use std::fs;

use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct NetworkConfig {
    pub network_id: String,
    pub node_url: String,
    pub archival_url: String,
    pub wallet_url: String,
    pub helper_url: String,
    pub explorer_url: String,
}

pub fn load(path: &str) -> NetworkConfig {
    let handle = fs::File::open(path).expect(&format!(
        "FATAL: Could not load network config path: {path}"
    ));
    let reader = std::io::BufReader::new(handle);

    serde_json::from_reader(reader).expect("FATAL: Could not parse network config file")
}

'''
'''--- service/src/repository/mod.rs ---
// https://siciarz.net/24-days-rust-git2/

use git2::{Direction, Repository, Signature};
use std::path::Path;

fn push(repo: &Repository) -> Result<(), git2::Error> {
    let mut remote = repo.find_remote("origin").expect("Repository does not have remote 'origin' configured.");
    remote.connect(Direction::Push)?;
    remote.push(&["refs/heads/main:refs/heads/main"], None)
}

pub fn update(
    repo_path: &Path,
    target_repo: &str,
    checkout: &str,
    path: &str,
) -> Result<(), git2::Error> {
    let repo_handle = Repository::open(repo_path)?;
    let mut index = repo_handle.index()?;

    let pairs = vec![
        ("repository.txt", target_repo),
        ("checkout.txt", checkout),
        ("path.txt", path),
    ];

    println!("Writing output to repository...");

    for (path, value) in pairs {
        std::fs::write(repo_path.join(path), value).unwrap();
        index.add_path(Path::new(path))?;
    }

    println!("Done writing output.");

    let oid = index.write_tree()?;

    let signature = Signature::now("Contract Registry Bot", "contract-registry@stats.gallery")?;

    let parent_commit = repo_handle.head()?.resolve()?.peel_to_commit()?;

    let tree = repo_handle.find_tree(oid)?;

    let commit_oid = repo_handle.commit(
        Some("HEAD"),
        &signature,
        &signature,
        &format!("Automated update\n\tTarget repository: {target_repo}\n\tCheckout: {checkout}\n\tPath: {path}"),
        &tree,
        &[&parent_commit],
    )?;

    println!("Commit hash: {commit_oid:?}");

    println!("Pushing...");

    push(&repo_handle)?;

    println!("Done.");

    Ok(())
}

#[cfg(test)]
mod tests {
    use std::path::Path;

    use super::update;

    #[test]
    fn test() {
        println!("running...");
        println!(
            "{:?}",
            update(
                &Path::new("C:/Users/Jacob/Projects/contract-registry-ci-test"),
                "https://github.com/NEAR-Edu/stats.gallery-dapp.git",
                "main",
                "",
            )
        );
    }
}

'''