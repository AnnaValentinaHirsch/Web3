*GitHub Repository "ggichuru/fungible_token_near"*

'''--- .gitpod.yml ---
tasks:
  - init: npm dev
    command: npm run dev
ports:
  - port: 1234
    onOpen: open-browser

'''
'''--- README.md ---
fungible_token
==============

This app was initialized with [create-near-app]

NOTES
=====

This is fungible token implementation with JSON serialization

- The maximum balance value is limited by U128 (2**128-1)
- JSON calls should pass U128 as a base-10 string. E.g "100".
- The contract optimizes the inner trie structure by hashing accound IDs. It will prevent some abuse of deep tries.
- The contract tracks the change in storage before and after the call. If the storage increases, the contract requires the caller to attach enough deposit to the function call to cover the storage cost. 
This is done to prvent a DOS attack on the contract by taking all available storage.
If the storage decreases, the contract will issue a refund for the cost of the released storage.
The unused tokens from the attached deposit are also refunded, so it's safe to attach more deposit than required.
- To prevent the deployed contract from being modified or deleted, it should not have any access keys on its account. 

Quick Start
===========

If you haven't installed dependencies during setup:

    npm run deps-install

Build and deploy your contract to TestNet with a temporary dev account:

    npm run deploy

Test your contract:

    npm test

If you have a frontend, run `npm start`. This will run a dev server.

Exploring The Code
==================

1. The smart-contract code lives in the `/contract` folder. See the README there for
   more info. In blockchain apps the smart contract is the "backend" of your app.
2. The frontend code lives in the `/frontend` folder. `/frontend/index.html` is a great
   place to start exploring. Note that it loads in `/frontend/index.js`,
   this is your entrypoint to learn how the frontend connects to the NEAR blockchain.
3. Test your contract: `npm test`, this will run the tests in `integration-tests` directory.

Deploy
======

Every smart contract in NEAR has its [own associated account][NEAR accounts].
When you run `npm run deploy`, your smart contract gets deployed to the live NEAR TestNet with a temporary dev account.
When you're ready to make it permanent, here's how:

Step 0: Install near-cli (optional)
-------------------------------------

[near-cli] is a command line interface (CLI) for interacting with the NEAR blockchain. It was installed to the local `node_modules` folder when you ran `npm install`, but for best ergonomics you may want to install it globally:

    npm install --global near-cli

Or, if you'd rather use the locally-installed version, you can prefix all `near` commands with `npx`

Ensure that it's installed with `near --version` (or `npx near --version`)

Step 1: Create an account for the contract
------------------------------------------

Each account on NEAR can have at most one contract deployed to it. If you've already created an account such as `your-name.testnet`, you can deploy your contract to `near-blank-project.your-name.testnet`. Assuming you've already created an account on [NEAR Wallet], here's how to create `near-blank-project.your-name.testnet`:

1. Authorize NEAR CLI, following the commands it gives you:

      near login

2. Create a subaccount (replace `YOUR-NAME` below with your actual account name):

      near create-account near-blank-project.YOUR-NAME.testnet --masterAccount YOUR-NAME.testnet

Step 2: deploy the contract
---------------------------

Use the CLI to deploy the contract to TestNet with your account ID.
Replace `PATH_TO_WASM_FILE` with the `wasm` that was generated in `contract` build directory.

    near deploy --accountId near-blank-project.YOUR-NAME.testnet --wasmFile PATH_TO_WASM_FILE

Step 3: set contract name in your frontend code
-----------------------------------------------

Modify the line in `src/config.js` that sets the account name of the contract. Set it to the account id you used above.

    const CONTRACT_NAME = process.env.CONTRACT_NAME || 'near-blank-project.YOUR-NAME.testnet'

Troubleshooting
===============

On Windows, if you're seeing an error containing `EPERM` it may be related to spaces in your path. Please see [this issue](https://github.com/zkat/npx/issues/209) for more details.

  [create-near-app]: https://github.com/near/create-near-app
  [Node.js]: https://nodejs.org/en/download/package-manager/
  [jest]: https://jestjs.io/
  [NEAR accounts]: https://docs.near.org/concepts/basics/account
  [NEAR Wallet]: https://wallet.testnet.near.org/
  [near-cli]: https://github.com/near/near-cli
  [gh-pages]: https://github.com/tschaub/gh-pages

'''
'''--- contract/Cargo.toml ---
[package]
name = "fungible-token"
version = "1.0.0"
authors = ["Near Inc <hello@near.org>"]
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0"
near-contract-standards = "4.0.0"
uint = { version = "0.9.3", default-features = false }

[profile.release]
codegen-units = 1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[workspace]
members = []

'''
'''--- contract/README.md ---
Hello NEAR!
=================================

A [smart contract] written in [Rust] for an app initialized with [create-near-app]

Quick Start
===========

Before you compile this code, you will need to install Rust with [correct target]

Exploring The Code
==================

1. The main smart contract code lives in `src/lib.rs`.
2. There are two functions to the smart contract: `get_greeting` and `set_greeting`.
3. Tests: You can run smart contract tests with the `cargo test`.

  [smart contract]: https://docs.near.org/develop/welcome
  [Rust]: https://www.rust-lang.org/
  [create-near-app]: https://github.com/near/create-near-app
  [correct target]: https://docs.near.org/develop/prerequisites#rust-and-wasm
  [cargo]: https://doc.rust-lang.org/book/ch01-03-hello-cargo.html

'''
'''--- contract/neardev/dev-account.env ---
CONTRACT_NAME=dev-1661782661293-11541106304415
'''
'''--- contract/src/lib.rs ---
use near_contract_standards::fungible_token::metadata::{
    FungibleTokenMetadata, FungibleTokenMetadataProvider, FT_METADATA_SPEC,
};
use near_contract_standards::fungible_token::FungibleToken;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LazyOption;
use near_sdk::json_types::U128;
use near_sdk::{env, log, near_bindgen, AccountId, Balance, PanicOnDefault, PromiseOrValue};

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    token: FungibleToken,
    metadata: LazyOption<FungibleTokenMetadata>,
}

const DATA_IMAGE_SVG_NEAR_ICON: &str = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 288 288'%3E%3Cg id='l' data-name='l'%3E%3Cpath d='M187.58,79.81l-30.1,44.69a3.2,3.2,0,0,0,4.75,4.2L191.86,103a1.2,1.2,0,0,1,2,.91v80.46a1.2,1.2,0,0,1-2.12.77L102.18,77.93A15.35,15.35,0,0,0,90.47,72.5H87.34A15.34,15.34,0,0,0,72,87.84V201.16A15.34,15.34,0,0,0,87.34,216.5h0a15.35,15.35,0,0,0,13.08-7.31l30.1-44.69a3.2,3.2,0,0,0-4.75-4.2L96.14,186a1.2,1.2,0,0,1-2-.91V104.61a1.2,1.2,0,0,1,2.12-.77l89.55,107.23a15.35,15.35,0,0,0,11.71,5.43h3.13A15.34,15.34,0,0,0,216,201.16V87.84A15.34,15.34,0,0,0,200.66,72.5h0A15.35,15.35,0,0,0,187.58,79.81Z'/%3E%3C/g%3E%3C/svg%3E";

#[near_bindgen]
impl Contract {
    ///
    /// Initializes the contract with the given total supply owned by the given `owner_id` with default metadata
    ///
    /// <this is for example purposes only>
    #[init]
    pub fn new_default_meta(owner_id: AccountId, total_supply: U128) -> Self {
        Self::new(
            owner_id,
            total_supply,
            FungibleTokenMetadata {
                spec: FT_METADATA_SPEC.to_string(),
                name: "GG Wa NGENI".to_string(),
                symbol: "GWN".to_string(),
                icon: Some(DATA_IMAGE_SVG_NEAR_ICON.to_string()),
                reference: None,
                reference_hash: None,
                decimals: 24,
            },
        )
    }

    ///
    /// initialize the contract with the given total supply owned by the given `owner_id' wihth the given ft metadata
    ///
    #[init]
    pub fn new(owner_id: AccountId, total_supply: U128, metadata: FungibleTokenMetadata) -> Self {
        assert!(!env::state_exists(), "Already initialized");
        metadata.assert_valid();

        let mut this = Self {
            token: FungibleToken::new(b"a".to_vec()),
            metadata: LazyOption::new(b"m".to_vec(), Some(&metadata)),
        };

        this.token.internal_register_account(&owner_id);
        this.token.internal_deposit(&owner_id, total_supply.into());

        near_contract_standards::fungible_token::events::FtMint {
            owner_id: &owner_id,
            amount: &total_supply,
            memo: Some("Initial tokens supply is minted"),
        }
        .emit();

        this
    }

    fn on_account_closed(&mut self, account_id: AccountId, balance: Balance) {
        log!("Closed @{} with {}.", account_id, balance);
    }

    fn on_tokens_burned(&mut self, account_id: AccountId, balance: Balance) {
        log!("Account @{} burned {}", account_id, balance);
    }
}

near_contract_standards::impl_fungible_token_core!(Contract, token, on_tokens_burned);
near_contract_standards::impl_fungible_token_storage!(Contract, token, on_account_closed);

#[near_bindgen]
impl FungibleTokenMetadataProvider for Contract {
    fn ft_metadata(&self) -> FungibleTokenMetadata {
        self.metadata.get().unwrap()
    }
}

#[cfg(all(test, not(target_arch = "wasm32")))]
mod tests {
    use near_sdk::test_utils::{accounts, VMContextBuilder};
    use near_sdk::{testing_env, Balance};

    use super::*;

    const TOTAL_SUPPLY: Balance = 1_000_000_000_000_000;

    fn get_context(predecessor_account_id: AccountId) -> VMContextBuilder {
        let mut builder = VMContextBuilder::new();

        builder
            .current_account_id(accounts(0))
            .signer_account_id(predecessor_account_id.clone())
            .predecessor_account_id(predecessor_account_id);

        builder
    }

    #[test]
    fn test_new() {
        let mut context = get_context(accounts(1));
        testing_env!(context.build());

        let contract = Contract::new_default_meta(accounts(1).into(), TOTAL_SUPPLY.into());

        testing_env!(context.is_view(true).build());

        assert_eq!(contract.ft_total_supply().0, TOTAL_SUPPLY);
        assert_eq!(contract.ft_balance_of(accounts(1)).0, TOTAL_SUPPLY);
    }

    #[test]
    #[should_panic(expected = "The contract is not initialized")]
    fn test_default() {
        let context = get_context(accounts(1));
        testing_env!(context.build());
        let _contract = Contract::default();
    }

    #[test]
    fn test_transfer() {
        let mut context = get_context(accounts(2));
        testing_env!(context.build());

        let mut contract = Contract::new_default_meta(accounts(2), TOTAL_SUPPLY.into());
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(contract.storage_balance_bounds().min.into())
            .predecessor_account_id(accounts(1))
            .build());

        // Paying for account registration, aka deposit
        contract.storage_deposit(None, None);

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(1)
            .predecessor_account_id(accounts(2))
            .build());

        let transfer_amount = TOTAL_SUPPLY / 3;

        contract.ft_transfer(accounts(1), transfer_amount.into(), None);

        testing_env!(context
            .storage_usage(env::storage_usage())
            .account_balance(env::account_balance())
            .is_view(true)
            .attached_deposit(0)
            .build());

        assert_eq!(contract.ft_balance_of(accounts(2)).0, (TOTAL_SUPPLY - transfer_amount));
        assert_eq!(contract.ft_balance_of(accounts(1)).0, transfer_amount);
    }
}

'''
'''--- integration-tests/Cargo.toml ---
[package]
name = "integration-tests"
version = "1.0.0"
publish = false
edition = "2018"

[dev-dependencies]
near-sdk = "4.0.0"
anyhow = "1.0"
borsh = "0.9"
maplit = "1.0"
near-units = "0.2.0"
# arbitrary_precision enabled for u128 types that workspaces requires for Balance types
serde_json = { version = "1.0", features = ["arbitrary_precision"] }
tokio = { version = "1.18.1", features = ["full"] }
tracing = "0.1"
tracing-subscriber = { version = "0.3.11", features = ["env-filter"] }
workspaces = "0.4.0"
pkg-config = "0.3.1"

[[example]]
name = "integration-tests"
path = "src/tests.rs"

'''
'''--- integration-tests/src/tests.rs ---
use anyhow::Ok;
use near_sdk::json_types::U128;
use near_units::{parse_gas, parse_near};
use serde_json::json;
use workspaces::prelude::*;
use workspaces::result::CallExecutionDetails;
use workspaces::{network::Sandbox, Account, Contract, Worker};

const DEFI_WASM_FILEPATH: &str =
    "../../contract/target/wasm32-unknown-unknown/release/fungible_token.wasm";

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // initiate environment
    let worker = workspaces::sandbox().await?;

    //deploy contracts
    let token_wasm = std::fs::read(DEFI_WASM_FILEPATH)?;
    let token_contract = worker.dev_deploy(&token_wasm).await?;

    // Create Accounts
    let owner = worker.root_account().unwrap();
    let jay = owner
        .create_subaccount(&worker, "jay")
        .initial_balance(parse_near!("30 N"))
        .transact()
        .await?
        .into_result()?;

    let george = owner
        .create_subaccount(&worker, "george")
        .initial_balance(parse_near!("30 N"))
        .transact()
        .await?
        .into_result()?;

    let dennoh = owner
        .create_subaccount(&worker, "dennoh")
        .initial_balance(parse_near!("30 N"))
        .transact()
        .await?
        .into_result()?;

    let gichuru = owner
        .create_subaccount(&worker, "gichuru")
        .initial_balance(parse_near!("30 N"))
        .transact()
        .await?
        .into_result()?;

    // Initialize Contracts
    token_contract
        .call(&worker, "new_default_meta")
        .args_json(serde_json::json!({
            "owner_id": owner.id(),
            "total_supply": parse_near!("1,000,000,000 N").to_string(),
        }))?
        .transact()
        .await?;

    //begin test
    //TODO: ADD tests here
    test_total_supply(&owner, &token_contract, &worker).await?;
    test_simple_transfer(&owner, &jay, &token_contract, &worker).await?;

    Ok(())
}

async fn test_total_supply(
    owner: &Account,
    contract: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    let initial_bal = U128::from(parse_near!("1,000,000,000 N"));
    let res: U128 = owner
        .call(&worker, contract.id(), "ft_total_supply")
        .args_json(json!({}))?
        .transact()
        .await?
        .json()?;

    assert_eq!(res, initial_bal);
    println!(" Passed test_total_supply");
    Ok(())
}

async fn test_simple_transfer(
    owner: &Account,
    user: &Account,
    contract: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    let transfer_amount = U128::from(parse_near!("1,000 N"));

    // register user
    user.call(&worker, contract.id(), "storage_deposit")
        .args_json(serde_json::json!({
            "account_id": user.id(),
        }))?
        .deposit(parse_near!("0.008 N"))
        .transact()
        .await?;

    // Transfer fungible token
    owner
        .call(&worker, contract.id(), "ft_transfer")
        .args_json(serde_json::json!({
            "receiver_id": user.id(),
            "amount": transfer_amount
        }))?
        .deposit(1)
        .transact()
        .await?;

    let root_balance: U128 = owner
        .call(&worker, contract.id(), "ft_balance_of")
        .args_json(serde_json::json!({
            "account_id": owner.id()
        }))?
        .transact()
        .await?
        .json()?;

    let jay_balance: U128 = owner
        .call(&worker, contract.id(), "ft_balance_of")
        .args_json(serde_json::json!({
            "account_id": user.id()
        }))?
        .transact()
        .await?
        .json()?;

    assert_eq!(root_balance, U128::from(parse_near!("999,999,000 N")));
    assert_eq!(jay_balance, transfer_amount);

    println!("Passed :white_check_mark: test_simple_transfer");

    Ok(())
}

'''
'''--- package-lock.json ---
{
  "name": "fungible_token",
  "version": "1.0.0",
  "lockfileVersion": 2,
  "requires": true,
  "packages": {
    "": {
      "name": "fungible_token",
      "version": "1.0.0",
      "license": "(MIT AND Apache-2.0)",
      "devDependencies": {
        "near-cli": "^1.0.0"
      }
    },
    "node_modules/near-cli": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/near-cli/-/near-cli-1.0.0.tgz",
      "integrity": "sha512-Ruy/8Ql7eno8eKfiFfyNiF3G73k0j6BsKi3++AHcI2kw1IY9BRN2B7l/+PLsqTgOz/sNVTMIKOLaOWMVrsG8eg==",
      "dev": true
    }
  },
  "dependencies": {
    "near-cli": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/near-cli/-/near-cli-1.0.0.tgz",
      "integrity": "sha512-Ruy/8Ql7eno8eKfiFfyNiF3G73k0j6BsKi3++AHcI2kw1IY9BRN2B7l/+PLsqTgOz/sNVTMIKOLaOWMVrsG8eg==",
      "dev": true
    }
  }
}

'''
'''--- package.json ---
{
  "name": "fungible_token",
  "version": "1.0.0",
  "license": "(MIT AND Apache-2.0)",
  "scripts": {
    "deploy": "npm run build:contract && cd contract && near deploy --accountId sub2.ggwangeni.testnet --wasmFile ./target/wasm32-unknown-unknown/release/fungible_token.wasm",
    "deploy:dev": "npm run build:contract && cd contract && near dev-deploy --wasmFile ./target/wasm32-unknown-unknown/release/fungible_token.wasm",
    "build": "npm run build:contract",
    "build:contract": "cd contract && rustup target add wasm32-unknown-unknown && cargo build --all --target wasm32-unknown-unknown --release",
    "test": "npm run test:unit && npm run test:integration",
    "test:unit": "cd contract && cargo test",
    "test:integration": "npm run build:contract && cd integration-tests && cargo run --example integration-tests \"../contract/target/wasm32-unknown-unknown/release/fungible_token.wasm\"",
    "deps-install": "npm install",
    "call:token": "near call $ID new '{'owner_id': '$ID', 'total_supply': '1000000000000000', 'metadata': { 'spec': 'ft-1.0.0', 'name': 'GG Wa ngeni Token', 'symbol': 'GWNT', 'decimals': 8 }}' --accountId $ID"
  },
  "devDependencies": {
    "near-cli": "^1.0.0"
  }
}
'''
'''--- rustfmt.toml ---
use_small_heuristics = "Max"

'''
'''--- scripts/build.bat ---
@echo off

title FT build
cd ..
cargo build --all --target wasm32-unknown-unknown --release
xcopy %CD%\target\wasm32-unknown-unknown\release\*.wasm %CD%\res /Y
pause
'''
'''--- scripts/build.sh ---
#!/bin/bash
set -e
cd "`dirname $0`"/../contract
cargo build --all --target wasm32-unknown-unknown --release
cd ..
cp contract/target/wasm32-unknown-unknown/rlease/*.wasm ./res/
'''