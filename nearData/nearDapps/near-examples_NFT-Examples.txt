*GitHub Repository "near-examples/NFT-Examples"*

'''--- NFT-example/.github/dependabot.yml ---
version: 2
updates:
- package-ecosystem: npm
  directory: "/"
  schedule:
    interval: daily
  open-pull-requests-limit: 10
- package-ecosystem: cargo
  directory: "/contracts/rust"
  schedule:
    interval: daily
  open-pull-requests-limit: 10
  ignore:
  - dependency-name: near-sdk
    versions:
    - 3.0.1

'''
'''--- NFT-example/.github/scripts/readme-quick-deploy.sh ---
#!/bin/bash
echo ==== Quick Deploy ====
TEXT=$(printf 'y\n' | near dev-deploy --wasmFile res/non_fungible_token.wasm)
if [[ ! "$TEXT" =~ .*"Done deploying to".* ]]; then 
    echo -e "\033[0;31m FAIL \033[0m"
    exit 1 
else 
    echo -e "\033[0;32m SUCCESS \033[0m"
fi

echo ==== Set dev account env variable ====
source neardev/dev-account.env
TEXT=$(echo $CONTRACT_NAME)
if [[ ! "$TEXT" =~ .*"dev-".* ]]; then 
    echo -e "\033[0;31m FAIL \033[0m"
    exit 1 
else 
    echo -e "\033[0;32m SUCCESS \033[0m"
fi

echo ==== Initialize contract using the new method ====
TEXT=$(near call $CONTRACT_NAME new_default_meta '{"owner_id": "'$CONTRACT_NAME'"}' --accountId $CONTRACT_NAME)
if [[ ! "$TEXT" =~ .*"To see the transaction in the transaction explorer".* ]]; then 
    echo -e "\033[0;31m FAIL \033[0m"
    exit 1 
else 
    echo -e "\033[0;32m SUCCESS \033[0m"
fi

echo ==== View contract metadata ====
TEXT=$(near view $CONTRACT_NAME nft_metadata)
if [[ ! "$TEXT" =~ .*"Example NEAR non-fungible token".* ]]; then 
    echo -e "\033[0;31m FAIL \033[0m"
    exit 1 
else 
    echo -e "\033[0;32m SUCCESS \033[0m"
fi

echo ==== Mint NFT ==== 
TEXT=$(near call $CONTRACT_NAME nft_mint '{"token_id": "0", "receiver_id": "'$CONTRACT_NAME'", "token_metadata": { "title": "Olympus Mons", "description": "Tallest mountain in charted solar system", "media": "https://upload.wikimedia.org/wikipedia/commons/thumb/0/00/Olympus_Mons_alt.jpg/1024px-Olympus_Mons_alt.jpg", "copies": 1}}' --accountId $CONTRACT_NAME --deposit 0.1)
if [[ ! "$TEXT" =~ .*"To see the transaction in the transaction explorer, please open this url in your browser".* ]]; then
    echo -e "\033[0;31m FAIL \033[0m"
    exit 1 
else 
    echo -e "\033[0;32m SUCCESS \033[0m"
fi

echo ==== Create Sub Account ====
TEXT=$(near create-account alice.$CONTRACT_NAME --masterAccount $CONTRACT_NAME --initialBalance 10)
if [[ ! "$TEXT" =~ .*"Account alice.$CONTRACT_NAME for network".* ]]; then
    echo -e "\033[0;31m FAIL \033[0m"
    exit 1 
else 
    echo -e "\033[0;32m SUCCESS \033[0m"
fi

echo ==== Check Sub Account for Tokens ====
TEXT=$(near view $CONTRACT_NAME nft_tokens_for_owner '{"account_id": "'alice.$CONTRACT_NAME'"}')
if [[ ! "$TEXT" =~ .*"[]".* ]]; then
    echo -e "\033[0;31m FAIL \033[0m"
    exit 1 
else 
    echo -e "\033[0;32m SUCCESS \033[0m"
fi

echo ==== Transfer NFT ====
TEXT=$(near call $CONTRACT_NAME nft_transfer '{"token_id": "0", "receiver_id": "alice.'$CONTRACT_NAME'", "memo": "transfer ownership"}' --accountId $CONTRACT_NAME --depositYocto 1)
if [[ ! "$TEXT" =~ .*"To see the transaction in the transaction explorer, please open this url in your browser".* ]]; then
    echo -e "\033[0;31m FAIL \033[0m"
    exit 1 
else 
    echo -e "\033[0;32m SUCCESS \033[0m"
fi

'''
'''--- NFT-example/.github/workflows/readme-ci.yml ---
name: Readme CI
on:
  repository_dispatch:
    types: [tests-report]
  push:
jobs:
  readme-ci:
    strategy:
      matrix:
        platform: [ubuntu-latest] # mac-os lags out
    runs-on: ${{ matrix.platform }}
    steps:
      - name: Checkout branch
        uses: actions/checkout@v2
      - name: Install Node
        uses: actions/setup-node@v2
      - name: Install Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          target: wasm32-unknown-unknown
      - name: Install NEAR CLI
        run: npm install near-cli -g
      - name: Building this contract
        run: bash ./scripts/build.sh
      - name: Run Readme Quick Deploy Commands
        run: bash .github/scripts/readme-quick-deploy.sh

'''
'''--- NFT-example/.github/workflows/tests.yml ---
name: Tests
on: 
  repository_dispatch:
    types: [tests-report]
  push:
jobs:
  tests:
    strategy:
      matrix:
        platform: [ubuntu-latest]  # mac-os currently in progress
    runs-on: ${{ matrix.platform }}
    steps:
      - name: Checkout branch
        uses: actions/checkout@v2
      - name: Install Node
        uses: actions/setup-node@v2
      - name: Install Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          target: wasm32-unknown-unknown
      - name: Build wasm files
        run: source scripts/flags.sh && cargo build --all --target wasm32-unknown-unknown --release && cp target/wasm32-unknown-unknown/release/*.wasm ./res/
      - name: Run unit tests
        env:
          IS_GITHUB_ACTION: true
        run: cd nft && cargo test -- --nocapture --color=always
      - name: Run Rust integration tests
        run: cd integration-tests/rs && cargo run --example integration-tests
      - name: Run TypeScript integration tests
        run: cd integration-tests/ts && yarn && yarn test 

'''
'''--- NFT-example/.gitpod.yml ---
image:
  file: .gitpod.Dockerfile
# List the start up tasks. You can start them in parallel in multiple terminals. See https://www.gitpod.io/docs/config-start-tasks/
tasks:
  - before: nvm use default && npm install near-cli -g --no-optional
    init: yarn && brew install tree
    command: clear && echo Explore non-fungible tokens on NEAR Protocol

'''
'''--- NFT-example/Cargo.toml ---
[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[workspace]
# remember to include a member for each contract
members = [
  "nft",
  "test-approval-receiver",
  "test-token-receiver",
]
exclude  = [
  "integration-tests"
]
'''
'''--- NFT-example/README-Windows.md ---
Non-fungible Token (NFT)
===================

[![Open in Gitpod](https://gitpod.io/button/open-in-gitpod.svg)](https://gitpod.io/#https://github.com/near-examples/NFT)

This repository includes an example implementation of a [non-fungible token] contract which uses [near-contract-standards] and [simulation] tests.

  [non-fungible token]: https://nomicon.io/Standards/NonFungibleToken/README.html
  [near-contract-standards]: https://github.com/near/near-sdk-rs/tree/master/near-contract-standards
  [simulation]: https://github.com/near/near-sdk-rs/tree/master/near-sdk-sim
Prerequisites
=============
If you're using Gitpod, you can skip this step.

  * Make sure Rust is installed per the prerequisites in [`near-sdk-rs`](https://github.com/near/near-sdk-rs).
  * Make sure [near-cli](https://github.com/near/near-cli) is installed.

Explore this contract
=====================

The source for this contract is in `nft/src/lib.rs`. It provides methods to manage access to tokens, transfer tokens, check access, and get token owner. Note, some further exploration inside the rust macros is needed to see how the `NonFungibleToken` contract is implemented.

Building this contract
======================
Run the following, and we'll build our rust project up via cargo. This will generate our WASM binaries into our `res/` directory. This is the smart contract we'll be deploying onto the NEAR blockchain later.
```batch
build.bat
```

Testing this contract
=====================
We have some tests that you can run. For example, the following will run our simple tests to verify that our contract code is working.
```bash
cargo test -- --nocapture
```
The more complex simulation tests aren't run with this command, but we can find them in `tests/sim`.

Using this contract
===================

This smart contract will get deployed to your NEAR account. For this example, please create a new NEAR account. Because NEAR allows the ability to upgrade contracts on the same account, initialization functions must be cleared. If you'd like to run this example on a NEAR account that has had prior contracts deployed, please use the `near-cli` command `near delete`, and then recreate it in Wallet. To create (or recreate) an account, please follow the directions in [Test Wallet](https://wallet.testnet.near.org) or ([NEAR Wallet](https://wallet.near.org/) if we're using mainnet).

In the project root, log in to your newly created account with `near-cli` by following the instructions after this command.

    near login

To make this tutorial easier to copy/paste, we're going to set an environment variable for our account id. In the below command, replace `MY_ACCOUNT_NAME` with the account name we just logged in with, including the `.testnet` (or `.near` for `mainnet`):

    set ID=MY_ACCOUNT_NAME

We can tell if the environment variable is set correctly if our command line prints the account name after this command:

    echo %ID%

Now we can deploy the compiled contract in this example to your account:

    near deploy --wasmFile res/non_fungible_token.wasm --accountId %ID%

NFT contract should be initialized before usage. More info about the metadata at [nomicon.io](https://nomicon.io/Standards/NonFungibleToken/Metadata.html). But for now, we'll initialize with the default metadata.

    near call %ID% new_default_meta "{\"owner_id\": \""%ID%"\"}" --accountId %ID%

We'll be able to view our metadata right after:

    near view %ID% nft_metadata

Then, let's mint our first token. This will create a NFT based on Olympus Mons where only one copy exists:

    near call %ID% nft_mint "{\"token_id\": \"0\", \"receiver_id\": \""%ID%"\", \"token_metadata\": { \"title\": \"Olympus Mons\", \"description\": \"Tallest mountain in charted solar system\", \"copies\": 1}}" --accountId %ID% --deposit 0.1

Transferring our NFT
====================

Let's set up an account to transfer our freshly minted token to. This account will be a sub-account of the NEAR account we logged in with originally via `near login`.

    near create-account alice.%ID% --masterAccount %ID% --initialBalance 10

Checking Alice's account for tokens:

    near view %ID% nft_tokens_for_owner "{\"account_id\": \""alice.%ID%"\"}"

Then we'll transfer over the NFT into Alice's account. Exactly 1 yoctoNEAR of deposit should be attached:

    near call %ID% nft_transfer "{\"token_id\": \"0\", \"receiver_id\": \""alice.%ID%"\", \"memo\": \"transfer ownership\"}" --accountId %ID% --depositYocto 1

Checking Alice's account again shows us that she has the Olympus Mons token.

Notes
=====

* The maximum balance value is limited by U128 (2**128 - 1).
* JSON calls should pass U128 as a base-10 string. E.g. "100".
* This does not include escrow functionality, as ft_transfer_call provides a superior approach. An escrow system can, of course, be added as a separate contract or additional functionality within this contract.

AssemblyScript
==============
Currently, AssemblyScript is not supported for this example. An old version can be found in the [NEP4 example](https://github.com/near-examples/NFT/releases/tag/nep4-example), but this is not recommended as it is out of date and does not follow the standards the NEAR SDK has set currently.

'''
'''--- NFT-example/README.md ---
Non-fungible Token (NFT)
===================

>**Note**: If you'd like to learn how to create an NFT contract from scratch that explores every aspect of the [NEP-171](https://github.com/near/NEPs/blob/master/neps/nep-0171.md) standard including an NFT marketplace, check out the NFT [Zero to Hero Tutorial](https://docs.near.org/tutorials/nfts/introduction).

[![Open in Gitpod](https://gitpod.io/button/open-in-gitpod.svg)](https://gitpod.io/#https://github.com/near-examples/NFT)

This repository includes an example implementation of a [non-fungible token] contract which uses [near-contract-standards] and workspaces-js and -rs tests.

  [non-fungible token]: https://nomicon.io/Standards/NonFungibleToken/README.html
  [near-contract-standards]: https://github.com/near/near-sdk-rs/tree/master/near-contract-standards
  [simulation]: https://github.com/near/near-sdk-rs/tree/master/near-sdk-sim
Prerequisites
=============
If you're using Gitpod, you can skip this step.

  * Make sure Rust is installed per the prerequisites in [`near-sdk-rs`](https://github.com/near/near-sdk-rs).
  * Make sure [near-cli](https://github.com/near/near-cli) is installed.

Explore this contract
=====================

The source for this contract is in `nft/src/lib.rs`. It provides methods to manage access to tokens, transfer tokens, check access, and get token owner. Note, some further exploration inside the rust macros is needed to see how the `NonFungibleToken` contract is implemented.

Building this contract
======================
Run the following, and we'll build our rust project up via cargo. This will generate our WASM binaries into our `res/` directory. This is the smart contract we'll be deploying onto the NEAR blockchain later.
```bash
./scripts/build.sh
```

Testing this contract
=====================
We have some tests that you can run. For example, the following will run our simple tests to verify that our contract code is working.

*Unit Tests*
```bash
cd nft
cargo test -- --nocapture
```

*Integration Tests*
*Rust*
```bash
cd integration-tests/rs
cargo run --example integration-tests
```
*TypeScript*
```bash
cd integration-tests/ts
yarn && yarn test 
```

Using this contract
===================

### Quickest deploy

You can build and deploy this smart contract to a development account. [Dev Accounts](https://docs.near.org/concepts/basics/account#dev-accounts) are auto-generated accounts to assist in developing and testing smart contracts. Please see the [Standard deploy](#standard-deploy) section for creating a more personalized account to deploy to.

```bash
near dev-deploy --wasmFile res/non_fungible_token.wasm
```

Behind the scenes, this is creating an account and deploying a contract to it. On the console, notice a message like:

>Done deploying to dev-1234567890123

In this instance, the account is `dev-1234567890123`. A file has been created containing a key pair to
the account, located at `neardev/dev-account`. To make the next few steps easier, we're going to set an
environment variable containing this development account id and use that when copy/pasting commands.
Run this command to set the environment variable:

```bash
source neardev/dev-account.env
```

You can tell if the environment variable is set correctly if your command line prints the account name after this command:
```bash
echo $CONTRACT_NAME
```

The next command will initialize the contract using the `new` method:

```bash
near call $CONTRACT_NAME new_default_meta '{"owner_id": "'$CONTRACT_NAME'"}' --accountId $CONTRACT_NAME
```

To view the NFT metadata:

```bash
near view $CONTRACT_NAME nft_metadata
```

### Standard deploy

This smart contract will get deployed to your NEAR account. For this example, please create a new NEAR account. Because NEAR allows the ability to upgrade contracts on the same account, initialization functions must be cleared. If you'd like to run this example on a NEAR account that has had prior contracts deployed, please use the `near-cli` command `near delete`, and then recreate it in Wallet. To create (or recreate) an account, please follow the directions in [Test Wallet](https://wallet.testnet.near.org) or ([NEAR Wallet](https://wallet.near.org/) if we're using `mainnet`).

In the project root, log in to your newly created account with `near-cli` by following the instructions after this command.

    near login

To make this tutorial easier to copy/paste, we're going to set an environment variable for our account id. In the below command, replace `MY_ACCOUNT_NAME` with the account name we just logged in with, including the `.testnet` (or `.near` for `mainnet`):

    ID=MY_ACCOUNT_NAME

We can tell if the environment variable is set correctly if our command line prints the account name after this command:

    echo $ID

Now we can deploy the compiled contract in this example to your account:

    near deploy --wasmFile res/non_fungible_token.wasm --accountId $ID

NFT contract should be initialized before usage. More info about the metadata at [nomicon.io](https://nomicon.io/Standards/NonFungibleToken/Metadata.html). But for now, we'll initialize with the default metadata.

    near call $ID new_default_meta '{"owner_id": "'$ID'"}' --accountId $ID

We'll be able to view our metadata right after:

    near view $ID nft_metadata

Then, let's mint our first token. This will create a NFT based on Olympus Mons where only one copy exists:

    near call $ID nft_mint '{"token_id": "0", "receiver_id": "'$ID'", "token_metadata": { "title": "Olympus Mons", "description": "Tallest mountain in charted solar system", "media": "https://upload.wikimedia.org/wikipedia/commons/thumb/0/00/Olympus_Mons_alt.jpg/1024px-Olympus_Mons_alt.jpg", "copies": 1}}' --accountId $ID --deposit 0.1

Transferring our NFT
====================

Let's set up an account to transfer our freshly minted token to. This account will be a sub-account of the NEAR account we logged in with originally via `near login`.

    near create-account alice.$ID --masterAccount $ID --initialBalance 10

Checking Alice's account for tokens:

    near view $ID nft_tokens_for_owner '{"account_id": "'alice.$ID'"}'

Then we'll transfer over the NFT into Alice's account. Exactly 1 yoctoNEAR of deposit should be attached:

    near call $ID nft_transfer '{"token_id": "0", "receiver_id": "alice.'$ID'", "memo": "transfer ownership"}' --accountId $ID --depositYocto 1

Checking Alice's account again shows us that she has the Olympus Mons token.

Notes
=====

* The maximum balance value is limited by U128 (2**128 - 1).
* JSON calls should pass U128 as a base-10 string. E.g. "100".
* This does not include escrow functionality, as ft_transfer_call provides a superior approach. An escrow system can, of course, be added as a separate contract or additional functionality within this contract.

AssemblyScript
==============
Currently, AssemblyScript is not supported for this example. An old version can be found in the [NEP4 example](https://github.com/near-examples/NFT/releases/tag/nep4-example), but this is not recommended as it is out of date and does not follow the standards the NEAR SDK has set currently.

'''
'''--- NFT-example/integration-tests/rs/Cargo.toml ---
[package]
name = "non-fungible-token-integration-tests"
version = "1.0.0"
publish = false
edition = "2018"

[dev-dependencies]
near-sdk = "4.0.0"
anyhow = "1.0"
borsh = "0.9"
maplit = "1.0"
near-units = "0.2.0"
# arbitrary_precision enabled for u128 types that workspaces requires for Balance types
serde_json = { version = "1.0", features = ["arbitrary_precision"] }
tokio = { version = "1.18.1", features = ["full"] }
tracing = "0.1"
tracing-subscriber = { version = "0.3.11", features = ["env-filter"] }
workspaces = "0.4.0"
pkg-config = "0.3.1"

[[example]]
name = "integration-tests"
path = "src/tests.rs"

'''
'''--- NFT-example/integration-tests/rs/src/tests.rs ---
use near_units::{parse_gas, parse_near};
use serde_json::json;
use workspaces::prelude::*;
use workspaces::{network::Sandbox, Account, Contract, Worker};

const NFT_WASM_FILEPATH: &str = "../../res/non_fungible_token.wasm";
const TR_WASM_FILEPATH: &str = "../../res/token_receiver.wasm";
const AR_WASM_FILEPATH: &str = "../../res/approval_receiver.wasm";

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // initiate environemnt
    let worker = workspaces::sandbox().await?;

    // deploy contracts
    let nft_wasm = std::fs::read(NFT_WASM_FILEPATH)?;
    let nft_contract = worker.dev_deploy(&nft_wasm).await?;
    let tr_wasm = std::fs::read(TR_WASM_FILEPATH)?;
    let tr_contract = worker.dev_deploy(&tr_wasm).await?;
    let ar_wasm = std::fs::read(AR_WASM_FILEPATH)?;
    let ar_contract = worker.dev_deploy(&ar_wasm).await?;

    // create accounts
    let owner = worker.root_account().unwrap();
    let alice = owner
        .create_subaccount(&worker, "alice")
        .initial_balance(parse_near!("30 N"))
        .transact()
        .await?
        .into_result()?;

    // Initialize contracts
    nft_contract
        .call(&worker, "new_default_meta")
        .args_json(serde_json::json!({
            "owner_id": owner.id()
        }))?
        .transact()
        .await?;
    tr_contract
        .call(&worker, "new")
        .args_json(serde_json::json!({
            "non_fungible_token_account_id": nft_contract.id()
        }))?
        .transact()
        .await?;
    ar_contract
        .call(&worker, "new")
        .args_json(serde_json::json!({
            "non_fungible_token_account_id": nft_contract.id()
        }))?
        .transact()
        .await?;

    // begin tests
    test_simple_approve(&owner, &alice, &nft_contract, &worker).await?;
    test_approval_simple_call(&owner, &nft_contract, &ar_contract, &worker).await?;
    test_approved_account_transfers_token(&owner, &alice, &nft_contract, &worker).await?;
    test_revoke(&owner, &alice, &nft_contract, &tr_contract, &worker).await?;
    test_revoke_all(&owner, &alice, &nft_contract, &tr_contract, &worker).await?;
    test_simple_transfer(&owner, &alice, &nft_contract, &worker).await?;
    test_transfer_call_fast_return_to_sender(&owner, &tr_contract, &nft_contract, &worker).await?;
    test_transfer_call_slow_return_to_sender(&owner, &tr_contract, &nft_contract, &worker).await?;
    test_transfer_call_fast_keep_with_sender(&owner, &tr_contract, &nft_contract, &worker).await?;
    test_transfer_call_slow_keep_with_sender(&owner, &tr_contract, &nft_contract, &worker).await?;
    test_transfer_call_receiver_panics(&owner, &tr_contract, &nft_contract, &worker).await?;
    test_enum_total_supply(&nft_contract, &worker).await?;
    test_enum_nft_tokens(&nft_contract, &worker).await?;
    test_enum_nft_supply_for_owner(&owner, &alice, &nft_contract, &worker).await?;
    test_enum_nft_tokens_for_owner(&owner, &alice, &nft_contract, &worker).await?;
    Ok(())
}

async fn test_simple_approve(
    owner: &Account,
    user: &Account,
    nft_contract: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    owner
        .call(&worker, nft_contract.id(), "nft_mint")
        .args_json(json!({
            "token_id": "0",
            "receiver_id": owner.id(),
            "token_metadata": {
                "title": "Olympus Mons",
                "description": "The tallest mountain in the charted solar system",
                "copies": 10000,
            }
        }))?
        .deposit(parse_gas!("5950000000000000000000"))
        .transact()
        .await?;

    // root approves alice
    owner
        .call(&worker, nft_contract.id(), "nft_approve")
        .args_json(json!({
            "token_id":  "0",
            "account_id": user.id(),
        }))?
        .deposit(parse_gas!("5950000000000000000000"))
        .transact()
        .await?;

    let approval_no_id: bool = nft_contract
        .call(&worker, "nft_is_approved")
        .args_json(json!({
            "token_id":  "0",
            "approved_account_id": user.id()
        }))?
        .transact()
        .await?
        .json()?;

    assert!(approval_no_id);

    let approval: bool = nft_contract
        .call(&worker, "nft_is_approved")
        .args_json(json!({
            "token_id":  "0",
            "approved_account_id": user.id(),
            "approval_id": 1
        }))?
        .transact()
        .await?
        .json()?;

    assert!(approval);

    let approval_wrong_id: bool = nft_contract
        .call(&worker, "nft_is_approved")
        .args_json(json!({
            "token_id":  "0",
            "approved_account_id": user.id(),
            "approval_id": 2
        }))?
        .transact()
        .await?
        .json()?;

    assert!(!approval_wrong_id);
    println!("      Passed ✅ test_simple_approve");
    Ok(())
}

async fn test_approval_simple_call(
    owner: &Account,
    nft_contract: &Contract,
    approval_receiver: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    owner
        .call(&worker, nft_contract.id(), "nft_mint")
        .args_json(json!({
            "token_id": "1",
            "receiver_id": owner.id(),
            "token_metadata": {
                "title": "Olympus Mons 2",
                "description": "The tallest mountain in the charted solar system",
                "copies": 1,
            }
        }))?
        .deposit(parse_gas!("5950000000000000000000"))
        .transact()
        .await?;

    let outcome: String = owner
        .call(&worker, nft_contract.id(), "nft_approve")
        .args_json(json!({
            "token_id": "1",
            "account_id": approval_receiver.id(),
            "msg": "return-now"
        }))?
        .gas(parse_gas!("150 Tgas") as u64)
        .deposit(parse_gas!("450000000000000000000"))
        .transact()
        .await?
        .json()?;
    assert_eq!("cool", outcome);

    let msg = "test message";
    let outcome: String = owner
        .call(&worker, nft_contract.id(), "nft_approve")
        .args_json(json!({
            "token_id": "1",
            "account_id": approval_receiver.id(),
            "msg": msg.clone(),
        }))?
        .gas(parse_gas!("150 Tgas") as u64)
        .deposit(parse_gas!("450000000000000000000"))
        .transact()
        .await?
        .json()?;
    assert_eq!(msg, outcome);

    println!("      Passed ✅ test_approval_simple_call");
    Ok(())
}

async fn test_approved_account_transfers_token(
    owner: &Account,
    user: &Account,
    nft_contract: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    use serde_json::Value::String;
    owner
        .call(&worker, nft_contract.id(), "nft_transfer")
        .args_json(json!({
            "receiver_id": user.id(),
            "token_id": '0',
            "approval_id": 1,
            "memo": "message for test 3",
        }))?
        .deposit(1)
        .transact()
        .await?;

    let token: serde_json::Value = nft_contract
        .call(&worker, "nft_token")
        .args_json(json!({"token_id": "0"}))?
        .transact()
        .await?
        .json()?;
    assert_eq!(token.get("owner_id"), Some(&String(user.id().to_string())));

    println!("      Passed ✅ test_approved_account_transfers_token");
    Ok(())
}

async fn test_revoke(
    owner: &Account,
    user: &Account,
    nft_contract: &Contract,
    token_receiver: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    owner
        .call(&worker, nft_contract.id(), "nft_approve")
        .args_json(json!({
            "token_id": "1",
            "account_id": user.id(),
        }))?
        .gas(parse_gas!("150 Tgas") as u64)
        .deposit(parse_gas!("450000000000000000000"))
        .transact()
        .await?;

    // root approves token_receiver
    owner
        .call(&worker, nft_contract.id(), "nft_approve")
        .args_json(json!({
            "token_id": "1",
            "account_id": token_receiver.id(),
        }))?
        .gas(parse_gas!("150 Tgas") as u64)
        .deposit(parse_gas!("450000000000000000000"))
        .transact()
        .await?;

    // root revokes user
    owner
        .call(&worker, nft_contract.id(), "nft_revoke")
        .args_json(json!({
            "token_id": "1",
            "account_id": user.id(),
        }))?
        .deposit(1)
        .transact()
        .await?;

    // assert user is revoked
    let revoke_bool: bool = nft_contract
        .call(&worker, "nft_is_approved")
        .args_json(json!({
            "token_id":  "1",
            "approved_account_id": user.id()
        }))?
        .transact()
        .await?
        .json()?;
    assert_eq!(revoke_bool, false);

    // assert token receiver still approved
    let revoke_bool: bool = nft_contract
        .call(&worker, "nft_is_approved")
        .args_json(json!({
            "token_id":  "1",
            "approved_account_id": token_receiver.id()
        }))?
        .transact()
        .await?
        .json()?;
    assert_eq!(revoke_bool, true);

    // root revokes token_receiver
    owner
        .call(&worker, nft_contract.id(), "nft_revoke")
        .args_json(json!({
            "token_id": "1",
            "account_id": token_receiver.id(),
        }))?
        .deposit(1)
        .transact()
        .await?;

    // assert alice is still revoked
    let revoke_bool: bool = nft_contract
        .call(&worker, "nft_is_approved")
        .args_json(json!({
            "token_id":  "1",
            "approved_account_id": user.id()
        }))?
        .transact()
        .await?
        .json()?;
    assert_eq!(revoke_bool, false);

    // and now so is token_receiver
    let revoke_bool: bool = nft_contract
        .call(&worker, "nft_is_approved")
        .args_json(json!({
            "token_id":  "1",
            "approved_account_id": token_receiver.id()
        }))?
        .transact()
        .await?
        .json()?;
    assert_eq!(revoke_bool, false);

    println!("      Passed ✅ test_revoke");
    Ok(())
}

async fn test_revoke_all(
    owner: &Account,
    user: &Account,
    nft_contract: &Contract,
    token_receiver: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    // root approves alice
    owner
        .call(&worker, nft_contract.id(), "nft_approve")
        .args_json(json!({
            "token_id": "1",
            "account_id": user.id(),
        }))?
        .gas(parse_gas!("150 Tgas") as u64)
        .deposit(parse_gas!("450000000000000000000"))
        .transact()
        .await?;

    // root approves token_receiver
    owner
        .call(&worker, nft_contract.id(), "nft_approve")
        .args_json(json!({
            "token_id": "1",
            "account_id": token_receiver.id(),
        }))?
        .gas(parse_gas!("150 Tgas") as u64)
        .deposit(parse_gas!("450000000000000000000"))
        .transact()
        .await?;

    // assert everyone is revoked
    let revoke_bool: bool = nft_contract
        .call(&worker, "nft_is_approved")
        .args_json(json!({
            "token_id":  "1",
            "approved_account_id": user.id()
        }))?
        .transact()
        .await?
        .json()?;
    assert_eq!(revoke_bool, true);

    let revoke_bool: bool = nft_contract
        .call(&worker, "nft_is_approved")
        .args_json(json!({
            "token_id":  "1",
            "approved_account_id": token_receiver.id()
        }))?
        .transact()
        .await?
        .json()?;
    assert_eq!(revoke_bool, true);

    println!("      Passed ✅ test_revoke_all");
    Ok(())
}

async fn test_simple_transfer(
    owner: &Account,
    user: &Account,
    nft_contract: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    use serde_json::Value::String;
    let token: serde_json::Value = nft_contract
        .call(&worker, "nft_token")
        .args_json(json!({"token_id": "1"}))?
        .transact()
        .await?
        .json()?;
    assert_eq!(token.get("owner_id"), Some(&String(owner.id().to_string())));

    owner
        .call(&worker, nft_contract.id(), "nft_transfer")
        .args_json(json!({
            "token_id": "1",
            "receiver_id": user.id(),
        }))?
        .deposit(1)
        .transact()
        .await?;

    let token: serde_json::Value = nft_contract
        .call(&worker, "nft_token")
        .args_json(json!({"token_id": "1"}))?
        .transact()
        .await?
        .json()?;
    assert_eq!(token.get("owner_id"), Some(&String(user.id().to_string())));

    println!("      Passed ✅ test_simple_transfer");
    Ok(())
}

async fn test_transfer_call_fast_return_to_sender(
    owner: &Account,
    token_receiver: &Contract,
    nft_contract: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    use serde_json::Value::String;
    owner
        .call(&worker, nft_contract.id(), "nft_mint")
        .args_json(json!({
            "token_id": "2",
            "receiver_id": owner.id(),
            "token_metadata": {
                "title": "Olympus Mons 3",
                "description": "The tallest mountain in the charted solar system",
                "copies": 1,
            }
        }))?
        .deposit(parse_gas!("6050000000000000000000"))
        .transact()
        .await?;

    owner
        .call(&worker, nft_contract.id(), "nft_transfer_call")
        .args_json(json!({
            "token_id": "2",
            "receiver_id": token_receiver.id(),
            "memo": "transfer & call",
            "msg": "return-it-now",
        }))?
        .deposit(1)
        .gas(parse_gas!("150 Tgas") as u64)
        .transact()
        .await?;

    let token: serde_json::Value = nft_contract
        .call(&worker, "nft_token")
        .args_json(json!({"token_id": "2"}))?
        .transact()
        .await?
        .json()?;
    assert_eq!(token.get("owner_id"), Some(&String(owner.id().to_string())));

    println!("      Passed ✅ test_transfer_call_fast_return_to_sender");
    Ok(())
}

async fn test_transfer_call_slow_return_to_sender(
    owner: &Account,
    token_receiver: &Contract,
    nft_contract: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    use serde_json::Value::String;
    owner
        .call(&worker, nft_contract.id(), "nft_transfer_call")
        .args_json(json!({
            "token_id": "2",
            "receiver_id": token_receiver.id(),
            "memo": "transfer & call",
            "msg": "return-it-later",
        }))?
        .deposit(1)
        .gas(parse_gas!("150 Tgas") as u64)
        .transact()
        .await?;

    let token: serde_json::Value = nft_contract
        .call(&worker, "nft_token")
        .args_json(json!({"token_id": "2"}))?
        .transact()
        .await?
        .json()?;
    assert_eq!(token.get("owner_id"), Some(&String(owner.id().to_string())));

    println!("      Passed ✅ test_transfer_call_slow_return_to_sender");
    Ok(())
}

async fn test_transfer_call_fast_keep_with_sender(
    owner: &Account,
    token_receiver: &Contract,
    nft_contract: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    use serde_json::Value::String;
    owner
        .call(&worker, nft_contract.id(), "nft_transfer_call")
        .args_json(json!({
            "token_id": "2",
            "receiver_id": token_receiver.id(),
            "memo": "transfer & call",
            "msg": "keep-it-now",
        }))?
        .deposit(1)
        .gas(parse_gas!("150 Tgas") as u64)
        .transact()
        .await?;

    let token: serde_json::Value = nft_contract
        .call(&worker, "nft_token")
        .args_json(json!({"token_id": "2"}))?
        .transact()
        .await?
        .json()?;
    assert_eq!(
        token.get("owner_id"),
        Some(&String(token_receiver.id().to_string()))
    );

    println!("      Passed ✅ test_transfer_call_fast_keep_with_sender");
    Ok(())
}

async fn test_transfer_call_slow_keep_with_sender(
    owner: &Account,
    token_receiver: &Contract,
    nft_contract: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    use serde_json::Value::String;
    owner
        .call(&worker, nft_contract.id(), "nft_mint")
        .args_json(json!({
            "token_id": "3",
            "receiver_id": owner.id(),
            "token_metadata": {
                "title": "Olympus Mons 4",
                "description": "The tallest mountain in the charted solar system",
                "copies": 1,
            }
        }))?
        .deposit(parse_gas!("6050000000000000000000"))
        .transact()
        .await?;

    owner
        .call(&worker, nft_contract.id(), "nft_transfer_call")
        .args_json(json!({
            "token_id": "3",
            "receiver_id": token_receiver.id(),
            "memo": "transfer & call",
            "msg": "keep-it-later",
        }))?
        .deposit(1)
        .gas(parse_gas!("150 Tgas") as u64)
        .transact()
        .await?;

    let token: serde_json::Value = nft_contract
        .call(&worker, "nft_token")
        .args_json(json!({"token_id": "3"}))?
        .transact()
        .await?
        .json()?;
    assert_eq!(
        token.get("owner_id"),
        Some(&String(token_receiver.id().to_string()))
    );

    println!("      Passed ✅ test_transfer_call_slow_keep_with_sender");
    Ok(())
}

async fn test_transfer_call_receiver_panics(
    owner: &Account,
    token_receiver: &Contract,
    nft_contract: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    use serde_json::Value::String;
    owner
        .call(&worker, nft_contract.id(), "nft_mint")
        .args_json(json!({
            "token_id": "4",
            "receiver_id": owner.id(),
            "token_metadata": {
                "title": "Olympus Mons 5",
                "description": "The tallest mountain in the charted solar system",
                "copies": 1,
            }
        }))?
        .deposit(parse_gas!("6050000000000000000000"))
        .gas(parse_gas!("150 Tgas") as u64)
        .transact()
        .await?;

    owner
        .call(&worker, nft_contract.id(), "nft_transfer_call")
        .args_json(json!({
            "token_id": "4",
            "receiver_id": token_receiver.id(),
            "memo": "transfer & call",
            "msg": "incorrect message",
        }))?
        .deposit(1)
        .gas(parse_gas!("150 Tgas") as u64)
        .transact()
        .await?;

    let token: serde_json::Value = nft_contract
        .call(&worker, "nft_token")
        .args_json(json!({"token_id": "4"}))?
        .transact()
        .await?
        .json()?;
    assert_eq!(token.get("owner_id"), Some(&String(owner.id().to_string())));

    println!("      Passed ✅ test_transfer_call_receiver_panics");
    Ok(())
}

async fn test_enum_total_supply(
    nft_contract: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    let supply: String = nft_contract
        .call(&worker, "nft_total_supply")
        .args_json(json!({}))?
        .transact()
        .await?
        .json()?;
    assert_eq!(supply, "5");

    println!("      Passed ✅ test_enum_total_supply");
    Ok(())
}

async fn test_enum_nft_tokens(
    nft_contract: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    let tokens: Vec<serde_json::Value> = nft_contract
        .call(&worker, "nft_tokens")
        .args_json(json!({}))?
        .transact()
        .await?
        .json()?;

    assert_eq!(tokens.len(), 5);

    println!("      Passed ✅ test_enum_nft_tokens");
    Ok(())
}

async fn test_enum_nft_supply_for_owner(
    owner: &Account,
    user: &Account,
    nft_contract: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    let owner_tokens: String = nft_contract
        .call(&worker, "nft_supply_for_owner")
        .args_json(json!({"account_id": owner.id()}))?
        .transact()
        .await?
        .json()?;
    assert_eq!(owner_tokens, "1");

    let user_tokens: String = nft_contract
        .call(&worker, "nft_supply_for_owner")
        .args_json(json!({"account_id": user.id()}))?
        .transact()
        .await?
        .json()?;
    assert_eq!(user_tokens, "2");

    println!("      Passed ✅ test_enum_nft_supply_for_owner");
    Ok(())
}

async fn test_enum_nft_tokens_for_owner(
    owner: &Account,
    user: &Account,
    nft_contract: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    let tokens: Vec<serde_json::Value> = nft_contract
        .call(&worker, "nft_tokens_for_owner")
        .args_json(json!({
            "account_id": user.id()
        }))?
        .transact()
        .await?
        .json()?;
    assert_eq!(tokens.len(), 2);

    let tokens: Vec<serde_json::Value> = nft_contract
        .call(&worker, "nft_tokens_for_owner")
        .args_json(json!({
            "account_id": owner.id()
        }))?
        .transact()
        .await?
        .json()?;
    assert_eq!(tokens.len(), 1);
    println!("      Passed ✅ test_enum_nft_tokens_for_owner");
    Ok(())
}

'''
'''--- NFT-example/integration-tests/ts/package.json ---
{
  "name": "non-fungible-token-integration-tests-ts",
  "version": "1.0.0",
  "license": "(MIT AND Apache-2.0)",
  "scripts": {
    "test": "ava --verbose"
  },
  "devDependencies": {
    "ava": "^4.2.0",
    "near-workspaces": "^3.2.2",
    "typescript": "^4.6.4",
    "ts-node": "^10.8.0",
    "@types/bn.js": "^5.1.0"
  },
  "dependencies": {}
}

'''
'''--- NFT-example/integration-tests/ts/src/main.ava.ts ---
import { Worker, NearAccount, tGas, NEAR, BN } from 'near-workspaces';
import anyTest, { TestFn } from 'ava';
import { mint_more, nft_total_supply } from './utils';

const test = anyTest as TestFn<{
    worker: Worker;
    accounts: Record<string, NearAccount>;
}>;

test.beforeEach(async t => {
    const worker = await Worker.init();
    const root = worker.rootAccount;
    const nft = await root.devDeploy(
        '../../res/non_fungible_token.wasm',
        {
            initialBalance: NEAR.parse('100 N').toJSON(),
            method: "new_default_meta",
            args: { owner_id: root }
        },
    );
    await root.call(
        nft,
        "nft_mint",
        {
            token_id: "0",
            receiver_id: root,
            token_metadata: {
                title: "Olympus Mons",
                description: "The tallest mountain in the charted solar system",
                media: null,
                media_hash: null,
                copies: 10000,
                issued_at: null,
                expires_at: null,
                starts_at: null,
                updated_at: null,
                extra: null,
                reference: null,
                reference_hash: null,
            }
        },
        { attachedDeposit: '7000000000000000000000' }
    );

    const alice = await root.createSubAccount('alice', { initialBalance: NEAR.parse('100 N').toJSON() });

    const tokenReceiver = await root.devDeploy(
        '../../res/token_receiver.wasm',
        {
            initialBalance: NEAR.parse('100 N').toJSON(),
            method: "new",
            args: { non_fungible_token_account_id: nft },
        }
    );

    const approvalReceiver = await root.devDeploy(
        '../../res/approval_receiver.wasm',
        {
            initialBalance: NEAR.parse('100 N').toJSON(),
            method: "new",
            args: { non_fungible_token_account_id: nft },
        }
    );

    t.context.worker = worker;
    t.context.accounts = { root, alice, nft, tokenReceiver, approvalReceiver };
});

test.afterEach(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed to tear down the worker:', error);
    });
});

test('Simple approve', async test => {
    const { root, alice, nft, tokenReceiver } = test.context.accounts;
    // root approves alice
    await root.call(
        nft,
        'nft_approve',
        {
            token_id: '0',
            account_id: alice,
        },
        {
            attachedDeposit: new BN('270000000000000000000'), // need more deposit than the sim-tests, cause names are longer
            gas: tGas('150')
        },
    );

    // check nft_is_approved, don't provide approval_id
    test.assert(
        await nft.view(
            'nft_is_approved',
            {
                token_id: '0',
                approved_account_id: alice,
            })
    );

    // check nft_is_approved, with approval_id=1
    test.assert(
        await nft.view(
            'nft_is_approved',
            {
                token_id: '0',
                approved_account_id: alice,
                approval_id: 1,
            })
    );

    // check nft_is_approved, with approval_id=2
    test.false(
        await nft.view(
            'nft_is_approved',
            {
                token_id: '0',
                approved_account_id: alice,
                approval_id: 2,
            })
    );

    // alternatively, one could check the data returned by nft_token
    const token: any = await nft.view('nft_token', { token_id: '0', });
    test.deepEqual(token.approved_account_ids, { [alice.accountId]: 1 })

    // root approves alice again, which changes the approval_id and doesn't require as much deposit
    await root.call(
        nft,
        'nft_approve',
        {
            token_id: '0',
            account_id: alice,
        },
        { attachedDeposit: '1', gas: tGas('150') }
    );

    test.true(
        await nft.view(
            'nft_is_approved',
            {
                token_id: '0',
                approved_account_id: alice,
                approval_id: 2,
            },
        )
    );

    // approving another account gives different approval_id
    await root.call(
        nft,
        'nft_approve',
        {
            token_id: '0',
            account_id: tokenReceiver,
        },
        // note that token_receiver's account name is longer, and so takes more bytes to store and
        // therefore requires a larger deposit!
        { attachedDeposit: new BN('360000000000000000000'), gas: tGas('150') }
    );

    test.true(
        await nft.view(
            'nft_is_approved',
            {
                token_id: '0',
                approved_account_id: tokenReceiver,
                approval_id: 3,
            })
    );
});

test('Approval with call', async test => {
    const { root, nft, approvalReceiver } = test.context.accounts;
    let outcome: string = await root.call(
        nft,
        'nft_approve',
        {
            token_id: '0',
            account_id: approvalReceiver,
            msg: 'return-now',
        },
        { attachedDeposit: new BN('390000000000000000000'), gas: tGas('150') },
    );

    test.is(outcome, 'cool');

    const msg = 'hahaha';
    outcome = await root.call(
        nft,
        'nft_approve',
        {
            token_id: '0',
            account_id: approvalReceiver,
            msg: msg,
        },
        { attachedDeposit: new BN('390000000000000000000'), gas: tGas('150') },
    );
    test.is(outcome, msg);
});

test('Approved account transfers token', async test => {
    const { root, alice, nft } = test.context.accounts;
    await root.call(
        nft,
        'nft_approve',
        {
            token_id: '0',
            account_id: alice,

        },
        { attachedDeposit: new BN('270000000000000000000'), gas: tGas('150') },
    );

    await alice.call(
        nft,
        'nft_transfer',
        {
            receiver_id: alice,
            token_id: '0',
            approval_id: 1,
            memo: 'gotcha! bahahaha',
        },
        { attachedDeposit: '1', gas: tGas('150') }
    );

    const token: any = await nft.view('nft_token', { token_id: '0' });
    test.is(token.owner_id, alice.accountId);
});

test('Revoke', async test => {
    const { root, alice, tokenReceiver, nft } = test.context.accounts;
    // root approves alice
    await root.call(
        nft,
        'nft_approve',
        {
            token_id: '0',
            account_id: alice,

        },
        { attachedDeposit: new BN('270000000000000000000'), gas: tGas('150') },
    );

    // root approves token_receiver
    await root.call(
        nft,
        'nft_approve',
        {
            token_id: '0',
            account_id: tokenReceiver,
        },
        { attachedDeposit: new BN('360000000000000000000'), gas: tGas('150') }
    );

    // root revokes alice
    await root.call(nft, 'nft_revoke', { token_id: '0', account_id: alice }, { attachedDeposit: '1' });

    // alice is revoked...
    test.false(
        await nft.view('nft_is_approved', { token_id: '0', approved_account_id: alice })
    );

    // but token_receiver is still approved
    test.true(
        await nft.view('nft_is_approved', { token_id: '0', approved_account_id: tokenReceiver })
    );

    // root revokes token_receiver
    await root.call(nft, 'nft_revoke', { token_id: '0', account_id: tokenReceiver }, { attachedDeposit: '1' });

    // alice is still revoked...
    test.false(
        await nft.view('nft_is_approved', { token_id: '0', approved_account_id: alice })
    );

    // ...and now so is token_receiver
    test.false(
        await nft.view('nft_is_approved', { token_id: '0', approved_account_id: tokenReceiver })
    );
})

test('Revoke all', async test => {
    const { root, alice, tokenReceiver, nft } = test.context.accounts;
    // root approves alice
    await root.call(
        nft,
        'nft_approve',
        {
            token_id: '0',
            account_id: alice,

        },
        { attachedDeposit: new BN('270000000000000000000'), gas: tGas('150') },
    );

    // root approves token_receiver
    await root.call(
        nft,
        'nft_approve',
        {
            token_id: '0',
            account_id: tokenReceiver,
        },
        { attachedDeposit: new BN('360000000000000000000'), gas: tGas('150') }
    );

    await root.call(nft, 'nft_revoke_all', { token_id: '0' }, { attachedDeposit: '1' });

    // everyone revoked...
    test.false(
        await nft.view('nft_is_approved', { token_id: '0', approved_account_id: alice })
    );
    test.false(
        await nft.view('nft_is_approved', { token_id: '0', approved_account_id: tokenReceiver })
    );
})

test('Simple transfer', async test => {
    const { root, alice, nft } = test.context.accounts;
    let token: any = await nft.view('nft_token', { token_id: '0' });
    test.is(token.owner_id, root.accountId);

    const result = await root.callRaw(
        nft,
        'nft_transfer',
        {
            receiver_id: alice,
            token_id: '0',
            memo: "simple transfer",
        },
        { attachedDeposit: '1' },
    );
    test.assert(result.succeeded);
    token = await nft.view('nft_token', { token_id: '0' });
    test.is(token.owner_id, alice.accountId);
});

test('Transfer call fast return to sender', async test => {
    const { root, tokenReceiver, nft } = test.context.accounts;
    await root.call(
        nft,
        'nft_transfer_call',
        {
            receiver_id: tokenReceiver,
            token_id: '0',
            memo: 'transfer & call',
            msg: 'return-it-now',
        },
        { attachedDeposit: '1', gas: tGas(150) },
    );

    const token: any = await nft.view('nft_token', { token_id: '0' });
    test.is(token.owner_id, root.accountId);
});

test('Transfer call slow return to sender', async test => {
    const { root, tokenReceiver, nft } = test.context.accounts;
    await root.call(
        nft,
        'nft_transfer_call',
        {
            receiver_id: tokenReceiver,
            token_id: '0',
            memo: 'transfer & call',
            msg: 'return-it-later',
        },
        { attachedDeposit: '1', gas: tGas(150) },
    );

    const token: any = await nft.view('nft_token', { token_id: '0' });
    test.is(token.owner_id, root.accountId);
});

test('Transfer call fast keep with sender', async test => {
    const { root, tokenReceiver, nft } = test.context.accounts;
    await root.call(
        nft,
        'nft_transfer_call',
        {
            receiver_id: tokenReceiver,
            token_id: '0',
            memo: 'transfer & call',
            msg: 'keep-it-now',
        },
        { attachedDeposit: '1', gas: tGas(150) },
    );
    const token: any = await nft.view('nft_token', { token_id: '0' });
    test.is(token.owner_id, tokenReceiver.accountId);
});

test('Transfer call slow keep with sender', async test => {
    const { root, tokenReceiver, nft } = test.context.accounts;
    await root.call(
        nft,
        'nft_transfer_call',
        {
            receiver_id: tokenReceiver,
            token_id: '0',
            approval_id: null,
            memo: 'transfer & call',
            msg: 'keep-it-later',
        },
        { attachedDeposit: '1', gas: tGas(150) },
    );
    const token: any = await nft.view('nft_token', { token_id: '0' });
    test.is(token.owner_id, tokenReceiver.accountId);
});

test('Transfer call receiver panics', async test => {
    const { root, tokenReceiver, nft } = test.context.accounts;
    await root.call(
        nft,
        'nft_transfer_call',
        {
            receiver_id: tokenReceiver,
            token_id: '0',
            approval_id: null,
            memo: 'transfer & call',
            msg: 'incorrect message',
        },
        { attachedDeposit: '1', gas: tGas(150) },
    );
    const token: any = await nft.view('nft_token', { token_id: '0' });
    test.is(token.owner_id, root.accountId);
});

test('Enum total supply', async test => {
    const { root, alice, nft } = test.context.accounts;
    await mint_more(root, nft);

    const total_supply = await nft_total_supply(nft, alice);
    test.deepEqual(total_supply, new BN(4));
});

test('Enum nft tokens', async test => {
    const { root, nft } = test.context.accounts;
    await mint_more(root, nft);

    // No optional args should return all
    let tokens: any[] = await nft.view('nft_tokens');
    test.is(tokens.length, 4);

    // Start at "1", with no limit arg
    tokens = await nft.view('nft_tokens', { from_index: '1' });
    test.is(tokens.length, 3);
    test.is(tokens[0].token_id, '1');
    test.is(tokens[1].token_id, '2');
    test.is(tokens[2].token_id, '3');

    // Start at "2", with limit 1
    tokens = await nft.view('nft_tokens', { from_index: '2', limit: 1 });
    test.is(tokens.length, 1);
    test.is(tokens[0].token_id, '2');

    // Don't specify from_index, but limit 2
    tokens = await nft.view('nft_tokens', { limit: 2 });
    test.is(tokens.length, 2);
    test.is(tokens[0].token_id, '0');
    test.is(tokens[1].token_id, '1');
});

test('Enum nft supply for owner', async test => {
    const { root, alice, nft } = test.context.accounts;
    // Get number from account with no NFTs
    let ownerNumTokens: BN = new BN(await nft.view('nft_supply_for_owner', { account_id: alice }));
    test.deepEqual(ownerNumTokens, new BN(0));

    ownerNumTokens = new BN(await nft.view('nft_supply_for_owner', { account_id: root }));
    test.deepEqual(ownerNumTokens, new BN(1));

    await mint_more(root, nft);

    ownerNumTokens = new BN(await nft.view('nft_supply_for_owner', { account_id: root }));
    test.deepEqual(ownerNumTokens, new BN(4));
});

test('Enum nft tokens for owner', async test => {
    const { root, alice, nft } = test.context.accounts;
    await mint_more(root, nft);

    // Get tokens from account with no NFTs
    let ownerTokens: any[] = await nft.view('nft_tokens_for_owner', { account_id: alice });
    test.deepEqual(ownerTokens.length, 0);

    // Get tokens with no optional args
    ownerTokens = await nft.view('nft_tokens_for_owner', { account_id: root });
    test.deepEqual(ownerTokens.length, 4);

    // With from_index and no limit
    ownerTokens = await nft.view('nft_tokens_for_owner', { account_id: root, from_index: new BN(2) });
    test.deepEqual(ownerTokens.length, 2);
    test.is(ownerTokens[0].token_id, '2');
    test.is(ownerTokens[1].token_id, '3');

    // With from_index and limit 1
    ownerTokens = await nft.view('nft_tokens_for_owner', { account_id: root, from_index: new BN(1), limit: 1 });
    test.deepEqual(ownerTokens.length, 1);
    test.is(ownerTokens[0].token_id, '1');

    // No from_index but limit 3
    ownerTokens = await nft.view('nft_tokens_for_owner', { account_id: root, limit: 3 });
    test.deepEqual(ownerTokens.length, 3);
    test.is(ownerTokens[0].token_id, '0');
    test.is(ownerTokens[1].token_id, '1');
    test.is(ownerTokens[2].token_id, '2');
});
'''
'''--- NFT-example/integration-tests/ts/src/utils.ts ---
import { NearAccount, BN } from 'near-workspaces';

export async function helper_mint(
    token_id: string,
    root: NearAccount,
    nft: NearAccount,
    title: String,
    desc: String) {
    await root.call(
        nft,
        "nft_mint",
        {
            token_id: token_id,
            receiver_id: root,
            token_metadata: {
                title: title,
                description: desc,
                media: null,
                media_hash: null,
                copies: 1,
                issued_at: null,
                expires_at: null,
                starts_at: null,
                updated_at: null,
                extra: null,
                reference: null,
                reference_hash: null,
            }
        },
        { attachedDeposit: '7000000000000000000000' }
    )
}
export async function mint_more(root: NearAccount, nft: NearAccount) {
    await helper_mint(
        "1",
        root,
        nft,
        "Black as the Night",
        "In charcoal"
    );
    await helper_mint(
        "2",
        root,
        nft,
        "Hamakua",
        "Vintage recording"
    );
    await helper_mint(
        "3",
        root,
        nft,
        "Aloha ke akua",
        "Original with piano"
    );
}

export async function nft_total_supply(nft: NearAccount, user: NearAccount): Promise<BN> {
    return new BN(await nft.view('nft_total_supply'));
}

'''
'''--- NFT-example/nft/Cargo.toml ---
[package]
name = "non-fungible-token"
version = "1.1.0"
authors = ["Near Inc <hello@near.org>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0"
near-contract-standards = "4.0.0"
'''
'''--- NFT-example/nft/src/lib.rs ---
/*!
Non-Fungible Token implementation with JSON serialization.
NOTES:
  - The maximum balance value is limited by U128 (2**128 - 1).
  - JSON calls should pass U128 as a base-10 string. E.g. "100".
  - The contract optimizes the inner trie structure by hashing account IDs. It will prevent some
    abuse of deep tries. Shouldn't be an issue, once NEAR clients implement full hashing of keys.
  - The contract tracks the change in storage before and after the call. If the storage increases,
    the contract requires the caller of the contract to attach enough deposit to the function call
    to cover the storage cost.
    This is done to prevent a denial of service attack on the contract by taking all available storage.
    If the storage decreases, the contract will issue a refund for the cost of the released storage.
    The unused tokens from the attached deposit are also refunded, so it's safe to
    attach more deposit than required.
  - To prevent the deployed contract from being modified or deleted, it should not have any access
    keys on its account.
*/
use near_contract_standards::non_fungible_token::metadata::{
    NFTContractMetadata, NonFungibleTokenMetadataProvider, TokenMetadata, NFT_METADATA_SPEC,
};
use near_contract_standards::non_fungible_token::{Token, TokenId};
use near_contract_standards::non_fungible_token::NonFungibleToken;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LazyOption;
use near_sdk::{
    env, near_bindgen, AccountId, BorshStorageKey, PanicOnDefault, Promise, PromiseOrValue,
};

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    tokens: NonFungibleToken,
    metadata: LazyOption<NFTContractMetadata>,
}

const DATA_IMAGE_SVG_NEAR_ICON: &str = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 288 288'%3E%3Cg id='l' data-name='l'%3E%3Cpath d='M187.58,79.81l-30.1,44.69a3.2,3.2,0,0,0,4.75,4.2L191.86,103a1.2,1.2,0,0,1,2,.91v80.46a1.2,1.2,0,0,1-2.12.77L102.18,77.93A15.35,15.35,0,0,0,90.47,72.5H87.34A15.34,15.34,0,0,0,72,87.84V201.16A15.34,15.34,0,0,0,87.34,216.5h0a15.35,15.35,0,0,0,13.08-7.31l30.1-44.69a3.2,3.2,0,0,0-4.75-4.2L96.14,186a1.2,1.2,0,0,1-2-.91V104.61a1.2,1.2,0,0,1,2.12-.77l89.55,107.23a15.35,15.35,0,0,0,11.71,5.43h3.13A15.34,15.34,0,0,0,216,201.16V87.84A15.34,15.34,0,0,0,200.66,72.5h0A15.35,15.35,0,0,0,187.58,79.81Z'/%3E%3C/g%3E%3C/svg%3E";

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
    NonFungibleToken,
    Metadata,
    TokenMetadata,
    Enumeration,
    Approval,
}

#[near_bindgen]
impl Contract {
    /// Initializes the contract owned by `owner_id` with
    /// default metadata (for example purposes only).
    #[init]
    pub fn new_default_meta(owner_id: AccountId) -> Self {
        Self::new(
            owner_id,
            NFTContractMetadata {
                spec: NFT_METADATA_SPEC.to_string(),
                name: "Example NEAR non-fungible token".to_string(),
                symbol: "EXAMPLE".to_string(),
                icon: Some(DATA_IMAGE_SVG_NEAR_ICON.to_string()),
                base_uri: None,
                reference: None,
                reference_hash: None,
            },
        )
    }

    #[init]
    pub fn new(owner_id: AccountId, metadata: NFTContractMetadata) -> Self {
        assert!(!env::state_exists(), "Already initialized");
        metadata.assert_valid();
        Self {
            tokens: NonFungibleToken::new(
                StorageKey::NonFungibleToken,
                owner_id,
                Some(StorageKey::TokenMetadata),
                Some(StorageKey::Enumeration),
                Some(StorageKey::Approval),
            ),
            metadata: LazyOption::new(StorageKey::Metadata, Some(&metadata)),
        }
    }

    /// Mint a new token with ID=`token_id` belonging to `receiver_id`.
    ///
    /// Since this example implements metadata, it also requires per-token metadata to be provided
    /// in this call. `self.tokens.mint` will also require it to be Some, since
    /// `StorageKey::TokenMetadata` was provided at initialization.
    ///
    /// `self.tokens.mint` will enforce `predecessor_account_id` to equal the `owner_id` given in
    /// initialization call to `new`.
    #[payable]
    pub fn nft_mint(
        &mut self,
        token_id: TokenId,
        receiver_id: AccountId,
        token_metadata: TokenMetadata,
    ) -> Token {
        self.tokens.mint(token_id, receiver_id, Some(token_metadata))
    }
}

near_contract_standards::impl_non_fungible_token_core!(Contract, tokens);
near_contract_standards::impl_non_fungible_token_approval!(Contract, tokens);
near_contract_standards::impl_non_fungible_token_enumeration!(Contract, tokens);

#[near_bindgen]
impl NonFungibleTokenMetadataProvider for Contract {
    fn nft_metadata(&self) -> NFTContractMetadata {
        self.metadata.get().unwrap()
    }
}

#[cfg(all(test, not(target_arch = "wasm32")))]
mod tests {
    use near_sdk::test_utils::{accounts, VMContextBuilder};
    use near_sdk::testing_env;
    use std::collections::HashMap;

    use super::*;

    const MINT_STORAGE_COST: u128 = 5870000000000000000000;

    fn get_context(predecessor_account_id: AccountId) -> VMContextBuilder {
        let mut builder = VMContextBuilder::new();
        builder
            .current_account_id(accounts(0))
            .signer_account_id(predecessor_account_id.clone())
            .predecessor_account_id(predecessor_account_id);
        builder
    }

    fn sample_token_metadata() -> TokenMetadata {
        TokenMetadata {
            title: Some("Olympus Mons".into()),
            description: Some("The tallest mountain in the charted solar system".into()),
            media: None,
            media_hash: None,
            copies: Some(1u64),
            issued_at: None,
            expires_at: None,
            starts_at: None,
            updated_at: None,
            extra: None,
            reference: None,
            reference_hash: None,
        }
    }

    #[test]
    fn test_new() {
        let mut context = get_context(accounts(1));
        testing_env!(context.build());
        let contract = Contract::new_default_meta(accounts(1).into());
        testing_env!(context.is_view(true).build());
        assert_eq!(contract.nft_token("1".to_string()), None);
    }

    #[test]
    #[should_panic(expected = "The contract is not initialized")]
    fn test_default() {
        let context = get_context(accounts(1));
        testing_env!(context.build());
        let _contract = Contract::default();
    }

    #[test]
    fn test_mint() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(0).into());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build());

        let token_id = "0".to_string();
        let token = contract.nft_mint(token_id.clone(), accounts(0), sample_token_metadata());
        assert_eq!(token.token_id, token_id);
        assert_eq!(token.owner_id.to_string(), accounts(0).to_string());
        assert_eq!(token.metadata.unwrap(), sample_token_metadata());
        assert_eq!(token.approved_account_ids.unwrap(), HashMap::new());
    }

    #[test]
    fn test_transfer() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(0).into());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build());
        let token_id = "0".to_string();
        contract.nft_mint(token_id.clone(), accounts(0), sample_token_metadata());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(1)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_transfer(accounts(1), token_id.clone(), None, None);

        testing_env!(context
            .storage_usage(env::storage_usage())
            .account_balance(env::account_balance())
            .is_view(true)
            .attached_deposit(0)
            .build());
        if let Some(token) = contract.nft_token(token_id.clone()) {
            assert_eq!(token.token_id, token_id);
            assert_eq!(token.owner_id.to_string(), accounts(1).to_string());
            assert_eq!(token.metadata.unwrap(), sample_token_metadata());
            assert_eq!(token.approved_account_ids.unwrap(), HashMap::new());
        } else {
            panic!("token not correctly created, or not found by nft_token");
        }
    }

    #[test]
    fn test_approve() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(0).into());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build());
        let token_id = "0".to_string();
        contract.nft_mint(token_id.clone(), accounts(0), sample_token_metadata());

        // alice approves bob
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(150000000000000000000)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_approve(token_id.clone(), accounts(1), None);

        testing_env!(context
            .storage_usage(env::storage_usage())
            .account_balance(env::account_balance())
            .is_view(true)
            .attached_deposit(0)
            .build());
        assert!(contract.nft_is_approved(token_id.clone(), accounts(1), Some(1)));
    }

    #[test]
    fn test_revoke() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(0).into());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build());
        let token_id = "0".to_string();
        contract.nft_mint(token_id.clone(), accounts(0), sample_token_metadata());

        // alice approves bob
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(150000000000000000000)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_approve(token_id.clone(), accounts(1), None);

        // alice revokes bob
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(1)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_revoke(token_id.clone(), accounts(1));
        testing_env!(context
            .storage_usage(env::storage_usage())
            .account_balance(env::account_balance())
            .is_view(true)
            .attached_deposit(0)
            .build());
        assert!(!contract.nft_is_approved(token_id.clone(), accounts(1), None));
    }

    #[test]
    fn test_revoke_all() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(0).into());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build());
        let token_id = "0".to_string();
        contract.nft_mint(token_id.clone(), accounts(0), sample_token_metadata());

        // alice approves bob
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(150000000000000000000)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_approve(token_id.clone(), accounts(1), None);

        // alice revokes bob
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(1)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_revoke_all(token_id.clone());
        testing_env!(context
            .storage_usage(env::storage_usage())
            .account_balance(env::account_balance())
            .is_view(true)
            .attached_deposit(0)
            .build());
        assert!(!contract.nft_is_approved(token_id.clone(), accounts(1), Some(1)));
    }
}
'''
'''--- NFT-example/res/README.md ---
# Folder that contains wasm files
'''
'''--- NFT-example/scripts/build.bat ---
@echo off

cd ..
title NFT build
cargo build --all --target wasm32-unknown-unknown --release
xcopy %CD%\target\wasm32-unknown-unknown\release\*.wasm %CD%\res /Y
pause
'''
'''--- NFT-example/scripts/build.sh ---
#!/bin/bash
set -e
cd "`dirname $0`"/..
source scripts/flags.sh
cargo build --all --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/*.wasm ./res/
'''
'''--- NFT-example/scripts/flags.sh ---
#!/bin/bash

if [ -z "$KEEP_NAMES" ]; then
  export RUSTFLAGS='-C link-arg=-s'
else
  export RUSTFLAGS=''
fi
'''
'''--- NFT-example/test-approval-receiver/Cargo.toml ---
[package]
name = "approval-receiver"
version = "0.0.1"
authors = ["Near Inc <hello@near.org>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0"
near-contract-standards = "4.0.0"
'''
'''--- NFT-example/test-approval-receiver/src/lib.rs ---
/*!
A stub contract that implements nft_on_approve for simulation testing nft_approve.
*/
use near_contract_standards::non_fungible_token::approval::NonFungibleTokenApprovalReceiver;
use near_contract_standards::non_fungible_token::TokenId;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{
    env, ext_contract, log, near_bindgen, AccountId, PanicOnDefault,
    PromiseOrValue,
};

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct ApprovalReceiver {
    non_fungible_token_account_id: AccountId,
}

// Defining cross-contract interface. This allows to create a new promise.
#[ext_contract(ext_self)]
pub trait ValueReturnTrait {
    fn ok_go(&self, msg: String) -> PromiseOrValue<String>;
}

#[near_bindgen]
impl ApprovalReceiver {
    #[init]
    pub fn new(non_fungible_token_account_id: AccountId) -> Self {
        Self { non_fungible_token_account_id: non_fungible_token_account_id.into() }
    }
}

#[near_bindgen]
impl NonFungibleTokenApprovalReceiver for ApprovalReceiver {
    /// Could do anything useful to the approval-receiving contract, such as store the given
    /// approval_id for use later when calling the NFT contract. Can also return whatever it wants,
    /// maybe after further promise calls. This one simulates "return anything" behavior only.
    /// Supports the following `msg` patterns:
    /// * "return-now" - immediately return `"cool"`
    /// * anything else - return the given `msg` after one more cross-contract call
    fn nft_on_approve(
        &mut self,
        token_id: TokenId,
        owner_id: AccountId,
        approval_id: u64,
        msg: String,
    ) -> PromiseOrValue<String> {
        // Verifying that we were called by non-fungible token contract that we expect.
        assert_eq!(
            &env::predecessor_account_id(),
            &self.non_fungible_token_account_id,
            "Only supports the one non-fungible token contract"
        );
        log!(
            "in nft_on_approve; sender_id={}, previous_owner_id={}, token_id={}, msg={}",
            &token_id,
            &owner_id,
            &approval_id,
            msg
        );
        match msg.as_str() {
            "return-now" => PromiseOrValue::Value("cool".to_string()),
            _ => {
                // Call ok_go with no attached deposit and all unspent GAS (weight of 1)
                Self::ext(env::current_account_id())
                    .ok_go(msg).into()
            }
        }
    }
}

#[near_bindgen]
impl ValueReturnTrait for ApprovalReceiver {
    fn ok_go(&self, msg: String) -> PromiseOrValue<String> {
        log!("in ok_go, msg={}", msg);
        PromiseOrValue::Value(msg)
    }
}
'''
'''--- NFT-example/test-token-receiver/Cargo.toml ---
[package]
name = "token-receiver"
version = "0.0.1"
authors = ["Near Inc <hello@near.org>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0"
near-contract-standards = "4.0.0"
'''
'''--- NFT-example/test-token-receiver/src/lib.rs ---
/*!
A stub contract that implements nft_on_transfer for simulation testing nft_transfer_call.
*/
use near_contract_standards::non_fungible_token::core::NonFungibleTokenReceiver;
use near_contract_standards::non_fungible_token::TokenId;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{
    env, ext_contract, log, near_bindgen, AccountId, PanicOnDefault,
    PromiseOrValue,
};
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct TokenReceiver {
    non_fungible_token_account_id: AccountId,
}

// Defining cross-contract interface. This allows to create a new promise.
#[ext_contract(ext_self)]
pub trait ValueReturnTrait {
    fn ok_go(&self, return_it: bool) -> PromiseOrValue<bool>;
}

#[near_bindgen]
impl TokenReceiver {
    #[init]
    pub fn new(non_fungible_token_account_id: AccountId) -> Self {
        Self { non_fungible_token_account_id: non_fungible_token_account_id.into() }
    }
}

#[near_bindgen]
impl NonFungibleTokenReceiver for TokenReceiver {
    /// Returns true if token should be returned to `sender_id`
    /// Four supported `msg`s:
    /// * "return-it-now" - immediately return `true`
    /// * "keep-it-now" - immediately return `false`
    /// * "return-it-later" - make cross-contract call which resolves with `true`
    /// * "keep-it-later" - make cross-contract call which resolves with `false`
    /// Otherwise panics, which should also return token to `sender_id`
    fn nft_on_transfer(
        &mut self,
        sender_id: AccountId,
        previous_owner_id: AccountId,
        token_id: TokenId,
        msg: String,
    ) -> PromiseOrValue<bool> {
        // Verifying that we were called by non-fungible token contract that we expect.
        assert_eq!(
            &env::predecessor_account_id(),
            &self.non_fungible_token_account_id,
            "Only supports the one non-fungible token contract"
        );
        log!(
            "in nft_on_transfer; sender_id={}, previous_owner_id={}, token_id={}, msg={}",
            &sender_id,
            &previous_owner_id,
            &token_id,
            msg
        );
        match msg.as_str() {
            "return-it-now" => PromiseOrValue::Value(true),
            "return-it-later" => {
                // Call ok_go with no attached deposit and all unspent GAS (weight of 1)
                Self::ext(env::current_account_id())
                    .ok_go(true).into()
            }
            "keep-it-now" => PromiseOrValue::Value(false),
            "keep-it-later" => {
                // Call ok_go with no attached deposit and all unspent GAS (weight of 1)
                Self::ext(env::current_account_id())
                    .ok_go(false).into()
            }
            _ => env::panic_str("unsupported msg"),
        }
    }
}

#[near_bindgen]
impl ValueReturnTrait for TokenReceiver {
    fn ok_go(&self, return_it: bool) -> PromiseOrValue<bool> {
        log!("in ok_go, return_it={}", return_it);
        PromiseOrValue::Value(return_it)
    }
}
'''
'''--- README.md ---
# NFT Examples

This repository contains an example of an NFT smart contract in Rust and tutorials on how to create them for both JavaScript and Rust.

## Repositories

- [NFT Smart Contract in Rust](NFT-example)
- [NFT Contract in Rust Tutorial](nft-tutorial)
- [NFT Contract in JavaScript Tutorial](nft-tutorial-js)

'''
'''--- nft-tutorial-js/.github/workflows/tests.yml ---
name: Tests
on: push
jobs:
  workflows:
    strategy:
      matrix:
        platform: [ubuntu-latest, macos-latest]
    runs-on: ${{ matrix.platform }}
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v2
        with:
          node-version: "16"
      - name: Install modules
        run: yarn
      - name: Build contract
        run: yarn build
      - name: Run tests
        run: yarn test

'''
'''--- nft-tutorial-js/README.md ---
# NEAR NFT-Tutorial JavaScript Edition

[![](https://img.shields.io/github/workflow/status/near-examples/nft-tutorial-js/Tests/master?label=Tests)](https://github.com/near-examples/nft-tutorial-js/actions/workflows/tests.yml)

Welcome to NEAR's NFT tutorial, where we will help you parse the details around NEAR's [NEP-171 standard](https://nomicon.io/Standards/NonFungibleToken/Core.html) (Non-Fungible Token Standard), and show you how to build your own NFT smart contract from the ground up, improving your understanding about the NFT standard along the way. 

## Prerequisites

* [Node.js](/develop/prerequisites#nodejs)
* [NEAR Wallet Account](wallet.testnet.near.org)
* [NEAR-CLI](https://docs.near.org/tools/near-cli#setup)
* [yarn](https://classic.yarnpkg.com/en/docs/install#mac-stable)

## Tutorial Stages 

Each branch you will find in this repo corresponds to various stages of this tutorial with a partially completed contract at each stage. You are welcome to start from any stage you want to learn the most about. 

| Branch        | Docs Tutorial                                                                                    | Description |
| ------------- | ------------------------------------------------------------------------------------------------ | ----------- |
| 1.skeleton    | [Contract Architecture](https://docs.near.org/docs/tutorials/contracts/nfts/js/skeleton) | You'll learn the basic architecture of the NFT smart contract.            |
| 2.minting     | [Minting](https://docs.near.org/docs/tutorials/contracts/nfts/js/minting)                |Here you'll flesh out the skeleton so the smart contract can mint a non-fungible token             |
| 3.enumeration | [Enumeration](https://docs.near.org/docs/tutorials/contracts/nfts/js/enumeration)        |    Here you'll find different enumeration methods that can be used to return the smart contract's states.          |
| 4.core        | [Core](https://docs.near.org/docs/tutorials/contracts/nfts/js/core)                      | In this tutorial you'll extend the NFT contract using the core standard, which will allow you to transfer non-fungible tokens.             |
| 5.approval    | [Approval](https://docs.near.org/docs/tutorials/contracts/nfts/js/approvals)             | Here you'll expand the contract allowing other accounts to transfer NFTs on your behalf.            |
| 6.royalty     | [Royalty](https://docs.near.org/docs/tutorials/contracts/nfts/js/royalty)                                                                                        |Here you'll add the ability for non-fungible tokens to have royalties. This will allow people to get a percentage of the purchase price when an NFT is purchased.             |
| 7.events      | -----------                                                                                        |   This allows indexers to know what functions are being called and make it easier and more reliable to keep track of information that can be used to populate the collectibles tab in the wallet for example. (tutorial docs have yet to be implemented )          |
| 8.marketplace | -----------                                                                                      | -----------             |

The tutorial series also contains a very helpful section on [**Upgrading Smart Contracts**](https://docs.near.org/docs/tutorials/contracts/nfts/js/upgrade-contract). Definitely go and check it out as this is a common pain point.

# Quick-Start 

If you want to see the full completed contract go ahead and clone and build this repo using 

```=bash
git clone https://github.com/near-examples/nft-tutorial-js.git 
cd nft-tutorial-js
yarn && yarn build
```

Now that you've cloned and built the contract we can try a few things. 

## Mint An NFT

Once you've created your near wallet go ahead and login to your wallet with your cli and follow the on-screen prompts

```=bash
near login
```

Once your logged in you have to deploy the contract. Make a subaccount with the name of your choosing 

```=bash 
near create-account nft-example.your-account.testnet --masterAccount your-account.testnet --initialBalance 10
```

After you've created your sub account deploy the contract to that sub account, set this variable to your sub account name

```=bash
NFT_CONTRACT_ID=nft-example.your-account.testnet

MAIN_ACCOUNT=your-account.testnet
```

Verify your new variable has the correct value
```=bash
echo $NFT_CONTRACT_ID

echo $MAIN_ACCOUNT
```

### Deploy Your Contract
```=bash
near deploy --accountId $NFT_CONTRACT_ID --wasmFile build/nft.wasm
```

### Initialize Your Contract 

```=bash
near call $NFT_CONTRACT_ID init '{"owner_id": "'$NFT_CONTRACT_ID'"}' --accountId $NFT_CONTRACT_ID
```

### View Contracts Meta Data

```=bash
near view $NFT_CONTRACT_ID nft_metadata
```
### Minting Token

```bash=
near call $NFT_CONTRACT_ID nft_mint '{"token_id": "token-1", "metadata": {"title": "My Non Fungible Team Token", "description": "The Team Most Certainly Goes :)", "media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif"}, "receiver_id": "'$MAIN_ACCOUNT'"}' --accountId $MAIN_ACCOUNT --amount 0.1
```

After you've minted the token go to wallet.testnet.near.org to `your-account.testnet` and look in the collections tab and check out your new sample NFT! 

## View NFT Information

After you've minted your NFT you can make a view call to get a response containing the `token_id` `owner_id` and the `metadata`

```bash=
near view $NFT_CONTRACT_ID nft_token '{"token_id": "token-1"}'
```

## Transfering NFTs

To transfer an NFT go ahead and make another [testnet wallet account](https://wallet.testnet.near.org).

Then run the following
```bash=
MAIN_ACCOUNT_2=your-second-wallet-account.testnet
```

Verify the correct variable names with this

```=bash
echo $NFT_CONTRACT_ID

echo $MAIN_ACCOUNT

echo $MAIN_ACCOUNT_2
```

To initiate the transfer..

```bash=
near call $NFT_CONTRACT_ID nft_transfer '{"receiver_id": "$MAIN_ACCOUNT_2", "token_id": "token-1", "memo": "Go Team :)"}' --accountId $MAIN_ACCOUNT --depositYocto 1
```

In this call you are depositing 1 yoctoNEAR for security and so that the user will be redirected to the NEAR wallet.
'''
'''--- nft-tutorial-js/__tests__/test-template.ava.js ---
import { Worker } from 'near-workspaces';
import test from 'ava';

test.beforeEach(async t => {
    // Init the worker and start a Sandbox server
    const worker = await Worker.init();

    // Prepare sandbox for tests, create accounts, deploy contracts, etc.
    const root = worker.rootAccount;

    // Deploy the counter contract.
    const counter = await root.createAndDeploy(
        root.getSubAccount('counter').accountId,
        './build/contract.wasm'
    );

    // Init the contract
    await counter.call(counter, 'init', {});

    // Test users
    const ali = await root.createSubAccount('ali');
    const bob = await root.createSubAccount('bob');

    // Save state for test runs
    t.context.worker = worker;
    t.context.accounts = { root, counter, ali, bob };
});

// If the environment is reused, use test.after to replace test.afterEach
test.afterEach(async t => {
    await t.context.worker.tearDown().catch(error => {
        console.log('Failed to tear down the worker:', error);
    });
});

test('Initial count is 0', async t => {
    const { counter } = t.context.accounts;
    const result = await counter.view('getCount', {});
    t.is(result, 0);
});

test('Increase works', async t => {
    const { counter, ali, bob } = t.context.accounts;
    await ali.call(counter, 'increase', {});

    let result = await counter.view('getCount', {});
    t.is(result, 1);

    await bob.call(counter, 'increase', { n: 4 });
    result = await counter.view('getCount', {});
    t.is(result, 5);
});

test('Decrease works', async t => {
    const { counter, ali, bob } = t.context.accounts;
    await ali.call(counter, 'decrease', {});

    let result = await counter.view('getCount', {});
    t.is(result, -1);

    await bob.call(counter, 'decrease', { n: 4 });
    result = await counter.view('getCount', {});
    t.is(result, -5);
});
'''
'''--- nft-tutorial-js/babel.config.json ---
{
  "plugins": [
    "near-sdk-js/lib/build-tools/near-bindgen-exporter",
    ["@babel/plugin-proposal-decorators", {"version": "legacy"}]
  ],
  "presets": ["@babel/preset-typescript"]
}
'''
'''--- nft-tutorial-js/commands.txt ---
near dev-deploy build/contract.wasm -f && source ./neardev/dev-account.env && near call $CONTRACT_NAME init '{"owner_id": "'$CONTRACT_NAME'"}' --accountId $CONTRACT_NAME && near call $CONTRACT_NAME nft_mint '{"token_id": "token-1", "metadata": {"title": "My Non Fungible Team Token", "description": "The Team Most Certainly Goes :)", "media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif"}, "receiver_id": "'$CONTRACT_NAME'"}' --accountId $CONTRACT_NAME --amount 0.1 

near call $CONTRACT_NAME nft_transfer '{"receiver_id": "benji.fayyr.testnet", "token_id": "token-1"}' --accountId $CONTRACT_NAME --depositYocto 1
'''
'''--- nft-tutorial-js/jsconfig.json ---
{
    "compilerOptions": {
        "experimentalDecorators": true,
    },
    "exclude": [
        "node_modules"
    ],
}
'''
'''--- nft-tutorial-js/neardev/dev-account.env ---
CONTRACT_NAME=dev-1659879671058-26952029212531
'''
'''--- nft-tutorial-js/package.json ---
{
  "name": "template",
  "version": "1.0.0",
  "description": "Contract template with near-sdk-js",
  "main": "index.js",
  "type": "module",
  "scripts": {
    "build": "yarn build:nft && yarn build:market",
    "build:nft": "near-sdk-js build src/nft-contract/index.ts build/nft.wasm",
    "build:market": "near-sdk-js build src/market-contract/index.ts build/market.wasm",
    "test": "ava"
  },
  "author": "Near Inc <hello@nearprotocol.com>",
  "license": "Apache-2.0",
  "dependencies": {
    "near-sdk-js": "0.4.0-5",
    "lodash-es": "^4.17.21"
  },
  "devDependencies": {
    "typescript": "^4.7.4"
  }
}

'''
'''--- nft-tutorial-js/src/market-contract/index.ts ---
import { NearContract, NearBindgen, near, call, view, LookupMap, UnorderedMap, Vector, UnorderedSet, assert } from 'near-sdk-js'
import { assertOneYocto, restoreOwners } from './internal';
import { internalNftOnApprove } from './nft_callbacks';
import { internalOffer, internalRemoveSale, internalResolvePurchase, internalUpdatePrice, Sale } from './sale';
import { internalGetSale, internalSalesByNftContractId, internalSalesByOwnerId, internalSupplyByNftContractId, internalSupplyByOwnerId, internalSupplySales } from './sale_views';

/// This spec can be treated like a version of the standard.
export const NFT_METADATA_SPEC = "nft-1.0.0";

/// This is the name of the NFT standard we're using
export const NFT_STANDARD_NAME = "nep171";

//the minimum storage to have a sale on the contract.
export const STORAGE_PER_SALE: bigint = BigInt(1000) * near.storageByteCost().valueOf();

//every sale will have a unique ID which is `CONTRACT + DELIMITER + TOKEN_ID`
export const DELIMETER = ".";

@NearBindgen
export class Contract extends NearContract {
    //keep track of the owner of the contract
    ownerId: string;
    
    /*
        to keep track of the sales, we map the ContractAndTokenId to a Sale. 
        the ContractAndTokenId is the unique identifier for every sale. It is made
        up of the `contract ID + DELIMITER + token ID`
    */
    sales: UnorderedMap;
    
    //keep track of all the Sale IDs for every account ID
    byOwnerId: LookupMap;

    //keep track of all the token IDs for sale for a given contract
    byNftContractId: LookupMap;

    //keep track of the storage that accounts have payed
    storageDeposits: LookupMap;

    /*
        initialization function (can only be called once).
        this initializes the contract with metadata that was passed in and
        the owner_id. 
    */
    constructor({ owner_id }: { owner_id: string }) {
        super()
        this.ownerId = owner_id;
        this.sales = new UnorderedMap("sales");
        this.byOwnerId = new LookupMap("byOwnerId");
        this.byNftContractId = new LookupMap("byNftContractId");
        this.storageDeposits = new LookupMap("storageDeposits");
    }

    default() {
        return new Contract({owner_id: ''})
    }

    /*
        STORAGE
    */
    @call
    //Allows users to deposit storage. This is to cover the cost of storing sale objects on the contract
    //Optional account ID is to users can pay for storage for other people.
    storage_deposit({ account_id }: { account_id?: string }) {
        //get the account ID to pay for storage for
        let storageAccountId = account_id || near.predecessorAccountId();

        //get the deposit value which is how much the user wants to add to their storage
        let deposit = near.attachedDeposit().valueOf();

        //make sure the deposit is greater than or equal to the minimum storage for a sale
        assert(deposit >= STORAGE_PER_SALE, `Requires minimum deposit of ${STORAGE_PER_SALE}`);

        //get the balance of the account (if the account isn't in the map we default to a balance of 0)
        let balance: string = this.storageDeposits.get(storageAccountId) as string || "0";
        //add the deposit to their balance
        let newBalance = BigInt(balance) + deposit;
        //insert the balance back into the map for that account ID
        this.storageDeposits.set(storageAccountId, newBalance.toString());
    }

    @call
    //Allows users to withdraw any excess storage that they're not using. Say Bob pays 0.01N for 1 sale
    //Alice then buys Bob's token. This means bob has paid 0.01N for a sale that's no longer on the marketplace
    //Bob could then withdraw this 0.01N back into his account. 
    storage_withdraw() {
        //make sure the user attaches exactly 1 yoctoNEAR for security purposes.
        //this will redirect them to the NEAR wallet (or requires a full access key). 
        assertOneYocto();

        //the account to withdraw storage to is always the function caller
        let ownerId = near.predecessorAccountId();
        //get the amount that the user has by removing them from the map. If they're not in the map, default to 0
        let amount: string = this.storageDeposits.remove(ownerId) as string || "0";
        
        //how many sales is that user taking up currently. This returns a set
        let sales = restoreOwners(this.byOwnerId.get(ownerId));
        //get the length of that set. 
        let len = 0;
        if (sales != null) {
            len = sales.len();
        }   
        
        //how much NEAR is being used up for all the current sales on the account 
        let diff = BigInt(len) * STORAGE_PER_SALE;
        //the excess to withdraw is the total storage paid - storage being used up.
        let amountLeft = BigInt(amount) - diff;

        //if that excess to withdraw is > 0, we transfer the amount to the user.
        if (amountLeft > 0) {
            const promise = near.promiseBatchCreate(ownerId);
            near.promiseBatchActionTransfer(promise, amountLeft)
        }

        //we need to add back the storage being used up into the map if it's greater than 0.
        //this is so that if the user had 500 sales on the market, we insert that value here so
        //if those sales get taken down, the user can then go and withdraw 500 sales worth of storage.
        if (diff > 0) {
            this.storageDeposits.set(ownerId, diff.toString());
        }
    }

    @view
    //return the minimum storage for 1 sale
    storage_minimum_balance(): string {
        return STORAGE_PER_SALE.toString()
    }

    @view
    //return how much storage an account has paid for
    storage_balance_of({ account_id }: { account_id: string}): string {
        return this.storageDeposits.get(account_id) as string || "0";
    }

    /*
        SALES
    */
    @call
    //removes a sale from the market. 
    remove_sale({nft_contract_id, token_id}:{nft_contract_id: string, token_id: string}) {
        return internalRemoveSale({contract: this, nftContractId: nft_contract_id, tokenId: token_id});
    }

    @call
    //updates the price for a sale on the market
    update_price({nft_contract_id, token_id, price}:{nft_contract_id: string, token_id: string, price: string}) {
        return internalUpdatePrice({contract: this, nftContractId: nft_contract_id, tokenId: token_id, price: price});
    }

    @call
    //place an offer on a specific sale. The sale will go through as long as your deposit is greater than or equal to the list price
    offer({nft_contract_id, token_id}:{nft_contract_id: string, token_id: string}) {
        return internalOffer({contract: this, nftContractId: nft_contract_id, tokenId: token_id});
    }

    @call
    //place an offer on a specific sale. The sale will go through as long as your deposit is greater than or equal to the list price
    resolve_purchase({buyer_id, price}:{buyer_id: string, price: string}) {
        return internalResolvePurchase({buyerId: buyer_id, price: price});
    }

    /*
        SALE VIEWS
    */
    @view
    //returns the number of sales the marketplace has up (as a string)
    get_supply_sales(): string {
        return internalSupplySales({contract: this});
    }

    @view
    //returns the number of sales for a given account (result is a string)
    get_supply_by_owner_id({account_id}:{account_id: string}): string {
        return internalSupplyByOwnerId({contract: this, accountId: account_id});
    }

    @view
    //returns paginated sale objects for a given account. (result is a vector of sales)
    get_sales_by_owner_id({account_id, from_index, limit}:{account_id: string, from_index?: string, limit?: number}): Sale[] {
        return internalSalesByOwnerId({contract: this, accountId: account_id, fromIndex: from_index, limit: limit});
    }

    @view
    //returns paginated sale objects for a given account. (result is a vector of sales)
    get_supply_by_nft_contract_id({nft_contract_id}:{nft_contract_id: string}): string {
        return internalSupplyByNftContractId({contract: this, nftContractId: nft_contract_id});        
    }

    @view
    //returns paginated sale objects associated with a given nft contract. (result is a vector of sales)
    get_sales_by_nft_contract_id({nft_contract_id, from_index, limit}:{nft_contract_id: string, from_index?: string, limit?: number}): Sale[] {
        return internalSalesByNftContractId({contract: this, accountId: nft_contract_id, fromIndex: from_index, limit: limit});
    }

    @view
    //get a sale information for a given unique sale ID (contract + DELIMITER + token ID)
    get_sale({nft_contract_token}:{nft_contract_token: string}): Sale {
        return internalGetSale({contract: this, nftContractToken: nft_contract_token});
    }

    /*
        APPROVALS
    */
    @call
        /// where we add the sale because we know nft owner can only call nft_approve
        nft_on_approve({token_id, owner_id, approval_id, msg}:{token_id: string, owner_id: string, approval_id: number, msg: string}) {
        return internalNftOnApprove({contract: this, tokenId: token_id, ownerId: owner_id, approvalId: approval_id, msg: msg});
    }  

}
'''
'''--- nft-tutorial-js/src/market-contract/internal.ts ---
import { assert, near, UnorderedSet } from "near-sdk-js";
import { Contract, DELIMETER } from ".";
import { Sale } from "./sale";

export function restoreOwners(collection) {
    if (collection == null) {
        return null;
    }
    return UnorderedSet.deserialize(collection as UnorderedSet);
}

//used to make sure the user attached exactly 1 yoctoNEAR
export function assertOneYocto() {
    assert(near.attachedDeposit().toString() === "1", "Requires attached deposit of exactly 1 yoctoNEAR");
}

//internal method for removing a sale from the market. This returns the previously removed sale object
export function internallyRemoveSale(contract: Contract, nftContractId: string, tokenId: string): Sale {
    //get the unique sale ID (contract + DELIMITER + token ID)
    let contractAndTokenId = `${nftContractId}${DELIMETER}${tokenId}`;
    //get the sale object by removing the unique sale ID. If there was no sale, panic
    let sale = contract.sales.remove(contractAndTokenId) as Sale;
    if (sale == null) {
        near.panic("no sale");
    }
    
    //get the set of sales for the sale's owner. If there's no sale, panic. 
    let byOwnerId = restoreOwners(contract.byOwnerId.get(sale.owner_id));
    if (byOwnerId == null) {
        near.panic("no sales by owner");
    }
    //remove the unique sale ID from the set of sales
    byOwnerId.remove(contractAndTokenId);

    //if the set of sales is now empty after removing the unique sale ID, we simply remove that owner from the map
    if (byOwnerId.isEmpty()) {
        contract.byOwnerId.remove(sale.owner_id);
    //if the set of sales is not empty after removing, we insert the set back into the map for the owner
    } else {
        contract.byOwnerId.set(sale.owner_id, byOwnerId);
    }

    //get the set of token IDs for sale for the nft contract ID. If there's no sale, panic. 
    let byNftContractId = restoreOwners(contract.byNftContractId.get(nftContractId));
    if (byNftContractId == null) {
        near.panic("no sales by nft contract");
    }
    
    //remove the token ID from the set 
    byNftContractId.remove(tokenId);
    //if the set is now empty after removing the token ID, we remove that nft contract ID from the map
    if (byNftContractId.isEmpty()) {
        contract.byNftContractId.remove(nftContractId);
    //if the set is not empty after removing, we insert the set back into the map for the nft contract ID
    } else {
        contract.byNftContractId.set(nftContractId, byNftContractId);
    }

    //return the sale object
    return sale;
}
'''
'''--- nft-tutorial-js/src/market-contract/nft_callbacks.ts ---
import { assert, near, UnorderedSet } from "near-sdk-js";
import { Contract, DELIMETER } from ".";
import { Sale } from "./sale";
import { internalSupplyByOwnerId } from "./sale_views";

/// where we add the sale because we know nft owner can only call nft_approve
export function internalNftOnApprove({
    contract,
    tokenId,
    ownerId,
    approvalId,
    msg
}:{ 
    contract: Contract, 
    tokenId: string, 
    ownerId: string, 
    approvalId: number, 
    msg: string 
}) {
    // get the contract ID which is the predecessor
    let contractId = near.predecessorAccountId();
    //get the signer which is the person who initiated the transaction
    let signerId = near.signerAccountId();
    
    //make sure that the signer isn't the predecessor. This is so that we're sure
    //this was called via a cross-contract call
    assert(signerId != contractId, "this function can only be called via a cross-contract call");
    //make sure the owner ID is the signer. 
    assert(ownerId == signerId, "only the owner of the token can approve it");
    
    //we need to enforce that the user has enough storage for 1 EXTRA sale.  
    let storageAmount = contract.storage_minimum_balance();
    //get the total storage paid by the owner
    let ownerPaidStorage = contract.storageDeposits.get(signerId) || BigInt(0);
    //get the storage required which is simply the storage for the number of sales they have + 1 
    let signerStorageRequired = (BigInt(internalSupplyByOwnerId({contract, accountId: signerId})) + BigInt(1)) * BigInt(storageAmount); 
    
    //make sure that the total paid is >= the required storage
    assert(ownerPaidStorage >= signerStorageRequired, "the owner does not have enough storage to approve this token");
    
    //if all these checks pass we can create the sale conditions object.
    let saleConditions = JSON.parse(msg);
    if (!saleConditions.hasOwnProperty('sale_conditions') || Object.keys(saleConditions).length != 1) {
        near.panic("invalid sale conditions");
    }
    //create the unique sale ID which is the contract + DELIMITER + token ID
    let contractAndTokenId = `${contractId}${DELIMETER}${tokenId}`;
    
    //insert the key value pair into the sales map. Key is the unique ID. value is the sale object
    contract.sales.set(contractAndTokenId, new Sale({
        ownerId: ownerId, //owner of the sale / token
        approvalId: approvalId, //approval ID for that token that was given to the market
        nftContractId: contractId, //NFT contract the token was minted on
        tokenId: tokenId, //the actual token ID
        saleConditions: saleConditions.sale_conditions //the sale conditions 
    }));

    //Extra functionality that populates collections necessary for the view calls 
    //get the sales by owner ID for the given owner. If there are none, we create a new empty set
    let byOwnerId = contract.byOwnerId.get(ownerId) as UnorderedSet || new UnorderedSet(ownerId);
    //insert the unique sale ID into the set
    byOwnerId.set(contractAndTokenId);
    //insert that set back into the collection for the owner
    contract.byOwnerId.set(ownerId, byOwnerId);
    
    //get the token IDs for the given nft contract ID. If there are none, we create a new empty set
    let byNftContractId = contract.byNftContractId.get(contractId) as UnorderedSet || new UnorderedSet(contractId);
    //insert the token ID into the set
    byNftContractId.set(tokenId);
    //insert the set back into the collection for the given nft contract ID
    contract.byNftContractId.set(contractId, byNftContractId);

}
'''
'''--- nft-tutorial-js/src/market-contract/sale.ts ---
import { assert, bytes, near } from "near-sdk-js";
import { Contract, DELIMETER } from ".";
import { assertOneYocto, internallyRemoveSale } from "./internal";

//GAS constants to attach to calls
const GAS_FOR_ROYALTIES = 115_000_000_000_000;
const GAS_FOR_NFT_TRANSFER = 15_000_000_000_000;

//struct that holds important information about each sale on the market
export class Sale {
    //owner of the sale
    owner_id: string;
    //market contract's approval ID to transfer the token on behalf of the owner
    approval_id: number;
    //nft contract where the token was minted
    nft_contract_id: string;
    //actual token ID for sale
    token_id: String;
    //sale price in yoctoNEAR that the token is listed for
    sale_conditions: string;
    
    constructor(
        {
            ownerId,
            approvalId,
            nftContractId,
            tokenId,
            saleConditions,
        }:{ 
            ownerId: string,
            approvalId: number,
            nftContractId: string,
            tokenId: String,
            saleConditions: string,
        }) {
        this.owner_id = ownerId;
        this.approval_id = approvalId;
        this.nft_contract_id = nftContractId;
        this.token_id = tokenId;
        this.sale_conditions = saleConditions;
    }
}

//removes a sale from the market. 
export function internalRemoveSale({
    contract,
    nftContractId,
    tokenId
}:{ 
    contract: Contract, 
    nftContractId: string, 
    tokenId: string 
}) {
    //assert that the user has attached exactly 1 yoctoNEAR (for security reasons)
    assertOneYocto();
    
    //get the sale object as the return value from removing the sale internally
    let sale = internallyRemoveSale(contract, nftContractId, tokenId);

    //get the predecessor of the call and make sure they're the owner of the sale
    let ownerId = near.predecessorAccountId();

    //assert that the owner of the sale is the same as the caller of the function
    assert(ownerId == sale.owner_id, "only the owner of the sale can remove it");
}

//updates the price for a sale on the market
export function internalUpdatePrice({
    contract,
    nftContractId,
    tokenId,
    price
}:{ 
    contract: Contract, 
    nftContractId: string, 
    tokenId: string, 
    price: string 
}) {
    //assert that the user has attached exactly 1 yoctoNEAR (for security reasons)
    assertOneYocto();

    //create the unique sale ID from the nft contract and token
    let contractAndTokenId = `${nftContractId}${DELIMETER}${tokenId}`;

    //get the sale object from the unique sale ID. If there is no token, panic. 
    let sale = contract.sales.get(contractAndTokenId) as Sale;
    if (sale == null) {
        near.panic("no sale");
    }

    assert(near.predecessorAccountId() == sale.owner_id, "only the owner of the sale can update it");
    //set the sale conditions equal to the passed in price
    sale.sale_conditions = price; 
    //insert the sale back into the map for the unique sale ID
    contract.sales.set(contractAndTokenId, sale);
}

//place an offer on a specific sale. The sale will go through as long as your deposit is greater than or equal to the list price
export function internalOffer({
    contract,
    nftContractId,
    tokenId
}:{
    contract: Contract, 
    nftContractId: string, 
    tokenId: string
}) {
    //get the attached deposit and make sure it's greater than 0
    let deposit = near.attachedDeposit().valueOf();
    assert(deposit > 0, "deposit must be greater than 0");
 
    //get the unique sale ID (contract + DELIMITER + token ID)
    let contractAndTokenId = `${nftContractId}${DELIMETER}${tokenId}`;
    //get the sale object from the unique sale ID. If the sale doesn't exist, panic.
    let sale = contract.sales.get(contractAndTokenId) as Sale;
    if (sale == null) {
        near.panic("no sale");
    }

    //get the buyer ID which is the person who called the function and make sure they're not the owner of the sale
    let buyerId = near.predecessorAccountId();
    assert(buyerId != sale.owner_id, "you can't offer on your own sale");

    //get the u128 price of the token (dot 0 converts from U128 to u128)
    let price = BigInt(sale.sale_conditions);
    //make sure the deposit is greater than the price
    assert(deposit >= price, "deposit must be greater than or equal to price");
    
    //process the purchase (which will remove the sale, transfer and get the payout from the nft contract, and then distribute royalties) 
    processPurchase({contract, nftContractId, tokenId, price: deposit.toString(), buyerId});
}

//private function used when a sale is purchased. 
//this will remove the sale, transfer and get the payout from the nft contract, and then distribute royalties
export function processPurchase({
    contract,
    nftContractId,
    tokenId,
    price,
    buyerId
}:{
    contract: Contract, 
    nftContractId: string, 
    tokenId: string, 
    price: string, 
    buyerId: string
}) {
    //get the sale object by removing the sale
    let sale = internallyRemoveSale(contract, nftContractId, tokenId);

    //initiate a cross contract call to the nft contract. This will transfer the token to the buyer and return
    //a payout object used for the market to distribute funds to the appropriate accounts.
    const promise = near.promiseBatchCreate(nftContractId);
    near.promiseBatchActionFunctionCall(
        promise, 
        "nft_transfer_payout", 
        bytes(JSON.stringify({ 
                receiver_id: buyerId, //purchaser (person to transfer the NFT to)
                token_id: tokenId, //token ID to transfer
                approval_id: sale.approval_id, //market contract's approval ID in order to transfer the token on behalf of the owner
                memo: "payout from market", //memo (to include some context)
                /*
                    the price that the token was purchased for. This will be used in conjunction with the royalty percentages
                    for the token in order to determine how much money should go to which account. 
                */
                balance: price, 
                max_len_payout : 10 //the maximum amount of accounts the market can payout at once (this is limited by GAS)
        })), 
        1, // 1 yoctoNEAR
        GAS_FOR_NFT_TRANSFER
    );

    //after the transfer payout has been initiated, we resolve the promise by calling our own resolve_purchase function. 
    //resolve purchase will take the payout object returned from the nft_transfer_payout and actually pay the accounts
    near.promiseThen(
        promise, 
        near.currentAccountId(), 
        "resolve_purchase", 
        bytes(JSON.stringify({
            buyer_id: buyerId, //the buyer and price are passed in incase something goes wrong and we need to refund the buyer
            price: price
        })), 
        0, // no deposit 
        GAS_FOR_ROYALTIES
    );
    return near.promiseReturn(promise);
}

/*
    private method used to resolve the promise when calling nft_transfer_payout. This will take the payout object and 
    check to see if it's authentic and there's no problems. If everything is fine, it will pay the accounts. If there's a problem,
    it will refund the buyer for the price. 
*/
export function internalResolvePurchase({
    buyerId,
    price
}:{
    buyerId: string, 
    price: string
}) {
    assert(near.currentAccountId() === near.predecessorAccountId(), "Only the contract itself can call this method");

    // checking for payout information returned from the nft_transfer_payout method
    let result = near.promiseResult(0);
    let payout = null;
    if (typeof result === 'string') {
        //if we set the payout_option to None, that means something went wrong and we should refund the buyer
        
        try {
            let payoutOption = JSON.parse(result);
            if (Object.keys(payoutOption.payout).length > 10 || Object.keys(payoutOption.payout).length < 1) {
                //we'll check if length of the payout object is > 10 or it's empty. In either case, we return None
                throw "Cannot have more than 10 royalties";
            //if the payout object is the correct length, we move forward
            } else {
                //we'll keep track of how much the nft contract wants us to payout. Starting at the full price payed by the buyer
                let remainder = BigInt(price);
                //loop through the payout and subtract the values from the remainder. 
                Object.entries(payoutOption.payout).forEach(([key, value], index) => {
                    remainder = remainder - BigInt(value as string);
                });

                //Check to see if the NFT contract sent back a faulty payout that requires us to pay more or too little. 
                //The remainder will be 0 if the payout summed to the total price. The remainder will be 1 if the royalties
                //we something like 3333 + 3333 + 3333.
                if (remainder == BigInt(0) || remainder == BigInt(1)) {
                    //set the payout because nothing went wrong
                    payout = payoutOption.payout;
                } else {
                    //if the remainder was anything but 1 or 0, we return None
                    throw "Payout is not correct";
                }
            }
        } catch (e) {
            near.log(`error parsing payout object ${result}`);
            payout = null;
        }
    }
    
    //if the payout was null, we refund the buyer for the price they payed and return
    if (payout == null) {
        const promise = near.promiseBatchCreate(buyerId);
        near.promiseBatchActionTransfer(promise, BigInt(price))
        return price;
    } 
    // NEAR payouts
    for (let [key, value] of Object.entries(payout)) {
        const promise = near.promiseBatchCreate(key);
        near.promiseBatchActionTransfer(promise, BigInt(value as string))
    }

    //return the price payout out
    return price;
}
'''
'''--- nft-tutorial-js/src/market-contract/sale_views.ts ---
import { Contract } from ".";
import { restoreOwners } from "./internal";
import { Sale } from "./sale";
    
//returns the number of sales the marketplace has up (as a string)
export function internalSupplySales({
    contract
}:{
    contract: Contract
}): string {
    //returns the sales object length wrapped as a string
    return contract.sales.len().toString();
}

//returns the number of sales for a given account (result is a string)
export function internalSupplyByOwnerId({
    contract,
    accountId
}:{ 
    contract: Contract, 
    accountId: string
}): string {
    //get the set of sales for the given owner Id
    let byOwnerId = restoreOwners(contract.byOwnerId.get(accountId));
    //if there as some set, we return the length but if there wasn't a set, we return 0
    if (byOwnerId == null) {
        return "0"
    }

    return byOwnerId.len().toString();
}

//returns paginated sale objects for a given account. (result is a vector of sales)
export function internalSalesByOwnerId({
    contract,
    accountId,
    fromIndex,
    limit
}:{ 
    contract: Contract, 
    accountId: string, 
    fromIndex?: string, 
    limit?: number
}): Sale[] {
    //get the set of token IDs for sale for the given account ID
    let tokenSet = restoreOwners(contract.byOwnerId.get(accountId));

    //if there was no set, we return an empty array
    if (tokenSet == null) {
        return [];
    }
    
    //where to start pagination - if we have a fromIndex, we'll use that - otherwise start from 0 index
    let start = fromIndex ? parseInt(fromIndex) : 0;
    //take the first "limit" elements in the array. If we didn't specify a limit, use 50
    let max = limit ? limit : 50;

    let keys = tokenSet.toArray();
    let sales: Sale[] = []
    for(let i = start; i < max; i++) {
        if(i >= keys.length) {
            break;
        }
        let sale = contract.sales.get(keys[i]) as Sale; 
        if (sale != null) {
            sales.push(sale);
        }
    }
    return sales;
}

//get the number of sales for an nft contract. (returns a string)
export function internalSupplyByNftContractId({
    contract,
    nftContractId
}:{ 
    contract: Contract, 
    nftContractId: string
}): string {
    //get the set of tokens for associated with the given nft contract
    let byNftContractId = restoreOwners(contract.byNftContractId.get(nftContractId));
    //if there as some set, we return the length but if there wasn't a set, we return 0
    if (byNftContractId == null) {
        return "0"
    }

    return byNftContractId.len().toString();
}

//returns paginated sale objects associated with a given nft contract. (result is a vector of sales)
export function internalSalesByNftContractId({
    contract,
    accountId,
    fromIndex,
    limit
}:{    
    contract: Contract, 
    accountId: string, 
    fromIndex?: string, 
    limit?: number
}): Sale[] {
    //get the set of token IDs for sale for the given contract ID
    let tokenSet = restoreOwners(contract.byNftContractId.get(accountId));

    //if there was no set, we return an empty array
    if (tokenSet == null) {
        return [];
    }
    
    //where to start pagination - if we have a fromIndex, we'll use that - otherwise start from 0 index
    let start = fromIndex ? parseInt(fromIndex) : 0;
    //take the first "limit" elements in the array. If we didn't specify a limit, use 50
    let max = limit ? limit : 50;

    let keys = tokenSet.toArray();
    let sales: Sale[] = []
    for(let i = start; i < max; i++) {
        if(i >= keys.length) {
            break;
        }
        let sale = contract.sales.get(keys[i]) as Sale; 
        if (sale != null) {
            sales.push(sale);
        }
    }
    return sales;
}

//get a sale information for a given unique sale ID (contract + DELIMITER + token ID)
export function internalGetSale({
    contract,
    nftContractToken,
}:{
    contract: Contract, 
    nftContractToken: string
}): Sale {
    //try and get the sale object for the given unique sale ID. Will return an option since
    //we're not guaranteed that the unique sale ID passed in will be valid.n);
    return contract.sales.get(nftContractToken) as Sale;
}
'''
'''--- nft-tutorial-js/src/nft-contract/approval.ts ---
// @ts-nocheck
import { assert, bytes, near } from "near-sdk-js";
import { Contract, NFT_METADATA_SPEC, NFT_STANDARD_NAME } from ".";
import { assertAtLeastOneYocto, assertOneYocto, bytesForApprovedAccountId, internalAddTokenToOwner, refundDeposit, refundApprovedAccountIds, refundApprovedAccountIdsIter } from "./internal";
import { Token } from "./metadata";

const GAS_FOR_NFT_ON_APPROVE = 35_000_000_000_000;

//approve an account ID to transfer a token on your behalf
export function internalNftApprove({
    contract,
    tokenId,
    accountId,
    msg
}:{ 
    contract: Contract, 
    tokenId: string, 
    accountId: string, 
    msg: string 
}) {
    /*
        assert at least one yocto for security reasons - this will cause a redirect to the NEAR wallet.
        The user needs to attach enough to pay for storage on the contract
    */
    assertAtLeastOneYocto();

    //get the token object from the token ID
    let token = contract.tokensById.get(tokenId) as Token;
    if (token == null) {
        near.panic("no token");
    }
    //make sure that the person calling the function is the owner of the token
    assert(near.predecessorAccountId() === token.owner_id, "Predecessor must be the token owner");

    //get the next approval ID if we need a new approval
    let approvalId = token.next_approval_id;

    //check if the account has been approved already for this token
    let isNewApproval = token.approved_account_ids.hasOwnProperty(accountId);
    token.approved_account_ids[accountId] = approvalId;

    //if it was a new approval, we need to calculate how much storage is being used to add the account.
    let storageUsed = isNewApproval ? bytesForApprovedAccountId(accountId) : 0;

    //increment the token's next approval ID by 1
    token.next_approval_id += 1;
    //insert the token back into the tokens_by_id collection
    contract.tokensById.set(tokenId, token);

    //refund any excess storage attached by the user. If the user didn't attach enough, panic. 
    refundDeposit(BigInt(storageUsed));
    
    //if some message was passed into the function, we initiate a cross contract call on the
    //account we're giving access to. 
    if (msg != null) {
        // Initiating receiver's call and the callback
        const promise = near.promiseBatchCreate(accountId);
        near.promiseBatchActionFunctionCall(
            promise, 
            "nft_on_approve", 
            bytes(JSON.stringify({ 
                token_id: tokenId,
                owner_id: token.owner_id,
                approval_id: approvalId,
                msg
            })), 
            0, // no deposit 
            GAS_FOR_NFT_ON_APPROVE
        );

        near.promiseReturn(promise);
    }
}

//check if the passed in account has access to approve the token ID
export function internalNftIsApproved({
    contract,
    tokenId,
    approvedAccountId,
    approvalId
}:{ 
    contract: Contract, 
    tokenId: string,
    approvedAccountId: string, 
    approvalId: number 
}) {
    //get the token object from the token_id
    let token = contract.tokensById.get(tokenId) as Token;
    if (token == null) {
        near.panic("no token");
    }

    //get the approval number for the passed in account ID
    let approval = token.approved_account_ids[approvedAccountId];

    //if there was no approval ID found for the account ID, we simply return false
    if (approval == null) {
        return false
    }

    //if there was some approval ID found for the account ID
    //if there was no approval_id passed into the function, we simply return true
    if (approvalId == null) {
        return true
    }

    //if a specific approval_id was passed into the function
    //return if the approval ID passed in matches the actual approval ID for the account
    return approvalId == approval;
}

//revoke a specific account from transferring the token on your behalf
export function internalNftRevoke({
    contract,
    tokenId,
    accountId
}:{ 
    contract: Contract, 
    tokenId: string, 
    accountId: string 
}) {
    //assert that the user attached exactly 1 yoctoNEAR for security reasons
    assertOneYocto();

    //get the token object using the passed in token_id
    let token = contract.tokensById.get(tokenId) as Token;
    if (token == null) {
        near.panic("no token");
    }

    //get the caller of the function and assert that they are the owner of the token
    let predecessorAccountId = near.predecessorAccountId();
    assert(predecessorAccountId == token.owner_id, "only token owner can revoke");
     
    //if the account ID was in the token's approval, we remove it
    if (token.approved_account_ids.hasOwnProperty(accountId)) {
        delete token.approved_account_ids[accountId];
        
        //refund the funds released by removing the approved_account_id to the caller of the function
        refundApprovedAccountIdsIter(predecessorAccountId, [accountId]);
        
        //insert the token back into the tokens_by_id collection with the account_id removed from the approval list
        contract.tokensById.set(tokenId, token);
    }
}

//revoke all accounts from transferring the token on your behalf
export function internalNftRevokeAll({
    contract,
    tokenId
}:{ 
    contract: Contract, 
    tokenId: string 
}) {
    //assert that the caller attached exactly 1 yoctoNEAR for security
    assertOneYocto();

    //get the token object from the passed in token ID
    let token = contract.tokensById.get(tokenId) as Token;
    if (token == null) {
        near.panic("no token");
    }

    //get the caller and make sure they are the owner of the tokens
    let predecessorAccountId = near.predecessorAccountId();
    assert(predecessorAccountId == token.owner_id, "only token owner can revoke");

    //only revoke if the approved account IDs for the token is not empty
    if (token.approved_account_ids && Object.keys(token.approved_account_ids).length === 0 && Object.getPrototypeOf(token.approved_account_ids) === Object.prototype) {
        //refund the approved account IDs to the caller of the function
        refundApprovedAccountIds(predecessorAccountId, token.approved_account_ids);
        //clear the approved account IDs
        token.approved_account_ids = {};
        //insert the token back into the tokens_by_id collection with the approved account IDs cleared
        contract.tokensById.set(tokenId, token);
    }
}
'''
'''--- nft-tutorial-js/src/nft-contract/enumeration.ts ---
// @ts-nocheck
import { near, UnorderedSet } from "near-sdk-js";
import { Contract, NFT_METADATA_SPEC, NFT_STANDARD_NAME } from ".";
import { restoreOwners } from "./internal";
import { JsonToken } from "./metadata";
import { internalNftToken } from "./nft_core";

//Query for the total supply of NFTs on the contract
export function internalTotalSupply({
    contract
}:{
    contract: Contract
}): number {
    //return the length of the token metadata by ID
    return contract.tokenMetadataById.len();
}

//Query for nft tokens on the contract regardless of the owner using pagination
export function internalNftTokens({
    contract,
    fromIndex,
    limit
}:{ 
    contract: Contract, 
    fromIndex?: string, 
    limit?: number
}): JsonToken[] {
    let tokens = [];

    //where to start pagination - if we have a fromIndex, we'll use that - otherwise start from 0 index
    let start = fromIndex ? parseInt(fromIndex) : 0;
    //take the first "limit" elements in the array. If we didn't specify a limit, use 50
    let max = limit ? limit : 50;

    let keys = contract.tokenMetadataById.toArray();
    // Paginate through the keys using the fromIndex and limit
    for (let i = start; i < keys.length && i < start + max; i++) {
        // get the token object from the keys
        let jsonToken = internalNftToken({contract, tokenId: keys[i][0]});
        tokens.push(jsonToken);
    }
    return tokens;
}

//get the total supply of NFTs for a given owner
export function internalSupplyForOwner({
    contract,
    accountId
}:{
    contract: Contract, 
    accountId: string
}): number {
    //get the set of tokens for the passed in owner
    let tokens = restoreOwners(contract.tokensPerOwner.get(accountId));
    //if there isn't a set of tokens for the passed in account ID, we'll return 0
    if (tokens == null) {
        return 0
    }

    //if there is some set of tokens, we'll return the length 
    return tokens.len();
}

//Query for all the tokens for an owner
export function internalTokensForOwner({
    contract,
    accountId,
    fromIndex,
    limit
}:{
    contract: Contract, 
    accountId: string, 
    fromIndex?: string, 
    limit?: number
}): JsonToken[] {
    //get the set of tokens for the passed in owner
    let tokenSet = restoreOwners(contract.tokensPerOwner.get(accountId));

    //if there isn't a set of tokens for the passed in account ID, we'll return 0
    if (tokenSet == null) {
        return [];
    }
    
    //where to start pagination - if we have a fromIndex, we'll use that - otherwise start from 0 index
    let start = fromIndex ? parseInt(fromIndex) : 0;
    //take the first "limit" elements in the array. If we didn't specify a limit, use 50
    let max = limit ? limit : 50;

    let keys = tokenSet.toArray();
    let tokens: JsonToken[] = []
    for(let i = start; i < max; i++) {
        if(i >= keys.length) {
            break;
        }
        let token = internalNftToken({contract, tokenId: keys[i]});
        tokens.push(token);
    }
    return tokens;
}
'''
'''--- nft-tutorial-js/src/nft-contract/index.ts ---

import { NearContract, NearBindgen, near, call, view, LookupMap, UnorderedMap, Vector, UnorderedSet } from 'near-sdk-js'
import { NFTContractMetadata, Token, TokenMetadata, internalNftMetadata } from './metadata';
import { internalMint } from './mint';
import { internalNftTokens, internalSupplyForOwner, internalTokensForOwner, internalTotalSupply } from './enumeration';
import { internalNftToken, internalNftTransfer, internalNftTransferCall, internalResolveTransfer } from './nft_core';
import { internalNftApprove, internalNftIsApproved, internalNftRevoke, internalNftRevokeAll } from './approval';
import { internalNftPayout, internalNftTransferPayout } from './royalty';

/// This spec can be treated like a version of the standard.
export const NFT_METADATA_SPEC = "nft-1.0.0";

/// This is the name of the NFT standard we're using
export const NFT_STANDARD_NAME = "nep171";

@NearBindgen
export class Contract extends NearContract {
    owner_id: string;
    tokensPerOwner: LookupMap;
    tokensById: LookupMap;
    tokenMetadataById: UnorderedMap;
    metadata: NFTContractMetadata;

    /*
        initialization function (can only be called once).
        this initializes the contract with metadata that was passed in and
        the owner_id. 
    */
    constructor({
        owner_id, 
        metadata = {
            spec: "nft-1.0.0",
            name: "NFT Tutorial Contract",
            symbol: "GOTEAM"
        } 
    }) {
        super()
        this.owner_id = owner_id;
        this.tokensPerOwner = new LookupMap("tokensPerOwner");
        this.tokensById = new LookupMap("tokensById");
        this.tokenMetadataById = new UnorderedMap("tokenMetadataById");
        this.metadata = metadata;
    }

    default() {
        return new Contract({owner_id: ''})
    }

    /*
        MINT
    */
    @call
    nft_mint({ token_id, metadata, receiver_id, perpetual_royalties }) {
        return internalMint({ contract: this, tokenId: token_id, metadata: metadata, receiverId: receiver_id, perpetualRoyalties: perpetual_royalties });
    }

    /*
        CORE
    */
    @view
    //get the information for a specific token ID
    nft_token({ token_id }) {
        return internalNftToken({ contract: this, tokenId: token_id });
    }

    @call
    //implementation of the nft_transfer method. This transfers the NFT from the current owner to the receiver. 
    nft_transfer({ receiver_id, token_id, approval_id, memo }) {
        return internalNftTransfer({ contract: this, receiverId: receiver_id, tokenId: token_id, approvalId: approval_id, memo: memo });
    }

    @call
    //implementation of the transfer call method. This will transfer the NFT and call a method on the receiver_id contract
    nft_transfer_call({ receiver_id, token_id, approval_id, memo, msg }) {
        return internalNftTransferCall({ contract: this, receiverId: receiver_id, tokenId: token_id, approvalId: approval_id, memo: memo, msg: msg });
    }

    @call
    //resolves the cross contract call when calling nft_on_transfer in the nft_transfer_call method
    //returns true if the token was successfully transferred to the receiver_id
    nft_resolve_transfer({ authorized_id, owner_id, receiver_id, token_id, approved_account_ids, memo }) {
        return internalResolveTransfer({ contract: this, authorizedId: authorized_id, ownerId: owner_id, receiverId: receiver_id, tokenId: token_id, approvedAccountIds: approved_account_ids, memo: memo });
    }

    /*
        APPROVALS
    */
    @view
    //check if the passed in account has access to approve the token ID
    nft_is_approved({ token_id, approved_account_id, approval_id }) {
        return internalNftIsApproved({ contract: this, tokenId: token_id, approvedAccountId: approved_account_id, approvalId: approval_id });
    }

    @call
    //approve an account ID to transfer a token on your behalf
    nft_approve({ token_id, account_id, msg }) {
        return internalNftApprove({ contract: this, tokenId: token_id, accountId: account_id, msg: msg });
    }

    /*
        ROYALTY
    */
    @view
    //calculates the payout for a token given the passed in balance. This is a view method
    nft_payout({ token_id, balance, max_len_payout }) {
        return internalNftPayout({ contract: this, tokenId: token_id, balance: balance, maxLenPayout: max_len_payout });
    }

    @call
    //transfers the token to the receiver ID and returns the payout object that should be payed given the passed in balance. 
    nft_transfer_payout({ receiver_id, token_id, approval_id, memo, balance, max_len_payout }) {
        return internalNftTransferPayout({ contract: this, receiverId: receiver_id, tokenId: token_id, approvalId: approval_id, memo: memo, balance: balance, maxLenPayout: max_len_payout });
    }

    @call
    //approve an account ID to transfer a token on your behalf
    nft_revoke({ token_id, account_id }) {
        return internalNftRevoke({ contract: this, tokenId: token_id, accountId: account_id });
    }

    @call
    //approve an account ID to transfer a token on your behalf
    nft_revoke_all({ token_id }) {
        return internalNftRevokeAll({ contract: this, tokenId: token_id });
    }

    /*
        ENUMERATION
    */
    @view
    //Query for the total supply of NFTs on the contract
    nft_total_supply() {
        return internalTotalSupply({ contract: this });
    }

    @view
    //Query for nft tokens on the contract regardless of the owner using pagination
    nft_tokens({ from_index, limit }) {
        return internalNftTokens({ contract: this, fromIndex: from_index, limit: limit });
    }

    @view
    //get the total supply of NFTs for a given owner
    nft_tokens_for_owner({ account_id, from_index, limit }) {
        return internalTokensForOwner({ contract: this, accountId: account_id, fromIndex: from_index, limit: limit });
    }

    @view
    //Query for all the tokens for an owner
    nft_supply_for_owner({ account_id }) {
        return internalSupplyForOwner({ contract: this, accountId: account_id });
    }

    /*
        METADATA
    */
    @view
    //Query for all the tokens for an owner
    nft_metadata() {
        return internalNftMetadata({ contract: this });
    }
}
'''
'''--- nft-tutorial-js/src/nft-contract/internal.ts ---
import { assert, near, UnorderedSet, Vector } from "near-sdk-js";
import { Contract, NFT_METADATA_SPEC, NFT_STANDARD_NAME } from ".";
import { Token } from "./metadata";

// Gets a collection and deserializes it into a set that can be used.
export function restoreOwners(collection) {
    if (collection == null) {
        return null;
    }
    return UnorderedSet.deserialize(collection as UnorderedSet);
}

//convert the royalty percentage and amount to pay into a payout (U128)
export function royaltyToPayout(royaltyPercentage: number, amountToPay: bigint): string {
    return (BigInt(royaltyPercentage) * BigInt(amountToPay) / BigInt(10000)).toString();
}

//refund the storage taken up by passed in approved account IDs and send the funds to the passed in account ID. 
export function refundApprovedAccountIdsIter(accountId: string, approvedAccountIds: string[]) {
    //get the storage total by going through and summing all the bytes for each approved account IDs
    let storageReleased = approvedAccountIds.map(e => bytesForApprovedAccountId(e)).reduce((partialSum, a) => partialSum + a, 0);
    let amountToTransfer = BigInt(storageReleased) * near.storageByteCost().valueOf();
    
    // Send the money to the beneficiary (TODO: don't use batch actions)
    const promise = near.promiseBatchCreate(accountId);
    near.promiseBatchActionTransfer(promise, amountToTransfer)
}

//refund a map of approved account IDs and send the funds to the passed in account ID
export function refundApprovedAccountIds(accountId: string, approvedAccountIds: { [key: string]: number }) {
    //call the refundApprovedAccountIdsIter with the approved account IDs as keys
    refundApprovedAccountIdsIter(accountId, Object.keys(approvedAccountIds));
}

//refund the initial deposit based on the amount of storage that was used up
export function refundDeposit(storageUsed: bigint) {
    //get how much it would cost to store the information
    let requiredCost = storageUsed * near.storageByteCost().valueOf()
    //get the attached deposit
    let attachedDeposit = near.attachedDeposit().valueOf();

    //make sure that the attached deposit is greater than or equal to the required cost
    assert(
        requiredCost <= attachedDeposit,
        `Must attach ${requiredCost} yoctoNEAR to cover storage`
    )

    //get the refund amount from the attached deposit - required cost
    let refund = attachedDeposit - requiredCost;
    near.log(`Refunding ${refund} yoctoNEAR`);

    //if the refund is greater than 1 yocto NEAR, we refund the predecessor that amount
    if (refund > 1) {
        // Send the money to the beneficiary (TODO: don't use batch actions)
        const promise = near.promiseBatchCreate(near.predecessorAccountId());
        near.promiseBatchActionTransfer(promise, refund)
    }
}

//calculate how many bytes the account ID is taking up
export function bytesForApprovedAccountId(accountId: string): number {
    // The extra 4 bytes are coming from Borsh serialization to store the length of the string.
    return accountId.length + 4 + 8;
}

//Assert that the user has attached at least 1 yoctoNEAR (for security reasons and to pay for storage)
export function assertAtLeastOneYocto() {
    assert(near.attachedDeposit().valueOf() >= BigInt(1), "Requires attached deposit of at least 1 yoctoNEAR");
}

//used to make sure the user attached exactly 1 yoctoNEAR
export function assertOneYocto() {
    assert(near.attachedDeposit().toString() === "1", "Requires attached deposit of exactly 1 yoctoNEAR");
}

//add a token to the set of tokens an owner has
export function internalAddTokenToOwner(contract: Contract, accountId: string, tokenId: string) {
    //get the set of tokens for the given account
    let tokenSet = restoreOwners(contract.tokensPerOwner.get(accountId));

    if(tokenSet == null) {
        //if the account doesn't have any tokens, we create a new unordered set
        tokenSet = new UnorderedSet("tokensPerOwner" + accountId.toString());
    }

    //we insert the token ID into the set
    tokenSet.set(tokenId);

    //we insert that set for the given account ID. 
    contract.tokensPerOwner.set(accountId, tokenSet);
}

//remove a token from an owner (internal method and can't be called directly via CLI).
export function internalRemoveTokenFromOwner(contract: Contract, accountId: string, tokenId: string) {
    //we get the set of tokens that the owner has
    let tokenSet = restoreOwners(contract.tokensPerOwner.get(accountId));
    //if there is no set of tokens for the owner, we panic with the following message:
    if (tokenSet == null) {
        near.panic("Token should be owned by the sender");
    }

    //we remove the the token_id from the set of tokens
    tokenSet.remove(tokenId)

    //if the token set is now empty, we remove the owner from the tokens_per_owner collection
    if (tokenSet.isEmpty()) {
        contract.tokensPerOwner.remove(accountId);
    } else { //if the token set is not empty, we simply insert it back for the account ID. 
        contract.tokensPerOwner.set(accountId, tokenSet);
    }
}

//transfers the NFT to the receiver_id (internal method and can't be called directly via CLI).
export function internalTransfer(contract: Contract, senderId: string, receiverId: string, tokenId: string, approvalId: number, memo: string): Token {
    //get the token object by passing in the token_id
    let token = contract.tokensById.get(tokenId) as Token;
    if (token == null) {
        near.panic("no token found");
    }

    //if the sender doesn't equal the owner, we check if the sender is in the approval list
    if (senderId != token.owner_id) {
        //if the token's approved account IDs doesn't contain the sender, we panic
        if (!token.approved_account_ids.hasOwnProperty(senderId)) {
            near.panic("Unauthorized");
        }

        // If they included an approval_id, check if the sender's actual approval_id is the same as the one included
        if (approvalId != null) {
            //get the actual approval ID
            let actualApprovalId = token.approved_account_ids[senderId];
            //if the sender isn't in the map, we panic
            if (actualApprovalId == null) {
                near.panic("Sender is not approved account");
            }

            //make sure that the actual approval ID is the same as the one provided
            assert(actualApprovalId == approvalId, `The actual approval_id ${actualApprovalId} is different from the given approval_id ${approvalId}`);
        }
    }

    //we make sure that the sender isn't sending the token to themselves
    assert(token.owner_id != receiverId, "The token owner and the receiver should be different")

    //we remove the token from it's current owner's set
    internalRemoveTokenFromOwner(contract, token.owner_id, tokenId);
    //we then add the token to the receiver_id's set
    internalAddTokenToOwner(contract, receiverId, tokenId);

    //we create a new token struct 
    let newToken = new Token ({
        ownerId: receiverId,
        //reset the approval account IDs
        approvedAccountIds: {},
        nextApprovalId: token.next_approval_id,
        //we copy over the royalties from the previous token
        royalty: token.royalty,
    });

    //insert that new token into the tokens_by_id, replacing the old entry 
    contract.tokensById.set(tokenId, newToken);

    //if there was some memo attached, we log it. 
    if (memo != null) {
        near.log(`Memo: ${memo}`);
    }

    // Default the authorized ID to be None for the logs.
    let authorizedId;

    //if the approval ID was provided, set the authorized ID equal to the sender
    if (approvalId != null) {
        authorizedId = senderId
    }

    // Construct the transfer log as per the events standard.
    let nftTransferLog = {
        // Standard name ("nep171").
        standard: NFT_STANDARD_NAME,
        // Version of the standard ("nft-1.0.0").
        version: NFT_METADATA_SPEC,
        // The data related with the event stored in a vector.
        event: "nft_transfer",
        data: [
            {
                // The optional authorized account ID to transfer the token on behalf of the old owner.
                authorized_id: authorizedId,
                // The old owner's account ID.
                old_owner_id: token.owner_id,
                // The account ID of the new owner of the token.
                new_owner_id: receiverId,
                // A vector containing the token IDs as strings.
                token_ids: [tokenId],
                // An optional memo to include.
                memo,
            }
        ]
    }

    // Log the serialized json.
    near.log(JSON.stringify(nftTransferLog));

    //return the previous token object that was transferred.
    return token
}
'''
'''--- nft-tutorial-js/src/nft-contract/metadata.ts ---
import { Contract } from ".";

//defines the payout type we'll be returning as a part of the royalty standards.
export class Payout {
    payout: { [accountId: string]: bigint };
    constructor({ payout }: { payout: { [accountId: string]: bigint } }) {
        this.payout = payout;
    }
}

export class NFTContractMetadata {
    spec: string;
    name: string;
    symbol: string;
    icon?: string;
    base_uri?: string;
    reference?: string;
    reference_hash?: string;
    
    constructor(
        {
            spec, 
            name, 
            symbol, 
            icon, 
            baseUri, 
            reference, 
            referenceHash
        }:{ 
            spec: string, 
            name: string, 
            symbol: string, 
            icon?: string, 
            baseUri?: string, 
            reference?: string, 
            referenceHash?: string
        }) {
        this.spec = spec  // required, essentially a version like "nft-1.0.0"
        this.name = name  // required, ex. "Mosaics"
        this.symbol = symbol // required, ex. "MOSAIC"
        this.icon = icon // Data URL
        this.base_uri = baseUri // Centralized gateway known to have reliable access to decentralized storage assets referenced by `reference` or `media` URLs
        this.reference = reference // URL to a JSON file with more info
        this.reference_hash = referenceHash // Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included.
    }
}

export class TokenMetadata {
    title?: string;
    description?: string;
    media?: string;
    media_hash?: string;
    copies?: number;
    issued_at?: string;
    expires_at?: string;
    starts_at?: string;
    updated_at?: string;
    extra?: string;
    reference?: string;
    reference_hash?: string;

    constructor(
        {
            title, 
            description, 
            media, 
            mediaHash, 
            copies, 
            issuedAt, 
            expiresAt, 
            startsAt, 
            updatedAt, 
            extra, 
            reference, 
            referenceHash
        }:{
            title?: string, 
            description?: string, 
            media?: string, 
            mediaHash?: string, 
            copies?: number, 
            issuedAt?: string, 
            expiresAt?: string, 
            startsAt?: string, 
            updatedAt?: string, 
            extra?: string, 
            reference?: string, 
            referenceHash?: string}
        ) {
        this.title = title // ex. "Arch Nemesis: Mail Carrier" or "Parcel #5055"
        this.description = description // free-form description
        this.media = media // URL to associated media, preferably to decentralized, content-addressed storage
        this.media_hash = mediaHash // Base64-encoded sha256 hash of content referenced by the `media` field. Required if `media` is included.
        this.copies = copies // number of copies of this set of metadata in existence when token was minted.
        this.issued_at = issuedAt // ISO 8601 datetime when token was issued or minted
        this.expires_at = expiresAt // ISO 8601 datetime when token expires
        this.starts_at = startsAt // ISO 8601 datetime when token starts being valid
        this.updated_at = updatedAt // ISO 8601 datetime when token was last updated
        this.extra = extra // anything extra the NFT wants to store on-chain. Can be stringified JSON.
        this.reference = reference // URL to an off-chain JSON file with more info.
        this.reference_hash = referenceHash // Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included.
    }
}

export class Token {
    owner_id: string;
    approved_account_ids: { [accountId: string]: number };
    next_approval_id: number;
    royalty: { [accountId: string]: number };

    constructor({ 
        ownerId, 
        approvedAccountIds, 
        nextApprovalId, 
        royalty 
    }:{ 
        ownerId: string, 
        approvedAccountIds: { [accountId: string]: number }, 
        nextApprovalId: number, 
        royalty: { [accountId: string]: number } 
    }) {
        //owner of the token
        this.owner_id = ownerId,
        //list of approved account IDs that have access to transfer the token. This maps an account ID to an approval ID
        this.approved_account_ids = approvedAccountIds,
        //the next approval ID to give out. 
        this.next_approval_id = nextApprovalId,
        //keep track of the royalty percentages for the token in a hash map
        this.royalty = royalty
    }
}

//The Json token is what will be returned from view calls. 
export class JsonToken {
    token_id: string;
    owner_id: string;
    metadata: TokenMetadata;
    approved_account_ids: { [accountId: string]: number };
    royalty: { [accountId: string]: number };

    constructor({ 
        tokenId, 
        ownerId, 
        metadata, 
        approvedAccountIds, 
        royalty 
    }:{
        tokenId: string,
        ownerId: string,
        metadata: TokenMetadata,
        approvedAccountIds: { [accountId: string]: number },
        royalty: { [accountId: string]: number }
    }) {
        //token ID
        this.token_id = tokenId,
        //owner of the token
        this.owner_id = ownerId,
        //token metadata
        this.metadata = metadata,
        //list of approved account IDs that have access to transfer the token. This maps an account ID to an approval ID
        this.approved_account_ids = approvedAccountIds,
        //keep track of the royalty percentages for the token in a hash map
        this.royalty = royalty
    }
}

//get the information for a specific token ID
export function internalNftMetadata({
    contract
}:{
    contract: Contract
}): NFTContractMetadata {
    return contract.metadata;
}
'''
'''--- nft-tutorial-js/src/nft-contract/mint.ts ---
// @ts-nocheck
import { assert, near } from "near-sdk-js";
import { Contract, NFT_METADATA_SPEC, NFT_STANDARD_NAME } from ".";
import { internalAddTokenToOwner, refundDeposit } from "./internal";
import { Token, TokenMetadata } from "./metadata";

export function internalMint({
    contract,
    tokenId,
    metadata,
    receiverId,
    perpetualRoyalties
}:{ 
    contract: Contract, 
    tokenId: string, 
    metadata: TokenMetadata, 
    receiverId: string 
    perpetualRoyalties: {[key: string]: number}
}): void {
    //measure the initial storage being used on the contract TODO
    let initialStorageUsage = near.storageUsage();

    // create a royalty map to store in the token
    let royalty: { [accountId: string]: number } = {}

    // if perpetual royalties were passed into the function: TODO: add isUndefined fn
    if (perpetualRoyalties != null) {
        //make sure that the length of the perpetual royalties is below 7 since we won't have enough GAS to pay out that many people
        assert(Object.keys(perpetualRoyalties).length < 7, "Cannot add more than 6 perpetual royalty amounts");
        
        //iterate through the perpetual royalties and insert the account and amount in the royalty map
        Object.entries(perpetualRoyalties).forEach(([account, amount], index) => {
            royalty[account] = amount;
        });
    }

    //specify the token struct that contains the owner ID 
    let token = new Token ({
        //set the owner ID equal to the receiver ID passed into the function
        ownerId: receiverId,
        //we set the approved account IDs to the default value (an empty map)
        approvedAccountIds: {},
        //the next approval ID is set to 0
        nextApprovalId: 0,
        //the map of perpetual royalties for the token (The owner will get 100% - total perpetual royalties)
        royalty,
    });

    //insert the token ID and token struct and make sure that the token doesn't exist
    assert(!contract.tokensById.containsKey(tokenId), "Token already exists");
    contract.tokensById.set(tokenId, token)

    //insert the token ID and metadata
    contract.tokenMetadataById.set(tokenId, metadata);

    //call the internal method for adding the token to the owner
    internalAddTokenToOwner(contract, token.owner_id, tokenId)

    // Construct the mint log as per the events standard.
    let nftMintLog = {
        // Standard name ("nep171").
        standard: NFT_STANDARD_NAME,
        // Version of the standard ("nft-1.0.0").
        version: NFT_METADATA_SPEC,
        // The data related with the event stored in a vector.
        event: "nft_mint",
        data: [
            {
                // Owner of the token.
                owner_id: token.owner_id,
                // Vector of token IDs that were minted.
                token_ids: [tokenId],
            }
        ]
    }
    
    // Log the json.
    near.log(`EVENT_JSON:${JSON.stringify(nftMintLog)}`);

    //calculate the required storage which was the used - initial TODO
    let requiredStorageInBytes = near.storageUsage().valueOf() - initialStorageUsage.valueOf();

    //refund any excess storage if the user attached too much. Panic if they didn't attach enough to cover the required.
    refundDeposit(requiredStorageInBytes);
}
'''
'''--- nft-tutorial-js/src/nft-contract/nft_core.ts ---
// @ts-nocheck
import { assert, bytes, near } from "near-sdk-js";
import { Contract, NFT_METADATA_SPEC, NFT_STANDARD_NAME } from ".";
import { assertOneYocto, internalAddTokenToOwner, internalRemoveTokenFromOwner, internalTransfer, refundDeposit, refundApprovedAccountIds } from "./internal";
import { JsonToken, Token, TokenMetadata } from "./metadata";

const GAS_FOR_RESOLVE_TRANSFER = 40_000_000_000_000;
const GAS_FOR_NFT_ON_TRANSFER = 35_000_000_000_000;

//get the information for a specific token ID
export function internalNftToken({
    contract,
    tokenId
}:{ 
    contract: Contract, 
    tokenId: string 
}) {
    let token = contract.tokensById.get(tokenId) as Token;
    //if there wasn't a token ID in the tokens_by_id collection, we return None
    if (token == null) {
        return null;
    }

    //if there is some token ID in the tokens_by_id collection
    //we'll get the metadata for that token
    let metadata = contract.tokenMetadataById.get(tokenId) as TokenMetadata;
    
    //we return the JsonToken
    let jsonToken = new JsonToken({
        tokenId: tokenId,
        ownerId: token.owner_id,
        metadata,
        approvedAccountIds: token.approved_account_ids,
        royalty: token.royalty
    });
    return jsonToken;
}

//implementation of the nft_transfer method. This transfers the NFT from the current owner to the receiver. 
export function internalNftTransfer({
    contract,
    receiverId,
    tokenId,
    approvalId,
    memo,
}:{
    contract: Contract, 
    receiverId: string, 
    tokenId: string, 
    approvalId: number
    memo: string
}) {
    //assert that the user attached exactly 1 yoctoNEAR. This is for security and so that the user will be redirected to the NEAR wallet. 
    assertOneYocto();
    //get the sender to transfer the token from the sender to the receiver
    let senderId = near.predecessorAccountId();

    //call the internal transfer method and get back the previous token so we can refund the approved account IDs
    let previousToken = internalTransfer(
        contract,
        senderId,
        receiverId,
        tokenId,
        approvalId,
        memo,
    );

    //we refund the owner for releasing the storage used up by the approved account IDs
    refundApprovedAccountIds(
        previousToken.owner_id,
        previousToken.approved_account_ids
    );
}

//implementation of the transfer call method. This will transfer the NFT and call a method on the receiver_id contract
export function internalNftTransferCall({
    contract,
    receiverId,
    tokenId,
    approvalId,
    memo,
    msg
}:{
    contract: Contract,
    receiverId: string, 
    tokenId: string, 
    approvalId: number,
    memo: string,
    msg: string  
}) {
    //assert that the user attached exactly 1 yocto for security reasons. 
    assertOneYocto();
    //get the sender to transfer the token from the sender to the receiver
    let senderId = near.predecessorAccountId();

    //call the internal transfer method and get back the previous token so we can refund the approved account IDs
    let previousToken = internalTransfer(
        contract,
        senderId,
        receiverId,
        tokenId,
        approvalId,
        memo,
    );

    // Initiating receiver's call and the callback
    const promise = near.promiseBatchCreate(receiverId);
    near.promiseBatchActionFunctionCall(
        promise, 
        "nft_on_transfer", 
        bytes(JSON.stringify({ 
            sender_id: senderId,
            previous_owner_id: previousToken.owner_id,
            token_id: tokenId,
            msg
        })), 
        0, // no deposit 
        GAS_FOR_NFT_ON_TRANSFER
    );

    // We then resolve the promise and call nft_resolve_transfer on our own contract
    near.promiseThen(
        promise, 
        near.currentAccountId(), 
        "nft_resolve_transfer", 
        bytes(JSON.stringify({
            owner_id: previousToken.owner_id,
            receiver_id: receiverId,
            token_id: tokenId,
            approved_account_ids: previousToken.approved_account_ids
        })), 
        0, // no deposit 
        GAS_FOR_RESOLVE_TRANSFER
    );
    return near.promiseReturn(promise);
}

//resolves the cross contract call when calling nft_on_transfer in the nft_transfer_call method
//returns true if the token was successfully transferred to the receiver_id
export function internalResolveTransfer({
    contract,
    authorizedId,
    ownerId,
    receiverId,
    tokenId,
    approvedAccountIds,
    memo
}:{
    contract: Contract,
    authorizedId: string,
    ownerId: string,
    receiverId: string,
    tokenId: string,
    approvedAccountIds: { [key: string]: number },
    memo: string    
}) {
    assert(near.currentAccountId() === near.predecessorAccountId(), "Only the contract itself can call this method");
    // Whether receiver wants to return token back to the sender, based on `nft_on_transfer`
    // call result.
    let result = near.promiseResult(0);
    if (typeof result === 'string') {
        //As per the standard, the nft_on_transfer should return whether we should return the token to it's owner or not
        //if we need don't need to return the token, we simply return true meaning everything went fine
        if (result === 'false') {
            /* 
                since we've already transferred the token and nft_on_transfer returned false, we don't have to 
                revert the original transfer and thus we can just return true since nothing went wrong.
            */
            //we refund the owner for releasing the storage used up by the approved account IDs
            refundApprovedAccountIds(ownerId, approvedAccountIds);
            return true;
        }
    }

    //get the token object if there is some token object
    let token = contract.tokensById.get(tokenId) as Token;
    if (token != null) {
        if (token.owner_id != receiverId) {
            //we refund the owner for releasing the storage used up by the approved account IDs
            refundApprovedAccountIds(ownerId, approvedAccountIds);
            // The token is not owner by the receiver anymore. Can't return it.
            return true;
        }
    //if there isn't a token object, it was burned and so we return true
    } else {
        //we refund the owner for releasing the storage used up by the approved account IDs
        refundApprovedAccountIds(ownerId, approvedAccountIds);
        return true;
    }

    //we remove the token from the receiver
    internalRemoveTokenFromOwner(contract, receiverId, tokenId);
    //we add the token to the original owner
    internalAddTokenToOwner(contract, ownerId, tokenId);

    //we change the token struct's owner to be the original owner 
    token.owner_id = ownerId

    //we refund the receiver any approved account IDs that they may have set on the token
    refundApprovedAccountIds(receiverId, token.approved_account_ids);
    //reset the approved account IDs to what they were before the transfer
    token.approved_account_ids = approvedAccountIds;

    //we inset the token b  ack into the tokens_by_id collection
    contract.tokensById.set(tokenId, token);

    /*
        We need to log that the NFT was reverted back to the original owner.
        The old_owner_id will be the receiver and the new_owner_id will be the
        original owner of the token since we're reverting the transfer.
    */

    // Construct the transfer log as per the events standard.
    let nftTransferLog = {
        // Standard name ("nep171").
        standard: NFT_STANDARD_NAME,
        // Version of the standard ("nft-1.0.0").
        version: NFT_METADATA_SPEC,
        // The data related with the event stored in a vector.
        event: "nft_transfer",
        data: [
            {
                // The optional authorized account ID to transfer the token on behalf of the old owner.
                authorized_id: authorizedId,
                // The old owner's account ID.
                old_owner_id: receiverId,
                // The account ID of the new owner of the token.
                new_owner_id: ownerId,
                // A vector containing the token IDs as strings.
                token_ids: [tokenId],
                // An optional memo to include.
                memo,
            }
        ]
    }

    // Log the serialized json.
    near.log(JSON.stringify(nftTransferLog));

    //return false
    return false
}
'''
'''--- nft-tutorial-js/src/nft-contract/royalty.ts ---
// @ts-nocheck
import { assert, near } from "near-sdk-js";
import { Contract, NFT_METADATA_SPEC, NFT_STANDARD_NAME } from ".";
import { assertAtLeastOneYocto, assertOneYocto, bytesForApprovedAccountId, internalAddTokenToOwner, internalTransfer, refundDeposit, refundApprovedAccountIds, refundApprovedAccountIdsIter, royaltyToPayout } from "./internal";
import { Token } from "./metadata";

//calculates the payout for a token given the passed in balance. This is a view method
export function internalNftPayout({
    contract,
    tokenId,
    balance,
    maxLenPayout
}:{
    contract: Contract, 
    tokenId: string,
    balance: bigint, 
    maxLenPayout: number,
}): { payout: {[key: string]: string }} {
    //get the token object
    let token = contract.tokensById.get(tokenId) as Token;
    if (token == null) {
        near.panic("no token");
    }

    //get the owner of the token
    let ownerId = token.owner_id;
    //keep track of the total perpetual royalties
    let totalPerpetual = 0;
    //keep track of the payout object to send back
    let payoutObj: { [key: string]: string } = {};
    //get the royalty object from token
    let royalty = token.royalty;

    //make sure we're not paying out to too many people (GAS limits this)
    assert(Object.keys(royalty).length <= maxLenPayout, "Market cannot payout to that many receivers");
    
    //go through each key and value in the royalty object
    Object.entries(royalty).forEach(([key, value], index) => {
        //only insert into the payout if the key isn't the token owner (we add their payout at the end)
        if (key != ownerId) {
            payoutObj[key] = royaltyToPayout(value, balance);
            totalPerpetual += value;
        }
    });

    // payout to previous owner who gets 100% - total perpetual royalties
    payoutObj[ownerId] = royaltyToPayout(10000 - totalPerpetual, balance);

    //return the payout object
    return {
        payout: payoutObj
    }
}

//transfers the token to the receiver ID and returns the payout object that should be payed given the passed in balance. 
export function internalNftTransferPayout({
    contract,
    receiverId,
    tokenId,
    approvalId,
    memo,
    balance,
    maxLenPayout
}:{
    contract: Contract, 
    receiverId: string, 
    tokenId: string,
    approvalId: number,
    memo: string,
    balance: bigint,
    maxLenPayout: number,
}): { payout: {[key: string]: string }} {
    //assert that the user attached 1 yocto NEAR for security reasons
    assertOneYocto();
    //get the sender ID
    let senderId = near.predecessorAccountId();
    //transfer the token to the passed in receiver and get the previous token object back
    let previousToken: Token = internalTransfer(
        contract,
        senderId,
        receiverId,
        tokenId,
        approvalId,
        memo,
    );

    //refund the previous token owner for the storage used up by the previous approved account IDs
    refundApprovedAccountIds(
        previousToken.owner_id,
        previousToken.approved_account_ids,
    );

    //get the owner of the token
    let ownerId = previousToken.owner_id;
    //keep track of the total perpetual royalties
    let totalPerpetual = 0;
    //keep track of the payout object to send back
    let payoutObj: { [key: string]: string } = {};
    //get the royalty object from token
    let royalty = previousToken.royalty;

    //make sure we're not paying out to too many people (GAS limits this)
    assert(Object.keys(royalty).length <= maxLenPayout, "Market cannot payout to that many receivers");
    
    //go through each key and value in the royalty object
    Object.entries(royalty).forEach(([key, value], index) => {
        //only insert into the payout if the key isn't the token owner (we add their payout at the end)
        if (key != ownerId) {
            payoutObj[key] = royaltyToPayout(value, balance);
            totalPerpetual += value;
        }
    });

    // payout to previous owner who gets 100% - total perpetual royalties
    payoutObj[ownerId] = royaltyToPayout(10000 - totalPerpetual, balance);

    //return the payout object
    return {
        payout: payoutObj
    }
}
'''
'''--- nft-tutorial-js/tsconfig.json ---
{
    "compilerOptions": {
        "experimentalDecorators": true,
        "target": "es5",
        "noEmit": true
    },
    "exclude": [
        "node_modules"
    ],
}
'''
'''--- nft-tutorial/.github/workflows/tests.yml ---
name: Tests
on:
  repository_dispatch:
    types: [tests-report]
  push:
jobs:
  unit-tests:
    name: Unit tests
    strategy:
      matrix:
        platform: [ubuntu-latest]  # , windows-latest, macos-latest]
    runs-on: ${{ matrix.platform }}
    env:
      RUST_BACKTRACE: 1
    steps:
      - name: Checkout branch
        uses: actions/checkout@v2
      - name: Install Node
        uses: actions/setup-node@v2
      - name: Install Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          target: wasm32-unknown-unknown
      - name: Build smart contract
        run: npm run build
      - name: Run unit tests
        run: npm run test:unit
  integration-tests:
    name: Integration tests
    strategy:
      matrix:
        platform: [ubuntu-latest]  # , windows-latest, macos-latest]
    runs-on: ${{ matrix.platform }}
    env:
      RUST_BACKTRACE: 1
    steps:
      - name: Checkout branch
        uses: actions/checkout@v2
      - name: Install Node
        uses: actions/setup-node@v2
      - name: Install Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          target: wasm32-unknown-unknown
      - name: Build smart contract
        run: npm run build
      - name: Run Rust integration tests
        run: npm run test:integration:rs
      - name: Run TS integration tests
        run: npm run test:integration:ts

'''
'''--- nft-tutorial/README.md ---
# NEAR NFT-Tutorial

[![](https://img.shields.io/github/workflow/status/near-examples/nft-tutorial/Tests/main?label=Tests)](https://github.com/near-examples/nft-tutorial/actions/workflows/tests.yml)

Welcome to NEAR's NFT tutorial, where we will help you parse the details around NEAR's [NEP-171 standard](https://nomicon.io/Standards/NonFungibleToken/Core.html) (Non-Fungible Token Standard), and show you how to build your own NFT smart contract from the ground up, improving your understanding about the NFT standard along the way. 

## Prerequisites

* [NEAR Wallet Account](wallet.testnet.near.org)
* [Rust Toolchain](https://docs.near.org/develop/prerequisites)
* [NEAR-CLI](https://docs.near.org/tools/near-cli#setup)
* [yarn](https://classic.yarnpkg.com/en/docs/install#mac-stable)

## Tutorial Stages 

Each branch you will find in this repo corresponds to various stages of this tutorial with a partially completed contract at each stage. You are welcome to start from any stage you want to learn the most about. 

| Branch        | Docs Tutorial                                                                                    | Description |
| ------------- | ------------------------------------------------------------------------------------------------ | ----------- |
| 1.skeleton    | [Contract Architecture](https://docs.near.org/docs/tutorials/contracts/nfts/rs/skeleton) | You'll learn the basic architecture of the NFT smart contract, and you'll compile this skeleton code with the Rust toolchain.            |
| 2.minting     | [Minting](https://docs.near.org/docs/tutorials/contracts/nfts/rs/minting)                |Here you'll flesh out the skeleton so the smart contract can mint a non-fungible token             |
| 3.enumeration | [Enumeration](https://docs.near.org/docs/tutorials/contracts/nfts/rs/enumeration)        |    Here you'll find different enumeration methods that can be used to return the smart contract's states.          |
| 4.core        | [Core](https://docs.near.org/docs/tutorials/contracts/nfts/rs/core)                      | In this tutorial you'll extend the NFT contract using the core standard, which will allow you to transfer non-fungible tokens.             |
| 5.approval    | [Approval](https://docs.near.org/docs/tutorials/contracts/nfts/rs/approvals)             | Here you'll expand the contract allowing other accounts to transfer NFTs on your behalf.            |
| 6.royalty     | [Royalty](https://docs.near.org/docs/tutorials/contracts/nfts/rs/royalty)                                                                                        |Here you'll add the ability for non-fungible tokens to have royalties. This will allow people to get a percentage of the purchase price when an NFT is purchased.             |
| 7.events      | -----------                                                                                        |   This allows indexers to know what functions are being called and make it easier and more reliable to keep track of information that can be used to populate the collectibles tab in the wallet for example. (tutorial docs have yet to be implemented )          |
| 8.marketplace | -----------                                                                                      | -----------             |

The tutorial series also contains a very helpful section on [**Upgrading Smart Contracts**](https://docs.near.org/docs/tutorials/contracts/nfts/rs/upgrade-contract). Definitely go and check it out as this is a common pain point.

# Quick-Start 

If you want to see the full completed contract go ahead and clone and build this repo using 

```=bash
git clone https://github.com/near-examples/nft-tutorial.git 
cd nft-tutorial
git switch 6.royalty
yarn build
```

Now that you've cloned and built the contract we can try a few things. 

## Mint An NFT

Once you've created your near wallet go ahead and login to your wallet with your cli and follow the on-screen prompts

```=bash
near login
```

Once your logged in you have to deploy the contract. Make a subaccount with the name of your choosing 

```=bash 
near create-account nft-example.your-account.testnet --masterAccount your-account.testnet --initialBalance 10
```

After you've created your sub account deploy the contract to that sub account, set this variable to your sub account name

```=bash
NFT_CONTRACT_ID=nft-example.your-account.testnet

MAIN_ACCOUNT=your-account.testnet
```

Verify your new variable has the correct value
```=bash
echo $NFT_CONTRACT_ID

echo $MAIN_ACCOUNT
```

### Deploy Your Contract
```=bash
near deploy --accountId $NFT_CONTRACT_ID --wasmFile out/main.wasm
```

### Initialize Your Contract 

```=bash
near call $NFT_CONTRACT_ID new_default_meta '{"owner_id": "'$NFT_CONTRACT_ID'"}' --accountId $NFT_CONTRACT_ID
```

### View Contracts Meta Data

```=bash
near view $NFT_CONTRACT_ID nft_metadata
```
### Minting Token

```bash=
near call $NFT_CONTRACT_ID nft_mint '{"token_id": "token-1", "metadata": {"title": "My Non Fungible Team Token", "description": "The Team Most Certainly Goes :)", "media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif"}, "receiver_id": "'$MAIN_ACCOUNT'"}' --accountId $MAIN_ACCOUNT --amount 0.1
```

After you've minted the token go to wallet.testnet.near.org to `your-account.testnet` and look in the collections tab and check out your new sample NFT! 

## View NFT Information

After you've minted your NFT you can make a view call to get a response containing the `token_id` `owner_id` and the `metadata`

```bash=
near view $NFT_CONTRACT_ID nft_token '{"token_id": "token-1"}'
```

## Transfering NFTs

To transfer an NFT go ahead and make another [testnet wallet account](https://wallet.testnet.near.org).

Then run the following
```bash=
MAIN_ACCOUNT_2=your-second-wallet-account.testnet
```

Verify the correct variable names with this

```=bash
echo $NFT_CONTRACT_ID

echo $MAIN_ACCOUNT

echo $MAIN_ACCOUNT_2
```

To initiate the transfer..

```bash=
near call $NFT_CONTRACT_ID nft_transfer '{"receiver_id": "$MAIN_ACCOUNT_2", "token_id": "token-1", "memo": "Go Team :)"}' --accountId $MAIN_ACCOUNT --depositYocto 1
```

In this call you are depositing 1 yoctoNEAR for security and so that the user will be redirected to the NEAR wallet.

## Errata

Large Changes:
* **2022-06-21**: updated the rust SDK to version 4.0.0. PR found [here](https://github.com/near-examples/nft-tutorial/pull/32)

* **2022-02-12**: updated the enumeration methods `nft_tokens` and `nft_tokens_for_owner` to no longer use any `to_vector` operations to save GAS. In addition, the default limit was changed from 0 to 50. PR found [here](https://github.com/near-examples/nft-tutorial/pull/17). 

Small Changes:
* **2022-02-22**: changed `token_id` parameter type in nft_payout from `String` to `TokenId` for consistency as per pythonicode's suggestion

'''
'''--- nft-tutorial/integration-tests/rs/Cargo.toml ---
[package]
name = "fungible-token-integration-tests"
version = "1.0.0"
publish = false
edition = "2018"

[dev-dependencies]
near-sdk = "4.0.0"
anyhow = "1.0"
borsh = "0.9"
maplit = "1.0"
near-units = "0.2.0"
# arbitrary_precision enabled for u128 types that workspaces requires for Balance types
serde_json = { version = "1.0", features = ["arbitrary_precision"] }
tokio = { version = "1.18.1", features = ["full"] }
tracing = "0.1"
tracing-subscriber = { version = "0.3.11", features = ["env-filter"] }
workspaces = "0.3.1"
pkg-config = "0.3.1"

[[example]]
name = "integration-tests"
path = "src/tests.rs"
'''
'''--- nft-tutorial/integration-tests/rs/src/helpers.rs ---
use serde_json::json;
use workspaces::{network::Sandbox, Account, Contract, Worker, AccountDetails};

pub const DEFAULT_DEPOSIT: u128 = 6760000000000000000000 as u128;
pub const DEFAULT_GAS: u128 = 300000000000000 as u128;

pub async fn mint_nft(
    user: &Account,
    nft_contract: &Contract,
    worker: &Worker<Sandbox>,
    token_id: &str,
) -> anyhow::Result<()> { 
    let request_payload = json!({
        "token_id": token_id,
        "receiver_id": user.id(),
        "metadata": {
            "title": "Grumpy Cat",
            "description": "Not amused.",
            "media": "https://www.adamsdrafting.com/wp-content/uploads/2018/06/More-Grumpy-Cat.jpg"
        },
    });

    user.call(&worker, nft_contract.id(), "nft_mint")
        .args_json(request_payload)?
        .deposit(DEFAULT_DEPOSIT)
        .transact()
        .await?;
    
    Ok(())
}

pub async fn approve_nft(
    market_contract: &Contract,
    user: &Account,
    nft_contract: &Contract,
    worker: &Worker<Sandbox>,
    token_id: &str,
) -> anyhow::Result<()> {
    let request_payload  = json!({
        "token_id": token_id,
        "account_id": market_contract.id(),
        "msg": serde_json::Value::Null,
    });

    user.call(&worker, nft_contract.id(), "nft_approve")
        .args_json(request_payload)?
        .deposit(DEFAULT_DEPOSIT)
        .transact()
        .await?;

    Ok(())
}

pub async fn pay_for_storage(
    user: &Account,
    market_contract: &Contract,
    worker: &Worker<Sandbox>,
    amount: u128,
) -> anyhow::Result<()> {
    let request_payload = json!({});
    
    user.call(&worker, market_contract.id(), "storage_deposit")
        .args_json(request_payload)?
        .deposit(amount)
        .transact()
        .await?;

    Ok(())
}

pub async fn place_nft_for_sale(
    user: &Account,
    market_contract: &Contract,
    nft_contract: &Contract,
    worker: &Worker<Sandbox>,
    token_id: &str,
    price: u128,
) -> anyhow::Result<()> {
    let request_payload  = json!({
        "token_id": token_id,
        "account_id": market_contract.id(),
        "msg": format!(r#"{{ "sale_conditions" : "{}" }}"#, price.to_string()),
    });

    user.call(&worker, nft_contract.id(), "nft_approve")
        .args_json(request_payload)?
        .deposit(DEFAULT_DEPOSIT)
        .transact()
        .await?;

    Ok(())
}

pub async fn get_user_balance(
    user: &Account,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<u128> {
    let details: AccountDetails = user.view_account(worker).await?;
    Ok(details.balance)
}

pub async fn purchase_listed_nft(
    bidder: &Account,
    market_contract: &Contract,
    nft_contract: &Contract,
    worker: &Worker<Sandbox>,
    token_id: &str,
    offer_price: u128
) -> anyhow::Result<()> {
    let request_payload  = json!({
        "token_id": token_id,
        "nft_contract_id": nft_contract.id(),
    });

    bidder.call(&worker, market_contract.id(), "offer")
        .args_json(request_payload)?
        .gas(DEFAULT_GAS as u64)
        .deposit(offer_price)
        .transact()
        .await?;

    Ok(())
}

pub async fn transfer_nft(
    sender: &Account,
    receiver: &Account,
    nft_contract: &Contract,
    worker: &Worker<Sandbox>,
    token_id: &str,
) -> anyhow::Result<()> {
    let request_payload  = json!({
        "token_id": token_id,
        "receiver_id": receiver.id(),
        "approval_id": 1 as u64,
    });

    sender.call(&worker, nft_contract.id(), "nft_transfer")
        .args_json(request_payload)?
        .gas(DEFAULT_GAS as u64)
        .deposit(1)
        .transact()
        .await?;
    
    Ok(())
}

pub async fn get_nft_token_info(
    nft_contract: &Contract,
    worker: &Worker<Sandbox>,
    token_id: &str,
) -> anyhow::Result<serde_json::Value> {
    let token_info: serde_json::Value = nft_contract
        .call(&worker, "nft_token")
        .args_json(json!({"token_id": token_id}))?
        .transact()
        .await?
        .json()?;

    Ok(token_info)
}

pub fn round_to_near_dp(
    amount: u128,
    sf: u128,
) -> String {
    let near_amount = amount as f64 / 1_000_000_000_000_000_000_000_000.0;  // yocto in 1 NEAR
    return format!("{:.1$}", near_amount, sf as usize);
} 

'''
'''--- nft-tutorial/integration-tests/rs/src/tests.rs ---
use near_units::parse_near;
use serde_json::json;
use workspaces::prelude::*;
use workspaces::{network::Sandbox, Account, Contract, Worker};

mod helpers;

const NFT_WASM_FILEPATH: &str = "../../out/main.wasm";
const MARKET_WASM_FILEPATH: &str = "../../out/market.wasm";

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // initiate environemnt
    let worker = workspaces::sandbox().await?;

    // deploy contracts
    let nft_wasm = std::fs::read(NFT_WASM_FILEPATH)?;
    let nft_contract = worker.dev_deploy(&nft_wasm).await?;
    let market_wasm = std::fs::read(MARKET_WASM_FILEPATH)?;
    let market_contract = worker.dev_deploy(&market_wasm).await?;

    // create accounts
    let owner = worker.root_account();
    let alice = owner
        .create_subaccount(&worker, "alice")
        .initial_balance(parse_near!("30 N"))
        .transact()
        .await?
        .into_result()?;
    let bob = owner
        .create_subaccount(&worker, "bob")
        .initial_balance(parse_near!("30 N"))
        .transact()
        .await?
        .into_result()?;
    let charlie = owner
        .create_subaccount(&worker, "charlie")
        .initial_balance(parse_near!("30 N"))
        .transact()
        .await?
        .into_result()?;

    // Initialize contracts
    nft_contract
        .call(&worker, "new_default_meta")
        .args_json(serde_json::json!({"owner_id": owner.id()}))?
        .transact()
        .await?;
    market_contract
        .call(&worker, "new")
        .args_json(serde_json::json!({"owner_id": owner.id()}))?
        .transact()
        .await?;

    // begin tests
    test_nft_metadata_view(&owner, &nft_contract, &worker).await?;
    test_nft_mint_call(&owner, &alice, &nft_contract, &worker).await?;
    test_nft_approve_call(&bob, &nft_contract, &market_contract, &worker).await?;
    test_nft_approve_call_long_msg_string(&alice, &nft_contract, &market_contract, &worker).await?;
    test_sell_nft_listed_on_marketplace(&alice, &nft_contract, &market_contract, &bob, &worker).await?;
    test_transfer_nft_when_listed_on_marketplace(&alice, &bob, &charlie, &nft_contract, &market_contract, &worker).await?;
    test_approval_revoke(&alice, &bob, &nft_contract, &market_contract, &worker).await?;
    test_reselling_and_royalties(&alice, &bob, &charlie, &nft_contract, &market_contract, &worker).await?;

    Ok(())
}

async fn test_nft_metadata_view(
    owner: &Account,
    contract: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    let expected = json!({
        "base_uri": serde_json::Value::Null,
        "icon": serde_json::Value::Null,
        "name": "NFT Tutorial Contract",
        "reference": serde_json::Value::Null,
        "reference_hash": serde_json::Value::Null,
        "spec": "nft-1.0.0",
        "symbol": "GOTEAM",
    });
    let res: serde_json::Value = owner
        .call(&worker, contract.id(), "nft_metadata")
        .args_json(json!({  "account_id": owner.id()  }))?
        .transact()
        .await?
        .json()?;
    assert_eq!(res, expected);
    println!("      Passed ✅ test_nft_metadata_view");
    Ok(())
}

async fn test_nft_mint_call(
    owner: &Account,
    user: &Account,
    contract: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    let request_payload = json!({
        "token_id": "1",
        "receiver_id": user.id(),
        "metadata": {
            "title": "LEEROYYYMMMJENKINSSS",
            "description": "Alright time's up, let's do this.",
            "media": "https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Ftse3.mm.bing.net%2Fth%3Fid%3DOIP.Fhp4lHufCdTzTeGCAblOdgHaF7%26pid%3DApi&f=1"
        },
    });

    user.call(&worker, contract.id(), "nft_mint")
        .args_json(request_payload)?
        .deposit(parse_near!("0.008 N"))
        .transact()
        .await?;

    let tokens: serde_json::Value = owner
        .call(&worker, contract.id(), "nft_tokens")
        .args_json(serde_json::json!({}))?
        .transact()
        .await?
        .json()?;

    let expected = json!([
        {   
            "approved_account_ids": {},
            "royalty": {},
            "token_id": "1",
            "owner_id": user.id(),
            "metadata": {
                "expires_at": serde_json::Value::Null, 
                "extra": serde_json::Value::Null, 
                "issued_at": serde_json::Value::Null, 
                "copies": serde_json::Value::Null,
                "media_hash": serde_json::Value::Null,
                "reference": serde_json::Value::Null,
                "reference_hash": serde_json::Value::Null,
                "starts_at": serde_json::Value::Null,
                "updated_at": serde_json::Value::Null,
                "title": "LEEROYYYMMMJENKINSSS",
                "description": "Alright time's up, let's do this.",
                "media": "https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Ftse3.mm.bing.net%2Fth%3Fid%3DOIP.Fhp4lHufCdTzTeGCAblOdgHaF7%26pid%3DApi&f=1"
            }
        }
    ]);

    assert_eq!(tokens, expected);
    println!("      Passed ✅ test_nft_mint_call");
    Ok(())
}

async fn test_nft_approve_call(
    user: &Account,
    nft_contract: &Contract,
    market_contract: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    let token_id = "2";
    helpers::mint_nft(user, nft_contract, worker, token_id).await?;
    helpers::approve_nft(market_contract, user, nft_contract, worker, token_id).await?;

    let view_payload = json!({
        "token_id": token_id,
        "approved_account_id": market_contract.id(),
    });
    let result: bool = user
        .call(&worker, nft_contract.id(), "nft_is_approved")
        .args_json(view_payload)?
        .transact()
        .await?
        .json()?;
    
    assert_eq!(result, true);
    println!("      Passed ✅ test_nft_approve_call");
    Ok(())
}

async fn test_nft_approve_call_long_msg_string(
    user: &Account,
    nft_contract: &Contract,
    market_contract: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    let token_id = "3";
    helpers::mint_nft(user, nft_contract, worker, token_id).await?;
    helpers::pay_for_storage(user, market_contract, worker, 10000000000000000000000).await?;

    let approve_payload  = json!({
        "token_id": token_id,
        "account_id": market_contract.id(),
        "msg": "sample message".repeat(10240),
    });

    match user.call(&worker, nft_contract.id(), "nft_approve")
        .args_json(approve_payload)?
        .deposit(helpers::DEFAULT_DEPOSIT)
        .gas(helpers::DEFAULT_GAS as u64)
        .transact()
        .await
    {
        Ok(_result) => {
            panic!("test_nft_approve_call_long_msg_string worked despite insufficient gas")
        }
        Err(e) => {
            let e_string = e.to_string();
            if !e_string
                .contains("Not valid SaleArgs")
            {
                panic!("test_nft_approve_call_long_msg_string displays unexpected error message: {:?}", e_string);
            }

            let view_payload = json!({
                "token_id": token_id,
                "approved_account_id": market_contract.id(),
            });
            let result: bool = user
                .call(&worker, nft_contract.id(), "nft_is_approved")
                .args_json(view_payload)?
                .transact()
                .await?
                .json()?;
            
            assert_eq!(result, true);
            println!("      Passed ✅ test_nft_approve_call_long_msg_string");
        }
    }
    Ok(())
}

async fn test_sell_nft_listed_on_marketplace(
    seller: &Account,
    nft_contract: &Contract,
    market_contract: &Contract,
    buyer: &Account,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    let token_id = "4";
    let sale_price = 300000000000000000000000 as u128;  // 0.3 NEAR in yoctoNEAR
    helpers::mint_nft(seller, nft_contract, worker, token_id).await?;
    helpers::pay_for_storage(seller, market_contract, worker, 10000000000000000000000 as u128).await?;
    helpers::place_nft_for_sale(seller, market_contract, nft_contract, worker, token_id, sale_price).await?;

    let before_seller_balance: u128 = helpers::get_user_balance(seller, worker).await?;
    let before_buyer_balance: u128 = helpers::get_user_balance(buyer, worker).await?;
    helpers::purchase_listed_nft(buyer, market_contract, nft_contract, worker, token_id, sale_price).await?;
    let after_seller_balance: u128 = helpers::get_user_balance(seller, worker).await?;
    let after_buyer_balance: u128 = helpers::get_user_balance(buyer, worker).await?;

    let dp = 1;  // being exact requires keeping track of gas usage 
    assert_eq!(helpers::round_to_near_dp(after_seller_balance, dp), helpers::round_to_near_dp(before_seller_balance + sale_price, dp), "seller did not receive the sale price");
    assert_eq!(helpers::round_to_near_dp(after_buyer_balance, dp), helpers::round_to_near_dp(before_buyer_balance - sale_price, dp), "buyer did not receive the sale price");

    println!("      Passed ✅ test_sell_nft_listed_on_marketplace");
    Ok(())
}

async fn test_transfer_nft_when_listed_on_marketplace(
    seller: &Account,
    first_buyer: &Account,
    second_buyer: &Account,
    nft_contract: &Contract,
    market_contract: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    let token_id = "5";
    let sale_price = 3000000000000000000000000 as u128;  // 3 NEAR in yoctoNEAR
    helpers::mint_nft(seller, nft_contract, worker, token_id).await?;
    helpers::pay_for_storage(seller, market_contract, worker, 10000000000000000000000 as u128).await?;
    helpers::place_nft_for_sale(seller, market_contract, nft_contract, worker, token_id, sale_price).await?;

    helpers::transfer_nft(seller, first_buyer, nft_contract, worker, token_id).await?;

    // attempt purchase NFT
    let before_seller_balance: u128 = helpers::get_user_balance(seller, worker).await?;
    let before_buyer_balance: u128 = helpers::get_user_balance(second_buyer, worker).await?;
    helpers::purchase_listed_nft(second_buyer, market_contract, nft_contract, worker, token_id, sale_price).await?;
    let after_seller_balance: u128 = helpers::get_user_balance(seller, worker).await?;
    let after_buyer_balance: u128 = helpers::get_user_balance(second_buyer, worker).await?;

    // assert owner remains first_buyer
    let token_info: serde_json::Value = helpers::get_nft_token_info(nft_contract, worker, token_id).await?;
    let owner_id: String = token_info["owner_id"].as_str().unwrap().to_string();
    assert_eq!(owner_id, first_buyer.id().to_string(), "token owner is not first_buyer");

    // assert balances remain equal
    let dp = 1;     
    assert_eq!(helpers::round_to_near_dp(after_seller_balance, dp), helpers::round_to_near_dp(before_seller_balance, dp), "seller balance changed");
    assert_eq!(helpers::round_to_near_dp(after_buyer_balance, dp), helpers::round_to_near_dp(before_buyer_balance, dp), "buyer balance changed");

    println!("      Passed ✅ test_transfer_nft_when_listed_on_marketplace");

    Ok(())
}

async fn test_approval_revoke(
    first_user: &Account,
    second_user: &Account,
    nft_contract: &Contract,
    market_contract: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    let token_id = "6";
    let sale_price = 3000000000000000000000000 as u128;  // 3 NEAR in yoctoNEAR
    helpers::mint_nft(first_user, nft_contract, worker, token_id).await?;
    helpers::pay_for_storage(first_user, market_contract, worker, 10000000000000000000000 as u128).await?;
    helpers::place_nft_for_sale(first_user, market_contract, nft_contract, worker, token_id, sale_price).await?;

    // nft_revoke market_contract call
    let revoke_payload = json!({
        "account_id": market_contract.id(),
        "token_id": token_id,
    });
    first_user.call(&worker, nft_contract.id(), "nft_revoke")
        .args_json(revoke_payload)?
        .deposit(1)
        .transact()
        .await?;

    // market_contract attempts to nft_transfer, when second_user tries to purchase NFT on market
    let before_seller_balance: u128 = helpers::get_user_balance(first_user, worker).await?;
    let before_buyer_balance: u128 = helpers::get_user_balance(second_user, worker).await?;
    helpers::purchase_listed_nft(
        second_user, market_contract, nft_contract, worker, token_id, sale_price
    ).await?;
    let after_seller_balance: u128 = helpers::get_user_balance(first_user, worker).await?;
    let after_buyer_balance: u128 = helpers::get_user_balance(second_user, worker).await?;

    // assert owner remains first_user
    let token_info: serde_json::Value = helpers::get_nft_token_info(nft_contract, worker, token_id).await?;
    let owner_id: String = token_info["owner_id"].as_str().unwrap().to_string();
    assert_eq!(owner_id, first_user.id().to_string(), "token owner is not first_user");

    // assert balances unchanged
    assert_eq!(helpers::round_to_near_dp(after_seller_balance, 0), helpers::round_to_near_dp(before_seller_balance, 0), "seller balance changed");
    assert_eq!(helpers::round_to_near_dp(after_buyer_balance, 0), helpers::round_to_near_dp(before_buyer_balance, 0), "buyer balance changed");    

    println!("      Passed ✅ test_approval_revoke");
    Ok(())
}

async fn test_reselling_and_royalties(
    user: &Account,
    first_buyer: &Account,
    second_buyer: &Account,
    nft_contract: &Contract,
    market_contract: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    let token_id = "7";
    let sale_price = 3000000000000000000000000 as u128;  // 3 NEAR in yoctoNEAR

    // mint with royalties
    let request_payload = json!({
        "token_id": token_id,
        "receiver_id": user.id(),
        "metadata": {
            "title": "Grumpy Cat",
            "description": "Not amused.",
            "media": "https://www.adamsdrafting.com/wp-content/uploads/2018/06/More-Grumpy-Cat.jpg"
        },
        "perpetual_royalties": {
            user.id().to_string(): 2000 as u128
        }
    });
    user.call(&worker, nft_contract.id(), "nft_mint")
        .args_json(request_payload)?
        .deposit(helpers::DEFAULT_DEPOSIT)
        .transact()
        .await?;

    helpers::pay_for_storage(user, market_contract, worker, 10000000000000000000000 as u128).await?;
    helpers::place_nft_for_sale(user, market_contract, nft_contract, worker, token_id, sale_price).await?;

    // first_buyer purchases NFT
    let mut before_seller_balance: u128 = helpers::get_user_balance(user, worker).await?;
    let mut before_buyer_balance: u128 = helpers::get_user_balance(first_buyer, worker).await?;
    helpers::purchase_listed_nft(first_buyer, market_contract, nft_contract, worker, token_id, sale_price).await?;
    let mut after_seller_balance: u128 = helpers::get_user_balance(user, worker).await?;
    let mut after_buyer_balance: u128 = helpers::get_user_balance(first_buyer, worker).await?;

    // assert owner becomes first_buyer
    let token_info: serde_json::Value = helpers::get_nft_token_info(nft_contract, worker, token_id).await?;
    let owner_id: String = token_info["owner_id"].as_str().unwrap().to_string();
    assert_eq!(owner_id, first_buyer.id().to_string(), "token owner is not first_buyer");

    // assert balances changed
    assert_eq!(helpers::round_to_near_dp(after_seller_balance, 0), helpers::round_to_near_dp(before_seller_balance + sale_price, 0), "seller balance unchanged");
    assert_eq!(helpers::round_to_near_dp(after_buyer_balance, 0), helpers::round_to_near_dp(before_buyer_balance - sale_price, 0), "buyer balance unchanged");

    // first buyer lists nft for sale
    helpers::pay_for_storage(first_buyer, market_contract, worker, 10000000000000000000000 as u128).await?;
    helpers::place_nft_for_sale(first_buyer, market_contract, nft_contract, worker, token_id, sale_price).await?;

    // second_buyer purchases NFT
    let resale_price = sale_price * 5;  // 15 NEAR
    before_seller_balance = helpers::get_user_balance(first_buyer, worker).await?;
    before_buyer_balance = helpers::get_user_balance(second_buyer, worker).await?;
    let before_user_balance: u128 = helpers::get_user_balance(user, worker).await?;
    helpers::purchase_listed_nft(second_buyer, market_contract, nft_contract, worker, token_id, resale_price).await?;
    let after_user_balance: u128 = helpers::get_user_balance(user, worker).await?;
    after_seller_balance = helpers::get_user_balance(first_buyer, worker).await?;
    after_buyer_balance = helpers::get_user_balance(second_buyer, worker).await?;

    // assert owner changes to second_buyer
    let token_info: serde_json::Value = helpers::get_nft_token_info(nft_contract, worker, token_id).await?;
    let owner_id: String = token_info["owner_id"].as_str().unwrap().to_string();
    assert_eq!(owner_id, second_buyer.id().to_string(), "token owner is not second_buyer");

    // assert balances changed
    let royalty_fee = resale_price / 5;
    assert_eq!(helpers::round_to_near_dp(after_seller_balance, 0), helpers::round_to_near_dp(before_seller_balance + resale_price - royalty_fee, 0), "seller balance unchanged");
    assert_eq!(helpers::round_to_near_dp(after_buyer_balance, 0), helpers::round_to_near_dp(before_buyer_balance - resale_price, 0), "buyer balance unchanged");
    assert_eq!(helpers::round_to_near_dp(after_user_balance, 0), helpers::round_to_near_dp(before_user_balance + royalty_fee, 0), "user balance unchanged");

    println!("      Passed ✅ test_reselling_and_royalties");
    Ok(())
}

'''
'''--- nft-tutorial/integration-tests/ts/package.json ---
{
  "name": "nft-tutorial-integration-tests-ts",
  "version": "0.1.0",
  "license": "(MIT AND Apache-2.0)",
  "scripts": {
    "test": "ava"
  },
  "devDependencies": {
    "ava": "^4.3.3",
    "near-workspaces": "^3.2.2",
    "typescript": "^4.6.4",
    "ts-node": "^10.8.0",
    "@types/bn.js": "^5.1.0"
  },
  "dependencies": {}
}

'''
'''--- nft-tutorial/integration-tests/ts/src/main.ava.ts ---
import anyTest, { TestFn } from "ava";
import { NEAR, NearAccount, Worker, BN } from "near-workspaces";
import path from "path";
import {
  approveNFT, defaultCallOptions, DEFAULT_GAS, mintNFT, payForStorage,
  placeNFTForSale, purchaseListedNFT, transferNFT
} from "./utils";

const test = anyTest as TestFn<{
  worker: Worker;
  accounts: Record<string, NearAccount>;
}>;

test.beforeEach(async (t) => {
  const worker = await Worker.init();
  const root = worker.rootAccount;

  const nftContractLocation = path.join(__dirname, "../../../out/main.wasm");
  const nft_contract = await root.devDeploy(
    nftContractLocation,
    {
      method: "new_default_meta",
      args: { owner_id: root },
      initialBalance: NEAR.parse("100 N").toJSON()
    }
  );

  const marketContractLocation = path.join(__dirname, "../../../out/market.wasm");
  const market_contract = await root.devDeploy(
    marketContractLocation,
    {
      method: "new",
      args: { owner_id: root },
      initialBalance: NEAR.parse("100 N").toJSON()
    }
  );

  const alice = await root.createSubAccount("alice", {
    initialBalance: NEAR.parse("100 N").toJSON(),
  });

  const bob = await root.createSubAccount("bob", {
    initialBalance: NEAR.parse("100 N").toJSON(),
  });

  const charlie = await root.createSubAccount("charlie", {
    initialBalance: NEAR.parse("100 N").toJSON(),
  });

  t.context.worker = worker;
  t.context.accounts = { root, nft_contract, market_contract, alice, bob, charlie };
});

test.afterEach.always(async (t) => {
  await t.context.worker.tearDown().catch((error) => {
    console.log("Failed to tear down the worker:", error);
  });
});

test("nft contract: nft metadata view", async (t) => {
  const { root, nft_contract } = t.context.accounts;
  const expected = {
    base_uri: null,
    icon: null,
    name: "NFT Tutorial Contract",
    reference: null,
    reference_hash: null,
    spec: "nft-1.0.0",
    symbol: "GOTEAM",
  };
  t.deepEqual(
    await nft_contract.view("nft_metadata", { account_id: root }),
    expected
  );
});

test("nft contract: nft mint call", async (t) => {
  const { alice, nft_contract } = t.context.accounts;
  const request_payload = {
    token_id: "TEST123",
    metadata: {
      title: "LEEROYYYMMMJENKINSSS",
      description: "Alright time's up, let's do this.",
      media:
        "https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Ftse3.mm.bing.net%2Fth%3Fid%3DOIP.Fhp4lHufCdTzTeGCAblOdgHaF7%26pid%3DApi&f=1",
    },
    receiver_id: alice,
  };
  await alice.call(
    nft_contract,
    "nft_mint",
    request_payload,
    defaultCallOptions()
  );

  const tokens = await nft_contract.view("nft_tokens");
  const expected = [
    {
      approved_account_ids: {},
      metadata: {
        copies: null,
        description: "Alright time's up, let's do this.",
        expires_at: null,
        extra: null,
        issued_at: null,
        media:
          "https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Ftse3.mm.bing.net%2Fth%3Fid%3DOIP.Fhp4lHufCdTzTeGCAblOdgHaF7%26pid%3DApi&f=1",
        media_hash: null,
        reference: null,
        reference_hash: null,
        starts_at: null,
        title: "LEEROYYYMMMJENKINSSS",
        updated_at: null,
      },
      owner_id: alice.accountId,
      royalty: {},
      token_id: "TEST123",
    },
  ];
  t.deepEqual(tokens, expected, "Expected to find one minted NFT");
});

test("nft contract: nft approve call", async (t) => {
  const { alice, nft_contract, market_contract } = t.context.accounts;
  await mintNFT(alice, nft_contract);
  await approveNFT(market_contract, alice, nft_contract);

  // test if approved
  const view_payload = {
    token_id: "TEST123",
    approved_account_id: market_contract,
  };
  const approved = await nft_contract.view("nft_is_approved", view_payload);
  t.true(approved, "Failed to approve NFT");
});

test("nft contract: nft approve call long msg string", async (t) => {
  const { alice, nft_contract, market_contract } = t.context.accounts;
  await mintNFT(alice, nft_contract);
  await payForStorage(alice, market_contract);

  // approve NFT
  const approve_payload = {
    token_id: "TEST123",
    account_id: market_contract,
    msg: "sample message".repeat(10 * 1024),
  };
  const result = await alice.callRaw(
    nft_contract,
    "nft_approve",
    approve_payload,
    defaultCallOptions()
  );
  t.regex(result.receiptFailureMessages.join("\n"), /Not valid SaleArgs+/);

  // test if approved
  const view_payload = {
    token_id: "TEST123",
    approved_account_id: market_contract,
  };
  const approved = await nft_contract.view("nft_is_approved", view_payload);
  t.true(approved, "NFT approval apss without sale args");
});

test("cross contract: sell NFT listed on marketplace", async (t) => {
  const { alice, nft_contract, market_contract, bob } = t.context.accounts;
  await mintNFT(alice, nft_contract);
  await payForStorage(alice, market_contract);

  const sale_price = "300000000000000000000000"; // sale price string in yoctoNEAR is 0.3 NEAR
  await placeNFTForSale(market_contract, alice, nft_contract, sale_price);

  const alice_balance_before = await alice.availableBalance();
  const bob_balance_before = await bob.availableBalance();
  await purchaseListedNFT(nft_contract, bob, market_contract, sale_price);
  const alice_balance_after = await alice.availableBalance();
  const bob_balance_after = await bob.availableBalance();

  // assert alice balance increased by sale price
  const test_precision_dp_near = 1;
  const slice_val = test_precision_dp_near - 24;
  t.is(
    alice_balance_after.toString().slice(0, slice_val),
    alice_balance_before.add(NEAR.from(sale_price)).toString().slice(0, slice_val),
    "Alice balance should increase by sale price"
  );
  // bob balance should decrease by sale price
  t.is(
    bob_balance_after.toString().slice(0, slice_val),
    bob_balance_before.sub(NEAR.from(sale_price)).toString().slice(0, slice_val),
    "Bob balance should decrease by sale price"
  );

  // NFT has new owner
  const view_payload = {
    token_id: "TEST123",
  };
  const token_info: any = await nft_contract.view("nft_token", view_payload);
  t.is(token_info.owner_id, bob.accountId, "NFT should have been sold");
  // nothing left for sale on market
  const sale_supply = await market_contract.view("get_supply_sales");
  t.is(sale_supply, "0", "Expected no sales to be left on market");
});

test("cross contract: transfer NFT when listed on marketplace", async (t) => {
  const { alice, nft_contract, market_contract, bob, charlie } = t.context.accounts;
  await mintNFT(alice, nft_contract);
  await payForStorage(alice, market_contract);

  const sale_price = "300000000000000000000000"; // sale price string in yoctoNEAR is 0.3 NEAR
  await placeNFTForSale(market_contract, alice, nft_contract, sale_price);

  await transferNFT(bob, market_contract, nft_contract);

  // purchase NFT
  const offer_payload = {
    nft_contract_id: nft_contract,
    token_id: "TEST123",
  };
  const result = await charlie.callRaw(
    market_contract,
    "offer",
    offer_payload,
    defaultCallOptions(
      DEFAULT_GAS + "0", // 10X default amount for XCC
      sale_price // Attached deposit must be greater than or equal to the current price
    )
  );

  // assert expectations
  // NFT has same owner
  const view_payload = {
    token_id: "TEST123",
  };
  const token_info: any = await nft_contract.view("nft_token", view_payload);
  t.is(
    token_info.owner_id,
    bob.accountId, // NFT was transferred to bob
    "NFT should have bob as owner"
  );
  // Unauthorized error should be found
  t.regex(result.receiptFailureMessages.join("\n"), /Unauthorized+/);
});

test("cross contract: approval revoke", async (t) => {
  const { alice, nft_contract, market_contract, bob } = t.context.accounts;
  await mintNFT(alice, nft_contract);
  await payForStorage(alice, market_contract);
  await placeNFTForSale(
    market_contract,
    alice,
    nft_contract,
    "300000000000000000000000"
  );

  // revoke approval
  const revoke_payload = {
    token_id: "TEST123",
    account_id: market_contract, // revoke market contract authorization
  };
  await alice.call(
    nft_contract,
    "nft_revoke",
    revoke_payload,
    defaultCallOptions(DEFAULT_GAS, "1") // Requires attached deposit of exactly 1 yoctoNEAR
  );

  // transfer NFT
  const transfer_payload = {
    receiver_id: bob,
    token_id: "TEST123",
    approval_id: 1,
  };
  const result = await market_contract.callRaw(
    nft_contract,
    "nft_transfer",
    transfer_payload,
    defaultCallOptions(DEFAULT_GAS, "1")
  );

  // assert expectations
  // Unauthorized error should be found
  t.regex(result.receiptFailureMessages.join("\n"), /Unauthorized+/);
});

test("cross contract: reselling and royalties", async (t) => {
  const { alice, nft_contract, market_contract, bob, charlie } = t.context.accounts;
  const royalties_string = `{"${alice.accountId}":2000}`;
  const royalties = JSON.parse(royalties_string);
  await mintNFT(alice, nft_contract, royalties);
  await payForStorage(alice, market_contract);
  const ask_price = "300000000000000000000000";
  await placeNFTForSale(market_contract, alice, nft_contract, ask_price);

  const bid_price = ask_price + "0";

  const alice_balance_before = await alice.availableBalance();
  const bob_balance_before = await bob.availableBalance();
  await purchaseListedNFT(nft_contract, bob, market_contract, bid_price);
  const alice_balance_after = await alice.availableBalance();
  const bob_balance_after = await bob.availableBalance();

  const test_precision_dp_near = 1;
  const slice_val = test_precision_dp_near - 24;
  t.is(
    alice_balance_after.toString().slice(0, slice_val),
    alice_balance_before.add(NEAR.from(bid_price)).toString().slice(0, slice_val),
    "Alice balance should increase by sale price"
  );
  t.is(
    bob_balance_after.toString().slice(0, slice_val),
    bob_balance_before.sub(NEAR.from(bid_price)).toString().slice(0, slice_val),
    "Bob balance should decrease by sale price"
  );

  // bob relists NFT for higher price
  await payForStorage(bob, market_contract);
  const resell_ask_price = bid_price + "0";
  await placeNFTForSale(market_contract, bob, nft_contract, resell_ask_price);

  // bob updates price to lower ask
  const lowered_resell_ask_price = "600000000000000000000000";
  const update_price_payload = {
    nft_contract_id: nft_contract,
    token_id: "TEST123",
    price: lowered_resell_ask_price,
  };
  await bob.call(
    market_contract,
    "update_price",
    update_price_payload,
    defaultCallOptions(DEFAULT_GAS, "1")
  );

  const alice_balance_before_2 = await alice.availableBalance();
  const bob_balance_before_2 = await bob.availableBalance();
  const charlie_balance_before_2 = await charlie.availableBalance();
  await purchaseListedNFT(nft_contract, charlie, market_contract, resell_ask_price);
  const alice_balance_after_2 = await alice.availableBalance();
  const bob_balance_after_2 = await bob.availableBalance();
  const charlie_balance_after_2 = await charlie.availableBalance();

  t.is(
    alice_balance_after_2.sub(alice_balance_before_2).toHuman(),
    "6 N",
    "Alice balance should increase by royalty fee of 20% of sale price"
  )
  t.is(
    bob_balance_after_2.sub(bob_balance_before_2).toHuman(),
    "24.00031 N",
    "Bob balance should decrease by sale price minus royalty fee of 20% of sale price"
  )
  t.is(
    charlie_balance_before_2.sub(charlie_balance_after_2).toHuman().slice(0, 2),
    "30",
    "Charlie balance should decrease by sale price"
  )
});

'''
'''--- nft-tutorial/integration-tests/ts/src/utils.ts ---
import { BN, NearAccount } from "near-workspaces";

export const DEFAULT_GAS: string = "30000000000000";
export const DEFAULT_DEPOSIT: string = "9050000000000000000000";

export async function purchaseListedNFT(
  nft_contract: NearAccount,
  bidder_account: NearAccount,
  market_contract: NearAccount,
  bid_price: string
) {
  const offer_payload = {
    nft_contract_id: nft_contract,
    token_id: "TEST123",
  };
  await bidder_account.callRaw(
    market_contract,
    "offer",
    offer_payload,
    defaultCallOptions(DEFAULT_GAS + "0", bid_price)
  );
}

export async function placeNFTForSale(
  market_contract: NearAccount,
  owner: NearAccount,
  nft_contract: NearAccount,
  ask_price: string // sale price string in yoctoNEAR
) {
  await approveNFT(
    market_contract,
    owner,
    nft_contract,
    '{"sale_conditions": ' + `"${ask_price}"` + " }" // msg string trigger XCC
  );
}

export function defaultCallOptions(
  gas: string = DEFAULT_GAS,
  deposit: string = DEFAULT_DEPOSIT
) {
  return {
    gas: new BN(gas),
    attachedDeposit: new BN(deposit),
  };
}
export async function approveNFT(
  account_to_approve: NearAccount,
  owner: NearAccount,
  nft_contract: NearAccount,
  message?: string
) {
  const approve_payload = {
    token_id: "TEST123",
    account_id: account_to_approve,
    msg: message,
  };
  await owner.call(
    nft_contract,
    "nft_approve",
    approve_payload,
    defaultCallOptions()
  );
}

export async function mintNFT(
  user: NearAccount,
  nft_contract: NearAccount,
  royalties?: object
) {
  const mint_payload = {
    token_id: "TEST123",
    metadata: {
      title: "LEEROYYYMMMJENKINSSS",
      description: "Alright time's up, let's do this.",
      media:
        "https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Ftse3.mm.bing.net%2Fth%3Fid%3DOIP.Fhp4lHufCdTzTeGCAblOdgHaF7%26pid%3DApi&f=1",
    },
    receiver_id: user,
    perpetual_royalties: royalties,
  };
  await user.call(nft_contract, "nft_mint", mint_payload, defaultCallOptions());
}

export async function payForStorage(
  alice: NearAccount,
  market_contract: NearAccount
) {
  await alice.call(
    market_contract,
    "storage_deposit",
    {},
    defaultCallOptions(DEFAULT_GAS, "10000000000000000000000") // Requires minimum deposit of 10000000000000000000000
  );
}

export async function transferNFT(
  receiver: NearAccount,
  sender: NearAccount,
  nft_contract: NearAccount
) {
  const transfer_payload = {
    receiver_id: receiver,
    token_id: "TEST123",
    approval_id: 0, // first and only approval done in line 224
  };
  await sender.call(
    nft_contract,
    "nft_transfer",
    transfer_payload,
    defaultCallOptions(DEFAULT_GAS, "1")
  );
}

'''
'''--- nft-tutorial/market-contract/Cargo.toml ---
[package]
name = "nft_simple"
version = "0.1.0"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0"

[profile.release]
codegen-units=1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- nft-tutorial/market-contract/README.md ---
# TBD

'''
'''--- nft-tutorial/market-contract/build.sh ---
#!/bin/bash
set -e && RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release && mkdir -p ../out && cp target/wasm32-unknown-unknown/release/*.wasm ../out/market.wasm
'''
'''--- nft-tutorial/market-contract/src/external.rs ---
use crate::*;

/// external contract calls

//initiate a cross contract call to the nft contract. This will transfer the token to the buyer and return
//a payout object used for the market to distribute funds to the appropriate accounts.
#[ext_contract(ext_contract)]
trait ExtContract {
    fn nft_transfer_payout(
        &mut self,
        receiver_id: AccountId, //purchaser (person to transfer the NFT to)
        token_id: TokenId, //token ID to transfer
        approval_id: u64, //market contract's approval ID in order to transfer the token on behalf of the owner
        memo: String, //memo (to include some context)
        /*
            the price that the token was purchased for. This will be used in conjunction with the royalty percentages
            for the token in order to determine how much money should go to which account. 
        */
        balance: U128,
        //the maximum amount of accounts the market can payout at once (this is limited by GAS)
		max_len_payout: u32,
    );
}
'''
'''--- nft-tutorial/market-contract/src/internal.rs ---
use crate::*;

//used to generate a unique prefix in our storage collections (this is to avoid data collisions)
pub(crate) fn hash_account_id(account_id: &AccountId) -> CryptoHash {
    //get the default hash
    let mut hash = CryptoHash::default();
    //we hash the account ID and return it
    hash.copy_from_slice(&env::sha256(account_id.as_bytes()));
    hash
}

impl Contract {
    //internal method for removing a sale from the market. This returns the previously removed sale object
    pub(crate) fn internal_remove_sale(
        &mut self,
        nft_contract_id: AccountId,
        token_id: TokenId,
    ) -> Sale {
        //get the unique sale ID (contract + DELIMITER + token ID)
        let contract_and_token_id = format!("{}{}{}", &nft_contract_id, DELIMETER, token_id);
        //get the sale object by removing the unique sale ID. If there was no sale, panic
        let sale = self.sales.remove(&contract_and_token_id).expect("No sale");

        //get the set of sales for the sale's owner. If there's no sale, panic. 
        let mut by_owner_id = self.by_owner_id.get(&sale.owner_id).expect("No sale by_owner_id");
        //remove the unique sale ID from the set of sales
        by_owner_id.remove(&contract_and_token_id);
        
        //if the set of sales is now empty after removing the unique sale ID, we simply remove that owner from the map
        if by_owner_id.is_empty() {
            self.by_owner_id.remove(&sale.owner_id);
        //if the set of sales is not empty after removing, we insert the set back into the map for the owner
        } else {
            self.by_owner_id.insert(&sale.owner_id, &by_owner_id);
        }

        //get the set of token IDs for sale for the nft contract ID. If there's no sale, panic. 
        let mut by_nft_contract_id = self
            .by_nft_contract_id
            .get(&nft_contract_id)
            .expect("No sale by nft_contract_id");
        
        //remove the token ID from the set 
        by_nft_contract_id.remove(&token_id);
        
        //if the set is now empty after removing the token ID, we remove that nft contract ID from the map
        if by_nft_contract_id.is_empty() {
            self.by_nft_contract_id.remove(&nft_contract_id);
        //if the set is not empty after removing, we insert the set back into the map for the nft contract ID
        } else {
            self.by_nft_contract_id
                .insert(&nft_contract_id, &by_nft_contract_id);
        }

        //return the sale object
        sale
    }
}

'''
'''--- nft-tutorial/market-contract/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LookupMap, UnorderedMap, UnorderedSet};
use near_sdk::json_types::{U128, U64};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{
    assert_one_yocto, env, ext_contract, near_bindgen, AccountId, Balance, Gas, PanicOnDefault,
    Promise, CryptoHash, BorshStorageKey,
};
use std::collections::HashMap;

use crate::external::*;
use crate::internal::*;
use crate::sale::*;
use near_sdk::env::STORAGE_PRICE_PER_BYTE;

mod external;
mod internal;
mod nft_callbacks;
mod sale;
mod sale_views;

//GAS constants to attach to calls
const GAS_FOR_RESOLVE_PURCHASE: Gas = Gas(115_000_000_000_000);
const GAS_FOR_NFT_TRANSFER: Gas = Gas(15_000_000_000_000);

//the minimum storage to have a sale on the contract.
const STORAGE_PER_SALE: u128 = 1000 * STORAGE_PRICE_PER_BYTE;

//every sale will have a unique ID which is `CONTRACT + DELIMITER + TOKEN_ID`
static DELIMETER: &str = ".";

//Creating custom types to use within the contract. This makes things more readable. 
pub type SalePriceInYoctoNear = U128;
pub type TokenId = String;
pub type FungibleTokenId = AccountId;
pub type ContractAndTokenId = String;
//defines the payout type we'll be parsing from the NFT contract as a part of the royalty standard.
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Payout {
    pub payout: HashMap<AccountId, U128>,
} 

//main contract struct to store all the information
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    //keep track of the owner of the contract
    pub owner_id: AccountId,
    
    /*
        to keep track of the sales, we map the ContractAndTokenId to a Sale. 
        the ContractAndTokenId is the unique identifier for every sale. It is made
        up of the `contract ID + DELIMITER + token ID`
    */
    pub sales: UnorderedMap<ContractAndTokenId, Sale>,
    
    //keep track of all the Sale IDs for every account ID
    pub by_owner_id: LookupMap<AccountId, UnorderedSet<ContractAndTokenId>>,

    //keep track of all the token IDs for sale for a given contract
    pub by_nft_contract_id: LookupMap<AccountId, UnorderedSet<TokenId>>,

    //keep track of the storage that accounts have payed
    pub storage_deposits: LookupMap<AccountId, Balance>,
}

/// Helper structure to for keys of the persistent collections.
#[derive(BorshStorageKey, BorshSerialize)]
pub enum StorageKey {
    Sales,
    ByOwnerId,
    ByOwnerIdInner { account_id_hash: CryptoHash },
    ByNFTContractId,
    ByNFTContractIdInner { account_id_hash: CryptoHash },
    ByNFTTokenType,
    ByNFTTokenTypeInner { token_type_hash: CryptoHash },
    FTTokenIds,
    StorageDeposits,
}

#[near_bindgen]
impl Contract {
    /*
        initialization function (can only be called once).
        this initializes the contract with default data and the owner ID
        that's passed in
    */
    #[init]
    pub fn new(owner_id: AccountId) -> Self {
        let this = Self {
            //set the owner_id field equal to the passed in owner_id. 
            owner_id,

            //Storage keys are simply the prefixes used for the collections. This helps avoid data collision
            sales: UnorderedMap::new(StorageKey::Sales),
            by_owner_id: LookupMap::new(StorageKey::ByOwnerId),
            by_nft_contract_id: LookupMap::new(StorageKey::ByNFTContractId),
            storage_deposits: LookupMap::new(StorageKey::StorageDeposits),
        };

        //return the Contract object
        this
    }

    //Allows users to deposit storage. This is to cover the cost of storing sale objects on the contract
    //Optional account ID is to users can pay for storage for other people.
    #[payable]
    pub fn storage_deposit(&mut self, account_id: Option<AccountId>) {
        //get the account ID to pay for storage for
        let storage_account_id = account_id 
            //convert the valid account ID into an account ID
            .map(|a| a.into())
            //if we didn't specify an account ID, we simply use the caller of the function
            .unwrap_or_else(env::predecessor_account_id);

        //get the deposit value which is how much the user wants to add to their storage
        let deposit = env::attached_deposit();

        //make sure the deposit is greater than or equal to the minimum storage for a sale
        assert!(
            deposit >= STORAGE_PER_SALE,
            "Requires minimum deposit of {}",
            STORAGE_PER_SALE
        );

        //get the balance of the account (if the account isn't in the map we default to a balance of 0)
        let mut balance: u128 = self.storage_deposits.get(&storage_account_id).unwrap_or(0);
        //add the deposit to their balance
        balance += deposit;
        //insert the balance back into the map for that account ID
        self.storage_deposits.insert(&storage_account_id, &balance);
    }

    //Allows users to withdraw any excess storage that they're not using. Say Bob pays 0.01N for 1 sale
    //Alice then buys Bob's token. This means bob has paid 0.01N for a sale that's no longer on the marketplace
    //Bob could then withdraw this 0.01N back into his account. 
    #[payable]
    pub fn storage_withdraw(&mut self) {
        //make sure the user attaches exactly 1 yoctoNEAR for security purposes.
        //this will redirect them to the NEAR wallet (or requires a full access key). 
        assert_one_yocto();

        //the account to withdraw storage to is always the function caller
        let owner_id = env::predecessor_account_id();
        //get the amount that the user has by removing them from the map. If they're not in the map, default to 0
        let mut amount = self.storage_deposits.remove(&owner_id).unwrap_or(0);
        
        //how many sales is that user taking up currently. This returns a set
        let sales = self.by_owner_id.get(&owner_id);
        //get the length of that set. 
        let len = sales.map(|s| s.len()).unwrap_or_default();
        //how much NEAR is being used up for all the current sales on the account 
        let diff = u128::from(len) * STORAGE_PER_SALE;

        //the excess to withdraw is the total storage paid - storage being used up.
        amount -= diff;

        //if that excess to withdraw is > 0, we transfer the amount to the user.
        if amount > 0 {
            Promise::new(owner_id.clone()).transfer(amount);
        }
        //we need to add back the storage being used up into the map if it's greater than 0.
        //this is so that if the user had 500 sales on the market, we insert that value here so
        //if those sales get taken down, the user can then go and withdraw 500 sales worth of storage.
        if diff > 0 {
            self.storage_deposits.insert(&owner_id, &diff);
        }
    }

    /// views
    //return the minimum storage for 1 sale
    pub fn storage_minimum_balance(&self) -> U128 {
        U128(STORAGE_PER_SALE)
    }

    //return how much storage an account has paid for
    pub fn storage_balance_of(&self, account_id: AccountId) -> U128 {
        U128(self.storage_deposits.get(&account_id).unwrap_or(0))
    }
}

#[cfg(test)]
mod tests;

'''
'''--- nft-tutorial/market-contract/src/nft_callbacks.rs ---
use crate::*;

/// approval callbacks from NFT Contracts

//struct for keeping track of the sale conditions for a Sale
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct SaleArgs {
    pub sale_conditions: SalePriceInYoctoNear,
}

/*
    trait that will be used as the callback from the NFT contract. When nft_approve is
    called, it will fire a cross contract call to this marketplace and this is the function
    that is invoked. 
*/
trait NonFungibleTokenApprovalsReceiver {
    fn nft_on_approve(
        &mut self,
        token_id: TokenId,
        owner_id: AccountId,
        approval_id: u64,
        msg: String,
    );
}

//implementation of the trait
#[near_bindgen]
impl NonFungibleTokenApprovalsReceiver for Contract {
    /// where we add the sale because we know nft owner can only call nft_approve

    fn nft_on_approve(
        &mut self,
        token_id: TokenId,
        owner_id: AccountId,
        approval_id: u64,
        msg: String,
    ) {
        // get the contract ID which is the predecessor
        let nft_contract_id = env::predecessor_account_id();
        //get the signer which is the person who initiated the transaction
        let signer_id = env::signer_account_id();

        //make sure that the signer isn't the predecessor. This is so that we're sure
        //this was called via a cross-contract call
        assert_ne!(
            nft_contract_id,
            signer_id,
            "nft_on_approve should only be called via cross-contract call"
        );
        //make sure the owner ID is the signer. 
        assert_eq!(
            owner_id,
            signer_id,
            "owner_id should be signer_id"
        );

        //we need to enforce that the user has enough storage for 1 EXTRA sale.  

        //get the storage for a sale. dot 0 converts from U128 to u128
        let storage_amount = self.storage_minimum_balance().0;
        //get the total storage paid by the owner
        let owner_paid_storage = self.storage_deposits.get(&signer_id).unwrap_or(0);
        //get the storage required which is simply the storage for the number of sales they have + 1 
        let signer_storage_required = (self.get_supply_by_owner_id(signer_id).0 + 1) as u128 * storage_amount;
        
        //make sure that the total paid is >= the required storage
        assert!(
            owner_paid_storage >= signer_storage_required,
            "Insufficient storage paid: {}, for {} sales at {} rate of per sale",
            owner_paid_storage, signer_storage_required / STORAGE_PER_SALE, STORAGE_PER_SALE
        );

        //if all these checks pass we can create the sale conditions object.
        let SaleArgs { sale_conditions } =
            //the sale conditions come from the msg field. The market assumes that the user passed
            //in a proper msg. If they didn't, it panics. 
            near_sdk::serde_json::from_str(&msg).expect("Not valid SaleArgs");

        //create the unique sale ID which is the contract + DELIMITER + token ID
        let contract_and_token_id = format!("{}{}{}", nft_contract_id, DELIMETER, token_id);
        
        //insert the key value pair into the sales map. Key is the unique ID. value is the sale object
        self.sales.insert(
            &contract_and_token_id,
            &Sale {
                owner_id: owner_id.clone(), //owner of the sale / token
                approval_id, //approval ID for that token that was given to the market
                nft_contract_id: nft_contract_id.to_string(), //NFT contract the token was minted on
                token_id: token_id.clone(), //the actual token ID
                sale_conditions, //the sale conditions 
           },
        );

        //Extra functionality that populates collections necessary for the view calls 

        //get the sales by owner ID for the given owner. If there are none, we create a new empty set
        let mut by_owner_id = self.by_owner_id.get(&owner_id).unwrap_or_else(|| {
            UnorderedSet::new(
                StorageKey::ByOwnerIdInner {
                    //we get a new unique prefix for the collection by hashing the owner
                    account_id_hash: hash_account_id(&owner_id),
                }
                .try_to_vec()
                .unwrap(),
            )
        });
        
        //insert the unique sale ID into the set
        by_owner_id.insert(&contract_and_token_id);
        //insert that set back into the collection for the owner
        self.by_owner_id.insert(&owner_id, &by_owner_id);

        //get the token IDs for the given nft contract ID. If there are none, we create a new empty set
        let mut by_nft_contract_id = self
            .by_nft_contract_id
            .get(&nft_contract_id)
            .unwrap_or_else(|| {
                UnorderedSet::new(
                    StorageKey::ByNFTContractIdInner {
                        //we get a new unique prefix for the collection by hashing the owner
                        account_id_hash: hash_account_id(&nft_contract_id),
                    }
                    .try_to_vec()
                    .unwrap(),
                )
            });
        
        //insert the token ID into the set
        by_nft_contract_id.insert(&token_id);
        //insert the set back into the collection for the given nft contract ID
        self.by_nft_contract_id
            .insert(&nft_contract_id, &by_nft_contract_id);
    }
}

'''
'''--- nft-tutorial/market-contract/src/sale.rs ---
use crate::*;
use near_sdk::promise_result_as_success;

//struct that holds important information about each sale on the market
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Sale {
    //owner of the sale
    pub owner_id: AccountId,
    //market contract's approval ID to transfer the token on behalf of the owner
    pub approval_id: u64,
    //nft contract where the token was minted
    pub nft_contract_id: String,
    //actual token ID for sale
    pub token_id: String,
    //sale price in yoctoNEAR that the token is listed for
    pub sale_conditions: SalePriceInYoctoNear,
}

#[near_bindgen]
impl Contract {
    
    //removes a sale from the market. 
    #[payable]
    pub fn remove_sale(&mut self, nft_contract_id: AccountId, token_id: String) {
        //assert that the user has attached exactly 1 yoctoNEAR (for security reasons)
        assert_one_yocto();
        //get the sale object as the return value from removing the sale internally
        let sale = self.internal_remove_sale(nft_contract_id.into(), token_id);
        //get the predecessor of the call and make sure they're the owner of the sale
        let owner_id = env::predecessor_account_id();
        //if this fails, the remove sale will revert
        assert_eq!(owner_id, sale.owner_id, "Must be sale owner");
    }

    //updates the price for a sale on the market
    #[payable]
    pub fn update_price(
        &mut self,
        nft_contract_id: AccountId,
        token_id: String,
        price: U128,
    ) {
        //assert that the user has attached exactly 1 yoctoNEAR (for security reasons)
        assert_one_yocto();
        
        //create the unique sale ID from the nft contract and token
        let contract_id: AccountId = nft_contract_id.into();
        let contract_and_token_id = format!("{}{}{}", contract_id, DELIMETER, token_id);
        
        //get the sale object from the unique sale ID. If there is no token, panic. 
        let mut sale = self.sales.get(&contract_and_token_id).expect("No sale");

        //assert that the caller of the function is the sale owner
        assert_eq!(
            env::predecessor_account_id(),
            sale.owner_id,
            "Must be sale owner"
        );
        
        //set the sale conditions equal to the passed in price
        sale.sale_conditions = price;
        //insert the sale back into the map for the unique sale ID
        self.sales.insert(&contract_and_token_id, &sale);
    }

    //place an offer on a specific sale. The sale will go through as long as your deposit is greater than or equal to the list price
    #[payable]
    pub fn offer(&mut self, nft_contract_id: AccountId, token_id: String) {
        //get the attached deposit and make sure it's greater than 0
        let deposit = env::attached_deposit();
        assert!(deposit > 0, "Attached deposit must be greater than 0");

        //convert the nft_contract_id from a AccountId to an AccountId
        let contract_id: AccountId = nft_contract_id.into();
        //get the unique sale ID (contract + DELIMITER + token ID)
        let contract_and_token_id = format!("{}{}{}", contract_id, DELIMETER, token_id);
        
        //get the sale object from the unique sale ID. If the sale doesn't exist, panic.
        let sale = self.sales.get(&contract_and_token_id).expect("No sale");
        
        //get the buyer ID which is the person who called the function and make sure they're not the owner of the sale
        let buyer_id = env::predecessor_account_id();
        assert_ne!(sale.owner_id, buyer_id, "Cannot bid on your own sale.");
        
        //get the u128 price of the token (dot 0 converts from U128 to u128)
        let price = sale.sale_conditions.0;

        //make sure the deposit is greater than the price
        assert!(deposit >= price, "Attached deposit must be greater than or equal to the current price: {:?}", price);

        //process the purchase (which will remove the sale, transfer and get the payout from the nft contract, and then distribute royalties) 
        self.process_purchase(
            contract_id,
            token_id,
            U128(deposit),
            buyer_id,
        );
    }

    //private function used when a sale is purchased. 
    //this will remove the sale, transfer and get the payout from the nft contract, and then distribute royalties
    #[private]
    pub fn process_purchase(
        &mut self,
        nft_contract_id: AccountId,
        token_id: String,
        price: U128,
        buyer_id: AccountId,
    ) -> Promise {
        //get the sale object by removing the sale
        let sale = self.internal_remove_sale(nft_contract_id.clone(), token_id.clone());

        //initiate a cross contract call to the nft contract. This will transfer the token to the buyer and return
        //a payout object used for the market to distribute funds to the appropriate accounts.
        ext_contract::ext(nft_contract_id)
            // Attach 1 yoctoNEAR with static GAS equal to the GAS for nft transfer. Also attach an unused GAS weight of 1 by default.
            .with_attached_deposit(1)
            .with_static_gas(GAS_FOR_NFT_TRANSFER)
            .nft_transfer_payout(
                buyer_id.clone(), //purchaser (person to transfer the NFT to)
                token_id, //token ID to transfer
                sale.approval_id, //market contract's approval ID in order to transfer the token on behalf of the owner
            "payout from market".to_string(), //memo (to include some context)
            /*
                the price that the token was purchased for. This will be used in conjunction with the royalty percentages
                for the token in order to determine how much money should go to which account. 
            */
            price,
            10, //the maximum amount of accounts the market can payout at once (this is limited by GAS)
            )
        //after the transfer payout has been initiated, we resolve the promise by calling our own resolve_purchase function. 
        //resolve purchase will take the payout object returned from the nft_transfer_payout and actually pay the accounts
        .then(
            // No attached deposit with static GAS equal to the GAS for resolving the purchase. Also attach an unused GAS weight of 1 by default.
            Self::ext(env::current_account_id())
            .with_static_gas(GAS_FOR_RESOLVE_PURCHASE)
            .resolve_purchase(
                buyer_id, //the buyer and price are passed in incase something goes wrong and we need to refund the buyer
                price,
            )
        )
    }

    /*
        private method used to resolve the promise when calling nft_transfer_payout. This will take the payout object and 
        check to see if it's authentic and there's no problems. If everything is fine, it will pay the accounts. If there's a problem,
        it will refund the buyer for the price. 
    */
    #[private]
    pub fn resolve_purchase(
        &mut self,
        buyer_id: AccountId,
        price: U128,
    ) -> U128 {
        // checking for payout information returned from the nft_transfer_payout method
        let payout_option = promise_result_as_success().and_then(|value| {
            //if we set the payout_option to None, that means something went wrong and we should refund the buyer
            near_sdk::serde_json::from_slice::<Payout>(&value)
                //converts the result to an optional value
                .ok()
                //returns None if the none. Otherwise executes the following logic
                .and_then(|payout_object| {
                    //we'll check if length of the payout object is > 10 or it's empty. In either case, we return None
                    if payout_object.payout.len() > 10 || payout_object.payout.is_empty() {
                        env::log_str("Cannot have more than 10 royalties");
                        None
                    
                    //if the payout object is the correct length, we move forward
                    } else {
                        //we'll keep track of how much the nft contract wants us to payout. Starting at the full price payed by the buyer
                        let mut remainder = price.0;
                        
                        //loop through the payout and subtract the values from the remainder. 
                        for &value in payout_object.payout.values() {
                            //checked sub checks for overflow or any errors and returns None if there are problems
                            remainder = remainder.checked_sub(value.0)?;
                        }
                        //Check to see if the NFT contract sent back a faulty payout that requires us to pay more or too little. 
                        //The remainder will be 0 if the payout summed to the total price. The remainder will be 1 if the royalties
                        //we something like 3333 + 3333 + 3333. 
                        if remainder == 0 || remainder == 1 {
                            //set the payout_option to be the payout because nothing went wrong
                            Some(payout_object.payout)
                        } else {
                            //if the remainder was anything but 1 or 0, we return None
                            None
                        }
                    }
                })
        });

        // if the payout option was some payout, we set this payout variable equal to that some payout
        let payout = if let Some(payout_option) = payout_option {
            payout_option
        //if the payout option was None, we refund the buyer for the price they payed and return
        } else {
            Promise::new(buyer_id).transfer(u128::from(price));
            // leave function and return the price that was refunded
            return price;
        };

        // NEAR payouts
        for (receiver_id, amount) in payout {
            Promise::new(receiver_id).transfer(amount.0);
        }

        //return the price payout out
        price
    }
}

//this is the cross contract call that we call on our own contract. 
/*
    private method used to resolve the promise when calling nft_transfer_payout. This will take the payout object and 
    check to see if it's authentic and there's no problems. If everything is fine, it will pay the accounts. If there's a problem,
    it will refund the buyer for the price. 
*/
#[ext_contract(ext_self)]
trait ExtSelf {
    fn resolve_purchase(
        &mut self,
        buyer_id: AccountId,
        price: U128,
    ) -> Promise;
}

'''
'''--- nft-tutorial/market-contract/src/sale_views.rs ---
use crate::*;

#[near_bindgen]
impl Contract {
    /// views
    
    //returns the number of sales the marketplace has up (as a string)
    pub fn get_supply_sales(
        &self,
    ) -> U64 {
        //returns the sales object length wrapped as a U64
        U64(self.sales.len())
    }
    
    //returns the number of sales for a given account (result is a string)
    pub fn get_supply_by_owner_id(
        &self,
        account_id: AccountId,
    ) -> U64 {
        //get the set of sales for the given owner Id
        let by_owner_id = self.by_owner_id.get(&account_id);
        
        //if there as some set, we return the length but if there wasn't a set, we return 0
        if let Some(by_owner_id) = by_owner_id {
            U64(by_owner_id.len())
        } else {
            U64(0)
        }
    }

    //returns paginated sale objects for a given account. (result is a vector of sales)
    pub fn get_sales_by_owner_id(
        &self,
        account_id: AccountId,
        from_index: Option<U128>,
        limit: Option<u64>,
    ) -> Vec<Sale> {
        //get the set of token IDs for sale for the given account ID
        let by_owner_id = self.by_owner_id.get(&account_id);
        //if there was some set, we set the sales variable equal to that set. If there wasn't, sales is set to an empty vector
        let sales = if let Some(by_owner_id) = by_owner_id {
            by_owner_id
        } else {
            return vec![];
        };
        
        //we'll convert the UnorderedSet into a vector of strings
        let keys = sales.as_vector();

        //where to start pagination - if we have a from_index, we'll use that - otherwise start from 0 index
        let start = u128::from(from_index.unwrap_or(U128(0)));
        
        //iterate through the keys vector
        keys.iter()
            //skip to the index we specified in the start variable
            .skip(start as usize) 
            //take the first "limit" elements in the vector. If we didn't specify a limit, use 0
            .take(limit.unwrap_or(0) as usize) 
            //we'll map the token IDs which are strings into Sale objects
            .map(|token_id| self.sales.get(&token_id).unwrap())
            //since we turned the keys into an iterator, we need to turn it back into a vector to return
            .collect()
    }

    //get the number of sales for an nft contract. (returns a string)
    pub fn get_supply_by_nft_contract_id(
        &self,
        nft_contract_id: AccountId,
    ) -> U64 {
        //get the set of tokens for associated with the given nft contract
        let by_nft_contract_id = self.by_nft_contract_id.get(&nft_contract_id);
        
        //if there was some set, return it's length. Otherwise return 0
        if let Some(by_nft_contract_id) = by_nft_contract_id {
            U64(by_nft_contract_id.len())
        } else {
            U64(0)
        }
    }

    //returns paginated sale objects associated with a given nft contract. (result is a vector of sales)
    pub fn get_sales_by_nft_contract_id(
        &self,
        nft_contract_id: AccountId,
        from_index: Option<U128>,
        limit: Option<u64>,
    ) -> Vec<Sale> {
        //get the set of token IDs for sale for the given contract ID
        let by_nft_contract_id = self.by_nft_contract_id.get(&nft_contract_id);
        
        //if there was some set, we set the sales variable equal to that set. If there wasn't, sales is set to an empty vector
        let sales = if let Some(by_nft_contract_id) = by_nft_contract_id {
            by_nft_contract_id
        } else {
            return vec![];
        };

        //we'll convert the UnorderedSet into a vector of strings
        let keys = sales.as_vector();

        //where to start pagination - if we have a from_index, we'll use that - otherwise start from 0 index
        let start = u128::from(from_index.unwrap_or(U128(0)));
        
        //iterate through the keys vector
        keys.iter()
            //skip to the index we specified in the start variable
            .skip(start as usize) 
            //take the first "limit" elements in the vector. If we didn't specify a limit, use 0
            .take(limit.unwrap_or(0) as usize) 
            //we'll map the token IDs which are strings into Sale objects by passing in the unique sale ID (contract + DELIMITER + token ID)
            .map(|token_id| self.sales.get(&format!("{}{}{}", nft_contract_id, DELIMETER, token_id)).unwrap())
            //since we turned the keys into an iterator, we need to turn it back into a vector to return
            .collect()
    }

    //get a sale information for a given unique sale ID (contract + DELIMITER + token ID)
    pub fn get_sale(&self, nft_contract_token: ContractAndTokenId) -> Option<Sale> {
        //try and get the sale object for the given unique sale ID. Will return an option since
        //we're not guaranteed that the unique sale ID passed in will be valid.
        self.sales.get(&nft_contract_token)
    }
}

'''
'''--- nft-tutorial/market-contract/src/tests.rs ---
/* unit tests */
use crate::sale::Sale;
#[cfg(test)]
use crate::Contract;
use near_sdk::{
    collections::UnorderedSet,
    env,
    json_types::{U128, U64},
    test_utils::{accounts, VMContextBuilder},
    testing_env, AccountId,
};

const MIN_REQUIRED_APPROVAL_YOCTO: u128 = 170000000000000000000;
const MIN_REQUIRED_STORAGE_YOCTO: u128 = 10000000000000000000000;

fn get_context(predecessor: AccountId) -> VMContextBuilder {
    let mut builder = VMContextBuilder::new();
    builder.predecessor_account_id(predecessor);
    builder
}

#[test]
#[should_panic(expected = "The contract is not initialized")]
fn test_default() {
    let context = get_context(accounts(0));
    testing_env!(context.build());
    let _contract = Contract::default();
}

#[test]
#[should_panic(expected = "Requires minimum deposit of 10000000000000000000000")]
fn test_storage_deposit_insufficient_deposit() {
    let mut context = get_context(accounts(0));
    testing_env!(context.build());
    let mut contract = Contract::new(accounts(0));
    testing_env!(context
        .storage_usage(env::storage_usage())
        .attached_deposit(MIN_REQUIRED_APPROVAL_YOCTO)
        .predecessor_account_id(accounts(0))
        .build());
    contract.storage_deposit(Some(accounts(0)));
}

#[test]
fn test_storage_deposit() {
    let mut context = get_context(accounts(0));
    testing_env!(context.build());
    let mut contract = Contract::new(accounts(0));
    testing_env!(context
        .storage_usage(env::storage_usage())
        .attached_deposit(MIN_REQUIRED_STORAGE_YOCTO)
        .predecessor_account_id(accounts(0))
        .build());
    contract.storage_deposit(Some(accounts(0)));
    let outcome = contract.storage_deposits.get(&accounts(0));
    let expected = MIN_REQUIRED_STORAGE_YOCTO;
    assert_eq!(outcome, Some(expected));
}

#[test]
fn test_storage_balance_of() {
    let mut context = get_context(accounts(0));
    testing_env!(context.build());
    let mut contract = Contract::new(accounts(0));
    testing_env!(context
        .storage_usage(env::storage_usage())
        .attached_deposit(MIN_REQUIRED_STORAGE_YOCTO)
        .predecessor_account_id(accounts(0))
        .build());
    contract.storage_deposit(Some(accounts(0)));
    let balance = contract.storage_balance_of(accounts(0));
    assert_eq!(balance, U128(MIN_REQUIRED_STORAGE_YOCTO));
}

#[test]
fn test_storage_withdraw() {
    let mut context = get_context(accounts(0));
    testing_env!(context.build());
    let mut contract = Contract::new(accounts(0));

    // deposit amount
    testing_env!(context
        .storage_usage(env::storage_usage())
        .attached_deposit(MIN_REQUIRED_STORAGE_YOCTO)
        .predecessor_account_id(accounts(0))
        .build());
    contract.storage_deposit(Some(accounts(0)));

    // withdraw amount
    testing_env!(context
        .storage_usage(env::storage_usage())
        .attached_deposit(U128(1).0) // below func requires a min of 1 yocto attached
        .predecessor_account_id(accounts(0))
        .build());
    contract.storage_withdraw();

    let remaining_amount = contract.storage_balance_of(accounts(0));
    assert_eq!(remaining_amount, U128(0))
}

#[test]
fn test_remove_sale() {
    let mut context = get_context(accounts(0));
    testing_env!(context.build());
    let mut contract = Contract::new(accounts(0));

    // deposit amount
    testing_env!(context
        .storage_usage(env::storage_usage())
        .attached_deposit(MIN_REQUIRED_STORAGE_YOCTO)
        .predecessor_account_id(accounts(0))
        .build());
    contract.storage_deposit(Some(accounts(0)));

    // add sale
    let token_id = String::from("0n3C0ntr4ctT0Rul3Th3m4ll");
    let sale = Sale {
        owner_id: accounts(0).clone(), //owner of the sale / token
        approval_id: U64(1).0,         //approval ID for that token that was given to the market
        nft_contract_id: env::predecessor_account_id().to_string(), //NFT contract the token was minted on
        token_id: token_id.clone(),                                 //the actual token ID
        sale_conditions: U128(100), //the sale conditions -- price in YOCTO NEAR
    };
    let nft_contract_id = env::predecessor_account_id();
    let contract_and_token_id = format!("{}{}{}", nft_contract_id, ".", token_id);
    contract.sales.insert(&contract_and_token_id, &sale);
    let owner_token_set = UnorderedSet::new(contract_and_token_id.as_bytes());
    contract
        .by_owner_id
        .insert(&sale.owner_id, &owner_token_set);
    let nft_token_set = UnorderedSet::new(token_id.as_bytes());
    contract
        .by_nft_contract_id
        .insert(&sale.owner_id, &nft_token_set);
    assert_eq!(contract.sales.len(), 1, "Failed to insert sale to contract");

    // remove sale
    testing_env!(context
        .storage_usage(env::storage_usage())
        .attached_deposit(U128(1).0) // below func requires a min of 1 yocto attached
        .predecessor_account_id(accounts(0))
        .build());
    contract.remove_sale(nft_contract_id, token_id);
    assert_eq!(
        contract.sales.len(),
        0,
        "Failed to remove sale from contract"
    );
}

#[test]
fn test_update_price() {
    let mut context = get_context(accounts(0));
    testing_env!(context.build());
    let mut contract = Contract::new(accounts(0));

    // deposit amount
    testing_env!(context
        .storage_usage(env::storage_usage())
        .attached_deposit(MIN_REQUIRED_STORAGE_YOCTO)
        .predecessor_account_id(accounts(0))
        .build());
    contract.storage_deposit(Some(accounts(0)));

    // add sale
    let token_id = String::from("0n3C0ntr4ctT0Rul3Th3m4ll");
    let nft_bid_yocto = U128(100);
    let sale = Sale {
        owner_id: accounts(0).clone(), //owner of the sale / token
        approval_id: U64(1).0,         //approval ID for that token that was given to the market
        nft_contract_id: env::predecessor_account_id().to_string(), //NFT contract the token was minted on
        token_id: token_id.clone(),                                 //the actual token ID
        sale_conditions: nft_bid_yocto, //the sale conditions -- price in YOCTO NEAR
    };
    let nft_contract_id = env::predecessor_account_id();
    let contract_and_token_id = format!("{}{}{}", nft_contract_id, ".", token_id);
    contract.sales.insert(&contract_and_token_id, &sale);
    let owner_token_set = UnorderedSet::new(contract_and_token_id.as_bytes());
    contract
        .by_owner_id
        .insert(&sale.owner_id, &owner_token_set);
    let nft_token_set = UnorderedSet::new(token_id.as_bytes());
    contract
        .by_nft_contract_id
        .insert(&sale.owner_id, &nft_token_set);
    assert_eq!(contract.sales.len(), 1, "Failed to insert sale to contract");

    // update price 
    let new_price = U128(150);
    testing_env!(context
        .storage_usage(env::storage_usage())
        .attached_deposit(U128(1).0)
        .predecessor_account_id(accounts(0))  // bob to buy NFT from alice
        .build());
    contract.update_price(nft_contract_id, token_id, new_price);

    // test update price success
    let sale = contract.sales.get(&contract_and_token_id).expect("No sale");
    assert_eq!(sale.sale_conditions, new_price);
}
'''
'''--- nft-tutorial/nft-contract/Cargo.toml ---
[package]
name = "nft_simple"
version = "0.1.0"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0"
serde_json = "1.0"

[profile.release]
codegen-units=1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- nft-tutorial/nft-contract/README.md ---
# TBD

'''
'''--- nft-tutorial/nft-contract/build.sh ---
#!/bin/bash
set -e && RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release && mkdir -p ../out && cp target/wasm32-unknown-unknown/release/*.wasm ../out/main.wasm
'''
'''--- nft-tutorial/nft-contract/src/approval.rs ---
use crate::*;
use near_sdk::{ext_contract};

pub trait NonFungibleTokenCore {
    //approve an account ID to transfer a token on your behalf
    fn nft_approve(&mut self, token_id: TokenId, account_id: AccountId, msg: Option<String>);

    //check if the passed in account has access to approve the token ID
	fn nft_is_approved(
        &self,
        token_id: TokenId,
        approved_account_id: AccountId,
        approval_id: Option<u64>,
    ) -> bool;

    //revoke a specific account from transferring the token on your behalf
    fn nft_revoke(&mut self, token_id: TokenId, account_id: AccountId);

    //revoke all accounts from transferring the token on your behalf
    fn nft_revoke_all(&mut self, token_id: TokenId);
}

#[ext_contract(ext_non_fungible_approval_receiver)]
trait NonFungibleTokenApprovalsReceiver {
    //cross contract call to an external contract that is initiated during nft_approve
    fn nft_on_approve(
        &mut self,
        token_id: TokenId,
        owner_id: AccountId,
        approval_id: u64,
        msg: String,
    );
}

#[near_bindgen]
impl NonFungibleTokenCore for Contract {

    //allow a specific account ID to approve a token on your behalf
    #[payable]
    fn nft_approve(&mut self, token_id: TokenId, account_id: AccountId, msg: Option<String>) {
        /*
            assert at least one yocto for security reasons - this will cause a redirect to the NEAR wallet.
            The user needs to attach enough to pay for storage on the contract
        */
        assert_at_least_one_yocto();

        //get the token object from the token ID
        let mut token = self.tokens_by_id.get(&token_id).expect("No token");

        //make sure that the person calling the function is the owner of the token
        assert_eq!(
            &env::predecessor_account_id(),
            &token.owner_id,
            "Predecessor must be the token owner."
        );

        //get the next approval ID if we need a new approval
        let approval_id: u64 = token.next_approval_id;

        //check if the account has been approved already for this token
        let is_new_approval = token
            .approved_account_ids
            //insert returns none if the key was not present.  
            .insert(account_id.clone(), approval_id)
            //if the key was not present, .is_none() will return true so it is a new approval.
            .is_none();

        //if it was a new approval, we need to calculate how much storage is being used to add the account.
        let storage_used = if is_new_approval {
            bytes_for_approved_account_id(&account_id)
        //if it was not a new approval, we used no storage.
        } else {
            0
        };

        //increment the token's next approval ID by 1
        token.next_approval_id += 1;
        //insert the token back into the tokens_by_id collection
        self.tokens_by_id.insert(&token_id, &token);

        //refund any excess storage attached by the user. If the user didn't attach enough, panic. 
        refund_deposit(storage_used);

        //if some message was passed into the function, we initiate a cross contract call on the
        //account we're giving access to. 
        if let Some(msg) = msg {
            // Defaulting GAS weight to 1, no attached deposit, and no static GAS to attach.
            ext_non_fungible_approval_receiver::ext(account_id)
                .nft_on_approve(
                    token_id, 
                    token.owner_id, 
                    approval_id, 
                    msg
                ).as_return();
        }
    }

    //check if the passed in account has access to approve the token ID
	fn nft_is_approved(
        &self,
        token_id: TokenId,
        approved_account_id: AccountId,
        approval_id: Option<u64>,
    ) -> bool {
        //get the token object from the token_id
        let token = self.tokens_by_id.get(&token_id).expect("No token");

        //get the approval number for the passed in account ID
		let approval = token.approved_account_ids.get(&approved_account_id);

        //if there was some approval ID found for the account ID
        if let Some(approval) = approval {
            //if a specific approval_id was passed into the function
			if let Some(approval_id) = approval_id {
                //return if the approval ID passed in matches the actual approval ID for the account
				approval_id == *approval
            //if there was no approval_id passed into the function, we simply return true
			} else {
				true
			}
        //if there was no approval ID found for the account ID, we simply return false
		} else {
			false
		}
    }

    //revoke a specific account from transferring the token on your behalf 
    #[payable]
    fn nft_revoke(&mut self, token_id: TokenId, account_id: AccountId) {
        //assert that the user attached exactly 1 yoctoNEAR for security reasons
        assert_one_yocto();
        //get the token object using the passed in token_id
        let mut token = self.tokens_by_id.get(&token_id).expect("No token");

        //get the caller of the function and assert that they are the owner of the token
        let predecessor_account_id = env::predecessor_account_id();
        assert_eq!(&predecessor_account_id, &token.owner_id);

        //if the account ID was in the token's approval, we remove it and the if statement logic executes
        if token
            .approved_account_ids
            .remove(&account_id)
            .is_some()
        {
            //refund the funds released by removing the approved_account_id to the caller of the function
            refund_approved_account_ids_iter(predecessor_account_id, [account_id].iter());

            //insert the token back into the tokens_by_id collection with the account_id removed from the approval list
            self.tokens_by_id.insert(&token_id, &token);
        }
    }

    //revoke all accounts from transferring the token on your behalf
    #[payable]
    fn nft_revoke_all(&mut self, token_id: TokenId) {
        //assert that the caller attached exactly 1 yoctoNEAR for security
        assert_one_yocto();

        //get the token object from the passed in token ID
        let mut token = self.tokens_by_id.get(&token_id).expect("No token");
        //get the caller and make sure they are the owner of the tokens
        let predecessor_account_id = env::predecessor_account_id();
        assert_eq!(&predecessor_account_id, &token.owner_id);

        //only revoke if the approved account IDs for the token is not empty
        if !token.approved_account_ids.is_empty() {
            //refund the approved account IDs to the caller of the function
            refund_approved_account_ids(predecessor_account_id, &token.approved_account_ids);
            //clear the approved account IDs
            token.approved_account_ids.clear();
            //insert the token back into the tokens_by_id collection with the approved account IDs cleared
            self.tokens_by_id.insert(&token_id, &token);
        }
    }
}
'''
'''--- nft-tutorial/nft-contract/src/enumeration.rs ---
use crate::*;

#[near_bindgen]
impl Contract {
    //Query for the total supply of NFTs on the contract
    pub fn nft_total_supply(&self) -> U128 {
        //return the length of the token metadata by ID
        U128(self.token_metadata_by_id.len() as u128)
    }

    //Query for nft tokens on the contract regardless of the owner using pagination
    pub fn nft_tokens(&self, from_index: Option<U128>, limit: Option<u64>) -> Vec<JsonToken> {
        //where to start pagination - if we have a from_index, we'll use that - otherwise start from 0 index
        let start = u128::from(from_index.unwrap_or(U128(0)));

        //iterate through each token using an iterator
        self.token_metadata_by_id.keys()
            //skip to the index we specified in the start variable
            .skip(start as usize) 
            //take the first "limit" elements in the vector. If we didn't specify a limit, use 50
            .take(limit.unwrap_or(50) as usize) 
            //we'll map the token IDs which are strings into Json Tokens
            .map(|token_id| self.nft_token(token_id.clone()).unwrap())
            //since we turned the keys into an iterator, we need to turn it back into a vector to return
            .collect()
    }

    //get the total supply of NFTs for a given owner
    pub fn nft_supply_for_owner(
        &self,
        account_id: AccountId,
    ) -> U128 {
        //get the set of tokens for the passed in owner
        let tokens_for_owner_set = self.tokens_per_owner.get(&account_id);

        //if there is some set of tokens, we'll return the length as a U128
        if let Some(tokens_for_owner_set) = tokens_for_owner_set {
            U128(tokens_for_owner_set.len() as u128)
        } else {
            //if there isn't a set of tokens for the passed in account ID, we'll return 0
            U128(0)
        }
    }

    //Query for all the tokens for an owner
    pub fn nft_tokens_for_owner(
        &self,
        account_id: AccountId,
        from_index: Option<U128>,
        limit: Option<u64>,
    ) -> Vec<JsonToken> {
        //get the set of tokens for the passed in owner
        let tokens_for_owner_set = self.tokens_per_owner.get(&account_id);
        //if there is some set of tokens, we'll set the tokens variable equal to that set
        let tokens = if let Some(tokens_for_owner_set) = tokens_for_owner_set {
            tokens_for_owner_set
        } else {
            //if there is no set of tokens, we'll simply return an empty vector. 
            return vec![];
        };

        //where to start pagination - if we have a from_index, we'll use that - otherwise start from 0 index
        let start = u128::from(from_index.unwrap_or(U128(0)));

        //iterate through the keys vector
        tokens.iter()
            //skip to the index we specified in the start variable
            .skip(start as usize) 
            //take the first "limit" elements in the vector. If we didn't specify a limit, use 50
            .take(limit.unwrap_or(50) as usize) 
            //we'll map the token IDs which are strings into Json Tokens
            .map(|token_id| self.nft_token(token_id.clone()).unwrap())
            //since we turned the keys into an iterator, we need to turn it back into a vector to return
            .collect()
    }
}

'''
'''--- nft-tutorial/nft-contract/src/events.rs ---
use std::fmt;

use near_sdk::serde::{Deserialize, Serialize};

/// Enum that represents the data type of the EventLog.
/// The enum can either be an NftMint or an NftTransfer.
#[derive(Serialize, Deserialize, Debug)]
#[serde(tag = "event", content = "data")]
#[serde(rename_all = "snake_case")]
#[serde(crate = "near_sdk::serde")]
#[non_exhaustive]
pub enum EventLogVariant {
    NftMint(Vec<NftMintLog>),
    NftTransfer(Vec<NftTransferLog>),
}

/// Interface to capture data about an event
///
/// Arguments:
/// * `standard`: name of standard e.g. nep171
/// * `version`: e.g. 1.0.0
/// * `event`: associate event data
#[derive(Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct EventLog {
    pub standard: String,
    pub version: String,

    // `flatten` to not have "event": {<EventLogVariant>} in the JSON, just have the contents of {<EventLogVariant>}.
    #[serde(flatten)]
    pub event: EventLogVariant,
}

impl fmt::Display for EventLog {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_fmt(format_args!(
            "EVENT_JSON:{}",
            &serde_json::to_string(self).map_err(|_| fmt::Error)?
        ))
    }
}

/// An event log to capture token minting
///
/// Arguments
/// * `owner_id`: "account.near"
/// * `token_ids`: ["1", "abc"]
/// * `memo`: optional message
#[derive(Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct NftMintLog {
    pub owner_id: String,
    pub token_ids: Vec<String>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub memo: Option<String>,
}

/// An event log to capture token transfer
///
/// Arguments
/// * `authorized_id`: approved account to transfer
/// * `old_owner_id`: "owner.near"
/// * `new_owner_id`: "receiver.near"
/// * `token_ids`: ["1", "12345abc"]
/// * `memo`: optional message
#[derive(Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct NftTransferLog {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub authorized_id: Option<String>,

    pub old_owner_id: String,
    pub new_owner_id: String,
    pub token_ids: Vec<String>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub memo: Option<String>,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn nep_format_vector() {
        let expected = r#"EVENT_JSON:{"standard":"nep171","version":"1.0.0","event":"nft_mint","data":[{"owner_id":"foundation.near","token_ids":["aurora","proximitylabs"]},{"owner_id":"user1.near","token_ids":["meme"]}]}"#;
        let log = EventLog {
            standard: "nep171".to_string(),
            version: "1.0.0".to_string(),
            event: EventLogVariant::NftMint(vec![
                NftMintLog {
                    owner_id: "foundation.near".to_owned(),
                    token_ids: vec!["aurora".to_string(), "proximitylabs".to_string()],
                    memo: None,
                },
                NftMintLog {
                    owner_id: "user1.near".to_owned(),
                    token_ids: vec!["meme".to_string()],
                    memo: None,
                },
            ]),
        };
        assert_eq!(expected, log.to_string());
    }

    #[test]
    fn nep_format_mint() {
        let expected = r#"EVENT_JSON:{"standard":"nep171","version":"1.0.0","event":"nft_mint","data":[{"owner_id":"foundation.near","token_ids":["aurora","proximitylabs"]}]}"#;
        let log = EventLog {
            standard: "nep171".to_string(),
            version: "1.0.0".to_string(),
            event: EventLogVariant::NftMint(vec![NftMintLog {
                owner_id: "foundation.near".to_owned(),
                token_ids: vec!["aurora".to_string(), "proximitylabs".to_string()],
                memo: None,
            }]),
        };
        assert_eq!(expected, log.to_string());
    }

    #[test]
    fn nep_format_transfer_all_fields() {
        let expected = r#"EVENT_JSON:{"standard":"nep171","version":"1.0.0","event":"nft_transfer","data":[{"authorized_id":"market.near","old_owner_id":"user1.near","new_owner_id":"user2.near","token_ids":["token"],"memo":"Go Team!"}]}"#;
        let log = EventLog {
            standard: "nep171".to_string(),
            version: "1.0.0".to_string(),
            event: EventLogVariant::NftTransfer(vec![NftTransferLog {
                authorized_id: Some("market.near".to_string()),
                old_owner_id: "user1.near".to_string(),
                new_owner_id: "user2.near".to_string(),
                token_ids: vec!["token".to_string()],
                memo: Some("Go Team!".to_owned()),
            }]),
        };
        assert_eq!(expected, log.to_string());
    }
} 
'''
'''--- nft-tutorial/nft-contract/src/internal.rs ---
use crate::*;
use near_sdk::{CryptoHash};
use std::mem::size_of;

//convert the royalty percentage and amount to pay into a payout (U128)
pub(crate) fn royalty_to_payout(royalty_percentage: u32, amount_to_pay: Balance) -> U128 {
    U128(royalty_percentage as u128 * amount_to_pay / 10_000u128)
}

//calculate how many bytes the account ID is taking up
pub(crate) fn bytes_for_approved_account_id(account_id: &AccountId) -> u64 {
    // The extra 4 bytes are coming from Borsh serialization to store the length of the string.
    account_id.as_str().len() as u64 + 4 + size_of::<u64>() as u64
}

//refund the storage taken up by passed in approved account IDs and send the funds to the passed in account ID. 
pub(crate) fn refund_approved_account_ids_iter<'a, I>(
    account_id: AccountId,
    approved_account_ids: I, //the approved account IDs must be passed in as an iterator
) -> Promise
where
    I: Iterator<Item = &'a AccountId>,
{
    //get the storage total by going through and summing all the bytes for each approved account IDs
    let storage_released: u64 = approved_account_ids.map(bytes_for_approved_account_id).sum();
    //transfer the account the storage that is released
    Promise::new(account_id).transfer(Balance::from(storage_released) * env::storage_byte_cost())
}

//refund a map of approved account IDs and send the funds to the passed in account ID
pub(crate) fn refund_approved_account_ids(
    account_id: AccountId,
    approved_account_ids: &HashMap<AccountId, u64>,
) -> Promise {
    //call the refund_approved_account_ids_iter with the approved account IDs as keys
    refund_approved_account_ids_iter(account_id, approved_account_ids.keys())
}

//used to generate a unique prefix in our storage collections (this is to avoid data collisions)
pub(crate) fn hash_account_id(account_id: &AccountId) -> CryptoHash {
    //get the default hash
    let mut hash = CryptoHash::default();
    //we hash the account ID and return it
    hash.copy_from_slice(&env::sha256(account_id.as_bytes()));
    hash
}

//used to make sure the user attached exactly 1 yoctoNEAR
pub(crate) fn assert_one_yocto() {
    assert_eq!(
        env::attached_deposit(),
        1,
        "Requires attached deposit of exactly 1 yoctoNEAR",
    )
}

//Assert that the user has attached at least 1 yoctoNEAR (for security reasons and to pay for storage)
pub(crate) fn assert_at_least_one_yocto() {
    assert!(
        env::attached_deposit() >= 1,
        "Requires attached deposit of at least 1 yoctoNEAR",
    )
}

//refund the initial deposit based on the amount of storage that was used up
pub(crate) fn refund_deposit(storage_used: u64) {
    //get how much it would cost to store the information
    let required_cost = env::storage_byte_cost() * Balance::from(storage_used);
    //get the attached deposit
    let attached_deposit = env::attached_deposit();

    //make sure that the attached deposit is greater than or equal to the required cost
    assert!(
        required_cost <= attached_deposit,
        "Must attach {} yoctoNEAR to cover storage",
        required_cost,
    );

    //get the refund amount from the attached deposit - required cost
    let refund = attached_deposit - required_cost;

    //if the refund is greater than 1 yocto NEAR, we refund the predecessor that amount
    if refund > 1 {
        Promise::new(env::predecessor_account_id()).transfer(refund);
    }
}

impl Contract {
    //add a token to the set of tokens an owner has
    pub(crate) fn internal_add_token_to_owner(
        &mut self,
        account_id: &AccountId,
        token_id: &TokenId,
    ) {
        //get the set of tokens for the given account
        let mut tokens_set = self.tokens_per_owner.get(account_id).unwrap_or_else(|| {
            //if the account doesn't have any tokens, we create a new unordered set
            UnorderedSet::new(
                StorageKey::TokenPerOwnerInner {
                    //we get a new unique prefix for the collection
                    account_id_hash: hash_account_id(&account_id),
                }
                .try_to_vec()
                .unwrap(),
            )
        });

        //we insert the token ID into the set
        tokens_set.insert(token_id);

        //we insert that set for the given account ID. 
        self.tokens_per_owner.insert(account_id, &tokens_set);
    }

    //remove a token from an owner (internal method and can't be called directly via CLI).
    pub(crate) fn internal_remove_token_from_owner(
        &mut self,
        account_id: &AccountId,
        token_id: &TokenId,
    ) {
        //we get the set of tokens that the owner has
        let mut tokens_set = self
            .tokens_per_owner
            .get(account_id)
            //if there is no set of tokens for the owner, we panic with the following message:
            .expect("Token should be owned by the sender");

        //we remove the the token_id from the set of tokens
        tokens_set.remove(token_id);

        //if the token set is now empty, we remove the owner from the tokens_per_owner collection
        if tokens_set.is_empty() {
            self.tokens_per_owner.remove(account_id);
        } else {
        //if the token set is not empty, we simply insert it back for the account ID. 
            self.tokens_per_owner.insert(account_id, &tokens_set);
        }
    }

    //transfers the NFT to the receiver_id (internal method and can't be called directly via CLI).
    pub(crate) fn internal_transfer(
        &mut self,
        sender_id: &AccountId,
        receiver_id: &AccountId,
        token_id: &TokenId,
        //we introduce an approval ID so that people with that approval ID can transfer the token
        approval_id: Option<u64>,
        memo: Option<String>,
    ) -> Token {
        //get the token object by passing in the token_id
        let token = self.tokens_by_id.get(token_id).expect("No token");

        //if the sender doesn't equal the owner, we check if the sender is in the approval list
		if sender_id != &token.owner_id {
			//if the token's approved account IDs doesn't contain the sender, we panic
			if !token.approved_account_ids.contains_key(sender_id) {
				env::panic_str("Unauthorized");
			}

			// If they included an approval_id, check if the sender's actual approval_id is the same as the one included
			if let Some(enforced_approval_id) = approval_id {
                //get the actual approval ID
				let actual_approval_id = token
					.approved_account_ids
					.get(sender_id)
                    //if the sender isn't in the map, we panic
					.expect("Sender is not approved account");

                //make sure that the actual approval ID is the same as the one provided
                assert_eq!(
					actual_approval_id, &enforced_approval_id,
					"The actual approval_id {} is different from the given approval_id {}",
					actual_approval_id, enforced_approval_id,
				);
			}
		}

        //we make sure that the sender isn't sending the token to themselves
        assert_ne!(
            &token.owner_id, receiver_id,
            "The token owner and the receiver should be different"
        );

        //we remove the token from it's current owner's set
        self.internal_remove_token_from_owner(&token.owner_id, token_id);
        //we then add the token to the receiver_id's set
        self.internal_add_token_to_owner(receiver_id, token_id);

        //we create a new token struct 
        let new_token = Token {
            owner_id: receiver_id.clone(),
            //reset the approval account IDs
            approved_account_ids: Default::default(),
            next_approval_id: token.next_approval_id,
            //we copy over the royalties from the previous token
            royalty: token.royalty.clone(),
        };
        //insert that new token into the tokens_by_id, replacing the old entry 
        self.tokens_by_id.insert(token_id, &new_token);

        //if there was some memo attached, we log it. 
        if let Some(memo) = memo.as_ref() {
            env::log_str(&format!("Memo: {}", memo).to_string());
        }

        // Default the authorized ID to be None for the logs.
        let mut authorized_id = None;
        //if the approval ID was provided, set the authorized ID equal to the sender
        if approval_id.is_some() {
            authorized_id = Some(sender_id.to_string());
        }

        // Construct the transfer log as per the events standard.
        let nft_transfer_log: EventLog = EventLog {
            // Standard name ("nep171").
            standard: NFT_STANDARD_NAME.to_string(),
            // Version of the standard ("nft-1.0.0").
            version: NFT_METADATA_SPEC.to_string(),
            // The data related with the event stored in a vector.
            event: EventLogVariant::NftTransfer(vec![NftTransferLog {
                // The optional authorized account ID to transfer the token on behalf of the old owner.
                authorized_id,
                // The old owner's account ID.
                old_owner_id: token.owner_id.to_string(),
                // The account ID of the new owner of the token.
                new_owner_id: receiver_id.to_string(),
                // A vector containing the token IDs as strings.
                token_ids: vec![token_id.to_string()],
                // An optional memo to include.
                memo,
            }]),
        };

        // Log the serialized json.
        env::log_str(&nft_transfer_log.to_string());
        
        //return the previous token object that was transferred.
        token
    }
} 
'''
'''--- nft-tutorial/nft-contract/src/lib.rs ---
use std::collections::HashMap;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LazyOption, LookupMap, UnorderedMap, UnorderedSet};
use near_sdk::json_types::{Base64VecU8, U128};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{
    env, near_bindgen, AccountId, Balance, CryptoHash, PanicOnDefault, Promise, PromiseOrValue,
};

use crate::internal::*;
pub use crate::metadata::*;
pub use crate::mint::*;
pub use crate::nft_core::*;
pub use crate::approval::*;
pub use crate::royalty::*;
pub use crate::events::*;

mod internal;
mod approval; 
mod enumeration; 
mod metadata; 
mod mint; 
mod nft_core; 
mod royalty; 
mod events;

/// This spec can be treated like a version of the standard.
pub const NFT_METADATA_SPEC: &str = "1.0.0";
/// This is the name of the NFT standard we're using
pub const NFT_STANDARD_NAME: &str = "nep171";

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    //contract owner
    pub owner_id: AccountId,

    //keeps track of all the token IDs for a given account
    pub tokens_per_owner: LookupMap<AccountId, UnorderedSet<TokenId>>,

    //keeps track of the token struct for a given token ID
    pub tokens_by_id: LookupMap<TokenId, Token>,

    //keeps track of the token metadata for a given token ID
    pub token_metadata_by_id: UnorderedMap<TokenId, TokenMetadata>,

    //keeps track of the metadata for the contract
    pub metadata: LazyOption<NFTContractMetadata>,
}

/// Helper structure for keys of the persistent collections.
#[derive(BorshSerialize)]
pub enum StorageKey {
    TokensPerOwner,
    TokenPerOwnerInner { account_id_hash: CryptoHash },
    TokensById,
    TokenMetadataById,
    NFTContractMetadata,
    TokensPerType,
    TokensPerTypeInner { token_type_hash: CryptoHash },
    TokenTypesLocked,
}

#[near_bindgen]
impl Contract {
    /*
        initialization function (can only be called once).
        this initializes the contract with default metadata so the
        user doesn't have to manually type metadata.
    */
    #[init]
    pub fn new_default_meta(owner_id: AccountId) -> Self {
        //calls the other function "new: with some default metadata and the owner_id passed in 
        Self::new(
            owner_id,
            NFTContractMetadata {
                spec: "nft-1.0.0".to_string(),
                name: "NFT Tutorial Contract".to_string(),
                symbol: "GOTEAM".to_string(),
                icon: None,
                base_uri: None,
                reference: None,
                reference_hash: None,
            },
        )
    }

    /*
        initialization function (can only be called once).
        this initializes the contract with metadata that was passed in and
        the owner_id. 
    */
    #[init]
    pub fn new(owner_id: AccountId, metadata: NFTContractMetadata) -> Self {
        //create a variable of type Self with all the fields initialized. 
        let this = Self {
            //Storage keys are simply the prefixes used for the collections. This helps avoid data collision
            tokens_per_owner: LookupMap::new(StorageKey::TokensPerOwner.try_to_vec().unwrap()),
            tokens_by_id: LookupMap::new(StorageKey::TokensById.try_to_vec().unwrap()),
            token_metadata_by_id: UnorderedMap::new(
                StorageKey::TokenMetadataById.try_to_vec().unwrap(),
            ),
            //set the owner_id field equal to the passed in owner_id. 
            owner_id,
            metadata: LazyOption::new(
                StorageKey::NFTContractMetadata.try_to_vec().unwrap(),
                Some(&metadata),
            ),
        };

        //return the Contract object
        this
    }
}

#[cfg(test)]
mod tests;
'''
'''--- nft-tutorial/nft-contract/src/metadata.rs ---
use crate::*;
pub type TokenId = String;
//defines the payout type we'll be returning as a part of the royalty standards.
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Payout {
    pub payout: HashMap<AccountId, U128>,
} 

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct NFTContractMetadata {
    pub spec: String,              // required, essentially a version like "nft-1.0.0"
    pub name: String,              // required, ex. "Mosaics"
    pub symbol: String,            // required, ex. "MOSAIC"
    pub icon: Option<String>,      // Data URL
    pub base_uri: Option<String>, // Centralized gateway known to have reliable access to decentralized storage assets referenced by `reference` or `media` URLs
    pub reference: Option<String>, // URL to a JSON file with more info
    pub reference_hash: Option<Base64VecU8>, // Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included.
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct TokenMetadata {
    pub title: Option<String>, // ex. "Arch Nemesis: Mail Carrier" or "Parcel #5055"
    pub description: Option<String>, // free-form description
    pub media: Option<String>, // URL to associated media, preferably to decentralized, content-addressed storage
    pub media_hash: Option<Base64VecU8>, // Base64-encoded sha256 hash of content referenced by the `media` field. Required if `media` is included.
    pub copies: Option<u64>, // number of copies of this set of metadata in existence when token was minted.
    pub issued_at: Option<u64>, // When token was issued or minted, Unix epoch in milliseconds
    pub expires_at: Option<u64>, // When token expires, Unix epoch in milliseconds
    pub starts_at: Option<u64>, // When token starts being valid, Unix epoch in milliseconds
    pub updated_at: Option<u64>, // When token was last updated, Unix epoch in milliseconds
    pub extra: Option<String>, // anything extra the NFT wants to store on-chain. Can be stringified JSON.
    pub reference: Option<String>, // URL to an off-chain JSON file with more info.
    pub reference_hash: Option<Base64VecU8>, // Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included.
}

#[derive(BorshDeserialize, BorshSerialize)]
pub struct Token {
    //owner of the token
    pub owner_id: AccountId,
    //list of approved account IDs that have access to transfer the token. This maps an account ID to an approval ID
    pub approved_account_ids: HashMap<AccountId, u64>,
    //the next approval ID to give out. 
    pub next_approval_id: u64,
    //keep track of the royalty percentages for the token in a hash map
    pub royalty: HashMap<AccountId, u32>,
}

//The Json token is what will be returned from view calls. 
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct JsonToken {
    //token ID
    pub token_id: TokenId,
    //owner of the token
    pub owner_id: AccountId,
    //token metadata
    pub metadata: TokenMetadata,
    //list of approved account IDs that have access to transfer the token. This maps an account ID to an approval ID
    pub approved_account_ids: HashMap<AccountId, u64>,
    //keep track of the royalty percentages for the token in a hash map
    pub royalty: HashMap<AccountId, u32>,
}

pub trait NonFungibleTokenMetadata {
    //view call for returning the contract metadata
    fn nft_metadata(&self) -> NFTContractMetadata;
}

#[near_bindgen]
impl NonFungibleTokenMetadata for Contract {
    fn nft_metadata(&self) -> NFTContractMetadata {
        self.metadata.get().unwrap()
    }
}
'''
'''--- nft-tutorial/nft-contract/src/mint.rs ---
use crate::*;

#[near_bindgen]
impl Contract {
    #[payable]
    pub fn nft_mint(
        &mut self,
        token_id: TokenId,
        metadata: TokenMetadata,
        receiver_id: AccountId,
        //we add an optional parameter for perpetual royalties
        perpetual_royalties: Option<HashMap<AccountId, u32>>,
    ) {
        //measure the initial storage being used on the contract
        let initial_storage_usage = env::storage_usage();

        // create a royalty map to store in the token
        let mut royalty = HashMap::new();

        // if perpetual royalties were passed into the function: 
        if let Some(perpetual_royalties) = perpetual_royalties {
            //make sure that the length of the perpetual royalties is below 7 since we won't have enough GAS to pay out that many people
            assert!(perpetual_royalties.len() < 7, "Cannot add more than 6 perpetual royalty amounts");

            //iterate through the perpetual royalties and insert the account and amount in the royalty map
            for (account, amount) in perpetual_royalties {
                royalty.insert(account, amount);
            }
        }

        //specify the token struct that contains the owner ID 
        let token = Token {
            //set the owner ID equal to the receiver ID passed into the function
            owner_id: receiver_id,
            //we set the approved account IDs to the default value (an empty map)
            approved_account_ids: Default::default(),
            //the next approval ID is set to 0
            next_approval_id: 0,
            //the map of perpetual royalties for the token (The owner will get 100% - total perpetual royalties)
            royalty,
        };

        //insert the token ID and token struct and make sure that the token doesn't exist
        assert!(
            self.tokens_by_id.insert(&token_id, &token).is_none(),
            "Token already exists"
        );

        //insert the token ID and metadata
        self.token_metadata_by_id.insert(&token_id, &metadata);

        //call the internal method for adding the token to the owner
        self.internal_add_token_to_owner(&token.owner_id, &token_id);

        // Construct the mint log as per the events standard.
        let nft_mint_log: EventLog = EventLog {
            // Standard name ("nep171").
            standard: NFT_STANDARD_NAME.to_string(),
            // Version of the standard ("nft-1.0.0").
            version: NFT_METADATA_SPEC.to_string(),
            // The data related with the event stored in a vector.
            event: EventLogVariant::NftMint(vec![NftMintLog {
                // Owner of the token.
                owner_id: token.owner_id.to_string(),
                // Vector of token IDs that were minted.
                token_ids: vec![token_id.to_string()],
                // An optional memo to include.
                memo: None,
            }]),
        };

        // Log the serialized json.
        env::log_str(&nft_mint_log.to_string());

        //calculate the required storage which was the used - initial
        let required_storage_in_bytes = env::storage_usage() - initial_storage_usage;

        //refund any excess storage if the user attached too much. Panic if they didn't attach enough to cover the required.
        refund_deposit(required_storage_in_bytes);
    }
}
'''
'''--- nft-tutorial/nft-contract/src/nft_core.rs ---
use crate::*;
use near_sdk::{ext_contract, Gas, PromiseResult};

const GAS_FOR_RESOLVE_TRANSFER: Gas = Gas(10_000_000_000_000);
const GAS_FOR_NFT_ON_TRANSFER: Gas = Gas(25_000_000_000_000);

pub trait NonFungibleTokenCore {
    //transfers an NFT to a receiver ID
    fn nft_transfer(
        &mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        //we introduce an approval ID so that people with that approval ID can transfer the token
        approval_id: Option<u64>,
        memo: Option<String>,
    );

/// Transfers an NFT to a receiver and calls the
///  function `nft_on_transfer` on their contract.
    fn nft_transfer_call(
        &mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        //we introduce an approval ID so that people with that approval ID can transfer the token
        approval_id: Option<u64>,
        memo: Option<String>,
        msg: String,
    ) -> PromiseOrValue<bool>;

    //get information about the NFT token passed in
    fn nft_token(&self, token_id: TokenId) -> Option<JsonToken>;
}

#[ext_contract(ext_non_fungible_token_receiver)]
trait NonFungibleTokenReceiver {
    //Method stored on the receiver contract that is called via cross contract call when nft_transfer_call is called
    /// Returns `true` if the token should be returned back to the sender.
    fn nft_on_transfer(
        &mut self,
        sender_id: AccountId,
        previous_owner_id: AccountId,
        token_id: TokenId,
        msg: String,
    ) -> Promise;
}

#[ext_contract(ext_self)]
/*
    resolves the promise of the cross contract call to the receiver contract
    this is stored on THIS contract and is meant to analyze what happened in the cross contract call when nft_on_transfer was called
    as part of the nft_transfer_call method
*/ 
trait NonFungibleTokenResolver {
    fn nft_resolve_transfer(
        &mut self,
        //we introduce an authorized ID for logging the transfer event
        authorized_id: Option<String>,
        owner_id: AccountId,
        receiver_id: AccountId,
        token_id: TokenId,
        //we introduce the approval map so we can keep track of what the approvals were before the transfer
        approved_account_ids: HashMap<AccountId, u64>,
        //we introduce a memo for logging the transfer event
        memo: Option<String>,
    ) -> bool;
}

#[near_bindgen]
impl NonFungibleTokenCore for Contract {

    //implementation of the nft_transfer method. This transfers the NFT from the current owner to the receiver. 
    #[payable]
    fn nft_transfer(
        &mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        //we introduce an approval ID so that people with that approval ID can transfer the token
        approval_id: Option<u64>,
        memo: Option<String>,
    ) {
        //assert that the user attached exactly 1 yoctoNEAR. This is for security and so that the user will be redirected to the NEAR wallet. 
        assert_one_yocto();
        //get the sender to transfer the token from the sender to the receiver
        let sender_id = env::predecessor_account_id();

        //call the internal transfer method and get back the previous token so we can refund the approved account IDs
        let previous_token = self.internal_transfer(
            &sender_id,
            &receiver_id,
            &token_id,
            approval_id,
            memo,
        );

        //we refund the owner for releasing the storage used up by the approved account IDs
        refund_approved_account_ids(
            previous_token.owner_id.clone(),
            &previous_token.approved_account_ids,
        );
    }

    //implementation of the transfer call method. This will transfer the NFT and call a method on the receiver_id contract
    #[payable]
    fn nft_transfer_call(
        &mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        //we introduce an approval ID so that people with that approval ID can transfer the token
        approval_id: Option<u64>,
        memo: Option<String>,
        msg: String,
    ) -> PromiseOrValue<bool> {
        //assert that the user attached exactly 1 yocto for security reasons. 
        assert_one_yocto();

        //get the sender ID 
        let sender_id = env::predecessor_account_id();

        //transfer the token and get the previous token object
        let previous_token = self.internal_transfer(
            &sender_id,
            &receiver_id,
            &token_id,
            approval_id,
            memo.clone(),
        );

        //default the authorized_id to none
        let mut authorized_id = None; 
        //if the sender isn't the owner of the token, we set the authorized ID equal to the sender.
        if sender_id != previous_token.owner_id {
            authorized_id = Some(sender_id.to_string());
        }

        // Initiating receiver's call and the callback
        // Defaulting GAS weight to 1, no attached deposit, and static GAS equal to the GAS for nft on transfer.
        ext_non_fungible_token_receiver::ext(receiver_id.clone())
            .with_static_gas(GAS_FOR_NFT_ON_TRANSFER)
            .nft_on_transfer(
                sender_id, 
                previous_token.owner_id.clone(), 
                token_id.clone(), 
                msg
            )
        // We then resolve the promise and call nft_resolve_transfer on our own contract
        .then(
            // Defaulting GAS weight to 1, no attached deposit, and static GAS equal to the GAS for resolve transfer
            Self::ext(env::current_account_id())
                .with_static_gas(GAS_FOR_RESOLVE_TRANSFER)
                .nft_resolve_transfer(
                    authorized_id, // we introduce an authorized ID so that we can log the transfer
                    previous_token.owner_id,
                    receiver_id,
                    token_id,
                    previous_token.approved_account_ids,
                    memo, // we introduce a memo for logging in the events standard
                )
        ).into()
    }

    //get the information for a specific token ID
    fn nft_token(&self, token_id: TokenId) -> Option<JsonToken> {
        //if there is some token ID in the tokens_by_id collection
        if let Some(token) = self.tokens_by_id.get(&token_id) {
            //we'll get the metadata for that token
            let metadata = self.token_metadata_by_id.get(&token_id).unwrap();
            //we return the JsonToken (wrapped by Some since we return an option)
            Some(JsonToken {
                token_id,
                owner_id: token.owner_id,
                metadata,
                approved_account_ids: token.approved_account_ids,
                royalty: token.royalty,
            })
        } else { //if there wasn't a token ID in the tokens_by_id collection, we return None
            None
        }
    }
}

#[near_bindgen]
impl NonFungibleTokenResolver for Contract {
    //resolves the cross contract call when calling nft_on_transfer in the nft_transfer_call method
    //returns true if the token was successfully transferred to the receiver_id
    #[private]
    fn nft_resolve_transfer(
        &mut self,
        //we introduce an authorized ID for logging the transfer event
        authorized_id: Option<String>,
        owner_id: AccountId,
        receiver_id: AccountId,
        token_id: TokenId,
        //we introduce the approval map so we can keep track of what the approvals were before the transfer
        approved_account_ids: HashMap<AccountId, u64>,
        //we introduce a memo for logging the transfer event
        memo: Option<String>,
    ) -> bool {
        // Whether receiver wants to return token back to the sender, based on `nft_on_transfer`
        // call result.
        if let PromiseResult::Successful(value) = env::promise_result(0) {
            //As per the standard, the nft_on_transfer should return whether we should return the token to it's owner or not
            if let Ok(return_token) = near_sdk::serde_json::from_slice::<bool>(&value) {
                //if we need don't need to return the token, we simply return true meaning everything went fine
                if !return_token {
                    /* 
                        since we've already transferred the token and nft_on_transfer returned false, we don't have to 
                        revert the original transfer and thus we can just return true since nothing went wrong.
                    */
                    //we refund the owner for releasing the storage used up by the approved account IDs
                    refund_approved_account_ids(owner_id, &approved_account_ids);
                    return true;
                }
            }
        }

        //get the token object if there is some token object
        let mut token = if let Some(token) = self.tokens_by_id.get(&token_id) {
            if token.owner_id != receiver_id {
                //we refund the owner for releasing the storage used up by the approved account IDs
                refund_approved_account_ids(owner_id, &approved_account_ids);
                // The token is not owner by the receiver anymore. Can't return it.
                return true;
            }
            token
        //if there isn't a token object, it was burned and so we return true
        } else {
            //we refund the owner for releasing the storage used up by the approved account IDs
            refund_approved_account_ids(owner_id, &approved_account_ids);
            return true;
        };

        //we remove the token from the receiver
        self.internal_remove_token_from_owner(&receiver_id.clone(), &token_id);
        //we add the token to the original owner
        self.internal_add_token_to_owner(&owner_id, &token_id);

        //we change the token struct's owner to be the original owner 
        token.owner_id = owner_id.clone();

        //we refund the receiver any approved account IDs that they may have set on the token
        refund_approved_account_ids(receiver_id.clone(), &token.approved_account_ids);
        //reset the approved account IDs to what they were before the transfer
        token.approved_account_ids = approved_account_ids;

        //we inset the token back into the tokens_by_id collection
        self.tokens_by_id.insert(&token_id, &token);

        /*
            We need to log that the NFT was reverted back to the original owner.
            The old_owner_id will be the receiver and the new_owner_id will be the
            original owner of the token since we're reverting the transfer.
        */
        let nft_transfer_log: EventLog = EventLog {
            // Standard name ("nep171").
            standard: NFT_STANDARD_NAME.to_string(),
            // Version of the standard ("nft-1.0.0").
            version: NFT_METADATA_SPEC.to_string(),
            // The data related with the event stored in a vector.
            event: EventLogVariant::NftTransfer(vec![NftTransferLog {
                // The optional authorized account ID to transfer the token on behalf of the old owner.
                authorized_id,
                // The old owner's account ID.
                old_owner_id: receiver_id.to_string(),
                // The account ID of the new owner of the token.
                new_owner_id: owner_id.to_string(),
                // A vector containing the token IDs as strings.
                token_ids: vec![token_id.to_string()],
                // An optional memo to include.
                memo,
            }]),
        };

        //we perform the actual logging
        env::log_str(&nft_transfer_log.to_string());

        //return false
        false
    }
}

'''
'''--- nft-tutorial/nft-contract/src/royalty.rs ---
use crate::*;

pub trait NonFungibleTokenCore {
    //calculates the payout for a token given the passed in balance. This is a view method
    fn nft_payout(&self, token_id: TokenId, balance: U128, max_len_payout: u32) -> Payout;
    
    //transfers the token to the receiver ID and returns the payout object that should be payed given the passed in balance. 
    fn nft_transfer_payout(
        &mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        approval_id: u64,
        memo: Option<String>,
        balance: U128,
        max_len_payout: u32,
    ) -> Payout;
}

#[near_bindgen]
impl NonFungibleTokenCore for Contract {

    //calculates the payout for a token given the passed in balance. This is a view method
    fn nft_payout(&self, token_id: TokenId, balance: U128, max_len_payout: u32) -> Payout {
        //get the token object
		let token = self.tokens_by_id.get(&token_id).expect("No token");

        //get the owner of the token
        let owner_id = token.owner_id;
        //keep track of the total perpetual royalties
        let mut total_perpetual = 0;
        //get the u128 version of the passed in balance (which was U128 before)
        let balance_u128 = u128::from(balance);
		//keep track of the payout object to send back
        let mut payout_object = Payout {
            payout: HashMap::new()
        };
        //get the royalty object from token
		let royalty = token.royalty;

        //make sure we're not paying out to too many people (GAS limits this)
		assert!(royalty.len() as u32 <= max_len_payout, "Market cannot payout to that many receivers");

        //go through each key and value in the royalty object
		for (k, v) in royalty.iter() {
            //get the key
			let key = k.clone();
            //only insert into the payout if the key isn't the token owner (we add their payout at the end)
			if key != owner_id {
                //
				payout_object.payout.insert(key, royalty_to_payout(*v, balance_u128));
				total_perpetual += *v;
			}
		}

		// payout to previous owner who gets 100% - total perpetual royalties
		payout_object.payout.insert(owner_id, royalty_to_payout(10000 - total_perpetual, balance_u128));

        //return the payout object
		payout_object
	}

    //transfers the token to the receiver ID and returns the payout object that should be payed given the passed in balance. 
    #[payable]
    fn nft_transfer_payout(
        &mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        approval_id: u64,
        memo: Option<String>,
        balance: U128,
        max_len_payout: u32,
    ) -> Payout { 
        //assert that the user attached 1 yocto NEAR for security reasons
        assert_one_yocto();
        //get the sender ID
        let sender_id = env::predecessor_account_id();
        //transfer the token to the passed in receiver and get the previous token object back
        let previous_token = self.internal_transfer(
            &sender_id,
            &receiver_id,
            &token_id,
            Some(approval_id),
            memo,
        );

        //refund the previous token owner for the storage used up by the previous approved account IDs
        refund_approved_account_ids(
            previous_token.owner_id.clone(),
            &previous_token.approved_account_ids,
        );

        //get the owner of the token
        let owner_id = previous_token.owner_id;
        //keep track of the total perpetual royalties
        let mut total_perpetual = 0;
        //get the u128 version of the passed in balance (which was U128 before)
        let balance_u128 = u128::from(balance);
		//keep track of the payout object to send back
        let mut payout_object = Payout {
            payout: HashMap::new()
        };
        //get the royalty object from token
		let royalty = previous_token.royalty;

        //make sure we're not paying out to too many people (GAS limits this)
		assert!(royalty.len() as u32 <= max_len_payout, "Market cannot payout to that many receivers");

        //go through each key and value in the royalty object
		for (k, v) in royalty.iter() {
            //get the key
			let key = k.clone();
            //only insert into the payout if the key isn't the token owner (we add their payout at the end)
			if key != owner_id {
                //
				payout_object.payout.insert(key, royalty_to_payout(*v, balance_u128));
				total_perpetual += *v;
			}
		}

		// payout to previous owner who gets 100% - total perpetual royalties
		payout_object.payout.insert(owner_id, royalty_to_payout(10000 - total_perpetual, balance_u128));

        //return the payout object
		payout_object
    }
}
'''
'''--- nft-tutorial/nft-contract/src/tests.rs ---
/* unit tests */
#[cfg(test)]
use crate::Contract;
use crate::TokenMetadata;
use crate::approval::NonFungibleTokenCore;
use near_sdk::json_types::{U128, U64};
use near_sdk::test_utils::{accounts, VMContextBuilder};
use near_sdk::testing_env;
use near_sdk::{env, AccountId};

use std::collections::HashMap;

const MINT_STORAGE_COST: u128 = 100_000_000_000_000_000_000_000;
const MIN_REQUIRED_APPROVAL_YOCTO: u128 = 170000000000000000000;

fn get_context(predecessor: AccountId) -> VMContextBuilder {
    let mut builder = VMContextBuilder::new();
    builder.predecessor_account_id(predecessor);
    builder
}

fn sample_token_metadata() -> TokenMetadata {
    TokenMetadata {
        title: Some("Olympus Mons".into()),
        description: Some("The tallest mountain in the charted solar system".into()),
        media: None,
        media_hash: None,
        copies: Some(1u64),
        issued_at: None,
        expires_at: None,
        starts_at: None,
        updated_at: None,
        extra: None,
        reference: None,
        reference_hash: None,
    }
}

#[test]
#[should_panic(expected = "The contract is not initialized")]
fn test_default() {
    let context = get_context(accounts(1));
    testing_env!(context.build());
    let _contract = Contract::default();
}

#[test]
fn test_new_account_contract() {
    let mut context = get_context(accounts(1));
    testing_env!(context.build());
    let contract = Contract::new_default_meta(accounts(1).into());
    testing_env!(context.is_view(true).build());
    let contract_nft_tokens = contract.nft_tokens(Some(U128(0)), None);
    assert_eq!(contract_nft_tokens.len(), 0);
}

#[test]
fn test_mint_nft() {
    let mut context = get_context(accounts(0));
    testing_env!(context.build());
    let mut contract = Contract::new_default_meta(accounts(0).into());
    testing_env!(context
        .storage_usage(env::storage_usage())
        .attached_deposit(MINT_STORAGE_COST)
        .predecessor_account_id(accounts(0))
        .build());
    let token_metadata: TokenMetadata = sample_token_metadata();
    let token_id = "0".to_string();
    contract.nft_mint(token_id.clone(), token_metadata, accounts(0), None);
    let contract_nft_tokens = contract.nft_tokens(Some(U128(0)), None);
    assert_eq!(contract_nft_tokens.len(), 1);

    assert_eq!(contract_nft_tokens[0].token_id, token_id);
    assert_eq!(contract_nft_tokens[0].owner_id, accounts(0));
    assert_eq!(
        contract_nft_tokens[0].metadata.title,
        sample_token_metadata().title
    );
    assert_eq!(
        contract_nft_tokens[0].metadata.description,
        sample_token_metadata().description
    );
    assert_eq!(
        contract_nft_tokens[0].metadata.media,
        sample_token_metadata().media
    );
    assert_eq!(contract_nft_tokens[0].approved_account_ids, HashMap::new());
}

#[test]
fn test_internal_transfer() {
    let mut context = get_context(accounts(0));
    testing_env!(context.build());
    let mut contract = Contract::new_default_meta(accounts(0).into());

    testing_env!(context
        .storage_usage(env::storage_usage())
        .attached_deposit(MINT_STORAGE_COST)
        .predecessor_account_id(accounts(0))
        .build());
    let token_id = "0".to_string();
    contract.nft_mint(token_id.clone(), sample_token_metadata(), accounts(0), None);

    testing_env!(context
        .storage_usage(env::storage_usage())
        .attached_deposit(1)
        .predecessor_account_id(accounts(0))
        .build());
    contract.internal_transfer(
        &accounts(0),
        &accounts(1),
        &token_id.clone(),
        Some(U64(1).0),
        None,
    );

    testing_env!(context
        .storage_usage(env::storage_usage())
        .account_balance(env::account_balance())
        .is_view(true)
        .attached_deposit(0)
        .build());

    let tokens = contract.nft_tokens_for_owner(accounts(1), Some(U128(0)), None);
    assert_ne!(
        tokens.len(),
        0,
        "Token not correctly created and/or sent to second account"
    );
    let token = &tokens[0];
    assert_eq!(token.token_id, token_id);
    assert_eq!(token.owner_id, accounts(1));
    assert_eq!(token.metadata.title, sample_token_metadata().title);
    assert_eq!(
        token.metadata.description,
        sample_token_metadata().description
    );
    assert_eq!(token.metadata.media, sample_token_metadata().media);
    assert_eq!(token.approved_account_ids, HashMap::new());
}

#[test]
fn test_nft_approve() {
    let mut context = get_context(accounts(0));
    testing_env!(context.build());
    let mut contract = Contract::new_default_meta(accounts(0).into());

    testing_env!(context
        .storage_usage(env::storage_usage())
        .attached_deposit(MINT_STORAGE_COST)
        .predecessor_account_id(accounts(0))
        .build());
    let token_id = "0".to_string();
    contract.nft_mint(token_id.clone(), sample_token_metadata(), accounts(0), None);

    testing_env!(context
        .storage_usage(env::storage_usage())
        .attached_deposit(MIN_REQUIRED_APPROVAL_YOCTO)
        .predecessor_account_id(accounts(0))
        .build());
    contract.nft_approve(token_id.clone(), accounts(1), None);

    testing_env!(context
        .storage_usage(env::storage_usage())
        .account_balance(env::account_balance())
        .is_view(true)
        .attached_deposit(0)
        .build());
    assert!(contract.nft_is_approved(token_id.clone(), accounts(1), None));
}

#[test]
fn test_nft_revoke() {
    let mut context = get_context(accounts(0));
    testing_env!(context.build());
    let mut contract = Contract::new_default_meta(accounts(0).into());

    testing_env!(context
        .storage_usage(env::storage_usage())
        .attached_deposit(MINT_STORAGE_COST)
        .predecessor_account_id(accounts(0))
        .build());
    let token_id = "0".to_string();
    contract.nft_mint(token_id.clone(), sample_token_metadata(), accounts(0), None);

    // alice approves bob
    testing_env!(context
        .storage_usage(env::storage_usage())
        .attached_deposit(MIN_REQUIRED_APPROVAL_YOCTO)
        .predecessor_account_id(accounts(0))
        .build());
    contract.nft_approve(token_id.clone(), accounts(1), None);

    // alice revokes bob
    testing_env!(context
        .storage_usage(env::storage_usage())
        .attached_deposit(1)
        .predecessor_account_id(accounts(0))
        .build());
    contract.nft_revoke(token_id.clone(), accounts(1));
    testing_env!(context
        .storage_usage(env::storage_usage())
        .account_balance(env::account_balance())
        .is_view(true)
        .attached_deposit(0)
        .build());
    assert!(!contract.nft_is_approved(token_id.clone(), accounts(1), None));
}

#[test]
fn test_revoke_all() {
    let mut context = get_context(accounts(0));
    testing_env!(context.build());
    let mut contract = Contract::new_default_meta(accounts(0).into());

    testing_env!(context
        .storage_usage(env::storage_usage())
        .attached_deposit(MINT_STORAGE_COST)
        .predecessor_account_id(accounts(0))
        .build());
    let token_id = "0".to_string();
    contract.nft_mint(token_id.clone(), sample_token_metadata(), accounts(0), None);

    // alice approves bob
    testing_env!(context
        .storage_usage(env::storage_usage())
        .attached_deposit(MIN_REQUIRED_APPROVAL_YOCTO)
        .predecessor_account_id(accounts(0))
        .build());
    contract.nft_approve(token_id.clone(), accounts(1), None);

    // alice revokes bob
    testing_env!(context
        .storage_usage(env::storage_usage())
        .attached_deposit(1)
        .predecessor_account_id(accounts(0))
        .build());
    contract.nft_revoke_all(token_id.clone());
    testing_env!(context
        .storage_usage(env::storage_usage())
        .account_balance(env::account_balance())
        .is_view(true)
        .attached_deposit(0)
        .build());
    assert!(!contract.nft_is_approved(token_id.clone(), accounts(1), Some(1)));
}

#[test]
fn test_internal_remove_token_from_owner() {
    let mut context = get_context(accounts(0));
    testing_env!(context.build());
    let mut contract = Contract::new_default_meta(accounts(0).into());

    testing_env!(context
        .storage_usage(env::storage_usage())
        .attached_deposit(MINT_STORAGE_COST)
        .predecessor_account_id(accounts(0))
        .build());
    let token_id = "0".to_string();
    contract.nft_mint(token_id.clone(), sample_token_metadata(), accounts(0), None);

    let contract_nft_tokens_before = contract.nft_tokens_for_owner(accounts(0), None, None);
    assert_eq!(contract_nft_tokens_before.len(), 1);

    contract.internal_remove_token_from_owner(&accounts(0), &token_id);
    let contract_nft_tokens_after = contract.nft_tokens_for_owner(accounts(0), None, None);
    assert_eq!(contract_nft_tokens_after.len(), 0);
}

#[test]
fn test_nft_payout() {
    use crate::royalty::NonFungibleTokenCore;
    let mut context = get_context(accounts(0));
    testing_env!(context.build());
    let mut contract = Contract::new_default_meta(accounts(0).into());

    testing_env!(context
        .storage_usage(env::storage_usage())
        .attached_deposit(MINT_STORAGE_COST)
        .predecessor_account_id(accounts(0))
        .build());
    let token_id = "0".to_string();
    contract.nft_mint(token_id.clone(), sample_token_metadata(), accounts(0), None);

    // alice approves bob
    testing_env!(context
        .storage_usage(env::storage_usage())
        .attached_deposit(MIN_REQUIRED_APPROVAL_YOCTO)
        .predecessor_account_id(accounts(0))
        .build());
    contract.nft_approve(token_id.clone(), accounts(1), None);

    let payout = contract.nft_payout(token_id.clone(), U128(10), 1);
    let expected = HashMap::from([(accounts(0), U128(10))]);
    assert_eq!(payout.payout, expected);
}

#[test]
fn test_nft_total_supply() {
    let mut context = get_context(accounts(0));
    testing_env!(context.build());
    let mut contract = Contract::new_default_meta(accounts(0).into());

    testing_env!(context
        .storage_usage(env::storage_usage())
        .attached_deposit(MINT_STORAGE_COST)
        .predecessor_account_id(accounts(0))
        .build());
    let token_id = "0".to_string();
    contract.nft_mint(token_id.clone(), sample_token_metadata(), accounts(0), None);

    let total_supply = contract.nft_total_supply();
    assert_eq!(total_supply, U128(1));
}
'''
'''--- nft-tutorial/nft-series/Cargo.toml ---
[package]
name = "nft_simple"
version = "0.1.0"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0"
serde_json = "1.0"

[profile.release]
codegen-units=1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- nft-tutorial/nft-series/README.md ---
# TBD

'''
'''--- nft-tutorial/nft-series/build.sh ---
#!/bin/bash
set -e && RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release && mkdir -p ../out && cp target/wasm32-unknown-unknown/release/*.wasm ../out/series.wasm
'''
'''--- nft-tutorial/nft-series/src/approval.rs ---
use crate::*;
use near_sdk::ext_contract;

pub trait NonFungibleTokenCore {
    //approve an account ID to transfer a token on your behalf
    fn nft_approve(&mut self, token_id: TokenId, account_id: AccountId, msg: Option<String>);

    //check if the passed in account has access to approve the token ID
    fn nft_is_approved(
        &self,
        token_id: TokenId,
        approved_account_id: AccountId,
        approval_id: Option<u64>,
    ) -> bool;

    //revoke a specific account from transferring the token on your behalf
    fn nft_revoke(&mut self, token_id: TokenId, account_id: AccountId);

    //revoke all accounts from transferring the token on your behalf
    fn nft_revoke_all(&mut self, token_id: TokenId);
}

#[ext_contract(ext_non_fungible_approval_receiver)]
trait NonFungibleTokenApprovalsReceiver {
    //cross contract call to an external contract that is initiated during nft_approve
    fn nft_on_approve(
        &mut self,
        token_id: TokenId,
        owner_id: AccountId,
        approval_id: u64,
        msg: String,
    );
}

#[near_bindgen]
impl NonFungibleTokenCore for Contract {
    //allow a specific account ID to approve a token on your behalf
    #[payable]
    fn nft_approve(&mut self, token_id: TokenId, account_id: AccountId, msg: Option<String>) {
        /*
            assert at least one yocto for security reasons - this will cause a redirect to the NEAR wallet.
            The user needs to attach enough to pay for storage on the contract
        */
        assert_at_least_one_yocto();

        //get the token object from the token ID
        let mut token = self.tokens_by_id.get(&token_id).expect("No token");

        //make sure that the person calling the function is the owner of the token
        assert_eq!(
            &env::predecessor_account_id(),
            &token.owner_id,
            "Predecessor must be the token owner."
        );

        //get the next approval ID if we need a new approval
        let approval_id: u64 = token.next_approval_id;

        //check if the account has been approved already for this token
        let is_new_approval = token
            .approved_account_ids
            //insert returns none if the key was not present.
            .insert(account_id.clone(), approval_id)
            //if the key was not present, .is_none() will return true so it is a new approval.
            .is_none();

        //if it was a new approval, we need to calculate how much storage is being used to add the account.
        let storage_used = if is_new_approval {
            bytes_for_approved_account_id(&account_id)
        //if it was not a new approval, we used no storage.
        } else {
            0
        };

        //increment the token's next approval ID by 1
        token.next_approval_id += 1;
        //insert the token back into the tokens_by_id collection
        self.tokens_by_id.insert(&token_id, &token);

        //refund any excess storage attached by the user. If the user didn't attach enough, panic.
        refund_deposit(storage_used);

        //if some message was passed into the function, we initiate a cross contract call on the
        //account we're giving access to.
        if let Some(msg) = msg {
            // Defaulting GAS weight to 1, no attached deposit, and no static GAS to attach.
            ext_non_fungible_approval_receiver::ext(account_id)
                .nft_on_approve(token_id, token.owner_id, approval_id, msg)
                .as_return();
        }
    }

    //check if the passed in account has access to approve the token ID
    fn nft_is_approved(
        &self,
        token_id: TokenId,
        approved_account_id: AccountId,
        approval_id: Option<u64>,
    ) -> bool {
        //get the token object from the token_id
        let token = self.tokens_by_id.get(&token_id).expect("No token");

        //get the approval number for the passed in account ID
        let approval = token.approved_account_ids.get(&approved_account_id);

        //if there was some approval ID found for the account ID
        if let Some(approval) = approval {
            //if a specific approval_id was passed into the function
            if let Some(approval_id) = approval_id {
                //return if the approval ID passed in matches the actual approval ID for the account
                approval_id == *approval
                //if there was no approval_id passed into the function, we simply return true
            } else {
                true
            }
            //if there was no approval ID found for the account ID, we simply return false
        } else {
            false
        }
    }

    //revoke a specific account from transferring the token on your behalf
    #[payable]
    fn nft_revoke(&mut self, token_id: TokenId, account_id: AccountId) {
        //assert that the user attached exactly 1 yoctoNEAR for security reasons
        assert_one_yocto();
        //get the token object using the passed in token_id
        let mut token = self.tokens_by_id.get(&token_id).expect("No token");

        //get the caller of the function and assert that they are the owner of the token
        let predecessor_account_id = env::predecessor_account_id();
        assert_eq!(&predecessor_account_id, &token.owner_id);

        //if the account ID was in the token's approval, we remove it and the if statement logic executes
        if token.approved_account_ids.remove(&account_id).is_some() {
            //refund the funds released by removing the approved_account_id to the caller of the function
            refund_approved_account_ids_iter(predecessor_account_id, [account_id].iter());

            //insert the token back into the tokens_by_id collection with the account_id removed from the approval list
            self.tokens_by_id.insert(&token_id, &token);
        }
    }

    //revoke all accounts from transferring the token on your behalf
    #[payable]
    fn nft_revoke_all(&mut self, token_id: TokenId) {
        //assert that the caller attached exactly 1 yoctoNEAR for security
        assert_one_yocto();

        //get the token object from the passed in token ID
        let mut token = self.tokens_by_id.get(&token_id).expect("No token");
        //get the caller and make sure they are the owner of the tokens
        let predecessor_account_id = env::predecessor_account_id();
        assert_eq!(&predecessor_account_id, &token.owner_id);

        //only revoke if the approved account IDs for the token is not empty
        if !token.approved_account_ids.is_empty() {
            //refund the approved account IDs to the caller of the function
            refund_approved_account_ids(predecessor_account_id, &token.approved_account_ids);
            //clear the approved account IDs
            token.approved_account_ids.clear();
            //insert the token back into the tokens_by_id collection with the approved account IDs cleared
            self.tokens_by_id.insert(&token_id, &token);
        }
    }
}

'''
'''--- nft-tutorial/nft-series/src/enumeration.rs ---
use crate::*;
use crate::nft_core::NonFungibleTokenCore;

/// Struct to return in views to query for specific data related to a series
#[derive(BorshDeserialize, BorshSerialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct JsonSeries {
    series_id: u64,
    // Metadata including title, num copies etc.. that all tokens will derive from
    metadata: TokenMetadata,
    // Royalty used for all tokens in the collection
    royalty: Option<HashMap<AccountId, u32>>,
    // Owner of the collection
    owner_id: AccountId,
}

#[near_bindgen]
impl Contract {
    //Query for the total supply of NFTs on the contract
    pub fn nft_total_supply(&self) -> U128 {
        //return the length of the tokens by id
        U128(self.tokens_by_id.len() as u128)
    }

    //Query for nft tokens on the contract regardless of the owner using pagination
    pub fn nft_tokens(&self, from_index: Option<U128>, limit: Option<u64>) -> Vec<JsonToken> {
        //where to start pagination - if we have a from_index, we'll use that - otherwise start from 0 index
        let start = u128::from(from_index.unwrap_or(U128(0)));

        //iterate through each token using an iterator
        self.tokens_by_id
            .keys()
            //skip to the index we specified in the start variable
            .skip(start as usize)
            //take the first "limit" elements in the vector. If we didn't specify a limit, use 50
            .take(limit.unwrap_or(50) as usize)
            //we'll map the token IDs which are strings into Json Tokens
            .map(|token_id| self.nft_token(token_id.clone()).unwrap())
            //since we turned the keys into an iterator, we need to turn it back into a vector to return
            .collect()
    }

    //get the total supply of NFTs for a given owner
    pub fn nft_supply_for_owner(&self, account_id: AccountId) -> U128 {
        //get the set of tokens for the passed in owner
        let tokens_for_owner_set = self.tokens_per_owner.get(&account_id);

        //if there is some set of tokens, we'll return the length as a U128
        if let Some(tokens_for_owner_set) = tokens_for_owner_set {
            U128(tokens_for_owner_set.len() as u128)
        } else {
            //if there isn't a set of tokens for the passed in account ID, we'll return 0
            U128(0)
        }
    }

    //Query for all the tokens for an owner
    pub fn nft_tokens_for_owner(
        &self,
        account_id: AccountId,
        from_index: Option<U128>,
        limit: Option<u64>,
    ) -> Vec<JsonToken> {
        //get the set of tokens for the passed in owner
        let tokens_for_owner_set = self.tokens_per_owner.get(&account_id);
        //if there is some set of tokens, we'll set the tokens variable equal to that set
        let tokens = if let Some(tokens_for_owner_set) = tokens_for_owner_set {
            tokens_for_owner_set
        } else {
            //if there is no set of tokens, we'll simply return an empty vector.
            return vec![];
        };

        //where to start pagination - if we have a from_index, we'll use that - otherwise start from 0 index
        let start = u128::from(from_index.unwrap_or(U128(0)));

        //iterate through the keys vector
        tokens
            .iter()
            //skip to the index we specified in the start variable
            .skip(start as usize)
            //take the first "limit" elements in the vector. If we didn't specify a limit, use 50
            .take(limit.unwrap_or(50) as usize)
            //we'll map the token IDs which are strings into Json Tokens
            .map(|token_id| self.nft_token(token_id.clone()).unwrap())
            //since we turned the keys into an iterator, we need to turn it back into a vector to return
            .collect()
    }

    // Get the total supply of series on the contract
    pub fn get_series_total_supply(&self) -> u64 {
        self.series_by_id.len()
    }

    // Paginate through all the series on the contract and return the a vector of JsonSeries
    pub fn get_series(&self, from_index: Option<U128>, limit: Option<u64>) -> Vec<JsonSeries> {
        //where to start pagination - if we have a from_index, we'll use that - otherwise start from 0 index
        let start = u128::from(from_index.unwrap_or(U128(0)));

        //iterate through each series using an iterator
        self.series_by_id
            .keys()
            //skip to the index we specified in the start variable
            .skip(start as usize)
            //take the first "limit" elements in the vector. If we didn't specify a limit, use 50
            .take(limit.unwrap_or(50) as usize)
            //we'll map the series IDs which are strings into Json Series
            .map(|series_id| self.get_series_details(series_id.clone()).unwrap())
            //since we turned the keys into an iterator, we need to turn it back into a vector to return
            .collect()
    }

    // get info for a specific series
    pub fn get_series_details(&self, id: u64) -> Option<JsonSeries> {
        //get the series from the map
        let series = self.series_by_id.get(&id);
        //if there is some series, we'll return the series
        if let Some(series) = series {
            Some(JsonSeries {
                series_id: id,
                metadata: series.metadata,
                royalty: series.royalty,
                owner_id: series.owner_id,
            })
        } else {
            //if there isn't a series, we'll return None
            None
        }
    }

    //get the total supply of NFTs on a current series
    pub fn nft_supply_for_series(&self, id: u64) -> U128 {
        //get the series
        let series = self.series_by_id.get(&id);

        //if there is some series, get the length of the tokens. Otherwise return -
        if let Some(series) = series {
            U128(series.tokens.len() as u128)
        } else {
            U128(0)
        }
    }

    /// Paginate through NFTs within a given series 
    pub fn nft_tokens_for_series(
        &self,
        id: u64,
        from_index: Option<U128>,
        limit: Option<u64>,
    ) -> Vec<JsonToken> {
        // Get the series and its tokens
        let series = self.series_by_id.get(&id);
        let tokens = if let Some(series) = series {
            series.tokens
        } else {
            return vec![];
        };

        //where to start pagination - if we have a from_index, we'll use that - otherwise start from 0 index
        let start = u128::from(from_index.unwrap_or(U128(0)));

        //iterate through the tokens
        tokens
            .iter()
            //skip to the index we specified in the start variable
            .skip(start as usize)
            //take the first "limit" elements in the vector. If we didn't specify a limit, use 50
            .take(limit.unwrap_or(50) as usize)
            //we'll map the token IDs which are strings into Json Tokens
            .map(|token_id| self.nft_token(token_id.clone()).unwrap())
            //since we turned the keys into an iterator, we need to turn it back into a vector to return
            .collect()
    }
}

'''
'''--- nft-tutorial/nft-series/src/events.rs ---
use std::fmt;

use near_sdk::serde::{Deserialize, Serialize};

/// Enum that represents the data type of the EventLog.
/// The enum can either be an NftMint or an NftTransfer.
#[derive(Serialize, Deserialize, Debug)]
#[serde(tag = "event", content = "data")]
#[serde(rename_all = "snake_case")]
#[serde(crate = "near_sdk::serde")]
#[non_exhaustive]
pub enum EventLogVariant {
    NftMint(Vec<NftMintLog>),
    NftTransfer(Vec<NftTransferLog>),
}

/// Interface to capture data about an event
///
/// Arguments:
/// * `standard`: name of standard e.g. nep171
/// * `version`: e.g. 1.0.0
/// * `event`: associate event data
#[derive(Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct EventLog {
    pub standard: String,
    pub version: String,

    // `flatten` to not have "event": {<EventLogVariant>} in the JSON, just have the contents of {<EventLogVariant>}.
    #[serde(flatten)]
    pub event: EventLogVariant,
}

impl fmt::Display for EventLog {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_fmt(format_args!(
            "EVENT_JSON:{}",
            &serde_json::to_string(self).map_err(|_| fmt::Error)?
        ))
    }
}

/// An event log to capture token minting
///
/// Arguments
/// * `owner_id`: "account.near"
/// * `token_ids`: ["1", "abc"]
/// * `memo`: optional message
#[derive(Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct NftMintLog {
    pub owner_id: String,
    pub token_ids: Vec<String>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub memo: Option<String>,
}

/// An event log to capture token transfer
///
/// Arguments
/// * `authorized_id`: approved account to transfer
/// * `old_owner_id`: "owner.near"
/// * `new_owner_id`: "receiver.near"
/// * `token_ids`: ["1", "12345abc"]
/// * `memo`: optional message
#[derive(Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct NftTransferLog {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub authorized_id: Option<String>,

    pub old_owner_id: String,
    pub new_owner_id: String,
    pub token_ids: Vec<String>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub memo: Option<String>,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn nep_format_vector() {
        let expected = r#"EVENT_JSON:{"standard":"nep171","version":"1.0.0","event":"nft_mint","data":[{"owner_id":"foundation.near","token_ids":["aurora","proximitylabs"]},{"owner_id":"user1.near","token_ids":["meme"]}]}"#;
        let log = EventLog {
            standard: "nep171".to_string(),
            version: "1.0.0".to_string(),
            event: EventLogVariant::NftMint(vec![
                NftMintLog {
                    owner_id: "foundation.near".to_owned(),
                    token_ids: vec!["aurora".to_string(), "proximitylabs".to_string()],
                    memo: None,
                },
                NftMintLog {
                    owner_id: "user1.near".to_owned(),
                    token_ids: vec!["meme".to_string()],
                    memo: None,
                },
            ]),
        };
        assert_eq!(expected, log.to_string());
    }

    #[test]
    fn nep_format_mint() {
        let expected = r#"EVENT_JSON:{"standard":"nep171","version":"1.0.0","event":"nft_mint","data":[{"owner_id":"foundation.near","token_ids":["aurora","proximitylabs"]}]}"#;
        let log = EventLog {
            standard: "nep171".to_string(),
            version: "1.0.0".to_string(),
            event: EventLogVariant::NftMint(vec![NftMintLog {
                owner_id: "foundation.near".to_owned(),
                token_ids: vec!["aurora".to_string(), "proximitylabs".to_string()],
                memo: None,
            }]),
        };
        assert_eq!(expected, log.to_string());
    }

    #[test]
    fn nep_format_transfer_all_fields() {
        let expected = r#"EVENT_JSON:{"standard":"nep171","version":"1.0.0","event":"nft_transfer","data":[{"authorized_id":"market.near","old_owner_id":"user1.near","new_owner_id":"user2.near","token_ids":["token"],"memo":"Go Team!"}]}"#;
        let log = EventLog {
            standard: "nep171".to_string(),
            version: "1.0.0".to_string(),
            event: EventLogVariant::NftTransfer(vec![NftTransferLog {
                authorized_id: Some("market.near".to_string()),
                old_owner_id: "user1.near".to_string(),
                new_owner_id: "user2.near".to_string(),
                token_ids: vec!["token".to_string()],
                memo: Some("Go Team!".to_owned()),
            }]),
        };
        assert_eq!(expected, log.to_string());
    }
}

'''
'''--- nft-tutorial/nft-series/src/internal.rs ---
use crate::*;
use near_sdk::CryptoHash;
use std::mem::size_of;

//convert the royalty percentage and amount to pay into a payout (U128)
pub(crate) fn royalty_to_payout(royalty_percentage: u32, amount_to_pay: Balance) -> U128 {
    U128(royalty_percentage as u128 * amount_to_pay / 10_000u128)
}

//calculate how many bytes the account ID is taking up
pub(crate) fn bytes_for_approved_account_id(account_id: &AccountId) -> u64 {
    // The extra 4 bytes are coming from Borsh serialization to store the length of the string.
    account_id.as_str().len() as u64 + 4 + size_of::<u64>() as u64
}

//refund the storage taken up by passed in approved account IDs and send the funds to the passed in account ID.
pub(crate) fn refund_approved_account_ids_iter<'a, I>(
    account_id: AccountId,
    approved_account_ids: I, //the approved account IDs must be passed in as an iterator
) -> Promise
where
    I: Iterator<Item = &'a AccountId>,
{
    //get the storage total by going through and summing all the bytes for each approved account IDs
    let storage_released: u64 = approved_account_ids
        .map(bytes_for_approved_account_id)
        .sum();
    //transfer the account the storage that is released
    Promise::new(account_id).transfer(Balance::from(storage_released) * env::storage_byte_cost())
}

//refund a map of approved account IDs and send the funds to the passed in account ID
pub(crate) fn refund_approved_account_ids(
    account_id: AccountId,
    approved_account_ids: &HashMap<AccountId, u64>,
) -> Promise {
    //call the refund_approved_account_ids_iter with the approved account IDs as keys
    refund_approved_account_ids_iter(account_id, approved_account_ids.keys())
}

//used to generate a unique prefix in our storage collections (this is to avoid data collisions)
pub(crate) fn hash_account_id(account_id: &String) -> CryptoHash {
    //get the default hash
    let mut hash = CryptoHash::default();
    //we hash the account ID and return it
    hash.copy_from_slice(&env::sha256(account_id.as_bytes()));
    hash
}

//used to make sure the user attached exactly 1 yoctoNEAR
pub(crate) fn assert_one_yocto() {
    assert_eq!(
        env::attached_deposit(),
        1,
        "Requires attached deposit of exactly 1 yoctoNEAR",
    )
}

//Assert that the user has attached at least 1 yoctoNEAR (for security reasons and to pay for storage)
pub(crate) fn assert_at_least_one_yocto() {
    assert!(
        env::attached_deposit() >= 1,
        "Requires attached deposit of at least 1 yoctoNEAR",
    )
}

// Send all the non storage funds to the series owner
pub(crate) fn payout_series_owner(storage_used: u64, price_per_token: Balance, owner_id: AccountId) {
    //get how much it would cost to store the information
    let required_cost = env::storage_byte_cost() * Balance::from(storage_used);
    //get the attached deposit
    let attached_deposit = env::attached_deposit();

    //make sure that the attached deposit is greater than or equal to the required cost
    assert!(
        attached_deposit >= required_cost + price_per_token,
        "Must attach {} yoctoNEAR to cover storage and price per token {}",
        required_cost,
        price_per_token
    );

    // If there's a price for the token, transfer everything but the storage to the series owner
    if price_per_token > 0 {
        Promise::new(owner_id).transfer(attached_deposit - required_cost);
    }
}

//refund the initial deposit based on the amount of storage that was used up
pub(crate) fn refund_deposit(storage_used: u64) {
    //get how much it would cost to store the information
    let required_cost = env::storage_byte_cost() * Balance::from(storage_used);
    //get the attached deposit
    let attached_deposit = env::attached_deposit();

    //make sure that the attached deposit is greater than or equal to the required cost
    assert!(
        required_cost <= attached_deposit,
        "Must attach {} yoctoNEAR to cover storage",
        required_cost,
    );

    //get the refund amount from the attached deposit - required cost
    let refund = attached_deposit - required_cost;

    //if the refund is greater than 1 yocto NEAR, we refund the predecessor that amount
    if refund > 1 {
        Promise::new(env::predecessor_account_id()).transfer(refund);
    }
}

impl Contract {
    /// Ensure that the caller is the owner of the contract
    pub(crate) fn assert_contract_owner(&mut self) {
        assert!(
            self.owner_id == env::predecessor_account_id(),
            "only contract owner"
        )
    }

    //add a token to the set of tokens an owner has
    pub(crate) fn internal_add_token_to_owner(
        &mut self,
        account_id: &AccountId,
        token_id: &TokenId,
    ) {
        //get the set of tokens for the given account
        let mut tokens_set = self.tokens_per_owner.get(account_id).unwrap_or_else(|| {
            //if the account doesn't have any tokens, we create a new unordered set
            UnorderedSet::new(
                StorageKey::TokenPerOwnerInner {
                    //we get a new unique prefix for the collection
                    account_id_hash: hash_account_id(&account_id.to_string()),
                }
                .try_to_vec()
                .unwrap(),
            )
        });

        //we insert the token ID into the set
        tokens_set.insert(token_id);

        //we insert that set for the given account ID.
        self.tokens_per_owner.insert(account_id, &tokens_set);
    }

    //remove a token from an owner (internal method and can't be called directly via CLI).
    pub(crate) fn internal_remove_token_from_owner(
        &mut self,
        account_id: &AccountId,
        token_id: &TokenId,
    ) {
        //we get the set of tokens that the owner has
        let mut tokens_set = self
            .tokens_per_owner
            .get(account_id)
            //if there is no set of tokens for the owner, we panic with the following message:
            .expect("Token should be owned by the sender");

        //we remove the the token_id from the set of tokens
        tokens_set.remove(token_id);

        //if the token set is now empty, we remove the owner from the tokens_per_owner collection
        if tokens_set.is_empty() {
            self.tokens_per_owner.remove(account_id);
        } else {
            //if the token set is not empty, we simply insert it back for the account ID.
            self.tokens_per_owner.insert(account_id, &tokens_set);
        }
    }

    //transfers the NFT to the receiver_id (internal method and can't be called directly via CLI).
    pub(crate) fn internal_transfer(
        &mut self,
        sender_id: &AccountId,
        receiver_id: &AccountId,
        token_id: &TokenId,
        //we introduce an approval ID so that people with that approval ID can transfer the token
        approval_id: Option<u64>,
        memo: Option<String>,
    ) -> Token {
        //get the token object by passing in the token_id
        let token = self.tokens_by_id.get(token_id).expect("No token");

        //if the sender doesn't equal the owner, we check if the sender is in the approval list
        if sender_id != &token.owner_id {
            //if the token's approved account IDs doesn't contain the sender, we panic
            if !token.approved_account_ids.contains_key(sender_id) {
                env::panic_str("Unauthorized");
            }

            // If they included an approval_id, check if the sender's actual approval_id is the same as the one included
            if let Some(enforced_approval_id) = approval_id {
                //get the actual approval ID
                let actual_approval_id = token
                    .approved_account_ids
                    .get(sender_id)
                    //if the sender isn't in the map, we panic
                    .expect("Sender is not approved account");

                //make sure that the actual approval ID is the same as the one provided
                assert_eq!(
                    actual_approval_id, &enforced_approval_id,
                    "The actual approval_id {} is different from the given approval_id {}",
                    actual_approval_id, enforced_approval_id,
                );
            }
        }

        //we make sure that the sender isn't sending the token to themselves
        assert_ne!(
            &token.owner_id, receiver_id,
            "The token owner and the receiver should be different"
        );

        //we remove the token from it's current owner's set
        self.internal_remove_token_from_owner(&token.owner_id, token_id);
        //we then add the token to the receiver_id's set
        self.internal_add_token_to_owner(receiver_id, token_id);

        //we create a new token struct
        let new_token = Token {
            series_id: token.series_id,
            owner_id: receiver_id.clone(),
            //reset the approval account IDs
            approved_account_ids: Default::default(),
            next_approval_id: token.next_approval_id,
        };
        //insert that new token into the tokens_by_id, replacing the old entry
        self.tokens_by_id.insert(token_id, &new_token);

        //if there was some memo attached, we log it.
        if let Some(memo) = memo.as_ref() {
            env::log_str(&format!("Memo: {}", memo).to_string());
        }

        // Default the authorized ID to be None for the logs.
        let mut authorized_id = None;
        //if the approval ID was provided, set the authorized ID equal to the sender
        if approval_id.is_some() {
            authorized_id = Some(sender_id.to_string());
        }

        // Construct the transfer log as per the events standard.
        let nft_transfer_log: EventLog = EventLog {
            // Standard name ("nep171").
            standard: NFT_STANDARD_NAME.to_string(),
            // Version of the standard ("nft-1.0.0").
            version: NFT_METADATA_SPEC.to_string(),
            // The data related with the event stored in a vector.
            event: EventLogVariant::NftTransfer(vec![NftTransferLog {
                // The optional authorized account ID to transfer the token on behalf of the old owner.
                authorized_id,
                // The old owner's account ID.
                old_owner_id: token.owner_id.to_string(),
                // The account ID of the new owner of the token.
                new_owner_id: receiver_id.to_string(),
                // A vector containing the token IDs as strings.
                token_ids: vec![token_id.to_string()],
                // An optional memo to include.
                memo,
            }]),
        };

        // Log the serialized json.
        env::log_str(&nft_transfer_log.to_string());

        //return the previous token object that was transferred.
        token
    }
}

'''
'''--- nft-tutorial/nft-series/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LazyOption, LookupMap, LookupSet, UnorderedMap, UnorderedSet};
use near_sdk::json_types::{Base64VecU8, U128};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{
    env, near_bindgen, require, AccountId, Balance, BorshStorageKey, CryptoHash, PanicOnDefault,
    Promise, PromiseOrValue,
};
use std::collections::HashMap;

pub use crate::approval::*;
pub use crate::events::*;
use crate::internal::*;
pub use crate::metadata::*;
pub use crate::nft_core::*;
pub use crate::owner::*;
pub use crate::royalty::*;
pub use crate::series::*;

mod approval;
mod enumeration;
mod events;
mod internal;
mod metadata;
mod nft_core;
mod owner;
mod royalty;
mod series;

/// This spec can be treated like a version of the standard.
pub const NFT_METADATA_SPEC: &str = "1.0.0";
/// This is the name of the NFT standard we're using
pub const NFT_STANDARD_NAME: &str = "nep171";

// Represents the series type. All tokens will derive this data.
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Series {
    // Metadata including title, num copies etc.. that all tokens will derive from
    metadata: TokenMetadata,
    // Royalty used for all tokens in the collection
    royalty: Option<HashMap<AccountId, u32>>,
    // Set of tokens in the collection
    tokens: UnorderedSet<TokenId>,
    // What is the price of each token in this series? If this is specified, when minting,
    // Users will need to attach enough $NEAR to cover the price.
    price: Option<Balance>,
    // Owner of the collection
    owner_id: AccountId,
}

pub type SeriesId = u64;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    //contract owner
    pub owner_id: AccountId,

    //approved minters
    pub approved_minters: LookupSet<AccountId>,

    //approved users that can create series
    pub approved_creators: LookupSet<AccountId>,

    //Map the collection ID (stored in Token obj) to the collection data
    pub series_by_id: UnorderedMap<SeriesId, Series>,

    //keeps track of the token struct for a given token ID
    pub tokens_by_id: UnorderedMap<TokenId, Token>,

    //keeps track of all the token IDs for a given account
    pub tokens_per_owner: LookupMap<AccountId, UnorderedSet<TokenId>>,

    //keeps track of the metadata for the contract
    pub metadata: LazyOption<NFTContractMetadata>,
}

/// Helper structure for keys of the persistent collections.
#[derive(BorshSerialize, BorshStorageKey)]
pub enum StorageKey {
    ApprovedMinters,
    ApprovedCreators,
    SeriesById,
    SeriesByIdInner { account_id_hash: CryptoHash },
    TokensPerOwner,
    TokenPerOwnerInner { account_id_hash: CryptoHash },
    TokensById,
    NFTContractMetadata,
}

#[near_bindgen]
impl Contract {
    /*
        initialization function (can only be called once).
        this initializes the contract with default metadata so the
        user doesn't have to manually type metadata.
    */
    #[init]
    pub fn new_default_meta(owner_id: AccountId) -> Self {
        //calls the other function "new: with some default metadata and the owner_id passed in
        Self::new(
            owner_id,
            NFTContractMetadata {
                spec: "nft-1.0.0".to_string(),
                name: "NFT Series Contract".to_string(),
                symbol: "GOTEAM".to_string(),
                icon: None,
                base_uri: None,
                reference: None,
                reference_hash: None,
            },
        )
    }

    /*
        initialization function (can only be called once).
        this initializes the contract with metadata that was passed in and
        the owner_id.
    */
    #[init]
    pub fn new(owner_id: AccountId, metadata: NFTContractMetadata) -> Self {
        // Create the approved minters set and insert the owner
        let mut approved_minters =
            LookupSet::new(StorageKey::ApprovedMinters.try_to_vec().unwrap());
        approved_minters.insert(&owner_id);

        // Create the approved creators set and insert the owner
        let mut approved_creators =
            LookupSet::new(StorageKey::ApprovedCreators.try_to_vec().unwrap());
        approved_creators.insert(&owner_id);
        
        // Create a variable of type Self with all the fields initialized.
        let this = Self {
            approved_minters,
            approved_creators,
            series_by_id: UnorderedMap::new(StorageKey::SeriesById.try_to_vec().unwrap()),
            //Storage keys are simply the prefixes used for the collections. This helps avoid data collision
            tokens_per_owner: LookupMap::new(StorageKey::TokensPerOwner.try_to_vec().unwrap()),
            tokens_by_id: UnorderedMap::new(StorageKey::TokensById.try_to_vec().unwrap()),
            //set the &owner_id field equal to the passed in owner_id.
            owner_id,
            metadata: LazyOption::new(
                StorageKey::NFTContractMetadata.try_to_vec().unwrap(),
                Some(&metadata),
            ),
        };

        //return the Contract object
        this
    }
}
'''
'''--- nft-tutorial/nft-series/src/metadata.rs ---
use crate::*;
pub type TokenId = String;
//defines the payout type we'll be returning as a part of the royalty standards.
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Payout {
    pub payout: HashMap<AccountId, U128>,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct NFTContractMetadata {
    pub spec: String,              // required, essentially a version like "nft-1.0.0"
    pub name: String,              // required, ex. "Mosaics"
    pub symbol: String,            // required, ex. "MOSAIC"
    pub icon: Option<String>,      // Data URL
    pub base_uri: Option<String>, // Centralized gateway known to have reliable access to decentralized storage assets referenced by `reference` or `media` URLs
    pub reference: Option<String>, // URL to a JSON file with more info
    pub reference_hash: Option<Base64VecU8>, // Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included.
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct TokenMetadata {
    pub title: Option<String>, // ex. "Arch Nemesis: Mail Carrier" or "Parcel #5055"
    pub description: Option<String>, // free-form description
    pub media: Option<String>, // URL to associated media, preferably to decentralized, content-addressed storage
    pub media_hash: Option<Base64VecU8>, // Base64-encoded sha256 hash of content referenced by the `media` field. Required if `media` is included.
    pub copies: Option<u64>, // number of copies of this set of metadata in existence when token was minted.
    pub issued_at: Option<u64>, // When token was issued or minted, Unix epoch in milliseconds
    pub expires_at: Option<u64>, // When token expires, Unix epoch in milliseconds
    pub starts_at: Option<u64>, // When token starts being valid, Unix epoch in milliseconds
    pub updated_at: Option<u64>, // When token was last updated, Unix epoch in milliseconds
    pub extra: Option<String>, // anything extra the NFT wants to store on-chain. Can be stringified JSON.
    pub reference: Option<String>, // URL to an off-chain JSON file with more info.
    pub reference_hash: Option<Base64VecU8>, // Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included.
}

#[derive(BorshDeserialize, BorshSerialize)]
pub struct Token {
    // Series that the token belongs to
    pub series_id: u64,
    //owner of the token
    pub owner_id: AccountId,
    //list of approved account IDs that have access to transfer the token. This maps an account ID to an approval ID
    pub approved_account_ids: HashMap<AccountId, u64>,
    //the next approval ID to give out.
    pub next_approval_id: u64,
}

//The Json token is what will be returned from view calls.
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct JsonToken {
    // Series that the token belongs to
    pub series_id: u64,
    //token ID
    pub token_id: TokenId,
    //owner of the token
    pub owner_id: AccountId,
    //token metadata
    pub metadata: TokenMetadata,
    //list of approved account IDs that have access to transfer the token. This maps an account ID to an approval ID
    pub approved_account_ids: HashMap<AccountId, u64>,
    //keep track of the royalty percentages for the token in a hash map
    pub royalty: Option<HashMap<AccountId, u32>>,
}

pub trait NonFungibleTokenMetadata {
    //view call for returning the contract metadata
    fn nft_metadata(&self) -> NFTContractMetadata;
}

#[near_bindgen]
impl NonFungibleTokenMetadata for Contract {
    fn nft_metadata(&self) -> NFTContractMetadata {
        self.metadata.get().unwrap()
    }
}

'''
'''--- nft-tutorial/nft-series/src/nft_core.rs ---
use crate::*;
use near_sdk::{ext_contract, Gas, PromiseResult};

const GAS_FOR_RESOLVE_TRANSFER: Gas = Gas(10_000_000_000_000);
const GAS_FOR_NFT_ON_TRANSFER: Gas = Gas(25_000_000_000_000);

pub trait NonFungibleTokenCore {
    //transfers an NFT to a receiver ID
    fn nft_transfer(
        &mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        //we introduce an approval ID so that people with that approval ID can transfer the token
        approval_id: Option<u64>,
        memo: Option<String>,
    );

    //transfers an NFT to a receiver and calls a function on the receiver ID's contract
    /// Returns `true` if the token was transferred from the sender's account.
    fn nft_transfer_call(
        &mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        //we introduce an approval ID so that people with that approval ID can transfer the token
        approval_id: Option<u64>,
        memo: Option<String>,
        msg: String,
    ) -> PromiseOrValue<bool>;

    //get information about the NFT token passed in
    fn nft_token(&self, token_id: TokenId) -> Option<JsonToken>;
}

#[ext_contract(ext_non_fungible_token_receiver)]
trait NonFungibleTokenReceiver {
    //Method stored on the receiver contract that is called via cross contract call when nft_transfer_call is called
    /// Returns `true` if the token should be returned back to the sender.
    fn nft_on_transfer(
        &mut self,
        sender_id: AccountId,
        previous_owner_id: AccountId,
        token_id: TokenId,
        msg: String,
    ) -> Promise;
}

#[ext_contract(ext_self)]
/*
    resolves the promise of the cross contract call to the receiver contract
    this is stored on THIS contract and is meant to analyze what happened in the cross contract call when nft_on_transfer was called
    as part of the nft_transfer_call method
*/
trait NonFungibleTokenResolver {
    fn nft_resolve_transfer(
        &mut self,
        //we introduce an authorized ID for logging the transfer event
        authorized_id: Option<String>,
        owner_id: AccountId,
        receiver_id: AccountId,
        token_id: TokenId,
        //we introduce the approval map so we can keep track of what the approvals were before the transfer
        approved_account_ids: HashMap<AccountId, u64>,
        //we introduce a memo for logging the transfer event
        memo: Option<String>,
    ) -> bool;
}

#[near_bindgen]
impl NonFungibleTokenCore for Contract {
    //implementation of the nft_transfer method. This transfers the NFT from the current owner to the receiver.
    #[payable]
    fn nft_transfer(
        &mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        //we introduce an approval ID so that people with that approval ID can transfer the token
        approval_id: Option<u64>,
        memo: Option<String>,
    ) {
        //assert that the user attached exactly 1 yoctoNEAR. This is for security and so that the user will be redirected to the NEAR wallet.
        assert_one_yocto();
        //get the sender to transfer the token from the sender to the receiver
        let sender_id = env::predecessor_account_id();

        //call the internal transfer method and get back the previous token so we can refund the approved account IDs
        let previous_token =
            self.internal_transfer(&sender_id, &receiver_id, &token_id, approval_id, memo);

        //we refund the owner for releasing the storage used up by the approved account IDs
        refund_approved_account_ids(
            previous_token.owner_id.clone(),
            &previous_token.approved_account_ids,
        );
    }

    //implementation of the transfer call method. This will transfer the NFT and call a method on the receiver_id contract
    #[payable]
    fn nft_transfer_call(
        &mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        //we introduce an approval ID so that people with that approval ID can transfer the token
        approval_id: Option<u64>,
        memo: Option<String>,
        msg: String,
    ) -> PromiseOrValue<bool> {
        //assert that the user attached exactly 1 yocto for security reasons.
        assert_one_yocto();

        //get the sender ID
        let sender_id = env::predecessor_account_id();

        //transfer the token and get the previous token object
        let previous_token = self.internal_transfer(
            &sender_id,
            &receiver_id,
            &token_id,
            approval_id,
            memo.clone(),
        );

        //default the authorized_id to none
        let mut authorized_id = None;
        //if the sender isn't the owner of the token, we set the authorized ID equal to the sender.
        if sender_id != previous_token.owner_id {
            authorized_id = Some(sender_id.to_string());
        }

        // Initiating receiver's call and the callback
        // Defaulting GAS weight to 1, no attached deposit, and static GAS equal to the GAS for nft on transfer.
        ext_non_fungible_token_receiver::ext(receiver_id.clone())
            .with_static_gas(GAS_FOR_NFT_ON_TRANSFER)
            .nft_on_transfer(
                sender_id,
                previous_token.owner_id.clone(),
                token_id.clone(),
                msg,
            )
            // We then resolve the promise and call nft_resolve_transfer on our own contract
            .then(
                // Defaulting GAS weight to 1, no attached deposit, and static GAS equal to the GAS for resolve transfer
                Self::ext(env::current_account_id())
                    .with_static_gas(GAS_FOR_RESOLVE_TRANSFER)
                    .nft_resolve_transfer(
                        authorized_id, // we introduce an authorized ID so that we can log the transfer
                        previous_token.owner_id,
                        receiver_id,
                        token_id,
                        previous_token.approved_account_ids,
                        memo, // we introduce a memo for logging in the events standard
                    ),
            )
            .into()
    }

    //get the information for a specific token ID
    fn nft_token(&self, token_id: TokenId) -> Option<JsonToken> {
        //if there is some token ID in the tokens_by_id collection
        if let Some(token) = self.tokens_by_id.get(&token_id) {
            // Get the series information
            let cur_series = self
                .series_by_id
                .get(&token.series_id)
                .expect("Not a series");
            // Get the metadata for the series
            let mut metadata = cur_series.metadata;

            // Get the edition number and series ID
            let split: Vec<&str> = token_id.split(":").collect();
            let edition_number = split[1];
            // If there is a title for the NFT, add the token ID to it.
            if let Some(title) = metadata.title {
                metadata.title = Some(format!("{} - {}", title, edition_number));
            } else {
                // If there is no title, we simply create one based on the series number and edition number
                metadata.title = Some(format!("Series {} : Edition {}", split[0], split[1]));
            }

            //we return the JsonToken (wrapped by Some since we return an option)
            Some(JsonToken {
                series_id: token.series_id,
                token_id,
                owner_id: token.owner_id,
                metadata,
                approved_account_ids: token.approved_account_ids,
                royalty: cur_series.royalty,
            })
        } else {
            //if there wasn't a token ID in the tokens_by_id collection, we return None
            None
        }
    }
}

#[near_bindgen]
impl NonFungibleTokenResolver for Contract {
    //resolves the cross contract call when calling nft_on_transfer in the nft_transfer_call method
    //returns true if the token was successfully transferred to the receiver_id
    #[private]
    fn nft_resolve_transfer(
        &mut self,
        //we introduce an authorized ID for logging the transfer event
        authorized_id: Option<String>,
        owner_id: AccountId,
        receiver_id: AccountId,
        token_id: TokenId,
        //we introduce the approval map so we can keep track of what the approvals were before the transfer
        approved_account_ids: HashMap<AccountId, u64>,
        //we introduce a memo for logging the transfer event
        memo: Option<String>,
    ) -> bool {
        // Whether receiver wants to return token back to the sender, based on `nft_on_transfer`
        // call result.
        if let PromiseResult::Successful(value) = env::promise_result(0) {
            //As per the standard, the nft_on_transfer should return whether we should return the token to it's owner or not
            if let Ok(return_token) = near_sdk::serde_json::from_slice::<bool>(&value) {
                //if we need don't need to return the token, we simply return true meaning everything went fine
                if !return_token {
                    /*
                        since we've already transferred the token and nft_on_transfer returned false, we don't have to
                        revert the original transfer and thus we can just return true since nothing went wrong.
                    */
                    //we refund the owner for releasing the storage used up by the approved account IDs
                    refund_approved_account_ids(owner_id, &approved_account_ids);
                    return true;
                }
            }
        }

        //get the token object if there is some token object
        let mut token = if let Some(token) = self.tokens_by_id.get(&token_id) {
            if token.owner_id != receiver_id {
                //we refund the owner for releasing the storage used up by the approved account IDs
                refund_approved_account_ids(owner_id, &approved_account_ids);
                // The token is not owner by the receiver anymore. Can't return it.
                return true;
            }
            token
        //if there isn't a token object, it was burned and so we return true
        } else {
            //we refund the owner for releasing the storage used up by the approved account IDs
            refund_approved_account_ids(owner_id, &approved_account_ids);
            return true;
        };

        //we remove the token from the receiver
        self.internal_remove_token_from_owner(&receiver_id.clone(), &token_id);
        //we add the token to the original owner
        self.internal_add_token_to_owner(&owner_id, &token_id);

        //we change the token struct's owner to be the original owner
        token.owner_id = owner_id.clone();

        //we refund the receiver any approved account IDs that they may have set on the token
        refund_approved_account_ids(receiver_id.clone(), &token.approved_account_ids);
        //reset the approved account IDs to what they were before the transfer
        token.approved_account_ids = approved_account_ids;

        //we inset the token back into the tokens_by_id collection
        self.tokens_by_id.insert(&token_id, &token);

        /*
            We need to log that the NFT was reverted back to the original owner.
            The old_owner_id will be the receiver and the new_owner_id will be the
            original owner of the token since we're reverting the transfer.
        */
        let nft_transfer_log: EventLog = EventLog {
            // Standard name ("nep171").
            standard: NFT_STANDARD_NAME.to_string(),
            // Version of the standard ("nft-1.0.0").
            version: NFT_METADATA_SPEC.to_string(),
            // The data related with the event stored in a vector.
            event: EventLogVariant::NftTransfer(vec![NftTransferLog {
                // The optional authorized account ID to transfer the token on behalf of the old owner.
                authorized_id,
                // The old owner's account ID.
                old_owner_id: receiver_id.to_string(),
                // The account ID of the new owner of the token.
                new_owner_id: owner_id.to_string(),
                // A vector containing the token IDs as strings.
                token_ids: vec![token_id.to_string()],
                // An optional memo to include.
                memo,
            }]),
        };

        //we perform the actual logging
        env::log_str(&nft_transfer_log.to_string());

        //return false
        false
    }
}

'''
'''--- nft-tutorial/nft-series/src/owner.rs ---
use crate::*;

#[near_bindgen]
impl Contract {
    /// Add a specified account as an approved minter
    pub fn add_approved_minter(&mut self, account_id: AccountId) {
        self.assert_contract_owner();
        self.approved_minters.insert(&account_id);
    }

    /// Remove a specified account as an approved minter
    pub fn remove_approved_minter(&mut self, account_id: AccountId) {
        self.assert_contract_owner();
        self.approved_minters.remove(&account_id);
    }

    /// Check if a specified account is an approved minter
    pub fn is_approved_minter(&self, account_id: AccountId) -> bool {
        self.approved_minters.contains(&account_id)
    }

    /// Add a specified account as an approved creator
    pub fn add_approved_creator(&mut self, account_id: AccountId) {
        self.assert_contract_owner();
        self.approved_creators.insert(&account_id);
    }

    /// Remove a specified account as an approved creator
    pub fn remove_approved_creator(&mut self, account_id: AccountId) {
        self.assert_contract_owner();
        self.approved_creators.remove(&account_id);
    }

    /// Check if a specified account is an approved creator
    pub fn is_approved_creator(&self, account_id: AccountId) -> bool {
        self.approved_creators.contains(&account_id)
    }
}

'''
'''--- nft-tutorial/nft-series/src/royalty.rs ---
use crate::*;

pub trait NonFungibleTokenCore {
    //calculates the payout for a token given the passed in balance. This is a view method
    fn nft_payout(&self, token_id: TokenId, balance: U128, max_len_payout: u32) -> Payout;

    //transfers the token to the receiver ID and returns the payout object that should be payed given the passed in balance.
    fn nft_transfer_payout(
        &mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        approval_id: u64,
        memo: Option<String>,
        balance: U128,
        max_len_payout: u32,
    ) -> Payout;
}

#[near_bindgen]
impl NonFungibleTokenCore for Contract {
    //calculates the payout for a token given the passed in balance. This is a view method
    fn nft_payout(&self, token_id: TokenId, balance: U128, max_len_payout: u32) -> Payout {
        //get the token object
        let token = self.tokens_by_id.get(&token_id).expect("No token");

        //get the owner of the token
        let owner_id = token.owner_id;
        //keep track of the total perpetual royalties
        let mut total_perpetual = 0;
        //get the u128 version of the passed in balance (which was U128 before)
        let balance_u128 = u128::from(balance);
        //keep track of the payout object to send back
        let mut payout_object = Payout {
            payout: HashMap::new(),
        };
        //get the royalty object from series
        let cur_series = self
            .series_by_id
            .get(&token.series_id)
            .expect("Not a series");

        // If the series doesn't have a royalty, we'll return an a payout object that just includes the owner
        let royalty_option = cur_series.royalty;
        if royalty_option.is_none() {
            let mut payout = HashMap::new();
            payout.insert(owner_id, balance);
            return Payout {
                payout: payout
            };
        }
        // Otherwise, we will get the royalty object from the series
        let royalty = royalty_option.unwrap();

        //make sure we're not paying out to too many people (GAS limits this)
        assert!(
            royalty.len() as u32 <= max_len_payout,
            "Market can&not payout to that many receivers"
        );

        //go through each key and value in the royalty object
        for (k, v) in royalty.iter() {
            //get the key
            let key = k.clone();
            //only insert into the payout if the key isn't the token owner (we add their payout at the end)
            if key != owner_id {
                //
                payout_object
                    .payout
                    .insert(key, royalty_to_payout(*v, balance_u128));
                total_perpetual += *v;
            }
        }

        // payout to previous owner who gets 100% - total perpetual royalties
        payout_object.payout.insert(
            owner_id,
            royalty_to_payout(10000 - total_perpetual, balance_u128),
        );

        //return the payout object
        payout_object
    }

    //transfers the token to the receiver ID and returns the payout object that should be payed given the passed in balance.
    #[payable]
    fn nft_transfer_payout(
        &mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        approval_id: u64,
        memo: Option<String>,
        balance: U128,
        max_len_payout: u32,
    ) -> Payout {
        //assert that the user attached 1 yocto NEAR for security reasons
        assert_one_yocto();
        //get the sender ID
        let sender_id = env::predecessor_account_id();
        //transfer the token to the passed in receiver and get the previous token object back
        let previous_token =
            self.internal_transfer(&sender_id, &receiver_id, &token_id, Some(approval_id), memo);

        //refund the previous token owner for the storage used up by the previous approved account IDs
        refund_approved_account_ids(
            previous_token.owner_id.clone(),
            &previous_token.approved_account_ids,
        );

        //get the owner of the token
        let owner_id = previous_token.owner_id;
        //keep track of the total perpetual royalties
        let mut total_perpetual = 0;
        //get the u128 version of the passed in balance (which was U128 before)
        let balance_u128 = u128::from(balance);
        //keep track of the payout object to send back
        let mut payout_object = Payout {
            payout: HashMap::new(),
        };

        //get the royalty object from series
        let cur_series = self
            .series_by_id
            .get(&previous_token.series_id)
            .expect("Not a series");

        // If the series doesn't have a royalty, we'll return an a payout object that just includes the owner
        let royalty_option = cur_series.royalty;
        if royalty_option.is_none() {
            let mut payout = HashMap::new();
            payout.insert(owner_id, balance);
            return Payout {
                payout: payout
            };
        }
        // Otherwise, we will get the royalty object from the series
        let royalty = royalty_option.unwrap();

        //make sure we're not paying out to too many people (GAS limits this)
        assert!(
            royalty.len() as u32 <= max_len_payout,
            "Market cannot payout to that many receivers"
        );

        //go through each key and value in the royalty object
        for (k, v) in royalty.iter() {
            //get the key
            let key = k.clone();
            //only insert into the payout if the key isn't the token owner (we add their payout at the end)
            if key != owner_id {
                //
                payout_object
                    .payout
                    .insert(key, royalty_to_payout(*v, balance_u128));
                total_perpetual += *v;
            }
        }

        // payout to previous owner who gets 100% - total perpetual royalties
        payout_object.payout.insert(
            owner_id,
            royalty_to_payout(10000 - total_perpetual, balance_u128),
        );

        //return the payout object
        payout_object
    }
}

'''
'''--- nft-tutorial/nft-series/src/series.rs ---
use near_sdk::json_types::U64;

use crate::*;

#[near_bindgen]
impl Contract {
    /// Create a new series. The caller must be an approved creator. All tokens in the series will inherit the same metadata
    /// If copies are set in the metadata, it will enforce that only that number of NFTs can be minted. If not, unlimited NFTs can be minted.
    /// If a title is set in the metadata, enumeration methods will return the `${title} - ${edition}` else, `${series_id} - ${edition}`
    /// All token IDs internally are stored as `${series_id}:${edition}`
    /// Caller must attach enough $NEAR to cover storage.
    #[payable]
    pub fn create_series(
        &mut self,
        id: u64,
        metadata: TokenMetadata,
        royalty: Option<HashMap<AccountId, u32>>,
        price: Option<U128>
    ) {
        // Measure the initial storage being used on the contract
        let initial_storage_usage = env::storage_usage();

        // Ensure the caller is an approved creator
        let caller = env::predecessor_account_id();
        require!(
            self.approved_creators.contains(&caller) == true,
            "only approved creators can add a type"
        );

        // Insert the series and ensure it doesn't already exist
        require!(
            self.series_by_id
                .insert(
                    &id,
                    &Series {
                        metadata,
                        royalty,
                        tokens: UnorderedSet::new(StorageKey::SeriesByIdInner {
                            // We get a new unique prefix for the collection
                            account_id_hash: hash_account_id(&format!(
                                "{}{}",
                                id, caller
                            )),
                        }),
                        owner_id: caller,
                        price: price.map(|p| p.into()),
                    }
                )
                .is_none(),
            "collection ID already exists"
        );

        //calculate the required storage which was the used - initial
        let required_storage_in_bytes = env::storage_usage() - initial_storage_usage;

        //refund any excess storage if the user attached too much. Panic if they didn't attach enough to cover the required.
        refund_deposit(required_storage_in_bytes);
    }

    /// Mint a new NFT that is part of a series. The caller must be an approved minter.
    /// The series ID must exist and if the metadata specifies a copy limit, you cannot exceed it.
    #[payable]
    pub fn nft_mint(&mut self, id: U64, receiver_id: AccountId) {
        // Measure the initial storage being used on the contract
        let initial_storage_usage = env::storage_usage();

        // Get the series and how many tokens currently exist (edition number = cur_len + 1)
        let mut series = self.series_by_id.get(&id.0).expect("Not a series");
        
        // Check if the series has a price per token. If it does, ensure the caller has attached at least that amount
        let mut price_per_token = 0; 
        if let Some(price) = series.price {
            price_per_token = price;
            require!(env::attached_deposit() > price_per_token, "Need to attach at least enough to cover price");
        // If the series doesn't have a price, ensure the caller is an approved minter.
        } else {
            // Ensure the caller is an approved minter
            let predecessor = env::predecessor_account_id();
            assert!(
                self.approved_minters.contains(&predecessor),
                "Not approved minter"
            );
        }

        let cur_len = series.tokens.len();
        // Ensure we haven't overflowed on the number of copies minted
        if let Some(copies) = series.metadata.copies {
            require!(
                cur_len < copies,
                "cannot mint anymore NFTs for the given series. Limit reached"
            );
        }

        // The token ID is stored internally as `${series_id}:${edition}`
        let token_id = format!("{}:{}", id.0, cur_len + 1);
        series.tokens.insert(&token_id);
        self.series_by_id.insert(&id.0, &series);

        //specify the token struct that contains the owner ID
        let token = Token {
            // Series ID that the token belongs to
            series_id: id.0,
            //set the owner ID equal to the receiver ID passed into the function
            owner_id: receiver_id,
            //we set the approved account IDs to the default value (an empty map)
            approved_account_ids: Default::default(),
            //the next approval ID is set to 0
            next_approval_id: 0,
        };

        //insert the token ID and token struct and make sure that the token doesn't exist
        require!(
            self.tokens_by_id.insert(&token_id, &token).is_none(),
            "Token already exists"
        );

        //call the internal method for adding the token to the owner
        self.internal_add_token_to_owner(&token.owner_id, &token_id);

        // Construct the mint log as per the events standard.
        let nft_mint_log: EventLog = EventLog {
            // Standard name ("nep171").
            standard: NFT_STANDARD_NAME.to_string(),
            // Version of the standard ("nft-1.0.0").
            version: NFT_METADATA_SPEC.to_string(),
            // The data related with the event stored in a vector.
            event: EventLogVariant::NftMint(vec![NftMintLog {
                // Owner of the token.
                owner_id: token.owner_id.to_string(),
                // Vector of token IDs that were minted.
                token_ids: vec![token_id.to_string()],
                // An optional memo to include.
                memo: None,
            }]),
        };

        // Log the serialized json.
        env::log_str(&nft_mint_log.to_string());

        //calculate the required storage which was the used - initial
        let required_storage_in_bytes = env::storage_usage() - initial_storage_usage;

        // If there's some price for the token, we'll payout the series owner. Otherwise, refund the excess deposit for storage to the caller
        if price_per_token > 0 {
            payout_series_owner(required_storage_in_bytes, price_per_token, series.owner_id);
        } else {
            refund_deposit(required_storage_in_bytes);
        }
    }
}

'''
'''--- nft-tutorial/package.json ---
{
    "name": "nft-tutorial",
    "version": "1.0.0",
    "description": "Zero to Hero NFT Tutorial",
    "author": "Ben Kurrek",
    "license": "ISC",
    "scripts": {
        "build": "cd nft-contract && bash build.sh && cd .. && ls && cd market-contract && bash build.sh && cd .. && cd nft-series && bash build.sh && cd ..",
        "test": "npm run test:unit && npm run test:integration",
            "test:unit": "npm run test:unit:nft && npm run test:unit:market",
                "test:unit:nft": "cd nft-contract && cargo test -- --nocapture --color=always && cd ..",
                "test:unit:market": "cd market-contract && cargo test -- --nocapture --color=always && cd ..",
            "test:integration": "npm run test:integration:ts && npm run test:integration:rs",
                "test:integration:ts": "cd integration-tests/ts && npm i && npm run test",
                "test:integration:rs": "cd integration-tests/rs && cargo run --example integration-tests"
    }
}

'''