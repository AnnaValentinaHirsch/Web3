*GitHub Repository "mervanerenci/2ND-Hand-Music"*

'''--- README.md ---
# Second Hand Music
Welcome to Second Hand Music. You can sell or buy used music products on blockchain like microphones here.

*NOTE FOR NCD LOOM VIDEO:*
*there was a problem causing the createMidi function not to work properly. createMic was working so i didnt noticed at the first sight. In the loom video i didnt noticed that too. The problem was on the model.ts , i forgot to write @Nearbindgen to Midis class. I fixed it. I hope you can review this accordingly.*

*Note 2: Updated Contract, added few more instruments and products.*
## Deploying Smart Contract
### Build
First, login your testnet account with:
    
    near login
    

Step-1

Clone the repo
    
    
    

Step-2:
    
    yarn
    

    
    yarn build:release
    

    
    near dev-deploy ./build/release/simple.wasm
    

 Now you will see an id looks like "dev-123-456"

Step-3: 
    
    export CONTRACT=<your dev-id>
    

### InApp commands
 
- near call createMics/createMidis : create product
- near view getMics/getMidis : view products
- near view getMicsbyname/getMidisbyname : view specific Mics or Midis via name
- near call purchaseMidisbyname/purchaseMicsbyname : buy Midis or Mics via name
- You can buy, sell, view ; Mics, Midis, Drums, Keyboards, Guitars, Mixers, Monitors and Interfaces.
 

 *Creating Mics*
    
    near call $CONTRACT createMics '{"name":" ","price":" ","brand":" ","stock":" ", "condition":" ", "explanation":" "}' --accountId $CONTRACT 
 
 *Creating Other Products*
    
    near call $CONTRACT createKeyboards '{"name":" ","price":" ","brand":" ","stock":" ", "condition":" ", "explanation":" "}' --accountId $CONTRACT
                              Monitors 
                              Mixers
                              Drums
                              Interfaces
                              Guitars 
                              Midis
 
 *Viewing Products*
    
    near view $CONTRACT getMics '{"offset": 0}' /// near view $CONTRACT getMidis '{"offset": 0}'

 *Getting Products by Id*

    near view $CONTRACT getMidisbyId '{"id":}' --accountId $CONTRACT

 *Purchase Products*

    near call $CONTRACT purchaseMicsbyId '{"id":""}' --accountId $CONTRACT --amount <amount here>

    near call $CONTRACT purchaseMidisbyId '{"id":""}' --accountId $CONTRACT --amount <amount here>

Feel free to explore !!

    

'''
'''--- as-pect.config.js ---
module.exports = require("near-sdk-as/imports");
module.exports.include.push("**/*.unit.spec.ts");

'''
'''--- asconfig.json ---
{
  "workspaces": [
    "src/simple",
    "src/singleton"
  ]
}

'''
'''--- package.json ---
{
  "name": "starter--near-sdk-as",
  "version": "0.0.1",
  "description": "Start with a basic project",
  "scripts": {
    "dev": "watch -d -n 1 'clear && yarn test'",
    "test": "yarn asp -f unit.spec",
    "clean": "rm -rf ./build && rm -rf ./neardev",
    "build": "asb --target debug",
    "build:release": "asb",
    "asp": "asp --verbose --nologo"
  },
  "keywords": [],
  "author": "hello@near.org",
  "license": "ISC",
  "devDependencies": {
    "near-sdk-as": "^3.1.0"
  }
}

'''
'''--- scripts/2ndhandmusic.sh ---
#!/bin/bash
echo "deleting $CONTRACT"
echo
near delete $CONTRACT

echo ---------------------------------------
echo 
echo
echo "cleaning up the /neardev folder"
echo
echo
rm -rf ./neardev

set -e

yarn

echo
echo
echo

echo
echo ---------------------------------------
echo
echo "rebuilding"
echo
echo
yarn build:release

echo ---------------------------------------
echo
echo "redeploying the contract"
echo
near dev-deploy ./build/release/simple.wasm

echo ---------------------------------------
echo
echo "run the following command"
echo
echo "export CONTRACT=dev-12345..."
echo

exit 0

'''
'''--- scripts/createproducts.sh ---
#!/bin/bash

echo "example Midi creating"
echo 
echo 
near call $CONTRACT createMidis '{"name":"v-mini","price":"10","brand":"alesis","stock":1}' --accountId $CONTRACT
echo -----------------------------------------
echo "Midi has been created"
echo -----------------------------------------
echo
echo
echo
near call $CONTRACT createMidis '{"name":"mpk mini 2","price":"8","brand":"Akai","stock":2}' --accountId $CONTRACT
echo -----------------------------------------
echo -----------------------------------------
echo
echo
echo
echo "1 more Midi added"
echo -----------------------------------------
echo -----------------------------------------
echo
echo
echo
near call $CONTRACT createMics '{"name":"beehive","price":"4","brand":"bee","stock":1, "condition":"new", "explanation": "Closed pack"}' --accountId $CONTRACT
echo "Mics has been created"
echo -----------------------------------------
echo -----------------------------------------
echo
echo
echo
near call $CONTRACT createKeyboards '{"name":"c5","price":"10","brand":"KORG","stock":1, "condition": "used", "explanation": "I bought this keys 3 years ago. Have few scratches."}' --accountId $CONTRACT
echo -----------------------------------------
echo -----------------------------------------
echo
echo
echo "1 Keyboard Added"

'''
'''--- scripts/getMics.sh ---
echo 
echo ------------------------------------
near view $CONTRACT getMics '{"offset": 0}'
echo ------------------------
echo 
'''
'''--- scripts/getMidis.sh ---
echo 
echo ------------------------------------
near view $CONTRACT getMidis '{"offset": 0}'
echo ------------------------
echo 
'''
'''--- scripts/purchase.sh ---
echo 
echo ----------
echo 
echo
near call $CONTRACT purchaseMidisbyid '{"id":"1182899087"}' --accountId $CONTRACT --amount 1
echo 
echo
echo
echo -------
near call $CONTRACT purchaseMicsbyid '{"id":"88992913"}' --accountId $CONTRACT --amount 1
'''
'''--- src/as_types.d.ts ---
/// <reference types="near-sdk-as/assembly/as_types" />
'''
'''--- src/simple/__tests__/as-pect.d.ts ---
/// <reference types="@as-pect/assembly/types/as-pect" />
'''
'''--- src/simple/__tests__/index.unit.spec.ts ---
import * as contract from "../assembly";

describe("Contract", () => {
  // VIEW method tests

  it("says hello", () => {
    expect(contract.helloWorld()).toStrictEqual("hello world")
  })

  it("reads data", () => {
    expect(contract.read("some key")).toStrictEqual("🚫 Key [ some key ] not found in storage. ( storage [ 0 bytes ] )")
  })

  // CHANGE method tests

  it("saves data to contract storage", () => {
    expect(contract.write("some-key", "some value")).toStrictEqual("✅ Data saved. ( storage [ 18 bytes ] )")
  })
})

'''
'''--- src/simple/asconfig.json ---
{
  "extends": "near-sdk-as/asconfig.json"
}

'''
'''--- src/simple/assembly/index.ts ---
import { context, u128 } from "near-sdk-as";
import { Mics, Midis, Drums, Keyboards, Guitars, Mixers, Monitors, Interfaces,  alldrums, allmics, allmidis, allguitars, allinterfaces, allkeyboards, allmixers, allmonitors } from "./model";

/* Midis Start */

export function createMidis( name: string,  price: u128, brand: string, stock: u8): Midis {
  assert(price != u128.Zero, "This discount may not be welcomed by the bosses!")
  return Midis.addMidis( name, price, brand, stock);

}

export function getMidis(offset: u32, limit: u32 = 5): Midis[] {
  return Midis.findMidis(offset, limit)
}

export function getMidisbyId(id: u32): Midis {
  return Midis.findMidisbyId(id)
}

export function purchaseMidisbyId(id:u32): number{
  const midis = allmidis.getSome(id)
  assert(context.attachedDeposit>=midis.price,"You have insufficient balance")
  
  if (context.attachedDeposit>=midis.price) {  
    midis.stock = midis.stock -1
  }
  return midis.stock
  }

/* Midis End */

/* Mics Start */

export function createMics(name: string, price: u128, brand: string, stock: u8, condition: string, explanation: string): Mics {
  assert(price != u128.Zero, "This discount may not be welcomed by the bosses!")
  return Mics.addMics( name, price, brand, stock, condition, explanation);

}

export function getMics(offset: u32, limit: u32 = 5): Mics[] {
  return Mics.findMics(offset, limit)
}

export function getMicsbyId(id: u32): Mics {
  return Mics.findMicsbyId(id)
}

export function purchaseMicsbyId(id:u32): number{
const mics = allmics.getSome(id)
assert(context.attachedDeposit>=mics.price,"You have insufficient balance")

if (context.attachedDeposit>=mics.price) {  
  mics.stock = mics.stock -1
}
return mics.stock
}

/* Mics End */

/* Drums Start */
export function createDrums(name: string, price: u128, brand: string, stock: u8, condition: string, explanation: string): Drums {
  assert(price != u128.Zero, "This discount may not be welcomed by the bosses!")
  return Drums.addDrums( name, price, brand, stock, condition, explanation);

}

export function getDrums(offset: u32, limit: u32 = 5): Drums[] {
  return Drums.findDrums(offset, limit)
}

export function getDrumsbyId(id: u32): Drums {
  return Drums.findDrumsbyId(id)
}

export function purchaseDrumsbyId(id:u32): number{
const drums = alldrums.getSome(id)
assert(context.attachedDeposit>=drums.price,"You have insufficient balance")

if (context.attachedDeposit>=drums.price) {  
  drums.stock = drums.stock -1
}
return drums.stock
}

/* Drums End */

/* Guitars Start */
export function createGuitars(name: string, price: u128, brand: string, stock: u8, condition: string, explanation: string): Guitars {
  assert(price != u128.Zero, "This discount may not be welcomed by the bosses!")
  return Guitars.addGuitars( name, price, brand, stock, condition, explanation);

}

export function getGuitars(offset: u32, limit: u32 = 5): Guitars[] {
  return Guitars.findGuitars(offset, limit)
}

export function getGuitarsbyId(id: u32): Guitars {
  return Guitars.findGuitarsbyId(id)
}

export function purchaseGuitarsbyId(id:u32): number{
const guitars = allguitars.getSome(id)
assert(context.attachedDeposit>=guitars.price,"You have insufficient balance")

if (context.attachedDeposit>=guitars.price) {  
  guitars.stock = guitars.stock -1
}
return guitars.stock
}

/* Guitars End */

/* Keyboards Start */
export function createKeyboards(name: string, price: u128, brand: string, stock: u8, condition: string, explanation: string): Keyboards {
  assert(price != u128.Zero, "This discount may not be welcomed by the bosses!")
  return Keyboards.addKeyboards( name, price, brand, stock, condition, explanation);

}

export function getKeyboards(offset: u32, limit: u32 = 5): Keyboards[] {
  return Keyboards.findKeyboards(offset, limit)
}

export function getKeyboardsbyId(id: u32): Keyboards {
  return Keyboards.findKeyboardsbyId(id)
}

export function purchaseKeyboardsbyId(id:u32): number{
const keyboards = allkeyboards.getSome(id)
assert(context.attachedDeposit>=keyboards.price,"You have insufficient balance")

if (context.attachedDeposit>=keyboards.price) {  
  keyboards.stock = keyboards.stock -1
}
return keyboards.stock
}
/* Keyboards End */

/* Interfaces Start */
export function createInterfaces(name: string, price: u128, brand: string, stock: u8, condition: string, explanation: string): Interfaces {
  assert(price != u128.Zero, "This discount may not be welcomed by the bosses!")
  return Interfaces.addInterfaces( name, price, brand, stock, condition, explanation);

}

export function getInterfaces(offset: u32, limit: u32 = 5): Interfaces[] {
  return Interfaces.findInterfaces(offset, limit)
}

export function getInterfacesbyId(id: u32): Interfaces {
  return Interfaces.findInterfacesbyId(id)
}

export function purchaseInterfacesbyId(id:u32): number{
const interfaces = allinterfaces.getSome(id)
assert(context.attachedDeposit>=interfaces.price,"You have insufficient balance")

if (context.attachedDeposit>=interfaces.price) {  
  interfaces.stock = interfaces.stock -1
}
return interfaces.stock
}
/* Interfaces End */

/* Mixers Start */
export function createMixers(name: string, price: u128, brand: string, stock: u8, condition: string, explanation: string): Mixers {
  assert(price != u128.Zero, "This discount may not be welcomed by the bosses!")
  return Mixers.addMixers( name, price, brand, stock, condition, explanation);

}

export function getMixers(offset: u32, limit: u32 = 5): Mixers[] {
  return Mixers.findMixers(offset, limit)
}

export function getMixersbyId(id: u32): Mixers {
  return Mixers.findMixersbyId(id)
}

export function purchaseMixersbyId(id:u32): number{
const mixers = allmixers.getSome(id)
assert(context.attachedDeposit>=mixers.price,"You have insufficient balance")

if (context.attachedDeposit>=mixers.price) {  
  mixers.stock = mixers.stock -1
}
return mixers.stock
}
/* Mixers End */

/* Monitors Start */
export function createMonitors(name: string, price: u128, brand: string, stock: u8, condition: string, explanation: string): Monitors {
  assert(price != u128.Zero, "This discount may not be welcomed by the bosses!")
  return Monitors.addMonitors( name, price, brand, stock, condition, explanation);

}

export function getMonitors(offset: u32, limit: u32 = 5): Monitors[] {
  return Monitors.findMonitors(offset, limit)
}

export function getMonitorsbyId(id: u32): Monitors {
  return Monitors.findMonitorsbyId(id)
}

export function purchaseMonitorsbyId(id:u32): number{
const monitors = allmonitors.getSome(id)
assert(context.attachedDeposit>=monitors.price,"You have insufficient balance")

if (context.attachedDeposit>=monitors.price) {  
  monitors.stock = monitors.stock -1
}
return monitors.stock
}
/* Monitors End */

'''
'''--- src/simple/assembly/model.ts ---
import { context, math,  u128,  PersistentUnorderedMap } from "near-sdk-as";
import { AccountId} from "../../utils";

/* Product Holders */

export let allmics = new PersistentUnorderedMap<u32, Mics>('mic')
export let allmidis = new PersistentUnorderedMap<u32, Midis>('midi')
export let alldrums = new PersistentUnorderedMap<u32, Drums>('drum')
export let allguitars = new PersistentUnorderedMap<u32, Guitars>('guitar')
export let allinterfaces = new PersistentUnorderedMap<u32, Interfaces>('interface')
export let allkeyboards = new PersistentUnorderedMap<u32, Keyboards>('keyboard')
export let allmonitors = new PersistentUnorderedMap<u32, Monitors>('monitor')
export let allmixers = new PersistentUnorderedMap<u32, Mixers>('mixer')

/* Mics Start */

@nearBindgen

export class Mics {
    id: u32
    user: AccountId = context.sender
    name: string
    price: u128
    brand: string
    stock: u8
    condition: string
    explanation : string
    constructor(name: string,  price: u128, brand: string, stock: u8, condition:string, explanation:string) {
        this.id = math.hash32<string>(name)
        this.price = price
        this.brand = brand
        this.stock = stock
        this.name = name
        this.condition = condition
        this.explanation = explanation
    }

    static addMics(name: string,price: u128, brand: string, stock: u8, condition: string, explanation: string): Mics {
        const mics = new Mics(name, price, brand, stock, condition, explanation);
        allmics.set(mics.id, mics)
        return mics;
    }

    static findMics(offset: u32, limit: u32): Mics[] {
        return allmics.values(offset, offset + limit)
    }

    static findMicsbyId(id: u32): Mics {
        return allmics.getSome(id);
    }

}

/* Mics End */

/* Midis Start */ 

@nearBindgen

export class Midis {
    id: u32
    user: AccountId = context.sender
    name: string
    price: u128
    brand: string
    stock: u8
    constructor(name: string,  price: u128, brand: string, stock: u8) {
        this.id = math.hash32<string>(name)
        this.price = price
        this.brand = brand
        this.stock = stock
        this.name = name
    }

    static addMidis(name: string,price: u128, brand: string, stock: u8): Midis {
        const midis = new Midis(name, price, brand, stock);
        allmidis.set(midis.id, midis)
        return midis;
    }

    static findMidis(offset: u32, limit: u32): Midis[] {
        return allmidis.values(offset, offset + limit)
    }

    static findMidisbyId(id: u32): Midis {
        return allmidis.getSome(id);
    }

}

/* Drums Start */
@nearBindgen

export class Drums {
    id: u32
    user: AccountId = context.sender
    name: string
    price: u128
    brand: string
    stock: u8
    condition: string
    explanation : string
    constructor(name: string,  price: u128, brand: string, stock: u8, condition:string, explanation:string) {
        this.id = math.hash32<string>(name)
        this.price = price
        this.brand = brand
        this.stock = stock
        this.name = name
        this.condition = condition
        this.explanation = explanation
    }

    static addDrums(name: string,  price: u128, brand: string, stock: u8, condition:string, explanation:string): Drums{
        const drums = new Drums(name, price, brand, stock, condition, explanation);
        alldrums.set(drums.id, drums)
        return drums;
    }

    static findDrums(offset: u32, limit: u32): Drums[] {
        return alldrums.values(offset, offset + limit)
    }

    static findDrumsbyId(id: u32): Drums {
        return alldrums.getSome(id);
    }

}

/* Drums End */

/* Guitars Start */
@nearBindgen
export class Guitars {
    id: u32
    user: AccountId = context.sender
    name: string
    price: u128
    brand: string
    stock: u8
    condition: string
    explanation: string
    constructor(name: string,  price: u128, brand: string, stock: u8, condition:string, explanation:string) {
        this.id = math.hash32<string>(name)
        this.price = price
        this.brand = brand
        this.stock = stock
        this.name = name
        this.condition = condition
        this.explanation = explanation
    }

    static addGuitars(name: string,  price: u128, brand: string, stock: u8, condition:string, explanation:string): Guitars{
        const guitars = new Guitars(name, price, brand, stock, condition, explanation);
        allguitars.set(guitars.id, guitars)
        return guitars;
    }

    static findGuitars(offset: u32, limit: u32): Guitars[] {
        return allguitars.values(offset, offset + limit)
    }

    static findGuitarsbyId(id: u32): Guitars {
        return allguitars.getSome(id);
    }

}

/* Guitars End */

/* Keyboards Start */
@nearBindgen
export class Keyboards {
    id: u32
    user: AccountId = context.sender
    name: string
    price: u128
    brand: string
    stock: u8
    condition: string
    explanation : string
    constructor(name: string,  price: u128, brand: string, stock: u8, condition:string, explanation:string) {
        this.id = math.hash32<string>(name)
        this.price = price
        this.brand = brand
        this.stock = stock
        this.name = name
        this.condition = condition
        this.explanation = explanation
    }

    static addKeyboards(name: string,  price: u128, brand: string, stock: u8, condition:string, explanation:string): Keyboards{
        const keyboards = new Keyboards(name, price, brand, stock, condition, explanation);
        allkeyboards.set(keyboards.id, keyboards)
        return keyboards;
    }

    static findKeyboards(offset: u32, limit: u32): Keyboards[] {
        return allkeyboards.values(offset, offset + limit)
    }

    static findKeyboardsbyId(id: u32): Keyboards {
        return allkeyboards.getSome(id);
    }

}

/* Keyboards End */

/* Interfaces Start */
@nearBindgen
export class Interfaces {
    id: u32
    user: AccountId = context.sender
    name: string
    price: u128
    brand: string
    stock: u8
    condition: string
    explanation : string
    constructor(name: string,  price: u128, brand: string, stock: u8, condition:string, explanation:string) {
        this.id = math.hash32<string>(name)
        this.price = price
        this.brand = brand
        this.stock = stock
        this.name = name
        this.condition = condition
        this.explanation = explanation
    }

    static addInterfaces(name: string,  price: u128, brand: string, stock: u8, condition:string, explanation:string): Interfaces{
        const interfaces = new Interfaces(name, price, brand, stock, condition, explanation);
        allinterfaces.set(interfaces.id, interfaces)
        return interfaces;
    }

    static findInterfaces(offset: u32, limit: u32): Interfaces[] {
        return allinterfaces.values(offset, offset + limit)
    }

    static findInterfacesbyId(id: u32): Interfaces {
        return allinterfaces.getSome(id);
    }

}

/* Interfaces End */

/* Mixers Start */
@nearBindgen
export class Mixers {
    id: u32
    user: AccountId = context.sender
    name: string
    price: u128
    brand: string
    stock: u8
    condition: string
    explanation : string
    constructor(name: string,  price: u128, brand: string, stock: u8, condition:string, explanation:string) {
        this.id = math.hash32<string>(name)
        this.price = price
        this.brand = brand
        this.stock = stock
        this.name = name
        this.condition = condition
        this.explanation = explanation
    }

    static addMixers(name: string,  price: u128, brand: string, stock: u8, condition:string, explanation:string): Mixers{
        const mixers = new Mixers(name, price, brand, stock, condition, explanation);
        allmixers.set(mixers.id, mixers)
        return mixers;
    }

    static findMixers(offset: u32, limit: u32): Mixers[] {
        return allmixers.values(offset, offset + limit)
    }

    static findMixersbyId(id: u32): Mixers {
        return allmixers.getSome(id);
    }

}

/* Mixers End */

/* Monitors Start */
@nearBindgen
export class Monitors {
    id: u32
    user: AccountId = context.sender
    name: string
    price: u128
    brand: string
    stock: u8
    condition: string
    explanation : string
    constructor(name: string,  price: u128, brand: string, stock: u8, condition:string, explanation:string) {
        this.id = math.hash32<string>(name)
        this.price = price
        this.brand = brand
        this.stock = stock
        this.name = name
        this.condition = condition
        this.explanation = explanation
    }

    static addMonitors(name: string,  price: u128, brand: string, stock: u8, condition:string, explanation:string): Monitors{
        const monitors = new Monitors(name, price, brand, stock, condition, explanation);
        allmonitors.set(monitors.id, monitors)
        return monitors;
    }

    static findMonitors(offset: u32, limit: u32): Monitors[] {
        return allmonitors.values(offset, offset + limit)
    }

    static findMonitorsbyId(id: u32): Monitors {
        return allmonitors.getSome(id);
    }

}

/* Monitors End */

'''
'''--- src/singleton/__tests__/as-pect.d.ts ---
/// <reference types="@as-pect/assembly/types/as-pect" />
'''
'''--- src/singleton/__tests__/index.unit.spec.ts ---
import { Contract } from "../assembly";

let contract: Contract

beforeEach(() => {
  contract = new Contract()
})

describe("Contract", () => {
  // VIEW method tests

  it("says hello", () => {
    expect(contract.helloWorld()).toStrictEqual("hello world")
  })

  it("reads data", () => {
    expect(contract.read("some key")).toStrictEqual("🚫 Key [ some key ] not found in storage. ( storage [ 0 bytes ] )")
  })

  // CHANGE method tests

  it("saves data to contract storage", () => {
    expect(contract.write("some-key", "some value")).toStrictEqual("✅ Data saved. ( storage [ 18 bytes ] )")
  })
})

'''
'''--- src/singleton/asconfig.json ---
{
  "extends": "near-sdk-as/asconfig.json"
}

'''
'''--- src/singleton/assembly/index.ts ---
import { storage, Context } from "near-sdk-core"

@nearBindgen
export class Contract {
  private message: string = 'hello world'

  // return the string 'hello world'
  helloWorld(): string {
    return this.message
  }

  // read the given key from account (contract) storage
  read(key: string): string {
    if (isKeyInStorage(key)) {
      return `✅ Key [ ${key} ] has value [ ${storage.getString(key)!} ] and "this.message" is [ ${this.message} ]`
    } else {
      return `🚫 Key [ ${key} ] not found in storage. ( ${this.storageReport()} )`
    }
  }

  /**
  write the given value at the given key to account (contract) storage
  ---
  note: this is what account storage will look like AFTER the write() method is called the first time
  ╔════════════════════════════════╤══════════════════════════════════════════════════════════════════════════════════╗
  ║                            key │ value                                                                            ║
  ╟────────────────────────────────┼──────────────────────────────────────────────────────────────────────────────────╢
  ║                          STATE │ {                                                                                ║
  ║                                │   "message": "data was saved"                                                    ║
  ║                                │ }                                                                                ║
  ╟────────────────────────────────┼──────────────────────────────────────────────────────────────────────────────────╢
  ║                       some-key │ some value                                                                       ║
  ╚════════════════════════════════╧══════════════════════════════════════════════════════════════════════════════════╝
   */
  @mutateState()
  write(key: string, value: string): string {
    storage.set(key, value)
    this.message = 'data was saved' // this is why we need the deorator @mutateState() above the method name
    return `✅ Data saved. ( ${this.storageReport()} )`
  }

  // private helper method used by read() and write() above
  private storageReport(): string {
    return `storage [ ${Context.storageUsage} bytes ]`
  }
}

/**
 * This function exists only to avoid a compiler error
 *

ERROR TS2339: Property 'contains' does not exist on type 'src/singleton/assembly/index/Contract'.

     return this.contains(key);
                 ~~~~~~~~
 in ~lib/near-sdk-core/storage.ts(119,17)

/Users/sherif/Documents/code/near/_projects/edu.t3/starter--near-sdk-as/node_modules/asbuild/dist/main.js:6
        throw err;
        ^

 * @param key string key in account storage
 * @returns boolean indicating whether key exists
 */
function isKeyInStorage(key: string): bool {
  return storage.hasKey(key)
}

'''
'''--- src/tsconfig.json ---
{
  "extends": "../node_modules/assemblyscript/std/assembly.json",
  "include": ["./**/*.ts"]
}

'''
'''--- src/utils.ts ---
import { u128, Context, ContractPromise } from "near-sdk-as";

/**
 * == TYPES ====================================================================
 */

/**
 * Account IDs in NEAR are just strings.
 */
export type AccountId = string;

/**
 * Gas is u64
 */
export type Gas = u64;

/**
 * Amounts, Balances, and Money in NEAR is are u128.
 */

export type Amount = u128;

export type Balance = Amount;

export type Money = Amount;

/**
 * Timestamp in NEAR is a number.
 */
export type Timestamp = u64;

/**
 * == CONSTANTS ================================================================
 *
 * ONE_NEAR = unit of NEAR token in yocto Ⓝ (1e24)
 * XCC_GAS = gas for cross-contract calls, ~5 Tgas (teragas = 1e12) per "hop"
 * MIN_ACCOUNT_BALANCE = 3 NEAR min to keep account alive via storage staking
 *
 * TODO: revist MIN_ACCOUNT_BALANCE after some real data is included b/c this
 *  could end up being much higher
 */

export const ONE_NEAR = u128.from("1000000000000000000000000");
export const XCC_GAS: Gas = 20_000_000_000_000;
export const MIN_ACCOUNT_BALANCE: u128 = u128.mul(ONE_NEAR, u128.from(3));

/**
 * == FUNCTIONS ================================================================
 */

/**
 * @function asNEAR
 * @param amount {u128} - Yocto Ⓝ token quantity as an unsigned 128-bit integer
 * @returns {string}    - Amount in NEAR, as a string
 *
 * @example
 *
 *    asNEAR(7000000000000000000000000)
 *    // => '7'
 */
export function asNEAR(amount: u128): string {
  return u128.div(amount, ONE_NEAR).toString();
}

/**
 * @function toYocto
 * @param amount {number} - Integer to convert
 * @returns {u128}        - Amount in yocto Ⓝ as an unsigned 128-bit integer
 *
 * @example
 *
 *    toYocto(7)
 *    // => 7000000000000000000000000
 */
export function toYocto(amount: number): u128 {
  return u128.mul(ONE_NEAR, u128.from(amount))
}

/**
 * Function to assert that the contract has called itself
 */
export function assert_self(): void {
  const caller = Context.predecessor
  const self = Context.contractName
  assert(caller == self, "Only this contract may call itself");
}

export function assert_single_promise_success(): void {
  const x = ContractPromise.getResults()
  assert(x.length == 1, "Expected exactly one promise result")
  assert(x[0].succeeded, "Expected PromiseStatus to be successful")
}

'''