*GitHub Repository "near/near-stats"*

'''--- .eslintrc.json ---
{
  "extends": "next/core-web-vitals"
}

'''
'''--- CONTRIBUTING.md ---
# Contributing to NEAR Explorer

Thank you for your interest in contributing to NEAR! There are many opportunities to contribute:
https://docs.near.org/docs/community/contribute/contribute-overview

## Feature Requests

To request a change to the way the NEAR Stats language works, please head over to the issues
page on Github and file an issue.

## Bug Reports

While bugs are unfortunate, they're a reality in software. We can't fix what we don't know about,
so please report liberally. If you're not sure if something is a bug or not, feel free to file a
bug anyway.

## Pull Requests

Pull requests are the primary mechanism we use to change NEAR projects. GitHub itself has some
[great documentation](https://help.github.com/articles/about-pull-requests/) on using the Pull
Request feature. We use the "fork and pull" model
[described here](https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/about-collaborative-development-models),
where contributors push changes to their personal fork and create pull requests to bring those
changes into the source repository.

Please make pull requests against the `master` branch.

GitHub allows closing issues using keywords. This feature should be used to keep the issue tracker
tidy. However, it is generally preferred to put the "closes #123" text in the PR description
rather than the issue commit; particularly during rebasing, citing the issue number in the commit
can "spam" the issue in question.

Once Pull Request is ready and reviewed by the code owners, it gets squashed into a single commit,
where the commit message should follow
[Conventional Commits](https://commonwealth.im/near/proposal/discussion/264-the-commit-template)
style.
'''
'''--- README.md ---
# NEAR Stats
Welcome to the NEAR Stats Repo.

NEAR Stats is a dashboard to track the growth of apps on the NEAR Platform. The data behind the NEAR Stats Project comes from the [NEAR Analytics](https://github.com/near/near-analytics) Database for aggregated data, and the [NEAR Ecosystem Repo](https://github.com/near/ecosystem) for app data. Alongside the dashboard is an API that provides that data behind all of the NEAR Stats visualizations.
    
Please visit the [API Wiki](../../wiki/API) for API Documentation.
Details of the structure and code for the dashboard can be found in the [Front End Wiki](../../wiki/Front-end).

# Running NEAR Stats
## Environment Variables
Environment variables required for connection to the NEAR Analytics database are required in a ```.env``` file. An example of the required variables are included in the [.env-example](.env-example). This file can be renamed ```.env```, however the credentials should be checked against the [NEAR Analytics](https://github.com/near/near-analytics) Repo.
  
## Running NEAR Stats Locally
NEAR Stats is developed using [Next.js](https://nextjs.org/). To install the dependencies needed for the project, run ```yarn```.
The project can be ran in development mode using ```yarn dev``` or alternatively in production mode with ```yarn build``` followed by ```yarn start```.

## Additional Dependencies
### Redis Cache Server
A Redis Caching Server is highly recommended to improve loadings time and load on the NEAR Analytics Database. Running NEAR Stats without a Redis Caching Server is possible without any additional modification however queries to the NEAR Analytics Database may be blocked during times of high volume. The Redis Caching Server will cache all results for a period of 24 hours.
  
#### Redis Installation Mac
The following terminal commands will install and run a local Redis Server on a Mac. Additional information and instructions for alternative systems can be found on the [Redis Website](https://redis.io/).
  
```
mkdir redis && cd redis
curl -O http://download.redis.io/redis-stable.tar.gz
tar xzvf redis-stable.tar.gz
cd redis-stable
make
make test
sudo make install
redis-server
```

#### Flushing Redis server cache
In the event you would like to clear the cached database results, the following results will flush (reset) the cache. 
```redis-cli FLUSHDB```

# DOCKER
The following steps will build a docker container that will automatically run the NEAR Stats dashboard and Redis server.

## Install Docker
Download [Docker Desktop](https://www.docker.com/products/docker-desktop) and ensure it is open and running to start the docker daemon.

## Docker Build
```docker build -t nearstats .```

## Docker Start
The docker container can be started from Docker Desktop
Run the image and set the local host port to 3000
visit http://localhost:3000 in your browser.

# Contributing

To contribute to NEAR Stats, please see [CONTRIBUTING](CONTRIBUTING.md).

# License

NEAR Stats is distributed under the terms of both the MIT license and the Apache License (Version 2.0).

See [LICENSE-MIT](LICENSE-MIT) and [LICENSE-APACHE](LICENSE-APACHE) for details.
'''
'''--- components/Background.js ---
import React from 'react'
import styles from '../styles/Background.module.scss'

export default function Background() {
  return (
    <>
      <div 
        className={styles.ovalContainer}>
        <div style={{width:'25%'}}>
          <div className={styles.ovalLeft}></div>
        </div>
        <div style={{width:'25%'}}>
          <div className={styles.ovalRight}></div>
        </div>
      </div>
    </>
  )
}

'''
'''--- components/Footer.js ---
import styles from '../styles/Footer.module.scss'
import React from 'react'

// sticky footer for report a bug button
export default function Footer({ }) {

  return (
    <div className={styles.footerContainer} >
        <div className={styles.bugButton} ><a href="https://github.com/datacult/near-stats/issues" target='_blank' rel="noreferrer">Report a bug</a></div>
    </div>
  )
}

'''
'''--- components/Graphcard.js ---
import React from 'react'
import styles from '../styles/Graphcard.module.scss'
import Select from 'react-select'
import CreatableSelect from 'react-select/creatable';
import Switch from "react-switch"
import canvasCapture from '../helpers/2dCanvasCapture'

export default function GraphCard({ icon, title, children, size = "full", setSelect, label_type, setLabel, dateCompare, placeholder }) {

  const elementRef = React.useRef();

  //declare handlers
  //save screenshot
  const handleCaptureClick = () => {
    canvasCapture(title, elementRef.current)
  }
  
  // set list for goals and milestones
  const handleGoals = (event) => {
    let goal_list = []
    event.forEach(d => goal_list.push(d.value))
    setSelect(goal_list)
    
  };
  
  // percentage switch for barChart
  const [checked, setChecked] = React.useState(false);
  const handleLabel = () => {
    setChecked(!checked)
    if (label_type === 'Number') {
      setLabel('Percent')
    } else {
      setLabel('Number')
    }
  };
  
  // set view for areaChart
  const handleDetail = (event) => {
    setSelect(event.value)
  }

  let dropdown, dynamic_title
  //set the dropdown menu and title based on the card title
  if (title === 'Total NEAR Accounts' || title === 'Top NEAR Apps') {
    dropdown =
      <CreatableSelect
        isMulti
        className={styles.react_select_container}
        classNamePrefix={"react_select"}
        isClearable={false}
        components={{
          IndicatorSeparator: () => null
        }}
        noOptionsMessage={() =>"Type to add"}
        placeholder={placeholder}
        onChange={handleGoals}
        options={[]}
        instanceId={title}
      />

    dynamic_title = title + ' (' + dateCompare + ' Day Growth)'
  } else if (title === 'Total NEAR Accounts by App' || title === 'NEAR Account Growth By App') {
    dropdown =
      <Select
        className={styles.react_select_container}
        classNamePrefix={"react_select"}
        isSearchable={false}
        isClearable={false}
        components={{
          IndicatorSeparator: () => null
        }}
        defaultValue={{ value: false, label: 'Overview' }}
        onChange={handleDetail}
        options={[{ value: false, label: 'Overview' }, { value: true, label: 'Top 10' }]}
        instanceId={title}
      />
    dynamic_title = title + ' (Last ' + dateCompare + ' Days)'
  } else {
    // no dropdown or compare period for table
    dropdown = ''
    dynamic_title = title
  }

  let label_switch
  // define switch for barChart
  if (title === 'Top NEAR Apps') {
    label_switch = <Switch
      checked={checked}
      onChange={handleLabel}
      onHandleColor="#5F8AFA"
      offHandleColor="#A463B0"
      onColor="#E5E5E5"
      offColor="#E5E5E5"
      uncheckedIcon={false}
      checkedIcon={false}
      uncheckedHandleIcon={<div
        style={{
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          color: 'white',
          fontSize: '.9em'
        }}>
        %
      </div>}
      checkedHandleIcon={<div
        style={{
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          color: 'white',
          fontSize: '.9em'
        }}>
        #
      </div>}
      height={20}
      handleDiameter={20}
      width={35}
    />
  } else {
    // no switch for other graphs
    label_switch = ''
  }

  return (
    <>
    <div ref={elementRef} className={`${styles.cardContainer} ${size}`}>
      <div className={styles.cardInner}>
        <div className="global-flex-container">
          <div className="global-flex-inner global-flex-inner-left">
            <img src={icon} className={styles.cardlogo} />
            <h3>
              {dynamic_title}
            </h3>
          </div>
          <div className="global-flex-inner global-flex-inner-right" data-html2canvas-ignore="">
            {dropdown}
            <div className="global-spacer"></div>
            <button className={styles.iconButton} onClick={handleCaptureClick}>
              <img src='/images/share-2share.png' className={styles.share} />
            </button>
          </div>
        </div>
        <div className={`${styles.switchContainer}`} data-html2canvas-ignore="">
          {label_switch}
        </div>
        <div>
          {children}
        </div>
      </div>
    </div>
    </>
  )
}

'''
'''--- components/Header.js ---
import React from 'react'
import styles from '../styles/Header.module.scss'
import Switch from "react-switch"
import Select from 'react-select'
import { setTheme } from '../helpers/theme';

export default function Header({ setDateCompare, setNetwork, setChecked, checked }) {

  //declare date compares
  const handleChange = (event) => {
    setDateCompare(event.value)
  }
  
  //declare React Hooks and handlers
  //dark mode
  const handleDarkMode = (event) => {
    setChecked(event);
    event ? setTheme('theme-dark') : setTheme('theme-light');
  };
  
  //network
  const handleNetwork = (event) => {
    setNetwork(event.value)
  }
  
  //declare network connections
  const connections = [
    {
      value: 'mainnet',
      text: 'Mainnet',
      icon: <></>
    }
  ]

  return (
    <div className={styles.headerContainer}>
      <div className={`global-flex-inner ${styles.flexInnerLeft}`}>
        <a href="http://near.org" target="_blank" rel="noreferrer"><img src={"/images/logo_nm.svg"} className={styles.nearlogo} /></a>
        <div className="global-spacer"></div>
        <Select
          className={styles.react_select_container}
          classNamePrefix={"react_select"}
          isSearchable={false}
          isClearable={false}
          components={{
            IndicatorSeparator: () => null
          }}
          defaultValue={connections[0]}
          options={connections}
          onChange={handleNetwork}
          getOptionLabel={e => (
            e.text === 'Mainnet' ?
              <div className={styles.networkItem}>
                <div className={styles.badge}></div><span> </span>{e.text}<span> </span><img src="/images/signal.svg" width={10} height={11.25}></img>
              </div>
              :
              <div className={styles.networkItem}>
                {e.text}
              </div>
          )}
          instanceId={'network'}
        />
      </div>

      <div className="title-container">
        <div className={styles.title} align="center">
          MOMENTUM
        </div>
      </div>

      <div className={`global-flex-inner ${styles.flexInnerRight}`}>
        <Select
          className={styles.react_select_container}
          classNamePrefix={"react_select"}
          isSearchable={false}
          isClearable={false}
          components={{
            IndicatorSeparator: () => null
          }}
          defaultValue={{ value: 30, label: '30 Days' }}
          onChange={handleChange}
          options={[{ value: 30, label: '30 Days' }, { value: 60, label: '60 days' }, { value: 90, label: '90 days' }]}
          instanceId={'range'}
        />
        <div className="global-spacer"></div>
        <div className={styles.switchContainer}>
        <Switch
            checked={checked}
            onChange={handleDarkMode}
            onColor='#8796A5'
            offColor='#aab4be'
            onHandleColor="#003892"
            offHandleColor="#001e3c"
            handleDiameter={32}
            uncheckedHandleIcon={
              <svg xmlns="http://www.w3.org/2000/svg" height="40" width="40" viewBox="-6 -6 40 40">
                <path fill="#ffffff" d="M9.305 1.667V3.75h1.389V1.667h-1.39zm-4.707 1.95l-.982.982L5.09 6.072l.982-.982-1.473-1.473zm10.802 0L13.927 5.09l.982.982 1.473-1.473-.982-.982zM10 5.139a4.872 4.872 0 00-4.862 4.86A4.872 4.872 0 0010 14.862 4.872 4.872 0 0014.86 10 4.872 4.872 0 0010 5.139zm0 1.389A3.462 3.462 0 0113.471 10a3.462 3.462 0 01-3.473 3.472A3.462 3.462 0 016.527 10 3.462 3.462 0 0110 6.528zM1.665 9.305v1.39h2.083v-1.39H1.666zm14.583 0v1.39h2.084v-1.39h-2.084zM5.09 13.928L3.616 15.4l.982.982 1.473-1.473-.982-.982zm9.82 0l-.982.982 1.473 1.473.982-.982-1.473-1.473zM9.305 16.25v2.083h1.389V16.25h-1.39z"/>
              </svg>
            }
            uncheckedIcon={false}
            checkedHandleIcon={
              <svg xmlns="http://www.w3.org/2000/svg" height="40" width="40" viewBox="-6 -6 40 40">
                <path fill="#ffffff" d="M4.2 2.5l-.7 1.8-1.8.7 1.8.7.7 1.8.6-1.8L6.7 5l-1.9-.7-.6-1.8zm15 8.3a6.7 6.7 0 11-6.6-6.6 5.8 5.8 0 006.6 6.6z"/>
              </svg>
            }
            checkedIcon={false}
            boxShadow="0px 1px 1px rgba(0, 0, 0, 0.6)"
            activeBoxShadow="0px 0px 1px 1px rgba(0, 0, 0, 0.2)"
            height={20}
            width={40}
            className="react-switch"
            id="material-switch"
          />
        </div>
      </div>
    </div>
  )
}

'''
'''--- components/areaChart.js ---
import React from "react";
import * as d3 from "d3";
import { formatNumbers } from '../helpers/formatNumbers';

function AreaChart({ account_data = [], app_data = [], x = '_x', y = '_y', compare = 30, growth = false, detail }) {

    // calculate dates
    let dateExtent = d3.extent(account_data, d => new Date(d[x]));
    let startDate = d3.timeDay.offset(dateExtent[1], -compare)

    // sort data in chronological order
    account_data.sort((a, b) => new Date(a[x]) > new Date(b[x]) ? 1 : -1)
    app_data.sort((a, b) => new Date(a[x]) > new Date(b[x]) ? 1 : -1)

    const svgRef = React.useRef();

    // declare margins
    const margin = {
        left: 100,
        right: 100,
        top: 20,
        bottom: 50
    }

    // base width & height. All other calculations based on this value
    const svgWidth = 700
    const svgHeight = 300

    // helper calculated variables for inner width & height
    const height = svgHeight - margin.top - margin.bottom
    const width = svgWidth - margin.left - margin.right

    // will be called initially and on every data change
    React.useEffect(() => {

        // filter data for compare period start date
        account_data = account_data.filter(d => new Date(d[x]) > startDate)
        app_data = app_data.filter(d => new Date(d[x]) > startDate)

        // rollup up the app data to a single total
        let app_total_data = d3.rollups(app_data, v => d3.sum(v, d => d[y]), d => d[x])

        // combine the data for stacking, reducing the account total for each day by the amount of accounts in the top 10 apps.
        let combined_data = {}

        app_total_data.forEach(d => {
            let date = d[0].split('T')[0]
            combined_data[date] = { [x]: date, 'other': 0, 'top apps': detail ? 0 : d[1] }
        })

        account_data.forEach(d => {
            let date = d[x].split('T')[0]
            if (!combined_data.hasOwnProperty(date)) {
                combined_data[date] = { [x]: date, 'other': detail ? 0 : parseInt(d[y]), 'top apps': 0 }
            } else {
                combined_data[date]['other'] = detail ? 0 : parseInt(d[y]) - combined_data[date]['top apps']
            }
        })

        combined_data = Object.values(combined_data)

        let app_detail = app_data.map(d => ({ ...d, [y]: detail ? d[y] : d[y] }))

        // set d3 references
        const svg = d3.select(svgRef.current)
        const svgContent = svg.select(".content");

        var stackedData = d3.stack()
            .keys(['other', 'top apps'])
            (combined_data)

        // calculate growth
        if (growth == true) {
            let other_start = stackedData[0][0][1]
            let app_start = stackedData[1][0][1]

            for (let i = 0; i < stackedData[0].length; i++) {
                stackedData[0][i][1] = (stackedData[0][i][1] - other_start > 0) ? stackedData[0][i][1] - other_start : 0
                stackedData[1][i][0] = (stackedData[1][i][0] - other_start > 0 ) ? stackedData[1][i][0] - other_start : 0

                stackedData[1][i][1] = stackedData[1][i][1] - app_start
            }
        }

        let other_apps_line_data = stackedData[0].map(d => ({[x]: d.data[x], [y] : detail ? 0 : d[1]}) )
        let top_apps_line_data = stackedData[1].map(d => ({[x]: d.data[x], [y] : detail ? 0 : d[1]}) )

        var stacked_apps = d3.groups(app_detail, d => d.entity_id)

        if (growth == true){
            stacked_apps.forEach(app => {
                let start = app[1][0][y]
                app[1].forEach(d => {
                    d[y] = d[y] - start
                })
            })
        }

        // time scale for X axis
        const xScale = d3.scaleTime()
            .range([0, width])
            .domain([startDate, d3.max(account_data, d => new Date(d[x]))])

        // Linear scale for Overview
        const yScale = d3.scaleLinear()
            .range([height, 0])
            .domain([0, d3.max(stackedData[1], d => d[1])])

        // Linear scale for Top 10 view
        const appYscale = d3.scaleLinear()
            .range([height, 0])
            .domain([0, d3.max(stacked_apps.map(d => d[1]).flat(), d => d[y])])

        // generator for svg path
        const lineGenerator = d3.line()
            .x(d => xScale(new Date(d[x])))
            .y(d => yScale(d[y]))
            .curve(d3.curveMonotoneX)

        const appLineGenerator = d3.line()
            .x(d => xScale(new Date(d[x])))
            .y(d => appYscale(d[y]))
            .curve(d3.curveMonotoneX)

        // Generators svg area
        const areaGenerator = d3.area()
            .x(d => xScale(new Date(d.data[x])))
            .y0(d => yScale(d[0]))
            .y1(d => yScale(d[1]))
            .curve(d3.curveMonotoneX)

        const t = d3.transition()
            .duration(500)

        // draw stacked area chart
        svgContent
            .selectAll(".current-area")
            .data(stackedData)
            .join("path")
            .attr("class", "current-area transition-all")
            .attr("stroke", "none")
            .attr("fill", (d, i) => i === 0 ? "url(#gradient-bottom)" : "url(#gradient-top)")
            .attr("d", areaGenerator)

        // add All Other Apps line
        svgContent
            .selectAll(".other-apps-data-line")
            .data([other_apps_line_data])
            .join("path")
            .attr("class", "other-apps-data-line transition-all")
            .attr("stroke", "#3EAAB7")
            .attr("stroke-width", 3)
            .attr("fill", "none")
            .attr("stroke-opacity", detail ? 0 : 1)
            .attr("stroke-linecap", "round")
            .attr("d", lineGenerator);

        // add Top 10 apps line
        svgContent
            .selectAll(".top-apps-data-line")
            .data([top_apps_line_data])
            .join("path")
            .attr("class", "top-apps-data-line transition-all")
            .attr("stroke", "#9B83FD")
            .attr("stroke-width", 3)
            .attr("fill", "none")
            .attr("stroke-opacity", detail ? 0 : 1)
            .attr("stroke-linecap", "round")
            .attr("d", lineGenerator);

        // Overview Tooltip
        // create all other apps tooltip
        var other_app_tooltip = svgContent.append("g")
            .attr("class", "area-tooltip")
            .style("display", "none");

        // draw indicator circle
        other_app_tooltip.append("circle")
            .attr("r", 5)
            .attr('fill','#3EAAB7');

        // draw tooltip box
        other_app_tooltip.append("rect")
            .attr('class',"tooltip-box")
            .attr("x", 9)
            .attr("y", -2)
            .attr("height",25)
            .attr('fill','white')
            .attr('rx','5px');

        // add tooltip text
        other_app_tooltip.append("text")
            .attr("x", 15)
            .attr("dy", "1.05em")
            .style("font-size",15);

        // create top 10 apps tooltip
        var top_app_tooltip = svgContent.append("g")
            .attr("class", "area-tooltip")
            .style("display", "none");

        // draw indicator circle
        top_app_tooltip.append("circle")
            .attr("r",5)
            .attr('fill','#9B83FD');

        // draw tooltip box
        top_app_tooltip.append("rect")
            .attr('class',"tooltip-box")
            .attr("x", 9)
            .attr("y", -23)
            .attr("height",25)
            .attr('rx','5px');

        // add tooltip text
        top_app_tooltip.append("text")
            .attr("x", 15)
            .attr("dy", "-.35em")
            .style("font-size",15);

        // draw box for hovering
        svgContent.append("rect")
            .attr("class", "overlay")
            .attr("width", width)
            .attr("height", height)
            .style('fill','none')
            .style('pointer-events','all')
            .on("mouseover", function() {
                other_app_tooltip.style("display", detail ? "none" : null)
                top_app_tooltip.style("display", detail ? "none" : null)
            })
            .on("mouseout", function() {
                other_app_tooltip.style("display", "none");
                top_app_tooltip.style("display", "none");
            })
            .on("mousemove", mousemove);
        
        // transform tooltip placement and text based on hover position
        function mousemove(event) {
            
            var hover_date = xScale.invert(d3.pointer(event)[0]),
                other_data_point = other_apps_line_data.find( ({ collected_for_day }) => collected_for_day === hover_date.toISOString().split('T')[0]),
                top_data_point = top_apps_line_data.find( ({ collected_for_day }) => collected_for_day === hover_date.toISOString().split('T')[0]);
            
            if (other_data_point){
            var y_value=parseFloat(other_data_point['total_accounts']);
            other_app_tooltip.attr("transform", "translate(" + xScale(new Date(other_data_point.collected_for_day)) + "," + yScale(y_value)+ ")"); 
            other_app_tooltip.select("text").text(formatNumbers(y_value));
            other_app_tooltip.select("rect").attr('width',other_app_tooltip.select("text").node().getComputedTextLength()+12)
            }

            if (top_data_point){
            var y_value=parseFloat(top_data_point['total_accounts']);
            top_app_tooltip.attr("transform", "translate(" + xScale(new Date(top_data_point.collected_for_day)) + "," + yScale(y_value)+ ")"); 
            top_app_tooltip.select("text").text(formatNumbers(y_value));
            top_app_tooltip.select("rect").attr('width',top_app_tooltip.select("text").node().getComputedTextLength()+12)
            }

        }

        // Top 10 View
        // create group for line and label
        var top_app_group = svgContent
            .selectAll('.app-label-group')
            .data(stacked_apps)
            .join('g')
            .attr("class", "app-label-group")
            .attr("id",d => 'groupid'+d[0]);
            

        // move group to front to enable visibility
        d3.selection.prototype.moveToFront = function() {
                return this.each(function(){
                  this.parentNode.appendChild(this);
                });
              };

        // control visibility of group
        svgContent
            .selectAll(".app-label-group")
            .attr("opacity", detail ? 1 : 0)
            .attr("stroke-opacity", detail ? .4 : 0)
            .on("mouseover", function (t) {
                d3.selectAll(".app-label-group").attr("stroke-opacity",.1)
                d3.selectAll(".app-label-text").attr("opacity",.4)
                d3.select(this).attr("stroke-opacity",1).select(".app-label-text").attr("opacity",1)
                d3.select(this).moveToFront()
            })
            .on("mouseout", function (t) {
                // d3.select(this).attr("stroke-opacity",.1)
                d3.selectAll(".app-label-group").attr("stroke-opacity",.4)
                d3.selectAll(".app-label-text").attr("opacity",1)
            });

        // draw line
        top_app_group
            .selectAll("path")
            .data(d => [d])
            .join("path")
            .attr("class", "app-data-line")
            .attr("stroke", "#985FD0")
            .attr("stroke-width", 3)
            .attr("fill", "none")
            .attr("stroke-linecap", "round")
            .attr("d", d => appLineGenerator(d[1]))

        // draw label box
        top_app_group
            .selectAll("rect")
            .data(d => [d])
            .join("rect")
            .attr('x', d => xScale(new Date(d[1][d[1].length - 1][x])) + 5)
            .attr('y', d => appYscale(d[1][d[1].length - 1][y])-10)
            .attr('height', 20)
            .attr('rx', 10)
            .attr("class", "app-label-box")
            .attr("stroke", "#985FD0")
            .attr("stroke-width", 2)
            .attr('fill','currentcolor')
        
        // add label text
        top_app_group
            .selectAll("text")
            .data(d => [d])
            .join("text")
            .attr('x', d => xScale(new Date(d[1][d[1].length - 1][x])) + 10)
            .attr('y', d => appYscale(d[1][d[1].length - 1][y]))
            .text(d => d[0])
            .attr('dominant-baseline', 'middle')
            .attr('class', 'app-label-text')
            .attr('id',d => 'id'+d[0])
            .attr('font-size', '0.7em')
        
        // resize box to fit label
        top_app_group
            .selectAll('rect')
            .attr('width',d => top_app_group.select("#id"+d[0]).node().getComputedTextLength()+10);

        // axes
        // scale x axis
        const xAxis = d3.axisBottom(xScale).ticks(3);

        // draw x axis
        svg
            .select(".x-axis")
            .attr("transform", `translate(0, ${height})`)
            .attr('font-family', 'manrope')
            .call(xAxis)
            .call(g => g.select(".domain").remove())
            .call(g => g.select(".tick line").remove())

        // scale y axis for overview and top 10
        const yAxis = d3.axisLeft(yScale).ticks(5);
        const appYaxis = d3.axisLeft(appYscale).ticks(3);

        // draw applicable y axis
        svg
            .select(".y-axis")
            .call(detail ? appYaxis : yAxis)
            .attr('font-family', 'manrope')
            .attr('font-size', '0.7em')
            .call(g => g.selectAll(".tick>line").remove())
            .call(g => g.select(".domain").remove());

        // draw grid lines
        svg
            .select(".y-axis")
            .append('g')
            .attr('class', 'y-grid')
            .call(detail ? appYaxis.tickSize(-width).tickFormat("") : yAxis.tickSize(-width).tickFormat(""))
            .call(g => g.select(".domain").remove())
            .call(g => g.selectAll(".tick>line")
                .attr("stroke", "#757575")
                .attr('opacity', .2))

        // draw legend boxes
        const size = 10

        svg.selectAll('.top-app-box')
            .data([0])
            .join("rect")
            .attr('class','top-app-box')
            .attr("x",margin.left)
            .attr("y",height+55)
            .attr("width", size)
            .attr("height", size)
            .style("fill", detail ? "none" : "#9B83FD")

        svg.selectAll('.other-app-box')
            .data([0])
            .join("rect")
            .attr('class','other-app-box')
            .attr("x",margin.left+100)
            .attr("y",height+55)
            .attr("width", size)
            .attr("height", size)
            .style("fill", "#3EAAB7")
            .attr("opacity", detail ? 0 : 1)

        // add legend text
        svg.selectAll('.top-app-text')
            .data([0])
            .join("text")
            .attr('class','top-app-text')
            .attr("x",margin.left+15)
            .attr("y", height+61)
            .text("Top 10 Apps")
            .style("font-size", "0.7em")
            .attr("alignment-baseline","middle")
            .attr("opacity", detail ? 0 : 1)

        svg.selectAll('.other-app-text')
            .data([0])
            .join("text")
            .attr('class','other-app-text')
            .attr("x", margin.left+115)
            .attr("y", height+61)
            .text("All Other Apps")
            .style("font-size", "0.7em")
            .attr("alignment-baseline","middle")
            .attr("opacity", detail ? 0 : 1)

        
        // load the watermark in as data
        d3.xml("/images/logo_nm.svg").then(watermark => {

            // use d3 join to ensure that additional watermarks are not continuously added.
            svg
            .selectAll('.watermark')
            .data([0])
            .join('g')
            .html('') // need to empty the group as React does not play well with append.
            .attr('class','watermark watermark-top')
            .node()
            .append(watermark.documentElement);

            // set attributes of watermark
            d3.selectAll('.watermark-top svg')
            .attr("y", 40)
            .attr("x",125)
            .attr("height",20*1.5)
            .attr("width",76*1.5)
            .attr('opacity', 0.1)
        })
    }, [account_data, app_data, detail, height, width, x, y, compare]);

    return (
        <React.Fragment>
            <div>
                <svg ref={svgRef} width="100%" viewBox={'0 0 ' + svgWidth + ' ' + svgHeight}>
                    <defs>
                        <linearGradient id="gradient-top" x1="100%" y1="100%" x2="100%" y2="0%">
                            <stop offset="0%" stopColor="#8776EE" stopOpacity="0.1" />
                            <stop offset="100%" stopColor="#8684F8" stopOpacity="1" />
                        </linearGradient>
                        <linearGradient id="gradient-bottom" x1="100%" y1="100%" x2="100%" y2="0%">
                            <stop offset="0%" stopColor="#8896DF" stopOpacity="0.1" />
                            <stop offset="100%" stopColor="#9FD0DB" stopOpacity="1" />
                        </linearGradient>
                    </defs>
                    <g transform={'translate(' + margin.left + ',' + margin.top + ')'}>
                        <g className="x-axis" />
                        <g className="y-axis" />
                        <g className="content" />
                        <g className="non-clip-content" />
                    </g>
                </svg>
            </div>
        </React.Fragment>
    );
}

export default AreaChart;
'''
'''--- components/barChart.js ---
import React from 'react';
import * as d3 from "d3";
import numeral from "numeral";
import { formatNumbers } from '../helpers/formatNumbers';

function Barchart({ data = [], app_data = [], x = '_x', y = '_y', compare = `accounts_30_days_ago`, label_type, goals, setTooltip}) {

    const svgRef = React.useRef();

    let app_lookup = {}
    app_data.forEach(d => app_lookup[d.slug] = d)

    // sort data
    data.sort((a, b) => d3.descending(a[x], b[x]))

    // filter data to include only top 10
    data = data.filter((d, i) => i < 10)

    // sort top 10
    data.sort((a, b) => d3.ascending(a[x], b[x]))

    data.forEach(d => {
        if (!d.hasOwnProperty(compare)) d[compare] = 0
    })

    // margins for SVG
    const margin = {
        left: 200,
        right: 50,
        top: 20,
        bottom: 75
    }

    // responsive width & height
    const svgWidth = 750
    const svgHeight = 425

    // helper calculated variables for inner width & height
    const height = svgHeight - margin.top - margin.bottom
    const width = svgWidth - margin.left - margin.right

    React.useEffect(() => {
        //number formatting function
        function formatNumber(x) {
            return x.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
        }

        // set d3 references
        const svg = d3.select(svgRef.current);
        const svgContent = svg.select(".content");
        const defs = svg.select("defs");

        // Linear scale for x-axis
        const xScale = d3.scaleLinear()
            .range([0, width])
            .domain([0, d3.max(data, d => d[x])])

        // Scale for y-axis
        const yScale = d3.scaleBand()
            .range([height, 0])
            .domain(data.map(d => d[y])).padding(0.1)

        const createTickLabel = (d) => {
            return app_lookup[d].title
        }

        // axes
        // scale y-axis
        const yAxis = d3.axisLeft(yScale).tickFormat(createTickLabel).tickPadding(70);

        // draw y-axis
        svg
            .select(".y-axis")
            .call(yAxis)
            .attr('font-family', 'manrope')
            .attr('font-size', '0.7em')
            .call(g => g.selectAll(".tick>line").remove())
            .call(g => g.select(".domain").remove());

        // scale x-axis
        const xAxis = d3.axisBottom(xScale);

        // draw x-axis
        svg
            .select(".x-axis")
            .attr("transform", `translate(0, ${height})`)
            .attr('font-family', 'manrope')
            .attr('font-size', '0.7em')
            .call(xAxis)
            .call(g => g.select(".domain").attr("stroke", "#CFCFCF"))
            .call(g => g.selectAll(".tick>line").attr("stroke", "#CFCFCF"))

        // draw x-axis gridlines
        svg
            .select(".x-axis")
            .append('g')
            .attr('class', 'x-grid')
            .call(xAxis.tickSize(-height).tickFormat(""))
            .call(g => g.select(".domain").remove())
            .call(g => g.selectAll(".tick>line")
                .attr("stroke", "#CFCFCF")
                .attr("stroke-dasharray", 10)
                .attr('opacity', .5))
            .call(g => g.select(".tick>line").remove())

        // draw y-axis gridlines
        svg
            .select(".y-axis")
            .append('g')
            .attr('class', 'y-grid')
            .call(yAxis.tickSize(-width).tickFormat(""))
            .call(g => g.select(".domain").remove())
            .call(g => g.selectAll(".tick>line")
                .attr("stroke", "#CFCFCF")
                .attr('opacity', .3))

        // draw pre-growth bar with tooltip on hover
        svgContent
            .selectAll(".pre-growth-bar")
            .data(data)
            .join('rect')
            .attr('x', 0)
            .attr('y', d => yScale(d[y]))
            .attr('height', yScale.bandwidth())
            .attr('width', d => xScale(d[x]) - (xScale(d[x] - d[compare])))
            .attr("class", "pre-growth-bar transition-all")
            .attr("stroke", "none")
            .attr("fill", "url(#bar-gradient)")
            .attr("opacity", 1)
            .on("mouseover", (event,d) => {
                let data = {
                    [app_lookup[d.entity_id].title]:"",
                    'Total Accounts' : formatNumber(d.total_accounts),
                    [`Created in the Last ${compare.split('_')[1]} Days`] : formatNumber(d[x] - d[compare])
                }
                setTooltip({visible:true, data:data, x: event.pageX, y: event.pageY})
            })
            .on("mouseout", (event,d) => {
                setTooltip({visible:false, data:{}, x: event.pageX, y: event.pageY})
            })

        // draw growth bar with tooltip on hover
        svgContent
            .selectAll(".growth-bar")
            .data(data)
            .join('rect')
            .attr('x', d => xScale(d[x]) - (xScale(d[x] - d[compare])))
            .attr('y', d => yScale(d[y]))
            .attr('height', yScale.bandwidth())
            .attr('width', d => xScale(d[x] - d[compare]))
            .attr("class", "growth-bar transition-all")
            .attr("stroke", "none")
            .attr("fill", "#7FADBC")
            .on("mouseover", (event,d) => {
                let data = {
                    [app_lookup[d.entity_id].title]:"",
                    'Total Accounts' : formatNumber(d.total_accounts),
                    [`Created in the Last ${compare.split('_')[3]} Days`] : formatNumber(d[x] - d[compare])
                }
                setTooltip({visible:true, data:data, x: event.pageX, y: event.pageY})
            })
            .on("mouseout", (event,d) => {
                setTooltip({visible:false, data:{}, x: event.pageX, y: event.pageY})
            })

        function growth(total, added) {
            if (added) {
                return `+ ${Math.floor((total - added) / added * 100)}`
            } else { return ' - ' }
            }

        // add growth %/# label to end of bar
        svgContent
            .selectAll(".growth-text")
            .data(data)
            .join('text')
            .attr('x', d => xScale(d[x])+ 5)
            .attr('y', d => yScale(d[y]) + yScale.bandwidth() / 2 + 4)
            .text(d => label_type === 'Percent' ? growth(d[x],d[compare]) + '%' : '+'+formatNumber(d[x]-d[compare]))
            .attr('class', 'growth-text')
            .attr('font-size', '0.7em')
            .attr('text-anchor', 'left') 

        // add logos
        // set logo diameter
        const logo_size=25

        // create mask for logos
        defs
            .selectAll(".logo-clip")
            .data(Array.from(new Set(data.map(d => d[y]))))
            .join("mask")
            .attr("id", d => "logo-clip-" + d)
            .attr('class', 'logo-clip')
            .append("circle")
            .attr("cx", logo_size/2)
            .attr("cy", logo_size/2)
            .attr("r", logo_size/2)
            .attr('fill','white')

        // add in logos with mask
        var logo = svg.selectAll(".logo")
            .data(Array.from(new Set(data.map(d => d[y]))))
            .join('a')
            .attr('class', 'logo')
            .attr('href',d => app_lookup[d].website)
            .attr('target','_blank')
            .append('image')
            .attr("x", 0)
            .attr("y", 0)
            .attr("width", logo_size)
            .attr("height", logo_size)
            .attr("href", d => app_lookup[d].logo)
            .attr("data-html2canvas-ignore", "") // svg cross site origin images for supported by html2canvas
            .attr("mask", d => "url(#logo-clip-" + d + ")")
            .attr("transform", d => "translate(" + '150' + "," + (yScale(d)+20) + ")")

        // goals
        const goal_list=[]
        goals.forEach(g => 
            goal_list.push(numeral(g.toLowerCase())._value)
            )
            
        // draw goal line
        svgContent
            .selectAll(".goal-line")
            .data(goal_list)
            .join('line')
            .attr('x1', d => xScale(d))
            .attr('y1', 0)
            .attr('x2', d => xScale(d))
            .attr('y2', height)
            .attr('class', 'goal-line')
            .attr('stroke', "#FFFFFF")

        // draw label box
        svgContent
            .selectAll(".goal-label-box")
            .data(goal_list)
            .join('rect')
            .attr('x', d => xScale(d) - 20)
            .attr('y', height + 24)
            .attr('width', 40)
            .attr('height', 20)
            .attr('rx', 10)
            .attr("class", "goal-label-box")
            .attr("stroke", "#A066B5")
            .attr("stroke-width", 2)
            .attr("fill", "none")

        // add label text
        svgContent
            .selectAll(".goal-label-text")
            .data(goal_list)
            .join('text')
            .attr('x', d => xScale(d))
            .attr('y', height + 35)
            .text(d => formatNumbers(d))
            .attr('dominant-baseline', 'middle')
            .attr('text-anchor', 'middle')
            .attr('class', 'goal-label-text')
            .attr('fill', '#A066B5')
            .attr('font-size', '0.7em')

        // draw legend boxes
        const size = 10
        
        svg.selectAll('.pre-growth-legend-box')
            .data([0])
            .join("rect")
            .attr('class','pre-growth-legend-box')
            .attr("x",margin.left)
            .attr("y",height+70)
            .attr("width", size)
            .attr("height", size)
            .style("fill", "url(#bar-gradient)")

        svg.selectAll('.growth-legend-box')
            .data([0])
            .join("rect")
            .attr('class','growth-legend-box')
            .attr("x",margin.left+190)
            .attr("y",height+70)
            .attr("width", size)
            .attr("height", size)
            .style("fill", "#7FADBC")

        // set text for dynamic growth legend text
        let compare_text
        if (compare === 'accounts_30_days_ago') {
            compare_text = '30 days'
        } else if (compare === 'accounts_60_days_ago') {
            compare_text = '60 days'
        } else {
            compare_text = '90 days'
        } 

        // add legend text
        svg.selectAll('.pre-growth-legend-text')
            .data([0])
            .join("text")
            .attr('class','pre-growth-legend-text')
            .attr("x",margin.left+15)
            .attr("y", height+76)
            .text("Previously Created Accounts")
            .style("font-size", "0.7em")
            .attr("alignment-baseline","middle")

        svg.selectAll('.growth-legend-text')
            .data([0])
            .join("text")
            .attr('class','growth-legend-text')
            .attr("x", margin.left+205)
            .attr("y", height+76)
            .text("Accounts Created in the Last "+compare_text)
            .style("font-size", "0.7em")
            .attr("alignment-baseline","middle")

        // load the watermark in as data
        d3.xml("/images/logo_nm.svg").then(watermark => {

            // use d3 join to ensure that additional watermarks are not continuously added.
            svg
            .selectAll('.watermark')
            .data([0])
            .join('g')
            .html('') // need to empty the group as React does not play well with append.
            .attr('class','watermark watermark-bottom')
            .node()
            .append(watermark.documentElement);

            // set attributes of watermark
            d3.selectAll('.watermark-bottom svg')
            .attr("y", height-50)
            .attr("x",width+55)
            .attr("height",20*1.5)
            .attr("width",76*1.5)
            .attr('opacity', 0.1)
        })

    });

    return (
        <React.Fragment>
            <svg ref={svgRef} width="100%" viewBox={'0 0 ' + svgWidth + ' ' + svgHeight}>
                <defs>
                </defs>
                <linearGradient id="bar-gradient" x1="0" y1="100%" x2="100%" y2="100%">
                    <stop offset="0%" stopColor="#D7D9ED" stopOpacity="1" />
                    <stop offset="100%" stopColor="#C4DFE5" stopOpacity="1" />
                </linearGradient>
                <g transform={'translate(' + margin.left + ',' + margin.top + ')'}>
                    <g className="x-axis" />
                    <g className="y-axis" />
                    <g className="content" />
                </g>
            </svg>
        </React.Fragment>
    )
}

export default Barchart;
'''
'''--- components/brushChart.js ---
import React from 'react';
import * as d3 from "d3";
import usePrevious from "./usePrevious";
import { regressionPoly } from 'd3-regression';

function BrushChart({ data = [], x = '_x', y = '_y', children }) {

    // set hooks
    const svgRef = React.useRef();
    const isInitialMount = React.useRef(true);
    const [prediction_data, setPredictionData] = React.useState([]);
    const [selection, setSelection] = React.useState();
    
    let dateExtent = d3.extent(data, d => new Date(d[x]));

    // calculate regression only on initial load
    if (isInitialMount.current) {
        // Regression generator
        const regressionGenerator = regressionPoly()
        .x(d => new Date(d.collected_for_day))
        .y(d => d.total_accounts)

        // Calculate future prediction based on regression
        let regression = regressionGenerator(data)
        let prediction_date = d3.timeDay.offset(new Date(), 90)
        let prediction = regression.predict(prediction_date)
        let regression_data = [...data]
        regression_data.push({ 'collected_for_day': prediction_date.toISOString(), 'total_accounts': prediction })
     
       setPredictionData(regression_data)
       setSelection([dateExtent[0], prediction_date]);
       isInitialMount.current = false;
    }

    // define margins
    const margin = {
        left: 110,
        right: 70,
        top: 0,
        bottom: 50
    }

    // base width & height. All other calculations based on this value
    const svgWidth = 700
    const svgHeight = 95

    // helper calculated variables for inner width & height
    const height = svgHeight - margin.top - margin.bottom
    const width = svgWidth - margin.left - margin.right

    // calculate forecast date
    let prediction_date = d3.max(prediction_data, d => new Date(d[x]))
    
    // define previous selection
    const previousSelection = usePrevious(selection);

    // will be called initially and on every data change
    React.useEffect(() => {
        const svg = d3.select(svgRef.current);
        const svgContent = svg.select(".content");

        // time scale for X axis
        const xScale = d3.scaleTime()
            .range([0, width])
            .domain([dateExtent[0], prediction_date])

        // Linear scale for counts
        const yScale = d3.scaleLinear()
            .range([height, 0])
            .domain([0, d3.max(prediction_data, d => d[y])])

        // generator for svg path
        const lineGenerator = d3.line()
            .x(d => xScale(new Date(d[x])))
            .y(d => yScale(d[y]))
            .curve(d3.curveMonotoneX)

        // Generators svg area
        const areaGenerator = d3.area()
            .x(d => xScale(new Date(d[x])))
            .y0(d => yScale(0))
            .y1(d => yScale(d[y]))
            .curve(d3.curveMonotoneX)

        // draw line for current data
        svgContent
            .selectAll(".brush-current-data-line")
            .data([data])
            .join("path")
            .attr("class", "brush-current-data-line")
            .attr("stroke", "#7D7D7D")
            .attr("stroke-width", 3)
            .attr("fill", "none")
            .attr("stroke-linecap", "round")
            .attr("d", lineGenerator);

        // draw area chart for current data
        svgContent
            .selectAll(".brush-current-data-area")
            .data([data])
            .join("path")
            .attr("class", "brush-current-data-area")
            .attr("stroke", "none")
            .attr("fill", "url(#brush-gradient)")
            .attr("d", areaGenerator);

        // draw line for prediction data
        svgContent
            .selectAll(".brush-prediction-data-line")
            .data([prediction_data])
            .join("path")
            .attr("class", "brush-prediction-data-line")
            .attr("stroke", "#7D7D7D")
            .attr("stroke-width", 2)
            .attr("stroke-dasharray", 4)
            .attr("fill", "none")
            .attr("stroke-linecap", "round")
            .attr("d", lineGenerator);

        // axes
        // define y-axis
        const yAxis = d3.axisLeft(yScale);

        // draw y-axis
        svg
            .select(".y-axis")
            .call(yAxis)
            .call(g => g.selectAll(".tick").remove())
            .call(g => g.select(".domain").attr("stroke", "#7D7D7D"));

        // define x-axis
        const xAxis = d3.axisBottom(xScale);

        // draw x-axis
        svg
            .select(".x-axis")
            .attr("transform", `translate(0, ${height})`)
            .attr('font-family','manrope')
            .call(xAxis)
            .call(g => g.select(".domain").attr("stroke", "#7D7D7D"))
            .call(g => g.selectAll(".tick>line").remove());

        // create brush
        const brush = d3.brushX()
            .extent([
                [0, 0],
                [width, height]
            ])
            .on("start brush end", (event) => {
                if (event.selection) {
                    const indexSelection = event.selection.map(xScale.invert);
                    setSelection(indexSelection);
                }
            });

        // set initial position + retaining position on resize
        if (previousSelection === selection || previousSelection === undefined) {
            svg
                .select(".brush")
                .call(brush)
                .call(brush.move, selection.map(xScale));
        }
    });

    return (
        <React.Fragment>
            {children({ selection, data, prediction_data })}
            <div>
                <svg ref={svgRef} width="100%" viewBox={'0 0 ' + svgWidth + ' ' + svgHeight}>
                    <linearGradient id="brush-gradient" x1="100%" y1="100%" x2="100%" y2="0%">
                        <stop offset="0%" stopColor="#3A7584" stopOpacity="0.12" />
                        <stop offset="100%" stopColor="#2C606D" stopOpacity="0.54" />
                    </linearGradient>
                    <g transform={'translate(' + margin.left + ',' + margin.top + ')'}>
                        <g className="content" />
                        <g className="brush" />
                        <g className="x-axis" />
                        <g className="y-axis" />
                    </g>
                </svg>
            </div>
        </React.Fragment>
    );
}

export default BrushChart;
'''
'''--- components/brushedAreaChart.js ---
import React from "react";
import * as d3 from "d3";
import numeral from "numeral";
import { formatNumbers } from '../helpers/formatNumbers';

function BrushedAreaChart({ data = [], prediction_data = [], x = '_x', y = '_y', compare = 30, goals = [2000000], selection }) {

    const svgRef = React.useRef();

    // declare margins
    const margin = {
        left: 110,
        right: 70,
        top: 20,
        bottom: 50
    }

    // base width & height. All other calculations based on this value
    const svgWidth = 700
    const svgHeight = 300

    // helper calculated variables for inner width & height
    const height = svgHeight - margin.top - margin.bottom
    const width = svgWidth - margin.left - margin.right

    // will be called initially and on every data change
    React.useEffect(() => {
        
        // data extents
        let dateExtent = d3.extent(data, d => new Date(d[x]));
        let growthStart = d3.timeDay.offset(dateExtent[1], -compare);
        let growthStartValue = data.find(d => new Date(d[x]) >= growthStart)[y]
        let growthEndValue = data[data.length - 1][y]
        let percentChange = (growthEndValue - growthStartValue) / growthStartValue
        let xAxisMax = d3.timeDay.offset(dateExtent[1], 90)
        let prediction = prediction_data[prediction_data.length - 1][y]

        // set d3 references
        const svg = d3.select(svgRef.current)
        const svgContent = svg.select(".content");
        const svgNoClip = svg.select(".non-clip-content");

        // time scale for X axis
        const xScale = d3.scaleTime()
            .range([0, width])
            .domain(selection)

        // Linear scale for counts
        const yScale = d3.scaleLinear()
            .range([height, 0])
            .domain([0, prediction])

        // generator for svg path
        const lineGenerator = d3.line()
            .x(d => xScale(new Date(d[x])))
            .y(d => yScale(d[y]))
            .curve(d3.curveMonotoneX)

        // Generators svg area
        const areaGenerator = d3.area()
            .x(d => xScale(new Date(d[x])))
            .y0(d => yScale(0))
            .y1(d => yScale(d[y]))
            .curve(d3.curveMonotoneX)

        // draw area graph for current data
        svgContent
            .selectAll(".current-area")
            .data([data])
            .join("path")
            .attr("class", "current-area")
            .attr("stroke", "none")
            .attr("fill", "url(#gradient)")
            .attr("d", areaGenerator);

        // draw area graph for prediction data
        svgContent
            .selectAll(".prediction-area")
            .data([prediction_data])
            .join("path")
            .attr("class", "prediction-area")
            .attr("stroke", "none")
            .attr("fill", "url(#gradient)")
            .attr("fill-opacity", 0.5)
            .attr("d", areaGenerator);

        // draw line for prediction data
        svgContent
            .selectAll(".predict-data-line")
            .data([prediction_data])
            .join("path")
            .attr("class", "predict-data-line")
            .attr("stroke", "#A066B5")
            .attr("stroke-width", 2)
            .attr("stroke-dasharray", 4)
            .attr("fill", "none")
            .attr("stroke-linecap", "round")
            .attr("d", lineGenerator);

        // draw line for current data
        svgContent
            .selectAll(".current-data-line")
            .data([data])
            .join("path")
            .attr("class", "current-data-line")
            .attr("stroke", "#A066B5")
            .attr("stroke-width", 3)
            .attr("fill", "none")
            .attr("stroke-linecap", "round")
            .attr("d", lineGenerator);

        // Tooltip
        // create tooltip
        var tooltip = svgContent.append("g")
            .attr("class", "area-tooltip")
            .style("display", "none");

        // draw indicator circle
        tooltip.append("circle")
            .attr("r", 5)
            .attr('fill','#A066B5');

        // draw tooltip box
        tooltip.append("rect")
            .attr('class',"tooltip-box")
            .attr("x", 9)
            .attr("y", -23)
            .attr("height",25)
            .attr('rx','5px');

        // add tooltip text
        tooltip.append("text")
            .attr("x", 15)
            .attr("dy", "-.35em")
            .style("font-size",15);

        // draw box for hovering
        svgContent.append("rect")
            .attr("class", "overlay")
            .attr("width", width)
            .attr("height", height)
            .style('fill','none')
            .style('pointer-events','all')
            .on("mouseover", function() {
                tooltip.style("display", null);
            })
            .on("mouseout", function() {
                tooltip.style("display", "none");
            })
            .on("mousemove", mousemove);

        // transform tooltip placement and text based on hover position
        function mousemove(event) {
            
            var hover_date = xScale.invert(d3.pointer(event)[0])

            var data_point = data.find( ({ collected_for_day }) => collected_for_day.split('T')[0] === hover_date.toISOString().split('T')[0] );

            if (data_point){
            var y_value=parseFloat(data_point['total_accounts']);
            tooltip.attr("transform", "translate(" + xScale(new Date(data_point.collected_for_day)) + "," + yScale(y_value)+ ")"); 
            tooltip.select("text").text(formatNumbers(y_value,2));
            tooltip.select("rect").attr('width',tooltip.select("text").node().getComputedTextLength()+12)
            }

        }

        // comparison period highlight
        // draw growth highlight box
        svgContent
            .selectAll(".growth-bar")
            .data([0])
            .join('rect')
            .attr('x', xScale(growthStart))
            .attr('y', 0)
            .attr('height', height)
            .attr('width', xScale(dateExtent[1]) - xScale(growthStart))
            .attr("class", "growth-bar")
            .attr("stroke", "none")
            .attr("fill", "rgba(117, 117, 117, 0.4)")
            .attr("opacity", 0.1)

        // add growth highlight label
        svgContent
            .selectAll(".growth-text")
            .data([0])
            .join('text')
            .attr('x', xScale(d3.mean([dateExtent[1], growthStart])))
            .attr('y', yScale(growthEndValue) - 20)
            .text(Math.floor(percentChange * 100) + '%')
            .attr('class', 'growth-text')
            .attr('font-size', '0.7em')
            .attr('text-anchor', 'middle')

        // Goal Lines
        // draw current line
        svgContent
            .selectAll(".current-line")
            .data([0])
            .join('line')
            .attr('x1', xScale(dateExtent[0]))
            .attr('y1', yScale(growthEndValue))
            .attr('x2', xScale(dateExtent[1]))
            .attr('y2', yScale(growthEndValue))
            .attr('class', 'current-line')
            .attr('stroke', "rgba(117, 117, 117, 0.2)")

        // goals
        const goal_list=[]
        goals.forEach(g => 
            goal_list.push(numeral(g.toLowerCase())._value)
            )
            
        // draw goal lines
        svgContent
            .selectAll(".goal-line")
            .data(goal_list)
            .join('line')
            .attr('x1', xScale(dateExtent[0]))
            .attr('y1', d => yScale(d))
            .attr('x2', xScale(xAxisMax))
            .attr('y2', d => yScale(d))
            .attr('class', 'goal-line')
            .attr('stroke-dasharray', 4)
            .attr('stroke', "rgba(117, 117, 117, 0.2)")

        // draw current label box
        svgNoClip
            .selectAll(".current-label-box")
            .data([0])
            .join('rect')
            .attr('x', -60)
            .attr('y', yScale(growthEndValue) - 10)
            .attr('width', 60)
            .attr('height', 20)
            .attr('rx', 10)
            .attr("class", "current-label-box")
            .attr("stroke", "#A066B5")
            .attr("stroke-width", 2)
            .attr("fill", "none")

        // add current label text
        svgNoClip
            .selectAll(".current-label-text")
            .data([0])
            .join('text')
            .attr('x', -30)
            .attr('y', yScale(growthEndValue))
            .text('Current')
            .attr('dominant-baseline', 'middle')
            .attr('text-anchor', 'middle')
            .attr('class', 'current-label-text')
            .attr('fill', '#A066B5')
            .attr('font-size', '0.7em')

        // add current label value text
        svgNoClip
            .selectAll(".current-value-text")
            .data([0])
            .join('text')
            .attr('x', -70)
            .attr('y', yScale(growthEndValue))
            .text(formatNumbers(growthEndValue))
            .attr('dominant-baseline', 'middle')
            .attr('text-anchor', 'end')
            .attr('class', 'current-value-text')
            .attr('font-size', '0.7em')

        // draw goal label boxes
        svgNoClip
            .selectAll(".goal-label-box")
            .data(goal_list)
            .join('rect')
            .attr('x', -60)
            .attr('y', d => yScale(d) - 10)
            .attr('width', 60)
            .attr('height', 20)
            .attr('rx', 10)
            .attr("class", "goal-label-box")
            .attr("stroke", "#A066B5")
            .attr("stroke-width", 2)
            .attr("fill", "none")

        // add goal labels text
        svgNoClip
            .selectAll(".goal-label-text")
            .data(goal_list)
            .join('text')
            .attr('x', -30)
            .attr('y', d => yScale(d))
            .text('Goal')
            .attr('dominant-baseline', 'middle')
            .attr('text-anchor', 'middle')
            .attr('class', 'current-label-text')
            .attr('fill', '#A066B5')
            .attr('font-size', '0.7em')

        // add goal label values text
        svgNoClip
            .selectAll(".goal-value-text")
            .data(goal_list)
            .join('text')
            .attr('x', -70)
            .attr('y', d => yScale(d))
            .text(d => formatNumbers(d))
            .attr('dominant-baseline', 'middle')
            .attr('text-anchor', 'end')
            .attr('class', 'current-value-text')
            .attr('font-size', '0.7em')

        // axes
        // define x-axis
        const xAxis = d3.axisBottom(xScale).ticks(3);

        // draw x-axis
        svg
            .select(".x-axis")
            .attr("transform", `translate(0, ${height})`)
            .attr('font-family', 'manrope')
            .call(xAxis)
            .call(g => g.select(".domain").remove())
            .call(g => g.select(".tick line").remove())

        // define y-axis
        const yAxis = d3.axisRight(yScale).ticks(4);

        // draw y-axis
        svg
            .select(".y-axis")
            .attr("transform", "translate("+width+",0)")
            .call(yAxis)
            .attr('font-family', 'manrope')
            .attr('font-size', '0.7em')
            .call(g => g.selectAll(".tick>line").remove())
            .call(g => g.select(".domain").remove());

        // load the watermark in as data
        d3.xml("/images/logo_nm.svg").then(watermark => {

            // use d3 join to ensure that additional watermarks are not continuously added.
            svg
            .selectAll('.watermark')
            .data([0])
            .join('g')
            .html('') // need to empty the group as React does not play well with append.
            .attr('class','watermark watermark-top')
            .node()
            .append(watermark.documentElement);

            // set attributes of watermark
            d3.selectAll('.watermark-top svg')
            .attr("y", 40)
            .attr("x",125)
            .attr("height",20*1.5)
            .attr("width",76*1.5)
            .attr('opacity', 0.1)
        })

    });

    if (!selection) {
        return null;
    }

    return (
        <React.Fragment>
            <div>
                <svg ref={svgRef} width="100%" viewBox={'0 0 ' + svgWidth + ' ' + svgHeight}>
                    <defs>
                        <linearGradient id="gradient" x1="100%" y1="100%" x2="100%" y2="0%">
                            <stop offset="0%" stopColor="#A066B5" stopOpacity="0.1" />
                            <stop offset="100%" stopColor="#A066B5" stopOpacity="1" />
                        </linearGradient>

                    </defs>
                    <g transform={'translate(' + margin.left + ',' + margin.top + ')'}>
                        <clipPath id="ClipPath">
                            <rect x="0" y="0" width={width} height={height} />
                        </clipPath>
                        <g className="content" clipPath="url(#ClipPath)" />
                        <g className="non-clip-content" />
                        <g className="x-axis" />
                        <g className="y-axis" />
                    </g>
                </svg>
            </div>
        </React.Fragment>
    );
}

export default BrushedAreaChart;
'''
'''--- components/datatable.js ---
import React, { useState } from 'react';
import * as d3 from "d3";
import PropTypes from 'prop-types';
import Box from '@mui/material/Box';
import Table from '@mui/material/Table';
import TableBody from '@mui/material/TableBody';
import TableCell from '@mui/material/TableCell';
import TableContainer from '@mui/material/TableContainer';
import TableHead from '@mui/material/TableHead';
import TableRow from '@mui/material/TableRow';
import Paper from '@mui/material/Paper';
import TableSortLabel from '@mui/material/TableSortLabel';
import ArrowDownwardIcon from '@mui/icons-material/ArrowDownward';
import ArrowUpwardIcon from '@mui/icons-material/ArrowUpward';
import TablePagination from '@mui/material/TablePagination'
import { visuallyHidden } from '@mui/utils';
import Image from 'next/image'
import styles from '../styles/datatable.module.scss'

// sort functions
function descendingComparator(a, b, orderBy) {
  if (orderBy === 'entity_id'){
    var elementA = a[orderBy].toLowerCase()
    var elementB = b[orderBy].toLowerCase()
  } else {
    var elementA = a[orderBy]
    var elementB = b[orderBy]
  }

  if (elementB < elementA) {
    return -1;
  }
  if (elementB > elementA) {
    return 1;
  }
  return 0;
}

//number formatting function (add commas)
function formatNumber(x) {
  return x.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
}

// define sort order for columns
function getComparator(order, orderBy) {
  return order === 'desc'
    ? (a, b) => descendingComparator(a, b, orderBy)
    : (a, b) => -descendingComparator(a, b, orderBy);
}

// set column sort function
function stableSort(array, comparator) {
  const stabilizedThis = array.map((el, index) => [el, index]);
  stabilizedThis.sort((a, b) => {
    const order = comparator(a[0], b[0]);
    if (order !== 0) {
      return order;
    }
    return a[1] - b[1];
  });
  return stabilizedThis.map((el) => el[0]);
}

// Set Header
const headCells = [
  {
    id: 'entity_id',
    numeric: false,
    disableSort: false,
    label: 'App',
  },
  {
    id: 'total_accounts',
    numeric: true,
    disableSort: false,
    label: 'Total Accounts',
  },
  {
    id: 'bar',
    numeric: true,
    disableSort: true,
    label: '',
  },
  {
    id: 'thirty_d',
    numeric: true,
    disableSort: false,
    label: '30d Δ',
  },
  {
    id: 'arrow30',
    numeric: true,
    disableSort: true,
    label: '',
  },
  {
    id: 'ninety_d',
    numeric: true,
    disableSort: false,
    label: '90d Δ',
  },
  {
    id: 'arrow90',
    numeric: true,
    disableSort: true,
    label: '',
  }
];

// Table Header
function EnhancedTableHead(props) {
  const { order, orderBy, onRequestSort } =
    props;
  const createSortHandler = (property) => (event) => {
    onRequestSort(event, property);
  };

  return (
    <TableHead>
      <TableRow className={styles.table_row}>
        {headCells.map((headCell) => (
          <TableCell
            key={headCell.id}
            align='left'
            className={styles.table_cell_header}
            sortDirection={orderBy === headCell.id ? order : false}
          >
            {headCell.disableSort === false ? (<TableSortLabel
              active={orderBy === headCell.id}
              direction={orderBy === headCell.id ? order : 'asc'}
              onClick={createSortHandler(headCell.id)}
              className={styles.table_sort_label}
            >
              {headCell.label}
              {orderBy === headCell.id ? (
                <Box component="span" sx={visuallyHidden} >
                  {order === 'desc' ? 'sorted descending' : 'sorted ascending'}
                </Box>
              ) : null}
            </TableSortLabel>) : headCell.label}
          </TableCell>
        ))}
      </TableRow>
    </TableHead>
  );
}

EnhancedTableHead.propTypes = {
  onRequestSort: PropTypes.func.isRequired,
  order: PropTypes.oneOf(['asc', 'desc']).isRequired,
  orderBy: PropTypes.string.isRequired
};

function Datatable({ data = [], app_data = [], name = '_name', accounts = '_accounts', thirty = '_thirty', ninety = '_ninety' }) {

  //declare states for pagination
  const [page, setPage] = useState(0)
  const [rowsPerPage, setrowsPerPage] = useState(10)

  //declare pagination handlers
  const handleChangePage = (event, newPage) => {
    setPage(newPage)
  }

  const handleChangeRowsPerPage = (event) => {
    setrowsPerPage(+event.target.value)
    setPage(0)
  }

  const svgRef = React.useRef();

  let app_lookup = {}
  app_data.forEach(d => app_lookup[d.slug] = d)

  // format 30d and 90d columns
  // calculate growth %
  function growth(total, added) {
    if (added) {
      return Math.floor((total - added) / added * 100)
    } else { return ' - ' }
  }

  data.forEach(function (d) {
    d["thirty_d"] = growth(d[accounts], d[thirty])
    d["ninety_d"] = growth(d[accounts], d[ninety])
  });

  // calculate arrow direction
  function growthArrow(value) {
    if (value > 0) {
      return <ArrowUpwardIcon sx={{ paddingTop: `5px` }} />
    } else if (value < 0) {
      return <ArrowDownwardIcon sx={{ paddingTop: `5px` }} />
    } else { return '' }
  }

  // responsive width & height
  const svgWidth = 100
  const svgHeight = 5

  // scale bars
  const xScale = d3.scaleLinear()
    .range([0, svgWidth])
    .domain([0, d3.max(data, d => d[accounts])])

  // enable sort
  const [order, setOrder] = React.useState('desc');
  const [orderBy, setOrderBy] = React.useState('total_accounts');

  const handleRequestSort = (event, property) => {
    const isAsc = orderBy === property && order === 'asc';
    setOrder(isAsc ? 'desc' : 'asc');
    setOrderBy(property);
  };

  return (

    <React.Fragment>
      <TableContainer component={Paper} className={styles.table_container}>
        <Table sx={{ minWidth: 650 }} aria-label="simple table">
          <EnhancedTableHead
            order={order}
            orderBy={orderBy}
            onRequestSort={handleRequestSort}
          />
          <TableBody className="table_body">
            {stableSort(data, getComparator(order, orderBy)).slice(page * rowsPerPage, page * rowsPerPage + rowsPerPage).map((row) => (
              <TableRow
                tabIndex={-1}
                key={row[name]}
              >

                <TableCell className={styles.table_cell_app} >
                  <a href={app_lookup[row[name]].website} target='_blank' rel="noreferrer"><Image src={app_lookup[row[name]].logo} alt={app_lookup[row[name]].title + ' logo'} width={25} height={25} className="round-image"></Image></a><span style={{marginLeft:'10%'}}>{app_lookup[row[name]].title}</span>
                </TableCell>
                <TableCell align="left" className={styles.table_cell_total_accounts}>
                  {formatNumber(row[accounts])}
                </TableCell>
                <TableCell align="left" className={styles.table_cell_total_accounts_bar} >
                  <svg ref={svgRef} width="60%" viewBox={'0 0 ' + svgWidth + ' ' + svgHeight} style={{ marginRight: `20%` }}>
                    <linearGradient id="datatable-gradient" x1="0" y1="100%" x2="100%" y2="100%">
                      <stop offset="0%" stopColor="#78ced8" stopOpacity=".17" />
                      <stop offset="100%" stopColor="#75B8BF" stopOpacity="1" />
                    </linearGradient>
                    <rect height={svgHeight} width={xScale(row[accounts])} fill="url(#datatable-gradient)"></rect>
                  </svg>
                </TableCell>
                <TableCell align="left" className={styles.table_cell_change}>
                  {row["thirty_d"] + '%'}
                </TableCell>
                <TableCell align="left" className={styles.table_cell_change_arrow}>
                  {growthArrow(row["thirty_d"])}
                </TableCell>
                <TableCell align="left" className={styles.table_cell_change}>
                  {row["ninety_d"] + '%'}
                </TableCell>
                <TableCell align="left" className={styles.table_cell_change_arrow}>
                  {growthArrow(row["ninety_d"])}
                </TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </TableContainer>
      <TablePagination
        rowsPerPageOptions={[10]}
        component="div"
        count={data.length}
        rowsPerPage={rowsPerPage}
        page={page}
        onPageChange={handleChangePage}
        onRowsPerPageChange={handleChangeRowsPerPage}
        className={styles.table_cell_change}
      />
    </React.Fragment>
  )
}

export default Datatable;

'''
'''--- components/tooltip.js ---
import React from "react";
import styles from '../styles/tooltip.module.scss'
import * as d3 from "d3";

// define tooltip for barChart
function Tooltip({ visible, data, x, y }) {

    const tooltipRef = React.useRef();

    let html = ""

    // set inner html
    for (const [key, value] of Object.entries(data)) {
        html += `<div><strong>${key}</strong>${value != "" ? ": " + value : ""}</div>`
    }

    React.useEffect(() => {
        // set tooltip location
        const tooltip = d3.select(tooltipRef.current)

        // define tooltip 
        tooltip
            .html(html)
            .style("left", (x + 50) + "px")
            .style("top", y + "px")
            .style("opacity", visible == true ? 1 : 0)

    })

    return (
        <React.Fragment>
            <div ref={tooltipRef} className={styles.tooltip}>
            </div>
        </React.Fragment>
    );

}

export default Tooltip;
'''
'''--- components/usePrevious.js ---
import { useEffect, useRef } from "react";

/**
 * Hook, that returns the last used value.
 */

function usePrevious(value) {
  const ref = useRef();
  useEffect(() => {
    ref.current = value;
  },[value]);
  return ref.current;
}

export default usePrevious;
'''
'''--- helpers/2dCanvasCapture.js ---
import html2canvas from "html2canvas";

export default function canvasCapture(fileName, element){

  var html = document.getElementsByTagName('HTML')[0]
  var body =  document.getElementsByTagName('BODY')[0]

  var htmlWidth = html.clientWidth;
  var bodyWidth = body.clientWidth;
  var newWidth = element.scrollWidth - element.clientWidth

  if (newWidth > element.clientWidth){
    htmlWidth += newWidth
    bodyWidth += newWidth
  }

  html.style.width = htmlWidth + 'px';
  body.style.width = bodyWidth + 'px';

  html2canvas(element,{backgroundColor:'#ffffff', allowTaint:true}).then((canvas)=>{
    canvas.toBlob(blob => navigator.clipboard.write([new ClipboardItem({'image/png': blob})]));

    var image = canvas.toDataURL('image/png', 1.0);
    fileName = fileName + " - " + new Date().toString() +'.png'
    saveAs(image, fileName);

  })
}

const saveAs = (blob, fileName) =>{

  var elem = window.document.createElement('a');
  elem.href = blob
  elem.download = fileName;
  elem.style = 'display:none;';
  (document.body || document.documentElement).appendChild(elem);

  if (typeof elem.click === 'function') {
    elem.click();
  } else {
    elem.target = '_blank';
    elem.dispatchEvent(new MouseEvent('click', {
      view: window,
      bubbles: true,
      cancelable: true
    }));
  }

  URL.revokeObjectURL(elem.href);
  elem.remove()

}
'''
'''--- helpers/formatNumbers.js ---
// format numerical value
function formatNumbers (value, decimals = 1) {
    // Nine Zeroes for Billions
    return Math.abs(Number(value)) >= 1.0e+9
    ? (Math.abs(Number(value)) / 1.0e+9).toFixed(2) + "B"

    // Six Zeroes for Millions 
    : Math.abs(Number(value)) >= 1.0e+6
    ? (Math.abs(Number(value)) / 1.0e+6).toFixed(decimals) + "M"

    // Three Zeroes for Thousands
    : Math.abs(Number(value)) >= 1.0e+3
    ? (Math.abs(Number(value)) / 1.0e+3).toFixed(0) + "K"

    : Math.abs(Number(value));
}

module.exports = {
    formatNumbers
  }
'''
'''--- helpers/theme.js ---
//set the document into light or dark mode
function setTheme(themeName) {
  localStorage.setItem('theme', themeName);
  document.documentElement.className = themeName;
}

// maintain previous dark/light mode setting on reload
function keepTheme(setChecked) {
  if (localStorage.getItem('theme')) {
    if (localStorage.getItem('theme') === 'theme-dark') {
      setTheme('theme-dark');
      setChecked(true)
    } else if (localStorage.getItem('theme') === 'theme-light') {
      setTheme('theme-light')
      setChecked(false)
    }
  } else {
    setTheme('theme-light')
    setChecked(false)
  }
}

module.exports = {
  setTheme,
  keepTheme
}
'''
'''--- next.config.js ---
module.exports = {
  reactStrictMode: false,
  images: {
    domains: ['github.com', 'pbs.twimg.com'],
  },
}

'''
'''--- package.json ---
{
  "name": "near-stats-app",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "node server.js",
    "build": "next build",
    "start": "NODE_ENV=production node server.js",
    "lint": "next lint"
  },
  "dependencies": {
    "@emotion/react": "^11.6.0",
    "@emotion/styled": "^11.6.0",
    "@material-ui/core": "^4.12.3",
    "@mui/icons-material": "^5.2.0",
    "@mui/material": "^5.2.0",
    "d3": "^7.1.1",
    "d3-axis-for-react": "^1.1.0",
    "d3-regression": "^1.3.9",
    "dotenv": "^10.0.0",
    "express": "^4.17.1",
    "express-redis-cache": "^1.1.3",
    "fs": "^0.0.1-security",
    "html2canvas": "^1.3.3",
    "neat-csv": "5.1.0",
    "next": "11.1.2",
    "numeral": "^2.0.6",
    "pg": "^8.7.1",
    "react": "17.0.2",
    "react-dom": "17.0.2",
    "react-select": "^5.2.1",
    "react-switch": "^6.0.0",
    "sass": "^1.45.0"
  },
  "devDependencies": {
    "eslint": "7.32.0",
    "eslint-config-next": "11.1.2"
  }
}

'''
'''--- pages/_app.js ---
import '../styles/globals.scss';
import Head from "next/head";

function MyApp({ Component, pageProps }) {
  return (
    <>
      <Head>
        <link rel="shortcut icon" href="/favicon.ico" />
      </Head>
      <Component {...pageProps} />
    </>
  );
}

export default MyApp

'''
'''--- pages/_document.js ---
import Document, { Html, Head, Main, NextScript } from 'next/document';
import {ServerStyleSheets} from "@material-ui/styles";

class MyDocument extends Document {
    static async getInitialProps(ctx) {
        const sheet = new ServerStyleSheets();
        const originalRenderPage = ctx.renderPage;

        try{
            ctx.renderPage = () => originalRenderPage({
                enhanceApp: App => props => sheet.collect(<App {...props}/>)
            });

            const initialProps = await Document.getInitialProps(ctx);
            return { ...initialProps,
                styles: (
                    <>
                        {initialProps.styles}
                        {sheet.getStyleElement()}
                    </>
                )
            }
        } finally {
            ctx.renderPage(sheet)
        }

    }
    render() {
        return (
            <Html>
                <Head>
                    <link rel="shortcut icon" type="image/png" href="../static/favicon.ico"/>
                    <style>{`body { margin: 0 } /* custom! */`}</style>
                    <meta content="width=device-width, initial-scale=1.0" />
                </Head>
                <body className="custom_class">
                    <Main />
                    <NextScript />
                </body>
            </Html>
    )}
}

export default MyDocument;
'''
'''--- pages/index.js ---
import React from 'react';
import Header from '../components/Header';
import Footer from '../components/Footer';
import Background from '../components/Background';
import Datatable from '../components/datatable';
import AreaChart from '../components/areaChart';
import BarChart from '../components/barChart';
import GraphCard from '../components/Graphcard';
import BrushChart from '../components/brushChart';
import BrushedAreaChart from '../components/brushedAreaChart';
import Tooltip from '../components/tooltip';
import { keepTheme } from '../helpers/theme';

import styles from '../styles/Home.module.scss'

const Home = ({ total_accounts, app_summary, app_total, apps}) => {

  // set hooks for dropdowns and switches
  const [date_compare, setDateCompare] = React.useState(30);
  const [network, setNetwork] = React.useState('mainnet');
  const [tooltip, setTooltip] = React.useState({ visible: false, data: {}, x: 0, y: 0 });
  const [goals, setGoals] = React.useState([]);
  const [milestones, setMilestones] = React.useState([]);
  const [label, setLabel] = React.useState('Percent')
  const [detail, setDetail] = React.useState(false);
  const [detailGrowth, setDetailGrowth] = React.useState(false);
  const [checked, setChecked] = React.useState(false);

  // set functionality for maintaining dark mode setting on reload
  React.useEffect(() => {
    keepTheme(setChecked);
},[]);

  return (
    <>
      <Background />
        <div className={styles.background}>
          <Tooltip visible={tooltip.visible} data={tooltip.data} x={tooltip.x} y={tooltip.y}></Tooltip>
          <div>
            <Header setDateCompare={setDateCompare} setNetwork={setNetwork} setChecked={setChecked} checked={checked}></Header>
            <div className={styles.gridContainer}>
              <div className="global-flex-container">
                <GraphCard title="Total NEAR Accounts" size="half" icon='/images/Frametotalacc.png' setSelect={setGoals} placeholder='Goals' dateCompare={date_compare}>
                  <BrushChart data={total_accounts} x='collected_for_day' y='total_accounts'>
                    {options => <BrushedAreaChart data={options.data} prediction_data={options.prediction_data} x='collected_for_day' y='total_accounts' compare={date_compare} selection={options.selection} goals={goals} setTooltip={setTooltip} />}
                  </BrushChart>
                </GraphCard>
                <GraphCard title="Top NEAR Apps" size="half" icon='/images/Frametopapps.png' setSelect={setMilestones} placeholder='Milestones' label_type={label} setLabel={setLabel} dateCompare={date_compare}>
                  <BarChart data={app_summary} app_data={apps} x='total_accounts' y='entity_id' compare={`accounts_${date_compare}_days_ago`} goals={milestones} setTooltip={setTooltip} label_type={label} />
                </GraphCard>
                <GraphCard title="Total NEAR Accounts by App" size="half" icon='/images/Frametotalaccbyapp.png' setSelect={setDetail} dateCompare={date_compare}>
                  <AreaChart account_data={total_accounts} app_data={app_total} x='collected_for_day' y='total_accounts' compare={date_compare} detail={detail} setTooltip={setTooltip} />
                </GraphCard>
                <GraphCard title="NEAR Account Growth By App" size="half" icon='/images/Framenewaccbyapp.png' setSelect={setDetailGrowth} dateCompare={date_compare}>
                  <AreaChart account_data={total_accounts} app_data={app_total} growth={true} x='collected_for_day' y='total_accounts' compare={date_compare} detail={detailGrowth} setTooltip={setTooltip} />
                </GraphCard>
                <GraphCard title="Near App Momentum" icon='/images/Frameappmomentum.png'>
                  <Datatable data={app_summary} app_data={apps} accounts='total_accounts' name='entity_id' thirty="accounts_30_days_ago" ninety="accounts_90_days_ago" />
                </GraphCard>
              </div>
            </div>
            <Footer></Footer>
          </div>
        </div>
    </>
  )
}

// pull data from API
export async function getServerSideProps() {

  let total_accounts = await fetch(`http://localhost:${process.env.NEXT_PORT || process.env.PORT || 3000}/api/v1/mainnet/accounts/total`)
  total_accounts = await total_accounts.json()
  let app_summary = await fetch(`http://localhost:${process.env.NEXT_PORT || process.env.PORT || 3000}/api/v1/mainnet/apps/accounts/summary`)

  app_summary = await app_summary.json()
  let app_total = await fetch(`http://localhost:${process.env.NEXT_PORT || process.env.PORT || 3000}/api/v1/mainnet/apps/accounts/total?limit=10`)
  app_total = await app_total.json()
  let apps = await fetch(`http://localhost:${process.env.NEXT_PORT || process.env.PORT || 3000}/api/v1/mainnet/apps?contract=true`)
  apps = await apps.json()
  if (!total_accounts || !app_summary || !app_total || !apps) {
    return {
      notFound: true,
    }
  }
  return {
    props: { total_accounts, app_summary, app_total, apps }, // will be passed to the page component as props
  }
}

export default Home

'''
'''--- public/images/logo_nm.svg ---
<svg id="Layer_1" data-name="Layer 1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 342 90"><path d="M171.21,18.75v52.5a.76.76,0,0,1-.75.75H165a7.49,7.49,0,0,1-6.3-3.43l-24.78-38.3.85,19.13V71.25A.76.76,0,0,1,134,72h-7.22a.76.76,0,0,1-.75-.75V18.75a.76.76,0,0,1,.75-.75h5.43a7.52,7.52,0,0,1,6.3,3.42l24.78,38.24-.77-19.06V18.75a.75.75,0,0,1,.75-.75h7.22A.76.76,0,0,1,171.21,18.75Z"/><path d="M245,72h-7.64a.75.75,0,0,1-.7-1L256.9,18.72A1.14,1.14,0,0,1,258,18h9.57a1.14,1.14,0,0,1,1.05.72L288.8,71a.75.75,0,0,1-.7,1h-7.64a.76.76,0,0,1-.71-.48l-16.31-43a.75.75,0,0,0-1.41,0l-16.31,43A.76.76,0,0,1,245,72Z"/><path d="M341.84,70.79,326.66,51.4c8.57-1.62,13.58-7.4,13.58-16.27,0-10.19-6.63-17.13-18.36-17.13H300.71a1.12,1.12,0,0,0-1.12,1.13h0a7.2,7.2,0,0,0,7.2,7.2H321c7.09,0,10.49,3.63,10.49,8.87s-3.32,8.95-10.49,8.95H300.71a1.13,1.13,0,0,0-1.12,1.13v26a.75.75,0,0,0,.75.75h7.22a.76.76,0,0,0,.75-.75V51.87h8.33l13.17,17.19a7.51,7.51,0,0,0,6,2.94h5.48A.75.75,0,0,0,341.84,70.79Z"/><path d="M222.17,18h-33.5a1,1,0,0,0-1,1h0A7.33,7.33,0,0,0,195,26.33h27.17a.74.74,0,0,0,.75-.75V18.75A.75.75,0,0,0,222.17,18Zm0,45.67h-25a.76.76,0,0,1-.75-.75V49.38a.75.75,0,0,1,.75-.75h23.11a.75.75,0,0,0,.75-.75V41a.75.75,0,0,0-.75-.75H188.79a1.13,1.13,0,0,0-1.12,1.13V70.88A1.12,1.12,0,0,0,188.79,72h33.38a.75.75,0,0,0,.75-.75V64.42A.74.74,0,0,0,222.17,63.67Z"/><path d="M72.24,4.57,53.42,32.5a2,2,0,0,0,3,2.63L74.91,19.08a.74.74,0,0,1,1.24.56V69.93a.75.75,0,0,1-1.32.48l-56-67A9.59,9.59,0,0,0,11.54,0H9.59A9.59,9.59,0,0,0,0,9.59V80.41A9.59,9.59,0,0,0,9.59,90h0a9.59,9.59,0,0,0,8.17-4.57L36.58,57.5a2,2,0,0,0-3-2.63L15.09,70.92a.74.74,0,0,1-1.24-.56V20.07a.75.75,0,0,1,1.32-.48l56,67A9.59,9.59,0,0,0,78.46,90h2A9.59,9.59,0,0,0,90,80.41V9.59A9.59,9.59,0,0,0,80.41,0h0A9.59,9.59,0,0,0,72.24,4.57Z"/></svg>
'''
'''--- public/images/signal.svg ---
<svg width="8" height="9" viewBox="0 0 8 9" fill="none" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<rect x="0.0588379" width="7.94118" height="9" fill="url(#pattern0)"/>
<defs>
<pattern id="pattern0" patternContentUnits="objectBoundingBox" width="1" height="1">
<use xlink:href="#image0_1_2620" transform="translate(-0.0666667) scale(0.0755556 0.0666667)"/>
</pattern>
<image id="image0_1_2620" width="15" height="15" xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAAPCAYAAAA71pVKAAABKUlEQVQ4EcWRsUoDQRCGT7CInWAjgthaCNZqYcCXEAsVC7EJPkSagIVYisHlbv5/5jhIYamoi/gCQsAX8CmsTjbexgsehlRu88/8+/1zw22SNJyiKBZUdT1N062g3vtWAzZpZVl2AMADeAHwTvKm0leSzyT3JxNJkojIJoBHEblW1d1fwDfTJtkHcJ/n+caIqYJvZrYaQ2a2AuAIQEdEDp1zy/FuMBisARiOBgDYiRdBSd6qali5S/IcQLdavV/nzGx73JdlOSciQ5LHY7NWADgJX6xZPyWAPefcYnRIXpF8UtW76KVpuiQi7dg3ahU89d7Pk+yFn9kINpnhWaLvnGuJyEPspyqASzM7C6CqdkheTA3VgTCA5OfMwTiEZBnrmfX/wgA+/lr3C91GsZ8olO6VAAAAAElFTkSuQmCC"/>
</defs>
</svg>

'''
'''--- server.js ---
require('dotenv').config();
const express = require('express')
const next = require('next')
const { Client } = require('pg')

//////////////////////////////
///// Redis cache setup //////
//////////////////////////////

var cache = require('express-redis-cache')({ expire: 60 * 60 * 24 }); // expire after 24 hours

cache.on('error', function (error) {
  console.error("Redis cache", error);
  console.log("Express bypassing Redis cache")
});

//////////////////////////////
/// db connection settings ///
//////////////////////////////

// details pulled in from .env file
const mainnet_connection_config = {
  host: process.env.NEAR_ANALYTICS_MAINNET_DATABASE_HOST,
  user: process.env.NEAR_ANALYTICS_MAINNET_DATABASE_USERNAME,
  password: process.env.NEAR_ANALYTICS_MAINNET_DATABASE_PASSWORD,
  database: process.env.NEAR_ANALYTICS_MAINNET_DATABASE_NAME
}

const testnet_connection_details = {
  host: process.env.NEAR_ANALYTICS_TESTNET_DATABASE_HOST,
  user: process.env.NEAR_ANALYTICS_TESTNET_DATABASE_USERNAME,
  password: process.env.NEAR_ANALYTICS_TESTNET_DATABASE_PASSWORD,
  database: process.env.NEAR_ANALYTICS_TESTNET_DATABASE_NAME
}

/////////////////////////////
////// Connect to db ////////
/////////////////////////////

const mainnet_db = new Client(mainnet_connection_config)
const testnet_db = new Client(testnet_connection_details)

// connect to the database and log a message of success or error to the server console
mainnet_db
  .connect()
  .then(() => console.log('connected to mainnet'))
  .catch(err => console.error('database connection error', err.stack))

testnet_db
  .connect()
  .then(() => console.log('connected to testnet'))
  .catch(err => console.error('database connection error', err.stack))

/////////////////////////////
////// Next.js Setup ////////
/////////////////////////////

const dev = process.env.NODE_ENV !== 'production'
const app = next({ dev })
const handle = app.getRequestHandler()

app.prepare().then(async () => {

  /////////////////////////////
  ////// Express Setup ////////
  /////////////////////////////

  const server = express()
  server.use(express.json())

  /////////////////////////////
  ////// API endpoints ////////
  /////////////////////////////

  //get total accounts
  server.get('/api/v1/:network/accounts/total', cache.route(), async (req, res) => {

    // extracting a limit parameter from the the url
    const { network } = req.params

    // extracting additional query parameters
    const start = req.query.start ? new Date(req.query.start) : new Date(0) // start of EPOCH
    const end = req.query.end ? new Date(req.query.end) : new Date() // now

    // dates split to create postgres format
    let query = `
    with cumulative_accounts as
    (
      select
        daily_new_accounts_count.collected_for_day
        , sum(coalesce(new_accounts_count, 0) - coalesce(deleted_accounts_count, 0)) over(order by daily_new_accounts_count.collected_for_day) as total_accounts
      from
        daily_new_accounts_count
        left join daily_deleted_accounts_count on
          daily_new_accounts_count.collected_for_day = daily_deleted_accounts_count.collected_for_day
    )
    select
      collected_for_day
      , total_accounts
    from
      cumulative_accounts
    where
      collected_for_day >= '${start.toISOString().split('T')[0]}'
      and collected_for_day <= '${end.toISOString().split('T')[0]}'
  `

    //select the database to use.
    const db = network == 'mainnet' ? mainnet_db : testnet_db

    // execute the query and save and extract the rows from the results object
    let { rows } = await db.query(query)

    rows.forEach(d => {
      d.total_accounts = parseInt(d.total_accounts)
    })
    // send the results to the browser
    res.send(rows)

  })

  server.get('/api/v1/:network/accounts/growth', cache.route(), async (req, res) => {

    // extracting a limit parameter from the the url
    const { network } = req.params

    // extracting additional query parameters
    const start = req.query.start ? new Date(req.query.start) : new Date(0) // start of EPOCH
    const end = req.query.end ? new Date(req.query.end) : new Date() // now

    // dates split to create postgres format
    let query = `
    with total_accounts as
    (
      select
        daily_new_accounts_count.collected_for_day
        , coalesce(new_accounts_count, 0) - coalesce(deleted_accounts_count, 0) as total_accounts
        , row_number() over(order by daily_new_accounts_count.collected_for_day) as r_n
      from
        daily_new_accounts_count
        left join daily_deleted_accounts_count on
          daily_new_accounts_count.collected_for_day = daily_deleted_accounts_count.collected_for_day
      where
        daily_new_accounts_count.collected_for_day >= '${start.toISOString().split('T')[0]}'
        and daily_new_accounts_count.collected_for_day <= '${end.toISOString().split('T')[0]}'
    )
    select
      collected_for_day
      , sum(
        case
        when r_n = 1 then 0
        else total_accounts
        end) over(order by collected_for_day) as total_accounts
    from
      total_accounts
  `

    //select the database to use.
    const db = network == 'mainnet' ? mainnet_db : testnet_db

    // execute the query and save and extract the rows from the results object
    let { rows } = await db.query(query)

    rows.forEach(d => {
      d.total_accounts = parseInt(d.total_accounts)
    })
    // send the results to the browser
    res.send(rows)

  })

  server.get('/api/v1/:network/accounts/daily', cache.route(), async (req, res) => {

    // extracting a limit parameter from the the url
    const { network } = req.params

    // extracting additional query parameters
    const start = req.query.start ? new Date(req.query.start) : new Date(0) // start of EPOCH
    const end = req.query.end ? new Date(req.query.end) : new Date() // now

    // dates split to create postgres format
    let query = `
      select
         *
      from
        daily_new_accounts_count
      where
        daily_new_accounts_count.collected_for_day >= '${start.toISOString().split('T')[0]}'
        and daily_new_accounts_count.collected_for_day <= '${end.toISOString().split('T')[0]}'
    `

    //select the database to use.
    const db = network == 'mainnet' ? mainnet_db : testnet_db

    // execute the query and save and extract the rows from the results object
    let { rows } = await db.query(query)

    rows.forEach(d => {
      d.new_accounts_count = parseInt(d.new_accounts_count)
    })

    // send the results to the browser
    res.send(rows)

  })

  server.get('/api/v1/:network/apps', cache.route(), async (req, res) => {

    // extracting a limit parameter from the the url
    const { network } = req.params

    const app = req.query.app ? req.query.app : null
    const contract = req.query.contract ? req.query.contract : false // must have contract_ids

    // dates split to create postgres format
    let query = `
      select
         *
      from
        near_ecosystem_entities
    `

    if (app !== null && contract === false) {
      query += `where slug = '${app}' AND is_app`
    } else if (app !== null && contract !== false) {
      query += `where slug = '${app}' AND is_app AND contract IS NOT NULL`
    } else if (app === null && contract !== false){
      query += `where contract IS NOT NULL`
    }

    //select the database to use.
    const db = network == 'mainnet' ? mainnet_db : testnet_db

    // execute the query and save and extract the rows from the results object
    let { rows } = await db.query(query)

    rows.forEach(d => {
      if (!d.logo) {
        d.logo = '/images/ecosystem.png'
      } else if (d.logo.startsWith('/img/')) {
        d.logo = 'https://github.com/near/ecosystem/raw/main' + d.logo
      }
    })

    // send the results to the browser
    res.send(rows)

  })

  server.get('/api/v1/:network/apps/accounts/total', cache.route(), async (req, res) => {

    // extracting a limit parameter from the the url
    const { network } = req.params

    // extracting additional query parameters
    const start = req.query.start ? new Date(req.query.start) : new Date(0) // start of EPOCH
    const end = req.query.end ? new Date(req.query.end) : new Date() // now
    const limit = req.query.limit ? `limit ${parseInt(req.query.limit)}` : ""

    // dates split to create postgres format
    let query = `
     WITH series AS (
       SELECT
         DATE_TRUNC('day',
           dd)::date AS date
       FROM
         generate_series('2020-09-15'::timestamp,
           CURRENT_DATE - 1,
           '1 day'::interval) AS dd
     ),
     entities AS (
       SELECT DISTINCT
         entity_id
       FROM
         daily_new_accounts_per_ecosystem_entity_count
     ),
     entity_series AS (
       SELECT
         date,
         entity_id
       FROM
         series
       CROSS JOIN entities
     ),
     apps_cumulative_accounts AS (
       SELECT
         date,
         entity_series.entity_id,
         sum(new_accounts_count) OVER (PARTITION BY entity_series.entity_id ORDER BY date) AS total_accounts
       FROM
         entity_series
         LEFT JOIN daily_new_accounts_per_ecosystem_entity_count ON entity_series.date = daily_new_accounts_per_ecosystem_entity_count.collected_for_day
           AND entity_series.entity_id = daily_new_accounts_per_ecosystem_entity_count.entity_id
     ),
     top_ten_entity AS (
     SELECT
       date,
       entity_id as entity,
       total_accounts
     FROM
       apps_cumulative_accounts
     WHERE
       total_accounts IS NOT NULL ORDER BY
         date DESC,
         total_accounts DESC
         ${limit}
     )
     SELECT
       apps_cumulative_accounts.date as collected_for_day,
       entity_id,
       apps_cumulative_accounts.total_accounts
     FROM
       apps_cumulative_accounts
     join
     top_ten_entity
     on apps_cumulative_accounts.entity_id = top_ten_entity.entity
     WHERE
      apps_cumulative_accounts.date >= '${start.toISOString().split('T')[0]}'
      AND apps_cumulative_accounts.date <= '${end.toISOString().split('T')[0]}'
      AND apps_cumulative_accounts.total_accounts IS NOT NULL
    ORDER BY apps_cumulative_accounts.total_accounts DESC;
     `

    //select the database to use.
    const db = network == 'mainnet' ? mainnet_db : testnet_db

    // execute the query and save and extract the rows from the results object
    let { rows } = await db.query(query)

    rows.forEach(d => {
      d.total_accounts = parseInt(d.total_accounts)
    })

    // send the results to the browser
    res.send(rows)

  })

  server.get('/api/v1/:network/apps/accounts/growth', cache.route(), async (req, res) => {

    // extracting a limit parameter from the the url
    const { network } = req.params

    // extracting additional query parameters
    const start = req.query.start ? new Date(req.query.start) : new Date('2020-09-15') // start of EPOCH
    const end = req.query.end ? new Date(req.query.end) : new Date() // now
    const limit = req.query.limit ? `limit ${parseInt(req.query.limit)}` : ""

    // dates split to create postgres format
    let query = `
    WITH series AS (
      SELECT
        DATE_TRUNC('day',
          dd)::date AS date
      FROM
        generate_series('${start.toISOString().split('T')[0]}'::timestamp,
          CURRENT_DATE - 1,
          '1 day'::interval) AS dd
    ),
    entities AS (
      SELECT DISTINCT
        entity_id
      FROM
        daily_new_accounts_per_ecosystem_entity_count
    ),
    entity_series AS (
      SELECT
        date,
        entity_id
      FROM
        series
      CROSS JOIN entities
    ),
    apps_cumulative_accounts AS (
      SELECT
        date,
        entity_series.entity_id,
        sum(new_accounts_count) OVER (PARTITION BY entity_series.entity_id ORDER BY date) AS total_accounts
      FROM
        entity_series
        LEFT JOIN daily_new_accounts_per_ecosystem_entity_count ON entity_series.date = daily_new_accounts_per_ecosystem_entity_count.collected_for_day
          AND entity_series.entity_id = daily_new_accounts_per_ecosystem_entity_count.entity_id
    ),
    top_ten_entity AS (
    SELECT
      date,
      entity_id as entity,
      total_accounts
    FROM
      apps_cumulative_accounts
    WHERE
      total_accounts IS NOT NULL ORDER BY
        date DESC,
        total_accounts DESC
        ${limit}
    )
    SELECT
      apps_cumulative_accounts.date as collected_for_day,
      entity_id,
      apps_cumulative_accounts.total_accounts
    FROM
      apps_cumulative_accounts
    join
    top_ten_entity
    on apps_cumulative_accounts.entity_id = top_ten_entity.entity
    WHERE
      apps_cumulative_accounts.date <= '${end.toISOString().split('T')[0]}' and
      apps_cumulative_accounts.total_accounts IS NOT NULL
    ORDER BY apps_cumulative_accounts.total_accounts DESC;
    `

    //select the database to use.
    const db = network == 'mainnet' ? mainnet_db : testnet_db

    // execute the query and save and extract the rows from the results object
    let { rows } = await db.query(query)

    rows.forEach(d => {
      d.total_accounts = parseInt(d.total_accounts)
    })

    // send the results to the browser
    res.send(rows)

  })

  server.get('/api/v1/:network/apps/accounts/summary', cache.route(), async (req, res) => {

    // extracting a limit parameter from the the url
    const { network } = req.params

    const yesterday = new Date()
    yesterday.setDate(yesterday.getDate() - 1)

    // extracting additional query parameters
    const date = req.query.date ? new Date(req.query.date) : yesterday
    const limit = req.query.limit ? parseInt(req.query.limit) : null
    const summary = req.query.summary ? req.query.summary : [30, 60, 90]

    // dates split to create postgres format
    let query = `
    with apps_cumulative_accounts as
    (
      select
        collected_for_day
        , entity_id
        , sum(new_accounts_count) over(partition by entity_id order by collected_for_day) as total_accounts
      from
        daily_new_accounts_per_ecosystem_entity_count
    )
    select
      a.collected_for_day
      , a.entity_id
      , a.total_accounts
      ${summary.map(time_period => `, (select t.total_accounts from apps_cumulative_accounts t where t.entity_id = a.entity_id and t.collected_for_day = (a.collected_for_day - interval '${time_period + 1}' day)) as accounts_${time_period}_days_ago`).join('')}
    from
      apps_cumulative_accounts a
    where
      a.collected_for_day = '${date.toISOString().split('T')[0]}'
    order by
      total_accounts desc
    `

    if (limit !== null) query += `limit ${limit}`

    //select the database to use.
    const db = network == 'mainnet' ? mainnet_db : testnet_db

    // execute the query and save and extract the rows from the results object
    let { rows } = await db.query(query)

    rows.forEach(d => {
      d.total_accounts = parseInt(d.total_accounts)
      summary.forEach(time_period => {
        d[`accounts_${time_period}_days_ago`] = parseInt(d[`accounts_${time_period}_days_ago`])
      })
    })

    // send the results to the browser
    res.send(rows)

  })

  server.get('/api/v1/:network/apps/accounts/daily', cache.route(), async (req, res) => {

    // extracting a limit parameter from the the url
    const { network } = req.params

    // extracting additional query parameters
    const start = req.query.start ? new Date(req.query.start) : new Date(0) // start of EPOCH
    const end = req.query.end ? new Date(req.query.end) : new Date() // now

    // dates split to create postgres format
    let query = `
    select
      *
    from
      daily_new_accounts_per_ecosystem_entity_count
    where
      collected_for_day >= '${start.toISOString().split('T')[0]}'
      and collected_for_day <= '${end.toISOString().split('T')[0]}'
    `

    //select the database to use.
    const db = network == 'mainnet' ? mainnet_db : testnet_db

    // execute the query and save and extract the rows from the results object
    let { rows } = await db.query(query)

    rows.forEach(d => {
      d.new_accounts_count = parseInt(d.new_accounts_count)
    })

    // send the results to the browser
    res.send(rows)

  })

  server.get('*', (req, res) => {
    return handle(req, res)
  })

  server.listen(process.env.NEXT_PORT || process.env.PORT || 3000, (err) => {
    if (err) throw err
    console.log(`NEAR Analytics API listening at http://localhost:${process.env.NEXT_PORT || process.env.PORT || 3000}`)
  })

})

'''
'''--- start.sh ---
#!/bin/sh
nohup redis-server &
yarn start
'''