*GitHub Repository "phoenixpulsar/vehicles-on-the-block-smart-contract"*

'''--- README.md ---
# `near-sdk-as` Starter Kit

This is a good project to use as a starting point for your AssemblyScript project.

## Samples

This repository includes a complete project structure for AssemblyScript contracts targeting the NEAR platform.

The example here is very basic.  It's a simple contract demonstrating the following concepts:
- a single contract
- the difference between `view` vs. `change` methods
- basic contract storage

AssemblyScript contract

- **singleton** in the `src/singleton` folder

### Singleton

We say that an AssemblyScript contract is written in the "singleton style" when the `index.ts` file (the contract entry point) has a single exported class (the name of the class doesn't matter) that is decorated with `@nearBindgen`.

In this case, all methods on the class become public contract methods unless marked `private`.  Also, all instance variables are stored as a serialized instance of the class under a special storage key named `STATE`.  AssemblyScript uses JSON for storage serialization (as opposed to Rust contracts which use a custom binary serialization format called borsh).

```ts
@nearBindgen
export class Contract {

  // return the string 'hello world'
  helloWorld(): string {}

  // read the given key from account (contract) storage
  read(key: string): string {}

  // write the given value at the given key to account (contract) storage
  @mutateState()
  write(key: string, value: string): string {}

  // private helper method used by read() and write() above
  private storageReport(): string {}
}
```

## Usage

### Getting started

(see below for video recordings of each of the following steps)

INSTALL `NEAR CLI` first like this: `npm i -g near-cli`

1. clone this repo to a local folder
2. run `yarn`
3. run `./scripts/1.dev-deploy.sh`
3. run `./scripts/2.use-contract.sh`
4. run `./scripts/2.use-contract.sh` (yes, run it to see changes)
5. run `./scripts/3.cleanup.sh`

### Videos

**`1.dev-deploy.sh`**

This video shows the build and deployment of the contract.

[![asciicast](https://asciinema.org/a/409575.svg)](https://asciinema.org/a/409575)

**`2.use-contract.sh`**

This video shows contract methods being called.  You should run the script twice to see the effect it has on contract state.

[![asciicast](https://asciinema.org/a/409577.svg)](https://asciinema.org/a/409577)

**`3.cleanup.sh`**

This video shows the cleanup script running.  Make sure you add the `BENEFICIARY` environment variable. The script will remind you if you forget.

```sh
export BENEFICIARY=<your-account-here>   # this account receives contract account balance
```

[![asciicast](https://asciinema.org/a/409580.svg)](https://asciinema.org/a/409580)

### Other documentation

- See `./scripts/README.md` for documentation about the scripts
- Watch this video where Willem Wyndham walks us through refactoring a simple example of a NEAR smart contract written in AssemblyScript

  https://youtu.be/QP7aveSqRPo

  ```
  There are 2 "styles" of implementing AssemblyScript NEAR contracts:
  - the contract interface can either be a collection of exported functions
  - or the contract interface can be the methods of a an exported class

  We call the second style "Singleton" because there is only one instance of the class which is serialized to the blockchain storage.  Rust contracts written for NEAR do this by default with the contract struct.

   0:00 noise (to cut)
   0:10 Welcome
   0:59 Create project starting with "npm init"
   2:20 Customize the project for AssemblyScript development
   9:25 Import the Counter example and get unit tests passing
  18:30 Adapt the Counter example to a Singleton style contract
  21:49 Refactoring unit tests to access the new methods
  24:45 Review and summary
  ```

## The file system

```sh
├── README.md                          # this file
├── as-pect.config.js                  # configuration for as-pect (AssemblyScript unit testing)
├── asconfig.json                      # configuration for AssemblyScript compiler (supports multiple contracts)
├── package.json                       # NodeJS project manifest
├── scripts
│   ├── 1.dev-deploy.sh                # helper: build and deploy contracts
│   ├── 2.use-contract.sh              # helper: call methods on ContractPromise
│   ├── 3.cleanup.sh                   # helper: delete build and deploy artifacts
│   └── README.md                      # documentation for helper scripts
├── src
│   ├── as_types.d.ts                  # AssemblyScript headers for type hints
│   ├── singleton                      # Contract 2: "Singleton-style example"
│   │   ├── __tests__
│   │   │   ├── as-pect.d.ts           # as-pect unit testing headers for type hints
│   │   │   └── index.unit.spec.ts     # unit tests for contract 2
│   │   ├── asconfig.json              # configuration for AssemblyScript compiler (one per contract)
│   │   └── assembly
│   │       └── index.ts               # contract code for contract 2
│   ├── tsconfig.json                  # Typescript configuration
│   └── utils.ts                       # common contract utility functions
└── yarn.lock                          # project manifest version lock
```

You may clone this repo to get started OR create everything from scratch.

Please note that, in order to create the AssemblyScript and tests folder structure, you may use the command `asp --init` which will create the following folders and files:

```
./assembly/
./assembly/tests/
./assembly/tests/example.spec.ts
./assembly/tests/as-pect.d.ts
```

'''
'''--- as-pect.config.js ---
module.exports = require("near-sdk-as/imports");
module.exports.include.push("**/*.unit.spec.ts");

'''
'''--- asconfig.json ---
{
  "workspaces": ["src/vehicleGarage"]
}

'''
'''--- package.json ---
{
  "name": "starter--near-sdk-as",
  "version": "0.0.1",
  "description": "Start with a basic project",
  "scripts": {
    "dev": "watch -d -n 1 'clear && yarn test'",
    "test": "yarn asp -f unit.spec",
    "clean": "rm -rf ./build && rm -rf ./neardev",
    "build": "asb --target debug",
    "build:release": "asb",
    "asp": "asp --verbose --nologo"
  },
  "keywords": [],
  "author": "hello@near.org",
  "license": "ISC",
  "devDependencies": {
    "near-sdk-as": "^3.1.0"
  }
}

'''
'''--- scripts/1.dev-deploy.sh ---
#!/usr/bin/env bash

# exit on first error after this point to avoid redeploying with successful build
set -e

echo
echo ---------------------------------------------------------
echo "Step 1: Build the contract (may take a few seconds)"
echo ---------------------------------------------------------
echo

yarn build

echo
echo
echo ---------------------------------------------------------
echo "Step 2: Deploy the contract"
echo
echo "(edit scripts/1.dev-deploy.sh to deploy other contract)"
echo ---------------------------------------------------------
echo

# uncomment out the line below to deploy the other example contract
# near dev-deploy ./build/debug/simple.wasm

# comment the line below to deploy the other example contract
near dev-deploy ./build/debug/singleton.wasm

echo
echo
echo ---------------------------------------------------------
echo "Step 3: Prepare your environment for next steps"
echo
echo "(a) find the contract (account) name in the message above"
echo "    it will look like this: [ Account id: dev-###-### ]"
echo
echo "(b) set an environment variable using this account name"
echo "    see example below (this may not work on Windows)"
echo
echo ---------------------------------------------------------
echo 'export CONTRACT=<dev-123-456>'
# uncomment this line for a useful hint when using the singleton style
# echo "near call \$CONTRACT init --accountId \$CONTRACT"
echo ---------------------------------------------------------
echo

exit 0

'''
'''--- scripts/2.use-contract.sh ---
#!/usr/bin/env bash

# exit on first error after this point to avoid redeploying with successful build
set -e

echo
echo ---------------------------------------------------------
echo "Step 0: Check for environment variable with contract name"
echo ---------------------------------------------------------
echo

[ -z "$CONTRACT" ] && echo "Missing \$CONTRACT environment variable" && exit 1
[ -z "$CONTRACT" ] || echo "Found it! \$CONTRACT is set to [ $CONTRACT ]"

echo
echo
echo ---------------------------------------------------------
echo "Step 1: Call 'view' functions on the contract"
echo
echo "(run this script again to see changes made by this file)"
echo ---------------------------------------------------------
echo

near view $CONTRACT helloWorld

echo
echo

near view $CONTRACT read '{"key":"some-key"}'

echo
echo
echo ---------------------------------------------------------
echo "Step 2: Call 'change' functions on the contract"
echo ---------------------------------------------------------
echo

# the following line fails with an error because we can't write to storage without signing the message
# --> FunctionCallError(HostError(ProhibitedInView { method_name: "storage_write" }))
# near view $CONTRACT write '{"key": "some-key", "value":"some value"}'
near call $CONTRACT write '{"key": "some-key", "value":"some value"}' --accountId $CONTRACT

echo
echo "now run this script again to see changes made by this file"
exit 0

'''
'''--- scripts/3.cleanup.sh ---
#!/usr/bin/env bash

# exit on first error after this point to avoid redeploying with successful build
set -e

echo
echo ---------------------------------------------------------
echo "Step 0: Check for required environment variables"
echo ---------------------------------------------------------
echo

[ -z "$CONTRACT" ] && echo "Missing \$CONTRACT environment variable" && exit 1
[ -z "$BENEFICIARY" ] && echo "Missing \$BENEFICIARY environment variable" && exit 1
[ -z "$CONTRACT" ] || echo "Found it! \$CONTRACT is set to [ $CONTRACT ]"
[ -z "$BENEFICIARY" ] || echo "Found it! \$BENEFICIARY is set to [ $BENEFICIARY ]"

echo
echo
echo ---------------------------------------------------------
echo "Step 1: Delete $CONTRACT, setting $BENEFICIARY as beneficiary"
echo ---------------------------------------------------------
echo
near delete $CONTRACT $BENEFICIARY

echo
echo ---------------------------------------------------------
echo "Step 2: Clean up project folders"
echo ---------------------------------------------------------
echo
yarn clean

exit 0

'''
'''--- scripts/README.md ---
## Setting up your terminal

The scripts in this folder are designed to help you demonstrate the behavior of the contract(s) in this project.

It uses the following setup:

```sh
# set your terminal up to have 2 windows, A and B like this:
┌─────────────────────────────────┬─────────────────────────────────┐
│                                 │                                 │
│                                 │                                 │
│                A                │                B                │
│                                 │                                 │
│                                 │                                 │
└─────────────────────────────────┴─────────────────────────────────┘
```

### Terminal **A**

*This window is used to compile, deploy and control the contract*
- Environment
  ```sh
  export CONTRACT=        # depends on deployment
  export OWNER=           # any account you control

  # for example
  # export CONTRACT=dev-1615190770786-2702449
  # export OWNER=sherif.testnet
  ```

- Commands

  _helper scripts_
  ```sh
  1.dev-deploy.sh                # helper: build and deploy contracts
  2.use-contract.sh              # helper: call methods on ContractPromise
  3.cleanup.sh                   # helper: delete build and deploy artifacts
  ```

### Terminal **B**

*This window is used to render the contract account storage*
- Environment
  ```sh
  export CONTRACT=               # depends on deployment

  # for example
  # export CONTRACT=dev-1615190770786-2702449
  ```

- Commands
  ```sh
  # monitor contract storage using near-account-utils
  # https://github.com/near-examples/near-account-utils
  watch -d -n 1 yarn storage $CONTRACT
  ```
---

## OS Support

### Linux

- The `watch` command is supported natively on Linux
- To learn more about any of these shell commands take a look at [explainshell.com](https://explainshell.com)

### MacOS

- Consider `brew info visionmedia-watch` (or `brew install watch`)

### Windows

- Consider this article: [What is the Windows analog of the Linux watch command?](https://superuser.com/questions/191063/what-is-the-windows-analog-of-the-linuo-watch-command#191068)

'''
'''--- src/as_types.d.ts ---
/// <reference types="near-sdk-as/assembly/as_types" />
'''
'''--- src/tsconfig.json ---
{
  "extends": "../node_modules/assemblyscript/std/assembly.json",
  "include": ["./**/*.ts"]
}

'''
'''--- src/utils.ts ---
import { u128, Context, ContractPromise } from "near-sdk-as";

export const GARAGE_KEY = "state";
export type VehicleId = string;
export type VehicleServiceId = string;
/**
 * @function idCreator
 * @return {string}
 * Creates a unique id by combining sender + block height
 */
export function idCreator(): string {
  let id = Context.blockIndex.toString();
  return id;
}

/**
 * == TYPES ====================================================================
 */

/**
 * Account IDs in NEAR are just strings.
 */
export type AccountId = string;

/**
 * Gas is u64
 */
export type Gas = u64;

/**
 * Amounts, Balances, and Money in NEAR is are u128.
 */

export type Amount = u128;

export type Balance = Amount;

export type Money = Amount;

/**
 * Timestamp in NEAR is a number.
 */
export type Timestamp = u64;

/**
 * == CONSTANTS ================================================================
 *
 * ONE_NEAR = unit of NEAR token in yocto Ⓝ (1e24)
 * XCC_GAS = gas for cross-contract calls, ~5 Tgas (teragas = 1e12) per "hop"
 * MIN_ACCOUNT_BALANCE = 3 NEAR min to keep account alive via storage staking
 *
 * TODO: revist MIN_ACCOUNT_BALANCE after some real data is included b/c this
 *  could end up being much higher
 */

export const ONE_NEAR = u128.from("1000000000000000000000000");
export const XCC_GAS: Gas = 20_000_000_000_000;
export const MIN_ACCOUNT_BALANCE: u128 = u128.mul(ONE_NEAR, u128.from(3));

/**
 * == FUNCTIONS ================================================================
 */

/**
 * @function asNEAR
 * @param amount {u128} - Yocto Ⓝ token quantity as an unsigned 128-bit integer
 * @returns {string}    - Amount in NEAR, as a string
 *
 * @example
 *
 *    asNEAR(7000000000000000000000000)
 *    // => '7'
 */
export function asNEAR(amount: u128): string {
  return u128.div(amount, ONE_NEAR).toString();
}

/**
 * @function toYocto
 * @param amount {number} - Integer to convert
 * @returns {u128}        - Amount in yocto Ⓝ as an unsigned 128-bit integer
 *
 * @example
 *
 *    toYocto(7)
 *    // => 7000000000000000000000000
 */
export function toYocto(amount: number): u128 {
  return u128.mul(ONE_NEAR, u128.from(amount));
}

/**
 * Function to assert that the contract has called itself
 */
export function assert_self(): void {
  const caller = Context.predecessor;
  const self = Context.contractName;
  assert(caller == self, "Only this contract may call itself");
}

export function assert_single_promise_success(): void {
  const x = ContractPromise.getResults();
  assert(x.length == 1, "Expected exactly one promise result");
  assert(x[0].succeeded, "Expected PromiseStatus to be successful");
}

'''
'''--- src/vehicleGarage/__tests__/as-pect.d.ts ---
/// <reference types="@as-pect/assembly/types/as-pect" />
'''
'''--- src/vehicleGarage/__tests__/index.unit.spec.ts ---
import { VMContext, PersistentMap } from "near-sdk-as";
import * as model from "../assembly/models";
import * as util from "../../utils";
import * as contract from "../assembly";

/**
 * == CONFIG VALUES ============================================================
 */
const VEHICLE_GARAGE_ACCOUNT_ID = "vehicleGarage";

/**
 * == HELPER FUNCTIONS =========================================================
 */
const useVehicleGarageAsPredecessor = (): void => {
  VMContext.setPredecessor_account_id(VEHICLE_GARAGE_ACCOUNT_ID);
};

const doInitialize = (): void => {
  useVehicleGarageAsPredecessor();
  contract.init();
};

/**
 * == UNIT TESTS ==============================================================
 */

describe("vehicleGarage", () => {
  beforeEach(doInitialize);

  it("creates a vehicleGarage", () => {
    const vg = contract.get_vehicle_garage();
    expect(vg.creator).toBe(VEHICLE_GARAGE_ACCOUNT_ID);
  });

  it("creates a new vehicle", () => {
    const newVehicle = contract.add_vehicle(
      "2015",
      "mini",
      "countryman",
      "phoenixpulsar.testnet",
      "new",
      "20150101"
    );

    expect(model.vehicles.get(newVehicle.id)).toStrictEqual(newVehicle);
  });

  it("creates a new vehicle and adds a service", () => {
    const newVehicle = contract.add_vehicle(
      "2018",
      "ford",
      "f-150",
      "phoenixpulsar.testnet",
      "new",
      "20180101"
    );

    const newService = contract.add_vehicle_service(
      newVehicle.id,
      "2019",
      "change oil"
    );

    let newVehicleWithService = model.vehicles.get(newVehicle.id);
    if (newVehicleWithService !== null) {
      expect(newVehicleWithService.serviceIds.has(newService.id));
    }
    expect(model.vehicleService.get(newService.id)).toStrictEqual(newService);
  });

  it("updates a vehicle", () => {
    const newVehicle = contract.add_vehicle(
      "2018",
      "ford",
      "f-150",
      "phoenixpulsar.testnet",
      "new",
      "20180101"
    );

    contract.update_vehicle(
      newVehicle.id,
      "2017",
      "Ford",
      "F-150",
      "tester.testnet",
      "NEW",
      "20170101"
    );
    let updatedVehicle = model.vehicles.get(newVehicle.id);
    if (updatedVehicle !== null) {
      expect(updatedVehicle.year).toBe("2017");
      expect(updatedVehicle.model).toBe("F-150");
      expect(updatedVehicle.make).toBe("Ford");
      expect(updatedVehicle.vehicleNotes).toBe("NEW");
      expect(updatedVehicle.dateAcquired).toBe("20170101");
    }
  });

  it("deletes a vehicle", () => {
    const newVehicle = contract.add_vehicle(
      "2018",
      "ford",
      "f-150",
      "phoenixpulsar.testnet",
      "new",
      "20180101"
    );

    contract.delete_vehicle(newVehicle.id);
    expect(model.vehicles.contains(newVehicle.id)).toBeFalsy();
  });

  it("updates a service", () => {
    const newVehicle = contract.add_vehicle(
      "2018",
      "ford",
      "f-150",
      "phoenixpulsar.testnet",
      "new",
      "20180101"
    );

    const newService = contract.add_vehicle_service(
      newVehicle.id,
      "2019",
      "change oil"
    );

    contract.update_vehicle_service(
      newService.id,
      newVehicle.id,
      "2020",
      "Change Oil and Filter"
    );
    let updatedService = model.vehicleService.get(newService.id);
    if (updatedService !== null) {
      expect(updatedService.serviceDate).toBe("2020");
      expect(updatedService.serviceNotes).toBe("Change Oil and Filter");
    }
  });

  it("deletes a service", () => {
    const newVehicle = contract.add_vehicle(
      "2018",
      "ford",
      "f-150",
      "phoenixpulsar.testnet",
      "new",
      "20180101"
    );

    const newService = contract.add_vehicle_service(
      newVehicle.id,
      "2019",
      "change oil"
    );

    contract.delete_vehicle_service(newService.id);
    expect(model.vehicleService.contains(newService.id)).toBeFalsy();
  });
});

'''
'''--- src/vehicleGarage/asconfig.json ---
{
  "extends": "near-sdk-as/asconfig.json"
}

'''
'''--- src/vehicleGarage/assembly/index.ts ---
import { storage } from "near-sdk-as";
import {
  VehicleId,
  VehicleServiceId,
  AccountId,
  GARAGE_KEY,
} from "../../utils";
import { Vehicle, VehicleGarage, VehicleService } from "./models";

export function init(): void {
  VehicleGarage.create_garage();
}
export function get_vehicle_garage(): VehicleGarage {
  assert_contract_is_initialized();
  return VehicleGarage.get_garage();
}
export function add_vehicle(
  year: string,
  make: string,
  model: string,
  owner: AccountId,
  vehicleNotes: string,
  dateAcquired: string
): Vehicle {
  assert_contract_is_initialized();
  return VehicleGarage.add_vehicle(
    year,
    make,
    model,
    owner,
    vehicleNotes,
    dateAcquired
  );
}
export function update_vehicle(
  vehicleId: VehicleId,
  year: string,
  make: string,
  model: string,
  owner: AccountId,
  vehicleNotes: string,
  dateAcquired: string
): void {
  assert_contract_is_initialized();
  VehicleGarage.update_vehicle(
    vehicleId,
    year,
    make,
    model,
    owner,
    vehicleNotes,
    dateAcquired
  );
}
export function delete_vehicle(vehicleId: VehicleId): void {
  assert_contract_is_initialized();
  VehicleGarage.delete_vehicle(vehicleId);
}
export function add_vehicle_service(
  vehicleId: VehicleId,
  serviceDate: string,
  serviceNotes: string
): VehicleService {
  assert_contract_is_initialized();
  return VehicleGarage.add_vehicle_service(
    vehicleId,
    serviceDate,
    serviceNotes
  );
}
export function update_vehicle_service(
  vehicleServiceId: VehicleServiceId,
  vehicleId: VehicleId,
  serviceDate: string,
  serviceNotes: string
): void {
  assert_contract_is_initialized();
  VehicleGarage.update_vehicle_service(
    vehicleServiceId,
    vehicleId,
    serviceDate,
    serviceNotes
  );
}
export function delete_vehicle_service(
  vehicleServiceId: VehicleServiceId
): void {
  assert_contract_is_initialized();
  VehicleGarage.delete_vehicle_service(vehicleServiceId);
}

function is_initialized(): bool {
  return storage.hasKey(GARAGE_KEY);
}
function assert_contract_is_initialized(): void {
  assert(is_initialized(), "Contract must be initialized first.");
}

'''
'''--- src/vehicleGarage/assembly/models.ts ---
import { context, storage, PersistentMap, PersistentSet } from "near-sdk-as";

import {
  VehicleId,
  VehicleServiceId,
  AccountId,
  Timestamp,
  idCreator,
  GARAGE_KEY,
} from "../../utils";

@nearBindgen
export class Vehicle {
  public id: VehicleId = idCreator();
  public serviceIds: PersistentSet<VehicleServiceId> = new PersistentSet<VehicleServiceId>(
    "s"
  );
  created_at: Timestamp = context.blockTimestamp;

  constructor(
    public year: string,
    public make: string,
    public model: string,
    public owner: AccountId,
    public vehicleNotes: string,
    public dateAcquired: string
  ) {}
}
@nearBindgen
export class VehicleService {
  public id: VehicleServiceId = idCreator();
  created_at: Timestamp = context.blockTimestamp;

  constructor(
    public vehicleId: VehicleId,
    public serviceDate: string,
    public serviceNotes: string
  ) {}
}

@nearBindgen
export class VehicleGarage {
  creator: AccountId = context.predecessor;
  created_at: Timestamp = context.blockTimestamp;

  static create_garage(): void {
    const garage = new VehicleGarage();
    this.set_garage(garage);
  }

  static get_garage(): VehicleGarage {
    return storage.getSome<VehicleGarage>(GARAGE_KEY);
  }

  static set_garage(garage: VehicleGarage): void {
    storage.set(GARAGE_KEY, garage);
  }

  // -------------------------------------------
  // Vehicles
  // -------------------------------------------

  static add_vehicle(
    year: string,
    make: string,
    model: string,
    owner: AccountId,
    vehicleNotes: string,
    dateAcquired: string
  ): Vehicle {
    let newVehicle = new Vehicle(
      year,
      make,
      model,
      owner,
      dateAcquired,
      vehicleNotes
    );
    vehicles.set(newVehicle.id, newVehicle);
    return newVehicle;
  }

  static update_vehicle(
    vehicleId: VehicleId,
    year: string,
    make: string,
    model: string,
    owner: AccountId,
    vehicleNotes: string,
    dateAcquired: string
  ): void {
    let currentVehicle = vehicles.get(vehicleId);
    if (currentVehicle !== null) {
      currentVehicle.year = year;
      currentVehicle.make = make;
      currentVehicle.model = model;
      currentVehicle.owner = owner;
      currentVehicle.vehicleNotes = vehicleNotes;
      currentVehicle.dateAcquired = dateAcquired;
      vehicles.set(vehicleId, currentVehicle);
    }
  }

  static delete_service_id_from_vehicle(
    vehicleId: VehicleId,
    vehicleServiceId: VehicleServiceId
  ): void {
    let currentVehicle = vehicles.get(vehicleId);
    if (currentVehicle !== null) {
      let serviceIds = currentVehicle.serviceIds;
      serviceIds.delete(vehicleServiceId);
      vehicles.set(vehicleId, currentVehicle);
    }
  }

  static delete_vehicle(vehicleId: VehicleId): void {
    // grab all service ids
    let currentVehicle = vehicles.get(vehicleId);

    if (currentVehicle !== null) {
      let vehicleServiceIds = currentVehicle.serviceIds.values();
      // delete all services from vehicle
      if (vehicleServiceIds.length) {
        for (let i = 0; i < vehicleServiceIds.length; ++i) {
          VehicleGarage.delete_vehicle_service(vehicleServiceIds[i]);
        }
      }
    }

    // delete vehicle
    vehicles.delete(vehicleId);
  }

  // -------------------------------------------
  // Vehicle Services
  // -------------------------------------------

  static add_vehicle_service(
    vehicleId: VehicleId,
    serviceDate: string,
    serviceNotes: string
  ): VehicleService {
    let newVehicleService = new VehicleService(
      vehicleId,
      serviceDate,
      serviceNotes
    );
    vehicleService.set(newVehicleService.id, newVehicleService);
    VehicleGarage.add_service_id(vehicleId, newVehicleService.id);
    return newVehicleService;
  }

  static add_service_id(
    vehicleId: VehicleId,
    vehicleServiceId: VehicleServiceId
  ): void {
    let currentVehicle = vehicles.get(vehicleId);
    if (currentVehicle !== null) {
      currentVehicle.serviceIds.add(vehicleServiceId);
      vehicles.set(vehicleId, currentVehicle);
    }
  }

  static update_vehicle_service(
    vehicleServiceId: VehicleServiceId,
    vehicleId: VehicleId,
    serviceDate: string,
    serviceNotes: string
  ): void {
    let currentVehicleService = vehicleService.get(vehicleServiceId);
    if (currentVehicleService !== null) {
      currentVehicleService.vehicleId = vehicleId;
      currentVehicleService.serviceDate = serviceDate;
      currentVehicleService.serviceNotes = serviceNotes;
      vehicleService.set(vehicleServiceId, currentVehicleService);
    }
  }

  static delete_vehicle_service(vehicleServiceId: VehicleServiceId): void {
    let currentVehicleService = vehicleService.get(vehicleServiceId);
    if (currentVehicleService !== null) {
      let currentVehicleId = currentVehicleService.vehicleId;
      VehicleGarage.delete_service_id_from_vehicle(
        currentVehicleId,
        vehicleServiceId
      );
    }
    vehicleService.delete(vehicleServiceId);
  }
}

export const vehicles = new PersistentMap<VehicleId, Vehicle>("v");
export const vehicleService = new PersistentMap<
  VehicleServiceId,
  VehicleService
>("vs");

'''