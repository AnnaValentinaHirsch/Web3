*GitHub Repository "near/near-account-id-rs"*

'''--- .github/workflows/ci.yml ---
name: Main

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

env:
  CARGO_TERM_COLOR: always

jobs:
  test:
    runs-on: ubuntu-latest
    container:
      image: rust:1.65.0
    steps:
    - uses: actions/checkout@v3
    - uses: Swatinem/rust-cache@v1
    - name: Build
      run:  cargo build --verbose --locked
    - name: Run tests
      run: cargo test --workspace --verbose --locked
  test-all:
    runs-on: ubuntu-latest
    container:
      image: rust:1.66.0
    steps:
      - uses: actions/checkout@v3
      - uses: Swatinem/rust-cache@v1
      - name: Build
        run:  cargo build --verbose --locked --all-features
      - name: Run tests
        run: cargo test --all-features --workspace --verbose --locked
  clippy:
    runs-on: ubuntu-latest
    container:
      image: rust:1.66.0
    steps:
      - uses: actions/checkout@v3
      - uses: Swatinem/rust-cache@v1
      - name: Install clippy
        run: rustup component add clippy
      - name: Run clippy
        run: cargo clippy --all-features

'''
'''--- .github/workflows/dep-reqs.yml ---
name: Dep reqs

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]
  schedule:
    - cron:  '0 5 * * *'

env:
  CARGO_TERM_COLOR: always

jobs:
  minimal-deps:
    # Build and test with the oldest possible versions of deps. This helps ensure the semver requirements for deps
    # are OK.
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    - name: Install Rust toolchain
      uses: dtolnay/rust-toolchain@1.65
    - uses: Swatinem/rust-cache@v1
    - name: Set up nightly
      run: |
        rustup install nightly-2023-06-15
        rustup default nightly-2023-06-15
    - name: Remove Cargo.lock
      run: rm Cargo.lock
    - name: Build
      run: cargo build --all-features -Zminimal-versions --verbose
    - name: Run tests
      run: cargo test --all-features --workspace -Zminimal-versions --verbose
  maximal-deps:
    # Build and test with the newest possible versions of deps. This helps ensure the semver requirements for deps
    # are OK.
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - name: Install Rust toolchain
      uses: dtolnay/rust-toolchain@stable
    - uses: Swatinem/rust-cache@v1
    - name: Update Cargo.lock
      run: cargo update
    - name: Build
      run: cargo build --all-features --verbose
    - name: Run tests
      run: cargo test --all-features --workspace --verbose

'''
'''--- .github/workflows/release-plz.yml ---
name: Release-plz

permissions:
  pull-requests: write
  contents: write

on:
  push:
    branches: [ main ]

jobs:
  release-plz:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.MY_GITHUB_TOKEN }}
      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable
      - name: Run release-plz
        uses: MarcoIeni/release-plz-action@v0.5
        env:
          # https://release-plz.ieni.dev/docs/github/trigger
          GITHUB_TOKEN: ${{ secrets.MY_GITHUB_TOKEN }}
          CARGO_REGISTRY_TOKEN: ${{ secrets.CARGO_REGISTRY_TOKEN }}

'''
'''--- CHANGELOG.md ---
# Changelog
All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

## 1.0.0 - 2023-12-22

This is the first stable release of near-account-id crate!

`AccountId` and `AccountIdRef` are two main types of this crate that have same relation as `String` and `str` in standard library of Rust.

AccountId guarantees to hold a valid NEAR account id (unless users explicitly opt-in for the unvalidated constructors feature and break this promise).

See all the changes listed in alpha releases below to learn about `AccountIdRef` and various new helper methods.

### Added
- Add `get_parent_account_id` method ([#24](https://github.com/near/near-account-id-rs/pull/24))

## [1.0.0-alpha.4](https://github.com/near/near-account-id-rs/compare/v1.0.0-alpha.3...v1.0.0-alpha.4) - 2023-11-24

### Fixed
- Remove account_id validation from `new_unvalidated()` when `internal_unstable` feature is enabled (required by nearcore) ([#20](https://github.com/near/near-account-id-rs/pull/20))

## [1.0.0-alpha.3](https://github.com/near/near-account-id-rs/compare/v1.0.0-alpha.2...v1.0.0-alpha.3) - 2023-11-06

### Other
- Add schemars support ([#17](https://github.com/near/near-account-id-rs/pull/17))

## [1.0.0-alpha.2](https://github.com/near/near-account-id-rs/compare/v1.0.0-alpha.1...v1.0.0-alpha.2) - 2023-11-03

### Other
- `AccountType`, add `EthImplicitAccount` ([#14](https://github.com/near/near-account-id-rs/pull/14))

## 1.0.0-alpha.1 - 2023-10-24

near-account-id was extracted from [nearcore](https://github.com/near/nearcore) as of 2023-08-01, and extended with the following features to reach stable 1.0.0 release.

### Added
- Introduce `AccountIdRef`, move all `AccountId` methods to `AccountIdRef`, and more idiomatic AsRef/Borrow impls
- Added `len` method ([#13](https://github.com/near/near-account-id/pull/13))
- Added const `AccountIdRef::new_or_panic` ([#12](https://github.com/near/near-account-id/pull/12))
- Added missing serde/borsh implementations for `AccountIdRef`
- Upgrade `borsh` dependency to 1.0 ([#8](https://github.com/near/near-account-id/pull/8))
- Implemented `Arbitrary` for `AccountIdRef`

### Other
- Use stable Rust version for maximal-deps test ([#7](https://github.com/near/near-account-id/pull/7))
- Added automated release pipeline (release-plz!)
- bump MSRV to 1.65

'''
'''--- Cargo.toml ---
[package]
name = "near-account-id"
version = "1.0.0"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2021"
description = "This crate contains the Account ID primitive and its validation facilities"
repository = "https://github.com/near/near-account-id"
license = "MIT OR Apache-2.0"
publish = true

[features]
abi = ["borsh/unstable__schema", "schemars"]
# This feature was introduced for legacy reasons for nearcore, and MUST be avoided
# https://github.com/near/nearcore/pull/4621#issuecomment-892099860
internal_unstable = []
default = []

[dependencies]
arbitrary = {  version = "1", features = ["derive"] , optional = true }
borsh = { version = "1.0.0", features = ["rc"], optional = true }
serde = { version = "1.0.119", features = ["alloc", "derive", "rc"], optional = true }
schemars = { version = "0.8", optional = true }

[dev-dependencies]
bolero = ">=0.8.0, <0.10.0"
serde_json = "1.0.25"

# We don't use these directly - we just need to tighten the version requirements to block dependency resolution
# from choosing old versions that cause compilation errors. These problems are usually detected by the
# "minimal-deps" CI job.
anyhow = "1.0.14"
backtrace = "0.3.13"
lazy_static = "1.0.2"

'''
'''--- README.md ---
# near-account-id

This crate provides a type for representing a syntactically valid, unique account identifier on the [NEAR](https://near.org) network, according to the [NEAR Account ID](https://docs.near.org/concepts/basics/account#account-id-rules) rules.

[![crates.io](https://img.shields.io/crates/v/near-account-id?label=latest)](https://crates.io/crates/near-account-id)
[![Documentation](https://docs.rs/near-account-id/badge.svg)](https://docs.rs/near-account-id)
![MIT or Apache 2.0 licensed](https://img.shields.io/crates/l/near-account-id.svg)

## Usage

```rust
use near_account_id::AccountId;

let alice: AccountId = "alice.near".parse()?;

assert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f)
```

See the [docs](https://docs.rs/near-account-id) for more information.

## License

Licensed under either of

- Apache License, Version 2.0
   ([LICENSE-APACHE](LICENSE-APACHE) or <http://www.apache.org/licenses/LICENSE-2.0>)
- MIT license
   ([LICENSE-MIT](LICENSE-MIT) or <http://opensource.org/licenses/MIT>)

at your option.

## Minimum Supported Rust Version (MSRV)

1.65

## Contribution

Unless you explicitly state otherwise, any contribution intentionally submitted
for inclusion in the work by you, as defined in the Apache-2.0 license, shall be
dual licensed as above, without any additional terms or conditions.

'''
'''--- fuzz/Cargo.toml ---
[package]
name = "near-account-id-fuzz"
version = "0.0.0"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2021"
repository = "https://github.com/near/near-account-id"
license = "MIT OR Apache-2.0"
publish = false

[package.metadata]
cargo-fuzz = true

[dependencies]
libfuzzer-sys = { version = ">=0.2.0, <0.5", features = ["arbitrary-derive"] }
borsh = { version = "0.10", features = ["rc"] }
serde_json = "1.0.25"
near-account-id = { path = ".." }

[[bin]]
name = "serde"
path = "fuzz_targets/serde.rs"
test = false
doc = false

[[bin]]
name = "borsh"
path = "fuzz_targets/borsh.rs"
test = false
doc = false

'''
'''--- fuzz/README.md ---
## Fuzzing `near-account-id`

### Setup

First, ensure [`cargo-fuzz`](https://github.com/rust-fuzz/cargo-fuzz) is installed:

```console
cargo install cargo-fuzz
```

### Execution

Finally, there are two fuzzing targets available: one for [`serde`](https://github.com/serde-rs/serde) and another for [`borsh`](https://github.com/near/borsh-rs). You can run both tests with:

```console
cd core/account-id/fuzz
RUSTC_BOOTSTRAP=1 cargo fuzz run serde
RUSTC_BOOTSTRAP=1 cargo fuzz run borsh
```

By default each fuzz test runs infinitely. To specify how many runs each test is allowed, you can use this:

```console
RUSTC_BOOTSTRAP=1 cargo fuzz run serde -runs=1000000000
RUSTC_BOOTSTRAP=1 cargo fuzz run borsh -runs=1000000000
```

'''
'''--- fuzz/fuzz_targets/borsh.rs ---
#![no_main]

use borsh::{BorshDeserialize, BorshSerialize};
use libfuzzer_sys::fuzz_target;
use near_account_id::AccountId;

fuzz_target!(|bytes: &[u8]| {
    if let Ok(account_id) = AccountId::try_from_slice(bytes) {
        assert_eq!(
            account_id,
            AccountId::try_from_slice(account_id.try_to_vec().unwrap().as_slice()).unwrap()
        );
    }
});

'''
'''--- fuzz/fuzz_targets/serde.rs ---
#![no_main]

use std::str;

use libfuzzer_sys::fuzz_target;
use near_account_id::AccountId;
use serde_json::json;

fuzz_target!(|bytes: &[u8]| {
    if let Ok(account_id) = str::from_utf8(bytes) {
        if let Ok(account_id) = serde_json::from_value::<AccountId>(json!(account_id)) {
            assert_eq!(
                account_id,
                serde_json::from_value(serde_json::to_value(&account_id).unwrap()).unwrap()
            );
        }
    }
});

'''
'''--- src/account_id.rs ---
use std::{borrow::Cow, fmt, ops::Deref, str::FromStr};

use crate::{AccountIdRef, ParseAccountError};

/// NEAR Account Identifier.
///
/// This is a unique, syntactically valid, human-readable account identifier on the NEAR network.
///
/// [See the crate-level docs for information about validation.](index.html#account-id-rules)
///
/// Also see [Error kind precedence](AccountId#error-kind-precedence).
///
/// ## Examples
///
/// ```
/// use near_account_id::AccountId;
///
/// let alice: AccountId = "alice.near".parse().unwrap();
///
/// assert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f)
/// ```
#[derive(Eq, Ord, Hash, Clone, Debug, PartialEq, PartialOrd)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[cfg_attr(feature = "abi", derive(borsh::BorshSchema))]
pub struct AccountId(pub(crate) Box<str>);

impl AccountId {
    /// Shortest valid length for a NEAR Account ID.
    pub const MIN_LEN: usize = crate::validation::MIN_LEN;
    /// Longest valid length for a NEAR Account ID.
    pub const MAX_LEN: usize = crate::validation::MAX_LEN;

    /// Creates an `AccountId` without any validation checks.
    ///
    /// Please note that this is restrictively for internal use only. Plus, being behind a feature flag,
    /// this could be removed later in the future.
    ///
    /// ## Safety
    ///
    /// Since this skips validation and constructs an `AccountId` regardless,
    /// the caller bears the responsibility of ensuring that the Account ID is valid.
    /// You can use the [`AccountId::validate`] function sometime after its creation but before it's use.
    ///
    /// ## Examples
    ///
    /// ```
    /// use near_account_id::AccountId;
    ///
    /// let alice = AccountId::new_unvalidated("alice.near".to_string());
    /// assert!(AccountId::validate(alice.as_str()).is_ok());
    /// ```
    #[doc(hidden)]
    #[cfg(feature = "internal_unstable")]
    #[deprecated = "AccountId construction without validation is illegal since nearcore#4440"]
    pub fn new_unvalidated(account_id: String) -> Self {
        Self(account_id.into_boxed_str())
    }

    /// Validates a string as a well-structured NEAR Account ID.
    ///
    /// Checks Account ID validity without constructing an `AccountId` instance.
    ///
    /// ## Examples
    ///
    /// ```
    /// use near_account_id::{AccountId, ParseErrorKind};
    ///
    /// assert!(AccountId::validate("alice.near").is_ok());
    ///
    /// assert!(
    ///   matches!(
    ///     AccountId::validate("ƒelicia.near"), // fancy ƒ!
    ///     Err(err) if err.kind() == &ParseErrorKind::InvalidChar
    ///   )
    /// );
    /// ```
    ///
    /// ## Error kind precedence
    ///
    /// If an Account ID has multiple format violations, the first one would be reported.
    ///
    /// ### Examples
    ///
    /// ```
    /// use near_account_id::{AccountId, ParseErrorKind};
    ///
    /// assert!(
    ///   matches!(
    ///     AccountId::validate("A__ƒƒluent."),
    ///     Err(err) if err.kind() == &ParseErrorKind::InvalidChar
    ///   )
    /// );
    ///
    /// assert!(
    ///   matches!(
    ///     AccountId::validate("a__ƒƒluent."),
    ///     Err(err) if err.kind() == &ParseErrorKind::RedundantSeparator
    ///   )
    /// );
    ///
    /// assert!(
    ///   matches!(
    ///     AccountId::validate("aƒƒluent."),
    ///     Err(err) if err.kind() == &ParseErrorKind::InvalidChar
    ///   )
    /// );
    ///
    /// assert!(
    ///   matches!(
    ///     AccountId::validate("affluent."),
    ///     Err(err) if err.kind() == &ParseErrorKind::RedundantSeparator
    ///   )
    /// );
    /// ```
    pub fn validate(account_id: &str) -> Result<(), ParseAccountError> {
        crate::validation::validate(account_id)
    }
}

impl AsRef<str> for AccountId {
    fn as_ref(&self) -> &str {
        &self.0
    }
}

impl AsRef<AccountIdRef> for AccountId {
    fn as_ref(&self) -> &AccountIdRef {
        self
    }
}

impl Deref for AccountId {
    type Target = AccountIdRef;

    fn deref(&self) -> &Self::Target {
        AccountIdRef::new_unvalidated(&self.0)
    }
}

impl std::borrow::Borrow<AccountIdRef> for AccountId {
    fn borrow(&self) -> &AccountIdRef {
        AccountIdRef::new_unvalidated(self)
    }
}

impl FromStr for AccountId {
    type Err = ParseAccountError;

    fn from_str(account_id: &str) -> Result<Self, Self::Err> {
        crate::validation::validate(account_id)?;
        Ok(Self(account_id.into()))
    }
}

impl TryFrom<Box<str>> for AccountId {
    type Error = ParseAccountError;

    fn try_from(account_id: Box<str>) -> Result<Self, Self::Error> {
        crate::validation::validate(&account_id)?;
        Ok(Self(account_id))
    }
}

impl TryFrom<String> for AccountId {
    type Error = ParseAccountError;

    fn try_from(account_id: String) -> Result<Self, Self::Error> {
        crate::validation::validate(&account_id)?;
        Ok(Self(account_id.into_boxed_str()))
    }
}

impl fmt::Display for AccountId {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self.0, f)
    }
}

impl From<AccountId> for String {
    fn from(account_id: AccountId) -> Self {
        account_id.0.into_string()
    }
}

impl From<AccountId> for Box<str> {
    fn from(value: AccountId) -> Box<str> {
        value.0
    }
}

impl PartialEq<AccountId> for AccountIdRef {
    fn eq(&self, other: &AccountId) -> bool {
        &self.0 == other.as_str()
    }
}

impl PartialEq<AccountIdRef> for AccountId {
    fn eq(&self, other: &AccountIdRef) -> bool {
        self.as_str() == &other.0
    }
}

impl<'a> PartialEq<AccountId> for &'a AccountIdRef {
    fn eq(&self, other: &AccountId) -> bool {
        &self.0 == other.as_str()
    }
}

impl<'a> PartialEq<&'a AccountIdRef> for AccountId {
    fn eq(&self, other: &&'a AccountIdRef) -> bool {
        self.as_str() == &other.0
    }
}

impl PartialEq<AccountId> for String {
    fn eq(&self, other: &AccountId) -> bool {
        self == other.as_str()
    }
}

impl PartialEq<String> for AccountId {
    fn eq(&self, other: &String) -> bool {
        self.as_str() == other
    }
}

impl PartialEq<AccountId> for str {
    fn eq(&self, other: &AccountId) -> bool {
        self == other.as_str()
    }
}

impl PartialEq<str> for AccountId {
    fn eq(&self, other: &str) -> bool {
        self.as_str() == other
    }
}

impl<'a> PartialEq<AccountId> for &'a str {
    fn eq(&self, other: &AccountId) -> bool {
        *self == other.as_str()
    }
}

impl<'a> PartialEq<&'a str> for AccountId {
    fn eq(&self, other: &&'a str) -> bool {
        self.as_str() == *other
    }
}

impl PartialOrd<AccountId> for AccountIdRef {
    fn partial_cmp(&self, other: &AccountId) -> Option<std::cmp::Ordering> {
        self.0.partial_cmp(other.as_str())
    }
}

impl PartialOrd<AccountIdRef> for AccountId {
    fn partial_cmp(&self, other: &AccountIdRef) -> Option<std::cmp::Ordering> {
        self.as_str().partial_cmp(&other.0)
    }
}

impl<'a> PartialOrd<AccountId> for &'a AccountIdRef {
    fn partial_cmp(&self, other: &AccountId) -> Option<std::cmp::Ordering> {
        self.0.partial_cmp(other.as_str())
    }
}

impl<'a> PartialOrd<&'a AccountIdRef> for AccountId {
    fn partial_cmp(&self, other: &&'a AccountIdRef) -> Option<std::cmp::Ordering> {
        self.as_str().partial_cmp(&other.0)
    }
}

impl PartialOrd<AccountId> for String {
    fn partial_cmp(&self, other: &AccountId) -> Option<std::cmp::Ordering> {
        self.as_str().partial_cmp(other.as_str())
    }
}

impl PartialOrd<String> for AccountId {
    fn partial_cmp(&self, other: &String) -> Option<std::cmp::Ordering> {
        self.as_str().partial_cmp(other.as_str())
    }
}

impl PartialOrd<AccountId> for str {
    fn partial_cmp(&self, other: &AccountId) -> Option<std::cmp::Ordering> {
        self.partial_cmp(other.as_str())
    }
}

impl PartialOrd<str> for AccountId {
    fn partial_cmp(&self, other: &str) -> Option<std::cmp::Ordering> {
        self.as_str().partial_cmp(other)
    }
}

impl<'a> PartialOrd<AccountId> for &'a str {
    fn partial_cmp(&self, other: &AccountId) -> Option<std::cmp::Ordering> {
        self.partial_cmp(&other.as_str())
    }
}

impl<'a> PartialOrd<&'a str> for AccountId {
    fn partial_cmp(&self, other: &&'a str) -> Option<std::cmp::Ordering> {
        self.as_str().partial_cmp(*other)
    }
}

impl<'a> From<AccountId> for Cow<'a, AccountIdRef> {
    fn from(value: AccountId) -> Self {
        Cow::Owned(value)
    }
}

impl<'a> From<&'a AccountId> for Cow<'a, AccountIdRef> {
    fn from(value: &'a AccountId) -> Self {
        Cow::Borrowed(value)
    }
}

impl<'a> From<Cow<'a, AccountIdRef>> for AccountId {
    fn from(value: Cow<'a, AccountIdRef>) -> Self {
        value.into_owned()
    }
}

#[cfg(feature = "arbitrary")]
impl<'a> arbitrary::Arbitrary<'a> for AccountId {
    fn size_hint(depth: usize) -> (usize, Option<usize>) {
        <&AccountIdRef as arbitrary::Arbitrary>::size_hint(depth)
    }

    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(u.arbitrary::<&AccountIdRef>()?.into())
    }

    fn arbitrary_take_rest(u: arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        Ok(<&AccountIdRef as arbitrary::Arbitrary>::arbitrary_take_rest(u)?.into())
    }
}

#[cfg(test)]
mod tests {
    #[allow(unused_imports)]
    use super::*;

    #[test]
    #[cfg(feature = "arbitrary")]
    fn test_arbitrary() {
        let corpus = [
            ("a|bcd", None),
            ("ab|cde", Some("ab")),
            ("a_-b", None),
            ("ab_-c", Some("ab")),
            ("a", None),
            ("miraclx.near", Some("miraclx.near")),
            (
                "01234567890123456789012345678901234567890123456789012345678901234",
                None,
            ),
        ];

        for (input, expected_output) in corpus {
            assert!(input.len() <= u8::MAX as usize);
            let data = [input.as_bytes(), &[input.len() as _]].concat();
            let mut u = arbitrary::Unstructured::new(&data);

            assert_eq!(
                u.arbitrary::<AccountId>().map(Into::<String>::into).ok(),
                expected_output.map(Into::<String>::into)
            );
        }
    }
    #[test]
    #[cfg(feature = "schemars")]
    fn test_schemars() {
        let schema = schemars::schema_for!(AccountId);
        let json_schema = serde_json::to_value(&schema).unwrap();
        dbg!(&json_schema);
        assert_eq!(
            json_schema,
            serde_json::json!({
                    "$schema": "http://json-schema.org/draft-07/schema#",
                    "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                    "title": "AccountId",
                    "type": "string"
                }
            )
        );
    }
}

'''
'''--- src/account_id_ref.rs ---
use std::borrow::Cow;

use crate::{AccountId, ParseAccountError};

/// Account identifier. This is the human readable UTF-8 string which is used internally to index
/// accounts on the network and their respective state.
///
/// This is the "referenced" version of the account ID. It is to [`AccountId`] what [`str`] is to [`String`],
/// and works quite similarly to [`Path`]. Like with [`str`] and [`Path`], you
/// can't have a value of type `AccountIdRef`, but you can have a reference like `&AccountIdRef` or
/// `&mut AccountIdRef`.
///
/// This type supports zero-copy deserialization offered by [`serde`](https://docs.rs/serde/), but cannot
/// do the same for [`borsh`](https://docs.rs/borsh/) since the latter does not support zero-copy.
///
/// # Examples
/// ```
/// use near_account_id::{AccountId, AccountIdRef};
/// use std::convert::{TryFrom, TryInto};
///
/// // Construction
/// let alice = AccountIdRef::new("alice.near").unwrap();
/// assert!(AccountIdRef::new("invalid.").is_err());
/// ```
///
/// [`FromStr`]: std::str::FromStr
/// [`Path`]: std::path::Path
#[derive(Debug, PartialEq, PartialOrd, Ord, Eq, Hash)]
#[cfg_attr(feature = "schemars", derive(schemars::JsonSchema))]
#[cfg_attr(feature = "abi", derive(borsh::BorshSchema))]
pub struct AccountIdRef(pub(crate) str);

/// Enum representing possible types of accounts.
/// This `enum` is returned by the [`get_account_type`] method on [`AccountIdRef`].
/// See its documentation for more.
///
/// [`get_account_type`]: AccountIdRef::get_account_type
/// [`AccountIdRef`]: struct.AccountIdRef.html
#[derive(PartialEq)]
pub enum AccountType {
    /// Any valid account, that is neither NEAR-implicit nor ETH-implicit.
    NamedAccount,
    /// An account with 64 characters long hexadecimal address.
    NearImplicitAccount,
    /// An account which address starts with '0x', followed by 40 hex characters.
    EthImplicitAccount,
}

impl AccountType {
    pub fn is_implicit(&self) -> bool {
        match &self {
            Self::NearImplicitAccount => true,
            Self::EthImplicitAccount => true,
            Self::NamedAccount => false,
        }
    }
}

impl AccountIdRef {
    /// Shortest valid length for a NEAR Account ID.
    pub const MIN_LEN: usize = crate::validation::MIN_LEN;
    /// Longest valid length for a NEAR Account ID.
    pub const MAX_LEN: usize = crate::validation::MAX_LEN;

    /// Construct a [`&AccountIdRef`](AccountIdRef) from a string reference.
    ///
    /// This constructor validates the provided ID, and will produce an error when validation fails.
    pub fn new<S: AsRef<str> + ?Sized>(id: &S) -> Result<&Self, ParseAccountError> {
        let id = id.as_ref();
        crate::validation::validate(id)?;

        // Safety:
        // - a newtype struct is guaranteed to have the same memory layout as its only field
        // - the borrow checker will enforce its rules appropriately on the resulting reference
        Ok(unsafe { &*(id as *const str as *const Self) })
    }

    /// Construct a [`&AccountIdRef`](AccountIdRef) from with validation at compile time.
    /// This constructor will panic if validation fails.
    /// ```rust
    /// use near_account_id::AccountIdRef;
    /// const ALICE: &AccountIdRef = AccountIdRef::new_or_panic("alice.near");
    /// ```
    pub const fn new_or_panic(id: &str) -> &Self {
        crate::validation::validate_const(id);

        unsafe { &*(id as *const str as *const Self) }
    }

    /// Construct a [`&AccountIdRef`](AccountIdRef) from a string reference without validating the address.
    /// It is the responsibility of the caller to ensure the account ID is valid.
    ///
    /// For more information, read: <https://docs.near.org/docs/concepts/account#account-id-rules>
    pub(crate) fn new_unvalidated<S: AsRef<str> + ?Sized>(id: &S) -> &Self {
        let id = id.as_ref();
        // In nearcore, due to legacy reasons, AccountId construction and validation are separated.
        // In order to avoid protocol change, `internal_unstable` feature was implemented and it is
        // expected that AccountId might be invalid and it will be explicitly validated at the
        // later stage.
        #[cfg(not(feature = "internal_unstable"))]
        debug_assert!(crate::validation::validate(id).is_ok());

        // Safety: see `AccountIdRef::new`
        unsafe { &*(id as *const str as *const Self) }
    }

    /// Returns a reference to the account ID bytes.
    pub fn as_bytes(&self) -> &[u8] {
        self.0.as_bytes()
    }

    /// Returns a string slice of the entire Account ID.
    ///
    /// ## Examples
    ///
    /// ```
    /// use near_account_id::AccountIdRef;
    ///
    /// let carol = AccountIdRef::new("carol.near").unwrap();
    /// assert_eq!("carol.near", carol.as_str());
    /// ```
    pub fn as_str(&self) -> &str {
        &self.0
    }

    /// Returns `true` if the account ID is a top-level NEAR Account ID.
    ///
    /// See [Top-level Accounts](https://docs.near.org/docs/concepts/account#top-level-accounts).
    ///
    /// ## Examples
    ///
    /// ```
    /// use near_account_id::AccountIdRef;
    ///
    /// let near_tla = AccountIdRef::new("near").unwrap();
    /// assert!(near_tla.is_top_level());
    ///
    /// // "alice.near" is a sub account of "near" account
    /// let alice = AccountIdRef::new("alice.near").unwrap();
    /// assert!(!alice.is_top_level());
    /// ```
    pub fn is_top_level(&self) -> bool {
        !self.is_system() && !self.0.contains('.')
    }

    /// Returns `true` if the `AccountId` is a direct sub-account of the provided parent account.
    ///
    /// See [Subaccounts](https://docs.near.org/docs/concepts/account#subaccounts).
    ///
    /// ## Examples
    ///
    /// ```
    /// use near_account_id::AccountId;
    ///
    /// let near_tla: AccountId = "near".parse().unwrap();
    /// assert!(near_tla.is_top_level());
    ///
    /// let alice: AccountId = "alice.near".parse().unwrap();
    /// assert!(alice.is_sub_account_of(&near_tla));
    ///
    /// let alice_app: AccountId = "app.alice.near".parse().unwrap();
    ///
    /// // While app.alice.near is a sub account of alice.near,
    /// // app.alice.near is not a sub account of near
    /// assert!(alice_app.is_sub_account_of(&alice));
    /// assert!(!alice_app.is_sub_account_of(&near_tla));
    /// ```
    pub fn is_sub_account_of(&self, parent: &AccountIdRef) -> bool {
        self.0
            .strip_suffix(parent.as_str())
            .and_then(|s| s.strip_suffix('.'))
            .map_or(false, |s| !s.contains('.'))
    }

    /// Returns `AccountType::EthImplicitAccount` if the `AccountId` is a 40 characters long hexadecimal prefixed with '0x'.
    /// Returns `AccountType::NearImplicitAccount` if the `AccountId` is a 64 characters long hexadecimal.
    /// Otherwise, returns `AccountType::NamedAccount`.
    ///
    /// See [Implicit-Accounts](https://docs.near.org/docs/concepts/account#implicit-accounts).
    ///
    /// ## Examples
    ///
    /// ```
    /// use near_account_id::{AccountId, AccountType};
    ///
    /// let alice: AccountId = "alice.near".parse().unwrap();
    /// assert!(alice.get_account_type() == AccountType::NamedAccount);
    ///
    /// let eth_rando = "0xb794f5ea0ba39494ce839613fffba74279579268"
    ///     .parse::<AccountId>()
    ///     .unwrap();
    /// assert!(eth_rando.get_account_type() == AccountType::EthImplicitAccount);
    ///
    /// let near_rando = "98793cd91a3f870fb126f66285808c7e094afcfc4eda8a970f6648cdf0dbd6de"
    ///     .parse::<AccountId>()
    ///     .unwrap();
    /// assert!(near_rando.get_account_type() == AccountType::NearImplicitAccount);
    /// ```
    pub fn get_account_type(&self) -> AccountType {
        if crate::validation::is_eth_implicit(self.as_str()) {
            return AccountType::EthImplicitAccount;
        }
        if crate::validation::is_near_implicit(self.as_str()) {
            return AccountType::NearImplicitAccount;
        }
        AccountType::NamedAccount
    }

    /// Returns `true` if this `AccountId` is the system account.
    ///
    /// See [System account](https://nomicon.io/DataStructures/Account.html?highlight=system#system-account).
    ///
    /// ## Examples
    ///
    /// ```
    /// use near_account_id::AccountId;
    ///
    /// let alice: AccountId = "alice.near".parse().unwrap();
    /// assert!(!alice.is_system());
    ///
    /// let system: AccountId = "system".parse().unwrap();
    /// assert!(system.is_system());
    /// ```
    pub fn is_system(&self) -> bool {
        self == "system"
    }

    /// Returns the length of the underlying account id string.
    pub const fn len(&self) -> usize {
        self.0.len()
    }

    /// Returns parent's account id reference
    ///
    /// ## Examples
    /// ```
    /// use near_account_id::AccountIdRef;
    ///
    /// let alice: &AccountIdRef = AccountIdRef::new_or_panic("alice.near");
    /// let parent: &AccountIdRef = alice.get_parent_account_id().unwrap();
    ///
    /// assert!(alice.is_sub_account_of(parent));
    ///
    /// let near: &AccountIdRef = AccountIdRef::new_or_panic("near");
    ///
    /// assert!(near.get_parent_account_id().is_none());
    ///
    /// let implicit: &AccountIdRef = AccountIdRef::new_or_panic("248e104d1d4764d713c4211c13808c8fc887869c580f4178e60538ac5c2a0b26");
    ///
    /// assert!(implicit.get_parent_account_id().is_none());
    /// ```
    pub fn get_parent_account_id(&self) -> Option<&AccountIdRef> {
        let parent_str = self.as_str().split_once('.')?.1;
        Some(AccountIdRef::new_unvalidated(parent_str))
    }
}

impl std::fmt::Display for AccountIdRef {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(&self.0, f)
    }
}

impl ToOwned for AccountIdRef {
    type Owned = AccountId;

    fn to_owned(&self) -> Self::Owned {
        AccountId(self.0.into())
    }
}

impl<'a> From<&'a AccountIdRef> for AccountId {
    fn from(id: &'a AccountIdRef) -> Self {
        id.to_owned()
    }
}

impl<'s> TryFrom<&'s str> for &'s AccountIdRef {
    type Error = ParseAccountError;

    fn try_from(value: &'s str) -> Result<Self, Self::Error> {
        AccountIdRef::new(value)
    }
}

impl AsRef<str> for AccountIdRef {
    fn as_ref(&self) -> &str {
        &self.0
    }
}

impl PartialEq<AccountIdRef> for String {
    fn eq(&self, other: &AccountIdRef) -> bool {
        self == &other.0
    }
}

impl PartialEq<String> for AccountIdRef {
    fn eq(&self, other: &String) -> bool {
        &self.0 == other
    }
}

impl PartialEq<AccountIdRef> for str {
    fn eq(&self, other: &AccountIdRef) -> bool {
        self == &other.0
    }
}

impl PartialEq<str> for AccountIdRef {
    fn eq(&self, other: &str) -> bool {
        &self.0 == other
    }
}

impl<'a> PartialEq<AccountIdRef> for &'a str {
    fn eq(&self, other: &AccountIdRef) -> bool {
        *self == &other.0
    }
}

impl<'a> PartialEq<&'a str> for AccountIdRef {
    fn eq(&self, other: &&'a str) -> bool {
        &self.0 == *other
    }
}

impl<'a> PartialEq<&'a AccountIdRef> for str {
    fn eq(&self, other: &&'a AccountIdRef) -> bool {
        self == &other.0
    }
}

impl<'a> PartialEq<str> for &'a AccountIdRef {
    fn eq(&self, other: &str) -> bool {
        &self.0 == other
    }
}

impl<'a> PartialEq<&'a AccountIdRef> for String {
    fn eq(&self, other: &&'a AccountIdRef) -> bool {
        self == &other.0
    }
}

impl<'a> PartialEq<String> for &'a AccountIdRef {
    fn eq(&self, other: &String) -> bool {
        &self.0 == other
    }
}

impl PartialOrd<AccountIdRef> for String {
    fn partial_cmp(&self, other: &AccountIdRef) -> Option<std::cmp::Ordering> {
        self.as_str().partial_cmp(&other.0)
    }
}

impl PartialOrd<String> for AccountIdRef {
    fn partial_cmp(&self, other: &String) -> Option<std::cmp::Ordering> {
        self.0.partial_cmp(other.as_str())
    }
}

impl PartialOrd<AccountIdRef> for str {
    fn partial_cmp(&self, other: &AccountIdRef) -> Option<std::cmp::Ordering> {
        self.partial_cmp(other.as_str())
    }
}

impl PartialOrd<str> for AccountIdRef {
    fn partial_cmp(&self, other: &str) -> Option<std::cmp::Ordering> {
        self.as_str().partial_cmp(other)
    }
}

impl<'a> PartialOrd<AccountIdRef> for &'a str {
    fn partial_cmp(&self, other: &AccountIdRef) -> Option<std::cmp::Ordering> {
        self.partial_cmp(&other.as_str())
    }
}

impl<'a> PartialOrd<&'a str> for AccountIdRef {
    fn partial_cmp(&self, other: &&'a str) -> Option<std::cmp::Ordering> {
        self.as_str().partial_cmp(*other)
    }
}

impl<'a> PartialOrd<&'a AccountIdRef> for String {
    fn partial_cmp(&self, other: &&'a AccountIdRef) -> Option<std::cmp::Ordering> {
        self.as_str().partial_cmp(&other.0)
    }
}

impl<'a> PartialOrd<String> for &'a AccountIdRef {
    fn partial_cmp(&self, other: &String) -> Option<std::cmp::Ordering> {
        self.0.partial_cmp(other.as_str())
    }
}

impl<'a> PartialOrd<&'a AccountIdRef> for str {
    fn partial_cmp(&self, other: &&'a AccountIdRef) -> Option<std::cmp::Ordering> {
        self.partial_cmp(other.as_str())
    }
}

impl<'a> PartialOrd<str> for &'a AccountIdRef {
    fn partial_cmp(&self, other: &str) -> Option<std::cmp::Ordering> {
        self.as_str().partial_cmp(other)
    }
}

impl<'a> From<&'a AccountIdRef> for Cow<'a, AccountIdRef> {
    fn from(value: &'a AccountIdRef) -> Self {
        Cow::Borrowed(value)
    }
}

#[cfg(feature = "arbitrary")]
impl<'a> arbitrary::Arbitrary<'a> for &'a AccountIdRef {
    fn size_hint(_depth: usize) -> (usize, Option<usize>) {
        (crate::validation::MIN_LEN, Some(crate::validation::MAX_LEN))
    }

    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let mut s = u.arbitrary::<&str>()?;

        loop {
            match AccountIdRef::new(s) {
                Ok(account_id) => break Ok(account_id),
                Err(ParseAccountError {
                    char: Some((idx, _)),
                    ..
                }) => {
                    s = &s[..idx];
                    continue;
                }
                _ => break Err(arbitrary::Error::IncorrectFormat),
            }
        }
    }

    fn arbitrary_take_rest(u: arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        let s = <&str as arbitrary::Arbitrary>::arbitrary_take_rest(u)?;
        AccountIdRef::new(s).map_err(|_| arbitrary::Error::IncorrectFormat)
    }
}

#[cfg(test)]
mod tests {
    use crate::ParseErrorKind;

    use super::*;

    #[test]
    #[cfg(feature = "schemars")]
    fn test_schemars() {
        let schema = schemars::schema_for!(AccountIdRef);
        let json_schema = serde_json::to_value(&schema).unwrap();
        assert_eq!(
            json_schema,
            serde_json::json!({
                    "$schema": "http://json-schema.org/draft-07/schema#",
                    "description": "Account identifier. This is the human readable UTF-8 string which is used internally to index accounts on the network and their respective state.\n\nThis is the \"referenced\" version of the account ID. It is to [`AccountId`] what [`str`] is to [`String`], and works quite similarly to [`Path`]. Like with [`str`] and [`Path`], you can't have a value of type `AccountIdRef`, but you can have a reference like `&AccountIdRef` or `&mut AccountIdRef`.\n\nThis type supports zero-copy deserialization offered by [`serde`](https://docs.rs/serde/), but cannot do the same for [`borsh`](https://docs.rs/borsh/) since the latter does not support zero-copy.\n\n# Examples ``` use near_account_id::{AccountId, AccountIdRef}; use std::convert::{TryFrom, TryInto};\n\n// Construction let alice = AccountIdRef::new(\"alice.near\").unwrap(); assert!(AccountIdRef::new(\"invalid.\").is_err()); ```\n\n[`FromStr`]: std::str::FromStr [`Path`]: std::path::Path",
                    "title": "AccountIdRef",
                    "type": "string"
                }
            )
        );
    }

    #[test]
    fn test_err_kind_classification() {
        let id = AccountIdRef::new("ErinMoriarty.near");
        debug_assert!(
            matches!(
                id,
                Err(ParseAccountError {
                    kind: ParseErrorKind::InvalidChar,
                    char: Some((0, 'E'))
                })
            ),
            "{:?}",
            id
        );

        let id = AccountIdRef::new("-KarlUrban.near");
        debug_assert!(
            matches!(
                id,
                Err(ParseAccountError {
                    kind: ParseErrorKind::RedundantSeparator,
                    char: Some((0, '-'))
                })
            ),
            "{:?}",
            id
        );

        let id = AccountIdRef::new("anthonystarr.");
        debug_assert!(
            matches!(
                id,
                Err(ParseAccountError {
                    kind: ParseErrorKind::RedundantSeparator,
                    char: Some((12, '.'))
                })
            ),
            "{:?}",
            id
        );

        let id = AccountIdRef::new("jack__Quaid.near");
        debug_assert!(
            matches!(
                id,
                Err(ParseAccountError {
                    kind: ParseErrorKind::RedundantSeparator,
                    char: Some((5, '_'))
                })
            ),
            "{:?}",
            id
        );
    }

    #[test]
    fn test_is_valid_top_level_account_id() {
        let ok_top_level_account_ids = &[
            "aa",
            "a-a",
            "a-aa",
            "100",
            "0o",
            "com",
            "near",
            "bowen",
            "b-o_w_e-n",
            "0o0ooo00oo00o",
            "alex-skidanov",
            "b-o_w_e-n",
            "no_lols",
            // ETH-implicit account
            "0xb794f5ea0ba39494ce839613fffba74279579268",
            // NEAR-implicit account
            "0123456789012345678901234567890123456789012345678901234567890123",
        ];
        for account_id in ok_top_level_account_ids {
            assert!(
                AccountIdRef::new(account_id).map_or(false, |account_id| account_id.is_top_level()),
                "Valid top level account id {:?} marked invalid",
                account_id
            );
        }

        let bad_top_level_account_ids = &[
            "ƒelicia.near", // fancy ƒ!
            "near.a",
            "b.owen",
            "bro.wen",
            "a.ha",
            "a.b-a.ra",
            "some-complex-address@gmail.com",
            "sub.buy_d1gitz@atata@b0-rg.c_0_m",
            "over.9000",
            "google.com",
            "illia.cheapaccounts.near",
            "10-4.8-2",
            "a",
            "A",
            "Abc",
            "-near",
            "near-",
            "-near-",
            "near.",
            ".near",
            "near@",
            "@near",
            "неар",
            "@@@@@",
            "0__0",
            "0_-_0",
            "0_-_0",
            "..",
            "a..near",
            "nEar",
            "_bowen",
            "hello world",
            "abcdefghijklmnopqrstuvwxyz.abcdefghijklmnopqrstuvwxyz.abcdefghijklmnopqrstuvwxyz",
            "01234567890123456789012345678901234567890123456789012345678901234",
            // Valid regex and length, but reserved
            "system",
        ];
        for account_id in bad_top_level_account_ids {
            assert!(
                !AccountIdRef::new(account_id)
                    .map_or(false, |account_id| account_id.is_top_level()),
                "Invalid top level account id {:?} marked valid",
                account_id
            );
        }
    }

    #[test]
    fn test_is_valid_sub_account_id() {
        let ok_pairs = &[
            ("test", "a.test"),
            ("test-me", "abc.test-me"),
            ("gmail.com", "abc.gmail.com"),
            ("gmail.com", "abc-lol.gmail.com"),
            ("gmail.com", "abc_lol.gmail.com"),
            ("gmail.com", "bro-abc_lol.gmail.com"),
            ("g0", "0g.g0"),
            ("1g", "1g.1g"),
            ("5-3", "4_2.5-3"),
        ];
        for (signer_id, sub_account_id) in ok_pairs {
            assert!(
                matches!(
                    (AccountIdRef::new(signer_id), AccountIdRef::new(sub_account_id)),
                    (Ok(signer_id), Ok(sub_account_id)) if sub_account_id.is_sub_account_of(signer_id)
                ),
                "Failed to create sub-account {:?} by account {:?}",
                sub_account_id,
                signer_id
            );
        }

        let bad_pairs = &[
            ("test", ".test"),
            ("test", "test"),
            ("test", "a1.a.test"),
            ("test", "est"),
            ("test", ""),
            ("test", "st"),
            ("test5", "ббб"),
            ("test", "a-test"),
            ("test", "etest"),
            ("test", "a.etest"),
            ("test", "retest"),
            ("test-me", "abc-.test-me"),
            ("test-me", "Abc.test-me"),
            ("test-me", "-abc.test-me"),
            ("test-me", "a--c.test-me"),
            ("test-me", "a_-c.test-me"),
            ("test-me", "a-_c.test-me"),
            ("test-me", "_abc.test-me"),
            ("test-me", "abc_.test-me"),
            ("test-me", "..test-me"),
            ("test-me", "a..test-me"),
            ("gmail.com", "a.abc@gmail.com"),
            ("gmail.com", ".abc@gmail.com"),
            ("gmail.com", ".abc@gmail@com"),
            ("gmail.com", "abc@gmail@com"),
            ("test", "a@test"),
            ("test_me", "abc@test_me"),
            ("gmail.com", "abc@gmail.com"),
            ("gmail@com", "abc.gmail@com"),
            ("gmail.com", "abc-lol@gmail.com"),
            ("gmail@com", "abc_lol.gmail@com"),
            ("gmail@com", "bro-abc_lol.gmail@com"),
            (
                "gmail.com",
                "123456789012345678901234567890123456789012345678901234567890@gmail.com",
            ),
            (
                "123456789012345678901234567890123456789012345678901234567890",
                "1234567890.123456789012345678901234567890123456789012345678901234567890",
            ),
            (
                "b794f5ea0ba39494ce839613fffba74279579268",
                // ETH-implicit account
                "0xb794f5ea0ba39494ce839613fffba74279579268",
            ),
            ("aa", "ъ@aa"),
            ("aa", "ъ.aa"),
        ];
        for (signer_id, sub_account_id) in bad_pairs {
            assert!(
                !matches!(
                    (AccountIdRef::new(signer_id), AccountIdRef::new(sub_account_id)),
                    (Ok(signer_id), Ok(sub_account_id)) if sub_account_id.is_sub_account_of(&signer_id)
                ),
                "Invalid sub-account {:?} created by account {:?}",
                sub_account_id,
                signer_id
            );
        }
    }

    #[test]
    fn test_is_account_id_near_implicit() {
        let valid_near_implicit_account_ids = &[
            "0000000000000000000000000000000000000000000000000000000000000000",
            "6174617461746174617461746174617461746174617461746174617461746174",
            "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef",
            "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
            "20782e20662e64666420482123494b6b6c677573646b6c66676a646b6c736667",
        ];
        for valid_account_id in valid_near_implicit_account_ids {
            assert!(
                matches!(
                    AccountIdRef::new(valid_account_id),
                    Ok(account_id) if account_id.get_account_type() == AccountType::NearImplicitAccount
                ),
                "Account ID {} should be valid 64-len hex",
                valid_account_id
            );
        }

        let invalid_near_implicit_account_ids = &[
            "000000000000000000000000000000000000000000000000000000000000000",
            "6.74617461746174617461746174617461746174617461746174617461746174",
            "012-456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef",
            "fffff_ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
            "oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo",
            "00000000000000000000000000000000000000000000000000000000000000",
        ];
        for invalid_account_id in invalid_near_implicit_account_ids {
            assert!(
                !matches!(
                    AccountIdRef::new(invalid_account_id),
                    Ok(account_id) if account_id.get_account_type() == AccountType::NearImplicitAccount
                ),
                "Account ID {} is not a NEAR-implicit account",
                invalid_account_id
            );
        }
    }

    #[test]
    fn test_is_account_id_eth_implicit() {
        let valid_eth_implicit_account_ids = &[
            "0x0000000000000000000000000000000000000000",
            "0x6174617461746174617461746174617461746174",
            "0x0123456789abcdef0123456789abcdef01234567",
            "0xffffffffffffffffffffffffffffffffffffffff",
            "0x20782e20662e64666420482123494b6b6c677573",
        ];
        for valid_account_id in valid_eth_implicit_account_ids {
            assert!(
                matches!(
                    valid_account_id.parse::<AccountId>(),
                    Ok(account_id) if account_id.get_account_type() == AccountType::EthImplicitAccount
                ),
                "Account ID {} should be valid 42-len hex, starting with 0x",
                valid_account_id
            );
        }

        let invalid_eth_implicit_account_ids = &[
            "04b794f5ea0ba39494ce839613fffba74279579268",
            "0x000000000000000000000000000000000000000",
            "0x6.74617461746174617461746174617461746174",
            "0x012-456789abcdef0123456789abcdef01234567",
            "0xfffff_ffffffffffffffffffffffffffffffffff",
            "0xoooooooooooooooooooooooooooooooooooooooo",
            "0x00000000000000000000000000000000000000000",
            "0000000000000000000000000000000000000000000000000000000000000000",
        ];
        for invalid_account_id in invalid_eth_implicit_account_ids {
            assert!(
                !matches!(
                    invalid_account_id.parse::<AccountId>(),
                    Ok(account_id) if account_id.get_account_type() == AccountType::EthImplicitAccount
                ),
                "Account ID {} is not an ETH-implicit account",
                invalid_account_id
            );
        }
    }

    #[test]
    #[cfg(feature = "arbitrary")]
    fn test_arbitrary() {
        let corpus = [
            ("a|bcd", None),
            ("ab|cde", Some("ab")),
            ("a_-b", None),
            ("ab_-c", Some("ab")),
            ("a", None),
            ("miraclx.near", Some("miraclx.near")),
            (
                "01234567890123456789012345678901234567890123456789012345678901234",
                None,
            ),
        ];

        for (input, expected_output) in corpus {
            assert!(input.len() <= u8::MAX as usize);
            let data = [input.as_bytes(), &[input.len() as _]].concat();
            let mut u = arbitrary::Unstructured::new(&data);

            assert_eq!(
                u.arbitrary::<&AccountIdRef>()
                    .ok()
                    .map(AsRef::<str>::as_ref),
                expected_output
            );
        }
    }
}

'''
'''--- src/borsh.rs ---
use crate::AccountIdRef;

use super::AccountId;

use std::io::{Read, Write};

use borsh::{BorshDeserialize, BorshSerialize};

impl BorshSerialize for AccountId {
    fn serialize<W: Write>(&self, writer: &mut W) -> std::io::Result<()> {
        self.0.serialize(writer)
    }
}

impl BorshSerialize for AccountIdRef {
    fn serialize<W: Write>(&self, writer: &mut W) -> std::io::Result<()> {
        self.0.serialize(writer)
    }
}

impl BorshDeserialize for AccountId {
    fn deserialize_reader<R: Read>(rd: &mut R) -> std::io::Result<Self> {
        let account_id = Box::<str>::deserialize_reader(rd)?;
        crate::validation::validate(&account_id).map_err(|err| {
            std::io::Error::new(
                std::io::ErrorKind::InvalidData,
                format!("invalid value: \"{}\", {}", account_id, err),
            )
        })?;
        Ok(Self(account_id))
    }
}

#[cfg(test)]
mod tests {
    use borsh::BorshDeserialize as _;

    use crate::test_data::{BAD_ACCOUNT_IDS, OK_ACCOUNT_IDS};
    use crate::AccountId;

    #[test]
    fn test_is_valid_account_id() {
        for account_id in OK_ACCOUNT_IDS {
            let parsed_account_id = account_id.parse::<AccountId>().unwrap_or_else(|err| {
                panic!("Valid account id {:?} marked invalid: {}", account_id, err)
            });

            let str_serialized_account_id = borsh::to_vec(account_id).unwrap();

            let deserialized_account_id = AccountId::try_from_slice(&str_serialized_account_id)
                .unwrap_or_else(|err| {
                    panic!("failed to deserialize account ID {:?}: {}", account_id, err)
                });
            assert_eq!(deserialized_account_id, parsed_account_id);

            let serialized_account_id =
                borsh::to_vec(&deserialized_account_id).unwrap_or_else(|err| {
                    panic!("failed to serialize account ID {:?}: {}", account_id, err)
                });
            assert_eq!(serialized_account_id, str_serialized_account_id);
        }

        for account_id in BAD_ACCOUNT_IDS {
            let str_serialized_account_id = borsh::to_vec(account_id).unwrap();

            assert!(
                AccountId::try_from_slice(&str_serialized_account_id).is_err(),
                "successfully deserialized invalid account ID {:?}",
                account_id
            );
        }
    }

    #[test]
    fn fuzz() {
        bolero::check!().for_each(|input: &[u8]| {
            if let Ok(account_id) = AccountId::try_from_slice(input) {
                assert_eq!(
                    account_id,
                    AccountId::try_from_slice(borsh::to_vec(&account_id).unwrap().as_slice())
                        .unwrap()
                );
            }
        });
    }
}

'''
'''--- src/errors.rs ---
use std::fmt;
use std::fmt::Write;

/// An error which can be returned when parsing a NEAR Account ID.
#[derive(Eq, Clone, Debug, PartialEq)]
pub struct ParseAccountError {
    pub(crate) kind: ParseErrorKind,
    pub(crate) char: Option<(usize, char)>,
}

impl ParseAccountError {
    /// Returns the specific cause why parsing the Account ID failed.
    pub fn kind(&self) -> &ParseErrorKind {
        &self.kind
    }
}

impl std::error::Error for ParseAccountError {}
impl fmt::Display for ParseAccountError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let mut buf = self.kind.to_string();
        if let Some((idx, char)) = self.char {
            write!(buf, " {:?} at index {}", char, idx)?
        }
        buf.fmt(f)
    }
}

/// A list of errors that occur when parsing an invalid Account ID.
///
/// Also see [Error kind precedence](crate::AccountId#error-kind-precedence).
#[non_exhaustive]
#[derive(Eq, Clone, Debug, PartialEq)]
pub enum ParseErrorKind {
    /// The Account ID is too long.
    ///
    /// Returned if the `AccountId` is longer than [`AccountId::MAX_LEN`](crate::AccountId::MAX_LEN).
    TooLong,
    /// The Account ID is too short.
    ///
    /// Returned if the `AccountId` is shorter than [`AccountId::MIN_LEN`](crate::AccountId::MIN_LEN).
    TooShort,
    /// The Account ID has a redundant separator.
    ///
    /// This variant would be returned if the Account ID either begins with,
    /// ends with or has separators immediately following each other.
    ///
    /// Cases: `jane.`, `angela__moss`, `tyrell..wellick`
    RedundantSeparator,
    /// The Account ID contains an invalid character.
    ///
    /// This variant would be returned if the Account ID contains an upper-case character, non-separating symbol or space.
    ///
    /// Cases: `ƒelicia.near`, `user@app.com`, `Emily.near`.
    InvalidChar,
}

impl fmt::Display for ParseErrorKind {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            ParseErrorKind::TooLong => "the Account ID is too long".fmt(f),
            ParseErrorKind::TooShort => "the Account ID is too short".fmt(f),
            ParseErrorKind::RedundantSeparator => "the Account ID has a redundant separator".fmt(f),
            ParseErrorKind::InvalidChar => "the Account ID contains an invalid character".fmt(f),
        }
    }
}

'''
'''--- src/lib.rs ---
//! This crate provides a type for representing a syntactically valid, unique account identifier on the [NEAR](https://near.org) network.
//!
//! ## Account ID Rules
//!
//! - Minimum length is `2`
//! - Maximum length is `64`
//! - An **Account ID** consists of **Account ID parts** separated by `.`, example:
//!   - `root` ✔
//!   - `alice.near` ✔
//!   - `app.stage.testnet` ✔
//! - Must not start or end with separators (`_`, `-` or `.`):
//!   - `_alice.` ✗
//!   - `.bob.near-` ✗
//! - Each part of the **Account ID** consists of lowercase alphanumeric symbols separated either by `_` or `-`, example:
//!   - `ƒelicia.near` ✗ (`ƒ` is not `f`)
//!   - `1_4m_n0t-al1c3.near` ✔
//! - Separators are not permitted to immediately follow each other, example:
//!   - `alice..near` ✗
//!   - `not-_alice.near` ✗
//! - An **Account ID** that is 64 characters long and consists of lowercase hex characters is a specific **implicit account ID**
//!
//! Learn more here: <https://docs.near.org/docs/concepts/account#account-id-rules>
//!
//! Also see [Error kind precedence](AccountId#error-kind-precedence).
//!
//! ## Usage
//!
//! ```
//! use near_account_id::{AccountIdRef, AccountId};
//!
//! const ALICE: &AccountIdRef = AccountIdRef::new_or_panic("alice.near");
//!
//! let alice: AccountId = "alice.near".parse().unwrap();
//!
//! assert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f)
//! ```

mod errors;

mod account_id;
mod account_id_ref;
#[cfg(feature = "borsh")]
mod borsh;
#[cfg(feature = "serde")]
mod serde;
#[cfg(test)]
mod test_data;
mod validation;

pub use account_id::AccountId;
pub use account_id_ref::{AccountIdRef, AccountType};
pub use errors::{ParseAccountError, ParseErrorKind};

'''
'''--- src/serde.rs ---
use crate::AccountIdRef;

use super::AccountId;

use serde::{de, ser};

impl ser::Serialize for AccountId {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: ser::Serializer,
    {
        self.0.serialize(serializer)
    }
}

impl ser::Serialize for AccountIdRef {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: ser::Serializer,
    {
        self.0.serialize(serializer)
    }
}

impl<'de> de::Deserialize<'de> for AccountId {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: de::Deserializer<'de>,
    {
        let account_id = Box::<str>::deserialize(deserializer)?;
        crate::validation::validate(&account_id).map_err(|err| {
            de::Error::custom(format!("invalid value: \"{}\", {}", account_id, err))
        })?;
        Ok(AccountId(account_id))
    }
}

impl<'de> de::Deserialize<'de> for &'de AccountIdRef {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: de::Deserializer<'de>,
    {
        <&str as de::Deserialize>::deserialize(deserializer)
            .and_then(|s| Self::try_from(s).map_err(de::Error::custom))
    }
}

#[cfg(test)]
mod tests {
    use crate::test_data::{BAD_ACCOUNT_IDS, OK_ACCOUNT_IDS};
    use crate::AccountId;

    use serde_json::json;

    #[test]
    fn test_is_valid_account_id() {
        for account_id in OK_ACCOUNT_IDS.iter() {
            let parsed_account_id = account_id.parse::<AccountId>().unwrap_or_else(|err| {
                panic!("Valid account id {:?} marked invalid: {}", account_id, err)
            });

            let deserialized_account_id: AccountId = serde_json::from_value(json!(account_id))
                .unwrap_or_else(|err| {
                    panic!("failed to deserialize account ID {:?}: {}", account_id, err)
                });
            assert_eq!(deserialized_account_id, parsed_account_id);

            let serialized_account_id = serde_json::to_value(&deserialized_account_id)
                .unwrap_or_else(|err| {
                    panic!("failed to serialize account ID {:?}: {}", account_id, err)
                });
            assert_eq!(serialized_account_id, json!(account_id));
        }

        for account_id in BAD_ACCOUNT_IDS.iter() {
            assert!(
                serde_json::from_value::<AccountId>(json!(account_id)).is_err(),
                "successfully deserialized invalid account ID {:?}",
                account_id
            );
        }
    }

    #[test]
    fn fuzz() {
        bolero::check!().for_each(|input: &[u8]| {
            if let Ok(account_id) = std::str::from_utf8(input) {
                if let Ok(account_id) = serde_json::from_value::<AccountId>(json!(account_id)) {
                    assert_eq!(
                        account_id,
                        serde_json::from_value::<AccountId>(
                            serde_json::to_value(&account_id).unwrap()
                        )
                        .unwrap()
                    );
                }
            }
        });
    }
}

'''
'''--- src/test_data.rs ---
pub const OK_ACCOUNT_IDS: [&str; 24] = [
    "aa",
    "a-a",
    "a-aa",
    "100",
    "0o",
    "com",
    "near",
    "bowen",
    "b-o_w_e-n",
    "b.owen",
    "bro.wen",
    "a.ha",
    "a.b-a.ra",
    "system",
    "over.9000",
    "google.com",
    "illia.cheapaccounts.near",
    "0o0ooo00oo00o",
    "alex-skidanov",
    "10-4.8-2",
    "b-o_w_e-n",
    "no_lols",
    "0123456789012345678901234567890123456789012345678901234567890123",
    // Valid, but can't be created
    "near.a",
];

pub const BAD_ACCOUNT_IDS: [&str; 24] = [
    "a",
    "A",
    "Abc",
    "-near",
    "near-",
    "-near-",
    "near.",
    ".near",
    "near@",
    "@near",
    "неар",
    "@@@@@",
    "0__0",
    "0_-_0",
    "0_-_0",
    "..",
    "a..near",
    "nEar",
    "_bowen",
    "hello world",
    "abcdefghijklmnopqrstuvwxyz.abcdefghijklmnopqrstuvwxyz.abcdefghijklmnopqrstuvwxyz",
    "01234567890123456789012345678901234567890123456789012345678901234",
    // `@` separators are banned now
    "some-complex-address@gmail.com",
    "sub.buy_d1gitz@atata@b0-rg.c_0_m",
];

'''
'''--- src/validation.rs ---
use crate::{ParseAccountError, ParseErrorKind};

/// Shortest valid length for a NEAR Account ID.
pub const MIN_LEN: usize = 2;
/// Longest valid length for a NEAR Account ID.
pub const MAX_LEN: usize = 64;

pub const fn validate_const(account_id: &str) {
    const fn validate_format_const(id: &[u8], idx: usize, current_char_is_separator: bool) {
        if idx >= id.len() {
            if current_char_is_separator {
                panic!("NEAR Account ID cannot end with char separator (-, _, .)");
            }
            return;
        }

        match id[idx] {
            b'a'..=b'z' | b'0'..=b'9' => validate_format_const(id, idx + 1, false),
            b'-' | b'_' | b'.' => {
                if current_char_is_separator {
                    panic!("NEAR Account ID cannot contain redundant separator (-, _, .)")
                } else if idx == 0 {
                    panic!("NEAR Account ID cannot start with char separator (-, _, .)")
                } else {
                    validate_format_const(id, idx + 1, true)
                }
            }
            _ => panic!(
                "NEAR Account ID cannot contain invalid chars (only a-z, 0-9, -, _, and . are allowed)"
            ),
        }
    }

    if account_id.len() < MIN_LEN {
        panic!("NEAR Account ID is too short")
    } else if account_id.len() > MAX_LEN {
        panic!("NEAR Account ID is too long")
    }

    validate_format_const(account_id.as_bytes(), 0, false);
}

pub fn validate(account_id: &str) -> Result<(), ParseAccountError> {
    if account_id.len() < MIN_LEN {
        Err(ParseAccountError {
            kind: ParseErrorKind::TooShort,
            char: None,
        })
    } else if account_id.len() > MAX_LEN {
        Err(ParseAccountError {
            kind: ParseErrorKind::TooLong,
            char: None,
        })
    } else {
        // Adapted from https://github.com/near/near-sdk-rs/blob/fd7d4f82d0dfd15f824a1cf110e552e940ea9073/near-sdk/src/environment/env.rs#L819

        // NOTE: We don't want to use Regex here, because it requires extra time to compile it.
        // The valid account ID regex is /^(([a-z\d]+[-_])*[a-z\d]+\.)*([a-z\d]+[-_])*[a-z\d]+$/
        // Instead the implementation is based on the previous character checks.

        // We can safely assume that last char was a separator.
        let mut last_char_is_separator = true;

        let mut this = None;
        for (i, c) in account_id.chars().enumerate() {
            this.replace((i, c));
            let current_char_is_separator = match c {
                'a'..='z' | '0'..='9' => false,
                '-' | '_' | '.' => true,
                _ => {
                    return Err(ParseAccountError {
                        kind: ParseErrorKind::InvalidChar,
                        char: this,
                    });
                }
            };
            if current_char_is_separator && last_char_is_separator {
                return Err(ParseAccountError {
                    kind: ParseErrorKind::RedundantSeparator,
                    char: this,
                });
            }
            last_char_is_separator = current_char_is_separator;
        }

        if last_char_is_separator {
            return Err(ParseAccountError {
                kind: ParseErrorKind::RedundantSeparator,
                char: this,
            });
        }
        Ok(())
    }
}

pub fn is_eth_implicit(account_id: &str) -> bool {
    account_id.len() == 42
        && account_id.starts_with("0x")
        && account_id[2..].as_bytes().iter().all(|b| matches!(b, b'a'..=b'f' | b'0'..=b'9'))
}

pub fn is_near_implicit(account_id: &str) -> bool {
    account_id.len() == 64
        && account_id
            .as_bytes()
            .iter()
            .all(|b| matches!(b, b'a'..=b'f' | b'0'..=b'9'))
}

#[cfg(test)]
mod tests {
    use super::*;

    use crate::test_data::{BAD_ACCOUNT_IDS, OK_ACCOUNT_IDS};

    #[test]
    fn test_is_valid_account_id() {
        for account_id in OK_ACCOUNT_IDS {
            if let Err(err) = validate(account_id) {
                panic!(
                    "Valid account id {:?} marked invalid: {}",
                    account_id,
                    err.kind()
                );
            }
        }

        for account_id in BAD_ACCOUNT_IDS {
            assert!(
                validate(account_id).is_err(),
                "Invalid account id {} marked valid",
                account_id
            );
        }
    }
    #[test]
    fn test_is_valid_account_id_const() {
        for account_id in OK_ACCOUNT_IDS {
            validate_const(account_id);
        }
    }

    #[test]
    fn test_is_invalid_account_id_const() {
        for account_id in BAD_ACCOUNT_IDS {
            // Do not print panic message for caught panic
            std::panic::set_hook(Box::new(|_| {}));

            let result = std::panic::catch_unwind(|| validate_const(account_id));

            // Restore panic hook to default to properly handle assertion failure
            let _ = std::panic::take_hook();

            assert!(
                result.is_err(),
                "Invalid account id {} marked valid",
                account_id
            );
        }
    }
}

'''