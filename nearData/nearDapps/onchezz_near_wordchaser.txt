*GitHub Repository "onchezz/near_wordchaser"*

'''--- .github/workflows/Wordchaser.yml ---
name: Rust

on:
  push:
    branches: [ "master" ]
  pull_request:
    branches: [ "master" ]

env:
  CARGO_TERM_COLOR: always

jobs:
  build:

    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v3
    - name: Build
      run: cargo build --verbose
    - name: Run tests
      run: cargo test --verbose

'''
'''--- Cargo.toml ---
[package]
name = "near_wordchaser"
version = "0.1.0"
edition = "2021"
authors = ["onchez brian <brianonchez@gmail.com>"]

[dependencies]
near-sdk = "4.0.0-pre.7"
near-contract-standards = "4.0.0-pre.7"
serde = { version = "1.0.104", features = ["derive"] }
serde_json = "1.0.48"
near-rng = "0.1.1"
chrono = "0.4.19"

[lib]
crate-type = ["cdylib","lib"]

[profile.release]
codegen-units = 1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- README.md ---
# NEAR Wordchaser Smart Contract

This is game smart contract to test your english knowledge to know words that lets you choose a word then gives an exmaple and meaning you can give a solution from the example and meaning given

## Tools Required

Ensure `near-cli` is installed by running:

```
near --version
```

If needed, install `near-cli`:

```
npm install near-cli -g
```

Ensure `Rust` is installed by running:

```
rustc --version
```

If needed, install [Rust](https://www.rust-lang.org/tools/install):

## file Layout

```
Root Folder
├── contract
│   ├── build.sh
│   ├── Cargo.lock
│   ├── Cargo.toml
│   ├── src
|   |   ├── data.rs
|   |   ├── how_play.rs
|   |   └── lib.rs
│   └── test.sh
└── README.md

```

## Game Function Calls

To start the game

```
near call word.onchez.testnet  how_to_play --accountId   Your accountId
```

To get a random word

```
near call word.onchez.testnet  random_word --accountId   Your accountId
```

To view completed words

```
near call word.onchez.testnet  view_available_words --accountId   Your accountId
```

To check solution

```
near call word.onchez.testnet  check_solution '{"word":"you_solution"}'--accountId   Your accountId
```

To add more tunrs in the game charge 1near per 10 turns added

```
near call word.onchez.testnet   add_more_turns --accountId   Your accountId
```

#### Author

- onchez brian <brianonchezz@gmail.com> [@onchez2](https://twitter.com/onchez2)

watch how  to call the smart contract

link to video : 
[Watch loom video](https://www.loom.com/share/0daad8d622154d18acf344d89a631b43?sid=12330c27-af54-4a93-b4ac-65677cd656e1)

'''
'''--- build.sh ---
#!/usr/bin/env bash

cargo build --target wasm32-unknown-unknown --release

'''
'''--- deploy.sh ---
#!/usr/bin/env bash

WASM_PATH="$(find ./target/wasm32-unknown-unknown/release/ -maxdepth 1 -name "*.wasm")"

near deploy \
  --wasmFile $WASM_PATH \
  --accountId "$1" \
  --initFunction new \
  --initArgs "$(node ./init-args.js)"

  

'''
'''--- dev-deploy.sh ---
#!/usr/bin/env bash

WASM_PATH="$(find ./target/wasm32-unknown-unknown/release/ -maxdepth 1 -name "*.wasm")"

near dev-deploy \
  --wasmFile $WASM_PATH \
  "$@"

near call "$(<./neardev/dev-account)" new "$(node ./init-args.js)" \
  --accountId "$(<./neardev/dev-account)"

'''
'''--- init-args.js ---
const ONE_DAY = 1_000_000_000 * 60 * 60 * 24;

// 1e24, calculated like this because JS numbers don't work that large
const ONE_NEAR = BigInt(1e12) ** 2n;

console.log(JSON.stringify({}));

'''
'''--- rustfmt.toml ---
tab_spaces = 2

'''
'''--- src/data.rs ---
use serde_json::json;

//this function creates  initial random data for  the wordchaser game
//this immitates a simple rest api for json respond
pub fn json_data() -> serde_json::Value {
  let data = json!(
    [
  {
  "word": "consider",
  "meaning":"deem to be",
  "example":"At the moment, artemisinin-based therapies are considered the best treatment, but cost about $10 per dose - far too much for impoverished communities"
  },
  {
  "word": "minute",
  "meaning":"infinitely or immeasurably small",
  "example":"The minute stain on the document was not visible to the naked eye."
  },
  {
  "word":"accord",
  "meaning":"concurrence of opinion",
  "example":"The committee worked in accord on the bill, and it eventually passed."
  },
  {
  "word":"evident",
  "meaning":"clearly revealed to the mind or the senses or judgment",
  "example":"That confidence was certainly evident in the way Smith handled the winning play with 14 seconds left on the clock."
  },
  {
  "word":"practice",
  "meaning":"a customary way of operation or behavior",
  "example":"He directed and acted in plays every season and became known for exploring Elizabethan theatre practices."
   },
  {
  "word":"intend",
  "meaning":"have in mind as a purpose",
  "example":"Lipstick, as a product intended for topical use with limited absorption, is ingested only in very small quantities,” the agency said on its website."
   },
  {
  "word":"concern",
  "meaning":"something that interests you because it is important",
  "example":"The scandal broke out in October after former chief executive Michael Woodford claimed he was fired for raising concerns about the company's accounting practices."
  },
  {
  "word":"commit",
  "meaning":"perform an act, usually with a negative connotation",
  "example":"In an unprecedented front page article in 2003 The Times reported that Mr. Blair, a young reporter on its staff, had committed journalistic fraud."
   },
   {
  "word":"issue",
  "meaning":"some situation or event that is thought about",
  "example":"As a result, the privacy issues surrounding mobile computing are becoming ever-more complex."
   },
   {
  "word":"approach",
  "meaning":"move towards",
  "example":"Spain’s jobless rate for people ages 16 to 24 is approaching 50 percent."
  } ,
  {
  "word":"establish",
  "meaning":"set up or found",
  "example":"A small French colony, Port Louis, was established on East Falkland in 1764 and handed to the Spanish three years later."
   },
   {
  "word":"utter",
  "meaning":"without qualification",
  "example":"No one can blame an honest mechanic for holding a wealthy snob in utter contempt.Ingersoll, Robert Green"
   },
   {
  "word":"conduct",
  "meaning":"direct the course of; manage or control",
  "example":"Scientists have been conducting studies of individual genes for years"
   },
   {
  "word":"engage",
  "meaning":"consume all of one's attention or time",
  "example":"We had nearly two hundred passengers, who were seated about on the sofas, reading, or playing games, or engaged in conversation.Field, Henry M."
   },
   {
  "word":"obtain",
  "meaning":"come into possession of",
  "example":"He delayed making the unclassified report public while awaiting an Army review, but Rolling Stone magazine obtained the report and posted it Friday night.N"
  },
   {
  "word":"scarce",
  "meaning":"deficient in quantity or number compared with the demand",
  "example":"Meanwhile, heating oil could grow more scarce in the Northeast this winter, the Energy Department warned last month"}
  ,
  {
  "word":"policy",
  "meaning":"a plan of action adopted by an individual or social group",
  "example":"Inflation has lagged behind the central bank’s 2 percent target, giving policy makers extra scope to cut rates."
  },
  {
  "word":"straight",
  "meaning":"successive, without a break",
  "example":"After three straight losing seasons, Hoosiers fans were just hoping for a winning record."
  },
  {
  "word":"stock",
  "meaning":"capital raised by a corporation through the issue of shares",
  "example":"In other words, Apple’s stock is cheap, and you should buy it."},
  {
  "word":"apparent",
  "meaning":"clearly revealed to the mind or the senses or judgment",
  "example":"But the elderly creak is beginning to become apparent in McCartney’s voice."
  },
  {
  "word":"hello",
  "meaning":"simple greeting used daily by people",
  "example":"hello am Emanuael from starbucks how may i help you today??"
  }
  ]
     );
  data
}

'''
'''--- src/how_play.rs ---
use serde_json::json;
//this function creates  initial random data for  the wordchaser game
//this immitates a simple rest api for json respond
pub fn how_to_play_json() -> serde_json::Value {
  let playinfo = json!([
    {
      "info": "Start the Game",
      "description": "to start playing the game call »",
      "method": "near call word.onchez.testnet  random_word --accountId   Your accountId"
    },
     {
      "info": "To View if your guess is correct ",
      "description": "compares your guess to the random number generated by the user",
      "method": "near call word.onchez.testnet  check_solution word:you_solution --accountId   Your accountId"
    },
    {
      "info": "To check completed words ",
      "description": " this function views completed words",
      "method": "near call word.onchez.testnet  view_available_words --accountId   Your accountId"
    },
    {
      "info": "To view saved words ",
      "description": "view words that are saved on copletion ",
      "method": "near call word.onchez.testnet  view_saved --accountId   Your accountId"
    },
  {
      "info": "To add more turns in the game  ",
      "description": "adds the player more turns at  a cost of one near per  10 turns aded ",
      "method": "near call word.onchez.testnet add_more_turns --accountId   Your accountId"
    },
    {
      "info": "To get help",
      "description": "Know how to play this game",
      "method": "near call word.onchez.testnet  how_to_play --accountId   Your accountId"
    },

      ]);
  playinfo
}

//  _    _  _____ ______ ______  _____  _   _   ___   _____  _____ ______
// | |  | ||  _  || ___ \|  _  \/  __ \| | | | / _ \ /  ___||  ___|| ___ \
// | |  | || | | || |_/ /| | | || /  \/| |_| |/ /_\ \\ `--. | |__  | |_/ /
// | |/\| || | | ||    / | | | || |    |  _  ||  _  | `--. \|  __| |    /
// \  /\  /\ \_/ /| |\ \ | |/ / | \__/\| | | || | | |/\__/ /| |___ | |\ \
//  \/  \/  \___/ \_| \_||___/   \____/\_| |_/\_| |_/\____/ \____/ \_| \_|

'''
'''--- src/lib.rs ---
use chrono::prelude::*;
use near_rng::Rng;
use near_sdk::{
  borsh::{self, BorshDeserialize, BorshSerialize},
  env, log, near_bindgen,
  serde::{Deserialize, Serialize},
  serde_json, Promise,
};
mod data;
mod how_play;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, Deserialize, Serialize, Clone, Debug)]
pub struct Info {
  info: String,
  description: String,
  method: String,
}
#[near_bindgen]
#[derive(
  BorshDeserialize, BorshSerialize, Serialize, Deserialize, Debug, Clone, Default, PartialEq,
)]
#[serde(crate = "near_sdk::serde")]
#[serde(rename_all = "camelCase")]
pub struct Vocabulary {
  pub example: String,
  pub meaning: String,
  pub word: String,
}
#[near_bindgen]
impl Vocabulary {
  pub fn create_unknown_word(&mut self) -> Vocabulary {
    let mut letters = Letter::get_letters(&mut self.word);
    let display_string = Letter::display_progress(&mut letters);
    let replace_example = self.example.replace(&self.word, &display_string);
    let unknown_word = Vocabulary {
      example: replace_example,
      meaning: self.meaning.clone(),
      word: display_string,
    };
    unknown_word
  }
}

// #[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, Deserialize, Serialize, Debug, PartialEq)]
#[serde(crate = "near_sdk::serde")]
pub enum Status {
  Completed,
  Inprogress,
  Failed,
}

#[derive(Debug, Serialize, Deserialize)]
#[near_bindgen]
pub struct Letter {
  pub letter: char,
  pub is_revealed: bool,
}
#[near_bindgen]
impl Letter {
  /*getting letters from the generated word*/
  pub fn get_letters(word: &mut String) -> Vec<Letter> {
    let mut chars: Vec<Letter> = Vec::new();
    //destracturing and looping the word letters and  saving them in a vector of type letters
    for c in word.chars() {
      chars.push(Self {
        letter: c,
        is_revealed: false,
      });
    }
    //returning the generated letters
    chars
  }

  /*this functions takes in a vector of letters and creats a display string of letter depending on if it is revealed or not */
  pub fn display_progress(letters: &mut Vec<Letter>) -> String {
    let mut display_string = String::from("");
    for l in letters {
      display_string.push(' ');
      if l.is_revealed {
        display_string.push(l.letter);
      } else {
        display_string.push('_');
      }
    }
    display_string
  }
  /*this function matches the userinput and the random word  and finds which  letter is revealed ans sets is revealed to true */
  pub fn reveal_letters(user_random: &mut String, user_input: String) -> Vec<Letter> {
    let mut random_word_letters = Letter::get_letters(user_random);
    /*user input word  */
    let guessed_word_letters: Vec<char> = user_input.chars().collect();

    for l in random_word_letters.iter_mut() {
      let letter = l.letter;
      for uin in guessed_word_letters.iter() {
        if &letter == uin {
          l.is_revealed = true;
        }
      }
    }
    random_word_letters
  }
}
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, Deserialize, Serialize)]
pub struct CompletedWord {
  word: String,
  status: String,
  trials_completed_at: String,
  completed_at: String,
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Player {
  pub userid: String,
  pub guess: String,
  pub word_progress: String,
  pub completed: Vec<CompletedWord>,
  pub turns: u64,
  pub is_revealed: bool,
}
impl Default for Player {
  fn default() -> Self {
    Self {
      userid: String::from("word.test"),
      guess: String::from("near"),
      word_progress: String::from(" _ _ _ _"),
      completed: Vec::new(),
      turns: 0,
      is_revealed: false,
    }
  }
}

#[near_bindgen]
impl Player {
  /*this a function to get data from a json file imitating a REST API for random words */
  fn get_data(&mut self) -> Option<Vec<Vocabulary>> {
    /*getting data from json  data  */
    let data = data::json_data();
    //saving words to a vector of type ::word wh&&ich is a struct
    let words: Vec<Vocabulary> = serde_json::from_value(data).expect("erro giving json");
    Some(words)
  }
  //this function fetches jsdon data on how to play  the game   then saves it in vector  if it exits
  fn playinfo(&mut self) -> Option<Vec<Info>> {
    let playinfo = how_play::how_to_play_json();
    let how_play: Vec<Info> = serde_json::from_value(playinfo).expect("unable to get playing info");
    Some(how_play)
  }
  //this function gives an overview on how to play the game
  pub fn how_to_play(&mut self) -> Result<Vec<Info>, &str> {
    let mut how_to_play: Vec<Info> = Vec::new();
    let info = self.playinfo();
    let account = env::signer_account_id();
    let user = String::from(account);
    /*
     *this function creates a  help based if the user exists
     *if the user exists  returns how to play without a  welcome message
     */
    match self.userid == user {
      true => Ok(info.unwrap()),
      false => match info {
        Some(info) => {
          // splting to get only the user name without ".near" or ".testnet" for the user name
          let username: Vec<&str> = user.split('.').collect();
          let wel = Info {
            info: format!("{} \n welcome  {}", WELCOME, username[0]),
            description:
              "To  start the  game call  the random_word to get a word randomly to play with "
                .to_string(),
            method: "random_word".to_string(),
          };
          //pushing a welcome info if the user is new to the game
          how_to_play.push(wel);
          for i in 0..info.len() {
            how_to_play.push(info[i].clone());
          }
          Ok(how_to_play)
        }
        None => Err("Sorry failed to get help"),
      },
    }
  }

  pub fn view_available_words(&mut self) -> Option<Vec<Vocabulary>> {
    /*this function creates vocabularies with hidden words for the player crack
    eg ..
     {
        example: 'The committee worked in    _ _ _ _ _ _ on the bill, and it eventually passed.',
        meaning: 'concurrence of opinion',
        word: '   _ _ _ _ _ _'
      },
    */

    let words = self.get_data();
    match words {
      Some(mut words) => {
        let mut display_unknown_words: Vec<Vocabulary> = Vec::new();

        for word_index in 0..words.len() {
          let word = &mut words[word_index];
          let unknown_word = word.create_unknown_word();
          display_unknown_words.push(unknown_word);
          for completed_words in self.completed.iter() {
            //this function checks if the  word is revealed by the user and shows it
            if word.word == completed_words.word {
              display_unknown_words.remove(word_index);

              display_unknown_words.insert(word_index, word.clone())
            }
          }
        }

        Some(display_unknown_words)
      }

      None => {
        log!("failed to create words");

        None
      }
    }
  }

  /*this is a function to generate a random word with range to index to play with  */
  pub fn random_word(&mut self) -> Result<Vocabulary, Info> {
    //saving words to a vector of type ::word which is a struct
    let account_id = env::signer_account_id();
    let user = String::from(account_id);
    if user != self.userid {
      self.userid = user;
    }
    //matches if there is data found on the  from json and matches some  else it returns an error
    match self.get_data() {
      Some(words) => {
        //this is the mximum index for generating the random word
        let index = self.random_index(words.len());
        match words.get(index) {
          Some(w) => {
            let mut w = w.clone();
            let unknown_word = w.create_unknown_word();
            self.guess = w.word;
            self.turns = self.guess.len() as u64;
            self.is_revealed = false;
            return Ok(unknown_word);
          }
          None => {
            let msg = format!("please chooose a number between 0 and {}", words.len() - 1);
            let i = Info {
              info: "Error".to_string(),
              description: msg,
              method: "random_word".to_string(),
            };
            return Err(i);
          }
        }
      }
      None => {
        let msg = format!("failed to get words from json ",);
        let i = Info {
          info: "Error".to_string(),
          description: msg,
          method: "random_word".to_string(),
        };
        return Err(i);
      }
    }
  }
  /* gets the usser solution to the random word created*/
  pub fn check_solution(&mut self, word: String) -> Result<String, Info> {
    let account_id = env::signer_account_id();
    let current_user = String::from(account_id);
    /*checks if the user id is equal to the saved id  from the randon word function  */
    match current_user == self.userid {
      true => {
        let mut w = self.guess.clone();
        let mut revealed_letters = Letter::reveal_letters(&mut w, word);
        self.word_progress = Letter::display_progress(&mut revealed_letters);
        /*it takes all the iterator in the letters vector and creats a single iterator thats iterates through all of the letters cheking if the user revealed the letter  and returns true if the letters are revealed*/
        // we are matching if the user account exixts
        let stamp = env::block_timestamp() as i64;
        match self.check_progress(self.turns, &revealed_letters) {
          Status::Completed => {
            let time = Utc
              .timestamp_nanos(stamp)
              .format("%a %b %e %T %Y")
              .to_string();

            self.completed.push(CompletedWord {
              word: String::from(&self.guess),
              status: String::from("completed"),
              trials_completed_at: String::from(format!("{} trials", self.turns)),
              completed_at: time,
            });

            let msg = format!("Congulatulations you won !!! ",);
            Ok(msg)
          }
          Status::Inprogress => {
            let msg = format!(
              "Progress {}      {}:trials remaining",
              &self.word_progress, &self.turns,
            );
            self.turns -= 1;
            Ok(msg)
          }
          Status::Failed => {
            let time = Utc
              .timestamp_nanos(stamp)
              .format("%a %b %e %T %Y")
              .to_string();

            self.completed.push(CompletedWord {
              word: String::from(&self.word_progress),
              status: String::from("failed"),
              trials_completed_at: format!("{} trials", self.turns),
              completed_at: format!("lost at {}", time),
            });
            let msg = format!(
              "Sorry you Lost the Game  {}    {}:trials remaining",
              &self.word_progress, &self.turns
            );
            Ok(msg)
          }
        }
      }
      false => {
        let err = format!("Sorry try again to geuss a random Word again",);
        Err(Info {
          info: "sorry".to_string(),
          description: err,
          method: "random_word".to_string(),
        })
      }
    }
  }

  /*checks the progress of the  game and returns  the status  */
  fn check_progress(&mut self, turns: u64, letters: &Vec<Letter>) -> Status {
    self.is_revealed = letters
      .iter()
      .zip(letters.iter())
      .all(|(_, c)| c.is_revealed);

    if self.is_revealed == true {
      return Status::Completed;
    } else if turns < 1 {
      return Status::Failed;
    } else {
      return Status::Inprogress;
    }
  }
  /*gets the complete words  */
  pub fn view_saved(&self) -> Result<&Vec<CompletedWord>, String> {
    let account_id = env::signer_account_id();
    let user = String::from(account_id);
    match self.userid == user {
      true => {
        if !&self.completed.is_empty() {
          Ok(&self.completed)
        } else {
          Err(String::from("Sorry You have not yet completed any words"))
        }
      }
      false => Err(String::from(
        "No completed  words available for this account",
      )),
    }
  }

  // this function adds more turns for the current word
  pub fn add_more_turns(&mut self) -> Result<Promise, String> {
    const ONE_NEAR: u128 = u128::pow(10, 24);

    let account_id = env::signer_account_id();
    let user = String::from(account_id.clone());
    let contract_id = env::current_account_id();
    match user == self.userid {
      true => {
        let balance = env::account_balance();
        let readable_bal = balance / ONE_NEAR;
        if readable_bal > 1 {
          self.turns = self.turns + 10;
          let msg = format!(
            "congrats  you added more  turns  {}turns available ",
            self.turns
          );
          env::log_str(&msg);

          env::log_str(&(balance / ONE_NEAR).to_string());
          Ok(Promise::new(contract_id).transfer(ONE_NEAR))
        } else {
          let err = format!("you dont't have enough balance ");
          Err(err)
        }
      }
      false => {
        let err = format!("failed to get account");
        Err(err)
      }
    }
  }
  // this generates a random index to generate a random wornd in the random_word function
  fn random_index(&self, max: usize) -> usize {
    //getting an rng from random seed
    let mut rng = Rng::new(&env::random_seed());
    let max_len = max as u64;
    let b = rng.rand_range_u64(0, max_len);
    b as usize
  }
}

#[cfg(test)]
mod tests {
  use super::*;
  use near_sdk::test_utils::VMContextBuilder;
  use near_sdk::{env, testing_env, AccountId, VMContext};

  const ONE_NEAR: u128 = u128::pow(10, 24);

  fn contract_account() -> AccountId {
    "contract".parse::<AccountId>().unwrap()
  }

  fn get_context(predecessor_account_id: AccountId) -> VMContext {
    let mut builder = VMContextBuilder::new();
    builder
      .current_account_id(contract_account())
      .account_balance(15 * ONE_NEAR)
      .signer_account_id(predecessor_account_id.clone())
      .predecessor_account_id(predecessor_account_id);
    builder.build()
  }

  #[test]
  fn test_create_unknown_word() {
    /* this test tests if the create_unknown_word function  hides the word  if the player has not yet  revealed it */
    let accountid = AccountId::new_unchecked("onchez.test".to_string());
    let context = get_context(accountid);
    testing_env!(context);
    let mut word = Vocabulary {
      example: "deploying a smartcontract to a near blockchain is easy and the smartcontract is faster other chains.".to_string(),
      meaning: "code that lives on the blockchain".to_string(),
      word: "smartcontract".to_string(),
    };

    let hidden_word = word.create_unknown_word();
    let msg = format!("{:#?}", hidden_word);
    env::log_str(&msg);
    assert_eq!(hidden_word.example, "deploying a  _ _ _ _ _ _ _ _ _ _ _ _ _ to a near blockchain is easy and the  _ _ _ _ _ _ _ _ _ _ _ _ _ is faster other chains.");
    assert_eq!(hidden_word.meaning, "code that lives on the blockchain");
    assert_eq!(hidden_word.word, " _ _ _ _ _ _ _ _ _ _ _ _ _");
  }

  #[test]
  fn test_get_letters() {
    /*
    This function Generates a vector of  characters  and creates a Struct of type letter for each  char in the letter
      [
       { letter: 'N', is_revealed: false },
       { letter: 'e', is_revealed: false },
       { letter: 'a', is_revealed: false },
       { letter: 'r', is_revealed: false }
      ]
    */
    let accountid = AccountId::new_unchecked("onchez.test".to_string());
    let context = get_context(accountid);
    testing_env!(context);
    let mut word = String::from("Near");
    let letters = Letter::get_letters(&mut word);

    assert_eq!(letters.len(), 4);
  }

  #[test]
  fn test_display_progress() {
    let accountid = AccountId::new_unchecked("onchez.test".to_string());
    let context = get_context(accountid);
    testing_env!(context);
    /*this function changes the state of  the letter  where its known  an replaces the rest with _ _ _*/
    let mut word = String::from("Near");
    let mut letters = Letter::get_letters(&mut word);

    //changing the state at index 0 and 3 to show letters
    for i in 0..letters.len() {
      if i == 0 || i == 3 {
        letters[i].is_revealed = true;
      }
    }
    let chars = &mut letters;

    let display_string = Letter::display_progress(chars);

    assert_eq!(display_string, " N _ _ r")
  }

  #[test]
  fn test_if_reveales_correct_letters() {
    /*this function tests if the  words that the user enters is equal to  word that the user entered and if its not equal it reveals only the letters that are the same in both the input ana the randomly generated word   */
    let accountid = AccountId::new_unchecked("onchez.test".to_string());
    let context = get_context(accountid);
    testing_env!(context);
    let mut user_random_chosen_word = "contract".to_string();
    let user_input = "contact".to_string();
    let mut revealed = Letter::reveal_letters(&mut user_random_chosen_word, user_input);
    let known_letters = Letter::display_progress(&mut revealed);

    assert_eq!(known_letters, " c o n t _ a c t")
  }

  #[test]
  fn get_data_from_jsons() {
    let accountid = AccountId::new_unchecked("onchez.test".to_string());
    let context = get_context(accountid);
    testing_env!(context);
    /* this function tests if the get data functions get data from a jsons and stores it in a vector so if the vector len () is greater tha zero it returns true  */

    let mut p = Player {
      userid: "onchez.testnet".to_string(),
      guess: String::from("Near"),
      word_progress: String::from("_ _ _"),
      completed: Vec::new(),
      turns: 0,
      is_revealed: false,
    };
    //getting  data from json
    let get_json_words = p.get_data().unwrap();
    let get_json_info = p.playinfo().unwrap();
    //ensures that the length of data read from json is not empty data else it panickes
    assert!(!get_json_words.is_empty());
    assert!(!get_json_info.is_empty())
  }

  #[test]
  fn how_to_play() {
    /*
     *this function  tests if values returned from json  is greater than 0
     *it then  asserts that a welcome field is added if the user doesnt exist
     */
    let accountid = AccountId::new_unchecked("onchez.test".to_string());
    let context = get_context(accountid);
    let player_id = String::from(context.signer_account_id.clone());
    testing_env!(context);

    //creating a new user instance
    let mut p = Player {
      userid: "onchez.testnet".to_string(),
      guess: String::from("Near"),
      word_progress: String::from("_ _ _"),
      completed: Vec::new(),
      turns: 0,
      is_revealed: false,
    };
    //calling the how_to_play function in  that returns a vector of  help info
    let helpinfo = p.how_to_play().unwrap();

    if p.userid == player_id {
      assert_eq!(helpinfo.len(), helpinfo.len() - 1);
    }

    assert!(!helpinfo.is_empty())
  }
  #[test]
  fn view_uncompleted_words() {
    let accountid = AccountId::new_unchecked("onchez.test".to_string());
    let context = get_context(accountid);

    testing_env!(context);
    //creating a new user instance
    let mut p = Player {
      userid: "onchez.testnet".to_string(),
      guess: String::from("Near"),
      word_progress: String::from("_ _ _"),
      completed: Vec::new(),
      turns: 0,
      is_revealed: false,
    };
    /*
    the view_uncompleted_words function returns a vector of hidden words where it is not empty
    */
    let uncompleted = p.view_available_words().unwrap();
    assert!(!uncompleted.is_empty());
  }

  #[test]
  fn test_random_word_is_picked_randomly() {
    let accountid = AccountId::new_unchecked("onchez.test".to_string());
    let context = get_context(accountid);
    // let player_id = String::from(context.signer_account_id.clone());
    testing_env!(context);
    //creating a new user instance
    let mut p = Player {
      userid: "onchez.testnet".to_string(),
      guess: String::from("Near"),
      word_progress: String::from("_ _ _"),
      completed: Vec::new(),
      turns: 0,
      is_revealed: false,
    };
    //this gets data at a certain index and  shows that it creats data from that index
    /*
    this  function get_random_word  fom an unknown index  randomly  we assert if the random word is availabele in the available_words vector

    */
    let data = p.get_data().unwrap();
    let random = p.random_word().unwrap();
    //the random index function takes in a maxmum  index of usize
    let random_index = p.random_index(data.len());

    assert_eq!(random.meaning, data[random_index].meaning);
  }

  #[test]
  fn test_if_the_userinput_solution_is_equal_saved_word() {
    /*this  */
    let accountid = AccountId::new_unchecked("onchez.test".to_string());
    let context = get_context(accountid);
    let player_id = String::from(context.signer_account_id.clone());
    testing_env!(context);
    //creating a new user instance
    let mut p = Player {
      userid: "onchez.testnet".to_string(),
      guess: String::from("Near"),
      word_progress: String::from("_ _ _"),
      completed: Vec::new(),
      turns: 0,
      is_revealed: false,
    };
    let input_solution = "Near".to_string();
    p.random_word().unwrap();
    //checks the solution if is the same as the word and returns status message

    let result = p.check_solution(input_solution);
    if p.userid == player_id {
      assert!(result.is_ok());
    }
    //if saved word dosent exist it returns an err
    if p.userid != player_id {
      assert!(result.is_err());
    }
  }

  #[test]
  fn test_progress() {
    /*this tests if  the check progress returns  fuctions  checks the progress of the user figuring out the word generated  and returns an enum  depending on the current progress status   */
    let accountid = AccountId::new_unchecked("onchez.test".to_string());
    let context = get_context(accountid);
    testing_env!(context);
    let mut p = Player {
      userid: "onchez.testnet".to_string(),
      guess: String::from("Near"),
      word_progress: String::from("_ _ _"),
      completed: Vec::new(),
      turns: 0,
      is_revealed: false,
    };

    //when turns are  above zero and word is not yet known returs  inprogress
    let mut turns = 6;
    let mut word = "near".to_string();
    let letters = Letter::get_letters(&mut word);
    let status = p.check_progress(turns, &letters);
    assert_eq!(Status::Inprogress, status);

    // when  all letters are  reveled returns a win
    //changing status to true
    turns = 4;
    let mut letters = Letter::get_letters(&mut word);
    for l in letters.iter_mut() {
      l.is_revealed = true;
    }
    let status = p.check_progress(turns, &letters);
    assert_eq!(Status::Completed, status);

    //when turns is 0 returns a fail
    turns = 0;
    let mut word = "near".to_string();
    let letters = Letter::get_letters(&mut word);
    let status = p.check_progress(turns, &letters);
    assert_eq!(Status::Failed, status);
  }

  #[test]
  fn test_view_completed() {
    /* generates  vector of compled words   */
    let accountid = AccountId::new_unchecked("onchez.test".to_string());
    let context = get_context(accountid);
    testing_env!(context);
    let mut p = Player {
      userid: "onchez.testnet".to_string(),
      guess: String::from("Near"),
      word_progress: String::from("_ _ _"),
      completed: Vec::new(),
      turns: 0,
      is_revealed: false,
    };
    let stamp = env::block_timestamp() as i64;
    let time = Utc.timestamp_nanos(stamp).format("%a %b %e %T %Y");
    p.completed.push(CompletedWord {
      word: String::from("near"),
      status: String::from("completed"),
      trials_completed_at: String::from("near"),
      completed_at: time.to_string(),
    });
    p.completed.push(CompletedWord {
      word: String::from("near"),
      status: String::from("completed"),
      trials_completed_at: String::from("near"),
      completed_at: time.to_string(),
    });
    p.completed.push(CompletedWord {
      word: String::from("near"),
      status: String::from("completed"),
      trials_completed_at: String::from("completed"),
      completed_at: time.to_string(),
    });

    assert_eq!(p.completed.len(), 3);
  }
  #[test]
  fn test_random_index() {
    let accountid = AccountId::new_unchecked("onchez.test".to_string());
    let context = get_context(accountid);
    testing_env!(context);
    let p = Player {
      userid: "onchez.testnet".to_string(),
      guess: String::from("Near"),
      word_progress: String::from("_ _ _"),
      completed: Vec::new(),
      turns: 0,
      is_revealed: false,
    };
    /*this function asserts that the give index doesn't exceed the maxmum number give */
    let max_lenth = 25 as usize;
    let index: usize = p.random_index(max_lenth);
    assert_eq!(max_lenth, index.max(max_lenth));
  }
  #[test]
  fn test_buy_more_turn() {
    let accountid = AccountId::new_unchecked("onchez.test".to_string());
    let context = get_context(accountid);
    let player_id = String::from(context.signer_account_id.clone());
    testing_env!(context);
    let mut p = Player {
      userid: "onchez.testnet".to_string(),
      guess: String::from("Near"),
      word_progress: String::from("_ _ _"),
      completed: Vec::new(),
      turns: 0,
      is_revealed: false,
    };
    let trasaction = p.add_more_turns();
    if player_id == p.userid {
      assert!(trasaction.is_ok())
    }
    assert!(trasaction.is_err())
  }
}

const WELCOME: &str = r#"
╦ ╦╔═╗╦═╗╔╦╗╔═╗╦ ╦╔═╗╔═╗╔═╗╦═╗  
║║║║ ║╠╦╝ ║║║  ╠═╣╠═╣╚═╗║╣ ╠╦╝  
╚╩╝╚═╝╩╚══╩╝╚═╝╩ ╩╩ ╩╚═╝╚═╝╩╚═ "#;

'''