*GitHub Repository "near/near-discovery-components"*

'''--- .github/ISSUE_TEMPLATE/bug_report.md ---
---
name: Bug report
about: Create a report to help us improve
title: ''
labels: ''
assignees: ''

---

**Describe the bug**
A clear and concise description of what the bug is.

**To Reproduce**
Steps to reproduce the behavior:
1. Go to '...'
2. Click on '....'
3. Scroll down to '....'
4. See error

**Expected behavior**
A clear and concise description of what you expected to happen.

**Screenshots**
If applicable, add screenshots to help explain your problem.

**Desktop (please complete the following information):**
 - OS: [e.g. iOS]
 - Browser [e.g. chrome, safari]
 - Version [e.g. 22]

**Smartphone (please complete the following information):**
 - Device: [e.g. iPhone6]
 - OS: [e.g. iOS8.1]
 - Browser [e.g. stock browser, safari]
 - Version [e.g. 22]

**Additional context**
Add any other context about the problem here.

'''
'''--- .github/ISSUE_TEMPLATE/feature_request.md ---
---
name: Feature request
about: Suggest an idea for this project
title: ''
labels: ''
assignees: ''

---

**Is your feature request related to a problem? Please describe.**
A clear and concise description of what the problem is. Ex. I'm always frustrated when [...]

**Describe the solution you'd like**
A clear and concise description of what you want to happen.

**Describe alternatives you've considered**
A clear and concise description of any alternative solutions or features you've considered.

**Additional context**
Add any other context or screenshots about the feature request here.

'''
'''--- .github/ISSUE_TEMPLATE/new-dig-component.md ---
---
name: New DIG Component
about: Add a new component to the DIG component library.
title: "[New Component] Component Name"
labels: product design
assignees: ''

---

## Component Description
Provide a description of the component and it's function.

### Sub-component(s)
If the component is composed of other sub-components, list those here:

- Sub-component
- Sub-component

## Screenshot

<br>
Insert screenshot here
<br>

## Figma Link

Insert a Figma link here

'''
'''--- .github/release.yml ---
---
changelog:
  exclude:
    labels:
      - ignore-for-release
    authors:
      - bot
  categories:
    - title: "\U0001F389 New Features"
      labels:
        - feature
    - title: "\U0001F6E0 Breaking Changes"
      labels:
        - breaking-change
    - title: "\U0001F41B Fixes"
      labels:
        - bug
    - title: "\U0001F31F Enhancements"
      labels:
        - enhancement

'''
'''--- .github/workflows/deploy-dev-testnet.yml ---
name: Deploy Widgets to Testnet Dev
on:
  push:
    branches: [develop]
jobs:
  deploy-widgets:
    runs-on: ubuntu-latest
    name: Deploy widgets to discom-dev.testnet
    env:
      NEAR_SOCIAL_ACCOUNT_ID: ${{ vars.NEAR_SOCIAL_TESTNET_DEV_ACCOUNT_ID }}
      NEAR_SOCIAL_ACCOUNT_PUBLIC_KEY: ${{ vars.NEAR_SOCIAL_TESTNET_DEV_ACCOUNT_PUBLIC_KEY }}
      NEAR_SOCIAL_ACCOUNT_PRIVATE_KEY: ${{ secrets.NEAR_SOCIAL_TESTNET_DEV_ACCOUNT_PRIVATE_KEY }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set replacements
        id: set_replacements
        run: |
          echo "replacements=$(jq -r '[to_entries[] | .["find"] = "${" + .key + "}" | .["replace"] = .value | del(.key, .value)]' replacements.dev.json | tr -d "\n\r")" >> $GITHUB_OUTPUT

      - name: Replace placeholders
        uses: flcdrg/replace-multiple-action@v1
        with:
          files: '**/*.jsx'
          find: '${{ steps.set_replacements.outputs.replacements }}'
          prefix: '(^|.*)'
          suffix: '($|.*)'

      - name: Install bos CLI
        run: |
          curl --proto '=https' --tlsv1.2 -LsSf https://github.com/FroVolod/bos-cli-rs/releases/download/v0.3.1/bos-cli-v0.3.1-installer.sh | sh
      
      - name: Deploy widgets
        run: |
          which bos
          echo $PATH
          bos components deploy "$NEAR_SOCIAL_ACCOUNT_ID" sign-as "$NEAR_SOCIAL_ACCOUNT_ID" network-config testnet sign-with-plaintext-private-key --signer-public-key "$NEAR_SOCIAL_ACCOUNT_PUBLIC_KEY" --signer-private-key "$NEAR_SOCIAL_ACCOUNT_PRIVATE_KEY" send

'''
'''--- .github/workflows/deploy-prod-mainnet.yml ---
name: Deploy Widgets to Mainnet
on:
  push:
    branches: [main]
jobs:
  deploy-widgets:
    runs-on: ubuntu-latest
    name: Deploy widgets to social.near (mainnet)
    env:
      NEAR_SOCIAL_DEPLOY_ID: ${{ vars.NEAR_SOCIAL_DEPLOY_ID }}
      NEAR_SOCIAL_ACCOUNT_ID: ${{ vars.NEAR_SOCIAL_ACCOUNT_ID }}
      NEAR_SOCIAL_ACCOUNT_PUBLIC_KEY: ${{ vars.NEAR_SOCIAL_ACCOUNT_PUBLIC_KEY }}
      NEAR_SOCIAL_ACCOUNT_PRIVATE_KEY: ${{ secrets.NEAR_SOCIAL_ACCOUNT_PRIVATE_KEY }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set replacements
        id: set_replacements
        run: |
          echo "replacements=$(jq -r '[to_entries[] | .["find"] = "${" + .key + "}" | .["replace"] = .value | del(.key, .value)]' replacements.mainnet.json | tr -d "\n\r")" >> $GITHUB_OUTPUT

      - name: Replace placeholders
        uses: flcdrg/replace-multiple-action@v1
        with:
          files: '**/*.jsx'
          find: '${{ steps.set_replacements.outputs.replacements }}'
          prefix: '(^|.*)'
          suffix: '($|.*)'

      - name: Install bos CLI
        run: |
          curl --proto '=https' --tlsv1.2 -LsSf https://github.com/FroVolod/bos-cli-rs/releases/download/v0.3.2/bos-cli-installer.sh | sh
      
      - name: Deploy widgets
        run: |
          which bos
          echo $PATH
          bos components deploy "$NEAR_SOCIAL_DEPLOY_ID" sign-as "$NEAR_SOCIAL_ACCOUNT_ID" network-config mainnet sign-with-plaintext-private-key --signer-public-key "$NEAR_SOCIAL_ACCOUNT_PUBLIC_KEY" --signer-private-key "$NEAR_SOCIAL_ACCOUNT_PRIVATE_KEY" send

'''
'''--- .github/workflows/deploy-prod-testnet.yml ---
name: Deploy Widgets to Testnet
on:
  push:
    branches: [main]
jobs:
  deploy-widgets:
    runs-on: ubuntu-latest
    name: Deploy widgets to discom.testnet
    env:
      NEAR_SOCIAL_ACCOUNT_ID: ${{ vars.NEAR_SOCIAL_TESTNET_ACCOUNT_ID }}
      NEAR_SOCIAL_ACCOUNT_PUBLIC_KEY: ${{ vars.NEAR_SOCIAL_TESTNET_ACCOUNT_PUBLIC_KEY }}
      NEAR_SOCIAL_ACCOUNT_PRIVATE_KEY: ${{ secrets.NEAR_SOCIAL_TESTNET_ACCOUNT_PRIVATE_KEY }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set replacements
        id: set_replacements
        run: |
          echo "replacements=$(jq -r '[to_entries[] | .["find"] = "${" + .key + "}" | .["replace"] = .value | del(.key, .value)]' replacements.testnet.json | tr -d "\n\r")" >> $GITHUB_OUTPUT

      - name: Replace placeholders
        uses: flcdrg/replace-multiple-action@v1
        with:
          files: '**/*.jsx'
          find: '${{ steps.set_replacements.outputs.replacements }}'
          prefix: '(^|.*)'
          suffix: '($|.*)'

      - name: Install bos CLI
        run: |
          curl --proto '=https' --tlsv1.2 -LsSf https://github.com/FroVolod/bos-cli-rs/releases/download/v0.3.2/bos-cli-installer.sh | sh
      
      - name: Deploy widgets
        run: |
          which bos
          echo $PATH
          bos components deploy "$NEAR_SOCIAL_ACCOUNT_ID" sign-as "$NEAR_SOCIAL_ACCOUNT_ID" network-config testnet sign-with-plaintext-private-key --signer-public-key "$NEAR_SOCIAL_ACCOUNT_PUBLIC_KEY" --signer-private-key "$NEAR_SOCIAL_ACCOUNT_PRIVATE_KEY" send

'''
'''--- .github/workflows/promote-develop-to-main.yml ---
name: weekly-production-release

on:
  schedule:
    - cron: '0 0 * * 2,4'

permissions: 
  pull-requests: write

jobs:
  pull-request:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/develop'
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: pull-request
        run: |
          gh pr create --base main --head develop -f -a shelegdmitriy -a calebjacob -a marcinbodnar --title "weekly promotion of develop to main"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

'''
'''--- .github/workflows/prs_must_have_labels.yml ---
---
name: Label Checker
on:
  pull_request:
    types:
      - opened
      - synchronize
      - reopened
      - labeled
      - unlabeled

jobs:

  check_labels:
    name: Check labels
    runs-on: ubuntu-latest
    steps:
      - uses: docker://agilepathway/pull-request-label-checker:latest
        with:
          one_of: bug,feature,enhancement,dependency,breaking-change,ignore-for-release,refactor
          repo_token: ${{ secrets.CG_PROJECT_WORKFLOW_SECRET }}

'''
'''--- .github/workflows/release_notes.yml ---
name: Automatic Github Releases

on: 
  push:
    branches:
      - "main"

jobs:
  update_release_draft:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
    - name: Get current date
      id: date
      run: echo "tag=$(date +'%m-%d-%Y')"  >> "$GITHUB_OUTPUT"
    - uses: actions/checkout@v4
    - uses: ncipollo/release-action@v1.14.0
      with:
        generateReleaseNotes: true
        tag: ${{ steps.date.outputs.tag }}
        makeLatest: true
        allowUpdates: false
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

'''
'''--- .github/workflows/stale.yml ---
name: Close Stale Pull Requests

on:
  schedule:
    - cron: '0 0 * * 5'  # Run at midnight on Fridays

permissions:
  issues: write
  pull-requests: write

jobs:
  close_stale_prs:
    runs-on: ubuntu-latest
    steps:
      - name: Close stale pull requests
        uses: actions/stale@v9.0.0

        with:
          repo-token: ${{ secrets.GITHUB_TOKEN }}
          days-before-issue-stale: 180
          days-before-pr-stale: 45
          days-before-close: 0
          close-issue-message: 'This issue has been automatically closed because it has been inactive for more than 180 days. Please reopen and prioritize this for development if it is essential.'
          close-pr-message: 'This pull request has been automatically closed because it has been inactive for more than 45 days. Please reopen and see this PR through its review if it is essential.'

'''
'''--- CODE_OF_CONDUCT.md ---
# Contributor Covenant Code of Conduct

## Our Pledge

In the interest of fostering an open and welcoming environment, we as
contributors and maintainers pledge to making participation in our project and
our community a harassment-free experience for everyone, regardless of age, body
size, disability, ethnicity, sex characteristics, gender identity and expression,
level of experience, education, socio-economic status, nationality, personal
appearance, race, religion, or sexual identity and orientation.

## Our Standards

Examples of behavior that contributes to creating a positive environment
include:

* Using welcoming and inclusive language
* Being respectful of differing viewpoints and experiences
* Gracefully accepting constructive criticism
* Focusing on what is best for the community
* Showing empathy towards other community members

Examples of unacceptable behavior by participants include:

* The use of sexualized language or imagery and unwelcome sexual attention or
 advances
* Trolling, insulting/derogatory comments, and personal or political attacks
* Public or private harassment
* Publishing others' private information, such as a physical or electronic
 address, without explicit permission
* Other conduct which could reasonably be considered inappropriate in a
 professional setting

## Our Responsibilities

Project maintainers are responsible for clarifying the standards of acceptable
behavior and are expected to take appropriate and fair corrective action in
response to any instances of unacceptable behavior.

Project maintainers have the right and responsibility to remove, edit, or
reject comments, commits, code, wiki edits, issues, and other contributions
that are not aligned to this Code of Conduct, or to ban temporarily or
permanently any contributor for other behaviors that they deem inappropriate,
threatening, offensive, or harmful.

## Scope

This Code of Conduct applies both within project spaces and in public spaces
when an individual is representing the project or its community. Examples of
representing a project or community include using an official project e-mail
address, posting via an official social media account, or acting as an appointed
representative at an online or offline event. Representation of a project may be
further defined and clarified by project maintainers.

## Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be
reported by contacting the project team at devconsole-team@pagoda.co. All
complaints will be reviewed and investigated and will result in a response that
is deemed necessary and appropriate to the circumstances. The project team is
obligated to maintain confidentiality with regard to the reporter of an incident.
Further details of specific enforcement policies may be posted separately.

Project maintainers who do not follow or enforce the Code of Conduct in good
faith may face temporary or permanent repercussions as determined by other
members of the project's leadership.

## Attribution

This Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4,
available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html

[homepage]: https://www.contributor-covenant.org

For answers to common questions about this code of conduct, see
https://www.contributor-covenant.org/faq

'''
'''--- CONTRIBUTING.md ---
Thank you for your interest in contributing to the Near Blockchain Operating System's Decentralized Interface Guidelines and the Near Discovery gateway's components.  We welcome contributions from everyone.  Below are various bits of information to help you get started.  If you require additional help, please start a [Discussion](https://github.com/near/near-discovery-components/discussions).

## Next Steps

To learn more about how to setup your local environment to efficiently work on BOS components for the Near Discovery gateway, [checkout this guide](https://github.com/near/near-discovery-components#near-discovery-widgets).

If you are looking for relatively simple tasks to familiarise yourself with
component development for the Discovery Gateway, take a look at the issues labeled `good first issue`
[here](https://github.com/near/near-discovery-components/labels/good%20first%20issue).  If you see
one that looks interesting and is unassigned or has not been actively worked on
in some time, please go ahead and start working towards creating your first pull request.

If you have an idea for an enhancement to Near Discovery's components, please submit a [feature request](https://github.com/near/near-discovery-components/issues/new?assignees=&labels=&projects=&template=feature_request.md&title=)

## Testing across multiple environments
When referencing a component or any parameter that depends on the network, please use the placeholders defined in `replacements.*.json`. There are three such files that correspond to different environments:

`replacements.dev.json` - deploys the develop branch, to testnet @ test.beta.near.org

`replacements.testnet.json` - deploys main branch, to testnet @ test.near.org

`replacements.mainnet.json` - deploys main branch to mainnet @ near.org

Placeholders should be encapsulated in the `${}` expression. Here is an example of a placeholder usage:

`<Widget src={homepage ?? "${REPL_ACCOUNT}/widget/ActivityPage"} />`
or
`<Widget src="${REPL_ACCOUNT}/widget/DIG.Button" />`

Placeholders are replaced with the target values specified in `replacements.*.json` when github actions deploys the components.

Feel free to specify a new placeholder if needed. The placeholder should have a `REPL_` prefix, for example: `REPL_PROJECT_NAME`

A new placeholder should be defined for all three environments: dev-testnet, prod-testnet and prod-mainnet.

## Local development with BOS-Loader
Use the latest version of [bos-loader](https://github.com/near/bos-loader) to faciliate testing the appearance and behavior of your components from a locally running viewer, or [near.org](https://near.org).

### Heads up!
One trick when using [bos-loader](https://github.com/near/bos-loader) with this `near-discovery-components` repository:
1. Open one of `replacements.*.json` depending on what environment you are about to start working on. Try to use `replacements.testnet.json` if you're not sure.
2. Delete the `REPL_ACCOUNT` line. This step is needed because you need to specify a `REPL_ACCOUNT` value when launching the `bos-loader`.
3. Open `near-discovery-components` in your terminal.
4. Navigate to `src` directory.
5. Run this command:
```bash
bos-loader -r ../replacements.<working-env>.json <account-name>
```

*Don't forget to specify your working environment and account name!*

If you did everything right you have to see such message in your terminal:

```
Serving .jsx files on http://127.0.0.1:3030

. as account <account-name>
```

6. Open the `/flags` route of your gateway and set the BOS Loader URL e.g. `http://127.0.0.1:3030`.
   If you are not testing changes to gateway code, then you can use `near.org` as your gateway. In this case you would navigate to `near.org/flags` and set the BOS Loader URL to `http://127.0.0.1:3030`.

*Note:* there is no hot reload, you must refresh the page to see component changes.

#### Do not commit `replacements.*.json` changes unless you have added a new `REPL_` variable

### Example:

```bash
bos-loader -r ../replacements.testnet.json discom.testnet
```

## Pull Requests
All the contributions to `near-discovery-components` happen via Pull Requests.  Please follow the following steps when creating a PR:

1. Fork the `near-discovery-components` repository and create a new branch to do you work there.
2. The branch can contain any number of commits.  When merged, all commits will
   be squashed into a single commit.
3. Thoroughly test your changes.
4. When ready, create a pull request against the `develop` branch of `near-discovery-components`.
5. Feel free to submit draft PRs to get early feedback and to make sure you are
   on the right track.
6. The PR name should follow the template: `<type>: <name>`.  Where `type` is:
   - `fix` for bug fixes;
   - `feat` for new features;
   - `refactor` for changes that reorganize code without adding new content;
   - `doc` for changes that change documentation or comments;
   - `test` for changes that introduce new tests;
   - `chore` for grunt tasks like updating dependencies.
7. The PR should also contain a description when appropriate to provide
   additional information to help the reviewer inspect the proposed change.

## After the PR is submitted

1. When all the comments from the reviewer(s) have been addressed, the reviewer should
approve the PR.
2. An approved PR will be merged automatically into `develop`, which is continuously deployed to [test.near.org](https://test.near.org)

## Release Schedule
Changes from `develop` are promoted to the `main` branch weekly, on Thursdays.

'''
'''--- README.md ---
# Near Discovery Components

This is a repository that holds the source code of all NEAR discovery components that the team maintains for [near.org](https://near.org).

Components will be deployed to production automatically as they are merged into the main branch. This occurs weekly, on Thursdays.

Keep in mind that folders under `src` will be prepended to the component name when it's deployed. E.g. `src/post/comment.jsx` will be deployed as `post.comment`.

### Deployments Across Discovery Gateways
#### tl;dr;
>test.beta.near.org => discom-dev.testnet

>test.near.org => discom.testnet

>near.org => near TLA

>beta.near.org => near TLA

The [discovery gateway](https://github.com/near/near-discovery) deploys its main and develop branches across environments as follows
- the `main` branch is deployed on [near.org](https://near.org), pointing to `mainnet` and [test.near.org](https://test.near.org) pointing to `testnet`
- the `develop` branch is deployed to [beta.near.org](https://beta.near.org), pointing to `mainnet`, and [test.beta.near.org](https://test.beta.near.org), pointing to `testnet`

This `discovery-components` repo deploys main and develop branches across accounts as follows
- the `main` branch deploys components to the near top-level-acount for `mainnet` and `discom.testnet` for `testnet` except where indicated otherwise in replacements.[mainnet/testnet].json
- the `develop` branch deploys components to `discom-dev.testnet` except where indicated otherwise in replacements.dev.json; there is currently no mainnet deployment for the develop branch.

## Contributing

Please review the [contribution guide](CONTRIBUTING.md)

## Local Development

Please review the [Local development with BOS-Loader](CONTRIBUTING.md#local-development-with-bos-loader)

*Note:* This repository is not compatible with the [VS Code Extension](https://docs.near.org/bos/dev/vscode) due to the [replacements](CONTRIBUTING.md#testing-across-multiple-environments) strategy featured in this repository.

## Troubleshooting Deployments

`near-social` cli tool will attempt to deploy any updated components with 1 NEAR of deposit and 100 Tgas.

The deployment may fail if too many changes are present. There are several solutions for this. You can either plan releases more often or release components in batches from your local using `near-social`.

If you get a `Not enough storage balance` error, you will need to make sure that the NEAR account has enough storage staked on the `social.near` contract. You can view the current storage and available storage for any account using `near-cli-rs`:

`near-cli contract call-function as-read-only social.near storage_balance_of json-args '{"account_id":"adminalpha.near"}' network-config mainnet now`

Note: replace `adminalpha.near` with any other account name on mainnet.

You can then stake more of your NEAR for storage on `social.near` using `near-cli-rs`:

`near-cli contract call-function as-transaction social.near storage_deposit json-args {} prepaid-gas '100.000 TeraGas' attached-deposit '0.5 NEAR' sign-as adminalpha.near network-config mainnet sign-with-seed-phrase '{{REPLACE_WITH_SEED_PHRASE}}' --seed-phrase-hd-path 'm/44'\''/397'\''/0'\'''`

'''
'''--- commitlint.config.js ---
module.exports = {extends: ['@commitlint/config-conventional']}

'''
'''--- indexers/README.md ---
# QueryApi Indexers used by components

Several components use QueryApi Indexers as a source of data, specifically the ActivityFeed Posts & 'Following' Posts.

These indexers can be modified at https://near.org/dataplatform.near/widget/QueryApi.App under the dataplatform.near account.

Each indexer has a .sql schema file and a .js file which contains the Indexer Function code.

'''
'''--- indexers/accounts/accounts.js ---
import { Block } from "@near-lake/primitives";
/**
 * Note: We only support javascript at the moment. We will support Rust, Typescript in a further release.
 */

/**
 * getBlock(block, context) applies your custom logic to a Block on Near and commits the data to a database.
 * context is a global variable that contains helper methods.
 * context.db is a subfield which contains helper methods to interact with your database.
 *
 * Learn more about indexers here:  https://docs.near.org/concepts/advanced/indexers
 *
 * @param {block} Block - A Near Protocol Block
 */
async function getBlock(block: Block) {
  const SOCIAL_DB = "social.near";

  function base64decode(encodedValue) {
    let buff = Buffer.from(encodedValue, "base64");
    return JSON.parse(buff.toString("utf-8"));
  }

  async function handleAccountProfileData(
    accountId,
    blockHeight,
    blockTimestamp,
    profileAction
  ) {
    const profileData = profileAction.args.data[accountId].profile;

    if (!profileData) {
      return;
    }

    try {
      console.log(
        `Attemp to store account data for account and fields:  ${Object.keys(
          profileAction
        ).join(", ")}`
      );
      const fields = Object.keys(profileData);
      const valuesToStrings = {};

      fields.forEach((field) => {
        switch (field) {
          case "image":
          case "linktree":
          case "tags":
            valuesToStrings[field] = JSON.stringify(profileData[field]);
            break;
          case "backgroundImage":
            valuesToStrings.background_image = JSON.stringify(
              profileData.backgroundImage
            );
            break;
          case "horizon_tnc":
            valuesToStrings.horizon_tnc = JSON.parse(profileData.horizon_tnc);
            break;
          default:
            valuesToStrings[field] = profileData[field];
            break;
        }
      });

      await context.db.Accounts.upsert(
        {
          account_id: accountId,
          block_height: blockHeight,
          block_timestamp_ms: blockTimestamp,
          ...valuesToStrings,
        },
        ["account_id"],
        Object.keys(valuesToStrings)
      );
    } catch (error) {
      console.log(`Failed to store data for ${accountId}. Error ${error}`);
    }
  }

  let accountProfileActions = [];
  try {
    const actions = block.actions();

    if (!actions) {
      console.log("Block has no actions");
      return;
    }
    const contractActions = actions.filter(
      (action) => action.receiverId === SOCIAL_DB
    );
    if (!contractActions) {
      console.log("Block has no actions");
      return;
    }
    accountProfileActions = contractActions.flatMap((action) =>
      action.operations
        .map((operation) => operation["FunctionCall"])
        .filter((operation) => operation?.methodName === "set")
        .map((functionCallOperation) => {
          try {
            return {
              ...functionCallOperation,
              args: base64decode(functionCallOperation.args),
              receiptId: action.receiptId, // providing receiptId as we need it
            };
          } catch (e) {
            console.log("Error parsing function call", e);
          }
        })
        .filter((functionCall) => {
          try {
            if (
              !functionCall ||
              !functionCall.args ||
              !functionCall.args.data ||
              !Object.keys(functionCall.args.data) ||
              !Object.keys(functionCall.args.data)[0]
            ) {
              console.log(
                "Set operation did not have arg data in expected format"
              );
              return;
            }
            const accountId = Object.keys(functionCall.args.data)[0];
            if (!functionCall.args.data[accountId]) {
              console.log(
                `Set operation did not have data for account ${accountId}`
              );
              return;
            }
            return Object.keys(functionCall.args.data[accountId]).includes(
              "profile"
            );
          } catch (e) {
            console.log("Error parsing social args", functionCall);
          }
        })
    );
  } catch (error) {
    console.log("Error parsing social operations", block.actions());
  }

  if (accountProfileActions.length > 0) {
    const blockHeight = block.blockHeight;
    const blockTimestamp = block.header().timestampNanosec;
    await Promise.all(
      accountProfileActions.map(async (profileAction) => {
        const accountId = Object.keys(profileAction.args.data)[0];
        console.log(`ACCOUNT_ID: ${accountId}`);
        await handleAccountProfileData(
          accountId,
          blockHeight,
          blockTimestamp,
          profileAction
        );
      })
    );
  }
}

'''
'''--- indexers/accounts/accounts.sql ---
CREATE TABLE
  "accounts" (
    "account_id" text NOT NULL,
    "block_height" INT NOT NULL,
    "block_timestamp_ms" BIGINT NOT NULL,
    "name" text,
    "description" text,
    "image" text,
    "background_image" text,
    "horizon_tnc" boolean,
    "linktree" text,
    "tags" text,
    PRIMARY KEY ("account_id")
  )

'''
'''--- indexers/components/components.js ---
import { Block } from "@near-lake/primitives";

/**
 * Note: We only support javascript at the moment. We will support Rust, Typescript in a further release.
 */

/**
 * getBlock(block, context) applies your custom logic to a Block on Near and commits the data to a database.
 * context is a global variable that contains helper methods.
 * context.db is a subfield which contains helper methods to interact with your database.
 *
 * Learn more about indexers here:  https://docs.near.org/concepts/advanced/indexers
 *
 * @param {block} Block - A Near Protocol Block
 */
async function getBlock(block: Block) {
  const ACCOUNT_NAME = "dataplatform_near";
  const INDEXER_NAME = `${ACCOUNT_NAME}_components`;
  const METADATA_TABLE = `${INDEXER_NAME}_metadata`;
  const VERSION_TABLE = `${INDEXER_NAME}_versions`;
  //dataplatform_near_components

  // =============================
  // Begin inclusion of diff library: https://github.com/kpdecker/jsdiff
  // =============================
  function Diff() { }

  Diff.prototype = {
    diff(oldString, newString, options = {}) {
      let callback = options.callback;
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      this.options = options;

      let self = this;

      function done(value) {
        if (callback) {
          setTimeout(function () {
            callback(undefined, value);
          }, 0);
          return true;
        } else {
          return value;
        }
      }

      // Allow subclasses to massage the input prior to running
      oldString = this.castInput(oldString);
      newString = this.castInput(newString);

      oldString = this.removeEmpty(this.tokenize(oldString));
      newString = this.removeEmpty(this.tokenize(newString));

      let newLen = newString.length,
        oldLen = oldString.length;
      let editLength = 1;
      let maxEditLength = newLen + oldLen;
      if (options.maxEditLength) {
        maxEditLength = Math.min(maxEditLength, options.maxEditLength);
      }

      let bestPath = [{ newPos: -1, components: [] }];

      // Seed editLength = 0, i.e. the content starts with the same values
      let oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);
      if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {
        // Identity per the equality and tokenizer
        return done([{ value: this.join(newString), count: newString.length }]);
      }

      // Main worker method. checks all permutations of a given edit length for acceptance.
      function execEditLength() {
        for (
          let diagonalPath = -1 * editLength;
          diagonalPath <= editLength;
          diagonalPath += 2
        ) {
          let basePath;
          let addPath = bestPath[diagonalPath - 1],
            removePath = bestPath[diagonalPath + 1],
            oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;
          if (addPath) {
            // No one else is going to attempt to use this value, clear it
            bestPath[diagonalPath - 1] = undefined;
          }

          let canAdd = addPath && addPath.newPos + 1 < newLen,
            canRemove = removePath && 0 <= oldPos && oldPos < oldLen;
          if (!canAdd && !canRemove) {
            // If this path is a terminal then prune
            bestPath[diagonalPath] = undefined;
            continue;
          }

          // Select the diagonal that we want to branch from. We select the prior
          // path whose position in the new string is the farthest from the origin
          // and does not pass the bounds of the diff graph
          if (!canAdd || (canRemove && addPath.newPos < removePath.newPos)) {
            basePath = clonePath(removePath);
            self.pushComponent(basePath.components, undefined, true);
          } else {
            basePath = addPath; // No need to clone, we've pulled it from the list
            basePath.newPos++;
            self.pushComponent(basePath.components, true, undefined);
          }

          oldPos = self.extractCommon(
            basePath,
            newString,
            oldString,
            diagonalPath
          );

          // If we have hit the end of both strings, then we are done
          if (basePath.newPos + 1 >= newLen && oldPos + 1 >= oldLen) {
            return done(
              buildValues(
                self,
                basePath.components,
                newString,
                oldString,
                self.useLongestToken
              )
            );
          } else {
            // Otherwise track this path as a potential candidate and continue.
            bestPath[diagonalPath] = basePath;
          }
        }

        editLength++;
      }

      // Performs the length of edit iteration. Is a bit fugly as this has to support the
      // sync and async mode which is never fun. Loops over execEditLength until a value
      // is produced, or until the edit length exceeds options.maxEditLength (if given),
      // in which case it will return undefined.
      if (callback) {
        (function exec() {
          setTimeout(function () {
            if (editLength > maxEditLength) {
              return callback();
            }

            if (!execEditLength()) {
              exec();
            }
          }, 0);
        })();
      } else {
        while (editLength <= maxEditLength) {
          let ret = execEditLength();
          if (ret) {
            return ret;
          }
        }
      }
    },

    pushComponent(components, added, removed) {
      let last = components[components.length - 1];
      if (last && last.added === added && last.removed === removed) {
        // We need to clone here as the component clone operation is just
        // as shallow array clone
        components[components.length - 1] = {
          count: last.count + 1,
          added: added,
          removed: removed,
        };
      } else {
        components.push({ count: 1, added: added, removed: removed });
      }
    },
    extractCommon(basePath, newString, oldString, diagonalPath) {
      let newLen = newString.length,
        oldLen = oldString.length,
        newPos = basePath.newPos,
        oldPos = newPos - diagonalPath,
        commonCount = 0;
      while (
        newPos + 1 < newLen &&
        oldPos + 1 < oldLen &&
        this.equals(newString[newPos + 1], oldString[oldPos + 1])
      ) {
        newPos++;
        oldPos++;
        commonCount++;
      }

      if (commonCount) {
        basePath.components.push({ count: commonCount });
      }

      basePath.newPos = newPos;
      return oldPos;
    },

    equals(left, right) {
      if (this.options.comparator) {
        return this.options.comparator(left, right);
      } else {
        return (
          left === right ||
          (this.options.ignoreCase &&
            left.toLowerCase() === right.toLowerCase())
        );
      }
    },
    removeEmpty(array) {
      let ret = [];
      for (let i = 0; i < array.length; i++) {
        if (array[i]) {
          ret.push(array[i]);
        }
      }
      return ret;
    },
    castInput(value) {
      return value;
    },
    tokenize(value) {
      return value.split("");
    },
    join(chars) {
      return chars.join("");
    },
  };

  function buildValues(
    diff,
    components,
    newString,
    oldString,
    useLongestToken
  ) {
    let componentPos = 0,
      componentLen = components.length,
      newPos = 0,
      oldPos = 0;

    for (; componentPos < componentLen; componentPos++) {
      let component = components[componentPos];
      if (!component.removed) {
        if (!component.added && useLongestToken) {
          let value = newString.slice(newPos, newPos + component.count);
          value = value.map(function (value, i) {
            let oldValue = oldString[oldPos + i];
            return oldValue.length > value.length ? oldValue : value;
          });

          component.value = diff.join(value);
        } else {
          component.value = diff.join(
            newString.slice(newPos, newPos + component.count)
          );
        }
        newPos += component.count;

        // Common case
        if (!component.added) {
          oldPos += component.count;
        }
      } else {
        component.value = diff.join(
          oldString.slice(oldPos, oldPos + component.count)
        );
        oldPos += component.count;

        // Reverse add and remove so removes are output first to match common convention
        // The diffing algorithm is tied to add then remove output and this is the simplest
        // route to get the desired output with minimal overhead.
        if (componentPos && components[componentPos - 1].added) {
          let tmp = components[componentPos - 1];
          components[componentPos - 1] = components[componentPos];
          components[componentPos] = tmp;
        }
      }
    }

    // Special case handle for when one terminal is ignored (i.e. whitespace).
    // For this case we merge the terminal into the prior string and drop the change.
    // This is only available for string mode.
    let lastComponent = components[componentLen - 1];
    if (
      componentLen > 1 &&
      typeof lastComponent.value === "string" &&
      (lastComponent.added || lastComponent.removed) &&
      diff.equals("", lastComponent.value)
    ) {
      components[componentLen - 2].value += lastComponent.value;
      components.pop();
    }

    return components;
  }

  function clonePath(path) {
    return { newPos: path.newPos, components: path.components.slice(0) };
  }

  const lineDiff = new Diff();
  lineDiff.tokenize = function (value) {
    let retLines = [],
      linesAndNewlines = value.split(new RegExp("(\\n|\r\\n)"));

    // Ignore the final empty token that occurs if the string ends with a new line
    if (!linesAndNewlines[linesAndNewlines.length - 1]) {
      linesAndNewlines.pop();
    }

    // Merge the content and line separators into single tokens
    for (let i = 0; i < linesAndNewlines.length; i++) {
      let line = linesAndNewlines[i];

      if (i % 2 && !this.options.newlineIsToken) {
        retLines[retLines.length - 1] += line;
      } else {
        if (this.options.ignoreWhitespace) {
          line = line.trim();
        }
        retLines.push(line);
      }
    }

    return retLines;
  };

  // =============================
  // End inclusion of diff library
  // =============================

  function base64decode(encodedValue) {
    try {
      const buff = Buffer.from(encodedValue, "base64");
      const str = buff.toString("utf-8").replace(/\\xa0/g, ' ');
      return JSON.parse(str);
    }
    catch (error) {
      console.log('Error parsing JSON - skipping data for "functionCallOperation.args"', error);
    }
  }

  const SOCIAL_DB = "social.near";

  const nearSocialActions = block
    .actions()
    .filter((action) => action.receiverId === SOCIAL_DB)
    .flatMap((action) =>
      action.operations
        .map((operation) => operation["FunctionCall"])
        .filter((operation) => operation?.methodName === "set")
        .map((functionCallOperation) => ({
          ...functionCallOperation,
          args: base64decode(functionCallOperation.args),
          receiptId: action.receiptId,
        }))
        .filter((a) =>
          block
            .receipts()
            .find((r) => r.receiptId === a.receiptId)
            .status.hasOwnProperty("SuccessValue")
        )
    );

  const componentUpdateTransactions = nearSocialActions.filter(
    (functionCall) => {
      if (
        !functionCall ||
        !functionCall.args ||
        !functionCall.args.data ||
        !Object.keys(functionCall.args.data) ||
        !Object.keys(functionCall.args.data)[0]
      ) {
        console.log(
          "Set operation did not have arg data in expected format"
        );
        return;
      }
      const accountId = Object.keys(functionCall.args.data)[0];
      const accountData = functionCall.args.data[accountId];
      if (!accountData) {
        console.log(
          "Set operation did not have arg data for accountId in expected format"
        );
        return;
      }
      return Object.keys(accountData).includes(
        "widget"
      );
    });

  const componentStarTransactions = nearSocialActions.filter(
    (functionCall) => {
      if (
        !functionCall ||
        !functionCall.args ||
        !functionCall.args.data ||
        !Object.keys(functionCall.args.data) ||
        !Object.keys(functionCall.args.data)[0]
      ) {
        console.log(
          "Set operation did not have arg data in expected format"
        );
        return;
      }
      const accountId = Object.keys(functionCall.args.data)[0];
      if (!functionCall.args.data[accountId]) {
        console.log("Set operation did not have arg data for accountId");
        return;
      }
      const data_keys = Object.keys(functionCall.args.data[accountId]);
      if (!data_keys) {
        console.log(
          "Set operation did not have arg data for accountId in expected format"
        );
        return;
      }

      const has_index = data_keys.includes("index");
      let index_wrapper = null;
      if (has_index) index_wrapper = functionCall.args.data[accountId]
      return (has_index && index_wrapper?.index?.star);
    });

  if (componentUpdateTransactions.length > 0) {

    const blockHeight = block.header().height;
    const blockTimestampMs = Math.floor(
      Number(block.header().timestampNanosec) / 1e6
    );

    for (const transaction of componentUpdateTransactions) {
      const receiptId = transaction.receiptId;
      const componentAuthorId = Object.keys(transaction.args.data)[0];
      const rawComponentData =
        transaction.args.data[componentAuthorId]["widget"] || {};
      const componentNames = Object.keys(rawComponentData);

      for (const componentName of componentNames) {
        if (
          !componentName ||
          !Object.keys(rawComponentData).length ||
          !rawComponentData[componentName]
        )
          continue;

        const metadata = rawComponentData[componentName]["metadata"];
        const code = rawComponentData[componentName][""] || "";

        let previousCode = "";
        let linesAdded = 0;
        let linesRemoved = 0;

        const rawGraphqlResponse = await context.graphql(
          `query PreviousVersionQuery($componentAuthorId: String, $componentName: String, $blockHeight: Int) {
              ${VERSION_TABLE}(
                limit: 1
                where: {component_author_id: {_eq: $componentAuthorId}, component_name: {_eq: $componentName}, block_height: {_lt: $blockHeight}}
                order_by: {block_height: desc}
              ) {
                id
                code
              }
            }`,
          {
            componentAuthorId,
            componentName,
            blockHeight,
          }
        );

        const previousVersions = rawGraphqlResponse[VERSION_TABLE] ?? [];
        previousCode = previousVersions[0] ? previousVersions[0].code : "";
        const diff = lineDiff.diff(previousCode, code, { ignoreWhitespace: true, });

        diff.forEach((result) => {
          if (result.added) linesAdded += result.count;
          if (result.removed) linesRemoved += result.count;
        });

        let forkSource = metadata?.fork_of
          ? metadata?.fork_of.split("@")[0]
          : null;
        let forkBlockHeight = metadata?.fork_of
          ? metadata?.fork_of.split("@")[1]
          : null;
        if (forkSource === `${componentAuthorId}/widget/${componentName}`) {
          forkSource = null;
          forkBlockHeight = null;
        }

        if (forkSource) {
          const rawGraphqlResponseForkSource = await context.graphql(
            `query PreviousMetaDataQuery($forkSource: String, $componentName: String) {
                ${METADATA_TABLE}(
                  limit: 1
                  where: {component_id: {_eq: $forkSource}, component_name: {_eq: $componentName}}
                ) {
                  block_height
                  block_timestamp_ms
                  code
                  component_author_id
                  component_id
                  fork_count
                  star_count
                  component_name
                }
              }`,
            {
              forkSource,
              componentName
            }
          );

          const previousInfoRawResponse = rawGraphqlResponseForkSource[METADATA_TABLE] ?? [];

          if (previousInfoRawResponse && previousInfoRawResponse.length && previousInfoRawResponse[0]) {
            const { block_height, block_timestamp_ms, component_author_id, code, component_name, fork_count, star_count } = previousInfoRawResponse[0];
            if (
              block_height &&
              block_timestamp_ms &&
              component_author_id &&
              code &&
              component_name
            ) {

              const sourceForkCount = fork_count + 1;

              const source_info = {
                block_height,
                block_timestamp_ms,
                code,
                component_author_id,
                component_id: forkSource,
                fork_count: sourceForkCount,
                star_count,
                component_name,
              }

              await context.db.Metadata.upsert([source_info], ["component_id"], ["fork_count"]);

              console.log(
                `Successfully updated source metadata record for: component_id=${forkSource}`
              );

            }
          }
        }

        const target_version = {
          block_height: blockHeight,
          block_timestamp_ms: blockTimestampMs,
          code,
          component_author_id: componentAuthorId,
          component_name: componentName,
          lines_added: linesAdded,
          lines_removed: linesRemoved,
          receipt_id: receiptId,
        };

        const target_info = {
          component_id: `${componentAuthorId}/widget/${componentName}`,
          block_height: blockHeight,
          block_timestamp_ms: blockTimestampMs,
          code,
          component_author_id: componentAuthorId,
          component_name: componentName,
          star_count: 0,
          fork_count: 0,
          name: metadata?.name,
          image_ipfs_cid: metadata?.image?.ipfs_cid,
          description: metadata?.description,
          fork_of_source: forkSource,
          fork_of_block_height: forkBlockHeight,
          tags: metadata?.tags ? Object.keys(metadata.tags).join(",") : null,
          website: metadata?.website,
        };

        await Promise.all([

          context.db.Versions.upsert(
            [target_version],
            ["receipt_id", "component_name", "component_author_id"],
            [
              "block_height",
              "block_timestamp_ms",
              "code",
              "lines_added",
              "lines_removed",
            ]
          ),

          context.db.Metadata.upsert(
            [target_info],
            ["component_id"],
            [
              "block_height",
              "block_timestamp_ms",
              "code",
              "star_count",
              "fork_count",
              "name",
              "image_ipfs_cid",
              "description",
              "fork_of_source",
              "fork_of_block_height",
              "tags",
              "website",
            ]
          ),
        ]);

        console.log(
          `Successfully inserted component version record for: componentAuthorId=${componentAuthorId}, componentName=${componentName}`
        );
        console.log(
          `Successfully inserted component metadata record for: componentAuthorId=${componentAuthorId}, componentName=${componentName}`
        );
      }
    }
  }

  //Star
  if (componentStarTransactions.length > 0) {
    const STAR_TRANSACTION_TYPE = 'star';
    const UNSTAR_TRANSACTION_TYPE = 'unstar';

    for (const transaction of componentStarTransactions) {
      const componentAuthorId = Object.keys(transaction.args.data)[0];
      const rawComponentData = transaction.args.data[componentAuthorId]["index"] || {};
      const rawStarData = rawComponentData?.star || {};
      if (!rawStarData || !Object.keys(rawStarData).length) return;

      const star_type = typeof rawStarData === 'string' ? JSON.parse(rawStarData) : rawStarData;
      if (!star_type) return;

      const transaction_value = star_type?.value?.type;
      const component_id = star_type?.key?.path;

      if (component_id && (transaction_value === STAR_TRANSACTION_TYPE || transaction_value === UNSTAR_TRANSACTION_TYPE)) {

        const rawGraphqlResponseStarData = await context.graphql(
          `query PreviousMetadataQuery($component_id: String) {
                    ${METADATA_TABLE}(
                      limit: 1
                      where: {component_id: {_eq: $component_id}}
                    ) {
                      block_height
                      block_timestamp_ms
                      code
                      component_author_id
                      component_id
                      fork_count
                      star_count
                      component_name
                    }
                  }`,
          {
            component_id,
          }
        );

        const previousInfoRawResponse = rawGraphqlResponseStarData[METADATA_TABLE] ?? [];

        if (previousInfoRawResponse && previousInfoRawResponse.length && previousInfoRawResponse[0]) {
          const { block_height, block_timestamp_ms, code, component_author_id, component_id, fork_count, star_count, component_name, } = previousInfoRawResponse[0];
          if (
            block_height &&
            block_timestamp_ms &&
            component_author_id &&
            code &&
            component_name
          ) {

            let sourceStarCount = transaction_value === STAR_TRANSACTION_TYPE ? star_count + 1 : star_count - 1;
            if (sourceStarCount < 0) sourceStarCount = 0;

            const source_info = {
              block_height,
              block_timestamp_ms,
              code,
              component_author_id,
              component_id,
              fork_count,
              star_count: sourceStarCount,
              component_name,
            }

            await context.db.Metadata.upsert([source_info], ["component_id"], ["star_count"]);

            console.log(
              `Successfully updated source star count metadata record for: component_id=${component_id} on type=${transaction_value}`
            );

          }
        }
      } else {
        console.log('one or more pieces of essential metadata missing to increment/decrement star count: star_type is', star_type, ' component_id: ', component_id);
      }
    }
  }
}

'''
'''--- indexers/components/components.sql ---
CREATE TABLE
  "versions" (
    "id" SERIAL PRIMARY KEY,
    "block_height" BIGINT NOT NULL,
    "block_timestamp_ms" BIGINT NOT NULL,
    "code" VARCHAR NOT NULL,
    "component_author_id" VARCHAR NOT NULL,
    "component_name" VARCHAR NOT NULL,
    "lines_added" INT NOT NULL,
    "lines_removed" INT NOT NULL,
    "receipt_id" VARCHAR NOT NULL
  );

CREATE TABLE 
  "metadata" (
    "component_id" VARCHAR PRIMARY KEY,
    "block_height" BIGINT NOT NULL,
    "block_timestamp_ms" BIGINT NOT NULL,
    "code" VARCHAR NOT NULL,
    "component_author_id" VARCHAR NOT NULL,
    "component_name" VARCHAR NOT NULL,
    "star_count" INT NOT NULL,
    "fork_count" INT NOT NULL,
    "name" VARCHAR, 
    "image_ipfs_cid" VARCHAR,
    "description" VARCHAR,
    "fork_of_source" VARCHAR,
    "fork_of_block_height" BIGINT,
    "tags" VARCHAR,
    "website" VARCHAR
  );

CREATE UNIQUE INDEX idx_versions_unique_receipt_version ON versions (receipt_id, component_author_id, component_name);

CREATE INDEX
  idx_versions_component_author_id_component_name ON versions (component_author_id, component_name);

CREATE INDEX
  idx_versions_block_height ON versions (block_height);

CREATE INDEX
  idx_info_fork_of ON metadata (fork_of_source);

CREATE INDEX
  idx_info_component_author_id ON metadata (component_author_id);

'''
'''--- indexers/entities/entities.js ---
/**
 * Note: We only support javascript at the moment. We will support Rust, Typescript in a further release.
 */

/**
 * getBlock(block, context) applies your custom logic to a Block on Near and commits the data to a database.
 * context is a global variable that contains helper methods.
 * context.db is a subfield which contains helper methods to interact with your database.
 *
 * Learn more about indexers here:  https://docs.near.org/concepts/advanced/indexers
 *
 * @param {block} Block - A Near Protocol Block
 */
export default async function getBlock(block) {
    function base64decode(encodedValue) {
        try {
            const buff = Buffer.from(encodedValue, "base64");
            const str = buff.toString("utf-8").replace(/\\xa0/g, " ");
            return JSON.parse(str);
        } catch (error) {
            console.error(
                'Error parsing JSON - skipping data for "functionCallOperation.args"',
                error
            );
        }
    }
    function arrayInPostgresForm(a) {
        if (!a) return a;
        try {
            const stringArray = JSON.stringify(a);
            return stringArray.replaceAll("[", "{").replaceAll("]", "}");
        } catch (error) {
            console.error("Error parsing JSON - skipping array field", error);
            return "";
        }
    }

    const getFunctionCallsFunction = (block, contract, method) => {
        return block
            .actions()
            .filter((action) => action.receiverId === contract)
            .flatMap((action) =>
                action.operations
                    .map((operation) => operation["FunctionCall"])
                    .filter((operation) => operation?.methodName === method)
                    .map((functionCallOperation) => ({
                        ...functionCallOperation,
                        args: base64decode(functionCallOperation.args),
                        receiptId: action.receiptId,
                    }))
                    .filter((a) =>
                        block
                            .receipts()
                            .find((r) => r.receiptId === a.receiptId)
                            .status.hasOwnProperty("SuccessValue")
                    )
            );
    };

    const getSocialOperations = (block, operation) => {
        const contract = "social.near";
        const method = "set";
        return getFunctionCallsFunction(block, contract, method)
            .filter((functionCall) => {
                if (
                    !functionCall ||
                    !functionCall.args ||
                    !functionCall.args.data ||
                    !Object.keys(functionCall.args.data) ||
                    !Object.keys(functionCall.args.data)[0]
                ) {
                    console.error(
                        "Set operation did not have arg data in expected format"
                    );
                    return;
                }
                const accountId = Object.keys(functionCall.args.data)[0];
                if (!functionCall.args.data[accountId]) {
                    console.error("Set operation did not have arg data for accountId");
                    return;
                }
                const accountData = functionCall.args.data[accountId];
                if (!accountData) {
                    console.error(
                        "Set operation did not have arg data for accountId in expected format"
                    );
                    return;
                }
                return accountData[operation];
            })
            .map((functionCall) => {
                const accountId = Object.keys(functionCall.args.data)[0];
                if (!functionCall.args.data[accountId]) {
                    console.error(
                        "Set operation did not have arg data for accountId, in map op"
                    );
                    return;
                }
                return {
                    accountId,
                    data: functionCall.args.data[accountId][operation],
                };
            });
    };

    const entityWrites = getSocialOperations(block, "entities");
    await entityWrites.map(async ({ accountId, data }) => {
        try {
            if (typeof data === "string") {
                data = JSON.parse(data);
            }
            const dataArray = Array.isArray(data) ? data : [data];
            dataArray.map(async (data) => {
                if (!data) {
                    console.error("missing entity data");
                    return;
                }
                const namespaces = Object.keys(data);
                namespaces.map(async (namespace) => {
                    if (!namespace) {
                        console.error("missing entity namespace");
                        return;
                    }
                    const namespaceData = data[namespace];
                    if (!namespaceData) {
                        console.error("data not found for namespace " + namespace);
                        return;
                    }
                    const entityTypes = Object.keys(namespaceData);
                    entityTypes.map(async (entityType) => {
                        if (!entityType) {
                            console.error("missing entity entityType");
                            return;
                        }
                        const entityTypeData = namespaceData[entityType];
                        if (!entityTypeData) {
                            console.error(
                                "namespaceData not found for entityType " + entityType
                            );
                            return;
                        }
                        const entities = Object.keys(entityTypeData);
                        entities.map(async (name) => {
                            if (!name) {
                                console.error("missing entity name");
                                return;
                            }
                            const entityProps = entityTypeData[name];
                            if (!entityProps) {
                                console.error("entityProps not found for entity named " + name);
                                return;
                            }

                            if (entityProps["operation"]) {
                                switch (entityProps["operation"]) {
                                    case "delete":
                                        await context.db.Entities.delete({
                                            namespace: namespace,
                                            entity_type: entityType,
                                            account_id: accountId,
                                            name: name,
                                        });
                                        console.log(
                                            `${entityType} ${namespace}/${name} from ${accountId} has been deleted from the database`
                                        );
                                        return;
                                    default:
                                        console.error(
                                            `Operation ${entityProps["operation"]} not supported`
                                        );
                                        return;
                                }
                            }
                            const {
                                displayName,
                                logoUrl,
                                description,
                                tags,
                                ...entityAttributes
                            } = entityProps;
                            const entity = {
                                namespace,
                                entity_type: entityType,
                                account_id: accountId,
                                name: name,
                                display_name: displayName,
                                logo_url: logoUrl,
                                description,
                                tags: arrayInPostgresForm(tags),
                                attributes: entityAttributes,
                            };
                            await context.db.Entities.upsert(
                                entity,
                                ["entity_type", "account_id", "name"],
                                [
                                    "display_name",
                                    "logo_url",
                                    "description",
                                    "tags",
                                    "attributes",
                                ]
                            );

                            console.log(
                                `${entityType} ${namespace}/${name} from ${accountId} has been added to the database`
                            );
                        });
                    });
                });
            });
        } catch (e) {
            console.error(
                `Failed to store entity from ${accountId} to the database`,
                e
            );
        }
    });

    const indexOps = getSocialOperations(block, "index");
    await indexOps
        .filter(({ accountId, data }) => {
            const type = "star";
            return data[type];
        })
        .map(async ({ accountId, data }) => {
            try {
                const type = "star";
                const starData = data[type];
                if (!starData) {
                    console.error("No star data found");
                    return;
                }
                const star = JSON.parse(starData);
                // "{\"key\":{\"type\":\"social\",\"path\":\"flatirons.near/examples/favoriteCar/delorean\"},\"value\":{\"type\":\"star\"}}"
                const starArray = typeof star === "object" ? [star] : star;
                starArray.map(async ({ key, value }) => {
                    if (!key || !value || !key.path || !value.type) {
                        console.error("Required fields not found for star", key, value);
                        return;
                    }
                    const { path } = key;
                    const { type } = value;
                    const [
                        targetAccountId,
                        entitiesConstant,
                        namespace,
                        entityType,
                        name,
                    ] = path.split("/");
                    const incDecQuery = `
                mutation ChangeStars {
                  update_dataplatform_near_entities_entities(
                    where: {namespace: {_eq: "${namespace}"}, entity_type: {_eq: "${entityType}"}, 
                    account_id: {_eq: "${targetAccountId}"}, name: {_eq: "${name}"}},
                    _inc: {stars: ${type === "star" ? 1 : -1}}
                  ) {
                    affected_rows
                    returning { account_id namespace entity_type name stars }
                  }
                }
                `;
                    await context.graphql(incDecQuery, {});
                });
            } catch (e) {
                console.error(
                    `Failed to process star of entity from ${accountId} to the database`,
                    e
                );
            }
        });
}

'''
'''--- indexers/entities/entities.sql ---
-- commented lines are features that are not supported by context.db but are in the table
-- that was created in the db
CREATE TABLE "entities"
(
    "id" SERIAL NOT NULL,
    "namespace"   TEXT NOT NULL,
    "entity_type"  TEXT NOT NULL,
    "account_id"   TEXT NOT NULL,
    "name"         TEXT NOT NULL,
    "display_name" TEXT,
    "description"  TEXT,
    "logo_url"     TEXT,
    "attributes"   JSONB,
    "stars"        integer, -- default 0
    "tags" text[],
    -- "created_at"   timestamp with time zone default now(),
    -- "updated_at"   timestamp with time zone default now(),
    PRIMARY KEY ("entity_type", "account_id", "name")
);

CREATE INDEX
    idx_tags_array ON entities USING GIN (tags);

-- CREATE TRIGGER set_dataplatform_near_agents_entities_updated_at
--     BEFORE UPDATE
--     ON dataplatform_near_agents.entities
--     FOR EACH ROW
-- EXECUTE FUNCTION dataplatform_near_agents.set_current_timestamp_updated_at();

-- CREATE VIEW dataplatform_near_entities."tags" as
-- select namespace, entity_type, unnest(tags) as tag, count(*)
-- from dataplatform_near_entities.entities
-- group by namespace, entity_type, tag
'''
'''--- indexers/entities/entities_tests.js ---
import getBlock from './entities.js';
import testBlock from './test_block.js';

describe('entities.js indexer', () => {

    it('accepts data with an empty namespace', () => {
        getBlock(testBlock);
        // successful if it does not throw an error
    });
});
'''
'''--- indexers/entities/test_block.js ---
const testBlock = {
    "streamerMessage": {
        "block": {
            "author": "zavodil.poolv1.near",
            "chunks": [
            ],
            "header": {
                "approvals": [],
                "blockBodyHash": "FxzZV2aduyXodUYWT4cAhAnu29MceJ8RVEPvSjNuF5oL",
                "blockMerkleRoot": "9HvD4bkfUmBWb8JBtRBMNbVLcNr9Zxujr1dJB1SzTbQr",
                "blockOrdinal": 106559321,
                "challengesResult": [],
                "challengesRoot": "11111111111111111111111111111111",
                "chunkHeadersRoot": "35N7w6zirD4Y8Puixu4CFWdjPWXf7xcBVSEGcYxeN6aE",
                "chunkMask": [
                    true,
                    true,
                    true,
                    true,
                    true,
                    true
                ],
                "chunkReceiptsRoot": "fFBpyd9TKCdexUycuQP1rEtRnRhLaFLi39Gms3Cho6C",
                "chunkTxRoot": "DXC84MVesiYGV9k3sYL6SPVpN1AjAxThMnFYTwabt783",
                "chunksIncluded": 6,
                "epochId": "4eGxYzrNFZ87hLFz2hqW1n4eM1oGZQmLSb42BqnEGAeb",
                "epochSyncDataHash": null,
                "gasPrice": "100000000",
                "hash": "4ioSs6NoSzk4Dp4Y1j8enh2NWoMncdHsErbfJNxPuBpX",
                "height": 116697960,
                "lastDsFinalBlock": "CtgUmuWx6zp3Z5VNbq5kbD7d1ZJUiqPdzWjjwkGqb4zd",
                "lastFinalBlock": "4gcBg99yNpNig9ZceG5arRqTtzQts1bxgyimagMsvSHm",
                "latestProtocolVersion": 66,
                "nextBpHash": "GpzbdvnwoLp7bZGJGpJXwwETDih5FGUtiti4gynA9tPs",
                "nextEpochId": "G5LYA2Wtqkvb4QJkQgkM4zAxPeNkDGYBrWhGmk8yzLf7",
                "outcomeRoot": "FBoc9tSMQp9A7LFmXyfB5hQGyBM8MEFkDgdQjPpTrzTy",
                "prevHash": "CtgUmuWx6zp3Z5VNbq5kbD7d1ZJUiqPdzWjjwkGqb4zd",
                "prevHeight": 116697959,
                "prevStateRoot": "BWUQdZPJUqUhRfkipQ5YTQ2w5UvNStSoFRtHFHF6A1pg",
                "randomValue": "9wNVWDE2z6VhZnvmfpKwvGVYwfGp5aiiQUfdQVju6D7H",
                "rentPaid": "0",
                "signature": "ed25519:47mTfuvLqKuVB8NPtqjrqnux1QVEWQDPfZny4kyANFXSh2qcAvdYx3yK88MwfqN5iEs2dq6oTShNv67crzG24QPo",
                "timestamp": 1712941136649285600,
                "timestampNanosec": "1712941136649285718",
                "totalSupply": "1185713651099339367629653868087495",
                "validatorProposals": [],
                "validatorReward": "0"
            }
        },
        "shards": [
            {
                "chunk": {
                    "author": "staked.poolv1.near",
                    "header": {
                        "balanceBurnt": "4723847890413100000000",
                        "chunkHash": "Gyc1uhz7m2hMhnNTmSifAJuf2miGJajK1zmK6R61vLDA",
                        "encodedLength": 12220,
                        "encodedMerkleRoot": "8QXEsgQmDoZFJVwzqrKzksN5vSixwJE7yaQWQBAcNXv8",
                        "gasLimit": 1000000000000000,
                        "gasUsed": 97925878504100,
                        "heightCreated": 116697960,
                        "heightIncluded": 116697960,
                        "outcomeRoot": "82xhUqKvQSuBVXno7A4CPA16HHX5nWFp7NfMZ9UidqMT",
                        "outgoingReceiptsRoot": "5dq5ZJoedC5VRnN6i2uSJq6fSRtncJnePmTgcRyWMzsp",
                        "prevBlockHash": "CtgUmuWx6zp3Z5VNbq5kbD7d1ZJUiqPdzWjjwkGqb4zd",
                        "prevStateRoot": "29pVCfowBdk1PTuXLjXurunbWpSUbUJTfikP7hM5t7mo",
                        "rentPaid": "0",
                        "shardId": 2,
                        "signature": "ed25519:4cNAWxfeLwxNwLxcqjcPwVm8qpuJf9Syy7JTyp9cqJhygWk4WYh5yuEiJ8gaEvveryLCmpviAMveg9iQTVuVboqU",
                        "txRoot": "7BxkHJj6Ggm7uJqhX7HgFDt7zUdbyJtnkLRmqHRPEux5",
                        "validatorProposals": [],
                        "validatorReward": "0"
                    },
                    "receipts": [
                        {
                            "predecessorId": "flatirons.near",
                            "receipt": {
                                "Action": {
                                    "actions": [
                                        {
                                            "FunctionCall": {
                                                "args": "eyJkYXRhIjp7ImZsYXRpcm9ucy5uZWFyIjp7ImFnZW50Ijp7ImNhcmJvbi1vZmZzZXQtY2FsY3VsYXRvciI6eyJjb21wb25lbnQiOm51bGwsImRpc3BsYXlOYW1lIjpudWxsLCJsb2dvVXJsIjpudWxsLCJwcm9tcHQiOm51bGx9LCJjdXN0b20tY2hhdC1jb21wb25lbnQiOnsiY29tcG9uZW50IjpudWxsLCJkaXNwbGF5TmFtZSI6bnVsbCwibG9nb1VybCI6bnVsbCwicHJvbXB0IjpudWxsfSwiaGFja2F0aG9uLWlkZWEtZ2VuZXJhdG9yIjp7ImRpc3BsYXlOYW1lIjpudWxsLCJwcm9tcHQiOm51bGx9LCJpbnZlc3RtZW50LWFkdmlzb3IiOnsiZGlzcGxheU5hbWUiOm51bGwsImxvZ29VcmwiOm51bGwsInByb21wdCI6bnVsbH0sInJlcHV0YXRpb24iOnsiZGlzcGxheU5hbWUiOm51bGwsInByb21wdCI6bnVsbH0sInRyYXZlbC1hZ2VudCI6eyJkaXNwbGF5TmFtZSI6bnVsbCwibG9nb1VybCI6bnVsbCwicHJvbXB0IjpudWxsfX0sImFnaWd1aWxkIjp7ImFsaWdubWVudERhdGFzZXQiOnsiZ3V0ZW5iZXJnLWRwby12MC4xIjp7ImRpc3BsYXlOYW1lIjpudWxsLCJsYW5ndWFnZXMiOm51bGwsImxvZ29VcmwiOm51bGx9fSwibW9kZWwiOnsiZ3B0LTMuNS10dXJibyI6eyJkaXNwbGF5TmFtZSI6bnVsbCwibG9nb1VybCI6bnVsbH19fSwiZW50aXRpZXMiOnsiIjpudWxsLCJhZ2lndWlsZCI6eyJhbGlnbm1lbnREYXRhc2V0Ijp7Imd1dGVuYmVyZy1kcG8tdjAuMSI6eyJkaXNwbGF5TmFtZSI6bnVsbCwibGFuZ3VhZ2VzIjpudWxsLCJsb2dvVXJsIjpudWxsfX0sIm1vZGVsIjp7ImdwdC0zLjUtdHVyYm8iOnsiZGlzcGxheU5hbWUiOm51bGwsImxvZ29VcmwiOm51bGx9fX0sImV4YW1wbGVzIjp7ImZhdm9yaXRlQ2FyIjp7ImMtbWF4LWVuZXJnaSI6eyJjb2xvciI6bnVsbCwiZGlzcGxheU5hbWUiOm51bGwsImxvZ29VcmwiOm51bGwsIm1ha2UiOm51bGwsIm1vZGVsIjpudWxsfSwiZGVsb3JlYW4iOnsiY29sb3IiOm51bGwsImRpc3BsYXlOYW1lIjpudWxsLCJsb2dvVXJsIjpudWxsLCJtYWtlIjpudWxsLCJtb2RlbCI6bnVsbH19LCJmYXZvcml0ZVBsYWNlIjp7InBhcmlzIjp7ImRpc3BsYXlOYW1lIjpudWxsLCJsb2dvVXJsIjpudWxsfSwicm9tZSI6eyJkaXNwbGF5TmFtZSI6bnVsbCwibG9nb1VybCI6bnVsbH19fX0sInVuZGVmaW5lZCI6eyJRdWVyeUFwaS5FZGl0b3IiOnsiIjpudWxsLCJtZXRhZGF0YSI6eyJuYW1lIjpudWxsfX0sIlF1ZXJ5QXBpLmRldi1BcHAiOnsiIjpudWxsfX0sIndpZGdldCI6eyJDdXN0b21GaWx0ZXJlZEhvbWVQYWdlIjp7IiI6bnVsbCwiYnJhbmNoIjp7ImRyYWZ0Ijp7IiI6bnVsbH19fSwiRmlsdGVyZWRJbmRleEZlZWQiOnsiIjpudWxsfSwiRmlsdGVyZWRGZWVkIjp7IiI6bnVsbH0sIkZlZWQuUG9zdCI6eyIiOm51bGx9LCJGaWx0ZXJlZE1hbnVhbEluZGV4RmVlZCI6eyIiOm51bGx9LCJNYWluUGFnZS5Db21tZW50LkZlZWQiOnsiIjpudWxsfSwiTWFpblBhZ2UuQ29tbWVudC5QYWdlIjp7IiI6bnVsbH0sIk1haW5QYWdlLkNvbW1lbnQiOnsiIjpudWxsfSwiTWFpblBhZ2UuQ29udGVudCI6eyIiOm51bGx9LCJNYWluUGFnZS5GZWVkIjp7IiI6bnVsbH0sIk1haW5QYWdlLlBvc3QuSGVhZGVyIjp7IiI6bnVsbH0sIk1haW5QYWdlLlBvc3QiOnsiIjpudWxsfSwiUXVlcnlBcGkuQXBwIjp7IiI6bnVsbH0sIlF1ZXJ5QXBpLkRhc2hib2FyZCI6eyIiOm51bGx9LCJRdWVyeUFwaS5FZGl0b3IiOnsiIjpudWxsfX19fX0=",
                                                "deposit": "0",
                                                "gas": 100000000000000,
                                                "methodName": "set"
                                            }
                                        }
                                    ],
                                    "gasPrice": "186029458",
                                    "inputDataIds": [],
                                    "outputDataReceivers": [],
                                    "signerId": "flatirons.near",
                                    "signerPublicKey": "ed25519:F5DeKFoyF1CQ6wG6jYpXxwReoksgi9a677JkniDBGBTB"
                                }
                            },
                            "receiptId": "2DmjYNpXXsVVcKvLmoDVW6CNiDfTgfWLpSthpnwT3xQd",
                            "receiverId": "social.near"
                        }
                    ],
                    "transactions": []
                },
                "receiptExecutionOutcomes": [],
                "shardId": 2,
                "stateChanges": []
            },
            {
                "chunk": {
                    "author": "twinstake.poolv1.near",
                    "header": {
                        "balanceBurnt": "3004262120861300000000",
                        "chunkHash": "EBL4VTZxQYf9NnUzWSoN5Ue6iciFrPjGySxyEfVjV7ed",
                        "encodedLength": 41366,
                        "encodedMerkleRoot": "5WyNcRLABENdaUub8npER1nWU4tVXMWpiNEeWetEDxZF",
                        "gasLimit": 1000000000000000,
                        "gasUsed": 48172407815535,
                        "heightCreated": 116697960,
                        "heightIncluded": 116697960,
                        "outcomeRoot": "4WuvRQPH1iUQ4PDNheRnPUGrL5LxfJjYfGTn7czfxFiM",
                        "outgoingReceiptsRoot": "Aj8DB6maV4NE8YJaGLCZLbRoxXhvD3AN7gGPSrAKKdHh",
                        "prevBlockHash": "CtgUmuWx6zp3Z5VNbq5kbD7d1ZJUiqPdzWjjwkGqb4zd",
                        "prevStateRoot": "nLs5L4jx1NNSLPTZ8LrAJpSubsc7HZxPRVnggwFL3vk",
                        "rentPaid": "0",
                        "shardId": 4,
                        "signature": "ed25519:39eVr4ANRhVg3PETkeT7Dj2RfeJ5cFXG3QnriBLfvsWYSU4uHe2nu7FH3HCzbMSxwUTNtRCEpuej1ESqg3qtkXJM",
                        "txRoot": "ACizPUAMKYLHwURT8KWXuNYGGSSjhByj3TPdPFBgYutU",
                        "validatorProposals": [],
                        "validatorReward": "0"
                    },
                    "receipts": [],
                    "transactions": []
                },
                "receiptExecutionOutcomes": [
                    {
                        "executionOutcome": {
                            "blockHash": "4ioSs6NoSzk4Dp4Y1j8enh2NWoMncdHsErbfJNxPuBpX",
                            "id": "2DmjYNpXXsVVcKvLmoDVW6CNiDfTgfWLpSthpnwT3xQd",
                            "outcome": {
                                "executorId": "social.near",
                                "gasBurnt": 54129184627910,
                                "logs": [],
                                "metadata": {
                                    "gasProfile": [
                                        {
                                            "cost": "BASE",
                                            "costCategory": "WASM_HOST_COST",
                                            "gasUsed": "384178529061"
                                        },
                                        {
                                            "cost": "CONTRACT_LOADING_BASE",
                                            "costCategory": "WASM_HOST_COST",
                                            "gasUsed": "35445963"
                                        },
                                        {
                                            "cost": "CONTRACT_LOADING_BYTES",
                                            "costCategory": "WASM_HOST_COST",
                                            "gasUsed": "348770473100"
                                        },
                                        {
                                            "cost": "READ_CACHED_TRIE_NODE",
                                            "costCategory": "WASM_HOST_COST",
                                            "gasUsed": "6308760000000"
                                        },
                                        {
                                            "cost": "READ_MEMORY_BASE",
                                            "costCategory": "WASM_HOST_COST",
                                            "gasUsed": "1453693802400"
                                        },
                                        {
                                            "cost": "READ_MEMORY_BYTE",
                                            "costCategory": "WASM_HOST_COST",
                                            "gasUsed": "35405615562"
                                        },
                                        {
                                            "cost": "READ_REGISTER_BASE",
                                            "costCategory": "WASM_HOST_COST",
                                            "gasUsed": "1120138507770"
                                        },
                                        {
                                            "cost": "READ_REGISTER_BYTE",
                                            "costCategory": "WASM_HOST_COST",
                                            "gasUsed": "10932102792"
                                        },
                                        {
                                            "cost": "STORAGE_READ_BASE",
                                            "costCategory": "WASM_HOST_COST",
                                            "gasUsed": "18710472789000"
                                        },
                                        {
                                            "cost": "STORAGE_READ_KEY_BYTE",
                                            "costCategory": "WASM_HOST_COST",
                                            "gasUsed": "149315019192"
                                        },
                                        {
                                            "cost": "STORAGE_READ_VALUE_BYTE",
                                            "costCategory": "WASM_HOST_COST",
                                            "gasUsed": "311057284185"
                                        },
                                        {
                                            "cost": "STORAGE_WRITE_BASE",
                                            "costCategory": "WASM_HOST_COST",
                                            "gasUsed": "7190034432000"
                                        },
                                        {
                                            "cost": "STORAGE_WRITE_EVICTED_BYTE",
                                            "costCategory": "WASM_HOST_COST",
                                            "gasUsed": "1728585580047"
                                        },
                                        {
                                            "cost": "STORAGE_WRITE_KEY_BYTE",
                                            "costCategory": "WASM_HOST_COST",
                                            "gasUsed": "78799845306"
                                        },
                                        {
                                            "cost": "STORAGE_WRITE_VALUE_BYTE",
                                            "costCategory": "WASM_HOST_COST",
                                            "gasUsed": "103725994416"
                                        },
                                        {
                                            "cost": "TOUCHING_TRIE_NODE",
                                            "costCategory": "WASM_HOST_COST",
                                            "gasUsed": "9274726613376"
                                        },
                                        {
                                            "cost": "WASM_INSTRUCTION",
                                            "costCategory": "WASM_HOST_COST",
                                            "gasUsed": "2776040450700"
                                        },
                                        {
                                            "cost": "WRITE_MEMORY_BASE",
                                            "costCategory": "WASM_HOST_COST",
                                            "gasUsed": "1250492508006"
                                        },
                                        {
                                            "cost": "WRITE_MEMORY_BYTE",
                                            "costCategory": "WASM_HOST_COST",
                                            "gasUsed": "302153475504"
                                        },
                                        {
                                            "cost": "WRITE_REGISTER_BASE",
                                            "costCategory": "WASM_HOST_COST",
                                            "gasUsed": "1278023028756"
                                        },
                                        {
                                            "cost": "WRITE_REGISTER_BYTE",
                                            "costCategory": "WASM_HOST_COST",
                                            "gasUsed": "421935588360"
                                        }
                                    ],
                                    "version": 3
                                },
                                "receiptIds": [
                                    "2VhVQgqYGFbXSZN6otGrUAh1jXdsqogPMtmzfQqVBG9n"
                                ],
                                "status": {
                                    "SuccessValue": "eyJibG9ja19oZWlnaHQiOiIxMTY2OTc5NjAifQ=="
                                },
                                "tokensBurnt": "5412918462791000000000"
                            },
                            "proof": [
                                {
                                    "direction": "Left",
                                    "hash": "FiySPEYpCrhpBSG3mzFwqt8u98WzE8VSiyjCbfd25VdG"
                                },
                                {
                                    "direction": "Right",
                                    "hash": "r5ymfwcYcy1s3w6rnQjbRR6KBssst32xwqdk8UN5XsZ"
                                },
                                {
                                    "direction": "Left",
                                    "hash": "Ab6F8P54g3Jkrk4wMTGcjfLv14gWtutmW8SbBj3y2SVv"
                                },
                                {
                                    "direction": "Right",
                                    "hash": "FCe4eSaSh5xH8r9CEJsnaVNQcmKNi1XGNQ5TMdGzEn4m"
                                },
                                {
                                    "direction": "Left",
                                    "hash": "6ymF2HukCmXTEUqYjfVsQRKwqis487py2KzfUw8LLHA4"
                                },
                                {
                                    "direction": "Right",
                                    "hash": "M6y7bCrGCuRDGRadfrNWc9iPaNYEtHXezZicGQUGofj"
                                },
                                {
                                    "direction": "Right",
                                    "hash": "14oEgzxYke874azyD6SU6zAWStPrjGbc9e9BaRJwujwj"
                                }
                            ]
                        },
                        "receipt": {
                            "predecessorId": "flatirons.near",
                            "receipt": {
                                "Action": {
                                    "actions": [
                                        {
                                            "FunctionCall": {
                                                "args": "eyJkYXRhIjp7ImZsYXRpcm9ucy5uZWFyIjp7ImFnZW50Ijp7ImNhcmJvbi1vZmZzZXQtY2FsY3VsYXRvciI6eyJjb21wb25lbnQiOm51bGwsImRpc3BsYXlOYW1lIjpudWxsLCJsb2dvVXJsIjpudWxsLCJwcm9tcHQiOm51bGx9LCJjdXN0b20tY2hhdC1jb21wb25lbnQiOnsiY29tcG9uZW50IjpudWxsLCJkaXNwbGF5TmFtZSI6bnVsbCwibG9nb1VybCI6bnVsbCwicHJvbXB0IjpudWxsfSwiaGFja2F0aG9uLWlkZWEtZ2VuZXJhdG9yIjp7ImRpc3BsYXlOYW1lIjpudWxsLCJwcm9tcHQiOm51bGx9LCJpbnZlc3RtZW50LWFkdmlzb3IiOnsiZGlzcGxheU5hbWUiOm51bGwsImxvZ29VcmwiOm51bGwsInByb21wdCI6bnVsbH0sInJlcHV0YXRpb24iOnsiZGlzcGxheU5hbWUiOm51bGwsInByb21wdCI6bnVsbH0sInRyYXZlbC1hZ2VudCI6eyJkaXNwbGF5TmFtZSI6bnVsbCwibG9nb1VybCI6bnVsbCwicHJvbXB0IjpudWxsfX0sImFnaWd1aWxkIjp7ImFsaWdubWVudERhdGFzZXQiOnsiZ3V0ZW5iZXJnLWRwby12MC4xIjp7ImRpc3BsYXlOYW1lIjpudWxsLCJsYW5ndWFnZXMiOm51bGwsImxvZ29VcmwiOm51bGx9fSwibW9kZWwiOnsiZ3B0LTMuNS10dXJibyI6eyJkaXNwbGF5TmFtZSI6bnVsbCwibG9nb1VybCI6bnVsbH19fSwiZW50aXRpZXMiOnsiIjpudWxsLCJhZ2lndWlsZCI6eyJhbGlnbm1lbnREYXRhc2V0Ijp7Imd1dGVuYmVyZy1kcG8tdjAuMSI6eyJkaXNwbGF5TmFtZSI6bnVsbCwibGFuZ3VhZ2VzIjpudWxsLCJsb2dvVXJsIjpudWxsfX0sIm1vZGVsIjp7ImdwdC0zLjUtdHVyYm8iOnsiZGlzcGxheU5hbWUiOm51bGwsImxvZ29VcmwiOm51bGx9fX0sImV4YW1wbGVzIjp7ImZhdm9yaXRlQ2FyIjp7ImMtbWF4LWVuZXJnaSI6eyJjb2xvciI6bnVsbCwiZGlzcGxheU5hbWUiOm51bGwsImxvZ29VcmwiOm51bGwsIm1ha2UiOm51bGwsIm1vZGVsIjpudWxsfSwiZGVsb3JlYW4iOnsiY29sb3IiOm51bGwsImRpc3BsYXlOYW1lIjpudWxsLCJsb2dvVXJsIjpudWxsLCJtYWtlIjpudWxsLCJtb2RlbCI6bnVsbH19LCJmYXZvcml0ZVBsYWNlIjp7InBhcmlzIjp7ImRpc3BsYXlOYW1lIjpudWxsLCJsb2dvVXJsIjpudWxsfSwicm9tZSI6eyJkaXNwbGF5TmFtZSI6bnVsbCwibG9nb1VybCI6bnVsbH19fX0sInVuZGVmaW5lZCI6eyJRdWVyeUFwaS5FZGl0b3IiOnsiIjpudWxsLCJtZXRhZGF0YSI6eyJuYW1lIjpudWxsfX0sIlF1ZXJ5QXBpLmRldi1BcHAiOnsiIjpudWxsfX0sIndpZGdldCI6eyJDdXN0b21GaWx0ZXJlZEhvbWVQYWdlIjp7IiI6bnVsbCwiYnJhbmNoIjp7ImRyYWZ0Ijp7IiI6bnVsbH19fSwiRmlsdGVyZWRJbmRleEZlZWQiOnsiIjpudWxsfSwiRmlsdGVyZWRGZWVkIjp7IiI6bnVsbH0sIkZlZWQuUG9zdCI6eyIiOm51bGx9LCJGaWx0ZXJlZE1hbnVhbEluZGV4RmVlZCI6eyIiOm51bGx9LCJNYWluUGFnZS5Db21tZW50LkZlZWQiOnsiIjpudWxsfSwiTWFpblBhZ2UuQ29tbWVudC5QYWdlIjp7IiI6bnVsbH0sIk1haW5QYWdlLkNvbW1lbnQiOnsiIjpudWxsfSwiTWFpblBhZ2UuQ29udGVudCI6eyIiOm51bGx9LCJNYWluUGFnZS5GZWVkIjp7IiI6bnVsbH0sIk1haW5QYWdlLlBvc3QuSGVhZGVyIjp7IiI6bnVsbH0sIk1haW5QYWdlLlBvc3QiOnsiIjpudWxsfSwiUXVlcnlBcGkuQXBwIjp7IiI6bnVsbH0sIlF1ZXJ5QXBpLkRhc2hib2FyZCI6eyIiOm51bGx9LCJRdWVyeUFwaS5FZGl0b3IiOnsiIjpudWxsfX19fX0=",
                                                "deposit": "0",
                                                "gas": 100000000000000,
                                                "methodName": "set"
                                            }
                                        }
                                    ],
                                    "gasPrice": "186029458",
                                    "inputDataIds": [],
                                    "outputDataReceivers": [],
                                    "signerId": "flatirons.near",
                                    "signerPublicKey": "ed25519:F5DeKFoyF1CQ6wG6jYpXxwReoksgi9a677JkniDBGBTB"
                                }
                            },
                            "receiptId": "2DmjYNpXXsVVcKvLmoDVW6CNiDfTgfWLpSthpnwT3xQd",
                            "receiverId": "social.near"
                        }
                    }
                ],
                "shardId": 4,
                "stateChanges": []
            }
        ]
    },
    "executedReceipts": [
        {
            "receiptKind": "Data",
            "receiptId": "2DmjYNpXXsVVcKvLmoDVW6CNiDfTgfWLpSthpnwT3xQd",
            "receiverId": "social.near",
            "predecessorId": "flatirons.near",
            "status": {
                "SuccessValue": "eyJibG9ja19oZWlnaHQiOiIxMTY2OTc5NjAifQ=="
            },
            "executionOutcomeId": "2DmjYNpXXsVVcKvLmoDVW6CNiDfTgfWLpSthpnwT3xQd",
            "logs": []
        }
    ],
    "postponedReceipts": [],
    "transactions": [],
    "_actions": {},
    "_events": {},
    "_stateChanges": []
};

export default testBlock;
'''
'''--- indexers/feed/README.md ---
# Feed indexer
This indexer holds the top level views used to display the feed.
It prevents a circular reference between the social_feed and moderation indexers.

The relationships.json file documents the manually created GraphQL relationships used by the feed, in hasura metadata format. 
At some point QueryApi indexers may support a similar format for declarative relationships.
'''
'''--- indexers/feed/feed.js ---
// This indexer holds views and does no indexing itself
'''
'''--- indexers/feed/feed.sql ---
CREATE VIEW moderated_posts as
SELECT * FROM dataplatform_near_social_feed.posts p
WHERE NOT EXISTS (
    SELECT * FROM dataplatform_near_moderation.moderation_decisions d
    WHERE p.account_id = d.moderated_account_id
      AND (d.moderated_path IS NULL OR (d.moderated_path = '/post/main' AND d.moderated_blockheight = p.block_height))
);

CREATE VIEW moderated_comments as
SELECT * FROM dataplatform_near_social_feed.comments p
WHERE NOT EXISTS (
    SELECT * FROM dataplatform_near_moderation.moderation_decisions d
    WHERE p.account_id = d.moderated_account_id
      AND (d.moderated_path IS NULL OR (d.moderated_path = '/post/comment' AND d.moderated_blockheight = p.block_height))
);
'''
'''--- indexers/feed/relationships.json ---
{
  "moderated_posts_with_reposts_feed": {
    "object_relationships": [
      {
        "name": "account",
        "using": {
          "manual_configuration": {
            "column_mapping": {
              "account_id": "account_id"
            },
            "insertion_order": null,
            "remote_table": {
              "name": "accounts",
              "schema": "dataplatform_near_accounts"
            }
          }
        }
      },
      {
        "name": "verifications",
        "using": {
          "manual_configuration": {
            "column_mapping": {
              "account_id": "account_id"
            },
            "insertion_order": null,
            "remote_table": {
              "name": "account",
              "schema": "dataplatform_near_verifications"
            }
          }
        }
      }
    ],
    "array_relationships": [
      {
        "name": "comments",
        "using": {
          "manual_configuration": {
            "column_mapping": {
              "id": "post_id"
            },
            "insertion_order": null,
            "remote_table": {
              "name": "moderated_comments",
              "schema": "dataplatform_near_feed"
            }
          }
        }
      },
      {
        "name": "post_likes",
        "using": {
          "manual_configuration": {
            "column_mapping": {
              "id": "post_id"
            },
            "insertion_order": null,
            "remote_table": {
              "name": "post_likes",
              "schema": "dataplatform_near_social_feed"
            }
          }
        }
      }
    ]
  },
  "moderated_posts": {
    "object_relationships": [
      {
        "name": "account",
        "using": {
          "manual_configuration": {
            "column_mapping": {
              "account_id": "account_id"
            },
            "insertion_order": null,
            "remote_table": {
              "name": "accounts",
              "schema": "dataplatform_near_accounts"
            }
          }
        }
      },
      {
        "name": "verifications",
        "using": {
          "manual_configuration": {
            "column_mapping": {
              "account_id": "account_id"
            },
            "insertion_order": null,
            "remote_table": {
              "name": "account",
              "schema": "dataplatform_near_verifications"
            }
          }
        }
      }
    ],
    "array_relationships": [
      {
        "name": "comments",
        "using": {
          "manual_configuration": {
            "column_mapping": {
              "id": "post_id"
            },
            "insertion_order": null,
            "remote_table": {
              "name": "moderated_comments",
              "schema": "dataplatform_near_feed"
            }
          }
        }
      },
      {
        "name": "post_likes",
        "using": {
          "manual_configuration": {
            "column_mapping": {
              "id": "post_id"
            },
            "insertion_order": null,
            "remote_table": {
              "name": "post_likes",
              "schema": "dataplatform_near_social_feed"
            }
          }
        }
      }
    ]
  },
  "moderated_comments": {
    "object_relationships": [
      {
        "name": "post",
        "using": {
          "manual_configuration": {
            "column_mapping": {
              "post_id": "id"
            },
            "insertion_order": null,
            "remote_table": {
              "name": "moderated_posts",
              "schema": "dataplatform_near_feed"
            }
          }
        }
      }
    ]
  }
}

'''
'''--- indexers/moderation/moderation.js ---
import { Block } from "@near-lake/primitives";
/**
 * Note: We only support javascript at the moment. We will support Rust, Typescript in a further release.
 */

/**
 * getBlock(block, context) applies your custom logic to a Block on Near and commits the data to a database.
 * context is a global variable that contains helper methods.
 * context.db is a subfield which contains helper methods to interact with your database.
 *
 * Learn more about indexers here:  https://docs.near.org/concepts/advanced/indexers
 *
 * @param {block} Block - A Near Protocol Block
 */
async function getBlock(block: Block) {
  function base64decode(encodedValue) {
    let buff = Buffer.from(encodedValue, "base64");
    return JSON.parse(buff.toString("utf-8"));
  }

  function parseIndexAction(actionName, userData) {
    const returnValues = [];
    const actionData =
      userData.index && userData.index[actionName]
        ? userData.index[actionName]
        : null;
    if (actionData) {
      const actionDataParsed = JSON.parse(actionData);
      const actionsArray = Array.isArray(actionDataParsed)
        ? actionDataParsed
        : [actionDataParsed];
      for (let a of actionsArray) {
        const value = a.value;
        if (value && value.path) {
          const fullPath = value.path.split("/");
          const account = fullPath[0];
          const path =
            fullPath.length > 1 ? "/" + fullPath.slice(1).join("/") : null;
          const { blockHeight, operation } = value;
          const label = value.label ?? "report";
          returnValues.push({ account, path, blockHeight, label, operation });
        }
      }
    }
    return returnValues;
  }

  const calls = block.actions().flatMap((action) =>
    action.operations
      .map((operation) => operation["FunctionCall"])
      .filter((operation) => operation?.methodName === "set")
      .map((functionCallOperation) => ({
        ...functionCallOperation,
        args: base64decode(functionCallOperation.args),
      }))
      .filter((functionCall) => {
        if (
            !functionCall ||
            !functionCall.args ||
            !functionCall.args.data ||
            !Object.keys(functionCall.args.data) ||
            !Object.keys(functionCall.args.data)[0]
        ) {
          console.log(
              "Set operation did not have arg data in expected format"
          );
          return;
        }
        const accountId = Object.keys(functionCall.args.data)[0];
        return (
          functionCall.args.data[accountId].moderate ||
          (functionCall.args.data[accountId].index &&
            functionCall.args.data[accountId].index.moderate) ||
          // ignore index.moderation because it duplicates the non-index moderate key
          (functionCall.args.data[accountId].index &&
            functionCall.args.data[accountId].index.flag) // backwards compatibility
        );
      }),
  );

  for (let index in calls) {
    let call = calls[index];
    console.log("call", call);
    try {
      const accountId = Object.keys(call.args.data)[0];
      const userData = call.args.data[accountId];

      // user self-moderation data and reported feed
      const reportedObjects = []; // build up an array of reported objects
      const userModeration = userData.moderate;
      if(userModeration) {
        const moderatedAccounts = Object.keys(userModeration);
        for (let account of moderatedAccounts) {
          let value = userModeration[account];
          if (typeof value === "string") {
            const label = value;
            reportedObjects.push({ account, label });
          } else {
            for (let path of Object.keys(value)) {
              value = value[path];
              if (typeof value === "string") {
                const label = value;
                reportedObjects.push({ account, path, label });
              } else {
                for (let blockHeight of Object.keys(value)) {
                  value = value[blockHeight];
                  if (typeof value === "string") {
                    const label = value;
                    reportedObjects.push({ account, path, blockHeight, label });
                  } else {
                    const label = value.label;
                    const expiration = value.expiration;
                    reportedObjects.push({
                      account,
                      path,
                      blockHeight,
                      label,
                      expiration,
                    });
                  }
                }
              }
            }
          }
        }
      }

      const userFlags = parseIndexAction("flag", userData); // backwards compatibility
      if (userFlags && userFlags.length > 0) {
        reportedObjects.push(userFlags);
      }

      console.log("Reported objects", reportedObjects);

      const group = "near.org";
      for (let report of reportedObjects) {
        const label = report.label;
        const moderated_account_id = report.account;
        const moderated_path = report.path?.replace(/\./g, "/");
        const moderated_blockheight = parseInt(report.blockHeight);
        const mutationData = {
          report: {
            group,
            account_id: accountId,
            moderated_account_id,
            moderated_path,
            moderated_blockheight,
            label,
          },
        };
        await context.graphql(
          `mutation insertReport($report: dataplatform_near_moderation_moderation_reporting_insert_input!) {
                        insert_dataplatform_near_moderation_moderation_reporting_one( object: $report
                        ) { group account_id moderated_account_id moderated_path moderated_blockheight label }
                    }`,
          mutationData,
        );
        // pending upgrade to Postgres 15 for NULLS NOT DISTINCT
        // on_conflict: {constraint: moderation_reporting_pkey, update_columns: [label, expiration]}

        // requires QueryApi V2
        // context V2 ONLY .db.ModerationReporting.insert({
        //   group,
        //   account_id: accountId,
        //   moderated_account_id,
        //   moderated_path,
        //   moderated_blockheight,
        //   label,
        // });
      }

      // moderator decisions
      const moderatorsForGroup = ["bosmod.near", "flatirons.near"]; // moderator, testing. future query placeholder
      if (moderatorsForGroup.includes(accountId)) {
        const decisions = parseIndexAction("moderate", userData);
        if (decisions) {
          for (let decision of decisions) {
            console.log("decision", decision);
            const operation = decision.operation;
            const label = decision.label;
            const moderated_account_id = decision.account;
            const moderated_path = decision.path;
            const moderated_blockheight = decision.blockHeight;

            if (operation) {
              switch (operation) {
                case "delete":
                  const pathDescriminator = moderated_path
                    ? `{_eq: "${moderated_path}"}`
                    : `{_is_null: true}`;
                  const blockHeightDescriminator = moderated_blockheight
                    ? `{_eq: ${moderated_blockheight}}`
                    : `{_is_null: true}`;
                  const mutation = `mutation {
                    delete_dataplatform_near_moderation_moderation_decisions(
                      where: {moderated_account_id: {_eq: "${moderated_account_id}"}, moderated_path: ${pathDescriminator}, moderated_blockheight: ${blockHeightDescriminator}}
                    ) {
                      returning {
                        moderated_account_id
                        moderated_path
                        moderated_blockheight
                      }
                    }
                  }`;
                  console.log("mutation", mutation);
                  context.graphql(mutation, {});
                  break;
                case "update":
                  // todo
                  console.log(
                    "Update operation is not yet implemented",
                    decision,
                  );
                  break;
                default:
                  console.log(
                    "Invalid moderation operation",
                    operation,
                    decision,
                  );
              }
            } else {
              const mutationData = {
                decision: {
                  group,
                  moderator_account_id: accountId,
                  moderated_account_id,
                  moderated_path,
                  moderated_blockheight,
                  label,
                },
              };
              context.graphql(
                `mutation insertDecision($decision: dataplatform_near_moderation_moderation_decisions_insert_input!) {
                                    insert_dataplatform_near_moderation_moderation_decisions_one( object: $decision
                                    ) { group moderator_account_id moderated_account_id moderated_path moderated_blockheight label }
                                }`,
                mutationData,
              );
              // pending upgrade to Postgres 15 for NULLS NOT DISTINCT
              // on_conflict: {constraint: moderation_decisions_pkey, update_columns: [label, expiration, notes]}

              // requires QueryApi V2
              // context. V2 ONLY db.ModerationDecisions.insert({
              //   group,
              //   moderator_account_id: accountId,
              //   moderated_account_id,
              //   moderated_path,
              //   moderated_blockheight,
              //   label,
              // });
            }
          }
        }
      }
    } catch (error) {
      console.log("Caught error", error);
    }
  }
}

'''
'''--- indexers/moderation/moderation.sql ---
CREATE TABLE
    "moderation_decisions" (
                               "group" text NOT NULL,
                               "moderator_account_id" text NOT NULL,
                               "moderated_account_id" text NOT NULL,
                               "moderated_path" text NULL,
                               "moderated_blockheight" integer NULL,
                               "base_content_account" text NULL, -- original poster when comment is being moderated
                               "base_content_path" text NULL, -- /post/main, /post/comment, etc
                               "base_content_blockheight" text NULL, -- original post blockheight
                               "label" text NOT NULL,
                               "expiration" timestamp NULL,
                               "notes" text NULL
);

CREATE INDEX
    moderation_decisions_content_idx ON moderation_decisions (
                                                              "moderated_account_id",
                                                              "moderated_path",
                                                              "moderated_blockheight"
    );

CREATE TABLE
    "moderation_reporting" (
                               "group" text NOT NULL,
                               "account_id" text NOT NULL,
                               "moderated_account_id" text NOT NULL,
                               "moderated_path" text NULL,
                               "moderated_blockheight" integer NULL,
                               "base_content_account" text NULL, -- original poster when comment is being moderated
                               "base_content_path" text NULL, -- /post/main, /post/comment, etc
                               "base_content_blockheight" text NULL, -- original post blockheight
                               "label" text NOT NULL,
                               "expiration" timestamp NULL,
                               "notes" text NULL
);

CREATE INDEX
    moderation_reporting_content_idx ON moderation_reporting (
                                                              "moderated_account_id",
                                                              "moderated_path",
                                                              "moderated_blockheight"
    );

CREATE VIEW dataplatform_near_moderation.unmoderated_reports as
SELECT min(report_blockheight) as first_report_blockheight, count(distinct account_id) as reporter_count,
       array(select account_id from dataplatform_near_moderation.moderation_reporting rl
             WHERE ((rl.moderated_account_id = r.moderated_account_id)
                        AND ((r.moderated_path IS NULL AND rl.moderated_path IS NULL) OR
                             ((rl.moderated_path = r.moderated_path) AND (rl.moderated_blockheight = r.moderated_blockheight))))
             AND rl.label != 'hide'
             group by account_id limit 5) as reporter_list,
       moderated_account_id, moderated_path, moderated_blockheight,
       mode() within group (order by label) as most_frequent_label --  most prevalent label
FROM dataplatform_near_moderation.moderation_reporting r
WHERE NOT EXISTS (
    SELECT * FROM dataplatform_near_moderation.moderation_decisions d
    WHERE r.moderated_account_id = d.moderated_account_id
      AND (d.moderated_path IS NULL OR (d.moderated_path = r.moderated_path AND r.moderated_blockheight = d.moderated_blockheight))
)
  AND r.label != 'hide'
GROUP by moderated_account_id, moderated_path, moderated_blockheight;

CREATE VIEW dataplatform_near_moderation.needs_moderation as
SELECT r.most_frequent_label, r.first_report_blockheight, r.reporter_count, r.reporter_list, r.moderated_path, p.account_id, p.block_height, p.block_timestamp, 'removed' as receipt_id, p.content
FROM dataplatform_near_moderation.unmoderated_reports as r
         INNER JOIN dataplatform_near_social_feed.posts p
                    ON p.account_id = r.moderated_account_id AND r.moderated_blockheight = p.block_height AND r.moderated_path = '/post/main'
UNION
SELECT r.most_frequent_label, r.first_report_blockheight, r.reporter_count, r.reporter_list, r.moderated_path, c.account_id, c.block_height, c.block_timestamp, 'removed' as receipt_id, c.content
FROM dataplatform_near_moderation.unmoderated_reports as r
         INNER JOIN dataplatform_near_social_feed.comments c
                    ON c.account_id = r.moderated_account_id AND r.moderated_blockheight = c.block_height AND r.moderated_path = '/post/comment'
UNION
SELECT r.most_frequent_label, r.first_report_blockheight, r.reporter_count, r.reporter_list, null as moderated_path, moderated_account_id as account_id, null as block_height, null as block_timestamp, 'removed' as receipt_id, null as content
FROM dataplatform_near_moderation.unmoderated_reports as r
WHERE r.moderated_path is null
ORDER BY block_height DESC;
'''
'''--- indexers/notifications/notifications.js ---
import { Block } from "@near-lake/primitives";
/**
 * Note: We only support javascript at the moment. We will support Rust, Typescript in a further release.
 */

/**
 * getBlock(block, context) applies your custom logic to a Block on Near and commits the data to a database.
 * context is a global variable that contains helper methods.
 * context.db is a subfield which contains helper methods to interact with your database.
 *
 * Learn more about indexers here:  https://docs.near.org/concepts/advanced/indexers
 *
 * @param {block} Block - A Near Protocol Block
 */
async function getBlock(block: Block) {
  const SOCIAL_DB = "social.near";

  let nearDBIndexUpdates = [];

  try {
    const actions = block.actions();

    if (!actions) {
      console.log("Block has no actions");
      return;
    }
    const contractActions = actions.filter(
      (action) => action.receiverId === SOCIAL_DB
    );
    if (!contractActions) {
      console.log("Block has no actions");
      return;
    }
    nearDBIndexUpdates = contractActions
      .flatMap((action) =>
        action.operations
          .map((operation) => operation["FunctionCall"])
          .filter((operation) => operation?.methodName === "set")
          .map((functionCallOperation) => ({
            ...functionCallOperation,
            args: base64decode(functionCallOperation.args),
            receiptId: action.receiptId,
          }))
          .filter((functionCall) => {
            try {
              if (
                !functionCall ||
                !functionCall.args ||
                !functionCall.args.data ||
                !Object.keys(functionCall.args.data) ||
                !Object.keys(functionCall.args.data)[0]
              ) {
                console.log(
                  "Set operation did not have arg data in expected format"
                );
                return;
              }
              const accountId = Object.keys(functionCall.args.data)[0];
              if (!functionCall.args.data[accountId]) {
                console.log(
                  "Set operation did not have arg data in expected format"
                );
                return;
              }
              return Object.keys(functionCall.args.data[accountId]).includes(
                "index"
              );
            } catch (error) {
              console.log("Error parsing social args", functionCall);
            }
          })
      );
  } catch (error) {
    console.log("Error parsing social operations", block.actions());
  }

  if (nearDBIndexUpdates.length > 0) {
    const blockHeight = block.blockHeight;
    await Promise.all(
      nearDBIndexUpdates.map(async (writeAction) => {
        const accountId = Object.keys(writeAction.args.data)[0];

        if (Object.keys(writeAction.args.data[accountId]).includes("index")) {
          if (!writeAction.args.data[accountId].index) {
            console.log(`Wrong notify format for receiver: ${accountId}, index is null`);
            return;
          }
          if (
            Object.keys(writeAction.args.data[accountId].index).includes(
              "notify"
            )
          ) {
            console.log(`ACCOUNT_ID: ${accountId}`);
            await handleNotify(
              accountId,
              blockHeight,
              writeAction.args.data[accountId].index.notify,
              writeAction.receiptId
            );
          }
        }
      })
    );
  }

  async function handleNotify(
    accountId,
    blockHeight,
    notifyPayload,
    receiptId
  ) {
    try {
      let data = JSON.parse(notifyPayload);
      data = Array.isArray(data) ? data : [data];
      const mutationPayload = data.map((notification) => {
        const { key, value } = notification;
        const {
          message,
          item = {},
          type: valueType,
          post: devhubPostId,
        } = value;
        const { path, type: itemType, blockHeight: actionAtBlockHeight } = item;
        // actionAtBlockHeight related to "like" itemType

        return {
          initiatedBy: accountId,
          receiver: key,
          message,
          valueType,
          itemType,
          path,
          blockHeight,
          devhubPostId,
          actionAtBlockHeight,
          receiptId,
        };
      });

      await context.graphql(
        `mutation MyMutation($objects: [dataplatform_near_notifications_notifications_insert_input!]!) {
        insert_dataplatform_near_notifications_notifications(
          objects: $objects
on_conflict: {
      constraint: notifications_receiptId_key,
      update_columns: [
          initiatedBy,
          receiver,
          message,
          valueType,
          itemType,
          path,
          blockHeight,
          devhubPostId,
          actionAtBlockHeight
      ]
    }
        ) {
          returning {
            initiatedBy
            receiver
            message
            valueType
            itemType
            path
            blockHeight
            devhubPostId
            actionAtBlockHeight
            receiptId
          }
        }
      }`,
        { objects: mutationPayload }
      );
      console.log(`Successfully stored Notify record for ${accountId}`);
    } catch (e) {
      console.log(`Failed to store Notify record for ${accountId}. Error: ${e}`);
    }
  }

  function base64decode(encodedValue) {
    try {
      const buff = Buffer.from(encodedValue, "base64");
      const str = buff.toString("utf-8").replace(/\\xa0/g, " ");
      return JSON.parse(str);
    } catch (e) {
      console.log("Error while decoding value", e);
      return null;
    }
  }
}

'''
'''--- indexers/notifications/notifications.sql ---
CREATE TABLE
  "notifications" (
    "id" SERIAL,
    "blockHeight" DECIMAL(58, 0) NOT NULL,
    "initiatedBy" TEXT NOT NULL,
    "receiver" TEXT NOT NULL,
    "valueType" TEXT NOT NULL,
    "message" TEXT NULL,
    "itemType" TEXT NULL,
    "path" TEXT NULL,
    "devhubPostId" INT NULL,
    "actionAtBlockHeight" INT NULL,
    "receiptId" VARCHAR NULL,
    PRIMARY KEY ("id")
  );

ALTER TABLE notifications
ADD CONSTRAINT notifications_receiptId_key UNIQUE (receiptId);

CREATE UNIQUE INDEX notifications_pkey ON notifications USING BTREE (id);

CREATE UNIQUE INDEX notifications_receiptId_key ON notifications USING BTREE (receiptId);

'''
'''--- indexers/notifications/relationships.json ---
{
  "object_relationships": [
    {
      "name": "account",
      "using": {
        "manual_configuration": {
          "column_mapping": {
            "initiatedBy": "account_id"
          },
          "insertion_order": null,
          "remote_table": {
            "name": "accounts",
            "schema": "dataplatform_near_accounts"
          }
        }
      }
    }
  ]
}

'''
'''--- indexers/social_feed/social_feed.js ---
import * as primitives from "@near-lake/primitives";
/**
 * Note: We only support javascript at the moment. We will support Rust, Typescript in a further release.
 */

/**
 * getBlock(block, context) applies your custom logic to a Block on Near and commits the data to a database.
 * context is a global variable that contains helper methods.
 * context.db is a subfield which contains helper methods to interact with your database.
 *
 * Learn more about indexers here:  https://docs.near.org/concepts/advanced/indexers
 *
 * @param {block} Block - A Near Protocol Block
 */
async function getBlock(block: primitives.Block) {
  function base64decode(encodedValue) {
    let buff = Buffer.from(encodedValue, "base64");
    return JSON.parse(buff.toString("utf-8"));
  }

  async function handlePostCreation(
    accountId,
    blockHeight,
    blockTimestamp,
    receiptId,
    content
  ) {
    try {
      const postData = {
        account_id: accountId,
        block_height: blockHeight,
        block_timestamp: blockTimestamp,
        content: content,
        receipt_id: receiptId,
      };

      // Call GraphQL mutation to insert a new post
      await context.db.Posts.insert(postData);

      console.log(`Post by ${accountId} has been added to the database`);
    } catch (e) {
      console.log(
        `Failed to store post by ${accountId} to the database (perhaps it is already stored)`
      );
    }
  }

  async function handleCommentCreation(
    accountId,
    blockHeight,
    blockTimestamp,
    receiptId,
    commentString
  ) {
    try {
      const comment = JSON.parse(commentString);
      const postAuthor = comment.item.path.split("/")[0];
      const postBlockHeight = comment.item.blockHeight;

      // find post to retrieve Id or print a warning that we don't have it
      try {
        // Call GraphQL query to fetch posts that match specified criteria
        const posts = await context.db.Posts.select(
          { account_id: postAuthor, block_height: postBlockHeight },
          1
        );
        console.log(`posts: ${JSON.stringify(posts)}`);
        if (posts.length === 0) {
          return;
        }

        const post = posts[0];

        try {
          delete comment["item"];
          const commentData = {
            account_id: accountId,
            receipt_id: receiptId,
            block_height: blockHeight,
            block_timestamp: blockTimestamp,
            content: JSON.stringify(comment),
            post_id: post.id,
          };
          // Call GraphQL mutation to insert a new comment
          await context.db.Comments.insert(commentData);

          // Update last comment timestamp in Post table
          const currentTimestamp = Date.now();
          await context.db.Posts.update(
            { id: post.id },
            { last_comment_timestamp: currentTimestamp }
          );
          console.log(`Comment by ${accountId} has been added to the database`);
        } catch (e) {
          console.log(
            `Failed to store comment to the post ${postAuthor}/${postBlockHeight} by ${accountId} perhaps it has already been stored. Error ${e}`
          );
        }
      } catch (e) {
        console.log(
          `Failed to store comment to the post ${postAuthor}/${postBlockHeight} as we don't have the post stored.`
        );
      }
    } catch (error) {
      console.log("Failed to parse comment content. Skipping...", error);
    }
  }

  async function handleLike(
    accountId,
    blockHeight,
    blockTimestamp,
    receiptId,
    likeContent
  ) {
    try {
      const like = JSON.parse(likeContent);
      const likeAction = like.value.type; // like or unlike
      const [itemAuthor, _, itemType] = like.key.path.split("/", 3);
      const itemBlockHeight = like.key.blockHeight;
      console.log("handling like", receiptId, accountId);
      switch (itemType) {
        case "main":
          try {
            const posts = await context.db.Posts.select(
              { account_id: itemAuthor, block_height: itemBlockHeight },
              1
            );
            if (posts.length == 0) {
              return;
            }

            const post = posts[0];
            switch (likeAction) {
              case "like":
                await _handlePostLike(
                  post.id,
                  accountId,
                  blockHeight,
                  blockTimestamp,
                  receiptId
                );
                break;
              case "unlike":
                await _handlePostUnlike(post.id, accountId);
                break;
            }
          } catch (e) {
            console.log(
              `Failed to store like to post ${itemAuthor}/${itemBlockHeight} as we don't have it stored in the first place.`
            );
          }
          break;
        case "comment":
          // Comment
          console.log(`Likes to comments are not supported yet. Skipping`);
          break;
        default:
          // something else
          console.log(`Got unsupported like type "${itemType}". Skipping...`);
          break;
      }
    } catch (error) {
      console.log("Failed to parse like content. Skipping...", error);
    }
  }

  async function _handlePostLike(
    postId,
    likeAuthorAccountId,
    likeBlockHeight,
    blockTimestamp,
    receiptId
  ) {
    try {
      const posts = await context.db.Posts.select({ id: postId });
      if (posts.length == 0) {
        return;
      }
      const post = posts[0];
      let accountsLiked =
        post.accounts_liked.length === 0
          ? post.accounts_liked
          : JSON.parse(post.accounts_liked);

      if (accountsLiked.indexOf(likeAuthorAccountId) === -1) {
        accountsLiked.push(likeAuthorAccountId);
      }

      // Call GraphQL mutation to update a post's liked accounts list
      await context.db.Posts.update(
        { id: postId },
        { accounts_liked: JSON.stringify(accountsLiked) }
      );

      const postLikeData = {
        post_id: postId,
        account_id: likeAuthorAccountId,
        block_height: likeBlockHeight,
        block_timestamp: blockTimestamp,
        receipt_id: receiptId,
      };
      // Call GraphQL mutation to insert a new like for a post
      await context.db.PostLikes.insert(postLikeData);
    } catch (e) {
      console.log(`Failed to store like to in the database: ${e}`);
    }
  }

  async function _handlePostUnlike(postId, likeAuthorAccountId) {
    try {
      const posts = await context.db.Posts.select({ id: postId });
      if (posts.length == 0) {
        return;
      }
      const post = posts[0];
      let accountsLiked =
        post.accounts_liked.length === 0
          ? post.accounts_liked
          : JSON.parse(post.accounts_liked);

      console.log(accountsLiked);

      let indexOfLikeAuthorAccountIdInPost =
        accountsLiked.indexOf(likeAuthorAccountId);
      if (indexOfLikeAuthorAccountIdInPost > -1) {
        accountsLiked.splice(indexOfLikeAuthorAccountIdInPost, 1);
        // Call GraphQL mutation to update a post's liked accounts list
        await context.db.Posts.update(
          { id: postId },
          { accounts_liked: JSON.stringify(accountsLiked) }
        );
      }
      // Call GraphQL mutation to delete a like for a post
      await context.db.PostLikes.delete({
        account_id: likeAuthorAccountId,
        post_id: postId,
      });
    } catch (e) {
      console.log(`Failed to delete like from the database: ${e}`);
    }
  }

  async function handlePromotion(
    accountId,
    blockHeight,
    blockTimestamp,
    receiptId,
    promoteString
  ) {
    const promotion = JSON.parse(promoteString);
    console.log("Promotion", promotion);
    const promotionOperation = promotion.value.operation;

    if (promotionOperation === "add") {
      console.log("handling add promotion");
      await _handleAddPromotion(
        promotion,
        accountId,
        blockHeight,
        blockTimestamp,
        receiptId
      );
      return;
    } else {
      // if an operation is implemented, we can handle it here
      console.log("Operation not implemented");
    }
  }

  async function _handleAddPromotion(
    promotion,
    accountId,
    blockHeight,
    blockTimestamp,
    receiptId
  ) {
    // Add your code here
    const postAuthor = promotion.value.post.path.split("/")[0];
    const postBlockHeight = promotion.value.post.blockHeight;
    const promotionType = promotion.value.type;

    console.log("Post Author", postAuthor);
    console.log("Post Block Height", postBlockHeight);
    console.log("Promotion Type", promotionType);
    try {
      const posts = await context.db.Posts.select(
        { account_id: postAuthor, block_height: postBlockHeight },
        1
      );

      if (posts.length > 0) {
        const post = posts[0];
        let content = JSON.parse(post.content);

        console.log("Post found in database", post);
        console.log("Post content", content);

        delete promotion["item"];

        const promotionData = {
          account_id: accountId,
          receipt_id: receiptId,
          block_height: blockHeight,
          block_timestamp: blockTimestamp,
          promotion_type: promotionType,
          post_id: post.id,
        };

        // Call GraphQL mutation to insert a new promotion
        await context.db.Promote.insert(promotionData);

        console.log(`Promotion by ${accountId} has been added to the database`);
      }
    } catch (e) {
      console.log("Error handling add promotion", JSON.stringify(e));
    }
  }

  async function handleRepost(
    accountId,
    blockHeight,
    blockTimestamp,
    receiptId,
    repostContent
  ) {
    try {

      const content = JSON.parse(repostContent);

      if (content[1]?.value?.type !== "repost") {
        console.log("Skipping non-repost content", content);
        return;
      }

      const postAuthor = content[1].key.path.split("/")[0];
      const postBlockHeight = content[1].key.blockHeight;

      try {
        const posts = await context.db.Posts.select(
          { account_id: postAuthor, block_height: postBlockHeight },
          1
        );
        console.log(`posts: ${JSON.stringify(posts)}`, posts);
        if (posts.length == 0) {
          return;
        }

        const post = posts[0];
        const accountsReposted =
          post.accounts_reposted.length === 0
            ? post.accounts_reposted
            : JSON.parse(post.accounts_reposted);
        if (accountsReposted.indexOf(accountId) === -1) {
          accountsReposted.push(accountId);
        }

        try {
          const repostData = {
            post_id: post.id,
            account_id: accountId,
            content: JSON.stringify(content),
            block_height: blockHeight,
            block_timestamp: blockTimestamp,
            receipt_id: receiptId,
          };
          // Call GraphQL mutation to insert a new repost
          await context.db.Reposts.insert(repostData);
          console.log(`Repost by ${accountId} has been added to the database`);

          // Call GraphQL mutation to update a post's reposted accounts list
          await context.db.Posts.update(
            { id: post.id },
            { accounts_reposted: JSON.stringify(accountsReposted) }
          );
          console.log(`Repost by ${accountId} has been added to the database`);
        } catch (e) {
          console.log(
            `Failed to store repost to the post ${postAuthor}/${postBlockHeight} by ${accountId} perhaps it has already been stored. Error ${e}`
          );
        }
      } catch (e) {
        console.log(
          `Failed to store repost to the post ${postAuthor}/${postBlockHeight} as we don't have it stored in the first place. Error ${e}`
        );
      }
    } catch (error) {
      console.log("Failed to parse repost content. Skipping...", error);
    }
  }

  // Add your code here
  const SOCIAL_DB = "social.near";

  let nearSocialPosts = [];
  try {
    const actions = block.actions();
    if (!actions) {
      console.log("Block has no actions");
      return;
    }
    const contractActions = actions.filter(
      (action) => action.receiverId === SOCIAL_DB
    );
    if (!contractActions) {
      console.log("Block has no actions");
      return;
    }
    nearSocialPosts = contractActions.flatMap((action) =>
      action.operations
        .map((operation) => operation["FunctionCall"])
        .filter((operation) => operation?.methodName === "set")
        .map((functionCallOperation) => {
          try {
            return {
              ...functionCallOperation,
              args: base64decode(functionCallOperation.args),
              receiptId: action.receiptId, // providing receiptId as we need it
            };
          } catch (e) {
            console.log("Error parsing function call", e);
          }
        })
        .filter((functionCall) => {
          try {
            if (
              !functionCall ||
              !functionCall.args ||
              !functionCall.args.data ||
              !Object.keys(functionCall.args.data) ||
              !Object.keys(functionCall.args.data)[0]
            ) {
              console.log(
                "Set operation did not have arg data in expected format"
              );
              return;
            }
            const accountId = Object.keys(functionCall.args.data)[0];
            return (
              Object.keys(functionCall.args.data[accountId]).includes("post") ||
              Object.keys(functionCall.args.data[accountId]).includes("index")
            );
          } catch (e) {
            console.log("Error parsing social args", functionCall);
          }
        })
    );
  } catch (e) {
    console.log("Error parsing social operations", block.actions());
  }

  if (nearSocialPosts.length > 0) {
    console.log("Found Near Social Posts in Block...");
    const blockHeight = block.blockHeight;
    const blockTimestamp = block.header().timestampNanosec;
    await Promise.all(
      nearSocialPosts.map(async (postAction) => {
        const accountId = Object.keys(postAction.args.data)[0];
        console.log(`ACCOUNT_ID: ${accountId}`);

        // if creates a post
        if (
          postAction.args.data[accountId].post &&
          Object.keys(postAction.args.data[accountId].post).includes("main")
        ) {
          console.log("Creating a post...");
          await handlePostCreation(
            accountId,
            blockHeight,
            blockTimestamp,
            postAction.receiptId,
            postAction.args.data[accountId].post.main
          );
        } else if (
          postAction.args.data[accountId].post &&
          Object.keys(postAction.args.data[accountId].post).includes("comment")
        ) {
          // if creates a comment
          await handleCommentCreation(
            accountId,
            blockHeight,
            blockTimestamp,
            postAction.receiptId,
            postAction.args.data[accountId].post.comment
          );
        } else if (
          Object.keys(postAction.args.data[accountId]).includes("index")
        ) {
          // Probably like or unlike action is happening
          if (
            Object.keys(postAction.args.data[accountId].index).includes("like")
          ) {
            console.log("handling like");
            await handleLike(
              accountId,
              blockHeight,
              blockTimestamp,
              postAction.receiptId,
              postAction.args.data[accountId].index.like
            );
          }

          if (
            Object.keys(postAction.args.data[accountId].index).includes(
              "promote"
            )
          ) {
            console.log("handling promotion");
            await handlePromotion(
              accountId,
              blockHeight,
              blockTimestamp,
              postAction.receiptId,
              postAction.args.data[accountId].index.promote
            );
          }

          // Probably repost action is happening
          if (
            Object.keys(postAction.args.data[accountId].index).includes(
              "repost"
            )
          ) {
            console.log("handling repost");
            await handleRepost(
              accountId,
              blockHeight,
              blockTimestamp,
              postAction.receiptId,
              postAction.args.data[accountId].index.repost
            );
          }
        }
      })
    );
  }
}

'''
'''--- indexers/social_feed/social_feed.sql ---
CREATE TABLE
  "posts" (
    "id" SERIAL NOT NULL,
    "account_id" VARCHAR NOT NULL,
    "block_height" DECIMAL(58, 0) NOT NULL,
    "receipt_id" VARCHAR NOT NULL,
    "content" TEXT NOT NULL,
    "block_timestamp" DECIMAL(20, 0) NOT NULL,
    "accounts_liked" JSONB NOT NULL DEFAULT '[]',
    "last_comment_timestamp" DECIMAL(20, 0),
    CONSTRAINT "posts_pkey" PRIMARY KEY ("id")
  );

CREATE TABLE
  "comments" (
    "id" SERIAL NOT NULL,
    "post_id" SERIAL NOT NULL,
    "account_id" VARCHAR NOT NULL,
    "block_height" DECIMAL(58, 0) NOT NULL,
    "content" TEXT NOT NULL,
    "block_timestamp" DECIMAL(20, 0) NOT NULL,
    "receipt_id" VARCHAR NOT NULL,
    CONSTRAINT "comments_pkey" PRIMARY KEY ("id")
  );

CREATE TABLE
  "post_likes" (
    "post_id" SERIAL NOT NULL,
    "account_id" VARCHAR NOT NULL,
    "block_height" DECIMAL(58, 0),
    "block_timestamp" DECIMAL(20, 0) NOT NULL,
    "receipt_id" VARCHAR NOT NULL,
    CONSTRAINT "post_likes_pkey" PRIMARY KEY ("post_id", "account_id")
  );

CREATE TABLE
  "promote" (
    "id" SERIAL NOT NULL,
    "account_id" VARCHAR NOT NULL,
    "receipt_id" VARCHAR NOT NULL,
    "block_height" DECIMAL(58, 0) NOT NULL,
    "block_timestamp" DECIMAL(20, 0) NOT NULL,
    "promotion_type" TEXT NOT NULL,
    "post_id" SERIAL NOT NULL
  );

CREATE TABLE
  "reposts" (
    "id" SERIAL NOT NULL,
    "post_id" SERIAL NOT NULL,
    "account_id" VARCHAR NOT NULL,
    "content" TEXT NOT NULL,
    "block_height" DECIMAL(58, 0) NOT NULL,
    "block_timestamp" DECIMAL(20, 0) NOT NULL,
    "receipt_id" VARCHAR NOT NULL,
    CONSTRAINT "reposts_pkey" PRIMARY KEY ("post_id", "account_id")
  ); 

CREATE UNIQUE INDEX "posts_account_id_block_height_key" ON "posts" ("account_id" ASC, "block_height" ASC);

CREATE UNIQUE INDEX "comments_post_id_account_id_block_height_key" ON "comments" (
  "post_id" ASC,
  "account_id" ASC,
  "block_height" ASC
);

CREATE INDEX
  "posts_last_comment_timestamp_idx" ON "posts" ("last_comment_timestamp" DESC);

ALTER TABLE
  "comments"
ADD
  CONSTRAINT "comments_post_id_fkey" FOREIGN KEY ("post_id") REFERENCES "posts" ("id") ON DELETE NO ACTION ON UPDATE NO ACTION;

ALTER TABLE
  "post_likes"
ADD
  CONSTRAINT "post_likes_post_id_fkey" FOREIGN KEY ("post_id") REFERENCES "posts" ("id") ON DELETE CASCADE ON UPDATE NO ACTION;

'''
'''--- indexers/verifications/verifications.js ---
import { Block } from "@near-lake/primitives";
/**
 * Note: We only support javascript at the moment. We will support Rust, Typescript in a further release.
 */

/**
 * getBlock(block, context) applies your custom logic to a Block on Near and commits the data to a database.
 * context is a global variable that contains helper methods.
 * context.db is a subfield which contains helper methods to interact with your database.
 *
 * Learn more about indexers here:  https://docs.near.org/concepts/advanced/indexers
 *
 * @param {block} Block - A Near Protocol Block
 */
async function getBlock(block: Block) {
  function base64decode(encodedValue) {
    let buff = Buffer.from(encodedValue, "base64");
    return JSON.parse(buff.toString("utf-8"));
  }
  const calls = block.actions().flatMap((action) =>
    action.operations
      .map((operation) => operation["FunctionCall"])
      .filter((operation) => operation?.methodName === "sbt_mint")
      .map((functionCallOperation) => ({
        ...functionCallOperation,
        args: base64decode(functionCallOperation.args),
      })),
  );

  for (let index in calls) {
    let call = calls[index];
    console.log("call", call);
    try {
      if (call && call.args && call.args.token_spec) {
        const accountId = call.args.token_spec[0][0];
        const issuance = call.args.token_spec[0][1][0];
        if (accountId && issuance) {
          const level = issuance.class ? issuance.class.toString() : "";
          const expires = new Date(issuance.expires_at).toISOString();
          const provider = "i-am-human.app";
          console.log(
            "found verification:",
            accountId,
            level,
            expires,
            provider,
          );

          const mutationData = {
            account: {
              account_id: accountId,
              human_valid_until: expires,
              human_verification_level: level,
              human_provider: provider,
            },
          };

          await context.graphql(
            `mutation createAccount($account: dataplatform_near_verifications_account_insert_input!){
                            insert_dataplatform_near_verifications_account_one(
                                object: $account
                                on_conflict: {constraint: account_pkey, update_columns: [human_valid_until,human_verification_level, human_provider]}
                            ) { account_id}
                        }`,
            mutationData,
          );
        } else {
          console.log("No account_id or issuance in this token spec");
        }
      } else {
        console.log("No token spec in this mint operation");
      }
    } catch (error) {
      console.log("Caught error", error);
    }
  }
}

'''
'''--- indexers/verifications/verifications.sql ---
CREATE TABLE
    "account" (
                  "account_id" TEXT NOT NULL,
                  "human_valid_until" timestamp NULL,
                  "human_verification_level" text NULL,
                  "human_provider" text NULL,
                  "kyc_valid_until" timestamp NULL,
                  "kyc_verification_level" text NULL,
                  "kyc_provider" text NULL,
                  "social_trust_score_1" integer NULL,
                  "social_trust_provider_1" text NULL,
                  "social_trust_score_2" integer NULL,
                  "social_trust_provider_2" text NULL,
                  PRIMARY KEY ("account_id")
)

'''
'''--- package.json ---
{
  "name": "near-discovery-components",
  "version": "0.1.0",
  "description": "This is a repository that holds the source code of all NEAR discovery components that the team maintains for near.org.",
  "scripts": {
    "prettier": "prettier --check --log-level warn 'src/**/*.{js,jsx,ts,tsx,json}'",
    "prettier:write": "prettier --write 'src/**/*.{js,jsx,ts,tsx,json}'",
    "prepare": "is-ci || husky install && npm install commitizen -g",
    "commit": "cz"
  },
  "license": "MIT",
  "devDependencies": {
    "@commitlint/cli": "^18.4.3",
    "@commitlint/config-conventional": "^18.4.3",
    "cz-conventional-changelog": "^3.3.0",
    "husky": "^8.0.0",
    "is-ci": "^3.0.1",
    "prettier": "^3.1.0"
  },
  "config": {
    "commitizen": {
      "path": "./node_modules/cz-conventional-changelog"
    }
  }
}

'''
'''--- replacements.dev.json ---
{
  "REPL_ACCOUNT": "discom-dev.testnet",
  "REPL_MOB": "eugenethedream",
  "REPL_MOB_2": "one.testnet",
  "REPL_MODERATOR": "bosmod.testnet",
  "REPL_NEAR_URL": "test.near.org",
  "REPL_NEARWEEK": "discom-dev.testnet",
  "REPL_FEATURED_COMP_MANAGER": "discom.testnet",
  "REPL_TIME_AGO_VERSION": "",
  "REPL_BOZON": "bozon_testnet.testnet",
  "REPL_NEARCATALOG": "discom-dev.testnet",
  "REPL_DEVHUB": "devhub-dev.testnet"
}

'''
'''--- replacements.mainnet.json ---
{
  "REPL_ACCOUNT": "near",
  "REPL_MOB": "mob.near",
  "REPL_MOB_2": "mob.near",
  "REPL_MODERATOR": "bosmod.near",
  "REPL_NEAR_URL": "near.org",
  "REPL_NEARWEEK": "nearweekapp.near",
  "REPL_FEATURED_COMP_MANAGER": "bosfeaturedmanager.near",
  "REPL_TIME_AGO_VERSION": "@97556750",
  "REPL_BOZON": "bozon.near",
  "REPL_NEARCATALOG": "nearcatalog.near",
  "REPL_DEVHUB": "devhub.near"
}

'''
'''--- replacements.testnet.json ---
{
  "REPL_ACCOUNT": "discom.testnet",
  "REPL_MOB": "eugenethedream",
  "REPL_MOB_2": "one.testnet",
  "REPL_MODERATOR": "bosmod.testnet",
  "REPL_NEAR_URL": "test.near.org",
  "REPL_NEARWEEK": "discom-dev.testnet",
  "REPL_FEATURED_COMP_MANAGER": "discom.testnet",
  "REPL_TIME_AGO_VERSION": "",
  "REPL_BOZON": "bozon_testnet.testnet",
  "REPL_NEARCATALOG": "discom-dev.testnet",
  "REPL_DEVHUB": "devhubtest.testnet"
}

'''
'''--- src/AI/DO_NOT_USE.md ---
The ai-platform repo deploys an AI folder of components into the same account.
Components here are likely to conflict.
'''
'''--- src/ActivityFeeds/test.js ---

'''
'''--- src/AppLibrary/IndexPage.metadata.json ---
{
  "description": "Welcome to the App Library, your portal to a world of possibilities on [near.org](http://near.org/). Discover a diverse array of apps with ease and seamless navigation. Dive into an ecosystem where you can browse and interact with hundreds of innovative applications!\nPlease bear in mind that we are currently in the beta phase of development. While we continue to refine our processes, the apps listed and categorized here may not yet benefit from a fully automated pipeline. Consider it a work in progress as we strive to enhance your experience!",
  "name": "App Library",
  "tags": {
    "app": "",
    "directory": "",
    "library": "",
    "store": ""
  }
}

'''
'''--- src/AppLibrary/Nearcon/IndexPage.metadata.json ---
{
  "description": "This is part of the NCON Bounties where we invite NEARCon attendees to explore Apps on B.O.S. and upvote their favorites to help decide the first group of Apps getting featured on the App Library (near.org/applications) Read more in the Event Guide section in the App! App Owners, Developers and Founders: This is your time to shine! Follow the Event Guide to get your Apps Qualified for participation!",
  "name": "NCON Bounty - App Upvoting",
  "image": {
    "ipfs_cid": "bafkreibphuaz2ksv6mqqhq6a5rmyybfe5r2l3kwpklirckmbmtbdemwyey"
  },
  "tags": {
    "app": "",
    "NEARCon23": ""
  }
}

'''
'''--- src/DIG/Accordion.metadata.json ---
{
  "description": "An accordion built with the Radix primitive: https://www.radix-ui.com/docs/primitives/components/accordion\n\n### Example\n\n```jsx\n<Widget\n  src=\"near/widget/DIG.Accordion\"\n  props={{\n    type: \"multiple\",\n    defaultValue: [\"1\"],\n    items: [\n      {\n        value: \"1\",\n        header: \"Header 1\",\n        content: (\n          <>\n            <p>My JSX context 1.</p>\n            <p>Here's another paragraph.</p>\n          </>\n        ),\n      },\n      {\n        value: \"2\",\n        header: \"Header 2\",\n        content: (\n          <>\n            <p>My JSX context 2.</p>\n            <p>Here's another paragraph.</p>\n          </>\n        ),\n      },\n    ],\n  }}\n/>\n```\n\n### Props\n\n`items`\n- type: array of objects defining each accordion section\n- Each object requires a `value` (unique string), `header` (string or JSX), and `content` (string or JSX)\n\nThis component also accepts all `Accordion.Root` props as outlined in the Radix documentation.",
  "name": "DIG.Accordion",
  "tags": {
    "dig": ""
  }
}

'''
'''--- src/DIG/Avatar.metadata.json ---
{
  "description": "This component renders an avatar.\n\n### Example\n\n```jsx\nconst accountId = props.accountId || context.accountId;\nconst profile = props.profile || Social.get(`${accountId}/profile/**`, \"final\");\n\nreturn (\n  <Widget\n    src=\"near/widget/DIG.Avatar\"\n    props={{\n      alt: accountId,\n      image: profile.image,\n      size: \"medium\",\n    }}\n  />\n);\n```\n\n### Props\n\n`alt`\n- type: string\n- optional\n- A description of the user's avatar (typically their account ID)\n\n`image`\n- type: object\n- required\n- An object that's compatible with `mob.near/widget/Image`: https://near.org/near/widget/ComponentDetailsPage?src=mob.near/widget/Image&tab=source\n\n`size`\n- type: string\n- optional\n- values: `small` (default), `medium`\n\n### HTML Attributes\n\nAll other props will be forwarded through to the wrapping `<div>` element. EG: `id`, `className`, `aria-*`.",
  "name": "DIG.Avatar",
  "tags": {
    "dig": ""
  }
}

'''
'''--- src/DIG/Badge.metadata.json ---
{
  "description": "This component renders a badge. Badges are not meant to be clickable. Refer to `DIG.Button` or `DIG.Chip` for clickable alternatives.\n\n### Example\n\n```jsx\nreturn (\n  <Widget\n    src=\"near/widget/DIG.Badge\"\n    props={{\n      label: \"Hello\",\n      iconLeft: \"ph-bold ph-pizza\",\n      variant: \"warning\",\n    }}\n  />\n);\n```\n\n### Props\n\n`iconLeft`\n- type: string (CSS Class)\n- optional\n- example: `\"ph-bold ph-anchor-simple\"`\n- https://phosphoricons.com\n- Adds an icon to the left of the `label`\n\n`iconRight`\n- type: string (CSS Class)\n- optional\n- example: `\"ph-bold ph-anchor-simple\"`\n- https://phosphoricons.com\n- Adds an icon to the right of the `label`\n\n`label`\n- type: string\n- required\n- The text displayed inside the badge\n\n`variant`\n- type: string\n- optional\n- Values: `primary` (default), `neutral`, `success`, `alert`, `warning`\n\nAll other props will be forwarded through to the wrapping `<div>` element. EG: `id`, `className`, `aria-*`.",
  "name": "DIG.Badge",
  "tags": {
    "dig": ""
  }
}

'''
'''--- src/DIG/Button.metadata.json ---
{
  "description": "A fully featured button component that can act as a `<button>` or `<a>` tag.\n\n### Example\n\n```jsx\n  <Widget src=\"near/widget/DIG.Button\" props={{ label: \"Click Me\" }} />\n```\n\n### Props\n\n`disabled`\n- type: bool\n\n`fill`\n- type: string\n- values: \"solid\", \"outline\", \"ghost\"\n- default: \"solid\"\n\n`href`\n- type: string\n- If a value is passed, the component will render an `<a>` tag instead of a `<button>`\n- All valid HTML props for `<a>` tags will be forwarded along to the element.\n\n`icon`\n- type: string (CSS Class)\n- example: `\"ph-bold ph-anchor-simple\"`\n- https://phosphoricons.com/\n- If a value is passed, the button will convert into an `IconButton` with an equal width and height.\n- If used in combination with the `label` prop, the `label` value will be converted into an `aria-label` attribute.\n\n`iconLeft`\n- type: string (CSS Class)\n- example: `\"ph-bold ph-anchor-simple\"`\n- https://phosphoricons.com/\n- Adds an icon to the left of the `label`\n\n`iconRight`\n- type: string (CSS Class)\n- example: `\"ph-bold ph-anchor-simple\"`\n- https://phosphoricons.com/\n- Adds an icon to the right of the `label`\n\n`label`\n- type: string\n- Adds visible text to button.\n- If used in combination with the `icon` prop, this value will be converted into an `aria-label` attribute.\n\n`loading`\n- type: bool\n- Disables the button, hides button text, and displays a loading spinner.\n\n`onClick`\n- type: function\n- Other DOM events like `onMouseDown` are also supported.\n\n`size`\n- type: string\n- values: \"small\", \"default\", \"large\"\n- default: \"default\"\n\n`type`\n- type: string\n- values: native HTML button type values (\"button\", \"submit\")\n- Ignored if `href` prop is passed\n\n`variant`\n- type: string\n- values: \"primary\", \"secondary\", \"affirmative\", \"destructive\"\n- default: \"primary\"\n\n### HTML Attributes\n\nAll other props will be forwarded through to the `<a>` or `<button>` element. EG: `id`, `target`, `aria-*`.",
  "name": "DIG.Button",
  "tags": {
    "dig": ""
  }
}

'''
'''--- src/DIG/Checkbox.metadata.json ---
{
  "description": "A checkbox built with the Radix primitive: https://www.radix-ui.com/docs/primitives/components/checkbox\n\n### Example\n\n```jsx\n<Widget\n  src=\"near/widget/DIG.Checkbox\"\n  props={{ id: \"checkbox-item\", label: \"Accept terms and conditions\" }}\n/>\n```\n\n### Props\n\n`id` - associates checkbox with label (`string`).\n\n`label` - text for checkbox (`string`).\n\nThis component also accepts all `Checkbox.Root` props as outlined in the Radix documentation.\n",
  "name": "DIG.Checkbox",
  "tags": {
    "dig": ""
  }
}

'''
'''--- src/DIG/Chip.metadata.json ---
{
  "description": "A fully featured chip component that can act as a <button> or <a> tag.\n\n### Example\n\n```jsx\n  <Widget src=\"near/widget/DIG.Chip\" props={{ label: 'Click Me' }} />\n```\n\n### Props\n\n`active`\n- type: bool\n- default: `false`\n- Uses the active style variant if true.\n\n`disabled`\n- type: bool\n\n`href`\n- type: string\n- If a value is passed, the component will render an <a> tag instead of a <button>\n- All valid HTML props for <a> tags will be forwarded along to the element.\n\n`iconLeft`\n- type: string (CSS Class)\n- example: \"ph-bold ph-anchor-simple\"\n- https://phosphoricons.com/\n- Adds an icon to the left of the label\n\n`iconRight`\n- type: string (CSS Class)\n- example: \"ph-bold ph-anchor-simple\"\n- https://phosphoricons.com/\n- Adds an icon to the right of the label\n\n`label`\n- type: string\n- required\n- Adds visible text to chip.\n\n`onClick`\n- type: function\n- Other DOM events like `onMouseDown` are also supported.\n\n`type`\n- type: string\n- values: native HTML button type values (\"button\", \"submit\")\n- Ignored if href prop is passed\n\n### HTML Attributes\n\nAll other props will be forwarded through to the <a> or <button> element. EG: id, target, aria-*.",
  "name": "DIG.Chip",
  "tags": {
    "dig": ""
  }
}

'''
'''--- src/DIG/Dialog.metadata.json ---
{
  "description": "This Dialog is built with the Radix primitive: https://www.radix-ui.com/primitives/docs/components/dialog\n\nExample:\n\n```jsx\nState.init({\n  dialogIsOpen: false,\n});\n\nfunction handleCancelFunction() {\n  console.log(\"cancel\");\n}\n\nfunction handleConfirmFunction() {\n  console.log(\"confirm\");\n}\n\nreturn (\n  <>\n    <Widget\n      src=\"near/widget/DIG.Button\"\n      props={{\n        label: \"Open Dialog\",\n        onClick: () => State.update({ dialogIsOpen: true }),\n      }}\n    />\n\n    <Widget\n      src=\"near/widget/DIG.Dialog\"\n      props={{\n        type: \"alert\",\n        title: \"Header\",\n        description: \"Some description\",\n        onCancel: handleCancelFunction,\n        onConfirm: handleConfirmFunction,\n        cancelButtonText: \"Cancel\",\n        confirmButtonText: \"Confirm\",\n        open: state.dialogIsOpen,\n        onOpenChange: (value) => State.update({ dialogIsOpen: value }),\n      }}\n    />\n  </>\n);\n```\n\n### Props\n\n`type`\n\n- type: `string` (variants: `\"alert\"` or `\"dialog\"`)\n- `\"alert\"` - https://www.radix-ui.com/primitives/docs/components/alert-dialog\n- `\"dialog\"` - https://www.radix-ui.com/primitives/docs/components/dialog\n- Defines type of Dialog.\n\n`title`\n\n- type: `string`\n- Title of Dialog.\n\n`description`\n\n- type: `string`\n- Description of Dialog.\n\n`content`\n\n- type: `string` or `JSX`\n- Add additional information to your Dialog or even specify your own `title`, `description`...\n\n`actionButtons`\n\n- type: `JSX`\n- A custom action buttons section for more control on Dialog.\n- _note:_ `onCancel`, `onConfirm`, `cancelButtonText`, `confirmButtonText`, `cancelButton`, `confirmButton` - all this properties will be ignored. Don't forget to pass event handlers to new buttons.\n\n`onCancel`\n\n- type: `function`\n- Event handler called when the user clicks on cancel button.\n\n`onConfirm`\n\n- type: `function`\n- Event handler called when the user clicks on confirm button.\n\n`cancelButtonText`\n\n- type: `string`\n- Label on cancel button.\n\n`confirmButtonText`\n\n- type: `string`\n- Label on confirm button.\n\n`cancelButton`\n\n- type: `JSX`\n- A custom button that closes the dialog.\n- Overrides `cancelButtonText`.\n- _note:_ pass `onCancel` event handler to specify custom action on cancel.\n\n`confirmButton`\n\n- type: `JSX`\n- A custom button that closes the dialog.\n- Overrides `confirmButtonText`.\n- _note:_ pass `onConfirm` event handler to specify custom action on cancel.\n\n`trigger`\n\n- type: `JSX`\n- An optional trigger element that will open the dialog.\n\n`contentStyles`\n\n- type: `object`\n- styling options for Dialog.Content.\n\n`actionStyles`\n\n- type: `object`\n- styling options for Dialog action buttons.\n\n`overlayColor`\n\n-type: `string`\n- Specify a color for layer that covers the inert portion of the view when the dialog is open.\n\n`overlayBlur`\n\n- type: `string`\n- Similar to `overlayColor`. Specifies blur.\n\n`enableCloseButton`\n\n- type: `boolean`\n- Enable or disable a close Dialog button (`X`).\n- _note:_ `false` by default. If `type = \"dialog\"` - `true`.\n\nThis component also accepts all `Alert.Dialog` or `Dialog` (depends on selected `type`) props as outlined in the Radix documentation.\n",
  "name": "DIG.Dialog",
  "tags": {
    "dig": ""
  }
}

'''
'''--- src/DIG/DropdownMenu.metadata.json ---
{
  "description": "This dropdown menu is built with the Radix primitive: https://www.radix-ui.com/primitives/docs/components/dropdown-menu\n\n### Example\n\n```jsx\n<Widget\n  src=\"near/widget/DIG.DropdownMenu\"\n  props={{\n    trigger: (\n      <Widget src=\"near/widget/DIG.Button\" props={{ label: \"Open Menu\" }} />\n    ),\n    header: \"Dropdown header\",\n    items: [\n      {\n        name: \"Profile\",\n        iconLeft: \"ph ph-user-circle\",\n        iconRight: \"ph ph-user-focus\",\n      },\n      {\n        subHeader: \"Sub header here\",\n        name: \"Settings\",\n      },\n      {\n        name: \"Groups\",\n        iconLeft: \"ph ph-user-circle\",\n        subMenuProps: {\n          items: [\n            {\n              header: \"Section header without divider\",\n              asSection: true,\n              noDivider: true,\n              items: [\n                {\n                  name: \"Section name 1\",\n                },\n                {\n                  name: \"Section name 2\",\n                },\n              ],\n            },\n            {\n              name: \"Nested Profile\",\n              iconLeft: \"ph ph-user-circle\",\n              iconRight: \"ph ph-user-focus\",\n            },\n            {\n              name: \"Nested Groups Nested Groups\",\n              subMenuProps: {\n                header: \"My double nested Account\",\n                items: [\n                  {\n                    name: \"Menu item as link\",\n                    href: \"near.org\",\n                    target: \"_blank\",\n                    iconRight: \"ph ph-link\",\n                  },\n                  {\n                    header: \"Section header 2\",\n                    asSection: true,\n                    items: [\n                      {\n                        name: \"Section name 1\",\n                      },\n                      {\n                        name: \"Section name 2\",\n                      },\n                    ],\n                  },\n                  {\n                    header: \"Section header 3\",\n                    asSection: true,\n                    items: [\n                      {\n                        name: \"Section name 1\",\n                      },\n                    ],\n                  },\n                  {\n                    name: \"Double Nested Groups\",\n                  },\n                  {\n                    name: \"Double Nested Settings\",\n                  },\n                ],\n              },\n            },\n            {\n              name: \"Nested Settings\",\n            },\n          ],\n        },\n      },\n    ],\n  }}\n/>\n```\n\n### Props\n\n`trigger`\n- type: `JSX`\n- `required`\n- Renders the element that will display the dropdown menu when clicked. This element will be wrapped with a `<span>` styled with `display: inline-block;`.\n\n`header`\n- type: `string`\n- Adds title with divider line.\n\n`subHeader`\n- type: `string`\n- Same as `header` but without divider.\n\n`items`\n- type: `array`\n- `required`\n- An array of objects defining each menu item with props\n\n`items.name`\n- type: `string`\n- `required`\n- Dropdown menu text\n\n`items.onSelect`\n- type: `function`\n- Event handler called when the user selects an item (via mouse or keyboard). Calling `event.preventDefault` in this handler will prevent the dropdown menu from closing when selecting that item.\n\n`items.disabled`\n- type: `boolean`\n- When `true`, prevents the user from interacting with the item.\n\n`items.href`\n- type: `string`\n- Converts menu item to link.\n- example:\n```jsx\n// ...\nitems: [\n  {\n    name: \"Link item text\",\n    href: \"https://near.org\",\n  },\n// ... other items\n]\n```\n\n`items.target`\n- type: `string`. Relates to `items.href`\n- Defines `target` for link\n\n`items.iconLeft`\n- type: `string` (CSS Class)\n- example: \"ph-bold ph-anchor-simple\"\n- https://phosphoricons.com\n- Adds an icon inside the left of the menu item\n\n`items.iconRight`\n- type: `string` (CSS Class)\n- example: \"ph-bold ph-anchor-simple\"\n- https://phosphoricons.com\n- Adds an icon inside the right of the menu item\n\n`items.asSection`\n- type: `boolean`\n- Defines given `items` as section and adds divider at the end of section.\n\n`items.noDivider `\n- type: `boolean`\n- Controls section divider.\n\n`items.subMenuProps`\n- type: `object`\n- Defines submenu for `items.name`. Object structure are the same as component props.\n\nThis component also accepts all `DropdownMenu.Root` props as outlined in the Radix documentation.",
  "name": "DIG.DropdownMenu",
  "tags": {
    "dig": ""
  }
}

'''
'''--- src/DIG/Input.metadata.json ---
{
  "description": "A text input component.\n\n### Example\n\n```jsx\nState.init({\n  myValue: \"\",\n});\n\nreturn (\n  <Widget\n    src=\"near/widget/DIG.Input\"\n    props={{\n      assistiveText: \"My assistive text\",\n      label: \"My Label\",\n      iconLeft: \"ph-bold ph-pizza\",\n      placeholder: \"Placeholder...\",\n      onInput: (e) => State.update({ myValue: e.target.value }),\n      value: state.myValue,\n    }}\n  />\n);\n\n```\n\n### Props\n\n`assistiveText`\n- type: string\n- Adds assistive text to the bottom of the input. Useful for info, success, and error messages.\n\n`disabled`\n- type: boolean\n- Disables the input\n\n`iconLeft`\n- type: string (CSS Class)\n- example: `\"ph-bold ph-anchor-simple\"`\n- https://phosphoricons.com\n- Adds an icon inside the left of the input\n\n`iconRight`\n- type: string (CSS Class)\n- example: `\"ph-bold ph-anchor-simple\"`\n- https://phosphoricons.com\n- Adds an icon inside the right of the input\n\n`invalid`\n- type: boolean\n- Renders input with error variant\n\n`label`\n- type: string\n- Renders label above input\n\n`onInput`\n- type: function\n- Other DOM events like `onKeyDown` are also supported.\n\n`valid`\n- type: boolean\n- Renders input with success variant\n\n### HTML Attributes\n\nAll other props will be forwarded through to the `<input>` element. EG: `type`, `value`, `placeholder`.",
  "name": "DIG.Input",
  "tags": {
    "dig": ""
  }
}

'''
'''--- src/DIG/InputSearch.metadata.json ---
{
  "description": "An input component for typing a search query.\n\n### Example\n\n```jsx\nreturn (\n  <Widget\n    src=\"near/widget/DIG.InputSearch\"\n    props={{\n      onQueryChange: (query) => console.log(query),\n    }}\n  />\n);\n```\n\n### Props\n\n`assistiveText`\n\n- type: string\n- Adds assistive text to the bottom of the input. Useful for info, success, and error messages.\n\n`debounceDelay`\n\n- type: number\n- default: 300\n- Determines debounce delay for `onQueryChange()` in milliseconds\n\n`disabled`\n\n- type: boolean\n- Disables the input\n\n`invalid`\n\n- type: boolean\n- Renders input with error variant\n\n`label`\n\n- type: string\n- Renders label above input\n\n`onInput`\n\n- type: function\n- Non-debounced handler that returns native input event \n\n`onQueryChange`\n\n- type: function\n- Debounced handler that returns search query whenever input changes\n\n### HTML Attributes\n\nAll other props will be forwarded through to the `<input>` element. EG: `placeholder`.",
  "name": "DIG.InputSearch",
  "tags": {
    "dig": ""
  }
}

'''
'''--- src/DIG/InputSelect.metadata.json ---
{
  "description": "A select input component built with the Radix primitive: https://www.radix-ui.com/docs/primitives/components/select\n\n### Example\n\n```jsx\nState.init({\n  myValue: \"c\",\n});\n\nreturn (\n  <Widget\n    src=\"near/widget/DIG.InputSelect\"\n    props={{\n      assistiveText: \"My assistive text\",\n      groups: [\n        {\n          label: \"Group One\",\n          items: [\n            {\n              label: \"Option A\",\n              value: \"a\",\n            },\n            {\n              label: \"Option B\",\n              value: \"b\",\n              disabled: true,\n            },\n          ],\n        },\n        {\n          label: \"Group Two\",\n          items: [\n            {\n              label: \"Option C\",\n              value: \"c\",\n            },\n            {\n              label: \"Option D\",\n              value: \"d\",\n            },\n          ],\n        },\n      ],\n      label: \"My Label\",\n      placeholder: \"Placeholder...\",\n      rootProps: {\n        value: state.myValue,\n        onValueChange: (value) => {\n          State.update({ myValue: value });\n        },\n      },\n    }}\n  />\n);\n```\n\n### Props\n\n`assistiveText`\n- type: string\n- Adds assistive text to the bottom of the input. Useful for info, success, and error messages.\n\n`contentProps`\n- type: object\n- Radix `Content` props: https://www.radix-ui.com/docs/primitives/components/select#content\n\n`disabled`\n- type: boolean\n- Disables the input\n\n`groups`\n- type: array of objects\n- `group.label`: optional string to render header text\n- `group.items`: array of objects\n- `group.items.disabled`: boolean to disable item\n- `group.items.label`: string to render display text\n- `group.items.value`: string to track internal value\n\n`invalid`\n- type: boolean\n- Renders input with error variant\n\n`label`\n- type: string\n- Renders label above input\n\n`rootProps`\n- type: object\n- Radix `Root` props: https://www.radix-ui.com/docs/primitives/components/select#root\n\n`valid`\n- type: boolean\n- Renders input with success variant\n\n`value`\n- type: string\n- Current input value (should match a corresponding `group.items.value`)\n\n### HTML Attributes\n\nAll other props will be forwarded through to the `<input>` element. EG: `placeholder`.",
  "name": "DIG.InputSelect",
  "tags": {
    "dig": ""
  }
}

'''
'''--- src/DIG/InputTags.metadata.json ---
{
  "description": "An input component that handles adding and removing tags.\n\n### Example\n\n```jsx\nState.init({\n  myTags: [\"food\", \"watermelon\"],\n});\n\nreturn (\n  <Widget\n    src=\"near/widget/DIG.InputTags\"\n    props={{\n      assistiveText: \"My assistive text\",\n      label: \"My Label\",\n      placeholder: \"Placeholder...\",\n      tags: state.myTags,\n      onTagsChange: (value) => State.update({ myTags: value }),\n    }}\n  />\n);\n```\n\n### Props\n\n`assistiveText`\n- type: string\n- Adds assistive text to the bottom of the input. Useful for info, success, and error messages.\n\n`disabled`\n- type: boolean\n- Disables the input\n\n`invalid`\n- type: boolean\n- Renders input with error variant\n\n`label`\n- type: string\n- Renders label above input\n\n`onTagsChange`\n- type: function\n- Returns updated array of strings whenever a tag is added or removed\n\n`tags`\n- type: array of strings\n- All string values should be unique\n\n`valid`\n- type: boolean\n- Renders input with success variant\n\n### HTML Attributes\n\nAll other props will be forwarded through to the `<input>` element. EG: `placeholder`.",
  "name": "DIG.InputTags",
  "tags": {
    "dig": ""
  }
}

'''
'''--- src/DIG/InputTextarea.metadata.json ---
{
  "description": "A textarea input component.\n\n### Example\n\n```jsx\nState.init({\n  myValue: \"\",\n});\n\nreturn (\n  <Widget\n    src=\"near/widget/DIG.InputTextarea\"\n    props={{\n      assistiveText: \"My assistive text\",\n      label: \"My Label\",\n      placeholder: \"Placeholder...\",\n      onInput: (e) => State.update({ myValue: e.target.value }),\n      value: state.myValue,\n    }}\n  />\n);\n\n```\n\n### Props\n\n`assistiveText`\n- type: string\n- Adds assistive text to the bottom of the input. Useful for info, success, and error messages.\n\n`disabled`\n- type: boolean\n- Disables the input\n\n`invalid`\n- type: boolean\n- Renders input with error variant\n\n`label`\n- type: string\n- Renders label above input\n\n`minHeight`\n- type: string\n- example: `10rem`\n\n`onInput`\n- type: function\n- Other DOM events like `onKeyDown` are also supported.\n\n`valid`\n- type: boolean\n- Renders input with success variant\n\n`value`\n- type: string\n- Current textarea value\n\n### HTML Attributes\n\nAll other props will be forwarded through to the `<textarea>` element. EG: `placeholder`.",
  "name": "DIG.InputTextarea",
  "tags": {
    "dig": ""
  }
}

'''
'''--- src/DIG/OverviewPage.metadata.json ---
{
  "description": "DIG (Decentralized Interface Guidelines) is a collection of UI components that can be used to quickly build decentralized apps with a consistent look and feel.",
  "name": "DIG.OverviewPage",
  "tags": {
    "app": "",
    "dig": ""
  }
}

'''
'''--- src/DIG/Tabs.metadata.json ---
{
  "description": "This tabs component is built with the Radix primitive: https://www.radix-ui.com/docs/primitives/components/tabs\n\n### Example\n\n```jsx\n<Widget\n  src=\"near/widget/DIG.Tabs\"\n  props={{\n    variant: \"line\",\n    size: \"default\",\n    items: [\n      {\n        name: \"Label 1\",\n        value: \"1\",\n        content: \"Hello 1\",\n        icon: \"ph ph-browser\",\n      },\n      {\n        name: \"Label 2\",\n        value: \"2\",\n        content: \"Hello 2\",\n        count: \"12\",\n        icon: \"ph ph-browser\",\n      },\n      {\n        name: \"Label 3\",\n        value: \"3\",\n        content: \"Hello 3\",\n        disabled: true,\n        icon: \"ph ph-browser\",\n      },\n    ],\n  }}\n/>\n```\n\n### Props\n\n`variant`\n- one of `\"pill\"`, `\"line\"`, `toggle`\n- Default to `\"line\"`\n\n`size`\n- `\"small\"`, `\"default\"`, `\"large\"`\n- Default to `\"default\"`\n\n`items`\n- array of objects defining each tab with it's own content.\n- Each object requires a `value` (unique string), `name` (string) and `content` (string or JSX).\n- Also there is optional parameters:\n  - `icon` - type: string (CSS Class). Example: `\"ph-bold ph-anchor-simple\"`. Adds an icon to the left of the `name`. Accepts classNames from https://phosphoricons.com and https://icons.getbootstrap.com.\n  - `count` - type: string. Adds an counter label to the right of `name`.\n  - `disabled` - type: `boolean`. When `true`, prevents the user from interacting with the tab.\n\n`contentProps`\n- type: `object`.\n- Properties to be passed to content if an item's `content` is a function.  \n\nThis component also accepts all `Tabs.Root` props as outlined in the Radix documentation.",
  "name": "DIG.Tabs",
  "tags": {
    "dig": ""
  }
}

'''
'''--- src/DIG/Theme.metadata.json ---
{
  "description": "This wrapper provides accessible color and font values to all children via CSS variables.\n\n### Props\n\n`children`\n- type: jsx\n",
  "name": "DIG.Theme"
}

'''
'''--- src/DIG/Toast.metadata.json ---
{
  "description": "This toast component is built with Radix primitive: https://www.radix-ui.com/primitives/docs/components/toast\n\n### Example\n\n```jsx\nState.init({ showToast: false });\n\nreturn (\n  <Widget\n    src=\"near/widget/DIG.Toast\"\n    props={{\n      title: \"Title\",\n      description: \"This is the toast description\",\n      type: \"success\",\n      open: state.showToast,\n      onOpenChange: (value) => State.update({ showToast: value }),\n      trigger: (\n        <Widget\n          src=\"near/widget/DIG.Button\"\n          props={{\n            label: \"Show Toast\",\n            onClick: () => State.update({ showToast: true }),\n          }}\n        />\n      ),\n      action: (\n        <Widget\n          src=\"near/widget/DIG.Button\"\n          props={{\n            label: \"Dismiss\",\n            onClick: () => State.update({ showToast: false }),\n          }}\n        />\n      ),\n      providerProps: { duration: 1000 },\n    }}\n  />\n);\n```\n\n### Props\n\n`title`\n- type: `string`.\n- _optional_.\n- An optional title for the toast.\n\n`description`\n- type: `string`.\n- `required`.\n- The toast message.\n\n`type`\n- type: `string`.\n- Specifies toast type. Variants: `\"success\"`, `\"error\"`, `\"info\"`, `\"custom\"`.\n- `\"custom\"` allows to specify it's own `iconClassName` and `iconColor`.\n- example:\n```jsx\n{\n// ...\n  type: \"custom\",\n  iconClassName: \"ph ph-airplane-tilt\",\n  iconColor: \"#c9f8f7\"\n}\n``` \n\n`open`\n- type: `boolean`,\n- `required`.\n- The controlled open state of the dialog. Must be used in conjunction with `onOpenChange`.\n\n`onOpenChange`\n- type: `function`.\n- `required`.\n- Event handler called when the open state of the dialog changes.\n\n`trigger`\n- type: `JSX`.\n- _optional_.\n- Renders the element that will display the toast when clicked. \n\n`action`\n- type: `JSX`.\n- _optional_.\n- An action that is safe to ignore to ensure users are not expected to complete tasks with unexpected side effects as a result of a time limit.\n\n`providerProps`\n- type: `object`.\n- Radix `Toast.Provider` props https://www.radix-ui.com/primitives/docs/components/toast#provider\n\nThis component also accepts all `Toast.Root` props as outlined in the Radix documentation.",
  "name": "DIG.Toast",
  "tags": {
    "dig": ""
  }
}

'''
'''--- src/DIG/Tooltip.metadata.json ---
{
  "description": "A tooltip built with the Radix primitive: https://www.radix-ui.com/docs/primitives/components/tooltip\n\n### Example\n\n```jsx\n<Widget\n  src=\"near/widget/DIG.Tooltip\"\n  props={{\n    content: \"This is my tooltip content.\",\n    trigger: (\n      <Widget src=\"near/widget/DIG.Button\" props={{ label: \"Hover Me\" }} />\n    ),\n  }}\n/>\n```\n\n### Props\n\n`content`\n- type: string or JSX\n- required\n- Content displayed inside the tooltip\n\n`contentProps`\n- type: object\n- optional\n- Radix `Content` props: https://www.radix-ui.com/docs/primitives/components/tooltip#content \n\n`rootProps`\n- type: object\n- optional\n- Radix `Root` props: https://www.radix-ui.com/docs/primitives/components/tooltip#root\n\n`trigger`\n- type: JSX\n- required\n- Renders the element that will display the tooltip when hovered. This element will be wrapped with a `<span>` styled with `display: inline-block;`.\n\n`wrapperStyle`\n- type: object\n- optional\n- Override styles for the `<span>` element wrapping the `trigger`.",
  "name": "DIG.Tooltip",
  "tags": {
    "dig": ""
  }
}

'''
'''--- src/DS/Button.metadata.json ---
{
  "description": "DS.Button has been deprecated in favor of near/widget/DIG.Button",
  "name": "DS.Button (deprecated)"
}

'''
'''--- src/DS/Theme.metadata.json ---
{
  "description": "DS.Theme has been deprecated in favor of near/widget/DIG.Theme",
  "name": "DS.Theme (deprecated)"
}

'''
'''--- src/FastAuth.metadata.json ---
{
  "tags": {
    "coming-soon": ""
  }
}

'''
'''--- src/Onboarding/ComponentCard.metadata.json ---
{
  "description": "This is the example for onboarding users of how to use component with styling, icons and passing props to other components.",
  "name": "Onboarding.ComponentCard",
  "tags": {
    "onboard": ""
  }
}

'''
'''--- src/Onboarding/ComponentCollection.metadata.json ---
{
  "description": "This is the example for onboarding users of how to get on-chain data and display it on the page.",
  "name": "Onboarding.ComponentCollection",
  "tags": {
    "onboard": ""
  }
}

'''
'''--- src/Onboarding/Starter.metadata.json ---
{
  "description": "This is the example for onboarding users of how to use another components. This means that the component won't work until the user edits the component as stated in the comments. This is how it should look like to make it work:\n\n```\nreturn (\n  <>\n    {/* src=\"near/widget/Onboarding.ComponentCard\" to be pasted below */}\n    <Widget src=\"near/widget/Onboarding.ComponentCard\" />\n    <br />\n    {/* src=\"near/widget/Onboarding.ComponentCollection\" to be pasted below */}\n    <Widget src=\"near/widget/Onboarding.ComponentCollection\" />\n  </>\n);\n```",
  "name": "Onboarding.Starter",
  "tags": {
    "onboard": ""
  }
}

'''
'''--- vm.d.ts ---
/**
 * VM provides a convenient API to update the state of the component.
 * More info {@link https://docs.near.org/bos/api/state#state-apis}
 */
declare namespace State {
  /**
   * `State.init` takes an object as an argument and initializes the state of the component with this object. It'll be no-op if the state is already initialized.
   * More info {@link https://docs.near.org/bos/api/state#stateinit}
   * @param state an initial state object for the component.
   */
  function init(state: object): void;

  /**
   * The `State.update` will trigger the state update, and the component will be re-rendered. It also has an optional argument, the object that will be added to the `state` object using `Object.assign`. The state will be initialized with the given object if it's not initialized yet.
   * More info {@link https://docs.near.org/bos/api/state#stateupdate}
   * @param state the state.
   * @param init an optional initial state object.
   */
  function update(state: object, init?: object): void;
}

type BlockIdentity = 'final' | number;
type NearBlockIdentity = BlockIdentity | 'optimistic';
type SocialReturnType = 'History' | 'True' | 'BlockHeight';
type NetworkId = 'mainnet' | 'testnet';

/**
 * @param subscribe (optional) if true, the data will be refreshed every 5 seconds.
 * @param return_deleted (optional) whether to return deleted values (as `null`). Default is `false`.
 */
interface SocialGetOptions {
  subscribe?: boolean;
  return_deleted?: boolean;
}

/**
 * @param subscribe (optional) if `true`, the data will be refreshed every 5 seconds.
 * @param return_type (optional) either `"History"`, `"True"`, or `"BlockHeight"`. If not specified, it will return the `"True"`.
 * @param return_deleted (optional) whether to return deleted values (as `null`). Default is `false`.
 * @param values_only (optional) whether to return only values (don't include objects). Default is `false`.
 */
type SocialKeysOptions = SocialGetOptions & {
  return_type?: SocialReturnType;
  values_only?: boolean;
};

/**
 * @param subscribe (optional) if `true`, the data will be refreshed every 5 seconds.
 * @param accountId (optional) If given, it should either be a string or an array of account IDs to filter values by them. Otherwise, not filters by account Id.
 * @param order (optional) Either `asc` or `desc`. Defaults to `asc`.
 * @param limit (optional) Defaults to `100`. The number of values to return. Index may return more than index values, if the last elements have the same block height.
 * @param from (optional) Defaults to `0` or `Max` depending on order.
 */
interface SocialIndexOptions {
  subscribe?: boolean;
  accountId?: string | string[];
  order?: 'asc' | 'desc';
  limit?: number;
  from?: number | 'Max';
}

/**
 * @param force (optional) whether to overwrite the data.
 * @param onCommit (optional) function to trigger on successful commit. Will pass the data that was written (including `accountID`).
 * @param onCancel (optional) function to trigger if the user cancels the commit.
 */
interface SocialSetOptions {
  force?: boolean;
  onCommit?: VoidFunction;
  onCancel?: VoidFunction;
}

declare namespace Social {
  /**
   * `Social.get` fetches the data from the SocialDB contract by calling get and returns the data. While the data is fetching, the returned value equals to `null`.
   * More info: {@link https://docs.near.org/bos/api/social#socialget}
   * @param patterns the path pattern(s);
   * @param finality (optional) the block height or finality;
   * @param options (optional) the {@link SocialGetOptions | options} object;
   */
  function get(patterns: string | string[], finality?: BlockIdentity, options?: SocialGetOptions): void;

  /**
   * `Social.getr` is just a wrapper helper for {@link Social.get}, it appends `**` to each of the path patterns.
   * More info: {@link https://docs.near.org/bos/api/social#socialgetr}
   * @param patterns the path pattern(s);
   * @param finality (optional) the block height or finality;
   * @param options (optional) the {@link SocialGetOptions | options} object;
   */
  function getr(patterns: string | string[], finality?: BlockIdentity, options?: SocialGetOptions): void;

  /**
   * It calls the SocialDB's `keys` API and returns the data. While the data is fetching, the returned value equals to `null`. The keys contract doesn't unwrap the object, so the returned data is the same as the SocialDB's `keys` API.
   * More info: {@link https://docs.near.org/bos/api/social#socialkeys}
   * @param patterns the path pattern(s);
   * @param finality (optional) the block height or finality;
   * @param options (optional) the {@link SocialGetOptions | options} object;
   */
  function keys(patterns: string | string[], finality?: BlockIdentity, options?: SocialKeysOptions): void;

  /**
   * Returns the array of matched indexed values. Ordered by `blockHeight`.
   * More info: {@link https://docs.near.org/bos/api/social#socialindex}
   * @param action is the `index_type` from the standard, e.g. in the path `index/like` the action is `like`.
   * @param key is the inner indexed value from the standard.
   * @param options the {@link SocialIndexOptions | options} object.
   */
  function index(action: string, key: string, options?: SocialIndexOptions): void;

  /**
   * Takes a `data` object and commits it to SocialDB. It works similarly to the `CommitButton` by spawning the modal window prompt to save data, but it doesn't have to be triggered through the commit button component. It allows you to write more flexible code that relies on async promises and use other events and components. Overall, it enables more flexibility when committing to SocialDB. For example, you can commit when the Enter key is pressed.
   * More info: {@link https://docs.near.org/bos/api/social#socialset}
   * @param data the data object to be committed. Similar to `CommitButton`, it shouldn't start with an account ID.
   * @param options {@link SocialSetOptions | optional} object.
   */
  function set(data: object, options?: SocialSetOptions): void;
}

/**
 * You can access the `context` object to get specific information about the VM instance.
 * More info {@link https://docs.near.org/bos/home#vm-context}
 */
declare namespace context {
  /**
   * @param networkId `mainnet` or `testnet`.
   */
  const networkId: NetworkId;
  const accountId: string;
}

/**
 * VM provides a convenient API to interact with the NEAR blockchain.
 * More info {@link https://docs.near.org/bos/api/near}
 */
declare namespace Near {
  /**
   * The block height (`number`) or finality level to use for the blockchain query (desired block height, or one of the following strings: `optimistic`, `final`)
   * @param blockHeightOrFinality `number`, `optimistic` or `final`.
   */
  function block(blockHeightOrFinality?: NearBlockIdentity): void;

  /**
   * This will conduct a call to a smart contract that will store a message onchain.
   * @param contractName name of the smart contract to call.
   * @param methodName name of the method to call on the smart contract.
   * @param args (optional) arguments to pass to the smart contract method as an object instance.
   * @param gas (optional) maximum amount of gas to be used for the transaction (default 300Tg)
   * @param deposit (optional) amount of NEAR tokens to attach to the call as deposit (in yoctoNEAR units).
   */
  function call(contractName: string, methodName: string, args?: object, gas?: string | number, deposit?: string | number): void;

  /**
   * This will make a view call to a smart contract that will get the message from blockchain.
   * @param contractName name of the smart contract to call.
   * @param methodName name of the method to call on the smart contract.
   * @param args (optional) arguments to pass to the smart contract method as an object instance.
   * @param blockId block ID or finality of the transaction.
   * @param subscribe this feature allows users to subscribe to a query, which automatically refreshes the data for all subscribers every 5 seconds.
   */
  function view(contractName: string, methodName: string, args?: object, blockId?: string, subscribe?: boolean): void;
}

/**
 * The VM implements a clipboard API that works like {@link https://developer.mozilla.org/en-US/docs/Web/API/Clipboard/writeText | Mozilla's Clipboard}, providing write access to the contents of the system clipboard. The Clipboard API can be used to implement cut, copy, and paste features within a web application.
 * More info {@link https://docs.near.org/bos/api/clipboard}
 */
declare namespace clipboard {
  /**
   * Copies the specified text string to the system clipboard.
   * @param text data to be copied to the clipboard.
   */
  function writeText(text: string): void;
}

/**
 * `Storage` object to store data for components that is persistent across refreshes. Simulates `localStorage` access.
 */
declare namespace StorageAPI {
  interface Storage {
    /**
     * `Storage.get` - returns the public value for a given `key` under the given `widgetSrc` or the current component if `widgetSrc` is omitted. Can only read public values.
     * More info {@link https://docs.near.org/bos/api/storage#storageget}
     * @param key a user-defined key.
     * @param widgetSrc (optional) a user-defined component.
     */
    get(key: string, widgetSrc?: string): Promise<string | null>;

    /**
     * `Storage.set` - sets the public value for a given key under the current widget. The value will be public, so other widgets can read it.
     * More info {@link https://docs.near.org/bos/api/storage#storageset}
     * @param key a user-defined key.
     * @param value a user-defined value.
     */
    set(key: string, value: string): Promise<void>;

    /**
     * `Storage.privateGet` - returns the private value for a given key under the current component.
     * @param key a user-defined key under the current component.
     */
    privateGet(key: string): Promise<string | null>;

    /**
     * `Storage.privateSet` - sets the private value for a given key under the current component. The value is private, only the current component can read it.
     * @param key a user-defined key under the current component.
     * @param value a user-defined value
     */
    privateSet(key: string, value: string): Promise<void>;
  }
}

'''