*GitHub Repository "near/near-sdk-as"*

'''--- .eslintrc.js ---
module.exports = {
  root: true,
  parser: "@typescript-eslint/parser",
  plugins: [
    "@typescript-eslint",
  ],
  extends: [
    "eslint:recommended",
    "plugin:@typescript-eslint/eslint-recommended",
    "plugin:@typescript-eslint/recommended",
  ],
  parserOptions: {
    ecmaVersion: 2020,
    sourceType: "module",
    ecmaFeatures: {}
  },

  // === General rules =========================================================

  rules: {
    // Omitted semicolons are hugely popular, yet within the compiler it makes
    // sense to be better safe than sorry.
    "semi": "error",

    // Our code bases uses 2 spaces for indentation, and we enforce it here so
    // files don't mix spaces, tabs or different indentation levels.
    "indent": ["error", 2, {
      "SwitchCase": 1,
      "VariableDeclarator": "first",
      "offsetTernaryExpressions": true,
      "ignoredNodes": [ // FIXME: something's odd here
        "ConditionalExpression > *",
        "ConditionalExpression > * > *",
        "ConditionalExpression > * > * > *"
      ]
    }],

    // This is mostly visual style, making comments look uniform.
    "spaced-comment": ["error", "always", {
      "markers": ["/"],   // triple-slash
      "exceptions": ["/"] // all slashes
    }],

    // This tends to be annoying as it encourages developers to make everything
    // that is never reassigned a 'const', sometimes semantically incorrect so,
    // typically leading to huge diffs in follow-up PRs modifying affected code.
    "prefer-const": "off",

    // It is perfectly fine to declare top-level variables with `var`, yet this
    // rule doesn't provide configuration options that would help.
    "no-var": "off",

    // Quite often, dealing with multiple related cases at once or otherwise
    // falling through is exactly the point of using a switch.
    "no-fallthrough": "off",

    // Typical false-positives here are `do { ... } while (true)` statements or
    // similar, but the only option provided here is not checking any loops.
    "no-constant-condition": ["error", { checkLoops: false }],

    // Functions are nested in blocks occasionally, and there haven't been any
    // problems with this so far, so turning the check off.
    "no-inner-declarations": "off",

    // Quite common in scenarios where an iteration starts at `current = this`.
    "@typescript-eslint/no-this-alias": "off",

    // Disabled here, but enabled again for JavaScript files.
    "no-unused-vars": "off",

    // Disabled here, but enabled again for TypeScript files.
    "@typescript-eslint/no-unused-vars": "off"
  },
  overrides: [

    // === TypeScript rules ====================================================

    {
      files: [
        "**/assembly/**/*.ts"
      ],
      rules: {
        // Enforcing to remove function parameters on stubs makes code less
        // maintainable, so we instead allow unused function parameters.
        "@typescript-eslint/no-unused-vars": [
          "warn", {
            "vars": "local",
            "varsIgnorePattern": "^_|^[A-Z](?:From|To)?$", // ignore type params
            "args": "none",
            "ignoreRestSiblings": false
          }
        ],

        // Namespaces are quite useful in AssemblyScript
        "@typescript-eslint/no-namespace": "off",

        // There is actually codegen difference here
        "@typescript-eslint/no-array-constructor": "off",

        // Sometimes it can't be avoided to add a @ts-ignore
        "@typescript-eslint/ban-ts-comment": "off",

        // Utilized to achieve portability in some cases
        "@typescript-eslint/no-non-null-assertion": "off",
      }
    },

    // === Compiler rules (extends AssemblyScript rules) =======================

    {
      files: [
        "**/assembly/**/*.ts"
      ],
      rules: {
        // There is an actual codegen difference here - TODO: revisit
        "no-cond-assign": "off",

        // Not all types can be omitted in AS yet - TODO: revisit
        "@typescript-eslint/no-inferrable-types": "off",

        // Used rarely to reference internals that are not user-visible
        "@typescript-eslint/triple-slash-reference": "off",

        // The compiler has its own `Function` class for example
        "no-shadow-restricted-names": "off",
        "@typescript-eslint/ban-types": "off"
      }
    },

    // === Standard Library rules (extends AssemblyScript rules) ===============

    {
      files: [
        "**/assembly/**/*.ts"
      ],
      rules: {
        // We are implementing with --noLib, so we shadow all the time
        "no-shadow-restricted-names": "off",

        // Similarly, sometimes we need the return type to be String, not string
        "@typescript-eslint/ban-types": "off"
      }
    },

    // === Standard Definition rules (extends TypeScript rules) ================

    {
      files: [
        "**/assembly/**/*.d.ts"
      ],
      rules: {
        // Often required to achieve compatibility with TypeScript
        "@typescript-eslint/no-explicit-any": "off",

        // Interfaces can be stubs here, i.e. not yet fully implemented
        "@typescript-eslint/no-empty-interface": "off",

        // Definitions make use of `object` to model rather unusual constraints
        "@typescript-eslint/ban-types": "off"
      }
    },

    

    // === Test rules (extends TypeScript rules) ===============================

    {
      files: [
        "**/assembly/__tests__/**/*.ts"
      ],
      rules: {
        // Tests typically include unusual code patterns on purpose. This is
        // very likely not an extensive list, but covers what's there so far.
        "no-empty": "off",
        "no-cond-assign": "off",
        "no-compare-neg-zero": "off",
        "no-inner-declarations": "off",
        "no-constant-condition": "off",
        "use-isnan": "off",
        "@typescript-eslint/no-namespace": "off",
        "@typescript-eslint/no-unused-vars": "off",
        "@typescript-eslint/no-empty-function": "off",
        "@typescript-eslint/no-non-null-assertion": "off",
        "@typescript-eslint/no-extra-semi": "off",
        "@typescript-eslint/no-inferrable-types": "off",
        "@typescript-eslint/ban-types": "off",
        "@typescript-eslint/triple-slash-reference": "off",
        "@typescript-eslint/ban-ts-comment": "off",
        "@typescript-eslint/no-extra-non-null-assertion": "off",
        "@typescript-eslint/no-empty-interface": "off"
      }
    },
  ]
};

'''
'''--- bindgen/asconfig.js ---
const compile = require("asbuild").main;

compile(["assembly/__tests__/test.ts", "--target", "debug", "--wat"], (err) => {
  if (err) {
    throw err;
  }
  
});

// Tests where the compiler should failed to compile
function buildFail(msg, args) {
  var failed = false;
  try {
    compile(...(args || []), {}, (err) => {
      if (err) {
        throw err;
      }
    });
  } catch (err) {
    failed = true;
  } finally {
    if (!failed) {
      throw new Error(msg);
    }
  }
}
buildFail("Setting a string to be a an int should fail.", [
  "./assembly/__tests__/bindgen/bad.ts",
  "--verbose",
]);
buildFail("Using ERROR in generic function should fail if wrong type passed.", [
  "./assembly/__tests__/bindgen/badType.ts",
  "verbose",
]);

console.log("PASSED");

'''
'''--- bindgen/compiler.js ---
const asb = require("asbuild").main;

module.exports.compile = function (inputFile, outputFile, args, options, cb) {
  if (inputFile == undefined) {
    throw new Error("input file required.");
  }
  if (outputFile == undefined) {
    throw new Error("output file required.");
  }
  if (typeof args === "function") {
    cb = args;
    args = [];
    options = null
  } else if (typeof options === "function") {
    cb = options;
  } else {
    cb = (err) => {
      if (err != null) {
        throw new Error(err);
      }
    };
  }
  if (options == null || typeof options == "function") {
    options = [];
  } else {
    res = [];
    for (let name of Object.getOwnPropertyNames(options)) {
      res.push("--" + name);
      if (typeof options[name] === "string") {
        res.push(options[name]);
      }
    }
    options = res;
  }
  args.unshift("--")
  args.unshift(...options);
  console.error(
    "\x1b[31m",
    `asconfig.js is deprecated use \`asb\`to build files.  NOTE: output now in ./build/release/`,
    "\x1b[0m"
  );
  asb([inputFile, ...args], cb)

}
'''
'''--- bindgen/dist/JSONBuilder.js ---
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.JSONBindingsBuilder = exports.isEntry = void 0;
const as_1 = require("visitor-as/as");
const visitor_as_1 = require("visitor-as");
const utils_1 = require("./utils");
const NEAR_DECORATOR = "nearBindgen";
const WRAPPER_PREFIX = "__wrapper_";
function returnsVoid(node) {
    return utils_1.toString(node.signature.returnType) === "void";
}
function numOfParameters(node) {
    return node.signature.parameters.length;
}
function hasNearDecorator(stmt) {
    return ((isEntry(stmt) ||
        stmt.text.includes("@nearfile") ||
        stmt.statements.some((s) => s instanceof as_1.DeclarationStatement &&
            visitor_as_1.utils.hasDecorator(s, NEAR_DECORATOR))) &&
        !stmt.text.includes("@notNearfile"));
}
function isEntry(source) {
    return source.range.source.sourceKind == as_1.SourceKind.USER_ENTRY;
}
exports.isEntry = isEntry;
function isClass(type) {
    return type.kind == as_1.NodeKind.CLASSDECLARATION;
}
function isField(mem) {
    return mem.kind == as_1.NodeKind.FIELDDECLARATION;
}
function isStatic(mem) {
    return mem.is(as_1.CommonFlags.STATIC);
}
function isEncodable(mem) {
    return isField(mem) && !isStatic(mem);
}
function isPayable(func) {
    return (func.decorators != null &&
        func.decorators.some((s) => utils_1.toString(s.name) != "payable"));
}
function createDecodeStatements(_class) {
    return _class.members
        .filter(isEncodable)
        .map((field) => {
        const name = utils_1.toString(field.name);
        return (createDecodeStatement(field, `this.${name} = obj.has("${name}") ? `) +
            `: ${field.initializer != null
                ? utils_1.toString(field.initializer)
                : `this.${name}`};`);
    });
}
function createDecodeStatement(field, setterPrefix = "") {
    let T = utils_1.toString(field.type);
    let name = utils_1.toString(field.name);
    return `${setterPrefix}decode<${T}, JSON.Obj>(obj, "${name}")`;
}
function createEncodeStatements(_class) {
    return _class.members
        .filter(isEncodable)
        .map((field) => {
        let T = utils_1.toString(field.type);
        let name = utils_1.toString(field.name);
        return `encode<${T}, JSONEncoder>(this.${name}, "${name}", encoder);`;
    });
}
// TODO: Extract this into separate module, preferrable pluggable
class JSONBindingsBuilder extends visitor_as_1.BaseVisitor {
    constructor() {
        super(...arguments);
        this.sb = [];
        this.exportedClasses = new Map();
        this.wrappedFuncs = new Set();
    }
    static build(source) {
        return new JSONBindingsBuilder().build(source);
    }
    static nearFiles(sources) {
        return sources.filter(hasNearDecorator);
    }
    static checkTestBuild(sources) {
        this.isTest = sources.some((s) => s.normalizedPath.includes(".spec."));
    }
    visitClassDeclaration(node) {
        if (!this.exportedClasses.has(utils_1.toString(node.name))) {
            this.exportedClasses.set(utils_1.toString(node.name), node);
        }
        super.visitClassDeclaration(node);
    }
    needsWrapper(node) {
        let isExport = node.is(as_1.CommonFlags.EXPORT);
        let alreadyWrapped = this.wrappedFuncs.has(utils_1.toString(node.name));
        let noInputOrOutput = numOfParameters(node) == 0 && returnsVoid(node);
        if (!isExport ||
            alreadyWrapped ||
            noInputOrOutput ||
            JSONBindingsBuilder.isTest)
            return false;
        return isEntry(node) || visitor_as_1.utils.hasDecorator(node, NEAR_DECORATOR);
    }
    visitFunctionDeclaration(node) {
        if (!this.needsWrapper(node)) {
            if ((isEntry(node) || visitor_as_1.utils.hasDecorator(node, NEAR_DECORATOR)) &&
                !this.wrappedFuncs.has(utils_1.toString(node.name)) &&
                node.is(as_1.CommonFlags.EXPORT)) {
                this.sb.push(this.camelCaseToSnakeCaseExport(utils_1.toString(node.name), ""));
                this.wrappedFuncs.add(utils_1.toString(node.name));
            }
            super.visitFunctionDeclaration(node);
            return;
        }
        this.generateWrapperFunction(node);
        // Change function to not be an export
        node.flags = node.flags ^ as_1.CommonFlags.EXPORT;
        this.wrappedFuncs.add(utils_1.toString(node.name));
        super.visit(node);
    }
    camelCaseToSnakeCaseExport(name, prefix = WRAPPER_PREFIX) {
        let s = utils_1.makeSnakeCase(name);
        if (s.normalize() === name.normalize()) {
            return "";
        }
        return `export { ${prefix + name} as ${s} }`;
    }
    /*
    Create a wrapper function that will be export in the function's place.
    */
    generateWrapperFunction(func) {
        let signature = func.signature;
        let params = signature.parameters;
        let returnType = signature.returnType;
        let returnTypeName = utils_1.toString(returnType)
            .split("|")
            .map((name) => name.trim())
            .filter((name) => name !== "null")
            .join("|");
        let hasNull = utils_1.toString(returnType).includes("null");
        let name = func.name.text;
        if (func.decorators && func.decorators.length > 0) {
            this.sb.push(func.decorators.map((decorator) => utils_1.toString(decorator)).join("\n"));
        }
        this.sb.push(`function __wrapper_${name}(): void {`);
        if (params.length > 0) {
            this.sb.push(`  const obj = getInput();`);
        }
        if (utils_1.toString(returnType) !== "void") {
            this.sb.push(`  let result: ${utils_1.toString(returnType)} = ${name}(`);
        }
        else {
            this.sb.push(`  ${name}(`);
        }
        if (params.length > 0) {
            this.sb[this.sb.length - 1] += params
                .map((param) => {
                let name = utils_1.toString(param.name);
                let type = utils_1.toString(param.type);
                let res = `obj.has('${name}') ?
             ${createDecodeStatement(param)} : ${param.initializer
                    ? utils_1.toString(param.initializer)
                    : `requireParameter<${type}>("${name}")`}`;
                return res;
            })
                .join(",\n    ");
        }
        this.sb[this.sb.length - 1] += ");";
        if (utils_1.toString(returnType) !== "void") {
            this.sb.push(`  const val = encode<${returnTypeName}>(${hasNull ? `changetype<${returnTypeName}>(result)` : "result"});
  value_return(val.byteLength, val.dataStart);`);
        }
        this.sb.push(`}
export { ${WRAPPER_PREFIX + name} as ${name} }
${this.camelCaseToSnakeCaseExport(name)}
`);
    }
    typeName(type) {
        if (!isClass(type)) {
            return utils_1.toString(type);
        }
        type = type;
        let className = utils_1.toString(type.name);
        if (type.isGeneric) {
            className += "<" + type.typeParameters.map(utils_1.toString).join(", ") + ">";
        }
        return className;
    }
    build(source) {
        const isNearFile = source.text.includes("@nearfile");
        this.sb = [];
        this.visit(source);
        let sourceText = source.statements.map((stmt) => {
            let str;
            if (isClass(stmt) &&
                (visitor_as_1.utils.hasDecorator(stmt, NEAR_DECORATOR) ||
                    isNearFile)) {
                let _class = stmt;
                let fields = _class.members
                    .filter(isField)
                    .map((field) => field);
                if (fields.some((field) => field.type == null)) {
                    throw new Error("All Fields must have explicit type declaration.");
                }
                fields.forEach((field) => {
                    if (field.initializer == null) {
                        field.initializer = utils_1.SimpleParser.parseExpression(`defaultValue<${utils_1.toString(field.type)}>())`);
                    }
                });
                str = utils_1.toString(stmt);
                str = str.slice(0, str.lastIndexOf("}"));
                let className = this.typeName(_class);
                if (!visitor_as_1.utils.hasDecorator(stmt, NEAR_DECORATOR)) {
                    console.error("\x1b[31m", `@nearfile is deprecated use @${NEAR_DECORATOR} decorator on ${className}`, "\x1b[0m");
                }
                str += `
  decode<_V = Uint8Array>(buf: _V): ${className} {
    let json: JSON.Obj;
    if (buf instanceof Uint8Array) {
      json = JSON.parse(buf);
    } else {
      assert(buf instanceof JSON.Obj, "argument must be Uint8Array or Json Object");
      json = <JSON.Obj> buf;
    }
    return this._decode(json);
  }

  static decode(buf: Uint8Array): ${className} {
    return decode<${className}>(buf);
  }

  private _decode(obj: JSON.Obj): ${className} {
    ${createDecodeStatements(_class).join("\n    ")}
    return this;
  }

  _encode(name: string | null = "", _encoder: JSONEncoder | null = null): JSONEncoder {
    let encoder = _encoder == null ? new JSONEncoder() : _encoder;
    encoder.pushObject(name);
    ${createEncodeStatements(_class).join("\n    ")}
    encoder.popObject();
    return encoder;
  }
  encode(): Uint8Array {
    return this._encode().serialize();
  }

  serialize(): Uint8Array {
    return this.encode();
  }

  toJSON(): string {
    return this._encode().toString();
  }
}`;
            }
            else {
                str = utils_1.toString(stmt);
            }
            return str;
        });
        return sourceText.concat(this.sb).join("\n");
    }
}
exports.JSONBindingsBuilder = JSONBindingsBuilder;
JSONBindingsBuilder.isTest = false;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSlNPTkJ1aWxkZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvSlNPTkJ1aWxkZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsc0NBWXVCO0FBQ3ZCLDJDQUFnRDtBQUNoRCxtQ0FBZ0U7QUFFaEUsTUFBTSxjQUFjLEdBQUcsYUFBYSxDQUFDO0FBQ3JDLE1BQU0sY0FBYyxHQUFHLFlBQVksQ0FBQztBQUVwQyxTQUFTLFdBQVcsQ0FBQyxJQUF5QjtJQUM1QyxPQUFPLGdCQUFRLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxVQUFVLENBQUMsS0FBSyxNQUFNLENBQUM7QUFDeEQsQ0FBQztBQUVELFNBQVMsZUFBZSxDQUFDLElBQXlCO0lBQ2hELE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDO0FBQzFDLENBQUM7QUFFRCxTQUFTLGdCQUFnQixDQUFDLElBQVk7SUFDcEMsT0FBTyxDQUNMLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQztRQUNaLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQztRQUMvQixJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FDbEIsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUNKLENBQUMsWUFBWSx5QkFBb0I7WUFDakMsa0JBQUssQ0FBQyxZQUFZLENBQUMsQ0FBQyxFQUFFLGNBQWMsQ0FBQyxDQUN4QyxDQUFDO1FBQ0osQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxjQUFjLENBQUMsQ0FDcEMsQ0FBQztBQUNKLENBQUM7QUFFRCxTQUFnQixPQUFPLENBQUMsTUFBcUI7SUFDM0MsT0FBTyxNQUFNLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxVQUFVLElBQUksZUFBVSxDQUFDLFVBQVUsQ0FBQztBQUNqRSxDQUFDO0FBRkQsMEJBRUM7QUFFRCxTQUFTLE9BQU8sQ0FBQyxJQUFVO0lBQ3pCLE9BQU8sSUFBSSxDQUFDLElBQUks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QUFjLENBQUMsRUFBRTtvQkFDL0QsT0FBTyxDQUFDLEtBQUssQ0FDWCxVQUFVLEVBQ1YsZ0NBQWdDLGNBQWMsaUJBQWlCLFNBQVMsRUFBRSxFQUMxRSxTQUFTLENBQ1YsQ0FBQztpQkFDSDtnQkFDRCxHQUFHLElBQUk7c0NBQ3VCLFNBQVM7Ozs7Ozs7Ozs7O29DQVdYLFNBQVM7b0JBQ3pCLFNBQVM7OztvQ0FHTyxTQUFTO01BQ3ZDLHNCQUFzQixDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUM7Ozs7Ozs7TUFPN0Msc0JBQXNCLENBQUMsTUFBTSxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7O0VBZWpELENBQUM7YUFDSTtpQkFBTTtnQkFDTCxHQUFHLEdBQUcsZ0JBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQzthQUN0QjtZQUNELE9BQU8sR0FBRyxDQUFDO1FBQ2IsQ0FBQyxDQUFDLENBQUM7UUFDSCxPQUFPLFVBQVUsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUMvQyxDQUFDOztBQTVOSCxrREE2TkM7QUExTlEsMEJBQU0sR0FBRyxLQUFLLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBOb2RlLFxuICBGdW5jdGlvbkRlY2xhcmF0aW9uLFxuICBOb2RlS2luZCxcbiAgU291cmNlLFxuICBTb3VyY2VLaW5kLFxuICBUeXBlTm9kZSxcbiAgQ2xhc3NEZWNsYXJhdGlvbixcbiAgRGVjbGFyYXRpb25TdGF0ZW1lbnQsXG4gIENvbW1vbkZsYWdzLFxuICBGaWVsZERlY2xhcmF0aW9uLFxuICBQYXJhbWV0ZXJOb2RlLFxufSBmcm9tIFwidmlzaXRvci1hcy9hc1wiO1xuaW1wb3J0IHsgQmFzZVZpc2l0b3IsIHV0aWxzIH0gZnJvbSBcInZpc2l0b3ItYXNcIjtcbmltcG9ydCB7IFNpbXBsZVBhcnNlciwgdG9TdHJpbmcsIG1ha2VTbmFrZUNhc2UgfSBmcm9tIFwiLi91dGlsc1wiO1xuXG5jb25zdCBORUFSX0RFQ09SQVRPUiA9IFwibmVhckJpbmRnZW5cIjtcbmNvbnN0IFdSQVBQRVJfUFJFRklYID0gXCJfX3dyYXBwZXJfXCI7XG5cbmZ1bmN0aW9uIHJldHVybnNWb2lkKG5vZGU6IEZ1bmN0aW9uRGVjbGFyYXRpb24pOiBib29sZWFuIHtcbiAgcmV0dXJuIHRvU3RyaW5nKG5vZGUuc2lnbmF0dXJlLnJldHVyblR5cGUpID09PSBcInZvaWRcIjtcbn1cblxuZnVuY3Rpb24gbnVtT2ZQYXJhbWV0ZXJzKG5vZGU6IEZ1bmN0aW9uRGVjbGFyYXRpb24pOiBudW1iZXIge1xuICByZXR1cm4gbm9kZS5zaWduYXR1cmUucGFyYW1ldGVycy5sZW5ndGg7XG59XG5cbmZ1bmN0aW9uIGhhc05lYXJEZWNvcmF0b3Ioc3RtdDogU291cmNlKTogYm9vbGVhbiB7XG4gIHJldHVybiAoXG4gICAgKGlzRW50cnkoc3RtdCkgfHxcbiAgICAgIHN0bXQudGV4dC5pbmNsdWRlcyhcIkBuZWFyZmlsZVwiKSB8fFxuICAgICAgc3RtdC5zdGF0ZW1lbnRzLnNvbWUoXG4gICAgICAgIChzKSA9PlxuICAgICAgICAgIHMgaW5zdGFuY2VvZiBEZWNsYXJhdGlvblN0YXRlbWVudCAmJlxuICAgICAgICAgIHV0aWxzLmhhc0RlY29yYXRvcihzLCBORUFSX0RFQ09SQVRPUilcbiAgICAgICkpICYmXG4gICAgIXN0bXQudGV4dC5pbmNsdWRlcyhcIkBub3ROZWFyZmlsZVwiKVxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNFbnRyeShzb3VyY2U6IFNvdXJjZSB8IE5vZGUpOiBib29sZWFuIHtcbiAgcmV0dXJuIHNvdXJjZS5yYW5nZS5zb3VyY2Uuc291cmNlS2luZCA9PSBTb3VyY2VLaW5kLlVTRVJfRU5UUlk7XG59XG5cbmZ1bmN0aW9uIGlzQ2xhc3ModHlwZTogTm9kZSk6IGJvb2xlYW4ge1xuICByZXR1cm4gdHlwZS5raW5kID09IE5vZGVLaW5kLkNMQVNTREVDTEFSQVRJT047XG59XG5cbmZ1bmN0aW9uIGlzRmllbGQobWVtOiBEZWNsYXJhdGlvblN0YXRlbWVudCkge1xuICByZXR1cm4gbWVtLmtpbmQgPT0gTm9kZUtpbmQuRklFTERERUNMQVJBVElPTjtcbn1cblxuZnVuY3Rpb24gaXNTdGF0aWMobWVtOiBEZWNsYXJhdGlvblN0YXRlbWVudCkge1xuICByZXR1cm4gbWVtLmlzKENvbW1vbkZsYWdzLlNUQVRJQyk7XG59XG5cbmZ1bmN0aW9uIGlzRW5jb2RhYmxlKG1lbTogRGVjbGFyYXRpb25TdGF0ZW1lbnQpIHtcbiAgcmV0dXJuIGlzRmllbGQobWVtKSAmJiAhaXNTdGF0aWMobWVtKTtcbn1cblxuZnVuY3Rpb24gaXNQYXlhYmxlKGZ1bmM6IEZ1bmN0aW9uRGVjbGFyYXRpb24pOiBib29sZWFuIHtcbiAgcmV0dXJuIChcbiAgICBmdW5jLmRlY29yYXRvcnMgIT0gbnVsbCAmJlxuICAgIGZ1bmMuZGVjb3JhdG9ycy5zb21lKChzKSA9PiB0b1N0cmluZyhzLm5hbWUpICE9IFwicGF5YWJsZVwiKVxuICApO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVEZWNvZGVTdGF0ZW1lbnRzKF9jbGFzczogQ2xhc3NEZWNsYXJhdGlvbik6IHN0cmluZ1tdIHtcbiAgcmV0dXJuIF9jbGFzcy5tZW1iZXJzXG4gICAgLmZpbHRlcihpc0VuY29kYWJsZSlcbiAgICAubWFwKChmaWVsZDogRmllbGREZWNsYXJhdGlvbik6IHN0cmluZyA9PiB7XG4gICAgICBjb25zdCBuYW1lID0gdG9TdHJpbmcoZmllbGQubmFtZSk7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBjcmVhdGVEZWNvZGVTdGF0ZW1lbnQoZmllbGQsIGB0aGlzLiR7bmFtZX0gPSBvYmouaGFzKFwiJHtuYW1lfVwiKSA/IGApICtcbiAgICAgICAgYDogJHtcbiAgICAgICAgICBmaWVsZC5pbml0aWFsaXplciAhPSBudWxsXG4gICAgICAgICAgICA/IHRvU3RyaW5nKGZpZWxkLmluaXRpYWxpemVyKVxuICAgICAgICAgICAgOiBgdGhpcy4ke25hbWV9YFxuICAgICAgICB9O2BcbiAgICAgICk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZURlY29kZVN0YXRlbWVudChcbiAgZmllbGQ6IEZpZWxkRGVjbGFyYXRpb24gfCBQYXJhbWV0ZXJOb2RlLFxuICBzZXR0ZXJQcmVmaXggPSBcIlwiXG4pOiBzdHJpbmcge1xuICBsZXQgVCA9IHRvU3RyaW5nKGZpZWxkLnR5cGUhKTtcbiAgbGV0IG5hbWUgPSB0b1N0cmluZyhmaWVsZC5uYW1lKTtcbiAgcmV0dXJuIGAke3NldHRlclByZWZpeH1kZWNvZGU8JHtUfSwgSlNPTi5PYmo+KG9iaiwgXCIke25hbWV9XCIpYDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRW5jb2RlU3RhdGVtZW50cyhfY2xhc3M6IENsYXNzRGVjbGFyYXRpb24pOiBzdHJpbmdbXSB7XG4gIHJldHVybiBfY2xhc3MubWVtYmVyc1xuICAgIC5maWx0ZXIoaXNFbmNvZGFibGUpXG4gICAgLm1hcCgoZmllbGQ6IEZpZWxkRGVjbGFyYXRpb24pOiBzdHJpbmcgPT4ge1xuICAgICAgbGV0IFQgPSB0b1N0cmluZyhmaWVsZC50eXBlISk7XG4gICAgICBsZXQgbmFtZSA9IHRvU3RyaW5nKGZpZWxkLm5hbWUpO1xuICAgICAgcmV0dXJuIGBlbmNvZGU8JHtUfSwgSlNPTkVuY29kZXI+KHRoaXMuJHtuYW1lfSwgXCIke25hbWV9XCIsIGVuY29kZXIpO2A7XG4gICAgfSk7XG59XG5cbi8vIFRPRE86IEV4dHJhY3QgdGhpcyBpbnRvIHNlcGFyYXRlIG1vZHVsZSwgcHJlZmVycmFibGUgcGx1Z2dhYmxlXG5leHBvcnQgY2xhc3MgSlNPTkJpbmRpbmdzQnVpbGRlciBleHRlbmRzIEJhc2VWaXNpdG9yIHtcbiAgcHJpdmF0ZSBzYjogc3RyaW5nW10gPSBbXTtcbiAgcHJpdmF0ZSBleHBvcnRlZENsYXNzZXM6IE1hcDxzdHJpbmcsIENsYXNzRGVjbGFyYXRpb24+ID0gbmV3IE1hcCgpO1xuICBzdGF0aWMgaXNUZXN0ID0gZmFsc2U7XG4gIHdyYXBwZWRGdW5jczogU2V0PHN0cmluZz4gPSBuZXcgU2V0KCk7XG5cbiAgc3RhdGljIGJ1aWxkKHNvdXJjZTogU291cmNlKTogc3RyaW5nIHtcbiAgICByZXR1cm4gbmV3IEpTT05CaW5kaW5nc0J1aWxkZXIoKS5idWlsZChzb3VyY2UpO1xuICB9XG5cbiAgc3RhdGljIG5lYXJGaWxlcyhzb3VyY2VzOiBTb3VyY2VbXSk6IFNvdXJjZVtdIHtcbiAgICByZXR1cm4gc291cmNlcy5maWx0ZXIoaGFzTmVhckRlY29yYXRvcik7XG4gIH1cblxuICBzdGF0aWMgY2hlY2tUZXN0QnVpbGQoc291cmNlczogU291cmNlW10pIHtcbiAgICB0aGlzLmlzVGVzdCA9IHNvdXJjZXMuc29tZSgocykgPT4gcy5ub3JtYWxpemVkUGF0aC5pbmNsdWRlcyhcIi5zcGVjLlwiKSk7XG4gIH1cblxuICB2aXNpdENsYXNzRGVjbGFyYXRpb24obm9kZTogQ2xhc3NEZWNsYXJhdGlvbik6IHZvaWQge1xuICAgIGlmICghdGhpcy5leHBvcnRlZENsYXNzZXMuaGFzKHRvU3RyaW5nKG5vZGUubmFtZSkpKSB7XG4gICAgICB0aGlzLmV4cG9ydGVkQ2xhc3Nlcy5zZXQodG9TdHJpbmcobm9kZS5uYW1lKSwgbm9kZSk7XG4gICAgfVxuICAgIHN1cGVyLnZpc2l0Q2xhc3NEZWNsYXJhdGlvbihub2RlKTtcbiAgfVxuXG4gIG5lZWRzV3JhcHBlcihub2RlOiBGdW5jdGlvbkRlY2xhcmF0aW9uKTogYm9vbGVhbiB7XG4gICAgbGV0IGlzRXhwb3J0ID0gbm9kZS5pcyhDb21tb25GbGFncy5FWFBPUlQpO1xuICAgIGxldCBhbHJlYWR5V3JhcHBlZCA9IHRoaXMud3JhcHBlZEZ1bmNzLmhhcyh0b1N0cmluZyhub2RlLm5hbWUpKTtcbiAgICBsZXQgbm9JbnB1dE9yT3V0cHV0ID0gbnVtT2ZQYXJhbWV0ZXJzKG5vZGUpID09IDAgJiYgcmV0dXJuc1ZvaWQobm9kZSk7XG4gICAgaWYgKFxuICAgICAgIWlzRXhwb3J0IHx8XG4gICAgICBhbHJlYWR5V3JhcHBlZCB8fFxuICAgICAgbm9JbnB1dE9yT3V0cHV0IHx8XG4gICAgICBKU09OQmluZGluZ3NCdWlsZGVyLmlzVGVzdFxuICAgIClcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gaXNFbnRyeShub2RlKSB8fCB1dGlscy5oYXNEZWNvcmF0b3Iobm9kZSwgTkVBUl9ERUNPUkFUT1IpO1xuICB9XG5cbiAgdmlzaXRGdW5jdGlvbkRlY2xhcmF0aW9uKG5vZGU6IEZ1bmN0aW9uRGVjbGFyYXRpb24pOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMubmVlZHNXcmFwcGVyKG5vZGUpKSB7XG4gICAgICBpZiAoXG4gICAgICAgIChpc0VudHJ5KG5vZGUpIHx8IHV0aWxzLmhhc0RlY29yYXRvcihub2RlLCBORUFSX0RFQ09SQVRPUikpICYmXG4gICAgICAgICF0aGlzLndyYXBwZWRGdW5jcy5oYXModG9TdHJpbmcobm9kZS5uYW1lKSkgJiZcbiAgICAgICAgbm9kZS5pcyhDb21tb25GbGFncy5FWFBPUlQpXG4gICAgICApIHtcbiAgICAgICAgdGhpcy5zYi5wdXNoKHRoaXMuY2FtZWxDYXNlVG9TbmFrZUNhc2VFeHBvcnQodG9TdHJpbmcobm9kZS5uYW1lKSwgXCJcIikpO1xuICAgICAgICB0aGlzLndyYXBwZWRGdW5jcy5hZGQodG9TdHJpbmcobm9kZS5uYW1lKSk7XG4gICAgICB9XG4gICAgICBzdXBlci52aXNpdEZ1bmN0aW9uRGVjbGFyYXRpb24obm9kZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZ2VuZXJhdGVXcmFwcGVyRnVuY3Rpb24obm9kZSk7XG4gICAgLy8gQ2hhbmdlIGZ1bmN0aW9uIHRvIG5vdCBiZSBhbiBleHBvcnRcbiAgICBub2RlLmZsYWdzID0gbm9kZS5mbGFncyBeIENvbW1vbkZsYWdzLkVYUE9SVDtcbiAgICB0aGlzLndyYXBwZWRGdW5jcy5hZGQodG9TdHJpbmcobm9kZS5uYW1lKSk7XG4gICAgc3VwZXIudmlzaXQobm9kZSk7XG4gIH1cblxuICBjYW1lbENhc2VUb1NuYWtlQ2FzZUV4cG9ydChcbiAgICBuYW1lOiBzdHJpbmcsXG4gICAgcHJlZml4OiBzdHJpbmcgPSBXUkFQUEVSX1BSRUZJWFxuICApOiBzdHJpbmcge1xuICAgIGxldCBzID0gbWFrZVNuYWtlQ2FzZShuYW1lKTtcbiAgICBpZiAocy5ub3JtYWxpemUoKSA9PT0gbmFtZS5ub3JtYWxpemUoKSkge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIHJldHVybiBgZXhwb3J0IHsgJHtwcmVmaXggKyBuYW1lfSBhcyAke3N9IH1gO1xuICB9XG5cbiAgLypcbiAgQ3JlYXRlIGEgd3JhcHBlciBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgZXhwb3J0IGluIHRoZSBmdW5jdGlvbidzIHBsYWNlLlxuICAqL1xuICBwcml2YXRlIGdlbmVyYXRlV3JhcHBlckZ1bmN0aW9uKGZ1bmM6IEZ1bmN0aW9uRGVjbGFyYXRpb24pIHtcbiAgICBsZXQgc2lnbmF0dXJlID0gZnVuYy5zaWduYXR1cmU7XG4gICAgbGV0IHBhcmFtcyA9IHNpZ25hdHVyZS5wYXJhbWV0ZXJzO1xuICAgIGxldCByZXR1cm5UeXBlID0gc2lnbmF0dXJlLnJldHVyblR5cGU7XG4gICAgbGV0IHJldHVyblR5cGVOYW1lID0gdG9TdHJpbmcocmV0dXJuVHlwZSlcbiAgICAgIC5zcGxpdChcInxcIilcbiAgICAgIC5tYXAoKG5hbWUpID0+IG5hbWUudHJpbSgpKVxuICAgICAgLmZpbHRlcigobmFtZSkgPT4gbmFtZSAhPT0gXCJudWxsXCIpXG4gICAgICAuam9pbihcInxcIik7XG4gICAgbGV0IGhhc051bGwgPSB0b1N0cmluZyhyZXR1cm5UeXBlKS5pbmNsdWRlcyhcIm51bGxcIik7XG4gICAgbGV0IG5hbWUgPSBmdW5jLm5hbWUudGV4dDtcbiAgICBpZiAoZnVuYy5kZWNvcmF0b3JzICYmIGZ1bmMuZGVjb3JhdG9ycy5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLnNiLnB1c2goXG4gICAgICAgIGZ1bmMuZGVjb3JhdG9ycy5tYXAoKGRlY29yYXRvcikgPT4gdG9TdHJpbmcoZGVjb3JhdG9yKSkuam9pbihcIlxcblwiKVxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5zYi5wdXNoKGBmdW5jdGlvbiBfX3dyYXBwZXJfJHtuYW1lfSgpOiB2b2lkIHtgKTtcbiAgICBpZiAocGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuc2IucHVzaChgICBjb25zdCBvYmogPSBnZXRJbnB1dCgpO2ApO1xuICAgIH1cbiAgICBpZiAodG9TdHJpbmcocmV0dXJuVHlwZSkgIT09IFwidm9pZFwiKSB7XG4gICAgICB0aGlzLnNiLnB1c2goYCAgbGV0IHJlc3VsdDogJHt0b1N0cmluZyhyZXR1cm5UeXBlKX0gPSAke25hbWV9KGApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNiLnB1c2goYCAgJHtuYW1lfShgKTtcbiAgICB9XG4gICAgaWYgKHBhcmFtcy5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLnNiW3RoaXMuc2IubGVuZ3RoIC0gMV0gKz0gcGFyYW1zXG4gICAgICAgIC5tYXAoKHBhcmFtKSA9PiB7XG4gICAgICAgICAgbGV0IG5hbWUgPSB0b1N0cmluZyhwYXJhbS5uYW1lKTtcbiAgICAgICAgICBsZXQgdHlwZSA9IHRvU3RyaW5nKHBhcmFtLnR5cGUpO1xuICAgICAgICAgIGxldCByZXMgPSBgb2JqLmhhcygnJHtuYW1lfScpID9cbiAgICAgICAgICAgICAke2NyZWF0ZURlY29kZVN0YXRlbWVudChwYXJhbSl9IDogJHtcbiAgICAgICAgICAgIHBhcmFtLmluaXRpYWxpemVyXG4gICAgICAgICAgICAgID8gdG9TdHJpbmcocGFyYW0uaW5pdGlhbGl6ZXIpXG4gICAgICAgICAgICAgIDogYHJlcXVpcmVQYXJhbWV0ZXI8JHt0eXBlfT4oXCIke25hbWV9XCIpYFxuICAgICAgICAgIH1gO1xuICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0pXG4gICAgICAgIC5qb2luKFwiLFxcbiAgICBcIik7XG4gICAgfVxuICAgIHRoaXMuc2JbdGhpcy5zYi5sZW5ndGggLSAxXSArPSBcIik7XCI7XG4gICAgaWYgKHRvU3RyaW5nKHJldHVyblR5cGUpICE9PSBcInZvaWRcIikge1xuICAgICAgdGhpcy5zYi5wdXNoKGAgIGNvbnN0IHZhbCA9IGVuY29kZTwke3JldHVyblR5cGVOYW1lfT4oJHtcbiAgICAgICAgaGFzTnVsbCA/IGBjaGFuZ2V0eXBlPCR7cmV0dXJuVHlwZU5hbWV9PihyZXN1bHQpYCA6IFwicmVzdWx0XCJcbiAgICAgIH0pO1xuICB2YWx1ZV9yZXR1cm4odmFsLmJ5dGVMZW5ndGgsIHZhbC5kYXRhU3RhcnQpO2ApO1xuICAgIH1cbiAgICB0aGlzLnNiLnB1c2goYH1cbmV4cG9ydCB7ICR7V1JBUFBFUl9QUkVGSVggKyBuYW1lfSBhcyAke25hbWV9IH1cbiR7dGhpcy5jYW1lbENhc2VUb1NuYWtlQ2FzZUV4cG9ydChuYW1lKX1cbmApO1xuICB9XG5cbiAgcHJpdmF0ZSB0eXBlTmFtZSh0eXBlOiBUeXBlTm9kZSB8IENsYXNzRGVjbGFyYXRpb24pOiBzdHJpbmcge1xuICAgIGlmICghaXNDbGFzcyh0eXBlKSkge1xuICAgICAgcmV0dXJuIHRvU3RyaW5nKHR5cGUpO1xuICAgIH1cbiAgICB0eXBlID0gPENsYXNzRGVjbGFyYXRpb24+dHlwZTtcbiAgICBsZXQgY2xhc3NOYW1lID0gdG9TdHJpbmcodHlwZS5uYW1lKTtcbiAgICBpZiAodHlwZS5pc0dlbmVyaWMpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIjxcIiArIHR5cGUudHlwZVBhcmFtZXRlcnMhLm1hcCh0b1N0cmluZykuam9pbihcIiwgXCIpICsgXCI+XCI7XG4gICAgfVxuICAgIHJldHVybiBjbGFzc05hbWU7XG4gIH1cblxuICBidWlsZChzb3VyY2U6IFNvdXJjZSk6IHN0cmluZyB7XG4gICAgY29uc3QgaXNOZWFyRmlsZSA9IHNvdXJjZS50ZXh0LmluY2x1ZGVzKFwiQG5lYXJmaWxlXCIpO1xuICAgIHRoaXMuc2IgPSBbXTtcbiAgICB0aGlzLnZpc2l0KHNvdXJjZSk7XG5cbiAgICBsZXQgc291cmNlVGV4dCA9IHNvdXJjZS5zdGF0ZW1lbnRzLm1hcCgoc3RtdCkgPT4ge1xuICAgICAgbGV0IHN0cjtcbiAgICAgIGlmIChcbiAgICAgICAgaXNDbGFzcyhzdG10KSAmJlxuICAgICAgICAodXRpbHMuaGFzRGVjb3JhdG9yKDxDbGFzc0RlY2xhcmF0aW9uPnN0bXQsIE5FQVJfREVDT1JBVE9SKSB8fFxuICAgICAgICAgIGlzTmVhckZpbGUpXG4gICAgICApIHtcbiAgICAgICAgbGV0IF9jbGFzcyA9IDxDbGFzc0RlY2xhcmF0aW9uPnN0bXQ7XG4gICAgICAgIGxldCBmaWVsZHMgPSBfY2xhc3MubWVtYmVyc1xuICAgICAgICAgIC5maWx0ZXIoaXNGaWVsZClcbiAgICAgICAgICAubWFwKChmaWVsZDogRmllbGREZWNsYXJhdGlvbikgPT4gZmllbGQpO1xuICAgICAgICBpZiAoZmllbGRzLnNvbWUoKGZpZWxkKSA9PiBmaWVsZC50eXBlID09IG51bGwpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWxsIEZpZWxkcyBtdXN0IGhhdmUgZXhwbGljaXQgdHlwZSBkZWNsYXJhdGlvbi5cIik7XG4gICAgICAgIH1cbiAgICAgICAgZmllbGRzLmZvckVhY2goKGZpZWxkKSA9PiB7XG4gICAgICAgICAgaWYgKGZpZWxkLmluaXRpYWxpemVyID09IG51bGwpIHtcbiAgICAgICAgICAgIGZpZWxkLmluaXRpYWxpemVyID0gU2ltcGxlUGFyc2VyLnBhcnNlRXhwcmVzc2lvbihcbiAgICAgICAgICAgICAgYGRlZmF1bHRWYWx1ZTwke3RvU3RyaW5nKGZpZWxkLnR5cGUhKX0+KCkpYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBzdHIgPSB0b1N0cmluZyhzdG10KTtcbiAgICAgICAgc3RyID0gc3RyLnNsaWNlKDAsIHN0ci5sYXN0SW5kZXhPZihcIn1cIikpO1xuICAgICAgICBsZXQgY2xhc3NOYW1lID0gdGhpcy50eXBlTmFtZShfY2xhc3MpO1xuICAgICAgICBpZiAoIXV0aWxzLmhhc0RlY29yYXRvcig8Q2xhc3NEZWNsYXJhdGlvbj5zdG10LCBORUFSX0RFQ09SQVRPUikpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJcXHgxYlszMW1cIixcbiAgICAgICAgICAgIGBAbmVhcmZpbGUgaXMgZGVwcmVjYXRlZCB1c2UgQCR7TkVBUl9ERUNPUkFUT1J9IGRlY29yYXRvciBvbiAke2NsYXNzTmFtZX1gLFxuICAgICAgICAgICAgXCJcXHgxYlswbVwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBzdHIgKz0gYFxuICBkZWNvZGU8X1YgPSBVaW50OEFycmF5PihidWY6IF9WKTogJHtjbGFzc05hbWV9IHtcbiAgICBsZXQganNvbjogSlNPTi5PYmo7XG4gICAgaWYgKGJ1ZiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgIGpzb24gPSBKU09OLnBhcnNlKGJ1Zik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydChidWYgaW5zdGFuY2VvZiBKU09OLk9iaiwgXCJhcmd1bWVudCBtdXN0IGJlIFVpbnQ4QXJyYXkgb3IgSnNvbiBPYmplY3RcIik7XG4gICAgICBqc29uID0gPEpTT04uT2JqPiBidWY7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9kZWNvZGUoanNvbik7XG4gIH1cblxuICBzdGF0aWMgZGVjb2RlKGJ1ZjogVWludDhBcnJheSk6ICR7Y2xhc3NOYW1lfSB7XG4gICAgcmV0dXJuIGRlY29kZTwke2NsYXNzTmFtZX0+KGJ1Zik7XG4gIH1cblxuICBwcml2YXRlIF9kZWNvZGUob2JqOiBKU09OLk9iaik6ICR7Y2xhc3NOYW1lfSB7XG4gICAgJHtjcmVhdGVEZWNvZGVTdGF0ZW1lbnRzKF9jbGFzcykuam9pbihcIlxcbiAgICBcIil9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBfZW5jb2RlKG5hbWU6IHN0cmluZyB8IG51bGwgPSBcIlwiLCBfZW5jb2RlcjogSlNPTkVuY29kZXIgfCBudWxsID0gbnVsbCk6IEpTT05FbmNvZGVyIHtcbiAgICBsZXQgZW5jb2RlciA9IF9lbmNvZGVyID09IG51bGwgPyBuZXcgSlNPTkVuY29kZXIoKSA6IF9lbmNvZGVyO1xuICAgIGVuY29kZXIucHVzaE9iamVjdChuYW1lKTtcbiAgICAke2NyZWF0ZUVuY29kZVN0YXRlbWVudHMoX2NsYXNzKS5qb2luKFwiXFxuICAgIFwiKX1cbiAgICBlbmNvZGVyLnBvcE9iamVjdCgpO1xuICAgIHJldHVybiBlbmNvZGVyO1xuICB9XG4gIGVuY29kZSgpOiBVaW50OEFycmF5IHtcbiAgICByZXR1cm4gdGhpcy5fZW5jb2RlKCkuc2VyaWFsaXplKCk7XG4gIH1cblxuICBzZXJpYWxpemUoKTogVWludDhBcnJheSB7XG4gICAgcmV0dXJuIHRoaXMuZW5jb2RlKCk7XG4gIH1cblxuICB0b0pTT04oKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fZW5jb2RlKCkudG9TdHJpbmcoKTtcbiAgfVxufWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSB0b1N0cmluZyhzdG10KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHI7XG4gICAgfSk7XG4gICAgcmV0dXJuIHNvdXJjZVRleHQuY29uY2F0KHRoaXMuc2IpLmpvaW4oXCJcXG5cIik7XG4gIH1cbn1cbiJdfQ==
'''
'''--- bindgen/dist/classExporter.js ---
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClassExporter = void 0;
const as_1 = require("visitor-as/as");
const visitor_as_1 = require("visitor-as");
const JSONBuilder_1 = require("./JSONBuilder");
const utils_1 = require("./utils");
const toString = visitor_as_1.utils.toString;
const privateDecorator = "contractPrivate";
class ClassExporter extends visitor_as_1.ClassDecorator {
    constructor() {
        super(...arguments);
        this.sb = [];
    }
    static get className() {
        return toString(ClassExporter.classSeen.name);
    }
    checkMethods(name) {
        let _class = ClassExporter.classSeen;
        _class.members.forEach((member) => {
            if (member instanceof as_1.MethodDeclaration &&
                !member.is(as_1.CommonFlags.PRIVATE)) {
                if (toString(member.name) === name) {
                    throw new Error(`Method "${toString(member.name)}" already used; cannot export constructor using the same name.`);
                }
            }
        });
    }
    visitFieldDeclaration(node) { }
    visitMethodDeclaration(node) {
        if (node.is(as_1.CommonFlags.SET) || node.is(as_1.CommonFlags.GET)) {
            throw new Error("Exported Singleton class cannot have properties. Found " +
                node.name.text);
        }
        // Private methods should be skipped.
        if (node.is(as_1.CommonFlags.PRIVATE)) {
            return;
        }
        let privateCheck = visitor_as_1.utils.hasDecorator(node, privateDecorator)
            ? `__assertPrivate();`
            : "";
        let name = toString(node.name);
        let decorators = (node.decorators || []).map(toString);
        let returnType = toString(node.signature.returnType);
        let origParams = node.signature.parameters.map(visitor_as_1.utils.cloneNode);
        let parameters = origParams.map((param) => {
            if (param.implicitFieldDeclaration) {
                param.name.text = param.name.text.substring(2);
            }
            return toString(param);
        });
        let pramNames = origParams.map((param) => {
            return toString(param.name);
        });
        let isInit = name === "constructor";
        let assertStr = "";
        if (isInit) {
            assertStr = `assert(isNull(__contract), "contract is already initialized");`;
        }
        else if (ClassExporter.hasConstructor) {
            assertStr = `assert(!isNull(__contract), "contract is not initialized");`;
        }
        let isVoid = returnType === "void";
        let body = isInit
            ? `__contract = new ${ClassExporter.className}(${pramNames.join(", ")});`
            : `${!isVoid ? "let res =  " : ""}__contract.${name}(${pramNames.join(", ")});`;
        if (isInit) {
            name = "init";
            parameters = origParams.map((node) => `${toString(node.name)}: ${toString(node.type)}${node.initializer ? " = " + toString(node.initializer) : ""}`);
            returnType = "void";
        }
        if (isInit) {
            if (!decorators.some((decorator) => decorator.includes("exportAs"))) {
                decorators.push(`@exportAs("new")`);
                this.checkMethods("new");
            }
            else {
                let decorator = node.decorators.find((d) => toString(d.name) === "exportAs");
                if (decorator.args.length == 1) {
                    this.checkMethods(toString(decorator.args[0]));
                }
            }
        }
        const hasMutateState = decorators.some((decorator) => {
            let res = decorator.includes("mutateState");
            return res;
        });
        this.sb.push(`${decorators.join("\n")}
export function ${name}(${parameters.join(", ")}): ${returnType} {
  ${privateCheck}
  ${assertStr}
  ${body}
  ${isInit || hasMutateState ? `__setState(__contract);` : ""}
  ${isVoid || isInit ? "" : "return res;"}
}`);
    }
    visitClassDeclaration(node) {
        if (JSONBuilder_1.isEntry(node) && node.is(as_1.CommonFlags.EXPORT)) {
            let name = toString(node.name);
            if (ClassExporter.classSeen) {
                throw new Error(`Cannot export class ${name}. ${ClassExporter.className} already exported. `);
            }
            ClassExporter.classSeen = node;
            ClassExporter.hasConstructor = node.members.some((member) => {
                if (member instanceof as_1.MethodDeclaration) {
                    return toString(member.name) === "constructor";
                }
                return false;
            });
            this.sb.push(`let __contract: ${name};
if (__checkState()) {
  __contract = __getState<${name}>();
}${!ClassExporter.hasConstructor
                ? ` else {
  __contract = new ${name}();
}`
                : ""}`);
            this.visit(node.members);
            node.flags = node.flags ^ as_1.CommonFlags.EXPORT;
            let newStatements = utils_1.SimpleParser.parseTopLevel(this.sb.join("\n")).map((n) => {
                if (n instanceof as_1.FunctionDeclaration) {
                    n.flags = n.flags | as_1.CommonFlags.EXPORT;
                    n.flags = n.flags | as_1.CommonFlags.MODULE_EXPORT;
                }
                n.range = node.range;
                return n;
            });
            node.range.source.statements.push(...newStatements);
        }
    }
    get name() {
        return "nearBindgen";
    }
    static visit(source) {
        if (source.sourceKind != as_1.SourceKind.USER_ENTRY) {
            return;
        }
        let visitor = new ClassExporter();
        visitor.visit(source);
    }
}
exports.ClassExporter = ClassExporter;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xhc3NFeHBvcnRlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9jbGFzc0V4cG9ydGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLHNDQVF1QjtBQUN2QiwyQ0FBbUQ7QUFDbkQsK0NBQXdDO0FBQ3hDLG1DQUF1QztBQUV2QyxNQUFNLFFBQVEsR0FBRyxrQkFBSyxDQUFDLFFBQVEsQ0FBQztBQUNoQyxNQUFNLGdCQUFnQixHQUFHLGlCQUFpQixDQUFDO0FBRTNDLE1BQWEsYUFBYyxTQUFRLDJCQUFjO0lBQWpEOztRQUNFLE9BQUUsR0FBYSxFQUFFLENBQUM7SUFpS3BCLENBQUM7SUE3SkMsTUFBTSxLQUFLLFNBQVM7UUFDbEIsT0FBTyxRQUFRLENBQUMsYUFBYSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNoRCxDQUFDO0lBRUQsWUFBWSxDQUFDLElBQVk7UUFDdkIsSUFBSSxNQUFNLEdBQUcsYUFBYSxDQUFDLFNBQVMsQ0FBQztRQUNyQyxNQUFNLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDLE1BQU0sRUFBRSxFQUFFO1lBQ2hDLElBQ0UsTUFBTSxZQUFZLHNCQUFpQjtnQkFDbkMsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLGdCQUFXLENBQUMsT0FBTyxDQUFDLEVBQy9CO2dCQUNBLElBQUksUUFBUSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxJQUFJLEVBQUU7b0JBQ2xDLE1BQU0sSUFBSSxLQUFLLENBQ2IsV0FBVyxRQUFRLENBQ2pCLE1BQU0sQ0FBQyxJQUFJLENBQ1osZ0VBQWdFLENBQ2xFLENBQUM7aUJBQ0g7YUFDRjtRQUNILENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVELHFCQUFxQixDQUFDLElBQXNCLElBQVMsQ0FBQztJQUV0RCxzQkFBc0IsQ0FBQyxJQUF1QjtRQUM1QyxJQUFJLElBQUksQ0FBQyxFQUFFLENBQUMsZ0JBQVcsQ0FBQyxHQUFHLENBQUMsSUFB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LElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUNwRSxDQUFDLENBQUMsRUFBRSxFQUFFO2dCQUNKLElBQUksQ0FBQyxZQUFZLHdCQUFtQixFQUFFO29CQUNwQyxDQUFDLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxLQUFLLEdBQUcsZ0JBQVcsQ0FBQyxNQUFNLENBQUM7b0JBQ3ZDLENBQUMsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLEtBQUssR0FBRyxnQkFBVyxDQUFDLGFBQWEsQ0FBQztpQkFDL0M7Z0JBQ0QsQ0FBQyxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDO2dCQUNyQixPQUFPLENBQUMsQ0FBQztZQUNYLENBQUMsQ0FDRixDQUFDO1lBQ0YsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxHQUFHLGFBQWEsQ0FBQyxDQUFDO1NBQ3JEO0lBQ0gsQ0FBQztJQUVELElBQUksSUFBSTtRQUNOLE9BQU8sYUFBYSxDQUFDO0lBQ3ZCLENBQUM7SUFFRCxNQUFNLENBQUMsS0FBSyxDQUFDLE1BQWM7UUFDekIsSUFBSSxNQUFNLENBQUMsVUFBVSxJQUFJLGVBQVUsQ0FBQyxVQUFVLEVBQUU7WUFDOUMsT0FBTztTQUNSO1FBQ0QsSUFBSSxPQUFPLEdBQUcsSUFBSSxhQUFhLEVBQUUsQ0FBQztRQUNsQyxPQUFPLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ3hCLENBQUM7Q0FDRjtBQWxLRCxzQ0FrS0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBDbGFzc0RlY2xhcmF0aW9uLFxuICBGaWVsZERlY2xhcmF0aW9uLFxuICBNZXRob2REZWNsYXJhdGlvbixcbiAgU291cmNlLFxuICBDb21tb25GbGFncyxcbiAgU291cmNlS2luZCxcbiAgRnVuY3Rpb25EZWNsYXJhdGlvbixcbn0gZnJvbSBcInZpc2l0b3ItYXMvYXNcIjtcbmltcG9ydCB7IHV0aWxzLCBDbGFzc0RlY29yYXRvciB9IGZyb20gXCJ2aXNpdG9yLWFzXCI7XG5pbXBvcnQgeyBpc0VudHJ5IH0gZnJvbSBcIi4vSlNPTkJ1aWxkZXJcIjtcbmltcG9ydCB7IFNpbXBsZVBhcnNlciB9IGZyb20gXCIuL3V0aWxzXCI7XG5cbmNvbnN0IHRvU3RyaW5nID0gdXRpbHMudG9TdHJpbmc7XG5jb25zdCBwcml2YXRlRGVjb3JhdG9yID0gXCJjb250cmFjdFByaXZhdGVcIjtcblxuZXhwb3J0IGNsYXNzIENsYXNzRXhwb3J0ZXIgZXh0ZW5kcyBDbGFzc0RlY29yYXRvciB7XG4gIHNiOiBzdHJpbmdbXSA9IFtdO1xuICBzdGF0aWMgY2xhc3NTZWVuOiBDbGFzc0RlY2xhcmF0aW9uO1xuICBzdGF0aWMgaGFzQ29uc3RydWN0b3I6IGJvb2xlYW47XG5cbiAgc3RhdGljIGdldCBjbGFzc05hbWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdG9TdHJpbmcoQ2xhc3NFeHBvcnRlci5jbGFzc1NlZW4ubmFtZSk7XG4gIH1cblxuICBjaGVja01ldGhvZHMobmFtZTogc3RyaW5nKSB7XG4gICAgbGV0IF9jbGFzcyA9IENsYXNzRXhwb3J0ZXIuY2xhc3NTZWVuO1xuICAgIF9jbGFzcy5tZW1iZXJzLmZvckVhY2goKG1lbWJlcikgPT4ge1xuICAgICAgaWYgKFxuICAgICAgICBtZW1iZXIgaW5zdGFuY2VvZiBNZXRob2REZWNsYXJhdGlvbiAmJlxuICAgICAgICAhbWVtYmVyLmlzKENvbW1vbkZsYWdzLlBSSVZBVEUpXG4gICAgICApIHtcbiAgICAgICAgaWYgKHRvU3RyaW5nKG1lbWJlci5uYW1lKSA9PT0gbmFtZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBNZXRob2QgXCIke3RvU3RyaW5nKFxuICAgICAgICAgICAgICBtZW1iZXIubmFtZVxuICAgICAgICAgICAgKX1cIiBhbHJlYWR5IHVzZWQ7IGNhbm5vdCBleHBvcnQgY29uc3RydWN0b3IgdXNpbmcgdGhlIHNhbWUgbmFtZS5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgdmlzaXRGaWVsZERlY2xhcmF0aW9uKG5vZGU6IEZpZWxkRGVjbGFyYXRpb24pOiB2b2lkIHt9XG5cbiAgdmlzaXRNZXRob2REZWNsYXJhdGlvbihub2RlOiBNZXRob2REZWNsYXJhdGlvbik6IHZvaWQge1xuICAgIGlmIChub2RlLmlzKENvbW1vbkZsYWdzLlNFVCkgfHwgbm9kZS5pcyhDb21tb25GbGFncy5HRVQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiRXhwb3J0ZWQgU2luZ2xldG9uIGNsYXNzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXMuIEZvdW5kIFwiICtcbiAgICAgICAgICBub2RlLm5hbWUudGV4dFxuICAgICAgKTtcbiAgICB9XG4gICAgLy8gUHJpdmF0ZSBtZXRob2RzIHNob3VsZCBiZSBza2lwcGVkLlxuICAgIGlmIChub2RlLmlzKENvbW1vbkZsYWdzLlBSSVZBVEUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBwcml2YXRlQ2hlY2sgPSB1dGlscy5oYXNEZWNvcmF0b3Iobm9kZSwgcHJpdmF0ZURlY29yYXRvcilcbiAgICAgID8gYF9fYXNzZXJ0UHJpdmF0ZSgpO2BcbiAgICAgIDogXCJcIjtcbiAgICBsZXQgbmFtZSA9IHRvU3RyaW5nKG5vZGUubmFtZSk7XG4gICAgbGV0IGRlY29yYXRvcnMgPSAobm9kZS5kZWNvcmF0b3JzIHx8IFtdKS5tYXAodG9TdHJpbmcpO1xuICAgIGxldCByZXR1cm5UeXBlID0gdG9TdHJpbmcobm9kZS5zaWduYXR1cmUucmV0dXJuVHlwZSk7XG4gICAgbGV0IG9yaWdQYXJhbXMgPSBub2RlLnNpZ25hdHVyZS5wYXJhbWV0ZXJzLm1hcCh1dGlscy5jbG9uZU5vZGUpO1xuICAgIGxldCBwYXJhbWV0ZXJzID0gb3JpZ1BhcmFtcy5tYXAoKHBhcmFtKSA9PiB7XG4gICAgICBpZiAocGFyYW0uaW1wbGljaXRGaWVsZERlY2xhcmF0aW9uKSB7XG4gICAgICAgIHBhcmFtLm5hbWUudGV4dCA9IHBhcmFtLm5hbWUudGV4dC5zdWJzdHJpbmcoMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdG9TdHJpbmcocGFyYW0pO1xuICAgIH0pO1xuICAgIGxldCBwcmFtTmFtZXMgPSBvcmlnUGFyYW1zLm1hcCgocGFyYW0pID0+IHtcbiAgICAgIHJldHVybiB0b1N0cmluZyhwYXJhbS5uYW1lKTtcbiAgICB9KTtcbiAgICBsZXQgaXNJbml0ID0gbmFtZSA9PT0gXCJjb25zdHJ1Y3RvclwiO1xuICAgIGxldCBhc3NlcnRTdHI6IHN0cmluZyA9IFwiXCI7XG4gICAgaWYgKGlzSW5pdCkge1xuICAgICAgYXNzZXJ0U3RyID0gYGFzc2VydChpc051bGwoX19jb250cmFjdCksIFwiY29udHJhY3QgaXMgYWxyZWFkeSBpbml0aWFsaXplZFwiKTtgO1xuICAgIH0gZWxzZSBpZiAoQ2xhc3NFeHBvcnRlci5oYXNDb25zdHJ1Y3Rvcikge1xuICAgICAgYXNzZXJ0U3RyID0gYGFzc2VydCghaXNOdWxsKF9fY29udHJhY3QpLCBcImNvbnRyYWN0IGlzIG5vdCBpbml0aWFsaXplZFwiKTtgO1xuICAgIH1cbiAgICBsZXQgaXNWb2lkID0gcmV0dXJuVHlwZSA9PT0gXCJ2b2lkXCI7XG4gICAgbGV0IGJvZHkgPSBpc0luaXRcbiAgICAgID8gYF9fY29udHJhY3QgPSBuZXcgJHtDbGFzc0V4cG9ydGVyLmNsYXNzTmFtZX0oJHtwcmFtTmFtZXMuam9pbihcIiwgXCIpfSk7YFxuICAgICAgOiBgJHshaXNWb2lkID8gXCJsZXQgcmVzID0gIFwiIDogXCJcIn1fX2NvbnRyYWN0LiR7bmFtZX0oJHtwcmFtTmFtZXMuam9pbihcbiAgICAgICAgICBcIiwgXCJcbiAgICAgICAgKX0pO2A7XG4gICAgaWYgKGlzSW5pdCkge1xuICAgICAgbmFtZSA9IFwiaW5pdFwiO1xuICAgICAgcGFyYW1ldGVycyA9IG9yaWdQYXJhbXMubWFwKFxuICAgICAgICAobm9kZSkgPT5cbiAgICAgICAgICBgJHt0b1N0cmluZyhub2RlLm5hbWUpfTogJHt0b1N0cmluZyhub2RlLnR5cGUpfSR7XG4gICAgICAgICAgICBub2RlLmluaXRpYWxpemVyID8gXCIgPSBcIiArIHRvU3RyaW5nKG5vZGUuaW5pdGlhbGl6ZXIpIDogXCJcIlxuICAgICAgICAgIH1gXG4gICAgICApO1xuICAgICAgcmV0dXJuVHlwZSA9IFwidm9pZFwiO1xuICAgIH1cbiAgICBpZiAoaXNJbml0KSB7XG4gICAgICBpZiAoIWRlY29yYXRvcnMuc29tZSgoZGVjb3JhdG9yKSA9PiBkZWNvcmF0b3IuaW5jbHVkZXMoXCJleHBvcnRBc1wiKSkpIHtcbiAgICAgICAgZGVjb3JhdG9ycy5wdXNoKGBAZXhwb3J0QXMoXCJuZXdcIilgKTtcbiAgICAgICAgdGhpcy5jaGVja01ldGhvZHMoXCJuZXdcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgZGVjb3JhdG9yID0gbm9kZS5kZWNvcmF0b3JzIS5maW5kKFxuICAgICAgICAgIChkKSA9PiB0b1N0cmluZyhkLm5hbWUpID09PSBcImV4cG9ydEFzXCJcbiAgICAgICAgKSE7XG4gICAgICAgIGlmIChkZWNvcmF0b3IuYXJncyEubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICB0aGlzLmNoZWNrTWV0aG9kcyh0b1N0cmluZyhkZWNvcmF0b3IuYXJncyFbMF0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBoYXNNdXRhdGVTdGF0ZSA9IGRlY29yYXRvcnMuc29tZSgoZGVjb3JhdG9yKSA9PiB7XG4gICAgICBsZXQgcmVzID0gZGVjb3JhdG9yLmluY2x1ZGVzKFwibXV0YXRlU3RhdGVcIik7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0pO1xuICAgIHRoaXMuc2IucHVzaChcbiAgICAgIGAke2RlY29yYXRvcnMuam9pbihcIlxcblwiKX1cbmV4cG9ydCBmdW5jdGlvbiAke25hbWV9KCR7cGFyYW1ldGVycy5qb2luKFwiLCBcIil9KTogJHtyZXR1cm5UeXBlfSB7XG4gICR7cHJpdmF0ZUNoZWNrfVxuICAke2Fzc2VydFN0cn1cbiAgJHtib2R5fVxuICAke2lzSW5pdCB8fCBoYXNNdXRhdGVTdGF0ZSA/IGBfX3NldFN0YXRlKF9fY29udHJhY3QpO2AgOiBcIlwifVxuICAke2lzVm9pZCB8fCBpc0luaXQgPyBcIlwiIDogXCJyZXR1cm4gcmVzO1wifVxufWBcbiAgICApO1xuICB9XG5cbiAgdmlzaXRDbGFzc0RlY2xhcmF0aW9uKG5vZGU6IENsYXNzRGVjbGFyYXRpb24pOiB2b2lkIHtcbiAgICBpZiAoaXNFbnRyeShub2RlKSAmJiBub2RlLmlzKENvbW1vbkZsYWdzLkVYUE9SVCkpIHtcbiAgICAgIGxldCBuYW1lID0gdG9TdHJpbmcobm9kZS5uYW1lKTtcbiAgICAgIGlmIChDbGFzc0V4cG9ydGVyLmNsYXNzU2Vlbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYENhbm5vdCBleHBvcnQgY2xhc3MgJHtuYW1lfS4gJHtDbGFzc0V4cG9ydGVyLmNsYXNzTmFtZX0gYWxyZWFkeSBleHBvcnRlZC4gYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgQ2xhc3NFeHBvcnRlci5jbGFzc1NlZW4gPSBub2RlO1xuICAgICAgQ2xhc3NFeHBvcnRlci5oYXNDb25zdHJ1Y3RvciA9IG5vZGUubWVtYmVycy5zb21lKChtZW1iZXIpID0+IHtcbiAgICAgICAgaWYgKG1lbWJlciBpbnN0YW5jZW9mIE1ldGhvZERlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIHRvU3RyaW5nKG1lbWJlci5uYW1lKSA9PT0gXCJjb25zdHJ1Y3RvclwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zYi5wdXNoKFxuICAgICAgICBgbGV0IF9fY29udHJhY3Q6ICR7bmFtZX07XG5pZiAoX19jaGVja1N0YXRlKCkpIHtcbiAgX19jb250cmFjdCA9IF9fZ2V0U3RhdGU8JHtuYW1lfT4oKTtcbn0ke1xuICAgICAgICAgICFDbGFzc0V4cG9ydGVyLmhhc0NvbnN0cnVjdG9yXG4gICAgICAgICAgICA/IGAgZWxzZSB7XG4gIF9fY29udHJhY3QgPSBuZXcgJHtuYW1lfSgpO1xufWBcbiAgICAgICAgICAgIDogXCJcIlxuICAgICAgICB9YFxuICAgICAgKTtcbiAgICAgIHRoaXMudmlzaXQobm9kZS5tZW1iZXJzKTtcbiAgICAgIG5vZGUuZmxhZ3MgPSBub2RlLmZsYWdzIF4gQ29tbW9uRmxhZ3MuRVhQT1JUO1xuICAgICAgbGV0IG5ld1N0YXRlbWVudHMgPSBTaW1wbGVQYXJzZXIucGFyc2VUb3BMZXZlbCh0aGlzLnNiLmpvaW4oXCJcXG5cIikpLm1hcChcbiAgICAgICAgKG4pID0+IHtcbiAgICAgICAgICBpZiAobiBpbnN0YW5jZW9mIEZ1bmN0aW9uRGVjbGFyYXRpb24pIHtcbiAgICAgICAgICAgIG4uZmxhZ3MgPSBuLmZsYWdzIHwgQ29tbW9uRmxhZ3MuRVhQT1JUO1xuICAgICAgICAgICAgbi5mbGFncyA9IG4uZmxhZ3MgfCBDb21tb25GbGFncy5NT0RVTEVfRVhQT1JUO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuLnJhbmdlID0gbm9kZS5yYW5nZTtcbiAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIG5vZGUucmFuZ2Uuc291cmNlLnN0YXRlbWVudHMucHVzaCguLi5uZXdTdGF0ZW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICBnZXQgbmFtZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiBcIm5lYXJCaW5kZ2VuXCI7XG4gIH1cblxuICBzdGF0aWMgdmlzaXQoc291cmNlOiBTb3VyY2UpOiB2b2lkIHtcbiAgICBpZiAoc291cmNlLnNvdXJjZUtpbmQgIT0gU291cmNlS2luZC5VU0VSX0VOVFJZKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCB2aXNpdG9yID0gbmV3IENsYXNzRXhwb3J0ZXIoKTtcbiAgICB2aXNpdG9yLnZpc2l0KHNvdXJjZSk7XG4gIH1cbn1cbiJdfQ==
'''
'''--- bindgen/dist/index.js ---
"use strict";
const transformer_1 = require("./transformer");
module.exports = transformer_1.JSONTransformer;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLCtDQUFnRDtBQUVoRCxpQkFBUyw2QkFBZSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSlNPTlRyYW5zZm9ybWVyIH0gZnJvbSBcIi4vdHJhbnNmb3JtZXJcIjtcblxuZXhwb3J0ID0gSlNPTlRyYW5zZm9ybWVyO1xuIl19
'''
'''--- bindgen/dist/transformer.js ---
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.JSONTransformer = void 0;
const as_1 = require("visitor-as/as");
const JSONBuilder_1 = require("./JSONBuilder");
const classExporter_1 = require("./classExporter");
const utils_1 = require("./utils");
class JSONTransformer extends as_1.Transform {
    afterParse(parser) {
        this.parser = parser;
        const writeFile = this.writeFile;
        const baseDir = this.baseDir;
        let newParser = new as_1.Parser(parser.diagnostics);
        // Filter for near files
        let files = JSONBuilder_1.JSONBindingsBuilder.nearFiles(this.parser.sources);
        JSONBuilder_1.JSONBindingsBuilder.checkTestBuild(parser.sources);
        // Visit each file
        files.forEach((source) => {
            if (source.internalPath.includes("index-stub"))
                return;
            let writeOut = /\/\/.*@nearfile .*out/.test(source.text);
            // Remove from logs in parser
            parser.donelog.delete(source.internalPath);
            parser.seenlog.delete(source.internalPath);
            // Remove from programs sources
            this.parser.sources = this.parser.sources.filter((_source) => _source !== source);
            this.program.sources = this.program.sources.filter((_source) => _source !== source);
            // Export main singleton class if one is present
            classExporter_1.ClassExporter.visit(source);
            // Build new Source
            let sourceText = JSONBuilder_1.JSONBindingsBuilder.build(source);
            if (writeOut) {
                writeFile(utils_1.posixRelativePath("out", source.normalizedPath), sourceText, baseDir);
            }
            // Parses file and any new imports added to the source
            newParser.parseFile(sourceText, utils_1.posixRelativePath(JSONBuilder_1.isEntry(source) ? "" : "./", source.normalizedPath), JSONBuilder_1.isEntry(source));
            let newSource = newParser.sources.pop();
            this.program.sources.push(newSource);
            parser.donelog.add(source.internalPath);
            parser.seenlog.add(source.internalPath);
            parser.sources.push(newSource);
        });
        classExporter_1.ClassExporter.classSeen = null;
    }
}
exports.JSONTransformer = JSONTransformer;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNmb3JtZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvdHJhbnNmb3JtZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsc0NBQThFO0FBQzlFLCtDQUE2RDtBQUU3RCxtREFBZ0Q7QUFHaEQsbUNBQTRDO0FBRTVDLE1BQU0sZUFBZ0IsU0FBUSxjQUFTO0lBR3JDLFVBQVUsQ0FBQyxNQUFjO1FBQ3ZCLElBQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDO1FBQ3JCLE1BQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUM7UUFDakMsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQztRQUM3QixJQUFJLFNBQVMsR0FBRyxJQUFJLFdBQU0sQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLENBQUM7UUFFL0Msd0JBQXdCO1FBQ3hCLElBQUksS0FBSyxHQUFHLGlDQUFtQixDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQy9ELGlDQUFtQixDQUFDLGNBQWMsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDbkQsa0JBQWtCO1FBQ2xCLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxNQUFNLEVBQUUsRUFBRTtZQUN2QixJQUFJLE1BQU0sQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFDLFlBQVksQ0FBQztnQkFBRSxPQUFPO1lBQ3ZELElBQUksUUFBUSxHQUFHLHVCQUF1QixDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDekQsNkJBQTZCO1lBQzdCLE1BQU0sQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsQ0FBQztZQUMzQyxNQUFNLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUM7WUFDM0MsK0JBQStCO1lBQy9CLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FDOUMsQ0FBQyxPQUFlLEVBQUUsRUFBRSxDQUFDLE9BQU8sS0FBSyxNQUFNLENBQ3hDLENBQUM7WUFDRixJQUFJLENBQUMsT0FBTyxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQ2hELENBQUMsT0FBZSxFQUFFLEVBQUUsQ0FBQyxPQUFPLEtBQUssTUFBTSxDQUN4QyxDQUFDO1lBQ0YsZ0RBQWdEO1lBQ2hELDZCQUFhLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQzVCLG1CQUFtQjtZQUNuQixJQUFJLFVBQVUsR0FBRyxpQ0FBbUIsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDbkQsSUFBSSxRQUFRLEVBQUU7Z0JBQ1osU0FBUyxDQUNQLHlCQUFpQixDQUFDLEtBQUssRUFBRSxNQUFNLENBQUMsY0FBYyxDQUFDLEVBQy9DLFVBQVUsRUFDVixPQUFPLENBQ1IsQ0FBQzthQUNIO1lBQ0Qsc0RBQXNEO1lBQ3RELFNBQVMsQ0FBQyxTQUFTLENBQ2pCLFVBQVUsRUFDVix5QkFBaUIsQ0FBQyxxQkFBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRSxNQUFNLENBQUMsY0FBYyxDQUFDLEVBQ3JFLHFCQUFPLENBQUMsTUFBTSxDQUFDLENBQ2hCLENBQUM7WUFDRixJQUFJLFNBQVMsR0FBRyxTQUFTLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRyxDQUFDO1lBQ3pDLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztZQUNyQyxNQUFNLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUM7WUFDeEMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDO1lBQ3hDLE1BQU0sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQ2pDLENBQUMsQ0FBQyxDQUFDO1FBRUgsNkJBQWEsQ0FBQyxTQUFTLEdBQUcsSUFBSyxDQUFDO0lBQ2xDLENBQUM7Q0FDRjtBQUVRLDBDQUFlIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVHJhbnNmb3JtLCBQYXJzZXIsIFNvdXJjZSwgTW9kdWxlLCBTb3VyY2VLaW5kIH0gZnJvbSBcInZpc2l0b3ItYXMvYXNcIjtcbmltcG9ydCB7IEpTT05CaW5kaW5nc0J1aWxkZXIsIGlzRW50cnkgfSBmcm9tIFwiLi9KU09OQnVpbGRlclwiO1xuaW1wb3J0IHsgVHlwZUNoZWNrZXIgfSBmcm9tIFwiLi90eXBlQ2hlY2tlclwiO1xuaW1wb3J0IHsgQ2xhc3NFeHBvcnRlciB9IGZyb20gXCIuL2NsYXNzRXhwb3J0ZXJcIjtcbmltcG9ydCB7IHV0aWxzIH0gZnJvbSBcInZpc2l0b3ItYXNcIjtcbmltcG9ydCAqIGFzIHBhdGggZnJvbSBcInBhdGhcIjtcbmltcG9ydCB7IHBvc2l4UmVsYXRpdmVQYXRoIH0gZnJvbSBcIi4vdXRpbHNcIjtcblxuY2xhc3MgSlNPTlRyYW5zZm9ybWVyIGV4dGVuZHMgVHJhbnNmb3JtIHtcbiAgcGFyc2VyOiBQYXJzZXI7XG5cbiAgYWZ0ZXJQYXJzZShwYXJzZXI6IFBhcnNlcik6IHZvaWQge1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIGNvbnN0IHdyaXRlRmlsZSA9IHRoaXMud3JpdGVGaWxlO1xuICAgIGNvbnN0IGJhc2VEaXIgPSB0aGlzLmJhc2VEaXI7XG4gICAgbGV0IG5ld1BhcnNlciA9IG5ldyBQYXJzZXIocGFyc2VyLmRpYWdub3N0aWNzKTtcblxuICAgIC8vIEZpbHRlciBmb3IgbmVhciBmaWxlc1xuICAgIGxldCBmaWxlcyA9IEpTT05CaW5kaW5nc0J1aWxkZXIubmVhckZpbGVzKHRoaXMucGFyc2VyLnNvdXJjZXMpO1xuICAgIEpTT05CaW5kaW5nc0J1aWxkZXIuY2hlY2tUZXN0QnVpbGQocGFyc2VyLnNvdXJjZXMpO1xuICAgIC8vIFZpc2l0IGVhY2ggZmlsZVxuICAgIGZpbGVzLmZvckVhY2goKHNvdXJjZSkgPT4ge1xuICAgICAgaWYgKHNvdXJjZS5pbnRlcm5hbFBhdGguaW5jbHVkZXMoXCJpbmRleC1zdHViXCIpKSByZXR1cm47XG4gICAgICBsZXQgd3JpdGVPdXQgPSAvXFwvXFwvLipAbmVhcmZpbGUgLipvdXQvLnRlc3Qoc291cmNlLnRleHQpO1xuICAgICAgLy8gUmVtb3ZlIGZyb20gbG9ncyBpbiBwYXJzZXJcbiAgICAgIHBhcnNlci5kb25lbG9nLmRlbGV0ZShzb3VyY2UuaW50ZXJuYWxQYXRoKTtcbiAgICAgIHBhcnNlci5zZWVubG9nLmRlbGV0ZShzb3VyY2UuaW50ZXJuYWxQYXRoKTtcbiAgICAgIC8vIFJlbW92ZSBmcm9tIHByb2dyYW1zIHNvdXJjZXNcbiAgICAgIHRoaXMucGFyc2VyLnNvdXJjZXMgPSB0aGlzLnBhcnNlci5zb3VyY2VzLmZpbHRlcihcbiAgICAgICAgKF9zb3VyY2U6IFNvdXJjZSkgPT4gX3NvdXJjZSAhPT0gc291cmNlXG4gICAgICApO1xuICAgICAgdGhpcy5wcm9ncmFtLnNvdXJjZXMgPSB0aGlzLnByb2dyYW0uc291cmNlcy5maWx0ZXIoXG4gICAgICAgIChfc291cmNlOiBTb3VyY2UpID0+IF9zb3VyY2UgIT09IHNvdXJjZVxuICAgICAgKTtcbiAgICAgIC8vIEV4cG9ydCBtYWluIHNpbmdsZXRvbiBjbGFzcyBpZiBvbmUgaXMgcHJlc2VudFxuICAgICAgQ2xhc3NFeHBvcnRlci52aXNpdChzb3VyY2UpO1xuICAgICAgLy8gQnVpbGQgbmV3IFNvdXJjZVxuICAgICAgbGV0IHNvdXJjZVRleHQgPSBKU09OQmluZGluZ3NCdWlsZGVyLmJ1aWxkKHNvdXJjZSk7XG4gICAgICBpZiAod3JpdGVPdXQpIHtcbiAgICAgICAgd3JpdGVGaWxlKFxuICAgICAgICAgIHBvc2l4UmVsYXRpdmVQYXRoKFwib3V0XCIsIHNvdXJjZS5ub3JtYWxpemVkUGF0aCksXG4gICAgICAgICAgc291cmNlVGV4dCxcbiAgICAgICAgICBiYXNlRGlyXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICAvLyBQYXJzZXMgZmlsZSBhbmQgYW55IG5ldyBpbXBvcnRzIGFkZGVkIHRvIHRoZSBzb3VyY2VcbiAgICAgIG5ld1BhcnNlci5wYXJzZUZpbGUoXG4gICAgICAgIHNvdXJjZVRleHQsXG4gICAgICAgIHBvc2l4UmVsYXRpdmVQYXRoKGlzRW50cnkoc291cmNlKSA/IFwiXCIgOiBcIi4vXCIsIHNvdXJjZS5ub3JtYWxpemVkUGF0aCksXG4gICAgICAgIGlzRW50cnkoc291cmNlKVxuICAgICAgKTtcbiAgICAgIGxldCBuZXdTb3VyY2UgPSBuZXdQYXJzZXIuc291cmNlcy5wb3AoKSE7XG4gICAgICB0aGlzLnByb2dyYW0uc291cmNlcy5wdXNoKG5ld1NvdXJjZSk7XG4gICAgICBwYXJzZXIuZG9uZWxvZy5hZGQoc291cmNlLmludGVybmFsUGF0aCk7XG4gICAgICBwYXJzZXIuc2VlbmxvZy5hZGQoc291cmNlLmludGVybmFsUGF0aCk7XG4gICAgICBwYXJzZXIuc291cmNlcy5wdXNoKG5ld1NvdXJjZSk7XG4gICAgfSk7XG5cbiAgICBDbGFzc0V4cG9ydGVyLmNsYXNzU2VlbiA9IG51bGwhO1xuICB9XG59XG5cbmV4cG9ydCB7IEpTT05UcmFuc2Zvcm1lciB9O1xuIl19
'''
'''--- bindgen/dist/typeChecker.js ---
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeChecker = void 0;
const visitor_as_1 = require("visitor-as");
const toIgnore = [
    "builtin",
    ".spec",
    "dataview",
    "date",
    "math",
    "number",
    "string",
    "typedarray",
    "bindings/Date",
    "bindings/Math",
];
class TypeChecker extends visitor_as_1.BaseVisitor {
    check(node) {
        let first = node.text.substring(0, node.text.indexOf("\n"));
        if (!(first.includes("ignore") ||
            toIgnore.some((n) => node.normalizedPath.includes(n)))) {
            this.visit(node);
        }
    }
    static check(node) {
        const typeChecker = new TypeChecker();
        for (let i = 0; i < node.sources.length; i++) {
            typeChecker.check(node.sources[i]);
        }
    }
    visitTypeName(node) {
        const regex = /f32|f64/;
        if (regex.test(node.identifier.text)) {
            let range = node.range;
            let source = range.source;
            let line = source.lineAt(range.start);
            let lineStr = source.text.split("\n")[line - 1];
            TypeChecker.floatsFound.push("\n" +
                " ".repeat(4) +
                lineStr +
                "\n" +
                "in " +
                source.normalizedPath +
                "(" +
                line.toString() +
                "," +
                source.columnAt().toString() +
                ")");
        }
    }
    static checkBinary(node) {
        const wat = node.toText();
        const regex = /f32|f64/;
        if (regex.test(wat)) {
            throw new Error("Floating point numbers are not allowed in smart contracts: Check\n" +
                TypeChecker.floatsFound.join("\n"));
        }
    }
}
exports.TypeChecker = TypeChecker;
TypeChecker.floatsFound = [];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHlwZUNoZWNrZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvdHlwZUNoZWNrZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQ0EsMkNBQXlDO0FBTXpDLE1BQU0sUUFBUSxHQUFHO0lBQ2YsU0FBUztJQUNULE9BQU87SUFDUCxVQUFVO0lBQ1YsTUFBTTtJQUNOLE1BQU07SUFDTixRQUFRO0lBQ1IsUUFBUTtJQUNSLFlBQVk7SUFDWixlQUFlO0lBQ2YsZUFBZTtDQUNoQixDQUFDO0FBRUYsTUFBYSxXQUFZLFNBQVEsd0JBQVc7SUFHMUMsS0FBSyxDQUFDLElBQVk7UUFDaEIsSUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7UUFDNUQsSUFDRSxDQUFDLENBQ0MsS0FBSyxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUM7WUFDeEIsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FDdEQsRUFDRDtZQUNBLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDbEI7SUFDSCxDQUFDO0lBRUQsTUFBTSxDQUFDLEtBQUssQ0FBQyxJQUFZO1FBQ3ZCLE1BQU0sV0FBVyxHQUFHLElBQUksV0FBVyxFQUFFLENBQUM7UUFDdEMsS0FBSyxJQUFJLENBQUMsR0FBUSxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQ2pELFdBQVcsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQ3BDO0lBQ0gsQ0FBQztJQUVELGFBQWEsQ0FBQyxJQUFjO1FBQzFCLE1BQU0sS0FBSyxHQUFtQixTQUFTLENBQUM7UUFDeEMsSUFBSSxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDcEMsSUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQztZQUN2QixJQUFJLE1BQU0sR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDO1lBQzFCLElBQUksSUFBSSxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ3RDLElBQUksT0FBTyxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksR0FBRyxDQUFDLENBQUMsQ0FBQztZQUVoRCxXQUFXLENBQUMsV0FBVyxDQUFDLElBQUksQ0FDMUIsSUFBSTtnQkFDRixHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztnQkFDYixPQUFPO2dCQUNQLElBQUk7Z0JBQ0osS0FBSztnQkFDTCxNQUFNLENBQUMsY0FBYztnQkFDckIsR0FBRztnQkFDSCxJQUFJLENBQUMsUUFBUSxFQUFFO2dCQUNmLEdBQUc7Z0JBQ0gsTUFBTSxDQUFDLFFBQVEsRUFBRSxDQUFDLFFBQVEsRUFBRTtnQkFDNUIsR0FBRyxDQUNOLENBQUM7U0FDSDtJQUNILENBQUM7SUFFRCxNQUFNLENBQUMsV0FBVyxDQUFDLElBQVk7UUFDN0IsTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO1FBQzFCLE1BQU0sS0FBSyxHQUFtQixTQUFTLENBQUM7UUFDeEMsSUFBSSxLQUFLLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFO1lBQ25CLE1BQU0sSUFBSSxLQUFLLENBQ2Isb0VBQW9FO2dCQUNsRSxXQUFXLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FDckMsQ0FBQztTQUNIO0lBQ0gsQ0FBQzs7QUF2REgsa0NBd0RDO0FBdkRRLHVCQUFXLEdBQWEsRUFBRSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVHlwZU5hbWUsIE1vZHVsZSwgU291cmNlLCBQYXJzZXIgfSBmcm9tIFwidmlzaXRvci1hcy9hc1wiO1xuaW1wb3J0IHsgQmFzZVZpc2l0b3IgfSBmcm9tIFwidmlzaXRvci1hc1wiO1xuXG5kZWNsYXJlIGludGVyZmFjZSBSZWdFeHAge1xuICB0ZXN0KHM6IHN0cmluZyk6IGJvb2w7XG59XG5cbmNvbnN0IHRvSWdub3JlID0gW1xuICBcImJ1aWx0aW5cIixcbiAgXCIuc3BlY1wiLFxuICBcImRhdGF2aWV3XCIsXG4gIFwiZGF0ZVwiLFxuICBcIm1hdGhcIixcbiAgXCJudW1iZXJcIixcbiAgXCJzdHJpbmdcIixcbiAgXCJ0eXBlZGFycmF5XCIsXG4gIFwiYmluZGluZ3MvRGF0ZVwiLFxuICBcImJpbmRpbmdzL01hdGhcIixcbl07XG5cbmV4cG9ydCBjbGFzcyBUeXBlQ2hlY2tlciBleHRlbmRzIEJhc2VWaXNpdG9yIHtcbiAgc3RhdGljIGZsb2F0c0ZvdW5kOiBzdHJpbmdbXSA9IFtdO1xuXG4gIGNoZWNrKG5vZGU6IFNvdXJjZSk6IHZvaWQge1xuICAgIGxldCBmaXJzdCA9IG5vZGUudGV4dC5zdWJzdHJpbmcoMCwgbm9kZS50ZXh0LmluZGV4T2YoXCJcXG5cIikpO1xuICAgIGlmIChcbiAgICAgICEoXG4gICAgICAgIGZpcnN0LmluY2x1ZGVzKFwiaWdub3JlXCIpIHx8XG4gICAgICAgIHRvSWdub3JlLnNvbWUoKG4pID0+IG5vZGUubm9ybWFsaXplZFBhdGguaW5jbHVkZXMobikpXG4gICAgICApXG4gICAgKSB7XG4gICAgICB0aGlzLnZpc2l0KG5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBjaGVjayhub2RlOiBQYXJzZXIpOiB2b2lkIHtcbiAgICBjb25zdCB0eXBlQ2hlY2tlciA9IG5ldyBUeXBlQ2hlY2tlcigpO1xuICAgIGZvciAobGV0IGk6IGkzMiA9IDA7IGkgPCBub2RlLnNvdXJjZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHR5cGVDaGVja2VyLmNoZWNrKG5vZGUuc291cmNlc1tpXSk7XG4gICAgfVxuICB9XG5cbiAgdmlzaXRUeXBlTmFtZShub2RlOiBUeXBlTmFtZSk6IHZvaWQge1xuICAgIGNvbnN0IHJlZ2V4OiBSZWdFeHAgPSA8UmVnRXhwPi9mMzJ8ZjY0LztcbiAgICBpZiAocmVnZXgudGVzdChub2RlLmlkZW50aWZpZXIudGV4dCkpIHtcbiAgICAgIGxldCByYW5nZSA9IG5vZGUucmFuZ2U7XG4gICAgICBsZXQgc291cmNlID0gcmFuZ2Uuc291cmNlO1xuICAgICAgbGV0IGxpbmUgPSBzb3VyY2UubGluZUF0KHJhbmdlLnN0YXJ0KTtcbiAgICAgIGxldCBsaW5lU3RyID0gc291cmNlLnRleHQuc3BsaXQoXCJcXG5cIilbbGluZSAtIDFdO1xuXG4gICAgICBUeXBlQ2hlY2tlci5mbG9hdHNGb3VuZC5wdXNoKFxuICAgICAgICBcIlxcblwiICtcbiAgICAgICAgICBcIiBcIi5yZXBlYXQoNCkgK1xuICAgICAgICAgIGxpbmVTdHIgK1xuICAgICAgICAgIFwiXFxuXCIgK1xuICAgICAgICAgIFwiaW4gXCIgK1xuICAgICAgICAgIHNvdXJjZS5ub3JtYWxpemVkUGF0aCArXG4gICAgICAgICAgXCIoXCIgK1xuICAgICAgICAgIGxpbmUudG9TdHJpbmcoKSArXG4gICAgICAgICAgXCIsXCIgK1xuICAgICAgICAgIHNvdXJjZS5jb2x1bW5BdCgpLnRvU3RyaW5nKCkgK1xuICAgICAgICAgIFwiKVwiXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBjaGVja0JpbmFyeShub2RlOiBNb2R1bGUpIHtcbiAgICBjb25zdCB3YXQgPSBub2RlLnRvVGV4dCgpO1xuICAgIGNvbnN0IHJlZ2V4OiBSZWdFeHAgPSA8UmVnRXhwPi9mMzJ8ZjY0LztcbiAgICBpZiAocmVnZXgudGVzdCh3YXQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiRmxvYXRpbmcgcG9pbnQgbnVtYmVycyBhcmUgbm90IGFsbG93ZWQgaW4gc21hcnQgY29udHJhY3RzOiBDaGVja1xcblwiICtcbiAgICAgICAgICBUeXBlQ2hlY2tlci5mbG9hdHNGb3VuZC5qb2luKFwiXFxuXCIpXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuIl19
'''
'''--- bindgen/dist/utils.js ---
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeSnakeCase = exports.toString = exports.posixRelativePath = exports.SimpleParser = void 0;
//@ts-ignore
let path = require("path");
const as_1 = require("visitor-as/as");
class SimpleParser {
    static getTokenizer(s) {
        return new as_1.Tokenizer(new as_1.Source(as_1.SourceKind.USER, "index.ts", s));
    }
    static parseExpression(s) {
        let res = this.parser.parseExpression(this.getTokenizer(s));
        if (res == null) {
            throw new Error("Failed to parse the expression: '" + s + "'");
        }
        return res;
    }
    static parseStatement(s, topLevel = false) {
        let res = this.parser.parseStatement(this.getTokenizer(s), topLevel);
        if (res == null) {
            throw new Error("Failed to parse the expression: '" + s + "'");
        }
        return res;
    }
    static parseTopLevel(s) {
        let tn = this.getTokenizer(s);
        let statements = [];
        while (!tn.skip(as_1.Token.ENDOFFILE)) {
            let statement = this.parser.parseTopLevelStatement(tn);
            if (statement) {
                statements.push(statement);
            }
            else {
                this.parser.skipStatement(tn);
            }
        }
        return statements;
    }
    static parseMethodDeclaration(s, parent) {
        let tn = this.getTokenizer(s);
        let res = this.parser.parseClassMember(tn, parent);
        if (res == null) {
            throw new Error("Failed to parse class member: '" + s + "'");
        }
        if (!(res instanceof as_1.MethodDeclaration)) {
            throw new Error("'" + s + "' is not a method declaration");
        }
        return res;
    }
}
exports.SimpleParser = SimpleParser;
SimpleParser.parser = new as_1.Parser();
function posixRelativePath(from, to) {
    const relativePath = path.relative(from, to);
    return relativePath.split(path.sep).join(path.posix.sep);
}
exports.posixRelativePath = posixRelativePath;
function toString(node) {
    return as_1.ASTBuilder.build(node);
}
exports.toString = toString;
const capitalPattern = /([a-z])([A-Z])/g;
const doubleCapital = /([A-Z])([A-Z][a-z])/g;
function makeSnakeCase(s) {
    return s
        .replace(capitalPattern, "$1_$2")
        .replace(doubleCapital, "$1_$2")
        .toLowerCase();
}
exports.makeSnakeCase = makeSnakeCase;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsWUFBWTtBQUNaLElBQUksSUFBSSxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUUzQixzQ0FZdUI7QUFFdkIsTUFBYSxZQUFZO0lBR2YsTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFTO1FBQ25DLE9BQU8sSUFBSSxjQUFTLENBQUMsSUFBSSxXQUFNLENBQUMsZUFBVSxDQUFDLElBQUksRUFBRSxVQUFVLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNuRSxDQUFDO0lBRUQsTUFBTSxDQUFDLGVBQWUsQ0FBQyxDQUFTO1FBQzlCLElBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUM1RCxJQUFJLEdBQUcsSUFBSSxJQUFJLEVBQUU7WUFDZixNQUFNLElBQUksS0FBSyxDQUFDLG1DQUFtQyxHQUFHLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQztTQUNoRTtRQUNELE9BQU8sR0FBRyxDQUFDO0lBQ2IsQ0FBQztJQUVELE1BQU0sQ0FBQyxjQUFjLENBQUMsQ0FBUyxFQUFFLFdBQW9CLEtBQUs7UUFDeEQsSUFBSSxHQUFHLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsRUFBRSxRQUFRLENBQUMsQ0FBQztRQUNyRSxJQUFJLEdBQUcsSUFBSSxJQUFJLEVBQUU7WUFDZixNQUFNLElBQUksS0FBSyxDQUFDLG1DQUFtQyxHQUFHLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQztTQUNoRTtRQUNELE9BQU8sR0FBRyxDQUFDO0lBQ2IsQ0FBQztJQUVELE1BQU0sQ0FBQyxhQUFhLENBQUMsQ0FBUztRQUM1QixJQUFJLEVBQUUsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzlCLElBQUksVUFBVSxHQUFnQixFQUFFLENBQUM7UUFDakMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsVUFBSyxDQUFDLFNBQVMsQ0FBQyxFQUFFO1lBQ2hDLElBQUksU0FBUyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsc0JBQXNCLENBQUMsRUFBRSxDQUFDLENBQUM7WUFDdkQsSUFBSSxTQUFTLEVBQUU7Z0JBQ2IsVUFBVSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQzthQUM1QjtpQkFBTTtnQkFDTCxJQUFJLENBQUMsTUFBTSxDQUFDLGFBQWEsQ0FBQyxFQUFFLENBQUMsQ0FBQzthQUMvQjtTQUNGO1FBQ0QsT0FBTyxVQUFVLENBQUM7SUFDcEIsQ0FBQztJQUVELE1BQU0sQ0FBQyxzQkFBc0IsQ0FDM0IsQ0FBUyxFQUNULE1BQXdCO1FBRXhCLElBQUksRUFBRSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDOUIsSUFBSSxHQUFHLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxFQUFFLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFDbkQsSUFBSSxHQUFHLElBQUksSUFBSSxFQUFFO1lBQ2YsTUFBTSxJQUFJLEtBQUssQ0FBQyxpQ0FBaUMsR0FBRyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUM7U0FDOUQ7UUFDRCxJQUFJLENBQUMsQ0FBQyxHQUFHLFlBQVksc0JBQWlCLENBQUMsRUFBRTtZQUN2QyxNQUFNLElBQUksS0FBSyxDQUFDLEdBQUcsR0FBRyxDQUFDLEdBQUcsK0JBQStCLENBQUMsQ0FBQztTQUM1RDtRQUNELE9BQU8sR0FBRyxDQUFDO0lBQ2IsQ0FBQzs7QUFsREgsb0NBbURDO0FBbERnQixtQkFBTSxHQUFHLElBQUksV0FBTSxFQUFFLENBQUM7QUFvRHZDLFNBQWdCLGlCQUFpQixDQUFDLElBQVksRUFBRSxFQUFVO0lBQ3hELE1BQU0sWUFBWSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxDQUFDO0lBQzdDLE9BQU8sWUFBWSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDM0QsQ0FBQztBQUhELDhDQUdDO0FBRUQsU0FBZ0IsUUFBUSxDQUFDLElBQVU7SUFDakMsT0FBTyxlQUFVLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ2hDLENBQUM7QUFGRCw0QkFFQztBQUVELE1BQU0sY0FBYyxHQUFHLGlCQUFpQixDQUFDO0FBQ3pDLE1BQU0sYUFBYSxHQUFHLHNCQUFzQixDQUFDO0FBRTdDLFNBQWdCLGFBQWEsQ0FBQyxDQUFTO0lBQ3JDLE9BQU8sQ0FBQztTQUNMLE9BQU8sQ0FBQyxjQUFjLEVBQUUsT0FBTyxDQUFDO1NBQ2hDLE9BQU8sQ0FBQyxhQUFhLEVBQUUsT0FBTyxDQUFDO1NBQy9CLFdBQVcsRUFBRSxDQUFDO0FBQ25CLENBQUM7QUFMRCxzQ0FLQyIsInNvdXJjZXNDb250ZW50IjpbIi8vQHRzLWlnbm9yZVxubGV0IHBhdGggPSByZXF1aXJlKFwicGF0aFwiKTtcblxuaW1wb3J0IHtcbiAgVG9rZW4sXG4gIEV4cHJlc3Npb24sXG4gIFRva2VuaXplcixcbiAgUGFyc2VyLFxuICBTb3VyY2UsXG4gIFNvdXJjZUtpbmQsXG4gIFN0YXRlbWVudCxcbiAgQVNUQnVpbGRlcixcbiAgTm9kZSxcbiAgTWV0aG9kRGVjbGFyYXRpb24sXG4gIENsYXNzRGVjbGFyYXRpb24sXG59IGZyb20gXCJ2aXNpdG9yLWFzL2FzXCI7XG5cbmV4cG9ydCBjbGFzcyBTaW1wbGVQYXJzZXIge1xuICBwcml2YXRlIHN0YXRpYyBwYXJzZXIgPSBuZXcgUGFyc2VyKCk7XG5cbiAgcHJpdmF0ZSBzdGF0aWMgZ2V0VG9rZW5pemVyKHM6IHN0cmluZyk6IFRva2VuaXplciB7XG4gICAgcmV0dXJuIG5ldyBUb2tlbml6ZXIobmV3IFNvdXJjZShTb3VyY2VLaW5kLlVTRVIsIFwiaW5kZXgudHNcIiwgcykpO1xuICB9XG5cbiAgc3RhdGljIHBhcnNlRXhwcmVzc2lvbihzOiBzdHJpbmcpOiBFeHByZXNzaW9uIHtcbiAgICBsZXQgcmVzID0gdGhpcy5wYXJzZXIucGFyc2VFeHByZXNzaW9uKHRoaXMuZ2V0VG9rZW5pemVyKHMpKTtcbiAgICBpZiAocmVzID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBwYXJzZSB0aGUgZXhwcmVzc2lvbjogJ1wiICsgcyArIFwiJ1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuXG4gIHN0YXRpYyBwYXJzZVN0YXRlbWVudChzOiBzdHJpbmcsIHRvcExldmVsOiBib29sZWFuID0gZmFsc2UpOiBTdGF0ZW1lbnQge1xuICAgIGxldCByZXMgPSB0aGlzLnBhcnNlci5wYXJzZVN0YXRlbWVudCh0aGlzLmdldFRva2VuaXplcihzKSwgdG9wTGV2ZWwpO1xuICAgIGlmIChyZXMgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIHBhcnNlIHRoZSBleHByZXNzaW9uOiAnXCIgKyBzICsgXCInXCIpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiAgc3RhdGljIHBhcnNlVG9wTGV2ZWwoczogc3RyaW5nKTogU3RhdGVtZW50W10ge1xuICAgIGxldCB0biA9IHRoaXMuZ2V0VG9rZW5pemVyKHMpO1xuICAgIGxldCBzdGF0ZW1lbnRzOiBTdGF0ZW1lbnRbXSA9IFtdO1xuICAgIHdoaWxlICghdG4uc2tpcChUb2tlbi5FTkRPRkZJTEUpKSB7XG4gICAgICBsZXQgc3RhdGVtZW50ID0gdGhpcy5wYXJzZXIucGFyc2VUb3BMZXZlbFN0YXRlbWVudCh0bik7XG4gICAgICBpZiAoc3RhdGVtZW50KSB7XG4gICAgICAgIHN0YXRlbWVudHMucHVzaChzdGF0ZW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wYXJzZXIuc2tpcFN0YXRlbWVudCh0bik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZW1lbnRzO1xuICB9XG5cbiAgc3RhdGljIHBhcnNlTWV0aG9kRGVjbGFyYXRpb24oXG4gICAgczogc3RyaW5nLFxuICAgIHBhcmVudDogQ2xhc3NEZWNsYXJhdGlvblxuICApOiBNZXRob2REZWNsYXJhdGlvbiB7XG4gICAgbGV0IHRuID0gdGhpcy5nZXRUb2tlbml6ZXIocyk7XG4gICAgbGV0IHJlcyA9IHRoaXMucGFyc2VyLnBhcnNlQ2xhc3NNZW1iZXIodG4sIHBhcmVudCk7XG4gICAgaWYgKHJlcyA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gcGFyc2UgY2xhc3MgbWVtYmVyOiAnXCIgKyBzICsgXCInXCIpO1xuICAgIH1cbiAgICBpZiAoIShyZXMgaW5zdGFuY2VvZiBNZXRob2REZWNsYXJhdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIidcIiArIHMgKyBcIicgaXMgbm90IGEgbWV0aG9kIGRlY2xhcmF0aW9uXCIpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwb3NpeFJlbGF0aXZlUGF0aChmcm9tOiBzdHJpbmcsIHRvOiBzdHJpbmcpOiBzdHJpbmcge1xuICBjb25zdCByZWxhdGl2ZVBhdGggPSBwYXRoLnJlbGF0aXZlKGZyb20sIHRvKTtcbiAgcmV0dXJuIHJlbGF0aXZlUGF0aC5zcGxpdChwYXRoLnNlcCkuam9pbihwYXRoLnBvc2l4LnNlcCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b1N0cmluZyhub2RlOiBOb2RlKTogc3RyaW5nIHtcbiAgcmV0dXJuIEFTVEJ1aWxkZXIuYnVpbGQobm9kZSk7XG59XG5cbmNvbnN0IGNhcGl0YWxQYXR0ZXJuID0gLyhbYS16XSkoW0EtWl0pL2c7XG5jb25zdCBkb3VibGVDYXBpdGFsID0gLyhbQS1aXSkoW0EtWl1bYS16XSkvZztcblxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VTbmFrZUNhc2Uoczogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIHNcbiAgICAucmVwbGFjZShjYXBpdGFsUGF0dGVybiwgXCIkMV8kMlwiKVxuICAgIC5yZXBsYWNlKGRvdWJsZUNhcGl0YWwsIFwiJDFfJDJcIilcbiAgICAudG9Mb3dlckNhc2UoKTtcbn1cbiJdfQ==
'''
'''--- bindgen/index.js ---
module.exports = require("./dist");
'''
'''--- bindgen/test.js ---
const v8 = require('v8');
const fs = require('fs');
const assert = require('assert');
let asc = require("assemblyscript/cli/asc");
const loader = require('assemblyscript/lib/loader');
const path = require('path');

const nodeVersion = process.versions.node;

if (
    parseInt(nodeVersion.substring(0, nodeVersion.indexOf('.'))) < 16
) {
    v8.setFlagsFromString("--experimental-wasm-bigint");
}

function localize(p) { return path.join(__dirname, p); }

function toNum(x) { return parseInt(x.toString());}
// http://www.onicos.com/staff/iz/amuse/javascript/expert/utf.txt

/* utf.js - UTF-8 <=> UTF-16 convertion
 *
 * Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>
 * Version: 1.0
 * LastModified: Dec 25 1999
 * This library is free.  You can redistribute it and/or modify it.
 */

function UTF8toStr(array) {
    var out, i, len, c;
    var char2, char3;

    out = "";
    len = array.length;
    i = 0;
    while(i < len) {
    c = array[i++];
    switch(c >> 4)
    {
      case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7:
        // 0xxxxxxx
        out += String.fromCharCode(c);
        break;
      case 12: case 13:
        // 110x xxxx   10xx xxxx
        char2 = array[i++];
        out += String.fromCharCode(((c & 0x1F) << 6) | (char2 & 0x3F));
        break;
      case 14:
        // 1110 xxxx  10xx xxxx  10xx xxxx
        char2 = array[i++];
        char3 = array[i++];
        out += String.fromCharCode(((c & 0x0F) << 12) |
                       ((char2 & 0x3F) << 6) |
                       ((char3 & 0x3F) << 0));
        break;
    }
    }

    return out;
}

async function loadModule(path) {
    let inputJson = null;
    let outputJson = null;
    let module;
    let mem = { get U8() {
                  return new Uint8Array(module.exports.memory.buffer);
    }}
    module = loader.instantiateSync(fs.readFileSync(path), {
        env: {
            abort(msg, file, line, column) {
                if (module) {
                    if (msg) {
                        msg = module.exports.__getString(msg);
                    }
                    if (file) {
                        file = module.exports.__getString(file);
                    }
                }
                console.log("abort called: %s %s:%s:%s", msg, file, line, column);
            },
            panic(){

            },
            log_utf8(len, ptr) {
                if (module) {
                    str = UTF8toStr(readBuffer(toNum(len), toNum(ptr)));
                }
                console.log(str || "Failed to read string");
            },
            read_register(register_id, ptr) {
                copyToPtr(inputJson, toNum(ptr))
            },
            register_len(register_id) {
                return BigInt(inputJson.length)
            },
            value_return(valLen, valPtr) {
                outputJson = readBuffer(toNum(valLen), toNum(valPtr));
            },
            input(register_id) {

            },
            attached_deposit() {
              return 0;
            }
        }
    });

    function setInputJson(json) {
        inputJson = Buffer.from(JSON.stringify(json || null));
    }

    function getOutputJson() {
        if (!outputJson) return null;
        return JSON.parse(Buffer.from(outputJson).toString());
    }

    function copyToPtr(fromBuf, toPtr) {
        for (let i = 0; i < fromBuf.length; i++) {
            mem.U8[toPtr + i] = fromBuf[i];
        }
    }

    function readBuffer(valLen, valPtr) {
        const result = new Uint8Array(valLen);
        for (let i = 0; i < valLen; i++) {
            result[i] = mem.U8[valPtr + i];
        }

        return result;
    }

    let wrapped = {};
    const exports = module.exports;
    Object.keys(exports).forEach(methodName => {
        wrapped[methodName] = async function(inputJson) {
            setInputJson(inputJson);
            outputJson = null;
            await exports[methodName].call(module);
            return getOutputJson();
        }
    });
    return wrapped;
}

(async function() {
    const module = await loadModule(localize("/build/debug/test.wasm"));
    await module.runTest();
    assert(module.run_test);
    assert(module.some_export);
    assert(module.change_user_api_key);
    assert.deepStrictEqual(await module.convertFoobars({ foobars: [] }), []);
    assert.deepStrictEqual(
      await module.convertFoobars({
        foobars: [{ foo: -12345, bar: 123, flag: true, baz: "bazinga" }]
      }),
      [
        {
          foobar: {
            foo: -12345,
            bar: 123,
            u64Val: (2 ** 32 + 1).toString(),
            i64Val: "-64",
            f32: 3.140000104904175,
            f64: 3.141592653589793238462643383279,
            f32_zero: 0,
            f64_zero: 0,
            flag: true,
            baz: "bazinga",
            uint8array: null,
            arr: null,
            u32Arr: null,
            i32Arr: null,
            u128Val: null,
            uint8arrays: null,
            u64Arr: null,
            u64_zero: "0",
          }
        }
      ]
    );
    assert.deepStrictEqual(
      await module.convertFoobars({
        foobars: [{ arr: [["1", "2"], ["3"]] }]
      }),
      [
        {
          foobar: {
            foo: 0,
            bar: 1,
            u64Val: "4294967297",
            i64Val: "-64",
            f32: 3.140000104904175,
            f64: 3.141592653589793238462643383279,
            f32_zero: 0,
            f64_zero: 0,
            flag: false,
            baz: "123",
            uint8array: null,
            u128Val: null,
            arr: [["1", "2"], ["3"]],
            u32Arr: null,
            i32Arr: null,
            uint8arrays: null,
            u64Arr: null,
            u64_zero: "0"
          }
        }
      ]
    );
    assert.equal(
      await module.getStringArrayLength({ arr: ["1", "2", "3"] }),
      3
    );
    assert.deepStrictEqual(
      await module.rewrapFoobar({ container: { foobar: { foo: 123 } } }),
      {
        foobars: [
          [
            {
              foo: 123,
              bar: 1,
              u64Val: "4294967297",
              i64Val: "-64",
              f32: 3.140000104904175,
              f64: 3.141592653589793238462643383279,
              f32_zero: 0,
              f64_zero: 0,
              flag: false,
              baz: "123",
              uint8array: null,
              arr: null,
              u32Arr: null,
              i32Arr: null,
              uint8arrays: null,
              u128Val: null,
              u64Arr: null,
              u64_zero: "0"
            }
          ]
        ]
      }
    );
    assert.deepStrictEqual(
      await module.unwrapFoobar({ container: { foobars: [[{ foo: 123 }]] } }),
      {
        foo: 123,
        bar: 1,
        u64Val: "4294967297",
        i64Val: "-64",
        f32: 3.140000104904175,
        f64: 3.141592653589793238462643383279,
        f32_zero: 0,
        f64_zero: 0,
        u128Val: null,
        flag: false,
        baz: "123",
        uint8array: null,
        arr: null,
        u32Arr: null,
        i32Arr: null,
        uint8arrays: null,
        u64Arr: null,
        u64_zero: "0"
      }
    );
    assert.deepStrictEqual(await module.stringOrNull(), null);
    assert.deepStrictEqual(
      await module.stringAliasTest({ str: "Hello" }),
      "Hello World"
    );

    assert.deepStrictEqual(await module.classOrNull(),
      {
        foo: 0,
        bar: 1,
        u64Val: "4294967297",
        i64Val: "-64",
        f32: 3.140000104904175,
        f64: 3.141592653589793238462643383279,
        f32_zero: 0,
        f64_zero: 0,
        flag: false,
        baz: "123",
        uint8array: null,
        arr: null,
        u32Arr: null,
        i32Arr: null,
        uint8arrays: null,
        u128Val: null,
        u64Arr: null,
        u64_zero: "0"
      }
    );
    assert.deepStrictEqual(await module.classAndNull(), null);

})().catch(e => {
    console.error('Error during test execution:', e);
    if (e.code == 'ERR_ASSERTION') {
        console.log('EXPECTED:\n%s', JSON.stringify(e.expected));
        console.log('ACTUAL:\n%s', JSON.stringify(e.actual));
    }
    process.exit(1);
});

'''
'''--- docs.js ---
const TypeDoc = require("typedoc");

async function main() {
    const app = new TypeDoc.Application();

    // Load tsconfig.json / typedoc.json files
    app.options.addReader(new TypeDoc.TSConfigReader());
    app.options.addReader(new TypeDoc.TypeDocReader());

    app.bootstrap({});

    const project = app.converter.convert(app.getEntryPoints() ?? []);

    if (project) {
        const outputDir = "docs";
        await app.generateDocs(project, outputDir);
    }
}

main().catch(console.error);
'''
'''--- jest.config.js ---
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  testMatch: ["**/__tests__/**/*.spec.ts"],
  testPathIgnorePatterns: ["/assembly/", "/node_modules/"],
};

'''
'''--- near-mock-vm/bin/bin.js ---
#!/usr/bin/env node
require("../vm/dist/cli");

'''
'''--- near-mock-vm/pkg/near_mock_vm.js ---
let imports = {};
imports['__wbindgen_placeholder__'] = module.exports;
let wasm;
const { TextDecoder, TextEncoder } = require(String.raw`util`);

const heap = new Array(32).fill(undefined);

heap.push(undefined, null, true, false);

function getObject(idx) { return heap[idx]; }

let heap_next = heap.length;

function dropObject(idx) {
    if (idx < 36) return;
    heap[idx] = heap_next;
    heap_next = idx;
}

function takeObject(idx) {
    const ret = getObject(idx);
    dropObject(idx);
    return ret;
}

function addHeapObject(obj) {
    if (heap_next === heap.length) heap.push(heap.length + 1);
    const idx = heap_next;
    heap_next = heap[idx];

    heap[idx] = obj;
    return idx;
}

let cachedTextDecoder = new TextDecoder('utf-8', { ignoreBOM: true, fatal: true });

cachedTextDecoder.decode();

let cachegetUint8Memory0 = null;
function getUint8Memory0() {
    if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== wasm.memory.buffer) {
        cachegetUint8Memory0 = new Uint8Array(wasm.memory.buffer);
    }
    return cachegetUint8Memory0;
}

function getStringFromWasm0(ptr, len) {
    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
}

function isLikeNone(x) {
    return x === undefined || x === null;
}

let cachegetFloat64Memory0 = null;
function getFloat64Memory0() {
    if (cachegetFloat64Memory0 === null || cachegetFloat64Memory0.buffer !== wasm.memory.buffer) {
        cachegetFloat64Memory0 = new Float64Array(wasm.memory.buffer);
    }
    return cachegetFloat64Memory0;
}

let cachegetInt32Memory0 = null;
function getInt32Memory0() {
    if (cachegetInt32Memory0 === null || cachegetInt32Memory0.buffer !== wasm.memory.buffer) {
        cachegetInt32Memory0 = new Int32Array(wasm.memory.buffer);
    }
    return cachegetInt32Memory0;
}

let WASM_VECTOR_LEN = 0;

let cachedTextEncoder = new TextEncoder('utf-8');

const encodeString = (typeof cachedTextEncoder.encodeInto === 'function'
    ? function (arg, view) {
    return cachedTextEncoder.encodeInto(arg, view);
}
    : function (arg, view) {
    const buf = cachedTextEncoder.encode(arg);
    view.set(buf);
    return {
        read: arg.length,
        written: buf.length
    };
});

function passStringToWasm0(arg, malloc, realloc) {

    if (realloc === undefined) {
        const buf = cachedTextEncoder.encode(arg);
        const ptr = malloc(buf.length);
        getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);
        WASM_VECTOR_LEN = buf.length;
        return ptr;
    }

    let len = arg.length;
    let ptr = malloc(len);

    const mem = getUint8Memory0();

    let offset = 0;

    for (; offset < len; offset++) {
        const code = arg.charCodeAt(offset);
        if (code > 0x7F) break;
        mem[ptr + offset] = code;
    }

    if (offset !== len) {
        if (offset !== 0) {
            arg = arg.slice(offset);
        }
        ptr = realloc(ptr, len, len = offset + arg.length * 3);
        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);
        const ret = encodeString(arg, view);

        offset += ret.written;
    }

    WASM_VECTOR_LEN = offset;
    return ptr;
}

function debugString(val) {
    // primitive types
    const type = typeof val;
    if (type == 'number' || type == 'boolean' || val == null) {
        return  `${val}`;
    }
    if (type == 'string') {
        return `"${val}"`;
    }
    if (type == 'symbol') {
        const description = val.description;
        if (description == null) {
            return 'Symbol';
        } else {
            return `Symbol(${description})`;
        }
    }
    if (type == 'function') {
        const name = val.name;
        if (typeof name == 'string' && name.length > 0) {
            return `Function(${name})`;
        } else {
            return 'Function';
        }
    }
    // objects
    if (Array.isArray(val)) {
        const length = val.length;
        let debug = '[';
        if (length > 0) {
            debug += debugString(val[0]);
        }
        for(let i = 1; i < length; i++) {
            debug += ', ' + debugString(val[i]);
        }
        debug += ']';
        return debug;
    }
    // Test for built-in
    const builtInMatches = /\[object ([^\]]+)\]/.exec(toString.call(val));
    let className;
    if (builtInMatches.length > 1) {
        className = builtInMatches[1];
    } else {
        // Failed to match the standard '[object ClassName]'
        return toString.call(val);
    }
    if (className == 'Object') {
        // we're a user defined class or Object
        // JSON.stringify avoids problems with cycles, and is generally much
        // easier than looping through ownProperties of `val`.
        try {
            return 'Object(' + JSON.stringify(val) + ')';
        } catch (_) {
            return 'Object';
        }
    }
    // errors
    if (val instanceof Error) {
        return `${val.name}: ${val.message}\n${val.stack}`;
    }
    // TODO we could test for more things here, like `Set`s and `Map`s.
    return className;
}
/**
*/
module.exports.main = function() {
    wasm.main();
};

/**
* @param {any} wasm_bytes
* @returns {any}
*/
module.exports.inject_contract = function(wasm_bytes) {
    var ret = wasm.inject_contract(addHeapObject(wasm_bytes));
    return takeObject(ret);
};

/**
* @param {any} mem
*/
module.exports.test_memory = function(mem) {
    wasm.test_memory(addHeapObject(mem));
};

const u32CvtShim = new Uint32Array(2);

const uint64CvtShim = new BigUint64Array(u32CvtShim.buffer);

function getArrayU8FromWasm0(ptr, len) {
    return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);
}

function handleError(f) {
    return function () {
        try {
            return f.apply(this, arguments);

        } catch (e) {
            wasm.__wbindgen_exn_store(addHeapObject(e));
        }
    };
}
/**
*/
class VM {

    static __wrap(ptr) {
        const obj = Object.create(VM.prototype);
        obj.ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_vm_free(ptr);
    }
    /**
    * @param {any} context
    * @param {any} mem
    */
    constructor(context, mem) {
        var ret = wasm.vm_new(addHeapObject(context), addHeapObject(mem));
        return VM.__wrap(ret);
    }
    /**
    */
    reset() {
        wasm.vm_reset(this.ptr);
    }
    /**
    * @param {any} context
    */
    set_context(context) {
        wasm.vm_set_context(this.ptr, addHeapObject(context));
    }
    /**
    * @param {any} s
    */
    set_current_account_id(s) {
        wasm.vm_set_current_account_id(this.ptr, addHeapObject(s));
    }
    /**
    * @param {any} s
    */
    set_input(s) {
        wasm.vm_set_input(this.ptr, addHeapObject(s));
    }
    /**
    * @param {any} s
    */
    set_signer_account_id(s) {
        wasm.vm_set_signer_account_id(this.ptr, addHeapObject(s));
    }
    /**
    * The public key that was used to sign the original transaction that led to
    * this execution.
    * @param {any} s
    */
    set_signer_account_pk(s) {
        wasm.vm_set_signer_account_pk(this.ptr, addHeapObject(s));
    }
    /**
    * @param {any} s
    */
    set_predecessor_account_id(s) {
        wasm.vm_set_predecessor_account_id(this.ptr, addHeapObject(s));
    }
    /**
    * @param {BigInt} block_height
    */
    set_block_index(block_height) {
        uint64CvtShim[0] = block_height;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        wasm.vm_set_block_index(this.ptr, low0, high0);
    }
    /**
    * @param {BigInt} stmp
    */
    set_block_timestamp(stmp) {
        uint64CvtShim[0] = stmp;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        wasm.vm_set_block_timestamp(this.ptr, low0, high0);
    }
    /**
    * @param {any} u_128
    */
    set_account_balance(u_128) {
        wasm.vm_set_account_balance(this.ptr, addHeapObject(u_128));
    }
    /**
    * @param {any} u_128
    */
    set_account_locked_balance(u_128) {
        wasm.vm_set_account_locked_balance(this.ptr, addHeapObject(u_128));
    }
    /**
    * @param {BigInt} amt
    */
    set_storage_usage(amt) {
        uint64CvtShim[0] = amt;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        wasm.vm_set_storage_usage(this.ptr, low0, high0);
    }
    /**
    * @param {any} u_128
    */
    set_attached_deposit(u_128) {
        wasm.vm_set_attached_deposit(this.ptr, addHeapObject(u_128));
    }
    /**
    * @param {BigInt} _u64
    */
    set_prepaid_gas(_u64) {
        uint64CvtShim[0] = _u64;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        wasm.vm_set_prepaid_gas(this.ptr, low0, high0);
    }
    /**
    * @param {any} s
    */
    set_random_seed(s) {
        wasm.vm_set_random_seed(this.ptr, addHeapObject(s));
    }
    /**
    * @param {boolean} b
    */
    set_is_view(b) {
        wasm.vm_set_is_view(this.ptr, b);
    }
    /**
    * @param {any} arr
    */
    set_output_data_receivers(arr) {
        wasm.vm_set_output_data_receivers(this.ptr, addHeapObject(arr));
    }
    /**
    * @param {BigInt} _u64
    */
    set_epoch_height(_u64) {
        uint64CvtShim[0] = _u64;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        wasm.vm_set_epoch_height(this.ptr, low0, high0);
    }
    /**
    * @param {any} s
    * @param {any} u_128
    */
    set_validator(s, u_128) {
        wasm.vm_set_validator(this.ptr, addHeapObject(s), addHeapObject(u_128));
    }
    /**
    * #################
    * # Registers API #
    * #################
    * Writes the entire content from the register `register_id` into the memory of the guest starting with `ptr`.
    *
    * # Arguments
    *
    * * `register_id` -- a register id from where to read the data;
    * * `ptr` -- location on guest memory where to copy the data.
    *
    * # Errors
    *
    * * If the content extends outside the memory allocated to the guest. In Wasmer, it returns `MemoryAccessViolation` error message;
    * * If `register_id` is pointing to unused register returns `InvalidRegisterId` error message.
    *
    * # Undefined Behavior
    *
    * If the content of register extends outside the preallocated memory on the host side, or the pointer points to a
    * wrong location this function will overwrite memory that it is not supposed to overwrite causing an undefined behavior.
    *
    * # Cost
    *
    * `base + read_register_base + read_register_byte * num_bytes + write_memory_base + write_memory_byte * num_bytes`
    * @param {BigInt} register_id
    * @param {BigInt} ptr
    */
    read_register(register_id, ptr) {
        uint64CvtShim[0] = register_id;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        uint64CvtShim[0] = ptr;
        const low1 = u32CvtShim[0];
        const high1 = u32CvtShim[1];
        wasm.vm_read_register(this.ptr, low0, high0, low1, high1);
    }
    /**
    * @param {BigInt} register_id
    * @returns {BigInt}
    */
    register_len(register_id) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            uint64CvtShim[0] = register_id;
            const low0 = u32CvtShim[0];
            const high0 = u32CvtShim[1];
            wasm.vm_register_len(retptr, this.ptr, low0, high0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            u32CvtShim[0] = r0;
            u32CvtShim[1] = r1;
            const n1 = uint64CvtShim[0];
            return n1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * ###################################
    * # String reading helper functions #
    * ###################################
    * Helper function to read and return utf8-encoding string.
    * If `len == u64::MAX` then treats the string as null-terminated with character `'\0'`.
    *
    * # Errors
    *
    * * If string extends outside the memory of the guest with `MemoryAccessViolation`;
    * * If string is not UTF-8 returns `BadUtf8`.
    * * If string is longer than `max_log_len` returns `BadUtf8`.
    *
    * # Cost
    *
    * For not nul-terminated string:
    * `read_memory_base + read_memory_byte * num_bytes + utf8_decoding_base + utf8_decoding_byte * num_bytes`
    *
    * For nul-terminated string:
    * `(read_memory_base + read_memory_byte) * num_bytes + utf8_decoding_base + utf8_decoding_byte * num_bytes`
    * Helper function to read UTF-16 formatted string from guest memory.
    * # Errors
    *
    * * If string extends outside the memory of the guest with `MemoryAccessViolation`;
    * * If string is not UTF-16 returns `BadUtf16`.
    *
    * # Cost
    *
    * For not nul-terminated string:
    * `read_memory_base + read_memory_byte * num_bytes + utf16_decoding_base + utf16_decoding_byte * num_bytes`
    *
    * For nul-terminated string:
    * `read_memory_base * num_bytes / 2 + read_memory_byte * num_bytes + utf16_decoding_base + utf16_decoding_byte * num_bytes`
    * ###############
    * # Context API #
    * ###############
    * Saves the account id of the current contract that we execute into the register.
    *
    * # Errors
    *
    * If the registers exceed the memory limit returns `MemoryAccessViolation`.
    *
    * # Cost
    *
    * `base + write_register_base + write_register_byte * num_bytes`
    * @param {BigInt} register_id
    */
    current_account_id(register_id) {
        uint64CvtShim[0] = register_id;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        wasm.vm_current_account_id(this.ptr, low0, high0);
    }
    /**
    * All contract calls are a result of some transaction that was signed by some account using
    * some access key and submitted into a memory pool (either through the wallet using RPC or by
    * a node itself). This function returns the id of that account. Saves the bytes of the signer
    * account id into the register.
    *
    * # Errors
    *
    * * If the registers exceed the memory limit returns `MemoryAccessViolation`.
    * * If called as view function returns `ProhibitedInView`.
    *
    * # Cost
    *
    * `base + write_register_base + write_register_byte * num_bytes`
    * @param {BigInt} register_id
    */
    signer_account_id(register_id) {
        uint64CvtShim[0] = register_id;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        wasm.vm_signer_account_id(this.ptr, low0, high0);
    }
    /**
    * Saves the public key fo the access key that was used by the signer into the register. In
    * rare situations smart contract might want to know the exact access key that was used to send
    * the original transaction, e.g. to increase the allowance or manipulate with the public key.
    *
    * # Errors
    *
    * * If the registers exceed the memory limit returns `MemoryAccessViolation`.
    * * If called as view function returns `ProhibitedInView`.
    *
    * # Cost
    *
    * `base + write_register_base + write_register_byte * num_bytes`
    * @param {BigInt} register_id
    */
    signer_account_pk(register_id) {
        uint64CvtShim[0] = register_id;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        wasm.vm_signer_account_pk(this.ptr, low0, high0);
    }
    /**
    * All contract calls are a result of a receipt, this receipt might be created by a transaction
    * that does function invocation on the contract or another contract as a result of
    * cross-contract call. Saves the bytes of the predecessor account id into the register.
    *
    * # Errors
    *
    * * If the registers exceed the memory limit returns `MemoryAccessViolation`.
    * * If called as view function returns `ProhibitedInView`.
    *
    * # Cost
    *
    * `base + write_register_base + write_register_byte * num_bytes`
    * @param {BigInt} register_id
    */
    predecessor_account_id(register_id) {
        uint64CvtShim[0] = register_id;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        wasm.vm_predecessor_account_id(this.ptr, low0, high0);
    }
    /**
    * Reads input to the contract call into the register. Input is expected to be in JSON-format.
    * If input is provided saves the bytes (potentially zero) of input into register. If input is
    * not provided writes 0 bytes into the register.
    *
    * # Cost
    *
    * `base + write_register_base + write_register_byte * num_bytes`
    * @param {BigInt} register_id
    */
    input(register_id) {
        uint64CvtShim[0] = register_id;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        wasm.vm_input(this.ptr, low0, high0);
    }
    /**
    * Returns the current block height.
    *
    * # Cost
    *
    * `base`
    * TODO #1903 rename to `block_height`
    * @returns {BigInt}
    */
    block_index() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.vm_block_index(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            u32CvtShim[0] = r0;
            u32CvtShim[1] = r1;
            const n0 = uint64CvtShim[0];
            return n0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Returns the current block timestamp.
    *
    * # Cost
    *
    * `base`
    * @returns {BigInt}
    */
    block_timestamp() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.vm_block_timestamp(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            u32CvtShim[0] = r0;
            u32CvtShim[1] = r1;
            const n0 = uint64CvtShim[0];
            return n0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {BigInt}
    */
    epoch_height() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.vm_epoch_height(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            u32CvtShim[0] = r0;
            u32CvtShim[1] = r1;
            const n0 = uint64CvtShim[0];
            return n0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Returns the number of bytes used by the contract if it was saved to the trie as of the
    * invocation. This includes:
    * * The data written with storage_* functions during current and previous execution;
    * * The bytes needed to store the access keys of the given account.
    * * The contract code size
    * * A small fixed overhead for account metadata.
    *
    * # Cost
    *
    * `base`
    * @returns {BigInt}
    */
    storage_usage() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.vm_storage_usage(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            u32CvtShim[0] = r0;
            u32CvtShim[1] = r1;
            const n0 = uint64CvtShim[0];
            return n0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * #################
    * # Economics API #
    * #################
    * The current balance of the given account. This includes the attached_deposit that was
    * attached to the transaction.
    *
    * # Cost
    *
    * `base + memory_write_base + memory_write_size * 16`
    * @param {BigInt} balance_ptr
    */
    account_balance(balance_ptr) {
        uint64CvtShim[0] = balance_ptr;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        wasm.vm_account_balance(this.ptr, low0, high0);
    }
    /**
    * The current amount of tokens locked due to staking.
    *
    * # Cost
    *
    * `base + memory_write_base + memory_write_size * 16`
    * @param {BigInt} balance_ptr
    */
    account_locked_balance(balance_ptr) {
        uint64CvtShim[0] = balance_ptr;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        wasm.vm_account_locked_balance(this.ptr, low0, high0);
    }
    /**
    * The balance that was attached to the call that will be immediately deposited before the
    * contract execution starts.
    *
    * # Errors
    *
    * If called as view function returns `ProhibitedInView``.
    *
    * # Cost
    *
    * `base + memory_write_base + memory_write_size * 16`
    * @param {BigInt} balance_ptr
    */
    attached_deposit(balance_ptr) {
        uint64CvtShim[0] = balance_ptr;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        wasm.vm_attached_deposit(this.ptr, low0, high0);
    }
    /**
    * The amount of gas attached to the call that can be used to pay for the gas fees.
    *
    * # Errors
    *
    * If called as view function returns `ProhibitedInView`.
    *
    * # Cost
    *
    * `base`
    * @returns {BigInt}
    */
    prepaid_gas() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.vm_prepaid_gas(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            u32CvtShim[0] = r0;
            u32CvtShim[1] = r1;
            const n0 = uint64CvtShim[0];
            return n0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * The gas that was already burnt during the contract execution (cannot exceed `prepaid_gas`)
    *
    * # Errors
    *
    * If called as view function returns `ProhibitedInView`.
    *
    * # Cost
    *
    * `base`
    * @returns {BigInt}
    */
    used_gas() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.vm_used_gas(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            u32CvtShim[0] = r0;
            u32CvtShim[1] = r1;
            const n0 = uint64CvtShim[0];
            return n0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * ############
    * # Math API #
    * ############
    * Writes random seed into the register.
    *
    * # Errors
    *
    * If the size of the registers exceed the set limit `MemoryAccessViolation`.
    *
    * # Cost
    *
    * `base + write_register_base + write_register_byte * num_bytes`.
    * @param {BigInt} register_id
    */
    random_seed(register_id) {
        uint64CvtShim[0] = register_id;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        wasm.vm_random_seed(this.ptr, low0, high0);
    }
    /**
    * Hashes the random sequence of bytes using sha256 and returns it into `register_id`.
    *
    * # Errors
    *
    * If `value_len + value_ptr` points outside the memory or the registers use more memory than
    * the limit with `MemoryAccessViolation`.
    *
    * # Cost
    *
    * `base + write_register_base + write_register_byte * num_bytes + sha256_base + sha256_byte * num_bytes`
    * @param {BigInt} value_len
    * @param {BigInt} value_ptr
    * @param {BigInt} register_id
    */
    sha256(value_len, value_ptr, register_id) {
        uint64CvtShim[0] = value_len;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        uint64CvtShim[0] = value_ptr;
        const low1 = u32CvtShim[0];
        const high1 = u32CvtShim[1];
        uint64CvtShim[0] = register_id;
        const low2 = u32CvtShim[0];
        const high2 = u32CvtShim[1];
        wasm.vm_sha256(this.ptr, low0, high0, low1, high1, low2, high2);
    }
    /**
    * Hashes the random sequence of bytes using keccak256 and returns it into `register_id`.
    *
    * # Errors
    *
    * If `value_len + value_ptr` points outside the memory or the registers use more memory than
    * the limit with `MemoryAccessViolation`.
    *
    * # Cost
    *
    * `base + write_register_base + write_register_byte * num_bytes + keccak256_base + keccak256_byte * num_bytes`
    * @param {BigInt} value_len
    * @param {BigInt} value_ptr
    * @param {BigInt} register_id
    */
    keccak256(value_len, value_ptr, register_id) {
        uint64CvtShim[0] = value_len;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        uint64CvtShim[0] = value_ptr;
        const low1 = u32CvtShim[0];
        const high1 = u32CvtShim[1];
        uint64CvtShim[0] = register_id;
        const low2 = u32CvtShim[0];
        const high2 = u32CvtShim[1];
        wasm.vm_keccak256(this.ptr, low0, high0, low1, high1, low2, high2);
    }
    /**
    * Hashes the random sequence of bytes using keccak512 and returns it into `register_id`.
    *
    * # Errors
    *
    * If `value_len + value_ptr` points outside the memory or the registers use more memory than
    * the limit with `MemoryAccessViolation`.
    *
    * # Cost
    *
    * `base + write_register_base + write_register_byte * num_bytes + keccak512_base + keccak512_byte * num_bytes`
    * @param {BigInt} value_len
    * @param {BigInt} value_ptr
    * @param {BigInt} register_id
    */
    keccak512(value_len, value_ptr, register_id) {
        uint64CvtShim[0] = value_len;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        uint64CvtShim[0] = value_ptr;
        const low1 = u32CvtShim[0];
        const high1 = u32CvtShim[1];
        uint64CvtShim[0] = register_id;
        const low2 = u32CvtShim[0];
        const high2 = u32CvtShim[1];
        wasm.vm_keccak512(this.ptr, low0, high0, low1, high1, low2, high2);
    }
    /**
    * Called by gas metering injected into Wasm. Counts both towards `burnt_gas` and `used_gas`.
    *
    * # Errors
    *
    * * If passed gas amount somehow overflows internal gas counters returns `IntegerOverflow`;
    * * If we exceed usage limit imposed on burnt gas returns `GasLimitExceeded`;
    * * If we exceed the `prepaid_gas` then returns `GasExceeded`.
    * @param {number} gas_amount
    */
    gas(gas_amount) {
        wasm.vm_gas(this.ptr, gas_amount);
    }
    /**
    * ################
    * # Promises API #
    * ################
    * A helper function to pay gas fee for creating a new receipt without actions.
    * # Args:
    * * `sir`: whether contract call is addressed to itself;
    * * `data_dependencies`: other contracts that this execution will be waiting on (or rather
    *   their data receipts), where bool indicates whether this is sender=receiver communication.
    *
    * # Cost
    *
    * This is a convenience function that encapsulates several costs:
    * `burnt_gas := dispatch cost of the receipt + base dispatch cost  cost of the data receipt`
    * `used_gas := burnt_gas + exec cost of the receipt + base exec cost  cost of the data receipt`
    * Notice that we prepay all base cost upon the creation of the data dependency, we are going to
    * pay for the content transmitted through the dependency upon the actual creation of the
    * DataReceipt.
    * A helper function to subtract balance on transfer or attached deposit for promises.
    * # Args:
    * * `amount`: the amount to deduct from the current account balance.
    * Creates a promise that will execute a method on account with given arguments and attaches
    * the given amount and gas. `amount_ptr` point to slices of bytes representing `u128`.
    *
    * # Errors
    *
    * * If `account_id_len + account_id_ptr` or `method_name_len + method_name_ptr` or
    * `arguments_len + arguments_ptr` or `amount_ptr + 16` points outside the memory of the guest
    * or host returns `MemoryAccessViolation`.
    * * If called as view function returns `ProhibitedInView`.
    *
    * # Returns
    *
    * Index of the new promise that uniquely identifies it within the current execution of the
    * method.
    *
    * # Cost
    *
    * Since `promise_create` is a convenience wrapper around `promise_batch_create` and
    * `promise_batch_action_function_call`. This also means it charges `base` cost twice.
    * @param {BigInt} account_id_len
    * @param {BigInt} account_id_ptr
    * @param {BigInt} method_name_len
    * @param {BigInt} method_name_ptr
    * @param {BigInt} arguments_len
    * @param {BigInt} arguments_ptr
    * @param {BigInt} amount_ptr
    * @param {BigInt} gas
    * @returns {BigInt}
    */
    promise_create(account_id_len, account_id_ptr, method_name_len, method_name_ptr, arguments_len, arguments_ptr, amount_ptr, gas) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            uint64CvtShim[0] = account_id_len;
            const low0 = u32CvtShim[0];
            const high0 = u32CvtShim[1];
            uint64CvtShim[0] = account_id_ptr;
            const low1 = u32CvtShim[0];
            const high1 = u32CvtShim[1];
            uint64CvtShim[0] = method_name_len;
            const low2 = u32CvtShim[0];
            const high2 = u32CvtShim[1];
            uint64CvtShim[0] = method_name_ptr;
            const low3 = u32CvtShim[0];
            const high3 = u32CvtShim[1];
            uint64CvtShim[0] = arguments_len;
            const low4 = u32CvtShim[0];
            const high4 = u32CvtShim[1];
            uint64CvtShim[0] = arguments_ptr;
            const low5 = u32CvtShim[0];
            const high5 = u32CvtShim[1];
            uint64CvtShim[0] = amount_ptr;
            const low6 = u32CvtShim[0];
            const high6 = u32CvtShim[1];
            uint64CvtShim[0] = gas;
            const low7 = u32CvtShim[0];
            const high7 = u32CvtShim[1];
            wasm.vm_promise_create(retptr, this.ptr, low0, high0, low1, high1, low2, high2, low3, high3, low4, high4, low5, high5, low6, high6, low7, high7);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            u32CvtShim[0] = r0;
            u32CvtShim[1] = r1;
            const n8 = uint64CvtShim[0];
            return n8;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Attaches the callback that is executed after promise pointed by `promise_idx` is complete.
    *
    * # Errors
    *
    * * If `promise_idx` does not correspond to an existing promise returns `InvalidPromiseIndex`;
    * * If `account_id_len + account_id_ptr` or `method_name_len + method_name_ptr` or
    *   `arguments_len + arguments_ptr` or `amount_ptr + 16` points outside the memory of the
    *   guest or host returns `MemoryAccessViolation`.
    * * If called as view function returns `ProhibitedInView`.
    *
    * # Returns
    *
    * Index of the new promise that uniquely identifies it within the current execution of the
    * method.
    *
    * # Cost
    *
    * Since `promise_create` is a convenience wrapper around `promise_batch_then` and
    * `promise_batch_action_function_call`. This also means it charges `base` cost twice.
    * @param {BigInt} promise_idx
    * @param {BigInt} account_id_len
    * @param {BigInt} account_id_ptr
    * @param {BigInt} method_name_len
    * @param {BigInt} method_name_ptr
    * @param {BigInt} arguments_len
    * @param {BigInt} arguments_ptr
    * @param {BigInt} amount_ptr
    * @param {BigInt} gas
    * @returns {BigInt}
    */
    promise_then(promise_idx, account_id_len, account_id_ptr, method_name_len, method_name_ptr, arguments_len, arguments_ptr, amount_ptr, gas) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            uint64CvtShim[0] = promise_idx;
            const low0 = u32CvtShim[0];
            const high0 = u32CvtShim[1];
            uint64CvtShim[0] = account_id_len;
            const low1 = u32CvtShim[0];
            const high1 = u32CvtShim[1];
            uint64CvtShim[0] = account_id_ptr;
            const low2 = u32CvtShim[0];
            const high2 = u32CvtShim[1];
            uint64CvtShim[0] = method_name_len;
            const low3 = u32CvtShim[0];
            const high3 = u32CvtShim[1];
            uint64CvtShim[0] = method_name_ptr;
            const low4 = u32CvtShim[0];
            const high4 = u32CvtShim[1];
            uint64CvtShim[0] = arguments_len;
            const low5 = u32CvtShim[0];
            const high5 = u32CvtShim[1];
            uint64CvtShim[0] = arguments_ptr;
            const low6 = u32CvtShim[0];
            const high6 = u32CvtShim[1];
            uint64CvtShim[0] = amount_ptr;
            const low7 = u32CvtShim[0];
            const high7 = u32CvtShim[1];
            uint64CvtShim[0] = gas;
            const low8 = u32CvtShim[0];
            const high8 = u32CvtShim[1];
            wasm.vm_promise_then(retptr, this.ptr, low0, high0, low1, high1, low2, high2, low3, high3, low4, high4, low5, high5, low6, high6, low7, high7, low8, high8);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            u32CvtShim[0] = r0;
            u32CvtShim[1] = r1;
            const n9 = uint64CvtShim[0];
            return n9;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Creates a new promise which completes when time all promises passed as arguments complete.
    * Cannot be used with registers. `promise_idx_ptr` points to an array of `u64` elements, with
    * `promise_idx_count` denoting the number of elements. The array contains indices of promises
    * that need to be waited on jointly.
    *
    * # Errors
    *
    * * If `promise_ids_ptr + 8 * promise_idx_count` extend outside the guest memory returns
    *   `MemoryAccessViolation`;
    * * If any of the promises in the array do not correspond to existing promises returns
    *   `InvalidPromiseIndex`.
    * * If called as view function returns `ProhibitedInView`.
    *
    * # Returns
    *
    * Index of the new promise that uniquely identifies it within the current execution of the
    * method.
    *
    * # Cost
    *
    * `base + promise_and_base + promise_and_per_promise * num_promises + cost of reading promise ids from memory`.
    * @param {BigInt} promise_idx_ptr
    * @param {BigInt} promise_idx_count
    * @returns {BigInt}
    */
    promise_and(promise_idx_ptr, promise_idx_count) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            uint64CvtShim[0] = promise_idx_ptr;
            const low0 = u32CvtShim[0];
            const high0 = u32CvtShim[1];
            uint64CvtShim[0] = promise_idx_count;
            const low1 = u32CvtShim[0];
            const high1 = u32CvtShim[1];
            wasm.vm_promise_and(retptr, this.ptr, low0, high0, low1, high1);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            u32CvtShim[0] = r0;
            u32CvtShim[1] = r1;
            const n2 = uint64CvtShim[0];
            return n2;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Creates a new promise towards given `account_id` without any actions attached to it.
    *
    * # Errors
    *
    * * If `account_id_len + account_id_ptr` points outside the memory of the guest or host
    * returns `MemoryAccessViolation`.
    * * If called as view function returns `ProhibitedInView`.
    *
    * # Returns
    *
    * Index of the new promise that uniquely identifies it within the current execution of the
    * method.
    *
    * # Cost
    *
    * `burnt_gas := base + cost of reading and decoding the account id + dispatch cost of the receipt`.
    * `used_gas := burnt_gas + exec cost of the receipt`.
    * @param {BigInt} account_id_len
    * @param {BigInt} account_id_ptr
    * @returns {BigInt}
    */
    promise_batch_create(account_id_len, account_id_ptr) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            uint64CvtShim[0] = account_id_len;
            const low0 = u32CvtShim[0];
            const high0 = u32CvtShim[1];
            uint64CvtShim[0] = account_id_ptr;
            const low1 = u32CvtShim[0];
            const high1 = u32CvtShim[1];
            wasm.vm_promise_batch_create(retptr, this.ptr, low0, high0, low1, high1);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            u32CvtShim[0] = r0;
            u32CvtShim[1] = r1;
            const n2 = uint64CvtShim[0];
            return n2;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Creates a new promise towards given `account_id` without any actions attached, that is
    * executed after promise pointed by `promise_idx` is complete.
    *
    * # Errors
    *
    * * If `promise_idx` does not correspond to an existing promise returns `InvalidPromiseIndex`;
    * * If `account_id_len + account_id_ptr` points outside the memory of the guest or host
    * returns `MemoryAccessViolation`.
    * * If called as view function returns `ProhibitedInView`.
    *
    * # Returns
    *
    * Index of the new promise that uniquely identifies it within the current execution of the
    * method.
    *
    * # Cost
    *
    * `base + cost of reading and decoding the account id + dispatch&execution cost of the receipt
    *  + dispatch&execution base cost for each data dependency`
    * @param {BigInt} promise_idx
    * @param {BigInt} account_id_len
    * @param {BigInt} account_id_ptr
    * @returns {BigInt}
    */
    promise_batch_then(promise_idx, account_id_len, account_id_ptr) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            uint64CvtShim[0] = promise_idx;
            const low0 = u32CvtShim[0];
            const high0 = u32CvtShim[1];
            uint64CvtShim[0] = account_id_len;
            const low1 = u32CvtShim[0];
            const high1 = u32CvtShim[1];
            uint64CvtShim[0] = account_id_ptr;
            const low2 = u32CvtShim[0];
            const high2 = u32CvtShim[1];
            wasm.vm_promise_batch_then(retptr, this.ptr, low0, high0, low1, high1, low2, high2);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            u32CvtShim[0] = r0;
            u32CvtShim[1] = r1;
            const n3 = uint64CvtShim[0];
            return n3;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Appends `CreateAccount` action to the batch of actions for the given promise pointed by
    * `promise_idx`.
    *
    * # Errors
    *
    * * If `promise_idx` does not correspond to an existing promise returns `InvalidPromiseIndex`.
    * * If the promise pointed by the `promise_idx` is an ephemeral promise created by
    * `promise_and` returns `CannotAppendActionToJointPromise`.
    * * If called as view function returns `ProhibitedInView`.
    *
    * # Cost
    *
    * `burnt_gas := base + dispatch action fee`
    * `used_gas := burnt_gas + exec action fee`
    * @param {BigInt} promise_idx
    */
    promise_batch_action_create_account(promise_idx) {
        uint64CvtShim[0] = promise_idx;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        wasm.vm_promise_batch_action_create_account(this.ptr, low0, high0);
    }
    /**
    * Appends `DeployContract` action to the batch of actions for the given promise pointed by
    * `promise_idx`.
    *
    * # Errors
    *
    * * If `promise_idx` does not correspond to an existing promise returns `InvalidPromiseIndex`.
    * * If the promise pointed by the `promise_idx` is an ephemeral promise created by
    * `promise_and` returns `CannotAppendActionToJointPromise`.
    * * If `code_len + code_ptr` points outside the memory of the guest or host returns
    * `MemoryAccessViolation`.
    * * If called as view function returns `ProhibitedInView`.
    *
    * # Cost
    *
    * `burnt_gas := base + dispatch action base fee + dispatch action per byte fee * num bytes + cost of reading vector from memory `
    * `used_gas := burnt_gas + exec action base fee + exec action per byte fee * num bytes`
    * @param {BigInt} promise_idx
    * @param {BigInt} code_len
    * @param {BigInt} code_ptr
    */
    promise_batch_action_deploy_contract(promise_idx, code_len, code_ptr) {
        uint64CvtShim[0] = promise_idx;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        uint64CvtShim[0] = code_len;
        const low1 = u32CvtShim[0];
        const high1 = u32CvtShim[1];
        uint64CvtShim[0] = code_ptr;
        const low2 = u32CvtShim[0];
        const high2 = u32CvtShim[1];
        wasm.vm_promise_batch_action_deploy_contract(this.ptr, low0, high0, low1, high1, low2, high2);
    }
    /**
    * Appends `FunctionCall` action to the batch of actions for the given promise pointed by
    * `promise_idx`.
    *
    * # Errors
    *
    * * If `promise_idx` does not correspond to an existing promise returns `InvalidPromiseIndex`.
    * * If the promise pointed by the `promise_idx` is an ephemeral promise created by
    * `promise_and` returns `CannotAppendActionToJointPromise`.
    * * If `method_name_len + method_name_ptr` or `arguments_len + arguments_ptr` or
    * `amount_ptr + 16` points outside the memory of the guest or host returns
    * `MemoryAccessViolation`.
    * * If called as view function returns `ProhibitedInView`.
    *
    * # Cost
    *
    * `burnt_gas := base + dispatch action base fee + dispatch action per byte fee * num bytes + cost of reading vector from memory
    *  + cost of reading u128, method_name and arguments from the memory`
    * `used_gas := burnt_gas + exec action base fee + exec action per byte fee * num bytes`
    * @param {BigInt} promise_idx
    * @param {BigInt} method_name_len
    * @param {BigInt} method_name_ptr
    * @param {BigInt} arguments_len
    * @param {BigInt} arguments_ptr
    * @param {BigInt} amount_ptr
    * @param {BigInt} gas
    */
    promise_batch_action_function_call(promise_idx, method_name_len, method_name_ptr, arguments_len, arguments_ptr, amount_ptr, gas) {
        uint64CvtShim[0] = promise_idx;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        uint64CvtShim[0] = method_name_len;
        const low1 = u32CvtShim[0];
        const high1 = u32CvtShim[1];
        uint64CvtShim[0] = method_name_ptr;
        const low2 = u32CvtShim[0];
        const high2 = u32CvtShim[1];
        uint64CvtShim[0] = arguments_len;
        const low3 = u32CvtShim[0];
        const high3 = u32CvtShim[1];
        uint64CvtShim[0] = arguments_ptr;
        const low4 = u32CvtShim[0];
        const high4 = u32CvtShim[1];
        uint64CvtShim[0] = amount_ptr;
        const low5 = u32CvtShim[0];
        const high5 = u32CvtShim[1];
        uint64CvtShim[0] = gas;
        const low6 = u32CvtShim[0];
        const high6 = u32CvtShim[1];
        wasm.vm_promise_batch_action_function_call(this.ptr, low0, high0, low1, high1, low2, high2, low3, high3, low4, high4, low5, high5, low6, high6);
    }
    /**
    * Appends `Transfer` action to the batch of actions for the given promise pointed by
    * `promise_idx`.
    *
    * # Errors
    *
    * * If `promise_idx` does not correspond to an existing promise returns `InvalidPromiseIndex`.
    * * If the promise pointed by the `promise_idx` is an ephemeral promise created by
    * `promise_and` returns `CannotAppendActionToJointPromise`.
    * * If `amount_ptr + 16` points outside the memory of the guest or host returns
    * `MemoryAccessViolation`.
    * * If called as view function returns `ProhibitedInView`.
    *
    * # Cost
    *
    * `burnt_gas := base + dispatch action base fee + dispatch action per byte fee * num bytes + cost of reading u128 from memory `
    * `used_gas := burnt_gas + exec action base fee + exec action per byte fee * num bytes`
    * @param {BigInt} promise_idx
    * @param {BigInt} amount_ptr
    */
    promise_batch_action_transfer(promise_idx, amount_ptr) {
        uint64CvtShim[0] = promise_idx;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        uint64CvtShim[0] = amount_ptr;
        const low1 = u32CvtShim[0];
        const high1 = u32CvtShim[1];
        wasm.vm_promise_batch_action_transfer(this.ptr, low0, high0, low1, high1);
    }
    /**
    * Appends `Stake` action to the batch of actions for the given promise pointed by
    * `promise_idx`.
    *
    * # Errors
    *
    * * If `promise_idx` does not correspond to an existing promise returns `InvalidPromiseIndex`.
    * * If the promise pointed by the `promise_idx` is an ephemeral promise created by
    * `promise_and` returns `CannotAppendActionToJointPromise`.
    * * If the given public key is not a valid (e.g. wrong length) returns `InvalidPublicKey`.
    * * If `amount_ptr + 16` or `public_key_len + public_key_ptr` points outside the memory of the
    * guest or host returns `MemoryAccessViolation`.
    * * If called as view function returns `ProhibitedInView`.
    *
    * # Cost
    *
    * `burnt_gas := base + dispatch action base fee + dispatch action per byte fee * num bytes + cost of reading public key from memory `
    * `used_gas := burnt_gas + exec action base fee + exec action per byte fee * num bytes`
    * @param {BigInt} promise_idx
    * @param {BigInt} amount_ptr
    * @param {BigInt} public_key_len
    * @param {BigInt} public_key_ptr
    */
    promise_batch_action_stake(promise_idx, amount_ptr, public_key_len, public_key_ptr) {
        uint64CvtShim[0] = promise_idx;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        uint64CvtShim[0] = amount_ptr;
        const low1 = u32CvtShim[0];
        const high1 = u32CvtShim[1];
        uint64CvtShim[0] = public_key_len;
        const low2 = u32CvtShim[0];
        const high2 = u32CvtShim[1];
        uint64CvtShim[0] = public_key_ptr;
        const low3 = u32CvtShim[0];
        const high3 = u32CvtShim[1];
        wasm.vm_promise_batch_action_stake(this.ptr, low0, high0, low1, high1, low2, high2, low3, high3);
    }
    /**
    * Appends `AddKey` action to the batch of actions for the given promise pointed by
    * `promise_idx`. The access key will have `FullAccess` permission.
    *
    * # Errors
    *
    * * If `promise_idx` does not correspond to an existing promise returns `InvalidPromiseIndex`.
    * * If the promise pointed by the `promise_idx` is an ephemeral promise created by
    * `promise_and` returns `CannotAppendActionToJointPromise`.
    * * If the given public key is not a valid (e.g. wrong length) returns `InvalidPublicKey`.
    * * If `public_key_len + public_key_ptr` points outside the memory of the guest or host
    * returns `MemoryAccessViolation`.
    * * If called as view function returns `ProhibitedInView`.
    *
    * # Cost
    *
    * `burnt_gas := base + dispatch action base fee + dispatch action per byte fee * num bytes + cost of reading public key from memory `
    * `used_gas := burnt_gas + exec action base fee + exec action per byte fee * num bytes`
    * @param {BigInt} promise_idx
    * @param {BigInt} public_key_len
    * @param {BigInt} public_key_ptr
    * @param {BigInt} nonce
    */
    promise_batch_action_add_key_with_full_access(promise_idx, public_key_len, public_key_ptr, nonce) {
        uint64CvtShim[0] = promise_idx;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        uint64CvtShim[0] = public_key_len;
        const low1 = u32CvtShim[0];
        const high1 = u32CvtShim[1];
        uint64CvtShim[0] = public_key_ptr;
        const low2 = u32CvtShim[0];
        const high2 = u32CvtShim[1];
        uint64CvtShim[0] = nonce;
        const low3 = u32CvtShim[0];
        const high3 = u32CvtShim[1];
        wasm.vm_promise_batch_action_add_key_with_full_access(this.ptr, low0, high0, low1, high1, low2, high2, low3, high3);
    }
    /**
    * Appends `AddKey` action to the batch of actions for the given promise pointed by
    * `promise_idx`. The access key will have `FunctionCall` permission.
    *
    * # Errors
    *
    * * If `promise_idx` does not correspond to an existing promise returns `InvalidPromiseIndex`.
    * * If the promise pointed by the `promise_idx` is an ephemeral promise created by
    * `promise_and` returns `CannotAppendActionToJointPromise`.
    * * If the given public key is not a valid (e.g. wrong length) returns `InvalidPublicKey`.
    * * If `public_key_len + public_key_ptr`, `allowance_ptr + 16`,
    * `receiver_id_len + receiver_id_ptr` or `method_names_len + method_names_ptr` points outside
    * the memory of the guest or host returns `MemoryAccessViolation`.
    * * If called as view function returns `ProhibitedInView`.
    *
    * # Cost
    *
    * `burnt_gas := base + dispatch action base fee + dispatch action per byte fee * num bytes + cost of reading vector from memory
    *  + cost of reading u128, method_names and public key from the memory + cost of reading and parsing account name`
    * `used_gas := burnt_gas + exec action base fee + exec action per byte fee * num bytes`
    * @param {BigInt} promise_idx
    * @param {BigInt} public_key_len
    * @param {BigInt} public_key_ptr
    * @param {BigInt} nonce
    * @param {BigInt} allowance_ptr
    * @param {BigInt} receiver_id_len
    * @param {BigInt} receiver_id_ptr
    * @param {BigInt} method_names_len
    * @param {BigInt} method_names_ptr
    */
    promise_batch_action_add_key_with_function_call(promise_idx, public_key_len, public_key_ptr, nonce, allowance_ptr, receiver_id_len, receiver_id_ptr, method_names_len, method_names_ptr) {
        uint64CvtShim[0] = promise_idx;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        uint64CvtShim[0] = public_key_len;
        const low1 = u32CvtShim[0];
        const high1 = u32CvtShim[1];
        uint64CvtShim[0] = public_key_ptr;
        const low2 = u32CvtShim[0];
        const high2 = u32CvtShim[1];
        uint64CvtShim[0] = nonce;
        const low3 = u32CvtShim[0];
        const high3 = u32CvtShim[1];
        uint64CvtShim[0] = allowance_ptr;
        const low4 = u32CvtShim[0];
        const high4 = u32CvtShim[1];
        uint64CvtShim[0] = receiver_id_len;
        const low5 = u32CvtShim[0];
        const high5 = u32CvtShim[1];
        uint64CvtShim[0] = receiver_id_ptr;
        const low6 = u32CvtShim[0];
        const high6 = u32CvtShim[1];
        uint64CvtShim[0] = method_names_len;
        const low7 = u32CvtShim[0];
        const high7 = u32CvtShim[1];
        uint64CvtShim[0] = method_names_ptr;
        const low8 = u32CvtShim[0];
        const high8 = u32CvtShim[1];
        wasm.vm_promise_batch_action_add_key_with_function_call(this.ptr, low0, high0, low1, high1, low2, high2, low3, high3, low4, high4, low5, high5, low6, high6, low7, high7, low8, high8);
    }
    /**
    * Appends `DeleteKey` action to the batch of actions for the given promise pointed by
    * `promise_idx`.
    *
    * # Errors
    *
    * * If `promise_idx` does not correspond to an existing promise returns `InvalidPromiseIndex`.
    * * If the promise pointed by the `promise_idx` is an ephemeral promise created by
    * `promise_and` returns `CannotAppendActionToJointPromise`.
    * * If the given public key is not a valid (e.g. wrong length) returns `InvalidPublicKey`.
    * * If `public_key_len + public_key_ptr` points outside the memory of the guest or host
    * returns `MemoryAccessViolation`.
    * * If called as view function returns `ProhibitedInView`.
    *
    * # Cost
    *
    * `burnt_gas := base + dispatch action base fee + dispatch action per byte fee * num bytes + cost of reading public key from memory `
    * `used_gas := burnt_gas + exec action base fee + exec action per byte fee * num bytes`
    * @param {BigInt} promise_idx
    * @param {BigInt} public_key_len
    * @param {BigInt} public_key_ptr
    */
    promise_batch_action_delete_key(promise_idx, public_key_len, public_key_ptr) {
        uint64CvtShim[0] = promise_idx;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        uint64CvtShim[0] = public_key_len;
        const low1 = u32CvtShim[0];
        const high1 = u32CvtShim[1];
        uint64CvtShim[0] = public_key_ptr;
        const low2 = u32CvtShim[0];
        const high2 = u32CvtShim[1];
        wasm.vm_promise_batch_action_delete_key(this.ptr, low0, high0, low1, high1, low2, high2);
    }
    /**
    * Appends `DeleteAccount` action to the batch of actions for the given promise pointed by
    * `promise_idx`.
    *
    * # Errors
    *
    * * If `promise_idx` does not correspond to an existing promise returns `InvalidPromiseIndex`.
    * * If the promise pointed by the `promise_idx` is an ephemeral promise created by
    * `promise_and` returns `CannotAppendActionToJointPromise`.
    * * If `beneficiary_id_len + beneficiary_id_ptr` points outside the memory of the guest or
    * host returns `MemoryAccessViolation`.
    * * If called as view function returns `ProhibitedInView`.
    *
    * # Cost
    *
    * `burnt_gas := base + dispatch action base fee + dispatch action per byte fee * num bytes + cost of reading and parsing account id from memory `
    * `used_gas := burnt_gas + exec action base fee + exec action per byte fee * num bytes`
    * @param {BigInt} promise_idx
    * @param {BigInt} beneficiary_id_len
    * @param {BigInt} beneficiary_id_ptr
    */
    promise_batch_action_delete_account(promise_idx, beneficiary_id_len, beneficiary_id_ptr) {
        uint64CvtShim[0] = promise_idx;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        uint64CvtShim[0] = beneficiary_id_len;
        const low1 = u32CvtShim[0];
        const high1 = u32CvtShim[1];
        uint64CvtShim[0] = beneficiary_id_ptr;
        const low2 = u32CvtShim[0];
        const high2 = u32CvtShim[1];
        wasm.vm_promise_batch_action_delete_account(this.ptr, low0, high0, low1, high1, low2, high2);
    }
    /**
    * If the current function is invoked by a callback we can access the execution results of the
    * promises that caused the callback. This function returns the number of complete and
    * incomplete callbacks.
    *
    * Note, we are only going to have incomplete callbacks once we have promise_or combinator.
    *
    *
    * * If there is only one callback returns `1`;
    * * If there are multiple callbacks (e.g. created through `promise_and`) returns their number;
    * * If the function was called not through the callback returns `0`.
    *
    * # Cost
    *
    * `base`
    * @returns {BigInt}
    */
    promise_results_count() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.vm_promise_results_count(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            u32CvtShim[0] = r0;
            u32CvtShim[1] = r1;
            const n0 = uint64CvtShim[0];
            return n0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * If the current function is invoked by a callback we can access the execution results of the
    * promises that caused the callback. This function returns the result in blob format and
    * places it into the register.
    *
    * * If promise result is complete and successful copies its blob into the register;
    * * If promise result is complete and failed or incomplete keeps register unused;
    *
    * # Returns
    *
    * * If promise result is not complete returns `0`;
    * * If promise result is complete and successful returns `1`;
    * * If promise result is complete and failed returns `2`.
    *
    * # Errors
    *
    * * If `result_id` does not correspond to an existing result returns `InvalidPromiseResultIndex`;
    * * If copying the blob exhausts the memory limit it returns `MemoryAccessViolation`.
    * * If called as view function returns `ProhibitedInView`.
    *
    * # Cost
    *
    * `base + cost of writing data into a register`
    * @param {BigInt} result_idx
    * @param {BigInt} register_id
    * @returns {BigInt}
    */
    promise_result(result_idx, register_id) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            uint64CvtShim[0] = result_idx;
            const low0 = u32CvtShim[0];
            const high0 = u32CvtShim[1];
            uint64CvtShim[0] = register_id;
            const low1 = u32CvtShim[0];
            const high1 = u32CvtShim[1];
            wasm.vm_promise_result(retptr, this.ptr, low0, high0, low1, high1);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            u32CvtShim[0] = r0;
            u32CvtShim[1] = r1;
            const n2 = uint64CvtShim[0];
            return n2;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * When promise `promise_idx` finishes executing its result is considered to be the result of
    * the current function.
    *
    * # Errors
    *
    * * If `promise_idx` does not correspond to an existing promise returns `InvalidPromiseIndex`.
    * * If called as view function returns `ProhibitedInView`.
    *
    * # Cost
    *
    * `base + promise_return`
    * @param {BigInt} promise_idx
    */
    promise_return(promise_idx) {
        uint64CvtShim[0] = promise_idx;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        wasm.vm_promise_return(this.ptr, low0, high0);
    }
    /**
    * #####################
    * # Miscellaneous API #
    * #####################
    * sets the blob of data as the return value of the contract.
    *
    * # Errors
    *
    * If `value_len + value_ptr` exceeds the memory container or points to an unused register it
    * returns `MemoryAccessViolation`.
    *
    * # Cost
    * `base + cost of reading return value from memory or register + dispatch&exec cost per byte of the data sent * num data receivers`
    * @param {BigInt} value_len
    * @param {BigInt} value_ptr
    */
    value_return(value_len, value_ptr) {
        uint64CvtShim[0] = value_len;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        uint64CvtShim[0] = value_ptr;
        const low1 = u32CvtShim[0];
        const high1 = u32CvtShim[1];
        wasm.vm_value_return(this.ptr, low0, high0, low1, high1);
    }
    /**
    * Terminates the execution of the program with panic `GuestPanic`.
    *
    * # Cost
    *
    * `base`
    */
    panic() {
        wasm.vm_panic(this.ptr);
    }
    /**
    * Guest panics with the UTF-8 encoded string.
    * If `len == u64::MAX` then treats the string as null-terminated with character `'\0'`.
    *
    * # Errors
    *
    * * If string extends outside the memory of the guest with `MemoryAccessViolation`;
    * * If string is not UTF-8 returns `BadUtf8`.
    * * If string is longer than `max_log_len` returns `BadUtf8`.
    *
    * # Cost
    * `base + cost of reading and decoding a utf8 string`
    * @param {BigInt} len
    * @param {BigInt} ptr
    */
    panic_utf8(len, ptr) {
        uint64CvtShim[0] = len;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        uint64CvtShim[0] = ptr;
        const low1 = u32CvtShim[0];
        const high1 = u32CvtShim[1];
        wasm.vm_panic_utf8(this.ptr, low0, high0, low1, high1);
    }
    /**
    * Logs the UTF-8 encoded string.
    * If `len == u64::MAX` then treats the string as null-terminated with character `'\0'`.
    *
    * # Errors
    *
    * * If string extends outside the memory of the guest with `MemoryAccessViolation`;
    * * If string is not UTF-8 returns `BadUtf8`.
    * * If string is longer than `max_log_len` returns `BadUtf8`.
    *
    * # Cost
    *
    * `base + log_base + log_byte + num_bytes + utf8 decoding cost`
    * @param {BigInt} len
    * @param {BigInt} ptr
    */
    log_utf8(len, ptr) {
        uint64CvtShim[0] = len;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        uint64CvtShim[0] = ptr;
        const low1 = u32CvtShim[0];
        const high1 = u32CvtShim[1];
        wasm.vm_log_utf8(this.ptr, low0, high0, low1, high1);
    }
    /**
    * Logs the UTF-16 encoded string. If `len == u64::MAX` then treats the string as
    * null-terminated with two-byte sequence of `0x00 0x00`.
    *
    * # Errors
    *
    * * If string extends outside the memory of the guest with `MemoryAccessViolation`;
    * * If string is not UTF-16 returns `BadUtf16`.
    *
    * # Cost
    *
    * `base + log_base + log_byte * num_bytes + utf16 decoding cost`
    * @param {BigInt} len
    * @param {BigInt} ptr
    */
    log_utf16(len, ptr) {
        uint64CvtShim[0] = len;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        uint64CvtShim[0] = ptr;
        const low1 = u32CvtShim[0];
        const high1 = u32CvtShim[1];
        wasm.vm_log_utf16(this.ptr, low0, high0, low1, high1);
    }
    /**
    * Special import kept for compatibility with AssemblyScript contracts. Not called by smart
    * contracts directly, but instead called by the code generated by AssemblyScript.
    *
    * # Cost
    *
    * `base +  log_base + log_byte * num_bytes + utf16 decoding cost`
    * @param {number} msg_ptr
    * @param {number} filename_ptr
    * @param {number} line
    * @param {number} col
    */
    abort(msg_ptr, filename_ptr, line, col) {
        wasm.vm_abort(this.ptr, msg_ptr, filename_ptr, line, col);
    }
    /**
    * ###############
    * # Storage API #
    * ###############
    * Reads account id from the given location in memory.
    *
    * # Errors
    *
    * * If account is not UTF-8 encoded then returns `BadUtf8`;
    *
    * # Cost
    *
    * This is a helper function that encapsulates the following costs:
    * cost of reading buffer from register or memory,
    * `utf8_decoding_base + utf8_decoding_byte * num_bytes`.
    * Writes key-value into storage.
    * * If key is not in use it inserts the key-value pair and does not modify the register. Returns `0`;
    * * If key is in use it inserts the key-value and copies the old value into the `register_id`. Returns `1`.
    *
    * # Errors
    *
    * * If `key_len + key_ptr` or `value_len + value_ptr` exceeds the memory container or points
    *   to an unused register it returns `MemoryAccessViolation`;
    * * If returning the preempted value into the registers exceed the memory container it returns
    *   `MemoryAccessViolation`.
    *
    * # Cost
    *
    * `base + storage_write_base + storage_write_key_byte * num_key_bytes + storage_write_value_byte * num_value_bytes
    * + get_vec_from_memory_or_register_cost x 2`.
    *
    * If a value was evicted it costs additional `storage_write_value_evicted_byte * num_evicted_bytes + internal_write_register_cost`.
    * @param {BigInt} key_len
    * @param {BigInt} key_ptr
    * @param {BigInt} value_len
    * @param {BigInt} value_ptr
    * @param {BigInt} register_id
    * @returns {BigInt}
    */
    storage_write(key_len, key_ptr, value_len, value_ptr, register_id) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            uint64CvtShim[0] = key_len;
            const low0 = u32CvtShim[0];
            const high0 = u32CvtShim[1];
            uint64CvtShim[0] = key_ptr;
            const low1 = u32CvtShim[0];
            const high1 = u32CvtShim[1];
            uint64CvtShim[0] = value_len;
            const low2 = u32CvtShim[0];
            const high2 = u32CvtShim[1];
            uint64CvtShim[0] = value_ptr;
            const low3 = u32CvtShim[0];
            const high3 = u32CvtShim[1];
            uint64CvtShim[0] = register_id;
            const low4 = u32CvtShim[0];
            const high4 = u32CvtShim[1];
            wasm.vm_storage_write(retptr, this.ptr, low0, high0, low1, high1, low2, high2, low3, high3, low4, high4);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            u32CvtShim[0] = r0;
            u32CvtShim[1] = r1;
            const n5 = uint64CvtShim[0];
            return n5;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Reads the value stored under the given key.
    * * If key is used copies the content of the value into the `register_id`, even if the content
    *   is zero bytes. Returns `1`;
    * * If key is not present then does not modify the register. Returns `0`;
    *
    * # Errors
    *
    * * If `key_len + key_ptr` exceeds the memory container or points to an unused register it
    *   returns `MemoryAccessViolation`;
    * * If returning the preempted value into the registers exceed the memory container it returns
    *   `MemoryAccessViolation`.
    *
    * # Cost
    *
    * `base + storage_read_base + storage_read_key_byte * num_key_bytes + storage_read_value_byte + num_value_bytes
    *  cost to read key from register + cost to write value into register`.
    * @param {BigInt} key_len
    * @param {BigInt} key_ptr
    * @param {BigInt} register_id
    * @returns {BigInt}
    */
    storage_read(key_len, key_ptr, register_id) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            uint64CvtShim[0] = key_len;
            const low0 = u32CvtShim[0];
            const high0 = u32CvtShim[1];
            uint64CvtShim[0] = key_ptr;
            const low1 = u32CvtShim[0];
            const high1 = u32CvtShim[1];
            uint64CvtShim[0] = register_id;
            const low2 = u32CvtShim[0];
            const high2 = u32CvtShim[1];
            wasm.vm_storage_read(retptr, this.ptr, low0, high0, low1, high1, low2, high2);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            u32CvtShim[0] = r0;
            u32CvtShim[1] = r1;
            const n3 = uint64CvtShim[0];
            return n3;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Removes the value stored under the given key.
    * * If key is used, removes the key-value from the trie and copies the content of the value
    *   into the `register_id`, even if the content is zero bytes. Returns `1`;
    * * If key is not present then does not modify the register. Returns `0`.
    *
    * # Errors
    *
    * * If `key_len + key_ptr` exceeds the memory container or points to an unused register it
    *   returns `MemoryAccessViolation`;
    * * If the registers exceed the memory limit returns `MemoryAccessViolation`;
    * * If returning the preempted value into the registers exceed the memory container it returns
    *   `MemoryAccessViolation`.
    *
    * # Cost
    *
    * `base + storage_remove_base + storage_remove_key_byte * num_key_bytes + storage_remove_ret_value_byte * num_value_bytes
    * + cost to read the key + cost to write the value`.
    * @param {BigInt} key_len
    * @param {BigInt} key_ptr
    * @param {BigInt} register_id
    * @returns {BigInt}
    */
    storage_remove(key_len, key_ptr, register_id) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            uint64CvtShim[0] = key_len;
            const low0 = u32CvtShim[0];
            const high0 = u32CvtShim[1];
            uint64CvtShim[0] = key_ptr;
            const low1 = u32CvtShim[0];
            const high1 = u32CvtShim[1];
            uint64CvtShim[0] = register_id;
            const low2 = u32CvtShim[0];
            const high2 = u32CvtShim[1];
            wasm.vm_storage_remove(retptr, this.ptr, low0, high0, low1, high1, low2, high2);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            u32CvtShim[0] = r0;
            u32CvtShim[1] = r1;
            const n3 = uint64CvtShim[0];
            return n3;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Checks if there is a key-value pair.
    * * If key is used returns `1`, even if the value is zero bytes;
    * * Otherwise returns `0`.
    *
    * # Errors
    *
    * If `key_len + key_ptr` exceeds the memory container it returns `MemoryAccessViolation`.
    *
    * # Cost
    *
    * `base + storage_has_key_base + storage_has_key_byte * num_bytes + cost of reading key`
    * @param {BigInt} key_len
    * @param {BigInt} key_ptr
    * @returns {BigInt}
    */
    storage_has_key(key_len, key_ptr) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            uint64CvtShim[0] = key_len;
            const low0 = u32CvtShim[0];
            const high0 = u32CvtShim[1];
            uint64CvtShim[0] = key_ptr;
            const low1 = u32CvtShim[0];
            const high1 = u32CvtShim[1];
            wasm.vm_storage_has_key(retptr, this.ptr, low0, high0, low1, high1);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            u32CvtShim[0] = r0;
            u32CvtShim[1] = r1;
            const n2 = uint64CvtShim[0];
            return n2;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {BigInt} account_id_len
    * @param {BigInt} account_id_ptr
    * @param {BigInt} stake_ptr
    */
    validator_stake(account_id_len, account_id_ptr, stake_ptr) {
        uint64CvtShim[0] = account_id_len;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        uint64CvtShim[0] = account_id_ptr;
        const low1 = u32CvtShim[0];
        const high1 = u32CvtShim[1];
        uint64CvtShim[0] = stake_ptr;
        const low2 = u32CvtShim[0];
        const high2 = u32CvtShim[1];
        wasm.vm_validator_stake(this.ptr, low0, high0, low1, high1, low2, high2);
    }
    /**
    * @param {BigInt} stake_ptr
    */
    validator_total_stake(stake_ptr) {
        uint64CvtShim[0] = stake_ptr;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        wasm.vm_validator_total_stake(this.ptr, low0, high0);
    }
    /**
    *
    *     * Utilities
    *
    *Computes the outcome of execution.
    * @returns {any}
    */
    outcome() {
        var ret = wasm.vm_outcome(this.ptr);
        return takeObject(ret);
    }
    /**
    * @returns {any}
    */
    created_receipts() {
        var ret = wasm.vm_created_receipts(this.ptr);
        return takeObject(ret);
    }
}
module.exports.VM = VM;

module.exports.__wbindgen_object_drop_ref = function(arg0) {
    takeObject(arg0);
};

module.exports.__wbg_writememory_ac21b7d629311fbb = function(arg0, arg1, arg2, arg3, arg4) {
    u32CvtShim[0] = arg1;
    u32CvtShim[1] = arg2;
    const n0 = uint64CvtShim[0];
    getObject(arg0).write_memory(n0, getArrayU8FromWasm0(arg3, arg4));
};

module.exports.__wbindgen_object_clone_ref = function(arg0) {
    var ret = getObject(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_fitsmemory_8e38756424432b8d = function(arg0, arg1, arg2, arg3, arg4) {
    u32CvtShim[0] = arg1;
    u32CvtShim[1] = arg2;
    const n0 = uint64CvtShim[0];
    u32CvtShim[0] = arg3;
    u32CvtShim[1] = arg4;
    const n1 = uint64CvtShim[0];
    var ret = getObject(arg0).fits_memory(n0, n1);
    return ret;
};

module.exports.__wbg_readmemory_61c77ecaade64c0d = function(arg0, arg1, arg2, arg3, arg4) {
    u32CvtShim[0] = arg1;
    u32CvtShim[1] = arg2;
    const n0 = uint64CvtShim[0];
    getObject(arg0).read_memory(n0, getArrayU8FromWasm0(arg3, arg4));
};

module.exports.__wbg_readmemoryu8_b854d6f121ba3eb7 = function(arg0, arg1, arg2) {
    u32CvtShim[0] = arg1;
    u32CvtShim[1] = arg2;
    const n0 = uint64CvtShim[0];
    var ret = getObject(arg0).read_memory_u8(n0);
    return ret;
};

module.exports.__wbg_new_59cb74e423758ede = function() {
    var ret = new Error();
    return addHeapObject(ret);
};

module.exports.__wbg_stack_558ba5917b466edd = function(arg0, arg1) {
    var ret = getObject(arg1).stack;
    var ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len0 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len0;
    getInt32Memory0()[arg0 / 4 + 0] = ptr0;
};

module.exports.__wbg_error_4bb6c2a97407129a = function(arg0, arg1) {
    try {
        console.error(getStringFromWasm0(arg0, arg1));
    } finally {
        wasm.__wbindgen_free(arg0, arg1);
    }
};

module.exports.__wbindgen_string_new = function(arg0, arg1) {
    var ret = getStringFromWasm0(arg0, arg1);
    return addHeapObject(ret);
};

module.exports.__wbindgen_is_null = function(arg0) {
    var ret = getObject(arg0) === null;
    return ret;
};

module.exports.__wbindgen_is_undefined = function(arg0) {
    var ret = getObject(arg0) === undefined;
    return ret;
};

module.exports.__wbg_new_68adb0d58759a4ed = function() {
    var ret = new Object();
    return addHeapObject(ret);
};

module.exports.__wbindgen_number_new = function(arg0) {
    var ret = arg0;
    return addHeapObject(ret);
};

module.exports.__wbg_set_2e79e744454afade = function(arg0, arg1, arg2) {
    getObject(arg0)[takeObject(arg1)] = takeObject(arg2);
};

module.exports.__wbindgen_is_object = function(arg0) {
    const val = getObject(arg0);
    var ret = typeof(val) === 'object' && val !== null;
    return ret;
};

module.exports.__wbindgen_is_function = function(arg0) {
    var ret = typeof(getObject(arg0)) === 'function';
    return ret;
};

module.exports.__wbg_next_f613b44647788059 = function(arg0) {
    var ret = getObject(arg0).next;
    return addHeapObject(ret);
};

module.exports.__wbg_next_cf4ec627a2e85bac = handleError(function(arg0) {
    var ret = getObject(arg0).next();
    return addHeapObject(ret);
});

module.exports.__wbg_done_4e046ac6e3b595e0 = function(arg0) {
    var ret = getObject(arg0).done;
    return ret;
};

module.exports.__wbg_value_6fa14ba8ee7b7c3d = function(arg0) {
    var ret = getObject(arg0).value;
    return addHeapObject(ret);
};

module.exports.__wbg_iterator_7d4f7917ab7aeca0 = function() {
    var ret = Symbol.iterator;
    return addHeapObject(ret);
};

module.exports.__wbg_get_4e90ba4e3de362de = handleError(function(arg0, arg1) {
    var ret = Reflect.get(getObject(arg0), getObject(arg1));
    return addHeapObject(ret);
});

module.exports.__wbg_call_e5847d15cc228e4f = handleError(function(arg0, arg1) {
    var ret = getObject(arg0).call(getObject(arg1));
    return addHeapObject(ret);
});

module.exports.__wbg_new_7c995f2adeba6fb5 = function() {
    var ret = new Array();
    return addHeapObject(ret);
};

module.exports.__wbg_isArray_dcc02660d0bae0c9 = function(arg0) {
    var ret = Array.isArray(getObject(arg0));
    return ret;
};

module.exports.__wbg_push_3f7c76b58919ce0d = function(arg0, arg1) {
    var ret = getObject(arg0).push(getObject(arg1));
    return ret;
};

module.exports.__wbg_instanceof_ArrayBuffer_f62c96496bf80760 = function(arg0) {
    var ret = getObject(arg0) instanceof ArrayBuffer;
    return ret;
};

module.exports.__wbg_values_6ff06259269d296c = function(arg0) {
    var ret = getObject(arg0).values();
    return addHeapObject(ret);
};

module.exports.__wbg_new_d0bf1a18ac785d9e = function(arg0, arg1) {
    var ret = new Error(getStringFromWasm0(arg0, arg1));
    return addHeapObject(ret);
};

module.exports.__wbg_isSafeInteger_84c8e80359f88059 = function(arg0) {
    var ret = Number.isSafeInteger(getObject(arg0));
    return ret;
};

module.exports.__wbg_buffer_0be9fb426f2dd82b = function(arg0) {
    var ret = getObject(arg0).buffer;
    return addHeapObject(ret);
};

module.exports.__wbg_length_3a5138f465b971ad = function(arg0) {
    var ret = getObject(arg0).length;
    return ret;
};

module.exports.__wbg_new_4e8d18dbf9cd5240 = function(arg0) {
    var ret = new Uint8Array(getObject(arg0));
    return addHeapObject(ret);
};

module.exports.__wbg_set_4769de301eb521d7 = function(arg0, arg1, arg2) {
    getObject(arg0).set(getObject(arg1), arg2 >>> 0);
};

module.exports.__wbg_instanceof_Uint8Array_502d9d37bbcc427a = function(arg0) {
    var ret = getObject(arg0) instanceof Uint8Array;
    return ret;
};

module.exports.__wbg_byteLength_ae97311b646a5b7a = function(arg0) {
    var ret = getObject(arg0).byteLength;
    return ret;
};

module.exports.__wbindgen_number_get = function(arg0, arg1) {
    const obj = getObject(arg1);
    var ret = typeof(obj) === 'number' ? obj : undefined;
    getFloat64Memory0()[arg0 / 8 + 1] = isLikeNone(ret) ? 0 : ret;
    getInt32Memory0()[arg0 / 4 + 0] = !isLikeNone(ret);
};

module.exports.__wbindgen_string_get = function(arg0, arg1) {
    const obj = getObject(arg1);
    var ret = typeof(obj) === 'string' ? obj : undefined;
    var ptr0 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len0 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len0;
    getInt32Memory0()[arg0 / 4 + 0] = ptr0;
};

module.exports.__wbindgen_boolean_get = function(arg0) {
    const v = getObject(arg0);
    var ret = typeof(v) === 'boolean' ? (v ? 1 : 0) : 2;
    return ret;
};

module.exports.__wbindgen_debug_string = function(arg0, arg1) {
    var ret = debugString(getObject(arg1));
    var ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len0 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len0;
    getInt32Memory0()[arg0 / 4 + 0] = ptr0;
};

module.exports.__wbindgen_throw = function(arg0, arg1) {
    throw new Error(getStringFromWasm0(arg0, arg1));
};

module.exports.__wbindgen_memory = function() {
    var ret = wasm.memory;
    return addHeapObject(ret);
};

const path = require('path').join(__dirname, 'near_mock_vm_bg.wasm');
const bytes = require('fs').readFileSync(path);

const wasmModule = new WebAssembly.Module(bytes);
const wasmInstance = new WebAssembly.Instance(wasmModule, imports);
wasm = wasmInstance.exports;
module.exports.__wasm = wasm;

wasm.__wbindgen_start();

'''
'''--- near-mock-vm/vm/dist/cli.js ---
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const yargs_1 = require("yargs");
const runner_1 = require("./runner");
const fs = __importStar(require("fs"));
const v8 = require("v8");
v8.setFlagsFromString("--experimental-wasm-bigint");
function serve(port) {
    console.info(`Serve on port ${port}.`);
}
yargs_1.scriptName("near-vm")
    .command({
    command: "run <wasmPath> <method> [input]",
    describe: "execute smart contract",
    builder: (yargs) => yargs.option("context", {
        describe: "path to VM context json file.",
    }),
    handler: (argv) => {
        const wasmBinary = fs.readFileSync(argv["wasmPath"]);
        const method = argv["method"];
        const input = argv["input"];
        runner_1.VMRunner.run(wasmBinary, method, input, argv["context"]);
    },
})
    .demandCommand(2)
    .help()
    .showHelpOnFail(true).argv;
//# sourceMappingURL=cli.js.map
'''
'''--- near-mock-vm/vm/dist/context.js ---
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createContext = exports.createDefault = void 0;
const js_base64_1 = require("js-base64");
const path = __importStar(require("path"));
function findContext(_path = "") {
    let paths = [
        _path,
        path.join(process.cwd(), "assembly", "__tests__"),
        process.cwd(),
        __dirname,
    ].map((p) => {
        if (!p.endsWith("context.json")) {
            return path.join(p, "context.json");
        }
        return p;
    });
    let _paths = paths.filter((p) => {
        try {
            require.resolve(p);
        }
        catch {
            return false;
        }
        return true;
    });
    let context = _paths.length > 0 ? require(_paths[0]) : null;
    if (context != null) {
        console.log("found path: " + _paths[0]);
        context.input = js_base64_1.Base64.encode(context.input);
    }
    return context;
}
const current_account_id = "alice";
const signer_account_id = "bob";
const signer_account_pk = "HuxUynD5GdrcZ5MauxJuu74sGHgS6wLfCqqhQkLWK";
const predecessor_account_id = "carol";
const input_str = '{"a":21,"b":21}';
const block_index = 10;
const block_timestamp = 42;
const epoch_height = 20;
const account_balance = "2";
const account_locked_balance = "1";
const storage_usage = 12;
const attached_deposit = "2";
const prepaid_gas = 10 ** 14;
const random_seed = "HuxUynD5GdrcZ5MauxJuu74sGHgS6wLfCqqhQkLWK";
const is_view = false;
const output_data_receivers = new Uint8Array([]);
function createDefault() {
    const _default = {
        /// The account id of the current contract that we are executing.
        current_account_id,
        /// The account id of that signed the original transaction that led to this
        /// execution.
        signer_account_id,
        /// The public key that was used to sign the original transaction that led to
        /// this execution.
        signer_account_pk,
        predecessor_account_id,
        input: js_base64_1.Base64.encode(input_str),
        block_index,
        block_timestamp,
        epoch_height,
        account_balance,
        account_locked_balance,
        storage_usage,
        attached_deposit,
        prepaid_gas,
        random_seed,
        is_view,
        output_data_receivers,
    };
    return _default;
}
exports.createDefault = createDefault;
function createContext(_path) {
    let context = findContext(_path) || createDefault();
    context.input = js_base64_1.Base64.encode(context.input);
    return context;
}
exports.createContext = createContext;
//# sourceMappingURL=context.js.map
'''
'''--- near-mock-vm/vm/dist/index.js ---
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./runner"), exports);
__exportStar(require("./memory"), exports);
//# sourceMappingURL=index.js.map
'''
'''--- near-mock-vm/vm/dist/memory.js ---
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Memory = void 0;
const utils = __importStar(require("./utils"));
const DEFAULT_MEMORY_DESC = { initial: 1024, maximum: 2048 };
class Memory {
    constructor(memory = DEFAULT_MEMORY_DESC) {
        if (memory instanceof WebAssembly.Memory) {
            this.Memory = memory;
        }
        else {
            this.Memory = new WebAssembly.Memory(memory);
        }
    }
    /** Access to memories buffer */
    get memory() {
        return new Uint8Array(this.Memory.buffer);
    }
    // Returns whether the memory interval is completely inside the smart contract memory.
    fits_memory(offset, len) {
        return utils.toNum(offset) + utils.toNum(len) < this.memory.length;
    }
    // Reads the content of the given memory interval.
    //
    // # Panics
    //
    // If memory interval is outside the smart contract memory.
    read_memory(offset, buffer) {
        offset = utils.toNum(offset);
        buffer.set(this.memory.slice(offset, offset + buffer.length), 0);
    }
    // Reads a single byte from the memory.
    //
    // # Panics
    //
    // If pointer is outside the smart contract memory.
    read_memory_u8(offset) {
        this.memory[utils.toNum(offset)];
    }
    // Writes the buffer into the smart contract memory.
    //
    // # Panics
    //
    // If `offset + buffer.len()` is outside the smart contract memory.
    write_memory(offset, buffer) {
        this.memory.set(buffer, utils.toNum(offset));
    }
    set(arr, offset) {
        this.memory.set(arr, offset);
    }
    slice(ptr, len) {
        return this.memory.slice(ptr, len);
    }
    readUTF8Str(ptr) {
        let arr = [];
        const mem = this.memory;
        while (mem[ptr] != 0) {
            arr.push(mem[ptr]);
            ptr++;
        }
        return utils.UTF8toStr(arr);
    }
}
exports.Memory = Memory;
//# sourceMappingURL=memory.js.map
'''
'''--- near-mock-vm/vm/dist/runner.js ---
"use strict";
/// <reference lib="dom" />
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.VMRunner = void 0;
const near_mock_vm_1 = require("../../pkg/near_mock_vm");
const context_1 = require("./context");
const memory_1 = require("./memory");
const js_base64_1 = require("js-base64");
const loader = __importStar(require("assemblyscript/lib/loader"));
const utils = __importStar(require("./utils"));
class VMRunner {
    constructor(memory, contextPath) {
        this.wasm = null;
        this.gas = 0;
        const context = context_1.createContext(contextPath);
        this.vm = new near_mock_vm_1.VM(context, memory);
        this.memory = memory;
        this.savedMemory = new Uint8Array(memory.memory.buffer);
    }
    static create(memory, contextPath) {
        let mem = new memory_1.Memory(memory);
        return new VMRunner(mem, contextPath);
    }
    static instrumentBinary(binary) {
        return Buffer.from(near_mock_vm_1.inject_contract(binary));
    }
    readUTF8Str(ptr) {
        let arr = [];
        let mem = this.memory.memory;
        while (mem[ptr] != 0) {
            arr.push(mem[ptr]);
            ptr++;
        }
        return utils.UTF8toStr(arr);
        // return this.memory.readUTF8Str(s);
    }
    createImports() {
        let vm = this.vm;
        let self = this;
        let memory = this.memory.Memory;
        let _imports = {
            vm: {
                saveMem() {
                    self.savedMemory = new Uint8Array(memory.buffer.slice(0, memory.buffer.byteLength));
                },
                restoreMem() {
                    new Uint8Array(memory.buffer).set(self.savedMemory);
                    if (memory.buffer.byteLength > self.savedMemory.byteLength) {
                        new Uint8Array(memory.buffer).fill(0, self.savedMemory.byteLength);
                        self.savedMemory = new Uint8Array(memory.buffer.slice(0, memory.buffer.byteLength));
                    }
                },
                restoreState() {
                    vm.reset();
                },
                outcome() {
                    let outcome = vm.outcome();
                    let strArrPtr = self.wasm.newStringArray();
                    for (let str of outcome.logs) {
                        strArrPtr = self.wasm.pushString(strArrPtr, self.wasm.__newString(str));
                    }
                    let return_data_ptr;
                    if (outcome.return_data === "None") {
                        return_data_ptr = self.wasm.None;
                    }
                    const balancePtr = self.wasm.__newString(outcome.balance);
                    let outcomePtr = new self.wasm.Outcome(balancePtr, BigInt(outcome.burnt_gas), BigInt(outcome.used_gas), strArrPtr, BigInt(outcome.storage_usage), return_data_ptr);
                    return outcomePtr.valueOf();
                },
                setCurrent_account_id(s) {
                    vm.set_current_account_id(self.readUTF8Str(s));
                },
                setInput(s) {
                    vm.set_input(js_base64_1.Base64.encode(self.readUTF8Str(s)));
                },
                setSigner_account_id(s) {
                    vm.set_signer_account_id(self.readUTF8Str(s));
                },
                /// The public key that was used to sign the original transaction that led to
                /// this execution.
                setSigner_account_pk(s) {
                    vm.set_signer_account_pk(self.readUTF8Str(s));
                },
                setPredecessor_account_id(s) {
                    vm.set_predecessor_account_id(self.readUTF8Str(s));
                },
                setBlock_index(block_height) {
                    vm.set_block_index(block_height);
                },
                setBlock_timestamp(stmp) {
                    vm.set_block_timestamp(stmp);
                },
                setAccount_balance(s) {
                    vm.set_account_balance(self.readUTF8Str(s));
                },
                setAccount_locked_balance(s) {
                    vm.set_account_locked_balance(self.readUTF8Str(s));
                },
                setStorage_usage(amt) {
                    vm.set_storage_usage(amt);
                },
                setAttached_deposit(s) {
                    vm.set_attached_deposit(self.readUTF8Str(s));
                },
                setPrepaid_gas(_u64) {
                    vm.set_prepaid_gas(_u64);
                },
                setRandom_seed(s) {
                    vm.set_random_seed(self.readUTF8Str(s));
                },
                setIs_view(b) {
                    vm.set_is_view(b == 1);
                },
                setEpoch_height(_u64) {
                    vm.set_epoch_height(_u64);
                },
                // setOutput_data_receivers(arr) {
                //   vm.set_output_data_receivers(arr);
                // },
                setValidator(s, b) {
                    vm.set_validator(self.readUTF8Str(s), self.readUTF8Str(b));
                },
            },
            env: {
                memory,
                /// #################
                /// # Registers API #
                /// #################
                // write_register(data_len, data_ptr, register_id: BigInt) {
                //   return vm.write_register(data_len, data_ptr, register_id);
                // },
                read_register(register_id, ptr) {
                    return vm.read_register(register_id, ptr);
                },
                register_len(register_id) {
                    return vm.register_len(register_id);
                },
                // ###############
                // # Context API #
                // ###############
                current_account_id(register_id) {
                    return vm.current_account_id(register_id);
                },
                signer_account_id(register_id) {
                    return vm.signer_account_id(register_id);
                },
                signer_account_pk(register_id) {
                    return vm.signer_account_pk(register_id);
                },
                predecessor_account_id(register_id) {
                    return vm.predecessor_account_id(register_id);
                },
                input(register_id) {
                    return vm.input(register_id);
                },
                block_index() {
                    return vm.block_index();
                },
                block_timestamp() {
                    return vm.block_timestamp();
                },
                epoch_height() {
                    return vm.epoch_height();
                },
                storage_usage() {
                    return vm.storage_usage();
                },
                // #################
                // # Economics API #
                // #################
                account_balance(balance_ptr) {
                    return vm.account_balance(balance_ptr);
                },
                account_locked_balance(ptr) {
                    vm.account_locked_balance(ptr);
                },
                attached_deposit(balance_ptr) {
                    return vm.attached_deposit(balance_ptr);
                },
                prepaid_gas() {
                    return vm.prepaid_gas();
                },
                used_gas() {
                    return vm.used_gas();
                },
                // ############
                // # Math API #
                // ############
                random_seed(register_id) {
                    return vm.random_seed(register_id);
                },
                sha256(value_len, value_ptr, register_id) {
                    return vm.sha256(value_len, value_ptr, register_id);
                },
                keccak256(value_len, value_ptr, register_id) {
                    return vm.keccak256(value_len, value_ptr, register_id);
                },
                keccak512(value_len, value_ptr, register_id) {
                    return vm.keccak512(value_len, value_ptr, register_id);
                },
                // #####################
                // # Miscellaneous API #
                // #####################
                value_return(value_len, value_ptr) {
                    return vm.value_return(value_len, value_ptr);
                },
                panic() {
                    return vm.panic();
                },
                log_utf8(len, ptr) {
                    return vm.log_utf8(len, ptr);
                },
                log_utf16(len, ptr) {
                    return vm.log_utf16(len, ptr);
                },
                // ################
                // # Promises API #
                // ################
                promise_create(account_id_len, account_id_ptr, method_name_len, method_name_ptr, arguments_len, arguments_ptr, amount_ptr, gas) {
                    return vm.promise_create(account_id_len, account_id_ptr, method_name_len, method_name_ptr, arguments_len, arguments_ptr, amount_ptr, gas);
                },
                promise_then(promise_index, account_id_len, account_id_ptr, method_name_len, method_name_ptr, arguments_len, arguments_ptr, amount_ptr, gas) {
                    return vm.promise_then(promise_index, account_id_len, account_id_ptr, method_name_len, method_name_ptr, arguments_len, arguments_ptr, amount_ptr, gas);
                },
                promise_and(promise_idx_ptr, promise_idx_count) {
                    return vm.promise_and(promise_idx_ptr, promise_idx_count);
                },
                promise_results_count() {
                    return vm.promise_results_count();
                },
                promise_result(result_idx, register_id) {
                    return vm.promise_result(result_idx, register_id);
                },
                promise_return(promise_id) {
                    return vm.promise_return(promise_id);
                },
                promise_batch_create(account_id_len, account_id_ptr) {
                    return vm.promise_batch_create(account_id_len, account_id_ptr);
                },
                promise_batch_then(promise_index, account_id_len, account_id_ptr) {
                    return vm.promise_batch_then(promise_index, account_id_len, account_id_ptr);
                },
                // #######################
                // # Promise API actions #
                // #######################
                promise_batch_action_create_account(promise_index) {
                    return vm.promise_batch_action_create_account(promise_index);
                },
                promise_batch_action_deploy_contract(promise_index, code_len, code_ptr) {
                    return vm.promise_batch_action_deploy_contract(promise_index, code_len, code_ptr);
                },
                promise_batch_action_function_call(promise_index, method_name_len, method_name_ptr, arguments_len, arguments_ptr, amount_ptr, gas) {
                    return vm.promise_batch_action_function_call(promise_index, method_name_len, method_name_ptr, arguments_len, arguments_ptr, amount_ptr, gas);
                },
                promise_batch_action_transfer(promise_index, amount_ptr) {
                    return vm.promise_batch_action_transfer(promise_index, amount_ptr);
                },
                promise_batch_action_stake(promise_index, amount_ptr, public_key_len, public_key_ptr) {
                    return vm.promise_batch_action_stake(promise_index, amount_ptr, public_key_len, public_key_ptr);
                },
                promise_batch_action_add_key_with_full_access(promise_index, public_key_len, public_key_ptr, nonce) {
                    return vm.promise_batch_action_add_key_with_full_access(promise_index, public_key_len, public_key_ptr, nonce);
                },
                promise_batch_action_add_key_with_function_call(promise_index, public_key_len, public_key_ptr, nonce, allowance_ptr, receiver_id_len, receiver_id_ptr, method_names_len, method_names_ptr) {
                    return vm.promise_batch_action_add_key_with_function_call(promise_index, public_key_len, public_key_ptr, nonce, allowance_ptr, receiver_id_len, receiver_id_ptr, method_names_len, method_names_ptr);
                },
                promise_batch_action_delete_key(promise_index, public_key_len, public_key_ptr) {
                    return vm.promise_batch_action_delete_key(promise_index, public_key_len, public_key_ptr);
                },
                promise_batch_action_delete_account(promise_index, beneficiary_id_len, beneficiary_id_ptr) {
                    return vm.promise_batch_action_delete_account(promise_index, beneficiary_id_len, beneficiary_id_ptr);
                },
                // ###############
                // # Storage API #
                // ###############
                storage_write(key_len, key_ptr, value_len, value_ptr, register_id) {
                    return vm.storage_write(key_len, key_ptr, value_len, value_ptr, register_id);
                },
                storage_read(key_len, key_ptr, register_id) {
                    return vm.storage_read(key_len, key_ptr, register_id);
                },
                storage_remove(key_len, key_ptr, register_id) {
                    return vm.storage_remove(key_len, key_ptr, register_id);
                },
                storage_has_key(key_len, key_ptr) {
                    return vm.storage_has_key(key_len, key_ptr);
                },
                // // Function for the injected gas counter. Automatically called by the gas meter.
                gas(gas_amount) {
                    self.gas += gas_amount;
                    return vm.gas(gas_amount);
                },
                // Validator API
                validator_stake(id_len, id_ptr, data_ptr) {
                    return vm.validator_stake(id_len, id_ptr, data_ptr);
                },
                validator_total_stake(data_ptr) {
                    return vm.validator_total_stake(data_ptr);
                },
            },
        };
        return _imports;
    }
    run(method, input) {
        this.vm.set_input(js_base64_1.Base64.encode(input));
        this.wasm.exports[method]();
    }
    static setup(binary, contextPath, memory) {
        const vm = VMRunner.create(memory, contextPath);
        const instrumented_bin = VMRunner.instrumentBinary(binary);
        const wasm = loader.instantiateSync(instrumented_bin, vm.createImports());
        vm.wasm = wasm;
        vm.memory = new memory_1.Memory(wasm.exports.memory);
        return vm;
    }
    outcome() {
        return this.vm.outcome();
    }
    created_receipts() {
        return this.vm.created_receipts();
    }
    static run(binary, method, input, contextPath) {
        const runner = VMRunner.setup(binary, contextPath);
        runner.run(method, input);
        let after = runner.outcome();
        // console.log(after);
        console.log("calls to injected gas: " + runner.gas);
        console.log("Gas used after startup: " + after.used_gas / 10 ** 12);
        console.log("Outcome:");
        console.log(after);
        const receipts = runner.created_receipts();
        if (receipts.length > 0) {
            console.log("Receipts: ");
            console.log(receipts);
        }
    }
}
exports.VMRunner = VMRunner;
//# sourceMappingURL=runner.js.map
'''
'''--- near-mock-vm/vm/dist/utils.js ---
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createU128Str = exports.StrtoUTF8 = exports.UTF8toStr = exports.toNum = void 0;
const bn_js_1 = __importDefault(require("bn.js"));
function toNum(x) {
    return parseInt(x.toString());
}
exports.toNum = toNum;
// http://www.onicos.com/staff/iz/amuse/javascript/expert/utf.txt
/* utf.js - UTF-8 <=> UTF-16 convertion
 *
 * Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>
 * Version: 1.0
 * LastModified: Dec 25 1999
 * This library is free.  You can redistribute it and/or modify it.
 */
function UTF8toStr(array) {
    var out, i, len, c;
    var char2, char3;
    out = "";
    len = array.length;
    i = 0;
    while (i < len) {
        c = array[i++];
        switch (c >> 4) {
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
                // 0xxxxxxx
                out += String.fromCharCode(c);
                break;
            case 12:
            case 13:
                // 110x xxxx   10xx xxxx
                char2 = array[i++];
                out += String.fromCharCode(((c & 0x1f) << 6) | (char2 & 0x3f));
                break;
            case 14:
                // 1110 xxxx  10xx xxxx  10xx xxxx
                char2 = array[i++];
                char3 = array[i++];
                out += String.fromCharCode(((c & 0x0f) << 12) | ((char2 & 0x3f) << 6) | ((char3 & 0x3f) << 0));
                break;
        }
    }
    return out;
}
exports.UTF8toStr = UTF8toStr;
function StrtoUTF8(str) {
    var utf8 = [];
    for (var i = 0; i < str.length; i++) {
        var charcode = str.charCodeAt(i);
        if (charcode < 0x80)
            utf8.push(charcode);
        else if (charcode < 0x800) {
            utf8.push(0xc0 | (charcode >> 6), 0x80 | (charcode & 0x3f));
        }
        else if (charcode < 0xd800 || charcode >= 0xe000) {
            utf8.push(0xe0 | (charcode >> 12), 0x80 | ((charcode >> 6) & 0x3f), 0x80 | (charcode & 0x3f));
        }
        // surrogate pair
        else {
            i++;
            // UTF-16 encodes 0x10000-0x10FFFF by
            // subtracting 0x10000 and splitting the
            // 20 bits of 0x0-0xFFFFF into two halves
            charcode =
                0x10000 + (((charcode & 0x3ff) << 10) | (str.charCodeAt(i) & 0x3ff));
            utf8.push(0xf0 | (charcode >> 18), 0x80 | ((charcode >> 12) & 0x3f), 0x80 | ((charcode >> 6) & 0x3f), 0x80 | (charcode & 0x3f));
        }
    }
    return new Uint8Array(utf8);
}
exports.StrtoUTF8 = StrtoUTF8;
function createU128Str(lo, hi) {
    const num = new bn_js_1.default(hi.toString());
    return num.shln(64).add(new bn_js_1.default(lo.toString())).toString();
}
exports.createU128Str = createU128Str;
//# sourceMappingURL=utils.js.map
'''
'''--- near-mock-vm/vm/index.js ---
module.exports = require("./dist");
'''
'''--- near-mock-vm/vm/tests/index.js ---
const v8 = require('v8');
let runner = require('..').VMRunner;
let fs = require("fs");
let assert = require("assert");

const nodeVersion = process.versions.node;

if (
    parseInt(nodeVersion.substring(0, nodeVersion.indexOf('.'))) < 16
) {
    v8.setFlagsFromString("--experimental-wasm-bigint");
}

let bin = fs.readFileSync(__dirname + "/../../build/debug/main.wasm");
// console.log(bin.length)
let instd = Buffer.from(runner.instrumentBinary(bin));
assert(WebAssembly.validate(instd), "binary is valid wasm");
// assert(instd.length - bin.length > 0 , "instrumented binary should be bigger");
// const original = new WebAssembly.Module(bin);
const instrumented = new WebAssembly.Module(instd);
// console.log(WebAssembly.Module.imports(original));
const newImports = WebAssembly.Module.imports(instrumented);
assert(newImports.some(_import => _import.name == "gas" && _import.kind == "function" ),
      "Instrumented module's imports should include a gas function");
'''
'''--- near-mock-vm/vm/tests/runWasm.js ---
let rust = require("../../pkg/wasm_mock_vm");
let fs = require("fs");

global.run_binary = (bin, method) => {
  let mod = new WebAssembly.Module(bin);
  let inst = new WebAssembly.Instance(mod, {});
  return BigInt(inst.exports[method](1, 2));
}
let bin = fs.readFileSync("src/mock/add.wasm")
rust.run(bin);

'''
'''--- near-mock-vm/vm/tests/setup.js ---

const utils = require('../dist/utils');

module.exports = async () => {
  const res = {
    decode: (bs) => {
      return JSON.parse(utils.UTF8toStr(bs));
    },
    encode: (obj) => {
      return utils.StrtoUTF8(JSON.stringify(obj));
    }
  }
  Object.setPrototypeOf(Object, {...Object.prototype, 
  ...res})
  return res
}
'''
'''--- near-mock-vm/vm/tests/test.js ---
let runner = require("..").VMRunner;
let assert = require("assert");
let utils = require('../dist/utils');

let vm = runner.create();
const memory = vm.memory.memory;
vm = vm.vm;
vm.signer_account_pk(BigInt(1));
ptr = 0;
let len = utils.toNum(vm.register_len(BigInt(1)));
vm.read_register(BigInt(1), BigInt(ptr));

function readReg(id) {
    const ptr = 10;
    let len = utils.toNum(vm.register_len(BigInt(id)));
    let before = memory.slice(ptr, ptr + len);
    vm.read_register(BigInt(id), BigInt(ptr));
    const res = memory.slice(ptr, ptr + utils.toNum(len));
    memory.set(before, ptr);
    return res;
}
// vm.read_register(BigInt(1), BigInt(1));
// assert.equal(bs58.encode(Buffer.from(readReg(1))), signer_account_pk);

debugger;
// vm.read_register(BigInt(0), BigInt(0));
// assert(memory[0] == 42);
// memory[1] = 85;
// vm.write_register(BigInt(1), BigInt(1), BigInt(1));
// assert.equal(readReg(1)[0], 85);

// vm.input(BigInt(0));
// assert.equal(utils.UTF8toStr(readReg(0)), input_str);

function storage_write(_key, _value) {
    let key = utils.StrtoUTF8(_key);
    let value = utils.StrtoUTF8(_value);
    memory.set(key, 1000);
    memory.set(value, 2000);
    vm.storage_write(BigInt(key.length), BigInt(1000), BigInt(value.length), BigInt(2000), BigInt(1));
    vm.storage_read(BigInt(key.length), BigInt(1000), BigInt(1));
}

function storage_read(_key, ptr) {
    let key = utils.StrtoUTF8(_key);
    memory.set(key, ptr);
    vm.storage_read(BigInt(key.length), BigInt(ptr), BigInt(0));
    return utils.UTF8toStr(readReg(0));
}

function storage_has_key(_key) {
    let key = utils.StrtoUTF8(_key);
    const saved = memory.slice(1000, 1000 + key.length);
    memory.set(key, 1000);
    let res = vm.storage_has_key(BigInt(key.length), BigInt(1000));
    memory.set(saved, 1000);
    return res;
}

const data = "I am data";
storage_write("key", data);
assert.equal(storage_read("key", 1000), data)
// assert.deepEqual(utils.UTF8toStr(memory.slice(1000, 1000 + toNum(vm.register_len(BigInt(0))))), data);
assert(storage_has_key("key"));

var errored = false
// vm.read_register(BigInt(10), BigInt(0));
storage_write("key1", data);

let key = utils.StrtoUTF8("key");
// const saved = memory.slice(1000, 1000 + key.length);
memory.set(key, 2000);

// let iterid = vm.storage_iter_prefix(BigInt(key.length), BigInt(2000));
// console.log(iterid);
// vm.storage_iter_next(iterid, BigInt(2), BigInt(3));
// console.log(utils.UTF8toStr(readReg(2)),utils.UTF8toStr(readReg(3)));
// vm.storage_iter_next(iterid, BigInt(2), BigInt(3));
// console.log(utils.UTF8toStr(readReg(2)),utils.UTF8toStr(readReg(3)));

// storage_write("aa", "bar1");
// storage_write("aaa", "bar2");
// storage_write("ab", "bar2");
// storage_write("abb", "bar3");

// key = utils.StrtoUTF8("key");
// // const saved = memory.slice(1000, 1000 + key.length);
// memory.set(key, 2000);

key2 = utils.StrtoUTF8("key9");
// const saved = memory.slice(1000, 1000 + key.length);
memory.set(key2, 3000);

// iterid = vm.storage_iter_range(BigInt(key.length), BigInt(2000), BigInt(key2.length), BigInt(3000));
// console.log(iterid);
// while (vm.storage_iter_next(iterid, BigInt(2), BigInt(3)) > 0) {
//     console.log(utils.UTF8toStr(readReg(2)),utils.UTF8toStr(readReg(3)));
// }
str = utils.StrtoUTF8("hello dolly!");
memory.set(str, 4000);
vm.log_utf8(BigInt(str.length), BigInt(4000));

console.log(vm.outcome());
// vm.read_register(BigInt(0), BigInt(0));
// assert(memory[0] == 84);

// vm.signer_account_pk(BigInt(1));

// assert.equal(vm.storage_usage(), storage_usage);
// assert.equal(vm.used_gas(), used_gas);
// assert.equal(vm.)

vm.set_current_account_id("Bobby");
vm.current_account_id(BigInt(0));
console.log(utils.UTF8toStr(readReg(0)));
assert.equal(storage_read("key", 1000), data);

assert(vm.block_timestamp() == 42);

// rust.pass_context(context);
// rust.set_context(new VMContext());
// vm.abort();
console.log("PASSED!");
'''
'''--- nearcore-tests/asconfig.js ---
const compile = require("../compiler").compile;

compile("../sdk/assembly/__tests__/runtime/main.ts", // input file
        "out/main.wasm",    // output file
        [
        //   "-O1",            // Optional arguments
        "--debug",
        "--measure",
        "--runPasses", "inlining-optimizing,dce",
        ],
        {verbose: true});

// compile("assembly/hello/main.ts", // input file
//         "out/hello/main.wasm",    // output file
//         [
//         //   "-O1",            // Optional arguments
//         "--debug",
//         "--measure",
//         "--runPasses", "inlining,dce",
//         ],
//         {verbose: true});

'''
'''--- nearcore-tests/verifyBatch.js ---
#!/usr/bin/env node

const assertNoDiff = require("assert-no-diff")
const outcomeStr = process.argv[2];
let outcome = JSON.parse(outcomeStr);
const expected = { 
  "outcome": {
    "balance": "4",
    "storage_usage": 0,
    "return_data": "None",
    "burnt_gas": 8106380049138,
    "used_gas": 14691459389832,
    "logs": []
 },
 "err": null,
 "receipts": [
    {
       "receipt_indices": [],
       "receiver_id": "test.account",
       "actions": [
          "CreateAccount",
          {
             "AddKeyWithFunctionCall": {
                "public_key": "1SnaTomvVzRgZah6Xh34z5xR4HUTRP67KxB8btMFqc9m",
                "nonce": 0,
                "allowance": null,
                "receiver_id": "testing.account",
                "method_names": [
                   "send",
                   "receive"
                ]
             }
          },
          {
             "AddKeyWithFullAccess": {
                "public_key": "1SnaTomvVzRgZah6Xh34z5xR4HUTRP67KxB8btMFqc9m",
                "nonce": 0
             }
          },
          {
             "DeleteKey": {
                "public_key": "1SnaTomvVzRgZah6Xh34z5xR4HUTRP67KxB8btMFqc9m"
             }
          },
          {
             "DeployContract": {
                "code": []
             }
          },
          {
             "FunctionCall": {
                "method_name": "send",
                "args": "",
                "gas": 0,
                "deposit": 0
             }
          },
          {
             "Stake": {
                "stake": 0,
                "public_key": "1SnaTomvVzRgZah6Xh34z5xR4HUTRP67KxB8btMFqc9m"
             }
          },
          {
             "Transfer": {
                "deposit": 0
             }
          },
          {
             "DeleteAccount": {
                "beneficiary_id": "bene.account"
             }
          }
       ]
    },
    {
       "receipt_indices": [],
       "receiver_id": "app-v1.bob.testnet",
       "actions": [
          "CreateAccount",
          {
             "Transfer": {
                "deposit": 1
             }
          },
          {
             "AddKeyWithFullAccess": {
                "public_key": "15T",
                "nonce": 0
             }
          },
          {
             "DeployContract": {
                "code": [
                   0,
                   1,
                   90,
                   100
                ]
             }
          }
       ]
    },
    {
       "receipt_indices": [],
       "receiver_id": "first-contract.bob.testnet",
       "actions": [
          "CreateAccount"
       ]
    },
    {
       "receipt_indices": [
          2
       ],
       "receiver_id": "first-contract.bob.testnet",
       "actions": [
          {
             "Transfer": {
                "deposit": 10
             }
          }
       ]
    }
 ],
 "state": {}
}
assertNoDiff.json(outcome.receipts, expected.receipts, "Batch receipts should be the same")
assertNoDiff.chars(outcome.outcome.balance, expected.outcome.balance, "Balances should be the same")

'''
'''--- sdk/as-pect.config.js ---
module.exports = require('./imports');

'''
'''--- sdk/assembly/__tests__/data.txt ---
Hello World!
'''
'''--- sdk/compiler.js ---
module.exports = require("near-sdk-bindgen/compiler");
'''
'''--- sdk/imports.js ---
const v8 = require('v8');

const nodeVersion = process.versions.node;

if (
    parseInt(nodeVersion.substring(0, nodeVersion.indexOf('.'))) < 16
) {
  v8.setFlagsFromString("--experimental-wasm-bigint");
}

let rust = require("near-mock-vm/vm");
let path = require("path");
let posixRelativePath = require("near-sdk-bindgen/dist/utils").posixRelativePath;

function createImports(memory, createImports, instantiateSync, binary) {
  let wasm;
  const runner = rust.VMRunner.create(memory);
  const _imports = runner.createImports();
  wasm = instantiateSync(binary, createImports(_imports));
  // Save reference to the instance
  runner.wasm = wasm.exports || wasm;
  return wasm;
}

module.exports = {
  /**
   * A set of globs passed to the glob package that qualify typescript files for testing.
   */
  include: ["assembly/__tests__/**/*.spec.ts"],
  /**
   * A set of globs passed to the glob package that quality files to be added to each test.
   */
  add: ["assembly/__tests__/**/*.include.ts"],
  /**
   * All the compiler flags needed for this test suite. Make sure that a binary file is output.
   */
  flags: {
    "--debug": [],
    /** 
     * This is required. Do not change this. 
     * The filename is ignored, but required by the compiler. 
     * */
    "--binaryFile": ["output.wasm"],
    /** To enable wat file output, use the following flag. The filename is ignored, but required by the compiler. */
    // "--textFile": ["output.wat"],
    /** To select an appropriate runtime, use the --runtime compiler flag. */
    "--runtime": ["stub"], // Acceptable values are: full, half, stub (arena),
    "--baseDir": process.cwd(),
    "--runPasses": ["inlining,dce"],
    "--config": path.join(__dirname, "asp.asconfig.json"),
    // "--showConfig": []
  },
  /**
   * A set of regexp that will disclude source files from testing.
   */
  disclude: [/node_modules/],
  /**
   * Add your required AssemblyScript imports here.
   */
  imports: createImports,
  /**
   * All performance statistics reporting can be configured here.
   */
  performance: {
    /** Enable performance statistics gathering for every test. */
    enabled: false,
    /** Set the maximum number of samples to run for every test. */
    maxSamples: 10000,
    /** Set the maximum test run time in milliseconds for every test. */
    maxTestRunTime: 2000,
    /** Report the median time in the default reporter for every test. */
    reportMedian: true,
    /** Report the average time in milliseconds for every test. */
    reportAverage: true,
    /** Report the standard deviation for every test. */
    reportStandardDeviation: false,
    /** Report the maximum run time in milliseconds for every test. */
    reportMax: false,
    /** Report the minimum run time in milliseconds for every test. */
    reportMin: false,
  },
  /**
   * Add a custom reporter here if you want one. The following example is in typescript.
   *
   * @example
   * import { TestReporter, TestGroup, TestResult, TestContext } from "as-pect";
   *
   * export class CustomReporter extends TestReporter {
   *   // implement each abstract method here
   *   public abstract onStart(suite: TestContext): void;
   *   public abstract onGroupStart(group: TestGroup): void;
   *   public abstract onGroupFinish(group: TestGroup): void;
   *   public abstract onTestStart(group: TestGroup, result: TestResult): void;
   *   public abstract onTestFinish(group: TestGroup, result: TestResult): void;
   *   public abstract onFinish(suite: TestContext): void;
   * }
   */
  // reporter: new CustomReporter(),
  /**
   * Specify if the binary wasm file should be written to the file system.
   */
  outputBinary: false
};

'''
'''--- simulator/asconfig.js ---
const asb = require("asbuild").main;

function compile_file(f) {
  asb(["assembly/__tests__/" + f, ...process.argv.slice(2)]);
}

let tests = [
  "sentences.ts",
  "words.ts",
  "avlTreeContract.ts",
  "empty.ts",
  "exportAs.ts",
  "singleton.ts",
  "singleton-no-constructor.ts",
  "transfer.ts",
];

tests.map(compile_file);

'''
'''--- simulator/dist/bin.js ---
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
//@ts-ignore
__exportStar(require("near-vm/run"), exports);
//# sourceMappingURL=bin.js.map
'''
'''--- simulator/dist/context.js ---
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createContext = exports.prepareContext = exports.defaultAccountContext = exports.defaultContext = void 0;
const js_base64_1 = require("js-base64");
const types_1 = require("./types");
function defaultContext() {
    return {
        input: "{}",
        output_data_receivers: [],
        prepaid_gas: types_1.DEFAULT_GAS,
        attached_deposit: "0",
        is_view: false,
        block_index: 1,
        block_timestamp: 42,
        epoch_height: 1,
        storage_usage: 100,
        random_seed: "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7",
        current_account_id: "alice",
        signer_account_id: "alice",
        predecessor_account_id: "bob",
        account_balance: "1000",
        signer_account_pk: "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7",
        account_locked_balance: "10",
    };
}
exports.defaultContext = defaultContext;
function defaultAccountContext() {
    return {
        input: "{}",
        input_data: [],
        output_data_receivers: [],
        prepaid_gas: types_1.DEFAULT_GAS,
        attached_deposit: "0",
        is_view: false,
    };
}
exports.defaultAccountContext = defaultAccountContext;
function prepareContext(vmcontext) {
    vmcontext.input = js_base64_1.Base64.encode(vmcontext.input);
    return vmcontext;
}
exports.prepareContext = prepareContext;
function createContext(accountContext, context = defaultContext()) {
    for (let key of Object.getOwnPropertyNames(context)) {
        //@ts-ignore
        if (accountContext[key] != undefined) {
            //@ts-ignore
            context[key] = accountContext[key];
        }
    }
    return prepareContext(context);
}
exports.createContext = createContext;
//# sourceMappingURL=context.js.map
'''
'''--- simulator/dist/index.js ---
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./runtime"), exports);
__exportStar(require("./context"), exports);
__exportStar(require("./utils"), exports);
//# sourceMappingURL=index.js.map
'''
'''--- simulator/dist/runtime.js ---
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Runtime = exports.Account = void 0;
const child_process_1 = require("child_process");
const os = __importStar(require("os"));
const fs = __importStar(require("fs"));
const utils_1 = require("./utils");
const context_1 = require("./context");
const types_1 = require("./types");
const DEFAULT_BALANCE = 1000000000000;
/**
 * Account object of client and contracts.
 */
class Account {
    /**
     * Sholud only be constructed by a runtime instance.
     * @param account_id
     * @param wasmFile
     * @param runtime
     */
    constructor(account_id, wasmFile = null, runtime) {
        this.account_id = account_id;
        this.wasmFile = wasmFile;
        this.runtime = runtime;
        this.internalState = {};
        this.balance = DEFAULT_BALANCE;
        this.lockedBalance = 0;
        this.storage_usage = 60;
        this.signerAccountPk = utils_1.encodeBs58(account_id.slice(0, 32).padEnd(32, " "));
        this.runtime.log(this.signerAccountPk);
        if (wasmFile != null && !fs.existsSync(wasmFile)) {
            throw new Error(`Path ${wasmFile} to contract wasm file doesn't exist`);
        }
    }
    createAccountContext(input = {}, prepaid_gas = types_1.DEFAULT_GAS) {
        input = JSON.stringify(input);
        let accountContext = {
            input,
            prepaid_gas,
            signer_account_pk: this.account_id,
        };
        return accountContext;
    }
    /**
     * Single execution of contract method.
     * @param account_id contractId to call
     * @param method_name method to call
     * @param input object of arguments of method
     * @param prepaid_gas How much gas to use.
     */
    call_step_other(account_id, method_name, input = {}, prepaid_gas = types_1.DEFAULT_GAS) {
        if (this.runtime == null)
            throw new Error("Runtime is not set");
        let accountContext = this.createAccountContext(input, prepaid_gas);
        accountContext.signer_account_id = this.signerAccountPk;
        return this.runtime.call_step(account_id, method_name, accountContext.input, accountContext);
    }
    /**
     * Single execution of contract method to the same contract.
     * @param method_name method to call
     * @param input object of arguments of method
     * @param prepaid_gas How much gas to use.
     */
    call_step(method_name, input, prepaid_gas) {
        return this.call_step_other(this.account_id, method_name, input, prepaid_gas);
    }
    /**
     * Execute contract and any promises generated until no more promises are generated or gas runs out.
     * @param account_id Initial Contract to call.
     * @param method_name Method to call.
     * @param input object of input to method.
     * @param prepaid_gas How much gas to use.
     * @param attached_deposit How many tokens to send to the contract
     */
    call_other(account_id, method_name, input, prepaid_gas = types_1.DEFAULT_GAS, attached_deposit = "0") {
        if (this.runtime == null)
            throw new Error("Runtime is not set");
        let accountContext = this.createAccountContext(input, prepaid_gas);
        accountContext.signer_account_id = this.account_id;
        if (attached_deposit) {
            accountContext.attached_deposit = attached_deposit;
        }
        this.runtime.log("Account Signer ID: " + accountContext.signer_account_id);
        this.runtime.log(accountContext);
        return this.runtime.call(account_id, method_name, accountContext.input, accountContext);
    }
    /**
     * Execute this contract and any promises generated until no more promises are generated or gas runs out.
     * @param method_name Method to call.
     * @param input object of input to method.
     * @param prepaid_gas How much gas to use.
     */
    call(method_name, input, prepaid_gas) {
        return this.call_other(this.account_id, method_name, input, prepaid_gas);
    }
    /**
     * View contract call to this contract.
     * @param method_name view method.
     * @param input object of input to method.
     */
    view(method_name, input) {
        if (this.runtime == null)
            throw new Error("Runtime is not set");
        let accountContext = this.createAccountContext(input);
        accountContext.is_view = true;
        const result = this.runtime.call_step(this.account_id, method_name, accountContext.input, accountContext);
        var return_data = (result.outcome && result.outcome.return_data);
        if (return_data && return_data.Value) {
            return_data = JSON.parse(return_data.Value);
        }
        const err = result["err"];
        return {
            return_data,
            err,
            result,
        };
    }
    /**
     * Current state of contract.
     */
    get state() {
        return utils_1.decodeState(this.internalState);
    }
    set state(state) {
        this.internalState = utils_1.encodeState(state);
        this.storage_usage = utils_1.stateSize(state);
    }
    reset() {
        this.internalState = {};
        this.balance = DEFAULT_BALANCE;
        this.lockedBalance = 0;
        this.storage_usage = 60;
    }
}
exports.Account = Account;
class Runtime {
    constructor() {
        this.accounts = new Map();
        if (os.type() === "Windows_NT") {
            console.error("Windows is not supported.");
            process.exit(0);
        }
        /**
         * run binary if it doesn't exist so that it installs itself.
         */
        try {
            child_process_1.spawnSync("node", [__dirname + "/bin.js"]);
        }
        catch (e) { }
    }
    log(input) {
        if (process.env.DEBUG) {
            console.log(input);
        }
    }
    newAccount(accoundId, wasmFile = null) {
        const account = new Account(accoundId, wasmFile, this);
        account.runtime = this;
        this.accounts.set(accoundId, account);
        return account;
    }
    getOrCreateAccount(account_id) {
        return this.accounts.get(account_id) || this.newAccount(account_id);
    }
    getAccount(account_id) {
        const account = this.accounts.get(account_id);
        if (account == undefined)
            throw new Error(account_id + " has not be added.");
        return account;
    }
    setContext(context) {
        this.context = { ...context_1.defaultContext(), ...context };
    }
    call_step(account_id, method_name, input = "", accountContext = context_1.defaultAccountContext()) {
        accountContext.signer_account_id =
            accountContext.signer_account_id || account_id;
        accountContext.input = input;
        accountContext.predecessor_account_id =
            accountContext.predecessor_account_id || accountContext.signer_account_id;
        const context = utils_1.assign(context_1.defaultAccountContext(), accountContext);
        const signer_account = this.getOrCreateAccount(context.signer_account_id);
        const predecessor_account = this.getAccount(context.predecessor_account_id);
        const account = this.getAccount(account_id);
        context.current_account_id = account.account_id;
        context.signer_account_pk = signer_account.signerAccountPk;
        context.account_balance = account.balance.toString();
        context.account_locked_balance = account.lockedBalance.toString();
        context.input = input;
        context.storage_usage = account.storage_usage;
        const vmContext = context_1.createContext(context, this.context);
        this.log(JSON.stringify(vmContext));
        let args = [
            __dirname + "/bin.js",
            "--context=" + JSON.stringify(vmContext),
            "--input=" + input,
            "--wasm-file=" + account.wasmFile,
            "--method-name=" + method_name,
            "--state=" + JSON.stringify(account.internalState),
        ];
        for (let data of accountContext.input_data || []) {
            args.push("--promise-results=" + JSON.stringify(data));
        }
        var result = this.spawn(args);
        if (!context.is_view && result.err == null) {
            account.balance = result.outcome.balance;
            account.internalState = result.state;
            account.storage_usage = result.outcome.storage_usage;
        }
        result.state = utils_1.decodeState(result.state);
        this.log(result);
        return result;
    }
    call(account_id, method_name, input = "", accountContext) {
        const q = [
            {
                ...accountContext,
                index: 0,
                account_id,
                method_name,
                input,
            },
        ];
        var numReceipts = 1;
        const all_input_data = {};
        const all_output_data = {};
        var num_data = 0;
        var return_index = 0;
        const calls = {};
        const results = {};
        while (q.length > 0) {
            let c = q.shift();
            let index = c["index"];
            let input_data = [];
            if (c.input_data) {
                for (let d of c.input_data) {
                    if (all_input_data[d] != undefined) {
                        input_data.push(all_input_data[d]);
                    }
                    else {
                        break;
                    }
                }
                if (input_data.length < c.input_data.length) {
                    q.push(c);
                    continue;
                }
            }
            let output_data = all_output_data[index] || [];
            calls[index] = c;
            this.log(`Call ${JSON.stringify(c)} Output ${JSON.stringify(output_data)}`);
            let accountContext = {
                ...c,
                output_data_receivers: output_data.map((d) => d.account_id),
                input_data,
            };
            let result = this.call_step(c.account_id, c.method_name, c.input, accountContext);
            results[index] = result;
            this.log(`Result:`);
            this.log(result);
            if (result) {
                if (result.outcome) {
                    for (let log of result.outcome.logs) {
                        this.log(`${c.account_id}: ${log}`);
                    }
                    if (result.err) {
                        let result_data = { Failed: null };
                        for (let d of output_data) {
                            all_input_data[d.data_id] = result_data;
                        }
                    }
                    else {
                        let ret = result.outcome.return_data;
                        if (typeof ret == "string" || ret.Value != undefined) {
                            let result_data = {
                                Successful: typeof ret == "string" ? "" : ret.Value,
                            };
                            for (let d of output_data) {
                                all_input_data[d.data_id] = result_data;
                            }
                        }
                        else if (ret.ReceiptIndex != undefined) {
                            let adj_index = ret.ReceiptIndex + numReceipts;
                            if (!all_output_data[adj_index]) {
                                all_output_data[adj_index] = [];
                            }
                            for (let d of output_data) {
                                all_output_data[adj_index].push(d);
                            }
                            if (return_index == index) {
                                return_index = adj_index;
                            }
                        }
                        for (let i in result.receipts) {
                            const receipt = result.receipts[i];
                            if (receipt.actions.length != 1) {
                                throw new Error("reciept actions must have length 1");
                            }
                            const action = receipt.actions[0];
                            const fca = action["FunctionCall"];
                            let new_input_data = [];
                            for (let ind of receipt["receipt_indices"]) {
                                let data_id = num_data++;
                                new_input_data.push(data_id);
                                let adj_index = ind + numReceipts;
                                if (all_output_data[adj_index] == undefined) {
                                    all_output_data[adj_index] = [];
                                }
                                all_output_data[adj_index].push({
                                    account_id: receipt["receiver_id"],
                                    data_id,
                                });
                                // }
                            }
                            if (fca) {
                                let next = {
                                    index: parseInt(i) + numReceipts,
                                    account_id: receipt["receiver_id"],
                                    method_name: fca["method_name"],
                                    input: fca["args"],
                                    signer_account_id: accountContext.signer_account_id,
                                    predecessor_account_id: c["account_id"],
                                    input_data: new_input_data,
                                    prepaid_gas: fca["gas"],
                                    attached_deposit: fca["deposit"],
                                };
                                q.push(next);
                            }
                        }
                        this.log(ret);
                        numReceipts += result["receipts"].length;
                    }
                }
            }
            this.log(`Queue:  ${q.map((x) => `${x.predecessor_account_id} -> ${x.account_id}`)}`);
        }
        const result = results[return_index];
        this.log(`Final result:`);
        this.log(result);
        let return_data = (result.outcome && result.outcome.return_data) || undefined;
        if (return_data != undefined) {
            return_data =
                typeof return_data != "string" && return_data.Value
                    ? JSON.parse(return_data.Value)
                    : null;
        }
        return {
            return_data,
            err: result["err"],
            result,
            calls,
            results,
        };
    }
    reset() {
        this.accounts.forEach((account) => account.reset());
    }
    spawn(args) {
        let execResult = child_process_1.spawnSync("node", args);
        if (execResult.status != 0) {
            throw new Error("Failed to run successfully: " + execResult.output[2].toString());
        }
        var output = execResult.output[1];
        var result;
        try {
            result = JSON.parse(output);
        }
        catch (e) {
            console.error("Failed to parse: " + output);
            throw e;
        }
        return result;
    }
}
exports.Runtime = Runtime;
//# sourceMappingURL=runtime.js.map
'''
'''--- simulator/dist/types.js ---
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DEFAULT_GAS = void 0;
exports.DEFAULT_GAS = 10 ** 15;
//# sourceMappingURL=types.js.map
'''
'''--- simulator/dist/utils.js ---
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.stateSize = exports.encodeState = exports.decodeState = exports.assign = exports.decodeBs64 = exports.encodeBs64 = exports.decodeBs58 = exports.encodeBs58 = exports.createU128Str = exports.StrtoUTF8 = exports.UTF8toStr = exports.toNum = void 0;
const bn_js_1 = __importDefault(require("bn.js"));
const base58 = __importStar(require("bs58"));
const js_base64_1 = require("js-base64");
function toNum(x) {
    return parseInt(x.toString());
}
exports.toNum = toNum;
// http://www.onicos.com/staff/iz/amuse/javascript/expert/utf.txt
/* utf.js - UTF-8 <=> UTF-16 convertion
 *
 * Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>
 * Version: 1.0
 * LastModified: Dec 25 1999
 * This library is free.  You can redistribute it and/or modify it.
 */
function UTF8toStr(array) {
    var out, i, len, c;
    var char2, char3;
    out = "";
    len = array.length;
    i = 0;
    while (i < len) {
        c = array[i++];
        switch (c >> 4) {
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
                // 0xxxxxxx
                out += String.fromCharCode(c);
                break;
            case 12:
            case 13:
                // 110x xxxx   10xx xxxx
                char2 = array[i++];
                out += String.fromCharCode(((c & 0x1f) << 6) | (char2 & 0x3f));
                break;
            case 14:
                // 1110 xxxx  10xx xxxx  10xx xxxx
                char2 = array[i++];
                char3 = array[i++];
                out += String.fromCharCode(((c & 0x0f) << 12) | ((char2 & 0x3f) << 6) | ((char3 & 0x3f) << 0));
                break;
        }
    }
    return out;
}
exports.UTF8toStr = UTF8toStr;
function StrtoUTF8(str) {
    var utf8 = [];
    for (var i = 0; i < str.length; i++) {
        var charcode = str.charCodeAt(i);
        if (charcode < 0x80)
            utf8.push(charcode);
        else if (charcode < 0x800) {
            utf8.push(0xc0 | (charcode >> 6), 0x80 | (charcode & 0x3f));
        }
        else if (charcode < 0xd800 || charcode >= 0xe000) {
            utf8.push(0xe0 | (charcode >> 12), 0x80 | ((charcode >> 6) & 0x3f), 0x80 | (charcode & 0x3f));
        }
        // surrogate pair
        else {
            i++;
            // UTF-16 encodes 0x10000-0x10FFFF by
            // subtracting 0x10000 and splitting the
            // 20 bits of 0x0-0xFFFFF into two halves
            charcode =
                0x10000 + (((charcode & 0x3ff) << 10) | (str.charCodeAt(i) & 0x3ff));
            utf8.push(0xf0 | (charcode >> 18), 0x80 | ((charcode >> 12) & 0x3f), 0x80 | ((charcode >> 6) & 0x3f), 0x80 | (charcode & 0x3f));
        }
    }
    return new Uint8Array(utf8);
}
exports.StrtoUTF8 = StrtoUTF8;
function createU128Str(lo, hi) {
    const num = new bn_js_1.default(hi.toString());
    return num.shln(64).add(new bn_js_1.default(lo.toString())).toString();
}
exports.createU128Str = createU128Str;
function encodeBs58(str) {
    return base58.encode(StrtoUTF8(str));
}
exports.encodeBs58 = encodeBs58;
function decodeBs58(str) {
    return UTF8toStr(new Uint8Array(base58.decode(str)));
}
exports.decodeBs58 = decodeBs58;
function encodeBs64(str) {
    return js_base64_1.Base64.encode(str);
}
exports.encodeBs64 = encodeBs64;
function decodeBs64(str) {
    return js_base64_1.Base64.decode(str);
}
exports.decodeBs64 = decodeBs64;
function assign(...args) {
    return Object.assign.apply(Object, [{}, ...args]);
}
exports.assign = assign;
function decodeState(state) {
    return Object.getOwnPropertyNames(state).reduce((acc, cur) => {
        let key = decodeBs64(cur);
        try {
            acc[key] = JSON.parse(decodeBs64(state[cur]));
        }
        catch {
            acc[key] = decodeBs64(state[cur]);
        }
        return acc;
    }, {});
}
exports.decodeState = decodeState;
function encodeState(state) {
    return Object.getOwnPropertyNames(state).reduce((acc, cur) => {
        let key = encodeBs64(cur);
        acc[key] = encodeBs64(JSON.stringify(state[cur]));
        return acc;
    }, {});
}
exports.encodeState = encodeState;
function stateSize(state) {
    return Object.getOwnPropertyNames(state).reduce((acc, cur) => {
        acc += StrtoUTF8(cur).length + StrtoUTF8(state[cur]).length;
        return acc;
    }, 0);
}
exports.stateSize = stateSize;
//# sourceMappingURL=utils.js.map
'''
'''--- simulator/jest.config.js ---
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  testMatch: ["**/__tests__/**/*.spec.ts"],
  testPathIgnorePatterns: ["/assembly/", "/node_modules/"],
};

'''