*GitHub Repository "orkun51/LesNotes"*

'''--- README.md ---
# `Les Notes` 

This is a project for students. This project includes two different parts. First part; in Universites or Schools students have study notes and sometimes,they don't want to share their notes for free. In this project, students can buy a lesson notes. So, they can build their lesson notes and sell them.(Maybe they can create NFT from their lesson notes. The project can develop on this idea). Second part is like chairity system but it is for students and lessons. Students can create a Lesson Classes and Supeducators(Supporter of education) can donate this classes.In the future; students can work together in this classes and they can write lesson notes for others. Students create a NFT from lesson notes in this classes. And supeducators can help students. 
This project I prepared as part of the NEAR Developer Course program offered by Patika.dev & NEAR Protocol. 

My project was selected as one of the 100 best projects of all time by Near University.
---

### Getting started

INSTALL `NEAR CLI` first like this: `npm i -g near-cli`

1. git clone this repo  https://github.com/orkun51/LesNotes
2. yarn
3. near login, and login to your testnet account.
4. yarn build:release
6. near dev-deploy ./build/release/simple.wasm
7. export CONTRACT =<dev-....>

Also;

1.sh ./scripts/1.dev-deploy.sh

2.sh ./scripts/2.use-contract.sh

3.sh ./scripts/3.cleanup.sh

  For create a Note 
```
near call $CONTRACT createNote '{"name": "Note Name", "Lesson": "Genres", "price" : 5}' --accountId orkun.testnet
```
  For buy a Note
```
near call $CONTRACT BuyNote {"id": "Note id"}' --accountId orkun.testnet --deposit 5
```
  For create a Lesson Class
```
near call $CONTRACT openClass '{ "description":"desc", "maxAmount":5}' --accountId orkun.testnet
```
  For close a Lesson Class
```
near call $CONTRACT closeClass '{"id":"Class id"}' --accountId orkun.testnet
```
  For latest schoolarship
```
near view $CONTRACT latestSchoolarship '{"start": 0, "limit": 10}'
```

## Samples

This repository includes a improving project structure for AssemblyScript contracts targeting the NEAR platform.

There is 1 AssemblyScript contracts in this project:

- **simple** in the `src/simple` folder

### Simple

We say that an AssemblyScript contract is written in the "simple style" when the `index.ts` file (the contract entry point) includes a series of exported functions.

-**index.ts** in this folder. You can see the function and you can improve this folder.
-**model.ts** in this folder. You can see the behind the functions in the "index.ts".Also you can improve this folder

In this case, all exported functions become public contract methods.

## Les Notes

# Assembly Directory
In this folder, there are smart contract codes developed by the project using assemblyscript and the near-sdk package provided by Near protocol.

# Model.ts
In this folder, we can see model classes of the 'Les Notes' such as Notes,Lesson Classes and Supeducators.
```
import {
  PersistentUnorderedMap,math,Context,
  u128,ContractPromiseBatch} from "near-sdk-as"
import { getNotes } from ".";

import { AccountId,Money,} from "../../utils"

export const notes=new PersistentUnorderedMap<u32, Notes>("notes"); 
export const noteOwners=new PersistentUnorderedMap<u32, Array <AccountId>>("access");
export const lessonclasses=new PersistentUnorderedMap<u32, LessonClasses>("lessonclasses");
export const supeducators=new PersistentUnorderedMap<u32, Supeducator>("supeducators"); 
```

**Notes Class**
```
//This class for Notes
@nearBindgen
export class Notes 
{
  id: u32
  owner: AccountId=Context.sender
  name:string
  lesson:string
  genres:string
  price: Money
  //comments:PersistentVector<Comment>=new PersistentVector<Comment>("comments")

  constructor(owner: AccountId,name: string,lesson:string,genres:string,price:Money) {
    this.id=math.hash32<string>(name);
    this.owner=owner;  
    this.name=name;
    this.lesson=lesson;
    this.genres=genres;
    this.price=price;
  }

 
  static createNote(owner:AccountId,name:string,lesson:string,genres:string,price:Money): Notes {
    this.assert_note(name);
    const notes=new Notes(owner,name,lesson,genres,price);
    //notes.set(notes.id,notes)
    noteOwners.set(notes.id, new Array <string>());
    return notes;

  }

  static BuyNote(id: u32): void {
    this.assert_price(id)
    let list:Array<AccountId>
    if (noteOwners.contains(id)) 
    {
      list=noteOwners.getSome(id);
      list.push(Context.sender);
      noteOwners.set(id,list);
    }else
    {
      let list=new Array <AccountId>();
      list.push(Context.sender);
      noteOwners.set(id,list);
    }

  }

  static assert_note(name:string): void {
    assert(!notes.contains(math.hash32<string>(name)),"You cannot take this name. Please take another one")
  }
  static assert_price(id:u32):void {
    let notes=this.findNotebyId(id);
    assert(notes.price<=Context.attachedDeposit,"Money is not enough")
  }
  static findNotebyId(id:u32):Notes{
    return notes.getSome(id);
  }
  static findNote(offset:u32,limit:u32=10):Notes[]{
    return notes.values(offset,limit + offset);
  }

}
```
**LessonClasses Class**
```
//This is the class for schoolership. 
@nearBindgen
export class LessonClasses{
  id:u32;//Id of Class
  owner:string=Context.sender;
  description:string;
  amount:u128;
  maxAmount:u128;
  latestSchoolarship:Supeducator;
  complete:bool;

  constructor(owner:string,description:string,maxAmount:u128){
    this.id=math.hash32<string>(owner);
    this.owner=owner;
    this.description=description;
    this.maxAmount= maxAmount;
    this.amount=new u128(0);
    this.complete=true;
 }
 
 static openClass(owner:string,description:string,maxAmount:u128):LessonClasses{
   this.assert_owner_class(math.hash32<string>(owner));
   const lessonClasses=new LessonClasses(owner,description,maxAmount);
   
   lessonclasses.set(lessonClasses.id,lessonClasses);

   return lessonClasses;
 }

 static addAmount(id:u32,message:string,amount:u128):LessonClasses{
   const lessonClasses=this.findLessonclassesbyId(id);
   lessonClasses.amount=u128.add(lessonClasses.amount,amount);
   const supeducators=new Supeducator(id,message,amount);
   lessonClasses.latestSchoolarship=supeducators;

   lessonclasses.set(id,lessonClasses);
   //supeducators.set (supeducators.lenght +1, supeducators);

   return lessonClasses;
 }
 
 static closeClass(lessonClasses:LessonClasses,caller:string): LessonClasses{
   this.assert_owner(lessonClasses,caller);

   const owner_call=ContractPromiseBatch.create(caller);
   owner_call.transfer(lessonClasses.amount);

   lessonClasses.amount =new u128(0);
   lessonClasses.complete=false;

   lessonclasses.set(lessonClasses.id,lessonClasses);

   return lessonClasses;
 }
 
  
 static findLessonclassesbyId(id:u32):LessonClasses{
   return lessonclasses.getSome(id);
 }

 static findLessonclasses(offset:u32,limit:u32=10):LessonClasses[] {
   return lessonclasses.values(offset,limit+offset);
 }
 
 static assert_owner_class(id:u32):void{
   const lessonclass=this.findLessonclassesbyId(id);
   if(lessonclass.complete !=false) 
    {
     assert(!lessonclasses.contains(id),"Owner has another class");
    }
 }
 
 static assert_owner(lessonClasses:LessonClasses, caller:string): void {
   assert(lessonClasses.owner==caller,"Only leader of class can call this function");
 }

}
```
**Supeducators Class**
```
@nearBindgen
export class Supeducator
{
  message:string;
  sup:u128;
  ClassId:u32;

  constructor(ClassId:u32,message:string,sup:u128){
    this.ClassId=ClassId;
    this.message=message;
    this.sup=sup;
  }
  static showLatestSups(offset:u32,limit:u32=20): Supeducator[]{
    return supeducators.values(offset,limit+offset)
  }

}
```
# Index.ts

This folder includes functions.

```
import { storage, Context, u128 } from "near-sdk-as"

import { LessonClasses, Notes, Supeducator } from "./model"

//This function ensure the creating lesson notes
export function createNote(name:string,lesson:string,genres:string,price:u128): Notes {
  return Notes.createNote(Context.sender,name,lesson,genres,price);
}

//This function ensure the buying lesson notes
export function BuyNote(id:u32):void {
  Notes.BuyNote(id);
}

export function getNotes(id:u32): Notes[] {
  return Notes.findNote(id);
}
//get LessonClasses by Id
export function getLessonClassesbyId(id:u32): LessonClasses{
  return LessonClasses.findLessonclassesbyId(id);
}
//This function ensure the opening class
export function openClass (description:string,maxAmount:u128):LessonClasses{
  return LessonClasses.openClass(Context.sender,description,maxAmount);
}

//This function ensures that Supeducators can give schoolarship to classes
export function SupportLessonClasses(id:u32,message:string): LessonClasses{
  return LessonClasses.addAmount(id,message,Context.attachedDeposit);
}
//This function ensures that close the Lesson Classes
export function closeClass(id:u32): LessonClasses{
  return LessonClasses.closeClass(getLessonClassesbyId(id),Context.sender);
}

//Looking for last donations
export function latestSchoolarship(start:u32,limit:u32): Supeducator[] {
  return Supeducator.showLatestSups(start,limit);
}
```

'''
'''--- as-pect.config.js ---
module.exports = require("near-sdk-as/imports");
module.exports.include.push("**/*.unit.spec.ts");

'''
'''--- asconfig.json ---
{
  "workspaces": [
    "src/simple",
    "src/singleton"
  ]
}

'''
'''--- package.json ---
{
  "name": "lesnotes",
  "version": "0.0.1",
  "description": "",
  "scripts": {
    "dev": "watch -d -n 1 'clear && yarn test'",
    "test": "yarn asp -f unit.spec",
    "clean": "rm -rf ./build && rm -rf ./neardev",
    "build": "asb --target debug",
    "build:release": "asb",
    "asp": "asp --verbose --nologo",
    "start": "node your-script.js",
    "preinstall" : "./configure",
    "install" : "make && make install",
    "dev:deploy:contract": "near dev-deploy",
    "deploy:contract": "near deploy"    
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "near-sdk-as": "^3.1.0"
  }
}

'''
'''--- scripts/1.dev-deploy.sh ---
#!/usr/bin/env bash

# exit on first error after this point to avoid redeploying with successful build
[ -z "$CONTRACT" ] && echo "Missing \$CONTRACT environment variable"
[ -z "$OWNER" ] && echo "Missing \$OWNER environment variable"

echo "deleting $CONTRACT and setting $OWNER as beneficiary"
near delete $CONTRACT $OWNER

set -e

echo
echo ---------------------------------------------------------
echo "Step 1: Build the contract (may take a few seconds)"
echo ---------------------------------------------------------
echo
yarn 

echo
echo
echo ---------------------------------------------------------
echo "Step 2: Deploy the contract"
near login
echo
echo "(edit scripts/1.dev-deploy.sh to deploy other contract)"
echo ---------------------------------------------------------
echo
yarn build:release
# uncomment out the line below to deploy the other example contract
# near dev-deploy ./build/debug/simple.wasm

# comment the line below to deploy the other example contract
near dev-deploy ./build/debug/simple.wasm

echo
echo
echo ---------------------------------------------------------
echo 
echo
echo 
echo "redeploying the contract"
echo
echo 
near dev-deploy ./build/release/simple.wasm
echo
echo ---------------------------------------------------------
echo 'export CONTRACT=<dev-123-456>'
echo 'export OWNER=<your account'
echo 'near call \$CONTRACT init '{\"owner\":\"'\$OWNER'\"}' --accountId \$CONTRACT'
# uncomment this line for a useful hint when using the simple style
# echo "near call \$CONTRACT init --accountId \$CONTRACT"
echo ---------------------------------------------------------
echo

exit 0

'''
'''--- scripts/2.use-contract.sh ---
#!/usr/bin/env bash

# exit on first error after this point to avoid redeploying with successful build

echo "export CONTRACT=dev<123 321>"

set -e

echo
echo ---------------------------------------------------------
echo "Step 0: Check for environment variable with contract name"
echo ---------------------------------------------------------
echo

[ -z "$CONTRACT" ] && echo "Missing \$CONTRACT environment variable" && exit 1
[ -z "$CONTRACT" ] || echo "Found it! \$CONTRACT is set to [ $CONTRACT ]"

echo
echo
echo ---------------------------------------------------------
echo "Step 1: Call 'view' functions on the contract"
echo
echo 
echo ---------------------------------------------------------
echo

near view $CONTRACT latestSchoolarship '{"start": 0, "limit": 10}'

echo
echo
echo
echo "now run this script again to see changes made by this file"
exit 0

'''
'''--- scripts/3.cleanup.sh ---
#!/usr/bin/env bash

# exit on first error after this point to avoid redeploying with successful build
set -e

echo
echo ---------------------------------------------------------
echo "Step 0: Check for required environment variables"
echo ---------------------------------------------------------
echo

[ -z "$CONTRACT" ] && echo "Missing \$CONTRACT environment variable" && exit 1
[ -z "$BENEFICIARY" ] && echo "Missing \$BENEFICIARY environment variable" && exit 1
[ -z "$CONTRACT" ] || echo "Found it! \$CONTRACT is set to [ $CONTRACT ]"
[ -z "$BENEFICIARY" ] || echo "Found it! \$BENEFICIARY is set to [ $BENEFICIARY ]"

echo
echo
echo ---------------------------------------------------------
echo "Step 1: Delete $CONTRACT, setting $BENEFICIARY as beneficiary"
echo ---------------------------------------------------------
echo
near delete $CONTRACT $BENEFICIARY

echo
echo ---------------------------------------------------------
echo "Step 2: Clean up project folders"
echo ---------------------------------------------------------
echo
yarn clean

exit 0

'''
'''--- scripts/README.md ---
## Setting up your terminal

The scripts in this folder are designed to help you demonstrate the behavior of the contract(s) in this project.

It uses the following setup:

```sh
# set your terminal up to have 2 windows, A and B like this:
┌─────────────────────────────────┬─────────────────────────────────┐
│                                 │                                 │
│                                 │                                 │
│                A                │                B                │
│                                 │                                 │
│                                 │                                 │
└─────────────────────────────────┴─────────────────────────────────┘
```

### Terminal **A**

*This window is used to compile, deploy and control the contract*
- Environment
  ```sh
  export CONTRACT=        # depends on deployment
  export OWNER=           # any account you control

  # for example
  # export CONTRACT=dev-1615190770786-2702449
  # export OWNER=sherif.testnet
  ```

- Commands

  _helper scripts_
  ```sh
  1.dev-deploy.sh                # helper: build and deploy contracts
  2.use-contract.sh              # helper: call methods on ContractPromise
  3.cleanup.sh                   # helper: delete build and deploy artifacts
  ```

### Terminal **B**

*This window is used to render the contract account storage*
- Environment
  ```sh
  export CONTRACT=               # depends on deployment

  # for example
  # export CONTRACT=dev-1615190770786-2702449
  ```

- Commands
  ```sh
  # monitor contract storage using near-account-utils
  # https://github.com/near-examples/near-account-utils
  watch -d -n 1 yarn storage $CONTRACT
  ```
---

## OS Support

### Linux

- The `watch` command is supported natively on Linux
- To learn more about any of these shell commands take a look at [explainshell.com](https://explainshell.com)

### MacOS

- Consider `brew info visionmedia-watch` (or `brew install watch`)

### Windows

- Consider this article: [What is the Windows analog of the Linux watch command?](https://superuser.com/questions/191063/what-is-the-windows-analog-of-the-linuo-watch-command#191068)

'''
'''--- src/as_types.d.ts ---
/// <reference types="near-sdk-as/assembly/as_types" />
'''
'''--- src/simple/__tests__/as-pect.d.ts ---
/// <reference types="@as-pect/assembly/types/as-pect" />
'''
'''--- src/simple/__tests__/index.unit.spec.ts ---
import * as contract from "../assembly";

describe("Contract", () => {
  // VIEW method tests

  it("says hello", () => {
    expect(contract.helloWorld()).toStrictEqual("hello world")
  })

  it("reads data", () => {
    expect(contract.read("some key")).toStrictEqual("🚫 Key [ some key ] not found in storage. ( storage [ 0 bytes ] )")
  })

  // CHANGE method tests

  it("saves data to contract storage", () => {
    expect(contract.write("some-key", "some value")).toStrictEqual("✅ Data saved. ( storage [ 18 bytes ] )")
  })
})

'''
'''--- src/simple/asconfig.json ---
{
  "extends": "near-sdk-as/asconfig.json"
}

'''
'''--- src/simple/assembly/index.ts ---
import { storage, Context, u128 } from "near-sdk-as"

//import { toYocto } from "../../utils"
import { LessonClasses, Notes, Supeducator } from "./model"

//This function ensure the creating lesson notes
export function createNote(name:string,lesson:string,genres:string,price:u128): Notes {
  return Notes.createNote(Context.sender,name,lesson,genres,price);
}

//This function ensure the buying lesson notes
export function BuyNote(id:u32):void {
  Notes.BuyNote(id);
}

export function getNotes(id:u32): Notes[] {
  return Notes.findNote(id);
  
}
//get LessonClasses by Id
export function getLessonClassesbyId(id:u32): LessonClasses{
  return LessonClasses.findLessonclassesbyId(id);
}
//This function ensure the opening class
export function openClass (description:string,maxAmount:u128):LessonClasses{
  return LessonClasses.openClass(Context.sender,description,maxAmount);
}

//This function ensures that Supeducators can give schoolarship to classes
export function SupportLessonClasses(id:u32,message:string): LessonClasses{
  return LessonClasses.addAmount(id,message,Context.attachedDeposit);
}
//This function ensures that close the Lesson Classes
export function closeClass(id:u32): LessonClasses{
  return LessonClasses.closeClass(getLessonClassesbyId(id),Context.sender);
}

//Looking for last donations
export function latestSchoolarship(start:u32,limit:u32): Supeducator[] {
  return Supeducator.showLatestSups(start,limit);
}
'''
'''--- src/simple/assembly/model.ts ---
//assembly/model.ts
import {
  PersistentUnorderedMap,math,Context,
  u128,ContractPromiseBatch} from "near-sdk-as"
import { getNotes } from ".";

import { AccountId,Money,} from "../../utils"

export const notes=new PersistentUnorderedMap<u32, Notes>("notes"); 
export const noteOwners=new PersistentUnorderedMap<u32, Array <AccountId>>("access");
export const lessonclasses=new PersistentUnorderedMap<u32, LessonClasses>("lessonclasses");
export const supeducators=new PersistentUnorderedMap<u32, Supeducator>("supeducators");

//This class for Notes
@nearBindgen
export class Notes 
{
  id: u32
  owner: AccountId=Context.sender
  name:string
  lesson:string
  genres:string
  price: Money
  //comments:PersistentVector<Comment>=new PersistentVector<Comment>("comments")

  constructor(owner: AccountId,name: string,lesson:string,genres:string,price:Money) {
    this.id=math.hash32<string>(name);
    this.owner=owner;  
    this.name=name;
    this.lesson=lesson;
    this.genres=genres;
    this.price=price;
  }

 
  static createNote(owner:AccountId,name:string,lesson:string,genres:string,price:Money): Notes {
    this.assert_note(name);
    const notes=new Notes(owner,name,lesson,genres,price);
    //notes.set(notes.id,notes)
    noteOwners.set(notes.id, new Array <string>());
    return notes;

  }

  static BuyNote(id: u32): void {
    this.assert_price(id)
    let list:Array<AccountId>
    if (noteOwners.contains(id)) 
    {
      list=noteOwners.getSome(id);
      list.push(Context.sender);
      noteOwners.set(id,list);
    }else
    {
      let list=new Array <AccountId>();
      list.push(Context.sender);
      noteOwners.set(id,list);
    }

  }

  static assert_note(name:string): void {
    assert(!notes.contains(math.hash32<string>(name)),"You cannot take this name. Please take another one")
  }
  static assert_price(id:u32):void {
    let notes=this.findNotebyId(id);
    assert(notes.price<=Context.attachedDeposit,"Money is not enough")
  }
  static findNotebyId(id:u32):Notes{
    return notes.getSome(id);
  }
  static findNote(offset:u32,limit:u32=10):Notes[]{
    return notes.values(offset,limit + offset);
  }

}
//This is the class for schoolership. 
@nearBindgen
export class LessonClasses{
  id:u32;//Id of Class
  owner:string=Context.sender;
  description:string;
  amount:u128;
  maxAmount:u128;
  latestSchoolarship:Supeducator;
  complete:bool;

  constructor(owner:string,description:string,maxAmount:u128){
    this.id=math.hash32<string>(owner);
    this.owner=owner;
    this.description=description;
    this.maxAmount= maxAmount;
    this.amount=new u128(0);
    this.complete=true;
 }
 
 static openClass(owner:string,description:string,maxAmount:u128):LessonClasses{
   this.assert_owner_class(math.hash32<string>(owner));
   const lessonClasses=new LessonClasses(owner,description,maxAmount);
   
   lessonclasses.set(lessonClasses.id,lessonClasses);

   return lessonClasses;
 }

 static addAmount(id:u32,message:string,amount:u128):LessonClasses{
   const lessonClasses=this.findLessonclassesbyId(id);
   lessonClasses.amount=u128.add(lessonClasses.amount,amount);
   const supeducators=new Supeducator(id,message,amount);
   lessonClasses.latestSchoolarship=supeducators;

   lessonclasses.set(id,lessonClasses);
   //supeducators.set (supeducators.lenght +1, supeducators);

   return lessonClasses;
 }
 
 static closeClass(lessonClasses:LessonClasses,caller:string): LessonClasses{
   this.assert_owner(lessonClasses,caller);

   const owner_call=ContractPromiseBatch.create(caller);
   owner_call.transfer(lessonClasses.amount);

   lessonClasses.amount =new u128(0);
   lessonClasses.complete=false;

   lessonclasses.set(lessonClasses.id,lessonClasses);

   return lessonClasses;
 }
 
  
 static findLessonclassesbyId(id:u32):LessonClasses{
   return lessonclasses.getSome(id);
 }

 static findLessonclasses(offset:u32,limit:u32=10):LessonClasses[] {
   return lessonclasses.values(offset,limit+offset);
 }
 
 static assert_owner_class(id:u32):void{
   const lessonclass=this.findLessonclassesbyId(id);
   if(lessonclass.complete !=false) 
    {
     assert(!lessonclasses.contains(id),"Owner has another class");
    }
 }
 
 static assert_owner(lessonClasses:LessonClasses, caller:string): void {
   assert(lessonClasses.owner==caller,"Only leader of class can call this function");
 }

}

@nearBindgen
export class Supeducator
{
  message:string;
  sup:u128;
  ClassId:u32;

  constructor(ClassId:u32,message:string,sup:u128){
    this.ClassId=ClassId;
    this.message=message;
    this.sup=sup;
  }
  static showLatestSups(offset:u32,limit:u32=20): Supeducator[]{
    return supeducators.values(offset,limit+offset)
  }

}

'''
'''--- src/tsconfig.json ---
{
  "extends": "../node_modules/assemblyscript/std/assembly.json",
  "include": ["./**/*.ts"]
}

'''
'''--- src/utils.ts ---
import { u128, Context, ContractPromise } from "near-sdk-as";

/**
 * == TYPES ====================================================================
 */

/**
 * Account IDs in NEAR are just strings.
 */
export type AccountId = string;

/**
 * Gas is u64
 */
export type Gas = u64;

/**
 * Amounts, Balances, and Money in NEAR is are u128.
 */

export type Amount = u128;

export type Balance = Amount;

export type Money = Amount;

/**
 * Timestamp in NEAR is a number.
 */
export type Timestamp = u64;

/**
 * == CONSTANTS ================================================================
 *
 * ONE_NEAR = unit of NEAR token in yocto Ⓝ (1e24)
 * XCC_GAS = gas for cross-contract calls, ~5 Tgas (teragas = 1e12) per "hop"
 * MIN_ACCOUNT_BALANCE = 3 NEAR min to keep account alive via storage staking
 *
 * TODO: revist MIN_ACCOUNT_BALANCE after some real data is included b/c this
 *  could end up being much higher
 */

export const ONE_NEAR = u128.from("1000000000000000000000000");
export const XCC_GAS: Gas = 20_000_000_000_000;
export const MIN_ACCOUNT_BALANCE: u128 = u128.mul(ONE_NEAR, u128.from(3));

/**
 * == FUNCTIONS ================================================================
 */

/**
 * @function asNEAR
 * @param amount {u128} - Yocto Ⓝ token quantity as an unsigned 128-bit integer
 * @returns {string}    - Amount in NEAR, as a string
 *
 * @example
 *
 *    asNEAR(7000000000000000000000000)
 *    // => '7'
 */
export function asNEAR(amount: u128): string {
  return u128.div(amount, ONE_NEAR).toString();
}

/**
 * @function toYocto
 * @param amount {number} - Integer to convert
 * @returns {u128}        - Amount in yocto Ⓝ as an unsigned 128-bit integer
 *
 * @example
 *
 *    toYocto(7)
 *    // => 7000000000000000000000000
 */
export function toYocto(amount: number): u128 {
  return u128.mul(ONE_NEAR, u128.from(amount))
}

/**
 * Function to assert that the contract has called itself
 */
export function assert_self(): void {
  const caller = Context.predecessor
  const self = Context.contractName
  assert(caller == self, "Only this contract may call itself");
}

export function assert_single_promise_success(): void {
  const x = ContractPromise.getResults()
  assert(x.length == 1, "Expected exactly one promise result")
  assert(x[0].succeeded, "Expected PromiseStatus to be successful")
}

'''