*GitHub Repository "kherld-hussein/near_ticket"*

'''--- .github/workflows/codeql-analysis.yml ---
# For most projects, this workflow file will not need changing; you simply need
# to commit it to your repository.
#
# You may wish to alter this file to override the set of languages analyzed,
# or to provide custom queries or build logic.
#
# ******** NOTE ********
# We have attempted to detect the languages in your repository. Please check
# the `language` matrix defined below to confirm you have the correct set of
# supported CodeQL languages.
#
name: "CodeQL"

on:
  push:
    branches: [ "main" ]
  pull_request:
    # The branches below must be a subset of the branches above
    branches: [ "main" ]
  schedule:
    - cron: '27 16 * * 1'

jobs:
  analyze:
    name: Analyze
    runs-on: ubuntu-latest
    permissions:
      actions: read
      contents: read
      security-events: write

    strategy:
      fail-fast: false
      matrix:
        language: [ 'javascript' ]
        # CodeQL supports [ 'cpp', 'csharp', 'go', 'java', 'javascript', 'python', 'ruby' ]
        # Learn more about CodeQL language support at https://aka.ms/codeql-docs/language-support

    steps:
    - name: Checkout repository
      uses: actions/checkout@v3

    # Initializes the CodeQL tools for scanning.
    - name: Initialize CodeQL
      uses: github/codeql-action/init@v2
      with:
        languages: ${{ matrix.language }}
        # If you wish to specify custom queries, you can do so here or in a config file.
        # By default, queries listed here will override any specified in a config file.
        # Prefix the list here with "+" to use these queries and those in the config file.
        
        # Details on CodeQL's query packs refer to : https://docs.github.com/en/code-security/code-scanning/automatically-scanning-your-code-for-vulnerabilities-and-errors/configuring-code-scanning#using-queries-in-ql-packs
        # queries: security-extended,security-and-quality

        
    # Autobuild attempts to build any compiled languages  (C/C++, C#, or Java).
    # If this step fails, then you should remove it and run the build manually (see below)
    - name: Autobuild
      uses: github/codeql-action/autobuild@v2

    # ‚ÑπÔ∏è Command-line programs to run using the OS shell.
    # üìö See https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idstepsrun

    #   If the Autobuild fails above, remove it and uncomment the following three lines. 
    #   modify them (or add more) to build your code if your project, please refer to the EXAMPLE below for guidance.

    # - run: |
    #   echo "Run, Build Application using script"
    #   ./location_of_script_within_repo/buildscript.sh

    - name: Perform CodeQL Analysis
      uses: github/codeql-action/analyze@v2
      with:
        category: "/language:${{matrix.language}}"

'''
'''--- Cargo.toml ---
[package]
name = "near-ticket"
version = "0.1.0"
edition = "2021"
authors = ["Khalid Hussein <kherld11@gmail.com>"]

[dependencies]
near-sdk = "4.0.0-pre.7"
near-contract-standards = "4.0.0-pre.7"

[lib]
crate-type = ["cdylib"]

[profile.release]
codegen-units = 1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- README.md ---
# NEAR Smart Event RSVP Contract

RSVP just got easy...

Create or get ticket to any event 

Project structure for writing smart contracts in Rust for NEAR Protocol

# Required Software

- Rust 1.58 + cargo
- Node.js
- NEAR CLI 3.1

# Author

- Khalid Hussein <kherld11@gmail.com> [@kherldhussein](https://twitter.com/kherldhussein)

'''
'''--- SECURITY.md ---
# Security Policy

## Supported Versions

Use this section to tell people about which versions of your project are
currently being supported with security updates.

| Version | Supported          |
| ------- | ------------------ |
| 5.1.x   | :white_check_mark: |
| 5.0.x   | :x:                |
| 4.0.x   | :white_check_mark: |
| < 4.0   | :x:                |

## Reporting a Vulnerability

Use this section to tell people how to report a vulnerability.

Tell them where to go, how often they can expect to get an update on a
reported vulnerability, what to expect if the vulnerability is accepted or
declined, etc.

'''
'''--- build.sh ---
#!/usr/bin/env bash

cargo build --target wasm32-unknown-unknown --release

'''
'''--- deploy.sh ---
#!/usr/bin/env bash

WASM_PATH="$(find ./target/wasm32-unknown-unknown/release/ -maxdepth 1 -name "*.wasm")"

near deploy \
  --wasmFile $WASM_PATH \
  --accountId "$1" \
  --initFunction new \
  --initArgs "$(node ./init-args.js)"

'''
'''--- dev-deploy.sh ---
#!/usr/bin/env bash

WASM_PATH="$(find ./target/wasm32-unknown-unknown/release/ -maxdepth 1 -name "*.wasm")"

near dev-deploy \
  --wasmFile $WASM_PATH \
  "$@"

near call "$(<./neardev/dev-account)" new "$(node ./init-args.js)" \
  --accountId "$(<./neardev/dev-account)"

'''
'''--- init-args.js ---
const ONE_DAY = 1_000_000_000 * 60 * 60 * 24;

// 1e24, calculated like this because JS numbers don't work that large
const ONE_NEAR = BigInt(1e12) ** 2n;

console.log(JSON.stringify({}));

'''
'''--- rustfmt.toml ---
tab_spaces = 2

'''
'''--- src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::Serialize;
use near_sdk::{env, log, near_bindgen, Promise};
use std::collections::HashMap;

pub type AccountId = String;
pub type TicketId = String;
pub type EventId = String;
pub type OrderNumber = String;

// Event creator && Ticket booking app for the Events

#[derive(Clone, BorshDeserialize, BorshSerialize, Debug)]
pub struct User {
  pub user_id: String,
}

impl User {
  fn new(user_id: String) -> Self {
    User { user_id }
  }
}

#[near_bindgen]
#[derive(Clone, BorshDeserialize, BorshSerialize, Debug, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Event {
  description: String,
  price: i32,
  venue: String,
  status: Status,
  mounts_tickets: i32,
  event_organizer: AccountId,
  eid: u32,
}

#[near_bindgen]
impl Event {
  fn new(
    description: String,
    price: i32,
    venue: String,
    mounts_tickets: i32,
    status: Status,
    event_organizer: AccountId,
    eid: u32,
  ) -> Self {
    Event {
      description,
      price,
      venue,
      mounts_tickets,
      status,
      event_organizer,
      eid,
    }
  }
}

#[derive(BorshDeserialize, BorshSerialize, Debug, PartialEq, Clone)]
pub struct Ticket {
  ticket_id: TicketId,
  event_id: EventId,
  ticket_owner: String,
  ticket_description: String,
  // Standard(Option<i32>),
  // Vip(Option<i32>),
}
impl Ticket {
  fn new(
    ticket_id: TicketId,
    event_id: EventId,
    ticket_owner: String,
    ticket_description: String,
  ) -> Self {
    Ticket {
      ticket_id,
      event_id,
      ticket_owner,
      ticket_description,
    }
  }
}
#[derive(BorshDeserialize, BorshSerialize, Debug, PartialEq, Clone, Copy, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub enum Status {
  Available,
  Unavailable,
}

// impl Status {
//   fn get_status(&mut self) -> Self {

//     match self {
//       Status::Available => env::log_str("Ticket Available"),
//       Status::Unavailable => env::log_str("Ticket Not Available"),
//     }
//   }
// }

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, Debug, Default)]
pub struct Contract {
  uid: AccountId,
  ticket: HashMap<OrderNumber, Ticket>,
  users: HashMap<String, User>,
  event_creator: Vec<Event>,
}

#[near_bindgen]
impl Contract {
  #[init]
  pub fn new(uid: AccountId) -> Self {
    let users: HashMap<String, User> = HashMap::new();
    let ticket: HashMap<OrderNumber, Ticket> = HashMap::new();
    let event_creator: Vec<Event> = Vec::new();

    Contract {
      uid,
      ticket,
      users,
      event_creator,
    }
  }

  // Create Events
  pub fn new_event(&mut self, description: String, price: i32, venue: String, ticket_amount: i32) {
    let account_id = env::signer_account_id();
    let user = String::from(account_id);
    let organizer_id = env::current_account_id();
    let event_id = self.event_creator.len() as u32;
    let available_ticket = Some(ticket_amount);

    match user == self.uid {
      true => {
        if available_ticket.unwrap() > 0 {
          let status = Status::Available;
          self.event_creator.push(Event::new(
            description,
            price,
            venue,
            ticket_amount,
            status,
            organizer_id.to_string(),
            event_id,
          ));
        }
      }
      false => (),
    }
  }

  // View events
  pub fn view_events(&self) -> Vec<Event> {
    let events = &self.event_creator;
    events.to_vec()
  }

  // Get events ticket
  fn get_ticket(&mut self, event_id: EventId) {
    let account_id = env::signer_account_id();
    let user = String::from(account_id);

    let u_name: Vec<&str> = user.split('.').collect();
    let ticket_id = self.ticket.len() as u32;
    // activate user
    match self.uid == user {
      true => {
        // Check available event and get details

        let events = &mut self.event_creator;
        let ticket = &mut self.ticket;

        let available = Status::Available;

        if let Status::Available = available {
          events.iter().for_each(|event| {
            if event.eid.to_string() == event_id {
              let order_num = event.eid.to_string() + &event.mounts_tickets.to_string();
              const ONE_NEAR: u128 = u128::pow(10, 24);
              let acc_balance = env::account_balance();
              let organizer_id = env::current_account_id();
              if acc_balance > 1 {
                ticket.insert(
                  order_num,
                  Ticket::new(
                    ticket_id.to_string(),
                    event_id.to_owned(),
                    user.to_owned(),
                    event.description.to_owned(),
                  ),
                );

                Promise::new(organizer_id).transfer(ONE_NEAR);
                log!(
                  "{} You have successfully RSVP to {}\n Your ticket info has been sent to {}@near.io",
                  u_name[0],
                  event.description,
                  u_name[0],
                );
              } else {
                env::log_str("You do not have sufficient funds to make this purchase");
              }
            }
          });
          for ticket_info in ticket {
            log!("Your Order Number is {:?}", ticket_info.0);
          }
        }
      }
      false => {}
    }
  }

  pub fn count_events(&mut self) -> usize {
    self.event_creator.len()
  }

  pub fn count_tickets(&mut self) -> usize {
    self.ticket.len()
  }

  // View ticket
  pub fn check_ticket_info(&mut self, order_number: String) {
    let account_id = env::signer_account_id();
    let tickets = &self.ticket;
    let user = String::from(account_id);
    match self.uid == user {
      true => {
        for ticket_info in tickets {
          if ticket_info.0 == &order_number {
            log!("Your ticket info {:?}", ticket_info.1);
          }
        }
      }
      false => {}
    }
  }
}

#[cfg(test)]
mod tests {
  use super::*;
  use near_sdk::test_utils::VMContextBuilder;
  use near_sdk::testing_env;
  use near_sdk::AccountId;

  fn to_valid_account(account: &str) -> AccountId {
    AccountId::try_from(account.to_string()).expect("Invalid account")
  }

  const ONE_NEAR: u128 = u128::pow(10, 24);

  fn get_context(predecessor: AccountId) -> VMContextBuilder {
    let mut builder = VMContextBuilder::new();
    builder
      .account_balance(100 * ONE_NEAR)
      .signer_account_id(predecessor);
    builder
  }

  #[test]
  fn test_create_event() {
    let kherld = AccountId::new_unchecked("kherld.testnet".to_string());
    // set up the mock context into the testing environment

    let context = get_context(to_valid_account("kherld.testnet"));

    testing_env!(context.build());
    let mut contract = Contract::new(kherld.to_string());

    contract.new_event("NEARCON 2022".to_string(), 500, "Lisbon".to_string(), 230);
    contract.new_event("NEARCON 2023".to_string(), 800, "Nairobi".to_string(), 380);

    assert_eq!(contract.count_events(), 2, "Expected 2 Events");
  }

  #[test]
  fn test_create_events() {
    let kherld = AccountId::new_unchecked("kherld.testnet".to_string());
    // set up the mock context into the testing environment
    let context = get_context(to_valid_account("kherld.testnet"));

    testing_env!(context.build());
    let mut contract = Contract::new(kherld.to_string());
    contract.new_event(
      "NEARCON 2023".to_string(),
      800,
      "In-Person".to_string(),
      3000,
    );

    let events = contract.view_events();

    let status = Status::Available;
    assert_eq!(
      events[0].status, status,
      "For event to be available, amount of ticket must be > 0"
    );
  }

  #[test]
  fn test_get_ticket() {
    let kherld = AccountId::new_unchecked("kherld.testnet".to_string());
    // set up the mock context into the testing environment
    let context = get_context(to_valid_account("kherld.testnet"));

    testing_env!(context.build());
    let mut contract = Contract::new(kherld.to_string());
    contract.new_event("NEARCON 2023".to_string(), 800, "In-Person".to_string(), 1);
    contract.get_ticket(0.to_string());
    // let ticket = contract.check_ticket_info();
    let events = contract.view_events();
    let status = Status::Available;
    assert_eq!(
      events[0].status, status,
      "For event to be available, amount of ticket must be > 0"
    );
  }

  #[test]
  fn test_check_ticket_info() {
    let kherld = AccountId::new_unchecked("kherld.testnet".to_string());
    // set up the mock context into the testing environment
    let context = get_context(to_valid_account("kherld.testnet"));

    testing_env!(context.build());
    let mut contract = Contract::new(kherld.to_string());
    contract.new_event("NEARCON 2023".to_string(), 800, "In-Person".to_string(), 66);
    contract.get_ticket(0.to_string());
    let ticket = contract.check_ticket_info("066".to_string());
    assert_eq!((), ticket);
  }
}

'''