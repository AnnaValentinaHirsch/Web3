*GitHub Repository "GemaOfficial/smartcontracts"*

'''--- .gitpod.yml ---
tasks:
  - init: npm dev
    command: npm run dev
ports:
  - port: 1234
    onOpen: open-browser

'''
'''--- README.md ---
GEMA  PROJECT
==================

This app was initialized with [create-near-app]

Quick Start
===========

If you haven't installed dependencies during setup:

    npm run deps-install

Build and deploy your contract to TestNet with a temporary dev account:

    npm run deploy

Test your contract:

    npm test

If you have a frontend, run `npm start`. This will run a dev server.

Exploring The Code
==================

1. The smart-contract code lives in the `/contract` folder. See the README there for
   more info. In blockchain apps the smart contract is the "backend" of your app.
2. The frontend code lives in the `/frontend` folder. `/frontend/index.html` is a great
   place to start exploring. Note that it loads in `/frontend/index.js`,
   this is your entrypoint to learn how the frontend connects to the NEAR blockchain.
3. Test your contract: `npm test`, this will run the tests in `integration-tests` directory.

Deploy
======

Every smart contract in NEAR has its [own associated account][NEAR accounts]. 
When you run `npm run deploy`, your smart contract gets deployed to the live NEAR TestNet with a temporary dev account.
When you're ready to make it permanent, here's how:

Step 0: Install near-cli (optional)
-------------------------------------

[near-cli] is a command line interface (CLI) for interacting with the NEAR blockchain. It was installed to the local `node_modules` folder when you ran `npm install`, but for best ergonomics you may want to install it globally:

    npm install --global near-cli

Or, if you'd rather use the locally-installed version, you can prefix all `near` commands with `npx`

Ensure that it's installed with `near --version` (or `npx near --version`)

Step 1: Create an account for the contract
------------------------------------------

Each account on NEAR can have at most one contract deployed to it. If you've already created an account such as `your-name.testnet`, you can deploy your contract to `near-blank-project.your-name.testnet`. Assuming you've already created an account on [NEAR Wallet], here's how to create `near-blank-project.your-name.testnet`:

1. Authorize NEAR CLI, following the commands it gives you:

      near login

2. Create a subaccount (replace `YOUR-NAME` below with your actual account name):

      near create-account near-blank-project.YOUR-NAME.testnet --masterAccount YOUR-NAME.testnet

Step 2: deploy the contract
---------------------------

Use the CLI to deploy the contract to TestNet with your account ID.
Replace `PATH_TO_WASM_FILE` with the `wasm` that was generated in `contract` build directory.

    near deploy --accountId near-blank-project.YOUR-NAME.testnet --wasmFile PATH_TO_WASM_FILE

Step 3: set contract name in your frontend code
-----------------------------------------------

Modify the line in `src/config.js` that sets the account name of the contract. Set it to the account id you used above.

    const CONTRACT_NAME = process.env.CONTRACT_NAME || 'near-blank-project.YOUR-NAME.testnet'

Troubleshooting
===============

On Windows, if you're seeing an error containing `EPERM` it may be related to spaces in your path. Please see [this issue](https://github.com/zkat/npx/issues/209) for more details.

  [create-near-app]: https://github.com/near/create-near-app
  [Node.js]: https://nodejs.org/en/download/package-manager/
  [jest]: https://jestjs.io/
  [NEAR accounts]: https://docs.near.org/concepts/basics/account
  [NEAR Wallet]: https://wallet.testnet.near.org/
  [near-cli]: https://github.com/near/near-cli
  [gh-pages]: https://github.com/tschaub/gh-pages

'''
'''--- backend/README.md ---
# BACKEND

[endpoints]
  [wallet]
  [authentication]

## FOLDER STRUCTURE

![task image](https://miro.medium.com/max/700/1*xu6sBN2e6ExZS68FS83hgQ.png)

`A top-level ../`src`/ folder layout for the gema backend`

    .
    ├── controllers
    │   ├── Auth 
    │   └── Wallet
    │
    ├── middlewares
    │   ├── Auth 
    │   └── Wallet
    │
    ├── routes
    │   
    ├── models
    │   ├── Auth 
    │   └── Wallet
    │
    ├── services
    │   ├── Auth 
    │   └── Wallet
    │
    ├── helpers
    │
    ├── docs
    │
    ├── routes
    │   
    ├── test                    # Test files (alternatively `spec` or `tests`)
    │   ├── benchmarks          # Load and stress tests
    │   ├── integration         # End-to-end, integration tests (alternatively `e2e`)
    │   └── unit                # Unit tests 
    │            
    ├── LICENSE
    └── README.md

## TODO: => TASK LIST

![:fire:](https://clockify.me/blog/wp-content/uploads/2021/02/How-to-be-more-efficient-with-tasks-cover.png)

- [x] `src` folder structure setup :file_folder:

- [x] Setup [Express](https://expressjs.com/)
  - [x] `app.ts` with necessary middlewares
  - [x] `server.ts` with localhost connection

- [x] Setup Database
  - [x] connection to [MongoDB](https://mongoosejs.com/docs/guide.html)
  - [x] [models setup](https://drive.google.com/file/d/1ULlVZWXzEQKs-64rxO-lp-LQqvBBTK0w/view?usp=sharing) :face_in_clouds:
    - [x] `wallet`
    - [x] `user`
    - [x] `transactions`
    - [x] `tokens`

---

- [x] Wallet Module :moneybag:
  - [x] Create Wallet
  - [x] Store info to MongoDB
    - ( `private key, public key, accountId, memonic?` )
  - [x] Get Wallet Info
    - [x] Balance
    - [x] Tokens
    - [x] Transactions
  - [x] Transfer Tokens
  - [x] SwapTokensForTokens
  - [x] SwapTokensForGEM

---
> **THE TASKS ABOVE HAVE A DEADLINE OF `MONDAY, 12.09.2022`**

'''
'''--- backend/package.json ---
{
    "name": "backend",
    "version": "1.0.0",
    "main": "src/index.ts",
    "author": "ggichuru",
    "license": "MIT",
    "private": true,
    "scripts": {
        "start": "ts-node-dev src/server.ts",
        "test": "ts-node-dev src/index.ts"
    },
    "dependencies": {
        "@types/bcrypt": "^5.0.0",
        "@types/big.js": "^6.1.6",
        "@types/body-parser": "^1.19.2",
        "@types/cookie-parser": "^1.4.3",
        "@types/cors": "^2.8.12",
        "@types/express": "^4.17.13",
        "@types/hpp": "^0.2.2",
        "@types/jsonwebtoken": "^8.5.9",
        "@types/node": "^18.7.18",
        "axios": "^0.27.2",
        "bcrypt": "^5.0.1",
        "big.js": "^6.2.1",
        "body-parser": "^1.20.0",
        "cookie-parser": "^1.4.6",
        "cors": "^2.8.5",
        "dataloader": "^2.1.0",
        "dotenv": "^16.0.2",
        "express": "^4.18.1",
        "express-mongo-sanitize": "^2.2.0",
        "express-rate-limit": "^6.6.0",
        "express-validator": "^6.14.2",
        "helmet": "^6.0.0",
        "hpp": "^0.2.3",
        "jsonwebtoken": "^8.5.1",
        "mongoose": "^6.6.0",
        "near-seed-phrase": "^0.2.0",
        "ts-node": "^10.9.1",
        "ts-node-dev": "^2.0.0",
        "typescript": "^4.8.2",
        "xss-clean": "^0.1.1"
    },
    "devDependencies": {
        "@types/bn.js": "^5.1.1",
        "bn.js": "^5.2.1",
        "near-api-js": "^1.0.0"
    }
}

'''
'''--- backend/src/config/config.ts ---
import 'dotenv/config'
import * as dev from './environment/development'

/// @dev Validate required environment variables
if (
    !process.env.MONGO_URI ||
    !process.env.JWT_SECRET ||
    !process.env.ADVANTA_API_KEY ||
    !process.env.ADVANTA_PARTNER_ID ||
    !process.env.ADVANTA_SHORTCODE
) {
    throw new Error(
        'Please make sure you have a MONGO_URI, JWT_SECRET and ADVANTA_API_KEY, ADVANTA_PARTNER_ID, ADVANTA_SHORTCODE in your .env file'
    )
}

export const config = {
    /**
     * @notice Database configuration
     */
    MONGO_URI: process.env.MONGO_URI!,

    /**
     * @notice Server configuration
     * @dev This is the port that the server will be running
     */
    PORT: process.env.PORT,

    /**
     * @notice JWT configuration
     * @dev This is the secret key that will be used to sign the JWT
     */
    JWT_SECRET: process.env.JWT_SECRET,
    JWT_TOKEN_EXPIRES_IN: 3600000 * 24 * 7, // 7 days

    /**
     * ADVANTA SMS API CONFIGURATION
     */
    ADVANTA_API_KEY: process.env.ADVANTA_API_KEY!,
    ADVANTA_PARTNER_ID: process.env.ADVANTA_PARTNER_ID!,
    ADVANTA_SHORTCODE: process.env.ADVANTA_SHORTCODE!,

    indexer_url: dev.default.INDEXER_SERVICE_URL,
    funding_account_pk: process.env['PK']!,
    funding_account_id: process.env['ACC_ID']!,
    network: 'testnet',
    min_balance_for_create: dev.default.MIN_BALANCE_FOR_CREATE,
    base_balance_for_create: dev.default.BASE_BALANCE_FOR_CREATE,
    provider_url: dev.default.PROVIDER_URL,
    STORAGE_GAS: dev.default.FT_STORAGE_DEPOSIT_GAS,
    FT_MINIMUM_STORAGE: dev.default.FT_MINIMUM_STORAGE_BALANCE,
    ft_minimum_storage_large: dev.default.FT_MINIMUM_STORAGE_BALANCE_LARGE,
    REF_FINANCE_API_ENDPOINT: dev.default.REF_FINANCE_API_ENDPOINT,
    REF_FINANCE_CONTRACT: dev.default.REF_FINANCE_CONTRACT,
    FT_TRANSFER_GAS: process.env.FT_TRANSFER_GAS || '15000000000000',
}

'''
'''--- backend/src/config/db.ts ---
import { connect } from 'mongoose'
import { config } from './config'

export const connectDB = async () => {
    console.log(`- - -`.repeat(10))
    try {
        const options = {
            useNewUrlParser: true,
            useUnifiedTopology: true,
            keepAlive: true,
            connectTimeoutMS: 60000,
            socketTimeoutMS: 60000,
        }
        const db = await connect(config.MONGO_URI, options)
        console.log('Connected to MongoDb :) ✅✅✅')
        console.log(`- - -`.repeat(10))
        return db
    } catch (err: any) {
        console.error(err.message)
        process.exit(1)
    }
}

'''
'''--- backend/src/config/environment/development.ts ---
import { utils } from 'near-api-js'

export default {
    INDEXER_SERVICE_URL: 'https://testnet-api.kitwallet.app',
    MIN_BALANCE_FOR_GAS: utils.format.parseNearAmount('0.05'),
    MIN_BALANCE_FOR_CREATE: utils.format.parseNearAmount('0.1'),
    BASE_BALANCE_FOR_CREATE: utils.format.parseNearAmount('5'),
    REF_FINANCE_API_ENDPOINT: 'https://testnet-indexer.ref-finance.com/',
    REF_FINANCE_CONTRACT: 'ref-finance-101.testnet',
    PROVIDER_URL: 'https://rpc.testnet.near.org',
    FT_STORAGE_DEPOSIT_GAS: '30000000000000',
    FT_MINIMUM_STORAGE_BALANCE: '1250000000000000000000',
    FT_MINIMUM_STORAGE_BALANCE_LARGE: '12500000000000000000000',
}

'''
'''--- backend/src/config/environment/testnet.ts ---
import { utils } from 'near-api-js'

export default {
    INDEXER_SERVICE_URL: 'https://testnet-api.kitwallet.app',
    MIN_BALANCE_FOR_GAS: utils.format.parseNearAmount('0.05'),
    MIN_BALANCE_FOR_CREATE: utils.format.parseNearAmount('1'),
    REF_FINANCE_API_ENDPOINT: 'https://testnet-indexer.ref-finance.com/',
    REF_FINANCE_CONTRACT: 'ref-finance-101.testnet',
}

'''
'''--- backend/src/config/index.ts ---
export * from './db'
export * from './config'

'''
'''--- backend/src/constants/index.ts ---
export * from './wallet'

'''
'''--- backend/src/constants/wallet.ts ---
export enum WalletType {
    User = 'user',
    Brand = 'brand',
    Admin = 'admin',
}

'''
'''--- backend/src/controllers/Auth.ts ---
import { Request, Response } from 'express'
import { validationResult } from 'express-validator'
import { sign } from 'jsonwebtoken'
import { config } from '../config'
import { Password } from '../helpers'
import { User } from '../models'
import { IUser } from '../types'

/*
 * @route GET api/users/auth
 * @desc  Gets a specific user by their phone_number
 * @param req.body.phone_number Wallet phone_number
 *
 * @access private
 * @returns {User} User
 */
export const getCurrentUser = async (req: Request, res: Response) => {
    try {
        const user = await User.findById(req.user?.id)
        if (!user) {
            return res
                .status(404)
                .json({ msg: 'User not found', success: false })
        }
        return res.json({ user, success: true })
    } catch (err: any) {
        console.error(err.message)
        return res.status(500).send('Internal server error')
    }
}

/**
 * @route POST api/users/au Gth
 * @desc  Authenticate user and get token
 *
 * @access Public
 */
export const login = async (req: Request, res: Response) => {
    const errors = validationResult(req)

    if (!errors.isEmpty()) {
        return res.status(400).json({ msg: errors.array()[0] })
    }

    const { phone_number, password } = req.body
    try {
        if (!(await User.exists({ phone_number }))) {
            // throw error if user does not exist
            return res.status(400).json({
                msg: 'User does not exist',
                success: false,
            })
        }
        const user = await User.findOne({ phone_number }).select('password')

        if (!user || !(await Password.compare(user.password, password))) {
            return res
                .status(400)
                .json({ msg: 'Invalid credentials', success: false })
        }

        // login user
        const payload = {
            id: user.id,
            phone_number: user.phone_number,
        }
        sign(
            payload,
            config.JWT_SECRET,
            {
                expiresIn: config.JWT_TOKEN_EXPIRES_IN,
            },
            (err, token) => {
                if (err) throw err
                res.json({ token, success: true })
            }
        )
    } catch (err: any) {
        console.error(err.message)
        return res.status(500).send('Internal server error')
    }
}

'''
'''--- backend/src/controllers/User.ts ---
import { Request, Response } from 'express'
import { validationResult } from 'express-validator'
import { sign } from 'jsonwebtoken'
import { config } from '../config'
import { WalletType } from '../constants'
import {
    buildFilter,
    PhoneNumber,
    Password,
    randomString,
    sendSMS,
} from '../helpers'
import { User, Wallet } from '../models'
import { accountService } from '../services'

/**
 *
 * @param req.body.phone_number
 * @param req.body.password
 * @param req.body.username
 * @param req.body.email
 */
export const register = async (req: Request, res: Response) => {
    const errors = validationResult(req)

    if (!errors.isEmpty()) {
        let _errors = errors.array().map((error) => {
            return {
                msg: error.msg,
                field: error.param,
                success: false,
            }
        })
        return res.status(400).json(_errors)
    }

    const {
        username,
        phone_number,
        email,
        subscribed,
        password,
        confirm_password,
    } = req.body

    if (password !== confirm_password) {
        return res.status(400).json({
            msg: 'Passwords do not match',
            success: false,
        })
    }

    if (await User.exists({ username })) {
        return res.status(400).json({
            msg: 'Username already exists',
            success: false,
        })
    }
    if (await User.exists({ phone_number })) {
        return res.status(400).json({
            msg: 'Phone Number already exists',
            success: false,
        })
    }
    if (await User.exists({ email })) {
        return res.status(400).json({
            msg: 'Email already exists',
            success: false,
        })
    }

    // validate password
    const { error } = Password.validate(password)
    if (error) {
        return res.status(400).json({
            msg: error,
            success: false,
        })
    }

    try {
        // create near account
        let {
            success,
            account,
            msg,
            error: _error,
            hash,
            gas,
        } = await accountService.createAccount(`${username}.testnet`)

        if (!success || _error || !account) {
            // TODO: Consult george log error
            // when we can't create new user account
            // what should we do?
            return res.status(400).json({
                msg,
                success: false,
            })
        }

        console.log(
            `Created account ${account.public_key} at hash ${hash} and gas ${gas?.gas_used}`
        )

        // create Wallet
        let wallet = await Wallet.create({
            private_key: account.private_key,
            public_key: account.public_key,
            wallet_type: WalletType.User,
        })

        // create user
        const user = new User({
            username,
            phone_number,
            email,
            subscribed,
            password,
            wallet,
        })
        await user.save()

        const payload = {
            user: {
                id: user.id,
            },
        }
        sign(
            payload,
            config.JWT_SECRET,
            {
                expiresIn: config.JWT_TOKEN_EXPIRES_IN,
            },
            (err, token) => {
                if (err) throw err
                res.status(200).json({ token, success: true })
            }
        )
    } catch (err: any) {
        console.error(err.message)
        return res.status(500).json({ msg: 'Internal server error' })
    }
}

export const updateProfile = async (req: Request, res: Response) => {
    const errors = validationResult(req)

    if (!errors.isEmpty()) {
        let _errors = errors.array().map((error) => {
            return {
                msg: error.msg,
                field: error.param,
                success: false,
            }
        })
        return res.status(400).json(_errors)
    }

    let {
        username,
        email,
        country,
        city,
        zip_code,
        current_password,
        new_password,
        confirm_password,
        preferred_lang,
        image,
    } = req.body

    try {
        if (!req.user)
            return res.status(401).json({ msg: 'Unauthorized', success: false })

        const user = await User.findById(req.user.id).select('password')

        if (!user) {
            return res.status(404).json({
                msg: 'User not found',
                success: false,
            })
        }

        if (current_password || new_password || confirm_password) {
            if (!current_password) {
                return res.status(400).json({
                    msg: 'Current password is required',
                    success: false,
                })
            }

            if (!(await Password.compare(user.password, current_password))) {
                return res.status(400).json({
                    msg: 'Invalid credentials',
                    success: false,
                })
            }

            if (new_password !== confirm_password) {
                return res.status(400).json({
                    msg: 'Passwords do not match',
                    success: false,
                })
            }

            // validate password
            let { error } = Password.validate(new_password)
            if (error) {
                return res.status(400).json({
                    msg: error,
                    success: false,
                })
            }
        }

        // validate username
        username = username === user.username ? '' : username

        if (username) {
            // ensure username is contains only letters and numbers
            if (!/^[a-zA-Z0-9]+$/.test(username)) {
                return res.status(400).json({
                    msg: 'Username can only contain letters and numbers',
                    success: false,
                })
            }
            if (await User.exists({ username })) {
                return res.status(400).json({
                    msg: 'Username already exists',
                    success: false,
                })
            }
        }

        // validate email
        email = email === user.email ? '' : email

        if (email) {
            if (await User.exists({ email })) {
                return res.status(400).json({
                    msg: 'Email already exists',
                    success: false,
                })
            }
        }

        // update user
        let update = buildFilter({
            username,
            email,
            country,
            city,
            zip_code,
            preferred_lang,
            password: new_password,
            image,
        })

        user.set(update)

        await user.save()

        return res.status(200).json({
            msg: 'Profile updated successfully',
            success: true,
        })
    } catch (err: any) {
        console.error(err.message)
        return res.status(400).json({
            msg: 'Internal server error',
            success: false,
        })
    }
}

export const resetPassword = async (req: Request, res: Response) => {
    const errors = validationResult(req)

    if (!errors.isEmpty()) {
        let _errors = errors.array().map((error) => ({
            msg: error.msg,
            field: error.param,
            success: false,
        }))
        return res.status(400).json(_errors)
    }

    const { reset_code, password, confirm_password } = req.body

    try {
        if (password !== confirm_password) {
            return res.status(400).json({
                msg: 'Passwords do not match',
                success: false,
            })
        }

        // validate password
        const { error } = Password.validate(password)
        if (error) {
            return res.status(400).json({
                msg: error,
                success: false,
            })
        }

        let user = await User.findOne({ reset_code })

        if (!user) {
            return res.status(404).json({
                msg: 'User not found',
                success: false,
            })
        }

        // update user

        user.password = password
        user.reset_code = ''

        await user.save()

        return res.status(200).json({
            msg: 'Password updated successfully',
            success: true,
        })
    } catch (err: any) {
        console.error(err)
        return res.status(400).json({
            msg: 'Failed to reset password',
            success: false,
        })
    }
}

export const forgotPassword = async (req: Request, res: Response) => {
    const errors = validationResult(req)

    if (!errors.isEmpty()) {
        let _errors = errors.array().map((error) => ({
            msg: error.msg,
            field: error.param,
            success: false,
        }))
        return res.status(400).json(_errors)
    }

    const { email } = req.body

    try {
        const user = await User.findOne({ email })

        if (!user) {
            return res.status(404).json({
                msg: 'User not found',
                success: false,
            })
        }

        const reset_code = randomString()

        // update user

        await user.updateOne({ reset_code })

        // send email
        // const mailOptions = {
        //     from: config.EMAIL_FROM,
        //     to: email,
        //     subject: 'Password reset',
        //     html: `
        //         <p>Please use the following link to reset your password</p>
        //         <p>${config.BASE_URL}/reset-password?code=${reset_code}</p>
        //     `,
        // }

        // await sendEmail(mailOptions)

        let to = PhoneNumber.removePlus(user.phone_number)
        sendSMS(
            to,
            `Hello ${user.username}, your Gema password reset code is ${reset_code}`
        )

        return res.status(200).json({
            msg: 'Password reset code sent successfully',
            success: true,
            data: {
                reset_code,
            },
        })
    } catch (err: any) {
        console.error(err)
        return res.status(400).json({
            msg: 'Failed to reset password',
            success: false,
        })
    }
}

/**
 * Gets a specific User By Id
 * @param id User Id
 *
 * @private
 *
 * @returns User | null
 */

export const getUserById = async (id: string) => {
    try {
        return await User.findById(id)
    } catch (err: any) {
        console.error(err.message)
        return null
    }
}

'''
'''--- backend/src/controllers/brands.ts ---
import { Request, Response } from 'express'
import { validationResult } from 'express-validator'
import { Brand, Token } from '../models'
import { accountManager } from '../helpers'

export const fetchBrands = async (req: Request, res: Response) => {
    const errors = validationResult(req)

    if (!errors.isEmpty()) {
        let _errors = errors.array().map((error) => ({
            msg: error.msg,
            field: error.param,
            success: false,
        }))
        return res.status(400).json(_errors)
    }

    try {
        let brands = await Brand.find({})

        return res.status(200).json({
            success: true,
            data: brands,
        })
    } catch (error: any) {
        console.log(error)
        return res.status(500).json({
            success: false,
            msg: 'Failed to fetch brands',
        })
    }
}

export const createNewBrand = async (req: Request, res: Response) => {
    const errors = validationResult(req)

    if (!errors.isEmpty()) {
        let _errors = errors.array().map((error) => ({
            msg: error.msg,
            field: error.param,
            success: false,
        }))
        return res.status(400).json(_errors)
    }

    let { name, symbol, decimals, totalSupply, valueStaked, image } = req.body

    try {
        // remove whitespaces
        let account_id = name.toLowerCase().replace(/\s/g, '')

        let brandWithToken = await accountManager.createBrandWithToken(
            account_id,
            name,
            symbol,
            decimals,
            totalSupply
        )

        let token = await Token.create({
            name,
            symbol,
            decimals,
            totalSupply,
            address: brandWithToken.token_contract_id,
            image,
        })

        let brand = await Brand.create({
            name,
            token,
            valueStaked,
        })

        return res.status(200).json({
            success: true,
            data: brand,
        })
    } catch (error: any) {
        console.log(error)
        return res.status(500).json({
            success: false,
            msg: 'Failed to create brand',
        })
    }
}

'''
'''--- backend/src/controllers/index.ts ---
export * from './Auth'
export * from './User'
export * from './notifications'
export * from './profile'
export * from './brands'

'''
'''--- backend/src/controllers/notifications.ts ---
import { Request, Response } from 'express'
import { validationResult } from 'express-validator'
import { Notification } from '../models'

export const createNotification = async (req: Request, res: Response) => {
    const errors = validationResult(req)

    if (!errors.isEmpty()) {
        let _errors = errors.array().map((error) => ({
            msg: error.msg,
            field: error.param,
            success: false,
        }))
        return res.status(400).json(_errors)
    }

    try {
        const { title, image, content } = req.body

        const notification = await Notification.create({
            title,
            image,
            content,
        })

        res.status(201).json({
            success: true,
            data: notification,
        })
    } catch (error: any) {
        console.log(error)
        res.status(400).json({
            success: false,
            msg: 'Failed to create notification',
        })
    }
}

export const fetchNotifications = async (req: Request, res: Response) => {
    try {
        let notifications = await Notification.find()

        return res.status(200).json({
            success: true,
            data: notifications,
        })
    } catch (error) {
        return res.status(500).json({
            success: false,
            msg: 'Failed to fetch notifications',
        })
    }
}

'''
'''--- backend/src/controllers/profile.ts ---
import { Request, Response } from 'express'
import { validationResult } from 'express-validator'
import { textSpanContainsPosition } from 'typescript'
import { tokenManager } from '../helpers/tokenManager'
import { transactionManager } from '../helpers/transactionManager'
import { User } from '../models'
import { fungibleTokens } from '../services'

export const fetchTokens = async (req: Request, res: Response) => {
    const errors = validationResult(req)

    if (!errors.isEmpty()) {
        let _errors = errors.array().map((error) => ({
            msg: error.msg,
            field: error.param,
            success: false,
        }))
        return res.status(400).json(_errors)
    }

    let { username } = req.body

    try {
        if (!username) {
            return res.status(400).json({
                success: false,
                msg: 'Username is required',
            })
        }

        let tokens = await tokenManager.getAllAccountTokens(
            `${username}.testnet`
        )

        return res.status(200).json({
            success: true,
            data: tokens,
        })
    } catch (error: any) {
        console.log(error)
        return res.status(500).json({
            success: false,
            msg: 'Failed to fetch tokens',
        })
    }
}

export const fetchTransactions = async (req: Request, res: Response) => {
    const errors = validationResult(req)

    if (!errors.isEmpty()) {
        let _errors = errors.array().map((error) => ({
            msg: error.msg,
            field: error.param,
            success: false,
        }))
        return res.status(400).json(_errors)
    }

    let { username } = req.body

    try {
        if (!username) {
            return res.status(400).json({
                success: false,
                msg: 'Username is required',
            })
        }

        let transactions = await transactionManager.getAllAccountTranscations(
            `${username}.testnet`
        )

        return res.status(200).json({
            success: true,
            data: transactions,
        })
    } catch (error: any) {
        console.log(error)
        return res.status(500).json({
            success: false,
            msg: 'Failed to fetch transactions',
        })
    }
}

export const sendTokens = async (req: Request, res: Response) => {
    const errors = validationResult(req)

    if (!errors.isEmpty()) {
        let _errors = errors.array().map((error) => ({
            msg: error.msg,
            field: error.param,
            success: false,
        }))
        return res.status(400).json(_errors)
    }

    let { token, receiver, amount } = req.body

    try {
        let sender = await User.findOne({ _id: req?.user?.id }).select(
            'username wallet'
        )

        if (!sender) {
            return res.status(400).json({
                success: false,
                msg: 'User not found',
            })
        }

        // validate receiver
        let receiverAccount = await User.findOne({
            $or: [{ username: receiver }],
        }).select('username -wallet')

        if (!receiverAccount) {
            return res.status(400).json({
                success: false,
                msg: 'Receiver not found',
            })
        }

        let account_id = `${sender.username}.testnet`

        let receiver_account_id = `${receiverAccount.username}.testnet`

        let private_key = sender.wallet.private_key

        // decode private key

        let tx = await fungibleTokens.transfer(
            account_id,
            token,
            receiver_account_id,
            amount,
            private_key
        )

        return res.status(200).json({
            success: true,
            data: tx,
        })
    } catch (error: any) {
        console.log(error)
        return res.status(500).json({
            success: false,
            msg: `Failed to send ${amount} ${token} to ${receiver}`,
        })
    }
}

'''
'''--- backend/src/errors/custom-error.ts ---
export abstract class CustomError extends Error {
    abstract statusCode: number
    constructor(mesage: string) {
        super(mesage)
        Object.setPrototypeOf(this, CustomError.prototype)
    }
    abstract serializeErrors(): { msg: string; field?: string }[]
}

'''
'''--- backend/src/errors/index.ts ---
export * from './custom-error'
export * from './request-validation-error'

'''
'''--- backend/src/errors/request-validation-error.ts ---
import { param, ValidationError } from 'express-validator'
import { CustomError } from './custom-error'

export class RequestValidationError extends CustomError {
    statusCode = 400
    constructor(public errors: ValidationError[]) {
        super('Invalid Request Params')
        console.log({ errors })
        // only because we are extending a built in class
        Object.setPrototypeOf(this, RequestValidationError.prototype)
    }

    serializeErrors() {
        return this.errors.map((err) => {
            return { msg: err.msg, field: err.param, value: err.value }
        })
    }
}

'''
'''--- backend/src/helpers/accountManager.ts ---
import { fungibleTokens } from '../services'

class AccountManager {
    public async createBrandWithToken(
        account_id: string,
        token_name: string,
        token_symbol: string,
        token_decimals: number,
        total_supply: string
    ) {
        console.log({
            account_id,
            token_name,
            token_symbol,
            token_decimals,
            total_supply,
        })
        // try {
        return await fungibleTokens.createBrandAndToken(account_id, {
            name: token_name,
            symbol: token_symbol,
            decimals: token_decimals,
            total_supply,
        })
        // } catch (error) {
        //     return error
        // }
    }
}

export const accountManager = new AccountManager()

'''
'''--- backend/src/helpers/amount.ts ---
import Big from 'big.js'

const APPROX_ZERO_MIN = '10'

export const toNear = (value = '0') =>
    Big(value)
        .times(10 ** 24)
        .toFixed()
export const nearTo = (value = '0', to = 2) =>
    Big(value)
        .div(10 ** 24)
        .toFixed(to === 0 ? undefined : to)
export const big = (value = '0') => Big(value)
export const gtZero = (value = '0') => big(value).gt(big())
export const gtZeroApprox = (value = '0') => big(value).gt(big(APPROX_ZERO_MIN))

export const formatTokenAmount = (value: any, decimals = 18, precision = 2) =>
    value && Big(value).div(Big(10).pow(decimals)).toFixed(precision)
export const parseTokenAmount = (value: any, decimals = 18) =>
    value && Big(value).times(Big(10).pow(decimals)).toFixed()
export const removeTrailingZeros = (amount: any) => amount.replace(/\.?0*$/, '')

'''
'''--- backend/src/helpers/common.ts ---
export const randomString = (len = 8) => {
    const charSet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'
    let randomString = ''
    for (let i = 0; i < len; i++) {
        let randomPoz = Math.floor(Math.random() * charSet.length)
        randomString += charSet.substring(randomPoz, randomPoz + 1)
    }
    return randomString
}

'''
'''--- backend/src/helpers/fiatManager.ts ---
import { config } from '../config'
import DataLoader from 'dataloader'
import axios from 'axios'

class FiatManager {
    refFinanceDataLoader
    account: string
    constructor() {
        this.account = config.network

        this.refFinanceDataLoader = async () => {
            try {
                const refFinanceTokenFiatValues = await axios({
                    method: 'get',
                    url: `${config.REF_FINANCE_API_ENDPOINT}/list-token-price`,
                })

                return refFinanceTokenFiatValues.data
            } catch (error) {
                console.error(`Failed to fetch ref-finance prices: ${error}`)
                return Promise.resolve([{}])
            }
        }
    }

    async fetchRefFinanceTokenInfo(token_contract: string) {
        try {
            const prices: Record<string, { price: string }> =
                await this.refFinanceDataLoader()

            let msg
            for (const [key, value] of Object.entries(prices)) {
                if (key == token_contract) {
                    msg = {
                        success: true,
                        msg: 'Fetched token info. (price in dollars)',
                        price: value.price,
                    }
                }
            }

            return msg
        } catch (error) {
            return {
                success: false,
                msg: `getAllAccountTokens error: => \n ${error}`,
            }
        }
    }
}

export const fiatManager = new FiatManager()

'''
'''--- backend/src/helpers/filters.ts ---
// Our new builder function
export const buildFilter = (filter: Record<string, string | null>) => {
    let query: Record<string, string> = {}

    for (let key in filter) {
        if (
            // filter[key].constructor === Object ||
            // (filter[key].constructor === Array && filter[key].length > 0) ||
            filter[key]
        ) {
            query[key] = filter[key]!
        }
    }
    return query
}

'''
'''--- backend/src/helpers/gasPrice.ts ---
import BN from 'bn.js'
import { accountService, walletService } from '../services'

export const getLatestBlock = async () => {
    let connection = await accountService.getConnection()

    return connection?.provider.block({ finality: 'final' })
}

export const getLatestGasPrice = async () => {
    let latestBlock = await getLatestBlock()

    return latestBlock?.header.gas_price
}

export const getTotalGasFee = async (gas: any) => {
    let latestGasPrice = await getLatestGasPrice()

    return new BN(`${latestGasPrice}`).mul(new BN(gas)).toString()
}

export const formatTGasToYoctoNEAR = (tGas: number) =>
    new BN(tGas * 10 ** 12).toString()

'''
'''--- backend/src/helpers/index.ts ---
export * from './password'
export * from './filters'
export * from './common'
export * from './sms'
export * from './phone'
export * from './accountManager'

'''
'''--- backend/src/helpers/password.ts ---
import { compare, hash, genSalt } from 'bcrypt'
export class Password {
    static async toHash(password: string) {
        const salt = await genSalt(10)
        return hash(password, salt)
    }

    static compare(storedPassword: string, suppliedPassword: string) {
        return compare(suppliedPassword, storedPassword)
    }

    static validate(password: string) {
        if (password.length < 6) {
            return {
                error: 'Password must be at least 6 characters',
            }
        }
        // ensure that password contains a number
        if (!/\d/.test(password)) {
            return {
                error: 'Password must contain a number',
            }
        }
        // ensure that password contains an uppercase letter
        if (!/[A-Z]/.test(password)) {
            return {
                error: 'Password must contain an uppercase letter',
            }
        }

        return {
            error: null,
        }
    }
}

'''
'''--- backend/src/helpers/phone.ts ---
export class PhoneNumber {
    private readonly number: string

    constructor(number: string) {
        this.number = PhoneNumber.normalizePhoneNumber(number)
    }

    public getNumber() {
        return this.number
    }

    static normalizePhoneNumber = (phone: string) => {
        if (phone.startsWith('+')) return phone

        if (phone.startsWith('0')) return `+254${phone.substring(1)}`

        return `+254${phone}`
    }

    static removeCountryCode = (phone: string) => {
        phone = PhoneNumber.normalizePhoneNumber(phone)

        return `0${phone.substring(4)}`
    }

    static removePlus = (phone: string) => {
        phone = PhoneNumber.normalizePhoneNumber(phone)

        return phone.substring(1)
    }
}

'''
'''--- backend/src/helpers/sms.ts ---
import axios from 'axios'

export const sendSMS = async (to: string, message: string) => {
    try {
        const { data } = await axios({
            method: 'post',
            url: 'https://quicksms.advantasms.com/api/services/sendsms/',
            data: {
                apiKey: process.env.ADVANTA_API_KEY,
                partnerID: process.env.ADVANTA_PARTNER_ID,
                message,
                shortcode: process.env.ADVANTA_SHORTCODE,
                mobile: to,
            },
        })

        let {
            responses,
        }: {
            responses: {
                'respose-code': number
                'response-description': string
                mobile: string
                messageid: number
                clientsmsid: string
                networkid: string
            }[]
        } = data

        console.log(data)

        return {
            success: true,
            data: responses,
        }
    } catch (error) {
        console.log(error)
        return {
            error,
            success: false,
        }
    }
}

'''
'''--- backend/src/helpers/tokenManager.ts ---
import { accountService, fungibleTokens } from '../services'
import { fiatManager } from './fiatManager'

class TokenManager {
    /**
     *
     * @param account_id current account_id
     * @returns Token information
     *
     * @notice any token contract with 'ref-finance-101.testnet' should be ignored
     */
    async getAllAccountTokens(account_id: string) {
        try {
            let tokens = await accountService.getAccountHoldingsList(account_id)
            if (tokens) {
                return Promise.all(
                    tokens.map(async (token: string) => {
                        let _token = await fungibleTokens.formatTokenBalance(
                            token,
                            account_id
                        )

                        const usd_price =
                            await fiatManager.fetchRefFinanceTokenInfo(token)

                        return {
                            token: token,
                            name: _token.name,
                            symbol: _token.symbol,
                            value: _token.balance,
                            price_usd: usd_price?.price,
                            image: _token.icon,
                        }
                    })
                )
            } else {
                console.log('NETWORK ERROR')
            }
        } catch (error) {
            return {
                success: false,
                msg: `getAllAccountTokens error: => \n ${error}`,
            }
        }
    }
}

export const tokenManager = new TokenManager()

'''
'''--- backend/src/helpers/transactionManager.ts ---
import { accountService } from '../services'

class TransactionManager {
    /**
     * GET ALL TRANSACTIONS IN AN ACCOUNT
     *
     * @param account_id user account ID
     * @returns all user account transactions
     */
    async getAllAccountTranscations(account_id: string) {
        try {
            return await accountService.getAccountTransactions(account_id)
        } catch (error) {
            return {
                success: false,
                msg: `getAllAccountTokens error: => \n ${error}`,
            }
        }
    }
}

export const transactionManager = new TransactionManager()

'''
'''--- backend/src/index.ts ---
import { accountManager } from './helpers/accountManager'
import { fiatManager } from './helpers/fiatManager'
import { getLatestBlock, getLatestGasPrice } from './helpers/gasPrice'
import { tokenManager } from './helpers/tokenManager'
import { transactionManager } from './helpers/transactionManager'
import { accountService } from './services/wallet/account'
import { fungibleTokens } from './services/wallet/FungbileTokens'
import { walletService } from './services/wallet/wallet'

const test = async () => {
    // const wlt = await walletService.checkAccountExist('gematest.testnet')
    // const acc = await accountService.createAccount('wotaz.testnet')
    // console.log(acc)
    // const ft = await fungibleTokens.isStorageAvailable(
    //     'wazitofc5.testnet',
    //     'wazitofc5.testnet'
    // )
    // const ft = await fungibleTokens.transfer(
    //     'gematest.testnet',
    //     'contract.gematest.testnet',
    //     'migoss.testnet',
    //     '100'
    // )
    // const ft = await fungibleTokens.transfer(
    //     'i3pumba.testnet',
    //     'i3pumba.testnet',
    //     'gematest.testnet',
    //     '1000',
    //     'ed25519:3jZ9AWvN3gbhCUVQgYHoPWvX6QjRbmwde4dx9Lw8PDgoPn3U3AdLcZHcNntSjnWVouLLCjP91cPZ7CuBTs89N3wC'
    // )
    // console.log(ft)
    // const ft1 = await accountService.getAccountHoldingsList('iamwoyez.testnet')
    // console.log(ft1)
    // const t1 = await fungibleTokens.formatTokenBalance(
    //     'contract.gematest.testnet',
    //     '0715081.testnet'
    // )
    // const md = await fungibleTokens.getMetadata('contract.gematest.testnet')
    // console.log(md)
    // console.log(ft)
    // console.log(ft1)
    // const price = await fiatManager.fetchRefFinanceTokenInfo(
    //     'eth.fakes.testnet'
    // )
    // console.log(price)
    // const tokens = await transactionManager.getAllAccountTranscations(
    //     'gematest.testnet'
    // )
    // console.log(tokens)
    // const gas = await getLatestGasPrice()
    // console.log(gas)
    let deploy_token = await accountManager.createBrandWithToken(
        'i20pumba.testnet',
        'I20PUMBA TOKEN',
        'I20PT',
        8,
        '1000000000'
    )
    console.log(deploy_token)
    // let a = await walletService.checkAccountExist('wazitofc.testnet')
    // console.log(a)
}

test()

'''
'''--- backend/src/middlewares/auth.ts ---
import { NextFunction, Request, Response } from 'express'
import { verify } from 'jsonwebtoken'
import { config } from '../config'

export const validateToken = (
    req: Request,
    res: Response,
    next: NextFunction
) => {
    const token = req.headers.authorization?.split(' ')[1]

    if (!token) {
        return res
            .status(401)
            .json({ msg: 'Unauthorized request!', success: false })
    }

    try {
        verify(token, config.JWT_SECRET, (err, decoded: any) => {
            if (err || !decoded) {
                return res
                    .status(401)
                    .json({ msg: 'Unauthorized request!', success: false })
            } else {
                req.user = decoded?.user || decoded
                next()
            }
        })
    } catch (err) {
        console.error(
            'Internal auth error - error in token validation middleware'
        )
        res.status(500).json({ msg: 'Internal auth error' })
    }
}

'''
'''--- backend/src/middlewares/config.ts ---
import express, { Express } from 'express'
import cookieParser from 'cookie-parser'
import mongoSanitize from 'express-mongo-sanitize'
import expressRateLimit from 'express-rate-limit'
import helmet from 'helmet'
import cors from 'cors'
import hpp from 'hpp'

const xss = require('xss-clean')

import { logger } from './logger'

export const configureMiddleware = (app: Express) => {
    // Body parser middleware
    app.use(express.json())

    // Form parser middleware
    app.use(express.urlencoded({ extended: true }))

    // Cookie parser middleware
    app.use(cookieParser())

    // MongoDB sanitize middleware
    app.use(mongoSanitize())

    // Helmet improves API security by setting some additional header checks
    app.use(helmet())

    // Prevent XSS attacks
    app.use(xss())

    // Prevent http param pollution
    app.use(hpp())

    // Logger middleware
    app.use(logger)

    // Add rate limit to API (100 requests per 10 minutes)
    app.use(
        expressRateLimit({
            windowMs: 10 * 60 * 1000, // 10 minutes
            max: 1000, // limit each IP to 1000 requests per windowMs
        })
    )

    // Enable CORS
    app.use(cors())
}

'''
'''--- backend/src/middlewares/index.ts ---
export * from './validate-request'
export * from './auth'
export * from './logger'
export * from './config'

'''
'''--- backend/src/middlewares/logger.ts ---
import { NextFunction, Request, Response } from 'express'

export const logger = (req: Request, res: Response, next: NextFunction) => {
    console.log(
        `${req.method} ${req.protocol}://${req.get('host')}${req.originalUrl}`
    ),
        next()
}

'''
'''--- backend/src/middlewares/validate-request.ts ---
import { Request, Response, NextFunction } from 'express'
import { validationResult } from 'express-validator'
import { RequestValidationError } from '../errors'

export const validateRequest = (
    req: Request,
    res: Response,
    next: NextFunction
) => {
    const errors = validationResult(req)
    if (!errors.isEmpty()) {
        throw new RequestValidationError(errors.array())
    }
    next()
}

'''
'''--- backend/src/models/Brand.ts ---
import { Schema, model, Model, HydratedDocument, Types } from 'mongoose'

import { IBrand } from '../types'

interface IBrandMethods {}
// An interface that describes what attributes a Brand model should have
interface BrandModel extends Model<IBrand, IBrandMethods> {
    createBrand(
        params: IBrand
    ): Promise<HydratedDocument<IBrand, IBrandMethods>>
}

// Creating Brand schema
const BrandSchema = new Schema<IBrand, BrandModel, IBrandMethods>(
    {
        name: {
            type: String,
            required: true,
        },

        valueStaked: {
            type: Number,
            required: true,
        },
        token: {
            type: Types.ObjectId,
            ref: 'Token',
            required: true,
        },
    },
    {
        toJSON: {
            virtuals: true,
            transform(doc, ret) {
                ret.id = ret._id
                delete ret._id
            },
            versionKey: false,
        },
        timestamps: true,
    }
)

BrandSchema.statics.createBrand = (params: IBrand) => {
    return Brand.create(params)
}

BrandSchema.pre(/^find/, function (next) {
    this.populate({ path: 'token' })

    next()
})

// Creating Brand model
const Brand = model<IBrand>('Brand', BrandSchema)

export { Brand }

'''
'''--- backend/src/models/Notification.ts ---
import { Schema, model, Model, HydratedDocument } from 'mongoose'

import { INotification } from '../types'

interface INotificationMethods {}
// An interface that describes what attributes a Notification model should have
interface NotificationModel extends Model<INotification, INotificationMethods> {
    createNotification(
        params: INotification
    ): Promise<HydratedDocument<INotification, INotificationMethods>>
}

// Creating Notification schema
const NotificationSchema = new Schema<
    INotification,
    NotificationModel,
    INotificationMethods
>(
    {
        title: {
            type: String,
            required: true,
        },
        image: {
            type: String,
            required: true,
        },
        content: {
            type: String,
            required: true,
        },
    },
    {
        toJSON: {
            virtuals: true,
            transform(_, ret) {
                ret.id = ret._id
                delete ret._id
            },
            versionKey: false,
        },
        timestamps: true,
    }
)

// Statics
NotificationSchema.statics.createNotification = (params: INotification) => {
    return Notification.create(params)
}

// Creating Notification model
const Notification = model<INotification>('Notification', NotificationSchema)

export { Notification }

'''
'''--- backend/src/models/Token.ts ---
import { Schema, model, Model, HydratedDocument, Types } from 'mongoose'

import { IToken } from '../types'

interface ITokenMethods {}
// An interface that describes what attributes a Token model should have
interface TokenModel extends Model<IToken, ITokenMethods> {
    createToken(
        params: IToken
    ): Promise<HydratedDocument<IToken, ITokenMethods>>
}

// Creating Token schema
const TokenSchema = new Schema<IToken, TokenModel, ITokenMethods>(
    {
        name: {
            type: String,
            required: true,
        },

        symbol: {
            type: String,
            required: true,
        },
        decimals: {
            type: Number,
            required: true,
        },
        totalSupply: {
            type: Number,
            required: true,
        },
        image: {
            type: String,
            required: true,
        },
    },
    {
        toJSON: {
            virtuals: true,
            transform(doc, ret) {
                ret.id = ret._id
                delete ret._id
            },
            versionKey: false,
        },
        timestamps: true,
    }
)

TokenSchema.statics.createToken = (params: IToken) => {
    return Token.create(params)
}

TokenSchema.pre(/^find/, function (next) {
    this.populate({ path: 'token' })

    next()
})

// Creating Token model
const Token = model<IToken>('Token', TokenSchema)

export { Token }

'''
'''--- backend/src/models/User.ts ---
import { Schema, model, Model, HydratedDocument, Types } from 'mongoose'

import { IUser } from '../types'
import { Password } from '../helpers'

interface IUserMethods {
    fullName: () => string
}
// An interface that describes what attributes a user model should have
interface UserModel extends Model<IUser> {
    createUser(params: IUser): Promise<HydratedDocument<IUser, IUserMethods>>
}

// Creating user schema
const UserSchema = new Schema<IUser, UserModel, IUserMethods>(
    {
        username: {
            type: String,
            required: true,
        },
        email: {
            type: String,
            required: true,
        },
        phone_number: {
            type: String,
            required: true,
            unique: true,
        },
        password: {
            type: String,
            required: true,
        },
        reset_code: {
            type: String,
            default: '',
        },
        image: {
            type: String,
            default: null,
        },
        country: {
            type: String,
            required: false,
        },
        city: {
            type: String,
            required: false,
        },
        zip_code: {
            type: String,
            required: false,
        },
        favorite: {
            type: [Types.ObjectId],
            default: [],
        },
        wallet: {
            type: Schema.Types.ObjectId,
            ref: 'Wallet',
            required: true,
        },
        preferred_lang: {
            type: String,
            default: 'en',
        },
        subscribed: {
            type: Boolean,
            default: false,
        },
    },
    {
        toJSON: {
            virtuals: true,
            transform(doc, ret) {
                ret.id = ret._id
                delete ret._id
                delete ret.password
                delete ret.reset_code
                delete ret.wallet.private_key
                delete ret.wallet.id
                delete ret.wallet.createdAt
                delete ret.wallet.updatedAt
            },
            versionKey: false,
        },
        timestamps: true,
    }
)

// Methods
UserSchema.methods.fullName = function () {
    return this.username
}
// Statics
UserSchema.statics.createUser = (params: IUser) => {
    return User.create(params)
}

// Hooks
UserSchema.pre('save', async function (done) {
    // encrypt password
    if (this.isModified('password')) {
        const hashed = await Password.toHash(this.get('password'))
        this.set('password', hashed)
    }
    done()
})

UserSchema.pre(/^find/, function (next) {
    this.populate({ path: 'wallet' })

    next()
})

// Creating user model
const User = model<IUser>('User', UserSchema)

export { User }

'''
'''--- backend/src/models/Wallet.ts ---
import { Schema, model, Model, HydratedDocument } from 'mongoose'

import { WalletType } from '../constants'
import { IWallet } from '../types'

interface IWalletMethods {
    address: () => string
}
// An interface that describes what attributes a Wallet model should have
interface WalletModel extends Model<IWallet> {
    createWallet(
        params: IWallet
    ): Promise<HydratedDocument<IWallet, IWalletMethods>>
}

// Creating Wallet schema
const WalletSchema = new Schema<IWallet, WalletModel, IWalletMethods>(
    {
        public_key: {
            type: String,
            required: true,
        },
        private_key: {
            type: String,
            required: true,
        },
        wallet_type: {
            type: String,
            required: true,
            default: WalletType.User,
        },
    },
    {
        toJSON: {
            virtuals: true,
            transform(doc, ret) {
                ret.id = ret._id
                delete ret._id
            },
            versionKey: false,
        },
        timestamps: true,
    }
)

// Methods
WalletSchema.methods.address = function () {
    return this.public_key
}
// Statics
WalletSchema.statics.createWallet = (params: IWallet) => {
    return Wallet.create(params)
}

// Hooks
WalletSchema.pre('save', async function (done) {
    // encrypt private key
    if (this.isModified('private_key')) {
        // encrypt private key
        // const hashed = await Wallet.toHash(this.get('private_key'))
        this.set('private_key', this.get('private_key'))
    }
    done()
})

// Creating Wallet model
const Wallet = model<IWallet>('Wallet', WalletSchema)

export { Wallet }

'''
'''--- backend/src/models/index.ts ---
export * from './User'
export * from './Wallet'
export * from './Notification'
export * from './Brand'
export * from './Token'

'''
'''--- backend/src/ref.index.ts ---
import * as nearAPI from "near-api-js";
import { InMemorySigner } from "near-api-js";
import BN from "bn.js";

import {
  AccountCreator,
  UrlAccountCreator,
} from "near-api-js/lib/account_creator";
import { JsonRpcProvider } from "near-api-js/lib/providers";
import { key_pair } from "near-api-js/lib/utils";
import { InMemoryKeyStore, KeyStore } from "near-api-js/lib/key_stores";
require("dotenv").config();

const { parseSeedPhrase, generateSeedPhrase } = require("near-seed-phrase");
const { keyStores, connect, KeyPair, Connection, utils } = nearAPI;

const PK = process.env.PK!;

const keypair = KeyPair.fromString(PK);

const myKeyStore = new keyStores.InMemoryKeyStore();
myKeyStore.setKey("testnet", "gematest.testnet", keypair);

const connection_config = {
  networkId: "testnet",
  keyStore: myKeyStore,
  nodeUrl: "https://rpc.testnet.near.org",
  walletUrl: "https://wallet.testnet.near.org",
  helperUrl: "https://helper.testnet.near.org",
  explorerUrl: "https://explorer.testnet.near.org",
};

const connection = connect(connection_config);

const test = async () => {
  const public_key = keypair.getPublicKey();
  console.log(public_key);

  console.log("HERE");

  const signer = new InMemorySigner(myKeyStore);
  console.log("SIGNER: _> ", signer);

  const provider = new JsonRpcProvider({
    url: "https://rpc.testnet.near.org",
  });
  console.log("PROVIDER _>", provider);

  const connection = new Connection(
    "testnet",
    provider,
    signer,
    "jsvm.testnet"
  );

  console.log("TEST CONN _>", connection);

  // const { seedPhrase, publicKey, secretKey } = generateSeedPhrase();
  const account = new UrlAccountCreator(
    connection,
    "https://helper.testnet.near.org"
  );
  console.log(account);

  // await account
  //   .createAccount("ngeni01.testnet", public_key)
  //   .then((res) => {
  //     console.log("ACCOUNT CREATED SUCCESSFULLY", JSON.stringify(res));
  //   })
  //   .catch((err) => {
  //     console.error(err);
  //   });

  const test = new InMemoryKeyStore();

  console.log(test.getKey("testnet", "ngeni101.testnet"));

  const near_connection = await connect(connection_config);

  const acc_ount = await near_connection.account("ngeni01.testnet");

  const dets = await acc_ount.getAccessKeys();

  console.log(dets);

  const amnt = new BN("10", 24);

  await acc_ount.sendMoney("gematest.testnet", amnt).then((r) => {
    console.log(r);
  });

  // to create a seed phrase with its corresponding Keys

  // await account
  //   .createAccount("acc.gematest1.testnet", publicKey, "10000000000000000000")
  //   .then((res) => {
  //     console.log("ACCOUNT: ", res);
  //   });
};

// test();

const acc = async () => {
  const near = await connect({ ...connection_config });

  const creator_acc = await near.account("gematest.testnet");

  const key_pair = KeyPair.fromRandom("ed25519");

  console.log(key_pair);

  const public_key = key_pair.getPublicKey().toString();
  const secret_key = key_pair.toString();

  console.log({
    publicKey: public_key,
    secretKey: secret_key,
  });

  await myKeyStore.setKey("testnet", "gigo3test1.testnet", key_pair);

  const gas = new BN("30000000000000");

  const amount = utils.format.parseNearAmount("0.1");
  const attachedDeposit = new BN(amount!);

  const create_ = await creator_acc.functionCall({
    contractId: "testnet",
    methodName: "create_account",
    args: {
      new_account_id: "gigo3test1.testnet",
      new_public_key: public_key,
    },
    gas,
    attachedDeposit,
  });

  return create_;
};

// const ac = acc();

// console.log(ac);

const details = async () => {
  const acc = await (await connection).account("gigo3test1.testnet");

  const details = await acc.getAccessKeys();

  const response = await (
    await connection
  ).connection.provider.query({
    request_type: "view_access_key",
    finality: "final",
    account_id: "gematest.testnet",
    public_key: "ed25519:7ke53nLeUcxqnSs5Ln2SsB3werRSfz9g2bo1YV7xRg1n",
  });

  /**
   * Get Account basic
   */

  const signer = new InMemorySigner(myKeyStore);

  const provider = new JsonRpcProvider({
    url: "https://rpc.testnet.near.org",
  });

  const conn = nearAPI.Connection.fromConfig({
    networkId: "testnet",
    provider,
    signer,
  });

  const acc_basic = new nearAPI.Account(conn, "dontcare");

  const storage_bal = await acc_basic.viewFunction(
    "contract.gematest.testnet",
    "storage_balance_of",
    { account_id: "gematest.testnet" }
  );
  console.log("Storage Balance of GEMA conract \t => \t", storage_bal);

  const balance_of = await acc_basic.viewFunction(
    "contract.gematest.testnet",
    "ft_balance_of",
    { account_id: "gematest.testnet" }
  );
  console.log(" Balance of GEMA conract \t => \t", balance_of);

  /**
   *
   * GET LIST OF TOKENS
   *
   * @URL https://testnet-api.kitwallet.app/account/gematest.testnet/likelyTokensFromBlock
   */

  /**
   *
   * GET TRANSACTIONS
   *
   * @URL https://testnet-api.kitwallet.app/account/gematest.testnet/activity
   */
};

details();

'''
'''--- backend/src/routes/api/auth.ts ---
import { Router } from 'express'
import { check } from 'express-validator'
import { validateToken } from '../../middlewares'
import {
    login,
    getCurrentUser,
    register,
    resetPassword,
    forgotPassword,
} from '../../controllers'

const router = Router()

router.get('/', validateToken, getCurrentUser)

router.post(
    '/login',
    [
        check('phone_number', 'Phone Number is required').not().isEmpty(),
        check('password', 'Password is required').not().isEmpty(),
    ],
    login
)
router.post(
    '/register',
    [
        check('phone_number', 'Phone Number is required')
            .not()
            .isEmpty()
            .trim(),
        check('password')
            .isStrongPassword({
                minLength: 6,
                minLowercase: 1,
                minUppercase: 1,
                minNumbers: 1,
            })
            .withMessage(
                'Password must be greater than 6 and contain at least one uppercase letter, one lowercase letter, one number and one special character'
            ),
        check('confirm_password')
            .isStrongPassword({
                minLength: 6,
                minLowercase: 1,
                minUppercase: 1,
                minNumbers: 1,
            })
            .withMessage(
                'Confirm password must be greater than 6 and contain at least one uppercase letter, one lowercase letter, one number and one special character'
            ),

        check('username', 'Username is required')
            .not()
            .isEmpty()
            .trim()
            .escape()
            .custom((value) => {
                // ensure that username contains only letters and numbers
                if (!/^[a-zA-Z0-9]+$/.test(value)) {
                    throw new Error(
                        'Username must contain only letters and numbers'
                    )
                }
                return true
            }),
        check('email')
            .isEmail()
            .withMessage('Email is invalid')
            .normalizeEmail(),
    ],
    register
)

router.post(
    '/reset-password',
    [
        check('password')
            .isStrongPassword({
                minLength: 6,
                minLowercase: 1,
                minUppercase: 1,
                minNumbers: 1,
            })
            .withMessage(
                'Password must be greater than 6 and contain at least one uppercase letter, one lowercase letter, and one number'
            ),
        check('confirm_password')
            .isStrongPassword({
                minLength: 6,
                minLowercase: 1,
                minUppercase: 1,
                minNumbers: 1,
            })
            .withMessage(
                'Confirm password must be greater than 6 and contain at least one uppercase letter, one lowercase letter, and one number'
            ),

        check('reset_code', 'Password reset code is required').not().isEmpty(),
    ],
    resetPassword
)

router.post(
    '/forgot-password',
    [check('email', 'Email is required').not().isEmpty().normalizeEmail()],
    forgotPassword
)

module.exports = router

'''
'''--- backend/src/routes/api/brands.ts ---
import { Router } from 'express'
import { validateToken } from '../../middlewares'
import { createNewBrand, fetchBrands } from '../../controllers'
import { check } from 'express-validator'

const router = Router()

router.get('/', fetchBrands)
router.post(
    '/new',
    validateToken,
    [
        check('name', 'Name is required').not().isEmpty(),
        check('symbol', 'Symbol is required').not().isEmpty(),
        check('decimals', 'Decimals is required')
            .not()
            .isEmpty()
            .isInt({ min: 1, max: 11 })
            .withMessage('Decimals must be between 1 and 11'),
        check('totalSupply', 'Total Supply is required')
            .not()
            .isEmpty()
            .isNumeric()
            .withMessage('Total Supply must be a number'),
        check('valueStaked', 'Value Staked is required')
            .not()
            .isEmpty()
            .isNumeric()
            .withMessage('Value Staked must be a number'),
        check('image', 'Image is required').not().isEmpty(),
    ],
    createNewBrand
)

module.exports = router

'''
'''--- backend/src/routes/api/notifications.ts ---
import { Router } from 'express'
import { validateToken } from '../../middlewares'
import { createNotification, fetchNotifications } from '../../controllers'
import { check } from 'express-validator'

const router = Router()

router.get('/', fetchNotifications)
router.post(
    '/new',
    validateToken,
    [
        check('title', 'Title is required').not().isEmpty(),
        check('image', 'Image is required').not().isEmpty(),
        check('content', 'Content is required').not().isEmpty(),
    ],
    createNotification
)

module.exports = router

'''
'''--- backend/src/routes/api/profile.ts ---
import { Router } from 'express'
import { validateToken } from '../../middlewares'
import {
    fetchTokens,
    updateProfile,
    fetchTransactions,
    sendTokens,
} from '../../controllers'
import { check } from 'express-validator'

const router = Router()

router.post('/update', validateToken, updateProfile)

router.post(
    '/tokens',
    validateToken,
    [check('username', 'Username is required').not().isEmpty()],
    fetchTokens
)
router.post(
    '/transactions',
    validateToken,
    [check('username', 'Username is required').not().isEmpty()],
    fetchTransactions
)

router.post(
    '/send',
    validateToken,
    [
        check('token', 'Token address is required').not().isEmpty(),
        check('receiver', 'Receiver address  is required').not().isEmpty(),
        check('amount')
            .not()
            .isEmpty()
            .withMessage('Amount is required')
            .isNumeric()
            .withMessage('Amount must be a number')
            //make sure amount is greater than 0
            .custom((value) => {
                if (parseFloat(value) <= 0) {
                    throw new Error('Amount must be greater than 0')
                }
                return true
            }),
    ],
    sendTokens
)

module.exports = router

'''
'''--- backend/src/routes/index.ts ---
import { Application } from 'express'

export const configureRoutes = (app: Application) => {
    app.use('/api/v1/auth', require('./api/auth'))
    app.use('/api/v1/profile', require('./api/profile'))
    app.use('/api/v1/brands', require('./api/brands'))
    app.use('/api/v1/notifications', require('./api/notifications'))

    // Health Check Endpoint
    app.use('/api/v1/status', (req, res) => {
        res.status(200).send(`Ok ${process.pid}`)
    })

    // Fallback Endpoint
    app.use('/', (req, res) => {
        res.status(200).send(`Ok ${process.pid}`)
    })
}

'''
'''--- backend/src/server.ts ---
import express from 'express'
import { createServer } from 'http'
import { config, connectDB } from './config'
import { configureRoutes } from './routes'
import { configureMiddleware } from './middlewares'
import cluster from 'cluster'
import { cpus } from 'os'

// Connect and get reference to db
let db: any
;(async () => {
    db = await connectDB()
})()

// Init express app
const app = express()

// Config Express middleware
configureMiddleware(app)

// Set-up routes
configureRoutes(app)

// Start server and listen for connections
const httpServer = createServer(app)

// Get number of CPUs
const numCPUs = cpus().length

if (cluster.isPrimary) {
    // Fork workers.
    for (let i = 0; i < numCPUs; i++) {
        // create a new worker process
        cluster.fork()
    }
    cluster.on('exit', (worker, code, signal) => {
        console.log(`worker ${worker.process.pid} died`)
        // fork a new worker process
        cluster.fork()
    })
} else {
    httpServer.listen(config.PORT || 5000, () => {
        console.info(
            `GEMA \`/api/v1/\` Server started on `,
            httpServer.address(),
            `PID ${process.pid}\n`
        )
    })
}

'''
'''--- backend/src/services/index.ts ---
export * from './wallet'

'''
'''--- backend/src/services/wallet/FungbileTokens.ts ---
import { BN } from 'bn.js'
import { Account, utils } from 'near-api-js'
import {
    functionCall,
    Transaction,
    Transfer,
} from 'near-api-js/lib/transaction'
import { config } from '../../config'
import { getTotalGasFee } from '../../helpers/gasPrice'
import { accountService } from './account'
import { walletService } from './wallet'
import { exec } from 'child_process'
import { readFileSync } from 'fs'
import { resolve } from 'path'

type Token = {
    name: string
    symbol: string
    decimals: number
    total_supply: string
}
class FungbileTokens {
    // view function (unsigned)
    viewFunctionAccount = accountService.createAccountBasic('dontcare')

    // Storage gas in bignumber
    storageDepositGas = new BN(config.STORAGE_GAS)

    transferGas = new BN(config.FT_TRANSFER_GAS)

    // Minimum deposit amount
    storageDepositAmount = new BN(config.FT_MINIMUM_STORAGE)

    /**
     *
     * @param account_id account id of the owner of the contract, which will also act as the contract storage
     * @param token token {name, symbol, decimals and total_supply}
     */
    public async createBrandAndToken(account_id: string, token: Token) {
        account_id = account_id.endsWith('.testnet')
            ? account_id.toLocaleLowerCase()
            : `${account_id.toLocaleLowerCase()}.testnet`
        // try {
        console.log('******'.repeat(15))
        console.log('\t INITIALIZING CREATE BRAND AND BRAND TOKEN')
        console.log('******'.repeat(15))

        // Create brand account
        console.log('\t ...... Creating brand account \n')
        let _acc = await accountService.createAccount(account_id)

        if (!_acc.success) {
            throw new Error(`${_acc?.error}` || 'Error creating brand account')
        }

        console.log('\t ...... Brand account created\n')

        // assign account_id and keys to variable
        let account_info = _acc.account

        // create connection to make S.C calls
        let conn = await walletService.callerAccount(
            _acc.account?.account_id!,
            _acc.account?.private_key
        )

        console.log(
            `\t ...... Deploying Token Contract to account -> ${account_info?.account_id!} \n`
        )

        // Deploy the token contract to the newly created account_id
        let deploy_contract = await conn.deployContract(
            readFileSync(resolve(__dirname, './token_contract.wasm'))
        )

        let deploy_contract_tx = deploy_contract.transaction_outcome.id

        console.log(
            `\t ...... Initializing Token [ ${account_id} ]. To account  \n`
        )

        // Format total supply to right amount
        let total_supply = (
            parseInt(token.total_supply) * Math.pow(10, token.decimals)
        ).toString()

        // Initialize a new token
        const create_token = await conn.functionCall({
            contractId: account_id,
            methodName: 'new',
            args: {
                owner_id: account_id,
                total_supply,
                metadata: {
                    spec: 'ft-1.0.0',
                    name: token.name,
                    symbol: token.symbol,
                    decimals: token.decimals,
                },
            },
            gas: this.storageDepositGas,
        })

        let token_contract_id = account_id

        const create_token_tx = create_token.transaction_outcome.id

        return {
            transactions: {
                deploy_contract_tx,
                create_token_tx,
            },
            account_info,
            token_contract_id,
        }
        // } catch (error: any) {
        //     throw new Error(error)
        //     // return {
        //     //     success: false,
        //     //     msg: 'ERROR CREATING BRAND AND TOKEN',
        //     //     error,
        //     // }
        // }
    }

    /**
     * GetTokenContracts
     *
     * @param account_id
     * @returns Return a list of all tokens contract_names in an specifc account
     */
    private async getTokenContracts(account_id: string) {
        return accountService.getAccountHoldingsList(account_id)
    }

    /**
     * GetStorageBalance
     *
     * @param contract_name name of contract e.g. `eth.fakes.testnet`
     * @param account_id
     * @returns Return an object depicting the total storage balance of a specific contract
     */
    private async getStorageBalance(contract_name: string, account_id: string) {
        return await accountService.getContractBalance(
            contract_name,
            'storage_balance_of',
            account_id
        )
    }

    /**
     * GetBalanceOf
     *
     * @param contract_name
     * @param account_id
     * @returns Returns the amoun of tokens available without decimal considerations
     */
    private async getBalanceOf(contract_name: string, account_id: string) {
        try {
            return await accountService.getContractBalance(
                contract_name,
                'ft_balance_of',
                account_id
            )
        } catch (error) {
            return {
                success: false,
                msg: `getBalanceOf error: => ${error}`,
            }
        }
    }

    /**
     *
     * @param contract_name
     * @returns The metadata of a specific token {decimals, name, symbol, spec}
     */
    private async getMetadata(contract_name: string) {
        try {
            return (await this.viewFunctionAccount)!.viewFunction(
                contract_name,
                'ft_metadata'
            )
        } catch (error) {
            return {
                success: false,
                msg: `getMetadata error: => ${error}`,
            }
        }
    }

    private async getEstimatedTotalFees(
        contract_name: string,
        account_id: string
    ) {
        try {
            if (
                contract_name &&
                account_id &&
                !(await this.isStorageAvailable(contract_name, account_id))
            ) {
                let totalGasFees = await getTotalGasFee(
                    new BN(config.FT_TRANSFER_GAS)
                        .add(new BN(config.STORAGE_GAS))
                        .toString()
                )
            } else {
                return getTotalGasFee(
                    contract_name ? config.FT_TRANSFER_GAS : '450000000000'
                )
            }
        } catch (error) {
            return {
                success: false,
                msg: `getMetadata error: => ${error}`,
            }
        }
    }

    /**
     *
     * @param contract_name
     * @param account_id
     * @returns Formated balance of all tokens
     */
    async formatTokenBalance(contract_name: string, account_id: string) {
        try {
            // Get token balance
            let _balance = await this.getBalanceOf(contract_name, account_id)

            // get token metadata
            let { symbol, decimals, name, icon } = await this.getMetadata(
                contract_name
            )

            let balance = parseInt(_balance) / Math.pow(10, decimals)

            return { balance, symbol, name, icon }
        } catch (error) {
            return {
                success: false,
                msg: `formartBalance error: => ${error}`,
            }
        }
    }

    private async formatTokenAmount(contract_name: string, amount: string) {
        let { decimals } = await this.getMetadata(contract_name)

        let balance = parseInt(amount) * Math.pow(10, decimals)

        return balance
    }

    /**
     *
     * @param contract_name
     * @param account_id
     * @returns Boolean of whether or not storage exists
     */
    public async isStorageAvailable(contract_name: string, account_id: string) {
        let _balance = await this.getStorageBalance(contract_name, account_id)

        return _balance?.total !== undefined
    }

    /**
     *
     * @param account_id current user id
     * @param contract_name contract_id on which transaction
     * @param receiver_id the account_id receiving the tokens
     * @param amount number of tokens to transfer
     * @returns [tx_hash, tx_status, from, to, method_name ]
     */
    async transfer(
        account_id: string,
        contract_name: string,
        receiver_id: string,
        amount: string,
        private_key?: string
    ) {
        // Get the account object of calling account
        let account

        if (private_key) {
            account = await walletService.callerAccount(
                account_id,
                private_key!
            )
        } else {
            account = await walletService.callerAccount(account_id)
        }

        let _amount = await this.formatTokenAmount(contract_name, amount)
        // let _amount = new BN(amount)

        // Pass storage gas as big number
        let gas = new BN(this.transferGas)

        // Pass exactly 1 yoctoNear for transfer
        let min_deposit_amount = 1
        let attachedDeposit = new BN(min_deposit_amount)

        // Check if the storage is available for the current account
        let storageAvailable = await this.isStorageAvailable(
            contract_name,
            receiver_id
        )

        // If storage is not available, deposit storage
        if (!storageAvailable) {
            await account.functionCall({
                contractId: contract_name,
                methodName: 'storage_deposit',
                args: {
                    account_id: receiver_id,
                    registration_only: true,
                },
                gas: this.storageDepositGas,
                attachedDeposit: this.storageDepositAmount,
            })
        }

        try {
            let _gasFee = await this.getEstimatedTotalFees(
                contract_name,
                account_id
            )

            let gasFee = utils.format.formatNearAmount(_gasFee!.toString())

            // Transfer Tokens
            let _transfer = await account.functionCall({
                contractId: contract_name,
                methodName: 'ft_transfer',
                args: {
                    receiver_id,
                    amount: _amount.toString(),
                },
                gas,
                attachedDeposit,
            })

            return {
                hash: _transfer.transaction_outcome.id,
                status: _transfer.transaction_outcome.outcome.status,
                from: _transfer.transaction.signer_id,
                to: receiver_id,
                method: 'TRANSFER_TOKENS',
                success: true,
                estimatedGasFeeInNear: gasFee,
            }
        } catch (error) {
            return {
                error: 'Transfer Tokens Error',
                message: error,
                success: false,
            }
        }
    }
}

export const fungibleTokens = new FungbileTokens()

'''
'''--- backend/src/services/wallet/account.ts ---
import axios from 'axios'
import BN from 'bn.js'
import {
    keyStores,
    connect,
    KeyPair,
    Connection,
    utils,
    Account,
    InMemorySigner,
} from 'near-api-js'
import { JsonRpcProvider } from 'near-api-js/lib/providers'
import { config } from '../../config'
import { walletService } from './wallet'

class AccountsService {
    keyStore: keyStores.InMemoryKeyStore
    keypair: KeyPair
    network: string
    minCreateBalance: string
    provideURL: string
    indexerServiceURL: string

    public constructor() {
        // Define the keystore without value
        this.keyStore = new keyStores.InMemoryKeyStore()

        // create secret and public key from a random ed25519 format
        this.keypair = KeyPair.fromRandom('ed25519')

        // Set newtork => mainnet / testnet / local
        this.network = config.network

        // Get min balance for create
        this.minCreateBalance = config.base_balance_for_create!

        this.provideURL = config.provider_url!
        this.indexerServiceURL = config.indexer_url!
    }

    /**
     * CREATE ACCOUNT
     *
     * @param account_id new unique account_id being createdd
     * @returns tx_hash, status, account_info and gas used
     */
    async createAccount(account_id: string) {
        try {
            account_id = account_id.endsWith('.testnet')
                ? account_id.toLocaleLowerCase()
                : `${account_id.toLocaleLowerCase()}.testnet`

            // get public and private keys from keypair
            let public_key = this.keypair.getPublicKey().toString()
            let private_key = this.keypair.toString()

            // add keys to inMemoryKeystore
            await this.keyStore.setKey(this.network, account_id, this.keypair)

            // Pass create account gas
            let gas = new BN('30000000000000')
            let gas_in_near = utils.format.formatNearAmount(gas.toString())

            // Get the minimum amount to pass when creating an account
            let min_create_amount = this.minCreateBalance
            let attachedDeposit = new BN(min_create_amount)

            // Check if account exists
            let account_exist = await walletService.checkAccountExist(
                account_id
            )

            // Return error if account already exists
            if (account_exist)
                return {
                    error: 'Account Id already exists. Try another one.',
                    success: false,
                }

            // get the creator account
            let creator_acc = await walletService.creatorAccount()

            // Call create_account method to create account
            let _account = await creator_acc.functionCall({
                contractId: this.network,
                methodName: 'create_account',
                args: {
                    new_account_id: account_id,
                    new_public_key: public_key,
                },
                gas,
                attachedDeposit,
            })

            return {
                hash: _account.transaction_outcome.id,
                status: _account.transaction_outcome.outcome.status,
                account: {
                    account_id,
                    public_key,
                    private_key,
                },
                gas: {
                    gas_attached: gas_in_near,
                    gas_used: utils.format.formatNearAmount(
                        `${_account.transaction_outcome.outcome.gas_burnt}`
                    ),
                },
                success: true,
            }
        } catch (error) {
            return {
                succcess: false,
                msg: `Near testnet create account error`,
                error,
            }
        }
    }

    public async createSubAccount(
        account_id: string,
        sub_account: string,
        private_key: string
    ) {
        let account = await walletService.callerAccount(account_id, private_key)

        // TODO: parseAsYoctoNear unit

        let initAmount = new BN(config.ft_minimum_storage_large)

        return await account.createAccount(
            sub_account,
            this.keypair.getPublicKey(),
            initAmount
        )
    }

    /**
     * INTERNAL FN -> _createConnection
     *
     * @returns connection object
     */
    private async _createConnection() {
        try {
            //Create a provider and a signer
            let signer = new InMemorySigner(this.keyStore)
            let provider = new JsonRpcProvider({
                url: this.provideURL,
            })

            return Connection.fromConfig({
                networkId: this.network,
                provider,
                signer,
            })
        } catch (error) {
            console.error(`createConnection ERROR: -> ${error}`)
        }
    }

    async getConnection() {
        return await this._createConnection()
    }

    /**
     * CREATE BASIC ACCOUNT
     *
     * @param account_id pass account_id to create a view or change account.
     *                  (for view account, use 'dontcare', for change account, use a valid accaount id)
     * @returns account object used to make view or change class
     */
    async createAccountBasic(account_id: string) {
        try {
            let connection = await this._createConnection()

            return new Account(connection!, account_id)
        } catch (error) {
            console.error(`createAccountBasic \n ERROR: -> ${error}`)
        }
    }

    /**
     * GET CONTRACT BALANCE
     *
     * @param contract_id contract you want to get balance of
     * @param method_name ['storage_balance_of' or 'ft_balance_of' or more]
     * @param account_id account id calling this
     * @returns  balance of a contract in yoctoNear
     */
    async getContractBalance(
        contract_id: string,
        method_name: string,
        account_id: string
    ) {
        // Use create basic to execute a  view function thus passing dontcare as a parameter
        return await (await this.createAccountBasic('dontcare'))!.viewFunction(
            contract_id,
            method_name,
            { account_id }
        )
    }

    /**
     * GET ACCOUNT HOLDINGS LIST
     *
     * Get all the tokens held in an account
     *
     * @param account_id -> the account_id of the account to get tokens from
     *                      e.g -> accountone.testnet
     * @returns a list of tokens in the account
     *          e.g -> ['contract.gematest.testnet','usdc.fakes.testnet','usdt.fakes.testnet']
     */
    async getAccountHoldingsList(account_id: string) {
        try {
            let url = `${this.indexerServiceURL}/account/${account_id}/likelyTokensFromBlock`

            let response = await axios({
                method: 'get',
                url,
            })

            return response.data['list']
        } catch (error) {
            return {
                error: 'getAccountHoldings error',
                msg: error,
                success: false,
            }
        }
    }

    /**
     * GET ACCOUNT TX
     *
     * Get all the transaction from an account
     *
     * @param account_id Account to get transactions for
     * @returns a transaction object
     *          - tx_hash : the transaction hash
     *          - timestamp : block timestamp of the transaction
     *          - from : the signer_id
     *          - to: the receivers account id
     *          - args: other info in the tx -> [gas, amount, method called, ]
     */
    async getAccountTransactions(account_id: string) {
        try {
            let url = `${this.indexerServiceURL}/account/${account_id}/activity`

            let response = await axios({
                method: 'get',
                url,
            })

            let transactions = response.data.map((tx: any) => {
                return {
                    hash: tx['hash'],
                    timestamp: tx['block_timestamp'],
                    from: tx['signer_id'],
                    to: tx['receiver_id'],
                    method_name: tx['args']['method_name'],
                    tx_type: tx['action_kind'],
                    args: tx['args'],
                }
            })

            return transactions
        } catch (error) {
            return {
                error: 'getAccountTransactions error',
                msg: error,
                success: false,
            }
        }
    }
}

export const accountService = new AccountsService()

'''
'''--- backend/src/services/wallet/index.ts ---
export * from './wallet'
export * from './FungbileTokens'
export * from './account'

'''
'''--- backend/src/services/wallet/wallet.ts ---
import BN from 'bn.js'
import {
    keyStores,
    connect,
    KeyPair,
    Connection,
    utils,
    ConnectConfig,
    Account,
} from 'near-api-js'
import { config } from '../../config'

class WalletService {
    keyPair: KeyPair
    keyStore: keyStores.InMemoryKeyStore
    connection: any
    config: ConnectConfig
    network: string
    fundingAcc: string

    constructor() {
        this.fundingAcc = config.funding_account_id!
        this.keyPair = KeyPair.fromString(config.funding_account_pk!)
        this.keyStore = new keyStores.InMemoryKeyStore()

        this.network = config.network

        this.keyStore.setKey(this.network, this.fundingAcc, this.keyPair)

        this.config = {
            networkId: this.network,
            keyStore: this.keyStore,
            nodeUrl: 'https://rpc.testnet.near.org',
            walletUrl: 'https://wallet.testnet.near.org',
            helperUrl: 'https://helper.testnet.near.org',
        }

        this.connection = connect(this.config)
    }

    async getConnection() {
        return this.connection
    }

    async creatorAccount() {
        const near = await connect({ ...this.config })
        return await near.account(this.fundingAcc)
    }

    /**
     * CallerAccount
     *
     * @param current_user_account account_id of the user
     * @param private_key optional parameter, passed when the caller account isnt the funding account
     * @returns current user account object
     */
    async callerAccount(current_user_account: string, private_key?: string) {
        let near = await connect({ ...this.config })

        // check if current_id is same as funding_account
        if (current_user_account != this.fundingAcc) {
            // Create keypair from the passed private_key
            this.keyPair = KeyPair.fromString(private_key!)

            // Reassign keystore with new key pair
            await this.keyStore.setKey(
                this.network,
                current_user_account,
                this.keyPair
            )

            return await near.account(current_user_account)
        }

        return await near.account(current_user_account)
    }

    /**
     * CHECK IF ACCOUNT EXISTS
     *
     * @param account_id
     * @returns boolean of whether account exists or not
     */
    async checkAccountExist(account_id: string) {
        let status

        const near = await connect({ ...this.config })

        const account = await near.account(account_id)

        await account
            .state()
            .then(() => (status = true))
            .catch(() => (status = false))

        return status
    }

    /**
     * GET ACCOUNT
     *
     * @param account_id
     * @returns A new instance of an account
     */
    async getAccount(account_id: string) {
        return new Account(this.connection, account_id)
    }
}

export const walletService = new WalletService()

'''
'''--- backend/src/types/IBrand.ts ---
import { IToken } from './IToken'

export interface IBrand {
    name: string
    token: IToken
    valueStaked: number
}

'''
'''--- backend/src/types/INotification.ts ---
export interface INotification {
    image: string
    title: string
    content: string
}

'''
'''--- backend/src/types/IToken.ts ---
export interface IToken {
    name: string
    symbol: string
    decimals: number
    address: string
    totalSupply: number
    image: string
}

'''
'''--- backend/src/types/IUser.ts ---
import { IWallet } from './IWallet'

export interface IUser {
    username: string
    email: string
    phone_number: string
    image: string | null
    password: string
    country: string
    city: string
    zip_code: string
    favorite: IUser[]
    wallet: IWallet
    preferred_lang: string
    reset_code?: string
    subscribed: boolean
}

'''
'''--- backend/src/types/IWallet.ts ---
import { WalletType } from '../constants'

export interface IWallet {
    public_key: string
    private_key: string
    wallet_type: WalletType
}

'''
'''--- backend/src/types/express/index.d.ts ---
import express from 'express';

declare global {
  namespace Express {
    interface Request {
      user?: Record<string, any>;
    }
  }
}

'''
'''--- backend/src/types/index.ts ---
export * from './IUser'
export * from './IWallet'
export * from './INotification'
export * from './IBrand'
export * from './IToken'

'''
'''--- backend/tsconfig.json ---
{
    "compilerOptions": {
        /* Visit https://aka.ms/tsconfig to read more about this file */

        /* Projects */
        // "incremental": true,                              /* Save .tsbuildinfo files to allow for incremental compilation of projects. */
        // "composite": true,                                /* Enable constraints that allow a TypeScript project to be used with project references. */
        // "tsBuildInfoFile": "./.tsbuildinfo",              /* Specify the path to .tsbuildinfo incremental compilation file. */
        // "disableSourceOfProjectReferenceRedirect": true,  /* Disable preferring source files instead of declaration files when referencing composite projects. */
        // "disableSolutionSearching": true,                 /* Opt a project out of multi-project reference checking when editing. */
        // "disableReferencedProjectLoad": true,             /* Reduce the number of projects loaded automatically by TypeScript. */

        /* Language and Environment */
        "target": "es2016" /* Set the JavaScript language version for emitted JavaScript and include compatible library declarations. */,
        // "lib": [],                                        /* Specify a set of bundled library declaration files that describe the target runtime environment. */
        // "jsx": "preserve",                                /* Specify what JSX code is generated. */
        // "experimentalDecorators": true,                   /* Enable experimental support for TC39 stage 2 draft decorators. */
        // "emitDecoratorMetadata": true,                    /* Emit design-type metadata for decorated declarations in source files. */
        // "jsxFactory": "",                                 /* Specify the JSX factory function used when targeting React JSX emit, e.g. 'React.createElement' or 'h'. */
        // "jsxFragmentFactory": "",                         /* Specify the JSX Fragment reference used for fragments when targeting React JSX emit e.g. 'React.Fragment' or 'Fragment'. */
        // "jsxImportSource": "",                            /* Specify module specifier used to import the JSX factory functions when using 'jsx: react-jsx*'. */
        // "reactNamespace": "",                             /* Specify the object invoked for 'createElement'. This only applies when targeting 'react' JSX emit. */
        // "noLib": true,                                    /* Disable including any library files, including the default lib.d.ts. */
        // "useDefineForClassFields": true,                  /* Emit ECMAScript-standard-compliant class fields. */
        // "moduleDetection": "auto",                        /* Control what method is used to detect module-format JS files. */

        /* Modules */
        "module": "commonjs" /* Specify what module code is generated. */,
        // "rootDir": "./",                                  /* Specify the root folder within your source files. */
        // "moduleResolution": "node",                       /* Specify how TypeScript looks up a file from a given module specifier. */
        // "baseUrl": "./",                                  /* Specify the base directory to resolve non-relative module names. */
        // "paths": {},                                      /* Specify a set of entries that re-map imports to additional lookup locations. */
        // "rootDirs": [],                                   /* Allow multiple folders to be treated as one when resolving modules. */
        "typeRoots": [
            "./node_modules/@types",
            "./src/types"
        ] /* Specify multiple folders that act like './node_modules/@types'. */,
        // "types": [],                                      /* Specify type package names to be included without being referenced in a source file. */
        // "allowUmdGlobalAccess": true,                     /* Allow accessing UMD globals from modules. */
        // "moduleSuffixes": [],                             /* List of file name suffixes to search when resolving a module. */
        // "resolveJsonModule": true,                        /* Enable importing .json files. */
        // "noResolve": true,                                /* Disallow 'import's, 'require's or '<reference>'s from expanding the number of files TypeScript should add to a project. */

        /* JavaScript Support */
        // "allowJs": true,                                  /* Allow JavaScript files to be a part of your program. Use the 'checkJS' option to get errors from these files. */
        // "checkJs": true,                                  /* Enable error reporting in type-checked JavaScript files. */
        // "maxNodeModuleJsDepth": 1,                        /* Specify the maximum folder depth used for checking JavaScript files from 'node_modules'. Only applicable with 'allowJs'. */

        /* Emit */
        // "declaration": true,                              /* Generate .d.ts files from TypeScript and JavaScript files in your project. */
        // "declarationMap": true,                           /* Create sourcemaps for d.ts files. */
        // "emitDeclarationOnly": true,                      /* Only output d.ts files and not JavaScript files. */
        // "sourceMap": true,                                /* Create source map files for emitted JavaScript files. */
        // "outFile": "./",                                  /* Specify a file that bundles all outputs into one JavaScript file. If 'declaration' is true, also designates a file that bundles all .d.ts output. */
        // "outDir": "./",                                   /* Specify an output folder for all emitted files. */
        // "removeComments": true,                           /* Disable emitting comments. */
        // "noEmit": true,                                   /* Disable emitting files from a compilation. */
        // "importHelpers": true,                            /* Allow importing helper functions from tslib once per project, instead of including them per-file. */
        // "importsNotUsedAsValues": "remove",               /* Specify emit/checking behavior for imports that are only used for types. */
        // "downlevelIteration": true,                       /* Emit more compliant, but verbose and less performant JavaScript for iteration. */
        // "sourceRoot": "",                                 /* Specify the root path for debuggers to find the reference source code. */
        // "mapRoot": "",                                    /* Specify the location where debugger should locate map files instead of generated locations. */
        // "inlineSourceMap": true,                          /* Include sourcemap files inside the emitted JavaScript. */
        // "inlineSources": true,                            /* Include source code in the sourcemaps inside the emitted JavaScript. */
        // "emitBOM": true,                                  /* Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files. */
        // "newLine": "crlf",                                /* Set the newline character for emitting files. */
        // "stripInternal": true,                            /* Disable emitting declarations that have '@internal' in their JSDoc comments. */
        // "noEmitHelpers": true,                            /* Disable generating custom helper functions like '__extends' in compiled output. */
        // "noEmitOnError": true,                            /* Disable emitting files if any type checking errors are reported. */
        // "preserveConstEnums": true,                       /* Disable erasing 'const enum' declarations in generated code. */
        // "declarationDir": "./",                           /* Specify the output directory for generated declaration files. */
        // "preserveValueImports": true,                     /* Preserve unused imported values in the JavaScript output that would otherwise be removed. */

        /* Interop Constraints */
        // "isolatedModules": true,                          /* Ensure that each file can be safely transpiled without relying on other imports. */
        // "allowSyntheticDefaultImports": true,             /* Allow 'import x from y' when a module doesn't have a default export. */
        "esModuleInterop": true /* Emit additional JavaScript to ease support for importing CommonJS modules. This enables 'allowSyntheticDefaultImports' for type compatibility. */,
        // "preserveSymlinks": true,                         /* Disable resolving symlinks to their realpath. This correlates to the same flag in node. */
        "forceConsistentCasingInFileNames": true /* Ensure that casing is correct in imports. */,

        /* Type Checking */
        "strict": true /* Enable all strict type-checking options. */,
        // "noImplicitAny": true,                            /* Enable error reporting for expressions and declarations with an implied 'any' type. */
        // "strictNullChecks": true,                         /* When type checking, take into account 'null' and 'undefined'. */
        // "strictFunctionTypes": true,                      /* When assigning functions, check to ensure parameters and the return values are subtype-compatible. */
        // "strictBindCallApply": true,                      /* Check that the arguments for 'bind', 'call', and 'apply' methods match the original function. */
        // "strictPropertyInitialization": true,             /* Check for class properties that are declared but not set in the constructor. */
        // "noImplicitThis": true,                           /* Enable error reporting when 'this' is given the type 'any'. */
        // "useUnknownInCatchVariables": true,               /* Default catch clause variables as 'unknown' instead of 'any'. */
        // "alwaysStrict": true,                             /* Ensure 'use strict' is always emitted. */
        // "noUnusedLocals": true,                           /* Enable error reporting when local variables aren't read. */
        // "noUnusedParameters": true,                       /* Raise an error when a function parameter isn't read. */
        // "exactOptionalPropertyTypes": true,               /* Interpret optional property types as written, rather than adding 'undefined'. */
        // "noImplicitReturns": true,                        /* Enable error reporting for codepaths that do not explicitly return in a function. */
        // "noFallthroughCasesInSwitch": true,               /* Enable error reporting for fallthrough cases in switch statements. */
        // "noUncheckedIndexedAccess": true,                 /* Add 'undefined' to a type when accessed using an index. */
        // "noImplicitOverride": true,                       /* Ensure overriding members in derived classes are marked with an override modifier. */
        // "noPropertyAccessFromIndexSignature": true,       /* Enforces using indexed accessors for keys declared using an indexed type. */
        // "allowUnusedLabels": true,                        /* Disable error reporting for unused labels. */
        // "allowUnreachableCode": true,                     /* Disable error reporting for unreachable code. */

        /* Completeness */
        // "skipDefaultLibCheck": true,                      /* Skip type checking .d.ts files that are included with TypeScript. */
        "skipLibCheck": true /* Skip type checking all .d.ts files. */
    }
}

'''
'''--- contracts/token_contract/Cargo.toml ---
[package]
name = "token_contract"
version = "1.0.0"
authors = ["Kimenyi Gichuru <ggichuru>"]
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0"
serde = "1"
serde_json = "1"
uint = { version = "0.9.3", default-features = false }

[profile.release]
codegen-units = 1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[workspace]
members = []

'''
'''--- contracts/token_contract/README.md ---
GEMA FUNGIBLE TOKENS
=================================

A [smart contract] written in [Rust] for an app initialized with [create-near-app]

Quick Start
===========

Before you compile this code, you will need to install Rust with [correct target]

Exploring The Code
==================

1. The main smart contract code lives in `src/lib.rs`.
2. There are two functions to the smart contract: `get_greeting` and `set_greeting`.
3. Tests: You can run smart contract tests with the `cargo test`.

  [smart contract]: https://docs.near.org/develop/welcome
  [Rust]: https://www.rust-lang.org/
  [create-near-app]: https://github.com/near/create-near-app
  [correct target]: https://docs.near.org/develop/prerequisites#rust-and-wasm
  [cargo]: https://doc.rust-lang.org/book/ch01-03-hello-cargo.html

'''
'''--- contracts/token_contract/neardev/dev-account.env ---
CONTRACT_NAME=dev-1661950821165-30150666171140
'''
'''--- contracts/token_contract/src/events.rs ---
//! This is the standard for nep-141 events
//!
//! The events will be picked up by the NEAR indexer
//!
//! [`FtMint`], [`FtTransfer`], [`FtBurn`]

use near_sdk::json_types::U128;
use near_sdk::serde::Serialize;
use near_sdk::AccountId;

use near_sdk::env;

#[derive(Serialize, Debug)]
#[serde(tag = "standard")]
#[must_use = "don't forget to `.emit()` this event"]
#[serde(rename_all = "snake_case")]

pub(crate) enum NearEvent<'a> {
    Nep141(Nep141Event<'a>),
}

impl<'a> NearEvent<'a> {
    fn to_json_string(&self) -> String {
        // Events cannot fail to serialize so fine to panic on error
        #[allow(clippy::redundant_closure)]
        serde_json::to_string(self)
            .ok()
            .unwrap_or_else(|| env::abort())
    }

    fn to_json_event_string(&self) -> String {
        format!("EVENT_JSON:{}", self.to_json_string())
    }

    /// Logs the event to the host.
    /// Ensures that the event is triggered and to consume the event.
    pub(crate) fn emit(self) {
        near_sdk::env::log_str(&self.to_json_event_string())
    }
}

/// Data to log for an FT min event.
/// To log this event, call [`.emit()`](FtMint::emit)
#[must_use]
#[derive(Serialize, Debug, Clone)]
pub struct FtMint<'a> {
    pub owner_id: &'a AccountId,
    pub amount: &'a U128,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub memo: Option<&'a str>,
}

impl FtMint<'_> {
    /// log the event to the host
    /// Required to ensure that the event is triggered and to cosume the event
    pub fn emit(self) {
        Self::emit_many(&[self])
    }

    /// Emit an FT mint event. Each [`FtMint`] represents the data of each mint
    pub fn emit_many(data: &[FtMint<'_>]) {
        new_141_v1(Nep141EventKind::FtMint(data)).emit()
    }
}

/// Data to log for a FT transfer event.
/// call `.emit()`(FtTransfer::event) to log
#[must_use]
#[derive(Serialize, Debug, Clone)]
pub struct FtTransfer<'a> {
    pub old_owner_id: &'a AccountId,
    pub new_owner_id: &'a AccountId,
    pub amount: &'a U128,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub memo: Option<&'a str>,
}

impl FtTransfer<'_> {
    /// Logs the event to the host.
    /// Ensures that the event is triggered and to consume the event
    pub fn emit(self) {
        Self::emit_many(&[self])
    }

    /// Emits an Ft transfer event
    /// Each FtTransfer represents the data of each transfer
    pub fn emit_many(data: &[FtTransfer<'_>]) {
        new_141_v1(Nep141EventKind::FtTransfer(data)).emit()
    }
}

#[derive(Serialize, Debug)]
pub(crate) struct Nep141Event<'a> {
    version: &'static str,

    #[serde(flatten)]
    event_kind: Nep141EventKind<'a>,
}

#[derive(Serialize, Debug)]
#[serde(tag = "event", content = "data")]
#[serde(rename_all = "snake_case")]
#[allow(clippy::enum_variant_names)]
enum Nep141EventKind<'a> {
    FtMint(&'a [FtMint<'a>]),
    FtTransfer(&'a [FtTransfer<'a>]),
}

fn new_141<'a>(version: &'static str, event_kind: Nep141EventKind<'a>) -> NearEvent<'a> {
    NearEvent::Nep141(Nep141Event {
        version,
        event_kind,
    })
}

fn new_141_v1(event_kind: Nep141EventKind) -> NearEvent {
    new_141("1.0.0", event_kind)
}

'''
'''--- contracts/token_contract/src/ft_core.rs ---
use near_sdk::{assert_one_yocto, ext_contract, Gas, PromiseOrValue, PromiseResult};

use crate::*;

const GAS_FOR_RESOLVE_TRANSFER: Gas = Gas(5_000_000_000_000);
const GAS_FOR_FT_TRANSFER_CALL: Gas = Gas(25_000_000_000_000);

#[ext_contract(ext_ft_core)]
pub trait FungibleTokenCore {
    fn ft_transfer(&mut self, receiver_id: AccountId, amount: U128, memo: Option<String>);

    fn ft_transfer_call(
        &mut self,
        receiver_id: AccountId,
        amount: U128,
        memo: Option<String>,
        msg: String,
    ) -> PromiseOrValue<U128>;

    fn ft_total_supply(&self) -> U128;

    fn ft_balance_of(&self, account_id: AccountId) -> U128;
}

#[near_bindgen]
impl FungibleTokenCore for Contract {
    #[payable]
    fn ft_transfer(&mut self, receiver_id: AccountId, amount: U128, memo: Option<String>) {
        // Assert that user attached exactly 1 yoctoNEAR
        assert_one_yocto();

        // sender - user who called the method
        let sender_id = env::predecessor_account_id();

        // How many tokens the user wants to transfer
        let amount: Balance = amount.into();

        // Trnansfer the tokens
        self.internal_transfer(&sender_id, &receiver_id, amount, memo);
    }

    #[payable]
    fn ft_transfer_call(
        &mut self,
        receiver_id: AccountId,
        amount: U128,
        memo: Option<String>,
        msg: String,
    ) -> PromiseOrValue<U128> {
        // Assert that user attached exactly 1 yoctoNEAR
        assert_one_yocto();

        let sender_id = env::predecessor_account_id();

        let amount: Balance = amount.into();

        self.internal_transfer(&sender_id, &receiver_id, amount, memo);

        // initiating receiver's call and callback
        // Defaulting Gas weight to 1, no attached deposit and Static GAS equal to the GAS for ft transfer call
        ext_ft_receiver::ext(receiver_id.clone())
            .with_static_gas(GAS_FOR_FT_TRANSFER_CALL)
            .ft_on_transfer(sender_id.clone(), amount.into(), msg)
            // We then resolve the promise and call ft_resolve_transfer on our own contract
            .then(
                Self::ext(env::current_account_id())
                    .with_static_gas(GAS_FOR_RESOLVE_TRANSFER)
                    .ft_resolve_transfer(&sender_id, receiver_id, amount.into()),
            )
            .into()
    }

    fn ft_total_supply(&self) -> U128 {
        // Return the total supplu casted to a U128
        self.total_supply.into()
    }

    fn ft_balance_of(&self, account_id: AccountId) -> U128 {
        // Return the balance of the account casted to U128
        self.accounts.get(&account_id).unwrap_or(0).into()
    }
}

#[ext_contract(ext_ft_receiver)]
pub trait FungibleTokenReciever {
    fn ft_on_transfer(
        &mut self,
        sender_id: AccountId,
        amount: U128,
        msg: String,
    ) -> PromiseOrValue<U128>;
}

#[near_bindgen]
impl Contract {
    #[private]
    pub fn ft_resolve_transfer(
        &mut self,
        sender_id: &AccountId,
        receiver_id: AccountId,
        amount: U128,
    ) -> U128 {
        let amount: Balance = amount.into();

        // Get the unused amount from the `ft_on_transfer` call result.
        let unused_amount = match env::promise_result(0) {
            PromiseResult::NotReady => env::abort(),

            // If promise was successful, get the return value and cast it to U128
            PromiseResult::Successful(value) => {
                // if we can properly parse the value, the unused amount is equal to whatever is smaller (unused / original amount)
                // else, if we can't properly pass the value, the original amount is returned

                if let Ok(unused_amount) = near_sdk::serde_json::from_slice::<U128>(&value) {
                    std::cmp::min(amount, unused_amount.0)
                } else {
                    amount
                }
            }

            // If promise wasn't successful, return the original amount
            PromiseResult::Failed => amount,
        };

        // if there is some unused amount, we should refund the sender
        if unused_amount > 0 {
            //Get receiver's balance. We can only refund sender if receiver has enough balance
            let receiver_balance = self.accounts.get(&receiver_id).unwrap_or(0);

            if receiver_balance > 0 {
                // The amnt to refund is the smaller b2 used amnt and receivers bal as we can only refund upto what the receiver currently has
                let refund_amount = std::cmp::min(receiver_balance, unused_amount);

                // Refund the sender for the unused amount
                self.internal_transfer(
                    &receiver_id,
                    &sender_id,
                    refund_amount,
                    Some("Refund".to_string()),
                );

                // Return what was actually used
                let unused_amount = amount
                    .checked_sub(refund_amount)
                    .unwrap_or_else(|| env::panic_str("Total supply overflow"));

                return unused_amount.into();
            }
        }

        // if the unused amount is 0, return the original amount.
        amount.into()
    }
}

'''
'''--- contracts/token_contract/src/internal.rs ---
//! Internal Contract Methods
//!

use near_sdk::require;

use crate::*;

impl Contract {
    /// Internal method to force getting the balance of an account
    /// If account has no bal, panic with message
    pub(crate) fn internal_unwrap_balance_of(&self, account_id: &AccountId) -> Balance {
        match self.accounts.get(account_id) {
            Some(balance) => balance,
            None => {
                env::panic_str(format!("The Account {} is not registered", &account_id).as_str())
            }
        }
    }

    /// Internal method for depositing some amount of FT into a/c
    pub(crate) fn internal_deposit(&mut self, account_id: &AccountId, amount: Balance) {
        // Get the current balance of the account. If not registered, panic.
        let balance = self.internal_unwrap_balance_of(account_id);

        // add the amount to the balanace and insert the new balance into the account
        if let Some(new_balance) = balance.checked_add(amount) {
            self.accounts.insert(account_id, &new_balance);
        } else {
            env::panic_str("Balance overflow");
        }
    }

    /// internal method for withdrawing some amount of FTs from account
    pub(crate) fn internal_withdraw(&mut self, account_id: &AccountId, amount: Balance) {
        // Get the current balance of the account. If not registered panic
        let balance = self.internal_unwrap_balance_of(account_id);

        // Decrease amount from the balance and insert new balance into the account
        if let Some(new_balance) = balance.checked_sub(amount) {
            self.accounts.insert(account_id, &new_balance);
        } else {
            env::panic_str("The Account doesnt have enough balance");
        }
    }

    /// Internal method for performing a transfer of FTs from one account
    ///  to another
    pub(crate) fn internal_transfer(
        &mut self,
        sender_id: &AccountId,
        receiver_id: &AccountId,
        amount: Balance,
        memo: Option<String>,
    ) {
        // Ensure the sender can't transfer to themselves
        require!(
            sender_id != receiver_id,
            "Sender and receiver should be different"
        );

        // Ensure the send can't transfer 0 tokens
        require!(amount > 0, "Amount should be greater than O");

        // Withdraw from the sender and deposit into the receiver
        self.internal_withdraw(sender_id, amount);
        self.internal_deposit(receiver_id, amount);

        // Emit a transfer event
        FtTransfer {
            old_owner_id: sender_id,
            new_owner_id: receiver_id,
            amount: &U128(amount),
            memo: memo.as_deref(),
        }
        .emit();
    }

    /// internal method for registering an account with the contract
    pub(crate) fn internal_register_account(&mut self, account_id: &AccountId) {
        if self.accounts.insert(account_id, &0).is_some() {
            env::panic_str("Account already registered");
        }
    }

    ///
    ///                 INTIALIZATION FUNCTION
    ///
    ///  Intenal method for measuring how many bytes it takes to insert the longest
    ///  possible account ID into our map
    ///  This will insert the account, measure the storage and remove the account.
    pub(crate) fn measure_bytes_for_longest_account_id(&mut self) {
        let initial_storage_usage = env::storage_usage();
        let tmp_account_id = AccountId::new_unchecked("a".repeat(64));
        self.accounts.insert(&tmp_account_id, &0u128);
        self.bytes_for_longest_account_id = env::storage_usage() - initial_storage_usage;
        self.accounts.remove(&tmp_account_id);
    }
}

'''
'''--- contracts/token_contract/src/lib.rs ---
//! GEMA Token contract entrypoint
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LazyOption, LookupMap};
use near_sdk::json_types::U128;
use near_sdk::{env, near_bindgen, AccountId, Balance, PanicOnDefault, StorageUsage};

pub mod events;
pub mod ft_core;
pub mod internal;
pub mod metadata;
pub mod storage;

use crate::events::*;
use crate::metadata::*;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    /// Keep track of each account's balances
    pub accounts: LookupMap<AccountId, Balance>,

    /// Total Supply of all tokens
    pub total_supply: Balance,

    /// The bytes for the larges possible account ID that can be registered
    pub bytes_for_longest_account_id: StorageUsage,

    /// Metadata
    pub metadata: LazyOption<FungibleTokenMetadata>,
}

/// Helper structure for keys of persistent collection
#[derive(BorshSerialize)]
pub enum StorageKey {
    Accounts,
    Metadata,
}

#[near_bindgen]
impl Contract {
    /// Initializes the contract with the given total supply owned by the given onwer id with given ft metadata
    #[init]
    pub fn new(owner_id: AccountId, total_supply: U128, metadata: FungibleTokenMetadata) -> Self {
        // Create a variable of type Self with all fields initialized
        let mut this = Self {
            total_supply: total_supply.0,
            bytes_for_longest_account_id: 0,
            accounts: LookupMap::new(StorageKey::Accounts.try_to_vec().unwrap()),
            metadata: LazyOption::new(StorageKey::Metadata.try_to_vec().unwrap(), Some(&metadata)),
        };

        // Measure the bytes for the longest accountID and store it in the contract
        this.measure_bytes_for_longest_account_id();

        // register the owner's account and set their bal ot the the total supply
        this.internal_register_account(&owner_id);
        this.internal_deposit(&owner_id, total_supply.into());

        // Emit an event showing that the FTs were minted
        FtMint {
            owner_id: &owner_id,
            amount: &total_supply,
            memo: Some("Initial token supply is minted"),
        }
        .emit();

        this
    }
}

'''
'''--- contracts/token_contract/src/metadata.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::Base64VecU8;
use near_sdk::near_bindgen;
use near_sdk::serde::{Deserialize, Serialize};

use crate::*;

#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct FungibleTokenMetadata {
    pub spec: String, // should be ft-1.0.0 to indicate that a ft contract adhere to the current metadata version
    pub name: String, // human readable name of token
    pub symbol: String, // EG WETH, SUDA
    pub icon: Option<String>,
    pub reference: Option<String>, // link to a valid JSON file containing various keys offering supplementary details on the token
    pub reference_hash: Option<Base64VecU8>, // base64-encoded sha256 hash of the JSON file containeed in the reference field.
    pub decimals: u8,
}

pub trait FungibleTokenMetadataProvider {
    // View call for returning the contract metadata
    fn ft_metadata(&self) -> FungibleTokenMetadata;
}

#[near_bindgen]
impl FungibleTokenMetadataProvider for Contract {
    fn ft_metadata(&self) -> FungibleTokenMetadata {
        self.metadata.get().unwrap()
    }
}

'''
'''--- contracts/token_contract/src/storage.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::U128;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{env, log, AccountId, Balance, Promise};

use crate::*;

// The structure that will be returned for the methods:
// * `storage_deposit`
// * `storage_withdraw`
// * `storage_balance_of`

///
/// `total` and `available`
/// values are string representations of U128 showing the balance of a specific account in yoctoNEAR
///
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct StorageBalance {
    pub total: U128,
    pub available: U128,
}

///
/// returned for the method `storage_balance_bounds`
///
/// `min` -> amount of tokes required to start using this contract
///
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct StorageBalanceBounds {
    pub min: U128,
    pub max: Option<U128>,
}

pub trait StorageManagement {
    ///
    /// CHANGE METHODS ON FT
    ///

    // Returns the Storage balance stucture showing updated balance
    fn storage_deposit(
        &mut self,
        account_id: Option<AccountId>,
        registration_only: Option<bool>,
    ) -> StorageBalance;

    ///
    ///  VIEW METHODS
    ///

    // Returns min and max allowed balance amount to intereact with this contract.
    fn storage_balance_bounds(&self) -> StorageBalanceBounds;

    // Returns minimum and max allowed balance amounts to interact with contract
    fn storage_balance_of(&self, account_id: AccountId) -> Option<StorageBalance>;
}

#[near_bindgen]
impl StorageManagement for Contract {
    #[allow(unused_variables)]
    #[payable]
    fn storage_deposit(
        &mut self,
        account_id: Option<AccountId>,
        registration_only: Option<bool>,
    ) -> StorageBalance {
        // Get the amount of NEAR to deposit
        let amount: Balance = env::attached_deposit();

        // If an account was specified, use that, otherwise, use predecessor account
        let account_id = account_id.unwrap_or_else(env::predecessor_account_id);

        //if account already registered, refund the deposit
        if self.accounts.contains_key(&account_id) {
            log!("A/C already registered");
            if amount > 0 {
                Promise::new(env::predecessor_account_id()).transfer(amount);
            }
            //Register the account and refund excess near
        } else {
            // Get the minimum required storage and ensure the deposit is atleast that amount
            let min_balance = self.storage_balance_bounds().min.0;

            if amount < min_balance {
                env::panic_str("The attached deposit is less than min req deposit");
            }

            // Register the account
            self.internal_register_account(&account_id);

            // Perform a refund
            let refund = amount - min_balance;
            if refund > 0 {
                Promise::new(env::predecessor_account_id()).transfer(refund);
            }
        }

        // Return the storage balance of the account
        StorageBalance {
            total: self.storage_balance_bounds().min,
            available: 0.into(),
        }
    }

    fn storage_balance_bounds(&self) -> StorageBalanceBounds {
        // Calculate the required storage balance by taking the bytes
        let required_storage_balance =
            Balance::from(self.bytes_for_longest_account_id) * env::storage_byte_cost();

        // Storage balance bounds will have min == max == required_storage_balance
        StorageBalanceBounds {
            min: required_storage_balance.into(),
            max: Some(required_storage_balance.into()),
        }
    }

    fn storage_balance_of(&self, account_id: AccountId) -> Option<StorageBalance> {
        // Get the storage balance of the account
        if self.accounts.contains_key(&account_id) {
            Some(StorageBalance {
                total: self.storage_balance_bounds().min,
                available: 0.into(),
            })
        } else {
            None
        }
    }
}

'''
'''--- integration-tests/Cargo.toml ---
[package]
name = "integration-tests"
version = "1.0.0"
publish = false
edition = "2018"

[dev-dependencies]
anyhow = "1.0"
borsh = "0.9"
maplit = "1.0"
near-units = "0.2.0"
# arbitrary_precision enabled for u128 types that workspaces requires for Balance types
serde_json = { version = "1.0", features = ["arbitrary_precision"] }
tokio = { version = "1.18.1", features = ["full"] }
tracing = "0.1"
tracing-subscriber = { version = "0.3.11", features = ["env-filter"] }
workspaces = "0.4.0"
pkg-config = "0.3.1"

[[example]]
name = "integration-tests"
path = "src/tests.rs"

'''
'''--- integration-tests/src/tests.rs ---
use std::{env, fs};
use near_units::parse_near;
use serde_json::json;
use workspaces::prelude::*;
use workspaces::{network::Sandbox, Account, Contract, Worker};

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let wasm_arg: &str = &(env::args().nth(1).unwrap());
    let wasm_filepath = fs::canonicalize(env::current_dir()?.join(wasm_arg))?;

    let worker = workspaces::sandbox().await?;
    let wasm = std::fs::read(wasm_filepath)?;
    let contract = worker.dev_deploy(&wasm).await?;

    // create accounts
    let account = worker.dev_create_account().await?;
    let alice = account
        .create_subaccount(&worker, "alice")
        .initial_balance(parse_near!("30 N"))
        .transact()
        .await?
        .into_result()?;

    // begin tests
    test_default_message(&alice, &contract, &worker).await?;
    test_changes_message(&alice, &contract, &worker).await?;
    Ok(())
}

async fn test_default_message(
    user: &Account,
    contract: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    let message: String = user
        .call(&worker, contract.id(), "get_greeting")
        .args_json(json!({}))?
        .transact()
        .await?
        .json()?;

    assert_eq!(message, "Hello".to_string());
    println!("      Passed ✅ gets default message");
    Ok(())
}

async fn test_changes_message(
    user: &Account,
    contract: &Contract,
    worker: &Worker<Sandbox>,
) -> anyhow::Result<()> {
    user.call(&worker, contract.id(), "set_greeting")
        .args_json(json!({"message": "Howdy"}))?
        .transact()
        .await?;

    let message: String = user
        .call(&worker, contract.id(), "get_greeting")
        .args_json(json!({}))?
        .transact()
        .await?
        .json()?;

    assert_eq!(message, "Howdy".to_string());
    println!("      Passed ✅ changes message");
    Ok(())
}
'''
'''--- package.json ---
{
  "name": "gema_project",
  "version": "1.0.0",
  "private": true,
  "license": "(MIT AND Apache-2.0)",
  "scripts": {
    "deps-install": "yarn",
    "s:deploy": "yarn workspace scripts deploy",
    "s:initialize": "yarn workspace scripts initialize",
    "s:mint": "yarn workspace scripts mint",
    "server": "yarn workspace backend start",
    "test": "yarn workspace backend test"
  },
  "devDependencies": {
    "near-cli": "^3.3.0"
  },
  "workspaces": {
    "packages": [
      "backend",
      "scripts"
    ],
    "nohoist": [
      "backend/*",
      "scripts/*"
    ]
  }
}
'''
'''--- scripts/TODO.md ---
# FUNGIBLE-TOKENS SCRIPTS

## [ ] Creating a fungible token

- Deploying a fungible toke and initializing it.
- metadata to define on initialization
  - Name
  - Symbol
  - Total Supply
- You also define owner who will own tokens total supply.

**1. Deploy the contract**

    near dev-deploy --wasmFile fungible_token.wasm

**2. Initialize the token with metadata** 

    near call <ft-contract> new '{"owner_id": "<owner-account>", "total_supply": "1000000000000000", "metadata": { "spec": "ft-1.0.0", "name": "Example Token Name", "symbol": "EXLT", "decimals": 8 }}' --accountId <ft-contract>

-----

## [ ] Register a user (to own and transfer tokens)
Done to allow user own and transfer tokens. You call `storage_deposit` and attach `0.00125Ⓝ`
        
    near call <ft-contract> storage_deposit '{"account_id": "<account-to-register>"}' --accountId <your-account> --amount 0.00125

    

-----

## [ ] Get Balance
Know how many coins a user has by using `balance_of`

    near view <ft-contract> ft_balance_of '{"account_id": "<users-account>"}'

`Keep in mind the decimals from the metadata. A balance of 150 FT for a token with 2 decimals actually represents 1.50 FT.`

-----

## [ ] Transferring
use `ft_transfer` method, indicating the receiver and the amount of the FT to send.

    near call <ft-contract> ft_transfer '{"receiver_id": "<receiver-account>", "amount": "<amount>"}' --accountId <your-account> --depositYocto 1

`Both sender and receiver must be registered in the FT contract`

-----

## [ ] Querying metadata
Querying the fungible tokens metadata

    near view <ft-contrac> ft_metadata

-----

## [ ] Minting
Mint fungible tokens and view them in your wallet
-----

'''
'''--- scripts/deploy.ts ---
import { exec } from "child_process";

const deploy = (account_id: string) => {
  exec(
    `near deploy --accountId ${account_id} --wasmFile ../contracts/token_contract/target/wasm32-unknown-unknown/release/token_contract.wasm`,
    (error, stdout, stderr) => {
      if (error) {
        console.log(`error: ${error.message}`);
        return;
      }

      if (stderr) {
        console.log(`stderr: ${stderr}`);
      }

      console.log("-----".repeat(20));
      console.log("Deploying token contract");
      console.log("------".repeat(20));
      console.log(`stdout: ${stdout} \n \n`);
    }
  );
};

const account_id = "token.wazitofc.testnet";

deploy(account_id);

'''
'''--- scripts/neardev/dev-account.env ---
CONTRACT_NAME=dev-1662330977898-63257472570474
'''
'''--- scripts/package.json ---
{
  "name": "scripts",
  "version": "1.0.0",
  "main": "src/index.ts",
  "license": "MIT",
  "private": true,
  "dependencies": {
    "child_process": "^1.0.2",
    "ts-node": "^10.9.1",
    "ts-node-dev": "^2.0.0",
    "typescript": "^4.8.2"
  },
  "scripts": {
    "deploy1": "npm run build:contract && cd ../contracts/token_contract && near dev-deploy --wasmFile ./target/wasm32-unknown-unknown/release/hello_near.wasm",
    "build:contract": "cd ../contracts/token_contract && rustup target add wasm32-unknown-unknown && cargo build --all --target wasm32-unknown-unknown --release",
    "build": "npm run build:contract",
    "test": "npm run test:unit && npm run test:integration",
    "test:unit": "cd contracts/token_contract && cargo test",
    "test:integration": "npm run build:contract && cd integration-tests && cargo run --example integration-tests \"../contracts/token_contract/target/wasm32-unknown-unknown/release/hello_near.wasm\"",
    "deploy": "ts-node deploy.ts",
    "initialize": "ts-node src/initialize.ts",
    "mint": "ts-node src/mint.ts"
  }
}
'''
'''--- scripts/src/initialize.ts ---
import { exec } from "child_process";

const deploy = (
  contract: string,
  owner_id: string,
  total_supply: string,
  token_name: string,
  token_symbol: string,
  token_decimals: number
) => {
  exec(
    `near call ${contract} new '{"owner_id":"${owner_id}", "total_supply": "${total_supply}", "metadata": {"spec": "ft-1.0.0", "name": "${token_name}", "symbol": "${token_symbol}", "decimals": ${token_decimals}}}' --accountId ${contract}`,
    (error, stdout, stderr) => {
      if (error) {
        console.log(`error: ${error.message}`);
        return;
      }

      if (stderr) {
        console.log(`stderr: ${stderr}`);
      }

      console.log("-----".repeat(20));
      console.log("Deploying token contract");
      console.log("------".repeat(20));
      console.log(`stdout: ${stdout} \n \n`);
    }
  );
};

const contract = "token.wazitofc.testnet";
const owner_id = "wazitofc.testnet";
const total_supply = "1000000000000000";
const token_name = "WAZI TOKEN";
const token_symbol = "WZ1";
const token_decimals = 8;

deploy(
  contract,
  owner_id,
  total_supply,
  token_name,
  token_symbol,
  token_decimals
);

'''
'''--- scripts/src/mint.ts ---
import { exec } from "child_process";

const deploy = (account_id: string, receiver_id: string, amount: string) => {
  exec(
    `near call ${account_id} ft_mint '{"receiver_id": "${receiver_id}", "amount": "${amount}"}' --deposit 0.1 --accountId ${receiver_id}`,
    (error, stdout, stderr) => {
      if (error) {
        console.log(`error: ${error.message}`);
        return;
      }

      if (stderr) {
        console.log(`stderr: ${stderr}`);
      }

      console.log("-----".repeat(20));
      console.log(`minting ${amount} to ${receiver_id}`);
      console.log("------".repeat(20));
      console.log(`stdout: ${stdout} \n \n`);
    }
  );
};

const account_id = "test-1.gematest.testnet";
const receiver_id = "gematest.testnet";
const amount = "1000";

deploy(account_id, receiver_id, amount);

'''
'''--- scripts/tsconfig.json ---
{
  "compilerOptions": {
    /* Visit https://aka.ms/tsconfig to read more about this file */

    /* Projects */
    // "incremental": true,                              /* Save .tsbuildinfo files to allow for incremental compilation of projects. */
    // "composite": true,                                /* Enable constraints that allow a TypeScript project to be used with project references. */
    // "tsBuildInfoFile": "./.tsbuildinfo",              /* Specify the path to .tsbuildinfo incremental compilation file. */
    // "disableSourceOfProjectReferenceRedirect": true,  /* Disable preferring source files instead of declaration files when referencing composite projects. */
    // "disableSolutionSearching": true,                 /* Opt a project out of multi-project reference checking when editing. */
    // "disableReferencedProjectLoad": true,             /* Reduce the number of projects loaded automatically by TypeScript. */

    /* Language and Environment */
    "target": "es2016",                                  /* Set the JavaScript language version for emitted JavaScript and include compatible library declarations. */
    // "lib": [],                                        /* Specify a set of bundled library declaration files that describe the target runtime environment. */
    // "jsx": "preserve",                                /* Specify what JSX code is generated. */
    // "experimentalDecorators": true,                   /* Enable experimental support for TC39 stage 2 draft decorators. */
    // "emitDecoratorMetadata": true,                    /* Emit design-type metadata for decorated declarations in source files. */
    // "jsxFactory": "",                                 /* Specify the JSX factory function used when targeting React JSX emit, e.g. 'React.createElement' or 'h'. */
    // "jsxFragmentFactory": "",                         /* Specify the JSX Fragment reference used for fragments when targeting React JSX emit e.g. 'React.Fragment' or 'Fragment'. */
    // "jsxImportSource": "",                            /* Specify module specifier used to import the JSX factory functions when using 'jsx: react-jsx*'. */
    // "reactNamespace": "",                             /* Specify the object invoked for 'createElement'. This only applies when targeting 'react' JSX emit. */
    // "noLib": true,                                    /* Disable including any library files, including the default lib.d.ts. */
    // "useDefineForClassFields": true,                  /* Emit ECMAScript-standard-compliant class fields. */
    // "moduleDetection": "auto",                        /* Control what method is used to detect module-format JS files. */

    /* Modules */
    "module": "commonjs",                                /* Specify what module code is generated. */
    // "rootDir": "./",                                  /* Specify the root folder within your source files. */
    // "moduleResolution": "node",                       /* Specify how TypeScript looks up a file from a given module specifier. */
    // "baseUrl": "./",                                  /* Specify the base directory to resolve non-relative module names. */
    // "paths": {},                                      /* Specify a set of entries that re-map imports to additional lookup locations. */
    // "rootDirs": [],                                   /* Allow multiple folders to be treated as one when resolving modules. */
    // "typeRoots": [],                                  /* Specify multiple folders that act like './node_modules/@types'. */
    // "types": [],                                      /* Specify type package names to be included without being referenced in a source file. */
    // "allowUmdGlobalAccess": true,                     /* Allow accessing UMD globals from modules. */
    // "moduleSuffixes": [],                             /* List of file name suffixes to search when resolving a module. */
    // "resolveJsonModule": true,                        /* Enable importing .json files. */
    // "noResolve": true,                                /* Disallow 'import's, 'require's or '<reference>'s from expanding the number of files TypeScript should add to a project. */

    /* JavaScript Support */
    // "allowJs": true,                                  /* Allow JavaScript files to be a part of your program. Use the 'checkJS' option to get errors from these files. */
    // "checkJs": true,                                  /* Enable error reporting in type-checked JavaScript files. */
    // "maxNodeModuleJsDepth": 1,                        /* Specify the maximum folder depth used for checking JavaScript files from 'node_modules'. Only applicable with 'allowJs'. */

    /* Emit */
    // "declaration": true,                              /* Generate .d.ts files from TypeScript and JavaScript files in your project. */
    // "declarationMap": true,                           /* Create sourcemaps for d.ts files. */
    // "emitDeclarationOnly": true,                      /* Only output d.ts files and not JavaScript files. */
    // "sourceMap": true,                                /* Create source map files for emitted JavaScript files. */
    // "outFile": "./",                                  /* Specify a file that bundles all outputs into one JavaScript file. If 'declaration' is true, also designates a file that bundles all .d.ts output. */
    // "outDir": "./",                                   /* Specify an output folder for all emitted files. */
    // "removeComments": true,                           /* Disable emitting comments. */
    // "noEmit": true,                                   /* Disable emitting files from a compilation. */
    // "importHelpers": true,                            /* Allow importing helper functions from tslib once per project, instead of including them per-file. */
    // "importsNotUsedAsValues": "remove",               /* Specify emit/checking behavior for imports that are only used for types. */
    // "downlevelIteration": true,                       /* Emit more compliant, but verbose and less performant JavaScript for iteration. */
    // "sourceRoot": "",                                 /* Specify the root path for debuggers to find the reference source code. */
    // "mapRoot": "",                                    /* Specify the location where debugger should locate map files instead of generated locations. */
    // "inlineSourceMap": true,                          /* Include sourcemap files inside the emitted JavaScript. */
    // "inlineSources": true,                            /* Include source code in the sourcemaps inside the emitted JavaScript. */
    // "emitBOM": true,                                  /* Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files. */
    // "newLine": "crlf",                                /* Set the newline character for emitting files. */
    // "stripInternal": true,                            /* Disable emitting declarations that have '@internal' in their JSDoc comments. */
    // "noEmitHelpers": true,                            /* Disable generating custom helper functions like '__extends' in compiled output. */
    // "noEmitOnError": true,                            /* Disable emitting files if any type checking errors are reported. */
    // "preserveConstEnums": true,                       /* Disable erasing 'const enum' declarations in generated code. */
    // "declarationDir": "./",                           /* Specify the output directory for generated declaration files. */
    // "preserveValueImports": true,                     /* Preserve unused imported values in the JavaScript output that would otherwise be removed. */

    /* Interop Constraints */
    // "isolatedModules": true,                          /* Ensure that each file can be safely transpiled without relying on other imports. */
    // "allowSyntheticDefaultImports": true,             /* Allow 'import x from y' when a module doesn't have a default export. */
    "esModuleInterop": true,                             /* Emit additional JavaScript to ease support for importing CommonJS modules. This enables 'allowSyntheticDefaultImports' for type compatibility. */
    // "preserveSymlinks": true,                         /* Disable resolving symlinks to their realpath. This correlates to the same flag in node. */
    "forceConsistentCasingInFileNames": true,            /* Ensure that casing is correct in imports. */

    /* Type Checking */
    "strict": true,                                      /* Enable all strict type-checking options. */
    // "noImplicitAny": true,                            /* Enable error reporting for expressions and declarations with an implied 'any' type. */
    // "strictNullChecks": true,                         /* When type checking, take into account 'null' and 'undefined'. */
    // "strictFunctionTypes": true,                      /* When assigning functions, check to ensure parameters and the return values are subtype-compatible. */
    // "strictBindCallApply": true,                      /* Check that the arguments for 'bind', 'call', and 'apply' methods match the original function. */
    // "strictPropertyInitialization": true,             /* Check for class properties that are declared but not set in the constructor. */
    // "noImplicitThis": true,                           /* Enable error reporting when 'this' is given the type 'any'. */
    // "useUnknownInCatchVariables": true,               /* Default catch clause variables as 'unknown' instead of 'any'. */
    // "alwaysStrict": true,                             /* Ensure 'use strict' is always emitted. */
    // "noUnusedLocals": true,                           /* Enable error reporting when local variables aren't read. */
    // "noUnusedParameters": true,                       /* Raise an error when a function parameter isn't read. */
    // "exactOptionalPropertyTypes": true,               /* Interpret optional property types as written, rather than adding 'undefined'. */
    // "noImplicitReturns": true,                        /* Enable error reporting for codepaths that do not explicitly return in a function. */
    // "noFallthroughCasesInSwitch": true,               /* Enable error reporting for fallthrough cases in switch statements. */
    // "noUncheckedIndexedAccess": true,                 /* Add 'undefined' to a type when accessed using an index. */
    // "noImplicitOverride": true,                       /* Ensure overriding members in derived classes are marked with an override modifier. */
    // "noPropertyAccessFromIndexSignature": true,       /* Enforces using indexed accessors for keys declared using an indexed type. */
    // "allowUnusedLabels": true,                        /* Disable error reporting for unused labels. */
    // "allowUnreachableCode": true,                     /* Disable error reporting for unreachable code. */

    /* Completeness */
    // "skipDefaultLibCheck": true,                      /* Skip type checking .d.ts files that are included with TypeScript. */
    "skipLibCheck": true                                 /* Skip type checking all .d.ts files. */
  }
}

'''