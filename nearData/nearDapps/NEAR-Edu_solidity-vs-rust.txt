*GitHub Repository "NEAR-Edu/solidity-vs-rust"*

'''--- README.md ---
# Solidity vs. Rust Smart Contract Comparison

# Dependencies

- Rust 1.56
- Node.js 14
- NEAR CLI 3.1

# Authors

- Jacob Lindahl <jacob@near.foundation> [@sudo_build](https://twitter.com/sudo_build)

'''
'''--- rust/Cargo.toml ---
[package]
name = "solidity-vs-rust"
version = "0.1.0"
edition = "2021"
authors = ["Jacob Lindahl <jacob@near.foundation>"]

[dependencies]
near-sdk = "4.0.0-pre.7"
near-contract-standards = "4.0.0-pre.7"

[lib]
crate-type = ["cdylib"]

[profile.release]
codegen-units = 1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- rust/build.sh ---
#!/usr/bin/env bash

cargo build --target wasm32-unknown-unknown --release

'''
'''--- rust/deploy.sh ---
#!/usr/bin/env bash

WASM_PATH="$(find ./target/wasm32-unknown-unknown/release/ -maxdepth 1 -name "*.wasm")"

near deploy \
  --wasmFile $WASM_PATH \
  --accountId "$1" \
  --initFunction new \
  --initArgs "$(node ./init-args.js)"

'''
'''--- rust/dev-deploy.sh ---
#!/usr/bin/env bash

WASM_PATH="$(find ./target/wasm32-unknown-unknown/release/ -maxdepth 1 -name "*.wasm")"

near dev-deploy \
  --wasmFile $WASM_PATH \
  "$@"

near call "$(<./neardev/dev-account)" new "$(node ./init-args.js)" \
  --accountId "$(<./neardev/dev-account)"

'''
'''--- rust/init-args.js ---
const ONE_DAY = 1_000_000_000 * 60 * 60 * 24;

// 1e24, calculated like this because JS numbers don't work that large
const ONE_NEAR = BigInt(1e12) ** 2n;

console.log(JSON.stringify({}));

'''
'''--- rust/src/contract.rs ---
use near_contract_standards::non_fungible_token::metadata::TokenMetadata;
use near_contract_standards::non_fungible_token::{NonFungibleToken, Token, TokenId};
use near_contract_standards::{
    impl_non_fungible_token_approval, impl_non_fungible_token_core,
    impl_non_fungible_token_enumeration,
};

use crate::*;

#[derive(BorshStorageKey, BorshSerialize)]
enum StorageKey {
    NonFungibleToken,
    TokenMetadata,
    TokenEnumeration,
    TokenApproval,
}

#[near_bindgen]
#[derive(PanicOnDefault, BorshDeserialize, BorshSerialize)]
pub struct Contract {
    pub tokens: NonFungibleToken,
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new() -> Self {
        Self {
            tokens: NonFungibleToken::new(
                StorageKey::NonFungibleToken,
                "hatchet.testnet".parse().unwrap(),
                Some(StorageKey::TokenMetadata),
                Some(StorageKey::TokenEnumeration),
                Some(StorageKey::TokenApproval),
            ),
        }
    }

    pub fn mint(&mut self, token_id: TokenId) {
        self.tokens.internal_mint(
            token_id,
            env::predecessor_account_id(),
            Some(TokenMetadata {
                title: Some("My special nft token".to_string()), // ex. "Arch Nemesis: Mail Carrier" or "Parcel #5055"
                description: None,                               // free-form description
                media: None, // URL to associated media, preferably to decentralized, content-addressed storage
                media_hash: None, // Base64-encoded sha256 hash of content referenced by the `media` field. Required if `media` is included.
                copies: None, // number of copies of this set of metadata in existence when token was minted.
                issued_at: None, // ISO 8601 datetime when token was issued or minted
                expires_at: None, // ISO 8601 datetime when token expires
                starts_at: None, // ISO 8601 datetime when token starts being valid
                updated_at: None, // ISO 8601 datetime when token was last updated
                extra: None, // anything extra the NFT wants to store on-chain. Can be stringified JSON.
                reference: None, // URL to an off-chain JSON file with more info.
                reference_hash: None, // Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included.
            }),
        );
    }
}

impl_non_fungible_token_core!(Contract, tokens);
impl_non_fungible_token_enumeration!(Contract, tokens);
impl_non_fungible_token_approval!(Contract, tokens);

'''
'''--- rust/src/lib.rs ---
use near_sdk::{
    borsh::{self, *},
    *,
};

mod contract;
pub use contract::*;

#[cfg(test)]
mod tests {
    #[test]
    fn test() {}
}

'''