*GitHub Repository "near/near-ledger-app"*

'''--- README.md ---
# REPO MOVED

New Location: https://github.com/near/app-near

'''
'''--- build.sh ---
#!/usr/bin/env bash
docker build --rm -f Dockerfile -t ledger-sdk .

'''
'''--- install_compiler.sh ---
#!/bin/bash

DEST=/opt/bolos

mkdir -p ${DEST}
cd ${DEST}

wget -q https://launchpad.net/gcc-arm-embedded/5.0/5-2016-q1-update/+download/gcc-arm-none-eabi-5_3-2016q1-20160330-linux.tar.bz2
wget -q http://releases.llvm.org/7.0.0/clang+llvm-7.0.0-x86_64-linux-gnu-ubuntu-16.04.tar.xz

tar xfj gcc-arm-none-eabi-5_3-2016q1-20160330-linux.tar.bz2
tar xfv clang+llvm-7.0.0-x86_64-linux-gnu-ubuntu-16.04.tar.xz

mv clang+llvm-7.0.0-x86_64-linux-gnu-ubuntu-16.04 clang-arm-fropi
chmod 757 -R clang-arm-fropi/
chmod +x clang-arm-fropi/bin/clang

ln -s ${DEST}/gcc-arm-none-eabi-5_3-2016q1/bin/arm-none-eabi-gcc /usr/bin/arm-none-eabi-gcc
ln -s ${DEST}/clang-arm-fropi/bin/clang /usr/bin/clang

# Avoid high UID/GID that affect CircleCI
chown root:root /opt/bolos -R

echo "export BOLOS_ENV=/opt/bolos" >> ~/.bashrc
'''
'''--- run.sh ---
#!/bin/sh
docker run -v "$(pwd)"/workdir:/workdir -it ledger-sdk /bin/bash

'''
'''--- workdir/near-ledger-app/.vscode/c_cpp_properties.json ---
{
    "configurations": [
        {
            "name": "Mac",
            "includePath": [
                "${workspaceFolder}/**",
                "${workspaceFolder}/../nanos-secure-sdk/include"
            ],
            "defines": [
                "OS_IO_SEPROXYHAL",
                "IO_SEPROXYHAL_BUFFER_SIZE_B=128",
                "HAVE_BAGL",
                "HAVE_SPRINTF"
            ],
            "macFrameworkPath": [
                "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.14.sdk/System/Library/Frameworks"
            ],
            "compilerPath": "/usr/bin/clang",
            "cStandard": "c11",
            "cppStandard": "c++17",
            "intelliSenseMode": "clang-x64"
        }
    ],
    "version": 4
}
'''
'''--- workdir/near-ledger-app/HACKING.md ---
# Gotchas

## Speculos emulator can be useful, but for now fakes keys

## Beware of unaligned RAM access

```
        uint16_t *ptr16 = &tmp_ctx.signing_context.buffer[processed]; 
        PRINTF("uint16_t: %d", ptr16[0]);
```

`ptr16[0]` is crashing, even though `tmp_ctx.signing_context.buffer[processed]` (`unsigned char*`) can be accessed alright.

## PIC hackery

See https://ledger.readthedocs.io/en/latest/userspace/memory.html#pic-and-model-implications

'''
'''--- workdir/near-ledger-app/README.md ---
# near-ledger-app

NEAR wallet application for Ledger Nano S

# Introduction

This is a Ledger Nano S wallet app for NEAR platform.

Thanks to Waves Platform for their [Ledger app](https://github.com/LedgerHQ/ledger-app-waves) serving as a base for this project.

Special thanks to Jean Passot and Oto from the Ledger team, Jake Bordens from the Ledger/Birst community for their support and advices.

# Building

You'll need a Ledger Nano S development environment.  More information can be 
found here: https://github.com/wavesplatform/nanos-app-waves/wiki

Note that it's good idea to use Docker config from this repository instead.

'''
'''--- workdir/near-ledger-app/src/crypto/base58.c ---
/**
 * Copyright (c) 2012-2014 Luke Dashjr
 * Copyright (c) 2013-2014 Pavol Rusnak
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES
 * OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#include <string.h>
#include <stdbool.h>
#include <sys/types.h>
#include "base58.h"

static const char b58digits_ordered[] = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";

bool b58enc(char *b58, size_t *b58sz, const void *data, size_t binsz)
{
	const uint8_t *bin = data;
	int carry;
	ssize_t i, j, high, zcount = 0;
	size_t size;

	while (zcount < (ssize_t)binsz && !bin[zcount])
		++zcount;

	size = (binsz - zcount) * 138 / 100 + 1;
	uint8_t buf[size];
	memset(buf, 0, size);

	for (i = zcount, high = size - 1; i < (ssize_t)binsz; ++i, high = j)
	{
		for (carry = bin[i], j = size - 1; (j > high) || carry; --j)
		{
			carry += 256 * buf[j];
			buf[j] = carry % 58;
			carry /= 58;
		}
	}

	for (j = 0; j < (ssize_t)size && !buf[j]; ++j);

	if (*b58sz <= zcount + size - j)
	{
		*b58sz = zcount + size - j + 1;
		return false;
	}

	if (zcount)
		memset(b58, '1', zcount);
	for (i = zcount; j < (ssize_t)size; ++i, ++j)
		b58[i] = b58digits_ordered[buf[j]];
	b58[i] = '\0';
	*b58sz = i + 1;

	return true;
}
'''
'''--- workdir/near-ledger-app/src/crypto/base58.h ---
/**
 * Copyright (c) 2013-2014 Tomas Dzetkulic
 * Copyright (c) 2013-2014 Pavol Rusnak
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES
 * OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef __BASE58_H__
#define __BASE58_H__

#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>

bool b58enc(char *b58, size_t *b58sz, const void *data, size_t binsz);

#endif

'''
'''--- workdir/near-ledger-app/src/crypto/ledger_crypto.c ---
#include "ledger_crypto.h"

#include "os.h"
#include "cx.h"

// converts little endian 65 byte (0x4 32X 32Y) public key to 32 byte Y big endian form (for other applications)
void public_key_le_to_be(cx_ecfp_public_key_t* public_key) {
    uint8_t public_key_be[32];
    // copy public key little endian to big endian
    for (uint8_t i = 0; i < 32; i++) {
        public_key_be[i] = public_key->W[64 - i];
    }
    // set sign bit
    if ((public_key->W[32] & 1) != 0) {
        public_key_be[31] |= 0x80;
    }
    os_memset(public_key->W, 0, 65);
    os_memmove(public_key->W, public_key_be, 32);
}

void get_keypair_by_path(const uint32_t* path, cx_ecfp_public_key_t* public_key, cx_ecfp_private_key_t* private_key) {
    unsigned char privateKeyData[32];
    os_perso_derive_node_bip32_seed_key(HDW_ED25519_SLIP10, CX_CURVE_Ed25519, path, 5, privateKeyData, NULL, (unsigned char*) "ed25519 seed", 12);
    cx_ecdsa_init_private_key(CX_CURVE_Ed25519, privateKeyData, 32, private_key);
    cx_ecdsa_init_public_key(CX_CURVE_Ed25519, NULL, 0, public_key);
    cx_ecfp_generate_pair(CX_CURVE_Ed25519, public_key, private_key, 1);
}

// Get a public key from the 44'/397' keypath.
bool get_ed25519_public_key_for_path(const uint32_t* path, cx_ecfp_public_key_t* public_key) {
    cx_ecfp_private_key_t private_key;
    // derive the ed25519 keys by that BIP32 path from the device
    get_keypair_by_path(path, public_key, &private_key);
    // clean private key
    os_memset(private_key.d, 0, 32);

    public_key_le_to_be(public_key);
    // TODO: Should there be error sometimes?
    return true;
}

void blake2b_256(const unsigned char* msg, size_t msg_len, void* out)
{
    cx_blake2b_t ctx;
    // size in bits
    cx_blake2b_init(&ctx, 256);
    cx_hash(&ctx.header, 0, (void *)msg, msg_len, NULL, 0);
    // size in bytes
    cx_hash(&ctx.header, CX_LAST, NULL, 0, out, 32);
}

void keccak_256(const unsigned char* msg, size_t msg_len, void* out)
{
    cx_sha3_t ctx;
    // size in bits
    cx_keccak_init(&ctx, 256);
    cx_hash(&ctx.header, 0, (void *)msg, msg_len, NULL, 0);
    // size in bytes
    cx_hash(&ctx.header, CX_LAST, NULL, 0, out, 32);
}

void sha_256(const unsigned char* msg, size_t msg_len, void* out)
{
    cx_sha256_t ctx;
    // size in bits
    cx_sha256_init(&ctx);
    cx_hash(&ctx.header, 0, (void *)msg, msg_len, NULL, 0);
    // size in bytes
    cx_hash(&ctx.header, CX_LAST, NULL, 0, out, 32);
}
'''
'''--- workdir/near-ledger-app/src/crypto/ledger_crypto.h ---
#ifndef __LEDGER_CRYPTO_H__
#define __LEDGER_CRYPTO_H__

#include "os.h"
#include <stdbool.h>

void public_key_le_to_be(cx_ecfp_public_key_t* public_key);
void get_keypair_by_path(const uint32_t* path, cx_ecfp_public_key_t* public_key, cx_ecfp_private_key_t* private_key);
bool get_ed25519_public_key_for_path(const uint32_t* path, cx_ecfp_public_key_t* public_key);
void blake2b_256(const unsigned char* msg, size_t msg_len, void* out);
void keccak_256(const unsigned char* msg, size_t msg_len, void* out);
void sha_256(const unsigned char* msg, size_t msg_len, void* out);

#endif
'''
'''--- workdir/near-ledger-app/src/crypto/near.c ---
#include "near.h"
#include "ledger_crypto.h"

void near_message_sign(const cx_ecfp_private_key_t *private_key, const ed25519_public_key public_key, const unsigned char *message, const size_t message_size, ed25519_signature signature) {
    uint8_t hash[32]; 
    sha_256(message, message_size, hash);
    cx_eddsa_sign(private_key, 0, CX_SHA512, hash, sizeof(hash), NULL, 0, signature, 64, NULL);
}
'''
'''--- workdir/near-ledger-app/src/crypto/near.h ---
#ifndef __WAVES_H__
#define __WAVES_H__

#include <stdint.h>
#include <stdbool.h>

#include "base58.h"
#include "os.h"
#include "cx.h"

typedef unsigned char ed25519_signature[64];
typedef unsigned char ed25519_public_key[32];
typedef unsigned char ed25519_secret_key[32];

void near_message_sign(const cx_ecfp_private_key_t *private_key, const ed25519_public_key public_key,
    const unsigned char *message, const size_t message_size, ed25519_signature signature);

#endif

'''
'''--- workdir/near-ledger-app/src/glyphs.c ---
#include "glyphs.h"
unsigned int const C_badge_transaction_colors[] = {
  0x00cccccc,
  0x00d8d8d8,
  0x00e9e9e9,
  0x00f9f9f9,
};

unsigned char const C_badge_transaction_bitmap[] = {
  0xff, 0xff, 0xff, 0xff, 0xbf, 0x15, 0x40, 0xe5, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0x6f, 0x00, 0x00, 0x00, 0x90, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1b, 0x00, 0x00, 0x00,
  0x00, 0x40, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0x00, 0xa4, 0xff, 0xaf, 0x01, 0x40, 0xff,
  0xff, 0xff, 0xff, 0xff, 0x2f, 0x00, 0xf9, 0xff, 0xff, 0xff, 0x06, 0x80, 0xff, 0xff, 0xff, 0xff,
  0x7f, 0x00, 0xf9, 0xff, 0xff, 0xff, 0xff, 0x06, 0xd0, 0xff, 0xff, 0xff, 0xff, 0x01, 0xf9, 0xff,
  0xff, 0xff, 0xff, 0xff, 0x06, 0xf4, 0xff, 0xff, 0xff, 0x07, 0xf4, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0x01, 0xfd, 0xff, 0xff, 0x1f, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbf, 0x40, 0xff,
  0xff, 0x7f, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x2f, 0xd0, 0xff, 0xff, 0x02, 0xfe,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0b, 0xf8, 0xff, 0x0f, 0xf4, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0x01, 0xff, 0x7f, 0xd0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0x7f, 0xd0, 0xff, 0x02, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0b, 0xf8, 0x1f,
  0xf4, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x41, 0xff, 0x80, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x2f, 0xf0, 0x0b, 0xfd, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0x07, 0x7e, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe7, 0xff, 0xff, 0xbf,
  0xd0, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0xf8, 0xff, 0xff, 0x0f, 0x2c, 0xf4, 0xff,
  0xff, 0xaa, 0xaa, 0xaa, 0xaa, 0x06, 0xfe, 0xff, 0xff, 0x81, 0x81, 0xff, 0xff, 0x0f, 0x00, 0x00,
  0x00, 0x00, 0x80, 0xff, 0xff, 0x2f, 0x14, 0xf8, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf4,
  0xff, 0xff, 0x42, 0xc1, 0xff, 0xff, 0x5f, 0x55, 0x55, 0x55, 0x15, 0xd0, 0xff, 0xff, 0x3f, 0x04,
  0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x47, 0xff, 0xff, 0xff, 0x03, 0xc0, 0xff, 0xff, 0xff,
  0xef, 0xff, 0xff, 0x7f, 0xfd, 0xff, 0xff, 0x3f, 0x00, 0xfc, 0xff, 0xff, 0x7f, 0xfd, 0xff, 0xff,
  0xfb, 0xff, 0xff, 0xff, 0x03, 0xc0, 0xff, 0xff, 0xff, 0xd1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0x3f, 0x10, 0xfc, 0xff, 0xff, 0x07, 0x54, 0x55, 0x55, 0x55, 0xf5, 0xff, 0xff, 0x43, 0x81, 0xff,
  0xff, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x2f, 0x14, 0xf8, 0xff, 0xff, 0x02, 0x00,
  0x00, 0x00, 0x00, 0xf0, 0xff, 0xff, 0x42, 0x42, 0xff, 0xff, 0xbf, 0x90, 0xaa, 0xaa, 0xaa, 0xaa,
  0xff, 0xff, 0x1f, 0x38, 0xf0, 0xff, 0xff, 0x2f, 0xfd, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0,
  0x07, 0xfe, 0xff, 0xff, 0xdb, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0b, 0xbd, 0xd0, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0xe0, 0x0f, 0xf8, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0x02, 0xff, 0x41, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0x1f, 0xf4, 0x2f, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbf, 0x80, 0xff, 0x07,
  0xfd, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x07, 0xfd, 0xff, 0x40, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0xf0, 0xff, 0x2f, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xbf, 0x80, 0xff, 0xff, 0x07, 0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x02, 0xfd,
  0xff, 0xff, 0x01, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0b, 0xf4, 0xff, 0xff, 0x7f, 0x40,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0xd0, 0xff, 0xff, 0xff, 0x1f, 0x90, 0xff, 0xff, 0xff,
  0xff, 0xff, 0x6f, 0x40, 0xff, 0xff, 0xff, 0xff, 0x07, 0x90, 0xff, 0xff, 0xff, 0xff, 0x6f, 0x00,
  0xfd, 0xff, 0xff, 0xff, 0xff, 0x02, 0x90, 0xff, 0xff, 0xff, 0x6f, 0x00, 0xf8, 0xff, 0xff, 0xff,
  0xff, 0xff, 0x01, 0x40, 0xfa, 0xff, 0x1a, 0x00, 0xf4, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbf, 0x01,
  0x00, 0x00, 0x00, 0x00, 0xe4, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x06, 0x00, 0x00, 0x00,
  0xf9, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x5b, 0x01, 0x54, 0xfe, 0xff, 0xff, 0xff,
  0xff,
};
#ifdef OS_IO_SEPROXYHAL
        #include "os_io_seproxyhal.h"
        const bagl_icon_details_t C_badge_transaction = { GLYPH_badge_transaction_WIDTH, GLYPH_badge_transaction_HEIGHT, 2, C_badge_transaction_colors, C_badge_transaction_bitmap };
        #endif // OS_IO_SEPROXYHAL
#include "glyphs.h"
unsigned int const C_icon_back_colors[] = {
  0x00000000,
  0x00ffffff,
};

unsigned char const C_icon_back_bitmap[] = {
  0xe0, 0x01, 0xfe, 0xc1, 0xfd, 0x38, 0x7f, 0x06, 0xdf, 0x81, 0xff, 0xc4, 0x7f, 0xf3, 0xff, 0xbc,
  0x1f, 0xe7, 0xe7, 0xf1, 0x3f, 0xf8, 0x07, 0x78, 0x00,
};
#ifdef OS_IO_SEPROXYHAL
        #include "os_io_seproxyhal.h"
        const bagl_icon_details_t C_icon_back = { GLYPH_icon_back_WIDTH, GLYPH_icon_back_HEIGHT, 1, C_icon_back_colors, C_icon_back_bitmap };
        #endif // OS_IO_SEPROXYHAL
#include "glyphs.h"
unsigned int const C_icon_dashboard_colors[] = {
  0x00000000,
  0x00ffffff,
};

unsigned char const C_icon_dashboard_bitmap[] = {
  0xe0, 0x01, 0xfe, 0xc1, 0xff, 0x38, 0x70, 0x06, 0xd8, 0x79, 0x7e, 0x9e, 0x9f, 0xe7, 0xe7, 0xb9,
  0x01, 0xe6, 0xc0, 0xf1, 0x3f, 0xf8, 0x07, 0x78, 0x00,
};
#ifdef OS_IO_SEPROXYHAL
        #include "os_io_seproxyhal.h"
        const bagl_icon_details_t C_icon_dashboard = { GLYPH_icon_dashboard_WIDTH, GLYPH_icon_dashboard_HEIGHT, 1, C_icon_dashboard_colors, C_icon_dashboard_bitmap };
        #endif // OS_IO_SEPROXYHAL
#include "glyphs.h"
unsigned int const C_icon_near_colors[] = {
  0x00000000,
  0x00ffffff,
};

unsigned char const C_icon_near_bitmap[] = {
  0xff, 0xff, 0xff, 0xff, 0xf3, 0xcf, 0xe3, 0xc7, 0xc3, 0xc3, 0x83, 0xcf, 0x13, 0xcf, 0x33, 0xce,
  0x73, 0xcc, 0xf3, 0xc8, 0xf3, 0xc1, 0xc3, 0xc3, 0xe3, 0xc7, 0xf3, 0xcf, 0xff, 0xff, 0xff, 0xff,
};
#ifdef OS_IO_SEPROXYHAL
        #include "os_io_seproxyhal.h"
        const bagl_icon_details_t C_icon_near = { GLYPH_icon_near_WIDTH, GLYPH_icon_near_HEIGHT, 1, C_icon_near_colors, C_icon_near_bitmap };
        #endif // OS_IO_SEPROXYHAL

'''
'''--- workdir/near-ledger-app/src/glyphs.h ---
#ifndef GLYPH_badge_transaction_BPP
        #define GLYPH_badge_transaction_WIDTH 50
        #define GLYPH_badge_transaction_HEIGHT 50
        #define GLYPH_badge_transaction_BPP 2
extern unsigned int const C_badge_transaction_colors[];
extern unsigned char const C_badge_transaction_bitmap[];
#ifdef OS_IO_SEPROXYHAL
        #include "os_io_seproxyhal.h"
        extern const bagl_icon_details_t C_badge_transaction;
        #endif // GLYPH_badge_transaction_BPP
        #endif // OS_IO_SEPROXYHAL
#ifndef GLYPH_icon_back_BPP
        #define GLYPH_icon_back_WIDTH 14
        #define GLYPH_icon_back_HEIGHT 14
        #define GLYPH_icon_back_BPP 1
extern unsigned int const C_icon_back_colors[];
extern unsigned char const C_icon_back_bitmap[];
#ifdef OS_IO_SEPROXYHAL
        #include "os_io_seproxyhal.h"
        extern const bagl_icon_details_t C_icon_back;
        #endif // GLYPH_icon_back_BPP
        #endif // OS_IO_SEPROXYHAL
#ifndef GLYPH_icon_dashboard_BPP
        #define GLYPH_icon_dashboard_WIDTH 14
        #define GLYPH_icon_dashboard_HEIGHT 14
        #define GLYPH_icon_dashboard_BPP 1
extern unsigned int const C_icon_dashboard_colors[];
extern unsigned char const C_icon_dashboard_bitmap[];
#ifdef OS_IO_SEPROXYHAL
        #include "os_io_seproxyhal.h"
        extern const bagl_icon_details_t C_icon_dashboard;
        #endif // GLYPH_icon_dashboard_BPP
        #endif // OS_IO_SEPROXYHAL
#ifndef GLYPH_icon_near_BPP
        #define GLYPH_icon_near_WIDTH 16
        #define GLYPH_icon_near_HEIGHT 16
        #define GLYPH_icon_near_BPP 1
extern unsigned int const C_icon_near_colors[];
extern unsigned char const C_icon_near_bitmap[];
#ifdef OS_IO_SEPROXYHAL
        #include "os_io_seproxyhal.h"
        extern const bagl_icon_details_t C_icon_near;
        #endif // GLYPH_icon_near_BPP
        #endif // OS_IO_SEPROXYHAL

'''
'''--- workdir/near-ledger-app/src/main.c ---
/*******************************************************************************
*   Waves platform Wallet App for Nano Ledger S. Updated By Waves community.
*   Copyright (c) 2017-2018 Sergey Tolmachev (Tolsi) <tolsi.ru@gmail.com>
* 
*   Based on Sample code provided and (c) 2016 Ledger and 2017-2018 Jake B. (Burstcoin)
*
*  Licensed under the Apache License, Version 2.0 (the "License");
*  you may not use this file except in compliance with the License.
*  You may obtain a copy of the License at
*
*      http://www.apache.org/licenses/LICENSE-2.0
*
*  Unless required by applicable law or agreed to in writing, software
*  distributed under the License is distributed on an "AS IS" BASIS,
*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*  See the License for the specific language governing permissions and
*  limitations under the License.
********************************************************************************/

#include <stdbool.h>

#include "main.h"
#include "crypto/ledger_crypto.h"
#include "os_io_seproxyhal.h"

// Ledger Stuff
#include "ui/ui.h"
#include "os.h"
#include "cx.h"
#include "os_io_seproxyhal.h"

// Temporary area to sore stuff and reuse the same memory
tmpContext_t tmp_ctx;
uiContext_t ui_context;

// Non-volatile storage for the wallet app's stuff
WIDE internal_storage_t N_storage_real;

// SPI Buffer for io_event
unsigned char G_io_seproxyhal_spi_buffer[IO_SEPROXYHAL_BUFFER_SIZE_B];

#if !defined(TARGET_NANOS)
#error This application only supports the Ledger Nano S
#endif

unsigned short io_exchange_al(unsigned char channel, unsigned short tx_len) {
    switch (channel & ~(IO_FLAGS)) {
    case CHANNEL_KEYBOARD:
        break;

    // multiplexed io exchange over a SPI channel and TLV encapsulated protocol
    case CHANNEL_SPI:
        if (tx_len) {
            io_seproxyhal_spi_send(G_io_apdu_buffer, tx_len);

            if (channel & IO_RESET_AFTER_REPLIED) {
                reset();
            }
            return 0; // nothing received from the master so far (it's a tx
                      // transaction)
        } else {
            return io_seproxyhal_spi_recv(G_io_apdu_buffer,
                                          sizeof(G_io_apdu_buffer), 0);
        }

    default:
        THROW(INVALID_PARAMETER);
    }
    return 0;
}

uint32_t deserialize_uint32_t(unsigned char *buffer)
{
    uint32_t value = 0;

    value |= buffer[0] << 24;
    value |= buffer[1] << 16;
    value |= buffer[2] << 8;
    value |= buffer[3];
    return value;

}

// 20 bytes total
void read_path_from_bytes(unsigned char *buffer, uint32_t *path) {
    path[0] = deserialize_uint32_t(buffer);
    path[1] = deserialize_uint32_t(buffer + 4);
    path[2] = deserialize_uint32_t(buffer + 8);
    path[3] = deserialize_uint32_t(buffer + 12);
    path[4] = deserialize_uint32_t(buffer + 16);
}

// Handle a signing request -- called both from the main apdu loop as well as from
// the button handler after the user verifies the transaction.
void add_chunk_data() {
    // if this is a first chunk
    if (tmp_ctx.signing_context.buffer_used == 0) {
        // then there is the bip32 path in the first chunk - first 20 bytes of data
        read_path_from_bytes(&G_io_apdu_buffer[5], (uint32_t *) tmp_ctx.signing_context.bip32);
        int path_size = sizeof(tmp_ctx.signing_context.bip32);

        // Update the other data from this segment
        int data_size = G_io_apdu_buffer[4];
        if (data_size < path_size) {
            // TODO: Have specific error for underflow?
            THROW(SW_BUFFER_OVERFLOW);
        }
        data_size -= path_size;
        PRINTF("data_size: %d\n", data_size);

        os_memmove((char *) tmp_ctx.signing_context.buffer, &G_io_apdu_buffer[25], data_size);
        PRINTF("buffer: %.*h\n", data_size, tmp_ctx.signing_context.buffer);
        tmp_ctx.signing_context.buffer_used += data_size;
    } else {
        // else update the data from entire segment.
        int data_size = G_io_apdu_buffer[4];
        PRINTF("data_size: %d\n", data_size);
        if (data_size > MAX_DATA_SIZE || tmp_ctx.signing_context.buffer_used + data_size > MAX_DATA_SIZE) {
            THROW(SW_BUFFER_OVERFLOW);
        }
        os_memmove((char *) &tmp_ctx.signing_context.buffer[tmp_ctx.signing_context.buffer_used], &G_io_apdu_buffer[5], data_size);
        PRINTF("buffer: %.*h\n", data_size, &tmp_ctx.signing_context.buffer[tmp_ctx.signing_context.buffer_used]);
        tmp_ctx.signing_context.buffer_used += data_size;
    }
}

// like https://github.com/lenondupe/ledger-app-stellar/blob/master/src/main.c#L1784
uint32_t set_result_sign() {
    cx_ecfp_public_key_t public_key;
    cx_ecfp_private_key_t private_key;
    get_keypair_by_path((uint32_t *) tmp_ctx.signing_context.bip32, &public_key, &private_key);

    public_key_le_to_be(&public_key);

    uint8_t signature[64];
    near_message_sign(&private_key, public_key.W, (unsigned char *) tmp_ctx.signing_context.buffer, tmp_ctx.signing_context.buffer_used, signature);

    os_memmove((char *) G_io_apdu_buffer, signature, sizeof(signature));

    // reset all private stuff
    os_memset(&private_key, 0, sizeof(cx_ecfp_private_key_t));
    os_memset(&public_key, 0, sizeof(cx_ecfp_public_key_t));

    return 64;
}

uint32_t set_result_get_address() {
    os_memmove((char *) G_io_apdu_buffer, (char *) tmp_ctx.address_context.public_key, 32);
    return 32;
}

uint32_t set_result_get_app_configuration() {
    PRINTF("set_result_get_app_configuration\n");
    G_io_apdu_buffer[0] = LEDGER_MAJOR_VERSION;
    G_io_apdu_buffer[1] = LEDGER_MINOR_VERSION;
    G_io_apdu_buffer[2] = LEDGER_PATCH_VERSION;
    return 3;
}

// Called by both the U2F and the standard communications channel
void handle_apdu(volatile unsigned int *flags, volatile unsigned int *tx, volatile unsigned int rx) {
    unsigned short sw = 0;
    BEGIN_TRY {
        TRY {

            if (os_global_pin_is_validated() == 0) {
                THROW(SW_DEVICE_IS_LOCKED);
            }
            
            if (G_io_apdu_buffer[0] != CLA) {
                THROW(SW_CLA_NOT_SUPPORTED);
            }

            PRINTF("command: %d\n", G_io_apdu_buffer[1]);
            switch (G_io_apdu_buffer[1]) {
            case INS_SIGN: {
                if (G_io_apdu_buffer[4] != rx - 5) {
                    // the length of the APDU should match what's in the 5-byte header.
                    // If not fail.  Don't want to buffer overrun or anything.
                    THROW(SW_CONDITIONS_NOT_SATISFIED);
                }
                if ((G_io_apdu_buffer[2] != P1_MORE) &&
                    (G_io_apdu_buffer[2] != P1_LAST)) {
                    THROW(SW_INCORRECT_P1_P2);
                }

                if (G_io_apdu_buffer[2] == P1_LAST) {
                    tmp_ctx.signing_context.network_byte = G_io_apdu_buffer[3];
                    add_chunk_data();
                    menu_sign_init();
                    *flags |= IO_ASYNCH_REPLY;
                } else {
                    add_chunk_data();
                    THROW(SW_OK);
                }

            } break;

            case INS_GET_PUBLIC_KEY: {
                if (G_io_apdu_buffer[4] != rx - 5 || G_io_apdu_buffer[4] != 20) {
                    // the length of the APDU should match what's in the 5-byte header.
                    // If not fail.  Don't want to buffer overrun or anything.
                    THROW(SW_CONDITIONS_NOT_SATISFIED);
                }

                init_context();

                // Get the public key and return it.
                cx_ecfp_public_key_t public_key;

                uint32_t path[5];
                read_path_from_bytes(G_io_apdu_buffer + 5, path);

                if (!get_ed25519_public_key_for_path(path, &public_key)) {
                    THROW(INVALID_PARAMETER);
                }

                os_memmove((char *) tmp_ctx.address_context.public_key, public_key.W, 32);

                *flags |= IO_ASYNCH_REPLY;
                menu_address_init();
            } break;

            case INS_GET_APP_CONFIGURATION:
                *tx = set_result_get_app_configuration();
                THROW(SW_OK);
                break;

            default:
                // Instruction not supported
                THROW(SW_INS_NOT_SUPPORTED);
                break;
            }
        }
        CATCH(EXCEPTION_IO_RESET) {
            THROW(EXCEPTION_IO_RESET);
        }
        CATCH_OTHER(e) {
            switch (e & 0xF000) {
            case 0x6000:
                sw = e;                
                break;
            case 0x9000:
                // All is well
                sw = e;
                break;
            default:
                // Internal error
                sw = 0x6800 | (e & 0x7FF);
                break;
            }
            // Unexpected exception => report
            G_io_apdu_buffer[*tx] = sw >> 8;
            G_io_apdu_buffer[*tx + 1] = sw;
            *tx += 2;
        }
        FINALLY {
        }
    END_TRY;
    }
}

void init_context() {
    os_memset(&tmp_ctx, 0, sizeof(tmp_ctx));
}

static void waves_main(void) {
    volatile unsigned int rx = 0;
    volatile unsigned int tx = 0;
    volatile unsigned int flags = 0;

    // next timer callback in 500 ms
    UX_CALLBACK_SET_INTERVAL(500);

    // DESIGN NOTE: the bootloader ignores the way APDU are fetched. The only
    // goal is to retrieve APDU.
    // When APDU are to be fetched from multiple IOs, like NFC+USB+BLE, make
    // sure the io_event is called with a
    // switch event, before the apdu is replied to the bootloader. This avoid
    // APDU injection faults.
    for (;;) {
        volatile unsigned short sw = 0;

        BEGIN_TRY {
            TRY {
                rx = tx;
                tx = 0; // ensure no race in catch_other if io_exchange throws
                        // an error
                rx = io_exchange(CHANNEL_APDU | flags, rx);
                flags = 0;

                // no apdu received, well, reset the session, and reset the
                // bootloader configuration
                if (rx == 0) {
                    THROW(SW_SECURITY_STATUS_NOT_SATISFIED);
                }

                // Call the Apdu handler,
                handle_apdu(&flags, &tx, rx);
            }
            CATCH(EXCEPTION_IO_RESET) {
                THROW(EXCEPTION_IO_RESET);
            }
            CATCH_OTHER(e) {
                switch (e & 0xF000) {
                case 0x6000:
                case 0x9000:
                    sw = e;
                    break;
                default:
                    sw = 0x6800 | (e & 0x7FF);
                    break;
                }
                // Unexpected exception => report
                G_io_apdu_buffer[tx] = sw >> 8;
                G_io_apdu_buffer[tx + 1] = sw;
                tx += 2;
            }
            FINALLY {
            }
        }
        END_TRY;
    }

    return;
}

void io_seproxyhal_display(const bagl_element_t *element) {
    io_seproxyhal_display_default((bagl_element_t *)element);
}

unsigned char io_event(unsigned char channel) {
    // nothing done with the event, throw an error on the transport layer if
    // needed
    // can't have more than one tag in the reply, not supported yet.
    switch (G_io_seproxyhal_spi_buffer[0]) {
    case SEPROXYHAL_TAG_FINGER_EVENT:
        UX_FINGER_EVENT(G_io_seproxyhal_spi_buffer);
        break;

    case SEPROXYHAL_TAG_BUTTON_PUSH_EVENT: // for Nano S
        UX_BUTTON_PUSH_EVENT(G_io_seproxyhal_spi_buffer);
        break;

    case SEPROXYHAL_TAG_DISPLAY_PROCESSED_EVENT:
        UX_DISPLAYED_EVENT({ });
        break;

    case SEPROXYHAL_TAG_TICKER_EVENT:
        UX_TICKER_EVENT(G_io_seproxyhal_spi_buffer, {
            if (ux_step_count && UX_ALLOWED) {
                // prepare next screen
                ux_step = (ux_step + 1) % ux_step_count;
                // redisplay screen
                UX_REDISPLAY();
            }
        });
        break;

    // unknown events are acknowledged
    default:
        UX_DEFAULT_EVENT();
        break;
    }

    // close the event if not done previously (by a display or whatever)
    if (!io_seproxyhal_spi_is_status_sent()) {
        io_seproxyhal_general_status();
    }

    // command has been processed, DO NOT reset the current APDU transport
    return 1;
}

void app_exit(void) {
    BEGIN_TRY_L(exit) {
        TRY_L(exit) {
            os_sched_exit(-1);
        }
        FINALLY_L(exit) {
        }
    }
    END_TRY_L(exit);
}

__attribute__((section(".boot"))) int main(void) {
    // exit critical section
    __asm volatile("cpsie i");

    init_context();
    // current_text_pos = 0;
    // text_y = 60;
    ui_state = UI_IDLE;

    for (;;) {
        // ensure exception will work as planned
        os_boot();

        UX_INIT();

        BEGIN_TRY {
            TRY {
                io_seproxyhal_init();

                if (N_storage.initialized != 0x01) {
                    internal_storage_t storage;
                    storage.fido_transport = 0x00;
                    storage.initialized = 0x01;
                    nvm_write(&N_storage, (void *)&storage,
                              sizeof(internal_storage_t));
                }

                USB_power(0);
                USB_power(1);

                ui_idle();

                waves_main();
            }
            CATCH(EXCEPTION_IO_RESET) {
                // reset IO and UX before continuing
                continue;
            }
            CATCH_ALL {
                break;
            }
            FINALLY {
            }
        }
        END_TRY;
    }
    app_exit();
    return 0;
}

'''
'''--- workdir/near-ledger-app/src/main.h ---

/*******************************************************************************
*   Burstcoin Wallet App for Nano Ledger S. Updated By Waves community.
*   Copyright (c) 2017-2018 Jake B.
* 
*   Based on Sample code provided and (c) 2016 Ledger
*
*  Licensed under the Apache License, Version 2.0 (the "License");
*  you may not use this file except in compliance with the License.
*  You may obtain a copy of the License at
*
*      http://www.apache.org/licenses/LICENSE-2.0
*
*  Unless required by applicable law or agreed to in writing, software
*  distributed under the License is distributed on an "AS IS" BASIS,
*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*  See the License for the specific language governing permissions and
*  limitations under the License.
********************************************************************************/

#ifndef __MAIN_H__
#define __MAIN_H__
#include "os.h"
#include "cx.h"
#include <stdbool.h>

// Host innteration communication protocol
#define CLA 0x80                // CLASS? 
#define INS_SIGN 0x02           // Sign Instruction
#define INS_GET_PUBLIC_KEY 0x04 // Get Public Key Instruction
#define INS_GET_APP_CONFIGURATION 0x06 // Get App Version
#define P1_LAST 0x80            // Parameter 1 = End of Bytes to Sign (finalize)
#define P1_MORE 0x00            // Parameter 1 = More bytes coming

#define SW_OK 0x9000
#define SW_USER_CANCELLED 0x9100
#define SW_DEVICE_IS_LOCKED 0x6986
#define SW_CONDITIONS_NOT_SATISFIED 0x6985
#define SW_BUFFER_OVERFLOW 0x6990
#define SW_INCORRECT_P1_P2 0x6A86
#define SW_INS_NOT_SUPPORTED 0x6D00
#define SW_CLA_NOT_SUPPORTED  0x6E00
#define SW_SECURITY_STATUS_NOT_SATISFIED 0x6982

#define COLOR_BG_1 0xF9F9F9
#define COLOR_APP 0x0055FF
#define COLOR_APP_LIGHT 0x87dee6

typedef struct internal_storage_t {
    uint8_t 			 fido_transport;
    uint8_t 			 initialized;
} internal_storage_t;

extern WIDE internal_storage_t N_storage_real;
#define N_storage (*(WIDE internal_storage_t *)PIC(&N_storage_real))

// A place to store information about the transaction
// for displaying to the user when requesting approval
// 44 for address/id and +1 for \0
typedef struct uiContext_t {
	char line1[45];
	char line2[45];
	char line3[45];
	char line4[45];
	char line5[45];
	char line6[45];
	char line7[45];
	char line8[45];
} uiContext_t;

// A place to store data during the signing
typedef struct signingContext_t {
    // bip32 path
	uint32_t bip32[5];
	char buffer[MAX_DATA_SIZE];
	uint32_t buffer_used;
	unsigned char network_byte;
} signingContext_t;

// A place to store data during the confirming the address
typedef struct addressesContext_t {
	unsigned char public_key[32];
} addressesContext_t;

typedef union {
    signingContext_t signing_context;
    addressesContext_t address_context;
} tmpContext_t;

extern uiContext_t ui_context;

extern tmpContext_t tmp_ctx; // Temporary area to store stuff

bool get_ed25519_public_key_for_path(const uint32_t* path, cx_ecfp_public_key_t* public_key);

void init_context();
uint32_t set_result_get_address();
uint32_t set_result_sign();

#endif

'''
'''--- workdir/near-ledger-app/src/qemu_printf.c ---
#include <stdarg.h>
#include <string.h>

#include "os.h"

void debug_write(char *buf)
{
    asm volatile(
        "movs r0, #0x04\n"
        "movs r1, %0\n"
        "svc      0xab\n"
        :: "r"(buf) : "r0", "r1"
    );
}

static const char const g_pcHex[] = {
    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f',
};
static const char const g_pcHex_cap[] = {
    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F',
};

#ifdef HAVE_PRINTF

int qemu_printf(const char *format, ...)
{
    char dest_buf[500];
    char *str = dest_buf;
    size_t str_size = sizeof(dest_buf);

    unsigned int ulIdx, ulValue, ulPos, ulCount, ulBase, ulNeg, ulStrlen, ulCap;
    char *pcStr, pcBuf[16], cFill;
    va_list vaArgP;
    char cStrlenSet;
    
    //
    // Check the arguments.
    //
    if(format == 0 || str == 0 ||str_size < 2) {
      debug_write(dest_buf); return 0;
    }

    // ensure terminating string with a \0
    os_memset(str, 0, str_size);
    str_size--;

    //
    // Start the varargs processing.
    //
    va_start(vaArgP, format);

    //
    // Loop while there are more characters in the string.
    //
    while(*format)
    {
        //
        // Find the first non-% character, or the end of the string.
        //
        for(ulIdx = 0; (format[ulIdx] != '%') && (format[ulIdx] != '\0');
            ulIdx++)
        {
        }

        //
        // Write this portion of the string.
        //
        ulIdx = MIN(ulIdx, str_size);
        os_memmove(str, format, ulIdx);
        str+= ulIdx;
        str_size -= ulIdx;
        if (str_size == 0) {
            debug_write(dest_buf); return 0;
        }

        //
        // Skip the portion of the string that was written.
        //
        format += ulIdx;

        //
        // See if the next character is a %.
        //
        if(*format == '%')
        {
            //
            // Skip the %.
            //
            format++;

            //
            // Set the digit count to zero, and the fill character to space
            // (i.e. to the defaults).
            //
            ulCount = 0;
            cFill = ' ';
            ulStrlen = 0;
            cStrlenSet = 0;
            ulCap = 0;
            ulBase = 10;

            //
            // It may be necessary to get back here to process more characters.
            // Goto's aren't pretty, but effective.  I feel extremely dirty for
            // using not one but two of the beasts.
            //
again:

            //
            // Determine how to handle the next character.
            //
            switch(*format++)
            {
                //
                // Handle the digit characters.
                //
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                {
                    //
                    // If this is a zero, and it is the first digit, then the
                    // fill character is a zero instead of a space.
                    //
                    if((format[-1] == '0') && (ulCount == 0))
                    {
                        cFill = '0';
                    }

                    //
                    // Update the digit count.
                    //
                    ulCount *= 10;
                    ulCount += format[-1] - '0';

                    //
                    // Get the next character.
                    //
                    goto again;
                }

                //
                // Handle the %c command.
                //
                case 'c':
                {
                    //
                    // Get the value from the varargs.
                    //
                    ulValue = va_arg(vaArgP, unsigned long);

                    //
                    // Print out the character.
                    //
                    str[0] = ulValue;
                    str++;
                    str_size -= 1;
                    if (str_size == 0) {
                        debug_write(dest_buf); return 0;
                    }

                    //
                    // This command has been handled.
                    //
                    break;
                }

                //
                // Handle the %d command.
                //
                case 'd':
                {
                    //
                    // Get the value from the varargs.
                    //
                    ulValue = va_arg(vaArgP, unsigned long);

                    //
                    // Reset the buffer position.
                    //
                    ulPos = 0;

                    //
                    // If the value is negative, make it positive and indicate
                    // that a minus sign is needed.
                    //
                    if((long)ulValue < 0)
                    {
                        //
                        // Make the value positive.
                        //
                        ulValue = -(long)ulValue;

                        //
                        // Indicate that the value is negative.
                        //
                        ulNeg = 1;
                    }
                    else
                    {
                        //
                        // Indicate that the value is positive so that a minus
                        // sign isn't inserted.
                        //
                        ulNeg = 0;
                    }

                    //
                    // Set the base to 10.
                    //
                    ulBase = 10;

                    //
                    // Convert the value to ASCII.
                    //
                    goto convert;
                }

                //
                // Handle ths %.*s command
                // special %.*H or %.*h format to print a given length of hex digits (case: H UPPER, h lower)
                //
                case '.':
                {
                  // ensure next char is '*' and next one is 's'/'h'/'H'
                  if (format[0] == '*' && (format[1] == 's' || format[1] == 'H' || format[1] == 'h')) {
                    
                    // skip '*' char
                    format++;
                    
                    ulStrlen = va_arg(vaArgP, unsigned long);
                    cStrlenSet = 1;
                    
                    // interpret next char (H/h/s)
                    goto again;
                  }
                  
                  // does not support %.2x for example
                  goto error;
                }
                
                case '*':
                {
                  if (*format == 's' ) {                    
                    
                    ulStrlen = va_arg(vaArgP, unsigned long);
                    cStrlenSet = 2;
                    goto again;
                  }
                  
                  goto error;
                }
                
                case '-': // -XXs
                {
                  cStrlenSet = 0;
                  // read a number of space to post pad with ' ' the string to display
                  goto again;
                }

                //
                // Handle the %s command.
                // %H and %h also
                case 'H':
                  ulCap = 1; // uppercase base 16
                  ulBase = 16;
                  goto case_s;
                case 'h':
                  ulBase = 16; // lowercase base 16
                  goto case_s;
                case 's':
                case_s:
                {
                    //
                    // Get the string pointer from the varargs.
                    //
                    pcStr = va_arg(vaArgP, char *);

                    //
                    // Determine the length of the string. (if not specified using .*)
                    //
                    switch(cStrlenSet) {
                      // compute length with strlen
                      case 0:
                        for(ulIdx = 0; pcStr[ulIdx] != '\0'; ulIdx++)
                        {
                        }
                        break;
                        
                      // use given length
                      case 1:
                        ulIdx = ulStrlen;
                        break;
                        
                      // printout prepad
                      case 2:
                        // if string is empty, then, ' ' padding
                        if (pcStr[0] == '\0') {
                        
                          // padd ulStrlen white space
                          ulStrlen = MIN(ulStrlen, str_size);
                          os_memset(str, ' ', ulStrlen);
                          str+= ulStrlen;
                          str_size -= ulStrlen;
                          if (str_size == 0) {
                              debug_write(dest_buf); return 0;
                          }
                        
                          goto s_pad;
                        }
                        goto error; // unsupported if replicating the same string multiple times
                      case 3:
                        // skip '-' still buggy ...
                        goto again;
                    }

                    //
                    // Write the string.
                    //
                    switch(ulBase) {
                      default:
                        ulIdx = MIN(ulIdx, str_size);
                        os_memmove(str, pcStr, ulIdx);
                        str+= ulIdx;
                        str_size -= ulIdx;
                        if (str_size == 0) {
                            debug_write(dest_buf); return 0;
                        }
                        break;
                      case 16: {
                        unsigned char nibble1, nibble2;
                        for (ulCount = 0; ulCount < ulIdx; ulCount++) {
                          nibble1 = (pcStr[ulCount]>>4)&0xF;
                          nibble2 = pcStr[ulCount]&0xF;
                          if (str_size < 2) {
                              debug_write(dest_buf); return 0;
                          }
                          switch(ulCap) {
                            case 0:
                                str[0] = g_pcHex[nibble1];
                                str[1] = g_pcHex[nibble2];
                                break;
                            case 1:
                                str[0] = g_pcHex_cap[nibble1];
                                str[1] = g_pcHex_cap[nibble2];
                              break;
                          }
                          str+= 2;
                          str_size -= 2;
                          if (str_size == 0) {
                              debug_write(dest_buf); return 0;
                          }
                        }
                        break;
                      }
                    }

s_pad:
                    //
                    // Write any required padding spaces
                    //
                    if(ulCount > ulIdx)
                    {
                        ulCount -= ulIdx;
                        ulCount = MIN(ulCount, str_size);
                        os_memset(str, ' ', ulCount);
                        str+= ulCount;
                        str_size -= ulCount;
                        if (str_size == 0) {
                            debug_write(dest_buf); return 0;
                        }
                    }
                    //
                    // This command has been handled.
                    //
                    break;
                }

                //
                // Handle the %u command.
                //
                case 'u':
                {
                    //
                    // Get the value from the varargs.
                    //
                    ulValue = va_arg(vaArgP, unsigned long);

                    //
                    // Reset the buffer position.
                    //
                    ulPos = 0;

                    //
                    // Set the base to 10.
                    //
                    ulBase = 10;

                    //
                    // Indicate that the value is positive so that a minus sign
                    // isn't inserted.
                    //
                    ulNeg = 0;

                    //
                    // Convert the value to ASCII.
                    //
                    goto convert;
                }

                //
                // Handle the %x and %X commands.  Note that they are treated
                // identically; i.e. %X will use lower case letters for a-f
                // instead of the upper case letters is should use.  We also
                // alias %p to %x.
                //
                case 'X':
                    ulCap = 1;
                case 'x':
                case 'p':
                {
                    //
                    // Get the value from the varargs.
                    //
                    ulValue = va_arg(vaArgP, unsigned long);

                    //
                    // Reset the buffer position.
                    //
                    ulPos = 0;

                    //
                    // Set the base to 16.
                    //
                    ulBase = 16;

                    //
                    // Indicate that the value is positive so that a minus sign
                    // isn't inserted.
                    //
                    ulNeg = 0;

                    //
                    // Determine the number of digits in the string version of
                    // the value.
                    //
convert:
                    for(ulIdx = 1;
                        (((ulIdx * ulBase) <= ulValue) &&
                         (((ulIdx * ulBase) / ulBase) == ulIdx));
                        ulIdx *= ulBase, ulCount--)
                    {
                    }

                    //
                    // If the value is negative, reduce the count of padding
                    // characters needed.
                    //
                    if(ulNeg)
                    {
                        ulCount--;
                    }

                    //
                    // If the value is negative and the value is padded with
                    // zeros, then place the minus sign before the padding.
                    //
                    if(ulNeg && (cFill == '0'))
                    {
                        //
                        // Place the minus sign in the output buffer.
                        //
                        pcBuf[ulPos++] = '-';

                        //
                        // The minus sign has been placed, so turn off the
                        // negative flag.
                        //
                        ulNeg = 0;
                    }

                    //
                    // Provide additional padding at the beginning of the
                    // string conversion if needed.
                    //
                    if((ulCount > 1) && (ulCount < 16))
                    {
                        for(ulCount--; ulCount; ulCount--)
                        {
                            pcBuf[ulPos++] = cFill;
                        }
                    }

                    //
                    // If the value is negative, then place the minus sign
                    // before the number.
                    //
                    if(ulNeg)
                    {
                        //
                        // Place the minus sign in the output buffer.
                        //
                        pcBuf[ulPos++] = '-';
                    }

                    //
                    // Convert the value into a string.
                    //
                    for(; ulIdx; ulIdx /= ulBase)
                    {
                        if (!ulCap) {
                          pcBuf[ulPos++] = g_pcHex[(ulValue / ulIdx) % ulBase];
                        }
                        else {
                          pcBuf[ulPos++] = g_pcHex_cap[(ulValue / ulIdx) % ulBase];
                        }
                    }

                    //
                    // Write the string.
                    //
                    ulPos = MIN(ulPos, str_size);
                    os_memmove(str, pcBuf, ulPos);
                    str+= ulPos;
                    str_size -= ulPos;
                    if (str_size == 0) {
                        debug_write(dest_buf); return 0;
                    }

                    //
                    // This command has been handled.
                    //
                    break;
                }

                //
                // Handle the %% command.
                //
                case '%':
                {
                    //
                    // Simply write a single %.
                    //
                    str[0] = '%';
                    str++;
                    str_size --;
                    if (str_size == 0) {
                        debug_write(dest_buf); return 0;
                    }

                    //
                    // This command has been handled.
                    //
                    break;
                }

error:
                //
                // Handle all other commands.
                //
                default:
                {
                    //
                    // Indicate an error.
                    //
                    ulPos = MIN(strlen("ERROR"), str_size);
                    os_memmove(str, "ERROR", ulPos);
                    str+= ulPos;
                    str_size -= ulPos;
                    if (str_size == 0) {
                        debug_write(dest_buf); return 0;
                    }

                    //
                    // This command has been handled.
                    //
                    break;
                }
            }
        }
    }

    //
    // End the varargs processing.
    //
    va_end(vaArgP);

    debug_write(dest_buf); return 0;
}

#endif // HAVE_PRINTF
'''
'''--- workdir/near-ledger-app/src/ui/nanos/ui_menus_buttons.c ---
#include "ui_menus_buttons.h"

#include "../ui_logic.h"
#include "os_io_seproxyhal.h"

#if defined(TARGET_NANOS)

unsigned int ui_verify_transfer_nanos_button(unsigned int button_mask, unsigned int button_mask_counter) {
    return ui_verify_transaction_nanos_button(button_mask, button_mask_counter);
}

unsigned int ui_verify_function_call_nanos_button(unsigned int button_mask, unsigned int button_mask_counter) {
    return ui_verify_transaction_nanos_button(button_mask, button_mask_counter);
}

unsigned int ui_verify_add_function_call_access_key_button(unsigned int button_mask, unsigned int button_mask_counter) {
    return ui_verify_transaction_nanos_button(button_mask, button_mask_counter);
}

unsigned int ui_verify_add_full_access_key_button(unsigned int button_mask, unsigned int button_mask_counter) {
    return ui_verify_transaction_nanos_button(button_mask, button_mask_counter);
}

unsigned int ui_verify_transaction_nanos_button(unsigned int button_mask, unsigned int button_mask_counter) {
    switch (button_mask) {
        case BUTTON_EVT_RELEASED | BUTTON_LEFT: // CANCEL
            io_seproxyhal_cancel(NULL);
            break;

        case BUTTON_EVT_RELEASED | BUTTON_RIGHT:  // OK
            io_seproxyhal_touch_sign_approve(NULL);
            break;
    }
    return 0;
}

unsigned int ui_address_nanos_button(unsigned int button_mask, unsigned int button_mask_counter) {
    switch (button_mask) {
        case BUTTON_EVT_RELEASED | BUTTON_LEFT: // CANCEL
            io_seproxyhal_cancel(NULL);
            break;

        case BUTTON_EVT_RELEASED | BUTTON_RIGHT:  // OK
            io_seproxyhal_touch_address_ok(NULL);
            break;
        }
    return 0;
}

#endif
'''
'''--- workdir/near-ledger-app/src/ui/nanos/ui_menus_buttons.h ---
#ifndef __UI_MENUS_BUTTONS_H__
#define __UI_MENUS_BUTTONS_H__

#include "os.h"
#include "cx.h"

#if defined(TARGET_NANOS)
unsigned int ui_verify_transfer_nanos_button(unsigned int button_mask, unsigned int button_mask_counter);
unsigned int ui_verify_function_call_nanos_button(unsigned int button_mask, unsigned int button_mask_counter);
unsigned int ui_verify_add_function_call_access_key_button(unsigned int button_mask, unsigned int button_mask_counter);
unsigned int ui_verify_add_full_access_key_button(unsigned int button_mask, unsigned int button_mask_counter);
unsigned int ui_verify_transaction_nanos_button(unsigned int button_mask, unsigned int button_mask_counter);
unsigned int ui_address_nanos_button(unsigned int button_mask, unsigned int button_mask_counter);
#endif

#endif
'''
'''--- workdir/near-ledger-app/src/ui/nanos/ui_menus_nanos.h ---
#ifndef __UI_MENUS_NANOS_H__
#define __UI_MENUS_NANOS_H__

#include "os.h"
#include "cx.h"

//    type          userid  x  y  w    h str rad fill       fg        bg      fid iid  txt 
#define EMPTY_BG() \
    {{BAGL_RECTANGLE, 0x00, 0, 0, 128, 32, 0, 0, BAGL_FILL, 0x000000, 0xFFFFFF, 0, 0}, NULL}

//    type     userid  x  y   w  h str rad fill fg     bg      fid  iid    txt
#define LEFT_ICON(icon) \
    {{BAGL_ICON, 0x00, 3, 12, 7, 7, 0, 0, 0, 0xFFFFFF, 0x000000, 0, icon}, NULL}
#define RIGHT_ICON(icon) \
    {{BAGL_ICON, 0x00, 117, 13, 8, 6, 0, 0, 0, 0xFFFFFF, 0x000000, 0, icon}, NULL}

//    type       userid  x  y   w    h  str rad fill    fg        bg
//    fid                                                            iid  txt
#define INFO_CELL(id, title, info)  \
    {{BAGL_LABELINE, id, 0, 12, 128, 12, 0, 0, 0, 0xFFFFFF, 0x000000, \
      BAGL_FONT_OPEN_SANS_REGULAR_11px | BAGL_FONT_ALIGNMENT_CENTER, 0}, title}, \
    {{BAGL_LABELINE, id, 23, 26, 82, 12, BAGL_STROKE_FLAG_ONESHOT | 10, 0, 0, 0xFFFFFF, 0x000000, \
      BAGL_FONT_OPEN_SANS_EXTRABOLD_11px | BAGL_FONT_ALIGNMENT_CENTER, 26}, info}

const bagl_element_t ui_address_nanos[] = {
    EMPTY_BG(),

    LEFT_ICON(BAGL_GLYPH_ICON_CROSS),
    RIGHT_ICON(BAGL_GLYPH_ICON_CHECK),

    INFO_CELL(0x01, "Confirm", "public key")
};

const bagl_element_t ui_verify_transfer_nanos[] = {
    EMPTY_BG(),

    LEFT_ICON(BAGL_GLYPH_ICON_CROSS),
    RIGHT_ICON(BAGL_GLYPH_ICON_CHECK),

    INFO_CELL(0x01, "Confirm", "transfer"),
    INFO_CELL(0x02, "Amount", ui_context.line1),
    INFO_CELL(0x03, "To", ui_context.line2),
    INFO_CELL(0x04, "From", ui_context.line3)
};

const bagl_element_t ui_verify_function_call_nanos[] = {
    EMPTY_BG(),

    LEFT_ICON(BAGL_GLYPH_ICON_CROSS),
    RIGHT_ICON(BAGL_GLYPH_ICON_CHECK),

    INFO_CELL(0x01, "Confirm", ui_context.line1),
    INFO_CELL(0x02, "Deposit", ui_context.line5),
    INFO_CELL(0x03, "To", ui_context.line2),
    INFO_CELL(0x04, "From", ui_context.line3),
    INFO_CELL(0x05, "Args", ui_context.line4)
};

const bagl_element_t ui_verify_add_function_call_access_key[] = {
    EMPTY_BG(),

    LEFT_ICON(BAGL_GLYPH_ICON_CROSS),
    RIGHT_ICON(BAGL_GLYPH_ICON_CHECK),

    INFO_CELL(0x01, "Confirm", "add key"),
    INFO_CELL(0x02, "To Account", ui_context.line3),
    INFO_CELL(0x03, "Contract", ui_context.line2),
    INFO_CELL(0x04, "Allowance", ui_context.line1)
};

const bagl_element_t ui_verify_add_full_access_key[] = {
    EMPTY_BG(),

    LEFT_ICON(BAGL_GLYPH_ICON_CROSS),
    RIGHT_ICON(BAGL_GLYPH_ICON_CHECK),

    INFO_CELL(0x01, "DANGER", "This gives full access to a device other than Ledger"),
    INFO_CELL(0x02, "For Contract", ui_context.line2)
};

const bagl_element_t ui_verify_transaction_nanos[] = {
    EMPTY_BG(),

    LEFT_ICON(BAGL_GLYPH_ICON_CROSS),
    RIGHT_ICON(BAGL_GLYPH_ICON_CHECK),

    INFO_CELL(0x01, "Confirm", ui_context.line1),
    INFO_CELL(0x02, "To", ui_context.line2),
    INFO_CELL(0x03, "From", ui_context.line3)
};

const ux_menu_entry_t menu_about[];

const ux_menu_entry_t menu_main[] = {
    {NULL, NULL, 0, &C_icon_near, "Use wallet to", "view accounts", 33, 12},
    {menu_about, NULL, 0, NULL, "About", NULL, 0, 0},
    {NULL, os_sched_exit, 0, &C_icon_dashboard, "Quit app", NULL, 50, 29},
    UX_MENU_END};

const ux_menu_entry_t menu_about[] = {
    {NULL, NULL, 0, NULL, "Version", APPVERSION, 0, 0},
    {menu_main, NULL, 1, &C_icon_back, "Back", NULL, 61, 40},
    UX_MENU_END};

#endif
'''
'''--- workdir/near-ledger-app/src/ui/nanos/ui_menus_prepro.c ---
#include "ui_menus_prepro.h"

#include "../ui.h"

const bagl_element_t * simple_scroll_prepro(const bagl_element_t *element) {
    // display or not according to step, and adjust delay
    if (element->component.userid > 0) {
        unsigned int display = (ux_step == element->component.userid - 1);
        if (display) {
            UX_CALLBACK_SET_INTERVAL(
                MAX(2000, bagl_label_roundtrip_duration_ms(element, 7)));
        }
        if (!display) {
             return NULL;
        }
    }
    return element;
}

const bagl_element_t * ui_address_prepro(const bagl_element_t *element) {
    return simple_scroll_prepro(element);
}

const bagl_element_t * ui_verify_transfer_prepro(const bagl_element_t *element) {
    return simple_scroll_prepro(element);
}

const bagl_element_t * ui_verify_function_call_prepro(const bagl_element_t *element) {
    return simple_scroll_prepro(element);
}

const bagl_element_t * ui_verify_transaction_prepro(const bagl_element_t *element) {
    return simple_scroll_prepro(element);
}
'''
'''--- workdir/near-ledger-app/src/ui/nanos/ui_menus_prepro.h ---
#ifndef __UI_MENUS_PREPRO_H__
#define __UI_MENUS_PREPRO_H__

#include "os_io_seproxyhal.h"

const bagl_element_t * simple_scroll_prepro(const bagl_element_t *element);

const bagl_element_t * ui_address_prepro(const bagl_element_t *element);
const bagl_element_t * ui_verify_transfer_prepro(const bagl_element_t *element);
const bagl_element_t * ui_verify_function_call_prepro(const bagl_element_t *element);
const bagl_element_t * ui_verify_transaction_prepro(const bagl_element_t *element);

#endif
'''
'''--- workdir/near-ledger-app/src/ui/ui.c ---

/*******************************************************************************
*   Burstcoin Wallet App for Nano Ledger S. Updated By Waves community.
*   Copyright (c) 2017-2018 Jake B.
*
*   Based on Sample code provided and (c) 2016 Ledger
*
*  Licensed under the Apache License, Version 2.0 (the "License");
*  you may not use this file except in compliance with the License.
*  You may obtain a copy of the License at
*
*      http://www.apache.org/licenses/LICENSE-2.0
*
*  Unless required by applicable law or agreed to in writing, software
*  distributed under the License is distributed on an "AS IS" BASIS,
*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*  See the License for the specific language governing permissions and
*  limitations under the License.
********************************************************************************/

#include "ui.h"
#include <stdbool.h>
#include "../glyphs.h"
#include "../main.h"

#ifdef TARGET_NANOS
#include "nanos/ui_menus_nanos.h"
#include "nanos/ui_menus_buttons.h"
#include "nanos/ui_menus_prepro.h"
#endif

ux_state_t ux;

// UI currently displayed
enum UI_STATE ui_state;

int ux_step, ux_step_count;

void menu_address_init() {
    ux_step = 0;
    ux_step_count = 1;
    #if defined(TARGET_NANOS)
        UX_DISPLAY(ui_address_nanos, ui_address_prepro);
    #endif // #if TARGET_ID
}

// Idle state, sow the menu
void ui_idle() {
    ux_step = 0; ux_step_count = 0;
    ui_state = UI_IDLE;
    #if defined(TARGET_NANOS)
        UX_MENU_DISPLAY(0, menu_main, NULL);
    #endif // #if TARGET_ID
}

/*
 Adapted from https://en.wikipedia.org/wiki/Double_dabble#C_implementation
 Returns: length of resulting string or -1 for error
*/
int format_long_int_amount(size_t input_size, char *input, size_t output_size, char *output) {
    // NOTE: Have to copy to have word-aligned array (otherwise crashing on read)
    // Lots of time has been lost debugging this, make sure to avoid unaligned RAM access (as compiler in BOLOS SDK won't)
    uint16_t aligned_amount[8];
    os_memmove(aligned_amount, input, 16);
    // Convert size in bytes into words
    size_t n = input_size / 2;

    size_t nbits = 16 * n;       /* length of arr in bits */
    size_t nscratch = nbits / 3; /* length of scratch in bytes */
    if (nscratch >= output_size) {
        // Output buffer is too small
        output[0] = '\0';
        return -1;
    }

    char *scratch = output;

    size_t i, j, k;
    size_t smin = nscratch - 2; /* speed optimization */

    for (i = 0; i < n; ++i) {
        for (j = 0; j < 16; ++j) {
            /* This bit will be shifted in on the right. */
            int shifted_in = (aligned_amount[n - i - 1] & (1 << (15 - j))) ? 1 : 0;

            /* Add 3 everywhere that scratch[k] >= 5. */
            for (k = smin; k < nscratch; ++k) {
                scratch[k] += (scratch[k] >= 5) ? 3 : 0;
            }

            /* Shift scratch to the left by one position. */
            if (scratch[smin] >= 8) {
                smin -= 1;
            }
            for (k = smin; k < nscratch - 1; ++k) {
                scratch[k] <<= 1;
                scratch[k] &= 0xF;
                scratch[k] |= (scratch[k + 1] >= 8);
            }

            /* Shift in the new bit from arr. */
            scratch[nscratch - 1] <<= 1;
            scratch[nscratch - 1] &= 0xF;
            scratch[nscratch - 1] |= shifted_in;
        }
    }

    /* Remove leading zeros from the scratch space. */
    for (k = 0; k < nscratch - 1; ++k) {
        if (scratch[k] != 0) {
            break;
        }
    }
    nscratch -= k;
    os_memmove(scratch, scratch + k, nscratch + 1);

    /* Convert the scratch space from BCD digits to ASCII. */
    for (k = 0; k < nscratch; ++k) {
        scratch[k] += '0';
    }

    /* Resize and return */
    os_memmove(output, scratch, nscratch + 1);
    return nscratch;
}

int format_long_decimal_amount(size_t input_size, char *input, size_t output_size, char *output, int nomination) {
    int len = format_long_int_amount(input_size, input, output_size, output);

    if (len < 0 || (size_t) len + 2 > output_size) {
        // Output buffer is too small
        output[0] = '\0';
        return -1;
    }

    if (len <= nomination) {
        // < 1.0
        os_memmove(output + 2 + (nomination - len), output, len);
        os_memset(output + 2, '0', (nomination - len));
        output[0] = '0';
        output[1] = '.';
        len = nomination + 2;
    } else {
        // >= 1.0
        int int_len = len - nomination;
        os_memmove(output + int_len + 1, output + int_len, nomination);
        output[int_len] = '.';
        len = len + 1;
    }

    // Remove trailing zeros and dot
    output[len] = '0';
    while (len > 0 && (output[len] == '0' || output[len] == '.')) {
        output[len--] = 0;
    }

    return len;
}

void check_overflow(unsigned int processed, unsigned int size) {
    PRINTF("check_overflow %d %d %d\n", processed, size, tmp_ctx.signing_context.buffer_used);
    if (size > tmp_ctx.signing_context.buffer_used || processed + size > tmp_ctx.signing_context.buffer_used) {
        THROW(SW_BUFFER_OVERFLOW);
    }
}

#define PRINT_REMAINING_BUFFER() \
    PRINTF("remaining buffer: %.*h\n", tmp_ctx.signing_context.buffer_used - processed, &tmp_ctx.signing_context.buffer[processed]);

uint8_t borsh_read_uint8(unsigned int *processed) {
    check_overflow(*processed, 1);
    uint8_t result = *((uint8_t *) &tmp_ctx.signing_context.buffer[*processed]);
    *processed += 1;
    return result;
}

uint32_t borsh_read_uint32(unsigned int *processed) {
    check_overflow(*processed, 4);
    uint32_t result = *((uint32_t *) &tmp_ctx.signing_context.buffer[*processed]);
    *processed += 4;
    return result;
}

void borsh_read_buffer(uint32_t *buffer_len, char **buffer, unsigned int *processed) {
    *buffer_len = borsh_read_uint32(processed);
    check_overflow(*processed, *buffer_len);
    *buffer = &tmp_ctx.signing_context.buffer[*processed];
    *processed += *buffer_len;
}

char *borsh_read_fixed_buffer(unsigned int buffer_len, unsigned int *processed) {
    check_overflow(*processed, buffer_len);
    char *buffer = &tmp_ctx.signing_context.buffer[*processed];
    *processed += buffer_len;
    return buffer;
}

void strcpy_ellipsis(size_t dst_size, char *dst, size_t src_size, char *src) {
    if (dst_size >= src_size + 1) {
        os_memmove(dst, src, src_size);
        dst[src_size] = 0;
        return;
    }

    os_memmove(dst, src, dst_size);
    size_t ellipsis_start = dst_size >= 4 ? dst_size - 4 : 0;
    for (size_t i = ellipsis_start; i < dst_size; i++) {
        dst[i] = '.';
    }
    dst[dst_size - 1] = 0;
    return;
}

#define BORSH_SKIP(size) \
    check_overflow(processed, size); \
    processed += size;

#define BORSH_DISPLAY_STRING(var_name, ui_line) \
    uint32_t var_name##_len; \
    char *var_name; \
    borsh_read_buffer(&var_name##_len, &var_name, &processed); \
    strcpy_ellipsis(sizeof(ui_line), ui_line, var_name##_len, var_name); \
    PRINTF("%s: %s\n", #var_name, ui_line);

#define BORSH_DISPLAY_AMOUNT(var_name, ui_line) \
    char *var_name = &tmp_ctx.signing_context.buffer[processed]; \
    processed += 16; \
    format_long_decimal_amount(16, var_name, sizeof(ui_context.line1), ui_context.line1, 24);

#define DISPLAY_VERIFY_UI(ui, step_count, prepro_fn) \
    ux_step = 0; \
    ux_step_count = step_count; \
    ui_state = UI_VERIFY; \
    UX_DISPLAY(ui, prepro_fn); \

#define COPY_LITERAL(dst, src) \
    os_memmove(dst, src, sizeof(src))

typedef enum {
    at_create_account,
    at_deploy_contract,
    at_function_call,
    at_transfer,
    at_stake,
    at_add_key,
    at_delete_key,
    at_delete_account,
    at_last_value = at_delete_account
} action_type_t;

// Show the transaction details for the user to approve
void menu_sign_init() {
    os_memset(&ui_context, 0, sizeof(uiContext_t));

    // TODO: Validate data when parsing tx

    unsigned int processed = 0;

    // signer
    BORSH_DISPLAY_STRING(signer_id, ui_context.line3);

    // public key
    BORSH_SKIP(33);

    // nonce
    BORSH_SKIP(8);

    // receiver
    BORSH_DISPLAY_STRING(receiver_id, ui_context.line2);

    // block hash
    BORSH_SKIP(32);

    // actions
    uint32_t actions_len = borsh_read_uint32(&processed);
    PRINTF("actions_len: %d\n", actions_len);

    if (actions_len != 1) {
        COPY_LITERAL(ui_context.line1, "multiple actions");
        DISPLAY_VERIFY_UI(ui_verify_transaction_nanos, 3, ui_verify_transaction_prepro);
        return;
    }

    // TODO: Parse more than one action

    // action type
    uint8_t action_type = borsh_read_uint8(&processed);
    PRINTF("action_type: %d\n", action_type);

    // TODO: assert action_type <= at_last_value

    switch (action_type) {
    case at_transfer: {
        BORSH_DISPLAY_AMOUNT(amount, ui_context.line1);

        DISPLAY_VERIFY_UI(ui_verify_transfer_nanos, 4, ui_verify_transfer_prepro);
        return;
    }

    case at_function_call: {
        // method name
        BORSH_DISPLAY_STRING(method_name, ui_context.line1);

        // args
        uint32_t args_len;
        char *args;
        borsh_read_buffer(&args_len, &args, &processed);
        if (args_len > 0 && args[0] == '{') {
            // Args look like JSON
            strcpy_ellipsis(sizeof(ui_context.line4), ui_context.line4, args_len, args);
            PRINTF("args: %s\n", ui_context.line4);
        } else {
            // TODO: Hexdump args otherwise
        }

        // gas
        BORSH_SKIP(8);

        // deposit
        BORSH_DISPLAY_AMOUNT(deposit, ui_context.line5);

        DISPLAY_VERIFY_UI(ui_verify_function_call_nanos, 5, ui_verify_function_call_prepro);
        return;
    }

    case at_add_key: {
        // TODO: Assert that sender/receiver are the same?

        // public key

        // key type
        BORSH_SKIP(1);
        // TODO: assert ed25519 key type

        // key data
        char *data = borsh_read_fixed_buffer(32, &processed);
        // TODO: Display Base58 key?

        // access key

        // nonce
        BORSH_SKIP(8);

        // permission
        uint8_t permission_type = borsh_read_uint8(&processed);
        PRINTF("permission_type: %d\n", permission_type);
        if (permission_type == 0) {
            // function call

            // allowance
            uint8_t has_allowance = borsh_read_uint8(&processed);
            if (has_allowance) {
                BORSH_DISPLAY_AMOUNT(allowance, ui_context.line5);
            } else {
                COPY_LITERAL(ui_context.line5, "Unlimited");
            }

            // receiver
            BORSH_DISPLAY_STRING(permission_receiver_id, ui_context.line2);

            // TODO: read method names array
            // TODO: Need to display one (multiple not supported yet – can just display "multiple methods")
            DISPLAY_VERIFY_UI(ui_verify_add_function_call_access_key, 4, simple_scroll_prepro);
            return;
        } else {
            // full access

            DISPLAY_VERIFY_UI(ui_verify_add_full_access_key, 2, simple_scroll_prepro);
            return;
        }
    }

    case at_create_account: {
        COPY_LITERAL(ui_context.line1, "create account");
        // Use generic UI
        break;
    }

    case at_deploy_contract: {
        COPY_LITERAL(ui_context.line1, "deploy contract");
        // Use generic UI
        break;
    }

    case at_stake: {
        COPY_LITERAL(ui_context.line1, "stake");
        // Use generic UI
        break;
    }

    case at_delete_key: {
        COPY_LITERAL(ui_context.line1, "delete key");
        // Use generic UI
        break;
    }

    case at_delete_account: {
        COPY_LITERAL(ui_context.line1, "delete account");
        // Use generic UI
        break;
    }

    default:
        // TODO: Throw more specific error?
        THROW(SW_CONDITIONS_NOT_SATISFIED);

    } // switch

    PRINT_REMAINING_BUFFER();

    DISPLAY_VERIFY_UI(ui_verify_transaction_nanos, 3, ui_verify_transaction_prepro);
}
'''
'''--- workdir/near-ledger-app/src/ui/ui.h ---

/*******************************************************************************
*   Burstcoin Wallet App for Nano Ledger S. Updated By Waves community.
*   Copyright (c) 2017-2018 Jake B.
* 
*   Based on Sample code provided and (c) 2016 Ledger
*
*  Licensed under the Apache License, Version 2.0 (the "License");
*  you may not use this file except in compliance with the License.
*  You may obtain a copy of the License at
*
*      http://www.apache.org/licenses/LICENSE-2.0
*
*  Unless required by applicable law or agreed to in writing, software
*  distributed under the License is distributed on an "AS IS" BASIS,
*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*  See the License for the specific language governing permissions and
*  limitations under the License.
********************************************************************************/

#ifndef __UI_H__
#define __UI_H__

#include "os.h"
#include "cx.h"
#include <stdbool.h>
#include "../main.h"
#include "../crypto/ledger_crypto.h"
#include "os_io_seproxyhal.h"

extern ux_state_t ux;

enum UI_STATE { UI_IDLE, UI_VERIFY };
extern enum UI_STATE ui_state;

void menu_sign_init();
void ui_idle();

extern int ux_step;
extern int ux_step_count;

void menu_address_init();

#endif
'''
'''--- workdir/near-ledger-app/src/ui/ui_logic.c ---
#include "ui_logic.h"
#include "main.h"
#include "ui.h"

// UI
unsigned int io_seproxyhal_touch_address_ok(const bagl_element_t *e) {
    uint32_t tx = set_result_get_address();
    unsigned short sw = SW_OK;

    G_io_apdu_buffer[tx++] = sw >> 8;
    G_io_apdu_buffer[tx++] = sw;

    // Send back the response, do not restart the event loop
    io_exchange(CHANNEL_APDU | IO_RETURN_AFTER_TX, tx);

    init_context();

    // Display back the original UX
    ui_idle();
    return 0; // do not redraw the widget
}

unsigned int io_seproxyhal_cancel(const bagl_element_t *e) {
    uint32_t tx = 0;

    unsigned short sw = SW_USER_CANCELLED;

    G_io_apdu_buffer[tx++] = sw >> 8;
    G_io_apdu_buffer[tx++] = sw;

    // Send back the response, do not restart the event loop
    io_exchange(CHANNEL_APDU | IO_RETURN_AFTER_TX, 2);

    init_context();

    // Display back the original UX
    ui_idle();
    return 0; // do not redraw the widget
}

unsigned int io_seproxyhal_touch_sign_approve(const bagl_element_t *e) {
    // first 64 byte - signature
    uint32_t tx = set_result_sign();
    unsigned short sw = SW_OK;

    G_io_apdu_buffer[tx++] = sw >> 8;
    G_io_apdu_buffer[tx++] = sw;

    io_exchange(CHANNEL_APDU | IO_RETURN_AFTER_TX, tx);

    init_context();

    ui_idle();

    return 0; // do not redraw the widget
}

unsigned int io_seproxyhal_touch_exit(const bagl_element_t *e) {
    // Go back to the dashboard
    os_sched_exit(0);
    return 0; // do not redraw the widget
}
'''
'''--- workdir/near-ledger-app/src/ui/ui_logic.h ---
#ifndef __UI_LOGIC_H__
#define __UI_LOGIC_H__

#include "os_io_seproxyhal.h"

unsigned int io_seproxyhal_touch_address_ok(const bagl_element_t *e);
unsigned int io_seproxyhal_cancel(const bagl_element_t *e);
unsigned int io_seproxyhal_touch_sign_approve(const bagl_element_t *e);
unsigned int io_seproxyhal_touch_exit(const bagl_element_t *e);

#endif
'''
'''--- workdir/near-ledger-app/test_app.sh ---
#!/usr/bin/env bash

RAM_USED=$(grep '0x300 00' debug/app.map | awk '{print $2}');
if [[ "$RAM_USED" > "0x20002100" ]]; then
    echo "Ram limit reached in a compiled app ($RAM_USED) !. Fix it!";
    exit -1;
fi;
'''
'''--- workdir/usbtool/Readme.txt ---
This is the Readme file for usbtool, a general purpose command line utility
which can send USB requests to arbitrary devices. Usbtool is based on libusb.

WHAT IS USBTOOL GOOD FOR?
=========================
When you implement a communication protocol like USB, you must usually write
two programs: one on each end of the communication. For USB, this means that
you must write a firmware for the device and driver software for the host.

Usbtool can save you the work of writing the host software, at least during
firmware development and testing. Usbtool can send control-in and -out
requests to arbitrary devices and send and receive data on interrupt- and
bulk-endpoints.

Usbtool is not only a useful developer tool, it's also an example for using
libusb for communication with the device.

SYNOPSIS
========
  usbtool [options] <command>

COMMANDS
========
  list
    This command prints a list of devices found on all available USB busses.
    Options -v, -V, -p and -P can be used to filter the list.

  control in|out <type> <recipient> <request> <value> <index>
    Sends a control-in or control-out request to the device. The request
    parameters are:
      type ........ Type of request, can be "standard", "class", "vendor" or
                    "reserved". The type determines which software module in
                    the device is responsible for answering the request:
                    Standard requests are answered by the driver, class
                    requests by the class implementation (e.g. HID, CDC) and
                    vendor requests by custom code.
      recipient ... Recipient of the request in the device. Can be "device",
                    "interface", "endpoint" or "other". For standard and
                    class requests, the specification defines a recipient for
                    each request. For vendor requests, choose whatever your
                    code expects.
      request ..... 8 bit numeric value identifying the request.
      value ....... 16 bit numeric value passed to the device.
      index ....... another 16 bit numeric value passed to the device.
    Use options -v, -V, -p and -P to single out a particular device. Use
    options -d or -D to to send data in an OUT request. Use options -n, -O
    and -b to determine what to do with data received in an IN request.

  interrupt in|out
    Sends or receives data on an interrupt-out resp. -in endpoint.
    Use options -v, -V, -p and -P to single out a particular device. Use
    options -d or -D to to send data to an OUT endpoint. Use options -n, -O
    and -b to determine what to do with data received from an IN endpoint.
    Use option -e to set the endpoint number, -c to choose a configuration
    -i to claim a particular interface.

  bulk in|out
    Same as "interrupt in" and "interrupt out", but for bulk endpoints.

OPTIONS
=======
Most options have already been mentioned at the commands which use them.
here is a complete list:

  -h or -?
    Prints a short help.

  -v <vendor-id>
    Numeric vendor ID, can be "*" to allow any VID. Take only devices with
    matching vendor ID into account.

  -p <product-id>
    Numeric product ID, can be "*" to allow any PID. Take only devices with
    matching product ID into account.

  -V <vendor-name-pattern>
    Shell style matching pattern for vendor name. Take only devices into
    account which have a vendor name that matches this pattern.

  -P <product-name-pattern>
    Shell style matching pattern for product name. Take only devices into
    account which have a product name that matches this pattern.

  -S <serial-pattern>
    Shell style matching pattern for serial number. Take only devices into
    account which have a serial number that matches this pattern.

  -d <databytes>
    Data bytes to send to the device, comma separated list of numeric values.
    E.g.: "1,2,3,4,5".

  -D <file>
    Binary data sent to the device should be taken from this file.

  -O <file>
    Write received data bytes to the given file. Format is either hex or
    binary, depending on the -b flag. By default, received data is printed
    to standard output.

  -b
    Request binary output format for files and standard output. Default is
    a hexadecimal listing.

  -n <count>
    Numeric value: Maximum number of bytes to receive. This value is passed
    directly to the libusb API functions.

  -e <endpoint>
    Numeric value: Endpoint number for interrupt and bulk commands.

  -t <timeout>
    Numeric value: Timeout in milliseconds for the request. This value is
    passed directly to the libusb API functions.

  -c <configuration>
    Numeric value: Interrupt and bulk endpoints can usually only be used if
    a configuration and an interface has been chosen. Use -c and -i to
    specify configuration and interface values.

  -i <interface>
    Numeric value: Interrupt and bulk endpoints can usually only be used if
    a configuration and an interface has been chosen. Use -c and -i to
    specify configuration and interface values.

  -w
    Usbtool may be too verbose with warnings for some applications. Use this
    option to suppress USB warnings.

NUMERIC VALUES
==============
All numeric values can be given in hexadecimal, decimal or octal. Hex values
are identified by their 0x or 0X prefix, octal values by a leading "0" (the
digit zero) and decimal values because they start with a non-zero digit. An
optional sign character is allowed. The special value "*" is translated to
zero and stands for "any value" in some contexts.

SHELL STYLE MATCHING PATTERNS
=============================
Some options take shell style matching patterns as an argument. This refers
to Unix shells and their file wildcard operations:
  + "*" (asterisk character) matches any number (0 to infinite) of any
    characters.
  + "?" matches exactly one arbitrary character.
  + A list of characters in square brackets (e.g. "[abc]") matches any of the
    characters in the list. If a dash ("-") is in the list, it must be the
    first or the last character. If a caret ("^") is in the list, it must
    not be the first character. A closing square bracket ("]") must be the
    first character in the list. A range of characters can be specified in
    the way "[a-z]". This matches all characters with numeric representation
    (usually ASCII) starting with "a" and ending with "z". The entire
    construct matches only one character.
  + A list of characters in square brackets starting with a caret ("^"), e.g.
    ("[^abc]") matches any character NOT in the list. The other rules are as
    above.
  + "\" (backslash) followed by any character matches that following
    character. This can be used to escape "*", "?", "[" and "\".

BUILDING USBTOOL
================
Usbtool uses libusb on Unix and libusb-win32 on Windows. These libraries can
be obtained from http://libusb.sourceforge.net/ and
http://libusb-win32.sourceforge.net/ respectively. On Unix, a simple "make"
should compile the sources (although you may have to edit Makefile to
include or remove additional libraries). On Windows, we recommend that you
use MinGW and MSYS. See the top level Readme file for details. Edit
Makefile.windows according to your library installation paths and build with
"make -f Makefile.windows".

EXAMPLES
========
To list all devices connected to your computer, do

    usbtool -w list

To check whether our selection options single out the desired device, use eg.

    usbtool -w -P LEDControl list

This command shows all LEDControl devices connected or prints nothing if
none is found. LEDControl is the device from the "custom-class" example.

You can also send commands to the LEDControl device using usbtool. From
the file requests.h in custom-class/firmware, we know that the set-status
request has numeric value 1 and the get-status request is 2. See this file
for details of the protocol used. We can therefore query the status with

    usbtool -w -P LEDControl control in vendor device 2 0 0

This command prints 0x00 if the LED is off or 0x01 if it is on. To turn the
LED on, use

    usbtool -w -P LEDControl control out vendor device 1 1 0

and to turn it off, use

    usbtool -w -P LEDControl control out vendor device 1 0 0

----------------------------------------------------------------------------
(c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH.
http://www.obdev.at/

'''
'''--- workdir/usbtool/make-files.sh ---
#!/bin/sh
# Author: Christian Starkjohann
# Creation Date: 2008-04-17
# Tabsize: 4
# Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
# License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)

if [ "$1" = remove ]; then
    make clean
    rm -f opendevice.[ch]
    exit
fi

cp ../../libs-host/opendevice.[ch] .

'''
'''--- workdir/usbtool/opendevice.c ---
/* Name: opendevice.c
 * Project: V-USB host-side library
 * Author: Christian Starkjohann
 * Creation Date: 2008-04-10
 * Tabsize: 4
 * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
 * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
 */

/*
General Description:
The functions in this module can be used to find and open a device based on
libusb or libusb-win32.
*/

#include <stdio.h>
#include "opendevice.h"

/* ------------------------------------------------------------------------- */

#define MATCH_SUCCESS			1
#define MATCH_FAILED			0
#define MATCH_ABORT				-1

/* private interface: match text and p, return MATCH_SUCCESS, MATCH_FAILED, or MATCH_ABORT. */
static int  _shellStyleMatch(char *text, char *p)
{
int last, matched, reverse;

    for(; *p; text++, p++){
        if(*text == 0 && *p != '*')
            return MATCH_ABORT;
        switch(*p){
        case '\\':
            /* Literal match with following character. */
            p++;
            /* FALLTHROUGH */
        default:
            if(*text != *p)
                return MATCH_FAILED;
            continue;
        case '?':
            /* Match anything. */
            continue;
        case '*':
            while(*++p == '*')
                /* Consecutive stars act just like one. */
                continue;
            if(*p == 0)
                /* Trailing star matches everything. */
                return MATCH_SUCCESS;
            while(*text)
                if((matched = _shellStyleMatch(text++, p)) != MATCH_FAILED)
                    return matched;
            return MATCH_ABORT;
        case '[':
            reverse = p[1] == '^';
            if(reverse) /* Inverted character class. */
                p++;
            matched = MATCH_FAILED;
            if(p[1] == ']' || p[1] == '-')
                if(*++p == *text)
                    matched = MATCH_SUCCESS;
            for(last = *p; *++p && *p != ']'; last = *p)
                if (*p == '-' && p[1] != ']' ? *text <= *++p && *text >= last : *text == *p)
                    matched = MATCH_SUCCESS;
            if(matched == reverse)
                return MATCH_FAILED;
            continue;
        }
    }
    return *text == 0;
}

/* public interface for shell style matching: returns 0 if fails, 1 if matches */
static int shellStyleMatch(char *text, char *pattern)
{
    if(pattern == NULL) /* NULL pattern is synonymous to "*" */
        return 1;
    return _shellStyleMatch(text, pattern) == MATCH_SUCCESS;
}

/* ------------------------------------------------------------------------- */

int usbGetStringAscii(usb_dev_handle *dev, int index, char *buf, int buflen)
{
char    buffer[256];
int     rval, i;

    if((rval = usb_get_string_simple(dev, index, buf, buflen)) >= 0) /* use libusb version if it works */
        return rval;
    if((rval = usb_control_msg(dev, USB_ENDPOINT_IN, USB_REQ_GET_DESCRIPTOR, (USB_DT_STRING << 8) + index, 0x0409, buffer, sizeof(buffer), 5000)) < 0)
        return rval;
    if(buffer[1] != USB_DT_STRING){
        *buf = 0;
        return 0;
    }
    if((unsigned char)buffer[0] < rval)
        rval = (unsigned char)buffer[0];
    rval /= 2;
    /* lossy conversion to ISO Latin1: */
    for(i=1;i<rval;i++){
        if(i > buflen)              /* destination buffer overflow */
            break;
        buf[i-1] = buffer[2 * i];
        if(buffer[2 * i + 1] != 0)  /* outside of ISO Latin1 range */
            buf[i-1] = '?';
    }
    buf[i-1] = 0;
    return i-1;
}

/* ------------------------------------------------------------------------- */

int usbOpenDevice(usb_dev_handle **device, int busID, int vendorID, char *vendorNamePattern, int productID, char *productNamePattern, char *serialNamePattern, FILE *printMatchingDevicesFp, FILE *warningsFp)
{
struct usb_bus      *bus;
struct usb_device   *dev;
usb_dev_handle      *handle = NULL;
int                 errorCode = USBOPEN_ERR_NOTFOUND;

    usb_find_busses();
    usb_find_devices();
    for(bus = usb_get_busses(); bus; bus = bus->next){
        for(dev = bus->devices; dev; dev = dev->next){  /* iterate over all devices on all busses */
            if((busID == 0 || bus->location == busID)
                        && (vendorID == 0 || dev->descriptor.idVendor == vendorID)
                        && (productID == 0 || dev->descriptor.idProduct == productID)){
                char    vendor[256], product[256], serial[256];
                int     len;
                handle = usb_open(dev); /* we need to open the device in order to query strings */
                if(!handle){
                    errorCode = USBOPEN_ERR_ACCESS;
                    if(warningsFp != NULL)
                        fprintf(warningsFp, "Warning: cannot open VID=0x%04x PID=0x%04x: %s\n", dev->descriptor.idVendor, dev->descriptor.idProduct, usb_strerror());
                    continue;
                }
                // we found a valid usb device, no need to walk more
                if (vendorID && productID) {
                  break;
                }
                /* now check whether the names match: */
                len = vendor[0] = 0;
                if(dev->descriptor.iManufacturer > 0){
                    len = usbGetStringAscii(handle, dev->descriptor.iManufacturer, vendor, sizeof(vendor));
                }
                if(len < 0){
                    errorCode = USBOPEN_ERR_ACCESS;
                    if(warningsFp != NULL)
                        fprintf(warningsFp, "Warning: cannot query manufacturer for VID=0x%04x PID=0x%04x: %s\n", dev->descriptor.idVendor, dev->descriptor.idProduct, usb_strerror());
                }else{
                    errorCode = USBOPEN_ERR_NOTFOUND;
                    /* printf("seen device from vendor ->%s<-\n", vendor); */
                    if(shellStyleMatch(vendor, vendorNamePattern)){
                        len = product[0] = 0;
                        if(dev->descriptor.iProduct > 0){
                            len = usbGetStringAscii(handle, dev->descriptor.iProduct, product, sizeof(product));
                        }
                        if(len < 0){
                            errorCode = USBOPEN_ERR_ACCESS;
                            if(warningsFp != NULL)
                                fprintf(warningsFp, "Warning: cannot query product for VID=0x%04x PID=0x%04x: %s\n", dev->descriptor.idVendor, dev->descriptor.idProduct, usb_strerror());
                        }else{
                            errorCode = USBOPEN_ERR_NOTFOUND;
                            /* printf("seen product ->%s<-\n", product); */
                            if(shellStyleMatch(product, productNamePattern)){
                                len = serial[0] = 0;
                                if(dev->descriptor.iSerialNumber > 0){
                                    len = usbGetStringAscii(handle, dev->descriptor.iSerialNumber, serial, sizeof(serial));
                                }
                                if(len < 0){
                                    errorCode = USBOPEN_ERR_ACCESS;
                                    if(warningsFp != NULL)
                                        fprintf(warningsFp, "Warning: cannot query serial for VID=0x%04x PID=0x%04x: %s\n", dev->descriptor.idVendor, dev->descriptor.idProduct, usb_strerror());
                                }
                                if(shellStyleMatch(serial, serialNamePattern)){
                                    if(printMatchingDevicesFp != NULL){
                                        if(serial[0] == 0){
                                            fprintf(printMatchingDevicesFp, "BID=0x%02x VID=0x%04x PID=0x%04x vendor=\"%s\" product=\"%s\"\n", bus->location, dev->descriptor.idVendor, dev->descriptor.idProduct, vendor, product);
                                        }else{
                                            fprintf(printMatchingDevicesFp, "BID=0x%02x VID=0x%04x PID=0x%04x vendor=\"%s\" product=\"%s\" serial=\"%s\"\n", bus->location, dev->descriptor.idVendor, dev->descriptor.idProduct, vendor, product, serial);
                                        }
                                    }else{
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }
                usb_close(handle);
                handle = NULL;
            }
        }
        if(handle)  /* we have found a deice */
            break;
    }
    if(handle != NULL){
        errorCode = 0;
        *device = handle;
    }
    if(printMatchingDevicesFp != NULL)  /* never return an error for listing only */
        errorCode = 0;
    return errorCode;
}

/* ------------------------------------------------------------------------- */

'''
'''--- workdir/usbtool/opendevice.h ---
/* Name: opendevice.h
 * Project: V-USB host-side library
 * Author: Christian Starkjohann
 * Creation Date: 2008-04-10
 * Tabsize: 4
 * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
 * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
 */

/*
General Description:
This module offers additional functionality for host side drivers based on
libusb or libusb-win32. It includes a function to find and open a device
based on numeric IDs and textual description. It also includes a function to
obtain textual descriptions from a device.

To use this functionality, simply copy opendevice.c and opendevice.h into your
project and add them to your Makefile. You may modify and redistribute these
files according to the GNU General Public License (GPL) version 2 or 3.
*/

#ifndef __OPENDEVICE_H_INCLUDED__
#define __OPENDEVICE_H_INCLUDED__

#include <usb.h>    /* this is libusb, see http://libusb.sourceforge.net/ */
#include <stdio.h>

int usbGetStringAscii(usb_dev_handle *dev, int index, char *buf, int buflen);
/* This function gets a string descriptor from the device. 'index' is the
 * string descriptor index. The string is returned in ISO Latin 1 encoding in
 * 'buf' and it is terminated with a 0-character. The buffer size must be
 * passed in 'buflen' to prevent buffer overflows. A libusb device handle
 * must be given in 'dev'.
 * Returns: The length of the string (excluding the terminating 0) or
 * a negative number in case of an error. If there was an error, use
 * usb_strerror() to obtain the error message.
 */

int usbOpenDevice(usb_dev_handle **device, int busID, int vendorID, char *vendorNamePattern, int productID, char *productNamePattern, char *serialNamePattern, FILE *printMatchingDevicesFp, FILE *warningsFp);
/* This function iterates over all devices on all USB busses and searches for
 * a device. Matching is done first by means of Vendor- and Product-ID (passed
 * in 'vendorID' and 'productID'. An ID of 0 matches any numeric ID (wildcard).
 * When a device matches by its IDs, matching by names is performed. Name
 * matching can be done on textual vendor name ('vendorNamePattern'), product
 * name ('productNamePattern') and serial number ('serialNamePattern'). A
 * device matches only if all non-null pattern match. If you don't care about
 * a string, pass NULL for the pattern. Patterns are Unix shell style pattern:
 * '*' stands for 0 or more characters, '?' for one single character, a list
 * of characters in square brackets for a single character from the list
 * (dashes are allowed to specify a range) and if the lis of characters begins
 * with a caret ('^'), it matches one character which is NOT in the list.
 * Other parameters to the function: If 'warningsFp' is not NULL, warning
 * messages are printed to this file descriptor with fprintf(). If
 * 'printMatchingDevicesFp' is not NULL, no device is opened but matching
 * devices are printed to the given file descriptor with fprintf().
 * If a device is opened, the resulting USB handle is stored in '*device'. A
 * pointer to a "usb_dev_handle *" type variable must be passed here.
 * Returns: 0 on success, an error code (see defines below) on failure.
 */

/* usbOpenDevice() error codes: */
#define USBOPEN_SUCCESS         0   /* no error */
#define USBOPEN_ERR_ACCESS      1   /* not enough permissions to open device */
#define USBOPEN_ERR_IO          2   /* I/O error */
#define USBOPEN_ERR_NOTFOUND    3   /* device not found */

/* Obdev's free USB IDs, see USB-IDs-for-free.txt for details */

#define USB_VID_OBDEV_SHARED        5824    /* obdev's shared vendor ID */
#define USB_PID_OBDEV_SHARED_CUSTOM 1500    /* shared PID for custom class devices */
#define USB_PID_OBDEV_SHARED_HID    1503    /* shared PID for HIDs except mice & keyboards */
#define USB_PID_OBDEV_SHARED_CDCACM 1505    /* shared PID for CDC Modem devices */
#define USB_PID_OBDEV_SHARED_MIDI   1508    /* shared PID for MIDI class devices */

#endif /* __OPENDEVICE_H_INCLUDED__ */

'''
'''--- workdir/usbtool/usbtool.c ---
/* Name: usbtool.c
 * Project: V-USB examples, host side
 * Author: Christian Starkjohann
 * Creation Date: 2008-04-06
 * Tabsize: 4
 * Copyright: (c) 2008 by OBJECTIVE DEVELOPMENT Software GmbH
 * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
 */

/*
General Description:
This command line tool can perform various USB requests at arbitrary
USB devices. It is intended as universal host side tool for experimentation
and debugging purposes. It must be linked with libusb, a library for accessing
the USB bus from Linux, FreeBSD, Mac OS X and other Unix operating systems.
Libusb can be obtained from http://libusb.sourceforge.net/.
On Windows use libusb-win32 from http://libusb-win32.sourceforge.net/.
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <stdarg.h>
#include <ctype.h>
#include <errno.h>

#include <usb.h>        /* this is libusb, see http://libusb.sourceforge.net/ */
#include "opendevice.h" /* common code moved to separate module */

#define DEFAULT_USB_BID         0   /* any */
#define DEFAULT_USB_VID         0   /* any */
#define DEFAULT_USB_PID         0   /* any */

static void usage(char *name)
{
    fprintf(stderr, "usage: %s [options] <command>\n", name);
    fprintf(stderr,
        "Options are:\n"
        "  -h or -? (print this help and exit)\n"
        "  -b <bus-id> (defaults to 0x%x, can be '*' for any BID)\n"
        "  -v <vendor-id> (defaults to 0x%x, can be '*' for any VID)\n"
        "  -p <product-id> (defaults to 0x%x, can be '*' for any PID)\n"
        "  -V <vendor-name-pattern> (shell style matching, defaults to '*')\n"
        "  -P <product-name-pattern> (shell style matching, defaults to '*')\n"
        "  -S <serial-pattern> (shell style matching, defaults to '*')\n"
        "  -d <databytes> (data byte for request, comma separated list)\n"
        "  -D <file> (binary data for request taken from file)\n"
        "  -O <file> (write received data bytes to file)\n"
        "  -a (binary output format, default is hex)\n"
        "  -n <count> (maximum number of bytes to receive)\n"
        "  -e <endpoint> (specify endpoint for some commands)\n"
        "  -t <timeout> (specify USB timeout in milliseconds)\n"
        "  -c <configuration> (device configuration to choose)\n"
        "  -i <interface> (configuration interface to claim)\n"
        "  -w (suppress USB warnings, default is verbose)\n"
        "  -s (suppress set configuration)\n"
        "  -r (restart operation infinitely)\n"
        "\n"
        "Commands are:\n"
        "  list (list all matching devices by name)\n"
        "  control in|out <type> <recipient> <request> <value> <index> (send control request)\n"
        "  interrupt in|out (send or receive interrupt data)\n"
        "  bulk in|out (send or receive bulk data)\n"
        "For valid enum values for <type> and <recipient> pass \"x\" for the value.\n"
        "Objective Development's free VID/PID pairs are:\n"
        "  5824/1500 for vendor class devices\n"
        "  5824/1503 for HID class devices excluding mice and keyboards\n"
        "  5824/1505 for CDC-ACM class devices\n"
        "  5824/1508 for MIDI class devices\n"
        , DEFAULT_USB_VID, DEFAULT_USB_PID
    );

}

static int  busID = DEFAULT_USB_BID;
static int  vendorID = DEFAULT_USB_VID;
static int  productID = DEFAULT_USB_PID;
static char *vendorNamePattern = "*";
static char *productNamePattern = "*";
static char *serialPattern = "*";
static char *sendBytes = NULL;
static int  sendByteCount;
static char *outputFile = NULL;
static int  endpoint = 0;
static int  outputFormatIsBinary = 0;
static int  showWarnings = 1;
static int  disableSetConfiguration = 0;
static int  retry = 0;
static int  usbTimeout = 5000;
static int  usbCount = 128;
static int  usbConfiguration = 1;
static int  usbInterface = 0;

static int  usbDirection, usbType, usbRecipient, usbRequest, usbValue, usbIndex; /* arguments of control transfer */

/* ------------------------------------------------------------------------- */

/* ASCII to integer (number parsing) which allows hex (0x prefix),
 * octal (0 prefix) and decimal (1-9 prefix) input.
 */
static int  myAtoi(char *text)
{
long    l;
char    *endPtr;

    if(strcmp(text, "*") == 0)
        return 0;
    l = strtol(text, &endPtr, 0);
    if(endPtr == text){
        fprintf(stderr, "warning: can't parse numeric parameter ->%s<-, defaults to 0.\n", text);
        l = 0;
    }else if(*endPtr != 0){
        fprintf(stderr, "warning: numeric parameter ->%s<- only partially parsed.\n", text);
    }
    return l;
}

static int  parseEnum(char *text, ...)
{
va_list vlist;
char    *entries[64];
int     i, numEntries;

    va_start(vlist, text);
    for(i = 0; i < 64; i++){
        entries[i] = va_arg(vlist, char *);
        if(entries[i] == NULL)
            break;
    }
    numEntries = i;
    va_end(vlist);
    for(i = 0; i < numEntries; i++){
        if(strcasecmp(text, entries[i]) == 0)
            return i;
    }
    if(isdigit(*text)){
        return myAtoi(text);
    }
    fprintf(stderr, "Enum value \"%s\" not allowed. Allowed values are:\n", text);
    for(i = 0; i < numEntries; i++){
        fprintf(stderr, "  %s\n", entries[i]);
    }
    exit(1);
}

/* ------------------------------------------------------------------------- */

#define ACTION_LIST         0
#define ACTION_CONTROL      1
#define ACTION_INTERRUPT    2
#define ACTION_BULK         3
#define ACTION_CONTROL_RAW  4
#define ACTION_LOG          5

int main(int argc, char **argv)
{
usb_dev_handle  *handle = NULL;
int             opt, len, action, argcnt;
char            *myName = argv[0], *s, *rxBuffer = NULL;
FILE            *fp;

    while((opt = getopt(argc, argv, "?hv:p:b:V:P:S:d:D:O:e:n:t:awi:sr")) != -1){
        switch(opt){
        case 'h':
        case '?':   /* -h or -? (print this help and exit) */
            usage(myName);
            exit(1);
        case 'v':   /* -v <vendor-id> (defaults to 0x%x, can be '*' for any VID) */
            vendorID = myAtoi(optarg);
            break;
        case 'b':   /* -b <bus-id> (defaults to 0x%x, can be '*' for any VID) */
            busID = myAtoi(optarg);
            break;
        case 'p':   /* -p <product-id> (defaults to 0x%x, can be '*' for any PID) */
            productID = myAtoi(optarg);
            break;
        case 'V':   /* -V <vendor-name-pattern> (shell style matching, defaults to '*') */
            vendorNamePattern = optarg;
            break;
        case 'P':   /* -P <product-name-pattern> (shell style matching, defaults to '*') */
            productNamePattern = optarg;
            break;
        case 'S':   /* -S <serial-pattern> (shell style matching, defaults to '*') */
            serialPattern = optarg;
            break;
        case 'd':   /* -d <databytes> (data bytes for requests given on command line) */
            while((s = strtok(optarg, ", ")) != NULL){
                optarg = NULL;
                if(sendBytes != NULL){
                    sendBytes = realloc(sendBytes, sendByteCount + 1);
                }else{
                    sendBytes = malloc(sendByteCount + 1);
                }
                sendBytes[sendByteCount++] = myAtoi(s);
            }
            break;
        case 'D':   /* -D <file> (data bytes for request taken from file) */
            if((fp = fopen(optarg, "rb")) == NULL){
                fprintf(stderr, "error opening %s: %s\n", optarg, strerror(errno));
                exit(1);
            }
            fseek(fp, 0, SEEK_END);
            len = ftell(fp);
            fseek(fp, 0, SEEK_SET);
            if(sendBytes != NULL){
                sendBytes = realloc(sendBytes, sendByteCount + len);
            }else{
                sendBytes = malloc(sendByteCount + len);
            }
            fread(sendBytes + sendByteCount, 1, len, fp);   /* would need error checking */
            sendByteCount += len;
            fclose(fp);
            break;
        case 'O':   /* -O <file> (write received data bytes to file) */
            outputFile = optarg;
            break;
        case 'e':   /* -e <endpoint> (specify endpoint for some commands) */
            endpoint = myAtoi(optarg);
            break;
        case 't':   /* -t <timeout> (specify USB timeout in milliseconds) */
            usbTimeout = myAtoi(optarg);
            break;
        case 'a':   /* -a (binary output format, default is hex) */
            outputFormatIsBinary = 1;
            break;
        case 'n':   /* -n <count> (maximum number of bytes to receive) */
            usbCount = myAtoi(optarg);
            break;
        case 'c':   /* -c <configuration> (device configuration to choose) */
            usbConfiguration = myAtoi(optarg);
            break;
        case 'i':   /* -i <interface> (configuration interface to claim) */
            usbInterface = myAtoi(optarg);
            break;
        case 'w':   /* -w (suppress USB warnings, default is verbose) */
            showWarnings = 0;
            break;
        case 's':   /* -s (suppress set configuration) */
            disableSetConfiguration = 1;
            break;
        case 'r':
            retry = 1;
            break;
        default:
            fprintf(stderr, "Option -%c unknown\n", opt);
            exit(1);
        }
    }
    argc -= optind;
    argv += optind;
    if(argc < 1){
        usage(myName);
        exit(1);
    }
    argcnt = 2;
    if(strcasecmp(argv[0], "list") == 0){
        action = ACTION_LIST;
        argcnt = 1;
    }else if(strcasecmp(argv[0], "control") == 0){
        action = ACTION_CONTROL;
        argcnt = 7;
    }else if(strcasecmp(argv[0], "log") == 0){
        action = ACTION_LOG;
        argcnt = 1;
    }else if(strcasecmp(argv[0], "controlraw") == 0){
        action = ACTION_CONTROL_RAW;
        argcnt = 5;
    }else if(strcasecmp(argv[0], "interrupt") == 0){
        action = ACTION_INTERRUPT;
    }else if(strcasecmp(argv[0], "bulk") == 0){
        action = ACTION_BULK;
    }else{
        fprintf(stderr, "command %s not known\n", argv[0]);
        usage(myName);
        exit(1);
    }
    if(argc < argcnt){
        fprintf(stderr, "Not enough arguments.\n");
        usage(myName);
        exit(1);
    }
    if(argc > argcnt){
        fprintf(stderr, "Warning: only %d arguments expected, rest ignored.\n", argcnt);
    }
    usb_init();
retry:
    if(usbOpenDevice(&handle, busID, vendorID, vendorNamePattern, productID, productNamePattern, serialPattern, action == ACTION_LIST ? stdout : NULL, showWarnings ? stderr : NULL) != 0){
        if (action == ACTION_LOG) {
            usleep(100000);
            goto retry;
        }
        else 
        {
            fprintf(stderr, "Could not find USB device with VID=0x%x PID=0x%x Vname=%s Pname=%s Serial=%s\n", vendorID, productID, vendorNamePattern, productNamePattern, serialPattern);
        }
        exit(1);
    }
    if (action == ACTION_LOG) {
        rxBuffer = malloc(64);
        // infinite control in transfer
        while(1) {
            len = usb_control_msg(handle, (0x80 | (2<<5) | 0)/*in vendor device*/, 0xFF, 0 /*value=0*/, 0/*index=0*/, rxBuffer, 64, usbTimeout);
            if(len < 0){
                fprintf(stderr, "USB error: %s\n", usb_strerror());
                usleep(100000);
                goto retry;
                //exit(1);
            }
            // long delay when nothing received
            if (len == 0) {
                usleep(100000);
                continue;
            }
            char * s = rxBuffer;
            while(len--) {
                unsigned char c = *s++;
                if (c >= 0x20 && c<= 0x7E) {
                    printf("%c", c);
                }
                else if (c == '\r') {
                    // ignore
                }
                else if (c == '\n') {
                    printf("\n");
                }
                else {
                    printf("<%02x>", c);
                }
            }
            fflush(stdout);
            usleep(10000);
        }
    }

    if(action == ACTION_LIST)
        exit(0);                /* we've done what we were asked to do already */
    if (action != ACTION_CONTROL_RAW) {
      usbDirection = parseEnum(argv[1], "out", "in", NULL);
      if(usbDirection){   /* IN transfer */
          rxBuffer = malloc(usbCount);
      }
    }
    if(action == ACTION_CONTROL){
        int requestType;
        usbType = parseEnum(argv[2], "standard", "class", "vendor", "reserved", NULL);
        usbRecipient = parseEnum(argv[3], "device", "interface", "endpoint", "other", NULL);
        usbRequest = myAtoi(argv[4]);
        usbValue = myAtoi(argv[5]);
        usbIndex = myAtoi(argv[6]);
        requestType = ((usbDirection & 1) << 7) | ((usbType & 3) << 5) | (usbRecipient & 0x1f);
        do {
        if(usbDirection){   /* IN transfer */
            len = usb_control_msg(handle, requestType, usbRequest, usbValue, usbIndex, rxBuffer, usbCount, usbTimeout);
        }else{              /* OUT transfer */
            len = usb_control_msg(handle, requestType, usbRequest, usbValue, usbIndex, sendBytes, sendByteCount, usbTimeout);
        }
        } while (retry);
    }else if(action == ACTION_CONTROL_RAW){
        int requestType = myAtoi(argv[1]);
        usbRequest = myAtoi(argv[2]);
        usbValue = myAtoi(argv[3]);
        usbIndex = myAtoi(argv[4]);
        do {
        if(requestType & 0x80){   /* IN transfer */
            len = usb_control_msg(handle, requestType, usbRequest, usbValue, usbIndex, rxBuffer, usbCount, usbTimeout);
        }else{              /* OUT transfer */
            len = usb_control_msg(handle, requestType, usbRequest, usbValue, usbIndex, sendBytes, sendByteCount, usbTimeout);
        }
        } while (retry);
    }else{  /* must be ACTION_INTERRUPT or ACTION_BULK */
        int retries = 1;
        if (!disableSetConfiguration) {
          if(usb_set_configuration(handle, usbConfiguration) && showWarnings){
              fprintf(stderr, "Warning: could not set configuration: %s\n", usb_strerror());
          }
        }
        /* now try to claim the interface and detach the kernel HID driver on
         * linux and other operating systems which support the call.
         */
        while((len = usb_claim_interface(handle, usbInterface)) != 0 && retries-- > 0){
#ifdef LIBUSB_HAS_DETACH_KERNEL_DRIVER_NP
            if(usb_detach_kernel_driver_np(handle, 0) < 0 && showWarnings){
                fprintf(stderr, "Warning: could not detach kernel driver: %s\n", usb_strerror());
            }
#endif
        }
        if(len != 0 && showWarnings)
            fprintf(stderr, "Warning: could not claim interface: %s\n", usb_strerror());
        
        do {
        if(action == ACTION_INTERRUPT){
            if(usbDirection){   /* IN transfer */
                len = usb_interrupt_read(handle, endpoint, rxBuffer, usbCount, usbTimeout);
            }else{
                len = usb_interrupt_write(handle, endpoint, sendBytes, sendByteCount, usbTimeout);
            }
        }else{
            if(usbDirection){   /* IN transfer */
                len = usb_bulk_read(handle, endpoint, rxBuffer, usbCount, usbTimeout);
            }else{
                len = usb_bulk_write(handle, endpoint, sendBytes, sendByteCount, usbTimeout);
            }
        }
        } while(retry);
    }
    if(len < 0){
        fprintf(stderr, "USB error: %s\n", usb_strerror());
        exit(1);
    }
    if(usbDirection == 0)   /* OUT */
        printf("%d bytes sent.\n", len);
    if(rxBuffer != NULL){
        FILE *fp = stdout;
        if(outputFile != NULL){
            fp = fopen(outputFile, outputFormatIsBinary ? "wb" : "w");
            if(fp == NULL){
                fprintf(stderr, "Error writing \"%s\": %s\n", outputFile, strerror(errno));
                exit(1);
            }
        }
        if(outputFormatIsBinary){
            fwrite(rxBuffer, 1, len, fp);
        }else{
            int i;
            for(i = 0; i < len; i++){
                if(i != 0){
                    if(i % 16 == 0){
                        fprintf(fp, "\n");
                    }else{
                        fprintf(fp, " ");
                    }
                }
                fprintf(fp, "0x%02x", rxBuffer[i] & 0xff);
            }
            if(i != 0)
                fprintf(fp, "\n");
        }
    }
    usb_close(handle);
    if(rxBuffer != NULL)
        free(rxBuffer);
    return 0;
}

'''