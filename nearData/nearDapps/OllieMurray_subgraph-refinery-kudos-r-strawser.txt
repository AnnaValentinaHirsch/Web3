*GitHub Repository "OllieMurray/subgraph-refinery-kudos-r-strawser"*

'''--- README.md ---
# **NEAR Subgraphs**

## **What is a Subgraph?**

Put simply, a subgraph is an index of specific events, actions, and data on the blockchain. Creating a subgraph of a contract’s events requires traversal of the entire blockchain to index, recording these events in a data store defined by a schema within the subgraph’s source code. Once complete, this data store will be queryable via GraphQL by clients or other consumers of the data.

## **Why Build a Subgraph?**

Subgraphs allow clients to query on-chain information that’s functionally cached off-chain. Without a subgraph, a client who wanted to fetch the ownership data for a given token or NFT contract, for example, would need to iterate through the entire blockchain and compile the data themselves. Subgraphs enable clients to make complex queries and return results much more quickly than iterating through the blockchain, so if a client plans on requesting a certain type of data more than once, building a subgraph is probably the best path forward.

## **Three Parts of a Subgraph**

### 1. **Schema**

The schema file is where you define all entities you want stored in your subgraph. These entities are defined using GraphQL, and will be used by The Graph to generate model files for use in the mapping, and corresponding data store to persist entries.

For any given entity, you define it like you would any other data schema in GraphQL. For example, a simple NFT entity that maps to the [NEP-177](https://nomicon.io/Standards/NonFungibleToken/Metadata) might look something like this:

```
type NFT @entity {
  id: ID!

  # NEP-177
  title: String
  description: String
  media: String
  media_hash: String
  copies: BigInt
  issued_at: BigInt
  expires_at: BigInt
  starts_at: BigInt
  updated_at: BigInt
  extra: String
  reference: String
  reference_hash: String
}
```

You can also create more complicated types, and relationships between entities. For example, in the above GraphQL sample you might add a Contract entity and a User entity, and store information like ownership, collection metadata, etc.

For more information on GraphQL Schemas, see the GraphQL documentation on [Schemas and Types](https://graphql.org/learn/schema/).

For more information on schemas for subgraphs, see documentation by [The Graph](https://thegraph.com/docs/en/developer/create-subgraph-hosted/#the-graph-ql-schema).

### 2. **Manifest**

The subgraph manifest is a [YAML](https://yaml.org/) file that contains the metadata required to build the subgraph, such as locations of the schema and mapping file, the entities to generate from the schema, the contract address to index, the events to monitor, and a link to the repository with the source code. The structure is standardized by [The Graph](https://thegraph.com/docs/en/developer/create-subgraph-hosted/#the-subgraph-manifest) and should be simple to fill in.

An example manifest file:

```
specVersion: 0.0.4
schema:
  file: ./schema.graphql
features:
  - ipfsOnEthereumContracts
  - fullTextSearch
dataSources:
  - kind: near
    name: Mrbrownproject
    network: near-mainnet
    source:
      account: "mrbrownproject.near"
      startBlock: 59140000
    mapping:
      apiVersion: 0.0.5
      language: wasm/assemblyscript
      entities:
        - Token
        - User
        - Contract
      receiptHandlers:
        - handler: handleReceipt
      file: ./src/mapping.ts
```

_Note: any given manifest can have multiple entries and serve multiple subgraphs._

### 3. **Mapping**

The Mapping is an [assemblyscript](https://www.assemblyscript.org/introduction.html) file designated in the Manifest (generally named mapping.ts) that contains a callback that’s triggered when certain events are detected on-chain. This callback receives data for a given transaction from the NEAR blockchain, maps this data to the entities defined in the schema, and saves it to the index. Once data is stored in the index, it’s queryable via GraphQL. The Graph has some great documentation on mappings [here](https://thegraph.com/docs/en/developer/create-subgraph-hosted/#writing-mappings).

## **Building Your Own Subgraph**

### **Installing the Graph CLI**

The first step in building your own subgraph is installing the global Graph CLI. You will need Node and Yarn installed on your computer

- If you don’t have Node installed, we recommend you use [Node Version Manager](https://github.com/nvm-sh/nvm). This will install both Node and the Node Package Manager (npm)
- If you don’t have Yarn installed, run `npm install --global yarn`

\_Note: If you just installed Node or Yarn, you’ll have to reset your terminal. Running the <code>reset</code> command in your terminal will handle this for you</em>

Once you have Node and Yarn installed, run the following command:

```
yarn global add @graphprotocol/graph-cli
```

### **Create your hosted service**

The Graph provides some dev infra called Hosted Service, which will host your subgraphs for free. To begin:

- go to [https://thegraph.com/hosted-service/](https://thegraph.com/hosted-service/) and login with Github.
- Click the “My Dashboard” button on the top of the screen, and click “Add Subgraph”.
- Within the subgraph creation form, you must provide a subgraph name and subtitle within the form, and you can choose to provide optional parameters such as a description, an image, and a github URL for the subgraph repository if you’ve already set one up.
- Click “Create Subgraph”

### **Create your subgraph repository and generate scaffolding**

- In your terminal, create a new directory, `cd` into that directory, and run `graph init -product hosted-service &lt;GITHUB_USER>/&lt;SUBGRAPH_NAME>`, where &lt;GITHUB_USER> is your Github username and &lt;SUBGRAPH_NAME> is the name you gave the subgraph we created above.
- Next, run `yarn install && yarn codegen`. These commands will install any required dependencies, and generate the basic data model types from the default GraphQL provided by the `graph init` command.
- If those commands didn’t spit out any errors, run `yarn deploy` to deploy your first subgraph!

_Note: after waiting a minute, reload your hosted service page, and you should see that indexing has begun!_

### **Filling in your subgraph**

Now that you’ve officially deployed your first subgraph to the Hosted Service, it’s time to fill in the three pieces of the subgraph that we discussed earlier: **the Schema**, **the Manifest**, and **the Mapping**.

#### **Manifest**

Let’s start with the Manifest. Thankfully, the `graph init` step should have filled in everything we need inside the Manifest file, so we shouldn’t have to make any changes yet.

However, if you want to make your subgraph more efficient, feel free to update the `startBlock` field of your data source(s), which indicates where on-chain indexing should begin.

For example, if you’re writing a subgraph for an NFT contract that just launched three days ago, you don’t need to index the entire history of the blockchain. Instead, you only need the history of the blockchain starting three days ago because any transactions before the NFT contract was deployed won’t be relevant for the purposes of your subgraph.

#### **Schema**

Next, you’ll need to fill in your data schema. Like we discussed above, the schema defines the structure of your subgraph by specifying what fields your data models have and the relationships among these models. You’ll have to determine what data models best suit your use case and add them to your `schema.graphql` file.

For example, a very simple token data model might look something like this:

```
type Token @entity {
  id: ID!
  ownerId: String
}
```

Once you’ve done that, be sure to re-run `yarn codegen` to make sure you re-generate your data models to use in your mapping.

#### **Mapping**

Lastly, you need to fill in the meat of the subgraph: the mapping code. Again, the mapping is where we extract data from on-chain transactions and write them to our data store using the types generated from our schema.

To do this, first you need to determine which function calls you want to monitor, and filter by those function calls. For example, if you were looking to index NFT ownership, you might want to monitor transfers of NFTs on a given contract. This would generally look something like this:

```
export function handleReceipt(receipt: near.ReceiptWithOutcome): void {
  const actions = receipt.receipt.actions;

  for (let i = 0; i < actions.length; i++) {
    handleAction(
      actions[i],
      receipt.receipt,
      receipt.block.header,
      receipt.outcome
      );
  }
}

function handleAction(
  action: near.ActionValue,
  receipt: near.ActionReceipt,
  blockHeader: near.BlockHeader,
  outcome: near.ExecutionOutcome
): void {
  if (action.kind != near.ActionKind.FUNCTION_CALL) {
    log.info("Early return: {}", ["Not a function call"]);
    return;
  }

  let accounts = new Account(receipt.signerId);
  const functionCall = action.toFunctionCall();
  if (functionCall.methodName == "nft_transfer") {
	...
  }
}
```

From there, you would parse the JSON from the outcome logs, and write the relevant data to your schema. For example, your parsing logic might look something like this:

```
if (functionCall.methodName == "nft_transfer") {
  const receiptId = receipt.id.toBase58();
  accounts.signerId = receipt.signerId;

    // Maps the JSON formatted log to the LOG entity
  if(outcome.logs[0]!=null){
    let parsed = outcome.logs[0].replace('EVENT_JSON:', '')

    let jsonData = json.try_fromString(parsed)
    if(jsonData.value != null) {
      const jsonObject = jsonData.value.toObject()

      let eventData = jsonObject.get('data')
      if(eventData) {
        let eventArray:JSONValue[] = eventData.toArray()
        let data = eventArray[0].toObject()
        const new_owner_id = data.get('new_owner_id')
        const tokenIds = data.get('token_ids')

        const ids:JSONValue[] = tokenIds.toArray()
        const tokenId = ids[0].toString()

        let token = Token.load(tokenId)

        if (!token) {
          token = new Token(tokenId)
          token.id = tokenId

          token.ownerId = new_owner_id.toString()
        }

        token.save()
     }
}
```

### **Re-deploy your subgraph**

Once you’ve written your mapping code and filled in your schema, simply run `yarn deploy` again! This will re-deploy your subgraph onto the hosted service and begin the indexing job again.

### **Querying your subgraph**

Once your subgraph is fully indexed, you’ll be able to query it within the Hosted Service. As an example, here’s a simple query we could run on a subgraph generated using the above schema and mapping.

```
{
  tokens(first: 5) {
    id
    ownerId
  }
}
```

This query, as you might expect, will return the first 5 tokens, and each token data model will contain the token ID and the owner ID. After typing that into the query field within the Hosted Service, simply click the Run button and wait for the response from your subgraph.

_Note: Your query will not succeed until a certain portion of the chain has been indexed. After all, before your indexing is complete, the data isn’t in your subgraph in the first place so there’s no way to query it._

Here’s a sample response for a query like the one above:

```
{
  "data": {
    "tokens": [
      {
        "id": "100",
        "ownerId": "azhyel.near"
      },
      {
        "id": "1001",
        "ownerId": "uncutgems.near"
      },
      {
        "id": "1012",
        "ownerId": "fbdaa19a39ffce9c26c0613fee064481d3d59fd9f5a2934a982adefc5b21339c"
      },
      {
        "id": "1025",
        "ownerId": "2f18219d1d7ca1638526ecde288a7a935266aaa6264a7c05ac00c18310c2f0d8"
      },
      {
        "id": "103",
        "ownerId": "enderr.near"
      }
    ]
  }
}
```

GraphQL also enables you to make much more complex queries than this, such as sorting, filtering, nested queries, etc. For more information about that, see the GraphQL documentation.

That’s it! You’ve officially deployed and queried your subgraph.

'''
'''--- subgraphs/tenkbay/debug-collection-metadata/README.md ---
Indexing mrbrownproject.near

https://thegraph.com/hosted-service/subgraph/r-strawser/debug-collection-metadata?selected=playground
'''
'''--- subgraphs/tenkbay/debug-collection-metadata/src/mapping.ts ---
import { near, BigInt, log, json, JSONValueKind } from "@graphprotocol/graph-ts"
import { FunctionCallLog, TransferCallLog, DeployContractLog, TotalsLog } from "../generated/schema"

export function handleReceipt(
  receiptWithOutcome: near.ReceiptWithOutcome
): void {

  const receipt = receiptWithOutcome.receipt;
  const outcome = receiptWithOutcome.outcome;
  const block = receiptWithOutcome.block;

  if (block.header.height > 62118000) {
    return;
  }
  
  log.info("****************** Receipt ID {} Start ***********************", [receipt.id.toBase58()]);

  log.info("Receipt data -> id: {}, predecessorId: {}, receiverId: {}, signerId: {}", [
    receipt.id.toBase58(),
    receipt.predecessorId,
    receipt.receiverId,
    receipt.signerId
  ]);
  
  const actions = receipt.actions;
  for(let i = 0; i < actions.length; i++) {
    log.info("Receipt actions: kind: {}, data: {}", [actions[i].kind.toString(), actions[i].data.toString()]);
  }

  const inputDataIds = receipt.inputDataIds;
  for(let i = 0; i < inputDataIds.length; i++) {
    log.info("Receipt input data id: {}", [inputDataIds[i].toBase58()]);
  }

  const outputDataReceivers = receipt.outputDataReceivers;
  for(let i = 0; i < outputDataReceivers.length; i++) {
    log.info("Receipt output data receiver id: {}", [outputDataReceivers[i].receiverId]);
  }

  log.info("Outcome data -> blockHash: {}, id: {}, executorId: {}", [
    outcome.blockHash.toBase58(),
    outcome.id.toBase58(),
    outcome.executorId
  ]);

  const logs = outcome.logs;
  for(let i = 0; i < logs.length; i++) {
    log.info("Outcome logs: {}", [logs[i].toString()]);
  }

  const receiptIds = outcome.receiptIds;
  for(let i = 0; i < receiptIds.length; i++) {
    log.info("Outcome receiptIds: {}", [receiptIds[i].toBase58()]);
  }

  log.info("****************** Receipt ID {} End ***********************", [receipt.id.toBase58()]);

  for (let i = 0; i < actions.length; i++) {
    handleAction(
      actions[i],
      receipt,
      block,
      outcome
    );
  }
}

function handleAction(
  action: near.ActionValue,
  receipt: near.ActionReceipt,
  block: near.Block,
  outcome: near.ExecutionOutcome
): void {

  if (action.kind == near.ActionKind.CREATE_ACCOUNT) {
    // handler create account
    const newAction = action.toCreateAccount();
    handleCreateAccount(newAction, receipt, block, outcome);
  }

  if (action.kind == near.ActionKind.DEPLOY_CONTRACT) {
    // handler deploy contract
    const newAction = action.toDeployContract();
    handleDeployContract(newAction, receipt, block, outcome);
  }

  if (action.kind == near.ActionKind.TRANSFER) {
    const newAction = action.toTransfer();
    handleTransfer(newAction, receipt, block, outcome);
  }

  if (action.kind == near.ActionKind.FUNCTION_CALL) {
    // handler function call
    const newAction = action.toFunctionCall();
    handleFunctionCall(newAction, receipt, block, outcome);
    // let funcCall = new FunctionCallLog(`${receipt.id.toBase58()}`);
    // funcCall.methodName = newAction.methodName.toString();
    // funcCall.args = newAction.args.toString();newAction
    // funcCall.deposit = newAction.deposit.toHexString();
    // funcCall.blockHash = block.header.hash.toHexString();
    // funcCall.outcomeLogs = outcome.logs.toString();
  }
}

function handleCreateAccount(
  createAccount: near.CreateAccountAction,
  receipt: near.ActionReceipt,
  block: near.Block,
  outcome: near.ExecutionOutcome
): void {
  log.info("Receipt create account -> id: {}", [receipt.id.toBase58()]);
}

function handleDeployContract(
  deployContract: near.DeployContractAction,
  receipt: near.ActionReceipt,
  block: near.Block,
  outcome: near.ExecutionOutcome
): void {
  log.info("Receipt deploy contract -> id: {}", [receipt.id.toBase58()]);
  let depContract = new DeployContractLog(`${receipt.id.toBase58()}`);
  depContract.codeHash = deployContract.codeHash.toBase58()
  depContract.blockHash = block.header.hash.toHexString();
  depContract.outcomeLogs = outcome.logs.toString();
  depContract.save();
}

function handleTransfer(
  transfer: near.TransferAction,
  receipt: near.ActionReceipt,
  block: near.Block,
  outcome: near.ExecutionOutcome
): void {
  log.info("Receipt transfer -> id: {}, deposit: {}, hash: {}, outcome logs: {}", [
    receipt.id.toBase58(),
    transfer.deposit.toHexString(),
    block.header.hash.toHexString(),
    outcome.logs.toString()
  ]);
  let transferCall = new TransferCallLog(`${receipt.id.toBase58()}`);
  if(transferCall.deposit) {
    transferCall.deposit = transfer.deposit.toHexString();
  }
  transferCall.blockHash = block.header.hash.toHexString();
  transferCall.outcomeLogs = outcome.logs.toString();
  transferCall.save();
}

function handleFunctionCall(
  functionCall: near.FunctionCallAction,
  receipt: near.ActionReceipt,
  block: near.Block,
  outcome: near.ExecutionOutcome
): void {
  log.info("Receipt function call -> id: {}, method: {}, args: {}, deposit: {}, hash: {}, outcome logs: {}", [
    receipt.id.toBase58(),
    functionCall.methodName,
    functionCall.args.toString(),
    functionCall.deposit.toHexString(),
    block.header.hash.toHexString(),
    outcome.logs.toString()
  ]);

  let totals = TotalsLog.load("mrbrownproject-LOGS")
  if(!totals) {
    totals = new TotalsLog("mrbrownproject-LOGS");
    totals.total_addToWhitelistCalls = BigInt.zero();
    totals.total_claimsCalls = BigInt.zero();
    totals.total_createAccountAndClaimCalls = BigInt.zero();
    totals.total_createLinkdropCalls = BigInt.zero();
    totals.total_linkCallbackCalls = BigInt.zero();
    totals.total_nftMintCalls = BigInt.zero();
    totals.total_nftMintManyCalls = BigInt.zero();
    totals.total_nftMintOneCalls = BigInt.zero();
    totals.total_nftResolveTranser = BigInt.zero();
    totals.total_nftTransferCallCalls = BigInt.zero();
    totals.total_nftTransferCalls = BigInt.zero();
  }

  let funcCall = new FunctionCallLog(`${receipt.id.toBase58()}`);
  funcCall.methodName = functionCall.methodName;
  funcCall.args = functionCall.args.toString();
  funcCall.deposit = functionCall.deposit.toHexString();
  funcCall.blockHash = block.header.hash.toHexString();
  funcCall.outcomeLogs = outcome.logs.toString();

  if(functionCall.methodName == "add_whitelist_accounts"){
    if(totals.total_addToWhitelistCalls) {
      totals.total_addToWhitelistCalls = totals.total_addToWhitelistCalls.plus(BigInt.fromI32(1));
    }
  }
  if(functionCall.methodName == "claim"){
    if(totals.total_claimsCalls) {
      totals.total_claimsCalls = totals.total_claimsCalls.plus(BigInt.fromI32(1));
    }
  }
  if(functionCall.methodName == "create_account_and_claim"){
    if(totals.total_createAccountAndClaimCalls) {
      totals.total_createAccountAndClaimCalls = totals.total_createAccountAndClaimCalls.plus(BigInt.fromI32(1));
    }
  }
  if(functionCall.methodName == "create_linkdrop"){
    if(totals.total_createLinkdropCalls) {
      totals.total_createLinkdropCalls = totals.total_createLinkdropCalls.plus(BigInt.fromI32(1));
    }
  }
  if(functionCall.methodName == "link_callback"){
    if(totals.total_linkCallbackCalls) {
      totals.total_linkCallbackCalls = totals.total_linkCallbackCalls.plus(BigInt.fromI32(1));
    }
  }
  if(functionCall.methodName == "nft_mint"){
    if(totals.total_nftMintCalls) {
      totals.total_nftMintCalls = totals.total_nftMintCalls.plus(BigInt.fromI32(1));
    }
  }
  if(functionCall.methodName == "nft_mint_one"){
    if(totals.total_nftMintOneCalls) {
      totals.total_nftMintOneCalls = totals.total_nftMintOneCalls.plus(BigInt.fromI32(1));
    }
  }
  if(functionCall.methodName == "nft_mint_many"){
    if(totals.total_nftMintManyCalls) {
      totals.total_nftMintManyCalls = totals.total_nftMintManyCalls.plus(BigInt.fromI32(1));
    }
  }
  if(functionCall.methodName == "nft_transfer"){
    if(totals.total_nftTransferCalls) {
      totals.total_nftTransferCalls = totals.total_nftTransferCalls.plus(BigInt.fromI32(1));
    }
  }
  if(functionCall.methodName == "nft_transfer_call"){
    if(totals.total_nftTransferCallCalls) {
      totals.total_nftTransferCallCalls = totals.total_nftTransferCallCalls.plus(BigInt.fromI32(1));
    }
  }

  funcCall.save();
  totals.save();
}
'''
'''--- subgraphs/tenkbay/extinctheroes-collection/src/mapping.ts ---
import { near, log, json, JSONValueKind, JSONValue, BigInt, ByteArray } from "@graphprotocol/graph-ts";
import { Account, Token, Contract, Transfer, Mint, Royalty } from "../generated/schema";

export function handleReceipt(
  receiptWithOutcome: near.ReceiptWithOutcome
  ): void {

    const receipt = receiptWithOutcome.receipt;
    const outcome = receiptWithOutcome.outcome;
    const block = receiptWithOutcome.block;

    const actions = receipt.actions;
    for(let i = 0; i < actions.length; i++) {
      log.info("Receipt actions: kind: {}, data: {}", [actions[i].kind.toString(), actions[i].data.toString()]);
    }

  for (let i = 0; i < actions.length; i++) {
    handleAction(
      actions[i],
      receipt,
      block,
      outcome
      );
  }
}

function handleAction(
  action: near.ActionValue,
  receipt: near.ActionReceipt,
  block: near.Block,
  outcome: near.ExecutionOutcome
): void {
  
  if (action.kind != near.ActionKind.FUNCTION_CALL) {
    log.info("Early return: {}", ["Not a function call"]);
    return;
  }

  const functionCall = action.toFunctionCall();

  // assign royalties to each account after a market sale
  // old_owner_id == seller
  // new_owner_id == buyer
  function assign_royalties(status_value: string, receipt_id: string, token_id: string, seller: string, buyer: string, signer: string, receiver: string, predecessor: string, ts: string): void {
    log.info("BEGIN - assign_royalties - outcome status value: {}", [status_value]);
    //log.info("POST - Assign_Royalties - resultOutcome status value: {}", [resultOutcome.status.toValue().toString()]);
    let jsonResultData = json.try_fromString(status_value)
    
    if(jsonResultData.value != null) {
      const jsonObject = jsonResultData.value.toObject()
  
      let resultData = jsonObject.get('payout')
      if(resultData) {
        let resultObject = resultData.toObject();
        let payout_entriesLength = resultObject.entries.length;

        let salePrice = 0;
        //let royalties = BigInt.zero();
        let arrAddresses = new Array<string>();
        let arrAmounts = new Array<string>();
        for(let i = 0; i < resultObject.entries.length; i++) {
          arrAddresses.push(resultObject.entries[i].key.toString());
          arrAmounts.push(resultObject.entries[i].value.toString());

          // let user = Account.load(resultObject.entries[i].key.toString());
  
          // if account doesn't exist save new account
          // if (!user) {
          //   user = new Account(resultObject.entries[i].key.toString());
          //   log.info("ACCOUNT CREATED: {}", [user.id]);
          //   user.total_owned = BigInt.zero();
          //   user.total_transferred = BigInt.zero();
          //   user.total_royalties_received = BigInt.zero();
          // }

          //user.total_royalties_received = user.total_royalties_received.plus(resultObject.entries[i].value.toBigInt());
          //salePrice = salePrice + parseInt(resultObject.entries[i].value.toString()) as i32;

          //user.save();
        }

        //let sale = BigInt.zero();
        // for(let i = 0; i < arrAddresses.length; i++) {
        //   if(seller == json.fromString(arrAddresses[i]).toString()) {
        //     // add to royalties
        //   }
        // }

        let sale = BigInt.zero();
        for(let i = 0; i < arrAmounts.length; i++) {
          sale = sale.plus(json.fromString(arrAmounts[i]).toBigInt());
        }

        let royalty = new Royalty(`${token_id}`)
        let token = Token.load(`${token_id}`)
        if(token) {
          token.prev_sale_price = sale;
          royalty.nft = token.id;
          token.save();
        }
        royalty.tokenId = token_id;
        royalty.idx = receipt_id;
        royalty.timestamp = ts;
        royalty.payout_addresses = arrAddresses;
        royalty.payout_amounts = arrAmounts;
        //royalty.addresses = arrAddresses;
        royalty.sale_price = sale;
        royalty.associated_transfer = receipt_id;

        royalty.seller = seller;
        royalty.buyer = buyer;
        royalty.signerId = signer;
        royalty.receiverId = receiver;
        royalty.predecessorId = predecessor;

        royalty.save();
      }
    }
  }

  function update_user(address: string, remove: boolean, increaseTransferred: boolean, ts: string): void {
    let user = Account.load(address);
  
    // if account doesn't exist save new account
    if (!user) {
      user = new Account(address);
      user.total_owned = BigInt.zero();
      user.total_transferred = BigInt.zero();
    }
  
    if (remove == true) {
      user.total_owned = user.total_owned.minus(BigInt.fromI32(1));
    } else {
      user.total_owned = user.total_owned.plus(BigInt.fromI32(1));
    }

    if(increaseTransferred) {
      user.total_transferred = user.total_transferred.plus(BigInt.fromI32(1));
    }
    user.last_updated = ts;
    user.save();
  }

  let accounts = new Account(receipt.signerId);

  if (functionCall.methodName == 'nft_mint_one' || functionCall.methodName == 'nft_mint_many' || functionCall.methodName == 'link_callback' || functionCall.methodName == 'nft_mint') {
    for (let logIndex = 0; logIndex < outcome.logs.length; logIndex++) {
      let outcomeLog = outcome.logs[logIndex].toString();

      const receiptId = receipt.id.toBase58();
      accounts.signerId = receipt.signerId;

      let mint = new Mint(`${receiptId}`);

      log.info('outcomeLog {}', [outcomeLog])

      let parsed = outcomeLog.replace('EVENT_JSON:', '')

      let jsonData = json.try_fromString(parsed)
      const jsonObject = jsonData.value.toObject()

      let eventData = jsonObject.get('data')
      if (eventData) {
        let eventArray:JSONValue[] = eventData.toArray()

        let data = eventArray[0].toObject()
        const tokenIds = data.get('token_ids')
        const owner_id = data.get('owner_id')
        if (!tokenIds || !owner_id) return

        let ids:JSONValue[] = tokenIds.toArray()

        let contract = Contract.load("extinctheroes.tenk.near")

        if(!contract) {
          // for multiple contracts use --> let transactionId = account.id.concat("-").concat(event.transaction.hash.toHexString()).concat("-").concat(event.logIndex.toHexString())
          contract = new Contract("extinctheroes.tenk.near")
          contract.id = "extinctheroes.tenk.near"
          contract.name = "NEAR Extinct Heroes"
          contract.symbol = "extinctheroes"
          contract.base_uri = "https://ipfs.io/ipfs/bafybeifry66qavug4hbo2kaa5brsltcr73yeax4b6sstf2dbrlr2kj6gj4/"
          contract.media_uri = "https://ipfs.io/ipfs/bafybeifry66qavug4hbo2kaa5brsltcr73yeax4b6sstf2dbrlr2kj6gj4/"
          contract.copies = "2000"
        }

        for(let i = 0; i < ids.length; i++) {
          const receiptId = receipt.id.toBase58();
          accounts.signerId = receipt.signerId;

            // Maps the JSON formatted log to the LOG entity
          let mint = new Mint(`${receiptId}`);
          if(ids[i].toString() != "" || ids[i].toString() != null) {
            let tokenId = ids[i].toString()

            let token = Token.load(tokenId)

            if (!token) {
              token = new Token(tokenId)
              token.tokenId = tokenId

              token.image = contract.media_uri + tokenId + '.png'
              const metadata = contract.base_uri + tokenId + '.json'
              token.metadata = metadata
              token.contract = contract.id
              mint.contract = contract.id
              token.mintedBy = owner_id.toString()
              // total_mints should return 1 --> testing
              token.total_mints = token.total_mints.plus(BigInt.fromI32(1));
            }

            contract.total_minted = contract.total_minted.plus(BigInt.fromI32(1));

            mint.tokenId = tokenId
            mint.nft = token.id
            mint.total_mints = mint.total_mints.plus(BigInt.fromI32(1));
            mint.ownerId = owner_id.toString()
            mint.owner = owner_id.toString()

            token.ownerId = owner_id.toString()
            token.owner = owner_id.toString()
            token.mintedBy = owner_id.toString()

            mint.idx = receiptId.toString()
            mint.timestamp = block.header.timestampNanosec.toString()
            mint.blockHash = block.header.hash.toBase58().toString()
            mint.blockHeight = block.header.height.toString()

            token.minted_timestamp = block.header.timestampNanosec.toString()
            token.minted_blockHeight = block.header.height.toString()

            // let account = Account.load(owner_id.toString())
            // if (!account) {
            //   account = new Account(owner_id.toString())
            //   account.total_owned = BigInt.zero();
            //   account.total_transferred = BigInt.zero();
            //   account.total_royalties_received = BigInt.zero();
            // }

            accounts.total_owned = accounts.total_owned.plus(BigInt.fromI32(1));
            accounts.last_updated = mint.timestamp;
            //update_user(owner_id.toString(), false, false, mint.timestamp);

            mint.save()
            token.save()
            accounts.save()
            contract.save()
          }
        }
      }
    }
  }

  if (functionCall.methodName == "nft_transfer" || functionCall.methodName == "nft_transfer_payout") {

    const receiptId = receipt.id.toBase58();
    accounts.signerId = receipt.signerId;

      // Maps the JSON formatted log to the LOG entity
      let transfer = new Transfer(`${receiptId}`);
      if(outcome.logs[0]!=null){
        transfer.id = receiptId;
        transfer.idx = receiptId;

        log.info('unparsed outcome.logs[0] for nft_transfer -> {}', [outcome.logs[0]])
        

        let parsed = outcome.logs[0].replace('EVENT_JSON:', '')

        let jsonData = json.try_fromString(parsed)
        if(jsonData.value != null) {
          const jsonObject = jsonData.value.toObject()

          let eventStandard = jsonObject.get('standard')
          if(eventStandard) {
            if(eventStandard) {
              transfer.standard = eventStandard.toString()
            }
          }

          let eventVersion = jsonObject.get('version')
          if(eventVersion) {
            if(eventVersion) {
              transfer.version = eventVersion.toString()
            }
          }

          let eventEvent = jsonObject.get('event')
          if(eventEvent) {
            if(eventEvent) {
              transfer.event = eventEvent.toString()
            }
          }
          
          let eventData = jsonObject.get('data')
          if(eventData) {
            let eventArray:JSONValue[] = eventData.toArray()
            let data = eventArray[0].toObject()
            const authorized_id = data.get('authorized_id')
            // if authorized_id !null, then 'nft_transfer_payout'
            // then track and transfer and sale (royalties) --> only available
            // in contracts that include/emit the 'authorized_id' field in their logs
            if (authorized_id) {
              transfer.authorizedId = authorized_id.toString();
            }
            const old_owner_id = data.get('old_owner_id')
            const new_owner_id = data.get('new_owner_id')
            const tokenIds = data.get('token_ids')
            
            if (!new_owner_id || !old_owner_id || !tokenIds) return

            let contract = Contract.load("extinctheroes.tenk.near")

          if(!contract) {
            //let transactionId = account.id.concat("-").concat(event.transaction.hash.toHexString()).concat("-").concat(event.logIndex.toHexString())
            contract = new Contract("extinctheroes.tenk.near")
            contract.id = "extinctheroes.tenk.near"
            contract.name = "NEAR Extinct Heroes"
            contract.symbol = "extinctheroes"
            contract.base_uri = "https://ipfs.io/ipfs/bafybeifry66qavug4hbo2kaa5brsltcr73yeax4b6sstf2dbrlr2kj6gj4/"
            contract.media_uri = "https://ipfs.io/ipfs/bafybeifry66qavug4hbo2kaa5brsltcr73yeax4b6sstf2dbrlr2kj6gj4/"
            contract.copies = "2000"
          }

            const ids:JSONValue[] = tokenIds.toArray()
            const tokenId = ids[0].toString()

            let token = Token.load(tokenId)

            if(token) {
              transfer.idx = receiptId.toString()
              token.ownerId = new_owner_id.toString()
              token.owner = new_owner_id.toString()
              transfer.nft = token.id
              transfer.tokenId = token.id

              transfer.old_ownerId = old_owner_id.toString();
              transfer.new_ownerId = new_owner_id.toString();
              transfer.from = old_owner_id.toString();
              transfer.to = new_owner_id.toString();

              token.total_transfers = token.total_transfers.plus(BigInt.fromI32(1));
            }

            if (!token) {
              token = new Token(tokenId)
              token.tokenId = tokenId

              // exclusive to transfer event
              token.standard = transfer.standard
              token.version = transfer.version
              
              token.image = contract.media_uri + tokenId + '.png'
              const metadata = contract.base_uri + tokenId + '.json'
              token.metadata = metadata
              token.contract = contract.id
              token.ownerId = new_owner_id.toString()
              token.owner = new_owner_id.toString()
              transfer.nft = token.id
              transfer.tokenId = token.id
              token.total_transfers = token.total_transfers.plus(BigInt.fromI32(1));
            }

            transfer.old_ownerId = old_owner_id.toString();
            transfer.new_ownerId = new_owner_id.toString();
            transfer.from = old_owner_id.toString();
            transfer.to = new_owner_id.toString();
            token.prev_ownerId = old_owner_id.toString();

            transfer.timestamp = block.header.timestampNanosec.toString();

            // added 3rd param to increase total number of transfers
            update_user(new_owner_id.toString(), false, true, transfer.timestamp);
            update_user(old_owner_id.toString(), true, true, transfer.timestamp);

            
            if(functionCall.methodName == "nft_transfer") {
              transfer.is_marketSale = "false";
            }
            if(functionCall.methodName == "nft_transfer_payout") {
              transfer.is_marketSale = "true";
              assign_royalties(outcome.status.toValue().toString(),
               receipt.id.toBase58(),
               tokenId,
               old_owner_id.toString(),
               new_owner_id.toString(),
               receipt.signerId,
               receipt.receiverId,
               receipt.predecessorId,
               transfer.timestamp)
            }
            token.save()
            contract.save()
          }
        }
        transfer.save()
      }
      
  } else {
    log.info("Not processed - FunctionCall is: {}", [functionCall.methodName]);
  }
  accounts.save();
}
'''
'''--- subgraphs/tenkbay/template-collection/src/mapping.ts ---
import { near, log, json, JSONValueKind, JSONValue, BigInt, ByteArray } from "@graphprotocol/graph-ts";
import { Account, Token, Contract, Transfer, Mint } from "../generated/schema";

export function handleReceipt(receipt: near.ReceiptWithOutcome): void {
  const actions = receipt.receipt.actions;
  
  for (let i = 0; i < actions.length; i++) {
    handleAction(
      actions[i], 
      receipt.receipt, 
      receipt.block.header,
      receipt.outcome
      );
  }
}

function handleAction(
  action: near.ActionValue,
  receipt: near.ActionReceipt,
  blockHeader: near.BlockHeader,
  outcome: near.ExecutionOutcome
): void {
  
  if (action.kind != near.ActionKind.FUNCTION_CALL) {
    log.info("Early return: {}", ["Not a function call"]);
    return;
  }

  

  function update_user(address: string, remove: boolean, increaseTransferred: boolean, ts: string): void {
    let user = Account.load(address);
  
    // if account doesn't exist save new account
    if (!user) {
      user = new Account(address);
      user.total_owned = BigInt.zero();
      user.total_transferred = BigInt.zero();
    }
  
    if (remove == true) {
      user.total_owned = user.total_owned.minus(BigInt.fromI32(1));
    } else {
      user.total_owned = user.total_owned.plus(BigInt.fromI32(1));
    }

    if(increaseTransferred) {
      user.total_transferred = user.total_transferred.plus(BigInt.fromI32(1));
    }
    user.last_updated = ts;
    user.save();
  }

  let accounts = new Account(receipt.signerId);
  const functionCall = action.toFunctionCall();

  if (functionCall.methodName == 'nft_mint_many' || functionCall.methodName == 'nft_mint_one') {
    for (let logIndex = 0; logIndex < outcome.logs.length; logIndex++) {
      let outcomeLog = outcome.logs[logIndex].toString();

      const receiptId = receipt.id.toBase58();
      accounts.signerId = receipt.signerId;

      let mint = new Mint(`${receiptId}`);

      log.info('outcomeLog {}', [outcomeLog])

      let parsed = outcomeLog.replace('EVENT_JSON:', '')

      let jsonData = json.try_fromString(parsed)
      const jsonObject = jsonData.value.toObject()

      let eventData = jsonObject.get('data')
      if (eventData) {
        let eventArray:JSONValue[] = eventData.toArray()

        let data = eventArray[0].toObject()
        const tokenIds = data.get('token_ids')
        const owner_id = data.get('owner_id')
        if (!tokenIds || !owner_id) return

        let ids:JSONValue[] = tokenIds.toArray()

        let contract = Contract.load("mrbrownproject.near")

        if(!contract) {
          //let transactionId = account.id.concat("-").concat(event.transaction.hash.toHexString()).concat("-").concat(event.logIndex.toHexString())
          contract = new Contract("mrbrownproject.near")
          contract.id = "mrbrownproject.near"
          contract.name = "MR. BROWN"
          contract.symbol = "MRBRN"
          contract.base_uri = "https://mrbrown.nftapi.art/meta/"
          contract.media_uri = "https://cloudflare-ipfs.com/ipfs/QmP3shtToBeoeHizRtvgUPJTeGbcVn2rdZhERSwEiQHtJh/"
        }

        for(let i = 0; i < ids.length; i++) {
          const receiptId = receipt.id.toBase58();
          accounts.signerId = receipt.signerId;

            // Maps the JSON formatted log to the LOG entity
          let mint = new Mint(`${receiptId}`);
          if(ids[i].toString() != "" || ids[i].toString() != null) {
            let tokenId = ids[i].toString()

            let token = Token.load(tokenId)

            if (!token) {
              token = new Token(tokenId)
              token.tokenId = tokenId
              // exclusive to mint

              token.image = contract.media_uri + tokenId + '.png'
              const metadata = contract.base_uri + tokenId + '.json'
              token.metadata = metadata
              token.contract = contract.id
              mint.contract = contract.id
              token.mintedBy = owner_id.toString()
              // total_mints should return 1 --> testing
              token.total_mints = token.total_mints.plus(BigInt.fromI32(1));
            }

            contract.total_minted = contract.total_minted.plus(BigInt.fromI32(1));

            mint.tokenId = tokenId
            mint.nft = token.id
            mint.total_mints = mint.total_mints.plus(BigInt.fromI32(1));
            mint.ownerId = owner_id.toString()
            mint.owner = owner_id.toString()

            token.ownerId = owner_id.toString()
            token.owner = owner_id.toString()
            token.mintedBy = owner_id.toString()

            mint.idx = receiptId.toString()
            mint.timestamp = blockHeader.timestampNanosec.toString()
            mint.blockHash = blockHeader.hash.toBase58().toString()
            mint.blockHeight = blockHeader.height.toString()

            token.minted_timestamp = blockHeader.timestampNanosec.toString()
            token.minted_blockHeight = blockHeader.height.toString()

            let account = Account.load(owner_id.toString())
            if (!account) {
              account = new Account(receipt.signerId)
            }

            mint.save()
            token.save()
            account.save()
            contract.save()
          }
        }
      }
    }
  }

  // change the methodName here to the methodName emitting the log in the contract
  if (functionCall.methodName == "nft_transfer" || functionCall.methodName == "nft_transfer_payout") {
    const receiptId = receipt.id.toBase58();
    accounts.signerId = receipt.signerId;

      // Maps the JSON formatted log to the LOG entity
      let transfer = new Transfer(`${receiptId}`);
      if(outcome.logs[0]!=null){
        transfer.id = receiptId;
        transfer.idx = receiptId;

        log.info('unparsed outcome.logs[0] for nft_transfer -> {}', [outcome.logs[0]])
        

        let parsed = outcome.logs[0].replace('EVENT_JSON:', '')

        let jsonData = json.try_fromString(parsed)
        if(jsonData.value != null) {
          const jsonObject = jsonData.value.toObject()

          let eventStandard = jsonObject.get('standard')
          if(eventStandard) {
            if(eventStandard) {
              transfer.standard = eventStandard.toString()
            }
          }

          let eventVersion = jsonObject.get('version')
          if(eventVersion) {
            if(eventVersion) {
              transfer.version = eventVersion.toString()
            }
          }

          let eventEvent = jsonObject.get('event')
          if(eventEvent) {
            if(eventEvent) {
              transfer.event = eventEvent.toString()
            }
          }

          let eventData = jsonObject.get('data')
          if(eventData) {
            let eventArray:JSONValue[] = eventData.toArray()
            let data = eventArray[0].toObject()
            const authorized_id = data.get('authorized_id')
            if (authorized_id) {
              transfer.authorizedId = authorized_id.toString();
            }
            const old_owner_id = data.get('old_owner_id')
            const new_owner_id = data.get('new_owner_id')
            const tokenIds = data.get('token_ids')
            
            if (!new_owner_id || !old_owner_id || !tokenIds) return

            let contract = Contract.load("mrbrownproject.near")

            if(!contract) {
              //let transactionId = account.id.concat("-").concat(event.transaction.hash.toHexString()).concat("-").concat(event.logIndex.toHexString())
              contract = new Contract("mrbrownproject.near")
              contract.id = "mrbrownproject.near"
              contract.name = "MR. BROWN"
              contract.symbol = "MRBRN"
              contract.base_uri = "https://mrbrown.nftapi.art/meta/"
              contract.media_uri = "https://cloudflare-ipfs.com/ipfs/QmP3shtToBeoeHizRtvgUPJTeGbcVn2rdZhERSwEiQHtJh/"
            }

            const ids:JSONValue[] = tokenIds.toArray()
            const tokenId = ids[0].toString()

            let token = Token.load(tokenId)

            if(token) {
              transfer.idx = receiptId.toString()
              token.ownerId = new_owner_id.toString()
              token.owner = new_owner_id.toString()
              transfer.nft = token.id
              transfer.tokenId = token.id

              transfer.old_ownerId = old_owner_id.toString();
              transfer.new_ownerId = new_owner_id.toString();
              transfer.from = old_owner_id.toString();
              transfer.to = new_owner_id.toString();

              token.total_transfers = token.total_transfers.plus(BigInt.fromI32(1));
            }

            if (!token) {
              token = new Token(tokenId)
              token.tokenId = tokenId

              // exclusive to transfer event
              token.standard = transfer.standard
              token.version = transfer.version
              
              token.image = contract.media_uri + tokenId + '.png'
              const metadata = contract.base_uri + tokenId + '.json'
              token.metadata = metadata
              token.contract = contract.id
              token.ownerId = new_owner_id.toString()
              token.owner = new_owner_id.toString()
              transfer.nft = token.id
              transfer.tokenId = token.id
              token.total_transfers = token.total_transfers.plus(BigInt.fromI32(1));
            }

            transfer.old_ownerId = old_owner_id.toString();
            transfer.new_ownerId = new_owner_id.toString();
            transfer.from = old_owner_id.toString();
            transfer.to = new_owner_id.toString();

            transfer.timestamp = blockHeader.timestampNanosec.toString();
            //blockHeader.hash
            // added 3rd param to increase total number of transfers
            update_user(new_owner_id.toString(), false, true, transfer.timestamp);
            update_user(old_owner_id.toString(), true, true, transfer.timestamp);

            token.save()
            contract.save()
          }
        }
        transfer.save()
      }
      
  } else {
    log.info("Not processed - FunctionCall is: {}", [functionCall.methodName]);
  }

  accounts.save();
}
'''
'''--- utils/README.md ---
# **NEAR Query Tooling**

'''
'''--- utils/package copy.json ---
{
  "name": "utils",
  "version": "1.0.0",
  "description": "tooling for debugging nft collections for subgraphs on NEAR",
  "main": "./utils/scripts/view-contract-methods.js",
  "scripts": {
    "test": "node ./scripts/TEMPLATES/view-contract-methods.js"
  },
  "keywords": [],
  "author": "Ryan Strawser",
  "license": "ISC",
  "dependencies": {
    "near-api-js": "^0.44.2",
    "near-contract-parser": "^0.1.4"
  }
}

//"node ./scripts/TEMPLATES/view-contract-methods.js"

'''
'''--- utils/package.json ---
{
  "name": "utils",
  "version": "1.0.0",
  "description": "tooling for debugging nft collections for subgraphs on NEAR",
  "main": "./scripts/TEMPLATES/view-contract-methods.js",
  "scripts": {
    "test": "node ./scripts/TEMPLATES/view-contract-methods.js"
  },
  "keywords": [],
  "author": "Ryan Strawser",
  "license": "ISC",
  "dependencies": {
    "near-api-js": "^0.44.2",
    "near-contract-parser": "^0.1.4"
  }
}

'''
'''--- utils/scripts/TEMPLATES/view-contract-methods.js ---
const { Near, keyStores } = require("near-api-js");
const { parseContract } = require("near-contract-parser");

const near = new Near({
  networkId: "mainnet",
  keyStore: new keyStores.InMemoryKeyStore(),
  nodeUrl: "https://rpc.mainnet.near.org",
  archivalUrl: "https://archival-rpc.mainnet.near.org",
  walletUrl: "https://wallet.mainnet.near.org",
  helperUrl: "https://helper.mainnet.near.org",
  explorerUrl: "https://explorer.mainnet.near.org",
});

(async () => {
  const account_id = "futurenft.near";
  const { code_base64 } = await near.connection.provider.query({
    account_id,
    finality: "final",
    request_type: "view_code",
  });

  console.log(parseContract(code_base64));
})();

'''
'''--- utils/scripts/TEMPLATES/view-nft-metadata.js ---
const { providers } = require("near-api-js");
const provider = new providers.JsonRpcProvider("https://rpc.mainnet.near.org");

getState();

async function getState() {
  const raw_nft_token = await provider.query({
    request_type: "call_function",
    account_id: "futurenft.near",
    method_name: "nft_metadata",
    args_base64: "e30=",
    finality: "optimistic",
  });

  const res = JSON.parse(Buffer.from(raw_nft_token.result).toString());
  console.log(res);
}

'''
'''--- utils/scripts/TEMPLATES/view-nft-token.js ---
const { providers } = require("near-api-js");
const provider = new providers.JsonRpcProvider("https://rpc.mainnet.near.org");

getState();

async function getState() {
  const raw_nft_token = await provider.query({
    request_type: "call_function",
    account_id: "futurenft.near",
    method_name: "nft_token",
    // {"token_id":"101"} base64 encoded
    args_base64: "eyJ0b2tlbl9pZCI6Ijk3MiJ9",
    finality: "optimistic",
  });

  const res = JSON.parse(Buffer.from(raw_nft_token.result).toString());
  console.log(res);
}

'''
'''--- utils/scripts/TEMPLATES/view-tx-details-in-range.js ---
const { connect, keyStores } = require("near-api-js");
const path = require("path");
const homedir = require("os").homedir();

const CREDENTIALS_DIR = ".near-credentials";
// block hash of query start (oldest block)
const START_BLOCK_HASH = "EUUE9ZjhpEpKDiJpefFmsDENBHbfUiY5Y6hq6mbGzQVG";
// block hash of query end (newest block)
const END_BLOCK_HASH = "ABW9GJk9yuA3C6HwdnBjd9EDRPFf6H6XkCNu1CbopN8w";
// contract ID or account ID you want to find transactions details for
const CONTRACT_ID = "futurenft.near";

const credentialsPath = path.join(homedir, CREDENTIALS_DIR);
const keyStore = new keyStores.InMemoryKeyStore();

// NOTE: we're using the archival rpc to look back in time for a specific set
// of transactions. For a full list of what nodes are available, visit:
// https://docs.near.org/docs/develop/node/intro/types-of-node
const config = {
  keyStore,
  networkId: "mainnet",
  nodeUrl: "https://archival-rpc.mainnet.near.org",
};

getTransactions(START_BLOCK_HASH, END_BLOCK_HASH, CONTRACT_ID);

async function getTransactions(startBlock, endBlock, accountId) {
  const near = await connect(config);

  // creates an array of block hashes for given range
  const blockArr = [];
  let blockHash = endBlock;
  do {
    const currentBlock = await getBlockByID(blockHash);
    blockArr.push(currentBlock.header.hash);
    blockHash = currentBlock.header.prev_hash;
    console.log("working...", blockHash);
  } while (blockHash !== startBlock);

  // returns block details based on hashes in array
  const blockDetails = await Promise.all(
    blockArr.map((blockId) =>
      near.connection.provider.block({
        blockId,
      })
    )
  );

  // returns an array of chunk hashes from block details
  const chunkHashArr = blockDetails.flatMap((block) =>
    block.chunks.map(({ chunk_hash }) => chunk_hash)
  );

  //returns chunk details based from the array of hashes
  const chunkDetails = await Promise.all(
    chunkHashArr.map((chunk) => near.connection.provider.chunk(chunk))
  );

  // checks chunk details for transactions
  // if there are transactions in the chunk we
  // find ones associated with passed accountId
  const transactions = chunkDetails.flatMap((chunk) =>
    (chunk.transactions || []).filter((tx) => tx.signer_id === accountId)
  );

  //creates transaction links from matchingTxs
  const txsLinks = transactions.map((txs) => ({
    method: txs.actions[0].FunctionCall.method_name,
    link: `https://explorer.mainnet.near.org/transactions/${txs.hash}`,
  }));
  console.log("MATCHING TRANSACTIONS: ", transactions);
  console.log("TRANSACTION LINKS: ", txsLinks);
}

async function getBlockByID(blockID) {
  const near = await connect(config);
  const blockInfoByHeight = await near.connection.provider.block({
    blockId: blockID,
  });
  return blockInfoByHeight;
}

'''
'''--- utils/scripts/extinctheroes/contract-methods.js ---
const { Near, keyStores } = require('near-api-js');
const { parseContract } = require('near-contract-parser');

const near = new Near({
  networkId: 'mainnet',
  keyStore: new keyStores.InMemoryKeyStore(),
  nodeUrl: 'https://rpc.mainnet.near.org',
  archivalUrl: 'https://archival-rpc.mainnet.near.org',
  walletUrl: 'https://wallet.mainnet.near.org',
  helperUrl: 'https://helper.mainnet.near.org',
  explorerUrl: 'https://explorer.mainnet.near.org',
});

(async () => {
  const account_id = 'extinctheroes.tenk.near';
  const { code_base64 } = await near.connection.provider.query({
    account_id,
    finality: 'final',
    request_type: 'view_code',
  });

  console.log(parseContract(code_base64));
})();
'''
'''--- utils/scripts/extinctheroes/nft-metadata.js ---
const { providers } = require("near-api-js");
const provider = new providers.JsonRpcProvider("https://rpc.mainnet.near.org");

getState();

async function getState() {

  const raw_nft_token = await provider.query({
    request_type: "call_function",
    account_id: "extinctheroes.tenk.near",
    method_name: "nft_metadata",
    args_base64: "e30=",
    finality: "optimistic",
  });

  const res = JSON.parse(Buffer.from(raw_nft_token.result).toString());
  console.log(res);
}
'''
'''--- utils/scripts/extinctheroes/nft-token.js ---
const { providers } = require("near-api-js");
const provider = new providers.JsonRpcProvider("https://rpc.mainnet.near.org");

getState();

async function getState() {

  const raw_nft_token = await provider.query({
    request_type: "call_function",
    account_id: "extinctheroes.tenk.near",
    method_name: "nft_token",
    // {"token_id":"101"} base64 encoded
    args_base64: "eyJ0b2tlbl9pZCI6IjEifQ==",
    finality: "optimistic",
  });

  const res = JSON.parse(Buffer.from(raw_nft_token.result).toString());
  console.log(res);
}
'''
'''--- utils/scripts/misfits/README.md ---

'''
'''--- utils/scripts/misfits/contract-methods.js ---
const { Near, keyStores } = require('near-api-js');
const { parseContract } = require('near-contract-parser');

const near = new Near({
  networkId: 'mainnet',
  keyStore: new keyStores.InMemoryKeyStore(),
  nodeUrl: 'https://rpc.mainnet.near.org',
  archivalUrl: 'https://archival-rpc.mainnet.near.org',
  walletUrl: 'https://wallet.mainnet.near.org',
  helperUrl: 'https://helper.mainnet.near.org',
  explorerUrl: 'https://explorer.mainnet.near.org',
});

(async () => {
  const account_id = 'misfits.tenk.near';
  const { code_base64 } = await near.connection.provider.query({
    account_id,
    finality: 'final',
    request_type: 'view_code',
  });

  console.log(parseContract(code_base64));
})();
'''
'''--- utils/scripts/misfits/nft-metadata.js ---
const { providers } = require("near-api-js");
const provider = new providers.JsonRpcProvider("https://rpc.mainnet.near.org");

getState();

async function getState() {

  const raw_nft_token = await provider.query({
    request_type: "call_function",
    account_id: "misfits.tenk.near",
    method_name: "nft_metadata",
    args_base64: "e30=",
    finality: "optimistic",
  });

  const res = JSON.parse(Buffer.from(raw_nft_token.result).toString());
  console.log(res);
}
'''
'''--- utils/scripts/mrbrownproject/contract-methods.js ---
const { Near, keyStores } = require('near-api-js');
const { parseContract } = require('near-contract-parser');

const near = new Near({
  networkId: 'mainnet',
  keyStore: new keyStores.InMemoryKeyStore(),
  nodeUrl: 'https://rpc.mainnet.near.org',
  archivalUrl: 'https://archival-rpc.mainnet.near.org',
  walletUrl: 'https://wallet.mainnet.near.org',
  helperUrl: 'https://helper.mainnet.near.org',
  explorerUrl: 'https://explorer.mainnet.near.org',
});

(async () => {
  const account_id = 'mrbrownproject.near';
  const { code_base64 } = await near.connection.provider.query({
    account_id,
    finality: 'final',
    request_type: 'view_code',
  });

  console.log(parseContract(code_base64));
})();
'''
'''--- utils/scripts/mrbrownproject/nft-metadata.js ---
const { providers } = require("near-api-js");
const provider = new providers.JsonRpcProvider("https://rpc.mainnet.near.org");

getState();

async function getState() {

  const raw_nft_token = await provider.query({
    request_type: "call_function",
    account_id: "mrbrownproject.near",
    method_name: "nft_metadata",
    args_base64: "e30=",
    finality: "optimistic",
  });

  const res = JSON.parse(Buffer.from(raw_nft_token.result).toString());
  console.log(res);
}
'''
'''--- utils/scripts/mrbrownproject/nft-token.js ---
const { providers } = require("near-api-js");
const provider = new providers.JsonRpcProvider("https://rpc.mainnet.near.org");

getState();

async function getState() {

  const raw_nft_token = await provider.query({
    request_type: "call_function",
    account_id: "mrbrownproject.near",
    method_name: "nft_token",
    // {"token_id":"101"} base64 encoded
    args_base64: "eyJ0b2tlbl9pZCI6Ijk3MiJ9",
    finality: "optimistic",
  });

  const res = JSON.parse(Buffer.from(raw_nft_token.result).toString());
  console.log(res);
}
'''
'''--- utils/scripts/tenk-dao/contract-methods.js ---
const { Near, keyStores } = require('near-api-js');
const { parseContract } = require('near-contract-parser');

const near = new Near({
  networkId: 'mainnet',
  keyStore: new keyStores.InMemoryKeyStore(),
  nodeUrl: 'https://rpc.mainnet.near.org',
  archivalUrl: 'https://archival-rpc.mainnet.near.org',
  walletUrl: 'https://wallet.mainnet.near.org',
  helperUrl: 'https://helper.mainnet.near.org',
  explorerUrl: 'https://explorer.mainnet.near.org',
});

(async () => {
  const account_id = 'tenk.sputnik-dao.near';
  const { code_base64 } = await near.connection.provider.query({
    account_id,
    finality: 'final',
    request_type: 'view_code',
  });

  console.log(parseContract(code_base64));
})();
'''
'''--- utils/scripts/tenk-dao/get-policy.js ---
const { providers } = require("near-api-js");
const provider = new providers.JsonRpcProvider("https://rpc.mainnet.near.org");

getState();

async function getState() {

  const raw_nft_token = await provider.query({
    request_type: "call_function",
    account_id: "tenk.sputnik-dao.near",
    method_name: "get_policy",
    args_base64: "e30=",
    finality: "optimistic",
  });

  const res = JSON.parse(Buffer.from(raw_nft_token.result).toString());
  console.log(res);
  //console.log(res.roles)
  //console.log(res.roles[0].kind.Group[0])
}
'''
'''--- utils/scripts/tenk-dao/get-tx-results.js ---
const { providers } = require("near-api-js");

//network config (replace testnet with mainnet or betanet)
const provider = new providers.JsonRpcProvider(
  "https://archival-rpc.mainnet.near.org"
);

const TX_HASH = "3HcPCmtQJJFVLjKph8HDEwheyCZFVy8p2DdwJRFjQ5YF";
// account ID associated with the transaction
const ACCOUNT_ID = "mrbrownproject.near";

getState(TX_HASH, ACCOUNT_ID);

async function getState(txHash, accountId) {
  const result = await provider.txStatus(txHash, accountId);
  //console.log("Result: ", result);
  //console.log("transaction outcome: ", result.transaction_outcome)
  //console.log("receipts outcome: ", result.receipts_outcome)
  //console.log("receipts proofs 0: ", result.receipts_outcome[0].proof)

  for(let i = 0; i < result.receipts_outcome.length; i++) {
    console.log(`receipt ID ${i}: `, result.receipts_outcome[i].id)
    console.log(`receipt proof ${i}: `, result.receipts_outcome[i].proof)
    console.log(`receipt outcome ids ${i}: `, result.receipts_outcome[i].outcome.receipt_ids)
    console.log(`receipts outcome logs ${i}: `, result.receipts_outcome[i].outcome.logs)
    console.log(`receipts outcome status ${i}: `, result.receipts_outcome[i].outcome.status)
  }
}
'''
'''--- utils/scripts/tenk-dao/tx-details.js ---
const { connect, keyStores } = require("near-api-js");
const path = require("path");
const homedir = require("os").homedir();

const CREDENTIALS_DIR = ".near-credentials";
// block hash of query start (oldest block)
const START_BLOCK_HASH = "6xNx43qTzmheXQiMmaZsa33BrmG41xjgmngnxGmve9cz"/*"91qswtoVPTzyuEH8xFSa4yASJHsSzN25tT8BrRtRqeHq"*/;
// block hash of query end (newest block)
const END_BLOCK_HASH = "2cn2es3Xcjk4uHFW2RS1972Mz3YabB7oUrsEchb7cLGw"/*"Az9YXjRgA475CAVzEJwovZgkY5nxTfVrNdqP6mMS3XnF"*/;
// contract ID or account ID you want to find transactions details for
const CONTRACT_ID = "tenk.sputnik-dao.near";

const credentialsPath = path.join(homedir, CREDENTIALS_DIR);
const keyStore = new keyStores.UnencryptedFileSystemKeyStore(credentialsPath);

// NOTE: we're using the archival rpc to look back in time for a specific set
// of transactions. For a full list of what nodes are available, visit:
// https://docs.near.org/docs/develop/node/intro/types-of-node
//https://rpc.mainnet.near.org
//https://archival-rpc.mainnet.near.org
const config = {
  keyStore,
  networkId: "mainnet",
  nodeUrl: "https://archival-rpc.mainnet.near.org",
};

getTransactions(START_BLOCK_HASH, END_BLOCK_HASH, CONTRACT_ID);

async function getTransactions(startBlock, endBlock, accountId) {
  const near = await connect(config);

  // creates an array of block hashes for given range
  const blockArr = [];
  let blockHash = endBlock;
  do {
    const currentBlock = await getBlockByID(blockHash);
    blockArr.push(currentBlock.header.hash);
    blockHash = currentBlock.header.prev_hash;
    console.log("working...", blockHash);
  } while (blockHash !== startBlock);

  // returns block details based on hashes in array
  const blockDetails = await Promise.all(
    blockArr.map((blockId) =>
      near.connection.provider.block({
        blockId,
      })
    )
  );

  // returns an array of chunk hashes from block details
  const chunkHashArr = blockDetails.flatMap((block) =>
    block.chunks.map(({ chunk_hash }) => chunk_hash)
  );

  //returns chunk details based from the array of hashes
  const chunkDetails = await Promise.all(
    chunkHashArr.map(chunk => near.connection.provider.chunk(chunk))
  );

  // checks chunk details for transactions
  // if there are transactions in the chunk we
  // find ones associated with passed accountId
  const transactions = chunkDetails.flatMap((chunk) =>
    (chunk.transactions || []).filter((tx) => tx.signer_id === accountId)
  );

  //creates transaction links from matchingTxs
  const txsLinks = transactions.map((txs) => ({
    method: txs.actions[0].FunctionCall.method_name,
    link: `https://explorer.mainnet.near.org/transactions/${txs.hash}`,
    actions: `${JSON.stringify(txs.actions[0])}`,
    block_hash: `${txs.block_hash}`,
  }));
  console.log("MATCHING TRANSACTIONS: ", transactions);
  console.log("TRANSACTION LINKS: ", txsLinks);
}

async function getBlockByID(blockID) {
  const near = await connect(config);
  const blockInfoByHeight = await near.connection.provider.block({
    blockId: blockID,
  });
  return blockInfoByHeight;
}
'''
'''--- utils/scripts/tigeracademy/contract-methods.js ---
const { Near, keyStores } = require('near-api-js');
const { parseContract } = require('near-contract-parser');

const near = new Near({
  networkId: 'mainnet',
  keyStore: new keyStores.InMemoryKeyStore(),
  nodeUrl: 'https://rpc.mainnet.near.org',
  archivalUrl: 'https://archival-rpc.mainnet.near.org',
  walletUrl: 'https://wallet.mainnet.near.org',
  helperUrl: 'https://helper.mainnet.near.org',
  explorerUrl: 'https://explorer.mainnet.near.org',
});

(async () => {
  const account_id = 'tigeracademy.near';
  const { code_base64 } = await near.connection.provider.query({
    account_id,
    finality: 'final',
    request_type: 'view_code',
  });

  console.log(parseContract(code_base64));
})();
'''
'''--- utils/scripts/tigeracademy/nft-metadata.js ---
const { providers } = require("near-api-js");
const provider = new providers.JsonRpcProvider("https://rpc.mainnet.near.org");

getState();

async function getState() {

  const raw_nft_token = await provider.query({
    request_type: "call_function",
    account_id: "tigeracademy.near",
    method_name: "nft_metadata",
    args_base64: "e30=",
    finality: "optimistic",
  });

  const res = JSON.parse(Buffer.from(raw_nft_token.result).toString());
  console.log(res);
}
'''