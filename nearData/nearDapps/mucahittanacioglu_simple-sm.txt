*GitHub Repository "mucahittanacioglu/simple-sm"*

'''--- README.md ---
Here I tried to simulate simple social media.I have used [near-starter-sdk](https://github.com/Learn-NEAR/starter--near-sdk-as) project as template.
You can create topic and people can comment on that it is basic structure but can be extendable such as adding like,emotion,even multimedia if storing is not problem.
I used PersistentVector for storing topics and comments.
Each topic has its comment array and there is one global topic array.
I used context from nearSDK for attached deposit and id of people.

[Loom Video Link](https://www.loom.com/embed/c4a93dc039f74692bb737f7dcc1ec5a6)

**Commands**

Single command was enough for me **"build:release:deploy": "asb && near dev-deploy ./build/release/simple.wasm"**.You can just write **yarn build:release:deploy** and its ready on dev account.
Here some interactions
```javascript
export CONTRACT_F=dev-blabla
export CONTRACT_S=someone.testnet

near view $CONTRACT_F get_topics
near call $CONTRACT_F create_topic '{"name":"testing"}' --accountId $CONTRACT_F
near call $CONTRACT_F add_comment_to_topic '{"topic_name":"testing","comment":"My first comment from dev-blabla"}' --accountId $CONTRACT_F
near call $CONTRACT_F get_comments_on_topic '{"topic_name":"testing"}' --accountId $CONTRACT_S
```
There is also shell scripts for each function, scripts are staight forward and interactive.

**Functions**

**a-) get_topics**
Function that returns last TOPIC_VIEW_LIMIT topics.
```javascript 
export function get_topics(): Array<Topic> {
  const number_of_topic = min(TOPIC_VIEW_LIMIT, topics.length)
  const starting_idx = topics.length - number_of_topic
  const result = new Array<Topic>(number_of_topic)
  
  for(let i = 0; i < number_of_topic; i++) {
    result[i] = topics[i + starting_idx]
  }
  return result
}
```
**b-) create_topic**
Function to create new topic.
```javascript 
export function create_topic(name:string): void {
  assert(!is_topic_exist(name), "Topic already created!")
  const topic = new Topic(name)
  topics.push(topic)
}
```
**c-) add_comment_to_topic**
Function to create add new comment to existing topic.
```javascript 
export function add_comment_to_topic(topic_name:string,comment:string): void {
  assert(comment.length < MAX_COMMENT_LENGTH_LIMIT,`Comment too long max ${MAX_COMMENT_LENGTH_LIMIT} char!`)
  assert(topics.length > 0 , "There is no topic created yet!")
  assert(is_topic_exist(topic_name),"Topic does not exist!")
  
  const topic_ = find_topic(topic_name)
  assert(!(topic_.is_premium && context.attachedDeposit < ONE_NEAR), "Its a premium topic you need to attach at least 1 near!")
  topic_.add_comment(new Comment(context.sender,comment))
}
```
**d-) get_comments_on_topic**
Function to retrieve last COMMENT_VIEW_LIMIT comment on existing topic.
```javascript 
export function get_comments_on_topic(topic_name:string): Array<Comment> {
  assert(is_topic_exist(topic_name),"Topic does not exist!")
  const topic_ = find_topic(topic_name)

  const number_of_comments = min(COMMENT_VIEW_LIMIT, topic_.comments.length)
  const starting_idx = topic_.comments.length - number_of_comments
  const result = new Array<Comment>(number_of_comments)
  
  for(let i = 0; i < number_of_comments; i++) {
    result[i] = topic_.comments[i + starting_idx]
  }
  return result
}
```

**Classes**

We can add more specific data here like date,view count,maybe donation box etc.
```javascript 
@nearBindgen
export class Topic{
  name:string
  comments:PersistentVector<Comment>
  is_premium:boolean
  constructor(t_name:string){
    this.name = t_name
    this.comments = new PersistentVector<Comment>("c")
    this.is_premium = context.attachedDeposit >= ONE_NEAR
  }
  add_comment(comment:Comment): void {
    this.comments.push(comment)
  }
}

@nearBindgen
export class Comment{
  user:string
  comment:string
  constructor(account:string, comment_:string){
    this.user = account
    this.comment = comment_
  }
}
``` 

'''
'''--- as-pect.config.js ---
module.exports = require("near-sdk-as/imports");
'''
'''--- asconfig.json ---
{
  "workspaces": [
    "src/simple"
  ]
}

'''
'''--- package.json ---
{
  "name": "starter--near-sdk-as",
  "version": "0.0.1",
  "description": "Start with a basic project",
  "scripts": {
    "build:release:deploy": "asb && near dev-deploy ./build/release/simple.wasm"
  },
  "keywords": [],
  "author": "hello@near.org",
  "license": "ISC",
  "devDependencies": {
    "near-sdk-as": "^3.1.0"
  }
}

'''
'''--- scripts/add_comment_on_topic.sh ---
#!/bin/bash

echo 'Please enter near account:'

read ACCOUNT

echo 'Please enter topic you want to comment on:'

read -r TOPIC_NAME

echo 'Please enter your comment:'

read -r COMMENT

eval "near call legalalien.testnet add_comment_to_topic '{\"topic_name\":\"$TOPIC_NAME\",\"comment\":\"$COMMENT\"}' --accountId $ACCOUNT"
'''
'''--- scripts/create_topic.sh ---
#!/bin/bash

echo 'Please enter near account:'

read ACCOUNT

echo 'Calling with account $ACCOUNT'

echo 'Please enter topic name:'
read -r TOPIC_NAME

eval "near call legalalien.testnet create_topic '{\"name\":\"$TOPIC_NAME\"}' --accountId $ACCOUNT"
'''
'''--- scripts/get_comment_on_topic.sh ---
#!/bin/bash

echo 'Please enter account near account:'

read ACCOUNT

echo 'Please enter topic name:'
read -r TOPIC_NAME

echo "Calling function to view comments on ${TOPIC_NAME} with account {$ACCOUNT}"

eval "near call legalalien.testnet get_comments_on_topic '{\"topic_name\":\"$TOPIC_NAME\"}' --accountId $ACCOUNT"
'''
'''--- scripts/view_topics.sh ---
#!/bin/bash

echo 'Topics stored on blockchain are below:'

near view legalalien.testnet get_topics
'''
'''--- src/as_types.d.ts ---
/// <reference types="near-sdk-as/assembly/as_types" />
'''
'''--- src/simple/asconfig.json ---
{
  "extends": "near-sdk-as/asconfig.json"
}

'''
'''--- src/simple/assembly/index.ts ---
import { context,logging} from "near-sdk-as"
import {topics,Topic,Comment} from "./model"
import { ONE_NEAR } from "../../utils"
// variable holds topics and comments within

//constants
const TOPIC_VIEW_LIMIT = 10
const COMMENT_VIEW_LIMIT = 10
const MAX_COMMENT_LENGTH_LIMIT = 100

//function returns last topics
export function get_topics(): Array<Topic> {
  

  const number_of_topic = min(TOPIC_VIEW_LIMIT, topics.length)
  const starting_idx = topics.length - number_of_topic
  const result = new Array<Topic>(number_of_topic)
  
  for(let i = 0; i < number_of_topic; i++) {
    result[i] = topics[i + starting_idx]
  }

  return result
}

//function to create topics
export function create_topic(name:string): void {

  assert(!is_topic_exist(name), "Topic already created!")
 
  const topic = new Topic(name)
  topics.push(topic)
}

//function to add comment on topic
export function add_comment_to_topic(topic_name:string,comment:string): void {
  logging.log("Commment: "+comment + ` \nlength: ${comment.length}` )
  assert(comment.length < MAX_COMMENT_LENGTH_LIMIT,`Comment too long max ${MAX_COMMENT_LENGTH_LIMIT} char!`)
  assert(topics.length > 0 , "There is no topic created yet!")
  assert(is_topic_exist(topic_name),"Topic does not exist!")
  const topic_ = find_topic(topic_name)
  assert(!(topic_.is_premium && context.attachedDeposit < ONE_NEAR), "Its a premium topic you need to attach at least 1 near!")
  topic_.add_comment(new Comment(context.sender,comment))
}

//function that returns comments on given topic
export function get_comments_on_topic(topic_name:string): Array<Comment> {
  assert(is_topic_exist(topic_name),"Topic does not exist!")
  const topic_ = find_topic(topic_name)

  const number_of_comments = min(COMMENT_VIEW_LIMIT, topic_.comments.length)
  const starting_idx = topic_.comments.length - number_of_comments
  const result = new Array<Comment>(number_of_comments)
  
  for(let i = 0; i < number_of_comments; i++) {
    result[i] = topic_.comments[i + starting_idx]
  }
  return result
}

// function to check whether topic exist
function is_topic_exist(topic_name:string): boolean {
  for(let i = 0; i < topics.length; i++){
    if(topics[i].name == topic_name)
      return true
  }
  return false
}
//function to find specific topic
function find_topic(topic_name:string): Topic {
  for(let i = 0; i < topics.length; i++){
    if(topics[i].name == topic_name)
      return topics[i]
  }
  return new Topic("This should not happen!!")
}
'''
'''--- src/simple/assembly/model.ts ---
import { u128, PersistentVector, context} from "near-sdk-as"
import { ONE_NEAR } from "../../utils"
//topic class
@nearBindgen
export class Topic{
  name:string
  comments:PersistentVector<Comment>
  is_premium:boolean
  constructor(t_name:string){
    this.name = t_name
    this.comments = new PersistentVector<Comment>("c"+t_name)
    this.is_premium = context.attachedDeposit >= ONE_NEAR
  }
  add_comment(comment:Comment): void {
    this.comments.push(comment)
  }
}
//comment class
@nearBindgen
export class Comment{
  user:string
  comment:string
  constructor(account:string, comment_:string){
    this.user = account
    this.comment = comment_
  }
}

// variable holds topics and comments within
export const topics = new PersistentVector<Topic>("t")

'''
'''--- src/tsconfig.json ---
{
  "extends": "../node_modules/assemblyscript/std/assembly.json",
  "include": ["./**/*.ts"]
}

'''
'''--- src/utils.ts ---
import { u128, Context, ContractPromise } from "near-sdk-as";

/**
 * == TYPES ====================================================================
 */

/**
 * Account IDs in NEAR are just strings.
 */
export type AccountId = string;

/**
 * Gas is u64
 */
export type Gas = u64;

/**
 * Amounts, Balances, and Money in NEAR is are u128.
 */

export type Amount = u128;

export type Balance = Amount;

export type Money = Amount;

/**
 * Timestamp in NEAR is a number.
 */
export type Timestamp = u64;

/**
 * == CONSTANTS ================================================================
 *
 * ONE_NEAR = unit of NEAR token in yocto â“ƒ (1e24)
 * XCC_GAS = gas for cross-contract calls, ~5 Tgas (teragas = 1e12) per "hop"
 * MIN_ACCOUNT_BALANCE = 3 NEAR min to keep account alive via storage staking
 *
 * TODO: revist MIN_ACCOUNT_BALANCE after some real data is included b/c this
 *  could end up being much higher
 */

export const ONE_NEAR = u128.from("1000000000000000000000000");
export const XCC_GAS: Gas = 20_000_000_000_000;
export const MIN_ACCOUNT_BALANCE: u128 = u128.mul(ONE_NEAR, u128.from(3));

/**
 * == FUNCTIONS ================================================================
 */

/**
 * @function asNEAR
 * @param amount {u128} - Yocto â“ƒ token quantity as an unsigned 128-bit integer
 * @returns {string}    - Amount in NEAR, as a string
 *
 * @example
 *
 *    asNEAR(7000000000000000000000000)
 *    // => '7'
 */
export function asNEAR(amount: u128): string {
  return u128.div(amount, ONE_NEAR).toString();
}

/**
 * @function toYocto
 * @param amount {number} - Integer to convert
 * @returns {u128}        - Amount in yocto â“ƒ as an unsigned 128-bit integer
 *
 * @example
 *
 *    toYocto(7)
 *    // => 7000000000000000000000000
 */
export function toYocto(amount: number): u128 {
  return u128.mul(ONE_NEAR, u128.from(amount))
}

/**
 * Function to assert that the contract has called itself
 */
export function assert_self(): void {
  const caller = Context.predecessor
  const self = Context.contractName
  assert(caller == self, "Only this contract may call itself");
}

export function assert_single_promise_success(): void {
  const x = ContractPromise.getResults()
  assert(x.length == 1, "Expected exactly one promise result")
  assert(x[0].succeeded, "Expected PromiseStatus to be successful")
}

'''