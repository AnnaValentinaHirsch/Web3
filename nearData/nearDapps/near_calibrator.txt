*GitHub Repository "near/calibrator"*

'''--- .github/ISSUE_TEMPLATE/BOUNTY.yml ---
name: "Simple Bounty"
description: "Use this template to create a HEROES Simple Bounty via Github bot"
title: "Bounty: "
labels: ["bounty"]
assignees: heroes-bot-test
body:
  - type: markdown
    attributes:
      value: |
        Hi! Let's set up your bounty! Please don't change the template - @heroes-bot-test won't be able to help you.

  - type: dropdown
    id: type
    attributes:
      label: What talent are you looking for?
      options:
        - Marketing
        - Development
        - Design
        - Other
        - Content
        - Research
        - Audit

  - type: textarea
    id: description
    attributes:
      label: What you need to be done?

  - type: dropdown
    id: tags
    attributes:
      label: Tags
      description: Add tags that match the topic of the work
      multiple: true
      options:
        - API
        - Blockchain
        - Community
        - CSS
        - DAO
        - dApp
        - DeFi
        - Design
        - Documentation
        - HTML
        - Javascript
        - NFT
        - React
        - Rust
        - Smart contract
        - Typescript
        - UI/UX
        - web3
        - Translation
        - Illustration
        - Branding
        - Copywriting
        - Blogging
        - Editing
        - Video Creation
        - Social Media
        - Graphic Design
        - Transcription
        - Product Design
        - Artificial Intelligence
        - Quality Assurance
        - Risk Assessment
        - Security Audit
        - Bug Bounty
        - Code Review
        - Blockchain Security
        - Smart Contract Testing
        - Penetration Testing
        - Vulnerability Assessment
        - BOS
        - News
        - Hackathon
        - NEARCON2023
        - NEARWEEK

  - type: input
    id: deadline
    attributes:
      label: Deadline
      description: "Set a deadline for your bounty. Please enter the date in format: DD.MM.YYYY"
      placeholder: "19.05.2027"

  - type: dropdown
    id: currencyType
    attributes:
      label: Currency
      description: What is the currency you want to pay?
      options:
        - USDC.e
        - USDT.e
        - DAI
        - wNEAR
        - USDt
        - XP
        - marmaj
        - NEKO
        - JUMP
        - USDC
        - NEARVIDIA
      default: 0
    validations:
      required: true

  - type: input
    id: currencyAmount
    attributes:
      label: Amount
      description: How much it will be cost?

  - type: markdown
    attributes:
      value: "## Advanced settings"

  - type: checkboxes
    id: kyc
    attributes:
      label: KYC
      description: "Use HEROES' KYC Verification, only applicants who passed HEROES' KYC can apply and work on this bounty!"
      options:
        - label: Use KYC Verification

  - type: markdown
    attributes:
      value: |
        ### This cannot be changed once the bounty is live!

'''
'''--- Cargo.toml ---
[package]
name = "calibrator"
version = "0.1.0"
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
sha256 = "1.0.2"
rand = "0.8.3"
structopt = "0.3.21"
itertools = "0.10.1"
'''
'''--- README.md ---

## Validator machine calibration utility

To make sure gas cost correlates with actual wall clock time we need to be able to calibrate machine and IO performance
across different hardware and OSes.

This utility measures those properties.

## Usage

Use like this

```bash
  cargo install --git https://github.com/near/calibrator --branch main
  calibrator -i 1000000 -c 1000000
```

## Plots

To measure with wider ranges on input sizes use smth like
```bash
  calibrator \
  --io-range \
100,\
1000,\
100000,\
200000,\
1000000,\
2000000,\
10000000,\
20000000,\
30000000,\
40000000,\
50000000,\
300000000,\
600000000,\
1000000000\
  --cpu-range \
1000,\
10000,\
100000\
  --output 'gnuplot:data.txt'
```

It will produce two files, `io_data.txt` and `cpu_data.txt` which could be plotted with `gnuplot`, i.e.

```bash
    brew install gnuplot
    gnuplot plot.gn
    open perf.png
```

'''
'''--- data/gcloud_io.txt ---
"count" "IO random read" "IO random write" "IO sequential read" "IO sequential write"
300000000 506863738428 753436851211 211235207343 336191037622
600000000 1047870190345 1513946967897 423578018936 668980967938
100000 125056927 164740714 68850182 109991641
1000000000 1776697860531 2539716875262 706326831424 1117637545759
1000 1244294 1656709 692652 1120094
200000 245506766 326289579 136241305 218298848
100 124568 171498 72432 162577
2000000 2620509002 3438162621 1389676390 2202264293
10000000 14003516851 18260837476 6969022191 11041116515
20000000 29105911443 38437465835 14129497157 22158718619
40000000 60449727054 79462679541 28140083596 44273229037
50000000 76679902452 101074755380 35029406239 55357113696
1000000 1284979725 1675386105 694936512 1100943151
30000000 44854476285 58321602570 21424704413 33181001018

'''
'''--- data/imac_2017_ssd_io.txt ---
"count" "IO random read" "IO random write" "IO sequential read" "IO sequential write" 
40000000 48779504097 196320117952 27362135922 82112083753
1000 1385181 1808676 1021592 1461187
1000000000 1330804167509 6503196422223 687345437741 1021841156938
100000 140101382 163623509 93268411 111886637
10000000 13475628225 50555328058 7416101499 37455052864
2000000 3207157733 6633167299 1808026113 2384348866
30000000 44139492356 162560092646 24204135133 81520949294
1000000 1491505174 2292654921 837526078 1114338326
20000000 27975851462 100007452570 15247241189 20462173424
100 293701 257893 226383 264392
200000 274613328 319419756 164314380 227131222
50000000 68246797288 212253848517 42436834419 59668090739
300000000 495719767550 1574293565183 213412494070 281803943895
600000000 796689252832 3228027370996 412564240007 689935172880

'''
'''--- data/linux_i5_ssd.txt ---
"count" "IO random read" "IO random write" "IO sequential read" "IO sequential write" 
50000000 47596619202 57134166081 23980263713 36540474252
1000000000 1010846373358 1306938606636 480456192913 732079587125
2000000 1727808866 2222187142 951886100 1458918949
1000 867261 1124938 482142 744368
100 89660 117789 50909 90756
1000000 865342411 1111013644 478160579 731462478
10000000 8984930579 11202125424 4762337511 7289480433
200000 170094466 219923712 94502444 145891113
30000000 28242787433 34306640739 14387524926 22219162477
40000000 37888827509 46877655757 19219739318 29259322367
100000 85217557 110123493 47267204 73646047
20000000 18810245839 23081712497 9631557512 14598415760
600000000 597957828859 777603029085 287533107545 438806014049
300000000 295209641223 383704952951 143807786950 220097466616

'''
'''--- src/main.rs ---
use itertools::Itertools;
use rand::Rng;
use std::collections::HashMap;
use std::fs::{remove_file, File, OpenOptions};
use std::io::{Read, Seek, SeekFrom, Write};
use std::time::Instant;

fn measure_cpu(count: u64, _: ()) -> i64 {
    use sha256::digest;
    let mut result = 0;
    for index in 0..count {
        let input = "what should I do but tend upon the hours, and times of your desire";
        let val = digest(input);
        assert_eq!(
            val,
            "9b4d38fd42c985baec11564a84366de0cbd26d3425ec4ce1266e26b7b951ac08"
        );
        result += val.as_bytes()[(index % 64) as usize] as i64;
    }
    result
}

fn create_file(size: u64) -> String {
    let file_name = format!("file_{}.dat", rand::thread_rng().gen::<u32>());
    let file = File::create(file_name.clone()).unwrap();
    file.set_len(size).unwrap();
    file_name
}

fn create_file_and_write(size: u64) -> String {
    let file_name = create_file(size);
    measure_io_write_seq(size, file_name.clone());
    file_name
}

fn measure_io_write_seq(count: u64, file_name: String) -> i64 {
    let mut file = OpenOptions::new()
        .write(true)
        .create(false)
        .open(file_name)
        .unwrap();
    for i in 0..count {
        let buf = [i as u8];
        file.write(&buf).unwrap();
    }
    0
}

fn measure_io_write_random(count: u64, file_name: String) -> i64 {
    let mut file = OpenOptions::new()
        .write(true)
        .create(false)
        .open(file_name)
        .unwrap();
    for i in 0..count {
        let buf = [i as u8];
        let position = (rand::thread_rng().gen::<u64>()) % count;
        file.seek(SeekFrom::Start(position)).unwrap();
        file.write(&buf).unwrap();
    }
    0
}

fn measure_io_read_seq(count: u64, file_name: String) -> i64 {
    let mut file = File::open(file_name).unwrap();
    for _i in 0..count {
        let mut buf = [0];
        file.read(&mut buf).unwrap();
    }
    0
}

fn measure_io_read_random(count: u64, file_name: String) -> i64 {
    let mut file = File::open(file_name).unwrap();
    for _i in 0..count {
        let mut buf = [0];
        let position = (rand::thread_rng().gen::<u64>()) % count;
        file.seek(SeekFrom::Start(position)).unwrap();
        file.read(&mut buf).unwrap();
    }
    0
}

fn cleanup_file(file_name: String) {
    remove_file(file_name).unwrap();
}

#[used]
static mut SINK: i64 = 0;

fn measure_operation<
    F1: FnOnce(u64) -> T,
    F2: FnOnce(u64, T) -> i64,
    F3: FnOnce(T) -> (),
    T: Clone,
>(
    count: u64,
    prepare: F1,
    op: F2,
    cleanup: F3,
) -> u128 {
    let prepared = prepare(count);
    let start = Instant::now();
    let value = op(count, prepared.clone());
    let result = start.elapsed().as_nanos();
    unsafe {
        SINK = value;
    }
    cleanup(prepared);
    result
}

fn output_stdout(kind: String, output_data: &HashMap<(String, u64), u128>) {
    for (key, value) in output_data.iter().sorted() {
        println!(
            "{}: scale {}: {} ns per {}",
            kind,
            key.1,
            value / (key.1 as u128),
            key.0,
        )
    }
}

fn output_gnuplot(file: String, kind: String, output_data: &HashMap<(String, u64), u128>) {
    let mut file = File::create(format!("{}_{}", kind, file)).unwrap();
    let mut data = HashMap::<u64, Vec<(u128, String)>>::new();
    for (key, value) in output_data.iter().sorted() {
        let v = data.entry(key.1).or_insert_with(|| Vec::new());
        v.push((*value, key.clone().0));
    }
    let mut index = 0;
    for (key, value) in data {
        if index == 0 {
            write!(file, "\"count\" ").unwrap();
            for (_, comment) in value.clone() {
                write!(file, "\"{}\" ", comment).unwrap();
            }
            write!(file, "\n").unwrap();
        }
        index += 1;
        write!(
            file,
            "{} {}\n",
            key,
            value
                .iter()
                .map(|(y, _comment)| y.to_string())
                .collect::<Vec<String>>()
                .join(" ")
        )
        .unwrap();
    }
}

fn finish_output(out: String, output_data: &HashMap<(String, u64), u128>, kind: String) {
    let dest = out.split(':').collect::<Vec<&str>>();
    match dest[0] {
        "gnuplot" => output_gnuplot(dest[1].to_string(), kind, output_data),
        "stdout" => output_stdout(kind, output_data),
        _ => panic!("Unknown output: {}", out),
    }
}

fn output(kind: String, count: u64, value: u128, output_data: &mut HashMap<(String, u64), u128>) {
    let key = (kind, count);
    output_data.insert(key, value);
}

fn parse_seq_or(arg: String, default: u64) -> Vec<u64> {
    if arg.is_empty() {
        vec![default]
    } else {
        arg.split(',').map(|x| x.parse::<u64>().unwrap()).collect()
    }
}

fn estimate() {
    const IO_COUNT: u64 = 100_000;
    const CPU_COUNT: u64 = 100_000;

    // TODO: tune the values basing on stats.
    const MIN_IO_READ: u64 = 1000;
    const MIN_IO_WRITE: u64 = 1000;
    const MIN_CPU: u64 = 1000;

    let io_write_random = measure_operation(
        IO_COUNT,
        create_file,
        measure_io_write_random,
        cleanup_file,
    );

    let write_per_byte = (io_write_random / (IO_COUNT as u128))  as u64;

    let io_read_random = measure_operation(
        IO_COUNT,
        create_file_and_write,
        measure_io_read_random,
        cleanup_file,
    );
    let read_per_byte = (io_read_random/ (IO_COUNT as u128))  as u64;

    let cpu = measure_operation(CPU_COUNT, |_| (), measure_cpu, |()| ());
    let cpu_per_op = (cpu / (CPU_COUNT as u128)) as u64;

    println!("System score is: DISK WRITE {} DISK READ {} CPU {}", write_per_byte, read_per_byte, cpu_per_op);
    let mut ok = true;
    if write_per_byte < MIN_IO_WRITE {
        println!("WARNING: system DISK WRITE performance is below minimal requirements for validators: {} < {}",
                 write_per_byte, MIN_IO_WRITE);
        ok = false;
    }
    if read_per_byte < MIN_IO_READ {
        println!("WARNING: system DISK READ performance is below minimal requirements for validators: {} < {}",
                 read_per_byte, MIN_IO_READ);
        ok = false;
    }
    if cpu_per_op < MIN_CPU {
        println!("WARNING: system CPU performance is below minimal requirements for validators: {} < {}",
                 cpu_per_op, MIN_CPU);
        ok = false;
    }

    if ok {
        println!("SYSTEM PERFORMANCE IS OK");
    } else {
        println!("ERROR: SYSTEM PERFORMANCE BELOW THRESHOLDS");
    }
}

fn main() {
    use structopt::StructOpt;
    #[derive(StructOpt)]
    struct Cli {
        #[structopt(short = "c", long = "cpu-iterations", default_value = "10000")]
        num_cpu_iterations: u64,
        #[structopt(short = "i", long = "io-size", default_value = "100000")]
        io_size: u64,
        #[structopt(short = "o", long = "output", default_value = "stdout")]
        output: String,
        #[structopt(long = "cpu-range", default_value = "")]
        cpu_range: String,
        #[structopt(long = "io-range", default_value = "")]
        io_range: String,
        #[structopt(short = "v", long = "verbose")]
        verbose: bool,
        #[structopt(short = "e", long = "estimate")]
        estimate: bool,
    }
    let args = Cli::from_args();
    let mut output_data_io: HashMap<(String, u64), u128> = HashMap::new();
    let mut output_data_cpu: HashMap<(String, u64), u128> = HashMap::new();

    #[cfg(debug_assertions)]
    println!("WARNING: calibrator must run in release mode to provide accurate results!");

    if args.estimate {
        estimate();
        return;
    }

    let cpu_range = parse_seq_or(args.cpu_range, args.num_cpu_iterations);
    for count in cpu_range {
        if args.verbose {
            println!("Measuring CPU: {} count...", count);
        }
        let cpu = measure_operation(count, |_| (), measure_cpu, |()| ());
        output("SHA256".to_string(), count, cpu, &mut output_data_cpu);
    }
    let io_range = parse_seq_or(args.io_range, args.io_size);
    for count in io_range {
        if args.verbose {
            println!("Measuring IO: {} count...", count);
        }
        let io_write_seq =
            measure_operation(count, create_file, measure_io_write_seq, cleanup_file);
        output(
            "IO sequential write".to_string(),
            count,
            io_write_seq,
            &mut output_data_io,
        );
        let io_write_random =
            measure_operation(count, create_file, measure_io_write_random, cleanup_file);
        output(
            "IO random write".to_string(),
            count,
            io_write_random,
            &mut output_data_io,
        );
        let io_read_seq = measure_operation(
            count,
            create_file_and_write,
            measure_io_read_seq,
            cleanup_file,
        );
        output(
            "IO sequential read".to_string(),
            count,
            io_read_seq,
            &mut output_data_io,
        );
        let io_read_random = measure_operation(
            count,
            create_file_and_write,
            measure_io_read_random,
            cleanup_file,
        );
        output(
            "IO random read".to_string(),
            count,
            io_read_random,
            &mut output_data_io,
        );
    }
    finish_output(args.output.clone(), &output_data_cpu, "cpu".to_string());
    finish_output(args.output, &output_data_io, "io".to_string());
}

'''