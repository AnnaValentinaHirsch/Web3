*GitHub Repository "near/near-blake2"*

'''--- .github/ISSUE_TEMPLATE/BOUNTY.yml ---
name: "Simple Bounty"
description: "Use this template to create a HEROES Simple Bounty via Github bot"
title: "Bounty: "
labels: ["bounty"]
assignees: heroes-bot-test
body:
  - type: markdown
    attributes:
      value: |
        Hi! Let's set up your bounty! Please don't change the template - @heroes-bot-test won't be able to help you.

  - type: dropdown
    id: type
    attributes:
      label: What talent are you looking for?
      options:
        - Marketing
        - Development
        - Design
        - Other
        - Content
        - Research
        - Audit

  - type: textarea
    id: description
    attributes:
      label: What you need to be done?

  - type: dropdown
    id: tags
    attributes:
      label: Tags
      description: Add tags that match the topic of the work
      multiple: true
      options:
        - API
        - Blockchain
        - Community
        - CSS
        - DAO
        - dApp
        - DeFi
        - Design
        - Documentation
        - HTML
        - Javascript
        - NFT
        - React
        - Rust
        - Smart contract
        - Typescript
        - UI/UX
        - web3
        - Translation
        - Illustration
        - Branding
        - Copywriting
        - Blogging
        - Editing
        - Video Creation
        - Social Media
        - Graphic Design
        - Transcription
        - Product Design
        - Artificial Intelligence
        - Quality Assurance
        - Risk Assessment
        - Security Audit
        - Bug Bounty
        - Code Review
        - Blockchain Security
        - Smart Contract Testing
        - Penetration Testing
        - Vulnerability Assessment
        - BOS
        - News
        - Hackathon
        - NEARCON2023
        - NEARWEEK

  - type: input
    id: deadline
    attributes:
      label: Deadline
      description: "Set a deadline for your bounty. Please enter the date in format: DD.MM.YYYY"
      placeholder: "19.05.2027"

  - type: dropdown
    id: currencyType
    attributes:
      label: Currency
      description: What is the currency you want to pay?
      options:
        - USDC.e
        - USDT.e
        - DAI
        - wNEAR
        - USDt
        - XP
        - marmaj
        - NEKO
        - JUMP
        - USDC
        - NEARVIDIA
      default: 0
    validations:
      required: true

  - type: input
    id: currencyAmount
    attributes:
      label: Amount
      description: How much it will be cost?

  - type: markdown
    attributes:
      value: "## Advanced settings"

  - type: checkboxes
    id: kyc
    attributes:
      label: KYC
      description: "Use HEROES' KYC Verification, only applicants who passed HEROES' KYC can apply and work on this bounty!"
      options:
        - label: Use KYC Verification

  - type: markdown
    attributes:
      value: |
        ### This cannot be changed once the bounty is live!

'''
'''--- CHANGELOG.md ---
# Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## 0.9.1 (2020-10-26)
### Changed
- Bump `opaque-debug` to v0.3 ([#168])
- Bump `block-buffer` to v0.9 ([#164])

[#168]: https://github.com/RustCrypto/hashes/pull/168
[#164]: https://github.com/RustCrypto/hashes/pull/164

## 0.9.0 (2020-06-10)
### Added
- Support for Persona and Salt ([#78]) 

### Changed
- Update to `digest` v0.9 release; MSRV 1.41+ ([#155])
- Use new `*Dirty` traits from the `digest` crate ([#153])
- Bump `crypto-mac` to v0.8 release ([#152])
- Bump `block-buffer` to v0.8 release ([#151])
- Rename `*result*` to `finalize` ([#148])
- Upgrade to Rust 2018 edition ([#119])

[#155]: https://github.com/RustCrypto/hashes/pull/155
[#153]: https://github.com/RustCrypto/hashes/pull/153
[#152]: https://github.com/RustCrypto/hashes/pull/152
[#151]: https://github.com/RustCrypto/hashes/pull/151
[#148]: https://github.com/RustCrypto/hashes/pull/148
[#119]: https://github.com/RustCrypto/hashes/pull/133
[#78]: https://github.com/RustCrypto/hashes/pull/78

## 0.8.1 (2019-08-25)

## 0.8.0 (2018-10-11)

## 0.7.1 (2018-04-30)

## 0.7.0 (2017-11-15)

## 0.6.1 (2017-07-24)

## 0.6.0 (2017-06-12)

## 0.5.2 (2017-05-17)

## 0.5.1 (2017-05-02)

## 0.5.0 (2017-04-06)

## 0.4.0 (2017-03-06)

## 0.3.0 (2016-11-17)

## 0.2.0 (2016-10-14)

## 0.1.1 (2016-10-11)

## 0.1.0 (2016-10-09)

'''
'''--- Cargo.toml ---
[package]
name = "near-blake2"
version = "0.9.1"
description = "BLAKE2 hash functions"
authors = [
    "RustCrypto Developers",
    "Near Inc <hello@nearprotocol.com>",
]
license = "MIT OR Apache-2.0"
readme = "README.md"
edition = "2018"
keywords = ["crypto", "blake2", "hash", "digest"]
categories = ["cryptography", "no-std"]

[dependencies]
digest = "0.9"
crypto-mac = "0.8"
opaque-debug = "0.3"

[dev-dependencies]
digest = { version = "0.9", features = ["dev"] }
crypto-mac = { version = "0.8", features = ["dev"] }
hex-literal = "0.2"

[features]
default = ["std"]
std = ["digest/std", "crypto-mac/std"]
simd = []
simd_opt = ["simd"]
simd_asm = ["simd_opt"]

'''
'''--- README.md ---
# RustCrypto: BLAKE2

[![crate][crate-image]][crate-link]
[![Docs][docs-image]][docs-link]
![Apache2/MIT licensed][license-image]
![Rust Version][rustc-image]
[![Project Chat][chat-image]][chat-link]
[![Build Status][build-image]][build-link]

Pure Rust implementation of the [BLAKE2 hash function][1] family with changes to
the compression function to specify an amount of rounds.

[Documentation][docs-link]

## Minimum Supported Rust Version

Rust **1.41** or higher.

Minimum supported Rust version can be changed in the future, but it will be
done with a minor version bump.

## SemVer Policy

- All on-by-default features of this library are covered by SemVer
- MSRV is considered exempt from SemVer as noted above

## License

Licensed under either of:

 * [Apache License, Version 2.0](http://www.apache.org/licenses/LICENSE-2.0)
 * [MIT license](http://opensource.org/licenses/MIT)

at your option.

### Contribution

Unless you explicitly state otherwise, any contribution intentionally submitted
for inclusion in the work by you, as defined in the Apache-2.0 license, shall be
dual licensed as above, without any additional terms or conditions.

[//]: # (badges)

[crate-image]: https://img.shields.io/crates/v/blake2.svg
[crate-link]: https://crates.io/crates/blake2
[docs-image]: https://docs.rs/blake2/badge.svg
[docs-link]: https://docs.rs/blake2/
[license-image]: https://img.shields.io/badge/license-Apache2.0/MIT-blue.svg
[chat-image]: https://img.shields.io/badge/zulip-join_chat-blue.svg
[chat-link]: https://rustcrypto.zulipchat.com/#narrow/stream/260041-hashes
[rustc-image]: https://img.shields.io/badge/rustc-1.41+-blue.svg
[build-image]: https://github.com/RustCrypto/hashes/workflows/blake2/badge.svg?branch=master
[build-link]: https://github.com/RustCrypto/hashes/actions?query=workflow%3Ablake2

[//]: # (general links)

[1]: https://blake2.net/

'''
'''--- benches/blake2b.rs ---
#![no_std]
#![feature(test)]

digest::bench!(blake2::Blake2b);

'''
'''--- benches/blake2s.rs ---
#![no_std]
#![feature(test)]

digest::bench!(blake2::Blake2s);

'''
'''--- examples/blake2b_sum.rs ---
use near_blake2::{Blake2b, Digest};
use std::env;
use std::fs;
use std::io::{self, Read};

const BUFFER_SIZE: usize = 1024;

/// Print digest result as hex string and name pair
fn print_result(sum: &[u8], name: &str) {
    for byte in sum {
        print!("{:02x}", byte);
    }
    println!("\t{}", name);
}

/// Compute digest value for given `Reader` and print it
/// On any error simply return without doing anything
fn process<D: Digest + Default, R: Read>(reader: &mut R, name: &str) {
    let mut sh = D::default();
    let mut buffer = [0u8; BUFFER_SIZE];
    loop {
        let n = match reader.read(&mut buffer) {
            Ok(n) => n,
            Err(_) => return,
        };
        sh.update(&buffer[..n]);
        if n == 0 || n < BUFFER_SIZE {
            break;
        }
    }
    print_result(&sh.finalize(), name);
}

fn main() {
    let args = env::args();
    // Process files listed in command line arguments one by one
    // If no files provided process input from stdin
    if args.len() > 1 {
        for path in args.skip(1) {
            if let Ok(mut file) = fs::File::open(&path) {
                process::<Blake2b, _>(&mut file, &path);
            }
        }
    } else {
        process::<Blake2b, _>(&mut io::stdin(), "-");
    }
}

'''
'''--- examples/blake2s_sum.rs ---
use near_blake2::{Blake2s, Digest};
use std::env;
use std::fs;
use std::io::{self, Read};

const BUFFER_SIZE: usize = 1024;

/// Print digest result as hex string and name pair
fn print_result(sum: &[u8], name: &str) {
    for byte in sum {
        print!("{:02x}", byte);
    }
    println!("\t{}", name);
}

/// Compute digest value for given `Reader` and print it
/// On any error simply return without doing anything
fn process<D: Digest + Default, R: Read>(reader: &mut R, name: &str) {
    let mut sh = D::default();
    let mut buffer = [0u8; BUFFER_SIZE];
    loop {
        let n = match reader.read(&mut buffer) {
            Ok(n) => n,
            Err(_) => return,
        };
        sh.update(&buffer[..n]);
        if n == 0 || n < BUFFER_SIZE {
            break;
        }
    }
    print_result(&sh.finalize(), name);
}

fn main() {
    let args = env::args();
    // Process files listed in command line arguments one by one
    // If no files provided process input from stdin
    if args.len() > 1 {
        for path in args.skip(1) {
            if let Ok(mut file) = fs::File::open(&path) {
                process::<Blake2s, _>(&mut file, &path);
            }
        }
    } else {
        process::<Blake2s, _>(&mut io::stdin(), "-");
    }
}

'''
'''--- src/as_bytes.rs ---
// Copyright 2016 blake2-rfc Developers
//
// Licensed under the Apache License, Version 2.0, <LICENSE-APACHE or
// http://apache.org/licenses/LICENSE-2.0> or the MIT license <LICENSE-MIT or
// http://opensource.org/licenses/MIT>, at your option. This file may not be
// copied, modified, or distributed except according to those terms.

use core::mem;
use core::slice;

pub unsafe trait Safe {}

pub trait AsBytes {
    fn as_bytes(&self) -> &[u8];
    fn as_mut_bytes(&mut self) -> &mut [u8];
}

impl<T: Safe> AsBytes for [T] {
    #[inline]
    fn as_bytes(&self) -> &[u8] {
        unsafe {
            slice::from_raw_parts(self.as_ptr() as *const u8, self.len() * mem::size_of::<T>())
        }
    }

    #[inline]
    fn as_mut_bytes(&mut self) -> &mut [u8] {
        unsafe {
            slice::from_raw_parts_mut(
                self.as_mut_ptr() as *mut u8,
                self.len() * mem::size_of::<T>(),
            )
        }
    }
}

unsafe impl Safe for u8 {}
unsafe impl Safe for u16 {}
unsafe impl Safe for u32 {}
unsafe impl Safe for u64 {}
unsafe impl Safe for i8 {}
unsafe impl Safe for i16 {}
unsafe impl Safe for i32 {}
unsafe impl Safe for i64 {}

'''
'''--- src/blake2.rs ---
macro_rules! blake2_impl {
    (
        $state:ident, $fix_state:ident, $word:ident, $vec:ident, $bytes:ident,
        $block_size:ident, $R1:expr, $R2:expr, $R3:expr, $R4:expr, $IV:expr,
        $vardoc:expr, $doc:expr,
    ) => {
        use $crate::as_bytes::AsBytes;
        use $crate::simd::{$vec, Vector4};

        use core::{cmp, convert::TryInto, ops::Div};
        use crypto_mac::{InvalidKeyLength, Mac, NewMac};
        use digest::generic_array::typenum::{Unsigned, U4};
        use digest::generic_array::GenericArray;
        use digest::InvalidOutputSize;
        use digest::{BlockInput, FixedOutputDirty, Reset, Update, VariableOutputDirty};

        type Output = GenericArray<u8, $bytes>;

        #[derive(Clone)]
        #[doc=$vardoc]
        pub struct $state {
            m: [$word; 16],
            h: [$vec; 2],
            t: [$word; 2],
            n: usize,

            h0: [$vec; 2],
            m0: [$word; 16],
            t0: [$word; 2],

            rounds: u32,
        }

        // Can't make this a const, else it would be great as that.
        fn max_rounds() -> u32 {
            if $bytes::to_u8() == 64 {
                12
            } else {
                10
            }
        }

        #[inline(always)]
        fn iv0() -> $vec {
            $vec::new($IV[0], $IV[1], $IV[2], $IV[3])
        }
        #[inline(always)]
        fn iv1() -> $vec {
            $vec::new($IV[4], $IV[5], $IV[6], $IV[7])
        }

        #[inline(always)]
        fn quarter_round(v: &mut [$vec; 4], rd: u32, rb: u32, m: $vec) {
            v[0] = v[0].wrapping_add(v[1]).wrapping_add(m.from_le());
            v[3] = (v[3] ^ v[0]).rotate_right_const(rd);
            v[2] = v[2].wrapping_add(v[3]);
            v[1] = (v[1] ^ v[2]).rotate_right_const(rb);
        }

        #[inline(always)]
        fn shuffle(v: &mut [$vec; 4]) {
            v[1] = v[1].shuffle_left_1();
            v[2] = v[2].shuffle_left_2();
            v[3] = v[3].shuffle_left_3();
        }

        #[inline(always)]
        fn unshuffle(v: &mut [$vec; 4]) {
            v[1] = v[1].shuffle_right_1();
            v[2] = v[2].shuffle_right_2();
            v[3] = v[3].shuffle_right_3();
        }

        #[inline(always)]
        fn round(v: &mut [$vec; 4], m: &[$word; 16], s: &[usize; 16]) {
            quarter_round(v, $R1, $R2, $vec::gather(m, s[0], s[2], s[4], s[6]));
            quarter_round(v, $R3, $R4, $vec::gather(m, s[1], s[3], s[5], s[7]));

            shuffle(v);
            quarter_round(v, $R1, $R2, $vec::gather(m, s[8], s[10], s[12], s[14]));
            quarter_round(v, $R3, $R4, $vec::gather(m, s[9], s[11], s[13], s[15]));
            unshuffle(v);
        }

        impl $state {
            /// Creates a new hashing context with a key.
            ///
            /// **WARNING!** If you plan to use it for variable output MAC, then
            /// make sure to compare codes in constant time! It can be done
            /// for example by using `subtle` crate.
            pub fn new_keyed(key: &[u8], output_size: usize) -> Self {
                Self::with_params(key, &[], &[], output_size)
            }

            /// Creates a new hashing context with the full set of sequential-mode parameters.
            pub fn with_params(
                key: &[u8],
                salt: &[u8],
                persona: &[u8],
                output_size: usize,
            ) -> Self {
                let kk = key.len();
                assert!(kk <= $bytes::to_usize());
                assert!(output_size <= $bytes::to_usize());

                // The number of bytes needed to express two words.
                let length = $bytes::to_usize() / 4;
                assert!(salt.len() <= length);
                assert!(persona.len() <= length);

                // Build a parameter block
                let mut p = [0 as $word; 8];
                p[0] = 0x0101_0000 ^ ((kk as $word) << 8) ^ (output_size as $word);

                // salt is two words long
                if salt.len() < length {
                    let mut padded_salt =
                        GenericArray::<u8, <$bytes as Div<U4>>::Output>::default();
                    for i in 0..salt.len() {
                        padded_salt[i] = salt[i];
                    }
                    p[4] = $word::from_le_bytes(padded_salt[0..length / 2].try_into().unwrap());
                    p[5] = $word::from_le_bytes(
                        padded_salt[length / 2..padded_salt.len()]
                            .try_into()
                            .unwrap(),
                    );
                } else {
                    p[4] = $word::from_le_bytes(salt[0..salt.len() / 2].try_into().unwrap());
                    p[5] =
                        $word::from_le_bytes(salt[salt.len() / 2..salt.len()].try_into().unwrap());
                }

                // persona is also two words long
                if persona.len() < length {
                    let mut padded_persona =
                        GenericArray::<u8, <$bytes as Div<U4>>::Output>::default();
                    for i in 0..persona.len() {
                        padded_persona[i] = persona[i];
                    }
                    p[6] = $word::from_le_bytes(padded_persona[0..length / 2].try_into().unwrap());
                    p[7] = $word::from_le_bytes(
                        padded_persona[length / 2..padded_persona.len()]
                            .try_into()
                            .unwrap(),
                    );
                } else {
                    p[6] = $word::from_le_bytes(persona[0..length / 2].try_into().unwrap());
                    p[7] = $word::from_le_bytes(
                        persona[length / 2..persona.len()].try_into().unwrap(),
                    );
                }

                let mut state = Self::with_parameter_block(&p);

                if kk > 0 {
                    copy(key, state.m.as_mut_bytes());
                    state.t[0] = (2 * $bytes::to_u64()) as $word;
                }

                state.t0 = state.t;
                state.m0 = state.m;
                state
            }

            #[doc(hidden)]
            pub fn with_parameter_block(p: &[$word; 8]) -> Self {
                let nn = p[0] as u8 as usize;
                let kk = (p[0] >> 8) as u8 as usize;
                assert!(nn >= 1 && nn <= $bytes::to_usize());
                assert!(kk <= $bytes::to_usize());

                let h0 = [
                    iv0() ^ $vec::new(p[0], p[1], p[2], p[3]),
                    iv1() ^ $vec::new(p[4], p[5], p[6], p[7]),
                ];

                $state {
                    m: [0; 16],
                    h: h0,
                    t: [0; 2],
                    n: nn,

                    t0: [0; 2],
                    m0: [0; 16],
                    h0,

                    rounds: max_rounds(),
                }
            }

            /// Constructs a new hashing context with a given state.
            ///
            /// This enables continued hashing of a pre-hashed state.
            ///
            /// **Warning**: The user of this method is responsible for the
            /// initialization of the vectors for the first round.
            pub fn with_state(rounds: u32, state: [$word; 8], t: [$word; 2]) -> Self {
                let h0 = [
                    $vec::new(state[0], state[1], state[2], state[3]),
                    $vec::new(state[4], state[5], state[6], state[7]),
                ];
                let nn = $bytes::to_u8() as usize;

                $state {
                    m: [0; 16],
                    h: h0,
                    t,
                    n: nn,
                    t0: [0; 2],
                    m0: [0; 16],
                    h0,
                    rounds,
                }
            }

            /// Updates the hashing context with more data.
            pub fn update_inner(&mut self, data: &[u8]) {
                let mut rest = data;

                let block = 2 * $bytes::to_usize();

                let off = self.t[0] as usize % block;
                if off != 0 || self.t[0] == 0 {
                    let len = cmp::min(block - off, rest.len());

                    let part = &rest[..len];
                    rest = &rest[part.len()..];

                    copy(part, &mut self.m.as_mut_bytes()[off..]);
                    self.t[0] = match self.t[0].checked_add(part.len() as $word) {
                        Some(v) => v,
                        None => 0,
                    }
                }

                while rest.len() >= block {
                    self.compress(0, 0);

                    let part = &rest[..block];
                    rest = &rest[part.len()..];

                    copy(part, &mut self.m.as_mut_bytes());
                    self.t[0] = match self.t[0].checked_add(part.len() as $word) {
                        Some(v) => v,
                        None => 0,
                    }
                }

                let n = rest.len();
                if n > 0 {
                    self.compress(0, 0);

                    copy(rest, &mut self.m.as_mut_bytes());
                    self.t[0] = match self.t[0].checked_add(rest.len() as $word) {
                        Some(v) => v,
                        None => 0,
                    }
                }
            }

            #[doc(hidden)]
            pub fn finalize_last_node(mut self) -> Output {
                self.finalize_with_flag(!0)
            }

            fn finalize_with_flag(&mut self, f1: $word) -> Output {
                let off = self.t[0] as usize % (2 * $bytes::to_usize());
                if off != 0 {
                    self.m.as_mut_bytes()[off..].iter_mut().for_each(|b| *b = 0);
                }

                self.compress(!0, f1);

                self.output()
            }

            /// Compression `F` function.
            pub fn compress(&mut self, f0: $word, f1: $word) {
                use $crate::consts::SIGMA;

                let m = &self.m;
                let h = &mut self.h;

                let t0 = self.t[0];
                let t1 = self.t[1];

                let mut v = [h[0], h[1], iv0(), iv1() ^ $vec::new(t0, t1, f0, f1)];

                for x in 0..self.rounds {
                    let x = x - x / 10 * 10;
                    round(&mut v, &m, &SIGMA[x as usize]);
                }

                h[0] = h[0] ^ (v[0] ^ v[2]);
                h[1] = h[1] ^ (v[1] ^ v[3]);
            }

            /// Returns the current count value `t`.
            pub fn counter(&self) -> [$word; 2] {
                self.t
            }

            /// Returns the current hashed state.
            pub fn output(&self) -> Output {
                let buf = [self.h[0].to_le(), self.h[1].to_le()];

                let mut out = GenericArray::default();
                copy(buf.as_bytes(), &mut out);
                out
            }
        }

        impl Default for $state {
            fn default() -> Self {
                Self::new_keyed(&[], $bytes::to_usize())
            }
        }

        impl BlockInput for $state {
            type BlockSize = $block_size;
        }

        impl Update for $state {
            fn update(&mut self, data: impl AsRef<[u8]>) {
                self.update_inner(data.as_ref());
            }
        }

        impl VariableOutputDirty for $state {
            fn new(output_size: usize) -> Result<Self, InvalidOutputSize> {
                if output_size == 0 || output_size > $bytes::to_usize() {
                    return Err(InvalidOutputSize);
                }
                Ok(Self::new_keyed(&[], output_size))
            }

            fn output_size(&self) -> usize {
                self.n
            }

            fn finalize_variable_dirty(&mut self, f: impl FnOnce(&[u8])) {
                let n = self.n;
                let res = self.finalize_with_flag(0);
                f(&res[..n]);
            }
        }

        impl Reset for $state {
            fn reset(&mut self) {
                self.t = self.t0;
                self.m = self.m0;
                self.h = self.h0;
            }
        }

        opaque_debug::implement!($state);
        digest::impl_write!($state);

        #[derive(Clone)]
        #[doc=$doc]
        pub struct $fix_state {
            state: $state,
        }

        impl $fix_state {
            /// Creates a new hashing context with the full set of sequential-mode parameters.
            pub fn with_params(key: &[u8], salt: &[u8], persona: &[u8]) -> Self {
                let state = $state::with_params(key, salt, persona, $bytes::to_usize());
                Self { state }
            }
        }

        impl Default for $fix_state {
            fn default() -> Self {
                let state = $state::new_keyed(&[], $bytes::to_usize());
                Self { state }
            }
        }

        impl BlockInput for $fix_state {
            type BlockSize = $block_size;
        }

        impl Update for $fix_state {
            fn update(&mut self, data: impl AsRef<[u8]>) {
                self.state.update_inner(data.as_ref());
            }
        }

        impl FixedOutputDirty for $fix_state {
            type OutputSize = $bytes;

            fn finalize_into_dirty(&mut self, out: &mut Output) {
                out.copy_from_slice(&self.state.finalize_with_flag(0));
            }
        }

        impl Reset for $fix_state {
            fn reset(&mut self) {
                self.state.reset()
            }
        }

        impl NewMac for $fix_state {
            type KeySize = $bytes;

            fn new(key: &GenericArray<u8, $bytes>) -> Self {
                let state = $state::new_keyed(key, $bytes::to_usize());
                Self { state }
            }

            fn new_varkey(key: &[u8]) -> Result<Self, InvalidKeyLength> {
                if key.len() > $bytes::to_usize() {
                    Err(InvalidKeyLength)
                } else {
                    let state = $state::new_keyed(key, $bytes::to_usize());
                    Ok(Self { state })
                }
            }
        }

        impl Mac for $fix_state {
            type OutputSize = $bytes;

            fn update(&mut self, data: &[u8]) {
                self.state.update_inner(data);
            }

            fn reset(&mut self) {
                <Self as Reset>::reset(self)
            }

            fn finalize(mut self) -> crypto_mac::Output<Self> {
                crypto_mac::Output::new(self.state.finalize_with_flag(0))
            }
        }

        opaque_debug::implement!($fix_state);
        digest::impl_write!($fix_state);

        fn copy(src: &[u8], dst: &mut [u8]) {
            assert!(dst.len() >= src.len());
            unsafe {
                core::ptr::copy_nonoverlapping(src.as_ptr(), dst.as_mut_ptr(), src.len());
            }
        }
    };
}

'''
'''--- src/blake2b.rs ---
use crate::consts::BLAKE2B_IV;
use digest::generic_array::typenum::{U128, U64};

blake2_impl!(
    VarBlake2b,
    Blake2b,
    u64,
    u64x4,
    U64,
    U128,
    32,
    24,
    16,
    63,
    BLAKE2B_IV,
    "Blake2b instance with a variable output.",
    "Blake2b instance with a fixed output.",
);

'''
'''--- src/blake2s.rs ---
use crate::consts::BLAKE2S_IV;
use digest::generic_array::typenum::{U32, U64};

blake2_impl!(
    VarBlake2s,
    Blake2s,
    u32,
    u32x4,
    U32,
    U64,
    16,
    12,
    8,
    7,
    BLAKE2S_IV,
    "Blake2s instance with a variable output.",
    "Blake2s instance with a fixed output.",
);

'''
'''--- src/consts.rs ---
#![allow(clippy::unreadable_literal)]

/// Message word permutations.
pub static SIGMA: [[usize; 16]; 12] = [
    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15],
    [14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3],
    [11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4],
    [7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8],
    [9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13],
    [2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9],
    [12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11],
    [13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10],
    [6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5],
    [10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0],
    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15],
    [14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3],
];

/// Blake2b initialization vector.
pub static BLAKE2B_IV: [u64; 8] = [
    0x6a09e667f3bcc908,
    0xbb67ae8584caa73b,
    0x3c6ef372fe94f82b,
    0xa54ff53a5f1d36f1,
    0x510e527fade682d1,
    0x9b05688c2b3e6c1f,
    0x1f83d9abfb41bd6b,
    0x5be0cd19137e2179,
];

/*
pub const BLAKE2B_BLOCKBYTES : usize = 128;
pub const BLAKE2B_OUTBYTES : usize = 64;
pub const BLAKE2B_KEYBYTES : usize = 64;
pub const BLAKE2B_SALTBYTES : usize = 16;
pub const BLAKE2B_PERSONALBYTES : usize = 16;
*/

/// Blake2s initialization vector.
pub static BLAKE2S_IV: [u32; 8] = [
    0x6A09E667, 0xBB67AE85, 0x3C6EF372, 0xA54FF53A, 0x510E527F, 0x9B05688C, 0x1F83D9AB, 0x5BE0CD19,
];

/*
pub const BLAKE2S_BLOCKBYTES : usize = 64;
pub const BLAKE2S_OUTBYTES : usize = 32;
pub const BLAKE2S_KEYBYTES : usize = 32;
pub const BLAKE2S_SALTBYTES : usize = 8;
pub const BLAKE2S_PERSONALBYTES : usize = 8;
*/

'''
'''--- src/lib.rs ---
//! An implementation of the [BLAKE2][1] hash functions.
//!
//! # Usage
//!
//! `Blake2b` can be used in the following way:
//!
//! ```rust
//! use near_blake2::{Blake2b, Blake2s, Digest};
//! use hex_literal::hex;
//!
//! // create a Blake2b object
//! let mut hasher = Blake2b::new();
//!
//! // write input message
//! hasher.update(b"hello world");
//!
//! // read hash digest and consume hasher
//! let res = hasher.finalize();
//! assert_eq!(res[..], hex!("
//!     021ced8799296ceca557832ab941a50b4a11f83478cf141f51f933f653ab9fbc
//!     c05a037cddbed06e309bf334942c4e58cdf1a46e237911ccd7fcf9787cbc7fd0
//! ")[..]);
//!
//! // same example for `Blake2s`:
//! let mut hasher = Blake2s::new();
//! hasher.update(b"hello world");
//! let res = hasher.finalize();
//! assert_eq!(res[..], hex!("
//!     9aec6806794561107e594b1f6a8a6b0c92a0cba9acf5e5e93cca06f781813b0b
//! ")[..]);
//! ```
//!
//! Also see [RustCrypto/hashes](https://github.com/RustCrypto/hashes) readme.
//!
//! ## Variable output size
//!
//! If you need variable sized output you can use `VarBlake2b` and `VarBlake2s`
//! which support variable output sizes through `VariableOutput` trait. `Update`
//! trait has to be imported as well.
//!
//! ```rust
//! use near_blake2::VarBlake2b;
//! use near_blake2::digest::{Update, VariableOutput};
//!
//! let mut hasher = VarBlake2b::new(10).unwrap();
//! hasher.update(b"my_input");
//! hasher.finalize_variable(|res| {
//!     assert_eq!(res, [44, 197, 92, 132, 228, 22, 146, 78, 100, 0])
//! })
//! ```
//!
//! ## Message Authentication Code (MAC)
//!
//! BLAKE2 can be used as a MAC without any additional constructs:
//!
//! ```rust
//! use near_blake2::Blake2b;
//! use near_blake2::crypto_mac::{Mac, NewMac};
//!
//! let mut hasher = Blake2b::new_varkey(b"my key").unwrap();
//! hasher.update(b"hello world");
//!
//! // `result` has type `crypto_mac::Output` which is a thin wrapper around
//! // a byte array and provides a constant time equality check
//! let result = hasher.finalize();
//! // To get underlying array use the `into_bytes` method, but be careful,
//! // since incorrect use of the code value may permit timing attacks which
//! // defeat the security provided by the `crypto_mac::Output`
//! let code_bytes = result.into_bytes();
//!
//! // To verify the message it's recommended to use `verify` method
//! let mut hasher = Blake2b::new_varkey(b"my key").unwrap();
//! hasher.update(b"hello world");
//! // `verify` return `Ok(())` if code is correct, `Err(MacError)` otherwise
//! hasher.verify(&code_bytes).unwrap();
//! ```
//!
//! # Acknowledgment
//! Based on the [blake2-rfc][2] crate.
//!
//! [1]: https://en.wikipedia.org/wiki/BLAKE_(hash_function)#BLAKE2
//! [2]: https://github.com/cesarb/blake2-rfc

#![no_std]
#![doc(
    html_logo_url = "https://raw.githubusercontent.com/RustCrypto/meta/master/logo.svg",
    html_favicon_url = "https://raw.githubusercontent.com/RustCrypto/meta/master/logo.svg"
)]
#![warn(missing_docs, rust_2018_idioms)]
#![cfg_attr(feature = "simd", feature(platform_intrinsics, repr_simd))]
#![cfg_attr(feature = "simd_asm", feature(asm))]

#[cfg(feature = "std")]
extern crate std;

mod as_bytes;
mod consts;

mod simd;

#[macro_use]
mod blake2;

mod blake2b;
mod blake2s;

pub use crypto_mac;
pub use digest::{self, Digest};

pub use crate::blake2b::{Blake2b, VarBlake2b};
pub use crate::blake2s::{Blake2s, VarBlake2s};
pub use crate::consts::{BLAKE2B_IV, BLAKE2S_IV, SIGMA};

'''
'''--- src/simd.rs ---
// Copyright 2015 blake2-rfc Developers
//
// Licensed under the Apache License, Version 2.0, <LICENSE-APACHE or
// http://apache.org/licenses/LICENSE-2.0> or the MIT license <LICENSE-MIT or
// http://opensource.org/licenses/MIT>, at your option. This file may not be
// copied, modified, or distributed except according to those terms.

mod simd_opt;
mod simdint;
mod simdop;
mod simdty;

pub use self::simdty::{u32x4, u64x4};

pub trait Vector4<T>: Copy {
    fn gather(src: &[T], i0: usize, i1: usize, i2: usize, i3: usize) -> Self;

    // Usually, this should be fixed but to keep it inline with blake2 upstream,
    // we will leave it as is for maximum compatibility.
    #[allow(clippy::wrong_self_convention)]
    fn from_le(self) -> Self;
    fn to_le(self) -> Self;
    fn to_be(self) -> Self;

    fn wrapping_add(self, rhs: Self) -> Self;

    fn rotate_right_const(self, n: u32) -> Self;

    fn shuffle_left_1(self) -> Self;
    fn shuffle_left_2(self) -> Self;
    fn shuffle_left_3(self) -> Self;

    #[inline(always)]
    fn shuffle_right_1(self) -> Self {
        self.shuffle_left_3()
    }
    #[inline(always)]
    fn shuffle_right_2(self) -> Self {
        self.shuffle_left_2()
    }
    #[inline(always)]
    fn shuffle_right_3(self) -> Self {
        self.shuffle_left_1()
    }
}

macro_rules! impl_vector4 {
    ($vec:ident, $word:ident) => {
        impl Vector4<$word> for $vec {
            #[inline(always)]
            fn gather(src: &[$word], i0: usize, i1: usize, i2: usize, i3: usize) -> Self {
                $vec::new(src[i0], src[i1], src[i2], src[i3])
            }

            #[cfg(target_endian = "little")]
            #[inline(always)]
            fn from_le(self) -> Self {
                self
            }

            #[cfg(not(target_endian = "little"))]
            #[inline(always)]
            fn from_le(self) -> Self {
                $vec::new(
                    $word::from_le(self.0),
                    $word::from_le(self.1),
                    $word::from_le(self.2),
                    $word::from_le(self.3),
                )
            }

            #[cfg(target_endian = "little")]
            #[inline(always)]
            fn to_le(self) -> Self {
                self
            }

            #[cfg(not(target_endian = "little"))]
            #[inline(always)]
            fn to_le(self) -> Self {
                $vec::new(
                    self.0.to_le(),
                    self.1.to_le(),
                    self.2.to_le(),
                    self.3.to_le(),
                )
            }

            #[inline(always)]
            fn to_be(self) -> Self {
                $vec::new(
                    self.0.to_be(),
                    self.1.to_be(),
                    self.2.to_be(),
                    self.3.to_be(),
                )
            }

            #[inline(always)]
            fn wrapping_add(self, rhs: Self) -> Self {
                self + rhs
            }

            #[inline(always)]
            fn rotate_right_const(self, n: u32) -> Self {
                simd_opt::$vec::rotate_right_const(self, n)
            }

            #[cfg(feature = "simd")]
            #[inline(always)]
            fn shuffle_left_1(self) -> Self {
                use crate::simd::simdint::simd_shuffle4;
                unsafe { simd_shuffle4(self, self, [1, 2, 3, 0]) }
            }

            #[cfg(not(feature = "simd"))]
            #[inline(always)]
            fn shuffle_left_1(self) -> Self {
                $vec::new(self.1, self.2, self.3, self.0)
            }

            #[cfg(feature = "simd")]
            #[inline(always)]
            fn shuffle_left_2(self) -> Self {
                use crate::simd::simdint::simd_shuffle4;
                unsafe { simd_shuffle4(self, self, [2, 3, 0, 1]) }
            }

            #[cfg(not(feature = "simd"))]
            #[inline(always)]
            fn shuffle_left_2(self) -> Self {
                $vec::new(self.2, self.3, self.0, self.1)
            }

            #[cfg(feature = "simd")]
            #[inline(always)]
            fn shuffle_left_3(self) -> Self {
                use crate::simd::simdint::simd_shuffle4;
                unsafe { simd_shuffle4(self, self, [3, 0, 1, 2]) }
            }

            #[cfg(not(feature = "simd"))]
            #[inline(always)]
            fn shuffle_left_3(self) -> Self {
                $vec::new(self.3, self.0, self.1, self.2)
            }
        }
    };
}

impl_vector4!(u32x4, u32);
impl_vector4!(u64x4, u64);

'''
'''--- src/simd/simd_opt.rs ---
// Copyright 2015 blake2-rfc Developers
//
// Licensed under the Apache License, Version 2.0, <LICENSE-APACHE or
// http://apache.org/licenses/LICENSE-2.0> or the MIT license <LICENSE-MIT or
// http://opensource.org/licenses/MIT>, at your option. This file may not be
// copied, modified, or distributed except according to those terms.

#[allow(unused_macros)]
#[cfg(feature = "simd")]
macro_rules! transmute_shuffle {
    ($tmp:ident, $shuffle:ident, $vec:expr, $idx:expr) => {
        unsafe {
            use crate::simd::simdint::$shuffle;
            use crate::simd::simdty::$tmp;
            use core::mem::transmute;

            let tmp_i: $tmp = transmute($vec);
            let tmp_o: $tmp = $shuffle(tmp_i, tmp_i, $idx);
            transmute(tmp_o)
        }
    };
}

#[cfg(feature = "simd")]
pub mod u32x4;
#[cfg(feature = "simd")]
pub mod u64x4;

#[cfg(not(feature = "simd"))]
macro_rules! simd_opt {
    ($vec:ident) => {
        pub mod $vec {
            use crate::simd::simdty::$vec;

            #[inline(always)]
            pub fn rotate_right_const(vec: $vec, n: u32) -> $vec {
                $vec::new(
                    vec.0.rotate_right(n),
                    vec.1.rotate_right(n),
                    vec.2.rotate_right(n),
                    vec.3.rotate_right(n),
                )
            }
        }
    };
}

#[cfg(not(feature = "simd"))]
simd_opt!(u32x4);
#[cfg(not(feature = "simd"))]
simd_opt!(u64x4);

'''
'''--- src/simd/simd_opt/u32x4.rs ---
// Copyright 2015 blake2-rfc Developers
//
// Licensed under the Apache License, Version 2.0, <LICENSE-APACHE or
// http://apache.org/licenses/LICENSE-2.0> or the MIT license <LICENSE-MIT or
// http://opensource.org/licenses/MIT>, at your option. This file may not be
// copied, modified, or distributed except according to those terms.

use crate::simd::simdty::u32x4;

#[cfg(feature = "simd_opt")]
#[inline(always)]
pub fn rotate_right_const(vec: u32x4, n: u32) -> u32x4 {
    match n {
        16 => rotate_right_16(vec),
        8 => rotate_right_8(vec),
        _ => rotate_right_any(vec, n),
    }
}

#[cfg(not(feature = "simd_opt"))]
#[inline(always)]
pub fn rotate_right_const(vec: u32x4, n: u32) -> u32x4 {
    rotate_right_any(vec, n)
}

#[inline(always)]
fn rotate_right_any(vec: u32x4, n: u32) -> u32x4 {
    let r = n as u32;
    let l = 32 - r;

    (vec >> u32x4::new(r, r, r, r)) ^ (vec << u32x4::new(l, l, l, l))
}

#[cfg(feature = "simd_opt")]
#[inline(always)]
fn rotate_right_16(vec: u32x4) -> u32x4 {
    if cfg!(target_feature = "ssse3") {
        // pshufb (SSSE3) / vpshufb (AVX2)
        transmute_shuffle!(
            u8x16,
            simd_shuffle16,
            vec,
            [2, 3, 0, 1, 6, 7, 4, 5, 10, 11, 8, 9, 14, 15, 12, 13]
        )
    } else if cfg!(any(target_feature = "sse2", target_feature = "neon")) {
        // pshuflw+pshufhw (SSE2) / vrev (NEON)
        transmute_shuffle!(u16x8, simd_shuffle8, vec, [1, 0, 3, 2, 5, 4, 7, 6])
    } else {
        rotate_right_any(vec, 16)
    }
}

#[cfg(feature = "simd_opt")]
#[inline(always)]
fn rotate_right_8(vec: u32x4) -> u32x4 {
    if cfg!(target_feature = "ssse3") {
        // pshufb (SSSE3) / vpshufb (AVX2)
        transmute_shuffle!(
            u8x16,
            simd_shuffle16,
            vec,
            [1, 2, 3, 0, 5, 6, 7, 4, 9, 10, 11, 8, 13, 14, 15, 12]
        )
    } else {
        rotate_right_any(vec, 8)
    }
}

'''
'''--- src/simd/simd_opt/u64x4.rs ---
// Copyright 2015 blake2-rfc Developers
//
// Licensed under the Apache License, Version 2.0, <LICENSE-APACHE or
// http://apache.org/licenses/LICENSE-2.0> or the MIT license <LICENSE-MIT or
// http://opensource.org/licenses/MIT>, at your option. This file may not be
// copied, modified, or distributed except according to those terms.

use crate::simd::simdty::u64x4;

#[cfg(feature = "simd_opt")]
#[inline(always)]
pub fn rotate_right_const(vec: u64x4, n: u32) -> u64x4 {
    match n {
        32 => rotate_right_32(vec),
        24 => rotate_right_24(vec),
        16 => rotate_right_16(vec),
        _ => rotate_right_any(vec, n),
    }
}

#[cfg(not(feature = "simd_opt"))]
#[inline(always)]
pub fn rotate_right_const(vec: u64x4, n: u32) -> u64x4 {
    rotate_right_any(vec, n)
}

#[inline(always)]
fn rotate_right_any(vec: u64x4, n: u32) -> u64x4 {
    let r = n as u64;
    let l = 64 - r;

    (vec >> u64x4::new(r, r, r, r)) ^ (vec << u64x4::new(l, l, l, l))
}

#[cfg(feature = "simd_opt")]
#[inline(always)]
fn rotate_right_32(vec: u64x4) -> u64x4 {
    if cfg!(any(target_feature = "sse2", target_feature = "neon")) {
        // 2 x pshufd (SSE2) / vpshufd (AVX2) / 2 x vrev (NEON)
        transmute_shuffle!(u32x8, simd_shuffle8, vec, [1, 0, 3, 2, 5, 4, 7, 6])
    } else {
        rotate_right_any(vec, 32)
    }
}

#[cfg(feature = "simd_opt")]
#[inline(always)]
fn rotate_right_24(vec: u64x4) -> u64x4 {
    if cfg!(all(
        feature = "simd_asm",
        target_feature = "neon",
        target_arch = "arm"
    )) {
        // 4 x vext (NEON)
        rotate_right_vext(vec, 3)
    } else if cfg!(target_feature = "ssse3") {
        // 2 x pshufb (SSSE3) / vpshufb (AVX2)
        transmute_shuffle!(
            u8x32,
            simd_shuffle32,
            vec,
            [
                3, 4, 5, 6, 7, 0, 1, 2, 11, 12, 13, 14, 15, 8, 9, 10, 19, 20, 21, 22, 23, 16, 17,
                18, 27, 28, 29, 30, 31, 24, 25, 26
            ]
        )
    } else {
        rotate_right_any(vec, 24)
    }
}

#[cfg(feature = "simd_opt")]
#[inline(always)]
fn rotate_right_16(vec: u64x4) -> u64x4 {
    if cfg!(all(
        feature = "simd_asm",
        target_feature = "neon",
        target_arch = "arm"
    )) {
        // 4 x vext (NEON)
        rotate_right_vext(vec, 2)
    } else if cfg!(target_feature = "ssse3") {
        // 2 x pshufb (SSSE3) / vpshufb (AVX2)
        transmute_shuffle!(
            u8x32,
            simd_shuffle32,
            vec,
            [
                2, 3, 4, 5, 6, 7, 0, 1, 10, 11, 12, 13, 14, 15, 8, 9, 18, 19, 20, 21, 22, 23, 16,
                17, 26, 27, 28, 29, 30, 31, 24, 25
            ]
        )
    } else if cfg!(target_feature = "sse2") {
        // 2 x pshuflw+pshufhw (SSE2)
        transmute_shuffle!(
            u16x16,
            simd_shuffle16,
            vec,
            [1, 2, 3, 0, 5, 6, 7, 4, 9, 10, 11, 8, 13, 14, 15, 12]
        )
    } else {
        rotate_right_any(vec, 16)
    }
}

#[cfg(all(feature = "simd_asm", target_feature = "neon", target_arch = "arm"))]
mod simd_asm_neon_arm {
    use crate::simd::simdty::{u64x2, u64x4};

    #[inline(always)]
    fn vext_u64(vec: u64x2, b: u8) -> u64x2 {
        unsafe {
            let result: u64x2;
            asm!("vext.8 ${0:e}, ${1:e}, ${1:e}, $2\nvext.8 ${0:f}, ${1:f}, ${1:f}, $2"
               : "=w" (result)
               : "w" (vec), "n" (b));
            result
        }
    }

    #[inline(always)]
    pub fn rotate_right_vext(vec: u64x4, b: u8) -> u64x4 {
        use crate::simd::simdint::{simd_shuffle2, simd_shuffle4};

        unsafe {
            let tmp0 = vext_u64(simd_shuffle2(vec, vec, [0, 1]), b);
            let tmp1 = vext_u64(simd_shuffle2(vec, vec, [2, 3]), b);
            simd_shuffle4(tmp0, tmp1, [0, 1, 2, 3])
        }
    }
}

#[cfg(all(feature = "simd_asm", target_feature = "neon", target_arch = "arm"))]
use self::simd_asm_neon_arm::rotate_right_vext;

#[cfg(feature = "simd_opt")]
#[cfg(not(all(feature = "simd_asm", target_feature = "neon", target_arch = "arm")))]
fn rotate_right_vext(_vec: u64x4, _n: u8) -> u64x4 {
    unreachable!()
}

'''
'''--- src/simd/simdint.rs ---
// Copyright 2015 blake2-rfc Developers
//
// Licensed under the Apache License, Version 2.0, <LICENSE-APACHE or
// http://apache.org/licenses/LICENSE-2.0> or the MIT license <LICENSE-MIT or
// http://opensource.org/licenses/MIT>, at your option. This file may not be
// copied, modified, or distributed except according to those terms.

#![allow(dead_code)]

#[cfg(feature = "simd")]
extern "platform-intrinsic" {
    pub fn simd_add<T>(x: T, y: T) -> T;
    pub fn simd_shl<T>(x: T, y: T) -> T;
    pub fn simd_shr<T>(x: T, y: T) -> T;
    pub fn simd_xor<T>(x: T, y: T) -> T;

    pub fn simd_shuffle2<T, U>(v: T, w: T, idx: [u32; 2]) -> U;
    pub fn simd_shuffle4<T, U>(v: T, w: T, idx: [u32; 4]) -> U;
    pub fn simd_shuffle8<T, U>(v: T, w: T, idx: [u32; 8]) -> U;
    pub fn simd_shuffle16<T, U>(v: T, w: T, idx: [u32; 16]) -> U;
    pub fn simd_shuffle32<T, U>(v: T, w: T, idx: [u32; 32]) -> U;
}

'''
'''--- src/simd/simdop.rs ---
// Copyright 2015 blake2-rfc Developers
//
// Licensed under the Apache License, Version 2.0, <LICENSE-APACHE or
// http://apache.org/licenses/LICENSE-2.0> or the MIT license <LICENSE-MIT or
// http://opensource.org/licenses/MIT>, at your option. This file may not be
// copied, modified, or distributed except according to those terms.

#[cfg(feature = "simd")]
use crate::simd::simdint;
use crate::simd::simdty::{u32x4, u64x4};

use core::ops::{Add, BitXor, Shl, Shr};

macro_rules! impl_ops {
    ($vec:ident) => {
        impl Add for $vec {
            type Output = Self;

            #[cfg(feature = "simd")]
            #[inline(always)]
            fn add(self, rhs: Self) -> Self::Output {
                unsafe { simdint::simd_add(self, rhs) }
            }

            #[cfg(not(feature = "simd"))]
            #[inline(always)]
            fn add(self, rhs: Self) -> Self::Output {
                $vec::new(
                    self.0.wrapping_add(rhs.0),
                    self.1.wrapping_add(rhs.1),
                    self.2.wrapping_add(rhs.2),
                    self.3.wrapping_add(rhs.3),
                )
            }
        }

        impl BitXor for $vec {
            type Output = Self;

            #[cfg(feature = "simd")]
            #[inline(always)]
            fn bitxor(self, rhs: Self) -> Self::Output {
                unsafe { simdint::simd_xor(self, rhs) }
            }

            #[cfg(not(feature = "simd"))]
            #[inline(always)]
            fn bitxor(self, rhs: Self) -> Self::Output {
                $vec::new(
                    self.0 ^ rhs.0,
                    self.1 ^ rhs.1,
                    self.2 ^ rhs.2,
                    self.3 ^ rhs.3,
                )
            }
        }

        impl Shl<$vec> for $vec {
            type Output = Self;

            #[cfg(feature = "simd")]
            #[inline(always)]
            fn shl(self, rhs: Self) -> Self::Output {
                unsafe { simdint::simd_shl(self, rhs) }
            }

            #[cfg(not(feature = "simd"))]
            #[inline(always)]
            fn shl(self, rhs: Self) -> Self::Output {
                $vec::new(
                    self.0 << rhs.0,
                    self.1 << rhs.1,
                    self.2 << rhs.2,
                    self.3 << rhs.3,
                )
            }
        }

        impl Shr<$vec> for $vec {
            type Output = Self;

            #[cfg(feature = "simd")]
            #[inline(always)]
            fn shr(self, rhs: Self) -> Self::Output {
                unsafe { simdint::simd_shr(self, rhs) }
            }

            #[cfg(not(feature = "simd"))]
            #[inline(always)]
            fn shr(self, rhs: Self) -> Self::Output {
                $vec::new(
                    self.0 >> rhs.0,
                    self.1 >> rhs.1,
                    self.2 >> rhs.2,
                    self.3 >> rhs.3,
                )
            }
        }
    };
}

impl_ops!(u32x4);
impl_ops!(u64x4);

'''
'''--- src/simd/simdty.rs ---
// Copyright 2016 blake2-rfc Developers
//
// Licensed under the Apache License, Version 2.0, <LICENSE-APACHE or
// http://apache.org/licenses/LICENSE-2.0> or the MIT license <LICENSE-MIT or
// http://opensource.org/licenses/MIT>, at your option. This file may not be
// copied, modified, or distributed except according to those terms.

#![allow(dead_code, non_camel_case_types)]

use crate::as_bytes::Safe;

#[cfg(feature = "simd")]
macro_rules! decl_simd {
    ($($decl:item)*) => {
        $(
            #[derive(Clone, Copy, Debug)]
            #[repr(simd)]
            $decl
        )*
    }
}

#[cfg(not(feature = "simd"))]
macro_rules! decl_simd {
    ($($decl:item)*) => {
        $(
            #[derive(Clone, Copy, Debug)]
            #[repr(C)]
            $decl
        )*
    }
}

decl_simd! {
    pub struct Simd2<T>(pub T, pub T);
    pub struct Simd4<T>(pub T, pub T, pub T, pub T);
    pub struct Simd8<T>(pub T, pub T, pub T, pub T,
                        pub T, pub T, pub T, pub T);
    pub struct Simd16<T>(pub T, pub T, pub T, pub T,
                         pub T, pub T, pub T, pub T,
                         pub T, pub T, pub T, pub T,
                         pub T, pub T, pub T, pub T);
    pub struct Simd32<T>(pub T, pub T, pub T, pub T,
                         pub T, pub T, pub T, pub T,
                         pub T, pub T, pub T, pub T,
                         pub T, pub T, pub T, pub T,
                         pub T, pub T, pub T, pub T,
                         pub T, pub T, pub T, pub T,
                         pub T, pub T, pub T, pub T,
                         pub T, pub T, pub T, pub T);
}

pub type u64x2 = Simd2<u64>;

pub type u32x4 = Simd4<u32>;
pub type u64x4 = Simd4<u64>;

pub type u16x8 = Simd8<u16>;
pub type u32x8 = Simd8<u32>;

pub type u8x16 = Simd16<u8>;
pub type u16x16 = Simd16<u16>;

pub type u8x32 = Simd32<u8>;

impl<T> Simd4<T> {
    #[inline(always)]
    pub fn new(e0: T, e1: T, e2: T, e3: T) -> Simd4<T> {
        Simd4(e0, e1, e2, e3)
    }
}

unsafe impl<T: Safe> Safe for Simd2<T> {}
unsafe impl<T: Safe> Safe for Simd4<T> {}
unsafe impl<T: Safe> Safe for Simd8<T> {}
unsafe impl<T: Safe> Safe for Simd16<T> {}
unsafe impl<T: Safe> Safe for Simd32<T> {}

'''
'''--- tests/lib.rs ---
#![no_std]

use digest::dev::{digest_test, variable_test};
use digest::new_test;

new_test!(
    blake2b_fixed,
    "blake2b/fixed",
    near_blake2::Blake2b,
    digest_test
);
new_test!(
    blake2b_variable,
    "blake2b/variable",
    near_blake2::VarBlake2b,
    variable_test
);
new_test!(
    blake2s_variable,
    "blake2s/variable",
    near_blake2::VarBlake2s,
    variable_test
);

'''
'''--- tests/mac.rs ---
#![no_std]

use crypto_mac::new_test;

new_test!(blake2b_mac, "blake2b/mac", near_blake2::Blake2b);
new_test!(blake2s_mac, "blake2s/mac", near_blake2::Blake2s);

'''
'''--- tests/persona.rs ---
use hex_literal::hex;
use near_blake2::{Blake2b, Blake2s, Digest};

#[test]
fn blake2s_persona() {
    let key_bytes = hex!("000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f");
    let persona = "personal";
    let persona_bytes = persona.as_bytes();
    let ctx = Blake2s::with_params(&key_bytes, &[], persona_bytes);
    assert_eq!(
        ctx.finalize().as_slice(),
        &hex!("25a4ee63b594aed3f88a971e1877ef7099534f9097291f88fb86c79b5e70d022")[..]
    );
}

#[test]
fn blake2b_persona() {
    let key_bytes = hex!("000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f");
    let persona = "personal";
    let persona_bytes = persona.as_bytes();
    let ctx = Blake2b::with_params(&key_bytes, &[], persona_bytes);
    assert_eq!(ctx.finalize().as_slice(), &hex!("03de3b295dcfc3b25b05abb09bc95fe3e9ff3073638badc68101d1e42019d0771dd07525a3aae8318e92c5e5d967ba92e4810d0021d7bf3b49da0b4b4a8a4e1f")[..]);
}

'''
'''--- tests/state.rs ---
// https://tools.ietf.org/html/rfc7693#appendix-A
#[test]
fn blake2b_state() {
    let rounds = 12;
    // Initial IV with parameter block.
    let h: [u64; 8] = [
        0x6a09e667f2bdc948,
        0xbb67ae8584caa73b,
        0x3c6ef372fe94f82b,
        0xa54ff53a5f1d36f1,
        0x510e527fade682d1,
        0x9b05688c2b3e6c1f,
        0x1f83d9abfb41bd6b,
        0x5be0cd19137e2179,
    ];
    let m = b"abc";
    let t0 = 0;
    let t1 = 0;
    let f0 = !0;
    let f1 = 0;

    let expected: [u8; 64] = [
        0xba, 0x80, 0xa5, 0x3f, 0x98, 0x1c, 0x4d, 0x0d, 0x6a, 0x27, 0x97, 0xb6, 0x9f, 0x12, 0xf6,
        0xe9, 0x4c, 0x21, 0x2f, 0x14, 0x68, 0x5a, 0xc4, 0xb7, 0x4b, 0x12, 0xbb, 0x6f, 0xdb, 0xff,
        0xa2, 0xd1, 0x7d, 0x87, 0xc5, 0x39, 0x2a, 0xab, 0x79, 0x2d, 0xc2, 0x52, 0xd5, 0xde, 0x45,
        0x33, 0xcc, 0x95, 0x18, 0xd3, 0x8a, 0xa8, 0xdb, 0xf1, 0x92, 0x5a, 0xb9, 0x23, 0x86, 0xed,
        0xd4, 0x0, 0x99, 0x23,
    ];

    let mut hasher = near_blake2::VarBlake2b::with_state(rounds, h, [t0, t1]);
    hasher.update_inner(m);
    hasher.compress(f0, f1);
    let res = hasher.output();

    assert_eq!(res.as_slice(), expected);
}

// https://tools.ietf.org/html/rfc7693#appendix-A
#[test]
fn blake2s_state() {
    let rounds = 10;
    let h: [u32; 8] = [
        0x6b08e647, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab,
        0x5be0cd19,
    ];
    let m: &[u8; 3] = b"abc";
    let t0 = 0;
    let t1 = 0;
    let f0 = !0;
    let f1 = 0;

    let expected: &[u8; 32] = &[
        0x50, 0x8c, 0x5e, 0x8c, 0x32, 0x7c, 0x14, 0xe2, 0xe1, 0xa7, 0x2b, 0xa3, 0x4e, 0xeb, 0x45,
        0x2f, 0x37, 0x45, 0x8b, 0x20, 0x9e, 0xd6, 0x3a, 0x29, 0x4d, 0x99, 0x9b, 0x4c, 0x86, 0x67,
        0x59, 0x82,
    ];

    let mut hasher = near_blake2::VarBlake2s::with_state(rounds, h, [t0, t1]);
    hasher.update_inner(m);
    hasher.compress(f0, f1);
    let res = hasher.output();

    assert_eq!(res.as_slice(), expected);
}

#[test]
fn blake2b_state_100r() {
    let rounds = 100;
    // Initial IV with parameter block.
    let h: [u64; 8] = [
        0x6a09e667f2bdc948,
        0xbb67ae8584caa73b,
        0x3c6ef372fe94f82b,
        0xa54ff53a5f1d36f1,
        0x510e527fade682d1,
        0x9b05688c2b3e6c1f,
        0x1f83d9abfb41bd6b,
        0x5be0cd19137e2179,
    ];
    let m = b"abc";
    let t0 = 0;
    let t1 = 0;
    let f0 = !0;
    let f1 = 0;

    let expected: [u8; 64] = [
        0x81, 0x36, 0x97, 0x2e, 0xb0, 0xcc, 0x5, 0xf3, 0xdf, 0x5e, 0xc9, 0x8a, 0xc6, 0x4b, 0x7e,
        0x95, 0x57, 0xba, 0xd1, 0x47, 0x11, 0xf1, 0x5f, 0xde, 0x8f, 0x42, 0x83, 0x4c, 0xf6, 0xbb,
        0xab, 0x48, 0x1b, 0x81, 0xb1, 0xb3, 0xc0, 0xbd, 0x70, 0x3f, 0x65, 0x69, 0x4e, 0x76, 0x39,
        0x75, 0xd0, 0x5c, 0x55, 0xc7, 0x31, 0xbf, 0xa1, 0xaf, 0xdd, 0x3a, 0x11, 0x8d, 0xcb, 0xf4,
        0xef, 0x7c, 0x28, 0x45,
    ];

    let mut hasher = near_blake2::VarBlake2b::with_state(rounds, h, [t0, t1]);
    hasher.update_inner(m);
    hasher.compress(f0, f1);
    let res = hasher.output();

    assert_eq!(res.as_slice(), expected);
}

'''