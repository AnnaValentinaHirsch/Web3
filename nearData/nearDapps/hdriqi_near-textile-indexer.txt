*GitHub Repository "hdriqi/near-textile-indexer"*

'''--- README.md ---
# near-textile-indexer

Event indexer for smart contract on [NEAR](https://near.org) using [Textile](https://textile.io) as storage and query engine.

## Problem

Doing intensive computation (sorting, etc) for get request is not possible on blockchain due to it's nature for decentralization.

Developers at NEAR create their own indexer (Flux Protocol, Mintbase, Paras). 
They need to setup a centralized database for the indexing layer. 

What if we also have a decentralized database for the indexing layer? 
This is where Textile's ThreadDB shine. A decentralized indexing layer.

Ethereum developers has Graph Protocol and they expect NEAR to have something similar. 
This repo is the proof of concept for NEAR indexing layer using decentralized database by Textile.

## TL;DR

Read the implementation via [example](https://github.com/hdriqi/near-textile-indexer-example).

or

Watch the demo & tutorial

[<img src="https://i.ibb.co/zm5BNVs/5f71561edd3b4near-textile-demo.png">](
https://www.loom.com/share/4d2382fa6e634569b51e467ede03d69e
)

## Installation

`npm install near-textile-indexer`

or

`yarn add near-textile-indexer`

## How to use

Unlike Ethereum, NEAR does not have built-in Event. This indexer requires your smart contract to have the Event store.

### Smart Contract

You can find the smart contract on code on [example here](https://github.com/hdriqi/near-textile-indexer-example).

You must create a `PersistentVector` that holds all the `Event` on smart contract with `getEvent` and `getEventHeight` public methods for querying the event.

#### PersistentVector

```ts
const events = new PersistentVector<Event>('events')
```

#### getEvent

```ts
export function getEvent(index: i32): Event {
	return events[index]
}
```

#### getEventHeight

```ts
export function getEventHeight(): i32 {
	return events.length
}
```

#### Event type

```ts
Event {
  collection: string
  action: string
  params: string[]
}
```

### Indexer

If your smart contract is ready with all the requirement above, you can setup the indexer.

The indexer will generate `setup.json` that contains `threadID` and `eventHeight`.

```js
const indexer = require('near-textile-indexer')

const config = {
  ...
}

indexer(config)
```

#### Config

```js
const config = {
  // NEAR network ID
  networkId: string,
  // NEAR node url
  nodeUrl: string,
  // NEAR contract name
  contractName: string,
  // key generated via https://docs.textile.io/hub/apis/
	keyInfo: {
		key: process.env.TEXTILE_API_KEY
  },
  // admin private key generated via https://textileio.github.io/js-hub/docs/hub.privatekey
  privateKey: process.env.ADMIN_PRIVATE_KEY,
  // see https://textileio.github.io/js-hub/docs/hub.collectionconfig
	collections: CollectionConfig[],
	// callback called when new event found
	async processEvent(ctx, event, textileClient) {
		// see example for more information
	}
}
```

### Query

You can easily query the data using `@textile/hub` on client or server side.

Here's the example code

```js
const { Client, ThreadID, PrivateKey } = require('@textile/hub')

const keyInfo = {
	key: 'xxx',
}
const threadID = 'yyy'

const client = await Client.withKeyInfo(keyInfo)
const identity = PrivateKey.fromRandom()
await client.getToken(identity)
const tID = ThreadID.fromString(threadID)
const x = await client.find(tID, 'person', {})
```

## License

MIT License

'''
'''--- package.json ---
{
  "name": "near-textile-indexer",
  "version": "1.0.0",
  "description": "NEAR indexer using textile as storage and query engine",
  "main": "src/index.js",
  "module": "src/index.js",
  "scripts": {
    "dev": "NODE_ENV=development nodemon --watch js src/index.js"
  },
  "dependencies": {
    "@textile/hub": "^1.0.0",
    "dotenv": "^8.2.0",
    "isomorphic-ws": "^4.0.1",
    "near-api-js": "^0.29.1",
    "ws": "^7.3.1"
  },
  "devDependencies": {
    "nodemon": "^2.0.4"
  },
  "author": "Rahmat Albariqi",
  "license": "MIT"
}

'''
'''--- src/index.js ---
const fs = require('fs')
const path = require('path')
const Textile = require('./textile')
const sync = require('./sync')

const getSetup = async (setupPath) => {
	try {
		const setupJSON = fs.readFileSync(setupPath)
		const setupData = JSON.parse(setupJSON)
		if (
			!(
				setupData.hasOwnProperty('threadID') &&
				setupData.hasOwnProperty('eventHeight')
			)
		) {
			throw new Error('Invalid setup.json')
		}
		return setupData
	} catch (err) {
		if (err.code == 'ENOENT') {
			return null
		} else {
			throw err
		}
	}
}

const main = async (config) => {
	if (!config.contractName) {
		console.log('[config] contractName is required')
		process.exit(1)
	}
	const setupPath = path.join(process.cwd(), 'setup.json')
	const ctx = {}
	try {
		let setup = await getSetup(setupPath)

		const textile = new Textile()
		await textile.init(config.keyInfo, config.privateKey)

		if (!setup) {
			// generate setup.json
			console.log(`creating initial setup.json`)
			const dbName = `${config.contractName}-${new Date().getTime()}`
			const threadID = await textile.client.newDB(undefined, dbName)
			const setupData = {
				threadID: threadID.toString(),
				eventHeight: 0,
			}
			fs.writeFileSync(setupPath, JSON.stringify(setupData))
			console.log(`setup.json done`)
			setup = setupData
		}
		console.log(`found setup.json`)
		ctx.setup = setup
		ctx.threadID = await textile.parseThreadID(setup.threadID)
		ctx.setupPath = setupPath

		console.log(`setting up collections`)
		for (const collection of config.collections) {
			console.log(`${collection.name}`)
			try {
				await textile.client.getCollectionInfo(ctx.threadID, collection.name)
				await textile.client.updateCollection(ctx.threadID, collection)
			} catch (err) {
				if (err.message === 'collection not found') {
					console.log(collection)
					await textile.client.newCollection(ctx.threadID, collection)
				} else {
					console.log(err)
				}
			}
		}
		console.log(`done setting up collections`)

		sync(ctx, textile.client, config)
	} catch (err) {
		console.log(err)
		process.exit(1)
	}
}

module.exports = main

'''
'''--- src/sync.js ---
const nearAPI = require('near-api-js')
const path = require('path')
const { UnencryptedFileSystemKeyStore } = require('near-api-js/lib/key_stores')
const { homedir } = require('os')
const { writeFileSync } = require('fs')

const CREDENTIALS_DIR = '.near-credentials'
const credentialsPath = path.join(homedir(), CREDENTIALS_DIR)

const processEvent = async (ctx, newEvent, textileClient, config) => {
	console.log('processing event')
	await config.processEvent(ctx, newEvent, textileClient, config)
}

const fetchEvent = async (ctx, account, textileClient, config) => {
	const eventHeight = await account.viewFunction(
		config.contractName,
		'getEventHeight',
		''
	)
	const curEventHeight = ctx.setup.eventHeight
	if (eventHeight > curEventHeight) {
		console.log(`sync event height ${curEventHeight}`)
		const newEvent = await account.viewFunction(
			config.contractName,
			'getEvent',
			{
				index: curEventHeight,
			}
		)
		try {
			await processEvent(ctx, newEvent, textileClient, config)
			console.log(`successfully processing event ${curEventHeight}`)
			ctx.setup.eventHeight += 1
			writeFileSync(ctx.setupPath, JSON.stringify(ctx.setup))
		} catch (err) {
			console.log(err)
		}
	}
	console.log(`syncing ${(curEventHeight * 100) / eventHeight}%`)
	setTimeout(() => {
		fetchEvent(ctx, account, textileClient, config)
	}, 500)
}

const main = async (ctx, textileClient, config) => {
	const nearConfig = {
		networkId: config.networkId,
		nodeUrl: config.nodeUrl,
		contractName: config.contractName,
	}
	console.log(`connecting to NEAR blockchain...`)
	const near = await nearAPI.connect({
		deps: {
			keyStore: new UnencryptedFileSystemKeyStore(credentialsPath),
		},
		...nearConfig,
	})
	const account = await near.account(config.contractName)
	console.log(`connected!`)
	fetchEvent(ctx, account, textileClient, config)
}

module.exports = main

'''
'''--- src/textile.js ---
const { PrivateKey } = require('@textile/hub')
const { Client, ThreadID } = require('../textile')

class Textile {
	constructor() {
		this.client = null
	}

	async init(keyInfo, privateKey) {
		this.client = await Client.withKeyInfo(keyInfo)
		const identity = PrivateKey.fromString(privateKey)
		await this.client.getToken(identity)
		console.log(`authenticate as ${identity.public.toString()}`)
	}

	async createDB(dbName) {
		try {
			const threadID = await this.client.newDB(undefined, dbName)
			return threadID
		} catch (err) {
			console.log(err)
		}
	}

	async parseThreadID(threadID) {
		return ThreadID.fromString(threadID)
	}
}

module.exports = Textile

'''
'''--- textile.js ---
const textile = require('@textile/hub')

module.exports = textile

'''