*GitHub Repository "NguyenTrongTin1107/dMart_fe"*

'''--- README.md ---
This is a [Next.js](https://nextjs.org/) project bootstrapped with [`create-next-app`](https://github.com/vercel/next.js/tree/canary/packages/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `pages/index.tsx`. The page auto-updates as you edit the file.

[API routes](https://nextjs.org/docs/api-routes/introduction) can be accessed on [http://localhost:3000/api/hello](http://localhost:3000/api/hello). This endpoint can be edited in `pages/api/hello.ts`.

The `pages/api` directory is mapped to `/api/*`. Files in this directory are treated as [API routes](https://nextjs.org/docs/api-routes/introduction) instead of React pages.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js/) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/deployment) for more details.

'''
'''--- apis/account.api.ts ---
import { BN } from 'bn.js';
import { parseNearAmount } from 'near-api-js/lib/utils/format';
import { getContainer } from '../core';
import { TransactionAction } from '../core/types';
import { parseToUsername } from '../core/utils';
import { AccountDto, AccountInfoDto, NftDto } from '../dtos';
import { mapToNftDto } from './nft.api';

enum ContractMethods {
  storage_deposit = 'storage_deposit',
  storage_withdraw = 'storage_withdraw',
  is_registered = 'is_registered',
  set_account_info = 'set_account_info',
  storage_minimum_balance = 'storage_minimum_balance',
  is_admin = 'is_admin',
  get_account = 'get_account',
  get_accounts = 'get_accounts',

  get_bookmarks = 'get_bookmarks',
  add_bookmark = 'add_bookmark',
  remove_bookmark = 'remove_bookmark',
}

export const AccountApi = Object.freeze({
  async storageDeposit(): Promise<void> {
    await getContainer().bcConnector.callChangeMethod({
      methodName: ContractMethods.storage_deposit,
      args: {},
      attachedDeposit: new BN(parseNearAmount('0.2') ?? 0),
    });
  },
  async storageWithdraw(amount: number): Promise<void> {
    console.log('payload ', amount, parseNearAmount(amount.toString()));
    await getContainer().bcConnector.callChangeMethod({
      methodName: ContractMethods.storage_withdraw,
      args: { amount: parseNearAmount(amount.toString()) ?? '0' },
      attachedDeposit: new BN(1),
    });
  },
  async isRegistered(): Promise<boolean> {
    const res = await getContainer().bcConnector.callViewMethod({
      methodName: ContractMethods.is_registered,
      args: {
        account_id: getContainer().bcConnector.wallet.getAccountId(),
      },
    });
    return res;
  },
  async storageMinimumBalance(): Promise<number> {
    const res = await getContainer().bcConnector.callViewMethod({
      methodName: ContractMethods.storage_minimum_balance,
      args: {},
    });
    return res;
  },
  async isAdmin(account_id: string): Promise<boolean> {
    const res = await getContainer().bcConnector.callViewMethod({
      methodName: ContractMethods.is_admin,
      args: {
        account_id,
      },
    });
    return res;
  },
  async fetchAccount(accountId: string): Promise<AccountDto> {
    let account: AccountDto = await getContainer().bcConnector.callViewMethod({
      methodName: ContractMethods.get_account,
      args: {
        account_id: accountId,
      },
    });
    console.log('account data', account);
    if (account) {
      return mapToAccount({ ...account, account_id: accountId });
    }
    throw new Error(`Account does not exist ${accountId}`);
  },
  async fetchAccounts(): Promise<AccountDto[]> {
    let accounts: AccountDto[] =
      await getContainer().bcConnector.callViewMethod({
        methodName: ContractMethods.get_accounts,
        args: {
          from_index: 0,
          limit: 500,
        },
      });
    console.log(mapToAccounts(accounts));
    return mapToAccounts(accounts);
  },
  async setAccountInfo(payload: AccountInfoDto): Promise<void> {
    const args = {
      account_info: btoa(JSON.stringify(payload)),
    };

    await getContainer().bcConnector.callChangeMethod({
      methodName: ContractMethods.set_account_info,
      args,
    });
  },
  async getBookmarks(): Promise<NftDto[]> {
    const res = await getContainer().bcConnector.callViewMethod({
      methodName: ContractMethods.get_bookmarks,
      args: { account_id: getContainer().bcConnector.wallet.getAccountId() },
    });
    return res.map((val: any) => mapToNftDto(val));
  },
  async addBookmark(nftId: string): Promise<void> {
    await getContainer().bcConnector.callChangeMethod({
      methodName: ContractMethods.add_bookmark,
      args: { nft_id: nftId },
    });
  },
  async removeBookmark(nftId: string): Promise<void> {
    await getContainer().bcConnector.callChangeMethod({
      methodName: ContractMethods.remove_bookmark,
      args: { nft_id: nftId },
    });
  },
});

const mapToAccounts = (raws: any[]): AccountDto[] => {
  return raws.map<AccountDto>((item) => {
    return mapToRawAccount(item);
  });
};

const mapToRawAccount = (item: any): AccountDto => {
  console.log(item);
  const accountInfo: AccountInfoDto = item[1]?.account_info
    ? JSON.parse(atob(item[1]?.account_info))
    : {};
  if (!accountInfo?.displayName)
    accountInfo.displayName = parseToUsername(item[0]);
  return {
    id: item[0],
    accountInfo,
    favouriteNfts: [],
    numFollowers: item[1]?.num_followers,
    numFollowing: item[1]?.num_following,
    numNfts: item[1]?.num_nfts,
    nfts: item[1]?.nfts,
  };
};

const mapToAccount = (item: any): AccountDto => {
  const accountInfo: AccountInfoDto = item?.account_info
    ? JSON.parse(atob(item?.account_info))
    : {};
  if (!accountInfo?.displayName)
    accountInfo.displayName = parseToUsername(item.account_id);
  return {
    id: item.account_id,
    accountInfo,
    favouriteNfts: item?.favourite_nfts.map((val: any) => mapToNftDto(val)),
    numFollowers: item?.num_followers,
    numFollowing: item?.num_following,
    numNfts: item?.num_nfts,
    nfts: item?.nfts,
  };
};

'''
'''--- apis/balance.api.ts ---
import BN from 'bn.js';
import { parseNearAmount } from 'near-api-js/lib/utils/format';
import { MIN_ENOUGH_STORAGE_BALANCE } from '../constants';
import { getContainer } from '../core';
import { BalanceDto } from '../dtos';

enum ContractMethods {
  storage_balance_of = 'storage_balance_of',
  storage_deposit = 'storage_deposit',
}

export const BalanceApi = Object.freeze({
  async fetchBalance(): Promise<BalanceDto> {
    const res = await getContainer().bcConnector.callViewMethod({
      methodName: ContractMethods.storage_balance_of,
      args: {
        account_id: getContainer().bcConnector.wallet.getAccountId(),
      },
    });
    return mapToBalance(res);
  },
  async storageDeposit(): Promise<void> {
    await getContainer().bcConnector.callChangeMethod({
      methodName: ContractMethods.storage_deposit,
      args: {},
      attachedDeposit: new BN(parseNearAmount('0.2') ?? 0),
    });
  },
});

const mapToBalance = (raw: any): BalanceDto => {
  const available = new BN(raw.available);

  return {
    ...raw,
    isEnough: available.gt(MIN_ENOUGH_STORAGE_BALANCE),
  };
};

'''
'''--- apis/index.ts ---
export * from './account.api';
export * from './nft.api';
export * from './balance.api';

'''
'''--- apis/nft.api.ts ---
import { BN } from 'bn.js';
import { parseNearAmount } from 'near-api-js/lib/utils/format';
import { getContainer } from '../core';
import { Optional } from '../core/types';
import { NFTMetadata, NftDto, OrderDto } from '../dtos';

enum ContractMethods {
  mint_nft = 'mint_nft',
  mint_art_nft = 'mint_art_nft',
  sell_nft = 'sell_nft',
  buy_nft = 'buy_nft',
  nft_transfer = 'nft_transfer',
  tokens_metadata_of_owner = 'tokens_metadata_of_owner',
  token_metadata = 'token_metadata',
}

export type MintNftInput = {
  title: string;
  description: string;
  media: string;
  extra: string;
  receiverId: string;
};

export type SellNftInput = {
  nftId: string;
  price: string;
};

export const NftApi = Object.freeze({
  async fetchListNFTs(accountId: string): Promise<NftDto[]> {
    const res = await getContainer().bcConnector.callViewMethod({
      methodName: ContractMethods.tokens_metadata_of_owner,
      args: {
        owner_id: accountId,
      },
    });

    return res.map((item: any) => mapToNftDto(item));
  },

  async fetchNFTMetadata(tokenId: string): Promise<Optional<NFTMetadata>> {
    try {
      const res = await getContainer().bcConnector.callViewMethod({
        methodName: ContractMethods.token_metadata,
        args: {
          token_id: tokenId,
        },
      });

      return res;
    } catch (err) {
      console.log(err);
    }
  },

  async mintArtNft(payload: MintNftInput): Promise<void> {
    await getContainer().bcConnector.callChangeMethod({
      methodName: ContractMethods.mint_art_nft,
      args: {
        receiver_id:
          payload.extra == 'Certificate'
            ? payload.receiverId
            : getContainer().bcConnector.wallet.getAccountId(),
        metadata: payload,
      },
      attachedDeposit: new BN(parseNearAmount('0.2') ?? 0),
    });
  },

  async sellNft(payload: SellNftInput): Promise<void> {
    await getContainer().bcConnector.callChangeMethod({
      methodName: ContractMethods.sell_nft,
      args: {
        nft_id: payload.nftId,
        price: parseNearAmount(payload.price),
      },
      attachedDeposit: new BN(1),
      // attachedDeposit: new BN(parseNearAmount('0.2') ?? 0),
    });
  },

  async buyNft(payload: OrderDto): Promise<void> {
    await getContainer().bcConnector.callChangeMethod({
      methodName: ContractMethods.buy_nft,
      args: {
        order_id: payload.orderId,
      },
      attachedDeposit: new BN(payload.price.toString() ?? 0),
    });
  },
});

export const mapToNftDto = (item: any): NftDto => {
  return {
    ...item,
    tokenId: item.token_id,
    ownerId: item.owner_id,
    metadata: {
      ...item.metadata,
    },
  };
};

'''
'''--- apis/order.api.ts ---
import { BN } from 'bn.js';
import { parseNearAmount } from 'near-api-js/lib/utils/format';
import { getContainer } from '../core';
import { Optional } from '../core/types';
import { NFTMetadata, NftDto, OrderDto } from '../dtos';
import { mapToNftDto } from './nft.api';

enum ContractMethods {
  get_orders = 'get_orders',
  get_account_orders = 'get_account_orders',
}

export const OrderApi = Object.freeze({
  async fetchListOrders(): Promise<OrderDto[]> {
    const res = await getContainer().bcConnector.callViewMethod({
      methodName: ContractMethods.get_orders,
      args: {},
    });

    return res
      .map((item: any) => mapToOrder(item))
      .filter((item: OrderDto) => !item.isSold);
  },
  async fetchListAccountOrders(accountId: string): Promise<OrderDto[]> {
    const res = await getContainer().bcConnector.callViewMethod({
      methodName: ContractMethods.get_account_orders,
      args: {
        account_id: getContainer().bcConnector.wallet.getAccountId(),
      },
    });

    return res
      .map((item: any) => mapToOrder(item))
      .filter((item: OrderDto) => !item.isSold);
  },
});

const mapToOrder = (item: any): OrderDto => {
  return {
    orderId: item.order_id,
    ownerId: item.owner_id,
    nftId: item.nft_id,
    price: item.price,
    createAt: item.create_at,
    isSold: item.is_sold,
    metadata: {
      ...item.metadata,
    },
  };
};

'''
'''--- assets/logos/DMartIcon.svg ---
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 74.46 74.46"><defs><style>.cls-1{fill:#414042;}.cls-2{fill:#d1d3d4;}.cls-3{fill:#ed1c24;}</style></defs><g id="Layer_2" data-name="Layer 2"><g id="Layer_1-2" data-name="Layer 1"><circle class="cls-1" cx="37.23" cy="37.23" r="37.23"/><path class="cls-2" d="M28.3,51.43v-2a12,12,0,0,1-6.86,2.14,12.12,12.12,0,0,1,0-24.24,12,12,0,0,1,6.86,2.14V15.23h9.38Z"/><polygon class="cls-3" points="63.14 59.11 63.14 59.23 51.09 59.23 51.09 37.57 47.3 42.67 48.7 46.51 45.88 46.51 45.16 45.54 44.44 46.51 41.62 46.51 43.02 42.67 39.22 37.57 39.22 59.23 27.17 59.23 27.17 59.11 38.02 17.23 45.16 36.8 52.29 17.23 63.14 59.11"/><polygon class="cls-3" points="37.24 37.17 37.24 37.29 37.22 37.29 37.24 37.17"/></g></g></svg>
'''
'''--- cache/index.ts ---
export {};

'''
'''--- components/header-account/header-account.module.css ---
.root [class='rs-dropdown-menu'] {
  background: transparent !important;
}

'''
'''--- components/index.ts ---
export * from './login-button';
export * from './footer';
export * from './navbar';
export * from './banner';
export * from './headline';
export * from './checkbox';
export * from './trending-card';
export * from './nft-card';
export * from './order-card';
export * from './avatar';
export * from './header-account';
export * from './accounts-list';
export * from './header-account-title';
export * from './mint-nft-modal';
export * from './sell-nft-modal';
export * from './add-storage-balance-modal';
export * from './storage-deposit-modal';
export * from './storage-withdraw-modal';

'''
'''--- constants/cache-prefix-keys.ts ---
export enum CachePrefixKeys {
  CATEGORY,
  ACCOUNT,
  LIST_ACCOUNT_POSTS,
  LIST_NFT,
  LIST_FAVOURITE_NFTS,
  LIST_ORDERS,
  LIST_POSTS,
  ACCOUNT_FOLLOWING,
  ACCOUNT_SEARCH,
}

'''
'''--- constants/index.ts ---
import BN from 'bn.js';

export * from './storage-keys';
export * from './cache-prefix-keys';
// export * from './contract';

export const MAX_WIDTH_CONTENT = '1200px';
export const MIN_ENOUGH_STORAGE_BALANCE = new BN('100000000000000000000000'); // 0.1 NEAR
export const IPFS_UPLOAD_SERVER_URL = 'https://ipfs-server.vercel.app';
export const IPFS_HOST = 'rep-run.infura-ipfs.io';
export const IPFS_BASE_URL = 'https://rep-run.infura-ipfs.io/ipfs/';

'''
'''--- constants/storage-keys.ts ---
export enum StorageKeys {
  CONTRACT_ID = 'CONTRACT_ID',
}

'''
'''--- core/blockchain/blockchain.connector.ts ---
export interface IBlockchainConnector<T = any> {
  conn: T;
  connect(): Promise<T>;
}

'''
'''--- core/blockchain/index.ts ---
export * from './blockchain.connector';

'''
'''--- core/blockchain/near/index.ts ---
export * from './near.connector';

'''
'''--- core/blockchain/near/near.connector.ts ---
import { BN } from 'bn.js';
import { connect, keyStores, Near, transactions, WalletConnection, Connection } from 'near-api-js';
import { ChangeFunctionCallOptions, ViewFunctionCallOptions } from 'near-api-js/lib/account';
import { NearConfig } from 'near-api-js/lib/near';
import { TransactionAction } from '../../types';
import { IBlockchainConnector } from '../blockchain.connector';

WalletConnection.prototype._completeSignInWithAccessKey = async function () {
  const currentUrl = new URL(window.location.href);
  const contractId = currentUrl.searchParams.get('contract_id') || '';
  if (contractId !== this._near.config.contractId) return;

  const publicKey = currentUrl.searchParams.get('public_key') || '';
  const allKeys = (currentUrl.searchParams.get('all_keys') || '').split(',');
  const accountId = currentUrl.searchParams.get('account_id') || '';
  // TODO: Handle errors during login
  if (accountId) {
    const authData = {
      accountId,
      allKeys,
    };
    window.localStorage.setItem(this._authDataKey, JSON.stringify(authData));
    if (publicKey) {
      await this._moveKeyFromTempToPermanent(accountId, publicKey);
    }
    this._authData = authData;
  }
  currentUrl.searchParams.delete('public_key');
  currentUrl.searchParams.delete('all_keys');
  currentUrl.searchParams.delete('account_id');
  currentUrl.searchParams.delete('meta');
  currentUrl.searchParams.delete('transactionHashes');
  currentUrl.searchParams.delete('contract_id');
  window.history.replaceState({}, document.title, currentUrl.toString());
};

const NUM_BLOCKS_NON_ARCHIVAL = 4 * 12 * 3600;

export type NearConnectorConfig = NearConfig & {
  contractId: string;
};
export type NearConnectorOptions = {
  afterCallChangeMethod?: () => any;
};
export type NearSignInOptions = {
  contractId?: string;
  methodNames?: string[];
  successUrl?: string;
  failureUrl?: string;
};
export class NearConnector implements IBlockchainConnector<Near> {
  constructor(config: NearConnectorConfig, options?: NearConnectorOptions) {
    this._config = config;
    this._options = options;
  }

  private _config: NearConnectorConfig;
  private _options?: NearConnectorOptions;
  private _lastBlockHeight!: number;
  private _archivalConnection!: Connection;

  get config(): NearConnectorConfig {
    return this._config;
  }

  private _conn?: Near;
  get conn(): Near {
    if (!this._conn) throw new Error(`${this.constructor.name}: conn not initialize`);
    return this._conn;
  }

  private _wallet?: WalletConnection;
  get wallet(): WalletConnection {
    if (!this._wallet) throw new Error(`${this.constructor.name}: wallet not initialize`);
    return this._wallet;
  }

  async connect(): Promise<Near> {
    const keyStore = new keyStores.BrowserLocalStorageKeyStore(window.localStorage, this.config.contractId);
    this._conn = await connect({
      ...this._config,
      keyStore,
    });
    this._wallet = new WalletConnection(this.conn, this.config.contractId);
    this._archivalConnection = Connection.fromConfig({
      networkId: this.config.networkId,
      provider: {
        type: 'JsonRpcProvider',
        args: {
          url: this.config.nodeUrl,
        },
      },
      signer: { type: 'InMemorySigner', keyStore },
    });
    return this.conn;
  }

  async signIn() {
    return this.wallet.requestSignIn({
      contractId: this.config.contractId,
      successUrl: `${location.origin + location.pathname}?contract_id=${this.config.contractId}`,
    });
  }

  async signOut() {
    return this.wallet.signOut();
  }

  async isSignedIn() {
    return this.wallet.isSignedInAsync();
  }

  public get lastBlockHeight(): number {
    return this._lastBlockHeight;
  }

  public async updateLastBlockHeight() {
    const block = await this.wallet.account().connection.provider.block({
      finality: 'optimistic',
    });

    this._lastBlockHeight = block.header.height;
  }

  public get archivalConnection(): Connection {
    return this._archivalConnection;
  }

  async getBlock(payload: { blockId: number; methodName: string; args: Record<string, any> }) {
    const { blockId, methodName, args } = payload;

    // @ts-ignore
    this.wallet.account().validateArgs(args || {});
    const connection =
      blockId + NUM_BLOCKS_NON_ARCHIVAL < this._lastBlockHeight
        ? this.archivalConnection
        : this.wallet.account().connection;

    const res: any = await connection.provider.query({
      request_type: 'call_function',
      block_id: blockId,
      // @ts-ignore
      account_id: process.env.NEXT_PUBLIC_NEAR_CONTRACT_NAME,
      method_name: methodName,
      args_base64: new Buffer(JSON.stringify(args), 'utf8').toString('base64'),
    });

    return res.result && res.result.length > 0 && JSON.parse(Buffer.from(res.result).toString());
  }

  async callViewMethod(
    payload: Omit<ViewFunctionCallOptions, 'contractId'> & {
      contractId?: string;
    }
  ) {
    try {
      return this.wallet.account().viewFunctionV2({
        ...payload,
        contractId: payload.contractId ?? this._config.contractId,
      });
    } catch (error) {
      console.error('[CONTRACT_FUNCTION_CALL]', { payload });
    }
  }

  async callChangeMethod(
    payload: Omit<ChangeFunctionCallOptions, 'contractId'> & {
      contractId?: string;
    }
  ) {
    try {
      await this.wallet.account().functionCall({
        ...payload,
        contractId: payload.contractId ?? this._config.contractId,
      });
      if (this._options?.afterCallChangeMethod) this._options?.afterCallChangeMethod();
    } catch (error) {
      console.error('[CONTRACT_FUNCTION_CALL]', { payload });
    }
  }

  async transaction(payload: {
    contractId?: string;
    actions: TransactionAction[];
    walletMeta?: string;
    walletCallbackUrl?: string;
    returnError?: boolean;
  }) {
    const { walletMeta, walletCallbackUrl, returnError } = payload;
    const actions = payload.actions.map(({ methodName, args: body, gas = '30000000000000', deposit = '0' }) =>
      transactions.functionCall(methodName, body, new BN(gas), new BN(deposit))
    );

    // @ts-ignore
    await this.wallet.account().signAndSendTransaction({
      receiverId: payload.contractId ?? this._config.contractId,
      actions,
      walletMeta,
      walletCallbackUrl,
      returnError,
    });

    if (this._options?.afterCallChangeMethod) this._options?.afterCallChangeMethod();
  }
}

'''
'''--- core/components/editor/editor.module.css ---
.root {
  height: 100%;
  padding-bottom: 45px;
  border: none;
}
.root [class='ql-toolbar ql-snow'] {
  background: bgSecondary;
  border: none !important;
  padding: 10px 0 !important;
}
.root [class='ql-container ql-snow'] {
  border: none !important;
  background: 'transparent';
}
.root [class='ql-tooltip ql-editing'][data-mode='video'] {
  top: -10px !important;
  right: 0 !important;
  left: unset !important;
  background: rgba(255, 255, 255, 0.6);
  border: none;
}
.root [class='ql-editor'] {
  padding: 12px 15px !important;
}
.root [class='ql-editor ql-blank'] {
  padding: 12px 15px !important;
  font-size: 16px;
}
.root [class='ql-editor ql-blank']::before {
  font-style: normal !important;
  font-family: 'Open Sans', sans-serif;
  font-weight: 800;
  font-size: 16px;
  left: 15px !important;
}
@media only screen and (max-width: 768px) {
  .root [class='ql-editor ql-blank']::before {
    font-size: 14px;
  }
}
.root [class='ql-container ql-snow'] [class='ql-editor'] {
  font-size: 12px;
}
.root [nft='true']::before {
  content: attr(data-nft-tag);
  position: absolute;
  top: 15px;
  right: 15px;
  background: #000;
  color: #fff;
}
.create-post [class='ql-toolbar ql-snow'] {
  margin-bottom: 125px;
}

'''
'''--- core/components/editor/index.ts ---
export * from './editor';

'''
'''--- core/components/editor/useQuillEditor.ts ---
import { useEffect } from 'react';
import { useQuill } from 'react-quilljs';
import ImageUploader from '../../utils/quill/quill.imageUploader';
import { QuillEditorPropsType } from './quillEditor';
// @ts-ignore
import MagicUrl from 'quill-magic-url';

export const useQuillEditor = (props: QuillEditorPropsType) => {
  const { id, placeholder, onChange, customRef, refQuill, defaultValue } = props;

  const modules: any = {
    toolbar: `#${id}`,
    clipboard: {
      matchVisual: false,
    },
    magicUrl: true,
  };

  const formats = [
    'header',
    'font',
    'size',
    'bold',
    'italic',
    'underline',
    'strike',
    'blockquote',
    'list',
    'bullet',
    'indent',
    'link',
    'image',
    'video',
  ];
  useEffect(() => {
    const Quill = require('quill');

    Quill.register('modules/imageUploader', ImageUploader);
    Quill.register('modules/magicUrl', MagicUrl);
  }, []);

  const { quill, quillRef } = useQuill({
    theme: 'bubble',
    modules,
    formats,
    placeholder,
  });

  useEffect(() => {
    if (quill) {
      quill.on('text-change', (delta: any, oldDelta: any, source: any) => {
        onChange!(quill.root.innerHTML);
      });

      if (customRef) {
        customRef.current.clearContent = () => {
          quill.root.innerHTML = '';
        };
      }

      if (refQuill) refQuill.current = quill;

      if (defaultValue) quill.root.innerHTML = defaultValue;
    }
  }, [quill]);

  return {
    props: {
      quill,
      quillRef,
    },
    methods: {},
  };
};

'''
'''--- core/components/index.ts ---
export * from './editor';

'''
'''--- core/container.ts ---
import { NearConnector } from './blockchain/near/near.connector';
import { NearProtocalConfig } from './contants';
import { Container } from './types';

export const DefaultContainer: Container = Object.freeze({
  bcConnector: new NearConnector(NearProtocalConfig),
});

export function getContainer<T extends Container>(): T {
  //@ts-ignore
  return !process.env.NEXT_RUNTIME && window.container
    ? //@ts-ignore
      window.container
    : (DefaultContainer as T);
}

'''
'''--- core/contants/index.ts ---
export const NearProtocalConfig = {
  networkId: process.env.NEXT_PUBLIC_NEAR_NETWORK_ID || 'testnet',
  nodeUrl: process.env.NEXT_PUBLIC_NEAR_NODE_URL || 'https://rpc.testnet.internal.near.org',
  walletUrl: process.env.NEXT_PUBLIC_NEAR_WALLET_URL!,
  helperUrl: process.env.NEXT_PUBLIC_NEAR_HELPER_URL!,
  contractId: process.env.NEXT_PUBLIC_NEAR_CONTRACT_NAME!,
};

export const NearTransactionConfig = {
  defaultGas: '30000000000000',
};

'''
'''--- core/hooks/index.ts ---
export * from './useBlockchain';
export * from './useWallet';
export * from './useWalletAccountId';

'''
'''--- core/hooks/useBlockchain.ts ---
import React from 'react';
import { State, useHookstate } from '@hookstate/core';
import { BlockChainState, BlockchainState } from '../store';
import { parseToUsername } from '../utils';
import { NearConnector, NearSignInOptions } from '../blockchain/near';
import { getContainer } from '..';

export const useBlockchain = ({
  connector,
  state,
}: {
  connector?: NearConnector;
  state?: State<BlockChainState>;
} = {}) => {
  const bcConnector: NearConnector = connector ?? getContainer().bcConnector;
  const blockchainState = useHookstate(state ?? BlockchainState);

  const _checkLogged = async () => {
    const isSignedIn = await bcConnector.isSignedIn();
    blockchainState.wallet.merge({
      logged: isSignedIn,
    });
    if (isSignedIn) {
      const accountId = bcConnector.wallet.getAccountId();
      console.log('connect? ', accountId);
      blockchainState.accountId.set(accountId);
      // get account balance
      const accountBalance = await getContainer()
        .bcConnector.wallet.account()
        .getAccountBalance();

      // update wallet state
      blockchainState.wallet.account.merge({
        id: accountId,
        username: parseToUsername(accountId),
        balance: accountBalance,
      });
    }
    blockchainState.wallet.merge({
      loading: false,
    });
  };

  /////

  const connect = React.useCallback(async () => {
    await bcConnector.connect();
    blockchainState.merge({
      loading: false,
      ready: true,
    });
    await _checkLogged();
  }, []);

  const signIn = React.useCallback(async (options?: NearSignInOptions) => {
    if (blockchainState.ready.value) {
      blockchainState.wallet.loading.set(true);
      await bcConnector.signIn();
    }
  }, []);

  const signOut = React.useCallback(
    async ({ isReload = true }: { isReload?: boolean } = {}) => {
      if (blockchainState.ready.value) {
        blockchainState.wallet.loading.set(true);
        await bcConnector.signOut();

        if (isReload) window.location.replace('/');
        // await _checkLogged();
      }
    },
    []
  );

  return {
    blockchainState,
    blockchainMethods: {
      connect,
      signIn,
      signOut,
    },
  };
};

'''
'''--- core/hooks/useWallet.ts ---
import { useHookstate } from '@hookstate/core';
import { BlockchainState } from '../store';

export const useWallet = () => {
  const blockchainState = useHookstate(BlockchainState);

  return {
    wallet: blockchainState.wallet.value,
  };
};

'''
'''--- core/hooks/useWalletAccountId.ts ---
import { useHookstate } from '@hookstate/core';
import { BlockchainState } from '../store';
import { parseToUsername } from '../utils';

export const useWalletAccountId = () => {
  const blockchainState = useHookstate(BlockchainState);

  return {
    accountId: blockchainState.accountId.value ?? null,
    username: blockchainState.accountId.value ? parseToUsername(blockchainState.accountId.value) : null,
  };
};

'''
'''--- core/index.ts ---
export * from './container';

'''
'''--- core/store/blockchain.state.ts ---
import { hookstate, State } from '@hookstate/core';
import { AccountBalance } from 'near-api-js/lib/account';

export type BlockChainState = {
  loading: boolean;
  ready: boolean;
  wallet: {
    loading: boolean;
    logged: boolean;
    account?: {
      id: string;
      username: string;
      balance: AccountBalance;
    };
  };
  accountId?: string;
};
export const BlockchainState: State<BlockChainState> = hookstate({
  loading: true,
  ready: false,
  wallet: {
    loading: true,
    logged: false,
  },
} as BlockChainState);

'''
'''--- core/store/index.ts ---
export * from './blockchain.state';

'''
'''--- core/types/index.ts ---
import { NearConnector } from '../blockchain/near';

export type Container = {
  bcConnector: NearConnector;
};

export type ApiGetListInput = {
  from_index: number;
  limit: number;
};

export type GetListInput<T extends {} = {}> = Omit<PouchDB.Find.FindRequest<T>, 'selector'> & {
  selector?: PouchDB.Find.Selector;
};

export type ModalStateType = {
  onOpen: (...args: any) => any;
  onClose: (...args: any) => any;
};

export type TransactionAction = {
  methodName: string;
  args: object;
  gas?: string;
  deposit?: string;
};

export type Optional<T> = T | undefined;
export type Nullable<T> = T | null;
export type StateWithLoading<T = {}> = T & {
  loading: boolean;
  error?: string | object;
};

'''
'''--- core/utils/cache.ts ---
import { ApiGetListInput } from '../types';

const DEFAULT_LIMIT_PER_CACHE_HIT = 5000;

export const cacheDataList = async ({
  dbClient,
  limitPerCacheHit = DEFAULT_LIMIT_PER_CACHE_HIT,
  firstRecordQuery,
  fetchList,
  compareKey,
}: {
  dbClient: PouchDB.Database;
  limitPerCacheHit?: number;
  firstRecordQuery: PouchDB.Find.FindRequest<any>;
  fetchList: (payload: ApiGetListInput) => Promise<any[]>;
  compareKey: string;
}) => {
  const firstRecord = (
    await dbClient.find({
      ...firstRecordQuery,
      skip: 0,
      limit: 1,
    })
  ).docs[0];

  let currentFromIndex = 0;
  let isCompleted = false;
  while (!isCompleted) {
    try {
      const res = await fetchList({
        from_index: currentFromIndex,
        limit: limitPerCacheHit,
      });

      if (res.length === 0) {
        isCompleted = true;
        break;
      }

      if (firstRecord) {
        const firstRecordIndex = res.findIndex(
          // @ts-ignore
          (item) => item[compareKey] === firstRecord[compareKey]
        );

        if (firstRecordIndex !== -1) {
          await dbClient.bulkDocs(res.slice(0, firstRecordIndex));
          isCompleted = true;
          break;
        }
      }

      await dbClient.bulkDocs(res);

      currentFromIndex += limitPerCacheHit;
    } catch (err) {
      console.error(err);
      isCompleted = true;
    }
  }
};

'''
'''--- core/utils/index.ts ---
export * from './cache';

export function debounce(func: any, timeout = 300) {
  let timer: any;
  return (...args: any) => {
    clearTimeout(timer);
    timer = setTimeout(() => {
      // @ts-ignore
      func.apply(this, args);
    }, timeout);
  };
}

export function parseToUsername(accountId: string) {
  return accountId?.replace('.testnet', '').replace('.near', '');
}

'''
'''--- core/utils/quill/blots/image.js ---
import Quill from 'quill';

const InlineBlot = Quill.import('blots/block');

class LoadingImage extends InlineBlot {
  static create(src) {
    const node = super.create(src);
    if (src === true) return node;

    const image = document.createElement('img');
    image.setAttribute('src', src);
    node.appendChild(image);
    return node;
  }
  deleteAt(index, length) {
    super.deleteAt(index, length);
    this.cache = {};
  }
  static value(domNode) {
    const { src, custom } = domNode.dataset;
    return { src, custom };
  }
}

LoadingImage.blotName = 'imageBlot';
LoadingImage.className = 'image-uploading';
LoadingImage.tagName = 'span';
Quill.register({ 'formats/imageBlot': LoadingImage });

export default LoadingImage;

'''
'''--- core/utils/quill/quill.imageUploader.css ---
.image-uploading {
  position: relative;
  display: inline-block;
}

.image-uploading img {
  max-width: 98% !important;
  filter: blur(5px);
  opacity: 0.3;
}

.image-uploading::before {
  content: '';
  box-sizing: border-box;
  position: absolute;
  top: 50%;
  left: 50%;
  width: 30px;
  height: 30px;
  margin-top: -15px;
  margin-left: -15px;
  border-radius: 50%;
  border: 3px solid #ccc;
  border-top-color: #1e986c;
  z-index: 1;
  animation: spinner 0.6s linear infinite;
}

@keyframes spinner {
  to {
    transform: rotate(360deg);
  }
}

'''
'''--- core/utils/quill/quill.imageUploader.js ---
import LoadingImage from './blots/image.js';

class ImageUploader {
  constructor(quill, options) {
    this.quill = quill;
    this.options = options;
    this.range = null;

    if (typeof this.options.upload !== 'function')
      console.warn('[Missing config] upload function that returns a promise is required');

    var toolbar = this.quill.getModule('toolbar');
    toolbar.addHandler('image', this.selectLocalImage.bind(this));

    this.handleDrop = this.handleDrop.bind(this);
    this.handlePaste = this.handlePaste.bind(this);

    this.quill.root.addEventListener('drop', this.handleDrop, false);
    this.quill.root.addEventListener('paste', this.handlePaste, false);
  }

  selectLocalImage() {
    this.range = this.quill.getSelection();
    this.fileHolder = document.createElement('input');
    this.fileHolder.setAttribute('type', 'file');
    this.fileHolder.setAttribute('accept', 'image/*');
    this.fileHolder.setAttribute('style', 'visibility:hidden');

    this.fileHolder.onchange = this.fileChanged.bind(this);

    document.body.appendChild(this.fileHolder);

    this.fileHolder.click();

    window.requestAnimationFrame(() => {
      document.body.removeChild(this.fileHolder);
    });
  }

  handleDrop(evt) {
    evt.stopPropagation();
    evt.preventDefault();
    if (evt.dataTransfer && evt.dataTransfer.files && evt.dataTransfer.files.length) {
      if (document.caretRangeFromPoint) {
        const selection = document.getSelection();
        const range = document.caretRangeFromPoint(evt.clientX, evt.clientY);
        if (selection && range) {
          selection.setBaseAndExtent(range.startContainer, range.startOffset, range.startContainer, range.startOffset);
        }
      } else {
        const selection = document.getSelection();
        const range = document.caretPositionFromPoint(evt.clientX, evt.clientY);
        if (selection && range) {
          selection.setBaseAndExtent(range.offsetNode, range.offset, range.offsetNode, range.offset);
        }
      }

      this.range = this.quill.getSelection();
      let file = evt.dataTransfer.files[0];

      setTimeout(() => {
        this.range = this.quill.getSelection();
        this.readAndUploadFile(file);
      }, 0);
    }
  }

  handlePaste(evt) {
    let clipboard = evt.clipboardData || window.clipboardData;

    // IE 11 is .files other browsers are .items
    if (clipboard && (clipboard.items || clipboard.files)) {
      let items = clipboard.items || clipboard.files;
      const IMAGE_MIME_REGEX = /^image\/(jpe?g|gif|png|svg|webp)$/i;

      for (let i = 0; i < items.length; i++) {
        if (IMAGE_MIME_REGEX.test(items[i].type)) {
          let file = items[i].getAsFile ? items[i].getAsFile() : items[i];

          if (file) {
            this.range = this.quill.getSelection();
            evt.preventDefault();
            setTimeout(() => {
              this.range = this.quill.getSelection();
              this.readAndUploadFile(file);
            }, 0);
          }
        }
      }
    }
  }

  readAndUploadFile(file) {
    let isUploadReject = false;

    const fileReader = new FileReader();

    fileReader.addEventListener(
      'load',
      () => {
        if (!isUploadReject) {
          let base64ImageSrc = fileReader.result;
          this.insertBase64Image(base64ImageSrc);
        }
      },
      false
    );

    if (file) {
      fileReader.readAsDataURL(file);
    }

    this.options.upload(file).then(
      (imageUrl) => {
        this.insertToEditor(imageUrl);
      },
      (error) => {
        isUploadReject = true;
        this.removeBase64Image();
        console.warn(error);
      }
    );
  }

  fileChanged() {
    const file = this.fileHolder.files[0];
    this.readAndUploadFile(file);
  }

  insertBase64Image(url) {
    const range = this.range;
    this.quill.insertEmbed(range.index, LoadingImage.blotName, `${url}`, 'user');
  }

  insertToEditor(url) {
    const range = this.range;
    // Delete the placeholder image
    this.quill.deleteText(range.index, 3, 'user');
    // Insert the server saved image
    this.quill.insertEmbed(range.index, 'image', `${url}`, 'user');

    range.index++;
    this.quill.setSelection(range, 'user');
  }

  removeBase64Image() {
    const range = this.range;
    this.quill.deleteText(range.index, 3, 'user');
  }
}

window.ImageUploader = ImageUploader;
export default ImageUploader;

'''
'''--- db/index.ts ---
export class DB {
  private static _client: {};

  static get client() {
    if (!this._client) throw new Error('DB client not initialize');
    return this._client;
  }

  static async init() {
    this._client = {};
  }

  static async destroy() {}
}

'''
'''--- dtos/account.dto.ts ---
import { NftDto } from './nft.dto';

export type AccountInfoDto = {
  avatar?: string;
  thumbnail?: string;

  displayName?: string;
  bio?: string;

  email?: string;
  location?: string;

  twitter?: string;
  github?: string;
  telegram?: string;
  linkedin?: string;
  behance?: string;
  website?: string;
};
export type AccountDto = {
  id: string;
  accountInfo: AccountInfoDto;
  favouriteNfts: NftDto[];
  numFollowers: number;
  numFollowing: number;
  numNfts: number;
  nfts: [];
};

'''
'''--- dtos/balance.dto.ts ---
export type BalanceDto = {
  total: string;
  available: string;
  isEnough: boolean;
};

'''
'''--- dtos/index.ts ---
export * from './account.dto';
export * from './nft.dto';
export * from './balance.dto';
export * from './order.dto';

'''
'''--- dtos/nft.dto.ts ---
import { Nullable } from '../core/types';

export type NFTMetadata = {
  copies: number;
  description: string;
  expires_at: Nullable<Date>;
  extra: any;
  issued_at: Nullable<Date>;
  media: string;
  media_hash: Nullable<string>;
  reference: Nullable<string>;
  reference_hash: Nullable<string>;
  starts_at: Nullable<Date>;
  title: string;
  updated_at: Nullable<Date>;
};

export type NftDto = {
  metadata: NFTMetadata;
  tokenId: string;
  ownerId: string;
};

'''
'''--- dtos/order.dto.ts ---
import { NFTMetadata } from './nft.dto';

export type OrderDto = {
  orderId: string;
  ownerId: string;
  nftId: string;
  price: string;
  createAt: number;
  isSold: boolean;
  metadata: NFTMetadata;
};

'''
'''--- hooks/atoms/index.ts ---
export * from './use-app';
export * from './use-bookmark';
export * from './use-account';
export * from './use-is-register';
export * from './use-account-list';

'''
'''--- hooks/atoms/use-account-list.ts ---
import { useMutation, useQuery, useQueryClient } from 'react-query';
import { AccountRepo } from '../../repos';

export const useAccountList = () => {
  const listAccountsQuery = useQuery(['list_accounts'], () =>
    AccountRepo.fetchAccounts()
  );

  return {
    accountListState: {
      listAccountsQuery,
    },
  };
};

'''
'''--- hooks/atoms/use-account.ts ---
import { useHookstate } from '@hookstate/core';
import { useCallback } from 'react';
import { useWalletAccountId } from '../../core/hooks';
import { AccountRepo, BalanceRepo } from '../../repos';
import { AccountState } from '../../store';

export const useAccount = () => {
  const accountState = useHookstate(AccountState);
  const { accountId } = useWalletAccountId();

  const fetchProfile = useCallback(async () => {
    if (accountId) {
      try {
        const profile = await AccountRepo.fetchAccount(accountId);
        accountState.profile.set(profile);
      } catch (error) {
        accountState.profile.merge({ id: accountId });
      }
    }
  }, [accountId]);

  const fetchBalance = useCallback(async () => {
    if (accountId) {
      const balance = await BalanceRepo.fetchBalance();
      accountState.balance.set(balance);
    }
  }, [accountId]);

  return {
    accountState,
    accountMethods: {
      fetchProfile,
      fetchBalance,
    },
  };
};

'''
'''--- hooks/atoms/use-app.ts ---
import { useHookstate } from '@hookstate/core';
import { AppState } from '../../store';

export const useApp = () => {
  const appState = useHookstate(AppState);

  return {
    appState,
  };
};

'''
'''--- hooks/atoms/use-bookmark.ts ---
import { useToast } from '@chakra-ui/react';
import React, { useCallback } from 'react';
import { useMutation, useQuery, useQueryClient } from 'react-query';
import { toastBaseConfig } from '../../utils';
import { useHookstate } from '@hookstate/core';
import { AccountState } from '../../store';
import { AccountRepo } from '../../repos';
import { CachePrefixKeys } from '../../constants';

export const useBookmark = (nftId?: string) => {
  const accountState = useHookstate(AccountState);
  const queryClient = useQueryClient();
  const toast = useToast();

  const accountBookmarksQuery = useQuery(
    [CachePrefixKeys.LIST_FAVOURITE_NFTS],
    () => AccountRepo.getBookmarks(),
    {
      enabled: !!accountState.value.profile?.id,
    }
  );

  const addBookmarkMutation = useMutation(
    () => AccountRepo.addBookmark(nftId!),
    {
      onSuccess: () => {
        toast({
          title: 'Add bookmark successfully',
          status: 'success',
          ...toastBaseConfig,
        });
        queryClient.invalidateQueries([CachePrefixKeys.LIST_FAVOURITE_NFTS]);
        accountBookmarksQuery.refetch();
      },
      onError: () => {
        toast({
          title: 'Add bookmark failed',
          status: 'error',
          ...toastBaseConfig,
        });
      },
    }
  );

  const removeBookmarkMutation = useMutation(
    () => AccountRepo.removeBookmark(nftId!),
    {
      onSuccess: () => {
        toast({
          title: 'Remove bookmark successfully',
          status: 'success',
          ...toastBaseConfig,
        });
        queryClient.invalidateQueries([CachePrefixKeys.LIST_FAVOURITE_NFTS]);
        accountBookmarksQuery.refetch();
      },
      onError: () => {
        toast({
          title: 'Remove bookmark failed',
          status: 'error',
          ...toastBaseConfig,
        });
      },
    }
  );

  const addBookmark = useCallback(async () => {
    addBookmarkMutation.mutate();
  }, [nftId]);

  const removeBookmark = useCallback(async () => {
    removeBookmarkMutation.mutate();
  }, [nftId]);

  const marked = React.useMemo(() => {
    console.log(
      'test',
      accountBookmarksQuery.data,
      !!accountBookmarksQuery.data?.find((item: any) => item.id === nftId)
    );
    return (
      !!accountBookmarksQuery.data &&
      !!accountBookmarksQuery.data?.find((item: any) => item.token_id === nftId)
    );
  }, [nftId, accountBookmarksQuery.data?.length]);

  return {
    bookmarkState: {
      marked,
      accountBookmarksQuery,
      isLoading:
        accountBookmarksQuery.isLoading ||
        addBookmarkMutation.isLoading ||
        removeBookmarkMutation.isLoading,
    },
    bookmarkMethods: {
      addBookmark,
      removeBookmark,
    },
  };
};

'''
'''--- hooks/atoms/use-is-register.ts ---
import { useHookstate } from '@hookstate/core';
import { AccountState } from '../../store';

export const useIsRegistered = () => {
  const accountState = useHookstate(AccountState);

  return {
    isRegistered: accountState.isRegistered.value ?? null,
  };
};

'''
'''--- hooks/index.ts ---
export * from './atoms';
export * from './use-initalize';
export * from './use-header';
export * from './use-storage-deposit-modal';
export * from './use-storage-deposit';
export * from './use-account-page';
export * from './use-mint-nft-modal';
export * from './use-sell-nft-modal';
export * from './use-marketplace-page';

'''
'''--- hooks/use-account-page.ts ---
import { useInfiniteQuery, useQuery } from 'react-query';
import { useRouter } from 'next/router';
import { useCallback, useMemo } from 'react';
import { CachePrefixKeys } from '../constants';
import { useBlockchain, useWalletAccountId } from '../core/hooks';
import { AccountRepo, NftRepo } from '../repos';
import { AccountApi, NftApi } from '../apis';
import { useHookstate } from '@hookstate/core';
import { AccountState, AppState } from '../store';
import { OrderRepo } from '../repos/order.repo';

export const useAccountPage = ({ accountId }: { accountId?: string }) => {
  const router = useRouter();
  const appState = useHookstate(AppState);
  const accountState = useHookstate(AccountState);
  const { blockchainState, blockchainMethods } = useBlockchain();

  const accountQuery = useQuery(
    [CachePrefixKeys.ACCOUNT, accountId],
    () => AccountRepo.getUserInfo(accountId!),
    {
      enabled: !!accountId,
    }
  );

  // const nftQuery = useQuery(
  //   [CachePrefixKeys.LIST_NFT, accountId],
  //   () => NFTApi.fetchListNFTs(accountId!),
  //   {
  //     enabled: !!accountId,
  //   }
  // );
  // {
  // skip,
  // limit: FETCH_POSTS_LIMIT,
  // selector: buildWhereQuery({
  //   filter: { ...postFilter.filter, accountId },
  // },
  //   sort: buildSortQuery(postFilter),
  // }

  const listFavouriteQuery = useQuery(
    [CachePrefixKeys.LIST_FAVOURITE_NFTS],
    () => AccountRepo.getBookmarks(),
    { enabled: appState.value.ready && !!accountId }
  );
  const nftQuery = useQuery(
    [CachePrefixKeys.LIST_NFT, accountId],
    () => NftRepo.fetchListNFTs(accountId!),
    { enabled: appState.value.ready && !!accountId }
  );

  const listOrdersQuery = useQuery(
    [CachePrefixKeys.LIST_ORDERS, accountId],
    () => OrderRepo.fetchListAccountOrders(accountId!),
    { enabled: appState.value.ready && !!accountId }
  );

  const isOwner = useMemo(() => {
    return accountId === accountState.value.profile?.id;
  }, [accountState.value.profile?.id, accountId]);

  return {
    accountPageState: {
      isOwner,
      accountQuery,
      listFavouriteQuery,
      nftQuery,
      listOrdersQuery,
    },
    accountPageMethods: {},
  };
};

'''
'''--- hooks/use-header.ts ---
import { useQuery } from 'react-query';
import { useRouter } from 'next/router';
import { useCallback } from 'react';
import { CachePrefixKeys } from '../constants';
import { useBlockchain, useWalletAccountId } from '../core/hooks';
import { AccountRepo } from '../repos';

export const useHeader = () => {
  const router = useRouter();
  const { blockchainState, blockchainMethods } = useBlockchain();
  const { accountId } = useWalletAccountId();

  const accountQuery = useQuery(
    [CachePrefixKeys.ACCOUNT, accountId],
    () => AccountRepo.getUserInfo(accountId!),
    {
      enabled: !!accountId,
    }
  );

  const brandOnClick = useCallback(() => router.push('/'), [router]);

  return {
    headerState: {
      blockchainLoading: blockchainState.loading.value,
      walletLoading: blockchainState.wallet.loading.value,
      logged: blockchainState.wallet.logged.value,
      account: accountQuery.data,
      accountId,
    },
    headerMethods: {
      signIn: blockchainMethods.signIn,
      signOut: blockchainMethods.signOut,
      brandOnClick,
    },
  };
};

'''
'''--- hooks/use-initalize.ts ---
import { useEffect } from 'react';
// import { PostCache } from '../cache';
import { StorageKeys } from '../constants';
import { useBlockchain, useWalletAccountId } from '../core/hooks';
import { DB } from '../db';
import { AccountRepo, NftRepo } from '../repos';
import { useAccount, useApp } from './atoms';
import { getContainer } from '../core';
import { ModalUtils } from '../utils';
import { QueryClient } from 'react-query';
import { useToast } from '@chakra-ui/react';

export const useInitialize = () => {
  const { blockchainState, blockchainMethods } = useBlockchain();
  const { accountId } = useWalletAccountId();
  const { appState } = useApp();
  const { accountState, accountMethods } = useAccount();
  const toast = useToast();

  // TODO: clean code later (isAboutMePage)
  useEffect(() => {
    (async () => {
      await DB.init();
      const oldContractId = localStorage.getItem(StorageKeys.CONTRACT_ID);
      if (oldContractId !== getContainer().bcConnector.config.contractId) {
        // clear old data
        localStorage.clear();
        await DB.destroy();
        await DB.init();
        localStorage.setItem(
          StorageKeys.CONTRACT_ID,
          getContainer().bcConnector.config.contractId
        );
      }
      await Promise.all([blockchainMethods.connect()]);
    })();
  }, []);

  useEffect(() => {
    if (!blockchainState.ready.value) return;

    const isStaging = window.location.hostname.includes('vercel.app');
    const hostnameItems = window.location.hostname.split('.');
    const isAboutMePage = !isStaging && hostnameItems.length > 2;

    // Cache data before app ready
    (async () => {
      // const cacheData = Promise.all([PostCache.cache()]).then(() => {
      //   console.info('App cached!!!');
      // });

      const checkIsRegisteredAndGetProfile = async () => {
        if (accountId) {
          const [
            isRegistered,
            // isAdmin
          ] = await Promise.all([
            AccountRepo.isRegistered(),
            // AccountRepo.isAdmin(accountId),
          ]);
          console.log('isRegistered', isRegistered);
          // console.log('isAdmin', isAdmin);
          accountState.isRegistered.set(isRegistered);
          // accountState.isAdmin.set(isAdmin);
          await Promise.all([
            accountMethods.fetchProfile(),
            accountMethods.fetchBalance(),
          ]);
        }
      };

      await Promise.all([
        //cacheData,
        checkIsRegisteredAndGetProfile(),
      ]);

      // Set app ready
      appState.merge({
        loading: false,
        ready: true,
      });
    })();
  }, [blockchainState.ready.value, accountId]);

  return {
    appState,
  };
};

'''
'''--- hooks/use-marketplace-page.ts ---
import { useQuery } from 'react-query';
import { CachePrefixKeys } from '../constants';
import { AccountRepo } from '../repos';
import { useHookstate } from '@hookstate/core';
import { AccountState, AppState } from '../store';
import { OrderRepo } from '../repos/order.repo';

export const useMarketplacePage = () => {
  const appState = useHookstate(AppState);
  const accountState = useHookstate(AccountState);
  const accountQuery = useQuery(
    [CachePrefixKeys.ACCOUNT, accountState.value.profile?.id],
    () => AccountRepo.fetchAccount(accountState.value.profile?.id!),
    {
      enabled: !!accountState.value.profile?.id,
    }
  );

  const listOrdersQuery = useQuery(
    [CachePrefixKeys.LIST_ORDERS],
    () => OrderRepo.fetchListOrders(),
    { enabled: appState.value.ready }
  );

  return {
    marketplacePageState: {
      accountQuery,
      listOrdersQuery,
    },
  };
};

'''
'''--- hooks/use-mint-nft-modal.ts ---
import { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import { useMutation, useQueryClient } from 'react-query';
import { useForm } from 'react-hook-form';
import { useDisclosure, useToast } from '@chakra-ui/react';
import {
  AuthUtils,
  getMessageFromExecutionError,
  IPFSUtils,
  ModalUtils,
} from '../utils';
import { NftRepo } from '../repos';
import { MintNftInput } from '../apis';
// import { PlaceChestInput } from '../apis/chest.api';

export const useMintNft = () => {
  const { isOpen, onOpen, onClose } = useDisclosure();
  const queryClient = useQueryClient();
  const mintNftForm = useForm<MintNftInput>();
  const [mintNftPublishing, setMintNftPublishing] = useState(false);
  const toast = useToast();

  const fileInputRef = useRef<any>();

  const uploadFileMutation = useMutation(async () => {
    if (fileInputRef.current?.files) {
      const file = fileInputRef.current.files[0];
      await IPFSUtils.uploadFileToIPFS({
        file,
        onSuccess: async (url) => {
          return mintNftForm.setValue('media', url);
        },
      });
    }
  });

  const handleMintNftFormSubmit = useMemo(
    () =>
      mintNftForm.handleSubmit(async (data: MintNftInput) => {
        AuthUtils.authCheckAndExec(async () => {
          setMintNftPublishing(true);

          try {
            await NftRepo.mintArtNft(data);

            queryClient.invalidateQueries('get_chests_by_account_id');
            ModalUtils.mintNft.onClose();
            mintNftForm.reset();

            toast({
              title: 'Mint NFT successfully',
              position: 'bottom-left',
              status: 'success',
              isClosable: true,
              duration: 3000,
            });

            // router
            //     .push(createPostRedirect)
            /* .finally(() => */
            /*     localStorage.removeItem(CREATE_POST_REDIRECT) */
            /* ); */
          } catch (error: any) {
            console.error(error);
            const message = getMessageFromExecutionError(
              error.kind.ExecutionError
            );
            toast({
              title: 'Mint NFT failed',
              description: message,
              position: 'bottom-left',
              status: 'error',
              isClosable: true,
              duration: 3000,
            });
          } finally {
            setMintNftPublishing(false);
          }
        });
      }),
    []
  );

  const openFileImport = useCallback(async () => {
    fileInputRef.current?.click();
  }, []);

  const onRemove = useCallback(async (e: any) => {
    console.log('ting clo', mintNftForm.getValues('media'));
    e.stopPropagation();
    mintNftForm.setValue('media', '');
    mintNftForm.trigger('media');
  }, []);

  useEffect(() => {
    ModalUtils.mintNft.onOpen = onOpen;
    ModalUtils.mintNft.onClose = onClose;
  }, []);

  return {
    mintNftModalState: {
      isOpen,
      fileInputRef,
      mintNftForm,
      mintNftPublishing,
    },
    mintNftModalMethods: {
      onOpen,
      onClose,
      onRemove,
      openFileImport,
      uploadFileMutation,
      handleMintNftFormSubmit,
    },
  };
};

'''
'''--- hooks/use-order-card.ts ---
import { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import { useMutation, useQueryClient } from 'react-query';
import { useForm } from 'react-hook-form';
import { useDisclosure, useToast } from '@chakra-ui/react';
import {
  AuthUtils,
  getMessageFromExecutionError,
  IPFSUtils,
  ModalUtils,
  toastBaseConfig,
} from '../utils';
import { NftRepo } from '../repos';
import { MintNftInput } from '../apis';
import { NftDto, OrderDto } from '../dtos';
import { useAccountPage } from './use-account-page';
// import { PlaceChestInput } from '../apis/chest.api';

export const useOrderCard = (data: OrderDto) => {
  const [selectedNft, setSelectedNft] = useState<NftDto | undefined>(undefined);
  const queryClient = useQueryClient();
  const [sellNftPublishing, setSellNftPublishing] = useState(false);
  const toast = useToast();

  const {
    accountPageState: { accountQuery },
  } = useAccountPage({ accountId: data.ownerId });

  const { data: account } = accountQuery;

  const handleBtnBuyClick = useCallback(() => {
    AuthUtils.authCheckAndExec(async () => {
      await NftRepo.buyNft(data);
    });
  }, [data]);

  return {
    orderCardState: {
      account,
    },
    orderCardMethods: {
      handleBtnBuyClick,
    },
  };
};

'''
'''--- hooks/use-sell-nft-modal.ts ---
import { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import { useMutation, useQueryClient } from 'react-query';
import { useForm } from 'react-hook-form';
import { useDisclosure, useToast } from '@chakra-ui/react';
import {
  AuthUtils,
  getMessageFromExecutionError,
  IPFSUtils,
  ModalUtils,
  toastBaseConfig,
} from '../utils';
import { NftRepo } from '../repos';
import { MintNftInput } from '../apis';
import { NftDto } from '../dtos';
// import { PlaceChestInput } from '../apis/chest.api';

export const useSellNftModal = () => {
  const { isOpen, onOpen, onClose } = useDisclosure();
  const [selectedNft, setSelectedNft] = useState<NftDto | undefined>(undefined);
  const queryClient = useQueryClient();
  const [sellNftPublishing, setSellNftPublishing] = useState(false);
  const toast = useToast();

  const priceInputRef = useRef<any>();

  const handleBtnSellClick = useCallback(() => {
    AuthUtils.authCheckAndExec(async () => {
      setSellNftPublishing(true);

      try {
        if (!selectedNft?.tokenId) throw 'Failed to get token id';
        const payload = {
          nftId: selectedNft?.tokenId,
          price: priceInputRef.current.value,
        };
        console.log(payload);
        await NftRepo.sellNft({
          nftId: selectedNft?.tokenId,
          price: priceInputRef.current.value,
        });

        queryClient.invalidateQueries('get_chests_by_account_id');
        ModalUtils.sellNft.onClose();
        priceInputRef.current.value = 0;

        toast({
          title: 'Sell NFT successfully',
          status: 'success',
          ...toastBaseConfig,
        });

        // router
        //     .push(createPostRedirect)
        /* .finally(() => */
        /*     localStorage.removeItem(CREATE_POST_REDIRECT) */
        /* ); */
      } catch (error: any) {
        console.error(error);
        const message = getMessageFromExecutionError(
          error?.kind?.ExecutionError
        );
        toast({
          title: 'Sell NFT failed',
          description: message,
          status: 'error',
          ...toastBaseConfig,
        });
      } finally {
        setSellNftPublishing(false);
      }
    });
  }, [selectedNft]);

  const handleOpen = useCallback((data: NftDto) => {
    setSelectedNft(data);
    onOpen();
  }, []);

  const handleClose = useCallback(() => {
    onClose();
    setSelectedNft(undefined);
  }, []);

  useEffect(() => {
    ModalUtils.sellNft.onOpen = handleOpen;
    ModalUtils.sellNft.onClose = handleClose;
  }, []);

  return {
    sellNftModalState: {
      isOpen,
      selectedNft,
      priceInputRef,
      sellNftPublishing,
    },
    sellNftModalMethods: {
      onOpen,
      onClose,
      handleBtnSellClick,
    },
  };
};

'''
'''--- hooks/use-storage-deposit-modal.ts ---
import { useDisclosure } from '@chakra-ui/react';
import { useEffect } from 'react';
import { ModalUtils } from '../utils';
import { useStorageDeposit } from './use-storage-deposit';

export const useStorageDepositModal = () => {
  const { isOpen, onOpen, onClose } = useDisclosure();
  const { storageDepositState, storageDepositMethods } = useStorageDeposit();

  useEffect(() => {
    ModalUtils.storageDeposit.onOpen = onOpen;
    ModalUtils.storageDeposit.onClose = onClose;
  }, []);

  return {
    storageDepositModalState: { isOpen, storageDepositState },
    storageDepositModalMethods: { onOpen, onClose, storageDepositMethods },
  };
};

'''
'''--- hooks/use-storage-deposit.ts ---
import { useMutation } from 'react-query';
import { AccountRepo } from '../repos';
import { useCallback } from 'react';

export const useStorageDeposit = () => {
  const useStorageDepositMutation = useMutation(() =>
    AccountRepo.storageDeposit()
  );

  const deposit = useCallback(
    () => useStorageDepositMutation.mutateAsync(),
    []
  );

  return {
    storageDepositState: {
      isLoading: useStorageDepositMutation.isLoading,
      data: useStorageDepositMutation.data,
    },
    storageDepositMethods: {
      deposit,
    },
  };
};

'''
'''--- hooks/use-storage-withdraw-modal.ts ---
import { useDisclosure } from '@chakra-ui/react';
import { useEffect } from 'react';
import { ModalUtils } from '../utils';
import { useStorageWithdraw } from './use-storage-withdraw';

export const useStorageWithdrawModal = () => {
  const { isOpen, onOpen, onClose } = useDisclosure();
  const { storageWithdrawState, storageWithdrawMethods } = useStorageWithdraw();

  useEffect(() => {
    ModalUtils.storageWithdraw.onOpen = onOpen;
    ModalUtils.storageWithdraw.onClose = onClose;
  }, []);

  return {
    storageWithdrawModalState: { isOpen, storageWithdrawState },
    storageWithdrawModalMethods: { onOpen, onClose, storageWithdrawMethods },
  };
};

'''
'''--- hooks/use-storage-withdraw.ts ---
import { useMutation } from 'react-query';
import { AccountRepo } from '../repos';
import { useCallback, useRef } from 'react';

export const useStorageWithdraw = () => {
  const amountInputRef = useRef<any>();
  const useStorageWithdrawMutation = useMutation(() =>
    AccountRepo.storageWithdraw(amountInputRef.current.value)
  );

  const withdraw = useCallback(
    () => useStorageWithdrawMutation.mutateAsync(),
    []
  );

  return {
    storageWithdrawState: {
      isLoading: useStorageWithdrawMutation.isLoading,
      data: useStorageWithdrawMutation.data,
      amountInputRef,
    },
    storageWithdrawMethods: {
      withdraw,
    },
  };
};

'''
'''--- layouts/index.ts ---
export * from './main-layout';

'''
'''--- next-env.d.ts ---
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/basic-features/typescript for more information.

'''
'''--- next.config.js ---
/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  swcMinify: true,
};

module.exports = nextConfig;

'''
'''--- package.json ---
{
  "name": "my-app",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "prettier": "prettier --write ."
  },
  "dependencies": {
    "@chakra-ui/icon": "^3.0.13",
    "@chakra-ui/react": "^2.3.4",
    "@emotion/react": "^11",
    "@emotion/styled": "^11",
    "@hookstate/core": "^4.0.0-rc21",
    "@mui/icons-material": "^5.10.16",
    "@tanstack/react-query": "^4.5.0",
    "@types/bn.js": "^5.1.1",
    "axios": "^1.2.2",
    "bn.js": "^5.2.1",
    "chakra-react-select": "^4.2.2",
    "date-fns": "^2.29.3",
    "framer-motion": "^6",
    "ipfs-http-client": "^59.0.0",
    "moment": "^2.29.4",
    "near-api-js": "^1.0.0",
    "next": "12.3.1",
    "nextjs-progressbar": "^0.0.14",
    "pouchdb": "^7.3.0",
    "pouchdb-find": "^7.3.0",
    "quill": "2.0.0-dev.4",
    "quill-image-uploader": "^1.2.2",
    "quill-magic-url": "^4.1.4",
    "react": "18.2.0",
    "react-dom": "18.2.0",
    "react-hook-form": "^7.36.1",
    "react-icons": "^4.7.1",
    "react-player": "^2.11.0",
    "react-query": "^3.39.2",
    "react-quilljs": "^1.2.17",
    "react-textarea-autosize": "^8.4.0",
    "react-use": "^17.4.0",
    "rsuite": "^5.19.0",
    "timeago-react": "^3.0.5"
  },
  "devDependencies": {
    "@types/node": "18.7.18",
    "@types/pouchdb": "^6.4.0",
    "@types/quill": "^2.0.9",
    "@types/react": "18.0.20",
    "@types/react-dom": "18.0.6",
    "@typescript-eslint/eslint-plugin": "5.38.0",
    "eslint": "8.23.1",
    "eslint-config-next": "12.3.1",
    "eslint-config-prettier": "8.5.0",
    "prettier": "2.7.1",
    "typescript": "4.8.3"
  }
}

'''
'''--- repos/account.repo.ts ---
import { AccountApi } from '../apis';
import { AccountDto, NftDto } from '../dtos';

export class AccountRepo {
  static async storageDeposit(): Promise<void> {
    return AccountApi.storageDeposit();
  }
  static async storageWithdraw(amount: number): Promise<void> {
    return AccountApi.storageWithdraw(amount);
  }
  static async isRegistered(): Promise<boolean> {
    return AccountApi.isRegistered();
  }
  static async storageMinimumBalance(): Promise<number> {
    return AccountApi.storageMinimumBalance();
  }
  static async getUserInfo(accountId: string): Promise<AccountDto> {
    return AccountApi.fetchAccount(accountId);
  }
  static async isAdmin(accountId: string): Promise<boolean> {
    return AccountApi.isAdmin(accountId);
  }
  static async fetchAccount(accountId: string): Promise<AccountDto> {
    return AccountApi.fetchAccount(accountId);
  }
  static async fetchAccounts(): Promise<AccountDto[]> {
    return AccountApi.fetchAccounts();
  }
  static async getBookmarks(): Promise<NftDto[]> {
    return AccountApi.getBookmarks();
  }
  static async addBookmark(nftId: string): Promise<void> {
    return AccountApi.addBookmark(nftId);
  }
  static async removeBookmark(nftId: string): Promise<void> {
    return AccountApi.removeBookmark(nftId);
  }
}

'''
'''--- repos/balance.repo.ts ---
import { BalanceApi } from '../apis/balance.api';
import { BalanceDto } from '../dtos';

export class BalanceRepo {
  static async fetchBalance(): Promise<BalanceDto> {
    return BalanceApi.fetchBalance();
  }
  static storageDeposit = BalanceApi.storageDeposit;
}

'''
'''--- repos/index.ts ---
export * from './account.repo';
export * from './nft.repo';
export * from './balance.repo';

'''
'''--- repos/nft.repo.ts ---
import { MintNftInput, NftApi as NftApi, SellNftInput } from '../apis';
import { GetListInput, Optional } from '../core/types';
import { DB } from '../db';
import { NftDto, NFTMetadata, OrderDto } from '../dtos';

export class NftRepo {
  static async fetchListNFTs(accountId: string): Promise<NftDto[]> {
    return NftApi.fetchListNFTs(accountId);
  }
  static async fetchNFTMetadata(
    tokenId: string
  ): Promise<Optional<NFTMetadata>> {
    return NftApi.fetchNFTMetadata(tokenId);
  }

  static async mintArtNft(payload: MintNftInput): Promise<void> {
    return NftApi.mintArtNft(payload);
  }

  static async sellNft(payload: SellNftInput): Promise<void> {
    return NftApi.sellNft(payload);
  }

  static async buyNft(payload: OrderDto): Promise<void> {
    return NftApi.buyNft(payload);
  }
}

'''
'''--- repos/order.repo.ts ---
import { MintNftInput, NftApi as NftApi, SellNftInput } from '../apis';
import { OrderApi } from '../apis/order.api';
import { GetListInput, Optional } from '../core/types';
import { DB } from '../db';
import { NftDto, NFTMetadata, OrderDto } from '../dtos';

export class OrderRepo {
  static async fetchListOrders(): Promise<OrderDto[]> {
    return OrderApi.fetchListOrders();
  }
  static async fetchListAccountOrders(accountId: string): Promise<OrderDto[]> {
    return OrderApi.fetchListAccountOrders(accountId);
  }
}

'''
'''--- store/account.state.ts ---
import { hookstate, State } from '@hookstate/core';
import { AccountDto, BalanceDto } from '../dtos';

export type AccountState = {
  loading: boolean;
  isRegistered?: boolean;
  isAdmin?: boolean;
  profile?: AccountDto;
  balance?: BalanceDto;
};
export const AccountState: State<AccountState> = hookstate({
  loading: true,
} as AccountState);

'''
'''--- store/app.state.ts ---
import { hookstate, State } from '@hookstate/core';

export type AppState = {
  loading: boolean;
  ready: boolean;
};
export const AppState: State<AppState> = hookstate({
  loading: true,
  ready: false,
} as AppState);

'''
'''--- store/index.ts ---
export * from './app.state';
export * from './account.state';

'''
'''--- styles/global.css ---
:root {
  --gradientPrimary: linear-gradient(to right, #0250c5 0%, #d43f8d 100%);
  --bgPrimary: #2b2b2b;
  --bgSecondary: #353535;

  --textHeader: #fff;
  --textPrimary: #ddd;
}

'''
'''--- styles/index.ts ---
export {};

'''
'''--- theme/components/button.ts ---
export const Button = {
  variants: {
    primary: ({
      borderColor,
      borderWidth = 1,
    }: {
      borderColor: string;
      borderWidth: number;
    }) => ({
      background: 'var(--gradientPrimary)',
      borderWidth: '0px',
      height: 'fit-content',
      width: 'fit-content',
      fontSize: '16px',
      fontWeight: '800',
      minW: 'auto',
      transition: 'all 0.2s',
      textColor: '#fff',
      _loading: {
        opacity: 1,
      },
      _hover: {
        background: undefined,
        opacity: 0.8,
        _disabled: {
          opacity: 1,
          background: '',
        },
      },
      _before: {
        content: '" "',
        width: '100%',
        height: '100%',
        position: 'absolute',
        color: '#fff',
      },
      _active: {
        boxShadow: 'none',
      },
      _focus: {
        boxShadow: 'none',
      },
    }),
    secondary: ({
      borderColor,
      borderWidth = 1,
    }: {
      borderColor: string;
      borderWidth: number;
    }) => ({
      background: 'textPrimary',
      borderWidth: '0px',
      height: 'fit-content',
      width: 'fit-content',
      fontSize: '16px',
      fontWeight: '800',
      minW: 'auto',
      transition: 'all 0.2s',
      textColor: '#fff',
      _loading: {
        opacity: 1,
      },
      _hover: {
        background: undefined,
        opacity: 0.8,
        _disabled: {
          opacity: 1,
          background: '',
        },
      },
      _before: {
        content: '" "',
        width: '100%',
        height: '100%',
        position: 'absolute',
        color: '#fff',
      },
      _active: {
        boxShadow: 'none',
      },
      _focus: {
        boxShadow: 'none',
      },
    }),
    // accountMenu: () => ({
    //   minW: 'auto',
    //   background: 'transparent',
    //   transition: 'all 0.2s',
    //   borderStyle: 'solid',
    //   borderColor: 'transparent',
    //   borderWidth: '2px',
    //   textColor: '#FFF',
    //   fontSize: '16px',
    //   borderRadius: 0,
    //   justifyContent: 'start',
    //   w: '100%',
    //   _hover: {
    //     borderImage: 'var(--primary-border-button-color) 1',
    //   },
    //   _active: {
    //     boxShadow: 'none',
    //   },
    //   _focus: {
    //     boxShadow: 'none',
    //   },
    // }),
    accountMenu: () => ({
      minW: 'auto',
      w: '100%',
      h: '50px',
      background: 'transparent',
      transition: 'all 0.2s',
      textColor: '#FFF',
      fontSize: '16px',
      borderRadius: 0,
      justifyContent: 'center',
      _hover: {
        background: '#fff1',
      },
      // _active: {
      //   boxShadow: 'none',
      // },
      // _focus: {
      //   boxShadow: 'none',
      // },
    }),
  },
};

'''
'''--- theme/components/index.ts ---
import { Button } from './button';

export const components = {
  Button,
};

'''
'''--- theme/index.ts ---
import { extendTheme } from '@chakra-ui/react';
import { components } from './components';

export const theme = extendTheme({
  components,
});

'''
'''--- tsconfig.json ---
{
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx"],
  "exclude": ["node_modules"]
}

'''
'''--- utils/auth.utils.ts ---
import BN from 'bn.js';
import { MIN_ENOUGH_STORAGE_BALANCE } from '../constants';
import { BlockchainState } from '../core/store';
import { AccountState } from '../store';
import { ModalUtils } from './modal.utils';

export const AuthUtils = Object.freeze({
  async authCheckAndExec(exec?: (...args: any) => any): Promise<boolean> {
    const logged = BlockchainState.wallet.logged.value;
    if (!logged) {
      ModalUtils.connectWallet.onOpen();
      return false;
    }

    const isRegistered = AccountState.isRegistered.value;
    if (!isRegistered) {
      ModalUtils.addStorageBalance.onOpen();
      return false;
    }

    console.log(AccountState.balance.get());
    if (!AccountState.balance.get()?.isEnough) {
      ModalUtils.addStorageBalance.onOpen();
      return false;
    }

    if (exec) await exec();

    return true;
  },
});

'''
'''--- utils/index.ts ---
import { UseToastOptions } from '@chakra-ui/react';
import moment from 'moment';

export * from './modal.utils';
export * from './auth.utils';
export * from './ipfs.utils';

export const toastBaseConfig: UseToastOptions = {
  position: 'top',
  duration: 3500,
  isClosable: true,
};

export const toastNotCompleteFeature: UseToastOptions = {
  title: 'Feature in development',
  description: '',
  status: 'warning',
  ...toastBaseConfig,
};

export const getTimeAgo = (time: number) => {
  const arr = moment(time).fromNow(true).split(' ');

  return arr[0] + arr[1].charAt(0);
};

export const getMessageFromExecutionError = (
  executionError: string
): string | undefined => {
  const res = /'(.*)'/.exec(executionError);
  let message: string | undefined = undefined;
  if (!!res && res?.length > 0) {
    message = res[1];
  }
  return message;
};

export const to_slug = (text: string): string => {
  return text
    .toLowerCase()
    .normalize('NFD')
    .replace(/[\u0300-\u036f]/g, '')
    .replace(/[đĐ]/g, 'd')
    .replace(/([^0-9a-z-\s-_])/g, '')
    .replace(/(\s+)/g, '_')
    .replace(/_+/g, '_')
    .replace(/^-+|-+$/g, '');
};

'''
'''--- utils/ipfs.utils.ts ---
import axios from 'axios';
import { create as ipfsClient, IPFSHTTPClient } from 'ipfs-http-client';
import { IPFS_BASE_URL, IPFS_HOST, IPFS_UPLOAD_SERVER_URL } from '../constants';

export class IPFSUtils {
  private static _client: IPFSHTTPClient;

  static get client(): IPFSHTTPClient {
    if (this._client) return this._client;

    this._client = ipfsClient({
      host: IPFS_HOST,
      protocol: 'https',
    });

    return this._client;
  }

  public static uploadDataToIPFS({
    data,
    onSuccess,
    onError,
  }: {
    data: any;
    onSuccess?: (url: string) => any;
    onError?: any;
  }): Promise<string> {
    return new Promise((resolve, reject) => {
      axios
        .post(IPFS_UPLOAD_SERVER_URL + '/upload', {
          data,
        })
        .then(async (res: any) => {
          const url = res.data.hash;
          if (onSuccess) await onSuccess(url);
          resolve(url);
        })
        .catch(async (err: any) => {
          if (onError) await onError(err);
          reject();
        });
    });
  }

  public static uploadFileToIPFS({
    file,
    onSuccess,
    onError,
  }: {
    file: File;
    onSuccess?: (url: string) => any;
    onError?: any;
  }) {
    return new Promise((resolve, reject) => {
      const body = new FormData();
      body.append('file', file);
      axios
        .post(IPFS_UPLOAD_SERVER_URL + '/uploadFile', body)
        .then(async (res: any) => {
          const url = IPFS_BASE_URL + res.data.hash;
          if (onSuccess) await onSuccess(url);
          resolve(url);
        })
        .catch(async (err: any) => {
          if (onError) await onError(err);
          reject();
        });
    });
  }

  public static async getDataFromIPFS(hash: string) {
    let res = await axios.get(IPFS_BASE_URL + hash);
    return res.data;
  }

  public static async getDataByCID(cid: string) {
    const stream = IPFSUtils.client.cat(cid);
    let data = '';
    // eslint-disable-next-line no-restricted-syntax
    for await (const chunk of stream) {
      data += new TextDecoder().decode(chunk);
    }

    return data;
  }
}

'''
'''--- utils/modal.utils.ts ---
import { ModalStateType } from '../core/types';

export const ModalUtils: {
  addStorageBalance: ModalStateType;
  storageDeposit: ModalStateType;
  storageWithdraw: ModalStateType;

  mintNft: ModalStateType;
  sellNft: ModalStateType;

  sayModal: ModalStateType;
  connectWallet: ModalStateType;
  placeChest: ModalStateType;
  composeMessage: ModalStateType;
  createPost: ModalStateType;
  selectGifModal: ModalStateType;
  reportModal: ModalStateType;
  selectVideo: ModalStateType;
  sharePost: ModalStateType;
  viewAllAccount: ModalStateType;
  homeMenu: ModalStateType;
  postOption: ModalStateType;
  editAboutMe: ModalStateType;
  contactMe: ModalStateType;
  arStorageDeposit: ModalStateType;
} = Object.freeze({
  addStorageBalance: {
    onOpen: () => {},
    onClose: () => {},
  },
  storageDeposit: {
    onOpen: () => {},
    onClose: () => {},
  },
  storageWithdraw: {
    onOpen: () => {},
    onClose: () => {},
  },

  mintNft: {
    onOpen: () => {},
    onClose: () => {},
  },
  sellNft: {
    onOpen: () => {},
    onClose: () => {},
  },

  sayModal: {
    onOpen: () => {},
    onClose: () => {},
  },
  connectWallet: {
    onOpen: () => {},
    onClose: () => {},
  },
  placeChest: {
    onOpen: () => {},
    onClose: () => {},
  },
  composeMessage: {
    onOpen: () => {},
    onClose: () => {},
  },
  createPost: {
    onOpen: () => {},
    onClose: () => {},
  },
  selectGifModal: {
    onOpen: () => {},
    onClose: () => {},
  },
  reportModal: {
    onOpen: () => {},
    onClose: () => {},
  },
  sharePost: {
    onOpen: () => {},
    onClose: () => {},
  },
  viewAllAccount: {
    onOpen: () => {},
    onClose: () => {},
  },
  selectVideo: {
    onOpen: () => {},
    onClose: () => {},
  },
  editAboutMe: {
    onOpen: () => {},
    onClose: () => {},
  },
  contactMe: {
    onOpen: () => {},
    onClose: () => {},
  },
  homeMenu: {
    onOpen: () => {},
    onClose: () => {},
  },
  postOption: {
    onOpen: () => {},
    onClose: () => {},
  },
  arStorageDeposit: {
    onOpen: () => {},
    onClose: () => {},
  },
});

'''