*GitHub Repository "phuc16102001/near-airplane-baggage-checking"*

'''--- Cargo.toml ---
[package]
name = "airplane-baggage-checking"
version = "0.1.0"
authors = ["Do Vuong Phuc <phuc16102001@gmail.com>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true
'''
'''--- README.md ---
# Introduction - Airline baggage checking

## Overview

This is a contract designed for the airline baggage checking. It allows the customers to deposit their money and let the airline to delivery their baggages. In the real situation, this may be a complicated process and risky. With smart contract, the process works faster and safer.

## Contract flow

In this workflow, we have three different roles:
- `Owner`: The one who create contract
- `Airline`: The airline company
- `Customer`: The user who want to deposit 

The contract has several steps:
- The contract first initialized by the `owner` and set payment to `airline`
- `Customer` registry their flight (with `flight_id`, `flight_class` and `distance`)
- For each flight, they can check at most 3 baggages (with `baggage_size`)
- The system print out the `baggage_id` after checking
- Check for the `price` 
- Accept the `fee` and deposit money to contract
- Baggages now are delivering
- Finally, the `Customer` claim baggages and the contract will send the money to `airline`

> Moreover, `Customer` can check many different attributes such as `flight_class`, their checked `baggages`, etc

## Rules
- Only `owner` can `reset` the contract
- `Customer` can only check their baggages when they were `registered`
- There are three different `flight_classes`, each one has a different `fee` (in NEAR unit) strategy:
  - `First class`: 2*(total weight, except the heaviest one)
  - `Business class`: 2*(total weight)
  - `Economy class`: 2*(total weight + distance)
- Each `Customer` in a `flight`, can only have `at most 3 baggages`
- Only the `Airline` can call the `deliver_baggage` method
- Every operations must follow the workflow (e.g. claim can only operate after delivering)

# Folder structure
- `baggage.rs`: The structure of a baggage
- `fee.rs`: The fee strategy classes (using strategy design pattern)
- `flight_detail.rs`: The structure of a flight detail (for each customer)
- `types.rs`: Definition of data types
- `lib.rs`: The main source code of my contract
- `test.rs`: Unit test source

# Unit test
```Bash
$ cargo test
```

# Manual test
## Compile and build
```Bash
$ ./build.sh
```

## Dev deploy
```Bash
$ ./dev-deploy.sh
```

## Create variables
```Bash
$ source 'neardev/dev-account.env'
$ export OWNER='phuc16102001.testnet'
$ export AIRLINE='phuc16102001.testnet'
$ export CUSTOMER='thanhhoang4869.testnet'
```

## Init contract
```Bash
$ near call $CONTRACT_NAME init '{"payment_account":"'$AIRLINE'"}' --accountId $OWNER
```

## Registry flight
```Bash
$ near call $CONTRACT_NAME registry '{"flight_id":1, "flight_class":"First", "distance": 10}' --accountId $CUSTOMER
```

## Baggage operations

### Add new baggage
```Bash
$ near call $CONTRACT_NAME add_baggage '{"flight_id":1,"baggage_weight":4}' --accountId $CUSTOMER
```

### Remove baggage
```Bash
$ near call $CONTRACT_NAME remove_baggage '{"flight_id":1,"baggage_id":0}' --accountId $CUSTOMER
```

### Remove all baggages
```Bash
$ near call $CONTRACT_NAME remove_all_baggages '{"flight_id":1}' --accountId $CUSTOMER
```

## Check status operations

### Check flight state
```Bash
$ near call $CONTRACT_NAME check_state '{"flight_id":1}' --accountId $CUSTOMER
```

### Check flight class
```Bash
$ near call $CONTRACT_NAME check_class '{"flight_id":1}' --accountId $CUSTOMER
```

### Check the number of current baggages
```Bash
$ near call $CONTRACT_NAME check_number_baggages '{"flight_id":1}' --accountId $CUSTOMER
```

### Check a baggage
```Bash
$ near call $CONTRACT_NAME check_baggage '{"flight_id":1, "baggage_id":0}' --accountId $CUSTOMER
```

### Check fee before depositing
```Bash
$ near call $CONTRACT_NAME check_fee '{"flight_id":1}' --accountId $CUSTOMER
```

## Process operations

### Deposit (accept)
```Bash
$ near call $CONTRACT_NAME accept '{"flight_id":1}' --accountId $CUSTOMER --amount 10
```

### Delivering baggages
```Bash
$ near call $CONTRACT_NAME deliver_baggage '{"flight_id":1, "customer_id": "'$CUSTOMER'"}' --accountId $AIRLINE
```

### Claim baggages
```Bash
$ near call $CONTRACT_NAME claim_baggages '{"flight_id":1}' --accountId $CUSTOMER
```

# Contribution
This project was implemented by [phuc16102001](https://github.com/phuc16102001)

You can reference from this, but **do not copy**

These are the project which I have referenced from:
- [Tin Writes Code](https://github.com/tinwritescode)
- [Sample lottery](https://github.com/Learn-NEAR/NCD.L1.sample--lottery)
- [Meme museum](https://github.com/Learn-NEAR/NCD.L1.sample--meme-museum)
- [Cold chain delivery](https://github.com/Learn-NEAR/NCD.L1.sample--cold-chain-delivery)
'''
'''--- build.sh ---
cargo build --target wasm32-unknown-unknown --release
'''
'''--- dev-deploy.sh ---
rm -rf neardev
near dev-deploy --accountId 'phuc16102001.testnet' --wasmFile 'target\wasm32-unknown-unknown\release\airplane_baggage_checking.wasm'
'''
'''--- src/baggage.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};  
use near_sdk::{serde::{Serialize, Deserialize}};
use crate::types::*;

#[derive(BorshDeserialize, BorshSerialize)]
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Baggage {
    baggage_id: BaggageId,
    baggage_weight: Weight
}

impl Baggage {
    pub fn new(baggage_id: BaggageId, baggage_weight: Weight) -> Self {
        Self {
            baggage_id,
            baggage_weight
        }
    }

    pub fn get_id(&self) -> &BaggageId {
        &self.baggage_id
    }
    
    pub fn get_weight(&self) -> &Weight {
        &self.baggage_weight
    }
}
'''
'''--- src/fee.rs ---
use near_sdk::Balance;
use near_sdk::collections::{UnorderedMap};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};  
  
use crate::baggage::*;
use crate::types::*;

pub trait FeeStrategy {
    fn calculate_fee(
        &self,
        distance: Distance,
        baggages: &UnorderedMap<BaggageId, Baggage>
    ) -> Balance;
}

fn sum_weight(baggages: &UnorderedMap<BaggageId, Baggage>) -> Weight{
    let mut ret: Weight = 0.0;
    for baggage in baggages.values() {
        ret += baggage.get_weight();
    }
    ret
}

fn max_weight(baggages: &UnorderedMap<BaggageId, Baggage>) -> Weight{
    let mut ret: Weight = 0.0;
    for baggage in baggages.values() {
        if *(baggage.get_weight()) > ret {
            ret = *(baggage.get_weight());
        }
    }
    ret
}

#[derive(BorshDeserialize, BorshSerialize)]
pub struct FirstFee {}
impl FeeStrategy for FirstFee {
    fn calculate_fee(
        &self,
        _distance: Distance,
        baggages: &UnorderedMap<BaggageId, Baggage>
    ) -> Balance {
        ((sum_weight(baggages)-max_weight(baggages)) as Balance)*2
    }
}

#[derive(BorshDeserialize, BorshSerialize)]
pub struct BusinessFee {}
impl FeeStrategy for BusinessFee {
    fn calculate_fee(
        &self,
        _distance: Distance,
        baggages: &UnorderedMap<BaggageId, Baggage>
    ) -> Balance {
        (sum_weight(baggages) as Balance)*2
    }
}

#[derive(BorshDeserialize, BorshSerialize)]
pub struct EconomyFee {}
impl FeeStrategy for EconomyFee {
    fn calculate_fee(
        &self,
        distance: Distance,
        baggages:&UnorderedMap<BaggageId, Baggage>
    ) -> Balance {
        ((sum_weight(baggages)+distance) as Balance)*2
    }
}
'''
'''--- src/flight_detail.rs ---
use near_sdk::Balance;
use near_sdk::collections::UnorderedMap;
use near_sdk::{serde::{Serialize, Deserialize}};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};  

use crate::fee::*;
use crate::types::*;
use crate::baggage::*;

#[derive(Serialize, Deserialize, BorshDeserialize, BorshSerialize)]
#[serde(crate = "near_sdk::serde")]
#[derive(Debug, PartialEq)]
pub enum FlightClass {
    First,
    Business,
    Economy
}

#[derive(Serialize, Deserialize, BorshDeserialize, BorshSerialize)]
#[serde(crate = "near_sdk::serde")]
#[derive(Debug, PartialEq)]
pub enum FlightState {
    Idle,
    Checked,
    Delivered,
    Claimed
}

#[derive(BorshDeserialize, BorshSerialize)]
pub struct FlightDetail {
    flight_id: FlightId,
    flight_class: FlightClass, 
    distance: Distance,
    baggages: UnorderedMap<BaggageId, Baggage>,
    state: FlightState
}

impl FlightDetail {
    pub fn new(
        flight_id: FlightId,
        flight_class: FlightClass,
        distance: Distance,
    ) -> Self {
        Self {
            flight_id,
            flight_class,
            distance,
            baggages: UnorderedMap::new(format!("baggages_{}",flight_id).as_bytes()),
            state: FlightState::Idle
        }
    }

    pub fn add_baggage(&mut self, baggage: Baggage) {
        self.baggages.insert(baggage.get_id(), &baggage);
    }

    pub fn remove_baggage(&mut self, baggage_id: BaggageId) {
        self.baggages.remove(&baggage_id);
    }

    pub fn clear_baggages(&mut self) {
        self.baggages.clear();
    }

    pub fn set_state(&mut self, new_state: FlightState) {
        self.state = new_state;
    }

    pub fn get_state(&self) -> &FlightState {
        &self.state
    }

    pub fn get_flight_id(&mut self) -> &FlightId{
        &self.flight_id
    }

    pub fn get_flight_class(&self) -> &FlightClass{
        &self.flight_class
    }
    
    pub fn get_distance(&self) -> &Distance{
        &self.distance
    }
    
    pub fn get_baggages(&self) -> &UnorderedMap<BaggageId, Baggage>{
        &self.baggages
    }

    pub fn get_fee(&self) -> Balance {
        self.get_fee_strategy().calculate_fee(
            self.distance,
            &self.baggages
        )
    }

    fn get_fee_strategy(&self) -> Box<dyn FeeStrategy> {
        match &self.flight_class {
            FlightClass::First => Box::new(FirstFee{}),
            FlightClass::Business => Box::new(BusinessFee{}),
            FlightClass::Economy => Box::new(EconomyFee{})
        }
    }
}
'''
'''--- src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{env, near_bindgen, Promise, Balance};
use near_sdk::{AccountId};
use near_sdk::collections::{UnorderedMap};

pub mod flight_detail;
pub mod baggage;
pub mod types;
pub mod fee;

use crate::flight_detail::*;
use crate::baggage::*;
use crate::types::*;

near_sdk::setup_alloc!();

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Contract {
    owner: AccountId,
    payment_account: AccountId,
    initialized: bool,
    user_flights: UnorderedMap<(AccountId, FlightId), FlightDetail>,
    count_baggage: BaggageId
}

impl Default for Contract {
    fn default() -> Self {
        Self {
            owner: env::signer_account_id(),
            payment_account: env::predecessor_account_id(),
            initialized: false,
            user_flights: UnorderedMap::new(b"user_flights".to_vec()),
            count_baggage: 0
        }
    }
}

#[near_bindgen]
impl Contract {
    fn _debug(&self) {
        self.assert_initialized();

        let signer = env::signer_account_id();
        let predecessor = env::predecessor_account_id();
        let current = env::current_account_id();

        env::log(format!("Signer: {}",&signer).as_bytes());
        env::log(format!("Predecessor: {}",&predecessor).as_bytes());
        env::log(format!("Current: {}",&current).as_bytes());
    }

    // ====================================================================
    pub fn get_payment_account(&self) -> &String {
        self.assert_initialized();
        &self.payment_account
    }

    pub fn get_initialized(&self) -> bool {
        self.initialized
    }

    pub fn get_owner(&self) -> &String {
        &self.owner
    }
    // ====================================================================
    pub fn init(&mut self, payment_account: AccountId) {
        // Contract must not be initialized
        assert_eq!(
            self.initialized,
            false,
            "Contract was already initialized"
        );

        // Only owner can init
        let predecessor = env::predecessor_account_id(); 
        assert_eq!(
            self.owner,
            predecessor,
            "Only contract owner can init"
        );
        
        // Payment account (Airlines) must not same as contract account
        let current = env::current_account_id();
        assert_ne!(
            payment_account,
            current,
            "Payment account cannot be contract"
        );

        self.initialized = true;
        self.user_flights = UnorderedMap::new(b"user_flights".to_vec());
        self.payment_account = payment_account;
    
        env::log(format!(
            "Contract initialized by {}, payment to {}",
            predecessor,
            self.payment_account
        ).as_bytes());
    }

    pub fn reset(&mut self) {
        self.assert_initialized();

        let predecessor = env::predecessor_account_id();
        assert_eq!(
            self.owner,
            predecessor,
            "Only the contract owner can reset"
        );

        self.initialized = false;
        self.payment_account = self.owner.clone();
        self.user_flights.clear();
    
        env::log("Reset successfully".as_bytes());
    }

    // ====================================================================
    pub fn registry(
        &mut self, 
        flight_id: FlightId,
        flight_class: FlightClass,
        distance: Distance
    ) {
        self.assert_initialized();

        let customer = env::predecessor_account_id();
        let key = (customer, flight_id);
        match self.user_flights.get(&key) {
            Some(_flight) => {
                panic!("This flight was registered by you");
            },
            None => {
                let new_flight = FlightDetail::new(
                    flight_id,
                    flight_class,
                    distance
                );
                self.user_flights.insert(&key, &new_flight);
                env::log("Registry successfully".as_bytes());
            }
        }
    }

    pub fn add_baggage(
        &mut self, 
        flight_id: FlightId, 
        baggage_weight: Weight
    ) -> BaggageId {
        self.assert_initialized();
    
        let customer_id = env::predecessor_account_id();
        let key = &(customer_id, flight_id);

        match self.user_flights.get(&key) {
            Some(mut flight) => {
                self.assert_state(&flight, FlightState::Idle);
                        
                // Each (account, flight) can only have at most 3
                let baggage_len: usize = flight.get_baggages().len() as usize;
                if baggage_len>=3 {
                    panic!("You cannot add more than 3 baggages"); 
                } else {
                    let baggage_id: BaggageId = self.count_baggage;
                    let new_baggage = Baggage::new (
                        baggage_id,
                        baggage_weight
                    );

                    flight.add_baggage(
                        new_baggage
                    );
                    self.user_flights.insert(&key,&flight);
                    self.count_baggage += 1;

                    env::log("Add baggage succesfully".as_bytes());
                    env::log(format!("Baggage id: {}",&baggage_id).as_bytes());

                    baggage_id
                }
            },
            None => {
                panic!("Cannot find your flight");
            }
        }
    }

    pub fn check_number_baggages(
        &mut self, 
        flight_id: FlightId
    ) -> u64 {
        self.assert_initialized();

        let customer_id = env::predecessor_account_id();
        let key = &(customer_id, flight_id);
        match self.user_flights.get(&key) {
            Some(flight) => {
                let baggages = flight.get_baggages();
                env::log(format!("Number of baggages: {}",baggages.len()).as_bytes());
                baggages.len()
            },
            None => {
                panic!("Cannot find your flight");
            }
        }
    }

    pub fn check_baggage(
        &mut self, 
        flight_id: FlightId,
        baggage_id: BaggageId
    ) -> Baggage {
        self.assert_initialized();

        let customer_id = env::predecessor_account_id();
        let key = &(customer_id, flight_id);

        match self.user_flights.get(&key) {
            Some(flight) => {
                let baggages = flight.get_baggages();
                
                match baggages.get(&baggage_id) {
                    Some(baggage) => {
                        env::log(format!(
                            "[{}] Weight={}", 
                            baggage.get_id(), 
                            baggage.get_weight()
                        ).as_bytes());
                        baggage
                    },
                    None => {
                        panic!("Cannot find your baggage");
                    }
                }
            },
            None => {
                panic!("Cannot find your flight");
            }
        }
    }

    pub fn check_fee(&mut self, flight_id: FlightId) -> Balance {
        self.assert_initialized();
        
        let customer_id = env::predecessor_account_id();
        let key = &(customer_id, flight_id);

        match self.user_flights.get(&key) {
            Some(flight) => {        
                let price = flight.get_fee();
                env::log(format!("Your price: {} NEAR",&price).as_bytes());
                price
            },
            None => {
                panic!("Cannot find your flight");
            }
        }
    }

    pub fn check_state(&mut self, flight_id: FlightId) -> String {
        self.assert_initialized();
        
        let customer_id = env::predecessor_account_id();
        let key = &(customer_id, flight_id);

        match self.user_flights.get(&key) {
            Some(flight) => {        
                env::log(format!("State: {:?}",flight.get_state()).as_bytes());
                format!("{:?}",&flight.get_state())
            },
            None => {
                panic!("Cannot find your flight");
            }
        }
    }

    
    pub fn check_class(&mut self, flight_id: FlightId) -> String {
        self.assert_initialized();
        
        let customer_id = env::predecessor_account_id();
        let key = &(customer_id, flight_id);

        match self.user_flights.get(&key) {
            Some(flight) => {        
                let flight_class = flight.get_flight_class();
                env::log(format!("Class: {:?}",&flight_class).as_bytes());
                format!("{:?}",&flight_class)
            },
            None => {
                panic!("Cannot find your flight");
            }
        }
    }

    #[payable]
    pub fn accept(&mut self, flight_id: FlightId) {
        self.assert_initialized();

        let customer_id = env::predecessor_account_id();
        let key = &(customer_id, flight_id);

        match self.user_flights.get(&key) {
            Some(mut flight) => {    
                self.assert_state(
                    &flight, 
                    FlightState::Idle,
                );
                let fee = flight.get_fee();
                let deposit = env::attached_deposit();
                assert_eq!(
                    to_yoto(fee),
                    deposit,
                    "You must pay {} NEAR", fee
                );

                flight.set_state(FlightState::Checked);
                self.user_flights.insert(&key,&flight);
                env::log("Your baggages are checked".as_bytes());
            },
            None => {
                panic!("Cannot find your flight");
            }
        }

    }

    pub fn remove_baggage(&mut self, flight_id: FlightId, baggage_id: BaggageId) {
        self.assert_initialized();

        let customer_id = env::predecessor_account_id();
        let key = &(customer_id, flight_id);

        match self.user_flights.get(&key) {
            Some(mut flight) => {        
                self.assert_state(&flight, FlightState::Idle);
                flight.remove_baggage(baggage_id);
                self.user_flights.insert(&key,&flight);
                env::log("Remove baggage successfully".as_bytes());
            },
            None => {
                panic!("Cannot find your flight");
            }
        }
    }

    pub fn remove_all_baggages(&mut self, flight_id: FlightId) {
        self.assert_initialized();

        let customer_id = env::predecessor_account_id();
        let key = &(customer_id, flight_id);

        match self.user_flights.get(&key) {
            Some(mut flight) => {        
                flight.clear_baggages();
                self.user_flights.insert(&key,&flight);
                env::log("Remove all baggages successfully".as_bytes());
            },
            None => {
                panic!("Cannot find your flight");
            }
        }
    }

    pub fn deliver_baggage(&mut self, customer_id: AccountId, flight_id: FlightId) {
        self.assert_initialized();

        assert_eq!(
            env::predecessor_account_id(),
            self.payment_account,
            "Only airline can deliver the baggages"
        );

        let key = &(customer_id, flight_id);

        match self.user_flights.get(&key) {
            Some(mut flight) => {        
                self.assert_state(&flight, FlightState::Checked);
                flight.set_state(FlightState::Delivered);
                self.user_flights.insert(&key,&flight);
            },
            None => {
                panic!("Cannot find your flight");
            }
        }
    }

    #[payable]
    pub fn claim_baggages(&mut self, flight_id: FlightId) {
        self.assert_initialized();

        let customer_id = env::predecessor_account_id();
        let key = &(customer_id, flight_id);

        match self.user_flights.get(&key) {
            Some(mut flight) => {        
                self.assert_state(&flight, FlightState::Delivered);

                flight.set_state(FlightState::Claimed);
                self.user_flights.insert(&key,&flight);
                
                Promise::new(
                    self.get_payment_account().to_string()
                ).transfer(
                    to_yoto(flight.get_fee())
                );
            },
            None => {
                panic!("Cannot find your flight");
            }
        }

    }

    // ===============================================
    fn assert_initialized(&self) {
        assert_eq!(
            self.initialized,
            true,
            "Contract was not initialized"
        );  

    }

    fn assert_state(&self, flight: &FlightDetail, target_state: FlightState) {
        if !(*flight.get_state() == target_state) {
            panic!(
                "You can only do this in {:?} state, not {:?}",
                target_state,
                flight.get_state()
            );
        }
    }
}
'''
'''--- src/types.rs ---
use near_sdk::Balance;

pub type BaggageId = u64;
pub type FlightId = u64;
pub type Distance = f32;    // miles    
pub type Weight = f32;      // pound (lbs)

pub fn to_yoto(near: Balance) -> Balance {
    return near*10u128.pow(24);
}
'''
'''--- tests/tests.rs ---
#[cfg(test)]
mod tests {
    use airplane_baggage_checking::*;
    use airplane_baggage_checking::flight_detail::*;
    use airplane_baggage_checking::types::*;
    use near_sdk::{MockedBlockchain, Balance};
    use near_sdk::{testing_env, VMContext};

    fn get_context(
        input: Vec<u8>, 
        is_view: bool, 
        predecessor_account_id: String,
        attached_deposit: Balance
    ) -> VMContext {
        VMContext {
            current_account_id: "dev&-account.testnet".to_string(),
            signer_account_id: predecessor_account_id.clone(),
            signer_account_pk: vec![0, 1, 2],
            predecessor_account_id: predecessor_account_id.clone(),
            input,
            block_index: 0,
            block_timestamp: 0,
            account_balance: 10u128.pow(32),
            account_locked_balance: 0,
            storage_usage: 0,
            attached_deposit: attached_deposit,
            prepaid_gas: 10u64.pow(18),
            random_seed: vec![0, 1, 2],
            is_view,
            output_data_receivers: vec![],
            epoch_height: 19,
        }
    }

    fn get_context_airlines() -> VMContext {
        get_context(
            vec![], 
            false, 
            "phuc16102001.testnet".to_string(), 
            0
        )
    }

    fn get_context_customer(attached_deposit: Balance) -> VMContext {
        get_context(
            vec![], 
            false, 
            "thanhhoang4869.testnet".to_string(),
            attached_deposit
        )
    }
    
    #[test]
    fn init_contract() {
        let context = get_context_airlines();
        testing_env!(context);

        let mut contract = Contract::default();
        assert_eq!(
            contract.get_initialized(),
            false
        );
        
        contract.init("phuc16102001.testnet".to_string());
        assert_eq!(
            contract.get_payment_account(),
            "phuc16102001.testnet"
        );
        assert_eq!(
            contract.get_owner(),
            "phuc16102001.testnet"
        );
        assert_eq!(
            contract.get_initialized(),
            true
        );
    }

    #[test]
    #[should_panic(
        expected = r#"Contract was already initialized"#
    )]
    fn double_init() {
        let context = get_context_airlines();
        testing_env!(context);

        let mut contract = Contract::default();
        assert_eq!(
            contract.get_initialized(),
            false
        );
        
        contract.init("phuc16102001.testnet".to_string());
        contract.init("phuc16102001.testnet".to_string());
    }

    #[test]
    fn reset_payment_account() {
        let context = get_context_airlines();
        testing_env!(context);
        let mut contract = Contract::default();

        contract.init("phuc16102001.testnet".to_string());
        contract.reset();
        contract.init("thanhhoang4869.testnet".to_string());
    
        assert_eq!(
            contract.get_payment_account(),
            "thanhhoang4869.testnet"
        );
        assert_eq!(
            contract.get_owner(),
            "phuc16102001.testnet"
        );
    }

    #[test]
    fn registry_flight() {
        let context_airline = get_context_airlines();
        let context_customer = get_context_customer(0);

        testing_env!(context_airline);
        let mut contract = Contract::default();
        contract.init("phuc16102001.testnet".to_string());
    
        testing_env!(context_customer);
        let flight_id = 1;
        contract.registry(1, FlightClass::First, 10.0);
        assert_eq!(
            contract.check_class(flight_id),
            "First"
        );
    }

    #[test]
    #[should_panic(
        expected=r#"Cannot find your flight"#
    )]
    fn add_baggages_fail() {
        let context_airline = get_context_airlines();
        let context_customer = get_context_customer(0);

        testing_env!(context_airline);
        let mut contract = Contract::default();
        contract.init("phuc16102001.testnet".to_string());
    
        testing_env!(context_customer);
        let flight_id = 1;
        contract.add_baggage(flight_id, 4.0);
    }

    #[test]
    fn add_baggages_success() {
        let context_airline = get_context_airlines();
        let context_customer = get_context_customer(0);

        testing_env!(context_airline);
        let mut contract = Contract::default();
        contract.init("phuc16102001.testnet".to_string());
    
        testing_env!(context_customer);
        let flight_id = 1;
        contract.registry(1, FlightClass::First, 10.0);
        let baggage_id = contract.add_baggage(flight_id, 4.0);
        let baggage = contract.check_baggage(flight_id, baggage_id);
        
        assert_eq!(
            baggage_id,
            0
        );
        assert_eq!(
            *baggage.get_id(),
            0
        );
        assert_eq!(
            *baggage.get_weight(),
            4.0
        );
    }

    #[test]
    fn count_baggages() {
        let context_airline = get_context_airlines();
        let context_customer = get_context_customer(0);

        testing_env!(context_airline);
        let mut contract = Contract::default();
        contract.init("phuc16102001.testnet".to_string());
    
        testing_env!(context_customer);
        let flight_id = 1;
        contract.registry(1, FlightClass::First, 10.0);
        contract.add_baggage(flight_id, 4.0);
        contract.add_baggage(flight_id, 1.0);
        
        assert_eq!(
            contract.check_number_baggages(flight_id),
            2
        );
    }

    #[test]
    #[should_panic(
        expected=r#"You cannot add more than 3 baggages"#
    )]
    fn limit_baggages() {
        let context_airline = get_context_airlines();
        let context_customer = get_context_customer(0);

        testing_env!(context_airline);
        let mut contract = Contract::default();
        contract.init("phuc16102001.testnet".to_string());
    
        testing_env!(context_customer);
        let flight_id = 1;
        contract.registry(1, FlightClass::First, 10.0);
        contract.add_baggage(flight_id, 1.0);
        contract.add_baggage(flight_id, 3.0);
        contract.add_baggage(flight_id, 5.0);
        contract.add_baggage(flight_id, 4.0);
    }

    #[test]
    #[should_panic(
        expected=r#"Cannot find your baggage"#
    )]
    fn not_found_baggages() {
        let context_airline = get_context_airlines();
        let context_customer = get_context_customer(0);

        testing_env!(context_airline);
        let mut contract = Contract::default();
        contract.init("phuc16102001.testnet".to_string());
    
        testing_env!(context_customer);
        let flight_id = 1;
        contract.registry(1, FlightClass::First, 10.0);
        
        let baggage_id = contract.add_baggage(flight_id, 1.0);
        let other_id = baggage_id+1;
        contract.check_baggage(flight_id, other_id);
    }

    fn check_fee(
        flight_class: FlightClass, 
        distance: Distance,
        first_weight: Weight,
        second_weight: Weight,
        third_weight: Weight,
        expected_price: Balance
    ) {
        let context_airline = get_context_airlines();
        let context_customer = get_context_customer(0);

        testing_env!(context_airline);
        let mut contract = Contract::default();
        contract.init("phuc16102001.testnet".to_string());
    
        testing_env!(context_customer);
        let flight_id = 1;
        contract.registry(flight_id, flight_class, distance);
        
        contract.add_baggage(flight_id, first_weight);
        contract.add_baggage(flight_id, second_weight);
        contract.add_baggage(flight_id, third_weight);

        assert_eq!(
            contract.check_fee(flight_id),
            expected_price
        )
    }

    #[test]
    fn check_fee_first() {
        check_fee(
            FlightClass::First,
            100.0,
            5.0, 2.0, 3.0,
            10
        )
    }

    #[test]
    fn check_fee_business() {
        check_fee(
            FlightClass::Business,
            100.0,
            5.0, 2.0, 3.0,
            20
        )
    }

    #[test]
    fn check_fee_economy() {
        check_fee(
            FlightClass::Economy,
            100.0,
            5.0, 2.0, 3.0,
            220
        )
    }
}
'''