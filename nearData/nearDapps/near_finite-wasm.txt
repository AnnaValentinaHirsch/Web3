*GitHub Repository "near/finite-wasm"*

'''--- .github/workflows/fuzz.yml ---
name: Package fuzz targets
on:
  workflow_dispatch:
  push:
    branches:
      - main
      - fuzz-test # Push to this branch to trigger this workflow for testing changes.

jobs:
  build:
    runs-on: "ubuntu-20.04"

    permissions:
      contents: "read"
      id-token: "write"

    steps:
      - uses: actions/checkout@v2
      - uses: ocaml/setup-ocaml@v2
        with:
          ocaml-compiler: 4.13.1
      - id: "auth"
        uses: "google-github-actions/auth@v2"
        with:
          workload_identity_provider: "projects/346595944828/locations/global/workloadIdentityPools/github-pool/providers/github-provider"
          service_account: "github-service-account@nearone-clusterfuzz.iam.gserviceaccount.com"
      - uses: "google-github-actions/setup-gcloud@v1"
        with:
          version: ">= 416.0.0"
      - run: rustup default nightly
      - run: opam install ocamlbuild
      - uses: baptiste0928/cargo-install@21a18ba3bf4a184d1804e8b759930d3471b1c941
        with:
          crate: cargo-bolero
      - run: |
          NAME="finite-wasm-$(env TZ=Etc/UTC date +"%Y%m%d%H%M%S")"
          opam exec -- cargo +nightly bolero build-clusterfuzz --all-features --profile fuzz
          gsutil cp -Z target/fuzz/clusterfuzz.tar "gs://nearone_fuzzer_targets/finite-wasm/$NAME.tar.gz"

'''
'''--- Cargo.toml ---
[package]
name = "finite-wasm"
version = "0.5.0"
edition = "2021"
authors = ["Simonas Kazlauskas <finite-wasm@kazlauskas.me>"]
license = "MIT OR Apache-2.0"
readme = "README.mkd"
repository = "https://github.com/near/finite-wasm"
homepage = "https://github.com/near/finite-wasm"
documentation = "https://docs.rs/finite-wasm"
description = """
Guarantee deterministic limits on execution time and space resources made available to the
WebAssembly programs in a runtime-agnostic way.
"""
exclude = ["/tests/snaps"]

[[test]]
name = "wast"
path = "src/wast_tests/runner.rs"
harness = false
required-features = ["wast-tests"]

[[bench]]
name = "instrument_all"
path = "benches/instrument_all.rs"
harness = false
required-features = ["instrument"]

[dependencies]
atoi = { version = "2.0", optional = true }
bitvec = "1.0.1"
dissimilar = "1"
lazy_static = { version = "1.4", optional = true }
libc = { version = "0.2.144", optional = true }
wasmparser = "0.105.0"
# Ensure that we depend on a single version of wasmparser only (patch versions bump wasmparser dep)
wasmprinter = "=0.2.57"
thiserror = "1"
num-traits = "0.2.15"
prefix-sum-vec = "0.1.2"
tempfile = { version = "3.5", optional = true }
wasm-encoder = { version = "0.27.0", optional = true }
wast = { version = "52", optional = true }

[dev-dependencies]
arbitrary = { version = "1.3", features = ["derive"] }
bolero = { version = "0.10.0", features = ["arbitrary"] }
criterion = "0.5.0"
rayon = "1.6.1"
tempfile = "3.7"
walkdir = "2.3.0"
wasm-instrument = "0.4"
wasm-smith = "0.12"
wasmparser = "0.105.0"

[features]
instrument = ["wasm-encoder"]
wast-tests = ["atoi", "instrument", "lazy_static", "libc", "tempfile", "wast"]

[package.metadata.docs.rs]
all-features = true
rustdoc-args = ["--cfg", "finite_wasm_docs"]

[profile.fuzz]
inherits = "dev"
opt-level = 3
incremental = false
codegen-units = 1

'''
'''--- benches/instrument_all.rs ---
fn instrument_finite_wasm(code: &[u8]) -> Result<Vec<u8>, ()> {
    let outcome = finite_wasm::Analysis::new()
        .with_stack(DefaultStackConfig)
        .with_gas(DefaultGasConfig)
        .analyze(code)
        .map_err(|_| ())?;
    outcome.instrument("env", code).map_err(|_| ())
}

fn instrument_wasm_instrument(code: &[u8]) -> Result<Vec<u8>, ()> {
    let parsed =
        wasm_instrument::parity_wasm::elements::Module::from_bytes(code).map_err(|_| ())?;
    let injector = wasm_instrument::gas_metering::host_function::Injector::new("env", "gas");
    let rules = wasm_instrument::gas_metering::ConstantCostRules::new(1, 1, 1);
    let gassed = wasm_instrument::gas_metering::inject(parsed, injector, &rules).map_err(|_| ())?;
    let stack_limited = wasm_instrument::inject_stack_limiter(gassed, 1024).map_err(|_| ())?;
    stack_limited.into_bytes().map_err(|_| ())
}

fn all_tests(c: &mut criterion::Criterion) {
    let current_directory = std::env::current_dir().expect("get current_dir");
    let tests_directory = current_directory.join("tests");
    let temp_directory = tests_directory.join("tmp");
    let snaps_directory = tests_directory.join("snaps");
    let mut group = c.benchmark_group("tests");
    for entry in walkdir::WalkDir::new(&tests_directory) {
        let entry = entry.expect("walkdir");
        let entry_path = entry.path();
        if entry_path.starts_with(&temp_directory) {
            continue;
        }
        if entry_path.starts_with(&snaps_directory) {
            continue;
        }
        if Some(std::ffi::OsStr::new("wast")) != entry_path.extension() {
            continue;
        }
        let test_name = entry_path
            .strip_prefix(&tests_directory)
            .unwrap_or(&entry_path)
            .display()
            .to_string();

        let test_contents = std::fs::read_to_string(entry_path).expect("read the test");
        let mut lexer = wast::lexer::Lexer::new(&test_contents);
        lexer.allow_confusing_unicode(true);
        let buf = wast::parser::ParseBuffer::new_with_lexer(lexer).expect("parse buffer");
        let wast: wast::Wast = wast::parser::parse(&buf).expect("parse wast");
        let mut modules = vec![];
        for directive in wast.directives {
            use wast::{QuoteWat as QW, WastDirective as WD, WastExecute as WE};
            match directive {
                WD::Wat(QW::Wat(wat))
                | WD::AssertTrap {
                    exec: WE::Wat(wat), ..
                }
                | WD::AssertMalformed {
                    module: QW::Wat(wat),
                    ..
                }
                | WD::AssertInvalid {
                    module: QW::Wat(wat),
                    ..
                }
                | WD::AssertReturn {
                    exec: WE::Wat(wat), ..
                }
                | WD::AssertException {
                    exec: WE::Wat(wat), ..
                } => match wat {
                    wast::Wat::Module(mut module) => {
                        let module_bytes = module.encode().expect("encode module");
                        modules.push(module_bytes);
                    }
                    wast::Wat::Component(_) => todo!("components"),
                },
                _ => {}
            }
        }

        // We must filter the list of modules to those valid for both approaches. This makes sure
        // both of the crates are doing the same amount of work, and not running faster because
        // e.g. they just failed to process the module entirely.
        modules.retain(|m| {
            instrument_finite_wasm(&m).is_ok() && instrument_wasm_instrument(&m).is_ok()
        });

        if !modules.is_empty() {
            group.bench_with_input(
                criterion::BenchmarkId::new("finite_wasm", &test_name),
                &modules,
                |b, i| {
                    b.iter(|| {
                        i.iter()
                            .map(|m| instrument_finite_wasm(m))
                            .collect::<Vec<_>>()
                    })
                },
            );
            group.bench_with_input(
                criterion::BenchmarkId::new("wasm_instrument", &test_name),
                &modules,
                |b, i| {
                    b.iter(|| {
                        i.iter()
                            .map(|m| instrument_wasm_instrument(m))
                            .collect::<Vec<_>>()
                    })
                },
            );
        }
    }
}

criterion::criterion_group!(benches, all_tests);
criterion::criterion_main!(benches);

struct DefaultStackConfig;
impl finite_wasm::max_stack::SizeConfig for DefaultStackConfig {
    fn size_of_value(&self, ty: wasmparser::ValType) -> u8 {
        use wasmparser::ValType::*;
        match ty {
            I32 => 4,
            I64 => 8,
            F32 => 4,
            F64 => 8,
            V128 => 16,
            FuncRef => 32,
            ExternRef => 32,
        }
    }

    fn size_of_function_activation(
        &self,
        locals: &prefix_sum_vec::PrefixSumVec<wasmparser::ValType, u32>,
    ) -> u64 {
        u64::from(locals.max_index().map(|&v| v + 1).unwrap_or(0))
    }
}

pub(crate) struct DefaultGasConfig;

macro_rules! gas_visit {
    (visit_end => $({ $($arg:ident: $argty:ty),* })?) => {};
    (visit_else => $({ $($arg:ident: $argty:ty),* })?) => {};
    ($visit:ident => $({ $($arg:ident: $argty:ty),* })?) => {
        fn $visit(&mut self $($(,$arg: $argty)*)?) -> Self::Output {
            1u64
        }
    };

    ($( @$proposal:ident $op:ident $({ $($arg:ident: $argty:ty),* })? => $visit:ident)*) => {
        $(gas_visit!{ $visit => $({ $($arg: $argty),* })? })*
    }
}

impl<'a> wasmparser::VisitOperator<'a> for DefaultGasConfig {
    type Output = u64;
    fn visit_end(&mut self) -> u64 {
        0
    }
    fn visit_else(&mut self) -> u64 {
        0
    }

    wasmparser::for_each_operator!(gas_visit);
}

'''
'''--- build.rs ---
#[cfg(feature = "wast-tests")]
fn build_interpreter() {
    println!("cargo:rerun-if-changed=interpreter");
    std::process::Command::new("make")
        .args(["-Cinterpreter", "wasm"])
        .output()
        .expect("failed compiling wasm interpreter");
}

fn main() {
    #[cfg(feature = "wast-tests")]
    build_interpreter();
}

'''
'''--- deny.toml ---
targets = [
    { triple = "x86_64-unknown-linux-gnu" },
    { triple = "aarch64-unknown-linux-gnu" },
    { triple = "x86_64-unknown-linux-musl" },
    { triple = "aarch64-apple-darwin" },
    { triple = "x86_64-apple-darwin" },
    { triple = "x86_64-pc-windows-msvc" },
]

[bans]
multiple-versions = "deny"
wildcards = "deny"
skip = [
    { name = "windows-sys" },
    { name = "windows-targets" },
    { name = "windows_x86_64_msvc" },
    # wasmparser 0.105 requires:
    { name = "wasmparser", version = "0.105" },
    { name = "hashbrown", version = "0.12" },
    { name = "indexmap", version = "1.9" },
    # bolero-generator-derive v0.9.2 requires:
    { name = "syn", version = "1.0" },
]

# our bolero fork requires:
[sources]
allow-git = ["https://github.com/Ekleog-NEAR/bolero?rev=362328af9f0539f9d6ee62bb4334afaa0a71b572#362328af9f0539f9d6ee62bb4334afaa0a71b572"]

[licenses]
allow = [
    "Apache-2.0",
    "MIT",
    "Apache-2.0 WITH LLVM-exception",
    "Unicode-DFS-2016"
]

[advisories]
ignore = [
    # parity-wasm is only ever used for dev-dependencies
    "RUSTSEC-2022-0061",
]

'''
'''--- interpreter/README.md ---
# WebAssembly Reference Interpreter

This repository implements a interpreter for WebAssembly. It is written for clarity and simplicity, _not_ speed. It is intended as a playground for trying out ideas and a device for nailing down the exact semantics, and as a proxy for the (yet to be produced) formal specification of WebAssembly. For that purpose, the code is written in a fairly declarative, "speccy" way.

The interpreter can

* *decode*/*parse* and *validate* modules in binary or text format
* *execute* scripts with module definitions, invocations, and assertions
* *convert* between binary and text format (both directions)
* *export* test scripts to self-contained JavaScript test cases
* *run* as an interactive interpreter

The text format defines modules in S-expression syntax. Moreover, it is generalised to a (very dumb) form of *script* that can define multiples module and a batch of invocations, assertions, and conversions between them. As such it is richer than the binary format, with the additional functionality purely intended as testing infrastructure. (See [below](#scripts) for details.)

## Building

You'll need OCaml 4.08 or higher. Instructions for installing a recent version of OCaml on multiple platforms are available [here](https://ocaml.org/docs/install.html). On most platforms, the recommended way is through [OPAM](https://ocaml.org/docs/install.html#OPAM).

Once you have OCaml, simply do

```
make
```
You'll get an executable named `./wasm`. This is a byte code executable. If you want a (faster) native code executable, do
```
make opt
```
To run the test suite,
```
make test
```
To do everything:
```
make all
```
Before committing changes, you should do
```
make land
```
That builds `all`, plus updates `winmake.bat`.

#### Building on Windows

The instructions depend on how you [installed OCaml on Windows](https://ocaml.org/docs/install.html#Windows).

1. *Cygwin*: If you want to build a native code executable, or want to hack on the interpreter (i.e., use incremental compilation), then you need to install the Cygwin core that is included with the OCaml installer. Then you can build the interpreter using `make` in the Cygwin terminal, as described above.

2. *Windows Subsystem for Linux* (WSL): You can build the interpreter using `make`, as described above.

3. *From source*: If you just want to build the interpreter and don't care about modifying it, you don't need to install the Cygwin core that comes with the installer. Just install OCaml itself and run
```
winmake.bat
```
in a Windows shell, which creates a program named `wasm`. Note that this will be a byte code executable only, i.e., somewhat slower.

In any way, in order to run the test suite you'll need to have Python installed. If you used Option 3, you can invoke the test runner `runtests.py` directly instead of doing it through `make`.

#### Cross-compiling the Interpreter to JavaScript ####

The Makefile also provides a target to compile (parts of) the interpreter into a [JavaScript library](#javascript-library):
```
make wast.js
```
Building this target requires `js_of_ocaml`, which can be installed with OPAM:
```
opam install js_of_ocaml js_of_ocaml-ppx
```

## Synopsis

#### Running Modules or Scripts

You can call the executable with

```
wasm [option | file ...]
```

where `file`, depending on its extension, either should be a binary (`.wasm`) or textual (`.wat`) module file to be loaded, or a script file (`.wast`, see below) to be run.

By default, the interpreter validates all modules.
The `-u` option selects "unchecked mode", which skips validation and runs code as is.
Runtime type errors will be captured and reported appropriately.

#### Converting Modules or Scripts

A file prefixed by `-o` is taken to be an output file. Depending on its extension, this will write out the preceding module definition in either S-expression or binary format. This option can be used to convert between the two in both directions, e.g.:

```
wasm -d module.wat -o module.wasm
wasm -d module.wasm -o module.wat
```

In the second case, the produced script contains exactly one module definition.
The `-d` option selects "dry mode" and ensures that the input module is not run, even if it has a start section.
In addition, the `-u` option for "unchecked mode" can be used to convert even modules that do not validate.

The interpreter can also convert entire test scripts:

```
wasm -d script.wast -o script.bin.wast
wasm -d script.wast -o script2.wast
wasm -d script.wast -o script.js
```

The first creates a new test scripts where all embedded modules are converted to binary, the second one where all are converted to textual.

The last invocation produces an equivalent, self-contained JavaScript test file.
The flag `-h` can be used to omit the test harness from the converted file;
it then is the client's responsibility to provide versions of the necessary functions.

#### Command Line Expressions

Finally, the option `-e` allows to provide arbitrary script commands directly on the command line. For example:

```
wasm module.wasm -e '(invoke "foo")'
```

#### Interactive Mode

If neither a file nor any of the previous options is given, you'll land in the REPL and can enter script commands interactively. You can also get into the REPL by explicitly passing `-` as a file name. You can do that in combination to giving a module or script file, so that you can then invoke its exports interactively, e.g.:

```
wasm module.wat -
```

See `wasm -h` for (the few) additional options.

#### JavaScript Library ####

The file `wast.js` generated by the respective [Makefile target](#cross-compiling-the-interpreter-to-javascript) is a self-contained JavaScript library for making the [S-expression syntax](#s-expression-syntax) available directly within JavaScript.
It provides a global object named `WebAssemblyText` that currently provides two methods,
```
WebAssemblyText.encode(source)
```
which turns a module in S-expression syntax into a WebAssembly binary, and
```
WebAssemblyText.decode(binary, width)
```
which pretty-prints a binary back into a canonicalised S-expression string.

For example:
```
let source = '(module (func (export "f") (param i32 i32) (result i32) (i32.add (local.get 0) (local.get 1))))'
let binary = WebAssemblyText.encode(source)

(new WebAssembly.Instance(new WebAssembly.Module(binary))).exports.f(3, 4)
// => 7

WebAssemblyText.decode(binary, 80)
// =>
// (module
//   (type $0 (func (param i32 i32) (result i32)))
//   (func $0 (type 0) (local.get 0) (local.get 1) (i32.add))
//   (export "f" (func 0))
// )
```

Depending on how you load the library, the object may be accessed in different ways. For example, using `require` in node.js:

```
let wast = require("./wast.js");
let binary = wast.WebAssemblyText.encode("(module)");
```

Or using `load` from a JavaScript shell:

```
load("./wast.js");
let binary = WebAssemblyText.encode("(module)");
```

## S-Expression Syntax

The implementation consumes a WebAssembly AST given in S-expression syntax. Here is an overview of the grammar of types, expressions, functions, and modules, mirroring what's described in the [design doc](https://github.com/WebAssembly/design/blob/main/Semantics.md).

Note: The grammar is shown here for convenience, the definite source is the [specification of the text format](https://webassembly.github.io/spec/core/text/).
```
num:    <digit>(_? <digit>)*
hexnum: <hexdigit>(_? <hexdigit>)*
nat:    <num> | 0x<hexnum>
int:    <nat> | +<nat> | -<nat>
float:  <num>.<num>?(e|E <num>)? | 0x<hexnum>.<hexnum>?(p|P <num>)?
name:   $(<letter> | <digit> | _ | . | + | - | * | / | \ | ^ | ~ | = | < | > | ! | ? | @ | # | $ | % | & | | | : | ' | `)+
string: "(<char> | \n | \t | \\ | \' | \" | \<hex><hex> | \u{<hex>+})*"

num_type: i32 | i64 | f32 | f64
vec_type: v128
vec_shape: i8x16 | i16x8 | i32x4 | i64x2 | f32x4 | f64x2 | v128
ref_kind: func | extern
ref_type: funcref | externref
val_type: <num_type> | <vec_type> | <ref_type>
block_type : ( result <val_type>* )*
func_type:   ( type <var> )? <param>* <result>*
global_type: <val_type> | ( mut <val_type> )
table_type:  <nat> <nat>? <ref_type>
memory_type: <nat> <nat>?

num: <int> | <float>
var: <nat> | <name>

unop:  ctz | clz | popcnt | ...
binop: add | sub | mul | ...
testop: eqz
relop: eq | ne | lt | ...
sign:  s | u
offset: offset=<nat>
align: align=(1|2|4|8|...)
cvtop: trunc | extend | wrap | ...

vecunop: abs | neg | ...
vecbinop: add | sub | min_<sign> | ...
vecternop: bitselect
vectestop: all_true | any_true
vecrelop: eq | ne | lt | ...
veccvtop: extend_low | extend_high | trunc_sat | ...
vecshiftop: shl | shr_<sign>

expr:
  ( <op> )
  ( <op> <expr>+ )                                                   ;; = <expr>+ (<op>)
  ( block <name>? <block_type> <instr>* )
  ( loop <name>? <block_type> <instr>* )
  ( if <name>? <block_type> ( then <instr>* ) ( else <instr>* )? )
  ( if <name>? <block_type> <expr>+ ( then <instr>* ) ( else <instr>* )? ) ;; = <expr>+ (if <name>? <block_type> (then <instr>*) (else <instr>*)?)

instr:
  <expr>
  <op>                                                               ;; = (<op>)
  block <name>? <block_type> <instr>* end <name>?                    ;; = (block <name>? <block_type> <instr>*)
  loop <name>? <block_type> <instr>* end <name>?                     ;; = (loop <name>? <block_type> <instr>*)
  if <name>? <block_type> <instr>* end <name>?                       ;; = (if <name>? <block_type> (then <instr>*))
  if <name>? <block_type> <instr>* else <name>? <instr>* end <name>? ;; = (if <name>? <block_type> (then <instr>*) (else <instr>*))

op:
  unreachable
  nop
  br <var>
  br_if <var>
  br_table <var>+
  return
  call <var>
  call_indirect <var>? <func_type>
  drop
  select
  local.get <var>
  local.set <var>
  local.tee <var>
  global.get <var>
  global.set <var>
  table.get <var>?
  table.set <var>?
  table.size <var>?
  table.grow <var>?
  table.fill <var>?
  table.copy <var>? <var>?
  table.init <var>? <var>
  elem.drop <var>
  <num_type>.load((8|16|32)_<sign>)? <offset>? <align>?
  <num_type>.store(8|16|32)? <offset>? <align>?
  <vec_type>.load((8x8|16x4|32x2)_<sign>)? <offset>? <align>?
  <vec_type>.store <offset>? <align>?
  <vec_type>.load(8|16|32|64)_(lane|splat|zero) <offset>? <align>?
  <vec_type>.store(8|16|32|64)_lane <offset>? <align>?
  memory.size
  memory.grow
  memory.fill
  memory.copy
  memory.init <var>
  data.drop <var>
  ref.null <ref_kind>
  ref.is_null <ref_kind>
  ref.func <var>
  <num_type>.const <num>
  <num_type>.<unop>
  <num_type>.<binop>
  <num_type>.<testop>
  <num_type>.<relop>
  <num_type>.<cvtop>_<num_type>(_<sign>)?
  <vec_type>.const <vec_shape> <num>+
  <vec_shape>.<vecunop>
  <vec_shape>.<vecbinop>
  <vec_shape>.<vecternop>
  <vec_shape>.<vectestop>
  <vec_shape>.<vecrelop>
  <vec_shape>.<veccvtop>_<vec_shape>(_<sign>)?(_<zero>)?
  <vec_shape>.<vecshiftop>
  <vec_shape>.bitmask
  <vec_shape>.splat
  <vec_shape>.extract_lane(_<sign>)? <nat>
  <vec_shape>.replace_lane <nat>

func:    ( func <name>? <func_type> <local>* <instr>* )
         ( func <name>? ( export <string> ) <...> )                         ;; = (export <string> (func <N>)) (func <name>? <...>)
         ( func <name>? ( import <string> <string> ) <func_type>)           ;; = (import <string> <string> (func <name>? <func_type>))
param:   ( param <val_type>* ) | ( param <name> <val_type> )
result:  ( result <val_type>* )
local:   ( local <val_type>* ) | ( local <name> <val_type> )

global:  ( global <name>? <global_type> <instr>* )
         ( global <name>? ( export <string> ) <...> )                       ;; = (export <string> (global <N>)) (global <name>? <...>)
         ( global <name>? ( import <string> <string> ) <global_type> )      ;; = (import <string> <string> (global <name>? <global_type>))
table:   ( table <name>? <table_type> )
         ( table <name>? ( export <string> ) <...> )                        ;; = (export <string> (table <N>)) (table <name>? <...>)
         ( table <name>? ( import <string> <string> ) <table_type> )        ;; = (import <string> <string> (table <name>? <table_type>))
         ( table <name>? ( export <string> )* <ref_type> ( elem <var>* ) )  ;; = (table <name>? ( export <string> )* <size> <size> <ref_type>) (elem (i32.const 0) <var>*)
elem:    ( elem <var>? (offset <instr>* ) <var>* )
         ( elem <var>? <expr> <var>* )                                      ;; = (elem <var>? (offset <expr>) <var>*)
         ( elem <var>? declare <ref_type> <var>* )
elem:    ( elem <name>? ( table <var> )? <offset> <ref_type> <item>* )
         ( elem <name>? ( table <var> )? <offset> func <var>* )             ;; = (elem <name>? ( table <var> )? <offset> funcref (ref.func <var>)*)
         ( elem <var>? declare? <ref_type> <var>* )
         ( elem <name>? declare? func <var>* )                               ;; = (elem <name>? declare? funcref (ref.func <var>)*)
offset:  ( offset <instr>* )
         <expr>                                                             ;; = ( offset <expr> )
item:    ( item <instr>* )
         <expr>                                                             ;; = ( item <expr> )
memory:  ( memory <name>? <memory_type> )
         ( memory <name>? ( export <string> ) <...> )                       ;; = (export <string> (memory <N>))+ (memory <name>? <...>)
         ( memory <name>? ( import <string> <string> ) <memory_type> )      ;; = (import <string> <string> (memory <name>? <memory_type>))
         ( memory <name>? ( export <string> )* ( data <string>* ) )         ;; = (memory <name>? ( export <string> )* <size> <size>) (data (i32.const 0) <string>*)
data:    ( data <name>? ( memory <var> )? <offset> <string>* )

start:   ( start <var> )

typedef: ( type <name>? ( func <param>* <result>* ) )

import:  ( import <string> <string> <imkind> )
imkind:  ( func <name>? <func_type> )
         ( global <name>? <global_type> )
         ( table <name>? <table_type> )
         ( memory <name>? <memory_type> )
export:  ( export <string> <exkind> )
exkind:  ( func <var> )
         ( global <var> )
         ( table <var> )
         ( memory <var> )

module:  ( module <name>? <typedef>* <func>* <import>* <export>* <table>* <memory>? <global>* <elem>* <data>* <start>? )
         <typedef>* <func>* <import>* <export>* <table>* <memory>? <global>* <elem>* <data>* <start>?  ;; =
         ( module <typedef>* <func>* <import>* <export>* <table>* <memory>? <global>* <elem>* <data>* <start>? )
```

Here, productions marked with respective comments are abbreviation forms for equivalent expansions (see the explanation of the AST below).
In particular, WebAssembly is a stack machine, so that all expressions of the form `(<op> <expr>+)` are merely abbreviations of a corresponding post-order sequence of instructions.
For raw instructions, the syntax allows omitting the parentheses around the operator name and its immediate operands. In the case of control operators (`block`, `loop`, `if`), this requires marking the end of the nested sequence with an explicit `end` keyword.

Any form of naming via `<name>` and `<var>` (including expression labels) is merely notational convenience of this text format. The actual AST has no names, and all bindings are referred to via ordered numeric indices; consequently, names are immediately resolved in the parser and replaced by indices. Indices can also be used directly in the text format.

The segment strings in the memory field are used to initialize the consecutive memory at the given offset.
The `<size>` in the expansion of the two short-hand forms for `table` and `memory` is the minimal size that can hold the segment: the number of `<var>`s for tables, and the accumulative length of the strings rounded up to page size for memories.

In addition to the grammar rules above, the fields of a module may appear in any order, except that all imports must occur before the first proper definition of a function, table, memory, or global.

Comments can be written in one of two ways:

```
comment:
  ;; <char>* <eol>
  (; (<char> | <comment>)* ;)
```

In particular, comments of the latter form nest properly.

## Scripts

In order to be able to check and run modules for testing purposes, the S-expression format is interpreted as a very simple and dumb notion of "script", with commands as follows:

```
script: <cmd>*

cmd:
  <module>                                   ;; define, validate, and initialize module
  ( register <string> <name>? )              ;; register module for imports
  <action>                                   ;; perform action and print results
  <assertion>                                ;; assert result of an action
  <meta>                                     ;; meta command

module:
  ...
  ( module <name>? binary <string>* )        ;; module in binary format (may be malformed)
  ( module <name>? quote <string>* )         ;; module quoted in text (may be malformed)

action:
  ( invoke <name>? <string> <const>* )       ;; invoke function export
  ( get <name>? <string> )                   ;; get global export

const:
  ( <num_type>.const <num> )                 ;; number value
  ( <vec_type> <vec_shape> <num>+ )          ;; vector value
  ( ref.null <ref_kind> )                    ;; null reference
  ( ref.extern <nat> )                       ;; host reference

assertion:
  ( assert_return <action> <result>* )       ;; assert action has expected results
  ( assert_trap <action> <failure> )         ;; assert action traps with given failure string
  ( assert_exhaustion <action> <failure> )   ;; assert action exhausts system resources
  ( assert_malformed <module> <failure> )    ;; assert module cannot be decoded with given failure string
  ( assert_invalid <module> <failure> )      ;; assert module is invalid with given failure string
  ( assert_unlinkable <module> <failure> )   ;; assert module fails to link
  ( assert_trap <module> <failure> )         ;; assert module traps on instantiation

result:
  <const>
  ( <num_type>.const <num_pat> )
  ( <vec_type>.const <vec_shape> <num_pat>+ )
  ( ref.extern )
  ( ref.func )

num_pat:
  <num>                                      ;; literal result
  nan:canonical                              ;; NaN in canonical form
  nan:arithmetic                             ;; NaN with 1 in MSB of payload

meta:
  ( script <name>? <script> )                ;; name a subscript
  ( input <name>? <string> )                 ;; read script or module from file
  ( output <name>? <string>? )               ;; output module to stout or file
```
Commands are executed in sequence. Commands taking an optional module name refer to the most recently defined module if no name is given. They are only possible after a module has been defined.

After a module is _registered_ under a string name it is available for importing in other modules.

The script format supports additional syntax for defining modules.
A module of the form `(module binary <string>*)` is given in binary form and will be decoded from the (concatenation of the) strings.
A module of the form `(module quote <string>*)` is given in textual form and will be parsed from the (concatenation of the) strings. In both cases, decoding/parsing happens when the command is executed, not when the script is parsed, so that meta commands like `assert_malformed` can be used to check expected errors.

There are also a number of meta commands.
The `script` command is a simple mechanism to name sub-scripts themselves. This is mainly useful for converting scripts with the `output` command. Commands inside a `script` will be executed normally, but nested meta are expanded in place (`input`, recursively) or elided (`output`) in the named script.

The `input` and `output` meta commands determine the requested file format from the file name extension. They can handle both `.wasm`, `.wat`, and `.wast` files. In the case of input, a `.wast` script will be recursively executed. Output additionally handles `.js` as a target, which will convert the referenced script to an equivalent, self-contained JavaScript runner. It also recognises `.bin.wast` specially, which creates a _binary script_ where module definitions are in binary, as defined below.

The interpreter supports a "dry" mode (flag `-d`), in which modules are only validated. In this mode, all actions and assertions are ignored.
It also supports an "unchecked" mode (flag `-u`), in which module definitions are not validated before use.

### Spectest host module

When running scripts, the interpreter predefines a simple host module named `"spectest"` that has the following module type:
```
(module
  (global (export "global_i32") i32)
  (global (export "global_i64") i64)
  (global (export "global_f32") f32)
  (global (export "global_f64") f64)

  (table (export "table") 10 20 funcref)

  (memory (export "memory") 1 2)

  (func (export "print"))
  (func (export "print_i32") (param i32))
  (func (export "print_i64") (param i64))
  (func (export "print_f32") (param f32))
  (func (export "print_f64") (param f64))
  (func (export "print_i32_f32") (param i32 f32))
  (func (export "print_f64_f64") (param f64 f64))
)
```
The `print` functions are assumed to print their respective argument values to stdout (followed by a newline) and can be used to produce observable output.

Note: This module predates the `register` command and should no longer be needed for new tests.
We might remove it in the future, so consider it deprecated.

### Binary Scripts

The grammar of binary scripts is a subset of the grammar for general scripts:
```
binscript: <cmd>*

cmd:
  <module>                                   ;; define, validate, and initialize module
  ( register <string> <name>? )              ;; register module for imports
  <action>                                   ;; perform action and print results
  <assertion>                                ;; assert result of an action

module:
  ( module <name>? binary <string>* )        ;; module in binary format (may be malformed)

action:
  ( invoke <name>? <string> <expr>* )        ;; invoke function export
  ( get <name>? <string> )                   ;; get global export

assertion:
  ( assert_return <action> <result>* )       ;; assert action has expected results
  ( assert_trap <action> <failure> )         ;; assert action traps with given failure string
  ( assert_exhaustion <action> <failure> )   ;; assert action exhausts system resources
  ( assert_malformed <module> <failure> )    ;; assert module cannot be decoded with given failure string
  ( assert_invalid <module> <failure> )      ;; assert module is invalid with given failure string
  ( assert_unlinkable <module> <failure> )   ;; assert module fails to link
  ( assert_trap <module> <failure> )         ;; assert module traps on instantiation

result:
  ( <num_type>.const <num_pat> )
  ( ref.extern )
  ( ref.func )

num_pat:
  <value>                                    ;; literal result
  nan:canonical                              ;; NaN in canonical form
  nan:arithmetic                             ;; NaN with 1 in MSB of payload

value:  <int> | <float>
int:    0x<hexnum>
float:  0x<hexnum>.<hexnum>?(p|P <num>)?
hexnum: <hexdigit>(_? <hexdigit>)*

name:   $(<letter> | <digit> | _ | . | + | - | * | / | \ | ^ | ~ | = | < | > | ! | ? | @ | # | $ | % | & | | | : | ' | `)+
string: "(<char> | \n | \t | \\ | \' | \" | \<hex><hex> | \u{<hex>+})*"
```
This grammar removes meta commands, textual and quoted modules.
All numbers are in hex notation.

Moreover, float values are required to be precise, that is, they may not contain bits that would lead to rounding.

## Abstract Syntax

The abstract WebAssembly syntax, as described above and in the [design doc](https://github.com/WebAssembly/design/blob/main/Semantics.md), is defined in [ast.ml](syntax/ast.ml).

However, to simplify the implementation, this AST representation represents some of the inner structure of the operators more explicitly. The mapping from the operators as given in the design doc to their structured form is defined in [operators.ml](syntax/operators.ml).

## Implementation

The implementation is split into several directories:

* `syntax`: the definition of abstract syntax; corresponds to the "Structure" section of the language specification

* `valid`: validation of code and modules; corresponds to the "Validation" section of the language specification

* `runtime`: the definition of runtime structures; corresponds to the "Execution/Runtime" section of the language specification

* `exec`: execution and module instantiation; corresponds to the "Execution" section of the language specification

* `binary`: encoding and decoding of the binary format; corresponds to the "Binary Format" section of the language specification

* `text`: parsing and printing the S-expressions text format; corresponds to the "Text Format" section of the language specification

* `script`: abstract syntax and execution of the extended script language

* `host`: definition of host environment modules

* `main`: main program

* `util`: utility libraries.

The implementation consists of the following parts:

* *Abstract Syntax* (`ast.ml`, `operators.ml`, `types.ml`, `source.ml[i]`, `script.ml`). Notably, the `phrase` wrapper type around each AST node carries the source position information.

* *Parser* (`lexer.mll`, `parser.mly`, `parse.ml[i]`). Generated with ocamllex and ocamlyacc. The lexer does the opcode encoding (non-trivial tokens carry e.g. type information as semantic values, as declared in `parser.mly`), the parser the actual S-expression parsing.

* *Pretty Printer* (`print.ml[i]`, `arrange.ml[i]`, `sexpr.ml[i]`). Turns a module or script AST back into the textual S-expression format.

* *Decoder*/*Encoder* (`decode.ml[i]`, `encode.ml[i]`). The former parses the binary format and turns it into an AST, the latter does the inverse.

* *Validator* (`valid.ml[i]`). Does a recursive walk of the AST, passing down the *expected* type for expressions, and checking each expression against that. An expected empty type can be matched by any result, corresponding to implicit dropping of unused values (e.g. in a block).

* *Evaluator* (`eval.ml[i]`, `values.ml`, `func.ml[i]`, `table.ml[i]`, `memory.ml[i]`, `global.ml[i]`, `instance.ml`, `eval_numeric.ml[i]`, `int.ml`, `float.ml`, and a few more). Implements evaluation as a small-step semantics that rewrites a program one computation step at a time.

* *JS Generator* (`js.ml[i]`). Converts a script to equivalent JavaScript.

* *Driver* (`main.ml`, `run.ml[i]`, `import.ml[i]`, `error.ml`, `flags.ml`). Executes scripts, reports results or errors, etc.

The most relevant pieces are probably the validator (`valid.ml`) and the evaluator (`eval.ml`). They are written to look as much like a "specification" as possible. Hopefully, the code is fairly self-explanatory, at least for those with a passing familiarity with functional programming.

In typical FP convention (and for better readability), the code tends to use single-character names for local variables where consistent naming conventions are applicable (e.g., `e` for expressions, `v` for values, `xs` for lists of `x`s, etc.). See `ast.ml`, `eval.ml` and `eval.ml` for more comments.

'''
'''--- interpreter/winmake.bat ---
rem Auto-generated from Makefile!
set NAME=wasm
if '%1' neq '' set NAME=%1
ocamlc.opt -c -w +a-3-4-27-42-44-45 -warn-error +a -I exec -I main -I syntax -I text -I binary -I script -I runtime -I util -I host -I valid -o exec/numeric_error.cmo exec/numeric_error.ml
ocamlc.opt -c -w +a-3-4-27-42-44-45 -warn-error +a -I exec -I main -I syntax -I text -I binary -I script -I runtime -I util -I host -I valid -o exec/int.cmo exec/int.ml
ocamlc.opt -c -w +a-3-4-27-42-44-45 -warn-error +a -I util -I main -I syntax -I text -I binary -I exec -I script -I runtime -I host -I valid -o util/lib.cmi util/lib.mli
ocamlc.opt -c -w +a-3-4-27-42-44-45 -warn-error +a -I exec -I main -I syntax -I text -I binary -I script -I runtime -I util -I host -I valid -o exec/i32.cmo exec/i32.ml
ocamlc.opt -c -w +a-3-4-27-42-44-45 -warn-error +a -I exec -I main -I syntax -I text -I binary -I script -I runtime -I util -I host -I valid -o exec/float.cmo exec/float.ml
ocamlc.opt -c -w +a-3-4-27-42-44-45 -warn-error +a -I syntax -I main -I text -I binary -I exec -I script -I runtime -I util -I host -I valid -o syntax/types.cmo syntax/types.ml
ocamlc.opt -c -w +a-3-4-27-42-44-45 -warn-error +a -I exec -I main -I syntax -I text -I binary -I script -I runtime -I util -I host -I valid -o exec/f32.cmo exec/f32.ml
ocamlc.opt -c -w +a-3-4-27-42-44-45 -warn-error +a -I exec -I main -I syntax -I text -I binary -I script -I runtime -I util -I host -I valid -o exec/f64.cmo exec/f64.ml
ocamlc.opt -c -w +a-3-4-27-42-44-45 -warn-error +a -I exec -I main -I syntax -I text -I binary -I script -I runtime -I util -I host -I valid -o exec/i64.cmo exec/i64.ml
ocamlc.opt -c -w +a-3-4-27-42-44-45 -warn-error +a -I syntax -I main -I text -I binary -I exec -I script -I runtime -I util -I host -I valid -o syntax/values.cmo syntax/values.ml
ocamlc.opt -c -w +a-3-4-27-42-44-45 -warn-error +a -I runtime -I main -I syntax -I text -I binary -I exec -I script -I util -I host -I valid -o runtime/memory.cmi runtime/memory.mli
ocamlc.opt -c -w +a-3-4-27-42-44-45 -warn-error +a -I util -I main -I syntax -I text -I binary -I exec -I script -I runtime -I host -I valid -o util/source.cmi util/source.mli
ocamlc.opt -c -w +a-3-4-27-42-44-45 -warn-error +a -I syntax -I main -I text -I binary -I exec -I script -I runtime -I util -I host -I valid -o syntax/ast.cmo syntax/ast.ml
ocamlc.opt -c -w +a-3-4-27-42-44-45 -warn-error +a -I runtime -I main -I syntax -I text -I binary -I exec -I script -I util -I host -I valid -o runtime/func.cmi runtime/func.mli
ocamlc.opt -c -w +a-3-4-27-42-44-45 -warn-error +a -I runtime -I main -I syntax -I text -I binary -I exec -I script -I util -I host -I valid -o runtime/global.cmi runtime/global.mli
ocamlc.opt -c -w +a-3-4-27-42-44-45 -warn-error +a -I runtime -I main -I syntax -I text -I binary -I exec -I script -I util -I host -I valid -o runtime/table.cmi runtime/table.mli
ocamlc.opt -c -w +a-3-4-27-42-44-45 -warn-error +a -I runtime -I main -I syntax -I text -I binary -I exec -I script -I util -I host -I valid -o runtime/instance.cmo runtime/instance.ml
ocamlc.opt -c -w +a-3-4-27-42-44-45 -warn-error +a -I exec -I main -I syntax -I text -I binary -I script -I runtime -I util -I host -I valid -o exec/eval.cmi exec/eval.mli
ocamlc.opt -c -w +a-3-4-27-42-44-45 -warn-error +a -I binary -I main -I syntax -I text -I exec -I script -I runtime -I util -I host -I valid -o binary/utf8.cmi binary/utf8.mli
ocamlc.opt -c -w +a-3-4-27-42-44-45 -warn-error +a -I host -I main -I syntax -I text -I binary -I exec -I script -I runtime -I util -I valid -o host/env.cmo host/env.ml
ocamlc.opt -c -w +a-3-4-27-42-44-45 -warn-error +a -I main -I syntax -I text -I binary -I exec -I script -I runtime -I util -I host -I valid -o main/flags.cmo main/flags.ml
ocamlc.opt -c -w +a-3-4-27-42-44-45 -warn-error +a -I script -I main -I syntax -I text -I binary -I exec -I runtime -I util -I host -I valid -o script/import.cmi script/import.mli
ocamlc.opt -c -w +a-3-4-27-42-44-45 -warn-error +a -I script -I main -I syntax -I text -I binary -I exec -I runtime -I util -I host -I valid -o script/run.cmi script/run.mli
ocamlc.opt -c -w +a-3-4-27-42-44-45 -warn-error +a -I host -I main -I syntax -I text -I binary -I exec -I script -I runtime -I util -I valid -o host/spectest.cmo host/spectest.ml
ocamlc.opt -c -w +a-3-4-27-42-44-45 -warn-error +a -I main -I syntax -I text -I binary -I exec -I script -I runtime -I util -I host -I valid -o main/main.cmo main/main.ml
ocamlc.opt -c -w +a-3-4-27-42-44-45 -warn-error +a -I util -I main -I syntax -I text -I binary -I exec -I script -I runtime -I host -I valid -o util/error.cmi util/error.mli
ocamlc.opt -c -w +a-3-4-27-42-44-45 -warn-error +a -I script -I main -I syntax -I text -I binary -I exec -I runtime -I util -I host -I valid -o script/script.cmo script/script.ml
ocamlc.opt -c -w +a-3-4-27-42-44-45 -warn-error +a -I binary -I main -I syntax -I text -I exec -I script -I runtime -I util -I host -I valid -o binary/decode.cmi binary/decode.mli
ocamlc.opt -c -w +a-3-4-27-42-44-45 -warn-error +a -I binary -I main -I syntax -I text -I exec -I script -I runtime -I util -I host -I valid -o binary/encode.cmi binary/encode.mli
ocamlc.opt -c -w +a-3-4-27-42-44-45 -warn-error +a -I script -I main -I syntax -I text -I binary -I exec -I runtime -I util -I host -I valid -o script/js.cmi script/js.mli
ocamlc.opt -c -w +a-3-4-27-42-44-45 -warn-error +a -I text -I main -I syntax -I binary -I exec -I script -I runtime -I util -I host -I valid -o text/parse.cmi text/parse.mli
ocamlc.opt -c -w +a-3-4-27-42-44-45 -warn-error +a -I text -I main -I syntax -I binary -I exec -I script -I runtime -I util -I host -I valid -o text/print.cmi text/print.mli
ocamlc.opt -c -w +a-3-4-27-42-44-45 -warn-error +a -I valid -I main -I syntax -I text -I binary -I exec -I script -I runtime -I util -I host -o valid/valid.cmi valid/valid.mli
ocamlc.opt -c -w +a-3-4-27-42-44-45 -warn-error +a -I script -I main -I syntax -I text -I binary -I exec -I runtime -I util -I host -I valid -o script/import.cmo script/import.ml
ocamlc.opt -c -w +a-3-4-27-42-44-45 -warn-error +a -I script -I main -I syntax -I text -I binary -I exec -I runtime -I util -I host -I valid -o script/run.cmo script/run.ml
ocamlc.opt -c -w +a-3-4-27-42-44-45 -warn-error +a -I binary -I main -I syntax -I text -I exec -I script -I runtime -I util -I host -I valid -o binary/utf8.cmo binary/utf8.ml
ocamlc.opt -c -w +a-3-4-27-42-44-45 -warn-error +a -I exec -I main -I syntax -I text -I binary -I script -I runtime -I util -I host -I valid -o exec/eval_numeric.cmi exec/eval_numeric.mli
ocamlc.opt -c -w +a-3-4-27-42-44-45 -warn-error +a -I exec -I main -I syntax -I text -I binary -I script -I runtime -I util -I host -I valid -o exec/i64_convert.cmi exec/i64_convert.mli
ocamlc.opt -c -w +a-3-4-27-42-44-45 -warn-error +a -I exec -I main -I syntax -I text -I binary -I script -I runtime -I util -I host -I valid -o exec/eval.cmo exec/eval.ml
ocamlc.opt -c -w +a-3-4-27-42-44-45 -warn-error +a -I runtime -I main -I syntax -I text -I binary -I exec -I script -I util -I host -I valid -o runtime/func.cmo runtime/func.ml
ocamlc.opt -c -w +a-3-4-27-42-44-45 -warn-error +a -I util -I main -I syntax -I text -I binary -I exec -I script -I runtime -I host -I valid -o util/source.cmo util/source.ml
ocamlc.opt -c -w +a-3-4-27-42-44-45 -warn-error +a -I exec -I main -I syntax -I text -I binary -I script -I runtime -I util -I host -I valid -o exec/f32_convert.cmi exec/f32_convert.mli
ocamlc.opt -c -w +a-3-4-27-42-44-45 -warn-error +a -I exec -I main -I syntax -I text -I binary -I script -I runtime -I util -I host -I valid -o exec/f64_convert.cmi exec/f64_convert.mli
ocamlc.opt -c -w +a-3-4-27-42-44-45 -warn-error +a -I exec -I main -I syntax -I text -I binary -I script -I runtime -I util -I host -I valid -o exec/i32_convert.cmi exec/i32_convert.mli
ocamlc.opt -c -w +a-3-4-27-42-44-45 -warn-error +a -I util -I main -I syntax -I text -I binary -I exec -I script -I runtime -I host -I valid -o util/error.cmo util/error.ml
ocamlc.opt -c -w +a-3-4-27-42-44-45 -warn-error +a -I exec -I main -I syntax -I text -I binary -I script -I runtime -I util -I host -I valid -o exec/eval_numeric.cmo exec/eval_numeric.ml
ocamlc.opt -c -w +a-3-4-27-42-44-45 -warn-error +a -I runtime -I main -I syntax -I text -I binary -I exec -I script -I util -I host -I valid -o runtime/global.cmo runtime/global.ml
ocamlc.opt -c -w +a-3-4-27-42-44-45 -warn-error +a -I exec -I main -I syntax -I text -I binary -I script -I runtime -I util -I host -I valid -o exec/i64_convert.cmo exec/i64_convert.ml
ocamlc.opt -c -w +a-3-4-27-42-44-45 -warn-error +a -I util -I main -I syntax -I text -I binary -I exec -I script -I runtime -I host -I valid -o util/lib.cmo util/lib.ml
ocamlc.opt -c -w +a-3-4-27-42-44-45 -warn-error +a -I runtime -I main -I syntax -I text -I binary -I exec -I script -I util -I host -I valid -o runtime/memory.cmo runtime/memory.ml
ocamlc.opt -c -w +a-3-4-27-42-44-45 -warn-error +a -I runtime -I main -I syntax -I text -I binary -I exec -I script -I util -I host -I valid -o runtime/table.cmo runtime/table.ml
ocamlc.opt -c -w +a-3-4-27-42-44-45 -warn-error +a -I exec -I main -I syntax -I text -I binary -I script -I runtime -I util -I host -I valid -o exec/f32_convert.cmo exec/f32_convert.ml
ocamlc.opt -c -w +a-3-4-27-42-44-45 -warn-error +a -I exec -I main -I syntax -I text -I binary -I script -I runtime -I util -I host -I valid -o exec/f64_convert.cmo exec/f64_convert.ml
ocamlc.opt -c -w +a-3-4-27-42-44-45 -warn-error +a -I exec -I main -I syntax -I text -I binary -I script -I runtime -I util -I host -I valid -o exec/i32_convert.cmo exec/i32_convert.ml
ocamlc.opt -c -w +a-3-4-27-42-44-45 -warn-error +a -I syntax -I main -I text -I binary -I exec -I script -I runtime -I util -I host -I valid -o syntax/operators.cmo syntax/operators.ml
ocamlyacc text/parser.mly
ocamlc.opt -c -w +a-3-4-27-42-44-45 -warn-error +a -I text -I main -I syntax -I binary -I exec -I script -I runtime -I util -I host -I valid -o text/parser.cmi text/parser.mli
ocamlc.opt -c -w +a-3-4-27-42-44-45 -warn-error +a -I text -I main -I syntax -I binary -I exec -I script -I runtime -I util -I host -I valid -o text/lexer.cmi text/lexer.mli
ocamlc.opt -c -w +a-3-4-27-42-44-45 -warn-error +a -I util -I main -I syntax -I text -I binary -I exec -I script -I runtime -I host -I valid -o util/sexpr.cmi util/sexpr.mli
ocamlc.opt -c -w +a-3-4-27-42-44-45 -warn-error +a -I text -I main -I syntax -I binary -I exec -I script -I runtime -I util -I host -I valid -o text/arrange.cmi text/arrange.mli
ocamlc.opt -c -w +a-3-4-27-42-44-45 -warn-error +a -I binary -I main -I syntax -I text -I exec -I script -I runtime -I util -I host -I valid -o binary/decode.cmo binary/decode.ml
ocamlc.opt -c -w +a-3-4-27-42-44-45 -warn-error +a -I binary -I main -I syntax -I text -I exec -I script -I runtime -I util -I host -I valid -o binary/encode.cmo binary/encode.ml
ocamlc.opt -c -w +a-3-4-27-42-44-45 -warn-error +a -I script -I main -I syntax -I text -I binary -I exec -I runtime -I util -I host -I valid -o script/js.cmo script/js.ml
ocamlc.opt -c -w +a-3-4-27-42-44-45 -warn-error +a -I text -I main -I syntax -I binary -I exec -I script -I runtime -I util -I host -I valid -o text/parse.cmo text/parse.ml
ocamlc.opt -c -w +a-3-4-27-42-44-45 -warn-error +a -I text -I main -I syntax -I binary -I exec -I script -I runtime -I util -I host -I valid -o text/print.cmo text/print.ml
ocamlc.opt -c -w +a-3-4-27-42-44-45 -warn-error +a -I valid -I main -I syntax -I text -I binary -I exec -I script -I runtime -I util -I host -o valid/valid.cmo valid/valid.ml
ocamllex.opt -q text/lexer.mll
ocamlc.opt -c -w +a-3-4-27-42-44-45 -warn-error +a -I text -I main -I syntax -I binary -I exec -I script -I runtime -I util -I host -I valid -o text/lexer.cmo text/lexer.ml
ocamlc.opt -c -w +a-3-4-27-42-44-45 -warn-error +a -I text -I main -I syntax -I binary -I exec -I script -I runtime -I util -I host -I valid -o text/parser.cmo text/parser.ml
ocamlc.opt -c -w +a-3-4-27-42-44-45 -warn-error +a -I text -I main -I syntax -I binary -I exec -I script -I runtime -I util -I host -I valid -o text/arrange.cmo text/arrange.ml
ocamlc.opt -c -w +a-3-4-27-42-44-45 -warn-error +a -I util -I main -I syntax -I text -I binary -I exec -I script -I runtime -I host -I valid -o util/sexpr.cmo util/sexpr.ml
ocamlc.opt bigarray.cma -I util -I binary -I exec -I syntax -I runtime -I host -I main -I script -I text -I valid util/lib.cmo binary/utf8.cmo exec/float.cmo exec/f32.cmo exec/f64.cmo exec/numeric_error.cmo exec/int.cmo exec/i32.cmo exec/i64.cmo exec/i32_convert.cmo exec/f32_convert.cmo exec/i64_convert.cmo exec/f64_convert.cmo syntax/types.cmo syntax/values.cmo runtime/memory.cmo util/source.cmo syntax/ast.cmo exec/eval_numeric.cmo runtime/func.cmo runtime/global.cmo runtime/table.cmo runtime/instance.cmo util/error.cmo exec/eval.cmo host/env.cmo host/spectest.cmo main/flags.cmo script/import.cmo binary/encode.cmo syntax/operators.cmo binary/decode.cmo script/script.cmo text/parser.cmo text/lexer.cmo text/parse.cmo script/js.cmo util/sexpr.cmo text/arrange.cmo text/print.cmo valid/valid.cmo script/run.cmo main/main.cmo -o main/main.byte

'''
'''--- src/fuzzers/compare_to_spec.rs ---
use std::fmt::Write;
use std::path::PathBuf;

/// Finds all no-parameter exported functions
pub fn find_entry_points(contract: &[u8]) -> Vec<String> {
    let mut tys = Vec::new();
    let mut fns = Vec::new();
    let mut entries = Vec::new();
    for payload in wasmparser::Parser::default().parse_all(contract) {
        match payload {
            Ok(wasmparser::Payload::FunctionSection(rdr)) => fns.extend(rdr),
            Ok(wasmparser::Payload::TypeSection(rdr)) => tys.extend(rdr),
            Ok(wasmparser::Payload::ExportSection(rdr)) => {
                for export in rdr {
                    if let Ok(wasmparser::Export {
                        name,
                        kind: wasmparser::ExternalKind::Func,
                        index,
                    }) = export
                    {
                        if name.chars().any(|c| !c.is_ascii_alphanumeric()) {
                            continue; // ignore non-ascii-alnum exports for convenience
                        }
                        if let Some(&Ok(ty_index)) = fns.get(index as usize) {
                            if let Some(Ok(wasmparser::Type::Func(func_type))) =
                                tys.get(ty_index as usize)
                            {
                                if func_type.params().is_empty() {
                                    entries.push(name.to_string());
                                }
                            }
                        }
                    }
                }
            }
            _ => (),
        }
    }
    entries
}

#[derive(Debug, arbitrary::Arbitrary)]
struct ModuleConfig;
impl wasm_smith::Config for ModuleConfig {
    fn max_imports(&self) -> usize {
        0
    }
    fn max_instructions(&self) -> usize {
        1000
    }
    fn allow_start_export(&self) -> bool {
        false // traps in start are not caught properly
    }
}

#[derive(Debug)]
struct WasmSmithModule {
    data: Vec<u8>,
}

impl<'a> arbitrary::Arbitrary<'a> for WasmSmithModule {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        wasm_smith::ConfiguredModule::<ModuleConfig>::arbitrary(u).map(|m| Self {
            data: m.module.to_bytes(),
        })
    }
    fn arbitrary_take_rest(u: arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        wasm_smith::ConfiguredModule::<ModuleConfig>::arbitrary_take_rest(u).map(|m| Self {
            data: m.module.to_bytes(),
        })
    }
    fn size_hint(depth: usize) -> (usize, Option<usize>) {
        wasm_smith::ConfiguredModule::<ModuleConfig>::size_hint(depth)
    }
}

#[test]
fn fuzz() {
    bolero::check!()
        .with_arbitrary::<WasmSmithModule>()
        .for_each(|module| {
            let bytes = &module.data;
            let exports = find_entry_points(&bytes);

            if exports.is_empty() {
                // It’s pointless looking more into this test as we won’t be running anything anyway.
                return;
            }

            let mut wast_test = String::new();
            write!(wast_test, "(module binary \"").unwrap();
            for b in bytes.iter() {
                write!(wast_test, "\\{:02X}", b).unwrap();
            }
            write!(wast_test, "\")\n").unwrap();
            for e in exports {
                // `(invoke ...)` will be turned into `(just_run ...)` by the test framework after wast parsing.
                // XREF:INVOKE-FOR-JUST-RUN
                write!(wast_test, "(invoke {:?})\n", e).unwrap();
            }

            let mut f = tempfile::Builder::new()
                .prefix("fuzzed-module-")
                .tempfile()
                .expect("creating temp file");
            std::io::Write::write_all(&mut f, wast_test.as_bytes())
                .expect("writing wast test file");

            let mut t = crate::wast_tests::test::TestContext::new(
                "fuzz".to_owned(),
                f.path().to_owned(),
                PathBuf::from("/"),
                PathBuf::from("/tmp"),
                false,
            );
            t.run();
            if t.failed() {
                let _ = std::fs::write("/tmp/fuzz-crash.wasm", &bytes);
                let output = String::from_utf8_lossy(&t.output);
                eprintln!(
                    "Test failed, module available in /tmp/fuzz-crash.wasm.
Module bytes were:
{:?}
Wast test was:
{}
Test output:
{}",
                    bytes, wast_test, output,
                );
                panic!("{}", output.lines().collect::<Vec<_>>().join("; "));
            }
        })
}

'''
'''--- src/fuzzers/mod.rs ---
mod compare_to_spec;
mod validity_invariants;
mod validity_invariants_smith;

'''
'''--- src/fuzzers/validity_invariants.rs ---
use crate::{max_stack, prefix_sum_vec, wasmparser};

struct DefaultStackConfig;
impl max_stack::SizeConfig for DefaultStackConfig {
    fn size_of_value(&self, _ty: wasmparser::ValType) -> u8 {
        u8::MAX
    }

    fn size_of_function_activation(
        &self,
        _locals: &prefix_sum_vec::PrefixSumVec<wasmparser::ValType, u32>,
    ) -> u64 {
        u64::MAX / 128
    }
}

pub(crate) struct DefaultGasConfig;

macro_rules! gas_visit {
    (visit_end => $({ $($arg:ident: $argty:ty),* })?) => {};
    (visit_else => $({ $($arg:ident: $argty:ty),* })?) => {};
    ($visit:ident => $({ $($arg:ident: $argty:ty),* })?) => {
        fn $visit(&mut self $($(,$arg: $argty)*)?) -> Self::Output {
            u64::MAX / 128 // allow for 128 operations before an overflow would occur.
        }
    };

    ($( @$proposal:ident $op:ident $({ $($arg:ident: $argty:ty),* })? => $visit:ident)*) => {
        $(gas_visit!{ $visit => $({ $($arg: $argty),* })? })*
    }
}

impl<'a> wasmparser::VisitOperator<'a> for DefaultGasConfig {
    type Output = u64;
    fn visit_end(&mut self) -> u64 {
        0
    }
    fn visit_else(&mut self) -> u64 {
        0
    }
    wasmparser::for_each_operator!(gas_visit);
}

#[test]
fn fuzz() {
    bolero::check!()
        .with_arbitrary::<Vec<u8>>()
        .for_each(|module| {
            let data = &module;
            let features = wasmparser::WasmFeatures {
                exceptions: false,
                ..Default::default()
            };
            // First, try to validate the data.
            let is_valid = wasmparser::Validator::new_with_features(features)
                .validate_all(data)
                .is_ok();
            let analysis_results = crate::Analysis::new()
                .with_stack(DefaultStackConfig)
                .with_gas(DefaultGasConfig)
                .analyze(data);
            let analysis_results = match analysis_results {
                Ok(res) => res,
                Err(e) if is_valid => {
                    let _ = std::fs::write("/tmp/input.wasm", data);
                    panic!("valid module didn't analyze successfully: {:?}!", e)
                }
                Err(_) => return,
            };
            match analysis_results.instrument("spectest", data) {
                // If the original input was valid, we want the instrumented module to be valid too!
                Ok(res) if is_valid => {
                    if let Err(e) =
                        wasmparser::Validator::new_with_features(features).validate_all(&res)
                    {
                        let _ = std::fs::write("/tmp/input.wasm", data);
                        let _ = std::fs::write("/tmp/instrumented.wasm", res);
                        panic!(
                            "valid module is no longer valid post-instrumentation: {:?}",
                            e
                        );
                    }
                }
                // We're happy that things did not explode, but we also want to ensure that the module
                // remains invalid if it was invalid initially.
                Ok(_res) => {
                    // This unfortunately does not work right now. In particular we might have an input
                    // along the lines of:
                    //
                    // 0x0 | 00 61 73 6d | version 22 (Component)
                    //     | 16 00 01 00
                    //
                    // which becomes a
                    //
                    // 0x0 | 00 61 73 6d | version 1 (Module)
                    //     | 01 00 00 00
                    // 0x8 | 01 01       | type section
                    // 0xa | 00          | 0 count
                    // 0xb | 02 01       | import section
                    // 0xd | 00          | 0 count
                    //
                    // after the instrumentation. This is due to a few factors, one of which is that
                    // wasm_encoder does not allow us to directly write out the `Payload::Version`,
                    // unfortunately. At least as things are right now.
                    //
                    // if let Ok(_) = wasmparser::validate(&res) {
                    //     let _ = std::fs::write("/tmp/input.wasm", data);
                    //     let _ = std::fs::write("/tmp/instrumented.wasm", res);
                    //     panic!("invalid module after instrumentation has become valid");
                    // }
                }
                Err(e) if is_valid => {
                    let _ = std::fs::write("/tmp/input.wasm", data);
                    panic!("valid module didn't instrument successfully: {:?}!", e)
                }
                Err(_) => return,
            };
        });
}

'''
'''--- src/fuzzers/validity_invariants_smith.rs ---
use crate::{max_stack, prefix_sum_vec, wasmparser};

struct DefaultStackConfig;
impl max_stack::SizeConfig for DefaultStackConfig {
    fn size_of_value(&self, _ty: wasmparser::ValType) -> u8 {
        u8::MAX
    }

    fn size_of_function_activation(
        &self,
        _locals: &prefix_sum_vec::PrefixSumVec<wasmparser::ValType, u32>,
    ) -> u64 {
        u64::MAX / 128
    }
}

pub(crate) struct DefaultGasConfig;

macro_rules! gas_visit {
    (visit_end => $({ $($arg:ident: $argty:ty),* })?) => {};
    (visit_else => $({ $($arg:ident: $argty:ty),* })?) => {};
    ($visit:ident => $({ $($arg:ident: $argty:ty),* })?) => {
        fn $visit(&mut self $($(,$arg: $argty)*)?) -> Self::Output {
            u64::MAX / 128 // allow for 128 operations before an overflow would occur.
        }
    };

    ($( @$proposal:ident $op:ident $({ $($arg:ident: $argty:ty),* })? => $visit:ident)*) => {
        $(gas_visit!{ $visit => $({ $($arg: $argty),* })? })*
    }
}

impl<'a> wasmparser::VisitOperator<'a> for DefaultGasConfig {
    type Output = u64;
    fn visit_end(&mut self) -> u64 {
        0
    }
    fn visit_else(&mut self) -> u64 {
        0
    }
    wasmparser::for_each_operator!(gas_visit);
}

#[derive(Debug)]
struct WasmSmithModule {
    data: Vec<u8>,
}

impl<'a> arbitrary::Arbitrary<'a> for WasmSmithModule {
    fn arbitrary(u: &mut arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        wasm_smith::MaybeInvalidModule::arbitrary(u).map(|m| Self { data: m.to_bytes() })
    }
    fn arbitrary_take_rest(u: arbitrary::Unstructured<'a>) -> arbitrary::Result<Self> {
        wasm_smith::MaybeInvalidModule::arbitrary_take_rest(u).map(|m| Self { data: m.to_bytes() })
    }
    fn size_hint(depth: usize) -> (usize, Option<usize>) {
        wasm_smith::MaybeInvalidModule::size_hint(depth)
    }
}

#[test]
fn fuzz() {
    bolero::check!()
        .with_arbitrary::<WasmSmithModule>()
        .for_each(|module| {
            let data = &module.data;
            let features = wasmparser::WasmFeatures {
                exceptions: false,
                ..Default::default()
            };
            // First, try to validate the data.
            let is_valid = wasmparser::Validator::new_with_features(features)
                .validate_all(data)
                .is_ok();
            let analysis_results = crate::Analysis::new()
                .with_stack(DefaultStackConfig)
                .with_gas(DefaultGasConfig)
                .analyze(data);
            let analysis_results = match analysis_results {
                Ok(res) => res,
                Err(e) if is_valid => {
                    let _ = std::fs::write("/tmp/input.wasm", data);
                    panic!("valid module didn't analyze successfully: {:?}!", e)
                }
                Err(_) => return,
            };
            match analysis_results.instrument("spectest", data) {
                // If the original input was valid, we want the instrumented module to be valid too!
                Ok(res) if is_valid => {
                    if let Err(e) =
                        wasmparser::Validator::new_with_features(features).validate_all(&res)
                    {
                        let _ = std::fs::write("/tmp/input.wasm", data);
                        let _ = std::fs::write("/tmp/instrumented.wasm", res);
                        panic!(
                            "valid module is no longer valid post-instrumentation: {:?}",
                            e
                        );
                    }
                }
                // We're happy that things did not explode, but we also want to ensure that the module
                // remains invalid if it was invalid initially.
                Ok(_res) => {
                    // This unfortunately does not work right now. In particular we might have an input
                    // along the lines of:
                    //
                    // 0x0 | 00 61 73 6d | version 22 (Component)
                    //     | 16 00 01 00
                    //
                    // which becomes a
                    //
                    // 0x0 | 00 61 73 6d | version 1 (Module)
                    //     | 01 00 00 00
                    // 0x8 | 01 01       | type section
                    // 0xa | 00          | 0 count
                    // 0xb | 02 01       | import section
                    // 0xd | 00          | 0 count
                    //
                    // after the instrumentation. This is due to a few factors, one of which is that
                    // wasm_encoder does not allow us to directly write out the `Payload::Version`,
                    // unfortunately. At least as things are right now.
                    //
                    // if let Ok(_) = wasmparser::validate(&res) {
                    //     let _ = std::fs::write("/tmp/input.wasm", data);
                    //     let _ = std::fs::write("/tmp/instrumented.wasm", res);
                    //     panic!("invalid module after instrumentation has become valid");
                    // }
                }
                Err(e) if is_valid => {
                    let _ = std::fs::write("/tmp/input.wasm", data);
                    panic!("valid module didn't instrument successfully: {:?}!", e)
                }
                Err(_) => return,
            };
        });
}

'''
'''--- src/gas/config.rs ---
use crate::{gas, visitors};

use super::{BranchTargetKind, Frame};

/// The configuration for the gas analysis.
///
/// Note that this trait is not intended to be implemented directly. Implement
/// [`finite_wasm::wasmparser::VisitOperator`](crate::wasmparser::VisitOperator) with `type Output
/// = u64`, where each of the `visit_*` methods return a gas cost for the specific instrution being
/// visited. Implementers of such trait will also implement `gas::Config` by definition.
pub trait Config<'b> {
    type GasVisitor<'s>: visitors::VisitOperatorWithOffset<'b, Output = Result<(), gas::Error>>
    where
        Self: 's;

    fn make_visitor<'s>(&'s mut self, state: &'s mut gas::FunctionState) -> Self::GasVisitor<'s>;
    fn save_outcomes(
        &self,
        state: &mut gas::FunctionState,
        destination: &mut crate::AnalysisOutcome,
    );
}

impl<'b> Config<'b> for crate::NoConfig {
    type GasVisitor<'s> = visitors::NoOpVisitor<Result<(), gas::Error>>;
    fn make_visitor<'s>(&'s mut self, _: &'s mut gas::FunctionState) -> Self::GasVisitor<'s> {
        visitors::NoOpVisitor(Ok(()))
    }

    fn save_outcomes(&self, _: &mut gas::FunctionState, _: &mut crate::AnalysisOutcome) {}
}

impl<'b, V: wasmparser::VisitOperator<'b, Output = u64>> Config<'b> for V {
    type GasVisitor<'s> = gas::Visitor<'s, V> where Self: 's;
    fn make_visitor<'s>(&'s mut self, state: &'s mut gas::FunctionState) -> Self::GasVisitor<'s> {
        gas::Visitor {
            offset: 0,
            model: self,
            state,
        }
    }

    fn save_outcomes(&self, state: &mut gas::FunctionState, out: &mut crate::AnalysisOutcome) {
        state.optimize();
        out.gas_offsets.push(state.offsets.drain(..).collect());
        out.gas_kinds.push(state.kinds.drain(..).collect());
        out.gas_costs.push(state.costs.drain(..).collect());
        state.frame_stack.clear();
        state.current_frame = Frame {
            stack_polymorphic: false,
            kind: BranchTargetKind::UntakenForward,
        };
        state.scheduled_instrumentation = None;
    }
}

'''
'''--- src/gas/error.rs ---
#[derive(thiserror::Error, Debug, Clone)]
pub enum Error {
    #[error("branch depth is too large at offset {0}")]
    BranchDepthTooLarge(usize),
    #[error("could not parse the brtable targets")]
    ParseBrTable(#[source] wasmparser::BinaryReaderError),
    #[error("the branch target is invalid at offset {0}")]
    InvalidBrTarget(usize),
    #[error("the exceptions proposal is not supported (at offset {0})")]
    ExceptionsNotSupported(usize),
    #[error("the memory control proposal is not supported (at offset {0})")]
    MemoryControlNotSupported(usize),
    #[error("the garbage collection proposal is not supported (at offset {0})")]
    GcNotSupported(usize),
}

'''
'''--- src/gas/mod.rs ---
//! Analysis of the amount of time (gas) a function takes to execute.
//!
//! The gas analysis is a two-pass linear-time algorithm. This algorithm first constructs a table
//! containing instrumentation offsets (represented as instructions in the example below), their
//! costs and kinds:
//!
//! <pre>
//! | Instructions | Cost | Kind |
//! | ============ | ==== | ==== |
//! | i32.const 0  | 1    | Pure |
//! | i32.const 1  | 1    | Pure |
//! | i32.add      | 1    | Pure |
//! </pre>
//!
//! In this table the instructions with certain instrumentation kind combinations can then be
//! coalesced in order to reduce the number of gas instrumentation points. For example all
//! instrumentation can be merged together across all instructions considered `Pure` to produce a
//! table like this:
//!
//! <pre>
//! | Instructions                           | Cost | Kind |
//! | ====================================== | ==== | ==== |
//! | (i32.add (i32.const 0) (i32.const 1))  | 3    | Pure |
//! </pre>
//!
//! Instrumentation can then, instead of inserting a gas charge before each of the 3 instructions,
//! insert a charge of 3 gas before the entire sequence, all without any observable difference in
//! execution semantics.
//!
//! **Why two passes?** A short answer is – branching. As the algorithm goes through the function
//! code for the first time, it can mark certain instructions as being a branch or a branch target.
//! For example `end` in `block…end` can be either pure or a branch target. Table entries for the
//! instructions that participate in control flow cannot be merged together if an eventually
//! accurate gas count is desired.

use crate::instruction_categories as gen;
pub use config::Config;
pub use error::Error;
use wasmparser::{BlockType, BrTable, VisitOperator};

mod config;
mod error;
mod optimize;

/// The type of a particular instrumentation point (as denoted by its offset.)
#[derive(Clone, Copy, Debug)]
pub enum InstrumentationKind {
    /// This instrumentation point precedes an instruction that is largely uninteresting for the
    /// purposes of gas analysis, besides its inherent cost.
    ///
    /// These do not participate in branching, trapping or any other kind of data flow. Simple
    /// operations such as an addition or subtraction will typically fall under this kind.
    Pure,

    /// This instrumentation point is unreachable (usually because the stack is polymorphic at this
    /// point.)
    ///
    /// For example,
    ///
    /// ```wast
    /// block
    ///   br 0                                ;; the stack becomes polymorphic
    ///                                       ;; this instrumentation point is unreachable
    ///   i32.add (i32.const 0) (i32.const 1)
    ///                                       ;; this instrumentation point is still unreachable
    /// end
    ///                                       ;; this instrumentation point is reachable again
    /// ```
    Unreachable,

    /// This instrumentation point precedes a branch target, branch, side effect, potential trap or
    /// similar construct.
    ///
    /// As a result none of the succeeding instrumentation points may be merged up into this
    /// instrumentation point, as the gas may be observed by the instruction that is going to
    /// execute after this instruction.
    PreControlFlow,

    /// This instrumentation point succeeds a branch target, branch, side effect, potential trap or
    /// similar construct.
    ///
    /// As a result this instrumentation point may not be merged up into the preceding
    /// instrumentation points (but succeeding instrumentation points may still be merged into
    /// this).
    PostControlFlow,

    /// This instrumentation point is between two control flow instructions (see
    /// Pre/PostControlFlow).
    ///
    /// This is largely used as a bottom type in optimization, representing a case where no further
    /// optimizations involving this type can be made (important if optimization is run multiple
    /// times, for example.)
    BetweenControlFlow,

    /// This instrumentation point precedes an aggregate operation.
    ///
    /// Instructions such as `memory.fill` cause this categorization. The amount of work they do
    /// depends on the operands.
    ///
    // TODO: a variant for each such instruction may be warranted?
    Aggregate,
}

#[derive(Debug)]
pub(crate) enum BranchTargetKind {
    // A branch instruction in this frame branches backwards in the instruction stream to the
    // loop header. Instrumentation points for this loop instruction are before and after the
    // stored indices.
    Loop(usize, usize),
    // A branch instruction in this frame branches forwards, but no branch instruction doing so has
    // been encountered yet.
    //
    // If a frame is popped while in this state, the surrounding structure that created this frame
    // in the first place is dead code.
    //
    // For example, `block (BODY…) end` without any branches to the frame created by `block`, can
    // be replaced with just `BODY…`.
    UntakenForward,
    // There is a branch instruction within this frame that branches to the `End` (or `Else` in the
    // case of `if…else…end`) instruction.
    Forward,
}

#[derive(Debug)]
pub(crate) struct Frame {
    /// Is the operand stack for the remainder of this frame considered polymorphic?
    ///
    /// Once the stack becomes polymorphic, the only way for it to stop being polymorphic is to pop
    /// the frames within which the stack is polymorphic.
    ///
    /// Note, that unlike validation, for the purposes of this analysis stack polymorphism is
    /// somewhat more lax. For example, validation algorithm will readly reject a function like
    /// `(func (unreachable) (i64.const 0) (i32.add))`, because at the time `i32.add` is evaluated
    /// the stack is `[t* i64]`, which does not unify with `[i32 i32] -> [i32]` expected by
    /// `i32.add`, despite being polymorphic. For the purposes of this analysis we do not keep
    /// track of the stack contents to that level of detail – all we care about is whether the
    /// stack is polymorphic at all.
    ///
    /// Search for `stack-polymorphic` in the wasm-core specification for further description and
    /// the list of instructions that make the stack polymorphic.
    pub(crate) stack_polymorphic: bool,

    /// How does a branch instruction behaves when targetting this frame?
    pub(crate) kind: BranchTargetKind,
}

pub(crate) struct ScheduledInstrumentation {
    cost: u64,
    kind: InstrumentationKind,
}

/// The per-function state used by the [`Visitor`].
///
/// This type maintains the state accumulated during the analysis of a single function in a module.
/// If the same instance of this `FunctionState` is used to analyze multiple functions, it will
/// result in re-use of the backing allocations, and thus an improved performance.
pub struct FunctionState {
    /// Table of instruction ranges, and the total gas cost of executing the range.
    pub(crate) offsets: Vec<usize>,
    pub(crate) costs: Vec<u64>,
    pub(crate) kinds: Vec<InstrumentationKind>,

    /// Information about the analyzed function’s frame stack.
    pub(crate) frame_stack: Vec<Frame>,

    pub(crate) current_frame: Frame,

    /// Is there a charge we want to introduce "after" the current offset?
    ///
    /// Note that the implementation here depends on the fact that all instructions invoke
    /// `charge_before` or `charge_after`, even if with a 0-cost so that there is an opportunity to
    /// merge this cost into the table.
    pub(crate) scheduled_instrumentation: Option<ScheduledInstrumentation>,
}

impl FunctionState {
    /// Create a new state for the gas analysis.
    pub fn new() -> Self {
        Self {
            offsets: vec![],
            costs: vec![],
            kinds: vec![],
            frame_stack: vec![],
            current_frame: Frame {
                stack_polymorphic: false,
                kind: BranchTargetKind::UntakenForward,
            },
            scheduled_instrumentation: None,
        }
    }
}

/// The core algorihtm of the `gas` analysis.
pub struct Visitor<'s, CostModel> {
    pub(crate) offset: usize,

    /// A visitor that produces costs for instructions.
    pub(crate) model: &'s mut CostModel,

    /// Per-function visitor state.
    ///
    /// This state allocates data intermediate results during the function analysis and ultimately
    /// then drains it into summarized data. As thus, this state can be reused between functions
    /// for better performance.
    pub(crate) state: &'s mut FunctionState,
}

impl<'a, CostModel> Visitor<'a, CostModel> {
    /// Charge fees for a pure instruction.
    ///
    /// Pure instructions do not participate in control flow, have no side effects and execute in
    /// roughly a known amount of time (i.e. their execution time is largely independent of the
    /// inputs.)
    fn visit_pure_instruction(&mut self, cost: u64) {
        self.push_instrumentation_before(InstrumentationKind::Pure, cost)
    }

    /// Charge fees before executing a side-effectful instruction.
    ///
    /// Side effectful instructions are those that are known to execute in roughly a known amount
    /// of time, but may branch, call into a host function or execute some other side effect.
    /// Instructions that are potential branch targets are not applicable.
    fn visit_side_effect_instruction(&mut self, cost: u64) {
        self.push_instrumentation_before(InstrumentationKind::PreControlFlow, cost);
        self.push_instrumentation_after(InstrumentationKind::PostControlFlow, 0);
    }

    /// Charge fees before executing an aggregate instruction.
    ///
    /// Aggregate instructions are those, whose execution time is proportional to the amplitude or
    /// number of the inputs it consumes. These instructions may be side-effectful (see
    /// [`Self::visit_side_effect`].)
    fn visit_aggregate_instruction(&mut self, cost: u64) {
        self.push_instrumentation_before(InstrumentationKind::Aggregate, cost);
        self.push_instrumentation_after(InstrumentationKind::PostControlFlow, 0);
    }

    /// Charge some gas before the currently analyzed instruction.
    fn push_instrumentation_before(&mut self, kind: InstrumentationKind, cost: u64) {
        let kind = if self.state.current_frame.stack_polymorphic {
            InstrumentationKind::Unreachable
        } else {
            kind
        };
        self.state.offsets.push(self.offset);
        self.state.kinds.push(kind);
        self.state.costs.push(cost);
    }

    /// Charge some gas after the currently analyzed instruction.
    ///
    /// Note that this method works by enqueueing a charge to be added to the tables at a next call
    /// of the `charge_before` or `charge_after` function.
    fn push_instrumentation_after(&mut self, kind: InstrumentationKind, cost: u64) {
        assert!(self
            .state
            .scheduled_instrumentation
            .replace(ScheduledInstrumentation { cost, kind })
            .is_none());
    }

    /// Create a new frame on the frame stack.
    ///
    /// The caller is responsible for specifying how the branches behave when branched to this
    /// frame.
    fn new_frame(&mut self, kind: BranchTargetKind) {
        let stack_polymorphic = self.state.current_frame.stack_polymorphic;
        self.state.frame_stack.push(std::mem::replace(
            &mut self.state.current_frame,
            Frame {
                stack_polymorphic,
                kind,
            },
        ));
    }

    /// Terminate the current top-most frame on the frame stack.
    ///
    /// When there is only one frame remaining this becomes a no-op.
    fn end_frame(&mut self) {
        if let Some(frame) = self.state.frame_stack.pop() {
            self.state.current_frame = frame;
        }
    }

    /// Mark the current frame as polymorphic.
    fn make_polymorphic(&mut self) {
        self.state.current_frame.stack_polymorphic = true;
    }

    /// The index of the root frame (that is the one representing the function entry.)
    fn root_frame_index(&self) -> usize {
        // NB: this implicitly is 1-less than the number of frames due to us maintaining a
        // `current_frame` field.
        self.state.frame_stack.len()
    }

    fn frame_index(&self, relative_depth: u32) -> Result<usize, Error> {
        usize::try_from(relative_depth).map_err(|_| Error::BranchDepthTooLarge(self.offset))
    }

    fn adjust_branch_target(&mut self, frame_index: usize) -> Result<(), Error> {
        let frame = if let Some(frame_stack_index) = frame_index.checked_sub(1) {
            self.state
                .frame_stack
                .iter_mut()
                .nth_back(frame_stack_index)
                .ok_or(Error::InvalidBrTarget(self.offset))?
        } else {
            &mut self.state.current_frame
        };
        match frame.kind {
            BranchTargetKind::Forward => (),
            BranchTargetKind::UntakenForward => frame.kind = BranchTargetKind::Forward,
            BranchTargetKind::Loop(pre_index, post_index) => {
                self.state.kinds[post_index] = InstrumentationKind::PostControlFlow;
                self.state.kinds[pre_index] = InstrumentationKind::PreControlFlow;
            }
        }
        Ok(())
    }

    fn visit_conditional_branch(&mut self, frame_index: usize, cost: u64) -> Result<(), Error> {
        self.visit_side_effect_instruction(cost);
        self.adjust_branch_target(frame_index)?;
        Ok(())
    }

    fn visit_unconditional_branch(&mut self, frame_index: usize, cost: u64) -> Result<(), Error> {
        self.visit_conditional_branch(frame_index, cost)?;
        self.make_polymorphic();
        Ok(())
    }
}

macro_rules! trapping_insn {
    (fn $visit:ident( $($arg:ident: $ty:ty),* )) => {
        fn $visit(&mut self, $($arg: $ty),*) -> Self::Output {
            let cost = self.model.$visit($($arg),*);
            Ok(self.visit_side_effect_instruction(cost))
        }
    };
    ($($_t:ident .
        $(atomic.rmw)?
        $(atomic.cmpxchg)?
        $(load)?
        $(store)?
    = $($insn:ident)|* ;)*) => {
        $($(trapping_insn!(fn $insn(mem: wasmparser::MemArg));)*)*
    };
    ($($_t:ident . $(loadlane)? $(storelane)? = $($insn:ident)|* ;)*) => {
        $($(trapping_insn!(fn $insn(mem: wasmparser::MemArg, lane: u8));)*)*
    };
    ($($_t:ident . $(binop)? $(cvtop)? = $($insn:ident)|* ;)*) => {
        $($(trapping_insn!(fn $insn());)*)*
    };
}

macro_rules! pure_insn {
    (fn $visit:ident( $($arg:ident: $ty:ty),* )) => {
        fn $visit(&mut self, $($arg: $ty),*) -> Self::Output {
            let cost = self.model.$visit($($arg),*);
            Ok(self.visit_pure_instruction(cost))
        }
    };
    ($($_t:ident .
        // This sequence below "matches" any of these categories.
        $(unop)?
        $(binop)?
        $(cvtop)?
        $(relop)?
        $(testop)?
        $(vbitmask)?
        $(vinarrowop)?
        $(vrelop)?
        $(vternop)?
        $(vishiftop)?
        $(splat)?
    = $($insn:ident)|* ;)*) => {
        $($(pure_insn!(fn $insn());)*)*
    };
    ($($_t:ident . const = $($insn:ident, $param:ty)|* ;)*) => {
        $($(pure_insn!(fn $insn(val: $param));)*)*
    };
    ($($_t:ident . $(extractlane)? $(replacelane)? = $($insn:ident)|* ;)*) => {
        $($(pure_insn!(fn $insn(lane: u8));)*)*
    };
    ($($_t:ident . localsglobals = $($insn:ident)|* ;)*) => {
        $($(pure_insn!(fn $insn(index: u32));)*)*
    };
}

impl<'a, 'b, CostModel: VisitOperator<'b, Output = u64>> VisitOperator<'b>
    for Visitor<'a, CostModel>
{
    type Output = Result<(), Error>;

    gen::atomic_cmpxchg!(trapping_insn);
    gen::atomic_rmw!(trapping_insn);
    gen::load!(trapping_insn);
    gen::store!(trapping_insn);
    gen::loadlane!(trapping_insn);
    gen::storelane!(trapping_insn);
    gen::binop_partial!(trapping_insn);
    gen::cvtop_partial!(trapping_insn);

    // Functions can inspect the remaining gas, or initiate other side effects (e.g. trap) so
    // we must be conservative with its handling. Inlining is a transformation which would
    // allow us to be less conservative, but it will already have been done during the
    // compilation from the source language to wasm, or wasm-opt, most of the time.
    trapping_insn!(fn visit_call(index: u32));
    trapping_insn!(fn visit_call_ref(type_index: u32));
    trapping_insn!(fn visit_call_indirect(ty_index: u32, table_index: u32, table_byte: u8));
    // TODO: double check if these may actually trap
    trapping_insn!(fn visit_memory_atomic_notify(mem: wasmparser::MemArg));
    trapping_insn!(fn visit_memory_atomic_wait32(mem: wasmparser::MemArg));
    trapping_insn!(fn visit_memory_atomic_wait64(mem: wasmparser::MemArg));
    trapping_insn!(fn visit_table_set(table: u32));
    trapping_insn!(fn visit_table_get(table: u32));
    trapping_insn!(fn visit_ref_as_non_null());

    fn visit_unreachable(&mut self) -> Self::Output {
        let cost = self.model.visit_unreachable();
        self.push_instrumentation_before(InstrumentationKind::PreControlFlow, cost);
        self.push_instrumentation_after(InstrumentationKind::Unreachable, 0);
        self.make_polymorphic();
        Ok(())
    }

    gen::binop_complete!(pure_insn);
    gen::cvtop_complete!(pure_insn);
    gen::unop!(pure_insn);
    gen::relop!(pure_insn);
    gen::vrelop!(pure_insn);
    gen::vishiftop!(pure_insn);
    gen::vternop!(pure_insn);
    gen::vbitmask!(pure_insn);
    gen::vinarrowop!(pure_insn);
    gen::splat!(pure_insn);
    gen::r#const!(pure_insn);
    gen::extractlane!(pure_insn);
    gen::replacelane!(pure_insn);
    gen::testop!(pure_insn);

    pure_insn!(fn visit_ref_null(t: wasmparser::HeapType));
    pure_insn!(fn visit_ref_func(index: u32));
    pure_insn!(fn visit_i8x16_shuffle(pattern: [u8; 16]));
    pure_insn!(fn visit_atomic_fence());
    pure_insn!(fn visit_select());
    pure_insn!(fn visit_typed_select(t: wasmparser::ValType));
    pure_insn!(fn visit_drop());
    pure_insn!(fn visit_nop());
    pure_insn!(fn visit_table_size(table: u32));
    pure_insn!(fn visit_memory_size(mem: u32, idk: u8));
    pure_insn!(fn visit_global_set(global: u32));
    pure_insn!(fn visit_global_get(global: u32));
    pure_insn!(fn visit_local_set(local: u32));
    pure_insn!(fn visit_local_get(local: u32));
    pure_insn!(fn visit_local_tee(local: u32));

    fn visit_loop(&mut self, blockty: BlockType) -> Self::Output {
        let cost = self.model.visit_loop(blockty);
        // For the time being this instruction is not a branch target, and therefore is pure.
        // However, we must charge for it _after_ it has been executed, just in case it becomes a
        // branch target later. That's because as per the WebAssembly specification, the `loop`
        // instruction is executed on every iteration.
        let instrumentation_kind_index_pre = self.state.kinds.len();
        self.push_instrumentation_before(InstrumentationKind::Pure, 0);
        let instrumentation_kind_index_post = self.state.kinds.len();
        self.push_instrumentation_after(InstrumentationKind::Pure, cost);
        // This instruction will become a branch target if there is a branching instruction
        // targetting the frame created by this instruction. At that point we will make a point of
        // adjusting the instruction kind to a `InstrumentationKind::PostControlFlow`.
        self.new_frame(BranchTargetKind::Loop(
            instrumentation_kind_index_pre,
            instrumentation_kind_index_post,
        ));
        Ok(())
    }

    // Branch Target (for if, block, else), only if there is a `br`/`br_if`/`br_table` to exactly
    // the frame created by the matching insn.
    fn visit_end(&mut self) -> Self::Output {
        let cost = self.model.visit_end();
        assert!(
            cost == 0,
            "the `end` instruction costs aren’t handled right, set it to 0"
        );

        // TODO: this needs to note if this is a `if..end` or `if..else..end` branch. In the case
        // of the former, the code consuming analysis results needs to know to generate the `else`
        // branch and propagate the gas cost upwards to both branches.
        //
        // Fixing this would allow us to remove the `assert!` here and in the `visit_else`.
        //
        // Note that we cannot `charge_after` here because `end` is not "executed" when a branching
        // instruction within the frame is executed.
        match self.state.current_frame.kind {
            BranchTargetKind::Forward => self.visit_side_effect_instruction(cost),
            BranchTargetKind::Loop(_, _) => self.visit_pure_instruction(cost),
            BranchTargetKind::UntakenForward => self.visit_pure_instruction(cost),
        }
        self.end_frame();
        Ok(())
    }

    // Branch
    fn visit_if(&mut self, blockty: BlockType) -> Self::Output {
        let cost = self.model.visit_if(blockty);
        self.visit_side_effect_instruction(cost);
        // `if` is already a branch instruction, it can execute the instruction that follows (i.e.
        // acting just like a pure instruction), or it could jump to the `else` (or `end`)
        // instruction that terminates this frame.
        self.new_frame(BranchTargetKind::Forward);
        Ok(())
    }

    // Branch Target (unconditionally)
    fn visit_else(&mut self) -> Self::Output {
        let cost = self.model.visit_else();
        assert!(
            cost == 0,
            "the `else` instruction costs aren’t handled right, set it to 0"
        );
        // `else` is already a taken branch target from `if` (if the condition is false).
        self.end_frame();
        // `else` is both a branch and a branch target, depending on how it was reached.
        //
        // If `else` ends up being executed from the truthy body of the `if..else..end` block, then
        // this acts like an unconditional branch to the `end` instruction associated with this
        // frame.
        //
        // Whenever `if` condition is falsy, `else` is instead a branch target for the `if` to
        // branch to.
        self.new_frame(BranchTargetKind::Forward);
        self.visit_side_effect_instruction(cost);
        Ok(())
    }

    fn visit_block(&mut self, blockty: BlockType) -> Self::Output {
        let cost = self.model.visit_block(blockty);
        self.visit_pure_instruction(cost);
        self.new_frame(BranchTargetKind::UntakenForward);
        Ok(())
    }

    fn visit_br(&mut self, relative_depth: u32) -> Self::Output {
        let frame_idx = self.frame_index(relative_depth)?;
        let cost = self.model.visit_br(relative_depth);
        self.visit_unconditional_branch(frame_idx, cost)
    }

    fn visit_br_if(&mut self, relative_depth: u32) -> Self::Output {
        let frame_idx = self.frame_index(relative_depth)?;
        let cost = self.model.visit_br_if(relative_depth);
        self.visit_conditional_branch(frame_idx, cost)
    }

    fn visit_br_on_null(&mut self, relative_depth: u32) -> Self::Output {
        let frame_idx = self.frame_index(relative_depth)?;
        let cost = self.model.visit_br_on_null(relative_depth);
        self.visit_conditional_branch(frame_idx, cost)
    }

    fn visit_br_on_non_null(&mut self, relative_depth: u32) -> Self::Output {
        let frame_idx = self.frame_index(relative_depth)?;
        let cost = self.model.visit_br_on_non_null(relative_depth);
        self.visit_conditional_branch(frame_idx, cost)
    }

    fn visit_br_table(&mut self, targets: BrTable<'b>) -> Self::Output {
        let cost = self.model.visit_br_table(targets.clone());
        self.visit_side_effect_instruction(cost);
        for target in targets.targets() {
            let target = target.map_err(Error::ParseBrTable)?;
            self.adjust_branch_target(self.frame_index(target)?)?;
        }
        self.adjust_branch_target(self.frame_index(targets.default())?)?;
        self.make_polymorphic();
        Ok(())
    }

    fn visit_return(&mut self) -> Self::Output {
        let cost = self.model.visit_return();
        self.visit_unconditional_branch(self.root_frame_index(), cost)
    }

    fn visit_return_call(&mut self, function_index: u32) -> Self::Output {
        let cost = self.model.visit_return_call(function_index);
        self.visit_unconditional_branch(self.root_frame_index(), cost)
    }

    fn visit_return_call_ref(&mut self, type_index: u32) -> Self::Output {
        let cost = self.model.visit_return_call_ref(type_index);
        self.visit_unconditional_branch(self.root_frame_index(), cost)
    }

    fn visit_return_call_indirect(&mut self, type_index: u32, table_index: u32) -> Self::Output {
        let cost = self
            .model
            .visit_return_call_indirect(type_index, table_index);
        self.visit_unconditional_branch(self.root_frame_index(), cost)
    }

    fn visit_memory_grow(&mut self, mem: u32, mem_byte: u8) -> Self::Output {
        let cost = self.model.visit_memory_grow(mem, mem_byte);
        Ok(self.visit_aggregate_instruction(cost))
    }

    fn visit_memory_init(&mut self, data_index: u32, mem: u32) -> Self::Output {
        let cost = self.model.visit_memory_init(data_index, mem);
        Ok(self.visit_aggregate_instruction(cost))
    }

    fn visit_data_drop(&mut self, data_index: u32) -> Self::Output {
        // TODO: [] -> []; does not interact with the operand stack, so isn’t really an aggregate
        // instruction. In practice, though, it may involve non-trivial amount of work in the
        // runtime anyway? Validate.
        let cost = self.model.visit_data_drop(data_index);
        Ok(self.visit_pure_instruction(cost))
    }

    fn visit_memory_copy(&mut self, dst_mem: u32, src_mem: u32) -> Self::Output {
        let cost = self.model.visit_memory_copy(dst_mem, src_mem);
        Ok(self.visit_aggregate_instruction(cost))
    }

    fn visit_memory_fill(&mut self, mem: u32) -> Self::Output {
        let cost = self.model.visit_memory_fill(mem);
        Ok(self.visit_aggregate_instruction(cost))
    }

    fn visit_table_init(&mut self, elem_index: u32, table: u32) -> Self::Output {
        let cost = self.model.visit_table_init(elem_index, table);
        Ok(self.visit_aggregate_instruction(cost))
    }

    fn visit_elem_drop(&mut self, elem_index: u32) -> Self::Output {
        // TODO: [] -> []; does not interact with the operand stack, so isn’t really an aggregate
        // instruction. In practice, though, it may involve non-trivial amount of work in the
        // runtime anyway? Validate.
        let cost = self.model.visit_elem_drop(elem_index);
        Ok(self.visit_pure_instruction(cost))
    }

    fn visit_table_copy(&mut self, dst_table: u32, src_table: u32) -> Self::Output {
        let cost = self.model.visit_table_copy(dst_table, src_table);
        Ok(self.visit_aggregate_instruction(cost))
    }

    fn visit_table_fill(&mut self, table: u32) -> Self::Output {
        let cost = self.model.visit_table_fill(table);
        Ok(self.visit_aggregate_instruction(cost))
    }

    fn visit_table_grow(&mut self, table: u32) -> Self::Output {
        let cost = self.model.visit_table_grow(table);
        Ok(self.visit_aggregate_instruction(cost))
    }

    fn visit_try(&mut self, _: BlockType) -> Self::Output {
        Err(Error::ExceptionsNotSupported(self.offset))
    }

    fn visit_catch(&mut self, _: u32) -> Self::Output {
        Err(Error::ExceptionsNotSupported(self.offset))
    }

    fn visit_throw(&mut self, _: u32) -> Self::Output {
        Err(Error::ExceptionsNotSupported(self.offset))
    }

    fn visit_rethrow(&mut self, _: u32) -> Self::Output {
        Err(Error::ExceptionsNotSupported(self.offset))
    }

    fn visit_delegate(&mut self, _: u32) -> Self::Output {
        Err(Error::ExceptionsNotSupported(self.offset))
    }

    fn visit_catch_all(&mut self) -> Self::Output {
        Err(Error::ExceptionsNotSupported(self.offset))
    }

    fn visit_memory_discard(&mut self, _: u32) -> Self::Output {
        Err(Error::MemoryControlNotSupported(self.offset))
    }

    fn visit_i31_new(&mut self) -> Self::Output {
        Err(Error::GcNotSupported(self.offset))
    }

    fn visit_i31_get_s(&mut self) -> Self::Output {
        Err(Error::GcNotSupported(self.offset))
    }

    fn visit_i31_get_u(&mut self) -> Self::Output {
        Err(Error::GcNotSupported(self.offset))
    }
}

impl<'a, 'b, CostModel: VisitOperator<'b, Output = u64>>
    crate::visitors::VisitOperatorWithOffset<'b> for Visitor<'a, CostModel>
{
    fn set_offset(&mut self, offset: usize) {
        self.offset = offset;
        if let Some(scheduled) = self.state.scheduled_instrumentation.take() {
            self.state.offsets.push(self.offset);
            self.state.kinds.push(scheduled.kind);
            self.state.costs.push(scheduled.cost);
        }
    }
}

'''
'''--- src/gas/optimize.rs ---
//! Optimize the instrumentation tables to minimize number of instrumentation points.
//!
//! Each instrumentation point means slower execution as the VM needs to spend time executing gas
//! accounting instead of doing useful work. This module implements optimization of the instruction
//! tables produced by [`super::Visitor`] on a per-function basis.
//!
//! There are a few cases that we need to worry about:
//!
//! * There are multiple instrumentation points at the same offset.
//!
//!   This can happen when two side-effectful instructions follow each other. Tables then can end
//!   up with a situation like this:
//!
//!   ```text
//!   - PreSideEffect
//!   {side effect}
//!   - PostSideEffect
//!   - PreSideEffect
//!   {side effect}
//!   - PostSideEffect
//!   ```
//!
//!   The `PostSideEffect` and `PreSideEffect` that appear at the same offset can be merged
//!   together reducing the number of instrumentation points by one.
//!
//! * We can also sometimes merge multiple instrumentation points _across_ instructions that have
//!   certain properties. Of particular interest would be runs of pure instructions which have no
//!   observable side-effects. This means that however the execution proceeds, the user will not be
//!   able to observe if these instructions have executed or not.
//!
//!   That means we can move any gas instrumentation points within continuous runs of such pure
//!   instructions to the beginning of a block, charging gas only once.

use super::InstrumentationKind;

pub(crate) struct InstrumentationPoint {
    offset: usize,
    kind: InstrumentationKind,
    cost: u64,
}

impl InstrumentationKind {
    /// Instrumentation kind after merging two instrumentation points at the same offset.
    fn merge_same_point(self, other: Self) -> Option<Self> {
        use InstrumentationKind::*;
        // FIXME(#49): make this infallible to guarantee single instrumentation point per offset.
        Some(match (self, other) {
            (Unreachable, _) => Unreachable,
            (_, Unreachable) => Unreachable,
            (Aggregate, _) => return None,
            (_, Aggregate) => return None,
            (Pure, Pure | PreControlFlow | PostControlFlow | BetweenControlFlow) => other,
            (PreControlFlow, PreControlFlow | Pure) => PreControlFlow,
            (PreControlFlow, PostControlFlow | BetweenControlFlow) => BetweenControlFlow,
            (PostControlFlow, PostControlFlow | Pure) => PostControlFlow,
            (PostControlFlow, PreControlFlow | BetweenControlFlow) => BetweenControlFlow,
            (BetweenControlFlow, Pure | PreControlFlow | PostControlFlow | BetweenControlFlow) => {
                BetweenControlFlow
            }
        })
    }

    /// Instrumentation kind after merging two instrumentation ranges separaated by an instruction.
    fn merge_across_instructions(self, other: Self) -> Option<Self> {
        // Implementation note: this should pretty much never return a “weaker” kind than either of
        // the inputs. That is, merging `Pure` with any other kind should never return a `Pure`,
        // because that might make it possible to merge two kinds that otherwise would never be
        // mergeable.
        use InstrumentationKind::*;
        match (self, other) {
            // The changes to the remaining gas pool are not observable across a pure instruction.
            (Pure, Pure) => Some(Pure),
            // The unreachable code is never executed.
            (Unreachable, Unreachable) => Some(Unreachable),
            // Two control flow operators meet here.
            (PostControlFlow, PreControlFlow) => Some(BetweenControlFlow),
            // The next instruction is about to be a control-flow instruction. We can still merge
            // into this instrumentation point from a previous, pure instrumentation point.
            (Pure, PreControlFlow) => Some(PreControlFlow),
            // The previous instrumentation point comes after a control-flow instruction. The
            // current instruction is pure, though.
            (PostControlFlow, Pure) => Some(PostControlFlow),
            _ => None,
        }
    }
}

impl super::FunctionState {
    pub(crate) fn instrumentation_count(&self) -> usize {
        let Self {
            kinds,
            offsets,
            costs,
            ..
        } = self;
        debug_assert!(kinds.len() == offsets.len() && kinds.len() == costs.len());
        kinds.len()
    }

    pub(crate) fn instrumentation_at(&self, index: usize) -> Option<InstrumentationPoint> {
        Some(InstrumentationPoint {
            kind: *self.kinds.get(index)?,
            offset: *self.offsets.get(index)?,
            cost: *self.costs.get(index)?,
        })
    }

    pub(crate) fn set_instrumentation_point(&mut self, index: usize, point: InstrumentationPoint) {
        self.kinds[index] = point.kind;
        self.costs[index] = point.cost;
        self.offsets[index] = point.offset;
    }

    pub(crate) fn optimize_with(
        &mut self,
        merge_point: impl Fn(
            &InstrumentationPoint,
            &InstrumentationPoint,
        ) -> Option<InstrumentationPoint>,
    ) {
        // NB: If indexing turns out to be expensive for whatever reason, it could probably be
        // optimized by replacing indexing with pointer pairs.
        let mut output_idx = 0;
        let mut prev_point = match self.instrumentation_at(0) {
            Some(point) => point,
            None => return,
        };
        for input_idx in 1..self.instrumentation_count() {
            let current_point = self
                .instrumentation_at(input_idx)
                .expect("should always succeed");
            if let Some(merged_point) = merge_point(&prev_point, &current_point) {
                prev_point = merged_point;
            } else {
                self.set_instrumentation_point(output_idx, prev_point);
                prev_point = current_point;
                output_idx += 1;
            }
        }
        self.set_instrumentation_point(output_idx, prev_point);
        output_idx += 1;
        self.kinds.truncate(output_idx);
        self.costs.truncate(output_idx);
        self.offsets.truncate(output_idx);
    }

    /// Optimize the instrumentation tables.
    ///
    /// This reduces the number of entries in the supplied vectors while preserving the equivalence
    /// of observable (instrumented) program behaviour.
    pub(crate) fn optimize(&mut self) {
        // First: merge all instrumentation points at the same offset. This is always possible, and
        // may enable slightly better optimizations, as the less sophisticated merger that works
        // across instructions will only need to deal with one kind of instrumentation.
        self.optimize_with(|prev, next| {
            if prev.offset == next.offset {
                Some(InstrumentationPoint {
                    offset: prev.offset,
                    cost: prev.cost.checked_add(next.cost)?,
                    kind: prev.kind.merge_same_point(next.kind)?,
                })
            } else {
                None
            }
        });
        // Then, merge instrumentation points across instructions to construct conceptually ranges
        // of instructions covered by a single instrumentation point.
        self.optimize_with(|prev, next| {
            Some(InstrumentationPoint {
                offset: std::cmp::min(prev.offset, next.offset),
                kind: prev.kind.merge_across_instructions(next.kind)?,
                cost: prev.cost.checked_add(next.cost)?,
            })
        });
    }
}

'''
'''--- src/instruction_categories.rs ---
macro_rules! r#const {
    ($generator:ident) => {
        $generator! {
            I32.const = visit_i32_const, i32;
            I64.const = visit_i64_const, i64;
            F32.const = visit_f32_const, wasmparser::Ieee32;
            F64.const = visit_f64_const, wasmparser::Ieee64;
            V128.const = visit_v128_const, wasmparser::V128;
        }
    };
}

macro_rules! unop {
    ($generator:ident) => {
        $generator! {
            I32.unop = visit_i32_clz | visit_i32_ctz | visit_i32_popcnt;

            I64.unop = visit_i64_clz | visit_i64_ctz | visit_i64_popcnt;

            F32.unop = visit_f32_abs | visit_f32_neg | visit_f32_sqrt | visit_f32_ceil
                     | visit_f32_floor | visit_f32_trunc | visit_f32_nearest;

            F64.unop = visit_f64_abs | visit_f64_neg | visit_f64_sqrt | visit_f64_ceil
                     | visit_f64_floor | visit_f64_trunc | visit_f64_nearest;

            V128.unop = visit_v128_not;

            V128.unop = visit_i8x16_abs | visit_i8x16_neg | visit_i8x16_popcnt;
            V128.unop = visit_i16x8_abs | visit_i16x8_neg;
            V128.unop = visit_i32x4_abs | visit_i32x4_neg;
            V128.unop = visit_i64x2_abs | visit_i64x2_neg;

            V128.unop = visit_f32x4_abs | visit_f32x4_neg | visit_f32x4_sqrt | visit_f32x4_ceil
                      | visit_f32x4_floor | visit_f32x4_trunc | visit_f32x4_nearest;
            V128.unop = visit_f64x2_abs | visit_f64x2_neg | visit_f64x2_sqrt | visit_f64x2_ceil
                      | visit_f64x2_floor | visit_f64x2_trunc | visit_f64x2_nearest;

            // ishape1.extadd_pairwise_ishape2_sx : [v128] → [v128]
            V128.unop = visit_i16x8_extadd_pairwise_i8x16_s | visit_i16x8_extadd_pairwise_i8x16_u;
            V128.unop = visit_i32x4_extadd_pairwise_i16x8_s | visit_i32x4_extadd_pairwise_i16x8_u;
        }
    };
}

macro_rules! binop_partial {
    ($generator:ident) => {
        $generator! {
            I32.binop = visit_i32_div_s | visit_i32_div_u
                      | visit_i32_rem_s | visit_i32_rem_u;
            I64.binop = visit_i64_div_s | visit_i64_div_u
                      | visit_i64_rem_s | visit_i64_rem_u;
        }
    };
}

macro_rules! binop_complete {
    ($generator:ident) => {
        $generator! {
            I32.binop = visit_i32_add | visit_i32_sub | visit_i32_mul
                      | visit_i32_and | visit_i32_or | visit_i32_xor | visit_i32_shl
                      | visit_i32_shr_s | visit_i32_shr_u
                      | visit_i32_rotl | visit_i32_rotr;
            I64.binop = visit_i64_add | visit_i64_sub | visit_i64_mul
                      | visit_i64_and | visit_i64_or | visit_i64_xor | visit_i64_shl
                      | visit_i64_shr_s | visit_i64_shr_u
                      | visit_i64_rotl | visit_i64_rotr;
            F32.binop = visit_f32_add | visit_f32_sub | visit_f32_mul
                      | visit_f32_div | visit_f32_min | visit_f32_max | visit_f32_copysign;
            F64.binop = visit_f64_add | visit_f64_sub | visit_f64_mul
                      | visit_f64_div | visit_f64_min | visit_f64_max | visit_f64_copysign;

            V128.binop = visit_v128_and | visit_v128_andnot | visit_v128_or | visit_v128_xor;

            V128.binop = visit_i8x16_add | visit_i8x16_sub;
            V128.binop = visit_i16x8_add | visit_i16x8_sub | visit_i16x8_mul;
            V128.binop = visit_i32x4_add | visit_i32x4_sub | visit_i32x4_mul;
            V128.binop = visit_i64x2_add | visit_i64x2_sub | visit_i64x2_mul;

            V128.binop = visit_f32x4_add | visit_f32x4_sub | visit_f32x4_mul | visit_f32x4_div
                       | visit_f32x4_min | visit_f32x4_max | visit_f32x4_pmin | visit_f32x4_pmax
                       | visit_f32x4_relaxed_min | visit_f32x4_relaxed_max;
            V128.binop = visit_f64x2_add | visit_f64x2_sub | visit_f64x2_mul | visit_f64x2_div
                       | visit_f64x2_min | visit_f64x2_max | visit_f64x2_pmin | visit_f64x2_pmax
                       | visit_f64x2_relaxed_min | visit_f64x2_relaxed_max;

            V128.binop = visit_i8x16_min_s | visit_i8x16_min_u | visit_i8x16_max_s | visit_i8x16_max_u;
            V128.binop = visit_i16x8_min_s | visit_i16x8_min_u | visit_i16x8_max_s | visit_i16x8_max_u;
            V128.binop = visit_i32x4_min_s | visit_i32x4_min_u | visit_i32x4_max_s | visit_i32x4_max_u;

            V128.binop = visit_i8x16_add_sat_s | visit_i8x16_add_sat_u
                       | visit_i8x16_sub_sat_s | visit_i8x16_sub_sat_u;
            V128.binop = visit_i16x8_add_sat_s | visit_i16x8_add_sat_u
                       | visit_i16x8_sub_sat_s | visit_i16x8_sub_sat_u;

            V128.binop = visit_i8x16_avgr_u;
            V128.binop = visit_i16x8_avgr_u | visit_i16x8_q15mulr_sat_s | visit_i16x8_relaxed_q15mulr_s;

            // ishape1.dot_ishape2_s : [v128 v128] → [v128]
            V128.binop = visit_i32x4_dot_i16x8_s;
            // https://github.com/WebAssembly/relaxed-simd/blob/main/proposals/relaxed-simd/Overview.md#relaxed-integer-dot-product
            V128.binop = visit_i16x8_relaxed_dot_i8x16_i7x16_s;

            // ishape1.extmul_half_ishape2_sx : [v128 v128] → [v128]
            V128.binop = visit_i16x8_extmul_low_i8x16_s | visit_i16x8_extmul_high_i8x16_s
                       | visit_i16x8_extmul_low_i8x16_u | visit_i16x8_extmul_high_i8x16_u;
            V128.binop = visit_i32x4_extmul_low_i16x8_s | visit_i32x4_extmul_high_i16x8_s
                       | visit_i32x4_extmul_low_i16x8_u | visit_i32x4_extmul_high_i16x8_u;
            V128.binop = visit_i64x2_extmul_low_i32x4_s | visit_i64x2_extmul_high_i32x4_s
                       | visit_i64x2_extmul_low_i32x4_u | visit_i64x2_extmul_high_i32x4_u;

            // i8x16.swizzle : [v128 v128] → [v128]
            // i8x16.relaxed_swizzle : [v128 v128] → [v128]
            // https://github.com/WebAssembly/relaxed-simd/blob/main/proposals/relaxed-simd/Overview.md#relaxed-swizzle
            V128.binop = visit_i8x16_swizzle | visit_i8x16_relaxed_swizzle;
        }
    }
}

macro_rules! binop {
    ($generator:ident) => {
        $crate::instruction_categories::binop_partial!($generator);
        $crate::instruction_categories::binop_complete!($generator);
    };
}

macro_rules! vishiftop {
    ($generator:ident) => {
        $generator! {
            V128.vishiftop = visit_i8x16_shl | visit_i8x16_shr_s | visit_i8x16_shr_u;
            V128.vishiftop = visit_i16x8_shl | visit_i16x8_shr_s | visit_i16x8_shr_u;
            V128.vishiftop = visit_i32x4_shl | visit_i32x4_shr_s | visit_i32x4_shr_u;
            V128.vishiftop = visit_i64x2_shl | visit_i64x2_shr_s | visit_i64x2_shr_u;
        }
    };
}

macro_rules! testop {
    ($generator:ident) => {
        $generator! {
            I32.testop = visit_i32_eqz;
            I64.testop = visit_i64_eqz;
            V128.testop = visit_v128_any_true
                        | visit_i8x16_all_true | visit_i16x8_all_true
                        | visit_i32x4_all_true | visit_i64x2_all_true;
            FuncRef.testop = visit_ref_is_null;
        }
    };
}

macro_rules! relop {
    ($generator:ident) => {
        $generator! {
            I32.relop = visit_i32_eq | visit_i32_ne
                      | visit_i32_lt_s | visit_i32_lt_u | visit_i32_gt_s | visit_i32_gt_u
                      | visit_i32_le_s | visit_i32_le_u | visit_i32_ge_s | visit_i32_ge_u;
            I64.relop = visit_i64_eq | visit_i64_ne
                      | visit_i64_lt_s | visit_i64_lt_u | visit_i64_gt_s | visit_i64_gt_u
                      | visit_i64_le_s | visit_i64_le_u | visit_i64_ge_s | visit_i64_ge_u;
            F32.relop = visit_f32_eq | visit_f32_ne
                      | visit_f32_lt | visit_f32_gt | visit_f32_le | visit_f32_ge;
            F64.relop = visit_f64_eq | visit_f64_ne
                      | visit_f64_lt | visit_f64_gt | visit_f64_le | visit_f64_ge;
        }
    };
}

macro_rules! cvtop_partial {
    ($generator:ident) => {
        $generator! {
            I32.cvtop = visit_i32_trunc_f32_s | visit_i32_trunc_f32_u
                      | visit_i32_trunc_f64_s | visit_i32_trunc_f64_u;
            I64.cvtop = visit_i64_trunc_f32_s | visit_i64_trunc_f32_u
                      | visit_i64_trunc_f64_s | visit_i64_trunc_f64_u;
        }
    };
}

macro_rules! cvtop_complete {
    ($generator:ident) => {
        $generator! {
            I32.cvtop = visit_i32_wrap_i64
                      | visit_i32_extend8_s | visit_i32_extend16_s
                      | visit_i32_trunc_sat_f32_s | visit_i32_trunc_sat_f32_u
                      | visit_i32_trunc_sat_f64_s | visit_i32_trunc_sat_f64_u
                      | visit_i32_reinterpret_f32;

            I64.cvtop = visit_i64_extend8_s | visit_i64_extend16_s | visit_i64_extend32_s
                      | visit_i64_extend_i32_s | visit_i64_extend_i32_u
                      | visit_i64_trunc_sat_f32_s | visit_i64_trunc_sat_f32_u
                      | visit_i64_trunc_sat_f64_s | visit_i64_trunc_sat_f64_u
                      | visit_i64_reinterpret_f64;

            F32.cvtop = visit_f32_demote_f64
                      | visit_f32_convert_i32_s | visit_f32_convert_i32_u
                      | visit_f32_convert_i64_s | visit_f32_convert_i64_u
                      | visit_f32_reinterpret_i32;
            F64.cvtop = visit_f64_promote_f32
                      | visit_f64_convert_i32_s | visit_f64_convert_i32_u
                      | visit_f64_convert_i64_s | visit_f64_convert_i64_u
                      | visit_f64_reinterpret_i64;

            V128.cvtop = visit_i16x8_extend_low_i8x16_s | visit_i16x8_extend_high_i8x16_s
                       | visit_i16x8_extend_low_i8x16_u | visit_i16x8_extend_high_i8x16_u;

            V128.cvtop = visit_i32x4_extend_low_i16x8_s | visit_i32x4_extend_high_i16x8_s
                       | visit_i32x4_extend_low_i16x8_u | visit_i32x4_extend_high_i16x8_u
                       | visit_i32x4_trunc_sat_f32x4_s | visit_i32x4_trunc_sat_f32x4_u
                       | visit_i32x4_trunc_sat_f64x2_s_zero | visit_i32x4_trunc_sat_f64x2_u_zero
                       | visit_i32x4_relaxed_trunc_f32x4_s
                       | visit_i32x4_relaxed_trunc_f32x4_u
                       | visit_i32x4_relaxed_trunc_f64x2_s_zero
                       | visit_i32x4_relaxed_trunc_f64x2_u_zero;

            V128.cvtop = visit_i64x2_extend_low_i32x4_s | visit_i64x2_extend_high_i32x4_s
                       | visit_i64x2_extend_low_i32x4_u | visit_i64x2_extend_high_i32x4_u;

            V128.cvtop = visit_f32x4_demote_f64x2_zero
                       | visit_f32x4_convert_i32x4_s | visit_f32x4_convert_i32x4_u;

            V128.cvtop = visit_f64x2_promote_low_f32x4
                       | visit_f64x2_convert_low_i32x4_s | visit_f64x2_convert_low_i32x4_u;
        }
    };
}

macro_rules! cvtop {
    ($generator:ident) => {
        $crate::instruction_categories::cvtop_partial!($generator);
        $crate::instruction_categories::cvtop_complete!($generator);
    };
}

macro_rules! loadlane {
    ($generator:ident) => {
        $generator! {
            V128.loadlane = visit_v128_load8_lane | visit_v128_load16_lane
                           | visit_v128_load32_lane | visit_v128_load64_lane;
        }
    };
}

macro_rules! load {
    ($generator:ident) => {
        $generator! {
            I32.load = visit_i32_load
                     | visit_i32_load8_s | visit_i32_load8_u
                     | visit_i32_load16_s | visit_i32_load16_u
                     | visit_i32_atomic_load
                     | visit_i32_atomic_load8_u
                     | visit_i32_atomic_load16_u;

            I64.load = visit_i64_load
                     | visit_i64_load8_s | visit_i64_load8_u
                     | visit_i64_load16_s | visit_i64_load16_u
                     | visit_i64_load32_s | visit_i64_load32_u
                     | visit_i64_atomic_load
                     | visit_i64_atomic_load8_u
                     | visit_i64_atomic_load16_u
                     | visit_i64_atomic_load32_u;

            F32.load = visit_f32_load;

            F64.load = visit_f64_load;

            V128.load = visit_v128_load
                      | visit_v128_load8x8_s | visit_v128_load8x8_u
                      | visit_v128_load16x4_s | visit_v128_load16x4_u
                      | visit_v128_load32x2_s | visit_v128_load32x2_u
                      | visit_v128_load32_zero | visit_v128_load64_zero
                      | visit_v128_load8_splat | visit_v128_load16_splat
                      | visit_v128_load32_splat | visit_v128_load64_splat;
        }
    };
}

macro_rules! storelane {
    ($generator:ident) => {
        $generator! {
            V128.storelane = visit_v128_store8_lane | visit_v128_store16_lane
                            | visit_v128_store32_lane | visit_v128_store64_lane;
        }
    };
}

macro_rules! store {
    ($generator:ident) => {
        $generator! {
            I32.store = visit_i32_store | visit_i32_store8 | visit_i32_store16
                      | visit_i32_atomic_store
                      | visit_i32_atomic_store8 | visit_i32_atomic_store16;

            I64.store = visit_i64_store | visit_i64_store8 | visit_i64_store16 | visit_i64_store32
                      | visit_i64_atomic_store
                      | visit_i64_atomic_store8
                      | visit_i64_atomic_store16
                      | visit_i64_atomic_store32;

            F32.store = visit_f32_store;

            F64.store = visit_f64_store;

            V128.store = visit_v128_store;
        }
    };
}

macro_rules! replacelane {
    ($generator:ident) => {
        $generator! {
            V128.replacelane = visit_i8x16_replace_lane | visit_i16x8_replace_lane
                             | visit_i32x4_replace_lane | visit_i64x2_replace_lane
                             | visit_f32x4_replace_lane | visit_f64x2_replace_lane;
        }
    };
}

macro_rules! extractlane {
    ($generator:ident) => {
        $generator! {
            I32.extractlane = visit_i8x16_extract_lane_s
                            | visit_i8x16_extract_lane_u
                            | visit_i16x8_extract_lane_s
                            | visit_i16x8_extract_lane_u
                            | visit_i32x4_extract_lane;
            I64.extractlane = visit_i64x2_extract_lane;
            F32.extractlane = visit_f32x4_extract_lane;
            F64.extractlane = visit_f64x2_extract_lane;
        }
    };
}

macro_rules! vternop {
    ($generator:ident) => {
        $generator! {
            V128.vternop = visit_v128_bitselect;

            // https://github.com/WebAssembly/relaxed-simd/blob/main/proposals/relaxed-simd/Overview.md#relaxed-laneselect
            V128.vternop = visit_i8x16_relaxed_laneselect;
            V128.vternop = visit_i16x8_relaxed_laneselect;
            V128.vternop = visit_i32x4_relaxed_laneselect;
            V128.vternop = visit_i64x2_relaxed_laneselect;

            // https://github.com/WebAssembly/relaxed-simd/blob/main/proposals/relaxed-simd/Overview.md#relaxed-fused-multiply-add-and-fused-negative-multiply-add
            V128.vternop = visit_f32x4_relaxed_madd | visit_f32x4_relaxed_nmadd;
            V128.vternop = visit_f64x2_relaxed_madd | visit_f64x2_relaxed_nmadd;

            // https://github.com/WebAssembly/relaxed-simd/blob/main/proposals/relaxed-simd/Overview.md#relaxed-integer-dot-product
            V128.vternop = visit_i32x4_relaxed_dot_i8x16_i7x16_add_s;
        }
    };
}

macro_rules! vrelop {
    ($generator:ident) => {
        $generator! {
            V128.vrelop = visit_i8x16_eq | visit_i8x16_ne
                        | visit_i8x16_lt_s | visit_i8x16_lt_u | visit_i8x16_gt_s | visit_i8x16_gt_u
                        | visit_i8x16_le_s | visit_i8x16_le_u | visit_i8x16_ge_s | visit_i8x16_ge_u;
            V128.vrelop = visit_i16x8_eq | visit_i16x8_ne
                        | visit_i16x8_lt_s | visit_i16x8_lt_u | visit_i16x8_gt_s | visit_i16x8_gt_u
                        | visit_i16x8_le_s | visit_i16x8_le_u | visit_i16x8_ge_s | visit_i16x8_ge_u;
            V128.vrelop = visit_i32x4_eq | visit_i32x4_ne
                        | visit_i32x4_lt_s | visit_i32x4_lt_u | visit_i32x4_gt_s | visit_i32x4_gt_u
                        | visit_i32x4_le_s | visit_i32x4_le_u | visit_i32x4_ge_s | visit_i32x4_ge_u;
            V128.vrelop = visit_i64x2_eq | visit_i64x2_ne
                        | visit_i64x2_lt_s | visit_i64x2_gt_s | visit_i64x2_le_s | visit_i64x2_ge_s;
            V128.vrelop = visit_f32x4_eq | visit_f32x4_ne
                        | visit_f32x4_lt | visit_f32x4_gt | visit_f32x4_le | visit_f32x4_ge;
            V128.vrelop = visit_f64x2_eq | visit_f64x2_ne
                        | visit_f64x2_lt | visit_f64x2_gt | visit_f64x2_le | visit_f64x2_ge;
        }
    };
}

macro_rules! vinarrowop {
    ($generator:ident) => {
        $generator! {
            V128.vinarrowop = visit_i8x16_narrow_i16x8_s | visit_i8x16_narrow_i16x8_u;
            V128.vinarrowop = visit_i16x8_narrow_i32x4_s | visit_i16x8_narrow_i32x4_u;
        }
    };
}

macro_rules! vbitmask {
    ($generator:ident) => {
        $generator! {
            V128.vbitmask = visit_i8x16_bitmask | visit_i16x8_bitmask
                          | visit_i32x4_bitmask | visit_i64x2_bitmask;
        }
    };
}

macro_rules! splat {
    ($generator:ident) => {
        $generator! {
            V128.splat = visit_i8x16_splat | visit_i16x8_splat | visit_i32x4_splat
                       | visit_i64x2_splat | visit_f32x4_splat | visit_f64x2_splat;
        }
    };
}

macro_rules! atomic_rmw {
    ($generator:ident) => {
        $generator! {
            I32.atomic.rmw = visit_i32_atomic_rmw_add | visit_i32_atomic_rmw_sub
                           | visit_i32_atomic_rmw_and | visit_i32_atomic_rmw_or
                           | visit_i32_atomic_rmw_xor | visit_i32_atomic_rmw_xchg
                           | visit_i32_atomic_rmw8_add_u | visit_i32_atomic_rmw16_add_u
                           | visit_i32_atomic_rmw8_sub_u | visit_i32_atomic_rmw16_sub_u
                           | visit_i32_atomic_rmw8_and_u | visit_i32_atomic_rmw16_and_u
                           | visit_i32_atomic_rmw8_or_u | visit_i32_atomic_rmw16_or_u
                           | visit_i32_atomic_rmw8_xor_u | visit_i32_atomic_rmw16_xor_u
                           | visit_i32_atomic_rmw8_xchg_u | visit_i32_atomic_rmw16_xchg_u;
            I64.atomic.rmw = visit_i64_atomic_rmw_add | visit_i64_atomic_rmw_sub
                           | visit_i64_atomic_rmw_and | visit_i64_atomic_rmw_or
                           | visit_i64_atomic_rmw_xor | visit_i64_atomic_rmw_xchg
                           | visit_i64_atomic_rmw8_add_u | visit_i64_atomic_rmw16_add_u
                           | visit_i64_atomic_rmw32_add_u
                           | visit_i64_atomic_rmw8_sub_u | visit_i64_atomic_rmw16_sub_u
                           | visit_i64_atomic_rmw32_sub_u
                           | visit_i64_atomic_rmw8_and_u | visit_i64_atomic_rmw16_and_u
                           | visit_i64_atomic_rmw32_and_u
                           | visit_i64_atomic_rmw8_or_u | visit_i64_atomic_rmw16_or_u
                           | visit_i64_atomic_rmw32_or_u
                           | visit_i64_atomic_rmw8_xor_u | visit_i64_atomic_rmw16_xor_u
                           | visit_i64_atomic_rmw32_xor_u
                           | visit_i64_atomic_rmw8_xchg_u | visit_i64_atomic_rmw16_xchg_u
                           | visit_i64_atomic_rmw32_xchg_u;
        }
    };
}

macro_rules! atomic_cmpxchg {
    ($generator:ident) => {
        $generator! {
            I32.atomic.cmpxchg = visit_i32_atomic_rmw_cmpxchg
                               | visit_i32_atomic_rmw8_cmpxchg_u
                               | visit_i32_atomic_rmw16_cmpxchg_u;
            I64.atomic.cmpxchg = visit_i64_atomic_rmw_cmpxchg
                               | visit_i64_atomic_rmw8_cmpxchg_u
                               | visit_i64_atomic_rmw16_cmpxchg_u
                               | visit_i64_atomic_rmw32_cmpxchg_u;
        }
    };
}

pub(crate) use {
    atomic_cmpxchg, atomic_rmw, binop, binop_complete, binop_partial, cvtop, cvtop_complete,
    cvtop_partial, extractlane, load, loadlane, r#const, relop, replacelane, splat, store,
    storelane, testop, unop, vbitmask, vinarrowop, vishiftop, vrelop, vternop,
};

'''
'''--- src/instrument.rs ---
use crate::{gas::InstrumentationKind, AnalysisOutcome};
use wasm_encoder::{self as we, Section};
use wasmparser as wp;

const PLACEHOLDER_FOR_NAMES: u8 = !0;

/// These function indices are known to be constant, as they are added at the beginning of the
/// imports section.
///
/// Doing so makes it much easier to transform references to other functions (basically add F to
/// all function indices)
const GAS_INSTRUMENTATION_FN: u32 = 0;

/// See [`GAS_INSTRUMENTATION_FN`].
const RESERVE_STACK_INSTRUMENTATION_FN: u32 = GAS_INSTRUMENTATION_FN + 1;

/// See [`RESERVE_STACK_INSTRUMENTATION_FN`].
const RELEASE_STACK_INSTRUMENTATION_FN: u32 = RESERVE_STACK_INSTRUMENTATION_FN + 1;

/// By how many to adjust the references to functions in the instrumented module.
const F: u32 = RELEASE_STACK_INSTRUMENTATION_FN + 1;

#[derive(thiserror::Error, Debug)]
pub enum Error {
    #[error("could not parse an element")]
    ParseElement(#[source] wp::BinaryReaderError),
    #[error("could not parse an element item")]
    ParseElementItem(#[source] wp::BinaryReaderError),
    #[error("could not parse an element expression")]
    ParseElementExpression(#[source] wp::BinaryReaderError),
    #[error("could not parse the function locals")]
    ParseLocals(#[source] wp::BinaryReaderError),
    #[error("could not parse a function local")]
    ParseLocal(#[source] wp::BinaryReaderError),
    #[error("could not parse the function operators")]
    ParseOperators(#[source] wp::BinaryReaderError),
    #[error("could not parse an operator")]
    ParseOperator(#[source] wp::BinaryReaderError),
    #[error("could not parse an export")]
    ParseExport(#[source] wp::BinaryReaderError),
    #[error("could not parse a global")]
    ParseGlobal(#[source] wp::BinaryReaderError),
    #[error("could not parse a name section entry")]
    ParseName(#[source] wp::BinaryReaderError),
    #[error("could not parse a name map entry")]
    ParseNameMapName(#[source] wp::BinaryReaderError),
    #[error("could not parse an indirect name map entry")]
    ParseIndirectNameMapName(#[source] wp::BinaryReaderError),
    #[error("could not parse a module section header")]
    ParseModuleSection(#[source] wp::BinaryReaderError),
    #[error("could not parse a type section entry")]
    ParseType(#[source] wp::BinaryReaderError),
    #[error("could not parse an import section entry")]
    ParseImport(#[source] wp::BinaryReaderError),
    #[error("could not parse a function section entry")]
    ParseFunctionTypeId(#[source] wp::BinaryReaderError),
    #[error("could not parse a constant expression operator")]
    ParseConstExprOperator(#[source] wp::BinaryReaderError),
    #[error("the analysis outcome missing a {0} entry for code section entry `{1}`")]
    FunctionMissingInAnalysisOutcome(&'static str, usize),
    #[error("module contains fewer function types than definitions")]
    InsufficientFunctionTypes,
    #[error("module contains a reference to an invalid type index")]
    InvalidTypeIndex,
    #[error("size for custom section {0} is out of input bounds")]
    CustomSectionRange(u8, usize),
    #[error("could not remap function index {0}")]
    RemapFunctionIndex(u32),
}

pub(crate) struct InstrumentContext<'a> {
    analysis: &'a AnalysisOutcome,
    wasm: &'a [u8],
    import_env: &'a str,

    function_section: we::FunctionSection,
    type_section: we::TypeSection,
    import_section: we::ImportSection,
    code_section: we::CodeSection,
    element_section: we::ElementSection,
    export_section: we::ExportSection,
    name_section: we::NameSection,
    global_section: we::GlobalSection,
    start_section: we::StartSection,
    raw_sections: Vec<we::RawSection<'a>>,

    types: Vec<wp::Type>,
    function_types: std::vec::IntoIter<u32>,
}

impl<'a> InstrumentContext<'a> {
    pub(crate) fn new(wasm: &'a [u8], import_env: &'a str, analysis: &'a AnalysisOutcome) -> Self {
        Self {
            analysis,
            wasm,
            import_env,

            function_section: we::FunctionSection::new(),
            type_section: we::TypeSection::new(),
            import_section: we::ImportSection::new(),
            code_section: we::CodeSection::new(),
            element_section: we::ElementSection::new(),
            export_section: we::ExportSection::new(),
            name_section: we::NameSection::new(),
            global_section: we::GlobalSection::new(),
            start_section: we::StartSection { function_index: 0 },
            raw_sections: vec![],

            types: vec![],
            function_types: vec![].into_iter(),
        }
    }

    fn schedule_section(&mut self, id: u8) {
        self.raw_sections.push(we::RawSection { id, data: &[] });
    }

    pub(crate) fn run(mut self) -> Result<Vec<u8>, Error> {
        let parser = wp::Parser::new(0);
        for payload in parser.parse_all(self.wasm) {
            let payload = payload.map_err(Error::ParseModuleSection)?;
            match payload {
                // These two payload types are (re-)generated by wasm_encoder.
                wp::Payload::Version { .. } => {}
                wp::Payload::End(_) => {}
                // We must manually reconstruct the type section because we’re appending types to
                // it.
                wp::Payload::TypeSection(types) => {
                    for ty in types {
                        let ty = ty.map_err(Error::ParseType)?;
                        match &ty {
                            wp::Type::Func(f) => {
                                self.type_section.function(
                                    f.params().iter().copied().map(valtype),
                                    f.results().iter().copied().map(valtype),
                                );
                            }
                        }
                        self.types.push(ty);
                    }
                }
                // We must manually reconstruct the imports section because we’re appending imports
                // to it.
                wp::Payload::ImportSection(imports) => {
                    self.maybe_add_imports();
                    self.transform_imports_section(imports)?;
                }
                wp::Payload::StartSection { func, .. } => {
                    self.start_section.function_index = map_func(func)?;
                    self.schedule_section(self.start_section.id());
                }
                wp::Payload::ElementSection(reader) => {
                    self.transform_elem_section(reader)?;
                    self.schedule_section(self.element_section.id());
                }
                wp::Payload::FunctionSection(reader) => {
                    // We don’t want to modify this, but need to remember function type indices…
                    let fn_types = reader
                        .into_iter()
                        .collect::<Result<Vec<u32>, _>>()
                        .map_err(Error::ParseFunctionTypeId)?;
                    for fnty in &fn_types {
                        self.function_section.function(*fnty);
                    }
                    self.function_types = fn_types.into_iter();
                    self.schedule_section(self.function_section.id());
                }
                wp::Payload::CodeSectionStart { .. } => {
                    self.schedule_section(self.code_section.id());
                }
                wp::Payload::CodeSectionEntry(reader) => {
                    self.maybe_add_imports();
                    let type_index = self
                        .function_types
                        .next()
                        .ok_or(Error::InsufficientFunctionTypes)?;
                    self.transform_code_section(reader, type_index)?;
                }
                wp::Payload::ExportSection(reader) => {
                    for export in reader {
                        let export = export.map_err(Error::ParseExport)?;
                        let (kind, index) = match export.kind {
                            wp::ExternalKind::Func => {
                                (we::ExportKind::Func, map_func(export.index)?)
                            }
                            wp::ExternalKind::Table => (we::ExportKind::Table, export.index),
                            wp::ExternalKind::Memory => (we::ExportKind::Memory, export.index),
                            wp::ExternalKind::Global => (we::ExportKind::Global, export.index),
                            wp::ExternalKind::Tag => (we::ExportKind::Tag, export.index),
                        };
                        self.export_section.export(export.name, kind, index);
                    }
                    self.schedule_section(self.export_section.id());
                }
                wp::Payload::GlobalSection(reader) => {
                    for global in reader {
                        let global = global.map_err(Error::ParseGlobal)?;
                        self.global_section.global(
                            we::GlobalType {
                                val_type: valtype(global.ty.content_type),
                                mutable: global.ty.mutable,
                            },
                            &constexpr(global.init_expr)?,
                        );
                    }
                    self.schedule_section(self.global_section.id());
                }
                wp::Payload::CustomSection(reader) if reader.name() == "name" => {
                    let names = wp::NameSectionReader::new(reader.data(), reader.data_offset());
                    if let Ok(_) = self.transform_name_section(names) {
                        // Keep valid name sections only. These sections don't have semantic
                        // purposes, so it isn't a big deal if we only keep the old section, or
                        // don't transform at all.
                        //
                        // (This is largely useful for fuzzing only)
                        self.schedule_section(PLACEHOLDER_FOR_NAMES)
                    }
                }
                // All the other sections are transparently copied over (they cannot reference a
                // function id, or we don’t know how to handle it anyhow)
                _ => {
                    let (id, range) = payload
                        .as_section()
                        .expect("any non-section payloads should have been handled already");
                    let len = range.len();
                    self.raw_sections.push(wasm_encoder::RawSection {
                        id,
                        data: self
                            .wasm
                            .get(range)
                            .ok_or(Error::CustomSectionRange(id, len))?,
                    });
                }
            }
        }

        // The type and import sections always come first in a module. They may potentially be
        // preceded or interspersed by custom sections in the original module, so we’re just hoping
        // that the ordering doesn’t matter for tests…
        let mut output = wasm_encoder::Module::new();
        output.section(&self.type_section);
        output.section(&self.import_section);
        for section in self.raw_sections {
            match section.id {
                id if id == self.code_section.id() => output.section(&self.code_section),
                id if id == self.element_section.id() => output.section(&self.element_section),
                id if id == self.export_section.id() => output.section(&self.export_section),
                id if id == self.global_section.id() => output.section(&self.global_section),
                id if id == self.start_section.id() => output.section(&self.start_section),
                id if id == self.function_section.id() => output.section(&self.function_section),
                PLACEHOLDER_FOR_NAMES => output.section(&self.name_section),
                _ => output.section(&section),
            };
        }
        Ok(output.finish())
    }

    fn transform_code_section(
        &mut self,
        reader: wp::FunctionBody,
        func_type_idx: u32,
    ) -> Result<(), Error> {
        let func_type_idx_usize =
            usize::try_from(func_type_idx).map_err(|_| Error::InvalidTypeIndex)?;
        let func_type = self
            .types
            .get(func_type_idx_usize)
            .ok_or(Error::InvalidTypeIndex)?;
        let locals = reader
            .get_locals_reader()
            .map_err(Error::ParseLocals)?
            .into_iter()
            .map(|v| v.map(|(c, t)| (c, valtype(t))))
            .collect::<Result<Vec<_>, _>>()
            .map_err(Error::ParseLocal)?;
        let mut new_function = we::Function::new(locals);
        let code_idx = self.code_section.len() as usize;
        macro_rules! get_idx {
            (analysis . $field: ident) => {{
                let f = self.analysis.$field.get(code_idx);
                const NAME: &str = stringify!($field);
                f.ok_or(Error::FunctionMissingInAnalysisOutcome(NAME, code_idx))
            }};
        }
        let gas_costs = get_idx!(analysis.gas_costs)?;
        let gas_kinds = get_idx!(analysis.gas_kinds)?;
        let gas_offsets = get_idx!(analysis.gas_offsets)?;
        let stack_sz = *get_idx!(analysis.function_operand_stack_sizes)?;
        let frame_sz = *get_idx!(analysis.function_frame_sizes)?;

        let mut instrumentation_points = gas_offsets
            .iter()
            .zip(gas_costs.iter())
            .zip(gas_kinds.iter())
            .peekable();
        let mut operators = reader
            .get_operators_reader()
            .map_err(Error::ParseOperators)?;

        // In order to enable us to insert the code to release the stack allocation, we’ll wrap the
        // function body into a `block` and insert the instrumentation after the block ends… This
        // additional wrapping block allows us to “intercept” various branching instructions with
        // frame depths that would otherwise lead to a return. This is especially important when
        // these branching instructions are conditional: we could replace `br $well_chosen_index`
        // with a `return` and handle it much the same way, but we can’t do anything of the sort
        // for `br_if $well_chosen_index`.
        let (params, results) = match func_type {
            wp::Type::Func(fnty) => (fnty.params(), fnty.results()),
        };
        // NOTE: Function parameters become locals, rather than operands, so we don’t need to
        // handle them in any way when inserting the block.
        let block_type = match (params, results) {
            (_, []) => we::BlockType::Empty,
            (_, [result]) => we::BlockType::Result(valtype(*result)),
            ([], _) => we::BlockType::FunctionType(func_type_idx),
            (_, results) => {
                let new_block_type_idx = self.type_section.len();
                self.type_section
                    .function(std::iter::empty(), results.iter().copied().map(valtype));
                we::BlockType::FunctionType(new_block_type_idx)
            }
        };

        let should_instrument_stack = stack_sz != 0 || frame_sz != 0;
        if should_instrument_stack {
            new_function.instruction(&we::Instruction::Block(block_type));
            new_function.instruction(&we::Instruction::I64Const(stack_sz as i64));
            new_function.instruction(&we::Instruction::I64Const(frame_sz as i64));
            new_function.instruction(&we::Instruction::Call(RESERVE_STACK_INSTRUMENTATION_FN));
        }

        while !operators.eof() {
            let (op, offset) = operators.read_with_offset().map_err(Error::ParseOperator)?;
            let end_offset = operators.original_position();
            while instrumentation_points.peek().map(|((o, _), _)| **o) == Some(offset) {
                let ((_, g), k) = instrumentation_points.next().expect("we just peeked");
                if !matches!(k, InstrumentationKind::Unreachable) {
                    call_gas_instrumentation(&mut new_function, *g)
                }
            }
            match op {
                wp::Operator::RefFunc { function_index } => {
                    new_function.instruction(&we::Instruction::RefFunc(map_func(function_index)?))
                }
                wp::Operator::Call { function_index } => {
                    new_function.instruction(&we::Instruction::Call(map_func(function_index)?))
                }
                wp::Operator::ReturnCall { function_index } => {
                    call_unstack_instrumentation(&mut new_function, stack_sz, frame_sz);
                    new_function
                        .instruction(&we::Instruction::ReturnCall(map_func(function_index)?))
                }
                wp::Operator::ReturnCallIndirect { .. } => {
                    call_unstack_instrumentation(&mut new_function, stack_sz, frame_sz);
                    new_function.raw(self.wasm[offset..end_offset].iter().copied())
                }
                wp::Operator::Return => {
                    // FIXME: we could replace these `return`s with `br $well_chosen_index`
                    // targetting the block we inserted around the function body.
                    call_unstack_instrumentation(&mut new_function, stack_sz, frame_sz);
                    new_function.instruction(&we::Instruction::Return)
                }
                wp::Operator::End if operators.eof() => {
                    // This is the last function end…
                    if should_instrument_stack {
                        new_function.instruction(&we::Instruction::End);
                        call_unstack_instrumentation(&mut new_function, stack_sz, frame_sz);
                    }
                    new_function.instruction(&we::Instruction::End)
                }
                _ => new_function.raw(self.wasm[offset..end_offset].iter().copied()),
            };
        }

        self.code_section.function(&new_function);
        Ok(())
    }

    fn maybe_add_imports(&mut self) {
        if self.import_section.is_empty() {
            let instrument_fn_ty = self.type_section.len();
            // By adding the type at the end of the type section we guarantee that any other
            // type references remain valid.
            self.type_section.function([we::ValType::I64], []);
            self.type_section
                .function([we::ValType::I64, we::ValType::I64], []);
            // By inserting the imports at the beginning of the import section we make the new
            // function index mapping trivial (it is always just an increment by F)
            self.import_section.import(
                self.import_env,
                "finite_wasm_gas",
                we::EntityType::Function(instrument_fn_ty),
            );
            self.import_section.import(
                self.import_env,
                "finite_wasm_stack",
                we::EntityType::Function(instrument_fn_ty + 1),
            );
            self.import_section.import(
                self.import_env,
                "finite_wasm_unstack",
                we::EntityType::Function(instrument_fn_ty + 1),
            );
        }
    }

    fn transform_name_section(&mut self, names: wp::NameSectionReader) -> Result<(), Error> {
        for name in names {
            let name = name.map_err(Error::ParseName)?;
            match name {
                wp::Name::Module { name, .. } => self.name_section.module(name),
                wp::Name::Function(map) => {
                    let mut new_name_map = we::NameMap::new();
                    new_name_map.append(GAS_INSTRUMENTATION_FN, "finite_wasm_gas");
                    new_name_map.append(RESERVE_STACK_INSTRUMENTATION_FN, "finite_wasm_stack");
                    new_name_map.append(RELEASE_STACK_INSTRUMENTATION_FN, "finite_wasm_unstack");
                    for naming in map {
                        let naming = naming.map_err(Error::ParseNameMapName)?;
                        new_name_map.append(map_func(naming.index)?, naming.name);
                    }
                    self.name_section.functions(&new_name_map)
                }
                wp::Name::Local(map) => self.name_section.locals(&indirectnamemap(map)?),
                wp::Name::Label(map) => self.name_section.labels(&indirectnamemap(map)?),
                wp::Name::Type(map) => self.name_section.types(&namemap(map, false)?),
                wp::Name::Table(map) => self.name_section.tables(&namemap(map, false)?),
                wp::Name::Memory(map) => self.name_section.memories(&namemap(map, false)?),
                wp::Name::Global(map) => self.name_section.globals(&namemap(map, false)?),
                wp::Name::Element(map) => self.name_section.elements(&namemap(map, false)?),
                wp::Name::Data(map) => self.name_section.data(&namemap(map, false)?),
                wp::Name::Unknown { .. } => {}
            }
        }
        Ok(())
    }

    fn transform_imports_section(&mut self, imports: wp::ImportSectionReader) -> Result<(), Error> {
        for import in imports {
            let import = import.map_err(Error::ParseImport)?;
            let import_ty = match import.ty {
                wp::TypeRef::Func(i) => we::EntityType::Function(i),
                wp::TypeRef::Table(t) => we::EntityType::Table(we::TableType {
                    element_type: reftype(t.element_type),
                    minimum: t.initial,
                    maximum: t.maximum,
                }),
                wp::TypeRef::Memory(t) => we::EntityType::Memory(we::MemoryType {
                    minimum: t.initial,
                    maximum: t.maximum,
                    memory64: t.memory64,
                    shared: t.shared,
                }),
                wp::TypeRef::Global(t) => we::EntityType::Global(we::GlobalType {
                    val_type: valtype(t.content_type),
                    mutable: t.mutable,
                }),
                wp::TypeRef::Tag(t) => we::EntityType::Tag(we::TagType {
                    kind: match t.kind {
                        wp::TagKind::Exception => we::TagKind::Exception,
                    },
                    func_type_idx: t.func_type_idx,
                }),
            };
            self.import_section
                .import(import.module, import.name, import_ty);
        }
        Ok(())
    }

    fn transform_elem_section(&mut self, reader: wp::ElementSectionReader) -> Result<(), Error> {
        for elem in reader {
            let elem = elem.map_err(Error::ParseElement)?;
            let functions;
            let expressions;
            let offset;
            let items = match elem.items {
                wp::ElementItems::Functions(fns) => {
                    functions = fns
                        .into_iter()
                        .map(|v| map_func(v.map_err(Error::ParseElementItem)?))
                        .collect::<Result<Vec<_>, _>>()?;
                    we::Elements::Functions(&functions)
                }
                wp::ElementItems::Expressions(exprs) => {
                    expressions = exprs
                        .into_iter()
                        .map(|v| v.map_err(Error::ParseElementExpression).and_then(constexpr))
                        .collect::<Result<Vec<_>, _>>()?;
                    we::Elements::Expressions(&expressions)
                }
            };
            self.element_section.segment(we::ElementSegment {
                mode: match elem.kind {
                    wp::ElementKind::Passive => we::ElementMode::Passive,
                    wp::ElementKind::Declared => we::ElementMode::Declared,
                    wp::ElementKind::Active {
                        table_index,
                        offset_expr,
                    } => {
                        offset = constexpr(offset_expr)?;
                        we::ElementMode::Active {
                            table: table_index,
                            offset: &offset,
                        }
                    }
                },
                element_type: reftype(elem.ty),
                elements: items,
            });
        }
        Ok(())
    }
}

fn call_unstack_instrumentation(
    func: &mut we::Function,
    max_operand_stack_size: u64,
    function_frame_size: u64,
) {
    if max_operand_stack_size != 0 || function_frame_size != 0 {
        // These casts being able to wrap-around is intentional. The callee must reinterpret these
        // back to unsigned.
        func.instruction(&we::Instruction::I64Const(max_operand_stack_size as i64));
        func.instruction(&we::Instruction::I64Const(function_frame_size as i64));
        func.instruction(&we::Instruction::Call(RELEASE_STACK_INSTRUMENTATION_FN));
    }
}

fn call_gas_instrumentation(func: &mut we::Function, gas: u64) {
    if gas != 0 {
        // The reinterpreting cast is intentional here. On the other side the host function is
        // expected to reinterpret the argument back to u64.
        func.instruction(&we::Instruction::I64Const(gas as i64));
        func.instruction(&we::Instruction::Call(GAS_INSTRUMENTATION_FN));
    }
}

fn valtype(wp: wp::ValType) -> we::ValType {
    match wp {
        wp::ValType::I32 => we::ValType::I32,
        wp::ValType::I64 => we::ValType::I64,
        wp::ValType::F32 => we::ValType::F32,
        wp::ValType::F64 => we::ValType::F64,
        wp::ValType::V128 => we::ValType::V128,
        wp::ValType::Ref(r) => we::ValType::Ref(reftype(r)),
    }
}

fn reftype(wp: wp::RefType) -> we::RefType {
    we::RefType {
        nullable: wp.is_nullable(),
        heap_type: match wp.heap_type() {
            wp::HeapType::Func => we::HeapType::Func,
            wp::HeapType::Extern => we::HeapType::Extern,
            wp::HeapType::Any => we::HeapType::Any,
            wp::HeapType::None => we::HeapType::None,
            wp::HeapType::NoExtern => we::HeapType::NoExtern,
            wp::HeapType::NoFunc => we::HeapType::NoFunc,
            wp::HeapType::Eq => we::HeapType::Eq,
            wp::HeapType::Struct => we::HeapType::Struct,
            wp::HeapType::Array => we::HeapType::Array,
            wp::HeapType::I31 => we::HeapType::I31,
            wp::HeapType::TypedFunc(idx) => we::HeapType::TypedFunc(idx),
        },
    }
}

fn constexpr(ep: wp::ConstExpr) -> Result<we::ConstExpr, Error> {
    let mut reader = ep.get_binary_reader();
    Ok(
        match reader
            .clone()
            .read_operator()
            .map_err(Error::ParseConstExprOperator)?
        {
            wp::Operator::RefFunc { function_index } => {
                we::ConstExpr::ref_func(map_func(function_index)?)
            }
            _ => {
                let expr_bytes = reader
                    .read_bytes(reader.bytes_remaining())
                    .expect("can't fail");
                // ConstExpr introduces its own `End` operand, so we want want to drop it.
                let without_end = &expr_bytes[0..expr_bytes.len() - 1];
                we::ConstExpr::raw(without_end.iter().copied())
            }
        },
    )
}

fn namemap(p: wp::NameMap, is_function: bool) -> Result<we::NameMap, Error> {
    let mut new_name_map = we::NameMap::new();
    for naming in p {
        let naming = naming.map_err(Error::ParseNameMapName)?;
        new_name_map.append(
            if is_function {
                map_func(naming.index)?
            } else {
                naming.index
            },
            naming.name,
        );
    }
    Ok(new_name_map)
}

fn indirectnamemap(p: wp::IndirectNameMap) -> Result<we::IndirectNameMap, Error> {
    let mut new_name_map = we::IndirectNameMap::new();
    for naming in p {
        let naming = naming.map_err(Error::ParseIndirectNameMapName)?;
        new_name_map.append(map_func(naming.index)?, &namemap(naming.names, false)?);
    }
    Ok(new_name_map)
}

#[inline(always)]
fn map_func(func_idx: u32) -> Result<u32, Error> {
    func_idx
        .checked_add(F)
        .ok_or(Error::RemapFunctionIndex(func_idx))
}

'''
'''--- src/lib.rs ---
#![doc = include_str!("../README.mkd")]
#![cfg_attr(finite_wasm_docs, feature(doc_auto_cfg))]

use gas::InstrumentationKind;
#[cfg(feature = "instrument")]
pub use instrument::Error as InstrumentError;
/// A re-export of the prefix_sum_vec crate. Use in implementing [`max_stack::SizeConfig`].
pub use prefix_sum_vec;
use visitors::VisitOperatorWithOffset;
/// A re-export of the wasmparser crate. Use in implementing [`max_stack::SizeConfig`] and
/// [`gas::Config`].
pub use wasmparser;
use wasmparser::BinaryReaderError;

#[cfg(all(test, feature = "wast-tests"))]
mod fuzzers;
pub mod gas;
mod instruction_categories;
#[cfg(feature = "instrument")]
mod instrument;
pub mod max_stack;
mod visitors;

#[doc(hidden)]
#[cfg(feature = "wast-tests")]
pub mod wast_tests {
    pub mod test;
}

#[derive(thiserror::Error, Debug)]
pub enum Error {
    #[error("could not parse a part of the WASM payload")]
    ParsePayload(#[source] BinaryReaderError),
    #[error("could not create a function locals’ reader")]
    LocalsReader(#[source] BinaryReaderError),
    #[error("could not create a function operators’ reader")]
    OperatorReader(#[source] BinaryReaderError),
    #[error("could not visit the function operators")]
    VisitOperators(#[source] BinaryReaderError),
    #[error("could not parse the type section entry")]
    ParseTypes(#[source] BinaryReaderError),
    #[error("could not parse the function section entry")]
    ParseFunctions(#[source] BinaryReaderError),
    #[error("could not parse the global section entry")]
    ParseGlobals(#[source] BinaryReaderError),
    #[error("could not parsse function locals")]
    ParseLocals(#[source] BinaryReaderError),
    #[error("could not parse the imports")]
    ParseImports(#[source] BinaryReaderError),
    #[error("too many functions in the module")]
    TooManyFunctions,
    #[error("could not parse the table section")]
    ParseTable(#[source] BinaryReaderError),
    #[error("could not process locals")]
    ProcessLocals(#[source] max_stack::Error),

    #[error("could not process operator for max_stack analysis")]
    MaxStack(#[source] max_stack::Error),
    #[error("could not process operator for gas analysis")]
    Gas(#[source] gas::Error),
}

/// No config is provided for the analysis, meaning the specific analysis will not run.
pub struct NoConfig;

/// The entry-point type to set-up your finite-wasm analysis.
///
/// This type allows running any number of analyses implemented by this crate. By default, none of
/// the analyses are run. Each can be enabled individually with methods such as
/// [`Self::with_stack`] or [`Self::with_gas`].
///
/// # Examples
///
/// See the [crate root](crate) for an example.
pub struct Analysis<StackConfig, GasCostModel> {
    max_stack_cfg: StackConfig,
    gas_cfg: GasCostModel,
}

impl Analysis<NoConfig, NoConfig> {
    pub fn new() -> Self {
        Self {
            max_stack_cfg: NoConfig,
            gas_cfg: NoConfig,
        }
    }
}

impl<StackConfig, GasCostModel> Analysis<StackConfig, GasCostModel> {
    /// Configure the stack analysis.
    ///
    /// You most likely want to pass in a type that implements the [`max_stack::SizeConfig`] trait.
    /// This can be either by value, by reference or as a dynamic object of some sort.
    pub fn with_stack<NewSC>(self, max_stack_cfg: NewSC) -> Analysis<NewSC, GasCostModel> {
        let Self { gas_cfg, .. } = self;
        Analysis {
            max_stack_cfg,
            gas_cfg,
        }
    }

    /// Configure the gas analysis.
    ///
    /// You most likely want to pass in a type that implements the [`wasmparser::VisitOperator`]
    /// trait. This can be either by value, by reference or as a dynamic object of some sort.
    /// Though do keep in mind, that using a dynamic object may incur a significant performance
    /// penality, as the configuration provided here is accessed for each instruction in the
    /// analyzed module.
    ///
    /// For more information see [`gas::Config`].
    pub fn with_gas<NewGC>(self, gas_cfg: NewGC) -> Analysis<StackConfig, NewGC> {
        let Self { max_stack_cfg, .. } = self;
        Analysis {
            max_stack_cfg,
            gas_cfg,
        }
    }
}

impl<'b, SC: max_stack::Config<'b>, GC: gas::Config<'b>> Analysis<SC, GC> {
    /// Execute the analysis on the provided module.
    pub fn analyze(&mut self, module: &'b [u8]) -> Result<AnalysisOutcome, Error> {
        let mut current_fn_id = 0u32;
        let mut outcome = AnalysisOutcome {
            function_frame_sizes: vec![],
            function_operand_stack_sizes: vec![],
            gas_offsets: vec![],
            gas_costs: vec![],
            gas_kinds: vec![],
        };
        // Reused between functions for speeds.
        let mut gas_state = gas::FunctionState::new();
        let mut stack_state = max_stack::FunctionState::new();
        let mut module_state = max_stack::ModuleState::new();

        let parser = wasmparser::Parser::new(0);
        for payload in parser.parse_all(module) {
            let payload = payload.map_err(Error::ParsePayload)?;
            match payload {
                wasmparser::Payload::ImportSection(reader) => {
                    for import in reader.into_iter() {
                        let import = import.map_err(Error::ParseImports)?;
                        match import.ty {
                            wasmparser::TypeRef::Func(f) => {
                                self.max_stack_cfg.add_function(&mut module_state, f);
                                current_fn_id = current_fn_id
                                    .checked_add(1)
                                    .ok_or(Error::TooManyFunctions)?;
                            }
                            wasmparser::TypeRef::Global(g) => {
                                self.max_stack_cfg
                                    .add_global(&mut module_state, g.content_type);
                            }
                            wasmparser::TypeRef::Table(t) => {
                                self.max_stack_cfg
                                    .add_table(&mut module_state, t.element_type);
                            }
                            wasmparser::TypeRef::Memory(_) => continue,
                            wasmparser::TypeRef::Tag(_) => continue,
                        }
                    }
                }
                wasmparser::Payload::TypeSection(reader) => {
                    for ty in reader {
                        let ty = ty.map_err(Error::ParseTypes)?;
                        self.max_stack_cfg.add_type(&mut module_state, ty);
                    }
                }
                wasmparser::Payload::GlobalSection(reader) => {
                    for global in reader {
                        let global = global.map_err(Error::ParseGlobals)?;
                        self.max_stack_cfg
                            .add_global(&mut module_state, global.ty.content_type);
                    }
                }
                wasmparser::Payload::TableSection(reader) => {
                    for tbl in reader.into_iter() {
                        let tbl = tbl.map_err(Error::ParseTable)?;
                        self.max_stack_cfg
                            .add_table(&mut module_state, tbl.ty.element_type);
                    }
                }
                wasmparser::Payload::FunctionSection(reader) => {
                    for function in reader {
                        let function = function.map_err(Error::ParseFunctions)?;
                        self.max_stack_cfg.add_function(&mut module_state, function);
                    }
                }
                wasmparser::Payload::CodeSectionEntry(function) => {
                    self.max_stack_cfg
                        .populate_locals(&module_state, &mut stack_state, current_fn_id)
                        .map_err(Error::ProcessLocals)?;
                    for local in function.get_locals_reader().map_err(Error::LocalsReader)? {
                        let local = local.map_err(Error::ParseLocals)?;
                        stack_state
                            .add_locals(local.0, local.1)
                            .map_err(Error::ProcessLocals)?;
                    }

                    // Visit the function body.
                    let mut combined_visitor = visitors::JoinVisitor(
                        self.gas_cfg.make_visitor(&mut gas_state),
                        self.max_stack_cfg
                            .make_visitor(&module_state, &mut stack_state),
                    );
                    let mut operators = function
                        .get_operators_reader()
                        .map_err(Error::OperatorReader)?;
                    while !operators.eof() {
                        combined_visitor.set_offset(operators.original_position());
                        let (gas_result, stack_result) = operators
                            .visit_operator(&mut combined_visitor)
                            .map_err(Error::VisitOperators)?;
                        let () = gas_result.map_err(Error::Gas)?;
                        let () = stack_result.map_err(Error::MaxStack)?;
                    }
                    drop(combined_visitor);

                    self.max_stack_cfg
                        .save_outcomes(&mut stack_state, &mut outcome);
                    self.gas_cfg.save_outcomes(&mut gas_state, &mut outcome);
                    current_fn_id = current_fn_id
                        .checked_add(1)
                        .ok_or(Error::TooManyFunctions)?;
                }
                _ => (),
            }
        }
        Ok(outcome)
    }
}

/// The results of parsing and analyzing the module.
///
/// This analysis collects information necessary to implement all of the transformations in one go,
/// so that re-parsing the module multiple times is not necessary.
pub struct AnalysisOutcome {
    /// The sizes of the stack frame for each function in the module, *excluding* imports.
    ///
    /// This includes the things like the function label and the locals that are 0-initialized.
    pub function_frame_sizes: Vec<u64>,
    /// The maximum size of the operand stack for each function in the module, *excluding* imports.
    ///
    /// Throughout the execution the sum of sizes of the operands on the function’s operand stack
    /// will differ, but will never exceed the number here.
    pub function_operand_stack_sizes: Vec<u64>,

    /// The table of offsets for gas instrumentation points.
    ///
    /// This vector is indexed by entries in the code section (that is, it is indexed by the
    /// function index, *excluding* imports).
    pub gas_offsets: Vec<Box<[usize]>>,
    /// The table of gas costs for gas instrumentation points.
    ///
    /// This vector is indexed by entries in the code section (that is, it is indexed by the
    /// function index, *excluding* imports).
    pub gas_costs: Vec<Box<[u64]>>,
    /// The table of instrumentation kinds for gas instrumentation points.
    ///
    /// This vector is indexed by entries in the code section (that is, it is indexed by the
    /// function index, *excluding* imports).
    pub gas_kinds: Vec<Box<[InstrumentationKind]>>,
}

impl AnalysisOutcome {
    /// Modify the provided `wasm` module to enforce gas and stack limits.
    ///
    /// The instrumentation approach provided by this crate has been largely tailored for this
    /// crate’s own testing needs and may not be applicable to every use-case. However the code is
    /// reasonably high quality that it might be useful for development purposes.
    ///
    /// This function will modify the provided core wasm module to introduce three imports:
    ///
    /// * `{env}.finite_wasm_gas`: `(func (params u64))`
    /// * `{env}.finite_wasm_stack`: `(func (params u64 u64))`
    /// * `{env}.finite_wasm_unstack`: `(func (params u64 u64))`
    ///
    /// These functions must be provided by the embedder. The `finite_wasm_gas` should reduce the
    /// pool of remaining gas by the only argument supplied and trap the execution when the gas is
    /// exhausted. When the gas is exhausted the reamining gas pool must be set to 0, as per the
    /// specification.
    ///
    /// The `finite_wasm_stack` and `finite_wasm_unstack` are called with two arguments. The first
    /// argument is the size by which the operands stack increases, or decreases. Second is the
    /// size of the stack reserved or released by the function frame. These host functions must
    /// keep track of the current total stack height and raise a trap if the stack limit is
    /// exceeded.
    #[cfg(feature = "instrument")]
    pub fn instrument(&self, import_env: &str, wasm: &[u8]) -> Result<Vec<u8>, InstrumentError> {
        instrument::InstrumentContext::new(wasm, import_env, self).run()
    }
}

#[cfg(test)]
pub(crate) mod tests {
    pub(crate) struct SizeConfig {
        pub(crate) value_size: u8,
        pub(crate) local_size: u8,
    }

    impl<'a> crate::max_stack::SizeConfig for SizeConfig {
        fn size_of_value(&self, _: wasmparser::ValType) -> u8 {
            self.value_size
        }

        fn size_of_function_activation(
            &self,
            locals: &prefix_sum_vec::PrefixSumVec<wasmparser::ValType, u32>,
        ) -> u64 {
            let locals = locals.max_index().map(|&v| v + 1).unwrap_or(0);
            u64::from(locals) * u64::from(self.local_size)
        }
    }

    impl Default for SizeConfig {
        fn default() -> Self {
            SizeConfig {
                value_size: 9,
                local_size: 5,
            }
        }
    }

    macro_rules! define_fee {
        ($(@$proposal:ident $op:ident $({ $($arg:ident: $argty:ty),* })? => $visit:ident)*) => {
            $(
                fn $visit(&mut self $($(,$arg: $argty)*)?) -> Self::Output { 1 }
            )*
        }
    }

    struct GasConfig;
    impl<'a> wasmparser::VisitOperator<'a> for GasConfig {
        type Output = u64;
        wasmparser::for_each_operator!(define_fee);
    }

    #[test]
    fn dynamic_dispatch_is_possible() {
        let dynamic_size_config = SizeConfig::default();
        let mut dynamic_gas_config = GasConfig;

        let _ = crate::Analysis::new()
            .with_stack(&dynamic_size_config as &dyn crate::max_stack::SizeConfig)
            .analyze(b"");

        let _ = crate::Analysis::new()
            .with_stack(Box::new(dynamic_size_config) as Box<dyn crate::max_stack::SizeConfig>)
            .analyze(b"");

        let _ = crate::Analysis::new()
            .with_gas(&mut dynamic_gas_config)
            .analyze(b"");

        let _ = crate::Analysis::new()
            .with_gas(&mut dynamic_gas_config as &mut dyn wasmparser::VisitOperator<Output = u64>)
            .analyze(b"");

        let _ = crate::Analysis::new()
            .with_gas(
                Box::new(dynamic_gas_config) as Box<dyn wasmparser::VisitOperator<Output = u64>>
            )
            .analyze(b"");
    }
}

'''
'''--- src/max_stack/config.rs ---
use super::Error;
use super::{instruction_visit::Output, FunctionState, ModuleState, Visitor};
use crate::prefix_sum_vec::PrefixSumVec;
use crate::visitors::{self, VisitOperatorWithOffset};
use crate::wasmparser::{RefType, Type, ValType};

/// Configure size of various values that may end up on the stack.
///
/// # Requirements
///
/// * Sizes of nullable (see [`RefType::is_nullable`]) and non-nullable references must match.
///
/// [`RefType::is_nullable`]: wasmparser::RefType::is_nullable
pub trait SizeConfig {
    fn size_of_value(&self, ty: ValType) -> u8;
    fn size_of_function_activation(&self, locals: &PrefixSumVec<ValType, u32>) -> u64;
}

impl<'a, C: SizeConfig + ?Sized> SizeConfig for &'a C {
    fn size_of_value(&self, ty: wasmparser::ValType) -> u8 {
        C::size_of_value(*self, ty)
    }

    fn size_of_function_activation(&self, locals: &PrefixSumVec<ValType, u32>) -> u64 {
        C::size_of_function_activation(*self, locals)
    }
}

impl<'a, C: SizeConfig + ?Sized> SizeConfig for &'a mut C {
    fn size_of_value(&self, ty: wasmparser::ValType) -> u8 {
        C::size_of_value(*self, ty)
    }

    fn size_of_function_activation(&self, locals: &PrefixSumVec<ValType, u32>) -> u64 {
        C::size_of_function_activation(*self, locals)
    }
}

impl<'a, C: SizeConfig + ?Sized> SizeConfig for Box<C> {
    fn size_of_value(&self, ty: wasmparser::ValType) -> u8 {
        C::size_of_value(&*self, ty)
    }

    fn size_of_function_activation(&self, locals: &PrefixSumVec<ValType, u32>) -> u64 {
        C::size_of_function_activation(&*self, locals)
    }
}

impl<'a, C: SizeConfig + ?Sized> SizeConfig for std::sync::Arc<C> {
    fn size_of_value(&self, ty: wasmparser::ValType) -> u8 {
        C::size_of_value(&*self, ty)
    }

    fn size_of_function_activation(&self, locals: &PrefixSumVec<ValType, u32>) -> u64 {
        C::size_of_function_activation(&*self, locals)
    }
}

/// The configuration for the stack analysis.
///
/// Note that this trait is not intended to be implemented directly. Implement [`SizeConfig`]
/// instead. Implementers of `SizeConfig` trait will also implement `max_stack::Config` by
/// definition.
pub trait Config<'b> {
    type StackVisitor<'s>: VisitOperatorWithOffset<'b, Output = Output>
    where
        Self: 's;

    fn make_visitor<'s>(
        &'s self,
        module_state: &'s ModuleState,
        function_state: &'s mut FunctionState,
    ) -> Self::StackVisitor<'s>;

    fn save_outcomes(&self, state: &mut FunctionState, out: &mut crate::AnalysisOutcome);

    fn add_function(&self, state: &mut ModuleState, type_index: u32);
    fn add_global(&self, state: &mut ModuleState, content_type: ValType);
    fn add_table(&self, state: &mut ModuleState, content_type: RefType);
    fn add_type(&self, state: &mut ModuleState, ty: Type);

    fn populate_locals(
        &self,
        module: &ModuleState,
        fn_state: &mut FunctionState,
        fn_idx: u32,
    ) -> Result<(), Error>;
}

impl<'b, S: SizeConfig> Config<'b> for S {
    type StackVisitor<'s> = Visitor<'s, Self> where Self: 's;

    fn make_visitor<'s>(
        &'s self,
        module_state: &'s ModuleState,
        function_state: &'s mut FunctionState,
    ) -> Self::StackVisitor<'s> {
        Visitor {
            offset: 0,
            config: self,
            module_state,
            function_state,
        }
    }

    fn save_outcomes(&self, state: &mut FunctionState, out: &mut crate::AnalysisOutcome) {
        out.function_frame_sizes
            .push(self.size_of_function_activation(&state.locals));
        out.function_operand_stack_sizes.push(state.max_size);
        state.clear();
    }

    fn populate_locals(
        &self,
        module: &ModuleState,
        fn_state: &mut FunctionState,
        fn_idx: u32,
    ) -> Result<(), Error> {
        let function_id_usize =
            usize::try_from(fn_idx).expect("failed converting from u32 to usize");
        let type_id = *module
            .functions
            .get(function_id_usize)
            .ok_or(Error::FunctionIndex(fn_idx))?;
        let type_id_usize =
            usize::try_from(type_id).map_err(|e| Error::TypeIndexRange(type_id, e))?;
        let fn_type = module
            .types
            .get(type_id_usize)
            .ok_or(Error::TypeIndex(type_id))?;

        match fn_type {
            wasmparser::Type::Func(fnty) => {
                for param in fnty.params() {
                    fn_state.add_locals(1, *param)?;
                }
            }
        }
        Ok(())
    }

    fn add_function(&self, state: &mut ModuleState, type_index: u32) {
        state.functions.push(type_index);
    }

    fn add_global(&self, state: &mut ModuleState, content_type: ValType) {
        state.globals.push(content_type);
    }

    fn add_table(&self, state: &mut ModuleState, content_type: RefType) {
        state.tables.push(content_type);
    }

    fn add_type(&self, state: &mut ModuleState, ty: Type) {
        state.types.push(ty);
    }
}

impl<'b> Config<'b> for crate::NoConfig {
    type StackVisitor<'s> = visitors::NoOpVisitor<Output>;

    fn make_visitor<'s>(
        &'s self,
        _: &'s ModuleState,
        _: &'s mut FunctionState,
    ) -> Self::StackVisitor<'s> {
        visitors::NoOpVisitor(Ok(()))
    }

    fn save_outcomes(&self, _: &mut FunctionState, _: &mut crate::AnalysisOutcome) {}

    fn add_function(&self, _: &mut ModuleState, _: u32) {}
    fn add_global(&self, _: &mut ModuleState, _: ValType) {}
    fn add_table(&self, _: &mut ModuleState, _: RefType) {}
    fn add_type(&self, _: &mut ModuleState, _: Type) {}
    fn populate_locals(&self, _: &ModuleState, _: &mut FunctionState, _: u32) -> Result<(), Error> {
        Ok(())
    }
}

'''
'''--- src/max_stack/error.rs ---
use std::num::TryFromIntError;

#[derive(thiserror::Error, Debug, Clone)]
pub enum Error {
    // These codes are a result of a malformed input (e.g. validation has not been run)
    #[error("frame stack is too short at offset {0}")]
    TruncatedFrameStack(usize),
    #[error("operand stack is too short at offset {0}")]
    TruncatedOperandStack(usize),
    #[error("empty stack at offset {0}")]
    EmptyStack(usize),
    #[error("type index {0} is out of range")]
    TypeIndexRange(u32, #[source] TryFromIntError),
    #[error("type index {0} refers to a non-existent type")]
    TypeIndex(u32),
    #[error("function index {0} is out of range")]
    FunctionIndexRange(u32, #[source] TryFromIntError),
    #[error("function index {0} refers to a non-existent type")]
    FunctionIndex(u32),
    #[error("global index {0} is out of range")]
    GlobalIndexRange(u32, #[source] TryFromIntError),
    #[error("global index {0} refers to a non-existent global")]
    GlobalIndex(u32),
    #[error("table index {0} is out of range")]
    TableIndexRange(u32, #[source] TryFromIntError),
    #[error("table index {0} refers to a non-existent table")]
    TableIndex(u32),
    #[error("type of local {0} could cannot be found")]
    LocalIndex(u32),
    #[error("too many frames in the function")]
    TooManyFrames,
    #[error("could not process function locals")]
    TooManyLocals(#[source] prefix_sum_vec::TryPushError),
    #[error("the exceptions proposal is not supported (at offset {0})")]
    ExceptionsNotSupported(usize),
    #[error("the memory control proposal is not supported (at offset {0})")]
    MemoryControlNotSupported(usize),
    #[error("the garbage collection proposal is not supported (at offset {0})")]
    GcNotSupported(usize),
    #[error("type is too large (at offset {0})")]
    TypeTooLarge(usize),
}

'''
'''--- src/max_stack/instruction_visit.rs ---
use super::{Error, SizeConfig, Visitor};
use crate::instruction_categories as gen;
use wasmparser::{BlockType, BrTable, HeapType, MemArg, RefType, ValType, VisitOperator};

pub(crate) type Output = Result<(), Error>;

macro_rules! instruction_category {
    ($($type:ident . const = $($insn:ident, $param: ty)|* ;)*) => {
        $($(fn $insn(&mut self, _: $param) -> Self::Output {
            self.visit_const(ValType::$type)
        })*)*
    };
    ($($type:ident . unop = $($insn:ident)|* ;)*) => {
        $($(fn $insn(&mut self) -> Self::Output {
            self.visit_unop()
        })*)*
    };
    ($($type:ident . binop = $($insn:ident)|* ;)*) => {
        $($(fn $insn(&mut self) -> Self::Output {
            self.visit_binop()
        })*)*
    };
    ($($type:ident . testop = $($insn:ident)|* ;)*) => {
        $($(fn $insn(&mut self) -> Self::Output {
            self.visit_testop()
        })*)*
    };

    ($($type:ident . relop = $($insn:ident)|* ;)*) => {
        $($(fn $insn(&mut self) -> Self::Output {
            self.visit_relop()
        })*)*
    };

    ($($type:ident . cvtop = $($insn:ident)|* ;)*) => {
        $($(fn $insn(&mut self) -> Self::Output {
            self.visit_cvtop(ValType::$type)
        })*)*
    };

    ($($type:ident . load = $($insn:ident)|* ;)*) => {
        $($(fn $insn(&mut self, _: MemArg) -> Self::Output {
            self.visit_load(ValType::$type)
        })*)*
    };

    ($($type:ident . store = $($insn:ident)|* ;)*) => {
        $($(fn $insn(&mut self, _: MemArg) -> Self::Output {
            self.visit_store()
        })*)*
    };

    ($($type:ident . loadlane = $($insn:ident)|* ;)*) => {
        $($(fn $insn(&mut self, _: MemArg, _: u8) -> Self::Output {
            self.visit_load_lane()
        })*)*
    };

    ($($type:ident . storelane = $($insn:ident)|* ;)*) => {
        $($(fn $insn(&mut self, _: MemArg, _: u8) -> Self::Output {
            self.visit_store_lane()
        })*)*
    };

    ($($type:ident . vternop = $($insn:ident)|* ;)*) => {
        $($(fn $insn(&mut self) -> Self::Output {
            self.visit_vternop()
        })*)*
    };

    ($($type:ident . vrelop = $($insn:ident)|* ;)*) => {
        $($(fn $insn(&mut self) -> Self::Output {
            self.visit_vrelop()
        })*)*
    };

    ($($type:ident . vishiftop = $($insn:ident)|* ;)*) => {
        $($(fn $insn(&mut self) -> Self::Output {
            self.visit_vishiftop()
        })*)*
    };

    ($($type:ident . vinarrowop = $($insn:ident)|* ;)*) => {
        $($(fn $insn(&mut self) -> Self::Output {
            self.visit_vinarrowop()
        })*)*
    };

    ($($type:ident . vbitmask = $($insn:ident)|* ;)*) => {
        $($(fn $insn(&mut self) -> Self::Output {
            self.visit_vbitmask()
        })*)*
    };

    ($($type:ident . splat = $($insn:ident)|* ;)*) => {
        $($(fn $insn(&mut self) -> Self::Output {
            self.visit_splat()
        })*)*
    };

    ($($type:ident . replacelane = $($insn:ident)|* ;)*) => {
        $($(fn $insn(&mut self, _: u8) -> Self::Output {
            self.visit_replace_lane()
        })*)*
    };

    ($($type:ident . extractlane = $($insn:ident)|* ;)*) => {
        $($(fn $insn(&mut self, _: u8) -> Self::Output {
            self.visit_extract_lane(ValType::$type)
        })*)*
    };

    ($($type:ident . atomic.rmw = $($insn:ident)|* ;)*) => {
        $($(fn $insn(&mut self, _: MemArg) -> Self::Output {
            self.visit_atomic_rmw(ValType::$type)
        })*)*
    };

    ($($type:ident . atomic.cmpxchg = $($insn:ident)|* ;)*) => {
        $($(fn $insn(&mut self, _: MemArg) -> Self::Output {
            self.visit_atomic_cmpxchg(ValType::$type)
        })*)*
    };
}

impl<'a, 's, 'cfg, Cfg: SizeConfig + ?Sized> VisitOperator<'a> for Visitor<'s, Cfg> {
    type Output = Output;

    gen::r#const!(instruction_category);

    fn visit_ref_null(&mut self, t: HeapType) -> Self::Output {
        // [] -> [(ref null t)]
        self.push(ValType::Ref(
            RefType::new(true, t).ok_or(Error::TypeTooLarge(self.offset))?,
        ));
        Ok(())
    }

    fn visit_ref_as_non_null(&mut self) -> Self::Output {
        // [(ref null ht)] -> [(ref ht)]
        Ok(())
    }

    fn visit_ref_func(&mut self, _: u32) -> Self::Output {
        self.visit_ref_null(HeapType::Func)
    }

    gen::unop!(instruction_category);
    gen::binop!(instruction_category);
    gen::vishiftop!(instruction_category);
    gen::testop!(instruction_category);
    gen::relop!(instruction_category);
    gen::cvtop!(instruction_category);
    gen::load!(instruction_category);
    gen::loadlane!(instruction_category);
    gen::store!(instruction_category);
    gen::storelane!(instruction_category);
    gen::replacelane!(instruction_category);
    gen::extractlane!(instruction_category);
    gen::vternop!(instruction_category);
    gen::vrelop!(instruction_category);
    gen::vinarrowop!(instruction_category);
    gen::vbitmask!(instruction_category);
    gen::splat!(instruction_category);
    gen::atomic_rmw!(instruction_category);
    gen::atomic_cmpxchg!(instruction_category);

    fn visit_i8x16_shuffle(&mut self, _: [u8; 16]) -> Self::Output {
        // i8x16.shuffle laneidx^16 : [v128 v128] → [v128]
        self.pop()?;
        Ok(())
    }

    fn visit_memory_atomic_notify(&mut self, _: MemArg) -> Self::Output {
        // [i32 i32] -> [i32]
        self.pop()?;
        Ok(())
    }

    fn visit_memory_atomic_wait32(&mut self, _: MemArg) -> Self::Output {
        // [i32 i32 i64] -> [i32]
        self.pop_many(2)?;
        Ok(())
    }

    fn visit_memory_atomic_wait64(&mut self, _: MemArg) -> Self::Output {
        // [i32 i64 i64] -> [i32]
        self.pop_many(2)?;
        Ok(())
    }

    fn visit_atomic_fence(&mut self) -> Self::Output {
        // https://github.com/WebAssembly/threads/blob/main/proposals/threads/Overview.md#fence-operator
        // [] -> []

        // Function body intentionally left empty
        Ok(())
    }

    fn visit_local_get(&mut self, local_index: u32) -> Self::Output {
        // [] → [t]
        let local_type = self
            .function_state
            .locals
            .get(&local_index)
            .ok_or(Error::LocalIndex(local_index))?;
        self.push(*local_type);
        Ok(())
    }

    fn visit_local_set(&mut self, _: u32) -> Self::Output {
        // [t] → []
        self.pop()?;
        Ok(())
    }

    fn visit_local_tee(&mut self, _: u32) -> Self::Output {
        // [t] → [t]
        Ok(())
    }

    fn visit_global_get(&mut self, global: u32) -> Self::Output {
        // [] → [t]
        let global_usize =
            usize::try_from(global).map_err(|e| Error::GlobalIndexRange(global, e))?;
        let global_ty = self
            .module_state
            .globals
            .get(global_usize)
            .ok_or(Error::GlobalIndex(global))?;
        self.push(*global_ty);
        Ok(())
    }

    fn visit_global_set(&mut self, _: u32) -> Self::Output {
        // [t] → []
        self.pop()?;
        Ok(())
    }

    fn visit_memory_size(&mut self, _: u32, _: u8) -> Self::Output {
        // [] → [i32]
        self.push(ValType::I32);
        Ok(())
    }

    fn visit_memory_grow(&mut self, _: u32, _: u8) -> Self::Output {
        // [i32] → [i32]

        // Function body intentionally left empty.
        Ok(())
    }

    fn visit_memory_fill(&mut self, _: u32) -> Self::Output {
        // [i32 i32 i32] → []
        self.pop_many(3)?;
        Ok(())
    }

    fn visit_memory_init(&mut self, _: u32, _: u32) -> Self::Output {
        // [i32 i32 i32] → []
        self.pop_many(3)?;
        Ok(())
    }

    fn visit_memory_copy(&mut self, _: u32, _: u32) -> Self::Output {
        // [i32 i32 i32] → []
        self.pop_many(3)?;
        Ok(())
    }

    fn visit_data_drop(&mut self, _: u32) -> Self::Output {
        // [] → []
        Ok(())
    }

    fn visit_table_get(&mut self, table: u32) -> Self::Output {
        // [i32] → [t]
        let table_usize = usize::try_from(table).map_err(|e| Error::TableIndexRange(table, e))?;
        let table_ty = *self
            .module_state
            .tables
            .get(table_usize)
            .ok_or(Error::TableIndex(table))?;
        self.pop()?;
        self.push(ValType::Ref(table_ty));
        Ok(())
    }

    fn visit_table_set(&mut self, _: u32) -> Self::Output {
        // [i32 t] → []
        self.pop_many(2)?;
        Ok(())
    }

    fn visit_table_size(&mut self, _: u32) -> Self::Output {
        // [] → [i32]
        self.push(ValType::I32);
        Ok(())
    }

    fn visit_table_grow(&mut self, _: u32) -> Self::Output {
        // [t i32] → [i32]
        self.pop_many(2)?;
        self.push(ValType::I32);
        Ok(())
    }

    fn visit_table_fill(&mut self, _: u32) -> Self::Output {
        // [i32 t i32] → []
        self.pop_many(3)?;
        Ok(())
    }

    fn visit_table_copy(&mut self, _: u32, _: u32) -> Self::Output {
        // [i32 i32 i32] → []
        self.pop_many(3)?;
        Ok(())
    }

    fn visit_table_init(&mut self, _: u32, _: u32) -> Self::Output {
        // [i32 i32 i32] → []
        self.pop_many(3)?;
        Ok(())
    }

    fn visit_elem_drop(&mut self, _: u32) -> Self::Output {
        // [] → []
        Ok(())
    }

    fn visit_select(&mut self) -> Self::Output {
        // [t t i32] -> [t]
        self.pop_many(2)?;
        Ok(())
    }

    fn visit_typed_select(&mut self, _: ValType) -> Self::Output {
        // [t t i32] -> [t]
        self.pop_many(2)?;
        Ok(())
    }

    fn visit_drop(&mut self) -> Self::Output {
        // [t] → []
        self.pop()?;
        Ok(())
    }

    fn visit_nop(&mut self) -> Self::Output {
        // [] → []
        Ok(())
    }

    fn visit_call(&mut self, function_index: u32) -> Self::Output {
        self.visit_function_call(self.function_type_index(function_index)?)
    }

    fn visit_call_ref(&mut self, type_index: u32) -> Self::Output {
        self.visit_function_call(type_index)
    }

    fn visit_call_indirect(&mut self, type_index: u32, _: u32, _: u8) -> Self::Output {
        self.visit_function_call(type_index)
    }

    fn visit_return_call(&mut self, function_index: u32) -> Self::Output {
        self.visit_return_call_type_index(self.function_type_index(function_index)?)
    }

    fn visit_return_call_ref(&mut self, ty: u32) -> Self::Output {
        self.visit_return_call_type_index(ty)
    }

    fn visit_return_call_indirect(&mut self, type_index: u32, _: u32) -> Self::Output {
        self.visit_return_call_type_index(type_index)
    }

    fn visit_unreachable(&mut self) -> Self::Output {
        // [*] → [*]  (stack-polymorphic)
        self.make_polymorphic();
        Ok(())
    }

    fn visit_block(&mut self, blockty: BlockType) -> Self::Output {
        // block blocktype instr* end : [t1*] → [t2*]
        self.with_block_types(blockty, |this, params, _| {
            this.new_frame(blockty, params.len())
        })?;
        Ok(())
    }

    fn visit_loop(&mut self, blockty: BlockType) -> Self::Output {
        // loop blocktype instr* end : [t1*] → [t2*]
        self.with_block_types(blockty, |this, params, _| {
            this.new_frame(blockty, params.len())
        })?;
        Ok(())
    }

    fn visit_if(&mut self, blockty: BlockType) -> Self::Output {
        // if blocktype instr* else instr* end : [t1* i32] → [t2*]
        self.pop()?;
        self.with_block_types(blockty, |this, params, _| {
            this.new_frame(blockty, params.len())
        })?;
        Ok(())
    }

    fn visit_else(&mut self) -> Self::Output {
        if let Some(frame) = self.end_frame()? {
            self.with_block_types(frame.block_type, |this, params, _| {
                this.new_frame(frame.block_type, 0)?;
                for param in params {
                    this.push(*param);
                }
                Ok(())
            })?;
            Ok(())
        } else {
            return Err(Error::TruncatedFrameStack(self.offset));
        }
    }

    fn visit_end(&mut self) -> Self::Output {
        if let Some(frame) = self.end_frame()? {
            self.with_block_types(frame.block_type, |this, _, results| {
                Ok(for result in results {
                    this.push(*result);
                })
            })?;
            Ok(())
        } else {
            // Returning from the function. Malformed WASM modules may have trailing instructions,
            // but we do ignore processing them in the operand feed loop. For that reason,
            // replacing `top_stack` with some sentinel value would work okay.
            Ok(())
        }
    }

    fn visit_br(&mut self, _: u32) -> Self::Output {
        // [t1* t*] → [t2*]  (stack-polymorphic)
        self.make_polymorphic();
        Ok(())
    }

    fn visit_br_if(&mut self, _: u32) -> Self::Output {
        // [t* i32] → [t*]

        // There are two things that could happen here.
        //
        // First is when the condition operand is true. This instruction executed as-if it was a
        // plain `br` in this place. This won’t result in the stack size of this frame increasing
        // again. The continuation of the destination label `L` will have an arity of `n`. As part
        // of executing `br`, `n` operands are popped from the operand stack, Then a number of
        // labels/frames are popped from the stack, along with the values contained therein.
        // Finally `n` operands are pushed back onto the operand stack as the “return value” of the
        // block. As thus, executing a `(br_if (i32.const 1))` will _always_ result in a smaller
        // operand stack, and so it is uninteresting to explore this branch in isolation.
        //
        // Second is if the condition was actually false and the rest of this block is executed,
        // which can potentially later increase the size of this current frame. We’re largely
        // interested in this second case, so we don’t really need to do anything much more than…
        self.pop()?;
        // …the condition.
        Ok(())
    }

    fn visit_br_on_null(&mut self, _relative_depth: u32) -> Self::Output {
        // br_on_null $l : [t* (ref null ht)] -> [t* (ref ht)]
        //
        // Branches to $l on null, otherwise returns operand as non-null. See the comment above for
        // why we don't need to pop or push back anything.
        Ok(())
    }

    fn visit_br_on_non_null(&mut self, relative_depth: u32) -> Self::Output {
        // br_on_non_null $l : [t* (ref null ht)] -> [t*]
        //
        // Branches to $l if operand is not null, passing the operand itself under non-null type
        // (along with potential additional operands).
        //
        self.visit_br_if(relative_depth)
    }

    fn visit_br_table(&mut self, _: BrTable) -> Self::Output {
        // [t1* t* i32] → [t2*]  (stack-polymorphic)
        self.make_polymorphic();
        Ok(())
    }

    fn visit_return(&mut self) -> Self::Output {
        // This behaves as-if a `br` to the outer-most block.

        // NB: self.frames.len() is actually 1 less than a number of frames, due to our maintaining
        // a `self.current_frame`.
        let branch_depth =
            u32::try_from(self.function_state.frames.len()).map_err(|_| Error::TooManyFrames)?;
        self.visit_br(branch_depth)
    }

    fn visit_try(&mut self, _: BlockType) -> Self::Output {
        Err(Error::ExceptionsNotSupported(self.offset))
    }

    fn visit_rethrow(&mut self, _: u32) -> Self::Output {
        Err(Error::ExceptionsNotSupported(self.offset))
    }

    fn visit_throw(&mut self, _: u32) -> Self::Output {
        Err(Error::ExceptionsNotSupported(self.offset))
    }

    fn visit_delegate(&mut self, _: u32) -> Self::Output {
        Err(Error::ExceptionsNotSupported(self.offset))
    }

    fn visit_catch(&mut self, _: u32) -> Self::Output {
        Err(Error::ExceptionsNotSupported(self.offset))
    }

    fn visit_catch_all(&mut self) -> Self::Output {
        Err(Error::ExceptionsNotSupported(self.offset))
    }

    fn visit_memory_discard(&mut self, _: u32) -> Self::Output {
        Err(Error::MemoryControlNotSupported(self.offset))
    }

    fn visit_i31_new(&mut self) -> Self::Output {
        Err(Error::GcNotSupported(self.offset))
    }

    fn visit_i31_get_s(&mut self) -> Self::Output {
        Err(Error::GcNotSupported(self.offset))
    }

    fn visit_i31_get_u(&mut self) -> Self::Output {
        Err(Error::GcNotSupported(self.offset))
    }
}

impl<'b, 's, Cfg: SizeConfig> crate::visitors::VisitOperatorWithOffset<'b> for Visitor<'s, Cfg> {
    fn set_offset(&mut self, offset: usize) {
        self.offset = offset;
    }
}

'''
'''--- src/max_stack/mod.rs ---
//! Analysis of the maximum amount of stack used by a function.
//!
//! This is a single pass linear-time algorithm.

pub use config::{Config, SizeConfig};
pub use error::Error;
use instruction_visit::Output;
use prefix_sum_vec::PrefixSumVec;
use wasmparser::{BlockType, ValType};

mod config;
mod error;
mod instruction_visit;
#[cfg(test)]
mod test;

/// The information about the whole-module necessary for the `max_stack` analysis.
///
/// This structure maintains the information gathered when parsing type, globals, tables and
/// function sections.
pub struct ModuleState {
    functions: Vec<u32>,
    types: Vec<wasmparser::Type>,
    globals: Vec<wasmparser::ValType>,
    tables: Vec<wasmparser::RefType>,
}

impl ModuleState {
    pub fn new() -> Self {
        Self {
            functions: vec![],
            types: vec![],
            globals: vec![],
            tables: vec![],
        }
    }
}

/// The per-function state used by the [`Visitor`].
///
/// This type maintains the state accumulated during the analysis of a single function in a module.
/// If the same instance of this `FunctionState` is used to analyze multiple functions, it will
/// result in re-use of the backing allocations, and thus an improved performance.
pub struct FunctionState {
    locals: PrefixSumVec<wasmparser::ValType, u32>,

    /// Sizes of the operands currently pushed to the operand stack within this function.
    ///
    /// This is an unfortunate requirement for this analysis – some instructions are
    /// parametric (that is, they don’t specify the type of values they operate on), which
    /// means that any analysis must maintain a stack of operand information in order to be
    /// able to tell what types these instructions will operate on.
    ///
    /// A particular example here is a `drop` – given a code sequence such as…
    ///
    /// ```wast
    /// (i32.const 42)
    /// (i64.const 42)
    /// drop
    /// (f32.const 42.0)
    /// ```
    ///
    /// …it is impossible to tell what is going to be the effect of `drop` on the overall
    /// maximum size of the frame unless an accurate representation of the operand stack is
    /// maintained at all times.
    ///
    /// Fortunately, we don’t exactly need to maintain the _types_, only their sizes suffice.
    operands: Vec<u8>,
    /// Sum of all values in the `operands` field above.
    size: u64,
    /// Maximum observed value for the `size` field above.
    pub(crate) max_size: u64,

    /// The stack of frames (as created by operations such as `block`).
    frames: Vec<Frame>,
    /// The top-most frame.
    ///
    /// This aids quicker access at a cost of some special-casing for the very last `end` operator.
    current_frame: Frame,
}

impl FunctionState {
    pub fn new() -> Self {
        Self {
            locals: PrefixSumVec::new(),
            operands: vec![],
            size: 0,
            max_size: 0,
            frames: vec![],
            current_frame: Frame {
                height: 0,
                block_type: BlockType::Empty,
                stack_polymorphic: false,
            },
        }
    }

    pub(crate) fn clear(&mut self) {
        self.locals.clear();
        self.operands.clear();
        self.size = 0;
        self.max_size = 0;
        self.frames.clear();
        self.current_frame = Frame {
            height: 0,
            block_type: BlockType::Empty,
            stack_polymorphic: false,
        };
    }

    pub(crate) fn add_locals(&mut self, count: u32, ty: wasmparser::ValType) -> Result<(), Error> {
        self.locals
            .try_push_more(count, ty)
            .map_err(Error::TooManyLocals)
    }
}

#[derive(Debug)]
pub(crate) struct Frame {
    /// Operand stack height at the time this frame was entered.
    ///
    /// This way no matter how the operand stack is modified during the execution of this frame, we
    /// can always reset the operand stack back to this specific height when the frame terminates.
    pub(crate) height: usize,

    /// Type of the block representing this frame.
    ///
    /// The parameters are below height and get popped when the frame terminates. Results get
    /// pushed back onto the operand stack.
    pub(crate) block_type: BlockType,

    /// Is the operand stack for the remainder of this frame considered polymorphic?
    ///
    /// Once the stack becomes polymorphic, the only way for it to stop being polymorphic is to pop
    /// the frames within which the stack is polymorphic.
    ///
    /// Note, that unlike validation, for the purposes of this analysis stack polymorphism is
    /// somewhat more lax. For example, validation algorithm will readly reject a function like
    /// `(func (unreachable) (i64.const 0) (i32.add))`, because at the time `i32.add` is evaluated
    /// the stack is `[t* i64]`, which does not unify with `[i32 i32] -> [i32]` expected by
    /// `i32.add`, despite being polymorphic. For the purposes of this analysis we do not keep
    /// track of the stack contents to that level of detail – all we care about is whether the
    /// stack is polymorphic at all. We then skip any tracking of stack operations for any
    /// instruction interacting with a polymorphic stack, as those instructions are effectively
    /// unreachable.
    ///
    /// See `stack-polymorphic` in the wasm-core specification for an extended explanation.
    pub(crate) stack_polymorphic: bool,
}

/// The core algorihtm of the `max_stack` analysis.
pub struct Visitor<'s, Cfg: ?Sized> {
    pub(crate) offset: usize,

    pub(crate) config: &'s Cfg,

    pub(crate) module_state: &'s ModuleState,
    pub(crate) function_state: &'s mut FunctionState,
}

impl<'b, 's, Cfg: SizeConfig + ?Sized> Visitor<'s, Cfg> {
    fn function_type_index(&self, function_index: u32) -> Result<u32, Error> {
        let function_index_usize = usize::try_from(function_index)
            .map_err(|e| Error::FunctionIndexRange(function_index, e))?;
        self.module_state
            .functions
            .get(function_index_usize)
            .copied()
            .ok_or(Error::FunctionIndex(function_index))
    }

    fn type_params_results(&self, type_idx: u32) -> Result<(&'s [ValType], &'s [ValType]), Error> {
        let type_idx_usize =
            usize::try_from(type_idx).map_err(|e| Error::TypeIndexRange(type_idx, e))?;
        match self
            .module_state
            .types
            .get(type_idx_usize)
            .ok_or(Error::TypeIndex(type_idx))?
        {
            wasmparser::Type::Func(fnty) => Ok((fnty.params(), fnty.results())),
        }
    }

    fn with_block_types<F>(&mut self, block_type: BlockType, cb: F) -> Result<(), Error>
    where
        F: FnOnce(&mut Self, &[ValType], &[ValType]) -> Result<(), Error>,
    {
        match block_type {
            BlockType::Empty => cb(self, &[], &[]),
            BlockType::Type(result) => cb(self, &[], &[result]),
            BlockType::FuncType(type_index) => {
                let (params, results) = self.type_params_results(type_index)?;
                cb(self, params, results)
            }
        }
    }

    /// Create a new frame on the frame stack.
    ///
    /// `shift_operands` will take the provided number of operands off the operand stack and place
    /// them into the newly created frame. This is useful for various block instructions with
    /// parameters, where the naive approach would be to pop the parameters, push the frame, and
    /// push the same parameters that have been just pooped back onto the operand stack.
    fn new_frame(&mut self, block_type: BlockType, shift_operands: usize) -> Result<(), Error> {
        let stack_polymorphic = self.function_state.current_frame.stack_polymorphic;
        let height = if stack_polymorphic {
            self.function_state.operands.len()
        } else {
            self.function_state
                .operands
                .len()
                .checked_sub(shift_operands)
                .ok_or(Error::EmptyStack(self.offset))?
        };
        self.function_state.frames.push(std::mem::replace(
            &mut self.function_state.current_frame,
            Frame {
                height,
                block_type,
                stack_polymorphic,
            },
        ));
        Ok(())
    }

    /// Terminate the current frame.
    ///
    /// If the frame is not the function-level frame, it will be returned.
    ///
    /// As part of this procedure, the operand stack will be reset to the same height at which the
    /// frame was created.
    ///
    /// Callers are responsible for pushing the block results themselves.
    fn end_frame(&mut self) -> Result<Option<Frame>, Error> {
        if let Some(frame) = self.function_state.frames.pop() {
            let frame = std::mem::replace(&mut self.function_state.current_frame, frame);
            let to_pop = self
                .function_state
                .operands
                .len()
                .checked_sub(frame.height)
                .ok_or(Error::TruncatedOperandStack(self.offset))?;
            self.pop_many(to_pop)?;
            Ok(Some(frame))
        } else {
            Ok(None)
        }
    }

    /// Mark the current frame as polymorphic.
    fn make_polymorphic(&mut self) {
        self.function_state.current_frame.stack_polymorphic = true;
    }

    fn push(&mut self, t: ValType) {
        if !self.function_state.current_frame.stack_polymorphic {
            let value_size = self.config.size_of_value(t);
            self.function_state.operands.push(value_size);
            self.function_state.size += u64::from(value_size);
            self.function_state.max_size =
                std::cmp::max(self.function_state.size, self.function_state.max_size);
        }
    }

    fn pop(&mut self) -> Result<(), Error> {
        if !self.function_state.current_frame.stack_polymorphic {
            let operand_size = u64::from(
                self.function_state
                    .operands
                    .pop()
                    .ok_or(Error::EmptyStack(self.offset))?,
            );
            self.function_state.size = self
                .function_state
                .size
                .checked_sub(operand_size)
                .expect("stack size is going negative");
        }
        Ok(())
    }

    fn pop_many(&mut self, count: usize) -> Result<(), Error> {
        if count == 0 || self.function_state.current_frame.stack_polymorphic {
            Ok(())
        } else {
            let operand_count = self.function_state.operands.len();
            let split_point = operand_count
                .checked_sub(count)
                .ok_or(Error::EmptyStack(self.offset))?;
            let size: u64 = self
                .function_state
                .operands
                .drain(split_point..)
                .map(u64::from)
                .sum();
            self.function_state.size = self
                .function_state
                .size
                .checked_sub(size)
                .expect("stack size is going negative");
            Ok(())
        }
    }

    fn visit_const(&mut self, t: ValType) -> Output {
        // [] → [t]
        self.push(t);
        Ok(())
    }

    fn visit_unop(&mut self) -> Output {
        // [t] -> [t]

        // Function body intentionally left empty (pops and immediately pushes the same type back)
        Ok(())
    }

    fn visit_binop(&mut self) -> Output {
        // [t t] -> [t]
        self.pop()?;
        Ok(())
    }

    fn visit_testop(&mut self) -> Output {
        // [t] -> [i32]
        self.pop()?;
        self.push(ValType::I32);
        Ok(())
    }

    fn visit_relop(&mut self) -> Output {
        // [t t] -> [i32]
        self.pop_many(2)?;
        self.push(ValType::I32);
        Ok(())
    }

    fn visit_cvtop(&mut self, result_ty: ValType) -> Output {
        // t2.cvtop_t1_sx? : [t1] -> [t2]
        self.pop()?;
        self.push(result_ty);
        Ok(())
    }

    fn visit_vternop(&mut self) -> Output {
        // [v128 v128 v128] → [v128]
        self.pop_many(2)?;
        Ok(())
    }

    fn visit_vrelop(&mut self) -> Output {
        // [v128 v128] -> [v128]
        self.visit_binop()
    }

    fn visit_vishiftop(&mut self) -> Output {
        // [v128 i32] -> [v128]
        self.pop()?;
        Ok(())
    }

    fn visit_vinarrowop(&mut self) -> Output {
        // [v128 v128] -> [v128]
        self.pop()?;
        Ok(())
    }

    fn visit_vbitmask(&mut self) -> Output {
        // [v128] -> [i32]
        self.pop()?;
        self.push(ValType::I32);
        Ok(())
    }

    fn visit_splat(&mut self) -> Output {
        // [unpacked(t)] -> [v128]
        self.pop()?;
        self.push(ValType::V128);
        Ok(())
    }

    fn visit_replace_lane(&mut self) -> Output {
        // shape.replace_lane laneidx : [v128 unpacked(shape)] → [v128]
        self.pop()?;
        Ok(())
    }

    fn visit_extract_lane(&mut self, unpacked_shape: ValType) -> Output {
        // txN.extract_lane_sx ? laneidx : [v128] → [unpacked(shape)]
        self.pop()?;
        self.push(unpacked_shape);
        Ok(())
    }

    fn visit_load(&mut self, t: ValType) -> Output {
        // t.load memarg           : [i32] → [t]
        // t.loadN_sx memarg       : [i32] → [t]
        // v128.loadNxM_sx memarg  : [i32] → [v128]
        // v128.loadN_splat memarg : [i32] → [v128]
        // v128.loadN_zero memarg  : [i32] → [v128]
        // t.atomic.load memarg    : [i32] → [t]
        // t.atomic.load memargN_u : [i32] → [t]
        self.pop()?;
        self.push(t);
        Ok(())
    }

    fn visit_load_lane(&mut self) -> Output {
        // v128.loadN_lane memarg laneidx : [i32 v128] → [v128]
        self.pop_many(2)?;
        self.push(ValType::V128);
        Ok(())
    }

    fn visit_store(&mut self) -> Output {
        // t.store memarg           : [i32 t] → []
        // t.storeN memarg          : [i32 t] → []
        // t.atomic.store memarg    : [i32 t] → []
        // t.atomic.store memargN_u : [i32 t] → []
        self.pop_many(2)?;
        Ok(())
    }

    fn visit_store_lane(&mut self) -> Output {
        // v128.storeN_lane memarg laneidx : [i32 v128] → []
        self.pop_many(2)?;
        Ok(())
    }

    fn visit_atomic_rmw(&mut self, t: ValType) -> Output {
        // t.atomic.rmw.atop memarg : [i32 t] → [t]
        // t.atomic.rmwN.atop_u memarg : [i32 t] → [t]
        self.pop_many(2)?;
        self.push(t);
        Ok(())
    }

    fn visit_atomic_cmpxchg(&mut self, t: ValType) -> Output {
        // t.atomic.rmw.cmpxchg : [i32 t t] → [t]
        // t.atomic.rmwN.cmpxchg_u : [i32 t t] → [t]
        self.pop_many(3)?;
        self.push(t);
        Ok(())
    }

    fn visit_function_call(&mut self, type_index: u32) -> Output {
        let (params, results) = self.type_params_results(type_index)?;
        self.pop_many(params.len())?;
        for result_ty in results {
            self.push(*result_ty);
        }
        Ok(())
    }

    fn visit_return_call_type_index(&mut self, _type_index: u32) -> Output {
        // `return_call` behaves as-if a regular `return` followed by the `call`. For the purposes
        // of modelling the frame size of the _current_ function, only the `return` portion of this
        // computation is relevant (as it makes the stack polymorphic)
        <Self as wasmparser::VisitOperator>::visit_return(self)
    }
}

'''
'''--- src/max_stack/test.rs ---
use super::{Error, Frame, FunctionState, ModuleState};
use crate::max_stack::Config;
use crate::tests::SizeConfig as TestConfig;
use wasmparser::{BlockType, RefType, ValType};

fn new_state() -> (TestConfig, ModuleState, FunctionState) {
    (
        TestConfig::default(),
        ModuleState::new(),
        FunctionState::new(),
    )
}

#[test]
fn test_function_type_index_oob() {
    let (config, mut mstate, mut fnstate) = new_state();
    mstate.functions = vec![1];
    mstate.types = vec![wasmparser::Type::Func(wasmparser::FuncType::new([], []))];
    let visitor = config.make_visitor(&mstate, &mut fnstate);

    assert_eq!(Some(1), visitor.function_type_index(0).ok());
    let Err(Error::FunctionIndex(1)) = visitor.function_type_index(1) else {
        panic!("function_type_index(1) did not fail")
    };
    let Err(Error::TypeIndex(1)) = visitor.type_params_results(1) else {
        panic!("type_params_results(1) did not fail")
    };
}

#[test]
fn test_with_block_types_empty() {
    let (config, mstate, mut fnstate) = new_state();
    let mut visitor = config.make_visitor(&mstate, &mut fnstate);

    let mut called = false;
    visitor
        .with_block_types(BlockType::Empty, |_, params, results| {
            assert_eq!(params, []);
            assert_eq!(results, []);
            called = true;
            Ok(())
        })
        .expect("should return Ok");
    assert!(
        called,
        "BlockType::Empty should still call with_block_types callback"
    );
}

#[test]
fn test_with_block_types_type() {
    let (config, mstate, mut fnstate) = new_state();
    let mut visitor = config.make_visitor(&mstate, &mut fnstate);
    let mut called = false;
    visitor
        .with_block_types(BlockType::Type(ValType::V128), |_, params, results| {
            assert_eq!(params, []);
            assert_eq!(results, [ValType::V128]);
            called = true;
            Ok(())
        })
        .expect("should return Ok");
    assert!(
        called,
        "BlockType::Type should call with_block_types callback"
    );
}

#[test]
fn test_with_block_types_functype() {
    let (config, mut mstate, mut fnstate) = new_state();
    mstate.types = vec![wasmparser::Type::Func(wasmparser::FuncType::new(
        [ValType::V128],
        [ValType::Ref(RefType::FUNCREF)],
    ))];
    let mut visitor = config.make_visitor(&mstate, &mut fnstate);

    let mut called = false;
    visitor
        .with_block_types(BlockType::FuncType(0), |_, params, results| {
            assert_eq!(params, [ValType::V128]);
            assert_eq!(results, [ValType::Ref(RefType::FUNCREF)]);
            called = true;
            Ok(())
        })
        .expect("should return Ok");
    assert!(
        called,
        "BlockType::FuncType should call with_block_types callback"
    );

    let result = visitor.with_block_types(BlockType::FuncType(1), |_, _, _| {
        panic!("should not get called");
    });
    let Err(Error::TypeIndex(1)) = result else {
        panic!("BlockType::FuncType(1) should have failed but it did not");
    };
}

#[test]
fn test_nested_polymorphic_frames() {
    let (config, mstate, mut fnstate) = new_state();

    assert_eq!(0, fnstate.size);
    let mut visitor = config.make_visitor(&mstate, &mut fnstate);
    visitor.make_polymorphic();
    visitor
        .pop()
        .expect("pops from polymorphic frames should never fail, even with empty stack");

    visitor
        .new_frame(BlockType::Empty, 0)
        .expect("pushing a new frame should succeed");
    visitor.push(ValType::I32);
    assert_eq!(0, fnstate.size);
    let mut visitor = config.make_visitor(&mstate, &mut fnstate);
    visitor
        .pop()
        .expect("pops from polymorphic frames should never fail");
    visitor
        .pop()
        .expect("pops from polymorphic frames should never fail");
    let Ok(Some(Frame { stack_polymorphic: true, .. })) = visitor.end_frame() else {
        panic!("pushing a frame when parent frame is already polymorphic should \
                have made this frame polymorphic too");
    };
}

#[test]
fn test_nested_polymorphic_frames_2() {
    let (config, mstate, mut fnstate) = new_state();
    assert_eq!(0, fnstate.size);

    let mut visitor = config.make_visitor(&mstate, &mut fnstate);
    visitor
        .new_frame(BlockType::Empty, 0)
        .expect("pushing a new frame should succeed");
    visitor.make_polymorphic();
    visitor
        .pop()
        .expect("pops from polymorphic frames should never fail, even with empty stack");
    let Ok(Some(Frame { stack_polymorphic: true, .. })) = visitor.end_frame() else {
        panic!("pushing a frame when parent frame is already polymorphic should \
                have made this frame polymorphic too");
    };

    assert!(!fnstate.current_frame.stack_polymorphic);

    let mut visitor = config.make_visitor(&mstate, &mut fnstate);
    let Err(Error::EmptyStack(_)) = visitor.pop() else {
        panic!("setting frame polymorphic should not affect the parent frames");
    };
    visitor.push(ValType::V128);
    assert!(visitor.pop().is_ok());
    assert_eq!(u64::from(visitor.config.value_size), fnstate.max_size);
}

#[test]
fn test_pop_many() {
    let (config, mstate, mut fnstate) = new_state();

    assert_eq!(0, fnstate.operands.len());
    let mut visitor = config.make_visitor(&mstate, &mut fnstate);
    visitor.push(ValType::V128);
    assert_eq!(1, fnstate.operands.len());

    let mut visitor = config.make_visitor(&mstate, &mut fnstate);
    let Err(Error::EmptyStack(_)) = visitor.pop_many(2) else {
        panic!("pop_many cannot pop more than there are operands");
    };
    assert!(visitor.pop_many(0).is_ok());
    assert_eq!(1, fnstate.operands.len());
    let mut visitor = config.make_visitor(&mstate, &mut fnstate);
    assert!(visitor.pop_many(1).is_ok());
    assert_eq!(0, fnstate.operands.len());

    let mut visitor = config.make_visitor(&mstate, &mut fnstate);
    visitor.push(ValType::V128);
    visitor.push(ValType::V128);
    assert_eq!(2, fnstate.operands.len());
    let mut visitor = config.make_visitor(&mstate, &mut fnstate);
    let Err(Error::EmptyStack(_)) = visitor.pop_many(3) else {
        panic!("pop_many cannot pop more than there are operands");
    };
    let mut visitor = config.make_visitor(&mstate, &mut fnstate);
    assert!(visitor.pop_many(2).is_ok());
    assert_eq!(0, fnstate.operands.len());
}

#[test]
fn test_operand_stack_size() {
    let (config, mstate, mut fnstate) = new_state();

    assert_eq!(0, fnstate.size);
    assert_eq!(0, fnstate.max_size);
    config
        .make_visitor(&mstate, &mut fnstate)
        .push(ValType::V128);
    assert_eq!(9, fnstate.size);
    assert_eq!(9, fnstate.max_size);
    config
        .make_visitor(&mstate, &mut fnstate)
        .push(ValType::V128);
    assert_eq!(18, fnstate.size);
    assert_eq!(18, fnstate.max_size);
    config
        .make_visitor(&mstate, &mut fnstate)
        .push(ValType::V128);
    assert_eq!(27, fnstate.size);
    assert_eq!(27, fnstate.max_size);
    config
        .make_visitor(&mstate, &mut fnstate)
        .pop()
        .expect("non empty operand stack");
    assert_eq!(18, fnstate.size);
    assert_eq!(27, fnstate.max_size);
    config
        .make_visitor(&mstate, &mut fnstate)
        .pop()
        .expect("non empty operand stack");
    assert_eq!(9, fnstate.size);
    assert_eq!(27, fnstate.max_size);
    config
        .make_visitor(&mstate, &mut fnstate)
        .pop()
        .expect("non empty operand stack");
    assert_eq!(0, fnstate.size);
    assert_eq!(27, fnstate.max_size);
    config
        .make_visitor(&mstate, &mut fnstate)
        .pop()
        .err()
        .expect("empty operand stack");
    assert_eq!(0, fnstate.size);
    assert_eq!(27, fnstate.max_size);
}

#[test]
fn test_operand_stack_size_with_frames() {
    let (config, mut mstate, mut fnstate) = new_state();
    mstate.types = vec![wasmparser::Type::Func(wasmparser::FuncType::new(
        [ValType::V128],
        [],
    ))];

    assert_eq!(0, fnstate.size);
    assert_eq!(0, fnstate.max_size);
    let mut visitor = config.make_visitor(&mstate, &mut fnstate);
    let Err(Error::EmptyStack(_)) = visitor.new_frame(BlockType::FuncType(0), 1) else {
        panic!("can't shift operands past empty stack!");
    };
    visitor.push(ValType::V128);
    assert_eq!(9, fnstate.size);
    assert_eq!(9, fnstate.max_size);
    let mut visitor = config.make_visitor(&mstate, &mut fnstate);
    let Err(Error::EmptyStack(_)) = visitor.new_frame(BlockType::FuncType(0), 2) else {
        panic!("can't shift operands past empty stack!");
    };
    assert_eq!(Some(()), visitor.new_frame(BlockType::FuncType(0), 0).ok());
    assert_eq!(9, fnstate.size);
    assert_eq!(9, fnstate.max_size);
    let mut visitor = config.make_visitor(&mstate, &mut fnstate);
    let Ok(Some(_)) = visitor.end_frame() else {
        panic!("should be able to end frame we pushed recently");
    };
    assert_eq!(9, fnstate.size);
    assert_eq!(9, fnstate.max_size);

    let mut visitor = config.make_visitor(&mstate, &mut fnstate);
    assert_eq!(Some(()), visitor.new_frame(BlockType::FuncType(0), 1).ok());
    assert_eq!(1, fnstate.operands.len());
    assert_eq!(9, fnstate.size);
    assert_eq!(9, fnstate.max_size);
    let mut visitor = config.make_visitor(&mstate, &mut fnstate);
    let Ok(Some(_)) = visitor.end_frame() else {
        panic!("should be able to end frame we pushed recently");
    };
    assert_eq!(0, fnstate.operands.len());
    assert_eq!(0, fnstate.size);
    assert_eq!(9, fnstate.max_size);

    config
        .make_visitor(&mstate, &mut fnstate)
        .push(ValType::V128);
    assert_eq!(9, fnstate.size);
    assert_eq!(9, fnstate.max_size);
    config
        .make_visitor(&mstate, &mut fnstate)
        .push(ValType::V128);
    assert_eq!(18, fnstate.size);
    assert_eq!(18, fnstate.max_size);
    let mut visitor = config.make_visitor(&mstate, &mut fnstate);
    assert_eq!(Some(()), visitor.new_frame(BlockType::FuncType(0), 1).ok());
    assert_eq!(2, fnstate.operands.len());
    assert_eq!(18, fnstate.size);
    assert_eq!(18, fnstate.max_size);
    config
        .make_visitor(&mstate, &mut fnstate)
        .push(ValType::V128);
    assert_eq!(27, fnstate.size);
    assert_eq!(27, fnstate.max_size);
    let mut visitor = config.make_visitor(&mstate, &mut fnstate);
    let Ok(Some(_)) = visitor.end_frame() else {
        panic!("should be able to end frame we pushed recently");
    };
    assert_eq!(1, fnstate.operands.len());
    assert_eq!(9, fnstate.size);
    assert_eq!(27, fnstate.max_size);
}

'''
'''--- src/visitors.rs ---
mod internal {
    pub trait VisitOperatorWithOffset<'a>: wasmparser::VisitOperator<'a> {
        fn set_offset(&mut self, offset: usize);
    }

    pub struct NoOpVisitor<Output>(pub(crate) Output);
}

pub(crate) use internal::{NoOpVisitor, VisitOperatorWithOffset};

macro_rules! noop_visit {
    ($( @$proposal:ident $op:ident $({ $($arg:ident: $argty:ty),* })? => $visit:ident)*) => {
        $(fn $visit(&mut self $($(,$arg: $argty)*)?) -> Self::Output {
            self.0.clone()
        })*
    }
}

impl<'a, Output: 'static + Clone> wasmparser::VisitOperator<'a> for NoOpVisitor<Output> {
    type Output = Output;
    wasmparser::for_each_operator!(noop_visit);
}

impl<'a, Output: 'static + Clone> VisitOperatorWithOffset<'a> for NoOpVisitor<Output> {
    fn set_offset(&mut self, _: usize) {}
}

pub(crate) struct JoinVisitor<L, R>(pub(crate) L, pub(crate) R);

macro_rules! join_visit {
    ($( @$proposal:ident $op:ident $({ $($arg:ident: $argty:ty),* })? => $visit:ident)*) => {
        $(fn $visit(&mut self $($(,$arg: $argty)*)?) -> Self::Output {
            (self.0.$visit($($($arg.clone()),*)?), self.1.$visit($($($arg),*)?))
        })*
    }
}

impl<'a, L, R> wasmparser::VisitOperator<'a> for JoinVisitor<L, R>
where
    L: wasmparser::VisitOperator<'a>,
    R: wasmparser::VisitOperator<'a>,
{
    type Output = (L::Output, R::Output);
    wasmparser::for_each_operator!(join_visit);
}

impl<'a, L, R> VisitOperatorWithOffset<'a> for JoinVisitor<L, R>
where
    L: VisitOperatorWithOffset<'a>,
    R: VisitOperatorWithOffset<'a>,
{
    fn set_offset(&mut self, offset: usize) {
        self.0.set_offset(offset);
        self.1.set_offset(offset);
    }
}

'''
'''--- src/wast_tests/runner.rs ---
use finite_wasm::wast_tests::test;
use rayon::prelude::*;
use std::ffi::OsStr;
use std::io::Write;
use std::path::PathBuf;

#[derive(thiserror::Error, Debug)]
enum Error {
    #[error("could not obtiain the current working directory")]
    CurrentDirectory(#[source] std::io::Error),
    #[error("could not walk the `tests` directory")]
    WalkDirEntry(#[source] walkdir::Error),
    #[error("could not write the test output to the standard error")]
    WriteTestOutput(#[source] std::io::Error),
    #[error("some tests failed")]
    TestsFailed,
}

struct Test {
    path: PathBuf,
}

fn run() -> Result<(), Error> {
    let current_directory = std::env::current_dir().map_err(Error::CurrentDirectory)?;
    let tests_directory = current_directory.join("tests");
    let snaps_directory = tests_directory.join("snaps");
    let temp_directory = tests_directory.join("tmp");
    let filter = std::env::args().nth(1);
    let mut tests = vec![Test {
        path: "!internal-self-test-interpreter".into(),
    }];
    for entry in walkdir::WalkDir::new(&tests_directory) {
        let entry = entry.map_err(Error::WalkDirEntry)?;
        let entry_path = entry.path();
        if entry_path.starts_with(&temp_directory) {
            continue;
        }
        let test_name = entry_path
            .strip_prefix(&tests_directory)
            .unwrap_or(&entry_path)
            .display()
            .to_string();
        if let Some(filter) = &filter {
            if !test_name.contains(filter) {
                continue;
            }
        }
        if Some(OsStr::new("wast")) == entry_path.extension() {
            tests.push(Test {
                path: entry_path.into(),
            });
        }
    }

    println!("running {} tests", tests.len());
    let failures = std::sync::atomic::AtomicUsize::new(0);
    tests.par_iter_mut().try_for_each(|test| {
        let test_path = test
            .path
            .strip_prefix(&current_directory)
            .unwrap_or(&test.path);
        let test_name = test
            .path
            .strip_prefix(&tests_directory)
            .unwrap_or(&test.path)
            .display()
            .to_string();
        let mut context = test::TestContext::new(
            test_name,
            test_path.into(),
            snaps_directory.clone(),
            temp_directory.clone(),
            true,
        );
        context.run();
        if context.failed() {
            failures.fetch_add(1, std::sync::atomic::Ordering::Relaxed);
        }
        std::io::stderr()
            .lock()
            .write_all(&context.output)
            .map_err(Error::WriteTestOutput)?;
        Ok::<_, Error>(())
    })?;

    if failures.load(std::sync::atomic::Ordering::Relaxed) != 0 {
        Err(Error::TestsFailed)
    } else {
        Ok(())
    }
}

fn main() {
    std::process::exit(match run() {
        Ok(()) => 0,
        Err(error) => {
            test::write_error(std::io::stderr().lock(), &error)
                .expect("failed writing out the error");
            1
        }
    })
}

'''
'''--- src/wast_tests/test.rs ---
use crate::{max_stack, Analysis};
use std::error;
use std::ffi::OsString;
use std::io::{self, Read, Seek, SeekFrom, Write};
use std::path::{Path, PathBuf};
use std::process::ExitStatus;
use std::time::Duration;

pub fn write_error(mut to: impl io::Write, error: impl error::Error) -> std::io::Result<()> {
    writeln!(to, "error: {}", error)?;
    let mut source = error.source();
    while let Some(error) = source {
        writeln!(to, "caused by: {}", error)?;
        source = error.source();
    }
    Ok(())
}

#[derive(Debug, PartialEq)]
enum Line {
    Equal(String),
    Delete(String),
    Insert(String),
}

#[derive(Debug)]
pub(crate) struct DiffError {
    diff: Vec<Line>,
    path: Option<PathBuf>,
}

impl DiffError {
    fn diff(old: &str, new: &str) -> Option<Self> {
        if old == new {
            return None;
        }
        let result = dissimilar::diff(old, new);
        let diff = result
            .into_iter()
            .map(|s| match s {
                dissimilar::Chunk::Delete(s) => Line::Delete(s.into()),
                dissimilar::Chunk::Insert(s) => Line::Insert(s.into()),
                dissimilar::Chunk::Equal(s) => Line::Equal(s.into()),
            })
            .collect::<Vec<_>>();
        if diff.iter().all(|l| matches!(l, Line::Equal(_))) {
            None
        } else {
            Some(Self { diff, path: None })
        }
    }
    fn with_path(self, path: PathBuf) -> Self {
        Self {
            diff: self.diff,
            path: Some(path),
        }
    }
}
impl std::error::Error for DiffError {}
impl std::fmt::Display for DiffError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if let Some(path) = &self.path {
            f.write_fmt(format_args!(
                "non-empty differential against {}",
                path.display()
            ))?;
        } else {
            f.write_str("non-empty differential")?;
        }
        for line in self.diff.iter() {
            match line {
                Line::Delete(s) => {
                    f.write_str("\n      - ")?;
                    f.write_str(&s)?;
                }
                Line::Insert(s) => {
                    f.write_str("\n      + ")?;
                    f.write_str(&s)?;
                }
                Line::Equal(s) => {
                    f.write_str("\n        ")?;
                    f.write_str(&s)?;
                }
            }
        }
        f.write_str("\n")
    }
}

#[derive(thiserror::Error, Debug)]
pub(crate) enum Error {
    #[error("could not read the test file `{1}`")]
    ReadTestContents(#[source] std::io::Error, PathBuf),
    #[error("could not interpret test file `{1}` as UTF-8")]
    FromUtf8(#[source] std::str::Utf8Error, PathBuf),
    #[error("could not create the parse buffer for the test file")]
    ParseBuffer(#[source] wast::Error),
    #[error("could not parse the test file")]
    ParseWast(#[source] wast::Error),
    #[error("could not encode the wast module `{1}`")]
    EncodeModule(#[source] wast::Error, String),

    #[error("could not open the snapshot file {1:?}")]
    OpenSnap(#[source] std::io::Error, PathBuf),
    #[error("could not read the snapshot file {1:?}")]
    ReadSnap(#[source] std::io::Error, PathBuf),
    #[error("could not truncate the snapshot file {1:?}")]
    TruncateSnap(#[source] std::io::Error, PathBuf),
    #[error("could not seek the snapshot file {1:?}")]
    SeekSnap(#[source] std::io::Error, PathBuf),
    #[error("could not write the snapshot file {1:?}")]
    WriteSnap(#[source] std::io::Error, PathBuf),
    #[error("snapshot comparison failed")]
    DiffSnap(#[source] DiffError),

    #[error("could not execute the interpreter with arguments: {1:?}")]
    InterpreterLaunch(#[source] std::io::Error, Vec<OsString>),
    #[error("could not wait on the interpreter")]
    InterpreterWait(#[source] std::io::Error),
    #[error("reference interpreter failed with exit code {1:?} (arguments: {2:?})")]
    InterpreterExit(
        #[source] Box<dyn std::error::Error + Send + Sync>,
        ExitStatus,
        Vec<OsString>,
    ),
    #[error("interpreter output wasn’t valid UTF-8")]
    InterpreterOutput(#[source] std::string::FromUtf8Error),
    #[error("could not analyze the module {1} at {2:?}")]
    AnalyseModule(#[source] crate::Error, String, PathBuf),
    #[error("could not analyze the module {0} at {1:?}, analysis panicked")]
    AnalyseModulePanic(String, PathBuf),
    #[error("could not instrument the module {0} at {1:?}, instrumentation code panicked")]
    InstrumentModulePanic(String, PathBuf),
    #[error("could not instrument the test module")]
    Instrument(#[source] crate::InstrumentError),
    #[error("could not write out the instrumented test module to a temporary file at {1:?}")]
    WriteTempTest(#[source] std::io::Error, PathBuf),
    #[error("interpreter (= {0}) and analysis (= {1}) disagree on gas consumption")]
    GasMismatch(i64, i64),
    #[error("processing the interpreter output panicked")]
    InterpreterOutputProcessingPanic,
}

impl Error {
    pub(crate) fn set_path(&mut self, path: &Path) {
        match self {
            Error::ReadTestContents(_, _)
            | Error::FromUtf8(_, _)
            | Error::OpenSnap(_, _)
            | Error::SeekSnap(_, _)
            | Error::TruncateSnap(_, _)
            | Error::ReadSnap(_, _)
            | Error::WriteSnap(_, _)
            | Error::InterpreterLaunch(_, _)
            | Error::InterpreterWait(_)
            | Error::InterpreterExit(_, _, _)
            | Error::InterpreterOutput(_)
            | Error::DiffSnap(_)
            | Error::AnalyseModule(_, _, _)
            | Error::AnalyseModulePanic(_, _)
            | Error::InstrumentModulePanic(_, _)
            | Error::Instrument(_)
            | Error::GasMismatch(_, _)
            | Error::InterpreterOutputProcessingPanic
            | Error::WriteTempTest(_, _) => {}
            Error::ParseBuffer(s) => set_wast_path(s, path),
            Error::ParseWast(s) => set_wast_path(s, path),
            Error::EncodeModule(s, _) => set_wast_path(s, path),
        }
    }
}

fn set_wast_path(error: &mut wast::Error, path: &Path) {
    error.set_path(path);
    if let Ok(content) = std::fs::read_to_string(path) {
        error.set_text(&content);
    }
}

pub(crate) fn read(storage: &mut String, path: &Path) -> Result<(), Error> {
    let test_contents = std::fs::read(path).map_err(|e| Error::ReadTestContents(e, path.into()))?;
    let test_string =
        std::str::from_utf8(&test_contents).map_err(|e| Error::FromUtf8(e, path.into()))?;
    storage.push_str(test_string);
    Ok(())
}

#[derive(Debug, PartialEq)]
enum Status {
    None,
    Passed,
    Failed,
}

#[derive(Debug)]
pub struct TestContext {
    test_name: String,
    test_path: PathBuf,
    snap_base: PathBuf,
    tmp_base: PathBuf,
    pub output: Vec<u8>,
    status: Status,
    analysis_duration: Duration,
    interpreter_duration: Duration,
    check_snapshot: bool,
}

impl<'a> TestContext {
    pub fn new(
        test_name: String,
        test_path: PathBuf,
        snap_base: PathBuf,
        tmp_base: PathBuf,
        check_snapshot: bool,
    ) -> Self {
        Self {
            test_name,
            test_path,
            snap_base,
            tmp_base,
            output: vec![],
            status: Status::None,
            analysis_duration: Duration::default(),
            interpreter_duration: Duration::default(),
            check_snapshot,
        }
    }

    pub fn failed(&self) -> bool {
        self.status == Status::Failed
    }

    fn pass(&mut self) {
        assert!(self.status == Status::None);
        self.status = Status::Passed;
        self.output.extend_from_slice(b"[PASS] ");
        self.output.extend_from_slice(self.test_name.as_bytes());
        self.output.extend_from_slice(
            format!(
                " (analysis: {:?}; interpreter: {:?})",
                self.analysis_duration, self.interpreter_duration
            )
            .as_bytes(),
        );
        self.output.extend_from_slice(b"\n");
    }

    fn fail(&mut self, error: impl error::Error) {
        assert!([Status::None, Status::Failed].contains(&self.status));
        if let Status::None = self.status {
            self.output.extend_from_slice(b"[FAIL] ");
            self.output.extend_from_slice(self.test_name.as_bytes());
            self.output.extend_from_slice(b"\n");
            self.status = Status::Failed;
        }
        write_error(&mut self.output, error).expect("this should be infallible");
    }

    fn fail_test_error(&mut self, error: &mut Error) {
        error.set_path(&self.test_path);
        self.fail(&*error)
    }

    pub fn run(&mut self) {
        // There are some interesting properties of the interpreter that we want to verify, but
        // those properties are hard/infeasible to validate with our wast test runner
        // infrastructure.
        //
        // Instead we implement an escape hatch via the test name and allow the test suite to run
        // arbitrary rust code within the test context.
        if "!internal-self-test-interpreter" == self.test_name {
            if let Err(mut e) = self.self_test_interpreter() {
                self.fail_test_error(&mut e);
            } else {
                self.pass();
            }
            return;
        }

        let instrumented_wast = match self.run_analysis() {
            Ok(instrumented_wast) => instrumented_wast,
            Err(mut e) => return self.fail_test_error(&mut e),
        };

        if self.check_snapshot {
            if let Err(mut e) = self.compare_snapshot(&instrumented_wast, "instrumented") {
                return self.fail_test_error(&mut e);
            }
        }

        // Run the interpreter here with the wast file in some sort of a tracing mode (needs to
        // be implemented inside the interpreter).
        //
        // The output is probably going to be extremely verbose, but hey, it doesn’t result in
        // excessive effort at least, does it?
        let output = match self.exec_interpreter(instrumented_wast) {
            Ok(o) => o,
            Err(mut e) => return self.fail_test_error(&mut e),
        };
        if let Err(mut e) = self.validate_interpreter_output(&output) {
            return self.fail_test_error(&mut e);
        }
        self.pass();
    }

    fn validate_interpreter_output(&mut self, interpreter_out: &str) -> Result<(), Error> {
        let (interpreter_gas, instrumentation_gas) =
            std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
                self.process_interpreter_output(interpreter_out)
            }))
            .map_err(|_| Error::InterpreterOutputProcessingPanic)??;
        if interpreter_gas != instrumentation_gas {
            return Err(Error::GasMismatch(interpreter_gas, instrumentation_gas));
        }
        Ok(())
    }

    fn process_interpreter_output(&mut self, interpreter_out: &str) -> Result<(i64, i64), Error> {
        fn parse_prefix_num(s: &[u8]) -> Option<i64> {
            match <i64 as atoi::FromRadix10Signed>::from_radix_10_signed(s) {
                (_, 0) => None,
                (n, _) => Some(n),
            }
        }

        let mut interpreter_gas = 0;
        let mut instrumentation_gas = 0;
        let mut total_stack_used = 0;
        let mut max_stack_used = 0;
        for line in interpreter_out.lines() {
            let Some((kind, rest)) = line.split_once(": ") else {
                continue;
            };

            match kind {
                "gas" => {
                    let count = parse_prefix_num(rest.as_bytes()).expect("TODO");
                    interpreter_gas += count;
                }
                "charge_gas" => {
                    let count = parse_prefix_num(rest.as_bytes()).expect("TODO");
                    instrumentation_gas += count;
                }
                "reserve_stack" => {
                    let Some((l, r)) = rest.split_once(" ") else {
                        continue;
                    };
                    let ops_size = parse_prefix_num(l.as_bytes()).expect("TODO");
                    let frame_size = parse_prefix_num(r.as_bytes()).expect("TODO");
                    // The reference interpreter charges 1 gas for each local and argument.
                    instrumentation_gas += frame_size;
                    total_stack_used += ops_size + frame_size;
                    max_stack_used = std::cmp::max(total_stack_used, max_stack_used);
                }
                "return_stack" => {
                    let Some((l, r)) = rest.split_once(" ") else {
                        continue;
                    };
                    let ops_size = parse_prefix_num(l.as_bytes()).expect("TODO");
                    let frame_size = parse_prefix_num(r.as_bytes()).expect("TODO");
                    total_stack_used -= ops_size + frame_size;
                }
                _ => {
                    continue;
                }
            }
        }

        Ok((interpreter_gas, instrumentation_gas))
    }

    fn run_analysis(&mut self) -> Result<String, Error> {
        let mut test_contents = String::new();
        read(&mut test_contents, &self.test_path)?;
        let mut lexer = wast::lexer::Lexer::new(&test_contents);
        lexer.allow_confusing_unicode(true);
        let buf = wast::parser::ParseBuffer::new_with_lexer(lexer).map_err(Error::ParseBuffer)?;
        let wast: wast::Wast = wast::parser::parse(&buf).map_err(Error::ParseWast)?;
        let mut output_wast = String::new();
        let mut iter = wast.directives.into_iter().enumerate().peekable();
        while let Some((directive_index, directive)) = iter.next() {
            // saturating_sub here grabs the preceding parenthesis if any.
            let start_offset = directive.span().offset().saturating_sub(1);
            let end_offset = iter
                .peek()
                // and this one ensures that we don't include the initial parenthesis of the next
                // directive.
                .map(|(_, d)| d.span().offset().saturating_sub(1))
                .unwrap_or(test_contents.len());
            match directive {
                wast::WastDirective::Wat(wast::QuoteWat::Wat(wast::Wat::Module(mut module))) => {
                    let id = module.id.map_or_else(
                        || format!("[directive {directive_index}]"),
                        |id| format!("{id:?}"),
                    );
                    let module = module
                        .encode()
                        .map_err(|e| Error::EncodeModule(e, id.clone()))?;
                    let instrumented = self.instrument_module(&id, &module)?;
                    let print = wasmprinter::print_bytes(&instrumented).expect("print");
                    output_wast.push_str(&print);
                    output_wast.push_str("\n");
                }
                wast::WastDirective::Wat(wast::QuoteWat::QuoteModule(_, _)) => {
                    unreachable!("doesn’t actually occur in our test suite");
                }
                wast::WastDirective::Wat(wast::QuoteWat::Wat(wast::Wat::Component(_))) => {
                    // These are difficult and I would rather skip them for now...
                    continue;
                }
                wast::WastDirective::Wat(wast::QuoteWat::QuoteComponent(_, _)) => {
                    // Same
                    continue;
                }

                // Ignore the “operations”, we only care about module analysis results.
                wast::WastDirective::Register { .. } => {
                    output_wast.push_str(&test_contents[start_offset..end_offset]);
                    continue;
                }
                wast::WastDirective::Invoke(i) => {
                    if self.check_snapshot {
                        output_wast.push_str(&test_contents[start_offset..end_offset]);
                    } else {
                        // When there’s no snapshot (ie. when fuzzing) we reuse
                        // the invoke instruction to pass the wast crate’s parsing
                        // while actually ignoring traps.
                        // The saturating_add(7) removes the "invoke " string added by
                        // the fuzzer. Grep XREF:INVOKE-FOR-JUST-RUN for more details.
                        output_wast.push_str("\n(just_run ");
                        output_wast.push_str(
                            &test_contents[i.span.offset().saturating_add(7)..end_offset],
                        );
                    }
                    continue;
                }
                wast::WastDirective::AssertTrap { exec, message, .. } => {
                    match exec {
                        wast::WastExecute::Invoke(_) => {
                            output_wast.push_str(&test_contents[start_offset..end_offset]);
                        }
                        wast::WastExecute::Wat(wast::Wat::Module(mut module)) => {
                            let id = module.id.map_or_else(
                                || format!("[directive {directive_index}]"),
                                |id| format!("{id:?}"),
                            );
                            let module = module
                                .encode()
                                .map_err(|e| Error::EncodeModule(e, id.clone()))?;
                            let instrumented = self.instrument_module(&id, &module)?;
                            output_wast.push_str("\n(assert_trap ");
                            let print = wasmprinter::print_bytes(&instrumented).expect("print");
                            output_wast.push_str(&print);
                            output_wast.push_str(" \"");
                            output_wast.push_str(message);
                            output_wast.push_str("\")\n");
                        }
                        wast::WastExecute::Wat(wast::Wat::Component(_)) => {
                            unreachable!("components are not supported");
                        }
                        wast::WastExecute::Get { .. } => {
                            output_wast.push_str(&test_contents[start_offset..end_offset]);
                        }
                    }
                    continue;
                }
                wast::WastDirective::AssertReturn { .. } => {
                    output_wast.push_str(&test_contents[start_offset..end_offset]);
                    continue;
                }
                wast::WastDirective::AssertExhaustion { .. } => continue,
                wast::WastDirective::AssertException { .. } => continue,
                // Do not attempt to process invalid modules.
                wast::WastDirective::AssertMalformed { .. } => continue,
                wast::WastDirective::AssertInvalid { .. } => continue,
                wast::WastDirective::AssertUnlinkable { .. } => continue,
            };
        }
        Ok(output_wast)
    }

    fn instrument_module(&mut self, id: &str, code: &[u8]) -> Result<Vec<u8>, Error> {
        let start = std::time::Instant::now();
        let results = std::panic::catch_unwind(|| {
            Analysis::new()
                .with_stack(DefaultStackConfig)
                .with_gas(DefaultGasConfig)
                .analyze(code)
        })
        .map_err(|_| Error::AnalyseModulePanic(id.into(), self.test_path.clone()))?
        .map_err(|e| Error::AnalyseModule(e, id.into(), self.test_path.clone()))?;
        self.analysis_duration += start.elapsed();

        std::panic::catch_unwind(|| results.instrument("spectest", code))
            .map_err(|_| Error::InstrumentModulePanic(id.into(), self.test_path.clone()))?
            .map_err(Error::Instrument)
    }

    fn self_test_interpreter(&mut self) -> Result<(), Error> {
        // Validate that the gas and stack intrinsics are considered by the interpreter to be free
        // and charge the expected amount of gas.
        let charge_for_stack = 10;
        let charge_for_gas = 100;
        let module = format!(
            r#"
            (module
              (type $gas_ty (func (param i64)))
              (type $stack_ty (func (param i64 i64)))
              (import "spectest" "finite_wasm_gas" (func $finite_wasm_gas (type $gas_ty)))
              (import "spectest" "finite_wasm_stack" (func $finite_wasm_stack (type $stack_ty)))
              (import "spectest" "finite_wasm_unstack" (func $finite_wasm_unstack (type $stack_ty)))
              (func $main (export "main")
                block
                    (call $finite_wasm_stack (i64.const 1) (i64.const {charge_for_stack}))
                    (call $finite_wasm_gas (i64.const {charge_for_gas}))
                end
                (call $finite_wasm_unstack (i64.const 1) (i64.const {charge_for_stack}))
              )
            )
            (assert_return (invoke "main"))
            "#
        );
        let output = self.exec_interpreter(module.into())?;
        let (interpreter_gas, instrumentation_gas) = self.process_interpreter_output(&output)?;
        let expected_instrumentation_gas = charge_for_stack + charge_for_gas;
        if interpreter_gas != 0 || instrumentation_gas != expected_instrumentation_gas {
            return Err(Error::GasMismatch(interpreter_gas, instrumentation_gas));
        }
        Ok(())
    }

    fn exec_interpreter(&mut self, code: String) -> Result<String, Error> {
        let mut test_path = self.tmp_base.join(&self.test_name);
        if test_path.extension().is_none() {
            test_path.set_extension("wast");
        }
        let _ = std::fs::create_dir_all(&test_path.parent().unwrap());
        std::fs::write(&test_path, code).map_err(|e| Error::WriteTempTest(e, test_path.clone()))?;

        let mut args = vec!["-tg".into(), "-i".into(), test_path.into()];
        if !self.check_snapshot {
            // Limit gas pool size, to avoid infinite loops
            args.push("-g".into());
            args.push("1000".into());
        }
        static INTERPRETER_BYTES: &[u8] = include_bytes!("../../interpreter/wasm");
        extern "C" fn delete_directory() {
            // lazy_static tempdirs aren’t actually deleted at the end of the program
            let _ = INTERPRETER
                .0
                .lock()
                .map(|mut o| o.take().map(|d| d.close()));
        }
        lazy_static::lazy_static! {
            static ref INTERPRETER: (std::sync::Mutex<Option<tempfile::TempDir>>, std::path::PathBuf) = {
                let d = tempfile::Builder::new()
                    .prefix("finite-wasm-spec-interpreter.")
                    .tempdir()
                    .expect("failed creating spec interpreter binary directory");
                let path = d.path().join("wasm");
                let mut f = std::fs::File::create(&path)
                    .expect("failed creating spec interpreter binary");
                f.write_all(INTERPRETER_BYTES)
                    .expect("failed writing spec interpreter binary");
                f.set_permissions(std::os::unix::fs::PermissionsExt::from_mode(0o700))
                    .expect("failed making spec interpreter binary executable");
                unsafe { libc::atexit(delete_directory) };
                (std::sync::Mutex::new(Some(d)), path)
            };
        }
        let start = std::time::Instant::now();
        let process = std::process::Command::new(&INTERPRETER.1)
            .stdin(std::process::Stdio::null())
            .stdout(std::process::Stdio::piped())
            .stderr(std::process::Stdio::piped())
            .args(&args)
            .spawn()
            .map_err(|e| Error::InterpreterLaunch(e, args.clone()))?;
        let output = process
            .wait_with_output()
            .map_err(|e| Error::InterpreterWait(e))?;
        self.interpreter_duration += start.elapsed();
        let stdoutput = String::from_utf8(output.stdout).map_err(Error::InterpreterOutput)?;
        if !output.status.success() {
            let stderr = String::from_utf8_lossy(&output.stderr);
            if !self.check_snapshot
                // Likely infinite recursion
                && (stderr.contains("call stack exhausted")
                    // Likely infinite looping, or somesuch case.
                    || stderr.contains("gas pool is empty")
                    // Likely module instantiation failed due to a runtime error of some sort.
                    || !stdoutput.contains("charge_gas"))
            {
                return Ok(String::new());
            }
            return Err(Error::InterpreterExit(stderr.into(), output.status, args));
        }
        Ok(stdoutput)
    }

    fn compare_snapshot(&mut self, directive_output: &str, index: &str) -> Result<(), Error> {
        let should_update = std::env::var_os("SNAP_UPDATE").is_some();
        let snap_filename = format!("{}@{}.snap", self.test_name, index);
        let snap_path = self.snap_base.join(snap_filename);
        if let Some(parent) = snap_path.parent() {
            let _ = std::fs::create_dir_all(parent);
        }
        let mut snap_file = std::fs::OpenOptions::new()
            .create(true)
            .read(true)
            .write(true)
            .open(&snap_path)
            .map_err(|e| Error::OpenSnap(e, snap_path.clone()))?;
        let mut snap_contents = String::with_capacity(1024);
        snap_file
            .read_to_string(&mut snap_contents)
            .map_err(|e| Error::ReadSnap(e, snap_path.clone()))?;
        if !should_update {
            match DiffError::diff(&snap_contents, &directive_output) {
                None => Ok(()),
                Some(error) => {
                    self.output.extend_from_slice(
                        "note: run with SNAP_UPDATE environment variable to update\n".as_bytes(),
                    );
                    Err(Error::DiffSnap(error.with_path(snap_path)))
                }
            }
        } else {
            snap_file
                .set_len(0)
                .map_err(|e| Error::TruncateSnap(e, snap_path.clone()))?;
            // TRICKY: If we don’t seek, the file will be filled with 0-bytes up to the
            // current position (we read the file’s contents just now!) before the data is
            // written...
            snap_file
                .seek(SeekFrom::Start(0))
                .map_err(|e| Error::SeekSnap(e, snap_path.clone()))?;
            snap_file
                .write_all(directive_output.as_bytes())
                .map_err(|e| Error::WriteSnap(e, snap_path))?;
            Ok(())
        }
    }
}

struct DefaultStackConfig;
impl max_stack::SizeConfig for DefaultStackConfig {
    fn size_of_value(&self, ty: wasmparser::ValType) -> u8 {
        use wasmparser::ValType::*;
        match ty {
            I32 => 4,
            I64 => 8,
            F32 => 4,
            F64 => 8,
            V128 => 16,
            Ref(_) => 32,
        }
    }

    fn size_of_function_activation(
        &self,
        locals: &prefix_sum_vec::PrefixSumVec<wasmparser::ValType, u32>,
    ) -> u64 {
        u64::from(locals.max_index().map(|&v| v + 1).unwrap_or(0))
    }
}

pub(crate) struct DefaultGasConfig;

macro_rules! gas_visit {
    (visit_end => $({ $($arg:ident: $argty:ty),* })?) => {};
    (visit_else => $({ $($arg:ident: $argty:ty),* })?) => {};
    ($visit:ident => $({ $($arg:ident: $argty:ty),* })?) => {
        fn $visit(&mut self $($(,$arg: $argty)*)?) -> Self::Output {
            1u64
        }
    };

    ($( @$proposal:ident $op:ident $({ $($arg:ident: $argty:ty),* })? => $visit:ident)*) => {
        $(gas_visit!{ $visit => $({ $($arg: $argty),* })? })*
    }
}

impl<'a> wasmparser::VisitOperator<'a> for DefaultGasConfig {
    type Output = u64;
    fn visit_end(&mut self) -> u64 {
        0
    }
    fn visit_else(&mut self) -> u64 {
        0
    }
    wasmparser::for_each_operator!(gas_visit);
}

'''