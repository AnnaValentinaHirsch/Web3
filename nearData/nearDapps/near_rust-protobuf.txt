*GitHub Repository "near/rust-protobuf"*

'''--- .github/ISSUE_TEMPLATE/BOUNTY.yml ---
name: "Simple Bounty"
description: "Use this template to create a HEROES Simple Bounty via Github bot"
title: "Bounty: "
labels: ["bounty"]
assignees: heroes-bot-test
body:
  - type: markdown
    attributes:
      value: |
        Hi! Let's set up your bounty! Please don't change the template - @heroes-bot-test won't be able to help you.

  - type: dropdown
    id: type
    attributes:
      label: What talent are you looking for?
      options:
        - Marketing
        - Development
        - Design
        - Other
        - Content
        - Research
        - Audit

  - type: textarea
    id: description
    attributes:
      label: What you need to be done?

  - type: dropdown
    id: tags
    attributes:
      label: Tags
      description: Add tags that match the topic of the work
      multiple: true
      options:
        - API
        - Blockchain
        - Community
        - CSS
        - DAO
        - dApp
        - DeFi
        - Design
        - Documentation
        - HTML
        - Javascript
        - NFT
        - React
        - Rust
        - Smart contract
        - Typescript
        - UI/UX
        - web3
        - Translation
        - Illustration
        - Branding
        - Copywriting
        - Blogging
        - Editing
        - Video Creation
        - Social Media
        - Graphic Design
        - Transcription
        - Product Design
        - Artificial Intelligence
        - Quality Assurance
        - Risk Assessment
        - Security Audit
        - Bug Bounty
        - Code Review
        - Blockchain Security
        - Smart Contract Testing
        - Penetration Testing
        - Vulnerability Assessment
        - BOS
        - News
        - Hackathon
        - NEARCON2023
        - NEARWEEK

  - type: input
    id: deadline
    attributes:
      label: Deadline
      description: "Set a deadline for your bounty. Please enter the date in format: DD.MM.YYYY"
      placeholder: "19.05.2027"

  - type: dropdown
    id: currencyType
    attributes:
      label: Currency
      description: What is the currency you want to pay?
      options:
        - USDC.e
        - USDT.e
        - DAI
        - wNEAR
        - USDt
        - XP
        - marmaj
        - NEKO
        - JUMP
        - USDC
        - NEARVIDIA
      default: 0
    validations:
      required: true

  - type: input
    id: currencyAmount
    attributes:
      label: Amount
      description: How much it will be cost?

  - type: markdown
    attributes:
      value: "## Advanced settings"

  - type: checkboxes
    id: kyc
    attributes:
      label: KYC
      description: "Use HEROES' KYC Verification, only applicants who passed HEROES' KYC can apply and work on this bounty!"
      options:
        - label: Use KYC Verification

  - type: markdown
    attributes:
      value: |
        ### This cannot be changed once the bounty is live!

'''
'''--- .github/linters/.markdown-lint.yml ---
{
    # Line length
    "MD013": false,
    # Headings should be surrounded by blank lines
    "MD022": false,
    # Multiple headings with the same content
    "MD024": false,
    # Lists should be surrounded by blank lines
    "MD032": false
}

'''
'''--- .github/workflows/ci.yml ---
# @generated by ci-gen, do not edit

on:
    - push
    - pull_request
name: CI
jobs:
    linux-stable-default-features:
        name: linux stable (default features)
        runs-on: ubuntu-latest
        env:
            RUST_BACKTRACE: 1
        steps:
            - name: Checkout sources
              uses: actions/checkout@v2
            - name: Install toolchain
              uses: actions-rs/toolchain@v1
              with:
                  profile: minimal
                  toolchain: stable
                  override: true
            - name: Cache protobuf
              uses: actions/cache@v2
              with:
                  key: pb-linux-3.19.4
                  path: ~/pb
              env:
                  cache-name: pb
            - name: Install protobuf
              run: ci/install-protobuf.sh
              shell: bash
              env:
                  PROTOBUF_VERSION: 3.19.4
            - name: Protoc check
              run: protoc --version
              shell: bash
            - name: Compile interop
              run: test-crates/interop/cxx/compile.sh
              shell: bash
            - name: Regenerate
              run: protobuf/regenerate.sh
              shell: bash
            - name: Test all
              run: cargo test --all --all-targets
              shell: bash
            - name: Test all
              run: cargo test
              shell: bash
            - name: cargo doc
              uses: actions-rs/cargo@v1
              with:
                  command: doc
    linux-beta-default-features:
        name: linux beta (default features)
        runs-on: ubuntu-latest
        env:
            RUST_BACKTRACE: 1
        steps:
            - name: Checkout sources
              uses: actions/checkout@v2
            - name: Install toolchain
              uses: actions-rs/toolchain@v1
              with:
                  profile: minimal
                  toolchain: beta
                  override: true
            - name: Cache protobuf
              uses: actions/cache@v2
              with:
                  key: pb-linux-3.19.4
                  path: ~/pb
              env:
                  cache-name: pb
            - name: Install protobuf
              run: ci/install-protobuf.sh
              shell: bash
              env:
                  PROTOBUF_VERSION: 3.19.4
            - name: Protoc check
              run: protoc --version
              shell: bash
            - name: Compile interop
              run: test-crates/interop/cxx/compile.sh
              shell: bash
            - name: Regenerate
              run: protobuf/regenerate.sh
              shell: bash
            - name: Test all
              run: cargo test --all --all-targets
              shell: bash
            - name: Test all
              run: cargo test
              shell: bash
            - name: cargo doc
              uses: actions-rs/cargo@v1
              with:
                  command: doc
    linux-stable-with-bytes:
        name: linux stable (with-bytes)
        runs-on: ubuntu-latest
        env:
            RUST_BACKTRACE: 1
        steps:
            - name: Checkout sources
              uses: actions/checkout@v2
            - name: Install toolchain
              uses: actions-rs/toolchain@v1
              with:
                  profile: minimal
                  toolchain: stable
                  override: true
            - name: Cache protobuf
              uses: actions/cache@v2
              with:
                  key: pb-linux-3.19.4
                  path: ~/pb
              env:
                  cache-name: pb
            - name: Install protobuf
              run: ci/install-protobuf.sh
              shell: bash
              env:
                  PROTOBUF_VERSION: 3.19.4
            - name: Protoc check
              run: protoc --version
              shell: bash
            - name: Compile interop
              run: test-crates/interop/cxx/compile.sh
              shell: bash
            - name: protobuf-codegen-protoc-test
              uses: actions-rs/cargo@v1
              with:
                  command: test
                  args: --manifest-path=test-crates/protobuf-codegen-protoc-test/Cargo.toml --features=with-bytes
            - name: protobuf-codegen-pure-test
              uses: actions-rs/cargo@v1
              with:
                  command: test
                  args: --manifest-path=test-crates/protobuf-codegen-pure-test/Cargo.toml --features=with-bytes
    linux-nightly-all-features:
        name: linux nightly (all features)
        runs-on: ubuntu-latest
        env:
            RUST_BACKTRACE: 1
        steps:
            - name: Checkout sources
              uses: actions/checkout@v2
            - name: Install toolchain
              uses: actions-rs/toolchain@v1
              with:
                  profile: minimal
                  toolchain: nightly
                  override: true
            - name: Cache protobuf
              uses: actions/cache@v2
              with:
                  key: pb-linux-3.19.4
                  path: ~/pb
              env:
                  cache-name: pb
            - name: Install protobuf
              run: ci/install-protobuf.sh
              shell: bash
              env:
                  PROTOBUF_VERSION: 3.19.4
            - name: Protoc check
              run: protoc --version
              shell: bash
            - name: Compile interop
              run: test-crates/interop/cxx/compile.sh
              shell: bash
            - name: Test all
              run: cargo test --all --all-targets --all-features
              shell: bash
            - name: Test all
              run: cargo test --all-features
              shell: bash
            - name: cargo doc
              uses: actions-rs/cargo@v1
              with:
                  command: doc
                  args: --all-features
    windows-stable-default-features:
        name: windows stable (default features)
        runs-on: windows-latest
        env:
            RUST_BACKTRACE: 1
            VCPKGRS_DYNAMIC: 1
        steps:
            - name: Checkout sources
              uses: actions/checkout@v2
            - name: Install toolchain
              uses: actions-rs/toolchain@v1
              with:
                  profile: minimal
                  toolchain: stable
                  override: true
            - name: Cache protobuf
              uses: actions/cache@v2
              with:
                  key: pb-windows-3.19.4
                  path: ~/pb
              env:
                  cache-name: pb
            - name: Install protobuf
              run: ci/install-protobuf.sh
              shell: bash
              env:
                  PROTOBUF_VERSION: 3.19.4
            - name: Protoc check
              run: protoc --version
              shell: bash
            - name: Test all
              run: cargo test --all --all-targets
              shell: bash
    miri-test:
        name: Miri test
        runs-on: ubuntu-latest
        timeout-minutes: 5
        env:
            RUST_BACKTRACE: 1
            RUST_TEST_THREADS: 1
            MIRIFLAGS: -Zmiri-tag-raw-pointers
        steps:
            - name: Checkout sources
              uses: actions/checkout@v2
            - name: Install toolchain
              uses: actions-rs/toolchain@v1
              with:
                  profile: minimal
                  toolchain: nightly
                  override: true
                  components: miri
            - name: cargo-miri-setup
              uses: actions-rs/cargo@v1
              with:
                  command: miri
                  args: setup
            - name: cargo-miri-test
              uses: actions-rs/cargo@v1
              with:
                  command: miri
                  args: test -p protobuf --lib --all-features
    mega-linter:
        name: mega-linter
        runs-on: ubuntu-latest
        steps:
            - name: Checkout sources
              uses: actions/checkout@v2
              with:
                  fetch-depth: 0
            - name: mega-linter
              uses: megalinter/megalinter@v5
              env:
                  VALIDATE_ALL_CODEBASE: false
                  DEFAULT_BRANCH: master
                  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
                  VALIDATE_JSCPD: false
                  VALIDATE_PROTOBUF: false
                  VALIDATE_RUST_CLIPPY: false
                  VALIDATE_RUST_2015: false
                  VALIDATE_COPYPASTE: false
                  VALIDATE_SPELL: false
    rustfmt-check:
        name: rustfmt check
        runs-on: ubuntu-latest
        steps:
            - name: Checkout sources
              uses: actions/checkout@v2
            - name: Cache protobuf
              uses: actions/cache@v2
              with:
                  key: pb-linux-3.19.4
                  path: ~/pb
              env:
                  cache-name: pb
            - name: Install protobuf
              run: ci/install-protobuf.sh
              shell: bash
              env:
                  PROTOBUF_VERSION: 3.19.4
            - name: Protoc check
              run: protoc --version
              shell: bash
            - name: cargo check
              uses: actions-rs/cargo@v1
              with:
                  command: check
            - name: cargo fmt check
              run: cargo fmt -- --check
              shell: bash
    cargo-sync-readme:
        name: Check sync-readme
        runs-on: ubuntu-latest
        steps:
            - name: Checkout sources
              uses: actions/checkout@v2
            - name: Install toolchain
              uses: actions-rs/toolchain@v1
              with:
                  profile: minimal
                  toolchain: stable
                  override: true
            - name: install cargo sync-readme
              run: cargo install cargo-sync-readme
              shell: bash
            - name: sync-readme protobuf
              run: cd protobuf && cargo sync-readme --check
              shell: bash
            - name: sync-readme protobuf-codegen
              run: cd protobuf-codegen && cargo sync-readme --check
              shell: bash
            - name: sync-readme protobuf-examples/customize-serde
              run: cd protobuf-examples/customize-serde && cargo sync-readme --check
              shell: bash
            - name: sync-readme protobuf-examples/vs-prost
              run: cd protobuf-examples/vs-prost && cargo sync-readme --check
              shell: bash
            - name: sync-readme protobuf-json-mapping
              run: cd protobuf-json-mapping && cargo sync-readme --check
              shell: bash
            - name: sync-readme protobuf-parse
              run: cd protobuf-parse && cargo sync-readme --check
              shell: bash
            - name: sync-readme protobuf-support
              run: cd protobuf-support && cargo sync-readme --check
              shell: bash
    self-check:
        name: CI self-check
        runs-on: ubuntu-latest
        steps:
            - name: Checkout sources
              uses: actions/checkout@v2
            - name: Install toolchain
              uses: actions-rs/toolchain@v1
              with:
                  profile: minimal
                  toolchain: stable
                  override: true
            - name: The check
              run: cargo run -p ci-gen -- --check
              shell: bash

'''
'''--- .rustfmt.toml ---
group_imports       = "StdExternalCrate"
imports_granularity = "Item"

'''
'''--- BUGREPORTING.md ---
# How to report bugs

When you report a bug, please always specify:

* which version of protobuf library do you use
* which of three ways to generate source code do you use
* which operating system you are on
* if you use some features, please specify these features
* if the generated code is incorrect, please provide both `.proto` input and generated output
  and codegen options if you have specified any.

Ideally, please create a small github project, which can be used to reproduce a problem with single command.

Thanks!

'''
'''--- CHANGELOG-before-3.md ---
# Changelog

Changelog after version 3.0.0 lives in [CHANGELOG.md](CHANGELOG.md).

## [3.0.0] - 2022-05-01

* New stable version released.

## [3.0.0-alpha.14] - 2022-05-01

* JSON support is moved into a separate crate `protobuf-json-mapping`
* Generated code for well known types is more similar to regular protobuf now
  (well known type modules are now placed as is in `well_known_types` module instead of being flattened).
* `file_descriptor_proto()` function is private now in generated code.
  Descriptor can be obtained by calling `file_descriptor().proto()`.
* `file_descriptor()` now returns `&'static FileDescriptor`
* Hide `UnknownValues` from public API (keep `UnknownFields`)

## [3.0.0-alpha.13] - 2022-05-01

* More efficient reflective operations
* Fewer internals exposed from public API (e.g. `ProtobufType` is no longer public)

## [3.0.0-alpha.12] - 2022-04-30

* keywords are now [escaped with `_` suffix](https://github.com/stepancheg/rust-protobuf/issues/618)
* generate trivial `is_initialized` functions when possible

## [3.0.0-alpha.11] - 2022-04-29

* all fields are public now in generated messages
* `protobuf-support` crate added. This crate contains utilities shared by other protobuf crates.
  This crate has no public API.

## [3.0.0-alpha.10] - 2022-04-11

* remove `expose_oneof` codegen option (it is on by default for a long time)
* remove unused serde-related options from `rustproto.proto`
* in generated code, enum variant names are converted to camel case
* generate `SpecialFields` field in messages instead of a pair (`unknown_fields`, `cached_size`)
* reflection operations like `nested_messages` now return iterator instead of `Vec`
* replace `fn Enum::values()` with `const Enum::VALUES`
* remove `EnumFull::enum_descriptor()`, does not provide much value over `enum_descriptor_static`
* rename `EnumFull::enum_descriptor_static` -> `enum_descriptor`
* fix `EnumFull::descriptor` for enums with `allow_alias`
* rename `MessageDescriptor::enums` to `nested_enums`
* rename `MessageDescriptor::descriptor_static` to `descriptor`
* add `EnumDescriptor::enclosing_message()`
* `Message` now requires `PartialEq`

## [3.0.0-alpha.9] - 2022-04-04

- Unimplement `DerefMut` for `MessageField`: `DerefMut` which modifies the object state is too dangerous.
  `Deref` is kept though. `Deref` returns an empty instance if field is not set.
- Added `Message::clear`, removed trait `Clear`
- `Lazy` (which is used in generated code) is now implemented with `once_cell` crate.
- protobuf 3 experimental `optional` fields are implemented

## [3.0.0-alpha.8] - 2022-02-21

- Lite runtime generation is restored. When lite runtime requested, code is generated without reflection support.
- `lite` option can be specified when using `protoc-gen-rust` plugin similarly to how
  [C++ or Java do](https://github.com/protocolbuffers/protobuf/issues/6489).

## [3.0.0-alpha.7] - 2022-02-20

- Getters are now generated without `get_` prefix. `get_` prefix also removed from public API functions.
- Reflection API now supports `ServiceDescriptor`. Which can be used to generate code for gRPC for example.
- Message size computation uses u64 now. It is explicit error now on attempt to serialize a message larger than 2GiB.
- Binary message parsing now switches by tag, not by field name. It is faster.

## [3.0.0-alpha.6] - 2022-02-08

- [Fixed invalid aliasing and uninitialized memory access](https://github.com/stepancheg/rust-protobuf/pull/592)
- `MessageField` now implements `Deref` and `DerefMut`
- Slightly more compact generated code
- serde is no longer supported natively. See explanations [in the issue](https://github.com/stepancheg/rust-protobuf/issues/519).
- Rename `ProtobufError` to `Error` and make it opaque type. Rename `ProtobufResult` to `Result`.
- Rename `ProtobufEnum` to `Enum` and `ProtobufEnumOrUnknown` to `EnumOrUnknown`
- `gen_mod_rs` option is `true` by default now: code generator now generates `mod.rs` with modules
- `carllerche` options renamed to `tokio` (since `bytes` crate now lives in `tokio` org)
- `protobuf-parse` API cleanup (API used to parse `.proto` files, not protocol buffers data files)
- Remove `protoc` crate, most of it is incorprotated into `protobuf-parse` crate, and the rest is not very useful
- Generated enums for `oneof` are marked `#[non_exhaustive]`

## [3.0.0-alpha.5] - 2022-02-02

- Dynamic messages work (but not tested enough)

## [3.0.0-alpha.4] - 2022-02-02

- `Display` for message now outputs text format, and `Debug` for message does standard rust `#[derive(Debug)]`.
- Smaller generated code (common code snippets extracted into the library runtime)
- Improvements in dynamic messages

## [3.0.0-alpha.3] - 2022-02-01

- Remove `protobuf-codegen-pure` and `protoc-rust` crates. Now all codegen
  (pure or with `protoc` is done using `protobuf-codegen` crate).
- `LazyV2` (internal utility for rust-protobuf) now implements `Drop`.
- Default `.proto` parser in `protobuf-codegen` is now pure-rust (not using `protoc` command)
- Dynamic messages mostly work

## [3.0.0-alpha.2] - 2021-11-01

- Use `always_output_default_values` option
  [to output empty array for repeated fields when serializing to JSON](https://github.com/stepancheg/rust-protobuf/pull/550)
- Switch error handling to `thiserror` and `anyhow` crates
- `.proto` file parsing now lives in a separate crate `protobuf-parse`

## [3.0.0-alpha.1] - 2021-10-24

### Backward compatibility

Version 3.0 is backward incompatible with 2.0 version. Changes are listed here:

- Enum fields are now
  [generated as `ProtobufEnumOrUnknown<E>`](https://github.com/stepancheg/rust-protobuf/issues/233)
- Nested messages are now
  [generated in nested mods](https://github.com/stepancheg/rust-protobuf/commit/da2e25dc6c20efcea3893c78e587b43b89da9528)
- Getters are no longer generated for public fields
- Field accessors (getters and setters) are not generated by default for public fields
- [Remove global `parse_length_delimited*`
  functions](https://github.com/stepancheg/rust-protobuf/commit/91c0875e909cdc0648256f0c45cd4a9ade1e4fa0)
- `PartialEq` with large number of fields
  [now panics](https://github.com/stepancheg/rust-protobuf/commit/4f1ca564a00e85b6e3821e91aace71ccb6592bf5).
  Previosly it could cause stack overflow in the Rust compiler.
- [Change `message_down_cast*` functions
  signatures](https://github.com/stepancheg/rust-protobuf/commit/a05a4216fc3305c67b7a2d19011be3bd503d5166)
- [Remove `descriptorx` from `protobuf`
  crate](https://github.com/stepancheg/rust-protobuf/commit/4e8896645c3e017ac91f529cb69ce76b002f6fc1)

### New features

- [Option to store repeated message fields in `Vec` instead of `RepeatedField`](
  https://github.com/stepancheg/rust-protobuf/issues/280). This option may be turned on by default later.
- Similarly, [option to store singular field on `Option` instead of `SingularPtrField`](
  https://github.com/stepancheg/rust-protobuf/issues/300), which also may be turned on by default later.
- `generate_getter` option to disable generation of getters functions.
- [Flush `CodedOutputStream` on `drop`](https://github.com/stepancheg/rust-protobuf/commit/0e9cc5964c2731a771725bcf70125d3eb1c273b3)

## [2.27] - Unreleased

## [2.28.0] - 2022-09-26

- [backport optional fields from version 3](https://github.com/stepancheg/rust-protobuf/pull/649)
- `protoc-bin-vendored` now lives in a [separate repository](https://github.com/stepancheg/rust-protoc-bin-vendored)

## [2.27.1] - 2022-02-05

- Min rust version bumped back to 1.52.1

## [2.27.0] - 2022-02-03

- Bump min rust version to 1.55.0
- [Fixed invalid aliasing and uninitialized memory access](https://github.com/stepancheg/rust-protobuf/pull/592)

## [2.26.1] - 2022-02-01

- Documentation

## [2.26.0] - 2020-01-31

- Min supported Rust version is 1.52.1.
- [Fix `SingularField::unwrap_or_default`](https://github.com/stepancheg/rust-protobuf/issues/572)
- [`serde_rename_all` codegen option](https://github.com/stepancheg/rust-protobuf/pull/586)

## [2.25.2] - 2021-10-24

- [don't panic on short buffer](https://github.com/stepancheg/rust-protobuf/pull/571)

## [2.25.1] - 2021-08-21

- [Allow leading zeros in float literals exponent](https://github.com/stepancheg/rust-protobuf/pull/565)

## [2.25.0] - 2021-08-08

- [Implement `Extend` and more `PartialEq` for `RepeatedField`](https://github.com/stepancheg/rust-protobuf/issues/561)
- [Make code generation deterministic](https://github.com/stepancheg/rust-protobuf/issues/562)

## [2.24.2] - 2021-08-08

- [Fix reflective enum access](https://github.com/stepancheg/rust-protobuf/issues/564)

## [2.24.1] - 2021-06-11

- [Stopgap support for Apple M1 for protoc-bin-vendored](https://github.com/stepancheg/rust-protobuf/pull/556)

## [2.24.0] - 2021-06-11

- Accidentally published version roughtly equivalent to 2.23.0

## [2.23.0] - 2021-04-24

- Update bundled `protoc` version to 3.15.8

## [2.22.1] - 2021-03-18

- Work around [some breaking changes in Rust nightly](https://github.com/stepancheg/rust-protobuf/issues/551)

## [2.22.0] - 2021-02-06

- Slightly better prefix stripping algorithm in pure rust codegen: "." is now considered to be a prefix for "foo/bar.proto".
  (Probably Rust stdlib should do that out of the box)
- Update bundled version of `protoc` to version 3.14.0
- `protoc-bin-vendored` now includes `google/**.proto` files, so `import "google/protobuf/Timestamp.proto"`
  should work with this crate without relying on external files

## [2.21.0] - 2021-02-06

- [Use fully qualified crate name in serde derives](https://github.com/stepancheg/rust-protobuf/pull/545)

## [2.20.0] - 2021-01-06

- update `bytes` crate dependency version from 0.6 to 1.0

## [2.19.0] - 2021-01-05

- Add `UnknownFields::remove`
- Fix several inconsistencies between `protoc` parser and pure rust parser
- `protobuf::parse_from*` functions are deprecated, use `protobuf::Message::parse_from*` instead
- impl `IntoIterator` for `&mut RepeatedField<T>` and for `RepeatedField<T>`
- update `bytes` crate dependency version from 0.5 to 0.6

## [2.18.2] - 2021-03-28

- Backport `rust::skip` workaround from 2.22.1

## [2.18.1] - 2020-11-22

- [map field referencing nested messages](https://github.com/stepancheg/rust-protobuf/issues/531)

## [2.18.0] - 2020-10-04

- `gen_mod_rs` codegen option can be used to generate `.rs` files friendlier to generating files in `$OUT_DIR`

## [2.17.0] - 2020-08-12

- `protoc` crate now depends on `which` crate for `protoc` binary lookup
- pure rust codegen output adjusted to be closer to `protoc`-command based output
- `RepeatedField::retain` is implemented

## [2.16.2] - 2020-07-06

- Fix compilation when feature `with-bytes` is enabled

## [2.16.1] - 2020-07-06

- Mute self-deprecation warning when compiling rust-protobuf

## [2.16.0] - 2020-07-06

- Generated repeated and message fields for proto2 are
  [public now](https://github.com/stepancheg/rust-protobuf/commit/f391e9ae0968ae08f4a68798c3b3f25852590150)
  (for proto3 all fields are already public).
- Generated code no longer contains `unsafe`
- Minor changes in generated files

## [2.15.1] - 2020-06-26

- [Use full name of Box in generated code](https://github.com/stepancheg/rust-protobuf/pull/492)

## [2.15.0] - 2020-06-21

- Min supported rust version if 1.44.1 now
- Replace deprecated `#![cfg_attr(rustfmt, rustfmt_skip)]` with `#![rustfmt::skip]`

## [2.14.0] - 2020-04-12

- Rename `protoc_rust::Args` to `protoc_rust::Codegen`
- Rename `protobuf_codegen_pure::Args` to `protobuf_codegen_pure::Codegen`
- [`protoc-bin-vendored` crate](https://docs.rs/protoc-bin-vendored) introduced

## [2.13.0] - 2020-04-09

- [Implement Any::pack,is,unpack
  operations](https://github.com/stepancheg/rust-protobuf/commit/e91bf7eb20abe68a7b29264b864e2cecbbb3f769)
- Rename `protoc::Args` to `protoc::ProtocLangOut`

## [2.12.0] - 2020-03-26

- Generated code for reflection now references messages by Protobuf name, not by Rust name.

## [2.11.0] - 2020-03-23

### Backward compatibility

- [Rename](https://github.com/stepancheg/rust-protobuf/commit/65667cb6e75e91027d595e8be1bce25cc29d7c88)
  `ProtobufValueRef` to `ReflectValueRef`. Old name is kept for a while.

### Other changes

- Generated code [now uses](https://github.com/stepancheg/rust-protobuf/commit/f362d93c3a0f2405115f92a7f6bb08ad058fbf02)
  associated constant `Lazy::INIT` for `Lazy` intialization instead of initializing fields directly.

## [2.10.3] - 2020-03-23

- Oneof names are escaped now in generated code

## [2.10.2] - 2020-03-01

- Added `dyn` to a list of rust keyword needed escaping

## [2.10.1] - 2020-01-14

- Remove accidentally slipped into 2.10 [version check](https://github.com/stepancheg/rust-protobuf/issues/466)

## [2.10.0] - 2020-01-01

### Backward compatibility

- Minimum supported Rust version is 1.40.0 now
- `bytes` crate [upgraded to 0.5](https://github.com/stepancheg/rust-protobuf/issues/465)

## Other changes

- [`ProtobufError` now provides error message in `Display` instead of
  `Error::description`](https://github.com/stepancheg/rust-protobuf/commit/24c20a0503c0946836d3044dad524757bac2cc8a)
- [`Debug` is now implemented for `EnumValueDescriptor` and
  `ReflectValueRef`](https://github.com/stepancheg/rust-protobuf/commit/0e6a2f4c50f07d2c6f8007abd469daa08bc09b9c)

## [2.9] - Unreleased

Changes in 2.9 branch are not included in 2.10.

## [2.9.0] - (2019-09-30) yanked

### Backward compatibility

- Minimum supported Rust version is 1.34.2 now
- Generated code by protobuf compiler is now compatible
  only with exactly the same version of protobuf library.
  Note you can use
  [pure rust protobuf compiler](https://docs.rs/protobuf-codegen-pure)
  to avoid dependency on `protoc` binary.
- `UnknownFields::fields` field is
  [no longer public](https://github.com/stepancheg/rust-protobuf/commit/8ad35ecaa0accaa251f9f29708e4ed3b96f2351b)

### Big changes

- Text format and JSON printing and parsing is now implemented
- Mutation reflection is implemented
- All fields are public now except optional or repeated fields when `syntax = "proto2"`,
  but message fields are public even when `syntax = "proto2"`

### Other changes

- [`Box<dyn Message>` now implements
  `Clone`](https://github.com/stepancheg/rust-protobuf/commit/08aedca14f6a4cf8bb85c3e82d2dae05cddf57b8)
- Generated code is slightly cleaner now (does not use `use` statements)
- Generated code no longer uses unsafe (protobuf library still does)
- Add a couple functions to reflection

## [2.8] - Unreleased

## [2.8.2] - 2019-12-31

- [Add `async` and `await` to rust keywords](https://github.com/stepancheg/rust-protobuf/pull/461)

## [2.8.1] - 2019-09-06

- [hidden lifetime parameters in types are deprecated](https://github.com/stepancheg/rust-protobuf/issues/435)

## [2.8.0] - 2019-07-22

- [Fix `dyn Trait` warning (again)](https://github.com/stepancheg/rust-protobuf/issues/414)

## [2.7.0] - 2019-07-02
- Minimum supported Rust version
  [is 1.27](https://github.com/stepancheg/rust-protobuf/commit/f51811e8376f7c46b433479903a1bd8670246aa0).
  This version stabilizes `dyn Trait` syntax.
- `inside_protobuf` option is added which slightly modifies generated code inside protobuf.
  Should not affect users.
- [Generated files are now compatible only with the same version of
  runtime](https://github.com/stepancheg/rust-protobuf/commit/2ab4d50c27c4dd7803b64ce1a43e2c134532c7a6)
- [Fixed codegen for mutually recursive messages with
  oneofs](https://github.com/stepancheg/rust-protobuf/pull/420)
- [Clippy annotations are now generated as `#[allow(clippy::all)]` instead of
  `#[allow(clippy)]`](https://github.com/stepancheg/rust-protobuf/pull/332)

## [2.6.2] - 2019-06-03
- Fix [OOM on malformed input for fields of type
  `bytes::Bytes`](https://github.com/stepancheg/rust-protobuf/issues/411)

## [2.6.1] - 2019-05-27

- [Fix `Hash` of
  `UnknownFields`](https://github.com/stepancheg/rust-protobuf/commit/7f285cc42990e34bd8a489519aaae216a93584cf)
- Improve rustdoc a little

## [2.6.0] - 2019-05-19

- [lite_runtime rust-protobuf option](https://github.com/stepancheg/rust-protobuf/pull/399)
- Fix [OOM on malformed input](https://github.com/stepancheg/rust-protobuf/issues/411)
- Minimum supported Rust version is [1.26](https://github.com/stepancheg/rust-protobuf/commit/71f09ae92e86be2ce439e71452c3ca1749a4bda7)
- [Implement `Hash` for
  `UnknownFields`](https://github.com/stepancheg/rust-protobuf/commit/113babc8c56deb7e2453f0d11c2bfc21134d540f)

## [2.5.0] - 2019-04-15

- `generate_accessors` options to disable generation of accessor functions (except getters).
- [`Default` is now implented for all `&MyMessage`
  types](https://github.com/stepancheg/rust-protobuf/commit/c026777976c895898fb50bc7c52802967bd33af5#diff-405e0ba76bb0afaaa4e11e89bc4bb943R4)
- [`Debug` is now implemented for oneof enums](https://github.com/stepancheg/rust-protobuf/issues/397)
  
## [2.4.2] - 2019-03-29

- [Fix well-known types codegen](https://github.com/stepancheg/grpc-rust/issues/129)
- [More extension types are supported now](https://github.com/stepancheg/rust-protobuf/issues/392)

## [2.3.1] - 2019-03-05

- [Fix codegen when `syntax = "proto2"` and `with-bytes` option and string field with default
  value](https://github.com/stepancheg/rust-protobuf/issues/395)

## [2.3.0] - 2019-01-30

- [`Default` is implemented for enums even in proto2](
  https://github.com/stepancheg/rust-protobuf/commit/166966627ebc1e5ce650acd1593489e52757178e)
- [Fix codegen where map value is an enum](https://github.com/stepancheg/rust-protobuf/issues/376)

## [2.2.5] - 2019-01-20

- [Escape extension field names](https://github.com/stepancheg/rust-protobuf/issues/371)

## [2.2.4] - 2019-01-13

- [Replace tempdir dependency with tempfile](https://github.com/stepancheg/rust-protobuf/pull/374)
- [Fix serialization of signed int map keys or values](https://github.com/stepancheg/rust-protobuf/pull/372)

## [2.2.2] - 2018-12-29

- [Fix codegen on Windows](https://github.com/stepancheg/rust-protobuf/issues/356)

## [2.2.1] - 2018-12-25

- [Fix panic with oneof and bytes codegen](https://github.com/stepancheg/rust-protobuf/issues/362)

## [2.2.0] - 2018-11-17

- [Implement](https://github.com/stepancheg/rust-protobuf/commit/c0856a0b7b9a74224d535ecb691c46669c86a878)
  `From<Option<T>> for SingularPtrField<T>`
  
## [2.1.5] - 2019-01-13

- [Fix serialization of signed int map keys or values](https://github.com/stepancheg/rust-protobuf/pull/372)

## [2.1.4] - 2018-11-01

- Revert clippy annotations

## [2.1.3] - 2018-10-31

- [Replace old clippy annotations with recommended new
  annotations](https://github.com/stepancheg/rust-protobuf/pull/332)

## [2.1.2] - 2018-10-28

- [`cached_size` field is public now](https://github.com/stepancheg/rust-protobuf/issues/348)

## [2.1.1] - 2018-10-09

- [Make `Customize::_future_options` public](https://github.com/stepancheg/rust-protobuf/pull/346)

## [2.1.0] - 2018-10-06

- Support of `protoc` command from Google protobuf before 3.0 is dropped
  (it might work, but not tested by CI); this does not affect `syntax = "proto2"` which is supported
- [When using `protoc` codegen options can now be passed with `--rust_opt`
  flag](https://github.com/stepancheg/rust-protobuf/commit/7ebf32b47cb18160752a943dccb9d0d7ecdf91ed)
- [Serde is now supported](https://github.com/stepancheg/rust-protobuf/issues/266)
- [`unknown_fields` field is public now](https://github.com/stepancheg/rust-protobuf/commit/24e6479e869d61455bfcf50dde102e6278648516)

## [2.0.6] - 2019-01-13

- [Fix serialization of signed int map keys or values](https://github.com/stepancheg/rust-protobuf/pull/372)

## [2.0.5] - 2018-09-21

- [Global `parse_length_delimited*` functions are
  deprecated](https://github.com/stepancheg/rust-protobuf/commit/efdfd5cacfa4f87b2a6e3ffc124d77692db142d9)
- [Fixed a bug with quotes in string literal parsing in pure
  codegen](https://github.com/stepancheg/rust-protobuf/issues/337)

## [2.0.4] - 2018-07-19

- Minimum bytes version is 0.4 now (since protobuf doesn't work with 0.3 anyway)

## [2.0.3] - 2018-07-11

- [Fix panic on singular string field appeared more than
  once](https://github.com/stepancheg/rust-protobuf/commit/28adf07a0b0027ddc8ff57f04ffeb69f35f65620)
- [Properly handle map fields with key or value skipped in binary proto](
  https://github.com/stepancheg/rust-protobuf/issues/318)

## [2.0.2] - 2018-05-29

- Make rust-protobuf compatible with rust 1.23.0

## [2.0.1] - 2018-05-27

- Fix codegen with enum with
  [default value a reserved rust keyword](https://github.com/stepancheg/rust-protobuf/issues/295)

## [2.0.0] - 2018-05-17

- Rebublished branch 1.6 because of
  [backward compatibility issues in 1.6 branch](https://github.com/stepancheg/rust-protobuf/issues/289)

## [1.7.5] - 2018-05-20
- Fix [OOM on malformed input](https://github.com/stepancheg/rust-protobuf/issues/411)

## [1.7.4] - 2018-07-11

- [Fix panic on singular string field appeared more than
  once](https://github.com/stepancheg/rust-protobuf/commit/28adf07a0b0027ddc8ff57f04ffeb69f35f65620)
- [Properly handle map fields with key or value skipped in binary proto](
  https://github.com/stepancheg/rust-protobuf/issues/318)

## [1.7.3] - 2018-05-29

- Make rust-protobuf compatible with rust 1.23.0

## [1.7.2] - 2018-05-27

- Fix codegen with enum with
  [default value a reserved rust keyword](https://github.com/stepancheg/rust-protobuf/issues/295)

## [1.7.1] - 2018-05-17

- Rebublished branch 1.5 because of
  [backward compatibility issues in 1.6 branch](https://github.com/stepancheg/rust-protobuf/issues/289)

## [1.6.0] - 2018-05-11

Republished as 2.0.0

### New features

- Pure rust codegen
- Generated code can now be customized not only with `rustproto.proto`
  but also when invoked programmatically with
  [`protoc-rust`](https://github.com/stepancheg/rust-protobuf/blob/b8573bd53cf5a9611598abbf02b71c49e59a8891/protobuf-codegen/src/customize.rs#L9)
- [Oneof are now public by
  default](https://github.com/stepancheg/rust-protobuf/commit/8bd911e2ea0d4461580105209ae11d9d3ec21fd0)
- [Option to specify recursion limit](https://github.com/stepancheg/rust-protobuf/pull/248)
- [Implement conversions for `Repeated*`](https://github.com/stepancheg/rust-protobuf/pull/236)
- [Proto files with suffixes others than `.proto`
  are now supported](https://github.com/stepancheg/rust-protobuf/pull/265)
- [Generated code now uses closures instead of private functions
  for reflection](https://github.com/stepancheg/rust-protobuf/pull/267)

### Backward compatibility issues

- [Drop `MessageStatic` trait](https://github.com/stepancheg/rust-protobuf/issues/214)
- [Protobuf no longer exposes internal `hex`
  module](https://github.com/stepancheg/rust-protobuf/commit/8ad9687529a565c5ef2db93732cc20c8d8d22f00)
- [`protobuf-codegen` is a separate crate](https://github.com/stepancheg/rust-protobuf/pull/261)
- [Drop old reflection
  accessors](https://github.com/stepancheg/rust-protobuf/commit/7a03aee4e67bdd25ae6c403f37386707a0ab5eb9).
  Now code may need to be regenerated when protobuf version changed.
- [Implement `std::io` traits by `CodedInputStream` and
  `CodedOutputStream`](https://github.com/stepancheg/rust-protobuf/pull/232)
- `*descriptor_static()` function signatures no longer include `Option` param
  ([1](https://github.com/stepancheg/rust-protobuf/commit/8723fca5fb29e279b3ab7d2a28c8fab79189c9c2),
  [2](https://github.com/stepancheg/rust-protobuf/commit/c5446983be3b9d8d49ee39b443ed4fabd8f35440))

## [1.5.1] - 2018-04-02
- [Fix serialization or large repeated packed fields](https://github.com/stepancheg/rust-protobuf/issues/281)

## [1.5.0] - 2018-03-25
- [Unknown enum values are now stored in unknown fields](https://github.com/stepancheg/rust-protobuf/pull/276)

## [1.4.5] - 2018-04-02
- [Fix serialization or large repeated packed fields](https://github.com/stepancheg/rust-protobuf/issues/281)

## [1.4.4] - 2018-03-05
- [Escape macro keyword](https://github.com/stepancheg/rust-protobuf/pull/269)

## [1.4.3] - 2017-12-03
- [Allow enum variants to be named `Self`](https://github.com/stepancheg/rust-protobuf/pull/259)

## [1.4.2] - 2017-10-14
- [Properly read messages from blocking streams](https://github.com/stepancheg/rust-protobuf/issues/157)

## [1.4.1] - 2017-06-24
- [Convert `String` to `Chars`](https://github.com/stepancheg/rust-protobuf/pull/225)

## [1.4] - 2017-06-24
- Start of changelog

## [0.0.0] - 2013-07-28
- First commit added to the repository

'''
'''--- CHANGELOG.md ---
# Changelog

## [3.3] - Unreleased

* [Unnecessary copy in print_to_string_internal](https://github.com/stepancheg/rust-protobuf/pull/684)

## [3.3.0] - 2023-09-30

* [protoc_extra_arg not passed through](https://github.com/stepancheg/rust-protobuf/issues/643)
* [move custom code before derive block in struct](https://github.com/stepancheg/rust-protobuf/issues/675)
* [Enum::from_str](https://github.com/stepancheg/rust-protobuf/pull/664)

## [3.2.0] - 2022-09-26

* [Correctly specify `log` version](https://github.com/stepancheg/rust-protobuf/pull/652)
* [Hash for SpecialFields](https://github.com/stepancheg/rust-protobuf/pull/648)

## [3.1.0] - 2022-06-22

* [Reflection API to clear fields](https://github.com/stepancheg/rust-protobuf/pull/635)

## [3.0.3] - 2022-05-31

* `optional` fields in proto3 are now
  [handled correctly in `protoc-gen-rust` plugin for `protoc`](https://github.com/stepancheg/rust-protobuf/issues/625)

## [3.0.2] - 2022-05-06

* [Sort modules in generated mod.rs](https://github.com/stepancheg/rust-protobuf/issues/621)

## [3.0.1] - 2022-05-01

* More up to date readme.

## [3.0.0] - 2022-05-01

* New stable version released.

## Before version 3

[Changelog before version 3](CHANGELOG-before-3.md)

'''
'''--- CONTRIBUTING.md ---
# Contributing to rust-protobuf

## I just want to ask a question

Feel free to open an issue to ask a question, the volume of questions is low,
so it's OK at the moment. But please don't expect a prompt answer.

## I have found a bug

Please open an [issue](https://github.com/stepancheg/rust-protobuf/issues). When reporting a bug please include minimal example
providing as much information as possible. In particular, please specify:

* exact proto file
* generated file
* rust-protobuf version
* command which was used to generate code (ideally, temporary standalone repository)
* what is version of `protoc` command
* what is operating system

## Tests

Most of code changes should be accompanied by tests.

Most tests can be executed by invoking `cargo test` in `protobuf-test` directory.

## Codegen

If you change code generator, tests will check that code generator works correctly.

However, before submitting a PR, it's necessary to regenerate generated files
shipped with rust-protobuf, notably, `descriptor.rs`.

This can be done by invoking a script `protobuf/regenerate.sh`.

## Performance improvements

Are always welcome, especially if they are backward-compatible.

## Help wanted

Most of all documentation is needed, any changes to rustdoc or markdown pages on GitHub are welcome.

'''
'''--- Cargo.toml ---
[workspace]
resolver = "2"
members = [
    "ci-gen",
    "protoc-bin",
    "protobuf",
    "protobuf-json-mapping",
    "protobuf-codegen",
    "protobuf-examples/customize-serde",
    "protobuf-examples/dynamic",
    "protobuf-examples/pure-vs-protoc",
    "protobuf-examples/vs-prost",
    "protobuf-examples/issue-614",
    "protobuf-parse",
    "protobuf-support",
    "test-crates/perftest/bytes",
    "test-crates/perftest/misc",
    "test-crates/perftest/vs-cxx",
    "test-crates/protobuf-codegen-identical-test",
    "test-crates/protobuf-codegen-protoc-test",
    "test-crates/protobuf-codegen-pure-test",
    "test-crates/protobuf-parse-error-test",
    "test-crates/protobuf-fuzz",
    "test-crates/protobuf-test",
    "test-crates/protobuf-test-common",
]

'''
'''--- LICENSE.txt ---
Copyright (c) 2019 Stepan Koltsov

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
OR OTHER DEALINGS IN THE SOFTWARE.
'''
'''--- README.md ---
# rust-protobuf

<!-- https://travis-ci.org/stepancheg/rust-protobuf.png -->
[![crates.io version][crates-io-shields]][crates-io]
[![docs.rs][docs-rs-shields]][docs-rs]
[![GitHub Workflow Status][actions-shields]][actions]
[![License][license-shields]][license]

[crates-io]: https://crates.io/crates/protobuf
[crates-io-shields]: https://img.shields.io/crates/v/protobuf.svg
[docs-rs]: https://docs.rs/protobuf
[docs-rs-shields]: https://img.shields.io/badge/docs.rs-rustdoc-green.svg
[actions]: https://github.com/stepancheg/rust-protobuf/actions?query=workflow%3ACI
[actions-shields]: https://img.shields.io/github/workflow/status/stepancheg/rust-protobuf/CI
[license]: https://github.com/stepancheg/rust-protobuf/blob/master/LICENSE.txt
[license-shields]: https://img.shields.io/crates/l/protobuf.svg

[Protobuf](https://developers.google.com/protocol-buffers/docs/overview) implementation in [Rust](https://www.rust-lang.org/).

* Written in pure rust
* Generates rust code
* Has runtime library support for generated code
  (Coded{Input|Output}Stream impl)
* Supports both Protobuf versions 2 and 3
* and more

## Where is documentation

Documentation is [hosted on docs.rs](https://docs.rs/protobuf).

## Versions and branches

### Version 3

Version 3 is current stable version. Compared to version 2 it implements:
* runtime reflection
* JSON and text format parsing and printing
* dynamic messages (messages which can be created from `.proto` file on the fly
  without code generation)

### Version 2

Version 2 is previous stable version. Only most critical bugfixes will be applied
to 2.x version, otherwise it won't be maintained.

### Help

The crate **needs help**:
* **a new maintainer**, but also
* testing
* documentation
* examples to be used as documentation
* feedback on API design
* feedback on implementation
* pull requests

## Changelog

See [CHANGELOG.md](CHANGELOG.md) for a list of changes and compatility issues between versions.

## Related projects

* [prost](https://github.com/tokio-rs/prost) — another protobuf implementation in Rust, also has gRPC implementation
* [quick-protobuf](https://github.com/tafia/quick-protobuf) — alternative protobuf implementation in Rust
* [grpc-rs](https://github.com/pingcap/grpc-rs/) — another gRPC implementation for Rust
* [grpc-rust](https://github.com/stepancheg/grpc-rust) — incomplete implementation of gRPC based on this library

'''
'''--- ci-gen/Cargo.toml ---
[package]
name = "ci-gen"
version = "0.0.0"
authors = ["Stiopa Koltsov <stepan.koltsov@gmail.com>"]
edition = "2021"
publish = false

[dependencies]

'''
'''--- ci-gen/src/actions.rs ---
use std::fmt;

use crate::ghwf::Step;
use crate::yaml::Yaml;

pub fn checkout_sources_depth(depth: Option<u32>) -> Step {
    let mut step = Step::uses("Checkout sources", "actions/checkout@v2");
    if let Some(depth) = depth {
        step.with = Some(Yaml::Map(vec![(
            "fetch-depth".to_owned(),
            Yaml::string(depth.to_string()),
        )]));
    }
    step
}

pub fn checkout_sources() -> Step {
    checkout_sources_depth(None)
}

#[derive(Eq, PartialEq, Copy, Clone)]
pub enum RustToolchain {
    Stable,
    Beta,
    Nightly,
}

impl fmt::Display for RustToolchain {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            RustToolchain::Stable => write!(f, "stable"),
            RustToolchain::Beta => write!(f, "beta"),
            RustToolchain::Nightly => write!(f, "nightly"),
        }
    }
}

pub fn rust_install_toolchain_with_components(channel: RustToolchain, components: &[&str]) -> Step {
    let mut params = vec![
        ("profile", "minimal".to_owned()),
        ("toolchain", format!("{}", channel)),
        ("override", "true".to_owned()),
    ];
    if !components.is_empty() {
        params.push(("components", components.join(", ")));
    }
    Step::uses_with(
        "Install toolchain",
        "actions-rs/toolchain@v1",
        Yaml::map(params),
    )
}

pub fn rust_install_toolchain(channel: RustToolchain) -> Step {
    rust_install_toolchain_with_components(channel, &[])
}

pub fn cargo(name: &str, command: &str, args: &str) -> Step {
    let mut with = vec![("command", command)];
    if !args.is_empty() {
        with.push(("args", args));
    }
    Step::uses_with(name, "actions-rs/cargo@v1", Yaml::map(with))
}

pub fn cargo_test(name: &str, args: &str) -> Step {
    cargo(name, "test", args)
}

pub fn cargo_miri_setup(name: &str) -> Step {
    cargo(name, "miri", "setup")
}

pub fn cargo_miri_test(name: &str, args: &str) -> Step {
    cargo(name, "miri", &format!("test {}", args))
}

#[allow(dead_code)]
pub fn cargo_build(name: &str, args: &str) -> Step {
    cargo(name, "build", args)
}

#[allow(dead_code)]
pub fn cargo_check(name: &str, args: &str) -> Step {
    cargo(name, "check", args)
}

pub fn cargo_doc(name: &str, args: &str) -> Step {
    cargo(name, "doc", args)
}

pub fn cache(name: &str, key: &str, path: &str) -> Step {
    Step::uses_env_with(
        name,
        "actions/cache@v2",
        &[("cache-name", "pb")],
        Yaml::map(vec![("key", key), ("path", path)]),
    )
}

'''
'''--- ci-gen/src/cargo_sync_readme.rs ---
use std::fs;
use std::io;
use std::process::Command;

use crate::checkout_sources;
use crate::rust_install_toolchain;
use crate::Job;
use crate::RustToolchain;
use crate::Step;

fn find_sync_readme_crates() -> Vec<String> {
    fn walk(path: &str, depth: u32, crates: &mut Vec<String>) {
        let path_fs = if path.is_empty() { "." } else { path };
        for cr in fs::read_dir(path_fs).unwrap() {
            let cr = cr.unwrap();
            if !fs::metadata(cr.path()).unwrap().is_dir() {
                continue;
            }

            let file_name = cr.file_name().to_str().unwrap().to_owned();
            if file_name == "target" {
                continue;
            }

            let child_path = if path.is_empty() {
                file_name.clone()
            } else {
                format!("{}/{}", path, file_name)
            };

            if depth == 0 {
                walk(&child_path, depth + 1, crates);
            }

            let readme = cr.path().join("README.md");
            let readme = match fs::read_to_string(&readme) {
                Ok(readme) => readme,
                Err(e) if e.kind() == io::ErrorKind::NotFound => {
                    continue;
                }
                Err(e) => panic!("failed to read {}: {}", readme.display(), e),
            };
            if readme.contains("<!-- cargo-sync-readme") {
                crates.push(child_path);
            }
        }
    }

    let mut crates = Vec::new();
    walk("", 0, &mut crates);
    crates.sort();
    crates
}

pub(crate) fn cargo_sync_readme_job() -> Job {
    let mut steps = vec![
        checkout_sources(),
        rust_install_toolchain(RustToolchain::Stable),
        Step::run(
            "install cargo sync-readme",
            "cargo install cargo-sync-readme",
        ),
    ];
    for cr in find_sync_readme_crates() {
        Command::new("cargo")
            .arg("sync-readme")
            .current_dir(&cr)
            .output()
            .unwrap();

        steps.push(Step::run(
            &format!("sync-readme {}", cr),
            &format!("cd {} && cargo sync-readme --check", cr),
        ));
    }
    Job {
        id: "cargo-sync-readme".to_owned(),
        name: "Check sync-readme".to_owned(),
        steps,
        ..Job::default()
    }
}

'''
'''--- ci-gen/src/ghwf.rs ---
use std::fmt;

use crate::yaml::Yaml;

#[allow(dead_code)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub enum Env {
    WindowsLatest,
    UbuntuLatest,
    MacosLatest,
}

impl Default for Env {
    fn default() -> Self {
        Env::UbuntuLatest
    }
}

impl fmt::Display for Env {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Env::WindowsLatest => write!(f, "windows-latest"),
            Env::UbuntuLatest => write!(f, "ubuntu-latest"),
            Env::MacosLatest => write!(f, "macos-latest"),
        }
    }
}

/// Github workflow step
#[derive(Default)]
pub struct Step {
    pub name: String,
    pub uses: Option<String>,
    pub with: Option<Yaml>,
    pub run: Option<String>,
    pub shell: Option<String>,
    pub env: Vec<(String, String)>,
}

impl Step {
    pub fn uses(name: &str, uses: &str) -> Step {
        Step {
            name: name.to_owned(),
            uses: Some(uses.to_owned()),
            ..Default::default()
        }
    }

    pub fn uses_with(name: &str, uses: &str, with: Yaml) -> Step {
        Step {
            name: name.to_owned(),
            uses: Some(uses.to_owned()),
            with: Some(with),
            ..Default::default()
        }
    }

    pub fn uses_env_with(name: &str, uses: &str, env: &[(&str, &str)], with: Yaml) -> Step {
        Step {
            name: name.to_owned(),
            uses: Some(uses.to_owned()),
            env: env
                .into_iter()
                .map(|(k, v)| (String::from(*k), String::from(*v)))
                .collect(),
            with: Some(with),
            ..Default::default()
        }
    }

    pub fn run(name: &str, run: &str) -> Step {
        Step {
            name: name.to_owned(),
            run: Some(run.to_owned()),
            shell: Some("bash".to_owned()),
            ..Default::default()
        }
    }
}

impl Step {
    pub fn env(mut self, name: &str, value: &str) -> Self {
        self.env.push((name.to_owned(), value.to_owned()));
        self
    }
}

impl Into<Yaml> for Step {
    fn into(self) -> Yaml {
        let Step {
            name,
            uses,
            with,
            run,
            shell,
            env,
        } = self;
        let mut entries = Vec::new();
        entries.push(("name", Yaml::string(name)));
        if let Some(uses) = uses {
            entries.push(("uses", Yaml::string(uses)));
        }
        if let Some(with) = with {
            entries.push(("with", with));
        }
        if let Some(run) = run {
            entries.push(("run", Yaml::string(run)));
        }
        if let Some(shell) = shell {
            entries.push(("shell", Yaml::string(shell)));
        }
        if !env.is_empty() {
            entries.push(("env", Yaml::map(env)));
        }
        Yaml::map(entries)
    }
}

#[derive(Default)]
pub struct Job {
    pub id: String,
    pub name: String,
    pub runs_on: Env,
    pub steps: Vec<Step>,
    pub timeout_minutes: Option<u64>,
    pub env: Vec<(String, String)>,
}

impl Job {
    #[allow(dead_code)]
    pub fn step(mut self, step: Step) -> Self {
        self.steps.push(step);
        self
    }
}

impl Into<(String, Yaml)> for Job {
    fn into(self) -> (String, Yaml) {
        assert!(!self.id.is_empty());
        let mut entries = vec![
            ("name", Yaml::string(self.name)),
            ("runs-on", Yaml::string(format!("{}", self.runs_on))),
        ];
        if let Some(timeout_minutes) = self.timeout_minutes {
            entries.push((
                "timeout-minutes",
                Yaml::string(format!("{}", timeout_minutes)),
            ));
        }
        if !self.env.is_empty() {
            entries.push(("env", Yaml::map(self.env)));
        }
        entries.push(("steps", Yaml::list(self.steps)));
        (self.id, Yaml::map(entries))
    }
}

'''
'''--- ci-gen/src/install_protobuf.rs ---
use crate::actions::cache;
use crate::ghwf::Step;
use crate::Os;
use crate::MACOS;

pub(crate) fn install_protobuf(os: Os) -> Vec<Step> {
    let protobuf_version = "3.19.4";

    let mut steps = Vec::new();
    steps.push(cache(
        "Cache protobuf",
        &format!("pb-{}-{}", os.name, protobuf_version),
        "~/pb",
    ));

    if os == MACOS {
        steps.push(Step::run("Install pkg-config", "brew install pkg-config"));
    }

    steps.push(
        Step::run("Install protobuf", "ci/install-protobuf.sh")
            .env("PROTOBUF_VERSION", protobuf_version),
    );
    steps.push(Step::run("Protoc check", "protoc --version"));
    steps
}

'''
'''--- ci-gen/src/main.rs ---
use std::env;
use std::fs::File;
use std::io::Read;
use std::io::Write;

use crate::actions::cargo_check;
use crate::actions::cargo_doc;
use crate::actions::cargo_miri_setup;
use crate::actions::cargo_miri_test;
use crate::actions::cargo_test;
use crate::actions::checkout_sources;
use crate::actions::checkout_sources_depth;
use crate::actions::rust_install_toolchain;
use crate::actions::rust_install_toolchain_with_components;
use crate::actions::RustToolchain;
use crate::cargo_sync_readme::cargo_sync_readme_job;
use crate::ghwf::Env;
use crate::ghwf::Job;
use crate::ghwf::Step;
use crate::yaml::Yaml;
use crate::yaml::YamlWriter;

mod actions;
mod cargo_sync_readme;
mod ghwf;
mod install_protobuf;
mod yaml;

#[derive(PartialEq, Eq, Copy, Clone)]
struct Os {
    name: &'static str,
    ghwf: Env,
}

const LINUX: Os = Os {
    name: "linux",
    ghwf: Env::UbuntuLatest,
};
const MACOS: Os = Os {
    name: "macos",
    ghwf: Env::MacosLatest,
};
const WINDOWS: Os = Os {
    name: "windows",
    ghwf: Env::WindowsLatest,
};

#[derive(Eq, PartialEq)]
enum Features {
    Default,
    Specific(&'static [&'static str]),
    All,
}

impl Features {
    fn flag(&self) -> String {
        match self {
            Features::Default => format!(""),
            Features::Specific(f) => format!("--features={}", f.join(",")),
            Features::All => format!("--all-features"),
        }
    }

    fn flag_suffix(&self) -> String {
        let flag = self.flag();
        if flag.is_empty() {
            "".to_owned()
        } else {
            format!(" {}", flag)
        }
    }

    fn id(&self) -> String {
        match self {
            Features::Default => format!("default-features"),
            Features::All => format!("all-features"),
            Features::Specific(s) => s.join("-"),
        }
    }

    fn name(&self) -> String {
        match self {
            Features::Default => format!("default features"),
            Features::All => format!("all features"),
            Features::Specific(s) => s.join(","),
        }
    }
}

fn self_check_job() -> Job {
    Job {
        id: format!("self-check"),
        name: format!("CI self-check"),
        runs_on: LINUX.ghwf,
        steps: vec![
            checkout_sources(),
            rust_install_toolchain(RustToolchain::Stable),
            Step::run("The check", "cargo run -p ci-gen -- --check"),
        ],
        ..Default::default()
    }
}

fn job(channel: RustToolchain, os: Os, features: Features) -> Job {
    let mut steps = vec![];
    steps.push(checkout_sources());
    steps.push(rust_install_toolchain(channel));

    steps.extend(install_protobuf::install_protobuf(os));

    if os != WINDOWS {
        steps.push(Step::run(
            "Compile interop",
            "test-crates/interop/cxx/compile.sh",
        ));
    }

    // * Nothing works on Windows
    // * Only regenerate with default features to avoid rebuilding twice
    if os != WINDOWS && features == Features::Default {
        steps.push(Step::run("Regenerate", "protobuf/regenerate.sh"));
    }

    match features {
        Features::Specific(..) => {
            steps.push(cargo_test(
                "protobuf-codegen-protoc-test",
                &format!(
                    "--manifest-path=test-crates/protobuf-codegen-protoc-test/Cargo.toml{}",
                    features.flag_suffix()
                ),
            ));
            steps.push(cargo_test(
                "protobuf-codegen-pure-test",
                &format!(
                    "--manifest-path=test-crates/protobuf-codegen-pure-test/Cargo.toml{}",
                    features.flag_suffix()
                ),
            ));
        }
        _ => {
            steps.push(Step::run(
                "Test all",
                &format!("cargo test --all --all-targets{}", features.flag_suffix()),
            ));
            if os == LINUX {
                // https://github.com/rust-lang/cargo/issues/6669
                steps.push(Step::run(
                    "Test all",
                    &format!("cargo test{}", features.flag_suffix()),
                ));

                steps.push(cargo_doc("cargo doc", &features.flag()));
            }
        }
    }

    let mut env = vec![("RUST_BACKTRACE".to_owned(), "1".to_owned())];
    if os == WINDOWS {
        env.push(("VCPKGRS_DYNAMIC".to_owned(), "1".to_owned()));
    };
    let id = format!("{}-{}-{}", os.name, channel, features.id());
    let name = format!("{} {} ({})", os.name, channel, features.name());
    Job {
        id,
        name,
        runs_on: os.ghwf.to_owned(),
        steps,
        env,
        ..Default::default()
    }
}

fn miri_test_job() -> Job {
    let mut steps = Vec::new();

    steps.push(checkout_sources());
    steps.push(rust_install_toolchain_with_components(
        RustToolchain::Nightly,
        &["miri"],
    ));
    steps.push(cargo_miri_setup("cargo-miri-setup"));
    steps.push(cargo_miri_test(
        "cargo-miri-test",
        "-p protobuf --lib --all-features",
    ));

    let id = "miri-test".to_owned();
    let name = "Miri test".to_owned();
    let env = vec![
        ("RUST_BACKTRACE".to_owned(), "1".to_owned()),
        ("RUST_TEST_THREADS".to_owned(), "1".to_owned()),
        ("MIRIFLAGS".to_owned(), "-Zmiri-tag-raw-pointers".to_owned()),
    ];
    Job {
        id,
        name,
        runs_on: LINUX.ghwf.to_owned(),
        steps,
        env,
        timeout_minutes: Some(5),
        ..Job::default()
    }
}

// https://github.com/megalinter/megalinter
fn super_linter_job() -> Job {
    let mut steps = Vec::new();
    steps.push(checkout_sources_depth(Some(0)));
    steps.push(
        Step::uses("mega-linter", "megalinter/megalinter@v5")
            .env("VALIDATE_ALL_CODEBASE", "false")
            .env("DEFAULT_BRANCH", "master")
            .env("GITHUB_TOKEN", "${{ secrets.GITHUB_TOKEN }}")
            // Too many false positives
            .env("VALIDATE_JSCPD", "false")
            // Too many dull reports like how we should pluralise variable names
            .env("VALIDATE_PROTOBUF", "false")
            // Clippy reports too many false positives
            .env("VALIDATE_RUST_CLIPPY", "false")
            // We don't care about previous edition
            .env("VALIDATE_RUST_2015", "false")
            // Finds copy-paste in LICENSE files.
            .env("VALIDATE_COPYPASTE", "false")
            // Complains about protobuf" in yml files.
            .env("VALIDATE_SPELL", "false"),
    );
    Job {
        id: "mega-linter".to_owned(),
        name: "mega-linter".to_owned(),
        runs_on: LINUX.ghwf,
        steps,
        ..Default::default()
    }
}

fn rustfmt_job() -> Job {
    let os = LINUX;
    let mut steps = Vec::new();
    steps.push(checkout_sources());
    // force generate code
    steps.extend(install_protobuf::install_protobuf(os));
    steps.push(cargo_check("cargo check", ""));
    steps.push(Step::run("cargo fmt check", "cargo fmt -- --check"));
    Job {
        id: "rustfmt-check".to_owned(),
        name: "rustfmt check".to_owned(),
        runs_on: os.ghwf,
        steps,
        ..Default::default()
    }
}

fn jobs() -> Yaml {
    let mut r = Vec::new();

    r.push(job(RustToolchain::Stable, LINUX, Features::Default));
    r.push(job(RustToolchain::Beta, LINUX, Features::Default));
    r.push(job(
        RustToolchain::Stable,
        LINUX,
        Features::Specific(&["with-bytes"]),
    ));
    r.push(job(RustToolchain::Nightly, LINUX, Features::All));

    r.push(job(RustToolchain::Stable, WINDOWS, Features::Default));

    r.push(miri_test_job());

    r.push(super_linter_job());

    r.push(rustfmt_job());

    r.push(cargo_sync_readme_job());

    r.push(self_check_job());

    // TODO: enable macos
    //r.push(job(RustToolchain::Stable, MACOS, Features::Default));

    Yaml::map(r.into_iter().map(Job::into))
}

fn main() {
    let args: Vec<String> = env::args().skip(1).collect();
    let args: Vec<&str> = args.iter().map(|a| a.as_str()).collect();

    let yaml = Yaml::map(vec![
        ("on", Yaml::list(vec!["push", "pull_request"])),
        ("name", Yaml::string("CI")),
        ("jobs", jobs()),
    ]);

    let mut writer = YamlWriter::default();
    writer.write_line(&format!(
        "# @generated by {}, do not edit",
        env!("CARGO_PKG_NAME")
    ));
    writer.write_line("");
    writer.write_yaml(&yaml);
    let ci_yml = writer.buffer;

    let ci_yml_path = ".github/workflows/ci.yml";

    match args.as_slice() {
        &[] => {
            File::create(ci_yml_path)
                .unwrap()
                .write_all(ci_yml.as_bytes())
                .unwrap();
            eprintln!("written {}", ci_yml_path);
        }
        &["--check"] => {
            let mut actual = String::new();
            File::open(ci_yml_path)
                .unwrap()
                .read_to_string(&mut actual)
                .unwrap();
            assert!(ci_yml == actual);
            eprintln!("The file is correct")
        }
        args => panic!("unknown args: {:?}", args),
    }
}

'''
'''--- ci-gen/src/yaml.rs ---
#[derive(Clone)]
pub enum Yaml {
    String(String),
    List(Vec<Yaml>),
    Map(Vec<(String, Yaml)>),
}

impl From<&Yaml> for Yaml {
    fn from(y: &Yaml) -> Self {
        y.clone()
    }
}

impl From<String> for Yaml {
    fn from(s: String) -> Self {
        Yaml::String(s)
    }
}

impl From<&str> for Yaml {
    fn from(s: &str) -> Self {
        Yaml::String(s.to_owned())
    }
}

impl From<&&str> for Yaml {
    fn from(s: &&str) -> Self {
        Yaml::String((*s).to_owned())
    }
}

impl<T: Into<Yaml>> From<Vec<T>> for Yaml {
    fn from(v: Vec<T>) -> Self {
        Yaml::List(v.into_iter().map(|t| t.into()).collect())
    }
}

impl Yaml {
    pub fn map<K: Into<String>, V: Into<Yaml>, E: IntoIterator<Item = (K, V)>>(entries: E) -> Yaml {
        Yaml::Map(
            entries
                .into_iter()
                .map(|(k, v)| (k.into(), v.into()))
                .collect(),
        )
    }

    pub fn list<V: Into<Yaml>, E: IntoIterator<Item = V>>(values: E) -> Yaml {
        Yaml::List(values.into_iter().map(|v| v.into()).collect())
    }

    pub fn string<S: Into<String>>(s: S) -> Yaml {
        Yaml::String(s.into())
    }
}

#[derive(Default)]
pub struct YamlWriter {
    pub buffer: String,
    indent: u32,
    minus: MinusState,
}

#[derive(Eq, PartialEq)]
enum MinusState {
    No,
    Yes,
    Already,
}

impl Default for MinusState {
    fn default() -> Self {
        MinusState::No
    }
}

impl YamlWriter {
    pub fn write_line(&mut self, line: &str) {
        if line.is_empty() {
            self.buffer.push_str("\n");
        } else {
            for _ in 0..self.indent {
                self.buffer.push_str("    ");
            }

            match self.minus {
                MinusState::No => {}
                MinusState::Yes => {
                    self.buffer.push_str("- ");
                    self.minus = MinusState::Already;
                }
                MinusState::Already => {
                    self.buffer.push_str("  ");
                }
            }

            self.buffer.push_str(line);
            self.buffer.push_str("\n");
        }
    }

    pub fn write_yaml(&mut self, yaml: &Yaml) {
        match yaml {
            Yaml::String(s) => {
                self.write_line(s);
            }
            Yaml::List(l) => {
                for x in l {
                    assert!(self.minus == MinusState::No);
                    self.minus = MinusState::Yes;
                    self.write_yaml(x);
                    assert!(self.minus != MinusState::No);
                    self.minus = MinusState::No;
                }
            }
            Yaml::Map(m) => {
                for (k, v) in m {
                    match v {
                        Yaml::String(v) => {
                            self.write_line(&format!("{}: {}", k, v));
                        }
                        _ => {
                            self.write_line(&format!("{}:", k));
                            self.indent += 1;
                            self.write_yaml(v);
                            self.indent -= 1;
                        }
                    }
                }
            }
        }
    }
}

'''
'''--- ci/env-debug.sh ---
#!/bin/sh

# Print environment in travis job
# The script is cheap but may save hours of debugging

set -e

echo "pwd: `pwd`"
echo "uname: `uname`"
echo "PATH: $PATH"
rustc --version
cargo --version
echo
echo "Environment variables:"
env

# vim: set ts=4 sw=4 et:

'''
'''--- ci/install-protobuf.sh ---
#!/bin/sh

set -ex

die() {
    echo "$@" >&2
    exit 1
}

test -n "$PROTOBUF_VERSION" || die "PROTOBUF_VERSION env var is undefined"

path_tr() {
    case `uname` in
        MINGW64*)
            cygpath --mixed "$1"
        ;;
        *)
            echo "$1"
        ;;
    esac
}

test -n "$GITHUB_PATH"
test -n "$GITHUB_ENV"

echo "$(path_tr $HOME/pb/bin)" >> "$GITHUB_PATH"
echo "LD_LIBRARY_PATH=$(path_tr $HOME/pb/lib)" >> "$GITHUB_ENV"
echo "PKG_CONFIG_PATH=$(path_tr $HOME/pb/lib/pkgconfig)" >> "$GITHUB_ENV"
echo "PROTOBUF_PREFIX=$(path_tr $HOME/pb)" >> "$GITHUB_ENV"

if test -e "$HOME/pb/bin/protoc" -o -e "$HOME/pb/bin/protoc.exe"; then
    echo "Already exists"
    $HOME/pb/bin/protoc --version
    exit 0
fi

if test -e "$HOME/pb"; then
    echo "... but $HOME/pb exists, and in it:"
    (
        cd $HOME/pb
        ls
        echo "EOF"
    )
fi

cd
rm -rf pb
mkdir pb

case `uname` in
    Linux|Darwin)
        # Check we have ccache
        # ccache --version
        # export CC="ccache gcc"
        # export CXX="ccache g++"

        case "$PROTOBUF_VERSION" in
        2*)
            basename=protobuf-$PROTOBUF_VERSION
            ;;
        3*)
            basename=protobuf-cpp-$PROTOBUF_VERSION
            ;;
        *)
            die "unknown protobuf version: $PROTOBUF_VERSION"
            ;;
        esac

        curl -sL https://github.com/protocolbuffers/protobuf/releases/download/v$PROTOBUF_VERSION/$basename.tar.gz | tar zx

        cd protobuf-$PROTOBUF_VERSION

        ./configure --prefix=$HOME/pb && make -j2 && make install

    ;;
    MSYS_NT*|MINGW64*)
        (
            cd pb
            curl -sLO https://github.com/protocolbuffers/protobuf/releases/download/v$PROTOBUF_VERSION/protoc-$PROTOBUF_VERSION-win32.zip
            unzip protoc-$PROTOBUF_VERSION-win32.zip
        )
    ;;
    *)
        die "unknown uname: `uname`"
    ;;
esac

$HOME/pb/bin/protoc --version

'''
'''--- doc/FAQ.md ---
# Frequently asked questions

## Questions about Protocol Buffers

Protocol Buffers is designed and maintained by Google.

Google has very thorough documentation including [FAQ](https://developers.google.com/protocol-buffers/docs/faq).

If your question is not rust-protobuf-specific, it's likely you can find your answer there.

## How to serialize a message to bytes?

The easiest way to do it is to invoke `write_to_bytes` function:

```
message.write_to_bytes()
```

## How to deserialize a message from a byte array?
Use `protobuf::Message`:
```
let my_message: MyMessage = Message::parse_from_bytes(bytes).unwrap()
```

## What is `cached_size` field?

Before serializing protobuf need to know sizes of all nested structures.

So serialization of protobuf message is done in two steps:
* first, compute sizes of all nested messages
* second, write the message tree with each message prepended by serialized size

So before serialization protobuf implementation stores size of a message into `cached_size` field.

(The same strategy used at least in Google's C++ and Java implementation of Protocol Buffers)

Sometimes it's annoying. Previously rust-protobuf stored message sizes in external buffer,
but it was slightly worse performance-wise.

rust-protobuf could have an option to skip generation of `cached_size`
and use external buffer when there's no such field. If you need that could be useful to you,
please open an issue.

## What is `unknown_fields` field?

When unknown field is encountered during parsing (e. g. field added in newer version of `.proto` file)
this field data is stored in `unknown_fields`.
The purpose of this field is to be able to perform loseless read-modify-write operation
even with older version of `proto` file which does not know about new fields.

## You answer is not there?

Feel free to open an issue with a question.

'''
'''--- doc/past-present-future.md ---
# Past, present and future of rust-protobuf

## Past

I started rust-protobuf 7 years ago (time flies).
I wanted to implement something and found no protobuf implementation in Rust.

So I decided to implement it. Implementation took quite a lot of time,
and I didn't implement that other project I wanted rust-protobuf to be used for.

That was a fun time. Rust was very far from being stable, breaking changes occurred weekly,
and patching rust-protobuf was not trivial because rust-protobuf itself contains generated code,
and fixing for rust updates required patching the library, the code generator
**and generated code** inside protobuf. I usually used `sed` to patch generated code
and occasionally I used previous version of rust to generate code compatible with newer rust.

There are still references to these old times. For example, `Debug` trait was called `Show` in early rust,
and this name is still
[mentioned in the code generator](https://github.com/stepancheg/rust-protobuf/blob/188596b3d78b381d49a753cdb3ecb5fbc9382b0d/protobuf-codegen/src/gen/message.rs#L535).

Many API decisions of rust-protobuf which seem to be strange, they can be explained by historical reasons.
For example, in rust-protobuf version 2 `Debug` implementation of messages outputs protobuf text format,
not standard rust debugging output: there was no clear explanation what `Debug` was supposed to do.

Another example, in the old times `cargo` didn't have `build.rs` files,
so files needed to be generated manually and probably committed to the repository,
and the code generator was optimized for storing generated files in the source tree.

Also, in earlier days, rust-protobuf had zero external dependencies because all
the libraries broke too often). This also explains some API or implementation decisions.
In rust-protobuf version 2, core library, `protobuf`, still has no non-optional dependencies.
Version 3 however started depending on other libraries.

## Present

There are two versions of rust-protobuf now: 2 and 3-alpha.

Version 2 is stable, it provides good backwards compatibility.

Version 3-alpha contains multiple improvements (mostly fixing past mistakes). It implements:
* proper runtime reflection
* dynamic messages
* json and text format printing and parsing
* better mapping of proto messages to rust module namespaces
* various API cleanups

Version 3 of rust-protobuf is mostly done. It requires about 20 hours of work to release it.

Version 3 is backwards-incompatible with version 2.
It is not possible to implement certain features of rust-protobuf 3 in version 2
without breaking backwards compatibility.

### Prost

Some time ago people started prost project, which is an alternative implementation or protobuf.
It has some advantages and some drawbacks.

Here I tried to do
[the comparison](https://github.com/stepancheg/rust-protobuf/tree/master/protobuf-examples/vs-prost).
I see some things rust-protobuf does better. And I learned a few tricks from prost,
and implemented them in rust-protobuf.

A long time ago there were some pull requests to rust-protobuf
which I had to reject for reasons like
* they broke backwards compatibility
* I could not always understand why the change is made
* there were no tests
* sometimes I was too slow to respond to pull requests or issues

Perhaps these rejections were the reason why prost project started. I don't know.
We didn't discuss it.

## Future

The future is foggy. Technically, I could release rust-protobuf 3. But:
* it would be a moral obligation to maintain it, and I have a full-time job
  unrelated to rust-protobuf
* having more than one protobuf implementation is not necessarily good

And if prost is considered superior to rust-protobuf,
maybe it would be better to keep maintaining rust-protobuf at version 2 and never release version 3.
And recommend using prost instead.

Advice (on [reddit](https://www.reddit.com/r/rust/comments/sls4uw/past_present_and_future_of_rustprotobuf/),
or in [email](mailto:stepan.koltsov@gmail.com)) would be appreciated.

'''
'''--- google-protobuf-all-protos/README.md ---
# .proto

All `.proto` files from protobuf repository.

Used in parser tests.

'''
'''--- google-protobuf-all-protos/update.sh ---
#!/bin/sh

set -ex

cd "$(dirname "$0")"

rm -rf protobuf protobuf-git

mkdir protobuf

git clone --branch v3.19.4 --depth 1 https://github.com/google/protobuf/ protobuf-git

rsync -r --include='*.proto' --include='*/' --exclude='*' --prune-empty-dirs protobuf-git protobuf

rm -rf protobuf-git

# vim: set ts=4 sw=4 et:

'''
'''--- proto/update.sh ---
#!/bin/sh

# Update bundled .proto files

set -ex

cd "$(dirname $0)"

cargo build --manifest-path=../protoc-bin/Cargo.toml --bin protoc-bin-print-paths

eval "$(cargo run --manifest-path=../protoc-bin/Cargo.toml --bin protoc-bin-print-paths)"

test -n "$PROTOC"
test -n "$PROTOBUF_INCLUDE"

rm -rf google
cp -r "$PROTOBUF_INCLUDE/google" google

cp -r "$PROTOBUF_INCLUDE/google" ../protobuf-parse/src/proto/
cp -r "rustproto.proto" ../protobuf-parse/src/proto/

# vim: set ts=4 sw=4 et:

'''
'''--- protobuf-codegen/Cargo.toml ---
[package]
name = "protobuf-codegen"
version = "4.0.0-alpha.0"
authors = ["Stepan Koltsov <stepan.koltsov@gmail.com>"]
edition = "2021"
license = "MIT"
homepage = "https://github.com/stepancheg/rust-protobuf/"
repository = "https://github.com/stepancheg/rust-protobuf/"
description = """
Code generator for rust-protobuf.

Includes a library to invoke programmatically (e. g. from `build.rs`) and `protoc-gen-rust` binary.
"""

[lib]
bench = false

[dependencies]
thiserror = "1.0.30"
anyhow    = "1.0.53"
regex     = "1.5.5"
once_cell = "1.10.0"
tempfile  = "3"

protobuf = { path = "../protobuf", version = "=4.0.0-alpha.0" }
protobuf-parse = { path = "../protobuf-parse", version = "=4.0.0-alpha.0" }

[[bin]]

name = "protoc-gen-rust"
path = "src/bin/protoc-gen-rust.rs"
test = false

[package.metadata.docs.rs]
all-features = true

'''
'''--- protobuf-codegen/LICENSE.txt ---
Copyright (c) 2019 Stepan Koltsov

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
OR OTHER DEALINGS IN THE SOFTWARE.
'''
'''--- protobuf-codegen/README.md ---
<!-- cargo-sync-readme start -->

# Protobuf code generator for `protobuf` crate

This crate is useful mostly from `build.rs` scripts to generate `.rs` files during the build.

# How to generate code

There are three main ways to generate `.rs` files from `.proto` files:
* using `protoc` command line tool and `protoc-gen-rust` plugin
* using this crate `Codegen` with pure rust parser
* using this crate `Codegen` with `protoc` parser

Which one should you use depends on your needs.

If you are using non-cargo build system (like Bazel), you might prefer
using `protoc-gen-rust` plugin for `protoc`.

If you build with `cargo`, you probably want to use `Codegen` from this crate.

# Protoc parser vs pure rust parser

There are two protobuf parsers which can be plugged into this crate:
* `protoc`-based parser (`protoc` is a command like utility from Google protobuf)
* pure rust parser (`protobuf-parse` crate)

`protoc`-based parser is expected to parse `.proto` files very correctly:
all Google's protobuf implementations rely on it.

While there are no known bugs in `protobuf-parse`, it is not tested very well.
Also `protobuf-parse` does not implement certain rarely used features of `.proto` parser,
mostly complex message options specified in `.proto` files.
I never saw anyone using them, but you have been warned.

Note `protoc` command can be obtained from
[`protoc-bin-vendored`](https://docs.rs/protoc-bin-vendored) crate.

# Example

```rust
// Use this in build.rs
protobuf_codegen::Codegen::new()
    // Use `protoc` parser, optional.
    .protoc()
    // Use `protoc-bin-vendored` bundled protoc command, optional.
    .protoc_path(&protoc_bin_vendored::protoc_bin_path().unwrap())
    // All inputs and imports from the inputs must reside in `includes` directories.
    .includes(&["src/protos"])
    // Inputs must reside in some of include paths.
    .input("src/protos/apple.proto")
    .input("src/protos/banana.proto")
    // Specify output directory relative to Cargo output directory.
    .cargo_out_dir("protos")
    .run_from_script();
```

## How to use `protoc-gen-rust`

If you have to.

(Note `protoc` can be invoked programmatically with
[protoc crate](https://docs.rs/protoc/%3E=3.0.0-alpha))

0) Install protobuf for `protoc` binary.

On OS X [Homebrew](https://github.com/Homebrew/brew) can be used:

```sh
brew install protobuf
```

On Ubuntu, `protobuf-compiler` package can be installed:

```sh
apt-get install protobuf-compiler
```

Protobuf is needed only for code generation, `rust-protobuf` runtime
does not use C++ protobuf library.

1) Install `protoc-gen-rust` program (which is `protoc` plugin)

It can be installed either from source or with `cargo install protobuf-codegen` command.

2) Add `protoc-gen-rust` to $PATH

If you installed it with cargo, it should be

```sh
PATH="$HOME/.cargo/bin:$PATH"
```

3) Generate .rs files:

```sh
protoc --rust_out . foo.proto
```

This will generate .rs files in current directory.

# Customize generate code

Sometimes generated code need to be adjusted, e. g. to have custom derives.

rust-protobuf provides two options to do that:
* generated `.rs` files contain `@@protoc_insertion_point(...)` markers
  (similar markers inserts Google's protobuf generator for C++ or Java).
  Simple script `sed` one-liners can be used to replace these markers with custom annotations.
* `Codegen::customize_callback` can be used to patch generated code
  when invoked from `build.rs` script.

# Serde

rust-protobuf since version 3 no longer directly supports serde.

Rust-protobuf 3 fully supports:
* runtime reflection
* JSON parsing and printing via
 [`protobuf-json-mapping`](https://docs.rs/protobuf-json-mapping)

Which covers the most of serde use cases.

If you still need serde, generic customization callback (see above) can be used
to insert `#[serde(...)]` annotations.

[Example project](https://github.com/stepancheg/rust-protobuf/tree/master/protobuf-examples/customize-serde)
in the rust-protobuf repository demonstrates how to do it.

<!-- cargo-sync-readme end -->

'''
'''--- protobuf-codegen/src/bin/protoc-gen-rust.rs ---
fn main() {
    protobuf_codegen::protoc_gen_rust::protoc_gen_rust_main();
}

'''
'''--- protobuf-codegen/src/codegen/mod.rs ---
use std::env;
use std::ffi::OsString;
use std::fs;
use std::path::Component;
use std::path::Path;
use std::path::PathBuf;
use std::process;

use anyhow::Context;
use protobuf_parse::Parser;

use crate::customize::CustomizeCallback;
use crate::customize::CustomizeCallbackHolder;
use crate::gen_and_write::gen_and_write;
use crate::Customize;

#[derive(Debug)]
enum WhichParser {
    Pure,
    Protoc,
}

impl Default for WhichParser {
    fn default() -> WhichParser {
        WhichParser::Pure
    }
}

#[derive(Debug, thiserror::Error)]
enum CodegenError {
    #[error("out_dir is not specified")]
    OutDirNotSpecified,
}

/// Entry point for `.proto` to `.rs` code generation.
///
/// This is similar to `protoc --rust_out...`.
#[derive(Debug, Default)]
pub struct Codegen {
    /// What parser to use to parse `.proto` files.
    which_parser: Option<WhichParser>,
    /// Create out directory.
    create_out_dir: bool,
    /// --lang_out= param
    out_dir: Option<PathBuf>,
    /// -I args
    includes: Vec<PathBuf>,
    /// List of .proto files to compile
    inputs: Vec<PathBuf>,
    /// Customize code generation
    customize: Customize,
    /// Customize code generation
    customize_callback: CustomizeCallbackHolder,
    /// Protoc command path
    protoc: Option<PathBuf>,
    /// Extra `protoc` args
    protoc_extra_args: Vec<OsString>,
    /// Capture stderr when running `protoc`.
    capture_stderr: bool,
}

impl Codegen {
    /// Create new codegen object.
    ///
    /// Uses `protoc` from `$PATH` by default.
    ///
    /// Can be switched to pure rust parser using [`pure`](Self::pure) function.
    pub fn new() -> Self {
        Self::default()
    }

    /// Switch to pure Rust parser of `.proto` files.
    pub fn pure(&mut self) -> &mut Self {
        self.which_parser = Some(WhichParser::Pure);
        self
    }

    /// Switch to `protoc` parser of `.proto` files.
    pub fn protoc(&mut self) -> &mut Self {
        self.which_parser = Some(WhichParser::Protoc);
        self
    }

    /// Output directory for generated code.
    ///
    /// When invoking from `build.rs`, consider using
    /// [`cargo_out_dir`](Self::cargo_out_dir) instead.
    pub fn out_dir(&mut self, out_dir: impl AsRef<Path>) -> &mut Self {
        self.out_dir = Some(out_dir.as_ref().to_owned());
        self
    }

    /// Set output directory relative to Cargo output dir.
    ///
    /// With this option, output directory is erased and recreated during invocation.
    pub fn cargo_out_dir(&mut self, rel: &str) -> &mut Self {
        let rel = Path::new(rel);
        let mut not_empty = false;
        for comp in rel.components() {
            match comp {
                Component::ParentDir => {
                    panic!("parent path in components of rel path: `{}`", rel.display());
                }
                Component::CurDir => {
                    continue;
                }
                Component::Normal(..) => {}
                Component::RootDir | Component::Prefix(..) => {
                    panic!("root dir in components of rel path: `{}`", rel.display());
                }
            }
            not_empty = true;
        }

        if !not_empty {
            panic!("empty rel path: `{}`", rel.display());
        }

        let cargo_out_dir = env::var("OUT_DIR").expect("OUT_DIR env var not set");
        let mut path = PathBuf::from(cargo_out_dir);
        path.push(rel);
        self.create_out_dir = true;
        self.out_dir(path)
    }

    /// Add an include directory.
    pub fn include(&mut self, include: impl AsRef<Path>) -> &mut Self {
        self.includes.push(include.as_ref().to_owned());
        self
    }

    /// Add include directories.
    pub fn includes(&mut self, includes: impl IntoIterator<Item = impl AsRef<Path>>) -> &mut Self {
        for include in includes {
            self.include(include);
        }
        self
    }

    /// Append a `.proto` file path to compile
    pub fn input(&mut self, input: impl AsRef<Path>) -> &mut Self {
        self.inputs.push(input.as_ref().to_owned());
        self
    }

    /// Append multiple `.proto` file paths to compile
    pub fn inputs(&mut self, inputs: impl IntoIterator<Item = impl AsRef<Path>>) -> &mut Self {
        for input in inputs {
            self.input(input);
        }
        self
    }

    /// Specify `protoc` command path to be used when invoking code generation.
    ///
    /// # Examples
    ///
    /// ```no_run
    /// # mod protoc_bin_vendored {
    /// #   pub fn protoc_bin_path() -> Result<std::path::PathBuf, std::io::Error> {
    /// #       unimplemented!()
    /// #   }
    /// # }
    ///
    /// use protobuf_codegen::Codegen;
    ///
    /// Codegen::new()
    ///     .protoc()
    ///     .protoc_path(&protoc_bin_vendored::protoc_bin_path().unwrap())
    ///     // ...
    ///     .run()
    ///     .unwrap();
    /// ```
    ///
    /// This option is ignored when pure Rust parser is used.
    pub fn protoc_path(&mut self, protoc: &Path) -> &mut Self {
        self.protoc = Some(protoc.to_owned());
        self
    }

    /// Capture stderr to error when running `protoc`.
    pub fn capture_stderr(&mut self) -> &mut Self {
        self.capture_stderr = true;
        self
    }

    /// Extra command line flags for `protoc` invocation.
    ///
    /// For example, `--experimental_allow_proto3_optional` option.
    ///
    /// This option is ignored when pure Rust parser is used.
    pub fn protoc_extra_arg(&mut self, arg: impl Into<OsString>) -> &mut Self {
        self.protoc_extra_args.push(arg.into());
        self
    }

    /// Set options to customize code generation
    pub fn customize(&mut self, customize: Customize) -> &mut Self {
        self.customize.update_with(&customize);
        self
    }

    /// Callback for dynamic per-element customization.
    pub fn customize_callback(&mut self, callback: impl CustomizeCallback) -> &mut Self {
        self.customize_callback = CustomizeCallbackHolder::new(callback);
        self
    }

    /// Invoke the code generation.
    ///
    /// This is roughly equivalent to `protoc --rust_out=...` but
    /// without requiring `protoc-gen-rust` command in `$PATH`.
    ///
    /// This function uses pure Rust parser or `protoc` parser depending on
    /// how this object was configured.
    pub fn run(&self) -> anyhow::Result<()> {
        let out_dir = match &self.out_dir {
            Some(out_dir) => out_dir,
            None => return Err(CodegenError::OutDirNotSpecified.into()),
        };

        if self.create_out_dir {
            if out_dir.exists() {
                fs::remove_dir_all(&out_dir)?;
            }
            fs::create_dir(&out_dir)?;
        }

        let mut parser = Parser::new();
        parser.protoc();
        if let Some(protoc) = &self.protoc {
            parser.protoc_path(protoc);
        }
        match &self.which_parser {
            Some(WhichParser::Protoc) => {
                parser.protoc();
            }
            Some(WhichParser::Pure) => {
                parser.pure();
            }
            None => {}
        }

        parser.inputs(&self.inputs);
        parser.includes(&self.includes);
        parser.protoc_extra_args(&self.protoc_extra_args);

        if self.capture_stderr {
            parser.capture_stderr();
        }

        let parsed_and_typechecked = parser
            .parse_and_typecheck()
            .context("parse and typecheck")?;

        gen_and_write(
            &parsed_and_typechecked.file_descriptors,
            &parsed_and_typechecked.parser,
            &parsed_and_typechecked.relative_paths,
            &out_dir,
            &self.customize,
            &*self.customize_callback,
        )
    }

    /// Similar to `run`, but prints the message to stderr and exits the process on error.
    pub fn run_from_script(&self) {
        if let Err(e) = self.run() {
            eprintln!("codegen failed: {:?}", e);
            process::exit(1);
        }
    }
}

'''
'''--- protobuf-codegen/src/compiler_plugin.rs ---
use std::io::stdin;
use std::io::stdout;
use std::str;

use protobuf::descriptor::FileDescriptorProto;
use protobuf::plugin::*;
use protobuf::Message;
use protobuf_parse::ProtoPathBuf;

pub struct GenRequest<'a> {
    pub file_descriptors: &'a [FileDescriptorProto],
    pub files_to_generate: &'a [ProtoPathBuf],
    pub parameter: &'a str,
}

pub struct GenResult {
    pub name: String,
    pub content: Vec<u8>,
}

pub fn plugin_main<F>(gen: F) -> anyhow::Result<()>
where
    F: Fn(&GenRequest) -> anyhow::Result<Vec<GenResult>>,
{
    let req = CodeGeneratorRequest::parse_from_reader(&mut stdin()).unwrap();
    let result = gen(&GenRequest {
        file_descriptors: &req.proto_file,
        files_to_generate: &req
            .file_to_generate
            .iter()
            .map(|n| ProtoPathBuf::new(n.to_owned()))
            .collect::<anyhow::Result<Vec<_>>>()?,
        parameter: req.parameter(),
    })?;
    let mut resp = CodeGeneratorResponse::new();
    resp.set_supported_features(code_generator_response::Feature::FEATURE_PROTO3_OPTIONAL as u64);
    resp.file = result
        .iter()
        .map(|file| {
            let mut r = code_generator_response::File::new();
            r.set_name(file.name.to_string());
            r.set_content(str::from_utf8(file.content.as_ref()).unwrap().to_string());
            r
        })
        .collect();
    resp.write_to_writer(&mut stdout()).unwrap();
    Ok(())
}

'''
'''--- protobuf-codegen/src/customize/ctx.rs ---
use std::fmt;

use protobuf::reflect::EnumDescriptor;
use protobuf::reflect::FieldDescriptor;
use protobuf::reflect::FileDescriptor;
use protobuf::reflect::MessageDescriptor;
use protobuf::reflect::OneofDescriptor;

use crate::customize::CustomizeCallback;
use crate::Customize;

#[derive(Clone)]
pub(crate) struct CustomizeElemCtx<'a> {
    pub(crate) for_elem: Customize,
    pub(crate) for_children: Customize,
    pub(crate) callback: &'a dyn CustomizeCallback,
}

impl<'a> fmt::Debug for CustomizeElemCtx<'a> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.debug_struct("CustomizeElemCtx")
            .field("for_elem", &self.for_elem)
            .field("for_children", &self.for_children)
            .finish_non_exhaustive()
    }
}

impl<'a> CustomizeElemCtx<'a> {
    pub(crate) fn child(
        &self,
        elem_from_rustproto: &Customize,
        elem_descriptor: &impl DescriptorForCustomize,
    ) -> CustomizeElemCtx<'a> {
        let mut for_elem = self.for_children.clone();
        for_elem.update_with(elem_from_rustproto);

        let for_children = for_elem.clone();

        for_elem.update_with(&elem_descriptor.customize(self.callback));

        CustomizeElemCtx {
            for_elem,
            for_children,
            callback: self.callback,
        }
    }
}

pub(crate) trait DescriptorForCustomize {
    fn customize(&self, callback: &dyn CustomizeCallback) -> Customize;
}

impl DescriptorForCustomize for MessageDescriptor {
    fn customize(&self, callback: &dyn CustomizeCallback) -> Customize {
        callback.message(self)
    }
}

impl DescriptorForCustomize for FieldDescriptor {
    fn customize(&self, callback: &dyn CustomizeCallback) -> Customize {
        callback.field(self)
    }
}

impl DescriptorForCustomize for EnumDescriptor {
    fn customize(&self, callback: &dyn CustomizeCallback) -> Customize {
        callback.enumeration(self)
    }
}

impl DescriptorForCustomize for OneofDescriptor {
    fn customize(&self, callback: &dyn CustomizeCallback) -> Customize {
        callback.oneof(self)
    }
}

impl DescriptorForCustomize for FileDescriptor {
    fn customize(&self, callback: &dyn CustomizeCallback) -> Customize {
        callback.file(self)
    }
}

pub(crate) struct SpecialFieldPseudoDescriptor<'a> {
    pub(crate) message: &'a MessageDescriptor,
    pub(crate) field: &'a str,
}

impl<'a> DescriptorForCustomize for SpecialFieldPseudoDescriptor<'a> {
    fn customize(&self, callback: &dyn CustomizeCallback) -> Customize {
        callback.special_field(self.message, self.field)
    }
}

'''
'''--- protobuf-codegen/src/customize/mod.rs ---
pub(crate) mod ctx;
pub(crate) mod rustproto_proto;

use std::fmt;
use std::ops::Deref;
use std::rc::Rc;

use protobuf::reflect::EnumDescriptor;
use protobuf::reflect::FieldDescriptor;
use protobuf::reflect::FileDescriptor;
use protobuf::reflect::MessageDescriptor;
use protobuf::reflect::OneofDescriptor;

/// Dynamic callback to customize code generation.
pub trait CustomizeCallback: 'static {
    fn file(&self, file: &FileDescriptor) -> Customize {
        let _ = file;
        Customize::default()
    }

    fn message(&self, message: &MessageDescriptor) -> Customize {
        let _ = message;
        Customize::default()
    }

    fn field(&self, field: &FieldDescriptor) -> Customize {
        let _ = field;
        Customize::default()
    }

    fn special_field(&self, message: &MessageDescriptor, field: &str) -> Customize {
        let _ = (message, field);
        Customize::default()
    }

    fn enumeration(&self, enum_type: &EnumDescriptor) -> Customize {
        let _ = enum_type;
        Customize::default()
    }

    fn oneof(&self, oneof: &OneofDescriptor) -> Customize {
        let _ = oneof;
        Customize::default()
    }
}

pub(crate) struct CustomizeCallbackDefault;
impl CustomizeCallback for CustomizeCallbackDefault {}

#[derive(Clone)]
pub(crate) struct CustomizeCallbackHolder(pub(crate) Rc<dyn CustomizeCallback>);

impl CustomizeCallbackHolder {
    pub(crate) fn new(callback: impl CustomizeCallback) -> CustomizeCallbackHolder {
        CustomizeCallbackHolder(Rc::new(callback))
    }
}

impl Deref for CustomizeCallbackHolder {
    type Target = dyn CustomizeCallback;

    fn deref(&self) -> &Self::Target {
        &*self.0
    }
}

impl Default for CustomizeCallbackHolder {
    fn default() -> Self {
        CustomizeCallbackHolder(Rc::new(CustomizeCallbackDefault))
    }
}

impl PartialEq for CustomizeCallbackHolder {
    fn eq(&self, other: &Self) -> bool {
        Rc::ptr_eq(&self.0, &other.0)
    }
}

impl fmt::Debug for CustomizeCallbackHolder {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.debug_struct("CustomizeCallbackWrapper")
            .finish_non_exhaustive()
    }
}

/// Specifies style of generated code.
/// Generated files can be customized using this proto
/// or using `rustproto.proto` options.
#[derive(Default, Debug, Clone, PartialEq)]
pub struct Customize {
    /// Code to insert before the element in the generated file.
    pub(crate) before: Option<String>,
    /// When false, `get_`, `set_`, `mut_` etc. accessors are not generated
    pub(crate) generate_accessors: Option<bool>,
    /// When false, `get_` is not generated even if `syntax = "proto2"`
    pub(crate) generate_getter: Option<bool>,
    /// Use `bytes::Bytes` for `bytes` fields
    pub(crate) tokio_bytes: Option<bool>,
    /// Use `bytes::Bytes` for `string` fields
    pub(crate) tokio_bytes_for_string: Option<bool>,
    /// Enable lite runtime.
    pub(crate) lite_runtime: Option<bool>,
    /// Generate `mod.rs` in the output directory.
    ///
    /// This option allows inclusion of generated files from cargo output directory.
    ///
    /// This option will likely be on by default in rust-protobuf version 3.
    pub(crate) gen_mod_rs: Option<bool>,
    /// Used internally to generate protos bundled in protobuf crate
    /// like `descriptor.proto`
    pub(crate) inside_protobuf: Option<bool>,
}

#[derive(Debug, thiserror::Error)]
pub(crate) enum CustomizeParseParameterError {
    #[error("Cannot parse bool option value: {:?}", .0)]
    CannotParseBool(String),
    #[error("Unknown option name: {:?}", .0)]
    UnknownOptionName(String),
}

impl Customize {
    /// Insert code before the element in the generated file
    /// (e. g. serde annotations, see
    /// [example here](https://github.com/stepancheg/rust-protobuf/tree/master/protobuf-examples/customize-serde)).
    pub fn before(mut self, before: &str) -> Self {
        self.before = Some(before.to_owned());
        self
    }

    pub fn generate_accessors(mut self, generate_accessors: bool) -> Self {
        self.generate_accessors = Some(generate_accessors);
        self
    }

    pub fn generate_getter(mut self, generate_getter: bool) -> Self {
        self.generate_getter = Some(generate_getter);
        self
    }

    pub fn tokio_bytes(mut self, tokio_bytes: bool) -> Self {
        self.tokio_bytes = Some(tokio_bytes);
        self
    }

    pub fn tokio_bytes_for_string(mut self, tokio_bytes_for_string: bool) -> Self {
        self.tokio_bytes_for_string = Some(tokio_bytes_for_string);
        self
    }

    /// Generate code for "lite runtime". Generated code contains no code for reflection.
    /// So the generated code (and more importantly, generated binary size) is smaller,
    /// but reflection, text format, JSON serialization won't work.
    ///
    /// Note when using `protoc` plugin `protoc-gen-rust`, the option name is just `lite`.
    pub fn lite_runtime(mut self, lite_runtime: bool) -> Self {
        self.lite_runtime = Some(lite_runtime);
        self
    }

    /// Generate `mod.rs` with all the generated modules.
    /// This option is on by default in rust-protobuf version 3.
    pub fn gen_mod_rs(mut self, gen_mod_rs: bool) -> Self {
        self.gen_mod_rs = Some(gen_mod_rs);
        self
    }

    /// Generate code bundled in protobuf crate. Regular users don't need this option.
    pub fn inside_protobuf(mut self, inside_protobuf: bool) -> Self {
        self.inside_protobuf = Some(inside_protobuf);
        self
    }

    /// Update fields of self with fields defined in other customize
    pub fn update_with(&mut self, that: &Customize) {
        if let Some(v) = &that.before {
            self.before = Some(v.clone());
        }
        if let Some(v) = that.generate_accessors {
            self.generate_accessors = Some(v);
        }
        if let Some(v) = that.generate_getter {
            self.generate_getter = Some(v);
        }
        if let Some(v) = that.tokio_bytes {
            self.tokio_bytes = Some(v);
        }
        if let Some(v) = that.tokio_bytes_for_string {
            self.tokio_bytes_for_string = Some(v);
        }
        if let Some(v) = that.lite_runtime {
            self.lite_runtime = Some(v);
        }
        if let Some(v) = that.gen_mod_rs {
            self.gen_mod_rs = Some(v);
        }
        if let Some(v) = that.inside_protobuf {
            self.inside_protobuf = Some(v);
        }
    }

    /// Update unset fields of self with fields from other customize
    pub fn set_defaults_from(&mut self, other: &Customize) {
        let mut tmp = other.clone();
        tmp.update_with(self);
        *self = tmp;
    }

    /// Parse customize options from a string passed via protoc flag.
    pub fn parse_from_parameter(parameter: &str) -> anyhow::Result<Customize> {
        fn parse_bool(v: &str) -> anyhow::Result<bool> {
            v.parse()
                .map_err(|_| CustomizeParseParameterError::CannotParseBool(v.to_owned()).into())
        }

        let mut r = Customize::default();
        for nv in parameter.split_whitespace() {
            let (n, v) = match nv.find('=') {
                Some(eq) => {
                    let n = &nv[..eq];
                    let v = &nv[eq + 1..];
                    (n, v)
                }
                None => (nv, "true"),
            };

            if n == "generate_accessors" {
                r.generate_accessors = Some(parse_bool(v)?);
            } else if n == "generate_getter" {
                r.generate_getter = Some(parse_bool(v)?);
            } else if n == "tokio_bytes" {
                r.tokio_bytes = Some(parse_bool(v)?);
            } else if n == "tokio_bytes_for_string" {
                r.tokio_bytes_for_string = Some(parse_bool(v)?);
            } else if n == "lite_runtime" {
                r.lite_runtime = Some(parse_bool(v)?);
            } else if n == "gen_mod_rs" {
                r.gen_mod_rs = Some(parse_bool(v)?);
            } else if n == "inside_protobuf" {
                r.inside_protobuf = Some(parse_bool(v)?);
            } else if n == "lite" {
                // Support Java and C++ protoc plugin syntax:
                // https://github.com/protocolbuffers/protobuf/issues/6489
                r.lite_runtime = Some(parse_bool(v)?);
            } else {
                return Err(CustomizeParseParameterError::UnknownOptionName(n.to_owned()).into());
            }
        }
        Ok(r)
    }
}

'''
'''--- protobuf-codegen/src/customize/rustproto_proto.rs ---
use protobuf::descriptor::EnumOptions;
use protobuf::descriptor::FieldOptions;
use protobuf::descriptor::FileOptions;
use protobuf::descriptor::MessageOptions;
use protobuf::rustproto;

use crate::Customize;

pub(crate) fn customize_from_rustproto_for_message(source: &MessageOptions) -> Customize {
    let before = None;
    let generate_accessors = rustproto::exts::generate_accessors.get(source);
    let generate_getter = rustproto::exts::generate_getter.get(source);
    let tokio_bytes = rustproto::exts::tokio_bytes.get(source);
    let tokio_bytes_for_string = rustproto::exts::tokio_bytes_for_string.get(source);
    let lite_runtime = None;
    let gen_mod_rs = None;
    let inside_protobuf = None;
    Customize {
        before,
        generate_accessors,
        generate_getter,
        tokio_bytes,
        tokio_bytes_for_string,
        lite_runtime,
        gen_mod_rs,
        inside_protobuf,
    }
}

pub(crate) fn customize_from_rustproto_for_enum(_source: &EnumOptions) -> Customize {
    Customize::default()
}

pub(crate) fn customize_from_rustproto_for_field(source: &FieldOptions) -> Customize {
    let before = None;
    let generate_accessors = rustproto::exts::generate_accessors_field.get(source);
    let generate_getter = rustproto::exts::generate_getter_field.get(source);
    let tokio_bytes = rustproto::exts::tokio_bytes_field.get(source);
    let tokio_bytes_for_string = rustproto::exts::tokio_bytes_for_string_field.get(source);
    let lite_runtime = None;
    let gen_mod_rs = None;
    let inside_protobuf = None;
    Customize {
        before,
        generate_accessors,
        generate_getter,
        tokio_bytes,
        tokio_bytes_for_string,
        lite_runtime,
        gen_mod_rs,
        inside_protobuf,
    }
}

pub(crate) fn customize_from_rustproto_for_file(source: &FileOptions) -> Customize {
    let before = None;
    let generate_accessors = rustproto::exts::generate_accessors_all.get(source);
    let generate_getter = rustproto::exts::generate_getter_all.get(source);
    let tokio_bytes = rustproto::exts::tokio_bytes_all.get(source);
    let tokio_bytes_for_string = rustproto::exts::tokio_bytes_for_string_all.get(source);
    let lite_runtime = rustproto::exts::lite_runtime_all.get(source);
    let gen_mod_rs = None;
    let inside_protobuf = None;
    Customize {
        before,
        generate_accessors,
        generate_getter,
        tokio_bytes,
        tokio_bytes_for_string,
        lite_runtime,
        inside_protobuf,
        gen_mod_rs,
    }
}

'''
'''--- protobuf-codegen/src/gen/all.rs ---
use std::collections::HashMap;

use protobuf::descriptor::FileDescriptorProto;
use protobuf::reflect::FileDescriptor;
use protobuf_parse::ProtoPath;
use protobuf_parse::ProtoPathBuf;

use crate::compiler_plugin;
use crate::customize::ctx::CustomizeElemCtx;
use crate::customize::CustomizeCallback;
use crate::gen::file::gen_file;
use crate::gen::mod_rs::gen_mod_rs;
use crate::gen::scope::RootScope;
use crate::gen::well_known_types::gen_well_known_types_mod;
use crate::Customize;

pub(crate) fn gen_all(
    file_descriptors: &[FileDescriptorProto],
    parser: &str,
    files_to_generate: &[ProtoPathBuf],
    customize: &Customize,
    customize_callback: &dyn CustomizeCallback,
) -> anyhow::Result<Vec<compiler_plugin::GenResult>> {
    let file_descriptors = FileDescriptor::new_dynamic_fds(file_descriptors.to_vec(), &[])?;

    let root_scope = RootScope {
        file_descriptors: &file_descriptors,
    };

    let mut results: Vec<compiler_plugin::GenResult> = Vec::new();
    let files_map: HashMap<&ProtoPath, &FileDescriptor> = file_descriptors
        .iter()
        .map(|f| Ok((ProtoPath::new(f.proto().name())?, f)))
        .collect::<Result<_, anyhow::Error>>()?;

    let mut mods = Vec::new();

    let customize = CustomizeElemCtx {
        for_elem: customize.clone(),
        for_children: customize.clone(),
        callback: customize_callback,
    };

    for file_name in files_to_generate {
        let file = files_map.get(file_name.as_path()).expect(&format!(
            "file not found in file descriptors: {:?}, files: {:?}",
            file_name,
            files_map.keys()
        ));
        let gen_file_result = gen_file(file, &files_map, &root_scope, &customize, parser)?;
        results.push(gen_file_result.compiler_plugin_result);
        mods.push(gen_file_result.mod_name);
    }

    if customize.for_elem.inside_protobuf.unwrap_or(false) {
        results.push(gen_well_known_types_mod());
    }

    if customize.for_elem.gen_mod_rs.unwrap_or(true) {
        results.push(gen_mod_rs(&mods));
    }

    Ok(results)
}

'''
'''--- protobuf-codegen/src/gen/code_writer.rs ---
use std::convert::Infallible;

use crate::gen::rust::rel_path::RustRelativePath;

/// Field visibility.
pub(crate) enum Visibility {
    Public,
    Default,
    Path(RustRelativePath),
}

pub(crate) struct CodeWriter<'a> {
    writer: &'a mut String,
    indent: String,
}

impl<'a> CodeWriter<'a> {
    pub(crate) fn new(writer: &'a mut String) -> CodeWriter<'a> {
        CodeWriter {
            writer,
            indent: "".to_string(),
        }
    }

    pub(crate) fn with_no_error(f: impl FnOnce(&mut CodeWriter)) -> String {
        Self::with_impl::<Infallible, _>(|w| Ok(f(w))).unwrap_or_else(|e| match e {})
    }

    pub(crate) fn with<F>(f: F) -> anyhow::Result<String>
    where
        F: FnOnce(&mut CodeWriter) -> anyhow::Result<()>,
    {
        Self::with_impl(f)
    }

    fn with_impl<E, F>(f: F) -> Result<String, E>
    where
        F: FnOnce(&mut CodeWriter) -> Result<(), E>,
    {
        let mut writer = String::new();
        {
            let mut cw = CodeWriter::new(&mut writer);
            f(&mut cw)?;
        }
        Ok(writer)
    }

    pub(crate) fn write_line<S: AsRef<str>>(&mut self, line: S) {
        if line.as_ref().is_empty() {
            self.writer.push_str("\n");
        } else {
            let s: String = [self.indent.as_ref(), line.as_ref(), "\n"].concat();
            self.writer.push_str(&s);
        }
    }

    pub(crate) fn _write_text(&mut self, text: &str) {
        for line in text.lines() {
            self.write_line(line);
        }
    }

    pub(crate) fn write_generated_by(&mut self, pkg: &str, version: &str, parser: &str) {
        self.write_line(format!(
            "// This file is generated by {pkg} {version}. Do not edit",
            pkg = pkg,
            version = version
        ));
        self.write_line(format!(
            "// .proto file is parsed by {parser}",
            parser = parser
        ));
        self.write_generated_common();
    }

    fn write_generated_common(&mut self) {
        // https://secure.phabricator.com/T784
        self.write_line(&format!("// {}generated", "@"));

        self.write_line("");
        self.comment("https://github.com/rust-lang/rust-clippy/issues/702");
        self.write_line("#![allow(unknown_lints)]");
        self.write_line("#![allow(clippy::all)]");
        self.write_line("");
        self.write_line("#![allow(unused_attributes)]");
        self.write_line("#![cfg_attr(rustfmt, rustfmt::skip)]");
        self.write_line("");
        self.write_line("#![allow(box_pointers)]");
        self.write_line("#![allow(dead_code)]");
        self.write_line("#![allow(missing_docs)]");
        self.write_line("#![allow(non_camel_case_types)]");
        self.write_line("#![allow(non_snake_case)]");
        self.write_line("#![allow(non_upper_case_globals)]");
        self.write_line("#![allow(trivial_casts)]");
        self.write_line("#![allow(unused_results)]");
        self.write_line("#![allow(unused_mut)]");
    }

    pub(crate) fn unimplemented(&mut self) {
        self.write_line(format!("unimplemented!();"));
    }

    pub(crate) fn indented<F>(&mut self, cb: F)
    where
        F: FnOnce(&mut CodeWriter),
    {
        cb(&mut CodeWriter {
            writer: self.writer,
            indent: format!("{}    ", self.indent),
        });
    }

    #[allow(dead_code)]
    pub(crate) fn commented<F>(&mut self, cb: F)
    where
        F: Fn(&mut CodeWriter),
    {
        cb(&mut CodeWriter {
            writer: self.writer,
            indent: format!("// {}", self.indent),
        });
    }

    pub(crate) fn pub_const(&mut self, name: &str, field_type: &str, init: &str) {
        self.write_line(&format!("pub const {}: {} = {};", name, field_type, init));
    }

    pub(crate) fn lazy_static(&mut self, name: &str, ty: &str, protobuf_crate_path: &str) {
        self.write_line(&format!(
            "static {}: {}::rt::Lazy<{}> = {}::rt::Lazy::new();",
            name, protobuf_crate_path, ty, protobuf_crate_path,
        ));
    }

    pub(crate) fn lazy_static_decl_get_simple(
        &mut self,
        name: &str,
        ty: &str,
        init: &str,
        protobuf_crate_path: &str,
    ) {
        self.lazy_static(name, ty, protobuf_crate_path);
        self.write_line(&format!("{}.get({})", name, init));
    }

    pub(crate) fn lazy_static_decl_get(
        &mut self,
        name: &str,
        ty: &str,
        protobuf_crate_path: &str,
        init: impl FnOnce(&mut CodeWriter),
    ) {
        self.lazy_static(name, ty, protobuf_crate_path);
        self.block(&format!("{}.get(|| {{", name), "})", init);
    }

    pub(crate) fn block<F>(&mut self, first_line: &str, last_line: &str, cb: F)
    where
        F: FnOnce(&mut CodeWriter),
    {
        self.write_line(first_line);
        self.indented(cb);
        self.write_line(last_line);
    }

    pub(crate) fn expr_block<F>(&mut self, prefix: &str, cb: F)
    where
        F: FnOnce(&mut CodeWriter),
    {
        self.block(&format!("{} {{", prefix), "}", cb);
    }

    pub(crate) fn stmt_block<S: AsRef<str>, F>(&mut self, prefix: S, cb: F)
    where
        F: FnOnce(&mut CodeWriter),
    {
        self.block(&format!("{} {{", prefix.as_ref()), "};", cb);
    }

    pub(crate) fn impl_self_block<S: AsRef<str>, F>(&mut self, name: S, cb: F)
    where
        F: Fn(&mut CodeWriter),
    {
        self.expr_block(&format!("impl {}", name.as_ref()), cb);
    }

    pub(crate) fn impl_for_block<S1: AsRef<str>, S2: AsRef<str>, F>(
        &mut self,
        tr: S1,
        ty: S2,
        cb: F,
    ) where
        F: Fn(&mut CodeWriter),
    {
        self.impl_args_for_block(&[], tr.as_ref(), ty.as_ref(), cb);
    }

    pub(crate) fn impl_args_for_block<F>(&mut self, args: &[&str], tr: &str, ty: &str, cb: F)
    where
        F: Fn(&mut CodeWriter),
    {
        let args_str = if args.is_empty() {
            "".to_owned()
        } else {
            format!("<{}>", args.join(", "))
        };
        self.expr_block(&format!("impl{} {} for {}", args_str, tr, ty), cb);
    }

    pub(crate) fn pub_struct<S: AsRef<str>, F>(&mut self, name: S, cb: F)
    where
        F: Fn(&mut CodeWriter),
    {
        self.expr_block(&format!("pub struct {}", name.as_ref()), cb);
    }

    pub(crate) fn pub_enum<F>(&mut self, name: &str, cb: F)
    where
        F: Fn(&mut CodeWriter),
    {
        self.expr_block(&format!("pub enum {}", name), cb);
    }

    pub(crate) fn field_entry(&mut self, name: &str, value: &str) {
        self.write_line(&format!("{}: {},", name, value));
    }

    pub(crate) fn field_decl(&mut self, name: &str, field_type: &str) {
        self.write_line(&format!("{}: {},", name, field_type));
    }

    pub(crate) fn pub_field_decl(&mut self, name: &str, field_type: &str) {
        self.write_line(&format!("pub {}: {},", name, field_type));
    }

    pub(crate) fn field_decl_vis(&mut self, vis: Visibility, name: &str, field_type: &str) {
        match vis {
            Visibility::Public => self.pub_field_decl(name, field_type),
            Visibility::Default => self.field_decl(name, field_type),
            Visibility::Path(..) => unimplemented!(),
        }
    }

    pub(crate) fn derive(&mut self, derive: &[&str]) {
        let v: Vec<String> = derive.iter().map(|&s| s.to_string()).collect();
        self.write_line(&format!("#[derive({})]", v.join(",")));
    }

    pub(crate) fn allow(&mut self, what: &[&str]) {
        let v: Vec<String> = what.iter().map(|&s| s.to_string()).collect();
        self.write_line(&format!("#[allow({})]", v.join(",")));
    }

    pub(crate) fn comment(&mut self, comment: &str) {
        if comment.is_empty() {
            self.write_line("//");
        } else {
            self.write_line(&format!("// {}", comment));
        }
    }

    fn documentation(&mut self, comment: &str) {
        if comment.is_empty() {
            self.write_line("///");
        } else {
            self.write_line(&format!("/// {}", comment));
        }
    }

    pub(crate) fn mod_doc(&mut self, comment: &str) {
        if comment.is_empty() {
            self.write_line("//!");
        } else {
            self.write_line(&format!("//! {}", comment));
        }
    }

    /// Writes the documentation of the given path.
    ///
    /// Protobuf paths are defined in proto/google/protobuf/descriptor.proto,
    /// in the `SourceCodeInfo` message.
    ///
    /// For example, say we have a file like:
    ///
    /// ```ignore
    /// message Foo {
    ///   optional string foo = 1;
    /// }
    /// ```
    ///
    /// Let's look at just the field definition. We have the following paths:
    ///
    /// ```ignore
    /// path               represents
    /// [ 4, 0, 2, 0 ]     The whole field definition.
    /// [ 4, 0, 2, 0, 4 ]  The label (optional).
    /// [ 4, 0, 2, 0, 5 ]  The type (string).
    /// [ 4, 0, 2, 0, 1 ]  The name (foo).
    /// [ 4, 0, 2, 0, 3 ]  The number (1).
    /// ```
    ///
    /// The `4`s can be obtained using simple introspection:
    ///
    /// ```
    /// use protobuf::descriptor::FileDescriptorProto;
    /// use protobuf::reflect::MessageDescriptor;
    ///
    /// let id = MessageDescriptor::for_type::<FileDescriptorProto>()
    ///     .field_by_name("message_type")
    ///     .expect("`message_type` must exist")
    ///     .proto()
    ///     .number();
    ///
    /// assert_eq!(id, 4);
    /// ```
    ///
    /// The first `0` here means this path refers to the first message.
    ///
    /// The `2` then refers to the `field` field on the `DescriptorProto` message.
    ///
    /// Then comes another `0` to refer to the first field of the current message.
    ///
    /// Etc.

    pub(crate) fn all_documentation(
        &mut self,
        info: Option<&protobuf::descriptor::SourceCodeInfo>,
        path: &[i32],
    ) {
        let doc = info
            .map(|v| &v.location)
            .and_then(|ls| ls.iter().find(|l| l.path == path))
            .map(|l| l.leading_comments());

        let lines = doc
            .iter()
            .map(|doc| doc.lines())
            .flatten()
            .collect::<Vec<_>>();

        // Skip comments with code blocks to avoid rustdoc trying to compile them.
        if !lines.iter().any(|line| line.starts_with("    ")) {
            for doc in &lines {
                self.documentation(doc);
            }
        }
    }

    pub(crate) fn fn_block<F>(&mut self, vis: Visibility, sig: &str, cb: F)
    where
        F: FnOnce(&mut CodeWriter),
    {
        match vis {
            Visibility::Public => self.expr_block(&format!("pub fn {}", sig), cb),
            Visibility::Default => self.expr_block(&format!("fn {}", sig), cb),
            Visibility::Path(p) if p.is_empty() => self.expr_block(&format!("fn {}", sig), cb),
            Visibility::Path(p) => self.expr_block(&format!("pub(in {}) fn {}", p, sig), cb),
        }
    }

    pub(crate) fn pub_fn<F>(&mut self, sig: &str, cb: F)
    where
        F: FnOnce(&mut CodeWriter),
    {
        self.fn_block(Visibility::Public, sig, cb);
    }

    pub(crate) fn def_fn<F>(&mut self, sig: &str, cb: F)
    where
        F: Fn(&mut CodeWriter),
    {
        self.fn_block(Visibility::Default, sig, cb);
    }

    pub(crate) fn pub_mod<F>(&mut self, name: &str, cb: F)
    where
        F: Fn(&mut CodeWriter),
    {
        self.expr_block(&format!("pub mod {}", name), cb)
    }

    pub(crate) fn while_block<S: AsRef<str>, F>(&mut self, cond: S, cb: F)
    where
        F: Fn(&mut CodeWriter),
    {
        self.expr_block(&format!("while {}", cond.as_ref()), cb);
    }

    // if ... { ... }
    pub(crate) fn if_stmt<S: AsRef<str>, F>(&mut self, cond: S, cb: F)
    where
        F: FnOnce(&mut CodeWriter),
    {
        self.expr_block(&format!("if {}", cond.as_ref()), cb);
    }

    // if ... {} else { ... }
    pub(crate) fn if_else_stmt<S: AsRef<str>, F>(&mut self, cond: S, cb: F)
    where
        F: Fn(&mut CodeWriter),
    {
        self.write_line(&format!("if {} {{", cond.as_ref()));
        self.write_line("} else {");
        self.indented(cb);
        self.write_line("}");
    }

    // if let ... = ... { ... }
    pub(crate) fn if_let_stmt<F>(&mut self, decl: &str, expr: &str, cb: F)
    where
        F: FnOnce(&mut CodeWriter),
    {
        self.if_stmt(&format!("let {} = {}", decl, expr), cb);
    }

    // if let ... = ... { } else { ... }
    pub(crate) fn if_let_else_stmt<F>(&mut self, decl: &str, expr: &str, cb: F)
    where
        F: Fn(&mut CodeWriter),
    {
        self.if_else_stmt(&format!("let {} = {}", decl, expr), cb);
    }

    pub(crate) fn for_stmt<S1: AsRef<str>, S2: AsRef<str>, F>(&mut self, over: S1, varn: S2, cb: F)
    where
        F: FnOnce(&mut CodeWriter),
    {
        self.stmt_block(&format!("for {} in {}", varn.as_ref(), over.as_ref()), cb)
    }

    pub(crate) fn match_block<S: AsRef<str>, F>(&mut self, value: S, cb: F)
    where
        F: FnOnce(&mut CodeWriter),
    {
        self.stmt_block(&format!("match {}", value.as_ref()), cb);
    }

    pub(crate) fn match_expr<S: AsRef<str>, F>(&mut self, value: S, cb: F)
    where
        F: Fn(&mut CodeWriter),
    {
        self.expr_block(&format!("match {}", value.as_ref()), cb);
    }

    pub(crate) fn case_block<S: AsRef<str>, F>(&mut self, cond: S, cb: F)
    where
        F: Fn(&mut CodeWriter),
    {
        self.block(&format!("{} => {{", cond.as_ref()), "},", cb);
    }

    pub(crate) fn case_expr<S1: AsRef<str>, S2: AsRef<str>>(&mut self, cond: S1, body: S2) {
        self.write_line(&format!("{} => {},", cond.as_ref(), body.as_ref()));
    }
}

'''
'''--- protobuf-codegen/src/gen/descriptor.rs ---
use protobuf::reflect::EnumDescriptor;
use protobuf::reflect::MessageDescriptor;

use crate::gen::code_writer::CodeWriter;
use crate::gen::file_descriptor::file_descriptor_call_expr;
use crate::gen::inside::protobuf_crate_path;
use crate::gen::scope::Scope;
use crate::Customize;

/// Abstract message or enum descriptor.
pub(crate) trait Descriptor {
    const DESCRIPTOR_FN: &'static str;
    const TYPE_NAME: &'static str;
    const GET_BY_RELATIVE_NAME_NAME: &'static str;
    fn name_to_package(&self) -> &str;
}

impl Descriptor for MessageDescriptor {
    const DESCRIPTOR_FN: &'static str = "descriptor";
    const TYPE_NAME: &'static str = "MessageDescriptor";
    const GET_BY_RELATIVE_NAME_NAME: &'static str = "message_by_package_relative_name";

    fn name_to_package(&self) -> &str {
        self.name_to_package()
    }
}

impl Descriptor for EnumDescriptor {
    const DESCRIPTOR_FN: &'static str = "enum_descriptor";
    const TYPE_NAME: &'static str = "EnumDescriptor";
    const GET_BY_RELATIVE_NAME_NAME: &'static str = "enum_by_package_relative_name";

    fn name_to_package(&self) -> &str {
        self.name_to_package()
    }
}

pub(crate) fn write_fn_descriptor<D: Descriptor>(
    descriptor: &D,
    scope: &Scope,
    customize: &Customize,
    w: &mut CodeWriter,
) {
    let sig = format!(
        "{}() -> {}::reflect::{}",
        D::DESCRIPTOR_FN,
        protobuf_crate_path(customize),
        D::TYPE_NAME,
    );
    w.def_fn(&sig, |w| {
        let expr = format!(
            "{}.{}(\"{}\").unwrap()",
            file_descriptor_call_expr(scope),
            D::GET_BY_RELATIVE_NAME_NAME,
            descriptor.name_to_package()
        );
        w.lazy_static(
            "descriptor",
            &format!(
                "{}::reflect::{}",
                protobuf_crate_path(customize),
                D::TYPE_NAME,
            ),
            &protobuf_crate_path(customize).to_string(),
        );
        w.write_line(&format!("descriptor.get(|| {}).clone()", expr));
    });
}

'''
'''--- protobuf-codegen/src/gen/enums.rs ---
use std::collections::HashSet;

use protobuf::descriptor::*;

use crate::customize::ctx::CustomizeElemCtx;
use crate::customize::rustproto_proto::customize_from_rustproto_for_enum;
use crate::gen::code_writer::CodeWriter;
use crate::gen::code_writer::Visibility;
use crate::gen::descriptor::write_fn_descriptor;
use crate::gen::inside::protobuf_crate_path;
use crate::gen::protoc_insertion_point::write_protoc_insertion_point_for_enum;
use crate::gen::protoc_insertion_point::write_protoc_insertion_point_for_enum_value;
use crate::gen::rust::ident::RustIdent;
use crate::gen::rust::ident_with_path::RustIdentWithPath;
use crate::gen::rust::snippets::EXPR_NONE;
use crate::gen::scope::EnumValueWithContext;
use crate::gen::scope::EnumWithScope;
use crate::gen::scope::RootScope;
use crate::gen::scope::WithScope;

#[derive(Clone)]
pub(crate) struct EnumValueGen<'a> {
    value: EnumValueWithContext<'a>,
    enum_rust_name: RustIdentWithPath,
}

impl<'a> EnumValueGen<'a> {
    fn parse(
        value: EnumValueWithContext<'a>,
        enum_rust_name: &RustIdentWithPath,
    ) -> EnumValueGen<'a> {
        EnumValueGen {
            value: value.clone(),
            enum_rust_name: enum_rust_name.clone(),
        }
    }

    // enum value
    fn number(&self) -> i32 {
        self.value.proto.proto().number()
    }

    // name of enum variant in generated rust code
    pub fn rust_name_inner(&self) -> RustIdent {
        self.value.rust_name()
    }

    pub fn rust_name_outer(&self) -> RustIdentWithPath {
        self.enum_rust_name
            .to_path()
            .with_ident(self.rust_name_inner())
    }
}

// Codegen for enum definition
pub(crate) struct EnumGen<'a> {
    enum_with_scope: &'a EnumWithScope<'a>,
    type_name: RustIdentWithPath,
    lite_runtime: bool,
    customize: CustomizeElemCtx<'a>,
    path: &'a [i32],
    info: Option<&'a SourceCodeInfo>,
}

impl<'a> EnumGen<'a> {
    pub fn new(
        enum_with_scope: &'a EnumWithScope<'a>,
        customize: &CustomizeElemCtx<'a>,
        _root_scope: &RootScope,
        path: &'a [i32],
        info: Option<&'a SourceCodeInfo>,
    ) -> EnumGen<'a> {
        let customize = customize.child(
            &customize_from_rustproto_for_enum(enum_with_scope.en.proto().options.get_or_default()),
            &enum_with_scope.en,
        );
        let lite_runtime = customize.for_elem.lite_runtime.unwrap_or_else(|| {
            enum_with_scope
                .file_descriptor()
                .proto()
                .options
                .optimize_for()
                == file_options::OptimizeMode::LITE_RUNTIME
        });

        EnumGen {
            enum_with_scope,
            type_name: enum_with_scope.rust_name().to_path(),
            lite_runtime,
            customize,
            path,
            info,
        }
    }

    fn allow_alias(&self) -> bool {
        self.enum_with_scope
            .en
            .proto()
            .options
            .get_or_default()
            .allow_alias()
    }

    fn values_all(&self) -> Vec<EnumValueGen> {
        let mut r = Vec::new();
        for p in self.enum_with_scope.values() {
            r.push(EnumValueGen::parse(p, &self.type_name));
        }
        r
    }

    fn values_unique(&self) -> Vec<EnumValueGen> {
        let mut used = HashSet::new();
        let mut r = Vec::new();
        for p in self.enum_with_scope.values() {
            if !used.insert(p.proto.proto().number()) {
                continue;
            }
            r.push(EnumValueGen::parse(p, &self.type_name));
        }
        r
    }

    pub fn write(&self, w: &mut CodeWriter) {
        self.write_enum(w);
        if self.allow_alias() {
            w.write_line("");
            self.write_impl_eq(w);
            w.write_line("");
            self.write_impl_hash(w);
        }
        w.write_line("");
        self.write_impl_enum(w);
        if !self.lite_runtime {
            w.write_line("");
            self.write_impl_enum_full(w);
        }
        w.write_line("");
        self.write_impl_default(w);
        w.write_line("");
        self.write_impl_self(w);
    }

    fn write_impl_self(&self, w: &mut CodeWriter) {
        if !self.lite_runtime {
            w.impl_self_block(&format!("{}", self.type_name), |w| {
                self.write_generated_enum_descriptor_data(w);
            });
        }
    }

    fn write_enum(&self, w: &mut CodeWriter) {
        w.all_documentation(self.info, self.path);

        let mut derive = Vec::new();
        derive.push("Clone");
        derive.push("Copy");
        if !self.allow_alias() {
            derive.push("PartialEq");
        }
        derive.push("Eq");
        derive.push("Debug");
        if !self.allow_alias() {
            derive.push("Hash");
        } else {
            w.comment("Note: you cannot use pattern matching for enums with allow_alias option");
        }
        w.derive(&derive);
        let ref type_name = self.type_name;
        write_protoc_insertion_point_for_enum(
            w,
            &self.customize.for_elem,
            &self.enum_with_scope.en,
        );
        w.expr_block(&format!("pub enum {}", type_name), |w| {
            for value in self.values_all() {
                write_protoc_insertion_point_for_enum_value(
                    w,
                    &self.customize.for_children,
                    &value.value.proto,
                );
                if self.allow_alias() {
                    w.write_line(&format!(
                        "{}, // {}",
                        value.rust_name_inner(),
                        value.number()
                    ));
                } else {
                    w.write_line(&format!(
                        "{} = {},",
                        value.rust_name_inner(),
                        value.number()
                    ));
                }
            }
        });
    }

    fn write_impl_enum_fn_value(&self, w: &mut CodeWriter) {
        w.def_fn("value(&self) -> i32", |w| {
            if self.allow_alias() {
                w.match_expr("*self", |w| {
                    for value in self.values_all() {
                        w.case_expr(
                            &format!("{}", value.rust_name_outer()),
                            &format!("{}", value.number()),
                        );
                    }
                });
            } else {
                w.write_line("*self as i32")
            }
        });
    }

    fn write_impl_enum_const_name(&self, w: &mut CodeWriter) {
        w.write_line(&format!(
            "const NAME: &'static str = \"{}\";",
            self.enum_with_scope.en.name()
        ));
    }

    fn write_impl_enum_fn_from_i32(&self, w: &mut CodeWriter) {
        w.def_fn(
            &format!(
                "from_i32(value: i32) -> ::std::option::Option<{}>",
                self.type_name
            ),
            |w| {
                w.match_expr("value", |w| {
                    let values = self.values_unique();
                    for value in values {
                        w.write_line(&format!(
                            "{} => ::std::option::Option::Some({}),",
                            value.number(),
                            value.rust_name_outer()
                        ));
                    }
                    w.write_line(&format!("_ => {}", EXPR_NONE));
                });
            },
        );
    }

    fn write_impl_enum_fn_from_str(&self, w: &mut CodeWriter) {
        w.def_fn(
            &format!(
                "from_str(str: &str) -> ::std::option::Option<{}>",
                self.type_name
            ),
            |w| {
                w.match_expr("str", |w| {
                    let values = self.values_unique();
                    for value in values {
                        w.write_line(&format!(
                            "\"{}\" => ::std::option::Option::Some({}),",
                            value.value.proto.name(),
                            value.rust_name_outer()
                        ));
                    }
                    w.write_line(&format!("_ => {}", EXPR_NONE));
                });
            },
        );
    }

    fn write_impl_enum_const_values(&self, w: &mut CodeWriter) {
        w.write_line(&format!("const VALUES: &'static [{}] = &[", self.type_name));
        w.indented(|w| {
            for value in self.values_all() {
                w.write_line(&format!("{},", value.rust_name_outer()));
            }
        });
        w.write_line("];");
    }

    fn write_impl_enum(&self, w: &mut CodeWriter) {
        w.impl_for_block(
            &format!("{}::Enum", protobuf_crate_path(&self.customize.for_elem)),
            &format!("{}", self.type_name),
            |w| {
                self.write_impl_enum_const_name(w);
                w.write_line("");
                self.write_impl_enum_fn_value(w);
                w.write_line("");
                self.write_impl_enum_fn_from_i32(w);
                w.write_line("");
                self.write_impl_enum_fn_from_str(w);
                w.write_line("");
                self.write_impl_enum_const_values(w);
            },
        );
    }

    fn write_impl_enum_full(&self, w: &mut CodeWriter) {
        let ref type_name = self.type_name;
        w.impl_for_block(
            &format!(
                "{}::EnumFull",
                protobuf_crate_path(&self.customize.for_elem)
            ),
            &format!("{}", type_name),
            |w| {
                self.write_impl_enum_full_fn_enum_descriptor(w);
                w.write_line("");
                self.write_impl_enum_full_fn_descriptor(w);
            },
        );
    }

    fn write_impl_enum_full_fn_enum_descriptor(&self, w: &mut CodeWriter) {
        write_fn_descriptor(
            &self.enum_with_scope.en,
            self.enum_with_scope.scope(),
            &self.customize.for_elem,
            w,
        );
    }

    fn rust_enum_descriptor_is_enum_index(&self) -> bool {
        if self.allow_alias() {
            false
        } else {
            self.values_all()
                .into_iter()
                .enumerate()
                .all(|(i, value)| (i as i32) == value.number())
        }
    }

    fn write_impl_enum_full_fn_descriptor(&self, w: &mut CodeWriter) {
        let sig = format!(
            "descriptor(&self) -> {}::reflect::EnumValueDescriptor",
            protobuf_crate_path(&self.customize.for_elem)
        );
        w.def_fn(&sig, |w| {
            if self.rust_enum_descriptor_is_enum_index() {
                w.write_line("let index = *self as usize;");
            } else {
                w.write_line("let index = match self {");
                w.indented(|w| {
                    for (i, value) in self.values_all().into_iter().enumerate() {
                        w.write_line(&format!(
                            "{}::{} => {},",
                            self.type_name,
                            value.rust_name_inner(),
                            i
                        ));
                    }
                });
                w.write_line("};");
            }
            w.write_line(&format!("Self::enum_descriptor().value_by_index(index)"));
        });
    }

    fn write_generated_enum_descriptor_data(&self, w: &mut CodeWriter) {
        let sig = format!(
            "generated_enum_descriptor_data() -> {}::reflect::GeneratedEnumDescriptorData",
            protobuf_crate_path(&self.customize.for_elem)
        );
        w.fn_block(
            Visibility::Path(
                self.enum_with_scope
                    .scope()
                    .rust_path_to_file()
                    .to_reverse(),
            ),
            &sig,
            |w| {
                w.write_line(&format!(
                    "{}::reflect::GeneratedEnumDescriptorData::new::<{}>(\"{}\")",
                    protobuf_crate_path(&self.customize.for_elem),
                    self.type_name,
                    self.enum_with_scope.name_to_package(),
                ));
            },
        );
    }

    fn write_impl_eq(&self, w: &mut CodeWriter) {
        assert!(self.allow_alias());
        w.impl_for_block(
            "::std::cmp::PartialEq",
            &format!("{}", self.type_name),
            |w| {
                w.def_fn("eq(&self, other: &Self) -> bool", |w| {
                    w.write_line(&format!(
                        "{}::Enum::value(self) == {}::Enum::value(other)",
                        protobuf_crate_path(&self.customize.for_elem),
                        protobuf_crate_path(&self.customize.for_elem)
                    ));
                });
            },
        );
    }

    fn write_impl_hash(&self, w: &mut CodeWriter) {
        assert!(self.allow_alias());
        w.impl_for_block("::std::hash::Hash", &format!("{}", self.type_name), |w| {
            w.def_fn("hash<H : ::std::hash::Hasher>(&self, state: &mut H)", |w| {
                w.write_line(&format!(
                    "state.write_i32({}::Enum::value(self))",
                    protobuf_crate_path(&self.customize.for_elem)
                ));
            });
        });
    }

    fn write_impl_default(&self, w: &mut CodeWriter) {
        let first_value = &self.enum_with_scope.values()[0];
        if first_value.proto.proto().number() != 0 {
            // This warning is emitted only for proto2
            // (because in proto3 first enum variant number is always 0).
            // `Default` implemented unconditionally to simplify certain
            // generic operations, e. g. reading a map.
            // Also, note that even in proto2 some operations fallback to
            // first enum value, e. g. `get_xxx` for unset field,
            // so this implementation is not completely unreasonable.
            w.comment("Note, `Default` is implemented although default value is not 0");
        }
        w.impl_for_block(
            "::std::default::Default",
            &format!("{}", self.type_name),
            |w| {
                w.def_fn("default() -> Self", |w| {
                    w.write_line(&format!(
                        "{}::{}",
                        &self.type_name,
                        &first_value.rust_name()
                    ))
                });
            },
        );
    }
}

'''
'''--- protobuf-codegen/src/gen/extensions.rs ---
use protobuf::descriptor::*;
use protobuf::reflect::FileDescriptor;
use protobuf_parse::ProtobufAbsPath;

use crate::customize::ctx::CustomizeElemCtx;
use crate::customize::Customize;
use crate::gen::code_writer::CodeWriter;
use crate::gen::field::rust_field_name_for_protobuf_field_name;
use crate::gen::file_and_mod::FileAndMod;
use crate::gen::inside::protobuf_crate_path;
use crate::gen::message::RustTypeMessage;
use crate::gen::rust::ident_with_path::RustIdentWithPath;
use crate::gen::rust::rel_path::RustRelativePath;
use crate::gen::rust_types_values::*;
use crate::gen::scope::RootScope;

struct ExtGen<'a> {
    file: &'a FileDescriptor,
    root_scope: &'a RootScope<'a>,
    field: &'a FieldDescriptorProto,
    customize: Customize,
}

impl<'a> ExtGen<'a> {
    fn extendee_rust_name(&self) -> RustIdentWithPath {
        type_name_to_rust_relative(
            &ProtobufAbsPath::from(self.field.extendee()),
            &FileAndMod {
                file: self.file.proto().name().to_owned(),
                relative_mod: RustRelativePath::from("exts"),
                customize: self.customize.clone(),
            },
            self.root_scope,
        )
    }

    fn repeated(&self) -> bool {
        match self.field.label() {
            field_descriptor_proto::Label::LABEL_REPEATED => true,
            field_descriptor_proto::Label::LABEL_OPTIONAL => false,
            field_descriptor_proto::Label::LABEL_REQUIRED => {
                panic!("required ext field: {}", self.field.name())
            }
        }
    }

    fn return_type_gen(&self) -> ProtobufTypeGen {
        if self.field.has_type_name() {
            let rust_name_relative = type_name_to_rust_relative(
                &ProtobufAbsPath::from(self.field.type_name()),
                &FileAndMod {
                    file: self.file.proto().name().to_owned(),
                    relative_mod: RustRelativePath::from("exts"),
                    customize: self.customize.clone(),
                },
                self.root_scope,
            );
            match self.field.type_() {
                field_descriptor_proto::Type::TYPE_MESSAGE => {
                    ProtobufTypeGen::Message(RustTypeMessage(rust_name_relative))
                }
                field_descriptor_proto::Type::TYPE_ENUM => {
                    ProtobufTypeGen::EnumOrUnknown(rust_name_relative)
                }
                t => panic!("unknown type: {:?}", t),
            }
        } else {
            ProtobufTypeGen::Primitive(self.field.type_(), PrimitiveTypeVariant::Default)
        }
    }

    fn write(&self, w: &mut CodeWriter) {
        let suffix = if self.repeated() {
            "ExtFieldRepeated"
        } else {
            "ExtFieldOptional"
        };
        let field_type = format!(
            "{protobuf_crate}::ext::{suffix}",
            protobuf_crate = protobuf_crate_path(&self.customize)
        );
        w.pub_const(
            &rust_field_name_for_protobuf_field_name(self.field.name()).to_string(),
            &format!(
                "{field_type}<{extendee}, {rust_type}>",
                extendee=self.extendee_rust_name(),
                rust_type=self.return_type_gen().protobuf_value(&self.customize),
            ),
            &format!(
                "{field_type}::new({field_number}, {protobuf_crate}::descriptor::field_descriptor_proto::Type::{t:?})",
                field_number=self.field.number(),
                protobuf_crate = protobuf_crate_path(&self.customize),
                t=self.field.type_(),
            ),
        );
    }
}

pub(crate) fn write_extensions(
    file: &FileDescriptor,
    root_scope: &RootScope,
    w: &mut CodeWriter,
    customize: &CustomizeElemCtx,
) {
    if file.proto().extension.is_empty() {
        return;
    }

    if customize.for_elem.lite_runtime.unwrap_or(false) {
        w.write_line("");
        w.comment("Extension generation with lite runtime is not supported");
        return;
    }

    w.write_line("");
    w.write_line("/// Extension fields");
    w.pub_mod("exts", |w| {
        for field in &file.proto().extension {
            if field.type_() == field_descriptor_proto::Type::TYPE_GROUP {
                continue;
            }

            w.write_line("");
            ExtGen {
                file,
                root_scope,
                field,
                customize: customize.for_elem.clone(),
            }
            .write(w);
        }
    });
}

'''
'''--- protobuf-codegen/src/gen/field/accessor.rs ---
use crate::gen::code_writer::CodeWriter;
use crate::gen::field::elem::FieldElem;
use crate::gen::field::elem::FieldElemEnum;
use crate::gen::field::option_kind::OptionKind;
use crate::gen::field::repeated::RepeatedField;
use crate::gen::field::repeated::RepeatedFieldKind;
use crate::gen::field::singular::SingularField;
use crate::gen::field::singular::SingularFieldFlag;
use crate::gen::field::FieldGen;
use crate::gen::field::FieldKind;
use crate::gen::field::MapField;
use crate::gen::inside::protobuf_crate_path;
use crate::gen::oneof::OneofField;
use crate::gen::rust_types_values::RustType;
use crate::gen::scope::WithScope;

struct AccessorFn {
    name: String,
    // function type params after first underscore
    type_params: Vec<String>,
    callback_params: Vec<String>,
}

impl AccessorFn {
    fn sig(&self) -> String {
        let mut s = self.name.clone();
        s.push_str("::<_");
        for p in &self.type_params {
            s.push_str(", ");
            s.push_str(&p);
        }
        s.push_str(">");
        s
    }
}

impl FieldGen<'_> {
    fn make_accessor_fns_lambda(&self) -> Vec<String> {
        let message = self.proto_field.message.rust_name();
        vec![
            format!("|m: &{}| {{ &m.{} }}", message, self.rust_name),
            format!("|m: &mut {}| {{ &mut m.{} }}", message, self.rust_name),
        ]
    }

    fn make_accessor_fns_has_get_set(&self) -> Vec<String> {
        let message = self.proto_field.message.rust_name();
        vec![
            format!("{}::{}", message, self.has_name()),
            format!("{}::{}", message, self.rust_name),
            format!("{}::{}", message, self.set_name()),
        ]
    }

    fn make_accessor_fns_has_get_mut_set(&self) -> Vec<String> {
        let message = self.proto_field.message.rust_name();
        vec![
            format!("{}::{}", message, self.has_name()),
            format!("{}::{}", message, self.rust_name),
            format!("{}::{}", message, self.mut_name()),
            format!("{}::{}", message, self.set_name()),
        ]
    }

    fn accessor_fn_map(&self, map_field: &MapField) -> AccessorFn {
        let MapField { .. } = map_field;
        AccessorFn {
            name: "make_map_simpler_accessor".to_owned(),
            type_params: vec![format!("_"), format!("_")],
            callback_params: self.make_accessor_fns_lambda(),
        }
    }

    fn accessor_fn_repeated(&self, repeated_field: &RepeatedField) -> AccessorFn {
        let RepeatedField { .. } = repeated_field;
        let name = match repeated_field.kind() {
            RepeatedFieldKind::Vec => "make_vec_simpler_accessor",
        };
        AccessorFn {
            name: name.to_owned(),
            type_params: vec![format!("_")],
            callback_params: self.make_accessor_fns_lambda(),
        }
    }

    fn accessor_fn_oneof_enum(&self, oneof: &OneofField, en: &FieldElemEnum) -> AccessorFn {
        let message = self.proto_field.message.rust_name();

        let variant_path = oneof.variant_path(&self.proto_field.message.scope.rust_path_to_file());

        let getter = CodeWriter::with_no_error(|w| {
            w.expr_block(
                &format!(
                    "|message: &{}| match &message.{}",
                    message, oneof.oneof_field_name
                ),
                |w| {
                    w.case_expr(
                        &format!("::std::option::Option::Some({}(e))", variant_path),
                        "::std::option::Option::Some(*e)",
                    );
                    w.case_expr("_", "::std::option::Option::None");
                },
            );
        });

        let setter = CodeWriter::with_no_error(|w| {
            w.expr_block(
                &format!(
                    "|message: &mut {}, e: {}::EnumOrUnknown<{}>|",
                    message,
                    protobuf_crate_path(&self.customize),
                    en.enum_rust_type(&self.file_and_mod())
                        .to_code(&self.customize)
                ),
                |w| {
                    w.write_line(&format!(
                        "message.{} = ::std::option::Option::Some({}(e));",
                        oneof.oneof_field_name, variant_path
                    ));
                },
            )
        });

        let default = self.xxx_default_value_rust();

        AccessorFn {
            name: "make_oneof_enum_accessors".to_owned(),
            type_params: vec![format!("_")],
            callback_params: vec![getter, setter, default],
        }
    }

    fn accessor_fn_singular_without_flag(&self, _elem: &FieldElem) -> AccessorFn {
        AccessorFn {
            name: "make_simpler_field_accessor".to_owned(),
            type_params: vec![format!("_")],
            callback_params: self.make_accessor_fns_lambda(),
        }
    }

    fn accessor_fn_singular_with_flag(
        &self,
        elem: &FieldElem,
        _option_kind: OptionKind,
    ) -> AccessorFn {
        match elem {
            FieldElem::Message(m) => AccessorFn {
                name: "make_message_field_accessor".to_owned(),
                type_params: vec![format!("{}", m.rust_name_relative(&self.file_and_mod()))],
                callback_params: self.make_accessor_fns_lambda(),
            },
            FieldElem::Primitive(..) | FieldElem::Enum(..) => AccessorFn {
                name: "make_option_accessor".to_owned(),
                type_params: vec!["_".to_owned()],
                callback_params: self.make_accessor_fns_lambda(),
            },
            FieldElem::Group => {
                unreachable!("no accessor for group field");
            }
        }
    }

    fn accessor_fn_oneof(&self, oneof: &OneofField) -> AccessorFn {
        let OneofField { ref elem, .. } = oneof;

        let reference = self
            .proto_field
            .message
            .scope
            .file_and_mod(self.customize.clone());

        if let FieldElem::Enum(en) = &oneof.elem {
            return self.accessor_fn_oneof_enum(oneof, en);
        }

        if elem.is_copy() {
            return AccessorFn {
                name: "make_oneof_copy_has_get_set_simpler_accessors".to_owned(),
                type_params: vec![format!("_")],
                callback_params: self.make_accessor_fns_has_get_set(),
            };
        }

        if let RustType::Message(name) = elem.rust_storage_elem_type(&reference) {
            return AccessorFn {
                name: "make_oneof_message_has_get_mut_set_accessor".to_owned(),
                type_params: vec![format!("{}", name)],
                callback_params: self.make_accessor_fns_has_get_mut_set(),
            };
        }

        // string or bytes
        AccessorFn {
            name: "make_oneof_deref_has_get_set_simpler_accessor".to_owned(),
            type_params: vec![format!("_")],
            callback_params: self.make_accessor_fns_has_get_set(),
        }
    }

    fn accessor_fn(&self) -> AccessorFn {
        match self.kind {
            FieldKind::Repeated(ref repeated_field) => self.accessor_fn_repeated(repeated_field),
            FieldKind::Map(ref map_field) => self.accessor_fn_map(map_field),
            FieldKind::Singular(SingularField {
                ref elem,
                flag: SingularFieldFlag::WithoutFlag,
            }) => self.accessor_fn_singular_without_flag(elem),
            FieldKind::Singular(SingularField {
                ref elem,
                flag: SingularFieldFlag::WithFlag { option_kind, .. },
            }) => self.accessor_fn_singular_with_flag(elem, option_kind),
            FieldKind::Oneof(ref oneof) => self.accessor_fn_oneof(oneof),
        }
    }

    pub fn write_push_accessor(&self, fields_var: &str, w: &mut CodeWriter) {
        let accessor_fn = self.accessor_fn();
        w.write_line(&format!(
            "{}.push({}::reflect::rt::v2::{}(",
            fields_var,
            protobuf_crate_path(&self.customize),
            accessor_fn.sig()
        ));
        w.indented(|w| {
            w.write_line(&format!("\"{}\",", self.proto_field.name()));
            for callback in &accessor_fn.callback_params {
                let callback_lines: Vec<&str> = callback.lines().collect();
                for (i, callback_line) in callback_lines.iter().enumerate() {
                    let comma = if i == callback_lines.len() - 1 {
                        ","
                    } else {
                        ""
                    };
                    w.write_line(&format!("{}{}", callback_line, comma));
                }
            }
        });
        w.write_line("));");
    }
}

'''
'''--- protobuf-codegen/src/gen/field/elem.rs ---
use protobuf::descriptor::field_descriptor_proto::Type;
use protobuf::reflect::RuntimeFieldType;
use protobuf::rt::tag_size;
use protobuf_parse::ProtobufAbsPath;

use crate::gen::code_writer::CodeWriter;
use crate::gen::field::type_ext::TypeExt;
use crate::gen::file_and_mod::FileAndMod;
use crate::gen::inside::protobuf_crate_path;
use crate::gen::message::RustTypeMessage;
use crate::gen::rust::ident_with_path::RustIdentWithPath;
use crate::gen::rust_types_values::message_or_enum_to_rust_relative;
use crate::gen::rust_types_values::PrimitiveTypeVariant;
use crate::gen::rust_types_values::RustType;
use crate::gen::rust_types_values::RustValueTyped;
use crate::gen::scope::EnumValueWithContext;
use crate::gen::scope::FieldWithContext;
use crate::gen::scope::MessageOrEnumWithScope;
use crate::gen::scope::MessageWithScope;
use crate::gen::scope::RootScope;
use crate::Customize;

#[derive(Clone, Debug)]
pub(crate) struct FieldElemEnum<'a> {
    /// Enum default value variant, either from proto or from enum definition
    default_value: EnumValueWithContext<'a>,
}

impl<'a> FieldElemEnum<'a> {
    fn rust_name_relative(&self, reference: &FileAndMod) -> RustIdentWithPath {
        message_or_enum_to_rust_relative(&self.default_value.en, reference)
    }

    pub(crate) fn enum_rust_type(&self, reference: &FileAndMod) -> RustType {
        RustType::Enum(
            self.rust_name_relative(reference),
            self.default_value.rust_name(),
            self.default_value.proto.proto().number(),
        )
    }

    fn enum_or_unknown_rust_type(&self, reference: &FileAndMod) -> RustType {
        RustType::EnumOrUnknown(
            self.rust_name_relative(reference),
            self.default_value.rust_name(),
            self.default_value.proto.proto().number(),
        )
    }

    pub(crate) fn default_value_rust_expr(&self, reference: &FileAndMod) -> RustIdentWithPath {
        self.rust_name_relative(reference)
            .to_path()
            .with_ident(self.default_value.rust_name())
    }
}

#[derive(Clone, Debug)]
pub(crate) struct FieldElemMessage<'a> {
    pub message: MessageWithScope<'a>,
}

impl<'a> FieldElemMessage<'a> {
    pub(crate) fn rust_name_relative(&self, reference: &FileAndMod) -> RustTypeMessage {
        RustTypeMessage(message_or_enum_to_rust_relative(&self.message, reference))
    }

    fn rust_type(&self, reference: &FileAndMod) -> RustType {
        RustType::Message(self.rust_name_relative(reference))
    }
}

#[derive(Clone, Debug)]
pub(crate) enum FieldElem<'a> {
    Primitive(Type, PrimitiveTypeVariant),
    Message(FieldElemMessage<'a>),
    Enum(FieldElemEnum<'a>),
    Group,
}

pub(crate) enum HowToGetMessageSize {
    Compute,
    GetCached,
}

impl<'a> FieldElem<'a> {
    pub(crate) fn proto_type(&self) -> Type {
        match *self {
            FieldElem::Primitive(t, ..) => t,
            FieldElem::Group => Type::TYPE_GROUP,
            FieldElem::Message(..) => Type::TYPE_MESSAGE,
            FieldElem::Enum(..) => Type::TYPE_ENUM,
        }
    }

    pub(crate) fn is_copy(&self) -> bool {
        self.proto_type().is_copy()
    }

    pub(crate) fn rust_storage_elem_type(&self, reference: &FileAndMod) -> RustType {
        match *self {
            FieldElem::Primitive(t, PrimitiveTypeVariant::Default) => t.rust_type(),
            FieldElem::Primitive(Type::TYPE_STRING, PrimitiveTypeVariant::TokioBytes) => {
                RustType::Chars
            }
            FieldElem::Primitive(Type::TYPE_BYTES, PrimitiveTypeVariant::TokioBytes) => {
                RustType::Bytes
            }
            FieldElem::Primitive(.., PrimitiveTypeVariant::TokioBytes) => unreachable!(),
            FieldElem::Group => RustType::Group,
            FieldElem::Message(ref m) => m.rust_type(reference),
            FieldElem::Enum(ref en) => en.enum_or_unknown_rust_type(reference),
        }
    }

    // Type of set_xxx function parameter type for singular fields
    pub(crate) fn rust_set_xxx_param_type(&self, reference: &FileAndMod) -> RustType {
        if let FieldElem::Enum(ref en) = *self {
            en.enum_rust_type(reference)
        } else {
            self.rust_storage_elem_type(reference)
        }
    }

    pub(crate) fn primitive_type_variant(&self) -> PrimitiveTypeVariant {
        match self {
            &FieldElem::Primitive(_, v) => v,
            _ => PrimitiveTypeVariant::Default,
        }
    }

    pub(crate) fn singular_field_size(
        &self,
        field_number: u32,
        var: &RustValueTyped,
        customize: &Customize,
    ) -> String {
        let tag_size = tag_size(field_number);
        match self.proto_type().encoded_size() {
            Some(data_size) => format!("{tag_size} + {data_size}"),
            None => match self.proto_type() {
                Type::TYPE_MESSAGE => panic!("not a single-liner"),
                // We are not inlining `bytes_size` here,
                // assuming the compiler is smart enough to do it for us.
                // https://rust.godbolt.org/z/GrKa5zxq6
                Type::TYPE_BYTES => format!(
                    "{}::rt::bytes_size({}, &{})",
                    protobuf_crate_path(customize),
                    field_number,
                    var.value
                ),
                Type::TYPE_STRING => format!(
                    "{}::rt::string_size({}, &{})",
                    protobuf_crate_path(customize),
                    field_number,
                    var.value
                ),
                Type::TYPE_ENUM => {
                    format!(
                        "{}::rt::int32_size({}, {}.value())",
                        protobuf_crate_path(customize),
                        field_number,
                        var.value,
                    )
                }
                _ => {
                    let param_type = match &var.rust_type {
                        RustType::Ref(t) => (**t).clone(),
                        t => t.clone(),
                    };
                    let f = match self.proto_type() {
                        Type::TYPE_SINT32 => "sint32_size",
                        Type::TYPE_SINT64 => "sint64_size",
                        Type::TYPE_INT32 => "int32_size",
                        Type::TYPE_INT64 => "int64_size",
                        Type::TYPE_UINT32 => "uint32_size",
                        Type::TYPE_UINT64 => "uint64_size",
                        t => unreachable!("unexpected type: {:?}", t),
                    };
                    format!(
                        "{}::rt::{f}({}, {})",
                        protobuf_crate_path(customize),
                        field_number,
                        var.into_type(param_type, customize).value
                    )
                }
            },
        }
    }

    pub(crate) fn write_element_size(
        &self,
        field_number: u32,
        item_var: &RustValueTyped,
        how_to_get_message_size: HowToGetMessageSize,
        sum_var: &str,
        customize: &Customize,
        w: &mut CodeWriter,
    ) {
        let tag_size = tag_size(field_number);
        match self.proto_type() {
            Type::TYPE_MESSAGE => {
                match how_to_get_message_size {
                    HowToGetMessageSize::Compute => {
                        w.write_line(&format!("let len = {}.compute_size();", item_var.value))
                    }
                    HowToGetMessageSize::GetCached => w.write_line(&format!(
                        "let len = {}.cached_size() as u64;",
                        item_var.value
                    )),
                }
                w.write_line(&format!(
                    "{sum_var} += {tag_size} + {}::rt::compute_raw_varint64_size(len) + len;",
                    protobuf_crate_path(customize),
                ));
            }
            _ => {
                w.write_line(&format!(
                    "{sum_var} += {};",
                    self.singular_field_size(field_number, item_var, customize)
                ));
            }
        }
    }

    pub(crate) fn write_write_element(
        &self,
        field_number: u32,
        v: &RustValueTyped,
        file_and_mod: &FileAndMod,
        customize: &Customize,
        os: &str,
        w: &mut CodeWriter,
    ) {
        match self.proto_type() {
            Type::TYPE_MESSAGE => {
                let param_type = RustType::Ref(Box::new(self.rust_storage_elem_type(file_and_mod)));

                w.write_line(&format!(
                    "{}::rt::write_message_field_with_cached_size({}, {}, {})?;",
                    protobuf_crate_path(customize),
                    field_number,
                    v.into_type(param_type, customize).value,
                    os
                ));
            }
            _ => {
                let param_type = self.proto_type().os_write_fn_param_type();
                let os_write_fn_suffix = self.proto_type().protobuf_name();
                w.write_line(&format!(
                    "{}.write_{}({}, {})?;",
                    os,
                    os_write_fn_suffix,
                    field_number,
                    v.into_type(param_type, customize).value
                ));
            }
        }
    }

    pub(crate) fn read_one_liner(&self) -> String {
        format!(
            "{}?",
            self.proto_type().read("is", self.primitive_type_variant())
        )
    }
}

pub(crate) fn field_elem<'a>(
    field: &FieldWithContext,
    root_scope: &'a RootScope<'a>,
    customize: &Customize,
) -> FieldElem<'a> {
    if let RuntimeFieldType::Map(..) = field.field.runtime_field_type() {
        unreachable!();
    }

    if field.field.proto().type_() == Type::TYPE_GROUP {
        FieldElem::Group
    } else if field.field.proto().has_type_name() {
        let message_or_enum = root_scope
            .find_message_or_enum(&ProtobufAbsPath::from(field.field.proto().type_name()));
        match (field.field.proto().type_(), message_or_enum) {
            (Type::TYPE_MESSAGE, MessageOrEnumWithScope::Message(message)) => {
                FieldElem::Message(FieldElemMessage {
                    message: message.clone(),
                })
            }
            (Type::TYPE_ENUM, MessageOrEnumWithScope::Enum(enum_with_scope)) => {
                let default_value = if field.field.proto().has_default_value() {
                    enum_with_scope.value_by_name(field.field.proto().default_value())
                } else {
                    enum_with_scope.values()[0].clone()
                };
                FieldElem::Enum(FieldElemEnum { default_value })
            }
            _ => panic!("unknown named type: {:?}", field.field.proto().type_()),
        }
    } else if field.field.proto().has_type() {
        let tokio_for_bytes = customize.tokio_bytes.unwrap_or(false);
        let tokio_for_string = customize.tokio_bytes_for_string.unwrap_or(false);

        let elem = match field.field.proto().type_() {
            Type::TYPE_STRING if tokio_for_string => {
                FieldElem::Primitive(Type::TYPE_STRING, PrimitiveTypeVariant::TokioBytes)
            }
            Type::TYPE_BYTES if tokio_for_bytes => {
                FieldElem::Primitive(Type::TYPE_BYTES, PrimitiveTypeVariant::TokioBytes)
            }
            t => FieldElem::Primitive(t, PrimitiveTypeVariant::Default),
        };

        elem
    } else {
        panic!(
            "neither type_name, nor field_type specified for field: {}",
            field.field.name()
        );
    }
}

'''
'''--- protobuf-codegen/src/gen/field/mod.rs ---
mod accessor;
pub(crate) mod elem;
mod option_kind;
mod repeated;
mod singular;
mod tag;
pub(crate) mod type_ext;

use protobuf::descriptor::field_descriptor_proto::Type;
use protobuf::descriptor::*;
use protobuf::reflect::ReflectValueRef;
use protobuf::reflect::RuntimeFieldType;
use protobuf::reflect::Syntax;
use protobuf::rt;
use protobuf::rt::WireType;
use protobuf_parse::camel_case;
use protobuf_parse::ProtobufAbsPath;

use crate::customize::ctx::CustomizeElemCtx;
use crate::customize::rustproto_proto::customize_from_rustproto_for_field;
use crate::customize::Customize;
use crate::gen::code_writer::CodeWriter;
use crate::gen::code_writer::Visibility;
use crate::gen::field::elem::field_elem;
use crate::gen::field::elem::FieldElem;
use crate::gen::field::elem::FieldElemEnum;
use crate::gen::field::elem::HowToGetMessageSize;
use crate::gen::field::option_kind::OptionKind;
use crate::gen::field::repeated::RepeatedField;
use crate::gen::field::singular::SingularField;
use crate::gen::field::singular::SingularFieldFlag;
use crate::gen::field::tag::make_tag;
use crate::gen::field::type_ext::TypeExt;
use crate::gen::file_and_mod::FileAndMod;
use crate::gen::inside::protobuf_crate_path;
use crate::gen::map::map_entry;
use crate::gen::oneof::OneofField;
use crate::gen::protoc_insertion_point::write_protoc_insertion_point_for_field;
use crate::gen::rust::ident::RustIdent;
use crate::gen::rust::quote::quote_escape_bytes;
use crate::gen::rust::quote::quote_escape_str;
use crate::gen::rust::snippets::EXPR_NONE;
use crate::gen::rust_types_values::PrimitiveTypeVariant;
use crate::gen::rust_types_values::RustType;
use crate::gen::rust_types_values::RustValueTyped;
use crate::gen::scope::FieldWithContext;
use crate::gen::scope::MessageWithScope;
use crate::gen::scope::RootScope;

fn field_type_protobuf_name<'a>(field: &'a FieldDescriptorProto) -> &'a str {
    if field.has_type_name() {
        field.type_name()
    } else {
        field.type_().protobuf_name()
    }
}

#[derive(Clone)]
pub struct MapField<'a> {
    _message: MessageWithScope<'a>,
    key: FieldElem<'a>,
    value: FieldElem<'a>,
}

#[derive(Clone)]
pub(crate) enum FieldKind<'a> {
    // optional or required
    Singular(SingularField<'a>),
    // repeated except map
    Repeated(RepeatedField<'a>),
    // map
    Map(MapField<'a>),
    // part of oneof
    Oneof(OneofField<'a>),
}

impl<'a> FieldKind<'a> {
    pub(crate) fn default(
        &self,
        customize: &Customize,
        reference: &FileAndMod,
        const_expr: bool,
    ) -> String {
        match self {
            FieldKind::Singular(s) => s.default_value(customize, reference, const_expr),
            FieldKind::Repeated(r) => r.default(),
            FieldKind::Oneof(..) => EXPR_NONE.to_owned(),
            FieldKind::Map(..) => panic!("map fields cannot have field value"),
        }
    }
}

#[derive(Clone)]
pub(crate) enum SingularOrOneofField<'a> {
    Singular(SingularField<'a>),
    Oneof(OneofField<'a>),
}

impl<'a> SingularOrOneofField<'a> {
    fn elem(&self) -> &FieldElem {
        match self {
            SingularOrOneofField::Singular(SingularField { ref elem, .. }) => elem,
            SingularOrOneofField::Oneof(OneofField { ref elem, .. }) => elem,
        }
    }

    // Type of `xxx` function for singular type.
    pub(crate) fn getter_return_type(&self, reference: &FileAndMod) -> RustType {
        let elem = self.elem();
        if let FieldElem::Enum(ref en) = elem {
            en.enum_rust_type(reference)
        } else if elem.is_copy() {
            elem.rust_storage_elem_type(reference)
        } else {
            elem.rust_storage_elem_type(reference).ref_type()
        }
    }
}

// Representation of map entry: key type and value type
#[derive(Clone, Debug)]
pub struct EntryKeyValue<'a>(FieldElem<'a>, FieldElem<'a>);

#[derive(Clone)]
pub(crate) struct FieldGen<'a> {
    syntax: Syntax,
    pub proto_field: FieldWithContext<'a>,
    // field name in generated code
    pub rust_name: RustIdent,
    pub proto_type: Type,
    wire_type: WireType,
    pub kind: FieldKind<'a>,
    pub generate_accessors: bool,
    pub generate_getter: bool,
    customize: Customize,
    path: Vec<i32>,
    info: Option<&'a SourceCodeInfo>,
}

impl<'a> FieldGen<'a> {
    pub(crate) fn parse(
        field: FieldWithContext<'a>,
        root_scope: &'a RootScope<'a>,
        parent_customize: &CustomizeElemCtx<'a>,
        path: Vec<i32>,
        info: Option<&'a SourceCodeInfo>,
    ) -> anyhow::Result<FieldGen<'a>> {
        let customize = parent_customize
            .child(
                &customize_from_rustproto_for_field(field.field.proto().options.get_or_default()),
                &field.field,
            )
            .for_elem;

        let syntax = field.message.scope.file_scope.syntax();

        let field_may_have_custom_default_value = syntax == Syntax::Proto2
            && field.field.proto().label() != field_descriptor_proto::Label::LABEL_REPEATED
            && field.field.proto().type_() != Type::TYPE_MESSAGE;

        let generate_accessors = customize
            .generate_accessors
            .unwrap_or(field_may_have_custom_default_value)
            || field.is_oneof();

        let default_generate_getter = generate_accessors || field_may_have_custom_default_value;
        let generate_getter =
            customize.generate_getter.unwrap_or(default_generate_getter) || field.is_oneof();

        let kind = match field.field.runtime_field_type() {
            RuntimeFieldType::Map(..) => {
                let message = root_scope
                    .find_message(&ProtobufAbsPath::from(field.field.proto().type_name()));

                let (key, value) = map_entry(&message).unwrap();

                let key = field_elem(&key, root_scope, &customize);
                let value = field_elem(&value, root_scope, &customize);

                FieldKind::Map(MapField {
                    _message: message,
                    key,
                    value,
                })
            }
            RuntimeFieldType::Repeated(..) => {
                let elem = field_elem(&field, root_scope, &customize);

                FieldKind::Repeated(RepeatedField {
                    elem,
                    packed: field.field.proto().options.get_or_default().packed(),
                })
            }
            RuntimeFieldType::Singular(..) => {
                let elem = field_elem(&field, root_scope, &customize);

                if let Some(oneof) = field.oneof() {
                    FieldKind::Oneof(OneofField::parse(&oneof, &field.field, elem, root_scope))
                } else {
                    let flag = if field.message.scope.file_scope.syntax() == Syntax::Proto3
                        && field.field.proto().type_() != field_descriptor_proto::Type::TYPE_MESSAGE
                        && !field.field.proto().proto3_optional()
                    {
                        SingularFieldFlag::WithoutFlag
                    } else {
                        let required = field.field.proto().label()
                            == field_descriptor_proto::Label::LABEL_REQUIRED;
                        let option_kind = match field.field.proto().type_() {
                            field_descriptor_proto::Type::TYPE_MESSAGE => OptionKind::MessageField,
                            _ => OptionKind::Option,
                        };

                        SingularFieldFlag::WithFlag {
                            required,
                            option_kind,
                        }
                    };
                    FieldKind::Singular(SingularField { elem, flag })
                }
            }
        };

        Ok(FieldGen {
            syntax: field.message.message.file_descriptor().syntax(),
            rust_name: rust_field_name_for_protobuf_field_name(&field.field.name()),
            proto_type: field.field.proto().type_(),
            wire_type: WireType::for_type(field.field.proto().type_()),
            proto_field: field,
            kind,
            generate_accessors,
            generate_getter,
            customize,
            path,
            info,
        })
    }

    // for message level
    fn file_and_mod(&self) -> FileAndMod {
        self.proto_field
            .message
            .scope
            .file_and_mod(self.customize.clone())
    }

    fn tag_size(&self) -> u32 {
        rt::tag_size(self.proto_field.number() as u32) as u32
    }

    fn is_singular(&self) -> bool {
        match self.kind {
            FieldKind::Singular(..) => true,
            _ => false,
        }
    }

    fn is_repeated_packed(&self) -> bool {
        match self.kind {
            FieldKind::Repeated(RepeatedField { packed: true, .. }) => true,
            _ => false,
        }
    }

    pub(crate) fn elem(&self) -> &FieldElem {
        match self.kind {
            FieldKind::Singular(SingularField { ref elem, .. }) => &elem,
            FieldKind::Repeated(RepeatedField { ref elem, .. }) => &elem,
            FieldKind::Oneof(OneofField { ref elem, .. }) => &elem,
            FieldKind::Map(..) => unreachable!(),
        }
    }

    // type of field in struct
    pub(crate) fn full_storage_type(&self, reference: &FileAndMod) -> RustType {
        match self.kind {
            FieldKind::Repeated(ref repeated) => repeated.rust_type(reference),
            FieldKind::Map(MapField {
                ref key, ref value, ..
            }) => RustType::HashMap(
                Box::new(key.rust_storage_elem_type(reference)),
                Box::new(value.rust_storage_elem_type(reference)),
            ),
            FieldKind::Singular(ref singular) => singular.rust_storage_type(reference),
            FieldKind::Oneof(..) => unreachable!(),
        }
    }

    // type of `v` in `for v in field`
    fn full_storage_iter_elem_type(&self, reference: &FileAndMod) -> RustType {
        if let FieldKind::Oneof(ref oneof) = self.kind {
            oneof.elem.rust_storage_elem_type(reference)
        } else {
            self.full_storage_type(reference).iter_elem_type()
        }
    }

    // suffix `xxx` as in `os.write_xxx_no_tag(..)`
    fn os_write_fn_suffix(&self) -> &str {
        self.proto_type.protobuf_name()
    }

    fn os_write_fn_suffix_with_unknown_for_enum(&self) -> &str {
        if self.proto_type == field_descriptor_proto::Type::TYPE_ENUM {
            "enum_or_unknown"
        } else {
            self.os_write_fn_suffix()
        }
    }

    // for field `foo`, type of param of `fn set_foo(..)`
    fn set_xxx_param_type(&self, reference: &FileAndMod) -> RustType {
        match self.kind {
            FieldKind::Singular(SingularField { ref elem, .. })
            | FieldKind::Oneof(OneofField { ref elem, .. }) => {
                elem.rust_set_xxx_param_type(reference)
            }
            FieldKind::Repeated(..) | FieldKind::Map(..) => self.full_storage_type(reference),
        }
    }

    // for field `foo`, return type if `fn take_foo(..)`
    fn take_xxx_return_type(&self, reference: &FileAndMod) -> RustType {
        self.set_xxx_param_type(reference)
    }

    // for field `foo`, return type of `fn mut_foo(..)`
    fn mut_xxx_return_type(&self, reference: &FileAndMod) -> RustType {
        RustType::Ref(Box::new(match self.kind {
            FieldKind::Singular(SingularField { ref elem, .. })
            | FieldKind::Oneof(OneofField { ref elem, .. }) => {
                elem.rust_storage_elem_type(reference)
            }
            FieldKind::Repeated(..) | FieldKind::Map(..) => self.full_storage_type(reference),
        }))
    }

    // for field `foo`, return type of `fn foo(..)`
    fn getter_return_type(&self) -> RustType {
        let reference = self
            .proto_field
            .message
            .scope
            .file_and_mod(self.customize.clone());
        match &self.kind {
            FieldKind::Singular(s) => {
                SingularOrOneofField::Singular(s.clone()).getter_return_type(&reference)
            }
            FieldKind::Oneof(o) => {
                SingularOrOneofField::Oneof(o.clone()).getter_return_type(&reference)
            }
            FieldKind::Repeated(RepeatedField { ref elem, .. }) => RustType::Ref(Box::new(
                RustType::Slice(Box::new(elem.rust_storage_elem_type(&reference))),
            )),
            FieldKind::Map(..) => RustType::Ref(Box::new(self.full_storage_type(&reference))),
        }
    }

    // elem data is not stored in heap
    pub(crate) fn elem_type_is_copy(&self) -> bool {
        self.proto_type.is_copy()
    }

    fn defaut_value_from_proto_float(f: f64, type_name: &str) -> String {
        if f.is_nan() {
            format!("::std::{}::NAN", type_name)
        } else if f.is_infinite() {
            if f > 0.0 {
                format!("::std::{}::INFINITY", type_name)
            } else {
                format!("::std::{}::NEG_INFINITY", type_name)
            }
        } else {
            format!("{:?}{}", f, type_name)
        }
    }

    fn singular_or_oneof_default_value_from_proto(&self, elem: &FieldElem) -> Option<String> {
        if !self.proto_field.field.proto().has_default_value() {
            return None;
        }

        let default_value = self.proto_field.field.singular_default_value();
        Some(match default_value {
            ReflectValueRef::Bool(b) => format!("{}", b),
            ReflectValueRef::I32(v) => format!("{}i32", v),
            ReflectValueRef::I64(v) => format!("{}i64", v),
            ReflectValueRef::U32(v) => format!("{}u32", v),
            ReflectValueRef::U64(v) => format!("{}u64", v),
            ReflectValueRef::String(v) => quote_escape_str(v),
            ReflectValueRef::Bytes(v) => quote_escape_bytes(v),
            ReflectValueRef::F32(v) => Self::defaut_value_from_proto_float(v as f64, "f32"),
            ReflectValueRef::F64(v) => Self::defaut_value_from_proto_float(v as f64, "f64"),
            ReflectValueRef::Enum(_e, _v) => {
                if let &FieldElem::Enum(ref e) = elem {
                    format!("{}", e.default_value_rust_expr(&self.file_and_mod()))
                } else {
                    unreachable!()
                }
            }
            t => panic!("default value is not implemented for type: {:?}", t),
        })
    }

    fn default_value_from_proto(&self) -> Option<String> {
        match self.kind {
            FieldKind::Oneof(OneofField { ref elem, .. })
            | FieldKind::Singular(SingularField { ref elem, .. }) => {
                self.singular_or_oneof_default_value_from_proto(elem)
            }
            _ => unreachable!(),
        }
    }

    fn default_value_from_proto_typed(&self) -> Option<RustValueTyped> {
        self.default_value_from_proto().map(|v| {
            let default_value_type = match self.proto_type {
                field_descriptor_proto::Type::TYPE_STRING => RustType::Ref(Box::new(RustType::Str)),
                field_descriptor_proto::Type::TYPE_BYTES => {
                    RustType::Ref(Box::new(RustType::Slice(Box::new(RustType::u8()))))
                }
                _ => self.full_storage_iter_elem_type(
                    &self
                        .proto_field
                        .message
                        .scope
                        .file_and_mod(self.customize.clone()),
                ),
            };

            RustValueTyped {
                value: v,
                rust_type: default_value_type,
            }
        })
    }

    // default value to be returned from `fn xxx` for field `xxx`.
    fn xxx_default_value_rust(&self) -> String {
        match self.kind {
            FieldKind::Singular(..) | FieldKind::Oneof(..) => {
                self.default_value_from_proto().unwrap_or_else(|| {
                    self.getter_return_type()
                        .default_value(&self.customize, false)
                })
            }
            _ => unreachable!(),
        }
    }

    // default to be assigned to field
    fn element_default_value_rust(&self) -> RustValueTyped {
        match self.kind {
            FieldKind::Singular(..) | FieldKind::Oneof(..) => {
                self.default_value_from_proto_typed().unwrap_or_else(|| {
                    self.elem()
                        .rust_storage_elem_type(
                            &self
                                .proto_field
                                .message
                                .scope
                                .file_and_mod(self.customize.clone()),
                        )
                        .default_value_typed(&self.customize, false)
                })
            }
            _ => unreachable!(),
        }
    }

    pub(crate) fn reconstruct_def(&self) -> String {
        let prefix = match (self.proto_field.field.proto().label(), self.syntax) {
            (field_descriptor_proto::Label::LABEL_REPEATED, _) => "repeated ",
            (_, Syntax::Proto3) => "",
            (field_descriptor_proto::Label::LABEL_OPTIONAL, _) => "optional ",
            (field_descriptor_proto::Label::LABEL_REQUIRED, _) => "required ",
        };
        format!(
            "{}{} {} = {}",
            prefix,
            field_type_protobuf_name(self.proto_field.field.proto()),
            self.proto_field.name(),
            self.proto_field.number()
        )
    }

    pub(crate) fn write_clear(&self, w: &mut CodeWriter) {
        match self.kind {
            FieldKind::Oneof(ref o) => {
                w.write_line(&format!(
                    "self.{} = ::std::option::Option::None;",
                    o.oneof_field_name
                ));
            }
            _ => {
                let clear_expr = self
                    .full_storage_type(
                        &self
                            .proto_field
                            .message
                            .scope
                            .file_and_mod(self.customize.clone()),
                    )
                    .clear(&self.self_field(), &self.customize);
                w.write_line(&format!("{};", clear_expr));
            }
        }
    }

    // output code that writes single element to stream
    pub(crate) fn write_write_element(
        &self,
        elem: &FieldElem,
        w: &mut CodeWriter,
        os: &str,
        v: &RustValueTyped,
    ) {
        assert!(!self.is_repeated_packed());

        elem.write_write_element(
            self.proto_field.number() as u32,
            v,
            &self.file_and_mod(),
            &self.customize,
            os,
            w,
        );
    }

    fn self_field(&self) -> String {
        format!("self.{}", self.rust_name)
    }

    fn self_field_is_some(&self) -> String {
        assert!(self.is_singular());
        format!("{}.is_some()", self.self_field())
    }

    fn self_field_is_none(&self) -> String {
        assert!(self.is_singular());
        format!("{}.is_none()", self.self_field())
    }

    // field data viewed as Option
    fn self_field_as_option(&self, elem: &FieldElem, option_kind: OptionKind) -> RustValueTyped {
        match self.full_storage_type(
            &self
                .proto_field
                .message
                .scope
                .file_and_mod(self.customize.clone()),
        ) {
            RustType::Option(ref e) if e.is_copy() => {
                return RustType::Option(e.clone()).value(self.self_field());
            }
            _ => {}
        };

        let as_option_type = option_kind.as_ref_type(
            elem.rust_storage_elem_type(
                &self
                    .proto_field
                    .message
                    .scope
                    .file_and_mod(self.customize.clone()),
            ),
        );

        as_option_type.value(format!("{}.as_ref()", self.self_field()))
    }

    pub(crate) fn write_struct_field(&self, w: &mut CodeWriter) {
        if self.proto_type == field_descriptor_proto::Type::TYPE_GROUP {
            w.comment(&format!("{}: <group>", &self.rust_name));
        } else {
            w.all_documentation(self.info, &self.path);

            write_protoc_insertion_point_for_field(w, &self.customize, &self.proto_field.field);
            w.field_decl_vis(
                Visibility::Public,
                &self.rust_name.to_string(),
                &self
                    .full_storage_type(
                        &self
                            .proto_field
                            .message
                            .scope
                            .file_and_mod(self.customize.clone()),
                    )
                    .to_code(&self.customize),
            );
        }
    }

    fn write_if_let_self_field_is_some<F>(&self, s: &SingularField, w: &mut CodeWriter, cb: F)
    where
        F: Fn(&RustValueTyped, &mut CodeWriter),
    {
        match s {
            SingularField {
                flag: SingularFieldFlag::WithFlag { option_kind, .. },
                ref elem,
            } => {
                let var = "v";
                let ref_prefix = match elem
                    .rust_storage_elem_type(
                        &self
                            .proto_field
                            .message
                            .scope
                            .file_and_mod(self.customize.clone()),
                    )
                    .is_copy()
                {
                    true => "",
                    false => "",
                };
                let as_option = self.self_field_as_option(elem, *option_kind);
                w.if_let_stmt(
                    &format!("Some({}{})", ref_prefix, var),
                    &as_option.value,
                    |w| {
                        let v = RustValueTyped {
                            value: var.to_owned(),
                            rust_type: as_option.rust_type.elem_type(),
                        };
                        cb(&v, w);
                    },
                );
            }
            SingularField {
                flag: SingularFieldFlag::WithoutFlag,
                ref elem,
            } => match *elem {
                FieldElem::Primitive(field_descriptor_proto::Type::TYPE_STRING, ..)
                | FieldElem::Primitive(field_descriptor_proto::Type::TYPE_BYTES, ..) => {
                    w.if_stmt(format!("!{}.is_empty()", self.self_field()), |w| {
                        let v = RustValueTyped {
                            value: self.self_field(),
                            rust_type: self.full_storage_type(
                                &self
                                    .proto_field
                                    .message
                                    .scope
                                    .file_and_mod(self.customize.clone()),
                            ),
                        };
                        cb(&v, w);
                    });
                }
                _ => {
                    w.if_stmt(
                        format!(
                            "{} != {}",
                            self.self_field(),
                            self.full_storage_type(
                                &self
                                    .proto_field
                                    .message
                                    .scope
                                    .file_and_mod(self.customize.clone())
                            )
                            .default_value(&self.customize, false)
                        ),
                        |w| {
                            let v = RustValueTyped {
                                value: self.self_field(),
                                rust_type: self.full_storage_type(
                                    &self
                                        .proto_field
                                        .message
                                        .scope
                                        .file_and_mod(self.customize.clone()),
                                ),
                            };
                            cb(&v, w);
                        },
                    );
                }
            },
        }
    }

    pub(crate) fn write_if_self_field_is_none<F>(&self, w: &mut CodeWriter, cb: F)
    where
        F: Fn(&mut CodeWriter),
    {
        let self_field_is_none = self.self_field_is_none();
        w.if_stmt(self_field_is_none, cb)
    }

    // repeated or singular
    pub(crate) fn write_for_self_field<F>(&self, w: &mut CodeWriter, varn: &str, cb: F)
    where
        F: Fn(&mut CodeWriter, &RustType),
    {
        let file_and_mod = self
            .proto_field
            .message
            .scope
            .file_and_mod(self.customize.clone());

        match &self.kind {
            FieldKind::Oneof(oneof_field) => {
                let cond = format!(
                    "Some({}(ref {}))",
                    oneof_field.variant_path(&file_and_mod.relative_mod),
                    varn
                );
                w.if_let_stmt(
                    &cond,
                    &format!("self.{}", oneof_field.oneof_field_name),
                    |w| cb(w, &oneof_field.elem.rust_storage_elem_type(&file_and_mod)),
                )
            }
            _ => {
                let v_type = self.full_storage_iter_elem_type(&file_and_mod);
                let self_field = self.self_field();
                w.for_stmt(&format!("&{}", self_field), varn, |w| cb(w, &v_type));
            }
        }
    }

    fn write_self_field_assign(&self, w: &mut CodeWriter, value: &str) {
        let self_field = self.self_field();
        w.write_line(&format!("{} = {};", self_field, value));
    }

    fn write_self_field_assign_some(&self, w: &mut CodeWriter, s: &SingularField, value: &str) {
        match s {
            &SingularField {
                flag: SingularFieldFlag::WithFlag { option_kind, .. },
                ..
            } => {
                self.write_self_field_assign(w, &option_kind.wrap_value(value, &self.customize));
            }
            &SingularField {
                flag: SingularFieldFlag::WithoutFlag,
                ..
            } => {
                self.write_self_field_assign(w, value);
            }
        }
    }

    fn write_self_field_assign_value_singular(
        &self,
        w: &mut CodeWriter,
        s: &SingularField,
        value: &RustValueTyped,
    ) {
        let SingularField { ref elem, ref flag } = s;
        let converted = value.into_type(
            elem.rust_storage_elem_type(
                &self
                    .proto_field
                    .message
                    .scope
                    .file_and_mod(self.customize.clone()),
            )
            .clone(),
            &self.customize,
        );
        let wrapped = match flag {
            SingularFieldFlag::WithoutFlag => converted.value,
            SingularFieldFlag::WithFlag { option_kind, .. } => {
                option_kind.wrap_value(&converted.value, &self.customize)
            }
        };
        self.write_self_field_assign(w, &wrapped);
    }

    fn write_self_field_assign_value(&self, w: &mut CodeWriter, value: &RustValueTyped) {
        match self.kind {
            FieldKind::Repeated(..) | FieldKind::Map(..) => {
                let converted = value.into_type(
                    self.full_storage_type(
                        &self
                            .proto_field
                            .message
                            .scope
                            .file_and_mod(self.customize.clone()),
                    ),
                    &self.customize,
                );
                self.write_self_field_assign(w, &converted.value);
            }
            FieldKind::Singular(ref s) => {
                self.write_self_field_assign_value_singular(w, s, value);
            }
            FieldKind::Oneof(..) => unreachable!(),
        }
    }

    fn write_self_field_assign_default(
        &self,
        field_kind: &SingularOrOneofField,
        w: &mut CodeWriter,
    ) {
        match field_kind {
            SingularOrOneofField::Oneof(oneof) => {
                w.write_line(format!(
                    "self.{} = ::std::option::Option::Some({}({}))",
                    oneof.oneof_field_name,
                    oneof.variant_path(&self.proto_field.message.scope.rust_path_to_file()),
                    // TODO: default from .proto is not needed here (?)
                    self.element_default_value_rust()
                        .into_type(
                            self.full_storage_iter_elem_type(
                                &self
                                    .proto_field
                                    .message
                                    .scope
                                    .file_and_mod(self.customize.clone())
                            ),
                            &self.customize
                        )
                        .value
                ));
            }
            SingularOrOneofField::Singular(singular) => {
                // Note it is different from C++ protobuf, where field is initialized
                // with default value
                match singular.flag {
                    SingularFieldFlag::WithFlag { option_kind, .. } => match option_kind {
                        OptionKind::MessageField => {
                            let self_field = self.self_field();
                            w.write_line(&format!("{}.set_default();", self_field));
                        }
                        _ => {
                            self.write_self_field_assign_some(
                                w,
                                singular,
                                &self
                                    .elem()
                                    .rust_storage_elem_type(
                                        &self
                                            .proto_field
                                            .message
                                            .scope
                                            .file_and_mod(self.customize.clone()),
                                    )
                                    .default_value_typed(&self.customize, false)
                                    .into_type(
                                        singular.elem.rust_storage_elem_type(
                                            &self
                                                .proto_field
                                                .message
                                                .scope
                                                .file_and_mod(self.customize.clone()),
                                        ),
                                        &self.customize,
                                    )
                                    .value,
                            );
                        }
                    },
                    SingularFieldFlag::WithoutFlag => unimplemented!(),
                }
            }
        }
    }

    fn self_field_vec_packed_size(&self) -> String {
        let fn_name = match self.proto_type {
            Type::TYPE_ENUM => "vec_packed_enum_or_unknown_size",
            Type::TYPE_SINT32 => "vec_packed_sint32_size",
            Type::TYPE_SINT64 => "vec_packed_sint64_size",
            Type::TYPE_INT32 => "vec_packed_int32_size",
            Type::TYPE_INT64 => "vec_packed_int64_size",
            Type::TYPE_UINT32 => "vec_packed_uint32_size",
            Type::TYPE_UINT64 => "vec_packed_uint64_size",
            Type::TYPE_BOOL => "vec_packed_bool_size",
            Type::TYPE_FIXED32 => "vec_packed_fixed32_size",
            Type::TYPE_FIXED64 => "vec_packed_fixed64_size",
            Type::TYPE_SFIXED32 => "vec_packed_sfixed32_size",
            Type::TYPE_SFIXED64 => "vec_packed_sfixed64_size",
            Type::TYPE_FLOAT => "vec_packed_float_size",
            Type::TYPE_DOUBLE => "vec_packed_double_size",
            t => unreachable!("{:?}", t),
        };
        format!(
            "{}::rt::{fn_name}({}, &{})",
            protobuf_crate_path(&self.customize),
            self.proto_field.number(),
            self.self_field()
        )
    }

    pub(crate) fn clear_field_func(&self) -> String {
        format!("clear_{}", self.rust_name)
    }

    fn write_merge_from_field_message_string_bytes_repeated(
        &self,
        r: &RepeatedField,
        w: &mut CodeWriter,
    ) {
        let read_fn = match &r.elem {
            FieldElem::Message(..) => "read_message",
            FieldElem::Primitive(Type::TYPE_STRING, PrimitiveTypeVariant::Default) => "read_string",
            FieldElem::Primitive(Type::TYPE_STRING, PrimitiveTypeVariant::TokioBytes) => {
                "read_tokio_chars"
            }
            FieldElem::Primitive(Type::TYPE_BYTES, PrimitiveTypeVariant::Default) => "read_bytes",
            FieldElem::Primitive(Type::TYPE_BYTES, PrimitiveTypeVariant::TokioBytes) => {
                "read_tokio_bytes"
            }
            _ => unreachable!("for field {}", self.proto_field.field),
        };
        w.write_line(&format!("self.{}.push(is.{}()?);", self.rust_name, read_fn,));
    }

    fn tag_with_wire_type(&self, wire_type: WireType) -> u32 {
        make_tag(self.proto_field.number() as u32, wire_type)
    }

    fn tag(&self) -> u32 {
        self.tag_with_wire_type(self.wire_type)
    }

    // Write `merge_from` part for this oneof field
    fn write_merge_from_oneof_case_block(&self, o: &OneofField, w: &mut CodeWriter) {
        w.case_block(&format!("{}", self.tag()), |w| {
            let typed = RustValueTyped {
                value: format!(
                    "{}?",
                    self.proto_type.read("is", o.elem.primitive_type_variant())
                ),
                rust_type: self.full_storage_iter_elem_type(
                    &self
                        .proto_field
                        .message
                        .scope
                        .file_and_mod(self.customize.clone()),
                ),
            };

            let maybe_boxed = if o.boxed {
                typed.boxed(&self.customize)
            } else {
                typed
            };

            w.write_line(&format!(
                "self.{} = ::std::option::Option::Some({}({}));",
                o.oneof_field_name,
                o.variant_path(&self.proto_field.message.scope.rust_path_to_file()),
                maybe_boxed.value
            ));
        })
    }

    // Write `merge_from` part for this map field
    fn write_merge_from_map_case_block(&self, map: &MapField, w: &mut CodeWriter) {
        let MapField { key, value, .. } = map;
        w.case_block(&format!("{}", self.tag()), |w| {
            w.write_line(&format!("let len = is.read_raw_varint32()?;",));
            w.write_line(&format!("let old_limit = is.push_limit(len as u64)?;"));
            w.write_line(&format!(
                "let mut key = ::std::default::Default::default();"
            ));
            w.write_line(&format!(
                "let mut value = ::std::default::Default::default();"
            ));
            w.while_block("let Some(tag) = is.read_raw_tag_or_eof()?", |w| {
                w.match_block("tag", |w| {
                    let key_tag = make_tag(1, WireType::for_type(key.proto_type()));
                    let value_tag = make_tag(2, WireType::for_type(value.proto_type()));
                    w.case_expr(
                        &format!("{key_tag}"),
                        &format!("key = {read}", read = key.read_one_liner()),
                    );
                    w.case_expr(
                        &format!("{value_tag}"),
                        &format!("value = {read}", read = value.read_one_liner()),
                    );
                    w.case_expr(
                        "_",
                        &format!(
                            "{protobuf_crate}::rt::skip_field_for_tag(tag, is)?",
                            protobuf_crate = protobuf_crate_path(&self.customize)
                        ),
                    );
                });
            });
            w.write_line(&format!("is.pop_limit(old_limit);"));
            w.write_line(&format!(
                "{field}.insert(key, value);",
                field = self.self_field()
            ));
        });
    }

    // Write `merge_from` part for this singular field
    fn write_merge_from_singular_case_block(&self, s: &SingularField, w: &mut CodeWriter) {
        w.case_block(&format!("{}", self.tag()), |w| match s.elem {
            FieldElem::Message(..) => {
                w.write_line(&format!(
                    "{}::rt::read_singular_message_into_field(is, &mut self.{})?;",
                    protobuf_crate_path(&self.customize),
                    self.rust_name,
                ));
            }
            _ => {
                let read_proc = s.elem.read_one_liner();
                self.write_self_field_assign_some(w, s, &read_proc);
            }
        })
    }

    // Write `merge_from` part for this repeated field
    fn write_merge_from_repeated_case_block(&self, w: &mut CodeWriter) {
        let field = match self.kind {
            FieldKind::Repeated(ref field) => field,
            _ => panic!(),
        };

        match field.elem {
            FieldElem::Message(..)
            | FieldElem::Primitive(field_descriptor_proto::Type::TYPE_STRING, ..)
            | FieldElem::Primitive(field_descriptor_proto::Type::TYPE_BYTES, ..) => {
                w.case_block(&format!("{}", self.tag()), |w| {
                    self.write_merge_from_field_message_string_bytes_repeated(field, w);
                })
            }
            FieldElem::Enum(..) => {
                w.case_block(
                    &format!("{}", self.tag_with_wire_type(WireType::Varint)),
                    |w| {
                        w.write_line(&format!(
                            "self.{}.push(is.read_enum_or_unknown()?);",
                            self.rust_name,
                        ));
                    },
                );
                w.case_block(
                    &format!("{}", self.tag_with_wire_type(WireType::LengthDelimited)),
                    |w| {
                        w.write_line(&format!(
                            "{}::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.{})?",
                            protobuf_crate_path(&self.customize),
                            self.rust_name,
                        ));
                    },
                );
            }
            _ => {
                assert_ne!(self.wire_type, WireType::LengthDelimited);
                w.case_block(
                    &format!("{}", self.tag_with_wire_type(WireType::LengthDelimited)),
                    |w| {
                        w.write_line(&format!(
                            "is.read_repeated_packed_{}_into(&mut self.{})?;",
                            self.proto_type.protobuf_name(),
                            self.rust_name
                        ));
                    },
                );
                w.case_block(&format!("{}", self.tag()), |w| {
                    w.write_line(&format!(
                        "self.{}.push(is.read_{}()?);",
                        self.rust_name,
                        self.proto_type.protobuf_name(),
                    ));
                });
            }
        }
    }

    /// Write `merge_from` part for this field
    pub(crate) fn write_merge_from_field_case_block(&self, w: &mut CodeWriter) {
        match &self.kind {
            FieldKind::Oneof(oneof) => self.write_merge_from_oneof_case_block(oneof, w),
            FieldKind::Map(map) => self.write_merge_from_map_case_block(map, w),
            FieldKind::Singular(ref s) => self.write_merge_from_singular_case_block(s, w),
            FieldKind::Repeated(..) => self.write_merge_from_repeated_case_block(w),
        }
    }

    pub(crate) fn write_element_size(
        &self,
        elem: &FieldElem,
        w: &mut CodeWriter,
        item_var: &RustValueTyped,
        sum_var: &str,
    ) {
        assert!(!self.is_repeated_packed());

        elem.write_element_size(
            self.proto_field.number() as u32,
            item_var,
            HowToGetMessageSize::Compute,
            sum_var,
            &self.customize,
            w,
        );
    }

    fn write_write_map_field(
        &self,
        key: &FieldElem,
        value: &FieldElem,
        os: &str,
        w: &mut CodeWriter,
    ) {
        self.for_each_map_entry(key, value, w, |k, v, w| {
            w.write_line("let mut entry_size = 0;");
            key.write_element_size(
                1,
                k,
                HowToGetMessageSize::GetCached,
                "entry_size",
                &self.customize,
                w,
            );
            value.write_element_size(
                2,
                v,
                HowToGetMessageSize::GetCached,
                "entry_size",
                &self.customize,
                w,
            );
            w.write_line(&format!(
                "{os}.write_raw_varint32({tag})?; // Tag.",
                tag = make_tag(self.proto_field.number() as u32, WireType::LengthDelimited),
            ));
            w.write_line(&format!("{os}.write_raw_varint32(entry_size as u32)?;",));
            key.write_write_element(1, k, &self.file_and_mod(), &self.customize, os, w);
            value.write_write_element(2, v, &self.file_and_mod(), &self.customize, os, w);
        });
    }

    pub(crate) fn write_message_write_field(&self, os: &str, w: &mut CodeWriter) {
        match &self.kind {
            FieldKind::Singular(s @ SingularField { elem, .. }) => {
                self.write_if_let_self_field_is_some(s, w, |v, w| {
                    self.write_write_element(&elem, w, os, &v);
                });
            }
            FieldKind::Repeated(RepeatedField {
                packed: false,
                elem,
                ..
            }) => {
                self.write_for_self_field(w, "v", |w, v_type| {
                    let v = RustValueTyped {
                        value: "v".to_owned(),
                        rust_type: v_type.clone(),
                    };
                    self.write_write_element(elem, w, "os", &v);
                });
            }
            FieldKind::Repeated(RepeatedField { packed: true, .. }) => {
                w.write_line(&format!(
                    "os.write_repeated_packed_{}({}, &{})?;",
                    self.os_write_fn_suffix_with_unknown_for_enum(),
                    self.proto_field.number(),
                    self.self_field()
                ));
            }
            FieldKind::Map(MapField { key, value, .. }) => {
                self.write_write_map_field(key, value, os, w)
            }
            FieldKind::Oneof(..) => unreachable!(),
        };
    }

    fn for_each_map_entry(
        &self,
        key: &FieldElem,
        value: &FieldElem,
        w: &mut CodeWriter,
        cb: impl FnOnce(&RustValueTyped, &RustValueTyped, &mut CodeWriter),
    ) {
        w.for_stmt(&format!("&{}", self.self_field()), "(k, v)", move |w| {
            let k = RustValueTyped {
                value: "k".to_owned(),
                rust_type: key.rust_storage_elem_type(&self.file_and_mod()).wrap_ref(),
            };
            let v = RustValueTyped {
                value: "v".to_owned(),
                rust_type: value
                    .rust_storage_elem_type(&self.file_and_mod())
                    .wrap_ref(),
            };
            cb(&k, &v, w)
        });
    }

    fn write_compute_map_field_size(
        &self,
        sum_var: &str,
        key: &FieldElem<'a>,
        value: &FieldElem<'a>,
        w: &mut CodeWriter,
    ) {
        self.for_each_map_entry(key, value, w, |k, v, w| {
                w.write_line("let mut entry_size = 0;");
                key.write_element_size(1, k, HowToGetMessageSize::Compute, "entry_size", &self.customize, w);
                value.write_element_size(2, v, HowToGetMessageSize::Compute, "entry_size", &self.customize, w);
                w.write_line(&format!("{sum_var} += {tag_size} + {protobuf_crate}::rt::compute_raw_varint64_size(entry_size) + entry_size",
                    tag_size = self.tag_size(),
                    protobuf_crate = protobuf_crate_path(&self.customize),
                ));
        });
    }

    pub(crate) fn write_message_compute_field_size(&self, sum_var: &str, w: &mut CodeWriter) {
        match &self.kind {
            FieldKind::Singular(s @ SingularField { elem, .. }) => {
                self.write_if_let_self_field_is_some(s, w, |v, w| {
                    self.write_element_size(&elem, w, v, sum_var)
                });
            }
            FieldKind::Repeated(RepeatedField {
                packed: false,
                elem,
                ..
            }) => {
                match elem.proto_type().encoded_size() {
                    Some(s) => {
                        let tag_size = self.tag_size();
                        let self_field = self.self_field();
                        w.write_line(&format!(
                            "{} += {} * {}.len() as u64;",
                            sum_var,
                            (s + tag_size) as isize,
                            self_field
                        ));
                    }
                    None => {
                        self.write_for_self_field(w, "value", |w, value_type| {
                            self.write_element_size(
                                elem,
                                w,
                                &RustValueTyped {
                                    value: "value".to_owned(),
                                    rust_type: value_type.clone(),
                                },
                                sum_var,
                            );
                        });
                    }
                };
            }
            FieldKind::Repeated(RepeatedField { packed: true, .. }) => {
                let size_expr = self.self_field_vec_packed_size();
                w.write_line(&format!("{} += {};", sum_var, size_expr));
            }
            FieldKind::Map(MapField { key, value, .. }) => {
                self.write_compute_map_field_size(sum_var, key, value, w)
            }
            FieldKind::Oneof(..) => unreachable!(),
        }
    }

    fn write_message_field_get_singular_message(&self, s: &SingularField, w: &mut CodeWriter) {
        match s.flag {
            SingularFieldFlag::WithoutFlag => unimplemented!(),
            SingularFieldFlag::WithFlag { option_kind, .. } => {
                let self_field = self.self_field();
                let ref field_type_name = self.elem().rust_storage_elem_type(
                    &self
                        .proto_field
                        .message
                        .scope
                        .file_and_mod(self.customize.clone()),
                );
                w.write_line(option_kind.unwrap_ref_or_else(
                    &format!("{}.as_ref()", self_field),
                    &format!(
                        "<{} as {}::Message>::default_instance()",
                        field_type_name.to_code(&self.customize),
                        protobuf_crate_path(&self.customize),
                    ),
                ));
            }
        }
    }

    fn write_message_field_get_singular_enum(
        &self,
        flag: SingularFieldFlag,
        _elem: &FieldElemEnum,
        w: &mut CodeWriter,
    ) {
        match flag {
            SingularFieldFlag::WithoutFlag => {
                w.write_line(&format!("self.{}.enum_value_or_default()", self.rust_name));
            }
            SingularFieldFlag::WithFlag { .. } => {
                w.match_expr(&self.self_field(), |w| {
                    let default_value = self.xxx_default_value_rust();
                    w.case_expr("Some(e)", &format!("e.enum_value_or({})", default_value));
                    w.case_expr("None", &format!("{}", default_value));
                });
            }
        }
    }

    fn write_message_field_get_singular(&self, singular: &SingularField, w: &mut CodeWriter) {
        let get_xxx_return_type = self.getter_return_type();

        match singular.elem {
            FieldElem::Message(..) => self.write_message_field_get_singular_message(singular, w),
            FieldElem::Enum(ref en) => {
                self.write_message_field_get_singular_enum(singular.flag, en, w)
            }
            _ => {
                let get_xxx_default_value_rust = self.xxx_default_value_rust();
                let self_field = self.self_field();
                match singular {
                    &SingularField {
                        ref elem,
                        flag: SingularFieldFlag::WithFlag { option_kind, .. },
                        ..
                    } => {
                        if get_xxx_return_type.is_ref().is_some() {
                            let as_option = self.self_field_as_option(elem, option_kind);
                            w.match_expr(&as_option.value, |w| {
                                let v_type = as_option.rust_type.elem_type();
                                let r_type = self.getter_return_type();
                                w.case_expr(
                                    "Some(v)",
                                    v_type.into_target(&r_type, "v", &self.customize),
                                );
                                let get_xxx_default_value_rust = self.xxx_default_value_rust();
                                w.case_expr("None", get_xxx_default_value_rust);
                            });
                        } else {
                            w.write_line(&format!(
                                "{}.unwrap_or({})",
                                self_field, get_xxx_default_value_rust
                            ));
                        }
                    }
                    &SingularField {
                        flag: SingularFieldFlag::WithoutFlag,
                        ..
                    } => {
                        w.write_line(
                            self.full_storage_type(
                                &self
                                    .proto_field
                                    .message
                                    .scope
                                    .file_and_mod(self.customize.clone()),
                            )
                            .into_target(
                                &get_xxx_return_type,
                                &self_field,
                                &self.customize,
                            ),
                        );
                    }
                }
            }
        }
    }

    fn write_message_field_get_oneof(&self, o: &OneofField, w: &mut CodeWriter) {
        let get_xxx_return_type = SingularOrOneofField::Oneof(o.clone()).getter_return_type(
            &self
                .proto_field
                .message
                .scope
                .file_and_mod(self.customize.clone()),
        );
        let OneofField { ref elem, .. } = o;
        w.match_expr(&format!("self.{}", o.oneof_field_name), |w| {
            let (refv, vtype) = if !elem.is_copy() {
                (
                    "ref v",
                    elem.rust_storage_elem_type(
                        &self
                            .proto_field
                            .message
                            .scope
                            .file_and_mod(self.customize.clone()),
                    )
                    .ref_type(),
                )
            } else {
                (
                    "v",
                    elem.rust_storage_elem_type(
                        &self
                            .proto_field
                            .message
                            .scope
                            .file_and_mod(self.customize.clone()),
                    ),
                )
            };
            w.case_expr(
                format!(
                    "::std::option::Option::Some({}({}))",
                    o.variant_path(&self.proto_field.message.scope.rust_path_to_file()),
                    refv
                ),
                vtype.into_target(&get_xxx_return_type, "v", &self.customize),
            );
            w.case_expr("_", self.xxx_default_value_rust());
        });
    }

    fn write_message_field_get(&self, w: &mut CodeWriter) {
        let get_xxx_return_type = self.getter_return_type();
        let fn_def = format!(
            "{}(&self) -> {}",
            self.rust_name,
            get_xxx_return_type.to_code(&self.customize)
        );

        w.pub_fn(&fn_def, |w| match self.kind {
            FieldKind::Oneof(ref o) => {
                self.write_message_field_get_oneof(o, w);
            }
            FieldKind::Singular(ref s) => {
                self.write_message_field_get_singular(s, w);
            }
            FieldKind::Repeated(..) | FieldKind::Map(..) => {
                let self_field = self.self_field();
                w.write_line(&format!("&{}", self_field));
            }
        });
    }

    fn has_has(&self) -> bool {
        match self.kind {
            FieldKind::Repeated(..) | FieldKind::Map(..) => false,
            FieldKind::Singular(SingularField {
                flag: SingularFieldFlag::WithFlag { .. },
                ..
            }) => true,
            FieldKind::Singular(SingularField {
                flag: SingularFieldFlag::WithoutFlag,
                ..
            }) => false,
            FieldKind::Oneof(..) => true,
        }
    }

    fn has_mut(&self) -> bool {
        match self.kind {
            FieldKind::Repeated(..) | FieldKind::Map(..) => true,
            // TODO: string should be public, and mut is not needed
            FieldKind::Singular(..) | FieldKind::Oneof(..) => !self.elem_type_is_copy(),
        }
    }

    fn has_take(&self) -> bool {
        match self.kind {
            FieldKind::Repeated(..) | FieldKind::Map(..) => true,
            // TODO: string should be public, and mut is not needed
            FieldKind::Singular(..) | FieldKind::Oneof(..) => !self.elem_type_is_copy(),
        }
    }

    fn has_name(&self) -> RustIdent {
        RustIdent::new(&format!("has_{}", self.rust_name.get()))
    }

    fn set_name(&self) -> RustIdent {
        RustIdent::new(&format!("set_{}", self.rust_name.get()))
    }

    fn mut_name(&self) -> RustIdent {
        RustIdent::new(&format!("mut_{}", self.rust_name.get()))
    }

    fn write_message_field_has(&self, w: &mut CodeWriter) {
        w.pub_fn(
            &format!("{}(&self) -> bool", self.has_name()),
            |w| match self.kind {
                FieldKind::Oneof(ref oneof) => {
                    w.match_expr(&format!("self.{}", oneof.oneof_field_name), |w| {
                        w.case_expr(
                            format!(
                                "::std::option::Option::Some({}(..))",
                                oneof.variant_path(
                                    &self.proto_field.message.scope.rust_path_to_file()
                                )
                            ),
                            "true",
                        );
                        w.case_expr("_", "false");
                    });
                }
                _ => {
                    let self_field_is_some = self.self_field_is_some();
                    w.write_line(self_field_is_some);
                }
            },
        );
    }

    fn write_message_field_set(&self, w: &mut CodeWriter) {
        let set_xxx_param_type = self.set_xxx_param_type(
            &self
                .proto_field
                .message
                .scope
                .file_and_mod(self.customize.clone()),
        );
        w.comment("Param is passed by value, moved");
        w.pub_fn(
            &format!(
                "{}(&mut self, v: {})",
                self.set_name(),
                set_xxx_param_type.to_code(&self.customize)
            ),
            |w| {
                let value_typed = RustValueTyped {
                    value: "v".to_owned(),
                    rust_type: set_xxx_param_type.clone(),
                };
                match self.kind {
                    FieldKind::Oneof(ref oneof) => {
                        let v = set_xxx_param_type.into_target(
                            &oneof.rust_type(
                                &self
                                    .proto_field
                                    .message
                                    .scope
                                    .file_and_mod(self.customize.clone()),
                            ),
                            "v",
                            &self.customize,
                        );
                        w.write_line(&format!(
                            "self.{} = ::std::option::Option::Some({}({}))",
                            oneof.oneof_field_name,
                            oneof.variant_path(&self.proto_field.message.scope.rust_path_to_file()),
                            v
                        ));
                    }
                    _ => {
                        self.write_self_field_assign_value(w, &value_typed);
                    }
                }
            },
        );
    }

    fn write_message_field_mut_singular_with_flag(
        &self,
        s: &SingularField,
        option_kind: OptionKind,
        w: &mut CodeWriter,
    ) {
        let self_field = self.self_field();
        match option_kind {
            OptionKind::MessageField => {
                w.write_line(&format!("{}.mut_or_insert_default()", self_field))
            }
            OptionKind::Option => {
                self.write_if_self_field_is_none(w, |w| {
                    self.write_self_field_assign_default(
                        &SingularOrOneofField::Singular(s.clone()),
                        w,
                    );
                });
                w.write_line(&format!("{}.as_mut().unwrap()", self_field));
            }
        }
    }

    fn write_message_field_mut_singular(&self, s: &SingularField, w: &mut CodeWriter) {
        match s {
            s @ SingularField {
                flag: SingularFieldFlag::WithFlag { option_kind, .. },
                ..
            } => self.write_message_field_mut_singular_with_flag(s, *option_kind, w),
            SingularField {
                flag: SingularFieldFlag::WithoutFlag,
                ..
            } => w.write_line(&format!("&mut {}", self.self_field())),
        }
    }

    fn write_message_field_mut(&self, w: &mut CodeWriter) {
        let mut_xxx_return_type = self.mut_xxx_return_type(
            &self
                .proto_field
                .message
                .scope
                .file_and_mod(self.customize.clone()),
        );
        w.comment("Mutable pointer to the field.");
        if self.is_singular() {
            w.comment("If field is not initialized, it is initialized with default value first.");
        }
        let fn_def = match mut_xxx_return_type {
            RustType::Ref(ref param) => format!(
                "{}(&mut self) -> &mut {}",
                self.mut_name(),
                param.to_code(&self.customize)
            ),
            _ => panic!(
                "not a ref: {}",
                mut_xxx_return_type.to_code(&self.customize)
            ),
        };
        w.pub_fn(&fn_def, |w| {
            match self.kind {
                FieldKind::Repeated(..) | FieldKind::Map(..) => {
                    let self_field = self.self_field();
                    w.write_line(&format!("&mut {}", self_field));
                }
                FieldKind::Singular(ref s) => {
                    self.write_message_field_mut_singular(s, w);
                }
                FieldKind::Oneof(ref o) => {
                    let self_field_oneof = format!("self.{}", o.oneof_field_name);

                    // if oneof does not contain current field
                    w.if_let_else_stmt(
                        &format!(
                            "::std::option::Option::Some({}(_))",
                            o.variant_path(&self.proto_field.message.scope.rust_path_to_file())
                        )[..],
                        &self_field_oneof[..],
                        |w| {
                            // initialize it with default value
                            w.write_line(&format!(
                                "{} = ::std::option::Option::Some({}({}));",
                                self_field_oneof,
                                o.variant_path(&self.proto_field.message.scope.rust_path_to_file()),
                                self.element_default_value_rust()
                                    .into_type(
                                        o.rust_type(
                                            &self
                                                .proto_field
                                                .message
                                                .scope
                                                .file_and_mod(self.customize.clone())
                                        ),
                                        &self.customize
                                    )
                                    .value
                            ));
                        },
                    );

                    // extract field
                    w.match_expr(self_field_oneof, |w| {
                        w.case_expr(
                            format!(
                                "::std::option::Option::Some({}(ref mut v))",
                                o.variant_path(&self.proto_field.message.scope.rust_path_to_file())
                            ),
                            "v",
                        );
                        w.case_expr("_", "panic!()");
                    });
                }
            }
        });
    }

    fn write_message_field_take_oneof(&self, o: &OneofField, w: &mut CodeWriter) {
        let take_xxx_return_type = self.take_xxx_return_type(
            &self
                .proto_field
                .message
                .scope
                .file_and_mod(self.customize.clone()),
        );

        // TODO: replace with if let
        w.write_line(&format!("if self.{}() {{", self.has_name()));
        w.indented(|w| {
            let self_field_oneof = format!("self.{}", o.oneof_field_name);
            w.match_expr(format!("{}.take()", self_field_oneof), |w| {
                let value_in_some = o
                    .rust_type(
                        &self
                            .proto_field
                            .message
                            .scope
                            .file_and_mod(self.customize.clone()),
                    )
                    .value("v".to_owned());
                let converted = value_in_some.into_type(
                    self.take_xxx_return_type(
                        &self
                            .proto_field
                            .message
                            .scope
                            .file_and_mod(self.customize.clone()),
                    ),
                    &self.customize,
                );
                w.case_expr(
                    format!(
                        "::std::option::Option::Some({}(v))",
                        o.variant_path(&self.proto_field.message.scope.rust_path_to_file())
                    ),
                    &converted.value,
                );
                w.case_expr("_", "panic!()");
            });
        });
        w.write_line("} else {");
        w.indented(|w| {
            w.write_line(
                self.elem()
                    .rust_storage_elem_type(
                        &self
                            .proto_field
                            .message
                            .scope
                            .file_and_mod(self.customize.clone()),
                    )
                    .default_value_typed(&self.customize, false)
                    .into_type(take_xxx_return_type.clone(), &self.customize)
                    .value,
            );
        });
        w.write_line("}");
    }

    fn write_message_field_take_singular(&self, s: &SingularField, w: &mut CodeWriter) {
        match s {
            SingularField {
                ref elem,
                flag: SingularFieldFlag::WithFlag { option_kind, .. },
            } => {
                if !elem.is_copy() {
                    w.write_line(
                        &option_kind.unwrap_or_else(
                            &format!("{}.take()", self.self_field()),
                            &elem
                                .rust_storage_elem_type(
                                    &self
                                        .proto_field
                                        .message
                                        .scope
                                        .file_and_mod(self.customize.clone()),
                                )
                                .default_value(&self.customize, false),
                        ),
                    );
                } else {
                    w.write_line(&format!(
                        "{}.take().unwrap_or({})",
                        self.self_field(),
                        self.element_default_value_rust().value
                    ));
                }
            }
            SingularField {
                flag: SingularFieldFlag::WithoutFlag,
                ..
            } => w.write_line(&format!(
                "::std::mem::replace(&mut {}, {})",
                self.self_field(),
                self.full_storage_type(
                    &self
                        .proto_field
                        .message
                        .scope
                        .file_and_mod(self.customize.clone())
                )
                .default_value(&self.customize, false)
            )),
        }
    }

    fn write_message_field_take(&self, w: &mut CodeWriter) {
        let take_xxx_return_type = self.take_xxx_return_type(
            &self
                .proto_field
                .message
                .scope
                .file_and_mod(self.customize.clone()),
        );
        w.comment("Take field");
        w.pub_fn(
            &format!(
                "take_{}(&mut self) -> {}",
                self.rust_name,
                take_xxx_return_type.to_code(&self.customize)
            ),
            |w| match self.kind {
                FieldKind::Singular(ref s) => self.write_message_field_take_singular(&s, w),
                FieldKind::Oneof(ref o) => self.write_message_field_take_oneof(o, w),
                FieldKind::Repeated(..) | FieldKind::Map(..) => {
                    w.write_line(&format!(
                        "::std::mem::replace(&mut self.{}, {})",
                        self.rust_name,
                        take_xxx_return_type.default_value(&self.customize, false)
                    ));
                }
            },
        );
    }

    pub(crate) fn write_message_single_field_accessors(&self, w: &mut CodeWriter) {
        if self.generate_accessors || self.generate_getter {
            w.write_line("");
            let reconstruct_def = self.reconstruct_def();
            w.comment(&(reconstruct_def + ";"));
        }

        if self.generate_getter {
            w.write_line("");
            self.write_message_field_get(w);
        }

        if !self.generate_accessors {
            return;
        }

        w.write_line("");
        let clear_field_func = self.clear_field_func();
        w.pub_fn(&format!("{}(&mut self)", clear_field_func), |w| {
            self.write_clear(w);
        });

        if self.has_has() {
            w.write_line("");
            self.write_message_field_has(w);
        }

        w.write_line("");
        self.write_message_field_set(w);

        if self.has_mut() {
            w.write_line("");
            self.write_message_field_mut(w);
        }

        if self.has_take() {
            w.write_line("");
            self.write_message_field_take(w);
        }
    }
}

pub(crate) fn rust_field_name_for_protobuf_field_name(name: &str) -> RustIdent {
    RustIdent::new(name)
}

pub(crate) fn rust_variant_name_for_protobuf_oneof_field_name(name: &str) -> RustIdent {
    let name = camel_case(name);
    RustIdent::new(&name)
}

'''
'''--- protobuf-codegen/src/gen/field/option_kind.rs ---
use crate::gen::inside::protobuf_crate_path;
use crate::gen::rust_types_values::RustType;
use crate::Customize;

/// Optional fields can be stored are `Option<T>` or `SingularPtrField<T>`.
#[derive(Copy, Clone, Eq, PartialEq)]
pub enum OptionKind {
    /// Field is `Option<T>`
    Option,
    /// Field is `SingularPtrField<T>`
    MessageField,
}

impl OptionKind {
    pub(crate) fn wrap_element(&self, element_type: RustType) -> RustType {
        let element_type = Box::new(element_type);
        match self {
            OptionKind::Option => RustType::Option(element_type),
            OptionKind::MessageField => RustType::MessageField(element_type),
        }
    }

    // Type of `as_ref()` operation
    pub(crate) fn as_ref_type(&self, element_type: RustType) -> RustType {
        match self {
            OptionKind::Option => RustType::Option(Box::new(element_type.ref_type())),
            OptionKind::MessageField => RustType::MessageField(Box::new(element_type.ref_type())),
        }
    }

    fn _as_option_ref(&self, v: &str) -> String {
        match self {
            OptionKind::Option | OptionKind::MessageField => format!("{}.as_ref()", v),
        }
    }

    pub(crate) fn unwrap_or_else(&self, what: &str, default_value: &str) -> String {
        match self {
            _ => format!("{}.unwrap_or_else(|| {})", what, default_value),
        }
    }

    pub(crate) fn unwrap_ref_or_else(&self, what: &str, default_value: &str) -> String {
        match self {
            _ => format!("{}.unwrap_or_else(|| {})", what, default_value),
        }
    }

    pub(crate) fn wrap_value(&self, value: &str, customize: &Customize) -> String {
        match self {
            OptionKind::Option => format!("::std::option::Option::Some({})", value),
            OptionKind::MessageField => format!(
                "{}::MessageField::some({})",
                protobuf_crate_path(customize),
                value
            ),
        }
    }
}

'''
'''--- protobuf-codegen/src/gen/field/repeated.rs ---
use crate::gen::field::elem::FieldElem;
use crate::gen::file_and_mod::FileAndMod;
use crate::gen::rust::snippets::EXPR_VEC_NEW;
use crate::gen::rust_types_values::RustType;

/// Repeated field can be `Vec<T>` or `RepeatedField<T>`.
#[derive(Eq, PartialEq, Copy, Clone)]
pub enum RepeatedFieldKind {
    Vec,
}

impl RepeatedFieldKind {
    fn wrap_element(&self, element_type: RustType) -> RustType {
        let element_type = Box::new(element_type);
        match self {
            RepeatedFieldKind::Vec => RustType::Vec(element_type),
        }
    }

    fn default(&self) -> String {
        match self {
            RepeatedFieldKind::Vec => EXPR_VEC_NEW.to_owned(),
        }
    }
}

#[derive(Clone)]
pub(crate) struct RepeatedField<'a> {
    pub elem: FieldElem<'a>,
    pub packed: bool,
}

impl<'a> RepeatedField<'a> {
    pub(crate) fn kind(&self) -> RepeatedFieldKind {
        RepeatedFieldKind::Vec
    }

    pub(crate) fn rust_type(&self, reference: &FileAndMod) -> RustType {
        self.kind()
            .wrap_element(self.elem.rust_storage_elem_type(reference))
    }

    pub(crate) fn default(&self) -> String {
        self.kind().default()
    }
}

'''
'''--- protobuf-codegen/src/gen/field/singular.rs ---
use crate::gen::field::elem::FieldElem;
use crate::gen::field::option_kind::OptionKind;
use crate::gen::file_and_mod::FileAndMod;
use crate::gen::rust_types_values::RustType;
use crate::Customize;

#[derive(Clone, PartialEq, Eq, Copy)]
pub enum SingularFieldFlag {
    // proto2 or proto3 message
    WithFlag {
        required: bool,
        option_kind: OptionKind,
    },
    // proto3
    WithoutFlag,
}

impl SingularFieldFlag {
    pub fn is_required(&self) -> bool {
        match *self {
            SingularFieldFlag::WithFlag { required, .. } => required,
            SingularFieldFlag::WithoutFlag => false,
        }
    }
}

#[derive(Clone)]
pub(crate) struct SingularField<'a> {
    pub flag: SingularFieldFlag,
    pub elem: FieldElem<'a>,
}

impl<'a> SingularField<'a> {
    pub(crate) fn rust_storage_type(&self, reference: &FileAndMod) -> RustType {
        match self.flag {
            SingularFieldFlag::WithFlag { option_kind, .. } => {
                option_kind.wrap_element(self.elem.rust_storage_elem_type(reference))
            }
            SingularFieldFlag::WithoutFlag => self.elem.rust_storage_elem_type(reference),
        }
    }

    pub(crate) fn default_value(
        &self,
        customize: &Customize,
        reference: &FileAndMod,
        const_expr: bool,
    ) -> String {
        self.rust_storage_type(reference)
            .default_value(customize, const_expr)
    }
}

'''
'''--- protobuf-codegen/src/gen/field/tag.rs ---
use protobuf::rt::WireType;

pub(crate) fn make_tag(field_number: u32, wire_type: WireType) -> u32 {
    (field_number << 3) | (wire_type as u32)
}

'''
'''--- protobuf-codegen/src/gen/field/type_ext.rs ---
use protobuf::descriptor::field_descriptor_proto::Type;

use crate::gen::rust_types_values::PrimitiveTypeVariant;
use crate::gen::rust_types_values::RustType;

pub(crate) trait TypeExt {
    fn read(&self, is: &str, primitive_type_variant: PrimitiveTypeVariant) -> String;
    fn is_s_varint(&self) -> bool;
    fn is_copy(&self) -> bool;
    fn protobuf_name(&self) -> &'static str;
    fn rust_type(&self) -> RustType;
    fn os_write_fn_param_type(&self) -> RustType;
    fn encoded_size(&self) -> Option<u32>;
}

impl TypeExt for Type {
    fn read(&self, is: &str, primitive_type_variant: PrimitiveTypeVariant) -> String {
        match (self, primitive_type_variant) {
            (Type::TYPE_ENUM, _) => format!("{}.read_enum_or_unknown()", is),
            (Type::TYPE_BYTES, PrimitiveTypeVariant::TokioBytes) => {
                format!("{}.read_tokio_bytes()", is)
            }
            (Type::TYPE_STRING, PrimitiveTypeVariant::TokioBytes) => {
                format!("{}.read_tokio_chars()", is)
            }
            _ => format!("{}.read_{}()", is, self.protobuf_name()),
        }
    }

    /// True if self is signed integer with zigzag encoding
    fn is_s_varint(&self) -> bool {
        match *self {
            Type::TYPE_SINT32 | Type::TYPE_SINT64 => true,
            _ => false,
        }
    }

    fn is_copy(&self) -> bool {
        match self {
            Type::TYPE_MESSAGE | Type::TYPE_STRING | Type::TYPE_BYTES => false,
            _ => true,
        }
    }

    fn protobuf_name(&self) -> &'static str {
        match self {
            Type::TYPE_DOUBLE => "double",
            Type::TYPE_FLOAT => "float",
            Type::TYPE_INT32 => "int32",
            Type::TYPE_INT64 => "int64",
            Type::TYPE_UINT32 => "uint32",
            Type::TYPE_UINT64 => "uint64",
            Type::TYPE_SINT32 => "sint32",
            Type::TYPE_SINT64 => "sint64",
            Type::TYPE_FIXED32 => "fixed32",
            Type::TYPE_FIXED64 => "fixed64",
            Type::TYPE_SFIXED32 => "sfixed32",
            Type::TYPE_SFIXED64 => "sfixed64",
            Type::TYPE_BOOL => "bool",
            Type::TYPE_STRING => "string",
            Type::TYPE_BYTES => "bytes",
            Type::TYPE_ENUM => "enum",
            Type::TYPE_MESSAGE => "message",
            Type::TYPE_GROUP => "group",
        }
    }

    /// Rust type for protobuf base type.
    fn rust_type(&self) -> RustType {
        match self {
            Type::TYPE_DOUBLE => RustType::Float(64),
            Type::TYPE_FLOAT => RustType::Float(32),
            Type::TYPE_INT32 => RustType::Int(true, 32),
            Type::TYPE_INT64 => RustType::Int(true, 64),
            Type::TYPE_UINT32 => RustType::Int(false, 32),
            Type::TYPE_UINT64 => RustType::Int(false, 64),
            Type::TYPE_SINT32 => RustType::Int(true, 32),
            Type::TYPE_SINT64 => RustType::Int(true, 64),
            Type::TYPE_FIXED32 => RustType::Int(false, 32),
            Type::TYPE_FIXED64 => RustType::Int(false, 64),
            Type::TYPE_SFIXED32 => RustType::Int(true, 32),
            Type::TYPE_SFIXED64 => RustType::Int(true, 64),
            Type::TYPE_BOOL => RustType::Bool,
            Type::TYPE_STRING => RustType::String,
            Type::TYPE_BYTES => RustType::Vec(Box::new(RustType::u8())),
            Type::TYPE_ENUM | Type::TYPE_GROUP | Type::TYPE_MESSAGE => {
                panic!("there is no rust name for {:?}", self)
            }
        }
    }

    // type of `v` in `os.write_xxx_no_tag(v)`
    fn os_write_fn_param_type(&self) -> RustType {
        match self {
            Type::TYPE_STRING => RustType::amp_str(),
            Type::TYPE_BYTES => RustType::amp_slice_of_u8(),
            Type::TYPE_ENUM => RustType::i32(),
            t => t.rust_type(),
        }
    }

    /// Size of value for type, None if variable.
    fn encoded_size(&self) -> Option<u32> {
        match self {
            Type::TYPE_BOOL => Some(1),
            Type::TYPE_FIXED32 => Some(4),
            Type::TYPE_FIXED64 => Some(8),
            Type::TYPE_SFIXED32 => Some(4),
            Type::TYPE_SFIXED64 => Some(8),
            Type::TYPE_FLOAT => Some(4),
            Type::TYPE_DOUBLE => Some(8),
            _ => None,
        }
    }
}

'''
'''--- protobuf-codegen/src/gen/file.rs ---
use std::collections::HashMap;

use protobuf::descriptor::file_options;
use protobuf::descriptor::FileDescriptorProto;
use protobuf::reflect::FileDescriptor;
use protobuf_parse::ProtoPath;

use crate::compiler_plugin;
use crate::customize::ctx::CustomizeElemCtx;
use crate::customize::rustproto_proto::customize_from_rustproto_for_file;
use crate::gen::code_writer::CodeWriter;
use crate::gen::enums::EnumGen;
use crate::gen::extensions::write_extensions;
use crate::gen::file_descriptor::write_file_descriptor_data;
use crate::gen::inside::protobuf_crate_path;
use crate::gen::message::MessageGen;
use crate::gen::paths::proto_path_to_rust_mod;
use crate::gen::scope::FileScope;
use crate::gen::scope::RootScope;
use crate::proto_name_to_rs;

pub(crate) struct GenFileResult {
    pub(crate) compiler_plugin_result: compiler_plugin::GenResult,
    pub(crate) mod_name: String,
}

pub(crate) fn gen_file(
    file_descriptor: &FileDescriptor,
    _files_map: &HashMap<&ProtoPath, &FileDescriptor>,
    root_scope: &RootScope,
    parent_customize: &CustomizeElemCtx,
    parser: &str,
) -> anyhow::Result<GenFileResult> {
    let lite_runtime_from_builtin_option = file_descriptor
        .proto()
        .options
        .get_or_default()
        .optimize_for()
        == file_options::OptimizeMode::LITE_RUNTIME;

    let mut customize_from_proto =
        customize_from_rustproto_for_file(file_descriptor.proto().options.get_or_default());
    if customize_from_proto.lite_runtime.is_none()
        && parent_customize.for_elem.lite_runtime.is_none()
    {
        customize_from_proto.lite_runtime = Some(lite_runtime_from_builtin_option);
    }

    let customize = parent_customize.child(&customize_from_proto, file_descriptor);

    let file_scope = FileScope { file_descriptor };
    let scope = file_scope.to_scope();

    let lite_runtime = customize.for_elem.lite_runtime.unwrap_or(false);

    let v = CodeWriter::with(|w| {
        w.write_generated_by("rust-protobuf", env!("CARGO_PKG_VERSION"), parser);

        w.write_line("");
        w.write_line(&format!(
            "//! Generated file from `{}`",
            file_descriptor.proto().name()
        ));

        if customize.for_elem.lite_runtime.unwrap_or(false) {
            w.comment("Generated for lite runtime");
        }

        if customize.for_elem.inside_protobuf != Some(true) {
            w.write_line("");
            w.write_line("/// Generated files are compatible only with the same version");
            w.write_line("/// of protobuf runtime.");
            w.write_line(&format!(
                "const _PROTOBUF_VERSION_CHECK: () = {}::{};",
                protobuf_crate_path(&customize.for_elem),
                protobuf::VERSION_IDENT
            ));
        }

        static NESTED_TYPE_NUMBER: protobuf::rt::Lazy<i32> = protobuf::rt::Lazy::new();
        let message_type_number = *NESTED_TYPE_NUMBER.get(|| {
            protobuf::reflect::MessageDescriptor::for_type::<FileDescriptorProto>()
                .field_by_name("message_type")
                .expect("`message_type` must exist")
                .proto()
                .number()
        });

        let mut path = vec![message_type_number, 0];
        for (id, message) in scope.messages().iter().enumerate() {
            // ignore map entries, because they are not used in map fields
            if !message.is_map() {
                path[1] = id as i32;

                w.write_line("");
                MessageGen::new(
                    file_descriptor,
                    message,
                    &root_scope,
                    &customize,
                    &path,
                    file_descriptor.proto().source_code_info.as_ref(),
                )?
                .write(w)?;
            }
        }

        static ENUM_TYPE_NUMBER: protobuf::rt::Lazy<i32> = protobuf::rt::Lazy::new();
        let enum_type_number = *ENUM_TYPE_NUMBER.get(|| {
            protobuf::reflect::MessageDescriptor::for_type::<FileDescriptorProto>()
                .field_by_name("enum_type")
                .expect("`enum_type` must exist")
                .proto()
                .number()
        });

        let mut path = vec![enum_type_number, 0];
        for (id, enum_type) in scope.enums().iter().enumerate() {
            path[1] = id as i32;

            w.write_line("");
            EnumGen::new(
                enum_type,
                &customize,
                root_scope,
                &path,
                file_descriptor.proto().source_code_info.as_ref(),
            )
            .write(w);
        }

        write_extensions(file_descriptor, &root_scope, w, &customize);

        if !lite_runtime {
            w.write_line("");
            write_file_descriptor_data(file_descriptor, &customize.for_elem, w);
        }

        Ok(())
    })?;

    Ok(GenFileResult {
        compiler_plugin_result: compiler_plugin::GenResult {
            name: proto_name_to_rs(file_descriptor.proto().name()),
            content: v.into_bytes(),
        },
        mod_name: proto_path_to_rust_mod(file_descriptor.proto().name()).into_string(),
    })
}

'''
'''--- protobuf-codegen/src/gen/file_and_mod.rs ---
use crate::customize::Customize;
use crate::gen::rust::rel_path::RustRelativePath;

pub(crate) struct FileAndMod {
    pub file: String,
    pub relative_mod: RustRelativePath,
    pub customize: Customize,
}

'''
'''--- protobuf-codegen/src/gen/file_descriptor.rs ---
use std::fmt::Write as _;

use protobuf::reflect::FileDescriptor;
use protobuf::Message;

use crate::gen::code_writer::CodeWriter;
use crate::gen::inside::protobuf_crate_path;
use crate::gen::paths::proto_path_to_fn_file_descriptor;
use crate::gen::rust::snippets::expr_vec_with_capacity_const;
use crate::gen::scope::FileScope;
use crate::gen::scope::Scope;
use crate::gen::scope::WithScope;
use crate::Customize;

fn escape_byte(s: &mut String, b: u8) {
    if b == b'\n' {
        write!(s, "\\n").unwrap();
    } else if b == b'\r' {
        write!(s, "\\r").unwrap();
    } else if b == b'\t' {
        write!(s, "\\t").unwrap();
    } else if b == b'\\' || b == b'"' {
        write!(s, "\\{}", b as char).unwrap();
    } else if b == b'\0' {
        write!(s, "\\0").unwrap();
    // ASCII printable except space
    } else if b > 0x20 && b < 0x7f {
        write!(s, "{}", b as char).unwrap();
    } else {
        write!(s, "\\x{:02x}", b).unwrap();
    }
}

fn write_generate_file_descriptor(
    file_descriptor: &FileDescriptor,
    customize: &Customize,
    w: &mut CodeWriter,
) {
    let deps = &file_descriptor.proto().dependency;
    w.write_line(&format!(
        "let mut deps = {vec_with_capacity};",
        vec_with_capacity = expr_vec_with_capacity_const(deps.len())
    ));
    for f in deps {
        w.write_line(&format!(
            "deps.push({}().clone());",
            proto_path_to_fn_file_descriptor(f, customize)
        ));
    }

    let scope = FileScope { file_descriptor };

    let messages = scope.find_messages_except_map();
    w.write_line(&format!(
        "let mut messages = {vec_with_capacity};",
        vec_with_capacity = expr_vec_with_capacity_const(messages.len())
    ));
    for m in &messages {
        w.write_line(&format!(
            "messages.push({}::generated_message_descriptor_data());",
            m.rust_name_to_file(),
        ));
    }

    let enums = scope.find_enums();
    w.write_line(&format!(
        "let mut enums = {};",
        expr_vec_with_capacity_const(enums.len())
    ));
    for e in &enums {
        w.write_line(&format!(
            "enums.push({}::generated_enum_descriptor_data());",
            e.rust_name_to_file(),
        ));
    }

    w.write_line(&format!(
        "{}::reflect::GeneratedFileDescriptor::new_generated(",
        protobuf_crate_path(&customize),
    ));
    w.indented(|w| {
        w.write_line(&format!("file_descriptor_proto(),"));
        w.write_line(&format!("deps,"));
        w.write_line(&format!("messages,"));
        w.write_line(&format!("enums,"));
    });
    w.write_line(")");
}

fn write_file_descriptor(
    file_descriptor: &FileDescriptor,
    customize: &Customize,
    w: &mut CodeWriter,
) {
    w.write_line("/// `FileDescriptor` object which allows dynamic access to files");
    w.pub_fn(
        &format!(
            "file_descriptor() -> &'static {protobuf_crate}::reflect::FileDescriptor",
            protobuf_crate = protobuf_crate_path(customize)
        ),
        |w| {
            w.lazy_static(
                "generated_file_descriptor_lazy",
                &format!(
                    "{protobuf_crate}::reflect::GeneratedFileDescriptor",
                    protobuf_crate = protobuf_crate_path(customize)
                ),
                &format!("{}", protobuf_crate_path(customize)),
            );
            w.lazy_static_decl_get(
                "file_descriptor",
                &format!(
                    "{protobuf_crate}::reflect::FileDescriptor",
                    protobuf_crate = protobuf_crate_path(customize)
                ),
                &format!("{}", protobuf_crate_path(customize)),
                |w| {
                    w.block(
                        "let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {",
                        "});",
                        |w| write_generate_file_descriptor(file_descriptor, customize, w),
                    );
                    w.write_line(&format!(
                        "{protobuf_crate}::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)",
                        protobuf_crate=protobuf_crate_path(&customize),
                    ));
                }
            );
        },
    );
}

pub(crate) fn write_file_descriptor_data(
    file: &FileDescriptor,
    customize: &Customize,
    w: &mut CodeWriter,
) {
    let fdp_bytes = file.proto().write_to_bytes().unwrap();
    w.write_line("static file_descriptor_proto_data: &'static [u8] = b\"\\");
    w.indented(|w| {
        const MAX_LINE_LEN: usize = 72;

        let mut s = String::new();
        for &b in &fdp_bytes {
            let prev_len = s.len();
            escape_byte(&mut s, b);
            let truncate = s.len() > MAX_LINE_LEN;
            if truncate {
                s.truncate(prev_len);
            }
            if truncate || s.len() == MAX_LINE_LEN {
                write!(s, "\\").unwrap();
                w.write_line(&s);
                s.clear();
            }
            if truncate {
                escape_byte(&mut s, b);
            }
        }
        if !s.is_empty() {
            write!(s, "\\").unwrap();
            w.write_line(&s);
            s.clear();
        }
    });
    w.write_line("\";");
    w.write_line("");
    write_file_descriptor_proto(&customize, w);
    w.write_line("");
    write_file_descriptor(file, &customize, w);
}

fn write_file_descriptor_proto(customize: &Customize, w: &mut CodeWriter) {
    w.write_line("/// `FileDescriptorProto` object which was a source for this generated file");
    w.def_fn(
        &format!(
            "file_descriptor_proto() -> &'static {protobuf_crate}::descriptor::FileDescriptorProto",
            protobuf_crate=protobuf_crate_path(customize)
        ),
        |w| {
            w.lazy_static_decl_get(
                "file_descriptor_proto_lazy",
                &format!(
                    "{protobuf_crate}::descriptor::FileDescriptorProto",
                    protobuf_crate=protobuf_crate_path(customize)
                ),
                &format!("{}", protobuf_crate_path(customize)),
                |w| {
                    w.write_line(&format!(
                        "{protobuf_crate}::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()",
                        protobuf_crate=protobuf_crate_path(customize)
                    ));
                },
            );
        },
    );
}

/// Code to generate call `module::file_descriptor()`.
pub(crate) fn file_descriptor_call_expr(scope: &Scope) -> String {
    format!(
        "{}()",
        scope
            .rust_path_to_file()
            .to_reverse()
            .append_ident("file_descriptor".into())
    )
}

'''
'''--- protobuf-codegen/src/gen/inside.rs ---
use crate::customize::Customize;
use crate::gen::rust::path::RustPath;

/// Path to `protobuf` crate, different when `.proto` file is
/// used inside or outside of protobuf crate.
pub(crate) fn protobuf_crate_path(customize: &Customize) -> RustPath {
    match customize.inside_protobuf {
        Some(true) => RustPath::from("crate"),
        _ => RustPath::from("::protobuf"),
    }
}

'''
'''--- protobuf-codegen/src/gen/map.rs ---
use crate::gen::scope::FieldWithContext;
use crate::gen::scope::MessageWithScope;

/// Pair of (key, value) if this message is map entry
pub(crate) fn map_entry<'a>(
    d: &'a MessageWithScope,
) -> Option<(FieldWithContext<'a>, FieldWithContext<'a>)> {
    if d.message.is_map_entry() {
        // `MessageDescriptor` validated the fields.
        let key = d.fields()[0].clone();
        let value = d.fields()[1].clone();
        Some((key, value))
    } else {
        None
    }
}

'''
'''--- protobuf-codegen/src/gen/message.rs ---
use std::fmt;

use protobuf::descriptor::*;
use protobuf::reflect::FileDescriptor;
use protobuf::reflect::MessageDescriptor;
use protobuf_parse::snake_case;

use crate::customize::ctx::CustomizeElemCtx;
use crate::customize::ctx::SpecialFieldPseudoDescriptor;
use crate::customize::rustproto_proto::customize_from_rustproto_for_message;
use crate::gen::code_writer::*;
use crate::gen::descriptor::write_fn_descriptor;
use crate::gen::enums::*;
use crate::gen::field::FieldGen;
use crate::gen::field::FieldKind;
use crate::gen::file_and_mod::FileAndMod;
use crate::gen::inside::protobuf_crate_path;
use crate::gen::oneof::OneofGen;
use crate::gen::oneof::OneofVariantGen;
use crate::gen::protoc_insertion_point::write_protoc_insertion_point_for_message;
use crate::gen::protoc_insertion_point::write_protoc_insertion_point_for_special_field;
use crate::gen::rust::ident::RustIdent;
use crate::gen::rust::ident_with_path::RustIdentWithPath;
use crate::gen::rust::rel_path::RustRelativePath;
use crate::gen::rust::snippets::expr_vec_with_capacity_const;
use crate::gen::rust::snippets::EXPR_NONE;
use crate::gen::rust_types_values::*;
use crate::gen::scope::MessageWithScope;
use crate::gen::scope::RootScope;
use crate::gen::scope::WithScope;
use crate::Customize;

/// Protobuf message Rust type name
#[derive(Debug, Clone, PartialEq, Eq)]
pub(crate) struct RustTypeMessage(pub RustIdentWithPath);

impl fmt::Display for RustTypeMessage {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        fmt::Display::fmt(&self.0, f)
    }
}

impl<S: Into<RustIdentWithPath>> From<S> for RustTypeMessage {
    fn from(s: S) -> Self {
        RustTypeMessage(s.into())
    }
}

impl RustTypeMessage {
    /// Code which emits default instance.
    pub fn default_instance(&self, customize: &Customize) -> String {
        format!(
            "<{} as {}::Message>::default_instance()",
            self.0,
            protobuf_crate_path(customize)
        )
    }
}

/// Message info for codegen
pub(crate) struct MessageGen<'a> {
    file_descriptor: &'a FileDescriptor,
    message_descriptor: MessageDescriptor,
    pub message: &'a MessageWithScope<'a>,
    pub root_scope: &'a RootScope<'a>,
    pub fields: Vec<FieldGen<'a>>,
    pub lite_runtime: bool,
    customize: CustomizeElemCtx<'a>,
    path: &'a [i32],
    info: Option<&'a SourceCodeInfo>,
}

impl<'a> MessageGen<'a> {
    pub fn new(
        file_descriptor: &'a FileDescriptor,
        message: &'a MessageWithScope<'a>,
        root_scope: &'a RootScope<'a>,
        parent_customize: &CustomizeElemCtx<'a>,
        path: &'a [i32],
        info: Option<&'a SourceCodeInfo>,
    ) -> anyhow::Result<MessageGen<'a>> {
        let message_descriptor = file_descriptor
            .message_by_package_relative_name(&format!("{}", message.protobuf_name_to_package()))
            .unwrap();

        let customize = parent_customize.child(
            &customize_from_rustproto_for_message(message.message.proto().options.get_or_default()),
            &message.message,
        );

        static FIELD_NUMBER: protobuf::rt::Lazy<i32> = protobuf::rt::Lazy::new();
        let field_number = *FIELD_NUMBER.get(|| {
            protobuf::reflect::MessageDescriptor::for_type::<DescriptorProto>()
                .field_by_name("field")
                .expect("`field` must exist")
                .proto()
                .number()
        });

        let fields: Vec<_> = message
            .fields()
            .into_iter()
            .enumerate()
            .map(|(id, field)| {
                let mut path = path.to_vec();
                path.extend_from_slice(&[field_number, id as i32]);
                FieldGen::parse(field, root_scope, &customize, path, info)
            })
            .collect::<anyhow::Result<Vec<_>>>()?;
        let lite_runtime = customize.for_elem.lite_runtime.unwrap_or_else(|| {
            message.file_descriptor().proto().options.optimize_for()
                == file_options::OptimizeMode::LITE_RUNTIME
        });
        Ok(MessageGen {
            message_descriptor,
            file_descriptor,
            message,
            root_scope,
            fields,
            lite_runtime,
            customize,
            path,
            info,
        })
    }

    fn rust_name(&self) -> RustIdent {
        self.message.rust_name()
    }

    fn mod_name(&self) -> RustRelativePath {
        self.message.scope.rust_path_to_file()
    }

    pub fn file_and_mod(&self) -> FileAndMod {
        self.message
            .scope
            .file_and_mod(self.customize.for_elem.clone())
    }

    fn oneofs(&'a self) -> Vec<OneofGen<'a>> {
        self.message
            .oneofs()
            .into_iter()
            .map(|oneof| OneofGen::parse(self, oneof, &self.customize))
            .collect()
    }

    fn required_fields(&'a self) -> Vec<&'a FieldGen> {
        self.fields
            .iter()
            .filter(|f| match f.kind {
                FieldKind::Singular(ref singular) => singular.flag.is_required(),
                _ => false,
            })
            .collect()
    }

    fn message_fields(&'a self) -> Vec<&'a FieldGen> {
        self.fields
            .iter()
            .filter(|f| f.proto_type == field_descriptor_proto::Type::TYPE_MESSAGE)
            .collect()
    }

    fn fields_except_oneof(&'a self) -> Vec<&'a FieldGen> {
        self.fields
            .iter()
            .filter(|f| match f.kind {
                FieldKind::Oneof(..) => false,
                _ => true,
            })
            .collect()
    }

    fn fields_except_group(&'a self) -> Vec<&'a FieldGen> {
        self.fields
            .iter()
            .filter(|f| f.proto_type != field_descriptor_proto::Type::TYPE_GROUP)
            .collect()
    }

    fn fields_except_oneof_and_group(&'a self) -> Vec<&'a FieldGen> {
        self.fields
            .iter()
            .filter(|f| match f.kind {
                FieldKind::Oneof(..) => false,
                _ => f.proto_type != field_descriptor_proto::Type::TYPE_GROUP,
            })
            .collect()
    }

    fn write_match_each_oneof_variant<F>(&self, w: &mut CodeWriter, cb: F)
    where
        F: Fn(&mut CodeWriter, &OneofVariantGen, &RustValueTyped),
    {
        for oneof in self.oneofs() {
            let variants = oneof.variants_except_group();
            if variants.is_empty() {
                // Special case because
                // https://github.com/rust-lang/rust/issues/50642
                continue;
            }
            w.if_let_stmt(
                "::std::option::Option::Some(ref v)",
                &format!("self.{}", oneof.oneof.field_name())[..],
                |w| {
                    w.match_block("v", |w| {
                        for variant in variants {
                            let ref field = variant.field;

                            let (refv, vtype) = if field.elem_type_is_copy() {
                                ("v", variant.rust_type(&self.file_and_mod()))
                            } else {
                                ("ref v", variant.rust_type(&self.file_and_mod()).ref_type())
                            };
                            w.case_block(
                                format!("&{}({})", variant.path(&self.file_and_mod()), refv),
                                |w| {
                                    cb(
                                        w,
                                        &variant,
                                        &RustValueTyped {
                                            value: "v".to_owned(),
                                            rust_type: vtype.clone(),
                                        },
                                    );
                                },
                            );
                        }
                    });
                },
            );
        }
    }

    fn write_write_to_with_cached_sizes(&self, w: &mut CodeWriter) {
        let sig = format!(
            "write_to_with_cached_sizes(&self, os: &mut {protobuf_crate}::CodedOutputStream<'_>) -> {protobuf_crate}::Result<()>",
            protobuf_crate=protobuf_crate_path(&self.customize.for_elem),
        );
        w.def_fn(&sig, |w| {
            // To have access to its methods but not polute the name space.
            for f in self.fields_except_oneof_and_group() {
                f.write_message_write_field("os", w);
            }
            self.write_match_each_oneof_variant(w, |w, variant, v| {
                variant
                    .field
                    .write_write_element(variant.elem(), w, "os", v);
            });
            w.write_line("os.write_unknown_fields(self.special_fields.unknown_fields())?;");
            w.write_line("::std::result::Result::Ok(())");
        });
    }

    fn write_default_instance_lazy(&self, w: &mut CodeWriter) {
        w.lazy_static_decl_get_simple(
            "instance",
            &format!("{}", self.rust_name()),
            &format!("{}::new", self.rust_name()),
            &format!("{}", protobuf_crate_path(&self.customize.for_elem)),
        );
    }

    fn write_default_instance_static(&self, w: &mut CodeWriter) {
        w.stmt_block(
            &format!(
                "static instance: {} = {}",
                self.rust_name(),
                self.rust_name()
            ),
            |w| {
                for f in &self.fields_except_oneof_and_group() {
                    w.field_entry(
                        &f.rust_name.to_string(),
                        &f.kind
                            .default(&self.customize.for_elem, &self.file_and_mod(), true),
                    );
                }
                for o in &self.oneofs() {
                    w.field_entry(&o.oneof.field_name().to_string(), EXPR_NONE);
                }
                w.field_entry(
                    "special_fields",
                    &format!(
                        "{}::SpecialFields::new()",
                        protobuf_crate_path(&self.customize.for_elem)
                    ),
                );
            },
        );
        w.write_line("&instance");
    }

    fn write_default_instance(&self, w: &mut CodeWriter) {
        w.def_fn(
            &format!("default_instance() -> &'static {}", self.rust_name()),
            |w| {
                let has_map_field = self.fields.iter().any(|f| match f.kind {
                    FieldKind::Map(..) => true,
                    _ => false,
                });
                if has_map_field {
                    self.write_default_instance_lazy(w)
                } else {
                    self.write_default_instance_static(w)
                }
            },
        );
    }

    fn write_compute_size(&self, w: &mut CodeWriter) {
        // Append sizes of messages in the tree to the specified vector.
        // First appended element is size of self, and then nested message sizes.
        // in serialization order are appended recursively.");
        w.comment("Compute sizes of nested messages");
        // there are unused variables in oneof
        w.allow(&["unused_variables"]);
        w.def_fn("compute_size(&self) -> u64", |w| {
            // To have access to its methods but not polute the name space.
            w.write_line("let mut my_size = 0;");
            for field in self.fields_except_oneof_and_group() {
                field.write_message_compute_field_size("my_size", w);
            }
            self.write_match_each_oneof_variant(w, |w, variant, v| {
                variant
                    .field
                    .write_element_size(variant.elem(), w, v, "my_size");
            });
            w.write_line(&format!(
                "my_size += {}::rt::unknown_fields_size(self.special_fields.unknown_fields());",
                protobuf_crate_path(&self.customize.for_elem)
            ));
            w.write_line("self.special_fields.cached_size().set(my_size as u32);");
            w.write_line("my_size");
        });
    }

    fn write_field_accessors(&self, w: &mut CodeWriter) {
        for f in self.fields_except_group() {
            f.write_message_single_field_accessors(w);
        }
    }

    fn write_impl_self(&self, w: &mut CodeWriter) {
        w.impl_self_block(&format!("{}", self.rust_name()), |w| {
            w.pub_fn(&format!("new() -> {}", self.rust_name()), |w| {
                w.write_line("::std::default::Default::default()");
            });

            self.write_field_accessors(w);

            if !self.lite_runtime {
                w.write_line("");
                self.write_generated_message_descriptor_data(w);
            }
        });
    }

    fn write_unknown_fields(&self, w: &mut CodeWriter) {
        let sig = format!(
            "special_fields(&self) -> &{}::SpecialFields",
            protobuf_crate_path(&self.customize.for_elem)
        );
        w.def_fn(&sig, |w| {
            w.write_line("&self.special_fields");
        });
        w.write_line("");
        let sig = format!(
            "mut_special_fields(&mut self) -> &mut {}::SpecialFields",
            protobuf_crate_path(&self.customize.for_elem)
        );
        w.def_fn(&sig, |w| {
            w.write_line("&mut self.special_fields");
        });
    }

    fn write_merge_from(&self, w: &mut CodeWriter) {
        let sig = format!(
            "merge_from(&mut self, is: &mut {}::CodedInputStream<'_>) -> {}::Result<()>",
            protobuf_crate_path(&self.customize.for_elem),
            protobuf_crate_path(&self.customize.for_elem),
        );
        w.def_fn(&sig, |w| {
            w.while_block("let Some(tag) = is.read_raw_tag_or_eof()?", |w| {
                w.match_block("tag", |w| {
                    for f in &self.fields_except_group() {
                        f.write_merge_from_field_case_block(w);
                    }
                    w.case_block("tag", |w| {
                        w.write_line(&format!("{}::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;", protobuf_crate_path(&self.customize.for_elem)));
                    });
                });
            });
            w.write_line("::std::result::Result::Ok(())");
        });
    }

    fn write_impl_message_full_fn_descriptor(&self, w: &mut CodeWriter) {
        write_fn_descriptor(
            &self.message.message,
            self.message.scope(),
            &self.customize.for_elem,
            w,
        );
    }

    fn write_generated_message_descriptor_data(&self, w: &mut CodeWriter) {
        let sig = format!(
            "generated_message_descriptor_data() -> {}::reflect::GeneratedMessageDescriptorData",
            protobuf_crate_path(&self.customize.for_elem)
        );
        w.fn_block(
            Visibility::Path(self.message.scope().rust_path_to_file().to_reverse()),
            &sig,
            |w| {
                let fields = self.fields_except_group();
                let oneofs = self.oneofs();
                w.write_line(&format!(
                    "let mut fields = {};",
                    expr_vec_with_capacity_const(fields.len())
                ));
                w.write_line(&format!(
                    "let mut oneofs = {};",
                    expr_vec_with_capacity_const(oneofs.len())
                ));
                for field in fields {
                    field.write_push_accessor("fields", w);
                }
                for oneof in oneofs {
                    w.write_line(&format!(
                        "oneofs.push({}::generated_oneof_descriptor_data());",
                        oneof.type_name_relative(&self.mod_name())
                    ));
                }
                w.write_line(&format!(
                    "{}::reflect::GeneratedMessageDescriptorData::new_2::<{}>(",
                    protobuf_crate_path(&self.customize.for_elem),
                    self.rust_name(),
                ));
                w.indented(|w| {
                    w.write_line(&format!("\"{}\",", self.message.name_to_package()));
                    w.write_line("fields,");
                    w.write_line("oneofs,");
                });
                w.write_line(")");
            },
        );
    }

    fn write_is_initialized(&self, w: &mut CodeWriter) {
        w.def_fn(&format!("is_initialized(&self) -> bool"), |w| {
            if !self.message.message.is_initialized_is_always_true() {
                // TODO: use single loop

                for f in self.required_fields() {
                    f.write_if_self_field_is_none(w, |w| {
                        w.write_line("return false;");
                    });
                }

                for f in self.message_fields() {
                    if let FieldKind::Map(..) = f.kind {
                        // TODO
                        w.comment("TODO: check map values are initialized");
                        continue;
                    }

                    f.write_for_self_field(w, "v", |w, _t| {
                        w.if_stmt("!v.is_initialized()", |w| {
                            w.write_line("return false;");
                        });
                    });
                }
            }
            w.write_line("true");
        });
    }

    fn write_impl_message(&self, w: &mut CodeWriter) {
        w.impl_for_block(
            &format!("{}::Message", protobuf_crate_path(&self.customize.for_elem),),
            &format!("{}", self.rust_name()),
            |w| {
                w.write_line(&format!(
                    "const NAME: &'static str = \"{}\";",
                    self.message.message.name()
                ));
                w.write_line("");
                self.write_is_initialized(w);
                w.write_line("");
                self.write_merge_from(w);
                w.write_line("");
                self.write_compute_size(w);
                w.write_line("");
                self.write_write_to_with_cached_sizes(w);
                w.write_line("");
                self.write_unknown_fields(w);
                w.write_line("");
                w.def_fn(&format!("new() -> {}", self.rust_name()), |w| {
                    w.write_line(&format!("{}::new()", self.rust_name()));
                });
                w.write_line("");
                w.def_fn("clear(&mut self)", |w| {
                    for f in self.fields_except_group() {
                        f.write_clear(w);
                    }
                    w.write_line("self.special_fields.clear();");
                });
                w.write_line("");
                self.write_default_instance(w);
            },
        );
    }

    fn write_impl_message_full(&self, w: &mut CodeWriter) {
        w.impl_for_block(
            &format!(
                "{}::MessageFull",
                protobuf_crate_path(&self.customize.for_elem),
            ),
            &format!("{}", self.rust_name()),
            |w| {
                self.write_impl_message_full_fn_descriptor(w);
            },
        );
    }

    fn write_impl_value(&self, w: &mut CodeWriter) {
        w.impl_for_block(
            &format!(
                "{}::reflect::ProtobufValue",
                protobuf_crate_path(&self.customize.for_elem)
            ),
            &format!("{}", self.rust_name()),
            |w| {
                w.write_line(&format!(
                    "type RuntimeType = {}::reflect::rt::RuntimeTypeMessage<Self>;",
                    protobuf_crate_path(&self.customize.for_elem)
                ));
            },
        )
    }

    fn write_impl_display(&self, w: &mut CodeWriter) {
        w.impl_for_block(
            "::std::fmt::Display",
            &format!("{}", self.rust_name()),
            |w| {
                w.def_fn(
                    "fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result",
                    |w| {
                        w.write_line(&format!(
                            "{}::text_format::fmt(self, f)",
                            protobuf_crate_path(&self.customize.for_elem)
                        ));
                    },
                );
            },
        );
    }

    fn supports_derive_partial_eq(&self) -> bool {
        // There's stack overflow in the compiler when struct has too many fields
        // https://github.com/rust-lang/rust/issues/40119
        self.fields.len() <= 500
    }

    fn write_struct(&self, w: &mut CodeWriter) {
        write_protoc_insertion_point_for_message(
            w,
            &self.customize.for_elem,
            &self.message_descriptor,
        );
        let mut derive = Vec::new();
        if self.supports_derive_partial_eq() {
            derive.push("PartialEq");
        }
        derive.extend(&["Clone", "Default", "Debug"]);
        w.derive(&derive);

        w.pub_struct(&format!("{}", self.rust_name()), |w| {
            if !self.fields_except_oneof().is_empty() {
                w.comment("message fields");
                for field in self.fields_except_oneof() {
                    field.write_struct_field(w);
                }
            }
            if !self.oneofs().is_empty() {
                w.comment("message oneof groups");
                for oneof in self.oneofs() {
                    w.field_decl_vis(
                        Visibility::Public,
                        &oneof.oneof.field_name().to_string(),
                        &oneof.full_storage_type().to_code(&self.customize.for_elem),
                    );
                }
            }
            w.comment("special fields");

            let customize_special_fields = self
                .customize
                .child(
                    &Customize::default(),
                    &SpecialFieldPseudoDescriptor {
                        message: &self.message.message,
                        field: "special_fields",
                    },
                )
                .for_elem;

            write_protoc_insertion_point_for_special_field(
                w,
                &customize_special_fields,
                &self.message_descriptor,
                "special_fields",
            );
            w.pub_field_decl(
                "special_fields",
                &format!(
                    "{}::SpecialFields",
                    protobuf_crate_path(&self.customize.for_elem)
                ),
            );
        });
    }

    fn write_impl_default_for_amp(&self, w: &mut CodeWriter) {
        w.impl_args_for_block(
            &["'a"],
            "::std::default::Default",
            &format!("&'a {}", self.rust_name()),
            |w| {
                w.def_fn(&format!("default() -> &'a {}", self.rust_name()), |w| {
                    w.write_line(&format!(
                        "<{} as {}::Message>::default_instance()",
                        self.rust_name(),
                        protobuf_crate_path(&self.customize.for_elem),
                    ));
                });
            },
        );
    }

    fn write_dummy_impl_partial_eq(&self, w: &mut CodeWriter) {
        w.impl_for_block(
            "::std::cmp::PartialEq",
            &format!("{}", self.rust_name()),
            |w| {
                w.def_fn("eq(&self, _: &Self) -> bool", |w| {
                    w.comment("https://github.com/rust-lang/rust/issues/40119");
                    w.unimplemented();
                });
            },
        );
    }

    pub fn write(&self, w: &mut CodeWriter) -> anyhow::Result<()> {
        w.all_documentation(self.info, self.path);
        self.write_struct(w);

        w.write_line("");
        self.write_impl_default_for_amp(w);

        if !self.supports_derive_partial_eq() {
            w.write_line("");
            self.write_dummy_impl_partial_eq(w);
        }

        w.write_line("");
        self.write_impl_self(w);
        w.write_line("");
        self.write_impl_message(w);
        if !self.lite_runtime {
            w.write_line("");
            self.write_impl_message_full(w);
        }
        if !self.lite_runtime {
            w.write_line("");
            self.write_impl_display(w);

            w.write_line("");
            self.write_impl_value(w);
        }

        let mod_name = message_name_to_nested_mod_name(&self.message.message.name());

        let oneofs = self.oneofs();
        let nested_messages: Vec<_> = self
            .message
            .to_scope()
            .messages()
            .into_iter()
            .filter(|nested| {
                // ignore map entries, because they are not used in map fields
                !nested.is_map()
            })
            .collect();
        let nested_enums = self.message.to_scope().enums();

        if !oneofs.is_empty() || !nested_messages.is_empty() || !nested_enums.is_empty() {
            w.write_line("");
            w.write_line(&format!(
                "/// Nested message and enums of message `{}`",
                self.message.message.name()
            ));
            w.pub_mod(&mod_name.to_string(), |w| {
                let mut first = true;

                for oneof in &oneofs {
                    w.write_line("");
                    oneof.write(w);
                }

                static NESTED_TYPE_NUMBER: protobuf::rt::Lazy<i32> = protobuf::rt::Lazy::new();
                let nested_type_number = *NESTED_TYPE_NUMBER.get(|| {
                    MessageDescriptor::for_type::<DescriptorProto>()
                        .field_by_name("nested_type")
                        .expect("`nested_type` must exist")
                        .proto()
                        .number()
                });

                let mut path = self.path.to_vec();
                path.extend(&[nested_type_number, 0]);
                for (id, nested) in nested_messages.iter().enumerate() {
                    let len = path.len() - 1;
                    path[len] = id as i32;

                    if !first {
                        w.write_line("");
                    }
                    first = false;
                    MessageGen::new(
                        &self.file_descriptor,
                        nested,
                        self.root_scope,
                        &self.customize,
                        &path,
                        self.info,
                    )
                    // TODO: do not unwrap.
                    .unwrap()
                    .write(w)
                    // TODO: do not unwrap.
                    .unwrap();
                }

                static ENUM_TYPE_NUMBER: protobuf::rt::Lazy<i32> = protobuf::rt::Lazy::new();
                let enum_type_number = *ENUM_TYPE_NUMBER.get(|| {
                    MessageDescriptor::for_type::<DescriptorProto>()
                        .field_by_name("enum_type")
                        .expect("`enum_type` must exist")
                        .proto()
                        .number()
                });

                let len = path.len() - 2;
                path[len] = enum_type_number;
                for (id, enum_type) in self.message.to_scope().enums().iter().enumerate() {
                    let len = path.len() - 1;
                    path[len] = id as i32;

                    if !first {
                        w.write_line("");
                    }
                    first = false;
                    EnumGen::new(
                        enum_type,
                        &self.customize,
                        self.root_scope,
                        &path,
                        self.info,
                    )
                    .write(w);
                }
            });
        }
        Ok(())
    }
}

pub(crate) fn message_name_to_nested_mod_name(message_name: &str) -> RustIdent {
    let mod_name = snake_case(message_name);
    RustIdent::new(&mod_name)
}

'''
'''--- protobuf-codegen/src/gen/mod.rs ---
pub(crate) mod all;
pub(crate) mod code_writer;
pub(crate) mod descriptor;
pub(crate) mod enums;
pub(crate) mod extensions;
pub(crate) mod field;
pub(crate) mod file;
pub(crate) mod file_and_mod;
pub(crate) mod file_descriptor;
pub(crate) mod inside;
mod map;
pub(crate) mod message;
pub(crate) mod mod_rs;
pub(crate) mod oneof;
pub(crate) mod paths;
pub(crate) mod protoc_insertion_point;
pub(crate) mod rust;
pub(crate) mod rust_types_values;
pub(crate) mod scope;
pub(crate) mod strx;
pub(crate) mod well_known_types;

'''
'''--- protobuf-codegen/src/gen/mod_rs.rs ---
use crate::compiler_plugin;
use crate::gen::code_writer::CodeWriter;

pub(crate) fn gen_mod_rs(mods: &[String]) -> compiler_plugin::GenResult {
    let v = CodeWriter::with_no_error(|w| {
        w.comment(&format!("{}generated", "@"));
        w.write_line("");
        let mut mods: Vec<&String> = mods.into_iter().collect();
        mods.sort();
        for m in mods {
            w.write_line(&format!("pub mod {};", m));
        }
    });
    compiler_plugin::GenResult {
        name: "mod.rs".to_owned(),
        content: v.into_bytes(),
    }
}

'''
'''--- protobuf-codegen/src/gen/oneof.rs ---
//! Oneof-related codegen functions.

use std::collections::HashSet;

use protobuf::descriptor::field_descriptor_proto;
use protobuf::descriptor::file_options;
use protobuf::reflect::FieldDescriptor;
use protobuf_parse::ProtobufAbsPath;

use crate::customize::ctx::CustomizeElemCtx;
use crate::customize::Customize;
use crate::gen::code_writer::CodeWriter;
use crate::gen::code_writer::Visibility;
use crate::gen::field::elem::FieldElem;
use crate::gen::field::rust_variant_name_for_protobuf_oneof_field_name;
use crate::gen::field::FieldGen;
use crate::gen::file_and_mod::FileAndMod;
use crate::gen::inside::protobuf_crate_path;
use crate::gen::message::MessageGen;
use crate::gen::protoc_insertion_point::write_protoc_insertion_point_for_oneof;
use crate::gen::protoc_insertion_point::write_protoc_insertion_point_for_oneof_field;
use crate::gen::rust::ident::RustIdent;
use crate::gen::rust::ident_with_path::RustIdentWithPath;
use crate::gen::rust::path::RustPath;
use crate::gen::rust::rel_path::RustRelativePath;
use crate::gen::rust_types_values::make_path;
use crate::gen::rust_types_values::RustType;
use crate::gen::scope::OneofVariantWithContext;
use crate::gen::scope::OneofWithContext;
use crate::gen::scope::RootScope;
use crate::gen::scope::WithScope;

// oneof one { ... }
#[derive(Clone)]
pub(crate) struct OneofField<'a> {
    pub elem: FieldElem<'a>,
    pub oneof_variant_rust_name: RustIdent,
    pub oneof_field_name: RustIdent,
    pub type_name: RustIdentWithPath,
    pub boxed: bool,
}

impl<'a> OneofField<'a> {
    // Detecting recursion: if oneof fields contains a self-reference
    // or another message which has a reference to self,
    // put oneof variant into a box.
    fn need_boxed(
        field: &FieldDescriptor,
        root_scope: &RootScope,
        owner_name: &ProtobufAbsPath,
    ) -> bool {
        let mut visited_messages = HashSet::new();
        let mut fields = vec![field.clone()];
        while let Some(field) = fields.pop() {
            if field.proto().type_() == field_descriptor_proto::Type::TYPE_MESSAGE {
                let message_name = ProtobufAbsPath::from(field.proto().type_name());
                if !visited_messages.insert(message_name.clone()) {
                    continue;
                }
                if message_name == *owner_name {
                    return true;
                }
                let message = root_scope.find_message(&message_name);
                fields.extend(
                    message
                        .message
                        .fields()
                        .into_iter()
                        .filter(|f| f.containing_oneof().is_some()),
                );
            }
        }
        false
    }

    pub fn parse(
        oneof: &OneofWithContext<'a>,
        field: &FieldDescriptor,
        elem: FieldElem<'a>,
        root_scope: &RootScope,
    ) -> OneofField<'a> {
        let boxed = OneofField::need_boxed(field, root_scope, &oneof.message.name_absolute());

        OneofField {
            elem,
            type_name: oneof.rust_name(),
            boxed,
            oneof_variant_rust_name: rust_variant_name_for_protobuf_oneof_field_name(field.name()),
            oneof_field_name: oneof.field_name(),
        }
    }

    pub fn rust_type(&self, reference: &FileAndMod) -> RustType {
        let t = self.elem.rust_storage_elem_type(reference);

        if self.boxed {
            RustType::Uniq(Box::new(t))
        } else {
            t
        }
    }

    pub fn variant_path(&self, reference: &RustRelativePath) -> RustIdentWithPath {
        make_path(
            reference,
            &self
                .type_name
                .to_path()
                .with_ident(self.oneof_variant_rust_name.clone()),
        )
    }
}

#[derive(Clone)]
pub(crate) struct OneofVariantGen<'a> {
    oneof: &'a OneofGen<'a>,
    _variant: OneofVariantWithContext<'a>,
    oneof_field: OneofField<'a>,
    pub field: FieldGen<'a>,
    _path: String,
}

impl<'a> OneofVariantGen<'a> {
    fn parse(
        oneof: &'a OneofGen<'a>,
        variant: OneofVariantWithContext<'a>,
        field: &'a FieldGen,
        _root_scope: &RootScope,
    ) -> OneofVariantGen<'a> {
        OneofVariantGen {
            oneof,
            _variant: variant.clone(),
            field: field.clone(),
            _path: format!(
                "{}::{}",
                oneof.type_name_relative(&oneof.oneof.message.scope.rust_path_to_file()),
                field.rust_name
            ),
            oneof_field: OneofField::parse(
                variant.oneof,
                &field.proto_field.field,
                field.elem().clone(),
                oneof.message.root_scope,
            ),
        }
    }

    pub fn rust_type(&self, reference: &FileAndMod) -> RustType {
        self.oneof_field.rust_type(reference)
    }

    pub fn path(&self, reference: &FileAndMod) -> RustPath {
        RustPath::from(format!(
            "{}::{}",
            self.oneof.type_name_relative(&reference.relative_mod),
            self.oneof_field.oneof_variant_rust_name,
        ))
    }

    pub(crate) fn elem(&self) -> &FieldElem<'_> {
        self.field.elem()
    }
}

pub(crate) struct OneofGen<'a> {
    // Message containing this oneof
    message: &'a MessageGen<'a>,
    pub oneof: OneofWithContext<'a>,
    customize: CustomizeElemCtx<'a>,
    lite_runtime: bool,
}

impl<'a> OneofGen<'a> {
    pub fn parse(
        message: &'a MessageGen,
        oneof: OneofWithContext<'a>,
        parent_customize: &CustomizeElemCtx<'a>,
    ) -> OneofGen<'a> {
        let customize = parent_customize.child(&Customize::default(), &oneof.oneof);
        let lite_runtime = customize.for_elem.lite_runtime.unwrap_or_else(|| {
            oneof
                .message
                .file_descriptor()
                .proto()
                .options
                .optimize_for()
                == file_options::OptimizeMode::LITE_RUNTIME
        });
        OneofGen {
            message,
            oneof,
            customize,
            lite_runtime,
        }
    }

    pub fn type_name_relative(&self, source: &RustRelativePath) -> RustIdentWithPath {
        make_path(source, &self.oneof.rust_name())
    }

    pub fn variants_except_group(&'a self) -> Vec<OneofVariantGen<'a>> {
        self.oneof
            .variants()
            .into_iter()
            .filter_map(|v| {
                let field = self
                    .message
                    .fields
                    .iter()
                    .filter(|f| f.proto_field.name() == v.field.name())
                    .next()
                    .expect(&format!("field not found by name: {}", v.field.name()));
                match field.proto_type {
                    field_descriptor_proto::Type::TYPE_GROUP => None,
                    _ => Some(OneofVariantGen::parse(
                        self,
                        v,
                        field,
                        self.message.root_scope,
                    )),
                }
            })
            .collect()
    }

    pub fn full_storage_type(&self) -> RustType {
        RustType::Option(Box::new(RustType::Oneof(
            self.type_name_relative(
                &self
                    .oneof
                    .message
                    .scope
                    .file_and_mod(self.customize.for_elem.clone())
                    .relative_mod,
            )
            .clone(),
        )))
    }

    fn file_and_mod(&self) -> FileAndMod {
        let mut file_and_mod = self
            .message
            .message
            .scope
            .file_and_mod(self.customize.for_elem.clone());
        file_and_mod
            .relative_mod
            .push_ident(self.message.message.mod_name());
        file_and_mod
    }

    fn write_enum(&self, w: &mut CodeWriter) {
        let derive = vec!["Clone", "PartialEq", "Debug"];
        w.derive(&derive);
        w.write_line("#[non_exhaustive]");
        write_protoc_insertion_point_for_oneof(w, &self.customize.for_elem, &self.oneof.oneof);
        w.pub_enum(&self.oneof.rust_name().ident.to_string(), |w| {
            for variant in self.variants_except_group() {
                write_protoc_insertion_point_for_oneof_field(
                    w,
                    &self.customize.for_children,
                    &variant.field.proto_field.field,
                );
                w.write_line(&format!(
                    "{}({}),",
                    variant.oneof_field.oneof_variant_rust_name,
                    &variant
                        .rust_type(&self.file_and_mod())
                        .to_code(&self.customize.for_elem)
                ));
            }
        });
    }

    fn write_impl_oneof(&self, w: &mut CodeWriter) {
        w.impl_for_block(
            &format!("{}::Oneof", protobuf_crate_path(&self.customize.for_elem)),
            self.oneof.rust_name().ident.to_string(),
            |_w| {
                // nothing here yet
            },
        );
    }

    fn write_impl_oneof_full_fn_descriptor(&self, w: &mut CodeWriter) {
        let sig = format!(
            "descriptor() -> {}::reflect::OneofDescriptor",
            protobuf_crate_path(&self.customize.for_elem),
        );
        w.def_fn(&sig, |w| {
            w.lazy_static(
                "descriptor",
                &format!(
                    "{}::reflect::OneofDescriptor",
                    protobuf_crate_path(&self.customize.for_elem),
                ),
                &protobuf_crate_path(&self.customize.for_elem).to_string(),
            );
            let message_type = make_path(
                &self
                    .oneof
                    .message
                    .scope()
                    .rust_path_to_file()
                    .append(self.oneof.message.mod_name().into_rel_path()),
                &self.oneof.message.rust_name_to_file(),
            );
            let expr = format!(
                "<{} as {}::MessageFull>::descriptor().oneof_by_name(\"{}\").unwrap()",
                message_type,
                protobuf_crate_path(&self.customize.for_elem),
                self.oneof.oneof.name()
            );
            w.write_line(&format!("descriptor.get(|| {}).clone()", expr));
        });
    }

    fn write_impl_oneof_full(&self, w: &mut CodeWriter) {
        w.impl_for_block(
            &format!(
                "{}::OneofFull",
                protobuf_crate_path(&self.customize.for_elem)
            ),
            self.oneof.rust_name().ident.to_string(),
            |w| self.write_impl_oneof_full_fn_descriptor(w),
        )
    }

    fn write_generated_oneof_descriptor_data(&self, w: &mut CodeWriter) {
        let sig = format!(
            "generated_oneof_descriptor_data() -> {}::reflect::GeneratedOneofDescriptorData",
            protobuf_crate_path(&self.customize.for_elem)
        );
        w.fn_block(
            Visibility::Path(
                self.oneof
                    .rust_name()
                    .path
                    .into_relative_or_panic()
                    .to_reverse(),
            ),
            &sig,
            |w| {
                w.write_line(&format!(
                    "{}::reflect::GeneratedOneofDescriptorData::new::<{}>(\"{}\")",
                    protobuf_crate_path(&self.customize.for_elem),
                    &self.oneof.rust_name().ident,
                    self.oneof.oneof.name(),
                ));
            },
        );
    }

    fn write_impl_self(&self, w: &mut CodeWriter) {
        w.impl_self_block(&format!("{}", &self.oneof.rust_name().ident), |w| {
            if !self.lite_runtime {
                self.write_generated_oneof_descriptor_data(w);
            }
        });
    }

    pub fn write(&self, w: &mut CodeWriter) {
        self.write_enum(w);
        w.write_line("");
        self.write_impl_oneof(w);
        if !self.lite_runtime {
            w.write_line("");
            self.write_impl_oneof_full(w);
        }
        w.write_line("");
        self.write_impl_self(w);
    }
}

'''
'''--- protobuf-codegen/src/gen/paths.rs ---
use crate::gen::inside::protobuf_crate_path;
use crate::gen::rust::ident::RustIdent;
use crate::gen::rust::path::RustPath;
use crate::gen::strx;
use crate::gen::well_known_types::WELL_KNOWN_TYPES_PROTO_FILE_FULL_NAMES;
use crate::Customize;

// Copy-pasted from libsyntax.
fn ident_start(c: char) -> bool {
    (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '_'
}

// Copy-pasted from libsyntax.
fn ident_continue(c: char) -> bool {
    (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9') || c == '_'
}

pub(crate) fn proto_path_to_rust_mod(path: &str) -> RustIdent {
    let without_dir = strx::remove_to(path, std::path::is_separator);
    let without_suffix = strx::remove_suffix(without_dir, ".proto");

    let name = without_suffix
        .chars()
        .enumerate()
        .map(|(i, c)| {
            let valid = if i == 0 {
                ident_start(c)
            } else {
                ident_continue(c)
            };
            if valid {
                c
            } else {
                '_'
            }
        })
        .collect::<String>();

    RustIdent::new(&name)
}

/// Used in protobuf-codegen-identical-test
pub fn proto_name_to_rs(proto_file_path: &str) -> String {
    format!("{}.rs", proto_path_to_rust_mod(proto_file_path))
}

pub(crate) fn proto_path_to_fn_file_descriptor(
    proto_path: &str,
    customize: &Customize,
) -> RustPath {
    let protobuf_crate = protobuf_crate_path(customize);
    match proto_path {
        "rustproto.proto" => protobuf_crate.append("rustproto::file_descriptor".into()),
        "google/protobuf/descriptor.proto" => {
            protobuf_crate.append("descriptor::file_descriptor".into())
        }
        s if WELL_KNOWN_TYPES_PROTO_FILE_FULL_NAMES.contains(&s) => protobuf_crate
            .append_ident("well_known_types".into())
            .append_ident(proto_path_to_rust_mod(s))
            .append_ident("file_descriptor".into()),
        s => RustPath::super_path()
            .append_ident(proto_path_to_rust_mod(s))
            .append_ident("file_descriptor".into()),
    }
}

#[cfg(test)]
mod test {
    use super::proto_path_to_rust_mod;
    use crate::gen::rust::ident::RustIdent;

    #[test]
    fn test_mod_path_proto_ext() {
        assert_eq!(
            RustIdent::from("proto"),
            proto_path_to_rust_mod("proto.proto")
        );
    }

    #[test]
    fn test_mod_path_unknown_ext() {
        assert_eq!(
            RustIdent::from("proto_proto3"),
            proto_path_to_rust_mod("proto.proto3")
        );
    }

    #[test]
    fn test_mod_path_empty_ext() {
        assert_eq!(RustIdent::from("proto"), proto_path_to_rust_mod("proto"));
    }

    #[test]
    fn test_mod_path_dir() {
        assert_eq!(
            RustIdent::from("baz"),
            proto_path_to_rust_mod("foo/bar/baz.proto"),
        )
    }

    #[cfg(target_os = "windows")]
    #[test]
    fn test_mod_path_dir_backslashes() {
        assert_eq!(
            RustIdent::from("baz"),
            proto_path_to_rust_mod("foo\\bar\\baz.proto"),
        )
    }
}

'''
'''--- protobuf-codegen/src/gen/protoc_insertion_point.rs ---
use protobuf::reflect::EnumDescriptor;
use protobuf::reflect::EnumValueDescriptor;
use protobuf::reflect::FieldDescriptor;
use protobuf::reflect::MessageDescriptor;
use protobuf::reflect::OneofDescriptor;

use crate::gen::code_writer::CodeWriter;
use crate::Customize;

/// Write `// @protoc_insertion_point(...)` before the element.
///
/// This is similar to what `protoc` codegen does for C++ or Java.
/// This can be used to modify the generated code.
fn write_protoc_insertion_point(w: &mut CodeWriter, customize: &Customize, arg: &str) {
    for line in customize.before.iter().flat_map(|s| s.lines()) {
        w.write_line(line);
    }
    w.comment(&format!("@@protoc_insertion_point({})", arg));
}

pub(crate) fn write_protoc_insertion_point_for_message(
    w: &mut CodeWriter,
    customize: &Customize,
    message: &MessageDescriptor,
) {
    write_protoc_insertion_point(w, customize, &format!("message:{}", message.full_name()));
}

pub(crate) fn write_protoc_insertion_point_for_field(
    w: &mut CodeWriter,
    customize: &Customize,
    field: &FieldDescriptor,
) {
    write_protoc_insertion_point(w, customize, &format!("field:{}", field.full_name()));
}

pub(crate) fn write_protoc_insertion_point_for_special_field(
    w: &mut CodeWriter,
    customize: &Customize,
    message: &MessageDescriptor,
    field: &str,
) {
    write_protoc_insertion_point(
        w,
        customize,
        &format!("special_field:{}.{}", message.full_name(), field),
    );
}

pub(crate) fn write_protoc_insertion_point_for_enum(
    w: &mut CodeWriter,
    customize: &Customize,
    enumeration: &EnumDescriptor,
) {
    write_protoc_insertion_point(w, customize, &format!("enum:{}", enumeration.full_name()));
}

pub(crate) fn write_protoc_insertion_point_for_enum_value(
    w: &mut CodeWriter,
    customize: &Customize,
    value: &EnumValueDescriptor,
) {
    write_protoc_insertion_point(w, customize, &format!("enum_value:{}", value.full_name()));
}

pub(crate) fn write_protoc_insertion_point_for_oneof(
    w: &mut CodeWriter,
    customize: &Customize,
    oneof: &OneofDescriptor,
) {
    write_protoc_insertion_point(w, customize, &format!("oneof:{}", oneof.full_name()));
}

pub(crate) fn write_protoc_insertion_point_for_oneof_field(
    w: &mut CodeWriter,
    customize: &Customize,
    field: &FieldDescriptor,
) {
    write_protoc_insertion_point(w, customize, &format!("oneof_field:{}", field.full_name()));
}

'''
'''--- protobuf-codegen/src/gen/rust/component.rs ---
use std::fmt;
use std::fmt::Formatter;

use crate::gen::rust::ident::RustIdent;
use crate::gen::rust::keywords::parse_rust_keyword;

#[derive(Clone, Debug, PartialEq, Eq, Hash)]
pub(crate) enum RustPathComponent {
    Ident(RustIdent),
    Keyword(&'static str),
}

impl fmt::Display for RustPathComponent {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        match self {
            RustPathComponent::Ident(ident) => write!(f, "{}", ident),
            RustPathComponent::Keyword(keyword) => write!(f, "{}", keyword),
        }
    }
}

impl RustPathComponent {
    pub(crate) const SUPER: RustPathComponent = RustPathComponent::Keyword("super");

    pub(crate) fn parse(s: &str) -> RustPathComponent {
        if s.starts_with("r#") {
            RustPathComponent::Ident(RustIdent::new(&s[2..]))
        } else if let Some(kw) = parse_rust_keyword(s) {
            RustPathComponent::Keyword(kw)
        } else {
            RustPathComponent::Ident(RustIdent::new(s))
        }
    }
}

'''
'''--- protobuf-codegen/src/gen/rust/ident.rs ---
use std::fmt;

use crate::gen::rust::ident_with_path::RustIdentWithPath;
use crate::gen::rust::keywords::is_rust_keyword;
use crate::gen::rust::rel_path::RustRelativePath;

/// Valid Rust identifier
#[derive(Eq, PartialEq, Debug, Clone, Hash)]
pub(crate) struct RustIdent(String);

impl RustIdent {
    pub fn new(s: &str) -> RustIdent {
        assert!(!s.is_empty());
        assert!(!s.contains("/"), "{}", s);
        assert!(!s.contains("."), "{}", s);
        assert!(!s.contains(":"), "{}", s);
        assert!(!s.contains(" "), "{}", s);
        assert!(!s.contains("#"), "{}", s);
        RustIdent(s.to_owned())
    }

    pub(crate) fn get(&self) -> &str {
        &self.0
    }

    pub fn into_string(self) -> String {
        self.0
    }

    pub fn to_path(&self) -> RustIdentWithPath {
        RustIdentWithPath::from(&self.0)
    }

    pub(crate) fn into_rel_path(self) -> RustRelativePath {
        RustRelativePath::from_idents([self])
    }
}

impl fmt::Display for RustIdent {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        // Rust-protobuf uses `_` suffix to escape identifiers instead of raw identifiers
        // because some identifiers cannot be escaped as raw identifiers,
        // e.g. `r#self` is not a valid raw identifier.
        if is_rust_keyword(&self.0) {
            write!(f, "{}_", self.0)
        } else {
            write!(f, "{}", self.0)
        }
    }
}

impl From<&'_ str> for RustIdent {
    fn from(s: &str) -> Self {
        RustIdent::new(s)
    }
}

impl From<String> for RustIdent {
    fn from(s: String) -> Self {
        RustIdent::new(&s)
    }
}

'''
'''--- protobuf-codegen/src/gen/rust/ident_with_path.rs ---
use std::fmt;

use crate::gen::rust::component::RustPathComponent;
use crate::gen::rust::ident::RustIdent;
use crate::gen::rust::path::RustPath;

#[derive(Eq, PartialEq, Debug, Clone)]
pub(crate) struct RustIdentWithPath {
    pub path: RustPath,
    pub ident: RustIdent,
}

impl RustIdentWithPath {
    pub fn new(s: String) -> RustIdentWithPath {
        let mut path = RustPath::from(s);
        let ident = match path.path.path.pop() {
            None => panic!("empty path"),
            Some(RustPathComponent::Ident(ident)) => ident,
            Some(RustPathComponent::Keyword(kw)) => {
                panic!("last path component is a keyword: {}", kw)
            }
        };
        RustIdentWithPath { path, ident }
    }

    pub fn prepend_ident(&mut self, ident: RustIdent) {
        self.path.prepend_ident(ident)
    }

    pub fn to_path(&self) -> RustPath {
        self.path.clone().append_ident(self.ident.clone())
    }
}

impl<S: Into<String>> From<S> for RustIdentWithPath {
    fn from(s: S) -> Self {
        RustIdentWithPath::new(s.into())
    }
}

impl fmt::Display for RustIdentWithPath {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self.to_path(), f)
    }
}

'''
'''--- protobuf-codegen/src/gen/rust/keywords.rs ---
#[cfg_attr(rustfmt, rustfmt_skip)]
static RUST_KEYWORDS: &'static [&'static str] = &[
    "_",
    "as",
    "async",
    "await",
    "break",
    "crate",
    "dyn",
    "else",
    "enum",
    "extern",
    "false",
    "fn",
    "for",
    "if",
    "impl",
    "in",
    "let",
    "loop",
    "match",
    "mod",
    "move",
    "mut",
    "pub",
    "ref",
    "return",
    "static",
    "self",
    "Self",
    "struct",
    "super",
    "true",
    "trait",
    "type",
    "unsafe",
    "use",
    "while",
    "continue",
    "box",
    "const",
    "where",
    "virtual",
    "proc",
    "alignof",
    "become",
    "offsetof",
    "priv",
    "pure",
    "sizeof",
    "typeof",
    "unsized",
    "yield",
    "do",
    "abstract",
    "final",
    "override",
    "macro",
];

// https://internals.rust-lang.org/t/raw-identifiers-dont-work-for-all-identifiers/9094/3
#[cfg_attr(rustfmt, rustfmt_skip)]
static RUST_KEYWORDS_WHICH_CANNOT_BE_RAW: &'static [&'static str] = &[
    "super",
    "self",
    "Self",
    "extern",
    "crate",
];

pub(crate) fn parse_rust_keyword(word: &str) -> Option<&'static str> {
    RUST_KEYWORDS.iter().cloned().find(|&kw| kw == word)
}

pub(crate) fn is_rust_keyword(ident: &str) -> bool {
    parse_rust_keyword(ident).is_some()
}

#[allow(dead_code)]
pub(crate) fn is_rust_keyword_which_cannot_be_raw(ident: &str) -> bool {
    RUST_KEYWORDS_WHICH_CANNOT_BE_RAW
        .iter()
        .cloned()
        .find(|&kw| kw == ident)
        .is_some()
}

'''
'''--- protobuf-codegen/src/gen/rust/mod.rs ---
pub(crate) mod component;
pub(crate) mod ident;
pub(crate) mod ident_with_path;
pub(crate) mod keywords;
pub(crate) mod path;
pub(crate) mod quote;
pub(crate) mod rel_path;
pub(crate) mod snippets;

'''
'''--- protobuf-codegen/src/gen/rust/path.rs ---
use std::fmt;

use crate::gen::rust::component::RustPathComponent;
use crate::gen::rust::ident::RustIdent;
use crate::gen::rust::ident_with_path::RustIdentWithPath;
use crate::gen::rust::rel_path::RustRelativePath;

#[derive(Default, Eq, PartialEq, Debug, Clone)]
pub(crate) struct RustPath {
    pub(crate) absolute: bool,
    pub(crate) path: RustRelativePath,
}

impl RustPath {
    pub fn super_path() -> RustPath {
        RustPath::from("super")
    }

    pub fn is_absolute(&self) -> bool {
        self.absolute
    }

    pub fn with_ident(self, ident: RustIdent) -> RustIdentWithPath {
        RustIdentWithPath { path: self, ident }
    }

    pub fn first(&self) -> Option<RustPathComponent> {
        assert!(!self.absolute);
        self.path.first()
    }

    pub fn remove_first(&mut self) -> Option<RustPathComponent> {
        assert!(!self.absolute);
        self.path.remove_first()
    }

    pub fn prepend_ident(&mut self, ident: RustIdent) {
        assert!(!self.absolute);
        self.path.prepend_ident(ident);
    }

    pub fn append(self, path: RustPath) -> RustPath {
        if path.absolute {
            path
        } else {
            RustPath {
                absolute: self.absolute,
                path: self.path.append(path.path),
            }
        }
    }

    pub(crate) fn append_component(mut self, component: RustPathComponent) -> RustPath {
        self.path.path.push(component);
        self
    }

    pub fn append_ident(self, ident: RustIdent) -> RustPath {
        self.append_component(RustPathComponent::Ident(ident))
    }

    pub fn append_with_ident(self, path: RustIdentWithPath) -> RustIdentWithPath {
        self.append(path.path).with_ident(path.ident)
    }

    pub fn into_relative_or_panic(self) -> RustRelativePath {
        assert!(!self.absolute);
        self.path
    }
}

impl From<&'_ str> for RustPath {
    fn from(s: &str) -> Self {
        let (s, absolute) = if s.starts_with("::") {
            (&s[2..], true)
        } else {
            (s, false)
        };
        RustPath {
            absolute,
            path: RustRelativePath::from(s),
        }
    }
}

impl From<String> for RustPath {
    fn from(s: String) -> Self {
        RustPath::from(&s[..])
    }
}

impl fmt::Display for RustPath {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        if self.absolute {
            write!(f, "::")?;
        }
        write!(f, "{}", self.path)
    }
}

'''
'''--- protobuf-codegen/src/gen/rust/quote.rs ---
fn hex_digit(value: u32) -> char {
    if value < 10 {
        (b'0' + value as u8) as char
    } else if value < 0x10 {
        (b'a' + value as u8 - 10) as char
    } else {
        unreachable!()
    }
}

pub fn quote_escape_str(s: &str) -> String {
    let mut buf = String::new();
    buf.push('"');
    buf.extend(s.chars().flat_map(|c| c.escape_default()));
    buf.push('"');
    buf
}

pub fn quote_escape_bytes(bytes: &[u8]) -> String {
    let mut buf = String::new();
    buf.push('b');
    buf.push('"');
    for &b in bytes {
        match b {
            b'\n' => buf.push_str(r"\n"),
            b'\r' => buf.push_str(r"\r"),
            b'\t' => buf.push_str(r"\t"),
            b'"' => buf.push_str("\\\""),
            b'\\' => buf.push_str(r"\\"),
            b'\x20'..=b'\x7e' => buf.push(b as char),
            _ => {
                buf.push_str(r"\x");
                buf.push(hex_digit((b as u32) >> 4));
                buf.push(hex_digit((b as u32) & 0x0f));
            }
        }
    }
    buf.push('"');
    buf
}

#[cfg(test)]
mod test {

    use super::*;

    #[test]
    fn test_quote_escape_bytes() {
        assert_eq!("b\"\"", quote_escape_bytes(b""));
        assert_eq!("b\"xyZW\"", quote_escape_bytes(b"xyZW"));
        assert_eq!("b\"aa\\\"bb\"", quote_escape_bytes(b"aa\"bb"));
        assert_eq!("b\"aa\\r\\n\\tbb\"", quote_escape_bytes(b"aa\r\n\tbb"));
        assert_eq!(
            "b\"\\x00\\x01\\x12\\xfe\\xff\"",
            quote_escape_bytes(b"\x00\x01\x12\xfe\xff")
        );
    }
}

'''
'''--- protobuf-codegen/src/gen/rust/rel_path.rs ---
use std::fmt;
use std::iter;

use crate::gen::rust::component::RustPathComponent;
use crate::gen::rust::ident::RustIdent;
use crate::gen::rust::path::RustPath;

#[derive(Default, Eq, PartialEq, Debug, Clone)]
pub(crate) struct RustRelativePath {
    pub(crate) path: Vec<RustPathComponent>,
}

impl RustRelativePath {
    pub fn into_path(self) -> RustPath {
        RustPath {
            absolute: false,
            path: self,
        }
    }

    pub fn _empty() -> RustRelativePath {
        RustRelativePath { path: Vec::new() }
    }

    pub fn from_components<I: IntoIterator<Item = RustPathComponent>>(i: I) -> RustRelativePath {
        RustRelativePath {
            path: i.into_iter().collect(),
        }
    }

    pub fn from_idents<I: IntoIterator<Item = RustIdent>>(i: I) -> RustRelativePath {
        Self::from_components(i.into_iter().map(RustPathComponent::Ident))
    }

    pub fn is_empty(&self) -> bool {
        self.path.is_empty()
    }

    pub fn first(&self) -> Option<RustPathComponent> {
        self.path.iter().cloned().next()
    }

    pub fn remove_first(&mut self) -> Option<RustPathComponent> {
        if self.path.is_empty() {
            None
        } else {
            Some(self.path.remove(0))
        }
    }

    pub fn prepend_ident(&mut self, ident: RustIdent) {
        self.path.insert(0, RustPathComponent::Ident(ident));
    }

    pub fn append(mut self, path: RustRelativePath) -> RustRelativePath {
        for c in path.path {
            self.path.push(c);
        }
        self
    }

    pub fn push_ident(&mut self, ident: RustIdent) {
        self.path.push(RustPathComponent::Ident(ident));
    }

    pub fn append_ident(mut self, ident: RustIdent) -> RustRelativePath {
        self.push_ident(ident);
        self
    }

    pub fn to_reverse(&self) -> RustRelativePath {
        RustRelativePath::from_components(
            iter::repeat(RustPathComponent::SUPER).take(self.path.len()),
        )
    }
}

impl fmt::Display for RustRelativePath {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        for (i, c) in self.path.iter().enumerate() {
            if i != 0 {
                write!(f, "::")?;
            }
            write!(f, "{}", c)?;
        }
        Ok(())
    }
}

impl From<&'_ str> for RustRelativePath {
    fn from(s: &str) -> Self {
        assert!(!s.starts_with("::"), "path is absolute: {:?}", s);
        RustRelativePath {
            path: s.split("::").map(RustPathComponent::parse).collect(),
        }
    }
}

'''
'''--- protobuf-codegen/src/gen/rust/snippets.rs ---
pub(crate) const EXPR_NONE: &str = "::std::option::Option::None";
pub(crate) const EXPR_VEC_NEW: &str = "::std::vec::Vec::new()";

fn expr_vec_with_capacity(capacity: &str) -> String {
    format!("::std::vec::Vec::with_capacity({})", capacity)
}

pub(crate) fn expr_vec_with_capacity_const(capacity: usize) -> String {
    expr_vec_with_capacity(&capacity.to_string())
}

'''
'''--- protobuf-codegen/src/gen/rust_types_values.rs ---
use std::cmp;

use once_cell::sync::Lazy;
use protobuf::descriptor::*;
use protobuf::reflect::FileDescriptor;
use protobuf_parse::ProtobufAbsPath;
use regex::Regex;

use crate::customize::Customize;
use crate::gen::field::type_ext::TypeExt;
use crate::gen::file_and_mod::FileAndMod;
use crate::gen::inside::protobuf_crate_path;
use crate::gen::message::RustTypeMessage;
use crate::gen::paths::proto_path_to_rust_mod;
use crate::gen::rust::component::RustPathComponent;
use crate::gen::rust::ident::RustIdent;
use crate::gen::rust::ident_with_path::RustIdentWithPath;
use crate::gen::rust::path::RustPath;
use crate::gen::rust::rel_path::RustRelativePath;
use crate::gen::rust::snippets::EXPR_NONE;
use crate::gen::rust::snippets::EXPR_VEC_NEW;
use crate::gen::scope::RootScope;
use crate::gen::scope::WithScope;
use crate::gen::strx::capitalize;
use crate::gen::well_known_types::is_well_known_type_full;

// Represent subset of rust types used in generated code
#[derive(Debug, Clone, PartialEq, Eq)]
pub(crate) enum RustType {
    // integer: signed?, size in bits
    Int(bool, u32),
    // param is size in bits
    Float(u32),
    Bool,
    Vec(Box<RustType>),
    HashMap(Box<RustType>, Box<RustType>),
    String,
    // [T], not &[T]
    Slice(Box<RustType>),
    // str, not &str
    Str,
    Option(Box<RustType>),
    MessageField(Box<RustType>),
    // Box<T>
    Uniq(Box<RustType>),
    // &T
    Ref(Box<RustType>),
    // protobuf message
    Message(RustTypeMessage),
    // protobuf enum, not any enum
    Enum(RustIdentWithPath, RustIdent, i32),
    // protobuf enum or unknown
    EnumOrUnknown(RustIdentWithPath, RustIdent, i32),
    // oneof enum
    Oneof(RustIdentWithPath),
    // bytes::Bytes
    Bytes,
    // chars::Chars
    Chars,
    // group
    Group,
}

impl RustType {
    #[inline]
    pub(crate) fn to_code(&self, customize: &Customize) -> String {
        match *self {
            RustType::Int(true, bits) => format!("i{}", bits),
            RustType::Int(false, bits) => format!("u{}", bits),
            RustType::Float(bits) => format!("f{}", bits),
            RustType::Bool => format!("bool"),
            RustType::Vec(ref param) => format!("::std::vec::Vec<{}>", param.to_code(customize)),
            RustType::HashMap(ref key, ref value) => format!(
                "::std::collections::HashMap<{}, {}>",
                key.to_code(customize),
                value.to_code(customize)
            ),
            RustType::String => format!("::std::string::String"),
            RustType::Slice(ref param) => format!("[{}]", param.to_code(customize)),
            RustType::Str => format!("str"),
            RustType::Option(ref param) => {
                format!("::std::option::Option<{}>", param.to_code(customize))
            }
            RustType::MessageField(ref param) => format!(
                "{}::MessageField<{}>",
                protobuf_crate_path(customize),
                param.to_code(customize)
            ),
            RustType::Uniq(ref param) => format!("::std::boxed::Box<{}>", param.to_code(customize)),
            RustType::Ref(ref param) => format!("&{}", param.to_code(customize)),
            RustType::Message(ref name) => format!("{}", name),
            RustType::Enum(ref name, ..) | RustType::Oneof(ref name) => format!("{}", name),
            RustType::EnumOrUnknown(ref name, ..) => format!(
                "{}::EnumOrUnknown<{}>",
                protobuf_crate_path(customize),
                name
            ),
            RustType::Group => format!("<group>"),
            RustType::Bytes => format!("::bytes::Bytes"),
            RustType::Chars => format!("{}::Chars", protobuf_crate_path(customize)),
        }
    }
}

impl RustType {
    pub(crate) fn u8() -> RustType {
        RustType::Int(false, 8)
    }

    pub(crate) fn i32() -> RustType {
        RustType::Int(true, 32)
    }

    /// `&str`.
    pub(crate) fn amp_str() -> RustType {
        RustType::Str.wrap_ref()
    }

    /// `&[u8]`.
    pub(crate) fn amp_slice_of_u8() -> RustType {
        RustType::u8().wrap_slice().wrap_ref()
    }

    /// Type is rust primitive?
    pub(crate) fn is_primitive(&self) -> bool {
        match *self {
            RustType::Int(..) | RustType::Float(..) | RustType::Bool => true,
            _ => false,
        }
    }

    pub fn is_u8(&self) -> bool {
        match *self {
            RustType::Int(false, 8) => true,
            _ => false,
        }
    }

    pub fn is_copy(&self) -> bool {
        if self.is_primitive() {
            true
        } else if let RustType::Enum(..) = *self {
            true
        } else if let RustType::EnumOrUnknown(..) = *self {
            true
        } else {
            false
        }
    }

    fn is_str(&self) -> bool {
        match *self {
            RustType::Str => true,
            _ => false,
        }
    }

    fn is_string(&self) -> bool {
        match *self {
            RustType::String => true,
            _ => false,
        }
    }

    fn is_slice(&self) -> Option<&RustType> {
        match *self {
            RustType::Slice(ref v) => Some(&**v),
            _ => None,
        }
    }

    fn is_slice_u8(&self) -> bool {
        match self.is_slice() {
            Some(t) => t.is_u8(),
            None => false,
        }
    }

    fn is_message(&self) -> bool {
        match *self {
            RustType::Message(..) => true,
            _ => false,
        }
    }

    fn is_enum(&self) -> bool {
        match *self {
            RustType::Enum(..) => true,
            _ => false,
        }
    }

    fn is_enum_or_unknown(&self) -> bool {
        match *self {
            RustType::EnumOrUnknown(..) => true,
            _ => false,
        }
    }

    pub fn is_ref(&self) -> Option<&RustType> {
        match *self {
            RustType::Ref(ref v) => Some(&**v),
            _ => None,
        }
    }

    pub fn is_box(&self) -> Option<&RustType> {
        match *self {
            RustType::Uniq(ref v) => Some(&**v),
            _ => None,
        }
    }

    // default value for type
    pub fn default_value(&self, customize: &Customize, const_expr: bool) -> String {
        match *self {
            RustType::Ref(ref t) if t.is_str() => "\"\"".to_string(),
            RustType::Ref(ref t) if t.is_slice().is_some() => "&[]".to_string(),
            RustType::Int(..) => "0".to_string(),
            RustType::Float(..) => "0.".to_string(),
            RustType::Bool => "false".to_string(),
            RustType::Vec(..) => EXPR_VEC_NEW.to_string(),
            RustType::HashMap(..) => "::std::collections::HashMap::new()".to_string(),
            RustType::String => "::std::string::String::new()".to_string(),
            RustType::Bytes => "::bytes::Bytes::new()".to_string(),
            RustType::Chars => format!("{}::Chars::new()", protobuf_crate_path(customize)),
            RustType::Option(..) => EXPR_NONE.to_string(),
            RustType::MessageField(..) => {
                format!("{}::MessageField::none()", protobuf_crate_path(customize))
            }
            RustType::Message(ref name) => format!("{}::new()", name),
            RustType::Ref(ref m) if m.is_message() => match **m {
                RustType::Message(ref name) => name.default_instance(customize),
                _ => unreachable!(),
            },
            // Note: default value of enum type may not be equal to default value of field
            RustType::Enum(ref name, ref default, ..) => format!("{}::{}", name, default),
            RustType::EnumOrUnknown(_, _, number) if const_expr => format!(
                "{}::EnumOrUnknown::from_i32({})",
                protobuf_crate_path(customize),
                number,
            ),
            RustType::EnumOrUnknown(ref name, ref default, ..) if !const_expr => format!(
                "{}::EnumOrUnknown::new({}::{})",
                protobuf_crate_path(customize),
                name,
                default
            ),
            _ => panic!("cannot create default value for: {:?}", self),
        }
    }

    pub fn default_value_typed(self, customize: &Customize, const_expr: bool) -> RustValueTyped {
        RustValueTyped {
            value: self.default_value(customize, const_expr),
            rust_type: self,
        }
    }

    /// Emit a code to clear a variable `v`
    pub fn clear(&self, v: &str, customize: &Customize) -> String {
        match *self {
            RustType::Option(..) => format!("{} = {}", v, EXPR_NONE),
            RustType::Vec(..)
            | RustType::Bytes
            | RustType::Chars
            | RustType::String
            | RustType::MessageField(..)
            | RustType::HashMap(..) => format!("{}.clear()", v),
            RustType::Bool
            | RustType::Float(..)
            | RustType::Int(..)
            | RustType::Enum(..)
            | RustType::EnumOrUnknown(..) => {
                format!("{} = {}", v, self.default_value(customize, false))
            }
            ref ty => panic!("cannot clear type: {:?}", ty),
        }
    }

    // expression to convert `v` of type `self` to type `target`
    pub fn into_target(&self, target: &RustType, v: &str, customize: &Customize) -> String {
        self.try_into_target(target, v, customize)
            .expect(&format!("failed to convert {:?} into {:?}", self, target))
    }

    // https://github.com/rust-lang-nursery/rustfmt/issues/3131
    #[cfg_attr(rustfmt, rustfmt_skip)]
    fn try_into_target(&self, target: &RustType, v: &str, customize: &Customize) -> Result<String, ()> {
        {
            if let Some(t1) = self.is_ref().and_then(|t| t.is_box()) {
                if let Some(t2) = target.is_ref() {
                    if t1 == t2 {
                        return Ok(format!("&**{}", v));
                    }
                }
            }
        }

        match (self, target) {
            (x, y) if x == y => return Ok(format!("{}", v)),
            (&RustType::Ref(ref x), y) if **x == *y => return Ok(format!("*{}", v)),
            (x, &RustType::Uniq(ref y)) if *x == **y => {
                return Ok(format!("::std::boxed::Box::new({})", v))
            }
            (&RustType::Uniq(ref x), y) if **x == *y => return Ok(format!("*{}", v)),
            (&RustType::String, &RustType::Ref(ref t)) if **t == RustType::Str => {
                return Ok(format!("&{}", v))
            }
            (&RustType::Chars, &RustType::Ref(ref t)) if **t == RustType::Str => {
                return Ok(format!("&{}", v))
            }
            (&RustType::Ref(ref t1), &RustType::Ref(ref t2)) if t1.is_string() && t2.is_str() => {
                return Ok(format!("&{}", v))
            }
            (&RustType::Ref(ref t1), &RustType::String)
                if match **t1 {
                       RustType::Str => true,
                       _ => false,
                   } => return Ok(format!("{}.to_owned()", v)),
            (&RustType::Ref(ref t1), &RustType::Chars)
                if match **t1 {
                       RustType::Str => true,
                       _ => false,
                   } => {
                return Ok(format!("<{}::Chars as ::std::convert::From<_>>::from({}.to_owned())",
                    protobuf_crate_path(customize), v))
            },
            (&RustType::Ref(ref t1), &RustType::Vec(ref t2))
                if match (&**t1, &**t2) {
                       (&RustType::Slice(ref x), ref y) => **x == **y,
                       _ => false,
                   } => return Ok(format!("{}.to_vec()", v)),
            (&RustType::Ref(ref t1), &RustType::Bytes)
                if t1.is_slice_u8() =>
                    return Ok(format!("<::bytes::Bytes as ::std::convert::From<_>>::from({}.to_vec())", v)),
            (&RustType::Vec(ref x), &RustType::Ref(ref t))
                if match **t {
                       RustType::Slice(ref y) => x == y,
                       _ => false,
                   } => return Ok(format!("&{}", v)),
            (&RustType::Bytes, &RustType::Ref(ref t))
                if match **t {
                       RustType::Slice(ref y) => **y == RustType::u8(),
                       _ => false,
                   } => return Ok(format!("&{}", v)),
            (&RustType::Ref(ref t1), &RustType::Ref(ref t2))
                if match (&**t1, &**t2) {
                       (&RustType::Vec(ref x), &RustType::Slice(ref y)) => x == y,
                       _ => false,
                   } => return Ok(format!("&{}", v)),
            (&RustType::Enum(..), &RustType::Int(true, 32)) => {
                return Ok(format!("{}::Enum::value(&{})", protobuf_crate_path(customize), v))
            },
            (&RustType::EnumOrUnknown(..), &RustType::Int(true, 32)) => {
                return Ok(format!("{}::EnumOrUnknown::value(&{})", protobuf_crate_path(customize), v))
            },
            (&RustType::Ref(ref t), &RustType::Int(true, 32)) if t.is_enum() => {
                return Ok(format!("{}::Enum::value({})", protobuf_crate_path(customize), v))
            }
            (&RustType::Ref(ref t), &RustType::Int(true, 32)) if t.is_enum_or_unknown() => {
                return Ok(format!("{}::EnumOrUnknown::value({})", protobuf_crate_path(customize), v))
            },
            (&RustType::EnumOrUnknown(ref f, ..), &RustType::Enum(ref t, ..)) if f == t => {
                return Ok(format!("{}::EnumOrUnknown::enum_value_or_default(&{})", protobuf_crate_path(customize), v))
            }
            (&RustType::Enum(ref f, ..), &RustType::EnumOrUnknown(ref t, ..)) if f == t => {
                return Ok(format!("{}::EnumOrUnknown::new({})", protobuf_crate_path(customize), v))
            }
            _ => (),
        };

        if let &RustType::Ref(ref s) = self {
            if let Ok(conv) = s.try_into_target(target, v, customize) {
                return Ok(conv);
            }
        }

        Err(())
    }

    /// Type to view data of this type
    pub fn ref_type(&self) -> RustType {
        RustType::Ref(Box::new(match self {
            &RustType::String | &RustType::Chars => RustType::Str,
            &RustType::Vec(ref p) => RustType::Slice(p.clone()),
            &RustType::Bytes => RustType::Slice(Box::new(RustType::u8())),
            &RustType::Message(ref p) => RustType::Message(p.clone()),
            &RustType::Uniq(ref p) => RustType::Uniq(p.clone()),
            x => panic!("no ref type for {:?}", x),
        }))
    }

    pub(crate) fn wrap_ref(&self) -> RustType {
        RustType::Ref(Box::new(self.clone()))
    }

    pub(crate) fn wrap_slice(&self) -> RustType {
        RustType::Slice(Box::new(self.clone()))
    }

    pub fn elem_type(&self) -> RustType {
        match self {
            &RustType::Option(ref ty) => (**ty).clone(),
            &RustType::MessageField(ref ty) => (**ty).clone(),
            x => panic!("cannot get elem type of {:?}", x),
        }
    }

    // type of `v` in `for v in xxx`
    pub fn iter_elem_type(&self) -> RustType {
        match self {
            &RustType::Vec(ref ty)
            | &RustType::Option(ref ty)
            | &RustType::MessageField(ref ty) => RustType::Ref(ty.clone()),
            x => panic!("cannot iterate {:?}", x),
        }
    }

    pub fn value(self, value: String) -> RustValueTyped {
        RustValueTyped {
            value: value,
            rust_type: self,
        }
    }
}

/// Representation of an expression in code generator: text and type
pub(crate) struct RustValueTyped {
    pub value: String,
    pub rust_type: RustType,
}

impl RustValueTyped {
    pub fn into_type(&self, target: RustType, customize: &Customize) -> RustValueTyped {
        let target_value = self.rust_type.into_target(&target, &self.value, customize);
        RustValueTyped {
            value: target_value,
            rust_type: target,
        }
    }

    pub fn boxed(self, customize: &Customize) -> RustValueTyped {
        self.into_type(RustType::Uniq(Box::new(self.rust_type.clone())), customize)
    }
}

fn file_last_component(file: &str) -> &str {
    let bs = file.rfind('\\').map(|i| i + 1).unwrap_or(0);
    let fs = file.rfind('/').map(|i| i + 1).unwrap_or(0);
    &file[cmp::max(fs, bs)..]
}

#[cfg(test)]
#[test]
fn test_file_last_component() {
    assert_eq!("ab.proto", file_last_component("ab.proto"));
    assert_eq!("ab.proto", file_last_component("xx/ab.proto"));
    assert_eq!("ab.proto", file_last_component("xx\\ab.proto"));
    assert_eq!("ab.proto", file_last_component("yy\\xx\\ab.proto"));
}

fn is_descriptor_proto(file: &FileDescriptor) -> bool {
    file.package() == "google.protobuf" && file_last_component(file.name()) == "descriptor.proto"
}

fn make_path_to_path(source: &RustRelativePath, dest: &RustPath) -> RustPath {
    if dest.is_absolute() {
        return dest.clone();
    }

    let mut source = source.clone();
    let mut dest = dest.clone();
    while !source.is_empty() && source.first() == dest.first() {
        source.remove_first().unwrap();
        dest.remove_first().unwrap();
    }
    source.to_reverse().into_path().append(dest)
}

pub(crate) fn make_path(source: &RustRelativePath, dest: &RustIdentWithPath) -> RustIdentWithPath {
    make_path_to_path(source, &dest.path).with_ident(dest.ident.clone())
}

pub(crate) fn message_or_enum_to_rust_relative(
    message_or_enum: &dyn WithScope,
    current: &FileAndMod,
) -> RustIdentWithPath {
    let same_file = message_or_enum.file_descriptor().name() == current.file;
    if same_file {
        // field type is a message or enum declared in the same file
        make_path(&current.relative_mod, &message_or_enum.rust_name_to_file())
    } else if let Some(name) = is_well_known_type_full(&message_or_enum.name_absolute()) {
        // Well-known types are included in rust-protobuf library
        // https://developers.google.com/protocol-buffers/docs/reference/google.protobuf
        let file_descriptor = message_or_enum.file_descriptor();
        static REGEX: Lazy<Regex> =
            Lazy::new(|| Regex::new(r"^google/protobuf/([^/]+\.proto)$").unwrap());
        let captures = REGEX
            .captures(file_descriptor.name())
            .unwrap_or_else(|| panic!("`{}` does not match the regex", file_descriptor.name()));
        let file_name = captures.get(1).unwrap().as_str();
        let mod_name = proto_path_to_rust_mod(file_name);
        RustIdentWithPath::from(format!(
            "{protobuf_crate}::well_known_types::{mod_name}::{name}",
            protobuf_crate = protobuf_crate_path(&current.customize),
        ))
    } else if is_descriptor_proto(&message_or_enum.file_descriptor()) {
        // Messages defined in descriptor.proto
        RustIdentWithPath::from(format!(
            "{}::descriptor::{}",
            protobuf_crate_path(&current.customize),
            message_or_enum.rust_name_to_file()
        ))
    } else {
        current
            .relative_mod
            .to_reverse()
            .into_path()
            .append_component(RustPathComponent::SUPER)
            .append_with_ident(message_or_enum.rust_name_with_file())
    }
}

pub(crate) fn type_name_to_rust_relative(
    type_name: &ProtobufAbsPath,
    current: &FileAndMod,
    root_scope: &RootScope,
) -> RustIdentWithPath {
    assert!(!type_name.is_root());
    let message_or_enum = root_scope.find_message_or_enum(type_name);
    message_or_enum_to_rust_relative(&message_or_enum, current)
}

#[derive(Copy, Clone, Debug, PartialEq, Eq)]
pub enum PrimitiveTypeVariant {
    Default,
    TokioBytes,
}

pub enum _TokioBytesType {
    Bytes,
    Chars,
}

// ProtobufType trait name
pub(crate) enum ProtobufTypeGen {
    Primitive(field_descriptor_proto::Type, PrimitiveTypeVariant),
    Message(RustTypeMessage),
    EnumOrUnknown(RustIdentWithPath),
}

impl ProtobufTypeGen {
    pub(crate) fn protobuf_value(&self, customize: &Customize) -> String {
        match self {
            ProtobufTypeGen::Primitive(t, PrimitiveTypeVariant::Default) => {
                t.rust_type().to_code(customize)
            }
            ProtobufTypeGen::Primitive(_, PrimitiveTypeVariant::TokioBytes) => unimplemented!(),
            ProtobufTypeGen::Message(m) => m.0.to_string(),
            ProtobufTypeGen::EnumOrUnknown(e) => format!(
                "{protobuf_crate}::EnumOrUnknown<{e}>",
                protobuf_crate = protobuf_crate_path(customize)
            ),
        }
    }

    pub(crate) fn _rust_type(&self, customize: &Customize) -> String {
        match self {
            &ProtobufTypeGen::Primitive(t, PrimitiveTypeVariant::Default) => format!(
                "{}::reflect::types::ProtobufType{}",
                protobuf_crate_path(customize),
                capitalize(t.protobuf_name())
            ),
            &ProtobufTypeGen::Primitive(
                field_descriptor_proto::Type::TYPE_BYTES,
                PrimitiveTypeVariant::TokioBytes,
            ) => format!(
                "{}::reflect::types::ProtobufTypeTokioBytes",
                protobuf_crate_path(customize)
            ),
            &ProtobufTypeGen::Primitive(
                field_descriptor_proto::Type::TYPE_STRING,
                PrimitiveTypeVariant::TokioBytes,
            ) => format!(
                "{}::reflect::types::ProtobufTypeTokioChars",
                protobuf_crate_path(customize)
            ),
            &ProtobufTypeGen::Primitive(.., PrimitiveTypeVariant::TokioBytes) => unreachable!(),
            &ProtobufTypeGen::Message(ref name) => format!(
                "{}::reflect::types::ProtobufTypeMessage<{}>",
                protobuf_crate_path(customize),
                name
            ),
            &ProtobufTypeGen::EnumOrUnknown(ref name) => format!(
                "{}::reflect::types::ProtobufTypeEnumOrUnknown<{}>",
                protobuf_crate_path(customize),
                name
            ),
        }
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn into_target_ref_box_to_ref() {
        let t1 = RustType::Ref(Box::new(RustType::Uniq(Box::new(RustType::Message(
            RustTypeMessage::from("Ab"),
        )))));
        let t2 = RustType::Ref(Box::new(RustType::Message(RustTypeMessage::from("Ab"))));

        assert_eq!("&**v", t1.into_target(&t2, "v", &Customize::default()));
    }
}

'''
'''--- protobuf-codegen/src/gen/scope.rs ---
use std::ops::Deref;

use protobuf::reflect::EnumDescriptor;
use protobuf::reflect::EnumValueDescriptor;
use protobuf::reflect::FieldDescriptor;
use protobuf::reflect::FileDescriptor;
use protobuf::reflect::MessageDescriptor;
use protobuf::reflect::OneofDescriptor;
use protobuf_parse::ProtobufAbsPath;
use protobuf_parse::ProtobufAbsPathRef;
use protobuf_parse::ProtobufIdentRef;
use protobuf_parse::ProtobufRelPath;
use protobuf_parse::ProtobufRelPathRef;

use crate::customize::Customize;
use crate::gen::field::rust_field_name_for_protobuf_field_name;
use crate::gen::file_and_mod::FileAndMod;
use crate::gen::map::map_entry;
use crate::gen::message::message_name_to_nested_mod_name;
use crate::gen::paths::proto_path_to_rust_mod;
use crate::gen::rust::ident::RustIdent;
use crate::gen::rust::ident_with_path::RustIdentWithPath;
use crate::gen::rust::rel_path::RustRelativePath;
use crate::gen::strx::capitalize;

pub(crate) struct RootScope<'a> {
    pub file_descriptors: &'a [FileDescriptor],
}

impl<'a> RootScope<'a> {
    fn packages(&'a self) -> Vec<FileScope<'a>> {
        self.file_descriptors
            .iter()
            .map(|fd| FileScope {
                file_descriptor: fd,
            })
            .collect()
    }

    // find enum by fully qualified name
    pub fn _find_enum(&'a self, fqn: &ProtobufAbsPath) -> EnumWithScope<'a> {
        match self.find_message_or_enum(fqn) {
            MessageOrEnumWithScope::Enum(e) => e,
            _ => panic!("not an enum: {}", fqn),
        }
    }

    // find message by fully qualified name
    pub fn find_message(&'a self, fqn: &ProtobufAbsPath) -> MessageWithScope<'a> {
        match self.find_message_or_enum(fqn) {
            MessageOrEnumWithScope::Message(m) => m,
            _ => panic!("not a message: {}", fqn),
        }
    }

    // find message or enum by fully qualified name
    pub fn find_message_or_enum(&'a self, fqn: &ProtobufAbsPath) -> MessageOrEnumWithScope<'a> {
        assert!(!fqn.is_root());
        self.packages()
            .into_iter()
            .flat_map(|p| p.find_message_or_enum_abs(fqn))
            .next()
            .expect(&format!("enum not found by name: {}", fqn))
    }
}

#[derive(Clone, Debug)]
pub(crate) struct FileScope<'a> {
    pub file_descriptor: &'a FileDescriptor,
}

impl<'a> Deref for FileScope<'a> {
    type Target = FileDescriptor;

    fn deref(&self) -> &Self::Target {
        self.file_descriptor
    }
}

impl<'a> FileScope<'a> {
    fn package(&self) -> ProtobufAbsPath {
        ProtobufAbsPath::package_from_file_descriptor(self.file_descriptor)
    }

    pub fn to_scope(&self) -> Scope<'a> {
        Scope {
            file_scope: self.clone(),
            path: Vec::new(),
        }
    }

    fn find_message_or_enum(
        &self,
        name: &ProtobufRelPathRef,
    ) -> Option<MessageOrEnumWithScope<'a>> {
        self.find_messages_and_enums()
            .into_iter()
            .filter(|e| e.protobuf_name_to_package().as_ref() == name)
            .next()
    }

    fn find_message_or_enum_abs(
        &self,
        name: &ProtobufAbsPathRef,
    ) -> Option<MessageOrEnumWithScope<'a>> {
        let name = name.to_owned();
        match name.remove_prefix(&self.package()) {
            Some(rem) => self.find_message_or_enum(&rem),
            None => None,
        }
    }

    // find all enums in given file descriptor
    pub fn find_enums(&self) -> Vec<EnumWithScope<'a>> {
        let mut r = Vec::new();

        self.to_scope().walk_scopes(|scope| {
            r.extend(scope.enums());
        });

        r
    }

    /// Find all messages in given file descriptor
    pub fn find_messages(&self) -> Vec<MessageWithScope<'a>> {
        let mut r = Vec::new();

        self.to_scope().walk_scopes(|scope| {
            r.extend(scope.messages());
        });

        r
    }

    /// Find all messages in given file descriptor, except map messages
    pub fn find_messages_except_map(&self) -> Vec<MessageWithScope<'a>> {
        self.find_messages()
            .into_iter()
            .filter(|m| !m.is_map())
            .collect()
    }

    /// find all messages and enums in given file descriptor
    pub fn find_messages_and_enums(&self) -> Vec<MessageOrEnumWithScope<'a>> {
        let mut r = Vec::new();

        self.to_scope().walk_scopes(|scope| {
            r.extend(scope.messages_and_enums());
        });

        r
    }
}

#[derive(Clone, Debug)]
pub(crate) struct Scope<'a> {
    pub file_scope: FileScope<'a>,
    pub path: Vec<MessageDescriptor>,
}

impl<'a> Scope<'a> {
    pub(crate) fn file_descriptor(&self) -> FileDescriptor {
        self.file_scope.file_descriptor.clone()
    }

    // get message descriptors in this scope
    fn message_descriptors(&self) -> Vec<MessageDescriptor> {
        if self.path.is_empty() {
            self.file_scope.file_descriptor.messages().collect()
        } else {
            self.path.last().unwrap().nested_messages().collect()
        }
    }

    // get enum descriptors in this scope
    fn enum_descriptors(&self) -> Vec<EnumDescriptor> {
        if self.path.is_empty() {
            self.file_scope.file_descriptor.enums().collect()
        } else {
            self.path.last().unwrap().nested_enums().collect()
        }
    }

    // get messages with attached scopes in this scope
    pub fn messages(&self) -> Vec<MessageWithScope<'a>> {
        self.message_descriptors()
            .into_iter()
            .map(|message| MessageWithScope {
                scope: self.clone(),
                message,
            })
            .collect()
    }

    // get enums with attached scopes in this scope
    pub fn enums(&self) -> Vec<EnumWithScope<'a>> {
        self.enum_descriptors()
            .into_iter()
            .map(|en| EnumWithScope {
                scope: self.clone(),
                en,
            })
            .collect()
    }

    // get messages and enums with attached scopes in this scope
    pub fn messages_and_enums(&self) -> Vec<MessageOrEnumWithScope<'a>> {
        self.messages()
            .into_iter()
            .map(|m| MessageOrEnumWithScope::Message(m))
            .chain(
                self.enums()
                    .into_iter()
                    .map(|m| MessageOrEnumWithScope::Enum(m)),
            )
            .collect()
    }

    // nested scopes, i. e. scopes of nested messages
    fn nested_scopes(&self) -> Vec<Scope<'a>> {
        self.message_descriptors()
            .into_iter()
            .map(|m| {
                let mut nested = self.clone();
                nested.path.push(m);
                nested
            })
            .collect()
    }

    fn walk_scopes_impl<F: FnMut(&Scope<'a>)>(&self, callback: &mut F) {
        (*callback)(self);

        for nested in self.nested_scopes() {
            nested.walk_scopes_impl(callback);
        }
    }

    // apply callback for this scope and all nested scopes
    fn walk_scopes<F>(&self, mut callback: F)
    where
        F: FnMut(&Scope<'a>),
    {
        self.walk_scopes_impl(&mut callback);
    }

    pub fn rust_path_to_file(&self) -> RustRelativePath {
        RustRelativePath::from_idents(
            self.path
                .iter()
                .map(|m| message_name_to_nested_mod_name(m.name())),
        )
    }

    pub fn path_str(&self) -> String {
        let v: Vec<&str> = self.path.iter().map(|m| m.name()).collect();
        v.join(".")
    }

    pub fn prefix(&self) -> String {
        let path_str = self.path_str();
        if path_str.is_empty() {
            path_str
        } else {
            format!("{}.", path_str)
        }
    }

    pub fn protobuf_path_to_file(&self) -> ProtobufRelPath {
        ProtobufRelPath::from_components(self.path.iter().map(|m| ProtobufIdentRef::new(m.name())))
    }

    pub fn protobuf_absolute_path(&self) -> ProtobufAbsPath {
        let mut r = self.file_scope.package();
        r.push_relative(&self.protobuf_path_to_file());
        r
    }

    pub fn file_and_mod(&self, customize: Customize) -> FileAndMod {
        FileAndMod {
            file: self.file_scope.file_descriptor.proto().name().to_owned(),
            relative_mod: self.rust_path_to_file(),
            customize,
        }
    }
}

pub(crate) trait WithScope<'a> {
    fn scope(&self) -> &Scope<'a>;

    fn file_descriptor(&self) -> FileDescriptor {
        self.scope().file_descriptor()
    }

    // message or enum name
    fn name(&self) -> &ProtobufIdentRef;

    fn name_to_package(&self) -> String {
        let mut r = self.scope().prefix();
        r.push_str(&self.name());
        r
    }

    fn protobuf_name_to_package(&self) -> ProtobufRelPath {
        let r = self.scope().protobuf_path_to_file();
        r.append_ident(ProtobufIdentRef::new(self.name()))
    }

    /// Return absolute name starting with dot
    fn name_absolute(&self) -> ProtobufAbsPath {
        let mut path = self.scope().protobuf_absolute_path();
        path.push_simple(self.name());
        path
    }

    // rust type name of this descriptor
    fn rust_name(&self) -> RustIdent {
        let rust_name = capitalize(&self.name());
        RustIdent::new(&rust_name)
    }

    fn rust_name_to_file(&self) -> RustIdentWithPath {
        self.scope()
            .rust_path_to_file()
            .into_path()
            .with_ident(self.rust_name())
    }

    // fully-qualified name of this type
    fn rust_name_with_file(&self) -> RustIdentWithPath {
        let mut r = self.rust_name_to_file();
        r.prepend_ident(proto_path_to_rust_mod(
            self.scope().file_descriptor().name(),
        ));
        r
    }
}

#[derive(Clone, Debug)]
pub(crate) struct MessageWithScope<'a> {
    pub scope: Scope<'a>,
    pub message: MessageDescriptor,
}

impl<'a> WithScope<'a> for MessageWithScope<'a> {
    fn scope(&self) -> &Scope<'a> {
        &self.scope
    }

    fn name(&self) -> &ProtobufIdentRef {
        ProtobufIdentRef::new(self.message.name())
    }
}

impl<'a> MessageWithScope<'a> {
    pub fn into_scope(mut self) -> Scope<'a> {
        self.scope.path.push(self.message);
        self.scope
    }

    pub fn to_scope(&self) -> Scope<'a> {
        self.clone().into_scope()
    }

    pub fn fields(&self) -> Vec<FieldWithContext<'a>> {
        self.message
            .fields()
            .into_iter()
            .map(|field| FieldWithContext {
                field,
                message: self.clone(),
            })
            .collect()
    }

    pub fn oneofs(&self) -> Vec<OneofWithContext<'a>> {
        self.message
            .oneofs()
            .into_iter()
            .map(|oneof| OneofWithContext {
                message: self.clone(),
                oneof,
            })
            .collect()
    }

    pub fn mod_name(&self) -> RustIdent {
        message_name_to_nested_mod_name(self.message.name())
    }

    /// This message is a special message which is a map.
    pub fn is_map(&self) -> bool {
        map_entry(self).is_some()
    }
}

#[derive(Clone, Debug)]
pub(crate) struct EnumWithScope<'a> {
    pub scope: Scope<'a>,
    pub en: EnumDescriptor,
}

impl<'a> EnumWithScope<'a> {
    pub fn values(&self) -> Vec<EnumValueWithContext<'a>> {
        self.en
            .values()
            .into_iter()
            .map(|v| EnumValueWithContext {
                en: self.clone(),
                proto: v,
            })
            .collect()
    }

    // find enum value by protobuf name
    pub fn value_by_name(&self, name: &str) -> EnumValueWithContext<'a> {
        self.values()
            .into_iter()
            .find(|v| v.proto.proto().name() == name)
            .unwrap()
    }
}

#[derive(Clone, Debug)]
pub(crate) struct EnumValueWithContext<'a> {
    pub en: EnumWithScope<'a>,
    pub proto: EnumValueDescriptor,
}

impl<'a> EnumValueWithContext<'a> {
    pub fn rust_name(&self) -> RustIdent {
        // TODO: camel case or something.
        RustIdent::new(self.proto.name())
    }
}

impl<'a> WithScope<'a> for EnumWithScope<'a> {
    fn scope(&self) -> &Scope<'a> {
        &self.scope
    }

    fn name(&self) -> &ProtobufIdentRef {
        ProtobufIdentRef::new(self.en.name())
    }
}

pub(crate) enum MessageOrEnumWithScope<'a> {
    Message(MessageWithScope<'a>),
    Enum(EnumWithScope<'a>),
}

impl<'a> WithScope<'a> for MessageOrEnumWithScope<'a> {
    fn scope(&self) -> &Scope<'a> {
        match self {
            MessageOrEnumWithScope::Message(m) => m.scope(),
            MessageOrEnumWithScope::Enum(e) => e.scope(),
        }
    }

    fn name(&self) -> &ProtobufIdentRef {
        match self {
            MessageOrEnumWithScope::Message(m) => m.name(),
            MessageOrEnumWithScope::Enum(e) => e.name(),
        }
    }
}

#[derive(Clone)]
pub(crate) struct FieldWithContext<'a> {
    pub field: FieldDescriptor,
    pub message: MessageWithScope<'a>,
}

impl<'a> Deref for FieldWithContext<'a> {
    type Target = FieldDescriptor;

    fn deref(&self) -> &Self::Target {
        &self.field
    }
}

impl<'a> FieldWithContext<'a> {
    pub fn is_oneof(&self) -> bool {
        self.field.containing_oneof().is_some()
    }

    pub fn oneof(&self) -> Option<OneofWithContext<'a>> {
        match self.field.containing_oneof() {
            Some(oneof) => Some(OneofWithContext {
                message: self.message.clone(),
                oneof,
            }),
            None => None,
        }
    }
}

#[derive(Clone)]
pub(crate) struct OneofVariantWithContext<'a> {
    pub oneof: &'a OneofWithContext<'a>,
    pub field: FieldDescriptor,
}

#[derive(Clone)]
pub(crate) struct OneofWithContext<'a> {
    pub oneof: OneofDescriptor,
    pub message: MessageWithScope<'a>,
}

impl<'a> OneofWithContext<'a> {
    pub fn field_name(&'a self) -> RustIdent {
        return rust_field_name_for_protobuf_field_name(self.oneof.name());
    }

    // rust type name of enum
    pub fn rust_name(&self) -> RustIdentWithPath {
        let type_name = RustIdent::from(capitalize(self.oneof.name()));
        self.message
            .to_scope()
            .rust_path_to_file()
            .into_path()
            .with_ident(type_name)
    }

    pub fn variants(&'a self) -> Vec<OneofVariantWithContext<'a>> {
        self.message
            .fields()
            .into_iter()
            .filter(|f| f.field.containing_oneof().as_ref() == Some(&self.oneof))
            .map(|f| OneofVariantWithContext {
                oneof: self,
                field: f.field,
            })
            .collect()
    }
}

'''
'''--- protobuf-codegen/src/gen/strx.rs ---
pub fn remove_to<'s, P>(s: &'s str, pattern: P) -> &'s str
where
    P: Fn(char) -> bool,
{
    match s.rfind(pattern) {
        Some(pos) => &s[(pos + 1)..],
        None => s,
    }
}

pub fn remove_suffix<'s>(s: &'s str, suffix: &str) -> &'s str {
    if !s.ends_with(suffix) {
        s
    } else {
        &s[..(s.len() - suffix.len())]
    }
}

pub fn capitalize(s: &str) -> String {
    if s.is_empty() {
        return String::new();
    }
    let mut char_indices = s.char_indices();
    char_indices.next().unwrap();
    match char_indices.next() {
        None => s.to_uppercase(),
        Some((i, _)) => s[..i].to_uppercase() + &s[i..],
    }
}

#[cfg(test)]
mod test {

    use super::capitalize;
    use super::remove_suffix;
    use super::remove_to;

    #[test]
    fn test_remove_to() {
        assert_eq!("aaa", remove_to("aaa", |c| c == '.'));
        assert_eq!("bbb", remove_to("aaa.bbb", |c| c == '.'));
        assert_eq!("ccc", remove_to("aaa.bbb.ccc", |c| c == '.'));
    }

    #[test]
    fn test_remove_suffix() {
        assert_eq!("bbb", remove_suffix("bbbaaa", "aaa"));
        assert_eq!("aaa", remove_suffix("aaa", "bbb"));
    }

    #[test]
    fn test_capitalize() {
        assert_eq!("", capitalize(""));
        assert_eq!("F", capitalize("f"));
        assert_eq!("Foo", capitalize("foo"));
    }
}

'''
'''--- protobuf-codegen/src/gen/well_known_types.rs ---
use protobuf_parse::ProtobufAbsPath;
use protobuf_parse::ProtobufRelPath;
use protobuf_parse::ProtobufRelPathRef;

use crate::compiler_plugin;
use crate::gen::code_writer::CodeWriter;
use crate::gen::paths::proto_path_to_rust_mod;

pub(crate) static WELL_KNOWN_TYPES_PROTO_FILE_NAMES: &[&str] = &[
    "any.proto",
    "api.proto",
    "duration.proto",
    "empty.proto",
    "field_mask.proto",
    "source_context.proto",
    "struct.proto",
    "timestamp.proto",
    "type.proto",
    "wrappers.proto",
];

pub(crate) static WELL_KNOWN_TYPES_PROTO_FILE_FULL_NAMES: &[&str] = &[
    "google/protobuf/any.proto",
    "google/protobuf/api.proto",
    "google/protobuf/duration.proto",
    "google/protobuf/empty.proto",
    "google/protobuf/field_mask.proto",
    "google/protobuf/source_context.proto",
    "google/protobuf/struct.proto",
    "google/protobuf/timestamp.proto",
    "google/protobuf/type.proto",
    "google/protobuf/wrappers.proto",
];

static NAMES: &'static [&'static str] = &[
    "Any",
    "Api",
    "BoolValue",
    "BytesValue",
    "DoubleValue",
    "Duration",
    "Empty",
    "Enum",
    "EnumValue",
    "Field",
    "Field.Cardinality",
    "Field.Kind",
    "FieldMask",
    "FloatValue",
    "Int32Value",
    "Int64Value",
    "ListValue",
    "Method",
    "Mixin",
    "NullValue",
    "Option",
    "SourceContext",
    "StringValue",
    "Struct",
    "Syntax",
    "Timestamp",
    "Type",
    "UInt32Value",
    "UInt64Value",
    "Value",
];

fn is_well_known_type(name: &ProtobufRelPathRef) -> bool {
    NAMES.iter().any(|&n| n == format!("{}", name))
}

pub(crate) fn is_well_known_type_full(name: &ProtobufAbsPath) -> Option<ProtobufRelPath> {
    if let Some(rem) = name.remove_prefix(&ProtobufAbsPath::from(".google.protobuf")) {
        if is_well_known_type(rem) {
            Some(rem.to_owned())
        } else {
            None
        }
    } else {
        None
    }
}

pub(crate) fn gen_well_known_types_mod() -> compiler_plugin::GenResult {
    let v = CodeWriter::with_no_error(|w| {
        w.comment("This file is generated. Do not edit");
        w.comment("@generated");
        w.mod_doc("Generated code for \"well known types\"");
        w.mod_doc("");
        w.mod_doc("[This document](https://developers.google.com/protocol-buffers/docs/reference/google.protobuf) describes these types.");

        w.write_line("");
        w.write_line("#![allow(unused_attributes)]");
        w.write_line("#![cfg_attr(rustfmt, rustfmt::skip)]");

        w.write_line("");
        for m in WELL_KNOWN_TYPES_PROTO_FILE_NAMES {
            w.write_line(&format!("pub mod {};", proto_path_to_rust_mod(m)));
        }
    });

    compiler_plugin::GenResult {
        name: "well_known_types_mod.rs".to_string(),
        content: v.into_bytes(),
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_is_well_known_type_full() {
        assert_eq!(
            Some(ProtobufRelPath::from("BoolValue")),
            is_well_known_type_full(&ProtobufAbsPath::from(".google.protobuf.BoolValue"))
        );
        assert_eq!(
            None,
            is_well_known_type_full(&ProtobufAbsPath::from(".google.protobuf.Fgfg"))
        );
    }
}

'''
'''--- protobuf-codegen/src/gen_and_write.rs ---
#![doc(hidden)]

use std::fs;
use std::io;
use std::path::Path;

use protobuf::descriptor::FileDescriptorProto;
use protobuf_parse::ProtoPathBuf;

use crate::customize::CustomizeCallback;
use crate::gen::all::gen_all;
use crate::Customize;

#[derive(Debug, thiserror::Error)]
enum Error {
    #[error("output path `{0}` is not a directory")]
    OutputIsNotDirectory(String),
    #[error("output path `{0}` does not exist or not accessible")]
    OutputDoesNotExistOrNotAccssible(String, #[source] io::Error),
    #[error("failed to create file `{0}`: {1}")]
    FailedToWriteFile(String, #[source] io::Error),
}

#[doc(hidden)]
pub fn gen_and_write(
    file_descriptors: &[FileDescriptorProto],
    parser: &str,
    files_to_generate: &[ProtoPathBuf],
    out_dir: &Path,
    customize: &Customize,
    customize_callback: &dyn CustomizeCallback,
) -> anyhow::Result<()> {
    match out_dir.metadata() {
        Ok(m) => {
            if !m.is_dir() {
                return Err(Error::OutputIsNotDirectory(out_dir.display().to_string()).into());
            }
        }
        Err(e) => {
            return Err(
                Error::OutputDoesNotExistOrNotAccssible(out_dir.display().to_string(), e).into(),
            );
        }
    }

    let results = gen_all(
        file_descriptors,
        parser,
        files_to_generate,
        customize,
        customize_callback,
    )?;

    for r in &results {
        let mut file_path = out_dir.to_owned();
        file_path.push(&r.name);
        fs::write(&file_path, r.content.as_slice())
            .map_err(|e| Error::FailedToWriteFile(file_path.display().to_string(), e))?;
    }

    Ok(())
}

'''
'''--- protobuf-codegen/src/lib.rs ---
//! # Protobuf code generator for `protobuf` crate
//!
//! This crate is useful mostly from `build.rs` scripts to generate `.rs` files during the build.
//!
//! # How to generate code
//!
//! There are three main ways to generate `.rs` files from `.proto` files:
//! * using `protoc` command line tool and `protoc-gen-rust` plugin
//! * using this crate `Codegen` with pure rust parser
//! * using this crate `Codegen` with `protoc` parser
//!
//! Which one should you use depends on your needs.
//!
//! If you are using non-cargo build system (like Bazel), you might prefer
//! using `protoc-gen-rust` plugin for `protoc`.
//!
//! If you build with `cargo`, you probably want to use `Codegen` from this crate.
//!
//! # Protoc parser vs pure rust parser
//!
//! There are two protobuf parsers which can be plugged into this crate:
//! * `protoc`-based parser (`protoc` is a command like utility from Google protobuf)
//! * pure rust parser (`protobuf-parse` crate)
//!
//! `protoc`-based parser is expected to parse `.proto` files very correctly:
//! all Google's protobuf implementations rely on it.
//!
//! While there are no known bugs in `protobuf-parse`, it is not tested very well.
//! Also `protobuf-parse` does not implement certain rarely used features of `.proto` parser,
//! mostly complex message options specified in `.proto` files.
//! I never saw anyone using them, but you have been warned.
//!
//! Note `protoc` command can be obtained from
//! [`protoc-bin-vendored`](https://docs.rs/protoc-bin-vendored) crate.
//!
//! # Example
//!
//! ```no_run
//! # mod protoc_bin_vendored {
//! #   pub fn protoc_bin_path() -> Result<std::path::PathBuf, std::io::Error> {
//! #       unimplemented!()
//! #   }
//! # }
//! // Use this in build.rs
//! protobuf_codegen::Codegen::new()
//!     // Use `protoc` parser, optional.
//!     .protoc()
//!     // Use `protoc-bin-vendored` bundled protoc command, optional.
//!     .protoc_path(&protoc_bin_vendored::protoc_bin_path().unwrap())
//!     // All inputs and imports from the inputs must reside in `includes` directories.
//!     .includes(&["src/protos"])
//!     // Inputs must reside in some of include paths.
//!     .input("src/protos/apple.proto")
//!     .input("src/protos/banana.proto")
//!     // Specify output directory relative to Cargo output directory.
//!     .cargo_out_dir("protos")
//!     .run_from_script();
//! ```
//!
//! ## How to use `protoc-gen-rust`
//!
//! If you have to.
//!
//! (Note `protoc` can be invoked programmatically with
//! [protoc crate](https://docs.rs/protoc/%3E=3.0.0-alpha))
//!
//! 0) Install protobuf for `protoc` binary.
//!
//! On OS X [Homebrew](https://github.com/Homebrew/brew) can be used:
//!
//! ```sh
//! brew install protobuf
//! ```
//!
//! On Ubuntu, `protobuf-compiler` package can be installed:
//!
//! ```sh
//! apt-get install protobuf-compiler
//! ```
//!
//! Protobuf is needed only for code generation, `rust-protobuf` runtime
//! does not use C++ protobuf library.
//!
//! 1) Install `protoc-gen-rust` program (which is `protoc` plugin)
//!
//! It can be installed either from source or with `cargo install protobuf-codegen` command.
//!
//! 2) Add `protoc-gen-rust` to $PATH
//!
//! If you installed it with cargo, it should be
//!
//! ```sh
//! PATH="$HOME/.cargo/bin:$PATH"
//! ```
//!
//! 3) Generate .rs files:
//!
//! ```sh
//! protoc --rust_out . foo.proto
//! ```
//!
//! This will generate .rs files in current directory.
//!
//! # Customize generate code
//!
//! Sometimes generated code need to be adjusted, e. g. to have custom derives.
//!
//! rust-protobuf provides two options to do that:
//! * generated `.rs` files contain `@@protoc_insertion_point(...)` markers
//!   (similar markers inserts Google's protobuf generator for C++ or Java).
//!   Simple script `sed` one-liners can be used to replace these markers with custom annotations.
//! * `Codegen::customize_callback` can be used to patch generated code
//!   when invoked from `build.rs` script.
//!
//! # Serde
//!
//! rust-protobuf since version 3 no longer directly supports serde.
//!
//! Rust-protobuf 3 fully supports:
//! * runtime reflection
//! * JSON parsing and printing via
//!  [`protobuf-json-mapping`](https://docs.rs/protobuf-json-mapping)
//!
//! Which covers the most of serde use cases.
//!
//! If you still need serde, generic customization callback (see above) can be used
//! to insert `#[serde(...)]` annotations.
//!
//! [Example project](https://github.com/stepancheg/rust-protobuf/tree/master/protobuf-examples/customize-serde)
//! in the rust-protobuf repository demonstrates how to do it.

#![deny(rustdoc::broken_intra_doc_links)]

mod codegen;
mod compiler_plugin;
mod customize;
mod gen;
pub mod gen_and_write;
pub mod protoc_gen_rust;

pub use codegen::Codegen;
pub use customize::Customize;
pub use customize::CustomizeCallback;
#[doc(hidden)]
pub use gen::paths::proto_name_to_rs;

'''
'''--- protobuf-codegen/src/protoc_gen_rust.rs ---
#![doc(hidden)]

use crate::compiler_plugin;
use crate::customize::CustomizeCallbackDefault;
use crate::gen::all::gen_all;
use crate::Customize;

#[doc(hidden)]
pub fn protoc_gen_rust_main() {
    compiler_plugin::plugin_main(|r| {
        let customize = Customize::parse_from_parameter(r.parameter).expect("parse options");
        gen_all(
            r.file_descriptors,
            "protoc --rust-out=...",
            r.files_to_generate,
            &customize,
            &CustomizeCallbackDefault,
        )
    })
    .expect("plugin failed");
}

'''
'''--- protobuf-examples/README.md ---
# rust-protobuf examples

This directory contains examples for rust-protobuf version 3.

Rust-protobuf 3 is currently alpha version, and will be released
in a few weeks.

Rust-protobuf version 2 has similar API, but examples won't work
as is with version 2.

## Crate references

In the examples, protobuf crates are referenced by relative paths:

```toml
protobuf = { path = "../../protobuf" }
```

in your project versions should be used instead like:

```toml
protobuf = "3.0.0-alpha.8"
```

'''
'''--- protobuf-examples/customize-serde/Cargo.toml ---
[package]
name = "protobuf-examples-customize"
version = "0.0.0"
authors = ["Stepan Koltsov <stepan.koltsov@gmail.com>"]
edition = "2021"
publish = false

[dependencies]
protobuf = { path = "../../protobuf" }
serde = {version = "1.0.84", features = ["derive"]}
serde_json = "1.0.78"

[build-dependencies]
protobuf = { path = "../../protobuf" }
protobuf-codegen = { path = "../../protobuf-codegen" }

'''
'''--- protobuf-examples/customize-serde/README.md ---
<!-- cargo-sync-readme start -->

# How to use serde with rust-protobuf

rust-protobuf 3 no longer directly supports serde.

Practically, serde is needed mostly to be able to serialize and deserialize JSON,
and **rust-protobuf supports JSON directly**, and more correctly according to
official protobuf to JSON mapping. For that reason,
native serde support was removed from rust-protobuf.

This crate is an example how to inject serde annotations into generated code.

Annotations are configured from `build.rs`.

<!-- cargo-sync-readme end -->

'''
'''--- protobuf-examples/customize-serde/build.rs ---
use protobuf::descriptor::field_descriptor_proto::Type;
use protobuf::reflect::FieldDescriptor;
use protobuf::reflect::MessageDescriptor;
use protobuf_codegen::Codegen;
use protobuf_codegen::Customize;
use protobuf_codegen::CustomizeCallback;

fn main() {
    struct GenSerde;

    impl CustomizeCallback for GenSerde {
        fn message(&self, _message: &MessageDescriptor) -> Customize {
            Customize::default().before("#[derive(::serde::Serialize, ::serde::Deserialize)]")
        }

        fn field(&self, field: &FieldDescriptor) -> Customize {
            if field.proto().type_() == Type::TYPE_ENUM {
                // `EnumOrUnknown` is not a part of rust-protobuf, so external serializer is needed.
                Customize::default().before(
                    "#[serde(serialize_with = \"crate::serialize_enum_or_unknown\", deserialize_with = \"crate::deserialize_enum_or_unknown\")]")
            } else {
                Customize::default()
            }
        }

        fn special_field(&self, _message: &MessageDescriptor, _field: &str) -> Customize {
            Customize::default().before("#[serde(skip)]")
        }
    }

    Codegen::new()
        .cargo_out_dir("protos")
        .include("src")
        .inputs(&["src/customize_example.proto"])
        .customize_callback(GenSerde)
        .run_from_script();
}

'''
'''--- protobuf-examples/customize-serde/src/lib.rs ---
//! # How to use serde with rust-protobuf
//!
//! rust-protobuf 3 no longer directly supports serde.
//!
//! Practically, serde is needed mostly to be able to serialize and deserialize JSON,
//! and **rust-protobuf supports JSON directly**, and more correctly according to
//! official protobuf to JSON mapping. For that reason,
//! native serde support was removed from rust-protobuf.
//!
//! This crate is an example how to inject serde annotations into generated code.
//!
//! Annotations are configured from `build.rs`.

use std::fmt::Formatter;
use std::marker::PhantomData;

use protobuf::EnumFull;
use protobuf::EnumOrUnknown;

include!(concat!(env!("OUT_DIR"), "/protos/mod.rs"));

fn serialize_enum_or_unknown<E: EnumFull, S: serde::Serializer>(
    e: &Option<EnumOrUnknown<E>>,
    s: S,
) -> Result<S::Ok, S::Error> {
    if let Some(e) = e {
        match e.enum_value() {
            Ok(v) => s.serialize_str(v.descriptor().name()),
            Err(v) => s.serialize_i32(v),
        }
    } else {
        s.serialize_unit()
    }
}

fn deserialize_enum_or_unknown<'de, E: EnumFull, D: serde::Deserializer<'de>>(
    d: D,
) -> Result<Option<EnumOrUnknown<E>>, D::Error> {
    struct DeserializeEnumVisitor<E: EnumFull>(PhantomData<E>);

    impl<'de, E: EnumFull> serde::de::Visitor<'de> for DeserializeEnumVisitor<E> {
        type Value = Option<EnumOrUnknown<E>>;

        fn expecting(&self, formatter: &mut Formatter) -> std::fmt::Result {
            write!(formatter, "a string, an integer or none")
        }

        fn visit_str<R>(self, v: &str) -> Result<Self::Value, R>
        where
            R: serde::de::Error,
        {
            match E::enum_descriptor().value_by_name(v) {
                Some(v) => Ok(Some(EnumOrUnknown::from_i32(v.value()))),
                None => Err(serde::de::Error::custom(format!(
                    "unknown enum value: {}",
                    v
                ))),
            }
        }

        fn visit_i32<R>(self, v: i32) -> Result<Self::Value, R>
        where
            R: serde::de::Error,
        {
            Ok(Some(EnumOrUnknown::from_i32(v)))
        }

        fn visit_unit<R>(self) -> Result<Self::Value, R>
        where
            R: serde::de::Error,
        {
            Ok(None)
        }
    }

    d.deserialize_any(DeserializeEnumVisitor(PhantomData))
}

#[cfg(test)]
mod test {
    use crate::customize_example::Fruit;
    use crate::customize_example::Shape;

    #[test]
    fn test() {
        let mut fruit = Fruit::new();
        fruit.set_name("Orange".to_owned());
        fruit.set_weight(1.5);
        fruit.set_shape(Shape::CIRCLE);

        // Serde works.
        // Note rust-protobuf has built in support for JSON,
        // which follows protobuf-JSON serialization more correctly than default serde-json.
        // This example here is for the demonstration of generation of custom derives.
        let json = serde_json::to_string(&fruit).unwrap();
        assert_eq!(
            "{\"name\":\"Orange\",\"weight\":1.5,\"shape\":\"CIRCLE\"}",
            json
        );

        // TODO: add deserialization test
    }
}

'''
'''--- protobuf-examples/dynamic/Cargo.toml ---
[package]
name = "protobuf-examples-dynamic"
version = "0.0.0"
authors = ["Stepan Koltsov <stepan.koltsov@gmail.com>"]
edition = "2021"
publish = false

[dependencies]
protobuf = { path = "../../protobuf" }
protobuf-parse = { path = "../../protobuf-parse" }
tempfile = "3"

'''
'''--- protobuf-examples/dynamic/README.md ---
# Dynamic messages

Example how to create "dynamic" messages:
these are created using only protobuf schema without generated files.

99% of users won't need this.

Note this crate does not depend on `protobuf-codegen` crate.

'''
'''--- protobuf-examples/dynamic/src/main.rs ---
use std::fs;

use protobuf::descriptor::FileDescriptorProto;
use protobuf::reflect::FileDescriptor;
use protobuf::reflect::ReflectValueBox;

fn main() {
    // Here we define `.proto` file source, we are not generating rust sources for it.
    let proto = "syntax = 'proto3'; message Mmm { int32 aaa = 1; }";

    let temp_dir = tempfile::tempdir().unwrap();
    let tempfile = temp_dir.path().join("mmm.proto");
    // For now we need to write files to the disk.
    fs::write(&tempfile, proto).unwrap();

    // Parse text `.proto` file to `FileDescriptorProto` message.
    // Note this API is not stable and subject to change.
    // But binary protos can always be generated manually with `protoc` command.
    let mut file_descriptor_protos = protobuf_parse::Parser::new()
        .pure()
        .includes(&[temp_dir.path().to_path_buf()])
        .input(&tempfile)
        .parse_and_typecheck()
        .unwrap()
        .file_descriptors;
    assert_eq!(1, file_descriptor_protos.len());

    // This is our .proto file converted to `FileDescriptorProto` from `descriptor.proto`.
    let file_descriptor_proto: FileDescriptorProto = file_descriptor_protos.pop().unwrap();
    // Now this `FileDescriptorProto` initialized for reflective access.
    let file_descriptor: FileDescriptor =
        FileDescriptor::new_dynamic(file_descriptor_proto, &[]).unwrap();
    // Find the message.
    let mmm_descriptor = file_descriptor
        .message_by_package_relative_name("Mmm")
        .unwrap();
    // Create an empty message.
    let mut mmm = mmm_descriptor.new_instance();
    // Find the field.
    let aaa_field = mmm_descriptor.field_by_name("aaa").unwrap();
    // Set field.
    aaa_field.set_singular_field(&mut *mmm, ReflectValueBox::I32(42));

    // Now serialize it to binary format.
    // field number = 1
    // wire_type = 0 (varint)
    // tag = (1 << 3) | 0 = 8
    // value = 42
    assert_eq!(&[8, 42], mmm.write_to_bytes_dyn().unwrap().as_slice());

    // Print it as text format.
    assert_eq!("aaa: 42", protobuf::text_format::print_to_string(&*mmm));
}

'''
'''--- protobuf-examples/issue-614/Cargo.toml ---
[package]
name = "protobuf-examples-issue-614"
version = "0.0.0"
authors = ["Stepan Koltsov <stepan.koltsov@gmail.com>"]
edition = "2021"
publish = false
description= """
Example for https://github.com/stepancheg/rust-protobuf/issues/614
"""

[dependencies]
protobuf = { path = "../../protobuf" }

[build-dependencies]
protobuf-codegen = { path = "../../protobuf-codegen" }

'''
'''--- protobuf-examples/issue-614/build.rs ---
use protobuf_codegen::Codegen;

fn main() {
    Codegen::new()
        .input("foos.proto")
        .include(".")
        .cargo_out_dir("p")
        .run_from_script();
}

'''
'''--- protobuf-examples/issue-614/examples/example-issue-614.rs ---
use protobuf::MessageFull;
use protobuf_examples_issue_614::foos;
use protobuf_examples_issue_614::generate_insert;
use protobuf_examples_issue_614::generate_schema_for;

fn main() {
    let descriptor = protobuf_examples_issue_614::foos::Foo::descriptor();
    println!("Schema: {}", generate_schema_for(descriptor));

    let mut message = foos::Foo::new();
    message.bar = 1;
    message.baz = Some(foos::foo::Baz::Qux("test".to_owned()));
    println!("Insert: {}", generate_insert(&message));
}

'''
'''--- protobuf-examples/issue-614/src/lib.rs ---
use protobuf::reflect::MessageDescriptor;
use protobuf::MessageDyn;
include!(concat!(env!("OUT_DIR"), "/p/mod.rs"));

fn table_name(message: &MessageDescriptor) -> String {
    format!("{}s", message.name().to_lowercase())
}

pub fn generate_schema_for(message: MessageDescriptor) -> String {
    let table = table_name(&message);
    let mut columns = Vec::new();
    for field in message.fields() {
        if field.containing_oneof().is_some() {
            continue;
        }
        columns.push(format!("{} STRING", field.name()));
    }
    for oneof in message.oneofs() {
        columns.push(format!("{}_type STRING", oneof.name()));
        columns.push(format!("{}_value STRING", oneof.name()));
    }
    let columns = columns.join(", ");
    format!("CREATE TABLE {table} ({columns})")
}

pub fn generate_insert(message: &dyn MessageDyn) -> String {
    let descriptor = message.descriptor_dyn();
    let table = table_name(&descriptor);
    let mut column_names = Vec::new();
    let mut column_values = Vec::new();
    for field in descriptor.fields() {
        if let Some(v) = field.get_singular(message) {
            if let Some(oneof) = field.containing_oneof() {
                column_names.push(format!("{}_type", oneof.name()));
                column_values.push(format!("'{}'", field.name()));
                column_names.push(format!("{}_value", oneof.name()));
                column_values.push(format!("'{}'", v));
            } else {
                column_names.push(field.name().to_owned());
                column_values.push(format!("'{}'", v));
            }
        }
    }
    let column_names = column_names.join(", ");
    let column_values = column_values.join(", ");
    format!("INSERT INTO {table}({column_names}) VALUES ({column_values})")
}

'''
'''--- protobuf-examples/pure-vs-protoc/Cargo.toml ---
[package]
name = "protobuf-examples-pure-vs-protoc"
version = "0.0.0"
authors = ["Jeff Garzik <jeff@bloq.com>"]
edition = "2021"
publish = false

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
protobuf = { path = "../../protobuf" }

[build-dependencies]
protobuf-codegen = { path = "../../protobuf-codegen" }

'''
'''--- protobuf-examples/pure-vs-protoc/README.md ---
# rust-protobuf-example

Example rust protobuf project

(This is an example for the master branch. For protobuf=v2.19 look at the
[same directory in v2.19 branch](https://github.com/stepancheg/rust-protobuf/tree/v2.19/protobuf-examples).)

## Motivation

Simple and obvious examples for using `rust-protobuf` module were lacking, so this was created.

## Look here

Key files to read are:

* src/protos/example.proto
* src/main.rs
* build.rs

## Using

Standard rust package:
```
$ cargo build
$ cargo run
```

'''
'''--- protobuf-examples/pure-vs-protoc/build.rs ---
use protobuf_codegen::Codegen;

fn main() {
    // We generate descriptors twice: with pure rust codegen
    // and with codegen depending on `protoc` binary.
    // This is for demonstration purposes; in practice you'd need either of them.
    //
    // Note there's a third option: using `protoc` binary directly and `protoc-gen-rust`
    // plugin, this is a canonical way to generate protobuf sources.
    // This is not possible to do with Cargo (since Cargo cannot depend on binaries)
    // but can be used with some other build system.

    Codegen::new()
        .protoc()
        .cargo_out_dir("generated_with_native")
        .input("src/protos/example.proto")
        .include("src/protos")
        .run_from_script();

    Codegen::new()
        .pure()
        .cargo_out_dir("generated_with_pure")
        .input("src/protos/example.proto")
        .include("src/protos")
        .run_from_script();
}

'''
'''--- protobuf-examples/pure-vs-protoc/src/main.rs ---
mod protos;

use protobuf::Message;
// For demonstration we take `GetRequest` messages from a source generated
// with pure-rust codegen, and `GetResponse` with `protoc`-based codegen.
// This is not needed in practice, done here for demonstration purposes.
use protos::generated_with_native::example::get_response::Status;
use protos::generated_with_native::example::GetResponse;
use protos::generated_with_pure::example::GetRequest;

fn main() {
    // Encode example request
    let mut out_msg = GetRequest::new();
    out_msg.name = "John Smith".to_string();
    out_msg.age = 25;
    out_msg.features.push("one".to_string());
    out_msg.features.push("two".to_string());

    let out_bytes: Vec<u8> = out_msg.write_to_bytes().unwrap();

    // Decode example request
    let in_msg = GetRequest::parse_from_bytes(&out_bytes).unwrap();

    let in_name = in_msg.name;

    assert_eq!(in_name, "John Smith");

    //////////////////////////////////

    // Encode example response
    let mut out_resp = GetResponse::new();
    out_resp.status = Status::OK.into();
    out_resp.address = "1243 main street".to_string();
    out_resp.city = "anytown".to_string();
    out_resp.zipcode = 54321;

    let out_bytes: Vec<u8> = out_resp.write_to_bytes().unwrap();

    // Decode example response
    let in_resp = GetResponse::parse_from_bytes(&out_bytes).unwrap();

    assert_eq!(in_resp.status, out_resp.status);
    assert_eq!(in_resp.zipcode, out_resp.zipcode);
    assert_eq!(in_resp.address, out_resp.address);
}

'''
'''--- protobuf-examples/pure-vs-protoc/src/protos/mod.rs ---
//! Generated files are imported from here.
//!
//! For the demonstration we generate descriptors twice, with
//! as pure rust codegen, and with codegen dependent on `protoc` binary.

pub mod generated_with_pure {
    include!(concat!(env!("OUT_DIR"), "/generated_with_pure/mod.rs"));
}

pub mod generated_with_native {
    include!(concat!(env!("OUT_DIR"), "/generated_with_native/mod.rs"));
}

'''
'''--- protobuf-examples/vs-prost/Cargo.toml ---
[package]
name = "protobuf-examples-vs-prost"
version = "0.0.0"
authors = ["Stepan Koltsov <stepan.koltsov@gmail.com>"]
edition = "2021"
publish = false

[dependencies]
protobuf = { path = "../../protobuf" }
prost = "0.10.1"

[build-dependencies]
protobuf-codegen = { path = "../../protobuf-codegen" }
prost-build = "0.9.0"

'''
'''--- protobuf-examples/vs-prost/README.md ---
<!-- cargo-sync-readme start -->

# Compare generated code and API between rust-protobuf and prost

This document tries to objectively compare rust-protobuf and prost.

Use

```rust
cargo expand -p protobuf-examples-vs-prost
```

to see the code.

Feel free to submit more items here.

## The differences

The comparison is
* rust-protobuf from master and
* prost version 0.9.0, which is the latest released version at the moment of writing.

The list is incomplete.

### Use of derives

Prost relies on `#[derive(::prost::Message)]` in generated code.
* seems to be unnecessary, if code is generated, not written by hand,
  derive does not help much.
* derives also make code harder to understand: something like `cargo expand`
  is needed, which is not as clear as looking at the generated code.

## Unknown fields

rust-protobuf preserves "unknown fields". This improves forward compatibility:
when new message is read using old version of schema and then written back,
rust-protobuf preserves the unknown fields, and prost discards them.

In 99% of the cases, unknown fields are not needed to be preserved.

## Cached size

Prost seems to not cache "cached size" of message before serialization.

In the worst case, with deeply nested messages, it results in exponential growth
serialization time. But deeply nested messages are rare, and API is clearer without it.

(Note, serialization can be linear if message sizes are stored in a queue/stack
during serialization. rust-protobuf did it
[before 2014](https://github.com/stepancheg/rust-protobuf/commit/86fe60cc67e3ea257fcad417bcb039973ace3bfc),
see `compute_sizes` function signature. But it was changed to storing cached size
because storing cached size is faster. If prost doesn't want to store cached size,
perhaps they can at least use similar approach.)

## Default instance

For each message, rust-protobuf generates `M::default_instance()` function
and `Default for <&M>` (similarly to what C++ and Java generators do).
So when fetching an optional field reference, rust-protobuf is able to
always provide a reference to a message instance: either a real message or a default instance
if a field is unset.

Prost doesn't do it.

## Enums

In prost, enum fields have type `i32`.

In rust-protobuf, `EnumOrUnknown<T>` is used to store enum values.

Note it is important to store full `i32` in enum value, not just the enum
to preserve unknown values when reading future message with old schema
and writing it back.

So rust-protobuf is a bit more type-safe, but generated code is somewhat harder to use.

## Reflection

Both prost and rust-protobuf can be configured to generate serde annotations.

But rust-protobuf fully supports runtime reflection
(e. g. find field by name, get field, set field).
This is implemented similarly to C++ implementation of protobuf.
The drawback is that generated code is quite large (which also affects binary size).

However, for prost there's [prost-reflect](https://github.com/andrewhickman/prost-reflect)
crate. I don't know what is it's status, seems like it is not mature enough yet:
the project started less than two months ago.

## Dynamic messages

rust-protobuf supports dynamic messages.

For prost, `prost-reflect` implements them.

## JSON

Proper [protobuf JSON mapping](https://developers.google.com/protocol-buffers/docs/proto3#json)
is supported natively by rust-protobuf.

For prost it can be done with `prost-reflect` package.

## Protobuf text format

rust-protobuf supports text format printing and parsing. Prost seems to be missing this feature.

## Dependency on `protoc` binary

prost depends on `protoc` binary to parse `.proto` files.

rust-protobuf can do both:
* parse using `protoc` binary
* has pure rust parser (and typechecker) of `.proto` files

## gRPC

[tonic](https://docs.rs/tonic/latest/tonic/) is a quality pure rust gRPC implementation
for prost.

[grpc-rs](https://github.com/tikv/grpc-rs) is an implementation for both
prost and rust-protobuf.

<!-- cargo-sync-readme end -->

'''
'''--- protobuf-examples/vs-prost/build.rs ---
fn main() {
    protobuf_codegen::Codegen::new()
        .include("src")
        .inputs(["src/segment.proto", "src/triangle.proto"])
        .cargo_out_dir("rust_protobuf_protos")
        .run_from_script();

    prost_build::Config::new()
        .compile_protos(&["src/segment.proto", "src/triangle.proto"], &["src"])
        .unwrap();
}

'''
'''--- protobuf-examples/vs-prost/src/lib.rs ---
//! # Compare generated code and API between rust-protobuf and prost
//!
//! This document tries to objectively compare rust-protobuf and prost.
//!
//! Use
//!
//! ```ignore
//! cargo expand -p protobuf-examples-vs-prost
//! ```
//!
//! to see the code.
//!
//! Feel free to submit more items here.
//!
//! ## The differences
//!
//! The comparison is
//! * rust-protobuf from master and
//! * prost version 0.9.0, which is the latest released version at the moment of writing.
//!
//! The list is incomplete.
//!
//! ### Use of derives
//!
//! Prost relies on `#[derive(::prost::Message)]` in generated code.
//! * seems to be unnecessary, if code is generated, not written by hand,
//!   derive does not help much.
//! * derives also make code harder to understand: something like `cargo expand`
//!   is needed, which is not as clear as looking at the generated code.
//!
//! ## Unknown fields
//!
//! rust-protobuf preserves "unknown fields". This improves forward compatibility:
//! when new message is read using old version of schema and then written back,
//! rust-protobuf preserves the unknown fields, and prost discards them.
//!
//! In 99% of the cases, unknown fields are not needed to be preserved.
//!
//! ## Cached size
//!
//! Prost seems to not cache "cached size" of message before serialization.
//!
//! In the worst case, with deeply nested messages, it results in exponential growth
//! serialization time. But deeply nested messages are rare, and API is clearer without it.
//!
//! (Note, serialization can be linear if message sizes are stored in a queue/stack
//! during serialization. rust-protobuf did it
//! [before 2014](https://github.com/stepancheg/rust-protobuf/commit/86fe60cc67e3ea257fcad417bcb039973ace3bfc),
//! see `compute_sizes` function signature. But it was changed to storing cached size
//! because storing cached size is faster. If prost doesn't want to store cached size,
//! perhaps they can at least use similar approach.)
//!
//! ## Default instance
//!
//! For each message, rust-protobuf generates `M::default_instance()` function
//! and `Default for <&M>` (similarly to what C++ and Java generators do).
//! So when fetching an optional field reference, rust-protobuf is able to
//! always provide a reference to a message instance: either a real message or a default instance
//! if a field is unset.
//!
//! Prost doesn't do it.
//!
//! ## Enums
//!
//! In prost, enum fields have type `i32`.
//!
//! In rust-protobuf, `EnumOrUnknown<T>` is used to store enum values.
//!
//! Note it is important to store full `i32` in enum value, not just the enum
//! to preserve unknown values when reading future message with old schema
//! and writing it back.
//!
//! So rust-protobuf is a bit more type-safe, but generated code is somewhat harder to use.
//!
//! ## Reflection
//!
//! Both prost and rust-protobuf can be configured to generate serde annotations.
//!
//! But rust-protobuf fully supports runtime reflection
//! (e. g. find field by name, get field, set field).
//! This is implemented similarly to C++ implementation of protobuf.
//! The drawback is that generated code is quite large (which also affects binary size).
//!
//! However, for prost there's [prost-reflect](https://github.com/andrewhickman/prost-reflect)
//! crate. I don't know what is it's status, seems like it is not mature enough yet:
//! the project started less than two months ago.
//!
//! ## Dynamic messages
//!
//! rust-protobuf supports dynamic messages.
//!
//! For prost, `prost-reflect` implements them.
//!
//! ## JSON
//!
//! Proper [protobuf JSON mapping](https://developers.google.com/protocol-buffers/docs/proto3#json)
//! is supported natively by rust-protobuf.
//!
//! For prost it can be done with `prost-reflect` package.
//!
//! ## Protobuf text format
//!
//! rust-protobuf supports text format printing and parsing. Prost seems to be missing this feature.
//!
//! ## Dependency on `protoc` binary
//!
//! prost depends on `protoc` binary to parse `.proto` files.
//!
//! rust-protobuf can do both:
//! * parse using `protoc` binary
//! * has pure rust parser (and typechecker) of `.proto` files
//!
//! ## gRPC
//!
//! [tonic](https://docs.rs/tonic/latest/tonic/) is a quality pure rust gRPC implementation
//! for prost.
//!
//! [grpc-rs](https://github.com/tikv/grpc-rs) is an implementation for both
//! prost and rust-protobuf.

mod rust_protobuf_protos {
    include!(concat!(env!("OUT_DIR"), "/rust_protobuf_protos/mod.rs"));
}

mod prost_protos {
    include!(concat!(env!("OUT_DIR"), "/_.rs"));
}

#[cfg(test)]
mod test {
    use crate::prost_protos;
    use crate::rust_protobuf_protos;

    #[test]
    fn triangles() {
        let mut rp = rust_protobuf_protos::triangle::Triangle::new();
        let mut pr = prost_protos::Triangle::default();

        rp.description = "The triangle".to_owned();
        pr.description = "The triangle".to_owned();

        rp.color = rust_protobuf_protos::triangle::Color::RED.into();
        pr.color = prost_protos::Color::Red as i32;
    }
}

'''
'''--- protobuf-json-mapping/Cargo.toml ---
[package]

name = "protobuf-json-mapping"
version = "4.0.0-alpha.0"
authors = ["Stepan Koltsov <stepan.koltsov@gmail.com>"]
edition = "2021"
license = "MIT"
homepage = "https://github.com/stepancheg/rust-protobuf/"
repository = "https://github.com/stepancheg/rust-protobuf/"
documentation = "https://github.com/stepancheg/rust-protobuf/blob/master/README.md"
description = """
JSON mapping for Protocol Buffers messages.
"""

[lib]
bench = false

[dependencies]
thiserror = "1.0.30"

protobuf = { path = "../protobuf", version = "=4.0.0-alpha.0" }
protobuf-support = { path = "../protobuf-support", version = "=4.0.0-alpha.0" }

[package.metadata.docs.rs]
all-features = true

'''
'''--- protobuf-json-mapping/README.md ---
<!-- cargo-sync-readme start -->

JSON printer and parser which tries to follow
[protobuf conventions](https://developers.google.com/protocol-buffers/docs/proto3#json).

<!-- cargo-sync-readme end -->

'''
'''--- protobuf-json-mapping/src/base64.rs ---
//! Copy-pasted from the internet
/// Available encoding character sets
#[derive(Clone, Copy, Debug)]
enum _CharacterSet {
    /// The standard character set (uses `+` and `/`)
    _Standard,
    /// The URL safe character set (uses `-` and `_`)
    _UrlSafe,
}

static STANDARD_CHARS: &'static [u8] = b"ABCDEFGHIJKLMNOPQRSTUVWXYZ\
                                        abcdefghijklmnopqrstuvwxyz\
                                        0123456789+/";

static _URLSAFE_CHARS: &'static [u8] = b"ABCDEFGHIJKLMNOPQRSTUVWXYZ\
                                       abcdefghijklmnopqrstuvwxyz\
                                       0123456789-_";

pub fn encode(input: &[u8]) -> String {
    let bytes = STANDARD_CHARS;

    let len = input.len();

    // Preallocate memory.
    let prealloc_len = (len + 2) / 3 * 4;
    let mut out_bytes = vec![b'='; prealloc_len];

    // Deal with padding bytes
    let mod_len = len % 3;

    // Use iterators to reduce branching
    {
        let mut s_in = input[..len - mod_len].iter().map(|&x| x as u32);
        let mut s_out = out_bytes.iter_mut();

        // Convenient shorthand
        let enc = |val| bytes[val as usize];
        let mut write = |val| *s_out.next().unwrap() = val;

        // Iterate though blocks of 4
        while let (Some(first), Some(second), Some(third)) = (s_in.next(), s_in.next(), s_in.next())
        {
            let n = first << 16 | second << 8 | third;

            // This 24-bit number gets separated into four 6-bit numbers.
            write(enc((n >> 18) & 63));
            write(enc((n >> 12) & 63));
            write(enc((n >> 6) & 63));
            write(enc((n >> 0) & 63));
        }

        // Heh, would be cool if we knew this was exhaustive
        // (the dream of bounded integer types)
        match mod_len {
            0 => (),
            1 => {
                let n = (input[len - 1] as u32) << 16;
                write(enc((n >> 18) & 63));
                write(enc((n >> 12) & 63));
            }
            2 => {
                let n = (input[len - 2] as u32) << 16 | (input[len - 1] as u32) << 8;
                write(enc((n >> 18) & 63));
                write(enc((n >> 12) & 63));
                write(enc((n >> 6) & 63));
            }
            _ => panic!("Algebra is broken, please alert the math police"),
        }
    }

    // `out_bytes` vec is prepopulated with `=` symbols and then only updated
    // with base64 chars, so this unsafe is safe.
    unsafe { String::from_utf8_unchecked(out_bytes) }
}

/// Errors that can occur when decoding a base64 encoded string
#[derive(Clone, Copy, Debug, thiserror::Error)]
pub enum FromBase64Error {
    /// The input contained a character not part of the base64 format
    #[error("Invalid base64 byte")]
    InvalidBase64Byte(u8, usize),
    /// The input had an invalid length
    #[error("Invalid base64 length")]
    InvalidBase64Length,
}

pub fn decode(input: &str) -> Result<Vec<u8>, FromBase64Error> {
    let mut r = Vec::with_capacity(input.len());
    let mut buf: u32 = 0;
    let mut modulus = 0;

    let mut it = input.as_bytes().iter();
    for byte in it.by_ref() {
        let code = DECODE_TABLE[*byte as usize];
        if code >= SPECIAL_CODES_START {
            match code {
                NEWLINE_CODE => continue,
                EQUALS_CODE => break,
                INVALID_CODE => {
                    return Err(FromBase64Error::InvalidBase64Byte(
                        *byte,
                        (byte as *const _ as usize) - input.as_ptr() as usize,
                    ))
                }
                _ => unreachable!(),
            }
        }
        buf = (buf | code as u32) << 6;
        modulus += 1;
        if modulus == 4 {
            modulus = 0;
            r.push((buf >> 22) as u8);
            r.push((buf >> 14) as u8);
            r.push((buf >> 6) as u8);
        }
    }

    for byte in it {
        match *byte {
            b'=' | b'\r' | b'\n' => continue,
            _ => {
                return Err(FromBase64Error::InvalidBase64Byte(
                    *byte,
                    (byte as *const _ as usize) - input.as_ptr() as usize,
                ))
            }
        }
    }

    match modulus {
        2 => {
            r.push((buf >> 10) as u8);
        }
        3 => {
            r.push((buf >> 16) as u8);
            r.push((buf >> 8) as u8);
        }
        0 => (),
        _ => return Err(FromBase64Error::InvalidBase64Length),
    }

    Ok(r)
}

const DECODE_TABLE: [u8; 256] = [
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0xFF, 0xFF, 0xFD, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3E, 0xFF, 0x3E, 0xFF, 0x3F,
    0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF,
    0xFF, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E,
    0x0F, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F,
    0xFF, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28,
    0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
];
const INVALID_CODE: u8 = 0xFF;
const EQUALS_CODE: u8 = 0xFE;
const NEWLINE_CODE: u8 = 0xFD;
const SPECIAL_CODES_START: u8 = NEWLINE_CODE;

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_encode_basic() {
        assert_eq!(encode(b""), "");
        assert_eq!(encode(b"f"), "Zg==");
        assert_eq!(encode(b"fo"), "Zm8=");
        assert_eq!(encode(b"foo"), "Zm9v");
        assert_eq!(encode(b"foob"), "Zm9vYg==");
        assert_eq!(encode(b"fooba"), "Zm9vYmE=");
        assert_eq!(encode(b"foobar"), "Zm9vYmFy");
    }

    #[test]
    fn test_encode_standard_safe() {
        assert_eq!(encode(&[251, 255]), "+/8=");
    }

    #[test]
    fn test_decode_basic() {
        assert_eq!(decode("").unwrap(), b"");
        assert_eq!(decode("Zg==").unwrap(), b"f");
        assert_eq!(decode("Zm8=").unwrap(), b"fo");
        assert_eq!(decode("Zm9v").unwrap(), b"foo");
        assert_eq!(decode("Zm9vYg==").unwrap(), b"foob");
        assert_eq!(decode("Zm9vYmE=").unwrap(), b"fooba");
        assert_eq!(decode("Zm9vYmFy").unwrap(), b"foobar");
    }

    #[test]
    fn test_decode() {
        assert_eq!(decode("Zm9vYmFy").unwrap(), b"foobar");
    }

    #[test]
    fn test_decode_newlines() {
        assert_eq!(decode("Zm9v\r\nYmFy").unwrap(), b"foobar");
        assert_eq!(decode("Zm9vYg==\r\n").unwrap(), b"foob");
        assert_eq!(decode("Zm9v\nYmFy").unwrap(), b"foobar");
        assert_eq!(decode("Zm9vYg==\n").unwrap(), b"foob");
    }

    #[test]
    fn test_decode_urlsafe() {
        assert_eq!(decode("-_8").unwrap(), decode("+/8=").unwrap());
    }

    #[test]
    fn test_from_base64_invalid_char() {
        assert!(decode("Zm$=").is_err());
        assert!(decode("Zg==$").is_err());
    }

    #[test]
    fn test_decode_invalid_padding() {
        assert!(decode("Z===").is_err());
    }
}

'''
'''--- protobuf-json-mapping/src/float.rs ---
pub const PROTOBUF_JSON_NAN: &str = "NaN";
pub const PROTOBUF_JSON_INF: &str = "Infinity";
pub const PROTOBUF_JSON_MINUS_INF: &str = "-Infinity";

'''
'''--- protobuf-json-mapping/src/lib.rs ---
//! JSON printer and parser which tries to follow
//! [protobuf conventions](https://developers.google.com/protocol-buffers/docs/proto3#json).

mod base64;
mod float;
mod parse;
mod print;
mod rfc_3339;
mod well_known_wrapper;

pub use self::parse::merge_from_str;
pub use self::parse::merge_from_str_with_options;
pub use self::parse::parse_dyn_from_str;
pub use self::parse::parse_dyn_from_str_with_options;
pub use self::parse::parse_from_str;
pub use self::parse::parse_from_str_with_options;
pub use self::parse::ParseError;
pub use self::parse::ParseOptions;
pub use self::print::print_to_string;
pub use self::print::print_to_string_with_options;
pub use self::print::PrintError;
pub use self::print::PrintOptions;

'''
'''--- protobuf-json-mapping/src/parse.rs ---
use std::num::ParseFloatError;
use std::num::ParseIntError;

use protobuf::reflect::EnumDescriptor;
use protobuf::reflect::EnumValueDescriptor;
use protobuf::reflect::FieldDescriptor;
use protobuf::reflect::MessageDescriptor;
use protobuf::reflect::ReflectValueBox;
use protobuf::reflect::RuntimeFieldType;
use protobuf::reflect::RuntimeType;
use protobuf::well_known_types::any::Any;
use protobuf::well_known_types::duration::Duration;
use protobuf::well_known_types::field_mask::FieldMask;
use protobuf::well_known_types::struct_;
use protobuf::well_known_types::struct_::ListValue;
use protobuf::well_known_types::struct_::NullValue;
use protobuf::well_known_types::struct_::Struct;
use protobuf::well_known_types::struct_::Value;
use protobuf::well_known_types::timestamp::Timestamp;
use protobuf::well_known_types::wrappers::BoolValue;
use protobuf::well_known_types::wrappers::BytesValue;
use protobuf::well_known_types::wrappers::DoubleValue;
use protobuf::well_known_types::wrappers::FloatValue;
use protobuf::well_known_types::wrappers::Int32Value;
use protobuf::well_known_types::wrappers::Int64Value;
use protobuf::well_known_types::wrappers::StringValue;
use protobuf::well_known_types::wrappers::UInt32Value;
use protobuf::well_known_types::wrappers::UInt64Value;
use protobuf::Enum;
use protobuf::MessageDyn;
use protobuf::MessageFull;
use protobuf_support::lexer::json_number_lit::JsonNumberLit;
use protobuf_support::lexer::lexer_impl::Lexer;
use protobuf_support::lexer::lexer_impl::LexerError;
use protobuf_support::lexer::loc::Loc;
use protobuf_support::lexer::parser_language::ParserLanguage;
use protobuf_support::lexer::token::Token;
use protobuf_support::lexer::tokenizer::Tokenizer;
use protobuf_support::lexer::tokenizer::TokenizerError;

use super::base64;
use super::float;
use super::rfc_3339;
use crate::base64::FromBase64Error;
use crate::well_known_wrapper::WellKnownWrapper;

#[derive(Debug, thiserror::Error)]
enum ParseErrorWithoutLocInner {
    #[error(transparent)]
    TokenizerError(#[from] TokenizerError),
    #[error("Unknown field name: `{}`", .0)]
    UnknownFieldName(String),
    #[error("Unknown enum variant name: `{}`", .0)]
    UnknownEnumVariantName(String),
    #[error(transparent)]
    FromBase64Error(#[from] FromBase64Error),
    #[error(transparent)]
    IncorrectStrLit(#[from] LexerError),
    #[error("Incorrect duration")]
    IncorrectDuration,
    #[error(transparent)]
    Rfc3339(#[from] rfc_3339::Rfc3339ParseError),
    #[error(transparent)]
    ParseIntError(#[from] ParseIntError),
    #[error(transparent)]
    ParseFloatError(#[from] ParseFloatError),
    #[error("Expecting bool")]
    ExpectingBool,
    #[error("Expecting string or integer")]
    ExpectingStrOrInt,
    #[error("Expecting number")]
    ExpectingNumber,
    #[error("Unexpected token")]
    UnexpectedToken,
    #[error("Any parsing is not implemented")]
    AnyParsingIsNotImplemented,
    #[error("Message not initialized")]
    MessageNotInitialized,
}

/// JSON parse error.
#[derive(Debug, thiserror::Error)]
#[error(transparent)]
struct ParseErrorWithoutLoc(ParseErrorWithoutLocInner);

impl From<TokenizerError> for ParseErrorWithoutLoc {
    fn from(e: TokenizerError) -> Self {
        ParseErrorWithoutLoc(ParseErrorWithoutLocInner::TokenizerError(e))
    }
}

impl From<FromBase64Error> for ParseErrorWithoutLoc {
    fn from(e: FromBase64Error) -> Self {
        ParseErrorWithoutLoc(ParseErrorWithoutLocInner::FromBase64Error(e))
    }
}

impl From<ParseIntError> for ParseErrorWithoutLoc {
    fn from(e: ParseIntError) -> Self {
        ParseErrorWithoutLoc(ParseErrorWithoutLocInner::ParseIntError(e))
    }
}

impl From<ParseFloatError> for ParseErrorWithoutLoc {
    fn from(e: ParseFloatError) -> Self {
        ParseErrorWithoutLoc(ParseErrorWithoutLocInner::ParseFloatError(e))
    }
}

impl From<rfc_3339::Rfc3339ParseError> for ParseErrorWithoutLoc {
    fn from(e: rfc_3339::Rfc3339ParseError) -> Self {
        ParseErrorWithoutLoc(ParseErrorWithoutLocInner::Rfc3339(e))
    }
}

/// JSON parse error
#[derive(Debug, thiserror::Error)]
#[error("{} at {}", error, loc)]
pub struct ParseError {
    error: ParseErrorWithoutLoc,
    loc: Loc,
}

type ParseResultWithoutLoc<A> = Result<A, ParseErrorWithoutLoc>;
type ParseResult<A> = Result<A, ParseError>;

#[derive(Clone)]
struct Parser<'a> {
    tokenizer: Tokenizer<'a>,
    parse_options: ParseOptions,
}

trait FromJsonNumber: PartialEq + Sized {
    fn from_f64(v: f64) -> Self;
    fn to_f64(&self) -> f64;
    fn from_string(v: &str) -> ParseResultWithoutLoc<Self>;
}

impl FromJsonNumber for u32 {
    fn from_f64(v: f64) -> Self {
        v as u32
    }

    fn to_f64(&self) -> f64 {
        *self as f64
    }

    fn from_string(v: &str) -> Result<Self, ParseErrorWithoutLoc> {
        Ok(v.parse()?)
    }
}

impl FromJsonNumber for u64 {
    fn from_f64(v: f64) -> Self {
        v as u64
    }

    fn to_f64(&self) -> f64 {
        *self as f64
    }

    fn from_string(v: &str) -> Result<Self, ParseErrorWithoutLoc> {
        Ok(v.parse()?)
    }
}

impl FromJsonNumber for i32 {
    fn from_f64(v: f64) -> Self {
        v as i32
    }

    fn to_f64(&self) -> f64 {
        *self as f64
    }

    fn from_string(v: &str) -> Result<Self, ParseErrorWithoutLoc> {
        Ok(v.parse()?)
    }
}

impl FromJsonNumber for i64 {
    fn from_f64(v: f64) -> Self {
        v as i64
    }

    fn to_f64(&self) -> f64 {
        *self as f64
    }

    fn from_string(v: &str) -> Result<Self, ParseErrorWithoutLoc> {
        Ok(v.parse()?)
    }
}

impl FromJsonNumber for f32 {
    fn from_f64(v: f64) -> Self {
        v as f32
    }

    fn to_f64(&self) -> f64 {
        *self as f64
    }

    fn from_string(v: &str) -> Result<Self, ParseErrorWithoutLoc> {
        if v == float::PROTOBUF_JSON_INF {
            Ok(f32::INFINITY)
        } else if v == float::PROTOBUF_JSON_MINUS_INF {
            Ok(f32::NEG_INFINITY)
        } else if v == float::PROTOBUF_JSON_NAN {
            Ok(f32::NAN)
        } else {
            Ok(v.parse()?)
        }
    }
}

impl FromJsonNumber for f64 {
    fn from_f64(v: f64) -> Self {
        v
    }

    fn to_f64(&self) -> f64 {
        *self
    }

    fn from_string(v: &str) -> Result<Self, ParseErrorWithoutLoc> {
        if v == float::PROTOBUF_JSON_INF {
            Ok(f64::INFINITY)
        } else if v == float::PROTOBUF_JSON_MINUS_INF {
            Ok(f64::NEG_INFINITY)
        } else if v == float::PROTOBUF_JSON_NAN {
            Ok(f64::NAN)
        } else {
            Ok(v.parse()?)
        }
    }
}

impl<'a> Parser<'a> {
    fn read_bool(&mut self) -> ParseResultWithoutLoc<bool> {
        if self.tokenizer.next_ident_if_eq("true")? {
            Ok(true)
        } else if self.tokenizer.next_ident_if_eq("false")? {
            Ok(false)
        } else {
            Err(ParseErrorWithoutLoc(
                ParseErrorWithoutLocInner::ExpectingBool,
            ))
        }
    }

    fn parse_bool(&self, s: &str) -> ParseResultWithoutLoc<bool> {
        if s == "true" {
            Ok(true)
        } else if s == "false" {
            Ok(false)
        } else {
            Err(ParseErrorWithoutLoc(
                ParseErrorWithoutLocInner::ExpectingBool,
            ))
        }
    }

    fn read_json_number_opt(&mut self) -> ParseResultWithoutLoc<Option<JsonNumberLit>> {
        Ok(self.tokenizer.next_token_if_map(|t| match t {
            Token::JsonNumber(v) => Some(v.clone()),
            _ => None,
        })?)
    }

    fn read_number<V: FromJsonNumber>(&mut self) -> ParseResultWithoutLoc<V> {
        if let Some(v) = self.read_json_number_opt()? {
            V::from_string(&v.0)
        } else if self.tokenizer.lookahead_is_str_lit()? {
            let v = self.read_string()?;
            self.parse_number(&v)
        } else {
            Err(ParseErrorWithoutLoc(
                ParseErrorWithoutLocInner::ExpectingNumber,
            ))
        }
    }

    fn parse_number<V: FromJsonNumber>(&self, s: &str) -> ParseResultWithoutLoc<V> {
        V::from_string(s)
    }

    fn merge_wrapper<W>(&mut self, w: &mut W) -> ParseResultWithoutLoc<()>
    where
        W: WellKnownWrapper,
        W::Underlying: FromJsonNumber,
    {
        *w.get_mut() = self.read_number()?;
        Ok(())
    }

    fn merge_bool_value(&mut self, w: &mut BoolValue) -> ParseResultWithoutLoc<()> {
        w.value = self.read_bool()?;
        Ok(())
    }

    fn merge_string_value(&mut self, w: &mut StringValue) -> ParseResultWithoutLoc<()> {
        w.value = self.read_string()?;
        Ok(())
    }

    fn merge_bytes_value(&mut self, w: &mut BytesValue) -> ParseResultWithoutLoc<()> {
        w.value = self.read_bytes()?;
        Ok(())
    }

    fn read_u32(&mut self) -> ParseResultWithoutLoc<u32> {
        self.read_number()
    }

    fn read_u64(&mut self) -> ParseResultWithoutLoc<u64> {
        self.read_number()
    }

    fn read_i32(&mut self) -> ParseResultWithoutLoc<i32> {
        self.read_number()
    }

    fn read_i64(&mut self) -> ParseResultWithoutLoc<i64> {
        self.read_number()
    }

    fn read_f32(&mut self) -> ParseResultWithoutLoc<f32> {
        self.read_number()
    }

    fn read_f64(&mut self) -> ParseResultWithoutLoc<f64> {
        self.read_number()
    }

    fn read_string(&mut self) -> ParseResultWithoutLoc<String> {
        let str_lit = self.tokenizer.next_str_lit()?;

        let mut lexer = Lexer::new(&str_lit.escaped, ParserLanguage::Json);
        let mut r = String::new();
        while !lexer.eof() {
            r.push(
                lexer
                    .next_json_char_value()
                    .map_err(ParseErrorWithoutLocInner::IncorrectStrLit)
                    .map_err(ParseErrorWithoutLoc)?,
            );
        }
        Ok(r)
    }

    fn read_bytes(&mut self) -> ParseResultWithoutLoc<Vec<u8>> {
        let s = self.read_string()?;
        self.parse_bytes(&s)
    }

    fn parse_bytes(&self, s: &str) -> ParseResultWithoutLoc<Vec<u8>> {
        Ok(base64::decode(s)?)
    }

    fn read_enum(&mut self, descriptor: &EnumDescriptor) -> ParseResultWithoutLoc<i32> {
        if descriptor.is::<NullValue>() {
            return Ok(self.read_wk_null_value()?.value());
        }

        if self.tokenizer.lookahead_is_str_lit()? {
            let name = self.read_string()?;
            Ok(self.parse_enum(name, descriptor)?.value())
        } else if self.tokenizer.lookahead_is_json_number()? {
            self.read_i32()
        } else {
            Err(ParseErrorWithoutLoc(
                ParseErrorWithoutLocInner::ExpectingStrOrInt,
            ))
        }
    }

    fn parse_enum(
        &self,
        name: String,
        descriptor: &EnumDescriptor,
    ) -> ParseResultWithoutLoc<EnumValueDescriptor> {
        match descriptor.value_by_name(&name) {
            Some(v) => Ok(v),
            None => Err(ParseErrorWithoutLoc(
                ParseErrorWithoutLocInner::UnknownEnumVariantName(name),
            )),
        }
    }

    fn read_wk_null_value(&mut self) -> ParseResultWithoutLoc<NullValue> {
        self.tokenizer.next_ident_expect_eq("null")?;
        Ok(NullValue::NULL_VALUE)
    }

    fn read_message(
        &mut self,
        descriptor: &MessageDescriptor,
    ) -> ParseResultWithoutLoc<Box<dyn MessageDyn>> {
        let mut m = descriptor.new_instance();
        self.merge_inner(&mut *m)?;
        Ok(m)
    }

    fn read_value(&mut self, t: &RuntimeType) -> ParseResultWithoutLoc<ReflectValueBox> {
        match t {
            RuntimeType::I32 => self.read_i32().map(ReflectValueBox::from),
            RuntimeType::I64 => self.read_i64().map(ReflectValueBox::from),
            RuntimeType::U32 => self.read_u32().map(ReflectValueBox::from),
            RuntimeType::U64 => self.read_u64().map(ReflectValueBox::from),
            RuntimeType::F32 => self.read_f32().map(ReflectValueBox::from),
            RuntimeType::F64 => self.read_f64().map(ReflectValueBox::from),
            RuntimeType::Bool => self.read_bool().map(ReflectValueBox::from),
            RuntimeType::String => self.read_string().map(ReflectValueBox::from),
            RuntimeType::VecU8 => self.read_bytes().map(ReflectValueBox::from),
            RuntimeType::Enum(e) => self
                .read_enum(&e)
                .map(|v| ReflectValueBox::Enum(e.clone(), v)),
            RuntimeType::Message(m) => self.read_message(&m).map(ReflectValueBox::from),
        }
    }

    fn merge_singular_field(
        &mut self,
        message: &mut dyn MessageDyn,
        field: &FieldDescriptor,
        t: &RuntimeType,
    ) -> ParseResultWithoutLoc<()> {
        field.set_singular_field(message, self.read_value(t)?);
        Ok(())
    }

    fn read_list<C>(&mut self, mut read_item: C) -> ParseResultWithoutLoc<()>
    where
        C: for<'b> FnMut(&'b mut Self) -> ParseResultWithoutLoc<()>,
    {
        if self.tokenizer.next_ident_if_eq("null")? {
            return Ok(());
        }

        // TODO: better error reporting on wrong field type
        self.tokenizer.next_symbol_expect_eq('[', "list")?;
        let mut first = true;
        while !self.tokenizer.next_symbol_if_eq(']')? {
            if !first {
                self.tokenizer.next_symbol_expect_eq(',', "list")?;
            }
            first = false;

            read_item(self)?;
        }

        Ok(())
    }

    fn merge_repeated_field(
        &mut self,
        message: &mut dyn MessageDyn,
        field: &FieldDescriptor,
        t: &RuntimeType,
    ) -> ParseResultWithoutLoc<()> {
        let mut repeated = field.mut_repeated(message);
        repeated.clear();

        self.read_list(|s| {
            repeated.push(s.read_value(t)?);
            Ok(())
        })
    }

    fn merge_wk_list_value(&mut self, list: &mut ListValue) -> ParseResultWithoutLoc<()> {
        list.values.clear();

        self.read_list(|s| {
            list.values.push(s.read_wk_value()?);
            Ok(())
        })
    }

    fn read_map<K, Fk, Fi>(
        &mut self,
        mut parse_key: Fk,
        mut read_value_and_insert: Fi,
    ) -> ParseResultWithoutLoc<()>
    where
        Fk: for<'b> FnMut(&Self, String) -> ParseResultWithoutLoc<K>,
        Fi: for<'b> FnMut(&mut Self, K) -> ParseResultWithoutLoc<()>,
    {
        if self.tokenizer.next_ident_if_eq("null")? {
            return Ok(());
        }

        self.tokenizer.next_symbol_expect_eq('{', "map")?;
        let mut first = true;
        while !self.tokenizer.next_symbol_if_eq('}')? {
            if !first {
                self.tokenizer.next_symbol_expect_eq(',', "map")?;
            }
            first = false;

            let key_string = self.read_string()?;
            let k = parse_key(self, key_string)?;

            self.tokenizer.next_symbol_expect_eq(':', "map")?;
            read_value_and_insert(self, k)?;
        }

        Ok(())
    }

    fn parse_key(&self, key: String, t: &RuntimeType) -> ParseResultWithoutLoc<ReflectValueBox> {
        match t {
            RuntimeType::I32 => self.parse_number::<i32>(&key).map(ReflectValueBox::I32),
            RuntimeType::I64 => self.parse_number::<i64>(&key).map(ReflectValueBox::I64),
            RuntimeType::U32 => self.parse_number::<u32>(&key).map(ReflectValueBox::U32),
            RuntimeType::U64 => self.parse_number::<u64>(&key).map(ReflectValueBox::U64),
            RuntimeType::Bool => self.parse_bool(&key).map(ReflectValueBox::Bool),
            RuntimeType::String => Ok(ReflectValueBox::String(key)),
            t @ RuntimeType::F32
            | t @ RuntimeType::F64
            | t @ RuntimeType::VecU8
            | t @ RuntimeType::Enum(..) => panic!("{} cannot be a map key", t),
            RuntimeType::Message(_) => panic!("message cannot be a map key"),
        }
    }

    fn merge_map_field(
        &mut self,
        message: &mut dyn MessageDyn,
        field: &FieldDescriptor,
        kt: &RuntimeType,
        vt: &RuntimeType,
    ) -> ParseResultWithoutLoc<()> {
        let mut map = field.mut_map(message);
        map.clear();

        self.read_map(
            |ss, s| ss.parse_key(s, kt),
            |s, k| {
                let v = s.read_value(vt)?;
                map.insert(k, v);
                Ok(())
            },
        )
    }

    fn merge_wk_struct(&mut self, struct_value: &mut Struct) -> ParseResultWithoutLoc<()> {
        struct_value.fields.clear();

        self.read_map(
            |_, s| Ok(s),
            |s, k| {
                let v = s.read_wk_value()?;
                struct_value.fields.insert(k, v);
                Ok(())
            },
        )
    }

    fn skip_json_value(&mut self) -> ParseResultWithoutLoc<()> {
        if self
            .tokenizer
            .next_ident_if_in(&["true", "false", "null"])?
            .is_some()
        {
        } else if self.tokenizer.lookahead_is_str_lit()? {
            self.tokenizer.next_str_lit()?;
        } else if self.tokenizer.lookahead_is_json_number()? {
            self.read_json_number_opt()?;
        } else if self.tokenizer.lookahead_is_symbol('[')? {
            self.read_list(|s| s.skip_json_value())?;
        } else if self.tokenizer.lookahead_is_symbol('{')? {
            self.read_map(|_, _| Ok(()), |s, ()| s.skip_json_value())?;
        } else {
            return Err(ParseErrorWithoutLoc(
                ParseErrorWithoutLocInner::UnexpectedToken,
            ));
        }
        Ok(())
    }

    fn merge_field(
        &mut self,
        message: &mut dyn MessageDyn,
        field: &FieldDescriptor,
    ) -> ParseResultWithoutLoc<()> {
        match field.runtime_field_type() {
            RuntimeFieldType::Singular(t) => self.merge_singular_field(message, field, &t),
            RuntimeFieldType::Repeated(t) => self.merge_repeated_field(message, field, &t),
            RuntimeFieldType::Map(kt, vt) => self.merge_map_field(message, field, &kt, &vt),
        }
    }

    fn merge_inner(&mut self, message: &mut dyn MessageDyn) -> ParseResultWithoutLoc<()> {
        if let Some(duration) = message.downcast_mut() {
            return self.merge_wk_duration(duration);
        }

        if let Some(timestamp) = message.downcast_mut() {
            return self.merge_wk_timestamp(timestamp);
        }

        if let Some(field_mask) = message.downcast_mut() {
            return self.merge_wk_field_mask(field_mask);
        }

        if let Some(value) = message.downcast_mut() {
            return self.merge_wk_value(value);
        }

        if let Some(value) = message.downcast_mut() {
            return self.merge_wk_any(value);
        }

        if let Some(value) = message.downcast_mut::<DoubleValue>() {
            return self.merge_wrapper(value);
        }

        if let Some(value) = message.downcast_mut::<FloatValue>() {
            return self.merge_wrapper(value);
        }

        if let Some(value) = message.downcast_mut::<Int64Value>() {
            return self.merge_wrapper(value);
        }

        if let Some(value) = message.downcast_mut::<UInt64Value>() {
            return self.merge_wrapper(value);
        }

        if let Some(value) = message.downcast_mut::<Int32Value>() {
            return self.merge_wrapper(value);
        }

        if let Some(value) = message.downcast_mut::<UInt32Value>() {
            return self.merge_wrapper(value);
        }

        if let Some(value) = message.downcast_mut::<BoolValue>() {
            return self.merge_bool_value(value);
        }

        if let Some(value) = message.downcast_mut::<StringValue>() {
            return self.merge_string_value(value);
        }

        if let Some(value) = message.downcast_mut::<BytesValue>() {
            return self.merge_bytes_value(value);
        }

        if let Some(value) = message.downcast_mut::<ListValue>() {
            return self.merge_wk_list_value(value);
        }

        if let Some(value) = message.downcast_mut::<Struct>() {
            return self.merge_wk_struct(value);
        }

        let descriptor = message.descriptor_dyn();

        self.tokenizer.next_symbol_expect_eq('{', "object")?;
        let mut first = true;
        while !self.tokenizer.next_symbol_if_eq('}')? {
            if !first {
                self.tokenizer.next_symbol_expect_eq(',', "object")?;
            }
            first = false;

            let field_name = self.read_string()?;
            // Proto3 JSON parsers are required to accept both
            // the converted `lowerCamelCase` name and the proto field name.
            match descriptor.field_by_name_or_json_name(&field_name) {
                Some(field) => {
                    self.tokenizer.next_symbol_expect_eq(':', "object")?;
                    self.merge_field(message, &field)?;
                }
                None if self.parse_options.ignore_unknown_fields => {
                    self.tokenizer.next_symbol_expect_eq(':', "object")?;
                    self.skip_json_value()?;
                }
                None => {
                    return Err(ParseErrorWithoutLoc(
                        ParseErrorWithoutLocInner::UnknownFieldName(field_name),
                    ))
                }
            };
        }
        Ok(())
    }

    fn merge_wk_duration(&mut self, duration: &mut Duration) -> ParseResultWithoutLoc<()> {
        let s = self.read_string()?;
        let mut lexer = Lexer::new(&s, ParserLanguage::Json);

        fn next_dec(lexer: &mut Lexer) -> ParseResultWithoutLoc<(u64, u32)> {
            let s = lexer.take_while(|c| c >= '0' && c <= '9');

            if s.len() == 0 {
                Ok((0, 0))
            } else {
                match s.parse() {
                    Ok(n) => Ok((n, s.len() as u32)),
                    Err(_) => Err(ParseErrorWithoutLoc(
                        ParseErrorWithoutLocInner::IncorrectDuration,
                    )),
                }
            }
        }

        let minus = lexer.next_char_if_eq('-');
        let seconds = match next_dec(&mut lexer)? {
            (_, 0) => {
                return Err(ParseErrorWithoutLoc(
                    ParseErrorWithoutLocInner::IncorrectDuration,
                ))
            }
            (s, _) => s,
        };
        let nanos = if lexer.next_char_if_eq('.') {
            let (mut a, mut b) = next_dec(&mut lexer)?;
            if b > 9 {
                return Err(ParseErrorWithoutLoc(
                    ParseErrorWithoutLocInner::IncorrectDuration,
                ));
            }
            while b != 9 {
                b += 1;
                a *= 10;
            }

            if a > 999_999_999 {
                return Err(ParseErrorWithoutLoc(
                    ParseErrorWithoutLocInner::IncorrectDuration,
                ));
            }

            a
        } else {
            0
        };

        // The suffix "s" is required
        if !lexer.next_char_if_eq('s') {
            return Err(ParseErrorWithoutLoc(
                ParseErrorWithoutLocInner::IncorrectDuration,
            ));
        }

        if !lexer.eof() {
            return Err(ParseErrorWithoutLoc(
                ParseErrorWithoutLocInner::IncorrectDuration,
            ));
        }

        if minus {
            duration.seconds = -(seconds as i64);
            duration.nanos = -(nanos as i32);
        } else {
            duration.seconds = seconds as i64;
            duration.nanos = nanos as i32;
        }
        Ok(())
    }

    fn merge_wk_timestamp(&mut self, timestamp: &mut Timestamp) -> ParseResultWithoutLoc<()> {
        let s = self.read_string()?;
        let (seconds, nanos) = rfc_3339::TmUtc::parse_rfc_3339(&s)?;
        timestamp.seconds = seconds;
        timestamp.nanos = nanos as i32;
        Ok(())
    }

    fn merge_wk_field_mask(&mut self, field_mask: &mut FieldMask) -> ParseResultWithoutLoc<()> {
        let s = self.read_string()?;
        if !s.is_empty() {
            field_mask.paths = s.split(',').map(|s| s.to_owned()).collect();
        }
        Ok(())
    }

    fn read_wk_list_value(&mut self) -> ParseResultWithoutLoc<ListValue> {
        let mut r = ListValue::new();
        self.merge_wk_list_value(&mut r)?;
        Ok(r)
    }

    fn read_wk_struct(&mut self) -> ParseResultWithoutLoc<Struct> {
        let mut r = Struct::new();
        self.merge_wk_struct(&mut r)?;
        Ok(r)
    }

    fn merge_wk_value(&mut self, value: &mut Value) -> ParseResultWithoutLoc<()> {
        if self.tokenizer.lookahead_is_ident("null")? {
            value.kind = Some(struct_::value::Kind::NullValue(
                self.read_wk_null_value()?.into(),
            ));
        } else if self.tokenizer.lookahead_is_ident("true")?
            || self.tokenizer.lookahead_is_ident("false")?
        {
            value.kind = Some(struct_::value::Kind::BoolValue(self.read_bool()?));
        } else if self.tokenizer.lookahead_is_json_number()? {
            value.kind = Some(struct_::value::Kind::NumberValue(self.read_f64()?));
        } else if self.tokenizer.lookahead_is_str_lit()? {
            value.kind = Some(struct_::value::Kind::StringValue(self.read_string()?));
        } else if self.tokenizer.lookahead_is_symbol('[')? {
            value.kind = Some(struct_::value::Kind::ListValue(self.read_wk_list_value()?));
        } else if self.tokenizer.lookahead_is_symbol('{')? {
            value.kind = Some(struct_::value::Kind::StructValue(self.read_wk_struct()?));
        } else {
            return Err(ParseErrorWithoutLoc(
                ParseErrorWithoutLocInner::UnexpectedToken,
            ));
        }
        Ok(())
    }

    fn merge_wk_any(&mut self, _value: &mut Any) -> ParseResultWithoutLoc<()> {
        Err(ParseErrorWithoutLoc(
            ParseErrorWithoutLocInner::AnyParsingIsNotImplemented,
        ))
    }

    fn read_wk_value(&mut self) -> ParseResultWithoutLoc<Value> {
        let mut v = Value::new();
        self.merge_wk_value(&mut v)?;
        Ok(v)
    }

    fn merge(&mut self, message: &mut dyn MessageDyn) -> ParseResult<()> {
        match self.merge_inner(message) {
            Ok(()) => Ok(()),
            Err(error) => Err(ParseError {
                error,
                loc: self.tokenizer.loc(),
            }),
        }
    }
}

/// JSON parse options.
///
/// # Examples
///
/// ```
/// let parse_options = protobuf_json_mapping::ParseOptions {
///     ignore_unknown_fields: true,
///     ..Default::default()
/// };
/// ```
#[derive(Default, Debug, Clone)]
pub struct ParseOptions {
    /// Ignore unknown fields when parsing.
    ///
    /// When `true` fields with unknown names are ignored.
    /// When `false` parser returns an error on unknown field.
    pub ignore_unknown_fields: bool,
    /// Prevent initializing `ParseOptions` enumerating all field.
    pub _future_options: (),
}

/// Merge JSON into provided message
pub fn merge_from_str_with_options(
    message: &mut dyn MessageDyn,
    json: &str,
    parse_options: &ParseOptions,
) -> ParseResult<()> {
    let mut parser = Parser {
        tokenizer: Tokenizer::new(json, ParserLanguage::Json),
        parse_options: parse_options.clone(),
    };
    parser.merge(message)
}

/// Merge JSON into provided message
pub fn merge_from_str(message: &mut dyn MessageDyn, json: &str) -> ParseResult<()> {
    merge_from_str_with_options(message, json, &ParseOptions::default())
}

/// Parse JSON to protobuf message.
pub fn parse_dyn_from_str_with_options(
    d: &MessageDescriptor,
    json: &str,
    parse_options: &ParseOptions,
) -> ParseResult<Box<dyn MessageDyn>> {
    let mut m = d.new_instance();
    merge_from_str_with_options(&mut *m, json, parse_options)?;
    if let Err(_) = m.check_initialized_dyn() {
        return Err(ParseError {
            error: ParseErrorWithoutLoc(ParseErrorWithoutLocInner::MessageNotInitialized),
            loc: Loc::start(),
        });
    }
    Ok(m)
}

/// Parse JSON to protobuf message.
pub fn parse_dyn_from_str(d: &MessageDescriptor, json: &str) -> ParseResult<Box<dyn MessageDyn>> {
    parse_dyn_from_str_with_options(d, json, &ParseOptions::default())
}

/// Parse JSON to protobuf message.
pub fn parse_from_str_with_options<M: MessageFull>(
    json: &str,
    parse_options: &ParseOptions,
) -> ParseResult<M> {
    let m = parse_dyn_from_str_with_options(&M::descriptor(), json, parse_options)?;
    Ok(*m.downcast_box().unwrap())
}

/// Parse JSON to protobuf message.
pub fn parse_from_str<M: MessageFull>(json: &str) -> ParseResult<M> {
    parse_from_str_with_options(json, &ParseOptions::default())
}

'''
'''--- protobuf-json-mapping/src/print.rs ---
use std::fmt;
use std::fmt::Write as fmt_Write;

use protobuf::reflect::EnumDescriptor;
use protobuf::reflect::EnumValueDescriptor;
use protobuf::reflect::MessageRef;
use protobuf::reflect::ReflectFieldRef;
use protobuf::reflect::ReflectMapRef;
use protobuf::reflect::ReflectRepeatedRef;
use protobuf::reflect::ReflectValueRef;
use protobuf::reflect::RuntimeFieldType;
use protobuf::reflect::RuntimeType;
use protobuf::well_known_types::any::Any;
use protobuf::well_known_types::duration::Duration;
use protobuf::well_known_types::field_mask::FieldMask;
use protobuf::well_known_types::struct_::value;
use protobuf::well_known_types::struct_::ListValue;
use protobuf::well_known_types::struct_::NullValue;
use protobuf::well_known_types::struct_::Struct;
use protobuf::well_known_types::struct_::Value;
use protobuf::well_known_types::timestamp::Timestamp;
use protobuf::well_known_types::wrappers::BoolValue;
use protobuf::well_known_types::wrappers::BytesValue;
use protobuf::well_known_types::wrappers::DoubleValue;
use protobuf::well_known_types::wrappers::FloatValue;
use protobuf::well_known_types::wrappers::Int32Value;
use protobuf::well_known_types::wrappers::Int64Value;
use protobuf::well_known_types::wrappers::StringValue;
use protobuf::well_known_types::wrappers::UInt32Value;
use protobuf::well_known_types::wrappers::UInt64Value;
use protobuf::MessageDyn;

use crate::base64;
use crate::float;
use crate::rfc_3339::TmUtc;
use crate::well_known_wrapper::WellKnownWrapper;

#[derive(Debug, thiserror::Error)]
enum PrintErrorInner {
    #[error(transparent)]
    Fmt(fmt::Error),
    #[error("JSON printing of Any is not implemented")]
    AnyPrintingIsNotImplemented,
    #[error("Negative nanoseconds in timestamp")]
    TimestampNegativeNanos,
    #[error("Unknown struct value kind")]
    UnknownStructValueKind,
}

/// Print to JSON error.
#[derive(Debug, thiserror::Error)]
#[error(transparent)]
pub struct PrintError(PrintErrorInner);

impl From<fmt::Error> for PrintError {
    fn from(e: fmt::Error) -> Self {
        PrintError(PrintErrorInner::Fmt(e))
    }
}

pub type PrintResult<T> = Result<T, PrintError>;

struct Printer {
    buf: String,
    print_options: PrintOptions,
}

trait PrintableToJson {
    fn print_to_json(&self, w: &mut Printer) -> PrintResult<()>;
}

trait JsonFloat: fmt::Display + fmt::Debug + PrintableToJson {
    fn is_nan(&self) -> bool;
    fn is_pos_infinity(&self) -> bool;
    fn is_neg_infinity(&self) -> bool;

    fn print_to_json_impl(&self, w: &mut String) -> PrintResult<()> {
        Ok(if self.is_nan() {
            write!(w, "\"{}\"", float::PROTOBUF_JSON_NAN)?
        } else if self.is_pos_infinity() {
            write!(w, "\"{}\"", float::PROTOBUF_JSON_INF)?
        } else if self.is_neg_infinity() {
            write!(w, "\"{}\"", float::PROTOBUF_JSON_MINUS_INF)?
        } else {
            write!(w, "{:?}", self)?
        })
    }
}

impl JsonFloat for f32 {
    fn is_nan(&self) -> bool {
        f32::is_nan(*self)
    }

    fn is_pos_infinity(&self) -> bool {
        f32::is_infinite(*self) && self > &0.0
    }

    fn is_neg_infinity(&self) -> bool {
        f32::is_infinite(*self) && self < &0.0
    }
}

impl PrintableToJson for f32 {
    fn print_to_json(&self, w: &mut Printer) -> PrintResult<()> {
        Ok(self.print_to_json_impl(&mut w.buf)?)
    }
}

impl JsonFloat for f64 {
    fn is_nan(&self) -> bool {
        f64::is_nan(*self)
    }

    fn is_pos_infinity(&self) -> bool {
        f64::is_infinite(*self) && self > &0.0
    }

    fn is_neg_infinity(&self) -> bool {
        f64::is_infinite(*self) && self < &0.0
    }
}

impl PrintableToJson for f64 {
    fn print_to_json(&self, w: &mut Printer) -> PrintResult<()> {
        self.print_to_json_impl(&mut w.buf)
    }
}

impl PrintableToJson for u64 {
    fn print_to_json(&self, w: &mut Printer) -> PrintResult<()> {
        // 64-bit integers are quoted by default
        Ok(write!(w.buf, "\"{}\"", self)?)
    }
}

impl PrintableToJson for i64 {
    fn print_to_json(&self, w: &mut Printer) -> PrintResult<()> {
        // 64-bit integers are quoted by default
        Ok(write!(w.buf, "\"{}\"", self)?)
    }
}

impl PrintableToJson for u32 {
    fn print_to_json(&self, w: &mut Printer) -> PrintResult<()> {
        Ok(write!(w.buf, "{}", self)?)
    }
}

impl PrintableToJson for i32 {
    fn print_to_json(&self, w: &mut Printer) -> PrintResult<()> {
        Ok(write!(w.buf, "{}", self)?)
    }
}

impl PrintableToJson for bool {
    fn print_to_json(&self, w: &mut Printer) -> PrintResult<()> {
        Ok(write!(w.buf, "{}", self)?)
    }
}

impl PrintableToJson for str {
    fn print_to_json(&self, w: &mut Printer) -> PrintResult<()> {
        write!(w.buf, "\"")?;
        for c in self.chars() {
            match c {
                '"' => write!(w.buf, "\\\""),
                '\\' => write!(w.buf, "\\\\"),
                '\n' => write!(w.buf, "\\n"),
                '\r' => write!(w.buf, "\\r"),
                '\t' => write!(w.buf, "\\t"),
                c if c.is_control() => write!(w.buf, "\\u{:04x}", c as u32),
                c => write!(w.buf, "{}", c),
            }?;
        }
        write!(w.buf, "\"")?;
        Ok(())
    }
}

impl PrintableToJson for String {
    fn print_to_json(&self, w: &mut Printer) -> PrintResult<()> {
        self.as_str().print_to_json(w)
    }
}

impl PrintableToJson for [u8] {
    fn print_to_json(&self, w: &mut Printer) -> PrintResult<()> {
        let encoded = base64::encode(self);
        encoded.print_to_json(w)
    }
}

impl PrintableToJson for Vec<u8> {
    fn print_to_json(&self, w: &mut Printer) -> PrintResult<()> {
        self.as_slice().print_to_json(w)
    }
}

impl<'a> PrintableToJson for ReflectValueRef<'a> {
    fn print_to_json(&self, w: &mut Printer) -> PrintResult<()> {
        match self {
            ReflectValueRef::U32(v) => w.print_printable(v),
            ReflectValueRef::U64(v) => w.print_printable(v),
            ReflectValueRef::I32(v) => w.print_printable(v),
            ReflectValueRef::I64(v) => w.print_printable(v),
            ReflectValueRef::F32(v) => w.print_printable(v),
            ReflectValueRef::F64(v) => w.print_printable(v),
            ReflectValueRef::Bool(v) => w.print_printable(v),
            ReflectValueRef::String(v) => w.print_printable::<str>(v),
            ReflectValueRef::Bytes(v) => w.print_printable::<[u8]>(v),
            ReflectValueRef::Enum(d, v) => w.print_enum(d, *v),
            ReflectValueRef::Message(v) => w.print_message(v),
        }
    }
}

impl PrintableToJson for Duration {
    fn print_to_json(&self, w: &mut Printer) -> PrintResult<()> {
        let sign = if self.seconds >= 0 { "" } else { "-" };
        Ok(write!(
            w.buf,
            "\"{}{}.{:09}s\"",
            sign,
            self.seconds.abs(),
            self.nanos.abs()
        )?)
    }
}

impl PrintableToJson for Timestamp {
    fn print_to_json(&self, w: &mut Printer) -> PrintResult<()> {
        if self.nanos < 0 {
            return Err(PrintError(PrintErrorInner::TimestampNegativeNanos));
        }
        let tm_utc = TmUtc::from_protobuf_timestamp(self.seconds, self.nanos as u32);
        w.print_printable(&tm_utc.to_string())
    }
}

impl PrintableToJson for FieldMask {
    fn print_to_json(&self, w: &mut Printer) -> PrintResult<()> {
        w.print_printable(&self.paths.join(","))
    }
}

impl PrintableToJson for Any {
    fn print_to_json(&self, _w: &mut Printer) -> PrintResult<()> {
        Err(PrintError(PrintErrorInner::AnyPrintingIsNotImplemented))
    }
}

impl PrintableToJson for Value {
    fn print_to_json(&self, w: &mut Printer) -> PrintResult<()> {
        match self.kind {
            // None should not be possible here, but it's better to print null than crash
            None => w.print_json_null(),
            Some(value::Kind::NullValue(null_value)) => {
                match null_value.enum_value() {
                    Ok(value) => w.print_wk_null_value(&value),
                    Err(n) => {
                        // Practically not possible, but it is safer this way.
                        w.print_printable(&n)
                    }
                }
            }
            Some(value::Kind::BoolValue(b)) => w.print_printable(&b),
            Some(value::Kind::NumberValue(n)) => w.print_printable(&n),
            Some(value::Kind::StringValue(ref s)) => w.print_printable::<String>(&s),
            Some(value::Kind::StructValue(ref s)) => w.print_printable(&s),
            Some(value::Kind::ListValue(ref l)) => w.print_printable(&l),
            Some(_) => Err(PrintError(PrintErrorInner::UnknownStructValueKind)),
        }
    }
}

impl PrintableToJson for ListValue {
    fn print_to_json(&self, w: &mut Printer) -> PrintResult<()> {
        w.print_list(&self.values)
    }
}

impl PrintableToJson for Struct {
    fn print_to_json(&self, w: &mut Printer) -> PrintResult<()> {
        w.print_object(&self.fields)
    }
}

impl<'a, P: PrintableToJson> PrintableToJson for &'a P {
    fn print_to_json(&self, w: &mut Printer) -> PrintResult<()> {
        (*self).print_to_json(w)
    }
}

trait ObjectKey {
    fn print_object_key(&self, w: &mut Printer) -> PrintResult<()>;
}

impl<'a> ObjectKey for ReflectValueRef<'a> {
    fn print_object_key(&self, w: &mut Printer) -> PrintResult<()> {
        match self {
            ReflectValueRef::String(v) => return w.print_printable::<str>(v),
            ReflectValueRef::Bytes(v) => return w.print_printable::<[u8]>(v),
            // do not quote, because printable is quoted
            ReflectValueRef::U64(v) => return w.print_printable(v),
            ReflectValueRef::I64(v) => return w.print_printable(v),
            ReflectValueRef::Enum(d, v) if !w.print_options.enum_values_int => {
                return w.print_enum(d, *v)
            }
            _ => {}
        }

        write!(w.buf, "\"")?;

        match self {
            ReflectValueRef::U32(v) => w.print_printable(v),
            ReflectValueRef::I32(v) => w.print_printable(v),
            ReflectValueRef::Bool(v) => w.print_printable(v),
            ReflectValueRef::Enum(d, v) if w.print_options.enum_values_int => w.print_enum(d, *v),
            ReflectValueRef::Enum(..)
            | ReflectValueRef::U64(_)
            | ReflectValueRef::I64(_)
            | ReflectValueRef::String(_)
            | ReflectValueRef::Bytes(_) => unreachable!(),
            ReflectValueRef::F32(_) | ReflectValueRef::F64(_) | ReflectValueRef::Message(_) => {
                panic!("cannot be object key")
            }
        }?;

        write!(w.buf, "\"")?;

        Ok(())
    }
}

impl ObjectKey for String {
    fn print_object_key(&self, w: &mut Printer) -> PrintResult<()> {
        w.print_printable(self)
    }
}

impl<'a, O: ObjectKey> ObjectKey for &'a O {
    fn print_object_key(&self, w: &mut Printer) -> PrintResult<()> {
        (*self).print_object_key(w)
    }
}

impl Printer {
    fn print_comma_but_first(&mut self, first: &mut bool) -> fmt::Result {
        if *first {
            *first = false;
            Ok(())
        } else {
            write!(self.buf, ", ")
        }
    }

    fn print_json_null(&mut self) -> PrintResult<()> {
        Ok(write!(self.buf, "null")?)
    }

    fn print_printable<F: PrintableToJson + ?Sized>(&mut self, f: &F) -> PrintResult<()> {
        f.print_to_json(self)
    }

    fn print_list<I>(&mut self, items: I) -> PrintResult<()>
    where
        I: IntoIterator,
        I::Item: PrintableToJson,
    {
        write!(self.buf, "[")?;
        for (i, item) in items.into_iter().enumerate() {
            if i != 0 {
                write!(self.buf, ", ")?;
            }
            self.print_printable(&item)?;
        }
        write!(self.buf, "]")?;
        Ok(())
    }

    fn print_repeated(&mut self, repeated: &ReflectRepeatedRef) -> PrintResult<()> {
        self.print_list(repeated)
    }

    fn print_object<I, K, V>(&mut self, items: I) -> PrintResult<()>
    where
        I: IntoIterator<Item = (K, V)>,
        K: ObjectKey,
        V: PrintableToJson,
    {
        write!(self.buf, "{{")?;
        for (i, (k, v)) in items.into_iter().enumerate() {
            if i != 0 {
                write!(self.buf, ", ")?;
            }
            k.print_object_key(self)?;
            write!(self.buf, ": ")?;
            self.print_printable(&v)?;
        }
        write!(self.buf, "}}")?;
        Ok(())
    }

    fn print_map(&mut self, map: &ReflectMapRef) -> PrintResult<()> {
        self.print_object(map.into_iter())
    }

    fn print_enum_known(&mut self, value: &EnumValueDescriptor) -> PrintResult<()> {
        if let Some(null_value) = value.cast() {
            self.print_wk_null_value(&null_value)
        } else {
            if self.print_options.enum_values_int {
                self.print_printable(&value.value())
            } else {
                Ok(write!(self.buf, "\"{}\"", value.name())?)
            }
        }
    }

    fn print_enum(&mut self, descriptor: &EnumDescriptor, v: i32) -> PrintResult<()> {
        if self.print_options.enum_values_int {
            self.print_printable(&v)
        } else {
            match descriptor.value_by_number(v) {
                Some(value) => self.print_enum_known(&value),
                None => self.print_printable(&v),
            }
        }
    }

    fn print_message(&mut self, message: &MessageRef) -> PrintResult<()> {
        if let Some(duration) = message.downcast_ref::<Duration>() {
            self.print_printable(duration)
        } else if let Some(timestamp) = message.downcast_ref::<Timestamp>() {
            self.print_printable(timestamp)
        } else if let Some(field_mask) = message.downcast_ref::<FieldMask>() {
            self.print_printable(field_mask)
        } else if let Some(any) = message.downcast_ref::<Any>() {
            self.print_printable(any)
        } else if let Some(value) = message.downcast_ref::<Value>() {
            self.print_printable(value)
        } else if let Some(value) = message.downcast_ref::<DoubleValue>() {
            self.print_wrapper(value)
        } else if let Some(value) = message.downcast_ref::<FloatValue>() {
            self.print_wrapper(value)
        } else if let Some(value) = message.downcast_ref::<Int64Value>() {
            self.print_wrapper(value)
        } else if let Some(value) = message.downcast_ref::<UInt64Value>() {
            self.print_wrapper(value)
        } else if let Some(value) = message.downcast_ref::<Int32Value>() {
            self.print_wrapper(value)
        } else if let Some(value) = message.downcast_ref::<UInt32Value>() {
            self.print_wrapper(value)
        } else if let Some(value) = message.downcast_ref::<BoolValue>() {
            self.print_wrapper(value)
        } else if let Some(value) = message.downcast_ref::<StringValue>() {
            self.print_wrapper(value)
        } else if let Some(value) = message.downcast_ref::<BytesValue>() {
            self.print_wrapper(value)
        } else if let Some(value) = message.downcast_ref::<ListValue>() {
            self.print_printable(value)
        } else if let Some(value) = message.downcast_ref::<Struct>() {
            self.print_printable(value)
        } else {
            self.print_regular_message(message)
        }
    }

    fn print_regular_message(&mut self, message: &MessageRef) -> Result<(), PrintError> {
        let descriptor = message.descriptor_dyn();

        write!(self.buf, "{{")?;
        let mut first = true;
        for field in descriptor.fields() {
            let json_field_name = if self.print_options.proto_field_name {
                field.name()
            } else {
                field.json_name()
            };

            let field_type = field.runtime_field_type();

            match field.get_reflect(&**message) {
                ReflectFieldRef::Optional(v) => match v.value() {
                    None => {
                        if self.print_options.always_output_default_values {
                            let is_message = match field_type {
                                RuntimeFieldType::Singular(s) => match s {
                                    RuntimeType::Message(_) => true,
                                    _ => false,
                                },
                                _ => unreachable!(),
                            };

                            let is_oneof = field.proto().has_oneof_index();

                            if !is_message && !is_oneof {
                                let v = field.get_singular_field_or_default(&**message);
                                self.print_comma_but_first(&mut first)?;
                                write!(self.buf, "\"{}\": ", json_field_name)?;
                                self.print_printable(&v)?;
                            }
                        }
                    }
                    Some(v) => {
                        self.print_comma_but_first(&mut first)?;
                        write!(self.buf, "\"{}\": ", json_field_name)?;
                        self.print_printable(&v)?;
                    }
                },
                ReflectFieldRef::Repeated(v) => {
                    if !v.is_empty() || self.print_options.always_output_default_values {
                        self.print_comma_but_first(&mut first)?;
                        write!(self.buf, "\"{}\": ", json_field_name)?;
                        self.print_repeated(&v)?;
                    }
                }
                ReflectFieldRef::Map(v) => {
                    if !v.is_empty() || self.print_options.always_output_default_values {
                        self.print_comma_but_first(&mut first)?;
                        write!(self.buf, "\"{}\": ", json_field_name)?;
                        self.print_map(&v)?;
                    }
                }
            }
        }
        write!(self.buf, "}}")?;
        Ok(())
    }

    fn print_wk_null_value(&mut self, _null_value: &NullValue) -> PrintResult<()> {
        self.print_json_null()
    }

    fn print_wrapper<W>(&mut self, value: &W) -> PrintResult<()>
    where
        W: WellKnownWrapper,
        W::Underlying: PrintableToJson,
    {
        self.print_printable(value.get_ref())
    }
}

/// Options for printing JSON to string
///
/// # Examples
///
/// ```
/// let print_options = protobuf_json_mapping::PrintOptions {
///     enum_values_int: true,
///     ..Default::default()
/// };
/// ```
#[derive(Default, Debug, Clone)]
pub struct PrintOptions {
    /// Use ints instead of strings for enums.
    ///
    /// Note both string or int can be parsed.
    pub enum_values_int: bool,
    /// Use protobuf field names instead of `lowerCamelCase` which is used by default.
    /// Note both names are supported when JSON is parsed.
    pub proto_field_name: bool,
    /// Output field default values.
    pub always_output_default_values: bool,
    /// Prevent initializing `PrintOptions` enumerating all field.
    pub _future_options: (),
}

/// Serialize message to JSON according to protobuf specification.
pub fn print_to_string_with_options(
    message: &dyn MessageDyn,
    print_options: &PrintOptions,
) -> PrintResult<String> {
    let mut printer = Printer {
        buf: String::new(),
        print_options: print_options.clone(),
    };
    printer.print_message(&MessageRef::from(message))?;
    Ok(printer.buf)
}

/// Serialize message to JSON according to protobuf specification.
pub fn print_to_string(message: &dyn MessageDyn) -> PrintResult<String> {
    print_to_string_with_options(message, &PrintOptions::default())
}

'''
'''--- protobuf-json-mapping/src/rfc_3339.rs ---
use std::fmt;
use std::time::Duration;

// Number of seconds in a day is a constant.
// We do not support leap seconds here.
const SECONDS_IN_DAY: u64 = 86400;

// Gregorian calendar has 400 years cycles, this is a procedure
// for computing if a year is a leap year.
fn is_leap_year(year: i64) -> bool {
    if year % 4 != 0 {
        false
    } else if year % 100 != 0 {
        true
    } else if year % 400 != 0 {
        false
    } else {
        true
    }
}

fn days_in_year(year: i64) -> u32 {
    if is_leap_year(year) {
        366
    } else {
        365
    }
}

// Number of leap years among 400 consecutive years.
const CYCLE_LEAP_YEARS: u32 = 400 / 4 - 400 / 100 + 400 / 400;
// Number of days in 400 years cycle.
const CYCLE_DAYS: u32 = 400 * 365 + CYCLE_LEAP_YEARS;
// Number of seconds in 400 years cycle.
const CYCLE_SECONDS: u64 = CYCLE_DAYS as u64 * SECONDS_IN_DAY;

// Number of seconds between 1 Jan 1970 and 1 Jan 2000.
// Check with:
// `TZ=UTC gdate --rfc-3339=seconds --date @946684800`
const YEARS_1970_2000_SECONDS: u64 = 946684800;
// Number of seconds between 1 Jan 1600 and 1 Jan 1970.
const YEARS_1600_1970_SECONDS: u64 = CYCLE_SECONDS - YEARS_1970_2000_SECONDS;

// For each year in the cycle, number of leap years before in the cycle.
#[cfg_attr(rustfmt, rustfmt_skip)]
static YEAR_DELTAS: [u8; 401] = [
    0,  1,  1,  1,  1,  2,  2,  2,  2,  3,  3,  3,  3,  4,  4,  4,  4,  5,  5,  5,
    5,  6,  6,  6,  6,  7,  7,  7,  7,  8,  8,  8,  8,  9,  9,  9,  9, 10, 10, 10,
    10, 11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15,
    15, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20,
    20, 21, 21, 21, 21, 22, 22, 22, 22, 23, 23, 23, 23, 24, 24, 24, 24, 25, 25, 25, // 100
    25, 25, 25, 25, 25, 26, 26, 26, 26, 27, 27, 27, 27, 28, 28, 28, 28, 29, 29, 29,
    29, 30, 30, 30, 30, 31, 31, 31, 31, 32, 32, 32, 32, 33, 33, 33, 33, 34, 34, 34,
    34, 35, 35, 35, 35, 36, 36, 36, 36, 37, 37, 37, 37, 38, 38, 38, 38, 39, 39, 39,
    39, 40, 40, 40, 40, 41, 41, 41, 41, 42, 42, 42, 42, 43, 43, 43, 43, 44, 44, 44,
    44, 45, 45, 45, 45, 46, 46, 46, 46, 47, 47, 47, 47, 48, 48, 48, 48, 49, 49, 49, // 200
    49, 49, 49, 49, 49, 50, 50, 50, 50, 51, 51, 51, 51, 52, 52, 52, 52, 53, 53, 53,
    53, 54, 54, 54, 54, 55, 55, 55, 55, 56, 56, 56, 56, 57, 57, 57, 57, 58, 58, 58,
    58, 59, 59, 59, 59, 60, 60, 60, 60, 61, 61, 61, 61, 62, 62, 62, 62, 63, 63, 63,
    63, 64, 64, 64, 64, 65, 65, 65, 65, 66, 66, 66, 66, 67, 67, 67, 67, 68, 68, 68,
    68, 69, 69, 69, 69, 70, 70, 70, 70, 71, 71, 71, 71, 72, 72, 72, 72, 73, 73, 73, // 300
    73, 73, 73, 73, 73, 74, 74, 74, 74, 75, 75, 75, 75, 76, 76, 76, 76, 77, 77, 77,
    77, 78, 78, 78, 78, 79, 79, 79, 79, 80, 80, 80, 80, 81, 81, 81, 81, 82, 82, 82,
    82, 83, 83, 83, 83, 84, 84, 84, 84, 85, 85, 85, 85, 86, 86, 86, 86, 87, 87, 87,
    87, 88, 88, 88, 88, 89, 89, 89, 89, 90, 90, 90, 90, 91, 91, 91, 91, 92, 92, 92,
    92, 93, 93, 93, 93, 94, 94, 94, 94, 95, 95, 95, 95, 96, 96, 96, 96, 97, 97, 97, 97,
];

/// UTC time
pub struct TmUtc {
    /// Year
    year: i64,
    /// 1..=12
    month: u32,
    /// 1-based day of month
    day: u32,
    /// 0..=23
    hour: u32,
    /// 0..=59
    minute: u32,
    /// 0..=59; no leap seconds
    second: u32,
    /// 0..=999_999_999
    nanos: u32,
}

#[derive(Debug, thiserror::Error)]
pub enum Rfc3339ParseError {
    #[error("Unexpected EOF")]
    UnexpectedEof,
    #[error("Trailing characters")]
    TrailngCharacters,
    #[error("Expecting digits")]
    ExpectingDigits,
    #[error("Expecting character: {:?}", .0)]
    ExpectingChar(char),
    #[error("Expecting timezone")]
    ExpectingTimezone,
    #[error("No digits after dot")]
    NoDigitsAfterDot,
    #[error("Date-time field is out of range")]
    DateTimeFieldOutOfRange,
    #[error("Expecting date-time separator")]
    ExpectingDateTimeSeparator,
}

pub type Rfc3339ParseResult<A> = Result<A, Rfc3339ParseError>;

impl TmUtc {
    fn day_of_cycle_to_year_day_of_year(day_of_cycle: u32) -> (i64, u32) {
        debug_assert!(day_of_cycle < CYCLE_DAYS);

        let mut year_mod_400 = (day_of_cycle / 365) as i64;
        let mut day_or_year = (day_of_cycle % 365) as u32;

        let delta = YEAR_DELTAS[year_mod_400 as usize] as u32;
        if day_or_year < delta {
            year_mod_400 -= 1;
            day_or_year += 365 - YEAR_DELTAS[year_mod_400 as usize] as u32;
        } else {
            day_or_year -= delta;
        }

        (year_mod_400, day_or_year)
    }

    fn year_day_of_year_to_day_of_cycle(year_mod_400: u32, day_of_year: u32) -> u32 {
        debug_assert!(year_mod_400 < 400);
        debug_assert!(day_of_year < days_in_year(year_mod_400 as i64));

        year_mod_400 * 365 + YEAR_DELTAS[year_mod_400 as usize] as u32 + day_of_year
    }

    // Convert seconds of the day of hour, minute and second
    fn second_of_day_to_h_m_s(seconds: u32) -> (u32, u32, u32) {
        debug_assert!(seconds < 86400);

        let hour = seconds / 3600;
        let minute = seconds % 3600 / 60;
        let second = seconds % 60;

        (hour, minute, second)
    }

    fn h_m_s_to_second_of_day(hour: u32, minute: u32, second: u32) -> u32 {
        debug_assert!(hour < 24);
        debug_assert!(minute < 60);
        debug_assert!(second < 60);

        hour * 3600 + minute * 60 + second
    }

    fn days_in_months(year: i64) -> &'static [u32] {
        if is_leap_year(year) {
            &[31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
        } else {
            &[31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
        }
    }

    // Convert day of year (0-based) to month and day
    fn day_of_year_to_month_day(year: i64, day_of_year: u32) -> (u32, u32) {
        debug_assert!(day_of_year < days_in_year(year));

        let days_in_months = TmUtc::days_in_months(year);

        let mut rem_days = day_of_year;
        let mut month = 1;
        while rem_days >= days_in_months[month - 1] {
            rem_days -= days_in_months[month - 1];
            month += 1;
        }

        debug_assert!(rem_days + 1 <= days_in_months[month - 1]);

        (month as u32, rem_days + 1)
    }

    fn month_day_to_day_of_year(year: i64, month: u32, day: u32) -> u32 {
        debug_assert!(month >= 1);
        debug_assert!(month <= 12);

        debug_assert!(day >= 1);

        let days_in_months = TmUtc::days_in_months(year);

        // TODO: replace loop with precomputed table
        let mut day_of_year = 0;
        for next_month in 1..month {
            day_of_year += days_in_months[next_month as usize - 1];
        }

        debug_assert!(day <= days_in_months[month as usize - 1]);

        day_of_year + day - 1
    }

    // Construct from duration added to cycle start year
    fn from_cycle_start_add_duration(mut cycle_start: i64, add: Duration) -> TmUtc {
        debug_assert!(cycle_start % 400 == 0);

        // Split duration to days and duration within day

        let days = add.as_secs() / SECONDS_IN_DAY;
        let duration_of_day = add - Duration::from_secs(days * SECONDS_IN_DAY);

        let cycles = days / CYCLE_DAYS as u64;
        cycle_start += cycles as i64 * 400;
        let day_of_cycle = days % CYCLE_DAYS as u64;

        let (year_mod_400, day_of_year) =
            TmUtc::day_of_cycle_to_year_day_of_year(day_of_cycle as u32);

        let (year,) = (cycle_start + year_mod_400,);
        let (month, day) = TmUtc::day_of_year_to_month_day(year, day_of_year);
        let (hour, minute, second) =
            TmUtc::second_of_day_to_h_m_s(duration_of_day.as_secs() as u32);

        TmUtc {
            year,
            month,
            day,
            hour,
            minute,
            second,
            nanos: duration_of_day.subsec_nanos(),
        }
    }

    // Protobuf timestamp: seconds from epoch, and nanos 0..=999_999_999 counting forward.
    pub fn from_protobuf_timestamp(seconds: i64, nanos: u32) -> TmUtc {
        assert!(nanos <= 999_999_999);

        let (mut year, mut seconds) = if seconds >= 0 {
            (1970, seconds as u64)
        } else {
            let minus_seconds = if seconds == i64::MIN {
                i64::MIN as u64
            } else {
                -seconds as u64
            };

            let cycles = (minus_seconds + CYCLE_SECONDS) / CYCLE_SECONDS;

            (
                1970 - 400 * cycles as i64,
                cycles * CYCLE_SECONDS - minus_seconds,
            )
        };

        year -= 370;
        seconds += YEARS_1600_1970_SECONDS;

        TmUtc::from_cycle_start_add_duration(year, Duration::new(seconds, nanos))
    }

    pub fn to_protobuf_timestamp(&self) -> (i64, u32) {
        assert!(self.year >= 0);
        assert!(self.year <= 9999);

        let year_mod_400 = ((self.year % 400 + 400) % 400) as u32;
        let cycle_start = self.year - year_mod_400 as i64;

        let day_of_year = TmUtc::month_day_to_day_of_year(self.year, self.month, self.day);
        let day_of_cycle = TmUtc::year_day_of_year_to_day_of_cycle(year_mod_400, day_of_year);
        let second_of_day = TmUtc::h_m_s_to_second_of_day(self.hour, self.minute, self.second);

        let second_of_cycle = day_of_cycle as u64 * SECONDS_IN_DAY + second_of_day as u64;

        let epoch_seconds = (cycle_start - 1600) / 400 * CYCLE_SECONDS as i64
            - YEARS_1600_1970_SECONDS as i64
            + second_of_cycle as i64;

        (epoch_seconds, self.nanos)
    }

    pub fn parse_rfc_3339(s: &str) -> Rfc3339ParseResult<(i64, u32)> {
        struct Parser<'a> {
            s: &'a [u8],
            pos: usize,
        }

        impl<'a> Parser<'a> {
            fn next_number(&mut self, len: usize) -> Rfc3339ParseResult<u32> {
                let end_pos = self.pos + len;
                if end_pos > self.s.len() {
                    return Err(Rfc3339ParseError::UnexpectedEof);
                }
                let mut r = 0;
                for i in 0..len {
                    let c = self.s[self.pos + i];
                    if c >= b'0' && c <= b'9' {
                        r = r * 10 + (c - b'0') as u32;
                    } else {
                        return Err(Rfc3339ParseError::ExpectingDigits);
                    }
                }
                self.pos += len;
                Ok(r)
            }

            fn lookahead_char(&self) -> Rfc3339ParseResult<u8> {
                if self.pos == self.s.len() {
                    return Err(Rfc3339ParseError::UnexpectedEof);
                }
                Ok(self.s[self.pos])
            }

            fn next_char(&mut self, expect: u8) -> Rfc3339ParseResult<()> {
                assert!(expect < 0x80);
                let c = self.lookahead_char()?;
                if c != expect {
                    return Err(Rfc3339ParseError::ExpectingChar(expect as char));
                }
                self.pos += 1;
                Ok(())
            }
        }

        let mut parser = Parser {
            s: s.as_bytes(),
            pos: 0,
        };

        let year = parser.next_number(4)? as i64;
        parser.next_char(b'-')?;
        let month = parser.next_number(2)?;
        parser.next_char(b'-')?;
        let day = parser.next_number(2)?;

        if month < 1 || month > 12 {
            return Err(Rfc3339ParseError::DateTimeFieldOutOfRange);
        }

        if day < 1 || day > TmUtc::days_in_months(year as i64)[month as usize - 1] {
            return Err(Rfc3339ParseError::DateTimeFieldOutOfRange);
        }

        match parser.lookahead_char()? {
            b'T' | b't' | b' ' => parser.pos += 1,
            _ => return Err(Rfc3339ParseError::ExpectingDateTimeSeparator),
        }

        let hour = parser.next_number(2)?;
        parser.next_char(b':')?;
        let minute = parser.next_number(2)?;
        parser.next_char(b':')?;
        let second = parser.next_number(2)?;

        if hour > 23 || minute > 59 || second > 60 {
            return Err(Rfc3339ParseError::DateTimeFieldOutOfRange);
        }

        // round down leap second
        let second = if second == 60 { 59 } else { second };

        let nanos = if parser.lookahead_char()? == b'.' {
            parser.pos += 1;
            let mut digits = 0;
            let mut nanos = 0;
            while parser.lookahead_char()? >= b'0' && parser.lookahead_char()? <= b'9' {
                let digit = (parser.lookahead_char()? - b'0') as u32;
                parser.pos += 1;
                if digits == 9 {
                    continue;
                }
                digits += 1;
                nanos = nanos * 10 + digit;
            }

            if digits == 0 {
                return Err(Rfc3339ParseError::NoDigitsAfterDot);
            }

            for _ in digits..9 {
                nanos *= 10;
            }
            nanos
        } else {
            0
        };

        let offset_seconds = if parser.lookahead_char()? == b'Z' || parser.lookahead_char()? == b'z'
        {
            parser.pos += 1;
            0
        } else {
            let sign = if parser.lookahead_char()? == b'+' {
                1
            } else if parser.lookahead_char()? == b'-' {
                -1
            } else {
                return Err(Rfc3339ParseError::ExpectingTimezone);
            };

            parser.pos += 1;

            let hour_offset = parser.next_number(2)?;
            parser.next_char(b':')?;
            let minute_offset = parser.next_number(2)?;

            (hour_offset * 3600 + 60 * minute_offset) as i64 * sign
        };

        if parser.pos != parser.s.len() {
            return Err(Rfc3339ParseError::TrailngCharacters);
        }

        let (seconds, nanos) = TmUtc {
            year,
            month,
            day,
            hour,
            minute,
            second,
            nanos,
        }
        .to_protobuf_timestamp();

        Ok((seconds - offset_seconds, nanos))
    }
}

impl fmt::Display for TmUtc {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        if self.year > 9999 {
            write!(f, "+{}", self.year)?;
        } else if self.year < 0 {
            write!(f, "{:05}", self.year)?;
        } else {
            write!(f, "{:04}", self.year)?;
        }
        write!(
            f,
            "-{:02}-{:02}T{:02}:{:02}:{:02}",
            self.month, self.day, self.hour, self.minute, self.second
        )?;

        // if precision is not specified, print nanoseconds
        let subsec_digits = f.precision().unwrap_or(9);
        if subsec_digits != 0 {
            let mut subsec_digits = subsec_digits;

            let width = if subsec_digits > 9 { 9 } else { subsec_digits };

            // "Truncated" nanonseconds.
            let mut subsec = self.nanos;

            // Performs 8 iterations when precision=1,
            // but that's probably not a issue compared to other computations.
            for _ in width..9 {
                subsec /= 10;
            }

            write!(f, ".{:0width$}", subsec, width = width as usize)?;

            // Adding more than 9 digits is meaningless,
            // but if user requests it, we should print zeros.
            for _ in 9..subsec_digits {
                write!(f, "0")?;
                subsec_digits -= 1;
            }
        }

        write!(f, "Z")
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_fmt() {
        fn test_impl(expected: &str, secs: i64, nanos: u32, subsec_digits: u32) {
            let tm_utc = TmUtc::from_protobuf_timestamp(secs, nanos);

            assert_eq!(
                expected,
                format!("{:.prec$}", tm_utc, prec = subsec_digits as usize)
            );
        }

        // Tests can be validated with with GNU date:
        // `TZ=UTC gdate --date @1535585179 --iso-8601=seconds`

        test_impl("1970-01-01T00:00:00Z", 0, 0, 0);
        test_impl("2018-08-29T23:26:19Z", 1535585179, 0, 0);
        test_impl("2018-08-29T23:26:19.123Z", 1535585179, 123456789, 3);
        test_impl("1646-04-01T03:45:44Z", -10216613656, 0, 0);
        test_impl("1970-01-01T00:00:00.000000001000Z", 0, 1, 12);
        test_impl("5138-11-16T09:46:40Z", 100000000000, 0, 0);
        test_impl("+33658-09-27T01:46:41Z", 1000000000001, 0, 0);
        // Leading zero
        test_impl("0000-12-31T00:00:00Z", -62135683200, 0, 0);
        // Minus zero
        test_impl("-0003-10-30T14:13:20Z", -62235683200, 0, 0);
        // More than 4 digits
        // Largest value GNU date can handle
        test_impl("+2147485547-12-31T23:59:59Z", 67768036191676799, 0, 0);
        // Negative dates
        test_impl("1969-12-31T23:59:59Z", -1, 0, 0);
        test_impl("1969-12-31T23:59:00Z", -60, 0, 0);
        test_impl("1969-12-31T23:59:58.900Z", -2, 900_000_000, 3);
        test_impl("1966-10-31T14:13:20Z", -100000000, 0, 0);
        test_impl("-29719-04-05T22:13:19Z", -1000000000001, 0, 0);
        // Smallest value GNU date can handle
        test_impl("-2147481748-01-01T00:00:00Z", -67768040609740800, 0, 0);
    }

    #[test]
    fn test_parse_fmt() {
        fn test_impl(s: &str, width: usize) {
            let (seconds, nanos) = TmUtc::parse_rfc_3339(s).unwrap();
            let formatted = format!(
                "{:.width$}",
                TmUtc::from_protobuf_timestamp(seconds, nanos),
                width = width
            );
            assert_eq!(formatted, s);
        }

        test_impl("1970-01-01T00:00:00Z", 0);
        test_impl("1970-01-01T00:00:00.000Z", 3);
        test_impl("1970-01-01T00:00:00.000000000Z", 9);
        test_impl("1970-01-02T00:00:00Z", 0);
        test_impl("1970-03-01T00:00:00Z", 0);
        test_impl("1974-01-01T00:00:00Z", 0);
        test_impl("2018-01-01T00:00:00Z", 0);
        test_impl("2018-09-02T05:49:10.123456789Z", 9);
        test_impl("0001-01-01T00:00:00.000000000Z", 9);
        test_impl("9999-12-31T23:59:59.999999999Z", 9);
    }

    #[test]
    fn test_parse_alt() {
        fn test_impl(alt: &str, parse: &str) {
            let reference = TmUtc::parse_rfc_3339(alt).unwrap();
            let parsed = TmUtc::parse_rfc_3339(parse).unwrap();
            assert_eq!(reference, parsed, "{} - {}", alt, parse);
        }

        // alternative spelling
        test_impl("1970-01-01 00:00:00Z", "1970-01-01T00:00:00Z");
        test_impl("1970-01-01 00:00:00Z", "1970-01-01t00:00:00Z");
        test_impl("1970-01-01 00:00:00Z", "1970-01-01 00:00:00z");
        // leap second is rounded down
        test_impl("2016-12-31 23:59:59Z", "2016-12-31 23:59:60Z");
        // TZ offset
        test_impl("1970-01-01 00:00:00Z", "1970-01-01T03:00:00+03:00");
        test_impl("1970-01-01 00:00:00Z", "1969-12-31 22:15:00-01:45");
    }

    #[test]
    fn test_parse_incorrect_inputs() {
        fn test_impl(s: &str) {
            assert!(TmUtc::parse_rfc_3339(s).is_err(), "{}", s);
        }

        test_impl("1970-01-01T00:00:61Z");
        test_impl("1970-01-01T00:60:61Z");
        test_impl("1970-01-01T24:00:61Z");
        test_impl("1970-01-01T00:00:00.Z");
        test_impl("1970-01-32T00:00:00Z");
        test_impl("1970-02-29T00:00:00Z");
        test_impl("1980-02-30T00:00:00Z");
        test_impl("1980-13-01T00:00:00Z");
        test_impl("1970-01-01T00:00:00");
        test_impl("1970-01-01T00:00Z");
    }

    #[test]
    fn test_fmt_max_duration() {
        // Simply check that there are no integer overflows.
        // I didn't check that resulting strings are correct.
        assert_eq!(
            "-292277022657-01-27T08:29:52.000000000Z",
            format!("{}", TmUtc::from_protobuf_timestamp(i64::MIN, 0))
        );
        assert_eq!(
            "+292277026596-12-04T15:30:07.999999999Z",
            format!("{}", TmUtc::from_protobuf_timestamp(i64::MAX, 999_999_999))
        );
    }
}

'''
'''--- protobuf-json-mapping/src/well_known_wrapper.rs ---
//! Trait for well-known wrapper types

use protobuf::well_known_types::wrappers::BoolValue;
use protobuf::well_known_types::wrappers::BytesValue;
use protobuf::well_known_types::wrappers::DoubleValue;
use protobuf::well_known_types::wrappers::FloatValue;
use protobuf::well_known_types::wrappers::Int32Value;
use protobuf::well_known_types::wrappers::Int64Value;
use protobuf::well_known_types::wrappers::StringValue;
use protobuf::well_known_types::wrappers::UInt32Value;
use protobuf::well_known_types::wrappers::UInt64Value;

/// Well-known wrapper types have single field.
/// This trait operations return pointers to that field.
pub(crate) trait WellKnownWrapper {
    type Underlying;

    fn get_ref(&self) -> &Self::Underlying;
    fn get_mut(&mut self) -> &mut Self::Underlying;
}

impl WellKnownWrapper for DoubleValue {
    type Underlying = f64;

    fn get_ref(&self) -> &f64 {
        &self.value
    }

    fn get_mut(&mut self) -> &mut f64 {
        &mut self.value
    }
}

impl WellKnownWrapper for FloatValue {
    type Underlying = f32;

    fn get_ref(&self) -> &f32 {
        &self.value
    }

    fn get_mut(&mut self) -> &mut f32 {
        &mut self.value
    }
}

impl WellKnownWrapper for Int64Value {
    type Underlying = i64;

    fn get_ref(&self) -> &i64 {
        &self.value
    }

    fn get_mut(&mut self) -> &mut i64 {
        &mut self.value
    }
}

impl WellKnownWrapper for UInt64Value {
    type Underlying = u64;

    fn get_ref(&self) -> &u64 {
        &self.value
    }

    fn get_mut(&mut self) -> &mut u64 {
        &mut self.value
    }
}

impl WellKnownWrapper for Int32Value {
    type Underlying = i32;

    fn get_ref(&self) -> &i32 {
        &self.value
    }

    fn get_mut(&mut self) -> &mut i32 {
        &mut self.value
    }
}

impl WellKnownWrapper for UInt32Value {
    type Underlying = u32;

    fn get_ref(&self) -> &u32 {
        &self.value
    }

    fn get_mut(&mut self) -> &mut u32 {
        &mut self.value
    }
}

impl WellKnownWrapper for BoolValue {
    type Underlying = bool;

    fn get_ref(&self) -> &bool {
        &self.value
    }

    fn get_mut(&mut self) -> &mut bool {
        &mut self.value
    }
}

impl WellKnownWrapper for StringValue {
    type Underlying = String;

    fn get_ref(&self) -> &String {
        &self.value
    }

    fn get_mut(&mut self) -> &mut String {
        &mut self.value
    }
}

impl WellKnownWrapper for BytesValue {
    type Underlying = Vec<u8>;

    fn get_ref(&self) -> &Vec<u8> {
        &self.value
    }

    fn get_mut(&mut self) -> &mut Vec<u8> {
        &mut self.value
    }
}

'''
'''--- protobuf-parse/Cargo.toml ---
[package]
name = "protobuf-parse"
version = "4.0.0-alpha.0"
edition = "2021"
authors = ["Stepan Koltsov <stepan.koltsov@gmail.com>"]
license = "MIT"
homepage = "https://github.com/stepancheg/rust-protobuf/tree/master/protobuf-parse/"
repository = "https://github.com/stepancheg/rust-protobuf/tree/master/protobuf-parse/"
description = """
Parse `.proto` files.

Files are parsed into a `protobuf::descriptor::FileDescriptorSet` object using either:
* pure rust parser (no dependencies)
* `protoc` binary (more reliable and compatible with Google's implementation)
"""

[dependencies]
tempfile  = "3.2.0"
log       = "0.4"
which     = "4.0"
anyhow    = "1.0.53"
thiserror = "1.0.30"
indexmap  = "1.8.0"

protobuf = { path = "../protobuf", version = "=4.0.0-alpha.0" }
protobuf-support = { path = "../protobuf-support", version = "=4.0.0-alpha.0" }

[lib]
# TODO: figure out what to do with bundled linked_hash_map
doctest = false

[[bin]]

name = "parse-and-typecheck"
path = "src/bin/parse-and-typecheck.rs"
test = false

[package.metadata.docs.rs]
all-features = true

'''
'''--- protobuf-parse/README.md ---
<!-- cargo-sync-readme start -->

# Parse `.proto` files

Parse `.proto` file definitions, **not** the protobuf text format serialization.

Files can be parsed using pure Rust parser (mod `pure`)
or using the `protoc` command (mod `protoc`).

This crate is not meant to be used directly, but rather through the `protobuf-codegen` crate.
If you think this crate might be useful to you,
please [consider creating an issue](https://github.com/stepancheg/rust-protobuf/issues/new),
until that this crate is considered to have **no stable API**.

<!-- cargo-sync-readme end -->

'''
'''--- protobuf-parse/examples/file-descriptor-out-compare.rs ---
use std::env;
use std::fs;

use protobuf::text_format;
use protobuf_parse::Parser;

enum Which {
    Protoc,
    Pure,
}

fn main() {
    let args = env::args().skip(1).collect::<Vec<_>>();
    let args = args.iter().map(|s| s.as_str()).collect::<Vec<_>>();
    let (path, out_protoc, out_pure) = match args.as_slice() {
        // Just invoke protoc.
        [path, out_protoc, out_pure] => (path, out_protoc, out_pure),
        _ => panic!("wrong args"),
    };

    for which in [Which::Pure, Which::Protoc] {
        let mut parser = Parser::new();
        match which {
            Which::Protoc => {
                parser.protoc();
            }
            Which::Pure => {
                parser.pure();
            }
        }

        parser.input(path);
        parser.include(".");
        let fds = parser.file_descriptor_set().unwrap();
        let fds = text_format::print_to_string_pretty(&fds);
        let out = match which {
            Which::Protoc => out_protoc,
            Which::Pure => out_pure,
        };
        fs::write(out, fds).unwrap();
    }
}

'''
'''--- protobuf-parse/src/bin/parse-and-typecheck.rs ---
use std::env;
use std::path::PathBuf;
use std::process::exit;

use protobuf_parse::Parser;

fn main() {
    let args = env::args_os()
        .skip(1)
        .map(PathBuf::from)
        .collect::<Vec<_>>();

    if args.len() != 2 {
        eprintln!(
            "usage: {} <input.proto> <include>",
            env::args().next().unwrap()
        );
        exit(1);
    }

    eprintln!(
        "{} is not a part of public interface",
        env::args().next().unwrap()
    );

    assert!(args.len() >= 2);
    let (input, includes) = args.split_at(1);
    let t = Parser::new()
        .pure()
        .includes(includes)
        .inputs(input)
        .parse_and_typecheck()
        .expect("parse_and_typecheck");
    for fd in t.file_descriptors {
        println!("{:#?}", fd);
    }
}

'''
'''--- protobuf-parse/src/case_convert.rs ---
// copy-paste from Google Protobuf
// must be kept in sync with Google for JSON interop
#[doc(hidden)]
pub fn camel_case(input: &str) -> String {
    let mut capitalize_next = true;
    let mut result = String::new();
    result.reserve(input.len());

    for c in input.chars() {
        if c == '_' {
            capitalize_next = true;
        } else if capitalize_next {
            result.push(c.to_ascii_uppercase());
            capitalize_next = false;
        } else {
            result.push(c);
        }
    }

    result
}

#[doc(hidden)]
pub fn snake_case(input: &str) -> String {
    let mut result = String::new();

    let mut last_lower = false;

    for c in input.chars() {
        if c.is_ascii_uppercase() && last_lower {
            result.push('_');
        }
        result.push(c.to_ascii_lowercase());
        last_lower = c.is_lowercase();
    }

    result
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_camel_case() {
        assert_eq!("FooBarBazQuxQUUX", camel_case("foo_barBaz_QuxQUUX"));
        assert_eq!("FooBarBazQuxQUUX", camel_case("Foo_barBaz_QuxQUUX"));
    }

    #[test]
    fn test_snake_case() {
        assert_eq!("foo_bar_baz_qux_quux", snake_case("foo_barBaz_QuxQUUX"));
        assert_eq!("foo_bar_baz_qux_quux", snake_case("Foo_barBaz_QuxQUUX"));
    }
}

'''
'''--- protobuf-parse/src/lib.rs ---
//! # Parse `.proto` files
//!
//! Parse `.proto` file definitions, **not** the protobuf text format serialization.
//!
//! Files can be parsed using pure Rust parser (mod `pure`)
//! or using the `protoc` command (mod `protoc`).
//!
//! This crate is not meant to be used directly, but rather through the `protobuf-codegen` crate.
//! If you think this crate might be useful to you,
//! please [consider creating an issue](https://github.com/stepancheg/rust-protobuf/issues/new),
//! until that this crate is considered to have **no stable API**.

extern crate core;

mod case_convert;
mod parse_and_typecheck;
mod parser;
mod path;
mod proto;
mod proto_path;
mod protobuf_abs_path;
mod protobuf_ident;
mod protobuf_path;
mod protobuf_rel_path;
pub(crate) mod protoc;
pub mod pure;
mod rel_path;
mod test_against_protobuf_protos;
mod which_parser;

// Public API
// Non-public API used by codegen crate.
pub use case_convert::*;
pub use parse_and_typecheck::*;
pub use parser::Parser;
pub use proto_path::*;
use protobuf::reflect::FileDescriptor;
pub use protobuf_abs_path::*;
pub use protobuf_ident::*;
pub use protobuf_rel_path::*;

use crate::pure::model;

#[derive(Clone)]
pub(crate) struct FileDescriptorPair {
    pub(crate) parsed: model::FileDescriptor,
    pub(crate) descriptor_proto: protobuf::descriptor::FileDescriptorProto,
    pub(crate) descriptor: FileDescriptor,
}

'''
'''--- protobuf-parse/src/parse_and_typecheck.rs ---
use crate::ProtoPathBuf;

/// Result of parsing `.proto` files.
#[doc(hidden)]
pub struct ParsedAndTypechecked {
    /// One entry for each input `.proto` file.
    pub relative_paths: Vec<ProtoPathBuf>,
    /// All parsed `.proto` files including dependencies of input files.
    pub file_descriptors: Vec<protobuf::descriptor::FileDescriptorProto>,
    /// Description of the parser (e.g. to include in generated files).
    pub parser: String,
}

#[cfg(test)]
mod test {
    use std::collections::HashSet;
    use std::fs;

    use crate::Parser;

    #[test]
    fn parse_and_typecheck() {
        let dir = tempfile::tempdir().unwrap();
        let a_proto = dir.path().join("a.proto");
        let b_proto = dir.path().join("b.proto");
        fs::write(&a_proto, "syntax = 'proto3'; message Apple {}").unwrap();
        fs::write(
            &b_proto,
            "syntax = 'proto3'; import 'a.proto'; message Banana { Apple a = 1; }",
        )
        .unwrap();

        let pure = Parser::new()
            .pure()
            .include(dir.path())
            .input(&b_proto)
            .parse_and_typecheck()
            .unwrap();
        let protoc = Parser::new()
            .protoc()
            .include(dir.path())
            .input(&b_proto)
            .parse_and_typecheck()
            .unwrap();

        assert_eq!(pure.relative_paths, protoc.relative_paths);
        assert_eq!(2, pure.file_descriptors.len());
        assert_eq!(2, protoc.file_descriptors.len());
        // TODO: make result more deterministic
        assert_eq!(
            HashSet::from(["a.proto", "b.proto"]),
            pure.file_descriptors.iter().map(|d| d.name()).collect()
        );
        assert_eq!(
            HashSet::from(["a.proto", "b.proto"]),
            protoc.file_descriptors.iter().map(|d| d.name()).collect()
        );
        assert_eq!(1, protoc.file_descriptors[0].message_type.len());
        assert_eq!(1, pure.file_descriptors[0].message_type.len());
        assert_eq!(
            "Banana",
            pure.file_descriptors
                .iter()
                .find(|d| d.name() == "b.proto")
                .unwrap()
                .message_type[0]
                .name()
        );
        assert_eq!(
            "Banana",
            protoc
                .file_descriptors
                .iter()
                .find(|d| d.name() == "b.proto")
                .unwrap()
                .message_type[0]
                .name()
        );
    }
}

'''
'''--- protobuf-parse/src/parser.rs ---
use std::collections::HashSet;
use std::ffi::OsStr;
use std::ffi::OsString;
use std::path::Path;
use std::path::PathBuf;

use anyhow::Context;
use protobuf::descriptor::FileDescriptorSet;

use crate::protoc;
use crate::pure;
use crate::which_parser::WhichParser;
use crate::ParsedAndTypechecked;

/// Configure and invoke `.proto` parser.
#[derive(Default, Debug)]
pub struct Parser {
    which_parser: WhichParser,
    pub(crate) includes: Vec<PathBuf>,
    pub(crate) inputs: Vec<PathBuf>,
    pub(crate) protoc: Option<PathBuf>,
    pub(crate) protoc_extra_args: Vec<OsString>,
    pub(crate) capture_stderr: bool,
}

impl Parser {
    /// Create new default configured parser.
    pub fn new() -> Parser {
        Parser::default()
    }

    /// Use pure rust parser.
    pub fn pure(&mut self) -> &mut Self {
        self.which_parser = WhichParser::Pure;
        self
    }

    /// Use `protoc` for parsing.
    pub fn protoc(&mut self) -> &mut Self {
        self.which_parser = WhichParser::Protoc;
        self
    }

    /// Add an include directory.
    pub fn include(&mut self, include: impl AsRef<Path>) -> &mut Self {
        self.includes.push(include.as_ref().to_owned());
        self
    }

    /// Add include directories.
    pub fn includes(&mut self, includes: impl IntoIterator<Item = impl AsRef<Path>>) -> &mut Self {
        for include in includes {
            self.include(include);
        }
        self
    }

    /// Append a `.proto` file path to compile
    pub fn input(&mut self, input: impl AsRef<Path>) -> &mut Self {
        self.inputs.push(input.as_ref().to_owned());
        self
    }

    /// Append multiple `.proto` file paths to compile
    pub fn inputs(&mut self, inputs: impl IntoIterator<Item = impl AsRef<Path>>) -> &mut Self {
        for input in inputs {
            self.input(input);
        }
        self
    }

    /// Specify `protoc` path used for parsing.
    ///
    /// This is ignored if pure rust parser is used.
    pub fn protoc_path(&mut self, protoc: &Path) -> &mut Self {
        self.protoc = Some(protoc.to_owned());
        self
    }

    /// Extra arguments to pass to `protoc` command (like experimental options).
    ///
    /// This is ignored if pure rust parser is used.
    pub fn protoc_extra_args(
        &mut self,
        args: impl IntoIterator<Item = impl AsRef<OsStr>>,
    ) -> &mut Self {
        self.protoc_extra_args = args.into_iter().map(|s| s.as_ref().to_owned()).collect();
        self
    }

    /// Capture stderr and return it in error.
    ///
    /// This option applies only to `protoc` parser.
    /// By default `protoc` stderr is inherited from this process stderr.
    pub fn capture_stderr(&mut self) -> &mut Self {
        self.capture_stderr = true;
        self
    }

    /// Parse `.proto` files and typecheck them using pure Rust parser of `protoc` command.
    pub fn parse_and_typecheck(&self) -> anyhow::Result<ParsedAndTypechecked> {
        match &self.which_parser {
            WhichParser::Pure => {
                pure::parse_and_typecheck::parse_and_typecheck(&self).context("using pure parser")
            }
            WhichParser::Protoc => protoc::parse_and_typecheck::parse_and_typecheck(&self)
                .context("using protoc parser"),
        }
    }

    /// Parse and convert result to `FileDescriptorSet`.
    pub fn file_descriptor_set(&self) -> anyhow::Result<FileDescriptorSet> {
        let mut generated = self.parse_and_typecheck()?;
        let relative_paths: HashSet<_> = generated
            .relative_paths
            .iter()
            .map(|path| path.to_string())
            .collect();
        generated
            .file_descriptors
            .retain(|fd| relative_paths.contains(fd.name()));
        let mut fds = FileDescriptorSet::new();
        fds.file = generated.file_descriptors;
        Ok(fds)
    }
}

'''
'''--- protobuf-parse/src/path.rs ---
use std::path::is_separator;

use crate::proto_path::ProtoPath;

pub(crate) fn fs_path_to_proto_path(path: &ProtoPath) -> String {
    path.to_str()
        .chars()
        .map(|c| if is_separator(c) { '/' } else { c })
        .collect()
}

#[cfg(test)]
mod test {
    use crate::path::fs_path_to_proto_path;
    use crate::ProtoPath;

    #[test]
    fn test_fs_path_to_proto_path() {
        assert_eq!(
            "foo.proto",
            fs_path_to_proto_path(ProtoPath::new("foo.proto").unwrap())
        );
        assert_eq!(
            "bar/foo.proto",
            fs_path_to_proto_path(ProtoPath::new("bar/foo.proto").unwrap())
        );
    }
}

'''
'''--- protobuf-parse/src/proto/mod.rs ---
//! This folder contains copy of .proto files
//! needed for pure codegen.
//!
//! Files are copied here because when publishing to crates,
//! referencing files from outside is not allowed.

pub(crate) const RUSTPROTO_PROTO: &str = include_str!("rustproto.proto");
pub(crate) const ANY_PROTO: &str = include_str!("google/protobuf/any.proto");
pub(crate) const API_PROTO: &str = include_str!("google/protobuf/api.proto");
pub(crate) const DESCRIPTOR_PROTO: &str = include_str!("google/protobuf/descriptor.proto");
pub(crate) const DURATION_PROTO: &str = include_str!("google/protobuf/duration.proto");
pub(crate) const EMPTY_PROTO: &str = include_str!("google/protobuf/empty.proto");
pub(crate) const FIELD_MASK_PROTO: &str = include_str!("google/protobuf/field_mask.proto");
pub(crate) const SOURCE_CONTEXT_PROTO: &str = include_str!("google/protobuf/source_context.proto");
pub(crate) const STRUCT_PROTO: &str = include_str!("google/protobuf/struct.proto");
pub(crate) const TIMESTAMP_PROTO: &str = include_str!("google/protobuf/timestamp.proto");
pub(crate) const TYPE_PROTO: &str = include_str!("google/protobuf/type.proto");
pub(crate) const WRAPPERS_PROTO: &str = include_str!("google/protobuf/wrappers.proto");

'''
'''--- protobuf-parse/src/proto_path.rs ---
#![doc(hidden)]

use std::borrow::Borrow;
use std::fmt;
use std::hash::Hash;
use std::ops::Deref;
use std::path::Component;
use std::path::Path;
use std::path::PathBuf;

#[derive(Debug, thiserror::Error)]
enum Error {
    #[error("path is empty")]
    Empty,
    #[error("backslashes in path: {0:?}")]
    Backslashes(String),
    #[error("path contains empty components: {0:?}")]
    EmptyComponent(String),
    #[error("dot in path: {0:?}")]
    Dot(String),
    #[error("dot-dot in path: {0:?}")]
    DotDot(String),
    #[error("path is absolute: `{}`", _0.display())]
    Absolute(PathBuf),
    #[error("non-UTF-8 component in path: `{}`", _0.display())]
    NotUtf8(PathBuf),
}

/// Protobuf file relative normalized file path.
#[repr(transparent)]
#[derive(Eq, PartialEq, Hash, Debug)]
pub struct ProtoPath {
    path: str,
}

/// Protobuf file relative normalized file path.
#[derive(Debug, Clone, PartialEq, Eq, Default)]
pub struct ProtoPathBuf {
    path: String,
}

impl Hash for ProtoPathBuf {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        self.as_path().hash(state);
    }
}

impl Borrow<ProtoPath> for ProtoPathBuf {
    fn borrow(&self) -> &ProtoPath {
        self.as_path()
    }
}

impl Deref for ProtoPathBuf {
    type Target = ProtoPath;

    fn deref(&self) -> &ProtoPath {
        self.as_path()
    }
}

impl fmt::Display for ProtoPath {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", &self.path)
    }
}

impl fmt::Display for ProtoPathBuf {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", &self.path)
    }
}

impl PartialEq<str> for ProtoPath {
    fn eq(&self, other: &str) -> bool {
        &self.path == other
    }
}

impl PartialEq<str> for ProtoPathBuf {
    fn eq(&self, other: &str) -> bool {
        &self.path == other
    }
}

impl ProtoPath {
    fn unchecked_new(path: &str) -> &ProtoPath {
        unsafe { &*(path as *const str as *const ProtoPath) }
    }

    pub fn new(path: &str) -> anyhow::Result<&ProtoPath> {
        if path.is_empty() {
            return Err(Error::Empty.into());
        }
        if path.contains('\\') {
            return Err(Error::Backslashes(path.to_owned()).into());
        }
        for component in path.split('/') {
            if component.is_empty() {
                return Err(Error::EmptyComponent(path.to_owned()).into());
            }
            if component == "." {
                return Err(Error::Dot(path.to_owned()).into());
            }
            if component == ".." {
                return Err(Error::DotDot(path.to_owned()).into());
            }
        }
        Ok(Self::unchecked_new(path))
    }

    pub fn to_str(&self) -> &str {
        &self.path
    }

    pub fn to_path(&self) -> &Path {
        Path::new(&self.path)
    }

    pub fn to_proto_path_buf(&self) -> ProtoPathBuf {
        ProtoPathBuf {
            path: self.path.to_owned(),
        }
    }
}

impl ProtoPathBuf {
    pub fn as_path(&self) -> &ProtoPath {
        ProtoPath::unchecked_new(&self.path)
    }

    pub fn new(path: String) -> anyhow::Result<ProtoPathBuf> {
        ProtoPath::new(&path)?;
        Ok(ProtoPathBuf { path })
    }

    pub fn from_path(path: &Path) -> anyhow::Result<ProtoPathBuf> {
        let mut path_str = String::new();
        for component in path.components() {
            match component {
                Component::Prefix(..) => return Err(Error::Absolute(path.to_owned()).into()),
                Component::RootDir => return Err(Error::Absolute(path.to_owned()).into()),
                Component::CurDir if path_str.is_empty() => {}
                Component::CurDir => return Err(Error::Dot(path.display().to_string()).into()),
                Component::ParentDir => {
                    return Err(Error::DotDot(path.display().to_string()).into())
                }
                Component::Normal(c) => {
                    if !path_str.is_empty() {
                        path_str.push('/');
                    }
                    path_str.push_str(c.to_str().ok_or_else(|| Error::NotUtf8(path.to_owned()))?);
                }
            }
        }
        Ok(ProtoPathBuf { path: path_str })
    }
}

'''
'''--- protobuf-parse/src/protobuf_abs_path.rs ---
#![doc(hidden)]

use std::fmt;
use std::mem;
use std::ops::Deref;

use protobuf::descriptor::FileDescriptorProto;
use protobuf::reflect::FileDescriptor;
use protobuf::reflect::MessageDescriptor;

use crate::protobuf_ident::ProtobufIdent;
use crate::protobuf_rel_path::ProtobufRelPath;
use crate::ProtobufIdentRef;
use crate::ProtobufRelPathRef;

/// Protobuf absolute name (e. g. `.foo.Bar`).
#[derive(Clone, Eq, PartialEq, Debug, Hash)]
#[doc(hidden)]
pub struct ProtobufAbsPath {
    pub path: String,
}

#[doc(hidden)]
#[derive(Eq, PartialEq, Debug, Hash)]
#[repr(C)]
pub struct ProtobufAbsPathRef(str);

impl Default for ProtobufAbsPath {
    fn default() -> ProtobufAbsPath {
        ProtobufAbsPath::root()
    }
}

impl Deref for ProtobufAbsPathRef {
    type Target = str;

    fn deref(&self) -> &str {
        &self.0
    }
}

impl Deref for ProtobufAbsPath {
    type Target = ProtobufAbsPathRef;

    fn deref(&self) -> &ProtobufAbsPathRef {
        ProtobufAbsPathRef::new(&self.path)
    }
}

impl ProtobufAbsPathRef {
    pub fn is_root(&self) -> bool {
        self.0.is_empty()
    }

    pub fn root() -> &'static ProtobufAbsPathRef {
        Self::new("")
    }

    pub fn new(path: &str) -> &ProtobufAbsPathRef {
        assert!(ProtobufAbsPath::is_abs(path), "{:?} is not absolute", path);
        // SAFETY: repr(transparent)
        unsafe { mem::transmute(path) }
    }

    pub fn remove_prefix(&self, prefix: &ProtobufAbsPathRef) -> Option<&ProtobufRelPathRef> {
        if self.0.starts_with(&prefix.0) {
            let rem = &self.0[prefix.0.len()..];
            if rem.is_empty() {
                return Some(ProtobufRelPathRef::empty());
            }
            if rem.starts_with('.') {
                return Some(ProtobufRelPathRef::new(&rem[1..]));
            }
        }
        None
    }

    pub fn starts_with(&self, that: &ProtobufAbsPathRef) -> bool {
        self.remove_prefix(that).is_some()
    }

    pub fn as_str(&self) -> &str {
        &self.0
    }

    pub fn to_owned(&self) -> ProtobufAbsPath {
        ProtobufAbsPath {
            path: self.0.to_owned(),
        }
    }

    pub fn parent(&self) -> Option<&ProtobufAbsPathRef> {
        match self.0.rfind('.') {
            Some(pos) => Some(ProtobufAbsPathRef::new(&self.0[..pos])),
            None => {
                if self.0.is_empty() {
                    None
                } else {
                    Some(ProtobufAbsPathRef::root())
                }
            }
        }
    }

    pub fn self_and_parents(&self) -> Vec<&ProtobufAbsPathRef> {
        let mut tmp = self;

        let mut r: Vec<&ProtobufAbsPathRef> = Vec::new();

        r.push(&self);

        while let Some(parent) = tmp.parent() {
            r.push(parent);
            tmp = parent;
        }

        r
    }
}

impl ProtobufAbsPath {
    pub fn root() -> ProtobufAbsPath {
        ProtobufAbsPathRef::root().to_owned()
    }

    pub fn as_ref(&self) -> &ProtobufAbsPathRef {
        ProtobufAbsPathRef::new(&self.path)
    }

    /// If given name is an fully quialified protobuf name.
    pub fn is_abs(path: &str) -> bool {
        path.is_empty() || (path.starts_with(".") && path != ".")
    }

    pub fn try_new(path: &str) -> Option<ProtobufAbsPath> {
        if ProtobufAbsPath::is_abs(path) {
            Some(ProtobufAbsPath::new(path))
        } else {
            None
        }
    }

    pub fn new<S: Into<String>>(path: S) -> ProtobufAbsPath {
        let path = path.into();
        assert!(
            ProtobufAbsPath::is_abs(&path),
            "path is not absolute: `{}`",
            path
        );
        assert!(!path.ends_with("."), "{}", path);
        ProtobufAbsPath { path }
    }

    pub fn new_from_rel(path: &str) -> ProtobufAbsPath {
        assert!(
            !path.starts_with("."),
            "rel path must not start with dot: {:?}",
            path
        );
        ProtobufAbsPath {
            path: if path.is_empty() {
                String::new()
            } else {
                format!(".{}", path)
            },
        }
    }

    pub fn package_from_file_proto(file: &FileDescriptorProto) -> ProtobufAbsPath {
        Self::new_from_rel(file.package())
    }

    pub fn package_from_file_descriptor(file: &FileDescriptor) -> ProtobufAbsPath {
        Self::package_from_file_proto(file.proto())
    }

    pub fn from_message(message: &MessageDescriptor) -> ProtobufAbsPath {
        Self::new_from_rel(&message.full_name())
    }

    pub fn concat(a: &ProtobufAbsPathRef, b: &ProtobufRelPathRef) -> ProtobufAbsPath {
        let mut a = a.to_owned();
        a.push_relative(b);
        a
    }

    pub fn from_path_without_dot(path: &str) -> ProtobufAbsPath {
        assert!(!path.is_empty());
        assert!(!path.starts_with("."));
        assert!(!path.ends_with("."));
        ProtobufAbsPath::new(format!(".{}", path))
    }

    pub fn from_path_maybe_dot(path: &str) -> ProtobufAbsPath {
        if path.starts_with(".") {
            ProtobufAbsPath::new(path.to_owned())
        } else {
            ProtobufAbsPath::from_path_without_dot(path)
        }
    }

    pub fn push_simple(&mut self, simple: &ProtobufIdentRef) {
        self.path.push('.');
        self.path.push_str(&simple);
    }

    pub fn push_relative(&mut self, relative: &ProtobufRelPathRef) {
        if !relative.is_empty() {
            self.path.push_str(&format!(".{}", relative));
        }
    }

    pub fn remove_suffix(&self, suffix: &ProtobufRelPathRef) -> Option<&ProtobufAbsPathRef> {
        if suffix.is_empty() {
            return Some(ProtobufAbsPathRef::new(&self.path));
        }

        if self.path.ends_with(suffix.as_str()) {
            let rem = &self.path[..self.path.len() - suffix.as_str().len()];
            if rem.is_empty() {
                return Some(ProtobufAbsPathRef::root());
            }
            if rem.ends_with('.') {
                return Some(ProtobufAbsPathRef::new(&rem[..rem.len() - 1]));
            }
        }
        None
    }

    /// Pop the last name component
    pub fn pop(&mut self) -> Option<ProtobufIdent> {
        match self.path.rfind('.') {
            Some(dot) => {
                let ident = ProtobufIdent::new(&self.path[dot + 1..]);
                self.path.truncate(dot);
                Some(ident)
            }
            None => None,
        }
    }

    pub fn to_root_rel(&self) -> ProtobufRelPath {
        if self == &Self::root() {
            ProtobufRelPath::empty()
        } else {
            ProtobufRelPath::new(&self.path[1..])
        }
    }

    pub fn ends_with(&self, that: &ProtobufRelPath) -> bool {
        self.remove_suffix(that).is_some()
    }
}

impl From<&'_ str> for ProtobufAbsPath {
    fn from(s: &str) -> Self {
        ProtobufAbsPath::new(s.to_owned())
    }
}

impl From<String> for ProtobufAbsPath {
    fn from(s: String) -> Self {
        ProtobufAbsPath::new(s)
    }
}

impl fmt::Display for ProtobufAbsPathRef {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", &self.0)
    }
}

impl fmt::Display for ProtobufAbsPath {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", ProtobufAbsPathRef::new(&self.0))
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn absolute_path_push_simple() {
        let mut foo = ProtobufAbsPath::new(".foo".to_owned());
        foo.push_simple(ProtobufIdentRef::new("bar"));
        assert_eq!(ProtobufAbsPath::new(".foo.bar".to_owned()), foo);

        let mut foo = ProtobufAbsPath::root();
        foo.push_simple(ProtobufIdentRef::new("bar"));
        assert_eq!(ProtobufAbsPath::new(".bar".to_owned()), foo);
    }

    #[test]
    fn absolute_path_remove_prefix() {
        assert_eq!(
            Some(ProtobufRelPathRef::empty()),
            ProtobufAbsPath::new(".foo".to_owned())
                .remove_prefix(&ProtobufAbsPath::new(".foo".to_owned()))
        );
        assert_eq!(
            Some(ProtobufRelPathRef::new("bar")),
            ProtobufAbsPath::new(".foo.bar".to_owned())
                .remove_prefix(&ProtobufAbsPath::new(".foo".to_owned()))
        );
        assert_eq!(
            Some(ProtobufRelPathRef::new("baz.qux")),
            ProtobufAbsPath::new(".foo.bar.baz.qux".to_owned())
                .remove_prefix(&ProtobufAbsPath::new(".foo.bar".to_owned()))
        );
        assert_eq!(
            None,
            ProtobufAbsPath::new(".foo.barbaz".to_owned())
                .remove_prefix(ProtobufAbsPathRef::new(".foo.bar"))
        );
    }

    #[test]
    fn self_and_parents() {
        assert_eq!(
            vec![
                ProtobufAbsPathRef::new(".ab.cde.fghi"),
                ProtobufAbsPathRef::new(".ab.cde"),
                ProtobufAbsPathRef::new(".ab"),
                ProtobufAbsPathRef::root(),
            ],
            ProtobufAbsPath::new(".ab.cde.fghi".to_owned()).self_and_parents()
        );
    }

    #[test]
    fn ends_with() {
        assert!(ProtobufAbsPath::new(".foo.bar").ends_with(&ProtobufRelPath::new("")));
        assert!(ProtobufAbsPath::new(".foo.bar").ends_with(&ProtobufRelPath::new("bar")));
        assert!(ProtobufAbsPath::new(".foo.bar").ends_with(&ProtobufRelPath::new("foo.bar")));
        assert!(!ProtobufAbsPath::new(".foo.bar").ends_with(&ProtobufRelPath::new("foo.bar.baz")));
    }
}

'''
'''--- protobuf-parse/src/protobuf_ident.rs ---
#![doc(hidden)]

use std::fmt;
use std::mem;
use std::ops::Deref;

/// Identifier in `.proto` file
#[derive(Eq, PartialEq, Debug, Clone, Hash)]
#[doc(hidden)]
pub struct ProtobufIdent(String);

#[derive(Eq, PartialEq, Debug, Hash)]
#[doc(hidden)]
#[repr(transparent)]
pub struct ProtobufIdentRef(str);

impl Deref for ProtobufIdentRef {
    type Target = str;

    fn deref(&self) -> &str {
        &self.0
    }
}

impl Deref for ProtobufIdent {
    type Target = ProtobufIdentRef;

    fn deref(&self) -> &ProtobufIdentRef {
        ProtobufIdentRef::new(&self.0)
    }
}

impl From<&'_ str> for ProtobufIdent {
    fn from(s: &str) -> Self {
        ProtobufIdent::new(s)
    }
}

impl From<String> for ProtobufIdent {
    fn from(s: String) -> Self {
        ProtobufIdent::new(&s)
    }
}

impl Into<String> for ProtobufIdent {
    fn into(self) -> String {
        self.0
    }
}

impl fmt::Display for ProtobufIdent {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self.get(), f)
    }
}

impl ProtobufIdentRef {
    pub fn new<'a>(ident: &'a str) -> &'a ProtobufIdentRef {
        assert!(!ident.is_empty());
        // SAFETY: ProtobufIdentRef is repr(transparent)
        unsafe { mem::transmute(ident) }
    }

    pub fn as_str(&self) -> &str {
        &*self
    }

    pub fn to_owned(&self) -> ProtobufIdent {
        ProtobufIdent(self.0.to_owned())
    }
}

impl ProtobufIdent {
    pub fn as_ref(&self) -> &ProtobufIdentRef {
        ProtobufIdentRef::new(&self.0)
    }

    pub fn new(s: &str) -> ProtobufIdent {
        assert!(!s.is_empty());
        assert!(!s.contains("/"));
        assert!(!s.contains("."));
        assert!(!s.contains(":"));
        assert!(!s.contains("("));
        assert!(!s.contains(")"));
        ProtobufIdent(s.to_owned())
    }

    pub fn get(&self) -> &str {
        &self.0
    }

    pub fn into_string(self) -> String {
        self.0
    }
}

'''
'''--- protobuf-parse/src/protobuf_path.rs ---
use std::fmt;

use crate::protobuf_abs_path::ProtobufAbsPath;
use crate::protobuf_rel_path::ProtobufRelPath;

/// Protobuf identifier can be absolute or relative.
#[derive(Debug, Eq, PartialEq, Clone, Hash)]
pub(crate) enum ProtobufPath {
    Abs(ProtobufAbsPath),
    Rel(ProtobufRelPath),
}

impl ProtobufPath {
    pub fn new<S: Into<String>>(path: S) -> ProtobufPath {
        let path = path.into();
        if path.starts_with('.') {
            ProtobufPath::Abs(ProtobufAbsPath::new(path))
        } else {
            ProtobufPath::Rel(ProtobufRelPath::new(path))
        }
    }

    pub fn _resolve(&self, package: &ProtobufAbsPath) -> ProtobufAbsPath {
        match self {
            ProtobufPath::Abs(p) => p.clone(),
            ProtobufPath::Rel(p) => {
                let mut package = package.clone();
                package.push_relative(p);
                package
            }
        }
    }
}

impl fmt::Display for ProtobufPath {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            ProtobufPath::Abs(p) => write!(f, "{}", p),
            ProtobufPath::Rel(p) => write!(f, "{}", p),
        }
    }
}

'''
'''--- protobuf-parse/src/protobuf_rel_path.rs ---
#![doc(hidden)]

use std::fmt;
use std::iter;
use std::mem;
use std::ops::Deref;

use crate::protobuf_abs_path::ProtobufAbsPath;
use crate::protobuf_ident::ProtobufIdent;
use crate::ProtobufIdentRef;

impl From<String> for ProtobufRelPath {
    fn from(s: String) -> ProtobufRelPath {
        ProtobufRelPath::new(s)
    }
}

impl From<&'_ str> for ProtobufRelPath {
    fn from(s: &str) -> ProtobufRelPath {
        ProtobufRelPath::from(s.to_owned())
    }
}

impl ProtobufRelPathRef {
    pub fn as_str(&self) -> &str {
        &self
    }

    pub fn empty() -> &'static ProtobufRelPathRef {
        Self::new("")
    }

    pub fn new(path: &str) -> &ProtobufRelPathRef {
        assert!(!path.starts_with('.'));
        // SAFETY: repr(transparent)
        unsafe { mem::transmute(path) }
    }

    pub fn is_empty(&self) -> bool {
        self.0.is_empty()
    }

    pub fn split_first_rem(&self) -> Option<(&ProtobufIdentRef, &ProtobufRelPathRef)> {
        if self.is_empty() {
            None
        } else {
            match self.0.find('.') {
                Some(i) => Some((
                    ProtobufIdentRef::new(&self.0[..i]),
                    ProtobufRelPathRef::new(&self.0[i + 1..]),
                )),
                None => Some((ProtobufIdentRef::new(&self.0), ProtobufRelPathRef::empty())),
            }
        }
    }

    pub fn components(&self) -> impl Iterator<Item = &ProtobufIdentRef> {
        iter::once(&self.0)
            .filter(|s| !s.is_empty())
            .flat_map(|p| p.split('.').map(|s| ProtobufIdentRef::new(s)))
    }

    fn parent(&self) -> Option<&ProtobufRelPathRef> {
        if self.0.is_empty() {
            None
        } else {
            match self.0.rfind('.') {
                Some(i) => Some(ProtobufRelPathRef::new(&self.0[..i])),
                None => Some(ProtobufRelPathRef::empty()),
            }
        }
    }

    pub fn self_and_parents(&self) -> Vec<&ProtobufRelPathRef> {
        let mut tmp = self;

        let mut r = Vec::new();

        r.push(self);

        while let Some(parent) = tmp.parent() {
            r.push(parent);
            tmp = parent;
        }

        r
    }

    pub fn append(&self, simple: &ProtobufRelPathRef) -> ProtobufRelPath {
        if self.is_empty() {
            simple.to_owned()
        } else if simple.is_empty() {
            self.to_owned()
        } else {
            ProtobufRelPath {
                path: format!("{}.{}", &self.0, &simple.0),
            }
        }
    }

    pub fn append_ident(&self, simple: &ProtobufIdentRef) -> ProtobufRelPath {
        self.append(&ProtobufRelPath::from(simple.to_owned()))
    }

    pub fn to_absolute(&self) -> ProtobufAbsPath {
        self.to_owned().into_absolute()
    }

    pub fn to_owned(&self) -> ProtobufRelPath {
        ProtobufRelPath {
            path: self.0.to_owned(),
        }
    }
}

impl ProtobufRelPath {
    pub fn as_ref(&self) -> &ProtobufRelPathRef {
        &self
    }

    pub fn empty() -> ProtobufRelPath {
        ProtobufRelPath {
            path: String::new(),
        }
    }

    pub fn new<S: Into<String>>(path: S) -> ProtobufRelPath {
        let path = path.into();
        // Validate
        ProtobufRelPathRef::new(&path);
        ProtobufRelPath { path }
    }

    pub fn from_components<'a, I: IntoIterator<Item = &'a ProtobufIdentRef>>(
        i: I,
    ) -> ProtobufRelPath {
        let v: Vec<&str> = i.into_iter().map(|c| c.as_str()).collect();
        ProtobufRelPath::from(v.join("."))
    }

    pub fn into_absolute(self) -> ProtobufAbsPath {
        if self.is_empty() {
            ProtobufAbsPath::root()
        } else {
            ProtobufAbsPath::from(format!(".{}", self))
        }
    }
}

#[doc(hidden)]
#[derive(Debug, Eq, PartialEq, Clone, Hash)]
pub struct ProtobufRelPath {
    pub(crate) path: String,
}

#[doc(hidden)]
#[derive(Debug, Eq, PartialEq, Hash)]
#[repr(transparent)]
pub struct ProtobufRelPathRef(str);

impl Deref for ProtobufRelPathRef {
    type Target = str;

    fn deref(&self) -> &str {
        &self.0
    }
}

impl Deref for ProtobufRelPath {
    type Target = ProtobufRelPathRef;

    fn deref(&self) -> &ProtobufRelPathRef {
        ProtobufRelPathRef::new(&self.path)
    }
}

impl From<ProtobufIdent> for ProtobufRelPath {
    fn from(s: ProtobufIdent) -> ProtobufRelPath {
        ProtobufRelPath { path: s.into() }
    }
}

impl fmt::Display for ProtobufRelPathRef {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", &self.0)
    }
}

impl fmt::Display for ProtobufRelPath {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.path)
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn parent() {
        assert_eq!(None, ProtobufRelPathRef::empty().parent());
        assert_eq!(
            Some(ProtobufRelPathRef::empty()),
            ProtobufRelPath::new("aaa".to_owned()).parent()
        );
        assert_eq!(
            Some(ProtobufRelPathRef::new("abc")),
            ProtobufRelPath::new("abc.def".to_owned()).parent()
        );
        assert_eq!(
            Some(ProtobufRelPathRef::new("abc.def")),
            ProtobufRelPath::new("abc.def.gh".to_owned()).parent()
        );
    }

    #[test]
    fn self_and_parents() {
        assert_eq!(
            vec![
                ProtobufRelPathRef::new("ab.cde.fghi"),
                ProtobufRelPathRef::new("ab.cde"),
                ProtobufRelPathRef::new("ab"),
                ProtobufRelPathRef::empty(),
            ],
            ProtobufRelPath::new("ab.cde.fghi".to_owned()).self_and_parents()
        );
    }

    #[test]
    fn components() {
        assert_eq!(
            Vec::<&ProtobufIdentRef>::new(),
            ProtobufRelPath::empty().components().collect::<Vec<_>>()
        );
        assert_eq!(
            vec![ProtobufIdentRef::new("ab")],
            ProtobufRelPath::new("ab").components().collect::<Vec<_>>()
        );
        assert_eq!(
            vec![ProtobufIdentRef::new("ab"), ProtobufIdentRef::new("cd")],
            ProtobufRelPath::new("ab.cd")
                .components()
                .collect::<Vec<_>>()
        );
    }
}

'''
'''--- protobuf-parse/src/protoc/command.rs ---
//! API to invoke `protoc` command.
//!
//! `protoc` command must be in `$PATH`, along with `protoc-gen-LANG` command.
//!
//! Note that to generate `rust` code from `.proto` files, `protoc-rust` crate
//! can be used, which does not require `protoc-gen-rust` present in `$PATH`.

#![deny(missing_docs)]
#![deny(rustdoc::broken_intra_doc_links)]

use std::ffi::OsStr;
use std::ffi::OsString;
use std::fmt;
use std::io;
use std::path::Path;
use std::path::PathBuf;
use std::process;
use std::process::Stdio;

use log::info;

#[derive(Debug, thiserror::Error)]
enum Error {
    #[error("protoc command exited with non-zero code")]
    ProtocNonZero,
    #[error("protoc command {0} exited with non-zero code")]
    ProtocNamedNonZero(String),
    #[error("protoc command {0} exited with non-zero code; stderr: {1:?}")]
    ProtocNamedNonZeroStderr(String, String),
    #[error("input is empty")]
    InputIsEmpty,
    #[error("output is empty")]
    OutputIsEmpty,
    #[error("output does not start with prefix")]
    OutputDoesNotStartWithPrefix,
    #[error("version is empty")]
    VersionIsEmpty,
    #[error("version does not start with digit")]
    VersionDoesNotStartWithDigit,
    #[error("failed to spawn command `{0}`")]
    FailedToSpawnCommand(String, #[source] io::Error),
    #[error("protoc output is not UTF-8")]
    ProtocOutputIsNotUtf8,
}

/// `Protoc --descriptor_set_out...` args
#[derive(Debug)]
pub(crate) struct DescriptorSetOutArgs {
    protoc: Protoc,
    /// `--file_descriptor_out=...` param
    out: Option<PathBuf>,
    /// `-I` args
    includes: Vec<PathBuf>,
    /// List of `.proto` files to compile
    inputs: Vec<PathBuf>,
    /// `--include_imports`
    include_imports: bool,
    /// Extra command line flags (like `--experimental_allow_proto3_optional`)
    extra_args: Vec<OsString>,
    /// Capture stderr instead of inheriting it.
    capture_stderr: bool,
}

impl DescriptorSetOutArgs {
    /// Set `--file_descriptor_out=...` param
    pub fn out(&mut self, out: impl AsRef<Path>) -> &mut Self {
        self.out = Some(out.as_ref().to_owned());
        self
    }

    /// Append a path to `-I` args
    pub fn include(&mut self, include: impl AsRef<Path>) -> &mut Self {
        self.includes.push(include.as_ref().to_owned());
        self
    }

    /// Append multiple paths to `-I` args
    pub fn includes(&mut self, includes: impl IntoIterator<Item = impl AsRef<Path>>) -> &mut Self {
        for include in includes {
            self.include(include);
        }
        self
    }

    /// Append a `.proto` file path to compile
    pub fn input(&mut self, input: impl AsRef<Path>) -> &mut Self {
        self.inputs.push(input.as_ref().to_owned());
        self
    }

    /// Append multiple `.proto` file paths to compile
    pub fn inputs(&mut self, inputs: impl IntoIterator<Item = impl AsRef<Path>>) -> &mut Self {
        for input in inputs {
            self.input(input);
        }
        self
    }

    /// Set `--include_imports`
    pub fn include_imports(&mut self, include_imports: bool) -> &mut Self {
        self.include_imports = include_imports;
        self
    }

    /// Add command line flags like `--experimental_allow_proto3_optional`.
    pub fn extra_arg(&mut self, arg: impl Into<OsString>) -> &mut Self {
        self.extra_args.push(arg.into());
        self
    }

    /// Add command line flags like `--experimental_allow_proto3_optional`.
    pub fn extra_args(&mut self, args: impl IntoIterator<Item = impl Into<OsString>>) -> &mut Self {
        for arg in args {
            self.extra_arg(arg);
        }
        self
    }

    /// Capture stderr instead of inheriting it.
    pub(crate) fn capture_stderr(&mut self, capture_stderr: bool) -> &mut Self {
        self.capture_stderr = capture_stderr;
        self
    }

    /// Execute `protoc --descriptor_set_out=`
    pub fn write_descriptor_set(&self) -> anyhow::Result<()> {
        if self.inputs.is_empty() {
            return Err(Error::InputIsEmpty.into());
        }

        let out = self.out.as_ref().ok_or_else(|| Error::OutputIsEmpty)?;

        // -I{include}
        let include_flags = self.includes.iter().map(|include| {
            let mut flag = OsString::from("-I");
            flag.push(include);
            flag
        });

        // --descriptor_set_out={out}
        let mut descriptor_set_out_flag = OsString::from("--descriptor_set_out=");
        descriptor_set_out_flag.push(out);

        // --include_imports
        let include_imports_flag = match self.include_imports {
            false => None,
            true => Some("--include_imports".into()),
        };

        let mut cmd_args = Vec::new();
        cmd_args.extend(include_flags);
        cmd_args.push(descriptor_set_out_flag);
        cmd_args.extend(include_imports_flag);
        cmd_args.extend(self.inputs.iter().map(|path| path.as_os_str().to_owned()));
        cmd_args.extend(self.extra_args.iter().cloned());
        self.protoc.run_with_args(cmd_args, self.capture_stderr)
    }
}

/// Protoc command.
#[derive(Clone, Debug)]
pub(crate) struct Protoc {
    exec: OsString,
}

impl Protoc {
    /// New `protoc` command from `$PATH`
    pub(crate) fn from_env_path() -> Protoc {
        match which::which("protoc") {
            Ok(path) => Protoc {
                exec: path.into_os_string(),
            },
            Err(e) => {
                panic!("protoc binary not found: {}", e);
            }
        }
    }

    /// New `protoc` command from specified path
    ///
    /// # Examples
    ///
    /// ```no_run
    /// # mod protoc_bin_vendored {
    /// #   pub fn protoc_bin_path() -> Result<std::path::PathBuf, std::io::Error> {
    /// #       unimplemented!()
    /// #   }
    /// # }
    ///
    /// // Use a binary from `protoc-bin-vendored` crate
    /// let protoc = protoc::Protoc::from_path(
    ///     protoc_bin_vendored::protoc_bin_path().unwrap());
    /// ```
    pub(crate) fn from_path(path: impl AsRef<OsStr>) -> Protoc {
        Protoc {
            exec: path.as_ref().to_owned(),
        }
    }

    /// Check `protoc` command found and valid
    pub(crate) fn _check(&self) -> anyhow::Result<()> {
        self.version()?;
        Ok(())
    }

    fn spawn(&self, cmd: &mut process::Command) -> anyhow::Result<process::Child> {
        info!("spawning command {:?}", cmd);

        cmd.spawn()
            .map_err(|e| Error::FailedToSpawnCommand(format!("{:?}", cmd), e).into())
    }

    /// Obtain `protoc` version
    pub(crate) fn version(&self) -> anyhow::Result<Version> {
        let child = self.spawn(
            process::Command::new(&self.exec)
                .stdin(process::Stdio::null())
                .stdout(process::Stdio::piped())
                .stderr(process::Stdio::piped())
                .args(&["--version"]),
        )?;

        let output = child.wait_with_output()?;
        if !output.status.success() {
            return Err(Error::ProtocNonZero.into());
        }
        let output = String::from_utf8(output.stdout).map_err(|_| Error::ProtocOutputIsNotUtf8)?;
        let output = match output.lines().next() {
            None => return Err(Error::OutputIsEmpty.into()),
            Some(line) => line,
        };
        let prefix = "libprotoc ";
        if !output.starts_with(prefix) {
            return Err(Error::OutputDoesNotStartWithPrefix.into());
        }
        let output = &output[prefix.len()..];
        if output.is_empty() {
            return Err(Error::VersionIsEmpty.into());
        }
        let first = output.chars().next().unwrap();
        if !first.is_digit(10) {
            return Err(Error::VersionDoesNotStartWithDigit.into());
        }
        Ok(Version {
            version: output.to_owned(),
        })
    }

    /// Execute `protoc` command with given args, check it completed correctly.
    fn run_with_args(&self, args: Vec<OsString>, capture_stderr: bool) -> anyhow::Result<()> {
        let mut cmd = process::Command::new(&self.exec);
        cmd.stdin(process::Stdio::null());
        cmd.args(args);

        if capture_stderr {
            cmd.stderr(Stdio::piped());
        }

        let mut child = self.spawn(&mut cmd)?;

        if capture_stderr {
            let output = child.wait_with_output()?;
            if !output.status.success() {
                let stderr = String::from_utf8_lossy(&output.stderr);
                let stderr = stderr.trim_end().to_owned();
                return Err(Error::ProtocNamedNonZeroStderr(format!("{:?}", cmd), stderr).into());
            }
        } else {
            if !child.wait()?.success() {
                return Err(Error::ProtocNamedNonZero(format!("{:?}", cmd)).into());
            }
        }

        Ok(())
    }

    /// Get default DescriptorSetOutArgs for this command.
    pub(crate) fn descriptor_set_out_args(&self) -> DescriptorSetOutArgs {
        DescriptorSetOutArgs {
            protoc: self.clone(),
            out: None,
            includes: Vec::new(),
            inputs: Vec::new(),
            include_imports: false,
            extra_args: Vec::new(),
            capture_stderr: false,
        }
    }
}

/// Protobuf (protoc) version.
pub(crate) struct Version {
    version: String,
}

impl Version {
    /// `true` if the protoc major version is 3.
    pub fn _is_3(&self) -> bool {
        self.version.starts_with("3")
    }
}

impl fmt::Display for Version {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self.version, f)
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn version() {
        Protoc::from_env_path().version().expect("version");
    }
}

'''
'''--- protobuf-parse/src/protoc/mod.rs ---
//! Parse `.proto` files using `protoc` command.

pub(crate) mod command;
pub(crate) mod parse_and_typecheck;

'''
'''--- protobuf-parse/src/protoc/parse_and_typecheck.rs ---
use std::fs;

use protobuf::descriptor::FileDescriptorSet;
use protobuf::Message;

use crate::protoc::command::Protoc;
use crate::pure::parse_and_typecheck::path_to_proto_path;
use crate::ParsedAndTypechecked;
use crate::Parser;
use crate::ProtoPathBuf;

/// Parse `.proto` files using `protoc` command.
pub(crate) fn parse_and_typecheck(parser: &Parser) -> anyhow::Result<ParsedAndTypechecked> {
    let temp_dir = tempfile::Builder::new()
        .prefix("protobuf-parse")
        .tempdir()?;
    let temp_file = temp_dir.path().join("descriptor.pbbin");

    let relative_paths: Vec<ProtoPathBuf> = parser
        .inputs
        .iter()
        .map(|p| path_to_proto_path(p, &parser.includes))
        .collect::<anyhow::Result<_>>()?;

    let protoc = match &parser.protoc {
        Some(protoc) => Protoc::from_path(protoc),
        None => Protoc::from_env_path(),
    };

    protoc
        .descriptor_set_out_args()
        .inputs(&parser.inputs)
        .includes(&parser.includes)
        .out(&temp_file)
        .include_imports(true)
        .extra_args(&parser.protoc_extra_args)
        .capture_stderr(parser.capture_stderr)
        .write_descriptor_set()?;

    let version = protoc.version()?;

    let fds = fs::read(temp_file)?;
    drop(temp_dir);

    let fds: protobuf::descriptor::FileDescriptorSet = FileDescriptorSet::parse_from_bytes(&fds)?;

    Ok(ParsedAndTypechecked {
        relative_paths,
        file_descriptors: fds.file,
        parser: format!("protoc {}", version),
    })
}

'''
'''--- protobuf-parse/src/pure/convert/mod.rs ---
//! Convert parser model to rust-protobuf model

mod option_resolver;
mod type_resolver;

use protobuf;
use protobuf::descriptor::descriptor_proto::ReservedRange;
use protobuf::descriptor::field_descriptor_proto;
use protobuf::descriptor::field_descriptor_proto::Type;
use protobuf::descriptor::FieldDescriptorProto;
use protobuf::descriptor::OneofDescriptorProto;
use protobuf::reflect::FileDescriptor;
use protobuf_support::json_name::json_name;
use protobuf_support::text_format::escape_bytes_to;

use crate::case_convert::camel_case;
use crate::path::fs_path_to_proto_path;
use crate::proto_path::ProtoPath;
use crate::protobuf_abs_path::ProtobufAbsPath;
use crate::protobuf_ident::ProtobufIdent;
use crate::pure::convert::option_resolver::OptionResoler;
use crate::pure::convert::option_resolver::ProtobufOptions;
use crate::pure::convert::type_resolver::MessageOrEnum;
use crate::pure::convert::type_resolver::TypeResolver;
use crate::pure::model;
use crate::FileDescriptorPair;
use crate::ProtobufAbsPathRef;
use crate::ProtobufIdentRef;

#[derive(Debug, thiserror::Error)]
enum ConvertError {
    #[error("default value is not a string literal")]
    DefaultValueIsNotStringLiteral,
    #[error("expecting a message for name {0}")]
    ExpectingMessage(ProtobufAbsPath),
    #[error("expecting an enum for name {0}")]
    ExpectingEnum(ProtobufAbsPath),
}

pub struct WithFullName<T> {
    full_name: ProtobufAbsPath,
    t: T,
}

#[derive(Debug, PartialEq)]
enum TypeResolved {
    Int32,
    Int64,
    Uint32,
    Uint64,
    Sint32,
    Sint64,
    Bool,
    Fixed64,
    Sfixed64,
    Double,
    String,
    Bytes,
    Fixed32,
    Sfixed32,
    Float,
    Message(ProtobufAbsPath),
    Enum(ProtobufAbsPath),
    Group(ProtobufAbsPath),
}

impl TypeResolved {
    fn from_field(field: &FieldDescriptorProto) -> TypeResolved {
        match field.type_() {
            Type::TYPE_DOUBLE => TypeResolved::Double,
            Type::TYPE_FLOAT => TypeResolved::Float,
            Type::TYPE_INT64 => TypeResolved::Int64,
            Type::TYPE_UINT64 => TypeResolved::Uint64,
            Type::TYPE_INT32 => TypeResolved::Int32,
            Type::TYPE_FIXED64 => TypeResolved::Fixed64,
            Type::TYPE_FIXED32 => TypeResolved::Fixed32,
            Type::TYPE_UINT32 => TypeResolved::Uint32,
            Type::TYPE_SFIXED32 => TypeResolved::Sfixed32,
            Type::TYPE_SFIXED64 => TypeResolved::Sfixed64,
            Type::TYPE_SINT32 => TypeResolved::Sint32,
            Type::TYPE_SINT64 => TypeResolved::Sint64,
            Type::TYPE_BOOL => TypeResolved::Bool,
            Type::TYPE_STRING => TypeResolved::String,
            Type::TYPE_BYTES => TypeResolved::Bytes,
            Type::TYPE_GROUP => {
                assert!(!field.type_name().is_empty());
                TypeResolved::Group(ProtobufAbsPath::new(field.type_name()))
            }
            Type::TYPE_ENUM => {
                assert!(!field.type_name().is_empty());
                TypeResolved::Enum(ProtobufAbsPath::new(field.type_name()))
            }
            Type::TYPE_MESSAGE => {
                assert!(!field.type_name().is_empty());
                TypeResolved::Message(ProtobufAbsPath::new(field.type_name()))
            }
        }
    }

    fn type_enum(&self) -> Type {
        match self {
            TypeResolved::Bool => Type::TYPE_BOOL,
            TypeResolved::Int32 => Type::TYPE_INT32,
            TypeResolved::Int64 => Type::TYPE_INT64,
            TypeResolved::Uint32 => Type::TYPE_UINT32,
            TypeResolved::Uint64 => Type::TYPE_UINT64,
            TypeResolved::Sint32 => Type::TYPE_SINT32,
            TypeResolved::Sint64 => Type::TYPE_SINT64,
            TypeResolved::Fixed32 => Type::TYPE_FIXED32,
            TypeResolved::Fixed64 => Type::TYPE_FIXED64,
            TypeResolved::Sfixed32 => Type::TYPE_SFIXED32,
            TypeResolved::Sfixed64 => Type::TYPE_SFIXED64,
            TypeResolved::Float => Type::TYPE_FLOAT,
            TypeResolved::Double => Type::TYPE_DOUBLE,
            TypeResolved::String => Type::TYPE_STRING,
            TypeResolved::Bytes => Type::TYPE_BYTES,
            TypeResolved::Message(_) => Type::TYPE_MESSAGE,
            TypeResolved::Enum(_) => Type::TYPE_ENUM,
            TypeResolved::Group(_) => Type::TYPE_GROUP,
        }
    }

    fn type_name(&self) -> Option<&ProtobufAbsPath> {
        match self {
            TypeResolved::Message(t) | TypeResolved::Enum(t) | TypeResolved::Group(t) => Some(t),
            _ => None,
        }
    }
}

pub(crate) struct Resolver<'a> {
    type_resolver: TypeResolver<'a>,
    current_file: &'a model::FileDescriptor,
}

impl<'a> Resolver<'a> {
    fn map_entry_name_for_field_name(field_name: &str) -> ProtobufIdent {
        // Field name and message name must match, otherwise
        // Google's validation fails.
        // https://git.io/JeOvF
        ProtobufIdent::from(format!("{}Entry", camel_case(field_name)))
    }

    fn map_entry_field(
        &self,
        scope: &ProtobufAbsPath,
        name: &str,
        number: i32,
        field_type: &model::FieldType,
    ) -> anyhow::Result<protobuf::descriptor::FieldDescriptorProto> {
        // should be consisent with DescriptorBuilder::ValidateMapEntry

        let mut output = protobuf::descriptor::FieldDescriptorProto::new();

        output.set_name(name.to_owned());
        output.set_number(number);

        let t = self.field_type(&scope, name, field_type)?;
        output.set_type(t.type_enum());
        if let Some(t_name) = t.type_name() {
            output.set_type_name(t_name.path.clone());
        }

        output.set_label(field_descriptor_proto::Label::LABEL_OPTIONAL);

        output.set_json_name(json_name(&name));

        Ok(output)
    }

    fn map_entry_message(
        &self,
        scope: &ProtobufAbsPath,
        field_name: &str,
        key: &model::FieldType,
        value: &model::FieldType,
    ) -> anyhow::Result<protobuf::descriptor::DescriptorProto> {
        let mut output = protobuf::descriptor::DescriptorProto::new();

        output.options.mut_or_insert_default().set_map_entry(true);
        output.set_name(Resolver::map_entry_name_for_field_name(field_name).into_string());
        output
            .field
            .push(self.map_entry_field(&scope, "key", 1, key)?);
        output
            .field
            .push(self.map_entry_field(&scope, "value", 2, value)?);

        Ok(output)
    }

    fn group_message(
        &self,
        scope: &ProtobufAbsPath,
        name: &str,
        fields: &[model::WithLoc<model::Field>],
    ) -> anyhow::Result<protobuf::descriptor::DescriptorProto> {
        let mut output = protobuf::descriptor::DescriptorProto::new();

        output.set_name(name.to_owned());

        for f in fields {
            output.field.push(self.field(scope, f, None)?);
        }

        Ok(output)
    }

    fn message(
        &self,
        scope: &ProtobufAbsPathRef,
        input: &model::Message,
    ) -> anyhow::Result<protobuf::descriptor::DescriptorProto> {
        let mut nested_scope = scope.to_owned();
        nested_scope.push_simple(ProtobufIdentRef::new(&input.name));

        let mut output = protobuf::descriptor::DescriptorProto::new();
        output.set_name(input.name.clone());

        let mut nested_messages = Vec::new();

        for m in &input.messages {
            let message = self.message(&nested_scope, &m.t)?;
            nested_messages.push(model::WithLoc {
                t: message,
                loc: m.loc,
            });
        }

        for f in input.regular_fields_including_in_oneofs() {
            match &f.t.typ {
                model::FieldType::Map(t) => {
                    let message = self.map_entry_message(&nested_scope, &f.t.name, &t.0, &t.1)?;
                    nested_messages.push(model::WithLoc {
                        t: message,
                        loc: f.loc,
                    });
                }
                model::FieldType::Group(model::Group {
                    name: group_name,
                    fields,
                    ..
                }) => {
                    let message = self.group_message(&nested_scope, group_name, fields)?;
                    nested_messages.push(model::WithLoc {
                        t: message,
                        loc: f.loc,
                    });
                }
                _ => (),
            }
        }

        // Preserve declaration order
        nested_messages.sort_by_key(|m| m.loc);
        output.nested_type = nested_messages
            .into_iter()
            .map(|model::WithLoc { t, .. }| t)
            .collect();

        output.enum_type = input
            .enums
            .iter()
            .map(|e| self.enumeration(scope, e))
            .collect::<Result<_, _>>()?;

        {
            let mut fields = Vec::new();

            for fo in &input.fields {
                match &fo.t {
                    model::FieldOrOneOf::Field(f) => {
                        let oneof_index = if self.is_proto3_optional(f) {
                            let oneof_index = output.oneof_decl.len() as i32;
                            let mut oneof = OneofDescriptorProto::new();
                            oneof.set_name(format!("_{}", f.name));
                            output.oneof_decl.push(oneof);
                            Some(oneof_index)
                        } else {
                            None
                        };
                        fields.push(self.field(&nested_scope, f, oneof_index)?);
                    }
                    model::FieldOrOneOf::OneOf(o) => {
                        let oneof_index = output.oneof_decl.len();
                        for f in &o.fields {
                            fields.push(self.field(&nested_scope, f, Some(oneof_index as i32))?);
                        }
                        output.oneof_decl.push(self.oneof(scope, o)?);
                    }
                }
            }

            output.field = fields;
        }

        for ext in &input.extension_ranges {
            let mut extension_range = protobuf::descriptor::descriptor_proto::ExtensionRange::new();
            extension_range.set_start(ext.from);
            extension_range.set_end(ext.to + 1);
            output.extension_range.push(extension_range);
        }
        for ext in &input.extensions {
            let mut extension = self.field(scope, &ext.t.field, None)?;
            extension.set_extendee(
                self.type_resolver
                    .resolve_message_or_enum(scope, &ext.t.extendee)?
                    .full_name
                    .path,
            );
            output.extension.push(extension);
        }

        for reserved in &input.reserved_nums {
            let mut reserved_range = ReservedRange::new();
            reserved_range.set_start(reserved.from);
            reserved_range.set_end(reserved.to + 1);
            output.reserved_range.push(reserved_range);
        }
        output.reserved_name = input.reserved_names.clone().into();

        Ok(output)
    }

    fn service_method(
        &self,
        input: &model::Method,
    ) -> anyhow::Result<protobuf::descriptor::MethodDescriptorProto> {
        let scope = &self.current_file.package;
        let mut output = protobuf::descriptor::MethodDescriptorProto::new();
        output.set_name(input.name.clone());
        output.set_input_type(
            self.type_resolver
                .resolve_message_or_enum(scope, &input.input_type)?
                .full_name
                .to_string(),
        );
        output.set_output_type(
            self.type_resolver
                .resolve_message_or_enum(scope, &input.output_type)?
                .full_name
                .to_string(),
        );
        Ok(output)
    }

    fn service(
        &self,
        input: &model::Service,
    ) -> anyhow::Result<protobuf::descriptor::ServiceDescriptorProto> {
        let mut output = protobuf::descriptor::ServiceDescriptorProto::new();
        output.set_name(input.name.clone());

        output.method = input
            .methods
            .iter()
            .map(|m| self.service_method(m))
            .collect::<Result<_, _>>()?;

        Ok(output)
    }

    fn is_proto3_optional(&self, input: &model::WithLoc<model::Field>) -> bool {
        (self.current_file.syntax, input.t.rule)
            == (model::Syntax::Proto3, Some(model::Rule::Optional))
    }

    fn field(
        &self,
        scope: &ProtobufAbsPathRef,
        input: &model::WithLoc<model::Field>,
        oneof_index: Option<i32>,
    ) -> anyhow::Result<protobuf::descriptor::FieldDescriptorProto> {
        let mut output = protobuf::descriptor::FieldDescriptorProto::new();
        output.set_name(input.t.name.clone());

        if let model::FieldType::Map(..) = input.t.typ {
            output.set_label(protobuf::descriptor::field_descriptor_proto::Label::LABEL_REPEATED);
        } else {
            output.set_label(label(input.t.rule));

            if self.is_proto3_optional(input) {
                output.set_proto3_optional(true);
            }
        }

        let t = self.field_type(scope, &input.t.name, &input.t.typ)?;
        output.set_type(t.type_enum());
        if let Some(t_name) = t.type_name() {
            output.set_type_name(t_name.path.clone());
        }

        output.set_number(input.t.number);
        // TODO: move default to option parser
        if let Some(ref default) = input.t.options.as_slice().by_name("default") {
            let default = match output.type_() {
                protobuf::descriptor::field_descriptor_proto::Type::TYPE_STRING => {
                    if let &model::ProtobufConstant::String(ref s) = default {
                        s.decode_utf8()?
                    } else {
                        return Err(ConvertError::DefaultValueIsNotStringLiteral.into());
                    }
                }
                protobuf::descriptor::field_descriptor_proto::Type::TYPE_BYTES => {
                    if let &model::ProtobufConstant::String(ref s) = default {
                        let mut buf = String::new();
                        escape_bytes_to(&s.decode_bytes()?, &mut buf);
                        buf
                    } else {
                        return Err(ConvertError::DefaultValueIsNotStringLiteral.into());
                    }
                }
                _ => default.format(),
            };
            output.set_default_value(default);
        }

        if let Some(oneof_index) = oneof_index {
            output.set_oneof_index(oneof_index);
        }

        if let Some(json_name) = input.t.options.as_slice().by_name_string("json_name")? {
            output.set_json_name(json_name);
        } else {
            output.set_json_name(json_name(&input.t.name));
        }

        Ok(output)
    }

    fn find_message_by_abs_name(
        &self,
        abs_path: &ProtobufAbsPath,
    ) -> anyhow::Result<WithFullName<&'a model::Message>> {
        let with_full_name = self
            .type_resolver
            .find_message_or_enum_by_abs_name(abs_path)?;
        match with_full_name.t {
            MessageOrEnum::Message(m) => Ok(WithFullName {
                t: m,
                full_name: with_full_name.full_name,
            }),
            MessageOrEnum::Enum(..) => Err(ConvertError::ExpectingMessage(abs_path.clone()).into()),
        }
    }

    fn find_enum_by_abs_name(
        &self,
        abs_path: &ProtobufAbsPath,
    ) -> anyhow::Result<&'a model::Enumeration> {
        match self
            .type_resolver
            .find_message_or_enum_by_abs_name(abs_path)?
            .t
        {
            MessageOrEnum::Enum(e) => Ok(e),
            MessageOrEnum::Message(..) => Err(ConvertError::ExpectingEnum(abs_path.clone()).into()),
        }
    }

    fn field_type(
        &self,
        scope: &ProtobufAbsPathRef,
        name: &str,
        input: &model::FieldType,
    ) -> anyhow::Result<TypeResolved> {
        Ok(match *input {
            model::FieldType::Bool => TypeResolved::Bool,
            model::FieldType::Int32 => TypeResolved::Int32,
            model::FieldType::Int64 => TypeResolved::Int64,
            model::FieldType::Uint32 => TypeResolved::Uint32,
            model::FieldType::Uint64 => TypeResolved::Uint64,
            model::FieldType::Sint32 => TypeResolved::Sint32,
            model::FieldType::Sint64 => TypeResolved::Sint64,
            model::FieldType::Fixed32 => TypeResolved::Fixed32,
            model::FieldType::Fixed64 => TypeResolved::Fixed64,
            model::FieldType::Sfixed32 => TypeResolved::Sfixed32,
            model::FieldType::Sfixed64 => TypeResolved::Sfixed64,
            model::FieldType::Float => TypeResolved::Float,
            model::FieldType::Double => TypeResolved::Double,
            model::FieldType::String => TypeResolved::String,
            model::FieldType::Bytes => TypeResolved::Bytes,
            model::FieldType::MessageOrEnum(ref name) => {
                let t = self.type_resolver.resolve_message_or_enum(scope, &name)?;
                match t.t {
                    MessageOrEnum::Message(..) => TypeResolved::Message(t.full_name),
                    MessageOrEnum::Enum(..) => TypeResolved::Enum(t.full_name),
                }
            }
            model::FieldType::Map(..) => {
                let mut type_name = scope.to_owned();
                type_name.push_simple(&Resolver::map_entry_name_for_field_name(name));
                TypeResolved::Message(type_name)
            }
            model::FieldType::Group(model::Group {
                name: ref group_name,
                ..
            }) => {
                let mut type_name = scope.to_owned();
                type_name.push_simple(ProtobufIdentRef::new(group_name));
                TypeResolved::Group(type_name)
            }
        })
    }

    fn enum_value(
        &self,
        _scope: &ProtobufAbsPathRef,
        input: &model::EnumValue,
    ) -> anyhow::Result<protobuf::descriptor::EnumValueDescriptorProto> {
        let mut output = protobuf::descriptor::EnumValueDescriptorProto::new();
        output.set_name(input.name.clone());
        output.set_number(input.number);
        Ok(output)
    }

    fn enumeration(
        &self,
        scope: &ProtobufAbsPathRef,
        input: &model::Enumeration,
    ) -> anyhow::Result<protobuf::descriptor::EnumDescriptorProto> {
        let mut output = protobuf::descriptor::EnumDescriptorProto::new();
        output.set_name(input.name.clone());
        output.value = input
            .values
            .iter()
            .map(|v| self.enum_value(scope, &v))
            .collect::<Result<_, _>>()?;
        Ok(output)
    }

    fn oneof(
        &self,
        _scope: &ProtobufAbsPathRef,
        input: &model::OneOf,
    ) -> anyhow::Result<protobuf::descriptor::OneofDescriptorProto> {
        let mut output = protobuf::descriptor::OneofDescriptorProto::new();
        output.set_name(input.name.clone());
        Ok(output)
    }

    fn extension(
        &self,
        scope: &ProtobufAbsPath,
        input: &model::Extension,
    ) -> anyhow::Result<(
        protobuf::descriptor::FieldDescriptorProto,
        Option<protobuf::descriptor::DescriptorProto>,
    )> {
        let mut field = self.field(scope, &input.field, None)?;
        field.set_extendee(
            self.type_resolver
                .resolve_message_or_enum(scope, &input.extendee)?
                .full_name
                .to_string(),
        );
        let group_messages = if let model::FieldType::Group(g) = &input.field.t.typ {
            Some(self.group_message(scope, &g.name, &g.fields)?)
        } else {
            None
        };
        Ok((field, group_messages))
    }
}

fn syntax(input: model::Syntax) -> String {
    match input {
        model::Syntax::Proto2 => "proto2".to_owned(),
        model::Syntax::Proto3 => "proto3".to_owned(),
    }
}

fn label(input: Option<model::Rule>) -> protobuf::descriptor::field_descriptor_proto::Label {
    match input {
        Some(model::Rule::Optional) => {
            protobuf::descriptor::field_descriptor_proto::Label::LABEL_OPTIONAL
        }
        Some(model::Rule::Required) => {
            protobuf::descriptor::field_descriptor_proto::Label::LABEL_REQUIRED
        }
        Some(model::Rule::Repeated) => {
            protobuf::descriptor::field_descriptor_proto::Label::LABEL_REPEATED
        }
        None => protobuf::descriptor::field_descriptor_proto::Label::LABEL_OPTIONAL,
    }
}

pub(crate) fn populate_dependencies(
    input: &model::FileDescriptor,
    output: &mut protobuf::descriptor::FileDescriptorProto,
) {
    for import in &input.imports {
        if import.vis == model::ImportVis::Public {
            output
                .public_dependency
                .push(output.dependency.len() as i32);
        } else if import.vis == model::ImportVis::Weak {
            output.weak_dependency.push(output.dependency.len() as i32);
        }
        output.dependency.push(import.path.to_string());
    }
}

pub(crate) fn file_descriptor(
    name: &ProtoPath,
    input: &model::FileDescriptor,
    deps: &[FileDescriptorPair],
) -> anyhow::Result<protobuf::descriptor::FileDescriptorProto> {
    let resolver = Resolver {
        current_file: &input,
        type_resolver: TypeResolver {
            current_file: &input,
            deps,
        },
    };

    let mut output = protobuf::descriptor::FileDescriptorProto::new();
    output.set_name(fs_path_to_proto_path(name));
    output.set_syntax(syntax(input.syntax));

    if input.package != ProtobufAbsPath::root() {
        output.set_package(input.package.to_root_rel().to_string());
    }

    populate_dependencies(&input, &mut output);

    let mut messages = Vec::new();
    let mut services = Vec::new();

    let mut extensions = Vec::new();
    for e in &input.extensions {
        let (ext, group_messages) = resolver.extension(&resolver.current_file.package, &e.t)?;
        extensions.push(ext);
        messages.extend(group_messages.map(model::WithLoc::with_loc(e.loc)));
    }
    output.extension = extensions;

    for m in &input.messages {
        let message = resolver.message(&resolver.current_file.package, &m.t)?;
        messages.push(model::WithLoc {
            t: message,
            loc: m.loc,
        });
    }

    for s in &input.services {
        let service = resolver.service(&s.t)?;
        services.push(model::WithLoc {
            t: service,
            loc: s.loc,
        })
    }

    // Preserve declaration order
    messages.sort_by_key(|m| m.loc);
    output.message_type = messages
        .into_iter()
        .map(|model::WithLoc { t, .. }| t)
        .collect();

    output.enum_type = input
        .enums
        .iter()
        .map(|e| resolver.enumeration(&resolver.current_file.package, e))
        .collect::<Result<_, _>>()?;

    output.service = services
        .into_iter()
        .map(|model::WithLoc { t, .. }| t)
        .collect();

    let descriptor_without_options = FileDescriptor::new_dynamic(
        output.clone(),
        &deps
            .iter()
            .map(|d| d.descriptor.clone())
            .collect::<Vec<_>>(),
    )?;

    let option_resolver = OptionResoler {
        resolver: &resolver,
        descriptor_without_options,
    };

    option_resolver.file(&mut output)?;

    Ok(output)
}

'''
'''--- protobuf-parse/src/pure/convert/option_resolver.rs ---
use anyhow::Context;
use protobuf::descriptor::DescriptorProto;
use protobuf::descriptor::EnumDescriptorProto;
use protobuf::descriptor::EnumValueDescriptorProto;
use protobuf::descriptor::FieldDescriptorProto;
use protobuf::descriptor::FileDescriptorProto;
use protobuf::descriptor::MethodDescriptorProto;
use protobuf::descriptor::OneofDescriptorProto;
use protobuf::descriptor::ServiceDescriptorProto;
use protobuf::reflect::FieldDescriptor;
use protobuf::reflect::FileDescriptor;
use protobuf::reflect::MessageDescriptor;
use protobuf::MessageFull;
use protobuf::UnknownFields;
use protobuf::UnknownValue;
use protobuf_support::lexer::str_lit::StrLitDecodeError;

use crate::model;
use crate::model::ProtobufConstant;
use crate::model::ProtobufConstantMessage;
use crate::model::ProtobufConstantMessageFieldName;
use crate::model::ProtobufOptionName;
use crate::model::ProtobufOptionNameExt;
use crate::model::ProtobufOptionNamePart;
use crate::model::WithLoc;
use crate::protobuf_path::ProtobufPath;
use crate::pure::convert::Resolver;
use crate::pure::convert::TypeResolved;
use crate::ProtobufAbsPath;
use crate::ProtobufAbsPathRef;
use crate::ProtobufIdent;
use crate::ProtobufIdentRef;
use crate::ProtobufRelPath;
use crate::ProtobufRelPathRef;

#[derive(Debug, thiserror::Error)]
enum OptionResolverError {
    #[error(transparent)]
    OtherError(anyhow::Error),
    #[error("extension is not a message: {0}")]
    ExtensionIsNotMessage(String),
    #[error("unknown field name: {0}")]
    UnknownFieldName(String),
    #[error("wrong extension type: option {0} extendee {1} expected extendee {2}")]
    WrongExtensionType(String, String, String),
    #[error("extension not found: {0}")]
    ExtensionNotFound(String),
    #[error("unknown enum value: {0}")]
    UnknownEnumValue(String),
    #[error("unsupported extension type: {0} {1} {2}")]
    UnsupportedExtensionType(String, String, model::ProtobufConstant),
    #[error("builtin option {0} not found for options {1}")]
    BuiltinOptionNotFound(String, String),
    #[error("builtin option {0} points to a non-singular field of {1}")]
    BuiltinOptionPointsToNonSingularField(String, String),
    #[error("incorrect string literal: {0}")]
    StrLitDecodeError(#[source] StrLitDecodeError),
    #[error("wrong option type, expecting {0}, got `{1}`")]
    WrongOptionType(&'static str, String),
    #[error("Message field requires a message constant")]
    MessageFieldRequiresMessageConstant,
    #[error("message not found by name {0}")]
    MessageNotFound(ProtobufAbsPath),
    #[error("message not found by name {0}")]
    MessageFoundMoreThanOnce(ProtobufAbsPath),
}

#[derive(Clone)]
enum LookupScope2 {
    File(FileDescriptor),
    Message(MessageDescriptor, ProtobufAbsPath),
}

impl LookupScope2 {
    fn current_path(&self) -> ProtobufAbsPath {
        match self {
            LookupScope2::File(f) => ProtobufAbsPath::package_from_file_descriptor(f),
            LookupScope2::Message(_, p) => p.clone(),
        }
    }

    fn messages(&self) -> Vec<MessageDescriptor> {
        match self {
            LookupScope2::File(file) => file.messages().collect(),
            LookupScope2::Message(message, _) => message.nested_messages().collect(),
        }
    }

    fn down(&self, name: &ProtobufIdentRef) -> Option<LookupScope2> {
        match self.messages().iter().find(|m| m.name() == name.as_str()) {
            Some(m) => {
                let mut path = self.current_path();
                path.push_simple(name);
                Some(LookupScope2::Message(m.clone(), path))
            }
            None => None,
        }
    }

    fn extensions(&self) -> Vec<FieldDescriptor> {
        match self {
            LookupScope2::File(f) => f.extensions().collect(),
            LookupScope2::Message(m, _) => m.extensions().collect(),
        }
    }
}

#[derive(Clone)]
pub(crate) struct LookupScopeUnion2 {
    path: ProtobufAbsPath,
    scopes: Vec<LookupScope2>,
    partial_scopes: Vec<FileDescriptor>,
}

impl LookupScopeUnion2 {
    fn down(&self, name: &ProtobufIdentRef) -> LookupScopeUnion2 {
        let mut path: ProtobufAbsPath = self.path.clone();
        path.push_simple(name);

        let mut scopes: Vec<_> = self.scopes.iter().flat_map(|f| f.down(name)).collect();
        let mut partial_scopes = Vec::new();

        for partial_scope in &self.partial_scopes {
            let package = ProtobufAbsPath::package_from_file_descriptor(partial_scope);
            if package.as_ref() == path.as_ref() {
                scopes.push(LookupScope2::File(partial_scope.clone()));
            } else if package.starts_with(&path) {
                partial_scopes.push(partial_scope.clone());
            }
        }
        LookupScopeUnion2 {
            path,
            scopes,
            partial_scopes,
        }
    }

    fn lookup(&self, path: &ProtobufRelPath) -> LookupScopeUnion2 {
        let mut scope = self.clone();
        for c in path.components() {
            scope = scope.down(c);
        }
        scope
    }

    fn extensions(&self) -> Vec<FieldDescriptor> {
        self.scopes.iter().flat_map(|s| s.extensions()).collect()
    }

    fn as_message(&self) -> anyhow::Result<MessageDescriptor> {
        let mut messages: Vec<MessageDescriptor> = self
            .scopes
            .iter()
            .filter_map(|s| match s {
                LookupScope2::Message(m, _) => Some(m.clone()),
                _ => None,
            })
            .collect();
        let message = match messages.pop() {
            Some(m) => m,
            None => return Err(OptionResolverError::MessageNotFound(self.path.clone()).into()),
        };
        if !messages.is_empty() {
            return Err(OptionResolverError::MessageFoundMoreThanOnce(self.path.clone()).into());
        }
        Ok(message)
    }
}

pub(crate) trait ProtobufOptions {
    fn by_name(&self, name: &str) -> Option<&model::ProtobufConstant>;

    fn by_name_bool(&self, name: &str) -> anyhow::Result<Option<bool>> {
        match self.by_name(name) {
            Some(model::ProtobufConstant::Bool(b)) => Ok(Some(*b)),
            Some(c) => Err(OptionResolverError::WrongOptionType("bool", c.to_string()).into()),
            None => Ok(None),
        }
    }

    fn by_name_string(&self, name: &str) -> anyhow::Result<Option<String>> {
        match self.by_name(name) {
            Some(model::ProtobufConstant::String(s)) => s
                .decode_utf8()
                .map(Some)
                .map_err(|e| OptionResolverError::StrLitDecodeError(e).into()),
            Some(c) => Err(OptionResolverError::WrongOptionType("string", c.to_string()).into()),
            None => Ok(None),
        }
    }
}

impl<'a> ProtobufOptions for &'a [model::ProtobufOption] {
    fn by_name(&self, name: &str) -> Option<&model::ProtobufConstant> {
        let option_name = ProtobufOptionName::simple(name);
        for model::ProtobufOption { name, value } in *self {
            if name == &option_name {
                return Some(&value);
            }
        }
        None
    }
}

pub(crate) struct OptionResoler<'a> {
    pub(crate) resolver: &'a Resolver<'a>,
    pub(crate) descriptor_without_options: FileDescriptor,
}

impl<'a> OptionResoler<'a> {
    fn all_files(&self) -> Vec<FileDescriptor> {
        let mut files = Vec::new();
        files.push(self.descriptor_without_options.clone());
        files.extend(
            self.resolver
                .type_resolver
                .deps
                .iter()
                .map(|p| p.descriptor.clone()),
        );
        files
    }

    fn root_scope(&self) -> LookupScopeUnion2 {
        let (scopes, partial_scopes) = self
            .all_files()
            .into_iter()
            .partition::<Vec<_>, _>(|f| ProtobufAbsPath::package_from_file_descriptor(f).is_root());
        LookupScopeUnion2 {
            path: ProtobufAbsPath::root(),
            scopes: scopes.into_iter().map(LookupScope2::File).collect(),
            partial_scopes,
        }
    }

    fn lookup(&self, path: &ProtobufAbsPath) -> LookupScopeUnion2 {
        self.root_scope().lookup(&path.to_root_rel())
    }

    fn find_message_by_abs_name(
        &self,
        path: &ProtobufAbsPath,
    ) -> anyhow::Result<MessageDescriptor> {
        let scope = self.lookup(path);
        scope.as_message()
    }

    fn scope_resolved_candidates_rel(
        scope: &ProtobufAbsPathRef,
        rel: &ProtobufRelPathRef,
    ) -> Vec<ProtobufAbsPath> {
        scope
            .self_and_parents()
            .into_iter()
            .map(|a| {
                let mut a = a.to_owned();
                a.push_relative(rel);
                a
            })
            .collect()
    }

    fn scope_resolved_candidates(
        scope: &ProtobufAbsPathRef,
        path: &ProtobufPath,
    ) -> Vec<ProtobufAbsPath> {
        match path {
            ProtobufPath::Abs(p) => vec![p.clone()],
            ProtobufPath::Rel(p) => Self::scope_resolved_candidates_rel(scope, p),
        }
    }

    fn find_extension_by_abs_path(
        &self,
        path: &ProtobufAbsPathRef,
    ) -> anyhow::Result<Option<FieldDescriptor>> {
        let mut path = path.to_owned();
        let extension = path.pop().unwrap();

        let scope = self.lookup(&path);

        for ext in scope.extensions() {
            if ext.name() == extension.get() {
                return Ok(Some(ext.clone()));
            }
        }

        Ok(None)
    }

    fn find_extension_by_path(
        &self,
        scope: &ProtobufAbsPathRef,
        path: &ProtobufPath,
    ) -> anyhow::Result<FieldDescriptor> {
        for candidate in Self::scope_resolved_candidates(scope, path) {
            if let Some(e) = self.find_extension_by_abs_path(&candidate)? {
                return Ok(e);
            }
        }

        Err(OptionResolverError::ExtensionNotFound(path.to_string()).into())
    }

    fn ext_resolve_field_ext(
        &self,
        scope: &ProtobufAbsPathRef,
        message: &MessageDescriptor,
        field_name: &ProtobufPath,
    ) -> anyhow::Result<FieldDescriptor> {
        let expected_extendee = ProtobufAbsPath::from_message(message);
        let field = self.find_extension_by_path(scope, field_name)?;
        if ProtobufAbsPath::new(field.proto().extendee()) != expected_extendee {
            return Err(OptionResolverError::WrongExtensionType(
                format!("{}", field_name),
                format!("{}", field.proto().extendee()),
                format!("{}", expected_extendee),
            )
            .into());
        }

        Ok(field)
    }

    fn ext_resolve_field(
        &self,
        scope: &ProtobufAbsPathRef,
        message: &MessageDescriptor,
        field: &ProtobufOptionNamePart,
    ) -> anyhow::Result<FieldDescriptor> {
        match field {
            ProtobufOptionNamePart::Direct(field) => match message.field_by_name(field.get()) {
                Some(field) => Ok(field),
                None => Err(OptionResolverError::UnknownFieldName(field.to_string()).into()),
            },
            ProtobufOptionNamePart::Ext(field) => {
                Ok(self.ext_resolve_field_ext(scope, message, field)?)
            }
        }
    }

    fn custom_option_ext_step(
        &self,
        scope: &ProtobufAbsPathRef,
        options_type: &MessageDescriptor,
        options: &mut UnknownFields,
        option_name: &ProtobufOptionNamePart,
        option_name_rem: &[ProtobufOptionNamePart],
        option_value: &ProtobufConstant,
    ) -> anyhow::Result<()> {
        let field = self.ext_resolve_field(scope, options_type, option_name)?;

        let field_type = TypeResolved::from_field(field.proto());

        match option_name_rem.split_first() {
            Some((first, rem)) => {
                match field_type {
                    TypeResolved::Message(message_name) => {
                        let m = self.find_message_by_abs_name(&message_name)?;
                        let mut unknown_fields = UnknownFields::new();
                        self.custom_option_ext_step(
                            scope,
                            &m,
                            &mut unknown_fields,
                            first,
                            rem,
                            option_value,
                        )?;
                        options.add_length_delimited(
                            field.proto().number() as u32,
                            unknown_fields.write_to_bytes(),
                        );
                        Ok(())
                    }
                    TypeResolved::Group(..) => {
                        // TODO: implement
                        Ok(())
                    }
                    _ => Err(OptionResolverError::ExtensionIsNotMessage(format!(
                        "scope: {}, option name: {}",
                        scope, option_name
                    ))
                    .into()),
                }
            }
            None => {
                let value = match self.option_value_to_unknown_value(
                    &field_type,
                    option_value,
                    &format!("{}", option_name),
                ) {
                    Ok(value) => value,
                    Err(e) => {
                        let e = e.context(format!(
                            "parsing custom option `{}` value `{}` at `{}`",
                            option_name, option_value, scope
                        ));
                        return Err(e.into());
                    }
                };

                options.add_value(field.proto().number() as u32, value);
                Ok(())
            }
        }
    }

    fn custom_option_ext<M>(
        &self,
        scope: &ProtobufAbsPathRef,
        options: &mut M,
        option_name: &ProtobufOptionNameExt,
        option_value: &ProtobufConstant,
    ) -> anyhow::Result<()>
    where
        M: MessageFull,
    {
        self.custom_option_ext_step(
            scope,
            &M::descriptor(),
            options.mut_unknown_fields(),
            &option_name.0[0],
            &option_name.0[1..],
            option_value,
        )
    }

    fn fixed32(
        v: impl TryInto<u32, Error = impl std::error::Error + Send + Sync + 'static>,
    ) -> anyhow::Result<UnknownValue> {
        Ok(UnknownValue::Fixed32(v.try_into()?))
    }

    fn sfixed32(
        v: impl TryInto<i32, Error = impl std::error::Error + Send + Sync + 'static>,
    ) -> anyhow::Result<UnknownValue> {
        Ok(UnknownValue::sfixed32(v.try_into()?))
    }

    fn fixed64(
        v: impl TryInto<u64, Error = impl std::error::Error + Send + Sync + 'static>,
    ) -> anyhow::Result<UnknownValue> {
        Ok(UnknownValue::Fixed64(v.try_into()?))
    }

    fn sfixed64(
        v: impl TryInto<i64, Error = impl std::error::Error + Send + Sync + 'static>,
    ) -> anyhow::Result<UnknownValue> {
        Ok(UnknownValue::sfixed64(v.try_into()?))
    }

    fn int32(
        v: impl TryInto<i32, Error = impl std::error::Error + Send + Sync + 'static>,
    ) -> anyhow::Result<UnknownValue> {
        Ok(UnknownValue::int32(v.try_into()?))
    }

    fn int64(
        v: impl TryInto<i64, Error = impl std::error::Error + Send + Sync + 'static>,
    ) -> anyhow::Result<UnknownValue> {
        Ok(UnknownValue::int64(v.try_into()?))
    }

    fn uint32(
        v: impl TryInto<u32, Error = impl std::error::Error + Send + Sync + 'static>,
    ) -> anyhow::Result<UnknownValue> {
        Ok(UnknownValue::Varint(v.try_into()? as u64))
    }

    fn uint64(
        v: impl TryInto<u64, Error = impl std::error::Error + Send + Sync + 'static>,
    ) -> anyhow::Result<UnknownValue> {
        Ok(UnknownValue::Varint(v.try_into()?))
    }

    fn sint32(
        v: impl TryInto<i32, Error = impl std::error::Error + Send + Sync + 'static>,
    ) -> anyhow::Result<UnknownValue> {
        Ok(UnknownValue::sint32(v.try_into()?))
    }

    fn sint64(
        v: impl TryInto<i64, Error = impl std::error::Error + Send + Sync + 'static>,
    ) -> anyhow::Result<UnknownValue> {
        Ok(UnknownValue::sint64(v.try_into()?))
    }

    fn option_value_message_to_unknown_value(
        &self,
        field_type: &TypeResolved,
        value: &ProtobufConstantMessage,
        option_name_for_diag: &str,
    ) -> anyhow::Result<UnknownValue> {
        match &field_type {
            TypeResolved::Message(ma) => {
                let m = self
                    .resolver
                    .find_message_by_abs_name(ma)
                    .map_err(OptionResolverError::OtherError)?
                    .t;
                let mut unknown_fields = UnknownFields::new();
                for (n, v) in &value.fields {
                    match n {
                        ProtobufConstantMessageFieldName::Regular(n) => {
                            let f = match m.field_by_name(n.as_str()) {
                                Some(f) => f,
                                None => {
                                    return Err(
                                        OptionResolverError::UnknownFieldName(n.clone()).into()
                                    )
                                }
                            };
                            let u = self
                                .option_value_field_to_unknown_value(
                                    ma,
                                    v,
                                    n,
                                    &f.typ,
                                    option_name_for_diag,
                                )
                                .map_err(OptionResolverError::OtherError)?;
                            unknown_fields.add_value(f.number as u32, u);
                        }
                        ProtobufConstantMessageFieldName::Extension(..) => {
                            // TODO: implement extension fields in constants
                        }
                        ProtobufConstantMessageFieldName::AnyTypeUrl(..) => {
                            // TODO: implement any type url in constants
                        }
                    }
                }
                Ok(UnknownValue::LengthDelimited(
                    unknown_fields.write_to_bytes(),
                ))
            }
            _ => Err(OptionResolverError::MessageFieldRequiresMessageConstant.into()),
        }
    }

    fn option_value_to_unknown_value(
        &self,
        field_type: &TypeResolved,
        value: &model::ProtobufConstant,
        option_name_for_diag: &str,
    ) -> anyhow::Result<UnknownValue> {
        match value {
            &model::ProtobufConstant::Bool(b) => {
                if field_type != &TypeResolved::Bool {
                    {}
                } else {
                    return Ok(UnknownValue::Varint(if b { 1 } else { 0 }));
                }
            }
            &model::ProtobufConstant::U64(v) => match field_type {
                TypeResolved::Fixed64 => return Self::fixed64(v),
                TypeResolved::Sfixed64 => return Self::sfixed64(v),
                TypeResolved::Fixed32 => return Self::fixed32(v),
                TypeResolved::Sfixed32 => return Self::sfixed32(v),
                TypeResolved::Int32 => return Self::int32(v),
                TypeResolved::Int64 => return Self::int64(v),
                TypeResolved::Uint64 => return Self::uint64(v),
                TypeResolved::Uint32 => return Self::uint32(v),
                TypeResolved::Sint64 => return Self::sint64(v),
                TypeResolved::Sint32 => return Self::sint32(v),
                TypeResolved::Float => return Ok(UnknownValue::float(v as f32)),
                TypeResolved::Double => return Ok(UnknownValue::double(v as f64)),
                _ => {}
            },
            &model::ProtobufConstant::I64(v) => match field_type {
                TypeResolved::Fixed64 => return Self::fixed64(v),
                TypeResolved::Sfixed64 => return Self::sfixed64(v),
                TypeResolved::Fixed32 => return Self::fixed32(v),
                TypeResolved::Sfixed32 => return Self::sfixed32(v),
                TypeResolved::Int64 => return Self::int64(v),
                TypeResolved::Int32 => return Self::int32(v),
                TypeResolved::Uint64 => return Self::uint64(v),
                TypeResolved::Uint32 => return Self::uint32(v),
                TypeResolved::Sint64 => return Self::sint64(v),
                TypeResolved::Sint32 => return Self::sint32(v),
                TypeResolved::Float => return Ok(UnknownValue::float(v as f32)),
                TypeResolved::Double => return Ok(UnknownValue::double(v as f64)),
                _ => {}
            },
            &model::ProtobufConstant::F64(f) => match field_type {
                TypeResolved::Float => return Ok(UnknownValue::float(f as f32)),
                TypeResolved::Double => return Ok(UnknownValue::double(f)),
                TypeResolved::Fixed32 => return Ok(UnknownValue::Fixed32(f as u32)),
                TypeResolved::Fixed64 => return Ok(UnknownValue::Fixed64(f as u64)),
                TypeResolved::Sfixed32 => return Ok(UnknownValue::sfixed32(f as i32)),
                TypeResolved::Sfixed64 => return Ok(UnknownValue::sfixed64(f as i64)),
                TypeResolved::Int32 | TypeResolved::Int64 => {
                    return Ok(UnknownValue::int64(f as i64))
                }
                TypeResolved::Uint32 | TypeResolved::Uint64 => {
                    return Ok(UnknownValue::Varint(f as u64))
                }
                TypeResolved::Sint64 => return Ok(UnknownValue::sint64(f as i64)),
                TypeResolved::Sint32 => return Ok(UnknownValue::sint32(f as i32)),
                _ => {}
            },
            &model::ProtobufConstant::String(ref s) => match field_type {
                TypeResolved::String => {
                    return Ok(UnknownValue::LengthDelimited(s.decode_utf8()?.into_bytes()))
                }
                TypeResolved::Bytes => return Ok(UnknownValue::LengthDelimited(s.decode_bytes()?)),
                _ => {}
            },
            model::ProtobufConstant::Ident(ident) => match &field_type {
                TypeResolved::Enum(e) => {
                    let e = self
                        .resolver
                        .find_enum_by_abs_name(e)
                        .map_err(OptionResolverError::OtherError)?;
                    let n = match e
                        .values
                        .iter()
                        .find(|v| v.name == format!("{}", ident))
                        .map(|v| v.number)
                    {
                        Some(n) => n,
                        None => {
                            return Err(
                                OptionResolverError::UnknownEnumValue(ident.to_string()).into()
                            )
                        }
                    };
                    return Ok(UnknownValue::int32(n));
                }
                _ => {}
            },
            model::ProtobufConstant::Message(mo) => {
                return self.option_value_message_to_unknown_value(
                    &field_type,
                    mo,
                    option_name_for_diag,
                );
            }
        };

        Err(match field_type {
            _ => OptionResolverError::UnsupportedExtensionType(
                option_name_for_diag.to_owned(),
                format!("{:?}", field_type),
                value.clone(),
            )
            .into(),
        })
    }

    fn option_value_field_to_unknown_value(
        &self,
        scope: &ProtobufAbsPath,
        value: &model::ProtobufConstant,
        name: &str,
        field_type: &model::FieldType,
        option_name_for_diag: &str,
    ) -> anyhow::Result<UnknownValue> {
        let field_type = self.resolver.field_type(&scope, name, field_type)?;
        Ok(self
            .option_value_to_unknown_value(&field_type, value, option_name_for_diag)
            .context("parsing custom option value")?)
    }

    fn custom_option_builtin<M>(
        &self,
        _scope: &ProtobufAbsPathRef,
        options: &mut M,
        option: &ProtobufIdent,
        option_value: &ProtobufConstant,
    ) -> anyhow::Result<()>
    where
        M: MessageFull,
    {
        if M::descriptor().full_name() == "google.protobuf.FieldOptions" {
            if option.get() == "default" || option.get() == "json_name" {
                // some options are written to non-options message and handled outside
                return Ok(());
            }
        }
        match M::descriptor().field_by_name(option.get()) {
            Some(field) => {
                if field.is_repeated_or_map() {
                    return Err(OptionResolverError::BuiltinOptionPointsToNonSingularField(
                        M::descriptor().full_name().to_owned(),
                        option.get().to_owned(),
                    )
                    .into());
                }

                field.set_singular_field(
                    options,
                    option_value.as_type(field.singular_runtime_type())?,
                );
                return Ok(());
            }
            None => {
                return Err(OptionResolverError::BuiltinOptionNotFound(
                    M::descriptor().full_name().to_owned(),
                    option.get().to_owned(),
                )
                .into())
            }
        }
    }

    fn custom_option<M>(
        &self,
        scope: &ProtobufAbsPathRef,
        options: &mut M,
        option: &model::ProtobufOption,
    ) -> anyhow::Result<()>
    where
        M: MessageFull,
    {
        match &option.name {
            ProtobufOptionName::Builtin(simple) => {
                self.custom_option_builtin(scope, options, simple, &option.value)
            }
            ProtobufOptionName::Ext(e) => self.custom_option_ext(scope, options, e, &option.value),
        }
    }

    fn custom_options<M>(
        &self,
        scope: &ProtobufAbsPathRef,
        input: &[model::ProtobufOption],
    ) -> anyhow::Result<Option<M>>
    where
        M: MessageFull,
    {
        if input.is_empty() {
            // Empty options do not have to represented to unset message field,
            // but this is what Google's parser does.
            return Ok(None);
        }

        let mut options = M::new();

        for option in input {
            self.custom_option(scope, &mut options, option)?;
        }
        Ok(Some(options))
    }

    fn file_options(
        &self,
        scope: &ProtobufAbsPath,
        input: &[model::ProtobufOption],
    ) -> anyhow::Result<Option<protobuf::descriptor::FileOptions>> {
        self.custom_options(scope, input)
    }

    fn enum_options(
        &self,
        scope: &ProtobufAbsPathRef,
        input: &[model::ProtobufOption],
    ) -> anyhow::Result<Option<protobuf::descriptor::EnumOptions>> {
        self.custom_options(scope, input)
    }

    fn enum_value_options(
        &self,
        scope: &ProtobufAbsPathRef,
        input: &[model::ProtobufOption],
    ) -> anyhow::Result<Option<protobuf::descriptor::EnumValueOptions>> {
        self.custom_options(scope, input)
    }

    fn field_options(
        &self,
        scope: &ProtobufAbsPathRef,
        input: &[model::ProtobufOption],
    ) -> anyhow::Result<Option<protobuf::descriptor::FieldOptions>> {
        self.custom_options(scope, input)
    }

    fn message_options(
        &self,
        scope: &ProtobufAbsPathRef,
        input: &[model::ProtobufOption],
    ) -> anyhow::Result<Option<protobuf::descriptor::MessageOptions>> {
        self.custom_options(scope, input)
    }

    fn oneof_options(
        &self,
        scope: &ProtobufAbsPathRef,
        input: &[model::ProtobufOption],
    ) -> anyhow::Result<Option<protobuf::descriptor::OneofOptions>> {
        self.custom_options(scope, input)
    }

    fn method(
        &self,
        method_proto: &mut MethodDescriptorProto,
        method_model: &model::Method,
    ) -> anyhow::Result<()> {
        method_proto.options = self.service_method_options(&method_model.options)?.into();
        Ok(())
    }

    fn service_options(
        &self,
        input: &[model::ProtobufOption],
    ) -> anyhow::Result<Option<protobuf::descriptor::ServiceOptions>> {
        self.custom_options(&self.resolver.current_file.package, input)
    }

    fn service_method_options(
        &self,
        input: &[model::ProtobufOption],
    ) -> anyhow::Result<Option<protobuf::descriptor::MethodOptions>> {
        self.custom_options(&self.resolver.current_file.package, input)
    }

    fn service(
        &self,
        service_proto: &mut ServiceDescriptorProto,
        service_model: &WithLoc<model::Service>,
    ) -> anyhow::Result<()> {
        service_proto.options = self.service_options(&service_model.options)?.into();

        for service_method_model in &service_model.methods {
            let mut method_proto = service_proto
                .method
                .iter_mut()
                .find(|method| method.name() == service_method_model.name)
                .unwrap();
            self.method(&mut method_proto, service_method_model)?;
        }

        Ok(())
    }

    fn enum_value(
        &self,
        scope: &ProtobufAbsPathRef,
        enum_value_proto: &mut EnumValueDescriptorProto,
        enum_value_model: &model::EnumValue,
    ) -> anyhow::Result<()> {
        enum_value_proto.options = self
            .enum_value_options(scope, &enum_value_model.options)?
            .into();
        Ok(())
    }

    fn enumeration(
        &self,
        scope: &ProtobufAbsPathRef,
        enum_proto: &mut EnumDescriptorProto,
        enum_model: &WithLoc<model::Enumeration>,
    ) -> anyhow::Result<()> {
        enum_proto.options = self.enum_options(scope, &enum_model.options)?.into();

        for enum_value_model in &enum_model.values {
            let mut enum_value_proto = enum_proto
                .value
                .iter_mut()
                .find(|v| v.name() == enum_value_model.name)
                .unwrap();
            self.enum_value(scope, &mut enum_value_proto, enum_value_model)?;
        }

        Ok(())
    }

    fn oneof(
        &self,
        scope: &ProtobufAbsPathRef,
        oneof_proto: &mut OneofDescriptorProto,
        oneof_model: &model::OneOf,
    ) -> anyhow::Result<()> {
        oneof_proto.options = self.oneof_options(scope, &oneof_model.options)?.into();
        Ok(())
    }

    fn field(
        &self,
        scope: &ProtobufAbsPathRef,
        field_proto: &mut FieldDescriptorProto,
        field_model: &model::Field,
    ) -> anyhow::Result<()> {
        field_proto.options = self.field_options(scope, &field_model.options)?.into();
        Ok(())
    }

    fn message(
        &self,
        scope: &ProtobufAbsPathRef,
        message_proto: &mut DescriptorProto,
        message_model: &WithLoc<model::Message>,
    ) -> anyhow::Result<()> {
        message_proto.options = self.message_options(scope, &message_model.options)?.into();

        let mut nested_scope = scope.to_owned();
        nested_scope.push_simple(ProtobufIdentRef::new(&message_proto.name()));

        for field_model in &message_model.regular_fields_including_in_oneofs() {
            let mut field_proto = message_proto
                .field
                .iter_mut()
                .find(|field| field.name() == field_model.name)
                .unwrap();
            self.field(&nested_scope, &mut field_proto, field_model)?;
        }
        for field_model in &message_model.extensions {
            let field_proto = message_proto
                .extension
                .iter_mut()
                .find(|field| field.name() == field_model.field.name)
                .unwrap();
            self.field(&nested_scope, field_proto, &field_model.field)?;
        }

        for nested_message_model in &message_model.messages {
            let nested_message_proto = message_proto
                .nested_type
                .iter_mut()
                .find(|nested_message_proto| {
                    nested_message_proto.name() == nested_message_model.name
                })
                .unwrap();
            self.message(&nested_scope, nested_message_proto, nested_message_model)?;
        }

        for nested_enum_model in &message_model.enums {
            let nested_enum_proto = message_proto
                .enum_type
                .iter_mut()
                .find(|nested_enum_proto| nested_enum_proto.name() == nested_enum_model.name)
                .unwrap();
            self.enumeration(&nested_scope, nested_enum_proto, nested_enum_model)?;
        }

        for oneof_model in &message_model.oneofs() {
            let oneof_proto = message_proto
                .oneof_decl
                .iter_mut()
                .find(|oneof_proto| oneof_proto.name() == oneof_model.name)
                .unwrap();
            self.oneof(&nested_scope, oneof_proto, oneof_model)?;
        }

        Ok(())
    }

    pub(crate) fn file(&self, output: &mut FileDescriptorProto) -> anyhow::Result<()> {
        // TODO: use it to resolve messages.
        let _ = &self.descriptor_without_options;

        for message_model in &self.resolver.current_file.messages {
            let message_proto = output
                .message_type
                .iter_mut()
                .find(|m| m.name() == message_model.name)
                .unwrap();
            self.message(
                &self.resolver.current_file.package,
                message_proto,
                message_model,
            )?;
        }

        for enum_model in &self.resolver.current_file.enums {
            let enum_proto = output
                .enum_type
                .iter_mut()
                .find(|e| e.name() == enum_model.name)
                .unwrap();
            self.enumeration(&self.resolver.current_file.package, enum_proto, enum_model)?;
        }

        for service_proto in &mut output.service {
            let service_model = self
                .resolver
                .current_file
                .services
                .iter()
                .find(|s| s.name == service_proto.name())
                .unwrap();
            self.service(service_proto, service_model)?;
        }

        for extension_model in &self.resolver.current_file.extensions {
            let extension_proto = output
                .extension
                .iter_mut()
                .find(|e| e.name() == extension_model.field.name)
                .unwrap();
            self.field(
                &self.resolver.current_file.package,
                extension_proto,
                &extension_model.field,
            )?;
        }

        output.options = self
            .file_options(
                &self.resolver.current_file.package,
                &self.resolver.current_file.options,
            )?
            .into();

        Ok(())
    }
}

'''
'''--- protobuf-parse/src/pure/convert/type_resolver.rs ---
use std::iter;

use crate::model;
use crate::model::WithLoc;
use crate::protobuf_path::ProtobufPath;
use crate::pure::convert::WithFullName;
use crate::FileDescriptorPair;
use crate::ProtobufAbsPath;
use crate::ProtobufAbsPathRef;
use crate::ProtobufIdent;
use crate::ProtobufIdentRef;
use crate::ProtobufRelPath;
use crate::ProtobufRelPathRef;

#[derive(thiserror::Error, Debug)]
enum TypeResolverError {
    #[error("object is not found by path: {0}")]
    NotFoundByAbsPath(ProtobufAbsPath),
    #[error("object is not found by path `{0}` in scope `{1}`")]
    NotFoundByRelPath(ProtobufRelPath, ProtobufAbsPath),
}

pub(crate) enum MessageOrEnum<'a> {
    Message(&'a model::Message),
    Enum(&'a model::Enumeration),
}

impl MessageOrEnum<'_> {
    fn _descriptor_type(&self) -> protobuf::descriptor::field_descriptor_proto::Type {
        match *self {
            MessageOrEnum::Message(..) => {
                protobuf::descriptor::field_descriptor_proto::Type::TYPE_MESSAGE
            }
            MessageOrEnum::Enum(..) => {
                protobuf::descriptor::field_descriptor_proto::Type::TYPE_ENUM
            }
        }
    }
}

#[derive(Clone)]
enum LookupScope<'a> {
    File(&'a model::FileDescriptor),
    Message(&'a model::Message, ProtobufAbsPath),
}

impl<'a> LookupScope<'a> {
    fn current_path(&self) -> ProtobufAbsPath {
        match self {
            LookupScope::File(f) => f.package.clone(),
            LookupScope::Message(_, p) => p.clone(),
        }
    }

    fn messages(&self) -> &'a [model::WithLoc<model::Message>] {
        match self {
            &LookupScope::File(file) => &file.messages,
            &LookupScope::Message(messasge, _) => &messasge.messages,
        }
    }

    fn find_message(&self, simple_name: &ProtobufIdentRef) -> Option<&'a model::Message> {
        self.messages()
            .into_iter()
            .find(|m| m.t.name == simple_name.as_str())
            .map(|m| &m.t)
    }

    fn enums(&self) -> &'a [WithLoc<model::Enumeration>] {
        match self {
            &LookupScope::File(file) => &file.enums,
            &LookupScope::Message(messasge, _) => &messasge.enums,
        }
    }

    fn members(&self) -> Vec<(ProtobufIdent, MessageOrEnum<'a>)> {
        let mut r = Vec::new();
        r.extend(
            self.enums()
                .into_iter()
                .map(|e| (ProtobufIdent::from(&e.name[..]), MessageOrEnum::Enum(e))),
        );
        r.extend(self.messages().into_iter().map(|m| {
            (
                ProtobufIdent::from(&m.t.name[..]),
                MessageOrEnum::Message(&m.t),
            )
        }));
        r
    }

    fn find_member(&self, simple_name: &ProtobufIdentRef) -> Option<MessageOrEnum<'a>> {
        self.members()
            .into_iter()
            .filter_map(|(member_name, message_or_enum)| {
                if member_name.as_ref() == simple_name {
                    Some(message_or_enum)
                } else {
                    None
                }
            })
            .next()
    }

    pub(crate) fn find_message_or_enum(
        &self,
        path: &ProtobufRelPathRef,
    ) -> Option<WithFullName<MessageOrEnum<'a>>> {
        let current_path = self.current_path();
        let (first, rem) = match path.split_first_rem() {
            Some(x) => x,
            None => return None,
        };

        if rem.is_empty() {
            match self.find_member(first) {
                Some(message_or_enum) => {
                    let mut result_path = current_path.clone();
                    result_path.push_simple(first);
                    Some(WithFullName {
                        full_name: result_path,
                        t: message_or_enum,
                    })
                }
                None => None,
            }
        } else {
            match self.find_message(first) {
                Some(message) => {
                    let mut message_path = current_path.clone();
                    message_path.push_simple(ProtobufIdentRef::new(&message.name));
                    let message_scope = LookupScope::Message(message, message_path);
                    message_scope.find_message_or_enum(rem)
                }
                None => None,
            }
        }
    }
}

pub(crate) struct TypeResolver<'a> {
    pub(crate) current_file: &'a model::FileDescriptor,
    pub(crate) deps: &'a [FileDescriptorPair],
}

impl<'a> TypeResolver<'a> {
    pub(crate) fn all_files(&self) -> Vec<&'a model::FileDescriptor> {
        iter::once(self.current_file)
            .chain(self.deps.iter().map(|p| &p.parsed))
            .collect()
    }

    pub(crate) fn find_message_or_enum_by_abs_name(
        &self,
        absolute_path: &ProtobufAbsPath,
    ) -> anyhow::Result<WithFullName<MessageOrEnum<'a>>> {
        for file in self.all_files() {
            if let Some(relative) = absolute_path.remove_prefix(&file.package) {
                if let Some(w) = LookupScope::File(file).find_message_or_enum(&relative) {
                    return Ok(w);
                }
            }
        }

        return Err(TypeResolverError::NotFoundByAbsPath(absolute_path.clone()).into());
    }

    pub(crate) fn resolve_message_or_enum(
        &self,
        scope: &ProtobufAbsPathRef,
        name: &ProtobufPath,
    ) -> anyhow::Result<WithFullName<MessageOrEnum>> {
        match name {
            ProtobufPath::Abs(name) => Ok(self.find_message_or_enum_by_abs_name(&name)?),
            ProtobufPath::Rel(name) => {
                // find message or enum in current package
                for p in scope.self_and_parents() {
                    let mut fq = p.to_owned();
                    fq.push_relative(&name);
                    if let Ok(me) = self.find_message_or_enum_by_abs_name(&fq) {
                        return Ok(me);
                    }
                }

                Err(TypeResolverError::NotFoundByRelPath(name.clone(), scope.to_owned()).into())
            }
        }
    }
}

'''
'''--- protobuf-parse/src/pure/mod.rs ---
//! Pure rust `.proto` file parser.

pub(crate) mod convert;
pub(crate) mod model;
pub(crate) mod parse_and_typecheck;
pub(crate) mod parse_dependencies;
mod parser;

pub use parse_and_typecheck::parse_and_typecheck_custom;
pub use parse_dependencies::*;

'''
'''--- protobuf-parse/src/pure/model.rs ---
//! A nom-based protobuf file parser
//!
//! This crate can be seen as a rust transcription of the
//! [descriptor.proto](https://github.com/google/protobuf/blob/master/src/google/protobuf/descriptor.proto) file

use std::fmt;
use std::fmt::Write;
use std::ops::Deref;

use indexmap::IndexMap;
use protobuf::reflect::ReflectValueBox;
use protobuf::reflect::RuntimeType;
use protobuf_support::lexer::float::format_protobuf_float;
use protobuf_support::lexer::loc::Loc;
use protobuf_support::lexer::str_lit::StrLit;

use crate::model;
use crate::proto_path::ProtoPathBuf;
use crate::protobuf_abs_path::ProtobufAbsPath;
use crate::protobuf_ident::ProtobufIdent;
use crate::protobuf_path::ProtobufPath;
use crate::pure::parser::Parser;
pub use crate::pure::parser::ParserErrorWithLocation;

#[derive(thiserror::Error, Debug)]
enum ModelError {
    #[error("cannot convert value `{1}` to type `{0}`")]
    InconvertibleValue(RuntimeType, model::ProtobufConstant),
}

#[derive(Debug, Clone, PartialEq)]
pub(crate) struct WithLoc<T> {
    pub loc: Loc,
    pub t: T,
}

impl<T> Deref for WithLoc<T> {
    type Target = T;

    fn deref(&self) -> &Self::Target {
        &self.t
    }
}

impl<T> WithLoc<T> {
    pub fn with_loc(loc: Loc) -> impl FnOnce(T) -> WithLoc<T> {
        move |t| WithLoc {
            t,
            loc: loc.clone(),
        }
    }
}

/// Protobuf syntax.
#[derive(Debug, Clone, Copy, Eq, PartialEq)]
pub(crate) enum Syntax {
    /// Protobuf syntax [2](https://developers.google.com/protocol-buffers/docs/proto) (default)
    Proto2,
    /// Protobuf syntax [3](https://developers.google.com/protocol-buffers/docs/proto3)
    Proto3,
}

impl Default for Syntax {
    fn default() -> Syntax {
        Syntax::Proto2
    }
}

/// A field rule
#[derive(Debug, Clone, Copy, Eq, PartialEq, Hash)]
pub(crate) enum Rule {
    /// A well-formed message can have zero or one of this field (but not more than one).
    Optional,
    /// This field can be repeated any number of times (including zero) in a well-formed message.
    /// The order of the repeated values will be preserved.
    Repeated,
    /// A well-formed message must have exactly one of this field.
    Required,
}

impl Rule {
    pub(crate) const ALL: [Rule; 3] = [Rule::Optional, Rule::Repeated, Rule::Required];

    pub(crate) const fn as_str(&self) -> &'static str {
        match self {
            Rule::Optional => "optional",
            Rule::Repeated => "repeated",
            Rule::Required => "required",
        }
    }
}

/// Protobuf group
#[derive(Debug, Clone, PartialEq)]
pub(crate) struct Group {
    /// Group name
    pub name: String,
    pub fields: Vec<WithLoc<Field>>,
}

/// Protobuf supported field types
#[derive(Debug, Clone, PartialEq)]
pub(crate) enum FieldType {
    /// Protobuf int32
    ///
    /// # Remarks
    ///
    /// Uses variable-length encoding. Inefficient for encoding negative numbers – if
    /// your field is likely to have negative values, use sint32 instead.
    Int32,
    /// Protobuf int64
    ///
    /// # Remarks
    ///
    /// Uses variable-length encoding. Inefficient for encoding negative numbers – if
    /// your field is likely to have negative values, use sint64 instead.
    Int64,
    /// Protobuf uint32
    ///
    /// # Remarks
    ///
    /// Uses variable-length encoding.
    Uint32,
    /// Protobuf uint64
    ///
    /// # Remarks
    ///
    /// Uses variable-length encoding.
    Uint64,
    /// Protobuf sint32
    ///
    /// # Remarks
    ///
    /// Uses ZigZag variable-length encoding. Signed int value. These more efficiently
    /// encode negative numbers than regular int32s.
    Sint32,
    /// Protobuf sint64
    ///
    /// # Remarks
    ///
    /// Uses ZigZag variable-length encoding. Signed int value. These more efficiently
    /// encode negative numbers than regular int32s.
    Sint64,
    /// Protobuf bool
    Bool,
    /// Protobuf fixed64
    ///
    /// # Remarks
    ///
    /// Always eight bytes. More efficient than uint64 if values are often greater than 2^56.
    Fixed64,
    /// Protobuf sfixed64
    ///
    /// # Remarks
    ///
    /// Always eight bytes.
    Sfixed64,
    /// Protobuf double
    Double,
    /// Protobuf string
    ///
    /// # Remarks
    ///
    /// A string must always contain UTF-8 encoded or 7-bit ASCII text.
    String,
    /// Protobuf bytes
    ///
    /// # Remarks
    ///
    /// May contain any arbitrary sequence of bytes.
    Bytes,
    /// Protobut fixed32
    ///
    /// # Remarks
    ///
    /// Always four bytes. More efficient than uint32 if values are often greater than 2^28.
    Fixed32,
    /// Protobut sfixed32
    ///
    /// # Remarks
    ///
    /// Always four bytes.
    Sfixed32,
    /// Protobut float
    Float,
    /// Protobuf message or enum (holds the name)
    MessageOrEnum(ProtobufPath),
    /// Protobut map
    Map(Box<(FieldType, FieldType)>),
    /// Protobuf group (deprecated)
    Group(Group),
}

/// A Protobuf Field
#[derive(Debug, Clone, PartialEq)]
pub(crate) struct Field {
    /// Field name
    pub name: String,
    /// Field `Rule`
    pub rule: Option<Rule>,
    /// Field type
    pub typ: FieldType,
    /// Tag number
    pub number: i32,
    /// Non-builtin options
    pub options: Vec<ProtobufOption>,
}

/// A Protobuf field of oneof group
#[derive(Debug, Clone, PartialEq)]
pub(crate) enum FieldOrOneOf {
    Field(WithLoc<Field>),
    OneOf(OneOf),
}

/// Extension range
#[derive(Default, Debug, Eq, PartialEq, Copy, Clone)]
pub(crate) struct FieldNumberRange {
    /// First number
    pub from: i32,
    /// Inclusive
    pub to: i32,
}

/// A protobuf message
#[derive(Debug, Clone, Default)]
pub(crate) struct Message {
    /// Message name
    pub name: String,
    /// Message fields and oneofs
    pub fields: Vec<WithLoc<FieldOrOneOf>>,
    /// Message reserved numbers
    ///
    /// TODO: use RangeInclusive once stable
    pub reserved_nums: Vec<FieldNumberRange>,
    /// Message reserved names
    pub reserved_names: Vec<String>,
    /// Nested messages
    pub messages: Vec<WithLoc<Message>>,
    /// Nested enums
    pub enums: Vec<WithLoc<Enumeration>>,
    /// Non-builtin options
    pub options: Vec<ProtobufOption>,
    /// Extension field numbers
    pub extension_ranges: Vec<FieldNumberRange>,
    /// Extensions
    pub extensions: Vec<WithLoc<Extension>>,
}

impl Message {
    pub fn regular_fields_including_in_oneofs(&self) -> Vec<&WithLoc<Field>> {
        self.fields
            .iter()
            .flat_map(|fo| match &fo.t {
                FieldOrOneOf::Field(f) => vec![f],
                FieldOrOneOf::OneOf(o) => o.fields.iter().collect(),
            })
            .collect()
    }

    /** Find a field by name. */
    pub fn field_by_name(&self, name: &str) -> Option<&Field> {
        self.regular_fields_including_in_oneofs()
            .iter()
            .find(|f| f.t.name == name)
            .map(|f| &f.t)
    }

    pub fn _nested_extensions(&self) -> Vec<&Group> {
        self.regular_fields_including_in_oneofs()
            .into_iter()
            .flat_map(|f| match &f.t.typ {
                FieldType::Group(g) => Some(g),
                _ => None,
            })
            .collect()
    }

    #[cfg(test)]
    pub fn regular_fields_for_test(&self) -> Vec<&Field> {
        self.fields
            .iter()
            .flat_map(|fo| match &fo.t {
                FieldOrOneOf::Field(f) => Some(&f.t),
                FieldOrOneOf::OneOf(_) => None,
            })
            .collect()
    }

    pub(crate) fn oneofs(&self) -> Vec<&OneOf> {
        self.fields
            .iter()
            .flat_map(|fo| match &fo.t {
                FieldOrOneOf::Field(_) => None,
                FieldOrOneOf::OneOf(o) => Some(o),
            })
            .collect()
    }
}

/// A protobuf enumeration field
#[derive(Debug, Clone)]
pub(crate) struct EnumValue {
    /// enum value name
    pub name: String,
    /// enum value number
    pub number: i32,
    /// enum value options
    pub options: Vec<ProtobufOption>,
}

/// A protobuf enumerator
#[derive(Debug, Clone)]
pub(crate) struct Enumeration {
    /// enum name
    pub name: String,
    /// enum values
    pub values: Vec<EnumValue>,
    /// enum options
    pub options: Vec<ProtobufOption>,
}

/// A OneOf
#[derive(Debug, Clone, Default, PartialEq)]
pub(crate) struct OneOf {
    /// OneOf name
    pub name: String,
    /// OneOf fields
    pub fields: Vec<WithLoc<Field>>,
    /// oneof options
    pub options: Vec<ProtobufOption>,
}

#[derive(Debug, Clone)]
pub(crate) struct Extension {
    /// Extend this type with field
    pub extendee: ProtobufPath,
    /// Extension field
    pub field: WithLoc<Field>,
}

/// Service method
#[derive(Debug, Clone)]
pub(crate) struct Method {
    /// Method name
    pub name: String,
    /// Input type
    pub input_type: ProtobufPath,
    /// Output type
    pub output_type: ProtobufPath,
    /// If this method is client streaming
    #[allow(dead_code)] // TODO
    pub client_streaming: bool,
    /// If this method is server streaming
    #[allow(dead_code)] // TODO
    pub server_streaming: bool,
    /// Method options
    pub options: Vec<ProtobufOption>,
}

/// Service definition
#[derive(Debug, Clone)]
pub(crate) struct Service {
    /// Service name
    pub name: String,
    pub methods: Vec<Method>,
    pub options: Vec<ProtobufOption>,
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub(crate) struct AnyTypeUrl {
    pub(crate) prefix: String,
    pub(crate) full_type_name: ProtobufPath,
}

impl fmt::Display for AnyTypeUrl {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}/{}", self.prefix, self.full_type_name)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub(crate) enum ProtobufConstantMessageFieldName {
    Regular(String),
    Extension(ProtobufPath),
    AnyTypeUrl(AnyTypeUrl),
}

impl fmt::Display for ProtobufConstantMessageFieldName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            ProtobufConstantMessageFieldName::Regular(s) => write!(f, "{}", s),
            ProtobufConstantMessageFieldName::Extension(p) => write!(f, "[{}]", p),
            ProtobufConstantMessageFieldName::AnyTypeUrl(a) => write!(f, "[{}]", a),
        }
    }
}

#[derive(Debug, Clone, PartialEq, Default)]
pub(crate) struct ProtobufConstantMessage {
    pub(crate) fields: IndexMap<ProtobufConstantMessageFieldName, ProtobufConstant>,
}

/// constant = fullIdent | ( [ "-" | "+" ] intLit ) | ( [ "-" | "+" ] floatLit ) |
//                 strLit | boolLit
#[derive(Debug, Clone, PartialEq)]
pub(crate) enum ProtobufConstant {
    U64(u64),
    I64(i64),
    F64(f64), // TODO: eq
    Bool(bool),
    Ident(ProtobufPath),
    String(StrLit),
    Message(ProtobufConstantMessage),
}

impl fmt::Display for ProtobufConstant {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            ProtobufConstant::U64(v) => write!(f, "{}", v),
            ProtobufConstant::I64(v) => write!(f, "{}", v),
            ProtobufConstant::F64(v) => write!(f, "{}", format_protobuf_float(*v)),
            ProtobufConstant::Bool(v) => write!(f, "{}", v),
            ProtobufConstant::Ident(v) => write!(f, "{}", v),
            ProtobufConstant::String(v) => write!(f, "{}", v),
            // TODO: text format explicitly
            ProtobufConstant::Message(v) => write!(f, "{:?}", v),
        }
    }
}

impl ProtobufConstantMessage {
    pub fn format(&self) -> String {
        let mut s = String::new();
        write!(s, "{{").unwrap();
        for (n, v) in &self.fields {
            match v {
                ProtobufConstant::Message(m) => write!(s, "{} {}", n, m.format()).unwrap(),
                v => write!(s, "{}: {}", n, v.format()).unwrap(),
            }
        }
        write!(s, "}}").unwrap();
        s
    }
}

impl ProtobufConstant {
    pub fn format(&self) -> String {
        match *self {
            ProtobufConstant::U64(u) => u.to_string(),
            ProtobufConstant::I64(i) => i.to_string(),
            ProtobufConstant::F64(f) => format_protobuf_float(f),
            ProtobufConstant::Bool(b) => b.to_string(),
            ProtobufConstant::Ident(ref i) => format!("{}", i),
            ProtobufConstant::String(ref s) => s.quoted(),
            ProtobufConstant::Message(ref s) => s.format(),
        }
    }

    /** Interpret .proto constant as an reflection value. */
    pub fn as_type(&self, ty: RuntimeType) -> anyhow::Result<ReflectValueBox> {
        match (self, &ty) {
            (ProtobufConstant::Ident(ident), RuntimeType::Enum(e)) => {
                if let Some(v) = e.value_by_name(&ident.to_string()) {
                    return Ok(ReflectValueBox::Enum(e.clone(), v.value()));
                }
            }
            (ProtobufConstant::Bool(b), RuntimeType::Bool) => return Ok(ReflectValueBox::Bool(*b)),
            (ProtobufConstant::String(lit), RuntimeType::String) => {
                return Ok(ReflectValueBox::String(lit.decode_utf8()?))
            }
            _ => {}
        }
        Err(ModelError::InconvertibleValue(ty.clone(), self.clone()).into())
    }
}

/// Equivalent of `UninterpretedOption.NamePart`.
#[derive(Debug, Clone, PartialEq)]
pub(crate) enum ProtobufOptionNamePart {
    Direct(ProtobufIdent),
    Ext(ProtobufPath),
}

impl fmt::Display for ProtobufOptionNamePart {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            ProtobufOptionNamePart::Direct(n) => write!(f, "{}", n),
            ProtobufOptionNamePart::Ext(n) => write!(f, "({})", n),
        }
    }
}

#[derive(Debug, Clone, PartialEq)]
pub(crate) struct ProtobufOptionNameExt(pub Vec<ProtobufOptionNamePart>);

#[derive(Debug, Clone, PartialEq)]
pub(crate) enum ProtobufOptionName {
    Builtin(ProtobufIdent),
    Ext(ProtobufOptionNameExt),
}

impl ProtobufOptionName {
    pub fn simple(name: &str) -> ProtobufOptionName {
        ProtobufOptionName::Builtin(ProtobufIdent::new(name))
    }
}

impl fmt::Display for ProtobufOptionNameExt {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        for (index, comp) in self.0.iter().enumerate() {
            if index != 0 {
                write!(f, ".")?;
            }
            write!(f, "{}", comp)?;
        }
        Ok(())
    }
}

impl fmt::Display for ProtobufOptionName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            ProtobufOptionName::Builtin(n) => write!(f, "{}", n),
            ProtobufOptionName::Ext(n) => write!(f, "{}", n),
        }
    }
}

#[derive(Debug, Clone, PartialEq)]
pub(crate) struct ProtobufOption {
    pub name: ProtobufOptionName,
    pub value: ProtobufConstant,
}

/// Visibility of import statement
#[derive(Debug, Clone, Eq, PartialEq)]
pub(crate) enum ImportVis {
    Default,
    Public,
    Weak,
}

impl Default for ImportVis {
    fn default() -> Self {
        ImportVis::Default
    }
}

/// Import statement
#[derive(Debug, Default, Clone)]
pub(crate) struct Import {
    pub path: ProtoPathBuf,
    pub vis: ImportVis,
}

/// A File descriptor representing a whole .proto file
#[derive(Debug, Default, Clone)]
pub(crate) struct FileDescriptor {
    /// Imports
    pub imports: Vec<Import>,
    /// Package
    pub package: ProtobufAbsPath,
    /// Protobuf Syntax
    pub syntax: Syntax,
    /// Top level messages
    pub messages: Vec<WithLoc<Message>>,
    /// Enums
    pub enums: Vec<WithLoc<Enumeration>>,
    /// Extensions
    pub extensions: Vec<WithLoc<Extension>>,
    /// Services
    pub services: Vec<WithLoc<Service>>,
    /// Non-builtin options
    pub options: Vec<ProtobufOption>,
}

impl FileDescriptor {
    /// Parses a .proto file content into a `FileDescriptor`
    pub fn parse<S: AsRef<str>>(file: S) -> Result<Self, ParserErrorWithLocation> {
        let mut parser = Parser::new(file.as_ref());
        match parser.next_proto() {
            Ok(r) => Ok(r),
            Err(error) => {
                let Loc { line, col } = parser.tokenizer.loc();
                Err(ParserErrorWithLocation { error, line, col })
            }
        }
    }
}

'''
'''--- protobuf-parse/src/pure/parse_and_typecheck.rs ---
use std::fmt;
use std::fs;
use std::io;
use std::path::Path;
use std::path::PathBuf;
use std::str;

use indexmap::IndexMap;
use protobuf::descriptor::FileDescriptorProto;
use protobuf::reflect::FileDescriptor;

use crate::parse_and_typecheck::ParsedAndTypechecked;
use crate::proto;
use crate::proto_path::ProtoPath;
use crate::proto_path::ProtoPathBuf;
use crate::pure::convert;
use crate::pure::model;
use crate::FileDescriptorPair;
use crate::Parser;

#[derive(Debug, thiserror::Error)]
enum ParseAndTypeckError {
    #[error("file `{0}` content is not UTF-8")]
    FileContentIsNotUtf8(String),
    #[error("protobuf path `{0}` is not found in import path {1}")]
    FileNotFoundInImportPath(String, String),
    #[error("file `{0}` must reside in include path {1}")]
    FileMustResideInImportPath(String, String),
    #[error("could not read file `{0}`: {1}")]
    CouldNotReadFile(String, io::Error),
}

#[derive(Debug, thiserror::Error)]
#[error("error in `{file}`: {error}")]
struct WithFileError {
    file: String,
    #[source]
    error: anyhow::Error,
}

/// Resolve `.proto` files. `Display` is used for error messages.
pub trait ProtoPathResolver: fmt::Display {
    /// Resolve a `.proto` file.
    ///
    /// Return `None` if a path is unknown, and if a path is a built-in protobuf file,
    /// like `google/protobuf/descriptor.proto`, it will be handled by the library.
    fn resolve(&self, path: &ProtoPath) -> anyhow::Result<Option<ResolvedProtoFile>>;
}

struct Run<R>
where
    R: ProtoPathResolver,
{
    parsed_files: IndexMap<ProtoPathBuf, FileDescriptorPair>,
    resolver: R,
}

impl<R> Run<R>
where
    R: ProtoPathResolver,
{
    fn file_and_all_deps_already_parsed(
        &self,
        protobuf_path: &ProtoPath,
        result: &mut IndexMap<ProtoPathBuf, FileDescriptorPair>,
    ) {
        if let Some(_) = result.get(protobuf_path) {
            return;
        }

        let pair = self
            .parsed_files
            .get(protobuf_path)
            .expect("must be already parsed");
        result.insert(protobuf_path.to_proto_path_buf(), pair.clone());

        self.all_deps_already_parsed(&pair.parsed, result);
    }

    fn all_deps_already_parsed(
        &self,
        parsed: &model::FileDescriptor,
        result: &mut IndexMap<ProtoPathBuf, FileDescriptorPair>,
    ) {
        for import in &parsed.imports {
            self.file_and_all_deps_already_parsed(&import.path, result);
        }
    }

    fn add_file_content(
        &mut self,
        protobuf_path: &ProtoPath,
        resolved: &ResolvedProtoFile,
    ) -> anyhow::Result<()> {
        let content = str::from_utf8(&resolved.content)
            .map_err(|_| ParseAndTypeckError::FileContentIsNotUtf8(protobuf_path.to_string()))?;

        let parsed = model::FileDescriptor::parse(&content).map_err(|e| WithFileError {
            file: resolved.path.clone(),
            error: e.into(),
        })?;

        for import in &parsed.imports {
            self.add_imported_file(&import.path)?;
        }

        let mut this_file_deps = IndexMap::new();
        self.all_deps_already_parsed(&parsed, &mut this_file_deps);

        let this_file_deps: Vec<_> = this_file_deps.into_iter().map(|(_, v)| v).collect();

        let descriptor_proto = convert::file_descriptor(protobuf_path, &parsed, &this_file_deps)
            .map_err(|e| WithFileError {
                file: resolved.path.clone(),
                error: e.into(),
            })?;

        let deps: Vec<FileDescriptor> = self
            .parsed_files
            .values()
            .map(|v| v.descriptor.clone())
            .collect();
        let descriptor = FileDescriptor::new_dynamic(descriptor_proto.clone(), &deps)?;

        self.parsed_files.insert(
            protobuf_path.to_proto_path_buf(),
            FileDescriptorPair {
                parsed,
                descriptor_proto,
                descriptor,
            },
        );

        Ok(())
    }

    fn add_imported_file(&mut self, protobuf_path: &ProtoPath) -> anyhow::Result<()> {
        if let Some(_) = self.parsed_files.get(protobuf_path) {
            return Ok(());
        }

        let resolved = self.resolver.resolve(protobuf_path)?;
        if let Some(resolved) = resolved {
            return self.add_file_content(protobuf_path, &resolved);
        }

        let embedded = match protobuf_path.to_str() {
            "rustproto.proto" => Some(proto::RUSTPROTO_PROTO),
            "google/protobuf/any.proto" => Some(proto::ANY_PROTO),
            "google/protobuf/api.proto" => Some(proto::API_PROTO),
            "google/protobuf/descriptor.proto" => Some(proto::DESCRIPTOR_PROTO),
            "google/protobuf/duration.proto" => Some(proto::DURATION_PROTO),
            "google/protobuf/empty.proto" => Some(proto::EMPTY_PROTO),
            "google/protobuf/field_mask.proto" => Some(proto::FIELD_MASK_PROTO),
            "google/protobuf/source_context.proto" => Some(proto::SOURCE_CONTEXT_PROTO),
            "google/protobuf/struct.proto" => Some(proto::STRUCT_PROTO),
            "google/protobuf/timestamp.proto" => Some(proto::TIMESTAMP_PROTO),
            "google/protobuf/type.proto" => Some(proto::TYPE_PROTO),
            "google/protobuf/wrappers.proto" => Some(proto::WRAPPERS_PROTO),
            _ => None,
        };

        match embedded {
            Some(content) => self.add_file_content(
                protobuf_path,
                &ResolvedProtoFile {
                    path: protobuf_path.to_string(),
                    content: content.as_bytes().to_vec(),
                },
            ),
            None => Err(ParseAndTypeckError::FileNotFoundInImportPath(
                protobuf_path.to_string(),
                format!("{}", self.resolver),
            )
            .into()),
        }
    }
}

pub(crate) fn path_to_proto_path(
    path: &Path,
    includes: &[PathBuf],
) -> anyhow::Result<ProtoPathBuf> {
    for include in includes {
        if include == Path::new(".") && path.is_relative() {
            // Special handling of `.` to allow using `.` as an include path
            // and `foo.proto` as input.
            return ProtoPathBuf::from_path(path);
        }
        match path.strip_prefix(include) {
            Ok(stripped) => return ProtoPathBuf::from_path(stripped),
            Err(_) => continue,
        }
    }
    Err(ParseAndTypeckError::FileMustResideInImportPath(
        path.display().to_string(),
        format!("{:?}", includes),
    )
    .into())
}

/// `.proto` file result provided from the [`ProtoPathResolver`].
pub struct ResolvedProtoFile {
    /// For error reporting.
    pub path: String,
    /// File content.
    pub content: Vec<u8>,
}

fn fs_resolver(includes: &[PathBuf]) -> impl ProtoPathResolver {
    struct Impl {
        includes: Vec<PathBuf>,
    }

    impl fmt::Display for Impl {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            write!(f, "{:?}", self.includes)
        }
    }

    impl ProtoPathResolver for Impl {
        fn resolve(&self, proto_path: &ProtoPath) -> anyhow::Result<Option<ResolvedProtoFile>> {
            for include_dir in &self.includes {
                let fs_path = include_dir.join(proto_path.to_path());
                match fs::read_to_string(&fs_path) {
                    Ok(content) => {
                        return Ok(Some(ResolvedProtoFile {
                            path: fs_path.display().to_string(),
                            content: content.into_bytes(),
                        }))
                    }
                    Err(e) if e.kind() == io::ErrorKind::NotFound => continue,
                    Err(e) => {
                        return Err(ParseAndTypeckError::CouldNotReadFile(
                            fs_path.display().to_string(),
                            e,
                        )
                        .into())
                    }
                }
            }
            Ok(None)
        }
    }

    Impl {
        includes: includes.to_vec(),
    }
}

/// Parse `.proto` files using pure Rust implementation.
pub fn parse_and_typecheck(parser: &Parser) -> anyhow::Result<ParsedAndTypechecked> {
    let mut run = Run {
        parsed_files: IndexMap::new(),
        resolver: fs_resolver(&parser.includes),
    };

    let relative_paths = parser
        .inputs
        .iter()
        .map(|input| Ok((path_to_proto_path(input, &parser.includes)?, input)))
        .collect::<anyhow::Result<Vec<_>>>()?;

    for (proto_path, path) in &relative_paths {
        let content = fs::read_to_string(path)
            .map_err(|e| ParseAndTypeckError::CouldNotReadFile(path.display().to_string(), e))?;
        run.add_file_content(
            proto_path,
            &ResolvedProtoFile {
                path: path.display().to_string(),
                content: content.into_bytes(),
            },
        )?;
    }

    let file_descriptors: Vec<_> = run
        .parsed_files
        .into_iter()
        .map(|(_, v)| v.descriptor_proto)
        .collect();

    Ok(ParsedAndTypechecked {
        relative_paths: relative_paths.into_iter().map(|(p, _)| p).collect(),
        file_descriptors,
        parser: "pure".to_owned(),
    })
}

/// TODO: this API is to be refactored.
pub fn parse_and_typecheck_custom(
    input: &[ProtoPathBuf],
    resolver: impl ProtoPathResolver,
) -> anyhow::Result<Vec<FileDescriptorProto>> {
    let mut run = Run {
        parsed_files: IndexMap::new(),
        resolver,
    };

    for proto_path in input {
        run.add_imported_file(proto_path)?;
    }

    Ok(run
        .parsed_files
        .into_iter()
        .map(|(_, v)| v.descriptor_proto)
        .collect())
}

#[cfg(test)]
mod test {
    use std::fmt;

    use crate::proto_path::ProtoPath;
    use crate::pure::parse_and_typecheck::ProtoPathResolver;
    use crate::pure::parse_and_typecheck::ResolvedProtoFile;
    use crate::ProtoPathBuf;

    #[test]
    fn parse_and_typecheck_custom() {
        struct ResolverImpl;

        impl fmt::Display for ResolverImpl {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                write!(f, "ResolverImpl")
            }
        }

        impl ProtoPathResolver for ResolverImpl {
            fn resolve(&self, proto_path: &ProtoPath) -> anyhow::Result<Option<ResolvedProtoFile>> {
                if proto_path == "xx.proto" {
                    Ok(Some(ResolvedProtoFile {
                        path: "xx.proto".to_string(),
                        content: "syntax = 'proto3'; message Foo {}".as_bytes().to_vec(),
                    }))
                } else {
                    Ok(None)
                }
            }
        }

        let resolved = super::parse_and_typecheck_custom(
            &[ProtoPathBuf::new("xx.proto".to_owned()).unwrap()],
            ResolverImpl,
        )
        .unwrap();
        assert_eq!(1, resolved.len());
        assert_eq!("Foo", resolved[0].message_type[0].name());
    }
}

'''
'''--- protobuf-parse/src/pure/parse_dependencies.rs ---
use protobuf::descriptor::FileDescriptorProto;

use crate::pure::convert::populate_dependencies;
use crate::pure::model;
use crate::pure::parser::ParserErrorWithLocation;

/// Parse imports from a `.proto` file.
///
/// The result is [`FileDescriptorProto`] object with only `*dependency` fields filled.
pub fn parse_dependencies(content: &str) -> Result<FileDescriptorProto, ParserErrorWithLocation> {
    let input = model::FileDescriptor::parse(content)?;
    let mut output = FileDescriptorProto::new();
    populate_dependencies(&input, &mut output);
    Ok(output)
}

#[cfg(test)]
mod test {
    #[test]
    fn parse_dependencies() {
        let deps = crate::pure::parse_dependencies::parse_dependencies(
            r"
syntax = 'proto3';

import 'google/protobuf/field_mask.proto';
import public 'google/protobuf/struct.proto';

message IgnoreMe {}
",
        )
        .unwrap();
        assert_eq!(
            &[
                "google/protobuf/field_mask.proto",
                "google/protobuf/struct.proto",
            ],
            &deps.dependency[..]
        );
        assert_eq!(&[1], &deps.public_dependency[..]);
    }
}

'''
'''--- protobuf-parse/src/pure/parser.rs ---
use std::str;

use protobuf_support::lexer::int;
use protobuf_support::lexer::lexer_impl::LexerError;
use protobuf_support::lexer::num_lit::NumLit;
use protobuf_support::lexer::parser_language::ParserLanguage;
use protobuf_support::lexer::str_lit::StrLitDecodeError;
use protobuf_support::lexer::token::Token;
use protobuf_support::lexer::tokenizer::Tokenizer;
use protobuf_support::lexer::tokenizer::TokenizerError;

use crate::model::AnyTypeUrl;
use crate::model::ProtobufConstantMessageFieldName;
use crate::proto_path::ProtoPathBuf;
use crate::protobuf_abs_path::ProtobufAbsPath;
use crate::protobuf_ident::ProtobufIdent;
use crate::protobuf_path::ProtobufPath;
use crate::protobuf_rel_path::ProtobufRelPath;
use crate::pure::model;
use crate::pure::model::EnumValue;
use crate::pure::model::Enumeration;
use crate::pure::model::Extension;
use crate::pure::model::Field;
use crate::pure::model::FieldNumberRange;
use crate::pure::model::FieldOrOneOf;
use crate::pure::model::FieldType;
use crate::pure::model::FileDescriptor;
use crate::pure::model::Group;
use crate::pure::model::ImportVis;
use crate::pure::model::Message;
use crate::pure::model::Method;
use crate::pure::model::OneOf;
use crate::pure::model::ProtobufConstant;
use crate::pure::model::ProtobufConstantMessage;
use crate::pure::model::ProtobufOption;
use crate::pure::model::ProtobufOptionName;
use crate::pure::model::ProtobufOptionNameExt;
use crate::pure::model::ProtobufOptionNamePart;
use crate::pure::model::Rule;
use crate::pure::model::Service;
use crate::pure::model::Syntax;
use crate::pure::model::WithLoc;

/// Basic information about parsing error.
#[derive(Debug, thiserror::Error)]
pub(crate) enum ParserError {
    #[error("{0}")]
    TokenizerError(#[source] TokenizerError),
    // TODO
    #[error("incorrect input")]
    IncorrectInput,
    #[error("not UTF-8")]
    NotUtf8,
    #[error("expecting a constant")]
    ExpectConstant,
    #[error("unknown syntax")]
    UnknownSyntax,
    #[error("integer overflow")]
    IntegerOverflow,
    #[error("label not allowed")]
    LabelNotAllowed,
    #[error("label required")]
    LabelRequired,
    #[error("group name should start with upper case")]
    GroupNameShouldStartWithUpperCase,
    #[error("map field not allowed")]
    MapFieldNotAllowed,
    #[error("string literal decode error: {0}")]
    StrLitDecodeError(#[source] StrLitDecodeError),
    #[error("lexer error: {0}")]
    LexerError(#[source] LexerError),
    #[error("oneof in group")]
    OneOfInGroup,
    #[error("oneof in oneof")]
    OneOfInOneOf,
    #[error("oneof in extend")]
    OneOfInExtend,
}

impl From<TokenizerError> for ParserError {
    fn from(e: TokenizerError) -> Self {
        ParserError::TokenizerError(e)
    }
}

impl From<StrLitDecodeError> for ParserError {
    fn from(e: StrLitDecodeError) -> Self {
        ParserError::StrLitDecodeError(e)
    }
}

impl From<LexerError> for ParserError {
    fn from(e: LexerError) -> Self {
        ParserError::LexerError(e)
    }
}

impl From<int::Overflow> for ParserError {
    fn from(_: int::Overflow) -> Self {
        ParserError::IntegerOverflow
    }
}

#[derive(Debug, thiserror::Error)]
#[error("at {line}:{col}: {error}")]
pub struct ParserErrorWithLocation {
    #[source]
    pub error: anyhow::Error,
    /// 1-based
    pub line: u32,
    /// 1-based
    pub col: u32,
}

trait ToU8 {
    fn to_u8(&self) -> anyhow::Result<u8>;
}

trait ToI32 {
    fn to_i32(&self) -> anyhow::Result<i32>;
}

trait ToI64 {
    fn to_i64(&self) -> anyhow::Result<i64>;
}

trait ToChar {
    fn to_char(&self) -> anyhow::Result<char>;
}

impl ToI32 for u64 {
    fn to_i32(&self) -> anyhow::Result<i32> {
        if *self <= i32::max_value() as u64 {
            Ok(*self as i32)
        } else {
            Err(ParserError::IntegerOverflow.into())
        }
    }
}

impl ToI32 for i64 {
    fn to_i32(&self) -> anyhow::Result<i32> {
        if *self <= i32::max_value() as i64 && *self >= i32::min_value() as i64 {
            Ok(*self as i32)
        } else {
            Err(ParserError::IntegerOverflow.into())
        }
    }
}

impl ToI64 for u64 {
    fn to_i64(&self) -> anyhow::Result<i64> {
        if *self <= i64::max_value() as u64 {
            Ok(*self as i64)
        } else {
            Err(ParserError::IntegerOverflow.into())
        }
    }
}

impl ToChar for u8 {
    fn to_char(&self) -> anyhow::Result<char> {
        if *self <= 0x7f {
            Ok(*self as char)
        } else {
            Err(ParserError::NotUtf8.into())
        }
    }
}

impl ToU8 for u32 {
    fn to_u8(&self) -> anyhow::Result<u8> {
        if *self as u8 as u32 == *self {
            Ok(*self as u8)
        } else {
            Err(ParserError::IntegerOverflow.into())
        }
    }
}

#[derive(Clone)]
pub(crate) struct Parser<'a> {
    pub tokenizer: Tokenizer<'a>,
    syntax: Syntax,
}

#[derive(Copy, Clone)]
enum MessageBodyParseMode {
    MessageProto2,
    MessageProto3,
    Oneof,
    ExtendProto2,
    ExtendProto3,
}

impl MessageBodyParseMode {
    fn label_allowed(&self, label: Rule) -> bool {
        match label {
            Rule::Repeated => match *self {
                MessageBodyParseMode::MessageProto2
                | MessageBodyParseMode::MessageProto3
                | MessageBodyParseMode::ExtendProto2
                | MessageBodyParseMode::ExtendProto3 => true,
                MessageBodyParseMode::Oneof => false,
            },
            Rule::Optional => match *self {
                MessageBodyParseMode::MessageProto2 | MessageBodyParseMode::ExtendProto2 => true,
                MessageBodyParseMode::MessageProto3 | MessageBodyParseMode::ExtendProto3 => true,
                MessageBodyParseMode::Oneof => false,
            },
            Rule::Required => match *self {
                MessageBodyParseMode::MessageProto2 | MessageBodyParseMode::ExtendProto2 => true,
                MessageBodyParseMode::MessageProto3 | MessageBodyParseMode::ExtendProto3 => false,
                MessageBodyParseMode::Oneof => false,
            },
        }
    }

    fn some_label_required(&self) -> bool {
        match *self {
            MessageBodyParseMode::MessageProto2 | MessageBodyParseMode::ExtendProto2 => true,
            MessageBodyParseMode::MessageProto3
            | MessageBodyParseMode::ExtendProto3
            | MessageBodyParseMode::Oneof => false,
        }
    }

    fn map_allowed(&self) -> bool {
        match *self {
            MessageBodyParseMode::MessageProto2
            | MessageBodyParseMode::MessageProto3
            | MessageBodyParseMode::ExtendProto2
            | MessageBodyParseMode::ExtendProto3 => true,
            MessageBodyParseMode::Oneof => false,
        }
    }

    fn is_most_non_fields_allowed(&self) -> bool {
        match *self {
            MessageBodyParseMode::MessageProto2 | MessageBodyParseMode::MessageProto3 => true,
            MessageBodyParseMode::ExtendProto2
            | MessageBodyParseMode::ExtendProto3
            | MessageBodyParseMode::Oneof => false,
        }
    }

    fn is_option_allowed(&self) -> bool {
        match *self {
            MessageBodyParseMode::MessageProto2
            | MessageBodyParseMode::MessageProto3
            | MessageBodyParseMode::Oneof => true,
            MessageBodyParseMode::ExtendProto2 | MessageBodyParseMode::ExtendProto3 => false,
        }
    }

    fn is_extensions_allowed(&self) -> bool {
        match self {
            MessageBodyParseMode::MessageProto2 => true,
            _ => false,
        }
    }
}

#[derive(Default)]
pub(crate) struct MessageBody {
    pub fields: Vec<WithLoc<FieldOrOneOf>>,
    pub reserved_nums: Vec<FieldNumberRange>,
    pub reserved_names: Vec<String>,
    pub messages: Vec<WithLoc<Message>>,
    pub enums: Vec<WithLoc<Enumeration>>,
    pub options: Vec<ProtobufOption>,
    pub extension_ranges: Vec<FieldNumberRange>,
    pub extensions: Vec<WithLoc<Extension>>,
}

trait NumLitEx {
    fn to_option_value(&self, sign_is_plus: bool) -> anyhow::Result<ProtobufConstant>;
}

impl NumLitEx for NumLit {
    fn to_option_value(&self, sign_is_plus: bool) -> anyhow::Result<ProtobufConstant> {
        Ok(match (*self, sign_is_plus) {
            (NumLit::U64(u), true) => ProtobufConstant::U64(u),
            (NumLit::F64(f), true) => ProtobufConstant::F64(f),
            (NumLit::U64(u), false) => {
                ProtobufConstant::I64(int::neg(u).map_err(|_| ParserError::IntegerOverflow)?)
            }
            (NumLit::F64(f), false) => ProtobufConstant::F64(-f),
        })
    }
}

impl<'a> Parser<'a> {
    pub(crate) fn new(input: &'a str) -> Parser<'a> {
        Parser {
            tokenizer: Tokenizer::new(input, ParserLanguage::Proto),
            syntax: Syntax::Proto2,
        }
    }

    // Protobuf grammar

    // fullIdent = ident { "." ident }
    fn next_full_ident(&mut self) -> anyhow::Result<ProtobufPath> {
        let mut full_ident = String::new();
        // https://github.com/google/protobuf/issues/4563
        if self.tokenizer.next_symbol_if_eq('.')? {
            full_ident.push('.');
        }
        full_ident.push_str(&self.tokenizer.next_ident()?);
        while self.tokenizer.next_symbol_if_eq('.')? {
            full_ident.push('.');
            full_ident.push_str(&self.tokenizer.next_ident()?);
        }
        Ok(ProtobufPath::new(full_ident))
    }

    // fullIdent = ident { "." ident }
    fn next_full_ident_rel(&mut self) -> anyhow::Result<ProtobufRelPath> {
        let mut full_ident = String::new();
        full_ident.push_str(&self.tokenizer.next_ident()?);
        while self.tokenizer.next_symbol_if_eq('.')? {
            full_ident.push('.');
            full_ident.push_str(&self.tokenizer.next_ident()?);
        }
        Ok(ProtobufRelPath::new(full_ident))
    }

    // emptyStatement = ";"
    fn next_empty_statement_opt(&mut self) -> anyhow::Result<Option<()>> {
        if self.tokenizer.next_symbol_if_eq(';')? {
            Ok(Some(()))
        } else {
            Ok(None)
        }
    }

    // messageName = ident
    // enumName = ident
    // messageType = [ "." ] { ident "." } messageName
    // enumType = [ "." ] { ident "." } enumName
    fn next_message_or_enum_type(&mut self) -> anyhow::Result<ProtobufPath> {
        self.next_full_ident()
    }

    // groupName = capitalLetter { letter | decimalDigit | "_" }
    fn next_group_name(&mut self) -> anyhow::Result<String> {
        // lexer cannot distinguish between group name and other ident
        let mut clone = self.clone();
        let ident = clone.tokenizer.next_ident()?;
        if !ident.chars().next().unwrap().is_ascii_uppercase() {
            return Err(ParserError::GroupNameShouldStartWithUpperCase.into());
        }
        *self = clone;
        Ok(ident)
    }

    // Boolean

    // boolLit = "true" | "false"
    fn next_bool_lit_opt(&mut self) -> anyhow::Result<Option<bool>> {
        Ok(if self.tokenizer.next_ident_if_eq("true")? {
            Some(true)
        } else if self.tokenizer.next_ident_if_eq("false")? {
            Some(false)
        } else {
            None
        })
    }

    // Constant

    fn next_num_lit(&mut self) -> anyhow::Result<NumLit> {
        self.tokenizer
            .next_token_check_map(|token| Ok(token.to_num_lit()?))
    }

    fn next_message_constant_field_name(
        &mut self,
    ) -> anyhow::Result<ProtobufConstantMessageFieldName> {
        if self.tokenizer.next_symbol_if_eq('[')? {
            let n = self.next_full_ident()?;
            if self.tokenizer.next_symbol_if_eq('/')? {
                let prefix = format!("{}", n);
                let full_type_name = self.next_full_ident()?;
                self.tokenizer
                    .next_symbol_expect_eq(']', "message constant")?;
                Ok(ProtobufConstantMessageFieldName::AnyTypeUrl(AnyTypeUrl {
                    prefix,
                    full_type_name,
                }))
            } else {
                self.tokenizer
                    .next_symbol_expect_eq(']', "message constant")?;
                Ok(ProtobufConstantMessageFieldName::Extension(n))
            }
        } else {
            let n = self.tokenizer.next_ident()?;
            Ok(ProtobufConstantMessageFieldName::Regular(n))
        }
    }

    fn next_message_constant(&mut self) -> anyhow::Result<ProtobufConstantMessage> {
        let mut r = ProtobufConstantMessage::default();
        self.tokenizer
            .next_symbol_expect_eq('{', "message constant")?;
        while !self.tokenizer.lookahead_is_symbol('}')? {
            let n = self.next_message_constant_field_name()?;
            let v = self.next_field_value()?;
            r.fields.insert(n, v);
        }
        self.tokenizer
            .next_symbol_expect_eq('}', "message constant")?;
        Ok(r)
    }

    // constant = fullIdent | ( [ "-" | "+" ] intLit ) | ( [ "-" | "+" ] floatLit ) |
    //            strLit | boolLit
    fn next_constant(&mut self) -> anyhow::Result<ProtobufConstant> {
        // https://github.com/google/protobuf/blob/a21f225824e994ebd35e8447382ea4e0cd165b3c/src/google/protobuf/unittest_custom_options.proto#L350
        if self.tokenizer.lookahead_is_symbol('{')? {
            return Ok(ProtobufConstant::Message(self.next_message_constant()?));
        }

        if let Some(b) = self.next_bool_lit_opt()? {
            return Ok(ProtobufConstant::Bool(b));
        }

        if let &Token::Symbol(c) = self.tokenizer.lookahead_some()? {
            if c == '+' || c == '-' {
                self.tokenizer.advance()?;
                let sign = c == '+';
                return Ok(self.next_num_lit()?.to_option_value(sign)?);
            }
        }

        if let Some(r) = self.tokenizer.next_token_if_map(|token| match token {
            &Token::StrLit(ref s) => Some(ProtobufConstant::String(s.clone())),
            _ => None,
        })? {
            return Ok(r);
        }

        match self.tokenizer.lookahead_some()? {
            &Token::IntLit(..) | &Token::FloatLit(..) => {
                return self.next_num_lit()?.to_option_value(true);
            }
            &Token::Ident(..) => {
                return Ok(ProtobufConstant::Ident(self.next_full_ident()?));
            }
            _ => {}
        }

        Err(ParserError::ExpectConstant.into())
    }

    fn next_field_value(&mut self) -> anyhow::Result<ProtobufConstant> {
        if self.tokenizer.next_symbol_if_eq(':')? {
            // Colon is optional when reading message constant.
            self.next_constant()
        } else {
            Ok(ProtobufConstant::Message(self.next_message_constant()?))
        }
    }

    fn next_int_lit(&mut self) -> anyhow::Result<u64> {
        self.tokenizer.next_token_check_map(|token| match token {
            &Token::IntLit(i) => Ok(i),
            _ => Err(ParserError::IncorrectInput.into()),
        })
    }

    // Syntax

    // syntax = "syntax" "=" quote "proto2" quote ";"
    // syntax = "syntax" "=" quote "proto3" quote ";"
    fn next_syntax(&mut self) -> anyhow::Result<Option<Syntax>> {
        if self.tokenizer.next_ident_if_eq("syntax")? {
            self.tokenizer.next_symbol_expect_eq('=', "syntax")?;
            let syntax_str = self.tokenizer.next_str_lit()?.decode_utf8()?;
            let syntax = if syntax_str == "proto2" {
                Syntax::Proto2
            } else if syntax_str == "proto3" {
                Syntax::Proto3
            } else {
                return Err(ParserError::UnknownSyntax.into());
            };
            self.tokenizer.next_symbol_expect_eq(';', "syntax")?;
            Ok(Some(syntax))
        } else {
            Ok(None)
        }
    }

    // Import Statement

    // import = "import" [ "weak" | "public" ] strLit ";"
    fn next_import_opt(&mut self) -> anyhow::Result<Option<model::Import>> {
        if self.tokenizer.next_ident_if_eq("import")? {
            let vis = if self.tokenizer.next_ident_if_eq("weak")? {
                ImportVis::Weak
            } else if self.tokenizer.next_ident_if_eq("public")? {
                ImportVis::Public
            } else {
                ImportVis::Default
            };
            let path = self.tokenizer.next_str_lit()?.decode_utf8()?;
            self.tokenizer.next_symbol_expect_eq(';', "import")?;
            let path = ProtoPathBuf::new(path)?;
            Ok(Some(model::Import { path, vis }))
        } else {
            Ok(None)
        }
    }

    // Package

    // package = "package" fullIdent ";"
    fn next_package_opt(&mut self) -> anyhow::Result<Option<ProtobufAbsPath>> {
        if self.tokenizer.next_ident_if_eq("package")? {
            let package = self.next_full_ident_rel()?;
            self.tokenizer.next_symbol_expect_eq(';', "package")?;
            Ok(Some(package.into_absolute()))
        } else {
            Ok(None)
        }
    }

    // Option

    fn next_ident(&mut self) -> anyhow::Result<ProtobufIdent> {
        Ok(ProtobufIdent::from(self.tokenizer.next_ident()?))
    }

    fn next_option_name_component(&mut self) -> anyhow::Result<ProtobufOptionNamePart> {
        if self.tokenizer.next_symbol_if_eq('(')? {
            let comp = self.next_full_ident()?;
            self.tokenizer
                .next_symbol_expect_eq(')', "option name component")?;
            Ok(ProtobufOptionNamePart::Ext(comp))
        } else {
            Ok(ProtobufOptionNamePart::Direct(self.next_ident()?))
        }
    }

    // https://github.com/google/protobuf/issues/4563
    // optionName = ( ident | "(" fullIdent ")" ) { "." ident }
    fn next_option_name(&mut self) -> anyhow::Result<ProtobufOptionName> {
        let mut components = Vec::new();
        components.push(self.next_option_name_component()?);
        while self.tokenizer.next_symbol_if_eq('.')? {
            components.push(self.next_option_name_component()?);
        }
        if components.len() == 1 {
            if let ProtobufOptionNamePart::Direct(n) = &components[0] {
                return Ok(ProtobufOptionName::Builtin(n.clone()));
            }
        }
        Ok(ProtobufOptionName::Ext(ProtobufOptionNameExt(components)))
    }

    // option = "option" optionName  "=" constant ";"
    fn next_option_opt(&mut self) -> anyhow::Result<Option<ProtobufOption>> {
        if self.tokenizer.next_ident_if_eq("option")? {
            let name = self.next_option_name()?;
            self.tokenizer.next_symbol_expect_eq('=', "option")?;
            let value = self.next_constant()?;
            self.tokenizer.next_symbol_expect_eq(';', "option")?;
            Ok(Some(ProtobufOption { name, value }))
        } else {
            Ok(None)
        }
    }

    // Fields

    // label = "required" | "optional" | "repeated"
    fn next_label(&mut self, mode: MessageBodyParseMode) -> anyhow::Result<Option<Rule>> {
        for rule in Rule::ALL {
            let mut clone = self.clone();
            if clone.tokenizer.next_ident_if_eq(rule.as_str())? {
                if !mode.label_allowed(rule) {
                    return Err(ParserError::LabelNotAllowed.into());
                }

                *self = clone;
                return Ok(Some(rule));
            }
        }

        if mode.some_label_required() {
            Err(ParserError::LabelRequired.into())
        } else {
            Ok(None)
        }
    }

    fn next_field_type(&mut self) -> anyhow::Result<FieldType> {
        let simple = &[
            ("int32", FieldType::Int32),
            ("int64", FieldType::Int64),
            ("uint32", FieldType::Uint32),
            ("uint64", FieldType::Uint64),
            ("sint32", FieldType::Sint32),
            ("sint64", FieldType::Sint64),
            ("fixed32", FieldType::Fixed32),
            ("sfixed32", FieldType::Sfixed32),
            ("fixed64", FieldType::Fixed64),
            ("sfixed64", FieldType::Sfixed64),
            ("bool", FieldType::Bool),
            ("string", FieldType::String),
            ("bytes", FieldType::Bytes),
            ("float", FieldType::Float),
            ("double", FieldType::Double),
        ];
        for &(ref n, ref t) in simple {
            if self.tokenizer.next_ident_if_eq(n)? {
                return Ok(t.clone());
            }
        }

        if let Some(t) = self.next_map_field_type_opt()? {
            return Ok(t);
        }

        let message_or_enum = self.next_message_or_enum_type()?;
        Ok(FieldType::MessageOrEnum(message_or_enum))
    }

    fn next_field_number(&mut self) -> anyhow::Result<i32> {
        // TODO: not all integers are valid field numbers
        self.tokenizer.next_token_check_map(|token| match token {
            &Token::IntLit(i) => i.to_i32(),
            _ => Err(ParserError::IncorrectInput.into()),
        })
    }

    // fieldOption = optionName "=" constant
    fn next_field_option(&mut self) -> anyhow::Result<ProtobufOption> {
        let name = self.next_option_name()?;
        self.tokenizer.next_symbol_expect_eq('=', "field option")?;
        let value = self.next_constant()?;
        Ok(ProtobufOption { name, value })
    }

    // fieldOptions = fieldOption { ","  fieldOption }
    fn next_field_options(&mut self) -> anyhow::Result<Vec<ProtobufOption>> {
        let mut options = Vec::new();

        options.push(self.next_field_option()?);

        while self.tokenizer.next_symbol_if_eq(',')? {
            options.push(self.next_field_option()?);
        }

        Ok(options)
    }

    // field = label type fieldName "=" fieldNumber [ "[" fieldOptions "]" ] ";"
    // group = label "group" groupName "=" fieldNumber messageBody
    fn next_field(&mut self, mode: MessageBodyParseMode) -> anyhow::Result<WithLoc<Field>> {
        let loc = self.tokenizer.lookahead_loc();
        let rule = if self.clone().tokenizer.next_ident_if_eq("map")? {
            if !mode.map_allowed() {
                return Err(ParserError::MapFieldNotAllowed.into());
            }
            None
        } else {
            self.next_label(mode)?
        };
        if self.tokenizer.next_ident_if_eq("group")? {
            let name = self.next_group_name()?.to_owned();
            self.tokenizer.next_symbol_expect_eq('=', "group")?;
            let number = self.next_field_number()?;

            let mode = match self.syntax {
                Syntax::Proto2 => MessageBodyParseMode::MessageProto2,
                Syntax::Proto3 => MessageBodyParseMode::MessageProto3,
            };

            let MessageBody { fields, .. } = self.next_message_body(mode)?;

            let fields = fields
                .into_iter()
                .map(|fo| match fo.t {
                    FieldOrOneOf::Field(f) => Ok(f),
                    FieldOrOneOf::OneOf(_) => Err(ParserError::OneOfInGroup),
                })
                .collect::<Result<_, ParserError>>()?;

            let field = Field {
                // The field name is a lowercased version of the type name
                // (which has been verified to start with an uppercase letter).
                // https://git.io/JvxAP
                name: name.to_ascii_lowercase(),
                rule,
                typ: FieldType::Group(Group { name, fields }),
                number,
                options: Vec::new(),
            };
            Ok(WithLoc { t: field, loc })
        } else {
            let typ = self.next_field_type()?;
            let name = self.tokenizer.next_ident()?.to_owned();
            self.tokenizer.next_symbol_expect_eq('=', "field")?;
            let number = self.next_field_number()?;

            let mut options = Vec::new();

            if self.tokenizer.next_symbol_if_eq('[')? {
                for o in self.next_field_options()? {
                    options.push(o);
                }
                self.tokenizer.next_symbol_expect_eq(']', "field")?;
            }
            self.tokenizer.next_symbol_expect_eq(';', "field")?;
            let field = Field {
                name,
                rule,
                typ,
                number,
                options,
            };
            Ok(WithLoc { t: field, loc })
        }
    }

    // oneof = "oneof" oneofName "{" { oneofField | emptyStatement } "}"
    // oneofField = type fieldName "=" fieldNumber [ "[" fieldOptions "]" ] ";"
    fn next_oneof_opt(&mut self) -> anyhow::Result<Option<OneOf>> {
        if self.tokenizer.next_ident_if_eq("oneof")? {
            let name = self.tokenizer.next_ident()?.to_owned();
            let MessageBody {
                fields, options, ..
            } = self.next_message_body(MessageBodyParseMode::Oneof)?;
            let fields = fields
                .into_iter()
                .map(|fo| match fo.t {
                    FieldOrOneOf::Field(f) => Ok(f),
                    FieldOrOneOf::OneOf(_) => Err(ParserError::OneOfInOneOf),
                })
                .collect::<Result<_, ParserError>>()?;
            Ok(Some(OneOf {
                name,
                fields,
                options,
            }))
        } else {
            Ok(None)
        }
    }

    // mapField = "map" "<" keyType "," type ">" mapName "=" fieldNumber [ "[" fieldOptions "]" ] ";"
    // keyType = "int32" | "int64" | "uint32" | "uint64" | "sint32" | "sint64" |
    //           "fixed32" | "fixed64" | "sfixed32" | "sfixed64" | "bool" | "string"
    fn next_map_field_type_opt(&mut self) -> anyhow::Result<Option<FieldType>> {
        if self.tokenizer.next_ident_if_eq("map")? {
            self.tokenizer
                .next_symbol_expect_eq('<', "map field type")?;
            // TODO: restrict key types
            let key = self.next_field_type()?;
            self.tokenizer
                .next_symbol_expect_eq(',', "map field type")?;
            let value = self.next_field_type()?;
            self.tokenizer
                .next_symbol_expect_eq('>', "map field type")?;
            Ok(Some(FieldType::Map(Box::new((key, value)))))
        } else {
            Ok(None)
        }
    }

    // Extensions and Reserved

    // Extensions

    // range =  intLit [ "to" ( intLit | "max" ) ]
    fn next_range(&mut self) -> anyhow::Result<FieldNumberRange> {
        let from = self.next_field_number()?;
        let to = if self.tokenizer.next_ident_if_eq("to")? {
            if self.tokenizer.next_ident_if_eq("max")? {
                0x20000000 - 1
            } else {
                self.next_field_number()?
            }
        } else {
            from
        };
        Ok(FieldNumberRange { from, to })
    }

    // ranges = range { "," range }
    fn next_ranges(&mut self) -> anyhow::Result<Vec<FieldNumberRange>> {
        let mut ranges = Vec::new();
        ranges.push(self.next_range()?);
        while self.tokenizer.next_symbol_if_eq(',')? {
            ranges.push(self.next_range()?);
        }
        Ok(ranges)
    }

    // extensions = "extensions" ranges ";"
    fn next_extensions_opt(&mut self) -> anyhow::Result<Option<Vec<FieldNumberRange>>> {
        if self.tokenizer.next_ident_if_eq("extensions")? {
            Ok(Some(self.next_ranges()?))
        } else {
            Ok(None)
        }
    }

    // Reserved

    // Grammar is incorrect: https://github.com/google/protobuf/issues/4558
    // reserved = "reserved" ( ranges | fieldNames ) ";"
    // fieldNames = fieldName { "," fieldName }
    fn next_reserved_opt(
        &mut self,
    ) -> anyhow::Result<Option<(Vec<FieldNumberRange>, Vec<String>)>> {
        if self.tokenizer.next_ident_if_eq("reserved")? {
            let (ranges, names) = if let &Token::StrLit(..) = self.tokenizer.lookahead_some()? {
                let mut names = Vec::new();
                names.push(self.tokenizer.next_str_lit()?.decode_utf8()?);
                while self.tokenizer.next_symbol_if_eq(',')? {
                    names.push(self.tokenizer.next_str_lit()?.decode_utf8()?);
                }
                (Vec::new(), names)
            } else {
                (self.next_ranges()?, Vec::new())
            };

            self.tokenizer.next_symbol_expect_eq(';', "reserved")?;

            Ok(Some((ranges, names)))
        } else {
            Ok(None)
        }
    }

    // Top Level definitions

    // Enum definition

    // enumValueOption = optionName "=" constant
    fn next_enum_value_option(&mut self) -> anyhow::Result<ProtobufOption> {
        let name = self.next_option_name()?;
        self.tokenizer
            .next_symbol_expect_eq('=', "enum value option")?;
        let value = self.next_constant()?;
        Ok(ProtobufOption { name, value })
    }

    // https://github.com/google/protobuf/issues/4561
    fn next_enum_value(&mut self) -> anyhow::Result<i32> {
        let minus = self.tokenizer.next_symbol_if_eq('-')?;
        let lit = self.next_int_lit()?;
        Ok(if minus {
            let unsigned = lit.to_i64()?;
            match unsigned.checked_neg() {
                Some(neg) => neg.to_i32()?,
                None => return Err(ParserError::IntegerOverflow.into()),
            }
        } else {
            lit.to_i32()?
        })
    }

    // enumField = ident "=" intLit [ "[" enumValueOption { ","  enumValueOption } "]" ]";"
    fn next_enum_field(&mut self) -> anyhow::Result<EnumValue> {
        let name = self.tokenizer.next_ident()?.to_owned();
        self.tokenizer.next_symbol_expect_eq('=', "enum field")?;
        let number = self.next_enum_value()?;
        let mut options = Vec::new();
        if self.tokenizer.next_symbol_if_eq('[')? {
            options.push(self.next_enum_value_option()?);
            while self.tokenizer.next_symbol_if_eq(',')? {
                options.push(self.next_enum_value_option()?);
            }
            self.tokenizer.next_symbol_expect_eq(']', "enum field")?;
        }

        Ok(EnumValue {
            name,
            number,
            options,
        })
    }

    // enum = "enum" enumName enumBody
    // enumBody = "{" { option | enumField | emptyStatement } "}"
    fn next_enum_opt(&mut self) -> anyhow::Result<Option<WithLoc<Enumeration>>> {
        let loc = self.tokenizer.lookahead_loc();

        if self.tokenizer.next_ident_if_eq("enum")? {
            let name = self.tokenizer.next_ident()?.to_owned();

            let mut values = Vec::new();
            let mut options = Vec::new();

            self.tokenizer.next_symbol_expect_eq('{', "enum")?;
            while self.tokenizer.lookahead_if_symbol()? != Some('}') {
                // emptyStatement
                if self.tokenizer.next_symbol_if_eq(';')? {
                    continue;
                }

                if let Some(o) = self.next_option_opt()? {
                    options.push(o);
                    continue;
                }

                values.push(self.next_enum_field()?);
            }
            self.tokenizer.next_symbol_expect_eq('}', "enum")?;
            let enumeration = Enumeration {
                name,
                values,
                options,
            };
            Ok(Some(WithLoc {
                loc,
                t: enumeration,
            }))
        } else {
            Ok(None)
        }
    }

    // Message definition

    // messageBody = "{" { field | enum | message | extend | extensions | group |
    //               option | oneof | mapField | reserved | emptyStatement } "}"
    fn next_message_body(&mut self, mode: MessageBodyParseMode) -> anyhow::Result<MessageBody> {
        self.tokenizer.next_symbol_expect_eq('{', "message body")?;

        let mut r = MessageBody::default();

        while self.tokenizer.lookahead_if_symbol()? != Some('}') {
            let loc = self.tokenizer.lookahead_loc();

            // emptyStatement
            if self.tokenizer.next_symbol_if_eq(';')? {
                continue;
            }

            if mode.is_most_non_fields_allowed() {
                if let Some((field_nums, field_names)) = self.next_reserved_opt()? {
                    r.reserved_nums.extend(field_nums);
                    r.reserved_names.extend(field_names);
                    continue;
                }

                if let Some(oneof) = self.next_oneof_opt()? {
                    let one_of = FieldOrOneOf::OneOf(oneof);
                    r.fields.push(WithLoc { t: one_of, loc });
                    continue;
                }

                if let Some(extensions) = self.next_extend_opt()? {
                    r.extensions.extend(extensions);
                    continue;
                }

                if let Some(nested_message) = self.next_message_opt()? {
                    r.messages.push(nested_message);
                    continue;
                }

                if let Some(nested_enum) = self.next_enum_opt()? {
                    r.enums.push(nested_enum);
                    continue;
                }
            } else {
                self.tokenizer.next_ident_if_eq_error("reserved")?;
                self.tokenizer.next_ident_if_eq_error("oneof")?;
                self.tokenizer.next_ident_if_eq_error("extend")?;
                self.tokenizer.next_ident_if_eq_error("message")?;
                self.tokenizer.next_ident_if_eq_error("enum")?;
            }

            if mode.is_extensions_allowed() {
                if let Some(extension_ranges) = self.next_extensions_opt()? {
                    r.extension_ranges.extend(extension_ranges);
                    continue;
                }
            } else {
                self.tokenizer.next_ident_if_eq_error("extensions")?;
            }

            if mode.is_option_allowed() {
                if let Some(option) = self.next_option_opt()? {
                    r.options.push(option);
                    continue;
                }
            } else {
                self.tokenizer.next_ident_if_eq_error("option")?;
            }

            let field = FieldOrOneOf::Field(self.next_field(mode)?);
            r.fields.push(WithLoc { t: field, loc });
        }

        self.tokenizer.next_symbol_expect_eq('}', "message body")?;

        Ok(r)
    }

    // message = "message" messageName messageBody
    fn next_message_opt(&mut self) -> anyhow::Result<Option<WithLoc<Message>>> {
        let loc = self.tokenizer.lookahead_loc();

        if self.tokenizer.next_ident_if_eq("message")? {
            let name = self.tokenizer.next_ident()?.to_owned();

            let mode = match self.syntax {
                Syntax::Proto2 => MessageBodyParseMode::MessageProto2,
                Syntax::Proto3 => MessageBodyParseMode::MessageProto3,
            };

            let MessageBody {
                fields,
                reserved_nums,
                reserved_names,
                messages,
                enums,
                options,
                extensions,
                extension_ranges,
            } = self.next_message_body(mode)?;

            let message = Message {
                name,
                fields,
                reserved_nums,
                reserved_names,
                messages,
                enums,
                options,
                extensions,
                extension_ranges,
            };
            Ok(Some(WithLoc { t: message, loc }))
        } else {
            Ok(None)
        }
    }

    // Extend

    // extend = "extend" messageType "{" {field | group | emptyStatement} "}"
    fn next_extend_opt(&mut self) -> anyhow::Result<Option<Vec<WithLoc<Extension>>>> {
        let mut clone = self.clone();
        if clone.tokenizer.next_ident_if_eq("extend")? {
            // According to spec `extend` is only for `proto2`, but it is used in `proto3`
            // https://github.com/google/protobuf/issues/4610

            *self = clone;

            let extendee = self.next_message_or_enum_type()?;

            let mode = match self.syntax {
                Syntax::Proto2 => MessageBodyParseMode::ExtendProto2,
                Syntax::Proto3 => MessageBodyParseMode::ExtendProto3,
            };

            let MessageBody { fields, .. } = self.next_message_body(mode)?;

            // TODO: is oneof allowed in extend?
            let fields: Vec<WithLoc<Field>> = fields
                .into_iter()
                .map(|fo| match fo.t {
                    FieldOrOneOf::Field(f) => Ok(f),
                    FieldOrOneOf::OneOf(_) => Err(ParserError::OneOfInExtend),
                })
                .collect::<Result<_, ParserError>>()?;

            let extensions = fields
                .into_iter()
                .map(|field| {
                    let extendee = extendee.clone();
                    let loc = field.loc;
                    let extension = Extension { extendee, field };
                    WithLoc { t: extension, loc }
                })
                .collect();

            Ok(Some(extensions))
        } else {
            Ok(None)
        }
    }

    // Service definition

    fn next_options_or_colon(&mut self) -> anyhow::Result<Vec<ProtobufOption>> {
        let mut options = Vec::new();
        if self.tokenizer.next_symbol_if_eq('{')? {
            while self.tokenizer.lookahead_if_symbol()? != Some('}') {
                if let Some(option) = self.next_option_opt()? {
                    options.push(option);
                    continue;
                }

                if let Some(()) = self.next_empty_statement_opt()? {
                    continue;
                }

                return Err(ParserError::IncorrectInput.into());
            }
            self.tokenizer.next_symbol_expect_eq('}', "option")?;
        } else {
            self.tokenizer.next_symbol_expect_eq(';', "option")?;
        }

        Ok(options)
    }

    // stream = "stream" streamName "(" messageType "," messageType ")"
    //        (( "{" { option | emptyStatement } "}") | ";" )
    fn next_stream_opt(&mut self) -> anyhow::Result<Option<Method>> {
        assert_eq!(Syntax::Proto2, self.syntax);
        if self.tokenizer.next_ident_if_eq("stream")? {
            let name = self.tokenizer.next_ident()?;
            self.tokenizer.next_symbol_expect_eq('(', "stream")?;
            let input_type = self.next_message_or_enum_type()?;
            self.tokenizer.next_symbol_expect_eq(',', "stream")?;
            let output_type = self.next_message_or_enum_type()?;
            self.tokenizer.next_symbol_expect_eq(')', "stream")?;
            let options = self.next_options_or_colon()?;
            Ok(Some(Method {
                name,
                input_type,
                output_type,
                client_streaming: true,
                server_streaming: true,
                options,
            }))
        } else {
            Ok(None)
        }
    }

    // rpc = "rpc" rpcName "(" [ "stream" ] messageType ")"
    //     "returns" "(" [ "stream" ] messageType ")"
    //     (( "{" { option | emptyStatement } "}" ) | ";" )
    fn next_rpc_opt(&mut self) -> anyhow::Result<Option<Method>> {
        if self.tokenizer.next_ident_if_eq("rpc")? {
            let name = self.tokenizer.next_ident()?;
            self.tokenizer.next_symbol_expect_eq('(', "rpc")?;
            let client_streaming = self.tokenizer.next_ident_if_eq("stream")?;
            let input_type = self.next_message_or_enum_type()?;
            self.tokenizer.next_symbol_expect_eq(')', "rpc")?;
            self.tokenizer.next_ident_expect_eq("returns")?;
            self.tokenizer.next_symbol_expect_eq('(', "rpc")?;
            let server_streaming = self.tokenizer.next_ident_if_eq("stream")?;
            let output_type = self.next_message_or_enum_type()?;
            self.tokenizer.next_symbol_expect_eq(')', "rpc")?;
            let options = self.next_options_or_colon()?;
            Ok(Some(Method {
                name,
                input_type,
                output_type,
                client_streaming,
                server_streaming,
                options,
            }))
        } else {
            Ok(None)
        }
    }

    // proto2:
    // service = "service" serviceName "{" { option | rpc | stream | emptyStatement } "}"
    //
    // proto3:
    // service = "service" serviceName "{" { option | rpc | emptyStatement } "}"
    fn next_service_opt(&mut self) -> anyhow::Result<Option<WithLoc<Service>>> {
        let loc = self.tokenizer.lookahead_loc();

        if self.tokenizer.next_ident_if_eq("service")? {
            let name = self.tokenizer.next_ident()?;
            let mut methods = Vec::new();
            let mut options = Vec::new();
            self.tokenizer.next_symbol_expect_eq('{', "service")?;
            while self.tokenizer.lookahead_if_symbol()? != Some('}') {
                if let Some(method) = self.next_rpc_opt()? {
                    methods.push(method);
                    continue;
                }

                if self.syntax == Syntax::Proto2 {
                    if let Some(method) = self.next_stream_opt()? {
                        methods.push(method);
                        continue;
                    }
                }

                if let Some(o) = self.next_option_opt()? {
                    options.push(o);
                    continue;
                }

                if let Some(()) = self.next_empty_statement_opt()? {
                    continue;
                }

                return Err(ParserError::IncorrectInput.into());
            }
            self.tokenizer.next_symbol_expect_eq('}', "service")?;
            Ok(Some(WithLoc {
                loc,
                t: Service {
                    name,
                    methods,
                    options,
                },
            }))
        } else {
            Ok(None)
        }
    }

    // Proto file

    // proto = syntax { import | package | option | topLevelDef | emptyStatement }
    // topLevelDef = message | enum | extend | service
    pub fn next_proto(&mut self) -> anyhow::Result<FileDescriptor> {
        let syntax = self.next_syntax()?.unwrap_or(Syntax::Proto2);
        self.syntax = syntax;

        let mut imports = Vec::new();
        let mut package = ProtobufAbsPath::root();
        let mut messages = Vec::new();
        let mut enums = Vec::new();
        let mut extensions = Vec::new();
        let mut options = Vec::new();
        let mut services = Vec::new();

        while !self.tokenizer.syntax_eof()? {
            if let Some(import) = self.next_import_opt()? {
                imports.push(import);
                continue;
            }

            if let Some(next_package) = self.next_package_opt()? {
                package = next_package;
                continue;
            }

            if let Some(option) = self.next_option_opt()? {
                options.push(option);
                continue;
            }

            if let Some(message) = self.next_message_opt()? {
                messages.push(message);
                continue;
            }

            if let Some(enumeration) = self.next_enum_opt()? {
                enums.push(enumeration);
                continue;
            }

            if let Some(more_extensions) = self.next_extend_opt()? {
                extensions.extend(more_extensions);
                continue;
            }

            if let Some(service) = self.next_service_opt()? {
                services.push(service);
                continue;
            }

            if self.tokenizer.next_symbol_if_eq(';')? {
                continue;
            }

            return Err(ParserError::IncorrectInput.into());
        }

        Ok(FileDescriptor {
            imports,
            package,
            syntax,
            messages,
            enums,
            extensions,
            services,
            options,
        })
    }
}

#[cfg(test)]
mod test {
    use super::*;

    fn parse<P, R>(input: &str, parse_what: P) -> R
    where
        P: FnOnce(&mut Parser) -> anyhow::Result<R>,
    {
        let mut parser = Parser::new(input);
        let r =
            parse_what(&mut parser).expect(&format!("parse failed at {}", parser.tokenizer.loc()));
        let eof = parser
            .tokenizer
            .syntax_eof()
            .expect(&format!("check eof failed at {}", parser.tokenizer.loc()));
        assert!(eof, "{}", parser.tokenizer.loc());
        r
    }

    fn parse_opt<P, R>(input: &str, parse_what: P) -> R
    where
        P: FnOnce(&mut Parser) -> anyhow::Result<Option<R>>,
    {
        let mut parser = Parser::new(input);
        let o =
            parse_what(&mut parser).expect(&format!("parse failed at {}", parser.tokenizer.loc()));
        let r = o.expect(&format!(
            "parser returned none at {}",
            parser.tokenizer.loc()
        ));
        assert!(parser.tokenizer.syntax_eof().unwrap());
        r
    }

    #[test]
    fn test_syntax() {
        let msg = r#"  syntax = "proto3";  "#;
        let mess = parse_opt(msg, |p| p.next_syntax());
        assert_eq!(Syntax::Proto3, mess);
    }

    #[test]
    fn test_field_default_value_int() {
        let msg = r#"  optional int64 f = 4 [default = 12];  "#;
        let mess = parse(msg, |p| p.next_field(MessageBodyParseMode::MessageProto2));
        assert_eq!("f", mess.t.name);
        assert_eq!(
            ProtobufOptionName::simple("default"),
            mess.t.options[0].name
        );
        assert_eq!("12", mess.t.options[0].value.format());
    }

    #[test]
    fn test_field_default_value_float() {
        let msg = r#"  optional float f = 2 [default = 10.0];  "#;
        let mess = parse(msg, |p| p.next_field(MessageBodyParseMode::MessageProto2));
        assert_eq!("f", mess.t.name);
        assert_eq!(
            ProtobufOptionName::simple("default"),
            mess.t.options[0].name
        );
        assert_eq!("10", mess.t.options[0].value.format());
    }

    #[test]
    fn test_message() {
        let msg = r#"message ReferenceData
    {
        repeated ScenarioInfo  scenarioSet = 1;
        repeated CalculatedObjectInfo calculatedObjectSet = 2;
        repeated RiskFactorList riskFactorListSet = 3;
        repeated RiskMaturityInfo riskMaturitySet = 4;
        repeated IndicatorInfo indicatorSet = 5;
        repeated RiskStrikeInfo riskStrikeSet = 6;
        repeated FreeProjectionList freeProjectionListSet = 7;
        repeated ValidationProperty ValidationSet = 8;
        repeated CalcProperties calcPropertiesSet = 9;
        repeated MaturityInfo maturitySet = 10;
    }"#;

        let mess = parse_opt(msg, |p| p.next_message_opt());
        assert_eq!(10, mess.t.fields.len());
    }

    #[test]
    fn test_enum() {
        let msg = r#"enum PairingStatus {
                DEALPAIRED        = 0;
                INVENTORYORPHAN   = 1;
                CALCULATEDORPHAN  = 2;
                CANCELED          = 3;
    }"#;

        let enumeration = parse_opt(msg, |p| p.next_enum_opt());
        assert_eq!(4, enumeration.values.len());
    }

    #[test]
    fn test_ignore() {
        let msg = r#"option optimize_for = SPEED;"#;

        parse_opt(msg, |p| p.next_option_opt());
    }

    #[test]
    fn test_import() {
        let msg = r#"syntax = "proto3";

    import "test_import_nested_imported_pb.proto";

    message ContainsImportedNested {
        ContainerForNested.NestedMessage m = 1;
        ContainerForNested.NestedEnum e = 2;
    }
    "#;
        let desc = parse(msg, |p| p.next_proto());

        assert_eq!(
            vec!["test_import_nested_imported_pb.proto"],
            desc.imports
                .into_iter()
                .map(|i| i.path.to_str().to_owned())
                .collect::<Vec<_>>()
        );
    }

    #[test]
    fn test_nested_message() {
        let msg = r#"message A
    {
        message B {
            repeated int32 a = 1;
            optional string b = 2;
        }
        optional string b = 1;
    }"#;

        let mess = parse_opt(msg, |p| p.next_message_opt());
        assert_eq!(1, mess.t.messages.len());
    }

    #[test]
    fn test_map() {
        let msg = r#"message A
    {
        optional map<string, int32> b = 1;
    }"#;

        let mess = parse_opt(msg, |p| p.next_message_opt());
        assert_eq!(1, mess.t.fields.len());
        match mess.t.regular_fields_for_test()[0].typ {
            FieldType::Map(ref f) => match &**f {
                &(FieldType::String, FieldType::Int32) => (),
                ref f => panic!("Expecting Map<String, Int32> found {:?}", f),
            },
            ref f => panic!("Expecting map, got {:?}", f),
        }
    }

    #[test]
    fn test_oneof() {
        let msg = r#"message A
    {
        optional int32 a1 = 1;
        oneof a_oneof {
            string a2 = 2;
            int32 a3 = 3;
            bytes a4 = 4;
        }
        repeated bool a5 = 5;
    }"#;

        let mess = parse_opt(msg, |p| p.next_message_opt());
        assert_eq!(1, mess.t.oneofs().len());
        assert_eq!(3, mess.t.oneofs()[0].fields.len());
    }

    #[test]
    fn test_reserved() {
        let msg = r#"message Sample {
       reserved 4, 15, 17 to 20, 30;
       reserved "foo", "bar";
       optional uint64 age =1;
       required bytes name =2;
    }"#;

        let mess = parse_opt(msg, |p| p.next_message_opt());
        assert_eq!(
            vec![
                FieldNumberRange { from: 4, to: 4 },
                FieldNumberRange { from: 15, to: 15 },
                FieldNumberRange { from: 17, to: 20 },
                FieldNumberRange { from: 30, to: 30 }
            ],
            mess.t.reserved_nums
        );
        assert_eq!(
            vec!["foo".to_string(), "bar".to_string()],
            mess.t.reserved_names
        );
        assert_eq!(2, mess.t.fields.len());
    }

    #[test]
    fn test_default_value_int() {
        let msg = r#"message Sample {
            optional int32 x = 1 [default = 17];
        }"#;

        let mess = parse_opt(msg, |p| p.next_message_opt());
        assert_eq!(
            ProtobufOptionName::simple("default"),
            mess.t.regular_fields_for_test()[0].options[0].name
        );
        assert_eq!(
            "17",
            mess.t.regular_fields_for_test()[0].options[0]
                .value
                .format()
        );
    }

    #[test]
    fn test_default_value_string() {
        let msg = r#"message Sample {
            optional string x = 1 [default = "ab\nc d\"g\'h\0\"z"];
        }"#;

        let mess = parse_opt(msg, |p| p.next_message_opt());
        assert_eq!(
            r#""ab\nc d\"g\'h\0\"z""#,
            mess.t.regular_fields_for_test()[0].options[0]
                .value
                .format()
        );
    }

    #[test]
    fn test_default_value_bytes() {
        let msg = r#"message Sample {
            optional bytes x = 1 [default = "ab\nc d\xfeE\"g\'h\0\"z"];
        }"#;

        let mess = parse_opt(msg, |p| p.next_message_opt());
        assert_eq!(
            r#""ab\nc d\xfeE\"g\'h\0\"z""#,
            mess.t.regular_fields_for_test()[0].options[0]
                .value
                .format()
        );
    }

    #[test]
    fn test_group() {
        let msg = r#"message MessageWithGroup {
            optional string aaa = 1;

            repeated group Identifier = 18 {
                optional int32 iii = 19;
                optional string sss = 20;
            }

            required int bbb = 3;
        }"#;
        let mess = parse_opt(msg, |p| p.next_message_opt());

        assert_eq!("identifier", mess.t.regular_fields_for_test()[1].name);
        if let FieldType::Group(Group { fields, .. }) = &mess.t.regular_fields_for_test()[1].typ {
            assert_eq!(2, fields.len());
        } else {
            panic!("expecting group");
        }

        assert_eq!("bbb", mess.t.regular_fields_for_test()[2].name);
    }

    #[test]
    fn test_incorrect_file_descriptor() {
        let msg = r#"
            message Foo {}

            dfgdg
        "#;

        let err = FileDescriptor::parse(msg).err().expect("err");
        assert_eq!(4, err.line);
    }
}

'''
'''--- protobuf-parse/src/rel_path.rs ---
use std::ops::Deref;
use std::path::Path;
use std::path::PathBuf;

/// Wrapper for `Path` that asserts that the path is relative.
#[repr(transparent)]
pub(crate) struct RelPath {
    path: Path,
}

/// Wrapper for `PathBuf` that asserts that the path is relative.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub(crate) struct RelPathBuf {
    path: PathBuf,
}

impl RelPath {
    pub(crate) fn new(path: &Path) -> &RelPath {
        assert!(
            !path.is_absolute(),
            "path must be relative: {}",
            path.display()
        );
        unsafe { &*(path as *const Path as *const RelPath) }
    }

    pub(crate) fn _to_owned(&self) -> RelPathBuf {
        RelPathBuf {
            path: self.path.to_owned(),
        }
    }
}

impl RelPathBuf {
    pub(crate) fn _new(path: PathBuf) -> RelPathBuf {
        assert!(
            !path.is_absolute(),
            "path must be relative: {}",
            path.display()
        );
        RelPathBuf { path }
    }
}

impl Deref for RelPath {
    type Target = Path;

    fn deref(&self) -> &Self::Target {
        &self.path
    }
}

impl Deref for RelPathBuf {
    type Target = RelPath;

    fn deref(&self) -> &Self::Target {
        RelPath::new(&self.path)
    }
}

'''
'''--- protobuf-parse/src/test_against_protobuf_protos.rs ---
#![cfg(test)]

use std::fs;
use std::io::Read;
use std::path::Path;

use anyhow::Context;

use crate::model;

fn parse_recursively(path: &Path) {
    assert!(path.exists());

    let file_name = path
        .file_name()
        .expect("file_name")
        .to_str()
        .expect("to_str");
    if path.is_dir() {
        for entry in fs::read_dir(path).expect("read_dir") {
            parse_recursively(&entry.expect("entry").path());
        }
    } else if file_name.ends_with(".proto") {
        println!("checking {}", path.display());
        let mut content = String::new();
        fs::File::open(path)
            .expect("open")
            .read_to_string(&mut content)
            .expect("read");
        model::FileDescriptor::parse(&content)
            .with_context(|| format!("testing `{}`", path.display()))
            .expect("parse");
    }
}

#[test]
fn test() {
    let path = &Path::new("../google-protobuf-all-protos/protobuf");
    parse_recursively(&Path::new(path));
}

'''
'''--- protobuf-parse/src/which_parser.rs ---
/// Which parse to use to parse `.proto` files.
#[derive(Debug, Copy, Clone)]
pub(crate) enum WhichParser {
    /// Pure Rust parser implemented by this crate.
    Pure,
    /// Parse `.proto` files using `protoc --descriptor_set_out=...` command.
    Protoc,
}

impl Default for WhichParser {
    fn default() -> Self {
        WhichParser::Pure
    }
}

'''
'''--- protobuf-parse/tests/bundled_proto_consistent.rs ---
use std::fs;
use std::path::Path;
use std::path::PathBuf;

fn list_dir(p: &Path) -> Vec<PathBuf> {
    let mut children = fs::read_dir(p)
        .unwrap()
        .map(|r| r.map(|e| e.path()))
        .collect::<Result<Vec<_>, _>>()
        .unwrap();
    children.sort();
    children
}

fn assert_equal_recursively(a: &Path, b: &Path) {
    assert_eq!(a.is_dir(), b.is_dir(), "{} {}", a.display(), b.display());
    assert_eq!(a.is_file(), b.is_file(), "{} {}", a.display(), b.display());
    if a.is_dir() {
        let mut a_contents = list_dir(a).into_iter();
        let mut b_contents = list_dir(b).into_iter();
        loop {
            let a_child = a_contents.next();
            let b_child = b_contents.next();
            match (a_child, b_child) {
                (Some(a_child), Some(b_child)) => {
                    assert_eq!(a_child.file_name(), b_child.file_name());
                    assert_equal_recursively(&a_child, &b_child);
                }
                (None, None) => break,
                _ => panic!(
                    "mismatched directories: {} and {}",
                    a.display(),
                    b.display()
                ),
            }
        }
    } else {
        let a_contents = fs::read_to_string(a).unwrap();
        let b_contents = fs::read_to_string(b).unwrap();
        assert_eq!(a_contents, b_contents);
    }
}

#[test]
fn test_bundled_google_proto_files_consistent() {
    let source = "../proto/google";
    let our_copy = "src/proto/google";
    assert_equal_recursively(Path::new(source), Path::new(our_copy));
}

#[test]
fn test_bundled_rustproto_proto_consistent() {
    let source = "../proto/rustproto.proto";
    let our_copy = "src/proto/rustproto.proto";
    assert_equal_recursively(Path::new(source), Path::new(our_copy));
}

'''
'''--- protobuf-support/Cargo.toml ---
[package]

name = "protobuf-support"
version = "4.0.0-alpha.0"
authors = ["Stepan Koltsov <stepan.koltsov@gmail.com>"]
edition = "2021"
license = "MIT"
homepage = "https://github.com/stepancheg/rust-protobuf/"
repository = "https://github.com/stepancheg/rust-protobuf/"
documentation = "https://github.com/stepancheg/rust-protobuf/blob/master/README.md"
description = """
Code supporting protobuf implementation. None of code in this crate is public API.
"""

[lib]
bench = false

[features]

[dependencies]
thiserror = "1.0.30"

[package.metadata.docs.rs]
all-features = true

'''
'''--- protobuf-support/README.md ---
<!-- cargo-sync-readme start -->

# Supporting code for protobuf crates

Code in this crate is used in protobuf crates like `protobuf` or `protobuf-parse`.
None of code in this crate has public API.

<!-- cargo-sync-readme end -->

'''
'''--- protobuf-support/src/json_name.rs ---
/// Implementation must match exactly
/// `ToJsonName()` function in C++ `descriptor.cc`.
pub fn json_name(input: &str) -> String {
    let mut capitalize_next = false;
    let mut result = String::with_capacity(input.len());

    for c in input.chars() {
        if c == '_' {
            capitalize_next = true;
        } else if capitalize_next {
            result.extend(c.to_uppercase());
            capitalize_next = false;
        } else {
            result.push(c);
        }
    }

    result
}

'''
'''--- protobuf-support/src/lexer/float.rs ---
#[derive(Debug)]
pub enum ProtobufFloatParseError {
    EmptyString,
    CannotParseFloat,
}

pub type ProtobufFloatParseResult<T> = Result<T, ProtobufFloatParseError>;

pub const PROTOBUF_NAN: &str = "nan";
pub const PROTOBUF_INF: &str = "inf";

/// Format float as in protobuf `.proto` files
pub fn format_protobuf_float(f: f64) -> String {
    if f.is_nan() {
        PROTOBUF_NAN.to_owned()
    } else if f.is_infinite() {
        if f > 0.0 {
            format!("{}", PROTOBUF_INF)
        } else {
            format!("-{}", PROTOBUF_INF)
        }
    } else {
        // TODO: make sure doesn't lose precision
        format!("{}", f)
    }
}

/// Parse float from `.proto` format
pub fn parse_protobuf_float(s: &str) -> ProtobufFloatParseResult<f64> {
    if s.is_empty() {
        return Err(ProtobufFloatParseError::EmptyString);
    }
    if s == PROTOBUF_NAN {
        return Ok(f64::NAN);
    }
    if s == PROTOBUF_INF || s == format!("+{}", PROTOBUF_INF) {
        return Ok(f64::INFINITY);
    }
    if s == format!("-{}", PROTOBUF_INF) {
        return Ok(f64::NEG_INFINITY);
    }
    match s.parse() {
        Ok(f) => Ok(f),
        Err(_) => Err(ProtobufFloatParseError::CannotParseFloat),
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_format_protobuf_float() {
        assert_eq!("10", format_protobuf_float(10.0));
    }
}

'''
'''--- protobuf-support/src/lexer/int.rs ---
pub struct Overflow;

/// Negate `u64` checking for overflow.
pub fn neg(value: u64) -> Result<i64, Overflow> {
    if value <= 0x7fff_ffff_ffff_ffff {
        Ok(-(value as i64))
    } else if value == 0x8000_0000_0000_0000 {
        Ok(-0x8000_0000_0000_0000)
    } else {
        Err(Overflow)
    }
}

'''
'''--- protobuf-support/src/lexer/json_number_lit.rs ---
use std::fmt;

#[derive(Clone, Debug, Eq, PartialEq)]
pub struct JsonNumberLit(pub String);

impl fmt::Display for JsonNumberLit {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self.0, f)
    }
}

'''
'''--- protobuf-support/src/lexer/lexer_impl.rs ---
use std::char;
use std::convert::TryFrom;
use std::num::ParseFloatError;
use std::num::ParseIntError;

use crate::lexer::float;
use crate::lexer::float::ProtobufFloatParseError;
use crate::lexer::json_number_lit::JsonNumberLit;
use crate::lexer::loc::Loc;
use crate::lexer::loc::FIRST_COL;
use crate::lexer::parser_language::ParserLanguage;
use crate::lexer::str_lit::StrLit;
use crate::lexer::str_lit::StrLitDecodeError;
use crate::lexer::token::Token;
use crate::lexer::token::TokenWithLocation;

#[derive(Debug, thiserror::Error)]
pub enum LexerError {
    // TODO: something better than this
    #[error("Incorrect input")]
    IncorrectInput,
    #[error("Unexpected EOF")]
    UnexpectedEof,
    #[error("Expecting char: {:?}", .0)]
    ExpectChar(char),
    #[error("Parse int error")]
    ParseIntError,
    #[error("Parse float error")]
    ParseFloatError,
    // TODO: how it is different from ParseFloatError?
    #[error("Incorrect float literal")]
    IncorrectFloatLit,
    #[error("Incorrect JSON escape")]
    IncorrectJsonEscape,
    #[error("Incorrect JSON number")]
    IncorrectJsonNumber,
    #[error("Incorrect Unicode character")]
    IncorrectUnicodeChar,
    #[error("Expecting hex digit")]
    ExpectHexDigit,
    #[error("Expecting oct digit")]
    ExpectOctDigit,
    #[error("Expecting dec digit")]
    ExpectDecDigit,
    #[error(transparent)]
    StrLitDecodeError(#[from] StrLitDecodeError),
    #[error("Expecting identifier")]
    ExpectedIdent,
}

pub type LexerResult<T> = Result<T, LexerError>;

impl From<ParseIntError> for LexerError {
    fn from(_: ParseIntError) -> Self {
        LexerError::ParseIntError
    }
}

impl From<ParseFloatError> for LexerError {
    fn from(_: ParseFloatError) -> Self {
        LexerError::ParseFloatError
    }
}

impl From<ProtobufFloatParseError> for LexerError {
    fn from(_: ProtobufFloatParseError) -> Self {
        LexerError::IncorrectFloatLit
    }
}

#[derive(Copy, Clone)]
pub struct Lexer<'a> {
    language: ParserLanguage,
    input: &'a str,
    pos: usize,
    pub loc: Loc,
}

fn is_letter(c: char) -> bool {
    c.is_alphabetic() || c == '_'
}

impl<'a> Lexer<'a> {
    pub fn new(input: &'a str, language: ParserLanguage) -> Lexer<'a> {
        Lexer {
            language,
            input,
            pos: 0,
            loc: Loc::start(),
        }
    }

    /// No more chars
    pub fn eof(&self) -> bool {
        self.pos == self.input.len()
    }

    /// Remaining chars
    fn rem_chars(&self) -> &'a str {
        &self.input[self.pos..]
    }

    pub fn lookahead_char_is<P: FnOnce(char) -> bool>(&self, p: P) -> bool {
        self.lookahead_char().map_or(false, p)
    }

    fn lookahead_char_is_in(&self, alphabet: &str) -> bool {
        self.lookahead_char_is(|c| alphabet.contains(c))
    }

    fn next_char_opt(&mut self) -> Option<char> {
        let rem = self.rem_chars();
        if rem.is_empty() {
            None
        } else {
            let mut char_indices = rem.char_indices();
            let (_, c) = char_indices.next().unwrap();
            let c_len = char_indices.next().map(|(len, _)| len).unwrap_or(rem.len());
            self.pos += c_len;
            if c == '\n' {
                self.loc.line += 1;
                self.loc.col = FIRST_COL;
            } else {
                self.loc.col += 1;
            }
            Some(c)
        }
    }

    fn next_char(&mut self) -> LexerResult<char> {
        self.next_char_opt().ok_or(LexerError::UnexpectedEof)
    }

    /// Skip whitespaces
    fn skip_whitespaces(&mut self) {
        self.take_while(|c| c.is_whitespace());
    }

    fn skip_c_comment(&mut self) -> LexerResult<()> {
        if self.skip_if_lookahead_is_str("/*") {
            let end = "*/";
            match self.rem_chars().find(end) {
                None => Err(LexerError::UnexpectedEof),
                Some(len) => {
                    let new_pos = self.pos + len + end.len();
                    self.skip_to_pos(new_pos);
                    Ok(())
                }
            }
        } else {
            Ok(())
        }
    }

    fn skip_cpp_comment(&mut self) {
        if self.skip_if_lookahead_is_str("//") {
            loop {
                match self.next_char_opt() {
                    Some('\n') | None => break,
                    _ => {}
                }
            }
        }
    }

    fn skip_sh_comment(&mut self) {
        if self.skip_if_lookahead_is_str("#") {
            loop {
                match self.next_char_opt() {
                    Some('\n') | None => break,
                    _ => {}
                }
            }
        }
    }

    fn skip_comment(&mut self) -> LexerResult<()> {
        match self.language {
            ParserLanguage::Proto => {
                self.skip_c_comment()?;
                self.skip_cpp_comment();
            }
            ParserLanguage::TextFormat => {
                self.skip_sh_comment();
            }
            ParserLanguage::Json => {}
        }
        Ok(())
    }

    pub fn skip_ws(&mut self) -> LexerResult<()> {
        loop {
            let pos = self.pos;
            self.skip_whitespaces();
            self.skip_comment()?;
            if pos == self.pos {
                // Did not advance
                return Ok(());
            }
        }
    }

    pub fn take_while<F>(&mut self, f: F) -> &'a str
    where
        F: Fn(char) -> bool,
    {
        let start = self.pos;
        while self.lookahead_char().map(&f) == Some(true) {
            self.next_char_opt().unwrap();
        }
        let end = self.pos;
        &self.input[start..end]
    }

    fn lookahead_char(&self) -> Option<char> {
        self.clone().next_char_opt()
    }

    fn lookahead_is_str(&self, s: &str) -> bool {
        self.rem_chars().starts_with(s)
    }

    fn skip_if_lookahead_is_str(&mut self, s: &str) -> bool {
        if self.lookahead_is_str(s) {
            let new_pos = self.pos + s.len();
            self.skip_to_pos(new_pos);
            true
        } else {
            false
        }
    }

    fn next_char_if<P>(&mut self, p: P) -> Option<char>
    where
        P: FnOnce(char) -> bool,
    {
        let mut clone = self.clone();
        match clone.next_char_opt() {
            Some(c) if p(c) => {
                *self = clone;
                Some(c)
            }
            _ => None,
        }
    }

    pub fn next_char_if_eq(&mut self, expect: char) -> bool {
        self.next_char_if(|c| c == expect) != None
    }

    fn next_char_if_in(&mut self, alphabet: &str) -> Option<char> {
        for c in alphabet.chars() {
            if self.next_char_if_eq(c) {
                return Some(c);
            }
        }
        None
    }

    fn next_char_expect_eq(&mut self, expect: char) -> LexerResult<()> {
        if self.next_char_if_eq(expect) {
            Ok(())
        } else {
            Err(LexerError::ExpectChar(expect))
        }
    }

    fn next_char_expect<P>(&mut self, expect: P, err: LexerError) -> LexerResult<char>
    where
        P: FnOnce(char) -> bool,
    {
        self.next_char_if(expect).ok_or(err)
    }

    // str functions

    /// properly update line and column
    fn skip_to_pos(&mut self, new_pos: usize) -> &'a str {
        assert!(new_pos >= self.pos);
        assert!(new_pos <= self.input.len());
        let pos = self.pos;
        while self.pos != new_pos {
            self.next_char_opt().unwrap();
        }
        &self.input[pos..new_pos]
    }

    // Protobuf grammar

    // char functions

    // letter = "A" … "Z" | "a" … "z"
    // https://github.com/google/protobuf/issues/4565
    fn next_letter_opt(&mut self) -> Option<char> {
        self.next_char_if(is_letter)
    }

    // capitalLetter =  "A" … "Z"
    fn _next_capital_letter_opt(&mut self) -> Option<char> {
        self.next_char_if(|c| c >= 'A' && c <= 'Z')
    }

    fn next_ident_part(&mut self) -> Option<char> {
        self.next_char_if(|c| c.is_ascii_alphanumeric() || c == '_')
    }

    // Identifiers

    // ident = letter { letter | decimalDigit | "_" }
    fn next_ident_opt(&mut self) -> LexerResult<Option<String>> {
        if let Some(c) = self.next_letter_opt() {
            let mut ident = String::new();
            ident.push(c);
            while let Some(c) = self.next_ident_part() {
                ident.push(c);
            }
            Ok(Some(ident))
        } else {
            Ok(None)
        }
    }

    // Integer literals

    // hexLit     = "0" ( "x" | "X" ) hexDigit { hexDigit }
    fn next_hex_lit_opt(&mut self) -> LexerResult<Option<u64>> {
        Ok(
            if self.skip_if_lookahead_is_str("0x") || self.skip_if_lookahead_is_str("0X") {
                let s = self.take_while(|c| c.is_ascii_hexdigit());
                Some(u64::from_str_radix(s, 16)? as u64)
            } else {
                None
            },
        )
    }

    // decimalLit = ( "1" … "9" ) { decimalDigit }
    // octalLit   = "0" { octalDigit }
    fn next_decimal_octal_lit_opt(&mut self) -> LexerResult<Option<u64>> {
        // do not advance on number parse error
        let mut clone = self.clone();

        let pos = clone.pos;

        Ok(if clone.next_char_if(|c| c.is_ascii_digit()) != None {
            clone.take_while(|c| c.is_ascii_digit());
            let value = clone.input[pos..clone.pos].parse()?;
            *self = clone;
            Some(value)
        } else {
            None
        })
    }

    // hexDigit     = "0" … "9" | "A" … "F" | "a" … "f"
    fn next_hex_digit(&mut self) -> LexerResult<u32> {
        let mut clone = self.clone();
        let r = match clone.next_char()? {
            c if c >= '0' && c <= '9' => c as u32 - b'0' as u32,
            c if c >= 'A' && c <= 'F' => c as u32 - b'A' as u32 + 10,
            c if c >= 'a' && c <= 'f' => c as u32 - b'a' as u32 + 10,
            _ => return Err(LexerError::ExpectHexDigit),
        };
        *self = clone;
        Ok(r)
    }

    // octalDigit   = "0" … "7"
    fn next_octal_digit(&mut self) -> LexerResult<u32> {
        self.next_char_expect(|c| c >= '0' && c <= '9', LexerError::ExpectOctDigit)
            .map(|c| c as u32 - '0' as u32)
    }

    // decimalDigit = "0" … "9"
    fn next_decimal_digit(&mut self) -> LexerResult<u32> {
        self.next_char_expect(|c| c >= '0' && c <= '9', LexerError::ExpectDecDigit)
            .map(|c| c as u32 - '0' as u32)
    }

    // decimals  = decimalDigit { decimalDigit }
    fn next_decimal_digits(&mut self) -> LexerResult<()> {
        self.next_decimal_digit()?;
        self.take_while(|c| c >= '0' && c <= '9');
        Ok(())
    }

    // intLit     = decimalLit | octalLit | hexLit
    pub fn next_int_lit_opt(&mut self) -> LexerResult<Option<u64>> {
        assert_ne!(ParserLanguage::Json, self.language);

        self.skip_ws()?;
        if let Some(i) = self.next_hex_lit_opt()? {
            return Ok(Some(i));
        }
        if let Some(i) = self.next_decimal_octal_lit_opt()? {
            return Ok(Some(i));
        }
        Ok(None)
    }

    // Floating-point literals

    // exponent  = ( "e" | "E" ) [ "+" | "-" ] decimals
    fn next_exponent_opt(&mut self) -> LexerResult<Option<()>> {
        if self.next_char_if_in("eE") != None {
            self.next_char_if_in("+-");
            self.next_decimal_digits()?;
            Ok(Some(()))
        } else {
            Ok(None)
        }
    }

    // floatLit = ( decimals "." [ decimals ] [ exponent ] | decimals exponent | "."decimals [ exponent ] ) | "inf" | "nan"
    fn next_float_lit(&mut self) -> LexerResult<()> {
        assert_ne!(ParserLanguage::Json, self.language);

        // "inf" and "nan" are handled as part of ident
        if self.next_char_if_eq('.') {
            self.next_decimal_digits()?;
            self.next_exponent_opt()?;
        } else {
            self.next_decimal_digits()?;
            if self.next_char_if_eq('.') {
                self.next_decimal_digits()?;
                self.next_exponent_opt()?;
            } else {
                if self.next_exponent_opt()? == None {
                    return Err(LexerError::IncorrectFloatLit);
                }
            }
        }
        Ok(())
    }

    // String literals

    // charValue = hexEscape | octEscape | charEscape | /[^\0\n\\]/
    // hexEscape = '\' ( "x" | "X" ) hexDigit hexDigit
    // https://github.com/google/protobuf/issues/4560
    // octEscape = '\' octalDigit octalDigit octalDigit
    // charEscape = '\' ( "a" | "b" | "f" | "n" | "r" | "t" | "v" | '\' | "'" | '"' )
    // quote = "'" | '"'
    pub fn next_byte_value(&mut self) -> LexerResult<u8> {
        match self.next_char()? {
            '\\' => {
                match self.next_char()? {
                    '\'' => Ok(b'\''),
                    '"' => Ok(b'"'),
                    '\\' => Ok(b'\\'),
                    'a' => Ok(b'\x07'),
                    'b' => Ok(b'\x08'),
                    'f' => Ok(b'\x0c'),
                    'n' => Ok(b'\n'),
                    'r' => Ok(b'\r'),
                    't' => Ok(b'\t'),
                    'v' => Ok(b'\x0b'),
                    'x' => {
                        let d1 = self.next_hex_digit()? as u8;
                        let d2 = self.next_hex_digit()? as u8;
                        Ok(((d1 << 4) | d2) as u8)
                    }
                    d if d >= '0' && d <= '7' => {
                        let mut r = d as u8 - b'0';
                        for _ in 0..2 {
                            match self.next_octal_digit() {
                                Err(_) => break,
                                Ok(d) => r = (r << 3) + d as u8,
                            }
                        }
                        Ok(r)
                    }
                    // https://github.com/google/protobuf/issues/4562
                    // TODO: overflow
                    c => Ok(c as u8),
                }
            }
            '\n' | '\0' => Err(LexerError::IncorrectInput),
            // TODO: check overflow
            c => Ok(c as u8),
        }
    }

    fn char_try_from(i: u32) -> LexerResult<char> {
        char::try_from(i).map_err(|_| LexerError::IncorrectUnicodeChar)
    }

    pub fn next_json_char_value(&mut self) -> LexerResult<char> {
        match self.next_char()? {
            '\\' => match self.next_char()? {
                '"' => Ok('"'),
                '\'' => Ok('\''),
                '\\' => Ok('\\'),
                '/' => Ok('/'),
                'b' => Ok('\x08'),
                'f' => Ok('\x0c'),
                'n' => Ok('\n'),
                'r' => Ok('\r'),
                't' => Ok('\t'),
                'u' => {
                    let mut v = 0;
                    for _ in 0..4 {
                        let digit = self.next_hex_digit()?;
                        v = v * 16 + digit;
                    }
                    Self::char_try_from(v)
                }
                _ => Err(LexerError::IncorrectJsonEscape),
            },
            c => Ok(c),
        }
    }

    // https://github.com/google/protobuf/issues/4564
    // strLit = ( "'" { charValue } "'" ) | ( '"' { charValue } '"' )
    fn next_str_lit_raw(&mut self) -> LexerResult<String> {
        let mut raw = String::new();

        let mut first = true;
        loop {
            if !first {
                self.skip_ws()?;
            }

            let start = self.pos;

            let q = match self.next_char_if_in("'\"") {
                Some(q) => q,
                None if !first => break,
                None => return Err(LexerError::IncorrectInput),
            };
            first = false;
            while self.lookahead_char() != Some(q) {
                self.next_byte_value()?;
            }
            self.next_char_expect_eq(q)?;

            raw.push_str(&self.input[start + 1..self.pos - 1]);
        }
        Ok(raw)
    }

    fn next_str_lit_raw_opt(&mut self) -> LexerResult<Option<String>> {
        if self.lookahead_char_is_in("'\"") {
            Ok(Some(self.next_str_lit_raw()?))
        } else {
            Ok(None)
        }
    }

    /// Parse next token as JSON number
    fn next_json_number_opt(&mut self) -> LexerResult<Option<JsonNumberLit>> {
        assert_eq!(ParserLanguage::Json, self.language);

        fn is_digit(c: char) -> bool {
            c >= '0' && c <= '9'
        }

        fn is_digit_1_9(c: char) -> bool {
            c >= '1' && c <= '9'
        }

        if !self.lookahead_char_is_in("-0123456789") {
            return Ok(None);
        }

        let mut s = String::new();
        if self.next_char_if_eq('-') {
            s.push('-');
        }

        if self.next_char_if_eq('0') {
            s.push('0');
        } else {
            s.push(self.next_char_expect(is_digit_1_9, LexerError::IncorrectJsonNumber)?);
            while let Some(c) = self.next_char_if(is_digit) {
                s.push(c);
            }
        }

        if self.next_char_if_eq('.') {
            s.push('.');
            s.push(self.next_char_expect(is_digit, LexerError::IncorrectJsonNumber)?);
            while let Some(c) = self.next_char_if(is_digit) {
                s.push(c);
            }
        }

        if let Some(c) = self.next_char_if_in("eE") {
            s.push(c);
            if let Some(c) = self.next_char_if_in("+-") {
                s.push(c);
            }
            s.push(self.next_char_expect(is_digit, LexerError::IncorrectJsonNumber)?);
            while let Some(c) = self.next_char_if(is_digit) {
                s.push(c);
            }
        }

        Ok(Some(JsonNumberLit(s)))
    }

    fn next_token_inner(&mut self) -> LexerResult<Token> {
        if self.language == ParserLanguage::Json {
            if let Some(v) = self.next_json_number_opt()? {
                return Ok(Token::JsonNumber(v));
            }
        }

        if let Some(ident) = self.next_ident_opt()? {
            let token = if self.language != ParserLanguage::Json && ident == float::PROTOBUF_NAN {
                Token::FloatLit(f64::NAN)
            } else if self.language != ParserLanguage::Json && ident == float::PROTOBUF_INF {
                Token::FloatLit(f64::INFINITY)
            } else {
                Token::Ident(ident.to_owned())
            };
            return Ok(token);
        }

        if self.language != ParserLanguage::Json {
            let mut clone = self.clone();
            let pos = clone.pos;
            if let Ok(_) = clone.next_float_lit() {
                let f = float::parse_protobuf_float(&self.input[pos..clone.pos])?;
                *self = clone;
                return Ok(Token::FloatLit(f));
            }

            if let Some(lit) = self.next_int_lit_opt()? {
                return Ok(Token::IntLit(lit));
            }
        }

        if let Some(escaped) = self.next_str_lit_raw_opt()? {
            return Ok(Token::StrLit(StrLit { escaped }));
        }

        // This branch must be after str lit
        if let Some(c) = self.next_char_if(|c| c.is_ascii_punctuation()) {
            return Ok(Token::Symbol(c));
        }

        if let Some(ident) = self.next_ident_opt()? {
            return Ok(Token::Ident(ident));
        }

        Err(LexerError::IncorrectInput)
    }

    pub fn next_token(&mut self) -> LexerResult<Option<TokenWithLocation>> {
        self.skip_ws()?;
        let loc = self.loc;

        Ok(if self.eof() {
            None
        } else {
            let token = self.next_token_inner()?;
            // Skip whitespace here to update location
            // to the beginning of the next token
            self.skip_ws()?;
            Some(TokenWithLocation { token, loc })
        })
    }
}

#[cfg(test)]
mod test {
    use super::*;

    fn lex<P, R>(input: &str, parse_what: P) -> R
    where
        P: FnOnce(&mut Lexer) -> LexerResult<R>,
    {
        let mut lexer = Lexer::new(input, ParserLanguage::Proto);
        let r = parse_what(&mut lexer).expect(&format!("lexer failed at {}", lexer.loc));
        assert!(lexer.eof(), "check eof failed at {}", lexer.loc);
        r
    }

    fn lex_opt<P, R>(input: &str, parse_what: P) -> R
    where
        P: FnOnce(&mut Lexer) -> LexerResult<Option<R>>,
    {
        let mut lexer = Lexer::new(input, ParserLanguage::Proto);
        let o = parse_what(&mut lexer).expect(&format!("lexer failed at {}", lexer.loc));
        let r = o.expect(&format!("lexer returned none at {}", lexer.loc));
        assert!(lexer.eof(), "check eof failed at {}", lexer.loc);
        r
    }

    #[test]
    fn test_lexer_int_lit() {
        let msg = r#"10"#;
        let mess = lex_opt(msg, |p| p.next_int_lit_opt());
        assert_eq!(10, mess);
    }

    #[test]
    fn test_lexer_float_lit() {
        let msg = r#"12.3"#;
        let mess = lex(msg, |p| p.next_token_inner());
        assert_eq!(Token::FloatLit(12.3), mess);
    }

    #[test]
    fn test_lexer_float_lit_leading_zeros_in_exp() {
        let msg = r#"1e00009"#;
        let mess = lex(msg, |p| p.next_token_inner());
        assert_eq!(Token::FloatLit(1_000_000_000.0), mess);
    }
}

'''
'''--- protobuf-support/src/lexer/loc.rs ---
use std::fmt;

pub const FIRST_LINE: u32 = 1;
pub const FIRST_COL: u32 = 1;

/// Location in file
#[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
pub struct Loc {
    /// 1-based
    pub line: u32,
    /// 1-based
    pub col: u32,
}

impl fmt::Display for Loc {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}:{}", self.line, self.col)
    }
}

impl Loc {
    pub fn start() -> Loc {
        Loc {
            line: FIRST_LINE,
            col: FIRST_COL,
        }
    }
}

'''
'''--- protobuf-support/src/lexer/mod.rs ---
//! Implementation of lexer for both protobuf parser and for text format parser.

pub mod float;
pub mod int;
pub mod json_number_lit;
pub mod lexer_impl;
pub mod loc;
pub mod num_lit;
pub mod parser_language;
pub mod str_lit;
pub mod token;
pub mod tokenizer;

'''
'''--- protobuf-support/src/lexer/num_lit.rs ---
#[derive(Copy, Clone)]
pub enum NumLit {
    U64(u64),
    F64(f64),
}

'''
'''--- protobuf-support/src/lexer/parser_language.rs ---
/// We use the same lexer/tokenizer for all parsers for simplicity
#[derive(Copy, Clone, Debug, Eq, PartialEq)]
pub enum ParserLanguage {
    // `.proto` files
    Proto,
    // Protobuf text format
    TextFormat,
    // JSON
    Json,
}

'''
'''--- protobuf-support/src/lexer/str_lit.rs ---
use std::fmt;
use std::string::FromUtf8Error;

use crate::lexer::lexer_impl::Lexer;
use crate::lexer::parser_language::ParserLanguage;

#[derive(Debug, thiserror::Error)]
pub enum StrLitDecodeError {
    #[error(transparent)]
    FromUtf8Error(#[from] FromUtf8Error),
    #[error("String literal decode error")]
    OtherError,
}

pub type StrLitDecodeResult<T> = Result<T, StrLitDecodeError>;

/// String literal, both `string` and `bytes`.
#[derive(Clone, Eq, PartialEq, Debug)]
pub struct StrLit {
    pub escaped: String,
}

impl fmt::Display for StrLit {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "\"{}\"", &self.escaped)
    }
}

impl StrLit {
    /// May fail if not valid UTF8
    pub fn decode_utf8(&self) -> StrLitDecodeResult<String> {
        let mut lexer = Lexer::new(&self.escaped, ParserLanguage::Json);
        let mut r = Vec::new();
        while !lexer.eof() {
            r.push(
                lexer
                    .next_byte_value()
                    .map_err(|_| StrLitDecodeError::OtherError)?,
            );
        }
        Ok(String::from_utf8(r)?)
    }

    pub fn decode_bytes(&self) -> StrLitDecodeResult<Vec<u8>> {
        let mut lexer = Lexer::new(&self.escaped, ParserLanguage::Json);
        let mut r = Vec::new();
        while !lexer.eof() {
            r.push(
                lexer
                    .next_byte_value()
                    .map_err(|_| StrLitDecodeError::OtherError)?,
            );
        }
        Ok(r)
    }

    pub fn quoted(&self) -> String {
        format!("\"{}\"", self.escaped)
    }
}

#[cfg(test)]
mod test {
    use crate::lexer::str_lit::StrLit;

    #[test]
    fn decode_utf8() {
        assert_eq!(
            "\u{1234}".to_owned(),
            StrLit {
                escaped: "\\341\\210\\264".to_owned()
            }
            .decode_utf8()
            .unwrap()
        )
    }
}

'''
'''--- protobuf-support/src/lexer/token.rs ---
use crate::lexer::json_number_lit::JsonNumberLit;
use crate::lexer::lexer_impl::LexerError;
use crate::lexer::lexer_impl::LexerResult;
use crate::lexer::loc::Loc;
use crate::lexer::num_lit::NumLit;
use crate::lexer::str_lit::StrLit;

#[derive(Clone, Debug, PartialEq)]
pub enum Token {
    Ident(String),
    Symbol(char),
    // Protobuf tokenizer has separate tokens for int and float.
    // Tokens do not include sign.
    IntLit(u64),
    FloatLit(f64),
    JsonNumber(JsonNumberLit),
    // including quotes
    StrLit(StrLit),
}

impl Token {
    /// Back to original
    pub fn format(&self) -> String {
        match self {
            &Token::Ident(ref s) => s.clone(),
            &Token::Symbol(c) => c.to_string(),
            &Token::IntLit(ref i) => i.to_string(),
            &Token::StrLit(ref s) => s.quoted(),
            &Token::FloatLit(ref f) => f.to_string(),
            &Token::JsonNumber(ref f) => f.to_string(),
        }
    }

    pub fn to_num_lit(&self) -> LexerResult<NumLit> {
        match self {
            &Token::IntLit(i) => Ok(NumLit::U64(i)),
            &Token::FloatLit(f) => Ok(NumLit::F64(f)),
            _ => Err(LexerError::IncorrectInput),
        }
    }
}

#[derive(Clone)]
pub struct TokenWithLocation {
    pub token: Token,
    pub loc: Loc,
}

'''
'''--- protobuf-support/src/lexer/tokenizer.rs ---
use crate::lexer::lexer_impl::Lexer;
use crate::lexer::lexer_impl::LexerError;
use crate::lexer::loc::Loc;
use crate::lexer::parser_language::ParserLanguage;
use crate::lexer::str_lit::StrLit;
use crate::lexer::str_lit::StrLitDecodeError;
use crate::lexer::token::Token;
use crate::lexer::token::TokenWithLocation;

#[derive(Debug, thiserror::Error)]
pub enum TokenizerError {
    #[error(transparent)]
    LexerError(#[from] LexerError),
    #[error(transparent)]
    StrLitDecodeError(#[from] StrLitDecodeError),
    #[error("Internal tokenizer error")]
    InternalError,
    // TODO: too broad
    #[error("Incorrect input")]
    IncorrectInput,
    #[error("Not allowed in this context: {0}")]
    NotAllowedInThisContext(&'static str),
    #[error("Unexpected end of input")]
    UnexpectedEof,
    #[error("Expecting string literal")]
    ExpectStrLit,
    #[error("Expecting int literal")]
    ExpectIntLit,
    #[error("Expecting float literal")]
    ExpectFloatLit,
    #[error("Expecting identifier")]
    ExpectIdent,
    #[error("Expecting identifier `{}`", .0)]
    ExpectNamedIdent(String),
    #[error("While parsing {}, expecting char `{}`", .1, .0)]
    ExpectChar(char, &'static str),
    #[error("Expecting any char of: {}", .0.iter().map(|c| format!("`{}`", c)).collect::<Vec<_>>().join(", "))]
    ExpectAnyChar(Vec<char>),
}

pub type TokenizerResult<R> = Result<R, TokenizerError>;

#[derive(Clone)]
pub struct Tokenizer<'a> {
    lexer: Lexer<'a>,
    next_token: Option<TokenWithLocation>,
    last_token_loc: Option<Loc>,
}

impl<'a> Tokenizer<'a> {
    pub fn new(input: &'a str, comment_style: ParserLanguage) -> Tokenizer<'a> {
        Tokenizer {
            lexer: Lexer::new(input, comment_style),
            next_token: None,
            last_token_loc: None,
        }
    }

    pub fn loc(&self) -> Loc {
        // After lookahead return the location of the next token
        self.next_token
            .as_ref()
            .map(|t| t.loc.clone())
            // After token consumed return the location of that token
            .or(self.last_token_loc.clone())
            // Otherwise return the position of lexer
            .unwrap_or(self.lexer.loc)
    }

    pub fn lookahead_loc(&mut self) -> Loc {
        drop(self.lookahead());
        // TODO: does not handle EOF properly
        self.loc()
    }

    fn lookahead(&mut self) -> TokenizerResult<Option<&Token>> {
        Ok(match self.next_token {
            Some(ref token) => Some(&token.token),
            None => {
                self.next_token = self.lexer.next_token()?;
                self.last_token_loc = self.next_token.as_ref().map(|t| t.loc.clone());
                match self.next_token {
                    Some(ref token) => Some(&token.token),
                    None => None,
                }
            }
        })
    }

    pub fn lookahead_some(&mut self) -> TokenizerResult<&Token> {
        match self.lookahead()? {
            Some(token) => Ok(token),
            None => Err(TokenizerError::UnexpectedEof),
        }
    }

    fn next(&mut self) -> TokenizerResult<Option<Token>> {
        self.lookahead()?;
        Ok(self
            .next_token
            .take()
            .map(|TokenWithLocation { token, .. }| token))
    }

    pub fn next_some(&mut self) -> TokenizerResult<Token> {
        match self.next()? {
            Some(token) => Ok(token),
            None => Err(TokenizerError::UnexpectedEof),
        }
    }

    /// Can be called only after lookahead, otherwise it's error
    pub fn advance(&mut self) -> TokenizerResult<Token> {
        self.next_token
            .take()
            .map(|TokenWithLocation { token, .. }| token)
            .ok_or(TokenizerError::InternalError)
    }

    /// No more tokens
    pub fn syntax_eof(&mut self) -> TokenizerResult<bool> {
        Ok(self.lookahead()?.is_none())
    }

    pub fn next_token_if_map<P, R>(&mut self, p: P) -> TokenizerResult<Option<R>>
    where
        P: FnOnce(&Token) -> Option<R>,
    {
        self.lookahead()?;
        let v = match self.next_token {
            Some(ref token) => match p(&token.token) {
                Some(v) => v,
                None => return Ok(None),
            },
            _ => return Ok(None),
        };
        self.next_token = None;
        Ok(Some(v))
    }

    pub fn next_token_check_map<P, R, E>(&mut self, p: P) -> Result<R, E>
    where
        P: FnOnce(&Token) -> Result<R, E>,
        E: From<TokenizerError>,
    {
        self.lookahead()?;
        let r = match self.next_token {
            Some(ref token) => p(&token.token)?,
            None => return Err(TokenizerError::UnexpectedEof.into()),
        };
        self.next_token = None;
        Ok(r)
    }

    fn next_token_if<P>(&mut self, p: P) -> TokenizerResult<Option<Token>>
    where
        P: FnOnce(&Token) -> bool,
    {
        self.next_token_if_map(|token| if p(token) { Some(token.clone()) } else { None })
    }

    pub fn next_ident_if_in(&mut self, idents: &[&str]) -> TokenizerResult<Option<String>> {
        let v = match self.lookahead()? {
            Some(&Token::Ident(ref next)) => {
                if idents.into_iter().find(|&i| i == next).is_some() {
                    next.clone()
                } else {
                    return Ok(None);
                }
            }
            _ => return Ok(None),
        };
        self.advance()?;
        Ok(Some(v))
    }

    pub fn next_ident_if_eq(&mut self, word: &str) -> TokenizerResult<bool> {
        Ok(self.next_ident_if_in(&[word])? != None)
    }

    pub fn next_ident_expect_eq(&mut self, word: &str) -> TokenizerResult<()> {
        if self.next_ident_if_eq(word)? {
            Ok(())
        } else {
            Err(TokenizerError::ExpectNamedIdent(word.to_owned()))
        }
    }

    pub fn next_ident_if_eq_error(&mut self, word: &'static str) -> TokenizerResult<()> {
        if self.clone().next_ident_if_eq(word)? {
            // TODO: which context?
            return Err(TokenizerError::NotAllowedInThisContext(word));
        }
        Ok(())
    }

    pub fn next_symbol_if_eq(&mut self, symbol: char) -> TokenizerResult<bool> {
        Ok(self.next_token_if(|token| match token {
            &Token::Symbol(c) if c == symbol => true,
            _ => false,
        })? != None)
    }

    pub fn next_symbol_expect_eq(
        &mut self,
        symbol: char,
        desc: &'static str,
    ) -> TokenizerResult<()> {
        if self.lookahead_is_symbol(symbol)? {
            self.advance()?;
            Ok(())
        } else {
            Err(TokenizerError::ExpectChar(symbol, desc))
        }
    }

    pub fn next_symbol_expect_eq_oneof(&mut self, symbols: &[char]) -> TokenizerResult<char> {
        for symbol in symbols {
            if let Ok(()) = self.next_symbol_expect_eq(*symbol, "ignored") {
                return Ok(*symbol);
            }
        }
        Err(TokenizerError::ExpectAnyChar(symbols.to_owned()))
    }

    pub fn lookahead_is_str_lit(&mut self) -> TokenizerResult<bool> {
        Ok(match self.lookahead()? {
            Some(&Token::StrLit(..)) => true,
            _ => false,
        })
    }

    pub fn lookahead_is_int_lit(&mut self) -> TokenizerResult<bool> {
        Ok(match self.lookahead()? {
            Some(&Token::IntLit(..)) => true,
            _ => false,
        })
    }

    pub fn lookahead_is_json_number(&mut self) -> TokenizerResult<bool> {
        Ok(match self.lookahead()? {
            Some(&Token::JsonNumber(..)) => true,
            _ => false,
        })
    }

    pub fn lookahead_if_symbol(&mut self) -> TokenizerResult<Option<char>> {
        Ok(match self.lookahead()? {
            Some(&Token::Symbol(c)) => Some(c),
            _ => None,
        })
    }

    pub fn lookahead_is_symbol(&mut self, symbol: char) -> TokenizerResult<bool> {
        Ok(self.lookahead_if_symbol()? == Some(symbol))
    }

    pub fn lookahead_is_ident(&mut self, ident: &str) -> TokenizerResult<bool> {
        Ok(match self.lookahead()? {
            Some(Token::Ident(i)) => i == ident,
            _ => false,
        })
    }

    pub fn next_ident(&mut self) -> TokenizerResult<String> {
        self.next_token_check_map(|token| match token {
            &Token::Ident(ref ident) => Ok(ident.clone()),
            _ => Err(TokenizerError::ExpectIdent),
        })
    }

    pub fn next_str_lit(&mut self) -> TokenizerResult<StrLit> {
        self.next_token_check_map(|token| match token {
            &Token::StrLit(ref str_lit) => Ok(str_lit.clone()),
            _ => Err(TokenizerError::ExpectStrLit),
        })
    }

    pub fn next_int_lit(&mut self) -> TokenizerResult<u64> {
        self.next_token_check_map(|token| match token {
            &Token::IntLit(v) => Ok(v),
            _ => Err(TokenizerError::ExpectIntLit),
        })
    }

    pub fn next_float_lit(&mut self) -> TokenizerResult<f64> {
        self.next_token_check_map(|token| match token {
            &Token::FloatLit(v) => Ok(v),
            _ => Err(TokenizerError::ExpectFloatLit),
        })
    }
}

#[cfg(test)]
mod test {

    use super::*;

    fn tokenize<P, R>(input: &str, what: P) -> R
    where
        P: FnOnce(&mut Tokenizer) -> TokenizerResult<R>,
    {
        let mut tokenizer = Tokenizer::new(input, ParserLanguage::Proto);
        let r = what(&mut tokenizer).expect(&format!("parse failed at {}", tokenizer.loc()));
        let eof = tokenizer
            .syntax_eof()
            .expect(&format!("check eof failed at {}", tokenizer.loc()));
        assert!(eof, "{}", tokenizer.loc());
        r
    }

    #[test]
    fn test_ident() {
        let msg = r#"  aabb_c  "#;
        let mess = tokenize(msg, |p| p.next_ident().map(|s| s.to_owned()));
        assert_eq!("aabb_c", mess);
    }

    #[test]
    fn test_str_lit() {
        let msg = r#"  "a\nb"  "#;
        let mess = tokenize(msg, |p| p.next_str_lit());
        assert_eq!(
            StrLit {
                escaped: r#"a\nb"#.to_owned()
            },
            mess
        );
    }
}

'''
'''--- protobuf-support/src/lib.rs ---
//! # Supporting code for protobuf crates
//!
//! Code in this crate is used in protobuf crates like `protobuf` or `protobuf-parse`.
//! None of code in this crate has public API.

pub mod json_name;
pub mod lexer;
pub mod text_format;
pub mod toposort;

'''
'''--- protobuf-support/src/text_format.rs ---
pub fn escape_bytes_to(bytes: &[u8], buf: &mut String) {
    for &c in bytes {
        match c {
            b'\n' => buf.push_str(r"\n"),
            b'\r' => buf.push_str(r"\r"),
            b'\t' => buf.push_str(r"\t"),
            b'\'' => buf.push_str("\\\'"),
            b'"' => buf.push_str("\\\""),
            b'\\' => buf.push_str(r"\\"),
            b'\x20'..=b'\x7e' => buf.push(c as char),
            _ => {
                buf.push('\\');
                buf.push((b'0' + (c >> 6)) as char);
                buf.push((b'0' + ((c >> 3) & 7)) as char);
                buf.push((b'0' + (c & 7)) as char);
            }
        }
    }
}

pub fn quote_bytes_to(bytes: &[u8], buf: &mut String) {
    buf.push('"');
    escape_bytes_to(bytes, buf);
    buf.push('"');
}

#[cfg(test)]
mod test {
    use crate::lexer::str_lit::StrLit;
    use crate::text_format::escape_bytes_to;

    fn escape(data: &[u8]) -> String {
        let mut s = String::with_capacity(data.len() * 4);
        escape_bytes_to(data, &mut s);
        s
    }

    fn unescape_string(escaped: &str) -> Vec<u8> {
        StrLit {
            escaped: escaped.to_owned(),
        }
        .decode_bytes()
        .expect("decode_bytes")
    }

    fn test_escape_unescape(text: &str, escaped: &str) {
        assert_eq!(text.as_bytes(), &unescape_string(escaped)[..]);
        assert_eq!(escaped, &escape(text.as_bytes())[..]);
    }

    #[test]
    fn test_print_to_bytes() {
        assert_eq!("ab", escape(b"ab"));
        assert_eq!("a\\\\023", escape(b"a\\023"));
        assert_eq!("a\\r\\n\\t \\'\\\"\\\\", escape(b"a\r\n\t '\"\\"));
        assert_eq!("\\344\\275\\240\\345\\245\\275", escape("你好".as_bytes()));
    }

    #[test]
    fn test_unescape_string() {
        test_escape_unescape("", "");
        test_escape_unescape("aa", "aa");
        test_escape_unescape("\n", "\\n");
        test_escape_unescape("\r", "\\r");
        test_escape_unescape("\t", "\\t");
        test_escape_unescape("你好", "\\344\\275\\240\\345\\245\\275");
        // hex
        assert_eq!(b"aaa\x01bbb", &unescape_string("aaa\\x01bbb")[..]);
        assert_eq!(b"aaa\xcdbbb", &unescape_string("aaa\\xCDbbb")[..]);
        assert_eq!(b"aaa\xcdbbb", &unescape_string("aaa\\xCDbbb")[..]);
        // quotes
        assert_eq!(b"aaa\"bbb", &unescape_string("aaa\\\"bbb")[..]);
        assert_eq!(b"aaa\'bbb", &unescape_string("aaa\\\'bbb")[..]);
    }
}

'''
'''--- protobuf-support/src/toposort.rs ---
use std::collections::HashSet;
use std::hash::Hash;

#[derive(Debug, thiserror::Error)]
#[error("Cycle detected")]
pub struct TopoSortCycle;

pub fn toposort<K, I>(
    input: impl IntoIterator<Item = K>,
    deps: impl Fn(&K) -> I,
) -> Result<Vec<K>, TopoSortCycle>
where
    K: Eq + Hash + Clone,
    I: Iterator<Item = K>,
{
    struct Ts<K, D, I>
    where
        K: Eq + Hash + Clone,
        I: Iterator<Item = K>,
        D: Fn(&K) -> I,
    {
        result_set: HashSet<K>,
        result: Vec<K>,
        deps: D,
        stack: HashSet<K>,
    }

    impl<K, D, I> Ts<K, D, I>
    where
        K: Eq + Hash + Clone,
        I: Iterator<Item = K>,
        D: Fn(&K) -> I,
    {
        fn visit(&mut self, i: &K) -> Result<(), TopoSortCycle> {
            if self.result_set.contains(i) {
                return Ok(());
            }

            if !self.stack.insert(i.clone()) {
                return Err(TopoSortCycle);
            }
            for dep in (self.deps)(i) {
                self.visit(&dep)?;
            }

            let removed = self.stack.remove(i);
            assert!(removed);

            self.result.push(i.clone());
            self.result_set.insert(i.clone());

            Ok(())
        }
    }

    let mut ts = Ts {
        result: Vec::new(),
        result_set: HashSet::new(),
        deps,
        stack: HashSet::new(),
    };

    for i in input {
        ts.visit(&i)?;
    }

    Ok(ts.result)
}

#[cfg(test)]
mod tests {
    use std::collections::HashMap;

    use crate::toposort::toposort;
    use crate::toposort::TopoSortCycle;

    fn test_toposort(input: &str) -> Result<Vec<&str>, TopoSortCycle> {
        let mut keys: Vec<&str> = Vec::new();
        let mut edges: HashMap<&str, Vec<&str>> = HashMap::new();
        for part in input.split(" ") {
            match part.split_once("->") {
                Some((k, vs)) => {
                    keys.push(k);
                    edges.insert(k, vs.split(",").collect());
                }
                None => keys.push(part),
            };
        }

        toposort(keys, |k| {
            edges
                .get(k)
                .map(|v| v.as_slice())
                .unwrap_or_default()
                .into_iter()
                .copied()
        })
    }

    fn test_toposort_check(input: &str, expected: &str) {
        let sorted = test_toposort(input).unwrap();
        let expected = expected.split(" ").collect::<Vec<_>>();
        assert_eq!(expected, sorted);
    }

    #[test]
    fn test() {
        test_toposort_check("1 2 3", "1 2 3");
        test_toposort_check("1->2 2->3 3", "3 2 1");
        test_toposort_check("1 2->1 3->2", "1 2 3");
        test_toposort_check("1->2,3 2->3 3", "3 2 1");
    }

    #[test]
    fn cycle() {
        assert!(test_toposort("1->1").is_err());
        assert!(test_toposort("1->2 2->1").is_err());
    }
}

'''
'''--- protobuf/Cargo.toml ---
[package]

name = "protobuf"
version = "4.0.0-alpha.0"
authors = ["Stepan Koltsov <stepan.koltsov@gmail.com>"]
edition = "2021"
license = "MIT"
homepage = "https://github.com/stepancheg/rust-protobuf/"
repository = "https://github.com/stepancheg/rust-protobuf/"
documentation = "https://github.com/stepancheg/rust-protobuf/blob/master/README.md"
description = """
Rust implementation of Google protocol buffers
"""

[lib]
bench = false

[features]
with-bytes = ["bytes"]
default = []

[dependencies]
bytes = { version = "1.1", optional = true }
thiserror = "1.0.30"
once_cell = "1.9.0"

protobuf-support = { path = "../protobuf-support", version = "=4.0.0-alpha.0" }

[package.metadata.docs.rs]
all-features = true

'''
'''--- protobuf/LICENSE.txt ---
Copyright (c) 2019 Stepan Koltsov

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
OR OTHER DEALINGS IN THE SOFTWARE.
'''
'''--- protobuf/README.md ---
<!-- cargo-sync-readme start -->

# Library to read and write protocol buffers data

## Features

This crate has one feature, which is `with-bytes`.

`with-bytes` enables `protobuf` crate support for
[`bytes` crate](https://github.com/tokio-rs/bytes):
when parsing bytes or strings from `bytes::Bytes`,
`protobuf` will be able to reference the input instead of allocating subarrays.

Note, codegen also need to be instructed to generate `Bytes` or `Chars` for
`bytes` or `string` protobuf types instead of default `Vec<u8>` or `String`,
just enabling option on this crate is not enough.

See `Customize` struct in [`protobuf-codegen` crate](https://docs.rs/protobuf-codegen).

## Accompanying crates

* [`protobuf-json-mapping`](https://docs.rs/protobuf-json-mapping)
  implements JSON parsing and serialization for protobuf messages.
* [`protobuf-codegen`](https://docs.rs/protobuf-codegen)
  can be used to generate rust code from `.proto` crates.
* [`protoc-bin-vendored`](https://docs.rs/protoc-bin-vendored)
  contains `protoc` command packed into the crate.
* [`protobuf-parse`](https://docs.rs/protobuf-parse) contains
  `.proto` file parser. Rarely need to be used directly,
  but can be used for mechanical processing of `.proto` files.

<!-- cargo-sync-readme end -->

'''
'''--- protobuf/benches/coded_input_stream.rs ---
// `cargo test --benches` and `#[feature(test)]` work only in nightly
#![cfg(rustc_nightly)]
#![feature(test)]

extern crate protobuf;
extern crate test;

use std::io;
use std::io::Read;

use protobuf::CodedInputStream;

use self::test::Bencher;

fn make_bytes(len: usize) -> Vec<u8> {
    let mut r = Vec::with_capacity(len);
    for i in 0..len {
        r.push((i % 10) as u8);
    }
    test::black_box(r)
}

#[bench]
fn read_byte(b: &mut Bencher) {
    let v = make_bytes(1_000);
    b.iter(|| {
        let mut is = CodedInputStream::from_bytes(test::black_box(&v));
        while !is.eof().expect("eof") {
            test::black_box(is.read_raw_byte().expect("read"));
        }
    });
}

#[bench]
fn read_byte_no_eof(b: &mut Bencher) {
    let v = make_bytes(1_000);
    b.iter(|| {
        let mut is = CodedInputStream::from_bytes(test::black_box(&v));
        for _ in 0..v.len() {
            test::black_box(is.read_raw_byte().expect("read"));
        }
        assert!(is.eof().expect("eof"));
    });
}

#[bench]
fn read_byte_from_vec(b: &mut Bencher) {
    let v = make_bytes(1_000);
    b.iter(|| {
        let mut v = io::Cursor::new(test::black_box(&v));
        loop {
            let mut buf = [0];
            let count = v.read(&mut buf).expect("read");
            if count == 0 {
                break;
            }
            test::black_box(buf);
        }
    });
}

#[bench]
fn read_varint_12(b: &mut Bencher) {
    let mut v = Vec::new();
    {
        let mut v = protobuf::CodedOutputStream::vec(&mut v);
        for i in 0..1000 {
            // one or two byte varints
            v.write_raw_varint32((i * 7919) % (1 << 14)).expect("write");
        }
        v.flush().expect("flush");
    }
    b.iter(|| {
        let mut is = CodedInputStream::from_bytes(test::black_box(&v));
        let mut count = 0;
        while !is.eof().expect("eof") {
            test::black_box(is.read_raw_varint32().expect("read"));
            count += 1;
        }
        assert_eq!(1000, count);
    })
}

#[bench]
fn read_varint_1(b: &mut Bencher) {
    let mut v = Vec::new();
    {
        let mut v = protobuf::CodedOutputStream::vec(&mut v);
        for i in 0..1000 {
            // one or two byte varints
            v.write_raw_varint32((i * 7919) % (1 << 7)).expect("write");
        }
        v.flush().expect("flush");
    }
    b.iter(|| {
        let mut is = CodedInputStream::from_bytes(test::black_box(&v));
        let mut count = 0;
        while !is.eof().expect("eof") {
            test::black_box(is.read_raw_varint32().expect("read"));
            count += 1;
        }
        assert_eq!(1000, count);
    })
}

fn xorshift(mut x: u64) -> u64 {
    x ^= x << 13;
    x ^= x >> 7;
    x ^= x << 17;
    x
}

#[bench]
fn read_varint_large(b: &mut Bencher) {
    let mut v = Vec::new();
    {
        let mut v = protobuf::CodedOutputStream::vec(&mut v);
        let mut rng = 1;
        for _ in 0..1000 {
            // one or two byte varints
            v.write_raw_varint64(rng).unwrap();
            rng = xorshift(rng);
        }
        v.flush().expect("flush");
    }
    b.iter(|| {
        let mut is = CodedInputStream::from_bytes(test::black_box(&v));
        let mut count = 0;
        while !is.eof().expect("eof") {
            test::black_box(is.read_raw_varint64().expect("read"));
            count += 1;
        }
        assert_eq!(1000, count);
    })
}

'''
'''--- protobuf/benches/coded_output_stream.rs ---
// `cargo test --benches` and `#[feature(test)]` work only in nightly
#![cfg(rustc_nightly)]
#![feature(test)]

extern crate protobuf;
extern crate test;

use protobuf::CodedOutputStream;

use self::test::Bencher;

#[inline]
fn buffer_write_byte(os: &mut CodedOutputStream) {
    for i in 0..10 {
        os.write_raw_byte(test::black_box(i as u8)).unwrap();
    }
    os.flush().unwrap();
}

#[inline]
fn buffer_write_bytes(os: &mut CodedOutputStream) {
    for _ in 0..10 {
        os.write_raw_bytes(test::black_box(b"1234567890")).unwrap();
    }
    os.flush().unwrap();
}

#[bench]
fn bench_buffer(b: &mut Bencher) {
    b.iter(|| {
        let mut v = Vec::new();
        {
            let mut os = CodedOutputStream::new(&mut v);
            buffer_write_byte(&mut os);
        }
        v
    });
}

#[bench]
fn bench_buffer_bytes(b: &mut Bencher) {
    b.iter(|| {
        let mut v = Vec::new();
        {
            let mut os = CodedOutputStream::new(&mut v);
            buffer_write_bytes(&mut os);
        }
        v
    });
}

#[bench]
fn bench_write_raw_varint_32(b: &mut Bencher) {
    let mut v = Vec::with_capacity(10_000);
    b.iter(|| {
        v.clear();
        {
            let mut os = CodedOutputStream::new(&mut v);
            for i in 0..1000 {
                os.write_raw_varint32(i * 139 % 1000).unwrap();
            }
        }
        v.len()
    })
}

'''
'''--- protobuf/benches/write.rs ---
// `cargo test --benches` and `#[feature(test)]` work only in nightly
#![cfg(rustc_nightly)]
#![feature(test)]

extern crate test;

use protobuf::well_known_types::struct_::value;
use protobuf::well_known_types::struct_::Struct;
use protobuf::well_known_types::struct_::Value;
use protobuf::Message;
use test::Bencher;

#[bench]
fn write_to_bytes(b: &mut Bencher) {
    let mut value = Value::new();
    value.kind = Some(value::Kind::NumberValue(10.0));
    let mut value2 = Value::new();
    value2.kind = Some(value::Kind::BoolValue(true));
    let mut s = Struct::new();
    s.fields.insert("foo".to_owned(), value);
    s.fields.insert("bar".to_owned(), value2);
    b.iter(|| s.write_to_bytes());
}

'''
'''--- protobuf/build.rs ---
use std::env;
use std::env::VarError;
use std::fs::File;
use std::io::Read;
use std::io::Write;
use std::path::Path;
use std::path::PathBuf;
use std::process;

// % rustc +stable --version
// rustc 1.26.0 (a77568041 2018-05-07)
// % rustc +beta --version
// rustc 1.27.0-beta.1 (03fb2f447 2018-05-09)
// % rustc +nightly --version
// rustc 1.27.0-nightly (acd3871ba 2018-05-10)
fn version_is_nightly(version: &str) -> bool {
    version.contains("nightly")
}

fn cfg_rust_version() {
    let rustc = env::var("RUSTC").expect("RUSTC unset");

    let mut child = process::Command::new(rustc)
        .args(&["--version"])
        .stdin(process::Stdio::null())
        .stdout(process::Stdio::piped())
        .spawn()
        .expect("spawn rustc");

    let mut rustc_version = String::new();

    child
        .stdout
        .as_mut()
        .expect("stdout")
        .read_to_string(&mut rustc_version)
        .expect("read_to_string");
    assert!(child.wait().expect("wait").success());

    if version_is_nightly(&rustc_version) {
        println!("cargo:rustc-cfg=rustc_nightly");
    }
}

fn cfg_serde() {
    match env::var("CARGO_FEATURE_WITH_SERDE") {
        Ok(_) => {
            println!("cargo:rustc-cfg=serde");
        }
        Err(VarError::NotUnicode(..)) => panic!(),
        Err(VarError::NotPresent) => {}
    }
}

fn out_dir() -> PathBuf {
    PathBuf::from(env::var("OUT_DIR").expect("OUT_DIR"))
}

fn version() -> String {
    env::var("CARGO_PKG_VERSION").expect("CARGO_PKG_VERSION")
}

fn write_version() {
    let version = version();
    let version_ident = format!(
        "VERSION_{}",
        version.replace(".", "_").replace("-", "_").to_uppercase()
    );
    let mut file = File::create(Path::join(&out_dir(), "version.rs")).expect("open");
    writeln!(file, "/// protobuf crate version").unwrap();
    writeln!(file, "pub const VERSION: &'static str = \"{}\";", version).unwrap();
    writeln!(file, "/// This symbol is used by codegen").unwrap();
    writeln!(file, "#[doc(hidden)]").unwrap();
    writeln!(
        file,
        "pub const VERSION_IDENT: &'static str = \"{}\";",
        version_ident
    )
    .unwrap();
    writeln!(
        file,
        "/// This symbol can be referenced to assert that proper version of crate is used"
    )
    .unwrap();
    writeln!(file, "pub const {}: () = ();", version_ident).unwrap();
    file.flush().unwrap();
}

fn main() {
    cfg_rust_version();
    cfg_serde();
    write_version();
}

'''
'''--- protobuf/regenerate.sh ---
#!/bin/sh -ex

cd "$(dirname "$0")"

die() {
    echo "$@" >&2
    exit 1
}

protoc_ver=$(protoc --version)
case "$protoc_ver" in
"libprotoc 3"*) ;;
*)
    die "you need to use protobuf 3 to regenerate .rs from .proto"
    ;;
esac

cargo build --manifest-path=../protobuf-codegen/Cargo.toml
cargo build --manifest-path=../protoc-bin/Cargo.toml --bin protoc-bin-print-paths

eval "$(cargo run --manifest-path=../protoc-bin/Cargo.toml --bin protoc-bin-print-paths)"

test -n "$PROTOC"

where_am_i=$(
    cd ..
    pwd
)

rm -rf tmp-generated
mkdir tmp-generated

case $(uname) in
Linux)
    exe_suffix=""
    ;;
MSYS_NT*)
    exe_suffix=".exe"
    ;;
esac

"$PROTOC" \
    --plugin=protoc-gen-rust="$where_am_i/target/debug/protoc-gen-rust$exe_suffix" \
    --rust_out tmp-generated \
    --rust_opt 'inside_protobuf=true gen_mod_rs=false' \
    -I../proto \
    ../proto/google/protobuf/*.proto \
    ../proto/google/protobuf/compiler/*.proto \
    ../proto/rustproto.proto \
    ../proto/doctest_pb.proto

mv \
    tmp-generated/descriptor.rs \
    tmp-generated/plugin.rs \
    tmp-generated/rustproto.rs \
    tmp-generated/doctest_pb.rs \
    src/
mv tmp-generated/well_known_types_mod.rs src/well_known_types/mod.rs
mv tmp-generated/*.rs src/well_known_types/

# vim: set ts=4 sw=4 et:

'''
'''--- protobuf/src/byteorder.rs ---
/// Expose cfg as constant to be able to typecheck both versions.
pub(crate) const LITTLE_ENDIAN: bool = cfg!(target_endian = "little");

'''
'''--- protobuf/src/cached_size.rs ---
use std::hash::Hash;
use std::hash::Hasher;
use std::sync::atomic::AtomicUsize;
use std::sync::atomic::Ordering;

/// Cached size field used in generated code.
///
/// It is always equal to itself to simplify generated code.
/// (Generated code can use `#[derive(Eq)]`).
///
/// This type should rarely be used directly.
#[derive(Debug, Default)]
pub struct CachedSize {
    size: AtomicUsize,
}

impl CachedSize {
    /// Create a new `CachedSize` object.
    pub const fn new() -> CachedSize {
        CachedSize {
            size: AtomicUsize::new(0),
        }
    }

    /// Get cached size
    pub fn get(&self) -> u32 {
        self.size.load(Ordering::Relaxed) as u32
    }

    /// Set cached size
    pub fn set(&self, size: u32) {
        self.size.store(size as usize, Ordering::Relaxed)
    }
}

impl Clone for CachedSize {
    fn clone(&self) -> CachedSize {
        CachedSize {
            size: AtomicUsize::new(self.size.load(Ordering::Relaxed)),
        }
    }
}

impl PartialEq<CachedSize> for CachedSize {
    fn eq(&self, _other: &CachedSize) -> bool {
        true
    }
}

impl Eq for CachedSize {}

impl Hash for CachedSize {
    fn hash<H: Hasher>(&self, _state: &mut H) {
        // ignore cached size in cache computation
    }
}

'''
'''--- protobuf/src/chars.rs ---
#![cfg(feature = "bytes")]

use std::borrow::Borrow;
use std::fmt;
use std::ops::Deref;
use std::str;

use bytes::Bytes;

/// Thin wrapper around `Bytes` which guarantees that bytes are valid UTF-8 string.
/// Should be API-compatible to `String`.
#[derive(Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct Chars(Bytes);

impl Chars {
    /// New empty object.
    pub const fn new() -> Chars {
        Chars(Bytes::new())
    }

    /// Clear the buffer.
    pub fn clear(&mut self) {
        self.0.clear();
    }

    /// Try convert from `Bytes`
    pub fn from_bytes(bytes: Bytes) -> Result<Chars, str::Utf8Error> {
        str::from_utf8(&bytes)?;

        Ok(Chars(bytes))
    }

    /// Len in bytes.
    pub fn len(&self) -> usize {
        self.0.len()
    }

    /// Self-explanatory
    pub fn is_empty(&self) -> bool {
        self.0.is_empty()
    }
}

impl<'a> From<&'a str> for Chars {
    fn from(src: &'a str) -> Chars {
        Chars(Bytes::copy_from_slice(src.as_bytes()))
    }
}

impl From<String> for Chars {
    fn from(src: String) -> Chars {
        Chars(Bytes::from(src))
    }
}

impl Into<String> for Chars {
    fn into(self) -> String {
        // This is safe because `Chars` is guaranteed to store a valid UTF-8 string
        unsafe { String::from_utf8_unchecked(self.0.as_ref().to_owned()) }
    }
}

impl Default for Chars {
    fn default() -> Self {
        Chars::new()
    }
}

impl Deref for Chars {
    type Target = str;

    fn deref(&self) -> &str {
        // This is safe because `Chars` is guaranteed to store a valid UTF-8 string
        unsafe { str::from_utf8_unchecked(&self.0) }
    }
}

impl Borrow<str> for Chars {
    fn borrow(&self) -> &str {
        &*self
    }
}

impl fmt::Display for Chars {
    #[inline]
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&**self, f)
    }
}

impl fmt::Debug for Chars {
    #[inline]
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Debug::fmt(&**self, f)
    }
}

#[cfg(test)]
mod test {
    use super::Chars;

    #[test]
    #[cfg_attr(miri, ignore)] // bytes violates SB, see https://github.com/tokio-rs/bytes/issues/522
    fn test_display_and_debug() {
        let s = "test";
        let string: String = s.into();
        let chars: Chars = s.into();

        assert_eq!(format!("{}", string), format!("{}", chars));
        assert_eq!(format!("{:?}", string), format!("{:?}", chars));
    }
}

'''
'''--- protobuf/src/coded_input_stream/buf_read_iter.rs ---
use std::cmp;
use std::io::BufRead;
use std::io::BufReader;
use std::io::Read;
use std::mem;
use std::mem::MaybeUninit;

#[cfg(feature = "bytes")]
use bytes::buf::UninitSlice;
#[cfg(feature = "bytes")]
use bytes::BufMut;
#[cfg(feature = "bytes")]
use bytes::Bytes;
#[cfg(feature = "bytes")]
use bytes::BytesMut;

use crate::coded_input_stream::buf_read_or_reader::BufReadOrReader;
use crate::coded_input_stream::input_buf::InputBuf;
use crate::coded_input_stream::input_source::InputSource;
use crate::coded_input_stream::READ_RAW_BYTES_MAX_ALLOC;
use crate::error::ProtobufError;
use crate::error::WireError;

// If an input stream is constructed with a `Read`, we create a
// `BufReader` with an internal buffer of this size.
const INPUT_STREAM_BUFFER_SIZE: usize = 4096;

const NO_LIMIT: u64 = u64::MAX;

/// Dangerous implementation of `BufRead`.
///
/// Unsafe wrapper around BufRead which assumes that `BufRead` buf is
/// not moved when `BufRead` is moved.
///
/// This assumption is generally incorrect, however, in practice
/// `BufReadIter` is created either from `BufRead` reference (which
/// cannot  be moved, because it is locked by `CodedInputStream`) or from
/// `BufReader` which does not move its buffer (we know that from
/// inspecting rust standard library).
///
/// It is important for `CodedInputStream` performance that small reads
/// (e. g. 4 bytes reads) do not involve virtual calls or switches.
/// This is achievable with `BufReadIter`.
#[derive(Debug)]
pub(crate) struct BufReadIter<'a> {
    input_source: InputSource<'a>,
    buf: InputBuf<'a>,
    pos_of_buf_start: u64,
    limit: u64,
}

impl<'a> Drop for BufReadIter<'a> {
    fn drop(&mut self) {
        match self.input_source {
            InputSource::Read(ref mut buf_read) => buf_read.consume(self.buf.pos_within_buf()),
            _ => {}
        }
    }
}

impl<'a> BufReadIter<'a> {
    pub(crate) fn from_read(read: &'a mut dyn Read) -> BufReadIter<'a> {
        BufReadIter {
            input_source: InputSource::Read(BufReadOrReader::BufReader(BufReader::with_capacity(
                INPUT_STREAM_BUFFER_SIZE,
                read,
            ))),
            buf: InputBuf::empty(),
            pos_of_buf_start: 0,
            limit: NO_LIMIT,
        }
    }

    pub(crate) fn from_buf_read(buf_read: &'a mut dyn BufRead) -> BufReadIter<'a> {
        BufReadIter {
            input_source: InputSource::Read(BufReadOrReader::BufRead(buf_read)),
            buf: InputBuf::empty(),
            pos_of_buf_start: 0,
            limit: NO_LIMIT,
        }
    }

    pub(crate) fn from_byte_slice(bytes: &'a [u8]) -> BufReadIter<'a> {
        BufReadIter {
            input_source: InputSource::Slice(bytes),
            buf: InputBuf::from_bytes(bytes),
            pos_of_buf_start: 0,
            limit: NO_LIMIT,
        }
    }

    #[cfg(feature = "bytes")]
    pub(crate) fn from_bytes(bytes: &'a Bytes) -> BufReadIter<'a> {
        BufReadIter {
            input_source: InputSource::Bytes(bytes),
            buf: InputBuf::from_bytes(&bytes),
            pos_of_buf_start: 0,
            limit: NO_LIMIT,
        }
    }

    #[inline]
    fn assertions(&self) {
        debug_assert!(self.pos() <= self.limit);
        self.buf.assertions();
    }

    #[inline(always)]
    pub(crate) fn pos(&self) -> u64 {
        self.pos_of_buf_start + self.buf.pos_within_buf() as u64
    }

    /// Recompute `limit_within_buf` after update of `limit`
    #[inline]
    fn update_limit_within_buf(&mut self) {
        assert!(self.limit >= self.pos_of_buf_start);
        self.buf.update_limit(self.limit - self.pos_of_buf_start);
        self.assertions();
    }

    pub(crate) fn push_limit(&mut self, limit: u64) -> crate::Result<u64> {
        let new_limit = match self.pos().checked_add(limit) {
            Some(new_limit) => new_limit,
            None => return Err(ProtobufError::WireError(WireError::LimitOverflow).into()),
        };

        if new_limit > self.limit {
            return Err(ProtobufError::WireError(WireError::LimitIncrease).into());
        }

        let prev_limit = mem::replace(&mut self.limit, new_limit);

        self.update_limit_within_buf();

        Ok(prev_limit)
    }

    #[inline]
    pub(crate) fn pop_limit(&mut self, limit: u64) {
        assert!(limit >= self.limit);

        self.limit = limit;

        self.update_limit_within_buf();
    }

    #[inline(always)]
    pub(crate) fn remaining_in_buf(&self) -> &[u8] {
        self.buf.remaining_in_buf()
    }

    #[inline]
    pub(crate) fn consume(&mut self, amt: usize) {
        self.buf.consume(amt);
    }

    #[inline(always)]
    pub(crate) fn remaining_in_buf_len(&self) -> usize {
        self.remaining_in_buf().len()
    }

    #[inline(always)]
    pub(crate) fn bytes_until_limit(&self) -> u64 {
        if self.limit == NO_LIMIT {
            NO_LIMIT
        } else {
            self.limit - self.pos()
        }
    }

    #[inline(always)]
    pub(crate) fn eof(&mut self) -> crate::Result<bool> {
        if self.remaining_in_buf_len() != 0 {
            Ok(false)
        } else {
            Ok(self.fill_buf()?.is_empty())
        }
    }

    fn read_byte_slow(&mut self) -> crate::Result<u8> {
        self.fill_buf_slow()?;

        if let Some(b) = self.buf.read_byte() {
            return Ok(b);
        }

        Err(WireError::UnexpectedEof.into())
    }

    #[inline(always)]
    pub(crate) fn read_byte(&mut self) -> crate::Result<u8> {
        if let Some(b) = self.buf.read_byte() {
            return Ok(b);
        }

        self.read_byte_slow()
    }

    #[cfg(feature = "bytes")]
    pub(crate) fn read_exact_bytes(&mut self, len: usize) -> crate::Result<Bytes> {
        if let InputSource::Bytes(bytes) = self.input_source {
            if len > self.remaining_in_buf_len() {
                return Err(ProtobufError::WireError(WireError::UnexpectedEof).into());
            }
            let end = self.buf.pos_within_buf() + len;

            let r = bytes.slice(self.buf.pos_within_buf()..end);
            self.buf.consume(len);
            Ok(r)
        } else {
            if len >= READ_RAW_BYTES_MAX_ALLOC {
                // We cannot trust `len` because protobuf message could be malformed.
                // Reading should not result in OOM when allocating a buffer.
                let mut v = Vec::new();
                self.read_exact_to_vec(len, &mut v)?;
                Ok(Bytes::from(v))
            } else {
                let mut r = BytesMut::with_capacity(len);
                unsafe {
                    let buf = Self::uninit_slice_as_mut_slice(&mut r.chunk_mut()[..len]);
                    self.read_exact(buf)?;
                    r.advance_mut(len);
                }
                Ok(r.freeze())
            }
        }
    }

    #[cfg(feature = "bytes")]
    unsafe fn uninit_slice_as_mut_slice(slice: &mut UninitSlice) -> &mut [MaybeUninit<u8>] {
        use std::slice;
        slice::from_raw_parts_mut(slice.as_mut_ptr() as *mut MaybeUninit<u8>, slice.len())
    }

    /// Returns 0 when EOF or limit reached.
    pub(crate) fn read(&mut self, buf: &mut [u8]) -> crate::Result<usize> {
        let rem = self.fill_buf()?;

        let len = cmp::min(rem.len(), buf.len());
        buf[..len].copy_from_slice(&rem[..len]);
        self.buf.consume(len);
        Ok(len)
    }

    fn consume_buf(&mut self) -> crate::Result<()> {
        match &mut self.input_source {
            InputSource::Read(read) => {
                read.consume(self.buf.pos_within_buf());
                self.pos_of_buf_start += self.buf.pos_within_buf() as u64;
                self.buf = InputBuf::empty();
                self.assertions();
                Ok(())
            }
            _ => Err(WireError::UnexpectedEof.into()),
        }
    }

    /// Read at most `max` bytes.
    ///
    /// Returns 0 when EOF or limit reached.
    fn read_to_vec(&mut self, vec: &mut Vec<u8>, max: usize) -> crate::Result<usize> {
        let rem = self.fill_buf()?;

        let len = cmp::min(rem.len(), max);
        vec.extend_from_slice(&rem[..len]);
        self.buf.consume(len);
        Ok(len)
    }

    fn read_exact_slow(&mut self, buf: &mut [MaybeUninit<u8>]) -> crate::Result<()> {
        if self.bytes_until_limit() < buf.len() as u64 {
            return Err(ProtobufError::WireError(WireError::UnexpectedEof).into());
        }

        self.consume_buf()?;

        match &mut self.input_source {
            InputSource::Read(buf_read) => {
                buf_read.read_exact_uninit(buf)?;
                self.pos_of_buf_start += buf.len() as u64;
                self.assertions();
                Ok(())
            }
            _ => unreachable!(),
        }
    }

    #[inline]
    pub(crate) fn read_exact(&mut self, buf: &mut [MaybeUninit<u8>]) -> crate::Result<()> {
        if self.remaining_in_buf_len() >= buf.len() {
            self.buf.read_bytes(buf);
            return Ok(());
        }

        self.read_exact_slow(buf)
    }

    /// Read raw bytes into the supplied vector.  The vector will be resized as needed and
    /// overwritten.
    pub(crate) fn read_exact_to_vec(
        &mut self,
        count: usize,
        target: &mut Vec<u8>,
    ) -> crate::Result<()> {
        // TODO: also do some limits when reading from unlimited source
        if count as u64 > self.bytes_until_limit() {
            return Err(ProtobufError::WireError(WireError::TruncatedMessage).into());
        }

        target.clear();

        if count >= READ_RAW_BYTES_MAX_ALLOC && count > target.capacity() {
            // avoid calling `reserve` on buf with very large buffer: could be a malformed message

            target.reserve(READ_RAW_BYTES_MAX_ALLOC);

            while target.len() < count {
                if count - target.len() <= target.len() {
                    target.reserve_exact(count - target.len());
                } else {
                    target.reserve(1);
                }

                let max = cmp::min(target.capacity() - target.len(), count - target.len());
                let read = self.read_to_vec(target, max)?;
                if read == 0 {
                    return Err(ProtobufError::WireError(WireError::TruncatedMessage).into());
                }
            }
        } else {
            target.reserve_exact(count);

            unsafe {
                self.read_exact(&mut target.spare_capacity_mut()[..count])?;
                target.set_len(count);
            }
        }

        debug_assert_eq!(count, target.len());

        Ok(())
    }

    pub(crate) fn skip_bytes(&mut self, count: u32) -> crate::Result<()> {
        if count as usize <= self.remaining_in_buf_len() {
            self.buf.consume(count as usize);
            return Ok(());
        }

        if count as u64 > self.bytes_until_limit() {
            return Err(WireError::TruncatedMessage.into());
        }

        self.consume_buf()?;

        match &mut self.input_source {
            InputSource::Read(read) => {
                read.skip_bytes(count as usize)?;
                self.pos_of_buf_start += count as u64;
                self.assertions();
                Ok(())
            }
            _ => unreachable!(),
        }
    }

    fn fill_buf_slow(&mut self) -> crate::Result<()> {
        self.assertions();
        if self.limit == self.pos() {
            return Ok(());
        }

        match self.input_source {
            InputSource::Read(..) => {}
            _ => return Ok(()),
        }

        self.consume_buf()?;

        match self.input_source {
            InputSource::Read(ref mut buf_read) => {
                self.buf = unsafe { InputBuf::from_bytes_ignore_lifetime(buf_read.fill_buf()?) };
                self.update_limit_within_buf();
                Ok(())
            }
            _ => {
                unreachable!();
            }
        }
    }

    #[inline(always)]
    pub(crate) fn fill_buf(&mut self) -> crate::Result<&[u8]> {
        let rem = self.buf.remaining_in_buf();
        if !rem.is_empty() {
            return Ok(rem);
        }

        if self.limit == self.pos() {
            return Ok(&[]);
        }

        self.fill_buf_slow()?;

        Ok(self.buf.remaining_in_buf())
    }
}

#[cfg(all(test, feature = "bytes"))]
mod test_bytes {
    use std::io::Write;

    use super::*;

    fn make_long_string(len: usize) -> Vec<u8> {
        let mut s = Vec::new();
        while s.len() < len {
            let len = s.len();
            write!(&mut s, "{}", len).expect("unexpected");
        }
        s.truncate(len);
        s
    }

    #[test]
    #[cfg_attr(miri, ignore)] // bytes violates SB, see https://github.com/tokio-rs/bytes/issues/522
    fn read_exact_bytes_from_slice() {
        let bytes = make_long_string(100);
        let mut bri = BufReadIter::from_byte_slice(&bytes[..]);
        assert_eq!(&bytes[..90], &bri.read_exact_bytes(90).unwrap()[..]);
        assert_eq!(bytes[90], bri.read_byte().expect("read_byte"));
    }

    #[test]
    #[cfg_attr(miri, ignore)] // bytes violates SB, see https://github.com/tokio-rs/bytes/issues/522
    fn read_exact_bytes_from_bytes() {
        let bytes = Bytes::from(make_long_string(100));
        let mut bri = BufReadIter::from_bytes(&bytes);
        let read = bri.read_exact_bytes(90).unwrap();
        assert_eq!(&bytes[..90], &read[..]);
        assert_eq!(&bytes[..90].as_ptr(), &read.as_ptr());
        assert_eq!(bytes[90], bri.read_byte().expect("read_byte"));
    }
}

#[cfg(test)]
mod test {
    use std::io;
    use std::io::BufRead;
    use std::io::Read;

    use super::*;

    #[test]
    fn eof_at_limit() {
        struct Read5ThenPanic {
            pos: usize,
        }

        impl Read for Read5ThenPanic {
            fn read(&mut self, _buf: &mut [u8]) -> io::Result<usize> {
                unreachable!();
            }
        }

        impl BufRead for Read5ThenPanic {
            fn fill_buf(&mut self) -> io::Result<&[u8]> {
                assert_eq!(0, self.pos);
                static ZERO_TO_FIVE: &'static [u8] = &[0, 1, 2, 3, 4];
                Ok(ZERO_TO_FIVE)
            }

            fn consume(&mut self, amt: usize) {
                if amt == 0 {
                    // drop of BufReadIter
                    return;
                }

                assert_eq!(0, self.pos);
                assert_eq!(5, amt);
                self.pos += amt;
            }
        }

        let mut read = Read5ThenPanic { pos: 0 };
        let mut buf_read_iter = BufReadIter::from_buf_read(&mut read);
        assert_eq!(0, buf_read_iter.pos());
        let _prev_limit = buf_read_iter.push_limit(5);
        buf_read_iter.read_byte().expect("read_byte");
        buf_read_iter
            .read_exact(&mut [
                MaybeUninit::uninit(),
                MaybeUninit::uninit(),
                MaybeUninit::uninit(),
                MaybeUninit::uninit(),
            ])
            .expect("read_exact");
        assert!(buf_read_iter.eof().expect("eof"));
    }
}

'''
'''--- protobuf/src/coded_input_stream/buf_read_or_reader.rs ---
//! `BufRead` pointer or `BufReader` owned.

use std::cmp;
use std::fmt;
use std::io;
use std::io::BufRead;
use std::io::BufReader;
use std::io::Read;
use std::mem::MaybeUninit;

use crate::misc::maybe_uninit_write_slice;

/// Helper type to simplify `BufReadIter` implementation.
pub(crate) enum BufReadOrReader<'a> {
    BufReader(BufReader<&'a mut dyn Read>),
    BufRead(&'a mut dyn BufRead),
}

impl<'a> fmt::Debug for BufReadOrReader<'a> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            BufReadOrReader::BufReader(..) => write!(f, "BufReader(...)"),
            BufReadOrReader::BufRead(..) => write!(f, "BufRead(...)"),
        }
    }
}

impl<'a> Read for BufReadOrReader<'a> {
    fn read(&mut self, buf: &mut [u8]) -> Result<usize, io::Error> {
        match self {
            BufReadOrReader::BufReader(r) => r.read(buf),
            BufReadOrReader::BufRead(r) => r.read(buf),
        }
    }

    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> Result<usize, io::Error> {
        match self {
            BufReadOrReader::BufReader(r) => r.read_to_end(buf),
            BufReadOrReader::BufRead(r) => r.read_to_end(buf),
        }
    }

    fn read_exact(&mut self, buf: &mut [u8]) -> Result<(), io::Error> {
        match self {
            BufReadOrReader::BufReader(r) => r.read_exact(buf),
            BufReadOrReader::BufRead(r) => r.read_exact(buf),
        }
    }
}

impl<'a> BufReadOrReader<'a> {
    /// Similar to `read_exact` but reads into `MaybeUninit`.
    pub(crate) fn read_exact_uninit(
        &mut self,
        buf: &mut [MaybeUninit<u8>],
    ) -> Result<(), io::Error> {
        let mut pos = 0;
        while pos != buf.len() {
            let fill_buf = match self {
                BufReadOrReader::BufReader(r) => r.fill_buf()?,
                BufReadOrReader::BufRead(r) => r.fill_buf()?,
            };
            if fill_buf.is_empty() {
                return Err(io::Error::new(
                    io::ErrorKind::UnexpectedEof,
                    "Unexpected end of file",
                ));
            }
            let consume = cmp::min(fill_buf.len(), buf.len() - pos);
            maybe_uninit_write_slice(&mut buf[pos..pos + consume], &fill_buf[..consume]);
            match self {
                BufReadOrReader::BufReader(r) => r.consume(consume),
                BufReadOrReader::BufRead(r) => r.consume(consume),
            }
            pos += consume;
        }
        Ok(())
    }

    pub(crate) fn skip_bytes(&mut self, count: usize) -> Result<(), io::Error> {
        let mut rem = count;
        while rem != 0 {
            let buf = self.fill_buf()?;
            if buf.is_empty() {
                return Err(io::Error::new(
                    io::ErrorKind::UnexpectedEof,
                    "Unexpected end of file",
                ));
            }
            let consume = cmp::min(buf.len(), rem);
            self.consume(consume);
            rem -= consume;
        }
        Ok(())
    }
}

impl<'a> BufRead for BufReadOrReader<'a> {
    fn fill_buf(&mut self) -> Result<&[u8], io::Error> {
        match self {
            BufReadOrReader::BufReader(r) => r.fill_buf(),
            BufReadOrReader::BufRead(r) => r.fill_buf(),
        }
    }

    fn consume(&mut self, amt: usize) {
        match self {
            BufReadOrReader::BufReader(r) => r.consume(amt),
            BufReadOrReader::BufRead(r) => r.consume(amt),
        }
    }
}

'''
'''--- protobuf/src/coded_input_stream/input_buf.rs ---
use std::cmp;
use std::mem::MaybeUninit;

use crate::misc::maybe_uninit_write_slice;

#[derive(Debug)]
pub(crate) struct InputBuf<'a> {
    // Invariants: `0 <= pos_within_buf <= limit_within_buf <= buf.len()`.
    buf: &'a [u8],
    pos_within_buf: usize,
    limit_within_buf: usize,
}

impl<'a> InputBuf<'a> {
    #[inline]
    pub(crate) fn assertions(&self) {
        debug_assert!(self.pos_within_buf <= self.limit_within_buf);
        debug_assert!(self.limit_within_buf <= self.buf.len());
    }

    pub(crate) fn empty() -> InputBuf<'a> {
        InputBuf {
            buf: &[],
            pos_within_buf: 0,
            limit_within_buf: 0,
        }
    }

    pub(crate) fn from_bytes(buf: &'a [u8]) -> InputBuf<'a> {
        InputBuf {
            buf,
            pos_within_buf: 0,
            limit_within_buf: buf.len(),
        }
    }

    pub(crate) unsafe fn from_bytes_ignore_lifetime(buf: &[u8]) -> InputBuf<'a> {
        let buf = &*(buf as *const [u8]);
        Self::from_bytes(buf)
    }

    pub(crate) fn update_limit(&mut self, limit: u64) {
        let limit_within_buf = cmp::min(self.buf.len() as u64, limit);
        assert!(limit_within_buf >= self.pos_within_buf as u64);
        self.limit_within_buf = limit_within_buf as usize;
    }

    pub(crate) fn pos_within_buf(&self) -> usize {
        self.pos_within_buf
    }

    #[inline(always)]
    pub(crate) fn remaining_in_buf(&self) -> &'a [u8] {
        // SAFETY: Invariants.
        unsafe {
            self.buf
                .get_unchecked(self.pos_within_buf..self.limit_within_buf)
        }
    }

    #[inline(always)]
    pub(crate) fn consume(&mut self, amt: usize) {
        assert!(amt <= self.remaining_in_buf().len());
        self.pos_within_buf += amt;
    }

    #[inline(always)]
    pub(crate) fn read_byte(&mut self) -> Option<u8> {
        let r = self.remaining_in_buf().first().copied();
        if let Some(..) = r {
            self.pos_within_buf += 1;
        }
        r
    }

    pub(crate) fn read_bytes<'b>(&mut self, dest: &'b mut [MaybeUninit<u8>]) -> &'b mut [u8] {
        // This panics if this has not enough data.
        let r = maybe_uninit_write_slice(dest, &self.remaining_in_buf()[..dest.len()]);
        self.pos_within_buf += r.len();
        r
    }
}

'''
'''--- protobuf/src/coded_input_stream/input_source.rs ---
#[cfg(feature = "bytes")]
use bytes::Bytes;

use crate::coded_input_stream::buf_read_or_reader::BufReadOrReader;

/// Hold all possible combinations of input source
#[derive(Debug)]
pub(crate) enum InputSource<'a> {
    Read(BufReadOrReader<'a>),
    Slice(&'a [u8]),
    #[cfg(feature = "bytes")]
    Bytes(&'a Bytes),
}

'''
'''--- protobuf/src/coded_input_stream/mod.rs ---
mod buf_read_iter;
mod buf_read_or_reader;
mod input_buf;
mod input_source;

use std::io;
use std::io::BufRead;
use std::io::Read;
use std::mem;
use std::mem::MaybeUninit;

#[cfg(feature = "bytes")]
use ::bytes::Bytes;

#[cfg(feature = "bytes")]
use crate::chars::Chars;
use crate::coded_input_stream::buf_read_iter::BufReadIter;
use crate::enums::Enum;
use crate::error::ProtobufError;
use crate::error::WireError;
use crate::misc::maybe_ununit_array_assume_init;
use crate::reflect::types::ProtobufTypeBool;
use crate::reflect::types::ProtobufTypeDouble;
use crate::reflect::types::ProtobufTypeFixed;
use crate::reflect::types::ProtobufTypeFixed32;
use crate::reflect::types::ProtobufTypeFixed64;
use crate::reflect::types::ProtobufTypeFloat;
use crate::reflect::types::ProtobufTypeInt32;
use crate::reflect::types::ProtobufTypeInt64;
use crate::reflect::types::ProtobufTypeSfixed32;
use crate::reflect::types::ProtobufTypeSfixed64;
use crate::reflect::types::ProtobufTypeSint32;
use crate::reflect::types::ProtobufTypeSint64;
use crate::reflect::types::ProtobufTypeTrait;
use crate::reflect::types::ProtobufTypeUint32;
use crate::reflect::types::ProtobufTypeUint64;
use crate::reflect::MessageDescriptor;
use crate::unknown::UnknownValue;
use crate::varint::decode::decode_varint32;
use crate::varint::decode::decode_varint64;
use crate::varint::MAX_VARINT_ENCODED_LEN;
use crate::wire_format;
use crate::wire_format::WireType;
use crate::zigzag::decode_zig_zag_32;
use crate::zigzag::decode_zig_zag_64;
use crate::EnumOrUnknown;
use crate::Message;
use crate::MessageDyn;

// Default recursion level limit. 100 is the default value of C++'s implementation.
const DEFAULT_RECURSION_LIMIT: u32 = 100;

// Max allocated vec when reading length-delimited from unknown input stream
pub(crate) const READ_RAW_BYTES_MAX_ALLOC: usize = 10_000_000;

/// Buffered read with handy utilities.
#[derive(Debug)]
pub struct CodedInputStream<'a> {
    source: BufReadIter<'a>,
    recursion_level: u32,
    recursion_limit: u32,
}

impl<'a> CodedInputStream<'a> {
    /// Wrap a `Read`.
    ///
    /// Note resulting `CodedInputStream` is buffered.
    ///
    /// If `Read` is buffered, the resulting stream will be double buffered,
    /// consider using [`from_buf_read`](Self::from_buf_read) instead.
    pub fn new(read: &'a mut dyn Read) -> CodedInputStream<'a> {
        CodedInputStream::from_buf_read_iter(BufReadIter::from_read(read))
    }

    /// Create from `BufRead`.
    ///
    /// `CodedInputStream` will utilize `BufRead` buffer.
    pub fn from_buf_read(buf_read: &'a mut dyn BufRead) -> CodedInputStream<'a> {
        CodedInputStream::from_buf_read_iter(BufReadIter::from_buf_read(buf_read))
    }

    /// Read from byte slice
    pub fn from_bytes(bytes: &'a [u8]) -> CodedInputStream<'a> {
        CodedInputStream::from_buf_read_iter(BufReadIter::from_byte_slice(bytes))
    }

    /// Read from `Bytes`.
    ///
    /// `CodedInputStream` operations like
    /// [`read_tokio_bytes`](crate::CodedInputStream::read_tokio_bytes)
    /// will return a shared copy of this bytes object.
    #[cfg(feature = "bytes")]
    pub fn from_tokio_bytes(bytes: &'a Bytes) -> CodedInputStream<'a> {
        CodedInputStream::from_buf_read_iter(BufReadIter::from_bytes(bytes))
    }

    fn from_buf_read_iter(source: BufReadIter<'a>) -> CodedInputStream<'a> {
        CodedInputStream {
            source,
            recursion_level: 0,
            recursion_limit: DEFAULT_RECURSION_LIMIT,
        }
    }

    /// Set the recursion limit.
    pub fn set_recursion_limit(&mut self, limit: u32) {
        self.recursion_limit = limit;
    }

    #[inline]
    pub(crate) fn incr_recursion(&mut self) -> crate::Result<()> {
        if self.recursion_level >= self.recursion_limit {
            return Err(ProtobufError::WireError(WireError::OverRecursionLimit).into());
        }
        self.recursion_level += 1;
        Ok(())
    }

    #[inline]
    pub(crate) fn decr_recursion(&mut self) {
        self.recursion_level -= 1;
    }

    /// How many bytes processed
    pub fn pos(&self) -> u64 {
        self.source.pos()
    }

    /// How many bytes until current limit
    pub fn bytes_until_limit(&self) -> u64 {
        self.source.bytes_until_limit()
    }

    /// Read bytes into given `buf`.
    #[inline]
    pub fn read_exact(&mut self, buf: &mut [MaybeUninit<u8>]) -> crate::Result<()> {
        self.source.read_exact(buf)
    }

    /// Read exact number of bytes as `Bytes` object.
    ///
    /// This operation returns a shared view if `CodedInputStream` is
    /// constructed with `Bytes` parameter.
    #[cfg(feature = "bytes")]
    fn read_raw_tokio_bytes(&mut self, count: usize) -> crate::Result<Bytes> {
        self.source.read_exact_bytes(count)
    }

    /// Read one byte
    #[inline(always)]
    pub fn read_raw_byte(&mut self) -> crate::Result<u8> {
        self.source.read_byte()
    }

    /// Push new limit, return previous limit.
    pub fn push_limit(&mut self, limit: u64) -> crate::Result<u64> {
        self.source.push_limit(limit)
    }

    /// Restore previous limit.
    pub fn pop_limit(&mut self, old_limit: u64) {
        self.source.pop_limit(old_limit);
    }

    /// Are we at EOF?
    #[inline(always)]
    pub fn eof(&mut self) -> crate::Result<bool> {
        self.source.eof()
    }

    /// Check we are at EOF.
    ///
    /// Return error if we are not at EOF.
    pub fn check_eof(&mut self) -> crate::Result<()> {
        let eof = self.eof()?;
        if !eof {
            return Err(ProtobufError::WireError(WireError::UnexpectedEof).into());
        }
        Ok(())
    }

    fn read_raw_varint64_slow(&mut self) -> crate::Result<u64> {
        let mut r: u64 = 0;
        let mut i = 0;
        loop {
            if i == MAX_VARINT_ENCODED_LEN {
                return Err(ProtobufError::WireError(WireError::IncorrectVarint).into());
            }
            let b = self.read_raw_byte()?;
            if i == 9 && (b & 0x7f) > 1 {
                return Err(ProtobufError::WireError(WireError::IncorrectVarint).into());
            }
            r = r | (((b & 0x7f) as u64) << (i * 7));
            i += 1;
            if b < 0x80 {
                return Ok(r);
            }
        }
    }

    fn read_raw_varint32_slow(&mut self) -> crate::Result<u32> {
        let v = self.read_raw_varint64_slow()?;
        if v > u32::MAX as u64 {
            return Err(ProtobufError::WireError(WireError::U32Overflow(v)).into());
        }
        Ok(v as u32)
    }

    /// Read varint
    #[inline]
    pub fn read_raw_varint64(&mut self) -> crate::Result<u64> {
        let rem = self.source.remaining_in_buf();

        match decode_varint64(rem)? {
            Some((r, c)) => {
                self.source.consume(c);
                Ok(r)
            }
            None => self.read_raw_varint64_slow(),
        }
    }

    /// Read varint
    #[inline]
    pub fn read_raw_varint32(&mut self) -> crate::Result<u32> {
        let rem = self.source.remaining_in_buf();

        match decode_varint32(rem)? {
            Some((r, c)) => {
                self.source.consume(c);
                Ok(r)
            }
            None => self.read_raw_varint32_slow(),
        }
    }

    #[inline]
    fn read_raw_varint32_or_eof(&mut self) -> crate::Result<Option<u32>> {
        let rem = self.source.remaining_in_buf();
        let v = decode_varint32(rem)?;
        match v {
            Some((r, c)) => {
                self.source.consume(c);
                Ok(Some(r))
            }
            None => {
                if self.eof()? {
                    Ok(None)
                } else {
                    let v = self.read_raw_varint32_slow()?;
                    Ok(Some(v))
                }
            }
        }
    }

    /// Read little-endian 32-bit integer
    pub fn read_raw_little_endian32(&mut self) -> crate::Result<u32> {
        let mut bytes = [MaybeUninit::uninit(); 4];
        self.read_exact(&mut bytes)?;
        // SAFETY: `read_exact` guarantees that the buffer is filled.
        let bytes = unsafe { maybe_ununit_array_assume_init(bytes) };
        Ok(u32::from_le_bytes(bytes))
    }

    /// Read little-endian 64-bit integer
    pub fn read_raw_little_endian64(&mut self) -> crate::Result<u64> {
        let mut bytes = [MaybeUninit::uninit(); 8];
        self.read_exact(&mut bytes)?;
        // SAFETY: `read_exact` guarantees that the buffer is filled.
        let bytes = unsafe { maybe_ununit_array_assume_init(bytes) };
        Ok(u64::from_le_bytes(bytes))
    }

    /// Read tag number as `u32` or None if EOF is reached.
    #[inline]
    pub fn read_raw_tag_or_eof(&mut self) -> crate::Result<Option<u32>> {
        self.read_raw_varint32_or_eof()
    }

    /// Read tag
    #[inline]
    pub(crate) fn read_tag(&mut self) -> crate::Result<wire_format::Tag> {
        let v = self.read_raw_varint32()?;
        wire_format::Tag::new(v)
    }

    /// Read tag, return it is pair (field number, wire type)
    #[inline]
    pub(crate) fn read_tag_unpack(&mut self) -> crate::Result<(u32, WireType)> {
        self.read_tag().map(|t| t.unpack())
    }

    /// Read `double`
    pub fn read_double(&mut self) -> crate::Result<f64> {
        let bits = self.read_raw_little_endian64()?;
        Ok(f64::from_bits(bits))
    }

    /// Read `float`
    pub fn read_float(&mut self) -> crate::Result<f32> {
        let bits = self.read_raw_little_endian32()?;
        Ok(f32::from_bits(bits))
    }

    /// Read `int64`
    pub fn read_int64(&mut self) -> crate::Result<i64> {
        self.read_raw_varint64().map(|v| v as i64)
    }

    /// Read `int32`
    pub fn read_int32(&mut self) -> crate::Result<i32> {
        let v = self.read_int64()?;
        i32::try_from(v).map_err(|_| WireError::I32Overflow(v).into())
    }

    /// Read `uint64`
    pub fn read_uint64(&mut self) -> crate::Result<u64> {
        self.read_raw_varint64()
    }

    /// Read `uint32`
    pub fn read_uint32(&mut self) -> crate::Result<u32> {
        self.read_raw_varint32()
    }

    /// Read `sint64`
    pub fn read_sint64(&mut self) -> crate::Result<i64> {
        self.read_uint64().map(decode_zig_zag_64)
    }

    /// Read `sint32`
    pub fn read_sint32(&mut self) -> crate::Result<i32> {
        self.read_uint32().map(decode_zig_zag_32)
    }

    /// Read `fixed64`
    pub fn read_fixed64(&mut self) -> crate::Result<u64> {
        self.read_raw_little_endian64()
    }

    /// Read `fixed32`
    pub fn read_fixed32(&mut self) -> crate::Result<u32> {
        self.read_raw_little_endian32()
    }

    /// Read `sfixed64`
    pub fn read_sfixed64(&mut self) -> crate::Result<i64> {
        self.read_raw_little_endian64().map(|v| v as i64)
    }

    /// Read `sfixed32`
    pub fn read_sfixed32(&mut self) -> crate::Result<i32> {
        self.read_raw_little_endian32().map(|v| v as i32)
    }

    /// Read `bool`
    pub fn read_bool(&mut self) -> crate::Result<bool> {
        self.read_raw_varint64().map(|v| v != 0)
    }

    pub(crate) fn read_enum_value(&mut self) -> crate::Result<i32> {
        self.read_int32()
    }

    /// Read `enum` as `ProtobufEnum`
    pub fn read_enum<E: Enum>(&mut self) -> crate::Result<E> {
        let i = self.read_enum_value()?;
        match Enum::from_i32(i) {
            Some(e) => Ok(e),
            None => Err(ProtobufError::WireError(WireError::InvalidEnumValue(E::NAME, i)).into()),
        }
    }

    /// Read `enum` as `ProtobufEnumOrUnknown`
    pub fn read_enum_or_unknown<E: Enum>(&mut self) -> crate::Result<EnumOrUnknown<E>> {
        Ok(EnumOrUnknown::from_i32(self.read_int32()?))
    }

    fn read_repeated_packed_fixed_into<T: ProtobufTypeFixed>(
        &mut self,
        target: &mut Vec<T::ProtobufValue>,
    ) -> crate::Result<()> {
        let len_bytes = self.read_raw_varint64()?;

        let reserve = if len_bytes <= READ_RAW_BYTES_MAX_ALLOC as u64 {
            (len_bytes as usize) / (T::ENCODED_SIZE as usize)
        } else {
            // prevent OOM on malformed input
            // probably should truncate
            READ_RAW_BYTES_MAX_ALLOC / (T::ENCODED_SIZE as usize)
        };

        target.reserve(reserve);

        let old_limit = self.push_limit(len_bytes)?;
        while !self.eof()? {
            target.push(T::read(self)?);
        }
        self.pop_limit(old_limit);
        Ok(())
    }

    fn read_repeated_packed_into<T: ProtobufTypeTrait>(
        &mut self,
        target: &mut Vec<T::ProtobufValue>,
    ) -> crate::Result<()> {
        let len_bytes = self.read_raw_varint64()?;

        // value is at least 1 bytes, so this is lower bound of element count
        let reserve = if len_bytes <= READ_RAW_BYTES_MAX_ALLOC as u64 {
            len_bytes as usize
        } else {
            // prevent OOM on malformed input
            READ_RAW_BYTES_MAX_ALLOC
        };

        target.reserve(reserve);

        let old_limit = self.push_limit(len_bytes)?;
        while !self.eof()? {
            target.push(T::read(self)?);
        }
        self.pop_limit(old_limit);
        Ok(())
    }

    /// Read repeated packed `double`
    pub fn read_repeated_packed_double_into(&mut self, target: &mut Vec<f64>) -> crate::Result<()> {
        self.read_repeated_packed_fixed_into::<ProtobufTypeDouble>(target)
    }

    /// Read repeated packed `float`
    pub fn read_repeated_packed_float_into(&mut self, target: &mut Vec<f32>) -> crate::Result<()> {
        self.read_repeated_packed_fixed_into::<ProtobufTypeFloat>(target)
    }

    /// Read repeated packed `int64`
    pub fn read_repeated_packed_int64_into(&mut self, target: &mut Vec<i64>) -> crate::Result<()> {
        self.read_repeated_packed_into::<ProtobufTypeInt64>(target)
    }

    /// Read repeated packed `int32`
    pub fn read_repeated_packed_int32_into(&mut self, target: &mut Vec<i32>) -> crate::Result<()> {
        self.read_repeated_packed_into::<ProtobufTypeInt32>(target)
    }

    /// Read repeated packed `uint64`
    pub fn read_repeated_packed_uint64_into(&mut self, target: &mut Vec<u64>) -> crate::Result<()> {
        self.read_repeated_packed_into::<ProtobufTypeUint64>(target)
    }

    /// Read repeated packed `uint32`
    pub fn read_repeated_packed_uint32_into(&mut self, target: &mut Vec<u32>) -> crate::Result<()> {
        self.read_repeated_packed_into::<ProtobufTypeUint32>(target)
    }

    /// Read repeated packed `sint64`
    pub fn read_repeated_packed_sint64_into(&mut self, target: &mut Vec<i64>) -> crate::Result<()> {
        self.read_repeated_packed_into::<ProtobufTypeSint64>(target)
    }

    /// Read repeated packed `sint32`
    pub fn read_repeated_packed_sint32_into(&mut self, target: &mut Vec<i32>) -> crate::Result<()> {
        self.read_repeated_packed_into::<ProtobufTypeSint32>(target)
    }

    /// Read repeated packed `fixed64`
    pub fn read_repeated_packed_fixed64_into(
        &mut self,
        target: &mut Vec<u64>,
    ) -> crate::Result<()> {
        self.read_repeated_packed_fixed_into::<ProtobufTypeFixed64>(target)
    }

    /// Read repeated packed `fixed32`
    pub fn read_repeated_packed_fixed32_into(
        &mut self,
        target: &mut Vec<u32>,
    ) -> crate::Result<()> {
        self.read_repeated_packed_fixed_into::<ProtobufTypeFixed32>(target)
    }

    /// Read repeated packed `sfixed64`
    pub fn read_repeated_packed_sfixed64_into(
        &mut self,
        target: &mut Vec<i64>,
    ) -> crate::Result<()> {
        self.read_repeated_packed_fixed_into::<ProtobufTypeSfixed64>(target)
    }

    /// Read repeated packed `sfixed32`
    pub fn read_repeated_packed_sfixed32_into(
        &mut self,
        target: &mut Vec<i32>,
    ) -> crate::Result<()> {
        self.read_repeated_packed_fixed_into::<ProtobufTypeSfixed32>(target)
    }

    /// Read repeated packed `bool`
    pub fn read_repeated_packed_bool_into(&mut self, target: &mut Vec<bool>) -> crate::Result<()> {
        self.read_repeated_packed_into::<ProtobufTypeBool>(target)
    }

    /// Read repeated packed enum values into the vector.
    pub(crate) fn read_repeated_packed_enum_values_into(
        &mut self,
        target: &mut Vec<i32>,
    ) -> crate::Result<()> {
        self.read_repeated_packed_into::<ProtobufTypeInt32>(target)
    }

    fn skip_group(&mut self) -> crate::Result<()> {
        while !self.eof()? {
            let wire_type = self.read_tag_unpack()?.1;
            if wire_type == WireType::EndGroup {
                break;
            }
            self.skip_field(wire_type)?;
        }
        Ok(())
    }

    /// Read `UnknownValue`
    pub fn read_unknown(&mut self, wire_type: WireType) -> crate::Result<UnknownValue> {
        match wire_type {
            WireType::Varint => self.read_raw_varint64().map(|v| UnknownValue::Varint(v)),
            WireType::Fixed64 => self.read_fixed64().map(|v| UnknownValue::Fixed64(v)),
            WireType::Fixed32 => self.read_fixed32().map(|v| UnknownValue::Fixed32(v)),
            WireType::LengthDelimited => {
                let len = self.read_raw_varint32()?;
                self.read_raw_bytes(len)
                    .map(|v| UnknownValue::LengthDelimited(v))
            }
            WireType::StartGroup => {
                self.skip_group()?;
                // We do not support groups, so just return something.
                Ok(UnknownValue::LengthDelimited(Vec::new()))
            }
            WireType::EndGroup => {
                Err(ProtobufError::WireError(WireError::UnexpectedWireType(wire_type)).into())
            }
        }
    }

    /// Skip field.
    pub fn skip_field(&mut self, wire_type: WireType) -> crate::Result<()> {
        match wire_type {
            WireType::Varint => self.read_raw_varint64().map(|_| ()),
            WireType::Fixed64 => self.read_fixed64().map(|_| ()),
            WireType::Fixed32 => self.read_fixed32().map(|_| ()),
            WireType::LengthDelimited => {
                let len = self.read_raw_varint32()?;
                self.skip_raw_bytes(len)
            }
            WireType::StartGroup => self.skip_group(),
            WireType::EndGroup => {
                Err(ProtobufError::WireError(WireError::UnexpectedWireType(wire_type)).into())
            }
        }
    }

    /// Read raw bytes into the supplied vector.  The vector will be resized as needed and
    /// overwritten.
    pub fn read_raw_bytes_into(&mut self, count: u32, target: &mut Vec<u8>) -> crate::Result<()> {
        self.source.read_exact_to_vec(count as usize, target)
    }

    /// Read exact number of bytes
    pub fn read_raw_bytes(&mut self, count: u32) -> crate::Result<Vec<u8>> {
        let mut r = Vec::new();
        self.read_raw_bytes_into(count, &mut r)?;
        Ok(r)
    }

    /// Skip exact number of bytes
    pub fn skip_raw_bytes(&mut self, count: u32) -> crate::Result<()> {
        self.source.skip_bytes(count)
    }

    /// Read `bytes` field, length delimited
    pub fn read_bytes(&mut self) -> crate::Result<Vec<u8>> {
        let mut r = Vec::new();
        self.read_bytes_into(&mut r)?;
        Ok(r)
    }

    /// Read `bytes` field, length delimited
    #[cfg(feature = "bytes")]
    pub fn read_tokio_bytes(&mut self) -> crate::Result<Bytes> {
        let len = self.read_raw_varint32()?;
        self.read_raw_tokio_bytes(len as usize)
    }

    /// Read `string` field, length delimited
    #[cfg(feature = "bytes")]
    pub fn read_tokio_chars(&mut self) -> crate::Result<Chars> {
        let bytes = self.read_tokio_bytes()?;
        Ok(Chars::from_bytes(bytes).map_err(ProtobufError::Utf8)?)
    }

    /// Read `bytes` field, length delimited
    pub fn read_bytes_into(&mut self, target: &mut Vec<u8>) -> crate::Result<()> {
        let len = self.read_raw_varint32()?;
        self.read_raw_bytes_into(len, target)?;
        Ok(())
    }

    /// Read `string` field, length delimited
    pub fn read_string(&mut self) -> crate::Result<String> {
        let mut r = String::new();
        self.read_string_into(&mut r)?;
        Ok(r)
    }

    /// Read `string` field, length delimited
    pub fn read_string_into(&mut self, target: &mut String) -> crate::Result<()> {
        target.clear();
        // take target's buffer
        let mut vec = mem::replace(target, String::new()).into_bytes();
        self.read_bytes_into(&mut vec)?;

        let s = match String::from_utf8(vec) {
            Ok(t) => t,
            Err(_) => return Err(ProtobufError::WireError(WireError::Utf8Error).into()),
        };
        *target = s;
        Ok(())
    }

    /// Read message, do not check if message is initialized
    pub fn merge_message<M: Message>(&mut self, message: &mut M) -> crate::Result<()> {
        self.incr_recursion()?;
        struct DecrRecursion<'a, 'b>(&'a mut CodedInputStream<'b>);
        impl<'a, 'b> Drop for DecrRecursion<'a, 'b> {
            fn drop(&mut self) {
                self.0.decr_recursion();
            }
        }

        let mut decr = DecrRecursion(self);

        let len = decr.0.read_raw_varint64()?;
        let old_limit = decr.0.push_limit(len)?;
        message.merge_from(&mut decr.0)?;
        decr.0.pop_limit(old_limit);
        Ok(())
    }

    /// Like `merge_message`, but for dynamic messages.
    pub fn merge_message_dyn(&mut self, message: &mut dyn MessageDyn) -> crate::Result<()> {
        let len = self.read_raw_varint64()?;
        let old_limit = self.push_limit(len)?;
        message.merge_from_dyn(self)?;
        self.pop_limit(old_limit);
        Ok(())
    }

    /// Read message
    pub fn read_message<M: Message>(&mut self) -> crate::Result<M> {
        let mut r: M = Message::new();
        self.merge_message(&mut r)?;
        r.check_initialized()?;
        Ok(r)
    }

    /// Read message.
    pub fn read_message_dyn(
        &mut self,
        descriptor: &MessageDescriptor,
    ) -> crate::Result<Box<dyn MessageDyn>> {
        let mut r = descriptor.new_instance();
        self.merge_message_dyn(&mut *r)?;
        r.check_initialized_dyn()?;
        Ok(r)
    }
}

impl<'a> Read for CodedInputStream<'a> {
    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {
        self.source.read(buf).map_err(Into::into)
    }
}

impl<'a> BufRead for CodedInputStream<'a> {
    fn fill_buf(&mut self) -> io::Result<&[u8]> {
        self.source.fill_buf().map_err(Into::into)
    }

    fn consume(&mut self, amt: usize) {
        self.source.consume(amt)
    }
}

#[cfg(test)]
mod test {

    use std::fmt::Debug;
    use std::io;
    use std::io::BufRead;
    use std::io::Read;

    use super::CodedInputStream;
    use super::READ_RAW_BYTES_MAX_ALLOC;
    use crate::error::ProtobufError;
    use crate::hex::decode_hex;
    use crate::wire_format::Tag;
    use crate::wire_format::WireType;
    use crate::CodedOutputStream;

    fn test_read_partial<F>(hex: &str, mut callback: F)
    where
        F: FnMut(&mut CodedInputStream),
    {
        let d = decode_hex(hex);
        // Test with buffered reader.
        {
            let mut reader = io::Cursor::new(&d);
            let mut is = CodedInputStream::from_buf_read(&mut reader as &mut dyn BufRead);
            assert_eq!(0, is.pos());
            callback(&mut is);
        }
        // Test from bytes.
        {
            let mut is = CodedInputStream::from_bytes(&d);
            assert_eq!(0, is.pos());
            callback(&mut is);
        }
    }

    fn test_read<F>(hex: &str, mut callback: F)
    where
        F: FnMut(&mut CodedInputStream),
    {
        let len = decode_hex(hex).len();
        test_read_partial(hex, |reader| {
            callback(reader);
            assert!(reader.eof().expect("eof"));
            assert_eq!(len as u64, reader.pos());
        });
    }

    fn test_read_v<F, V>(hex: &str, v: V, mut callback: F)
    where
        F: FnMut(&mut CodedInputStream) -> crate::Result<V>,
        V: PartialEq + Debug,
    {
        test_read(hex, |reader| {
            assert_eq!(v, callback(reader).unwrap());
        });
    }

    #[test]
    fn test_input_stream_read_raw_byte() {
        test_read("17", |is| {
            assert_eq!(23, is.read_raw_byte().unwrap());
        });
    }

    #[test]
    fn test_input_stream_read_raw_varint() {
        test_read_v("07", 7, |reader| reader.read_raw_varint32());
        test_read_v("07", 7, |reader| reader.read_raw_varint64());

        test_read_v("96 01", 150, |reader| reader.read_raw_varint32());
        test_read_v("96 01", 150, |reader| reader.read_raw_varint64());

        test_read_v(
            "ff ff ff ff ff ff ff ff ff 01",
            0xffffffffffffffff,
            |reader| reader.read_raw_varint64(),
        );

        test_read_v("ff ff ff ff 0f", 0xffffffff, |reader| {
            reader.read_raw_varint32()
        });
        test_read_v("ff ff ff ff 0f", 0xffffffff, |reader| {
            reader.read_raw_varint64()
        });
    }

    #[test]
    fn test_input_stream_read_raw_varint_out_of_range() {
        test_read_partial("ff ff ff ff ff ff ff ff ff 02", |is| {
            assert!(is.read_raw_varint64().is_err());
        });
        test_read_partial("ff ff ff ff ff ff ff ff ff 02", |is| {
            assert!(is.read_raw_varint32().is_err());
        });
    }

    #[test]
    fn test_input_stream_read_raw_varint_too_long() {
        // varint cannot have length > 10
        test_read_partial("ff ff ff ff ff ff ff ff ff ff 01", |reader| {
            let error = reader.read_raw_varint64().unwrap_err().0;
            match *error {
                ProtobufError::WireError(..) => (),
                _ => panic!(),
            }
        });
        test_read_partial("ff ff ff ff ff ff ff ff ff ff 01", |reader| {
            let error = reader.read_raw_varint32().unwrap_err().0;
            match *error {
                ProtobufError::WireError(..) => (),
                _ => panic!(),
            }
        });
    }

    #[test]
    fn test_input_stream_read_raw_varint_unexpected_eof() {
        test_read_partial("96 97", |reader| {
            let error = reader.read_raw_varint32().unwrap_err().0;
            match *error {
                ProtobufError::WireError(..) => (),
                _ => panic!(),
            }
        });
    }

    #[test]
    fn test_input_stream_read_raw_varint_pos() {
        test_read_partial("95 01 98", |reader| {
            assert_eq!(149, reader.read_raw_varint32().unwrap());
            assert_eq!(2, reader.pos());
        });
    }

    #[test]
    fn test_input_stream_read_int32() {
        test_read_v("02", 2, |reader| reader.read_int32());
    }

    #[test]
    fn test_input_stream_read_float() {
        test_read_v("95 73 13 61", 17e19, |is| is.read_float());
    }

    #[test]
    fn test_input_stream_read_double() {
        test_read_v("40 d5 ab 68 b3 07 3d 46", 23e29, |is| is.read_double());
    }

    #[test]
    fn test_input_stream_skip_raw_bytes() {
        test_read("", |reader| {
            reader.skip_raw_bytes(0).unwrap();
        });
        test_read("aa bb", |reader| {
            reader.skip_raw_bytes(2).unwrap();
        });
        test_read("aa bb cc dd ee ff", |reader| {
            reader.skip_raw_bytes(6).unwrap();
        });
    }

    #[test]
    fn test_input_stream_read_raw_bytes() {
        test_read("", |reader| {
            assert_eq!(
                Vec::from(&b""[..]),
                reader.read_raw_bytes(0).expect("read_raw_bytes")
            );
        })
    }

    #[test]
    fn test_input_stream_limits() {
        test_read("aa bb cc", |is| {
            let old_limit = is.push_limit(1).unwrap();
            assert_eq!(1, is.bytes_until_limit());
            let r1 = is.read_raw_bytes(1).unwrap();
            assert_eq!(&[0xaa as u8], &r1[..]);
            is.pop_limit(old_limit);
            let r2 = is.read_raw_bytes(2).unwrap();
            assert_eq!(&[0xbb as u8, 0xcc], &r2[..]);
        });
    }

    #[test]
    fn test_input_stream_io_read() {
        test_read("aa bb cc", |is| {
            let mut buf = [0; 3];
            assert_eq!(Read::read(is, &mut buf).expect("io::Read"), 3);
            assert_eq!(buf, [0xaa, 0xbb, 0xcc]);
        });
    }

    #[test]
    fn test_input_stream_io_bufread() {
        test_read("aa bb cc", |is| {
            assert_eq!(
                BufRead::fill_buf(is).expect("io::BufRead::fill_buf"),
                &[0xaa, 0xbb, 0xcc]
            );
            BufRead::consume(is, 3);
        });
    }

    #[test]
    #[cfg_attr(miri, ignore)] // Miri is too slow for this test.
    fn test_input_stream_read_raw_bytes_into_huge() {
        let mut v = Vec::new();
        for i in 0..READ_RAW_BYTES_MAX_ALLOC + 1000 {
            v.push((i % 10) as u8);
        }

        let mut slice: &[u8] = v.as_slice();

        let mut is = CodedInputStream::new(&mut slice);

        let mut buf = Vec::new();

        is.read_raw_bytes_into(READ_RAW_BYTES_MAX_ALLOC as u32 + 10, &mut buf)
            .expect("read");

        assert_eq!(READ_RAW_BYTES_MAX_ALLOC + 10, buf.len());

        buf.clear();

        is.read_raw_bytes_into(1000 - 10, &mut buf).expect("read");

        assert_eq!(1000 - 10, buf.len());

        assert!(is.eof().expect("eof"));
    }

    // Copy of this test: https://tinyurl.com/34hfavtz
    #[test]
    fn test_skip_group() {
        // Create an output stream with a group in:
        // Field 1: string "field 1"
        // Field 2: group containing:
        //   Field 1: fixed int32 value 100
        //   Field 2: string "ignore me"
        //   Field 3: nested group containing
        //      Field 1: fixed int64 value 1000
        // Field 3: string "field 3"

        let mut vec = Vec::new();
        let mut os = CodedOutputStream::new(&mut vec);
        os.write_tag(1, WireType::LengthDelimited).unwrap();
        os.write_string_no_tag("field 1").unwrap();

        // The outer group...
        os.write_tag(2, WireType::StartGroup).unwrap();
        os.write_tag(1, WireType::Fixed32).unwrap();
        os.write_fixed32_no_tag(100).unwrap();
        os.write_tag(3, WireType::LengthDelimited).unwrap();
        os.write_string_no_tag("ignore me").unwrap();
        // The nested group...
        os.write_tag(3, WireType::StartGroup).unwrap();
        os.write_tag(1, WireType::Fixed64).unwrap();
        os.write_fixed64_no_tag(1000).unwrap();
        // Note: Not sure the field number is relevant for end group...
        os.write_tag(3, WireType::EndGroup).unwrap();

        // End the outer group
        os.write_tag(2, WireType::EndGroup).unwrap();

        os.write_tag(3, WireType::LengthDelimited).unwrap();
        os.write_string_no_tag("field 3").unwrap();
        os.flush().unwrap();
        drop(os);

        let mut input = CodedInputStream::from_bytes(&vec);
        // Now act like a generated client
        assert_eq!(
            Tag::make(1, WireType::LengthDelimited),
            input.read_tag().unwrap()
        );
        assert_eq!("field 1", &input.read_string().unwrap());
        assert_eq!(
            Tag::make(2, WireType::StartGroup),
            input.read_tag().unwrap()
        );
        input.skip_field(WireType::StartGroup).unwrap();
        assert_eq!(
            Tag::make(3, WireType::LengthDelimited),
            input.read_tag().unwrap()
        );
        assert_eq!("field 3", input.read_string().unwrap());
    }
}

'''
'''--- protobuf/src/coded_output_stream/buffer.rs ---
use std::fmt;
use std::fmt::Formatter;
use std::mem::MaybeUninit;
use std::slice;

use crate::misc::maybe_uninit_write_slice;

pub(crate) struct OutputBuffer {
    // Actual buffer is owned by `OutputTarget`,
    // and here we alias the buffer so access to the buffer is branchless:
    // access does not require switch by actual target type: `&[], `Vec`, `Write` etc.
    // We don't access the actual buffer in `OutputTarget` except when
    // we initialize `buffer` field here.
    buffer: *mut [MaybeUninit<u8>],
    /// Position within the buffer.
    /// Always correct.
    pos_within_buf: usize,
}

impl fmt::Debug for OutputBuffer {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        f.debug_struct("OutputBuffer")
            .field("buffer.len", &self.buffer().len())
            .field("pos_within_buf", &self.pos_within_buf)
            .finish()
    }
}

impl OutputBuffer {
    #[inline]
    pub(crate) fn new(buffer: *mut [MaybeUninit<u8>]) -> OutputBuffer {
        Self {
            buffer,
            pos_within_buf: 0,
        }
    }

    /// Whole buffer: written data + unwritten data.
    #[inline]
    pub(crate) fn buffer(&self) -> &[MaybeUninit<u8>] {
        unsafe { &*self.buffer }
    }

    #[inline]
    fn buffer_mut(&mut self) -> &mut [MaybeUninit<u8>] {
        unsafe { &mut *self.buffer }
    }

    #[inline]
    pub(crate) fn pos_within_buf(&self) -> usize {
        self.pos_within_buf
    }

    #[inline]
    pub(crate) fn filled(&self) -> &[u8] {
        // SAFETY: This type invariant is data is filled up to `pos_within_buf`.
        unsafe { slice::from_raw_parts_mut(self.buffer as *mut u8, self.pos_within_buf) }
    }

    #[inline]
    pub(crate) fn unfilled(&mut self) -> &mut [MaybeUninit<u8>] {
        // SAFETY: This type invariant is `pos_within_buf` is smaller than buffer length.
        let pos_within_buf = self.pos_within_buf;
        unsafe { self.buffer_mut().get_unchecked_mut(pos_within_buf..) }
    }

    #[inline]
    pub(crate) fn unfilled_len(&self) -> usize {
        self.buffer().len() - self.pos_within_buf
    }

    #[inline]
    pub(crate) unsafe fn advance(&mut self, n: usize) {
        debug_assert!(n <= self.unfilled_len());
        self.pos_within_buf += n;
    }

    #[inline]
    pub(crate) fn rewind(&mut self) {
        self.pos_within_buf = 0;
    }

    #[inline]
    pub(crate) fn replace_buffer_keep_pos(&mut self, buffer: *mut [MaybeUninit<u8>]) {
        unsafe {
            assert!(self.pos_within_buf <= (&*buffer).len());
        }
        self.buffer = buffer;
    }

    #[inline]
    pub(crate) unsafe fn write_byte(&mut self, b: u8) {
        debug_assert!(self.unfilled_len() >= 1);
        // SAFETY: caller is responsible for ensuring that byte fits in the buffer.
        let pos_within_buf = self.pos_within_buf;
        self.buffer_mut().get_unchecked_mut(pos_within_buf).write(b);
        self.pos_within_buf += 1;
    }

    #[inline]
    pub(crate) unsafe fn write_bytes(&mut self, bytes: &[u8]) {
        debug_assert!(self.unfilled_len() >= bytes.len());
        let bottom = self.pos_within_buf as usize;
        let top = bottom + (bytes.len() as usize);
        // SAFETY: caller is responsible for ensuring that `bytes` fits in the buffer.
        let buffer = self.buffer_mut().get_unchecked_mut(bottom..top);
        maybe_uninit_write_slice(buffer, bytes);
        self.pos_within_buf += bytes.len();
    }
}

'''
'''--- protobuf/src/coded_output_stream/mod.rs ---
mod buffer;
mod output_target;
pub(crate) mod with;

use std::io;
use std::io::Write;
use std::mem::MaybeUninit;
use std::ptr;
use std::slice;

use crate::byteorder::LITTLE_ENDIAN;
use crate::coded_output_stream::buffer::OutputBuffer;
use crate::coded_output_stream::output_target::OutputTarget;
use crate::error::ProtobufError;
use crate::rt::packed::vec_packed_enum_or_unknown_data_size;
use crate::rt::packed::vec_packed_fixed_data_size;
use crate::rt::packed::vec_packed_varint_data_size;
use crate::rt::packed::vec_packed_varint_zigzag_data_size;
use crate::varint::encode::encode_varint32;
use crate::varint::encode::encode_varint64;
use crate::varint::encode::encoded_varint64_len;
use crate::varint::MAX_VARINT_ENCODED_LEN;
use crate::wire_format;
use crate::wire_format::check_message_size;
use crate::wire_format::WireType;
use crate::wire_format::MAX_MESSAGE_SIZE;
use crate::zigzag::encode_zig_zag_32;
use crate::zigzag::encode_zig_zag_64;
use crate::Enum;
use crate::EnumOrUnknown;
use crate::Message;
use crate::MessageDyn;
use crate::MessageFull;
use crate::UnknownFields;
use crate::UnknownValueRef;

// Equal to the default buffer size of `BufWriter`, so when
// `CodedOutputStream` wraps `BufWriter`, it often skips double buffering.
const OUTPUT_STREAM_BUFFER_SIZE: usize = 8 * 1024;

/// Buffered write with handy utilities
#[derive(Debug)]
pub struct CodedOutputStream<'a> {
    target: OutputTarget<'a>,
    buffer: OutputBuffer,
    /// Absolute position of the buffer start.
    pos_of_buffer_start: u64,
}

impl<'a> CodedOutputStream<'a> {
    /// Construct from given `Write`.
    ///
    /// `CodedOutputStream` is buffered even if `Write` is not
    pub fn new(writer: &'a mut dyn Write) -> CodedOutputStream<'a> {
        let buffer_len = OUTPUT_STREAM_BUFFER_SIZE;

        let mut buffer_storage = Vec::with_capacity(buffer_len);

        // SAFETY: we are not using the `buffer_storage`
        // except for initializing the `buffer` field.
        // See `buffer` field documentation.
        let buffer = OutputBuffer::new(buffer_storage.spare_capacity_mut());

        CodedOutputStream {
            target: OutputTarget::Write(writer, buffer_storage),
            buffer,
            pos_of_buffer_start: 0,
        }
    }

    /// `CodedOutputStream` which writes directly to bytes.
    ///
    /// Attempt to write more than bytes capacity results in error.
    pub fn bytes(bytes: &'a mut [u8]) -> CodedOutputStream<'a> {
        // SAFETY: it is safe to cast from &mut [u8] to &mut [MaybeUninit<u8>].
        let buffer =
            ptr::slice_from_raw_parts_mut(bytes.as_mut_ptr() as *mut MaybeUninit<u8>, bytes.len());
        let buffer = OutputBuffer::new(buffer);
        CodedOutputStream {
            target: OutputTarget::Bytes,
            buffer,
            pos_of_buffer_start: 0,
        }
    }

    /// `CodedOutputStream` which writes directly to `Vec<u8>`.
    pub fn vec(vec: &'a mut Vec<u8>) -> CodedOutputStream<'a> {
        let buffer = OutputBuffer::new(vec.spare_capacity_mut());
        CodedOutputStream {
            target: OutputTarget::Vec(vec),
            buffer,
            pos_of_buffer_start: 0,
        }
    }

    pub(crate) fn reserve_additional(
        &mut self,
        additional: u32,
        message: &str,
    ) -> crate::Result<()> {
        if additional as usize <= self.buffer.unfilled_len() {
            return Ok(());
        }
        match &mut self.target {
            OutputTarget::Write(..) => Ok(()),
            OutputTarget::Vec(v) => {
                let reserve = (additional as usize)
                    .checked_add(self.buffer.pos_within_buf())
                    .unwrap();
                v.reserve(reserve);
                // `pos_within_buf` remains unchanged.
                self.buffer.replace_buffer_keep_pos(v.spare_capacity_mut());
                Ok(())
            }
            OutputTarget::Bytes => {
                Err(ProtobufError::BufferHasNotEnoughCapacity(message.to_owned()).into())
            }
        }
    }

    pub(crate) fn reserve_additional_for_length_delimited(
        &mut self,
        size: u32,
        message: &str,
    ) -> crate::Result<()> {
        debug_assert!(
            size <= MAX_MESSAGE_SIZE as u32,
            "Caller of this function is responsible to guarantee \
            that message size does not exceed; size: {}, MAX_MESSAGE_SIZE: {}",
            size,
            MAX_MESSAGE_SIZE,
        );
        let reserve = size + encoded_varint64_len(size as u64) as u32;
        self.reserve_additional(reserve, message)
    }

    /// Total number of bytes written to this stream.
    ///
    /// This number may be larger than the actual number of bytes written to the underlying stream,
    /// if the buffer was not flushed.
    ///
    /// The number may be inaccurate if there was an error during the write.
    pub fn total_bytes_written(&self) -> u64 {
        self.pos_of_buffer_start + self.buffer.pos_within_buf() as u64
    }

    /// Check if EOF is reached.
    ///
    /// # Panics
    ///
    /// If underlying write has no EOF
    pub fn check_eof(&self) {
        match self.target {
            OutputTarget::Bytes => {
                assert_eq!(
                    self.buffer.buffer().len() as u64,
                    self.buffer.pos_within_buf() as u64
                );
            }
            OutputTarget::Write(..) | OutputTarget::Vec(..) => {
                panic!("must not be called with Writer or Vec");
            }
        }
    }

    fn refresh_buffer(&mut self) -> crate::Result<()> {
        match self.target {
            OutputTarget::Write(ref mut write, _) => {
                write.write_all(self.buffer.filled())?;
                self.pos_of_buffer_start += self.buffer.pos_within_buf() as u64;
                self.buffer.rewind();
            }
            OutputTarget::Vec(ref mut vec) => unsafe {
                let vec_len = vec.len();
                assert!(vec_len + self.buffer.pos_within_buf() <= vec.capacity());
                vec.set_len(vec_len + self.buffer.pos_within_buf());
                vec.reserve(1);
                self.pos_of_buffer_start += self.buffer.pos_within_buf() as u64;
                self.buffer = OutputBuffer::new(vec.spare_capacity_mut());
            },
            OutputTarget::Bytes => {
                return Err(ProtobufError::IoError(io::Error::new(
                    io::ErrorKind::Other,
                    "given slice is too small to serialize the message",
                ))
                .into());
            }
        }
        Ok(())
    }

    /// Flush to buffer to the underlying buffer.
    /// Note that `CodedOutputStream` does `flush` in the destructor,
    /// however, if `flush` in destructor fails, then destructor panics
    /// and program terminates. So it's advisable to explicitly call flush
    /// before destructor.
    pub fn flush(&mut self) -> crate::Result<()> {
        match &mut self.target {
            OutputTarget::Bytes => Ok(()),
            OutputTarget::Vec(vec) => {
                let vec_len = vec.len();
                assert!(vec_len + self.buffer.pos_within_buf() <= vec.capacity());
                unsafe {
                    vec.set_len(vec_len + self.buffer.pos_within_buf());
                }
                self.pos_of_buffer_start += self.buffer.pos_within_buf() as u64;
                self.buffer = OutputBuffer::new(vec.spare_capacity_mut());
                Ok(())
            }
            OutputTarget::Write(..) => self.refresh_buffer(),
        }
    }

    /// Write a byte
    pub fn write_raw_byte(&mut self, byte: u8) -> crate::Result<()> {
        if self.buffer.unfilled_len() == 0 {
            self.refresh_buffer()?;
        }
        unsafe { self.buffer.write_byte(byte) };
        Ok(())
    }

    /// Write bytes
    pub fn write_raw_bytes(&mut self, bytes: &[u8]) -> crate::Result<()> {
        if bytes.len() <= self.buffer.unfilled_len() {
            // SAFETY: we've just checked that there's enough space in the buffer.
            unsafe { self.buffer.write_bytes(bytes) };
            return Ok(());
        }

        self.refresh_buffer()?;

        assert!(self.buffer.pos_within_buf() == 0);

        if bytes.len() <= self.buffer.unfilled_len() {
            // SAFETY: we've just checked that there's enough space in the buffer.
            unsafe { self.buffer.write_bytes(bytes) };
            return Ok(());
        }

        match self.target {
            OutputTarget::Bytes => {
                unreachable!();
            }
            OutputTarget::Write(ref mut write, _) => {
                write.write_all(bytes)?;
            }
            OutputTarget::Vec(ref mut vec) => {
                assert!(self.buffer.pos_within_buf() == 0);
                vec.extend(bytes);
                self.buffer = OutputBuffer::new(vec.spare_capacity_mut());
                self.pos_of_buffer_start += bytes.len() as u64;
            }
        }
        Ok(())
    }

    /// Write a tag
    pub fn write_tag(&mut self, field_number: u32, wire_type: WireType) -> crate::Result<()> {
        self.write_raw_varint32(wire_format::Tag::make(field_number, wire_type).value())
    }

    /// Write varint
    pub fn write_raw_varint32(&mut self, value: u32) -> crate::Result<()> {
        if self.buffer.unfilled_len() >= 5 {
            // fast path
            unsafe {
                let len = encode_varint32(value, self.buffer.unfilled());
                self.buffer.advance(len);
            };
            Ok(())
        } else {
            // slow path
            let buf = &mut [0u8; 5];
            let len = encode_varint32(value, unsafe {
                slice::from_raw_parts_mut(buf.as_mut_ptr() as *mut MaybeUninit<u8>, buf.len())
            });
            self.write_raw_bytes(&buf[..len])
        }
    }

    /// Write varint
    pub fn write_raw_varint64(&mut self, value: u64) -> crate::Result<()> {
        if self.buffer.unfilled_len() >= MAX_VARINT_ENCODED_LEN {
            // fast path
            unsafe {
                let len = encode_varint64(value, self.buffer.unfilled());
                self.buffer.advance(len);
            };
            Ok(())
        } else {
            // slow path
            let buf = &mut [0u8; MAX_VARINT_ENCODED_LEN];
            let len = encode_varint64(value, unsafe {
                slice::from_raw_parts_mut(buf.as_mut_ptr() as *mut MaybeUninit<u8>, buf.len())
            });
            self.write_raw_bytes(&buf[..len])
        }
    }

    /// Write 32-bit integer little endian
    pub fn write_raw_little_endian32(&mut self, value: u32) -> crate::Result<()> {
        self.write_raw_bytes(&value.to_le_bytes())
    }

    /// Write 64-bit integer little endian
    pub fn write_raw_little_endian64(&mut self, value: u64) -> crate::Result<()> {
        self.write_raw_bytes(&value.to_le_bytes())
    }

    /// Write `float`
    pub fn write_float_no_tag(&mut self, value: f32) -> crate::Result<()> {
        self.write_raw_little_endian32(value.to_bits())
    }

    /// Write `double`
    pub fn write_double_no_tag(&mut self, value: f64) -> crate::Result<()> {
        self.write_raw_little_endian64(value.to_bits())
    }

    /// Write `float` field
    pub fn write_float(&mut self, field_number: u32, value: f32) -> crate::Result<()> {
        self.write_tag(field_number, WireType::Fixed32)?;
        self.write_float_no_tag(value)?;
        Ok(())
    }

    /// Write `double` field
    pub fn write_double(&mut self, field_number: u32, value: f64) -> crate::Result<()> {
        self.write_tag(field_number, WireType::Fixed64)?;
        self.write_double_no_tag(value)?;
        Ok(())
    }

    /// Write varint
    pub fn write_uint64_no_tag(&mut self, value: u64) -> crate::Result<()> {
        self.write_raw_varint64(value)
    }

    /// Write varint
    pub fn write_uint32_no_tag(&mut self, value: u32) -> crate::Result<()> {
        self.write_raw_varint32(value)
    }

    /// Write varint
    pub fn write_int64_no_tag(&mut self, value: i64) -> crate::Result<()> {
        self.write_raw_varint64(value as u64)
    }

    /// Write varint
    pub fn write_int32_no_tag(&mut self, value: i32) -> crate::Result<()> {
        self.write_raw_varint64(value as u64)
    }

    /// Write zigzag varint
    pub fn write_sint64_no_tag(&mut self, value: i64) -> crate::Result<()> {
        self.write_uint64_no_tag(encode_zig_zag_64(value))
    }

    /// Write zigzag varint
    pub fn write_sint32_no_tag(&mut self, value: i32) -> crate::Result<()> {
        self.write_uint32_no_tag(encode_zig_zag_32(value))
    }

    /// Write `fixed64`
    pub fn write_fixed64_no_tag(&mut self, value: u64) -> crate::Result<()> {
        self.write_raw_little_endian64(value)
    }

    /// Write `fixed32`
    pub fn write_fixed32_no_tag(&mut self, value: u32) -> crate::Result<()> {
        self.write_raw_little_endian32(value)
    }

    /// Write `sfixed64`
    pub fn write_sfixed64_no_tag(&mut self, value: i64) -> crate::Result<()> {
        self.write_raw_little_endian64(value as u64)
    }

    /// Write `sfixed32`
    pub fn write_sfixed32_no_tag(&mut self, value: i32) -> crate::Result<()> {
        self.write_raw_little_endian32(value as u32)
    }

    /// Write `bool`
    pub fn write_bool_no_tag(&mut self, value: bool) -> crate::Result<()> {
        self.write_raw_varint32(if value { 1 } else { 0 })
    }

    /// Write `enum`
    pub fn write_enum_no_tag(&mut self, value: i32) -> crate::Result<()> {
        self.write_int32_no_tag(value)
    }

    /// Write `enum`
    pub fn write_enum_obj_no_tag<E>(&mut self, value: E) -> crate::Result<()>
    where
        E: Enum,
    {
        self.write_enum_no_tag(value.value())
    }

    /// Write `enum`
    pub fn write_enum_or_unknown_no_tag<E>(&mut self, value: EnumOrUnknown<E>) -> crate::Result<()>
    where
        E: Enum,
    {
        self.write_enum_no_tag(value.value())
    }

    /// Write unknown value
    pub fn write_unknown_no_tag(&mut self, unknown: UnknownValueRef) -> crate::Result<()> {
        match unknown {
            UnknownValueRef::Fixed64(fixed64) => self.write_raw_little_endian64(fixed64),
            UnknownValueRef::Fixed32(fixed32) => self.write_raw_little_endian32(fixed32),
            UnknownValueRef::Varint(varint) => self.write_raw_varint64(varint),
            UnknownValueRef::LengthDelimited(bytes) => self.write_bytes_no_tag(bytes),
        }
    }

    /// Write `uint64` field
    pub fn write_uint64(&mut self, field_number: u32, value: u64) -> crate::Result<()> {
        self.write_tag(field_number, WireType::Varint)?;
        self.write_uint64_no_tag(value)?;
        Ok(())
    }

    /// Write `uint32` field
    pub fn write_uint32(&mut self, field_number: u32, value: u32) -> crate::Result<()> {
        self.write_tag(field_number, WireType::Varint)?;
        self.write_uint32_no_tag(value)?;
        Ok(())
    }

    /// Write `int64` field
    pub fn write_int64(&mut self, field_number: u32, value: i64) -> crate::Result<()> {
        self.write_tag(field_number, WireType::Varint)?;
        self.write_int64_no_tag(value)?;
        Ok(())
    }

    /// Write `int32` field
    pub fn write_int32(&mut self, field_number: u32, value: i32) -> crate::Result<()> {
        self.write_tag(field_number, WireType::Varint)?;
        self.write_int32_no_tag(value)?;
        Ok(())
    }

    /// Write `sint64` field
    pub fn write_sint64(&mut self, field_number: u32, value: i64) -> crate::Result<()> {
        self.write_tag(field_number, WireType::Varint)?;
        self.write_sint64_no_tag(value)?;
        Ok(())
    }

    /// Write `sint32` field
    pub fn write_sint32(&mut self, field_number: u32, value: i32) -> crate::Result<()> {
        self.write_tag(field_number, WireType::Varint)?;
        self.write_sint32_no_tag(value)?;
        Ok(())
    }

    /// Write `fixed64` field
    pub fn write_fixed64(&mut self, field_number: u32, value: u64) -> crate::Result<()> {
        self.write_tag(field_number, WireType::Fixed64)?;
        self.write_fixed64_no_tag(value)?;
        Ok(())
    }

    /// Write `fixed32` field
    pub fn write_fixed32(&mut self, field_number: u32, value: u32) -> crate::Result<()> {
        self.write_tag(field_number, WireType::Fixed32)?;
        self.write_fixed32_no_tag(value)?;
        Ok(())
    }

    /// Write `sfixed64` field
    pub fn write_sfixed64(&mut self, field_number: u32, value: i64) -> crate::Result<()> {
        self.write_tag(field_number, WireType::Fixed64)?;
        self.write_sfixed64_no_tag(value)?;
        Ok(())
    }

    /// Write `sfixed32` field
    pub fn write_sfixed32(&mut self, field_number: u32, value: i32) -> crate::Result<()> {
        self.write_tag(field_number, WireType::Fixed32)?;
        self.write_sfixed32_no_tag(value)?;
        Ok(())
    }

    /// Write `bool` field
    pub fn write_bool(&mut self, field_number: u32, value: bool) -> crate::Result<()> {
        self.write_tag(field_number, WireType::Varint)?;
        self.write_bool_no_tag(value)?;
        Ok(())
    }

    /// Write `enum` field
    pub fn write_enum(&mut self, field_number: u32, value: i32) -> crate::Result<()> {
        self.write_tag(field_number, WireType::Varint)?;
        self.write_enum_no_tag(value)?;
        Ok(())
    }

    /// Write `enum` field
    pub fn write_enum_obj<E>(&mut self, field_number: u32, value: E) -> crate::Result<()>
    where
        E: Enum,
    {
        self.write_enum(field_number, value.value())
    }

    /// Write `enum` field
    pub fn write_enum_or_unknown<E>(
        &mut self,
        field_number: u32,
        value: EnumOrUnknown<E>,
    ) -> crate::Result<()>
    where
        E: Enum,
    {
        self.write_enum(field_number, value.value())
    }

    /// Write unknown field
    pub fn write_unknown(
        &mut self,
        field_number: u32,
        value: UnknownValueRef,
    ) -> crate::Result<()> {
        self.write_tag(field_number, value.wire_type())?;
        self.write_unknown_no_tag(value)?;
        Ok(())
    }

    /// Write unknown fields
    pub fn write_unknown_fields(&mut self, fields: &UnknownFields) -> crate::Result<()> {
        for (number, value) in fields {
            self.write_unknown(number, value)?;
        }
        Ok(())
    }

    /// Write unknown fields sorting them by name
    // TODO: make unknown fields deterministic and remove this.
    pub(crate) fn write_unknown_fields_sorted(
        &mut self,
        fields: &UnknownFields,
    ) -> crate::Result<()> {
        let mut fields: Vec<_> = fields.iter().collect();
        fields.sort_by_key(|(n, _)| *n);
        for (number, value) in fields {
            self.write_unknown(number, value)?;
        }
        Ok(())
    }

    /// Write bytes
    pub fn write_bytes_no_tag(&mut self, bytes: &[u8]) -> crate::Result<()> {
        self.write_raw_varint32(bytes.len() as u32)?;
        self.write_raw_bytes(bytes)?;
        Ok(())
    }

    /// Write string
    pub fn write_string_no_tag(&mut self, s: &str) -> crate::Result<()> {
        self.write_bytes_no_tag(s.as_bytes())
    }

    /// Write message
    pub fn write_message_no_tag<M: Message>(&mut self, msg: &M) -> crate::Result<()> {
        msg.write_length_delimited_to(self)
    }

    /// Write dynamic message
    pub fn write_message_no_tag_dyn(&mut self, msg: &dyn MessageDyn) -> crate::Result<()> {
        let size = msg.compute_size_dyn();
        let size = check_message_size(size)?;
        self.write_raw_varint32(size)?;
        msg.write_to_dyn(self)?;
        Ok(())
    }

    /// Write `bytes` field
    pub fn write_bytes(&mut self, field_number: u32, bytes: &[u8]) -> crate::Result<()> {
        self.write_tag(field_number, WireType::LengthDelimited)?;
        self.write_bytes_no_tag(bytes)?;
        Ok(())
    }

    /// Write `string` field
    pub fn write_string(&mut self, field_number: u32, s: &str) -> crate::Result<()> {
        self.write_tag(field_number, WireType::LengthDelimited)?;
        self.write_string_no_tag(s)?;
        Ok(())
    }

    /// Write repeated packed float values.
    pub fn write_repeated_packed_float_no_tag(&mut self, values: &[f32]) -> crate::Result<()> {
        if LITTLE_ENDIAN {
            // SAFETY: it is safe to transmute floats to bytes.
            let bytes =
                unsafe { slice::from_raw_parts(values.as_ptr() as *const u8, values.len() * 4) };
            self.write_raw_bytes(bytes)
        } else {
            for v in values {
                self.write_float_no_tag(*v)?;
            }
            Ok(())
        }
    }

    /// Write field header and data for repeated packed float.
    pub fn write_repeated_packed_float(
        &mut self,
        field_number: u32,
        values: &[f32],
    ) -> crate::Result<()> {
        if values.is_empty() {
            return Ok(());
        }
        self.write_tag(field_number, WireType::LengthDelimited)?;
        let data_size = vec_packed_fixed_data_size(values);
        self.write_raw_varint32(data_size as u32)?;
        self.write_repeated_packed_float_no_tag(values)?;
        Ok(())
    }

    /// Write repeated packed double values.
    pub fn write_repeated_packed_double_no_tag(&mut self, values: &[f64]) -> crate::Result<()> {
        if LITTLE_ENDIAN {
            // SAFETY: it is safe to transmute doubles to bytes.
            let bytes =
                unsafe { slice::from_raw_parts(values.as_ptr() as *const u8, values.len() * 8) };
            self.write_raw_bytes(bytes)
        } else {
            for v in values {
                self.write_double_no_tag(*v)?;
            }
            Ok(())
        }
    }

    /// Write field header and data for repeated packed double.
    pub fn write_repeated_packed_double(
        &mut self,
        field_number: u32,
        values: &[f64],
    ) -> crate::Result<()> {
        if values.is_empty() {
            return Ok(());
        }
        self.write_tag(field_number, WireType::LengthDelimited)?;
        let data_size = vec_packed_fixed_data_size(values);
        self.write_raw_varint32(data_size as u32)?;
        self.write_repeated_packed_double_no_tag(values)?;
        Ok(())
    }

    /// Write repeated packed fixed32 values.
    pub fn write_repeated_packed_fixed32_no_tag(&mut self, values: &[u32]) -> crate::Result<()> {
        if LITTLE_ENDIAN {
            // SAFETY: it is safe to transmute integer to bytes.
            let bytes =
                unsafe { slice::from_raw_parts(values.as_ptr() as *const u8, values.len() * 4) };
            self.write_raw_bytes(bytes)?;
        } else {
            for v in values {
                self.write_fixed32_no_tag(*v)?;
            }
        }
        Ok(())
    }

    /// Write field header and data for repeated packed fixed32.
    pub fn write_repeated_packed_fixed32(
        &mut self,
        field_number: u32,
        values: &[u32],
    ) -> crate::Result<()> {
        if values.is_empty() {
            return Ok(());
        }
        self.write_tag(field_number, WireType::LengthDelimited)?;
        let data_size = vec_packed_fixed_data_size(values);
        self.write_raw_varint32(data_size as u32)?;
        self.write_repeated_packed_fixed32_no_tag(values)?;
        Ok(())
    }

    /// Write repeated packed fixed64 values.
    pub fn write_repeated_packed_fixed64_no_tag(&mut self, values: &[u64]) -> crate::Result<()> {
        if LITTLE_ENDIAN {
            // SAFETY: it is safe to transmute integer to bytes.
            let bytes =
                unsafe { slice::from_raw_parts(values.as_ptr() as *const u8, values.len() * 8) };
            self.write_raw_bytes(bytes)?;
        } else {
            for v in values {
                self.write_fixed64_no_tag(*v)?;
            }
        }
        Ok(())
    }

    /// Write field header and data for repeated packed fixed64.
    pub fn write_repeated_packed_fixed64(
        &mut self,
        field_number: u32,
        values: &[u64],
    ) -> crate::Result<()> {
        if values.is_empty() {
            return Ok(());
        }
        self.write_tag(field_number, WireType::LengthDelimited)?;
        let data_size = vec_packed_fixed_data_size(values);
        self.write_raw_varint32(data_size as u32)?;
        self.write_repeated_packed_fixed64_no_tag(values)?;
        Ok(())
    }

    /// Write repeated packed sfixed32 values.
    pub fn write_repeated_packed_sfixed32_no_tag(&mut self, values: &[i32]) -> crate::Result<()> {
        if LITTLE_ENDIAN {
            // SAFETY: it is safe to transmute integer to bytes.
            let bytes =
                unsafe { slice::from_raw_parts(values.as_ptr() as *const u8, values.len() * 4) };
            self.write_raw_bytes(bytes)?;
        } else {
            for v in values {
                self.write_sfixed32_no_tag(*v)?;
            }
        }
        Ok(())
    }

    /// Write field header and data for repeated packed sfixed32.
    pub fn write_repeated_packed_sfixed32(
        &mut self,
        field_number: u32,
        values: &[i32],
    ) -> crate::Result<()> {
        if values.is_empty() {
            return Ok(());
        }
        self.write_tag(field_number, WireType::LengthDelimited)?;
        let data_size = vec_packed_fixed_data_size(values);
        self.write_raw_varint32(data_size as u32)?;
        self.write_repeated_packed_sfixed32_no_tag(values)?;
        Ok(())
    }

    /// Write repeated packed sfixed64 values.
    pub fn write_repeated_packed_sfixed64_no_tag(&mut self, values: &[i64]) -> crate::Result<()> {
        if LITTLE_ENDIAN {
            // SAFETY: it is safe to transmute integer to bytes.
            let bytes =
                unsafe { slice::from_raw_parts(values.as_ptr() as *const u8, values.len() * 8) };
            self.write_raw_bytes(bytes)?;
        } else {
            for v in values {
                self.write_sfixed64_no_tag(*v)?;
            }
        }
        Ok(())
    }

    /// Write field header and data for repeated packed sfixed64.
    pub fn write_repeated_packed_sfixed64(
        &mut self,
        field_number: u32,
        values: &[i64],
    ) -> crate::Result<()> {
        if values.is_empty() {
            return Ok(());
        }
        self.write_tag(field_number, WireType::LengthDelimited)?;
        let data_size = vec_packed_fixed_data_size(values);
        self.write_raw_varint32(data_size as u32)?;
        self.write_repeated_packed_sfixed64_no_tag(values)?;
        Ok(())
    }

    /// Write repeated packed int32 values.
    pub fn write_repeated_packed_int32_no_tag(&mut self, values: &[i32]) -> crate::Result<()> {
        for v in values {
            self.write_int32_no_tag(*v)?;
        }
        Ok(())
    }

    /// Write field header and data for repeated packed int32.
    pub fn write_repeated_packed_int32(
        &mut self,
        field_number: u32,
        values: &[i32],
    ) -> crate::Result<()> {
        if values.is_empty() {
            return Ok(());
        }
        self.write_tag(field_number, WireType::LengthDelimited)?;
        let data_size = vec_packed_varint_data_size(values);
        self.write_raw_varint32(data_size as u32)?;
        self.write_repeated_packed_int32_no_tag(values)?;
        Ok(())
    }

    /// Write repeated packed int64 values.
    pub fn write_repeated_packed_int64_no_tag(&mut self, values: &[i64]) -> crate::Result<()> {
        for v in values {
            self.write_int64_no_tag(*v)?;
        }
        Ok(())
    }

    /// Write field header and data for repeated packed int64.
    pub fn write_repeated_packed_int64(
        &mut self,
        field_number: u32,
        values: &[i64],
    ) -> crate::Result<()> {
        if values.is_empty() {
            return Ok(());
        }
        self.write_tag(field_number, WireType::LengthDelimited)?;
        let data_size = vec_packed_varint_data_size(values);
        self.write_raw_varint32(data_size as u32)?;
        self.write_repeated_packed_int64_no_tag(values)?;
        Ok(())
    }

    /// Write repeated packed uint32 values.
    pub fn write_repeated_packed_uint32_no_tag(&mut self, values: &[u32]) -> crate::Result<()> {
        for v in values {
            self.write_uint32_no_tag(*v)?;
        }
        Ok(())
    }

    /// Write field header and data for repeated packed uint32.
    pub fn write_repeated_packed_uint32(
        &mut self,
        field_number: u32,
        values: &[u32],
    ) -> crate::Result<()> {
        if values.is_empty() {
            return Ok(());
        }
        self.write_tag(field_number, WireType::LengthDelimited)?;
        let data_size = vec_packed_varint_data_size(values);
        self.write_raw_varint32(data_size as u32)?;
        self.write_repeated_packed_uint32_no_tag(values)?;
        Ok(())
    }

    /// Write repeated packed uint64 values.
    pub fn write_repeated_packed_uint64_no_tag(&mut self, values: &[u64]) -> crate::Result<()> {
        for v in values {
            self.write_uint64_no_tag(*v)?;
        }
        Ok(())
    }

    /// Write field header and data for repeated packed uint64.
    pub fn write_repeated_packed_uint64(
        &mut self,
        field_number: u32,
        values: &[u64],
    ) -> crate::Result<()> {
        if values.is_empty() {
            return Ok(());
        }
        self.write_tag(field_number, WireType::LengthDelimited)?;
        let data_size = vec_packed_varint_data_size(values);
        self.write_raw_varint32(data_size as u32)?;
        self.write_repeated_packed_uint64_no_tag(values)?;
        Ok(())
    }

    /// Write repeated packed sint32 values.
    pub fn write_repeated_packed_sint32_no_tag(&mut self, values: &[i32]) -> crate::Result<()> {
        for v in values {
            self.write_sint32_no_tag(*v)?;
        }
        Ok(())
    }

    /// Write field header and data for repeated packed sint32.
    pub fn write_repeated_packed_sint32(
        &mut self,
        field_number: u32,
        values: &[i32],
    ) -> crate::Result<()> {
        if values.is_empty() {
            return Ok(());
        }
        self.write_tag(field_number, WireType::LengthDelimited)?;
        let data_size = vec_packed_varint_zigzag_data_size(values);
        self.write_raw_varint32(data_size as u32)?;
        self.write_repeated_packed_sint32_no_tag(values)?;
        Ok(())
    }

    /// Write repeated packed sint64 values.
    pub fn write_repeated_packed_sint64_no_tag(&mut self, values: &[i64]) -> crate::Result<()> {
        for v in values {
            self.write_sint64_no_tag(*v)?;
        }
        Ok(())
    }

    /// Write field header and data for repeated packed sint64.
    pub fn write_repeated_packed_sint64(
        &mut self,
        field_number: u32,
        values: &[i64],
    ) -> crate::Result<()> {
        if values.is_empty() {
            return Ok(());
        }
        self.write_tag(field_number, WireType::LengthDelimited)?;
        let data_size = vec_packed_varint_zigzag_data_size(values);
        self.write_raw_varint32(data_size as u32)?;
        self.write_repeated_packed_sint64_no_tag(values)?;
        Ok(())
    }

    /// Write repeated packed bool values.
    pub fn write_repeated_packed_bool_no_tag(&mut self, values: &[bool]) -> crate::Result<()> {
        for v in values {
            self.write_bool_no_tag(*v)?;
        }
        Ok(())
    }

    /// Write field header and data for repeated packed bool.
    pub fn write_repeated_packed_bool(
        &mut self,
        field_number: u32,
        values: &[bool],
    ) -> crate::Result<()> {
        if values.is_empty() {
            return Ok(());
        }
        self.write_tag(field_number, WireType::LengthDelimited)?;
        let data_size = vec_packed_fixed_data_size(values);
        self.write_raw_varint32(data_size as u32)?;
        self.write_repeated_packed_bool_no_tag(values)?;
        Ok(())
    }

    /// Write repeated packed enum values.
    #[inline]
    pub fn write_repeated_packed_enum_or_unknown_no_tag<E: Enum>(
        &mut self,
        values: &[EnumOrUnknown<E>],
    ) -> crate::Result<()> {
        self.write_repeated_packed_int32_no_tag(EnumOrUnknown::cast_to_values(values))
    }

    /// Write field header and data for repeated packed enum.
    pub fn write_repeated_packed_enum_or_unknown<E: Enum>(
        &mut self,
        field_number: u32,
        values: &[EnumOrUnknown<E>],
    ) -> crate::Result<()> {
        if values.is_empty() {
            return Ok(());
        }
        self.write_tag(field_number, WireType::LengthDelimited)?;
        let data_size = vec_packed_enum_or_unknown_data_size(values);
        self.write_raw_varint32(data_size as u32)?;
        self.write_repeated_packed_enum_or_unknown_no_tag(values)?;
        Ok(())
    }

    /// Write `message` field
    pub fn write_message<M: MessageFull>(
        &mut self,
        field_number: u32,
        msg: &M,
    ) -> crate::Result<()> {
        self.write_tag(field_number, WireType::LengthDelimited)?;
        self.write_message_no_tag(msg)?;
        Ok(())
    }

    /// Write dynamic `message` field
    pub fn write_message_dyn(
        &mut self,
        field_number: u32,
        msg: &dyn MessageDyn,
    ) -> crate::Result<()> {
        self.write_tag(field_number, WireType::LengthDelimited)?;
        self.write_message_no_tag_dyn(msg)?;
        Ok(())
    }
}

impl<'a> Write for CodedOutputStream<'a> {
    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
        self.write_raw_bytes(buf)?;
        Ok(buf.len())
    }

    fn flush(&mut self) -> io::Result<()> {
        CodedOutputStream::flush(self).map_err(Into::into)
    }
}

impl<'a> Drop for CodedOutputStream<'a> {
    fn drop(&mut self) {
        // This may panic
        CodedOutputStream::flush(self).expect("failed to flush");
    }
}

#[cfg(test)]
mod test {
    use std::iter;

    use super::*;
    use crate::hex::decode_hex;
    use crate::hex::encode_hex;

    fn test_write<F>(expected: &str, mut gen: F)
    where
        F: FnMut(&mut CodedOutputStream) -> crate::Result<()>,
    {
        let expected_bytes = decode_hex(expected);

        // write to Write
        {
            let mut v = Vec::new();
            {
                let mut os = CodedOutputStream::new(&mut v as &mut dyn Write);
                gen(&mut os).unwrap();
                os.flush().unwrap();
            }
            assert_eq!(encode_hex(&expected_bytes), encode_hex(&v));
        }

        // write to &[u8]
        {
            let mut r = Vec::with_capacity(expected_bytes.len());
            r.resize(expected_bytes.len(), 0);
            {
                let mut os = CodedOutputStream::bytes(&mut r);
                gen(&mut os).unwrap();
                os.check_eof();
            }
            assert_eq!(encode_hex(&expected_bytes), encode_hex(&r));
        }

        // write to Vec<u8>
        {
            let mut r = Vec::new();
            r.extend(&[11, 22, 33, 44, 55, 66, 77]);
            {
                let mut os = CodedOutputStream::vec(&mut r);
                gen(&mut os).unwrap();
                os.flush().unwrap();
            }

            r.drain(..7);
            assert_eq!(encode_hex(&expected_bytes), encode_hex(&r));
        }
    }

    #[test]
    fn test_output_stream_write_raw_byte() {
        test_write("a1", |os| os.write_raw_byte(0xa1));
    }

    #[test]
    fn test_output_stream_write_tag() {
        test_write("08", |os| os.write_tag(1, WireType::Varint));
    }

    #[test]
    #[cfg_attr(miri, ignore)] // Miri is too slow for this test.
    fn test_output_stream_write_raw_bytes() {
        test_write("00 ab", |os| os.write_raw_bytes(&[0x00, 0xab]));

        let expected = iter::repeat("01 02 03 04")
            .take(2048)
            .collect::<Vec<_>>()
            .join(" ");
        test_write(&expected, |os| {
            for _ in 0..2048 {
                os.write_raw_bytes(&[0x01, 0x02, 0x03, 0x04])?;
            }

            Ok(())
        });
    }

    #[test]
    fn test_output_stream_write_raw_varint32() {
        test_write("96 01", |os| os.write_raw_varint32(150));
        test_write("ff ff ff ff 0f", |os| os.write_raw_varint32(0xffffffff));
    }

    #[test]
    fn test_output_stream_write_raw_varint64() {
        test_write("96 01", |os| os.write_raw_varint64(150));
        test_write("ff ff ff ff ff ff ff ff ff 01", |os| {
            os.write_raw_varint64(0xffffffffffffffff)
        });
    }

    #[test]
    fn test_output_stream_write_int32_no_tag() {
        test_write("ff ff ff ff ff ff ff ff ff 01", |os| {
            os.write_int32_no_tag(-1)
        });
    }

    #[test]
    fn test_output_stream_write_int64_no_tag() {
        test_write("ff ff ff ff ff ff ff ff ff 01", |os| {
            os.write_int64_no_tag(-1)
        });
    }

    #[test]
    fn test_output_stream_write_raw_little_endian32() {
        test_write("f1 e2 d3 c4", |os| os.write_raw_little_endian32(0xc4d3e2f1));
    }

    #[test]
    fn test_output_stream_write_float_no_tag() {
        test_write("95 73 13 61", |os| os.write_float_no_tag(17e19));
    }

    #[test]
    fn test_output_stream_write_double_no_tag() {
        test_write("40 d5 ab 68 b3 07 3d 46", |os| {
            os.write_double_no_tag(23e29)
        });
    }

    #[test]
    fn test_output_stream_write_raw_little_endian64() {
        test_write("f1 e2 d3 c4 b5 a6 07 f8", |os| {
            os.write_raw_little_endian64(0xf807a6b5c4d3e2f1)
        });
    }

    #[test]
    fn test_output_stream_io_write() {
        let expected = [0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77];

        // write to Write
        {
            let mut v = Vec::new();
            {
                let mut os = CodedOutputStream::new(&mut v as &mut dyn Write);
                Write::write(&mut os, &expected).expect("io::Write::write");
                Write::flush(&mut os).expect("io::Write::flush");
            }
            assert_eq!(expected, *v);
        }

        // write to &[u8]
        {
            let mut v = Vec::with_capacity(expected.len());
            v.resize(expected.len(), 0);
            {
                let mut os = CodedOutputStream::bytes(&mut v);
                Write::write(&mut os, &expected).expect("io::Write::write");
                Write::flush(&mut os).expect("io::Write::flush");
                os.check_eof();
            }
            assert_eq!(expected, *v);
        }

        // write to Vec<u8>
        {
            let mut v = Vec::new();
            {
                let mut os = CodedOutputStream::vec(&mut v);
                Write::write(&mut os, &expected).expect("io::Write::write");
                Write::flush(&mut os).expect("io::Write::flush");
            }
            assert_eq!(expected, *v);
        }
    }

    #[test]
    fn flush_for_vec_does_not_allocate_more() {
        let mut v = Vec::with_capacity(10);
        {
            let mut os = CodedOutputStream::vec(&mut v);
            for i in 0..10 {
                os.write_raw_byte(i as u8).unwrap();
            }
            os.flush().unwrap();
        }
        assert_eq!(10, v.len());
        // Previously, this allocated more data in buf.
        assert_eq!(10, v.capacity());
    }

    #[test]
    fn total_bytes_written_to_bytes() {
        let mut buf = vec![0; 10];
        let mut stream = CodedOutputStream::bytes(&mut buf);
        assert_eq!(0, stream.total_bytes_written());
        stream.write_raw_bytes(&[11, 22]).unwrap();
        assert_eq!(2, stream.total_bytes_written());
        stream.write_raw_bytes(&[33, 44, 55]).unwrap();
        assert_eq!(5, stream.total_bytes_written());
    }

    #[test]
    fn total_bytes_written_to_vec() {
        let mut buf = Vec::new();
        let mut stream = CodedOutputStream::vec(&mut buf);
        for i in 0..100 {
            stream.write_raw_bytes(&[0, 1, 2]).unwrap();
            assert_eq!((i + 1) * 3, stream.total_bytes_written());
        }
    }
}

'''
'''--- protobuf/src/coded_output_stream/output_target.rs ---
use std::fmt;
use std::io::Write;

/// Output buffer/writer for `CodedOutputStream`.
pub(crate) enum OutputTarget<'a> {
    Write(&'a mut dyn Write, Vec<u8>),
    Vec(&'a mut Vec<u8>),
    /// The buffer is passed as `&[u8]` to `CodedOutputStream` constructor
    /// and immediately converted to `buffer` field of `CodedOutputStream`,
    /// it is not needed to be stored here.
    /// Lifetime parameter of `CodedOutputStream` guarantees the buffer is valid
    /// during the lifetime of `CodedOutputStream`.
    Bytes,
}

impl<'a> fmt::Debug for OutputTarget<'a> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            OutputTarget::Write(_w, vec) => f
                .debug_struct("Write")
                .field("buf_len", &vec.len())
                .field("buf_cap", &vec.capacity())
                .finish_non_exhaustive(),
            OutputTarget::Vec(vec) => f
                .debug_struct("Vec")
                .field("len", &vec.len())
                .field("cap", &vec.capacity())
                .finish_non_exhaustive(),
            OutputTarget::Bytes => f.debug_tuple("Bytes").finish(),
        }
    }
}

'''
'''--- protobuf/src/coded_output_stream/with.rs ---
use std::io::Write;

use crate::CodedOutputStream;

pub(crate) trait WithCodedOutputStream {
    fn with_coded_output_stream<T, F>(self, cb: F) -> crate::Result<T>
    where
        F: FnOnce(&mut CodedOutputStream) -> crate::Result<T>;
}

impl<'a> WithCodedOutputStream for &'a mut (dyn Write + 'a) {
    fn with_coded_output_stream<T, F>(self, cb: F) -> crate::Result<T>
    where
        F: FnOnce(&mut CodedOutputStream) -> crate::Result<T>,
    {
        let mut os = CodedOutputStream::new(self);
        let r = cb(&mut os)?;
        os.flush()?;
        Ok(r)
    }
}

impl<'a> WithCodedOutputStream for &'a mut Vec<u8> {
    fn with_coded_output_stream<T, F>(mut self, cb: F) -> crate::Result<T>
    where
        F: FnOnce(&mut CodedOutputStream) -> crate::Result<T>,
    {
        let mut os = CodedOutputStream::vec(&mut self);
        let r = cb(&mut os)?;
        os.flush()?;
        Ok(r)
    }
}

'''
'''--- protobuf/src/descriptor.rs ---
// This file is generated by rust-protobuf 4.0.0-alpha.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `google/protobuf/descriptor.proto`

///  The protocol compiler can output a FileDescriptorSet containing the .proto
///  files it parses.
// @@protoc_insertion_point(message:google.protobuf.FileDescriptorSet)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FileDescriptorSet {
    // message fields
    // @@protoc_insertion_point(field:google.protobuf.FileDescriptorSet.file)
    pub file: ::std::vec::Vec<FileDescriptorProto>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.FileDescriptorSet.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FileDescriptorSet {
    fn default() -> &'a FileDescriptorSet {
        <FileDescriptorSet as crate::Message>::default_instance()
    }
}

impl FileDescriptorSet {
    pub fn new() -> FileDescriptorSet {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "file",
            |m: &FileDescriptorSet| { &m.file },
            |m: &mut FileDescriptorSet| { &mut m.file },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<FileDescriptorSet>(
            "FileDescriptorSet",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for FileDescriptorSet {
    const NAME: &'static str = "FileDescriptorSet";

    fn is_initialized(&self) -> bool {
        for v in &self.file {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.file.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.file {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.file {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FileDescriptorSet {
        FileDescriptorSet::new()
    }

    fn clear(&mut self) {
        self.file.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FileDescriptorSet {
        static instance: FileDescriptorSet = FileDescriptorSet {
            file: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for FileDescriptorSet {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FileDescriptorSet").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FileDescriptorSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for FileDescriptorSet {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Describes a complete .proto file.
// @@protoc_insertion_point(message:google.protobuf.FileDescriptorProto)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FileDescriptorProto {
    // message fields
    // @@protoc_insertion_point(field:google.protobuf.FileDescriptorProto.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.protobuf.FileDescriptorProto.package)
    pub package: ::std::option::Option<::std::string::String>,
    ///  Names of files imported by this file.
    // @@protoc_insertion_point(field:google.protobuf.FileDescriptorProto.dependency)
    pub dependency: ::std::vec::Vec<::std::string::String>,
    ///  Indexes of the public imported files in the dependency list above.
    // @@protoc_insertion_point(field:google.protobuf.FileDescriptorProto.public_dependency)
    pub public_dependency: ::std::vec::Vec<i32>,
    ///  Indexes of the weak imported files in the dependency list.
    ///  For Google-internal migration only. Do not use.
    // @@protoc_insertion_point(field:google.protobuf.FileDescriptorProto.weak_dependency)
    pub weak_dependency: ::std::vec::Vec<i32>,
    ///  All top-level definitions in this file.
    // @@protoc_insertion_point(field:google.protobuf.FileDescriptorProto.message_type)
    pub message_type: ::std::vec::Vec<DescriptorProto>,
    // @@protoc_insertion_point(field:google.protobuf.FileDescriptorProto.enum_type)
    pub enum_type: ::std::vec::Vec<EnumDescriptorProto>,
    // @@protoc_insertion_point(field:google.protobuf.FileDescriptorProto.service)
    pub service: ::std::vec::Vec<ServiceDescriptorProto>,
    // @@protoc_insertion_point(field:google.protobuf.FileDescriptorProto.extension)
    pub extension: ::std::vec::Vec<FieldDescriptorProto>,
    // @@protoc_insertion_point(field:google.protobuf.FileDescriptorProto.options)
    pub options: crate::MessageField<FileOptions>,
    ///  This field contains optional information about the original source code.
    ///  You may safely remove this entire field without harming runtime
    ///  functionality of the descriptors -- the information is needed only by
    ///  development tools.
    // @@protoc_insertion_point(field:google.protobuf.FileDescriptorProto.source_code_info)
    pub source_code_info: crate::MessageField<SourceCodeInfo>,
    ///  The syntax of the proto file.
    ///  The supported values are "proto2" and "proto3".
    // @@protoc_insertion_point(field:google.protobuf.FileDescriptorProto.syntax)
    pub syntax: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.FileDescriptorProto.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FileDescriptorProto {
    fn default() -> &'a FileDescriptorProto {
        <FileDescriptorProto as crate::Message>::default_instance()
    }
}

impl FileDescriptorProto {
    pub fn new() -> FileDescriptorProto {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string package = 2;

    pub fn package(&self) -> &str {
        match self.package.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_package(&mut self) {
        self.package = ::std::option::Option::None;
    }

    pub fn has_package(&self) -> bool {
        self.package.is_some()
    }

    // Param is passed by value, moved
    pub fn set_package(&mut self, v: ::std::string::String) {
        self.package = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_package(&mut self) -> &mut ::std::string::String {
        if self.package.is_none() {
            self.package = ::std::option::Option::Some(::std::string::String::new());
        }
        self.package.as_mut().unwrap()
    }

    // Take field
    pub fn take_package(&mut self) -> ::std::string::String {
        self.package.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string syntax = 12;

    pub fn syntax(&self) -> &str {
        match self.syntax.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_syntax(&mut self) {
        self.syntax = ::std::option::Option::None;
    }

    pub fn has_syntax(&self) -> bool {
        self.syntax.is_some()
    }

    // Param is passed by value, moved
    pub fn set_syntax(&mut self, v: ::std::string::String) {
        self.syntax = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_syntax(&mut self) -> &mut ::std::string::String {
        if self.syntax.is_none() {
            self.syntax = ::std::option::Option::Some(::std::string::String::new());
        }
        self.syntax.as_mut().unwrap()
    }

    // Take field
    pub fn take_syntax(&mut self) -> ::std::string::String {
        self.syntax.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(12);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &FileDescriptorProto| { &m.name },
            |m: &mut FileDescriptorProto| { &mut m.name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "package",
            |m: &FileDescriptorProto| { &m.package },
            |m: &mut FileDescriptorProto| { &mut m.package },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "dependency",
            |m: &FileDescriptorProto| { &m.dependency },
            |m: &mut FileDescriptorProto| { &mut m.dependency },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "public_dependency",
            |m: &FileDescriptorProto| { &m.public_dependency },
            |m: &mut FileDescriptorProto| { &mut m.public_dependency },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "weak_dependency",
            |m: &FileDescriptorProto| { &m.weak_dependency },
            |m: &mut FileDescriptorProto| { &mut m.weak_dependency },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "message_type",
            |m: &FileDescriptorProto| { &m.message_type },
            |m: &mut FileDescriptorProto| { &mut m.message_type },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "enum_type",
            |m: &FileDescriptorProto| { &m.enum_type },
            |m: &mut FileDescriptorProto| { &mut m.enum_type },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "service",
            |m: &FileDescriptorProto| { &m.service },
            |m: &mut FileDescriptorProto| { &mut m.service },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "extension",
            |m: &FileDescriptorProto| { &m.extension },
            |m: &mut FileDescriptorProto| { &mut m.extension },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, FileOptions>(
            "options",
            |m: &FileDescriptorProto| { &m.options },
            |m: &mut FileDescriptorProto| { &mut m.options },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, SourceCodeInfo>(
            "source_code_info",
            |m: &FileDescriptorProto| { &m.source_code_info },
            |m: &mut FileDescriptorProto| { &mut m.source_code_info },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "syntax",
            |m: &FileDescriptorProto| { &m.syntax },
            |m: &mut FileDescriptorProto| { &mut m.syntax },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<FileDescriptorProto>(
            "FileDescriptorProto",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for FileDescriptorProto {
    const NAME: &'static str = "FileDescriptorProto";

    fn is_initialized(&self) -> bool {
        for v in &self.message_type {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.enum_type {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.service {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.options {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.source_code_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.package = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.dependency.push(is.read_string()?);
                },
                82 => {
                    is.read_repeated_packed_int32_into(&mut self.public_dependency)?;
                },
                80 => {
                    self.public_dependency.push(is.read_int32()?);
                },
                90 => {
                    is.read_repeated_packed_int32_into(&mut self.weak_dependency)?;
                },
                88 => {
                    self.weak_dependency.push(is.read_int32()?);
                },
                34 => {
                    self.message_type.push(is.read_message()?);
                },
                42 => {
                    self.enum_type.push(is.read_message()?);
                },
                50 => {
                    self.service.push(is.read_message()?);
                },
                58 => {
                    self.extension.push(is.read_message()?);
                },
                66 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.options)?;
                },
                74 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.source_code_info)?;
                },
                98 => {
                    self.syntax = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        if let Some(v) = self.package.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        for value in &self.dependency {
            my_size += crate::rt::string_size(3, &value);
        };
        for value in &self.public_dependency {
            my_size += crate::rt::int32_size(10, *value);
        };
        for value in &self.weak_dependency {
            my_size += crate::rt::int32_size(11, *value);
        };
        for value in &self.message_type {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.enum_type {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.service {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.source_code_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.syntax.as_ref() {
            my_size += crate::rt::string_size(12, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.package.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.dependency {
            os.write_string(3, &v)?;
        };
        for v in &self.public_dependency {
            os.write_int32(10, *v)?;
        };
        for v in &self.weak_dependency {
            os.write_int32(11, *v)?;
        };
        for v in &self.message_type {
            crate::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.enum_type {
            crate::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        for v in &self.service {
            crate::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        for v in &self.extension {
            crate::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        if let Some(v) = self.options.as_ref() {
            crate::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.source_code_info.as_ref() {
            crate::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.syntax.as_ref() {
            os.write_string(12, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FileDescriptorProto {
        FileDescriptorProto::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.package = ::std::option::Option::None;
        self.dependency.clear();
        self.public_dependency.clear();
        self.weak_dependency.clear();
        self.message_type.clear();
        self.enum_type.clear();
        self.service.clear();
        self.extension.clear();
        self.options.clear();
        self.source_code_info.clear();
        self.syntax = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FileDescriptorProto {
        static instance: FileDescriptorProto = FileDescriptorProto {
            name: ::std::option::Option::None,
            package: ::std::option::Option::None,
            dependency: ::std::vec::Vec::new(),
            public_dependency: ::std::vec::Vec::new(),
            weak_dependency: ::std::vec::Vec::new(),
            message_type: ::std::vec::Vec::new(),
            enum_type: ::std::vec::Vec::new(),
            service: ::std::vec::Vec::new(),
            extension: ::std::vec::Vec::new(),
            options: crate::MessageField::none(),
            source_code_info: crate::MessageField::none(),
            syntax: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for FileDescriptorProto {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FileDescriptorProto").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FileDescriptorProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for FileDescriptorProto {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Describes a message type.
// @@protoc_insertion_point(message:google.protobuf.DescriptorProto)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DescriptorProto {
    // message fields
    // @@protoc_insertion_point(field:google.protobuf.DescriptorProto.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.protobuf.DescriptorProto.field)
    pub field: ::std::vec::Vec<FieldDescriptorProto>,
    // @@protoc_insertion_point(field:google.protobuf.DescriptorProto.extension)
    pub extension: ::std::vec::Vec<FieldDescriptorProto>,
    // @@protoc_insertion_point(field:google.protobuf.DescriptorProto.nested_type)
    pub nested_type: ::std::vec::Vec<DescriptorProto>,
    // @@protoc_insertion_point(field:google.protobuf.DescriptorProto.enum_type)
    pub enum_type: ::std::vec::Vec<EnumDescriptorProto>,
    // @@protoc_insertion_point(field:google.protobuf.DescriptorProto.extension_range)
    pub extension_range: ::std::vec::Vec<descriptor_proto::ExtensionRange>,
    // @@protoc_insertion_point(field:google.protobuf.DescriptorProto.oneof_decl)
    pub oneof_decl: ::std::vec::Vec<OneofDescriptorProto>,
    // @@protoc_insertion_point(field:google.protobuf.DescriptorProto.options)
    pub options: crate::MessageField<MessageOptions>,
    // @@protoc_insertion_point(field:google.protobuf.DescriptorProto.reserved_range)
    pub reserved_range: ::std::vec::Vec<descriptor_proto::ReservedRange>,
    ///  Reserved field names, which may not be used by fields in the same message.
    ///  A given name may only be reserved once.
    // @@protoc_insertion_point(field:google.protobuf.DescriptorProto.reserved_name)
    pub reserved_name: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.DescriptorProto.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DescriptorProto {
    fn default() -> &'a DescriptorProto {
        <DescriptorProto as crate::Message>::default_instance()
    }
}

impl DescriptorProto {
    pub fn new() -> DescriptorProto {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &DescriptorProto| { &m.name },
            |m: &mut DescriptorProto| { &mut m.name },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "field",
            |m: &DescriptorProto| { &m.field },
            |m: &mut DescriptorProto| { &mut m.field },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "extension",
            |m: &DescriptorProto| { &m.extension },
            |m: &mut DescriptorProto| { &mut m.extension },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "nested_type",
            |m: &DescriptorProto| { &m.nested_type },
            |m: &mut DescriptorProto| { &mut m.nested_type },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "enum_type",
            |m: &DescriptorProto| { &m.enum_type },
            |m: &mut DescriptorProto| { &mut m.enum_type },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "extension_range",
            |m: &DescriptorProto| { &m.extension_range },
            |m: &mut DescriptorProto| { &mut m.extension_range },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "oneof_decl",
            |m: &DescriptorProto| { &m.oneof_decl },
            |m: &mut DescriptorProto| { &mut m.oneof_decl },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, MessageOptions>(
            "options",
            |m: &DescriptorProto| { &m.options },
            |m: &mut DescriptorProto| { &mut m.options },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "reserved_range",
            |m: &DescriptorProto| { &m.reserved_range },
            |m: &mut DescriptorProto| { &mut m.reserved_range },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "reserved_name",
            |m: &DescriptorProto| { &m.reserved_name },
            |m: &mut DescriptorProto| { &mut m.reserved_name },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<DescriptorProto>(
            "DescriptorProto",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for DescriptorProto {
    const NAME: &'static str = "DescriptorProto";

    fn is_initialized(&self) -> bool {
        for v in &self.field {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.nested_type {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.enum_type {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension_range {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.oneof_decl {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.options {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.reserved_range {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.field.push(is.read_message()?);
                },
                50 => {
                    self.extension.push(is.read_message()?);
                },
                26 => {
                    self.nested_type.push(is.read_message()?);
                },
                34 => {
                    self.enum_type.push(is.read_message()?);
                },
                42 => {
                    self.extension_range.push(is.read_message()?);
                },
                66 => {
                    self.oneof_decl.push(is.read_message()?);
                },
                58 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.options)?;
                },
                74 => {
                    self.reserved_range.push(is.read_message()?);
                },
                82 => {
                    self.reserved_name.push(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        for value in &self.field {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.nested_type {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.enum_type {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.extension_range {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.oneof_decl {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.reserved_range {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.reserved_name {
            my_size += crate::rt::string_size(10, &value);
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.field {
            crate::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.extension {
            crate::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        for v in &self.nested_type {
            crate::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.enum_type {
            crate::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.extension_range {
            crate::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        for v in &self.oneof_decl {
            crate::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        if let Some(v) = self.options.as_ref() {
            crate::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        for v in &self.reserved_range {
            crate::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        for v in &self.reserved_name {
            os.write_string(10, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DescriptorProto {
        DescriptorProto::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.field.clear();
        self.extension.clear();
        self.nested_type.clear();
        self.enum_type.clear();
        self.extension_range.clear();
        self.oneof_decl.clear();
        self.options.clear();
        self.reserved_range.clear();
        self.reserved_name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DescriptorProto {
        static instance: DescriptorProto = DescriptorProto {
            name: ::std::option::Option::None,
            field: ::std::vec::Vec::new(),
            extension: ::std::vec::Vec::new(),
            nested_type: ::std::vec::Vec::new(),
            enum_type: ::std::vec::Vec::new(),
            extension_range: ::std::vec::Vec::new(),
            oneof_decl: ::std::vec::Vec::new(),
            options: crate::MessageField::none(),
            reserved_range: ::std::vec::Vec::new(),
            reserved_name: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for DescriptorProto {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DescriptorProto").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DescriptorProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for DescriptorProto {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `DescriptorProto`
pub mod descriptor_proto {
    // @@protoc_insertion_point(message:google.protobuf.DescriptorProto.ExtensionRange)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ExtensionRange {
        // message fields
        // @@protoc_insertion_point(field:google.protobuf.DescriptorProto.ExtensionRange.start)
        pub start: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:google.protobuf.DescriptorProto.ExtensionRange.end)
        pub end: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:google.protobuf.DescriptorProto.ExtensionRange.options)
        pub options: crate::MessageField<super::ExtensionRangeOptions>,
        // special fields
        // @@protoc_insertion_point(special_field:google.protobuf.DescriptorProto.ExtensionRange.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ExtensionRange {
        fn default() -> &'a ExtensionRange {
            <ExtensionRange as crate::Message>::default_instance()
        }
    }

    impl ExtensionRange {
        pub fn new() -> ExtensionRange {
            ::std::default::Default::default()
        }

        // optional int32 start = 1;

        pub fn start(&self) -> i32 {
            self.start.unwrap_or(0)
        }

        pub fn clear_start(&mut self) {
            self.start = ::std::option::Option::None;
        }

        pub fn has_start(&self) -> bool {
            self.start.is_some()
        }

        // Param is passed by value, moved
        pub fn set_start(&mut self, v: i32) {
            self.start = ::std::option::Option::Some(v);
        }

        // optional int32 end = 2;

        pub fn end(&self) -> i32 {
            self.end.unwrap_or(0)
        }

        pub fn clear_end(&mut self) {
            self.end = ::std::option::Option::None;
        }

        pub fn has_end(&self) -> bool {
            self.end.is_some()
        }

        // Param is passed by value, moved
        pub fn set_end(&mut self, v: i32) {
            self.end = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "start",
                |m: &ExtensionRange| { &m.start },
                |m: &mut ExtensionRange| { &mut m.start },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "end",
                |m: &ExtensionRange| { &m.end },
                |m: &mut ExtensionRange| { &mut m.end },
            ));
            fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, super::ExtensionRangeOptions>(
                "options",
                |m: &ExtensionRange| { &m.options },
                |m: &mut ExtensionRange| { &mut m.options },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<ExtensionRange>(
                "DescriptorProto.ExtensionRange",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for ExtensionRange {
        const NAME: &'static str = "ExtensionRange";

        fn is_initialized(&self) -> bool {
            for v in &self.options {
                if !v.is_initialized() {
                    return false;
                }
            };
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.start = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.end = ::std::option::Option::Some(is.read_int32()?);
                    },
                    26 => {
                        crate::rt::read_singular_message_into_field(is, &mut self.options)?;
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.start {
                my_size += crate::rt::int32_size(1, v);
            }
            if let Some(v) = self.end {
                my_size += crate::rt::int32_size(2, v);
            }
            if let Some(v) = self.options.as_ref() {
                let len = v.compute_size();
                my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.start {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.end {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.options.as_ref() {
                crate::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ExtensionRange {
            ExtensionRange::new()
        }

        fn clear(&mut self) {
            self.start = ::std::option::Option::None;
            self.end = ::std::option::Option::None;
            self.options.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ExtensionRange {
            static instance: ExtensionRange = ExtensionRange {
                start: ::std::option::Option::None,
                end: ::std::option::Option::None,
                options: crate::MessageField::none(),
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for ExtensionRange {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("DescriptorProto.ExtensionRange").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ExtensionRange {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for ExtensionRange {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }

    ///  Range of reserved tag numbers. Reserved tag numbers may not be used by
    ///  fields or extension ranges in the same message. Reserved ranges may
    ///  not overlap.
    // @@protoc_insertion_point(message:google.protobuf.DescriptorProto.ReservedRange)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ReservedRange {
        // message fields
        // @@protoc_insertion_point(field:google.protobuf.DescriptorProto.ReservedRange.start)
        pub start: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:google.protobuf.DescriptorProto.ReservedRange.end)
        pub end: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:google.protobuf.DescriptorProto.ReservedRange.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ReservedRange {
        fn default() -> &'a ReservedRange {
            <ReservedRange as crate::Message>::default_instance()
        }
    }

    impl ReservedRange {
        pub fn new() -> ReservedRange {
            ::std::default::Default::default()
        }

        // optional int32 start = 1;

        pub fn start(&self) -> i32 {
            self.start.unwrap_or(0)
        }

        pub fn clear_start(&mut self) {
            self.start = ::std::option::Option::None;
        }

        pub fn has_start(&self) -> bool {
            self.start.is_some()
        }

        // Param is passed by value, moved
        pub fn set_start(&mut self, v: i32) {
            self.start = ::std::option::Option::Some(v);
        }

        // optional int32 end = 2;

        pub fn end(&self) -> i32 {
            self.end.unwrap_or(0)
        }

        pub fn clear_end(&mut self) {
            self.end = ::std::option::Option::None;
        }

        pub fn has_end(&self) -> bool {
            self.end.is_some()
        }

        // Param is passed by value, moved
        pub fn set_end(&mut self, v: i32) {
            self.end = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "start",
                |m: &ReservedRange| { &m.start },
                |m: &mut ReservedRange| { &mut m.start },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "end",
                |m: &ReservedRange| { &m.end },
                |m: &mut ReservedRange| { &mut m.end },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<ReservedRange>(
                "DescriptorProto.ReservedRange",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for ReservedRange {
        const NAME: &'static str = "ReservedRange";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.start = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.end = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.start {
                my_size += crate::rt::int32_size(1, v);
            }
            if let Some(v) = self.end {
                my_size += crate::rt::int32_size(2, v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.start {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.end {
                os.write_int32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ReservedRange {
            ReservedRange::new()
        }

        fn clear(&mut self) {
            self.start = ::std::option::Option::None;
            self.end = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ReservedRange {
            static instance: ReservedRange = ReservedRange {
                start: ::std::option::Option::None,
                end: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for ReservedRange {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("DescriptorProto.ReservedRange").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ReservedRange {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for ReservedRange {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:google.protobuf.ExtensionRangeOptions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ExtensionRangeOptions {
    // message fields
    ///  The parser stores options it doesn't recognize here. See above.
    // @@protoc_insertion_point(field:google.protobuf.ExtensionRangeOptions.uninterpreted_option)
    pub uninterpreted_option: ::std::vec::Vec<UninterpretedOption>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.ExtensionRangeOptions.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ExtensionRangeOptions {
    fn default() -> &'a ExtensionRangeOptions {
        <ExtensionRangeOptions as crate::Message>::default_instance()
    }
}

impl ExtensionRangeOptions {
    pub fn new() -> ExtensionRangeOptions {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "uninterpreted_option",
            |m: &ExtensionRangeOptions| { &m.uninterpreted_option },
            |m: &mut ExtensionRangeOptions| { &mut m.uninterpreted_option },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<ExtensionRangeOptions>(
            "ExtensionRangeOptions",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for ExtensionRangeOptions {
    const NAME: &'static str = "ExtensionRangeOptions";

    fn is_initialized(&self) -> bool {
        for v in &self.uninterpreted_option {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                7994 => {
                    self.uninterpreted_option.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.uninterpreted_option {
            let len = value.compute_size();
            my_size += 2 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.uninterpreted_option {
            crate::rt::write_message_field_with_cached_size(999, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ExtensionRangeOptions {
        ExtensionRangeOptions::new()
    }

    fn clear(&mut self) {
        self.uninterpreted_option.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ExtensionRangeOptions {
        static instance: ExtensionRangeOptions = ExtensionRangeOptions {
            uninterpreted_option: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for ExtensionRangeOptions {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ExtensionRangeOptions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ExtensionRangeOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for ExtensionRangeOptions {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Describes a field within a message.
// @@protoc_insertion_point(message:google.protobuf.FieldDescriptorProto)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FieldDescriptorProto {
    // message fields
    // @@protoc_insertion_point(field:google.protobuf.FieldDescriptorProto.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.protobuf.FieldDescriptorProto.number)
    pub number: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:google.protobuf.FieldDescriptorProto.label)
    pub label: ::std::option::Option<crate::EnumOrUnknown<field_descriptor_proto::Label>>,
    ///  If type_name is set, this need not be set.  If both this and type_name
    ///  are set, this must be one of TYPE_ENUM, TYPE_MESSAGE or TYPE_GROUP.
    // @@protoc_insertion_point(field:google.protobuf.FieldDescriptorProto.type)
    pub type_: ::std::option::Option<crate::EnumOrUnknown<field_descriptor_proto::Type>>,
    ///  For message and enum types, this is the name of the type.  If the name
    ///  starts with a '.', it is fully-qualified.  Otherwise, C++-like scoping
    ///  rules are used to find the type (i.e. first the nested types within this
    ///  message are searched, then within the parent, on up to the root
    ///  namespace).
    // @@protoc_insertion_point(field:google.protobuf.FieldDescriptorProto.type_name)
    pub type_name: ::std::option::Option<::std::string::String>,
    ///  For extensions, this is the name of the type being extended.  It is
    ///  resolved in the same manner as type_name.
    // @@protoc_insertion_point(field:google.protobuf.FieldDescriptorProto.extendee)
    pub extendee: ::std::option::Option<::std::string::String>,
    ///  For numeric types, contains the original text representation of the value.
    ///  For booleans, "true" or "false".
    ///  For strings, contains the default text contents (not escaped in any way).
    ///  For bytes, contains the C escaped value.  All bytes >= 128 are escaped.
    ///  TODO(kenton):  Base-64 encode?
    // @@protoc_insertion_point(field:google.protobuf.FieldDescriptorProto.default_value)
    pub default_value: ::std::option::Option<::std::string::String>,
    ///  If set, gives the index of a oneof in the containing type's oneof_decl
    ///  list.  This field is a member of that oneof.
    // @@protoc_insertion_point(field:google.protobuf.FieldDescriptorProto.oneof_index)
    pub oneof_index: ::std::option::Option<i32>,
    ///  JSON name of this field. The value is set by protocol compiler. If the
    ///  user has set a "json_name" option on this field, that option's value
    ///  will be used. Otherwise, it's deduced from the field's name by converting
    ///  it to camelCase.
    // @@protoc_insertion_point(field:google.protobuf.FieldDescriptorProto.json_name)
    pub json_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.protobuf.FieldDescriptorProto.options)
    pub options: crate::MessageField<FieldOptions>,
    ///  If true, this is a proto3 "optional". When a proto3 field is optional, it
    ///  tracks presence regardless of field type.
    ///
    ///  When proto3_optional is true, this field must be belong to a oneof to
    ///  signal to old proto3 clients that presence is tracked for this field. This
    ///  oneof is known as a "synthetic" oneof, and this field must be its sole
    ///  member (each proto3 optional field gets its own synthetic oneof). Synthetic
    ///  oneofs exist in the descriptor only, and do not generate any API. Synthetic
    ///  oneofs must be ordered after all "real" oneofs.
    ///
    ///  For message fields, proto3_optional doesn't create any semantic change,
    ///  since non-repeated message fields always track presence. However it still
    ///  indicates the semantic detail of whether the user wrote "optional" or not.
    ///  This can be useful for round-tripping the .proto file. For consistency we
    ///  give message fields a synthetic oneof also, even though it is not required
    ///  to track presence. This is especially important because the parser can't
    ///  tell if a field is a message or an enum, so it must always create a
    ///  synthetic oneof.
    ///
    ///  Proto2 optional fields do not set this flag, because they already indicate
    ///  optional with `LABEL_OPTIONAL`.
    // @@protoc_insertion_point(field:google.protobuf.FieldDescriptorProto.proto3_optional)
    pub proto3_optional: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.FieldDescriptorProto.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FieldDescriptorProto {
    fn default() -> &'a FieldDescriptorProto {
        <FieldDescriptorProto as crate::Message>::default_instance()
    }
}

impl FieldDescriptorProto {
    pub fn new() -> FieldDescriptorProto {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 number = 3;

    pub fn number(&self) -> i32 {
        self.number.unwrap_or(0)
    }

    pub fn clear_number(&mut self) {
        self.number = ::std::option::Option::None;
    }

    pub fn has_number(&self) -> bool {
        self.number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_number(&mut self, v: i32) {
        self.number = ::std::option::Option::Some(v);
    }

    // optional .google.protobuf.FieldDescriptorProto.Label label = 4;

    pub fn label(&self) -> field_descriptor_proto::Label {
        match self.label {
            Some(e) => e.enum_value_or(field_descriptor_proto::Label::LABEL_OPTIONAL),
            None => field_descriptor_proto::Label::LABEL_OPTIONAL,
        }
    }

    pub fn clear_label(&mut self) {
        self.label = ::std::option::Option::None;
    }

    pub fn has_label(&self) -> bool {
        self.label.is_some()
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: field_descriptor_proto::Label) {
        self.label = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional .google.protobuf.FieldDescriptorProto.Type type = 5;

    pub fn type_(&self) -> field_descriptor_proto::Type {
        match self.type_ {
            Some(e) => e.enum_value_or(field_descriptor_proto::Type::TYPE_DOUBLE),
            None => field_descriptor_proto::Type::TYPE_DOUBLE,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: field_descriptor_proto::Type) {
        self.type_ = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional string type_name = 6;

    pub fn type_name(&self) -> &str {
        match self.type_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_type_name(&mut self) {
        self.type_name = ::std::option::Option::None;
    }

    pub fn has_type_name(&self) -> bool {
        self.type_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type_name(&mut self, v: ::std::string::String) {
        self.type_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type_name(&mut self) -> &mut ::std::string::String {
        if self.type_name.is_none() {
            self.type_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.type_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_type_name(&mut self) -> ::std::string::String {
        self.type_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string extendee = 2;

    pub fn extendee(&self) -> &str {
        match self.extendee.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_extendee(&mut self) {
        self.extendee = ::std::option::Option::None;
    }

    pub fn has_extendee(&self) -> bool {
        self.extendee.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extendee(&mut self, v: ::std::string::String) {
        self.extendee = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extendee(&mut self) -> &mut ::std::string::String {
        if self.extendee.is_none() {
            self.extendee = ::std::option::Option::Some(::std::string::String::new());
        }
        self.extendee.as_mut().unwrap()
    }

    // Take field
    pub fn take_extendee(&mut self) -> ::std::string::String {
        self.extendee.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string default_value = 7;

    pub fn default_value(&self) -> &str {
        match self.default_value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_default_value(&mut self) {
        self.default_value = ::std::option::Option::None;
    }

    pub fn has_default_value(&self) -> bool {
        self.default_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_value(&mut self, v: ::std::string::String) {
        self.default_value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_default_value(&mut self) -> &mut ::std::string::String {
        if self.default_value.is_none() {
            self.default_value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.default_value.as_mut().unwrap()
    }

    // Take field
    pub fn take_default_value(&mut self) -> ::std::string::String {
        self.default_value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 oneof_index = 9;

    pub fn oneof_index(&self) -> i32 {
        self.oneof_index.unwrap_or(0)
    }

    pub fn clear_oneof_index(&mut self) {
        self.oneof_index = ::std::option::Option::None;
    }

    pub fn has_oneof_index(&self) -> bool {
        self.oneof_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_oneof_index(&mut self, v: i32) {
        self.oneof_index = ::std::option::Option::Some(v);
    }

    // optional string json_name = 10;

    pub fn json_name(&self) -> &str {
        match self.json_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_json_name(&mut self) {
        self.json_name = ::std::option::Option::None;
    }

    pub fn has_json_name(&self) -> bool {
        self.json_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_json_name(&mut self, v: ::std::string::String) {
        self.json_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_json_name(&mut self) -> &mut ::std::string::String {
        if self.json_name.is_none() {
            self.json_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.json_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_json_name(&mut self) -> ::std::string::String {
        self.json_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool proto3_optional = 17;

    pub fn proto3_optional(&self) -> bool {
        self.proto3_optional.unwrap_or(false)
    }

    pub fn clear_proto3_optional(&mut self) {
        self.proto3_optional = ::std::option::Option::None;
    }

    pub fn has_proto3_optional(&self) -> bool {
        self.proto3_optional.is_some()
    }

    // Param is passed by value, moved
    pub fn set_proto3_optional(&mut self, v: bool) {
        self.proto3_optional = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &FieldDescriptorProto| { &m.name },
            |m: &mut FieldDescriptorProto| { &mut m.name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "number",
            |m: &FieldDescriptorProto| { &m.number },
            |m: &mut FieldDescriptorProto| { &mut m.number },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "label",
            |m: &FieldDescriptorProto| { &m.label },
            |m: &mut FieldDescriptorProto| { &mut m.label },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &FieldDescriptorProto| { &m.type_ },
            |m: &mut FieldDescriptorProto| { &mut m.type_ },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "type_name",
            |m: &FieldDescriptorProto| { &m.type_name },
            |m: &mut FieldDescriptorProto| { &mut m.type_name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "extendee",
            |m: &FieldDescriptorProto| { &m.extendee },
            |m: &mut FieldDescriptorProto| { &mut m.extendee },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "default_value",
            |m: &FieldDescriptorProto| { &m.default_value },
            |m: &mut FieldDescriptorProto| { &mut m.default_value },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "oneof_index",
            |m: &FieldDescriptorProto| { &m.oneof_index },
            |m: &mut FieldDescriptorProto| { &mut m.oneof_index },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "json_name",
            |m: &FieldDescriptorProto| { &m.json_name },
            |m: &mut FieldDescriptorProto| { &mut m.json_name },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, FieldOptions>(
            "options",
            |m: &FieldDescriptorProto| { &m.options },
            |m: &mut FieldDescriptorProto| { &mut m.options },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "proto3_optional",
            |m: &FieldDescriptorProto| { &m.proto3_optional },
            |m: &mut FieldDescriptorProto| { &mut m.proto3_optional },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<FieldDescriptorProto>(
            "FieldDescriptorProto",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for FieldDescriptorProto {
    const NAME: &'static str = "FieldDescriptorProto";

    fn is_initialized(&self) -> bool {
        for v in &self.options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.number = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.label = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                40 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                50 => {
                    self.type_name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.extendee = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.default_value = ::std::option::Option::Some(is.read_string()?);
                },
                72 => {
                    self.oneof_index = ::std::option::Option::Some(is.read_int32()?);
                },
                82 => {
                    self.json_name = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.options)?;
                },
                136 => {
                    self.proto3_optional = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        if let Some(v) = self.number {
            my_size += crate::rt::int32_size(3, v);
        }
        if let Some(v) = self.label {
            my_size += crate::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.type_ {
            my_size += crate::rt::int32_size(5, v.value());
        }
        if let Some(v) = self.type_name.as_ref() {
            my_size += crate::rt::string_size(6, &v);
        }
        if let Some(v) = self.extendee.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        if let Some(v) = self.default_value.as_ref() {
            my_size += crate::rt::string_size(7, &v);
        }
        if let Some(v) = self.oneof_index {
            my_size += crate::rt::int32_size(9, v);
        }
        if let Some(v) = self.json_name.as_ref() {
            my_size += crate::rt::string_size(10, &v);
        }
        if let Some(v) = self.options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.proto3_optional {
            my_size += 2 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.number {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.label {
            os.write_enum(4, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.type_ {
            os.write_enum(5, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.type_name.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.extendee.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.default_value.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.oneof_index {
            os.write_int32(9, v)?;
        }
        if let Some(v) = self.json_name.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.options.as_ref() {
            crate::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.proto3_optional {
            os.write_bool(17, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FieldDescriptorProto {
        FieldDescriptorProto::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.number = ::std::option::Option::None;
        self.label = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.type_name = ::std::option::Option::None;
        self.extendee = ::std::option::Option::None;
        self.default_value = ::std::option::Option::None;
        self.oneof_index = ::std::option::Option::None;
        self.json_name = ::std::option::Option::None;
        self.options.clear();
        self.proto3_optional = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FieldDescriptorProto {
        static instance: FieldDescriptorProto = FieldDescriptorProto {
            name: ::std::option::Option::None,
            number: ::std::option::Option::None,
            label: ::std::option::Option::None,
            type_: ::std::option::Option::None,
            type_name: ::std::option::Option::None,
            extendee: ::std::option::Option::None,
            default_value: ::std::option::Option::None,
            oneof_index: ::std::option::Option::None,
            json_name: ::std::option::Option::None,
            options: crate::MessageField::none(),
            proto3_optional: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for FieldDescriptorProto {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FieldDescriptorProto").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FieldDescriptorProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for FieldDescriptorProto {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `FieldDescriptorProto`
pub mod field_descriptor_proto {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:google.protobuf.FieldDescriptorProto.Type)
    pub enum Type {
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Type.TYPE_DOUBLE)
        TYPE_DOUBLE = 1,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Type.TYPE_FLOAT)
        TYPE_FLOAT = 2,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Type.TYPE_INT64)
        TYPE_INT64 = 3,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Type.TYPE_UINT64)
        TYPE_UINT64 = 4,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Type.TYPE_INT32)
        TYPE_INT32 = 5,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Type.TYPE_FIXED64)
        TYPE_FIXED64 = 6,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Type.TYPE_FIXED32)
        TYPE_FIXED32 = 7,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Type.TYPE_BOOL)
        TYPE_BOOL = 8,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Type.TYPE_STRING)
        TYPE_STRING = 9,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Type.TYPE_GROUP)
        TYPE_GROUP = 10,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Type.TYPE_MESSAGE)
        TYPE_MESSAGE = 11,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Type.TYPE_BYTES)
        TYPE_BYTES = 12,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Type.TYPE_UINT32)
        TYPE_UINT32 = 13,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Type.TYPE_ENUM)
        TYPE_ENUM = 14,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Type.TYPE_SFIXED32)
        TYPE_SFIXED32 = 15,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Type.TYPE_SFIXED64)
        TYPE_SFIXED64 = 16,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Type.TYPE_SINT32)
        TYPE_SINT32 = 17,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Type.TYPE_SINT64)
        TYPE_SINT64 = 18,
    }

    impl crate::Enum for Type {
        const NAME: &'static str = "Type";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Type> {
            match value {
                1 => ::std::option::Option::Some(Type::TYPE_DOUBLE),
                2 => ::std::option::Option::Some(Type::TYPE_FLOAT),
                3 => ::std::option::Option::Some(Type::TYPE_INT64),
                4 => ::std::option::Option::Some(Type::TYPE_UINT64),
                5 => ::std::option::Option::Some(Type::TYPE_INT32),
                6 => ::std::option::Option::Some(Type::TYPE_FIXED64),
                7 => ::std::option::Option::Some(Type::TYPE_FIXED32),
                8 => ::std::option::Option::Some(Type::TYPE_BOOL),
                9 => ::std::option::Option::Some(Type::TYPE_STRING),
                10 => ::std::option::Option::Some(Type::TYPE_GROUP),
                11 => ::std::option::Option::Some(Type::TYPE_MESSAGE),
                12 => ::std::option::Option::Some(Type::TYPE_BYTES),
                13 => ::std::option::Option::Some(Type::TYPE_UINT32),
                14 => ::std::option::Option::Some(Type::TYPE_ENUM),
                15 => ::std::option::Option::Some(Type::TYPE_SFIXED32),
                16 => ::std::option::Option::Some(Type::TYPE_SFIXED64),
                17 => ::std::option::Option::Some(Type::TYPE_SINT32),
                18 => ::std::option::Option::Some(Type::TYPE_SINT64),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Type> {
            match str {
                "TYPE_DOUBLE" => ::std::option::Option::Some(Type::TYPE_DOUBLE),
                "TYPE_FLOAT" => ::std::option::Option::Some(Type::TYPE_FLOAT),
                "TYPE_INT64" => ::std::option::Option::Some(Type::TYPE_INT64),
                "TYPE_UINT64" => ::std::option::Option::Some(Type::TYPE_UINT64),
                "TYPE_INT32" => ::std::option::Option::Some(Type::TYPE_INT32),
                "TYPE_FIXED64" => ::std::option::Option::Some(Type::TYPE_FIXED64),
                "TYPE_FIXED32" => ::std::option::Option::Some(Type::TYPE_FIXED32),
                "TYPE_BOOL" => ::std::option::Option::Some(Type::TYPE_BOOL),
                "TYPE_STRING" => ::std::option::Option::Some(Type::TYPE_STRING),
                "TYPE_GROUP" => ::std::option::Option::Some(Type::TYPE_GROUP),
                "TYPE_MESSAGE" => ::std::option::Option::Some(Type::TYPE_MESSAGE),
                "TYPE_BYTES" => ::std::option::Option::Some(Type::TYPE_BYTES),
                "TYPE_UINT32" => ::std::option::Option::Some(Type::TYPE_UINT32),
                "TYPE_ENUM" => ::std::option::Option::Some(Type::TYPE_ENUM),
                "TYPE_SFIXED32" => ::std::option::Option::Some(Type::TYPE_SFIXED32),
                "TYPE_SFIXED64" => ::std::option::Option::Some(Type::TYPE_SFIXED64),
                "TYPE_SINT32" => ::std::option::Option::Some(Type::TYPE_SINT32),
                "TYPE_SINT64" => ::std::option::Option::Some(Type::TYPE_SINT64),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Type] = &[
            Type::TYPE_DOUBLE,
            Type::TYPE_FLOAT,
            Type::TYPE_INT64,
            Type::TYPE_UINT64,
            Type::TYPE_INT32,
            Type::TYPE_FIXED64,
            Type::TYPE_FIXED32,
            Type::TYPE_BOOL,
            Type::TYPE_STRING,
            Type::TYPE_GROUP,
            Type::TYPE_MESSAGE,
            Type::TYPE_BYTES,
            Type::TYPE_UINT32,
            Type::TYPE_ENUM,
            Type::TYPE_SFIXED32,
            Type::TYPE_SFIXED64,
            Type::TYPE_SINT32,
            Type::TYPE_SINT64,
        ];
    }

    impl crate::EnumFull for Type {
        fn enum_descriptor() -> crate::reflect::EnumDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("FieldDescriptorProto.Type").unwrap()).clone()
        }

        fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
            let index = match self {
                Type::TYPE_DOUBLE => 0,
                Type::TYPE_FLOAT => 1,
                Type::TYPE_INT64 => 2,
                Type::TYPE_UINT64 => 3,
                Type::TYPE_INT32 => 4,
                Type::TYPE_FIXED64 => 5,
                Type::TYPE_FIXED32 => 6,
                Type::TYPE_BOOL => 7,
                Type::TYPE_STRING => 8,
                Type::TYPE_GROUP => 9,
                Type::TYPE_MESSAGE => 10,
                Type::TYPE_BYTES => 11,
                Type::TYPE_UINT32 => 12,
                Type::TYPE_ENUM => 13,
                Type::TYPE_SFIXED32 => 14,
                Type::TYPE_SFIXED64 => 15,
                Type::TYPE_SINT32 => 16,
                Type::TYPE_SINT64 => 17,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for Type {
        fn default() -> Self {
            Type::TYPE_DOUBLE
        }
    }

    impl Type {
        pub(in super) fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
            crate::reflect::GeneratedEnumDescriptorData::new::<Type>("FieldDescriptorProto.Type")
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:google.protobuf.FieldDescriptorProto.Label)
    pub enum Label {
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Label.LABEL_OPTIONAL)
        LABEL_OPTIONAL = 1,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Label.LABEL_REQUIRED)
        LABEL_REQUIRED = 2,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Label.LABEL_REPEATED)
        LABEL_REPEATED = 3,
    }

    impl crate::Enum for Label {
        const NAME: &'static str = "Label";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Label> {
            match value {
                1 => ::std::option::Option::Some(Label::LABEL_OPTIONAL),
                2 => ::std::option::Option::Some(Label::LABEL_REQUIRED),
                3 => ::std::option::Option::Some(Label::LABEL_REPEATED),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Label> {
            match str {
                "LABEL_OPTIONAL" => ::std::option::Option::Some(Label::LABEL_OPTIONAL),
                "LABEL_REQUIRED" => ::std::option::Option::Some(Label::LABEL_REQUIRED),
                "LABEL_REPEATED" => ::std::option::Option::Some(Label::LABEL_REPEATED),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Label] = &[
            Label::LABEL_OPTIONAL,
            Label::LABEL_REQUIRED,
            Label::LABEL_REPEATED,
        ];
    }

    impl crate::EnumFull for Label {
        fn enum_descriptor() -> crate::reflect::EnumDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("FieldDescriptorProto.Label").unwrap()).clone()
        }

        fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
            let index = match self {
                Label::LABEL_OPTIONAL => 0,
                Label::LABEL_REQUIRED => 1,
                Label::LABEL_REPEATED => 2,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for Label {
        fn default() -> Self {
            Label::LABEL_OPTIONAL
        }
    }

    impl Label {
        pub(in super) fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
            crate::reflect::GeneratedEnumDescriptorData::new::<Label>("FieldDescriptorProto.Label")
        }
    }
}

///  Describes a oneof.
// @@protoc_insertion_point(message:google.protobuf.OneofDescriptorProto)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct OneofDescriptorProto {
    // message fields
    // @@protoc_insertion_point(field:google.protobuf.OneofDescriptorProto.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.protobuf.OneofDescriptorProto.options)
    pub options: crate::MessageField<OneofOptions>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.OneofDescriptorProto.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a OneofDescriptorProto {
    fn default() -> &'a OneofDescriptorProto {
        <OneofDescriptorProto as crate::Message>::default_instance()
    }
}

impl OneofDescriptorProto {
    pub fn new() -> OneofDescriptorProto {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &OneofDescriptorProto| { &m.name },
            |m: &mut OneofDescriptorProto| { &mut m.name },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, OneofOptions>(
            "options",
            |m: &OneofDescriptorProto| { &m.options },
            |m: &mut OneofDescriptorProto| { &mut m.options },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<OneofDescriptorProto>(
            "OneofDescriptorProto",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for OneofDescriptorProto {
    const NAME: &'static str = "OneofDescriptorProto";

    fn is_initialized(&self) -> bool {
        for v in &self.options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.options)?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        if let Some(v) = self.options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.options.as_ref() {
            crate::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> OneofDescriptorProto {
        OneofDescriptorProto::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.options.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static OneofDescriptorProto {
        static instance: OneofDescriptorProto = OneofDescriptorProto {
            name: ::std::option::Option::None,
            options: crate::MessageField::none(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for OneofDescriptorProto {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("OneofDescriptorProto").unwrap()).clone()
    }
}

impl ::std::fmt::Display for OneofDescriptorProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for OneofDescriptorProto {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Describes an enum type.
// @@protoc_insertion_point(message:google.protobuf.EnumDescriptorProto)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct EnumDescriptorProto {
    // message fields
    // @@protoc_insertion_point(field:google.protobuf.EnumDescriptorProto.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.protobuf.EnumDescriptorProto.value)
    pub value: ::std::vec::Vec<EnumValueDescriptorProto>,
    // @@protoc_insertion_point(field:google.protobuf.EnumDescriptorProto.options)
    pub options: crate::MessageField<EnumOptions>,
    ///  Range of reserved numeric values. Reserved numeric values may not be used
    ///  by enum values in the same enum declaration. Reserved ranges may not
    ///  overlap.
    // @@protoc_insertion_point(field:google.protobuf.EnumDescriptorProto.reserved_range)
    pub reserved_range: ::std::vec::Vec<enum_descriptor_proto::EnumReservedRange>,
    ///  Reserved enum value names, which may not be reused. A given name may only
    ///  be reserved once.
    // @@protoc_insertion_point(field:google.protobuf.EnumDescriptorProto.reserved_name)
    pub reserved_name: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.EnumDescriptorProto.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EnumDescriptorProto {
    fn default() -> &'a EnumDescriptorProto {
        <EnumDescriptorProto as crate::Message>::default_instance()
    }
}

impl EnumDescriptorProto {
    pub fn new() -> EnumDescriptorProto {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &EnumDescriptorProto| { &m.name },
            |m: &mut EnumDescriptorProto| { &mut m.name },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "value",
            |m: &EnumDescriptorProto| { &m.value },
            |m: &mut EnumDescriptorProto| { &mut m.value },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, EnumOptions>(
            "options",
            |m: &EnumDescriptorProto| { &m.options },
            |m: &mut EnumDescriptorProto| { &mut m.options },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "reserved_range",
            |m: &EnumDescriptorProto| { &m.reserved_range },
            |m: &mut EnumDescriptorProto| { &mut m.reserved_range },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "reserved_name",
            |m: &EnumDescriptorProto| { &m.reserved_name },
            |m: &mut EnumDescriptorProto| { &mut m.reserved_name },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<EnumDescriptorProto>(
            "EnumDescriptorProto",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for EnumDescriptorProto {
    const NAME: &'static str = "EnumDescriptorProto";

    fn is_initialized(&self) -> bool {
        for v in &self.value {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.options {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.reserved_range {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.value.push(is.read_message()?);
                },
                26 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.options)?;
                },
                34 => {
                    self.reserved_range.push(is.read_message()?);
                },
                42 => {
                    self.reserved_name.push(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        for value in &self.value {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.reserved_range {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.reserved_name {
            my_size += crate::rt::string_size(5, &value);
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.value {
            crate::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.options.as_ref() {
            crate::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        for v in &self.reserved_range {
            crate::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.reserved_name {
            os.write_string(5, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EnumDescriptorProto {
        EnumDescriptorProto::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.value.clear();
        self.options.clear();
        self.reserved_range.clear();
        self.reserved_name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EnumDescriptorProto {
        static instance: EnumDescriptorProto = EnumDescriptorProto {
            name: ::std::option::Option::None,
            value: ::std::vec::Vec::new(),
            options: crate::MessageField::none(),
            reserved_range: ::std::vec::Vec::new(),
            reserved_name: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for EnumDescriptorProto {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EnumDescriptorProto").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EnumDescriptorProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for EnumDescriptorProto {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `EnumDescriptorProto`
pub mod enum_descriptor_proto {
    ///  Range of reserved numeric values. Reserved values may not be used by
    ///  entries in the same enum. Reserved ranges may not overlap.
    ///
    ///  Note that this is distinct from DescriptorProto.ReservedRange in that it
    ///  is inclusive such that it can appropriately represent the entire int32
    ///  domain.
    // @@protoc_insertion_point(message:google.protobuf.EnumDescriptorProto.EnumReservedRange)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct EnumReservedRange {
        // message fields
        // @@protoc_insertion_point(field:google.protobuf.EnumDescriptorProto.EnumReservedRange.start)
        pub start: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:google.protobuf.EnumDescriptorProto.EnumReservedRange.end)
        pub end: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:google.protobuf.EnumDescriptorProto.EnumReservedRange.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a EnumReservedRange {
        fn default() -> &'a EnumReservedRange {
            <EnumReservedRange as crate::Message>::default_instance()
        }
    }

    impl EnumReservedRange {
        pub fn new() -> EnumReservedRange {
            ::std::default::Default::default()
        }

        // optional int32 start = 1;

        pub fn start(&self) -> i32 {
            self.start.unwrap_or(0)
        }

        pub fn clear_start(&mut self) {
            self.start = ::std::option::Option::None;
        }

        pub fn has_start(&self) -> bool {
            self.start.is_some()
        }

        // Param is passed by value, moved
        pub fn set_start(&mut self, v: i32) {
            self.start = ::std::option::Option::Some(v);
        }

        // optional int32 end = 2;

        pub fn end(&self) -> i32 {
            self.end.unwrap_or(0)
        }

        pub fn clear_end(&mut self) {
            self.end = ::std::option::Option::None;
        }

        pub fn has_end(&self) -> bool {
            self.end.is_some()
        }

        // Param is passed by value, moved
        pub fn set_end(&mut self, v: i32) {
            self.end = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "start",
                |m: &EnumReservedRange| { &m.start },
                |m: &mut EnumReservedRange| { &mut m.start },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "end",
                |m: &EnumReservedRange| { &m.end },
                |m: &mut EnumReservedRange| { &mut m.end },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<EnumReservedRange>(
                "EnumDescriptorProto.EnumReservedRange",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for EnumReservedRange {
        const NAME: &'static str = "EnumReservedRange";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.start = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.end = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.start {
                my_size += crate::rt::int32_size(1, v);
            }
            if let Some(v) = self.end {
                my_size += crate::rt::int32_size(2, v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.start {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.end {
                os.write_int32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> EnumReservedRange {
            EnumReservedRange::new()
        }

        fn clear(&mut self) {
            self.start = ::std::option::Option::None;
            self.end = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static EnumReservedRange {
            static instance: EnumReservedRange = EnumReservedRange {
                start: ::std::option::Option::None,
                end: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for EnumReservedRange {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("EnumDescriptorProto.EnumReservedRange").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for EnumReservedRange {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for EnumReservedRange {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

///  Describes a value within an enum.
// @@protoc_insertion_point(message:google.protobuf.EnumValueDescriptorProto)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct EnumValueDescriptorProto {
    // message fields
    // @@protoc_insertion_point(field:google.protobuf.EnumValueDescriptorProto.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.protobuf.EnumValueDescriptorProto.number)
    pub number: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:google.protobuf.EnumValueDescriptorProto.options)
    pub options: crate::MessageField<EnumValueOptions>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.EnumValueDescriptorProto.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EnumValueDescriptorProto {
    fn default() -> &'a EnumValueDescriptorProto {
        <EnumValueDescriptorProto as crate::Message>::default_instance()
    }
}

impl EnumValueDescriptorProto {
    pub fn new() -> EnumValueDescriptorProto {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 number = 2;

    pub fn number(&self) -> i32 {
        self.number.unwrap_or(0)
    }

    pub fn clear_number(&mut self) {
        self.number = ::std::option::Option::None;
    }

    pub fn has_number(&self) -> bool {
        self.number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_number(&mut self, v: i32) {
        self.number = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &EnumValueDescriptorProto| { &m.name },
            |m: &mut EnumValueDescriptorProto| { &mut m.name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "number",
            |m: &EnumValueDescriptorProto| { &m.number },
            |m: &mut EnumValueDescriptorProto| { &mut m.number },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, EnumValueOptions>(
            "options",
            |m: &EnumValueDescriptorProto| { &m.options },
            |m: &mut EnumValueDescriptorProto| { &mut m.options },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<EnumValueDescriptorProto>(
            "EnumValueDescriptorProto",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for EnumValueDescriptorProto {
    const NAME: &'static str = "EnumValueDescriptorProto";

    fn is_initialized(&self) -> bool {
        for v in &self.options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.number = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.options)?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        if let Some(v) = self.number {
            my_size += crate::rt::int32_size(2, v);
        }
        if let Some(v) = self.options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.number {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.options.as_ref() {
            crate::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EnumValueDescriptorProto {
        EnumValueDescriptorProto::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.number = ::std::option::Option::None;
        self.options.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EnumValueDescriptorProto {
        static instance: EnumValueDescriptorProto = EnumValueDescriptorProto {
            name: ::std::option::Option::None,
            number: ::std::option::Option::None,
            options: crate::MessageField::none(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for EnumValueDescriptorProto {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EnumValueDescriptorProto").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EnumValueDescriptorProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for EnumValueDescriptorProto {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Describes a service.
// @@protoc_insertion_point(message:google.protobuf.ServiceDescriptorProto)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ServiceDescriptorProto {
    // message fields
    // @@protoc_insertion_point(field:google.protobuf.ServiceDescriptorProto.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.protobuf.ServiceDescriptorProto.method)
    pub method: ::std::vec::Vec<MethodDescriptorProto>,
    // @@protoc_insertion_point(field:google.protobuf.ServiceDescriptorProto.options)
    pub options: crate::MessageField<ServiceOptions>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.ServiceDescriptorProto.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ServiceDescriptorProto {
    fn default() -> &'a ServiceDescriptorProto {
        <ServiceDescriptorProto as crate::Message>::default_instance()
    }
}

impl ServiceDescriptorProto {
    pub fn new() -> ServiceDescriptorProto {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &ServiceDescriptorProto| { &m.name },
            |m: &mut ServiceDescriptorProto| { &mut m.name },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "method",
            |m: &ServiceDescriptorProto| { &m.method },
            |m: &mut ServiceDescriptorProto| { &mut m.method },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, ServiceOptions>(
            "options",
            |m: &ServiceDescriptorProto| { &m.options },
            |m: &mut ServiceDescriptorProto| { &mut m.options },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<ServiceDescriptorProto>(
            "ServiceDescriptorProto",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for ServiceDescriptorProto {
    const NAME: &'static str = "ServiceDescriptorProto";

    fn is_initialized(&self) -> bool {
        for v in &self.method {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.method.push(is.read_message()?);
                },
                26 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.options)?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        for value in &self.method {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.method {
            crate::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.options.as_ref() {
            crate::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ServiceDescriptorProto {
        ServiceDescriptorProto::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.method.clear();
        self.options.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ServiceDescriptorProto {
        static instance: ServiceDescriptorProto = ServiceDescriptorProto {
            name: ::std::option::Option::None,
            method: ::std::vec::Vec::new(),
            options: crate::MessageField::none(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for ServiceDescriptorProto {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ServiceDescriptorProto").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ServiceDescriptorProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for ServiceDescriptorProto {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Describes a method of a service.
// @@protoc_insertion_point(message:google.protobuf.MethodDescriptorProto)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MethodDescriptorProto {
    // message fields
    // @@protoc_insertion_point(field:google.protobuf.MethodDescriptorProto.name)
    pub name: ::std::option::Option<::std::string::String>,
    ///  Input and output type names.  These are resolved in the same way as
    ///  FieldDescriptorProto.type_name, but must refer to a message type.
    // @@protoc_insertion_point(field:google.protobuf.MethodDescriptorProto.input_type)
    pub input_type: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.protobuf.MethodDescriptorProto.output_type)
    pub output_type: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.protobuf.MethodDescriptorProto.options)
    pub options: crate::MessageField<MethodOptions>,
    ///  Identifies if client streams multiple client messages
    // @@protoc_insertion_point(field:google.protobuf.MethodDescriptorProto.client_streaming)
    pub client_streaming: ::std::option::Option<bool>,
    ///  Identifies if server streams multiple server messages
    // @@protoc_insertion_point(field:google.protobuf.MethodDescriptorProto.server_streaming)
    pub server_streaming: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.MethodDescriptorProto.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MethodDescriptorProto {
    fn default() -> &'a MethodDescriptorProto {
        <MethodDescriptorProto as crate::Message>::default_instance()
    }
}

impl MethodDescriptorProto {
    pub fn new() -> MethodDescriptorProto {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string input_type = 2;

    pub fn input_type(&self) -> &str {
        match self.input_type.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_input_type(&mut self) {
        self.input_type = ::std::option::Option::None;
    }

    pub fn has_input_type(&self) -> bool {
        self.input_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_type(&mut self, v: ::std::string::String) {
        self.input_type = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_input_type(&mut self) -> &mut ::std::string::String {
        if self.input_type.is_none() {
            self.input_type = ::std::option::Option::Some(::std::string::String::new());
        }
        self.input_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_input_type(&mut self) -> ::std::string::String {
        self.input_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string output_type = 3;

    pub fn output_type(&self) -> &str {
        match self.output_type.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_output_type(&mut self) {
        self.output_type = ::std::option::Option::None;
    }

    pub fn has_output_type(&self) -> bool {
        self.output_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_output_type(&mut self, v: ::std::string::String) {
        self.output_type = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_output_type(&mut self) -> &mut ::std::string::String {
        if self.output_type.is_none() {
            self.output_type = ::std::option::Option::Some(::std::string::String::new());
        }
        self.output_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_output_type(&mut self) -> ::std::string::String {
        self.output_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool client_streaming = 5;

    pub fn client_streaming(&self) -> bool {
        self.client_streaming.unwrap_or(false)
    }

    pub fn clear_client_streaming(&mut self) {
        self.client_streaming = ::std::option::Option::None;
    }

    pub fn has_client_streaming(&self) -> bool {
        self.client_streaming.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_streaming(&mut self, v: bool) {
        self.client_streaming = ::std::option::Option::Some(v);
    }

    // optional bool server_streaming = 6;

    pub fn server_streaming(&self) -> bool {
        self.server_streaming.unwrap_or(false)
    }

    pub fn clear_server_streaming(&mut self) {
        self.server_streaming = ::std::option::Option::None;
    }

    pub fn has_server_streaming(&self) -> bool {
        self.server_streaming.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_streaming(&mut self, v: bool) {
        self.server_streaming = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &MethodDescriptorProto| { &m.name },
            |m: &mut MethodDescriptorProto| { &mut m.name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "input_type",
            |m: &MethodDescriptorProto| { &m.input_type },
            |m: &mut MethodDescriptorProto| { &mut m.input_type },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "output_type",
            |m: &MethodDescriptorProto| { &m.output_type },
            |m: &mut MethodDescriptorProto| { &mut m.output_type },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, MethodOptions>(
            "options",
            |m: &MethodDescriptorProto| { &m.options },
            |m: &mut MethodDescriptorProto| { &mut m.options },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_streaming",
            |m: &MethodDescriptorProto| { &m.client_streaming },
            |m: &mut MethodDescriptorProto| { &mut m.client_streaming },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_streaming",
            |m: &MethodDescriptorProto| { &m.server_streaming },
            |m: &mut MethodDescriptorProto| { &mut m.server_streaming },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<MethodDescriptorProto>(
            "MethodDescriptorProto",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for MethodDescriptorProto {
    const NAME: &'static str = "MethodDescriptorProto";

    fn is_initialized(&self) -> bool {
        for v in &self.options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.input_type = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.output_type = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.options)?;
                },
                40 => {
                    self.client_streaming = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.server_streaming = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        if let Some(v) = self.input_type.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        if let Some(v) = self.output_type.as_ref() {
            my_size += crate::rt::string_size(3, &v);
        }
        if let Some(v) = self.options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.client_streaming {
            my_size += 1 + 1;
        }
        if let Some(v) = self.server_streaming {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.input_type.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.output_type.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.options.as_ref() {
            crate::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.client_streaming {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.server_streaming {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MethodDescriptorProto {
        MethodDescriptorProto::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.input_type = ::std::option::Option::None;
        self.output_type = ::std::option::Option::None;
        self.options.clear();
        self.client_streaming = ::std::option::Option::None;
        self.server_streaming = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MethodDescriptorProto {
        static instance: MethodDescriptorProto = MethodDescriptorProto {
            name: ::std::option::Option::None,
            input_type: ::std::option::Option::None,
            output_type: ::std::option::Option::None,
            options: crate::MessageField::none(),
            client_streaming: ::std::option::Option::None,
            server_streaming: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for MethodDescriptorProto {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MethodDescriptorProto").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MethodDescriptorProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for MethodDescriptorProto {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:google.protobuf.FileOptions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FileOptions {
    // message fields
    ///  Sets the Java package where classes generated from this .proto will be
    ///  placed.  By default, the proto package is used, but this is often
    ///  inappropriate because proto packages do not normally start with backwards
    ///  domain names.
    // @@protoc_insertion_point(field:google.protobuf.FileOptions.java_package)
    pub java_package: ::std::option::Option<::std::string::String>,
    ///  Controls the name of the wrapper Java class generated for the .proto file.
    ///  That class will always contain the .proto file's getDescriptor() method as
    ///  well as any top-level extensions defined in the .proto file.
    ///  If java_multiple_files is disabled, then all the other classes from the
    ///  .proto file will be nested inside the single wrapper outer class.
    // @@protoc_insertion_point(field:google.protobuf.FileOptions.java_outer_classname)
    pub java_outer_classname: ::std::option::Option<::std::string::String>,
    ///  If enabled, then the Java code generator will generate a separate .java
    ///  file for each top-level message, enum, and service defined in the .proto
    ///  file.  Thus, these types will *not* be nested inside the wrapper class
    ///  named by java_outer_classname.  However, the wrapper class will still be
    ///  generated to contain the file's getDescriptor() method as well as any
    ///  top-level extensions defined in the file.
    // @@protoc_insertion_point(field:google.protobuf.FileOptions.java_multiple_files)
    pub java_multiple_files: ::std::option::Option<bool>,
    ///  This option does nothing.
    // @@protoc_insertion_point(field:google.protobuf.FileOptions.java_generate_equals_and_hash)
    pub java_generate_equals_and_hash: ::std::option::Option<bool>,
    ///  If set true, then the Java2 code generator will generate code that
    ///  throws an exception whenever an attempt is made to assign a non-UTF-8
    ///  byte sequence to a string field.
    ///  Message reflection will do the same.
    ///  However, an extension field still accepts non-UTF-8 byte sequences.
    ///  This option has no effect on when used with the lite runtime.
    // @@protoc_insertion_point(field:google.protobuf.FileOptions.java_string_check_utf8)
    pub java_string_check_utf8: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:google.protobuf.FileOptions.optimize_for)
    pub optimize_for: ::std::option::Option<crate::EnumOrUnknown<file_options::OptimizeMode>>,
    ///  Sets the Go package where structs generated from this .proto will be
    ///  placed. If omitted, the Go package will be derived from the following:
    ///    - The basename of the package import path, if provided.
    ///    - Otherwise, the package statement in the .proto file, if present.
    ///    - Otherwise, the basename of the .proto file, without extension.
    // @@protoc_insertion_point(field:google.protobuf.FileOptions.go_package)
    pub go_package: ::std::option::Option<::std::string::String>,
    ///  Should generic services be generated in each language?  "Generic" services
    ///  are not specific to any particular RPC system.  They are generated by the
    ///  main code generators in each language (without additional plugins).
    ///  Generic services were the only kind of service generation supported by
    ///  early versions of google.protobuf.
    ///
    ///  Generic services are now considered deprecated in favor of using plugins
    ///  that generate code specific to your particular RPC system.  Therefore,
    ///  these default to false.  Old code which depends on generic services should
    ///  explicitly set them to true.
    // @@protoc_insertion_point(field:google.protobuf.FileOptions.cc_generic_services)
    pub cc_generic_services: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:google.protobuf.FileOptions.java_generic_services)
    pub java_generic_services: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:google.protobuf.FileOptions.py_generic_services)
    pub py_generic_services: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:google.protobuf.FileOptions.php_generic_services)
    pub php_generic_services: ::std::option::Option<bool>,
    ///  Is this file deprecated?
    ///  Depending on the target platform, this can emit Deprecated annotations
    ///  for everything in the file, or it will be completely ignored; in the very
    ///  least, this is a formalization for deprecating files.
    // @@protoc_insertion_point(field:google.protobuf.FileOptions.deprecated)
    pub deprecated: ::std::option::Option<bool>,
    ///  Enables the use of arenas for the proto messages in this file. This applies
    ///  only to generated classes for C++.
    // @@protoc_insertion_point(field:google.protobuf.FileOptions.cc_enable_arenas)
    pub cc_enable_arenas: ::std::option::Option<bool>,
    ///  Sets the objective c class prefix which is prepended to all objective c
    ///  generated classes from this .proto. There is no default.
    // @@protoc_insertion_point(field:google.protobuf.FileOptions.objc_class_prefix)
    pub objc_class_prefix: ::std::option::Option<::std::string::String>,
    ///  Namespace for generated classes; defaults to the package.
    // @@protoc_insertion_point(field:google.protobuf.FileOptions.csharp_namespace)
    pub csharp_namespace: ::std::option::Option<::std::string::String>,
    ///  By default Swift generators will take the proto package and CamelCase it
    ///  replacing '.' with underscore and use that to prefix the types/symbols
    ///  defined. When this options is provided, they will use this value instead
    ///  to prefix the types/symbols defined.
    // @@protoc_insertion_point(field:google.protobuf.FileOptions.swift_prefix)
    pub swift_prefix: ::std::option::Option<::std::string::String>,
    ///  Sets the php class prefix which is prepended to all php generated classes
    ///  from this .proto. Default is empty.
    // @@protoc_insertion_point(field:google.protobuf.FileOptions.php_class_prefix)
    pub php_class_prefix: ::std::option::Option<::std::string::String>,
    ///  Use this option to change the namespace of php generated classes. Default
    ///  is empty. When this option is empty, the package name will be used for
    ///  determining the namespace.
    // @@protoc_insertion_point(field:google.protobuf.FileOptions.php_namespace)
    pub php_namespace: ::std::option::Option<::std::string::String>,
    ///  Use this option to change the namespace of php generated metadata classes.
    ///  Default is empty. When this option is empty, the proto file name will be
    ///  used for determining the namespace.
    // @@protoc_insertion_point(field:google.protobuf.FileOptions.php_metadata_namespace)
    pub php_metadata_namespace: ::std::option::Option<::std::string::String>,
    ///  Use this option to change the package of ruby generated classes. Default
    ///  is empty. When this option is not set, the package name will be used for
    ///  determining the ruby package.
    // @@protoc_insertion_point(field:google.protobuf.FileOptions.ruby_package)
    pub ruby_package: ::std::option::Option<::std::string::String>,
    ///  The parser stores options it doesn't recognize here.
    ///  See the documentation for the "Options" section above.
    // @@protoc_insertion_point(field:google.protobuf.FileOptions.uninterpreted_option)
    pub uninterpreted_option: ::std::vec::Vec<UninterpretedOption>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.FileOptions.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FileOptions {
    fn default() -> &'a FileOptions {
        <FileOptions as crate::Message>::default_instance()
    }
}

impl FileOptions {
    pub fn new() -> FileOptions {
        ::std::default::Default::default()
    }

    // optional string java_package = 1;

    pub fn java_package(&self) -> &str {
        match self.java_package.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_java_package(&mut self) {
        self.java_package = ::std::option::Option::None;
    }

    pub fn has_java_package(&self) -> bool {
        self.java_package.is_some()
    }

    // Param is passed by value, moved
    pub fn set_java_package(&mut self, v: ::std::string::String) {
        self.java_package = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_java_package(&mut self) -> &mut ::std::string::String {
        if self.java_package.is_none() {
            self.java_package = ::std::option::Option::Some(::std::string::String::new());
        }
        self.java_package.as_mut().unwrap()
    }

    // Take field
    pub fn take_java_package(&mut self) -> ::std::string::String {
        self.java_package.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string java_outer_classname = 8;

    pub fn java_outer_classname(&self) -> &str {
        match self.java_outer_classname.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_java_outer_classname(&mut self) {
        self.java_outer_classname = ::std::option::Option::None;
    }

    pub fn has_java_outer_classname(&self) -> bool {
        self.java_outer_classname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_java_outer_classname(&mut self, v: ::std::string::String) {
        self.java_outer_classname = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_java_outer_classname(&mut self) -> &mut ::std::string::String {
        if self.java_outer_classname.is_none() {
            self.java_outer_classname = ::std::option::Option::Some(::std::string::String::new());
        }
        self.java_outer_classname.as_mut().unwrap()
    }

    // Take field
    pub fn take_java_outer_classname(&mut self) -> ::std::string::String {
        self.java_outer_classname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool java_multiple_files = 10;

    pub fn java_multiple_files(&self) -> bool {
        self.java_multiple_files.unwrap_or(false)
    }

    pub fn clear_java_multiple_files(&mut self) {
        self.java_multiple_files = ::std::option::Option::None;
    }

    pub fn has_java_multiple_files(&self) -> bool {
        self.java_multiple_files.is_some()
    }

    // Param is passed by value, moved
    pub fn set_java_multiple_files(&mut self, v: bool) {
        self.java_multiple_files = ::std::option::Option::Some(v);
    }

    // optional bool java_generate_equals_and_hash = 20;

    pub fn java_generate_equals_and_hash(&self) -> bool {
        self.java_generate_equals_and_hash.unwrap_or(false)
    }

    pub fn clear_java_generate_equals_and_hash(&mut self) {
        self.java_generate_equals_and_hash = ::std::option::Option::None;
    }

    pub fn has_java_generate_equals_and_hash(&self) -> bool {
        self.java_generate_equals_and_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_java_generate_equals_and_hash(&mut self, v: bool) {
        self.java_generate_equals_and_hash = ::std::option::Option::Some(v);
    }

    // optional bool java_string_check_utf8 = 27;

    pub fn java_string_check_utf8(&self) -> bool {
        self.java_string_check_utf8.unwrap_or(false)
    }

    pub fn clear_java_string_check_utf8(&mut self) {
        self.java_string_check_utf8 = ::std::option::Option::None;
    }

    pub fn has_java_string_check_utf8(&self) -> bool {
        self.java_string_check_utf8.is_some()
    }

    // Param is passed by value, moved
    pub fn set_java_string_check_utf8(&mut self, v: bool) {
        self.java_string_check_utf8 = ::std::option::Option::Some(v);
    }

    // optional .google.protobuf.FileOptions.OptimizeMode optimize_for = 9;

    pub fn optimize_for(&self) -> file_options::OptimizeMode {
        match self.optimize_for {
            Some(e) => e.enum_value_or(file_options::OptimizeMode::SPEED),
            None => file_options::OptimizeMode::SPEED,
        }
    }

    pub fn clear_optimize_for(&mut self) {
        self.optimize_for = ::std::option::Option::None;
    }

    pub fn has_optimize_for(&self) -> bool {
        self.optimize_for.is_some()
    }

    // Param is passed by value, moved
    pub fn set_optimize_for(&mut self, v: file_options::OptimizeMode) {
        self.optimize_for = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional string go_package = 11;

    pub fn go_package(&self) -> &str {
        match self.go_package.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_go_package(&mut self) {
        self.go_package = ::std::option::Option::None;
    }

    pub fn has_go_package(&self) -> bool {
        self.go_package.is_some()
    }

    // Param is passed by value, moved
    pub fn set_go_package(&mut self, v: ::std::string::String) {
        self.go_package = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_go_package(&mut self) -> &mut ::std::string::String {
        if self.go_package.is_none() {
            self.go_package = ::std::option::Option::Some(::std::string::String::new());
        }
        self.go_package.as_mut().unwrap()
    }

    // Take field
    pub fn take_go_package(&mut self) -> ::std::string::String {
        self.go_package.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool cc_generic_services = 16;

    pub fn cc_generic_services(&self) -> bool {
        self.cc_generic_services.unwrap_or(false)
    }

    pub fn clear_cc_generic_services(&mut self) {
        self.cc_generic_services = ::std::option::Option::None;
    }

    pub fn has_cc_generic_services(&self) -> bool {
        self.cc_generic_services.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cc_generic_services(&mut self, v: bool) {
        self.cc_generic_services = ::std::option::Option::Some(v);
    }

    // optional bool java_generic_services = 17;

    pub fn java_generic_services(&self) -> bool {
        self.java_generic_services.unwrap_or(false)
    }

    pub fn clear_java_generic_services(&mut self) {
        self.java_generic_services = ::std::option::Option::None;
    }

    pub fn has_java_generic_services(&self) -> bool {
        self.java_generic_services.is_some()
    }

    // Param is passed by value, moved
    pub fn set_java_generic_services(&mut self, v: bool) {
        self.java_generic_services = ::std::option::Option::Some(v);
    }

    // optional bool py_generic_services = 18;

    pub fn py_generic_services(&self) -> bool {
        self.py_generic_services.unwrap_or(false)
    }

    pub fn clear_py_generic_services(&mut self) {
        self.py_generic_services = ::std::option::Option::None;
    }

    pub fn has_py_generic_services(&self) -> bool {
        self.py_generic_services.is_some()
    }

    // Param is passed by value, moved
    pub fn set_py_generic_services(&mut self, v: bool) {
        self.py_generic_services = ::std::option::Option::Some(v);
    }

    // optional bool php_generic_services = 42;

    pub fn php_generic_services(&self) -> bool {
        self.php_generic_services.unwrap_or(false)
    }

    pub fn clear_php_generic_services(&mut self) {
        self.php_generic_services = ::std::option::Option::None;
    }

    pub fn has_php_generic_services(&self) -> bool {
        self.php_generic_services.is_some()
    }

    // Param is passed by value, moved
    pub fn set_php_generic_services(&mut self, v: bool) {
        self.php_generic_services = ::std::option::Option::Some(v);
    }

    // optional bool deprecated = 23;

    pub fn deprecated(&self) -> bool {
        self.deprecated.unwrap_or(false)
    }

    pub fn clear_deprecated(&mut self) {
        self.deprecated = ::std::option::Option::None;
    }

    pub fn has_deprecated(&self) -> bool {
        self.deprecated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deprecated(&mut self, v: bool) {
        self.deprecated = ::std::option::Option::Some(v);
    }

    // optional bool cc_enable_arenas = 31;

    pub fn cc_enable_arenas(&self) -> bool {
        self.cc_enable_arenas.unwrap_or(true)
    }

    pub fn clear_cc_enable_arenas(&mut self) {
        self.cc_enable_arenas = ::std::option::Option::None;
    }

    pub fn has_cc_enable_arenas(&self) -> bool {
        self.cc_enable_arenas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cc_enable_arenas(&mut self, v: bool) {
        self.cc_enable_arenas = ::std::option::Option::Some(v);
    }

    // optional string objc_class_prefix = 36;

    pub fn objc_class_prefix(&self) -> &str {
        match self.objc_class_prefix.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_objc_class_prefix(&mut self) {
        self.objc_class_prefix = ::std::option::Option::None;
    }

    pub fn has_objc_class_prefix(&self) -> bool {
        self.objc_class_prefix.is_some()
    }

    // Param is passed by value, moved
    pub fn set_objc_class_prefix(&mut self, v: ::std::string::String) {
        self.objc_class_prefix = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_objc_class_prefix(&mut self) -> &mut ::std::string::String {
        if self.objc_class_prefix.is_none() {
            self.objc_class_prefix = ::std::option::Option::Some(::std::string::String::new());
        }
        self.objc_class_prefix.as_mut().unwrap()
    }

    // Take field
    pub fn take_objc_class_prefix(&mut self) -> ::std::string::String {
        self.objc_class_prefix.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string csharp_namespace = 37;

    pub fn csharp_namespace(&self) -> &str {
        match self.csharp_namespace.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_csharp_namespace(&mut self) {
        self.csharp_namespace = ::std::option::Option::None;
    }

    pub fn has_csharp_namespace(&self) -> bool {
        self.csharp_namespace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_csharp_namespace(&mut self, v: ::std::string::String) {
        self.csharp_namespace = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_csharp_namespace(&mut self) -> &mut ::std::string::String {
        if self.csharp_namespace.is_none() {
            self.csharp_namespace = ::std::option::Option::Some(::std::string::String::new());
        }
        self.csharp_namespace.as_mut().unwrap()
    }

    // Take field
    pub fn take_csharp_namespace(&mut self) -> ::std::string::String {
        self.csharp_namespace.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string swift_prefix = 39;

    pub fn swift_prefix(&self) -> &str {
        match self.swift_prefix.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_swift_prefix(&mut self) {
        self.swift_prefix = ::std::option::Option::None;
    }

    pub fn has_swift_prefix(&self) -> bool {
        self.swift_prefix.is_some()
    }

    // Param is passed by value, moved
    pub fn set_swift_prefix(&mut self, v: ::std::string::String) {
        self.swift_prefix = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_swift_prefix(&mut self) -> &mut ::std::string::String {
        if self.swift_prefix.is_none() {
            self.swift_prefix = ::std::option::Option::Some(::std::string::String::new());
        }
        self.swift_prefix.as_mut().unwrap()
    }

    // Take field
    pub fn take_swift_prefix(&mut self) -> ::std::string::String {
        self.swift_prefix.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string php_class_prefix = 40;

    pub fn php_class_prefix(&self) -> &str {
        match self.php_class_prefix.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_php_class_prefix(&mut self) {
        self.php_class_prefix = ::std::option::Option::None;
    }

    pub fn has_php_class_prefix(&self) -> bool {
        self.php_class_prefix.is_some()
    }

    // Param is passed by value, moved
    pub fn set_php_class_prefix(&mut self, v: ::std::string::String) {
        self.php_class_prefix = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_php_class_prefix(&mut self) -> &mut ::std::string::String {
        if self.php_class_prefix.is_none() {
            self.php_class_prefix = ::std::option::Option::Some(::std::string::String::new());
        }
        self.php_class_prefix.as_mut().unwrap()
    }

    // Take field
    pub fn take_php_class_prefix(&mut self) -> ::std::string::String {
        self.php_class_prefix.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string php_namespace = 41;

    pub fn php_namespace(&self) -> &str {
        match self.php_namespace.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_php_namespace(&mut self) {
        self.php_namespace = ::std::option::Option::None;
    }

    pub fn has_php_namespace(&self) -> bool {
        self.php_namespace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_php_namespace(&mut self, v: ::std::string::String) {
        self.php_namespace = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_php_namespace(&mut self) -> &mut ::std::string::String {
        if self.php_namespace.is_none() {
            self.php_namespace = ::std::option::Option::Some(::std::string::String::new());
        }
        self.php_namespace.as_mut().unwrap()
    }

    // Take field
    pub fn take_php_namespace(&mut self) -> ::std::string::String {
        self.php_namespace.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string php_metadata_namespace = 44;

    pub fn php_metadata_namespace(&self) -> &str {
        match self.php_metadata_namespace.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_php_metadata_namespace(&mut self) {
        self.php_metadata_namespace = ::std::option::Option::None;
    }

    pub fn has_php_metadata_namespace(&self) -> bool {
        self.php_metadata_namespace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_php_metadata_namespace(&mut self, v: ::std::string::String) {
        self.php_metadata_namespace = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_php_metadata_namespace(&mut self) -> &mut ::std::string::String {
        if self.php_metadata_namespace.is_none() {
            self.php_metadata_namespace = ::std::option::Option::Some(::std::string::String::new());
        }
        self.php_metadata_namespace.as_mut().unwrap()
    }

    // Take field
    pub fn take_php_metadata_namespace(&mut self) -> ::std::string::String {
        self.php_metadata_namespace.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string ruby_package = 45;

    pub fn ruby_package(&self) -> &str {
        match self.ruby_package.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_ruby_package(&mut self) {
        self.ruby_package = ::std::option::Option::None;
    }

    pub fn has_ruby_package(&self) -> bool {
        self.ruby_package.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ruby_package(&mut self, v: ::std::string::String) {
        self.ruby_package = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ruby_package(&mut self) -> &mut ::std::string::String {
        if self.ruby_package.is_none() {
            self.ruby_package = ::std::option::Option::Some(::std::string::String::new());
        }
        self.ruby_package.as_mut().unwrap()
    }

    // Take field
    pub fn take_ruby_package(&mut self) -> ::std::string::String {
        self.ruby_package.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(21);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "java_package",
            |m: &FileOptions| { &m.java_package },
            |m: &mut FileOptions| { &mut m.java_package },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "java_outer_classname",
            |m: &FileOptions| { &m.java_outer_classname },
            |m: &mut FileOptions| { &mut m.java_outer_classname },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "java_multiple_files",
            |m: &FileOptions| { &m.java_multiple_files },
            |m: &mut FileOptions| { &mut m.java_multiple_files },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "java_generate_equals_and_hash",
            |m: &FileOptions| { &m.java_generate_equals_and_hash },
            |m: &mut FileOptions| { &mut m.java_generate_equals_and_hash },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "java_string_check_utf8",
            |m: &FileOptions| { &m.java_string_check_utf8 },
            |m: &mut FileOptions| { &mut m.java_string_check_utf8 },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "optimize_for",
            |m: &FileOptions| { &m.optimize_for },
            |m: &mut FileOptions| { &mut m.optimize_for },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "go_package",
            |m: &FileOptions| { &m.go_package },
            |m: &mut FileOptions| { &mut m.go_package },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "cc_generic_services",
            |m: &FileOptions| { &m.cc_generic_services },
            |m: &mut FileOptions| { &mut m.cc_generic_services },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "java_generic_services",
            |m: &FileOptions| { &m.java_generic_services },
            |m: &mut FileOptions| { &mut m.java_generic_services },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "py_generic_services",
            |m: &FileOptions| { &m.py_generic_services },
            |m: &mut FileOptions| { &mut m.py_generic_services },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "php_generic_services",
            |m: &FileOptions| { &m.php_generic_services },
            |m: &mut FileOptions| { &mut m.php_generic_services },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "deprecated",
            |m: &FileOptions| { &m.deprecated },
            |m: &mut FileOptions| { &mut m.deprecated },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "cc_enable_arenas",
            |m: &FileOptions| { &m.cc_enable_arenas },
            |m: &mut FileOptions| { &mut m.cc_enable_arenas },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "objc_class_prefix",
            |m: &FileOptions| { &m.objc_class_prefix },
            |m: &mut FileOptions| { &mut m.objc_class_prefix },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "csharp_namespace",
            |m: &FileOptions| { &m.csharp_namespace },
            |m: &mut FileOptions| { &mut m.csharp_namespace },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "swift_prefix",
            |m: &FileOptions| { &m.swift_prefix },
            |m: &mut FileOptions| { &mut m.swift_prefix },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "php_class_prefix",
            |m: &FileOptions| { &m.php_class_prefix },
            |m: &mut FileOptions| { &mut m.php_class_prefix },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "php_namespace",
            |m: &FileOptions| { &m.php_namespace },
            |m: &mut FileOptions| { &mut m.php_namespace },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "php_metadata_namespace",
            |m: &FileOptions| { &m.php_metadata_namespace },
            |m: &mut FileOptions| { &mut m.php_metadata_namespace },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "ruby_package",
            |m: &FileOptions| { &m.ruby_package },
            |m: &mut FileOptions| { &mut m.ruby_package },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "uninterpreted_option",
            |m: &FileOptions| { &m.uninterpreted_option },
            |m: &mut FileOptions| { &mut m.uninterpreted_option },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<FileOptions>(
            "FileOptions",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for FileOptions {
    const NAME: &'static str = "FileOptions";

    fn is_initialized(&self) -> bool {
        for v in &self.uninterpreted_option {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.java_package = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    self.java_outer_classname = ::std::option::Option::Some(is.read_string()?);
                },
                80 => {
                    self.java_multiple_files = ::std::option::Option::Some(is.read_bool()?);
                },
                160 => {
                    self.java_generate_equals_and_hash = ::std::option::Option::Some(is.read_bool()?);
                },
                216 => {
                    self.java_string_check_utf8 = ::std::option::Option::Some(is.read_bool()?);
                },
                72 => {
                    self.optimize_for = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                90 => {
                    self.go_package = ::std::option::Option::Some(is.read_string()?);
                },
                128 => {
                    self.cc_generic_services = ::std::option::Option::Some(is.read_bool()?);
                },
                136 => {
                    self.java_generic_services = ::std::option::Option::Some(is.read_bool()?);
                },
                144 => {
                    self.py_generic_services = ::std::option::Option::Some(is.read_bool()?);
                },
                336 => {
                    self.php_generic_services = ::std::option::Option::Some(is.read_bool()?);
                },
                184 => {
                    self.deprecated = ::std::option::Option::Some(is.read_bool()?);
                },
                248 => {
                    self.cc_enable_arenas = ::std::option::Option::Some(is.read_bool()?);
                },
                290 => {
                    self.objc_class_prefix = ::std::option::Option::Some(is.read_string()?);
                },
                298 => {
                    self.csharp_namespace = ::std::option::Option::Some(is.read_string()?);
                },
                314 => {
                    self.swift_prefix = ::std::option::Option::Some(is.read_string()?);
                },
                322 => {
                    self.php_class_prefix = ::std::option::Option::Some(is.read_string()?);
                },
                330 => {
                    self.php_namespace = ::std::option::Option::Some(is.read_string()?);
                },
                354 => {
                    self.php_metadata_namespace = ::std::option::Option::Some(is.read_string()?);
                },
                362 => {
                    self.ruby_package = ::std::option::Option::Some(is.read_string()?);
                },
                7994 => {
                    self.uninterpreted_option.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.java_package.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        if let Some(v) = self.java_outer_classname.as_ref() {
            my_size += crate::rt::string_size(8, &v);
        }
        if let Some(v) = self.java_multiple_files {
            my_size += 1 + 1;
        }
        if let Some(v) = self.java_generate_equals_and_hash {
            my_size += 2 + 1;
        }
        if let Some(v) = self.java_string_check_utf8 {
            my_size += 2 + 1;
        }
        if let Some(v) = self.optimize_for {
            my_size += crate::rt::int32_size(9, v.value());
        }
        if let Some(v) = self.go_package.as_ref() {
            my_size += crate::rt::string_size(11, &v);
        }
        if let Some(v) = self.cc_generic_services {
            my_size += 2 + 1;
        }
        if let Some(v) = self.java_generic_services {
            my_size += 2 + 1;
        }
        if let Some(v) = self.py_generic_services {
            my_size += 2 + 1;
        }
        if let Some(v) = self.php_generic_services {
            my_size += 2 + 1;
        }
        if let Some(v) = self.deprecated {
            my_size += 2 + 1;
        }
        if let Some(v) = self.cc_enable_arenas {
            my_size += 2 + 1;
        }
        if let Some(v) = self.objc_class_prefix.as_ref() {
            my_size += crate::rt::string_size(36, &v);
        }
        if let Some(v) = self.csharp_namespace.as_ref() {
            my_size += crate::rt::string_size(37, &v);
        }
        if let Some(v) = self.swift_prefix.as_ref() {
            my_size += crate::rt::string_size(39, &v);
        }
        if let Some(v) = self.php_class_prefix.as_ref() {
            my_size += crate::rt::string_size(40, &v);
        }
        if let Some(v) = self.php_namespace.as_ref() {
            my_size += crate::rt::string_size(41, &v);
        }
        if let Some(v) = self.php_metadata_namespace.as_ref() {
            my_size += crate::rt::string_size(44, &v);
        }
        if let Some(v) = self.ruby_package.as_ref() {
            my_size += crate::rt::string_size(45, &v);
        }
        for value in &self.uninterpreted_option {
            let len = value.compute_size();
            my_size += 2 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.java_package.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.java_outer_classname.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.java_multiple_files {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.java_generate_equals_and_hash {
            os.write_bool(20, v)?;
        }
        if let Some(v) = self.java_string_check_utf8 {
            os.write_bool(27, v)?;
        }
        if let Some(v) = self.optimize_for {
            os.write_enum(9, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.go_package.as_ref() {
            os.write_string(11, v)?;
        }
        if let Some(v) = self.cc_generic_services {
            os.write_bool(16, v)?;
        }
        if let Some(v) = self.java_generic_services {
            os.write_bool(17, v)?;
        }
        if let Some(v) = self.py_generic_services {
            os.write_bool(18, v)?;
        }
        if let Some(v) = self.php_generic_services {
            os.write_bool(42, v)?;
        }
        if let Some(v) = self.deprecated {
            os.write_bool(23, v)?;
        }
        if let Some(v) = self.cc_enable_arenas {
            os.write_bool(31, v)?;
        }
        if let Some(v) = self.objc_class_prefix.as_ref() {
            os.write_string(36, v)?;
        }
        if let Some(v) = self.csharp_namespace.as_ref() {
            os.write_string(37, v)?;
        }
        if let Some(v) = self.swift_prefix.as_ref() {
            os.write_string(39, v)?;
        }
        if let Some(v) = self.php_class_prefix.as_ref() {
            os.write_string(40, v)?;
        }
        if let Some(v) = self.php_namespace.as_ref() {
            os.write_string(41, v)?;
        }
        if let Some(v) = self.php_metadata_namespace.as_ref() {
            os.write_string(44, v)?;
        }
        if let Some(v) = self.ruby_package.as_ref() {
            os.write_string(45, v)?;
        }
        for v in &self.uninterpreted_option {
            crate::rt::write_message_field_with_cached_size(999, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FileOptions {
        FileOptions::new()
    }

    fn clear(&mut self) {
        self.java_package = ::std::option::Option::None;
        self.java_outer_classname = ::std::option::Option::None;
        self.java_multiple_files = ::std::option::Option::None;
        self.java_generate_equals_and_hash = ::std::option::Option::None;
        self.java_string_check_utf8 = ::std::option::Option::None;
        self.optimize_for = ::std::option::Option::None;
        self.go_package = ::std::option::Option::None;
        self.cc_generic_services = ::std::option::Option::None;
        self.java_generic_services = ::std::option::Option::None;
        self.py_generic_services = ::std::option::Option::None;
        self.php_generic_services = ::std::option::Option::None;
        self.deprecated = ::std::option::Option::None;
        self.cc_enable_arenas = ::std::option::Option::None;
        self.objc_class_prefix = ::std::option::Option::None;
        self.csharp_namespace = ::std::option::Option::None;
        self.swift_prefix = ::std::option::Option::None;
        self.php_class_prefix = ::std::option::Option::None;
        self.php_namespace = ::std::option::Option::None;
        self.php_metadata_namespace = ::std::option::Option::None;
        self.ruby_package = ::std::option::Option::None;
        self.uninterpreted_option.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FileOptions {
        static instance: FileOptions = FileOptions {
            java_package: ::std::option::Option::None,
            java_outer_classname: ::std::option::Option::None,
            java_multiple_files: ::std::option::Option::None,
            java_generate_equals_and_hash: ::std::option::Option::None,
            java_string_check_utf8: ::std::option::Option::None,
            optimize_for: ::std::option::Option::None,
            go_package: ::std::option::Option::None,
            cc_generic_services: ::std::option::Option::None,
            java_generic_services: ::std::option::Option::None,
            py_generic_services: ::std::option::Option::None,
            php_generic_services: ::std::option::Option::None,
            deprecated: ::std::option::Option::None,
            cc_enable_arenas: ::std::option::Option::None,
            objc_class_prefix: ::std::option::Option::None,
            csharp_namespace: ::std::option::Option::None,
            swift_prefix: ::std::option::Option::None,
            php_class_prefix: ::std::option::Option::None,
            php_namespace: ::std::option::Option::None,
            php_metadata_namespace: ::std::option::Option::None,
            ruby_package: ::std::option::Option::None,
            uninterpreted_option: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for FileOptions {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FileOptions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FileOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for FileOptions {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `FileOptions`
pub mod file_options {
    ///  Generated classes can be optimized for speed or code size.
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:google.protobuf.FileOptions.OptimizeMode)
    pub enum OptimizeMode {
        // @@protoc_insertion_point(enum_value:google.protobuf.FileOptions.OptimizeMode.SPEED)
        SPEED = 1,
        // @@protoc_insertion_point(enum_value:google.protobuf.FileOptions.OptimizeMode.CODE_SIZE)
        CODE_SIZE = 2,
        // @@protoc_insertion_point(enum_value:google.protobuf.FileOptions.OptimizeMode.LITE_RUNTIME)
        LITE_RUNTIME = 3,
    }

    impl crate::Enum for OptimizeMode {
        const NAME: &'static str = "OptimizeMode";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<OptimizeMode> {
            match value {
                1 => ::std::option::Option::Some(OptimizeMode::SPEED),
                2 => ::std::option::Option::Some(OptimizeMode::CODE_SIZE),
                3 => ::std::option::Option::Some(OptimizeMode::LITE_RUNTIME),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<OptimizeMode> {
            match str {
                "SPEED" => ::std::option::Option::Some(OptimizeMode::SPEED),
                "CODE_SIZE" => ::std::option::Option::Some(OptimizeMode::CODE_SIZE),
                "LITE_RUNTIME" => ::std::option::Option::Some(OptimizeMode::LITE_RUNTIME),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [OptimizeMode] = &[
            OptimizeMode::SPEED,
            OptimizeMode::CODE_SIZE,
            OptimizeMode::LITE_RUNTIME,
        ];
    }

    impl crate::EnumFull for OptimizeMode {
        fn enum_descriptor() -> crate::reflect::EnumDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("FileOptions.OptimizeMode").unwrap()).clone()
        }

        fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
            let index = match self {
                OptimizeMode::SPEED => 0,
                OptimizeMode::CODE_SIZE => 1,
                OptimizeMode::LITE_RUNTIME => 2,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for OptimizeMode {
        fn default() -> Self {
            OptimizeMode::SPEED
        }
    }

    impl OptimizeMode {
        pub(in super) fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
            crate::reflect::GeneratedEnumDescriptorData::new::<OptimizeMode>("FileOptions.OptimizeMode")
        }
    }
}

// @@protoc_insertion_point(message:google.protobuf.MessageOptions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MessageOptions {
    // message fields
    // @@protoc_insertion_point(field:google.protobuf.MessageOptions.message_set_wire_format)
    pub message_set_wire_format: ::std::option::Option<bool>,
    ///  Disables the generation of the standard "descriptor()" accessor, which can
    ///  conflict with a field of the same name.  This is meant to make migration
    ///  from proto1 easier; new code should avoid fields named "descriptor".
    // @@protoc_insertion_point(field:google.protobuf.MessageOptions.no_standard_descriptor_accessor)
    pub no_standard_descriptor_accessor: ::std::option::Option<bool>,
    ///  Is this message deprecated?
    ///  Depending on the target platform, this can emit Deprecated annotations
    ///  for the message, or it will be completely ignored; in the very least,
    ///  this is a formalization for deprecating messages.
    // @@protoc_insertion_point(field:google.protobuf.MessageOptions.deprecated)
    pub deprecated: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:google.protobuf.MessageOptions.map_entry)
    pub map_entry: ::std::option::Option<bool>,
    ///  The parser stores options it doesn't recognize here. See above.
    // @@protoc_insertion_point(field:google.protobuf.MessageOptions.uninterpreted_option)
    pub uninterpreted_option: ::std::vec::Vec<UninterpretedOption>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.MessageOptions.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MessageOptions {
    fn default() -> &'a MessageOptions {
        <MessageOptions as crate::Message>::default_instance()
    }
}

impl MessageOptions {
    pub fn new() -> MessageOptions {
        ::std::default::Default::default()
    }

    // optional bool message_set_wire_format = 1;

    pub fn message_set_wire_format(&self) -> bool {
        self.message_set_wire_format.unwrap_or(false)
    }

    pub fn clear_message_set_wire_format(&mut self) {
        self.message_set_wire_format = ::std::option::Option::None;
    }

    pub fn has_message_set_wire_format(&self) -> bool {
        self.message_set_wire_format.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_set_wire_format(&mut self, v: bool) {
        self.message_set_wire_format = ::std::option::Option::Some(v);
    }

    // optional bool no_standard_descriptor_accessor = 2;

    pub fn no_standard_descriptor_accessor(&self) -> bool {
        self.no_standard_descriptor_accessor.unwrap_or(false)
    }

    pub fn clear_no_standard_descriptor_accessor(&mut self) {
        self.no_standard_descriptor_accessor = ::std::option::Option::None;
    }

    pub fn has_no_standard_descriptor_accessor(&self) -> bool {
        self.no_standard_descriptor_accessor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_no_standard_descriptor_accessor(&mut self, v: bool) {
        self.no_standard_descriptor_accessor = ::std::option::Option::Some(v);
    }

    // optional bool deprecated = 3;

    pub fn deprecated(&self) -> bool {
        self.deprecated.unwrap_or(false)
    }

    pub fn clear_deprecated(&mut self) {
        self.deprecated = ::std::option::Option::None;
    }

    pub fn has_deprecated(&self) -> bool {
        self.deprecated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deprecated(&mut self, v: bool) {
        self.deprecated = ::std::option::Option::Some(v);
    }

    // optional bool map_entry = 7;

    pub fn map_entry(&self) -> bool {
        self.map_entry.unwrap_or(false)
    }

    pub fn clear_map_entry(&mut self) {
        self.map_entry = ::std::option::Option::None;
    }

    pub fn has_map_entry(&self) -> bool {
        self.map_entry.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_entry(&mut self, v: bool) {
        self.map_entry = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "message_set_wire_format",
            |m: &MessageOptions| { &m.message_set_wire_format },
            |m: &mut MessageOptions| { &mut m.message_set_wire_format },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "no_standard_descriptor_accessor",
            |m: &MessageOptions| { &m.no_standard_descriptor_accessor },
            |m: &mut MessageOptions| { &mut m.no_standard_descriptor_accessor },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "deprecated",
            |m: &MessageOptions| { &m.deprecated },
            |m: &mut MessageOptions| { &mut m.deprecated },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "map_entry",
            |m: &MessageOptions| { &m.map_entry },
            |m: &mut MessageOptions| { &mut m.map_entry },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "uninterpreted_option",
            |m: &MessageOptions| { &m.uninterpreted_option },
            |m: &mut MessageOptions| { &mut m.uninterpreted_option },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<MessageOptions>(
            "MessageOptions",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for MessageOptions {
    const NAME: &'static str = "MessageOptions";

    fn is_initialized(&self) -> bool {
        for v in &self.uninterpreted_option {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.message_set_wire_format = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.no_standard_descriptor_accessor = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.deprecated = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.map_entry = ::std::option::Option::Some(is.read_bool()?);
                },
                7994 => {
                    self.uninterpreted_option.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.message_set_wire_format {
            my_size += 1 + 1;
        }
        if let Some(v) = self.no_standard_descriptor_accessor {
            my_size += 1 + 1;
        }
        if let Some(v) = self.deprecated {
            my_size += 1 + 1;
        }
        if let Some(v) = self.map_entry {
            my_size += 1 + 1;
        }
        for value in &self.uninterpreted_option {
            let len = value.compute_size();
            my_size += 2 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.message_set_wire_format {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.no_standard_descriptor_accessor {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.deprecated {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.map_entry {
            os.write_bool(7, v)?;
        }
        for v in &self.uninterpreted_option {
            crate::rt::write_message_field_with_cached_size(999, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MessageOptions {
        MessageOptions::new()
    }

    fn clear(&mut self) {
        self.message_set_wire_format = ::std::option::Option::None;
        self.no_standard_descriptor_accessor = ::std::option::Option::None;
        self.deprecated = ::std::option::Option::None;
        self.map_entry = ::std::option::Option::None;
        self.uninterpreted_option.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MessageOptions {
        static instance: MessageOptions = MessageOptions {
            message_set_wire_format: ::std::option::Option::None,
            no_standard_descriptor_accessor: ::std::option::Option::None,
            deprecated: ::std::option::Option::None,
            map_entry: ::std::option::Option::None,
            uninterpreted_option: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for MessageOptions {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MessageOptions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MessageOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for MessageOptions {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:google.protobuf.FieldOptions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FieldOptions {
    // message fields
    ///  The ctype option instructs the C++ code generator to use a different
    ///  representation of the field than it normally would.  See the specific
    ///  options below.  This option is not yet implemented in the open source
    ///  release -- sorry, we'll try to include it in a future version!
    // @@protoc_insertion_point(field:google.protobuf.FieldOptions.ctype)
    pub ctype: ::std::option::Option<crate::EnumOrUnknown<field_options::CType>>,
    ///  The packed option can be enabled for repeated primitive fields to enable
    ///  a more efficient representation on the wire. Rather than repeatedly
    ///  writing the tag and type for each element, the entire array is encoded as
    ///  a single length-delimited blob. In proto3, only explicit setting it to
    ///  false will avoid using packed encoding.
    // @@protoc_insertion_point(field:google.protobuf.FieldOptions.packed)
    pub packed: ::std::option::Option<bool>,
    ///  The jstype option determines the JavaScript type used for values of the
    ///  field.  The option is permitted only for 64 bit integral and fixed types
    ///  (int64, uint64, sint64, fixed64, sfixed64).  A field with jstype JS_STRING
    ///  is represented as JavaScript string, which avoids loss of precision that
    ///  can happen when a large value is converted to a floating point JavaScript.
    ///  Specifying JS_NUMBER for the jstype causes the generated JavaScript code to
    ///  use the JavaScript "number" type.  The behavior of the default option
    ///  JS_NORMAL is implementation dependent.
    ///
    ///  This option is an enum to permit additional types to be added, e.g.
    ///  goog.math.Integer.
    // @@protoc_insertion_point(field:google.protobuf.FieldOptions.jstype)
    pub jstype: ::std::option::Option<crate::EnumOrUnknown<field_options::JSType>>,
    ///  Should this field be parsed lazily?  Lazy applies only to message-type
    ///  fields.  It means that when the outer message is initially parsed, the
    ///  inner message's contents will not be parsed but instead stored in encoded
    ///  form.  The inner message will actually be parsed when it is first accessed.
    ///
    ///  This is only a hint.  Implementations are free to choose whether to use
    ///  eager or lazy parsing regardless of the value of this option.  However,
    ///  setting this option true suggests that the protocol author believes that
    ///  using lazy parsing on this field is worth the additional bookkeeping
    ///  overhead typically needed to implement it.
    ///
    ///  This option does not affect the public interface of any generated code;
    ///  all method signatures remain the same.  Furthermore, thread-safety of the
    ///  interface is not affected by this option; const methods remain safe to
    ///  call from multiple threads concurrently, while non-const methods continue
    ///  to require exclusive access.
    ///
    ///
    ///  Note that implementations may choose not to check required fields within
    ///  a lazy sub-message.  That is, calling IsInitialized() on the outer message
    ///  may return true even if the inner message has missing required fields.
    ///  This is necessary because otherwise the inner message would have to be
    ///  parsed in order to perform the check, defeating the purpose of lazy
    ///  parsing.  An implementation which chooses not to check required fields
    ///  must be consistent about it.  That is, for any particular sub-message, the
    ///  implementation must either *always* check its required fields, or *never*
    ///  check its required fields, regardless of whether or not the message has
    ///  been parsed.
    // @@protoc_insertion_point(field:google.protobuf.FieldOptions.lazy)
    pub lazy: ::std::option::Option<bool>,
    ///  Is this field deprecated?
    ///  Depending on the target platform, this can emit Deprecated annotations
    ///  for accessors, or it will be completely ignored; in the very least, this
    ///  is a formalization for deprecating fields.
    // @@protoc_insertion_point(field:google.protobuf.FieldOptions.deprecated)
    pub deprecated: ::std::option::Option<bool>,
    ///  For Google-internal migration only. Do not use.
    // @@protoc_insertion_point(field:google.protobuf.FieldOptions.weak)
    pub weak: ::std::option::Option<bool>,
    ///  The parser stores options it doesn't recognize here. See above.
    // @@protoc_insertion_point(field:google.protobuf.FieldOptions.uninterpreted_option)
    pub uninterpreted_option: ::std::vec::Vec<UninterpretedOption>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.FieldOptions.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FieldOptions {
    fn default() -> &'a FieldOptions {
        <FieldOptions as crate::Message>::default_instance()
    }
}

impl FieldOptions {
    pub fn new() -> FieldOptions {
        ::std::default::Default::default()
    }

    // optional .google.protobuf.FieldOptions.CType ctype = 1;

    pub fn ctype(&self) -> field_options::CType {
        match self.ctype {
            Some(e) => e.enum_value_or(field_options::CType::STRING),
            None => field_options::CType::STRING,
        }
    }

    pub fn clear_ctype(&mut self) {
        self.ctype = ::std::option::Option::None;
    }

    pub fn has_ctype(&self) -> bool {
        self.ctype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctype(&mut self, v: field_options::CType) {
        self.ctype = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional bool packed = 2;

    pub fn packed(&self) -> bool {
        self.packed.unwrap_or(false)
    }

    pub fn clear_packed(&mut self) {
        self.packed = ::std::option::Option::None;
    }

    pub fn has_packed(&self) -> bool {
        self.packed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packed(&mut self, v: bool) {
        self.packed = ::std::option::Option::Some(v);
    }

    // optional .google.protobuf.FieldOptions.JSType jstype = 6;

    pub fn jstype(&self) -> field_options::JSType {
        match self.jstype {
            Some(e) => e.enum_value_or(field_options::JSType::JS_NORMAL),
            None => field_options::JSType::JS_NORMAL,
        }
    }

    pub fn clear_jstype(&mut self) {
        self.jstype = ::std::option::Option::None;
    }

    pub fn has_jstype(&self) -> bool {
        self.jstype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jstype(&mut self, v: field_options::JSType) {
        self.jstype = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional bool lazy = 5;

    pub fn lazy(&self) -> bool {
        self.lazy.unwrap_or(false)
    }

    pub fn clear_lazy(&mut self) {
        self.lazy = ::std::option::Option::None;
    }

    pub fn has_lazy(&self) -> bool {
        self.lazy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lazy(&mut self, v: bool) {
        self.lazy = ::std::option::Option::Some(v);
    }

    // optional bool deprecated = 3;

    pub fn deprecated(&self) -> bool {
        self.deprecated.unwrap_or(false)
    }

    pub fn clear_deprecated(&mut self) {
        self.deprecated = ::std::option::Option::None;
    }

    pub fn has_deprecated(&self) -> bool {
        self.deprecated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deprecated(&mut self, v: bool) {
        self.deprecated = ::std::option::Option::Some(v);
    }

    // optional bool weak = 10;

    pub fn weak(&self) -> bool {
        self.weak.unwrap_or(false)
    }

    pub fn clear_weak(&mut self) {
        self.weak = ::std::option::Option::None;
    }

    pub fn has_weak(&self) -> bool {
        self.weak.is_some()
    }

    // Param is passed by value, moved
    pub fn set_weak(&mut self, v: bool) {
        self.weak = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctype",
            |m: &FieldOptions| { &m.ctype },
            |m: &mut FieldOptions| { &mut m.ctype },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "packed",
            |m: &FieldOptions| { &m.packed },
            |m: &mut FieldOptions| { &mut m.packed },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "jstype",
            |m: &FieldOptions| { &m.jstype },
            |m: &mut FieldOptions| { &mut m.jstype },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "lazy",
            |m: &FieldOptions| { &m.lazy },
            |m: &mut FieldOptions| { &mut m.lazy },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "deprecated",
            |m: &FieldOptions| { &m.deprecated },
            |m: &mut FieldOptions| { &mut m.deprecated },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "weak",
            |m: &FieldOptions| { &m.weak },
            |m: &mut FieldOptions| { &mut m.weak },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "uninterpreted_option",
            |m: &FieldOptions| { &m.uninterpreted_option },
            |m: &mut FieldOptions| { &mut m.uninterpreted_option },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<FieldOptions>(
            "FieldOptions",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for FieldOptions {
    const NAME: &'static str = "FieldOptions";

    fn is_initialized(&self) -> bool {
        for v in &self.uninterpreted_option {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ctype = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.packed = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.jstype = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                40 => {
                    self.lazy = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.deprecated = ::std::option::Option::Some(is.read_bool()?);
                },
                80 => {
                    self.weak = ::std::option::Option::Some(is.read_bool()?);
                },
                7994 => {
                    self.uninterpreted_option.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ctype {
            my_size += crate::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.packed {
            my_size += 1 + 1;
        }
        if let Some(v) = self.jstype {
            my_size += crate::rt::int32_size(6, v.value());
        }
        if let Some(v) = self.lazy {
            my_size += 1 + 1;
        }
        if let Some(v) = self.deprecated {
            my_size += 1 + 1;
        }
        if let Some(v) = self.weak {
            my_size += 1 + 1;
        }
        for value in &self.uninterpreted_option {
            let len = value.compute_size();
            my_size += 2 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.ctype {
            os.write_enum(1, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.packed {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.jstype {
            os.write_enum(6, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.lazy {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.deprecated {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.weak {
            os.write_bool(10, v)?;
        }
        for v in &self.uninterpreted_option {
            crate::rt::write_message_field_with_cached_size(999, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FieldOptions {
        FieldOptions::new()
    }

    fn clear(&mut self) {
        self.ctype = ::std::option::Option::None;
        self.packed = ::std::option::Option::None;
        self.jstype = ::std::option::Option::None;
        self.lazy = ::std::option::Option::None;
        self.deprecated = ::std::option::Option::None;
        self.weak = ::std::option::Option::None;
        self.uninterpreted_option.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FieldOptions {
        static instance: FieldOptions = FieldOptions {
            ctype: ::std::option::Option::None,
            packed: ::std::option::Option::None,
            jstype: ::std::option::Option::None,
            lazy: ::std::option::Option::None,
            deprecated: ::std::option::Option::None,
            weak: ::std::option::Option::None,
            uninterpreted_option: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for FieldOptions {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FieldOptions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FieldOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for FieldOptions {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `FieldOptions`
pub mod field_options {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:google.protobuf.FieldOptions.CType)
    pub enum CType {
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldOptions.CType.STRING)
        STRING = 0,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldOptions.CType.CORD)
        CORD = 1,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldOptions.CType.STRING_PIECE)
        STRING_PIECE = 2,
    }

    impl crate::Enum for CType {
        const NAME: &'static str = "CType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<CType> {
            match value {
                0 => ::std::option::Option::Some(CType::STRING),
                1 => ::std::option::Option::Some(CType::CORD),
                2 => ::std::option::Option::Some(CType::STRING_PIECE),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<CType> {
            match str {
                "STRING" => ::std::option::Option::Some(CType::STRING),
                "CORD" => ::std::option::Option::Some(CType::CORD),
                "STRING_PIECE" => ::std::option::Option::Some(CType::STRING_PIECE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [CType] = &[
            CType::STRING,
            CType::CORD,
            CType::STRING_PIECE,
        ];
    }

    impl crate::EnumFull for CType {
        fn enum_descriptor() -> crate::reflect::EnumDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("FieldOptions.CType").unwrap()).clone()
        }

        fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for CType {
        fn default() -> Self {
            CType::STRING
        }
    }

    impl CType {
        pub(in super) fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
            crate::reflect::GeneratedEnumDescriptorData::new::<CType>("FieldOptions.CType")
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:google.protobuf.FieldOptions.JSType)
    pub enum JSType {
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldOptions.JSType.JS_NORMAL)
        JS_NORMAL = 0,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldOptions.JSType.JS_STRING)
        JS_STRING = 1,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldOptions.JSType.JS_NUMBER)
        JS_NUMBER = 2,
    }

    impl crate::Enum for JSType {
        const NAME: &'static str = "JSType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<JSType> {
            match value {
                0 => ::std::option::Option::Some(JSType::JS_NORMAL),
                1 => ::std::option::Option::Some(JSType::JS_STRING),
                2 => ::std::option::Option::Some(JSType::JS_NUMBER),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<JSType> {
            match str {
                "JS_NORMAL" => ::std::option::Option::Some(JSType::JS_NORMAL),
                "JS_STRING" => ::std::option::Option::Some(JSType::JS_STRING),
                "JS_NUMBER" => ::std::option::Option::Some(JSType::JS_NUMBER),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [JSType] = &[
            JSType::JS_NORMAL,
            JSType::JS_STRING,
            JSType::JS_NUMBER,
        ];
    }

    impl crate::EnumFull for JSType {
        fn enum_descriptor() -> crate::reflect::EnumDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("FieldOptions.JSType").unwrap()).clone()
        }

        fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for JSType {
        fn default() -> Self {
            JSType::JS_NORMAL
        }
    }

    impl JSType {
        pub(in super) fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
            crate::reflect::GeneratedEnumDescriptorData::new::<JSType>("FieldOptions.JSType")
        }
    }
}

// @@protoc_insertion_point(message:google.protobuf.OneofOptions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct OneofOptions {
    // message fields
    ///  The parser stores options it doesn't recognize here. See above.
    // @@protoc_insertion_point(field:google.protobuf.OneofOptions.uninterpreted_option)
    pub uninterpreted_option: ::std::vec::Vec<UninterpretedOption>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.OneofOptions.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a OneofOptions {
    fn default() -> &'a OneofOptions {
        <OneofOptions as crate::Message>::default_instance()
    }
}

impl OneofOptions {
    pub fn new() -> OneofOptions {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "uninterpreted_option",
            |m: &OneofOptions| { &m.uninterpreted_option },
            |m: &mut OneofOptions| { &mut m.uninterpreted_option },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<OneofOptions>(
            "OneofOptions",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for OneofOptions {
    const NAME: &'static str = "OneofOptions";

    fn is_initialized(&self) -> bool {
        for v in &self.uninterpreted_option {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                7994 => {
                    self.uninterpreted_option.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.uninterpreted_option {
            let len = value.compute_size();
            my_size += 2 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.uninterpreted_option {
            crate::rt::write_message_field_with_cached_size(999, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> OneofOptions {
        OneofOptions::new()
    }

    fn clear(&mut self) {
        self.uninterpreted_option.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static OneofOptions {
        static instance: OneofOptions = OneofOptions {
            uninterpreted_option: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for OneofOptions {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("OneofOptions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for OneofOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for OneofOptions {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:google.protobuf.EnumOptions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct EnumOptions {
    // message fields
    ///  Set this option to true to allow mapping different tag names to the same
    ///  value.
    // @@protoc_insertion_point(field:google.protobuf.EnumOptions.allow_alias)
    pub allow_alias: ::std::option::Option<bool>,
    ///  Is this enum deprecated?
    ///  Depending on the target platform, this can emit Deprecated annotations
    ///  for the enum, or it will be completely ignored; in the very least, this
    ///  is a formalization for deprecating enums.
    // @@protoc_insertion_point(field:google.protobuf.EnumOptions.deprecated)
    pub deprecated: ::std::option::Option<bool>,
    ///  The parser stores options it doesn't recognize here. See above.
    // @@protoc_insertion_point(field:google.protobuf.EnumOptions.uninterpreted_option)
    pub uninterpreted_option: ::std::vec::Vec<UninterpretedOption>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.EnumOptions.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EnumOptions {
    fn default() -> &'a EnumOptions {
        <EnumOptions as crate::Message>::default_instance()
    }
}

impl EnumOptions {
    pub fn new() -> EnumOptions {
        ::std::default::Default::default()
    }

    // optional bool allow_alias = 2;

    pub fn allow_alias(&self) -> bool {
        self.allow_alias.unwrap_or(false)
    }

    pub fn clear_allow_alias(&mut self) {
        self.allow_alias = ::std::option::Option::None;
    }

    pub fn has_allow_alias(&self) -> bool {
        self.allow_alias.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allow_alias(&mut self, v: bool) {
        self.allow_alias = ::std::option::Option::Some(v);
    }

    // optional bool deprecated = 3;

    pub fn deprecated(&self) -> bool {
        self.deprecated.unwrap_or(false)
    }

    pub fn clear_deprecated(&mut self) {
        self.deprecated = ::std::option::Option::None;
    }

    pub fn has_deprecated(&self) -> bool {
        self.deprecated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deprecated(&mut self, v: bool) {
        self.deprecated = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "allow_alias",
            |m: &EnumOptions| { &m.allow_alias },
            |m: &mut EnumOptions| { &mut m.allow_alias },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "deprecated",
            |m: &EnumOptions| { &m.deprecated },
            |m: &mut EnumOptions| { &mut m.deprecated },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "uninterpreted_option",
            |m: &EnumOptions| { &m.uninterpreted_option },
            |m: &mut EnumOptions| { &mut m.uninterpreted_option },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<EnumOptions>(
            "EnumOptions",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for EnumOptions {
    const NAME: &'static str = "EnumOptions";

    fn is_initialized(&self) -> bool {
        for v in &self.uninterpreted_option {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                16 => {
                    self.allow_alias = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.deprecated = ::std::option::Option::Some(is.read_bool()?);
                },
                7994 => {
                    self.uninterpreted_option.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.allow_alias {
            my_size += 1 + 1;
        }
        if let Some(v) = self.deprecated {
            my_size += 1 + 1;
        }
        for value in &self.uninterpreted_option {
            let len = value.compute_size();
            my_size += 2 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.allow_alias {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.deprecated {
            os.write_bool(3, v)?;
        }
        for v in &self.uninterpreted_option {
            crate::rt::write_message_field_with_cached_size(999, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EnumOptions {
        EnumOptions::new()
    }

    fn clear(&mut self) {
        self.allow_alias = ::std::option::Option::None;
        self.deprecated = ::std::option::Option::None;
        self.uninterpreted_option.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EnumOptions {
        static instance: EnumOptions = EnumOptions {
            allow_alias: ::std::option::Option::None,
            deprecated: ::std::option::Option::None,
            uninterpreted_option: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for EnumOptions {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EnumOptions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EnumOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for EnumOptions {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:google.protobuf.EnumValueOptions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct EnumValueOptions {
    // message fields
    ///  Is this enum value deprecated?
    ///  Depending on the target platform, this can emit Deprecated annotations
    ///  for the enum value, or it will be completely ignored; in the very least,
    ///  this is a formalization for deprecating enum values.
    // @@protoc_insertion_point(field:google.protobuf.EnumValueOptions.deprecated)
    pub deprecated: ::std::option::Option<bool>,
    ///  The parser stores options it doesn't recognize here. See above.
    // @@protoc_insertion_point(field:google.protobuf.EnumValueOptions.uninterpreted_option)
    pub uninterpreted_option: ::std::vec::Vec<UninterpretedOption>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.EnumValueOptions.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EnumValueOptions {
    fn default() -> &'a EnumValueOptions {
        <EnumValueOptions as crate::Message>::default_instance()
    }
}

impl EnumValueOptions {
    pub fn new() -> EnumValueOptions {
        ::std::default::Default::default()
    }

    // optional bool deprecated = 1;

    pub fn deprecated(&self) -> bool {
        self.deprecated.unwrap_or(false)
    }

    pub fn clear_deprecated(&mut self) {
        self.deprecated = ::std::option::Option::None;
    }

    pub fn has_deprecated(&self) -> bool {
        self.deprecated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deprecated(&mut self, v: bool) {
        self.deprecated = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "deprecated",
            |m: &EnumValueOptions| { &m.deprecated },
            |m: &mut EnumValueOptions| { &mut m.deprecated },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "uninterpreted_option",
            |m: &EnumValueOptions| { &m.uninterpreted_option },
            |m: &mut EnumValueOptions| { &mut m.uninterpreted_option },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<EnumValueOptions>(
            "EnumValueOptions",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for EnumValueOptions {
    const NAME: &'static str = "EnumValueOptions";

    fn is_initialized(&self) -> bool {
        for v in &self.uninterpreted_option {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.deprecated = ::std::option::Option::Some(is.read_bool()?);
                },
                7994 => {
                    self.uninterpreted_option.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.deprecated {
            my_size += 1 + 1;
        }
        for value in &self.uninterpreted_option {
            let len = value.compute_size();
            my_size += 2 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.deprecated {
            os.write_bool(1, v)?;
        }
        for v in &self.uninterpreted_option {
            crate::rt::write_message_field_with_cached_size(999, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EnumValueOptions {
        EnumValueOptions::new()
    }

    fn clear(&mut self) {
        self.deprecated = ::std::option::Option::None;
        self.uninterpreted_option.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EnumValueOptions {
        static instance: EnumValueOptions = EnumValueOptions {
            deprecated: ::std::option::Option::None,
            uninterpreted_option: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for EnumValueOptions {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EnumValueOptions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EnumValueOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for EnumValueOptions {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:google.protobuf.ServiceOptions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ServiceOptions {
    // message fields
    ///  Is this service deprecated?
    ///  Depending on the target platform, this can emit Deprecated annotations
    ///  for the service, or it will be completely ignored; in the very least,
    ///  this is a formalization for deprecating services.
    // @@protoc_insertion_point(field:google.protobuf.ServiceOptions.deprecated)
    pub deprecated: ::std::option::Option<bool>,
    ///  The parser stores options it doesn't recognize here. See above.
    // @@protoc_insertion_point(field:google.protobuf.ServiceOptions.uninterpreted_option)
    pub uninterpreted_option: ::std::vec::Vec<UninterpretedOption>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.ServiceOptions.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ServiceOptions {
    fn default() -> &'a ServiceOptions {
        <ServiceOptions as crate::Message>::default_instance()
    }
}

impl ServiceOptions {
    pub fn new() -> ServiceOptions {
        ::std::default::Default::default()
    }

    // optional bool deprecated = 33;

    pub fn deprecated(&self) -> bool {
        self.deprecated.unwrap_or(false)
    }

    pub fn clear_deprecated(&mut self) {
        self.deprecated = ::std::option::Option::None;
    }

    pub fn has_deprecated(&self) -> bool {
        self.deprecated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deprecated(&mut self, v: bool) {
        self.deprecated = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "deprecated",
            |m: &ServiceOptions| { &m.deprecated },
            |m: &mut ServiceOptions| { &mut m.deprecated },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "uninterpreted_option",
            |m: &ServiceOptions| { &m.uninterpreted_option },
            |m: &mut ServiceOptions| { &mut m.uninterpreted_option },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<ServiceOptions>(
            "ServiceOptions",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for ServiceOptions {
    const NAME: &'static str = "ServiceOptions";

    fn is_initialized(&self) -> bool {
        for v in &self.uninterpreted_option {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                264 => {
                    self.deprecated = ::std::option::Option::Some(is.read_bool()?);
                },
                7994 => {
                    self.uninterpreted_option.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.deprecated {
            my_size += 2 + 1;
        }
        for value in &self.uninterpreted_option {
            let len = value.compute_size();
            my_size += 2 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.deprecated {
            os.write_bool(33, v)?;
        }
        for v in &self.uninterpreted_option {
            crate::rt::write_message_field_with_cached_size(999, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ServiceOptions {
        ServiceOptions::new()
    }

    fn clear(&mut self) {
        self.deprecated = ::std::option::Option::None;
        self.uninterpreted_option.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ServiceOptions {
        static instance: ServiceOptions = ServiceOptions {
            deprecated: ::std::option::Option::None,
            uninterpreted_option: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for ServiceOptions {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ServiceOptions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ServiceOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for ServiceOptions {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:google.protobuf.MethodOptions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MethodOptions {
    // message fields
    ///  Is this method deprecated?
    ///  Depending on the target platform, this can emit Deprecated annotations
    ///  for the method, or it will be completely ignored; in the very least,
    ///  this is a formalization for deprecating methods.
    // @@protoc_insertion_point(field:google.protobuf.MethodOptions.deprecated)
    pub deprecated: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:google.protobuf.MethodOptions.idempotency_level)
    pub idempotency_level: ::std::option::Option<crate::EnumOrUnknown<method_options::IdempotencyLevel>>,
    ///  The parser stores options it doesn't recognize here. See above.
    // @@protoc_insertion_point(field:google.protobuf.MethodOptions.uninterpreted_option)
    pub uninterpreted_option: ::std::vec::Vec<UninterpretedOption>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.MethodOptions.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MethodOptions {
    fn default() -> &'a MethodOptions {
        <MethodOptions as crate::Message>::default_instance()
    }
}

impl MethodOptions {
    pub fn new() -> MethodOptions {
        ::std::default::Default::default()
    }

    // optional bool deprecated = 33;

    pub fn deprecated(&self) -> bool {
        self.deprecated.unwrap_or(false)
    }

    pub fn clear_deprecated(&mut self) {
        self.deprecated = ::std::option::Option::None;
    }

    pub fn has_deprecated(&self) -> bool {
        self.deprecated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deprecated(&mut self, v: bool) {
        self.deprecated = ::std::option::Option::Some(v);
    }

    // optional .google.protobuf.MethodOptions.IdempotencyLevel idempotency_level = 34;

    pub fn idempotency_level(&self) -> method_options::IdempotencyLevel {
        match self.idempotency_level {
            Some(e) => e.enum_value_or(method_options::IdempotencyLevel::IDEMPOTENCY_UNKNOWN),
            None => method_options::IdempotencyLevel::IDEMPOTENCY_UNKNOWN,
        }
    }

    pub fn clear_idempotency_level(&mut self) {
        self.idempotency_level = ::std::option::Option::None;
    }

    pub fn has_idempotency_level(&self) -> bool {
        self.idempotency_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_idempotency_level(&mut self, v: method_options::IdempotencyLevel) {
        self.idempotency_level = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "deprecated",
            |m: &MethodOptions| { &m.deprecated },
            |m: &mut MethodOptions| { &mut m.deprecated },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "idempotency_level",
            |m: &MethodOptions| { &m.idempotency_level },
            |m: &mut MethodOptions| { &mut m.idempotency_level },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "uninterpreted_option",
            |m: &MethodOptions| { &m.uninterpreted_option },
            |m: &mut MethodOptions| { &mut m.uninterpreted_option },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<MethodOptions>(
            "MethodOptions",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for MethodOptions {
    const NAME: &'static str = "MethodOptions";

    fn is_initialized(&self) -> bool {
        for v in &self.uninterpreted_option {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                264 => {
                    self.deprecated = ::std::option::Option::Some(is.read_bool()?);
                },
                272 => {
                    self.idempotency_level = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                7994 => {
                    self.uninterpreted_option.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.deprecated {
            my_size += 2 + 1;
        }
        if let Some(v) = self.idempotency_level {
            my_size += crate::rt::int32_size(34, v.value());
        }
        for value in &self.uninterpreted_option {
            let len = value.compute_size();
            my_size += 2 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.deprecated {
            os.write_bool(33, v)?;
        }
        if let Some(v) = self.idempotency_level {
            os.write_enum(34, crate::EnumOrUnknown::value(&v))?;
        }
        for v in &self.uninterpreted_option {
            crate::rt::write_message_field_with_cached_size(999, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MethodOptions {
        MethodOptions::new()
    }

    fn clear(&mut self) {
        self.deprecated = ::std::option::Option::None;
        self.idempotency_level = ::std::option::Option::None;
        self.uninterpreted_option.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MethodOptions {
        static instance: MethodOptions = MethodOptions {
            deprecated: ::std::option::Option::None,
            idempotency_level: ::std::option::Option::None,
            uninterpreted_option: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for MethodOptions {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MethodOptions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MethodOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for MethodOptions {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `MethodOptions`
pub mod method_options {
    ///  Is this method side-effect-free (or safe in HTTP parlance), or idempotent,
    ///  or neither? HTTP based RPC implementation may choose GET verb for safe
    ///  methods, and PUT verb for idempotent methods instead of the default POST.
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:google.protobuf.MethodOptions.IdempotencyLevel)
    pub enum IdempotencyLevel {
        // @@protoc_insertion_point(enum_value:google.protobuf.MethodOptions.IdempotencyLevel.IDEMPOTENCY_UNKNOWN)
        IDEMPOTENCY_UNKNOWN = 0,
        // @@protoc_insertion_point(enum_value:google.protobuf.MethodOptions.IdempotencyLevel.NO_SIDE_EFFECTS)
        NO_SIDE_EFFECTS = 1,
        // @@protoc_insertion_point(enum_value:google.protobuf.MethodOptions.IdempotencyLevel.IDEMPOTENT)
        IDEMPOTENT = 2,
    }

    impl crate::Enum for IdempotencyLevel {
        const NAME: &'static str = "IdempotencyLevel";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<IdempotencyLevel> {
            match value {
                0 => ::std::option::Option::Some(IdempotencyLevel::IDEMPOTENCY_UNKNOWN),
                1 => ::std::option::Option::Some(IdempotencyLevel::NO_SIDE_EFFECTS),
                2 => ::std::option::Option::Some(IdempotencyLevel::IDEMPOTENT),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<IdempotencyLevel> {
            match str {
                "IDEMPOTENCY_UNKNOWN" => ::std::option::Option::Some(IdempotencyLevel::IDEMPOTENCY_UNKNOWN),
                "NO_SIDE_EFFECTS" => ::std::option::Option::Some(IdempotencyLevel::NO_SIDE_EFFECTS),
                "IDEMPOTENT" => ::std::option::Option::Some(IdempotencyLevel::IDEMPOTENT),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [IdempotencyLevel] = &[
            IdempotencyLevel::IDEMPOTENCY_UNKNOWN,
            IdempotencyLevel::NO_SIDE_EFFECTS,
            IdempotencyLevel::IDEMPOTENT,
        ];
    }

    impl crate::EnumFull for IdempotencyLevel {
        fn enum_descriptor() -> crate::reflect::EnumDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("MethodOptions.IdempotencyLevel").unwrap()).clone()
        }

        fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for IdempotencyLevel {
        fn default() -> Self {
            IdempotencyLevel::IDEMPOTENCY_UNKNOWN
        }
    }

    impl IdempotencyLevel {
        pub(in super) fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
            crate::reflect::GeneratedEnumDescriptorData::new::<IdempotencyLevel>("MethodOptions.IdempotencyLevel")
        }
    }
}

///  A message representing a option the parser does not recognize. This only
///  appears in options protos created by the compiler::Parser class.
///  DescriptorPool resolves these when building Descriptor objects. Therefore,
///  options protos in descriptor objects (e.g. returned by Descriptor::options(),
///  or produced by Descriptor::CopyTo()) will never have UninterpretedOptions
///  in them.
// @@protoc_insertion_point(message:google.protobuf.UninterpretedOption)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UninterpretedOption {
    // message fields
    // @@protoc_insertion_point(field:google.protobuf.UninterpretedOption.name)
    pub name: ::std::vec::Vec<uninterpreted_option::NamePart>,
    ///  The value of the uninterpreted option, in whatever type the tokenizer
    ///  identified it as during parsing. Exactly one of these should be set.
    // @@protoc_insertion_point(field:google.protobuf.UninterpretedOption.identifier_value)
    pub identifier_value: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.protobuf.UninterpretedOption.positive_int_value)
    pub positive_int_value: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:google.protobuf.UninterpretedOption.negative_int_value)
    pub negative_int_value: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:google.protobuf.UninterpretedOption.double_value)
    pub double_value: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:google.protobuf.UninterpretedOption.string_value)
    pub string_value: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:google.protobuf.UninterpretedOption.aggregate_value)
    pub aggregate_value: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.UninterpretedOption.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UninterpretedOption {
    fn default() -> &'a UninterpretedOption {
        <UninterpretedOption as crate::Message>::default_instance()
    }
}

impl UninterpretedOption {
    pub fn new() -> UninterpretedOption {
        ::std::default::Default::default()
    }

    // optional string identifier_value = 3;

    pub fn identifier_value(&self) -> &str {
        match self.identifier_value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_identifier_value(&mut self) {
        self.identifier_value = ::std::option::Option::None;
    }

    pub fn has_identifier_value(&self) -> bool {
        self.identifier_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_identifier_value(&mut self, v: ::std::string::String) {
        self.identifier_value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identifier_value(&mut self) -> &mut ::std::string::String {
        if self.identifier_value.is_none() {
            self.identifier_value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.identifier_value.as_mut().unwrap()
    }

    // Take field
    pub fn take_identifier_value(&mut self) -> ::std::string::String {
        self.identifier_value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 positive_int_value = 4;

    pub fn positive_int_value(&self) -> u64 {
        self.positive_int_value.unwrap_or(0)
    }

    pub fn clear_positive_int_value(&mut self) {
        self.positive_int_value = ::std::option::Option::None;
    }

    pub fn has_positive_int_value(&self) -> bool {
        self.positive_int_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_positive_int_value(&mut self, v: u64) {
        self.positive_int_value = ::std::option::Option::Some(v);
    }

    // optional int64 negative_int_value = 5;

    pub fn negative_int_value(&self) -> i64 {
        self.negative_int_value.unwrap_or(0)
    }

    pub fn clear_negative_int_value(&mut self) {
        self.negative_int_value = ::std::option::Option::None;
    }

    pub fn has_negative_int_value(&self) -> bool {
        self.negative_int_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_negative_int_value(&mut self, v: i64) {
        self.negative_int_value = ::std::option::Option::Some(v);
    }

    // optional double double_value = 6;

    pub fn double_value(&self) -> f64 {
        self.double_value.unwrap_or(0.)
    }

    pub fn clear_double_value(&mut self) {
        self.double_value = ::std::option::Option::None;
    }

    pub fn has_double_value(&self) -> bool {
        self.double_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_double_value(&mut self, v: f64) {
        self.double_value = ::std::option::Option::Some(v);
    }

    // optional bytes string_value = 7;

    pub fn string_value(&self) -> &[u8] {
        match self.string_value.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_string_value(&mut self) {
        self.string_value = ::std::option::Option::None;
    }

    pub fn has_string_value(&self) -> bool {
        self.string_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_string_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.string_value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_string_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.string_value.is_none() {
            self.string_value = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.string_value.as_mut().unwrap()
    }

    // Take field
    pub fn take_string_value(&mut self) -> ::std::vec::Vec<u8> {
        self.string_value.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string aggregate_value = 8;

    pub fn aggregate_value(&self) -> &str {
        match self.aggregate_value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_aggregate_value(&mut self) {
        self.aggregate_value = ::std::option::Option::None;
    }

    pub fn has_aggregate_value(&self) -> bool {
        self.aggregate_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_aggregate_value(&mut self, v: ::std::string::String) {
        self.aggregate_value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_aggregate_value(&mut self) -> &mut ::std::string::String {
        if self.aggregate_value.is_none() {
            self.aggregate_value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.aggregate_value.as_mut().unwrap()
    }

    // Take field
    pub fn take_aggregate_value(&mut self) -> ::std::string::String {
        self.aggregate_value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "name",
            |m: &UninterpretedOption| { &m.name },
            |m: &mut UninterpretedOption| { &mut m.name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "identifier_value",
            |m: &UninterpretedOption| { &m.identifier_value },
            |m: &mut UninterpretedOption| { &mut m.identifier_value },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "positive_int_value",
            |m: &UninterpretedOption| { &m.positive_int_value },
            |m: &mut UninterpretedOption| { &mut m.positive_int_value },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "negative_int_value",
            |m: &UninterpretedOption| { &m.negative_int_value },
            |m: &mut UninterpretedOption| { &mut m.negative_int_value },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "double_value",
            |m: &UninterpretedOption| { &m.double_value },
            |m: &mut UninterpretedOption| { &mut m.double_value },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "string_value",
            |m: &UninterpretedOption| { &m.string_value },
            |m: &mut UninterpretedOption| { &mut m.string_value },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "aggregate_value",
            |m: &UninterpretedOption| { &m.aggregate_value },
            |m: &mut UninterpretedOption| { &mut m.aggregate_value },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<UninterpretedOption>(
            "UninterpretedOption",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for UninterpretedOption {
    const NAME: &'static str = "UninterpretedOption";

    fn is_initialized(&self) -> bool {
        for v in &self.name {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    self.name.push(is.read_message()?);
                },
                26 => {
                    self.identifier_value = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.positive_int_value = ::std::option::Option::Some(is.read_uint64()?);
                },
                40 => {
                    self.negative_int_value = ::std::option::Option::Some(is.read_int64()?);
                },
                49 => {
                    self.double_value = ::std::option::Option::Some(is.read_double()?);
                },
                58 => {
                    self.string_value = ::std::option::Option::Some(is.read_bytes()?);
                },
                66 => {
                    self.aggregate_value = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.name {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.identifier_value.as_ref() {
            my_size += crate::rt::string_size(3, &v);
        }
        if let Some(v) = self.positive_int_value {
            my_size += crate::rt::uint64_size(4, v);
        }
        if let Some(v) = self.negative_int_value {
            my_size += crate::rt::int64_size(5, v);
        }
        if let Some(v) = self.double_value {
            my_size += 1 + 8;
        }
        if let Some(v) = self.string_value.as_ref() {
            my_size += crate::rt::bytes_size(7, &v);
        }
        if let Some(v) = self.aggregate_value.as_ref() {
            my_size += crate::rt::string_size(8, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.name {
            crate::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.identifier_value.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.positive_int_value {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.negative_int_value {
            os.write_int64(5, v)?;
        }
        if let Some(v) = self.double_value {
            os.write_double(6, v)?;
        }
        if let Some(v) = self.string_value.as_ref() {
            os.write_bytes(7, v)?;
        }
        if let Some(v) = self.aggregate_value.as_ref() {
            os.write_string(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UninterpretedOption {
        UninterpretedOption::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.identifier_value = ::std::option::Option::None;
        self.positive_int_value = ::std::option::Option::None;
        self.negative_int_value = ::std::option::Option::None;
        self.double_value = ::std::option::Option::None;
        self.string_value = ::std::option::Option::None;
        self.aggregate_value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UninterpretedOption {
        static instance: UninterpretedOption = UninterpretedOption {
            name: ::std::vec::Vec::new(),
            identifier_value: ::std::option::Option::None,
            positive_int_value: ::std::option::Option::None,
            negative_int_value: ::std::option::Option::None,
            double_value: ::std::option::Option::None,
            string_value: ::std::option::Option::None,
            aggregate_value: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for UninterpretedOption {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UninterpretedOption").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UninterpretedOption {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for UninterpretedOption {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `UninterpretedOption`
pub mod uninterpreted_option {
    ///  The name of the uninterpreted option.  Each string represents a segment in
    ///  a dot-separated name.  is_extension is true iff a segment represents an
    ///  extension (denoted with parentheses in options specs in .proto files).
    ///  E.g.,{ ["foo", false], ["bar.baz", true], ["qux", false] } represents
    ///  "foo.(bar.baz).qux".
    // @@protoc_insertion_point(message:google.protobuf.UninterpretedOption.NamePart)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct NamePart {
        // message fields
        // @@protoc_insertion_point(field:google.protobuf.UninterpretedOption.NamePart.name_part)
        pub name_part: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:google.protobuf.UninterpretedOption.NamePart.is_extension)
        pub is_extension: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:google.protobuf.UninterpretedOption.NamePart.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a NamePart {
        fn default() -> &'a NamePart {
            <NamePart as crate::Message>::default_instance()
        }
    }

    impl NamePart {
        pub fn new() -> NamePart {
            ::std::default::Default::default()
        }

        // required string name_part = 1;

        pub fn name_part(&self) -> &str {
            match self.name_part.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name_part(&mut self) {
            self.name_part = ::std::option::Option::None;
        }

        pub fn has_name_part(&self) -> bool {
            self.name_part.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name_part(&mut self, v: ::std::string::String) {
            self.name_part = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name_part(&mut self) -> &mut ::std::string::String {
            if self.name_part.is_none() {
                self.name_part = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name_part.as_mut().unwrap()
        }

        // Take field
        pub fn take_name_part(&mut self) -> ::std::string::String {
            self.name_part.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // required bool is_extension = 2;

        pub fn is_extension(&self) -> bool {
            self.is_extension.unwrap_or(false)
        }

        pub fn clear_is_extension(&mut self) {
            self.is_extension = ::std::option::Option::None;
        }

        pub fn has_is_extension(&self) -> bool {
            self.is_extension.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_extension(&mut self, v: bool) {
            self.is_extension = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "name_part",
                |m: &NamePart| { &m.name_part },
                |m: &mut NamePart| { &mut m.name_part },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "is_extension",
                |m: &NamePart| { &m.is_extension },
                |m: &mut NamePart| { &mut m.is_extension },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<NamePart>(
                "UninterpretedOption.NamePart",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for NamePart {
        const NAME: &'static str = "NamePart";

        fn is_initialized(&self) -> bool {
            if self.name_part.is_none() {
                return false;
            }
            if self.is_extension.is_none() {
                return false;
            }
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name_part = ::std::option::Option::Some(is.read_string()?);
                    },
                    16 => {
                        self.is_extension = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.name_part.as_ref() {
                my_size += crate::rt::string_size(1, &v);
            }
            if let Some(v) = self.is_extension {
                my_size += 1 + 1;
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.name_part.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.is_extension {
                os.write_bool(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> NamePart {
            NamePart::new()
        }

        fn clear(&mut self) {
            self.name_part = ::std::option::Option::None;
            self.is_extension = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static NamePart {
            static instance: NamePart = NamePart {
                name_part: ::std::option::Option::None,
                is_extension: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for NamePart {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("UninterpretedOption.NamePart").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for NamePart {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for NamePart {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

///  Encapsulates information about the original source file from which a
///  FileDescriptorProto was generated.
// @@protoc_insertion_point(message:google.protobuf.SourceCodeInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SourceCodeInfo {
    // message fields
    // @@protoc_insertion_point(field:google.protobuf.SourceCodeInfo.location)
    pub location: ::std::vec::Vec<source_code_info::Location>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.SourceCodeInfo.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SourceCodeInfo {
    fn default() -> &'a SourceCodeInfo {
        <SourceCodeInfo as crate::Message>::default_instance()
    }
}

impl SourceCodeInfo {
    pub fn new() -> SourceCodeInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "location",
            |m: &SourceCodeInfo| { &m.location },
            |m: &mut SourceCodeInfo| { &mut m.location },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<SourceCodeInfo>(
            "SourceCodeInfo",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for SourceCodeInfo {
    const NAME: &'static str = "SourceCodeInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.location.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.location {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.location {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SourceCodeInfo {
        SourceCodeInfo::new()
    }

    fn clear(&mut self) {
        self.location.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SourceCodeInfo {
        static instance: SourceCodeInfo = SourceCodeInfo {
            location: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for SourceCodeInfo {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SourceCodeInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SourceCodeInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for SourceCodeInfo {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `SourceCodeInfo`
pub mod source_code_info {
    // @@protoc_insertion_point(message:google.protobuf.SourceCodeInfo.Location)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Location {
        // message fields
        // @@protoc_insertion_point(field:google.protobuf.SourceCodeInfo.Location.path)
        pub path: ::std::vec::Vec<i32>,
        ///  Always has exactly three or four elements: start line, start column,
        ///  end line (optional, otherwise assumed same as start line), end column.
        ///  These are packed into a single field for efficiency.  Note that line
        ///  and column numbers are zero-based -- typically you will want to add
        ///  1 to each before displaying to a user.
        // @@protoc_insertion_point(field:google.protobuf.SourceCodeInfo.Location.span)
        pub span: ::std::vec::Vec<i32>,
        // @@protoc_insertion_point(field:google.protobuf.SourceCodeInfo.Location.leading_comments)
        pub leading_comments: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:google.protobuf.SourceCodeInfo.Location.trailing_comments)
        pub trailing_comments: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:google.protobuf.SourceCodeInfo.Location.leading_detached_comments)
        pub leading_detached_comments: ::std::vec::Vec<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:google.protobuf.SourceCodeInfo.Location.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Location {
        fn default() -> &'a Location {
            <Location as crate::Message>::default_instance()
        }
    }

    impl Location {
        pub fn new() -> Location {
            ::std::default::Default::default()
        }

        // optional string leading_comments = 3;

        pub fn leading_comments(&self) -> &str {
            match self.leading_comments.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_leading_comments(&mut self) {
            self.leading_comments = ::std::option::Option::None;
        }

        pub fn has_leading_comments(&self) -> bool {
            self.leading_comments.is_some()
        }

        // Param is passed by value, moved
        pub fn set_leading_comments(&mut self, v: ::std::string::String) {
            self.leading_comments = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_leading_comments(&mut self) -> &mut ::std::string::String {
            if self.leading_comments.is_none() {
                self.leading_comments = ::std::option::Option::Some(::std::string::String::new());
            }
            self.leading_comments.as_mut().unwrap()
        }

        // Take field
        pub fn take_leading_comments(&mut self) -> ::std::string::String {
            self.leading_comments.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string trailing_comments = 4;

        pub fn trailing_comments(&self) -> &str {
            match self.trailing_comments.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_trailing_comments(&mut self) {
            self.trailing_comments = ::std::option::Option::None;
        }

        pub fn has_trailing_comments(&self) -> bool {
            self.trailing_comments.is_some()
        }

        // Param is passed by value, moved
        pub fn set_trailing_comments(&mut self, v: ::std::string::String) {
            self.trailing_comments = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_trailing_comments(&mut self) -> &mut ::std::string::String {
            if self.trailing_comments.is_none() {
                self.trailing_comments = ::std::option::Option::Some(::std::string::String::new());
            }
            self.trailing_comments.as_mut().unwrap()
        }

        // Take field
        pub fn take_trailing_comments(&mut self) -> ::std::string::String {
            self.trailing_comments.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "path",
                |m: &Location| { &m.path },
                |m: &mut Location| { &mut m.path },
            ));
            fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "span",
                |m: &Location| { &m.span },
                |m: &mut Location| { &mut m.span },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "leading_comments",
                |m: &Location| { &m.leading_comments },
                |m: &mut Location| { &mut m.leading_comments },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "trailing_comments",
                |m: &Location| { &m.trailing_comments },
                |m: &mut Location| { &mut m.trailing_comments },
            ));
            fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "leading_detached_comments",
                |m: &Location| { &m.leading_detached_comments },
                |m: &mut Location| { &mut m.leading_detached_comments },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<Location>(
                "SourceCodeInfo.Location",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for Location {
        const NAME: &'static str = "Location";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        is.read_repeated_packed_int32_into(&mut self.path)?;
                    },
                    8 => {
                        self.path.push(is.read_int32()?);
                    },
                    18 => {
                        is.read_repeated_packed_int32_into(&mut self.span)?;
                    },
                    16 => {
                        self.span.push(is.read_int32()?);
                    },
                    26 => {
                        self.leading_comments = ::std::option::Option::Some(is.read_string()?);
                    },
                    34 => {
                        self.trailing_comments = ::std::option::Option::Some(is.read_string()?);
                    },
                    50 => {
                        self.leading_detached_comments.push(is.read_string()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += crate::rt::vec_packed_int32_size(1, &self.path);
            my_size += crate::rt::vec_packed_int32_size(2, &self.span);
            if let Some(v) = self.leading_comments.as_ref() {
                my_size += crate::rt::string_size(3, &v);
            }
            if let Some(v) = self.trailing_comments.as_ref() {
                my_size += crate::rt::string_size(4, &v);
            }
            for value in &self.leading_detached_comments {
                my_size += crate::rt::string_size(6, &value);
            };
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            os.write_repeated_packed_int32(1, &self.path)?;
            os.write_repeated_packed_int32(2, &self.span)?;
            if let Some(v) = self.leading_comments.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.trailing_comments.as_ref() {
                os.write_string(4, v)?;
            }
            for v in &self.leading_detached_comments {
                os.write_string(6, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Location {
            Location::new()
        }

        fn clear(&mut self) {
            self.path.clear();
            self.span.clear();
            self.leading_comments = ::std::option::Option::None;
            self.trailing_comments = ::std::option::Option::None;
            self.leading_detached_comments.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Location {
            static instance: Location = Location {
                path: ::std::vec::Vec::new(),
                span: ::std::vec::Vec::new(),
                leading_comments: ::std::option::Option::None,
                trailing_comments: ::std::option::Option::None,
                leading_detached_comments: ::std::vec::Vec::new(),
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for Location {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("SourceCodeInfo.Location").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Location {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for Location {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

///  Describes the relationship between generated code and its original source
///  file. A GeneratedCodeInfo message is associated with only one generated
///  source file, but may contain references to different source .proto files.
// @@protoc_insertion_point(message:google.protobuf.GeneratedCodeInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GeneratedCodeInfo {
    // message fields
    ///  An Annotation connects some span of text in generated code to an element
    ///  of its generating .proto file.
    // @@protoc_insertion_point(field:google.protobuf.GeneratedCodeInfo.annotation)
    pub annotation: ::std::vec::Vec<generated_code_info::Annotation>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.GeneratedCodeInfo.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GeneratedCodeInfo {
    fn default() -> &'a GeneratedCodeInfo {
        <GeneratedCodeInfo as crate::Message>::default_instance()
    }
}

impl GeneratedCodeInfo {
    pub fn new() -> GeneratedCodeInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "annotation",
            |m: &GeneratedCodeInfo| { &m.annotation },
            |m: &mut GeneratedCodeInfo| { &mut m.annotation },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<GeneratedCodeInfo>(
            "GeneratedCodeInfo",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for GeneratedCodeInfo {
    const NAME: &'static str = "GeneratedCodeInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.annotation.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.annotation {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.annotation {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GeneratedCodeInfo {
        GeneratedCodeInfo::new()
    }

    fn clear(&mut self) {
        self.annotation.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GeneratedCodeInfo {
        static instance: GeneratedCodeInfo = GeneratedCodeInfo {
            annotation: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for GeneratedCodeInfo {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GeneratedCodeInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GeneratedCodeInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for GeneratedCodeInfo {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `GeneratedCodeInfo`
pub mod generated_code_info {
    // @@protoc_insertion_point(message:google.protobuf.GeneratedCodeInfo.Annotation)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Annotation {
        // message fields
        ///  Identifies the element in the original source .proto file. This field
        ///  is formatted the same as SourceCodeInfo.Location.path.
        // @@protoc_insertion_point(field:google.protobuf.GeneratedCodeInfo.Annotation.path)
        pub path: ::std::vec::Vec<i32>,
        ///  Identifies the filesystem path to the original source .proto.
        // @@protoc_insertion_point(field:google.protobuf.GeneratedCodeInfo.Annotation.source_file)
        pub source_file: ::std::option::Option<::std::string::String>,
        ///  Identifies the starting offset in bytes in the generated code
        ///  that relates to the identified object.
        // @@protoc_insertion_point(field:google.protobuf.GeneratedCodeInfo.Annotation.begin)
        pub begin: ::std::option::Option<i32>,
        ///  Identifies the ending offset in bytes in the generated code that
        ///  relates to the identified offset. The end offset should be one past
        ///  the last relevant byte (so the length of the text = end - begin).
        // @@protoc_insertion_point(field:google.protobuf.GeneratedCodeInfo.Annotation.end)
        pub end: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:google.protobuf.GeneratedCodeInfo.Annotation.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Annotation {
        fn default() -> &'a Annotation {
            <Annotation as crate::Message>::default_instance()
        }
    }

    impl Annotation {
        pub fn new() -> Annotation {
            ::std::default::Default::default()
        }

        // optional string source_file = 2;

        pub fn source_file(&self) -> &str {
            match self.source_file.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_source_file(&mut self) {
            self.source_file = ::std::option::Option::None;
        }

        pub fn has_source_file(&self) -> bool {
            self.source_file.is_some()
        }

        // Param is passed by value, moved
        pub fn set_source_file(&mut self, v: ::std::string::String) {
            self.source_file = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_source_file(&mut self) -> &mut ::std::string::String {
            if self.source_file.is_none() {
                self.source_file = ::std::option::Option::Some(::std::string::String::new());
            }
            self.source_file.as_mut().unwrap()
        }

        // Take field
        pub fn take_source_file(&mut self) -> ::std::string::String {
            self.source_file.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional int32 begin = 3;

        pub fn begin(&self) -> i32 {
            self.begin.unwrap_or(0)
        }

        pub fn clear_begin(&mut self) {
            self.begin = ::std::option::Option::None;
        }

        pub fn has_begin(&self) -> bool {
            self.begin.is_some()
        }

        // Param is passed by value, moved
        pub fn set_begin(&mut self, v: i32) {
            self.begin = ::std::option::Option::Some(v);
        }

        // optional int32 end = 4;

        pub fn end(&self) -> i32 {
            self.end.unwrap_or(0)
        }

        pub fn clear_end(&mut self) {
            self.end = ::std::option::Option::None;
        }

        pub fn has_end(&self) -> bool {
            self.end.is_some()
        }

        // Param is passed by value, moved
        pub fn set_end(&mut self, v: i32) {
            self.end = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "path",
                |m: &Annotation| { &m.path },
                |m: &mut Annotation| { &mut m.path },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "source_file",
                |m: &Annotation| { &m.source_file },
                |m: &mut Annotation| { &mut m.source_file },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "begin",
                |m: &Annotation| { &m.begin },
                |m: &mut Annotation| { &mut m.begin },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "end",
                |m: &Annotation| { &m.end },
                |m: &mut Annotation| { &mut m.end },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<Annotation>(
                "GeneratedCodeInfo.Annotation",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for Annotation {
        const NAME: &'static str = "Annotation";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        is.read_repeated_packed_int32_into(&mut self.path)?;
                    },
                    8 => {
                        self.path.push(is.read_int32()?);
                    },
                    18 => {
                        self.source_file = ::std::option::Option::Some(is.read_string()?);
                    },
                    24 => {
                        self.begin = ::std::option::Option::Some(is.read_int32()?);
                    },
                    32 => {
                        self.end = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += crate::rt::vec_packed_int32_size(1, &self.path);
            if let Some(v) = self.source_file.as_ref() {
                my_size += crate::rt::string_size(2, &v);
            }
            if let Some(v) = self.begin {
                my_size += crate::rt::int32_size(3, v);
            }
            if let Some(v) = self.end {
                my_size += crate::rt::int32_size(4, v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            os.write_repeated_packed_int32(1, &self.path)?;
            if let Some(v) = self.source_file.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.begin {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.end {
                os.write_int32(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Annotation {
            Annotation::new()
        }

        fn clear(&mut self) {
            self.path.clear();
            self.source_file = ::std::option::Option::None;
            self.begin = ::std::option::Option::None;
            self.end = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Annotation {
            static instance: Annotation = Annotation {
                path: ::std::vec::Vec::new(),
                source_file: ::std::option::Option::None,
                begin: ::std::option::Option::None,
                end: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for Annotation {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("GeneratedCodeInfo.Annotation").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Annotation {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for Annotation {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x20google/protobuf/descriptor.proto\x12\x0fgoogle.protobuf\"M\n\x11Fi\
    leDescriptorSet\x128\n\x04file\x18\x01\x20\x03(\x0b2$.google.protobuf.Fi\
    leDescriptorProtoR\x04file\"\xe4\x04\n\x13FileDescriptorProto\x12\x12\n\
    \x04name\x18\x01\x20\x01(\tR\x04name\x12\x18\n\x07package\x18\x02\x20\
    \x01(\tR\x07package\x12\x1e\n\ndependency\x18\x03\x20\x03(\tR\ndependenc\
    y\x12+\n\x11public_dependency\x18\n\x20\x03(\x05R\x10publicDependency\
    \x12'\n\x0fweak_dependency\x18\x0b\x20\x03(\x05R\x0eweakDependency\x12C\
    \n\x0cmessage_type\x18\x04\x20\x03(\x0b2\x20.google.protobuf.DescriptorP\
    rotoR\x0bmessageType\x12A\n\tenum_type\x18\x05\x20\x03(\x0b2$.google.pro\
    tobuf.EnumDescriptorProtoR\x08enumType\x12A\n\x07service\x18\x06\x20\x03\
    (\x0b2'.google.protobuf.ServiceDescriptorProtoR\x07service\x12C\n\texten\
    sion\x18\x07\x20\x03(\x0b2%.google.protobuf.FieldDescriptorProtoR\texten\
    sion\x126\n\x07options\x18\x08\x20\x01(\x0b2\x1c.google.protobuf.FileOpt\
    ionsR\x07options\x12I\n\x10source_code_info\x18\t\x20\x01(\x0b2\x1f.goog\
    le.protobuf.SourceCodeInfoR\x0esourceCodeInfo\x12\x16\n\x06syntax\x18\
    \x0c\x20\x01(\tR\x06syntax\"\xb9\x06\n\x0fDescriptorProto\x12\x12\n\x04n\
    ame\x18\x01\x20\x01(\tR\x04name\x12;\n\x05field\x18\x02\x20\x03(\x0b2%.g\
    oogle.protobuf.FieldDescriptorProtoR\x05field\x12C\n\textension\x18\x06\
    \x20\x03(\x0b2%.google.protobuf.FieldDescriptorProtoR\textension\x12A\n\
    \x0bnested_type\x18\x03\x20\x03(\x0b2\x20.google.protobuf.DescriptorProt\
    oR\nnestedType\x12A\n\tenum_type\x18\x04\x20\x03(\x0b2$.google.protobuf.\
    EnumDescriptorProtoR\x08enumType\x12X\n\x0fextension_range\x18\x05\x20\
    \x03(\x0b2/.google.protobuf.DescriptorProto.ExtensionRangeR\x0eextension\
    Range\x12D\n\noneof_decl\x18\x08\x20\x03(\x0b2%.google.protobuf.OneofDes\
    criptorProtoR\toneofDecl\x129\n\x07options\x18\x07\x20\x01(\x0b2\x1f.goo\
    gle.protobuf.MessageOptionsR\x07options\x12U\n\x0ereserved_range\x18\t\
    \x20\x03(\x0b2..google.protobuf.DescriptorProto.ReservedRangeR\rreserved\
    Range\x12#\n\rreserved_name\x18\n\x20\x03(\tR\x0creservedName\x1az\n\x0e\
    ExtensionRange\x12\x14\n\x05start\x18\x01\x20\x01(\x05R\x05start\x12\x10\
    \n\x03end\x18\x02\x20\x01(\x05R\x03end\x12@\n\x07options\x18\x03\x20\x01\
    (\x0b2&.google.protobuf.ExtensionRangeOptionsR\x07options\x1a7\n\rReserv\
    edRange\x12\x14\n\x05start\x18\x01\x20\x01(\x05R\x05start\x12\x10\n\x03e\
    nd\x18\x02\x20\x01(\x05R\x03end\"|\n\x15ExtensionRangeOptions\x12X\n\x14\
    uninterpreted_option\x18\xe7\x07\x20\x03(\x0b2$.google.protobuf.Uninterp\
    retedOptionR\x13uninterpretedOption*\t\x08\xe8\x07\x10\x80\x80\x80\x80\
    \x02\"\xc1\x06\n\x14FieldDescriptorProto\x12\x12\n\x04name\x18\x01\x20\
    \x01(\tR\x04name\x12\x16\n\x06number\x18\x03\x20\x01(\x05R\x06number\x12\
    A\n\x05label\x18\x04\x20\x01(\x0e2+.google.protobuf.FieldDescriptorProto\
    .LabelR\x05label\x12>\n\x04type\x18\x05\x20\x01(\x0e2*.google.protobuf.F\
    ieldDescriptorProto.TypeR\x04type\x12\x1b\n\ttype_name\x18\x06\x20\x01(\
    \tR\x08typeName\x12\x1a\n\x08extendee\x18\x02\x20\x01(\tR\x08extendee\
    \x12#\n\rdefault_value\x18\x07\x20\x01(\tR\x0cdefaultValue\x12\x1f\n\x0b\
    oneof_index\x18\t\x20\x01(\x05R\noneofIndex\x12\x1b\n\tjson_name\x18\n\
    \x20\x01(\tR\x08jsonName\x127\n\x07options\x18\x08\x20\x01(\x0b2\x1d.goo\
    gle.protobuf.FieldOptionsR\x07options\x12'\n\x0fproto3_optional\x18\x11\
    \x20\x01(\x08R\x0eproto3Optional\"\xb6\x02\n\x04Type\x12\x0f\n\x0bTYPE_D\
    OUBLE\x10\x01\x12\x0e\n\nTYPE_FLOAT\x10\x02\x12\x0e\n\nTYPE_INT64\x10\
    \x03\x12\x0f\n\x0bTYPE_UINT64\x10\x04\x12\x0e\n\nTYPE_INT32\x10\x05\x12\
    \x10\n\x0cTYPE_FIXED64\x10\x06\x12\x10\n\x0cTYPE_FIXED32\x10\x07\x12\r\n\
    \tTYPE_BOOL\x10\x08\x12\x0f\n\x0bTYPE_STRING\x10\t\x12\x0e\n\nTYPE_GROUP\
    \x10\n\x12\x10\n\x0cTYPE_MESSAGE\x10\x0b\x12\x0e\n\nTYPE_BYTES\x10\x0c\
    \x12\x0f\n\x0bTYPE_UINT32\x10\r\x12\r\n\tTYPE_ENUM\x10\x0e\x12\x11\n\rTY\
    PE_SFIXED32\x10\x0f\x12\x11\n\rTYPE_SFIXED64\x10\x10\x12\x0f\n\x0bTYPE_S\
    INT32\x10\x11\x12\x0f\n\x0bTYPE_SINT64\x10\x12\"C\n\x05Label\x12\x12\n\
    \x0eLABEL_OPTIONAL\x10\x01\x12\x12\n\x0eLABEL_REQUIRED\x10\x02\x12\x12\n\
    \x0eLABEL_REPEATED\x10\x03\"c\n\x14OneofDescriptorProto\x12\x12\n\x04nam\
    e\x18\x01\x20\x01(\tR\x04name\x127\n\x07options\x18\x02\x20\x01(\x0b2\
    \x1d.google.protobuf.OneofOptionsR\x07options\"\xe3\x02\n\x13EnumDescrip\
    torProto\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12?\n\x05value\
    \x18\x02\x20\x03(\x0b2).google.protobuf.EnumValueDescriptorProtoR\x05val\
    ue\x126\n\x07options\x18\x03\x20\x01(\x0b2\x1c.google.protobuf.EnumOptio\
    nsR\x07options\x12]\n\x0ereserved_range\x18\x04\x20\x03(\x0b26.google.pr\
    otobuf.EnumDescriptorProto.EnumReservedRangeR\rreservedRange\x12#\n\rres\
    erved_name\x18\x05\x20\x03(\tR\x0creservedName\x1a;\n\x11EnumReservedRan\
    ge\x12\x14\n\x05start\x18\x01\x20\x01(\x05R\x05start\x12\x10\n\x03end\
    \x18\x02\x20\x01(\x05R\x03end\"\x83\x01\n\x18EnumValueDescriptorProto\
    \x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x16\n\x06number\x18\
    \x02\x20\x01(\x05R\x06number\x12;\n\x07options\x18\x03\x20\x01(\x0b2!.go\
    ogle.protobuf.EnumValueOptionsR\x07options\"\xa7\x01\n\x16ServiceDescrip\
    torProto\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12>\n\x06method\
    \x18\x02\x20\x03(\x0b2&.google.protobuf.MethodDescriptorProtoR\x06method\
    \x129\n\x07options\x18\x03\x20\x01(\x0b2\x1f.google.protobuf.ServiceOpti\
    onsR\x07options\"\x89\x02\n\x15MethodDescriptorProto\x12\x12\n\x04name\
    \x18\x01\x20\x01(\tR\x04name\x12\x1d\n\ninput_type\x18\x02\x20\x01(\tR\t\
    inputType\x12\x1f\n\x0boutput_type\x18\x03\x20\x01(\tR\noutputType\x128\
    \n\x07options\x18\x04\x20\x01(\x0b2\x1e.google.protobuf.MethodOptionsR\
    \x07options\x120\n\x10client_streaming\x18\x05\x20\x01(\x08:\x05falseR\
    \x0fclientStreaming\x120\n\x10server_streaming\x18\x06\x20\x01(\x08:\x05\
    falseR\x0fserverStreaming\"\x91\t\n\x0bFileOptions\x12!\n\x0cjava_packag\
    e\x18\x01\x20\x01(\tR\x0bjavaPackage\x120\n\x14java_outer_classname\x18\
    \x08\x20\x01(\tR\x12javaOuterClassname\x125\n\x13java_multiple_files\x18\
    \n\x20\x01(\x08:\x05falseR\x11javaMultipleFiles\x12D\n\x1djava_generate_\
    equals_and_hash\x18\x14\x20\x01(\x08R\x19javaGenerateEqualsAndHashB\x02\
    \x18\x01\x12:\n\x16java_string_check_utf8\x18\x1b\x20\x01(\x08:\x05false\
    R\x13javaStringCheckUtf8\x12S\n\x0coptimize_for\x18\t\x20\x01(\x0e2).goo\
    gle.protobuf.FileOptions.OptimizeMode:\x05SPEEDR\x0boptimizeFor\x12\x1d\
    \n\ngo_package\x18\x0b\x20\x01(\tR\tgoPackage\x125\n\x13cc_generic_servi\
    ces\x18\x10\x20\x01(\x08:\x05falseR\x11ccGenericServices\x129\n\x15java_\
    generic_services\x18\x11\x20\x01(\x08:\x05falseR\x13javaGenericServices\
    \x125\n\x13py_generic_services\x18\x12\x20\x01(\x08:\x05falseR\x11pyGene\
    ricServices\x127\n\x14php_generic_services\x18*\x20\x01(\x08:\x05falseR\
    \x12phpGenericServices\x12%\n\ndeprecated\x18\x17\x20\x01(\x08:\x05false\
    R\ndeprecated\x12.\n\x10cc_enable_arenas\x18\x1f\x20\x01(\x08:\x04trueR\
    \x0eccEnableArenas\x12*\n\x11objc_class_prefix\x18$\x20\x01(\tR\x0fobjcC\
    lassPrefix\x12)\n\x10csharp_namespace\x18%\x20\x01(\tR\x0fcsharpNamespac\
    e\x12!\n\x0cswift_prefix\x18'\x20\x01(\tR\x0bswiftPrefix\x12(\n\x10php_c\
    lass_prefix\x18(\x20\x01(\tR\x0ephpClassPrefix\x12#\n\rphp_namespace\x18\
    )\x20\x01(\tR\x0cphpNamespace\x124\n\x16php_metadata_namespace\x18,\x20\
    \x01(\tR\x14phpMetadataNamespace\x12!\n\x0cruby_package\x18-\x20\x01(\tR\
    \x0brubyPackage\x12X\n\x14uninterpreted_option\x18\xe7\x07\x20\x03(\x0b2\
    $.google.protobuf.UninterpretedOptionR\x13uninterpretedOption\":\n\x0cOp\
    timizeMode\x12\t\n\x05SPEED\x10\x01\x12\r\n\tCODE_SIZE\x10\x02\x12\x10\n\
    \x0cLITE_RUNTIME\x10\x03*\t\x08\xe8\x07\x10\x80\x80\x80\x80\x02J\x04\x08\
    &\x10'\"\xe3\x02\n\x0eMessageOptions\x12<\n\x17message_set_wire_format\
    \x18\x01\x20\x01(\x08:\x05falseR\x14messageSetWireFormat\x12L\n\x1fno_st\
    andard_descriptor_accessor\x18\x02\x20\x01(\x08:\x05falseR\x1cnoStandard\
    DescriptorAccessor\x12%\n\ndeprecated\x18\x03\x20\x01(\x08:\x05falseR\nd\
    eprecated\x12\x1b\n\tmap_entry\x18\x07\x20\x01(\x08R\x08mapEntry\x12X\n\
    \x14uninterpreted_option\x18\xe7\x07\x20\x03(\x0b2$.google.protobuf.Unin\
    terpretedOptionR\x13uninterpretedOption*\t\x08\xe8\x07\x10\x80\x80\x80\
    \x80\x02J\x04\x08\x04\x10\x05J\x04\x08\x05\x10\x06J\x04\x08\x06\x10\x07J\
    \x04\x08\x08\x10\tJ\x04\x08\t\x10\n\"\xe2\x03\n\x0cFieldOptions\x12A\n\
    \x05ctype\x18\x01\x20\x01(\x0e2#.google.protobuf.FieldOptions.CType:\x06\
    STRINGR\x05ctype\x12\x16\n\x06packed\x18\x02\x20\x01(\x08R\x06packed\x12\
    G\n\x06jstype\x18\x06\x20\x01(\x0e2$.google.protobuf.FieldOptions.JSType\
    :\tJS_NORMALR\x06jstype\x12\x19\n\x04lazy\x18\x05\x20\x01(\x08:\x05false\
    R\x04lazy\x12%\n\ndeprecated\x18\x03\x20\x01(\x08:\x05falseR\ndeprecated\
    \x12\x19\n\x04weak\x18\n\x20\x01(\x08:\x05falseR\x04weak\x12X\n\x14unint\
    erpreted_option\x18\xe7\x07\x20\x03(\x0b2$.google.protobuf.Uninterpreted\
    OptionR\x13uninterpretedOption\"/\n\x05CType\x12\n\n\x06STRING\x10\0\x12\
    \x08\n\x04CORD\x10\x01\x12\x10\n\x0cSTRING_PIECE\x10\x02\"5\n\x06JSType\
    \x12\r\n\tJS_NORMAL\x10\0\x12\r\n\tJS_STRING\x10\x01\x12\r\n\tJS_NUMBER\
    \x10\x02*\t\x08\xe8\x07\x10\x80\x80\x80\x80\x02J\x04\x08\x04\x10\x05\"s\
    \n\x0cOneofOptions\x12X\n\x14uninterpreted_option\x18\xe7\x07\x20\x03(\
    \x0b2$.google.protobuf.UninterpretedOptionR\x13uninterpretedOption*\t\
    \x08\xe8\x07\x10\x80\x80\x80\x80\x02\"\xc0\x01\n\x0bEnumOptions\x12\x1f\
    \n\x0ballow_alias\x18\x02\x20\x01(\x08R\nallowAlias\x12%\n\ndeprecated\
    \x18\x03\x20\x01(\x08:\x05falseR\ndeprecated\x12X\n\x14uninterpreted_opt\
    ion\x18\xe7\x07\x20\x03(\x0b2$.google.protobuf.UninterpretedOptionR\x13u\
    ninterpretedOption*\t\x08\xe8\x07\x10\x80\x80\x80\x80\x02J\x04\x08\x05\
    \x10\x06\"\x9e\x01\n\x10EnumValueOptions\x12%\n\ndeprecated\x18\x01\x20\
    \x01(\x08:\x05falseR\ndeprecated\x12X\n\x14uninterpreted_option\x18\xe7\
    \x07\x20\x03(\x0b2$.google.protobuf.UninterpretedOptionR\x13uninterprete\
    dOption*\t\x08\xe8\x07\x10\x80\x80\x80\x80\x02\"\x9c\x01\n\x0eServiceOpt\
    ions\x12%\n\ndeprecated\x18!\x20\x01(\x08:\x05falseR\ndeprecated\x12X\n\
    \x14uninterpreted_option\x18\xe7\x07\x20\x03(\x0b2$.google.protobuf.Unin\
    terpretedOptionR\x13uninterpretedOption*\t\x08\xe8\x07\x10\x80\x80\x80\
    \x80\x02\"\xe0\x02\n\rMethodOptions\x12%\n\ndeprecated\x18!\x20\x01(\x08\
    :\x05falseR\ndeprecated\x12q\n\x11idempotency_level\x18\"\x20\x01(\x0e2/\
    .google.protobuf.MethodOptions.IdempotencyLevel:\x13IDEMPOTENCY_UNKNOWNR\
    \x10idempotencyLevel\x12X\n\x14uninterpreted_option\x18\xe7\x07\x20\x03(\
    \x0b2$.google.protobuf.UninterpretedOptionR\x13uninterpretedOption\"P\n\
    \x10IdempotencyLevel\x12\x17\n\x13IDEMPOTENCY_UNKNOWN\x10\0\x12\x13\n\
    \x0fNO_SIDE_EFFECTS\x10\x01\x12\x0e\n\nIDEMPOTENT\x10\x02*\t\x08\xe8\x07\
    \x10\x80\x80\x80\x80\x02\"\x9a\x03\n\x13UninterpretedOption\x12A\n\x04na\
    me\x18\x02\x20\x03(\x0b2-.google.protobuf.UninterpretedOption.NamePartR\
    \x04name\x12)\n\x10identifier_value\x18\x03\x20\x01(\tR\x0fidentifierVal\
    ue\x12,\n\x12positive_int_value\x18\x04\x20\x01(\x04R\x10positiveIntValu\
    e\x12,\n\x12negative_int_value\x18\x05\x20\x01(\x03R\x10negativeIntValue\
    \x12!\n\x0cdouble_value\x18\x06\x20\x01(\x01R\x0bdoubleValue\x12!\n\x0cs\
    tring_value\x18\x07\x20\x01(\x0cR\x0bstringValue\x12'\n\x0faggregate_val\
    ue\x18\x08\x20\x01(\tR\x0eaggregateValue\x1aJ\n\x08NamePart\x12\x1b\n\tn\
    ame_part\x18\x01\x20\x02(\tR\x08namePart\x12!\n\x0cis_extension\x18\x02\
    \x20\x02(\x08R\x0bisExtension\"\xa7\x02\n\x0eSourceCodeInfo\x12D\n\x08lo\
    cation\x18\x01\x20\x03(\x0b2(.google.protobuf.SourceCodeInfo.LocationR\
    \x08location\x1a\xce\x01\n\x08Location\x12\x16\n\x04path\x18\x01\x20\x03\
    (\x05R\x04pathB\x02\x10\x01\x12\x16\n\x04span\x18\x02\x20\x03(\x05R\x04s\
    panB\x02\x10\x01\x12)\n\x10leading_comments\x18\x03\x20\x01(\tR\x0fleadi\
    ngComments\x12+\n\x11trailing_comments\x18\x04\x20\x01(\tR\x10trailingCo\
    mments\x12:\n\x19leading_detached_comments\x18\x06\x20\x03(\tR\x17leadin\
    gDetachedComments\"\xd1\x01\n\x11GeneratedCodeInfo\x12M\n\nannotation\
    \x18\x01\x20\x03(\x0b2-.google.protobuf.GeneratedCodeInfo.AnnotationR\na\
    nnotation\x1am\n\nAnnotation\x12\x16\n\x04path\x18\x01\x20\x03(\x05R\x04\
    pathB\x02\x10\x01\x12\x1f\n\x0bsource_file\x18\x02\x20\x01(\tR\nsourceFi\
    le\x12\x14\n\x05begin\x18\x03\x20\x01(\x05R\x05begin\x12\x10\n\x03end\
    \x18\x04\x20\x01(\x05R\x03endB~\n\x13com.google.protobufB\x10DescriptorP\
    rotosH\x01Z-google.golang.org/protobuf/types/descriptorpb\xf8\x01\x01\
    \xa2\x02\x03GPB\xaa\x02\x1aGoogle.Protobuf.ReflectionJ\x82\xca\x02\n\x07\
    \x12\x05'\0\x8e\x07\x01\n\xaa\x0f\n\x01\x0c\x12\x03'\0\x122\xc1\x0c\x20P\
    rotocol\x20Buffers\x20-\x20Google's\x20data\x20interchange\x20format\n\
    \x20Copyright\x202008\x20Google\x20Inc.\x20\x20All\x20rights\x20reserved\
    .\n\x20https://developers.google.com/protocol-buffers/\n\n\x20Redistribu\
    tion\x20and\x20use\x20in\x20source\x20and\x20binary\x20forms,\x20with\
    \x20or\x20without\n\x20modification,\x20are\x20permitted\x20provided\x20\
    that\x20the\x20following\x20conditions\x20are\n\x20met:\n\n\x20\x20\x20\
    \x20\x20*\x20Redistributions\x20of\x20source\x20code\x20must\x20retain\
    \x20the\x20above\x20copyright\n\x20notice,\x20this\x20list\x20of\x20cond\
    itions\x20and\x20the\x20following\x20disclaimer.\n\x20\x20\x20\x20\x20*\
    \x20Redistributions\x20in\x20binary\x20form\x20must\x20reproduce\x20the\
    \x20above\n\x20copyright\x20notice,\x20this\x20list\x20of\x20conditions\
    \x20and\x20the\x20following\x20disclaimer\n\x20in\x20the\x20documentatio\
    n\x20and/or\x20other\x20materials\x20provided\x20with\x20the\n\x20distri\
    bution.\n\x20\x20\x20\x20\x20*\x20Neither\x20the\x20name\x20of\x20Google\
    \x20Inc.\x20nor\x20the\x20names\x20of\x20its\n\x20contributors\x20may\
    \x20be\x20used\x20to\x20endorse\x20or\x20promote\x20products\x20derived\
    \x20from\n\x20this\x20software\x20without\x20specific\x20prior\x20writte\
    n\x20permission.\n\n\x20THIS\x20SOFTWARE\x20IS\x20PROVIDED\x20BY\x20THE\
    \x20COPYRIGHT\x20HOLDERS\x20AND\x20CONTRIBUTORS\n\x20\"AS\x20IS\"\x20AND\
    \x20ANY\x20EXPRESS\x20OR\x20IMPLIED\x20WARRANTIES,\x20INCLUDING,\x20BUT\
    \x20NOT\n\x20LIMITED\x20TO,\x20THE\x20IMPLIED\x20WARRANTIES\x20OF\x20MER\
    CHANTABILITY\x20AND\x20FITNESS\x20FOR\n\x20A\x20PARTICULAR\x20PURPOSE\
    \x20ARE\x20DISCLAIMED.\x20IN\x20NO\x20EVENT\x20SHALL\x20THE\x20COPYRIGHT\
    \n\x20OWNER\x20OR\x20CONTRIBUTORS\x20BE\x20LIABLE\x20FOR\x20ANY\x20DIREC\
    T,\x20INDIRECT,\x20INCIDENTAL,\n\x20SPECIAL,\x20EXEMPLARY,\x20OR\x20CONS\
    EQUENTIAL\x20DAMAGES\x20(INCLUDING,\x20BUT\x20NOT\n\x20LIMITED\x20TO,\
    \x20PROCUREMENT\x20OF\x20SUBSTITUTE\x20GOODS\x20OR\x20SERVICES;\x20LOSS\
    \x20OF\x20USE,\n\x20DATA,\x20OR\x20PROFITS;\x20OR\x20BUSINESS\x20INTERRU\
    PTION)\x20HOWEVER\x20CAUSED\x20AND\x20ON\x20ANY\n\x20THEORY\x20OF\x20LIA\
    BILITY,\x20WHETHER\x20IN\x20CONTRACT,\x20STRICT\x20LIABILITY,\x20OR\x20T\
    ORT\n\x20(INCLUDING\x20NEGLIGENCE\x20OR\x20OTHERWISE)\x20ARISING\x20IN\
    \x20ANY\x20WAY\x20OUT\x20OF\x20THE\x20USE\n\x20OF\x20THIS\x20SOFTWARE,\
    \x20EVEN\x20IF\x20ADVISED\x20OF\x20THE\x20POSSIBILITY\x20OF\x20SUCH\x20D\
    AMAGE.\n2\xdb\x02\x20Author:\x20kenton@google.com\x20(Kenton\x20Varda)\n\
    \x20\x20Based\x20on\x20original\x20Protocol\x20Buffers\x20design\x20by\n\
    \x20\x20Sanjay\x20Ghemawat,\x20Jeff\x20Dean,\x20and\x20others.\n\n\x20Th\
    e\x20messages\x20in\x20this\x20file\x20describe\x20the\x20definitions\
    \x20found\x20in\x20.proto\x20files.\n\x20A\x20valid\x20.proto\x20file\
    \x20can\x20be\x20translated\x20directly\x20to\x20a\x20FileDescriptorProt\
    o\n\x20without\x20any\x20other\x20information\x20(e.g.\x20without\x20rea\
    ding\x20its\x20imports).\n\n\x08\n\x01\x02\x12\x03)\0\x18\n\x08\n\x01\
    \x08\x12\x03+\0D\n\t\n\x02\x08\x0b\x12\x03+\0D\n\x08\n\x01\x08\x12\x03,\
    \0,\n\t\n\x02\x08\x01\x12\x03,\0,\n\x08\n\x01\x08\x12\x03-\01\n\t\n\x02\
    \x08\x08\x12\x03-\01\n\x08\n\x01\x08\x12\x03.\07\n\t\n\x02\x08%\x12\x03.\
    \07\n\x08\n\x01\x08\x12\x03/\0!\n\t\n\x02\x08$\x12\x03/\0!\n\x08\n\x01\
    \x08\x12\x030\0\x1f\n\t\n\x02\x08\x1f\x12\x030\0\x1f\n\x08\n\x01\x08\x12\
    \x034\0\x1c\n\x7f\n\x02\x08\t\x12\x034\0\x1c\x1at\x20descriptor.proto\
    \x20must\x20be\x20optimized\x20for\x20speed\x20because\x20reflection-bas\
    ed\n\x20algorithms\x20don't\x20work\x20during\x20bootstrapping.\n\nj\n\
    \x02\x04\0\x12\x048\0:\x01\x1a^\x20The\x20protocol\x20compiler\x20can\
    \x20output\x20a\x20FileDescriptorSet\x20containing\x20the\x20.proto\n\
    \x20files\x20it\x20parses.\n\n\n\n\x03\x04\0\x01\x12\x038\x08\x19\n\x0b\
    \n\x04\x04\0\x02\0\x12\x039\x02(\n\x0c\n\x05\x04\0\x02\0\x04\x12\x039\
    \x02\n\n\x0c\n\x05\x04\0\x02\0\x06\x12\x039\x0b\x1e\n\x0c\n\x05\x04\0\
    \x02\0\x01\x12\x039\x1f#\n\x0c\n\x05\x04\0\x02\0\x03\x12\x039&'\n/\n\x02\
    \x04\x01\x12\x04=\0Z\x01\x1a#\x20Describes\x20a\x20complete\x20.proto\
    \x20file.\n\n\n\n\x03\x04\x01\x01\x12\x03=\x08\x1b\n9\n\x04\x04\x01\x02\
    \0\x12\x03>\x02\x1b\",\x20file\x20name,\x20relative\x20to\x20root\x20of\
    \x20source\x20tree\n\n\x0c\n\x05\x04\x01\x02\0\x04\x12\x03>\x02\n\n\x0c\
    \n\x05\x04\x01\x02\0\x05\x12\x03>\x0b\x11\n\x0c\n\x05\x04\x01\x02\0\x01\
    \x12\x03>\x12\x16\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03>\x19\x1a\n*\n\
    \x04\x04\x01\x02\x01\x12\x03?\x02\x1e\"\x1d\x20e.g.\x20\"foo\",\x20\"foo\
    .bar\",\x20etc.\n\n\x0c\n\x05\x04\x01\x02\x01\x04\x12\x03?\x02\n\n\x0c\n\
    \x05\x04\x01\x02\x01\x05\x12\x03?\x0b\x11\n\x0c\n\x05\x04\x01\x02\x01\
    \x01\x12\x03?\x12\x19\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x03?\x1c\x1d\n\
    4\n\x04\x04\x01\x02\x02\x12\x03B\x02!\x1a'\x20Names\x20of\x20files\x20im\
    ported\x20by\x20this\x20file.\n\n\x0c\n\x05\x04\x01\x02\x02\x04\x12\x03B\
    \x02\n\n\x0c\n\x05\x04\x01\x02\x02\x05\x12\x03B\x0b\x11\n\x0c\n\x05\x04\
    \x01\x02\x02\x01\x12\x03B\x12\x1c\n\x0c\n\x05\x04\x01\x02\x02\x03\x12\
    \x03B\x1f\x20\nQ\n\x04\x04\x01\x02\x03\x12\x03D\x02(\x1aD\x20Indexes\x20\
    of\x20the\x20public\x20imported\x20files\x20in\x20the\x20dependency\x20l\
    ist\x20above.\n\n\x0c\n\x05\x04\x01\x02\x03\x04\x12\x03D\x02\n\n\x0c\n\
    \x05\x04\x01\x02\x03\x05\x12\x03D\x0b\x10\n\x0c\n\x05\x04\x01\x02\x03\
    \x01\x12\x03D\x11\"\n\x0c\n\x05\x04\x01\x02\x03\x03\x12\x03D%'\nz\n\x04\
    \x04\x01\x02\x04\x12\x03G\x02&\x1am\x20Indexes\x20of\x20the\x20weak\x20i\
    mported\x20files\x20in\x20the\x20dependency\x20list.\n\x20For\x20Google-\
    internal\x20migration\x20only.\x20Do\x20not\x20use.\n\n\x0c\n\x05\x04\
    \x01\x02\x04\x04\x12\x03G\x02\n\n\x0c\n\x05\x04\x01\x02\x04\x05\x12\x03G\
    \x0b\x10\n\x0c\n\x05\x04\x01\x02\x04\x01\x12\x03G\x11\x20\n\x0c\n\x05\
    \x04\x01\x02\x04\x03\x12\x03G#%\n6\n\x04\x04\x01\x02\x05\x12\x03J\x02,\
    \x1a)\x20All\x20top-level\x20definitions\x20in\x20this\x20file.\n\n\x0c\
    \n\x05\x04\x01\x02\x05\x04\x12\x03J\x02\n\n\x0c\n\x05\x04\x01\x02\x05\
    \x06\x12\x03J\x0b\x1a\n\x0c\n\x05\x04\x01\x02\x05\x01\x12\x03J\x1b'\n\
    \x0c\n\x05\x04\x01\x02\x05\x03\x12\x03J*+\n\x0b\n\x04\x04\x01\x02\x06\
    \x12\x03K\x02-\n\x0c\n\x05\x04\x01\x02\x06\x04\x12\x03K\x02\n\n\x0c\n\
    \x05\x04\x01\x02\x06\x06\x12\x03K\x0b\x1e\n\x0c\n\x05\x04\x01\x02\x06\
    \x01\x12\x03K\x1f(\n\x0c\n\x05\x04\x01\x02\x06\x03\x12\x03K+,\n\x0b\n\
    \x04\x04\x01\x02\x07\x12\x03L\x02.\n\x0c\n\x05\x04\x01\x02\x07\x04\x12\
    \x03L\x02\n\n\x0c\n\x05\x04\x01\x02\x07\x06\x12\x03L\x0b!\n\x0c\n\x05\
    \x04\x01\x02\x07\x01\x12\x03L\")\n\x0c\n\x05\x04\x01\x02\x07\x03\x12\x03\
    L,-\n\x0b\n\x04\x04\x01\x02\x08\x12\x03M\x02.\n\x0c\n\x05\x04\x01\x02\
    \x08\x04\x12\x03M\x02\n\n\x0c\n\x05\x04\x01\x02\x08\x06\x12\x03M\x0b\x1f\
    \n\x0c\n\x05\x04\x01\x02\x08\x01\x12\x03M\x20)\n\x0c\n\x05\x04\x01\x02\
    \x08\x03\x12\x03M,-\n\x0b\n\x04\x04\x01\x02\t\x12\x03O\x02#\n\x0c\n\x05\
    \x04\x01\x02\t\x04\x12\x03O\x02\n\n\x0c\n\x05\x04\x01\x02\t\x06\x12\x03O\
    \x0b\x16\n\x0c\n\x05\x04\x01\x02\t\x01\x12\x03O\x17\x1e\n\x0c\n\x05\x04\
    \x01\x02\t\x03\x12\x03O!\"\n\xf4\x01\n\x04\x04\x01\x02\n\x12\x03U\x02/\
    \x1a\xe6\x01\x20This\x20field\x20contains\x20optional\x20information\x20\
    about\x20the\x20original\x20source\x20code.\n\x20You\x20may\x20safely\
    \x20remove\x20this\x20entire\x20field\x20without\x20harming\x20runtime\n\
    \x20functionality\x20of\x20the\x20descriptors\x20--\x20the\x20informatio\
    n\x20is\x20needed\x20only\x20by\n\x20development\x20tools.\n\n\x0c\n\x05\
    \x04\x01\x02\n\x04\x12\x03U\x02\n\n\x0c\n\x05\x04\x01\x02\n\x06\x12\x03U\
    \x0b\x19\n\x0c\n\x05\x04\x01\x02\n\x01\x12\x03U\x1a*\n\x0c\n\x05\x04\x01\
    \x02\n\x03\x12\x03U-.\n]\n\x04\x04\x01\x02\x0b\x12\x03Y\x02\x1e\x1aP\x20\
    The\x20syntax\x20of\x20the\x20proto\x20file.\n\x20The\x20supported\x20va\
    lues\x20are\x20\"proto2\"\x20and\x20\"proto3\".\n\n\x0c\n\x05\x04\x01\
    \x02\x0b\x04\x12\x03Y\x02\n\n\x0c\n\x05\x04\x01\x02\x0b\x05\x12\x03Y\x0b\
    \x11\n\x0c\n\x05\x04\x01\x02\x0b\x01\x12\x03Y\x12\x18\n\x0c\n\x05\x04\
    \x01\x02\x0b\x03\x12\x03Y\x1b\x1d\n'\n\x02\x04\x02\x12\x04]\0}\x01\x1a\
    \x1b\x20Describes\x20a\x20message\x20type.\n\n\n\n\x03\x04\x02\x01\x12\
    \x03]\x08\x17\n\x0b\n\x04\x04\x02\x02\0\x12\x03^\x02\x1b\n\x0c\n\x05\x04\
    \x02\x02\0\x04\x12\x03^\x02\n\n\x0c\n\x05\x04\x02\x02\0\x05\x12\x03^\x0b\
    \x11\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03^\x12\x16\n\x0c\n\x05\x04\x02\
    \x02\0\x03\x12\x03^\x19\x1a\n\x0b\n\x04\x04\x02\x02\x01\x12\x03`\x02*\n\
    \x0c\n\x05\x04\x02\x02\x01\x04\x12\x03`\x02\n\n\x0c\n\x05\x04\x02\x02\
    \x01\x06\x12\x03`\x0b\x1f\n\x0c\n\x05\x04\x02\x02\x01\x01\x12\x03`\x20%\
    \n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x03`()\n\x0b\n\x04\x04\x02\x02\x02\
    \x12\x03a\x02.\n\x0c\n\x05\x04\x02\x02\x02\x04\x12\x03a\x02\n\n\x0c\n\
    \x05\x04\x02\x02\x02\x06\x12\x03a\x0b\x1f\n\x0c\n\x05\x04\x02\x02\x02\
    \x01\x12\x03a\x20)\n\x0c\n\x05\x04\x02\x02\x02\x03\x12\x03a,-\n\x0b\n\
    \x04\x04\x02\x02\x03\x12\x03c\x02+\n\x0c\n\x05\x04\x02\x02\x03\x04\x12\
    \x03c\x02\n\n\x0c\n\x05\x04\x02\x02\x03\x06\x12\x03c\x0b\x1a\n\x0c\n\x05\
    \x04\x02\x02\x03\x01\x12\x03c\x1b&\n\x0c\n\x05\x04\x02\x02\x03\x03\x12\
    \x03c)*\n\x0b\n\x04\x04\x02\x02\x04\x12\x03d\x02-\n\x0c\n\x05\x04\x02\
    \x02\x04\x04\x12\x03d\x02\n\n\x0c\n\x05\x04\x02\x02\x04\x06\x12\x03d\x0b\
    \x1e\n\x0c\n\x05\x04\x02\x02\x04\x01\x12\x03d\x1f(\n\x0c\n\x05\x04\x02\
    \x02\x04\x03\x12\x03d+,\n\x0c\n\x04\x04\x02\x03\0\x12\x04f\x02k\x03\n\
    \x0c\n\x05\x04\x02\x03\0\x01\x12\x03f\n\x18\n\x1b\n\x06\x04\x02\x03\0\
    \x02\0\x12\x03g\x04\x1d\"\x0c\x20Inclusive.\n\n\x0e\n\x07\x04\x02\x03\0\
    \x02\0\x04\x12\x03g\x04\x0c\n\x0e\n\x07\x04\x02\x03\0\x02\0\x05\x12\x03g\
    \r\x12\n\x0e\n\x07\x04\x02\x03\0\x02\0\x01\x12\x03g\x13\x18\n\x0e\n\x07\
    \x04\x02\x03\0\x02\0\x03\x12\x03g\x1b\x1c\n\x1b\n\x06\x04\x02\x03\0\x02\
    \x01\x12\x03h\x04\x1b\"\x0c\x20Exclusive.\n\n\x0e\n\x07\x04\x02\x03\0\
    \x02\x01\x04\x12\x03h\x04\x0c\n\x0e\n\x07\x04\x02\x03\0\x02\x01\x05\x12\
    \x03h\r\x12\n\x0e\n\x07\x04\x02\x03\0\x02\x01\x01\x12\x03h\x13\x16\n\x0e\
    \n\x07\x04\x02\x03\0\x02\x01\x03\x12\x03h\x19\x1a\n\r\n\x06\x04\x02\x03\
    \0\x02\x02\x12\x03j\x04/\n\x0e\n\x07\x04\x02\x03\0\x02\x02\x04\x12\x03j\
    \x04\x0c\n\x0e\n\x07\x04\x02\x03\0\x02\x02\x06\x12\x03j\r\"\n\x0e\n\x07\
    \x04\x02\x03\0\x02\x02\x01\x12\x03j#*\n\x0e\n\x07\x04\x02\x03\0\x02\x02\
    \x03\x12\x03j-.\n\x0b\n\x04\x04\x02\x02\x05\x12\x03l\x02.\n\x0c\n\x05\
    \x04\x02\x02\x05\x04\x12\x03l\x02\n\n\x0c\n\x05\x04\x02\x02\x05\x06\x12\
    \x03l\x0b\x19\n\x0c\n\x05\x04\x02\x02\x05\x01\x12\x03l\x1a)\n\x0c\n\x05\
    \x04\x02\x02\x05\x03\x12\x03l,-\n\x0b\n\x04\x04\x02\x02\x06\x12\x03n\x02\
    /\n\x0c\n\x05\x04\x02\x02\x06\x04\x12\x03n\x02\n\n\x0c\n\x05\x04\x02\x02\
    \x06\x06\x12\x03n\x0b\x1f\n\x0c\n\x05\x04\x02\x02\x06\x01\x12\x03n\x20*\
    \n\x0c\n\x05\x04\x02\x02\x06\x03\x12\x03n-.\n\x0b\n\x04\x04\x02\x02\x07\
    \x12\x03p\x02&\n\x0c\n\x05\x04\x02\x02\x07\x04\x12\x03p\x02\n\n\x0c\n\
    \x05\x04\x02\x02\x07\x06\x12\x03p\x0b\x19\n\x0c\n\x05\x04\x02\x02\x07\
    \x01\x12\x03p\x1a!\n\x0c\n\x05\x04\x02\x02\x07\x03\x12\x03p$%\n\xaa\x01\
    \n\x04\x04\x02\x03\x01\x12\x04u\x02x\x03\x1a\x9b\x01\x20Range\x20of\x20r\
    eserved\x20tag\x20numbers.\x20Reserved\x20tag\x20numbers\x20may\x20not\
    \x20be\x20used\x20by\n\x20fields\x20or\x20extension\x20ranges\x20in\x20t\
    he\x20same\x20message.\x20Reserved\x20ranges\x20may\n\x20not\x20overlap.\
    \n\n\x0c\n\x05\x04\x02\x03\x01\x01\x12\x03u\n\x17\n\x1b\n\x06\x04\x02\
    \x03\x01\x02\0\x12\x03v\x04\x1d\"\x0c\x20Inclusive.\n\n\x0e\n\x07\x04\
    \x02\x03\x01\x02\0\x04\x12\x03v\x04\x0c\n\x0e\n\x07\x04\x02\x03\x01\x02\
    \0\x05\x12\x03v\r\x12\n\x0e\n\x07\x04\x02\x03\x01\x02\0\x01\x12\x03v\x13\
    \x18\n\x0e\n\x07\x04\x02\x03\x01\x02\0\x03\x12\x03v\x1b\x1c\n\x1b\n\x06\
    \x04\x02\x03\x01\x02\x01\x12\x03w\x04\x1b\"\x0c\x20Exclusive.\n\n\x0e\n\
    \x07\x04\x02\x03\x01\x02\x01\x04\x12\x03w\x04\x0c\n\x0e\n\x07\x04\x02\
    \x03\x01\x02\x01\x05\x12\x03w\r\x12\n\x0e\n\x07\x04\x02\x03\x01\x02\x01\
    \x01\x12\x03w\x13\x16\n\x0e\n\x07\x04\x02\x03\x01\x02\x01\x03\x12\x03w\
    \x19\x1a\n\x0b\n\x04\x04\x02\x02\x08\x12\x03y\x02,\n\x0c\n\x05\x04\x02\
    \x02\x08\x04\x12\x03y\x02\n\n\x0c\n\x05\x04\x02\x02\x08\x06\x12\x03y\x0b\
    \x18\n\x0c\n\x05\x04\x02\x02\x08\x01\x12\x03y\x19'\n\x0c\n\x05\x04\x02\
    \x02\x08\x03\x12\x03y*+\n\x82\x01\n\x04\x04\x02\x02\t\x12\x03|\x02%\x1au\
    \x20Reserved\x20field\x20names,\x20which\x20may\x20not\x20be\x20used\x20\
    by\x20fields\x20in\x20the\x20same\x20message.\n\x20A\x20given\x20name\
    \x20may\x20only\x20be\x20reserved\x20once.\n\n\x0c\n\x05\x04\x02\x02\t\
    \x04\x12\x03|\x02\n\n\x0c\n\x05\x04\x02\x02\t\x05\x12\x03|\x0b\x11\n\x0c\
    \n\x05\x04\x02\x02\t\x01\x12\x03|\x12\x1f\n\x0c\n\x05\x04\x02\x02\t\x03\
    \x12\x03|\"$\n\x0b\n\x02\x04\x03\x12\x05\x7f\0\x86\x01\x01\n\n\n\x03\x04\
    \x03\x01\x12\x03\x7f\x08\x1d\nO\n\x04\x04\x03\x02\0\x12\x04\x81\x01\x02:\
    \x1aA\x20The\x20parser\x20stores\x20options\x20it\x20doesn't\x20recogniz\
    e\x20here.\x20See\x20above.\n\n\r\n\x05\x04\x03\x02\0\x04\x12\x04\x81\
    \x01\x02\n\n\r\n\x05\x04\x03\x02\0\x06\x12\x04\x81\x01\x0b\x1e\n\r\n\x05\
    \x04\x03\x02\0\x01\x12\x04\x81\x01\x1f3\n\r\n\x05\x04\x03\x02\0\x03\x12\
    \x04\x81\x0169\nZ\n\x03\x04\x03\x05\x12\x04\x85\x01\x02\x19\x1aM\x20Clie\
    nts\x20can\x20define\x20custom\x20options\x20in\x20extensions\x20of\x20t\
    his\x20message.\x20See\x20above.\n\n\x0c\n\x04\x04\x03\x05\0\x12\x04\x85\
    \x01\r\x18\n\r\n\x05\x04\x03\x05\0\x01\x12\x04\x85\x01\r\x11\n\r\n\x05\
    \x04\x03\x05\0\x02\x12\x04\x85\x01\x15\x18\n3\n\x02\x04\x04\x12\x06\x89\
    \x01\0\xee\x01\x01\x1a%\x20Describes\x20a\x20field\x20within\x20a\x20mes\
    sage.\n\n\x0b\n\x03\x04\x04\x01\x12\x04\x89\x01\x08\x1c\n\x0e\n\x04\x04\
    \x04\x04\0\x12\x06\x8a\x01\x02\xa9\x01\x03\n\r\n\x05\x04\x04\x04\0\x01\
    \x12\x04\x8a\x01\x07\x0b\nS\n\x06\x04\x04\x04\0\x02\0\x12\x04\x8d\x01\
    \x04\x14\x1aC\x200\x20is\x20reserved\x20for\x20errors.\n\x20Order\x20is\
    \x20weird\x20for\x20historical\x20reasons.\n\n\x0f\n\x07\x04\x04\x04\0\
    \x02\0\x01\x12\x04\x8d\x01\x04\x0f\n\x0f\n\x07\x04\x04\x04\0\x02\0\x02\
    \x12\x04\x8d\x01\x12\x13\n\x0e\n\x06\x04\x04\x04\0\x02\x01\x12\x04\x8e\
    \x01\x04\x13\n\x0f\n\x07\x04\x04\x04\0\x02\x01\x01\x12\x04\x8e\x01\x04\
    \x0e\n\x0f\n\x07\x04\x04\x04\0\x02\x01\x02\x12\x04\x8e\x01\x11\x12\nw\n\
    \x06\x04\x04\x04\0\x02\x02\x12\x04\x91\x01\x04\x13\x1ag\x20Not\x20ZigZag\
    \x20encoded.\x20\x20Negative\x20numbers\x20take\x2010\x20bytes.\x20\x20U\
    se\x20TYPE_SINT64\x20if\n\x20negative\x20values\x20are\x20likely.\n\n\
    \x0f\n\x07\x04\x04\x04\0\x02\x02\x01\x12\x04\x91\x01\x04\x0e\n\x0f\n\x07\
    \x04\x04\x04\0\x02\x02\x02\x12\x04\x91\x01\x11\x12\n\x0e\n\x06\x04\x04\
    \x04\0\x02\x03\x12\x04\x92\x01\x04\x14\n\x0f\n\x07\x04\x04\x04\0\x02\x03\
    \x01\x12\x04\x92\x01\x04\x0f\n\x0f\n\x07\x04\x04\x04\0\x02\x03\x02\x12\
    \x04\x92\x01\x12\x13\nw\n\x06\x04\x04\x04\0\x02\x04\x12\x04\x95\x01\x04\
    \x13\x1ag\x20Not\x20ZigZag\x20encoded.\x20\x20Negative\x20numbers\x20tak\
    e\x2010\x20bytes.\x20\x20Use\x20TYPE_SINT32\x20if\n\x20negative\x20value\
    s\x20are\x20likely.\n\n\x0f\n\x07\x04\x04\x04\0\x02\x04\x01\x12\x04\x95\
    \x01\x04\x0e\n\x0f\n\x07\x04\x04\x04\0\x02\x04\x02\x12\x04\x95\x01\x11\
    \x12\n\x0e\n\x06\x04\x04\x04\0\x02\x05\x12\x04\x96\x01\x04\x15\n\x0f\n\
    \x07\x04\x04\x04\0\x02\x05\x01\x12\x04\x96\x01\x04\x10\n\x0f\n\x07\x04\
    \x04\x04\0\x02\x05\x02\x12\x04\x96\x01\x13\x14\n\x0e\n\x06\x04\x04\x04\0\
    \x02\x06\x12\x04\x97\x01\x04\x15\n\x0f\n\x07\x04\x04\x04\0\x02\x06\x01\
    \x12\x04\x97\x01\x04\x10\n\x0f\n\x07\x04\x04\x04\0\x02\x06\x02\x12\x04\
    \x97\x01\x13\x14\n\x0e\n\x06\x04\x04\x04\0\x02\x07\x12\x04\x98\x01\x04\
    \x12\n\x0f\n\x07\x04\x04\x04\0\x02\x07\x01\x12\x04\x98\x01\x04\r\n\x0f\n\
    \x07\x04\x04\x04\0\x02\x07\x02\x12\x04\x98\x01\x10\x11\n\x0e\n\x06\x04\
    \x04\x04\0\x02\x08\x12\x04\x99\x01\x04\x14\n\x0f\n\x07\x04\x04\x04\0\x02\
    \x08\x01\x12\x04\x99\x01\x04\x0f\n\x0f\n\x07\x04\x04\x04\0\x02\x08\x02\
    \x12\x04\x99\x01\x12\x13\n\xe2\x01\n\x06\x04\x04\x04\0\x02\t\x12\x04\x9e\
    \x01\x04\x14\x1a\xd1\x01\x20Tag-delimited\x20aggregate.\n\x20Group\x20ty\
    pe\x20is\x20deprecated\x20and\x20not\x20supported\x20in\x20proto3.\x20Ho\
    wever,\x20Proto3\n\x20implementations\x20should\x20still\x20be\x20able\
    \x20to\x20parse\x20the\x20group\x20wire\x20format\x20and\n\x20treat\x20g\
    roup\x20fields\x20as\x20unknown\x20fields.\n\n\x0f\n\x07\x04\x04\x04\0\
    \x02\t\x01\x12\x04\x9e\x01\x04\x0e\n\x0f\n\x07\x04\x04\x04\0\x02\t\x02\
    \x12\x04\x9e\x01\x11\x13\n-\n\x06\x04\x04\x04\0\x02\n\x12\x04\x9f\x01\
    \x04\x16\"\x1d\x20Length-delimited\x20aggregate.\n\n\x0f\n\x07\x04\x04\
    \x04\0\x02\n\x01\x12\x04\x9f\x01\x04\x10\n\x0f\n\x07\x04\x04\x04\0\x02\n\
    \x02\x12\x04\x9f\x01\x13\x15\n#\n\x06\x04\x04\x04\0\x02\x0b\x12\x04\xa2\
    \x01\x04\x14\x1a\x13\x20New\x20in\x20version\x202.\n\n\x0f\n\x07\x04\x04\
    \x04\0\x02\x0b\x01\x12\x04\xa2\x01\x04\x0e\n\x0f\n\x07\x04\x04\x04\0\x02\
    \x0b\x02\x12\x04\xa2\x01\x11\x13\n\x0e\n\x06\x04\x04\x04\0\x02\x0c\x12\
    \x04\xa3\x01\x04\x15\n\x0f\n\x07\x04\x04\x04\0\x02\x0c\x01\x12\x04\xa3\
    \x01\x04\x0f\n\x0f\n\x07\x04\x04\x04\0\x02\x0c\x02\x12\x04\xa3\x01\x12\
    \x14\n\x0e\n\x06\x04\x04\x04\0\x02\r\x12\x04\xa4\x01\x04\x13\n\x0f\n\x07\
    \x04\x04\x04\0\x02\r\x01\x12\x04\xa4\x01\x04\r\n\x0f\n\x07\x04\x04\x04\0\
    \x02\r\x02\x12\x04\xa4\x01\x10\x12\n\x0e\n\x06\x04\x04\x04\0\x02\x0e\x12\
    \x04\xa5\x01\x04\x17\n\x0f\n\x07\x04\x04\x04\0\x02\x0e\x01\x12\x04\xa5\
    \x01\x04\x11\n\x0f\n\x07\x04\x04\x04\0\x02\x0e\x02\x12\x04\xa5\x01\x14\
    \x16\n\x0e\n\x06\x04\x04\x04\0\x02\x0f\x12\x04\xa6\x01\x04\x17\n\x0f\n\
    \x07\x04\x04\x04\0\x02\x0f\x01\x12\x04\xa6\x01\x04\x11\n\x0f\n\x07\x04\
    \x04\x04\0\x02\x0f\x02\x12\x04\xa6\x01\x14\x16\n'\n\x06\x04\x04\x04\0\
    \x02\x10\x12\x04\xa7\x01\x04\x15\"\x17\x20Uses\x20ZigZag\x20encoding.\n\
    \n\x0f\n\x07\x04\x04\x04\0\x02\x10\x01\x12\x04\xa7\x01\x04\x0f\n\x0f\n\
    \x07\x04\x04\x04\0\x02\x10\x02\x12\x04\xa7\x01\x12\x14\n'\n\x06\x04\x04\
    \x04\0\x02\x11\x12\x04\xa8\x01\x04\x15\"\x17\x20Uses\x20ZigZag\x20encodi\
    ng.\n\n\x0f\n\x07\x04\x04\x04\0\x02\x11\x01\x12\x04\xa8\x01\x04\x0f\n\
    \x0f\n\x07\x04\x04\x04\0\x02\x11\x02\x12\x04\xa8\x01\x12\x14\n\x0e\n\x04\
    \x04\x04\x04\x01\x12\x06\xab\x01\x02\xb0\x01\x03\n\r\n\x05\x04\x04\x04\
    \x01\x01\x12\x04\xab\x01\x07\x0c\n*\n\x06\x04\x04\x04\x01\x02\0\x12\x04\
    \xad\x01\x04\x17\x1a\x1a\x200\x20is\x20reserved\x20for\x20errors\n\n\x0f\
    \n\x07\x04\x04\x04\x01\x02\0\x01\x12\x04\xad\x01\x04\x12\n\x0f\n\x07\x04\
    \x04\x04\x01\x02\0\x02\x12\x04\xad\x01\x15\x16\n\x0e\n\x06\x04\x04\x04\
    \x01\x02\x01\x12\x04\xae\x01\x04\x17\n\x0f\n\x07\x04\x04\x04\x01\x02\x01\
    \x01\x12\x04\xae\x01\x04\x12\n\x0f\n\x07\x04\x04\x04\x01\x02\x01\x02\x12\
    \x04\xae\x01\x15\x16\n\x0e\n\x06\x04\x04\x04\x01\x02\x02\x12\x04\xaf\x01\
    \x04\x17\n\x0f\n\x07\x04\x04\x04\x01\x02\x02\x01\x12\x04\xaf\x01\x04\x12\
    \n\x0f\n\x07\x04\x04\x04\x01\x02\x02\x02\x12\x04\xaf\x01\x15\x16\n\x0c\n\
    \x04\x04\x04\x02\0\x12\x04\xb2\x01\x02\x1b\n\r\n\x05\x04\x04\x02\0\x04\
    \x12\x04\xb2\x01\x02\n\n\r\n\x05\x04\x04\x02\0\x05\x12\x04\xb2\x01\x0b\
    \x11\n\r\n\x05\x04\x04\x02\0\x01\x12\x04\xb2\x01\x12\x16\n\r\n\x05\x04\
    \x04\x02\0\x03\x12\x04\xb2\x01\x19\x1a\n\x0c\n\x04\x04\x04\x02\x01\x12\
    \x04\xb3\x01\x02\x1c\n\r\n\x05\x04\x04\x02\x01\x04\x12\x04\xb3\x01\x02\n\
    \n\r\n\x05\x04\x04\x02\x01\x05\x12\x04\xb3\x01\x0b\x10\n\r\n\x05\x04\x04\
    \x02\x01\x01\x12\x04\xb3\x01\x11\x17\n\r\n\x05\x04\x04\x02\x01\x03\x12\
    \x04\xb3\x01\x1a\x1b\n\x0c\n\x04\x04\x04\x02\x02\x12\x04\xb4\x01\x02\x1b\
    \n\r\n\x05\x04\x04\x02\x02\x04\x12\x04\xb4\x01\x02\n\n\r\n\x05\x04\x04\
    \x02\x02\x06\x12\x04\xb4\x01\x0b\x10\n\r\n\x05\x04\x04\x02\x02\x01\x12\
    \x04\xb4\x01\x11\x16\n\r\n\x05\x04\x04\x02\x02\x03\x12\x04\xb4\x01\x19\
    \x1a\n\x9c\x01\n\x04\x04\x04\x02\x03\x12\x04\xb8\x01\x02\x19\x1a\x8d\x01\
    \x20If\x20type_name\x20is\x20set,\x20this\x20need\x20not\x20be\x20set.\
    \x20\x20If\x20both\x20this\x20and\x20type_name\n\x20are\x20set,\x20this\
    \x20must\x20be\x20one\x20of\x20TYPE_ENUM,\x20TYPE_MESSAGE\x20or\x20TYPE_\
    GROUP.\n\n\r\n\x05\x04\x04\x02\x03\x04\x12\x04\xb8\x01\x02\n\n\r\n\x05\
    \x04\x04\x02\x03\x06\x12\x04\xb8\x01\x0b\x0f\n\r\n\x05\x04\x04\x02\x03\
    \x01\x12\x04\xb8\x01\x10\x14\n\r\n\x05\x04\x04\x02\x03\x03\x12\x04\xb8\
    \x01\x17\x18\n\xb7\x02\n\x04\x04\x04\x02\x04\x12\x04\xbf\x01\x02\x20\x1a\
    \xa8\x02\x20For\x20message\x20and\x20enum\x20types,\x20this\x20is\x20the\
    \x20name\x20of\x20the\x20type.\x20\x20If\x20the\x20name\n\x20starts\x20w\
    ith\x20a\x20'.',\x20it\x20is\x20fully-qualified.\x20\x20Otherwise,\x20C+\
    +-like\x20scoping\n\x20rules\x20are\x20used\x20to\x20find\x20the\x20type\
    \x20(i.e.\x20first\x20the\x20nested\x20types\x20within\x20this\n\x20mess\
    age\x20are\x20searched,\x20then\x20within\x20the\x20parent,\x20on\x20up\
    \x20to\x20the\x20root\n\x20namespace).\n\n\r\n\x05\x04\x04\x02\x04\x04\
    \x12\x04\xbf\x01\x02\n\n\r\n\x05\x04\x04\x02\x04\x05\x12\x04\xbf\x01\x0b\
    \x11\n\r\n\x05\x04\x04\x02\x04\x01\x12\x04\xbf\x01\x12\x1b\n\r\n\x05\x04\
    \x04\x02\x04\x03\x12\x04\xbf\x01\x1e\x1f\n~\n\x04\x04\x04\x02\x05\x12\
    \x04\xc3\x01\x02\x1f\x1ap\x20For\x20extensions,\x20this\x20is\x20the\x20\
    name\x20of\x20the\x20type\x20being\x20extended.\x20\x20It\x20is\n\x20res\
    olved\x20in\x20the\x20same\x20manner\x20as\x20type_name.\n\n\r\n\x05\x04\
    \x04\x02\x05\x04\x12\x04\xc3\x01\x02\n\n\r\n\x05\x04\x04\x02\x05\x05\x12\
    \x04\xc3\x01\x0b\x11\n\r\n\x05\x04\x04\x02\x05\x01\x12\x04\xc3\x01\x12\
    \x1a\n\r\n\x05\x04\x04\x02\x05\x03\x12\x04\xc3\x01\x1d\x1e\n\xb1\x02\n\
    \x04\x04\x04\x02\x06\x12\x04\xca\x01\x02$\x1a\xa2\x02\x20For\x20numeric\
    \x20types,\x20contains\x20the\x20original\x20text\x20representation\x20o\
    f\x20the\x20value.\n\x20For\x20booleans,\x20\"true\"\x20or\x20\"false\".\
    \n\x20For\x20strings,\x20contains\x20the\x20default\x20text\x20contents\
    \x20(not\x20escaped\x20in\x20any\x20way).\n\x20For\x20bytes,\x20contains\
    \x20the\x20C\x20escaped\x20value.\x20\x20All\x20bytes\x20>=\x20128\x20ar\
    e\x20escaped.\n\x20TODO(kenton):\x20\x20Base-64\x20encode?\n\n\r\n\x05\
    \x04\x04\x02\x06\x04\x12\x04\xca\x01\x02\n\n\r\n\x05\x04\x04\x02\x06\x05\
    \x12\x04\xca\x01\x0b\x11\n\r\n\x05\x04\x04\x02\x06\x01\x12\x04\xca\x01\
    \x12\x1f\n\r\n\x05\x04\x04\x02\x06\x03\x12\x04\xca\x01\"#\n\x84\x01\n\
    \x04\x04\x04\x02\x07\x12\x04\xce\x01\x02!\x1av\x20If\x20set,\x20gives\
    \x20the\x20index\x20of\x20a\x20oneof\x20in\x20the\x20containing\x20type'\
    s\x20oneof_decl\n\x20list.\x20\x20This\x20field\x20is\x20a\x20member\x20\
    of\x20that\x20oneof.\n\n\r\n\x05\x04\x04\x02\x07\x04\x12\x04\xce\x01\x02\
    \n\n\r\n\x05\x04\x04\x02\x07\x05\x12\x04\xce\x01\x0b\x10\n\r\n\x05\x04\
    \x04\x02\x07\x01\x12\x04\xce\x01\x11\x1c\n\r\n\x05\x04\x04\x02\x07\x03\
    \x12\x04\xce\x01\x1f\x20\n\xfa\x01\n\x04\x04\x04\x02\x08\x12\x04\xd4\x01\
    \x02!\x1a\xeb\x01\x20JSON\x20name\x20of\x20this\x20field.\x20The\x20valu\
    e\x20is\x20set\x20by\x20protocol\x20compiler.\x20If\x20the\n\x20user\x20\
    has\x20set\x20a\x20\"json_name\"\x20option\x20on\x20this\x20field,\x20th\
    at\x20option's\x20value\n\x20will\x20be\x20used.\x20Otherwise,\x20it's\
    \x20deduced\x20from\x20the\x20field's\x20name\x20by\x20converting\n\x20i\
    t\x20to\x20camelCase.\n\n\r\n\x05\x04\x04\x02\x08\x04\x12\x04\xd4\x01\
    \x02\n\n\r\n\x05\x04\x04\x02\x08\x05\x12\x04\xd4\x01\x0b\x11\n\r\n\x05\
    \x04\x04\x02\x08\x01\x12\x04\xd4\x01\x12\x1b\n\r\n\x05\x04\x04\x02\x08\
    \x03\x12\x04\xd4\x01\x1e\x20\n\x0c\n\x04\x04\x04\x02\t\x12\x04\xd6\x01\
    \x02$\n\r\n\x05\x04\x04\x02\t\x04\x12\x04\xd6\x01\x02\n\n\r\n\x05\x04\
    \x04\x02\t\x06\x12\x04\xd6\x01\x0b\x17\n\r\n\x05\x04\x04\x02\t\x01\x12\
    \x04\xd6\x01\x18\x1f\n\r\n\x05\x04\x04\x02\t\x03\x12\x04\xd6\x01\"#\n\
    \xb3\t\n\x04\x04\x04\x02\n\x12\x04\xed\x01\x02%\x1a\xa4\t\x20If\x20true,\
    \x20this\x20is\x20a\x20proto3\x20\"optional\".\x20When\x20a\x20proto3\
    \x20field\x20is\x20optional,\x20it\n\x20tracks\x20presence\x20regardless\
    \x20of\x20field\x20type.\n\n\x20When\x20proto3_optional\x20is\x20true,\
    \x20this\x20field\x20must\x20be\x20belong\x20to\x20a\x20oneof\x20to\n\
    \x20signal\x20to\x20old\x20proto3\x20clients\x20that\x20presence\x20is\
    \x20tracked\x20for\x20this\x20field.\x20This\n\x20oneof\x20is\x20known\
    \x20as\x20a\x20\"synthetic\"\x20oneof,\x20and\x20this\x20field\x20must\
    \x20be\x20its\x20sole\n\x20member\x20(each\x20proto3\x20optional\x20fiel\
    d\x20gets\x20its\x20own\x20synthetic\x20oneof).\x20Synthetic\n\x20oneofs\
    \x20exist\x20in\x20the\x20descriptor\x20only,\x20and\x20do\x20not\x20gen\
    erate\x20any\x20API.\x20Synthetic\n\x20oneofs\x20must\x20be\x20ordered\
    \x20after\x20all\x20\"real\"\x20oneofs.\n\n\x20For\x20message\x20fields,\
    \x20proto3_optional\x20doesn't\x20create\x20any\x20semantic\x20change,\n\
    \x20since\x20non-repeated\x20message\x20fields\x20always\x20track\x20pre\
    sence.\x20However\x20it\x20still\n\x20indicates\x20the\x20semantic\x20de\
    tail\x20of\x20whether\x20the\x20user\x20wrote\x20\"optional\"\x20or\x20n\
    ot.\n\x20This\x20can\x20be\x20useful\x20for\x20round-tripping\x20the\x20\
    .proto\x20file.\x20For\x20consistency\x20we\n\x20give\x20message\x20fiel\
    ds\x20a\x20synthetic\x20oneof\x20also,\x20even\x20though\x20it\x20is\x20\
    not\x20required\n\x20to\x20track\x20presence.\x20This\x20is\x20especiall\
    y\x20important\x20because\x20the\x20parser\x20can't\n\x20tell\x20if\x20a\
    \x20field\x20is\x20a\x20message\x20or\x20an\x20enum,\x20so\x20it\x20must\
    \x20always\x20create\x20a\n\x20synthetic\x20oneof.\n\n\x20Proto2\x20opti\
    onal\x20fields\x20do\x20not\x20set\x20this\x20flag,\x20because\x20they\
    \x20already\x20indicate\n\x20optional\x20with\x20`LABEL_OPTIONAL`.\n\n\r\
    \n\x05\x04\x04\x02\n\x04\x12\x04\xed\x01\x02\n\n\r\n\x05\x04\x04\x02\n\
    \x05\x12\x04\xed\x01\x0b\x0f\n\r\n\x05\x04\x04\x02\n\x01\x12\x04\xed\x01\
    \x10\x1f\n\r\n\x05\x04\x04\x02\n\x03\x12\x04\xed\x01\"$\n\"\n\x02\x04\
    \x05\x12\x06\xf1\x01\0\xf4\x01\x01\x1a\x14\x20Describes\x20a\x20oneof.\n\
    \n\x0b\n\x03\x04\x05\x01\x12\x04\xf1\x01\x08\x1c\n\x0c\n\x04\x04\x05\x02\
    \0\x12\x04\xf2\x01\x02\x1b\n\r\n\x05\x04\x05\x02\0\x04\x12\x04\xf2\x01\
    \x02\n\n\r\n\x05\x04\x05\x02\0\x05\x12\x04\xf2\x01\x0b\x11\n\r\n\x05\x04\
    \x05\x02\0\x01\x12\x04\xf2\x01\x12\x16\n\r\n\x05\x04\x05\x02\0\x03\x12\
    \x04\xf2\x01\x19\x1a\n\x0c\n\x04\x04\x05\x02\x01\x12\x04\xf3\x01\x02$\n\
    \r\n\x05\x04\x05\x02\x01\x04\x12\x04\xf3\x01\x02\n\n\r\n\x05\x04\x05\x02\
    \x01\x06\x12\x04\xf3\x01\x0b\x17\n\r\n\x05\x04\x05\x02\x01\x01\x12\x04\
    \xf3\x01\x18\x1f\n\r\n\x05\x04\x05\x02\x01\x03\x12\x04\xf3\x01\"#\n'\n\
    \x02\x04\x06\x12\x06\xf7\x01\0\x91\x02\x01\x1a\x19\x20Describes\x20an\
    \x20enum\x20type.\n\n\x0b\n\x03\x04\x06\x01\x12\x04\xf7\x01\x08\x1b\n\
    \x0c\n\x04\x04\x06\x02\0\x12\x04\xf8\x01\x02\x1b\n\r\n\x05\x04\x06\x02\0\
    \x04\x12\x04\xf8\x01\x02\n\n\r\n\x05\x04\x06\x02\0\x05\x12\x04\xf8\x01\
    \x0b\x11\n\r\n\x05\x04\x06\x02\0\x01\x12\x04\xf8\x01\x12\x16\n\r\n\x05\
    \x04\x06\x02\0\x03\x12\x04\xf8\x01\x19\x1a\n\x0c\n\x04\x04\x06\x02\x01\
    \x12\x04\xfa\x01\x02.\n\r\n\x05\x04\x06\x02\x01\x04\x12\x04\xfa\x01\x02\
    \n\n\r\n\x05\x04\x06\x02\x01\x06\x12\x04\xfa\x01\x0b#\n\r\n\x05\x04\x06\
    \x02\x01\x01\x12\x04\xfa\x01$)\n\r\n\x05\x04\x06\x02\x01\x03\x12\x04\xfa\
    \x01,-\n\x0c\n\x04\x04\x06\x02\x02\x12\x04\xfc\x01\x02#\n\r\n\x05\x04\
    \x06\x02\x02\x04\x12\x04\xfc\x01\x02\n\n\r\n\x05\x04\x06\x02\x02\x06\x12\
    \x04\xfc\x01\x0b\x16\n\r\n\x05\x04\x06\x02\x02\x01\x12\x04\xfc\x01\x17\
    \x1e\n\r\n\x05\x04\x06\x02\x02\x03\x12\x04\xfc\x01!\"\n\xaf\x02\n\x04\
    \x04\x06\x03\0\x12\x06\x84\x02\x02\x87\x02\x03\x1a\x9e\x02\x20Range\x20o\
    f\x20reserved\x20numeric\x20values.\x20Reserved\x20values\x20may\x20not\
    \x20be\x20used\x20by\n\x20entries\x20in\x20the\x20same\x20enum.\x20Reser\
    ved\x20ranges\x20may\x20not\x20overlap.\n\n\x20Note\x20that\x20this\x20i\
    s\x20distinct\x20from\x20DescriptorProto.ReservedRange\x20in\x20that\x20\
    it\n\x20is\x20inclusive\x20such\x20that\x20it\x20can\x20appropriately\
    \x20represent\x20the\x20entire\x20int32\n\x20domain.\n\n\r\n\x05\x04\x06\
    \x03\0\x01\x12\x04\x84\x02\n\x1b\n\x1c\n\x06\x04\x06\x03\0\x02\0\x12\x04\
    \x85\x02\x04\x1d\"\x0c\x20Inclusive.\n\n\x0f\n\x07\x04\x06\x03\0\x02\0\
    \x04\x12\x04\x85\x02\x04\x0c\n\x0f\n\x07\x04\x06\x03\0\x02\0\x05\x12\x04\
    \x85\x02\r\x12\n\x0f\n\x07\x04\x06\x03\0\x02\0\x01\x12\x04\x85\x02\x13\
    \x18\n\x0f\n\x07\x04\x06\x03\0\x02\0\x03\x12\x04\x85\x02\x1b\x1c\n\x1c\n\
    \x06\x04\x06\x03\0\x02\x01\x12\x04\x86\x02\x04\x1b\"\x0c\x20Inclusive.\n\
    \n\x0f\n\x07\x04\x06\x03\0\x02\x01\x04\x12\x04\x86\x02\x04\x0c\n\x0f\n\
    \x07\x04\x06\x03\0\x02\x01\x05\x12\x04\x86\x02\r\x12\n\x0f\n\x07\x04\x06\
    \x03\0\x02\x01\x01\x12\x04\x86\x02\x13\x16\n\x0f\n\x07\x04\x06\x03\0\x02\
    \x01\x03\x12\x04\x86\x02\x19\x1a\n\xaa\x01\n\x04\x04\x06\x02\x03\x12\x04\
    \x8c\x02\x020\x1a\x9b\x01\x20Range\x20of\x20reserved\x20numeric\x20value\
    s.\x20Reserved\x20numeric\x20values\x20may\x20not\x20be\x20used\n\x20by\
    \x20enum\x20values\x20in\x20the\x20same\x20enum\x20declaration.\x20Reser\
    ved\x20ranges\x20may\x20not\n\x20overlap.\n\n\r\n\x05\x04\x06\x02\x03\
    \x04\x12\x04\x8c\x02\x02\n\n\r\n\x05\x04\x06\x02\x03\x06\x12\x04\x8c\x02\
    \x0b\x1c\n\r\n\x05\x04\x06\x02\x03\x01\x12\x04\x8c\x02\x1d+\n\r\n\x05\
    \x04\x06\x02\x03\x03\x12\x04\x8c\x02./\nl\n\x04\x04\x06\x02\x04\x12\x04\
    \x90\x02\x02$\x1a^\x20Reserved\x20enum\x20value\x20names,\x20which\x20ma\
    y\x20not\x20be\x20reused.\x20A\x20given\x20name\x20may\x20only\n\x20be\
    \x20reserved\x20once.\n\n\r\n\x05\x04\x06\x02\x04\x04\x12\x04\x90\x02\
    \x02\n\n\r\n\x05\x04\x06\x02\x04\x05\x12\x04\x90\x02\x0b\x11\n\r\n\x05\
    \x04\x06\x02\x04\x01\x12\x04\x90\x02\x12\x1f\n\r\n\x05\x04\x06\x02\x04\
    \x03\x12\x04\x90\x02\"#\n1\n\x02\x04\x07\x12\x06\x94\x02\0\x99\x02\x01\
    \x1a#\x20Describes\x20a\x20value\x20within\x20an\x20enum.\n\n\x0b\n\x03\
    \x04\x07\x01\x12\x04\x94\x02\x08\x20\n\x0c\n\x04\x04\x07\x02\0\x12\x04\
    \x95\x02\x02\x1b\n\r\n\x05\x04\x07\x02\0\x04\x12\x04\x95\x02\x02\n\n\r\n\
    \x05\x04\x07\x02\0\x05\x12\x04\x95\x02\x0b\x11\n\r\n\x05\x04\x07\x02\0\
    \x01\x12\x04\x95\x02\x12\x16\n\r\n\x05\x04\x07\x02\0\x03\x12\x04\x95\x02\
    \x19\x1a\n\x0c\n\x04\x04\x07\x02\x01\x12\x04\x96\x02\x02\x1c\n\r\n\x05\
    \x04\x07\x02\x01\x04\x12\x04\x96\x02\x02\n\n\r\n\x05\x04\x07\x02\x01\x05\
    \x12\x04\x96\x02\x0b\x10\n\r\n\x05\x04\x07\x02\x01\x01\x12\x04\x96\x02\
    \x11\x17\n\r\n\x05\x04\x07\x02\x01\x03\x12\x04\x96\x02\x1a\x1b\n\x0c\n\
    \x04\x04\x07\x02\x02\x12\x04\x98\x02\x02(\n\r\n\x05\x04\x07\x02\x02\x04\
    \x12\x04\x98\x02\x02\n\n\r\n\x05\x04\x07\x02\x02\x06\x12\x04\x98\x02\x0b\
    \x1b\n\r\n\x05\x04\x07\x02\x02\x01\x12\x04\x98\x02\x1c#\n\r\n\x05\x04\
    \x07\x02\x02\x03\x12\x04\x98\x02&'\n$\n\x02\x04\x08\x12\x06\x9c\x02\0\
    \xa1\x02\x01\x1a\x16\x20Describes\x20a\x20service.\n\n\x0b\n\x03\x04\x08\
    \x01\x12\x04\x9c\x02\x08\x1e\n\x0c\n\x04\x04\x08\x02\0\x12\x04\x9d\x02\
    \x02\x1b\n\r\n\x05\x04\x08\x02\0\x04\x12\x04\x9d\x02\x02\n\n\r\n\x05\x04\
    \x08\x02\0\x05\x12\x04\x9d\x02\x0b\x11\n\r\n\x05\x04\x08\x02\0\x01\x12\
    \x04\x9d\x02\x12\x16\n\r\n\x05\x04\x08\x02\0\x03\x12\x04\x9d\x02\x19\x1a\
    \n\x0c\n\x04\x04\x08\x02\x01\x12\x04\x9e\x02\x02,\n\r\n\x05\x04\x08\x02\
    \x01\x04\x12\x04\x9e\x02\x02\n\n\r\n\x05\x04\x08\x02\x01\x06\x12\x04\x9e\
    \x02\x0b\x20\n\r\n\x05\x04\x08\x02\x01\x01\x12\x04\x9e\x02!'\n\r\n\x05\
    \x04\x08\x02\x01\x03\x12\x04\x9e\x02*+\n\x0c\n\x04\x04\x08\x02\x02\x12\
    \x04\xa0\x02\x02&\n\r\n\x05\x04\x08\x02\x02\x04\x12\x04\xa0\x02\x02\n\n\
    \r\n\x05\x04\x08\x02\x02\x06\x12\x04\xa0\x02\x0b\x19\n\r\n\x05\x04\x08\
    \x02\x02\x01\x12\x04\xa0\x02\x1a!\n\r\n\x05\x04\x08\x02\x02\x03\x12\x04\
    \xa0\x02$%\n0\n\x02\x04\t\x12\x06\xa4\x02\0\xb2\x02\x01\x1a\"\x20Describ\
    es\x20a\x20method\x20of\x20a\x20service.\n\n\x0b\n\x03\x04\t\x01\x12\x04\
    \xa4\x02\x08\x1d\n\x0c\n\x04\x04\t\x02\0\x12\x04\xa5\x02\x02\x1b\n\r\n\
    \x05\x04\t\x02\0\x04\x12\x04\xa5\x02\x02\n\n\r\n\x05\x04\t\x02\0\x05\x12\
    \x04\xa5\x02\x0b\x11\n\r\n\x05\x04\t\x02\0\x01\x12\x04\xa5\x02\x12\x16\n\
    \r\n\x05\x04\t\x02\0\x03\x12\x04\xa5\x02\x19\x1a\n\x97\x01\n\x04\x04\t\
    \x02\x01\x12\x04\xa9\x02\x02!\x1a\x88\x01\x20Input\x20and\x20output\x20t\
    ype\x20names.\x20\x20These\x20are\x20resolved\x20in\x20the\x20same\x20wa\
    y\x20as\n\x20FieldDescriptorProto.type_name,\x20but\x20must\x20refer\x20\
    to\x20a\x20message\x20type.\n\n\r\n\x05\x04\t\x02\x01\x04\x12\x04\xa9\
    \x02\x02\n\n\r\n\x05\x04\t\x02\x01\x05\x12\x04\xa9\x02\x0b\x11\n\r\n\x05\
    \x04\t\x02\x01\x01\x12\x04\xa9\x02\x12\x1c\n\r\n\x05\x04\t\x02\x01\x03\
    \x12\x04\xa9\x02\x1f\x20\n\x0c\n\x04\x04\t\x02\x02\x12\x04\xaa\x02\x02\"\
    \n\r\n\x05\x04\t\x02\x02\x04\x12\x04\xaa\x02\x02\n\n\r\n\x05\x04\t\x02\
    \x02\x05\x12\x04\xaa\x02\x0b\x11\n\r\n\x05\x04\t\x02\x02\x01\x12\x04\xaa\
    \x02\x12\x1d\n\r\n\x05\x04\t\x02\x02\x03\x12\x04\xaa\x02\x20!\n\x0c\n\
    \x04\x04\t\x02\x03\x12\x04\xac\x02\x02%\n\r\n\x05\x04\t\x02\x03\x04\x12\
    \x04\xac\x02\x02\n\n\r\n\x05\x04\t\x02\x03\x06\x12\x04\xac\x02\x0b\x18\n\
    \r\n\x05\x04\t\x02\x03\x01\x12\x04\xac\x02\x19\x20\n\r\n\x05\x04\t\x02\
    \x03\x03\x12\x04\xac\x02#$\nE\n\x04\x04\t\x02\x04\x12\x04\xaf\x02\x027\
    \x1a7\x20Identifies\x20if\x20client\x20streams\x20multiple\x20client\x20\
    messages\n\n\r\n\x05\x04\t\x02\x04\x04\x12\x04\xaf\x02\x02\n\n\r\n\x05\
    \x04\t\x02\x04\x05\x12\x04\xaf\x02\x0b\x0f\n\r\n\x05\x04\t\x02\x04\x01\
    \x12\x04\xaf\x02\x10\x20\n\r\n\x05\x04\t\x02\x04\x03\x12\x04\xaf\x02#$\n\
    \r\n\x05\x04\t\x02\x04\x08\x12\x04\xaf\x02%6\n\r\n\x05\x04\t\x02\x04\x07\
    \x12\x04\xaf\x0205\nE\n\x04\x04\t\x02\x05\x12\x04\xb1\x02\x027\x1a7\x20I\
    dentifies\x20if\x20server\x20streams\x20multiple\x20server\x20messages\n\
    \n\r\n\x05\x04\t\x02\x05\x04\x12\x04\xb1\x02\x02\n\n\r\n\x05\x04\t\x02\
    \x05\x05\x12\x04\xb1\x02\x0b\x0f\n\r\n\x05\x04\t\x02\x05\x01\x12\x04\xb1\
    \x02\x10\x20\n\r\n\x05\x04\t\x02\x05\x03\x12\x04\xb1\x02#$\n\r\n\x05\x04\
    \t\x02\x05\x08\x12\x04\xb1\x02%6\n\r\n\x05\x04\t\x02\x05\x07\x12\x04\xb1\
    \x0205\n\xaf\x0e\n\x02\x04\n\x12\x06\xd5\x02\0\xd0\x03\x012N\x20========\
    ===========================================================\n\x20Options\
    \n2\xd0\r\x20Each\x20of\x20the\x20definitions\x20above\x20may\x20have\
    \x20\"options\"\x20attached.\x20\x20These\x20are\n\x20just\x20annotation\
    s\x20which\x20may\x20cause\x20code\x20to\x20be\x20generated\x20slightly\
    \x20differently\n\x20or\x20may\x20contain\x20hints\x20for\x20code\x20tha\
    t\x20manipulates\x20protocol\x20messages.\n\n\x20Clients\x20may\x20defin\
    e\x20custom\x20options\x20as\x20extensions\x20of\x20the\x20*Options\x20m\
    essages.\n\x20These\x20extensions\x20may\x20not\x20yet\x20be\x20known\
    \x20at\x20parsing\x20time,\x20so\x20the\x20parser\x20cannot\n\x20store\
    \x20the\x20values\x20in\x20them.\x20\x20Instead\x20it\x20stores\x20them\
    \x20in\x20a\x20field\x20in\x20the\x20*Options\n\x20message\x20called\x20\
    uninterpreted_option.\x20This\x20field\x20must\x20have\x20the\x20same\
    \x20name\n\x20across\x20all\x20*Options\x20messages.\x20We\x20then\x20us\
    e\x20this\x20field\x20to\x20populate\x20the\n\x20extensions\x20when\x20w\
    e\x20build\x20a\x20descriptor,\x20at\x20which\x20point\x20all\x20protos\
    \x20have\x20been\n\x20parsed\x20and\x20so\x20all\x20extensions\x20are\
    \x20known.\n\n\x20Extension\x20numbers\x20for\x20custom\x20options\x20ma\
    y\x20be\x20chosen\x20as\x20follows:\n\x20*\x20For\x20options\x20which\
    \x20will\x20only\x20be\x20used\x20within\x20a\x20single\x20application\
    \x20or\n\x20\x20\x20organization,\x20or\x20for\x20experimental\x20option\
    s,\x20use\x20field\x20numbers\x2050000\n\x20\x20\x20through\x2099999.\
    \x20\x20It\x20is\x20up\x20to\x20you\x20to\x20ensure\x20that\x20you\x20do\
    \x20not\x20use\x20the\n\x20\x20\x20same\x20number\x20for\x20multiple\x20\
    options.\n\x20*\x20For\x20options\x20which\x20will\x20be\x20published\
    \x20and\x20used\x20publicly\x20by\x20multiple\n\x20\x20\x20independent\
    \x20entities,\x20e-mail\x20protobuf-global-extension-registry@google.com\
    \n\x20\x20\x20to\x20reserve\x20extension\x20numbers.\x20Simply\x20provid\
    e\x20your\x20project\x20name\x20(e.g.\n\x20\x20\x20Objective-C\x20plugin\
    )\x20and\x20your\x20project\x20website\x20(if\x20available)\x20--\x20the\
    re's\x20no\n\x20\x20\x20need\x20to\x20explain\x20how\x20you\x20intend\
    \x20to\x20use\x20them.\x20Usually\x20you\x20only\x20need\x20one\n\x20\
    \x20\x20extension\x20number.\x20You\x20can\x20declare\x20multiple\x20opt\
    ions\x20with\x20only\x20one\x20extension\n\x20\x20\x20number\x20by\x20pu\
    tting\x20them\x20in\x20a\x20sub-message.\x20See\x20the\x20Custom\x20Opti\
    ons\x20section\x20of\n\x20\x20\x20the\x20docs\x20for\x20examples:\n\x20\
    \x20\x20https://developers.google.com/protocol-buffers/docs/proto#option\
    s\n\x20\x20\x20If\x20this\x20turns\x20out\x20to\x20be\x20popular,\x20a\
    \x20web\x20service\x20will\x20be\x20set\x20up\n\x20\x20\x20to\x20automat\
    ically\x20assign\x20option\x20numbers.\n\n\x0b\n\x03\x04\n\x01\x12\x04\
    \xd5\x02\x08\x13\n\xf4\x01\n\x04\x04\n\x02\0\x12\x04\xdb\x02\x02#\x1a\
    \xe5\x01\x20Sets\x20the\x20Java\x20package\x20where\x20classes\x20genera\
    ted\x20from\x20this\x20.proto\x20will\x20be\n\x20placed.\x20\x20By\x20de\
    fault,\x20the\x20proto\x20package\x20is\x20used,\x20but\x20this\x20is\
    \x20often\n\x20inappropriate\x20because\x20proto\x20packages\x20do\x20no\
    t\x20normally\x20start\x20with\x20backwards\n\x20domain\x20names.\n\n\r\
    \n\x05\x04\n\x02\0\x04\x12\x04\xdb\x02\x02\n\n\r\n\x05\x04\n\x02\0\x05\
    \x12\x04\xdb\x02\x0b\x11\n\r\n\x05\x04\n\x02\0\x01\x12\x04\xdb\x02\x12\
    \x1e\n\r\n\x05\x04\n\x02\0\x03\x12\x04\xdb\x02!\"\n\xf1\x02\n\x04\x04\n\
    \x02\x01\x12\x04\xe3\x02\x02+\x1a\xe2\x02\x20Controls\x20the\x20name\x20\
    of\x20the\x20wrapper\x20Java\x20class\x20generated\x20for\x20the\x20.pro\
    to\x20file.\n\x20That\x20class\x20will\x20always\x20contain\x20the\x20.p\
    roto\x20file's\x20getDescriptor()\x20method\x20as\n\x20well\x20as\x20any\
    \x20top-level\x20extensions\x20defined\x20in\x20the\x20.proto\x20file.\n\
    \x20If\x20java_multiple_files\x20is\x20disabled,\x20then\x20all\x20the\
    \x20other\x20classes\x20from\x20the\n\x20.proto\x20file\x20will\x20be\
    \x20nested\x20inside\x20the\x20single\x20wrapper\x20outer\x20class.\n\n\
    \r\n\x05\x04\n\x02\x01\x04\x12\x04\xe3\x02\x02\n\n\r\n\x05\x04\n\x02\x01\
    \x05\x12\x04\xe3\x02\x0b\x11\n\r\n\x05\x04\n\x02\x01\x01\x12\x04\xe3\x02\
    \x12&\n\r\n\x05\x04\n\x02\x01\x03\x12\x04\xe3\x02)*\n\xa6\x03\n\x04\x04\
    \n\x02\x02\x12\x04\xeb\x02\x02;\x1a\x97\x03\x20If\x20enabled,\x20then\
    \x20the\x20Java\x20code\x20generator\x20will\x20generate\x20a\x20separat\
    e\x20.java\n\x20file\x20for\x20each\x20top-level\x20message,\x20enum,\
    \x20and\x20service\x20defined\x20in\x20the\x20.proto\n\x20file.\x20\x20T\
    hus,\x20these\x20types\x20will\x20*not*\x20be\x20nested\x20inside\x20the\
    \x20wrapper\x20class\n\x20named\x20by\x20java_outer_classname.\x20\x20Ho\
    wever,\x20the\x20wrapper\x20class\x20will\x20still\x20be\n\x20generated\
    \x20to\x20contain\x20the\x20file's\x20getDescriptor()\x20method\x20as\
    \x20well\x20as\x20any\n\x20top-level\x20extensions\x20defined\x20in\x20t\
    he\x20file.\n\n\r\n\x05\x04\n\x02\x02\x04\x12\x04\xeb\x02\x02\n\n\r\n\
    \x05\x04\n\x02\x02\x05\x12\x04\xeb\x02\x0b\x0f\n\r\n\x05\x04\n\x02\x02\
    \x01\x12\x04\xeb\x02\x10#\n\r\n\x05\x04\n\x02\x02\x03\x12\x04\xeb\x02&(\
    \n\r\n\x05\x04\n\x02\x02\x08\x12\x04\xeb\x02):\n\r\n\x05\x04\n\x02\x02\
    \x07\x12\x04\xeb\x0249\n)\n\x04\x04\n\x02\x03\x12\x04\xee\x02\x02E\x1a\
    \x1b\x20This\x20option\x20does\x20nothing.\n\n\r\n\x05\x04\n\x02\x03\x04\
    \x12\x04\xee\x02\x02\n\n\r\n\x05\x04\n\x02\x03\x05\x12\x04\xee\x02\x0b\
    \x0f\n\r\n\x05\x04\n\x02\x03\x01\x12\x04\xee\x02\x10-\n\r\n\x05\x04\n\
    \x02\x03\x03\x12\x04\xee\x0202\n\r\n\x05\x04\n\x02\x03\x08\x12\x04\xee\
    \x023D\n\x0e\n\x06\x04\n\x02\x03\x08\x03\x12\x04\xee\x024C\n\xe6\x02\n\
    \x04\x04\n\x02\x04\x12\x04\xf6\x02\x02>\x1a\xd7\x02\x20If\x20set\x20true\
    ,\x20then\x20the\x20Java2\x20code\x20generator\x20will\x20generate\x20co\
    de\x20that\n\x20throws\x20an\x20exception\x20whenever\x20an\x20attempt\
    \x20is\x20made\x20to\x20assign\x20a\x20non-UTF-8\n\x20byte\x20sequence\
    \x20to\x20a\x20string\x20field.\n\x20Message\x20reflection\x20will\x20do\
    \x20the\x20same.\n\x20However,\x20an\x20extension\x20field\x20still\x20a\
    ccepts\x20non-UTF-8\x20byte\x20sequences.\n\x20This\x20option\x20has\x20\
    no\x20effect\x20on\x20when\x20used\x20with\x20the\x20lite\x20runtime.\n\
    \n\r\n\x05\x04\n\x02\x04\x04\x12\x04\xf6\x02\x02\n\n\r\n\x05\x04\n\x02\
    \x04\x05\x12\x04\xf6\x02\x0b\x0f\n\r\n\x05\x04\n\x02\x04\x01\x12\x04\xf6\
    \x02\x10&\n\r\n\x05\x04\n\x02\x04\x03\x12\x04\xf6\x02)+\n\r\n\x05\x04\n\
    \x02\x04\x08\x12\x04\xf6\x02,=\n\r\n\x05\x04\n\x02\x04\x07\x12\x04\xf6\
    \x027<\nL\n\x04\x04\n\x04\0\x12\x06\xfa\x02\x02\xff\x02\x03\x1a<\x20Gene\
    rated\x20classes\x20can\x20be\x20optimized\x20for\x20speed\x20or\x20code\
    \x20size.\n\n\r\n\x05\x04\n\x04\0\x01\x12\x04\xfa\x02\x07\x13\nD\n\x06\
    \x04\n\x04\0\x02\0\x12\x04\xfb\x02\x04\x0e\"4\x20Generate\x20complete\
    \x20code\x20for\x20parsing,\x20serialization,\n\n\x0f\n\x07\x04\n\x04\0\
    \x02\0\x01\x12\x04\xfb\x02\x04\t\n\x0f\n\x07\x04\n\x04\0\x02\0\x02\x12\
    \x04\xfb\x02\x0c\r\nG\n\x06\x04\n\x04\0\x02\x01\x12\x04\xfd\x02\x04\x12\
    \x1a\x06\x20etc.\n\"/\x20Use\x20ReflectionOps\x20to\x20implement\x20thes\
    e\x20methods.\n\n\x0f\n\x07\x04\n\x04\0\x02\x01\x01\x12\x04\xfd\x02\x04\
    \r\n\x0f\n\x07\x04\n\x04\0\x02\x01\x02\x12\x04\xfd\x02\x10\x11\nG\n\x06\
    \x04\n\x04\0\x02\x02\x12\x04\xfe\x02\x04\x15\"7\x20Generate\x20code\x20u\
    sing\x20MessageLite\x20and\x20the\x20lite\x20runtime.\n\n\x0f\n\x07\x04\
    \n\x04\0\x02\x02\x01\x12\x04\xfe\x02\x04\x10\n\x0f\n\x07\x04\n\x04\0\x02\
    \x02\x02\x12\x04\xfe\x02\x13\x14\n\x0c\n\x04\x04\n\x02\x05\x12\x04\x80\
    \x03\x02;\n\r\n\x05\x04\n\x02\x05\x04\x12\x04\x80\x03\x02\n\n\r\n\x05\
    \x04\n\x02\x05\x06\x12\x04\x80\x03\x0b\x17\n\r\n\x05\x04\n\x02\x05\x01\
    \x12\x04\x80\x03\x18$\n\r\n\x05\x04\n\x02\x05\x03\x12\x04\x80\x03'(\n\r\
    \n\x05\x04\n\x02\x05\x08\x12\x04\x80\x03):\n\r\n\x05\x04\n\x02\x05\x07\
    \x12\x04\x80\x0349\n\xe2\x02\n\x04\x04\n\x02\x06\x12\x04\x87\x03\x02\"\
    \x1a\xd3\x02\x20Sets\x20the\x20Go\x20package\x20where\x20structs\x20gene\
    rated\x20from\x20this\x20.proto\x20will\x20be\n\x20placed.\x20If\x20omit\
    ted,\x20the\x20Go\x20package\x20will\x20be\x20derived\x20from\x20the\x20\
    following:\n\x20\x20\x20-\x20The\x20basename\x20of\x20the\x20package\x20\
    import\x20path,\x20if\x20provided.\n\x20\x20\x20-\x20Otherwise,\x20the\
    \x20package\x20statement\x20in\x20the\x20.proto\x20file,\x20if\x20presen\
    t.\n\x20\x20\x20-\x20Otherwise,\x20the\x20basename\x20of\x20the\x20.prot\
    o\x20file,\x20without\x20extension.\n\n\r\n\x05\x04\n\x02\x06\x04\x12\
    \x04\x87\x03\x02\n\n\r\n\x05\x04\n\x02\x06\x05\x12\x04\x87\x03\x0b\x11\n\
    \r\n\x05\x04\n\x02\x06\x01\x12\x04\x87\x03\x12\x1c\n\r\n\x05\x04\n\x02\
    \x06\x03\x12\x04\x87\x03\x1f!\n\xd4\x04\n\x04\x04\n\x02\x07\x12\x04\x96\
    \x03\x02;\x1a\xc5\x04\x20Should\x20generic\x20services\x20be\x20generate\
    d\x20in\x20each\x20language?\x20\x20\"Generic\"\x20services\n\x20are\x20\
    not\x20specific\x20to\x20any\x20particular\x20RPC\x20system.\x20\x20They\
    \x20are\x20generated\x20by\x20the\n\x20main\x20code\x20generators\x20in\
    \x20each\x20language\x20(without\x20additional\x20plugins).\n\x20Generic\
    \x20services\x20were\x20the\x20only\x20kind\x20of\x20service\x20generati\
    on\x20supported\x20by\n\x20early\x20versions\x20of\x20google.protobuf.\n\
    \n\x20Generic\x20services\x20are\x20now\x20considered\x20deprecated\x20i\
    n\x20favor\x20of\x20using\x20plugins\n\x20that\x20generate\x20code\x20sp\
    ecific\x20to\x20your\x20particular\x20RPC\x20system.\x20\x20Therefore,\n\
    \x20these\x20default\x20to\x20false.\x20\x20Old\x20code\x20which\x20depe\
    nds\x20on\x20generic\x20services\x20should\n\x20explicitly\x20set\x20the\
    m\x20to\x20true.\n\n\r\n\x05\x04\n\x02\x07\x04\x12\x04\x96\x03\x02\n\n\r\
    \n\x05\x04\n\x02\x07\x05\x12\x04\x96\x03\x0b\x0f\n\r\n\x05\x04\n\x02\x07\
    \x01\x12\x04\x96\x03\x10#\n\r\n\x05\x04\n\x02\x07\x03\x12\x04\x96\x03&(\
    \n\r\n\x05\x04\n\x02\x07\x08\x12\x04\x96\x03):\n\r\n\x05\x04\n\x02\x07\
    \x07\x12\x04\x96\x0349\n\x0c\n\x04\x04\n\x02\x08\x12\x04\x97\x03\x02=\n\
    \r\n\x05\x04\n\x02\x08\x04\x12\x04\x97\x03\x02\n\n\r\n\x05\x04\n\x02\x08\
    \x05\x12\x04\x97\x03\x0b\x0f\n\r\n\x05\x04\n\x02\x08\x01\x12\x04\x97\x03\
    \x10%\n\r\n\x05\x04\n\x02\x08\x03\x12\x04\x97\x03(*\n\r\n\x05\x04\n\x02\
    \x08\x08\x12\x04\x97\x03+<\n\r\n\x05\x04\n\x02\x08\x07\x12\x04\x97\x036;\
    \n\x0c\n\x04\x04\n\x02\t\x12\x04\x98\x03\x02;\n\r\n\x05\x04\n\x02\t\x04\
    \x12\x04\x98\x03\x02\n\n\r\n\x05\x04\n\x02\t\x05\x12\x04\x98\x03\x0b\x0f\
    \n\r\n\x05\x04\n\x02\t\x01\x12\x04\x98\x03\x10#\n\r\n\x05\x04\n\x02\t\
    \x03\x12\x04\x98\x03&(\n\r\n\x05\x04\n\x02\t\x08\x12\x04\x98\x03):\n\r\n\
    \x05\x04\n\x02\t\x07\x12\x04\x98\x0349\n\x0c\n\x04\x04\n\x02\n\x12\x04\
    \x99\x03\x02<\n\r\n\x05\x04\n\x02\n\x04\x12\x04\x99\x03\x02\n\n\r\n\x05\
    \x04\n\x02\n\x05\x12\x04\x99\x03\x0b\x0f\n\r\n\x05\x04\n\x02\n\x01\x12\
    \x04\x99\x03\x10$\n\r\n\x05\x04\n\x02\n\x03\x12\x04\x99\x03')\n\r\n\x05\
    \x04\n\x02\n\x08\x12\x04\x99\x03*;\n\r\n\x05\x04\n\x02\n\x07\x12\x04\x99\
    \x035:\n\xf3\x01\n\x04\x04\n\x02\x0b\x12\x04\x9f\x03\x022\x1a\xe4\x01\
    \x20Is\x20this\x20file\x20deprecated?\n\x20Depending\x20on\x20the\x20tar\
    get\x20platform,\x20this\x20can\x20emit\x20Deprecated\x20annotations\n\
    \x20for\x20everything\x20in\x20the\x20file,\x20or\x20it\x20will\x20be\
    \x20completely\x20ignored;\x20in\x20the\x20very\n\x20least,\x20this\x20i\
    s\x20a\x20formalization\x20for\x20deprecating\x20files.\n\n\r\n\x05\x04\
    \n\x02\x0b\x04\x12\x04\x9f\x03\x02\n\n\r\n\x05\x04\n\x02\x0b\x05\x12\x04\
    \x9f\x03\x0b\x0f\n\r\n\x05\x04\n\x02\x0b\x01\x12\x04\x9f\x03\x10\x1a\n\r\
    \n\x05\x04\n\x02\x0b\x03\x12\x04\x9f\x03\x1d\x1f\n\r\n\x05\x04\n\x02\x0b\
    \x08\x12\x04\x9f\x03\x201\n\r\n\x05\x04\n\x02\x0b\x07\x12\x04\x9f\x03+0\
    \n\x7f\n\x04\x04\n\x02\x0c\x12\x04\xa3\x03\x027\x1aq\x20Enables\x20the\
    \x20use\x20of\x20arenas\x20for\x20the\x20proto\x20messages\x20in\x20this\
    \x20file.\x20This\x20applies\n\x20only\x20to\x20generated\x20classes\x20\
    for\x20C++.\n\n\r\n\x05\x04\n\x02\x0c\x04\x12\x04\xa3\x03\x02\n\n\r\n\
    \x05\x04\n\x02\x0c\x05\x12\x04\xa3\x03\x0b\x0f\n\r\n\x05\x04\n\x02\x0c\
    \x01\x12\x04\xa3\x03\x10\x20\n\r\n\x05\x04\n\x02\x0c\x03\x12\x04\xa3\x03\
    #%\n\r\n\x05\x04\n\x02\x0c\x08\x12\x04\xa3\x03&6\n\r\n\x05\x04\n\x02\x0c\
    \x07\x12\x04\xa3\x0315\n\x92\x01\n\x04\x04\n\x02\r\x12\x04\xa8\x03\x02)\
    \x1a\x83\x01\x20Sets\x20the\x20objective\x20c\x20class\x20prefix\x20whic\
    h\x20is\x20prepended\x20to\x20all\x20objective\x20c\n\x20generated\x20cl\
    asses\x20from\x20this\x20.proto.\x20There\x20is\x20no\x20default.\n\n\r\
    \n\x05\x04\n\x02\r\x04\x12\x04\xa8\x03\x02\n\n\r\n\x05\x04\n\x02\r\x05\
    \x12\x04\xa8\x03\x0b\x11\n\r\n\x05\x04\n\x02\r\x01\x12\x04\xa8\x03\x12#\
    \n\r\n\x05\x04\n\x02\r\x03\x12\x04\xa8\x03&(\nI\n\x04\x04\n\x02\x0e\x12\
    \x04\xab\x03\x02(\x1a;\x20Namespace\x20for\x20generated\x20classes;\x20d\
    efaults\x20to\x20the\x20package.\n\n\r\n\x05\x04\n\x02\x0e\x04\x12\x04\
    \xab\x03\x02\n\n\r\n\x05\x04\n\x02\x0e\x05\x12\x04\xab\x03\x0b\x11\n\r\n\
    \x05\x04\n\x02\x0e\x01\x12\x04\xab\x03\x12\"\n\r\n\x05\x04\n\x02\x0e\x03\
    \x12\x04\xab\x03%'\n\x91\x02\n\x04\x04\n\x02\x0f\x12\x04\xb1\x03\x02$\
    \x1a\x82\x02\x20By\x20default\x20Swift\x20generators\x20will\x20take\x20\
    the\x20proto\x20package\x20and\x20CamelCase\x20it\n\x20replacing\x20'.'\
    \x20with\x20underscore\x20and\x20use\x20that\x20to\x20prefix\x20the\x20t\
    ypes/symbols\n\x20defined.\x20When\x20this\x20options\x20is\x20provided,\
    \x20they\x20will\x20use\x20this\x20value\x20instead\n\x20to\x20prefix\
    \x20the\x20types/symbols\x20defined.\n\n\r\n\x05\x04\n\x02\x0f\x04\x12\
    \x04\xb1\x03\x02\n\n\r\n\x05\x04\n\x02\x0f\x05\x12\x04\xb1\x03\x0b\x11\n\
    \r\n\x05\x04\n\x02\x0f\x01\x12\x04\xb1\x03\x12\x1e\n\r\n\x05\x04\n\x02\
    \x0f\x03\x12\x04\xb1\x03!#\n~\n\x04\x04\n\x02\x10\x12\x04\xb5\x03\x02(\
    \x1ap\x20Sets\x20the\x20php\x20class\x20prefix\x20which\x20is\x20prepend\
    ed\x20to\x20all\x20php\x20generated\x20classes\n\x20from\x20this\x20.pro\
    to.\x20Default\x20is\x20empty.\n\n\r\n\x05\x04\n\x02\x10\x04\x12\x04\xb5\
    \x03\x02\n\n\r\n\x05\x04\n\x02\x10\x05\x12\x04\xb5\x03\x0b\x11\n\r\n\x05\
    \x04\n\x02\x10\x01\x12\x04\xb5\x03\x12\"\n\r\n\x05\x04\n\x02\x10\x03\x12\
    \x04\xb5\x03%'\n\xbe\x01\n\x04\x04\n\x02\x11\x12\x04\xba\x03\x02%\x1a\
    \xaf\x01\x20Use\x20this\x20option\x20to\x20change\x20the\x20namespace\
    \x20of\x20php\x20generated\x20classes.\x20Default\n\x20is\x20empty.\x20W\
    hen\x20this\x20option\x20is\x20empty,\x20the\x20package\x20name\x20will\
    \x20be\x20used\x20for\n\x20determining\x20the\x20namespace.\n\n\r\n\x05\
    \x04\n\x02\x11\x04\x12\x04\xba\x03\x02\n\n\r\n\x05\x04\n\x02\x11\x05\x12\
    \x04\xba\x03\x0b\x11\n\r\n\x05\x04\n\x02\x11\x01\x12\x04\xba\x03\x12\x1f\
    \n\r\n\x05\x04\n\x02\x11\x03\x12\x04\xba\x03\"$\n\xca\x01\n\x04\x04\n\
    \x02\x12\x12\x04\xbf\x03\x02.\x1a\xbb\x01\x20Use\x20this\x20option\x20to\
    \x20change\x20the\x20namespace\x20of\x20php\x20generated\x20metadata\x20\
    classes.\n\x20Default\x20is\x20empty.\x20When\x20this\x20option\x20is\
    \x20empty,\x20the\x20proto\x20file\x20name\x20will\x20be\n\x20used\x20fo\
    r\x20determining\x20the\x20namespace.\n\n\r\n\x05\x04\n\x02\x12\x04\x12\
    \x04\xbf\x03\x02\n\n\r\n\x05\x04\n\x02\x12\x05\x12\x04\xbf\x03\x0b\x11\n\
    \r\n\x05\x04\n\x02\x12\x01\x12\x04\xbf\x03\x12(\n\r\n\x05\x04\n\x02\x12\
    \x03\x12\x04\xbf\x03+-\n\xc2\x01\n\x04\x04\n\x02\x13\x12\x04\xc4\x03\x02\
    $\x1a\xb3\x01\x20Use\x20this\x20option\x20to\x20change\x20the\x20package\
    \x20of\x20ruby\x20generated\x20classes.\x20Default\n\x20is\x20empty.\x20\
    When\x20this\x20option\x20is\x20not\x20set,\x20the\x20package\x20name\
    \x20will\x20be\x20used\x20for\n\x20determining\x20the\x20ruby\x20package\
    .\n\n\r\n\x05\x04\n\x02\x13\x04\x12\x04\xc4\x03\x02\n\n\r\n\x05\x04\n\
    \x02\x13\x05\x12\x04\xc4\x03\x0b\x11\n\r\n\x05\x04\n\x02\x13\x01\x12\x04\
    \xc4\x03\x12\x1e\n\r\n\x05\x04\n\x02\x13\x03\x12\x04\xc4\x03!#\n|\n\x04\
    \x04\n\x02\x14\x12\x04\xc9\x03\x02:\x1an\x20The\x20parser\x20stores\x20o\
    ptions\x20it\x20doesn't\x20recognize\x20here.\n\x20See\x20the\x20documen\
    tation\x20for\x20the\x20\"Options\"\x20section\x20above.\n\n\r\n\x05\x04\
    \n\x02\x14\x04\x12\x04\xc9\x03\x02\n\n\r\n\x05\x04\n\x02\x14\x06\x12\x04\
    \xc9\x03\x0b\x1e\n\r\n\x05\x04\n\x02\x14\x01\x12\x04\xc9\x03\x1f3\n\r\n\
    \x05\x04\n\x02\x14\x03\x12\x04\xc9\x0369\n\x87\x01\n\x03\x04\n\x05\x12\
    \x04\xcd\x03\x02\x19\x1az\x20Clients\x20can\x20define\x20custom\x20optio\
    ns\x20in\x20extensions\x20of\x20this\x20message.\n\x20See\x20the\x20docu\
    mentation\x20for\x20the\x20\"Options\"\x20section\x20above.\n\n\x0c\n\
    \x04\x04\n\x05\0\x12\x04\xcd\x03\r\x18\n\r\n\x05\x04\n\x05\0\x01\x12\x04\
    \xcd\x03\r\x11\n\r\n\x05\x04\n\x05\0\x02\x12\x04\xcd\x03\x15\x18\n\x0b\n\
    \x03\x04\n\t\x12\x04\xcf\x03\x02\x0e\n\x0c\n\x04\x04\n\t\0\x12\x04\xcf\
    \x03\x0b\r\n\r\n\x05\x04\n\t\0\x01\x12\x04\xcf\x03\x0b\r\n\r\n\x05\x04\n\
    \t\0\x02\x12\x04\xcf\x03\x0b\r\n\x0c\n\x02\x04\x0b\x12\x06\xd2\x03\0\x94\
    \x04\x01\n\x0b\n\x03\x04\x0b\x01\x12\x04\xd2\x03\x08\x16\n\xd8\x05\n\x04\
    \x04\x0b\x02\0\x12\x04\xe5\x03\x02>\x1a\xc9\x05\x20Set\x20true\x20to\x20\
    use\x20the\x20old\x20proto1\x20MessageSet\x20wire\x20format\x20for\x20ex\
    tensions.\n\x20This\x20is\x20provided\x20for\x20backwards-compatibility\
    \x20with\x20the\x20MessageSet\x20wire\n\x20format.\x20\x20You\x20should\
    \x20not\x20use\x20this\x20for\x20any\x20other\x20reason:\x20\x20It's\x20\
    less\n\x20efficient,\x20has\x20fewer\x20features,\x20and\x20is\x20more\
    \x20complicated.\n\n\x20The\x20message\x20must\x20be\x20defined\x20exact\
    ly\x20as\x20follows:\n\x20\x20\x20message\x20Foo\x20{\n\x20\x20\x20\x20\
    \x20option\x20message_set_wire_format\x20=\x20true;\n\x20\x20\x20\x20\
    \x20extensions\x204\x20to\x20max;\n\x20\x20\x20}\n\x20Note\x20that\x20th\
    e\x20message\x20cannot\x20have\x20any\x20defined\x20fields;\x20MessageSe\
    ts\x20only\n\x20have\x20extensions.\n\n\x20All\x20extensions\x20of\x20yo\
    ur\x20type\x20must\x20be\x20singular\x20messages;\x20e.g.\x20they\x20can\
    not\n\x20be\x20int32s,\x20enums,\x20or\x20repeated\x20messages.\n\n\x20B\
    ecause\x20this\x20is\x20an\x20option,\x20the\x20above\x20two\x20restrict\
    ions\x20are\x20not\x20enforced\x20by\n\x20the\x20protocol\x20compiler.\n\
    \n\r\n\x05\x04\x0b\x02\0\x04\x12\x04\xe5\x03\x02\n\n\r\n\x05\x04\x0b\x02\
    \0\x05\x12\x04\xe5\x03\x0b\x0f\n\r\n\x05\x04\x0b\x02\0\x01\x12\x04\xe5\
    \x03\x10'\n\r\n\x05\x04\x0b\x02\0\x03\x12\x04\xe5\x03*+\n\r\n\x05\x04\
    \x0b\x02\0\x08\x12\x04\xe5\x03,=\n\r\n\x05\x04\x0b\x02\0\x07\x12\x04\xe5\
    \x037<\n\xeb\x01\n\x04\x04\x0b\x02\x01\x12\x04\xea\x03\x02F\x1a\xdc\x01\
    \x20Disables\x20the\x20generation\x20of\x20the\x20standard\x20\"descript\
    or()\"\x20accessor,\x20which\x20can\n\x20conflict\x20with\x20a\x20field\
    \x20of\x20the\x20same\x20name.\x20\x20This\x20is\x20meant\x20to\x20make\
    \x20migration\n\x20from\x20proto1\x20easier;\x20new\x20code\x20should\
    \x20avoid\x20fields\x20named\x20\"descriptor\".\n\n\r\n\x05\x04\x0b\x02\
    \x01\x04\x12\x04\xea\x03\x02\n\n\r\n\x05\x04\x0b\x02\x01\x05\x12\x04\xea\
    \x03\x0b\x0f\n\r\n\x05\x04\x0b\x02\x01\x01\x12\x04\xea\x03\x10/\n\r\n\
    \x05\x04\x0b\x02\x01\x03\x12\x04\xea\x0323\n\r\n\x05\x04\x0b\x02\x01\x08\
    \x12\x04\xea\x034E\n\r\n\x05\x04\x0b\x02\x01\x07\x12\x04\xea\x03?D\n\xee\
    \x01\n\x04\x04\x0b\x02\x02\x12\x04\xf0\x03\x021\x1a\xdf\x01\x20Is\x20thi\
    s\x20message\x20deprecated?\n\x20Depending\x20on\x20the\x20target\x20pla\
    tform,\x20this\x20can\x20emit\x20Deprecated\x20annotations\n\x20for\x20t\
    he\x20message,\x20or\x20it\x20will\x20be\x20completely\x20ignored;\x20in\
    \x20the\x20very\x20least,\n\x20this\x20is\x20a\x20formalization\x20for\
    \x20deprecating\x20messages.\n\n\r\n\x05\x04\x0b\x02\x02\x04\x12\x04\xf0\
    \x03\x02\n\n\r\n\x05\x04\x0b\x02\x02\x05\x12\x04\xf0\x03\x0b\x0f\n\r\n\
    \x05\x04\x0b\x02\x02\x01\x12\x04\xf0\x03\x10\x1a\n\r\n\x05\x04\x0b\x02\
    \x02\x03\x12\x04\xf0\x03\x1d\x1e\n\r\n\x05\x04\x0b\x02\x02\x08\x12\x04\
    \xf0\x03\x1f0\n\r\n\x05\x04\x0b\x02\x02\x07\x12\x04\xf0\x03*/\n\x0b\n\
    \x03\x04\x0b\t\x12\x04\xf2\x03\x02\x13\n\x0c\n\x04\x04\x0b\t\0\x12\x04\
    \xf2\x03\x0b\x0c\n\r\n\x05\x04\x0b\t\0\x01\x12\x04\xf2\x03\x0b\x0c\n\r\n\
    \x05\x04\x0b\t\0\x02\x12\x04\xf2\x03\x0b\x0c\n\x0c\n\x04\x04\x0b\t\x01\
    \x12\x04\xf2\x03\x0e\x0f\n\r\n\x05\x04\x0b\t\x01\x01\x12\x04\xf2\x03\x0e\
    \x0f\n\r\n\x05\x04\x0b\t\x01\x02\x12\x04\xf2\x03\x0e\x0f\n\x0c\n\x04\x04\
    \x0b\t\x02\x12\x04\xf2\x03\x11\x12\n\r\n\x05\x04\x0b\t\x02\x01\x12\x04\
    \xf2\x03\x11\x12\n\r\n\x05\x04\x0b\t\x02\x02\x12\x04\xf2\x03\x11\x12\n\
    \xa0\x06\n\x04\x04\x0b\x02\x03\x12\x04\x89\x04\x02\x1e\x1a\x91\x06\x20Wh\
    ether\x20the\x20message\x20is\x20an\x20automatically\x20generated\x20map\
    \x20entry\x20type\x20for\x20the\n\x20maps\x20field.\n\n\x20For\x20maps\
    \x20fields:\n\x20\x20\x20\x20\x20map<KeyType,\x20ValueType>\x20map_field\
    \x20=\x201;\n\x20The\x20parsed\x20descriptor\x20looks\x20like:\n\x20\x20\
    \x20\x20\x20message\x20MapFieldEntry\x20{\n\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20option\x20map_entry\x20=\x20true;\n\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20optional\x20KeyType\x20key\x20=\x201;\n\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20optional\x20ValueType\x20value\x20=\x202;\n\x20\x20\x20\x20\
    \x20}\n\x20\x20\x20\x20\x20repeated\x20MapFieldEntry\x20map_field\x20=\
    \x201;\n\n\x20Implementations\x20may\x20choose\x20not\x20to\x20generate\
    \x20the\x20map_entry=true\x20message,\x20but\n\x20use\x20a\x20native\x20\
    map\x20in\x20the\x20target\x20language\x20to\x20hold\x20the\x20keys\x20a\
    nd\x20values.\n\x20The\x20reflection\x20APIs\x20in\x20such\x20implementa\
    tions\x20still\x20need\x20to\x20work\x20as\n\x20if\x20the\x20field\x20is\
    \x20a\x20repeated\x20message\x20field.\n\n\x20NOTE:\x20Do\x20not\x20set\
    \x20the\x20option\x20in\x20.proto\x20files.\x20Always\x20use\x20the\x20m\
    aps\x20syntax\n\x20instead.\x20The\x20option\x20should\x20only\x20be\x20\
    implicitly\x20set\x20by\x20the\x20proto\x20compiler\n\x20parser.\n\n\r\n\
    \x05\x04\x0b\x02\x03\x04\x12\x04\x89\x04\x02\n\n\r\n\x05\x04\x0b\x02\x03\
    \x05\x12\x04\x89\x04\x0b\x0f\n\r\n\x05\x04\x0b\x02\x03\x01\x12\x04\x89\
    \x04\x10\x19\n\r\n\x05\x04\x0b\x02\x03\x03\x12\x04\x89\x04\x1c\x1d\n$\n\
    \x03\x04\x0b\t\x12\x04\x8b\x04\x02\r\"\x17\x20javalite_serializable\n\n\
    \x0c\n\x04\x04\x0b\t\x03\x12\x04\x8b\x04\x0b\x0c\n\r\n\x05\x04\x0b\t\x03\
    \x01\x12\x04\x8b\x04\x0b\x0c\n\r\n\x05\x04\x0b\t\x03\x02\x12\x04\x8b\x04\
    \x0b\x0c\n\x1f\n\x03\x04\x0b\t\x12\x04\x8c\x04\x02\r\"\x12\x20javanano_a\
    s_lite\n\n\x0c\n\x04\x04\x0b\t\x04\x12\x04\x8c\x04\x0b\x0c\n\r\n\x05\x04\
    \x0b\t\x04\x01\x12\x04\x8c\x04\x0b\x0c\n\r\n\x05\x04\x0b\t\x04\x02\x12\
    \x04\x8c\x04\x0b\x0c\nO\n\x04\x04\x0b\x02\x04\x12\x04\x90\x04\x02:\x1aA\
    \x20The\x20parser\x20stores\x20options\x20it\x20doesn't\x20recognize\x20\
    here.\x20See\x20above.\n\n\r\n\x05\x04\x0b\x02\x04\x04\x12\x04\x90\x04\
    \x02\n\n\r\n\x05\x04\x0b\x02\x04\x06\x12\x04\x90\x04\x0b\x1e\n\r\n\x05\
    \x04\x0b\x02\x04\x01\x12\x04\x90\x04\x1f3\n\r\n\x05\x04\x0b\x02\x04\x03\
    \x12\x04\x90\x0469\nZ\n\x03\x04\x0b\x05\x12\x04\x93\x04\x02\x19\x1aM\x20\
    Clients\x20can\x20define\x20custom\x20options\x20in\x20extensions\x20of\
    \x20this\x20message.\x20See\x20above.\n\n\x0c\n\x04\x04\x0b\x05\0\x12\
    \x04\x93\x04\r\x18\n\r\n\x05\x04\x0b\x05\0\x01\x12\x04\x93\x04\r\x11\n\r\
    \n\x05\x04\x0b\x05\0\x02\x12\x04\x93\x04\x15\x18\n\x0c\n\x02\x04\x0c\x12\
    \x06\x96\x04\0\xf1\x04\x01\n\x0b\n\x03\x04\x0c\x01\x12\x04\x96\x04\x08\
    \x14\n\xa3\x02\n\x04\x04\x0c\x02\0\x12\x04\x9b\x04\x02.\x1a\x94\x02\x20T\
    he\x20ctype\x20option\x20instructs\x20the\x20C++\x20code\x20generator\
    \x20to\x20use\x20a\x20different\n\x20representation\x20of\x20the\x20fiel\
    d\x20than\x20it\x20normally\x20would.\x20\x20See\x20the\x20specific\n\
    \x20options\x20below.\x20\x20This\x20option\x20is\x20not\x20yet\x20imple\
    mented\x20in\x20the\x20open\x20source\n\x20release\x20--\x20sorry,\x20we\
    'll\x20try\x20to\x20include\x20it\x20in\x20a\x20future\x20version!\n\n\r\
    \n\x05\x04\x0c\x02\0\x04\x12\x04\x9b\x04\x02\n\n\r\n\x05\x04\x0c\x02\0\
    \x06\x12\x04\x9b\x04\x0b\x10\n\r\n\x05\x04\x0c\x02\0\x01\x12\x04\x9b\x04\
    \x11\x16\n\r\n\x05\x04\x0c\x02\0\x03\x12\x04\x9b\x04\x19\x1a\n\r\n\x05\
    \x04\x0c\x02\0\x08\x12\x04\x9b\x04\x1b-\n\r\n\x05\x04\x0c\x02\0\x07\x12\
    \x04\x9b\x04&,\n\x0e\n\x04\x04\x0c\x04\0\x12\x06\x9c\x04\x02\xa3\x04\x03\
    \n\r\n\x05\x04\x0c\x04\0\x01\x12\x04\x9c\x04\x07\x0c\n\x1f\n\x06\x04\x0c\
    \x04\0\x02\0\x12\x04\x9e\x04\x04\x0f\x1a\x0f\x20Default\x20mode.\n\n\x0f\
    \n\x07\x04\x0c\x04\0\x02\0\x01\x12\x04\x9e\x04\x04\n\n\x0f\n\x07\x04\x0c\
    \x04\0\x02\0\x02\x12\x04\x9e\x04\r\x0e\n\x0e\n\x06\x04\x0c\x04\0\x02\x01\
    \x12\x04\xa0\x04\x04\r\n\x0f\n\x07\x04\x0c\x04\0\x02\x01\x01\x12\x04\xa0\
    \x04\x04\x08\n\x0f\n\x07\x04\x0c\x04\0\x02\x01\x02\x12\x04\xa0\x04\x0b\
    \x0c\n\x0e\n\x06\x04\x0c\x04\0\x02\x02\x12\x04\xa2\x04\x04\x15\n\x0f\n\
    \x07\x04\x0c\x04\0\x02\x02\x01\x12\x04\xa2\x04\x04\x10\n\x0f\n\x07\x04\
    \x0c\x04\0\x02\x02\x02\x12\x04\xa2\x04\x13\x14\n\xda\x02\n\x04\x04\x0c\
    \x02\x01\x12\x04\xa9\x04\x02\x1b\x1a\xcb\x02\x20The\x20packed\x20option\
    \x20can\x20be\x20enabled\x20for\x20repeated\x20primitive\x20fields\x20to\
    \x20enable\n\x20a\x20more\x20efficient\x20representation\x20on\x20the\
    \x20wire.\x20Rather\x20than\x20repeatedly\n\x20writing\x20the\x20tag\x20\
    and\x20type\x20for\x20each\x20element,\x20the\x20entire\x20array\x20is\
    \x20encoded\x20as\n\x20a\x20single\x20length-delimited\x20blob.\x20In\
    \x20proto3,\x20only\x20explicit\x20setting\x20it\x20to\n\x20false\x20wil\
    l\x20avoid\x20using\x20packed\x20encoding.\n\n\r\n\x05\x04\x0c\x02\x01\
    \x04\x12\x04\xa9\x04\x02\n\n\r\n\x05\x04\x0c\x02\x01\x05\x12\x04\xa9\x04\
    \x0b\x0f\n\r\n\x05\x04\x0c\x02\x01\x01\x12\x04\xa9\x04\x10\x16\n\r\n\x05\
    \x04\x0c\x02\x01\x03\x12\x04\xa9\x04\x19\x1a\n\x9a\x05\n\x04\x04\x0c\x02\
    \x02\x12\x04\xb6\x04\x023\x1a\x8b\x05\x20The\x20jstype\x20option\x20dete\
    rmines\x20the\x20JavaScript\x20type\x20used\x20for\x20values\x20of\x20th\
    e\n\x20field.\x20\x20The\x20option\x20is\x20permitted\x20only\x20for\x20\
    64\x20bit\x20integral\x20and\x20fixed\x20types\n\x20(int64,\x20uint64,\
    \x20sint64,\x20fixed64,\x20sfixed64).\x20\x20A\x20field\x20with\x20jstyp\
    e\x20JS_STRING\n\x20is\x20represented\x20as\x20JavaScript\x20string,\x20\
    which\x20avoids\x20loss\x20of\x20precision\x20that\n\x20can\x20happen\
    \x20when\x20a\x20large\x20value\x20is\x20converted\x20to\x20a\x20floatin\
    g\x20point\x20JavaScript.\n\x20Specifying\x20JS_NUMBER\x20for\x20the\x20\
    jstype\x20causes\x20the\x20generated\x20JavaScript\x20code\x20to\n\x20us\
    e\x20the\x20JavaScript\x20\"number\"\x20type.\x20\x20The\x20behavior\x20\
    of\x20the\x20default\x20option\n\x20JS_NORMAL\x20is\x20implementation\
    \x20dependent.\n\n\x20This\x20option\x20is\x20an\x20enum\x20to\x20permit\
    \x20additional\x20types\x20to\x20be\x20added,\x20e.g.\n\x20goog.math.Int\
    eger.\n\n\r\n\x05\x04\x0c\x02\x02\x04\x12\x04\xb6\x04\x02\n\n\r\n\x05\
    \x04\x0c\x02\x02\x06\x12\x04\xb6\x04\x0b\x11\n\r\n\x05\x04\x0c\x02\x02\
    \x01\x12\x04\xb6\x04\x12\x18\n\r\n\x05\x04\x0c\x02\x02\x03\x12\x04\xb6\
    \x04\x1b\x1c\n\r\n\x05\x04\x0c\x02\x02\x08\x12\x04\xb6\x04\x1d2\n\r\n\
    \x05\x04\x0c\x02\x02\x07\x12\x04\xb6\x04(1\n\x0e\n\x04\x04\x0c\x04\x01\
    \x12\x06\xb7\x04\x02\xc0\x04\x03\n\r\n\x05\x04\x0c\x04\x01\x01\x12\x04\
    \xb7\x04\x07\r\n'\n\x06\x04\x0c\x04\x01\x02\0\x12\x04\xb9\x04\x04\x12\
    \x1a\x17\x20Use\x20the\x20default\x20type.\n\n\x0f\n\x07\x04\x0c\x04\x01\
    \x02\0\x01\x12\x04\xb9\x04\x04\r\n\x0f\n\x07\x04\x0c\x04\x01\x02\0\x02\
    \x12\x04\xb9\x04\x10\x11\n)\n\x06\x04\x0c\x04\x01\x02\x01\x12\x04\xbc\
    \x04\x04\x12\x1a\x19\x20Use\x20JavaScript\x20strings.\n\n\x0f\n\x07\x04\
    \x0c\x04\x01\x02\x01\x01\x12\x04\xbc\x04\x04\r\n\x0f\n\x07\x04\x0c\x04\
    \x01\x02\x01\x02\x12\x04\xbc\x04\x10\x11\n)\n\x06\x04\x0c\x04\x01\x02\
    \x02\x12\x04\xbf\x04\x04\x12\x1a\x19\x20Use\x20JavaScript\x20numbers.\n\
    \n\x0f\n\x07\x04\x0c\x04\x01\x02\x02\x01\x12\x04\xbf\x04\x04\r\n\x0f\n\
    \x07\x04\x0c\x04\x01\x02\x02\x02\x12\x04\xbf\x04\x10\x11\n\xef\x0c\n\x04\
    \x04\x0c\x02\x03\x12\x04\xde\x04\x02+\x1a\xe0\x0c\x20Should\x20this\x20f\
    ield\x20be\x20parsed\x20lazily?\x20\x20Lazy\x20applies\x20only\x20to\x20\
    message-type\n\x20fields.\x20\x20It\x20means\x20that\x20when\x20the\x20o\
    uter\x20message\x20is\x20initially\x20parsed,\x20the\n\x20inner\x20messa\
    ge's\x20contents\x20will\x20not\x20be\x20parsed\x20but\x20instead\x20sto\
    red\x20in\x20encoded\n\x20form.\x20\x20The\x20inner\x20message\x20will\
    \x20actually\x20be\x20parsed\x20when\x20it\x20is\x20first\x20accessed.\n\
    \n\x20This\x20is\x20only\x20a\x20hint.\x20\x20Implementations\x20are\x20\
    free\x20to\x20choose\x20whether\x20to\x20use\n\x20eager\x20or\x20lazy\
    \x20parsing\x20regardless\x20of\x20the\x20value\x20of\x20this\x20option.\
    \x20\x20However,\n\x20setting\x20this\x20option\x20true\x20suggests\x20t\
    hat\x20the\x20protocol\x20author\x20believes\x20that\n\x20using\x20lazy\
    \x20parsing\x20on\x20this\x20field\x20is\x20worth\x20the\x20additional\
    \x20bookkeeping\n\x20overhead\x20typically\x20needed\x20to\x20implement\
    \x20it.\n\n\x20This\x20option\x20does\x20not\x20affect\x20the\x20public\
    \x20interface\x20of\x20any\x20generated\x20code;\n\x20all\x20method\x20s\
    ignatures\x20remain\x20the\x20same.\x20\x20Furthermore,\x20thread-safety\
    \x20of\x20the\n\x20interface\x20is\x20not\x20affected\x20by\x20this\x20o\
    ption;\x20const\x20methods\x20remain\x20safe\x20to\n\x20call\x20from\x20\
    multiple\x20threads\x20concurrently,\x20while\x20non-const\x20methods\
    \x20continue\n\x20to\x20require\x20exclusive\x20access.\n\n\n\x20Note\
    \x20that\x20implementations\x20may\x20choose\x20not\x20to\x20check\x20re\
    quired\x20fields\x20within\n\x20a\x20lazy\x20sub-message.\x20\x20That\
    \x20is,\x20calling\x20IsInitialized()\x20on\x20the\x20outer\x20message\n\
    \x20may\x20return\x20true\x20even\x20if\x20the\x20inner\x20message\x20ha\
    s\x20missing\x20required\x20fields.\n\x20This\x20is\x20necessary\x20beca\
    use\x20otherwise\x20the\x20inner\x20message\x20would\x20have\x20to\x20be\
    \n\x20parsed\x20in\x20order\x20to\x20perform\x20the\x20check,\x20defeati\
    ng\x20the\x20purpose\x20of\x20lazy\n\x20parsing.\x20\x20An\x20implementa\
    tion\x20which\x20chooses\x20not\x20to\x20check\x20required\x20fields\n\
    \x20must\x20be\x20consistent\x20about\x20it.\x20\x20That\x20is,\x20for\
    \x20any\x20particular\x20sub-message,\x20the\n\x20implementation\x20must\
    \x20either\x20*always*\x20check\x20its\x20required\x20fields,\x20or\x20*\
    never*\n\x20check\x20its\x20required\x20fields,\x20regardless\x20of\x20w\
    hether\x20or\x20not\x20the\x20message\x20has\n\x20been\x20parsed.\n\n\r\
    \n\x05\x04\x0c\x02\x03\x04\x12\x04\xde\x04\x02\n\n\r\n\x05\x04\x0c\x02\
    \x03\x05\x12\x04\xde\x04\x0b\x0f\n\r\n\x05\x04\x0c\x02\x03\x01\x12\x04\
    \xde\x04\x10\x14\n\r\n\x05\x04\x0c\x02\x03\x03\x12\x04\xde\x04\x17\x18\n\
    \r\n\x05\x04\x0c\x02\x03\x08\x12\x04\xde\x04\x19*\n\r\n\x05\x04\x0c\x02\
    \x03\x07\x12\x04\xde\x04$)\n\xe8\x01\n\x04\x04\x0c\x02\x04\x12\x04\xe4\
    \x04\x021\x1a\xd9\x01\x20Is\x20this\x20field\x20deprecated?\n\x20Dependi\
    ng\x20on\x20the\x20target\x20platform,\x20this\x20can\x20emit\x20Depreca\
    ted\x20annotations\n\x20for\x20accessors,\x20or\x20it\x20will\x20be\x20c\
    ompletely\x20ignored;\x20in\x20the\x20very\x20least,\x20this\n\x20is\x20\
    a\x20formalization\x20for\x20deprecating\x20fields.\n\n\r\n\x05\x04\x0c\
    \x02\x04\x04\x12\x04\xe4\x04\x02\n\n\r\n\x05\x04\x0c\x02\x04\x05\x12\x04\
    \xe4\x04\x0b\x0f\n\r\n\x05\x04\x0c\x02\x04\x01\x12\x04\xe4\x04\x10\x1a\n\
    \r\n\x05\x04\x0c\x02\x04\x03\x12\x04\xe4\x04\x1d\x1e\n\r\n\x05\x04\x0c\
    \x02\x04\x08\x12\x04\xe4\x04\x1f0\n\r\n\x05\x04\x0c\x02\x04\x07\x12\x04\
    \xe4\x04*/\n?\n\x04\x04\x0c\x02\x05\x12\x04\xe7\x04\x02,\x1a1\x20For\x20\
    Google-internal\x20migration\x20only.\x20Do\x20not\x20use.\n\n\r\n\x05\
    \x04\x0c\x02\x05\x04\x12\x04\xe7\x04\x02\n\n\r\n\x05\x04\x0c\x02\x05\x05\
    \x12\x04\xe7\x04\x0b\x0f\n\r\n\x05\x04\x0c\x02\x05\x01\x12\x04\xe7\x04\
    \x10\x14\n\r\n\x05\x04\x0c\x02\x05\x03\x12\x04\xe7\x04\x17\x19\n\r\n\x05\
    \x04\x0c\x02\x05\x08\x12\x04\xe7\x04\x1a+\n\r\n\x05\x04\x0c\x02\x05\x07\
    \x12\x04\xe7\x04%*\nO\n\x04\x04\x0c\x02\x06\x12\x04\xeb\x04\x02:\x1aA\
    \x20The\x20parser\x20stores\x20options\x20it\x20doesn't\x20recognize\x20\
    here.\x20See\x20above.\n\n\r\n\x05\x04\x0c\x02\x06\x04\x12\x04\xeb\x04\
    \x02\n\n\r\n\x05\x04\x0c\x02\x06\x06\x12\x04\xeb\x04\x0b\x1e\n\r\n\x05\
    \x04\x0c\x02\x06\x01\x12\x04\xeb\x04\x1f3\n\r\n\x05\x04\x0c\x02\x06\x03\
    \x12\x04\xeb\x0469\nZ\n\x03\x04\x0c\x05\x12\x04\xee\x04\x02\x19\x1aM\x20\
    Clients\x20can\x20define\x20custom\x20options\x20in\x20extensions\x20of\
    \x20this\x20message.\x20See\x20above.\n\n\x0c\n\x04\x04\x0c\x05\0\x12\
    \x04\xee\x04\r\x18\n\r\n\x05\x04\x0c\x05\0\x01\x12\x04\xee\x04\r\x11\n\r\
    \n\x05\x04\x0c\x05\0\x02\x12\x04\xee\x04\x15\x18\n\x1c\n\x03\x04\x0c\t\
    \x12\x04\xf0\x04\x02\r\"\x0f\x20removed\x20jtype\n\n\x0c\n\x04\x04\x0c\t\
    \0\x12\x04\xf0\x04\x0b\x0c\n\r\n\x05\x04\x0c\t\0\x01\x12\x04\xf0\x04\x0b\
    \x0c\n\r\n\x05\x04\x0c\t\0\x02\x12\x04\xf0\x04\x0b\x0c\n\x0c\n\x02\x04\r\
    \x12\x06\xf3\x04\0\xf9\x04\x01\n\x0b\n\x03\x04\r\x01\x12\x04\xf3\x04\x08\
    \x14\nO\n\x04\x04\r\x02\0\x12\x04\xf5\x04\x02:\x1aA\x20The\x20parser\x20\
    stores\x20options\x20it\x20doesn't\x20recognize\x20here.\x20See\x20above\
    .\n\n\r\n\x05\x04\r\x02\0\x04\x12\x04\xf5\x04\x02\n\n\r\n\x05\x04\r\x02\
    \0\x06\x12\x04\xf5\x04\x0b\x1e\n\r\n\x05\x04\r\x02\0\x01\x12\x04\xf5\x04\
    \x1f3\n\r\n\x05\x04\r\x02\0\x03\x12\x04\xf5\x0469\nZ\n\x03\x04\r\x05\x12\
    \x04\xf8\x04\x02\x19\x1aM\x20Clients\x20can\x20define\x20custom\x20optio\
    ns\x20in\x20extensions\x20of\x20this\x20message.\x20See\x20above.\n\n\
    \x0c\n\x04\x04\r\x05\0\x12\x04\xf8\x04\r\x18\n\r\n\x05\x04\r\x05\0\x01\
    \x12\x04\xf8\x04\r\x11\n\r\n\x05\x04\r\x05\0\x02\x12\x04\xf8\x04\x15\x18\
    \n\x0c\n\x02\x04\x0e\x12\x06\xfb\x04\0\x8e\x05\x01\n\x0b\n\x03\x04\x0e\
    \x01\x12\x04\xfb\x04\x08\x13\n`\n\x04\x04\x0e\x02\0\x12\x04\xff\x04\x02\
    \x20\x1aR\x20Set\x20this\x20option\x20to\x20true\x20to\x20allow\x20mappi\
    ng\x20different\x20tag\x20names\x20to\x20the\x20same\n\x20value.\n\n\r\n\
    \x05\x04\x0e\x02\0\x04\x12\x04\xff\x04\x02\n\n\r\n\x05\x04\x0e\x02\0\x05\
    \x12\x04\xff\x04\x0b\x0f\n\r\n\x05\x04\x0e\x02\0\x01\x12\x04\xff\x04\x10\
    \x1b\n\r\n\x05\x04\x0e\x02\0\x03\x12\x04\xff\x04\x1e\x1f\n\xe5\x01\n\x04\
    \x04\x0e\x02\x01\x12\x04\x85\x05\x021\x1a\xd6\x01\x20Is\x20this\x20enum\
    \x20deprecated?\n\x20Depending\x20on\x20the\x20target\x20platform,\x20th\
    is\x20can\x20emit\x20Deprecated\x20annotations\n\x20for\x20the\x20enum,\
    \x20or\x20it\x20will\x20be\x20completely\x20ignored;\x20in\x20the\x20ver\
    y\x20least,\x20this\n\x20is\x20a\x20formalization\x20for\x20deprecating\
    \x20enums.\n\n\r\n\x05\x04\x0e\x02\x01\x04\x12\x04\x85\x05\x02\n\n\r\n\
    \x05\x04\x0e\x02\x01\x05\x12\x04\x85\x05\x0b\x0f\n\r\n\x05\x04\x0e\x02\
    \x01\x01\x12\x04\x85\x05\x10\x1a\n\r\n\x05\x04\x0e\x02\x01\x03\x12\x04\
    \x85\x05\x1d\x1e\n\r\n\x05\x04\x0e\x02\x01\x08\x12\x04\x85\x05\x1f0\n\r\
    \n\x05\x04\x0e\x02\x01\x07\x12\x04\x85\x05*/\n\x1f\n\x03\x04\x0e\t\x12\
    \x04\x87\x05\x02\r\"\x12\x20javanano_as_lite\n\n\x0c\n\x04\x04\x0e\t\0\
    \x12\x04\x87\x05\x0b\x0c\n\r\n\x05\x04\x0e\t\0\x01\x12\x04\x87\x05\x0b\
    \x0c\n\r\n\x05\x04\x0e\t\0\x02\x12\x04\x87\x05\x0b\x0c\nO\n\x04\x04\x0e\
    \x02\x02\x12\x04\x8a\x05\x02:\x1aA\x20The\x20parser\x20stores\x20options\
    \x20it\x20doesn't\x20recognize\x20here.\x20See\x20above.\n\n\r\n\x05\x04\
    \x0e\x02\x02\x04\x12\x04\x8a\x05\x02\n\n\r\n\x05\x04\x0e\x02\x02\x06\x12\
    \x04\x8a\x05\x0b\x1e\n\r\n\x05\x04\x0e\x02\x02\x01\x12\x04\x8a\x05\x1f3\
    \n\r\n\x05\x04\x0e\x02\x02\x03\x12\x04\x8a\x0569\nZ\n\x03\x04\x0e\x05\
    \x12\x04\x8d\x05\x02\x19\x1aM\x20Clients\x20can\x20define\x20custom\x20o\
    ptions\x20in\x20extensions\x20of\x20this\x20message.\x20See\x20above.\n\
    \n\x0c\n\x04\x04\x0e\x05\0\x12\x04\x8d\x05\r\x18\n\r\n\x05\x04\x0e\x05\0\
    \x01\x12\x04\x8d\x05\r\x11\n\r\n\x05\x04\x0e\x05\0\x02\x12\x04\x8d\x05\
    \x15\x18\n\x0c\n\x02\x04\x0f\x12\x06\x90\x05\0\x9c\x05\x01\n\x0b\n\x03\
    \x04\x0f\x01\x12\x04\x90\x05\x08\x18\n\xf7\x01\n\x04\x04\x0f\x02\0\x12\
    \x04\x95\x05\x021\x1a\xe8\x01\x20Is\x20this\x20enum\x20value\x20deprecat\
    ed?\n\x20Depending\x20on\x20the\x20target\x20platform,\x20this\x20can\
    \x20emit\x20Deprecated\x20annotations\n\x20for\x20the\x20enum\x20value,\
    \x20or\x20it\x20will\x20be\x20completely\x20ignored;\x20in\x20the\x20ver\
    y\x20least,\n\x20this\x20is\x20a\x20formalization\x20for\x20deprecating\
    \x20enum\x20values.\n\n\r\n\x05\x04\x0f\x02\0\x04\x12\x04\x95\x05\x02\n\
    \n\r\n\x05\x04\x0f\x02\0\x05\x12\x04\x95\x05\x0b\x0f\n\r\n\x05\x04\x0f\
    \x02\0\x01\x12\x04\x95\x05\x10\x1a\n\r\n\x05\x04\x0f\x02\0\x03\x12\x04\
    \x95\x05\x1d\x1e\n\r\n\x05\x04\x0f\x02\0\x08\x12\x04\x95\x05\x1f0\n\r\n\
    \x05\x04\x0f\x02\0\x07\x12\x04\x95\x05*/\nO\n\x04\x04\x0f\x02\x01\x12\
    \x04\x98\x05\x02:\x1aA\x20The\x20parser\x20stores\x20options\x20it\x20do\
    esn't\x20recognize\x20here.\x20See\x20above.\n\n\r\n\x05\x04\x0f\x02\x01\
    \x04\x12\x04\x98\x05\x02\n\n\r\n\x05\x04\x0f\x02\x01\x06\x12\x04\x98\x05\
    \x0b\x1e\n\r\n\x05\x04\x0f\x02\x01\x01\x12\x04\x98\x05\x1f3\n\r\n\x05\
    \x04\x0f\x02\x01\x03\x12\x04\x98\x0569\nZ\n\x03\x04\x0f\x05\x12\x04\x9b\
    \x05\x02\x19\x1aM\x20Clients\x20can\x20define\x20custom\x20options\x20in\
    \x20extensions\x20of\x20this\x20message.\x20See\x20above.\n\n\x0c\n\x04\
    \x04\x0f\x05\0\x12\x04\x9b\x05\r\x18\n\r\n\x05\x04\x0f\x05\0\x01\x12\x04\
    \x9b\x05\r\x11\n\r\n\x05\x04\x0f\x05\0\x02\x12\x04\x9b\x05\x15\x18\n\x0c\
    \n\x02\x04\x10\x12\x06\x9e\x05\0\xb0\x05\x01\n\x0b\n\x03\x04\x10\x01\x12\
    \x04\x9e\x05\x08\x16\n\xd9\x03\n\x04\x04\x10\x02\0\x12\x04\xa9\x05\x022\
    \x1a\xdf\x01\x20Is\x20this\x20service\x20deprecated?\n\x20Depending\x20o\
    n\x20the\x20target\x20platform,\x20this\x20can\x20emit\x20Deprecated\x20\
    annotations\n\x20for\x20the\x20service,\x20or\x20it\x20will\x20be\x20com\
    pletely\x20ignored;\x20in\x20the\x20very\x20least,\n\x20this\x20is\x20a\
    \x20formalization\x20for\x20deprecating\x20services.\n2\xe8\x01\x20Note:\
    \x20\x20Field\x20numbers\x201\x20through\x2032\x20are\x20reserved\x20for\
    \x20Google's\x20internal\x20RPC\n\x20\x20\x20framework.\x20\x20We\x20apo\
    logize\x20for\x20hoarding\x20these\x20numbers\x20to\x20ourselves,\x20but\
    \n\x20\x20\x20we\x20were\x20already\x20using\x20them\x20long\x20before\
    \x20we\x20decided\x20to\x20release\x20Protocol\n\x20\x20\x20Buffers.\n\n\
    \r\n\x05\x04\x10\x02\0\x04\x12\x04\xa9\x05\x02\n\n\r\n\x05\x04\x10\x02\0\
    \x05\x12\x04\xa9\x05\x0b\x0f\n\r\n\x05\x04\x10\x02\0\x01\x12\x04\xa9\x05\
    \x10\x1a\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\xa9\x05\x1d\x1f\n\r\n\x05\
    \x04\x10\x02\0\x08\x12\x04\xa9\x05\x201\n\r\n\x05\x04\x10\x02\0\x07\x12\
    \x04\xa9\x05+0\nO\n\x04\x04\x10\x02\x01\x12\x04\xac\x05\x02:\x1aA\x20The\
    \x20parser\x20stores\x20options\x20it\x20doesn't\x20recognize\x20here.\
    \x20See\x20above.\n\n\r\n\x05\x04\x10\x02\x01\x04\x12\x04\xac\x05\x02\n\
    \n\r\n\x05\x04\x10\x02\x01\x06\x12\x04\xac\x05\x0b\x1e\n\r\n\x05\x04\x10\
    \x02\x01\x01\x12\x04\xac\x05\x1f3\n\r\n\x05\x04\x10\x02\x01\x03\x12\x04\
    \xac\x0569\nZ\n\x03\x04\x10\x05\x12\x04\xaf\x05\x02\x19\x1aM\x20Clients\
    \x20can\x20define\x20custom\x20options\x20in\x20extensions\x20of\x20this\
    \x20message.\x20See\x20above.\n\n\x0c\n\x04\x04\x10\x05\0\x12\x04\xaf\
    \x05\r\x18\n\r\n\x05\x04\x10\x05\0\x01\x12\x04\xaf\x05\r\x11\n\r\n\x05\
    \x04\x10\x05\0\x02\x12\x04\xaf\x05\x15\x18\n\x0c\n\x02\x04\x11\x12\x06\
    \xb2\x05\0\xcf\x05\x01\n\x0b\n\x03\x04\x11\x01\x12\x04\xb2\x05\x08\x15\n\
    \xd6\x03\n\x04\x04\x11\x02\0\x12\x04\xbd\x05\x022\x1a\xdc\x01\x20Is\x20t\
    his\x20method\x20deprecated?\n\x20Depending\x20on\x20the\x20target\x20pl\
    atform,\x20this\x20can\x20emit\x20Deprecated\x20annotations\n\x20for\x20\
    the\x20method,\x20or\x20it\x20will\x20be\x20completely\x20ignored;\x20in\
    \x20the\x20very\x20least,\n\x20this\x20is\x20a\x20formalization\x20for\
    \x20deprecating\x20methods.\n2\xe8\x01\x20Note:\x20\x20Field\x20numbers\
    \x201\x20through\x2032\x20are\x20reserved\x20for\x20Google's\x20internal\
    \x20RPC\n\x20\x20\x20framework.\x20\x20We\x20apologize\x20for\x20hoardin\
    g\x20these\x20numbers\x20to\x20ourselves,\x20but\n\x20\x20\x20we\x20were\
    \x20already\x20using\x20them\x20long\x20before\x20we\x20decided\x20to\
    \x20release\x20Protocol\n\x20\x20\x20Buffers.\n\n\r\n\x05\x04\x11\x02\0\
    \x04\x12\x04\xbd\x05\x02\n\n\r\n\x05\x04\x11\x02\0\x05\x12\x04\xbd\x05\
    \x0b\x0f\n\r\n\x05\x04\x11\x02\0\x01\x12\x04\xbd\x05\x10\x1a\n\r\n\x05\
    \x04\x11\x02\0\x03\x12\x04\xbd\x05\x1d\x1f\n\r\n\x05\x04\x11\x02\0\x08\
    \x12\x04\xbd\x05\x201\n\r\n\x05\x04\x11\x02\0\x07\x12\x04\xbd\x05+0\n\
    \xf0\x01\n\x04\x04\x11\x04\0\x12\x06\xc2\x05\x02\xc6\x05\x03\x1a\xdf\x01\
    \x20Is\x20this\x20method\x20side-effect-free\x20(or\x20safe\x20in\x20HTT\
    P\x20parlance),\x20or\x20idempotent,\n\x20or\x20neither?\x20HTTP\x20base\
    d\x20RPC\x20implementation\x20may\x20choose\x20GET\x20verb\x20for\x20saf\
    e\n\x20methods,\x20and\x20PUT\x20verb\x20for\x20idempotent\x20methods\
    \x20instead\x20of\x20the\x20default\x20POST.\n\n\r\n\x05\x04\x11\x04\0\
    \x01\x12\x04\xc2\x05\x07\x17\n\x0e\n\x06\x04\x11\x04\0\x02\0\x12\x04\xc3\
    \x05\x04\x1c\n\x0f\n\x07\x04\x11\x04\0\x02\0\x01\x12\x04\xc3\x05\x04\x17\
    \n\x0f\n\x07\x04\x11\x04\0\x02\0\x02\x12\x04\xc3\x05\x1a\x1b\n$\n\x06\
    \x04\x11\x04\0\x02\x01\x12\x04\xc4\x05\x04\x18\"\x14\x20implies\x20idemp\
    otent\n\n\x0f\n\x07\x04\x11\x04\0\x02\x01\x01\x12\x04\xc4\x05\x04\x13\n\
    \x0f\n\x07\x04\x11\x04\0\x02\x01\x02\x12\x04\xc4\x05\x16\x17\n7\n\x06\
    \x04\x11\x04\0\x02\x02\x12\x04\xc5\x05\x04\x13\"'\x20idempotent,\x20but\
    \x20may\x20have\x20side\x20effects\n\n\x0f\n\x07\x04\x11\x04\0\x02\x02\
    \x01\x12\x04\xc5\x05\x04\x0e\n\x0f\n\x07\x04\x11\x04\0\x02\x02\x02\x12\
    \x04\xc5\x05\x11\x12\n\x0e\n\x04\x04\x11\x02\x01\x12\x06\xc7\x05\x02\xc8\
    \x05&\n\r\n\x05\x04\x11\x02\x01\x04\x12\x04\xc7\x05\x02\n\n\r\n\x05\x04\
    \x11\x02\x01\x06\x12\x04\xc7\x05\x0b\x1b\n\r\n\x05\x04\x11\x02\x01\x01\
    \x12\x04\xc7\x05\x1c-\n\r\n\x05\x04\x11\x02\x01\x03\x12\x04\xc7\x0502\n\
    \r\n\x05\x04\x11\x02\x01\x08\x12\x04\xc8\x05\x06%\n\r\n\x05\x04\x11\x02\
    \x01\x07\x12\x04\xc8\x05\x11$\nO\n\x04\x04\x11\x02\x02\x12\x04\xcb\x05\
    \x02:\x1aA\x20The\x20parser\x20stores\x20options\x20it\x20doesn't\x20rec\
    ognize\x20here.\x20See\x20above.\n\n\r\n\x05\x04\x11\x02\x02\x04\x12\x04\
    \xcb\x05\x02\n\n\r\n\x05\x04\x11\x02\x02\x06\x12\x04\xcb\x05\x0b\x1e\n\r\
    \n\x05\x04\x11\x02\x02\x01\x12\x04\xcb\x05\x1f3\n\r\n\x05\x04\x11\x02\
    \x02\x03\x12\x04\xcb\x0569\nZ\n\x03\x04\x11\x05\x12\x04\xce\x05\x02\x19\
    \x1aM\x20Clients\x20can\x20define\x20custom\x20options\x20in\x20extensio\
    ns\x20of\x20this\x20message.\x20See\x20above.\n\n\x0c\n\x04\x04\x11\x05\
    \0\x12\x04\xce\x05\r\x18\n\r\n\x05\x04\x11\x05\0\x01\x12\x04\xce\x05\r\
    \x11\n\r\n\x05\x04\x11\x05\0\x02\x12\x04\xce\x05\x15\x18\n\x8b\x03\n\x02\
    \x04\x12\x12\x06\xd8\x05\0\xec\x05\x01\x1a\xfc\x02\x20A\x20message\x20re\
    presenting\x20a\x20option\x20the\x20parser\x20does\x20not\x20recognize.\
    \x20This\x20only\n\x20appears\x20in\x20options\x20protos\x20created\x20b\
    y\x20the\x20compiler::Parser\x20class.\n\x20DescriptorPool\x20resolves\
    \x20these\x20when\x20building\x20Descriptor\x20objects.\x20Therefore,\n\
    \x20options\x20protos\x20in\x20descriptor\x20objects\x20(e.g.\x20returne\
    d\x20by\x20Descriptor::options(),\n\x20or\x20produced\x20by\x20Descripto\
    r::CopyTo())\x20will\x20never\x20have\x20UninterpretedOptions\n\x20in\
    \x20them.\n\n\x0b\n\x03\x04\x12\x01\x12\x04\xd8\x05\x08\x1b\n\xcb\x02\n\
    \x04\x04\x12\x03\0\x12\x06\xde\x05\x02\xe1\x05\x03\x1a\xba\x02\x20The\
    \x20name\x20of\x20the\x20uninterpreted\x20option.\x20\x20Each\x20string\
    \x20represents\x20a\x20segment\x20in\n\x20a\x20dot-separated\x20name.\
    \x20\x20is_extension\x20is\x20true\x20iff\x20a\x20segment\x20represents\
    \x20an\n\x20extension\x20(denoted\x20with\x20parentheses\x20in\x20option\
    s\x20specs\x20in\x20.proto\x20files).\n\x20E.g.,{\x20[\"foo\",\x20false]\
    ,\x20[\"bar.baz\",\x20true],\x20[\"qux\",\x20false]\x20}\x20represents\n\
    \x20\"foo.(bar.baz).qux\".\n\n\r\n\x05\x04\x12\x03\0\x01\x12\x04\xde\x05\
    \n\x12\n\x0e\n\x06\x04\x12\x03\0\x02\0\x12\x04\xdf\x05\x04\"\n\x0f\n\x07\
    \x04\x12\x03\0\x02\0\x04\x12\x04\xdf\x05\x04\x0c\n\x0f\n\x07\x04\x12\x03\
    \0\x02\0\x05\x12\x04\xdf\x05\r\x13\n\x0f\n\x07\x04\x12\x03\0\x02\0\x01\
    \x12\x04\xdf\x05\x14\x1d\n\x0f\n\x07\x04\x12\x03\0\x02\0\x03\x12\x04\xdf\
    \x05\x20!\n\x0e\n\x06\x04\x12\x03\0\x02\x01\x12\x04\xe0\x05\x04#\n\x0f\n\
    \x07\x04\x12\x03\0\x02\x01\x04\x12\x04\xe0\x05\x04\x0c\n\x0f\n\x07\x04\
    \x12\x03\0\x02\x01\x05\x12\x04\xe0\x05\r\x11\n\x0f\n\x07\x04\x12\x03\0\
    \x02\x01\x01\x12\x04\xe0\x05\x12\x1e\n\x0f\n\x07\x04\x12\x03\0\x02\x01\
    \x03\x12\x04\xe0\x05!\"\n\x0c\n\x04\x04\x12\x02\0\x12\x04\xe2\x05\x02\
    \x1d\n\r\n\x05\x04\x12\x02\0\x04\x12\x04\xe2\x05\x02\n\n\r\n\x05\x04\x12\
    \x02\0\x06\x12\x04\xe2\x05\x0b\x13\n\r\n\x05\x04\x12\x02\0\x01\x12\x04\
    \xe2\x05\x14\x18\n\r\n\x05\x04\x12\x02\0\x03\x12\x04\xe2\x05\x1b\x1c\n\
    \x9c\x01\n\x04\x04\x12\x02\x01\x12\x04\xe6\x05\x02'\x1a\x8d\x01\x20The\
    \x20value\x20of\x20the\x20uninterpreted\x20option,\x20in\x20whatever\x20\
    type\x20the\x20tokenizer\n\x20identified\x20it\x20as\x20during\x20parsin\
    g.\x20Exactly\x20one\x20of\x20these\x20should\x20be\x20set.\n\n\r\n\x05\
    \x04\x12\x02\x01\x04\x12\x04\xe6\x05\x02\n\n\r\n\x05\x04\x12\x02\x01\x05\
    \x12\x04\xe6\x05\x0b\x11\n\r\n\x05\x04\x12\x02\x01\x01\x12\x04\xe6\x05\
    \x12\"\n\r\n\x05\x04\x12\x02\x01\x03\x12\x04\xe6\x05%&\n\x0c\n\x04\x04\
    \x12\x02\x02\x12\x04\xe7\x05\x02)\n\r\n\x05\x04\x12\x02\x02\x04\x12\x04\
    \xe7\x05\x02\n\n\r\n\x05\x04\x12\x02\x02\x05\x12\x04\xe7\x05\x0b\x11\n\r\
    \n\x05\x04\x12\x02\x02\x01\x12\x04\xe7\x05\x12$\n\r\n\x05\x04\x12\x02\
    \x02\x03\x12\x04\xe7\x05'(\n\x0c\n\x04\x04\x12\x02\x03\x12\x04\xe8\x05\
    \x02(\n\r\n\x05\x04\x12\x02\x03\x04\x12\x04\xe8\x05\x02\n\n\r\n\x05\x04\
    \x12\x02\x03\x05\x12\x04\xe8\x05\x0b\x10\n\r\n\x05\x04\x12\x02\x03\x01\
    \x12\x04\xe8\x05\x11#\n\r\n\x05\x04\x12\x02\x03\x03\x12\x04\xe8\x05&'\n\
    \x0c\n\x04\x04\x12\x02\x04\x12\x04\xe9\x05\x02#\n\r\n\x05\x04\x12\x02\
    \x04\x04\x12\x04\xe9\x05\x02\n\n\r\n\x05\x04\x12\x02\x04\x05\x12\x04\xe9\
    \x05\x0b\x11\n\r\n\x05\x04\x12\x02\x04\x01\x12\x04\xe9\x05\x12\x1e\n\r\n\
    \x05\x04\x12\x02\x04\x03\x12\x04\xe9\x05!\"\n\x0c\n\x04\x04\x12\x02\x05\
    \x12\x04\xea\x05\x02\"\n\r\n\x05\x04\x12\x02\x05\x04\x12\x04\xea\x05\x02\
    \n\n\r\n\x05\x04\x12\x02\x05\x05\x12\x04\xea\x05\x0b\x10\n\r\n\x05\x04\
    \x12\x02\x05\x01\x12\x04\xea\x05\x11\x1d\n\r\n\x05\x04\x12\x02\x05\x03\
    \x12\x04\xea\x05\x20!\n\x0c\n\x04\x04\x12\x02\x06\x12\x04\xeb\x05\x02&\n\
    \r\n\x05\x04\x12\x02\x06\x04\x12\x04\xeb\x05\x02\n\n\r\n\x05\x04\x12\x02\
    \x06\x05\x12\x04\xeb\x05\x0b\x11\n\r\n\x05\x04\x12\x02\x06\x01\x12\x04\
    \xeb\x05\x12!\n\r\n\x05\x04\x12\x02\x06\x03\x12\x04\xeb\x05$%\n\xda\x01\
    \n\x02\x04\x13\x12\x06\xf3\x05\0\xf4\x06\x01\x1aj\x20Encapsulates\x20inf\
    ormation\x20about\x20the\x20original\x20source\x20file\x20from\x20which\
    \x20a\n\x20FileDescriptorProto\x20was\x20generated.\n2`\x20=============\
    ======================================================\n\x20Optional\x20\
    source\x20code\x20info\n\n\x0b\n\x03\x04\x13\x01\x12\x04\xf3\x05\x08\x16\
    \n\x82\x11\n\x04\x04\x13\x02\0\x12\x04\x9f\x06\x02!\x1a\xf3\x10\x20A\x20\
    Location\x20identifies\x20a\x20piece\x20of\x20source\x20code\x20in\x20a\
    \x20.proto\x20file\x20which\n\x20corresponds\x20to\x20a\x20particular\
    \x20definition.\x20\x20This\x20information\x20is\x20intended\n\x20to\x20\
    be\x20useful\x20to\x20IDEs,\x20code\x20indexers,\x20documentation\x20gen\
    erators,\x20and\x20similar\n\x20tools.\n\n\x20For\x20example,\x20say\x20\
    we\x20have\x20a\x20file\x20like:\n\x20\x20\x20message\x20Foo\x20{\n\x20\
    \x20\x20\x20\x20optional\x20string\x20foo\x20=\x201;\n\x20\x20\x20}\n\
    \x20Let's\x20look\x20at\x20just\x20the\x20field\x20definition:\n\x20\x20\
    \x20optional\x20string\x20foo\x20=\x201;\n\x20\x20\x20^\x20\x20\x20\x20\
    \x20\x20\x20^^\x20\x20\x20\x20\x20^^\x20\x20^\x20\x20^^^\n\x20\x20\x20a\
    \x20\x20\x20\x20\x20\x20\x20bc\x20\x20\x20\x20\x20de\x20\x20f\x20\x20ghi\
    \n\x20We\x20have\x20the\x20following\x20locations:\n\x20\x20\x20span\x20\
    \x20\x20path\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    represents\n\x20\x20\x20[a,i)\x20\x20[\x204,\x200,\x202,\x200\x20]\x20\
    \x20\x20\x20\x20The\x20whole\x20field\x20definition.\n\x20\x20\x20[a,b)\
    \x20\x20[\x204,\x200,\x202,\x200,\x204\x20]\x20\x20The\x20label\x20(opti\
    onal).\n\x20\x20\x20[c,d)\x20\x20[\x204,\x200,\x202,\x200,\x205\x20]\x20\
    \x20The\x20type\x20(string).\n\x20\x20\x20[e,f)\x20\x20[\x204,\x200,\x20\
    2,\x200,\x201\x20]\x20\x20The\x20name\x20(foo).\n\x20\x20\x20[g,h)\x20\
    \x20[\x204,\x200,\x202,\x200,\x203\x20]\x20\x20The\x20number\x20(1).\n\n\
    \x20Notes:\n\x20-\x20A\x20location\x20may\x20refer\x20to\x20a\x20repeate\
    d\x20field\x20itself\x20(i.e.\x20not\x20to\x20any\n\x20\x20\x20particula\
    r\x20index\x20within\x20it).\x20\x20This\x20is\x20used\x20whenever\x20a\
    \x20set\x20of\x20elements\x20are\n\x20\x20\x20logically\x20enclosed\x20i\
    n\x20a\x20single\x20code\x20segment.\x20\x20For\x20example,\x20an\x20ent\
    ire\n\x20\x20\x20extend\x20block\x20(possibly\x20containing\x20multiple\
    \x20extension\x20definitions)\x20will\n\x20\x20\x20have\x20an\x20outer\
    \x20location\x20whose\x20path\x20refers\x20to\x20the\x20\"extensions\"\
    \x20repeated\n\x20\x20\x20field\x20without\x20an\x20index.\n\x20-\x20Mul\
    tiple\x20locations\x20may\x20have\x20the\x20same\x20path.\x20\x20This\
    \x20happens\x20when\x20a\x20single\n\x20\x20\x20logical\x20declaration\
    \x20is\x20spread\x20out\x20across\x20multiple\x20places.\x20\x20The\x20m\
    ost\n\x20\x20\x20obvious\x20example\x20is\x20the\x20\"extend\"\x20block\
    \x20again\x20--\x20there\x20may\x20be\x20multiple\n\x20\x20\x20extend\
    \x20blocks\x20in\x20the\x20same\x20scope,\x20each\x20of\x20which\x20will\
    \x20have\x20the\x20same\x20path.\n\x20-\x20A\x20location's\x20span\x20is\
    \x20not\x20always\x20a\x20subset\x20of\x20its\x20parent's\x20span.\x20\
    \x20For\n\x20\x20\x20example,\x20the\x20\"extendee\"\x20of\x20an\x20exte\
    nsion\x20declaration\x20appears\x20at\x20the\n\x20\x20\x20beginning\x20o\
    f\x20the\x20\"extend\"\x20block\x20and\x20is\x20shared\x20by\x20all\x20e\
    xtensions\x20within\n\x20\x20\x20the\x20block.\n\x20-\x20Just\x20because\
    \x20a\x20location's\x20span\x20is\x20a\x20subset\x20of\x20some\x20other\
    \x20location's\x20span\n\x20\x20\x20does\x20not\x20mean\x20that\x20it\
    \x20is\x20a\x20descendant.\x20\x20For\x20example,\x20a\x20\"group\"\x20d\
    efines\n\x20\x20\x20both\x20a\x20type\x20and\x20a\x20field\x20in\x20a\
    \x20single\x20declaration.\x20\x20Thus,\x20the\x20locations\n\x20\x20\
    \x20corresponding\x20to\x20the\x20type\x20and\x20field\x20and\x20their\
    \x20components\x20will\x20overlap.\n\x20-\x20Code\x20which\x20tries\x20t\
    o\x20interpret\x20locations\x20should\x20probably\x20be\x20designed\x20t\
    o\n\x20\x20\x20ignore\x20those\x20that\x20it\x20doesn't\x20understand,\
    \x20as\x20more\x20types\x20of\x20locations\x20could\n\x20\x20\x20be\x20r\
    ecorded\x20in\x20the\x20future.\n\n\r\n\x05\x04\x13\x02\0\x04\x12\x04\
    \x9f\x06\x02\n\n\r\n\x05\x04\x13\x02\0\x06\x12\x04\x9f\x06\x0b\x13\n\r\n\
    \x05\x04\x13\x02\0\x01\x12\x04\x9f\x06\x14\x1c\n\r\n\x05\x04\x13\x02\0\
    \x03\x12\x04\x9f\x06\x1f\x20\n\x0e\n\x04\x04\x13\x03\0\x12\x06\xa0\x06\
    \x02\xf3\x06\x03\n\r\n\x05\x04\x13\x03\0\x01\x12\x04\xa0\x06\n\x12\n\x83\
    \x07\n\x06\x04\x13\x03\0\x02\0\x12\x04\xb8\x06\x04,\x1a\xf2\x06\x20Ident\
    ifies\x20which\x20part\x20of\x20the\x20FileDescriptorProto\x20was\x20def\
    ined\x20at\x20this\n\x20location.\n\n\x20Each\x20element\x20is\x20a\x20f\
    ield\x20number\x20or\x20an\x20index.\x20\x20They\x20form\x20a\x20path\
    \x20from\n\x20the\x20root\x20FileDescriptorProto\x20to\x20the\x20place\
    \x20where\x20the\x20definition.\x20\x20For\n\x20example,\x20this\x20path\
    :\n\x20\x20\x20[\x204,\x203,\x202,\x207,\x201\x20]\n\x20refers\x20to:\n\
    \x20\x20\x20file.message_type(3)\x20\x20//\x204,\x203\n\x20\x20\x20\x20\
    \x20\x20\x20.field(7)\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x202,\x207\n\
    \x20\x20\x20\x20\x20\x20\x20.name()\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20//\x201\n\x20This\x20is\x20because\x20FileDescriptorProto.messag\
    e_type\x20has\x20field\x20number\x204:\n\x20\x20\x20repeated\x20Descript\
    orProto\x20message_type\x20=\x204;\n\x20and\x20DescriptorProto.field\x20\
    has\x20field\x20number\x202:\n\x20\x20\x20repeated\x20FieldDescriptorPro\
    to\x20field\x20=\x202;\n\x20and\x20FieldDescriptorProto.name\x20has\x20f\
    ield\x20number\x201:\n\x20\x20\x20optional\x20string\x20name\x20=\x201;\
    \n\n\x20Thus,\x20the\x20above\x20path\x20gives\x20the\x20location\x20of\
    \x20a\x20field\x20name.\x20\x20If\x20we\x20removed\n\x20the\x20last\x20e\
    lement:\n\x20\x20\x20[\x204,\x203,\x202,\x207\x20]\n\x20this\x20path\x20\
    refers\x20to\x20the\x20whole\x20field\x20declaration\x20(from\x20the\x20\
    beginning\n\x20of\x20the\x20label\x20to\x20the\x20terminating\x20semicol\
    on).\n\n\x0f\n\x07\x04\x13\x03\0\x02\0\x04\x12\x04\xb8\x06\x04\x0c\n\x0f\
    \n\x07\x04\x13\x03\0\x02\0\x05\x12\x04\xb8\x06\r\x12\n\x0f\n\x07\x04\x13\
    \x03\0\x02\0\x01\x12\x04\xb8\x06\x13\x17\n\x0f\n\x07\x04\x13\x03\0\x02\0\
    \x03\x12\x04\xb8\x06\x1a\x1b\n\x0f\n\x07\x04\x13\x03\0\x02\0\x08\x12\x04\
    \xb8\x06\x1c+\n\x10\n\x08\x04\x13\x03\0\x02\0\x08\x02\x12\x04\xb8\x06\
    \x1d*\n\xd2\x02\n\x06\x04\x13\x03\0\x02\x01\x12\x04\xbf\x06\x04,\x1a\xc1\
    \x02\x20Always\x20has\x20exactly\x20three\x20or\x20four\x20elements:\x20\
    start\x20line,\x20start\x20column,\n\x20end\x20line\x20(optional,\x20oth\
    erwise\x20assumed\x20same\x20as\x20start\x20line),\x20end\x20column.\n\
    \x20These\x20are\x20packed\x20into\x20a\x20single\x20field\x20for\x20eff\
    iciency.\x20\x20Note\x20that\x20line\n\x20and\x20column\x20numbers\x20ar\
    e\x20zero-based\x20--\x20typically\x20you\x20will\x20want\x20to\x20add\n\
    \x201\x20to\x20each\x20before\x20displaying\x20to\x20a\x20user.\n\n\x0f\
    \n\x07\x04\x13\x03\0\x02\x01\x04\x12\x04\xbf\x06\x04\x0c\n\x0f\n\x07\x04\
    \x13\x03\0\x02\x01\x05\x12\x04\xbf\x06\r\x12\n\x0f\n\x07\x04\x13\x03\0\
    \x02\x01\x01\x12\x04\xbf\x06\x13\x17\n\x0f\n\x07\x04\x13\x03\0\x02\x01\
    \x03\x12\x04\xbf\x06\x1a\x1b\n\x0f\n\x07\x04\x13\x03\0\x02\x01\x08\x12\
    \x04\xbf\x06\x1c+\n\x10\n\x08\x04\x13\x03\0\x02\x01\x08\x02\x12\x04\xbf\
    \x06\x1d*\n\xa5\x0c\n\x06\x04\x13\x03\0\x02\x02\x12\x04\xf0\x06\x04)\x1a\
    \x94\x0c\x20If\x20this\x20SourceCodeInfo\x20represents\x20a\x20complete\
    \x20declaration,\x20these\x20are\x20any\n\x20comments\x20appearing\x20be\
    fore\x20and\x20after\x20the\x20declaration\x20which\x20appear\x20to\x20b\
    e\n\x20attached\x20to\x20the\x20declaration.\n\n\x20A\x20series\x20of\
    \x20line\x20comments\x20appearing\x20on\x20consecutive\x20lines,\x20with\
    \x20no\x20other\n\x20tokens\x20appearing\x20on\x20those\x20lines,\x20wil\
    l\x20be\x20treated\x20as\x20a\x20single\x20comment.\n\n\x20leading_detac\
    hed_comments\x20will\x20keep\x20paragraphs\x20of\x20comments\x20that\x20\
    appear\n\x20before\x20(but\x20not\x20connected\x20to)\x20the\x20current\
    \x20element.\x20Each\x20paragraph,\n\x20separated\x20by\x20empty\x20line\
    s,\x20will\x20be\x20one\x20comment\x20element\x20in\x20the\x20repeated\n\
    \x20field.\n\n\x20Only\x20the\x20comment\x20content\x20is\x20provided;\
    \x20comment\x20markers\x20(e.g.\x20//)\x20are\n\x20stripped\x20out.\x20\
    \x20For\x20block\x20comments,\x20leading\x20whitespace\x20and\x20an\x20a\
    sterisk\n\x20will\x20be\x20stripped\x20from\x20the\x20beginning\x20of\
    \x20each\x20line\x20other\x20than\x20the\x20first.\n\x20Newlines\x20are\
    \x20included\x20in\x20the\x20output.\n\n\x20Examples:\n\n\x20\x20\x20opt\
    ional\x20int32\x20foo\x20=\x201;\x20\x20//\x20Comment\x20attached\x20to\
    \x20foo.\n\x20\x20\x20//\x20Comment\x20attached\x20to\x20bar.\n\x20\x20\
    \x20optional\x20int32\x20bar\x20=\x202;\n\n\x20\x20\x20optional\x20strin\
    g\x20baz\x20=\x203;\n\x20\x20\x20//\x20Comment\x20attached\x20to\x20baz.\
    \n\x20\x20\x20//\x20Another\x20line\x20attached\x20to\x20baz.\n\n\x20\
    \x20\x20//\x20Comment\x20attached\x20to\x20qux.\n\x20\x20\x20//\n\x20\
    \x20\x20//\x20Another\x20line\x20attached\x20to\x20qux.\n\x20\x20\x20opt\
    ional\x20double\x20qux\x20=\x204;\n\n\x20\x20\x20//\x20Detached\x20comme\
    nt\x20for\x20corge.\x20This\x20is\x20not\x20leading\x20or\x20trailing\
    \x20comments\n\x20\x20\x20//\x20to\x20qux\x20or\x20corge\x20because\x20t\
    here\x20are\x20blank\x20lines\x20separating\x20it\x20from\n\x20\x20\x20/\
    /\x20both.\n\n\x20\x20\x20//\x20Detached\x20comment\x20for\x20corge\x20p\
    aragraph\x202.\n\n\x20\x20\x20optional\x20string\x20corge\x20=\x205;\n\
    \x20\x20\x20/*\x20Block\x20comment\x20attached\n\x20\x20\x20\x20*\x20to\
    \x20corge.\x20\x20Leading\x20asterisks\n\x20\x20\x20\x20*\x20will\x20be\
    \x20removed.\x20*/\n\x20\x20\x20/*\x20Block\x20comment\x20attached\x20to\
    \n\x20\x20\x20\x20*\x20grault.\x20*/\n\x20\x20\x20optional\x20int32\x20g\
    rault\x20=\x206;\n\n\x20\x20\x20//\x20ignored\x20detached\x20comments.\n\
    \n\x0f\n\x07\x04\x13\x03\0\x02\x02\x04\x12\x04\xf0\x06\x04\x0c\n\x0f\n\
    \x07\x04\x13\x03\0\x02\x02\x05\x12\x04\xf0\x06\r\x13\n\x0f\n\x07\x04\x13\
    \x03\0\x02\x02\x01\x12\x04\xf0\x06\x14$\n\x0f\n\x07\x04\x13\x03\0\x02\
    \x02\x03\x12\x04\xf0\x06'(\n\x0e\n\x06\x04\x13\x03\0\x02\x03\x12\x04\xf1\
    \x06\x04*\n\x0f\n\x07\x04\x13\x03\0\x02\x03\x04\x12\x04\xf1\x06\x04\x0c\
    \n\x0f\n\x07\x04\x13\x03\0\x02\x03\x05\x12\x04\xf1\x06\r\x13\n\x0f\n\x07\
    \x04\x13\x03\0\x02\x03\x01\x12\x04\xf1\x06\x14%\n\x0f\n\x07\x04\x13\x03\
    \0\x02\x03\x03\x12\x04\xf1\x06()\n\x0e\n\x06\x04\x13\x03\0\x02\x04\x12\
    \x04\xf2\x06\x042\n\x0f\n\x07\x04\x13\x03\0\x02\x04\x04\x12\x04\xf2\x06\
    \x04\x0c\n\x0f\n\x07\x04\x13\x03\0\x02\x04\x05\x12\x04\xf2\x06\r\x13\n\
    \x0f\n\x07\x04\x13\x03\0\x02\x04\x01\x12\x04\xf2\x06\x14-\n\x0f\n\x07\
    \x04\x13\x03\0\x02\x04\x03\x12\x04\xf2\x0601\n\xee\x01\n\x02\x04\x14\x12\
    \x06\xf9\x06\0\x8e\x07\x01\x1a\xdf\x01\x20Describes\x20the\x20relationsh\
    ip\x20between\x20generated\x20code\x20and\x20its\x20original\x20source\n\
    \x20file.\x20A\x20GeneratedCodeInfo\x20message\x20is\x20associated\x20wi\
    th\x20only\x20one\x20generated\n\x20source\x20file,\x20but\x20may\x20con\
    tain\x20references\x20to\x20different\x20source\x20.proto\x20files.\n\n\
    \x0b\n\x03\x04\x14\x01\x12\x04\xf9\x06\x08\x19\nx\n\x04\x04\x14\x02\0\
    \x12\x04\xfc\x06\x02%\x1aj\x20An\x20Annotation\x20connects\x20some\x20sp\
    an\x20of\x20text\x20in\x20generated\x20code\x20to\x20an\x20element\n\x20\
    of\x20its\x20generating\x20.proto\x20file.\n\n\r\n\x05\x04\x14\x02\0\x04\
    \x12\x04\xfc\x06\x02\n\n\r\n\x05\x04\x14\x02\0\x06\x12\x04\xfc\x06\x0b\
    \x15\n\r\n\x05\x04\x14\x02\0\x01\x12\x04\xfc\x06\x16\x20\n\r\n\x05\x04\
    \x14\x02\0\x03\x12\x04\xfc\x06#$\n\x0e\n\x04\x04\x14\x03\0\x12\x06\xfd\
    \x06\x02\x8d\x07\x03\n\r\n\x05\x04\x14\x03\0\x01\x12\x04\xfd\x06\n\x14\n\
    \x8f\x01\n\x06\x04\x14\x03\0\x02\0\x12\x04\x80\x07\x04,\x1a\x7f\x20Ident\
    ifies\x20the\x20element\x20in\x20the\x20original\x20source\x20.proto\x20\
    file.\x20This\x20field\n\x20is\x20formatted\x20the\x20same\x20as\x20Sour\
    ceCodeInfo.Location.path.\n\n\x0f\n\x07\x04\x14\x03\0\x02\0\x04\x12\x04\
    \x80\x07\x04\x0c\n\x0f\n\x07\x04\x14\x03\0\x02\0\x05\x12\x04\x80\x07\r\
    \x12\n\x0f\n\x07\x04\x14\x03\0\x02\0\x01\x12\x04\x80\x07\x13\x17\n\x0f\n\
    \x07\x04\x14\x03\0\x02\0\x03\x12\x04\x80\x07\x1a\x1b\n\x0f\n\x07\x04\x14\
    \x03\0\x02\0\x08\x12\x04\x80\x07\x1c+\n\x10\n\x08\x04\x14\x03\0\x02\0\
    \x08\x02\x12\x04\x80\x07\x1d*\nO\n\x06\x04\x14\x03\0\x02\x01\x12\x04\x83\
    \x07\x04$\x1a?\x20Identifies\x20the\x20filesystem\x20path\x20to\x20the\
    \x20original\x20source\x20.proto.\n\n\x0f\n\x07\x04\x14\x03\0\x02\x01\
    \x04\x12\x04\x83\x07\x04\x0c\n\x0f\n\x07\x04\x14\x03\0\x02\x01\x05\x12\
    \x04\x83\x07\r\x13\n\x0f\n\x07\x04\x14\x03\0\x02\x01\x01\x12\x04\x83\x07\
    \x14\x1f\n\x0f\n\x07\x04\x14\x03\0\x02\x01\x03\x12\x04\x83\x07\"#\nw\n\
    \x06\x04\x14\x03\0\x02\x02\x12\x04\x87\x07\x04\x1d\x1ag\x20Identifies\
    \x20the\x20starting\x20offset\x20in\x20bytes\x20in\x20the\x20generated\
    \x20code\n\x20that\x20relates\x20to\x20the\x20identified\x20object.\n\n\
    \x0f\n\x07\x04\x14\x03\0\x02\x02\x04\x12\x04\x87\x07\x04\x0c\n\x0f\n\x07\
    \x04\x14\x03\0\x02\x02\x05\x12\x04\x87\x07\r\x12\n\x0f\n\x07\x04\x14\x03\
    \0\x02\x02\x01\x12\x04\x87\x07\x13\x18\n\x0f\n\x07\x04\x14\x03\0\x02\x02\
    \x03\x12\x04\x87\x07\x1b\x1c\n\xdb\x01\n\x06\x04\x14\x03\0\x02\x03\x12\
    \x04\x8c\x07\x04\x1b\x1a\xca\x01\x20Identifies\x20the\x20ending\x20offse\
    t\x20in\x20bytes\x20in\x20the\x20generated\x20code\x20that\n\x20relates\
    \x20to\x20the\x20identified\x20offset.\x20The\x20end\x20offset\x20should\
    \x20be\x20one\x20past\n\x20the\x20last\x20relevant\x20byte\x20(so\x20the\
    \x20length\x20of\x20the\x20text\x20=\x20end\x20-\x20begin).\n\n\x0f\n\
    \x07\x04\x14\x03\0\x02\x03\x04\x12\x04\x8c\x07\x04\x0c\n\x0f\n\x07\x04\
    \x14\x03\0\x02\x03\x05\x12\x04\x8c\x07\r\x12\n\x0f\n\x07\x04\x14\x03\0\
    \x02\x03\x01\x12\x04\x8c\x07\x13\x16\n\x0f\n\x07\x04\x14\x03\0\x02\x03\
    \x03\x12\x04\x8c\x07\x19\x1a\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static crate::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: crate::rt::Lazy<crate::descriptor::FileDescriptorProto> = crate::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        crate::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static crate::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: crate::rt::Lazy<crate::reflect::GeneratedFileDescriptor> = crate::rt::Lazy::new();
    static file_descriptor: crate::rt::Lazy<crate::reflect::FileDescriptor> = crate::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(27);
            messages.push(FileDescriptorSet::generated_message_descriptor_data());
            messages.push(FileDescriptorProto::generated_message_descriptor_data());
            messages.push(DescriptorProto::generated_message_descriptor_data());
            messages.push(ExtensionRangeOptions::generated_message_descriptor_data());
            messages.push(FieldDescriptorProto::generated_message_descriptor_data());
            messages.push(OneofDescriptorProto::generated_message_descriptor_data());
            messages.push(EnumDescriptorProto::generated_message_descriptor_data());
            messages.push(EnumValueDescriptorProto::generated_message_descriptor_data());
            messages.push(ServiceDescriptorProto::generated_message_descriptor_data());
            messages.push(MethodDescriptorProto::generated_message_descriptor_data());
            messages.push(FileOptions::generated_message_descriptor_data());
            messages.push(MessageOptions::generated_message_descriptor_data());
            messages.push(FieldOptions::generated_message_descriptor_data());
            messages.push(OneofOptions::generated_message_descriptor_data());
            messages.push(EnumOptions::generated_message_descriptor_data());
            messages.push(EnumValueOptions::generated_message_descriptor_data());
            messages.push(ServiceOptions::generated_message_descriptor_data());
            messages.push(MethodOptions::generated_message_descriptor_data());
            messages.push(UninterpretedOption::generated_message_descriptor_data());
            messages.push(SourceCodeInfo::generated_message_descriptor_data());
            messages.push(GeneratedCodeInfo::generated_message_descriptor_data());
            messages.push(descriptor_proto::ExtensionRange::generated_message_descriptor_data());
            messages.push(descriptor_proto::ReservedRange::generated_message_descriptor_data());
            messages.push(enum_descriptor_proto::EnumReservedRange::generated_message_descriptor_data());
            messages.push(uninterpreted_option::NamePart::generated_message_descriptor_data());
            messages.push(source_code_info::Location::generated_message_descriptor_data());
            messages.push(generated_code_info::Annotation::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(6);
            enums.push(field_descriptor_proto::Type::generated_enum_descriptor_data());
            enums.push(field_descriptor_proto::Label::generated_enum_descriptor_data());
            enums.push(file_options::OptimizeMode::generated_enum_descriptor_data());
            enums.push(field_options::CType::generated_enum_descriptor_data());
            enums.push(field_options::JSType::generated_enum_descriptor_data());
            enums.push(method_options::IdempotencyLevel::generated_enum_descriptor_data());
            crate::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        crate::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}

'''
'''--- protobuf/src/doctest_pb.rs ---
// This file is generated by rust-protobuf 4.0.0-alpha.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `doctest_pb.proto`

// @@protoc_insertion_point(message:MyMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MyMessage {
    // special fields
    // @@protoc_insertion_point(special_field:MyMessage.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MyMessage {
    fn default() -> &'a MyMessage {
        <MyMessage as crate::Message>::default_instance()
    }
}

impl MyMessage {
    pub fn new() -> MyMessage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<MyMessage>(
            "MyMessage",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for MyMessage {
    const NAME: &'static str = "MyMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MyMessage {
        MyMessage::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MyMessage {
        static instance: MyMessage = MyMessage {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for MyMessage {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MyMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MyMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for MyMessage {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x10doctest_pb.proto\"\x0b\n\tMyMessageJG\n\x06\x12\x04\x02\0\x05\x01\
    \n%\n\x01\x0c\x12\x03\x02\0\x122\x1b\x20Messages\x20used\x20in\x20doctes\
    ts\n\n\n\n\x02\x04\0\x12\x04\x04\0\x05\x01\n\n\n\x03\x04\0\x01\x12\x03\
    \x04\x08\x11b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static crate::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: crate::rt::Lazy<crate::descriptor::FileDescriptorProto> = crate::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        crate::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static crate::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: crate::rt::Lazy<crate::reflect::GeneratedFileDescriptor> = crate::rt::Lazy::new();
    static file_descriptor: crate::rt::Lazy<crate::reflect::FileDescriptor> = crate::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(1);
            messages.push(MyMessage::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            crate::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        crate::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}

'''
'''--- protobuf/src/enum_full.rs ---
use crate::reflect::EnumDescriptor;
use crate::reflect::EnumValueDescriptor;
use crate::Enum;

/// Trait is implemented for all enum types if lite runtime is not requested.
///
/// This trait provides access to runtime reflection.
pub trait EnumFull: Enum {
    /// Get enum value descriptor.
    fn descriptor(&self) -> EnumValueDescriptor;

    /// Get enum descriptor by type.
    fn enum_descriptor() -> EnumDescriptor;
}

'''
'''--- protobuf/src/enum_or_unknown.rs ---
use std::fmt;
use std::marker::PhantomData;
use std::mem;

use crate::reflect::runtime_types::RuntimeTypeEnumOrUnknown;
use crate::reflect::EnumDescriptor;
use crate::reflect::ProtobufValue;
use crate::Enum;
use crate::EnumFull;

/// Protobuf enums with possibly unknown values are preserved in this struct.
#[derive(Eq, PartialEq, Ord, PartialOrd, Copy, Clone)]
#[repr(transparent)]
// This should be <E: ProtobufEnum> when it no longer prevents using const fns.
pub struct EnumOrUnknown<E> {
    value: i32,
    _marker: PhantomData<E>,
}

// Move into <E: ProtobufEnum> when no longer:
// > trait bounds other than `Sized` on const fn parameters are unstable.
impl<E> EnumOrUnknown<E> {
    /// Construct from any `i32` value.
    ///
    /// Note passed value is not required to be a valid enum value.
    pub const fn from_i32(value: i32) -> EnumOrUnknown<E> {
        EnumOrUnknown {
            value,
            _marker: PhantomData,
        }
    }
}

impl<E: Enum> EnumOrUnknown<E> {
    /// Construct from typed enum
    pub fn new(e: E) -> EnumOrUnknown<E> {
        EnumOrUnknown::from_i32(e.value())
    }

    /// Get contained `i32` value of enum
    pub fn value(&self) -> i32 {
        self.value
    }

    /// Get `i32` value as typed enum. Return `None` is value is unknown.
    pub fn enum_value(&self) -> Result<E, i32> {
        E::from_i32(self.value).ok_or(self.value)
    }

    /// Get contained enum, panic if value is unknown.
    pub fn unwrap(&self) -> E {
        self.enum_value().unwrap()
    }

    /// Get `i32` value as typed enum.
    /// Return default enum value (first value) if value is unknown.
    pub fn enum_value_or_default(&self) -> E {
        self.enum_value().unwrap_or_default()
    }

    /// Get `i32` value as typed enum.
    /// Return given enum value if value is unknown.
    pub fn enum_value_or(&self, map_unknown: E) -> E {
        self.enum_value().unwrap_or(map_unknown)
    }

    pub(crate) fn cast_to_values(enums: &[EnumOrUnknown<E>]) -> &[i32] {
        assert_eq!(mem::size_of::<EnumOrUnknown<E>>(), mem::size_of::<i32>());
        // SAFETY: `EnumOrUnknown` is `repr(C)`.
        unsafe { std::slice::from_raw_parts(enums.as_ptr() as *const i32, enums.len()) }
    }
}

impl<E: EnumFull> EnumOrUnknown<E> {
    /// Get enum descriptor by type.
    pub fn enum_descriptor() -> EnumDescriptor {
        E::enum_descriptor()
    }
}

impl<E: Enum> From<E> for EnumOrUnknown<E> {
    fn from(e: E) -> Self {
        EnumOrUnknown::new(e)
    }
}

impl<E: Enum> Default for EnumOrUnknown<E> {
    fn default() -> EnumOrUnknown<E> {
        EnumOrUnknown::new(E::default())
    }
}

impl<E: Enum + fmt::Debug> fmt::Debug for EnumOrUnknown<E> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self.enum_value() {
            Ok(e) => fmt::Debug::fmt(&e, f),
            Err(e) => fmt::Debug::fmt(&e, f),
        }
    }
}

impl<E: EnumFull> ProtobufValue for EnumOrUnknown<E> {
    type RuntimeType = RuntimeTypeEnumOrUnknown<E>;
}

'''
'''--- protobuf/src/enums.rs ---
use std::fmt;

/// Trait implemented by all protobuf enum types.
///
/// Additionally, generated enums also implement [`EnumFull`](crate::EnumFull) trait,
/// which provides access to reflection.
pub trait Enum: Eq + Sized + Copy + fmt::Debug + Default + Send + Sync + 'static {
    /// Enum name as specified in `.proto` file.
    ///
    /// There's full reflection when non-lite runtime code generation is used,
    /// and enums implement [`EnumFull`](crate::EnumFull) trait.
    /// This operation is for lite runtime.
    const NAME: &'static str;

    /// Get enum `i32` value.
    fn value(&self) -> i32;

    /// Try to create an enum from `i32` value.
    /// Return `None` if value is unknown.
    fn from_i32(v: i32) -> Option<Self>;

    /// Try to create an enum from `&str` value.
    /// Return `None` if str is unknown.
    fn from_str(s: &str) -> Option<Self>;

    /// All enum values for enum type.
    const VALUES: &'static [Self] = &[];
}

'''
'''--- protobuf/src/error.rs ---
use std::io;
use std::str;

use crate::reflect::error::ReflectError;
use crate::wire_format::WireType;

/// [`Result`] alias for [`Error`].
pub type Result<T> = std::result::Result<T, crate::Error>;

/// Enum values added here for diagnostic purposes.
/// Users should not depend on specific values.
#[derive(Debug, thiserror::Error)]
pub(crate) enum WireError {
    #[error("Unexpected EOF")]
    UnexpectedEof,
    #[error("Unexpected wire type")]
    UnexpectedWireType(WireType),
    #[error("Incorrect tag")]
    IncorrectTag(u32),
    #[error("Incorrect varint")]
    IncorrectVarint,
    #[error("Invalid UTF-8 sequence")]
    Utf8Error,
    #[error("Invalid enum `{}` value: {}", .0, .1)]
    InvalidEnumValue(&'static str, i32),
    #[error("Over recursion limit")]
    OverRecursionLimit,
    #[error("Truncated message")]
    TruncatedMessage,
    // not really possible
    #[error("Limit overflow")]
    LimitOverflow,
    #[error("New limit must not be greater than current limit")]
    LimitIncrease,
    #[error("Encoded message size {0} is too large")]
    MessageTooLarge(u64),
    #[error("Value too large for u32: {}", .0)]
    U32Overflow(u64),
    #[error("Value too large for i32: {}", .0)]
    I32Overflow(i64),
}

/// Generic protobuf error
#[derive(Debug, thiserror::Error)]
pub(crate) enum ProtobufError {
    /// I/O error when reading or writing
    #[error(transparent)]
    IoError(#[from] io::Error),
    /// Malformed input
    #[error(transparent)]
    WireError(#[from] WireError),
    #[error(transparent)]
    Reflect(#[from] ReflectError),
    /// Protocol contains a string which is not valid UTF-8 string
    #[error("UTF-8 decode error")]
    Utf8(
        #[source]
        #[from]
        str::Utf8Error,
    ),
    /// Not all required fields of message set.
    #[error("Message `{}` is missing required fields", .0)]
    MessageNotInitialized(String),
    /// Message is too large.
    #[error("Provided buffer has not enough capacity to write message `{0}`")]
    BufferHasNotEnoughCapacity(String),
    /// Protobuf type and runtime types mismatch.
    #[error("Protobuf type and runtime types are not compatible")]
    IncompatibleProtobufTypeAndRuntimeType,
    /// Group field type not implemented.
    #[error("Group field is not supported")]
    GroupIsNotImplemented,
}

/// Error type for protobuf operations.
#[derive(Debug, thiserror::Error)]
#[error(transparent)]
pub struct Error(pub(crate) Box<ProtobufError>);

impl From<ProtobufError> for Error {
    #[cold]
    fn from(e: ProtobufError) -> Self {
        Self(Box::new(e))
    }
}

impl From<WireError> for Error {
    #[cold]
    fn from(e: WireError) -> Self {
        Self(Box::new(ProtobufError::WireError(e)))
    }
}

impl From<ReflectError> for Error {
    #[cold]
    fn from(e: ReflectError) -> Self {
        Self(Box::new(ProtobufError::Reflect(e)))
    }
}

impl From<Error> for io::Error {
    #[cold]
    fn from(err: Error) -> Self {
        match *err.0 {
            ProtobufError::IoError(e) => e,
            ProtobufError::WireError(e) => {
                io::Error::new(io::ErrorKind::InvalidData, ProtobufError::WireError(e))
            }
            ProtobufError::MessageNotInitialized(message) => io::Error::new(
                io::ErrorKind::InvalidInput,
                ProtobufError::MessageNotInitialized(message),
            ),
            e => io::Error::new(io::ErrorKind::Other, Box::new(e)),
        }
    }
}

impl From<io::Error> for Error {
    #[cold]
    fn from(err: io::Error) -> Self {
        Error(Box::new(ProtobufError::IoError(err)))
    }
}

#[cfg(test)]
mod test {
    use std::mem;

    #[test]
    fn error_size() {
        assert_eq!(mem::size_of::<usize>(), mem::size_of::<crate::Error>());
    }
}

'''
'''--- protobuf/src/ext.rs ---
//! Utilities to support "extension" fields.
//!
//! This is a stopgap implementation, it only allows to fetch basic singular values,
//! and that's it. Anything similar to extension registry is not implemented yet.
//!
//! Extensions are [described in the official protobuf documentation][exts].
//!
//! [exts]: https://developers.google.com/protocol-buffers/docs/proto#extensions

use std::marker::PhantomData;

use crate::descriptor::field_descriptor_proto::Type;
use crate::reflect::runtime_types::RuntimeTypeTrait;
use crate::reflect::ProtobufValue;
use crate::Message;

/// Optional ext field
///
/// This is initialized from generated code, do not instantiate directly.
pub struct ExtFieldOptional<M, T> {
    /// Extension field number.
    field_number: u32,
    /// Extension field type.
    field_type: Type,
    /// Marker
    phantom: PhantomData<(M, T)>,
}

/// Repeated ext field
///
/// This is initialized from generated code, do not instantiate directly.
pub struct ExtFieldRepeated<M, V> {
    /// Extension field number
    #[allow(dead_code)]
    field_number: u32,
    /// Field type.
    #[allow(dead_code)]
    field_type: Type,
    /// Extension field number
    phantom: PhantomData<(M, V)>,
}

impl<M, V> ExtFieldOptional<M, V> {
    /// Constructor. Called from generated code.
    pub const fn new(field_number: u32, field_type: Type) -> Self {
        ExtFieldOptional {
            field_number,
            field_type,
            phantom: PhantomData,
        }
    }
}

impl<M: Message, V: ProtobufValue> ExtFieldOptional<M, V> {
    /// Get a copy of value from a message.
    ///
    /// Extension data is stored in [`UnknownFields`](crate::UnknownFields).
    pub fn get(&self, m: &M) -> Option<V> {
        m.unknown_fields()
            .get(self.field_number)
            .and_then(|u| V::RuntimeType::get_from_unknown(u, self.field_type))
    }
}

impl<M, V> ExtFieldRepeated<M, V> {
    /// Constructor. Called from generated code.
    pub const fn new(field_number: u32, field_type: Type) -> Self {
        ExtFieldRepeated {
            field_number,
            field_type,
            phantom: PhantomData,
        }
    }
}

impl<M: Message, V: ProtobufValue> ExtFieldRepeated<M, V> {
    /// Get a copy of value from a message (**not implemented**).
    pub fn get(&self, _m: &M) -> Vec<V> {
        unimplemented!("extension fields implementation in rust-protobuf is stopgap")
    }
}

'''
'''--- protobuf/src/fixed.rs ---
/// Fixed size integers.
pub(crate) trait ProtobufFixed {
    /// Size of this fixed type in bytes.
    const LEN: u32;
}

impl ProtobufFixed for u32 {
    const LEN: u32 = 4;
}

impl ProtobufFixed for i32 {
    const LEN: u32 = 4;
}

impl ProtobufFixed for u64 {
    const LEN: u32 = 8;
}

impl ProtobufFixed for i64 {
    const LEN: u32 = 8;
}

impl ProtobufFixed for f32 {
    const LEN: u32 = 4;
}

impl ProtobufFixed for f64 {
    const LEN: u32 = 8;
}

/// Technically `bool` is not fixed, but it can be considered as fixed
/// for the purpose of encoding.
impl ProtobufFixed for bool {
    const LEN: u32 = 1;
}

'''
'''--- protobuf/src/lazy.rs ---
use once_cell::sync::OnceCell;

/// Lazily initialized static variable.
///
/// Used in generated code.
///
/// Currently a wrapper around `once_cell`s `OnceCell`.
pub struct Lazy<T> {
    once_cell: OnceCell<T>,
}

impl<T> Lazy<T> {
    /// Uninitialized state.
    pub const fn new() -> Lazy<T> {
        Lazy {
            once_cell: OnceCell::new(),
        }
    }

    /// Lazily initialize the value.
    pub fn get(&self, f: impl FnOnce() -> T) -> &T {
        self.once_cell.get_or_init(f)
    }
}

'''
'''--- protobuf/src/lib.rs ---
//! # Library to read and write protocol buffers data
//!
//! ## Features
//!
//! This crate has one feature, which is `with-bytes`.
//!
//! `with-bytes` enables `protobuf` crate support for
//! [`bytes` crate](https://github.com/tokio-rs/bytes):
//! when parsing bytes or strings from `bytes::Bytes`,
//! `protobuf` will be able to reference the input instead of allocating subarrays.
//!
//! Note, codegen also need to be instructed to generate `Bytes` or `Chars` for
//! `bytes` or `string` protobuf types instead of default `Vec<u8>` or `String`,
//! just enabling option on this crate is not enough.
//!
//! See `Customize` struct in [`protobuf-codegen` crate](https://docs.rs/protobuf-codegen).
//!
//! ## Accompanying crates
//!
//! * [`protobuf-json-mapping`](https://docs.rs/protobuf-json-mapping)
//!   implements JSON parsing and serialization for protobuf messages.
//! * [`protobuf-codegen`](https://docs.rs/protobuf-codegen)
//!   can be used to generate rust code from `.proto` crates.
//! * [`protoc-bin-vendored`](https://docs.rs/protoc-bin-vendored)
//!   contains `protoc` command packed into the crate.
//! * [`protobuf-parse`](https://docs.rs/protobuf-parse) contains
//!   `.proto` file parser. Rarely need to be used directly,
//!   but can be used for mechanical processing of `.proto` files.

#![deny(missing_docs)]
#![deny(rustdoc::broken_intra_doc_links)]

pub use crate::coded_input_stream::CodedInputStream;
pub use crate::coded_output_stream::CodedOutputStream;
pub use crate::enum_full::EnumFull;
pub use crate::enum_or_unknown::EnumOrUnknown;
pub use crate::enums::Enum;
pub use crate::message::Message;
pub use crate::message_dyn::MessageDyn;
pub use crate::message_field::MessageField;
pub use crate::message_full::MessageFull;
pub use crate::oneof::Oneof;
pub use crate::oneof_full::OneofFull;
pub use crate::special::SpecialFields;
pub use crate::unknown::UnknownFields;
pub use crate::unknown::UnknownFieldsIter;
pub use crate::unknown::UnknownValue;
pub use crate::unknown::UnknownValueRef;
pub(crate) mod wire_format;
#[cfg(feature = "bytes")]
pub use crate::chars::Chars;
pub use crate::error::Error;
pub use crate::error::Result;

// generated
pub mod descriptor;
pub mod plugin;
pub mod rustproto;

mod byteorder;
mod coded_input_stream;
mod coded_output_stream;
mod enum_full;
mod enum_or_unknown;
mod enums;
mod error;
pub mod ext;
mod lazy;
mod message;
mod message_dyn;
mod message_field;
mod message_full;
mod oneof;
mod oneof_full;
mod owning_ref;
pub mod reflect;
pub mod rt;
pub mod text_format;
pub mod well_known_types;
mod well_known_types_util;

// used by test
#[cfg(test)]
#[path = "../../test-crates/protobuf-test-common/src/hex.rs"]
mod hex;

mod cached_size;
mod chars;
mod fixed;
mod special;
mod unknown;
mod varint;
mod zigzag;

mod misc;

// This does not work: https://github.com/rust-lang/rust/issues/67295
#[cfg(doctest)]
mod doctest_pb;

/// This symbol is in generated `version.rs`, include here for IDE
#[cfg(never)]
pub const VERSION: &str = "";
/// This symbol is in generated `version.rs`, include here for IDE
#[cfg(never)]
#[doc(hidden)]
pub const VERSION_IDENT: &str = "";
include!(concat!(env!("OUT_DIR"), "/version.rs"));

'''
'''--- protobuf/src/message.rs ---
use std::io::Read;
use std::io::Write;

use crate::coded_output_stream::with::WithCodedOutputStream;
use crate::error::ProtobufError;
use crate::wire_format::check_message_size;
use crate::CodedInputStream;
use crate::CodedOutputStream;
use crate::SpecialFields;
use crate::UnknownFields;

/// Trait which is implemented by all generated message.
///
/// Note, by default all generated messages also implement [`MessageFull`](crate::MessageFull)
/// trait which provides access to reflection and features which depend on reflection
/// (text format and JSON serialization).
pub trait Message: Default + Clone + Send + Sync + Sized + PartialEq + 'static {
    /// Message name as specified in `.proto` file.
    ///
    /// Message name can be accessed using
    /// [`MessageFull::descriptor`](crate::MessageFull::descriptor),
    /// but when lite runtime is requested, this field can be used.
    const NAME: &'static str;

    /// True iff all required fields are initialized.
    /// Always returns `true` for protobuf 3.
    fn is_initialized(&self) -> bool;

    /// Update this message object with fields read from given stream.
    fn merge_from(&mut self, is: &mut CodedInputStream) -> crate::Result<()>;

    /// Parse message from stream.
    fn parse_from(is: &mut CodedInputStream) -> crate::Result<Self> {
        let mut r: Self = Message::new();
        r.merge_from(is)?;
        r.check_initialized()?;
        Ok(r)
    }

    /// Write message to the stream.
    ///
    /// Sizes of this messages and nested messages must be cached
    /// by calling `compute_size` prior to this call.
    fn write_to_with_cached_sizes(&self, os: &mut CodedOutputStream) -> crate::Result<()>;

    /// Compute and cache size of this message and all nested messages.
    ///
    /// Note if the computation overflows u32, the cached size is stored truncated.
    fn compute_size(&self) -> u64;

    /// Get size previously computed by `compute_size`.
    ///
    /// Note if message size exceeds u32, the cached size is stored truncated.
    fn cached_size(&self) -> u32 {
        self.special_fields().cached_size().get()
    }

    /// Write the message to the stream.
    ///
    /// Results in error if message is not fully initialized.
    fn write_to(&self, os: &mut CodedOutputStream) -> crate::Result<()> {
        self.check_initialized()?;

        // cache sizes
        let size = self.compute_size();
        let size = check_message_size(size)?;
        os.reserve_additional(size as u32, Self::NAME)?;
        self.write_to_with_cached_sizes(os)?;

        Ok(())
    }

    /// Write the message to the stream prepending the message with message length
    /// encoded as varint.
    fn write_length_delimited_to(&self, os: &mut CodedOutputStream) -> crate::Result<()> {
        let size = self.compute_size();
        let size = check_message_size(size)?;

        os.reserve_additional_for_length_delimited(size, Self::NAME)?;

        os.write_raw_varint32(size)?;

        let written = os.total_bytes_written();

        self.write_to_with_cached_sizes(os)?;

        // Self-check.
        assert_eq!(
            written + size as u64,
            os.total_bytes_written(),
            "Expected to write {}, actually wrote {}",
            size,
            os.total_bytes_written() - written
        );

        Ok(())
    }

    /// Write the message to the vec, prepend the message with message length
    /// encoded as varint.
    fn write_length_delimited_to_vec(&self, vec: &mut Vec<u8>) -> crate::Result<()> {
        let mut os = CodedOutputStream::vec(vec);
        self.write_length_delimited_to(&mut os)?;
        os.flush()?;
        Ok(())
    }

    /// Update this message object with fields read from given stream.
    fn merge_from_bytes(&mut self, bytes: &[u8]) -> crate::Result<()> {
        let mut is = CodedInputStream::from_bytes(bytes);
        self.merge_from(&mut is)
    }

    /// Parse message from reader.
    /// Parse stops on EOF or when error encountered.
    fn parse_from_reader(reader: &mut dyn Read) -> crate::Result<Self> {
        let mut is = CodedInputStream::new(reader);
        let r = Message::parse_from(&mut is)?;
        is.check_eof()?;
        Ok(r)
    }

    /// Parse message from byte array.
    fn parse_from_bytes(bytes: &[u8]) -> crate::Result<Self> {
        let mut is = CodedInputStream::from_bytes(bytes);
        let r = Message::parse_from(&mut is)?;
        is.check_eof()?;
        Ok(r)
    }

    /// Parse message from `Bytes` object.
    /// Resulting message may share references to the passed bytes object.
    #[cfg(feature = "bytes")]
    fn parse_from_tokio_bytes(bytes: &bytes::Bytes) -> crate::Result<Self> {
        let mut is = CodedInputStream::from_tokio_bytes(bytes);
        let r = Self::parse_from(&mut is)?;
        is.check_eof()?;
        Ok(r)
    }

    /// Check if all required fields of this object are initialized.
    fn check_initialized(&self) -> crate::Result<()> {
        if !self.is_initialized() {
            Err(ProtobufError::MessageNotInitialized(Self::NAME.to_owned()).into())
        } else {
            Ok(())
        }
    }

    /// Write the message to the writer.
    fn write_to_writer(&self, w: &mut dyn Write) -> crate::Result<()> {
        w.with_coded_output_stream(|os| self.write_to(os))
    }

    /// Write the message to bytes vec.
    fn write_to_vec(&self, v: &mut Vec<u8>) -> crate::Result<()> {
        v.with_coded_output_stream(|os| self.write_to(os))
    }

    /// Write the message to bytes vec.
    ///
    /// > **Note**: You can use [`Message::parse_from_bytes`]
    /// to do the reverse.
    fn write_to_bytes(&self) -> crate::Result<Vec<u8>> {
        self.check_initialized()?;

        let size = self.compute_size() as usize;
        let mut v = Vec::with_capacity(size);
        let mut os = CodedOutputStream::vec(&mut v);
        self.write_to_with_cached_sizes(&mut os)?;
        os.flush()?;
        drop(os);
        Ok(v)
    }

    /// Write the message to the writer, prepend the message with message length
    /// encoded as varint.
    fn write_length_delimited_to_writer(&self, w: &mut dyn Write) -> crate::Result<()> {
        w.with_coded_output_stream(|os| self.write_length_delimited_to(os))
    }

    /// Write the message to the bytes vec, prepend the message with message length
    /// encoded as varint.
    fn write_length_delimited_to_bytes(&self) -> crate::Result<Vec<u8>> {
        let mut v = Vec::new();
        v.with_coded_output_stream(|os| self.write_length_delimited_to(os))?;
        Ok(v)
    }

    /// Special fields (unknown fields and cached size).
    fn special_fields(&self) -> &SpecialFields;
    /// Special fields (unknown fields and cached size).
    fn mut_special_fields(&mut self) -> &mut SpecialFields;

    /// Get a reference to unknown fields.
    fn unknown_fields(&self) -> &UnknownFields {
        &self.special_fields().unknown_fields()
    }
    /// Get a mutable reference to unknown fields.
    fn mut_unknown_fields(&mut self) -> &mut UnknownFields {
        self.mut_special_fields().mut_unknown_fields()
    }

    /// Create an empty message object.
    ///
    /// ```
    /// # use protobuf::MessageFull;
    /// # fn foo<MyMessage: MessageFull>() {
    /// let m = MyMessage::new();
    /// # }
    /// ```
    fn new() -> Self;

    /// Reset all fields.
    fn clear(&mut self) {
        *self = Self::new();
    }

    /// Return a pointer to default immutable message with static lifetime.
    ///
    /// ```
    /// # use protobuf::MessageFull;
    /// # fn foo<MyMessage: MessageFull>() {
    /// let m: &MyMessage = MyMessage::default_instance();
    /// # }
    /// ```
    fn default_instance() -> &'static Self;
}

'''
'''--- protobuf/src/message_dyn.rs ---
use std::any::Any;
use std::any::TypeId;
use std::fmt;
use std::io::Write;

use crate::coded_output_stream::with::WithCodedOutputStream;
use crate::error::ProtobufError;
use crate::reflect::MessageDescriptor;
use crate::reflect::ReflectEqMode;
use crate::wire_format::check_message_size;
use crate::CodedInputStream;
use crate::CodedOutputStream;
use crate::MessageFull;
use crate::SpecialFields;
use crate::UnknownFields;

/// Dynamic-dispatch version of either generated message or dynamic message.
///
/// Generated messages implement [`MessageFull`](crate::MessageFull) unless lite runtime requested.
/// Dynamic messages can be created with
/// [`FileDescriptor::new_dynamic`](crate::reflect::FileDescriptor::new_dynamic).
pub trait MessageDyn: Any + fmt::Debug + fmt::Display + Send + Sync + 'static {
    /// Message descriptor for this message, used for reflection.
    fn descriptor_dyn(&self) -> MessageDescriptor;

    /// Update this message fields with contents of given stream.
    fn merge_from_dyn(&mut self, is: &mut CodedInputStream) -> crate::Result<()>;

    /// Write the message.
    fn write_to_with_cached_sizes_dyn(&self, os: &mut CodedOutputStream) -> crate::Result<()>;

    /// Compute (and cache) the message size.
    fn compute_size_dyn(&self) -> u64;

    /// True iff all required fields are initialized.
    /// Always returns `true` for protobuf 3.
    fn is_initialized_dyn(&self) -> bool;

    /// Get a reference to special fields.
    fn special_fields_dyn(&self) -> &SpecialFields;
    /// Get a mutable reference to special fields.
    fn mut_special_fields_dyn(&mut self) -> &mut SpecialFields;
}

impl<M: MessageFull> MessageDyn for M {
    fn descriptor_dyn(&self) -> MessageDescriptor {
        M::descriptor()
    }

    fn merge_from_dyn(&mut self, is: &mut CodedInputStream) -> crate::Result<()> {
        self.merge_from(is)
    }

    fn write_to_with_cached_sizes_dyn(&self, os: &mut CodedOutputStream) -> crate::Result<()> {
        self.write_to_with_cached_sizes(os)
    }

    fn compute_size_dyn(&self) -> u64 {
        self.compute_size()
    }

    fn is_initialized_dyn(&self) -> bool {
        self.is_initialized()
    }

    fn special_fields_dyn(&self) -> &SpecialFields {
        self.special_fields()
    }

    fn mut_special_fields_dyn(&mut self) -> &mut SpecialFields {
        self.mut_special_fields()
    }
}

impl dyn MessageDyn {
    /// Check if all required fields of this object are initialized.
    pub fn check_initialized_dyn(&self) -> crate::Result<()> {
        if !self.is_initialized_dyn() {
            Err(
                ProtobufError::MessageNotInitialized(self.descriptor_dyn().name().to_owned())
                    .into(),
            )
        } else {
            Ok(())
        }
    }

    /// Write the message to the writer.
    pub fn write_to_writer_dyn(&self, w: &mut dyn Write) -> crate::Result<()> {
        w.with_coded_output_stream(|os| self.write_to_dyn(os))
    }

    /// Write the message to bytes vec.
    pub fn write_to_vec_dyn(&self, v: &mut Vec<u8>) -> crate::Result<()> {
        v.with_coded_output_stream(|os| self.write_to_dyn(os))
    }

    /// Write the message to the stream.
    ///
    /// Results in error if message is not fully initialized.
    pub fn write_to_dyn(&self, os: &mut CodedOutputStream) -> crate::Result<()> {
        self.check_initialized_dyn()?;

        // cache sizes
        let size = self.compute_size_dyn();
        let size = check_message_size(size)?;
        os.reserve_additional(size, self.descriptor_dyn().name())?;
        self.write_to_with_cached_sizes_dyn(os)?;

        Ok(())
    }

    /// Write the message to the vec, prepend the message with message length
    /// encoded as varint.
    pub fn write_length_delimited_to_vec_dyn(&self, vec: &mut Vec<u8>) -> crate::Result<()> {
        let mut os = CodedOutputStream::vec(vec);
        self.write_length_delimited_to_dyn(&mut os)?;
        os.flush()?;
        Ok(())
    }

    /// Update this message object with fields read from given stream.
    pub fn merge_from_bytes_dyn(&mut self, bytes: &[u8]) -> crate::Result<()> {
        let mut is = CodedInputStream::from_bytes(bytes);
        self.merge_from_dyn(&mut is)
    }

    /// Write the message to bytes vec.
    ///
    /// > **Note**: You can use [`Message::parse_from_bytes`](crate::Message::parse_from_bytes)
    /// to do the reverse.
    pub fn write_to_bytes_dyn(&self) -> crate::Result<Vec<u8>> {
        self.check_initialized_dyn()?;

        let size = self.compute_size_dyn();
        let size = check_message_size(size)?;
        let mut v = Vec::new();
        let mut os = CodedOutputStream::vec(&mut v);
        os.reserve_additional(size, self.descriptor_dyn().name())?;
        self.write_to_with_cached_sizes_dyn(&mut os)?;
        os.flush()?;
        drop(os);
        Ok(v)
    }

    /// Write the message to the stream prepending the message with message length
    /// encoded as varint.
    pub fn write_length_delimited_to_dyn(&self, os: &mut CodedOutputStream) -> crate::Result<()> {
        let size = self.compute_size_dyn();
        let size = check_message_size(size)?;
        os.reserve_additional_for_length_delimited(size, self.descriptor_dyn().name())?;
        os.write_raw_varint32(size)?;

        let pos = os.total_bytes_written();

        self.write_to_with_cached_sizes_dyn(os)?;

        // Cheap self-check.
        assert_eq!(os.total_bytes_written() - pos, size as u64);

        Ok(())
    }

    /// Write the message to the writer, prepend the message with message length
    /// encoded as varint.
    pub fn write_length_delimited_to_writer_dyn(&self, w: &mut dyn Write) -> crate::Result<()> {
        w.with_coded_output_stream(|os| self.write_length_delimited_to_dyn(os))
    }

    /// Write the message to the bytes vec, prepend the message with message length
    /// encoded as varint.
    pub fn write_length_delimited_to_bytes_dyn(&self) -> crate::Result<Vec<u8>> {
        let mut v = Vec::new();
        v.with_coded_output_stream(|os| self.write_length_delimited_to_dyn(os))?;
        Ok(v)
    }

    /// Get a reference to unknown fields.
    pub fn unknown_fields_dyn(&self) -> &UnknownFields {
        self.special_fields_dyn().unknown_fields()
    }
    /// Get a mutable reference to unknown fields.
    pub fn mut_unknown_fields_dyn(&mut self) -> &mut UnknownFields {
        self.mut_special_fields_dyn().mut_unknown_fields()
    }

    /// Downcast `Box<dyn Message>` to specific message type.
    ///
    /// ```
    /// # use protobuf::{MessageFull, MessageDyn};
    /// # fn foo<MyMessage: MessageFull>(message: Box<dyn MessageDyn>) {
    /// let m: Box<dyn MessageDyn> = message;
    /// let m: Box<MyMessage> = <dyn MessageDyn>::downcast_box(m).unwrap();
    /// # }
    /// ```
    pub fn downcast_box<T: Any>(
        self: Box<dyn MessageDyn>,
    ) -> std::result::Result<Box<T>, Box<dyn MessageDyn>> {
        if Any::type_id(&*self) == TypeId::of::<T>() {
            unsafe {
                let raw: *mut dyn MessageDyn = Box::into_raw(self);
                Ok(Box::from_raw(raw as *mut T))
            }
        } else {
            Err(self)
        }
    }

    /// Downcast `&dyn Message` to specific message type.
    ///
    /// ```
    /// # use protobuf::{MessageFull, MessageDyn};
    /// # fn foo<MyMessage: MessageFull>(message: &dyn MessageDyn) {
    /// let m: &dyn MessageDyn = message;
    /// let m: &MyMessage = <dyn MessageDyn>::downcast_ref(m).unwrap();
    /// # }
    /// ```
    pub fn downcast_ref<'a, M: MessageFull + 'a>(&'a self) -> Option<&'a M> {
        if Any::type_id(&*self) == TypeId::of::<M>() {
            unsafe { Some(&*(self as *const dyn MessageDyn as *const M)) }
        } else {
            None
        }
    }

    /// Downcast `&mut dyn Message` to specific message type.
    ///
    /// ```
    /// # use protobuf::{MessageFull, MessageDyn};
    /// # fn foo<MyMessage: MessageFull>(message: &mut dyn MessageDyn) {
    /// let m: &mut dyn MessageDyn = message;
    /// let m: &mut MyMessage = <dyn MessageDyn>::downcast_mut(m).unwrap();
    /// # }
    /// ```
    pub fn downcast_mut<'a, M: MessageFull + 'a>(&'a mut self) -> Option<&'a mut M> {
        if Any::type_id(&*self) == TypeId::of::<M>() {
            unsafe { Some(&mut *(self as *mut dyn MessageDyn as *mut M)) }
        } else {
            None
        }
    }

    /// Clone from a `dyn Message` reference.
    pub fn clone_box(&self) -> Box<dyn MessageDyn> {
        self.descriptor_dyn().clone_message(self)
    }

    /// Reflectively compare the messages.
    pub fn reflect_eq_dyn(&self, other: &dyn MessageDyn, mode: &ReflectEqMode) -> bool {
        MessageDescriptor::reflect_eq_maybe_unrelated(self, other, mode)
    }
}

impl Clone for Box<dyn MessageDyn> {
    fn clone(&self) -> Self {
        (*self).clone_box()
    }
}

impl PartialEq for Box<dyn MessageDyn> {
    fn eq(&self, other: &Box<dyn MessageDyn>) -> bool {
        MessageDescriptor::reflect_eq_maybe_unrelated(&**self, &**other, &ReflectEqMode::default())
    }
}

#[cfg(test)]
mod test {
    use crate::descriptor::FileDescriptorProto;
    use crate::MessageDyn;

    #[test]
    fn downcast_ref() {
        let m = FileDescriptorProto::new();
        let d = &m as &dyn MessageDyn;
        let c: &FileDescriptorProto = d.downcast_ref().unwrap();
        assert_eq!(
            c as *const FileDescriptorProto,
            &m as *const FileDescriptorProto
        );
    }

    #[test]
    fn downcast_mut() {
        let mut m = FileDescriptorProto::new();
        let d = &mut m as &mut dyn MessageDyn;
        let c: &mut FileDescriptorProto = d.downcast_mut().unwrap();
        assert_eq!(
            c as *const FileDescriptorProto,
            &m as *const FileDescriptorProto
        );
    }

    #[test]
    fn downcast_box() {
        let m = FileDescriptorProto::new();
        let d: Box<dyn MessageDyn> = Box::new(m);
        let mut _c: Box<FileDescriptorProto> = d.downcast_box().unwrap();
    }
}

'''
'''--- protobuf/src/message_field.rs ---
use std::default::Default;
use std::hash::Hash;
use std::ops::Deref;
use std::option;

use crate::Message;

/// Wrapper around `Option<Box<T>>`, convenient newtype.
///
/// # Examples
///
/// ```no_run
/// # use protobuf::MessageField;
/// # use std::ops::Add;
/// # struct Address {
/// # }
/// # struct Customer {
/// #     address: MessageField<Address>,
/// # }
/// # impl Customer {
/// #     fn new() -> Customer { unimplemented!() }
/// # }
/// #
/// #
/// # fn make_address() -> Address { unimplemented!() }
/// let mut customer = Customer::new();
///
/// // field of type `SingularPtrField` can be initialized like this
/// customer.address = MessageField::some(make_address());
/// // or using `Option` and `Into`
/// customer.address = Some(make_address()).into();
/// ```
#[derive(Clone, Debug, Eq, PartialEq, Hash)]
pub struct MessageField<T>(pub Option<Box<T>>);

impl<T> MessageField<T> {
    /// Construct `SingularPtrField` from given object.
    #[inline]
    pub fn some(value: T) -> MessageField<T> {
        MessageField(Some(Box::new(value)))
    }

    /// Construct an empty `SingularPtrField`.
    #[inline]
    pub const fn none() -> MessageField<T> {
        MessageField(None)
    }

    /// Construct `SingularPtrField` from optional.
    #[inline]
    pub fn from_option(option: Option<T>) -> MessageField<T> {
        match option {
            Some(x) => MessageField::some(x),
            None => MessageField::none(),
        }
    }

    /// True iff this object contains data.
    #[inline]
    pub fn is_some(&self) -> bool {
        self.0.is_some()
    }

    /// True iff this object contains no data.
    #[inline]
    pub fn is_none(&self) -> bool {
        self.0.is_none()
    }

    /// Convert into `Option<T>`.
    #[inline]
    pub fn into_option(self) -> Option<T> {
        self.0.map(|v| *v)
    }

    /// View data as reference option.
    #[inline]
    pub fn as_ref(&self) -> Option<&T> {
        self.0.as_ref().map(|v| &**v)
    }

    /// View data as mutable reference option.
    #[inline]
    pub fn as_mut(&mut self) -> Option<&mut T> {
        self.0.as_mut().map(|v| &mut **v)
    }

    /// Take the data.
    /// Panics if empty
    #[inline]
    pub fn unwrap(self) -> T {
        *self.0.unwrap()
    }

    /// Take the data or return supplied default element if empty.
    #[inline]
    pub fn unwrap_or(self, def: T) -> T {
        self.0.map(|v| *v).unwrap_or(def)
    }

    /// Take the data or return supplied default element if empty.
    #[inline]
    pub fn unwrap_or_else<F>(self, f: F) -> T
    where
        F: FnOnce() -> T,
    {
        self.0.map(|v| *v).unwrap_or_else(f)
    }

    /// Apply given function to contained data to construct another `SingularPtrField`.
    /// Returns empty `SingularPtrField` if this object is empty.
    #[inline]
    pub fn map<U, F>(self, f: F) -> MessageField<U>
    where
        F: FnOnce(T) -> U,
    {
        MessageField::from_option(self.into_option().map(f))
    }

    /// View data as iterator.
    #[inline]
    pub fn iter(&self) -> option::IntoIter<&T> {
        self.as_ref().into_iter()
    }

    /// View data as mutable iterator.
    #[inline]
    pub fn mut_iter(&mut self) -> option::IntoIter<&mut T> {
        self.as_mut().into_iter()
    }

    /// Take data as option, leaving this object empty.
    #[inline]
    pub fn take(&mut self) -> Option<T> {
        self.0.take().map(|v| *v)
    }

    /// Clear this object, but do not call destructor of underlying data.
    #[inline]
    pub fn clear(&mut self) {
        self.0 = None;
    }
}

impl<T: Default> MessageField<T> {
    /// Get contained data, consume self. Return default value for type if this is empty.
    #[inline]
    pub fn unwrap_or_default(self) -> T {
        *self.0.unwrap_or_default()
    }
}

impl<M: Message> MessageField<M> {
    /// Get a reference to contained value or a default instance.
    pub fn get_or_default(&self) -> &M {
        self.as_ref().unwrap_or_else(|| M::default_instance())
    }

    /// Get a mutable reference to contained value, initialize if not initialized yet.
    pub fn mut_or_insert_default(&mut self) -> &mut M {
        if self.is_none() {
            *self = MessageField::some(Default::default());
        }
        self.as_mut().unwrap()
    }
}

/// Get a reference to contained value or a default instance if the field is not initialized.
impl<M: Message> Deref for MessageField<M> {
    type Target = M;

    fn deref(&self) -> &Self::Target {
        self.get_or_default()
    }
}

/// Get a mutable reference to the message **and** initialize the message if not initialized yet.
///
/// Note that part about initializing is not conventional.
/// Generally `DerefMut` is not supposed to modify the state.
#[cfg(no)]
impl<M: Message> DerefMut for MessageField<M> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        self.mut_or_insert_default()
    }
}

impl<T> Default for MessageField<T> {
    #[inline]
    fn default() -> MessageField<T> {
        MessageField::none()
    }
}

/// We don't have `From<Option<Box<T>>> for MessageField<T>` because
/// it would make type inference worse.
impl<T> From<Option<T>> for MessageField<T> {
    fn from(o: Option<T>) -> Self {
        MessageField::from_option(o)
    }
}

impl<'a, T> IntoIterator for &'a MessageField<T> {
    type Item = &'a T;
    type IntoIter = option::IntoIter<&'a T>;

    fn into_iter(self) -> option::IntoIter<&'a T> {
        self.iter()
    }
}

'''
'''--- protobuf/src/message_full.rs ---
use std::fmt;

use crate::message_dyn::MessageDyn;
use crate::reflect::reflect_eq::ReflectEqMode;
use crate::reflect::MessageDescriptor;
use crate::reflect::ProtobufValue;
use crate::Message;

/// Trait implemented for all the generated messages, except when lite runtime is enabled.
///
/// When lite runtime is enabled, only `MessageLite` is implemented.
///
/// * Generated messages are generated from `.proto` files
/// * Dynamic messages can be created without code generation using only parsed proto files
///   (see [FileDescriptor::new_dynamic](crate::reflect::FileDescriptor::new_dynamic)).
///
/// Also, generated messages implement `Default + PartialEq`
///
/// This trait is sized, there's accompanying [`MessageDyn`](crate::MessageDyn) trait
/// which is implemented for all messages which can be used in functions
/// without making message a function type parameter.
///
/// ## `Display`
///
/// [`Display`](fmt::Display) implementation for messages does protobuf text format.
/// See [`text_format`](crate::text_format) for more details.
pub trait MessageFull: Message + ProtobufValue + fmt::Debug + fmt::Display {
    /// Get message descriptor for message type.
    ///
    /// ```
    /// # use protobuf::MessageFull;
    /// # fn foo<MyMessage: MessageFull>() {
    /// let descriptor = MyMessage::descriptor();
    /// assert_eq!("MyMessage", descriptor.name());
    /// # }
    /// ```
    fn descriptor() -> MessageDescriptor;

    /// Reflective equality.
    ///
    /// # See also
    ///
    /// [`dyn Message::reflect_eq_dyn()`], `dyn` version of this function.
    fn reflect_eq(&self, other: &Self, mode: &ReflectEqMode) -> bool {
        <dyn MessageDyn>::reflect_eq_dyn(self, other, mode)
    }
}

'''
'''--- protobuf/src/misc.rs ---
use std::mem;
use std::mem::MaybeUninit;

use crate::well_known_types;

/// `MaybeUninit::write_slice` is not stable.
pub(crate) fn maybe_uninit_write_slice<'a, T>(
    this: &'a mut [MaybeUninit<T>],
    src: &[T],
) -> &'a mut [T]
where
    T: Copy,
{
    // SAFETY: copy-paste from rust stdlib.

    let uninit_src: &[MaybeUninit<T>] = unsafe { mem::transmute(src) };

    this.copy_from_slice(uninit_src);

    unsafe { &mut *(this as *mut [MaybeUninit<T>] as *mut [T]) }
}

/// `MaybeUninit::array_assume_init` is not stable.
#[inline]
pub(crate) unsafe fn maybe_ununit_array_assume_init<T, const N: usize>(
    array: [MaybeUninit<T>; N],
) -> [T; N] {
    // SAFETY:
    // * The caller guarantees that all elements of the array are initialized
    // * `MaybeUninit<T>` and T are guaranteed to have the same layout
    // * `MaybeUninit` does not drop, so there are no double-frees
    // And thus the conversion is safe
    (&array as *const _ as *const [T; N]).read()
}

// bool <-> BoolValue

impl From<well_known_types::wrappers::BoolValue> for bool {
    fn from(inner: well_known_types::wrappers::BoolValue) -> Self {
        inner.value
    }
}

impl From<bool> for well_known_types::wrappers::BoolValue {
    fn from(inner: bool) -> Self {
        let mut value = Self::new();
        value.value = inner;
        value
    }
}

// Vec<u8> <-> BytesValue

impl From<well_known_types::wrappers::BytesValue> for Vec<u8> {
    fn from(inner: well_known_types::wrappers::BytesValue) -> Self {
        inner.value
    }
}

impl From<Vec<u8>> for well_known_types::wrappers::BytesValue {
    fn from(inner: Vec<u8>) -> Self {
        let mut value = Self::new();
        value.value = inner;
        value
    }
}

// f64 <-> DoubleValue

impl From<well_known_types::wrappers::DoubleValue> for f64 {
    fn from(inner: well_known_types::wrappers::DoubleValue) -> Self {
        inner.value
    }
}

impl From<f64> for well_known_types::wrappers::DoubleValue {
    fn from(inner: f64) -> Self {
        let mut value = Self::new();
        value.value = inner;
        value
    }
}

// f32 <-> FloatValue

impl From<well_known_types::wrappers::FloatValue> for f32 {
    fn from(inner: well_known_types::wrappers::FloatValue) -> Self {
        inner.value
    }
}

impl From<f32> for well_known_types::wrappers::FloatValue {
    fn from(inner: f32) -> Self {
        let mut value = Self::new();
        value.value = inner;
        value
    }
}

// i32 <-> Int32Value

impl From<well_known_types::wrappers::Int32Value> for i32 {
    fn from(inner: well_known_types::wrappers::Int32Value) -> Self {
        inner.value
    }
}

impl From<i32> for well_known_types::wrappers::Int32Value {
    fn from(inner: i32) -> Self {
        let mut value = Self::new();
        value.value = inner;
        value
    }
}

// i64 <-> Int64Value

impl From<well_known_types::wrappers::Int64Value> for i64 {
    fn from(inner: well_known_types::wrappers::Int64Value) -> Self {
        inner.value
    }
}

impl From<i64> for well_known_types::wrappers::Int64Value {
    fn from(inner: i64) -> Self {
        let mut value = Self::new();
        value.value = inner;
        value
    }
}

// u32 <-> UInt32Value

impl From<well_known_types::wrappers::UInt32Value> for u32 {
    fn from(inner: well_known_types::wrappers::UInt32Value) -> Self {
        inner.value
    }
}

impl From<u32> for well_known_types::wrappers::UInt32Value {
    fn from(inner: u32) -> Self {
        let mut value = Self::new();
        value.value = inner;
        value
    }
}

// u64 <-> UInt64Value

impl From<well_known_types::wrappers::UInt64Value> for u64 {
    fn from(inner: well_known_types::wrappers::UInt64Value) -> Self {
        inner.value
    }
}

impl From<u64> for well_known_types::wrappers::UInt64Value {
    fn from(inner: u64) -> Self {
        let mut value = Self::new();
        value.value = inner;
        value
    }
}

// () <-> Empty

impl From<well_known_types::empty::Empty> for () {
    fn from(_inner: well_known_types::empty::Empty) -> Self {}
}

impl From<()> for well_known_types::empty::Empty {
    fn from(_inner: ()) -> Self {
        Self::new()
    }
}

'''
'''--- protobuf/src/oneof.rs ---
/// Trait implemented by all oneof types in generated code.
pub trait Oneof {}

'''
'''--- protobuf/src/oneof_full.rs ---
use crate::reflect::OneofDescriptor;
use crate::Oneof;

/// Implemented by all oneof types when lite runtime is not enabled.
pub trait OneofFull: Oneof {
    /// Descriptor object for this oneof.
    fn descriptor() -> OneofDescriptor;
}

'''
'''--- protobuf/src/owning_ref.rs ---
//! Utility similar to provided by `owning_ref` crate.

use std::fmt;
use std::fmt::Debug;
use std::ops::Deref;
use std::sync::Arc;

enum Owner<A: 'static> {
    Arc(Arc<A>),
    Static(&'static A),
}

impl<A: 'static> Deref for Owner<A> {
    type Target = A;

    fn deref(&self) -> &A {
        match self {
            Owner::Arc(a) => &*a,
            Owner::Static(a) => a,
        }
    }
}

pub(crate) struct OwningRef<A: 'static, B: 'static> {
    owner: Owner<A>,
    ptr: *const B,
}

unsafe impl<A: Send + Sync + 'static, B: Send + Sync + 'static> Sync for OwningRef<A, B> {}
unsafe impl<A: Send + Sync + 'static, B: Send + Sync + 'static> Send for OwningRef<A, B> {}

impl<A: 'static, B: 'static> Deref for OwningRef<A, B> {
    type Target = B;

    fn deref(&self) -> &B {
        // SAFETY: `self.owner` owns the data and it is not movable.
        unsafe { &*self.ptr }
    }
}

impl<A: 'static> Clone for Owner<A> {
    fn clone(&self) -> Owner<A> {
        match self {
            Owner::Arc(arc) => Owner::Arc(arc.clone()),
            Owner::Static(ptr) => Owner::Static(ptr),
        }
    }
}

impl<A: 'static, B: 'static> Clone for OwningRef<A, B> {
    fn clone(&self) -> OwningRef<A, B> {
        OwningRef {
            ptr: self.ptr,
            owner: self.owner.clone(),
        }
    }
}

impl<A: 'static, B: fmt::Debug + 'static> Debug for OwningRef<A, B> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        Debug::fmt(&**self, f)
    }
}

impl<A: 'static> OwningRef<A, A> {
    pub(crate) fn new_arc(arc: Arc<A>) -> OwningRef<A, A> {
        OwningRef {
            ptr: Arc::as_ptr(&arc),
            owner: Owner::Arc(arc),
        }
    }

    pub(crate) fn new_static(ptr: &'static A) -> OwningRef<A, A> {
        OwningRef {
            ptr,
            owner: Owner::Static(ptr),
        }
    }

    pub(crate) fn owner(&self) -> &A {
        &self.owner
    }
}

impl<A: 'static, B: 'static> OwningRef<A, B> {
    pub(crate) fn _map<C>(self, f: impl FnOnce(&B) -> &C) -> OwningRef<A, C> {
        let ptr = f(&*self);
        OwningRef {
            ptr,
            owner: self.owner,
        }
    }

    pub(crate) fn flat_map_slice<'x, C, T: FnOnce(&B) -> &[C]>(
        &self,
        f: T,
    ) -> impl Iterator<Item = OwningRef<A, C>> + '_
    where
        C: 'static,
    {
        f(&self).into_iter().map(|ptr| OwningRef {
            ptr,
            owner: self.owner.clone(),
        })
    }
}

'''
'''--- protobuf/src/plugin.rs ---
// This file is generated by rust-protobuf 4.0.0-alpha.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `google/protobuf/compiler/plugin.proto`

///  The version number of protocol compiler.
// @@protoc_insertion_point(message:google.protobuf.compiler.Version)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Version {
    // message fields
    // @@protoc_insertion_point(field:google.protobuf.compiler.Version.major)
    pub major: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:google.protobuf.compiler.Version.minor)
    pub minor: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:google.protobuf.compiler.Version.patch)
    pub patch: ::std::option::Option<i32>,
    ///  A suffix for alpha, beta or rc release, e.g., "alpha-1", "rc2". It should
    ///  be empty for mainline stable releases.
    // @@protoc_insertion_point(field:google.protobuf.compiler.Version.suffix)
    pub suffix: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.compiler.Version.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Version {
    fn default() -> &'a Version {
        <Version as crate::Message>::default_instance()
    }
}

impl Version {
    pub fn new() -> Version {
        ::std::default::Default::default()
    }

    // optional int32 major = 1;

    pub fn major(&self) -> i32 {
        self.major.unwrap_or(0)
    }

    pub fn clear_major(&mut self) {
        self.major = ::std::option::Option::None;
    }

    pub fn has_major(&self) -> bool {
        self.major.is_some()
    }

    // Param is passed by value, moved
    pub fn set_major(&mut self, v: i32) {
        self.major = ::std::option::Option::Some(v);
    }

    // optional int32 minor = 2;

    pub fn minor(&self) -> i32 {
        self.minor.unwrap_or(0)
    }

    pub fn clear_minor(&mut self) {
        self.minor = ::std::option::Option::None;
    }

    pub fn has_minor(&self) -> bool {
        self.minor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minor(&mut self, v: i32) {
        self.minor = ::std::option::Option::Some(v);
    }

    // optional int32 patch = 3;

    pub fn patch(&self) -> i32 {
        self.patch.unwrap_or(0)
    }

    pub fn clear_patch(&mut self) {
        self.patch = ::std::option::Option::None;
    }

    pub fn has_patch(&self) -> bool {
        self.patch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_patch(&mut self, v: i32) {
        self.patch = ::std::option::Option::Some(v);
    }

    // optional string suffix = 4;

    pub fn suffix(&self) -> &str {
        match self.suffix.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_suffix(&mut self) {
        self.suffix = ::std::option::Option::None;
    }

    pub fn has_suffix(&self) -> bool {
        self.suffix.is_some()
    }

    // Param is passed by value, moved
    pub fn set_suffix(&mut self, v: ::std::string::String) {
        self.suffix = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_suffix(&mut self) -> &mut ::std::string::String {
        if self.suffix.is_none() {
            self.suffix = ::std::option::Option::Some(::std::string::String::new());
        }
        self.suffix.as_mut().unwrap()
    }

    // Take field
    pub fn take_suffix(&mut self) -> ::std::string::String {
        self.suffix.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "major",
            |m: &Version| { &m.major },
            |m: &mut Version| { &mut m.major },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "minor",
            |m: &Version| { &m.minor },
            |m: &mut Version| { &mut m.minor },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "patch",
            |m: &Version| { &m.patch },
            |m: &mut Version| { &mut m.patch },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "suffix",
            |m: &Version| { &m.suffix },
            |m: &mut Version| { &mut m.suffix },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<Version>(
            "Version",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for Version {
    const NAME: &'static str = "Version";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.major = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.minor = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.patch = ::std::option::Option::Some(is.read_int32()?);
                },
                34 => {
                    self.suffix = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.major {
            my_size += crate::rt::int32_size(1, v);
        }
        if let Some(v) = self.minor {
            my_size += crate::rt::int32_size(2, v);
        }
        if let Some(v) = self.patch {
            my_size += crate::rt::int32_size(3, v);
        }
        if let Some(v) = self.suffix.as_ref() {
            my_size += crate::rt::string_size(4, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.major {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.minor {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.patch {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.suffix.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Version {
        Version::new()
    }

    fn clear(&mut self) {
        self.major = ::std::option::Option::None;
        self.minor = ::std::option::Option::None;
        self.patch = ::std::option::Option::None;
        self.suffix = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Version {
        static instance: Version = Version {
            major: ::std::option::Option::None,
            minor: ::std::option::Option::None,
            patch: ::std::option::Option::None,
            suffix: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for Version {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Version").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Version {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for Version {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

///  An encoded CodeGeneratorRequest is written to the plugin's stdin.
// @@protoc_insertion_point(message:google.protobuf.compiler.CodeGeneratorRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CodeGeneratorRequest {
    // message fields
    ///  The .proto files that were explicitly listed on the command-line.  The
    ///  code generator should generate code only for these files.  Each file's
    ///  descriptor will be included in proto_file, below.
    // @@protoc_insertion_point(field:google.protobuf.compiler.CodeGeneratorRequest.file_to_generate)
    pub file_to_generate: ::std::vec::Vec<::std::string::String>,
    ///  The generator parameter passed on the command-line.
    // @@protoc_insertion_point(field:google.protobuf.compiler.CodeGeneratorRequest.parameter)
    pub parameter: ::std::option::Option<::std::string::String>,
    ///  FileDescriptorProtos for all files in files_to_generate and everything
    ///  they import.  The files will appear in topological order, so each file
    ///  appears before any file that imports it.
    ///
    ///  protoc guarantees that all proto_files will be written after
    ///  the fields above, even though this is not technically guaranteed by the
    ///  protobuf wire format.  This theoretically could allow a plugin to stream
    ///  in the FileDescriptorProtos and handle them one by one rather than read
    ///  the entire set into memory at once.  However, as of this writing, this
    ///  is not similarly optimized on protoc's end -- it will store all fields in
    ///  memory at once before sending them to the plugin.
    ///
    ///  Type names of fields and extensions in the FileDescriptorProto are always
    ///  fully qualified.
    // @@protoc_insertion_point(field:google.protobuf.compiler.CodeGeneratorRequest.proto_file)
    pub proto_file: ::std::vec::Vec<crate::descriptor::FileDescriptorProto>,
    ///  The version number of protocol compiler.
    // @@protoc_insertion_point(field:google.protobuf.compiler.CodeGeneratorRequest.compiler_version)
    pub compiler_version: crate::MessageField<Version>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.compiler.CodeGeneratorRequest.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CodeGeneratorRequest {
    fn default() -> &'a CodeGeneratorRequest {
        <CodeGeneratorRequest as crate::Message>::default_instance()
    }
}

impl CodeGeneratorRequest {
    pub fn new() -> CodeGeneratorRequest {
        ::std::default::Default::default()
    }

    // optional string parameter = 2;

    pub fn parameter(&self) -> &str {
        match self.parameter.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_parameter(&mut self) {
        self.parameter = ::std::option::Option::None;
    }

    pub fn has_parameter(&self) -> bool {
        self.parameter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parameter(&mut self, v: ::std::string::String) {
        self.parameter = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parameter(&mut self) -> &mut ::std::string::String {
        if self.parameter.is_none() {
            self.parameter = ::std::option::Option::Some(::std::string::String::new());
        }
        self.parameter.as_mut().unwrap()
    }

    // Take field
    pub fn take_parameter(&mut self) -> ::std::string::String {
        self.parameter.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "file_to_generate",
            |m: &CodeGeneratorRequest| { &m.file_to_generate },
            |m: &mut CodeGeneratorRequest| { &mut m.file_to_generate },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "parameter",
            |m: &CodeGeneratorRequest| { &m.parameter },
            |m: &mut CodeGeneratorRequest| { &mut m.parameter },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "proto_file",
            |m: &CodeGeneratorRequest| { &m.proto_file },
            |m: &mut CodeGeneratorRequest| { &mut m.proto_file },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, Version>(
            "compiler_version",
            |m: &CodeGeneratorRequest| { &m.compiler_version },
            |m: &mut CodeGeneratorRequest| { &mut m.compiler_version },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CodeGeneratorRequest>(
            "CodeGeneratorRequest",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CodeGeneratorRequest {
    const NAME: &'static str = "CodeGeneratorRequest";

    fn is_initialized(&self) -> bool {
        for v in &self.proto_file {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.compiler_version {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.file_to_generate.push(is.read_string()?);
                },
                18 => {
                    self.parameter = ::std::option::Option::Some(is.read_string()?);
                },
                122 => {
                    self.proto_file.push(is.read_message()?);
                },
                26 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.compiler_version)?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.file_to_generate {
            my_size += crate::rt::string_size(1, &value);
        };
        if let Some(v) = self.parameter.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        for value in &self.proto_file {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.compiler_version.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.file_to_generate {
            os.write_string(1, &v)?;
        };
        if let Some(v) = self.parameter.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.proto_file {
            crate::rt::write_message_field_with_cached_size(15, v, os)?;
        };
        if let Some(v) = self.compiler_version.as_ref() {
            crate::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CodeGeneratorRequest {
        CodeGeneratorRequest::new()
    }

    fn clear(&mut self) {
        self.file_to_generate.clear();
        self.parameter = ::std::option::Option::None;
        self.proto_file.clear();
        self.compiler_version.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CodeGeneratorRequest {
        static instance: CodeGeneratorRequest = CodeGeneratorRequest {
            file_to_generate: ::std::vec::Vec::new(),
            parameter: ::std::option::Option::None,
            proto_file: ::std::vec::Vec::new(),
            compiler_version: crate::MessageField::none(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CodeGeneratorRequest {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CodeGeneratorRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CodeGeneratorRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CodeGeneratorRequest {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

///  The plugin writes an encoded CodeGeneratorResponse to stdout.
// @@protoc_insertion_point(message:google.protobuf.compiler.CodeGeneratorResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CodeGeneratorResponse {
    // message fields
    ///  Error message.  If non-empty, code generation failed.  The plugin process
    ///  should exit with status code zero even if it reports an error in this way.
    ///
    ///  This should be used to indicate errors in .proto files which prevent the
    ///  code generator from generating correct code.  Errors which indicate a
    ///  problem in protoc itself -- such as the input CodeGeneratorRequest being
    ///  unparseable -- should be reported by writing a message to stderr and
    ///  exiting with a non-zero status code.
    // @@protoc_insertion_point(field:google.protobuf.compiler.CodeGeneratorResponse.error)
    pub error: ::std::option::Option<::std::string::String>,
    ///  A bitmask of supported features that the code generator supports.
    ///  This is a bitwise "or" of values from the Feature enum.
    // @@protoc_insertion_point(field:google.protobuf.compiler.CodeGeneratorResponse.supported_features)
    pub supported_features: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:google.protobuf.compiler.CodeGeneratorResponse.file)
    pub file: ::std::vec::Vec<code_generator_response::File>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.compiler.CodeGeneratorResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CodeGeneratorResponse {
    fn default() -> &'a CodeGeneratorResponse {
        <CodeGeneratorResponse as crate::Message>::default_instance()
    }
}

impl CodeGeneratorResponse {
    pub fn new() -> CodeGeneratorResponse {
        ::std::default::Default::default()
    }

    // optional string error = 1;

    pub fn error(&self) -> &str {
        match self.error.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_error(&mut self) {
        self.error = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        if self.error.is_none() {
            self.error = ::std::option::Option::Some(::std::string::String::new());
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        self.error.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 supported_features = 2;

    pub fn supported_features(&self) -> u64 {
        self.supported_features.unwrap_or(0)
    }

    pub fn clear_supported_features(&mut self) {
        self.supported_features = ::std::option::Option::None;
    }

    pub fn has_supported_features(&self) -> bool {
        self.supported_features.is_some()
    }

    // Param is passed by value, moved
    pub fn set_supported_features(&mut self, v: u64) {
        self.supported_features = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "error",
            |m: &CodeGeneratorResponse| { &m.error },
            |m: &mut CodeGeneratorResponse| { &mut m.error },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "supported_features",
            |m: &CodeGeneratorResponse| { &m.supported_features },
            |m: &mut CodeGeneratorResponse| { &mut m.supported_features },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "file",
            |m: &CodeGeneratorResponse| { &m.file },
            |m: &mut CodeGeneratorResponse| { &mut m.file },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CodeGeneratorResponse>(
            "CodeGeneratorResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CodeGeneratorResponse {
    const NAME: &'static str = "CodeGeneratorResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.error = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.supported_features = ::std::option::Option::Some(is.read_uint64()?);
                },
                122 => {
                    self.file.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.error.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        if let Some(v) = self.supported_features {
            my_size += crate::rt::uint64_size(2, v);
        }
        for value in &self.file {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.error.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.supported_features {
            os.write_uint64(2, v)?;
        }
        for v in &self.file {
            crate::rt::write_message_field_with_cached_size(15, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CodeGeneratorResponse {
        CodeGeneratorResponse::new()
    }

    fn clear(&mut self) {
        self.error = ::std::option::Option::None;
        self.supported_features = ::std::option::Option::None;
        self.file.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CodeGeneratorResponse {
        static instance: CodeGeneratorResponse = CodeGeneratorResponse {
            error: ::std::option::Option::None,
            supported_features: ::std::option::Option::None,
            file: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CodeGeneratorResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CodeGeneratorResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CodeGeneratorResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CodeGeneratorResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CodeGeneratorResponse`
pub mod code_generator_response {
    ///  Represents a single generated file.
    // @@protoc_insertion_point(message:google.protobuf.compiler.CodeGeneratorResponse.File)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct File {
        // message fields
        ///  The file name, relative to the output directory.  The name must not
        ///  contain "." or ".." components and must be relative, not be absolute (so,
        ///  the file cannot lie outside the output directory).  "/" must be used as
        ///  the path separator, not "\".
        ///
        ///  If the name is omitted, the content will be appended to the previous
        ///  file.  This allows the generator to break large files into small chunks,
        ///  and allows the generated text to be streamed back to protoc so that large
        ///  files need not reside completely in memory at one time.  Note that as of
        ///  this writing protoc does not optimize for this -- it will read the entire
        ///  CodeGeneratorResponse before writing files to disk.
        // @@protoc_insertion_point(field:google.protobuf.compiler.CodeGeneratorResponse.File.name)
        pub name: ::std::option::Option<::std::string::String>,
        ///  If non-empty, indicates that the named file should already exist, and the
        ///  content here is to be inserted into that file at a defined insertion
        ///  point.  This feature allows a code generator to extend the output
        ///  produced by another code generator.  The original generator may provide
        ///  insertion points by placing special annotations in the file that look
        ///  like:
        ///    @@protoc_insertion_point(NAME)
        ///  The annotation can have arbitrary text before and after it on the line,
        ///  which allows it to be placed in a comment.  NAME should be replaced with
        ///  an identifier naming the point -- this is what other generators will use
        ///  as the insertion_point.  Code inserted at this point will be placed
        ///  immediately above the line containing the insertion point (thus multiple
        ///  insertions to the same point will come out in the order they were added).
        ///  The double-@ is intended to make it unlikely that the generated code
        ///  could contain things that look like insertion points by accident.
        ///
        ///  For example, the C++ code generator places the following line in the
        ///  .pb.h files that it generates:
        ///    // @@protoc_insertion_point(namespace_scope)
        ///  This line appears within the scope of the file's package namespace, but
        ///  outside of any particular class.  Another plugin can then specify the
        ///  insertion_point "namespace_scope" to generate additional classes or
        ///  other declarations that should be placed in this scope.
        ///
        ///  Note that if the line containing the insertion point begins with
        ///  whitespace, the same whitespace will be added to every line of the
        ///  inserted text.  This is useful for languages like Python, where
        ///  indentation matters.  In these languages, the insertion point comment
        ///  should be indented the same amount as any inserted code will need to be
        ///  in order to work correctly in that context.
        ///
        ///  The code generator that generates the initial file and the one which
        ///  inserts into it must both run as part of a single invocation of protoc.
        ///  Code generators are executed in the order in which they appear on the
        ///  command line.
        ///
        ///  If |insertion_point| is present, |name| must also be present.
        // @@protoc_insertion_point(field:google.protobuf.compiler.CodeGeneratorResponse.File.insertion_point)
        pub insertion_point: ::std::option::Option<::std::string::String>,
        ///  The file contents.
        // @@protoc_insertion_point(field:google.protobuf.compiler.CodeGeneratorResponse.File.content)
        pub content: ::std::option::Option<::std::string::String>,
        ///  Information describing the file content being inserted. If an insertion
        ///  point is used, this information will be appropriately offset and inserted
        ///  into the code generation metadata for the generated files.
        // @@protoc_insertion_point(field:google.protobuf.compiler.CodeGeneratorResponse.File.generated_code_info)
        pub generated_code_info: crate::MessageField<crate::descriptor::GeneratedCodeInfo>,
        // special fields
        // @@protoc_insertion_point(special_field:google.protobuf.compiler.CodeGeneratorResponse.File.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a File {
        fn default() -> &'a File {
            <File as crate::Message>::default_instance()
        }
    }

    impl File {
        pub fn new() -> File {
            ::std::default::Default::default()
        }

        // optional string name = 1;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string insertion_point = 2;

        pub fn insertion_point(&self) -> &str {
            match self.insertion_point.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_insertion_point(&mut self) {
            self.insertion_point = ::std::option::Option::None;
        }

        pub fn has_insertion_point(&self) -> bool {
            self.insertion_point.is_some()
        }

        // Param is passed by value, moved
        pub fn set_insertion_point(&mut self, v: ::std::string::String) {
            self.insertion_point = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_insertion_point(&mut self) -> &mut ::std::string::String {
            if self.insertion_point.is_none() {
                self.insertion_point = ::std::option::Option::Some(::std::string::String::new());
            }
            self.insertion_point.as_mut().unwrap()
        }

        // Take field
        pub fn take_insertion_point(&mut self) -> ::std::string::String {
            self.insertion_point.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string content = 15;

        pub fn content(&self) -> &str {
            match self.content.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_content(&mut self) {
            self.content = ::std::option::Option::None;
        }

        pub fn has_content(&self) -> bool {
            self.content.is_some()
        }

        // Param is passed by value, moved
        pub fn set_content(&mut self, v: ::std::string::String) {
            self.content = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_content(&mut self) -> &mut ::std::string::String {
            if self.content.is_none() {
                self.content = ::std::option::Option::Some(::std::string::String::new());
            }
            self.content.as_mut().unwrap()
        }

        // Take field
        pub fn take_content(&mut self) -> ::std::string::String {
            self.content.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "name",
                |m: &File| { &m.name },
                |m: &mut File| { &mut m.name },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "insertion_point",
                |m: &File| { &m.insertion_point },
                |m: &mut File| { &mut m.insertion_point },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "content",
                |m: &File| { &m.content },
                |m: &mut File| { &mut m.content },
            ));
            fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, crate::descriptor::GeneratedCodeInfo>(
                "generated_code_info",
                |m: &File| { &m.generated_code_info },
                |m: &mut File| { &mut m.generated_code_info },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<File>(
                "CodeGeneratorResponse.File",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for File {
        const NAME: &'static str = "File";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.insertion_point = ::std::option::Option::Some(is.read_string()?);
                    },
                    122 => {
                        self.content = ::std::option::Option::Some(is.read_string()?);
                    },
                    130 => {
                        crate::rt::read_singular_message_into_field(is, &mut self.generated_code_info)?;
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.name.as_ref() {
                my_size += crate::rt::string_size(1, &v);
            }
            if let Some(v) = self.insertion_point.as_ref() {
                my_size += crate::rt::string_size(2, &v);
            }
            if let Some(v) = self.content.as_ref() {
                my_size += crate::rt::string_size(15, &v);
            }
            if let Some(v) = self.generated_code_info.as_ref() {
                let len = v.compute_size();
                my_size += 2 + crate::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.insertion_point.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.content.as_ref() {
                os.write_string(15, v)?;
            }
            if let Some(v) = self.generated_code_info.as_ref() {
                crate::rt::write_message_field_with_cached_size(16, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> File {
            File::new()
        }

        fn clear(&mut self) {
            self.name = ::std::option::Option::None;
            self.insertion_point = ::std::option::Option::None;
            self.content = ::std::option::Option::None;
            self.generated_code_info.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static File {
            static instance: File = File {
                name: ::std::option::Option::None,
                insertion_point: ::std::option::Option::None,
                content: ::std::option::Option::None,
                generated_code_info: crate::MessageField::none(),
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for File {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CodeGeneratorResponse.File").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for File {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for File {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }

    ///  Sync with code_generator.h.
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:google.protobuf.compiler.CodeGeneratorResponse.Feature)
    pub enum Feature {
        // @@protoc_insertion_point(enum_value:google.protobuf.compiler.CodeGeneratorResponse.Feature.FEATURE_NONE)
        FEATURE_NONE = 0,
        // @@protoc_insertion_point(enum_value:google.protobuf.compiler.CodeGeneratorResponse.Feature.FEATURE_PROTO3_OPTIONAL)
        FEATURE_PROTO3_OPTIONAL = 1,
    }

    impl crate::Enum for Feature {
        const NAME: &'static str = "Feature";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Feature> {
            match value {
                0 => ::std::option::Option::Some(Feature::FEATURE_NONE),
                1 => ::std::option::Option::Some(Feature::FEATURE_PROTO3_OPTIONAL),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Feature> {
            match str {
                "FEATURE_NONE" => ::std::option::Option::Some(Feature::FEATURE_NONE),
                "FEATURE_PROTO3_OPTIONAL" => ::std::option::Option::Some(Feature::FEATURE_PROTO3_OPTIONAL),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Feature] = &[
            Feature::FEATURE_NONE,
            Feature::FEATURE_PROTO3_OPTIONAL,
        ];
    }

    impl crate::EnumFull for Feature {
        fn enum_descriptor() -> crate::reflect::EnumDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CodeGeneratorResponse.Feature").unwrap()).clone()
        }

        fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Feature {
        fn default() -> Self {
            Feature::FEATURE_NONE
        }
    }

    impl Feature {
        pub(in super) fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
            crate::reflect::GeneratedEnumDescriptorData::new::<Feature>("CodeGeneratorResponse.Feature")
        }
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n%google/protobuf/compiler/plugin.proto\x12\x18google.protobuf.compiler\
    \x1a\x20google/protobuf/descriptor.proto\"c\n\x07Version\x12\x14\n\x05ma\
    jor\x18\x01\x20\x01(\x05R\x05major\x12\x14\n\x05minor\x18\x02\x20\x01(\
    \x05R\x05minor\x12\x14\n\x05patch\x18\x03\x20\x01(\x05R\x05patch\x12\x16\
    \n\x06suffix\x18\x04\x20\x01(\tR\x06suffix\"\xf1\x01\n\x14CodeGeneratorR\
    equest\x12(\n\x10file_to_generate\x18\x01\x20\x03(\tR\x0efileToGenerate\
    \x12\x1c\n\tparameter\x18\x02\x20\x01(\tR\tparameter\x12C\n\nproto_file\
    \x18\x0f\x20\x03(\x0b2$.google.protobuf.FileDescriptorProtoR\tprotoFile\
    \x12L\n\x10compiler_version\x18\x03\x20\x01(\x0b2!.google.protobuf.compi\
    ler.VersionR\x0fcompilerVersion\"\x94\x03\n\x15CodeGeneratorResponse\x12\
    \x14\n\x05error\x18\x01\x20\x01(\tR\x05error\x12-\n\x12supported_feature\
    s\x18\x02\x20\x01(\x04R\x11supportedFeatures\x12H\n\x04file\x18\x0f\x20\
    \x03(\x0b24.google.protobuf.compiler.CodeGeneratorResponse.FileR\x04file\
    \x1a\xb1\x01\n\x04File\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\
    '\n\x0finsertion_point\x18\x02\x20\x01(\tR\x0einsertionPoint\x12\x18\n\
    \x07content\x18\x0f\x20\x01(\tR\x07content\x12R\n\x13generated_code_info\
    \x18\x10\x20\x01(\x0b2\".google.protobuf.GeneratedCodeInfoR\x11generated\
    CodeInfo\"8\n\x07Feature\x12\x10\n\x0cFEATURE_NONE\x10\0\x12\x1b\n\x17FE\
    ATURE_PROTO3_OPTIONAL\x10\x01BW\n\x1ccom.google.protobuf.compilerB\x0cPl\
    uginProtosZ)google.golang.org/protobuf/types/pluginpbJ\xf9C\n\x07\x12\
    \x05.\0\xb6\x01\x01\n\xca\x11\n\x01\x0c\x12\x03.\0\x122\xc1\x0c\x20Proto\
    col\x20Buffers\x20-\x20Google's\x20data\x20interchange\x20format\n\x20Co\
    pyright\x202008\x20Google\x20Inc.\x20\x20All\x20rights\x20reserved.\n\
    \x20https://developers.google.com/protocol-buffers/\n\n\x20Redistributio\
    n\x20and\x20use\x20in\x20source\x20and\x20binary\x20forms,\x20with\x20or\
    \x20without\n\x20modification,\x20are\x20permitted\x20provided\x20that\
    \x20the\x20following\x20conditions\x20are\n\x20met:\n\n\x20\x20\x20\x20\
    \x20*\x20Redistributions\x20of\x20source\x20code\x20must\x20retain\x20th\
    e\x20above\x20copyright\n\x20notice,\x20this\x20list\x20of\x20conditions\
    \x20and\x20the\x20following\x20disclaimer.\n\x20\x20\x20\x20\x20*\x20Red\
    istributions\x20in\x20binary\x20form\x20must\x20reproduce\x20the\x20abov\
    e\n\x20copyright\x20notice,\x20this\x20list\x20of\x20conditions\x20and\
    \x20the\x20following\x20disclaimer\n\x20in\x20the\x20documentation\x20an\
    d/or\x20other\x20materials\x20provided\x20with\x20the\n\x20distribution.\
    \n\x20\x20\x20\x20\x20*\x20Neither\x20the\x20name\x20of\x20Google\x20Inc\
    .\x20nor\x20the\x20names\x20of\x20its\n\x20contributors\x20may\x20be\x20\
    used\x20to\x20endorse\x20or\x20promote\x20products\x20derived\x20from\n\
    \x20this\x20software\x20without\x20specific\x20prior\x20written\x20permi\
    ssion.\n\n\x20THIS\x20SOFTWARE\x20IS\x20PROVIDED\x20BY\x20THE\x20COPYRIG\
    HT\x20HOLDERS\x20AND\x20CONTRIBUTORS\n\x20\"AS\x20IS\"\x20AND\x20ANY\x20\
    EXPRESS\x20OR\x20IMPLIED\x20WARRANTIES,\x20INCLUDING,\x20BUT\x20NOT\n\
    \x20LIMITED\x20TO,\x20THE\x20IMPLIED\x20WARRANTIES\x20OF\x20MERCHANTABIL\
    ITY\x20AND\x20FITNESS\x20FOR\n\x20A\x20PARTICULAR\x20PURPOSE\x20ARE\x20D\
    ISCLAIMED.\x20IN\x20NO\x20EVENT\x20SHALL\x20THE\x20COPYRIGHT\n\x20OWNER\
    \x20OR\x20CONTRIBUTORS\x20BE\x20LIABLE\x20FOR\x20ANY\x20DIRECT,\x20INDIR\
    ECT,\x20INCIDENTAL,\n\x20SPECIAL,\x20EXEMPLARY,\x20OR\x20CONSEQUENTIAL\
    \x20DAMAGES\x20(INCLUDING,\x20BUT\x20NOT\n\x20LIMITED\x20TO,\x20PROCUREM\
    ENT\x20OF\x20SUBSTITUTE\x20GOODS\x20OR\x20SERVICES;\x20LOSS\x20OF\x20USE\
    ,\n\x20DATA,\x20OR\x20PROFITS;\x20OR\x20BUSINESS\x20INTERRUPTION)\x20HOW\
    EVER\x20CAUSED\x20AND\x20ON\x20ANY\n\x20THEORY\x20OF\x20LIABILITY,\x20WH\
    ETHER\x20IN\x20CONTRACT,\x20STRICT\x20LIABILITY,\x20OR\x20TORT\n\x20(INC\
    LUDING\x20NEGLIGENCE\x20OR\x20OTHERWISE)\x20ARISING\x20IN\x20ANY\x20WAY\
    \x20OUT\x20OF\x20THE\x20USE\n\x20OF\x20THIS\x20SOFTWARE,\x20EVEN\x20IF\
    \x20ADVISED\x20OF\x20THE\x20POSSIBILITY\x20OF\x20SUCH\x20DAMAGE.\n2\xfb\
    \x04\x20Author:\x20kenton@google.com\x20(Kenton\x20Varda)\n\n\x20WARNING\
    :\x20\x20The\x20plugin\x20interface\x20is\x20currently\x20EXPERIMENTAL\
    \x20and\x20is\x20subject\x20to\n\x20\x20\x20change.\n\n\x20protoc\x20(ak\
    a\x20the\x20Protocol\x20Compiler)\x20can\x20be\x20extended\x20via\x20plu\
    gins.\x20\x20A\x20plugin\x20is\n\x20just\x20a\x20program\x20that\x20read\
    s\x20a\x20CodeGeneratorRequest\x20from\x20stdin\x20and\x20writes\x20a\n\
    \x20CodeGeneratorResponse\x20to\x20stdout.\n\n\x20Plugins\x20written\x20\
    using\x20C++\x20can\x20use\x20google/protobuf/compiler/plugin.h\x20inste\
    ad\n\x20of\x20dealing\x20with\x20the\x20raw\x20protocol\x20defined\x20he\
    re.\n\n\x20A\x20plugin\x20executable\x20needs\x20only\x20to\x20be\x20pla\
    ced\x20somewhere\x20in\x20the\x20path.\x20\x20The\n\x20plugin\x20should\
    \x20be\x20named\x20\"protoc-gen-$NAME\",\x20and\x20will\x20then\x20be\
    \x20used\x20when\x20the\n\x20flag\x20\"--${NAME}_out\"\x20is\x20passed\
    \x20to\x20protoc.\n\n\x08\n\x01\x02\x12\x030\0!\n\x08\n\x01\x08\x12\x031\
    \05\n\t\n\x02\x08\x01\x12\x031\05\n\x08\n\x01\x08\x12\x032\0-\n\t\n\x02\
    \x08\x08\x12\x032\0-\n\x08\n\x01\x08\x12\x034\0@\n\t\n\x02\x08\x0b\x12\
    \x034\0@\n\t\n\x02\x03\0\x12\x036\0*\n6\n\x02\x04\0\x12\x049\0@\x01\x1a*\
    \x20The\x20version\x20number\x20of\x20protocol\x20compiler.\n\n\n\n\x03\
    \x04\0\x01\x12\x039\x08\x0f\n\x0b\n\x04\x04\0\x02\0\x12\x03:\x02\x1b\n\
    \x0c\n\x05\x04\0\x02\0\x04\x12\x03:\x02\n\n\x0c\n\x05\x04\0\x02\0\x05\
    \x12\x03:\x0b\x10\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03:\x11\x16\n\x0c\n\
    \x05\x04\0\x02\0\x03\x12\x03:\x19\x1a\n\x0b\n\x04\x04\0\x02\x01\x12\x03;\
    \x02\x1b\n\x0c\n\x05\x04\0\x02\x01\x04\x12\x03;\x02\n\n\x0c\n\x05\x04\0\
    \x02\x01\x05\x12\x03;\x0b\x10\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03;\x11\
    \x16\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03;\x19\x1a\n\x0b\n\x04\x04\0\
    \x02\x02\x12\x03<\x02\x1b\n\x0c\n\x05\x04\0\x02\x02\x04\x12\x03<\x02\n\n\
    \x0c\n\x05\x04\0\x02\x02\x05\x12\x03<\x0b\x10\n\x0c\n\x05\x04\0\x02\x02\
    \x01\x12\x03<\x11\x16\n\x0c\n\x05\x04\0\x02\x02\x03\x12\x03<\x19\x1a\n\
    \x80\x01\n\x04\x04\0\x02\x03\x12\x03?\x02\x1d\x1as\x20A\x20suffix\x20for\
    \x20alpha,\x20beta\x20or\x20rc\x20release,\x20e.g.,\x20\"alpha-1\",\x20\
    \"rc2\".\x20It\x20should\n\x20be\x20empty\x20for\x20mainline\x20stable\
    \x20releases.\n\n\x0c\n\x05\x04\0\x02\x03\x04\x12\x03?\x02\n\n\x0c\n\x05\
    \x04\0\x02\x03\x05\x12\x03?\x0b\x11\n\x0c\n\x05\x04\0\x02\x03\x01\x12\
    \x03?\x12\x18\n\x0c\n\x05\x04\0\x02\x03\x03\x12\x03?\x1b\x1c\nO\n\x02\
    \x04\x01\x12\x04C\0_\x01\x1aC\x20An\x20encoded\x20CodeGeneratorRequest\
    \x20is\x20written\x20to\x20the\x20plugin's\x20stdin.\n\n\n\n\x03\x04\x01\
    \x01\x12\x03C\x08\x1c\n\xd1\x01\n\x04\x04\x01\x02\0\x12\x03G\x02'\x1a\
    \xc3\x01\x20The\x20.proto\x20files\x20that\x20were\x20explicitly\x20list\
    ed\x20on\x20the\x20command-line.\x20\x20The\n\x20code\x20generator\x20sh\
    ould\x20generate\x20code\x20only\x20for\x20these\x20files.\x20\x20Each\
    \x20file's\n\x20descriptor\x20will\x20be\x20included\x20in\x20proto_file\
    ,\x20below.\n\n\x0c\n\x05\x04\x01\x02\0\x04\x12\x03G\x02\n\n\x0c\n\x05\
    \x04\x01\x02\0\x05\x12\x03G\x0b\x11\n\x0c\n\x05\x04\x01\x02\0\x01\x12\
    \x03G\x12\"\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03G%&\nB\n\x04\x04\x01\
    \x02\x01\x12\x03J\x02\x20\x1a5\x20The\x20generator\x20parameter\x20passe\
    d\x20on\x20the\x20command-line.\n\n\x0c\n\x05\x04\x01\x02\x01\x04\x12\
    \x03J\x02\n\n\x0c\n\x05\x04\x01\x02\x01\x05\x12\x03J\x0b\x11\n\x0c\n\x05\
    \x04\x01\x02\x01\x01\x12\x03J\x12\x1b\n\x0c\n\x05\x04\x01\x02\x01\x03\
    \x12\x03J\x1e\x1f\n\x87\x06\n\x04\x04\x01\x02\x02\x12\x03Z\x02/\x1a\xf9\
    \x05\x20FileDescriptorProtos\x20for\x20all\x20files\x20in\x20files_to_ge\
    nerate\x20and\x20everything\n\x20they\x20import.\x20\x20The\x20files\x20\
    will\x20appear\x20in\x20topological\x20order,\x20so\x20each\x20file\n\
    \x20appears\x20before\x20any\x20file\x20that\x20imports\x20it.\n\n\x20pr\
    otoc\x20guarantees\x20that\x20all\x20proto_files\x20will\x20be\x20writte\
    n\x20after\n\x20the\x20fields\x20above,\x20even\x20though\x20this\x20is\
    \x20not\x20technically\x20guaranteed\x20by\x20the\n\x20protobuf\x20wire\
    \x20format.\x20\x20This\x20theoretically\x20could\x20allow\x20a\x20plugi\
    n\x20to\x20stream\n\x20in\x20the\x20FileDescriptorProtos\x20and\x20handl\
    e\x20them\x20one\x20by\x20one\x20rather\x20than\x20read\n\x20the\x20enti\
    re\x20set\x20into\x20memory\x20at\x20once.\x20\x20However,\x20as\x20of\
    \x20this\x20writing,\x20this\n\x20is\x20not\x20similarly\x20optimized\
    \x20on\x20protoc's\x20end\x20--\x20it\x20will\x20store\x20all\x20fields\
    \x20in\n\x20memory\x20at\x20once\x20before\x20sending\x20them\x20to\x20t\
    he\x20plugin.\n\n\x20Type\x20names\x20of\x20fields\x20and\x20extensions\
    \x20in\x20the\x20FileDescriptorProto\x20are\x20always\n\x20fully\x20qual\
    ified.\n\n\x0c\n\x05\x04\x01\x02\x02\x04\x12\x03Z\x02\n\n\x0c\n\x05\x04\
    \x01\x02\x02\x06\x12\x03Z\x0b\x1e\n\x0c\n\x05\x04\x01\x02\x02\x01\x12\
    \x03Z\x1f)\n\x0c\n\x05\x04\x01\x02\x02\x03\x12\x03Z,.\n7\n\x04\x04\x01\
    \x02\x03\x12\x03]\x02(\x1a*\x20The\x20version\x20number\x20of\x20protoco\
    l\x20compiler.\n\n\x0c\n\x05\x04\x01\x02\x03\x04\x12\x03]\x02\n\n\x0c\n\
    \x05\x04\x01\x02\x03\x06\x12\x03]\x0b\x12\n\x0c\n\x05\x04\x01\x02\x03\
    \x01\x12\x03]\x13#\n\x0c\n\x05\x04\x01\x02\x03\x03\x12\x03]&'\nL\n\x02\
    \x04\x02\x12\x05b\0\xb6\x01\x01\x1a?\x20The\x20plugin\x20writes\x20an\
    \x20encoded\x20CodeGeneratorResponse\x20to\x20stdout.\n\n\n\n\x03\x04\
    \x02\x01\x12\x03b\x08\x1d\n\xed\x03\n\x04\x04\x02\x02\0\x12\x03k\x02\x1c\
    \x1a\xdf\x03\x20Error\x20message.\x20\x20If\x20non-empty,\x20code\x20gen\
    eration\x20failed.\x20\x20The\x20plugin\x20process\n\x20should\x20exit\
    \x20with\x20status\x20code\x20zero\x20even\x20if\x20it\x20reports\x20an\
    \x20error\x20in\x20this\x20way.\n\n\x20This\x20should\x20be\x20used\x20t\
    o\x20indicate\x20errors\x20in\x20.proto\x20files\x20which\x20prevent\x20\
    the\n\x20code\x20generator\x20from\x20generating\x20correct\x20code.\x20\
    \x20Errors\x20which\x20indicate\x20a\n\x20problem\x20in\x20protoc\x20its\
    elf\x20--\x20such\x20as\x20the\x20input\x20CodeGeneratorRequest\x20being\
    \n\x20unparseable\x20--\x20should\x20be\x20reported\x20by\x20writing\x20\
    a\x20message\x20to\x20stderr\x20and\n\x20exiting\x20with\x20a\x20non-zer\
    o\x20status\x20code.\n\n\x0c\n\x05\x04\x02\x02\0\x04\x12\x03k\x02\n\n\
    \x0c\n\x05\x04\x02\x02\0\x05\x12\x03k\x0b\x11\n\x0c\n\x05\x04\x02\x02\0\
    \x01\x12\x03k\x12\x17\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03k\x1a\x1b\n\
    \x89\x01\n\x04\x04\x02\x02\x01\x12\x03o\x02)\x1a|\x20A\x20bitmask\x20of\
    \x20supported\x20features\x20that\x20the\x20code\x20generator\x20support\
    s.\n\x20This\x20is\x20a\x20bitwise\x20\"or\"\x20of\x20values\x20from\x20\
    the\x20Feature\x20enum.\n\n\x0c\n\x05\x04\x02\x02\x01\x04\x12\x03o\x02\n\
    \n\x0c\n\x05\x04\x02\x02\x01\x05\x12\x03o\x0b\x11\n\x0c\n\x05\x04\x02\
    \x02\x01\x01\x12\x03o\x12$\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x03o'(\n+\
    \n\x04\x04\x02\x04\0\x12\x04r\x02u\x03\x1a\x1d\x20Sync\x20with\x20code_g\
    enerator.h.\n\n\x0c\n\x05\x04\x02\x04\0\x01\x12\x03r\x07\x0e\n\r\n\x06\
    \x04\x02\x04\0\x02\0\x12\x03s\x04\x15\n\x0e\n\x07\x04\x02\x04\0\x02\0\
    \x01\x12\x03s\x04\x10\n\x0e\n\x07\x04\x02\x04\0\x02\0\x02\x12\x03s\x13\
    \x14\n\r\n\x06\x04\x02\x04\0\x02\x01\x12\x03t\x04\x20\n\x0e\n\x07\x04\
    \x02\x04\0\x02\x01\x01\x12\x03t\x04\x1b\n\x0e\n\x07\x04\x02\x04\0\x02\
    \x01\x02\x12\x03t\x1e\x1f\n4\n\x04\x04\x02\x03\0\x12\x05x\x02\xb4\x01\
    \x03\x1a%\x20Represents\x20a\x20single\x20generated\x20file.\n\n\x0c\n\
    \x05\x04\x02\x03\0\x01\x12\x03x\n\x0e\n\xae\x05\n\x06\x04\x02\x03\0\x02\
    \0\x12\x04\x84\x01\x04\x1d\x1a\x9d\x05\x20The\x20file\x20name,\x20relati\
    ve\x20to\x20the\x20output\x20directory.\x20\x20The\x20name\x20must\x20no\
    t\n\x20contain\x20\".\"\x20or\x20\"..\"\x20components\x20and\x20must\x20\
    be\x20relative,\x20not\x20be\x20absolute\x20(so,\n\x20the\x20file\x20can\
    not\x20lie\x20outside\x20the\x20output\x20directory).\x20\x20\"/\"\x20mu\
    st\x20be\x20used\x20as\n\x20the\x20path\x20separator,\x20not\x20\"\\\".\
    \n\n\x20If\x20the\x20name\x20is\x20omitted,\x20the\x20content\x20will\
    \x20be\x20appended\x20to\x20the\x20previous\n\x20file.\x20\x20This\x20al\
    lows\x20the\x20generator\x20to\x20break\x20large\x20files\x20into\x20sma\
    ll\x20chunks,\n\x20and\x20allows\x20the\x20generated\x20text\x20to\x20be\
    \x20streamed\x20back\x20to\x20protoc\x20so\x20that\x20large\n\x20files\
    \x20need\x20not\x20reside\x20completely\x20in\x20memory\x20at\x20one\x20\
    time.\x20\x20Note\x20that\x20as\x20of\n\x20this\x20writing\x20protoc\x20\
    does\x20not\x20optimize\x20for\x20this\x20--\x20it\x20will\x20read\x20th\
    e\x20entire\n\x20CodeGeneratorResponse\x20before\x20writing\x20files\x20\
    to\x20disk.\n\n\x0f\n\x07\x04\x02\x03\0\x02\0\x04\x12\x04\x84\x01\x04\
    \x0c\n\x0f\n\x07\x04\x02\x03\0\x02\0\x05\x12\x04\x84\x01\r\x13\n\x0f\n\
    \x07\x04\x02\x03\0\x02\0\x01\x12\x04\x84\x01\x14\x18\n\x0f\n\x07\x04\x02\
    \x03\0\x02\0\x03\x12\x04\x84\x01\x1b\x1c\n\xae\x10\n\x06\x04\x02\x03\0\
    \x02\x01\x12\x04\xab\x01\x04(\x1a\x9d\x10\x20If\x20non-empty,\x20indicat\
    es\x20that\x20the\x20named\x20file\x20should\x20already\x20exist,\x20and\
    \x20the\n\x20content\x20here\x20is\x20to\x20be\x20inserted\x20into\x20th\
    at\x20file\x20at\x20a\x20defined\x20insertion\n\x20point.\x20\x20This\
    \x20feature\x20allows\x20a\x20code\x20generator\x20to\x20extend\x20the\
    \x20output\n\x20produced\x20by\x20another\x20code\x20generator.\x20\x20T\
    he\x20original\x20generator\x20may\x20provide\n\x20insertion\x20points\
    \x20by\x20placing\x20special\x20annotations\x20in\x20the\x20file\x20that\
    \x20look\n\x20like:\n\x20\x20\x20@@protoc_insertion_point(NAME)\n\x20The\
    \x20annotation\x20can\x20have\x20arbitrary\x20text\x20before\x20and\x20a\
    fter\x20it\x20on\x20the\x20line,\n\x20which\x20allows\x20it\x20to\x20be\
    \x20placed\x20in\x20a\x20comment.\x20\x20NAME\x20should\x20be\x20replace\
    d\x20with\n\x20an\x20identifier\x20naming\x20the\x20point\x20--\x20this\
    \x20is\x20what\x20other\x20generators\x20will\x20use\n\x20as\x20the\x20i\
    nsertion_point.\x20\x20Code\x20inserted\x20at\x20this\x20point\x20will\
    \x20be\x20placed\n\x20immediately\x20above\x20the\x20line\x20containing\
    \x20the\x20insertion\x20point\x20(thus\x20multiple\n\x20insertions\x20to\
    \x20the\x20same\x20point\x20will\x20come\x20out\x20in\x20the\x20order\
    \x20they\x20were\x20added).\n\x20The\x20double-@\x20is\x20intended\x20to\
    \x20make\x20it\x20unlikely\x20that\x20the\x20generated\x20code\n\x20coul\
    d\x20contain\x20things\x20that\x20look\x20like\x20insertion\x20points\
    \x20by\x20accident.\n\n\x20For\x20example,\x20the\x20C++\x20code\x20gene\
    rator\x20places\x20the\x20following\x20line\x20in\x20the\n\x20.pb.h\x20f\
    iles\x20that\x20it\x20generates:\n\x20\x20\x20//\x20@@protoc_insertion_p\
    oint(namespace_scope)\n\x20This\x20line\x20appears\x20within\x20the\x20s\
    cope\x20of\x20the\x20file's\x20package\x20namespace,\x20but\n\x20outside\
    \x20of\x20any\x20particular\x20class.\x20\x20Another\x20plugin\x20can\
    \x20then\x20specify\x20the\n\x20insertion_point\x20\"namespace_scope\"\
    \x20to\x20generate\x20additional\x20classes\x20or\n\x20other\x20declarat\
    ions\x20that\x20should\x20be\x20placed\x20in\x20this\x20scope.\n\n\x20No\
    te\x20that\x20if\x20the\x20line\x20containing\x20the\x20insertion\x20poi\
    nt\x20begins\x20with\n\x20whitespace,\x20the\x20same\x20whitespace\x20wi\
    ll\x20be\x20added\x20to\x20every\x20line\x20of\x20the\n\x20inserted\x20t\
    ext.\x20\x20This\x20is\x20useful\x20for\x20languages\x20like\x20Python,\
    \x20where\n\x20indentation\x20matters.\x20\x20In\x20these\x20languages,\
    \x20the\x20insertion\x20point\x20comment\n\x20should\x20be\x20indented\
    \x20the\x20same\x20amount\x20as\x20any\x20inserted\x20code\x20will\x20ne\
    ed\x20to\x20be\n\x20in\x20order\x20to\x20work\x20correctly\x20in\x20that\
    \x20context.\n\n\x20The\x20code\x20generator\x20that\x20generates\x20the\
    \x20initial\x20file\x20and\x20the\x20one\x20which\n\x20inserts\x20into\
    \x20it\x20must\x20both\x20run\x20as\x20part\x20of\x20a\x20single\x20invo\
    cation\x20of\x20protoc.\n\x20Code\x20generators\x20are\x20executed\x20in\
    \x20the\x20order\x20in\x20which\x20they\x20appear\x20on\x20the\n\x20comm\
    and\x20line.\n\n\x20If\x20|insertion_point|\x20is\x20present,\x20|name|\
    \x20must\x20also\x20be\x20present.\n\n\x0f\n\x07\x04\x02\x03\0\x02\x01\
    \x04\x12\x04\xab\x01\x04\x0c\n\x0f\n\x07\x04\x02\x03\0\x02\x01\x05\x12\
    \x04\xab\x01\r\x13\n\x0f\n\x07\x04\x02\x03\0\x02\x01\x01\x12\x04\xab\x01\
    \x14#\n\x0f\n\x07\x04\x02\x03\0\x02\x01\x03\x12\x04\xab\x01&'\n$\n\x06\
    \x04\x02\x03\0\x02\x02\x12\x04\xae\x01\x04!\x1a\x14\x20The\x20file\x20co\
    ntents.\n\n\x0f\n\x07\x04\x02\x03\0\x02\x02\x04\x12\x04\xae\x01\x04\x0c\
    \n\x0f\n\x07\x04\x02\x03\0\x02\x02\x05\x12\x04\xae\x01\r\x13\n\x0f\n\x07\
    \x04\x02\x03\0\x02\x02\x01\x12\x04\xae\x01\x14\x1b\n\x0f\n\x07\x04\x02\
    \x03\0\x02\x02\x03\x12\x04\xae\x01\x1e\x20\n\xe1\x01\n\x06\x04\x02\x03\0\
    \x02\x03\x12\x04\xb3\x01\x048\x1a\xd0\x01\x20Information\x20describing\
    \x20the\x20file\x20content\x20being\x20inserted.\x20If\x20an\x20insertio\
    n\n\x20point\x20is\x20used,\x20this\x20information\x20will\x20be\x20appr\
    opriately\x20offset\x20and\x20inserted\n\x20into\x20the\x20code\x20gener\
    ation\x20metadata\x20for\x20the\x20generated\x20files.\n\n\x0f\n\x07\x04\
    \x02\x03\0\x02\x03\x04\x12\x04\xb3\x01\x04\x0c\n\x0f\n\x07\x04\x02\x03\0\
    \x02\x03\x06\x12\x04\xb3\x01\r\x1e\n\x0f\n\x07\x04\x02\x03\0\x02\x03\x01\
    \x12\x04\xb3\x01\x1f2\n\x0f\n\x07\x04\x02\x03\0\x02\x03\x03\x12\x04\xb3\
    \x0157\n\x0c\n\x04\x04\x02\x02\x02\x12\x04\xb5\x01\x02\x1a\n\r\n\x05\x04\
    \x02\x02\x02\x04\x12\x04\xb5\x01\x02\n\n\r\n\x05\x04\x02\x02\x02\x06\x12\
    \x04\xb5\x01\x0b\x0f\n\r\n\x05\x04\x02\x02\x02\x01\x12\x04\xb5\x01\x10\
    \x14\n\r\n\x05\x04\x02\x02\x02\x03\x12\x04\xb5\x01\x17\x19\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static crate::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: crate::rt::Lazy<crate::descriptor::FileDescriptorProto> = crate::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        crate::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static crate::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: crate::rt::Lazy<crate::reflect::GeneratedFileDescriptor> = crate::rt::Lazy::new();
    static file_descriptor: crate::rt::Lazy<crate::reflect::FileDescriptor> = crate::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(crate::descriptor::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(4);
            messages.push(Version::generated_message_descriptor_data());
            messages.push(CodeGeneratorRequest::generated_message_descriptor_data());
            messages.push(CodeGeneratorResponse::generated_message_descriptor_data());
            messages.push(code_generator_response::File::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(1);
            enums.push(code_generator_response::Feature::generated_enum_descriptor_data());
            crate::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        crate::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}

'''
'''--- protobuf/src/reflect/acc/mod.rs ---
use crate::message_dyn::MessageDyn;
use crate::reflect::acc::v2::AccessorV2;
use crate::reflect::ReflectFieldRef;

pub(crate) mod v2;

#[derive(Debug)]
pub(crate) enum GeneratedFieldAccessor {
    V2(AccessorV2),
}

/// Accessor object is constructed in generated code.
/// Should not be used directly.
#[derive(Debug)]
pub struct FieldAccessor {
    pub(crate) _name: &'static str,
    pub(crate) accessor: GeneratedFieldAccessor,
}

impl GeneratedFieldAccessor {
    pub(crate) fn get_reflect<'a>(&self, m: &'a dyn MessageDyn) -> ReflectFieldRef<'a> {
        match self {
            GeneratedFieldAccessor::V2(AccessorV2::Singular(ref a)) => {
                ReflectFieldRef::Optional(a.accessor.get_field(m))
            }
            GeneratedFieldAccessor::V2(AccessorV2::Repeated(ref a)) => {
                ReflectFieldRef::Repeated(a.accessor.get_repeated(m))
            }
            GeneratedFieldAccessor::V2(AccessorV2::Map(ref a)) => {
                ReflectFieldRef::Map(a.accessor.get_reflect(m))
            }
        }
    }
}

impl FieldAccessor {
    pub(crate) fn new(name: &'static str, accessor: AccessorV2) -> FieldAccessor {
        FieldAccessor {
            _name: name,
            accessor: GeneratedFieldAccessor::V2(accessor),
        }
    }
}

'''
'''--- protobuf/src/reflect/acc/v2/map.rs ---
use std::collections::HashMap;
use std::fmt;
use std::hash::Hash;

use crate::message_dyn::MessageDyn;
use crate::message_full::MessageFull;
use crate::reflect::acc::v2::AccessorV2;
use crate::reflect::acc::FieldAccessor;
use crate::reflect::map::ReflectMapMut;
use crate::reflect::map::ReflectMapRef;
use crate::reflect::runtime_types::RuntimeTypeHashable;
use crate::reflect::runtime_types::RuntimeTypeTrait;
use crate::reflect::ProtobufValue;
use crate::reflect::RuntimeType;

pub(crate) trait MapFieldAccessor: Send + Sync + 'static {
    fn get_reflect<'a>(&self, m: &'a dyn MessageDyn) -> ReflectMapRef<'a>;
    fn mut_reflect<'a>(&self, m: &'a mut dyn MessageDyn) -> ReflectMapMut<'a>;
    fn element_type(&self) -> (RuntimeType, RuntimeType);
}

pub(crate) struct MapFieldAccessorHolder {
    pub accessor: Box<dyn MapFieldAccessor>,
}

impl<'a> fmt::Debug for MapFieldAccessorHolder {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("MapFieldAccessorHolder").finish()
    }
}

struct MapFieldAccessorImpl<M, K, V>
where
    M: MessageFull,
    K: ProtobufValue,
    V: ProtobufValue,
{
    get_field: fn(&M) -> &HashMap<K, V>,
    mut_field: fn(&mut M) -> &mut HashMap<K, V>,
}

impl<M, K, V> MapFieldAccessor for MapFieldAccessorImpl<M, K, V>
where
    M: MessageFull,
    K: ProtobufValue + Eq + Hash,
    K::RuntimeType: RuntimeTypeHashable,
    V: ProtobufValue,
{
    fn get_reflect<'a>(&self, m: &'a dyn MessageDyn) -> ReflectMapRef<'a> {
        let m = m.downcast_ref().unwrap();
        let map = (self.get_field)(m);
        ReflectMapRef::new(map)
    }

    fn mut_reflect<'a>(&self, m: &'a mut dyn MessageDyn) -> ReflectMapMut<'a> {
        let m = m.downcast_mut().unwrap();
        let map = (self.mut_field)(m);
        ReflectMapMut::new(map)
    }

    fn element_type(&self) -> (RuntimeType, RuntimeType) {
        (
            K::RuntimeType::runtime_type_box(),
            V::RuntimeType::runtime_type_box(),
        )
    }
}

/// Make accessor for map field
pub fn make_map_simpler_accessor<M, K, V>(
    name: &'static str,
    get_field: for<'a> fn(&'a M) -> &'a HashMap<K, V>,
    mut_field: for<'a> fn(&'a mut M) -> &'a mut HashMap<K, V>,
) -> FieldAccessor
where
    M: MessageFull + 'static,
    K: ProtobufValue + Hash + Eq,
    K::RuntimeType: RuntimeTypeHashable,
    V: ProtobufValue,
{
    FieldAccessor::new(
        name,
        AccessorV2::Map(MapFieldAccessorHolder {
            accessor: Box::new(MapFieldAccessorImpl::<M, K, V> {
                get_field,
                mut_field,
            }),
        }),
    )
}

'''
'''--- protobuf/src/reflect/acc/v2/mod.rs ---
use crate::reflect::acc::v2::map::MapFieldAccessorHolder;
use crate::reflect::acc::v2::repeated::RepeatedFieldAccessorHolder;
use crate::reflect::acc::v2::singular::SingularFieldAccessorHolder;

pub(crate) mod map;
pub(crate) mod repeated;
pub(crate) mod singular;

#[derive(Debug)]
pub(crate) enum AccessorV2 {
    Singular(SingularFieldAccessorHolder),
    Repeated(RepeatedFieldAccessorHolder),
    Map(MapFieldAccessorHolder),
}

'''
'''--- protobuf/src/reflect/acc/v2/repeated.rs ---
use std::fmt;
use std::marker;

use crate::message_dyn::MessageDyn;
use crate::message_full::MessageFull;
use crate::reflect::acc::v2::AccessorV2;
use crate::reflect::acc::FieldAccessor;
use crate::reflect::repeated::ReflectRepeated;
use crate::reflect::repeated::ReflectRepeatedMut;
use crate::reflect::repeated::ReflectRepeatedRef;
use crate::reflect::runtime_types::RuntimeTypeTrait;
use crate::reflect::ProtobufValue;
use crate::reflect::RuntimeType;

pub(crate) trait RepeatedFieldAccessor: Send + Sync + 'static {
    fn get_repeated<'a>(&self, m: &'a dyn MessageDyn) -> ReflectRepeatedRef<'a>;
    fn mut_repeated<'a>(&self, m: &'a mut dyn MessageDyn) -> ReflectRepeatedMut<'a>;
    fn element_type(&self) -> RuntimeType;
}

pub(crate) struct RepeatedFieldAccessorHolder {
    pub accessor: Box<dyn RepeatedFieldAccessor>,
}

impl<'a> fmt::Debug for RepeatedFieldAccessorHolder {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("RepeatedFieldAccessorHolder").finish()
    }
}

trait RepeatedFieldGetMut<M, R: ?Sized>: Send + Sync + 'static
where
    M: MessageFull + 'static,
{
    fn get_field<'a>(&self, message: &'a M) -> &'a R;
    fn mut_field<'a>(&self, message: &'a mut M) -> &'a mut R;
}

struct RepeatedFieldGetMutImpl<M, L>
where
    M: MessageFull + 'static,
{
    get_field: for<'a> fn(&'a M) -> &'a L,
    mut_field: for<'a> fn(&'a mut M) -> &'a mut L,
}

impl<M, V> RepeatedFieldGetMut<M, dyn ReflectRepeated> for RepeatedFieldGetMutImpl<M, Vec<V>>
where
    M: MessageFull + 'static,
    V: ProtobufValue,
{
    fn get_field<'a>(&self, m: &'a M) -> &'a dyn ReflectRepeated {
        (self.get_field)(m) as &dyn ReflectRepeated
    }

    fn mut_field<'a>(&self, m: &'a mut M) -> &'a mut dyn ReflectRepeated {
        (self.mut_field)(m) as &mut dyn ReflectRepeated
    }
}

struct RepeatedFieldAccessorImpl<M, V>
where
    M: MessageFull,
    V: ProtobufValue,
{
    fns: Box<dyn RepeatedFieldGetMut<M, dyn ReflectRepeated>>,
    _marker: marker::PhantomData<V>,
}

impl<M, V> RepeatedFieldAccessor for RepeatedFieldAccessorImpl<M, V>
where
    M: MessageFull,
    V: ProtobufValue,
{
    fn get_repeated<'a>(&self, m: &'a dyn MessageDyn) -> ReflectRepeatedRef<'a> {
        let m = m.downcast_ref().unwrap();
        let repeated = self.fns.get_field(m);
        ReflectRepeatedRef::new(repeated)
    }

    fn mut_repeated<'a>(&self, m: &'a mut dyn MessageDyn) -> ReflectRepeatedMut<'a> {
        let m = m.downcast_mut().unwrap();
        let repeated = self.fns.mut_field(m);
        ReflectRepeatedMut::new(repeated)
    }

    fn element_type(&self) -> RuntimeType {
        V::RuntimeType::runtime_type_box()
    }
}

/// Make accessor for `Vec` field
pub fn make_vec_simpler_accessor<M, V>(
    name: &'static str,
    get_vec: for<'a> fn(&'a M) -> &'a Vec<V>,
    mut_vec: for<'a> fn(&'a mut M) -> &'a mut Vec<V>,
) -> FieldAccessor
where
    M: MessageFull + 'static,
    V: ProtobufValue,
{
    FieldAccessor::new(
        name,
        AccessorV2::Repeated(RepeatedFieldAccessorHolder {
            accessor: Box::new(RepeatedFieldAccessorImpl::<M, V> {
                fns: Box::new(RepeatedFieldGetMutImpl::<M, Vec<V>> {
                    get_field: get_vec,
                    mut_field: mut_vec,
                }),
                _marker: marker::PhantomData::<V>,
            }),
        }),
    )
}

'''
'''--- protobuf/src/reflect/acc/v2/singular/mod.rs ---
use std::fmt;
use std::marker;

use crate::message_dyn::MessageDyn;
use crate::message_field::MessageField;
use crate::message_full::MessageFull;
use crate::reflect::acc::v2::AccessorV2;
use crate::reflect::acc::FieldAccessor;
use crate::reflect::runtime_types::RuntimeTypeTrait;
use crate::reflect::runtime_types::RuntimeTypeWithDeref;
use crate::reflect::value::value_ref::ReflectValueMut;
use crate::reflect::ProtobufValue;
use crate::reflect::ReflectOptionalRef;
use crate::reflect::ReflectValueBox;
use crate::reflect::ReflectValueRef;
use crate::EnumFull;
use crate::EnumOrUnknown;

pub(crate) mod oneof;

/// This trait should not be used directly, use `FieldDescriptor` instead
pub(crate) trait SingularFieldAccessor: Send + Sync + 'static {
    fn get_field<'a>(&self, m: &'a dyn MessageDyn) -> ReflectOptionalRef<'a>;
    fn mut_field_or_default<'a>(&self, m: &'a mut dyn MessageDyn) -> ReflectValueMut<'a>;
    fn set_field(&self, m: &mut dyn MessageDyn, value: ReflectValueBox);
    fn clear_field(&self, m: &mut dyn MessageDyn);
}

pub(crate) struct SingularFieldAccessorHolder {
    pub accessor: Box<dyn SingularFieldAccessor>,
}

impl SingularFieldAccessorHolder {
    fn new<M>(
        get_field: impl for<'a> Fn(&'a M) -> ReflectOptionalRef<'a> + Send + Sync + 'static,
        mut_field_or_default: impl for<'a> Fn(&'a mut M) -> ReflectValueMut<'a> + Send + Sync + 'static,
        set_field: impl Fn(&mut M, ReflectValueBox) + Send + Sync + 'static,
        clear_field: impl Fn(&mut M) + Send + Sync + 'static,
    ) -> SingularFieldAccessorHolder
    where
        M: MessageFull,
    {
        struct Impl<M, G, H, S, C> {
            get_field: G,
            mut_field_or_default: H,
            set_field: S,
            clear_field: C,
            _marker: marker::PhantomData<M>,
        }

        impl<M, G, H, S, C> SingularFieldAccessor for Impl<M, G, H, S, C>
        where
            M: MessageFull,
            G: for<'a> Fn(&'a M) -> ReflectOptionalRef<'a> + Send + Sync + 'static,
            H: for<'a> Fn(&'a mut M) -> ReflectValueMut<'a> + Send + Sync + 'static,
            S: Fn(&mut M, ReflectValueBox) + Send + Sync + 'static,
            C: Fn(&mut M) + Send + Sync + 'static,
        {
            fn get_field<'a>(&self, m: &'a dyn MessageDyn) -> ReflectOptionalRef<'a> {
                (self.get_field)(m.downcast_ref::<M>().unwrap())
            }

            fn mut_field_or_default<'a>(&self, m: &'a mut dyn MessageDyn) -> ReflectValueMut<'a> {
                (self.mut_field_or_default)(m.downcast_mut::<M>().unwrap())
            }

            fn set_field(&self, m: &mut dyn MessageDyn, value: ReflectValueBox) {
                (self.set_field)(m.downcast_mut::<M>().unwrap(), value);
            }

            fn clear_field(&self, m: &mut dyn MessageDyn) {
                (self.clear_field)(m.downcast_mut::<M>().unwrap());
            }
        }

        SingularFieldAccessorHolder {
            accessor: Box::new(Impl {
                get_field,
                mut_field_or_default,
                set_field,
                clear_field,
                _marker: marker::PhantomData,
            }),
        }
    }

    fn new_get_mut<M, V>(
        get_field: for<'a> fn(&'a M) -> &'a V,
        mut_field: for<'a> fn(&'a mut M) -> &'a mut V,
    ) -> SingularFieldAccessorHolder
    where
        M: MessageFull,
        V: ProtobufValue,
    {
        Self::new(
            move |m| {
                let v = (get_field)(m);
                ReflectOptionalRef::new_filter_non_zero(v)
            },
            move |m| V::RuntimeType::as_mut((mut_field)(m)),
            move |m, value| V::RuntimeType::set_from_value_box((mut_field)(m), value),
            move |m| {
                let default_value = V::RuntimeType::default_value_ref().to_box();
                V::RuntimeType::set_from_value_box((mut_field)(m), default_value);
            },
        )
    }

    fn new_get_option_mut_option<M, V>(
        get_field: for<'a> fn(&'a M) -> &'a Option<V>,
        mut_field: for<'a> fn(&'a mut M) -> &'a mut Option<V>,
    ) -> SingularFieldAccessorHolder
    where
        M: MessageFull,
        V: ProtobufValue,
    {
        Self::new(
            move |m| ReflectOptionalRef::new_from_option((get_field)(m).as_ref()),
            move |_m| unimplemented!(),
            move |m, value| {
                *(mut_field)(m) = Some(V::RuntimeType::from_value_box(value).expect("wrong type"))
            },
            move |m| *(mut_field)(m) = None,
        )
    }

    fn new_get_mut_message<M, V>(
        get_field: for<'a> fn(&'a M) -> &'a MessageField<V>,
        mut_field: for<'a> fn(&'a mut M) -> &'a mut MessageField<V>,
    ) -> SingularFieldAccessorHolder
    where
        M: MessageFull,
        V: MessageFull,
    {
        Self::new(
            move |m| ReflectOptionalRef::new_from_option((get_field)(m).as_ref()),
            move |m| {
                let option = (mut_field)(m);
                if option.as_ref().is_none() {
                    *option = MessageField::some(V::default());
                }
                V::RuntimeType::as_mut(option.as_mut().unwrap())
            },
            move |m, value| {
                *(mut_field)(m) =
                    MessageField::some(V::RuntimeType::from_value_box(value).expect("wrong type"))
            },
            move |m| {
                *(mut_field)(m) = MessageField::none();
            },
        )
    }

    pub(crate) fn new_get_option_set_enum<M, E>(
        get: fn(&M) -> Option<EnumOrUnknown<E>>,
        set: fn(&mut M, EnumOrUnknown<E>),
    ) -> SingularFieldAccessorHolder
    where
        M: MessageFull,
        E: EnumFull,
    {
        Self::new(
            move |m| {
                let value = (get)(m);
                match value {
                    Some(v) => ReflectOptionalRef::some(ReflectValueRef::Enum(
                        E::enum_descriptor(),
                        v.value(),
                    )),
                    None => ReflectOptionalRef::none_from::<EnumOrUnknown<E>>(),
                }
            },
            |_m| panic!("cannot get mutable pointer"),
            move |m, value| match value {
                ReflectValueBox::Enum(e, v) => {
                    assert_eq!(E::enum_descriptor(), e);
                    (set)(m, EnumOrUnknown::from_i32(v));
                }
                _ => panic!("expecting enum value"),
            },
            move |m| {
                (set)(m, EnumOrUnknown::from_i32(0));
            },
        )
    }

    pub(crate) fn new_has_get_set<M, V>(
        has: fn(&M) -> bool,
        get: fn(&M) -> V,
        set: fn(&mut M, V),
    ) -> SingularFieldAccessorHolder
    where
        M: MessageFull,
        V: ProtobufValue + Copy,
    {
        Self::new(
            move |m| {
                if (has)(m) {
                    ReflectOptionalRef::some(V::RuntimeType::into_static_value_ref((get)(m)))
                } else {
                    ReflectOptionalRef::none_from::<V>()
                }
            },
            |_m| unimplemented!(),
            move |m, value| (set)(m, value.downcast::<V>().expect("wrong type")),
            move |m| {
                if (has)(m) {
                    (set)(m, V::default());
                }
            },
        )
    }

    pub(crate) fn new_has_get_set_deref<M, V>(
        has: fn(&M) -> bool,
        get: for<'a> fn(&'a M) -> &'a <V::RuntimeType as RuntimeTypeWithDeref>::DerefTarget,
        set: fn(&mut M, V),
    ) -> SingularFieldAccessorHolder
    where
        M: MessageFull,
        V: ProtobufValue,
        V::RuntimeType: RuntimeTypeWithDeref,
    {
        Self::new(
            move |m| {
                if (has)(m) {
                    ReflectOptionalRef::some(
                        <V::RuntimeType as RuntimeTypeWithDeref>::deref_as_ref((get)(m)),
                    )
                } else {
                    ReflectOptionalRef::none_from::<V>()
                }
            },
            |_m| unimplemented!(),
            move |m, value| (set)(m, value.downcast::<V>().expect("message")),
            move |m| {
                if (has)(m) {
                    (set)(m, V::default());
                }
            },
        )
    }

    pub(crate) fn new_has_get_mut_set<M, F>(
        has_field: fn(&M) -> bool,
        get_field: for<'a> fn(&'a M) -> &'a F,
        mut_field: for<'a> fn(&'a mut M) -> &'a mut F,
        set_field: fn(&mut M, F),
    ) -> SingularFieldAccessorHolder
    where
        M: MessageFull,
        F: MessageFull,
    {
        Self::new(
            move |m| {
                if (has_field)(m) {
                    ReflectOptionalRef::some(F::RuntimeType::as_ref((get_field)(m)))
                } else {
                    ReflectOptionalRef::none_from::<F>()
                }
            },
            move |m| F::RuntimeType::as_mut((mut_field)(m)),
            move |m, value| (set_field)(m, value.downcast::<F>().expect("message")),
            move |m| {
                if (has_field)(m) {
                    (set_field)(m, F::default());
                }
            },
        )
    }
}

impl<'a> fmt::Debug for SingularFieldAccessorHolder {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("SingularFieldAccessorHolder").finish()
    }
}

/// Make accessor for `SingularPtrField`
pub fn make_message_field_accessor<M, V>(
    name: &'static str,
    get_field: for<'a> fn(&'a M) -> &'a MessageField<V>,
    mut_field: for<'a> fn(&'a mut M) -> &'a mut MessageField<V>,
) -> FieldAccessor
where
    M: MessageFull,
    V: MessageFull,
{
    FieldAccessor::new(
        name,
        AccessorV2::Singular(SingularFieldAccessorHolder::new_get_mut_message(
            get_field, mut_field,
        )),
    )
}

/// Make accessor for `Option<C>` field
pub fn make_option_accessor<M, V>(
    name: &'static str,
    get_field: for<'a> fn(&'a M) -> &'a Option<V>,
    mut_field: for<'a> fn(&'a mut M) -> &'a mut Option<V>,
) -> FieldAccessor
where
    M: MessageFull,
    V: ProtobufValue,
{
    FieldAccessor::new(
        name,
        AccessorV2::Singular(SingularFieldAccessorHolder::new_get_option_mut_option(
            get_field, mut_field,
        )),
    )
}

/// Make accessor for simple field
pub fn make_simpler_field_accessor<M, V>(
    name: &'static str,
    get_field: for<'a> fn(&'a M) -> &'a V,
    mut_field: for<'a> fn(&'a mut M) -> &'a mut V,
) -> FieldAccessor
where
    M: MessageFull,
    V: ProtobufValue,
{
    FieldAccessor::new(
        name,
        AccessorV2::Singular(SingularFieldAccessorHolder::new_get_mut(
            get_field, mut_field,
        )),
    )
}

'''
'''--- protobuf/src/reflect/acc/v2/singular/oneof.rs ---
use crate::reflect::acc::v2::singular::SingularFieldAccessorHolder;
use crate::reflect::acc::v2::AccessorV2;
use crate::reflect::acc::FieldAccessor;
use crate::reflect::runtime_types::RuntimeTypeWithDeref;
use crate::reflect::ProtobufValue;
use crate::EnumFull;
use crate::EnumOrUnknown;
use crate::MessageFull;

/// Make accessor for `oneof` `message` field
pub fn make_oneof_message_has_get_mut_set_accessor<M, F>(
    name: &'static str,
    has_field: fn(&M) -> bool,
    get_field: for<'a> fn(&'a M) -> &'a F,
    mut_field: for<'a> fn(&'a mut M) -> &'a mut F,
    set_field: fn(&mut M, F),
) -> FieldAccessor
where
    M: MessageFull,
    F: MessageFull,
{
    FieldAccessor::new(
        name,
        AccessorV2::Singular(SingularFieldAccessorHolder::new_has_get_mut_set(
            has_field, get_field, mut_field, set_field,
        )),
    )
}

/// Make accessor for `Copy` field
pub fn make_oneof_copy_has_get_set_simpler_accessors<M, V>(
    name: &'static str,
    has: fn(&M) -> bool,
    get: fn(&M) -> V,
    set: fn(&mut M, V),
) -> FieldAccessor
where
    M: MessageFull,
    V: ProtobufValue + Copy,
{
    FieldAccessor::new(
        name,
        AccessorV2::Singular(SingularFieldAccessorHolder::new_has_get_set(has, get, set)),
    )
}

/// Make accessor for `Copy` field
pub fn make_oneof_enum_accessors<M, E>(
    name: &'static str,
    get: fn(&M) -> Option<EnumOrUnknown<E>>,
    set: fn(&mut M, EnumOrUnknown<E>),
    // TODO: remove this
    _default_value: E,
) -> FieldAccessor
where
    M: MessageFull,
    E: EnumFull,
{
    FieldAccessor::new(
        name,
        AccessorV2::Singular(SingularFieldAccessorHolder::new_get_option_set_enum(
            get, set,
        )),
    )
}

/// Make accessor for `oneof` field
pub fn make_oneof_deref_has_get_set_simpler_accessor<M, F>(
    name: &'static str,
    has: fn(&M) -> bool,
    get: for<'a> fn(&'a M) -> &'a <F::RuntimeType as RuntimeTypeWithDeref>::DerefTarget,
    set: fn(&mut M, F),
) -> FieldAccessor
where
    M: MessageFull + 'static,
    F: ProtobufValue,
    F::RuntimeType: RuntimeTypeWithDeref,
{
    FieldAccessor::new(
        name,
        AccessorV2::Singular(SingularFieldAccessorHolder::new_has_get_set_deref(
            has, get, set,
        )),
    )
}

'''
'''--- protobuf/src/reflect/dynamic/map.rs ---
use std::collections::hash_map;
use std::collections::HashMap;
use std::fmt;
use std::hash::Hash;

use crate::reflect::map::ReflectMap;
use crate::reflect::map::ReflectMapIter;
use crate::reflect::map::ReflectMapIterTrait;
use crate::reflect::runtime_types::RuntimeTypeTrait;
use crate::reflect::ProtobufValue;
use crate::reflect::ReflectValueBox;
use crate::reflect::ReflectValueRef;
use crate::reflect::RuntimeType;

#[derive(Clone)]
enum Maps {
    U32(HashMap<u32, ReflectValueBox>),
    I32(HashMap<i32, ReflectValueBox>),
    U64(HashMap<u64, ReflectValueBox>),
    I64(HashMap<i64, ReflectValueBox>),
    Bool(HashMap<bool, ReflectValueBox>),
    String(HashMap<String, ReflectValueBox>),
}

impl fmt::Debug for Maps {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Maps::U32(map) => fmt::Debug::fmt(map, f),
            Maps::I32(map) => fmt::Debug::fmt(map, f),
            Maps::U64(map) => fmt::Debug::fmt(map, f),
            Maps::I64(map) => fmt::Debug::fmt(map, f),
            Maps::Bool(map) => fmt::Debug::fmt(map, f),
            Maps::String(map) => fmt::Debug::fmt(map, f),
        }
    }
}

impl Maps {
    fn len(&self) -> usize {
        match self {
            Maps::U32(m) => m.len(),
            Maps::I32(m) => m.len(),
            Maps::U64(m) => m.len(),
            Maps::I64(m) => m.len(),
            Maps::Bool(m) => m.len(),
            Maps::String(m) => m.len(),
        }
    }

    fn is_empty(&self) -> bool {
        match self {
            Maps::U32(m) => m.is_empty(),
            Maps::I32(m) => m.is_empty(),
            Maps::U64(m) => m.is_empty(),
            Maps::I64(m) => m.is_empty(),
            Maps::Bool(m) => m.is_empty(),
            Maps::String(m) => m.is_empty(),
        }
    }

    fn clear(&mut self) {
        match self {
            Maps::U32(m) => m.clear(),
            Maps::I32(m) => m.clear(),
            Maps::U64(m) => m.clear(),
            Maps::I64(m) => m.clear(),
            Maps::Bool(m) => m.clear(),
            Maps::String(m) => m.clear(),
        }
    }

    fn key_type(&self) -> RuntimeType {
        match self {
            Maps::U32(..) => RuntimeType::U32,
            Maps::I32(..) => RuntimeType::I32,
            Maps::U64(..) => RuntimeType::U64,
            Maps::I64(..) => RuntimeType::I64,
            Maps::Bool(..) => RuntimeType::Bool,
            Maps::String(..) => RuntimeType::String,
        }
    }
}

#[derive(Clone)]
pub(crate) struct DynamicMap {
    /// Type of value.
    ///
    /// Type of key is defined by the maps key.
    value: RuntimeType,
    maps: Maps,
}

impl fmt::Debug for DynamicMap {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Debug::fmt(&self.maps, f)
    }
}

impl DynamicMap {
    pub fn new(key: RuntimeType, value: RuntimeType) -> DynamicMap {
        DynamicMap {
            value,
            maps: match key {
                RuntimeType::U32 => Maps::U32(HashMap::new()),
                RuntimeType::I32 => Maps::I32(HashMap::new()),
                RuntimeType::U64 => Maps::U64(HashMap::new()),
                RuntimeType::I64 => Maps::I64(HashMap::new()),
                RuntimeType::Bool => Maps::Bool(HashMap::new()),
                RuntimeType::String => Maps::String(HashMap::new()),
                t => panic!("type cannot be hashmap key: {}", t),
            },
        }
    }
}

struct DynamicMapIterImpl<'a, K: ProtobufValue + Eq + Hash + 'static> {
    iter: hash_map::Iter<'a, K, ReflectValueBox>,
    value: &'a RuntimeType,
}

impl<'a, K: ProtobufValue + Eq + Hash + 'static> ReflectMapIterTrait<'a>
    for DynamicMapIterImpl<'a, K>
{
    fn next(&mut self) -> Option<(ReflectValueRef<'a>, ReflectValueRef<'a>)> {
        self.iter
            .next()
            .map(|(k, v)| (K::RuntimeType::as_ref(k), v.as_value_ref()))
    }

    fn key_type(&self) -> RuntimeType {
        K::RuntimeType::runtime_type_box()
    }

    fn value_type(&self) -> RuntimeType {
        self.value.clone()
    }
}

impl ReflectMap for DynamicMap {
    fn reflect_iter(&self) -> ReflectMapIter {
        match &self.maps {
            Maps::U32(m) => ReflectMapIter::new(DynamicMapIterImpl {
                iter: m.iter(),
                value: &self.value,
            }),
            Maps::I32(m) => ReflectMapIter::new(DynamicMapIterImpl {
                iter: m.iter(),
                value: &self.value,
            }),
            Maps::U64(m) => ReflectMapIter::new(DynamicMapIterImpl {
                iter: m.iter(),
                value: &self.value,
            }),
            Maps::I64(m) => ReflectMapIter::new(DynamicMapIterImpl {
                iter: m.iter(),
                value: &self.value,
            }),
            Maps::Bool(m) => ReflectMapIter::new(DynamicMapIterImpl {
                iter: m.iter(),
                value: &self.value,
            }),
            Maps::String(m) => ReflectMapIter::new(DynamicMapIterImpl {
                iter: m.iter(),
                value: &self.value,
            }),
        }
    }

    fn len(&self) -> usize {
        self.maps.len()
    }

    fn is_empty(&self) -> bool {
        self.maps.is_empty()
    }

    fn get<'a>(&'a self, key: ReflectValueRef) -> Option<ReflectValueRef<'a>> {
        match (&self.maps, key) {
            (Maps::U32(m), ReflectValueRef::U32(v)) => m.get(&v),
            (Maps::U64(m), ReflectValueRef::U64(v)) => m.get(&v),
            (Maps::I32(m), ReflectValueRef::I32(v)) => m.get(&v),
            (Maps::I64(m), ReflectValueRef::I64(v)) => m.get(&v),
            (Maps::Bool(m), ReflectValueRef::Bool(v)) => m.get(&v),
            (Maps::String(m), ReflectValueRef::String(v)) => m.get(&*v),
            _ => None,
        }
        .map(ReflectValueBox::as_value_ref)
    }

    fn insert(&mut self, key: ReflectValueBox, value: ReflectValueBox) {
        assert!(value.get_type() == self.value);
        match (&mut self.maps, &key) {
            (Maps::U32(m), ReflectValueBox::U32(k)) => m.insert(*k, value),
            (Maps::U64(m), ReflectValueBox::U64(k)) => m.insert(*k, value),
            (Maps::I32(m), ReflectValueBox::I32(k)) => m.insert(*k, value),
            (Maps::I64(m), ReflectValueBox::I64(k)) => m.insert(*k, value),
            (Maps::Bool(m), ReflectValueBox::Bool(k)) => m.insert(*k, value),
            (Maps::String(m), _) => match key {
                ReflectValueBox::String(k) => m.insert(k, value),
                _ => panic!("wrong key type"),
            },
            _ => panic!("wrong key type"),
        };
    }

    fn clear(&mut self) {
        self.maps.clear()
    }

    fn key_type(&self) -> RuntimeType {
        self.maps.key_type()
    }

    fn value_type(&self) -> RuntimeType {
        self.value.clone()
    }
}

'''
'''--- protobuf/src/reflect/dynamic/mod.rs ---
use std::any::Any;
use std::any::TypeId;
use std::fmt;

use crate::descriptor::field_descriptor_proto::Type;
use crate::message_dyn::MessageDyn;
use crate::reflect::dynamic::map::DynamicMap;
use crate::reflect::dynamic::optional::DynamicOptional;
use crate::reflect::dynamic::repeated::DynamicRepeated;
use crate::reflect::map::ReflectMap;
use crate::reflect::protobuf_type_box::ProtobufType;
use crate::reflect::repeated::ReflectRepeated;
use crate::reflect::value::value_ref::ReflectValueMut;
use crate::reflect::FieldDescriptor;
use crate::reflect::MessageDescriptor;
use crate::reflect::ReflectFieldRef;
use crate::reflect::ReflectMapMut;
use crate::reflect::ReflectMapRef;
use crate::reflect::ReflectRepeatedMut;
use crate::reflect::ReflectRepeatedRef;
use crate::reflect::ReflectValueBox;
use crate::reflect::ReflectValueRef;
use crate::reflect::RuntimeFieldType;
use crate::reflect::Syntax;
use crate::rt::bytes_size;
use crate::rt::compute_raw_varint32_size;
use crate::rt::compute_raw_varint64_size;
use crate::rt::int32_size;
use crate::rt::int64_size;
use crate::rt::map::read_map_template;
use crate::rt::sint32_size;
use crate::rt::sint64_size;
use crate::rt::string_size;
use crate::rt::tag_size;
use crate::rt::uint32_size;
use crate::rt::uint64_size;
use crate::rt::unknown_fields_size;
use crate::rt::unknown_or_group::read_unknown_or_skip_group_with_tag_unpacked;
use crate::rt::vec_packed_bool_size;
use crate::rt::vec_packed_double_size;
use crate::rt::vec_packed_fixed32_size;
use crate::rt::vec_packed_fixed64_size;
use crate::rt::vec_packed_float_size;
use crate::rt::vec_packed_int32_size;
use crate::rt::vec_packed_int64_size;
use crate::rt::vec_packed_sfixed32_size;
use crate::rt::vec_packed_sfixed64_size;
use crate::rt::vec_packed_sint32_size;
use crate::rt::vec_packed_sint64_size;
use crate::rt::vec_packed_uint32_size;
use crate::rt::vec_packed_uint64_size;
use crate::text_format;
use crate::wire_format::WireType;
use crate::CodedInputStream;
use crate::CodedOutputStream;
use crate::SpecialFields;
use crate::UnknownFields;

pub(crate) mod map;
pub(crate) mod optional;
pub(crate) mod repeated;

#[derive(Debug, Clone)]
enum DynamicFieldValue {
    Singular(DynamicOptional),
    Repeated(DynamicRepeated),
    Map(DynamicMap),
}

impl DynamicFieldValue {
    fn as_ref(&self) -> ReflectFieldRef {
        match self {
            DynamicFieldValue::Singular(v) => ReflectFieldRef::Optional(v.reflect_singlar_ref()),
            DynamicFieldValue::Repeated(r) => ReflectFieldRef::Repeated(ReflectRepeatedRef::new(r)),
            DynamicFieldValue::Map(m) => ReflectFieldRef::Map(ReflectMapRef::new(m)),
        }
    }

    fn clear(&mut self) {
        match self {
            DynamicFieldValue::Singular(o) => o.clear(),
            DynamicFieldValue::Repeated(r) => r.clear(),
            DynamicFieldValue::Map(m) => m.clear(),
        }
    }
}

impl DynamicFieldValue {
    fn default_for_field(field: &FieldDescriptor) -> DynamicFieldValue {
        match field.runtime_field_type() {
            RuntimeFieldType::Singular(s) => DynamicFieldValue::Singular(DynamicOptional::none(s)),
            RuntimeFieldType::Repeated(r) => DynamicFieldValue::Repeated(DynamicRepeated::new(r)),
            RuntimeFieldType::Map(k, v) => DynamicFieldValue::Map(DynamicMap::new(k, v)),
        }
    }
}

#[derive(Debug, Clone)]
pub(crate) struct DynamicMessage {
    descriptor: MessageDescriptor,
    /// Fields by index in the description.
    /// This field is lazy-init: it is empty when created.
    fields: Box<[DynamicFieldValue]>,
    special_fields: SpecialFields,
}

impl DynamicMessage {
    pub(crate) fn new(descriptor: MessageDescriptor) -> DynamicMessage {
        DynamicMessage {
            descriptor,
            fields: Vec::new().into_boxed_slice(),
            special_fields: SpecialFields::new(),
        }
    }

    pub(crate) fn descriptor(&self) -> &MessageDescriptor {
        &self.descriptor
    }

    fn init_fields(&mut self) {
        if self.fields.is_empty() {
            self.fields = self
                .descriptor
                .fields()
                .map(|f| DynamicFieldValue::default_for_field(&f))
                .collect();
        }
    }

    pub(crate) fn get_reflect<'a>(&'a self, field: &FieldDescriptor) -> ReflectFieldRef<'a> {
        let (descriptor, index) = field.regular();
        assert_eq!(self.descriptor, descriptor);
        if self.fields.is_empty() {
            ReflectFieldRef::default_for_field(field)
        } else {
            self.fields[index].as_ref()
        }
    }

    pub fn clear_field(&mut self, field: &FieldDescriptor) {
        let (descriptor, index) = field.regular();
        assert_eq!(self.descriptor, descriptor);
        if self.fields.is_empty() {
            return;
        }

        self.fields[index].clear();
    }

    fn clear_oneof_group_fields_except(&mut self, field: &FieldDescriptor) {
        if let Some(oneof) = field.containing_oneof_including_synthetic() {
            for next in oneof.fields() {
                if &next == field {
                    continue;
                }
                self.clear_field(&next);
            }
        }
    }

    pub(crate) fn mut_singular_field_or_default<'a>(
        &'a mut self,
        field: &FieldDescriptor,
    ) -> ReflectValueMut<'a> {
        let (descriptor, index) = field.regular();
        assert_eq!(self.descriptor, descriptor);
        self.init_fields();
        self.clear_oneof_group_fields_except(field);
        match &mut self.fields[index] {
            DynamicFieldValue::Singular(f) => f.mut_or_default(),
            _ => panic!("Not a singular field"),
        }
    }

    pub(crate) fn mut_repeated<'a>(
        &'a mut self,
        field: &FieldDescriptor,
    ) -> ReflectRepeatedMut<'a> {
        let (descriptor, index) = field.regular();
        assert_eq!(self.descriptor, descriptor);
        self.init_fields();
        self.clear_oneof_group_fields_except(field);
        match &mut self.fields[index] {
            DynamicFieldValue::Repeated(r) => ReflectRepeatedMut::new(r),
            _ => panic!("Not a repeated field: {}", field),
        }
    }

    pub(crate) fn mut_map<'a>(&'a mut self, field: &FieldDescriptor) -> ReflectMapMut<'a> {
        let (descriptor, index) = field.regular();
        assert_eq!(self.descriptor, descriptor);
        self.init_fields();
        self.clear_oneof_group_fields_except(field);
        match &mut self.fields[index] {
            DynamicFieldValue::Map(m) => ReflectMapMut::new(m),
            _ => panic!("Not a map field: {}", field),
        }
    }

    pub(crate) fn set_field(&mut self, field: &FieldDescriptor, value: ReflectValueBox) {
        let (descriptor, index) = field.regular();
        assert_eq!(self.descriptor, descriptor);
        self.init_fields();
        self.clear_oneof_group_fields_except(field);
        match &mut self.fields[index] {
            DynamicFieldValue::Singular(s) => s.set(value),
            _ => panic!("Not a singular field: {}", field),
        }
    }

    pub(crate) fn downcast_ref(message: &dyn MessageDyn) -> &DynamicMessage {
        assert!(Any::type_id(&*message) == TypeId::of::<DynamicMessage>());
        unsafe { &*(message as *const dyn MessageDyn as *const DynamicMessage) }
    }

    pub(crate) fn downcast_mut(message: &mut dyn MessageDyn) -> &mut DynamicMessage {
        assert!(Any::type_id(&*message) == TypeId::of::<DynamicMessage>());
        unsafe { &mut *(message as *mut dyn MessageDyn as *mut DynamicMessage) }
    }

    fn for_each_field_to_write(
        &self,
        handler: &mut impl ForEachSingularFieldToWrite,
    ) -> crate::Result<()> {
        let is_proto3 = self.descriptor.file_descriptor().syntax() == Syntax::Proto3;
        for field_desc in self.descriptor.fields() {
            let field_number = field_desc.proto().number() as u32;
            match field_desc.runtime_field_type() {
                RuntimeFieldType::Singular(..) => {
                    if let Some(v) = field_desc.get_singular(self) {
                        // Ignore default value for proto3.
                        if !is_proto3 || v.is_non_zero() {
                            handler.field(field_desc.proto().type_(), field_number, &v)?;
                        }
                    }
                }
                RuntimeFieldType::Repeated(..) => {
                    let repeated = field_desc.get_repeated(self);
                    if field_desc.proto().options.get_or_default().packed() {
                        handler.repeated_packed(
                            field_desc.proto().type_(),
                            field_number,
                            &repeated,
                        )?;
                    } else {
                        for i in 0..repeated.len() {
                            let v = repeated.get(i);
                            handler.field(field_desc.proto().type_(), field_number, &v)?;
                        }
                    }
                }
                RuntimeFieldType::Map(_, _) => {
                    let map = field_desc.get_map(self);
                    let (key_type, value_type) = field_desc.map_proto_type();
                    for (k, v) in &map {
                        handler.map_field_entry(
                            field_number,
                            &k,
                            key_type.t(),
                            &v,
                            value_type.t(),
                        )?;
                    }
                }
            }
        }

        handler.unknown_fields(&self.special_fields.unknown_fields())?;
        Ok(())
    }
}

trait ForEachSingularFieldToWrite {
    fn field(&mut self, t: Type, number: u32, value: &ReflectValueRef) -> crate::Result<()>;
    fn repeated_packed(
        &mut self,
        t: Type,
        number: u32,
        value: &ReflectRepeatedRef,
    ) -> crate::Result<()>;
    fn map_field_entry(
        &mut self,
        number: u32,
        key: &ReflectValueRef,
        kt: Type,
        value: &ReflectValueRef,
        vt: Type,
    ) -> crate::Result<()>;
    fn unknown_fields(&mut self, unknown_fields: &UnknownFields) -> crate::Result<()>;
}

impl fmt::Display for DynamicMessage {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        text_format::fmt(self, f)
    }
}

impl MessageDyn for DynamicMessage {
    fn descriptor_dyn(&self) -> MessageDescriptor {
        self.descriptor.clone()
    }

    fn is_initialized_dyn(&self) -> bool {
        if self.descriptor.is_initialized_is_always_true() {
            return true;
        }

        for f in self.descriptor.fields() {
            let fv = self.get_reflect(&f);
            match fv {
                ReflectFieldRef::Optional(s) => match s.value() {
                    None => {
                        if f.is_required() {
                            return false;
                        }
                    }
                    Some(v) => {
                        if !v.is_initialized() {
                            return false;
                        }
                    }
                },
                ReflectFieldRef::Repeated(r) => {
                    for v in &r {
                        if !v.is_initialized() {
                            return false;
                        }
                    }
                }
                ReflectFieldRef::Map(m) => {
                    for (_k, v) in &m {
                        // Keys cannot be messages, so only check values.
                        if !v.is_initialized() {
                            return false;
                        }
                    }
                }
            }
        }
        true
    }

    fn merge_from_dyn(&mut self, is: &mut CodedInputStream) -> crate::Result<()> {
        while !is.eof()? {
            let (field, wire_type) = is.read_tag_unpack()?;
            let field_desc = match self.descriptor.field_by_number(field) {
                Some(f) => f,
                None => {
                    read_unknown_or_skip_group_with_tag_unpacked(
                        field,
                        wire_type,
                        is,
                        &mut self.special_fields.mut_unknown_fields(),
                    )?;
                    continue;
                }
            };
            match field_desc.runtime_field_type() {
                RuntimeFieldType::Singular(rtb) => {
                    let pt = ProtobufType::new(rtb, field_desc.proto().type_())?;
                    let value = pt.read(is, wire_type)?;
                    self.set_field(&field_desc, value);
                }
                RuntimeFieldType::Repeated(rtb) => {
                    let pt = ProtobufType::new(rtb, field_desc.proto().type_())?;
                    let mut repeated = self.mut_repeated(&field_desc);
                    pt.read_repeated_into(is, wire_type, &mut repeated)?;
                }
                RuntimeFieldType::Map(..) => {
                    let (key_type, value_type) = field_desc.map_proto_type();
                    let mut map = self.mut_map(&field_desc);
                    let mut key = key_type.runtime().default_value_box();
                    let mut value = value_type.runtime().default_value_box();
                    read_map_template(
                        wire_type,
                        is,
                        |wire_type, is| {
                            key = key_type.read(is, wire_type)?;
                            Ok(())
                        },
                        |wire_type, is| {
                            value = value_type.read(is, wire_type)?;
                            Ok(())
                        },
                    )?;
                    map.insert(key, value);
                }
            }
        }
        Ok(())
    }

    fn write_to_with_cached_sizes_dyn(&self, os: &mut CodedOutputStream) -> crate::Result<()> {
        struct Handler<'a, 'o> {
            os: &'a mut CodedOutputStream<'o>,
        }

        impl<'a, 'o> ForEachSingularFieldToWrite for Handler<'a, 'o> {
            fn field(
                &mut self,
                t: Type,
                number: u32,
                value: &ReflectValueRef,
            ) -> crate::Result<()> {
                singular_write_to(t, number, value, self.os)
            }

            fn repeated_packed(
                &mut self,
                t: Type,
                number: u32,
                value: &ReflectRepeatedRef,
            ) -> crate::Result<()> {
                repeated_write_to(t, number, value, self.os)
            }

            fn map_field_entry(
                &mut self,
                number: u32,
                key: &ReflectValueRef,
                kt: Type,
                value: &ReflectValueRef,
                vt: Type,
            ) -> crate::Result<()> {
                let entry_data_size = compute_map_entry_field_data_size(key, kt, value, vt);
                self.os.write_tag(number, WireType::LengthDelimited)?;
                self.os.write_raw_varint32(entry_data_size as u32)?;
                singular_write_to(kt, 1, key, self.os)?;
                singular_write_to(vt, 2, value, self.os)?;
                Ok(())
            }

            fn unknown_fields(&mut self, unknown_fields: &UnknownFields) -> crate::Result<()> {
                self.os.write_unknown_fields(unknown_fields)
            }
        }

        let mut handler = Handler { os };

        self.for_each_field_to_write(&mut handler)
    }

    fn compute_size_dyn(&self) -> u64 {
        struct Handler {
            m_size: u64,
        }

        impl ForEachSingularFieldToWrite for Handler {
            fn field(
                &mut self,
                t: Type,
                number: u32,
                value: &ReflectValueRef,
            ) -> crate::Result<()> {
                self.m_size += compute_singular_size(t, number, value);
                Ok(())
            }

            fn repeated_packed(
                &mut self,
                t: Type,
                number: u32,
                value: &ReflectRepeatedRef,
            ) -> crate::Result<()> {
                self.m_size += compute_repeated_packed_size(t, number, value);
                Ok(())
            }

            fn map_field_entry(
                &mut self,
                number: u32,
                key: &ReflectValueRef,
                kt: Type,
                value: &ReflectValueRef,
                vt: Type,
            ) -> crate::Result<()> {
                let entry_data_size = compute_map_entry_field_data_size(key, kt, value, vt);
                self.m_size += tag_size(number)
                    + compute_raw_varint32_size(entry_data_size as u32)
                    + entry_data_size;
                Ok(())
            }

            fn unknown_fields(&mut self, unknown_fields: &UnknownFields) -> crate::Result<()> {
                self.m_size += unknown_fields_size(unknown_fields);
                Ok(())
            }
        }

        let mut handler = Handler { m_size: 0 };

        self.for_each_field_to_write(&mut handler)
            .expect("compute_size should not fail");

        handler.m_size
    }

    fn special_fields_dyn(&self) -> &SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields_dyn(&mut self) -> &mut SpecialFields {
        &mut self.special_fields
    }
}

/// Write singular field to output stream
fn singular_write_to(
    proto_type: Type,
    field_number: u32,
    v: &ReflectValueRef,
    os: &mut CodedOutputStream,
) -> crate::Result<()> {
    match proto_type {
        Type::TYPE_ENUM => {
            let enum_v = v.to_enum_value().unwrap();
            os.write_enum(field_number, enum_v)
        }
        Type::TYPE_MESSAGE => {
            let msg_v = v.to_message().unwrap();
            os.write_message_dyn(field_number, &*msg_v)
        }
        Type::TYPE_GROUP => {
            unimplemented!()
        }
        Type::TYPE_UINT32 => os.write_uint32(field_number, v.to_u32().unwrap()),
        Type::TYPE_UINT64 => os.write_uint64(field_number, v.to_u64().unwrap()),
        Type::TYPE_INT32 => os.write_int32(field_number, v.to_i32().unwrap()),
        Type::TYPE_INT64 => os.write_int64(field_number, v.to_i64().unwrap()),
        Type::TYPE_SINT32 => os.write_sint32(field_number, v.to_i32().unwrap()),
        Type::TYPE_SINT64 => os.write_sint64(field_number, v.to_i64().unwrap()),
        Type::TYPE_FIXED32 => os.write_fixed32(field_number, v.to_u32().unwrap()),
        Type::TYPE_FIXED64 => os.write_fixed64(field_number, v.to_u64().unwrap()),
        Type::TYPE_SFIXED64 => os.write_sfixed64(field_number, v.to_i64().unwrap()),
        Type::TYPE_SFIXED32 => os.write_sfixed32(field_number, v.to_i32().unwrap()),
        Type::TYPE_BOOL => os.write_bool(field_number, v.to_bool().unwrap()),
        Type::TYPE_STRING => os.write_string(field_number, v.to_str().unwrap()),
        Type::TYPE_BYTES => os.write_bytes(field_number, v.to_bytes().unwrap()),
        Type::TYPE_FLOAT => os.write_float(field_number, v.to_f32().unwrap()),
        Type::TYPE_DOUBLE => os.write_double(field_number, v.to_f64().unwrap()),
    }
}

/// Compute singular field size
fn compute_singular_size(proto_type: Type, field_number: u32, v: &ReflectValueRef) -> u64 {
    match proto_type {
        Type::TYPE_ENUM => {
            let enum_v = v.to_enum_value().unwrap();
            int32_size(field_number, enum_v)
        }
        Type::TYPE_MESSAGE => {
            let msg_v = v.to_message().unwrap();
            let len = msg_v.compute_size_dyn();
            tag_size(field_number) + compute_raw_varint64_size(len) + len
        }
        Type::TYPE_GROUP => {
            unimplemented!()
        }
        Type::TYPE_UINT32 => {
            let typed_v = v.to_u32().unwrap();
            uint32_size(field_number, typed_v)
        }
        Type::TYPE_UINT64 => {
            let typed_v = v.to_u64().unwrap();
            uint64_size(field_number, typed_v)
        }
        Type::TYPE_INT32 => {
            let typed_v = v.to_i32().unwrap();
            int32_size(field_number, typed_v)
        }
        Type::TYPE_INT64 => {
            let typed_v = v.to_i64().unwrap();
            int64_size(field_number, typed_v)
        }
        Type::TYPE_SINT32 => {
            let typed_v = v.to_i32().unwrap();
            sint32_size(field_number, typed_v)
        }
        Type::TYPE_SINT64 => {
            let typed_v = v.to_i64().unwrap();
            sint64_size(field_number, typed_v)
        }
        Type::TYPE_FIXED32 => tag_size(field_number) + 4,
        Type::TYPE_FIXED64 => tag_size(field_number) + 8,
        Type::TYPE_SFIXED32 => tag_size(field_number) + 4,
        Type::TYPE_SFIXED64 => tag_size(field_number) + 8,
        Type::TYPE_BOOL => tag_size(field_number) + 1,
        Type::TYPE_STRING => {
            let typed_v = v.to_str().unwrap();
            string_size(field_number, typed_v)
        }
        Type::TYPE_BYTES => {
            let typed_v = v.to_bytes().unwrap();
            bytes_size(field_number, typed_v)
        }
        Type::TYPE_FLOAT => tag_size(field_number) + 4,
        Type::TYPE_DOUBLE => tag_size(field_number) + 8,
    }
}

fn compute_repeated_packed_size(
    proto_type: Type,
    field_number: u32,
    v: &ReflectRepeatedRef,
) -> u64 {
    match proto_type {
        Type::TYPE_INT32 => vec_packed_int32_size(field_number, v.data_i32()),
        Type::TYPE_INT64 => vec_packed_int64_size(field_number, v.data_i64()),
        Type::TYPE_UINT32 => vec_packed_uint32_size(field_number, v.data_u32()),
        Type::TYPE_UINT64 => vec_packed_uint64_size(field_number, v.data_u64()),
        Type::TYPE_SINT32 => vec_packed_sint32_size(field_number, v.data_i32()),
        Type::TYPE_SINT64 => vec_packed_sint64_size(field_number, v.data_i64()),
        Type::TYPE_FIXED32 => vec_packed_fixed32_size(field_number, v.data_u32()),
        Type::TYPE_FIXED64 => vec_packed_fixed64_size(field_number, v.data_u64()),
        Type::TYPE_SFIXED32 => vec_packed_sfixed32_size(field_number, v.data_i32()),
        Type::TYPE_SFIXED64 => vec_packed_sfixed64_size(field_number, v.data_i64()),
        Type::TYPE_FLOAT => vec_packed_float_size(field_number, v.data_f32()),
        Type::TYPE_DOUBLE => vec_packed_double_size(field_number, v.data_f64()),
        Type::TYPE_BOOL => vec_packed_bool_size(field_number, v.data_bool()),
        Type::TYPE_STRING => panic!("strings cannot be packed"),
        Type::TYPE_BYTES => panic!("bytes cannot be packed"),
        Type::TYPE_ENUM => vec_packed_int32_size(field_number, v.data_enum_values()),
        Type::TYPE_MESSAGE => panic!("messages cannot be packed"),
        Type::TYPE_GROUP => panic!("groups cannot be packed"),
    }
}

fn repeated_write_to(
    proto_type: Type,
    field_number: u32,
    v: &ReflectRepeatedRef,
    os: &mut CodedOutputStream,
) -> crate::Result<()> {
    match proto_type {
        Type::TYPE_INT32 => os.write_repeated_packed_int32(field_number, v.data_i32()),
        Type::TYPE_INT64 => os.write_repeated_packed_int64(field_number, v.data_i64()),
        Type::TYPE_UINT64 => os.write_repeated_packed_uint64(field_number, v.data_u64()),
        Type::TYPE_FIXED64 => os.write_repeated_packed_fixed64(field_number, v.data_u64()),
        Type::TYPE_FIXED32 => os.write_repeated_packed_fixed32(field_number, v.data_u32()),
        Type::TYPE_UINT32 => os.write_repeated_packed_uint32(field_number, v.data_u32()),
        Type::TYPE_SINT32 => os.write_repeated_packed_sint32(field_number, v.data_i32()),
        Type::TYPE_SINT64 => os.write_repeated_packed_sint64(field_number, v.data_i64()),
        Type::TYPE_SFIXED32 => os.write_repeated_packed_sfixed32(field_number, v.data_i32()),
        Type::TYPE_SFIXED64 => os.write_repeated_packed_sfixed64(field_number, v.data_i64()),
        Type::TYPE_BOOL => os.write_repeated_packed_bool(field_number, v.data_bool()),
        Type::TYPE_FLOAT => os.write_repeated_packed_float(field_number, v.data_f32()),
        Type::TYPE_DOUBLE => os.write_repeated_packed_double(field_number, v.data_f64()),
        Type::TYPE_ENUM => os.write_repeated_packed_int32(field_number, v.data_enum_values()),
        Type::TYPE_STRING => panic!("strings cannot be packed"),
        Type::TYPE_BYTES => panic!("bytes cannot be packed"),
        Type::TYPE_GROUP => panic!("groups cannot be packed"),
        Type::TYPE_MESSAGE => panic!("messages cannot be packed"),
    }
}

fn compute_map_entry_field_data_size(
    key: &ReflectValueRef,
    kt: Type,
    value: &ReflectValueRef,
    vt: Type,
) -> u64 {
    let key_size = compute_singular_size(kt, 1, key);
    let value_size = compute_singular_size(vt, 2, value);
    key_size + value_size
}

'''
'''--- protobuf/src/reflect/dynamic/optional.rs ---
use crate::reflect::value::value_ref::ReflectValueMut;
use crate::reflect::ReflectOptionalRef;
use crate::reflect::ReflectValueBox;
use crate::reflect::RuntimeType;

#[derive(Debug, Clone)]
pub(crate) struct DynamicOptional {
    elem: RuntimeType,
    value: Option<ReflectValueBox>,
}

impl DynamicOptional {
    pub(crate) fn none(elem: RuntimeType) -> DynamicOptional {
        DynamicOptional { elem, value: None }
    }

    pub(crate) fn mut_or_default(&mut self) -> ReflectValueMut {
        if let None = self.value {
            self.value = Some(self.elem.default_value_ref().to_box());
        }
        self.value.as_mut().unwrap().as_value_mut()
    }

    pub(crate) fn clear(&mut self) {
        self.value = None;
    }

    pub(crate) fn set(&mut self, value: ReflectValueBox) {
        assert_eq!(value.get_type(), self.elem);
        self.value = Some(value);
    }

    pub(crate) fn reflect_singlar_ref(&self) -> ReflectOptionalRef {
        match &self.value {
            Some(value) => ReflectOptionalRef::some(value.as_value_ref()),
            None => ReflectOptionalRef::none(self.elem.clone()),
        }
    }
}

'''
'''--- protobuf/src/reflect/dynamic/repeated.rs ---
use crate::reflect::repeated::drain_iter::ReflectRepeatedDrainIter;
use crate::reflect::repeated::iter::ReflectRepeatedIter;
use crate::reflect::repeated::ReflectRepeated;
use crate::reflect::EnumDescriptor;
use crate::reflect::MessageDescriptor;
use crate::reflect::MessageRef;
use crate::reflect::ReflectRepeatedMut;
use crate::reflect::ReflectValueBox;
use crate::reflect::ReflectValueRef;
use crate::reflect::RuntimeType;
use crate::MessageDyn;

/// Container of repeated values for dynamic messages.
///
/// It is logically similar to `Vec<ReflectValueBox>`, but:
/// * more efficient
/// * asserts all the elements are of the same type, the type which is specified at construction
#[derive(Debug, Clone)]
pub(crate) enum DynamicRepeated {
    U32(Vec<u32>),
    U64(Vec<u64>),
    I32(Vec<i32>),
    I64(Vec<i64>),
    F32(Vec<f32>),
    F64(Vec<f64>),
    Bool(Vec<bool>),
    String(Vec<String>),
    Bytes(Vec<Vec<u8>>),
    Enum(EnumDescriptor, Vec<i32>),
    Message(MessageDescriptor, Vec<Box<dyn MessageDyn>>),
}

impl ReflectRepeated for DynamicRepeated {
    fn reflect_iter(&self) -> ReflectRepeatedIter {
        match self {
            DynamicRepeated::U32(v) => ReflectRepeatedIter::new_slice(&v),
            DynamicRepeated::U64(v) => ReflectRepeatedIter::new_slice(&v),
            DynamicRepeated::I32(v) => ReflectRepeatedIter::new_slice(&v),
            DynamicRepeated::I64(v) => ReflectRepeatedIter::new_slice(&v),
            DynamicRepeated::F32(v) => ReflectRepeatedIter::new_slice(&v),
            DynamicRepeated::F64(v) => ReflectRepeatedIter::new_slice(&v),
            DynamicRepeated::Bool(v) => ReflectRepeatedIter::new_slice(&v),
            DynamicRepeated::String(v) => ReflectRepeatedIter::new_slice(&v),
            DynamicRepeated::Bytes(v) => ReflectRepeatedIter::new_slice(&v),
            DynamicRepeated::Enum(descriptor, v) => ReflectRepeatedIter::new(
                v.iter()
                    .map(|v| ReflectValueRef::Enum(descriptor.clone(), *v)),
            ),
            DynamicRepeated::Message(_descriptor, v) => ReflectRepeatedIter::new(
                v.iter()
                    .map(|v| ReflectValueRef::Message(MessageRef::new(&**v))),
            ),
        }
    }

    fn reflect_drain_iter(&mut self) -> ReflectRepeatedDrainIter {
        match self {
            DynamicRepeated::U32(v) => ReflectRepeatedDrainIter::new_vec(v),
            DynamicRepeated::U64(v) => ReflectRepeatedDrainIter::new_vec(v),
            DynamicRepeated::I32(v) => ReflectRepeatedDrainIter::new_vec(v),
            DynamicRepeated::I64(v) => ReflectRepeatedDrainIter::new_vec(v),
            DynamicRepeated::F32(v) => ReflectRepeatedDrainIter::new_vec(v),
            DynamicRepeated::F64(v) => ReflectRepeatedDrainIter::new_vec(v),
            DynamicRepeated::Bool(v) => ReflectRepeatedDrainIter::new_vec(v),
            DynamicRepeated::String(v) => ReflectRepeatedDrainIter::new_vec(v),
            DynamicRepeated::Bytes(v) => ReflectRepeatedDrainIter::new_vec(v),
            DynamicRepeated::Enum(descriptor, v) => ReflectRepeatedDrainIter::new(
                v.drain(..)
                    .map(|v| ReflectValueBox::Enum(descriptor.clone(), v)),
            ),
            DynamicRepeated::Message(_descriptor, v) => {
                ReflectRepeatedDrainIter::new(v.drain(..).map(|v| ReflectValueBox::Message(v)))
            }
        }
    }

    fn len(&self) -> usize {
        match self {
            DynamicRepeated::U32(v) => v.len(),
            DynamicRepeated::U64(v) => v.len(),
            DynamicRepeated::I32(v) => v.len(),
            DynamicRepeated::I64(v) => v.len(),
            DynamicRepeated::F32(v) => v.len(),
            DynamicRepeated::F64(v) => v.len(),
            DynamicRepeated::Bool(v) => v.len(),
            DynamicRepeated::String(v) => v.len(),
            DynamicRepeated::Bytes(v) => v.len(),
            DynamicRepeated::Enum(.., v) => v.len(),
            DynamicRepeated::Message(.., v) => v.len(),
        }
    }

    fn get(&self, index: usize) -> ReflectValueRef {
        match self {
            DynamicRepeated::U32(v) => ReflectValueRef::U32(v[index]),
            DynamicRepeated::U64(v) => ReflectValueRef::U64(v[index]),
            DynamicRepeated::I32(v) => ReflectValueRef::I32(v[index]),
            DynamicRepeated::I64(v) => ReflectValueRef::I64(v[index]),
            DynamicRepeated::F32(v) => ReflectValueRef::F32(v[index]),
            DynamicRepeated::F64(v) => ReflectValueRef::F64(v[index]),
            DynamicRepeated::Bool(v) => ReflectValueRef::Bool(v[index]),
            DynamicRepeated::String(v) => ReflectValueRef::String(&v[index]),
            DynamicRepeated::Bytes(v) => ReflectValueRef::Bytes(&v[index]),
            DynamicRepeated::Enum(descriptor, v) => {
                ReflectValueRef::Enum(descriptor.clone(), v[index])
            }
            DynamicRepeated::Message(_descriptor, v) => {
                ReflectValueRef::Message(MessageRef::from(&*v[index]))
            }
        }
    }

    fn set(&mut self, index: usize, value: ReflectValueBox) {
        match self {
            DynamicRepeated::U32(v) => v.set(index, value),
            DynamicRepeated::U64(v) => v.set(index, value),
            DynamicRepeated::I32(v) => v.set(index, value),
            DynamicRepeated::I64(v) => v.set(index, value),
            DynamicRepeated::F32(v) => v.set(index, value),
            DynamicRepeated::F64(v) => v.set(index, value),
            DynamicRepeated::Bool(v) => v.set(index, value),
            DynamicRepeated::String(v) => v.set(index, value),
            DynamicRepeated::Bytes(v) => v.set(index, value),
            DynamicRepeated::Enum(descriptor, vs) => match value {
                ReflectValueBox::Enum(value_description, v) => {
                    assert_eq!(*descriptor, value_description);
                    vs[index] = v;
                }
                _ => panic!("Expected enum value"),
            },
            DynamicRepeated::Message(descriptor, vs) => match value {
                ReflectValueBox::Message(message) => {
                    assert_eq!(*descriptor, message.descriptor_dyn());
                    vs[index] = message;
                }
                _ => panic!("Expected message value"),
            },
        }
    }

    fn push(&mut self, value: ReflectValueBox) {
        match self {
            DynamicRepeated::U32(vs) => ReflectRepeated::push(vs, value),
            DynamicRepeated::U64(vs) => ReflectRepeated::push(vs, value),
            DynamicRepeated::I32(vs) => ReflectRepeated::push(vs, value),
            DynamicRepeated::I64(vs) => ReflectRepeated::push(vs, value),
            DynamicRepeated::F32(vs) => ReflectRepeated::push(vs, value),
            DynamicRepeated::F64(vs) => ReflectRepeated::push(vs, value),
            DynamicRepeated::Bool(vs) => ReflectRepeated::push(vs, value),
            DynamicRepeated::String(vs) => ReflectRepeated::push(vs, value),
            DynamicRepeated::Bytes(vs) => ReflectRepeated::push(vs, value),
            DynamicRepeated::Enum(descriptor, vs) => match value {
                ReflectValueBox::Enum(value_description, v) => {
                    assert_eq!(*descriptor, value_description);
                    vs.push(v);
                }
                _ => panic!("Expected enum value"),
            },
            DynamicRepeated::Message(descriptor, vs) => match value {
                ReflectValueBox::Message(message) => {
                    assert_eq!(*descriptor, message.descriptor_dyn());
                    vs.push(message);
                }
                _ => panic!("Expected message value"),
            },
        }
    }

    fn reflect_extend(&mut self, values: ReflectRepeatedMut) {
        match self {
            DynamicRepeated::U32(vs) => vs.extend(values.repeated.data_u32()),
            DynamicRepeated::U64(vs) => vs.extend(values.repeated.data_u64()),
            DynamicRepeated::I32(vs) => vs.extend(values.repeated.data_i32()),
            DynamicRepeated::I64(vs) => vs.extend(values.repeated.data_i64()),
            DynamicRepeated::F32(vs) => vs.extend(values.repeated.data_f32()),
            DynamicRepeated::F64(vs) => vs.extend(values.repeated.data_f64()),
            DynamicRepeated::Bool(vs) => vs.extend(values.repeated.data_bool()),
            _ => {
                // Default less efficient implementation.
                for value in values.repeated.reflect_drain_iter() {
                    self.push(value);
                }
            }
        }
    }

    fn clear(&mut self) {
        match self {
            DynamicRepeated::U32(vs) => vs.clear(),
            DynamicRepeated::U64(vs) => vs.clear(),
            DynamicRepeated::I32(vs) => vs.clear(),
            DynamicRepeated::I64(vs) => vs.clear(),
            DynamicRepeated::F32(vs) => vs.clear(),
            DynamicRepeated::F64(vs) => vs.clear(),
            DynamicRepeated::Bool(vs) => vs.clear(),
            DynamicRepeated::String(vs) => vs.clear(),
            DynamicRepeated::Bytes(vs) => vs.clear(),
            DynamicRepeated::Enum(_descriptor, vs) => vs.clear(),
            DynamicRepeated::Message(_descriptor, vs) => vs.clear(),
        }
    }

    fn element_type(&self) -> RuntimeType {
        match self {
            DynamicRepeated::U32(..) => RuntimeType::U32,
            DynamicRepeated::U64(..) => RuntimeType::U64,
            DynamicRepeated::I32(..) => RuntimeType::I32,
            DynamicRepeated::I64(..) => RuntimeType::I64,
            DynamicRepeated::F32(..) => RuntimeType::F32,
            DynamicRepeated::F64(..) => RuntimeType::F64,
            DynamicRepeated::Bool(..) => RuntimeType::Bool,
            DynamicRepeated::String(..) => RuntimeType::String,
            DynamicRepeated::Bytes(..) => RuntimeType::VecU8,
            DynamicRepeated::Enum(descriptor, _vs) => RuntimeType::Enum(descriptor.clone()),
            DynamicRepeated::Message(descriptor, _vs) => RuntimeType::Message(descriptor.clone()),
        }
    }

    fn data_enum_values(&self) -> &[i32] {
        match self {
            DynamicRepeated::Enum(_descriptor, vs) => &vs,
            _ => panic!("Expected enum value"),
        }
    }

    fn data_bool(&self) -> &[bool] {
        match self {
            DynamicRepeated::Bool(vs) => &vs,
            _ => panic!("Expected bool value"),
        }
    }

    fn data_u32(&self) -> &[u32] {
        match self {
            DynamicRepeated::U32(vs) => &vs,
            _ => panic!("Expected u32 value"),
        }
    }

    fn data_u64(&self) -> &[u64] {
        match self {
            DynamicRepeated::U64(vs) => &vs,
            _ => panic!("Expected u64 value"),
        }
    }

    fn data_i32(&self) -> &[i32] {
        match self {
            DynamicRepeated::I32(vs) => &vs,
            _ => panic!("Expected i32 value"),
        }
    }

    fn data_i64(&self) -> &[i64] {
        match self {
            DynamicRepeated::I64(vs) => &vs,
            _ => panic!("Expected i64 value"),
        }
    }

    fn data_f32(&self) -> &[f32] {
        match self {
            DynamicRepeated::F32(vs) => &vs,
            _ => panic!("Expected f32 value"),
        }
    }

    fn data_f64(&self) -> &[f64] {
        match self {
            DynamicRepeated::F64(vs) => &vs,
            _ => panic!("Expected f64 value"),
        }
    }
}

impl DynamicRepeated {
    pub fn new(elem: RuntimeType) -> DynamicRepeated {
        match elem {
            RuntimeType::U32 => DynamicRepeated::U32(Vec::new()),
            RuntimeType::U64 => DynamicRepeated::U64(Vec::new()),
            RuntimeType::I32 => DynamicRepeated::I32(Vec::new()),
            RuntimeType::I64 => DynamicRepeated::I64(Vec::new()),
            RuntimeType::F32 => DynamicRepeated::F32(Vec::new()),
            RuntimeType::F64 => DynamicRepeated::F64(Vec::new()),
            RuntimeType::Bool => DynamicRepeated::Bool(Vec::new()),
            RuntimeType::String => DynamicRepeated::String(Vec::new()),
            RuntimeType::VecU8 => DynamicRepeated::Bytes(Vec::new()),
            RuntimeType::Enum(enum_descriptor) => {
                DynamicRepeated::Enum(enum_descriptor, Vec::new())
            }
            RuntimeType::Message(message_descriptor) => {
                DynamicRepeated::Message(message_descriptor, Vec::new())
            }
        }
    }
}

'''
'''--- protobuf/src/reflect/enums/generated.rs ---
//! Generated code support for enum descriptors.

use std::any::TypeId;

use crate::descriptor::FileDescriptorProto;
use crate::EnumFull;
use crate::EnumOrUnknown;

#[doc(hidden)]
pub struct GeneratedEnumDescriptorData {
    pub(crate) name_in_file: &'static str,
    type_id: TypeId,
    enum_or_unknown_type_id: TypeId,
}

impl GeneratedEnumDescriptorData {
    #[doc(hidden)]
    pub fn new<E>(name_in_file: &'static str) -> GeneratedEnumDescriptorData
    where
        E: EnumFull,
    {
        GeneratedEnumDescriptorData {
            name_in_file,
            type_id: TypeId::of::<E>(),
            enum_or_unknown_type_id: TypeId::of::<EnumOrUnknown<E>>(),
        }
    }
}

#[derive(Debug)]
pub(crate) struct GeneratedEnumDescriptor {
    /// Type id of `<E>`
    pub(crate) type_id: TypeId,
    /// Type id of `<ProtobufEnumOrUnknown<E>>`
    pub(crate) _enum_or_unknown_type_id: TypeId,
}

impl GeneratedEnumDescriptor {
    pub(crate) fn new(
        data: GeneratedEnumDescriptorData,
        file_descriptor_proto: &'static FileDescriptorProto,
    ) -> GeneratedEnumDescriptor {
        let GeneratedEnumDescriptorData {
            name_in_file,
            type_id,
            enum_or_unknown_type_id,
        } = data;

        let _ = (name_in_file, file_descriptor_proto);

        GeneratedEnumDescriptor {
            type_id,
            _enum_or_unknown_type_id: enum_or_unknown_type_id,
        }
    }
}

'''
'''--- protobuf/src/reflect/enums/mod.rs ---
use std::any::TypeId;
use std::fmt;
use std::fmt::Formatter;
use std::hash::Hash;

use crate::descriptor::EnumDescriptorProto;
use crate::descriptor::EnumValueDescriptorProto;
use crate::enums::Enum;
use crate::reflect::enums::generated::GeneratedEnumDescriptor;
use crate::reflect::file::index::EnumIndices;
use crate::reflect::file::FileDescriptorImpl;
use crate::reflect::FileDescriptor;
use crate::reflect::MessageDescriptor;
use crate::EnumFull;

pub(crate) mod generated;

/// Description for enum variant.
///
/// Used in reflection.
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct EnumValueDescriptor {
    pub(crate) enum_descriptor: EnumDescriptor,
    pub(crate) index: usize,
}

fn _assert_send_sync() {
    fn _assert_send_sync<T: Send + Sync>() {}
    _assert_send_sync::<EnumValueDescriptor>();
}

impl fmt::Debug for EnumValueDescriptor {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.debug_struct("EnumValueDescriptor")
            .field("enum_descriptor", &self.enum_descriptor)
            .field("name", &self.name())
            .finish()
    }
}

impl fmt::Display for EnumValueDescriptor {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        write!(f, "{}.{}", self.enum_descriptor, self.name())
    }
}

impl EnumValueDescriptor {
    pub(crate) fn new(enum_descriptor: EnumDescriptor, index: usize) -> EnumValueDescriptor {
        EnumValueDescriptor {
            enum_descriptor,
            index,
        }
    }

    /// `.proto` object which declared this value.
    pub fn proto(&self) -> &EnumValueDescriptorProto {
        &self.enum_descriptor.proto().value[self.index]
    }

    /// Name of enum variant as specified in proto file
    pub fn name(&self) -> &str {
        self.proto().name()
    }

    /// Fully qualified enum value name: fully qualified enum name followed by value name.
    pub fn full_name(&self) -> String {
        self.to_string()
    }

    /// `i32` value of the enum variant
    pub fn value(&self) -> i32 {
        self.proto().number()
    }

    /// Get descriptor of enum holding this value.
    pub fn enum_descriptor(&self) -> &EnumDescriptor {
        &self.enum_descriptor
    }

    /// Convert this value descriptor into proper enum object.
    ///
    /// ```
    /// # use protobuf::well_known_types::struct_::NullValue;
    /// # use protobuf::EnumFull;
    /// # use protobuf::reflect::EnumValueDescriptor;
    ///
    /// # if !cfg!(miri) {
    /// let value: EnumValueDescriptor = NullValue::NULL_VALUE.descriptor();
    /// let null: Option<NullValue> = value.cast();
    /// assert_eq!(Some(NullValue::NULL_VALUE), null);
    /// # }
    /// ```
    pub fn cast<E: EnumFull>(&self) -> Option<E> {
        if self.enum_descriptor != E::enum_descriptor() {
            return None;
        }
        E::from_i32(self.value())
    }
}

/// Dynamic representation of enum type.
///
/// Can be used in reflective operations.
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct EnumDescriptor {
    file_descriptor: FileDescriptor,
    index: usize,
}

impl fmt::Display for EnumDescriptor {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.full_name())
    }
}

impl fmt::Debug for EnumDescriptor {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.debug_struct("EnumDescriptor")
            .field("full_name", &self.full_name())
            .finish_non_exhaustive()
    }
}

impl EnumDescriptor {
    pub(crate) fn new(file_descriptor: FileDescriptor, index: usize) -> EnumDescriptor {
        EnumDescriptor {
            file_descriptor,
            index,
        }
    }

    fn get_impl(&self) -> EnumDescriptorImplRef {
        match &self.file_descriptor.imp {
            FileDescriptorImpl::Generated(g) => {
                EnumDescriptorImplRef::Generated(&g.enums[self.index])
            }
            FileDescriptorImpl::Dynamic(..) => EnumDescriptorImplRef::Dynamic,
        }
    }

    /// Descriptor objects which defined this enum.
    pub fn proto(&self) -> &EnumDescriptorProto {
        &self.index_entry().proto
    }

    /// Enum name as given in `.proto` file
    pub fn name(&self) -> &str {
        self.proto().name()
    }

    fn index_entry(&self) -> &EnumIndices {
        self.file_descriptor.enum_indices(self.index)
    }

    /// Fully qualified protobuf name of enum
    pub fn full_name(&self) -> &str {
        &self.index_entry().full_name
    }

    /// Name relative to the package where the message is declared.
    pub fn name_to_package(&self) -> &str {
        &self.index_entry().name_to_package
    }

    /// Get `EnumDescriptor` object for given enum type
    pub fn for_type<E: EnumFull>() -> EnumDescriptor {
        E::enum_descriptor()
    }

    /// Get a message containing this message, or `None` if this message is declared at file level.
    pub fn enclosing_message(&self) -> Option<MessageDescriptor> {
        self.index_entry()
            .enclosing_message
            .map(|i| MessageDescriptor::new(self.file_descriptor.clone(), i))
    }

    /// This enum values
    pub fn values<'a>(&'a self) -> impl Iterator<Item = EnumValueDescriptor> + 'a {
        let value_len = self.proto().value.len();
        (0..value_len).map(move |index| EnumValueDescriptor {
            enum_descriptor: self.clone(),
            index,
        })
    }

    /// Find enum variant by name
    pub fn value_by_name(&self, name: &str) -> Option<EnumValueDescriptor> {
        let index = *self.file_descriptor.common().enums[self.index]
            .index_by_name
            .get(name)?;
        Some(EnumValueDescriptor {
            enum_descriptor: self.clone(),
            index,
        })
    }

    /// Find enum variant by number
    pub fn value_by_number(&self, number: i32) -> Option<EnumValueDescriptor> {
        let index = *self.file_descriptor.common().enums[self.index]
            .index_by_number
            .get(&number)?;
        Some(self.value_by_index(index))
    }

    /// Get enum variant by index (as declared in `.proto` file).
    pub fn value_by_index(&self, index: usize) -> EnumValueDescriptor {
        assert!(index < self.proto().value.len());
        EnumValueDescriptor {
            enum_descriptor: self.clone(),
            index,
        }
    }

    /// Default enum value (first variant).
    pub fn default_value(&self) -> EnumValueDescriptor {
        EnumValueDescriptor {
            enum_descriptor: self.clone(),
            index: 0,
        }
    }

    /// Find enum variant by number or return default (first) enum value
    pub fn value_by_number_or_default(&self, number: i32) -> EnumValueDescriptor {
        self.value_by_number(number)
            .unwrap_or_else(|| self.default_value())
    }

    /// Check if this enum descriptor corresponds given enum type
    ///
    /// ```
    /// # use protobuf::EnumFull;
    /// # use protobuf::descriptor::field_descriptor_proto::Label;
    /// # use protobuf::reflect::EnumDescriptor;
    ///
    /// # if !cfg!(miri) {
    /// let descriptor: EnumDescriptor = Label::enum_descriptor();
    ///
    /// assert!(descriptor.is::<Label>())
    /// }
    /// ```
    pub fn is<E: Enum>(&self) -> bool {
        match self.get_impl() {
            EnumDescriptorImplRef::Generated(g) => g.type_id == TypeId::of::<E>(),
            EnumDescriptorImplRef::Dynamic => false,
        }
    }
}

enum EnumDescriptorImplRef {
    Generated(&'static GeneratedEnumDescriptor),
    Dynamic,
}

#[cfg(test)]
mod test {
    use crate::descriptor::field_descriptor_proto::Label;
    use crate::descriptor::field_descriptor_proto::Type;
    use crate::descriptor::FieldDescriptorProto;
    use crate::well_known_types::struct_::NullValue;
    use crate::EnumFull;
    use crate::MessageFull;

    #[test]
    #[cfg_attr(miri, ignore)] // Too slow on Miri.
    fn enclosing_message() {
        assert_eq!(
            Some(FieldDescriptorProto::descriptor()),
            Type::enum_descriptor().enclosing_message()
        );
        assert_eq!(None, NullValue::enum_descriptor().enclosing_message());
    }

    #[test]
    #[cfg_attr(miri, ignore)] // Too slow on Miri.
    fn to_string() {
        assert_eq!(
            "google.protobuf.FieldDescriptorProto.Label",
            Label::enum_descriptor().to_string()
        );
        assert_eq!(
            "google.protobuf.FieldDescriptorProto.Label",
            Label::enum_descriptor().full_name()
        );
        assert_eq!(
            "google.protobuf.FieldDescriptorProto.Label.LABEL_REPEATED",
            Label::LABEL_REPEATED.descriptor().to_string()
        );
        assert_eq!(
            "google.protobuf.FieldDescriptorProto.Label.LABEL_REPEATED",
            Label::LABEL_REPEATED.descriptor().full_name()
        );
    }
}

'''
'''--- protobuf/src/reflect/error.rs ---
#[derive(Debug, thiserror::Error)]
pub(crate) enum ReflectError {
    #[error("Message `{}` not found in files: {}", .0, .1)]
    MessageNotFoundInFiles(String, String),
    #[error("Dependency `{}` of `{}` not found; all deps: {}", .0, .1, .2)]
    DependencyNotFound(String, String, String),
    #[error("Non-unique dependencies given: {}", .0)]
    NonUniqueDependencies(String),
    #[error("Non-unique field name: `{0}`")]
    NonUniqueFieldName(String),
    #[error("Non-unique file descriptor: `{0}`")]
    NonUniqueFileDescriptor(String),
    #[error("Cycle in provided file descriptors")]
    CycleInFileDescriptors,
    #[error("Map entry message name must end with `Entry`")]
    MapEntryNameMustEndWithEntry,
    #[error("Map entry message must have no extensions, nested messages or enums")]
    MapEntryMustHaveNo,
    #[error(
        "Map entry message must have two optional fields, \
        numbered 1 and 2 and named `key` and `value`"
    )]
    MapEntryIncorrectFields,
    #[error("Could not parse default value for field {0}")]
    CouldNotParseDefaultValueForField(String),
}

'''
'''--- protobuf/src/reflect/field/dynamic.rs ---
use crate::message_dyn::MessageDyn;
use crate::reflect::dynamic::DynamicMessage;
use crate::reflect::FieldDescriptor;
use crate::reflect::ReflectFieldRef;
use crate::reflect::ReflectMapMut;
use crate::reflect::ReflectRepeatedMut;
use crate::reflect::ReflectValueBox;

pub(crate) struct DynamicFieldDescriptorRef<'a> {
    pub(crate) field: &'a FieldDescriptor,
}

impl<'a> DynamicFieldDescriptorRef<'a> {
    pub(crate) fn get_reflect<'b>(&self, message: &'b dyn MessageDyn) -> ReflectFieldRef<'b> {
        DynamicMessage::downcast_ref(message).get_reflect(&self.field)
    }

    pub(crate) fn mut_repeated<'b>(
        &self,
        message: &'b mut dyn MessageDyn,
    ) -> ReflectRepeatedMut<'b> {
        DynamicMessage::downcast_mut(message).mut_repeated(&self.field)
    }

    pub(crate) fn mut_map<'b>(&self, message: &'b mut dyn MessageDyn) -> ReflectMapMut<'b> {
        DynamicMessage::downcast_mut(message).mut_map(&self.field)
    }

    pub(crate) fn set_field(&self, message: &mut dyn MessageDyn, value: ReflectValueBox) {
        DynamicMessage::downcast_mut(message).set_field(&self.field, value)
    }

    pub(crate) fn clear_field(&self, message: &mut dyn MessageDyn) {
        DynamicMessage::downcast_mut(message).clear_field(&self.field)
    }
}

'''
'''--- protobuf/src/reflect/field/index.rs ---
use protobuf_support::json_name::json_name;

use crate::descriptor::field_descriptor_proto::Type;
use crate::descriptor::FieldDescriptorProto;
use crate::descriptor::FileDescriptorProto;
use crate::owning_ref::OwningRef;
use crate::reflect::error::ReflectError;
use crate::reflect::field::protobuf_field_type::ProtobufFieldType;
use crate::reflect::file::building::FileDescriptorBuilding;
use crate::reflect::protobuf_type_box::ProtobufType;
use crate::reflect::EnumDescriptor;
use crate::reflect::EnumValueDescriptor;
use crate::reflect::FieldDescriptor;
use crate::reflect::FileDescriptor;
use crate::reflect::MessageDescriptor;
use crate::reflect::ReflectValueBox;
use crate::reflect::ReflectValueRef;
use crate::reflect::RuntimeType;

#[derive(Debug)]
pub(crate) enum ForwardProtobufTypeBox {
    ProtobufTypeBox(ProtobufType),
    CurrentFileEnum(usize),
    CurrentFileMessage(usize),
}

impl ForwardProtobufTypeBox {
    pub(crate) fn message(message: MessageDescriptor) -> ForwardProtobufTypeBox {
        ForwardProtobufTypeBox::ProtobufTypeBox(ProtobufType::message(message))
    }

    pub(crate) fn enumeration(enumeration: EnumDescriptor) -> ForwardProtobufTypeBox {
        ForwardProtobufTypeBox::ProtobufTypeBox(ProtobufType::enumeration(enumeration))
    }

    pub(crate) fn from_proto_type(t: Type) -> ForwardProtobufTypeBox {
        ForwardProtobufTypeBox::ProtobufTypeBox(ProtobufType::from_proto_type(t))
    }

    pub(crate) fn resolve(&self, file: &FileDescriptor) -> ProtobufType {
        match self {
            ForwardProtobufTypeBox::ProtobufTypeBox(t) => t.clone(),
            ForwardProtobufTypeBox::CurrentFileMessage(m) => {
                ProtobufType::message(MessageDescriptor::new(file.clone(), *m))
            }
            ForwardProtobufTypeBox::CurrentFileEnum(m) => {
                ProtobufType::enumeration(EnumDescriptor::new(file.clone(), *m))
            }
        }
    }

    pub(crate) fn resolve_message(&self, file: &FileDescriptor) -> MessageDescriptor {
        match self.resolve(file).runtime() {
            RuntimeType::Message(m) => m.clone(),
            _ => panic!("not message"),
        }
    }
}

#[derive(Debug)]
pub(crate) enum ForwardProtobufFieldType {
    Singular(ForwardProtobufTypeBox),
    Repeated(ForwardProtobufTypeBox),
    Map(ForwardProtobufTypeBox, ForwardProtobufTypeBox),
}

impl ForwardProtobufFieldType {
    pub(crate) fn resolve(&self, file: &FileDescriptor) -> ProtobufFieldType {
        match self {
            ForwardProtobufFieldType::Singular(t) => ProtobufFieldType::Singular(t.resolve(file)),
            ForwardProtobufFieldType::Repeated(t) => ProtobufFieldType::Repeated(t.resolve(file)),
            ForwardProtobufFieldType::Map(k, v) => {
                ProtobufFieldType::Map(k.resolve(file), v.resolve(file))
            }
        }
    }
}

#[derive(Debug)]
pub(crate) enum FieldDefaultValue {
    ReflectValueBox(ReflectValueBox),
    Enum(usize),
}

#[derive(Debug)]
pub(crate) enum FieldKind {
    MessageField(
        /// Message index.
        usize,
    ),
    Extension(
        /// Message index or `None` for file.
        Option<usize>,
        ForwardProtobufTypeBox,
    ),
}

#[derive(Debug)]
pub(crate) struct FieldIndex {
    pub(crate) proto: OwningRef<FileDescriptorProto, FieldDescriptorProto>,
    pub(crate) kind: FieldKind,
    pub(crate) json_name: String,
    pub(crate) field_type: ForwardProtobufFieldType,
    pub(crate) default_value: Option<FieldDefaultValue>,
}

impl FieldIndex {
    fn enum_default_value(
        field: &FieldDescriptorProto,
        building: &FileDescriptorBuilding,
    ) -> crate::Result<FieldDefaultValue> {
        let en = building.find_enum(field.type_name());
        let (n, _) = match en
            .value
            .iter()
            .enumerate()
            .find(|(_n, v)| v.name() == field.default_value())
        {
            Some(v) => v,
            None => Err(ReflectError::CouldNotParseDefaultValueForField(
                field.name().to_owned(),
            ))?,
        };
        Ok(FieldDefaultValue::Enum(n))
    }

    fn parse_default_value(
        field: &FieldDescriptorProto,
        building: &FileDescriptorBuilding,
    ) -> crate::Result<FieldDefaultValue> {
        Ok(FieldDefaultValue::ReflectValueBox(match field.type_() {
            Type::TYPE_GROUP | Type::TYPE_MESSAGE => {
                return Err(ReflectError::CouldNotParseDefaultValueForField(
                    field.name().to_owned(),
                )
                .into());
            }
            Type::TYPE_ENUM => {
                return Self::enum_default_value(field, building);
            }
            t => RuntimeType::from_proto_type(t)
                .parse_proto_default_value(field.default_value())
                .map_err(|()| {
                    ReflectError::CouldNotParseDefaultValueForField(field.name().to_owned())
                })?,
        }))
    }

    pub(crate) fn index(
        containing_message: Option<usize>,
        field: OwningRef<FileDescriptorProto, FieldDescriptorProto>,
        building: &FileDescriptorBuilding,
    ) -> crate::Result<FieldIndex> {
        let default_value = if field.has_default_value() {
            Some(Self::parse_default_value(&field, building)?)
        } else {
            None
        };

        let json_name = if !field.json_name().is_empty() {
            field.json_name().to_owned()
        } else {
            json_name(field.name())
        };

        let extendee = if field.has_extendee() {
            Some(building.resolve_message(field.extendee())?)
        } else {
            None
        };

        let kind = match (containing_message, extendee) {
            (Some(m), None) => FieldKind::MessageField(m),
            (m, Some(extendee)) => FieldKind::Extension(m, extendee),
            (None, None) => panic!("field must be in a message or an extension"),
        };

        let field_type = building.resolve_field_type(&field)?;
        Ok(FieldIndex {
            proto: field,
            kind,
            default_value,
            json_name,
            field_type,
        })
    }

    pub(crate) fn default_value<'a>(&'a self, field: &FieldDescriptor) -> ReflectValueRef<'a> {
        match &self.default_value {
            Some(FieldDefaultValue::ReflectValueBox(v)) => v.as_value_ref(),
            Some(FieldDefaultValue::Enum(v)) => match field.singular_runtime_type() {
                RuntimeType::Enum(e) => {
                    let ev = EnumValueDescriptor::new(e.clone(), *v);
                    ReflectValueRef::from(ev)
                }
                t => panic!("wrong type {:?} for default value enum", t),
            },
            None => field.singular_runtime_type().default_value_ref(),
        }
    }
}

'''
'''--- protobuf/src/reflect/field/mod.rs ---
use std::fmt;

use crate::descriptor::field_descriptor_proto;
use crate::descriptor::FieldDescriptorProto;
use crate::message_dyn::MessageDyn;
use crate::reflect::acc::v2::map::MapFieldAccessorHolder;
use crate::reflect::acc::v2::repeated::RepeatedFieldAccessorHolder;
use crate::reflect::acc::v2::singular::SingularFieldAccessorHolder;
use crate::reflect::acc::v2::AccessorV2;
use crate::reflect::acc::GeneratedFieldAccessor;
use crate::reflect::dynamic::DynamicMessage;
use crate::reflect::field::dynamic::DynamicFieldDescriptorRef;
use crate::reflect::field::index::FieldIndex;
use crate::reflect::field::index::FieldKind;
use crate::reflect::field::protobuf_field_type::ProtobufFieldType;
use crate::reflect::field::runtime_field_type::RuntimeFieldType;
use crate::reflect::map::ReflectMapMut;
use crate::reflect::map::ReflectMapRef;
use crate::reflect::message::message_ref::MessageRef;
use crate::reflect::message::MessageDescriptorImplRef;
use crate::reflect::oneof::OneofDescriptor;
use crate::reflect::protobuf_type_box::ProtobufType;
use crate::reflect::reflect_eq::ReflectEq;
use crate::reflect::reflect_eq::ReflectEqMode;
use crate::reflect::repeated::ReflectRepeatedMut;
use crate::reflect::repeated::ReflectRepeatedRef;
use crate::reflect::value::value_ref::ReflectValueMut;
use crate::reflect::FileDescriptor;
use crate::reflect::MessageDescriptor;
use crate::reflect::ReflectOptionalRef;
use crate::reflect::ReflectValueBox;
use crate::reflect::ReflectValueRef;
use crate::reflect::RuntimeType;

pub(crate) mod dynamic;
pub(crate) mod index;
pub(crate) mod protobuf_field_type;
pub(crate) mod runtime_field_type;

/// Reference to a value stored in a field, optional, repeated or map.
#[derive(PartialEq)]
pub enum ReflectFieldRef<'a> {
    /// Singular field, optional or required in proto3 and just plain field in proto3
    Optional(ReflectOptionalRef<'a>),
    /// Repeated field
    Repeated(ReflectRepeatedRef<'a>),
    /// Map field
    Map(ReflectMapRef<'a>),
}

impl<'a> ReflectFieldRef<'a> {
    pub(crate) fn default_for_field(field: &FieldDescriptor) -> ReflectFieldRef<'a> {
        match field.runtime_field_type() {
            RuntimeFieldType::Singular(elem) => {
                ReflectFieldRef::Optional(ReflectOptionalRef::none(elem))
            }
            RuntimeFieldType::Repeated(elem) => {
                ReflectFieldRef::Repeated(ReflectRepeatedRef::new_empty(elem))
            }
            RuntimeFieldType::Map(k, v) => ReflectFieldRef::Map(ReflectMapRef::new_empty(k, v)),
        }
    }
}

impl<'a> ReflectEq for ReflectFieldRef<'a> {
    fn reflect_eq(&self, that: &Self, mode: &ReflectEqMode) -> bool {
        match (self, that) {
            (ReflectFieldRef::Optional(a), ReflectFieldRef::Optional(b)) => {
                match (a.value(), b.value()) {
                    (Some(av), Some(bv)) => av.reflect_eq(&bv, mode),
                    (None, None) => true,
                    _ => false,
                }
            }
            (ReflectFieldRef::Repeated(a), ReflectFieldRef::Repeated(b)) => a.reflect_eq(b, mode),
            (ReflectFieldRef::Map(a), ReflectFieldRef::Map(b)) => a.reflect_eq(b, mode),
            _ => false,
        }
    }
}

fn _assert_sync<'a>() {
    fn _assert_send_sync<T: Sync>() {}
    _assert_send_sync::<ReflectFieldRef<'a>>();
}

/// Field descriptor.
///
/// Can be used for runtime reflection.
#[derive(Eq, PartialEq, Clone)]
pub struct FieldDescriptor {
    pub(crate) file_descriptor: FileDescriptor,
    pub(crate) index: usize,
}

impl fmt::Display for FieldDescriptor {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match &self.index().kind {
            FieldKind::MessageField(m) => write!(
                f,
                "{}.{}",
                self.file_descriptor.message_by_index(*m),
                self.name()
            ),
            FieldKind::Extension(Some(m), _) => write!(
                f,
                "{}.{}",
                self.file_descriptor.message_by_index(*m),
                self.name()
            ),
            FieldKind::Extension(None, _) => {
                if self.file_descriptor.proto().package().is_empty() {
                    write!(f, "{}", self.name())
                } else {
                    write!(
                        f,
                        "{}.{}",
                        self.file_descriptor.proto().package(),
                        self.name()
                    )
                }
            }
        }
    }
}

impl FieldDescriptor {
    pub(crate) fn regular(&self) -> (MessageDescriptor, usize) {
        match self.index().kind {
            FieldKind::MessageField(_) => {
                let m = self.containing_message();
                (
                    m.clone(),
                    self.index - m.index().message_index.first_field_index,
                )
            }
            // TODO: implement and remove.
            _ => panic!("regular field"),
        }
    }

    pub(crate) fn file_descriptor(&self) -> &FileDescriptor {
        &self.file_descriptor
    }

    /// Get `.proto` description of field
    pub fn proto(&self) -> &FieldDescriptorProto {
        &self.index().proto
    }

    /// Field name as specified in `.proto` file.
    pub fn name(&self) -> &str {
        self.proto().name()
    }

    /// Field number as specified in `.proto` file.
    pub fn number(&self) -> i32 {
        self.proto().number()
    }

    /// Fully qualified name of the field: fully qualified name of the declaring type
    /// followed by the field name.
    ///
    /// Declaring type is a message (for regular field or extensions) or a package
    /// (for top-level extensions).
    pub fn full_name(&self) -> String {
        self.to_string()
    }

    /// Oneof descriptor containing this field. Do not skip synthetic oneofs.
    pub fn containing_oneof_including_synthetic(&self) -> Option<OneofDescriptor> {
        if let FieldKind::MessageField(..) = self.index().kind {
            let proto = self.proto();
            if proto.has_oneof_index() {
                Some(OneofDescriptor {
                    file_descriptor: self.file_descriptor().clone(),
                    index: self.containing_message().index().oneofs.start
                        + proto.oneof_index() as usize,
                })
            } else {
                None
            }
        } else {
            None
        }
    }

    /// Oneof containing this field.
    ///
    /// Return `None` if this field is not part of oneof or if it is synthetic oneof.
    pub fn containing_oneof(&self) -> Option<OneofDescriptor> {
        self.containing_oneof_including_synthetic()
            .filter(|o| !o.is_synthetic())
    }

    /// Message which declares this field (for extension, **not** the message we extend).
    fn _declaring_message(&self) -> Option<MessageDescriptor> {
        match &self.index().kind {
            FieldKind::MessageField(m) => Some(self.file_descriptor.message_by_index(*m)),
            FieldKind::Extension(m, _) => Some(self.file_descriptor.message_by_index(*m.as_ref()?)),
        }
    }

    /// Message which contains this field.
    ///
    /// For extension fields, this is the message being extended.
    pub fn containing_message(&self) -> MessageDescriptor {
        match &self.index().kind {
            FieldKind::MessageField(m) => self.file_descriptor().message_by_index(*m),
            FieldKind::Extension(_, extendee) => extendee.resolve_message(self.file_descriptor()),
        }
    }

    fn index(&self) -> &FieldIndex {
        &self.file_descriptor.common().fields[self.index]
    }

    fn index_with_message_lifetime<'a>(&self, m: &'a dyn MessageDyn) -> &'a FieldIndex {
        let (descriptor, index) = self.regular();
        let file_fields = match self.singular() {
            SingularFieldAccessorRef::Generated(..) => {
                &descriptor
                    .file_descriptor
                    .common_for_generated_descriptor()
                    .fields
            }
            SingularFieldAccessorRef::Dynamic(..) => {
                &DynamicMessage::downcast_ref(m)
                    .descriptor()
                    .file_descriptor
                    .common()
                    .fields
            }
        };
        &descriptor.index().message_index.slice_fields(file_fields)[index]
    }

    /// JSON field name.
    ///
    /// Can be different from `.proto` field name.
    ///
    /// See [JSON mapping][json] for details.
    ///
    /// [json]: https://developers.google.com/protocol-buffers/docs/proto3#json
    pub fn json_name(&self) -> &str {
        &self.index().json_name
    }

    /// If this field is optional or required.
    pub fn is_singular(&self) -> bool {
        match self.proto().label() {
            field_descriptor_proto::Label::LABEL_REQUIRED => true,
            field_descriptor_proto::Label::LABEL_OPTIONAL => true,
            field_descriptor_proto::Label::LABEL_REPEATED => false,
        }
    }

    /// Is this field required.
    pub fn is_required(&self) -> bool {
        self.proto().label() == field_descriptor_proto::Label::LABEL_REQUIRED
    }

    /// If this field repeated or map?
    pub fn is_repeated_or_map(&self) -> bool {
        self.proto().label() == field_descriptor_proto::Label::LABEL_REPEATED
    }

    /// Is this field repeated, but not map field?
    pub fn is_repeated(&self) -> bool {
        match self.runtime_field_type() {
            RuntimeFieldType::Repeated(..) => true,
            _ => false,
        }
    }

    fn get_impl(&self) -> FieldDescriptorImplRef {
        let (descriptor, index) = self.regular();
        match descriptor.get_impl() {
            MessageDescriptorImplRef::Generated(g) => {
                FieldDescriptorImplRef::Generated(&g.non_map().fields[index].accessor)
            }
            MessageDescriptorImplRef::Dynamic => {
                FieldDescriptorImplRef::Dynamic(DynamicFieldDescriptorRef { field: self })
            }
        }
    }

    /// If this field a map field?
    pub fn is_map(&self) -> bool {
        match self.runtime_field_type() {
            RuntimeFieldType::Map(..) => true,
            _ => false,
        }
    }

    /// Check if field is set in given message.
    ///
    /// For repeated field or map field return `true` if
    /// collection is not empty.
    ///
    /// # Panics
    ///
    /// If this field belongs to a different message type.
    pub fn has_field(&self, m: &dyn MessageDyn) -> bool {
        match self.get_reflect(m) {
            ReflectFieldRef::Optional(v) => v.value().is_some(),
            ReflectFieldRef::Repeated(r) => !r.is_empty(),
            ReflectFieldRef::Map(m) => !m.is_empty(),
        }
    }

    // accessors

    fn singular(&self) -> SingularFieldAccessorRef {
        match self.get_impl() {
            FieldDescriptorImplRef::Generated(GeneratedFieldAccessor::V2(
                AccessorV2::Singular(ref a),
            )) => SingularFieldAccessorRef::Generated(a),
            FieldDescriptorImplRef::Generated(GeneratedFieldAccessor::V2(..)) => {
                panic!("not a singular field: {}", self)
            }
            FieldDescriptorImplRef::Dynamic(d) => SingularFieldAccessorRef::Dynamic(d),
        }
    }

    fn repeated(&self) -> RepeatedFieldAccessorRef {
        match self.get_impl() {
            FieldDescriptorImplRef::Generated(GeneratedFieldAccessor::V2(
                AccessorV2::Repeated(ref a),
            )) => RepeatedFieldAccessorRef::Generated(a),
            FieldDescriptorImplRef::Generated(GeneratedFieldAccessor::V2(..)) => {
                panic!("not a repeated field: {}", self)
            }
            FieldDescriptorImplRef::Dynamic(d) => RepeatedFieldAccessorRef::Dynamic(d),
        }
    }

    fn map(&self) -> MapFieldAccessorRef {
        match self.get_impl() {
            FieldDescriptorImplRef::Generated(GeneratedFieldAccessor::V2(AccessorV2::Map(
                ref a,
            ))) => MapFieldAccessorRef::Generated(a),
            FieldDescriptorImplRef::Generated(GeneratedFieldAccessor::V2(..)) => {
                panic!("not a map field: {}", self)
            }
            FieldDescriptorImplRef::Dynamic(d) => MapFieldAccessorRef::Dynamic(d),
        }
    }

    /// Obtain type of map key and value.
    pub(crate) fn map_proto_type(&self) -> (ProtobufType, ProtobufType) {
        match self.protobuf_field_type() {
            ProtobufFieldType::Map(k, v) => (k, v),
            _ => panic!("not a map field: {}", self),
        }
    }

    /// Get message field or default instance if field is unset.
    ///
    /// # Panics
    /// If this field belongs to a different message type or
    /// field type is not message.
    pub fn get_message<'a>(&self, m: &'a dyn MessageDyn) -> MessageRef<'a> {
        match self.get_singular_field_or_default(m) {
            ReflectValueRef::Message(m) => m,
            _ => panic!("not message field: {}", self),
        }
    }

    /// Get a mutable reference to a message field.
    /// Initialize field with default message if unset.
    ///
    /// # Panics
    ///
    /// If this field belongs to a different message type or
    /// field type is not singular message.
    pub fn mut_message<'a>(&self, m: &'a mut dyn MessageDyn) -> &'a mut dyn MessageDyn {
        match self.mut_singular_field_or_default(m) {
            ReflectValueMut::Message(m) => m,
        }
    }

    /// Default value.
    ///
    /// # Panics
    ///
    /// If field is not singular.
    pub fn singular_default_value(&self) -> ReflectValueRef {
        self.index().default_value(self)
    }

    /// Get singular field value.
    ///
    /// Return field default value if field is unset.
    ///
    /// # Panics
    ///
    /// If this field belongs to a different message type or fields is not singular.
    pub fn get_singular_field_or_default<'a>(&self, m: &'a dyn MessageDyn) -> ReflectValueRef<'a> {
        match self.get_singular(m) {
            Some(m) => m,
            None => self.index_with_message_lifetime(m).default_value(self),
        }
    }

    // Not public because it is not implemented for all types
    fn mut_singular_field_or_default<'a>(&self, m: &'a mut dyn MessageDyn) -> ReflectValueMut<'a> {
        match self.singular() {
            SingularFieldAccessorRef::Generated(g) => g.accessor.mut_field_or_default(m),
            SingularFieldAccessorRef::Dynamic(..) => {
                DynamicMessage::downcast_mut(m).mut_singular_field_or_default(self)
            }
        }
    }

    /// Runtime representation of singular field.
    ///
    /// # Panics
    ///
    /// If this field belongs to a different message type or field is not singular.
    pub fn singular_runtime_type(&self) -> RuntimeType {
        match self.runtime_field_type() {
            RuntimeFieldType::Singular(s) => s,
            _ => panic!("Not a singular field: {}", self),
        }
    }

    /// Set singular field.
    ///
    /// # Panics
    ///
    /// If this field belongs to a different message type or
    /// field is not singular or value is of different type.
    pub fn set_singular_field(&self, m: &mut dyn MessageDyn, value: ReflectValueBox) {
        match self.singular() {
            SingularFieldAccessorRef::Generated(g) => g.accessor.set_field(m, value),
            SingularFieldAccessorRef::Dynamic(d) => d.set_field(m, value),
        }
    }

    /// Clear a field.
    pub fn clear_field(&self, m: &mut dyn MessageDyn) {
        if self.is_singular() {
            match self.singular() {
                SingularFieldAccessorRef::Generated(g) => g.accessor.clear_field(m),
                SingularFieldAccessorRef::Dynamic(d) => d.clear_field(m),
            }
        } else if self.is_repeated() {
            self.mut_repeated(m).clear();
        } else if self.is_map() {
            self.mut_map(m).clear();
        }
    }

    /// Dynamic representation of field type with wire type.
    pub(crate) fn protobuf_field_type(&self) -> ProtobufFieldType {
        self.index().field_type.resolve(self.file_descriptor())
    }

    /// Dynamic representation of field type.
    pub fn runtime_field_type(&self) -> RuntimeFieldType {
        self.protobuf_field_type().runtime()
    }

    /// Get field of any type.
    ///
    /// # Panics
    ///
    /// If this field belongs to a different message type.
    pub fn get_reflect<'a>(&self, m: &'a dyn MessageDyn) -> ReflectFieldRef<'a> {
        match self.get_impl() {
            FieldDescriptorImplRef::Generated(g) => g.get_reflect(m),
            FieldDescriptorImplRef::Dynamic(d) => d.get_reflect(m),
        }
    }

    /// Get singular field value.
    ///
    /// Return `None` if field is unset.
    ///
    /// # Panics
    ///
    /// If this field belongs to a different message type or fields is not singular.
    pub fn get_singular<'a>(&self, m: &'a dyn MessageDyn) -> Option<ReflectValueRef<'a>> {
        match self.get_reflect(m) {
            ReflectFieldRef::Optional(o) => o.value(),
            _ => panic!("not a singular field"),
        }
    }

    // repeated

    /// Get repeated field.
    ///
    /// # Panics
    ///
    /// If this field belongs to a different message type or field is not repeated.
    pub fn get_repeated<'a>(&self, m: &'a dyn MessageDyn) -> ReflectRepeatedRef<'a> {
        match self.get_reflect(m) {
            ReflectFieldRef::Repeated(r) => r,
            _ => panic!("not a repeated field"),
        }
    }

    /// Get a mutable reference to `repeated` field.
    ///
    /// # Panics
    ///
    /// If this field belongs to a different message type or field is not `repeated`.
    pub fn mut_repeated<'a>(&self, m: &'a mut dyn MessageDyn) -> ReflectRepeatedMut<'a> {
        match self.repeated() {
            RepeatedFieldAccessorRef::Generated(g) => g.accessor.mut_repeated(m),
            RepeatedFieldAccessorRef::Dynamic(d) => d.mut_repeated(m),
        }
    }

    // map

    /// Get `map` field.
    ///
    /// # Panics
    ///
    /// If this field belongs to a different message type or field is not `map`.
    pub fn get_map<'a>(&self, m: &'a dyn MessageDyn) -> ReflectMapRef<'a> {
        match self.get_reflect(m) {
            ReflectFieldRef::Map(m) => m,
            _ => panic!("not a map field"),
        }
    }

    /// Get a mutable reference to `map` field.
    ///
    /// # Panics
    ///
    /// If this field belongs to a different message type or field is not `map`.
    pub fn mut_map<'a>(&self, m: &'a mut dyn MessageDyn) -> ReflectMapMut<'a> {
        match self.map() {
            MapFieldAccessorRef::Generated(g) => g.accessor.mut_reflect(m),
            MapFieldAccessorRef::Dynamic(d) => d.mut_map(m),
        }
    }
}

enum SingularFieldAccessorRef<'a> {
    Generated(&'a SingularFieldAccessorHolder),
    Dynamic(DynamicFieldDescriptorRef<'a>),
}

enum RepeatedFieldAccessorRef<'a> {
    Generated(&'a RepeatedFieldAccessorHolder),
    Dynamic(DynamicFieldDescriptorRef<'a>),
}

enum MapFieldAccessorRef<'a> {
    Generated(&'a MapFieldAccessorHolder),
    Dynamic(DynamicFieldDescriptorRef<'a>),
}

pub(crate) enum FieldDescriptorImplRef<'a> {
    Generated(&'static GeneratedFieldAccessor),
    Dynamic(DynamicFieldDescriptorRef<'a>),
}

#[cfg(test)]
mod test {
    use std::collections::HashMap;

    use crate::descriptor::DescriptorProto;
    use crate::reflect::ReflectValueBox;
    use crate::well_known_types::struct_::Struct;
    use crate::well_known_types::struct_::Value;
    use crate::MessageFull;

    #[test]
    #[cfg_attr(miri, ignore)]
    fn display() {
        let field = DescriptorProto::descriptor()
            .field_by_name("enum_type")
            .unwrap();
        assert_eq!(
            "google.protobuf.DescriptorProto.enum_type",
            field.to_string()
        );
    }
}

'''
'''--- protobuf/src/reflect/field/protobuf_field_type.rs ---
use crate::reflect::protobuf_type_box::ProtobufType;
use crate::reflect::RuntimeFieldType;

/// Reflective representation of field type plus wire type.
pub(crate) enum ProtobufFieldType {
    /// Singular field (required, optional for proto2 or singular for proto3)
    Singular(ProtobufType),
    /// Repeated field
    Repeated(ProtobufType),
    /// Map field
    Map(ProtobufType, ProtobufType),
}

impl ProtobufFieldType {
    /// Drop wire type from the type.
    pub fn runtime(&self) -> RuntimeFieldType {
        match self {
            ProtobufFieldType::Singular(t) => RuntimeFieldType::Singular(t.runtime().clone()),
            ProtobufFieldType::Repeated(t) => RuntimeFieldType::Repeated(t.runtime().clone()),
            ProtobufFieldType::Map(kt, vt) => {
                RuntimeFieldType::Map(kt.runtime().clone(), vt.runtime().clone())
            }
        }
    }
}

'''
'''--- protobuf/src/reflect/field/runtime_field_type.rs ---
use crate::reflect::RuntimeType;

/// Reflective representation of field type.
pub enum RuntimeFieldType {
    /// Singular field (required, optional for proto2 or singular for proto3)
    Singular(RuntimeType),
    /// Repeated field
    Repeated(RuntimeType),
    /// Map field
    Map(RuntimeType, RuntimeType),
}

'''
'''--- protobuf/src/reflect/file/building.rs ---
use std::collections::HashMap;
use std::iter;

use crate::descriptor::field_descriptor_proto;
use crate::descriptor::DescriptorProto;
use crate::descriptor::EnumDescriptorProto;
use crate::descriptor::FieldDescriptorProto;
use crate::descriptor::FileDescriptorProto;
use crate::reflect::error::ReflectError;
use crate::reflect::field::index::ForwardProtobufFieldType;
use crate::reflect::field::index::ForwardProtobufTypeBox;
use crate::reflect::file::index::MessageIndices;
use crate::reflect::find_message_or_enum::find_message_or_enum;
use crate::reflect::find_message_or_enum::MessageOrEnum;
use crate::reflect::name::protobuf_name_starts_with_package;
use crate::reflect::runtime_type_box::RuntimeType;
use crate::reflect::FileDescriptor;

pub(crate) struct FileDescriptorBuilding<'a> {
    pub(crate) current_file_descriptor: &'a FileDescriptorProto,
    pub(crate) deps_with_public: &'a [FileDescriptor],
    pub(crate) message_by_name_to_package: &'a HashMap<String, usize>,
    pub(crate) messages: &'a [MessageIndices],
    pub(crate) enums_by_name_to_package: &'a HashMap<String, usize>,
}

impl<'a> FileDescriptorBuilding<'a> {
    fn all_descriptors(&self) -> impl Iterator<Item = &'a FileDescriptorProto> {
        iter::once(self.current_file_descriptor)
            .chain(self.deps_with_public.iter().map(|d| d.proto()))
    }

    pub fn find_enum(&self, full_name: &str) -> &'a EnumDescriptorProto {
        assert!(full_name.starts_with("."));

        for file in self.all_descriptors() {
            if let Some(name_to_package) =
                protobuf_name_starts_with_package(full_name, file.package())
            {
                if let Some((_, me)) = find_message_or_enum(file, name_to_package) {
                    match me {
                        MessageOrEnum::Enum(e) => return e,
                        MessageOrEnum::Message(_) => panic!("not an enum: {}", full_name),
                    }
                }
            }
        }

        panic!(
            "enum not found: {}, in files: {}",
            full_name,
            self.all_files_str()
        );
    }

    fn all_files_str(&self) -> String {
        self.all_descriptors()
            .map(|d| d.name())
            .collect::<Vec<_>>()
            .join(", ")
    }

    pub(crate) fn resolve_field_type(
        &self,
        field: &FieldDescriptorProto,
    ) -> crate::Result<ForwardProtobufFieldType> {
        Ok(match field.label() {
            field_descriptor_proto::Label::LABEL_OPTIONAL
            | field_descriptor_proto::Label::LABEL_REQUIRED => {
                ForwardProtobufFieldType::Singular(self.resolve_field_element_type(field)?)
            }
            field_descriptor_proto::Label::LABEL_REPEATED => {
                let element = self.resolve_field_element_type(field)?;
                let type_proto = match &element {
                    ForwardProtobufTypeBox::CurrentFileMessage(m) => {
                        Some(&*self.messages[*m].proto)
                    }
                    ForwardProtobufTypeBox::ProtobufTypeBox(t) => match t.runtime() {
                        RuntimeType::Message(m) => Some(m.proto()),
                        _ => None,
                    },
                    _ => None,
                };
                match type_proto {
                    Some(m) if m.options.get_or_default().map_entry() => self.map_field(m)?,
                    _ => ForwardProtobufFieldType::Repeated(element),
                }
            }
        })
    }

    fn resolve_field_element_type(
        &self,
        field: &FieldDescriptorProto,
    ) -> crate::Result<ForwardProtobufTypeBox> {
        Ok(match field.type_() {
            field_descriptor_proto::Type::TYPE_MESSAGE
            | field_descriptor_proto::Type::TYPE_GROUP => {
                self.resolve_message(field.type_name())?
            }
            field_descriptor_proto::Type::TYPE_ENUM => {
                if let Some(name_to_package) = protobuf_name_starts_with_package(
                    field.type_name(),
                    self.current_file_descriptor.package(),
                ) {
                    if let Some(index) = self.enums_by_name_to_package.get(name_to_package) {
                        return Ok(ForwardProtobufTypeBox::CurrentFileEnum(*index));
                    }
                }
                for dep in self.deps_with_public {
                    if let Some(m) = dep.enum_by_full_name(field.type_name()) {
                        return Ok(ForwardProtobufTypeBox::enumeration(m));
                    }
                }
                panic!(
                    "enum not found: {}; files: {}",
                    field.type_name(),
                    self.all_files_str()
                );
            }
            t => ForwardProtobufTypeBox::from_proto_type(t),
        })
    }

    pub(crate) fn resolve_message(&self, type_name: &str) -> crate::Result<ForwardProtobufTypeBox> {
        if let Some(name_to_package) =
            protobuf_name_starts_with_package(type_name, self.current_file_descriptor.package())
        {
            if let Some(index) = self.message_by_name_to_package.get(name_to_package) {
                return Ok(ForwardProtobufTypeBox::CurrentFileMessage(*index));
            }
        }
        for dep in self.deps_with_public {
            if let Some(m) = dep.message_by_full_name(type_name) {
                return Ok(ForwardProtobufTypeBox::message(m));
            }
        }
        Err(ReflectError::MessageNotFoundInFiles(type_name.to_owned(), self.all_files_str()).into())
    }

    fn map_field(&self, type_proto: &DescriptorProto) -> crate::Result<ForwardProtobufFieldType> {
        assert!(type_proto.name().ends_with("Entry"));

        assert_eq!(0, type_proto.extension.len());
        assert_eq!(0, type_proto.extension_range.len());
        assert_eq!(0, type_proto.nested_type.len());
        assert_eq!(0, type_proto.enum_type.len());

        assert_eq!(2, type_proto.field.len());
        let key = &type_proto.field[0];
        let value = &type_proto.field[1];

        assert_eq!("key", key.name());
        assert_eq!("value", value.name());

        assert_eq!(1, key.number());
        assert_eq!(2, value.number());

        assert_eq!(field_descriptor_proto::Label::LABEL_OPTIONAL, key.label());
        assert_eq!(field_descriptor_proto::Label::LABEL_OPTIONAL, value.label());

        // It is OK to resolve using current descriptor because map field
        // should always point to the same file.
        let key = self.resolve_field_element_type(key)?;
        let value = self.resolve_field_element_type(value)?;
        Ok(ForwardProtobufFieldType::Map(key, value))
    }
}

'''
'''--- protobuf/src/reflect/file/dynamic.rs ---
use std::collections::HashMap;
use std::sync::Arc;

use crate::descriptor::FileDescriptorProto;
use crate::owning_ref::OwningRef;
use crate::reflect::error::ReflectError;
use crate::reflect::file::index::FileDescriptorCommon;
use crate::reflect::FileDescriptor;

#[derive(Debug)]
pub(crate) struct DynamicFileDescriptor {
    pub(crate) proto: Arc<FileDescriptorProto>,
    pub(crate) common: FileDescriptorCommon,
}

impl DynamicFileDescriptor {
    pub(crate) fn new(
        proto: FileDescriptorProto,
        dependencies: &[FileDescriptor],
    ) -> crate::Result<DynamicFileDescriptor> {
        // Remove undeclared dependencies.
        let dependencies_index: HashMap<_, &FileDescriptor> =
            dependencies.iter().map(|d| (d.proto().name(), d)).collect();

        if dependencies_index.len() != dependencies.len() {
            return Err(ReflectError::NonUniqueDependencies(
                dependencies
                    .iter()
                    .map(|d| d.proto().name())
                    .collect::<Vec<_>>()
                    .join(", "),
            )
            .into());
        }

        let dependencies: Vec<FileDescriptor> = proto
            .dependency
            .iter()
            .map(|d| {
                let dep = dependencies_index.get(d.as_str());
                match dep {
                    Some(dep) => Ok((*dep).clone()),
                    None => Err(ReflectError::DependencyNotFound(
                        d.clone(),
                        proto.name().to_owned(),
                        dependencies
                            .iter()
                            .map(|d| d.proto().name())
                            .collect::<Vec<_>>()
                            .join(", "),
                    )
                    .into()),
                }
            })
            .collect::<crate::Result<Vec<_>>>()?;

        let proto = Arc::new(proto);

        let common = FileDescriptorCommon::new(OwningRef::new_arc(proto.clone()), dependencies)?;

        Ok(DynamicFileDescriptor { proto, common })
    }
}

'''
'''--- protobuf/src/reflect/file/fds.rs ---
use std::collections::HashMap;
use std::collections::HashSet;
use std::mem;

use protobuf_support::toposort::toposort;

use crate::descriptor::FileDescriptorProto;
use crate::reflect::error::ReflectError;
use crate::reflect::FileDescriptor;

pub(crate) fn build_fds(
    protos: Vec<FileDescriptorProto>,
    dependencies: &[FileDescriptor],
) -> crate::Result<Vec<FileDescriptor>> {
    let mut index_by_name: HashMap<&str, usize> = HashMap::new();
    for (i, proto) in protos.iter().enumerate() {
        let prev = index_by_name.insert(proto.name(), i);
        if prev.is_some() {
            return Err(ReflectError::NonUniqueFileDescriptor(proto.name().to_owned()).into());
        }
    }

    let sorted = match toposort(0..protos.len(), |&i| {
        protos[i]
            .dependency
            .iter()
            .filter_map(|d| index_by_name.get(d.as_str()).copied())
    }) {
        Ok(s) => s,
        Err(_) => return Err(ReflectError::CycleInFileDescriptors.into()),
    };

    let mut built_descriptors_by_index = vec![None; protos.len()];

    let mut protos: Vec<Option<FileDescriptorProto>> = protos.into_iter().map(Some).collect();

    let mut all_descriptors = dependencies.to_vec();
    for f in sorted {
        let proto = mem::take(&mut protos[f]).unwrap();
        let d = FileDescriptor::new_dynamic(proto, &all_descriptors)?;
        all_descriptors.push(d.clone());
        built_descriptors_by_index[f] = Some(d);
    }

    Ok(built_descriptors_by_index
        .into_iter()
        .map(Option::unwrap)
        .collect())
}

pub(crate) fn fds_extend_with_public(file_descriptors: Vec<FileDescriptor>) -> Vec<FileDescriptor> {
    let mut visited = HashSet::new();

    let mut r = Vec::new();
    let mut stack = file_descriptors;
    stack.reverse();

    while let Some(f) = stack.pop() {
        if !visited.insert(f.proto().name().to_owned()) {
            continue;
        }

        stack.extend(f.public_deps());

        r.push(f);
    }
    r
}

'''
'''--- protobuf/src/reflect/file/generated.rs ---
use std::collections::HashMap;
use std::fmt;
use std::fmt::Formatter;

use crate::descriptor::FileDescriptorProto;
use crate::owning_ref::OwningRef;
use crate::reflect::enums::generated::GeneratedEnumDescriptor;
use crate::reflect::file::index::FileDescriptorCommon;
use crate::reflect::message::generated::GeneratedMessageDescriptor;
use crate::reflect::oneof::generated::GeneratedOneofDescriptor;
use crate::reflect::FileDescriptor;
use crate::reflect::GeneratedEnumDescriptorData;
use crate::reflect::GeneratedMessageDescriptorData;

/// Reflection for objects defined in `.proto` file (messages, enums, etc).
#[doc(hidden)]
pub struct GeneratedFileDescriptor {
    pub(crate) proto: &'static FileDescriptorProto,
    pub(crate) messages: Vec<GeneratedMessageDescriptor>,
    pub(crate) enums: Vec<GeneratedEnumDescriptor>,
    pub(crate) oneofs: Vec<GeneratedOneofDescriptor>,
    pub(crate) common: FileDescriptorCommon,
}

impl fmt::Debug for GeneratedFileDescriptor {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        f.debug_struct("GeneratedFileDescriptor")
            .field("proto.name", &self.proto.name())
            .finish_non_exhaustive()
    }
}

impl GeneratedFileDescriptor {
    /// This function is called from generated code.
    pub fn new_generated(
        file_descriptor_proto: &'static FileDescriptorProto,
        dependencies: Vec<FileDescriptor>,
        messages: Vec<GeneratedMessageDescriptorData>,
        enums: Vec<GeneratedEnumDescriptorData>,
    ) -> GeneratedFileDescriptor {
        let common =
            FileDescriptorCommon::new(OwningRef::new_static(file_descriptor_proto), dependencies)
                .unwrap();

        let mut messages: HashMap<&str, GeneratedMessageDescriptorData> = messages
            .into_iter()
            .map(|m| (m.protobuf_name_to_package, m))
            .collect();

        let mut enums: HashMap<&str, GeneratedEnumDescriptorData> =
            enums.into_iter().map(|e| (e.name_in_file, e)).collect();

        let mut oneofs = Vec::new();
        for oneof in &common.oneofs {
            let message = &common.messages[oneof.containing_message];
            let message_proto = &message.proto;
            let oneof_proto = &message_proto.oneof_decl[oneof.index_in_containing_message];
            let message = messages.get(message.name_to_package.as_str()).unwrap();
            let oneof_data = &message.oneofs.iter().find(|o| o.name == oneof_proto.name());
            if oneof.synthetic {
                assert!(oneof_data.is_none());
                oneofs.push(GeneratedOneofDescriptor::new_synthetic())
            } else {
                let oneof = GeneratedOneofDescriptor::new(oneof_data.unwrap());
                oneofs.push(oneof);
            }
        }

        let messages = common
            .messages
            .iter()
            .map(|message_index| {
                if message_index.proto.options.map_entry() {
                    GeneratedMessageDescriptor::new_map_entry()
                } else {
                    let message = messages
                        .remove(message_index.name_to_package.as_str())
                        .unwrap();
                    GeneratedMessageDescriptor::new(message, file_descriptor_proto, &common)
                }
            })
            .collect();

        let enums = common
            .enums
            .iter()
            .map(|enum_index| {
                let en = enums.remove(enum_index.name_to_package.as_str()).unwrap();
                GeneratedEnumDescriptor::new(en, file_descriptor_proto)
            })
            .collect();

        GeneratedFileDescriptor {
            proto: file_descriptor_proto,
            messages,
            enums,
            oneofs,
            common,
        }
    }
}

'''
'''--- protobuf/src/reflect/file/index.rs ---
use std::collections::HashMap;
use std::ops::Range;

use crate::descriptor::field_descriptor_proto::Label;
use crate::descriptor::DescriptorProto;
use crate::descriptor::EnumDescriptorProto;
use crate::descriptor::FileDescriptorProto;
use crate::owning_ref::OwningRef;
use crate::reflect::error::ReflectError;
use crate::reflect::field::index::FieldIndex;
use crate::reflect::file::building::FileDescriptorBuilding;
use crate::reflect::file::fds::fds_extend_with_public;
use crate::reflect::message::is_initialized_is_always_true::compute_is_initialized_is_always_true;
use crate::reflect::name::concat_paths;
use crate::reflect::service::index::ServiceIndex;
use crate::reflect::FileDescriptor;

#[derive(Debug)]
pub(crate) struct MessageIndices {
    pub(crate) proto: OwningRef<FileDescriptorProto, DescriptorProto>,
    pub(crate) name_to_package: String,
    pub(crate) full_name: String,
    pub(crate) enclosing_message: Option<usize>,
    pub(crate) nested_messages: Vec<usize>,
    pub(crate) nested_enums: Range<usize>,
    pub(crate) oneofs: Range<usize>,
    pub(crate) map_entry: bool,
    pub(crate) message_index: MessageFieldIndices,
    pub(crate) is_initialized_is_always_true: bool,
}

#[derive(Debug, Default)]
pub(crate) struct MessageFieldIndices {
    /// Index of the first field in global field index.
    pub(crate) first_field_index: usize,
    pub(crate) field_count: usize,
    /// Extensions follow fields in global field index.
    pub(crate) extension_count: usize,
    // Following fields map to the local field index.
    pub(crate) field_index_by_name: HashMap<String, usize>,
    pub(crate) field_index_by_name_or_json_name: HashMap<String, usize>,
    pub(crate) field_index_by_number: HashMap<u32, usize>,
}

impl MessageFieldIndices {
    pub(crate) fn regular_field_range(&self) -> Range<usize> {
        self.first_field_index..(self.first_field_index + self.field_count)
    }

    pub(crate) fn extension_field_range(&self) -> Range<usize> {
        self.first_field_index + self.field_count
            ..self.first_field_index + self.field_count + self.extension_count
    }

    pub(crate) fn slice_fields<'a>(&self, file_fields: &'a [FieldIndex]) -> &'a [FieldIndex] {
        &file_fields[self.first_field_index..self.first_field_index + self.field_count]
    }
}

#[derive(Debug)]
pub(crate) struct EnumIndices {
    pub(crate) proto: OwningRef<FileDescriptorProto, EnumDescriptorProto>,
    pub(crate) name_to_package: String,
    pub(crate) full_name: String,
    pub(crate) enclosing_message: Option<usize>,
    pub(crate) index_by_name: HashMap<String, usize>,
    pub(crate) index_by_number: HashMap<i32, usize>,
}

impl EnumIndices {
    pub(crate) fn new(
        name_to_package: String,
        enclosing_message: Option<usize>,
        proto: OwningRef<FileDescriptorProto, EnumDescriptorProto>,
        file: &FileDescriptorProto,
    ) -> EnumIndices {
        let mut index_by_name = HashMap::new();
        let mut index_by_number = HashMap::new();
        for (i, v) in proto.value.iter().enumerate() {
            index_by_number.insert(v.number(), i);
            index_by_name.insert(v.name().to_owned(), i);
        }
        let full_name = concat_paths(file.package(), &name_to_package);
        EnumIndices {
            proto,
            full_name,
            name_to_package,
            enclosing_message,
            index_by_name,
            index_by_number,
        }
    }
}

#[derive(Debug)]
pub(crate) struct OneofIndices {
    pub(crate) containing_message: usize,
    pub(crate) index_in_containing_message: usize,
    /// Synthetic oneof for proto3 optional field.
    pub(crate) synthetic: bool,
    pub(crate) fields: Vec<usize>,
}

/// Common `FileDescriptor` data for generated and dynamic file descriptors.
#[derive(Debug)]
pub(crate) struct FileDescriptorCommon {
    /// Direct dependencies of this file.
    pub(crate) dependencies: Vec<FileDescriptor>,
    /// All messages in this file.
    pub(crate) messages: Vec<MessageIndices>,
    pub(crate) message_by_name_to_package: HashMap<String, usize>,
    pub(crate) top_level_messages: Vec<usize>,
    pub(crate) enums: Vec<EnumIndices>,
    pub(crate) enums_by_name_to_package: HashMap<String, usize>,
    pub(crate) oneofs: Vec<OneofIndices>,
    pub(crate) services: Vec<ServiceIndex>,
    pub(crate) first_extension_field_index: usize,
    /// All fields followed by file-level extensions.
    pub(crate) fields: Vec<FieldIndex>,
}

impl FileDescriptorCommon {
    pub(crate) fn extension_field_range(&self) -> Range<usize> {
        self.first_extension_field_index..self.fields.len()
    }

    pub(crate) fn new(
        file: OwningRef<FileDescriptorProto, FileDescriptorProto>,
        dependencies: Vec<FileDescriptor>,
    ) -> crate::Result<FileDescriptorCommon> {
        let deps_with_public = fds_extend_with_public(dependencies.clone());

        let mut messages = Vec::new();
        let mut enums = Vec::new();
        let mut oneofs = Vec::new();
        let mut top_level_messages = Vec::new();

        // Top-level enums start with zero
        for e in file.flat_map_slice(|f| &f.enum_type) {
            enums.push(EnumIndices::new(e.name().to_owned(), None, e, file.owner()));
        }

        for message in file.flat_map_slice(|f| &f.message_type) {
            let message_index = Self::index_message_and_inners(
                file.owner(),
                message,
                None,
                "",
                &mut messages,
                &mut enums,
                &mut oneofs,
            )?;
            top_level_messages.push(message_index);
        }

        let message_by_name_to_package = Self::build_message_by_name_to_package(&messages);
        let enums_by_name_to_package = Self::build_enum_by_name_to_package(&enums);

        let mut services = Vec::new();

        for service in &file.service {
            let service_index = ServiceIndex::index(
                service,
                &FileDescriptorBuilding {
                    current_file_descriptor: file.owner(),
                    deps_with_public: &deps_with_public,
                    message_by_name_to_package: &message_by_name_to_package,
                    messages: &messages,
                    enums_by_name_to_package: &enums_by_name_to_package,
                },
            )?;
            services.push(service_index);
        }

        let mut fields = Vec::new();

        Self::build_message_index(
            file.owner(),
            &deps_with_public,
            &mut messages,
            &mut fields,
            &message_by_name_to_package,
            &enums_by_name_to_package,
        )?;

        let first_extension_field_index = fields.len();
        for ext in file.flat_map_slice(|f| &f.extension) {
            fields.push(FieldIndex::index(
                None,
                ext,
                &FileDescriptorBuilding {
                    current_file_descriptor: file.owner(),
                    deps_with_public: &deps_with_public,
                    message_by_name_to_package: &message_by_name_to_package,
                    messages: &messages,
                    enums_by_name_to_package: &enums_by_name_to_package,
                },
            )?);
        }

        compute_is_initialized_is_always_true(&mut messages, &fields, file.owner());

        Ok(FileDescriptorCommon {
            dependencies,
            messages,
            message_by_name_to_package,
            enums,
            top_level_messages,
            enums_by_name_to_package,
            oneofs,
            services,
            first_extension_field_index,
            fields,
        })
    }

    fn is_map_entry(message: &DescriptorProto) -> crate::Result<bool> {
        // Must be consistent with
        // DescriptorBuilder::ValidateMapEntry

        if !message.options.map_entry() {
            return Ok(false);
        }

        if !message.name().ends_with("Entry") {
            return Err(ReflectError::MapEntryNameMustEndWithEntry.into());
        }
        if !message.extension.is_empty()
            || !message.extension_range.is_empty()
            || !message.nested_type.is_empty()
            || !message.enum_type.is_empty()
        {
            return Err(ReflectError::MapEntryMustHaveNo.into());
        }

        if message.field.len() != 2 {
            return Err(ReflectError::MapEntryIncorrectFields.into());
        }

        let key = &message.field[0];
        let value = &message.field[1];

        if key.number() != 1
            || key.name() != "key"
            || key.label() != Label::LABEL_OPTIONAL
            || value.number() != 2
            || value.name() != "value"
            || value.label() != Label::LABEL_OPTIONAL
        {
            return Err(ReflectError::MapEntryIncorrectFields.into());
        }

        Ok(true)
    }

    fn index_message_and_inners(
        file: &FileDescriptorProto,
        message: OwningRef<FileDescriptorProto, DescriptorProto>,
        parent: Option<usize>,
        parent_name_to_package: &str,
        messages: &mut Vec<MessageIndices>,
        enums: &mut Vec<EnumIndices>,
        oneofs: &mut Vec<OneofIndices>,
    ) -> crate::Result<usize> {
        let name_to_package = concat_paths(parent_name_to_package, message.name());

        let message_index = messages.len();
        messages.push(MessageIndices {
            proto: message.clone(),
            full_name: concat_paths(file.package(), &name_to_package),
            name_to_package: name_to_package.clone(),
            enclosing_message: parent,
            nested_messages: Vec::with_capacity(message.nested_type.len()),
            nested_enums: enums.len()..enums.len() + message.enum_type.len(),
            oneofs: oneofs.len()..oneofs.len() + message.oneof_decl.len(),
            message_index: MessageFieldIndices::default(),
            map_entry: Self::is_map_entry(&message)?,
            // Initialized later.
            is_initialized_is_always_true: false,
        });

        for e in message.flat_map_slice(|m| &m.enum_type) {
            enums.push(EnumIndices::new(
                concat_paths(&name_to_package, e.name()),
                Some(message_index),
                e,
                file,
            ));
        }

        for (i, _oneof) in message.oneof_decl.iter().enumerate() {
            let fields: Vec<_> = message
                .field
                .iter()
                .enumerate()
                .filter(|(_, f)| f.has_oneof_index() && f.oneof_index() == i as i32)
                .collect();
            let synthetic = fields.len() == 1 && fields[0].1.proto3_optional();
            oneofs.push(OneofIndices {
                containing_message: message_index,
                index_in_containing_message: i,
                synthetic,
                fields: fields.iter().map(|(i, _)| *i).collect(),
            });
        }

        for nested in message.flat_map_slice(|m| &m.nested_type) {
            let nested_index = Self::index_message_and_inners(
                file,
                nested,
                Some(message_index),
                &name_to_package,
                messages,
                enums,
                oneofs,
            )?;
            messages[message_index].nested_messages.push(nested_index);
        }

        Ok(message_index)
    }

    fn build_message_by_name_to_package(messages: &[MessageIndices]) -> HashMap<String, usize> {
        messages
            .iter()
            .enumerate()
            .map(|(i, m)| (m.name_to_package.to_owned(), i))
            .collect()
    }

    fn build_enum_by_name_to_package(enums: &[EnumIndices]) -> HashMap<String, usize> {
        enums
            .iter()
            .enumerate()
            .map(|(i, e)| (e.name_to_package.to_owned(), i))
            .collect()
    }

    fn build_message_index(
        file: &FileDescriptorProto,
        deps_with_public: &[FileDescriptor],
        messages: &mut [MessageIndices],
        fields: &mut Vec<FieldIndex>,
        message_by_name_to_package: &HashMap<String, usize>,
        enums_by_name_to_package: &HashMap<String, usize>,
    ) -> crate::Result<()> {
        for i in 0..messages.len() {
            let message_proto = &messages[i].proto;
            let building = FileDescriptorBuilding {
                current_file_descriptor: file,
                deps_with_public,
                message_by_name_to_package,
                messages,
                enums_by_name_to_package,
            };
            let message_index = Self::index_message(i, message_proto, &building, fields)?;
            messages[i].message_index = message_index;
        }
        Ok(())
    }

    fn index_message(
        message_index: usize,
        proto: &OwningRef<FileDescriptorProto, DescriptorProto>,
        building: &FileDescriptorBuilding,
        fields: &mut Vec<FieldIndex>,
    ) -> crate::Result<MessageFieldIndices> {
        let mut index_by_name = HashMap::new();
        let mut index_by_name_or_json_name = HashMap::new();
        let mut index_by_number = HashMap::new();

        let first_field_index = fields.len();

        for field in proto.flat_map_slice(|m| &m.field) {
            fields.push(FieldIndex::index(Some(message_index), field, building)?);
        }

        let field_count = proto.field.len();

        for (i, f) in proto.field.iter().enumerate() {
            let field_index = &fields[first_field_index + i];

            if index_by_number.insert(f.number() as u32, i).is_some() {
                return Err(ReflectError::NonUniqueFieldName(f.name().to_owned()).into());
            }
            if index_by_name.insert(f.name().to_owned(), i).is_some() {
                return Err(ReflectError::NonUniqueFieldName(f.name().to_owned()).into());
            }
            if index_by_name_or_json_name
                .insert(f.name().to_owned(), i)
                .is_some()
            {
                return Err(ReflectError::NonUniqueFieldName(f.name().to_owned()).into());
            }

            if field_index.json_name != f.name() {
                if index_by_name_or_json_name
                    .insert(field_index.json_name.clone(), i)
                    .is_some()
                {
                    return Err(ReflectError::NonUniqueFieldName(f.name().to_owned()).into());
                }
            }
        }

        for ext in proto.flat_map_slice(|m| &m.extension) {
            fields.push(FieldIndex::index(Some(message_index), ext, building)?);
        }

        let extension_count = proto.extension.len();

        Ok(MessageFieldIndices {
            first_field_index,
            field_count,
            extension_count,
            field_index_by_name: index_by_name,
            field_index_by_name_or_json_name: index_by_name_or_json_name,
            field_index_by_number: index_by_number,
        })
    }
}

'''
'''--- protobuf/src/reflect/file/mod.rs ---
use std::collections::HashSet;
use std::hash::Hash;
use std::hash::Hasher;
use std::sync::Arc;

use crate::descriptor::DescriptorProto;
use crate::descriptor::FileDescriptorProto;
use crate::reflect::file::dynamic::DynamicFileDescriptor;
use crate::reflect::file::fds::build_fds;
use crate::reflect::file::index::EnumIndices;
use crate::reflect::file::index::FileDescriptorCommon;
use crate::reflect::file::index::MessageIndices;
use crate::reflect::name::protobuf_name_starts_with_package;
use crate::reflect::service::ServiceDescriptor;
use crate::reflect::EnumDescriptor;
use crate::reflect::FieldDescriptor;
use crate::reflect::GeneratedFileDescriptor;
use crate::reflect::MessageDescriptor;
use crate::reflect::Syntax;

pub(crate) mod building;
pub(crate) mod dynamic;
pub(crate) mod fds;
pub(crate) mod generated;
pub(crate) mod index;
pub(crate) mod syntax;

#[derive(Clone, Debug)]
pub(crate) enum FileDescriptorImpl {
    Generated(&'static GeneratedFileDescriptor),
    Dynamic(Arc<DynamicFileDescriptor>),
}

impl PartialEq for FileDescriptorImpl {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (FileDescriptorImpl::Generated(a), FileDescriptorImpl::Generated(b)) => {
                *a as *const GeneratedFileDescriptor == *b as *const GeneratedFileDescriptor
            }
            (FileDescriptorImpl::Dynamic(a), FileDescriptorImpl::Dynamic(b)) => Arc::ptr_eq(a, b),
            _ => false,
        }
    }
}

impl Hash for FileDescriptorImpl {
    fn hash<H: Hasher>(&self, state: &mut H) {
        match self {
            FileDescriptorImpl::Generated(g) => {
                Hash::hash(&(*g as *const GeneratedFileDescriptor), state)
            }
            FileDescriptorImpl::Dynamic(a) => {
                Hash::hash(&(&**a as *const DynamicFileDescriptor), state)
            }
        }
    }
}

impl Eq for FileDescriptorImpl {}

/// Reflection for objects defined in `.proto` file (messages, enums, etc).
///
/// The object is refcounted: clone is shallow.
///
/// The equality performs pointer comparison: two clones of the same `FileDescriptor`
/// objects are equal, but two `FileDescriptor` objects created from the same `FileDescriptorProto`
/// objects are **not** equal.
#[derive(Clone, PartialEq, Eq, Hash, Debug)]
pub struct FileDescriptor {
    pub(crate) imp: FileDescriptorImpl,
}

impl FileDescriptor {
    pub(crate) fn common(&self) -> &FileDescriptorCommon {
        match &self.imp {
            FileDescriptorImpl::Generated(g) => &g.common,
            FileDescriptorImpl::Dynamic(d) => &d.common,
        }
    }

    /// Same as `common`, but returns `&'static`.
    pub(crate) fn common_for_generated_descriptor(&self) -> &'static FileDescriptorCommon {
        match &self.imp {
            FileDescriptorImpl::Generated(g) => &g.common,
            FileDescriptorImpl::Dynamic(..) => panic!("not generated"),
        }
    }

    pub(crate) fn message_indices(&self, index: usize) -> &MessageIndices {
        &self.common().messages[index]
    }

    pub(crate) fn message_by_index(&self, index: usize) -> MessageDescriptor {
        MessageDescriptor {
            file_descriptor: self.clone(),
            index,
        }
    }

    pub(crate) fn message_proto_by_index(&self, index: usize) -> &DescriptorProto {
        &self.common().messages[index].proto
    }

    pub(crate) fn enum_indices(&self, index: usize) -> &EnumIndices {
        &self.common().enums[index]
    }

    /// The file name.
    pub fn name(&self) -> &str {
        self.proto().name()
    }

    /// Protobuf package.
    pub fn package(&self) -> &str {
        self.proto().package()
    }

    /// Syntax of current file.
    pub fn syntax(&self) -> Syntax {
        Syntax::parse(self.proto().syntax()).unwrap_or(Syntax::Proto2)
    }

    /// Top-level messages.
    pub fn messages(&self) -> impl Iterator<Item = MessageDescriptor> + '_ {
        self.common()
            .top_level_messages
            .iter()
            .map(|i| MessageDescriptor::new(self.clone(), *i))
    }

    /// Get top-level enums.
    pub fn enums(&self) -> impl Iterator<Item = EnumDescriptor> + '_ {
        self.proto()
            .enum_type
            .iter()
            .enumerate()
            .map(|(i, _)| EnumDescriptor::new(self.clone(), i))
    }

    /// Get services defined in `.proto` file.
    pub fn services(&self) -> impl Iterator<Item = ServiceDescriptor> + '_ {
        self.proto()
            .service
            .iter()
            .enumerate()
            .map(|(i, _)| ServiceDescriptor::new(self.clone(), i))
    }

    /// Extension fields.
    pub fn extensions(&self) -> impl Iterator<Item = FieldDescriptor> + '_ {
        self.common()
            .extension_field_range()
            .map(move |index| FieldDescriptor {
                file_descriptor: self.clone(),
                index,
            })
    }

    /// Find message by name relative to the package.
    ///
    /// Only search in the current file, not in any dependencies.
    pub fn message_by_package_relative_name(&self, name: &str) -> Option<MessageDescriptor> {
        self.common()
            .message_by_name_to_package
            .get(name)
            .map(|&index| MessageDescriptor::new(self.clone(), index))
    }

    /// Find message by name relative to the package.
    ///
    /// Only search in the current file, not in any dependencies.
    pub fn enum_by_package_relative_name(&self, name: &str) -> Option<EnumDescriptor> {
        self.common()
            .enums_by_name_to_package
            .get(name)
            .map(|&index| EnumDescriptor::new(self.clone(), index))
    }

    /// Find message by fully-qualified name.
    ///
    /// Only search in the current file, not in any dependencies.
    pub fn message_by_full_name(&self, name: &str) -> Option<MessageDescriptor> {
        if let Some(name_to_package) =
            protobuf_name_starts_with_package(name, self.proto().package())
        {
            self.message_by_package_relative_name(name_to_package)
        } else {
            None
        }
    }

    /// Find enum by name fully-qualified name.
    ///
    /// Only search in the current file, not in any dependencies.
    pub fn enum_by_full_name(&self, name: &str) -> Option<EnumDescriptor> {
        if let Some(name_to_package) =
            protobuf_name_starts_with_package(name, self.proto().package())
        {
            self.enum_by_package_relative_name(name_to_package)
        } else {
            None
        }
    }

    /// This function is called from generated code, it is not stable, and should not be called.
    #[doc(hidden)]
    pub fn new_generated_2(generated: &'static GeneratedFileDescriptor) -> FileDescriptor {
        FileDescriptor {
            imp: FileDescriptorImpl::Generated(generated),
        }
    }

    /// Dynamic message created from [`FileDescriptorProto`] without generated files.
    pub fn new_dynamic(
        proto: FileDescriptorProto,
        dependencies: &[FileDescriptor],
    ) -> crate::Result<FileDescriptor> {
        Ok(FileDescriptor {
            imp: FileDescriptorImpl::Dynamic(Arc::new(DynamicFileDescriptor::new(
                proto,
                dependencies,
            )?)),
        })
    }

    /// Create a set of file descriptors from individual file descriptors.
    pub fn new_dynamic_fds(
        protos: Vec<FileDescriptorProto>,
        dependencies: &[FileDescriptor],
    ) -> crate::Result<Vec<FileDescriptor>> {
        build_fds(protos, dependencies)
    }

    /// `.proto` data for this file.
    pub fn proto(&self) -> &FileDescriptorProto {
        match &self.imp {
            FileDescriptorImpl::Generated(g) => &g.proto,
            FileDescriptorImpl::Dynamic(d) => &d.proto,
        }
    }

    /// Direct dependencies of this file.
    pub fn deps(&self) -> &[FileDescriptor] {
        &self.common().dependencies
    }

    /// Subset of dependencies which are public
    pub fn public_deps(&self) -> impl Iterator<Item = FileDescriptor> + '_ {
        self.proto()
            .public_dependency
            .iter()
            .map(|&i| self.deps()[i as usize].clone())
    }

    fn _all_files(&self) -> Vec<&FileDescriptor> {
        let mut r = Vec::new();
        let mut visited = HashSet::new();

        let mut stack = Vec::new();
        stack.push(self);
        while let Some(file) = stack.pop() {
            if !visited.insert(file) {
                continue;
            }

            r.push(file);
            stack.extend(file.deps());
        }

        r
    }
}

#[cfg(test)]
mod test {
    use crate::descriptor;

    #[test]
    #[cfg_attr(miri, ignore)]
    fn eq() {
        assert!(descriptor::file_descriptor() == &descriptor::file_descriptor().clone());
    }
}

'''
'''--- protobuf/src/reflect/file/syntax.rs ---
use crate::descriptor::FileDescriptorProto;

/// `.proto` file syntax.
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum Syntax {
    /// `syntax = "proto2"`.
    Proto2,
    /// `syntax = "proto3"`.
    Proto3,
}

impl Syntax {
    pub(crate) fn parse(syntax: &str) -> Option<Syntax> {
        match syntax {
            "" | "proto2" => Some(Syntax::Proto2),
            "proto3" => Some(Syntax::Proto3),
            _ => None,
        }
    }

    pub(crate) fn of_file(file: &FileDescriptorProto) -> Syntax {
        Syntax::parse(file.syntax()).unwrap_or(Syntax::Proto2)
    }
}

'''
'''--- protobuf/src/reflect/find_message_or_enum.rs ---
use crate::descriptor::DescriptorProto;
use crate::descriptor::EnumDescriptorProto;
use crate::descriptor::FileDescriptorProto;

pub(crate) enum MessageOrEnum<'a> {
    Message(&'a DescriptorProto),
    Enum(&'a EnumDescriptorProto),
}

impl<'a> MessageOrEnum<'a> {
    fn from_two_options(
        m: Option<&'a DescriptorProto>,
        e: Option<&'a EnumDescriptorProto>,
    ) -> Option<MessageOrEnum<'a>> {
        match (m, e) {
            (Some(_), Some(_)) => panic!("enum and message with the same name"),
            (Some(m), None) => Some(MessageOrEnum::Message(m)),
            (None, Some(e)) => Some(MessageOrEnum::Enum(e)),
            (None, None) => None,
        }
    }
}

pub(crate) fn find_message_or_enum<'a>(
    file: &'a FileDescriptorProto,
    name_to_package: &str,
) -> Option<(String, MessageOrEnum<'a>)> {
    assert!(!name_to_package.starts_with("."));
    assert!(!name_to_package.is_empty());

    let mut path = name_to_package.split('.');
    let first = path.next().unwrap();
    let child_message = file.message_type.iter().find(|m| m.name() == first);
    let child_enum = file.enum_type.iter().find(|e| e.name() == first);

    let mut package_to_name = String::new();
    let mut me = MessageOrEnum::from_two_options(child_message, child_enum)?;

    for name in path {
        let message = match me {
            MessageOrEnum::Message(m) => m,
            MessageOrEnum::Enum(_) => panic!("enum has no children"),
        };

        if !package_to_name.is_empty() {
            package_to_name.push_str(".");
        }
        package_to_name.push_str(message.name());

        let child_message = message.nested_type.iter().find(|m| m.name() == name);
        let child_enum = message.enum_type.iter().find(|e| e.name() == name);
        me = MessageOrEnum::from_two_options(child_message, child_enum)?;
    }

    Some((package_to_name, me))
}

'''
'''--- protobuf/src/reflect/map/empty.rs ---
use std::fmt;

use crate::reflect::map::ReflectMapIter;
use crate::reflect::map::ReflectMapIterTrait;
use crate::reflect::ReflectValueRef;
use crate::reflect::RuntimeType;

#[derive(Clone)]
pub(crate) struct DynamicEmptyMap {
    key_type: RuntimeType,
    value_type: RuntimeType,
}

impl DynamicEmptyMap {
    pub(crate) fn new(key_type: RuntimeType, value_type: RuntimeType) -> DynamicEmptyMap {
        Self {
            key_type,
            value_type,
        }
    }

    pub(crate) fn len(&self) -> usize {
        0
    }

    pub(crate) fn is_empty(&self) -> bool {
        true
    }

    pub(crate) fn get<'a>(&'a self, _key: ReflectValueRef) -> Option<ReflectValueRef<'a>> {
        None
    }

    pub(crate) fn key_type(&self) -> RuntimeType {
        self.key_type.clone()
    }

    pub(crate) fn value_type(&self) -> RuntimeType {
        self.value_type.clone()
    }

    pub(crate) fn reflect_iter(&self) -> ReflectMapIter {
        ReflectMapIter::new(DynamicEmptyMapIter {
            key_type: self.key_type.clone(),
            value_type: self.value_type.clone(),
        })
    }
}

impl fmt::Debug for DynamicEmptyMap {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.debug_map().finish()
    }
}

struct DynamicEmptyMapIter {
    key_type: RuntimeType,
    value_type: RuntimeType,
}

impl<'a> ReflectMapIterTrait<'a> for DynamicEmptyMapIter {
    fn next(&mut self) -> Option<(ReflectValueRef<'a>, ReflectValueRef<'a>)> {
        None
    }

    fn key_type(&self) -> RuntimeType {
        self.key_type.clone()
    }

    fn value_type(&self) -> RuntimeType {
        self.value_type.clone()
    }
}

'''
'''--- protobuf/src/reflect/map/generated.rs ---
use std::collections::hash_map;
use std::collections::HashMap;
use std::hash::Hash;

use crate::reflect::map::ReflectMap;
use crate::reflect::map::ReflectMapIter;
use crate::reflect::map::ReflectMapIterTrait;
use crate::reflect::runtime_types::RuntimeTypeHashable;
use crate::reflect::runtime_types::RuntimeTypeTrait;
use crate::reflect::ProtobufValue;
use crate::reflect::ReflectValueBox;
use crate::reflect::ReflectValueRef;
use crate::reflect::RuntimeType;

impl<K, V> ReflectMap for HashMap<K, V>
where
    K: ProtobufValue + Eq + Hash,
    V: ProtobufValue,
    K::RuntimeType: RuntimeTypeHashable,
{
    fn reflect_iter<'a>(&'a self) -> ReflectMapIter<'a> {
        ReflectMapIter::new(GeneratedMapIterImpl::<'a, K, V> { iter: self.iter() })
    }

    fn len(&self) -> usize {
        HashMap::len(self)
    }

    fn is_empty(&self) -> bool {
        self.is_empty()
    }

    fn get<'a>(&'a self, key: ReflectValueRef) -> Option<ReflectValueRef<'a>> {
        <K::RuntimeType as RuntimeTypeHashable>::hash_map_get(self, key).map(V::RuntimeType::as_ref)
    }

    fn insert(&mut self, key: ReflectValueBox, value: ReflectValueBox) {
        let key: K = key.downcast().expect("wrong key type");
        let value: V = value.downcast().expect("wrong value type");
        self.insert(key, value);
    }

    fn clear(&mut self) {
        self.clear();
    }

    fn key_type(&self) -> RuntimeType {
        K::RuntimeType::runtime_type_box()
    }

    fn value_type(&self) -> RuntimeType {
        V::RuntimeType::runtime_type_box()
    }
}

struct GeneratedMapIterImpl<'a, K: Eq + Hash + 'static, V: 'static> {
    iter: hash_map::Iter<'a, K, V>,
}

impl<'a, K: ProtobufValue + Eq + Hash, V: ProtobufValue> ReflectMapIterTrait<'a>
    for GeneratedMapIterImpl<'a, K, V>
{
    fn next(&mut self) -> Option<(ReflectValueRef<'a>, ReflectValueRef<'a>)> {
        match self.iter.next() {
            Some((k, v)) => Some((K::RuntimeType::as_ref(k), V::RuntimeType::as_ref(v))),
            None => None,
        }
    }

    fn key_type(&self) -> RuntimeType {
        K::RuntimeType::runtime_type_box()
    }

    fn value_type(&self) -> RuntimeType {
        V::RuntimeType::runtime_type_box()
    }
}

'''
'''--- protobuf/src/reflect/map/mod.rs ---
use std::fmt;
use std::fmt::Debug;
use std::fmt::Formatter;

use crate::reflect::map::empty::DynamicEmptyMap;
use crate::reflect::reflect_eq::ReflectEq;
use crate::reflect::reflect_eq::ReflectEqMode;
use crate::reflect::ReflectValueBox;
use crate::reflect::ReflectValueRef;
use crate::reflect::RuntimeType;

mod empty;
mod generated;

/// Implemented for `HashMap` with appropriate keys and values
pub(crate) trait ReflectMap: Debug + Send + Sync + 'static {
    fn reflect_iter(&self) -> ReflectMapIter;

    fn len(&self) -> usize;

    fn is_empty(&self) -> bool;

    fn get<'a>(&'a self, key: ReflectValueRef) -> Option<ReflectValueRef<'a>>;

    fn insert(&mut self, key: ReflectValueBox, value: ReflectValueBox);

    fn clear(&mut self);

    fn key_type(&self) -> RuntimeType;

    fn value_type(&self) -> RuntimeType;
}

pub(crate) trait ReflectMapIterTrait<'a> {
    fn next(&mut self) -> Option<(ReflectValueRef<'a>, ReflectValueRef<'a>)>;
    fn key_type(&self) -> RuntimeType;
    fn value_type(&self) -> RuntimeType;
}

pub struct ReflectMapIter<'a> {
    imp: Box<dyn ReflectMapIterTrait<'a> + 'a>,
}

impl<'a> ReflectMapIter<'a> {
    pub(crate) fn new<I: ReflectMapIterTrait<'a> + 'a>(imp: I) -> ReflectMapIter<'a> {
        ReflectMapIter { imp: Box::new(imp) }
    }
}

impl<'a> Iterator for ReflectMapIter<'a> {
    type Item = (ReflectValueRef<'a>, ReflectValueRef<'a>);

    fn next(&mut self) -> Option<(ReflectValueRef<'a>, ReflectValueRef<'a>)> {
        self.imp.next()
    }
}

impl<'a> IntoIterator for &'a dyn ReflectMap {
    type Item = (ReflectValueRef<'a>, ReflectValueRef<'a>);
    type IntoIter = ReflectMapIter<'a>;

    fn into_iter(self) -> Self::IntoIter {
        self.reflect_iter()
    }
}

#[derive(Clone)]
enum ReflectMapRefImpl<'a> {
    Generated(&'a dyn ReflectMap),
    DynamicEmpty(DynamicEmptyMap),
}

impl<'a> fmt::Debug for ReflectMapRefImpl<'a> {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        match self {
            ReflectMapRefImpl::Generated(m) => fmt::Debug::fmt(m, f),
            ReflectMapRefImpl::DynamicEmpty(m) => fmt::Debug::fmt(m, f),
        }
    }
}

/// Dynamic reference to `map` field
#[derive(Clone)]
pub struct ReflectMapRef<'a> {
    imp: ReflectMapRefImpl<'a>,
}

/// Dynamic mutable reference to `map` field
pub struct ReflectMapMut<'a> {
    map: &'a mut dyn ReflectMap,
}

impl<'a> fmt::Debug for ReflectMapRef<'a> {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        fmt::Debug::fmt(&self.imp, f)
    }
}

impl<'a> fmt::Debug for ReflectMapMut<'a> {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        fmt::Debug::fmt(&self.map, f)
    }
}

impl<'a> ReflectMapRef<'a> {
    pub(crate) fn new(map: &'a dyn ReflectMap) -> ReflectMapRef<'a> {
        ReflectMapRef {
            imp: ReflectMapRefImpl::Generated(map),
        }
    }

    pub(crate) fn new_empty(key: RuntimeType, value: RuntimeType) -> ReflectMapRef<'a> {
        ReflectMapRef {
            imp: ReflectMapRefImpl::DynamicEmpty(DynamicEmptyMap::new(key, value)),
        }
    }

    /// Size of the map
    pub fn len(&self) -> usize {
        match &self.imp {
            ReflectMapRefImpl::Generated(map) => map.len(),
            ReflectMapRefImpl::DynamicEmpty(map) => map.len(),
        }
    }

    /// Is map empty?
    pub fn is_empty(&self) -> bool {
        match &self.imp {
            ReflectMapRefImpl::Generated(map) => map.is_empty(),
            ReflectMapRefImpl::DynamicEmpty(map) => map.is_empty(),
        }
    }

    /// Find a value by given key.
    pub fn get(&self, key: ReflectValueRef) -> Option<ReflectValueRef> {
        match &self.imp {
            ReflectMapRefImpl::Generated(map) => map.get(key),
            ReflectMapRefImpl::DynamicEmpty(map) => map.get(key),
        }
    }

    /// Map key type
    pub fn key_type(&self) -> RuntimeType {
        match &self.imp {
            ReflectMapRefImpl::Generated(map) => map.key_type(),
            ReflectMapRefImpl::DynamicEmpty(map) => map.key_type(),
        }
    }

    /// Map value type
    pub fn value_type(&self) -> RuntimeType {
        match &self.imp {
            ReflectMapRefImpl::Generated(map) => map.value_type(),
            ReflectMapRefImpl::DynamicEmpty(map) => map.value_type(),
        }
    }
}

impl<'a> PartialEq for ReflectMapRef<'a> {
    fn eq(&self, other: &Self) -> bool {
        self.reflect_eq(other, &ReflectEqMode::default())
    }
}

impl<'a> ReflectEq for ReflectMapRef<'a> {
    fn reflect_eq(&self, that: &Self, mode: &ReflectEqMode) -> bool {
        let len = self.len();

        if len != that.len() {
            return false;
        }

        if self.key_type() != that.key_type() {
            return false;
        }
        if self.value_type() != that.value_type() {
            return false;
        }

        for (k, va) in self {
            let vb = match that.get(k) {
                Some(v) => v,
                None => return false,
            };

            if !va.reflect_eq(&vb, mode) {
                return false;
            }
        }

        true
    }
}

impl<'a> ReflectMapMut<'a> {
    pub(crate) fn new(map: &'a mut dyn ReflectMap) -> ReflectMapMut<'a> {
        ReflectMapMut { map }
    }

    fn as_ref(&'a self) -> ReflectMapRef<'a> {
        ReflectMapRef::new(self.map)
    }

    /// Map key type
    pub fn key_type(&self) -> RuntimeType {
        self.map.key_type()
    }

    /// Map value type
    pub fn value_type(&self) -> RuntimeType {
        self.map.value_type()
    }

    /// Number of map entries
    pub fn len(&self) -> usize {
        self.as_ref().len()
    }

    /// Is this map empty?
    pub fn is_empty(&self) -> bool {
        self.as_ref().is_empty()
    }

    /// Find a value for given key
    pub fn get(&self, key: ReflectValueRef) -> Option<ReflectValueRef> {
        self.map.get(key)
    }

    /// Insert a value into the map.
    ///
    /// # Panics
    ///
    /// If given key has an incompatible key type.
    pub fn insert(&mut self, key: ReflectValueBox, value: ReflectValueBox) {
        self.map.insert(key, value)
    }

    /// Clear
    pub fn clear(&mut self) {
        self.map.clear();
    }
}

/// Iterator over map
pub struct ReflectMapRefIter<'a> {
    iter: ReflectMapIter<'a>,
}

impl<'a> ReflectMapRefIter<'a> {
    fn _key_type(&self) -> RuntimeType {
        self.iter.imp.key_type()
    }

    fn _value_type(&self) -> RuntimeType {
        self.iter.imp.value_type()
    }
}

impl<'a> Iterator for ReflectMapRefIter<'a> {
    type Item = (ReflectValueRef<'a>, ReflectValueRef<'a>);

    fn next(&mut self) -> Option<(ReflectValueRef<'a>, ReflectValueRef<'a>)> {
        self.iter.next()
    }
}

impl<'a, 'b: 'a> IntoIterator for &'b ReflectMapRef<'a> {
    type Item = (ReflectValueRef<'a>, ReflectValueRef<'a>);
    type IntoIter = ReflectMapRefIter<'a>;

    fn into_iter(self) -> ReflectMapRefIter<'a> {
        match &self.imp {
            ReflectMapRefImpl::Generated(map) => ReflectMapRefIter {
                iter: map.reflect_iter(),
            },
            ReflectMapRefImpl::DynamicEmpty(map) => ReflectMapRefIter {
                iter: map.reflect_iter(),
            },
        }
    }
}

'''
'''--- protobuf/src/reflect/message/generated.rs ---
//! Generated messages reflection support.

use std::fmt;
use std::marker;

use crate::descriptor::FileDescriptorProto;
use crate::message_dyn::MessageDyn;
use crate::message_full::MessageFull;
use crate::reflect::acc::FieldAccessor;
use crate::reflect::file::index::FileDescriptorCommon;
use crate::reflect::find_message_or_enum::find_message_or_enum;
use crate::reflect::find_message_or_enum::MessageOrEnum;
use crate::reflect::GeneratedOneofDescriptorData;

/// Sized to dynamic reflection operations.
pub(crate) trait MessageFactory: Send + Sync + 'static {
    fn new_instance(&self) -> Box<dyn MessageDyn>;
    fn default_instance(&self) -> &dyn MessageDyn;
    fn clone(&self, message: &dyn MessageDyn) -> Box<dyn MessageDyn>;
    fn eq(&self, a: &dyn MessageDyn, b: &dyn MessageDyn) -> bool;
}

impl<'a> fmt::Debug for &'a dyn MessageFactory {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("MessageFactory").finish()
    }
}

/// The only message factory implementation.
pub(crate) struct MessageFactoryImpl<M>(pub marker::PhantomData<M>);

impl<M> MessageFactory for MessageFactoryImpl<M>
where
    M: MessageFull,
{
    fn new_instance(&self) -> Box<dyn MessageDyn> {
        let m: M = Default::default();
        Box::new(m)
    }

    fn default_instance(&self) -> &dyn MessageDyn {
        M::default_instance() as &dyn MessageDyn
    }

    fn clone(&self, message: &dyn MessageDyn) -> Box<dyn MessageDyn> {
        let m: &M = message.downcast_ref().expect("wrong message type");
        Box::new(m.clone())
    }

    fn eq(&self, a: &dyn MessageDyn, b: &dyn MessageDyn) -> bool {
        let a: &M = a.downcast_ref().expect("wrong message type");
        let b: &M = b.downcast_ref().expect("wrong message type");
        a == b
    }
}

#[doc(hidden)]
pub struct GeneratedMessageDescriptorData {
    pub(crate) protobuf_name_to_package: &'static str,
    pub(crate) fields: Vec<FieldAccessor>,
    pub(crate) factory: &'static dyn MessageFactory,
    pub(crate) oneofs: Vec<GeneratedOneofDescriptorData>,
}

impl GeneratedMessageDescriptorData {
    /// Construct a new message descriptor.
    ///
    /// This operation is called from generated code and rarely
    /// need to be called directly.
    ///
    /// This function is not a part of public API.
    #[doc(hidden)]
    pub fn new_2<M: MessageFull>(
        protobuf_name_to_package: &'static str,
        fields: Vec<FieldAccessor>,
        oneofs: Vec<GeneratedOneofDescriptorData>,
    ) -> GeneratedMessageDescriptorData {
        let factory = &MessageFactoryImpl(marker::PhantomData::<M>);
        GeneratedMessageDescriptorData {
            protobuf_name_to_package,
            fields,
            factory,
            oneofs,
        }
    }
}

#[derive(Debug)]
pub(crate) struct NonMapMessageDescriptor {
    pub(crate) factory: &'static dyn MessageFactory,

    pub(crate) fields: Vec<FieldAccessor>,
}

#[derive(Debug)]
pub(crate) struct GeneratedMessageDescriptor {
    pub(crate) non_map: Option<NonMapMessageDescriptor>,
}

impl GeneratedMessageDescriptor {
    pub(crate) fn new_map_entry() -> GeneratedMessageDescriptor {
        GeneratedMessageDescriptor { non_map: None }
    }

    pub(crate) fn new(
        data: GeneratedMessageDescriptorData,
        file_descriptor_proto: &'static FileDescriptorProto,
        _file_index: &FileDescriptorCommon,
    ) -> GeneratedMessageDescriptor {
        let GeneratedMessageDescriptorData {
            protobuf_name_to_package,
            fields,
            factory,
            oneofs: _,
        } = data;

        let (_path_to_package, _proto) =
            match find_message_or_enum(file_descriptor_proto, protobuf_name_to_package) {
                Some((path_to_package, MessageOrEnum::Message(m))) => (path_to_package, m),
                Some((_, MessageOrEnum::Enum(_))) => panic!("not a message"),
                None => panic!("not found"),
            };

        GeneratedMessageDescriptor {
            non_map: Some(NonMapMessageDescriptor { factory, fields }),
        }
    }

    pub(crate) fn non_map(&self) -> &NonMapMessageDescriptor {
        match &self.non_map {
            Some(non_map) => non_map,
            None => panic!("map message"),
        }
    }
}

'''
'''--- protobuf/src/reflect/message/is_initialized_is_always_true.rs ---
use std::collections::HashMap;
use std::collections::HashSet;

use crate::descriptor::field_descriptor_proto::Label;
use crate::descriptor::FileDescriptorProto;
use crate::reflect::field::index::FieldIndex;
use crate::reflect::field::index::ForwardProtobufFieldType;
use crate::reflect::field::index::ForwardProtobufTypeBox;
use crate::reflect::file::index::MessageIndices;
use crate::reflect::MessageDescriptor;
use crate::reflect::RuntimeType;
use crate::reflect::Syntax;

pub(crate) fn compute_is_initialized_is_always_true(
    messages: &mut [MessageIndices],
    file_fields: &[FieldIndex],
    file: &FileDescriptorProto,
) {
    for message in messages.iter_mut() {
        message.is_initialized_is_always_true =
            is_initialized_is_always_true_ignoring_deps(message, file);
    }

    // Map from a message to messages who include it. E.g. for:
    // ```
    // 0: message A {}
    // 1: message B { A a = 10; }
    // ```
    // This map will contain: `{0: [1]}`
    let mut rdeps: HashMap<usize, Vec<usize>> = HashMap::new();

    for i in 0..messages.len() {
        let message = &mut messages[i];

        if !message.is_initialized_is_always_true {
            continue;
        }

        let mut is_initialized_is_always_true = true;
        for ft in message_field_messages(message, file_fields) {
            match ft {
                MessageType::ThisFile(j) => {
                    rdeps.entry(j).or_default().push(i);
                }
                MessageType::OtherFile(m) => {
                    if !m.is_initialized_is_always_true() {
                        is_initialized_is_always_true = false;
                    }
                }
            }
        }
        message.is_initialized_is_always_true = is_initialized_is_always_true;
    }

    let mut invalidated: HashSet<usize> = HashSet::new();
    let mut invalidate_stack: Vec<usize> = Vec::new();

    for i in 0..messages.len() {
        let message = &messages[i];
        if message.is_initialized_is_always_true {
            continue;
        }

        invalidate_stack.push(i);
    }

    while let Some(i) = invalidate_stack.pop() {
        if !invalidated.insert(i) {
            continue;
        }

        messages[i].is_initialized_is_always_true = false;
        let next = rdeps.get(&i).map(|v| v.as_slice()).unwrap_or_default();
        for next in next {
            invalidate_stack.push(*next);
        }
    }
}

enum MessageType<'m> {
    ThisFile(usize),
    OtherFile(&'m MessageDescriptor),
}

fn message_field_messages<'a>(
    message: &'a MessageIndices,
    file_fields: &'a [FieldIndex],
) -> impl Iterator<Item = MessageType<'a>> + 'a {
    message_field_types(message, file_fields).filter_map(|f| match f {
        ForwardProtobufTypeBox::ProtobufTypeBox(t) => match t.runtime() {
            RuntimeType::Message(m) => Some(MessageType::OtherFile(m)),
            _ => None,
        },
        ForwardProtobufTypeBox::CurrentFileEnum(_) => None,
        ForwardProtobufTypeBox::CurrentFileMessage(i) => Some(MessageType::ThisFile(*i)),
    })
}

fn message_field_types<'a>(
    message: &'a MessageIndices,
    file_fields: &'a [FieldIndex],
) -> impl Iterator<Item = &'a ForwardProtobufTypeBox> {
    enum Either<A, B> {
        Left(A),
        Right(B),
    }

    impl<T, A: Iterator<Item = T>, B: Iterator<Item = T>> Iterator for Either<A, B> {
        type Item = T;

        fn next(&mut self) -> Option<T> {
            match self {
                Either::Left(a) => a.next(),
                Either::Right(b) => b.next(),
            }
        }
    }

    message
        .message_index
        .slice_fields(file_fields)
        .iter()
        .flat_map(|f| match &f.field_type {
            ForwardProtobufFieldType::Singular(t) => Either::Left([t].into_iter()),
            ForwardProtobufFieldType::Repeated(t) => Either::Left([t].into_iter()),
            ForwardProtobufFieldType::Map(k, v) => Either::Right([k, v].into_iter()),
        })
}

fn is_initialized_is_always_true_ignoring_deps(
    message: &MessageIndices,
    file: &FileDescriptorProto,
) -> bool {
    // Shortcut.
    if Syntax::of_file(file) == Syntax::Proto3 {
        return true;
    }

    // We don't support extensions properly but if we did,
    // extensions should have been checked for `is_initialized`.
    if !message.proto.extension_range.is_empty() {
        return false;
    }

    for field in &message.proto.field {
        if field.label() == Label::LABEL_REQUIRED {
            return false;
        }
    }
    true
}

'''
'''--- protobuf/src/reflect/message/message_ref.rs ---
use std::fmt;
use std::ops::Deref;

use crate::message_dyn::MessageDyn;
use crate::reflect::dynamic::DynamicMessage;
use crate::reflect::reflect_eq::ReflectEq;
use crate::reflect::reflect_eq::ReflectEqMode;
use crate::reflect::MessageDescriptor;
use crate::MessageFull;

#[derive(Clone, Debug)]
enum MessageRefImpl<'a> {
    Message(&'a dyn MessageDyn),
    EmptyDynamic(DynamicMessage),
}

/// Wrapper around either [`MessageFull`] reference or a container for an empty dynamic message.
#[derive(Clone, Debug)]
pub struct MessageRef<'a> {
    imp: MessageRefImpl<'a>,
}

impl<'a> fmt::Display for MessageRef<'a> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(self.deref(), f)
    }
}

impl<'a> From<&'a dyn MessageDyn> for MessageRef<'a> {
    fn from(m: &'a dyn MessageDyn) -> Self {
        MessageRef {
            imp: MessageRefImpl::Message(m),
        }
    }
}

impl<'a, M: MessageFull> From<&'a M> for MessageRef<'a> {
    fn from(m: &'a M) -> Self {
        MessageRef {
            imp: MessageRefImpl::Message(m),
        }
    }
}

impl<'a> ReflectEq for MessageRef<'a> {
    fn reflect_eq(&self, that: &Self, mode: &ReflectEqMode) -> bool {
        let ad = self.descriptor_dyn();
        let bd = that.descriptor_dyn();
        ad == bd && ad.reflect_eq(&**self, &**that, mode)
    }
}

impl<'a> MessageRef<'a> {
    /// Wrap a message.
    pub fn new(message: &'a dyn MessageDyn) -> MessageRef<'a> {
        MessageRef {
            imp: MessageRefImpl::Message(message),
        }
    }

    /// Default (empty) instance of given message type.
    pub fn default_instance(message: &MessageDescriptor) -> MessageRef<'static> {
        // Note we create a native generated instance for generated types
        // and dynamic message for dynamic types.
        match message.default_instance() {
            Some(m) => MessageRef::new(m),
            None => MessageRef {
                imp: MessageRefImpl::EmptyDynamic(DynamicMessage::new(message.clone())),
            },
        }
    }
}

impl<'a> Deref for MessageRef<'a> {
    type Target = dyn MessageDyn;

    fn deref(&self) -> &dyn MessageDyn {
        match &self.imp {
            MessageRefImpl::Message(m) => *m,
            MessageRefImpl::EmptyDynamic(e) => e,
        }
    }
}

'''
'''--- protobuf/src/reflect/message/mod.rs ---
use std::fmt;
use std::io::Read;

use crate::descriptor::DescriptorProto;
use crate::descriptor::FileDescriptorProto;
use crate::message_dyn::MessageDyn;
use crate::message_full::MessageFull;
use crate::reflect::dynamic::DynamicMessage;
use crate::reflect::file::index::MessageIndices;
use crate::reflect::file::FileDescriptorImpl;
use crate::reflect::message::generated::GeneratedMessageDescriptor;
use crate::reflect::reflect_eq::ReflectEq;
use crate::reflect::reflect_eq::ReflectEqMode;
use crate::reflect::EnumDescriptor;
use crate::reflect::FieldDescriptor;
use crate::reflect::FileDescriptor;
use crate::reflect::OneofDescriptor;
use crate::CodedInputStream;

pub(crate) mod generated;
pub(crate) mod is_initialized_is_always_true;
pub(crate) mod message_ref;

/// Dynamic representation of message type.
///
/// Used for reflection.
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct MessageDescriptor {
    pub(crate) file_descriptor: FileDescriptor,
    pub(crate) index: usize,
}

impl fmt::Display for MessageDescriptor {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.full_name())
    }
}

impl fmt::Debug for MessageDescriptor {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("MessageDescriptor").finish_non_exhaustive()
    }
}

impl MessageDescriptor {
    pub(crate) fn new(file_descriptor: FileDescriptor, index: usize) -> MessageDescriptor {
        MessageDescriptor {
            file_descriptor,
            index,
        }
    }

    /// Get underlying `DescriptorProto` object.
    pub fn proto(&self) -> &DescriptorProto {
        self.file_descriptor.message_proto_by_index(self.index)
    }

    /// Message name as specified in `.proto` file.
    pub fn name(&self) -> &str {
        self.proto().name()
    }

    fn index_entry(&self) -> &MessageIndices {
        self.file_descriptor.message_indices(self.index)
    }

    /// Get a message descriptor for given message type
    pub fn for_type<M: MessageFull>() -> MessageDescriptor {
        M::descriptor()
    }

    /// Messages declared in this messages.
    pub fn nested_messages(&self) -> impl Iterator<Item = MessageDescriptor> + '_ {
        self.index_entry()
            .nested_messages
            .iter()
            .map(|i| MessageDescriptor::new(self.file_descriptor.clone(), *i))
    }

    /// Get enums declared in this message.
    pub fn nested_enums(&self) -> impl Iterator<Item = EnumDescriptor> + '_ {
        self.index_entry()
            .nested_enums
            .clone()
            .map(|i| EnumDescriptor::new(self.file_descriptor.clone(), i))
    }

    /// Get a message containing this message, or `None` if this message is declared at file level.
    pub fn enclosing_message(&self) -> Option<MessageDescriptor> {
        self.index_entry()
            .enclosing_message
            .map(|i| MessageDescriptor::new(self.file_descriptor.clone(), i))
    }

    pub(crate) fn get_impl(&self) -> MessageDescriptorImplRef {
        match &self.file_descriptor.imp {
            FileDescriptorImpl::Generated(g) => {
                MessageDescriptorImplRef::Generated(&g.messages[self.index])
            }
            FileDescriptorImpl::Dynamic(..) => MessageDescriptorImplRef::Dynamic,
        }
    }

    /// [`FileDescriptor`] containing this message.
    pub fn file_descriptor(&self) -> &FileDescriptor {
        &self.file_descriptor
    }

    /// `FileDescriptorProto` containg this message type
    pub fn file_descriptor_proto(&self) -> &FileDescriptorProto {
        self.file_descriptor().proto()
    }

    /// This message descriptor is a map entry.
    pub fn is_map_entry(&self) -> bool {
        self.index().map_entry
    }

    fn assert_not_map_entry(&self) {
        assert!(
            !self.is_map_entry(),
            "message is map entry: {}",
            self.full_name()
        );
    }

    /// Message is considered always initialized.
    #[doc(hidden)]
    pub fn is_initialized_is_always_true(&self) -> bool {
        self.index().is_initialized_is_always_true
    }

    /// New empty message.
    ///
    /// # Panics
    ///
    /// If this message is a map entry message.
    pub fn new_instance(&self) -> Box<dyn MessageDyn> {
        self.assert_not_map_entry();
        match self.get_impl() {
            MessageDescriptorImplRef::Generated(g) => g.non_map().factory.new_instance(),
            MessageDescriptorImplRef::Dynamic => Box::new(DynamicMessage::new(self.clone())),
        }
    }

    /// Shared immutable empty message.
    ///
    /// Returns `None` for dynamic message.
    ///
    /// # Panics
    ///
    /// If this message is a map entry message.
    pub fn default_instance(&self) -> Option<&'static dyn MessageDyn> {
        self.assert_not_map_entry();
        match self.get_impl() {
            MessageDescriptorImplRef::Generated(g) => Some(g.non_map().factory.default_instance()),
            MessageDescriptorImplRef::Dynamic => None,
        }
    }

    /// Clone a message
    pub(crate) fn clone_message(&self, message: &dyn MessageDyn) -> Box<dyn MessageDyn> {
        assert!(&message.descriptor_dyn() == self);
        match self.get_impl() {
            MessageDescriptorImplRef::Generated(g) => g.non_map().factory.clone(message),
            MessageDescriptorImplRef::Dynamic => {
                let message: &DynamicMessage = DynamicMessage::downcast_ref(message);
                Box::new(message.clone())
            }
        }
    }

    /// Check if two messages equal.
    ///
    /// # Panics
    ///
    /// Is any message has different type than this descriptor.
    pub fn eq(&self, a: &dyn MessageDyn, b: &dyn MessageDyn) -> bool {
        match self.get_impl() {
            MessageDescriptorImplRef::Generated(g) => g.non_map().factory.eq(a, b),
            MessageDescriptorImplRef::Dynamic => unimplemented!(),
        }
    }

    /// Similar to `eq`, but considers `NaN` values equal.
    ///
    /// # Panics
    ///
    /// Is any message has different type than this descriptor.
    pub(crate) fn reflect_eq(
        &self,
        a: &dyn MessageDyn,
        b: &dyn MessageDyn,
        mode: &ReflectEqMode,
    ) -> bool {
        // Explicitly force panic even if field list is empty
        assert_eq!(self, &a.descriptor_dyn());
        assert_eq!(self, &b.descriptor_dyn());

        for field in self.fields() {
            let af = field.get_reflect(a);
            let bf = field.get_reflect(b);
            if !af.reflect_eq(&bf, mode) {
                return false;
            }
        }
        true
    }

    pub(crate) fn reflect_eq_maybe_unrelated(
        a: &dyn MessageDyn,
        b: &dyn MessageDyn,
        mode: &ReflectEqMode,
    ) -> bool {
        let ad = a.descriptor_dyn();
        let bd = b.descriptor_dyn();
        ad == bd && ad.reflect_eq(a, b, mode)
    }

    /// Fully qualified protobuf message name
    pub fn full_name(&self) -> &str {
        &self.index_entry().full_name
    }

    /// Name relative to the package where the message is declared.
    pub fn name_to_package(&self) -> &str {
        &self.index_entry().name_to_package
    }

    /// Nested oneofs including synthetic.
    pub fn all_oneofs<'a>(&'a self) -> impl Iterator<Item = OneofDescriptor> + 'a {
        self.index_entry()
            .oneofs
            .clone()
            .map(move |i| OneofDescriptor {
                file_descriptor: self.file_descriptor.clone(),
                index: i,
            })
    }

    /// Non-synthetic oneofs.
    pub fn oneofs<'a>(&'a self) -> impl Iterator<Item = OneofDescriptor> + 'a {
        self.all_oneofs().filter(|oneof| !oneof.is_synthetic())
    }

    /// Get message oneof by name (**not implemented**).
    pub fn oneof_by_name(&self, name: &str) -> Option<OneofDescriptor> {
        self.all_oneofs().find(|oneof| oneof.name() == name)
    }

    /// Message field descriptors.
    pub fn fields<'a>(&'a self) -> impl Iterator<Item = FieldDescriptor> + 'a {
        self.index()
            .message_index
            .regular_field_range()
            .map(move |index| FieldDescriptor {
                file_descriptor: self.file_descriptor.clone(),
                index,
            })
    }

    /// Extension fields.
    pub fn extensions(&self) -> impl Iterator<Item = FieldDescriptor> + '_ {
        self.index()
            .message_index
            .extension_field_range()
            .map(move |index| FieldDescriptor {
                file_descriptor: self.file_descriptor.clone(),
                index,
            })
    }

    pub(crate) fn index(&self) -> &MessageIndices {
        &self.file_descriptor.common().messages[self.index]
    }

    pub(crate) fn field_by_index(&self, index: usize) -> FieldDescriptor {
        FieldDescriptor {
            file_descriptor: self.file_descriptor.clone(),
            index: self.index().message_index.first_field_index + index,
        }
    }

    /// Find message field by protobuf field name
    ///
    /// Note: protobuf field name might be different for Rust field name.
    // TODO: return value, not pointer, pointer is not compatible with dynamic message
    pub fn field_by_name(&self, name: &str) -> Option<FieldDescriptor> {
        let &index = self.index().message_index.field_index_by_name.get(name)?;
        Some(self.field_by_index(index))
    }

    /// Find message field by field name or field JSON name
    pub fn field_by_name_or_json_name<'a>(&'a self, name: &str) -> Option<FieldDescriptor> {
        let &index = self
            .index()
            .message_index
            .field_index_by_name_or_json_name
            .get(name)?;
        Some(self.field_by_index(index))
    }

    /// Find message field by field name
    pub fn field_by_number(&self, number: u32) -> Option<FieldDescriptor> {
        let &index = self
            .index()
            .message_index
            .field_index_by_number
            .get(&number)?;
        Some(self.field_by_index(index))
    }

    /// Parse message from stream.
    pub fn parse_from(&self, is: &mut CodedInputStream) -> crate::Result<Box<dyn MessageDyn>> {
        let mut r = self.new_instance();
        r.merge_from_dyn(is)?;
        r.check_initialized_dyn()?;
        Ok(r)
    }

    /// Parse message from reader.
    /// Parse stops on EOF or when error encountered.
    pub fn parse_from_reader(&self, reader: &mut dyn Read) -> crate::Result<Box<dyn MessageDyn>> {
        let mut is = CodedInputStream::new(reader);
        let r = self.parse_from(&mut is)?;
        is.check_eof()?;
        Ok(r)
    }

    /// Parse message from byte array.
    pub fn parse_from_bytes(&self, bytes: &[u8]) -> crate::Result<Box<dyn MessageDyn>> {
        let mut is = CodedInputStream::from_bytes(bytes);
        let r = self.parse_from(&mut is)?;
        is.check_eof()?;
        Ok(r)
    }
}

pub(crate) enum MessageDescriptorImplRef {
    Generated(&'static GeneratedMessageDescriptor),
    Dynamic,
}

#[cfg(test)]
mod test {
    use crate::descriptor::descriptor_proto::ExtensionRange;
    use crate::descriptor::field_descriptor_proto::Type;
    use crate::descriptor::DescriptorProto;
    use crate::descriptor::FieldDescriptorProto;
    use crate::EnumFull;
    use crate::MessageFull;

    #[test]
    #[cfg_attr(miri, ignore)] // Too slow on Miri.
    fn nested_messages() {
        assert!(DescriptorProto::descriptor()
            .nested_messages()
            .collect::<Vec<_>>()
            .contains(&ExtensionRange::descriptor()));
    }

    #[test]
    #[cfg_attr(miri, ignore)] // Too slow on Miri.
    fn nested_enums() {
        assert!(FieldDescriptorProto::descriptor()
            .nested_enums()
            .collect::<Vec<_>>()
            .contains(&Type::enum_descriptor()));
    }

    #[test]
    #[cfg_attr(miri, ignore)] // Too slow on Miri.
    fn enclosing_message() {
        assert_eq!(
            Some(DescriptorProto::descriptor()),
            ExtensionRange::descriptor().enclosing_message()
        );
        assert_eq!(None, DescriptorProto::descriptor().enclosing_message());
    }
}

'''
'''--- protobuf/src/reflect/mod.rs ---
//! # Reflection implementation for protobuf data
//!
//! ## Generated vs dynamic
//!
//! rust-protobuf supports reflection for both:
//! * generated messages (generated rust code)
//! * dynamic messages (created from arbitrary `FileDescriptorProto` without code generation)
//!
//! The API to work with these types of messages is the same.
//!
//! ## API
//!
//! The API roughly follows Google protobuf C++ and Java API.
//! Some minor adjustements are made to make code more idiomatic to rust.

mod acc;
mod dynamic;
mod enums;
pub(crate) mod error;
mod field;
mod file;
mod find_message_or_enum;
mod map;
pub(crate) mod message;
mod oneof;
mod optional;
mod protobuf_type_box;
mod repeated;
mod runtime_type_box;
mod service;
mod type_dynamic;
pub(crate) mod value;

// Runtime type types are public, but not visible in public API.
pub(crate) mod runtime_types;

pub(crate) mod types;

pub(crate) mod reflect_eq;

pub mod rt;

pub(crate) mod name;

#[doc(hidden)]
pub use self::enums::generated::GeneratedEnumDescriptorData;
pub use self::enums::EnumDescriptor;
pub use self::enums::EnumValueDescriptor;
pub use self::field::runtime_field_type::RuntimeFieldType;
pub use self::field::FieldDescriptor;
pub use self::field::ReflectFieldRef;
#[doc(hidden)]
pub use self::file::generated::GeneratedFileDescriptor;
pub use self::file::syntax::Syntax;
pub use self::file::FileDescriptor;
pub use self::map::ReflectMapMut;
pub use self::map::ReflectMapRef;
#[doc(hidden)]
pub use self::message::generated::GeneratedMessageDescriptorData;
pub use self::message::message_ref::MessageRef;
pub use self::message::MessageDescriptor;
#[doc(hidden)]
pub use self::oneof::generated::GeneratedOneofDescriptorData;
pub use self::oneof::OneofDescriptor;
pub use self::optional::ReflectOptionalRef;
pub use self::reflect_eq::ReflectEq;
pub use self::reflect_eq::ReflectEqMode;
pub use self::repeated::ReflectRepeatedMut;
pub use self::repeated::ReflectRepeatedRef;
pub use self::runtime_type_box::RuntimeType;
pub use self::service::MethodDescriptor;
pub use self::service::ServiceDescriptor;
pub use self::value::value_box::ReflectValueBox;
pub use self::value::value_ref::ReflectValueRef;
pub use self::value::ProtobufValue;

'''
'''--- protobuf/src/reflect/name.rs ---
pub(crate) fn concat_paths(a: &str, b: &str) -> String {
    if a.is_empty() {
        b.to_owned()
    } else if b.is_empty() {
        b.to_owned()
    } else {
        format!("{}.{}", a, b)
    }
}

pub(crate) fn protobuf_name_starts_with_package<'a>(
    name: &'a str,
    package: &str,
) -> Option<&'a str> {
    assert!(
        !package.starts_with("."),
        "package must not start with dot: {}",
        package
    );

    assert!(
        name.starts_with("."),
        "full name must start with dot: {}",
        name
    );
    let name = &name[1..];
    // assert!(!name.starts_with("."), "full name must not start with dot: {}", name);

    if package.is_empty() {
        Some(name)
    } else {
        if name.starts_with(package) {
            let rem = &name[package.len()..];
            if rem.starts_with(".") {
                Some(&rem[1..])
            } else {
                None
            }
        } else {
            None
        }
    }
}

#[test]
fn test_protobuf_name_starts_with_package() {
    assert_eq!(
        Some("bar"),
        protobuf_name_starts_with_package(".foo.bar", "foo")
    );
    assert_eq!(None, protobuf_name_starts_with_package(".foo", "foo"));
    assert_eq!(Some("foo"), protobuf_name_starts_with_package(".foo", ""));
}

'''
'''--- protobuf/src/reflect/oneof/generated.rs ---
use crate::OneofFull;

#[doc(hidden)]
pub struct GeneratedOneofDescriptorData {
    pub(crate) name: &'static str,
}

impl GeneratedOneofDescriptorData {
    #[doc(hidden)]
    pub fn new<O>(name: &'static str) -> GeneratedOneofDescriptorData
    where
        O: OneofFull,
    {
        GeneratedOneofDescriptorData { name }
    }
}

#[derive(Debug)]
pub(crate) struct GeneratedOneofDescriptor {}

impl GeneratedOneofDescriptor {
    /// Synthetic oneof for proto3 optional field.
    pub(crate) fn new_synthetic() -> GeneratedOneofDescriptor {
        GeneratedOneofDescriptor {}
    }

    pub(crate) fn new(_data: &GeneratedOneofDescriptorData) -> GeneratedOneofDescriptor {
        GeneratedOneofDescriptor {}
    }
}

'''
'''--- protobuf/src/reflect/oneof/mod.rs ---
pub(crate) mod generated;

use crate::descriptor::OneofDescriptorProto;
use crate::reflect::file::index::OneofIndices;
use crate::reflect::file::FileDescriptorImpl;
use crate::reflect::oneof::generated::GeneratedOneofDescriptor;
use crate::reflect::FieldDescriptor;
use crate::reflect::FileDescriptor;
use crate::reflect::MessageDescriptor;

/// Oneof descriptor.
#[derive(Eq, PartialEq, Clone, Debug)]
pub struct OneofDescriptor {
    pub(crate) file_descriptor: FileDescriptor,
    pub(crate) index: usize,
}

pub(crate) enum OneofDescriptorImplRef {
    Generated(&'static GeneratedOneofDescriptor),
    Dynamic,
}

impl OneofDescriptor {
    fn index_entry(&self) -> &OneofIndices {
        &self.file_descriptor.common().oneofs[self.index]
    }

    /// `.proto` part associated with this descriptor
    pub fn proto(&self) -> &OneofDescriptorProto {
        let index_entry = self.index_entry();
        let message_descriptor = self
            .file_descriptor
            .message_proto_by_index(index_entry.containing_message);
        &message_descriptor.oneof_decl[index_entry.index_in_containing_message]
    }

    /// Oneof name as specified in `.proto` file.
    pub fn name(&self) -> &str {
        self.proto().name()
    }

    #[allow(dead_code)]
    pub(crate) fn _get_impl(&self) -> OneofDescriptorImplRef {
        match &self.file_descriptor.imp {
            FileDescriptorImpl::Generated(g) => {
                OneofDescriptorImplRef::Generated(&g.oneofs[self.index])
            }
            FileDescriptorImpl::Dynamic(..) => OneofDescriptorImplRef::Dynamic,
        }
    }

    /// Message which contains this oneof.
    pub fn containing_message(&self) -> MessageDescriptor {
        MessageDescriptor {
            file_descriptor: self.file_descriptor.clone(),
            index: self.index_entry().containing_message,
        }
    }

    /// This oneof is not present in sources.
    pub fn is_synthetic(&self) -> bool {
        self.index_entry().synthetic
    }

    /// Fully qualified name of oneof (fully qualified name of enclosing message
    /// followed by oneof name).
    pub fn full_name(&self) -> String {
        format!("{}.{}", self.containing_message(), self.name())
    }

    /// Fields in this oneof.
    pub fn fields<'a>(&'a self) -> impl Iterator<Item = FieldDescriptor> + 'a {
        let message = self.containing_message();
        self.index_entry()
            .fields
            .iter()
            .map(move |&i| message.field_by_index(i))
    }
}

'''
'''--- protobuf/src/reflect/optional/mod.rs ---
use crate::reflect::runtime_types::RuntimeTypeTrait;
use crate::reflect::ProtobufValue;
use crate::reflect::ReflectEq;
use crate::reflect::ReflectEqMode;
use crate::reflect::ReflectValueRef;
use crate::reflect::RuntimeType;

enum Impl<'a> {
    None(RuntimeType),
    Some(ReflectValueRef<'a>),
}

/// Singular field field and value type.
pub struct ReflectOptionalRef<'a>(Impl<'a>);

impl<'a> PartialEq for ReflectOptionalRef<'a> {
    fn eq(&self, other: &Self) -> bool {
        self.reflect_eq(other, &ReflectEqMode::default())
    }
}

impl<'a> ReflectEq for ReflectOptionalRef<'a> {
    fn reflect_eq(&self, that: &Self, mode: &ReflectEqMode) -> bool {
        match (&self.0, &that.0) {
            (Impl::None(at), Impl::None(bt)) => at == bt,
            (Impl::Some(a), Impl::Some(b)) => a.reflect_eq(b, mode),
            (Impl::None(_), Impl::Some(_)) | (Impl::Some(_), Impl::None(_)) => false,
        }
    }
}

impl<'a> ReflectOptionalRef<'a> {
    /// No value.
    pub fn none(elem: RuntimeType) -> ReflectOptionalRef<'a> {
        ReflectOptionalRef(Impl::None(elem))
    }

    /// Has value.
    pub fn some(value: ReflectValueRef<'a>) -> ReflectOptionalRef<'a> {
        ReflectOptionalRef(Impl::Some(value))
    }

    pub(crate) fn none_from<V: ProtobufValue>() -> ReflectOptionalRef<'a> {
        ReflectOptionalRef::none(V::RuntimeType::runtime_type_box())
    }

    pub(crate) fn some_from<V: ProtobufValue>(value: &'a V) -> ReflectOptionalRef<'a> {
        ReflectOptionalRef::some(V::RuntimeType::as_ref(value))
    }

    pub(crate) fn new_filter_non_zero<V: ProtobufValue>(v: &'a V) -> ReflectOptionalRef<'a> {
        if V::RuntimeType::is_non_zero(v) {
            ReflectOptionalRef::some_from(v)
        } else {
            ReflectOptionalRef::none_from::<V>()
        }
    }

    pub(crate) fn new_from_option<V: ProtobufValue>(v: Option<&'a V>) -> ReflectOptionalRef<'a> {
        if let Some(v) = v {
            ReflectOptionalRef::some_from(v)
        } else {
            ReflectOptionalRef::none_from::<V>()
        }
    }

    /// Obtain the value, drop the type.
    pub fn value(&self) -> Option<ReflectValueRef<'a>> {
        match &self.0 {
            Impl::None(_) => None,
            Impl::Some(v) => Some(v.clone()),
        }
    }
}

'''
'''--- protobuf/src/reflect/protobuf_type_box.rs ---
use crate::descriptor::field_descriptor_proto::Type;
use crate::error::ProtobufError;
use crate::error::WireError;
use crate::reflect::EnumDescriptor;
use crate::reflect::MessageDescriptor;
use crate::reflect::ProtobufValue;
use crate::reflect::ReflectRepeatedMut;
use crate::reflect::ReflectValueBox;
use crate::reflect::RuntimeType;
use crate::wire_format::WireType;
use crate::CodedInputStream;

/// Runtime type and protobuf type.
#[derive(Debug, Clone)]
pub(crate) struct ProtobufType {
    /// Runtime type.
    runtime: RuntimeType,
    /// Wire type.
    t: Type,
}

impl ProtobufType {
    pub(crate) fn runtime(&self) -> &RuntimeType {
        &self.runtime
    }

    pub(crate) fn t(&self) -> Type {
        self.t
    }

    pub(crate) fn _into_runtime(self) -> RuntimeType {
        self.runtime
    }

    pub(crate) fn message(message: MessageDescriptor) -> ProtobufType {
        ProtobufType::new(RuntimeType::Message(message), Type::TYPE_MESSAGE).unwrap()
    }

    pub(crate) fn enumeration(enumeration: EnumDescriptor) -> ProtobufType {
        ProtobufType::new(RuntimeType::Enum(enumeration), Type::TYPE_ENUM).unwrap()
    }

    pub(crate) fn from_proto_type(t: Type) -> ProtobufType {
        ProtobufType::new(RuntimeType::from_proto_type(t), t).unwrap()
    }

    pub(crate) fn new(runtime: RuntimeType, t: Type) -> crate::Result<ProtobufType> {
        match (t, &runtime) {
            (Type::TYPE_INT32, RuntimeType::I32) => {}
            (Type::TYPE_INT64, RuntimeType::I64) => {}
            (Type::TYPE_UINT32, RuntimeType::U32) => {}
            (Type::TYPE_UINT64, RuntimeType::U64) => {}
            (Type::TYPE_SINT32, RuntimeType::I32) => {}
            (Type::TYPE_SINT64, RuntimeType::I64) => {}
            (Type::TYPE_FIXED32, RuntimeType::U32) => {}
            (Type::TYPE_FIXED64, RuntimeType::U64) => {}
            (Type::TYPE_SFIXED32, RuntimeType::I32) => {}
            (Type::TYPE_SFIXED64, RuntimeType::I64) => {}
            (Type::TYPE_FLOAT, RuntimeType::F32) => {}
            (Type::TYPE_DOUBLE, RuntimeType::F64) => {}
            (Type::TYPE_BOOL, RuntimeType::Bool) => {}
            (Type::TYPE_STRING, RuntimeType::String) => {}
            (Type::TYPE_BYTES, RuntimeType::VecU8) => {}
            (Type::TYPE_MESSAGE, RuntimeType::Message(..)) => {}
            (Type::TYPE_ENUM, RuntimeType::Enum(..)) => {}
            (Type::TYPE_GROUP, ..) => return Err(ProtobufError::GroupIsNotImplemented.into()),
            _ => return Err(ProtobufError::IncompatibleProtobufTypeAndRuntimeType.into()),
        }
        Ok(ProtobufType { runtime, t })
    }

    pub(crate) fn read(
        &self,
        is: &mut CodedInputStream,
        wire_type: WireType,
    ) -> crate::Result<ReflectValueBox> {
        if wire_type != WireType::for_type(self.t) {
            return Err(WireError::UnexpectedWireType(wire_type).into());
        }
        Ok(match self.t {
            Type::TYPE_DOUBLE => ReflectValueBox::F64(is.read_double()?),
            Type::TYPE_FLOAT => ReflectValueBox::F32(is.read_float()?),
            Type::TYPE_INT64 => ReflectValueBox::I64(is.read_int64()?),
            Type::TYPE_UINT64 => ReflectValueBox::U64(is.read_uint64()?),
            Type::TYPE_INT32 => ReflectValueBox::I32(is.read_int32()?),
            Type::TYPE_FIXED64 => ReflectValueBox::U64(is.read_fixed64()?),
            Type::TYPE_FIXED32 => ReflectValueBox::U32(is.read_fixed32()?),
            Type::TYPE_BOOL => ReflectValueBox::Bool(is.read_bool()?),
            Type::TYPE_UINT32 => ReflectValueBox::U32(is.read_uint32()?),
            Type::TYPE_SFIXED32 => ReflectValueBox::I32(is.read_sfixed32()?),
            Type::TYPE_SFIXED64 => ReflectValueBox::I64(is.read_sfixed64()?),
            Type::TYPE_SINT32 => ReflectValueBox::I32(is.read_sint32()?),
            Type::TYPE_SINT64 => ReflectValueBox::I64(is.read_sint64()?),
            Type::TYPE_STRING => ReflectValueBox::String(is.read_string()?),
            Type::TYPE_BYTES => ReflectValueBox::Bytes(is.read_bytes()?),
            Type::TYPE_ENUM => match &self.runtime {
                RuntimeType::Enum(e) => {
                    let v = is.read_enum_value()?;
                    ReflectValueBox::Enum(e.clone(), v)
                }
                _ => unreachable!(),
            },
            Type::TYPE_GROUP => return Err(ProtobufError::GroupIsNotImplemented.into()),
            Type::TYPE_MESSAGE => match &self.runtime {
                RuntimeType::Message(m) => ReflectValueBox::Message(is.read_message_dyn(m)?),
                _ => unreachable!(),
            },
        })
    }

    pub(crate) fn read_repeated_into(
        &self,
        is: &mut CodedInputStream,
        wire_type: WireType,
        repeated: &mut ReflectRepeatedMut,
    ) -> crate::Result<()> {
        if wire_type == WireType::for_type(self.t) {
            let value = self.read(is, wire_type)?;
            repeated.push(value);
            Ok(())
        } else if wire_type == WireType::LengthDelimited {
            fn extend<V: ProtobufValue>(repeated: &mut ReflectRepeatedMut, mut v: Vec<V>) {
                repeated.extend(ReflectRepeatedMut::new(&mut v));
            }

            match self.t {
                Type::TYPE_INT32 => {
                    let mut v = Vec::new();
                    is.read_repeated_packed_int32_into(&mut v)?;
                    extend(repeated, v);
                    Ok(())
                }
                Type::TYPE_INT64 => {
                    let mut v = Vec::new();
                    is.read_repeated_packed_int64_into(&mut v)?;
                    extend(repeated, v);
                    Ok(())
                }
                Type::TYPE_UINT32 => {
                    let mut v = Vec::new();
                    is.read_repeated_packed_uint32_into(&mut v)?;
                    extend(repeated, v);
                    Ok(())
                }
                Type::TYPE_UINT64 => {
                    let mut v = Vec::new();
                    is.read_repeated_packed_uint64_into(&mut v)?;
                    extend(repeated, v);
                    Ok(())
                }
                Type::TYPE_SINT32 => {
                    let mut v = Vec::new();
                    is.read_repeated_packed_sint32_into(&mut v)?;
                    extend(repeated, v);
                    Ok(())
                }
                Type::TYPE_SINT64 => {
                    let mut v = Vec::new();
                    is.read_repeated_packed_sint64_into(&mut v)?;
                    extend(repeated, v);
                    Ok(())
                }
                Type::TYPE_FIXED32 => {
                    let mut v = Vec::new();
                    is.read_repeated_packed_fixed32_into(&mut v)?;
                    extend(repeated, v);
                    Ok(())
                }
                Type::TYPE_FIXED64 => {
                    let mut v = Vec::new();
                    is.read_repeated_packed_fixed64_into(&mut v)?;
                    extend(repeated, v);
                    Ok(())
                }
                Type::TYPE_SFIXED32 => {
                    let mut v = Vec::new();
                    is.read_repeated_packed_sfixed32_into(&mut v)?;
                    extend(repeated, v);
                    Ok(())
                }
                Type::TYPE_SFIXED64 => {
                    let mut v = Vec::new();
                    is.read_repeated_packed_sfixed64_into(&mut v)?;
                    extend(repeated, v);
                    Ok(())
                }
                Type::TYPE_FLOAT => {
                    let mut v = Vec::new();
                    is.read_repeated_packed_float_into(&mut v)?;
                    extend(repeated, v);
                    Ok(())
                }
                Type::TYPE_DOUBLE => {
                    let mut v = Vec::new();
                    is.read_repeated_packed_double_into(&mut v)?;
                    extend(repeated, v);
                    Ok(())
                }
                Type::TYPE_BOOL => {
                    let mut v = Vec::new();
                    is.read_repeated_packed_bool_into(&mut v)?;
                    extend(repeated, v);
                    Ok(())
                }
                Type::TYPE_ENUM => match &self.runtime {
                    RuntimeType::Enum(e) => {
                        let mut v = Vec::new();
                        is.read_repeated_packed_enum_values_into(&mut v)?;
                        for e_v in v {
                            repeated.push(ReflectValueBox::Enum(e.clone(), e_v));
                        }
                        Ok(())
                    }
                    _ => unreachable!(),
                },
                Type::TYPE_GROUP => Err(ProtobufError::GroupIsNotImplemented.into()),
                Type::TYPE_MESSAGE | Type::TYPE_STRING | Type::TYPE_BYTES => {
                    Err(WireError::UnexpectedWireType(wire_type).into())
                }
            }
        } else {
            Err(WireError::UnexpectedWireType(wire_type).into())
        }
    }
}

'''
'''--- protobuf/src/reflect/reflect_eq.rs ---
/// Parameter for [`ReflectEq`].
#[derive(Debug, Default)]
pub struct ReflectEqMode {
    /// When `true`, `NaN` values are considered equal to each other.
    pub nan_equal: bool,
    _non_exhausitve: (),
}

impl ReflectEqMode {
    /// Default equality, similar to `#[derive(PartialEq)]`.
    pub fn default() -> ReflectEqMode {
        Default::default()
    }

    /// Equality where float `NaN` values are considered equal to each other.
    ///
    /// Useful in tests.
    pub fn nan_equal() -> ReflectEqMode {
        ReflectEqMode {
            nan_equal: true,
            ..Default::default()
        }
    }
}

/// Special version of eq.
///
/// With `mode` [`ReflectEqMode::default()`], should be equivalent
/// to `#[derive(PartialEq)]`.
pub trait ReflectEq {
    /// Perform the equality comparison.
    fn reflect_eq(&self, that: &Self, mode: &ReflectEqMode) -> bool;
}

'''
'''--- protobuf/src/reflect/repeated/drain_iter.rs ---
use crate::reflect::runtime_types::RuntimeTypeTrait;
use crate::reflect::ProtobufValue;
use crate::reflect::ReflectValueBox;

pub(crate) struct ReflectRepeatedDrainIter<'a> {
    imp: Box<dyn Iterator<Item = ReflectValueBox> + 'a>,
}

impl<'a> ReflectRepeatedDrainIter<'a> {
    pub(crate) fn new(
        imp: impl Iterator<Item = ReflectValueBox> + 'a,
    ) -> ReflectRepeatedDrainIter<'a> {
        ReflectRepeatedDrainIter { imp: Box::new(imp) }
    }

    pub(crate) fn new_vec<V: ProtobufValue>(v: &'a mut Vec<V>) -> ReflectRepeatedDrainIter<'a> {
        ReflectRepeatedDrainIter::new(v.drain(..).map(V::RuntimeType::into_value_box))
    }
}

impl<'a> Iterator for ReflectRepeatedDrainIter<'a> {
    type Item = ReflectValueBox;

    fn next(&mut self) -> Option<Self::Item> {
        self.imp.next()
    }
}

'''
'''--- protobuf/src/reflect/repeated/iter.rs ---
use crate::reflect::runtime_types::RuntimeTypeTrait;
use crate::reflect::ProtobufValue;
use crate::reflect::ReflectValueRef;

pub(crate) struct ReflectRepeatedIter<'a> {
    imp: Box<dyn Iterator<Item = ReflectValueRef<'a>> + 'a>,
}

impl<'a> ReflectRepeatedIter<'a> {
    pub(crate) fn new(
        iter: impl Iterator<Item = ReflectValueRef<'a>> + 'a,
    ) -> ReflectRepeatedIter<'a> {
        ReflectRepeatedIter {
            imp: Box::new(iter),
        }
    }

    pub(crate) fn new_slice<V: ProtobufValue>(slice: &'a [V]) -> ReflectRepeatedIter<'a> {
        ReflectRepeatedIter::new(slice.into_iter().map(V::RuntimeType::as_ref))
    }
}

impl<'a> Iterator for ReflectRepeatedIter<'a> {
    type Item = ReflectValueRef<'a>;

    fn next(&mut self) -> Option<ReflectValueRef<'a>> {
        self.imp.next()
    }
}

'''
'''--- protobuf/src/reflect/repeated/mod.rs ---
pub(crate) mod drain_iter;
pub(crate) mod iter;
mod transmute;
mod vec_downcast;

use std::any::type_name;
use std::fmt;

use crate::reflect::dynamic::repeated::DynamicRepeated;
use crate::reflect::reflect_eq::ReflectEq;
use crate::reflect::reflect_eq::ReflectEqMode;
use crate::reflect::repeated::drain_iter::ReflectRepeatedDrainIter;
use crate::reflect::repeated::iter::ReflectRepeatedIter;
use crate::reflect::repeated::transmute::transmute_ref_if_eq;
use crate::reflect::repeated::vec_downcast::VecMutVariant;
use crate::reflect::runtime_types::RuntimeTypeTrait;
use crate::reflect::value::value_ref::ReflectValueRef;
use crate::reflect::ProtobufValue;
use crate::reflect::ReflectValueBox;
use crate::reflect::RuntimeType;

pub(crate) trait ReflectRepeated: Sync + 'static + fmt::Debug {
    fn reflect_iter(&self) -> ReflectRepeatedIter;
    fn reflect_drain_iter(&mut self) -> ReflectRepeatedDrainIter;
    fn len(&self) -> usize;
    fn get(&self, index: usize) -> ReflectValueRef;
    /// Set element at index.
    ///
    /// # Panics
    ///
    /// * if index is out of bounds
    /// * if the element type does not match the collection element type
    fn set(&mut self, index: usize, value: ReflectValueBox);
    /// Append element.
    ///
    /// # Panics
    ///
    /// * if the element type does not match the collection element type
    fn push(&mut self, value: ReflectValueBox);

    fn reflect_extend(&mut self, values: ReflectRepeatedMut);

    fn clear(&mut self);
    /// Get the collection element type.
    fn element_type(&self) -> RuntimeType;

    /// Get array data for enum elements.
    ///
    /// # Panics
    ///
    /// * if the element type is not an enum
    fn data_enum_values(&self) -> &[i32];

    /// Get array data if the element type is bool.
    fn data_bool(&self) -> &[bool];
    /// Get array data if the element type is i32.
    fn data_i32(&self) -> &[i32];
    /// Get array data if the element type is u32.
    fn data_u32(&self) -> &[u32];
    /// Get array data if the element type is i64.
    fn data_i64(&self) -> &[i64];
    /// Get array data if the element type is u64.
    fn data_u64(&self) -> &[u64];
    /// Get array data if the element type is f32.
    fn data_f32(&self) -> &[f32];
    /// Get array data if the element type is f64.
    fn data_f64(&self) -> &[f64];
}

fn data_impl<V: ProtobufValue, X: ProtobufValue>(v: &Vec<V>) -> &[X] {
    match transmute_ref_if_eq::<_, Vec<X>>(v) {
        Ok(v) => v.as_slice(),
        Err(_) => panic!("not {}", type_name::<X>()),
    }
}

impl<V: ProtobufValue> ReflectRepeated for Vec<V> {
    fn reflect_iter<'a>(&'a self) -> ReflectRepeatedIter<'a> {
        ReflectRepeatedIter::new_slice(self.as_slice())
    }

    fn reflect_drain_iter<'a>(&'a mut self) -> ReflectRepeatedDrainIter<'a> {
        ReflectRepeatedDrainIter::new_vec(self)
    }

    fn len(&self) -> usize {
        Vec::len(self)
    }

    fn get(&self, index: usize) -> ReflectValueRef {
        V::RuntimeType::as_ref(&self[index])
    }

    fn set(&mut self, index: usize, value: ReflectValueBox) {
        let value = value.downcast().expect("wrong type");
        self[index] = value;
    }

    fn push(&mut self, value: ReflectValueBox) {
        let value = value.downcast().expect("wrong type");
        self.push(value)
    }

    fn reflect_extend(&mut self, values: ReflectRepeatedMut) {
        match VecMutVariant::downcast(self) {
            Some(VecMutVariant::U32(v)) => v.extend(values.repeated.data_u32()),
            Some(VecMutVariant::U64(v)) => v.extend(values.repeated.data_u64()),
            Some(VecMutVariant::I32(v)) => v.extend(values.repeated.data_i32()),
            Some(VecMutVariant::I64(v)) => v.extend(values.repeated.data_i64()),
            Some(VecMutVariant::F32(v)) => v.extend(values.repeated.data_f32()),
            Some(VecMutVariant::F64(v)) => v.extend(values.repeated.data_f64()),
            Some(VecMutVariant::Bool(v)) => v.extend(values.repeated.data_bool()),
            None => {
                for value in values.repeated.reflect_drain_iter() {
                    // Less efficient.
                    ReflectRepeated::push(self, value);
                }
            }
        }
    }

    fn clear(&mut self) {
        self.clear()
    }

    fn element_type(&self) -> RuntimeType {
        V::RuntimeType::runtime_type_box()
    }

    fn data_enum_values(&self) -> &[i32] {
        V::RuntimeType::cast_to_enum_values(&self)
    }

    fn data_bool(&self) -> &[bool] {
        data_impl(self)
    }

    fn data_i32(&self) -> &[i32] {
        data_impl(self)
    }

    fn data_u32(&self) -> &[u32] {
        data_impl(self)
    }

    fn data_i64(&self) -> &[i64] {
        data_impl(self)
    }

    fn data_u64(&self) -> &[u64] {
        data_impl(self)
    }

    fn data_f32(&self) -> &[f32] {
        data_impl(self)
    }

    fn data_f64(&self) -> &[f64] {
        data_impl(self)
    }
}

impl<'a> IntoIterator for &'a dyn ReflectRepeated {
    type Item = ReflectValueRef<'a>;
    type IntoIter = ReflectRepeatedIter<'a>;

    fn into_iter(self) -> Self::IntoIter {
        self.reflect_iter()
    }
}

#[derive(Clone)]
enum ReflectRepeatedRefImpl<'a> {
    Generated(&'a dyn ReflectRepeated),
    DynamicEmpty(DynamicRepeated),
}

impl<'a> fmt::Debug for ReflectRepeatedRefImpl<'a> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            ReflectRepeatedRefImpl::Generated(r) => fmt::Debug::fmt(r, f),
            ReflectRepeatedRefImpl::DynamicEmpty(r) => fmt::Debug::fmt(r, f),
        }
    }
}

/// Dynamic reference to repeated field
#[derive(Clone)]
pub struct ReflectRepeatedRef<'a> {
    imp: ReflectRepeatedRefImpl<'a>,
}

/// Dynamic mutable reference to repeated field
pub struct ReflectRepeatedMut<'a> {
    pub(crate) repeated: &'a mut dyn ReflectRepeated,
}

impl<'a> ReflectRepeatedRef<'a> {
    pub(crate) fn new(repeated: &'a dyn ReflectRepeated) -> ReflectRepeatedRef<'a> {
        ReflectRepeatedRef {
            imp: ReflectRepeatedRefImpl::Generated(repeated),
        }
    }

    pub(crate) fn new_empty(elem: RuntimeType) -> ReflectRepeatedRef<'static> {
        ReflectRepeatedRef {
            imp: ReflectRepeatedRefImpl::DynamicEmpty(DynamicRepeated::new(elem)),
        }
    }

    /// Number of elements in repeated field
    pub fn len(&self) -> usize {
        match &self.imp {
            ReflectRepeatedRefImpl::Generated(g) => g.len(),
            ReflectRepeatedRefImpl::DynamicEmpty(d) => d.len(),
        }
    }

    /// Repeated field is empty
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }

    /// Get item by index
    // TODO: replace with index
    pub fn get(&self, index: usize) -> ReflectValueRef<'a> {
        match &self.imp {
            ReflectRepeatedRefImpl::Generated(r) => r.get(index),
            ReflectRepeatedRefImpl::DynamicEmpty(..) => panic!("empty"),
        }
    }

    /// Runtime type of element
    pub fn element_type(&self) -> RuntimeType {
        match &self.imp {
            ReflectRepeatedRefImpl::Generated(r) => r.element_type(),
            ReflectRepeatedRefImpl::DynamicEmpty(r) => r.element_type(),
        }
    }

    pub(crate) fn data_enum_values(&self) -> &[i32] {
        match &self.imp {
            ReflectRepeatedRefImpl::Generated(r) => r.data_enum_values(),
            ReflectRepeatedRefImpl::DynamicEmpty(r) => r.data_enum_values(),
        }
    }

    pub(crate) fn data_bool(&self) -> &[bool] {
        match &self.imp {
            ReflectRepeatedRefImpl::Generated(r) => r.data_bool(),
            ReflectRepeatedRefImpl::DynamicEmpty(r) => r.data_bool(),
        }
    }

    pub(crate) fn data_u32(&self) -> &[u32] {
        match &self.imp {
            ReflectRepeatedRefImpl::Generated(r) => r.data_u32(),
            ReflectRepeatedRefImpl::DynamicEmpty(r) => r.data_u32(),
        }
    }

    pub(crate) fn data_i32(&self) -> &[i32] {
        match &self.imp {
            ReflectRepeatedRefImpl::Generated(r) => r.data_i32(),
            ReflectRepeatedRefImpl::DynamicEmpty(r) => r.data_i32(),
        }
    }

    pub(crate) fn data_u64(&self) -> &[u64] {
        match &self.imp {
            ReflectRepeatedRefImpl::Generated(r) => r.data_u64(),
            ReflectRepeatedRefImpl::DynamicEmpty(r) => r.data_u64(),
        }
    }

    pub(crate) fn data_i64(&self) -> &[i64] {
        match &self.imp {
            ReflectRepeatedRefImpl::Generated(r) => r.data_i64(),
            ReflectRepeatedRefImpl::DynamicEmpty(r) => r.data_i64(),
        }
    }

    pub(crate) fn data_f32(&self) -> &[f32] {
        match &self.imp {
            ReflectRepeatedRefImpl::Generated(r) => r.data_f32(),
            ReflectRepeatedRefImpl::DynamicEmpty(r) => r.data_f32(),
        }
    }

    pub(crate) fn data_f64(&self) -> &[f64] {
        match &self.imp {
            ReflectRepeatedRefImpl::Generated(r) => r.data_f64(),
            ReflectRepeatedRefImpl::DynamicEmpty(r) => r.data_f64(),
        }
    }
}

impl<'a> ReflectEq for ReflectRepeatedRef<'a> {
    fn reflect_eq(&self, that: &Self, mode: &ReflectEqMode) -> bool {
        let len = self.len();

        if len != that.len() {
            return false;
        }

        if self.element_type() != that.element_type() {
            return false;
        }

        for i in 0..len {
            let a = self.get(i);
            let b = that.get(i);
            if !a.reflect_eq(&b, mode) {
                return false;
            }
        }

        true
    }
}

impl<'a> PartialEq for ReflectRepeatedRef<'a> {
    fn eq(&self, other: &Self) -> bool {
        self.reflect_eq(other, &ReflectEqMode::default())
    }
}

impl<'a> PartialEq<[ReflectValueBox]> for ReflectRepeatedRef<'a> {
    fn eq(&self, other: &[ReflectValueBox]) -> bool {
        if self.len() != other.len() {
            return false;
        }

        for i in 0..self.len() {
            if self.get(i) != other[i] {
                return false;
            }
        }

        return true;
    }
}

impl<'a> PartialEq<ReflectRepeatedRef<'a>> for [ReflectValueBox] {
    fn eq(&self, other: &ReflectRepeatedRef) -> bool {
        other == self
    }
}

impl<'a> PartialEq<Vec<ReflectValueBox>> for ReflectRepeatedRef<'a> {
    fn eq(&self, other: &Vec<ReflectValueBox>) -> bool {
        self == other.as_slice()
    }
}

impl<'a> PartialEq<ReflectRepeatedRef<'a>> for Vec<ReflectValueBox> {
    fn eq(&self, other: &ReflectRepeatedRef) -> bool {
        self.as_slice() == other
    }
}

impl<'a> ReflectRepeatedMut<'a> {
    pub(crate) fn new(repeated: &'a mut dyn ReflectRepeated) -> ReflectRepeatedMut<'a> {
        ReflectRepeatedMut { repeated }
    }

    fn as_ref(&'a self) -> ReflectRepeatedRef<'a> {
        ReflectRepeatedRef::new(self.repeated)
    }

    /// Number of elements in repeated field
    pub fn len(&self) -> usize {
        self.repeated.len()
    }

    /// Self-explanatory
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }

    /// Get an item by index
    ///
    /// Note: return immutable reference.
    pub fn get(&'a self, index: usize) -> ReflectValueRef<'a> {
        self.repeated.get(index)
    }

    /// Runtime type of element
    pub fn element_type(&self) -> RuntimeType {
        self.repeated.element_type()
    }

    /// Set a value at given index.
    ///
    /// # Panics
    ///
    /// If index if out of range or value type does not match container element type
    pub fn set(&mut self, index: usize, value: ReflectValueBox) {
        self.repeated.set(index, value);
    }

    /// Push an item to repeated field.
    ///
    /// # Panics
    ///
    /// If index if out of range or value type does not match container element type
    pub fn push(&mut self, value: ReflectValueBox) {
        self.repeated.push(value);
    }

    pub(crate) fn extend(&mut self, values: ReflectRepeatedMut) {
        self.repeated.reflect_extend(values);
    }

    /// Self-explanatory
    pub fn clear(&mut self) {
        self.repeated.clear();
    }
}

/// Iterator over repeated field.
pub struct ReflectRepeatedRefIter<'a> {
    repeated: ReflectRepeatedRef<'a>,
    index: usize,
}

impl<'a> Iterator for ReflectRepeatedRefIter<'a> {
    type Item = ReflectValueRef<'a>;

    fn next(&mut self) -> Option<Self::Item> {
        let index = self.index;
        if index != self.repeated.len() {
            let r = self.repeated.get(index);
            self.index += 1;
            Some(r)
        } else {
            None
        }
    }
}

impl<'a> IntoIterator for &'a ReflectRepeatedRef<'a> {
    type Item = ReflectValueRef<'a>;
    type IntoIter = ReflectRepeatedRefIter<'a>;

    fn into_iter(self) -> Self::IntoIter {
        ReflectRepeatedRefIter {
            repeated: self.clone(),
            index: 0,
        }
    }
}

impl<'a> IntoIterator for ReflectRepeatedRef<'a> {
    type Item = ReflectValueRef<'a>;
    type IntoIter = ReflectRepeatedRefIter<'a>;

    fn into_iter(self) -> Self::IntoIter {
        ReflectRepeatedRefIter {
            repeated: self,
            index: 0,
        }
    }
}

impl<'a> IntoIterator for &'a ReflectRepeatedMut<'a> {
    type Item = ReflectValueRef<'a>;
    type IntoIter = ReflectRepeatedRefIter<'a>;

    fn into_iter(self) -> Self::IntoIter {
        self.as_ref().into_iter()
    }
}

impl<'a> fmt::Debug for ReflectRepeatedRef<'a> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Debug::fmt(&self.imp, f)
    }
}

impl<'a> fmt::Debug for ReflectRepeatedMut<'a> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Debug::fmt(self.repeated, f)
    }
}

impl<'a> PartialEq for ReflectRepeatedMut<'a> {
    fn eq(&self, other: &Self) -> bool {
        self.as_ref() == other.as_ref()
    }
}

impl<'a> PartialEq<ReflectRepeatedRef<'a>> for ReflectRepeatedMut<'a> {
    fn eq(&self, other: &ReflectRepeatedRef) -> bool {
        PartialEq::eq(&self.as_ref(), other)
    }
}

impl<'a> PartialEq<[ReflectValueBox]> for ReflectRepeatedMut<'a> {
    fn eq(&self, other: &[ReflectValueBox]) -> bool {
        PartialEq::eq(&self.as_ref(), other)
    }
}

impl<'a> PartialEq<ReflectRepeatedMut<'a>> for [ReflectValueBox] {
    fn eq(&self, other: &ReflectRepeatedMut) -> bool {
        PartialEq::eq(self, &other.as_ref())
    }
}

impl<'a> PartialEq<Vec<ReflectValueBox>> for ReflectRepeatedMut<'a> {
    fn eq(&self, other: &Vec<ReflectValueBox>) -> bool {
        self == other.as_slice()
    }
}

impl<'a> PartialEq<ReflectRepeatedMut<'a>> for Vec<ReflectValueBox> {
    fn eq(&self, other: &ReflectRepeatedMut) -> bool {
        self.as_slice() == other
    }
}

'''
'''--- protobuf/src/reflect/repeated/transmute.rs ---
use std::any::TypeId;

pub(crate) fn transmute_mut_if_eq<A: 'static, B: 'static>(a: &mut A) -> Result<&mut B, &mut A> {
    if TypeId::of::<A>() == TypeId::of::<B>() {
        // SAFETY: we check type before transmuting.
        Ok(unsafe { &mut *(a as *mut A as *mut B) })
    } else {
        Err(a)
    }
}

pub(crate) fn transmute_ref_if_eq<A: 'static, B: 'static>(a: &A) -> Result<&B, &A> {
    if TypeId::of::<A>() == TypeId::of::<B>() {
        // SAFETY: we check type before transmuting.
        Ok(unsafe { &*(a as *const A as *const B) })
    } else {
        Err(a)
    }
}

'''
'''--- protobuf/src/reflect/repeated/vec_downcast.rs ---
use crate::reflect::repeated::transmute::transmute_mut_if_eq;
use crate::reflect::ProtobufValue;

pub(crate) enum VecMutVariant<'a> {
    U32(&'a mut Vec<u32>),
    U64(&'a mut Vec<u64>),
    I32(&'a mut Vec<i32>),
    I64(&'a mut Vec<i64>),
    F32(&'a mut Vec<f32>),
    F64(&'a mut Vec<f64>),
    Bool(&'a mut Vec<bool>),
}

impl<'a> VecMutVariant<'a> {
    pub(crate) fn downcast<V: ProtobufValue>(vec: &'a mut Vec<V>) -> Option<VecMutVariant<'a>> {
        let vec = match transmute_mut_if_eq(vec) {
            Ok(vec) => return Some(VecMutVariant::U32(vec)),
            Err(vec) => vec,
        };
        let vec = match transmute_mut_if_eq(vec) {
            Ok(vec) => return Some(VecMutVariant::U64(vec)),
            Err(vec) => vec,
        };
        let vec = match transmute_mut_if_eq(vec) {
            Ok(vec) => return Some(VecMutVariant::I32(vec)),
            Err(vec) => vec,
        };
        let vec = match transmute_mut_if_eq(vec) {
            Ok(vec) => return Some(VecMutVariant::I64(vec)),
            Err(vec) => vec,
        };
        let vec = match transmute_mut_if_eq(vec) {
            Ok(vec) => return Some(VecMutVariant::F32(vec)),
            Err(vec) => vec,
        };
        let vec = match transmute_mut_if_eq(vec) {
            Ok(vec) => return Some(VecMutVariant::F64(vec)),
            Err(vec) => vec,
        };
        let vec = match transmute_mut_if_eq(vec) {
            Ok(vec) => return Some(VecMutVariant::Bool(vec)),
            Err(vec) => vec,
        };
        let _ = vec;
        None
    }
}

'''
'''--- protobuf/src/reflect/rt/mod.rs ---
//! This module contains functions references for reflection in generated code.

#![doc(hidden)]

pub mod v2;

pub use crate::reflect::acc::FieldAccessor;
pub use crate::reflect::runtime_types::RuntimeTypeMessage;

'''
'''--- protobuf/src/reflect/rt/v2.rs ---
//! This module contains functions references for reflection in generated code.

#![doc(hidden)]

pub use crate::reflect::acc::v2::map::make_map_simpler_accessor;
pub use crate::reflect::acc::v2::repeated::make_vec_simpler_accessor;
pub use crate::reflect::acc::v2::singular::make_message_field_accessor;
pub use crate::reflect::acc::v2::singular::make_option_accessor;
pub use crate::reflect::acc::v2::singular::make_simpler_field_accessor;
pub use crate::reflect::acc::v2::singular::oneof::make_oneof_copy_has_get_set_simpler_accessors;
pub use crate::reflect::acc::v2::singular::oneof::make_oneof_deref_has_get_set_simpler_accessor;
pub use crate::reflect::acc::v2::singular::oneof::make_oneof_enum_accessors;
pub use crate::reflect::acc::v2::singular::oneof::make_oneof_message_has_get_mut_set_accessor;

'''
'''--- protobuf/src/reflect/runtime_type_box.rs ---
use std::fmt;

use protobuf_support::lexer::float::parse_protobuf_float;
use protobuf_support::lexer::str_lit::StrLit;

use crate::descriptor::field_descriptor_proto;
use crate::reflect::EnumDescriptor;
use crate::reflect::MessageDescriptor;
use crate::reflect::MessageRef;
use crate::reflect::ReflectValueBox;
use crate::reflect::ReflectValueRef;

/// Runtime representation of elementary protobuf type.
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum RuntimeType {
    /// `i32`
    I32,
    /// `i64`
    I64,
    /// `u32`
    U32,
    /// `u64`
    U64,
    /// `f32`
    F32,
    /// `f64`
    F64,
    /// `bool`
    Bool,
    /// [`String`](std::string::String)
    String,
    /// [`Vec<u8>`](std::vec::Vec)
    VecU8,
    /// `enum`
    Enum(EnumDescriptor),
    /// `message`
    Message(MessageDescriptor),
}

impl RuntimeType {
    pub(crate) fn default_value_ref(&self) -> ReflectValueRef<'static> {
        match self {
            RuntimeType::I32 => ReflectValueRef::I32(0),
            RuntimeType::I64 => ReflectValueRef::I64(0),
            RuntimeType::U32 => ReflectValueRef::U32(0),
            RuntimeType::U64 => ReflectValueRef::U64(0),
            RuntimeType::F32 => ReflectValueRef::F32(0.0),
            RuntimeType::F64 => ReflectValueRef::F64(0.0),
            RuntimeType::Bool => ReflectValueRef::Bool(false),
            RuntimeType::String => ReflectValueRef::String(""),
            RuntimeType::VecU8 => ReflectValueRef::Bytes(b""),
            RuntimeType::Enum(e) => ReflectValueRef::Enum(e.clone(), e.default_value().value()),
            RuntimeType::Message(m) => ReflectValueRef::Message(MessageRef::default_instance(m)),
        }
    }

    pub(crate) fn default_value_box(&self) -> ReflectValueBox {
        self.default_value_ref().to_box()
    }

    /// Rust type from protobuf type.
    ///
    /// # Panics
    ///
    /// Panics for message or enum types (because they can't be resolved without context).
    pub(crate) fn from_proto_type(t: field_descriptor_proto::Type) -> RuntimeType {
        match t {
            field_descriptor_proto::Type::TYPE_UINT32 => RuntimeType::U32,
            field_descriptor_proto::Type::TYPE_UINT64 => RuntimeType::U64,
            field_descriptor_proto::Type::TYPE_INT32 => RuntimeType::I32,
            field_descriptor_proto::Type::TYPE_INT64 => RuntimeType::I64,
            field_descriptor_proto::Type::TYPE_SINT32 => RuntimeType::I32,
            field_descriptor_proto::Type::TYPE_SINT64 => RuntimeType::I64,
            field_descriptor_proto::Type::TYPE_FIXED32 => RuntimeType::U32,
            field_descriptor_proto::Type::TYPE_FIXED64 => RuntimeType::U64,
            field_descriptor_proto::Type::TYPE_SFIXED64 => RuntimeType::I64,
            field_descriptor_proto::Type::TYPE_SFIXED32 => RuntimeType::I32,
            field_descriptor_proto::Type::TYPE_BOOL => RuntimeType::Bool,
            field_descriptor_proto::Type::TYPE_STRING => RuntimeType::String,
            field_descriptor_proto::Type::TYPE_BYTES => RuntimeType::VecU8,
            field_descriptor_proto::Type::TYPE_FLOAT => RuntimeType::F32,
            field_descriptor_proto::Type::TYPE_DOUBLE => RuntimeType::F64,
            field_descriptor_proto::Type::TYPE_ENUM
            | field_descriptor_proto::Type::TYPE_MESSAGE
            | field_descriptor_proto::Type::TYPE_GROUP => panic!(
                "{:?} cannot be converted to runtime type without context",
                t
            ),
        }
    }

    pub(crate) fn parse_proto_default_value(&self, value: &str) -> Result<ReflectValueBox, ()> {
        match self {
            // For booleans, "true" or "false"
            RuntimeType::Bool => {
                if value == "true" {
                    Ok(ReflectValueBox::Bool(true))
                } else if value == "false" {
                    Ok(ReflectValueBox::Bool(false))
                } else {
                    Err(())
                }
            }
            RuntimeType::I32 => value.parse().map_err(|_| ()).map(ReflectValueBox::I32),
            RuntimeType::I64 => value.parse().map_err(|_| ()).map(ReflectValueBox::I64),
            RuntimeType::U32 => value.parse().map_err(|_| ()).map(ReflectValueBox::U32),
            RuntimeType::U64 => value.parse().map_err(|_| ()).map(ReflectValueBox::U64),
            RuntimeType::F32 => parse_protobuf_float(value)
                .map_err(|_| ())
                .map(|v| ReflectValueBox::F32(v as f32)),
            RuntimeType::F64 => parse_protobuf_float(value)
                .map_err(|_| ())
                .map(ReflectValueBox::F64),
            // For strings, contains the default text contents (not escaped in any way)
            RuntimeType::String => Ok(ReflectValueBox::String(value.to_owned())),
            // For bytes, contains the C escaped value.  All bytes >= 128 are escaped
            RuntimeType::VecU8 => StrLit {
                escaped: value.to_owned(),
            }
            .decode_bytes()
            .map_err(|_| ())
            .map(ReflectValueBox::Bytes),
            RuntimeType::Enum(_) => {
                // Handled outside.
                Err(())
            }
            RuntimeType::Message(_) => {
                // Message cannot have default value.
                Err(())
            }
        }
    }
}

impl fmt::Display for RuntimeType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            RuntimeType::I32 => write!(f, "i32"),
            RuntimeType::I64 => write!(f, "i64"),
            RuntimeType::U32 => write!(f, "u32"),
            RuntimeType::U64 => write!(f, "u64"),
            RuntimeType::F32 => write!(f, "f32"),
            RuntimeType::F64 => write!(f, "f64"),
            RuntimeType::Bool => write!(f, "bool"),
            RuntimeType::String => write!(f, "String"),
            RuntimeType::VecU8 => write!(f, "Vec<u8>"),
            RuntimeType::Enum(e) => write!(f, "{}", e.full_name()),
            RuntimeType::Message(m) => write!(f, "{}", m.full_name()),
        }
    }
}

'''
'''--- protobuf/src/reflect/runtime_types.rs ---
//! Implementations of `RuntimeType` for all types.

use std::collections::HashMap;
use std::fmt;
use std::marker;

#[cfg(feature = "bytes")]
use bytes::Bytes;

#[cfg(feature = "bytes")]
use crate::chars::Chars;
use crate::descriptor::field_descriptor_proto::Type;
use crate::enum_or_unknown::EnumOrUnknown;
use crate::message_full::MessageFull;
use crate::reflect::runtime_type_box::RuntimeType;
use crate::reflect::types::ProtobufTypeBool;
use crate::reflect::types::ProtobufTypeBytes;
use crate::reflect::types::ProtobufTypeDouble;
use crate::reflect::types::ProtobufTypeEnumOrUnknown;
use crate::reflect::types::ProtobufTypeFixed32;
use crate::reflect::types::ProtobufTypeFixed64;
use crate::reflect::types::ProtobufTypeFloat;
use crate::reflect::types::ProtobufTypeInt32;
use crate::reflect::types::ProtobufTypeInt64;
use crate::reflect::types::ProtobufTypeMessage;
use crate::reflect::types::ProtobufTypeSfixed32;
use crate::reflect::types::ProtobufTypeSfixed64;
use crate::reflect::types::ProtobufTypeSint32;
use crate::reflect::types::ProtobufTypeSint64;
use crate::reflect::types::ProtobufTypeString;
#[cfg(feature = "bytes")]
use crate::reflect::types::ProtobufTypeTokioBytes;
#[cfg(feature = "bytes")]
use crate::reflect::types::ProtobufTypeTokioChars;
use crate::reflect::types::ProtobufTypeTrait;
use crate::reflect::types::ProtobufTypeUint32;
use crate::reflect::types::ProtobufTypeUint64;
use crate::reflect::value::value_ref::ReflectValueMut;
use crate::reflect::MessageRef;
use crate::reflect::ProtobufValue;
use crate::reflect::ReflectValueBox;
use crate::reflect::ReflectValueRef;
use crate::EnumFull;
use crate::UnknownValueRef;

/// `RuntimeType` is not implemented by all protobuf types directly
/// because it's not possible to implement `RuntimeType` for all `Message`
/// implementations at once: each `Message` implementation has to reimplement
/// all the methods again. With current strategy there's only implementation
/// for all messages, which is `RuntimeTypeMessage`.
///
/// The downside is that we have to explicitly specify type parameters
/// in a lot of places.
pub trait RuntimeTypeTrait: fmt::Debug + Send + Sync + Sized + 'static {
    /// Actual value for this type.
    type Value: ProtobufValue + Clone + Sized + fmt::Debug + Default;

    /// "Box" version of type type.
    fn runtime_type_box() -> RuntimeType;

    /// Default value for this type.
    fn default_value_ref() -> ReflectValueRef<'static>;

    /// Construct a value from given reflective value.
    ///
    /// # Panics
    ///
    /// If reflective value is of incompatible type.
    fn from_value_box(value_box: ReflectValueBox) -> Result<Self::Value, ReflectValueBox>;

    /// Convert a value into a refletive box value.
    fn into_value_box(value: Self::Value) -> ReflectValueBox;

    /// Convert a value into a ref value if possible.
    ///
    /// # Panics
    ///
    /// For message and enum.
    // TODO: move the operation into a separate trait
    fn into_static_value_ref(value: Self::Value) -> ReflectValueRef<'static> {
        panic!("value {:?} cannot be converted to static ref", value)
    }

    /// Pointer to a dynamic reference.
    fn as_ref(value: &Self::Value) -> ReflectValueRef;
    /// Mutable pointer to a dynamic mutable reference.
    fn as_mut(value: &mut Self::Value) -> ReflectValueMut;

    /// Value is non-default?
    fn is_non_zero(value: &Self::Value) -> bool;

    /// Write the value.
    fn set_from_value_box(target: &mut Self::Value, value_box: ReflectValueBox) {
        *target = Self::from_value_box(value_box).expect("wrong type");
    }

    /// Cast values to enum values.
    ///
    /// # Panics
    ///
    /// If self is not an enum.
    fn cast_to_enum_values(values: &[Self::Value]) -> &[i32] {
        let _ = values;
        panic!("not enum")
    }

    /// Parse the value from unknown fields.
    fn get_from_unknown(unknown: UnknownValueRef, field_type: Type) -> Option<Self::Value>;
}

/// Runtime type which can be dereferenced.
pub trait RuntimeTypeWithDeref: RuntimeTypeTrait {
    /// Deref target.
    type DerefTarget: ?Sized;

    /// Deref.
    // TODO: rename to `deref`
    fn deref_as_ref(value: &Self::DerefTarget) -> ReflectValueRef;
}

/// Types which can be hashmap keys.
pub trait RuntimeTypeHashable: RuntimeTypeTrait {
    /// Query hash map with a given key.
    fn hash_map_get<'a, V>(map: &'a HashMap<Self::Value, V>, key: ReflectValueRef)
        -> Option<&'a V>;
}

/// Implementation for `f32`
#[derive(Debug, Copy, Clone)]
pub struct RuntimeTypeF32;
/// Implementation for `f64`
#[derive(Debug, Copy, Clone)]
pub struct RuntimeTypeF64;
/// Implementation for `i32`
#[derive(Debug, Copy, Clone)]
pub struct RuntimeTypeI32;
/// Implementation for `f32`
#[derive(Debug, Copy, Clone)]
pub struct RuntimeTypeI64;
/// Implementation for `u32`
#[derive(Debug, Copy, Clone)]
pub struct RuntimeTypeU32;
/// Implementation for `u64`
#[derive(Debug, Copy, Clone)]
pub struct RuntimeTypeU64;
/// Implementation for `bool`
#[derive(Debug, Copy, Clone)]
pub struct RuntimeTypeBool;
/// Implementation for `String`
#[derive(Debug, Copy, Clone)]
pub struct RuntimeTypeString;
/// Implementation for `Vec<u8>`
#[derive(Debug, Copy, Clone)]
pub struct RuntimeTypeVecU8;

/// Implementation for [`Bytes`].
#[cfg(feature = "bytes")]
#[derive(Debug, Copy, Clone)]
pub struct RuntimeTypeTokioBytes;
/// Implementation for [`Chars`].
#[cfg(feature = "bytes")]
#[derive(Debug, Copy, Clone)]
pub struct RuntimeTypeTokioChars;

/// Implementation for enum.
#[derive(Debug, Copy, Clone)]
pub struct RuntimeTypeEnumOrUnknown<E: EnumFull>(marker::PhantomData<E>);
/// Implementation for [`MessageFull`].
#[derive(Debug, Copy, Clone)]
pub struct RuntimeTypeMessage<M: MessageFull>(marker::PhantomData<M>);

impl RuntimeTypeTrait for RuntimeTypeF32 {
    type Value = f32;

    fn runtime_type_box() -> RuntimeType
    where
        Self: Sized,
    {
        RuntimeType::F32
    }

    fn default_value_ref() -> ReflectValueRef<'static> {
        ReflectValueRef::F32(0.0)
    }

    fn from_value_box(value_box: ReflectValueBox) -> Result<f32, ReflectValueBox> {
        match value_box {
            ReflectValueBox::F32(v) => Ok(v),
            b => Err(b),
        }
    }
    fn into_value_box(value: f32) -> ReflectValueBox {
        ReflectValueBox::F32(value)
    }

    fn into_static_value_ref(value: f32) -> ReflectValueRef<'static> {
        ReflectValueRef::F32(value)
    }
    fn as_ref(value: &f32) -> ReflectValueRef {
        ReflectValueRef::F32(*value)
    }

    fn as_mut(_value: &mut Self::Value) -> ReflectValueMut {
        unimplemented!()
    }

    fn is_non_zero(value: &f32) -> bool {
        *value != 0.0
    }

    fn get_from_unknown(unknown: UnknownValueRef, field_type: Type) -> Option<Self::Value> {
        assert_eq!(field_type, Type::TYPE_FLOAT);
        ProtobufTypeFloat::get_from_unknown(unknown)
    }
}

impl RuntimeTypeTrait for RuntimeTypeF64 {
    type Value = f64;

    fn default_value_ref() -> ReflectValueRef<'static> {
        ReflectValueRef::F64(0.0)
    }

    fn runtime_type_box() -> RuntimeType
    where
        Self: Sized,
    {
        RuntimeType::F64
    }

    fn from_value_box(value_box: ReflectValueBox) -> Result<f64, ReflectValueBox> {
        match value_box {
            ReflectValueBox::F64(v) => Ok(v),
            b => Err(b),
        }
    }

    fn into_value_box(value: f64) -> ReflectValueBox {
        ReflectValueBox::F64(value)
    }

    fn into_static_value_ref(value: f64) -> ReflectValueRef<'static> {
        ReflectValueRef::F64(value)
    }

    fn as_ref(value: &f64) -> ReflectValueRef {
        ReflectValueRef::F64(*value)
    }

    fn is_non_zero(value: &f64) -> bool {
        *value != 0.0
    }

    fn as_mut(_value: &mut Self::Value) -> ReflectValueMut {
        unimplemented!()
    }

    fn get_from_unknown(unknown: UnknownValueRef, field_type: Type) -> Option<Self::Value> {
        assert_eq!(field_type, Type::TYPE_DOUBLE);
        ProtobufTypeDouble::get_from_unknown(unknown)
    }
}

impl RuntimeTypeTrait for RuntimeTypeI32 {
    type Value = i32;

    fn default_value_ref() -> ReflectValueRef<'static> {
        ReflectValueRef::I32(0)
    }

    fn runtime_type_box() -> RuntimeType
    where
        Self: Sized,
    {
        RuntimeType::I32
    }

    fn from_value_box(value_box: ReflectValueBox) -> Result<i32, ReflectValueBox> {
        match value_box {
            ReflectValueBox::I32(v) => Ok(v),
            b => Err(b),
        }
    }

    fn into_value_box(value: i32) -> ReflectValueBox {
        ReflectValueBox::I32(value)
    }

    fn into_static_value_ref(value: i32) -> ReflectValueRef<'static> {
        ReflectValueRef::I32(value)
    }

    fn as_ref(value: &i32) -> ReflectValueRef {
        ReflectValueRef::I32(*value)
    }

    fn is_non_zero(value: &i32) -> bool {
        *value != 0
    }

    fn as_mut(_value: &mut Self::Value) -> ReflectValueMut {
        unimplemented!()
    }

    fn get_from_unknown(unknown: UnknownValueRef, field_type: Type) -> Option<Self::Value> {
        match field_type {
            Type::TYPE_INT32 => ProtobufTypeInt32::get_from_unknown(unknown),
            Type::TYPE_SINT32 => ProtobufTypeSint32::get_from_unknown(unknown),
            Type::TYPE_SFIXED32 => ProtobufTypeSfixed32::get_from_unknown(unknown),
            _ => panic!("wrong type: {:?}", field_type),
        }
    }
}
impl RuntimeTypeHashable for RuntimeTypeI32 {
    fn hash_map_get<'a, V>(map: &'a HashMap<i32, V>, key: ReflectValueRef) -> Option<&'a V> {
        match key {
            ReflectValueRef::I32(i) => map.get(&i),
            _ => None,
        }
    }
}

impl RuntimeTypeTrait for RuntimeTypeI64 {
    type Value = i64;

    fn default_value_ref() -> ReflectValueRef<'static> {
        ReflectValueRef::I64(0)
    }

    fn runtime_type_box() -> RuntimeType
    where
        Self: Sized,
    {
        RuntimeType::I64
    }

    fn from_value_box(value_box: ReflectValueBox) -> Result<i64, ReflectValueBox> {
        match value_box {
            ReflectValueBox::I64(v) => Ok(v),
            b => Err(b),
        }
    }

    fn into_value_box(value: i64) -> ReflectValueBox {
        ReflectValueBox::I64(value)
    }

    fn into_static_value_ref(value: i64) -> ReflectValueRef<'static> {
        ReflectValueRef::I64(value)
    }

    fn as_ref(value: &i64) -> ReflectValueRef {
        ReflectValueRef::I64(*value)
    }

    fn is_non_zero(value: &i64) -> bool {
        *value != 0
    }

    fn as_mut(_value: &mut Self::Value) -> ReflectValueMut {
        unimplemented!()
    }

    fn get_from_unknown(unknown: UnknownValueRef, field_type: Type) -> Option<Self::Value> {
        match field_type {
            Type::TYPE_INT64 => ProtobufTypeInt64::get_from_unknown(unknown),
            Type::TYPE_SINT64 => ProtobufTypeSint64::get_from_unknown(unknown),
            Type::TYPE_SFIXED64 => ProtobufTypeSfixed64::get_from_unknown(unknown),
            _ => panic!("wrong type: {:?}", field_type),
        }
    }
}
impl RuntimeTypeHashable for RuntimeTypeI64 {
    fn hash_map_get<'a, V>(map: &'a HashMap<i64, V>, key: ReflectValueRef) -> Option<&'a V> {
        match key {
            ReflectValueRef::I64(i) => map.get(&i),
            _ => None,
        }
    }
}

impl RuntimeTypeTrait for RuntimeTypeU32 {
    type Value = u32;

    fn runtime_type_box() -> RuntimeType
    where
        Self: Sized,
    {
        RuntimeType::U32
    }

    fn default_value_ref() -> ReflectValueRef<'static> {
        ReflectValueRef::U32(0)
    }

    fn from_value_box(value_box: ReflectValueBox) -> Result<u32, ReflectValueBox> {
        match value_box {
            ReflectValueBox::U32(v) => Ok(v),
            b => Err(b),
        }
    }

    fn into_value_box(value: u32) -> ReflectValueBox {
        ReflectValueBox::U32(value)
    }

    fn into_static_value_ref(value: u32) -> ReflectValueRef<'static> {
        ReflectValueRef::U32(value)
    }

    fn as_ref(value: &u32) -> ReflectValueRef {
        ReflectValueRef::U32(*value)
    }

    fn as_mut(_value: &mut Self::Value) -> ReflectValueMut {
        unimplemented!()
    }

    fn is_non_zero(value: &u32) -> bool {
        *value != 0
    }

    fn get_from_unknown(unknown: UnknownValueRef, field_type: Type) -> Option<Self::Value> {
        match field_type {
            Type::TYPE_UINT32 => ProtobufTypeUint32::get_from_unknown(unknown),
            Type::TYPE_FIXED32 => ProtobufTypeFixed32::get_from_unknown(unknown),
            _ => panic!("wrong type: {:?}", field_type),
        }
    }
}
impl RuntimeTypeHashable for RuntimeTypeU32 {
    fn hash_map_get<'a, V>(map: &'a HashMap<u32, V>, key: ReflectValueRef) -> Option<&'a V> {
        match key {
            ReflectValueRef::U32(i) => map.get(&i),
            _ => None,
        }
    }
}

impl RuntimeTypeTrait for RuntimeTypeU64 {
    type Value = u64;

    fn default_value_ref() -> ReflectValueRef<'static> {
        ReflectValueRef::U64(0)
    }

    fn runtime_type_box() -> RuntimeType
    where
        Self: Sized,
    {
        RuntimeType::U64
    }

    fn from_value_box(value_box: ReflectValueBox) -> Result<u64, ReflectValueBox> {
        match value_box {
            ReflectValueBox::U64(v) => Ok(v),
            b => Err(b),
        }
    }

    fn into_value_box(value: u64) -> ReflectValueBox {
        ReflectValueBox::U64(value)
    }

    fn into_static_value_ref(value: u64) -> ReflectValueRef<'static> {
        ReflectValueRef::U64(value)
    }

    fn as_ref(value: &u64) -> ReflectValueRef {
        ReflectValueRef::U64(*value)
    }

    fn is_non_zero(value: &u64) -> bool {
        *value != 0
    }

    fn as_mut(_value: &mut Self::Value) -> ReflectValueMut {
        unimplemented!()
    }

    fn get_from_unknown(unknown: UnknownValueRef, field_type: Type) -> Option<Self::Value> {
        match field_type {
            Type::TYPE_UINT64 => ProtobufTypeUint64::get_from_unknown(unknown),
            Type::TYPE_FIXED64 => ProtobufTypeFixed64::get_from_unknown(unknown),
            _ => panic!("wrong type: {:?}", field_type),
        }
    }
}
impl RuntimeTypeHashable for RuntimeTypeU64 {
    fn hash_map_get<'a, V>(map: &'a HashMap<u64, V>, key: ReflectValueRef) -> Option<&'a V> {
        match key {
            ReflectValueRef::U64(i) => map.get(&i),
            _ => None,
        }
    }
}

impl RuntimeTypeTrait for RuntimeTypeBool {
    type Value = bool;

    fn default_value_ref() -> ReflectValueRef<'static> {
        ReflectValueRef::Bool(false)
    }

    fn runtime_type_box() -> RuntimeType
    where
        Self: Sized,
    {
        RuntimeType::Bool
    }

    fn from_value_box(value_box: ReflectValueBox) -> Result<bool, ReflectValueBox> {
        match value_box {
            ReflectValueBox::Bool(v) => Ok(v),
            b => Err(b),
        }
    }

    fn into_value_box(value: bool) -> ReflectValueBox {
        ReflectValueBox::Bool(value)
    }

    fn into_static_value_ref(value: bool) -> ReflectValueRef<'static> {
        ReflectValueRef::Bool(value)
    }

    fn as_ref(value: &bool) -> ReflectValueRef {
        ReflectValueRef::Bool(*value)
    }

    fn is_non_zero(value: &bool) -> bool {
        *value
    }

    fn as_mut(_value: &mut Self::Value) -> ReflectValueMut {
        unimplemented!()
    }

    fn get_from_unknown(unknown: UnknownValueRef, field_type: Type) -> Option<Self::Value> {
        assert_eq!(field_type, Type::TYPE_BOOL);
        ProtobufTypeBool::get_from_unknown(unknown)
    }
}
impl RuntimeTypeHashable for RuntimeTypeBool {
    fn hash_map_get<'a, V>(map: &'a HashMap<bool, V>, key: ReflectValueRef) -> Option<&'a V> {
        match key {
            ReflectValueRef::Bool(i) => map.get(&i),
            _ => None,
        }
    }
}

impl RuntimeTypeTrait for RuntimeTypeString {
    type Value = String;

    fn runtime_type_box() -> RuntimeType
    where
        Self: Sized,
    {
        RuntimeType::String
    }

    fn default_value_ref() -> ReflectValueRef<'static> {
        ReflectValueRef::String("")
    }

    fn from_value_box(value_box: ReflectValueBox) -> Result<String, ReflectValueBox> {
        match value_box {
            ReflectValueBox::String(v) => Ok(v),
            b => Err(b),
        }
    }

    fn into_value_box(value: String) -> ReflectValueBox {
        ReflectValueBox::String(value)
    }

    fn as_ref(value: &String) -> ReflectValueRef {
        ReflectValueRef::String(&*value)
    }

    fn as_mut(_value: &mut Self::Value) -> ReflectValueMut {
        unimplemented!()
    }

    fn is_non_zero(value: &String) -> bool {
        !value.is_empty()
    }

    fn get_from_unknown(unknown: UnknownValueRef, field_type: Type) -> Option<Self::Value> {
        assert_eq!(field_type, Type::TYPE_STRING);
        ProtobufTypeString::get_from_unknown(unknown)
    }
}
impl RuntimeTypeWithDeref for RuntimeTypeString {
    type DerefTarget = str;

    fn deref_as_ref(value: &str) -> ReflectValueRef {
        ReflectValueRef::String(value)
    }
}
impl RuntimeTypeHashable for RuntimeTypeString {
    fn hash_map_get<'a, V>(map: &'a HashMap<String, V>, key: ReflectValueRef) -> Option<&'a V> {
        match key {
            ReflectValueRef::String(s) => map.get(*&s),
            _ => None,
        }
    }
}

impl RuntimeTypeTrait for RuntimeTypeVecU8 {
    type Value = Vec<u8>;

    fn runtime_type_box() -> RuntimeType
    where
        Self: Sized,
    {
        RuntimeType::VecU8
    }

    fn default_value_ref() -> ReflectValueRef<'static> {
        ReflectValueRef::Bytes(b"")
    }

    fn from_value_box(value_box: ReflectValueBox) -> Result<Vec<u8>, ReflectValueBox> {
        match value_box {
            ReflectValueBox::Bytes(v) => Ok(v),
            b => Err(b),
        }
    }

    fn into_value_box(value: Vec<u8>) -> ReflectValueBox {
        ReflectValueBox::Bytes(value)
    }

    fn as_ref(value: &Vec<u8>) -> ReflectValueRef {
        ReflectValueRef::Bytes(value.as_slice())
    }

    fn as_mut(_value: &mut Self::Value) -> ReflectValueMut {
        unimplemented!()
    }

    fn is_non_zero(value: &Vec<u8>) -> bool {
        !value.is_empty()
    }

    fn get_from_unknown(unknown: UnknownValueRef, field_type: Type) -> Option<Self::Value> {
        assert_eq!(field_type, Type::TYPE_BYTES);
        ProtobufTypeBytes::get_from_unknown(unknown)
    }
}
impl RuntimeTypeWithDeref for RuntimeTypeVecU8 {
    type DerefTarget = [u8];

    fn deref_as_ref(value: &[u8]) -> ReflectValueRef {
        ReflectValueRef::Bytes(value)
    }
}

#[cfg(feature = "bytes")]
impl RuntimeTypeTrait for RuntimeTypeTokioBytes {
    type Value = Bytes;

    fn default_value_ref() -> ReflectValueRef<'static> {
        ReflectValueRef::Bytes(b"")
    }

    fn runtime_type_box() -> RuntimeType
    where
        Self: Sized,
    {
        RuntimeType::VecU8
    }

    fn from_value_box(value_box: ReflectValueBox) -> Result<Bytes, ReflectValueBox> {
        match value_box {
            ReflectValueBox::Bytes(v) => Ok(v.into()),
            b => Err(b),
        }
    }

    fn into_value_box(value: Bytes) -> ReflectValueBox {
        // TODO: copies here
        ReflectValueBox::Bytes(value.as_ref().to_owned())
    }

    fn as_ref(value: &Bytes) -> ReflectValueRef {
        ReflectValueRef::Bytes(value.as_ref())
    }

    fn is_non_zero(value: &Bytes) -> bool {
        !value.is_empty()
    }

    fn as_mut(_value: &mut Self::Value) -> ReflectValueMut {
        unimplemented!()
    }

    fn get_from_unknown(unknown: UnknownValueRef, field_type: Type) -> Option<Self::Value> {
        assert_eq!(field_type, Type::TYPE_BYTES);
        ProtobufTypeTokioBytes::get_from_unknown(unknown)
    }
}
#[cfg(feature = "bytes")]
impl RuntimeTypeWithDeref for RuntimeTypeTokioBytes {
    type DerefTarget = [u8];

    fn deref_as_ref(value: &[u8]) -> ReflectValueRef {
        ReflectValueRef::Bytes(value)
    }
}

#[cfg(feature = "bytes")]
impl RuntimeTypeTrait for RuntimeTypeTokioChars {
    type Value = Chars;

    fn default_value_ref() -> ReflectValueRef<'static> {
        ReflectValueRef::String("")
    }

    fn runtime_type_box() -> RuntimeType
    where
        Self: Sized,
    {
        RuntimeType::String
    }

    fn from_value_box(value_box: ReflectValueBox) -> Result<Chars, ReflectValueBox> {
        match value_box {
            ReflectValueBox::String(v) => Ok(v.into()),
            b => Err(b),
        }
    }

    fn into_value_box(value: Chars) -> ReflectValueBox {
        ReflectValueBox::String(value.into())
    }

    fn as_ref(value: &Chars) -> ReflectValueRef {
        ReflectValueRef::String(value.as_ref())
    }

    fn is_non_zero(value: &Chars) -> bool {
        !value.is_empty()
    }

    fn as_mut(_value: &mut Self::Value) -> ReflectValueMut {
        unimplemented!()
    }

    fn get_from_unknown(unknown: UnknownValueRef, field_type: Type) -> Option<Self::Value> {
        assert_eq!(field_type, Type::TYPE_STRING);
        ProtobufTypeTokioChars::get_from_unknown(unknown)
    }
}
#[cfg(feature = "bytes")]
impl RuntimeTypeWithDeref for RuntimeTypeTokioChars {
    type DerefTarget = str;

    fn deref_as_ref(value: &str) -> ReflectValueRef {
        ReflectValueRef::String(value)
    }
}
#[cfg(feature = "bytes")]
impl RuntimeTypeHashable for RuntimeTypeTokioChars {
    fn hash_map_get<'a, V>(map: &'a HashMap<Chars, V>, key: ReflectValueRef) -> Option<&'a V> {
        match key {
            ReflectValueRef::String(s) => map.get(&*s),
            _ => None,
        }
    }
}

impl<E> RuntimeTypeTrait for RuntimeTypeEnumOrUnknown<E>
where
    E: EnumFull + fmt::Debug,
{
    type Value = EnumOrUnknown<E>;

    fn runtime_type_box() -> RuntimeType
    where
        Self: Sized,
    {
        RuntimeType::Enum(E::enum_descriptor())
    }

    fn default_value_ref() -> ReflectValueRef<'static> {
        ReflectValueRef::from(E::enum_descriptor().default_value())
    }

    fn from_value_box(value_box: ReflectValueBox) -> Result<EnumOrUnknown<E>, ReflectValueBox> {
        match value_box {
            ReflectValueBox::Enum(d, v) if d == E::enum_descriptor() => {
                Ok(EnumOrUnknown::from_i32(v))
            }
            b => Err(b),
        }
    }

    fn into_value_box(value: EnumOrUnknown<E>) -> ReflectValueBox {
        ReflectValueBox::Enum(E::enum_descriptor(), value.value())
    }

    fn into_static_value_ref(value: EnumOrUnknown<E>) -> ReflectValueRef<'static> {
        ReflectValueRef::Enum(E::enum_descriptor(), value.value())
    }

    fn as_ref(value: &EnumOrUnknown<E>) -> ReflectValueRef {
        ReflectValueRef::Enum(E::enum_descriptor(), value.value())
    }

    fn as_mut(_value: &mut Self::Value) -> ReflectValueMut {
        unimplemented!()
    }

    fn is_non_zero(value: &EnumOrUnknown<E>) -> bool {
        value.value() != 0
    }

    fn cast_to_enum_values(values: &[EnumOrUnknown<E>]) -> &[i32] {
        EnumOrUnknown::cast_to_values(values)
    }

    fn get_from_unknown(unknown: UnknownValueRef, field_type: Type) -> Option<Self::Value> {
        assert_eq!(field_type, Type::TYPE_ENUM);
        ProtobufTypeEnumOrUnknown::<E>::get_from_unknown(unknown)
    }
}

impl<M> RuntimeTypeTrait for RuntimeTypeMessage<M>
where
    M: MessageFull + ProtobufValue + Clone + Default,
{
    type Value = M;

    fn runtime_type_box() -> RuntimeType
    where
        Self: Sized,
    {
        RuntimeType::Message(M::descriptor())
    }

    fn default_value_ref() -> ReflectValueRef<'static> {
        ReflectValueRef::Message(MessageRef::new(M::default_instance()))
    }

    fn from_value_box(value_box: ReflectValueBox) -> Result<M, ReflectValueBox> {
        match value_box {
            ReflectValueBox::Message(v) => v
                .downcast_box()
                .map(|v| *v)
                .map_err(ReflectValueBox::Message),
            b => Err(b),
        }
    }

    fn into_value_box(value: M) -> ReflectValueBox {
        ReflectValueBox::Message(Box::new(value))
    }
    fn as_ref(value: &M) -> ReflectValueRef {
        ReflectValueRef::Message(MessageRef::new(value))
    }

    fn as_mut(value: &mut M) -> ReflectValueMut {
        ReflectValueMut::Message(value)
    }

    fn is_non_zero(_value: &M) -> bool {
        true
    }

    fn get_from_unknown(unknown: UnknownValueRef, field_type: Type) -> Option<Self::Value> {
        assert_eq!(field_type, Type::TYPE_MESSAGE);
        ProtobufTypeMessage::<M>::get_from_unknown(unknown)
    }
}

'''
'''--- protobuf/src/reflect/service/index.rs ---
use crate::descriptor::MethodDescriptorProto;
use crate::descriptor::ServiceDescriptorProto;
use crate::reflect::field::index::ForwardProtobufTypeBox;
use crate::reflect::file::building::FileDescriptorBuilding;

#[derive(Debug)]
pub(crate) struct ServiceIndex {
    pub(crate) methods: Vec<MethodIndex>,
}

impl ServiceIndex {
    pub(crate) fn index(
        proto: &ServiceDescriptorProto,
        building: &FileDescriptorBuilding,
    ) -> crate::Result<ServiceIndex> {
        let methods = proto
            .method
            .iter()
            .map(|method| MethodIndex::index(method, building))
            .collect::<crate::Result<Vec<_>>>()?;
        Ok(ServiceIndex { methods })
    }
}

#[derive(Debug)]
pub(crate) struct MethodIndex {
    pub(crate) input_type: ForwardProtobufTypeBox,
    pub(crate) output_type: ForwardProtobufTypeBox,
}

impl MethodIndex {
    pub(crate) fn index(
        proto: &MethodDescriptorProto,
        building: &FileDescriptorBuilding,
    ) -> crate::Result<MethodIndex> {
        let input_type = building.resolve_message(proto.input_type())?;
        let output_type = building.resolve_message(proto.output_type())?;
        Ok(MethodIndex {
            input_type,
            output_type,
        })
    }
}

'''
'''--- protobuf/src/reflect/service/mod.rs ---
use crate::descriptor::MethodDescriptorProto;
use crate::descriptor::ServiceDescriptorProto;
use crate::reflect::service::index::MethodIndex;
use crate::reflect::service::index::ServiceIndex;
use crate::reflect::FileDescriptor;
use crate::reflect::MessageDescriptor;

pub(crate) mod index;

/// Dynamic representation of service type.
///
/// Rust-protobuf does not support services (it is not an RPC library),
/// but it support querying service description. Which might be useful
/// for example to generate source files for the services.
/// or to perform invocations dynamically.
#[derive(Clone, Eq, PartialEq)]
pub struct ServiceDescriptor {
    file_descriptor: FileDescriptor,
    index: usize,
}

impl ServiceDescriptor {
    pub(crate) fn new(file_descriptor: FileDescriptor, index: usize) -> ServiceDescriptor {
        ServiceDescriptor {
            file_descriptor,
            index,
        }
    }

    fn index(&self) -> &ServiceIndex {
        &self.file_descriptor.common().services[self.index]
    }

    /// Proto snippet describing this service.
    pub fn proto(&self) -> &ServiceDescriptorProto {
        &self.file_descriptor.proto().service[self.index]
    }

    /// Method descriptors of this service.
    pub fn methods(&self) -> impl Iterator<Item = MethodDescriptor> + '_ {
        let value_len = self.proto().method.len();
        (0..value_len).map(move |index| MethodDescriptor {
            service_descriptor: self.clone(),
            index,
        })
    }
}

/// Service method descriptor.
pub struct MethodDescriptor {
    service_descriptor: ServiceDescriptor,
    index: usize,
}

impl MethodDescriptor {
    fn index(&self) -> &MethodIndex {
        &self.service_descriptor.index().methods[self.index]
    }

    /// Proto snippet describing this method.
    pub fn proto(&self) -> &MethodDescriptorProto {
        &self.service_descriptor.proto().method[self.index]
    }

    /// Method input type.
    pub fn input_type(&self) -> MessageDescriptor {
        self.index()
            .input_type
            .resolve_message(&self.service_descriptor.file_descriptor)
    }

    /// Method output type.
    pub fn output_type(&self) -> MessageDescriptor {
        self.index()
            .output_type
            .resolve_message(&self.service_descriptor.file_descriptor)
    }
}

'''
'''--- protobuf/src/reflect/type_dynamic.rs ---
//! Reflection internals.

use std::marker;

use crate::reflect::runtime_types::RuntimeTypeTrait;
use crate::reflect::types::ProtobufTypeTrait;
use crate::reflect::ProtobufValue;
use crate::reflect::RuntimeType;
use crate::wire_format::WireType;

/// Dynamic version of [`ProtobufType`](crate::reflect::types::ProtobufType).
///
/// This is used internally.
pub trait ProtobufTypeDynamic: Send + Sync + 'static {
    /// Wire type for this type.
    fn wire_type(&self) -> WireType;

    /// Get runtime type for this protobuf type.
    fn runtime_type(&self) -> RuntimeType;
}

pub(crate) struct ProtobufTypeDynamicImpl<T: ProtobufTypeTrait>(pub marker::PhantomData<T>);

impl<T> ProtobufTypeDynamic for ProtobufTypeDynamicImpl<T>
where
    T: ProtobufTypeTrait,
    <T as ProtobufTypeTrait>::ProtobufValue: ProtobufValue,
{
    fn wire_type(&self) -> WireType {
        T::WIRE_TYPE
    }

    fn runtime_type(&self) -> RuntimeType {
        <T::ProtobufValue as ProtobufValue>::RuntimeType::runtime_type_box()
    }
}

'''
'''--- protobuf/src/reflect/types.rs ---
//! Implementations of `ProtobufType` for all types.

#![doc(hidden)]

use std::marker;

#[cfg(feature = "bytes")]
use ::bytes::Bytes;

#[cfg(feature = "bytes")]
use crate::chars::Chars;
use crate::coded_input_stream::CodedInputStream;
use crate::coded_output_stream::CodedOutputStream;
use crate::enums::Enum;
use crate::error::Result;
pub use crate::reflect::type_dynamic::ProtobufTypeDynamic;
use crate::reflect::type_dynamic::ProtobufTypeDynamicImpl;
use crate::reflect::ProtobufValue;
use crate::rt;
use crate::rt::singular::value_varint_zigzag_size_no_tag;
use crate::wire_format::WireType;
use crate::zigzag::decode_zig_zag_32;
use crate::zigzag::decode_zig_zag_64;
use crate::EnumOrUnknown;
use crate::Message;
use crate::UnknownValueRef;

/// Encapsulate type-specific serialization and conversion logic
pub(crate) trait ProtobufTypeTrait: Send + Sync + Clone + Sized + 'static {
    /// Rust type for this protobuf type.
    type ProtobufValue: Default;

    /// Dynamic version of this
    fn dynamic() -> &'static dyn ProtobufTypeDynamic
    where
        Self::ProtobufValue: ProtobufValue,
    {
        &ProtobufTypeDynamicImpl::<Self>(marker::PhantomData)
    }

    /// Wire type for encoding objects of this type
    const WIRE_TYPE: WireType;

    /// Read a value from `CodedInputStream`
    fn read(is: &mut CodedInputStream) -> Result<Self::ProtobufValue>;

    /// Take a value from `UnknownValues`
    fn get_from_unknown(_unknown: UnknownValueRef) -> Option<Self::ProtobufValue>;

    /// Compute serialized size of a value
    fn compute_size(value: &Self::ProtobufValue) -> u64;

    /// Compute size adding length prefix if wire type is length delimited
    /// (i. e. string, bytes, message)
    fn compute_size_with_length_delimiter(value: &Self::ProtobufValue) -> u64 {
        let size = Self::compute_size(value);
        if Self::WIRE_TYPE == WireType::LengthDelimited {
            rt::compute_raw_varint64_size(size) + size
        } else {
            size
        }
    }

    /// Get previously computed size
    #[inline]
    fn get_cached_size(value: &Self::ProtobufValue) -> u32 {
        Self::compute_size(value) as u32
    }

    /// Get previously cached size with length prefix
    #[inline]
    fn get_cached_size_with_length_delimiter(value: &Self::ProtobufValue) -> u32 {
        let size = Self::get_cached_size(value);
        if Self::WIRE_TYPE == WireType::LengthDelimited {
            rt::compute_raw_varint32_size(size) as u32 + size
        } else {
            size
        }
    }

    /// Write a value with previously cached size
    fn write_with_cached_size(
        field_number: u32,
        value: &Self::ProtobufValue,
        os: &mut CodedOutputStream,
    ) -> Result<()>;
}

/// All fixed size types
pub(crate) trait ProtobufTypeFixed: ProtobufTypeTrait {
    /// Encoded size of value in bytes of this type.
    ///
    /// E. g. it is `4` for `fixed32`
    const ENCODED_SIZE: u32;
}

/// `float`
#[derive(Copy, Clone)]
pub struct ProtobufTypeFloat;
/// `double`
#[derive(Copy, Clone)]
pub struct ProtobufTypeDouble;
/// `int32`
#[derive(Copy, Clone)]
pub struct ProtobufTypeInt32;
/// `int64`
#[derive(Copy, Clone)]
pub struct ProtobufTypeInt64;
/// `uint32`
#[derive(Copy, Clone)]
pub struct ProtobufTypeUint32;
/// `uint64`
#[derive(Copy, Clone)]
pub struct ProtobufTypeUint64;
/// `sint32`
#[derive(Copy, Clone)]
pub struct ProtobufTypeSint32;
/// `sint64`
#[derive(Copy, Clone)]
pub struct ProtobufTypeSint64;
/// `fixed32`
#[derive(Copy, Clone)]
pub struct ProtobufTypeFixed32;
/// `fixed64`
#[derive(Copy, Clone)]
pub struct ProtobufTypeFixed64;
/// `sfixed32`
#[derive(Copy, Clone)]
pub struct ProtobufTypeSfixed32;
/// `sfixed64`
#[derive(Copy, Clone)]
pub struct ProtobufTypeSfixed64;
/// `bool`
#[derive(Copy, Clone)]
pub struct ProtobufTypeBool;
/// `string`
#[derive(Copy, Clone)]
pub struct ProtobufTypeString;
/// `bytes`
#[derive(Copy, Clone)]
pub struct ProtobufTypeBytes;

/// `bytes` as [`Bytes`](bytes::Bytes)
#[cfg(feature = "bytes")]
#[derive(Copy, Clone)]
pub struct ProtobufTypeTokioBytes;
/// `string` as [`Chars`](crate::Chars)
#[cfg(feature = "bytes")]
#[derive(Copy, Clone)]
pub struct ProtobufTypeTokioChars;

/// `enum` as `ProtobufEnumOrUnknown`
#[derive(Copy, Clone)]
pub struct ProtobufTypeEnumOrUnknown<E: Enum>(marker::PhantomData<E>);
/// `message`
#[derive(Copy, Clone)]
pub struct ProtobufTypeMessage<M: Message>(marker::PhantomData<M>);

impl ProtobufTypeTrait for ProtobufTypeFloat {
    type ProtobufValue = f32;

    const WIRE_TYPE: WireType = WireType::Fixed32;

    fn read(is: &mut CodedInputStream) -> Result<f32> {
        is.read_float()
    }

    fn get_from_unknown(unknown: UnknownValueRef) -> Option<f32> {
        match unknown {
            UnknownValueRef::Fixed32(v) => Some(f32::from_bits(v)),
            _ => None,
        }
    }

    fn compute_size(_value: &f32) -> u64 {
        Self::ENCODED_SIZE as u64
    }

    fn write_with_cached_size(
        field_number: u32,
        value: &f32,
        os: &mut CodedOutputStream,
    ) -> Result<()> {
        os.write_float(field_number, *value)
    }
}

impl ProtobufTypeFixed for ProtobufTypeFloat {
    const ENCODED_SIZE: u32 = 4;
}

impl ProtobufTypeTrait for ProtobufTypeDouble {
    type ProtobufValue = f64;

    const WIRE_TYPE: WireType = WireType::Fixed64;

    fn read(is: &mut CodedInputStream) -> Result<f64> {
        is.read_double()
    }

    fn get_from_unknown(unknown: UnknownValueRef) -> Option<f64> {
        match unknown {
            UnknownValueRef::Fixed64(v) => Some(f64::from_bits(v)),
            _ => None,
        }
    }

    fn compute_size(_value: &f64) -> u64 {
        Self::ENCODED_SIZE as u64
    }

    fn write_with_cached_size(
        field_number: u32,
        value: &f64,
        os: &mut CodedOutputStream,
    ) -> Result<()> {
        os.write_double(field_number, *value)
    }
}

impl ProtobufTypeFixed for ProtobufTypeDouble {
    const ENCODED_SIZE: u32 = 8;
}

impl ProtobufTypeTrait for ProtobufTypeInt32 {
    type ProtobufValue = i32;

    const WIRE_TYPE: WireType = WireType::Varint;

    fn read(is: &mut CodedInputStream) -> Result<i32> {
        is.read_int32()
    }

    fn compute_size(value: &i32) -> u64 {
        // See also: https://github.com/protocolbuffers/protobuf/blob/bd00671b924310c0353a730bf8fa77c44e0a9c72/src/google/protobuf/io/coded_stream.h#L1300-L1306
        if *value < 0 {
            return 10;
        }
        rt::compute_raw_varint32_size(*value as u32)
    }

    fn write_with_cached_size(
        field_number: u32,
        value: &i32,
        os: &mut CodedOutputStream,
    ) -> Result<()> {
        os.write_int32(field_number, *value)
    }

    fn get_from_unknown(unknown: UnknownValueRef) -> Option<i32> {
        match unknown {
            UnknownValueRef::Varint(v) => Some(v as i32),
            _ => None,
        }
    }
}

impl ProtobufTypeTrait for ProtobufTypeInt64 {
    type ProtobufValue = i64;

    const WIRE_TYPE: WireType = WireType::Varint;

    fn read(is: &mut CodedInputStream) -> Result<i64> {
        is.read_int64()
    }

    fn get_from_unknown(unknown: UnknownValueRef) -> Option<i64> {
        match unknown {
            UnknownValueRef::Varint(v) => Some(v as i64),
            _ => None,
        }
    }

    fn compute_size(value: &i64) -> u64 {
        rt::compute_raw_varint64_size(*value as u64)
    }

    fn write_with_cached_size(
        field_number: u32,
        value: &i64,
        os: &mut CodedOutputStream,
    ) -> Result<()> {
        os.write_int64(field_number, *value)
    }
}

impl ProtobufTypeTrait for ProtobufTypeUint32 {
    type ProtobufValue = u32;

    const WIRE_TYPE: WireType = WireType::Varint;

    fn read(is: &mut CodedInputStream) -> Result<u32> {
        is.read_uint32()
    }

    fn get_from_unknown(unknown: UnknownValueRef) -> Option<u32> {
        match unknown {
            UnknownValueRef::Varint(v) => Some(v as u32),
            _ => None,
        }
    }

    fn compute_size(value: &u32) -> u64 {
        rt::compute_raw_varint32_size(*value)
    }

    fn write_with_cached_size(
        field_number: u32,
        value: &u32,
        os: &mut CodedOutputStream,
    ) -> Result<()> {
        os.write_uint32(field_number, *value)
    }
}

impl ProtobufTypeTrait for ProtobufTypeUint64 {
    type ProtobufValue = u64;

    const WIRE_TYPE: WireType = WireType::Varint;

    fn read(is: &mut CodedInputStream) -> Result<u64> {
        is.read_uint64()
    }

    fn get_from_unknown(unknown: UnknownValueRef) -> Option<u64> {
        match unknown {
            UnknownValueRef::Varint(v) => Some(v as u64),
            _ => None,
        }
    }

    fn compute_size(value: &u64) -> u64 {
        rt::compute_raw_varint64_size(*value)
    }

    fn write_with_cached_size(
        field_number: u32,
        value: &u64,
        os: &mut CodedOutputStream,
    ) -> Result<()> {
        os.write_uint64(field_number, *value)
    }
}

impl ProtobufTypeTrait for ProtobufTypeSint32 {
    type ProtobufValue = i32;

    const WIRE_TYPE: WireType = WireType::Varint;

    fn read(is: &mut CodedInputStream) -> Result<i32> {
        is.read_sint32()
    }

    fn get_from_unknown(unknown: UnknownValueRef) -> Option<i32> {
        ProtobufTypeUint32::get_from_unknown(unknown).map(decode_zig_zag_32)
    }

    fn compute_size(value: &i32) -> u64 {
        value_varint_zigzag_size_no_tag(*value)
    }

    fn write_with_cached_size(
        field_number: u32,
        value: &i32,
        os: &mut CodedOutputStream,
    ) -> Result<()> {
        os.write_sint32(field_number, *value)
    }
}

impl ProtobufTypeTrait for ProtobufTypeSint64 {
    type ProtobufValue = i64;

    const WIRE_TYPE: WireType = WireType::Varint;

    fn read(is: &mut CodedInputStream) -> Result<i64> {
        is.read_sint64()
    }

    fn get_from_unknown(unknown: UnknownValueRef) -> Option<i64> {
        ProtobufTypeUint64::get_from_unknown(unknown).map(decode_zig_zag_64)
    }

    fn compute_size(value: &i64) -> u64 {
        value_varint_zigzag_size_no_tag(*value)
    }

    fn write_with_cached_size(
        field_number: u32,
        value: &i64,
        os: &mut CodedOutputStream,
    ) -> Result<()> {
        os.write_sint64(field_number, *value)
    }
}

impl ProtobufTypeTrait for ProtobufTypeFixed32 {
    type ProtobufValue = u32;

    const WIRE_TYPE: WireType = WireType::Fixed32;

    fn read(is: &mut CodedInputStream) -> Result<u32> {
        is.read_fixed32()
    }

    fn get_from_unknown(unknown: UnknownValueRef) -> Option<u32> {
        match unknown {
            UnknownValueRef::Fixed32(v) => Some(v),
            _ => None,
        }
    }

    fn compute_size(_value: &u32) -> u64 {
        Self::ENCODED_SIZE as u64
    }

    fn write_with_cached_size(
        field_number: u32,
        value: &u32,
        os: &mut CodedOutputStream,
    ) -> Result<()> {
        os.write_fixed32(field_number, *value)
    }
}

impl ProtobufTypeFixed for ProtobufTypeFixed32 {
    const ENCODED_SIZE: u32 = 4;
}

impl ProtobufTypeTrait for ProtobufTypeFixed64 {
    type ProtobufValue = u64;

    const WIRE_TYPE: WireType = WireType::Fixed64;

    fn read(is: &mut CodedInputStream) -> Result<u64> {
        is.read_fixed64()
    }

    fn get_from_unknown(unknown: UnknownValueRef) -> Option<u64> {
        match unknown {
            UnknownValueRef::Fixed64(v) => Some(v),
            _ => None,
        }
    }

    fn compute_size(_value: &u64) -> u64 {
        Self::ENCODED_SIZE as u64
    }

    fn write_with_cached_size(
        field_number: u32,
        value: &u64,
        os: &mut CodedOutputStream,
    ) -> Result<()> {
        os.write_fixed64(field_number, *value)
    }
}

impl ProtobufTypeFixed for ProtobufTypeFixed64 {
    const ENCODED_SIZE: u32 = 8;
}

impl ProtobufTypeTrait for ProtobufTypeSfixed32 {
    type ProtobufValue = i32;

    const WIRE_TYPE: WireType = WireType::Fixed32;

    fn read(is: &mut CodedInputStream) -> Result<i32> {
        is.read_sfixed32()
    }

    fn get_from_unknown(unknown: UnknownValueRef) -> Option<i32> {
        match unknown {
            UnknownValueRef::Fixed32(v) => Some(v as i32),
            _ => None,
        }
    }

    fn compute_size(_value: &i32) -> u64 {
        Self::ENCODED_SIZE as u64
    }

    fn write_with_cached_size(
        field_number: u32,
        value: &i32,
        os: &mut CodedOutputStream,
    ) -> Result<()> {
        os.write_sfixed32(field_number, *value)
    }
}

impl ProtobufTypeFixed for ProtobufTypeSfixed32 {
    const ENCODED_SIZE: u32 = 4;
}

impl ProtobufTypeTrait for ProtobufTypeSfixed64 {
    type ProtobufValue = i64;

    const WIRE_TYPE: WireType = WireType::Fixed64;

    fn read(is: &mut CodedInputStream) -> Result<i64> {
        is.read_sfixed64()
    }

    fn get_from_unknown(unknown: UnknownValueRef) -> Option<i64> {
        match unknown {
            UnknownValueRef::Fixed64(v) => Some(v as i64),
            _ => None,
        }
    }

    fn compute_size(_value: &i64) -> u64 {
        8
    }

    fn write_with_cached_size(
        field_number: u32,
        value: &i64,
        os: &mut CodedOutputStream,
    ) -> Result<()> {
        os.write_sfixed64(field_number, *value)
    }
}

impl ProtobufTypeFixed for ProtobufTypeSfixed64 {
    const ENCODED_SIZE: u32 = 8;
}

impl ProtobufTypeTrait for ProtobufTypeBool {
    type ProtobufValue = bool;

    const WIRE_TYPE: WireType = WireType::Varint;

    fn read(is: &mut CodedInputStream) -> Result<bool> {
        is.read_bool()
    }

    fn get_from_unknown(unknown: UnknownValueRef) -> Option<bool> {
        match unknown {
            UnknownValueRef::Varint(b) => Some(b != 0),
            _ => None,
        }
    }

    fn compute_size(_value: &bool) -> u64 {
        1
    }

    fn write_with_cached_size(
        field_number: u32,
        value: &bool,
        os: &mut CodedOutputStream,
    ) -> Result<()> {
        os.write_bool(field_number, *value)
    }
}

impl ProtobufTypeTrait for ProtobufTypeString {
    type ProtobufValue = String;

    const WIRE_TYPE: WireType = WireType::LengthDelimited;

    fn read(is: &mut CodedInputStream) -> Result<String> {
        is.read_string()
    }

    fn get_from_unknown(unknown: UnknownValueRef) -> Option<String> {
        match unknown {
            UnknownValueRef::LengthDelimited(v) => String::from_utf8(v.to_vec()).ok(),
            _ => None,
        }
    }

    fn compute_size(value: &String) -> u64 {
        value.len() as u64
    }

    fn write_with_cached_size(
        field_number: u32,
        value: &String,
        os: &mut CodedOutputStream,
    ) -> Result<()> {
        os.write_string(field_number, &value)
    }
}

impl ProtobufTypeTrait for ProtobufTypeBytes {
    type ProtobufValue = Vec<u8>;

    const WIRE_TYPE: WireType = WireType::LengthDelimited;

    fn read(is: &mut CodedInputStream) -> Result<Vec<u8>> {
        is.read_bytes()
    }

    fn get_from_unknown(unknown: UnknownValueRef) -> Option<Vec<u8>> {
        match unknown {
            UnknownValueRef::LengthDelimited(v) => Some(v.to_vec()),
            _ => None,
        }
    }

    fn compute_size(value: &Vec<u8>) -> u64 {
        value.len() as u64
    }

    fn write_with_cached_size(
        field_number: u32,
        value: &Vec<u8>,
        os: &mut CodedOutputStream,
    ) -> Result<()> {
        os.write_bytes(field_number, &value)
    }
}

#[cfg(feature = "bytes")]
impl ProtobufTypeTrait for ProtobufTypeTokioBytes {
    type ProtobufValue = bytes::Bytes;

    const WIRE_TYPE: WireType = ProtobufTypeBytes::WIRE_TYPE;

    fn read(is: &mut CodedInputStream) -> Result<Bytes> {
        is.read_tokio_bytes()
    }

    fn get_from_unknown(unknown: UnknownValueRef) -> Option<Bytes> {
        ProtobufTypeBytes::get_from_unknown(unknown).map(Bytes::from)
    }

    fn compute_size(value: &Bytes) -> u64 {
        value.len() as u64
    }

    fn write_with_cached_size(
        field_number: u32,
        value: &Bytes,
        os: &mut CodedOutputStream,
    ) -> Result<()> {
        os.write_bytes(field_number, &value)
    }
}

#[cfg(feature = "bytes")]
impl ProtobufTypeTrait for ProtobufTypeTokioChars {
    type ProtobufValue = Chars;

    const WIRE_TYPE: WireType = ProtobufTypeBytes::WIRE_TYPE;

    fn read(is: &mut CodedInputStream) -> Result<Chars> {
        is.read_tokio_chars()
    }

    fn get_from_unknown(unknown: UnknownValueRef) -> Option<Chars> {
        ProtobufTypeString::get_from_unknown(unknown).map(Chars::from)
    }

    fn compute_size(value: &Chars) -> u64 {
        value.len() as u64
    }

    fn write_with_cached_size(
        field_number: u32,
        value: &Chars,
        os: &mut CodedOutputStream,
    ) -> Result<()> {
        os.write_string(field_number, &value)
    }
}

impl<E: Enum> ProtobufTypeTrait for ProtobufTypeEnumOrUnknown<E> {
    type ProtobufValue = EnumOrUnknown<E>;

    const WIRE_TYPE: WireType = WireType::Varint;

    fn read(is: &mut CodedInputStream) -> Result<EnumOrUnknown<E>> {
        is.read_enum_or_unknown()
    }

    fn get_from_unknown(unknown: UnknownValueRef) -> Option<EnumOrUnknown<E>> {
        ProtobufTypeInt32::get_from_unknown(unknown).map(|i| EnumOrUnknown::from_i32(i))
    }

    fn compute_size(value: &EnumOrUnknown<E>) -> u64 {
        ProtobufTypeInt32::compute_size(&value.value())
    }

    fn write_with_cached_size(
        field_number: u32,
        value: &EnumOrUnknown<E>,
        os: &mut CodedOutputStream,
    ) -> Result<()> {
        os.write_enum_or_unknown(field_number, *value)
    }
}

impl<M: Message + Clone + Default> ProtobufTypeTrait for ProtobufTypeMessage<M> {
    type ProtobufValue = M;

    const WIRE_TYPE: WireType = WireType::LengthDelimited;

    fn read(is: &mut CodedInputStream) -> Result<M> {
        is.read_message()
    }

    fn get_from_unknown(unknown: UnknownValueRef) -> Option<M> {
        match unknown {
            UnknownValueRef::LengthDelimited(v) => M::parse_from_bytes(&v).ok(),
            _ => None,
        }
    }

    fn compute_size(value: &M) -> u64 {
        value.compute_size()
    }

    fn get_cached_size(value: &M) -> u32 {
        value.cached_size()
    }

    fn write_with_cached_size(
        field_number: u32,
        value: &Self::ProtobufValue,
        os: &mut CodedOutputStream,
    ) -> Result<()> {
        os.write_tag(field_number, WireType::LengthDelimited)?;
        os.write_raw_varint32(value.cached_size())?;
        value.write_to_with_cached_sizes(os)?;
        Ok(())
    }
}

'''
'''--- protobuf/src/reflect/value/mod.rs ---
use std::fmt;

#[cfg(feature = "bytes")]
use ::bytes::Bytes;

#[cfg(feature = "bytes")]
use crate::chars::Chars;
use crate::reflect::runtime_types::RuntimeTypeBool;
use crate::reflect::runtime_types::RuntimeTypeF32;
use crate::reflect::runtime_types::RuntimeTypeF64;
use crate::reflect::runtime_types::RuntimeTypeI32;
use crate::reflect::runtime_types::RuntimeTypeI64;
use crate::reflect::runtime_types::RuntimeTypeString;
#[cfg(feature = "bytes")]
use crate::reflect::runtime_types::RuntimeTypeTokioBytes;
#[cfg(feature = "bytes")]
use crate::reflect::runtime_types::RuntimeTypeTokioChars;
use crate::reflect::runtime_types::RuntimeTypeTrait;
use crate::reflect::runtime_types::RuntimeTypeU32;
use crate::reflect::runtime_types::RuntimeTypeU64;
use crate::reflect::runtime_types::RuntimeTypeVecU8;

pub(crate) mod value_box;
pub(crate) mod value_ref;

/// Type implemented by all protobuf singular types
/// (primitives, string, messages, enums).
///
/// Used in reflection.
pub trait ProtobufValue: Clone + Default + fmt::Debug + Send + Sync + Sized + 'static {
    /// Actual implementation of type properties.
    type RuntimeType: RuntimeTypeTrait<Value = Self>;
}

impl ProtobufValue for u32 {
    type RuntimeType = RuntimeTypeU32;
}

impl ProtobufValue for u64 {
    type RuntimeType = RuntimeTypeU64;
}

impl ProtobufValue for i32 {
    type RuntimeType = RuntimeTypeI32;
}

impl ProtobufValue for i64 {
    type RuntimeType = RuntimeTypeI64;
}

impl ProtobufValue for f32 {
    type RuntimeType = RuntimeTypeF32;
}

impl ProtobufValue for f64 {
    type RuntimeType = RuntimeTypeF64;
}

impl ProtobufValue for bool {
    type RuntimeType = RuntimeTypeBool;
}

impl ProtobufValue for String {
    type RuntimeType = RuntimeTypeString;
}

impl ProtobufValue for Vec<u8> {
    type RuntimeType = RuntimeTypeVecU8;
}

#[cfg(feature = "bytes")]
impl ProtobufValue for Bytes {
    type RuntimeType = RuntimeTypeTokioBytes;
}

#[cfg(feature = "bytes")]
impl ProtobufValue for Chars {
    type RuntimeType = RuntimeTypeTokioChars;
}

// conflicting implementations, so generated code is used instead
/*
impl<E : ProtobufEnum> ProtobufValue for E {
}

impl<M : Message> ProtobufValue for M {
}
*/

'''
'''--- protobuf/src/reflect/value/value_box.rs ---
use crate::reflect::message::message_ref::MessageRef;
use crate::reflect::runtime_types::RuntimeTypeTrait;
use crate::reflect::value::value_ref::ReflectValueMut;
use crate::reflect::value::value_ref::ReflectValueRef;
use crate::reflect::EnumDescriptor;
use crate::reflect::EnumValueDescriptor;
use crate::reflect::ProtobufValue;
use crate::reflect::RuntimeType;
use crate::MessageDyn;

/// Owner value of any elementary type
#[derive(Debug, Clone)]
pub enum ReflectValueBox {
    /// `u32`
    U32(u32),
    /// `u64`
    U64(u64),
    /// `i32`
    I32(i32),
    /// `i64`
    I64(i64),
    /// `f32`
    F32(f32),
    /// `f64`
    F64(f64),
    /// `bool`
    Bool(bool),
    /// `string`
    String(String),
    /// `bytes`
    Bytes(Vec<u8>),
    /// `enum`
    Enum(EnumDescriptor, i32),
    /// `message`
    Message(Box<dyn MessageDyn>),
}

impl From<u32> for ReflectValueBox {
    fn from(v: u32) -> Self {
        ReflectValueBox::U32(v)
    }
}

impl From<u64> for ReflectValueBox {
    fn from(v: u64) -> Self {
        ReflectValueBox::U64(v)
    }
}

impl From<i32> for ReflectValueBox {
    fn from(v: i32) -> Self {
        ReflectValueBox::I32(v)
    }
}

impl From<i64> for ReflectValueBox {
    fn from(v: i64) -> Self {
        ReflectValueBox::I64(v)
    }
}

impl From<f32> for ReflectValueBox {
    fn from(v: f32) -> Self {
        ReflectValueBox::F32(v)
    }
}

impl From<f64> for ReflectValueBox {
    fn from(v: f64) -> Self {
        ReflectValueBox::F64(v)
    }
}

impl From<bool> for ReflectValueBox {
    fn from(v: bool) -> Self {
        ReflectValueBox::Bool(v)
    }
}

impl From<String> for ReflectValueBox {
    fn from(v: String) -> Self {
        ReflectValueBox::String(v)
    }
}

impl From<Vec<u8>> for ReflectValueBox {
    fn from(v: Vec<u8>) -> Self {
        ReflectValueBox::Bytes(v)
    }
}

impl<'a> From<&'a EnumValueDescriptor> for ReflectValueBox {
    fn from(v: &'a EnumValueDescriptor) -> Self {
        ReflectValueBox::from(v.clone())
    }
}

impl From<EnumValueDescriptor> for ReflectValueBox {
    fn from(v: EnumValueDescriptor) -> Self {
        let number = v.value();
        ReflectValueBox::Enum(v.enum_descriptor, number)
    }
}

impl From<Box<dyn MessageDyn>> for ReflectValueBox {
    fn from(v: Box<dyn MessageDyn>) -> Self {
        ReflectValueBox::Message(v)
    }
}

fn _assert_value_box_send_sync() {
    fn _assert_send_sync<T: Send + Sync>() {}
    _assert_send_sync::<ReflectValueBox>();
}

impl ReflectValueBox {
    /// Type of this value.
    pub fn get_type(&self) -> RuntimeType {
        self.as_value_ref().get_type()
    }

    /// As ref
    pub fn as_value_ref(&self) -> ReflectValueRef {
        match self {
            ReflectValueBox::U32(v) => ReflectValueRef::U32(*v),
            ReflectValueBox::U64(v) => ReflectValueRef::U64(*v),
            ReflectValueBox::I32(v) => ReflectValueRef::I32(*v),
            ReflectValueBox::I64(v) => ReflectValueRef::I64(*v),
            ReflectValueBox::F32(v) => ReflectValueRef::F32(*v),
            ReflectValueBox::F64(v) => ReflectValueRef::F64(*v),
            ReflectValueBox::Bool(v) => ReflectValueRef::Bool(*v),
            ReflectValueBox::String(ref v) => ReflectValueRef::String(v.as_str()),
            ReflectValueBox::Bytes(ref v) => ReflectValueRef::Bytes(v.as_slice()),
            ReflectValueBox::Enum(d, v) => ReflectValueRef::Enum(d.clone(), *v),
            ReflectValueBox::Message(v) => ReflectValueRef::Message(MessageRef::from(&**v)),
        }
    }

    pub(crate) fn as_value_mut(&mut self) -> ReflectValueMut {
        match self {
            ReflectValueBox::Message(m) => ReflectValueMut::Message(&mut **m),
            _ => panic!(
                "ReflectValueMut cannot be constructed from {:?}",
                self.get_type()
            ),
        }
    }

    /// Downcast to real typed value.
    ///
    /// For `enum` `V` can be either `V: ProtobufEnum` or `V: ProtobufEnumOrUnknown<E>`.
    pub fn downcast<V: ProtobufValue>(self) -> Result<V, Self> {
        V::RuntimeType::from_value_box(self)
    }
}

impl<'a> PartialEq for ReflectValueBox {
    fn eq(&self, other: &Self) -> bool {
        self.as_value_ref() == other.as_value_ref()
    }
}

impl<'a> PartialEq<ReflectValueBox> for ReflectValueRef<'a> {
    fn eq(&self, other: &ReflectValueBox) -> bool {
        *self == other.as_value_ref()
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn reflect_value_box_downcast_primitive() {
        assert_eq!(Ok(10), ReflectValueBox::U32(10).downcast::<u32>());
        assert_eq!(
            Err(ReflectValueBox::I32(10)),
            ReflectValueBox::I32(10).downcast::<u32>()
        );
    }

    #[test]
    fn reflect_value_box_downcast_string() {
        assert_eq!(
            Ok("aa".to_owned()),
            ReflectValueBox::String("aa".to_owned()).downcast::<String>()
        );
        assert_eq!(
            Err(ReflectValueBox::String("aa".to_owned())),
            ReflectValueBox::String("aa".to_owned()).downcast::<u32>()
        );
        assert_eq!(
            Err(ReflectValueBox::Bool(false)),
            ReflectValueBox::Bool(false).downcast::<String>()
        );
    }
}

'''
'''--- protobuf/src/reflect/value/value_ref.rs ---
use std::fmt;
use std::hash::Hash;
use std::hash::Hasher;
use std::mem;

use crate::reflect::value::value_box::ReflectValueBox;
use crate::reflect::EnumDescriptor;
use crate::reflect::EnumValueDescriptor;
use crate::reflect::MessageDescriptor;
use crate::reflect::MessageRef;
use crate::reflect::ProtobufValue;
use crate::reflect::ReflectEq;
use crate::reflect::ReflectEqMode;
use crate::reflect::RuntimeType;
use crate::MessageDyn;

/// A reference to a value
#[derive(Debug, Clone)]
pub enum ReflectValueRef<'a> {
    /// `u32`
    U32(u32),
    /// `u64`
    U64(u64),
    /// `i32`
    I32(i32),
    /// `i64`
    I64(i64),
    /// `f32`
    F32(f32),
    /// `f64`
    F64(f64),
    /// `bool`
    Bool(bool),
    /// `string`
    String(&'a str),
    /// `bytes`
    Bytes(&'a [u8]),
    /// `enum`
    Enum(
        EnumDescriptor,
        /// Enum value.
        ///
        /// Note when `allow_alias` option is enabled, more than one enum variant
        /// may have the same value.
        i32,
    ),
    /// `message`
    Message(MessageRef<'a>),
}

impl<'a> fmt::Display for ReflectValueRef<'a> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            ReflectValueRef::U32(v) => write!(f, "{}", v),
            ReflectValueRef::U64(v) => write!(f, "{}", v),
            ReflectValueRef::I32(v) => write!(f, "{}", v),
            ReflectValueRef::I64(v) => write!(f, "{}", v),
            ReflectValueRef::F32(v) => write!(f, "{}", v),
            ReflectValueRef::F64(v) => write!(f, "{}", v),
            ReflectValueRef::Bool(v) => write!(f, "{}", v),
            ReflectValueRef::String(v) => write!(f, "{}", v),
            // TODO: better display
            ReflectValueRef::Bytes(v) => write!(f, "{:?}", v),
            ReflectValueRef::Enum(descriptor, value) => match descriptor.value_by_number(*value) {
                Some(v) => write!(f, "{}", v.name()),
                None => write!(f, "{}", value),
            },
            ReflectValueRef::Message(msg) => write!(f, "{}", msg),
        }
    }
}

impl<'a> ReflectValueRef<'a> {
    /// Get type of this value.
    pub fn get_type(&self) -> RuntimeType {
        match self {
            ReflectValueRef::U32(..) => RuntimeType::U32,
            ReflectValueRef::U64(..) => RuntimeType::U64,
            ReflectValueRef::I32(..) => RuntimeType::I32,
            ReflectValueRef::I64(..) => RuntimeType::I64,
            ReflectValueRef::F32(..) => RuntimeType::F32,
            ReflectValueRef::F64(..) => RuntimeType::F64,
            ReflectValueRef::Bool(..) => RuntimeType::Bool,
            ReflectValueRef::String(..) => RuntimeType::String,
            ReflectValueRef::Bytes(..) => RuntimeType::VecU8,
            ReflectValueRef::Enum(d, ..) => RuntimeType::Enum(d.clone()),
            ReflectValueRef::Message(m) => RuntimeType::Message(m.descriptor_dyn()),
        }
    }

    /// Value is "non-zero"?
    pub(crate) fn is_non_zero(&self) -> bool {
        match self {
            ReflectValueRef::U32(v) => *v != 0,
            ReflectValueRef::U64(v) => *v != 0,
            ReflectValueRef::I32(v) => *v != 0,
            ReflectValueRef::I64(v) => *v != 0,
            ReflectValueRef::F32(v) => *v != 0.,
            ReflectValueRef::F64(v) => *v != 0.,
            ReflectValueRef::Bool(v) => *v,
            ReflectValueRef::String(v) => !v.is_empty(),
            ReflectValueRef::Bytes(v) => !v.is_empty(),
            ReflectValueRef::Enum(_d, v) => *v != 0,
            ReflectValueRef::Message(_) => true,
        }
    }

    pub(crate) fn is_initialized(&self) -> bool {
        if let ReflectValueRef::Message(m) = self {
            m.is_initialized_dyn()
        } else {
            true
        }
    }

    /// Take `i32` value.
    pub fn to_i32(&self) -> Option<i32> {
        match *self {
            ReflectValueRef::I32(v) => Some(v),
            _ => None,
        }
    }

    /// Take `i64` value.
    pub fn to_i64(&self) -> Option<i64> {
        match *self {
            ReflectValueRef::I64(v) => Some(v),
            _ => None,
        }
    }

    /// Take `u32` value.
    pub fn to_u32(&self) -> Option<u32> {
        match *self {
            ReflectValueRef::U32(v) => Some(v),
            _ => None,
        }
    }

    /// Take `u64` value.
    pub fn to_u64(&self) -> Option<u64> {
        match *self {
            ReflectValueRef::U64(v) => Some(v),
            _ => None,
        }
    }

    /// Take `f32` value.
    pub fn to_f32(&self) -> Option<f32> {
        match *self {
            ReflectValueRef::F32(v) => Some(v),
            _ => None,
        }
    }

    /// Take `f64` value.
    pub fn to_f64(&self) -> Option<f64> {
        match *self {
            ReflectValueRef::F64(v) => Some(v),
            _ => None,
        }
    }

    /// Take `bool` value.
    pub fn to_bool(&self) -> Option<bool> {
        match *self {
            ReflectValueRef::Bool(v) => Some(v),
            _ => None,
        }
    }

    /// Take `str` value.
    pub fn to_str(&self) -> Option<&str> {
        match *self {
            ReflectValueRef::String(v) => Some(v),
            _ => None,
        }
    }

    /// Take `[u8]` value.
    pub fn to_bytes(&self) -> Option<&[u8]> {
        match *self {
            ReflectValueRef::Bytes(v) => Some(v),
            _ => None,
        }
    }

    /// Take enum value.
    pub fn to_enum_value(&self) -> Option<i32> {
        match *self {
            ReflectValueRef::Enum(_, v) => Some(v),
            _ => None,
        }
    }

    /// Take message value.
    pub fn to_message(&self) -> Option<MessageRef<'a>> {
        match self {
            ReflectValueRef::Message(m) => Some(m.clone()),
            _ => None,
        }
    }

    /// Clone to a box
    pub fn to_box(&self) -> ReflectValueBox {
        match self {
            ReflectValueRef::U32(v) => ReflectValueBox::U32(*v),
            ReflectValueRef::U64(v) => ReflectValueBox::U64(*v),
            ReflectValueRef::I32(v) => ReflectValueBox::I32(*v),
            ReflectValueRef::I64(v) => ReflectValueBox::I64(*v),
            ReflectValueRef::F32(v) => ReflectValueBox::F32(*v),
            ReflectValueRef::F64(v) => ReflectValueBox::F64(*v),
            ReflectValueRef::Bool(v) => ReflectValueBox::Bool(*v),
            ReflectValueRef::String(v) => ReflectValueBox::String((*v).to_owned()),
            ReflectValueRef::Bytes(v) => ReflectValueBox::Bytes((*v).to_owned()),
            ReflectValueRef::Enum(d, v) => ReflectValueBox::Enum(d.clone(), *v),
            ReflectValueRef::Message(v) => ReflectValueBox::Message(v.clone_box()),
        }
    }

    /// Convert a value to arbitrary value.
    pub fn downcast_clone<V: ProtobufValue>(&self) -> Result<V, Self> {
        self.to_box().downcast().map_err(|_| self.clone())
    }
}

pub enum ReflectValueMut<'a> {
    Message(&'a mut dyn MessageDyn),
}

impl<'a> ReflectEq for ReflectValueRef<'a> {
    fn reflect_eq(&self, that: &Self, mode: &ReflectEqMode) -> bool {
        use crate::reflect::value::value_ref::ReflectValueRef::*;
        match (self, that) {
            (U32(a), U32(b)) => a == b,
            (U64(a), U64(b)) => a == b,
            (I32(a), I32(b)) => a == b,
            (I64(a), I64(b)) => a == b,
            (F32(a), F32(b)) => {
                if a.is_nan() || b.is_nan() {
                    a.is_nan() == b.is_nan() && mode.nan_equal
                } else {
                    a == b
                }
            }
            (F64(a), F64(b)) => {
                if a.is_nan() || b.is_nan() {
                    a.is_nan() == b.is_nan() && mode.nan_equal
                } else {
                    a == b
                }
            }
            (Bool(a), Bool(b)) => a == b,
            (String(a), String(b)) => a == b,
            (Bytes(a), Bytes(b)) => a == b,
            (Enum(ad, a), Enum(bd, b)) => ad == bd && a == b,
            (Message(a), Message(b)) => a.reflect_eq(b, mode),
            _ => false,
        }
    }
}

impl<'a> PartialEq for ReflectValueRef<'a> {
    fn eq(&self, other: &ReflectValueRef) -> bool {
        use self::ReflectValueRef::*;
        match (self, other) {
            (U32(a), U32(b)) => a == b,
            (U64(a), U64(b)) => a == b,
            (I32(a), I32(b)) => a == b,
            (I64(a), I64(b)) => a == b,
            // should probably NaN == NaN here
            (F32(a), F32(b)) => a == b,
            (F64(a), F64(b)) => a == b,
            (Bool(a), Bool(b)) => a == b,
            (String(a), String(b)) => a == b,
            (Bytes(a), Bytes(b)) => a == b,
            (Enum(da, a), Enum(db, b)) => da == db && a == b,
            (Message(a), Message(b)) => {
                MessageDescriptor::reflect_eq_maybe_unrelated(&**a, &**b, &ReflectEqMode::default())
            }
            _ => false,
        }
    }
}

impl<'a> PartialEq<ReflectValueRef<'a>> for ReflectValueBox {
    fn eq(&self, other: &ReflectValueRef) -> bool {
        self.as_value_ref() == *other
    }
}

// Panics if contained type is not hashable
impl<'a> Hash for ReflectValueRef<'a> {
    fn hash<H: Hasher>(&self, state: &mut H) {
        use self::ReflectValueRef::*;
        Hash::hash(&mem::discriminant(self), state);
        match self {
            U32(v) => Hash::hash(&v, state),
            U64(v) => Hash::hash(&v, state),
            I32(v) => Hash::hash(&v, state),
            I64(v) => Hash::hash(&v, state),
            Bool(v) => Hash::hash(&v, state),
            String(v) => Hash::hash(&v, state),
            Bytes(v) => Hash::hash(&v, state),
            Enum(_d, v) => Hash::hash(v, state),
            F32(_) | F64(_) | Message(_) => panic!("not hashable: {:?}", self),
        }
    }
}

impl<'a> From<EnumValueDescriptor> for ReflectValueRef<'a> {
    fn from(v: EnumValueDescriptor) -> Self {
        let number = v.value();
        ReflectValueRef::Enum(v.enum_descriptor, number)
    }
}

impl From<u32> for ReflectValueRef<'_> {
    fn from(v: u32) -> Self {
        ReflectValueRef::U32(v)
    }
}

impl From<i32> for ReflectValueRef<'_> {
    fn from(v: i32) -> Self {
        ReflectValueRef::I32(v)
    }
}

impl From<u64> for ReflectValueRef<'_> {
    fn from(v: u64) -> Self {
        ReflectValueRef::U64(v)
    }
}

impl From<i64> for ReflectValueRef<'_> {
    fn from(v: i64) -> Self {
        ReflectValueRef::I64(v)
    }
}

impl From<f32> for ReflectValueRef<'_> {
    fn from(v: f32) -> Self {
        ReflectValueRef::F32(v)
    }
}

impl From<f64> for ReflectValueRef<'_> {
    fn from(v: f64) -> Self {
        ReflectValueRef::F64(v)
    }
}

impl From<bool> for ReflectValueRef<'_> {
    fn from(v: bool) -> Self {
        ReflectValueRef::Bool(v)
    }
}

impl<'a> From<&'a str> for ReflectValueRef<'a> {
    fn from(v: &'a str) -> Self {
        ReflectValueRef::String(v)
    }
}

impl<'a> From<&'a [u8]> for ReflectValueRef<'a> {
    fn from(v: &'a [u8]) -> Self {
        ReflectValueRef::Bytes(v)
    }
}

'''
'''--- protobuf/src/rt/map.rs ---
use crate::error::WireError;
use crate::wire_format::WireType;
use crate::CodedInputStream;

pub(crate) fn read_map_template_new(
    is: &mut CodedInputStream,
    mut key: impl FnMut(WireType, &mut CodedInputStream) -> crate::Result<()>,
    mut value: impl FnMut(WireType, &mut CodedInputStream) -> crate::Result<()>,
) -> crate::Result<()> {
    let len = is.read_raw_varint32()?;
    let old_limit = is.push_limit(len as u64)?;
    while !is.eof()? {
        let (field_number, wire_type) = is.read_tag_unpack()?;
        match field_number {
            1 => key(wire_type, is)?,
            2 => value(wire_type, is)?,
            _ => is.skip_field(wire_type)?,
        }
    }
    is.pop_limit(old_limit);
    Ok(())
}

pub(crate) fn read_map_template(
    wire_type: WireType,
    is: &mut CodedInputStream,
    key: impl FnMut(WireType, &mut CodedInputStream) -> crate::Result<()>,
    value: impl FnMut(WireType, &mut CodedInputStream) -> crate::Result<()>,
) -> crate::Result<()> {
    if wire_type != WireType::LengthDelimited {
        return Err(WireError::UnexpectedWireType(wire_type).into());
    }

    read_map_template_new(is, key, value)
}

'''
'''--- protobuf/src/rt/message.rs ---
use crate::wire_format::WireType;
use crate::CodedInputStream;
use crate::CodedOutputStream;
use crate::Message;
use crate::MessageField;

/// Read singular `message` field.
pub fn read_singular_message_into_field<M>(
    is: &mut CodedInputStream,
    target: &mut MessageField<M>,
) -> crate::Result<()>
where
    M: Message,
{
    let mut m = M::new();
    is.merge_message(&mut m)?;
    *target = MessageField::some(m);
    Ok(())
}

/// Write message with field number and length to the stream.
pub fn write_message_field_with_cached_size<M>(
    field_number: u32,
    message: &M,
    os: &mut CodedOutputStream,
) -> crate::Result<()>
where
    M: Message,
{
    os.write_tag(field_number, WireType::LengthDelimited)?;
    os.write_raw_varint32(message.cached_size())?;
    message.write_to_with_cached_sizes(os)
}

'''
'''--- protobuf/src/rt/mod.rs ---
//! # Functions and types used by generated protobuf code
//!
//! These are not considered to be public API of rust-protobuf,
//! so they can be changed any time (provided compatibility with
//! previously generated code is preserved).

pub(crate) mod map;
mod message;
pub(crate) mod packed;
pub(crate) mod repeated;
pub(crate) mod singular;
pub(crate) mod unknown_or_group;

pub use message::read_singular_message_into_field;
pub use message::write_message_field_with_cached_size;
pub use packed::vec_packed_bool_size;
pub use packed::vec_packed_double_size;
pub use packed::vec_packed_enum_or_unknown_size;
pub use packed::vec_packed_fixed32_size;
pub use packed::vec_packed_fixed64_size;
pub use packed::vec_packed_float_size;
pub use packed::vec_packed_int32_size;
pub use packed::vec_packed_int64_size;
pub use packed::vec_packed_sfixed32_size;
pub use packed::vec_packed_sfixed64_size;
pub use packed::vec_packed_sint32_size;
pub use packed::vec_packed_sint64_size;
pub use packed::vec_packed_uint32_size;
pub use packed::vec_packed_uint64_size;
pub use repeated::read_repeated_packed_enum_or_unknown_into;
pub use singular::bytes_size;
pub use singular::int32_size;
pub use singular::int64_size;
pub use singular::sint32_size;
pub use singular::sint64_size;
pub use singular::string_size;
pub use singular::uint32_size;
pub use singular::uint64_size;
pub use unknown_or_group::read_unknown_or_skip_group;
pub use unknown_or_group::skip_field_for_tag;
pub use unknown_or_group::unknown_fields_size;

pub use crate::cached_size::CachedSize;
pub use crate::lazy::Lazy;
use crate::varint::encode::encoded_varint64_len;
pub use crate::wire_format::WireType;

/// Given `u64` value compute varint encoded length.
pub fn compute_raw_varint64_size(value: u64) -> u64 {
    encoded_varint64_len(value) as u64
}

/// Given `u32` value compute varint encoded length.
pub(crate) fn compute_raw_varint32_size(value: u32) -> u64 {
    compute_raw_varint64_size(value as u64)
}

/// Compute tag size. Size of tag does not depend on wire type.
#[inline]
pub fn tag_size(field_number: u32) -> u64 {
    encoded_varint64_len((field_number as u64) << 3) as u64
}

'''
'''--- protobuf/src/rt/packed.rs ---
use crate::fixed::ProtobufFixed;
use crate::rt::compute_raw_varint32_size;
use crate::rt::tag_size;
use crate::varint::generic::ProtobufVarint;
use crate::zigzag::ProtobufVarintZigzag;
use crate::Enum;
use crate::EnumOrUnknown;

/// Size of serialized repeated packed field, excluding length and tag.
pub(crate) fn vec_packed_varint_data_size<T: ProtobufVarint>(vec: &[T]) -> u64 {
    vec.iter().map(|v| v.len_varint() as u64).sum()
}

/// Size of serialized repeated packed field, excluding length and tag.
pub(crate) fn vec_packed_varint_zigzag_data_size<T: ProtobufVarintZigzag>(vec: &[T]) -> u64 {
    vec.iter().map(|v| v.len_varint_zigzag()).sum()
}

/// Size of serialized repeated packed enum field, excluding length and tag.
pub(crate) fn vec_packed_enum_or_unknown_data_size<E: Enum>(vec: &[EnumOrUnknown<E>]) -> u64 {
    vec.iter()
        .map(|e| compute_raw_varint32_size(e.value() as u32))
        .sum()
}

/// Size of serialized data with length prefix and tag
#[inline]
fn vec_packed_varint_size<T: ProtobufVarint>(field_number: u32, vec: &[T]) -> u64 {
    if vec.is_empty() {
        0
    } else {
        let data_size = vec_packed_varint_data_size(vec);
        tag_size(field_number) + data_size.len_varint() + data_size
    }
}

/// Size of serialized data with length prefix and tag.
#[inline]
pub fn vec_packed_int32_size(field_number: u32, vec: &[i32]) -> u64 {
    vec_packed_varint_size(field_number, vec)
}

/// Size of serialized data with length prefix and tag.
#[inline]
pub fn vec_packed_int64_size(field_number: u32, vec: &[i64]) -> u64 {
    vec_packed_varint_size(field_number, vec)
}

/// Size of serialized data with length prefix and tag.
#[inline]
pub fn vec_packed_uint32_size(field_number: u32, vec: &[u32]) -> u64 {
    vec_packed_varint_size(field_number, vec)
}

/// Size of serialized data with length prefix and tag.
#[inline]
pub fn vec_packed_uint64_size(field_number: u32, vec: &[u64]) -> u64 {
    vec_packed_varint_size(field_number, vec)
}

/// Size of serialized data with length prefix and tag
#[inline]
fn vec_packed_varint_zigzag_size<T: ProtobufVarintZigzag>(field_number: u32, vec: &[T]) -> u64 {
    if vec.is_empty() {
        0
    } else {
        let data_size = vec_packed_varint_zigzag_data_size(vec);
        tag_size(field_number) + data_size.len_varint() + data_size
    }
}

/// Size of serialized data with length prefix and tag.
#[inline]
pub fn vec_packed_sint32_size(field_number: u32, vec: &[i32]) -> u64 {
    vec_packed_varint_zigzag_size(field_number, vec)
}

/// Size of serialized data with length prefix and tag.
#[inline]
pub fn vec_packed_sint64_size(field_number: u32, vec: &[i64]) -> u64 {
    vec_packed_varint_zigzag_size(field_number, vec)
}

/// Size of serialized data with length prefix and tag
#[inline]
pub fn vec_packed_enum_or_unknown_size<E: Enum>(
    field_number: u32,
    vec: &[EnumOrUnknown<E>],
) -> u64 {
    if vec.is_empty() {
        0
    } else {
        let data_size = vec_packed_enum_or_unknown_data_size(vec);
        tag_size(field_number) + data_size.len_varint() + data_size
    }
}

/// Compute data size of fixed encoding of repeated field data.
pub(crate) fn vec_packed_fixed_data_size<V: ProtobufFixed>(vec: &[V]) -> u64 {
    (vec.len() as u64) * (V::LEN as u64)
}

/// Compute field size (data plus header) of fixed encoding of repeated field.
#[inline]
fn vec_packed_fixed_size<V: ProtobufFixed>(field_number: u32, vec: &[V]) -> u64 {
    if vec.is_empty() {
        0
    } else {
        let data_size = vec_packed_fixed_data_size::<V>(vec);
        tag_size(field_number) + data_size.len_varint() + data_size
    }
}

/// Compute data size of fixed encoding of repeated field data.
#[inline]
pub fn vec_packed_fixed32_size(field_number: u32, vec: &[u32]) -> u64 {
    vec_packed_fixed_size(field_number, vec)
}

/// Compute data size of fixed encoding of repeated field data.
#[inline]
pub fn vec_packed_fixed64_size(field_number: u32, vec: &[u64]) -> u64 {
    vec_packed_fixed_size(field_number, vec)
}

/// Compute data size of fixed encoding of repeated field data.
#[inline]
pub fn vec_packed_sfixed32_size(field_number: u32, vec: &[i32]) -> u64 {
    vec_packed_fixed_size(field_number, vec)
}

/// Compute data size of fixed encoding of repeated field data.
#[inline]
pub fn vec_packed_sfixed64_size(field_number: u32, vec: &[i64]) -> u64 {
    vec_packed_fixed_size(field_number, vec)
}

/// Compute data size of fixed encoding of repeated field data.
#[inline]
pub fn vec_packed_float_size(field_number: u32, vec: &[f32]) -> u64 {
    vec_packed_fixed_size(field_number, vec)
}

/// Compute data size of fixed encoding of repeated field data.
#[inline]
pub fn vec_packed_double_size(field_number: u32, vec: &[f64]) -> u64 {
    vec_packed_fixed_size(field_number, vec)
}

/// Compute data size of fixed encoding of repeated field data.
#[inline]
pub fn vec_packed_bool_size(field_number: u32, vec: &[bool]) -> u64 {
    vec_packed_fixed_size(field_number, vec)
}

'''
'''--- protobuf/src/rt/repeated.rs ---
use crate::CodedInputStream;
use crate::Enum;
use crate::EnumOrUnknown;

/// Read repeated enum field when the wire format is length-delimited.
pub fn read_repeated_packed_enum_or_unknown_into<E: Enum>(
    is: &mut CodedInputStream,
    target: &mut Vec<EnumOrUnknown<E>>,
) -> crate::Result<()> {
    let len = is.read_raw_varint64()?;
    let old_limit = is.push_limit(len)?;
    while !is.eof()? {
        target.push(is.read_enum_or_unknown()?);
    }
    is.pop_limit(old_limit);
    Ok(())
}

'''
'''--- protobuf/src/rt/singular.rs ---
use crate::rt::compute_raw_varint64_size;
use crate::rt::tag_size;
use crate::varint::generic::ProtobufVarint;
use crate::zigzag::ProtobufVarintZigzag;

/// Integer value size when encoded.
#[inline]
fn varint_size<T: ProtobufVarint>(field_number: u32, value: T) -> u64 {
    tag_size(field_number) + value.len_varint()
}

/// Encoded `int32` size.
#[inline]
pub fn int32_size(field_number: u32, value: i32) -> u64 {
    varint_size(field_number, value)
}

/// Encoded `int64` size.
#[inline]
pub fn int64_size(field_number: u32, value: i64) -> u64 {
    varint_size(field_number, value)
}

/// Encoded `uint32` size.
#[inline]
pub fn uint32_size(field_number: u32, value: u32) -> u64 {
    varint_size(field_number, value)
}

/// Encoded `uint64` size.
#[inline]
pub fn uint64_size(field_number: u32, value: u64) -> u64 {
    varint_size(field_number, value)
}

/// Integer value size when encoded as specified wire type.
pub(crate) fn value_varint_zigzag_size_no_tag<T: ProtobufVarintZigzag>(value: T) -> u64 {
    value.len_varint_zigzag()
}

/// Length of value when encoding with zigzag encoding with tag
#[inline]
fn value_varint_zigzag_size<T: ProtobufVarintZigzag>(field_number: u32, value: T) -> u64 {
    tag_size(field_number) + value_varint_zigzag_size_no_tag(value)
}

/// Size of serialized `sint32` field.
#[inline]
pub fn sint32_size(field_number: u32, value: i32) -> u64 {
    value_varint_zigzag_size(field_number, value)
}

/// Size of serialized `sint64` field.
#[inline]
pub fn sint64_size(field_number: u32, value: i64) -> u64 {
    value_varint_zigzag_size(field_number, value)
}

/// Size of encoded bytes field.
pub(crate) fn bytes_size_no_tag(bytes: &[u8]) -> u64 {
    compute_raw_varint64_size(bytes.len() as u64) + bytes.len() as u64
}

/// Size of encoded bytes field.
#[inline]
pub fn bytes_size(field_number: u32, bytes: &[u8]) -> u64 {
    tag_size(field_number) + bytes_size_no_tag(bytes)
}

/// Size of encoded string field.
pub(crate) fn string_size_no_tag(s: &str) -> u64 {
    bytes_size_no_tag(s.as_bytes())
}

/// Size of encoded string field.
#[inline]
pub fn string_size(field_number: u32, s: &str) -> u64 {
    tag_size(field_number) + string_size_no_tag(s)
}

'''
'''--- protobuf/src/rt/unknown_or_group.rs ---
use crate::rt::compute_raw_varint64_size;
use crate::rt::singular::bytes_size_no_tag;
use crate::rt::tag_size;
use crate::wire_format::Tag;
use crate::wire_format::WireType;
use crate::CodedInputStream;
use crate::UnknownFields;
use crate::UnknownValueRef;

fn skip_group(is: &mut CodedInputStream) -> crate::Result<()> {
    loop {
        let (_, wire_type) = is.read_tag_unpack()?;
        if wire_type == WireType::EndGroup {
            return Ok(());
        }
        is.skip_field(wire_type)?;
    }
}

/// Size of encoded unknown fields size.
pub fn unknown_fields_size(unknown_fields: &UnknownFields) -> u64 {
    let mut r = 0;
    for (number, value) in unknown_fields {
        r += tag_size(number);
        r += match value {
            UnknownValueRef::Fixed32(_) => 4,
            UnknownValueRef::Fixed64(_) => 8,
            UnknownValueRef::Varint(v) => compute_raw_varint64_size(v),
            UnknownValueRef::LengthDelimited(v) => bytes_size_no_tag(v),
        };
    }
    r
}

/// Handle unknown field in generated code.
/// Either store a value in unknown, or skip a group.
pub(crate) fn read_unknown_or_skip_group_with_tag_unpacked(
    field_number: u32,
    wire_type: WireType,
    is: &mut CodedInputStream,
    unknown_fields: &mut UnknownFields,
) -> crate::Result<()> {
    match wire_type {
        WireType::StartGroup => skip_group(is),
        _ => {
            let unknown = is.read_unknown(wire_type)?;
            unknown_fields.add_value(field_number, unknown);
            Ok(())
        }
    }
}

/// Handle unknown field in generated code.
/// Either store a value in unknown, or skip a group.
/// Return error if tag is incorrect.
pub fn read_unknown_or_skip_group(
    tag: u32,
    is: &mut CodedInputStream,
    unknown_fields: &mut UnknownFields,
) -> crate::Result<()> {
    let (field_humber, wire_type) = Tag::new(tag)?.unpack();
    read_unknown_or_skip_group_with_tag_unpacked(field_humber, wire_type, is, unknown_fields)
}

/// Skip field.
pub fn skip_field_for_tag(tag: u32, is: &mut CodedInputStream) -> crate::Result<()> {
    let (_field_humber, wire_type) = Tag::new(tag)?.unpack();
    is.skip_field(wire_type)
}

'''
'''--- protobuf/src/rustproto.rs ---
// This file is generated by rust-protobuf 4.0.0-alpha.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `rustproto.proto`

/// Extension fields
pub mod exts {

    pub const generate_accessors_all: crate::ext::ExtFieldOptional<crate::descriptor::FileOptions, bool> = crate::ext::ExtFieldOptional::new(17004, crate::descriptor::field_descriptor_proto::Type::TYPE_BOOL);

    pub const generate_getter_all: crate::ext::ExtFieldOptional<crate::descriptor::FileOptions, bool> = crate::ext::ExtFieldOptional::new(17005, crate::descriptor::field_descriptor_proto::Type::TYPE_BOOL);

    pub const tokio_bytes_all: crate::ext::ExtFieldOptional<crate::descriptor::FileOptions, bool> = crate::ext::ExtFieldOptional::new(17011, crate::descriptor::field_descriptor_proto::Type::TYPE_BOOL);

    pub const tokio_bytes_for_string_all: crate::ext::ExtFieldOptional<crate::descriptor::FileOptions, bool> = crate::ext::ExtFieldOptional::new(17012, crate::descriptor::field_descriptor_proto::Type::TYPE_BOOL);

    pub const lite_runtime_all: crate::ext::ExtFieldOptional<crate::descriptor::FileOptions, bool> = crate::ext::ExtFieldOptional::new(17035, crate::descriptor::field_descriptor_proto::Type::TYPE_BOOL);

    pub const generate_accessors: crate::ext::ExtFieldOptional<crate::descriptor::MessageOptions, bool> = crate::ext::ExtFieldOptional::new(17004, crate::descriptor::field_descriptor_proto::Type::TYPE_BOOL);

    pub const generate_getter: crate::ext::ExtFieldOptional<crate::descriptor::MessageOptions, bool> = crate::ext::ExtFieldOptional::new(17005, crate::descriptor::field_descriptor_proto::Type::TYPE_BOOL);

    pub const tokio_bytes: crate::ext::ExtFieldOptional<crate::descriptor::MessageOptions, bool> = crate::ext::ExtFieldOptional::new(17011, crate::descriptor::field_descriptor_proto::Type::TYPE_BOOL);

    pub const tokio_bytes_for_string: crate::ext::ExtFieldOptional<crate::descriptor::MessageOptions, bool> = crate::ext::ExtFieldOptional::new(17012, crate::descriptor::field_descriptor_proto::Type::TYPE_BOOL);

    pub const generate_accessors_field: crate::ext::ExtFieldOptional<crate::descriptor::FieldOptions, bool> = crate::ext::ExtFieldOptional::new(17004, crate::descriptor::field_descriptor_proto::Type::TYPE_BOOL);

    pub const generate_getter_field: crate::ext::ExtFieldOptional<crate::descriptor::FieldOptions, bool> = crate::ext::ExtFieldOptional::new(17005, crate::descriptor::field_descriptor_proto::Type::TYPE_BOOL);

    pub const tokio_bytes_field: crate::ext::ExtFieldOptional<crate::descriptor::FieldOptions, bool> = crate::ext::ExtFieldOptional::new(17011, crate::descriptor::field_descriptor_proto::Type::TYPE_BOOL);

    pub const tokio_bytes_for_string_field: crate::ext::ExtFieldOptional<crate::descriptor::FieldOptions, bool> = crate::ext::ExtFieldOptional::new(17012, crate::descriptor::field_descriptor_proto::Type::TYPE_BOOL);
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0frustproto.proto\x12\trustproto\x1a\x20google/protobuf/descriptor.p\
    roto:T\n\x16generate_accessors_all\x18\xec\x84\x01\x20\x01(\x08\x12\x1c.\
    google.protobuf.FileOptionsR\x14generateAccessorsAll:N\n\x13generate_get\
    ter_all\x18\xed\x84\x01\x20\x01(\x08\x12\x1c.google.protobuf.FileOptions\
    R\x11generateGetterAll:F\n\x0ftokio_bytes_all\x18\xf3\x84\x01\x20\x01(\
    \x08\x12\x1c.google.protobuf.FileOptionsR\rtokioBytesAll:Z\n\x1atokio_by\
    tes_for_string_all\x18\xf4\x84\x01\x20\x01(\x08\x12\x1c.google.protobuf.\
    FileOptionsR\x16tokioBytesForStringAll:H\n\x10lite_runtime_all\x18\x8b\
    \x85\x01\x20\x01(\x08\x12\x1c.google.protobuf.FileOptionsR\x0eliteRuntim\
    eAll:P\n\x12generate_accessors\x18\xec\x84\x01\x20\x01(\x08\x12\x1f.goog\
    le.protobuf.MessageOptionsR\x11generateAccessors:J\n\x0fgenerate_getter\
    \x18\xed\x84\x01\x20\x01(\x08\x12\x1f.google.protobuf.MessageOptionsR\
    \x0egenerateGetter:B\n\x0btokio_bytes\x18\xf3\x84\x01\x20\x01(\x08\x12\
    \x1f.google.protobuf.MessageOptionsR\ntokioBytes:V\n\x16tokio_bytes_for_\
    string\x18\xf4\x84\x01\x20\x01(\x08\x12\x1f.google.protobuf.MessageOptio\
    nsR\x13tokioBytesForString:Y\n\x18generate_accessors_field\x18\xec\x84\
    \x01\x20\x01(\x08\x12\x1d.google.protobuf.FieldOptionsR\x16generateAcces\
    sorsField:S\n\x15generate_getter_field\x18\xed\x84\x01\x20\x01(\x08\x12\
    \x1d.google.protobuf.FieldOptionsR\x13generateGetterField:K\n\x11tokio_b\
    ytes_field\x18\xf3\x84\x01\x20\x01(\x08\x12\x1d.google.protobuf.FieldOpt\
    ionsR\x0ftokioBytesField:_\n\x1ctokio_bytes_for_string_field\x18\xf4\x84\
    \x01\x20\x01(\x08\x12\x1d.google.protobuf.FieldOptionsR\x18tokioBytesFor\
    StringFieldJ\x9d\x0f\n\x06\x12\x04\0\0.\x01\n\x08\n\x01\x0c\x12\x03\0\0\
    \x12\n\t\n\x02\x03\0\x12\x03\x02\0*\n\xe5\x01\n\x01\x02\x12\x03\n\0\x122\
    ^\x20see\x20https://github.com/gogo/protobuf/blob/master/gogoproto/gogo.\
    proto\n\x20for\x20the\x20original\x20idea\n2{\x20Generated\x20files\x20c\
    an\x20be\x20customized\x20using\x20this\x20proto\n\x20or\x20using\x20`Cu\
    stomize`\x20struct\x20when\x20codegen\x20is\x20invoked\x20programmatical\
    ly.\n\n\t\n\x01\x07\x12\x04\x0c\0\x18\x01\nP\n\x02\x07\0\x12\x03\x0e\x04\
    1\x1aE\x20When\x20false,\x20`get_`,\x20`set_`,\x20`mut_`\x20etc.\x20acce\
    ssors\x20are\x20not\x20generated\n\n\n\n\x03\x07\0\x02\x12\x03\x0c\x07\"\
    \n\n\n\x03\x07\0\x04\x12\x03\x0e\x04\x0c\n\n\n\x03\x07\0\x05\x12\x03\x0e\
    \r\x11\n\n\n\x03\x07\0\x01\x12\x03\x0e\x12(\n\n\n\x03\x07\0\x03\x12\x03\
    \x0e+0\nL\n\x02\x07\x01\x12\x03\x10\x04.\x1aA\x20When\x20false,\x20`get_\
    `\x20is\x20not\x20generated\x20even\x20if\x20`syntax\x20=\x20\"proto2\"`\
    \n\n\n\n\x03\x07\x01\x02\x12\x03\x0c\x07\"\n\n\n\x03\x07\x01\x04\x12\x03\
    \x10\x04\x0c\n\n\n\x03\x07\x01\x05\x12\x03\x10\r\x11\n\n\n\x03\x07\x01\
    \x01\x12\x03\x10\x12%\n\n\n\x03\x07\x01\x03\x12\x03\x10(-\n2\n\x02\x07\
    \x02\x12\x03\x12\x04*\x1a'\x20Use\x20`bytes::Bytes`\x20for\x20`bytes`\
    \x20fields\n\n\n\n\x03\x07\x02\x02\x12\x03\x0c\x07\"\n\n\n\x03\x07\x02\
    \x04\x12\x03\x12\x04\x0c\n\n\n\x03\x07\x02\x05\x12\x03\x12\r\x11\n\n\n\
    \x03\x07\x02\x01\x12\x03\x12\x12!\n\n\n\x03\x07\x02\x03\x12\x03\x12$)\n3\
    \n\x02\x07\x03\x12\x03\x14\x045\x1a(\x20Use\x20`bytes::Bytes`\x20for\x20\
    `string`\x20fields\n\n\n\n\x03\x07\x03\x02\x12\x03\x0c\x07\"\n\n\n\x03\
    \x07\x03\x04\x12\x03\x14\x04\x0c\n\n\n\x03\x07\x03\x05\x12\x03\x14\r\x11\
    \n\n\n\x03\x07\x03\x01\x12\x03\x14\x12,\n\n\n\x03\x07\x03\x03\x12\x03\
    \x14/4\nN\n\x02\x07\x04\x12\x03\x17\x04+\x1aC\x20When\x20true,\x20will\
    \x20only\x20generate\x20codes\x20that\x20works\x20with\x20lite\x20runtim\
    e.\n\n\n\n\x03\x07\x04\x02\x12\x03\x0c\x07\"\n\n\n\x03\x07\x04\x04\x12\
    \x03\x17\x04\x0c\n\n\n\x03\x07\x04\x05\x12\x03\x17\r\x11\n\n\n\x03\x07\
    \x04\x01\x12\x03\x17\x12\"\n\n\n\x03\x07\x04\x03\x12\x03\x17%*\n\t\n\x01\
    \x07\x12\x04\x1a\0#\x01\nP\n\x02\x07\x05\x12\x03\x1c\x04-\x1aE\x20When\
    \x20false,\x20`get_`,\x20`set_`,\x20`mut_`\x20etc.\x20accessors\x20are\
    \x20not\x20generated\n\n\n\n\x03\x07\x05\x02\x12\x03\x1a\x07%\n\n\n\x03\
    \x07\x05\x04\x12\x03\x1c\x04\x0c\n\n\n\x03\x07\x05\x05\x12\x03\x1c\r\x11\
    \n\n\n\x03\x07\x05\x01\x12\x03\x1c\x12$\n\n\n\x03\x07\x05\x03\x12\x03\
    \x1c',\nL\n\x02\x07\x06\x12\x03\x1e\x04*\x1aA\x20When\x20false,\x20`get_\
    `\x20is\x20not\x20generated\x20even\x20if\x20`syntax\x20=\x20\"proto2\"`\
    \n\n\n\n\x03\x07\x06\x02\x12\x03\x1a\x07%\n\n\n\x03\x07\x06\x04\x12\x03\
    \x1e\x04\x0c\n\n\n\x03\x07\x06\x05\x12\x03\x1e\r\x11\n\n\n\x03\x07\x06\
    \x01\x12\x03\x1e\x12!\n\n\n\x03\x07\x06\x03\x12\x03\x1e$)\n2\n\x02\x07\
    \x07\x12\x03\x20\x04&\x1a'\x20Use\x20`bytes::Bytes`\x20for\x20`bytes`\
    \x20fields\n\n\n\n\x03\x07\x07\x02\x12\x03\x1a\x07%\n\n\n\x03\x07\x07\
    \x04\x12\x03\x20\x04\x0c\n\n\n\x03\x07\x07\x05\x12\x03\x20\r\x11\n\n\n\
    \x03\x07\x07\x01\x12\x03\x20\x12\x1d\n\n\n\x03\x07\x07\x03\x12\x03\x20\
    \x20%\n3\n\x02\x07\x08\x12\x03\"\x041\x1a(\x20Use\x20`bytes::Bytes`\x20f\
    or\x20`string`\x20fields\n\n\n\n\x03\x07\x08\x02\x12\x03\x1a\x07%\n\n\n\
    \x03\x07\x08\x04\x12\x03\"\x04\x0c\n\n\n\x03\x07\x08\x05\x12\x03\"\r\x11\
    \n\n\n\x03\x07\x08\x01\x12\x03\"\x12(\n\n\n\x03\x07\x08\x03\x12\x03\"+0\
    \n\t\n\x01\x07\x12\x04%\0.\x01\nP\n\x02\x07\t\x12\x03'\x043\x1aE\x20When\
    \x20false,\x20`get_`,\x20`set_`,\x20`mut_`\x20etc.\x20accessors\x20are\
    \x20not\x20generated\n\n\n\n\x03\x07\t\x02\x12\x03%\x07#\n\n\n\x03\x07\t\
    \x04\x12\x03'\x04\x0c\n\n\n\x03\x07\t\x05\x12\x03'\r\x11\n\n\n\x03\x07\t\
    \x01\x12\x03'\x12*\n\n\n\x03\x07\t\x03\x12\x03'-2\nL\n\x02\x07\n\x12\x03\
    )\x040\x1aA\x20When\x20false,\x20`get_`\x20is\x20not\x20generated\x20eve\
    n\x20if\x20`syntax\x20=\x20\"proto2\"`\n\n\n\n\x03\x07\n\x02\x12\x03%\
    \x07#\n\n\n\x03\x07\n\x04\x12\x03)\x04\x0c\n\n\n\x03\x07\n\x05\x12\x03)\
    \r\x11\n\n\n\x03\x07\n\x01\x12\x03)\x12'\n\n\n\x03\x07\n\x03\x12\x03)*/\
    \n2\n\x02\x07\x0b\x12\x03+\x04,\x1a'\x20Use\x20`bytes::Bytes`\x20for\x20\
    `bytes`\x20fields\n\n\n\n\x03\x07\x0b\x02\x12\x03%\x07#\n\n\n\x03\x07\
    \x0b\x04\x12\x03+\x04\x0c\n\n\n\x03\x07\x0b\x05\x12\x03+\r\x11\n\n\n\x03\
    \x07\x0b\x01\x12\x03+\x12#\n\n\n\x03\x07\x0b\x03\x12\x03+&+\n3\n\x02\x07\
    \x0c\x12\x03-\x047\x1a(\x20Use\x20`bytes::Bytes`\x20for\x20`string`\x20f\
    ields\n\n\n\n\x03\x07\x0c\x02\x12\x03%\x07#\n\n\n\x03\x07\x0c\x04\x12\
    \x03-\x04\x0c\n\n\n\x03\x07\x0c\x05\x12\x03-\r\x11\n\n\n\x03\x07\x0c\x01\
    \x12\x03-\x12.\n\n\n\x03\x07\x0c\x03\x12\x03-16\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static crate::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: crate::rt::Lazy<crate::descriptor::FileDescriptorProto> = crate::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        crate::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static crate::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: crate::rt::Lazy<crate::reflect::GeneratedFileDescriptor> = crate::rt::Lazy::new();
    static file_descriptor: crate::rt::Lazy<crate::reflect::FileDescriptor> = crate::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(crate::descriptor::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(0);
            let mut enums = ::std::vec::Vec::with_capacity(0);
            crate::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        crate::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}

'''
'''--- protobuf/src/special.rs ---
use crate::cached_size::CachedSize;
use crate::UnknownFields;

/// Special fields included in each generated message.
#[derive(Default, Eq, PartialEq, Clone, Debug, Hash)]
pub struct SpecialFields {
    unknown_fields: UnknownFields,
    cached_size: CachedSize,
}

impl SpecialFields {
    /// Defaults.
    pub const fn new() -> SpecialFields {
        SpecialFields {
            unknown_fields: UnknownFields::new(),
            cached_size: CachedSize::new(),
        }
    }

    /// Clear.
    pub fn clear(&mut self) {
        self.unknown_fields.clear();
        // No need to clear `cached_size`.
    }

    /// Getter.
    pub fn cached_size(&self) -> &CachedSize {
        &self.cached_size
    }

    /// Getter.
    pub fn unknown_fields(&self) -> &UnknownFields {
        &self.unknown_fields
    }

    /// Setter.
    pub fn mut_unknown_fields(&mut self) -> &mut UnknownFields {
        &mut self.unknown_fields
    }
}

'''
'''--- protobuf/src/text_format/mod.rs ---
//! # Protobuf "text format" implementation.
//!
//! Text format message look like this:
//!
//! ```text,ignore
//! size: 17
//! color: "red"
//! children {
//!     size: 18
//!     color: "blue"
//! }
//! children {
//!     size: 19
//!     color: "green"
//! }
//! ```
//!
//! This format is not specified, but it is implemented by all official
//! protobuf implementations, including `protoc` command which can decode
//! and encode messages using text format.
//!
//! # JSON
//!
//! rust-protobuf also supports JSON printing and parsing.
//! It is implemented in
//! [`protobuf-json-mapping` crate](https://docs.rs/protobuf-json-mapping/%3E=3.0.0-alpha).

mod parse;
mod print;

pub use self::parse::merge_from_str;
pub use self::parse::parse_from_str;
pub use self::parse::ParseError;
pub use self::print::fmt;
pub use self::print::print_to;
pub use self::print::print_to_string;
pub use self::print::print_to_string_pretty;

'''
'''--- protobuf/src/text_format/parse.rs ---
use std::str;

use protobuf_support::lexer::int;
use protobuf_support::lexer::loc::Loc;
use protobuf_support::lexer::parser_language::ParserLanguage;
use protobuf_support::lexer::str_lit::StrLitDecodeError;
use protobuf_support::lexer::tokenizer::Tokenizer;
use protobuf_support::lexer::tokenizer::TokenizerError;

use crate::message_dyn::MessageDyn;
use crate::message_full::MessageFull;
use crate::reflect::EnumDescriptor;
use crate::reflect::EnumValueDescriptor;
use crate::reflect::MessageDescriptor;
use crate::reflect::ReflectValueBox;
use crate::reflect::RuntimeFieldType;
use crate::reflect::RuntimeType;

#[derive(Debug, thiserror::Error)]
pub enum ParseErrorWithoutLoc {
    #[error(transparent)]
    TokenizerError(#[from] TokenizerError),
    #[error(transparent)]
    StrLitDecodeError(#[from] StrLitDecodeError),
    #[error("Unknown field: `{}`", .0)]
    UnknownField(String),
    #[error("Unknown enum value: `{}`", .0)]
    UnknownEnumValue(String),
    #[error("Map field specified more than once: `{}`", .0)]
    MapFieldIsSpecifiedMoreThanOnce(String),
    #[error("Integer overflow")]
    IntegerOverflow,
    #[error("Expecting bool")]
    ExpectingBool,
    #[error("Message not initialized")]
    MessageNotInitialized,
}

impl From<int::Overflow> for ParseErrorWithoutLoc {
    fn from(_: int::Overflow) -> Self {
        ParseErrorWithoutLoc::IntegerOverflow
    }
}

/// Text format parse error.
#[derive(Debug, thiserror::Error)]
#[error("{}: {}", loc, error)]
pub struct ParseError {
    error: ParseErrorWithoutLoc,
    loc: Loc,
}

pub type ParseResult<A> = Result<A, ParseErrorWithoutLoc>;
pub type ParseWithLocResult<A> = Result<A, ParseError>;

#[derive(Clone)]
struct Parser<'a> {
    tokenizer: Tokenizer<'a>,
}

impl<'a> Parser<'a> {
    // Text format

    fn next_field_name(&mut self) -> ParseResult<String> {
        Ok(self.tokenizer.next_ident()?)
    }

    fn read_colon(&mut self, desc: &'static str) -> ParseResult<()> {
        Ok(self.tokenizer.next_symbol_expect_eq(':', desc)?)
    }

    fn read_enum<'e>(&mut self, e: &'e EnumDescriptor) -> ParseResult<EnumValueDescriptor> {
        self.read_colon("enum")?;

        // TODO: read integer?
        let ident = self.tokenizer.next_ident()?;
        let value = match e.value_by_name(&ident) {
            Some(value) => value,
            None => return Err(ParseErrorWithoutLoc::UnknownEnumValue(ident)),
        };
        Ok(value)
    }

    fn read_u64(&mut self) -> ParseResult<u64> {
        self.read_colon("u64")?;

        Ok(self.tokenizer.next_int_lit()?)
    }

    fn read_u32(&mut self) -> ParseResult<u32> {
        self.read_colon("int value")?;

        let int_lit = self.tokenizer.next_int_lit()?;
        let value_u32 = int_lit as u32;
        if value_u32 as u64 != int_lit {
            return Err(ParseErrorWithoutLoc::IntegerOverflow);
        }
        Ok(value_u32)
    }

    fn read_i64(&mut self) -> ParseResult<i64> {
        self.read_colon("int value")?;

        if self.tokenizer.next_symbol_if_eq('-')? {
            let int_lit = self.tokenizer.next_int_lit()?;
            Ok(int::neg(int_lit)?)
        } else {
            let int_lit = self.tokenizer.next_int_lit()?;
            if int_lit > i64::MAX as u64 {
                return Err(ParseErrorWithoutLoc::IntegerOverflow);
            }
            Ok(int_lit as i64)
        }
    }

    fn read_i32(&mut self) -> ParseResult<i32> {
        let value = self.read_i64()?;
        if value < i32::min_value() as i64 || value > i32::max_value() as i64 {
            return Err(ParseErrorWithoutLoc::IntegerOverflow);
        }
        Ok(value as i32)
    }

    fn read_f64(&mut self) -> ParseResult<f64> {
        self.read_colon("float value")?;

        let minus = self.tokenizer.next_symbol_if_eq('-')?;

        let value = if let Ok(value) = self.tokenizer.next_int_lit() {
            value as f64
        } else {
            self.tokenizer.next_float_lit()?
        };

        Ok(if minus { -value } else { value })
    }

    fn read_f32(&mut self) -> ParseResult<f32> {
        Ok(self.read_f64()? as f32)
    }

    fn read_bool(&mut self) -> ParseResult<bool> {
        self.read_colon("bool value")?;

        if self.tokenizer.next_ident_if_eq("true")? {
            Ok(true)
        } else if self.tokenizer.next_ident_if_eq("false")? {
            Ok(false)
        } else {
            Err(ParseErrorWithoutLoc::ExpectingBool)
        }
    }

    fn read_string(&mut self) -> ParseResult<String> {
        self.read_colon("string value")?;

        Ok(self
            .tokenizer
            .next_str_lit()
            .and_then(|s| s.decode_utf8().map_err(From::from))?)
    }

    fn read_bytes(&mut self) -> ParseResult<Vec<u8>> {
        self.read_colon("bytes value")?;

        Ok(self
            .tokenizer
            .next_str_lit()
            .and_then(|s| s.decode_bytes().map_err(From::from))?)
    }

    fn read_message(&mut self, descriptor: &MessageDescriptor) -> ParseResult<Box<dyn MessageDyn>> {
        let mut message = descriptor.new_instance();

        let symbol = self.tokenizer.next_symbol_expect_eq_oneof(&['{', '<'])?;
        let terminator = if symbol == '{' { '}' } else { '>' };
        while !self.tokenizer.lookahead_is_symbol(terminator)? {
            self.merge_field(&mut *message, descriptor)?;
        }
        self.tokenizer
            .next_symbol_expect_eq(terminator, "message")?;
        Ok(message)
    }

    fn read_map_entry(
        &mut self,
        k: &RuntimeType,
        v: &RuntimeType,
    ) -> ParseResult<(ReflectValueBox, ReflectValueBox)> {
        let key_field_name: &str = "key";
        let value_field_name: &str = "value";

        let mut key = None;
        let mut value = None;
        self.tokenizer.next_symbol_expect_eq('{', "map entry")?;
        while !self.tokenizer.lookahead_is_symbol('}')? {
            let ident = self.next_field_name()?;
            let (field, field_type) = if ident == key_field_name {
                (&mut key, k)
            } else if ident == value_field_name {
                (&mut value, v)
            } else {
                return Err(ParseErrorWithoutLoc::UnknownField(ident));
            };

            if let Some(..) = *field {
                return Err(ParseErrorWithoutLoc::MapFieldIsSpecifiedMoreThanOnce(ident));
            }

            let field_value = self.read_value_of_type(field_type)?;

            *field = Some(field_value);
        }
        self.tokenizer.next_symbol_expect_eq('}', "map entry")?;
        let key = match key {
            Some(key) => key,
            None => k.default_value_ref().to_box(),
        };
        let value = match value {
            Some(value) => value,
            None => v.default_value_ref().to_box(),
        };
        Ok((key, value))
    }

    fn read_value_of_type(&mut self, t: &RuntimeType) -> ParseResult<ReflectValueBox> {
        Ok(match t {
            RuntimeType::Enum(d) => {
                let value = self.read_enum(&d)?.value();
                ReflectValueBox::Enum(d.clone(), value)
            }
            RuntimeType::U32 => ReflectValueBox::U32(self.read_u32()?),
            RuntimeType::U64 => ReflectValueBox::U64(self.read_u64()?),
            RuntimeType::I32 => ReflectValueBox::I32(self.read_i32()?),
            RuntimeType::I64 => ReflectValueBox::I64(self.read_i64()?),
            RuntimeType::F32 => ReflectValueBox::F32(self.read_f32()?),
            RuntimeType::F64 => ReflectValueBox::F64(self.read_f64()?),
            RuntimeType::Bool => ReflectValueBox::Bool(self.read_bool()?),
            RuntimeType::String => ReflectValueBox::String(self.read_string()?),
            RuntimeType::VecU8 => ReflectValueBox::Bytes(self.read_bytes()?),
            RuntimeType::Message(m) => ReflectValueBox::Message(self.read_message(&m)?),
        })
    }

    fn merge_field(
        &mut self,
        message: &mut dyn MessageDyn,
        descriptor: &MessageDescriptor,
    ) -> ParseResult<()> {
        let field_name = self.next_field_name()?;

        let field = match descriptor.field_by_name(&field_name) {
            Some(field) => field,
            None => {
                // TODO: shouldn't unknown fields be quietly skipped?
                return Err(ParseErrorWithoutLoc::UnknownField(field_name));
            }
        };

        match field.runtime_field_type() {
            RuntimeFieldType::Singular(t) => {
                let value = self.read_value_of_type(&t)?;
                field.set_singular_field(message, value);
            }
            RuntimeFieldType::Repeated(t) => {
                let value = self.read_value_of_type(&t)?;
                field.mut_repeated(message).push(value);
            }
            RuntimeFieldType::Map(k, v) => {
                let (k, v) = self.read_map_entry(&k, &v)?;
                field.mut_map(message).insert(k, v);
            }
        };

        Ok(())
    }

    fn merge_inner(&mut self, message: &mut dyn MessageDyn) -> ParseResult<()> {
        loop {
            if self.tokenizer.syntax_eof()? {
                break;
            }
            let descriptor = message.descriptor_dyn();
            self.merge_field(message, &descriptor)?;
        }
        Ok(())
    }

    fn merge(&mut self, message: &mut dyn MessageDyn) -> ParseWithLocResult<()> {
        match self.merge_inner(message) {
            Ok(()) => Ok(()),
            Err(error) => Err(ParseError {
                error,
                loc: self.tokenizer.loc(),
            }),
        }
    }
}

/// Parse text format message.
///
/// This function does not check if message required fields are set.
pub fn merge_from_str(message: &mut dyn MessageDyn, input: &str) -> ParseWithLocResult<()> {
    let mut parser = Parser {
        tokenizer: Tokenizer::new(input, ParserLanguage::TextFormat),
    };
    parser.merge(message)
}

/// Parse text format message.
pub fn parse_from_str<M: MessageFull>(input: &str) -> ParseWithLocResult<M> {
    let mut m = M::new();
    merge_from_str(&mut m, input)?;
    if let Err(_) = m.check_initialized() {
        return Err(ParseError {
            error: ParseErrorWithoutLoc::MessageNotInitialized,
            loc: Loc::start(),
        });
    }
    Ok(m)
}

'''
'''--- protobuf/src/text_format/print.rs ---
use std::fmt;
use std::fmt::Write;

use protobuf_support::text_format::quote_bytes_to;

use crate::message_dyn::MessageDyn;
use crate::reflect::MessageRef;
use crate::reflect::ReflectFieldRef;
use crate::reflect::ReflectValueRef;
use crate::UnknownValueRef;

fn print_str_to(s: &str, buf: &mut String) {
    // TODO: keep printable Unicode
    quote_bytes_to(s.as_bytes(), buf);
}

fn do_indent(buf: &mut String, pretty: bool, indent: usize) {
    if pretty && indent > 0 {
        for _ in 0..indent {
            buf.push_str("  ");
        }
    }
}

trait FieldName: fmt::Display {}
impl<'a> FieldName for &'a str {}
impl FieldName for u32 {}

fn print_start_field<F: FieldName>(
    buf: &mut String,
    pretty: bool,
    indent: usize,
    first: &mut bool,
    field_name: F,
) {
    if !*first && !pretty {
        buf.push_str(" ");
    }
    do_indent(buf, pretty, indent);
    *first = false;
    write!(buf, "{}", field_name).unwrap();
}

fn print_end_field(buf: &mut String, pretty: bool) {
    if pretty {
        buf.push_str("\n");
    }
}

fn print_field<F: FieldName>(
    buf: &mut String,
    pretty: bool,
    indent: usize,
    first: &mut bool,
    field_name: F,
    value: ReflectValueRef,
) {
    print_start_field(buf, pretty, indent, first, field_name);

    match value {
        ReflectValueRef::Message(m) => {
            buf.push_str(" {");
            if pretty {
                buf.push_str("\n");
            }
            print_to_internal(&m, buf, pretty, indent + 1);
            do_indent(buf, pretty, indent);
            buf.push_str("}");
        }
        ReflectValueRef::Enum(d, v) => {
            buf.push_str(": ");
            match d.value_by_number(v) {
                Some(e) => buf.push_str(e.name()),
                None => write!(buf, ": {}", v).unwrap(),
            }
        }
        ReflectValueRef::String(s) => {
            buf.push_str(": ");
            print_str_to(s, buf);
        }
        ReflectValueRef::Bytes(b) => {
            buf.push_str(": ");
            quote_bytes_to(b, buf);
        }
        ReflectValueRef::I32(v) => {
            write!(buf, ": {}", v).unwrap();
        }
        ReflectValueRef::I64(v) => {
            write!(buf, ": {}", v).unwrap();
        }
        ReflectValueRef::U32(v) => {
            write!(buf, ": {}", v).unwrap();
        }
        ReflectValueRef::U64(v) => {
            write!(buf, ": {}", v).unwrap();
        }
        ReflectValueRef::Bool(v) => {
            write!(buf, ": {}", v).unwrap();
        }
        ReflectValueRef::F32(v) => {
            write!(buf, ": {}", v).unwrap();
        }
        ReflectValueRef::F64(v) => {
            write!(buf, ": {}", v).unwrap();
        }
    }

    print_end_field(buf, pretty);
}

fn print_to_internal(m: &MessageRef, buf: &mut String, pretty: bool, indent: usize) {
    let d = m.descriptor_dyn();
    let mut first = true;
    for f in d.fields() {
        match f.get_reflect(&**m) {
            ReflectFieldRef::Map(map) => {
                for (k, v) in &map {
                    print_start_field(buf, pretty, indent, &mut first, f.name());
                    buf.push_str(" {");
                    if pretty {
                        buf.push_str("\n");
                    }

                    let mut entry_first = true;

                    print_field(buf, pretty, indent + 1, &mut entry_first, "key", k);
                    print_field(buf, pretty, indent + 1, &mut entry_first, "value", v);
                    do_indent(buf, pretty, indent);
                    buf.push_str("}");
                    print_end_field(buf, pretty);
                }
            }
            ReflectFieldRef::Repeated(repeated) => {
                for v in repeated {
                    print_field(buf, pretty, indent, &mut first, f.name(), v);
                }
            }
            ReflectFieldRef::Optional(optional) => {
                if let Some(v) = optional.value() {
                    print_field(buf, pretty, indent, &mut first, f.name(), v);
                }
            }
        }
    }

    let mut fields: Vec<(u32, UnknownValueRef)> = m.unknown_fields_dyn().iter().collect();
    // Sort for stable output
    fields.sort_by_key(|(field_number, _)| *field_number);
    for (field_number, value) in fields {
        // TODO: try decode nested message for length-delimited
        print_field(
            buf,
            pretty,
            indent,
            &mut first,
            field_number,
            value.to_reflect_value_ref(),
        );
    }
}

/// Text-format
pub fn print_to(m: &dyn MessageDyn, buf: &mut String) {
    print_to_internal(&MessageRef::from(m), buf, false, 0)
}

fn print_to_string_internal(m: &dyn MessageDyn, pretty: bool) -> String {
    let mut r = String::new();
    print_to_internal(&MessageRef::from(m), &mut r, pretty, 0);
    r
}

/// Text-format
pub fn print_to_string(m: &dyn MessageDyn) -> String {
    print_to_string_internal(m, false)
}

/// Text-format
pub fn print_to_string_pretty(m: &dyn MessageDyn) -> String {
    print_to_string_internal(m, true)
}

/// Text-format to `fmt::Formatter`.
pub fn fmt(m: &dyn MessageDyn, f: &mut fmt::Formatter) -> fmt::Result {
    let pretty = f.alternate();
    f.write_str(&print_to_string_internal(m, pretty))
}

'''
'''--- protobuf/src/timestamp.rs ---
use crate::cached_size::CachedSize;
use crate::well_known_types::Timestamp;
use crate::UnknownFields;
use std::time::{Duration, SystemTime};

impl Timestamp {
    /// Unix epoch value of timestamp.
    pub const UNIX_EPOCH: Timestamp = Timestamp {
        seconds: 0,
        nanos: 0,
        unknown_fields: UnknownFields::INIT,
        cached_size: CachedSize::INIT,
    };

    /// Return current time as `Timestamp`.
    pub fn now() -> Timestamp {
        Timestamp::from(SystemTime::now())
    }
}

/// Convert from [`Timestamp`].
///
/// # Panics
///
/// This function panics if given `SystemTime` is outside of `Timestamp` range.
impl From<SystemTime> for Timestamp {
    fn from(time: SystemTime) -> Self {
        match time.duration_since(SystemTime::UNIX_EPOCH) {
            Ok(since_epoch) => Timestamp {
                seconds: since_epoch.as_secs() as i64,
                nanos: since_epoch.subsec_nanos() as i32,
                ..Default::default()
            },
            Err(e) => {
                let before_epoch = e.duration();
                Timestamp {
                    seconds: -(before_epoch.as_secs() as i64)
                        - (before_epoch.subsec_nanos() != 0) as i64,
                    nanos: (1_000_000_000 - before_epoch.subsec_nanos() as i32) % 1_000_000_000,
                    ..Default::default()
                }
            }
        }
    }
}

/// Convert into [`SystemTime`].
///
/// The conversion could be lossy if `SystemTime` precision is smaller than nanoseconds.
///
/// # Panics
///
/// This function panics:
/// * if given `Timestamp` is outside of `SystemTime` range
/// * if `Timestamp` is malformed
impl Into<SystemTime> for Timestamp {
    fn into(self) -> SystemTime {
        if self.seconds >= 0 {
            let duration =
                Duration::from_secs(self.seconds as u64) + Duration::from_nanos(self.nanos as u64);
            SystemTime::UNIX_EPOCH + duration
        } else {
            let duration =
                Duration::from_secs(-self.seconds as u64) - Duration::from_nanos(self.nanos as u64);
            SystemTime::UNIX_EPOCH - duration
        }
    }
}

#[cfg(test)]
mod test {
    use crate::well_known_types::Timestamp;
    use std::time::Duration;
    use std::time::SystemTime;

    #[test]
    fn from_system_time() {
        fn to_from(timestamp: Timestamp, system_time: SystemTime) {
            assert_eq!(timestamp, Timestamp::from(system_time));
            assert_eq!(system_time, Into::<SystemTime>::into(timestamp));
        }

        to_from(Timestamp::UNIX_EPOCH, SystemTime::UNIX_EPOCH);
        to_from(
            Timestamp {
                seconds: 0,
                nanos: 200_000_000,
                ..Default::default()
            },
            SystemTime::UNIX_EPOCH + Duration::from_millis(200),
        );
        to_from(
            Timestamp {
                seconds: 3,
                nanos: 200_000_000,
                ..Default::default()
            },
            SystemTime::UNIX_EPOCH + Duration::from_millis(3_200),
        );
        to_from(
            Timestamp {
                seconds: -1,
                nanos: 800_000_000,
                ..Default::default()
            },
            SystemTime::UNIX_EPOCH - Duration::from_millis(200),
        );
        to_from(
            Timestamp {
                seconds: -4,
                nanos: 800_000_000,
                ..Default::default()
            },
            SystemTime::UNIX_EPOCH - Duration::from_millis(3_200),
        );
    }
}

'''
'''--- protobuf/src/unknown.rs ---
use std::collections::hash_map;
use std::collections::hash_map::DefaultHasher;
use std::collections::HashMap;
use std::default::Default;
use std::hash::BuildHasherDefault;
use std::hash::Hash;
use std::hash::Hasher;
use std::slice;

use crate::reflect::ReflectValueRef;
use crate::rt;
use crate::wire_format::WireType;
use crate::zigzag::encode_zig_zag_32;
use crate::zigzag::encode_zig_zag_64;
use crate::CodedOutputStream;

/// Unknown value.
///
/// See [`UnknownFields`](crate::UnknownFields) for the explanations.
#[derive(Debug)]
pub enum UnknownValue {
    /// 32-bit unknown (e. g. `fixed32` or `float`)
    Fixed32(u32),
    /// 64-bit unknown (e. g. `fixed64` or `double`)
    Fixed64(u64),
    /// Varint unknown (e. g. `int32` or `bool`)
    Varint(u64),
    /// Length-delimited unknown (e. g. `message` or `string`)
    LengthDelimited(Vec<u8>),
}

impl UnknownValue {
    /// Wire type for this unknown
    pub fn wire_type(&self) -> WireType {
        self.get_ref().wire_type()
    }

    /// As ref
    pub fn get_ref<'s>(&'s self) -> UnknownValueRef<'s> {
        match *self {
            UnknownValue::Fixed32(fixed32) => UnknownValueRef::Fixed32(fixed32),
            UnknownValue::Fixed64(fixed64) => UnknownValueRef::Fixed64(fixed64),
            UnknownValue::Varint(varint) => UnknownValueRef::Varint(varint),
            UnknownValue::LengthDelimited(ref bytes) => UnknownValueRef::LengthDelimited(&bytes),
        }
    }

    /// Construct unknown value from `int64` value.
    pub fn int32(i: i32) -> UnknownValue {
        UnknownValue::int64(i as i64)
    }

    /// Construct unknown value from `int64` value.
    pub fn int64(i: i64) -> UnknownValue {
        UnknownValue::Varint(i as u64)
    }

    /// Construct unknown value from `sint32` value.
    pub fn sint32(i: i32) -> UnknownValue {
        UnknownValue::Varint(encode_zig_zag_32(i) as u64)
    }

    /// Construct unknown value from `sint64` value.
    pub fn sint64(i: i64) -> UnknownValue {
        UnknownValue::Varint(encode_zig_zag_64(i))
    }

    /// Construct unknown value from `float` value.
    pub fn float(f: f32) -> UnknownValue {
        UnknownValue::Fixed32(f.to_bits())
    }

    /// Construct unknown value from `double` value.
    pub fn double(f: f64) -> UnknownValue {
        UnknownValue::Fixed64(f.to_bits())
    }

    /// Construct unknown value from `sfixed32` value.
    pub fn sfixed32(i: i32) -> UnknownValue {
        UnknownValue::Fixed32(i as u32)
    }

    /// Construct unknown value from `sfixed64` value.
    pub fn sfixed64(i: i64) -> UnknownValue {
        UnknownValue::Fixed64(i as u64)
    }
}

/// Reference to unknown value.
///
/// See [`UnknownFields`](crate::UnknownFields) for explanations.
#[derive(Debug, PartialEq)]
pub enum UnknownValueRef<'o> {
    /// 32-bit unknown
    Fixed32(u32),
    /// 64-bit unknown
    Fixed64(u64),
    /// Varint unknown
    Varint(u64),
    /// Length-delimited unknown
    LengthDelimited(&'o [u8]),
}

impl<'o> UnknownValueRef<'o> {
    /// Wire-type to serialize this unknown
    pub fn wire_type(&self) -> WireType {
        match *self {
            UnknownValueRef::Fixed32(_) => WireType::Fixed32,
            UnknownValueRef::Fixed64(_) => WireType::Fixed64,
            UnknownValueRef::Varint(_) => WireType::Varint,
            UnknownValueRef::LengthDelimited(_) => WireType::LengthDelimited,
        }
    }

    pub(crate) fn to_reflect_value_ref(&'o self) -> ReflectValueRef<'o> {
        match self {
            UnknownValueRef::Fixed32(v) => ReflectValueRef::U32(*v),
            UnknownValueRef::Fixed64(v) => ReflectValueRef::U64(*v),
            UnknownValueRef::Varint(v) => ReflectValueRef::U64(*v),
            UnknownValueRef::LengthDelimited(v) => ReflectValueRef::Bytes(v),
        }
    }
}

/// Field unknown values.
///
/// See [`UnknownFields`](crate::UnknownFields) for explanations.
#[derive(Clone, PartialEq, Eq, Debug, Default, Hash)]
pub(crate) struct UnknownValues {
    /// 32-bit unknowns
    pub(crate) fixed32: Vec<u32>,
    /// 64-bit unknowns
    pub(crate) fixed64: Vec<u64>,
    /// Varint unknowns
    pub(crate) varint: Vec<u64>,
    /// Length-delimited unknowns
    pub(crate) length_delimited: Vec<Vec<u8>>,
}

impl UnknownValues {
    /// Add unknown value
    pub fn add_value(&mut self, value: UnknownValue) {
        match value {
            UnknownValue::Fixed64(fixed64) => self.fixed64.push(fixed64),
            UnknownValue::Fixed32(fixed32) => self.fixed32.push(fixed32),
            UnknownValue::Varint(varint) => self.varint.push(varint),
            UnknownValue::LengthDelimited(length_delimited) => {
                self.length_delimited.push(length_delimited)
            }
        };
    }

    /// Iterate over unknown values
    pub fn iter<'s>(&'s self) -> UnknownValuesIter<'s> {
        UnknownValuesIter {
            fixed32: self.fixed32.iter(),
            fixed64: self.fixed64.iter(),
            varint: self.varint.iter(),
            length_delimited: self.length_delimited.iter(),
        }
    }

    pub(crate) fn any(&self) -> Option<UnknownValueRef> {
        if let Some(last) = self.fixed32.last() {
            Some(UnknownValueRef::Fixed32(*last))
        } else if let Some(last) = self.fixed64.last() {
            Some(UnknownValueRef::Fixed64(*last))
        } else if let Some(last) = self.varint.last() {
            Some(UnknownValueRef::Varint(*last))
        } else if let Some(last) = self.length_delimited.last() {
            Some(UnknownValueRef::LengthDelimited(last))
        } else {
            None
        }
    }
}

impl<'a> IntoIterator for &'a UnknownValues {
    type Item = UnknownValueRef<'a>;
    type IntoIter = UnknownValuesIter<'a>;

    fn into_iter(self) -> UnknownValuesIter<'a> {
        self.iter()
    }
}

/// Iterator over unknown values
pub(crate) struct UnknownValuesIter<'o> {
    fixed32: slice::Iter<'o, u32>,
    fixed64: slice::Iter<'o, u64>,
    varint: slice::Iter<'o, u64>,
    length_delimited: slice::Iter<'o, Vec<u8>>,
}

impl<'o> Iterator for UnknownValuesIter<'o> {
    type Item = UnknownValueRef<'o>;

    fn next(&mut self) -> Option<UnknownValueRef<'o>> {
        if let Some(fixed32) = self.fixed32.next() {
            return Some(UnknownValueRef::Fixed32(*fixed32));
        }
        if let Some(fixed64) = self.fixed64.next() {
            return Some(UnknownValueRef::Fixed64(*fixed64));
        }
        if let Some(varint) = self.varint.next() {
            return Some(UnknownValueRef::Varint(*varint));
        }
        if let Some(length_delimited) = self.length_delimited.next() {
            return Some(UnknownValueRef::LengthDelimited(&length_delimited));
        }
        None
    }
}

/// Hold "unknown" fields in parsed message.
///
/// Field may be unknown if it they are added in newer version of `.proto`.
/// Unknown fields are stored in `UnknownFields` structure, so
/// protobuf message could process messages without losing data.
///
/// For example, in this operation: load from DB, modify, store to DB,
/// even when working with older `.proto` file, new fields won't be lost.
#[derive(Clone, PartialEq, Eq, Debug, Default)]
pub struct UnknownFields {
    /// The map.
    //
    // `Option` is needed, because HashMap constructor performs allocation,
    // and very expensive.
    //
    // We use "default hasher" to make iteration order deterministic.
    // Which is used to make codegen output deterministic in presence of unknown fields
    // (e. g. file options are represented as unknown fields).
    // Using default hasher is suboptimal, because it makes unknown fields less safe.
    // Note, Google Protobuf C++ simply uses linear map (which can exploitable the same way),
    // and Google Protobuf Java uses tree map to store unknown fields
    // (which is more expensive than hashmap).
    fields: Option<Box<HashMap<u32, UnknownValues, BuildHasherDefault<DefaultHasher>>>>,
}

/// Very simple hash implementation of `Hash` for `UnknownFields`.
/// Since map is unordered, we cannot put entry hashes into hasher,
/// instead we summing hashes of entries.
impl Hash for UnknownFields {
    fn hash<H: Hasher>(&self, state: &mut H) {
        if let Some(ref map) = self.fields {
            if !map.is_empty() {
                let mut hash: u64 = 0;
                for (k, v) in &**map {
                    let mut entry_hasher = DefaultHasher::new();
                    Hash::hash(&(k, v), &mut entry_hasher);
                    hash = hash.wrapping_add(entry_hasher.finish());
                }
                Hash::hash(&map.len(), state);
                Hash::hash(&hash, state);
            }
        }
    }
}

impl UnknownFields {
    /// Empty unknown fields.
    pub const fn new() -> UnknownFields {
        UnknownFields { fields: None }
    }

    /// Clear all unknown fields.
    pub fn clear(&mut self) {
        if let Some(ref mut fields) = self.fields {
            fields.clear();
        }
    }

    fn init_map(&mut self) {
        if self.fields.is_none() {
            self.fields = Some(Default::default());
        }
    }

    fn find_field<'a>(&'a mut self, number: &'a u32) -> &'a mut UnknownValues {
        self.init_map();

        match self.fields.as_mut().unwrap().entry(*number) {
            hash_map::Entry::Occupied(e) => e.into_mut(),
            hash_map::Entry::Vacant(e) => e.insert(Default::default()),
        }
    }

    /// Add unknown fixed 32-bit
    pub fn add_fixed32(&mut self, number: u32, fixed32: u32) {
        self.find_field(&number).fixed32.push(fixed32);
    }

    /// Add unknown fixed 64-bit
    pub fn add_fixed64(&mut self, number: u32, fixed64: u64) {
        self.find_field(&number).fixed64.push(fixed64);
    }

    /// Add unknown varint
    pub fn add_varint(&mut self, number: u32, varint: u64) {
        self.find_field(&number).varint.push(varint);
    }

    /// Add unknown length delimited
    pub fn add_length_delimited(&mut self, number: u32, length_delimited: Vec<u8>) {
        self.find_field(&number)
            .length_delimited
            .push(length_delimited);
    }

    /// Add unknown value
    pub fn add_value(&mut self, number: u32, value: UnknownValue) {
        self.find_field(&number).add_value(value);
    }

    /// Remove unknown field by number
    pub fn remove(&mut self, field_number: u32) {
        if let Some(fields) = &mut self.fields {
            fields.remove(&field_number);
        }
    }

    /// Iterate over all unknowns
    pub fn iter<'s>(&'s self) -> UnknownFieldsIter<'s> {
        UnknownFieldsIter {
            entries: self.fields.as_ref().map(|m| UnknownFieldsNotEmptyIter {
                fields: m.iter(),
                current: None,
            }),
        }
    }

    /// Get any value for unknown fields.
    pub fn get(&self, field_number: u32) -> Option<UnknownValueRef> {
        match &self.fields {
            Some(map) => map.get(&field_number).and_then(|v| v.any()),
            None => None,
        }
    }

    #[doc(hidden)]
    pub fn write_to_bytes(&self) -> Vec<u8> {
        let mut r = Vec::with_capacity(rt::unknown_fields_size(self) as usize);
        let mut stream = CodedOutputStream::vec(&mut r);
        // Do we need it stable everywhere?
        stream.write_unknown_fields_sorted(self).unwrap();
        stream.flush().unwrap();
        drop(stream);
        r
    }
}

impl<'a> IntoIterator for &'a UnknownFields {
    type Item = (u32, UnknownValueRef<'a>);
    type IntoIter = UnknownFieldsIter<'a>;

    fn into_iter(self) -> UnknownFieldsIter<'a> {
        self.iter()
    }
}

struct UnknownFieldsNotEmptyIter<'s> {
    fields: hash_map::Iter<'s, u32, UnknownValues>,
    current: Option<(u32, UnknownValuesIter<'s>)>,
}

/// Iterator over [`UnknownFields`](crate::UnknownFields)
pub struct UnknownFieldsIter<'s> {
    entries: Option<UnknownFieldsNotEmptyIter<'s>>,
}

impl<'s> Iterator for UnknownFieldsNotEmptyIter<'s> {
    type Item = (u32, UnknownValueRef<'s>);

    fn next(&mut self) -> Option<(u32, UnknownValueRef<'s>)> {
        loop {
            if let Some((field_number, values)) = &mut self.current {
                if let Some(value) = values.next() {
                    return Some((*field_number, value));
                }
            }
            let (field_number, values) = self.fields.next()?;
            self.current = Some((*field_number, values.iter()));
        }
    }
}

impl<'s> Iterator for UnknownFieldsIter<'s> {
    type Item = (u32, UnknownValueRef<'s>);

    fn next(&mut self) -> Option<(u32, UnknownValueRef<'s>)> {
        self.entries.as_mut().and_then(|entries| entries.next())
    }
}

#[cfg(test)]
mod test {
    use std::collections::hash_map::DefaultHasher;
    use std::hash::Hash;
    use std::hash::Hasher;

    use super::UnknownFields;

    #[test]
    fn unknown_fields_hash() {
        let mut unknown_fields_1 = UnknownFields::new();
        let mut unknown_fields_2 = UnknownFields::new();

        // Check field order is not important

        unknown_fields_1.add_fixed32(10, 222);
        unknown_fields_1.add_fixed32(10, 223);
        unknown_fields_1.add_fixed64(14, 224);

        unknown_fields_2.add_fixed32(10, 222);
        unknown_fields_2.add_fixed64(14, 224);
        unknown_fields_2.add_fixed32(10, 223);

        fn hash(unknown_fields: &UnknownFields) -> u64 {
            let mut hasher = DefaultHasher::new();
            Hash::hash(unknown_fields, &mut hasher);
            hasher.finish()
        }

        assert_eq!(hash(&unknown_fields_1), hash(&unknown_fields_2));
    }

    #[test]
    fn unknown_fields_iteration_order_deterministic() {
        let mut u_1 = UnknownFields::new();
        let mut u_2 = UnknownFields::new();
        for u in &mut [&mut u_1, &mut u_2] {
            u.add_fixed32(10, 20);
            u.add_varint(30, 40);
            u.add_fixed64(50, 60);
            u.add_length_delimited(70, Vec::new());
            u.add_varint(80, 90);
            u.add_fixed32(11, 22);
            u.add_fixed64(33, 44);
        }

        let items_1: Vec<_> = u_1.iter().collect();
        let items_2: Vec<_> = u_2.iter().collect();
        assert_eq!(items_1, items_2);
    }
}

'''
'''--- protobuf/src/varint/decode.rs ---
//! Varint decode utilities.

use crate::error::WireError;
use crate::varint::MAX_VARINT32_ENCODED_LEN;
use crate::varint::MAX_VARINT_ENCODED_LEN;

trait DecodeVarint {
    const MAX_ENCODED_LEN: usize;
    const LAST_BYTE_MAX_VALUE: u8;

    fn from_u64(value: u64) -> Self;
}

impl DecodeVarint for u64 {
    const MAX_ENCODED_LEN: usize = MAX_VARINT_ENCODED_LEN;
    const LAST_BYTE_MAX_VALUE: u8 = 0x01;

    fn from_u64(value: u64) -> Self {
        value
    }
}

impl DecodeVarint for u32 {
    const MAX_ENCODED_LEN: usize = MAX_VARINT32_ENCODED_LEN;
    const LAST_BYTE_MAX_VALUE: u8 = 0x0f;

    fn from_u64(value: u64) -> Self {
        value as u32
    }
}

/// Decode a varint, and return decoded value and decoded byte count.
#[inline]
fn decode_varint_full<D: DecodeVarint>(rem: &[u8]) -> crate::Result<Option<(D, usize)>> {
    let mut r: u64 = 0;
    for (i, &b) in rem.iter().enumerate() {
        if i == D::MAX_ENCODED_LEN - 1 {
            if b > D::LAST_BYTE_MAX_VALUE {
                return Err(WireError::IncorrectVarint.into());
            }
            let r = r | ((b as u64) << (i as u64 * 7));
            return Ok(Some((D::from_u64(r), i + 1)));
        }

        r = r | (((b & 0x7f) as u64) << (i as u64 * 7));
        if b < 0x80 {
            return Ok(Some((D::from_u64(r), i + 1)));
        }
    }
    Ok(None)
}

#[inline]
fn decode_varint_impl<D: DecodeVarint>(buf: &[u8]) -> crate::Result<Option<(D, usize)>> {
    if buf.len() >= 1 && buf[0] < 0x80 {
        // The the most common case.
        let ret = buf[0] as u64;
        let consume = 1;
        Ok(Some((D::from_u64(ret), consume)))
    } else if buf.len() >= 2 && buf[1] < 0x80 {
        // Handle the case of two bytes too.
        let ret = (buf[0] & 0x7f) as u64 | (buf[1] as u64) << 7;
        let consume = 2;
        Ok(Some((D::from_u64(ret), consume)))
    } else {
        // Read from array when buf at at least 10 bytes,
        // max len for varint.
        decode_varint_full(buf)
    }
}

/// Try decode a varint. Return `None` if the buffer does not contain complete varint.
#[inline]
pub(crate) fn decode_varint64(buf: &[u8]) -> crate::Result<Option<(u64, usize)>> {
    decode_varint_impl(buf)
}

/// Try decode a varint. Return `None` if the buffer does not contain complete varint.
#[inline]
pub(crate) fn decode_varint32(buf: &[u8]) -> crate::Result<Option<(u32, usize)>> {
    decode_varint_impl(buf)
}

#[cfg(test)]
mod tests {
    use crate::hex::decode_hex;
    use crate::varint::decode::decode_varint32;
    use crate::varint::decode::decode_varint64;

    #[test]
    fn test_decode_varint64() {
        assert_eq!((0, 1), decode_varint64(&decode_hex("00")).unwrap().unwrap());
        assert_eq!(
            (u64::MAX, 10),
            decode_varint64(&decode_hex("ff ff ff ff ff ff ff ff ff 01"))
                .unwrap()
                .unwrap()
        );
        assert!(decode_varint64(&decode_hex("ff ff ff ff ff ff ff ff ff 02")).is_err());
    }

    #[test]
    fn test_decode_varint32() {
        assert_eq!((0, 1), decode_varint32(&decode_hex("00")).unwrap().unwrap());
        assert_eq!(
            (u32::MAX, 5),
            decode_varint32(&decode_hex("ff ff ff ff 0f"))
                .unwrap()
                .unwrap()
        );
        assert!(decode_varint32(&decode_hex("ff ff ff ff 10")).is_err());
    }
}

'''
'''--- protobuf/src/varint/encode.rs ---
use std::mem::MaybeUninit;

use crate::varint::MAX_VARINT_ENCODED_LEN;

/// Encode u64 as varint.
/// Panics if buffer length is less than 10.
#[inline]
pub(crate) fn encode_varint64(mut value: u64, buf: &mut [MaybeUninit<u8>]) -> usize {
    assert!(buf.len() >= MAX_VARINT_ENCODED_LEN);

    fn iter(value: &mut u64, byte: &mut MaybeUninit<u8>) -> bool {
        if (*value & !0x7F) > 0 {
            byte.write(((*value & 0x7F) | 0x80) as u8);
            *value >>= 7;
            true
        } else {
            byte.write(*value as u8);
            false
        }
    }

    // Explicitly unroll loop to avoid either
    // unsafe code or bound checking when writing to `buf`

    if !iter(&mut value, &mut buf[0]) {
        return 1;
    };
    if !iter(&mut value, &mut buf[1]) {
        return 2;
    };
    if !iter(&mut value, &mut buf[2]) {
        return 3;
    };
    if !iter(&mut value, &mut buf[3]) {
        return 4;
    };
    if !iter(&mut value, &mut buf[4]) {
        return 5;
    };
    if !iter(&mut value, &mut buf[5]) {
        return 6;
    };
    if !iter(&mut value, &mut buf[6]) {
        return 7;
    };
    if !iter(&mut value, &mut buf[7]) {
        return 8;
    };
    if !iter(&mut value, &mut buf[8]) {
        return 9;
    };
    buf[9].write(value as u8);
    10
}

/// Encode u32 value as varint.
/// Panics if buffer length is less than 5.
#[inline]
pub(crate) fn encode_varint32(mut value: u32, buf: &mut [MaybeUninit<u8>]) -> usize {
    assert!(buf.len() >= 5);

    fn iter(value: &mut u32, byte: &mut MaybeUninit<u8>) -> bool {
        if (*value & !0x7F) > 0 {
            byte.write(((*value & 0x7F) | 0x80) as u8);
            *value >>= 7;
            true
        } else {
            byte.write(*value as u8);
            false
        }
    }

    // Explicitly unroll loop to avoid either
    // unsafe code or bound checking when writing to `buf`

    if !iter(&mut value, &mut buf[0]) {
        return 1;
    };
    if !iter(&mut value, &mut buf[1]) {
        return 2;
    };
    if !iter(&mut value, &mut buf[2]) {
        return 3;
    };
    if !iter(&mut value, &mut buf[3]) {
        return 4;
    };
    buf[4].write(value as u8);
    5
}

/// Encoded size of u64 value.
#[inline]
pub(crate) fn encoded_varint64_len(value: u64) -> usize {
    if value == 0 {
        1
    } else {
        let significant_bits = 64 - value.leading_zeros();
        (significant_bits + 6) as usize / 7
    }
}

#[cfg(test)]
mod test {
    use std::mem::MaybeUninit;

    use crate::varint::encode::encode_varint64;
    use crate::varint::encode::encoded_varint64_len;

    #[test]
    fn test_encoded_varint64_len() {
        fn test(n: u64) {
            let mut buf = [MaybeUninit::uninit(); 10];
            let expected = encode_varint64(n, &mut buf);
            assert_eq!(expected, encoded_varint64_len(n), "n={}", n);
        }

        for n in 0..1000 {
            test(n);
        }

        for p in 0.. {
            match 2u64.checked_pow(p) {
                Some(n) => test(n),
                None => break,
            }
        }

        for p in 0.. {
            match 3u64.checked_pow(p) {
                Some(n) => test(n),
                None => break,
            }
        }

        test(u64::MAX);
        test(u64::MAX - 1);
        test((i64::MAX as u64) + 1);
        test(i64::MAX as u64);
        test((i64::MAX as u64) - 1);
        test((u32::MAX as u64) + 1);
        test(u32::MAX as u64);
        test((u32::MAX as u64) - 1);
        test((i32::MAX as u64) + 1);
        test(i32::MAX as u64);
        test((i32::MAX as u64) - 1);
    }
}

'''
'''--- protobuf/src/varint/generic.rs ---
use crate::rt::compute_raw_varint64_size;

/// Helper trait implemented by integer types which could be encoded as varint.
pub(crate) trait ProtobufVarint {
    /// Size of self when encoded as varint.
    fn len_varint(&self) -> u64;
}

impl ProtobufVarint for u64 {
    fn len_varint(&self) -> u64 {
        compute_raw_varint64_size(*self)
    }
}

impl ProtobufVarint for u32 {
    fn len_varint(&self) -> u64 {
        (*self as u64).len_varint()
    }
}

impl ProtobufVarint for i64 {
    fn len_varint(&self) -> u64 {
        // same as length of u64
        (*self as u64).len_varint()
    }
}

impl ProtobufVarint for i32 {
    fn len_varint(&self) -> u64 {
        // sign-extend and then compute
        (*self as i64).len_varint()
    }
}

impl ProtobufVarint for bool {
    fn len_varint(&self) -> u64 {
        1
    }
}

'''
'''--- protobuf/src/varint/mod.rs ---
pub(crate) mod decode;
pub(crate) mod encode;
pub(crate) mod generic;

/// Encoded varint message is not longer than 10 bytes.
pub(crate) const MAX_VARINT_ENCODED_LEN: usize = 10;
pub(crate) const MAX_VARINT32_ENCODED_LEN: usize = 5;

'''
'''--- protobuf/src/well_known_types/any.rs ---
// This file is generated by rust-protobuf 4.0.0-alpha.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `google/protobuf/any.proto`

// @@protoc_insertion_point(message:google.protobuf.Any)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Any {
    // message fields
    ///  A URL/resource name that uniquely identifies the type of the serialized
    ///  protocol buffer message. This string must contain at least
    ///  one "/" character. The last segment of the URL's path must represent
    ///  the fully qualified name of the type (as in
    ///  `path/google.protobuf.Duration`). The name should be in a canonical form
    ///  (e.g., leading "." is not accepted).
    ///
    ///  In practice, teams usually precompile into the binary all types that they
    ///  expect it to use in the context of Any. However, for URLs which use the
    ///  scheme `http`, `https`, or no scheme, one can optionally set up a type
    ///  server that maps type URLs to message definitions as follows:
    ///
    ///  * If no scheme is provided, `https` is assumed.
    ///  * An HTTP GET on the URL must yield a [google.protobuf.Type][]
    ///    value in binary format, or produce an error.
    ///  * Applications are allowed to cache lookup results based on the
    ///    URL, or have them precompiled into a binary to avoid any
    ///    lookup. Therefore, binary compatibility needs to be preserved
    ///    on changes to types. (Use versioned type names to manage
    ///    breaking changes.)
    ///
    ///  Note: this functionality is not currently available in the official
    ///  protobuf release, and it is not used for type URLs beginning with
    ///  type.googleapis.com.
    ///
    ///  Schemes other than `http`, `https` (or the empty scheme) might be
    ///  used with implementation specific semantics.
    ///
    // @@protoc_insertion_point(field:google.protobuf.Any.type_url)
    pub type_url: ::std::string::String,
    ///  Must be a valid serialized protocol buffer of the above specified type.
    // @@protoc_insertion_point(field:google.protobuf.Any.value)
    pub value: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.Any.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Any {
    fn default() -> &'a Any {
        <Any as crate::Message>::default_instance()
    }
}

impl Any {
    pub fn new() -> Any {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type_url",
            |m: &Any| { &m.type_url },
            |m: &mut Any| { &mut m.type_url },
        ));
        fields.push(crate::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "value",
            |m: &Any| { &m.value },
            |m: &mut Any| { &mut m.value },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<Any>(
            "Any",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for Any {
    const NAME: &'static str = "Any";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.type_url = is.read_string()?;
                },
                18 => {
                    self.value = is.read_bytes()?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.type_url.is_empty() {
            my_size += crate::rt::string_size(1, &self.type_url);
        }
        if !self.value.is_empty() {
            my_size += crate::rt::bytes_size(2, &self.value);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if !self.type_url.is_empty() {
            os.write_string(1, &self.type_url)?;
        }
        if !self.value.is_empty() {
            os.write_bytes(2, &self.value)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Any {
        Any::new()
    }

    fn clear(&mut self) {
        self.type_url.clear();
        self.value.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Any {
        static instance: Any = Any {
            type_url: ::std::string::String::new(),
            value: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for Any {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Any").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Any {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for Any {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x19google/protobuf/any.proto\x12\x0fgoogle.protobuf\"6\n\x03Any\x12\
    \x19\n\x08type_url\x18\x01\x20\x01(\tR\x07typeUrl\x12\x14\n\x05value\x18\
    \x02\x20\x01(\x0cR\x05valueBv\n\x13com.google.protobufB\x08AnyProtoP\x01\
    Z,google.golang.org/protobuf/types/known/anypb\xa2\x02\x03GPB\xaa\x02\
    \x1eGoogle.Protobuf.WellKnownTypesJ\xf9*\n\x07\x12\x05\x1e\0\x9d\x01\x01\
    \n\xcc\x0c\n\x01\x0c\x12\x03\x1e\0\x122\xc1\x0c\x20Protocol\x20Buffers\
    \x20-\x20Google's\x20data\x20interchange\x20format\n\x20Copyright\x20200\
    8\x20Google\x20Inc.\x20\x20All\x20rights\x20reserved.\n\x20https://devel\
    opers.google.com/protocol-buffers/\n\n\x20Redistribution\x20and\x20use\
    \x20in\x20source\x20and\x20binary\x20forms,\x20with\x20or\x20without\n\
    \x20modification,\x20are\x20permitted\x20provided\x20that\x20the\x20foll\
    owing\x20conditions\x20are\n\x20met:\n\n\x20\x20\x20\x20\x20*\x20Redistr\
    ibutions\x20of\x20source\x20code\x20must\x20retain\x20the\x20above\x20co\
    pyright\n\x20notice,\x20this\x20list\x20of\x20conditions\x20and\x20the\
    \x20following\x20disclaimer.\n\x20\x20\x20\x20\x20*\x20Redistributions\
    \x20in\x20binary\x20form\x20must\x20reproduce\x20the\x20above\n\x20copyr\
    ight\x20notice,\x20this\x20list\x20of\x20conditions\x20and\x20the\x20fol\
    lowing\x20disclaimer\n\x20in\x20the\x20documentation\x20and/or\x20other\
    \x20materials\x20provided\x20with\x20the\n\x20distribution.\n\x20\x20\
    \x20\x20\x20*\x20Neither\x20the\x20name\x20of\x20Google\x20Inc.\x20nor\
    \x20the\x20names\x20of\x20its\n\x20contributors\x20may\x20be\x20used\x20\
    to\x20endorse\x20or\x20promote\x20products\x20derived\x20from\n\x20this\
    \x20software\x20without\x20specific\x20prior\x20written\x20permission.\n\
    \n\x20THIS\x20SOFTWARE\x20IS\x20PROVIDED\x20BY\x20THE\x20COPYRIGHT\x20HO\
    LDERS\x20AND\x20CONTRIBUTORS\n\x20\"AS\x20IS\"\x20AND\x20ANY\x20EXPRESS\
    \x20OR\x20IMPLIED\x20WARRANTIES,\x20INCLUDING,\x20BUT\x20NOT\n\x20LIMITE\
    D\x20TO,\x20THE\x20IMPLIED\x20WARRANTIES\x20OF\x20MERCHANTABILITY\x20AND\
    \x20FITNESS\x20FOR\n\x20A\x20PARTICULAR\x20PURPOSE\x20ARE\x20DISCLAIMED.\
    \x20IN\x20NO\x20EVENT\x20SHALL\x20THE\x20COPYRIGHT\n\x20OWNER\x20OR\x20C\
    ONTRIBUTORS\x20BE\x20LIABLE\x20FOR\x20ANY\x20DIRECT,\x20INDIRECT,\x20INC\
    IDENTAL,\n\x20SPECIAL,\x20EXEMPLARY,\x20OR\x20CONSEQUENTIAL\x20DAMAGES\
    \x20(INCLUDING,\x20BUT\x20NOT\n\x20LIMITED\x20TO,\x20PROCUREMENT\x20OF\
    \x20SUBSTITUTE\x20GOODS\x20OR\x20SERVICES;\x20LOSS\x20OF\x20USE,\n\x20DA\
    TA,\x20OR\x20PROFITS;\x20OR\x20BUSINESS\x20INTERRUPTION)\x20HOWEVER\x20C\
    AUSED\x20AND\x20ON\x20ANY\n\x20THEORY\x20OF\x20LIABILITY,\x20WHETHER\x20\
    IN\x20CONTRACT,\x20STRICT\x20LIABILITY,\x20OR\x20TORT\n\x20(INCLUDING\
    \x20NEGLIGENCE\x20OR\x20OTHERWISE)\x20ARISING\x20IN\x20ANY\x20WAY\x20OUT\
    \x20OF\x20THE\x20USE\n\x20OF\x20THIS\x20SOFTWARE,\x20EVEN\x20IF\x20ADVIS\
    ED\x20OF\x20THE\x20POSSIBILITY\x20OF\x20SUCH\x20DAMAGE.\n\n\x08\n\x01\
    \x02\x12\x03\x20\0\x18\n\x08\n\x01\x08\x12\x03\"\0;\n\t\n\x02\x08%\x12\
    \x03\"\0;\n\x08\n\x01\x08\x12\x03#\0C\n\t\n\x02\x08\x0b\x12\x03#\0C\n\
    \x08\n\x01\x08\x12\x03$\0,\n\t\n\x02\x08\x01\x12\x03$\0,\n\x08\n\x01\x08\
    \x12\x03%\0)\n\t\n\x02\x08\x08\x12\x03%\0)\n\x08\n\x01\x08\x12\x03&\0\"\
    \n\t\n\x02\x08\n\x12\x03&\0\"\n\x08\n\x01\x08\x12\x03'\0!\n\t\n\x02\x08$\
    \x12\x03'\0!\n\xfd\x10\n\x02\x04\0\x12\x05|\0\x9d\x01\x01\x1a\xef\x10\
    \x20`Any`\x20contains\x20an\x20arbitrary\x20serialized\x20protocol\x20bu\
    ffer\x20message\x20along\x20with\x20a\n\x20URL\x20that\x20describes\x20t\
    he\x20type\x20of\x20the\x20serialized\x20message.\n\n\x20Protobuf\x20lib\
    rary\x20provides\x20support\x20to\x20pack/unpack\x20Any\x20values\x20in\
    \x20the\x20form\n\x20of\x20utility\x20functions\x20or\x20additional\x20g\
    enerated\x20methods\x20of\x20the\x20Any\x20type.\n\n\x20Example\x201:\
    \x20Pack\x20and\x20unpack\x20a\x20message\x20in\x20C++.\n\n\x20\x20\x20\
    \x20\x20Foo\x20foo\x20=\x20...;\n\x20\x20\x20\x20\x20Any\x20any;\n\x20\
    \x20\x20\x20\x20any.PackFrom(foo);\n\x20\x20\x20\x20\x20...\n\x20\x20\
    \x20\x20\x20if\x20(any.UnpackTo(&foo))\x20{\n\x20\x20\x20\x20\x20\x20\
    \x20...\n\x20\x20\x20\x20\x20}\n\n\x20Example\x202:\x20Pack\x20and\x20un\
    pack\x20a\x20message\x20in\x20Java.\n\n\x20\x20\x20\x20\x20Foo\x20foo\
    \x20=\x20...;\n\x20\x20\x20\x20\x20Any\x20any\x20=\x20Any.pack(foo);\n\
    \x20\x20\x20\x20\x20...\n\x20\x20\x20\x20\x20if\x20(any.is(Foo.class))\
    \x20{\n\x20\x20\x20\x20\x20\x20\x20foo\x20=\x20any.unpack(Foo.class);\n\
    \x20\x20\x20\x20\x20}\n\n\x20\x20Example\x203:\x20Pack\x20and\x20unpack\
    \x20a\x20message\x20in\x20Python.\n\n\x20\x20\x20\x20\x20foo\x20=\x20Foo\
    (...)\n\x20\x20\x20\x20\x20any\x20=\x20Any()\n\x20\x20\x20\x20\x20any.Pa\
    ck(foo)\n\x20\x20\x20\x20\x20...\n\x20\x20\x20\x20\x20if\x20any.Is(Foo.D\
    ESCRIPTOR):\n\x20\x20\x20\x20\x20\x20\x20any.Unpack(foo)\n\x20\x20\x20\
    \x20\x20\x20\x20...\n\n\x20\x20Example\x204:\x20Pack\x20and\x20unpack\
    \x20a\x20message\x20in\x20Go\n\n\x20\x20\x20\x20\x20\x20foo\x20:=\x20&pb\
    .Foo{...}\n\x20\x20\x20\x20\x20\x20any,\x20err\x20:=\x20anypb.New(foo)\n\
    \x20\x20\x20\x20\x20\x20if\x20err\x20!=\x20nil\x20{\n\x20\x20\x20\x20\
    \x20\x20\x20\x20...\n\x20\x20\x20\x20\x20\x20}\n\x20\x20\x20\x20\x20\x20\
    ...\n\x20\x20\x20\x20\x20\x20foo\x20:=\x20&pb.Foo{}\n\x20\x20\x20\x20\
    \x20\x20if\x20err\x20:=\x20any.UnmarshalTo(foo);\x20err\x20!=\x20nil\x20\
    {\n\x20\x20\x20\x20\x20\x20\x20\x20...\n\x20\x20\x20\x20\x20\x20}\n\n\
    \x20The\x20pack\x20methods\x20provided\x20by\x20protobuf\x20library\x20w\
    ill\x20by\x20default\x20use\n\x20'type.googleapis.com/full.type.name'\
    \x20as\x20the\x20type\x20URL\x20and\x20the\x20unpack\n\x20methods\x20onl\
    y\x20use\x20the\x20fully\x20qualified\x20type\x20name\x20after\x20the\
    \x20last\x20'/'\n\x20in\x20the\x20type\x20URL,\x20for\x20example\x20\"fo\
    o.bar.com/x/y.z\"\x20will\x20yield\x20type\n\x20name\x20\"y.z\".\n\n\n\
    \x20JSON\n\x20====\n\x20The\x20JSON\x20representation\x20of\x20an\x20`An\
    y`\x20value\x20uses\x20the\x20regular\n\x20representation\x20of\x20the\
    \x20deserialized,\x20embedded\x20message,\x20with\x20an\n\x20additional\
    \x20field\x20`@type`\x20which\x20contains\x20the\x20type\x20URL.\x20Exam\
    ple:\n\n\x20\x20\x20\x20\x20package\x20google.profile;\n\x20\x20\x20\x20\
    \x20message\x20Person\x20{\n\x20\x20\x20\x20\x20\x20\x20string\x20first_\
    name\x20=\x201;\n\x20\x20\x20\x20\x20\x20\x20string\x20last_name\x20=\
    \x202;\n\x20\x20\x20\x20\x20}\n\n\x20\x20\x20\x20\x20{\n\x20\x20\x20\x20\
    \x20\x20\x20\"@type\":\x20\"type.googleapis.com/google.profile.Person\",\
    \n\x20\x20\x20\x20\x20\x20\x20\"firstName\":\x20<string>,\n\x20\x20\x20\
    \x20\x20\x20\x20\"lastName\":\x20<string>\n\x20\x20\x20\x20\x20}\n\n\x20\
    If\x20the\x20embedded\x20message\x20type\x20is\x20well-known\x20and\x20h\
    as\x20a\x20custom\x20JSON\n\x20representation,\x20that\x20representation\
    \x20will\x20be\x20embedded\x20adding\x20a\x20field\n\x20`value`\x20which\
    \x20holds\x20the\x20custom\x20JSON\x20in\x20addition\x20to\x20the\x20`@t\
    ype`\n\x20field.\x20Example\x20(for\x20message\x20[google.protobuf.Durat\
    ion][]):\n\n\x20\x20\x20\x20\x20{\n\x20\x20\x20\x20\x20\x20\x20\"@type\"\
    :\x20\"type.googleapis.com/google.protobuf.Duration\",\n\x20\x20\x20\x20\
    \x20\x20\x20\"value\":\x20\"1.212s\"\n\x20\x20\x20\x20\x20}\n\n\n\n\n\
    \x03\x04\0\x01\x12\x03|\x08\x0b\n\xd7\n\n\x04\x04\0\x02\0\x12\x04\x99\
    \x01\x02\x16\x1a\xc8\n\x20A\x20URL/resource\x20name\x20that\x20uniquely\
    \x20identifies\x20the\x20type\x20of\x20the\x20serialized\n\x20protocol\
    \x20buffer\x20message.\x20This\x20string\x20must\x20contain\x20at\x20lea\
    st\n\x20one\x20\"/\"\x20character.\x20The\x20last\x20segment\x20of\x20th\
    e\x20URL's\x20path\x20must\x20represent\n\x20the\x20fully\x20qualified\
    \x20name\x20of\x20the\x20type\x20(as\x20in\n\x20`path/google.protobuf.Du\
    ration`).\x20The\x20name\x20should\x20be\x20in\x20a\x20canonical\x20form\
    \n\x20(e.g.,\x20leading\x20\".\"\x20is\x20not\x20accepted).\n\n\x20In\
    \x20practice,\x20teams\x20usually\x20precompile\x20into\x20the\x20binary\
    \x20all\x20types\x20that\x20they\n\x20expect\x20it\x20to\x20use\x20in\
    \x20the\x20context\x20of\x20Any.\x20However,\x20for\x20URLs\x20which\x20\
    use\x20the\n\x20scheme\x20`http`,\x20`https`,\x20or\x20no\x20scheme,\x20\
    one\x20can\x20optionally\x20set\x20up\x20a\x20type\n\x20server\x20that\
    \x20maps\x20type\x20URLs\x20to\x20message\x20definitions\x20as\x20follow\
    s:\n\n\x20*\x20If\x20no\x20scheme\x20is\x20provided,\x20`https`\x20is\
    \x20assumed.\n\x20*\x20An\x20HTTP\x20GET\x20on\x20the\x20URL\x20must\x20\
    yield\x20a\x20[google.protobuf.Type][]\n\x20\x20\x20value\x20in\x20binar\
    y\x20format,\x20or\x20produce\x20an\x20error.\n\x20*\x20Applications\x20\
    are\x20allowed\x20to\x20cache\x20lookup\x20results\x20based\x20on\x20the\
    \n\x20\x20\x20URL,\x20or\x20have\x20them\x20precompiled\x20into\x20a\x20\
    binary\x20to\x20avoid\x20any\n\x20\x20\x20lookup.\x20Therefore,\x20binar\
    y\x20compatibility\x20needs\x20to\x20be\x20preserved\n\x20\x20\x20on\x20\
    changes\x20to\x20types.\x20(Use\x20versioned\x20type\x20names\x20to\x20m\
    anage\n\x20\x20\x20breaking\x20changes.)\n\n\x20Note:\x20this\x20functio\
    nality\x20is\x20not\x20currently\x20available\x20in\x20the\x20official\n\
    \x20protobuf\x20release,\x20and\x20it\x20is\x20not\x20used\x20for\x20typ\
    e\x20URLs\x20beginning\x20with\n\x20type.googleapis.com.\n\n\x20Schemes\
    \x20other\x20than\x20`http`,\x20`https`\x20(or\x20the\x20empty\x20scheme\
    )\x20might\x20be\n\x20used\x20with\x20implementation\x20specific\x20sema\
    ntics.\n\n\n\r\n\x05\x04\0\x02\0\x05\x12\x04\x99\x01\x02\x08\n\r\n\x05\
    \x04\0\x02\0\x01\x12\x04\x99\x01\t\x11\n\r\n\x05\x04\0\x02\0\x03\x12\x04\
    \x99\x01\x14\x15\nW\n\x04\x04\0\x02\x01\x12\x04\x9c\x01\x02\x12\x1aI\x20\
    Must\x20be\x20a\x20valid\x20serialized\x20protocol\x20buffer\x20of\x20th\
    e\x20above\x20specified\x20type.\n\n\r\n\x05\x04\0\x02\x01\x05\x12\x04\
    \x9c\x01\x02\x07\n\r\n\x05\x04\0\x02\x01\x01\x12\x04\x9c\x01\x08\r\n\r\n\
    \x05\x04\0\x02\x01\x03\x12\x04\x9c\x01\x10\x11b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static crate::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: crate::rt::Lazy<crate::descriptor::FileDescriptorProto> = crate::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        crate::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static crate::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: crate::rt::Lazy<crate::reflect::GeneratedFileDescriptor> = crate::rt::Lazy::new();
    static file_descriptor: crate::rt::Lazy<crate::reflect::FileDescriptor> = crate::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(1);
            messages.push(Any::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            crate::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        crate::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}

'''
'''--- protobuf/src/well_known_types/api.rs ---
// This file is generated by rust-protobuf 4.0.0-alpha.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `google/protobuf/api.proto`

///  Api is a light-weight descriptor for an API Interface.
///
///  Interfaces are also described as "protocol buffer services" in some contexts,
///  such as by the "service" keyword in a .proto file, but they are different
///  from API Services, which represent a concrete implementation of an interface
///  as opposed to simply a description of methods and bindings. They are also
///  sometimes simply referred to as "APIs" in other contexts, such as the name of
///  this message itself. See https://cloud.google.com/apis/design/glossary for
///  detailed terminology.
// @@protoc_insertion_point(message:google.protobuf.Api)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Api {
    // message fields
    ///  The fully qualified name of this interface, including package name
    ///  followed by the interface's simple name.
    // @@protoc_insertion_point(field:google.protobuf.Api.name)
    pub name: ::std::string::String,
    ///  The methods of this interface, in unspecified order.
    // @@protoc_insertion_point(field:google.protobuf.Api.methods)
    pub methods: ::std::vec::Vec<Method>,
    ///  Any metadata attached to the interface.
    // @@protoc_insertion_point(field:google.protobuf.Api.options)
    pub options: ::std::vec::Vec<crate::well_known_types::type_::Option>,
    ///  A version string for this interface. If specified, must have the form
    ///  `major-version.minor-version`, as in `1.10`. If the minor version is
    ///  omitted, it defaults to zero. If the entire version field is empty, the
    ///  major version is derived from the package name, as outlined below. If the
    ///  field is not empty, the version in the package name will be verified to be
    ///  consistent with what is provided here.
    ///
    ///  The versioning schema uses [semantic
    ///  versioning](http://semver.org) where the major version number
    ///  indicates a breaking change and the minor version an additive,
    ///  non-breaking change. Both version numbers are signals to users
    ///  what to expect from different versions, and should be carefully
    ///  chosen based on the product plan.
    ///
    ///  The major version is also reflected in the package name of the
    ///  interface, which must end in `v<major-version>`, as in
    ///  `google.feature.v1`. For major versions 0 and 1, the suffix can
    ///  be omitted. Zero major versions must only be used for
    ///  experimental, non-GA interfaces.
    ///
    ///
    // @@protoc_insertion_point(field:google.protobuf.Api.version)
    pub version: ::std::string::String,
    ///  Source context for the protocol buffer service represented by this
    ///  message.
    // @@protoc_insertion_point(field:google.protobuf.Api.source_context)
    pub source_context: crate::MessageField<crate::well_known_types::source_context::SourceContext>,
    ///  Included interfaces. See [Mixin][].
    // @@protoc_insertion_point(field:google.protobuf.Api.mixins)
    pub mixins: ::std::vec::Vec<Mixin>,
    ///  The source syntax of the service.
    // @@protoc_insertion_point(field:google.protobuf.Api.syntax)
    pub syntax: crate::EnumOrUnknown<crate::well_known_types::type_::Syntax>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.Api.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Api {
    fn default() -> &'a Api {
        <Api as crate::Message>::default_instance()
    }
}

impl Api {
    pub fn new() -> Api {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &Api| { &m.name },
            |m: &mut Api| { &mut m.name },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "methods",
            |m: &Api| { &m.methods },
            |m: &mut Api| { &mut m.methods },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "options",
            |m: &Api| { &m.options },
            |m: &mut Api| { &mut m.options },
        ));
        fields.push(crate::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version",
            |m: &Api| { &m.version },
            |m: &mut Api| { &mut m.version },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, crate::well_known_types::source_context::SourceContext>(
            "source_context",
            |m: &Api| { &m.source_context },
            |m: &mut Api| { &mut m.source_context },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "mixins",
            |m: &Api| { &m.mixins },
            |m: &mut Api| { &mut m.mixins },
        ));
        fields.push(crate::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "syntax",
            |m: &Api| { &m.syntax },
            |m: &mut Api| { &mut m.syntax },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<Api>(
            "Api",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for Api {
    const NAME: &'static str = "Api";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                18 => {
                    self.methods.push(is.read_message()?);
                },
                26 => {
                    self.options.push(is.read_message()?);
                },
                34 => {
                    self.version = is.read_string()?;
                },
                42 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.source_context)?;
                },
                50 => {
                    self.mixins.push(is.read_message()?);
                },
                56 => {
                    self.syntax = is.read_enum_or_unknown()?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += crate::rt::string_size(1, &self.name);
        }
        for value in &self.methods {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.options {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.version.is_empty() {
            my_size += crate::rt::string_size(4, &self.version);
        }
        if let Some(v) = self.source_context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.mixins {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if self.syntax != crate::EnumOrUnknown::new(crate::well_known_types::type_::Syntax::SYNTAX_PROTO2) {
            my_size += crate::rt::int32_size(7, self.syntax.value());
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        for v in &self.methods {
            crate::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.options {
            crate::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if !self.version.is_empty() {
            os.write_string(4, &self.version)?;
        }
        if let Some(v) = self.source_context.as_ref() {
            crate::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        for v in &self.mixins {
            crate::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        if self.syntax != crate::EnumOrUnknown::new(crate::well_known_types::type_::Syntax::SYNTAX_PROTO2) {
            os.write_enum(7, crate::EnumOrUnknown::value(&self.syntax))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Api {
        Api::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.methods.clear();
        self.options.clear();
        self.version.clear();
        self.source_context.clear();
        self.mixins.clear();
        self.syntax = crate::EnumOrUnknown::new(crate::well_known_types::type_::Syntax::SYNTAX_PROTO2);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Api {
        static instance: Api = Api {
            name: ::std::string::String::new(),
            methods: ::std::vec::Vec::new(),
            options: ::std::vec::Vec::new(),
            version: ::std::string::String::new(),
            source_context: crate::MessageField::none(),
            mixins: ::std::vec::Vec::new(),
            syntax: crate::EnumOrUnknown::from_i32(0),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for Api {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Api").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Api {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for Api {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Method represents a method of an API interface.
// @@protoc_insertion_point(message:google.protobuf.Method)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Method {
    // message fields
    ///  The simple name of this method.
    // @@protoc_insertion_point(field:google.protobuf.Method.name)
    pub name: ::std::string::String,
    ///  A URL of the input message type.
    // @@protoc_insertion_point(field:google.protobuf.Method.request_type_url)
    pub request_type_url: ::std::string::String,
    ///  If true, the request is streamed.
    // @@protoc_insertion_point(field:google.protobuf.Method.request_streaming)
    pub request_streaming: bool,
    ///  The URL of the output message type.
    // @@protoc_insertion_point(field:google.protobuf.Method.response_type_url)
    pub response_type_url: ::std::string::String,
    ///  If true, the response is streamed.
    // @@protoc_insertion_point(field:google.protobuf.Method.response_streaming)
    pub response_streaming: bool,
    ///  Any metadata attached to the method.
    // @@protoc_insertion_point(field:google.protobuf.Method.options)
    pub options: ::std::vec::Vec<crate::well_known_types::type_::Option>,
    ///  The source syntax of this method.
    // @@protoc_insertion_point(field:google.protobuf.Method.syntax)
    pub syntax: crate::EnumOrUnknown<crate::well_known_types::type_::Syntax>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.Method.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Method {
    fn default() -> &'a Method {
        <Method as crate::Message>::default_instance()
    }
}

impl Method {
    pub fn new() -> Method {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &Method| { &m.name },
            |m: &mut Method| { &mut m.name },
        ));
        fields.push(crate::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "request_type_url",
            |m: &Method| { &m.request_type_url },
            |m: &mut Method| { &mut m.request_type_url },
        ));
        fields.push(crate::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "request_streaming",
            |m: &Method| { &m.request_streaming },
            |m: &mut Method| { &mut m.request_streaming },
        ));
        fields.push(crate::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "response_type_url",
            |m: &Method| { &m.response_type_url },
            |m: &mut Method| { &mut m.response_type_url },
        ));
        fields.push(crate::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "response_streaming",
            |m: &Method| { &m.response_streaming },
            |m: &mut Method| { &mut m.response_streaming },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "options",
            |m: &Method| { &m.options },
            |m: &mut Method| { &mut m.options },
        ));
        fields.push(crate::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "syntax",
            |m: &Method| { &m.syntax },
            |m: &mut Method| { &mut m.syntax },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<Method>(
            "Method",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for Method {
    const NAME: &'static str = "Method";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                18 => {
                    self.request_type_url = is.read_string()?;
                },
                24 => {
                    self.request_streaming = is.read_bool()?;
                },
                34 => {
                    self.response_type_url = is.read_string()?;
                },
                40 => {
                    self.response_streaming = is.read_bool()?;
                },
                50 => {
                    self.options.push(is.read_message()?);
                },
                56 => {
                    self.syntax = is.read_enum_or_unknown()?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += crate::rt::string_size(1, &self.name);
        }
        if !self.request_type_url.is_empty() {
            my_size += crate::rt::string_size(2, &self.request_type_url);
        }
        if self.request_streaming != false {
            my_size += 1 + 1;
        }
        if !self.response_type_url.is_empty() {
            my_size += crate::rt::string_size(4, &self.response_type_url);
        }
        if self.response_streaming != false {
            my_size += 1 + 1;
        }
        for value in &self.options {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if self.syntax != crate::EnumOrUnknown::new(crate::well_known_types::type_::Syntax::SYNTAX_PROTO2) {
            my_size += crate::rt::int32_size(7, self.syntax.value());
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.request_type_url.is_empty() {
            os.write_string(2, &self.request_type_url)?;
        }
        if self.request_streaming != false {
            os.write_bool(3, self.request_streaming)?;
        }
        if !self.response_type_url.is_empty() {
            os.write_string(4, &self.response_type_url)?;
        }
        if self.response_streaming != false {
            os.write_bool(5, self.response_streaming)?;
        }
        for v in &self.options {
            crate::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        if self.syntax != crate::EnumOrUnknown::new(crate::well_known_types::type_::Syntax::SYNTAX_PROTO2) {
            os.write_enum(7, crate::EnumOrUnknown::value(&self.syntax))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Method {
        Method::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.request_type_url.clear();
        self.request_streaming = false;
        self.response_type_url.clear();
        self.response_streaming = false;
        self.options.clear();
        self.syntax = crate::EnumOrUnknown::new(crate::well_known_types::type_::Syntax::SYNTAX_PROTO2);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Method {
        static instance: Method = Method {
            name: ::std::string::String::new(),
            request_type_url: ::std::string::String::new(),
            request_streaming: false,
            response_type_url: ::std::string::String::new(),
            response_streaming: false,
            options: ::std::vec::Vec::new(),
            syntax: crate::EnumOrUnknown::from_i32(0),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for Method {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Method").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Method {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for Method {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:google.protobuf.Mixin)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Mixin {
    // message fields
    ///  The fully qualified name of the interface which is included.
    // @@protoc_insertion_point(field:google.protobuf.Mixin.name)
    pub name: ::std::string::String,
    ///  If non-empty specifies a path under which inherited HTTP paths
    ///  are rooted.
    // @@protoc_insertion_point(field:google.protobuf.Mixin.root)
    pub root: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.Mixin.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Mixin {
    fn default() -> &'a Mixin {
        <Mixin as crate::Message>::default_instance()
    }
}

impl Mixin {
    pub fn new() -> Mixin {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &Mixin| { &m.name },
            |m: &mut Mixin| { &mut m.name },
        ));
        fields.push(crate::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "root",
            |m: &Mixin| { &m.root },
            |m: &mut Mixin| { &mut m.root },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<Mixin>(
            "Mixin",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for Mixin {
    const NAME: &'static str = "Mixin";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                18 => {
                    self.root = is.read_string()?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += crate::rt::string_size(1, &self.name);
        }
        if !self.root.is_empty() {
            my_size += crate::rt::string_size(2, &self.root);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.root.is_empty() {
            os.write_string(2, &self.root)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Mixin {
        Mixin::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.root.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Mixin {
        static instance: Mixin = Mixin {
            name: ::std::string::String::new(),
            root: ::std::string::String::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for Mixin {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Mixin").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Mixin {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for Mixin {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x19google/protobuf/api.proto\x12\x0fgoogle.protobuf\x1a$google/protob\
    uf/source_context.proto\x1a\x1agoogle/protobuf/type.proto\"\xc1\x02\n\
    \x03Api\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x121\n\x07methods\
    \x18\x02\x20\x03(\x0b2\x17.google.protobuf.MethodR\x07methods\x121\n\x07\
    options\x18\x03\x20\x03(\x0b2\x17.google.protobuf.OptionR\x07options\x12\
    \x18\n\x07version\x18\x04\x20\x01(\tR\x07version\x12E\n\x0esource_contex\
    t\x18\x05\x20\x01(\x0b2\x1e.google.protobuf.SourceContextR\rsourceContex\
    t\x12.\n\x06mixins\x18\x06\x20\x03(\x0b2\x16.google.protobuf.MixinR\x06m\
    ixins\x12/\n\x06syntax\x18\x07\x20\x01(\x0e2\x17.google.protobuf.SyntaxR\
    \x06syntax\"\xb2\x02\n\x06Method\x12\x12\n\x04name\x18\x01\x20\x01(\tR\
    \x04name\x12(\n\x10request_type_url\x18\x02\x20\x01(\tR\x0erequestTypeUr\
    l\x12+\n\x11request_streaming\x18\x03\x20\x01(\x08R\x10requestStreaming\
    \x12*\n\x11response_type_url\x18\x04\x20\x01(\tR\x0fresponseTypeUrl\x12-\
    \n\x12response_streaming\x18\x05\x20\x01(\x08R\x11responseStreaming\x121\
    \n\x07options\x18\x06\x20\x03(\x0b2\x17.google.protobuf.OptionR\x07optio\
    ns\x12/\n\x06syntax\x18\x07\x20\x01(\x0e2\x17.google.protobuf.SyntaxR\
    \x06syntax\"/\n\x05Mixin\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\
    \x12\x12\n\x04root\x18\x02\x20\x01(\tR\x04rootBv\n\x13com.google.protobu\
    fB\x08ApiProtoP\x01Z,google.golang.org/protobuf/types/known/apipb\xa2\
    \x02\x03GPB\xaa\x02\x1eGoogle.Protobuf.WellKnownTypesJ\x81<\n\x07\x12\
    \x05\x1e\0\xcf\x01\x01\n\xcc\x0c\n\x01\x0c\x12\x03\x1e\0\x122\xc1\x0c\
    \x20Protocol\x20Buffers\x20-\x20Google's\x20data\x20interchange\x20forma\
    t\n\x20Copyright\x202008\x20Google\x20Inc.\x20\x20All\x20rights\x20reser\
    ved.\n\x20https://developers.google.com/protocol-buffers/\n\n\x20Redistr\
    ibution\x20and\x20use\x20in\x20source\x20and\x20binary\x20forms,\x20with\
    \x20or\x20without\n\x20modification,\x20are\x20permitted\x20provided\x20\
    that\x20the\x20following\x20conditions\x20are\n\x20met:\n\n\x20\x20\x20\
    \x20\x20*\x20Redistributions\x20of\x20source\x20code\x20must\x20retain\
    \x20the\x20above\x20copyright\n\x20notice,\x20this\x20list\x20of\x20cond\
    itions\x20and\x20the\x20following\x20disclaimer.\n\x20\x20\x20\x20\x20*\
    \x20Redistributions\x20in\x20binary\x20form\x20must\x20reproduce\x20the\
    \x20above\n\x20copyright\x20notice,\x20this\x20list\x20of\x20conditions\
    \x20and\x20the\x20following\x20disclaimer\n\x20in\x20the\x20documentatio\
    n\x20and/or\x20other\x20materials\x20provided\x20with\x20the\n\x20distri\
    bution.\n\x20\x20\x20\x20\x20*\x20Neither\x20the\x20name\x20of\x20Google\
    \x20Inc.\x20nor\x20the\x20names\x20of\x20its\n\x20contributors\x20may\
    \x20be\x20used\x20to\x20endorse\x20or\x20promote\x20products\x20derived\
    \x20from\n\x20this\x20software\x20without\x20specific\x20prior\x20writte\
    n\x20permission.\n\n\x20THIS\x20SOFTWARE\x20IS\x20PROVIDED\x20BY\x20THE\
    \x20COPYRIGHT\x20HOLDERS\x20AND\x20CONTRIBUTORS\n\x20\"AS\x20IS\"\x20AND\
    \x20ANY\x20EXPRESS\x20OR\x20IMPLIED\x20WARRANTIES,\x20INCLUDING,\x20BUT\
    \x20NOT\n\x20LIMITED\x20TO,\x20THE\x20IMPLIED\x20WARRANTIES\x20OF\x20MER\
    CHANTABILITY\x20AND\x20FITNESS\x20FOR\n\x20A\x20PARTICULAR\x20PURPOSE\
    \x20ARE\x20DISCLAIMED.\x20IN\x20NO\x20EVENT\x20SHALL\x20THE\x20COPYRIGHT\
    \n\x20OWNER\x20OR\x20CONTRIBUTORS\x20BE\x20LIABLE\x20FOR\x20ANY\x20DIREC\
    T,\x20INDIRECT,\x20INCIDENTAL,\n\x20SPECIAL,\x20EXEMPLARY,\x20OR\x20CONS\
    EQUENTIAL\x20DAMAGES\x20(INCLUDING,\x20BUT\x20NOT\n\x20LIMITED\x20TO,\
    \x20PROCUREMENT\x20OF\x20SUBSTITUTE\x20GOODS\x20OR\x20SERVICES;\x20LOSS\
    \x20OF\x20USE,\n\x20DATA,\x20OR\x20PROFITS;\x20OR\x20BUSINESS\x20INTERRU\
    PTION)\x20HOWEVER\x20CAUSED\x20AND\x20ON\x20ANY\n\x20THEORY\x20OF\x20LIA\
    BILITY,\x20WHETHER\x20IN\x20CONTRACT,\x20STRICT\x20LIABILITY,\x20OR\x20T\
    ORT\n\x20(INCLUDING\x20NEGLIGENCE\x20OR\x20OTHERWISE)\x20ARISING\x20IN\
    \x20ANY\x20WAY\x20OUT\x20OF\x20THE\x20USE\n\x20OF\x20THIS\x20SOFTWARE,\
    \x20EVEN\x20IF\x20ADVISED\x20OF\x20THE\x20POSSIBILITY\x20OF\x20SUCH\x20D\
    AMAGE.\n\n\x08\n\x01\x02\x12\x03\x20\0\x18\n\t\n\x02\x03\0\x12\x03\"\0.\
    \n\t\n\x02\x03\x01\x12\x03#\0$\n\x08\n\x01\x08\x12\x03%\0;\n\t\n\x02\x08\
    %\x12\x03%\0;\n\x08\n\x01\x08\x12\x03&\0,\n\t\n\x02\x08\x01\x12\x03&\0,\
    \n\x08\n\x01\x08\x12\x03'\0)\n\t\n\x02\x08\x08\x12\x03'\0)\n\x08\n\x01\
    \x08\x12\x03(\0\"\n\t\n\x02\x08\n\x12\x03(\0\"\n\x08\n\x01\x08\x12\x03)\
    \0!\n\t\n\x02\x08$\x12\x03)\0!\n\x08\n\x01\x08\x12\x03*\0C\n\t\n\x02\x08\
    \x0b\x12\x03*\0C\n\xab\x04\n\x02\x04\0\x12\x045\0`\x01\x1a\x9e\x04\x20Ap\
    i\x20is\x20a\x20light-weight\x20descriptor\x20for\x20an\x20API\x20Interf\
    ace.\n\n\x20Interfaces\x20are\x20also\x20described\x20as\x20\"protocol\
    \x20buffer\x20services\"\x20in\x20some\x20contexts,\n\x20such\x20as\x20b\
    y\x20the\x20\"service\"\x20keyword\x20in\x20a\x20.proto\x20file,\x20but\
    \x20they\x20are\x20different\n\x20from\x20API\x20Services,\x20which\x20r\
    epresent\x20a\x20concrete\x20implementation\x20of\x20an\x20interface\n\
    \x20as\x20opposed\x20to\x20simply\x20a\x20description\x20of\x20methods\
    \x20and\x20bindings.\x20They\x20are\x20also\n\x20sometimes\x20simply\x20\
    referred\x20to\x20as\x20\"APIs\"\x20in\x20other\x20contexts,\x20such\x20\
    as\x20the\x20name\x20of\n\x20this\x20message\x20itself.\x20See\x20https:\
    //cloud.google.com/apis/design/glossary\x20for\n\x20detailed\x20terminol\
    ogy.\n\n\n\n\x03\x04\0\x01\x12\x035\x08\x0b\n{\n\x04\x04\0\x02\0\x12\x03\
    8\x02\x12\x1an\x20The\x20fully\x20qualified\x20name\x20of\x20this\x20int\
    erface,\x20including\x20package\x20name\n\x20followed\x20by\x20the\x20in\
    terface's\x20simple\x20name.\n\n\x0c\n\x05\x04\0\x02\0\x05\x12\x038\x02\
    \x08\n\x0c\n\x05\x04\0\x02\0\x01\x12\x038\t\r\n\x0c\n\x05\x04\0\x02\0\
    \x03\x12\x038\x10\x11\nC\n\x04\x04\0\x02\x01\x12\x03;\x02\x1e\x1a6\x20Th\
    e\x20methods\x20of\x20this\x20interface,\x20in\x20unspecified\x20order.\
    \n\n\x0c\n\x05\x04\0\x02\x01\x04\x12\x03;\x02\n\n\x0c\n\x05\x04\0\x02\
    \x01\x06\x12\x03;\x0b\x11\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03;\x12\x19\
    \n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03;\x1c\x1d\n6\n\x04\x04\0\x02\x02\
    \x12\x03>\x02\x1e\x1a)\x20Any\x20metadata\x20attached\x20to\x20the\x20in\
    terface.\n\n\x0c\n\x05\x04\0\x02\x02\x04\x12\x03>\x02\n\n\x0c\n\x05\x04\
    \0\x02\x02\x06\x12\x03>\x0b\x11\n\x0c\n\x05\x04\0\x02\x02\x01\x12\x03>\
    \x12\x19\n\x0c\n\x05\x04\0\x02\x02\x03\x12\x03>\x1c\x1d\n\x82\x08\n\x04\
    \x04\0\x02\x03\x12\x03U\x02\x15\x1a\xf4\x07\x20A\x20version\x20string\
    \x20for\x20this\x20interface.\x20If\x20specified,\x20must\x20have\x20the\
    \x20form\n\x20`major-version.minor-version`,\x20as\x20in\x20`1.10`.\x20I\
    f\x20the\x20minor\x20version\x20is\n\x20omitted,\x20it\x20defaults\x20to\
    \x20zero.\x20If\x20the\x20entire\x20version\x20field\x20is\x20empty,\x20\
    the\n\x20major\x20version\x20is\x20derived\x20from\x20the\x20package\x20\
    name,\x20as\x20outlined\x20below.\x20If\x20the\n\x20field\x20is\x20not\
    \x20empty,\x20the\x20version\x20in\x20the\x20package\x20name\x20will\x20\
    be\x20verified\x20to\x20be\n\x20consistent\x20with\x20what\x20is\x20prov\
    ided\x20here.\n\n\x20The\x20versioning\x20schema\x20uses\x20[semantic\n\
    \x20versioning](http://semver.org)\x20where\x20the\x20major\x20version\
    \x20number\n\x20indicates\x20a\x20breaking\x20change\x20and\x20the\x20mi\
    nor\x20version\x20an\x20additive,\n\x20non-breaking\x20change.\x20Both\
    \x20version\x20numbers\x20are\x20signals\x20to\x20users\n\x20what\x20to\
    \x20expect\x20from\x20different\x20versions,\x20and\x20should\x20be\x20c\
    arefully\n\x20chosen\x20based\x20on\x20the\x20product\x20plan.\n\n\x20Th\
    e\x20major\x20version\x20is\x20also\x20reflected\x20in\x20the\x20package\
    \x20name\x20of\x20the\n\x20interface,\x20which\x20must\x20end\x20in\x20`\
    v<major-version>`,\x20as\x20in\n\x20`google.feature.v1`.\x20For\x20major\
    \x20versions\x200\x20and\x201,\x20the\x20suffix\x20can\n\x20be\x20omitte\
    d.\x20Zero\x20major\x20versions\x20must\x20only\x20be\x20used\x20for\n\
    \x20experimental,\x20non-GA\x20interfaces.\n\n\n\n\x0c\n\x05\x04\0\x02\
    \x03\x05\x12\x03U\x02\x08\n\x0c\n\x05\x04\0\x02\x03\x01\x12\x03U\t\x10\n\
    \x0c\n\x05\x04\0\x02\x03\x03\x12\x03U\x13\x14\n[\n\x04\x04\0\x02\x04\x12\
    \x03Y\x02#\x1aN\x20Source\x20context\x20for\x20the\x20protocol\x20buffer\
    \x20service\x20represented\x20by\x20this\n\x20message.\n\n\x0c\n\x05\x04\
    \0\x02\x04\x06\x12\x03Y\x02\x0f\n\x0c\n\x05\x04\0\x02\x04\x01\x12\x03Y\
    \x10\x1e\n\x0c\n\x05\x04\0\x02\x04\x03\x12\x03Y!\"\n2\n\x04\x04\0\x02\
    \x05\x12\x03\\\x02\x1c\x1a%\x20Included\x20interfaces.\x20See\x20[Mixin]\
    [].\n\n\x0c\n\x05\x04\0\x02\x05\x04\x12\x03\\\x02\n\n\x0c\n\x05\x04\0\
    \x02\x05\x06\x12\x03\\\x0b\x10\n\x0c\n\x05\x04\0\x02\x05\x01\x12\x03\\\
    \x11\x17\n\x0c\n\x05\x04\0\x02\x05\x03\x12\x03\\\x1a\x1b\n0\n\x04\x04\0\
    \x02\x06\x12\x03_\x02\x14\x1a#\x20The\x20source\x20syntax\x20of\x20the\
    \x20service.\n\n\x0c\n\x05\x04\0\x02\x06\x06\x12\x03_\x02\x08\n\x0c\n\
    \x05\x04\0\x02\x06\x01\x12\x03_\t\x0f\n\x0c\n\x05\x04\0\x02\x06\x03\x12\
    \x03_\x12\x13\n=\n\x02\x04\x01\x12\x04c\0x\x01\x1a1\x20Method\x20represe\
    nts\x20a\x20method\x20of\x20an\x20API\x20interface.\n\n\n\n\x03\x04\x01\
    \x01\x12\x03c\x08\x0e\n.\n\x04\x04\x01\x02\0\x12\x03e\x02\x12\x1a!\x20Th\
    e\x20simple\x20name\x20of\x20this\x20method.\n\n\x0c\n\x05\x04\x01\x02\0\
    \x05\x12\x03e\x02\x08\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03e\t\r\n\x0c\n\
    \x05\x04\x01\x02\0\x03\x12\x03e\x10\x11\n/\n\x04\x04\x01\x02\x01\x12\x03\
    h\x02\x1e\x1a\"\x20A\x20URL\x20of\x20the\x20input\x20message\x20type.\n\
    \n\x0c\n\x05\x04\x01\x02\x01\x05\x12\x03h\x02\x08\n\x0c\n\x05\x04\x01\
    \x02\x01\x01\x12\x03h\t\x19\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x03h\x1c\
    \x1d\n0\n\x04\x04\x01\x02\x02\x12\x03k\x02\x1d\x1a#\x20If\x20true,\x20th\
    e\x20request\x20is\x20streamed.\n\n\x0c\n\x05\x04\x01\x02\x02\x05\x12\
    \x03k\x02\x06\n\x0c\n\x05\x04\x01\x02\x02\x01\x12\x03k\x07\x18\n\x0c\n\
    \x05\x04\x01\x02\x02\x03\x12\x03k\x1b\x1c\n2\n\x04\x04\x01\x02\x03\x12\
    \x03n\x02\x1f\x1a%\x20The\x20URL\x20of\x20the\x20output\x20message\x20ty\
    pe.\n\n\x0c\n\x05\x04\x01\x02\x03\x05\x12\x03n\x02\x08\n\x0c\n\x05\x04\
    \x01\x02\x03\x01\x12\x03n\t\x1a\n\x0c\n\x05\x04\x01\x02\x03\x03\x12\x03n\
    \x1d\x1e\n1\n\x04\x04\x01\x02\x04\x12\x03q\x02\x1e\x1a$\x20If\x20true,\
    \x20the\x20response\x20is\x20streamed.\n\n\x0c\n\x05\x04\x01\x02\x04\x05\
    \x12\x03q\x02\x06\n\x0c\n\x05\x04\x01\x02\x04\x01\x12\x03q\x07\x19\n\x0c\
    \n\x05\x04\x01\x02\x04\x03\x12\x03q\x1c\x1d\n3\n\x04\x04\x01\x02\x05\x12\
    \x03t\x02\x1e\x1a&\x20Any\x20metadata\x20attached\x20to\x20the\x20method\
    .\n\n\x0c\n\x05\x04\x01\x02\x05\x04\x12\x03t\x02\n\n\x0c\n\x05\x04\x01\
    \x02\x05\x06\x12\x03t\x0b\x11\n\x0c\n\x05\x04\x01\x02\x05\x01\x12\x03t\
    \x12\x19\n\x0c\n\x05\x04\x01\x02\x05\x03\x12\x03t\x1c\x1d\n0\n\x04\x04\
    \x01\x02\x06\x12\x03w\x02\x14\x1a#\x20The\x20source\x20syntax\x20of\x20t\
    his\x20method.\n\n\x0c\n\x05\x04\x01\x02\x06\x06\x12\x03w\x02\x08\n\x0c\
    \n\x05\x04\x01\x02\x06\x01\x12\x03w\t\x0f\n\x0c\n\x05\x04\x01\x02\x06\
    \x03\x12\x03w\x12\x13\n\xca\x13\n\x02\x04\x02\x12\x06\xc8\x01\0\xcf\x01\
    \x01\x1a\xbb\x13\x20Declares\x20an\x20API\x20Interface\x20to\x20be\x20in\
    cluded\x20in\x20this\x20interface.\x20The\x20including\n\x20interface\
    \x20must\x20redeclare\x20all\x20the\x20methods\x20from\x20the\x20include\
    d\x20interface,\x20but\n\x20documentation\x20and\x20options\x20are\x20in\
    herited\x20as\x20follows:\n\n\x20-\x20If\x20after\x20comment\x20and\x20w\
    hitespace\x20stripping,\x20the\x20documentation\n\x20\x20\x20string\x20o\
    f\x20the\x20redeclared\x20method\x20is\x20empty,\x20it\x20will\x20be\x20\
    inherited\n\x20\x20\x20from\x20the\x20original\x20method.\n\n\x20-\x20Ea\
    ch\x20annotation\x20belonging\x20to\x20the\x20service\x20config\x20(http\
    ,\n\x20\x20\x20visibility)\x20which\x20is\x20not\x20set\x20in\x20the\x20\
    redeclared\x20method\x20will\x20be\n\x20\x20\x20inherited.\n\n\x20-\x20I\
    f\x20an\x20http\x20annotation\x20is\x20inherited,\x20the\x20path\x20patt\
    ern\x20will\x20be\n\x20\x20\x20modified\x20as\x20follows.\x20Any\x20vers\
    ion\x20prefix\x20will\x20be\x20replaced\x20by\x20the\n\x20\x20\x20versio\
    n\x20of\x20the\x20including\x20interface\x20plus\x20the\x20[root][]\x20p\
    ath\x20if\n\x20\x20\x20specified.\n\n\x20Example\x20of\x20a\x20simple\
    \x20mixin:\n\n\x20\x20\x20\x20\x20package\x20google.acl.v1;\n\x20\x20\
    \x20\x20\x20service\x20AccessControl\x20{\n\x20\x20\x20\x20\x20\x20\x20/\
    /\x20Get\x20the\x20underlying\x20ACL\x20object.\n\x20\x20\x20\x20\x20\
    \x20\x20rpc\x20GetAcl(GetAclRequest)\x20returns\x20(Acl)\x20{\n\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20option\x20(google.api.http).get\x20=\x20\"/v\
    1/{resource=**}:getAcl\";\n\x20\x20\x20\x20\x20\x20\x20}\n\x20\x20\x20\
    \x20\x20}\n\n\x20\x20\x20\x20\x20package\x20google.storage.v2;\n\x20\x20\
    \x20\x20\x20service\x20Storage\x20{\n\x20\x20\x20\x20\x20\x20\x20rpc\x20\
    GetAcl(GetAclRequest)\x20returns\x20(Acl);\n\n\x20\x20\x20\x20\x20\x20\
    \x20//\x20Get\x20a\x20data\x20record.\n\x20\x20\x20\x20\x20\x20\x20rpc\
    \x20GetData(GetDataRequest)\x20returns\x20(Data)\x20{\n\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20option\x20(google.api.http).get\x20=\x20\"/v2/{resou\
    rce=**}\";\n\x20\x20\x20\x20\x20\x20\x20}\n\x20\x20\x20\x20\x20}\n\n\x20\
    Example\x20of\x20a\x20mixin\x20configuration:\n\n\x20\x20\x20\x20\x20api\
    s:\n\x20\x20\x20\x20\x20-\x20name:\x20google.storage.v2.Storage\n\x20\
    \x20\x20\x20\x20\x20\x20mixins:\n\x20\x20\x20\x20\x20\x20\x20-\x20name:\
    \x20google.acl.v1.AccessControl\n\n\x20The\x20mixin\x20construct\x20impl\
    ies\x20that\x20all\x20methods\x20in\x20`AccessControl`\x20are\n\x20also\
    \x20declared\x20with\x20same\x20name\x20and\x20request/response\x20types\
    \x20in\n\x20`Storage`.\x20A\x20documentation\x20generator\x20or\x20annot\
    ation\x20processor\x20will\n\x20see\x20the\x20effective\x20`Storage.GetA\
    cl`\x20method\x20after\x20inheriting\n\x20documentation\x20and\x20annota\
    tions\x20as\x20follows:\n\n\x20\x20\x20\x20\x20service\x20Storage\x20{\n\
    \x20\x20\x20\x20\x20\x20\x20//\x20Get\x20the\x20underlying\x20ACL\x20obj\
    ect.\n\x20\x20\x20\x20\x20\x20\x20rpc\x20GetAcl(GetAclRequest)\x20return\
    s\x20(Acl)\x20{\n\x20\x20\x20\x20\x20\x20\x20\x20\x20option\x20(google.a\
    pi.http).get\x20=\x20\"/v2/{resource=**}:getAcl\";\n\x20\x20\x20\x20\x20\
    \x20\x20}\n\x20\x20\x20\x20\x20\x20\x20...\n\x20\x20\x20\x20\x20}\n\n\
    \x20Note\x20how\x20the\x20version\x20in\x20the\x20path\x20pattern\x20cha\
    nged\x20from\x20`v1`\x20to\x20`v2`.\n\n\x20If\x20the\x20`root`\x20field\
    \x20in\x20the\x20mixin\x20is\x20specified,\x20it\x20should\x20be\x20a\n\
    \x20relative\x20path\x20under\x20which\x20inherited\x20HTTP\x20paths\x20\
    are\x20placed.\x20Example:\n\n\x20\x20\x20\x20\x20apis:\n\x20\x20\x20\
    \x20\x20-\x20name:\x20google.storage.v2.Storage\n\x20\x20\x20\x20\x20\
    \x20\x20mixins:\n\x20\x20\x20\x20\x20\x20\x20-\x20name:\x20google.acl.v1\
    .AccessControl\n\x20\x20\x20\x20\x20\x20\x20\x20\x20root:\x20acls\n\n\
    \x20This\x20implies\x20the\x20following\x20inherited\x20HTTP\x20annotati\
    on:\n\n\x20\x20\x20\x20\x20service\x20Storage\x20{\n\x20\x20\x20\x20\x20\
    \x20\x20//\x20Get\x20the\x20underlying\x20ACL\x20object.\n\x20\x20\x20\
    \x20\x20\x20\x20rpc\x20GetAcl(GetAclRequest)\x20returns\x20(Acl)\x20{\n\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20option\x20(google.api.http).get\x20=\
    \x20\"/v2/acls/{resource=**}:getAcl\";\n\x20\x20\x20\x20\x20\x20\x20}\n\
    \x20\x20\x20\x20\x20\x20\x20...\n\x20\x20\x20\x20\x20}\n\n\x0b\n\x03\x04\
    \x02\x01\x12\x04\xc8\x01\x08\r\nL\n\x04\x04\x02\x02\0\x12\x04\xca\x01\
    \x02\x12\x1a>\x20The\x20fully\x20qualified\x20name\x20of\x20the\x20inter\
    face\x20which\x20is\x20included.\n\n\r\n\x05\x04\x02\x02\0\x05\x12\x04\
    \xca\x01\x02\x08\n\r\n\x05\x04\x02\x02\0\x01\x12\x04\xca\x01\t\r\n\r\n\
    \x05\x04\x02\x02\0\x03\x12\x04\xca\x01\x10\x11\n[\n\x04\x04\x02\x02\x01\
    \x12\x04\xce\x01\x02\x12\x1aM\x20If\x20non-empty\x20specifies\x20a\x20pa\
    th\x20under\x20which\x20inherited\x20HTTP\x20paths\n\x20are\x20rooted.\n\
    \n\r\n\x05\x04\x02\x02\x01\x05\x12\x04\xce\x01\x02\x08\n\r\n\x05\x04\x02\
    \x02\x01\x01\x12\x04\xce\x01\t\r\n\r\n\x05\x04\x02\x02\x01\x03\x12\x04\
    \xce\x01\x10\x11b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static crate::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: crate::rt::Lazy<crate::descriptor::FileDescriptorProto> = crate::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        crate::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static crate::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: crate::rt::Lazy<crate::reflect::GeneratedFileDescriptor> = crate::rt::Lazy::new();
    static file_descriptor: crate::rt::Lazy<crate::reflect::FileDescriptor> = crate::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(2);
            deps.push(crate::well_known_types::source_context::file_descriptor().clone());
            deps.push(crate::well_known_types::type_::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(3);
            messages.push(Api::generated_message_descriptor_data());
            messages.push(Method::generated_message_descriptor_data());
            messages.push(Mixin::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            crate::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        crate::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}

'''
'''--- protobuf/src/well_known_types/duration.rs ---
// This file is generated by rust-protobuf 4.0.0-alpha.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `google/protobuf/duration.proto`

// @@protoc_insertion_point(message:google.protobuf.Duration)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Duration {
    // message fields
    ///  Signed seconds of the span of time. Must be from -315,576,000,000
    ///  to +315,576,000,000 inclusive. Note: these bounds are computed from:
    ///  60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
    // @@protoc_insertion_point(field:google.protobuf.Duration.seconds)
    pub seconds: i64,
    ///  Signed fractions of a second at nanosecond resolution of the span
    ///  of time. Durations less than one second are represented with a 0
    ///  `seconds` field and a positive or negative `nanos` field. For durations
    ///  of one second or more, a non-zero value for the `nanos` field must be
    ///  of the same sign as the `seconds` field. Must be from -999,999,999
    ///  to +999,999,999 inclusive.
    // @@protoc_insertion_point(field:google.protobuf.Duration.nanos)
    pub nanos: i32,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.Duration.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Duration {
    fn default() -> &'a Duration {
        <Duration as crate::Message>::default_instance()
    }
}

impl Duration {
    pub fn new() -> Duration {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "seconds",
            |m: &Duration| { &m.seconds },
            |m: &mut Duration| { &mut m.seconds },
        ));
        fields.push(crate::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "nanos",
            |m: &Duration| { &m.nanos },
            |m: &mut Duration| { &mut m.nanos },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<Duration>(
            "Duration",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for Duration {
    const NAME: &'static str = "Duration";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.seconds = is.read_int64()?;
                },
                16 => {
                    self.nanos = is.read_int32()?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.seconds != 0 {
            my_size += crate::rt::int64_size(1, self.seconds);
        }
        if self.nanos != 0 {
            my_size += crate::rt::int32_size(2, self.nanos);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if self.seconds != 0 {
            os.write_int64(1, self.seconds)?;
        }
        if self.nanos != 0 {
            os.write_int32(2, self.nanos)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Duration {
        Duration::new()
    }

    fn clear(&mut self) {
        self.seconds = 0;
        self.nanos = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Duration {
        static instance: Duration = Duration {
            seconds: 0,
            nanos: 0,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for Duration {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Duration").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Duration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for Duration {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1egoogle/protobuf/duration.proto\x12\x0fgoogle.protobuf\":\n\x08Dura\
    tion\x12\x18\n\x07seconds\x18\x01\x20\x01(\x03R\x07seconds\x12\x14\n\x05\
    nanos\x18\x02\x20\x01(\x05R\x05nanosB\x83\x01\n\x13com.google.protobufB\
    \rDurationProtoP\x01Z1google.golang.org/protobuf/types/known/durationpb\
    \xf8\x01\x01\xa2\x02\x03GPB\xaa\x02\x1eGoogle.Protobuf.WellKnownTypesJ\
    \xda#\n\x06\x12\x04\x1e\0s\x01\n\xcc\x0c\n\x01\x0c\x12\x03\x1e\0\x122\
    \xc1\x0c\x20Protocol\x20Buffers\x20-\x20Google's\x20data\x20interchange\
    \x20format\n\x20Copyright\x202008\x20Google\x20Inc.\x20\x20All\x20rights\
    \x20reserved.\n\x20https://developers.google.com/protocol-buffers/\n\n\
    \x20Redistribution\x20and\x20use\x20in\x20source\x20and\x20binary\x20for\
    ms,\x20with\x20or\x20without\n\x20modification,\x20are\x20permitted\x20p\
    rovided\x20that\x20the\x20following\x20conditions\x20are\n\x20met:\n\n\
    \x20\x20\x20\x20\x20*\x20Redistributions\x20of\x20source\x20code\x20must\
    \x20retain\x20the\x20above\x20copyright\n\x20notice,\x20this\x20list\x20\
    of\x20conditions\x20and\x20the\x20following\x20disclaimer.\n\x20\x20\x20\
    \x20\x20*\x20Redistributions\x20in\x20binary\x20form\x20must\x20reproduc\
    e\x20the\x20above\n\x20copyright\x20notice,\x20this\x20list\x20of\x20con\
    ditions\x20and\x20the\x20following\x20disclaimer\n\x20in\x20the\x20docum\
    entation\x20and/or\x20other\x20materials\x20provided\x20with\x20the\n\
    \x20distribution.\n\x20\x20\x20\x20\x20*\x20Neither\x20the\x20name\x20of\
    \x20Google\x20Inc.\x20nor\x20the\x20names\x20of\x20its\n\x20contributors\
    \x20may\x20be\x20used\x20to\x20endorse\x20or\x20promote\x20products\x20d\
    erived\x20from\n\x20this\x20software\x20without\x20specific\x20prior\x20\
    written\x20permission.\n\n\x20THIS\x20SOFTWARE\x20IS\x20PROVIDED\x20BY\
    \x20THE\x20COPYRIGHT\x20HOLDERS\x20AND\x20CONTRIBUTORS\n\x20\"AS\x20IS\"\
    \x20AND\x20ANY\x20EXPRESS\x20OR\x20IMPLIED\x20WARRANTIES,\x20INCLUDING,\
    \x20BUT\x20NOT\n\x20LIMITED\x20TO,\x20THE\x20IMPLIED\x20WARRANTIES\x20OF\
    \x20MERCHANTABILITY\x20AND\x20FITNESS\x20FOR\n\x20A\x20PARTICULAR\x20PUR\
    POSE\x20ARE\x20DISCLAIMED.\x20IN\x20NO\x20EVENT\x20SHALL\x20THE\x20COPYR\
    IGHT\n\x20OWNER\x20OR\x20CONTRIBUTORS\x20BE\x20LIABLE\x20FOR\x20ANY\x20D\
    IRECT,\x20INDIRECT,\x20INCIDENTAL,\n\x20SPECIAL,\x20EXEMPLARY,\x20OR\x20\
    CONSEQUENTIAL\x20DAMAGES\x20(INCLUDING,\x20BUT\x20NOT\n\x20LIMITED\x20TO\
    ,\x20PROCUREMENT\x20OF\x20SUBSTITUTE\x20GOODS\x20OR\x20SERVICES;\x20LOSS\
    \x20OF\x20USE,\n\x20DATA,\x20OR\x20PROFITS;\x20OR\x20BUSINESS\x20INTERRU\
    PTION)\x20HOWEVER\x20CAUSED\x20AND\x20ON\x20ANY\n\x20THEORY\x20OF\x20LIA\
    BILITY,\x20WHETHER\x20IN\x20CONTRACT,\x20STRICT\x20LIABILITY,\x20OR\x20T\
    ORT\n\x20(INCLUDING\x20NEGLIGENCE\x20OR\x20OTHERWISE)\x20ARISING\x20IN\
    \x20ANY\x20WAY\x20OUT\x20OF\x20THE\x20USE\n\x20OF\x20THIS\x20SOFTWARE,\
    \x20EVEN\x20IF\x20ADVISED\x20OF\x20THE\x20POSSIBILITY\x20OF\x20SUCH\x20D\
    AMAGE.\n\n\x08\n\x01\x02\x12\x03\x20\0\x18\n\x08\n\x01\x08\x12\x03\"\0;\
    \n\t\n\x02\x08%\x12\x03\"\0;\n\x08\n\x01\x08\x12\x03#\0\x1f\n\t\n\x02\
    \x08\x1f\x12\x03#\0\x1f\n\x08\n\x01\x08\x12\x03$\0H\n\t\n\x02\x08\x0b\
    \x12\x03$\0H\n\x08\n\x01\x08\x12\x03%\0,\n\t\n\x02\x08\x01\x12\x03%\0,\n\
    \x08\n\x01\x08\x12\x03&\0.\n\t\n\x02\x08\x08\x12\x03&\0.\n\x08\n\x01\x08\
    \x12\x03'\0\"\n\t\n\x02\x08\n\x12\x03'\0\"\n\x08\n\x01\x08\x12\x03(\0!\n\
    \t\n\x02\x08$\x12\x03(\0!\n\x9e\x10\n\x02\x04\0\x12\x04f\0s\x01\x1a\x91\
    \x10\x20A\x20Duration\x20represents\x20a\x20signed,\x20fixed-length\x20s\
    pan\x20of\x20time\x20represented\n\x20as\x20a\x20count\x20of\x20seconds\
    \x20and\x20fractions\x20of\x20seconds\x20at\x20nanosecond\n\x20resolutio\
    n.\x20It\x20is\x20independent\x20of\x20any\x20calendar\x20and\x20concept\
    s\x20like\x20\"day\"\n\x20or\x20\"month\".\x20It\x20is\x20related\x20to\
    \x20Timestamp\x20in\x20that\x20the\x20difference\x20between\n\x20two\x20\
    Timestamp\x20values\x20is\x20a\x20Duration\x20and\x20it\x20can\x20be\x20\
    added\x20or\x20subtracted\n\x20from\x20a\x20Timestamp.\x20Range\x20is\
    \x20approximately\x20+-10,000\x20years.\n\n\x20#\x20Examples\n\n\x20Exam\
    ple\x201:\x20Compute\x20Duration\x20from\x20two\x20Timestamps\x20in\x20p\
    seudo\x20code.\n\n\x20\x20\x20\x20\x20Timestamp\x20start\x20=\x20...;\n\
    \x20\x20\x20\x20\x20Timestamp\x20end\x20=\x20...;\n\x20\x20\x20\x20\x20D\
    uration\x20duration\x20=\x20...;\n\n\x20\x20\x20\x20\x20duration.seconds\
    \x20=\x20end.seconds\x20-\x20start.seconds;\n\x20\x20\x20\x20\x20duratio\
    n.nanos\x20=\x20end.nanos\x20-\x20start.nanos;\n\n\x20\x20\x20\x20\x20if\
    \x20(duration.seconds\x20<\x200\x20&&\x20duration.nanos\x20>\x200)\x20{\
    \n\x20\x20\x20\x20\x20\x20\x20duration.seconds\x20+=\x201;\n\x20\x20\x20\
    \x20\x20\x20\x20duration.nanos\x20-=\x201000000000;\n\x20\x20\x20\x20\
    \x20}\x20else\x20if\x20(duration.seconds\x20>\x200\x20&&\x20duration.nan\
    os\x20<\x200)\x20{\n\x20\x20\x20\x20\x20\x20\x20duration.seconds\x20-=\
    \x201;\n\x20\x20\x20\x20\x20\x20\x20duration.nanos\x20+=\x201000000000;\
    \n\x20\x20\x20\x20\x20}\n\n\x20Example\x202:\x20Compute\x20Timestamp\x20\
    from\x20Timestamp\x20+\x20Duration\x20in\x20pseudo\x20code.\n\n\x20\x20\
    \x20\x20\x20Timestamp\x20start\x20=\x20...;\n\x20\x20\x20\x20\x20Duratio\
    n\x20duration\x20=\x20...;\n\x20\x20\x20\x20\x20Timestamp\x20end\x20=\
    \x20...;\n\n\x20\x20\x20\x20\x20end.seconds\x20=\x20start.seconds\x20+\
    \x20duration.seconds;\n\x20\x20\x20\x20\x20end.nanos\x20=\x20start.nanos\
    \x20+\x20duration.nanos;\n\n\x20\x20\x20\x20\x20if\x20(end.nanos\x20<\
    \x200)\x20{\n\x20\x20\x20\x20\x20\x20\x20end.seconds\x20-=\x201;\n\x20\
    \x20\x20\x20\x20\x20\x20end.nanos\x20+=\x201000000000;\n\x20\x20\x20\x20\
    \x20}\x20else\x20if\x20(end.nanos\x20>=\x201000000000)\x20{\n\x20\x20\
    \x20\x20\x20\x20\x20end.seconds\x20+=\x201;\n\x20\x20\x20\x20\x20\x20\
    \x20end.nanos\x20-=\x201000000000;\n\x20\x20\x20\x20\x20}\n\n\x20Example\
    \x203:\x20Compute\x20Duration\x20from\x20datetime.timedelta\x20in\x20Pyt\
    hon.\n\n\x20\x20\x20\x20\x20td\x20=\x20datetime.timedelta(days=3,\x20min\
    utes=10)\n\x20\x20\x20\x20\x20duration\x20=\x20Duration()\n\x20\x20\x20\
    \x20\x20duration.FromTimedelta(td)\n\n\x20#\x20JSON\x20Mapping\n\n\x20In\
    \x20JSON\x20format,\x20the\x20Duration\x20type\x20is\x20encoded\x20as\
    \x20a\x20string\x20rather\x20than\x20an\n\x20object,\x20where\x20the\x20\
    string\x20ends\x20in\x20the\x20suffix\x20\"s\"\x20(indicating\x20seconds\
    )\x20and\n\x20is\x20preceded\x20by\x20the\x20number\x20of\x20seconds,\
    \x20with\x20nanoseconds\x20expressed\x20as\n\x20fractional\x20seconds.\
    \x20For\x20example,\x203\x20seconds\x20with\x200\x20nanoseconds\x20shoul\
    d\x20be\n\x20encoded\x20in\x20JSON\x20format\x20as\x20\"3s\",\x20while\
    \x203\x20seconds\x20and\x201\x20nanosecond\x20should\n\x20be\x20expresse\
    d\x20in\x20JSON\x20format\x20as\x20\"3.000000001s\",\x20and\x203\x20seco\
    nds\x20and\x201\n\x20microsecond\x20should\x20be\x20expressed\x20in\x20J\
    SON\x20format\x20as\x20\"3.000001s\".\n\n\n\n\n\n\x03\x04\0\x01\x12\x03f\
    \x08\x10\n\xdc\x01\n\x04\x04\0\x02\0\x12\x03j\x02\x14\x1a\xce\x01\x20Sig\
    ned\x20seconds\x20of\x20the\x20span\x20of\x20time.\x20Must\x20be\x20from\
    \x20-315,576,000,000\n\x20to\x20+315,576,000,000\x20inclusive.\x20Note:\
    \x20these\x20bounds\x20are\x20computed\x20from:\n\x2060\x20sec/min\x20*\
    \x2060\x20min/hr\x20*\x2024\x20hr/day\x20*\x20365.25\x20days/year\x20*\
    \x2010000\x20years\n\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03j\x02\x07\n\x0c\
    \n\x05\x04\0\x02\0\x01\x12\x03j\x08\x0f\n\x0c\n\x05\x04\0\x02\0\x03\x12\
    \x03j\x12\x13\n\x83\x03\n\x04\x04\0\x02\x01\x12\x03r\x02\x12\x1a\xf5\x02\
    \x20Signed\x20fractions\x20of\x20a\x20second\x20at\x20nanosecond\x20reso\
    lution\x20of\x20the\x20span\n\x20of\x20time.\x20Durations\x20less\x20tha\
    n\x20one\x20second\x20are\x20represented\x20with\x20a\x200\n\x20`seconds\
    `\x20field\x20and\x20a\x20positive\x20or\x20negative\x20`nanos`\x20field\
    .\x20For\x20durations\n\x20of\x20one\x20second\x20or\x20more,\x20a\x20no\
    n-zero\x20value\x20for\x20the\x20`nanos`\x20field\x20must\x20be\n\x20of\
    \x20the\x20same\x20sign\x20as\x20the\x20`seconds`\x20field.\x20Must\x20b\
    e\x20from\x20-999,999,999\n\x20to\x20+999,999,999\x20inclusive.\n\n\x0c\
    \n\x05\x04\0\x02\x01\x05\x12\x03r\x02\x07\n\x0c\n\x05\x04\0\x02\x01\x01\
    \x12\x03r\x08\r\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03r\x10\x11b\x06proto\
    3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static crate::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: crate::rt::Lazy<crate::descriptor::FileDescriptorProto> = crate::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        crate::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static crate::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: crate::rt::Lazy<crate::reflect::GeneratedFileDescriptor> = crate::rt::Lazy::new();
    static file_descriptor: crate::rt::Lazy<crate::reflect::FileDescriptor> = crate::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(1);
            messages.push(Duration::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            crate::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        crate::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}

'''
'''--- protobuf/src/well_known_types/empty.rs ---
// This file is generated by rust-protobuf 4.0.0-alpha.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `google/protobuf/empty.proto`

// @@protoc_insertion_point(message:google.protobuf.Empty)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Empty {
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.Empty.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Empty {
    fn default() -> &'a Empty {
        <Empty as crate::Message>::default_instance()
    }
}

impl Empty {
    pub fn new() -> Empty {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<Empty>(
            "Empty",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for Empty {
    const NAME: &'static str = "Empty";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Empty {
        Empty::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Empty {
        static instance: Empty = Empty {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for Empty {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Empty").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Empty {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for Empty {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1bgoogle/protobuf/empty.proto\x12\x0fgoogle.protobuf\"\x07\n\x05Empt\
    yB}\n\x13com.google.protobufB\nEmptyProtoP\x01Z.google.golang.org/protob\
    uf/types/known/emptypb\xf8\x01\x01\xa2\x02\x03GPB\xaa\x02\x1eGoogle.Prot\
    obuf.WellKnownTypesJ\xfe\x10\n\x06\x12\x04\x1e\03\x10\n\xcc\x0c\n\x01\
    \x0c\x12\x03\x1e\0\x122\xc1\x0c\x20Protocol\x20Buffers\x20-\x20Google's\
    \x20data\x20interchange\x20format\n\x20Copyright\x202008\x20Google\x20In\
    c.\x20\x20All\x20rights\x20reserved.\n\x20https://developers.google.com/\
    protocol-buffers/\n\n\x20Redistribution\x20and\x20use\x20in\x20source\
    \x20and\x20binary\x20forms,\x20with\x20or\x20without\n\x20modification,\
    \x20are\x20permitted\x20provided\x20that\x20the\x20following\x20conditio\
    ns\x20are\n\x20met:\n\n\x20\x20\x20\x20\x20*\x20Redistributions\x20of\
    \x20source\x20code\x20must\x20retain\x20the\x20above\x20copyright\n\x20n\
    otice,\x20this\x20list\x20of\x20conditions\x20and\x20the\x20following\
    \x20disclaimer.\n\x20\x20\x20\x20\x20*\x20Redistributions\x20in\x20binar\
    y\x20form\x20must\x20reproduce\x20the\x20above\n\x20copyright\x20notice,\
    \x20this\x20list\x20of\x20conditions\x20and\x20the\x20following\x20discl\
    aimer\n\x20in\x20the\x20documentation\x20and/or\x20other\x20materials\
    \x20provided\x20with\x20the\n\x20distribution.\n\x20\x20\x20\x20\x20*\
    \x20Neither\x20the\x20name\x20of\x20Google\x20Inc.\x20nor\x20the\x20name\
    s\x20of\x20its\n\x20contributors\x20may\x20be\x20used\x20to\x20endorse\
    \x20or\x20promote\x20products\x20derived\x20from\n\x20this\x20software\
    \x20without\x20specific\x20prior\x20written\x20permission.\n\n\x20THIS\
    \x20SOFTWARE\x20IS\x20PROVIDED\x20BY\x20THE\x20COPYRIGHT\x20HOLDERS\x20A\
    ND\x20CONTRIBUTORS\n\x20\"AS\x20IS\"\x20AND\x20ANY\x20EXPRESS\x20OR\x20I\
    MPLIED\x20WARRANTIES,\x20INCLUDING,\x20BUT\x20NOT\n\x20LIMITED\x20TO,\
    \x20THE\x20IMPLIED\x20WARRANTIES\x20OF\x20MERCHANTABILITY\x20AND\x20FITN\
    ESS\x20FOR\n\x20A\x20PARTICULAR\x20PURPOSE\x20ARE\x20DISCLAIMED.\x20IN\
    \x20NO\x20EVENT\x20SHALL\x20THE\x20COPYRIGHT\n\x20OWNER\x20OR\x20CONTRIB\
    UTORS\x20BE\x20LIABLE\x20FOR\x20ANY\x20DIRECT,\x20INDIRECT,\x20INCIDENTA\
    L,\n\x20SPECIAL,\x20EXEMPLARY,\x20OR\x20CONSEQUENTIAL\x20DAMAGES\x20(INC\
    LUDING,\x20BUT\x20NOT\n\x20LIMITED\x20TO,\x20PROCUREMENT\x20OF\x20SUBSTI\
    TUTE\x20GOODS\x20OR\x20SERVICES;\x20LOSS\x20OF\x20USE,\n\x20DATA,\x20OR\
    \x20PROFITS;\x20OR\x20BUSINESS\x20INTERRUPTION)\x20HOWEVER\x20CAUSED\x20\
    AND\x20ON\x20ANY\n\x20THEORY\x20OF\x20LIABILITY,\x20WHETHER\x20IN\x20CON\
    TRACT,\x20STRICT\x20LIABILITY,\x20OR\x20TORT\n\x20(INCLUDING\x20NEGLIGEN\
    CE\x20OR\x20OTHERWISE)\x20ARISING\x20IN\x20ANY\x20WAY\x20OUT\x20OF\x20TH\
    E\x20USE\n\x20OF\x20THIS\x20SOFTWARE,\x20EVEN\x20IF\x20ADVISED\x20OF\x20\
    THE\x20POSSIBILITY\x20OF\x20SUCH\x20DAMAGE.\n\n\x08\n\x01\x02\x12\x03\
    \x20\0\x18\n\x08\n\x01\x08\x12\x03\"\0;\n\t\n\x02\x08%\x12\x03\"\0;\n\
    \x08\n\x01\x08\x12\x03#\0E\n\t\n\x02\x08\x0b\x12\x03#\0E\n\x08\n\x01\x08\
    \x12\x03$\0,\n\t\n\x02\x08\x01\x12\x03$\0,\n\x08\n\x01\x08\x12\x03%\0+\n\
    \t\n\x02\x08\x08\x12\x03%\0+\n\x08\n\x01\x08\x12\x03&\0\"\n\t\n\x02\x08\
    \n\x12\x03&\0\"\n\x08\n\x01\x08\x12\x03'\0!\n\t\n\x02\x08$\x12\x03'\0!\n\
    \x08\n\x01\x08\x12\x03(\0\x1f\n\t\n\x02\x08\x1f\x12\x03(\0\x1f\n\xfb\x02\
    \n\x02\x04\0\x12\x033\0\x10\x1a\xef\x02\x20A\x20generic\x20empty\x20mess\
    age\x20that\x20you\x20can\x20re-use\x20to\x20avoid\x20defining\x20duplic\
    ated\n\x20empty\x20messages\x20in\x20your\x20APIs.\x20A\x20typical\x20ex\
    ample\x20is\x20to\x20use\x20it\x20as\x20the\x20request\n\x20or\x20the\
    \x20response\x20type\x20of\x20an\x20API\x20method.\x20For\x20instance:\n\
    \n\x20\x20\x20\x20\x20service\x20Foo\x20{\n\x20\x20\x20\x20\x20\x20\x20r\
    pc\x20Bar(google.protobuf.Empty)\x20returns\x20(google.protobuf.Empty);\
    \n\x20\x20\x20\x20\x20}\n\n\x20The\x20JSON\x20representation\x20for\x20`\
    Empty`\x20is\x20empty\x20JSON\x20object\x20`{}`.\n\n\n\n\x03\x04\0\x01\
    \x12\x033\x08\rb\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static crate::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: crate::rt::Lazy<crate::descriptor::FileDescriptorProto> = crate::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        crate::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static crate::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: crate::rt::Lazy<crate::reflect::GeneratedFileDescriptor> = crate::rt::Lazy::new();
    static file_descriptor: crate::rt::Lazy<crate::reflect::FileDescriptor> = crate::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(1);
            messages.push(Empty::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            crate::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        crate::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}

'''
'''--- protobuf/src/well_known_types/field_mask.rs ---
// This file is generated by rust-protobuf 4.0.0-alpha.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `google/protobuf/field_mask.proto`

// @@protoc_insertion_point(message:google.protobuf.FieldMask)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FieldMask {
    // message fields
    ///  The set of field mask paths.
    // @@protoc_insertion_point(field:google.protobuf.FieldMask.paths)
    pub paths: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.FieldMask.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FieldMask {
    fn default() -> &'a FieldMask {
        <FieldMask as crate::Message>::default_instance()
    }
}

impl FieldMask {
    pub fn new() -> FieldMask {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "paths",
            |m: &FieldMask| { &m.paths },
            |m: &mut FieldMask| { &mut m.paths },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<FieldMask>(
            "FieldMask",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for FieldMask {
    const NAME: &'static str = "FieldMask";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.paths.push(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.paths {
            my_size += crate::rt::string_size(1, &value);
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.paths {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FieldMask {
        FieldMask::new()
    }

    fn clear(&mut self) {
        self.paths.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FieldMask {
        static instance: FieldMask = FieldMask {
            paths: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for FieldMask {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FieldMask").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FieldMask {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for FieldMask {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x20google/protobuf/field_mask.proto\x12\x0fgoogle.protobuf\"!\n\tFiel\
    dMask\x12\x14\n\x05paths\x18\x01\x20\x03(\tR\x05pathsB\x85\x01\n\x13com.\
    google.protobufB\x0eFieldMaskProtoP\x01Z2google.golang.org/protobuf/type\
    s/known/fieldmaskpb\xf8\x01\x01\xa2\x02\x03GPB\xaa\x02\x1eGoogle.Protobu\
    f.WellKnownTypesJ\xa1;\n\x07\x12\x05\x1e\0\xf4\x01\x01\n\xcc\x0c\n\x01\
    \x0c\x12\x03\x1e\0\x122\xc1\x0c\x20Protocol\x20Buffers\x20-\x20Google's\
    \x20data\x20interchange\x20format\n\x20Copyright\x202008\x20Google\x20In\
    c.\x20\x20All\x20rights\x20reserved.\n\x20https://developers.google.com/\
    protocol-buffers/\n\n\x20Redistribution\x20and\x20use\x20in\x20source\
    \x20and\x20binary\x20forms,\x20with\x20or\x20without\n\x20modification,\
    \x20are\x20permitted\x20provided\x20that\x20the\x20following\x20conditio\
    ns\x20are\n\x20met:\n\n\x20\x20\x20\x20\x20*\x20Redistributions\x20of\
    \x20source\x20code\x20must\x20retain\x20the\x20above\x20copyright\n\x20n\
    otice,\x20this\x20list\x20of\x20conditions\x20and\x20the\x20following\
    \x20disclaimer.\n\x20\x20\x20\x20\x20*\x20Redistributions\x20in\x20binar\
    y\x20form\x20must\x20reproduce\x20the\x20above\n\x20copyright\x20notice,\
    \x20this\x20list\x20of\x20conditions\x20and\x20the\x20following\x20discl\
    aimer\n\x20in\x20the\x20documentation\x20and/or\x20other\x20materials\
    \x20provided\x20with\x20the\n\x20distribution.\n\x20\x20\x20\x20\x20*\
    \x20Neither\x20the\x20name\x20of\x20Google\x20Inc.\x20nor\x20the\x20name\
    s\x20of\x20its\n\x20contributors\x20may\x20be\x20used\x20to\x20endorse\
    \x20or\x20promote\x20products\x20derived\x20from\n\x20this\x20software\
    \x20without\x20specific\x20prior\x20written\x20permission.\n\n\x20THIS\
    \x20SOFTWARE\x20IS\x20PROVIDED\x20BY\x20THE\x20COPYRIGHT\x20HOLDERS\x20A\
    ND\x20CONTRIBUTORS\n\x20\"AS\x20IS\"\x20AND\x20ANY\x20EXPRESS\x20OR\x20I\
    MPLIED\x20WARRANTIES,\x20INCLUDING,\x20BUT\x20NOT\n\x20LIMITED\x20TO,\
    \x20THE\x20IMPLIED\x20WARRANTIES\x20OF\x20MERCHANTABILITY\x20AND\x20FITN\
    ESS\x20FOR\n\x20A\x20PARTICULAR\x20PURPOSE\x20ARE\x20DISCLAIMED.\x20IN\
    \x20NO\x20EVENT\x20SHALL\x20THE\x20COPYRIGHT\n\x20OWNER\x20OR\x20CONTRIB\
    UTORS\x20BE\x20LIABLE\x20FOR\x20ANY\x20DIRECT,\x20INDIRECT,\x20INCIDENTA\
    L,\n\x20SPECIAL,\x20EXEMPLARY,\x20OR\x20CONSEQUENTIAL\x20DAMAGES\x20(INC\
    LUDING,\x20BUT\x20NOT\n\x20LIMITED\x20TO,\x20PROCUREMENT\x20OF\x20SUBSTI\
    TUTE\x20GOODS\x20OR\x20SERVICES;\x20LOSS\x20OF\x20USE,\n\x20DATA,\x20OR\
    \x20PROFITS;\x20OR\x20BUSINESS\x20INTERRUPTION)\x20HOWEVER\x20CAUSED\x20\
    AND\x20ON\x20ANY\n\x20THEORY\x20OF\x20LIABILITY,\x20WHETHER\x20IN\x20CON\
    TRACT,\x20STRICT\x20LIABILITY,\x20OR\x20TORT\n\x20(INCLUDING\x20NEGLIGEN\
    CE\x20OR\x20OTHERWISE)\x20ARISING\x20IN\x20ANY\x20WAY\x20OUT\x20OF\x20TH\
    E\x20USE\n\x20OF\x20THIS\x20SOFTWARE,\x20EVEN\x20IF\x20ADVISED\x20OF\x20\
    THE\x20POSSIBILITY\x20OF\x20SUCH\x20DAMAGE.\n\n\x08\n\x01\x02\x12\x03\
    \x20\0\x18\n\x08\n\x01\x08\x12\x03\"\0;\n\t\n\x02\x08%\x12\x03\"\0;\n\
    \x08\n\x01\x08\x12\x03#\0,\n\t\n\x02\x08\x01\x12\x03#\0,\n\x08\n\x01\x08\
    \x12\x03$\0/\n\t\n\x02\x08\x08\x12\x03$\0/\n\x08\n\x01\x08\x12\x03%\0\"\
    \n\t\n\x02\x08\n\x12\x03%\0\"\n\x08\n\x01\x08\x12\x03&\0!\n\t\n\x02\x08$\
    \x12\x03&\0!\n\x08\n\x01\x08\x12\x03'\0I\n\t\n\x02\x08\x0b\x12\x03'\0I\n\
    \x08\n\x01\x08\x12\x03(\0\x1f\n\t\n\x02\x08\x1f\x12\x03(\0\x1f\n\xb2,\n\
    \x02\x04\0\x12\x06\xf1\x01\0\xf4\x01\x01\x1a\xa3,\x20`FieldMask`\x20repr\
    esents\x20a\x20set\x20of\x20symbolic\x20field\x20paths,\x20for\x20exampl\
    e:\n\n\x20\x20\x20\x20\x20paths:\x20\"f.a\"\n\x20\x20\x20\x20\x20paths:\
    \x20\"f.b.d\"\n\n\x20Here\x20`f`\x20represents\x20a\x20field\x20in\x20so\
    me\x20root\x20message,\x20`a`\x20and\x20`b`\n\x20fields\x20in\x20the\x20\
    message\x20found\x20in\x20`f`,\x20and\x20`d`\x20a\x20field\x20found\x20i\
    n\x20the\n\x20message\x20in\x20`f.b`.\n\n\x20Field\x20masks\x20are\x20us\
    ed\x20to\x20specify\x20a\x20subset\x20of\x20fields\x20that\x20should\x20\
    be\n\x20returned\x20by\x20a\x20get\x20operation\x20or\x20modified\x20by\
    \x20an\x20update\x20operation.\n\x20Field\x20masks\x20also\x20have\x20a\
    \x20custom\x20JSON\x20encoding\x20(see\x20below).\n\n\x20#\x20Field\x20M\
    asks\x20in\x20Projections\n\n\x20When\x20used\x20in\x20the\x20context\
    \x20of\x20a\x20projection,\x20a\x20response\x20message\x20or\n\x20sub-me\
    ssage\x20is\x20filtered\x20by\x20the\x20API\x20to\x20only\x20contain\x20\
    those\x20fields\x20as\n\x20specified\x20in\x20the\x20mask.\x20For\x20exa\
    mple,\x20if\x20the\x20mask\x20in\x20the\x20previous\n\x20example\x20is\
    \x20applied\x20to\x20a\x20response\x20message\x20as\x20follows:\n\n\x20\
    \x20\x20\x20\x20f\x20{\n\x20\x20\x20\x20\x20\x20\x20a\x20:\x2022\n\x20\
    \x20\x20\x20\x20\x20\x20b\x20{\n\x20\x20\x20\x20\x20\x20\x20\x20\x20d\
    \x20:\x201\n\x20\x20\x20\x20\x20\x20\x20\x20\x20x\x20:\x202\n\x20\x20\
    \x20\x20\x20\x20\x20}\n\x20\x20\x20\x20\x20\x20\x20y\x20:\x2013\n\x20\
    \x20\x20\x20\x20}\n\x20\x20\x20\x20\x20z:\x208\n\n\x20The\x20result\x20w\
    ill\x20not\x20contain\x20specific\x20values\x20for\x20fields\x20x,y\x20a\
    nd\x20z\n\x20(their\x20value\x20will\x20be\x20set\x20to\x20the\x20defaul\
    t,\x20and\x20omitted\x20in\x20proto\x20text\n\x20output):\n\n\n\x20\x20\
    \x20\x20\x20f\x20{\n\x20\x20\x20\x20\x20\x20\x20a\x20:\x2022\n\x20\x20\
    \x20\x20\x20\x20\x20b\x20{\n\x20\x20\x20\x20\x20\x20\x20\x20\x20d\x20:\
    \x201\n\x20\x20\x20\x20\x20\x20\x20}\n\x20\x20\x20\x20\x20}\n\n\x20A\x20\
    repeated\x20field\x20is\x20not\x20allowed\x20except\x20at\x20the\x20last\
    \x20position\x20of\x20a\n\x20paths\x20string.\n\n\x20If\x20a\x20FieldMas\
    k\x20object\x20is\x20not\x20present\x20in\x20a\x20get\x20operation,\x20t\
    he\n\x20operation\x20applies\x20to\x20all\x20fields\x20(as\x20if\x20a\
    \x20FieldMask\x20of\x20all\x20fields\n\x20had\x20been\x20specified).\n\n\
    \x20Note\x20that\x20a\x20field\x20mask\x20does\x20not\x20necessarily\x20\
    apply\x20to\x20the\n\x20top-level\x20response\x20message.\x20In\x20case\
    \x20of\x20a\x20REST\x20get\x20operation,\x20the\n\x20field\x20mask\x20ap\
    plies\x20directly\x20to\x20the\x20response,\x20but\x20in\x20case\x20of\
    \x20a\x20REST\n\x20list\x20operation,\x20the\x20mask\x20instead\x20appli\
    es\x20to\x20each\x20individual\x20message\n\x20in\x20the\x20returned\x20\
    resource\x20list.\x20In\x20case\x20of\x20a\x20REST\x20custom\x20method,\
    \n\x20other\x20definitions\x20may\x20be\x20used.\x20Where\x20the\x20mask\
    \x20applies\x20will\x20be\n\x20clearly\x20documented\x20together\x20with\
    \x20its\x20declaration\x20in\x20the\x20API.\x20\x20In\n\x20any\x20case,\
    \x20the\x20effect\x20on\x20the\x20returned\x20resource/resources\x20is\
    \x20required\n\x20behavior\x20for\x20APIs.\n\n\x20#\x20Field\x20Masks\
    \x20in\x20Update\x20Operations\n\n\x20A\x20field\x20mask\x20in\x20update\
    \x20operations\x20specifies\x20which\x20fields\x20of\x20the\n\x20targete\
    d\x20resource\x20are\x20going\x20to\x20be\x20updated.\x20The\x20API\x20i\
    s\x20required\n\x20to\x20only\x20change\x20the\x20values\x20of\x20the\
    \x20fields\x20as\x20specified\x20in\x20the\x20mask\n\x20and\x20leave\x20\
    the\x20others\x20untouched.\x20If\x20a\x20resource\x20is\x20passed\x20in\
    \x20to\n\x20describe\x20the\x20updated\x20values,\x20the\x20API\x20ignor\
    es\x20the\x20values\x20of\x20all\n\x20fields\x20not\x20covered\x20by\x20\
    the\x20mask.\n\n\x20If\x20a\x20repeated\x20field\x20is\x20specified\x20f\
    or\x20an\x20update\x20operation,\x20new\x20values\x20will\n\x20be\x20app\
    ended\x20to\x20the\x20existing\x20repeated\x20field\x20in\x20the\x20targ\
    et\x20resource.\x20Note\x20that\n\x20a\x20repeated\x20field\x20is\x20onl\
    y\x20allowed\x20in\x20the\x20last\x20position\x20of\x20a\x20`paths`\x20s\
    tring.\n\n\x20If\x20a\x20sub-message\x20is\x20specified\x20in\x20the\x20\
    last\x20position\x20of\x20the\x20field\x20mask\x20for\x20an\n\x20update\
    \x20operation,\x20then\x20new\x20value\x20will\x20be\x20merged\x20into\
    \x20the\x20existing\x20sub-message\n\x20in\x20the\x20target\x20resource.\
    \n\n\x20For\x20example,\x20given\x20the\x20target\x20message:\n\n\x20\
    \x20\x20\x20\x20f\x20{\n\x20\x20\x20\x20\x20\x20\x20b\x20{\n\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20d:\x201\n\x20\x20\x20\x20\x20\x20\x20\x20\x20x:\
    \x202\n\x20\x20\x20\x20\x20\x20\x20}\n\x20\x20\x20\x20\x20\x20\x20c:\x20\
    [1]\n\x20\x20\x20\x20\x20}\n\n\x20And\x20an\x20update\x20message:\n\n\
    \x20\x20\x20\x20\x20f\x20{\n\x20\x20\x20\x20\x20\x20\x20b\x20{\n\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20d:\x2010\n\x20\x20\x20\x20\x20\x20\x20}\n\
    \x20\x20\x20\x20\x20\x20\x20c:\x20[2]\n\x20\x20\x20\x20\x20}\n\n\x20then\
    \x20if\x20the\x20field\x20mask\x20is:\n\n\x20\x20paths:\x20[\"f.b\",\x20\
    \"f.c\"]\n\n\x20then\x20the\x20result\x20will\x20be:\n\n\x20\x20\x20\x20\
    \x20f\x20{\n\x20\x20\x20\x20\x20\x20\x20b\x20{\n\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20d:\x2010\n\x20\x20\x20\x20\x20\x20\x20\x20\x20x:\x202\n\x20\
    \x20\x20\x20\x20\x20\x20}\n\x20\x20\x20\x20\x20\x20\x20c:\x20[1,\x202]\n\
    \x20\x20\x20\x20\x20}\n\n\x20An\x20implementation\x20may\x20provide\x20o\
    ptions\x20to\x20override\x20this\x20default\x20behavior\x20for\n\x20repe\
    ated\x20and\x20message\x20fields.\n\n\x20In\x20order\x20to\x20reset\x20a\
    \x20field's\x20value\x20to\x20the\x20default,\x20the\x20field\x20must\n\
    \x20be\x20in\x20the\x20mask\x20and\x20set\x20to\x20the\x20default\x20val\
    ue\x20in\x20the\x20provided\x20resource.\n\x20Hence,\x20in\x20order\x20t\
    o\x20reset\x20all\x20fields\x20of\x20a\x20resource,\x20provide\x20a\x20d\
    efault\n\x20instance\x20of\x20the\x20resource\x20and\x20set\x20all\x20fi\
    elds\x20in\x20the\x20mask,\x20or\x20do\n\x20not\x20provide\x20a\x20mask\
    \x20as\x20described\x20below.\n\n\x20If\x20a\x20field\x20mask\x20is\x20n\
    ot\x20present\x20on\x20update,\x20the\x20operation\x20applies\x20to\n\
    \x20all\x20fields\x20(as\x20if\x20a\x20field\x20mask\x20of\x20all\x20fie\
    lds\x20has\x20been\x20specified).\n\x20Note\x20that\x20in\x20the\x20pres\
    ence\x20of\x20schema\x20evolution,\x20this\x20may\x20mean\x20that\n\x20f\
    ields\x20the\x20client\x20does\x20not\x20know\x20and\x20has\x20therefore\
    \x20not\x20filled\x20into\n\x20the\x20request\x20will\x20be\x20reset\x20\
    to\x20their\x20default.\x20If\x20this\x20is\x20unwanted\n\x20behavior,\
    \x20a\x20specific\x20service\x20may\x20require\x20a\x20client\x20to\x20a\
    lways\x20specify\n\x20a\x20field\x20mask,\x20producing\x20an\x20error\
    \x20if\x20not.\n\n\x20As\x20with\x20get\x20operations,\x20the\x20locatio\
    n\x20of\x20the\x20resource\x20which\n\x20describes\x20the\x20updated\x20\
    values\x20in\x20the\x20request\x20message\x20depends\x20on\x20the\n\x20o\
    peration\x20kind.\x20In\x20any\x20case,\x20the\x20effect\x20of\x20the\
    \x20field\x20mask\x20is\n\x20required\x20to\x20be\x20honored\x20by\x20th\
    e\x20API.\n\n\x20##\x20Considerations\x20for\x20HTTP\x20REST\n\n\x20The\
    \x20HTTP\x20kind\x20of\x20an\x20update\x20operation\x20which\x20uses\x20\
    a\x20field\x20mask\x20must\n\x20be\x20set\x20to\x20PATCH\x20instead\x20o\
    f\x20PUT\x20in\x20order\x20to\x20satisfy\x20HTTP\x20semantics\n\x20(PUT\
    \x20must\x20only\x20be\x20used\x20for\x20full\x20updates).\n\n\x20#\x20J\
    SON\x20Encoding\x20of\x20Field\x20Masks\n\n\x20In\x20JSON,\x20a\x20field\
    \x20mask\x20is\x20encoded\x20as\x20a\x20single\x20string\x20where\x20pat\
    hs\x20are\n\x20separated\x20by\x20a\x20comma.\x20Fields\x20name\x20in\
    \x20each\x20path\x20are\x20converted\n\x20to/from\x20lower-camel\x20nami\
    ng\x20conventions.\n\n\x20As\x20an\x20example,\x20consider\x20the\x20fol\
    lowing\x20message\x20declarations:\n\n\x20\x20\x20\x20\x20message\x20Pro\
    file\x20{\n\x20\x20\x20\x20\x20\x20\x20User\x20user\x20=\x201;\n\x20\x20\
    \x20\x20\x20\x20\x20Photo\x20photo\x20=\x202;\n\x20\x20\x20\x20\x20}\n\
    \x20\x20\x20\x20\x20message\x20User\x20{\n\x20\x20\x20\x20\x20\x20\x20st\
    ring\x20display_name\x20=\x201;\n\x20\x20\x20\x20\x20\x20\x20string\x20a\
    ddress\x20=\x202;\n\x20\x20\x20\x20\x20}\n\n\x20In\x20proto\x20a\x20fiel\
    d\x20mask\x20for\x20`Profile`\x20may\x20look\x20as\x20such:\n\n\x20\x20\
    \x20\x20\x20mask\x20{\n\x20\x20\x20\x20\x20\x20\x20paths:\x20\"user.disp\
    lay_name\"\n\x20\x20\x20\x20\x20\x20\x20paths:\x20\"photo\"\n\x20\x20\
    \x20\x20\x20}\n\n\x20In\x20JSON,\x20the\x20same\x20mask\x20is\x20represe\
    nted\x20as\x20below:\n\n\x20\x20\x20\x20\x20{\n\x20\x20\x20\x20\x20\x20\
    \x20mask:\x20\"user.displayName,photo\"\n\x20\x20\x20\x20\x20}\n\n\x20#\
    \x20Field\x20Masks\x20and\x20Oneof\x20Fields\n\n\x20Field\x20masks\x20tr\
    eat\x20fields\x20in\x20oneofs\x20just\x20as\x20regular\x20fields.\x20Con\
    sider\x20the\n\x20following\x20message:\n\n\x20\x20\x20\x20\x20message\
    \x20SampleMessage\x20{\n\x20\x20\x20\x20\x20\x20\x20oneof\x20test_oneof\
    \x20{\n\x20\x20\x20\x20\x20\x20\x20\x20\x20string\x20name\x20=\x204;\n\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20SubMessage\x20sub_message\x20=\x209;\
    \n\x20\x20\x20\x20\x20\x20\x20}\n\x20\x20\x20\x20\x20}\n\n\x20The\x20fie\
    ld\x20mask\x20can\x20be:\n\n\x20\x20\x20\x20\x20mask\x20{\n\x20\x20\x20\
    \x20\x20\x20\x20paths:\x20\"name\"\n\x20\x20\x20\x20\x20}\n\n\x20Or:\n\n\
    \x20\x20\x20\x20\x20mask\x20{\n\x20\x20\x20\x20\x20\x20\x20paths:\x20\"s\
    ub_message\"\n\x20\x20\x20\x20\x20}\n\n\x20Note\x20that\x20oneof\x20type\
    \x20names\x20(\"test_oneof\"\x20in\x20this\x20case)\x20cannot\x20be\x20u\
    sed\x20in\n\x20paths.\n\n\x20##\x20Field\x20Mask\x20Verification\n\n\x20\
    The\x20implementation\x20of\x20any\x20API\x20method\x20which\x20has\x20a\
    \x20FieldMask\x20type\x20field\x20in\x20the\n\x20request\x20should\x20ve\
    rify\x20the\x20included\x20field\x20paths,\x20and\x20return\x20an\n\x20`\
    INVALID_ARGUMENT`\x20error\x20if\x20any\x20path\x20is\x20unmappable.\n\n\
    \x0b\n\x03\x04\0\x01\x12\x04\xf1\x01\x08\x11\n,\n\x04\x04\0\x02\0\x12\
    \x04\xf3\x01\x02\x1c\x1a\x1e\x20The\x20set\x20of\x20field\x20mask\x20pat\
    hs.\n\n\r\n\x05\x04\0\x02\0\x04\x12\x04\xf3\x01\x02\n\n\r\n\x05\x04\0\
    \x02\0\x05\x12\x04\xf3\x01\x0b\x11\n\r\n\x05\x04\0\x02\0\x01\x12\x04\xf3\
    \x01\x12\x17\n\r\n\x05\x04\0\x02\0\x03\x12\x04\xf3\x01\x1a\x1bb\x06proto\
    3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static crate::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: crate::rt::Lazy<crate::descriptor::FileDescriptorProto> = crate::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        crate::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static crate::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: crate::rt::Lazy<crate::reflect::GeneratedFileDescriptor> = crate::rt::Lazy::new();
    static file_descriptor: crate::rt::Lazy<crate::reflect::FileDescriptor> = crate::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(1);
            messages.push(FieldMask::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            crate::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        crate::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}

'''
'''--- protobuf/src/well_known_types/mod.rs ---
// This file is generated. Do not edit
// @generated
//! Generated code for "well known types"
//!
//! [This document](https://developers.google.com/protocol-buffers/docs/reference/google.protobuf) describes these types.

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

pub mod any;
pub mod api;
pub mod duration;
pub mod empty;
pub mod field_mask;
pub mod source_context;
pub mod struct_;
pub mod timestamp;
pub mod type_;
pub mod wrappers;

'''
'''--- protobuf/src/well_known_types/source_context.rs ---
// This file is generated by rust-protobuf 4.0.0-alpha.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `google/protobuf/source_context.proto`

///  `SourceContext` represents information about the source of a
///  protobuf element, like the file in which it is defined.
// @@protoc_insertion_point(message:google.protobuf.SourceContext)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SourceContext {
    // message fields
    ///  The path-qualified name of the .proto file that contained the associated
    ///  protobuf element.  For example: `"google/protobuf/source_context.proto"`.
    // @@protoc_insertion_point(field:google.protobuf.SourceContext.file_name)
    pub file_name: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.SourceContext.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SourceContext {
    fn default() -> &'a SourceContext {
        <SourceContext as crate::Message>::default_instance()
    }
}

impl SourceContext {
    pub fn new() -> SourceContext {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "file_name",
            |m: &SourceContext| { &m.file_name },
            |m: &mut SourceContext| { &mut m.file_name },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<SourceContext>(
            "SourceContext",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for SourceContext {
    const NAME: &'static str = "SourceContext";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.file_name = is.read_string()?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.file_name.is_empty() {
            my_size += crate::rt::string_size(1, &self.file_name);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if !self.file_name.is_empty() {
            os.write_string(1, &self.file_name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SourceContext {
        SourceContext::new()
    }

    fn clear(&mut self) {
        self.file_name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SourceContext {
        static instance: SourceContext = SourceContext {
            file_name: ::std::string::String::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for SourceContext {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SourceContext").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SourceContext {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for SourceContext {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n$google/protobuf/source_context.proto\x12\x0fgoogle.protobuf\",\n\rSou\
    rceContext\x12\x1b\n\tfile_name\x18\x01\x20\x01(\tR\x08fileNameB\x8a\x01\
    \n\x13com.google.protobufB\x12SourceContextProtoP\x01Z6google.golang.org\
    /protobuf/types/known/sourcecontextpb\xa2\x02\x03GPB\xaa\x02\x1eGoogle.P\
    rotobuf.WellKnownTypesJ\xc1\x10\n\x06\x12\x04\x1e\0/\x01\n\xcc\x0c\n\x01\
    \x0c\x12\x03\x1e\0\x122\xc1\x0c\x20Protocol\x20Buffers\x20-\x20Google's\
    \x20data\x20interchange\x20format\n\x20Copyright\x202008\x20Google\x20In\
    c.\x20\x20All\x20rights\x20reserved.\n\x20https://developers.google.com/\
    protocol-buffers/\n\n\x20Redistribution\x20and\x20use\x20in\x20source\
    \x20and\x20binary\x20forms,\x20with\x20or\x20without\n\x20modification,\
    \x20are\x20permitted\x20provided\x20that\x20the\x20following\x20conditio\
    ns\x20are\n\x20met:\n\n\x20\x20\x20\x20\x20*\x20Redistributions\x20of\
    \x20source\x20code\x20must\x20retain\x20the\x20above\x20copyright\n\x20n\
    otice,\x20this\x20list\x20of\x20conditions\x20and\x20the\x20following\
    \x20disclaimer.\n\x20\x20\x20\x20\x20*\x20Redistributions\x20in\x20binar\
    y\x20form\x20must\x20reproduce\x20the\x20above\n\x20copyright\x20notice,\
    \x20this\x20list\x20of\x20conditions\x20and\x20the\x20following\x20discl\
    aimer\n\x20in\x20the\x20documentation\x20and/or\x20other\x20materials\
    \x20provided\x20with\x20the\n\x20distribution.\n\x20\x20\x20\x20\x20*\
    \x20Neither\x20the\x20name\x20of\x20Google\x20Inc.\x20nor\x20the\x20name\
    s\x20of\x20its\n\x20contributors\x20may\x20be\x20used\x20to\x20endorse\
    \x20or\x20promote\x20products\x20derived\x20from\n\x20this\x20software\
    \x20without\x20specific\x20prior\x20written\x20permission.\n\n\x20THIS\
    \x20SOFTWARE\x20IS\x20PROVIDED\x20BY\x20THE\x20COPYRIGHT\x20HOLDERS\x20A\
    ND\x20CONTRIBUTORS\n\x20\"AS\x20IS\"\x20AND\x20ANY\x20EXPRESS\x20OR\x20I\
    MPLIED\x20WARRANTIES,\x20INCLUDING,\x20BUT\x20NOT\n\x20LIMITED\x20TO,\
    \x20THE\x20IMPLIED\x20WARRANTIES\x20OF\x20MERCHANTABILITY\x20AND\x20FITN\
    ESS\x20FOR\n\x20A\x20PARTICULAR\x20PURPOSE\x20ARE\x20DISCLAIMED.\x20IN\
    \x20NO\x20EVENT\x20SHALL\x20THE\x20COPYRIGHT\n\x20OWNER\x20OR\x20CONTRIB\
    UTORS\x20BE\x20LIABLE\x20FOR\x20ANY\x20DIRECT,\x20INDIRECT,\x20INCIDENTA\
    L,\n\x20SPECIAL,\x20EXEMPLARY,\x20OR\x20CONSEQUENTIAL\x20DAMAGES\x20(INC\
    LUDING,\x20BUT\x20NOT\n\x20LIMITED\x20TO,\x20PROCUREMENT\x20OF\x20SUBSTI\
    TUTE\x20GOODS\x20OR\x20SERVICES;\x20LOSS\x20OF\x20USE,\n\x20DATA,\x20OR\
    \x20PROFITS;\x20OR\x20BUSINESS\x20INTERRUPTION)\x20HOWEVER\x20CAUSED\x20\
    AND\x20ON\x20ANY\n\x20THEORY\x20OF\x20LIABILITY,\x20WHETHER\x20IN\x20CON\
    TRACT,\x20STRICT\x20LIABILITY,\x20OR\x20TORT\n\x20(INCLUDING\x20NEGLIGEN\
    CE\x20OR\x20OTHERWISE)\x20ARISING\x20IN\x20ANY\x20WAY\x20OUT\x20OF\x20TH\
    E\x20USE\n\x20OF\x20THIS\x20SOFTWARE,\x20EVEN\x20IF\x20ADVISED\x20OF\x20\
    THE\x20POSSIBILITY\x20OF\x20SUCH\x20DAMAGE.\n\n\x08\n\x01\x02\x12\x03\
    \x20\0\x18\n\x08\n\x01\x08\x12\x03\"\0;\n\t\n\x02\x08%\x12\x03\"\0;\n\
    \x08\n\x01\x08\x12\x03#\0,\n\t\n\x02\x08\x01\x12\x03#\0,\n\x08\n\x01\x08\
    \x12\x03$\03\n\t\n\x02\x08\x08\x12\x03$\03\n\x08\n\x01\x08\x12\x03%\0\"\
    \n\t\n\x02\x08\n\x12\x03%\0\"\n\x08\n\x01\x08\x12\x03&\0!\n\t\n\x02\x08$\
    \x12\x03&\0!\n\x08\n\x01\x08\x12\x03'\0M\n\t\n\x02\x08\x0b\x12\x03'\0M\n\
    \x83\x01\n\x02\x04\0\x12\x04+\0/\x01\x1aw\x20`SourceContext`\x20represen\
    ts\x20information\x20about\x20the\x20source\x20of\x20a\n\x20protobuf\x20\
    element,\x20like\x20the\x20file\x20in\x20which\x20it\x20is\x20defined.\n\
    \n\n\n\x03\x04\0\x01\x12\x03+\x08\x15\n\xa3\x01\n\x04\x04\0\x02\0\x12\
    \x03.\x02\x17\x1a\x95\x01\x20The\x20path-qualified\x20name\x20of\x20the\
    \x20.proto\x20file\x20that\x20contained\x20the\x20associated\n\x20protob\
    uf\x20element.\x20\x20For\x20example:\x20`\"google/protobuf/source_conte\
    xt.proto\"`.\n\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03.\x02\x08\n\x0c\n\x05\
    \x04\0\x02\0\x01\x12\x03.\t\x12\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03.\x15\
    \x16b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static crate::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: crate::rt::Lazy<crate::descriptor::FileDescriptorProto> = crate::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        crate::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static crate::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: crate::rt::Lazy<crate::reflect::GeneratedFileDescriptor> = crate::rt::Lazy::new();
    static file_descriptor: crate::rt::Lazy<crate::reflect::FileDescriptor> = crate::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(1);
            messages.push(SourceContext::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            crate::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        crate::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}

'''
'''--- protobuf/src/well_known_types/struct_.rs ---
// This file is generated by rust-protobuf 4.0.0-alpha.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `google/protobuf/struct.proto`

///  `Struct` represents a structured data value, consisting of fields
///  which map to dynamically typed values. In some languages, `Struct`
///  might be supported by a native representation. For example, in
///  scripting languages like JS a struct is represented as an
///  object. The details of that representation are described together
///  with the proto support for the language.
///
///  The JSON representation for `Struct` is JSON object.
// @@protoc_insertion_point(message:google.protobuf.Struct)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Struct {
    // message fields
    ///  Unordered map of dynamically typed values.
    // @@protoc_insertion_point(field:google.protobuf.Struct.fields)
    pub fields: ::std::collections::HashMap<::std::string::String, Value>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.Struct.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Struct {
    fn default() -> &'a Struct {
        <Struct as crate::Message>::default_instance()
    }
}

impl Struct {
    pub fn new() -> Struct {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "fields",
            |m: &Struct| { &m.fields },
            |m: &mut Struct| { &mut m.fields },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<Struct>(
            "Struct",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for Struct {
    const NAME: &'static str = "Struct";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => crate::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.fields.insert(key, value);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for (k, v) in &self.fields {
            let mut entry_size = 0;
            entry_size += crate::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + crate::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for (k, v) in &self.fields {
            let mut entry_size = 0;
            entry_size += crate::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(10)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            crate::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Struct {
        Struct::new()
    }

    fn clear(&mut self) {
        self.fields.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Struct {
        static instance: crate::rt::Lazy<Struct> = crate::rt::Lazy::new();
        instance.get(Struct::new)
    }
}

impl crate::MessageFull for Struct {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Struct").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Struct {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for Struct {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

///  `Value` represents a dynamically typed value which can be either
///  null, a number, a string, a boolean, a recursive struct value, or a
///  list of values. A producer of value is expected to set one of these
///  variants. Absence of any variant indicates an error.
///
///  The JSON representation for `Value` is JSON value.
// @@protoc_insertion_point(message:google.protobuf.Value)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Value {
    // message oneof groups
    pub kind: ::std::option::Option<value::Kind>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.Value.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Value {
    fn default() -> &'a Value {
        <Value as crate::Message>::default_instance()
    }
}

impl Value {
    pub fn new() -> Value {
        ::std::default::Default::default()
    }

    // .google.protobuf.NullValue null_value = 1;

    pub fn null_value(&self) -> NullValue {
        match self.kind {
            ::std::option::Option::Some(value::Kind::NullValue(v)) => crate::EnumOrUnknown::enum_value_or_default(&v),
            _ => NullValue::NULL_VALUE,
        }
    }

    pub fn clear_null_value(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_null_value(&self) -> bool {
        match self.kind {
            ::std::option::Option::Some(value::Kind::NullValue(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_null_value(&mut self, v: NullValue) {
        self.kind = ::std::option::Option::Some(value::Kind::NullValue(crate::EnumOrUnknown::new(v)))
    }

    // double number_value = 2;

    pub fn number_value(&self) -> f64 {
        match self.kind {
            ::std::option::Option::Some(value::Kind::NumberValue(v)) => v,
            _ => 0.,
        }
    }

    pub fn clear_number_value(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_number_value(&self) -> bool {
        match self.kind {
            ::std::option::Option::Some(value::Kind::NumberValue(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_number_value(&mut self, v: f64) {
        self.kind = ::std::option::Option::Some(value::Kind::NumberValue(v))
    }

    // string string_value = 3;

    pub fn string_value(&self) -> &str {
        match self.kind {
            ::std::option::Option::Some(value::Kind::StringValue(ref v)) => v,
            _ => "",
        }
    }

    pub fn clear_string_value(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_string_value(&self) -> bool {
        match self.kind {
            ::std::option::Option::Some(value::Kind::StringValue(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_string_value(&mut self, v: ::std::string::String) {
        self.kind = ::std::option::Option::Some(value::Kind::StringValue(v))
    }

    // Mutable pointer to the field.
    pub fn mut_string_value(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(value::Kind::StringValue(_)) = self.kind {
        } else {
            self.kind = ::std::option::Option::Some(value::Kind::StringValue(::std::string::String::new()));
        }
        match self.kind {
            ::std::option::Option::Some(value::Kind::StringValue(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_string_value(&mut self) -> ::std::string::String {
        if self.has_string_value() {
            match self.kind.take() {
                ::std::option::Option::Some(value::Kind::StringValue(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // bool bool_value = 4;

    pub fn bool_value(&self) -> bool {
        match self.kind {
            ::std::option::Option::Some(value::Kind::BoolValue(v)) => v,
            _ => false,
        }
    }

    pub fn clear_bool_value(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_bool_value(&self) -> bool {
        match self.kind {
            ::std::option::Option::Some(value::Kind::BoolValue(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_bool_value(&mut self, v: bool) {
        self.kind = ::std::option::Option::Some(value::Kind::BoolValue(v))
    }

    // .google.protobuf.Struct struct_value = 5;

    pub fn struct_value(&self) -> &Struct {
        match self.kind {
            ::std::option::Option::Some(value::Kind::StructValue(ref v)) => v,
            _ => <Struct as crate::Message>::default_instance(),
        }
    }

    pub fn clear_struct_value(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_struct_value(&self) -> bool {
        match self.kind {
            ::std::option::Option::Some(value::Kind::StructValue(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_struct_value(&mut self, v: Struct) {
        self.kind = ::std::option::Option::Some(value::Kind::StructValue(v))
    }

    // Mutable pointer to the field.
    pub fn mut_struct_value(&mut self) -> &mut Struct {
        if let ::std::option::Option::Some(value::Kind::StructValue(_)) = self.kind {
        } else {
            self.kind = ::std::option::Option::Some(value::Kind::StructValue(Struct::new()));
        }
        match self.kind {
            ::std::option::Option::Some(value::Kind::StructValue(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_struct_value(&mut self) -> Struct {
        if self.has_struct_value() {
            match self.kind.take() {
                ::std::option::Option::Some(value::Kind::StructValue(v)) => v,
                _ => panic!(),
            }
        } else {
            Struct::new()
        }
    }

    // .google.protobuf.ListValue list_value = 6;

    pub fn list_value(&self) -> &ListValue {
        match self.kind {
            ::std::option::Option::Some(value::Kind::ListValue(ref v)) => v,
            _ => <ListValue as crate::Message>::default_instance(),
        }
    }

    pub fn clear_list_value(&mut self) {
        self.kind = ::std::option::Option::None;
    }

    pub fn has_list_value(&self) -> bool {
        match self.kind {
            ::std::option::Option::Some(value::Kind::ListValue(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_list_value(&mut self, v: ListValue) {
        self.kind = ::std::option::Option::Some(value::Kind::ListValue(v))
    }

    // Mutable pointer to the field.
    pub fn mut_list_value(&mut self) -> &mut ListValue {
        if let ::std::option::Option::Some(value::Kind::ListValue(_)) = self.kind {
        } else {
            self.kind = ::std::option::Option::Some(value::Kind::ListValue(ListValue::new()));
        }
        match self.kind {
            ::std::option::Option::Some(value::Kind::ListValue(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_list_value(&mut self) -> ListValue {
        if self.has_list_value() {
            match self.kind.take() {
                ::std::option::Option::Some(value::Kind::ListValue(v)) => v,
                _ => panic!(),
            }
        } else {
            ListValue::new()
        }
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(crate::reflect::rt::v2::make_oneof_enum_accessors::<_, _>(
            "null_value",
            |message: &Value| match &message.kind {
                ::std::option::Option::Some(value::Kind::NullValue(e)) => ::std::option::Option::Some(*e),
                _ => ::std::option::Option::None,
            },
            |message: &mut Value, e: crate::EnumOrUnknown<NullValue>| {
                message.kind = ::std::option::Option::Some(value::Kind::NullValue(e));
            },
            NullValue::NULL_VALUE,
        ));
        fields.push(crate::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "number_value",
            Value::has_number_value,
            Value::number_value,
            Value::set_number_value,
        ));
        fields.push(crate::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "string_value",
            Value::has_string_value,
            Value::string_value,
            Value::set_string_value,
        ));
        fields.push(crate::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "bool_value",
            Value::has_bool_value,
            Value::bool_value,
            Value::set_bool_value,
        ));
        fields.push(crate::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Struct>(
            "struct_value",
            Value::has_struct_value,
            Value::struct_value,
            Value::mut_struct_value,
            Value::set_struct_value,
        ));
        fields.push(crate::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ListValue>(
            "list_value",
            Value::has_list_value,
            Value::list_value,
            Value::mut_list_value,
            Value::set_list_value,
        ));
        oneofs.push(value::Kind::generated_oneof_descriptor_data());
        crate::reflect::GeneratedMessageDescriptorData::new_2::<Value>(
            "Value",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for Value {
    const NAME: &'static str = "Value";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.kind = ::std::option::Option::Some(value::Kind::NullValue(is.read_enum_or_unknown()?));
                },
                17 => {
                    self.kind = ::std::option::Option::Some(value::Kind::NumberValue(is.read_double()?));
                },
                26 => {
                    self.kind = ::std::option::Option::Some(value::Kind::StringValue(is.read_string()?));
                },
                32 => {
                    self.kind = ::std::option::Option::Some(value::Kind::BoolValue(is.read_bool()?));
                },
                42 => {
                    self.kind = ::std::option::Option::Some(value::Kind::StructValue(is.read_message()?));
                },
                50 => {
                    self.kind = ::std::option::Option::Some(value::Kind::ListValue(is.read_message()?));
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.kind {
            match v {
                &value::Kind::NullValue(v) => {
                    my_size += crate::rt::int32_size(1, v.value());
                },
                &value::Kind::NumberValue(v) => {
                    my_size += 1 + 8;
                },
                &value::Kind::StringValue(ref v) => {
                    my_size += crate::rt::string_size(3, &v);
                },
                &value::Kind::BoolValue(v) => {
                    my_size += 1 + 1;
                },
                &value::Kind::StructValue(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
                },
                &value::Kind::ListValue(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.kind {
            match v {
                &value::Kind::NullValue(v) => {
                    os.write_enum(1, crate::EnumOrUnknown::value(&v))?;
                },
                &value::Kind::NumberValue(v) => {
                    os.write_double(2, v)?;
                },
                &value::Kind::StringValue(ref v) => {
                    os.write_string(3, v)?;
                },
                &value::Kind::BoolValue(v) => {
                    os.write_bool(4, v)?;
                },
                &value::Kind::StructValue(ref v) => {
                    crate::rt::write_message_field_with_cached_size(5, v, os)?;
                },
                &value::Kind::ListValue(ref v) => {
                    crate::rt::write_message_field_with_cached_size(6, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Value {
        Value::new()
    }

    fn clear(&mut self) {
        self.kind = ::std::option::Option::None;
        self.kind = ::std::option::Option::None;
        self.kind = ::std::option::Option::None;
        self.kind = ::std::option::Option::None;
        self.kind = ::std::option::Option::None;
        self.kind = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Value {
        static instance: Value = Value {
            kind: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for Value {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Value").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Value {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for Value {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Value`
pub mod value {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:google.protobuf.Value.kind)
    pub enum Kind {
        // @@protoc_insertion_point(oneof_field:google.protobuf.Value.null_value)
        NullValue(crate::EnumOrUnknown<super::NullValue>),
        // @@protoc_insertion_point(oneof_field:google.protobuf.Value.number_value)
        NumberValue(f64),
        // @@protoc_insertion_point(oneof_field:google.protobuf.Value.string_value)
        StringValue(::std::string::String),
        // @@protoc_insertion_point(oneof_field:google.protobuf.Value.bool_value)
        BoolValue(bool),
        // @@protoc_insertion_point(oneof_field:google.protobuf.Value.struct_value)
        StructValue(super::Struct),
        // @@protoc_insertion_point(oneof_field:google.protobuf.Value.list_value)
        ListValue(super::ListValue),
    }

    impl crate::Oneof for Kind {
    }

    impl crate::OneofFull for Kind {
        fn descriptor() -> crate::reflect::OneofDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::OneofDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| <super::Value as crate::MessageFull>::descriptor().oneof_by_name("kind").unwrap()).clone()
        }
    }

    impl Kind {
        pub(in super) fn generated_oneof_descriptor_data() -> crate::reflect::GeneratedOneofDescriptorData {
            crate::reflect::GeneratedOneofDescriptorData::new::<Kind>("kind")
        }
    }
}

///  `ListValue` is a wrapper around a repeated field of values.
///
///  The JSON representation for `ListValue` is JSON array.
// @@protoc_insertion_point(message:google.protobuf.ListValue)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListValue {
    // message fields
    ///  Repeated field of dynamically typed values.
    // @@protoc_insertion_point(field:google.protobuf.ListValue.values)
    pub values: ::std::vec::Vec<Value>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.ListValue.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListValue {
    fn default() -> &'a ListValue {
        <ListValue as crate::Message>::default_instance()
    }
}

impl ListValue {
    pub fn new() -> ListValue {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "values",
            |m: &ListValue| { &m.values },
            |m: &mut ListValue| { &mut m.values },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<ListValue>(
            "ListValue",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for ListValue {
    const NAME: &'static str = "ListValue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.values.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.values {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.values {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListValue {
        ListValue::new()
    }

    fn clear(&mut self) {
        self.values.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListValue {
        static instance: ListValue = ListValue {
            values: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for ListValue {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListValue").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for ListValue {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

///  `NullValue` is a singleton enumeration to represent the null value for the
///  `Value` type union.
///
///   The JSON representation for `NullValue` is JSON `null`.
#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:google.protobuf.NullValue)
pub enum NullValue {
    // @@protoc_insertion_point(enum_value:google.protobuf.NullValue.NULL_VALUE)
    NULL_VALUE = 0,
}

impl crate::Enum for NullValue {
    const NAME: &'static str = "NullValue";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<NullValue> {
        match value {
            0 => ::std::option::Option::Some(NullValue::NULL_VALUE),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<NullValue> {
        match str {
            "NULL_VALUE" => ::std::option::Option::Some(NullValue::NULL_VALUE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [NullValue] = &[
        NullValue::NULL_VALUE,
    ];
}

impl crate::EnumFull for NullValue {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("NullValue").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for NullValue {
    fn default() -> Self {
        NullValue::NULL_VALUE
    }
}

impl NullValue {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<NullValue>("NullValue")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1cgoogle/protobuf/struct.proto\x12\x0fgoogle.protobuf\"\x98\x01\n\
    \x06Struct\x12;\n\x06fields\x18\x01\x20\x03(\x0b2#.google.protobuf.Struc\
    t.FieldsEntryR\x06fields\x1aQ\n\x0bFieldsEntry\x12\x10\n\x03key\x18\x01\
    \x20\x01(\tR\x03key\x12,\n\x05value\x18\x02\x20\x01(\x0b2\x16.google.pro\
    tobuf.ValueR\x05value:\x028\x01\"\xb2\x02\n\x05Value\x12;\n\nnull_value\
    \x18\x01\x20\x01(\x0e2\x1a.google.protobuf.NullValueH\0R\tnullValue\x12#\
    \n\x0cnumber_value\x18\x02\x20\x01(\x01H\0R\x0bnumberValue\x12#\n\x0cstr\
    ing_value\x18\x03\x20\x01(\tH\0R\x0bstringValue\x12\x1f\n\nbool_value\
    \x18\x04\x20\x01(\x08H\0R\tboolValue\x12<\n\x0cstruct_value\x18\x05\x20\
    \x01(\x0b2\x17.google.protobuf.StructH\0R\x0bstructValue\x12;\n\nlist_va\
    lue\x18\x06\x20\x01(\x0b2\x1a.google.protobuf.ListValueH\0R\tlistValueB\
    \x06\n\x04kind\";\n\tListValue\x12.\n\x06values\x18\x01\x20\x03(\x0b2\
    \x16.google.protobuf.ValueR\x06values*\x1b\n\tNullValue\x12\x0e\n\nNULL_\
    VALUE\x10\0B\x7f\n\x13com.google.protobufB\x0bStructProtoP\x01Z/google.g\
    olang.org/protobuf/types/known/structpb\xf8\x01\x01\xa2\x02\x03GPB\xaa\
    \x02\x1eGoogle.Protobuf.WellKnownTypesJ\x9a\x1d\n\x06\x12\x04\x1e\0^\x01\
    \n\xcc\x0c\n\x01\x0c\x12\x03\x1e\0\x122\xc1\x0c\x20Protocol\x20Buffers\
    \x20-\x20Google's\x20data\x20interchange\x20format\n\x20Copyright\x20200\
    8\x20Google\x20Inc.\x20\x20All\x20rights\x20reserved.\n\x20https://devel\
    opers.google.com/protocol-buffers/\n\n\x20Redistribution\x20and\x20use\
    \x20in\x20source\x20and\x20binary\x20forms,\x20with\x20or\x20without\n\
    \x20modification,\x20are\x20permitted\x20provided\x20that\x20the\x20foll\
    owing\x20conditions\x20are\n\x20met:\n\n\x20\x20\x20\x20\x20*\x20Redistr\
    ibutions\x20of\x20source\x20code\x20must\x20retain\x20the\x20above\x20co\
    pyright\n\x20notice,\x20this\x20list\x20of\x20conditions\x20and\x20the\
    \x20following\x20disclaimer.\n\x20\x20\x20\x20\x20*\x20Redistributions\
    \x20in\x20binary\x20form\x20must\x20reproduce\x20the\x20above\n\x20copyr\
    ight\x20notice,\x20this\x20list\x20of\x20conditions\x20and\x20the\x20fol\
    lowing\x20disclaimer\n\x20in\x20the\x20documentation\x20and/or\x20other\
    \x20materials\x20provided\x20with\x20the\n\x20distribution.\n\x20\x20\
    \x20\x20\x20*\x20Neither\x20the\x20name\x20of\x20Google\x20Inc.\x20nor\
    \x20the\x20names\x20of\x20its\n\x20contributors\x20may\x20be\x20used\x20\
    to\x20endorse\x20or\x20promote\x20products\x20derived\x20from\n\x20this\
    \x20software\x20without\x20specific\x20prior\x20written\x20permission.\n\
    \n\x20THIS\x20SOFTWARE\x20IS\x20PROVIDED\x20BY\x20THE\x20COPYRIGHT\x20HO\
    LDERS\x20AND\x20CONTRIBUTORS\n\x20\"AS\x20IS\"\x20AND\x20ANY\x20EXPRESS\
    \x20OR\x20IMPLIED\x20WARRANTIES,\x20INCLUDING,\x20BUT\x20NOT\n\x20LIMITE\
    D\x20TO,\x20THE\x20IMPLIED\x20WARRANTIES\x20OF\x20MERCHANTABILITY\x20AND\
    \x20FITNESS\x20FOR\n\x20A\x20PARTICULAR\x20PURPOSE\x20ARE\x20DISCLAIMED.\
    \x20IN\x20NO\x20EVENT\x20SHALL\x20THE\x20COPYRIGHT\n\x20OWNER\x20OR\x20C\
    ONTRIBUTORS\x20BE\x20LIABLE\x20FOR\x20ANY\x20DIRECT,\x20INDIRECT,\x20INC\
    IDENTAL,\n\x20SPECIAL,\x20EXEMPLARY,\x20OR\x20CONSEQUENTIAL\x20DAMAGES\
    \x20(INCLUDING,\x20BUT\x20NOT\n\x20LIMITED\x20TO,\x20PROCUREMENT\x20OF\
    \x20SUBSTITUTE\x20GOODS\x20OR\x20SERVICES;\x20LOSS\x20OF\x20USE,\n\x20DA\
    TA,\x20OR\x20PROFITS;\x20OR\x20BUSINESS\x20INTERRUPTION)\x20HOWEVER\x20C\
    AUSED\x20AND\x20ON\x20ANY\n\x20THEORY\x20OF\x20LIABILITY,\x20WHETHER\x20\
    IN\x20CONTRACT,\x20STRICT\x20LIABILITY,\x20OR\x20TORT\n\x20(INCLUDING\
    \x20NEGLIGENCE\x20OR\x20OTHERWISE)\x20ARISING\x20IN\x20ANY\x20WAY\x20OUT\
    \x20OF\x20THE\x20USE\n\x20OF\x20THIS\x20SOFTWARE,\x20EVEN\x20IF\x20ADVIS\
    ED\x20OF\x20THE\x20POSSIBILITY\x20OF\x20SUCH\x20DAMAGE.\n\n\x08\n\x01\
    \x02\x12\x03\x20\0\x18\n\x08\n\x01\x08\x12\x03\"\0;\n\t\n\x02\x08%\x12\
    \x03\"\0;\n\x08\n\x01\x08\x12\x03#\0\x1f\n\t\n\x02\x08\x1f\x12\x03#\0\
    \x1f\n\x08\n\x01\x08\x12\x03$\0F\n\t\n\x02\x08\x0b\x12\x03$\0F\n\x08\n\
    \x01\x08\x12\x03%\0,\n\t\n\x02\x08\x01\x12\x03%\0,\n\x08\n\x01\x08\x12\
    \x03&\0,\n\t\n\x02\x08\x08\x12\x03&\0,\n\x08\n\x01\x08\x12\x03'\0\"\n\t\
    \n\x02\x08\n\x12\x03'\0\"\n\x08\n\x01\x08\x12\x03(\0!\n\t\n\x02\x08$\x12\
    \x03(\0!\n\xb3\x03\n\x02\x04\0\x12\x042\05\x01\x1a\xa6\x03\x20`Struct`\
    \x20represents\x20a\x20structured\x20data\x20value,\x20consisting\x20of\
    \x20fields\n\x20which\x20map\x20to\x20dynamically\x20typed\x20values.\
    \x20In\x20some\x20languages,\x20`Struct`\n\x20might\x20be\x20supported\
    \x20by\x20a\x20native\x20representation.\x20For\x20example,\x20in\n\x20s\
    cripting\x20languages\x20like\x20JS\x20a\x20struct\x20is\x20represented\
    \x20as\x20an\n\x20object.\x20The\x20details\x20of\x20that\x20representat\
    ion\x20are\x20described\x20together\n\x20with\x20the\x20proto\x20support\
    \x20for\x20the\x20language.\n\n\x20The\x20JSON\x20representation\x20for\
    \x20`Struct`\x20is\x20JSON\x20object.\n\n\n\n\x03\x04\0\x01\x12\x032\x08\
    \x0e\n9\n\x04\x04\0\x02\0\x12\x034\x02\x20\x1a,\x20Unordered\x20map\x20o\
    f\x20dynamically\x20typed\x20values.\n\n\x0c\n\x05\x04\0\x02\0\x06\x12\
    \x034\x02\x14\n\x0c\n\x05\x04\0\x02\0\x01\x12\x034\x15\x1b\n\x0c\n\x05\
    \x04\0\x02\0\x03\x12\x034\x1e\x1f\n\xc4\x02\n\x02\x04\x01\x12\x04=\0M\
    \x01\x1a\xb7\x02\x20`Value`\x20represents\x20a\x20dynamically\x20typed\
    \x20value\x20which\x20can\x20be\x20either\n\x20null,\x20a\x20number,\x20\
    a\x20string,\x20a\x20boolean,\x20a\x20recursive\x20struct\x20value,\x20o\
    r\x20a\n\x20list\x20of\x20values.\x20A\x20producer\x20of\x20value\x20is\
    \x20expected\x20to\x20set\x20one\x20of\x20these\n\x20variants.\x20Absenc\
    e\x20of\x20any\x20variant\x20indicates\x20an\x20error.\n\n\x20The\x20JSO\
    N\x20representation\x20for\x20`Value`\x20is\x20JSON\x20value.\n\n\n\n\
    \x03\x04\x01\x01\x12\x03=\x08\r\n\"\n\x04\x04\x01\x08\0\x12\x04?\x02L\
    \x03\x1a\x14\x20The\x20kind\x20of\x20value.\n\n\x0c\n\x05\x04\x01\x08\0\
    \x01\x12\x03?\x08\x0c\n'\n\x04\x04\x01\x02\0\x12\x03A\x04\x1d\x1a\x1a\
    \x20Represents\x20a\x20null\x20value.\n\n\x0c\n\x05\x04\x01\x02\0\x06\
    \x12\x03A\x04\r\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03A\x0e\x18\n\x0c\n\
    \x05\x04\x01\x02\0\x03\x12\x03A\x1b\x1c\n)\n\x04\x04\x01\x02\x01\x12\x03\
    C\x04\x1c\x1a\x1c\x20Represents\x20a\x20double\x20value.\n\n\x0c\n\x05\
    \x04\x01\x02\x01\x05\x12\x03C\x04\n\n\x0c\n\x05\x04\x01\x02\x01\x01\x12\
    \x03C\x0b\x17\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x03C\x1a\x1b\n)\n\x04\
    \x04\x01\x02\x02\x12\x03E\x04\x1c\x1a\x1c\x20Represents\x20a\x20string\
    \x20value.\n\n\x0c\n\x05\x04\x01\x02\x02\x05\x12\x03E\x04\n\n\x0c\n\x05\
    \x04\x01\x02\x02\x01\x12\x03E\x0b\x17\n\x0c\n\x05\x04\x01\x02\x02\x03\
    \x12\x03E\x1a\x1b\n*\n\x04\x04\x01\x02\x03\x12\x03G\x04\x18\x1a\x1d\x20R\
    epresents\x20a\x20boolean\x20value.\n\n\x0c\n\x05\x04\x01\x02\x03\x05\
    \x12\x03G\x04\x08\n\x0c\n\x05\x04\x01\x02\x03\x01\x12\x03G\t\x13\n\x0c\n\
    \x05\x04\x01\x02\x03\x03\x12\x03G\x16\x17\n-\n\x04\x04\x01\x02\x04\x12\
    \x03I\x04\x1c\x1a\x20\x20Represents\x20a\x20structured\x20value.\n\n\x0c\
    \n\x05\x04\x01\x02\x04\x06\x12\x03I\x04\n\n\x0c\n\x05\x04\x01\x02\x04\
    \x01\x12\x03I\x0b\x17\n\x0c\n\x05\x04\x01\x02\x04\x03\x12\x03I\x1a\x1b\n\
    -\n\x04\x04\x01\x02\x05\x12\x03K\x04\x1d\x1a\x20\x20Represents\x20a\x20r\
    epeated\x20`Value`.\n\n\x0c\n\x05\x04\x01\x02\x05\x06\x12\x03K\x04\r\n\
    \x0c\n\x05\x04\x01\x02\x05\x01\x12\x03K\x0e\x18\n\x0c\n\x05\x04\x01\x02\
    \x05\x03\x12\x03K\x1b\x1c\n\xa9\x01\n\x02\x05\0\x12\x04S\0V\x01\x1a\x9c\
    \x01\x20`NullValue`\x20is\x20a\x20singleton\x20enumeration\x20to\x20repr\
    esent\x20the\x20null\x20value\x20for\x20the\n\x20`Value`\x20type\x20unio\
    n.\n\n\x20\x20The\x20JSON\x20representation\x20for\x20`NullValue`\x20is\
    \x20JSON\x20`null`.\n\n\n\n\x03\x05\0\x01\x12\x03S\x05\x0e\n\x1a\n\x04\
    \x05\0\x02\0\x12\x03U\x02\x11\x1a\r\x20Null\x20value.\n\n\x0c\n\x05\x05\
    \0\x02\0\x01\x12\x03U\x02\x0c\n\x0c\n\x05\x05\0\x02\0\x02\x12\x03U\x0f\
    \x10\n\x82\x01\n\x02\x04\x02\x12\x04[\0^\x01\x1av\x20`ListValue`\x20is\
    \x20a\x20wrapper\x20around\x20a\x20repeated\x20field\x20of\x20values.\n\
    \n\x20The\x20JSON\x20representation\x20for\x20`ListValue`\x20is\x20JSON\
    \x20array.\n\n\n\n\x03\x04\x02\x01\x12\x03[\x08\x11\n:\n\x04\x04\x02\x02\
    \0\x12\x03]\x02\x1c\x1a-\x20Repeated\x20field\x20of\x20dynamically\x20ty\
    ped\x20values.\n\n\x0c\n\x05\x04\x02\x02\0\x04\x12\x03]\x02\n\n\x0c\n\
    \x05\x04\x02\x02\0\x06\x12\x03]\x0b\x10\n\x0c\n\x05\x04\x02\x02\0\x01\
    \x12\x03]\x11\x17\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03]\x1a\x1bb\x06pro\
    to3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static crate::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: crate::rt::Lazy<crate::descriptor::FileDescriptorProto> = crate::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        crate::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static crate::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: crate::rt::Lazy<crate::reflect::GeneratedFileDescriptor> = crate::rt::Lazy::new();
    static file_descriptor: crate::rt::Lazy<crate::reflect::FileDescriptor> = crate::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(3);
            messages.push(Struct::generated_message_descriptor_data());
            messages.push(Value::generated_message_descriptor_data());
            messages.push(ListValue::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(1);
            enums.push(NullValue::generated_enum_descriptor_data());
            crate::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        crate::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}

'''
'''--- protobuf/src/well_known_types/timestamp.rs ---
// This file is generated by rust-protobuf 4.0.0-alpha.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `google/protobuf/timestamp.proto`

// @@protoc_insertion_point(message:google.protobuf.Timestamp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Timestamp {
    // message fields
    ///  Represents seconds of UTC time since Unix epoch
    ///  1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
    ///  9999-12-31T23:59:59Z inclusive.
    // @@protoc_insertion_point(field:google.protobuf.Timestamp.seconds)
    pub seconds: i64,
    ///  Non-negative fractions of a second at nanosecond resolution. Negative
    ///  second values with fractions must still have non-negative nanos values
    ///  that count forward in time. Must be from 0 to 999,999,999
    ///  inclusive.
    // @@protoc_insertion_point(field:google.protobuf.Timestamp.nanos)
    pub nanos: i32,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.Timestamp.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Timestamp {
    fn default() -> &'a Timestamp {
        <Timestamp as crate::Message>::default_instance()
    }
}

impl Timestamp {
    pub fn new() -> Timestamp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "seconds",
            |m: &Timestamp| { &m.seconds },
            |m: &mut Timestamp| { &mut m.seconds },
        ));
        fields.push(crate::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "nanos",
            |m: &Timestamp| { &m.nanos },
            |m: &mut Timestamp| { &mut m.nanos },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<Timestamp>(
            "Timestamp",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for Timestamp {
    const NAME: &'static str = "Timestamp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.seconds = is.read_int64()?;
                },
                16 => {
                    self.nanos = is.read_int32()?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.seconds != 0 {
            my_size += crate::rt::int64_size(1, self.seconds);
        }
        if self.nanos != 0 {
            my_size += crate::rt::int32_size(2, self.nanos);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if self.seconds != 0 {
            os.write_int64(1, self.seconds)?;
        }
        if self.nanos != 0 {
            os.write_int32(2, self.nanos)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Timestamp {
        Timestamp::new()
    }

    fn clear(&mut self) {
        self.seconds = 0;
        self.nanos = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Timestamp {
        static instance: Timestamp = Timestamp {
            seconds: 0,
            nanos: 0,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for Timestamp {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Timestamp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Timestamp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for Timestamp {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1fgoogle/protobuf/timestamp.proto\x12\x0fgoogle.protobuf\";\n\tTimes\
    tamp\x12\x18\n\x07seconds\x18\x01\x20\x01(\x03R\x07seconds\x12\x14\n\x05\
    nanos\x18\x02\x20\x01(\x05R\x05nanosB\x85\x01\n\x13com.google.protobufB\
    \x0eTimestampProtoP\x01Z2google.golang.org/protobuf/types/known/timestam\
    ppb\xf8\x01\x01\xa2\x02\x03GPB\xaa\x02\x1eGoogle.Protobuf.WellKnownTypes\
    J\xc5/\n\x07\x12\x05\x1e\0\x92\x01\x01\n\xcc\x0c\n\x01\x0c\x12\x03\x1e\0\
    \x122\xc1\x0c\x20Protocol\x20Buffers\x20-\x20Google's\x20data\x20interch\
    ange\x20format\n\x20Copyright\x202008\x20Google\x20Inc.\x20\x20All\x20ri\
    ghts\x20reserved.\n\x20https://developers.google.com/protocol-buffers/\n\
    \n\x20Redistribution\x20and\x20use\x20in\x20source\x20and\x20binary\x20f\
    orms,\x20with\x20or\x20without\n\x20modification,\x20are\x20permitted\
    \x20provided\x20that\x20the\x20following\x20conditions\x20are\n\x20met:\
    \n\n\x20\x20\x20\x20\x20*\x20Redistributions\x20of\x20source\x20code\x20\
    must\x20retain\x20the\x20above\x20copyright\n\x20notice,\x20this\x20list\
    \x20of\x20conditions\x20and\x20the\x20following\x20disclaimer.\n\x20\x20\
    \x20\x20\x20*\x20Redistributions\x20in\x20binary\x20form\x20must\x20repr\
    oduce\x20the\x20above\n\x20copyright\x20notice,\x20this\x20list\x20of\
    \x20conditions\x20and\x20the\x20following\x20disclaimer\n\x20in\x20the\
    \x20documentation\x20and/or\x20other\x20materials\x20provided\x20with\
    \x20the\n\x20distribution.\n\x20\x20\x20\x20\x20*\x20Neither\x20the\x20n\
    ame\x20of\x20Google\x20Inc.\x20nor\x20the\x20names\x20of\x20its\n\x20con\
    tributors\x20may\x20be\x20used\x20to\x20endorse\x20or\x20promote\x20prod\
    ucts\x20derived\x20from\n\x20this\x20software\x20without\x20specific\x20\
    prior\x20written\x20permission.\n\n\x20THIS\x20SOFTWARE\x20IS\x20PROVIDE\
    D\x20BY\x20THE\x20COPYRIGHT\x20HOLDERS\x20AND\x20CONTRIBUTORS\n\x20\"AS\
    \x20IS\"\x20AND\x20ANY\x20EXPRESS\x20OR\x20IMPLIED\x20WARRANTIES,\x20INC\
    LUDING,\x20BUT\x20NOT\n\x20LIMITED\x20TO,\x20THE\x20IMPLIED\x20WARRANTIE\
    S\x20OF\x20MERCHANTABILITY\x20AND\x20FITNESS\x20FOR\n\x20A\x20PARTICULAR\
    \x20PURPOSE\x20ARE\x20DISCLAIMED.\x20IN\x20NO\x20EVENT\x20SHALL\x20THE\
    \x20COPYRIGHT\n\x20OWNER\x20OR\x20CONTRIBUTORS\x20BE\x20LIABLE\x20FOR\
    \x20ANY\x20DIRECT,\x20INDIRECT,\x20INCIDENTAL,\n\x20SPECIAL,\x20EXEMPLAR\
    Y,\x20OR\x20CONSEQUENTIAL\x20DAMAGES\x20(INCLUDING,\x20BUT\x20NOT\n\x20L\
    IMITED\x20TO,\x20PROCUREMENT\x20OF\x20SUBSTITUTE\x20GOODS\x20OR\x20SERVI\
    CES;\x20LOSS\x20OF\x20USE,\n\x20DATA,\x20OR\x20PROFITS;\x20OR\x20BUSINES\
    S\x20INTERRUPTION)\x20HOWEVER\x20CAUSED\x20AND\x20ON\x20ANY\n\x20THEORY\
    \x20OF\x20LIABILITY,\x20WHETHER\x20IN\x20CONTRACT,\x20STRICT\x20LIABILIT\
    Y,\x20OR\x20TORT\n\x20(INCLUDING\x20NEGLIGENCE\x20OR\x20OTHERWISE)\x20AR\
    ISING\x20IN\x20ANY\x20WAY\x20OUT\x20OF\x20THE\x20USE\n\x20OF\x20THIS\x20\
    SOFTWARE,\x20EVEN\x20IF\x20ADVISED\x20OF\x20THE\x20POSSIBILITY\x20OF\x20\
    SUCH\x20DAMAGE.\n\n\x08\n\x01\x02\x12\x03\x20\0\x18\n\x08\n\x01\x08\x12\
    \x03\"\0;\n\t\n\x02\x08%\x12\x03\"\0;\n\x08\n\x01\x08\x12\x03#\0\x1f\n\t\
    \n\x02\x08\x1f\x12\x03#\0\x1f\n\x08\n\x01\x08\x12\x03$\0I\n\t\n\x02\x08\
    \x0b\x12\x03$\0I\n\x08\n\x01\x08\x12\x03%\0,\n\t\n\x02\x08\x01\x12\x03%\
    \0,\n\x08\n\x01\x08\x12\x03&\0/\n\t\n\x02\x08\x08\x12\x03&\0/\n\x08\n\
    \x01\x08\x12\x03'\0\"\n\t\n\x02\x08\n\x12\x03'\0\"\n\x08\n\x01\x08\x12\
    \x03(\0!\n\t\n\x02\x08$\x12\x03(\0!\n\xde\x1d\n\x02\x04\0\x12\x06\x87\
    \x01\0\x92\x01\x01\x1a\xcf\x1d\x20A\x20Timestamp\x20represents\x20a\x20p\
    oint\x20in\x20time\x20independent\x20of\x20any\x20time\x20zone\x20or\x20\
    local\n\x20calendar,\x20encoded\x20as\x20a\x20count\x20of\x20seconds\x20\
    and\x20fractions\x20of\x20seconds\x20at\n\x20nanosecond\x20resolution.\
    \x20The\x20count\x20is\x20relative\x20to\x20an\x20epoch\x20at\x20UTC\x20\
    midnight\x20on\n\x20January\x201,\x201970,\x20in\x20the\x20proleptic\x20\
    Gregorian\x20calendar\x20which\x20extends\x20the\n\x20Gregorian\x20calen\
    dar\x20backwards\x20to\x20year\x20one.\n\n\x20All\x20minutes\x20are\x206\
    0\x20seconds\x20long.\x20Leap\x20seconds\x20are\x20\"smeared\"\x20so\x20\
    that\x20no\x20leap\n\x20second\x20table\x20is\x20needed\x20for\x20interp\
    retation,\x20using\x20a\x20[24-hour\x20linear\n\x20smear](https://develo\
    pers.google.com/time/smear).\n\n\x20The\x20range\x20is\x20from\x200001-0\
    1-01T00:00:00Z\x20to\x209999-12-31T23:59:59.999999999Z.\x20By\n\x20restr\
    icting\x20to\x20that\x20range,\x20we\x20ensure\x20that\x20we\x20can\x20c\
    onvert\x20to\x20and\x20from\x20[RFC\n\x203339](https://www.ietf.org/rfc/\
    rfc3339.txt)\x20date\x20strings.\n\n\x20#\x20Examples\n\n\x20Example\x20\
    1:\x20Compute\x20Timestamp\x20from\x20POSIX\x20`time()`.\n\n\x20\x20\x20\
    \x20\x20Timestamp\x20timestamp;\n\x20\x20\x20\x20\x20timestamp.set_secon\
    ds(time(NULL));\n\x20\x20\x20\x20\x20timestamp.set_nanos(0);\n\n\x20Exam\
    ple\x202:\x20Compute\x20Timestamp\x20from\x20POSIX\x20`gettimeofday()`.\
    \n\n\x20\x20\x20\x20\x20struct\x20timeval\x20tv;\n\x20\x20\x20\x20\x20ge\
    ttimeofday(&tv,\x20NULL);\n\n\x20\x20\x20\x20\x20Timestamp\x20timestamp;\
    \n\x20\x20\x20\x20\x20timestamp.set_seconds(tv.tv_sec);\n\x20\x20\x20\
    \x20\x20timestamp.set_nanos(tv.tv_usec\x20*\x201000);\n\n\x20Example\x20\
    3:\x20Compute\x20Timestamp\x20from\x20Win32\x20`GetSystemTimeAsFileTime(\
    )`.\n\n\x20\x20\x20\x20\x20FILETIME\x20ft;\n\x20\x20\x20\x20\x20GetSyste\
    mTimeAsFileTime(&ft);\n\x20\x20\x20\x20\x20UINT64\x20ticks\x20=\x20(((UI\
    NT64)ft.dwHighDateTime)\x20<<\x2032)\x20|\x20ft.dwLowDateTime;\n\n\x20\
    \x20\x20\x20\x20//\x20A\x20Windows\x20tick\x20is\x20100\x20nanoseconds.\
    \x20Windows\x20epoch\x201601-01-01T00:00:00Z\n\x20\x20\x20\x20\x20//\x20\
    is\x2011644473600\x20seconds\x20before\x20Unix\x20epoch\x201970-01-01T00\
    :00:00Z.\n\x20\x20\x20\x20\x20Timestamp\x20timestamp;\n\x20\x20\x20\x20\
    \x20timestamp.set_seconds((INT64)\x20((ticks\x20/\x2010000000)\x20-\x201\
    1644473600LL));\n\x20\x20\x20\x20\x20timestamp.set_nanos((INT32)\x20((ti\
    cks\x20%\x2010000000)\x20*\x20100));\n\n\x20Example\x204:\x20Compute\x20\
    Timestamp\x20from\x20Java\x20`System.currentTimeMillis()`.\n\n\x20\x20\
    \x20\x20\x20long\x20millis\x20=\x20System.currentTimeMillis();\n\n\x20\
    \x20\x20\x20\x20Timestamp\x20timestamp\x20=\x20Timestamp.newBuilder().se\
    tSeconds(millis\x20/\x201000)\n\x20\x20\x20\x20\x20\x20\x20\x20\x20.setN\
    anos((int)\x20((millis\x20%\x201000)\x20*\x201000000)).build();\n\n\n\
    \x20Example\x205:\x20Compute\x20Timestamp\x20from\x20Java\x20`Instant.no\
    w()`.\n\n\x20\x20\x20\x20\x20Instant\x20now\x20=\x20Instant.now();\n\n\
    \x20\x20\x20\x20\x20Timestamp\x20timestamp\x20=\n\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20Timestamp.newBuilder().setSeconds(now.getEpochSecond())\
    \n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20.setNanos(now.getN\
    ano()).build();\n\n\n\x20Example\x206:\x20Compute\x20Timestamp\x20from\
    \x20current\x20time\x20in\x20Python.\n\n\x20\x20\x20\x20\x20timestamp\
    \x20=\x20Timestamp()\n\x20\x20\x20\x20\x20timestamp.GetCurrentTime()\n\n\
    \x20#\x20JSON\x20Mapping\n\n\x20In\x20JSON\x20format,\x20the\x20Timestam\
    p\x20type\x20is\x20encoded\x20as\x20a\x20string\x20in\x20the\n\x20[RFC\
    \x203339](https://www.ietf.org/rfc/rfc3339.txt)\x20format.\x20That\x20is\
    ,\x20the\n\x20format\x20is\x20\"{year}-{month}-{day}T{hour}:{min}:{sec}[\
    .{frac_sec}]Z\"\n\x20where\x20{year}\x20is\x20always\x20expressed\x20usi\
    ng\x20four\x20digits\x20while\x20{month},\x20{day},\n\x20{hour},\x20{min\
    },\x20and\x20{sec}\x20are\x20zero-padded\x20to\x20two\x20digits\x20each.\
    \x20The\x20fractional\n\x20seconds,\x20which\x20can\x20go\x20up\x20to\
    \x209\x20digits\x20(i.e.\x20up\x20to\x201\x20nanosecond\x20resolution),\
    \n\x20are\x20optional.\x20The\x20\"Z\"\x20suffix\x20indicates\x20the\x20\
    timezone\x20(\"UTC\");\x20the\x20timezone\n\x20is\x20required.\x20A\x20p\
    roto3\x20JSON\x20serializer\x20should\x20always\x20use\x20UTC\x20(as\x20\
    indicated\x20by\n\x20\"Z\")\x20when\x20printing\x20the\x20Timestamp\x20t\
    ype\x20and\x20a\x20proto3\x20JSON\x20parser\x20should\x20be\n\x20able\
    \x20to\x20accept\x20both\x20UTC\x20and\x20other\x20timezones\x20(as\x20i\
    ndicated\x20by\x20an\x20offset).\n\n\x20For\x20example,\x20\"2017-01-15T\
    01:30:15.01Z\"\x20encodes\x2015.01\x20seconds\x20past\n\x2001:30\x20UTC\
    \x20on\x20January\x2015,\x202017.\n\n\x20In\x20JavaScript,\x20one\x20can\
    \x20convert\x20a\x20Date\x20object\x20to\x20this\x20format\x20using\x20t\
    he\n\x20standard\n\x20[toISOString()](https://developer.mozilla.org/en-U\
    S/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString)\n\x20me\
    thod.\x20In\x20Python,\x20a\x20standard\x20`datetime.datetime`\x20object\
    \x20can\x20be\x20converted\n\x20to\x20this\x20format\x20using\n\x20[`str\
    ftime`](https://docs.python.org/2/library/time.html#time.strftime)\x20wi\
    th\n\x20the\x20time\x20format\x20spec\x20'%Y-%m-%dT%H:%M:%S.%fZ'.\x20Lik\
    ewise,\x20in\x20Java,\x20one\x20can\x20use\n\x20the\x20Joda\x20Time's\
    \x20[`ISODateTimeFormat.dateTime()`](\n\x20http://www.joda.org/joda-time\
    /apidocs/org/joda/time/format/ISODateTimeFormat.html#dateTime%2D%2D\n\
    \x20)\x20to\x20obtain\x20a\x20formatter\x20capable\x20of\x20generating\
    \x20timestamps\x20in\x20this\x20format.\n\n\n\n\x0b\n\x03\x04\0\x01\x12\
    \x04\x87\x01\x08\x11\n\x9d\x01\n\x04\x04\0\x02\0\x12\x04\x8b\x01\x02\x14\
    \x1a\x8e\x01\x20Represents\x20seconds\x20of\x20UTC\x20time\x20since\x20U\
    nix\x20epoch\n\x201970-01-01T00:00:00Z.\x20Must\x20be\x20from\x200001-01\
    -01T00:00:00Z\x20to\n\x209999-12-31T23:59:59Z\x20inclusive.\n\n\r\n\x05\
    \x04\0\x02\0\x05\x12\x04\x8b\x01\x02\x07\n\r\n\x05\x04\0\x02\0\x01\x12\
    \x04\x8b\x01\x08\x0f\n\r\n\x05\x04\0\x02\0\x03\x12\x04\x8b\x01\x12\x13\n\
    \xe5\x01\n\x04\x04\0\x02\x01\x12\x04\x91\x01\x02\x12\x1a\xd6\x01\x20Non-\
    negative\x20fractions\x20of\x20a\x20second\x20at\x20nanosecond\x20resolu\
    tion.\x20Negative\n\x20second\x20values\x20with\x20fractions\x20must\x20\
    still\x20have\x20non-negative\x20nanos\x20values\n\x20that\x20count\x20f\
    orward\x20in\x20time.\x20Must\x20be\x20from\x200\x20to\x20999,999,999\n\
    \x20inclusive.\n\n\r\n\x05\x04\0\x02\x01\x05\x12\x04\x91\x01\x02\x07\n\r\
    \n\x05\x04\0\x02\x01\x01\x12\x04\x91\x01\x08\r\n\r\n\x05\x04\0\x02\x01\
    \x03\x12\x04\x91\x01\x10\x11b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static crate::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: crate::rt::Lazy<crate::descriptor::FileDescriptorProto> = crate::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        crate::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static crate::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: crate::rt::Lazy<crate::reflect::GeneratedFileDescriptor> = crate::rt::Lazy::new();
    static file_descriptor: crate::rt::Lazy<crate::reflect::FileDescriptor> = crate::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(1);
            messages.push(Timestamp::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            crate::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        crate::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}

'''
'''--- protobuf/src/well_known_types/type_.rs ---
// This file is generated by rust-protobuf 4.0.0-alpha.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `google/protobuf/type.proto`

///  A protocol buffer message type.
// @@protoc_insertion_point(message:google.protobuf.Type)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Type {
    // message fields
    ///  The fully qualified message name.
    // @@protoc_insertion_point(field:google.protobuf.Type.name)
    pub name: ::std::string::String,
    ///  The list of fields.
    // @@protoc_insertion_point(field:google.protobuf.Type.fields)
    pub fields: ::std::vec::Vec<Field>,
    ///  The list of types appearing in `oneof` definitions in this type.
    // @@protoc_insertion_point(field:google.protobuf.Type.oneofs)
    pub oneofs: ::std::vec::Vec<::std::string::String>,
    ///  The protocol buffer options.
    // @@protoc_insertion_point(field:google.protobuf.Type.options)
    pub options: ::std::vec::Vec<Option>,
    ///  The source context.
    // @@protoc_insertion_point(field:google.protobuf.Type.source_context)
    pub source_context: crate::MessageField<crate::well_known_types::source_context::SourceContext>,
    ///  The source syntax.
    // @@protoc_insertion_point(field:google.protobuf.Type.syntax)
    pub syntax: crate::EnumOrUnknown<Syntax>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.Type.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Type {
    fn default() -> &'a Type {
        <Type as crate::Message>::default_instance()
    }
}

impl Type {
    pub fn new() -> Type {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &Type| { &m.name },
            |m: &mut Type| { &mut m.name },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "fields",
            |m: &Type| { &m.fields },
            |m: &mut Type| { &mut m.fields },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "oneofs",
            |m: &Type| { &m.oneofs },
            |m: &mut Type| { &mut m.oneofs },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "options",
            |m: &Type| { &m.options },
            |m: &mut Type| { &mut m.options },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, crate::well_known_types::source_context::SourceContext>(
            "source_context",
            |m: &Type| { &m.source_context },
            |m: &mut Type| { &mut m.source_context },
        ));
        fields.push(crate::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "syntax",
            |m: &Type| { &m.syntax },
            |m: &mut Type| { &mut m.syntax },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<Type>(
            "Type",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for Type {
    const NAME: &'static str = "Type";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                18 => {
                    self.fields.push(is.read_message()?);
                },
                26 => {
                    self.oneofs.push(is.read_string()?);
                },
                34 => {
                    self.options.push(is.read_message()?);
                },
                42 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.source_context)?;
                },
                48 => {
                    self.syntax = is.read_enum_or_unknown()?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += crate::rt::string_size(1, &self.name);
        }
        for value in &self.fields {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.oneofs {
            my_size += crate::rt::string_size(3, &value);
        };
        for value in &self.options {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.source_context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if self.syntax != crate::EnumOrUnknown::new(Syntax::SYNTAX_PROTO2) {
            my_size += crate::rt::int32_size(6, self.syntax.value());
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        for v in &self.fields {
            crate::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.oneofs {
            os.write_string(3, &v)?;
        };
        for v in &self.options {
            crate::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.source_context.as_ref() {
            crate::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if self.syntax != crate::EnumOrUnknown::new(Syntax::SYNTAX_PROTO2) {
            os.write_enum(6, crate::EnumOrUnknown::value(&self.syntax))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Type {
        Type::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.fields.clear();
        self.oneofs.clear();
        self.options.clear();
        self.source_context.clear();
        self.syntax = crate::EnumOrUnknown::new(Syntax::SYNTAX_PROTO2);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Type {
        static instance: Type = Type {
            name: ::std::string::String::new(),
            fields: ::std::vec::Vec::new(),
            oneofs: ::std::vec::Vec::new(),
            options: ::std::vec::Vec::new(),
            source_context: crate::MessageField::none(),
            syntax: crate::EnumOrUnknown::from_i32(0),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for Type {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Type").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Type {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for Type {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

///  A single field of a message type.
// @@protoc_insertion_point(message:google.protobuf.Field)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Field {
    // message fields
    ///  The field type.
    // @@protoc_insertion_point(field:google.protobuf.Field.kind)
    pub kind: crate::EnumOrUnknown<field::Kind>,
    ///  The field cardinality.
    // @@protoc_insertion_point(field:google.protobuf.Field.cardinality)
    pub cardinality: crate::EnumOrUnknown<field::Cardinality>,
    ///  The field number.
    // @@protoc_insertion_point(field:google.protobuf.Field.number)
    pub number: i32,
    ///  The field name.
    // @@protoc_insertion_point(field:google.protobuf.Field.name)
    pub name: ::std::string::String,
    ///  The field type URL, without the scheme, for message or enumeration
    ///  types. Example: `"type.googleapis.com/google.protobuf.Timestamp"`.
    // @@protoc_insertion_point(field:google.protobuf.Field.type_url)
    pub type_url: ::std::string::String,
    ///  The index of the field type in `Type.oneofs`, for message or enumeration
    ///  types. The first type has index 1; zero means the type is not in the list.
    // @@protoc_insertion_point(field:google.protobuf.Field.oneof_index)
    pub oneof_index: i32,
    ///  Whether to use alternative packed wire representation.
    // @@protoc_insertion_point(field:google.protobuf.Field.packed)
    pub packed: bool,
    ///  The protocol buffer options.
    // @@protoc_insertion_point(field:google.protobuf.Field.options)
    pub options: ::std::vec::Vec<Option>,
    ///  The field JSON name.
    // @@protoc_insertion_point(field:google.protobuf.Field.json_name)
    pub json_name: ::std::string::String,
    ///  The string value of the default value of this field. Proto2 syntax only.
    // @@protoc_insertion_point(field:google.protobuf.Field.default_value)
    pub default_value: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.Field.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Field {
    fn default() -> &'a Field {
        <Field as crate::Message>::default_instance()
    }
}

impl Field {
    pub fn new() -> Field {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "kind",
            |m: &Field| { &m.kind },
            |m: &mut Field| { &mut m.kind },
        ));
        fields.push(crate::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cardinality",
            |m: &Field| { &m.cardinality },
            |m: &mut Field| { &mut m.cardinality },
        ));
        fields.push(crate::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "number",
            |m: &Field| { &m.number },
            |m: &mut Field| { &mut m.number },
        ));
        fields.push(crate::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &Field| { &m.name },
            |m: &mut Field| { &mut m.name },
        ));
        fields.push(crate::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type_url",
            |m: &Field| { &m.type_url },
            |m: &mut Field| { &mut m.type_url },
        ));
        fields.push(crate::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "oneof_index",
            |m: &Field| { &m.oneof_index },
            |m: &mut Field| { &mut m.oneof_index },
        ));
        fields.push(crate::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "packed",
            |m: &Field| { &m.packed },
            |m: &mut Field| { &mut m.packed },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "options",
            |m: &Field| { &m.options },
            |m: &mut Field| { &mut m.options },
        ));
        fields.push(crate::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "json_name",
            |m: &Field| { &m.json_name },
            |m: &mut Field| { &mut m.json_name },
        ));
        fields.push(crate::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "default_value",
            |m: &Field| { &m.default_value },
            |m: &mut Field| { &mut m.default_value },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<Field>(
            "Field",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for Field {
    const NAME: &'static str = "Field";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.kind = is.read_enum_or_unknown()?;
                },
                16 => {
                    self.cardinality = is.read_enum_or_unknown()?;
                },
                24 => {
                    self.number = is.read_int32()?;
                },
                34 => {
                    self.name = is.read_string()?;
                },
                50 => {
                    self.type_url = is.read_string()?;
                },
                56 => {
                    self.oneof_index = is.read_int32()?;
                },
                64 => {
                    self.packed = is.read_bool()?;
                },
                74 => {
                    self.options.push(is.read_message()?);
                },
                82 => {
                    self.json_name = is.read_string()?;
                },
                90 => {
                    self.default_value = is.read_string()?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.kind != crate::EnumOrUnknown::new(field::Kind::TYPE_UNKNOWN) {
            my_size += crate::rt::int32_size(1, self.kind.value());
        }
        if self.cardinality != crate::EnumOrUnknown::new(field::Cardinality::CARDINALITY_UNKNOWN) {
            my_size += crate::rt::int32_size(2, self.cardinality.value());
        }
        if self.number != 0 {
            my_size += crate::rt::int32_size(3, self.number);
        }
        if !self.name.is_empty() {
            my_size += crate::rt::string_size(4, &self.name);
        }
        if !self.type_url.is_empty() {
            my_size += crate::rt::string_size(6, &self.type_url);
        }
        if self.oneof_index != 0 {
            my_size += crate::rt::int32_size(7, self.oneof_index);
        }
        if self.packed != false {
            my_size += 1 + 1;
        }
        for value in &self.options {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.json_name.is_empty() {
            my_size += crate::rt::string_size(10, &self.json_name);
        }
        if !self.default_value.is_empty() {
            my_size += crate::rt::string_size(11, &self.default_value);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if self.kind != crate::EnumOrUnknown::new(field::Kind::TYPE_UNKNOWN) {
            os.write_enum(1, crate::EnumOrUnknown::value(&self.kind))?;
        }
        if self.cardinality != crate::EnumOrUnknown::new(field::Cardinality::CARDINALITY_UNKNOWN) {
            os.write_enum(2, crate::EnumOrUnknown::value(&self.cardinality))?;
        }
        if self.number != 0 {
            os.write_int32(3, self.number)?;
        }
        if !self.name.is_empty() {
            os.write_string(4, &self.name)?;
        }
        if !self.type_url.is_empty() {
            os.write_string(6, &self.type_url)?;
        }
        if self.oneof_index != 0 {
            os.write_int32(7, self.oneof_index)?;
        }
        if self.packed != false {
            os.write_bool(8, self.packed)?;
        }
        for v in &self.options {
            crate::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        if !self.json_name.is_empty() {
            os.write_string(10, &self.json_name)?;
        }
        if !self.default_value.is_empty() {
            os.write_string(11, &self.default_value)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Field {
        Field::new()
    }

    fn clear(&mut self) {
        self.kind = crate::EnumOrUnknown::new(field::Kind::TYPE_UNKNOWN);
        self.cardinality = crate::EnumOrUnknown::new(field::Cardinality::CARDINALITY_UNKNOWN);
        self.number = 0;
        self.name.clear();
        self.type_url.clear();
        self.oneof_index = 0;
        self.packed = false;
        self.options.clear();
        self.json_name.clear();
        self.default_value.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Field {
        static instance: Field = Field {
            kind: crate::EnumOrUnknown::from_i32(0),
            cardinality: crate::EnumOrUnknown::from_i32(0),
            number: 0,
            name: ::std::string::String::new(),
            type_url: ::std::string::String::new(),
            oneof_index: 0,
            packed: false,
            options: ::std::vec::Vec::new(),
            json_name: ::std::string::String::new(),
            default_value: ::std::string::String::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for Field {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Field").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Field {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for Field {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Field`
pub mod field {
    ///  Basic field types.
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:google.protobuf.Field.Kind)
    pub enum Kind {
        // @@protoc_insertion_point(enum_value:google.protobuf.Field.Kind.TYPE_UNKNOWN)
        TYPE_UNKNOWN = 0,
        // @@protoc_insertion_point(enum_value:google.protobuf.Field.Kind.TYPE_DOUBLE)
        TYPE_DOUBLE = 1,
        // @@protoc_insertion_point(enum_value:google.protobuf.Field.Kind.TYPE_FLOAT)
        TYPE_FLOAT = 2,
        // @@protoc_insertion_point(enum_value:google.protobuf.Field.Kind.TYPE_INT64)
        TYPE_INT64 = 3,
        // @@protoc_insertion_point(enum_value:google.protobuf.Field.Kind.TYPE_UINT64)
        TYPE_UINT64 = 4,
        // @@protoc_insertion_point(enum_value:google.protobuf.Field.Kind.TYPE_INT32)
        TYPE_INT32 = 5,
        // @@protoc_insertion_point(enum_value:google.protobuf.Field.Kind.TYPE_FIXED64)
        TYPE_FIXED64 = 6,
        // @@protoc_insertion_point(enum_value:google.protobuf.Field.Kind.TYPE_FIXED32)
        TYPE_FIXED32 = 7,
        // @@protoc_insertion_point(enum_value:google.protobuf.Field.Kind.TYPE_BOOL)
        TYPE_BOOL = 8,
        // @@protoc_insertion_point(enum_value:google.protobuf.Field.Kind.TYPE_STRING)
        TYPE_STRING = 9,
        // @@protoc_insertion_point(enum_value:google.protobuf.Field.Kind.TYPE_GROUP)
        TYPE_GROUP = 10,
        // @@protoc_insertion_point(enum_value:google.protobuf.Field.Kind.TYPE_MESSAGE)
        TYPE_MESSAGE = 11,
        // @@protoc_insertion_point(enum_value:google.protobuf.Field.Kind.TYPE_BYTES)
        TYPE_BYTES = 12,
        // @@protoc_insertion_point(enum_value:google.protobuf.Field.Kind.TYPE_UINT32)
        TYPE_UINT32 = 13,
        // @@protoc_insertion_point(enum_value:google.protobuf.Field.Kind.TYPE_ENUM)
        TYPE_ENUM = 14,
        // @@protoc_insertion_point(enum_value:google.protobuf.Field.Kind.TYPE_SFIXED32)
        TYPE_SFIXED32 = 15,
        // @@protoc_insertion_point(enum_value:google.protobuf.Field.Kind.TYPE_SFIXED64)
        TYPE_SFIXED64 = 16,
        // @@protoc_insertion_point(enum_value:google.protobuf.Field.Kind.TYPE_SINT32)
        TYPE_SINT32 = 17,
        // @@protoc_insertion_point(enum_value:google.protobuf.Field.Kind.TYPE_SINT64)
        TYPE_SINT64 = 18,
    }

    impl crate::Enum for Kind {
        const NAME: &'static str = "Kind";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Kind> {
            match value {
                0 => ::std::option::Option::Some(Kind::TYPE_UNKNOWN),
                1 => ::std::option::Option::Some(Kind::TYPE_DOUBLE),
                2 => ::std::option::Option::Some(Kind::TYPE_FLOAT),
                3 => ::std::option::Option::Some(Kind::TYPE_INT64),
                4 => ::std::option::Option::Some(Kind::TYPE_UINT64),
                5 => ::std::option::Option::Some(Kind::TYPE_INT32),
                6 => ::std::option::Option::Some(Kind::TYPE_FIXED64),
                7 => ::std::option::Option::Some(Kind::TYPE_FIXED32),
                8 => ::std::option::Option::Some(Kind::TYPE_BOOL),
                9 => ::std::option::Option::Some(Kind::TYPE_STRING),
                10 => ::std::option::Option::Some(Kind::TYPE_GROUP),
                11 => ::std::option::Option::Some(Kind::TYPE_MESSAGE),
                12 => ::std::option::Option::Some(Kind::TYPE_BYTES),
                13 => ::std::option::Option::Some(Kind::TYPE_UINT32),
                14 => ::std::option::Option::Some(Kind::TYPE_ENUM),
                15 => ::std::option::Option::Some(Kind::TYPE_SFIXED32),
                16 => ::std::option::Option::Some(Kind::TYPE_SFIXED64),
                17 => ::std::option::Option::Some(Kind::TYPE_SINT32),
                18 => ::std::option::Option::Some(Kind::TYPE_SINT64),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Kind> {
            match str {
                "TYPE_UNKNOWN" => ::std::option::Option::Some(Kind::TYPE_UNKNOWN),
                "TYPE_DOUBLE" => ::std::option::Option::Some(Kind::TYPE_DOUBLE),
                "TYPE_FLOAT" => ::std::option::Option::Some(Kind::TYPE_FLOAT),
                "TYPE_INT64" => ::std::option::Option::Some(Kind::TYPE_INT64),
                "TYPE_UINT64" => ::std::option::Option::Some(Kind::TYPE_UINT64),
                "TYPE_INT32" => ::std::option::Option::Some(Kind::TYPE_INT32),
                "TYPE_FIXED64" => ::std::option::Option::Some(Kind::TYPE_FIXED64),
                "TYPE_FIXED32" => ::std::option::Option::Some(Kind::TYPE_FIXED32),
                "TYPE_BOOL" => ::std::option::Option::Some(Kind::TYPE_BOOL),
                "TYPE_STRING" => ::std::option::Option::Some(Kind::TYPE_STRING),
                "TYPE_GROUP" => ::std::option::Option::Some(Kind::TYPE_GROUP),
                "TYPE_MESSAGE" => ::std::option::Option::Some(Kind::TYPE_MESSAGE),
                "TYPE_BYTES" => ::std::option::Option::Some(Kind::TYPE_BYTES),
                "TYPE_UINT32" => ::std::option::Option::Some(Kind::TYPE_UINT32),
                "TYPE_ENUM" => ::std::option::Option::Some(Kind::TYPE_ENUM),
                "TYPE_SFIXED32" => ::std::option::Option::Some(Kind::TYPE_SFIXED32),
                "TYPE_SFIXED64" => ::std::option::Option::Some(Kind::TYPE_SFIXED64),
                "TYPE_SINT32" => ::std::option::Option::Some(Kind::TYPE_SINT32),
                "TYPE_SINT64" => ::std::option::Option::Some(Kind::TYPE_SINT64),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Kind] = &[
            Kind::TYPE_UNKNOWN,
            Kind::TYPE_DOUBLE,
            Kind::TYPE_FLOAT,
            Kind::TYPE_INT64,
            Kind::TYPE_UINT64,
            Kind::TYPE_INT32,
            Kind::TYPE_FIXED64,
            Kind::TYPE_FIXED32,
            Kind::TYPE_BOOL,
            Kind::TYPE_STRING,
            Kind::TYPE_GROUP,
            Kind::TYPE_MESSAGE,
            Kind::TYPE_BYTES,
            Kind::TYPE_UINT32,
            Kind::TYPE_ENUM,
            Kind::TYPE_SFIXED32,
            Kind::TYPE_SFIXED64,
            Kind::TYPE_SINT32,
            Kind::TYPE_SINT64,
        ];
    }

    impl crate::EnumFull for Kind {
        fn enum_descriptor() -> crate::reflect::EnumDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("Field.Kind").unwrap()).clone()
        }

        fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Kind {
        fn default() -> Self {
            Kind::TYPE_UNKNOWN
        }
    }

    impl Kind {
        pub(in super) fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
            crate::reflect::GeneratedEnumDescriptorData::new::<Kind>("Field.Kind")
        }
    }

    ///  Whether a field is optional, required, or repeated.
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:google.protobuf.Field.Cardinality)
    pub enum Cardinality {
        // @@protoc_insertion_point(enum_value:google.protobuf.Field.Cardinality.CARDINALITY_UNKNOWN)
        CARDINALITY_UNKNOWN = 0,
        // @@protoc_insertion_point(enum_value:google.protobuf.Field.Cardinality.CARDINALITY_OPTIONAL)
        CARDINALITY_OPTIONAL = 1,
        // @@protoc_insertion_point(enum_value:google.protobuf.Field.Cardinality.CARDINALITY_REQUIRED)
        CARDINALITY_REQUIRED = 2,
        // @@protoc_insertion_point(enum_value:google.protobuf.Field.Cardinality.CARDINALITY_REPEATED)
        CARDINALITY_REPEATED = 3,
    }

    impl crate::Enum for Cardinality {
        const NAME: &'static str = "Cardinality";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Cardinality> {
            match value {
                0 => ::std::option::Option::Some(Cardinality::CARDINALITY_UNKNOWN),
                1 => ::std::option::Option::Some(Cardinality::CARDINALITY_OPTIONAL),
                2 => ::std::option::Option::Some(Cardinality::CARDINALITY_REQUIRED),
                3 => ::std::option::Option::Some(Cardinality::CARDINALITY_REPEATED),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Cardinality> {
            match str {
                "CARDINALITY_UNKNOWN" => ::std::option::Option::Some(Cardinality::CARDINALITY_UNKNOWN),
                "CARDINALITY_OPTIONAL" => ::std::option::Option::Some(Cardinality::CARDINALITY_OPTIONAL),
                "CARDINALITY_REQUIRED" => ::std::option::Option::Some(Cardinality::CARDINALITY_REQUIRED),
                "CARDINALITY_REPEATED" => ::std::option::Option::Some(Cardinality::CARDINALITY_REPEATED),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Cardinality] = &[
            Cardinality::CARDINALITY_UNKNOWN,
            Cardinality::CARDINALITY_OPTIONAL,
            Cardinality::CARDINALITY_REQUIRED,
            Cardinality::CARDINALITY_REPEATED,
        ];
    }

    impl crate::EnumFull for Cardinality {
        fn enum_descriptor() -> crate::reflect::EnumDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("Field.Cardinality").unwrap()).clone()
        }

        fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Cardinality {
        fn default() -> Self {
            Cardinality::CARDINALITY_UNKNOWN
        }
    }

    impl Cardinality {
        pub(in super) fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
            crate::reflect::GeneratedEnumDescriptorData::new::<Cardinality>("Field.Cardinality")
        }
    }
}

///  Enum type definition.
// @@protoc_insertion_point(message:google.protobuf.Enum)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Enum {
    // message fields
    ///  Enum type name.
    // @@protoc_insertion_point(field:google.protobuf.Enum.name)
    pub name: ::std::string::String,
    ///  Enum value definitions.
    // @@protoc_insertion_point(field:google.protobuf.Enum.enumvalue)
    pub enumvalue: ::std::vec::Vec<EnumValue>,
    ///  Protocol buffer options.
    // @@protoc_insertion_point(field:google.protobuf.Enum.options)
    pub options: ::std::vec::Vec<Option>,
    ///  The source context.
    // @@protoc_insertion_point(field:google.protobuf.Enum.source_context)
    pub source_context: crate::MessageField<crate::well_known_types::source_context::SourceContext>,
    ///  The source syntax.
    // @@protoc_insertion_point(field:google.protobuf.Enum.syntax)
    pub syntax: crate::EnumOrUnknown<Syntax>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.Enum.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Enum {
    fn default() -> &'a Enum {
        <Enum as crate::Message>::default_instance()
    }
}

impl Enum {
    pub fn new() -> Enum {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &Enum| { &m.name },
            |m: &mut Enum| { &mut m.name },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "enumvalue",
            |m: &Enum| { &m.enumvalue },
            |m: &mut Enum| { &mut m.enumvalue },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "options",
            |m: &Enum| { &m.options },
            |m: &mut Enum| { &mut m.options },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, crate::well_known_types::source_context::SourceContext>(
            "source_context",
            |m: &Enum| { &m.source_context },
            |m: &mut Enum| { &mut m.source_context },
        ));
        fields.push(crate::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "syntax",
            |m: &Enum| { &m.syntax },
            |m: &mut Enum| { &mut m.syntax },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<Enum>(
            "Enum",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for Enum {
    const NAME: &'static str = "Enum";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                18 => {
                    self.enumvalue.push(is.read_message()?);
                },
                26 => {
                    self.options.push(is.read_message()?);
                },
                34 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.source_context)?;
                },
                40 => {
                    self.syntax = is.read_enum_or_unknown()?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += crate::rt::string_size(1, &self.name);
        }
        for value in &self.enumvalue {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.options {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.source_context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if self.syntax != crate::EnumOrUnknown::new(Syntax::SYNTAX_PROTO2) {
            my_size += crate::rt::int32_size(5, self.syntax.value());
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        for v in &self.enumvalue {
            crate::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.options {
            crate::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.source_context.as_ref() {
            crate::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if self.syntax != crate::EnumOrUnknown::new(Syntax::SYNTAX_PROTO2) {
            os.write_enum(5, crate::EnumOrUnknown::value(&self.syntax))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Enum {
        Enum::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.enumvalue.clear();
        self.options.clear();
        self.source_context.clear();
        self.syntax = crate::EnumOrUnknown::new(Syntax::SYNTAX_PROTO2);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Enum {
        static instance: Enum = Enum {
            name: ::std::string::String::new(),
            enumvalue: ::std::vec::Vec::new(),
            options: ::std::vec::Vec::new(),
            source_context: crate::MessageField::none(),
            syntax: crate::EnumOrUnknown::from_i32(0),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for Enum {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Enum").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Enum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for Enum {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Enum value definition.
// @@protoc_insertion_point(message:google.protobuf.EnumValue)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct EnumValue {
    // message fields
    ///  Enum value name.
    // @@protoc_insertion_point(field:google.protobuf.EnumValue.name)
    pub name: ::std::string::String,
    ///  Enum value number.
    // @@protoc_insertion_point(field:google.protobuf.EnumValue.number)
    pub number: i32,
    ///  Protocol buffer options.
    // @@protoc_insertion_point(field:google.protobuf.EnumValue.options)
    pub options: ::std::vec::Vec<Option>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.EnumValue.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EnumValue {
    fn default() -> &'a EnumValue {
        <EnumValue as crate::Message>::default_instance()
    }
}

impl EnumValue {
    pub fn new() -> EnumValue {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &EnumValue| { &m.name },
            |m: &mut EnumValue| { &mut m.name },
        ));
        fields.push(crate::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "number",
            |m: &EnumValue| { &m.number },
            |m: &mut EnumValue| { &mut m.number },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "options",
            |m: &EnumValue| { &m.options },
            |m: &mut EnumValue| { &mut m.options },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<EnumValue>(
            "EnumValue",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for EnumValue {
    const NAME: &'static str = "EnumValue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                16 => {
                    self.number = is.read_int32()?;
                },
                26 => {
                    self.options.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += crate::rt::string_size(1, &self.name);
        }
        if self.number != 0 {
            my_size += crate::rt::int32_size(2, self.number);
        }
        for value in &self.options {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if self.number != 0 {
            os.write_int32(2, self.number)?;
        }
        for v in &self.options {
            crate::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EnumValue {
        EnumValue::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.number = 0;
        self.options.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EnumValue {
        static instance: EnumValue = EnumValue {
            name: ::std::string::String::new(),
            number: 0,
            options: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for EnumValue {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EnumValue").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EnumValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for EnumValue {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

///  A protocol buffer option, which can be attached to a message, field,
///  enumeration, etc.
// @@protoc_insertion_point(message:google.protobuf.Option)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Option {
    // message fields
    ///  The option's name. For protobuf built-in options (options defined in
    ///  descriptor.proto), this is the short name. For example, `"map_entry"`.
    ///  For custom options, it should be the fully-qualified name. For example,
    ///  `"google.api.http"`.
    // @@protoc_insertion_point(field:google.protobuf.Option.name)
    pub name: ::std::string::String,
    ///  The option's value packed in an Any message. If the value is a primitive,
    ///  the corresponding wrapper type defined in google/protobuf/wrappers.proto
    ///  should be used. If the value is an enum, it should be stored as an int32
    ///  value using the google.protobuf.Int32Value type.
    // @@protoc_insertion_point(field:google.protobuf.Option.value)
    pub value: crate::MessageField<crate::well_known_types::any::Any>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.Option.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Option {
    fn default() -> &'a Option {
        <Option as crate::Message>::default_instance()
    }
}

impl Option {
    pub fn new() -> Option {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &Option| { &m.name },
            |m: &mut Option| { &mut m.name },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, crate::well_known_types::any::Any>(
            "value",
            |m: &Option| { &m.value },
            |m: &mut Option| { &mut m.value },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<Option>(
            "Option",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for Option {
    const NAME: &'static str = "Option";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                18 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.value)?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += crate::rt::string_size(1, &self.name);
        }
        if let Some(v) = self.value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if let Some(v) = self.value.as_ref() {
            crate::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Option {
        Option::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.value.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Option {
        static instance: Option = Option {
            name: ::std::string::String::new(),
            value: crate::MessageField::none(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for Option {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Option").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Option {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for Option {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

///  The syntax in which a protocol buffer element is defined.
#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:google.protobuf.Syntax)
pub enum Syntax {
    // @@protoc_insertion_point(enum_value:google.protobuf.Syntax.SYNTAX_PROTO2)
    SYNTAX_PROTO2 = 0,
    // @@protoc_insertion_point(enum_value:google.protobuf.Syntax.SYNTAX_PROTO3)
    SYNTAX_PROTO3 = 1,
}

impl crate::Enum for Syntax {
    const NAME: &'static str = "Syntax";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Syntax> {
        match value {
            0 => ::std::option::Option::Some(Syntax::SYNTAX_PROTO2),
            1 => ::std::option::Option::Some(Syntax::SYNTAX_PROTO3),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<Syntax> {
        match str {
            "SYNTAX_PROTO2" => ::std::option::Option::Some(Syntax::SYNTAX_PROTO2),
            "SYNTAX_PROTO3" => ::std::option::Option::Some(Syntax::SYNTAX_PROTO3),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [Syntax] = &[
        Syntax::SYNTAX_PROTO2,
        Syntax::SYNTAX_PROTO3,
    ];
}

impl crate::EnumFull for Syntax {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("Syntax").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for Syntax {
    fn default() -> Self {
        Syntax::SYNTAX_PROTO2
    }
}

impl Syntax {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<Syntax>("Syntax")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1agoogle/protobuf/type.proto\x12\x0fgoogle.protobuf\x1a\x19google/pr\
    otobuf/any.proto\x1a$google/protobuf/source_context.proto\"\x8d\x02\n\
    \x04Type\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12.\n\x06fields\
    \x18\x02\x20\x03(\x0b2\x16.google.protobuf.FieldR\x06fields\x12\x16\n\
    \x06oneofs\x18\x03\x20\x03(\tR\x06oneofs\x121\n\x07options\x18\x04\x20\
    \x03(\x0b2\x17.google.protobuf.OptionR\x07options\x12E\n\x0esource_conte\
    xt\x18\x05\x20\x01(\x0b2\x1e.google.protobuf.SourceContextR\rsourceConte\
    xt\x12/\n\x06syntax\x18\x06\x20\x01(\x0e2\x17.google.protobuf.SyntaxR\
    \x06syntax\"\xb4\x06\n\x05Field\x12/\n\x04kind\x18\x01\x20\x01(\x0e2\x1b\
    .google.protobuf.Field.KindR\x04kind\x12D\n\x0bcardinality\x18\x02\x20\
    \x01(\x0e2\".google.protobuf.Field.CardinalityR\x0bcardinality\x12\x16\n\
    \x06number\x18\x03\x20\x01(\x05R\x06number\x12\x12\n\x04name\x18\x04\x20\
    \x01(\tR\x04name\x12\x19\n\x08type_url\x18\x06\x20\x01(\tR\x07typeUrl\
    \x12\x1f\n\x0boneof_index\x18\x07\x20\x01(\x05R\noneofIndex\x12\x16\n\
    \x06packed\x18\x08\x20\x01(\x08R\x06packed\x121\n\x07options\x18\t\x20\
    \x03(\x0b2\x17.google.protobuf.OptionR\x07options\x12\x1b\n\tjson_name\
    \x18\n\x20\x01(\tR\x08jsonName\x12#\n\rdefault_value\x18\x0b\x20\x01(\tR\
    \x0cdefaultValue\"\xc8\x02\n\x04Kind\x12\x10\n\x0cTYPE_UNKNOWN\x10\0\x12\
    \x0f\n\x0bTYPE_DOUBLE\x10\x01\x12\x0e\n\nTYPE_FLOAT\x10\x02\x12\x0e\n\nT\
    YPE_INT64\x10\x03\x12\x0f\n\x0bTYPE_UINT64\x10\x04\x12\x0e\n\nTYPE_INT32\
    \x10\x05\x12\x10\n\x0cTYPE_FIXED64\x10\x06\x12\x10\n\x0cTYPE_FIXED32\x10\
    \x07\x12\r\n\tTYPE_BOOL\x10\x08\x12\x0f\n\x0bTYPE_STRING\x10\t\x12\x0e\n\
    \nTYPE_GROUP\x10\n\x12\x10\n\x0cTYPE_MESSAGE\x10\x0b\x12\x0e\n\nTYPE_BYT\
    ES\x10\x0c\x12\x0f\n\x0bTYPE_UINT32\x10\r\x12\r\n\tTYPE_ENUM\x10\x0e\x12\
    \x11\n\rTYPE_SFIXED32\x10\x0f\x12\x11\n\rTYPE_SFIXED64\x10\x10\x12\x0f\n\
    \x0bTYPE_SINT32\x10\x11\x12\x0f\n\x0bTYPE_SINT64\x10\x12\"t\n\x0bCardina\
    lity\x12\x17\n\x13CARDINALITY_UNKNOWN\x10\0\x12\x18\n\x14CARDINALITY_OPT\
    IONAL\x10\x01\x12\x18\n\x14CARDINALITY_REQUIRED\x10\x02\x12\x18\n\x14CAR\
    DINALITY_REPEATED\x10\x03\"\xff\x01\n\x04Enum\x12\x12\n\x04name\x18\x01\
    \x20\x01(\tR\x04name\x128\n\tenumvalue\x18\x02\x20\x03(\x0b2\x1a.google.\
    protobuf.EnumValueR\tenumvalue\x121\n\x07options\x18\x03\x20\x03(\x0b2\
    \x17.google.protobuf.OptionR\x07options\x12E\n\x0esource_context\x18\x04\
    \x20\x01(\x0b2\x1e.google.protobuf.SourceContextR\rsourceContext\x12/\n\
    \x06syntax\x18\x05\x20\x01(\x0e2\x17.google.protobuf.SyntaxR\x06syntax\"\
    j\n\tEnumValue\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x16\n\
    \x06number\x18\x02\x20\x01(\x05R\x06number\x121\n\x07options\x18\x03\x20\
    \x03(\x0b2\x17.google.protobuf.OptionR\x07options\"H\n\x06Option\x12\x12\
    \n\x04name\x18\x01\x20\x01(\tR\x04name\x12*\n\x05value\x18\x02\x20\x01(\
    \x0b2\x14.google.protobuf.AnyR\x05value*.\n\x06Syntax\x12\x11\n\rSYNTAX_\
    PROTO2\x10\0\x12\x11\n\rSYNTAX_PROTO3\x10\x01B{\n\x13com.google.protobuf\
    B\tTypeProtoP\x01Z-google.golang.org/protobuf/types/known/typepb\xf8\x01\
    \x01\xa2\x02\x03GPB\xaa\x02\x1eGoogle.Protobuf.WellKnownTypesJ\xc38\n\
    \x07\x12\x05\x1e\0\xba\x01\x01\n\xcc\x0c\n\x01\x0c\x12\x03\x1e\0\x122\
    \xc1\x0c\x20Protocol\x20Buffers\x20-\x20Google's\x20data\x20interchange\
    \x20format\n\x20Copyright\x202008\x20Google\x20Inc.\x20\x20All\x20rights\
    \x20reserved.\n\x20https://developers.google.com/protocol-buffers/\n\n\
    \x20Redistribution\x20and\x20use\x20in\x20source\x20and\x20binary\x20for\
    ms,\x20with\x20or\x20without\n\x20modification,\x20are\x20permitted\x20p\
    rovided\x20that\x20the\x20following\x20conditions\x20are\n\x20met:\n\n\
    \x20\x20\x20\x20\x20*\x20Redistributions\x20of\x20source\x20code\x20must\
    \x20retain\x20the\x20above\x20copyright\n\x20notice,\x20this\x20list\x20\
    of\x20conditions\x20and\x20the\x20following\x20disclaimer.\n\x20\x20\x20\
    \x20\x20*\x20Redistributions\x20in\x20binary\x20form\x20must\x20reproduc\
    e\x20the\x20above\n\x20copyright\x20notice,\x20this\x20list\x20of\x20con\
    ditions\x20and\x20the\x20following\x20disclaimer\n\x20in\x20the\x20docum\
    entation\x20and/or\x20other\x20materials\x20provided\x20with\x20the\n\
    \x20distribution.\n\x20\x20\x20\x20\x20*\x20Neither\x20the\x20name\x20of\
    \x20Google\x20Inc.\x20nor\x20the\x20names\x20of\x20its\n\x20contributors\
    \x20may\x20be\x20used\x20to\x20endorse\x20or\x20promote\x20products\x20d\
    erived\x20from\n\x20this\x20software\x20without\x20specific\x20prior\x20\
    written\x20permission.\n\n\x20THIS\x20SOFTWARE\x20IS\x20PROVIDED\x20BY\
    \x20THE\x20COPYRIGHT\x20HOLDERS\x20AND\x20CONTRIBUTORS\n\x20\"AS\x20IS\"\
    \x20AND\x20ANY\x20EXPRESS\x20OR\x20IMPLIED\x20WARRANTIES,\x20INCLUDING,\
    \x20BUT\x20NOT\n\x20LIMITED\x20TO,\x20THE\x20IMPLIED\x20WARRANTIES\x20OF\
    \x20MERCHANTABILITY\x20AND\x20FITNESS\x20FOR\n\x20A\x20PARTICULAR\x20PUR\
    POSE\x20ARE\x20DISCLAIMED.\x20IN\x20NO\x20EVENT\x20SHALL\x20THE\x20COPYR\
    IGHT\n\x20OWNER\x20OR\x20CONTRIBUTORS\x20BE\x20LIABLE\x20FOR\x20ANY\x20D\
    IRECT,\x20INDIRECT,\x20INCIDENTAL,\n\x20SPECIAL,\x20EXEMPLARY,\x20OR\x20\
    CONSEQUENTIAL\x20DAMAGES\x20(INCLUDING,\x20BUT\x20NOT\n\x20LIMITED\x20TO\
    ,\x20PROCUREMENT\x20OF\x20SUBSTITUTE\x20GOODS\x20OR\x20SERVICES;\x20LOSS\
    \x20OF\x20USE,\n\x20DATA,\x20OR\x20PROFITS;\x20OR\x20BUSINESS\x20INTERRU\
    PTION)\x20HOWEVER\x20CAUSED\x20AND\x20ON\x20ANY\n\x20THEORY\x20OF\x20LIA\
    BILITY,\x20WHETHER\x20IN\x20CONTRACT,\x20STRICT\x20LIABILITY,\x20OR\x20T\
    ORT\n\x20(INCLUDING\x20NEGLIGENCE\x20OR\x20OTHERWISE)\x20ARISING\x20IN\
    \x20ANY\x20WAY\x20OUT\x20OF\x20THE\x20USE\n\x20OF\x20THIS\x20SOFTWARE,\
    \x20EVEN\x20IF\x20ADVISED\x20OF\x20THE\x20POSSIBILITY\x20OF\x20SUCH\x20D\
    AMAGE.\n\n\x08\n\x01\x02\x12\x03\x20\0\x18\n\t\n\x02\x03\0\x12\x03\"\0#\
    \n\t\n\x02\x03\x01\x12\x03#\0.\n\x08\n\x01\x08\x12\x03%\0;\n\t\n\x02\x08\
    %\x12\x03%\0;\n\x08\n\x01\x08\x12\x03&\0\x1f\n\t\n\x02\x08\x1f\x12\x03&\
    \0\x1f\n\x08\n\x01\x08\x12\x03'\0,\n\t\n\x02\x08\x01\x12\x03'\0,\n\x08\n\
    \x01\x08\x12\x03(\0*\n\t\n\x02\x08\x08\x12\x03(\0*\n\x08\n\x01\x08\x12\
    \x03)\0\"\n\t\n\x02\x08\n\x12\x03)\0\"\n\x08\n\x01\x08\x12\x03*\0!\n\t\n\
    \x02\x08$\x12\x03*\0!\n\x08\n\x01\x08\x12\x03+\0D\n\t\n\x02\x08\x0b\x12\
    \x03+\0D\n-\n\x02\x04\0\x12\x04.\0;\x01\x1a!\x20A\x20protocol\x20buffer\
    \x20message\x20type.\n\n\n\n\x03\x04\0\x01\x12\x03.\x08\x0c\n0\n\x04\x04\
    \0\x02\0\x12\x030\x02\x12\x1a#\x20The\x20fully\x20qualified\x20message\
    \x20name.\n\n\x0c\n\x05\x04\0\x02\0\x05\x12\x030\x02\x08\n\x0c\n\x05\x04\
    \0\x02\0\x01\x12\x030\t\r\n\x0c\n\x05\x04\0\x02\0\x03\x12\x030\x10\x11\n\
    \"\n\x04\x04\0\x02\x01\x12\x032\x02\x1c\x1a\x15\x20The\x20list\x20of\x20\
    fields.\n\n\x0c\n\x05\x04\0\x02\x01\x04\x12\x032\x02\n\n\x0c\n\x05\x04\0\
    \x02\x01\x06\x12\x032\x0b\x10\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x032\x11\
    \x17\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x032\x1a\x1b\nO\n\x04\x04\0\x02\
    \x02\x12\x034\x02\x1d\x1aB\x20The\x20list\x20of\x20types\x20appearing\
    \x20in\x20`oneof`\x20definitions\x20in\x20this\x20type.\n\n\x0c\n\x05\
    \x04\0\x02\x02\x04\x12\x034\x02\n\n\x0c\n\x05\x04\0\x02\x02\x05\x12\x034\
    \x0b\x11\n\x0c\n\x05\x04\0\x02\x02\x01\x12\x034\x12\x18\n\x0c\n\x05\x04\
    \0\x02\x02\x03\x12\x034\x1b\x1c\n+\n\x04\x04\0\x02\x03\x12\x036\x02\x1e\
    \x1a\x1e\x20The\x20protocol\x20buffer\x20options.\n\n\x0c\n\x05\x04\0\
    \x02\x03\x04\x12\x036\x02\n\n\x0c\n\x05\x04\0\x02\x03\x06\x12\x036\x0b\
    \x11\n\x0c\n\x05\x04\0\x02\x03\x01\x12\x036\x12\x19\n\x0c\n\x05\x04\0\
    \x02\x03\x03\x12\x036\x1c\x1d\n\"\n\x04\x04\0\x02\x04\x12\x038\x02#\x1a\
    \x15\x20The\x20source\x20context.\n\n\x0c\n\x05\x04\0\x02\x04\x06\x12\
    \x038\x02\x0f\n\x0c\n\x05\x04\0\x02\x04\x01\x12\x038\x10\x1e\n\x0c\n\x05\
    \x04\0\x02\x04\x03\x12\x038!\"\n!\n\x04\x04\0\x02\x05\x12\x03:\x02\x14\
    \x1a\x14\x20The\x20source\x20syntax.\n\n\x0c\n\x05\x04\0\x02\x05\x06\x12\
    \x03:\x02\x08\n\x0c\n\x05\x04\0\x02\x05\x01\x12\x03:\t\x0f\n\x0c\n\x05\
    \x04\0\x02\x05\x03\x12\x03:\x12\x13\n0\n\x02\x04\x01\x12\x05>\0\x8b\x01\
    \x01\x1a#\x20A\x20single\x20field\x20of\x20a\x20message\x20type.\n\n\n\n\
    \x03\x04\x01\x01\x12\x03>\x08\r\n\"\n\x04\x04\x01\x04\0\x12\x04@\x02g\
    \x03\x1a\x14\x20Basic\x20field\x20types.\n\n\x0c\n\x05\x04\x01\x04\0\x01\
    \x12\x03@\x07\x0b\n$\n\x06\x04\x01\x04\0\x02\0\x12\x03B\x04\x15\x1a\x15\
    \x20Field\x20type\x20unknown.\n\n\x0e\n\x07\x04\x01\x04\0\x02\0\x01\x12\
    \x03B\x04\x10\n\x0e\n\x07\x04\x01\x04\0\x02\0\x02\x12\x03B\x13\x14\n#\n\
    \x06\x04\x01\x04\0\x02\x01\x12\x03D\x04\x14\x1a\x14\x20Field\x20type\x20\
    double.\n\n\x0e\n\x07\x04\x01\x04\0\x02\x01\x01\x12\x03D\x04\x0f\n\x0e\n\
    \x07\x04\x01\x04\0\x02\x01\x02\x12\x03D\x12\x13\n\"\n\x06\x04\x01\x04\0\
    \x02\x02\x12\x03F\x04\x13\x1a\x13\x20Field\x20type\x20float.\n\n\x0e\n\
    \x07\x04\x01\x04\0\x02\x02\x01\x12\x03F\x04\x0e\n\x0e\n\x07\x04\x01\x04\
    \0\x02\x02\x02\x12\x03F\x11\x12\n\"\n\x06\x04\x01\x04\0\x02\x03\x12\x03H\
    \x04\x13\x1a\x13\x20Field\x20type\x20int64.\n\n\x0e\n\x07\x04\x01\x04\0\
    \x02\x03\x01\x12\x03H\x04\x0e\n\x0e\n\x07\x04\x01\x04\0\x02\x03\x02\x12\
    \x03H\x11\x12\n#\n\x06\x04\x01\x04\0\x02\x04\x12\x03J\x04\x14\x1a\x14\
    \x20Field\x20type\x20uint64.\n\n\x0e\n\x07\x04\x01\x04\0\x02\x04\x01\x12\
    \x03J\x04\x0f\n\x0e\n\x07\x04\x01\x04\0\x02\x04\x02\x12\x03J\x12\x13\n\"\
    \n\x06\x04\x01\x04\0\x02\x05\x12\x03L\x04\x13\x1a\x13\x20Field\x20type\
    \x20int32.\n\n\x0e\n\x07\x04\x01\x04\0\x02\x05\x01\x12\x03L\x04\x0e\n\
    \x0e\n\x07\x04\x01\x04\0\x02\x05\x02\x12\x03L\x11\x12\n$\n\x06\x04\x01\
    \x04\0\x02\x06\x12\x03N\x04\x15\x1a\x15\x20Field\x20type\x20fixed64.\n\n\
    \x0e\n\x07\x04\x01\x04\0\x02\x06\x01\x12\x03N\x04\x10\n\x0e\n\x07\x04\
    \x01\x04\0\x02\x06\x02\x12\x03N\x13\x14\n$\n\x06\x04\x01\x04\0\x02\x07\
    \x12\x03P\x04\x15\x1a\x15\x20Field\x20type\x20fixed32.\n\n\x0e\n\x07\x04\
    \x01\x04\0\x02\x07\x01\x12\x03P\x04\x10\n\x0e\n\x07\x04\x01\x04\0\x02\
    \x07\x02\x12\x03P\x13\x14\n!\n\x06\x04\x01\x04\0\x02\x08\x12\x03R\x04\
    \x12\x1a\x12\x20Field\x20type\x20bool.\n\n\x0e\n\x07\x04\x01\x04\0\x02\
    \x08\x01\x12\x03R\x04\r\n\x0e\n\x07\x04\x01\x04\0\x02\x08\x02\x12\x03R\
    \x10\x11\n#\n\x06\x04\x01\x04\0\x02\t\x12\x03T\x04\x14\x1a\x14\x20Field\
    \x20type\x20string.\n\n\x0e\n\x07\x04\x01\x04\0\x02\t\x01\x12\x03T\x04\
    \x0f\n\x0e\n\x07\x04\x01\x04\0\x02\t\x02\x12\x03T\x12\x13\nF\n\x06\x04\
    \x01\x04\0\x02\n\x12\x03V\x04\x14\x1a7\x20Field\x20type\x20group.\x20Pro\
    to2\x20syntax\x20only,\x20and\x20deprecated.\n\n\x0e\n\x07\x04\x01\x04\0\
    \x02\n\x01\x12\x03V\x04\x0e\n\x0e\n\x07\x04\x01\x04\0\x02\n\x02\x12\x03V\
    \x11\x13\n$\n\x06\x04\x01\x04\0\x02\x0b\x12\x03X\x04\x16\x1a\x15\x20Fiel\
    d\x20type\x20message.\n\n\x0e\n\x07\x04\x01\x04\0\x02\x0b\x01\x12\x03X\
    \x04\x10\n\x0e\n\x07\x04\x01\x04\0\x02\x0b\x02\x12\x03X\x13\x15\n\"\n\
    \x06\x04\x01\x04\0\x02\x0c\x12\x03Z\x04\x14\x1a\x13\x20Field\x20type\x20\
    bytes.\n\n\x0e\n\x07\x04\x01\x04\0\x02\x0c\x01\x12\x03Z\x04\x0e\n\x0e\n\
    \x07\x04\x01\x04\0\x02\x0c\x02\x12\x03Z\x11\x13\n#\n\x06\x04\x01\x04\0\
    \x02\r\x12\x03\\\x04\x15\x1a\x14\x20Field\x20type\x20uint32.\n\n\x0e\n\
    \x07\x04\x01\x04\0\x02\r\x01\x12\x03\\\x04\x0f\n\x0e\n\x07\x04\x01\x04\0\
    \x02\r\x02\x12\x03\\\x12\x14\n!\n\x06\x04\x01\x04\0\x02\x0e\x12\x03^\x04\
    \x13\x1a\x12\x20Field\x20type\x20enum.\n\n\x0e\n\x07\x04\x01\x04\0\x02\
    \x0e\x01\x12\x03^\x04\r\n\x0e\n\x07\x04\x01\x04\0\x02\x0e\x02\x12\x03^\
    \x10\x12\n%\n\x06\x04\x01\x04\0\x02\x0f\x12\x03`\x04\x17\x1a\x16\x20Fiel\
    d\x20type\x20sfixed32.\n\n\x0e\n\x07\x04\x01\x04\0\x02\x0f\x01\x12\x03`\
    \x04\x11\n\x0e\n\x07\x04\x01\x04\0\x02\x0f\x02\x12\x03`\x14\x16\n%\n\x06\
    \x04\x01\x04\0\x02\x10\x12\x03b\x04\x17\x1a\x16\x20Field\x20type\x20sfix\
    ed64.\n\n\x0e\n\x07\x04\x01\x04\0\x02\x10\x01\x12\x03b\x04\x11\n\x0e\n\
    \x07\x04\x01\x04\0\x02\x10\x02\x12\x03b\x14\x16\n#\n\x06\x04\x01\x04\0\
    \x02\x11\x12\x03d\x04\x15\x1a\x14\x20Field\x20type\x20sint32.\n\n\x0e\n\
    \x07\x04\x01\x04\0\x02\x11\x01\x12\x03d\x04\x0f\n\x0e\n\x07\x04\x01\x04\
    \0\x02\x11\x02\x12\x03d\x12\x14\n#\n\x06\x04\x01\x04\0\x02\x12\x12\x03f\
    \x04\x15\x1a\x14\x20Field\x20type\x20sint64.\n\n\x0e\n\x07\x04\x01\x04\0\
    \x02\x12\x01\x12\x03f\x04\x0f\n\x0e\n\x07\x04\x01\x04\0\x02\x12\x02\x12\
    \x03f\x12\x14\nC\n\x04\x04\x01\x04\x01\x12\x04j\x02s\x03\x1a5\x20Whether\
    \x20a\x20field\x20is\x20optional,\x20required,\x20or\x20repeated.\n\n\
    \x0c\n\x05\x04\x01\x04\x01\x01\x12\x03j\x07\x12\n5\n\x06\x04\x01\x04\x01\
    \x02\0\x12\x03l\x04\x1c\x1a&\x20For\x20fields\x20with\x20unknown\x20card\
    inality.\n\n\x0e\n\x07\x04\x01\x04\x01\x02\0\x01\x12\x03l\x04\x17\n\x0e\
    \n\x07\x04\x01\x04\x01\x02\0\x02\x12\x03l\x1a\x1b\n%\n\x06\x04\x01\x04\
    \x01\x02\x01\x12\x03n\x04\x1d\x1a\x16\x20For\x20optional\x20fields.\n\n\
    \x0e\n\x07\x04\x01\x04\x01\x02\x01\x01\x12\x03n\x04\x18\n\x0e\n\x07\x04\
    \x01\x04\x01\x02\x01\x02\x12\x03n\x1b\x1c\n9\n\x06\x04\x01\x04\x01\x02\
    \x02\x12\x03p\x04\x1d\x1a*\x20For\x20required\x20fields.\x20Proto2\x20sy\
    ntax\x20only.\n\n\x0e\n\x07\x04\x01\x04\x01\x02\x02\x01\x12\x03p\x04\x18\
    \n\x0e\n\x07\x04\x01\x04\x01\x02\x02\x02\x12\x03p\x1b\x1c\n%\n\x06\x04\
    \x01\x04\x01\x02\x03\x12\x03r\x04\x1d\x1a\x16\x20For\x20repeated\x20fiel\
    ds.\n\n\x0e\n\x07\x04\x01\x04\x01\x02\x03\x01\x12\x03r\x04\x18\n\x0e\n\
    \x07\x04\x01\x04\x01\x02\x03\x02\x12\x03r\x1b\x1c\n\x1e\n\x04\x04\x01\
    \x02\0\x12\x03v\x02\x10\x1a\x11\x20The\x20field\x20type.\n\n\x0c\n\x05\
    \x04\x01\x02\0\x06\x12\x03v\x02\x06\n\x0c\n\x05\x04\x01\x02\0\x01\x12\
    \x03v\x07\x0b\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03v\x0e\x0f\n%\n\x04\
    \x04\x01\x02\x01\x12\x03x\x02\x1e\x1a\x18\x20The\x20field\x20cardinality\
    .\n\n\x0c\n\x05\x04\x01\x02\x01\x06\x12\x03x\x02\r\n\x0c\n\x05\x04\x01\
    \x02\x01\x01\x12\x03x\x0e\x19\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x03x\
    \x1c\x1d\n\x20\n\x04\x04\x01\x02\x02\x12\x03z\x02\x13\x1a\x13\x20The\x20\
    field\x20number.\n\n\x0c\n\x05\x04\x01\x02\x02\x05\x12\x03z\x02\x07\n\
    \x0c\n\x05\x04\x01\x02\x02\x01\x12\x03z\x08\x0e\n\x0c\n\x05\x04\x01\x02\
    \x02\x03\x12\x03z\x11\x12\n\x1e\n\x04\x04\x01\x02\x03\x12\x03|\x02\x12\
    \x1a\x11\x20The\x20field\x20name.\n\n\x0c\n\x05\x04\x01\x02\x03\x05\x12\
    \x03|\x02\x08\n\x0c\n\x05\x04\x01\x02\x03\x01\x12\x03|\t\r\n\x0c\n\x05\
    \x04\x01\x02\x03\x03\x12\x03|\x10\x11\n\x96\x01\n\x04\x04\x01\x02\x04\
    \x12\x03\x7f\x02\x16\x1a\x88\x01\x20The\x20field\x20type\x20URL,\x20with\
    out\x20the\x20scheme,\x20for\x20message\x20or\x20enumeration\n\x20types.\
    \x20Example:\x20`\"type.googleapis.com/google.protobuf.Timestamp\"`.\n\n\
    \x0c\n\x05\x04\x01\x02\x04\x05\x12\x03\x7f\x02\x08\n\x0c\n\x05\x04\x01\
    \x02\x04\x01\x12\x03\x7f\t\x11\n\x0c\n\x05\x04\x01\x02\x04\x03\x12\x03\
    \x7f\x14\x15\n\xa5\x01\n\x04\x04\x01\x02\x05\x12\x04\x82\x01\x02\x18\x1a\
    \x96\x01\x20The\x20index\x20of\x20the\x20field\x20type\x20in\x20`Type.on\
    eofs`,\x20for\x20message\x20or\x20enumeration\n\x20types.\x20The\x20firs\
    t\x20type\x20has\x20index\x201;\x20zero\x20means\x20the\x20type\x20is\
    \x20not\x20in\x20the\x20list.\n\n\r\n\x05\x04\x01\x02\x05\x05\x12\x04\
    \x82\x01\x02\x07\n\r\n\x05\x04\x01\x02\x05\x01\x12\x04\x82\x01\x08\x13\n\
    \r\n\x05\x04\x01\x02\x05\x03\x12\x04\x82\x01\x16\x17\nF\n\x04\x04\x01\
    \x02\x06\x12\x04\x84\x01\x02\x12\x1a8\x20Whether\x20to\x20use\x20alterna\
    tive\x20packed\x20wire\x20representation.\n\n\r\n\x05\x04\x01\x02\x06\
    \x05\x12\x04\x84\x01\x02\x06\n\r\n\x05\x04\x01\x02\x06\x01\x12\x04\x84\
    \x01\x07\r\n\r\n\x05\x04\x01\x02\x06\x03\x12\x04\x84\x01\x10\x11\n,\n\
    \x04\x04\x01\x02\x07\x12\x04\x86\x01\x02\x1e\x1a\x1e\x20The\x20protocol\
    \x20buffer\x20options.\n\n\r\n\x05\x04\x01\x02\x07\x04\x12\x04\x86\x01\
    \x02\n\n\r\n\x05\x04\x01\x02\x07\x06\x12\x04\x86\x01\x0b\x11\n\r\n\x05\
    \x04\x01\x02\x07\x01\x12\x04\x86\x01\x12\x19\n\r\n\x05\x04\x01\x02\x07\
    \x03\x12\x04\x86\x01\x1c\x1d\n$\n\x04\x04\x01\x02\x08\x12\x04\x88\x01\
    \x02\x18\x1a\x16\x20The\x20field\x20JSON\x20name.\n\n\r\n\x05\x04\x01\
    \x02\x08\x05\x12\x04\x88\x01\x02\x08\n\r\n\x05\x04\x01\x02\x08\x01\x12\
    \x04\x88\x01\t\x12\n\r\n\x05\x04\x01\x02\x08\x03\x12\x04\x88\x01\x15\x17\
    \nX\n\x04\x04\x01\x02\t\x12\x04\x8a\x01\x02\x1c\x1aJ\x20The\x20string\
    \x20value\x20of\x20the\x20default\x20value\x20of\x20this\x20field.\x20Pr\
    oto2\x20syntax\x20only.\n\n\r\n\x05\x04\x01\x02\t\x05\x12\x04\x8a\x01\
    \x02\x08\n\r\n\x05\x04\x01\x02\t\x01\x12\x04\x8a\x01\t\x16\n\r\n\x05\x04\
    \x01\x02\t\x03\x12\x04\x8a\x01\x19\x1b\n%\n\x02\x04\x02\x12\x06\x8e\x01\
    \0\x99\x01\x01\x1a\x17\x20Enum\x20type\x20definition.\n\n\x0b\n\x03\x04\
    \x02\x01\x12\x04\x8e\x01\x08\x0c\n\x1f\n\x04\x04\x02\x02\0\x12\x04\x90\
    \x01\x02\x12\x1a\x11\x20Enum\x20type\x20name.\n\n\r\n\x05\x04\x02\x02\0\
    \x05\x12\x04\x90\x01\x02\x08\n\r\n\x05\x04\x02\x02\0\x01\x12\x04\x90\x01\
    \t\r\n\r\n\x05\x04\x02\x02\0\x03\x12\x04\x90\x01\x10\x11\n'\n\x04\x04\
    \x02\x02\x01\x12\x04\x92\x01\x02#\x1a\x19\x20Enum\x20value\x20definition\
    s.\n\n\r\n\x05\x04\x02\x02\x01\x04\x12\x04\x92\x01\x02\n\n\r\n\x05\x04\
    \x02\x02\x01\x06\x12\x04\x92\x01\x0b\x14\n\r\n\x05\x04\x02\x02\x01\x01\
    \x12\x04\x92\x01\x15\x1e\n\r\n\x05\x04\x02\x02\x01\x03\x12\x04\x92\x01!\
    \"\n(\n\x04\x04\x02\x02\x02\x12\x04\x94\x01\x02\x1e\x1a\x1a\x20Protocol\
    \x20buffer\x20options.\n\n\r\n\x05\x04\x02\x02\x02\x04\x12\x04\x94\x01\
    \x02\n\n\r\n\x05\x04\x02\x02\x02\x06\x12\x04\x94\x01\x0b\x11\n\r\n\x05\
    \x04\x02\x02\x02\x01\x12\x04\x94\x01\x12\x19\n\r\n\x05\x04\x02\x02\x02\
    \x03\x12\x04\x94\x01\x1c\x1d\n#\n\x04\x04\x02\x02\x03\x12\x04\x96\x01\
    \x02#\x1a\x15\x20The\x20source\x20context.\n\n\r\n\x05\x04\x02\x02\x03\
    \x06\x12\x04\x96\x01\x02\x0f\n\r\n\x05\x04\x02\x02\x03\x01\x12\x04\x96\
    \x01\x10\x1e\n\r\n\x05\x04\x02\x02\x03\x03\x12\x04\x96\x01!\"\n\"\n\x04\
    \x04\x02\x02\x04\x12\x04\x98\x01\x02\x14\x1a\x14\x20The\x20source\x20syn\
    tax.\n\n\r\n\x05\x04\x02\x02\x04\x06\x12\x04\x98\x01\x02\x08\n\r\n\x05\
    \x04\x02\x02\x04\x01\x12\x04\x98\x01\t\x0f\n\r\n\x05\x04\x02\x02\x04\x03\
    \x12\x04\x98\x01\x12\x13\n&\n\x02\x04\x03\x12\x06\x9c\x01\0\xa3\x01\x01\
    \x1a\x18\x20Enum\x20value\x20definition.\n\n\x0b\n\x03\x04\x03\x01\x12\
    \x04\x9c\x01\x08\x11\n\x20\n\x04\x04\x03\x02\0\x12\x04\x9e\x01\x02\x12\
    \x1a\x12\x20Enum\x20value\x20name.\n\n\r\n\x05\x04\x03\x02\0\x05\x12\x04\
    \x9e\x01\x02\x08\n\r\n\x05\x04\x03\x02\0\x01\x12\x04\x9e\x01\t\r\n\r\n\
    \x05\x04\x03\x02\0\x03\x12\x04\x9e\x01\x10\x11\n\"\n\x04\x04\x03\x02\x01\
    \x12\x04\xa0\x01\x02\x13\x1a\x14\x20Enum\x20value\x20number.\n\n\r\n\x05\
    \x04\x03\x02\x01\x05\x12\x04\xa0\x01\x02\x07\n\r\n\x05\x04\x03\x02\x01\
    \x01\x12\x04\xa0\x01\x08\x0e\n\r\n\x05\x04\x03\x02\x01\x03\x12\x04\xa0\
    \x01\x11\x12\n(\n\x04\x04\x03\x02\x02\x12\x04\xa2\x01\x02\x1e\x1a\x1a\
    \x20Protocol\x20buffer\x20options.\n\n\r\n\x05\x04\x03\x02\x02\x04\x12\
    \x04\xa2\x01\x02\n\n\r\n\x05\x04\x03\x02\x02\x06\x12\x04\xa2\x01\x0b\x11\
    \n\r\n\x05\x04\x03\x02\x02\x01\x12\x04\xa2\x01\x12\x19\n\r\n\x05\x04\x03\
    \x02\x02\x03\x12\x04\xa2\x01\x1c\x1d\ng\n\x02\x04\x04\x12\x06\xa7\x01\0\
    \xb2\x01\x01\x1aY\x20A\x20protocol\x20buffer\x20option,\x20which\x20can\
    \x20be\x20attached\x20to\x20a\x20message,\x20field,\n\x20enumeration,\
    \x20etc.\n\n\x0b\n\x03\x04\x04\x01\x12\x04\xa7\x01\x08\x0e\n\xfc\x01\n\
    \x04\x04\x04\x02\0\x12\x04\xac\x01\x02\x12\x1a\xed\x01\x20The\x20option'\
    s\x20name.\x20For\x20protobuf\x20built-in\x20options\x20(options\x20defi\
    ned\x20in\n\x20descriptor.proto),\x20this\x20is\x20the\x20short\x20name.\
    \x20For\x20example,\x20`\"map_entry\"`.\n\x20For\x20custom\x20options,\
    \x20it\x20should\x20be\x20the\x20fully-qualified\x20name.\x20For\x20exam\
    ple,\n\x20`\"google.api.http\"`.\n\n\r\n\x05\x04\x04\x02\0\x05\x12\x04\
    \xac\x01\x02\x08\n\r\n\x05\x04\x04\x02\0\x01\x12\x04\xac\x01\t\r\n\r\n\
    \x05\x04\x04\x02\0\x03\x12\x04\xac\x01\x10\x11\n\xa0\x02\n\x04\x04\x04\
    \x02\x01\x12\x04\xb1\x01\x02\x10\x1a\x91\x02\x20The\x20option's\x20value\
    \x20packed\x20in\x20an\x20Any\x20message.\x20If\x20the\x20value\x20is\
    \x20a\x20primitive,\n\x20the\x20corresponding\x20wrapper\x20type\x20defi\
    ned\x20in\x20google/protobuf/wrappers.proto\n\x20should\x20be\x20used.\
    \x20If\x20the\x20value\x20is\x20an\x20enum,\x20it\x20should\x20be\x20sto\
    red\x20as\x20an\x20int32\n\x20value\x20using\x20the\x20google.protobuf.I\
    nt32Value\x20type.\n\n\r\n\x05\x04\x04\x02\x01\x06\x12\x04\xb1\x01\x02\
    \x05\n\r\n\x05\x04\x04\x02\x01\x01\x12\x04\xb1\x01\x06\x0b\n\r\n\x05\x04\
    \x04\x02\x01\x03\x12\x04\xb1\x01\x0e\x0f\nI\n\x02\x05\0\x12\x06\xb5\x01\
    \0\xba\x01\x01\x1a;\x20The\x20syntax\x20in\x20which\x20a\x20protocol\x20\
    buffer\x20element\x20is\x20defined.\n\n\x0b\n\x03\x05\0\x01\x12\x04\xb5\
    \x01\x05\x0b\n\x20\n\x04\x05\0\x02\0\x12\x04\xb7\x01\x02\x14\x1a\x12\x20\
    Syntax\x20`proto2`.\n\n\r\n\x05\x05\0\x02\0\x01\x12\x04\xb7\x01\x02\x0f\
    \n\r\n\x05\x05\0\x02\0\x02\x12\x04\xb7\x01\x12\x13\n\x20\n\x04\x05\0\x02\
    \x01\x12\x04\xb9\x01\x02\x14\x1a\x12\x20Syntax\x20`proto3`.\n\n\r\n\x05\
    \x05\0\x02\x01\x01\x12\x04\xb9\x01\x02\x0f\n\r\n\x05\x05\0\x02\x01\x02\
    \x12\x04\xb9\x01\x12\x13b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static crate::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: crate::rt::Lazy<crate::descriptor::FileDescriptorProto> = crate::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        crate::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static crate::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: crate::rt::Lazy<crate::reflect::GeneratedFileDescriptor> = crate::rt::Lazy::new();
    static file_descriptor: crate::rt::Lazy<crate::reflect::FileDescriptor> = crate::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(2);
            deps.push(crate::well_known_types::any::file_descriptor().clone());
            deps.push(crate::well_known_types::source_context::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(5);
            messages.push(Type::generated_message_descriptor_data());
            messages.push(Field::generated_message_descriptor_data());
            messages.push(Enum::generated_message_descriptor_data());
            messages.push(EnumValue::generated_message_descriptor_data());
            messages.push(Option::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(3);
            enums.push(Syntax::generated_enum_descriptor_data());
            enums.push(field::Kind::generated_enum_descriptor_data());
            enums.push(field::Cardinality::generated_enum_descriptor_data());
            crate::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        crate::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}

'''
'''--- protobuf/src/well_known_types/wrappers.rs ---
// This file is generated by rust-protobuf 4.0.0-alpha.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `google/protobuf/wrappers.proto`

///  Wrapper message for `double`.
///
///  The JSON representation for `DoubleValue` is JSON number.
// @@protoc_insertion_point(message:google.protobuf.DoubleValue)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DoubleValue {
    // message fields
    ///  The double value.
    // @@protoc_insertion_point(field:google.protobuf.DoubleValue.value)
    pub value: f64,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.DoubleValue.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DoubleValue {
    fn default() -> &'a DoubleValue {
        <DoubleValue as crate::Message>::default_instance()
    }
}

impl DoubleValue {
    pub fn new() -> DoubleValue {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "value",
            |m: &DoubleValue| { &m.value },
            |m: &mut DoubleValue| { &mut m.value },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<DoubleValue>(
            "DoubleValue",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for DoubleValue {
    const NAME: &'static str = "DoubleValue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.value = is.read_double()?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.value != 0. {
            my_size += 1 + 8;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if self.value != 0. {
            os.write_double(1, self.value)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DoubleValue {
        DoubleValue::new()
    }

    fn clear(&mut self) {
        self.value = 0.;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DoubleValue {
        static instance: DoubleValue = DoubleValue {
            value: 0.,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for DoubleValue {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DoubleValue").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DoubleValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for DoubleValue {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Wrapper message for `float`.
///
///  The JSON representation for `FloatValue` is JSON number.
// @@protoc_insertion_point(message:google.protobuf.FloatValue)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FloatValue {
    // message fields
    ///  The float value.
    // @@protoc_insertion_point(field:google.protobuf.FloatValue.value)
    pub value: f32,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.FloatValue.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FloatValue {
    fn default() -> &'a FloatValue {
        <FloatValue as crate::Message>::default_instance()
    }
}

impl FloatValue {
    pub fn new() -> FloatValue {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "value",
            |m: &FloatValue| { &m.value },
            |m: &mut FloatValue| { &mut m.value },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<FloatValue>(
            "FloatValue",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for FloatValue {
    const NAME: &'static str = "FloatValue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.value = is.read_float()?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.value != 0. {
            my_size += 1 + 4;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if self.value != 0. {
            os.write_float(1, self.value)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FloatValue {
        FloatValue::new()
    }

    fn clear(&mut self) {
        self.value = 0.;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FloatValue {
        static instance: FloatValue = FloatValue {
            value: 0.,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for FloatValue {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FloatValue").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FloatValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for FloatValue {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Wrapper message for `int64`.
///
///  The JSON representation for `Int64Value` is JSON string.
// @@protoc_insertion_point(message:google.protobuf.Int64Value)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Int64Value {
    // message fields
    ///  The int64 value.
    // @@protoc_insertion_point(field:google.protobuf.Int64Value.value)
    pub value: i64,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.Int64Value.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Int64Value {
    fn default() -> &'a Int64Value {
        <Int64Value as crate::Message>::default_instance()
    }
}

impl Int64Value {
    pub fn new() -> Int64Value {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "value",
            |m: &Int64Value| { &m.value },
            |m: &mut Int64Value| { &mut m.value },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<Int64Value>(
            "Int64Value",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for Int64Value {
    const NAME: &'static str = "Int64Value";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.value = is.read_int64()?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.value != 0 {
            my_size += crate::rt::int64_size(1, self.value);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if self.value != 0 {
            os.write_int64(1, self.value)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Int64Value {
        Int64Value::new()
    }

    fn clear(&mut self) {
        self.value = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Int64Value {
        static instance: Int64Value = Int64Value {
            value: 0,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for Int64Value {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Int64Value").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Int64Value {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for Int64Value {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Wrapper message for `uint64`.
///
///  The JSON representation for `UInt64Value` is JSON string.
// @@protoc_insertion_point(message:google.protobuf.UInt64Value)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UInt64Value {
    // message fields
    ///  The uint64 value.
    // @@protoc_insertion_point(field:google.protobuf.UInt64Value.value)
    pub value: u64,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.UInt64Value.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UInt64Value {
    fn default() -> &'a UInt64Value {
        <UInt64Value as crate::Message>::default_instance()
    }
}

impl UInt64Value {
    pub fn new() -> UInt64Value {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "value",
            |m: &UInt64Value| { &m.value },
            |m: &mut UInt64Value| { &mut m.value },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<UInt64Value>(
            "UInt64Value",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for UInt64Value {
    const NAME: &'static str = "UInt64Value";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.value = is.read_uint64()?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.value != 0 {
            my_size += crate::rt::uint64_size(1, self.value);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if self.value != 0 {
            os.write_uint64(1, self.value)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UInt64Value {
        UInt64Value::new()
    }

    fn clear(&mut self) {
        self.value = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UInt64Value {
        static instance: UInt64Value = UInt64Value {
            value: 0,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for UInt64Value {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UInt64Value").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UInt64Value {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for UInt64Value {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Wrapper message for `int32`.
///
///  The JSON representation for `Int32Value` is JSON number.
// @@protoc_insertion_point(message:google.protobuf.Int32Value)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Int32Value {
    // message fields
    ///  The int32 value.
    // @@protoc_insertion_point(field:google.protobuf.Int32Value.value)
    pub value: i32,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.Int32Value.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Int32Value {
    fn default() -> &'a Int32Value {
        <Int32Value as crate::Message>::default_instance()
    }
}

impl Int32Value {
    pub fn new() -> Int32Value {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "value",
            |m: &Int32Value| { &m.value },
            |m: &mut Int32Value| { &mut m.value },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<Int32Value>(
            "Int32Value",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for Int32Value {
    const NAME: &'static str = "Int32Value";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.value = is.read_int32()?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.value != 0 {
            my_size += crate::rt::int32_size(1, self.value);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if self.value != 0 {
            os.write_int32(1, self.value)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Int32Value {
        Int32Value::new()
    }

    fn clear(&mut self) {
        self.value = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Int32Value {
        static instance: Int32Value = Int32Value {
            value: 0,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for Int32Value {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Int32Value").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Int32Value {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for Int32Value {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Wrapper message for `uint32`.
///
///  The JSON representation for `UInt32Value` is JSON number.
// @@protoc_insertion_point(message:google.protobuf.UInt32Value)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UInt32Value {
    // message fields
    ///  The uint32 value.
    // @@protoc_insertion_point(field:google.protobuf.UInt32Value.value)
    pub value: u32,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.UInt32Value.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UInt32Value {
    fn default() -> &'a UInt32Value {
        <UInt32Value as crate::Message>::default_instance()
    }
}

impl UInt32Value {
    pub fn new() -> UInt32Value {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "value",
            |m: &UInt32Value| { &m.value },
            |m: &mut UInt32Value| { &mut m.value },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<UInt32Value>(
            "UInt32Value",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for UInt32Value {
    const NAME: &'static str = "UInt32Value";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.value = is.read_uint32()?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.value != 0 {
            my_size += crate::rt::uint32_size(1, self.value);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if self.value != 0 {
            os.write_uint32(1, self.value)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UInt32Value {
        UInt32Value::new()
    }

    fn clear(&mut self) {
        self.value = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UInt32Value {
        static instance: UInt32Value = UInt32Value {
            value: 0,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for UInt32Value {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UInt32Value").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UInt32Value {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for UInt32Value {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Wrapper message for `bool`.
///
///  The JSON representation for `BoolValue` is JSON `true` and `false`.
// @@protoc_insertion_point(message:google.protobuf.BoolValue)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BoolValue {
    // message fields
    ///  The bool value.
    // @@protoc_insertion_point(field:google.protobuf.BoolValue.value)
    pub value: bool,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.BoolValue.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BoolValue {
    fn default() -> &'a BoolValue {
        <BoolValue as crate::Message>::default_instance()
    }
}

impl BoolValue {
    pub fn new() -> BoolValue {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "value",
            |m: &BoolValue| { &m.value },
            |m: &mut BoolValue| { &mut m.value },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<BoolValue>(
            "BoolValue",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for BoolValue {
    const NAME: &'static str = "BoolValue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.value = is.read_bool()?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.value != false {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if self.value != false {
            os.write_bool(1, self.value)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BoolValue {
        BoolValue::new()
    }

    fn clear(&mut self) {
        self.value = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BoolValue {
        static instance: BoolValue = BoolValue {
            value: false,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for BoolValue {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BoolValue").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BoolValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for BoolValue {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Wrapper message for `string`.
///
///  The JSON representation for `StringValue` is JSON string.
// @@protoc_insertion_point(message:google.protobuf.StringValue)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StringValue {
    // message fields
    ///  The string value.
    // @@protoc_insertion_point(field:google.protobuf.StringValue.value)
    pub value: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.StringValue.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StringValue {
    fn default() -> &'a StringValue {
        <StringValue as crate::Message>::default_instance()
    }
}

impl StringValue {
    pub fn new() -> StringValue {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "value",
            |m: &StringValue| { &m.value },
            |m: &mut StringValue| { &mut m.value },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<StringValue>(
            "StringValue",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for StringValue {
    const NAME: &'static str = "StringValue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.value = is.read_string()?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.value.is_empty() {
            my_size += crate::rt::string_size(1, &self.value);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if !self.value.is_empty() {
            os.write_string(1, &self.value)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StringValue {
        StringValue::new()
    }

    fn clear(&mut self) {
        self.value.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StringValue {
        static instance: StringValue = StringValue {
            value: ::std::string::String::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for StringValue {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StringValue").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StringValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for StringValue {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Wrapper message for `bytes`.
///
///  The JSON representation for `BytesValue` is JSON string.
// @@protoc_insertion_point(message:google.protobuf.BytesValue)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BytesValue {
    // message fields
    ///  The bytes value.
    // @@protoc_insertion_point(field:google.protobuf.BytesValue.value)
    pub value: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.BytesValue.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BytesValue {
    fn default() -> &'a BytesValue {
        <BytesValue as crate::Message>::default_instance()
    }
}

impl BytesValue {
    pub fn new() -> BytesValue {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "value",
            |m: &BytesValue| { &m.value },
            |m: &mut BytesValue| { &mut m.value },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<BytesValue>(
            "BytesValue",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for BytesValue {
    const NAME: &'static str = "BytesValue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.value = is.read_bytes()?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.value.is_empty() {
            my_size += crate::rt::bytes_size(1, &self.value);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if !self.value.is_empty() {
            os.write_bytes(1, &self.value)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BytesValue {
        BytesValue::new()
    }

    fn clear(&mut self) {
        self.value.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BytesValue {
        static instance: BytesValue = BytesValue {
            value: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for BytesValue {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BytesValue").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BytesValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for BytesValue {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1egoogle/protobuf/wrappers.proto\x12\x0fgoogle.protobuf\"#\n\x0bDoub\
    leValue\x12\x14\n\x05value\x18\x01\x20\x01(\x01R\x05value\"\"\n\nFloatVa\
    lue\x12\x14\n\x05value\x18\x01\x20\x01(\x02R\x05value\"\"\n\nInt64Value\
    \x12\x14\n\x05value\x18\x01\x20\x01(\x03R\x05value\"#\n\x0bUInt64Value\
    \x12\x14\n\x05value\x18\x01\x20\x01(\x04R\x05value\"\"\n\nInt32Value\x12\
    \x14\n\x05value\x18\x01\x20\x01(\x05R\x05value\"#\n\x0bUInt32Value\x12\
    \x14\n\x05value\x18\x01\x20\x01(\rR\x05value\"!\n\tBoolValue\x12\x14\n\
    \x05value\x18\x01\x20\x01(\x08R\x05value\"#\n\x0bStringValue\x12\x14\n\
    \x05value\x18\x01\x20\x01(\tR\x05value\"\"\n\nBytesValue\x12\x14\n\x05va\
    lue\x18\x01\x20\x01(\x0cR\x05valueB\x83\x01\n\x13com.google.protobufB\rW\
    rappersProtoP\x01Z1google.golang.org/protobuf/types/known/wrapperspb\xf8\
    \x01\x01\xa2\x02\x03GPB\xaa\x02\x1eGoogle.Protobuf.WellKnownTypesJ\xc6\
    \x1f\n\x06\x12\x04(\0z\x01\n\xdb\x10\n\x01\x0c\x12\x03(\0\x122\xc1\x0c\
    \x20Protocol\x20Buffers\x20-\x20Google's\x20data\x20interchange\x20forma\
    t\n\x20Copyright\x202008\x20Google\x20Inc.\x20\x20All\x20rights\x20reser\
    ved.\n\x20https://developers.google.com/protocol-buffers/\n\n\x20Redistr\
    ibution\x20and\x20use\x20in\x20source\x20and\x20binary\x20forms,\x20with\
    \x20or\x20without\n\x20modification,\x20are\x20permitted\x20provided\x20\
    that\x20the\x20following\x20conditions\x20are\n\x20met:\n\n\x20\x20\x20\
    \x20\x20*\x20Redistributions\x20of\x20source\x20code\x20must\x20retain\
    \x20the\x20above\x20copyright\n\x20notice,\x20this\x20list\x20of\x20cond\
    itions\x20and\x20the\x20following\x20disclaimer.\n\x20\x20\x20\x20\x20*\
    \x20Redistributions\x20in\x20binary\x20form\x20must\x20reproduce\x20the\
    \x20above\n\x20copyright\x20notice,\x20this\x20list\x20of\x20conditions\
    \x20and\x20the\x20following\x20disclaimer\n\x20in\x20the\x20documentatio\
    n\x20and/or\x20other\x20materials\x20provided\x20with\x20the\n\x20distri\
    bution.\n\x20\x20\x20\x20\x20*\x20Neither\x20the\x20name\x20of\x20Google\
    \x20Inc.\x20nor\x20the\x20names\x20of\x20its\n\x20contributors\x20may\
    \x20be\x20used\x20to\x20endorse\x20or\x20promote\x20products\x20derived\
    \x20from\n\x20this\x20software\x20without\x20specific\x20prior\x20writte\
    n\x20permission.\n\n\x20THIS\x20SOFTWARE\x20IS\x20PROVIDED\x20BY\x20THE\
    \x20COPYRIGHT\x20HOLDERS\x20AND\x20CONTRIBUTORS\n\x20\"AS\x20IS\"\x20AND\
    \x20ANY\x20EXPRESS\x20OR\x20IMPLIED\x20WARRANTIES,\x20INCLUDING,\x20BUT\
    \x20NOT\n\x20LIMITED\x20TO,\x20THE\x20IMPLIED\x20WARRANTIES\x20OF\x20MER\
    CHANTABILITY\x20AND\x20FITNESS\x20FOR\n\x20A\x20PARTICULAR\x20PURPOSE\
    \x20ARE\x20DISCLAIMED.\x20IN\x20NO\x20EVENT\x20SHALL\x20THE\x20COPYRIGHT\
    \n\x20OWNER\x20OR\x20CONTRIBUTORS\x20BE\x20LIABLE\x20FOR\x20ANY\x20DIREC\
    T,\x20INDIRECT,\x20INCIDENTAL,\n\x20SPECIAL,\x20EXEMPLARY,\x20OR\x20CONS\
    EQUENTIAL\x20DAMAGES\x20(INCLUDING,\x20BUT\x20NOT\n\x20LIMITED\x20TO,\
    \x20PROCUREMENT\x20OF\x20SUBSTITUTE\x20GOODS\x20OR\x20SERVICES;\x20LOSS\
    \x20OF\x20USE,\n\x20DATA,\x20OR\x20PROFITS;\x20OR\x20BUSINESS\x20INTERRU\
    PTION)\x20HOWEVER\x20CAUSED\x20AND\x20ON\x20ANY\n\x20THEORY\x20OF\x20LIA\
    BILITY,\x20WHETHER\x20IN\x20CONTRACT,\x20STRICT\x20LIABILITY,\x20OR\x20T\
    ORT\n\x20(INCLUDING\x20NEGLIGENCE\x20OR\x20OTHERWISE)\x20ARISING\x20IN\
    \x20ANY\x20WAY\x20OUT\x20OF\x20THE\x20USE\n\x20OF\x20THIS\x20SOFTWARE,\
    \x20EVEN\x20IF\x20ADVISED\x20OF\x20THE\x20POSSIBILITY\x20OF\x20SUCH\x20D\
    AMAGE.\n2\x8c\x04\x20Wrappers\x20for\x20primitive\x20(non-message)\x20ty\
    pes.\x20These\x20types\x20are\x20useful\n\x20for\x20embedding\x20primiti\
    ves\x20in\x20the\x20`google.protobuf.Any`\x20type\x20and\x20for\x20place\
    s\n\x20where\x20we\x20need\x20to\x20distinguish\x20between\x20the\x20abs\
    ence\x20of\x20a\x20primitive\n\x20typed\x20field\x20and\x20its\x20defaul\
    t\x20value.\n\n\x20These\x20wrappers\x20have\x20no\x20meaningful\x20use\
    \x20within\x20repeated\x20fields\x20as\x20they\x20lack\n\x20the\x20abili\
    ty\x20to\x20detect\x20presence\x20on\x20individual\x20elements.\n\x20The\
    se\x20wrappers\x20have\x20no\x20meaningful\x20use\x20within\x20a\x20map\
    \x20or\x20a\x20oneof\x20since\n\x20individual\x20entries\x20of\x20a\x20m\
    ap\x20or\x20fields\x20of\x20a\x20oneof\x20can\x20already\x20detect\x20pr\
    esence.\n\n\x08\n\x01\x02\x12\x03*\0\x18\n\x08\n\x01\x08\x12\x03,\0;\n\t\
    \n\x02\x08%\x12\x03,\0;\n\x08\n\x01\x08\x12\x03-\0\x1f\n\t\n\x02\x08\x1f\
    \x12\x03-\0\x1f\n\x08\n\x01\x08\x12\x03.\0H\n\t\n\x02\x08\x0b\x12\x03.\0\
    H\n\x08\n\x01\x08\x12\x03/\0,\n\t\n\x02\x08\x01\x12\x03/\0,\n\x08\n\x01\
    \x08\x12\x030\0.\n\t\n\x02\x08\x08\x12\x030\0.\n\x08\n\x01\x08\x12\x031\
    \0\"\n\t\n\x02\x08\n\x12\x031\0\"\n\x08\n\x01\x08\x12\x032\0!\n\t\n\x02\
    \x08$\x12\x032\0!\ng\n\x02\x04\0\x12\x047\0:\x01\x1a[\x20Wrapper\x20mess\
    age\x20for\x20`double`.\n\n\x20The\x20JSON\x20representation\x20for\x20`\
    DoubleValue`\x20is\x20JSON\x20number.\n\n\n\n\x03\x04\0\x01\x12\x037\x08\
    \x13\n\x20\n\x04\x04\0\x02\0\x12\x039\x02\x13\x1a\x13\x20The\x20double\
    \x20value.\n\n\x0c\n\x05\x04\0\x02\0\x05\x12\x039\x02\x08\n\x0c\n\x05\
    \x04\0\x02\0\x01\x12\x039\t\x0e\n\x0c\n\x05\x04\0\x02\0\x03\x12\x039\x11\
    \x12\ne\n\x02\x04\x01\x12\x04?\0B\x01\x1aY\x20Wrapper\x20message\x20for\
    \x20`float`.\n\n\x20The\x20JSON\x20representation\x20for\x20`FloatValue`\
    \x20is\x20JSON\x20number.\n\n\n\n\x03\x04\x01\x01\x12\x03?\x08\x12\n\x1f\
    \n\x04\x04\x01\x02\0\x12\x03A\x02\x12\x1a\x12\x20The\x20float\x20value.\
    \n\n\x0c\n\x05\x04\x01\x02\0\x05\x12\x03A\x02\x07\n\x0c\n\x05\x04\x01\
    \x02\0\x01\x12\x03A\x08\r\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03A\x10\x11\
    \ne\n\x02\x04\x02\x12\x04G\0J\x01\x1aY\x20Wrapper\x20message\x20for\x20`\
    int64`.\n\n\x20The\x20JSON\x20representation\x20for\x20`Int64Value`\x20i\
    s\x20JSON\x20string.\n\n\n\n\x03\x04\x02\x01\x12\x03G\x08\x12\n\x1f\n\
    \x04\x04\x02\x02\0\x12\x03I\x02\x12\x1a\x12\x20The\x20int64\x20value.\n\
    \n\x0c\n\x05\x04\x02\x02\0\x05\x12\x03I\x02\x07\n\x0c\n\x05\x04\x02\x02\
    \0\x01\x12\x03I\x08\r\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03I\x10\x11\ng\
    \n\x02\x04\x03\x12\x04O\0R\x01\x1a[\x20Wrapper\x20message\x20for\x20`uin\
    t64`.\n\n\x20The\x20JSON\x20representation\x20for\x20`UInt64Value`\x20is\
    \x20JSON\x20string.\n\n\n\n\x03\x04\x03\x01\x12\x03O\x08\x13\n\x20\n\x04\
    \x04\x03\x02\0\x12\x03Q\x02\x13\x1a\x13\x20The\x20uint64\x20value.\n\n\
    \x0c\n\x05\x04\x03\x02\0\x05\x12\x03Q\x02\x08\n\x0c\n\x05\x04\x03\x02\0\
    \x01\x12\x03Q\t\x0e\n\x0c\n\x05\x04\x03\x02\0\x03\x12\x03Q\x11\x12\ne\n\
    \x02\x04\x04\x12\x04W\0Z\x01\x1aY\x20Wrapper\x20message\x20for\x20`int32\
    `.\n\n\x20The\x20JSON\x20representation\x20for\x20`Int32Value`\x20is\x20\
    JSON\x20number.\n\n\n\n\x03\x04\x04\x01\x12\x03W\x08\x12\n\x1f\n\x04\x04\
    \x04\x02\0\x12\x03Y\x02\x12\x1a\x12\x20The\x20int32\x20value.\n\n\x0c\n\
    \x05\x04\x04\x02\0\x05\x12\x03Y\x02\x07\n\x0c\n\x05\x04\x04\x02\0\x01\
    \x12\x03Y\x08\r\n\x0c\n\x05\x04\x04\x02\0\x03\x12\x03Y\x10\x11\ng\n\x02\
    \x04\x05\x12\x04_\0b\x01\x1a[\x20Wrapper\x20message\x20for\x20`uint32`.\
    \n\n\x20The\x20JSON\x20representation\x20for\x20`UInt32Value`\x20is\x20J\
    SON\x20number.\n\n\n\n\x03\x04\x05\x01\x12\x03_\x08\x13\n\x20\n\x04\x04\
    \x05\x02\0\x12\x03a\x02\x13\x1a\x13\x20The\x20uint32\x20value.\n\n\x0c\n\
    \x05\x04\x05\x02\0\x05\x12\x03a\x02\x08\n\x0c\n\x05\x04\x05\x02\0\x01\
    \x12\x03a\t\x0e\n\x0c\n\x05\x04\x05\x02\0\x03\x12\x03a\x11\x12\no\n\x02\
    \x04\x06\x12\x04g\0j\x01\x1ac\x20Wrapper\x20message\x20for\x20`bool`.\n\
    \n\x20The\x20JSON\x20representation\x20for\x20`BoolValue`\x20is\x20JSON\
    \x20`true`\x20and\x20`false`.\n\n\n\n\x03\x04\x06\x01\x12\x03g\x08\x11\n\
    \x1e\n\x04\x04\x06\x02\0\x12\x03i\x02\x11\x1a\x11\x20The\x20bool\x20valu\
    e.\n\n\x0c\n\x05\x04\x06\x02\0\x05\x12\x03i\x02\x06\n\x0c\n\x05\x04\x06\
    \x02\0\x01\x12\x03i\x07\x0c\n\x0c\n\x05\x04\x06\x02\0\x03\x12\x03i\x0f\
    \x10\ng\n\x02\x04\x07\x12\x04o\0r\x01\x1a[\x20Wrapper\x20message\x20for\
    \x20`string`.\n\n\x20The\x20JSON\x20representation\x20for\x20`StringValu\
    e`\x20is\x20JSON\x20string.\n\n\n\n\x03\x04\x07\x01\x12\x03o\x08\x13\n\
    \x20\n\x04\x04\x07\x02\0\x12\x03q\x02\x13\x1a\x13\x20The\x20string\x20va\
    lue.\n\n\x0c\n\x05\x04\x07\x02\0\x05\x12\x03q\x02\x08\n\x0c\n\x05\x04\
    \x07\x02\0\x01\x12\x03q\t\x0e\n\x0c\n\x05\x04\x07\x02\0\x03\x12\x03q\x11\
    \x12\ne\n\x02\x04\x08\x12\x04w\0z\x01\x1aY\x20Wrapper\x20message\x20for\
    \x20`bytes`.\n\n\x20The\x20JSON\x20representation\x20for\x20`BytesValue`\
    \x20is\x20JSON\x20string.\n\n\n\n\x03\x04\x08\x01\x12\x03w\x08\x12\n\x1f\
    \n\x04\x04\x08\x02\0\x12\x03y\x02\x12\x1a\x12\x20The\x20bytes\x20value.\
    \n\n\x0c\n\x05\x04\x08\x02\0\x05\x12\x03y\x02\x07\n\x0c\n\x05\x04\x08\
    \x02\0\x01\x12\x03y\x08\r\n\x0c\n\x05\x04\x08\x02\0\x03\x12\x03y\x10\x11\
    b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static crate::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: crate::rt::Lazy<crate::descriptor::FileDescriptorProto> = crate::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        crate::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static crate::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: crate::rt::Lazy<crate::reflect::GeneratedFileDescriptor> = crate::rt::Lazy::new();
    static file_descriptor: crate::rt::Lazy<crate::reflect::FileDescriptor> = crate::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(9);
            messages.push(DoubleValue::generated_message_descriptor_data());
            messages.push(FloatValue::generated_message_descriptor_data());
            messages.push(Int64Value::generated_message_descriptor_data());
            messages.push(UInt64Value::generated_message_descriptor_data());
            messages.push(Int32Value::generated_message_descriptor_data());
            messages.push(UInt32Value::generated_message_descriptor_data());
            messages.push(BoolValue::generated_message_descriptor_data());
            messages.push(StringValue::generated_message_descriptor_data());
            messages.push(BytesValue::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            crate::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        crate::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}

'''
'''--- protobuf/src/well_known_types_util/any.rs ---
use crate::message_dyn::MessageDyn;
use crate::reflect::MessageDescriptor;
use crate::well_known_types::any::Any;
use crate::MessageFull;

impl Any {
    fn type_url(type_url_prefix: &str, descriptor: &MessageDescriptor) -> String {
        format!("{}/{}", type_url_prefix, descriptor.full_name())
    }

    fn type_name_from_type_url(type_url: &str) -> Option<&str> {
        match type_url.rfind('/') {
            Some(i) => Some(&type_url[i + 1..]),
            None => None,
        }
    }

    /// Pack any message into `well_known_types::Any` value.
    ///
    /// # Examples
    ///
    /// ```
    /// # use protobuf::MessageFull;
    /// use protobuf::well_known_types::any::Any;
    ///
    /// # fn the_test<MyMessage: MessageFull>(message: &MyMessage) -> protobuf::Result<()> {
    /// let message: &MyMessage = message;
    /// let any = Any::pack(message)?;
    /// assert!(any.is::<MyMessage>());
    /// #   Ok(())
    /// # }
    /// ```
    pub fn pack<M: MessageFull>(message: &M) -> crate::Result<Any> {
        Any::pack_dyn(message)
    }

    /// Pack any message into `well_known_types::Any` value.
    ///
    /// # Examples
    ///
    /// ```
    /// use protobuf::{MessageFull, MessageDyn};
    /// use protobuf::well_known_types::any::Any;
    ///
    /// # fn the_test(message: &dyn MessageDyn) -> protobuf::Result<()> {
    /// let message: &dyn MessageDyn = message;
    /// let any = Any::pack_dyn(message)?;
    /// assert!(any.is_dyn(&message.descriptor_dyn()));
    /// #   Ok(())
    /// # }
    /// ```
    pub fn pack_dyn(message: &dyn MessageDyn) -> crate::Result<Any> {
        Any::pack_with_type_url_prefix(message, "type.googleapis.com")
    }

    fn pack_with_type_url_prefix(
        message: &dyn MessageDyn,
        type_url_prefix: &str,
    ) -> crate::Result<Any> {
        Ok(Any {
            type_url: Any::type_url(type_url_prefix, &message.descriptor_dyn()),
            value: message.write_to_bytes_dyn()?,
            ..Default::default()
        })
    }

    /// Check if `Any` contains a message of given type.
    pub fn is<M: MessageFull>(&self) -> bool {
        self.is_dyn(&M::descriptor())
    }

    /// Check if `Any` contains a message of given type.
    pub fn is_dyn(&self, descriptor: &MessageDescriptor) -> bool {
        match Any::type_name_from_type_url(&self.type_url) {
            Some(type_name) => type_name == descriptor.full_name(),
            None => false,
        }
    }

    /// Extract a message from this `Any`.
    ///
    /// # Returns
    ///
    /// * `Ok(None)` when message type mismatch
    /// * `Err` when parse failed
    pub fn unpack<M: MessageFull>(&self) -> crate::Result<Option<M>> {
        if !self.is::<M>() {
            return Ok(None);
        }
        Ok(Some(M::parse_from_bytes(&self.value)?))
    }

    /// Extract a message from this `Any`.
    ///
    /// # Returns
    ///
    /// * `Ok(None)` when message type mismatch
    /// * `Err` when parse failed
    pub fn unpack_dyn(
        &self,
        descriptor: &MessageDescriptor,
    ) -> crate::Result<Option<Box<dyn MessageDyn>>> {
        if !self.is_dyn(descriptor) {
            return Ok(None);
        }
        let mut message = descriptor.new_instance();
        message.merge_from_bytes_dyn(&self.value)?;
        message.check_initialized_dyn()?;
        Ok(Some(message))
    }
}

'''
'''--- protobuf/src/well_known_types_util/duration.rs ---
use crate::well_known_types::duration::Duration;
use crate::SpecialFields;

impl Duration {
    /// Zero seconds zero nanoseconds.
    pub const ZERO: Duration = Duration {
        seconds: 0,
        nanos: 0,
        special_fields: SpecialFields::new(),
    };
}

/// Convert from `std::time::Duration`.
///
/// # Panics
///
/// If `std::time::Duration` value is outside of `Duration` supported range.
impl From<std::time::Duration> for Duration {
    fn from(duration: std::time::Duration) -> Self {
        Duration {
            seconds: duration.as_secs() as i64,
            nanos: duration.subsec_nanos() as i32,
            ..Default::default()
        }
    }
}

/// Convert to `std::time::Duration`.
///
/// This conversion might be lossy if `std::time::Duration` precision is smaller than nanoseconds.
///
/// # Panics
///
/// If `Duration` value is outside of `std::time::Duration` supported range.
impl Into<std::time::Duration> for Duration {
    fn into(self) -> std::time::Duration {
        assert!(self.seconds >= 0);
        std::time::Duration::from_secs(self.seconds as u64)
            + std::time::Duration::from_nanos(self.nanos as u64)
    }
}

#[cfg(test)]
mod test {
    use crate::well_known_types::duration::Duration;

    #[test]
    fn to_from_duration() {
        fn to_from(duration: Duration, std_time_duration: std::time::Duration) {
            assert_eq!(duration, Duration::from(std_time_duration));
            assert_eq!(
                std_time_duration,
                Into::<std::time::Duration>::into(duration)
            );
        }

        to_from(Duration::ZERO, std::time::Duration::from_secs(0));
        to_from(
            Duration {
                seconds: 4,
                nanos: 123_000_000,
                ..Default::default()
            },
            std::time::Duration::from_millis(4_123),
        );
    }
}

'''
'''--- protobuf/src/well_known_types_util/mod.rs ---
mod any;
mod duration;
mod timestamp;

'''
'''--- protobuf/src/well_known_types_util/timestamp.rs ---
use std::time::Duration;
use std::time::SystemTime;

use crate::well_known_types::timestamp::Timestamp;
use crate::SpecialFields;

impl Timestamp {
    /// Unix epoch value of timestamp.
    pub const UNIX_EPOCH: Timestamp = Timestamp {
        seconds: 0,
        nanos: 0,
        special_fields: SpecialFields::new(),
    };

    /// Return current time as `Timestamp`.
    pub fn now() -> Timestamp {
        Timestamp::from(SystemTime::now())
    }
}

/// Convert from [`Timestamp`].
///
/// # Panics
///
/// This function panics if given `SystemTime` is outside of `Timestamp` range.
impl From<SystemTime> for Timestamp {
    fn from(time: SystemTime) -> Self {
        match time.duration_since(SystemTime::UNIX_EPOCH) {
            Ok(since_epoch) => Timestamp {
                seconds: since_epoch.as_secs() as i64,
                nanos: since_epoch.subsec_nanos() as i32,
                ..Default::default()
            },
            Err(e) => {
                let before_epoch = e.duration();
                Timestamp {
                    seconds: -(before_epoch.as_secs() as i64)
                        - (before_epoch.subsec_nanos() != 0) as i64,
                    nanos: (1_000_000_000 - before_epoch.subsec_nanos() as i32) % 1_000_000_000,
                    ..Default::default()
                }
            }
        }
    }
}

/// Convert into [`SystemTime`].
///
/// The conversion could be lossy if `SystemTime` precision is smaller than nanoseconds.
///
/// # Panics
///
/// This function panics:
/// * if given `Timestamp` is outside of `SystemTime` range
/// * if `Timestamp` is malformed
impl Into<SystemTime> for Timestamp {
    fn into(self) -> SystemTime {
        if self.seconds >= 0 {
            let duration =
                Duration::from_secs(self.seconds as u64) + Duration::from_nanos(self.nanos as u64);
            SystemTime::UNIX_EPOCH + duration
        } else {
            let duration =
                Duration::from_secs(-self.seconds as u64) - Duration::from_nanos(self.nanos as u64);
            SystemTime::UNIX_EPOCH - duration
        }
    }
}

#[cfg(test)]
mod test {
    use std::time::Duration;
    use std::time::SystemTime;

    use crate::well_known_types::timestamp::Timestamp;

    #[test]
    fn to_from_system_time() {
        fn to_from(timestamp: Timestamp, system_time: SystemTime) {
            assert_eq!(timestamp, Timestamp::from(system_time));
            assert_eq!(system_time, Into::<SystemTime>::into(timestamp));
        }

        to_from(Timestamp::UNIX_EPOCH, SystemTime::UNIX_EPOCH);
        to_from(
            Timestamp {
                seconds: 0,
                nanos: 200_000_000,
                ..Default::default()
            },
            SystemTime::UNIX_EPOCH + Duration::from_millis(200),
        );
        to_from(
            Timestamp {
                seconds: 3,
                nanos: 200_000_000,
                ..Default::default()
            },
            SystemTime::UNIX_EPOCH + Duration::from_millis(3_200),
        );
        to_from(
            Timestamp {
                seconds: -1,
                nanos: 800_000_000,
                ..Default::default()
            },
            SystemTime::UNIX_EPOCH - Duration::from_millis(200),
        );
        to_from(
            Timestamp {
                seconds: -4,
                nanos: 800_000_000,
                ..Default::default()
            },
            SystemTime::UNIX_EPOCH - Duration::from_millis(3_200),
        );
    }
}

'''
'''--- protobuf/src/wire_format.rs ---
//! Constants used in serializations.

use crate::descriptor::field_descriptor_proto;
use crate::error::WireError;

/// Tag occupies three bits.
pub(crate) const TAG_TYPE_BITS: u32 = 3;
/// Apply this mask to varint value to obtain a tag.
pub(crate) const TAG_TYPE_MASK: u32 = (1u32 << TAG_TYPE_BITS as usize) - 1;
/// Max possible field number
pub(crate) const FIELD_NUMBER_MAX: u32 = 0x1fffffff;

pub(crate) const MAX_MESSAGE_SIZE: u64 = i32::MAX as u64;

#[inline]
pub(crate) fn check_message_size(size: u64) -> crate::Result<u32> {
    if size <= MAX_MESSAGE_SIZE {
        Ok(size as u32)
    } else {
        #[cold]
        fn message_too_large(size: u64) -> crate::Error {
            WireError::MessageTooLarge(size).into()
        }

        Err(message_too_large(size))
    }
}

/// All supported "wire types" are listed in this enum.
#[derive(PartialEq, Eq, Clone, Copy, Debug)]
pub enum WireType {
    /// Variable-length integer
    Varint = 0,
    /// 32-bit field (e. g. `fixed64` or `double`)
    Fixed64 = 1,
    /// Length-delimited field
    LengthDelimited = 2,
    /// Groups are not supported in rust-protobuf
    StartGroup = 3,
    /// Groups are not supported in rust-protobuf
    EndGroup = 4,
    /// 32-bit field (e. g. `fixed32` or `float`)
    Fixed32 = 5,
}

impl WireType {
    /// Construct `WireType` from number, or return `None` if type is unknown.
    pub fn new(n: u32) -> Option<WireType> {
        match n {
            0 => Some(WireType::Varint),
            1 => Some(WireType::Fixed64),
            2 => Some(WireType::LengthDelimited),
            3 => Some(WireType::StartGroup),
            4 => Some(WireType::EndGroup),
            5 => Some(WireType::Fixed32),
            _ => None,
        }
    }

    #[doc(hidden)]
    pub fn for_type(field_type: field_descriptor_proto::Type) -> WireType {
        use field_descriptor_proto::Type;
        match field_type {
            Type::TYPE_INT32 => WireType::Varint,
            Type::TYPE_INT64 => WireType::Varint,
            Type::TYPE_UINT32 => WireType::Varint,
            Type::TYPE_UINT64 => WireType::Varint,
            Type::TYPE_SINT32 => WireType::Varint,
            Type::TYPE_SINT64 => WireType::Varint,
            Type::TYPE_BOOL => WireType::Varint,
            Type::TYPE_ENUM => WireType::Varint,
            Type::TYPE_FIXED32 => WireType::Fixed32,
            Type::TYPE_FIXED64 => WireType::Fixed64,
            Type::TYPE_SFIXED32 => WireType::Fixed32,
            Type::TYPE_SFIXED64 => WireType::Fixed64,
            Type::TYPE_FLOAT => WireType::Fixed32,
            Type::TYPE_DOUBLE => WireType::Fixed64,
            Type::TYPE_STRING => WireType::LengthDelimited,
            Type::TYPE_BYTES => WireType::LengthDelimited,
            Type::TYPE_MESSAGE => WireType::LengthDelimited,
            Type::TYPE_GROUP => WireType::LengthDelimited, // not true
        }
    }
}

/// Parsed field tag (a pair of field number and wire type)
#[derive(Clone, Copy, PartialEq, Eq, Debug)]
pub(crate) struct Tag {
    field_number: u32,
    wire_type: WireType,
}

impl Tag {
    /// Fold tag to a number to be serialized.
    pub(crate) fn value(self) -> u32 {
        (self.field_number << TAG_TYPE_BITS) | (self.wire_type as u32)
    }

    /// Extract wire type and field number from integer tag
    pub(crate) fn new(value: u32) -> crate::Result<Tag> {
        let wire_type = WireType::new(value & TAG_TYPE_MASK);
        if wire_type.is_none() {
            return Err(WireError::IncorrectTag(value).into());
        }
        let field_number = value >> TAG_TYPE_BITS;
        if field_number == 0 {
            return Err(WireError::IncorrectTag(value).into());
        }
        Ok(Tag {
            field_number,
            wire_type: wire_type.unwrap(),
        })
    }

    /// Construct a tag from a field number and wire type.
    ///
    /// # Panics
    ///
    /// If field number is outside of valid range.
    pub(crate) fn make(field_number: u32, wire_type: WireType) -> Tag {
        assert!(field_number > 0 && field_number <= FIELD_NUMBER_MAX);
        Tag {
            field_number,
            wire_type,
        }
    }

    /// Get field number and wire type
    pub(crate) fn unpack(self) -> (u32, WireType) {
        (self.field_number(), self.wire_type())
    }

    /// Get wire type
    fn wire_type(self) -> WireType {
        self.wire_type
    }

    /// Get field number
    pub(crate) fn field_number(self) -> u32 {
        self.field_number
    }
}

'''
'''--- protobuf/src/zigzag.rs ---
// ZigZag endoging used for efficient transfer of signed integers
// https://developers.google.com/protocol-buffers/docs/encoding#types

use crate::rt::compute_raw_varint32_size;
use crate::rt::compute_raw_varint64_size;

pub(crate) fn decode_zig_zag_32(n: u32) -> i32 {
    ((n >> 1) as i32) ^ (-((n & 1) as i32))
}

pub(crate) fn decode_zig_zag_64(n: u64) -> i64 {
    ((n >> 1) as i64) ^ (-((n & 1) as i64))
}

pub(crate) fn encode_zig_zag_32(n: i32) -> u32 {
    ((n << 1) ^ (n >> 31)) as u32
}

pub(crate) fn encode_zig_zag_64(n: i64) -> u64 {
    ((n << 1) ^ (n >> 63)) as u64
}

/// Helper trait implemented by integer types which could be encoded as zigzag varint.
pub(crate) trait ProtobufVarintZigzag {
    /// Size of self when encoded as zigzag varint.
    fn len_varint_zigzag(&self) -> u64;
}

impl ProtobufVarintZigzag for i64 {
    fn len_varint_zigzag(&self) -> u64 {
        compute_raw_varint64_size(encode_zig_zag_64(*self))
    }
}

impl ProtobufVarintZigzag for i32 {
    fn len_varint_zigzag(&self) -> u64 {
        compute_raw_varint32_size(encode_zig_zag_32(*self))
    }
}

#[cfg(test)]
mod test {

    use super::decode_zig_zag_32;
    use super::decode_zig_zag_64;
    use super::encode_zig_zag_32;
    use super::encode_zig_zag_64;

    #[test]
    fn test_zig_zag() {
        fn test_zig_zag_pair_64(decoded: i64, encoded: u64) {
            assert_eq!(decoded, decode_zig_zag_64(encoded));
            assert_eq!(encoded, encode_zig_zag_64(decoded));
        }

        fn test_zig_zag_pair(decoded: i32, encoded: u32) {
            assert_eq!(decoded, decode_zig_zag_32(encoded));
            assert_eq!(encoded, encode_zig_zag_32(decoded));
            test_zig_zag_pair_64(decoded as i64, encoded as u64);
        }

        test_zig_zag_pair(0, 0);
        test_zig_zag_pair(-1, 1);
        test_zig_zag_pair(1, 2);
        test_zig_zag_pair(-2, 3);
        test_zig_zag_pair(2147483647, 4294967294);
        test_zig_zag_pair(-2147483648, 4294967295);
        test_zig_zag_pair_64(9223372036854775807, 18446744073709551614);
        test_zig_zag_pair_64(-9223372036854775808, 18446744073709551615);
    }
}

'''
'''--- protoc-bin/Cargo.toml ---
[package]
name = "protoc-bin"
version = "0.0.0"
authors = ["Stepan Koltsov <stepan.koltsov@gmail.com>"]
license = "MIT"
homepage = "https://github.com/stepancheg/rust-protobuf/"
repository = "https://github.com/stepancheg/rust-protobuf/"
description = """
Internal crate to rust-protobuf
"""
publish = false

[lib]
doctest = false
bench = false

[dependencies]
protoc-bin-vendored = "=3.0.0"

[package.metadata.docs.rs]
all-features = true

'''
'''--- protoc-bin/src/bin/protoc-bin-print-paths.rs ---
fn main() {
    println!(
        "PROTOC={}",
        protoc_bin_vendored::protoc_bin_path()
            .unwrap()
            .to_str()
            .unwrap()
    );
    println!(
        "PROTOBUF_INCLUDE={}",
        protoc_bin_vendored::include_path()
            .unwrap()
            .to_str()
            .unwrap()
    );
}

'''
'''--- protoc-bin/src/lib.rs ---
//! Just pull the dependency on `protoc-bin-vendored`, nothing to see here.

'''
'''--- test-crates/README.md ---
# Test for rust-protobuf

Larger tests for rust-protobuf crates.

(Small tests are implemented as unit tests inside the respective crates.)

'''
'''--- test-crates/interop/cxx/compile.sh ---
#!/bin/sh

set -ex

cd $(dirname $0)

if test -n "$PROTOBUF_PREFIX"; then
    if test -n "$PKG_CONFIG_PATH"; then
        PKG_CONFIG_PATH=":$PKG_CONFIG_PATH"
    fi
    export PKG_CONFIG_PATH="$PROTOBUF_PREFIX/lib/pkgconfig$PKG_CONFIG_PATH"
fi

protoc --cpp_out=. interop_pb.proto
c++ --version
c++ -std=c++11 -Wall -O1 \
    interop.cc interop_pb.pb.cc \
    `pkg-config --cflags --libs protobuf` \
    -o interop
./interop self-test

# vim: set ts=4 sw=4 et:

'''
'''--- test-crates/perftest/bytes/Cargo.toml ---
[package]
name = "perftest-bytes"
version = "0.0.0"
authors = ["Stepan Koltsov <stepan.koltsov@gmail.com>"]
publish = false
edition = "2021"

[lib]
test = false
doctest = false

[features]
default = []
with-bytes = ["bytes", "protobuf/with-bytes"]

[dependencies]
bytes = { version = "1.1", optional = true }

[dependencies.protobuf]
path = "../../../protobuf"

[build-dependencies]
protobuf-codegen = { path = "../../../protobuf-codegen" }

'''
'''--- test-crates/perftest/bytes/benches/vs.rs ---
// `cargo test --benches` and `#[feature(test)]` work only in nightly
#![cfg(rustc_nightly)]
#![cfg(feature = "bytes")]
#![feature(test)]

extern crate test;

use std::fmt::Write as _;

use bytes::Bytes;
use perftest_bytes::messages;
use protobuf::Message;

fn make_string_of_len(len: usize) -> String {
    let mut s = String::new();
    for i in 0..len {
        write!(s, "{}", i % 10).expect("unreachable");
    }
    s
}

fn make_repeated(len: usize) -> Vec<u8> {
    let mut m = messages::TestMessage::new();

    for i in 0..100 {
        m.sr.push(make_string_of_len(i % len));
        m.br.push(make_string_of_len((i + len / 2) % len).into_bytes());
    }

    m.write_to_bytes().expect("write")
}

#[bench]
fn parse_repeated_small_regular(b: &mut test::Bencher) {
    let bs = make_repeated(30);
    b.iter(|| messages::TestMessage::parse_from_bytes(&bs).expect("parse"))
}

#[bench]
fn parse_repeated_small_bytes(b: &mut test::Bencher) {
    let bs = Bytes::from(make_repeated(30));
    b.iter(|| messages::TestMessageWithBytes::parse_from_tokio_bytes(&bs).expect("parse"))
}

#[bench]
fn parse_repeated_medium_regular(b: &mut test::Bencher) {
    let bs = make_repeated(300);
    b.iter(|| messages::TestMessage::parse_from_bytes(&bs).expect("parse"))
}

#[bench]
fn parse_repeated_medium_bytes(b: &mut test::Bencher) {
    let bs = Bytes::from(make_repeated(300));
    b.iter(|| messages::TestMessageWithBytes::parse_from_tokio_bytes(&bs).expect("parse"))
}

#[bench]
fn parse_repeated_large_regular(b: &mut test::Bencher) {
    let bs = make_repeated(3000);
    b.iter(|| messages::TestMessage::parse_from_bytes(&bs).expect("parse"))
}

#[bench]
fn parse_repeated_large_bytes(b: &mut test::Bencher) {
    let bs = Bytes::from(make_repeated(3000));
    b.iter(|| messages::TestMessageWithBytes::parse_from_tokio_bytes(&bs).expect("parse"))
}

#[bench]
fn parse_repeated_huge_regular(b: &mut test::Bencher) {
    let bs = make_repeated(30000);
    b.iter(|| messages::TestMessage::parse_from_bytes(&bs).expect("parse"))
}

#[bench]
fn parse_repeated_huge_bytes(b: &mut test::Bencher) {
    let bs = Bytes::from(make_repeated(30000));
    b.iter(|| messages::TestMessageWithBytes::parse_from_tokio_bytes(&bs).expect("parse"))
}

'''
'''--- test-crates/perftest/bytes/build.rs ---
use std::env;
use std::io::Read;
use std::process;

use protobuf_codegen::Codegen;
use protobuf_codegen::Customize;

fn generate_protos() {
    Codegen::new()
        .pure()
        .out_dir("src")
        .input("src/messages.proto")
        .includes(&["src", "../../proto"])
        .customize(Customize::default().gen_mod_rs(false))
        .run_from_script();
}

// % rustc +stable --version
// rustc 1.26.0 (a77568041 2018-05-07)
// % rustc +beta --version
// rustc 1.27.0-beta.1 (03fb2f447 2018-05-09)
// % rustc +nightly --version
// rustc 1.27.0-nightly (acd3871ba 2018-05-10)
fn version_is_nightly(version: &str) -> bool {
    version.contains("nightly")
}

fn export_rustc_cfg() {
    let rustc = env::var("RUSTC").expect("RUSTC unset");

    let mut child = process::Command::new(rustc)
        .args(&["--version"])
        .stdin(process::Stdio::null())
        .stdout(process::Stdio::piped())
        .spawn()
        .expect("spawn rustc");

    let mut rustc_version = String::new();

    child
        .stdout
        .as_mut()
        .expect("stdout")
        .read_to_string(&mut rustc_version)
        .expect("read_to_string");
    assert!(child.wait().expect("wait").success());

    if version_is_nightly(&rustc_version) {
        println!("cargo:rustc-cfg=rustc_nightly");
    }
}

fn main() {
    generate_protos();

    export_rustc_cfg();
}

'''
'''--- test-crates/perftest/bytes/src/lib.rs ---
#![cfg(feature = "bytes")]

pub mod messages;

'''
'''--- test-crates/perftest/misc/Cargo.toml ---
[package]
name = "protobuf-perftest-misc"
version = "0.0.0"
authors = ["Stepan Koltsov <stepan.koltsov@gmail.com>"]
publish = false
edition = "2021"

[lib]
test = false
doctest = false

[features]
default = []
with-bytes = ["bytes", "protobuf/with-bytes"]

[dependencies]
bytes = { version = "1.1", optional = true }
fastrand = "1.4.0"

[dependencies.protobuf]
path = "../../../protobuf"
features = ["with-bytes"]

[build-dependencies]
protobuf-codegen = { path = "../../../protobuf-codegen" }

'''
'''--- test-crates/perftest/misc/build.rs ---
use std::env;
use std::io::Read;
use std::process;

// % rustc +stable --version
// rustc 1.26.0 (a77568041 2018-05-07)
// % rustc +beta --version
// rustc 1.27.0-beta.1 (03fb2f447 2018-05-09)
// % rustc +nightly --version
// rustc 1.27.0-nightly (acd3871ba 2018-05-10)
fn version_is_nightly(version: &str) -> bool {
    version.contains("nightly")
}

fn export_rustc_cfg() {
    let rustc = env::var("RUSTC").expect("RUSTC unset");

    let mut child = process::Command::new(rustc)
        .args(&["--version"])
        .stdin(process::Stdio::null())
        .stdout(process::Stdio::piped())
        .spawn()
        .expect("spawn rustc");

    let mut rustc_version = String::new();

    child
        .stdout
        .as_mut()
        .expect("stdout")
        .read_to_string(&mut rustc_version)
        .expect("read_to_string");
    assert!(child.wait().expect("wait").success());

    if version_is_nightly(&rustc_version) {
        println!("cargo:rustc-cfg=rustc_nightly");
    }
}

fn main() {
    export_rustc_cfg();
}

'''
'''--- test-crates/perftest/misc/src/bin/read_varint.rs ---
use std::env;
use std::hint;
use std::process;
use std::time::Instant;

use protobuf::CodedInputStream;
use protobuf::CodedOutputStream;

fn main() {
    let args: Vec<String> = env::args().skip(1).collect();
    if args.len() != 3 {
        eprintln!(
            "usage: {} <limit> <count> <iter>",
            env::args().next().unwrap()
        );
        process::exit(1);
    }

    let upper: u64 = args[0].parse().unwrap();
    let count = args[1].parse().unwrap();
    let iter = args[2].parse().unwrap();

    let rng = fastrand::Rng::with_seed(17);

    let mut data = Vec::new();
    let mut os = CodedOutputStream::vec(&mut data);
    for _ in 0..count {
        let v = match upper {
            0 => rng.u64(..),
            x => rng.u64(..x),
        };
        os.write_raw_varint64(v).unwrap();
    }
    os.flush().unwrap();
    drop(os);

    let br = iter / 10;

    let start = Instant::now();

    for i in 0..iter {
        if i % br == 0 {
            eprintln!("{}", i / br);
        }
        let mut is = CodedInputStream::from_bytes(hint::black_box(&data));
        while !is.eof().unwrap() {
            hint::black_box(is.read_raw_varint64().unwrap());
        }
    }

    let elapsed = start.elapsed();
    let per_read = elapsed.as_secs_f64() / (iter as f64) / (count as f64);
    eprintln!("{:.3}ns per iter", per_read * 1_000_000_000.0);
}

'''
'''--- test-crates/perftest/misc/src/lib.rs ---

'''
'''--- test-crates/perftest/vs-cxx/Cargo.toml ---
[package]
name = "rust-protobuf-perftest"
version = "0.0.0"
authors = ["Stepan Koltsov <stepan.koltsov@gmail.com>"]
publish = false
edition = "2021"

[features]
default = []
proto3 = []
with-bytes = ["protobuf/with-bytes"]

[dependencies.protobuf]
path = "../../../protobuf"

[dependencies]
rand = "~0.5"

[build-dependencies]
protobuf-codegen = { path = "../../../protobuf-codegen" }

[[bin]]

name = "rust-protobuf-perftest"
path = "perftest.rs"
test = false

'''
'''--- test-crates/perftest/vs-cxx/build-perftest-cxx.sh ---
#!/bin/sh -ex

protoc --cpp_out=. ./perftest_data.proto
clang++ -std=c++11 -O3 -g -Wall -o perftest-cxx perftest-cxx.cxx perftest_data.pb.cc -lprotobuf

# vim: set ts=4 sw=4 et:

'''
'''--- test-crates/perftest/vs-cxx/build-perftest-data.sh ---
#!/bin/sh -ex

cd $(dirname $0)
protoc ./perftest_data.proto --encode=PerftestData < perftest_data.pbtxt > perftest_data.pbbin

# vim: set ts=4 sw=4 et:

'''
'''--- test-crates/perftest/vs-cxx/build-perftest.sh ---
#!/bin/sh -ex

cd $(dirname $0)

./build-perftest-data.sh
cargo build --release
./build-perftest-cxx.sh

# vim: set ts=4 sw=4 et:

'''
'''--- test-crates/perftest/vs-cxx/build.rs ---
use protobuf_codegen::Codegen;
use protobuf_codegen::Customize;

fn main() {
    Codegen::new()
        .pure()
        .out_dir(".")
        .include(".")
        .input("perftest_data.proto")
        .customize(Customize::default().gen_mod_rs(false))
        .run_from_script();
}

'''
'''--- test-crates/perftest/vs-cxx/perftest.rs ---
use std::fs::File;
use std::path::Path;
use std::time::Instant;

use perftest_data::PerftestData;
use protobuf::Message;
use protobuf::MessageFull;
use rand::Rng;
use rand::SeedableRng;
use rand::StdRng;

mod perftest_data;

fn measure_ns<R, F: FnMut() -> R>(mut f: F) -> (u64, R) {
    let start = Instant::now();
    let r = f();
    (start.elapsed().as_nanos() as u64, r)
}

fn measure_and_print<R, F: FnMut() -> R>(title: &str, iter: u64, f: F) -> R {
    let (ns, r) = measure_ns(f);
    let ns_per_iter = ns / iter;
    println!("{}: {} ns per iter", title, ns_per_iter);
    r
}

struct TestRunner {
    data_size: u32,
    selected: Option<String>,
    any_matched: bool,
}

impl TestRunner {
    fn run_test<M: MessageFull + Clone + PartialEq>(&self, name: &str, data: &[M]) {
        assert!(data.len() > 0, "empty string for test: {}", name);

        let mut rng: StdRng = SeedableRng::from_seed([
            10, 20, 30, 40, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0,
        ]);

        let mut random_data: Vec<M> = Vec::new();

        let mut total_size = 0;
        while total_size < self.data_size {
            let ref item = data[rng.gen_range(0, data.len())];
            random_data.push(item.clone());
            total_size += item.compute_size() as u32;
        }

        let mut buf = Vec::new();
        measure_and_print(
            &format!("{}: write", name),
            random_data.len() as u64,
            || {
                for m in &random_data {
                    m.write_length_delimited_to_vec(&mut buf).unwrap();
                }
            },
        );

        let read_data =
            measure_and_print(&format!("{}: read", name), random_data.len() as u64, || {
                let mut r = Vec::new();
                let mut coded_input_stream = protobuf::CodedInputStream::from_bytes(&buf);
                while !coded_input_stream.eof().unwrap() {
                    r.push(coded_input_stream.read_message().unwrap());
                }
                r
            });

        assert_eq!(random_data, read_data);

        let merged = measure_and_print(
            &format!("{}: read reuse", name),
            random_data.len() as u64,
            || {
                let mut coded_input_stream = protobuf::CodedInputStream::from_bytes(&buf);
                let mut msg: M = Message::new();
                let mut count = 0;
                while !coded_input_stream.eof().unwrap() {
                    msg.clear();
                    coded_input_stream.merge_message(&mut msg).unwrap();
                    count += 1;
                }
                count
            },
        );

        assert_eq!(random_data.len(), merged);
    }

    fn test<M: MessageFull + Clone + PartialEq>(&mut self, name: &str, data: &[M]) {
        if self.selected.as_ref().map(|s| *s == name).unwrap_or(true) {
            self.run_test(name, data);
            self.any_matched = true;
        }
    }

    fn check(&self) {
        if !self.any_matched {
            let name = self.selected.as_ref().map(|s| &s[..]).unwrap_or("bug");
            panic!("no tests found with name {}", name);
        }
    }
}

fn main() {
    let args = std::env::args().collect::<Vec<_>>();
    if args.len() > 3 {
        panic!("usage: {} [data_size] [test]", args[0])
    }
    let data_size = args
        .iter()
        .nth(1)
        .map(|x| x.parse().unwrap())
        .unwrap_or(1000000);
    let selected = args.iter().nth(2).cloned();

    let mut runner = TestRunner {
        selected: selected,
        any_matched: false,
        data_size: data_size,
    };

    let mut is = File::open(&Path::new("perftest_data.pbbin")).unwrap();
    let test_data = PerftestData::parse_from_reader(&mut is).unwrap();

    runner.test("test1", &test_data.test1);
    runner.test("test_repeated_bool", &test_data.test_repeated_bool);
    runner.test(
        "test_repeated_packed_int32",
        &test_data.test_repeated_packed_int32,
    );
    runner.test("test_repeated_messages", &test_data.test_repeated_messages);
    runner.test("test_optional_messages", &test_data.test_optional_messages);
    runner.test("test_strings", &test_data.test_strings);
    runner.test("test_small_bytearrays", &test_data.test_small_bytearrays);
    runner.test("test_large_bytearrays", &test_data.test_large_bytearrays);
    runner.check();
}

'''
'''--- test-crates/protobuf-codegen-identical-test/Cargo.toml ---
[package]
name = "protobuf-codegen-identical-test"
version = "0.0.0"
authors = ["Nikhil Benesch <nikhil.benesch@gmail.com>"]
publish = false
edition = "2021"
description = "Test protoc-based and pure rust codegen produce identical output"

[lib]
test = false
doctest = false

[dev-dependencies]
anyhow = "1.0.57"
tempfile = "3"
regex = "1.3.9"

protoc-bin-vendored = "=3.0.0"

protobuf = { path = "../../protobuf" }
protobuf-support = { path = "../../protobuf-support" }
protobuf-codegen = { path = "../../protobuf-codegen" }
protobuf-test-common = { path = "../../test-crates/protobuf-test-common" }
protobuf-parse = { path = "../../protobuf-parse" }

'''
'''--- test-crates/protobuf-codegen-identical-test/src/lib.rs ---

'''
'''--- test-crates/protobuf-codegen-identical-test/tests/diff.rs ---
use std::fmt::Write as _;
use std::fs;
use std::path::Path;
use std::path::PathBuf;
use std::path::MAIN_SEPARATOR;
use std::process::Command;
use std::process::Stdio;
use std::str;

use anyhow::Context;
use protobuf::descriptor::field_descriptor_proto;
use protobuf::descriptor::DescriptorProto;
use protobuf::descriptor::EnumDescriptorProto;
use protobuf::descriptor::FieldDescriptorProto;
use protobuf::descriptor::FileDescriptorProto;
use protobuf::descriptor::FileDescriptorSet;
use protobuf::descriptor::MethodDescriptorProto;
use protobuf::descriptor::OneofDescriptorProto;
use protobuf::descriptor::ServiceDescriptorProto;
use protobuf::Message;
use protobuf_codegen::Codegen;
use protobuf_parse::Parser;
use protobuf_support::lexer::float::parse_protobuf_float;
use protobuf_test_common::build::copy_tests_v2_v3;
use protobuf_test_common::build::glob_simple;
use regex::Regex;

fn to_paths(iter: impl IntoIterator<Item = impl Into<String>>) -> Vec<PathBuf> {
    iter.into_iter()
        .map(|item| item.into().replace(MAIN_SEPARATOR, "/").into())
        .collect()
}

#[derive(Default, Debug)]
struct TestStats {
    passed: u32,
    passed_marked_skip: u32,
    skipped: u32,
    failed: u32,
}

fn normalize_generated_file(contents: &str) -> String {
    let parsed_by = Regex::new("^// \\.proto file is parsed by.*").unwrap();

    let mut r = String::new();
    let mut inside_descriptor_data = false;
    for line in contents.lines() {
        let line = if inside_descriptor_data {
            if line == "\";" {
                inside_descriptor_data = false;
                line.to_owned()
            } else {
                continue;
            }
        } else if line.starts_with("static file_descriptor_proto_data") {
            inside_descriptor_data = true;
            line.to_owned()
        } else {
            parsed_by.replace(line, "").into_owned()
        };

        writeln!(&mut r, "{}", line).unwrap();
    }

    // sanity check
    assert!(!inside_descriptor_data);

    r
}

fn normalize_generated_file_in_place(path: &Path) {
    let contents = fs::read_to_string(path).unwrap();
    let contents = normalize_generated_file(&contents);
    fs::write(path, &contents).unwrap();
}

fn print_diff(dir: &Path, a: &Path, b: &Path) {
    if cfg!(windows) {
        // likely we don't have `diff` command on Windows
        return;
    }

    // sanity check
    let mut a_full = dir.to_path_buf();
    a_full.push(a);
    assert!(a_full.exists());
    let mut b_full = dir.to_path_buf();
    b_full.push(b);
    assert!(b_full.exists());

    // Not using difference crate because it's slow for large files
    let output = Command::new("diff")
        .current_dir(dir)
        .arg("-U10")
        .arg(a)
        .arg(b)
        .stdin(Stdio::null())
        .stdout(Stdio::piped())
        .stderr(Stdio::piped())
        .output()
        .unwrap();

    print!("{}", str::from_utf8(&output.stdout).unwrap());
    print!("{}", str::from_utf8(&output.stderr).unwrap());
}

fn normalize_descriptor_set(fds: &mut FileDescriptorSet) {
    for desc in &mut fds.file {
        normalize_file_descriptor(desc)
    }
}

fn normalize_file_descriptor(desc: &mut FileDescriptorProto) {
    if !desc.has_syntax() {
        desc.set_syntax("proto2".into())
    }
    for desc in &mut *desc.message_type {
        normalize_descriptor(desc)
    }
    for desc in &mut desc.enum_type {
        normalize_enum_descriptor(desc)
    }

    for desc in &mut desc.extension {
        desc.options.mut_or_insert_default();
    }
    desc.options.mut_or_insert_default();

    for service in &mut desc.service {
        normalize_service(service);
    }

    // for unittest_custom_options.proto where a custom option
    // is an extension. Probably nobody outside of Google uses it.
    desc.options
        .mut_or_insert_default()
        .mut_unknown_fields()
        .remove(15478479);
}

fn normalize_enum_descriptor(desc: &mut EnumDescriptorProto) {
    desc.options.mut_or_insert_default();

    for value in &mut desc.value {
        value.options.mut_or_insert_default();
    }
}

fn normalize_oneof_descriptor(desc: &mut OneofDescriptorProto) {
    desc.options.mut_or_insert_default();
}

fn normalize_descriptor(desc: &mut DescriptorProto) {
    for desc in &mut desc.nested_type {
        normalize_descriptor(desc);
    }
    for desc in &mut desc.enum_type {
        normalize_enum_descriptor(desc);
    }
    for desc in &mut desc.oneof_decl {
        normalize_oneof_descriptor(desc);
    }

    desc.options.mut_or_insert_default();

    // group are not supported
    desc.options
        .mut_or_insert_default()
        .mut_unknown_fields()
        .remove(7636463);

    for field in &mut desc.field {
        normalize_field(field);
    }

    for ext in &mut desc.extension {
        ext.options.mut_or_insert_default();
    }

    for ext in &mut desc.extension_range {
        // If ext range end exceeds max field number,
        // the actual upper limit does not matter.
        // protoc is not consistent in behavior thus flush
        // the value to some arbitrary compatible value.
        if ext.has_end() && ext.end() >= 0x20000000 {
            ext.set_end(0x20000000);
        }
    }
}

fn normalize_method(method: &mut MethodDescriptorProto) {
    method.options.mut_or_insert_default();
}

fn normalize_service(service: &mut ServiceDescriptorProto) {
    for m in &mut service.method {
        normalize_method(m);
    }

    service.options.mut_or_insert_default();
}

fn normalize_field(field: &mut FieldDescriptorProto) {
    field.options.mut_or_insert_default();

    if field.has_default_value() {
        if field.type_() == field_descriptor_proto::Type::TYPE_FLOAT {
            field.set_default_value(format!(
                "{}",
                parse_protobuf_float(field.default_value()).unwrap()
            ));
        }
    }
}

fn pretty_message<M: protobuf::MessageFull>(message: &M) -> String {
    format!("{:#}", message)
}

fn descriptor_for_file<'a>(fds: &'a FileDescriptorSet, file_name: &str) -> &'a FileDescriptorProto {
    for file in &fds.file {
        if Path::new(file.name()).file_name().unwrap() == Path::new(file_name).file_name().unwrap()
        {
            return file;
        }
    }
    panic!(
        "file not found: {}; all files: {}",
        file_name,
        fds.file
            .iter()
            .map(|f| f.name())
            .collect::<Vec<_>>()
            .join(", ")
    );
}

fn join(a: &str, b: &str) -> String {
    if a == "." {
        b.to_owned()
    } else {
        format!("{}/{}", a, b)
    }
}

fn strip_prefix<'a>(path: &'a Path, prefix: &Path) -> &'a Path {
    if prefix == Path::new(".") {
        path
    } else {
        path.strip_prefix(prefix)
            .with_context(|| format!("strip_prefix({:?}, {:?})", path, prefix))
            .unwrap()
    }
}

fn test_diff_in<F>(root: &str, sources_dir: &str, include: &str, should_skip: F)
where
    F: Fn(&str) -> bool,
{
    let mut stats = TestStats {
        passed: 0,
        passed_marked_skip: 0,
        skipped: 0,
        failed: 0,
    };

    let include_root = join(root, include);

    let include_full = join(root, include);
    let s_full = join(root, sources_dir);

    let inputs_glob = format!("{}/*.proto*", s_full);
    let inputs = to_paths(glob_simple(&inputs_glob));
    assert!(!inputs.is_empty(), "glob is empty: {}", inputs_glob);
    let includes = to_paths(vec![include_full.as_str(), "../../proto"]);

    let temp_dir = tempfile::Builder::new()
        .prefix("protobuf-codegen-identical-test")
        .tempdir()
        .unwrap();

    let protoc_dir = format!("{}/protoc", temp_dir.path().to_str().unwrap());
    let pure_dir = format!("{}/pure", temp_dir.path().to_str().unwrap());

    fs::create_dir(&protoc_dir).unwrap();
    fs::create_dir(&pure_dir).unwrap();

    Codegen::new()
        .protoc()
        .protoc_path(&protoc_bin_vendored::protoc_bin_path().unwrap())
        .capture_stderr()
        .inputs(&inputs)
        .includes(&includes)
        .out_dir(&protoc_dir)
        .run()
        .unwrap();

    Codegen::new()
        .pure()
        .inputs(&inputs)
        .includes(&includes)
        .out_dir(&pure_dir)
        .run()
        .unwrap();

    let mut protoc_descriptors = Parser::new()
        .protoc()
        .includes(&includes)
        .inputs(&inputs)
        .file_descriptor_set()
        .unwrap();
    let mut pure_descriptors = Parser::new()
        .pure()
        .includes(&includes)
        .inputs(&inputs)
        .file_descriptor_set()
        .unwrap();
    normalize_descriptor_set(&mut protoc_descriptors);
    normalize_descriptor_set(&mut pure_descriptors);

    for input in &inputs {
        let label = strip_prefix(input, Path::new(root)).to_str().unwrap();
        let proto_file_name = strip_prefix(input, Path::new(&include_root))
            .to_str()
            .unwrap();
        let proto_name = input.file_name().unwrap().to_str().unwrap();
        let rs_name = protobuf_codegen::proto_name_to_rs(proto_name);
        let protoc_rs = format!("{}/{}", protoc_dir, rs_name);
        let pure_rs = format!("{}/{}", pure_dir, rs_name);

        normalize_generated_file_in_place(Path::new(&protoc_rs));
        normalize_generated_file_in_place(Path::new(&pure_rs));

        let protoc_rs_contents =
            fs::read_to_string(&protoc_rs).expect(&format!("while reading {}", protoc_rs));
        let pure_rs_contents =
            fs::read_to_string(&pure_rs).expect(&format!("while reading {}", pure_rs));

        let protoc_descriptor_for_file = descriptor_for_file(&protoc_descriptors, &proto_file_name);
        let pure_descriptor_for_file = descriptor_for_file(&pure_descriptors, &proto_file_name);

        let skip = should_skip(input.to_str().unwrap());
        if protoc_rs_contents == pure_rs_contents
            && protoc_descriptor_for_file == pure_descriptor_for_file
        {
            if !skip {
                stats.passed += 1;
                println!("{}: PASSED", label);
            } else {
                stats.passed_marked_skip += 1;
                println!("{}: PASSED BUT MARKED SKIP", label);
            }
        } else {
            if skip {
                stats.skipped += 1;
                println!("{} SKIPPED", label);
            } else {
                stats.failed += 1;
                println!("{} FAILED", label);
            }

            print_diff(
                temp_dir.path(),
                Path::new(&protoc_rs).strip_prefix(temp_dir.path()).unwrap(),
                Path::new(&pure_rs).strip_prefix(temp_dir.path()).unwrap(),
            );

            fs::write(
                format!("{}/{}.descriptors", protoc_dir, proto_name),
                pretty_message(protoc_descriptor_for_file),
            )
            .unwrap();
            fs::write(
                format!("{}/{}.descriptors", pure_dir, proto_name),
                pretty_message(pure_descriptor_for_file),
            )
            .unwrap();
            print_diff(
                temp_dir.path(),
                Path::new(&format!("protoc/{}.descriptors", proto_name)),
                Path::new(&format!("pure/{}.descriptors", proto_name)),
            );
        }
    }

    println!("{:?}", stats);
    assert!(stats.failed == 0, "at least one test failed");
}

fn should_skip_with_marker(path: &str) -> bool {
    fs::read_to_string(path)
        .unwrap()
        .contains("@skip-codegen-identical-test")
}

#[test]
fn common_v2() {
    test_diff_in(
        "../../test-crates/protobuf-codegen-protoc-test",
        "src/common/v2",
        "src/common/v2",
        should_skip_with_marker,
    );
}

#[test]
fn common_v3() {
    let common_v3_root = tempfile::Builder::new()
        .prefix("common-v3")
        .tempdir()
        .unwrap();
    fs::create_dir_all(format!(
        "{}/src/common/v3",
        common_v3_root.path().to_str().unwrap()
    ))
    .unwrap();

    copy_tests_v2_v3(
        "../../test-crates/protobuf-codegen-protoc-test/src/common/v2",
        &format!("{}/src/common/v3", common_v3_root.path().to_str().unwrap()),
    );

    test_diff_in(
        common_v3_root.path().to_str().unwrap(),
        "src/common/v3",
        "src/common/v3",
        should_skip_with_marker,
    );
}

#[test]
fn v2() {
    test_diff_in(
        "../../test-crates/protobuf-codegen-protoc-test",
        "src/v2",
        "src/v2",
        should_skip_with_marker,
    );
}

#[test]
fn v3() {
    test_diff_in(
        "../../test-crates/protobuf-codegen-protoc-test",
        "src/v3",
        "src/v3",
        should_skip_with_marker,
    );
}

#[test]
fn interop() {
    test_diff_in(
        "../..",
        "test-crates/interop/cxx",
        "test-crates/interop/cxx",
        should_skip_with_marker,
    );
}

#[test]
fn google() {
    test_diff_in(
        "../../test-crates/protobuf-codegen-protoc-test",
        "src/google/protobuf",
        "src",
        |_| false,
    );
}

#[test]
fn test_data() {
    test_diff_in(".", "test-data", "test-data", |_| false);
}

'''
'''--- test-crates/protobuf-codegen-protoc-test/Cargo.toml ---
[package]
name = "protobuf-codegen-protoc-test"
version = "0.0.0"
authors = ["Stepan Koltsov <stepan.koltsov@gmail.com>"]
publish = false
edition = "2021"
description = "Test protoc codegen"

[lib]
doctest = false
bench = false

[features]
default = []
proto3 = []
with-bytes = ["bytes", "protobuf/with-bytes", "protobuf-test-common/with-bytes"]

[build-dependencies]
glob        = "0.2"
log         = "0.4"
env_logger  = "0.5.*"

protoc-bin-vendored = "=3.0.0"

protobuf-codegen = { path = "../../protobuf-codegen" }
protobuf-test-common = { path = "../../test-crates/protobuf-test-common" }

[dependencies]
bytes = { version = "1.1", optional = true }

protobuf = { path = "../../protobuf" }
protobuf-test-common = { path = "../../test-crates/protobuf-test-common" }
protobuf-json-mapping = { path = "../../protobuf-json-mapping" }

'''
'''--- test-crates/protobuf-codegen-protoc-test/README.md ---
# Tests for rust-protobuf

To execute tests simply execute `cargo test`.

If protobuf 3 is installed, command will include test for protobuf 3 generated code.

If `--features=with-bytes` flag is specified, tests will include test for `with-bytes` feature,
which is not enabled by default.

`./test.sh` is to be used from [travis-ci](https://travis-ci.org/stepancheg/rust-protobuf/),
and not needed for local development.

`cargo test` executes [`build.rs`](https://github.com/stepancheg/rust-protobuf/blob/master/protobuf-codegen-protoc-test/build.rs) script,
which generates `.rs` files from `.proto` and `mod.rs` files for certain folder.

## Test contents

* `v2` contains tests specific to protobuf 2
* `v3` contains tests specific to protobuf 2
* `google` contains tests `.proto` files taken from Google's protobuf implementation
* `common` contains tests which are identical for both versions of protobuf syntax.
  `common/v2` directory contains sources, and contents of `common/v3` is generated
  from `common/v2` by copy and replace.

'''
'''--- test-crates/protobuf-codegen-protoc-test/build.rs ---
use std::env;
use std::fs;
use std::path::Path;
use std::path::PathBuf;

use protobuf_codegen::Codegen;
use protobuf_test_common::build::*;

fn test_protoc_bin_path() -> PathBuf {
    protoc_bin_vendored::protoc_bin_path().unwrap()
}

fn codegen() -> Codegen {
    let mut codegen = Codegen::new();
    codegen.protoc();
    codegen.protoc_path(&test_protoc_bin_path());
    codegen.protoc_extra_arg("--experimental_allow_proto3_optional");
    codegen
}

fn gen_in_dir(dir: &str, include_dir: &str) {
    gen_in_dir_impl(
        dir,
        |GenInDirArgs {
             out_dir,
             input,
             customize,
         }| {
            codegen()
                .out_dir(out_dir)
                .inputs(input)
                .includes(&["../../proto", include_dir])
                .customize(customize)
                .run_from_script()
        },
    );
}

fn generate_in_common() {
    gen_in_dir("src/common/v2", "src/common/v2");

    copy_tests_v2_v3("src/common/v2", "src/common/v3");
    gen_in_dir("src/common/v3", "src/common/v3");
}

fn generate_in_v2_v3() {
    gen_in_dir("src/v2", "src/v2");

    gen_in_dir("src/v3", "src/v3");

    gen_in_dir("src/google/protobuf", "src");
}

fn generate_interop() {
    codegen()
        .out_dir("src/interop")
        .includes(&["../../test-crates/interop/cxx", "../../proto"])
        .input("../../test-crates/interop/cxx/interop_pb.proto")
        .run_from_script();
}

fn generate_include_generated() {
    let dir = format!("{}/include_generated", env::var("OUT_DIR").unwrap());
    if Path::new(&dir).exists() {
        fs::remove_dir_all(&dir).unwrap();
    }
    fs::create_dir(&dir).unwrap();
    Codegen::new()
        .protoc()
        .out_dir(dir)
        .input("src/include_generated/v2.proto")
        .input("src/include_generated/v3.proto")
        .include("src/include_generated")
        .run_from_script();
}

fn generate_pb_rs() {
    generate_in_common();
    generate_in_v2_v3();
    generate_interop();
    generate_include_generated();
}

fn main() {
    env_logger::init();

    clean_old_files();

    generate_pb_rs();
}

'''
'''--- test-crates/protobuf-codegen-protoc-test/src/common/README.md ---
# Common tests for v2 and v3 codegen

When behavior should be identical.

The source is `v2` folder.

For `v3` files are copied from `v2` folder with:
* `syntax` instruction patched
* `optional` field prefix is removed.

'''
'''--- test-crates/protobuf-codegen-protoc-test/src/common/mod.rs ---
// v2 tests which must be compatible with v3 tests
mod v2;

// v3 tests are generated from v2 tests by copy&replace
mod v3;

'''
'''--- test-crates/protobuf-codegen-protoc-test/src/common/v2/test_all_types.rs ---
use protobuf_test_common::test_serialize_deserialize_no_hex_with_dynamic;

use super::test_all_types_pb::*;

#[test]
fn test_types_singular() {
    let mut message = TestTypesSingular::new();
    message.set_double_field(19f64);
    message.set_float_field(20f32);
    message.set_int32_field(21);
    message.set_int64_field(-22);
    message.set_uint32_field(23);
    message.set_uint64_field(24);
    message.set_sint32_field(-25);
    message.set_sint64_field(26);
    message.set_fixed32_field(27);
    message.set_fixed64_field(28);
    message.set_sfixed32_field(-29);
    message.set_sfixed64_field(30);
    message.set_bool_field(true);
    message.set_string_field("thirty two".to_string());
    message.set_bytes_field([33u8, 34].to_vec());
    message.set_enum_field(SomeEnum::BLUE);
    test_serialize_deserialize_no_hex_with_dynamic(&message);
}

#[test]
fn test_types_repeated() {
    let mut message = TestTypesRepeated::new();
    message.set_double_field([19f64, 20f64].to_vec());
    message.set_float_field([20f32].to_vec());
    message.set_int32_field([21i32, -22, 23].to_vec());
    message.set_int64_field([22i64].to_vec());
    message.set_uint32_field([23u32, 24].to_vec());
    message.set_uint64_field([24u64].to_vec());
    message.set_sint32_field([25i32].to_vec());
    message.set_sint64_field([26i64, -27].to_vec());
    message.set_fixed32_field([27u32].to_vec());
    message.set_fixed64_field([28u64].to_vec());
    message.set_sfixed32_field([29i32, -30].to_vec());
    message.set_sfixed64_field([30i64].to_vec());
    message.set_bool_field([true, true].to_vec());
    message.set_string_field(vec!["thirty two".to_string(), "thirty three".to_string()]);
    message.set_bytes_field(vec![[33u8, 34].to_vec(), [35u8].to_vec()]);
    message.set_enum_field([SomeEnum::BLUE.into(), SomeEnum::GREEN.into()].to_vec());
    test_serialize_deserialize_no_hex_with_dynamic(&message);
}

#[test]
fn test_types_repeated_packed() {
    let mut message = TestTypesRepeatedPacked::new();
    message.set_double_field([19f64, 20f64].to_vec());
    message.set_float_field([20f32].to_vec());
    message.set_int32_field([21i32, -22, 23].to_vec());
    message.set_int64_field([22i64].to_vec());
    message.set_uint32_field([23u32, 24].to_vec());
    message.set_uint64_field([24u64].to_vec());
    message.set_sint32_field([-25i32, 26].to_vec());
    message.set_sint64_field([26i64, -27, 28].to_vec());
    message.set_fixed32_field([27u32].to_vec());
    message.set_fixed64_field([28u64].to_vec());
    message.set_sfixed32_field([29i32, -30].to_vec());
    message.set_sfixed64_field([30i64].to_vec());
    message.set_bool_field([true, true].to_vec());
    message.set_string_field(vec!["thirty two".to_string(), "thirty three".to_string()]);
    message.set_bytes_field(vec![[33u8, 34].to_vec(), [35u8].to_vec()]);
    message.set_enum_field([SomeEnum::BLUE.into(), SomeEnum::GREEN.into()].to_vec());
    test_serialize_deserialize_no_hex_with_dynamic(&message);
}

'''
'''--- test-crates/protobuf-codegen-protoc-test/src/common/v2/test_any.rs ---
use protobuf::well_known_types::any::Any;
use protobuf::MessageFull;

use super::test_any_pb::MessageOne;
use super::test_any_pb::MessageTwo;

#[test]
fn test_static() {
    let mut m1 = MessageOne::new();
    m1.set_i(10);
    let any = Any::pack(&m1).unwrap();
    assert_eq!("type.googleapis.com/test_any.MessageOne", any.type_url);
    assert!(any.is::<MessageOne>());
    assert!(!any.is::<MessageTwo>());
    assert_eq!(Some(m1), any.unpack::<MessageOne>().unwrap());
    assert_eq!(None, any.unpack::<MessageTwo>().unwrap());
}

#[test]
fn test_dynamic() {
    let mut m1 = MessageOne::new();
    m1.set_i(10);
    let any = Any::pack_dyn(&m1).unwrap();
    assert_eq!("type.googleapis.com/test_any.MessageOne", any.type_url);
    assert!(any.is_dyn(&MessageOne::descriptor()));
    assert!(!any.is_dyn(&MessageTwo::descriptor()));
    assert_eq!(
        m1,
        *any.unpack_dyn(&MessageOne::descriptor())
            .unwrap()
            .unwrap()
            .downcast_box::<MessageOne>()
            .unwrap()
    );
    assert!(any.unpack_dyn(&MessageTwo::descriptor()).unwrap().is_none());
}

'''
'''--- test-crates/protobuf-codegen-protoc-test/src/common/v2/test_basic.rs ---
use protobuf::descriptor;
use protobuf::reflect;
use protobuf::CodedInputStream;
use protobuf::CodedOutputStream;
use protobuf::EnumFull;
use protobuf::Message;
use protobuf::MessageFull;
use protobuf_test_common::hex::decode_hex;
use protobuf_test_common::*;

use super::test_basic_pb::*;

#[test]
fn test1() {
    let mut test1 = Test1::new();
    test1.set_a(150);
    test_serialize_deserialize_with_dynamic("08 96 01", &test1);
}

#[test]
fn test2() {
    let mut test2 = Test2::new();
    test2.set_b("testing".to_string());
    test_serialize_deserialize_with_dynamic("12 07 74 65 73 74 69 6e 67", &test2);
}

#[test]
fn test3() {
    let mut test1 = Test1::new();
    test1.set_a(150);
    let mut test3 = Test3::new();
    test3.set_c(test1);
    test_serialize_deserialize_with_dynamic("1a 03 08 96 01", &test3);
}

#[test]
fn test4() {
    let mut test4 = Test4::new();
    test4.set_d([3i32, 270, 86942].to_vec());
    test_serialize_deserialize_with_dynamic("22 06 03 8E 02 9E A7 05", &test4);
}

#[test]
fn test_recursion_limit() {
    let mut test = TestRecursion::new();
    for _ in 0..10 {
        let mut t = TestRecursion::new();
        t.mut_children().push(test);
        test = t;
    }

    let bytes = test.write_to_bytes().unwrap();
    let cases = vec![(None, false), (Some(9), true), (Some(10), false)];

    for (limit, has_err) in cases {
        let mut is = CodedInputStream::from_bytes(&bytes);
        if let Some(limit) = limit {
            is.set_recursion_limit(limit);
        }
        let mut t = TestRecursion::new();
        let res = t.merge_from(&mut is);
        assert_eq!(res.is_err(), has_err, "limit: {:?}", limit);
        if !has_err {
            assert_eq!(t, test, "limit: {:?}", limit);
        }
    }
}

#[test]
fn test_end_by_negative_int() {
    // added following https://github.com/stepancheg/rust-protobuf/pull/209
    let mut test = Test1::new();
    test.set_a(-1);
    test_serialize_deserialize_with_dynamic("08 ff ff ff ff ff ff ff ff ff 01", &test);
}

#[test]
fn test_empty() {
    test_serialize_deserialize_with_dynamic("", &TestEmpty::new());
}

#[test]
fn test_read_junk() {
    assert!(Test1::parse_from_bytes(&decode_hex("00")).is_err());
}

#[test]
fn test_unknown_fields_length_delimited() {
    let mut message = TestUnknownFields::new();
    message.set_a(150);
    message
        .mut_unknown_fields()
        .add_length_delimited(4, [0x10u8, 0x20, 0x30].to_vec());
    test_serialize_deserialize_with_dynamic("08 96 01 22 03 10 20 30", &message);
}

#[test]
fn test_unknown_fields_fixed32() {
    let mut message = TestUnknownFields::new();
    message.set_a(150);
    message.mut_unknown_fields().add_fixed32(4, 0x01020304);
    message.mut_unknown_fields().add_fixed32(4, 0xA1A2A3A4);
    test_serialize_deserialize_with_dynamic("08 96 01 25 04 03 02 01 25 A4 A3 A2 A1", &message);
}

#[test]
fn test_file_descriptor_proto() {
    let file_descriptor = file_descriptor();
    let p: &descriptor::FileDescriptorProto = file_descriptor.proto();
    assert!(p.has_name());
    assert_eq!("test_basic_pb.proto", p.name());
}

#[test]
fn test_default_instance() {
    let d = TestDefaultInstance::new();
    assert_eq!("", d.field().s());
}

#[test]
fn test_message_descriptor() {
    assert_eq!("TestDescriptor", TestDescriptor::descriptor().name());

    let d = reflect::MessageDescriptor::for_type::<TestDescriptor>();
    assert_eq!("TestDescriptor", d.name());
    assert_eq!("basic.TestDescriptor", d.full_name());

    let mut t = TestDescriptor::new();
    t.set_stuff(55);

    let field = d.field_by_name("stuff").unwrap();
    assert_eq!(
        55,
        field.get_singular_field_or_default(&t).to_i32().unwrap()
    );
}

#[test]
fn test_enum_descriptor() {
    let d = TestEnumDescriptor::enum_descriptor();
    assert_eq!("TestEnumDescriptor", d.name());
    assert_eq!(
        "TestEnumDescriptor",
        reflect::EnumDescriptor::for_type::<TestEnumDescriptor>().name()
    );
    assert_eq!("GREEN", d.value_by_name("GREEN").unwrap().name());
}

#[test]
fn test_invalid_tag() {
    // 01 is invalid tag, because field number for that tag would be 0
    let bytes = decode_hex("01 02 03");
    let r = TestInvalidTag::parse_from_bytes(&bytes);
    assert!(r.is_err());
}

#[test]
fn test_truncated_no_varint() {
    // 08 is valid tag that should be followed by varint
    let bytes = decode_hex("08");
    let r = TestTruncated::parse_from_bytes(&bytes);
    assert!(r.is_err());
}

#[test]
fn test_truncated_middle_of_varint() {
    // 08 is field 1, wire type varint
    // 96 is non-final byte of varint
    let bytes = decode_hex("08 96");
    let r = TestTruncated::parse_from_bytes(&bytes);
    assert!(r.is_err());
}

#[test]
fn test_truncated_middle_of_length_delimited() {
    // 0a is field 1, wire type length delimited
    // 03 is length 3
    let bytes = decode_hex("0a 03 10");
    let r = TestTruncated::parse_from_bytes(&bytes);
    assert!(r.is_err());
}

#[test]
fn test_truncated_repeated_packed() {
    // 12 is field 2, wire type length delimited
    // 04 is length 4
    let bytes = decode_hex("12 04 10 20");
    let r = TestTruncated::parse_from_bytes(&bytes);
    assert!(r.is_err());
}

#[test]
fn test_bug_sint() {
    {
        let mut x = TestBugSint::new();
        x.set_s32(-1);
        test_serialize_deserialize_with_dynamic("08 01", &x);
    }
    {
        let mut x = TestBugSint::new();
        x.set_s64(-2);
        test_serialize_deserialize_with_dynamic("10 03", &x);
    }
}

/// Smoke test which validates that read from the network doesn't block
#[test]
fn test_parse_length_delimited_from_network_smoke() {
    use std::io::Write;
    use std::net;
    use std::thread;

    let listener = net::TcpListener::bind(("127.0.0.1", 0)).expect("bind");
    let addr = listener.local_addr().expect("local_addr");
    thread::spawn(move || {
        let mut test1 = Test1::new();
        test1.set_a(10);
        let bytes = test1.write_length_delimited_to_bytes().expect("bytes");

        let mut stream = listener.accept().expect("accept").0;
        stream.write(&bytes).expect("write");
    });

    let mut tcp_stream = net::TcpStream::connect(addr).expect("connect");
    let mut is = CodedInputStream::new(&mut tcp_stream);
    let test1: Test1 = is.read_message().expect("read_message");
    assert_eq!(10, test1.a());
    is.check_eof().expect("check_eof");
}

/// Test if providing a smaller buffer, protobuf can detect and report error.
#[test]
fn test_serialize_too_large_message() {
    let mut test1 = Test1::new();
    test1.set_a(150);
    let len = test1.compute_size();
    let mut bytes = vec![0; len as usize - 1];
    let mut s = CodedOutputStream::bytes(&mut bytes);
    test1.write_to_with_cached_sizes(&mut s).unwrap_err();
}

'''
'''--- test-crates/protobuf-codegen-protoc-test/src/common/v2/test_default.rs ---
use super::test_default_pb::*;

#[test]
fn test_default_for_amp_message() {
    let none: Option<&TestDefault> = None;
    assert_eq!(0, none.unwrap_or_default().i());
}

'''
'''--- test-crates/protobuf-codegen-protoc-test/src/common/v2/test_dynamic_repeated_get_set.rs ---
use protobuf::reflect::FileDescriptor;
use protobuf::reflect::ReflectValueBox;

use super::test_dynamic_repeated_get_set_pb;

fn dynamic_file_descriptor() -> FileDescriptor {
    FileDescriptor::new_dynamic(
        test_dynamic_repeated_get_set_pb::file_descriptor()
            .proto()
            .clone(),
        &[],
    )
    .unwrap()
}

fn do_test_repeated(file_descriptor: &FileDescriptor) {
    let m = file_descriptor
        .message_by_package_relative_name("ForDynamicRepeatedTest")
        .unwrap();
    let f = m.field_by_name("ii").unwrap();
    let mut m = m.new_instance();
    assert!(f.get_repeated(&*m).is_empty());
    assert!(f.mut_repeated(&mut *m).is_empty());
    f.mut_repeated(&mut *m).push(ReflectValueBox::U32(19));
    f.mut_repeated(&mut *m).push(ReflectValueBox::U32(17));
    assert_eq!(2, f.get_repeated(&*m).len());
    assert_eq!(ReflectValueBox::U32(17), f.get_repeated(&*m).get(1));
    assert_eq!(
        &[ReflectValueBox::U32(19), ReflectValueBox::U32(17)][..],
        &f.get_repeated(&*m)
    );
}

#[test]
fn generated_repeated() {
    do_test_repeated(&dynamic_file_descriptor());
}

#[test]
fn dynamic_repeated() {
    do_test_repeated(&test_dynamic_repeated_get_set_pb::file_descriptor());
}

'''
'''--- test-crates/protobuf-codegen-protoc-test/src/common/v2/test_dynamic_singular_get_set.rs ---
use protobuf::reflect::FileDescriptor;
use protobuf::reflect::ReflectValueBox;
use protobuf::reflect::ReflectValueRef;

use super::test_dynamic_singular_get_set_pb;

fn dynamic_file_descriptor() -> FileDescriptor {
    FileDescriptor::new_dynamic(
        test_dynamic_singular_get_set_pb::file_descriptor()
            .proto()
            .clone(),
        &[],
    )
    .unwrap()
}

fn do_test_get_set(file_descriptor: &FileDescriptor) {
    let m = file_descriptor
        .message_by_package_relative_name("ForDynamicTest")
        .unwrap();
    let f = m.field_by_name("ff").unwrap();

    let mut m = m.new_instance();
    let m = &mut *m;
    assert_eq!(None, f.get_singular(m));

    f.set_singular_field(m, 10u32.into());
    assert_eq!(Some(ReflectValueRef::from(10u32)), f.get_singular(m));
}

#[test]
fn generated_get_set() {
    do_test_get_set(&test_dynamic_singular_get_set_pb::file_descriptor());
}

#[test]
fn dynamic_get_set() {
    do_test_get_set(&dynamic_file_descriptor());
}

fn do_test_set_panic_on_wrong_field_type(file_descriptor: &FileDescriptor) {
    let m = file_descriptor
        .message_by_package_relative_name("ForDynamicTest")
        .unwrap();
    let f = m.field_by_name("ff").unwrap();
    let mut m = m.new_instance();
    let m = &mut *m;
    f.set_singular_field(m, ReflectValueBox::from(10i64));
}

#[test]
#[should_panic]
fn generated_set_panic_on_wrong_field_type() {
    do_test_set_panic_on_wrong_field_type(&test_dynamic_singular_get_set_pb::file_descriptor());
}

#[test]
#[should_panic]
fn dynamic_set_panic_on_wrong_field_type() {
    do_test_set_panic_on_wrong_field_type(&dynamic_file_descriptor());
}

'''
'''--- test-crates/protobuf-codegen-protoc-test/src/common/v2/test_enable_lite_runtime.rs ---
use protobuf_test_common::*;

use super::test_enable_lite_runtime_pb::*;

#[test]
fn test_lite_runtime() {
    let mut m = TestLiteRuntime::new();
    m.set_v(10);
    test_serialize_deserialize("08 0a", &m);

    // test it doesn't crash
    format!("{:?}", m);
}

'''
'''--- test-crates/protobuf-codegen-protoc-test/src/common/v2/test_enum_alias.rs ---
use protobuf::Enum;
use protobuf::EnumFull;
use protobuf_test_common::*;

use super::test_enum_alias_pb::*;

#[test]
fn test_enum() {
    assert_eq!(10, EnumWithAlias::A.value());
    assert_eq!(10, EnumWithAlias::A_AGAIN.value());
    assert_eq!(
        &[
            EnumWithAlias::UNKNOWN,
            EnumWithAlias::A,
            EnumWithAlias::B,
            EnumWithAlias::A_AGAIN,
        ],
        EnumWithAlias::VALUES,
    );
    assert_eq!(EnumWithAlias::A, EnumWithAlias::A_AGAIN);
}

#[test]
fn test_enum_in_message() {
    let mut m = TestEnumWithAlias::new();
    m.set_en(EnumWithAlias::A);
    test_serialize_deserialize_with_dynamic("08 0a", &m);
}

#[test]
fn descriptor() {
    assert_eq!("A", EnumWithAlias::A.descriptor().name());
    assert_eq!("A_AGAIN", EnumWithAlias::A_AGAIN.descriptor().name());
}

'''
'''--- test-crates/protobuf-codegen-protoc-test/src/common/v2/test_enum_nonunique.rs ---
use super::test_enum_nonunique_pb::*;

#[test]
fn test() {
    let _ = message_a::EnumA::FOO;
}

'''
'''--- test-crates/protobuf-codegen-protoc-test/src/common/v2/test_enum_unknown_values_preserved.rs ---
use protobuf::Message;
use protobuf_test_common::*;

use super::test_enum_unknown_values_preserved_pb::*;

#[test]
fn unknown_values_preserved() {
    let mut new = NewMessage::new();
    new.set_eee(NewEnum::C);

    test_serialize_deserialize_with_dynamic("08 1e", &new);

    // `OldEnum` doesn't have variant `C = 30`,
    // but message still properly serialized and deserialized.

    let old: OldMessage = OldMessage::parse_from_bytes(&hex::decode_hex("08 1e")).expect("parse");

    test_serialize_deserialize_with_dynamic("08 1e", &old);
}

'''
'''--- test-crates/protobuf-codegen-protoc-test/src/common/v2/test_enum_values.rs ---
use protobuf::*;

use super::test_enum_values_pb::*;

#[test]
fn test_enum_values() {
    let expected = [
        TestEnumValuesEnum::UNKNOWN,
        TestEnumValuesEnum::WINTER,
        TestEnumValuesEnum::SPRING,
        TestEnumValuesEnum::SUMMER,
        TestEnumValuesEnum::AUTUMN,
    ];
    assert_eq!(expected, TestEnumValuesEnum::VALUES);
}

'''
'''--- test-crates/protobuf-codegen-protoc-test/src/common/v2/test_ext.rs ---
use protobuf::MessageFull;

use super::test_ext_pb::*;

#[test]
fn test_get() {
    let descriptor = MyMessage::descriptor();
    let message = descriptor.proto().options.get_or_default();
    assert_eq!(10.5, exts::double_field.get(message).unwrap_or_default());
    assert_eq!(-8.5, exts::float_field.get(message).unwrap_or_default());
    assert_eq!(-3, exts::int32_field.get(message).unwrap_or_default());
    assert_eq!(-13, exts::int64_field.get(message).unwrap_or_default());
    assert_eq!(-4, exts::sint32_field.get(message).unwrap_or_default());
    assert_eq!(-14, exts::sint64_field.get(message).unwrap_or_default());
    assert_eq!(5, exts::uint32_field.get(message).unwrap_or_default());
    assert_eq!(15, exts::uint64_field.get(message).unwrap_or_default());
    assert_eq!(6, exts::fixed32_field.get(message).unwrap_or_default());
    assert_eq!(16, exts::fixed64_field.get(message).unwrap_or_default());
    assert_eq!(7, exts::sfixed32_field.get(message).unwrap_or_default());
    assert_eq!(-17, exts::sfixed64_field.get(message).unwrap_or_default());
    assert_eq!(true, exts::bool_field.get(message).unwrap_or_default());
    assert_eq!(
        "Hello world!",
        exts::string_field.get(message).unwrap_or_default()
    );
    if false {
        // TODO: only implemented in `protoc`-based codegen
        assert_eq!(
            TestEnum::RED,
            exts::enum_field.get(message).unwrap_or_default().unwrap()
        );
        assert_eq!(22, exts::message_field.get(message).unwrap().n());
    }
}

'''
'''--- test-crates/protobuf-codegen-protoc-test/src/common/v2/test_fmt_json.rs ---
use protobuf::MessageFull;
use protobuf_test_common::*;

use super::test_fmt_json_pb::*;

#[test]
fn empty() {
    test_json_print_parse_message("{}", &TestTypes::new());
}

#[test]
fn test_bool() {
    let mut m = TestTypes::new();
    m.set_bool_singular(true);
    test_json_print_parse_message("{\"boolSingular\": true}", &m);

    let mut m = TestTypes::new();
    m.set_bool_repeated(vec![true, false, false]);
    test_json_print_parse_message("{\"boolRepeated\": [true, false, false]}", &m);
}

#[test]
fn test_float() {
    let mut m = TestTypes::new();
    m.set_float_singular(10.0);
    test_json_print_parse_message("{\"floatSingular\": 10.0}", &m);

    let mut m = TestTypes::new();
    m.float_repeated.push(11.0);
    m.float_repeated.push(-12.5);
    m.float_repeated.push(f32::NAN);
    m.float_repeated.push(f32::NEG_INFINITY);
    test_json_print_parse_message(
        "{\"floatRepeated\": [11.0, -12.5, \"NaN\", \"-Infinity\"]}",
        &m,
    );
}

#[test]
fn test_double() {
    let mut m = TestTypes::new();
    m.set_double_singular(12.0);
    test_json_print_parse_message("{\"doubleSingular\": 12.0}", &m);
    test_json_parse_message("{\"doubleSingular\": \"12.0\"}", &m);

    let mut m = TestTypes::new();
    m.double_repeated.push(13.0);
    m.double_repeated.push(f64::INFINITY);
    test_json_print_parse_message("{\"doubleRepeated\": [13.0, \"Infinity\"]}", &m);
}

#[test]
fn test_int32() {
    let mut m = TestTypes::new();
    m.set_int32_singular(1234);
    test_json_print_parse_message("{\"int32Singular\": 1234}", &m);

    let mut m = TestTypes::new();
    m.int32_repeated.push(10);
    m.int32_repeated.push(-20);
    test_json_print_parse_message("{\"int32Repeated\": [10, -20]}", &m);
}

#[test]
fn test_int64() {
    let mut m = TestTypes::new();
    m.set_int64_singular(1234567890123456789);
    test_json_print_parse_message("{\"int64Singular\": \"1234567890123456789\"}", &m);

    let mut m = TestTypes::new();
    m.int64_repeated.push(2345678901234567890);
    m.int64_repeated.push(-2345678901234567890);
    test_json_print_parse_message(
        "{\"int64Repeated\": [\"2345678901234567890\", \"-2345678901234567890\"]}",
        &m,
    );
}

#[test]
fn test_sint32() {
    let mut m = TestTypes::new();
    m.set_sint32_singular(1234);
    test_json_print_parse_message("{\"sint32Singular\": 1234}", &m);

    let mut m = TestTypes::new();
    m.sint32_repeated.push(10);
    m.sint32_repeated.push(-20);
    test_json_print_parse_message("{\"sint32Repeated\": [10, -20]}", &m);
}

#[test]
fn test_sint64() {
    let mut m = TestTypes::new();
    m.set_sint64_singular(1234567890123456789);
    test_json_print_parse_message("{\"sint64Singular\": \"1234567890123456789\"}", &m);

    let mut m = TestTypes::new();
    m.sint64_repeated.push(2345678901234567890);
    m.sint64_repeated.push(-2345678901234567890);
    test_json_print_parse_message(
        "{\"sint64Repeated\": [\"2345678901234567890\", \"-2345678901234567890\"]}",
        &m,
    );
}

#[test]
fn test_sfixed32() {
    let mut m = TestTypes::new();
    m.set_sfixed32_singular(1234);
    test_json_print_parse_message("{\"sfixed32Singular\": 1234}", &m);

    let mut m = TestTypes::new();
    m.sfixed32_repeated.push(10);
    m.sfixed32_repeated.push(-20);
    test_json_print_parse_message("{\"sfixed32Repeated\": [10, -20]}", &m);
}

#[test]
fn test_sfixed64() {
    let mut m = TestTypes::new();
    m.set_sfixed64_singular(1234567890123456789);
    test_json_print_parse_message("{\"sfixed64Singular\": \"1234567890123456789\"}", &m);

    let mut m = TestTypes::new();
    m.sfixed64_repeated.push(2345678901234567890);
    m.sfixed64_repeated.push(-2345678901234567890);
    test_json_print_parse_message(
        "{\"sfixed64Repeated\": [\"2345678901234567890\", \"-2345678901234567890\"]}",
        &m,
    );
}

#[test]
fn test_uint32() {
    let mut m = TestTypes::new();
    m.set_uint32_singular(1234);
    test_json_print_parse_message("{\"uint32Singular\": 1234}", &m);

    let mut m = TestTypes::new();
    m.uint32_repeated.push(10);
    m.uint32_repeated.push(20300);
    test_json_print_parse_message("{\"uint32Repeated\": [10, 20300]}", &m);
}

#[test]
fn test_uint64() {
    let mut m = TestTypes::new();
    m.set_uint64_singular(1234567890123456789);
    test_json_print_parse_message("{\"uint64Singular\": \"1234567890123456789\"}", &m);

    let mut m = TestTypes::new();
    m.uint64_repeated.push(2345678901234567890);
    m.uint64_repeated.push(1345678901234567890);
    test_json_print_parse_message(
        "{\"uint64Repeated\": [\"2345678901234567890\", \"1345678901234567890\"]}",
        &m,
    );
}

#[test]
fn test_fixed32() {
    let mut m = TestTypes::new();
    m.set_fixed32_singular(1234);
    test_json_print_parse_message("{\"fixed32Singular\": 1234}", &m);

    let mut m = TestTypes::new();
    m.fixed32_repeated.push(10);
    m.fixed32_repeated.push(20300);
    test_json_print_parse_message("{\"fixed32Repeated\": [10, 20300]}", &m);
}

#[test]
fn test_fixed64() {
    let mut m = TestTypes::new();
    m.set_fixed64_singular(1234567890123456789);
    test_json_print_parse_message("{\"fixed64Singular\": \"1234567890123456789\"}", &m);
    test_json_parse_message("{\"fixed64Singular\": 1234567890123456789}", &m);

    let mut m = TestTypes::new();
    m.fixed64_repeated.push(2345678901234567890);
    m.fixed64_repeated.push(1345678901234567890);
    test_json_print_parse_message(
        "{\"fixed64Repeated\": [\"2345678901234567890\", \"1345678901234567890\"]}",
        &m,
    );
    test_json_parse_message(
        "{\"fixed64Repeated\": [\"2345678901234567890\", 1345678901234567890]}",
        &m,
    );
}

#[test]
fn test_string() {
    let mut m = TestTypes::new();
    m.set_string_singular("ab".to_owned());
    test_json_print_parse_message("{\"stringSingular\": \"ab\"}", &m);

    let mut m = TestTypes::new();
    m.set_string_repeated(vec!["".to_owned(), "\0".to_owned(), "A\nB".to_owned()].into());
    test_json_print_parse_message("{\"stringRepeated\": [\"\", \"\\u0000\", \"A\\nB\"]}", &m);
}

#[test]
fn test_bytes() {
    let mut m = TestTypes::new();
    m.set_bytes_singular(b"ab".to_vec());
    test_json_print_parse_message("{\"bytesSingular\": \"YWI=\"}", &m);

    let mut m = TestTypes::new();
    m.set_bytes_repeated(vec![b"".to_vec(), b"\0".to_vec(), b"A\nB".to_vec()].into());
    test_json_print_parse_message("{\"bytesRepeated\": [\"\", \"AA==\", \"QQpC\"]}", &m);
}

#[test]
fn test_enum() {
    let mut m = TestTypes::new();
    m.set_test_enum_singular(TestEnum::DARK);
    test_json_print_parse_message("{\"testEnumSingular\": \"DARK\"}", &m);
    test_json_parse_message("{\"testEnumSingular\": 10}", &m);

    let mut m = TestTypes::new();
    m.set_test_enum_repeated(vec![TestEnum::DARK.into(), TestEnum::LIGHT.into()]);
    test_json_print_parse_message("{\"testEnumRepeated\": [\"DARK\", \"LIGHT\"]}", &m);
    test_json_parse_message("{\"testEnumRepeated\": [\"DARK\", 20]}", &m);
}

#[test]
fn test_enum_int() {
    let mut m = TestTypes::new();
    m.set_test_enum_singular(TestEnum::DARK);
    let print_options = protobuf_json_mapping::PrintOptions {
        enum_values_int: true,
        ..Default::default()
    };
    let json = protobuf_json_mapping::print_to_string_with_options(&m, &print_options).unwrap();
    assert_eq!("{\"testEnumSingular\": 10}", json);
}

#[test]
fn test_map_field_int_key() {
    let mut m = TestTypes::new();
    m.fixed64_map_field.insert(10, 20);
    test_json_print_parse_message("{\"fixed64MapField\": {\"10\": \"20\"}}", &m);

    m.fixed64_map_field.insert(30, 40);
    let json = protobuf_json_mapping::print_to_string(&m).unwrap();
    assert!(
        json == "{\"fixed64MapField\": {\"10\": \"20\", \"30\": \"40\"}}"
            || json == "{\"fixed64MapField\": {\"30\": \"40\", \"10\": \"20\"}}"
    );
}

#[test]
fn test_map_field_string_key() {
    let mut m = TestTypes::new();
    m.uint64_map_field.insert("foo".to_owned(), 20);
    test_json_print_parse_message("{\"uint64MapField\": {\"foo\": \"20\"}}", &m);
}

/// Proto3 JSON parsers are required to accept both the converted `lowerCamelCase` name
/// and the proto field name.
#[test]
fn test_accepts_both_json_and_original() {
    let mut m = TestTypes::new();
    m.set_bool_singular(true);
    test_json_parse_message("{\"boolSingular\": true}", &m);
    test_json_parse_message("{\"bool_singular\": true}", &m);

    let mut m = TestTypes::new();
    m.set_bool_repeated(vec![true, false, false]);
    test_json_parse_message("{\"boolRepeated\": [true, false, false]}", &m);
    test_json_parse_message("{\"bool_repeated\": [true, false, false]}", &m);
}

#[test]
fn test_use_original_field_names() {
    let mut m = TestTypes::new();
    m.set_bool_singular(true);
    let print_options = protobuf_json_mapping::PrintOptions {
        proto_field_name: true,
        ..Default::default()
    };
    let json = protobuf_json_mapping::print_to_string_with_options(&m, &print_options).unwrap();
    assert_eq!("{\"bool_singular\": true}", json);
}

#[test]
fn test_always_output_default_values() {
    let mut m = TestIncludeDefaultValues::new();
    m.set_sss("asd".to_owned());
    let print_options = protobuf_json_mapping::PrintOptions {
        always_output_default_values: true,
        ..Default::default()
    };
    let json = protobuf_json_mapping::print_to_string_with_options(&m, &print_options).unwrap();
    assert_eq!("{\"iii\": 0, \"sss\": \"asd\"}", json);
}

#[test]
fn test_always_output_default_values_for_repeated_fields() {
    let m = TestIncludeDefaultValuesWithRepeatedField::new();
    let json = protobuf_json_mapping::print_to_string_with_options(
        &m,
        &protobuf_json_mapping::PrintOptions {
            always_output_default_values: false,
            ..Default::default()
        },
    )
    .unwrap();
    assert_eq!("{}", json);
    let json = protobuf_json_mapping::print_to_string_with_options(
        &m,
        &protobuf_json_mapping::PrintOptions {
            always_output_default_values: true,
            ..Default::default()
        },
    )
    .unwrap();
    assert_eq!("{\"rrr\": []}", json);
}

#[test]
fn test_ignore_unknown_fields() {
    let mut expected = TestTypes::new();
    expected.set_bool_singular(true);

    let parse_options = protobuf_json_mapping::ParseOptions {
        ignore_unknown_fields: true,
        ..Default::default()
    };
    let mut m = TestTypes::new();
    let json = "{\"fgfgfg\": 12, \"bool_singular\": true, \"x\": [{\"a\": 12.4}]}";
    protobuf_json_mapping::merge_from_str_with_options(&mut m, json, &parse_options).unwrap();

    assert_eq!(expected, m);
}

#[test]
fn test_reflect() {
    for m in special_messages(&TestTypes::descriptor()) {
        test_json_message(&*m);
    }
}

#[test]
fn test_use_json_name() {
    let mut m = TestJsonName::new();
    m.set_field_with_json_name(true);
    let json = protobuf_json_mapping::print_to_string(&m).unwrap();
    assert_eq!("{\"Field With json_name\": true}", json);
}

#[test]
fn test_more_than_one() {
    let mut m = TestTypes::new();
    m.set_bool_singular(true);
    m.set_bool_repeated(vec![true, false, false]);
    m.uint64_map_field.insert("foo".to_owned(), 20);

    test_json_print_parse_message(
        "{\"boolSingular\": true, \"boolRepeated\": [true, false, false], \"uint64MapField\": {\"foo\": \"20\"}}",
        &m,
    );
}

'''
'''--- test-crates/protobuf-codegen-protoc-test/src/common/v2/test_fmt_json_well_known.rs ---
use protobuf::well_known_types::duration::Duration;
use protobuf::well_known_types::field_mask::FieldMask;
use protobuf::well_known_types::struct_::ListValue;
use protobuf::well_known_types::struct_::NullValue;
use protobuf::well_known_types::struct_::Struct;
use protobuf::well_known_types::struct_::Value;
use protobuf::well_known_types::timestamp::Timestamp;
use protobuf_test_common::*;

use super::test_fmt_json_well_known_pb::*;

#[test]
fn test_duration() {
    let mut m = TestFmtJsonWellKnownTypes::new();
    let mut d = Duration::new();
    d.seconds = 1;
    d.nanos = 340012;
    m.set_duration(d);
    test_json_print_parse_message("{\"duration\": \"1.000340012s\"}", &m);

    let mut m = TestFmtJsonWellKnownTypes::new();
    let mut d = Duration::new();
    d.seconds = 1;
    m.set_duration(d);
    test_json_parse_message("{\"duration\": \"1s\"}", &m);
}

#[test]
fn test_timestamp() {
    let mut m = TestFmtJsonWellKnownTypes::new();
    let mut t = Timestamp::new();
    t.seconds = 1;
    t.nanos = 1;
    m.set_timestamp(t);
    test_json_print_parse_message("{\"timestamp\": \"1970-01-01T00:00:01.000000001Z\"}", &m);
}

#[test]
fn test_null_value() {
    let mut m = TestFmtJsonWellKnownTypes::new();
    m.set_null_values(vec![NullValue::NULL_VALUE.into()]);
    test_json_print_parse_message("{\"nullValues\": [null]}", &m);
}

#[test]
fn test_value() {
    let mut m = TestFmtJsonWellKnownTypes::new();
    m.mut_value().set_bool_value(true);
    test_json_print_parse_message("{\"value\": true}", &m);
    m.mut_value().set_number_value(12.0);
    test_json_print_parse_message("{\"value\": 12.0}", &m);
    m.mut_value().set_string_value("ab".to_owned());
    test_json_print_parse_message("{\"value\": \"ab\"}", &m);
    m.mut_value().set_null_value(NullValue::NULL_VALUE);
    test_json_print_parse_message("{\"value\": null}", &m);

    m.mut_value().set_list_value({
        let mut l = ListValue::new();
        l.values.push({
            let mut v = Value::new();
            v.set_bool_value(true);
            v
        });
        l.values.push({
            let mut v = Value::new();
            v.set_number_value(12.0);
            v
        });
        l
    });
    test_json_print_parse_message("{\"value\": [true, 12.0]}", &m);

    m.mut_value().set_struct_value(Struct::new());
    test_json_print_parse_message("{\"value\": {}}", &m);
}

#[test]
fn test_list_value() {
    let mut m = TestFmtJsonWellKnownTypes::new();
    m.mut_list_value().values.push({
        let mut v = Value::new();
        v.set_number_value(2.0);
        v
    });
    m.mut_list_value().values.push({
        let mut v = Value::new();
        v.set_bool_value(false);
        v
    });
    test_json_print_parse_message("{\"listValue\": [2.0, false]}", &m);
}

#[test]
fn test_struct() {
    let mut m = TestFmtJsonWellKnownTypes::new();
    m.mut_struct_value().fields.insert("ab".to_owned(), {
        let mut v = Value::new();
        v.set_number_value(3.0);
        v
    });
    test_json_print_parse_message("{\"structValue\": {\"ab\": 3.0}}", &m);
}

#[test]
fn test_wrappers() {
    let mut m = TestFmtJsonWellKnownTypes::new();
    m.mut_double_value().value = 10.0;
    test_json_print_parse_message("{\"doubleValue\": 10.0}", &m);
    let mut m = TestFmtJsonWellKnownTypes::new();
    m.mut_float_value().value = 12.0;
    test_json_print_parse_message("{\"floatValue\": 12.0}", &m);
    let mut m = TestFmtJsonWellKnownTypes::new();
    m.mut_int64_value().value = -13;
    test_json_print_parse_message("{\"int64Value\": \"-13\"}", &m);
    let mut m = TestFmtJsonWellKnownTypes::new();
    m.mut_uint64_value().value = 13;
    test_json_print_parse_message("{\"uint64Value\": \"13\"}", &m);
    let mut m = TestFmtJsonWellKnownTypes::new();
    m.mut_int32_value().value = -13;
    test_json_print_parse_message("{\"int32Value\": -13}", &m);
    let mut m = TestFmtJsonWellKnownTypes::new();
    m.mut_uint32_value().value = 13;
    test_json_print_parse_message("{\"uint32Value\": 13}", &m);
    let mut m = TestFmtJsonWellKnownTypes::new();
    m.mut_bool_value().value = true;
    test_json_print_parse_message("{\"boolValue\": true}", &m);
    let mut m = TestFmtJsonWellKnownTypes::new();
    m.mut_string_value().value = "ab".to_owned();
    test_json_print_parse_message("{\"stringValue\": \"ab\"}", &m);
    let mut m = TestFmtJsonWellKnownTypes::new();
    m.mut_bytes_value().value = b"ab".to_vec();
    test_json_print_parse_message("{\"bytesValue\": \"YWI=\"}", &m);
}

#[test]
fn test_any() {
    let mut m = TestFmtJsonWellKnownTypes::new();
    m.any_value.mut_or_insert_default();
    // TODO
}

#[test]
fn test_field_mask() {
    let mut m = TestFmtJsonWellKnownTypes::new();

    m.set_field_mask(FieldMask::new());
    test_json_print_parse_message("{\"fieldMask\": \"\"}", &m);

    m.set_field_mask({
        let mut v = FieldMask::new();
        v.paths = vec!["a.b".to_owned()].into();
        v
    });
    test_json_print_parse_message("{\"fieldMask\": \"a.b\"}", &m);

    m.set_field_mask({
        let mut v = FieldMask::new();
        v.paths = vec!["ab".to_owned(), "c.d.e".to_owned()].into();
        v
    });
    test_json_print_parse_message("{\"fieldMask\": \"ab,c.d.e\"}", &m);
}

'''
'''--- test-crates/protobuf-codegen-protoc-test/src/common/v2/test_fmt_text_format.rs ---
use protobuf::text_format::print_to_string;
use protobuf::MessageField;
use protobuf::MessageFull;
use protobuf_test_common::*;

use super::test_fmt_text_format_pb::*;

#[test]
fn test_display() {
    let mut m = TestTypes::new();
    m.set_bool_singular(true);
    assert_eq!("bool_singular: true", &*format!("{}", m));
}

#[test]
fn test_pretty() {
    let mut tm = TestMessage::new();
    tm.set_value(23);
    let mut m = TestTypes::new();
    m.set_test_message_singular(tm);
    m.set_string_singular("abc".to_string());
    m.mut_string_repeated().push("def".to_string());
    m.mut_string_repeated().push("ghi".to_string());
    assert_eq!(
        "string_singular: \"abc\"\ntest_message_singular {\n  value: 23\n}\nstring_repeated: \"def\"\nstring_repeated: \"ghi\"\n",
        &*format!("{:#}", m)
    );
}

#[test]
fn test_rust_identifier() {
    let mut m = TestTextFormatRustIdentifier::new();
    m.set_const(true);
    assert_eq!("const: true", &*format!("{}", m));
}

#[test]
fn test_empty() {
    test_text_format_str_descriptor("", &TestTypes::descriptor());
}

#[test]
fn test_enum() {
    test_text_format_str_descriptor("test_enum_singular: DARK", &TestTypes::descriptor());

    test_text_format_str_descriptor(
        "test_enum_repeated: DARK test_enum_repeated: LIGHT test_enum_repeated: LIGHT",
        &TestTypes::descriptor(),
    );
}

#[test]
fn test_int() {
    test_text_format_str_descriptor("uint32_singular: 98", &TestTypes::descriptor());
    test_text_format_str_descriptor("uint64_singular: 100", &TestTypes::descriptor());

    test_text_format_str_descriptor("int32_singular: 98", &TestTypes::descriptor());
    test_text_format_str_descriptor("int64_singular: 100", &TestTypes::descriptor());
    test_text_format_str_descriptor("int32_singular: -98", &TestTypes::descriptor());
    test_text_format_str_descriptor("int64_singular: -100", &TestTypes::descriptor());

    test_text_format_str_descriptor("fixed32_singular: 98", &TestTypes::descriptor());
    test_text_format_str_descriptor("fixed64_singular: 100", &TestTypes::descriptor());
    test_text_format_str_descriptor("sfixed32_singular: 98", &TestTypes::descriptor());
    test_text_format_str_descriptor("sfixed64_singular: 100", &TestTypes::descriptor());
    test_text_format_str_descriptor("sfixed32_singular: -98", &TestTypes::descriptor());
    test_text_format_str_descriptor("sfixed64_singular: -100", &TestTypes::descriptor());

    test_text_format_str_descriptor(
        "int32_repeated: 98 int32_repeated: -99",
        &TestTypes::descriptor(),
    );
}

#[test]
fn test_parse_float() {
    test_text_format_str_descriptor("float_singular: 98.5", &TestTypes::descriptor());
    test_text_format_str_descriptor("float_singular: -99.5", &TestTypes::descriptor());
    test_text_format_str_descriptor("float_singular: -99", &TestTypes::descriptor());
    test_text_format_str_descriptor("double_singular: 98.5", &TestTypes::descriptor());
    test_text_format_str_descriptor("double_singular: -99.5", &TestTypes::descriptor());
    test_text_format_str_descriptor("double_singular: 99", &TestTypes::descriptor());
}

#[test]
fn test_bool() {
    test_text_format_str_descriptor("bool_singular: true", &TestTypes::descriptor());
    test_text_format_str_descriptor("bool_singular: false", &TestTypes::descriptor());
    test_text_format_str_descriptor(
        "bool_repeated: false bool_repeated: false bool_repeated: true",
        &TestTypes::descriptor(),
    );
}

#[test]
fn test_string_bytes() {
    test_text_format_str_descriptor("string_singular: \"\"", &TestTypes::descriptor());
    test_text_format_str_descriptor("string_singular: \"a b\"", &TestTypes::descriptor());
    test_text_format_str_descriptor("string_singular: \"a\\nb\"", &TestTypes::descriptor());

    test_text_format_str_descriptor("bytes_singular: \"\"", &TestTypes::descriptor());
    test_text_format_str_descriptor("bytes_singular: \"a b\"", &TestTypes::descriptor());
    test_text_format_str_descriptor("bytes_singular: \"a\\nb\"", &TestTypes::descriptor());
    test_text_format_str_descriptor("bytes_singular: \"a\\xfeb\"", &TestTypes::descriptor());

    test_text_format_str_descriptor(
        "string_repeated: \"ab\" bytes_repeated: \"cd\" string_repeated: \"ef\"",
        &TestTypes::descriptor(),
    );

    test_text_format_str_descriptor(
        "string_singular: \"quote\\\"newline\\nbackslash\\\\del\\177\"",
        &TestTypes::descriptor(),
    );
}

#[test]
fn test_message() {
    test_text_format_str_descriptor("test_message_singular {}", &TestTypes::descriptor());

    test_text_format_str_descriptor(
        "test_message_singular { value: 10 }",
        &TestTypes::descriptor(),
    );

    test_text_format_str_descriptor(
        "test_message_repeated { value: 10 } test_message_repeated { value: 20 }",
        &TestTypes::descriptor(),
    );

    test_text_format_str_descriptor("test_message_singular <>", &TestTypes::descriptor());

    test_text_format_str_descriptor(
        "test_message_singular < value: 10 >",
        &TestTypes::descriptor(),
    );

    assert!(
        parse_using_rust_protobuf(
            "test_message_singular < value: 10 }",
            &TestTypes::descriptor()
        )
        .is_err(),
        "Parsing a message with mismatched message start and terminator symbols should fail."
    );

    assert!(
        parse_using_rust_protobuf(
            "test_message_singular { value: 10 >",
            &TestTypes::descriptor()
        )
        .is_err(),
        "Parsing a message with mismatched message start and terminator symbols should fail."
    );
}

#[test]
fn test_map_keys_sorted() {
    // TODO
    // When generating text format for a .proto, maps are sorted by key.
    // Numeric keys are sorted numerically.
}

#[test]
fn test_reflect() {
    for m in special_messages_typed::<TestTypes>() {
        test_text_format_message(&m);
        // This slow test is equivalent to the fast test below.
        // Do just one iteration as smoke test.
        // `break` statement can be commented out for easier debugging.
        break;
    }

    let mut l = TestTypesList::new();
    // TODO: make `ts` field public in codegen
    l.set_ts(special_messages_typed().into());
    test_text_format_message(&l);
}

#[test]
fn test_parse_error() {
    let e = protobuf::text_format::parse_from_str::<TestTypes>("nonexistent: 42").unwrap_err();
    let _error: &dyn std::error::Error = &e;
    assert_eq!(e.to_string(), "1:1: Unknown field: `nonexistent`");
}

fn t<F: FnMut(&mut TestTypes)>(expected: &str, mut setter: F) {
    let mut m = TestTypes::new();
    setter(&mut m);
    assert_eq!(&*print_to_string(&m), expected);
}

#[test]
fn test_singular() {
    t("int32_singular: 99", |m| m.set_int32_singular(99));
    t("double_singular: 99", |m| m.set_double_singular(99.0));
    t("float_singular: 99", |m| m.set_float_singular(99.0));
    t("int32_singular: 99", |m| m.set_int32_singular(99));
    t("int64_singular: 99", |m| m.set_int64_singular(99));
    t("uint32_singular: 99", |m| m.set_uint32_singular(99));
    t("uint64_singular: 99", |m| m.set_uint64_singular(99));
    t("sint32_singular: 99", |m| m.set_sint32_singular(99));
    t("sint64_singular: 99", |m| m.set_sint64_singular(99));
    t("fixed32_singular: 99", |m| m.set_fixed32_singular(99));
    t("fixed64_singular: 99", |m| m.set_fixed64_singular(99));
    t("sfixed32_singular: 99", |m| m.set_sfixed32_singular(99));
    t("sfixed64_singular: 99", |m| m.set_sfixed64_singular(99));
    t("bool_singular: true", |m| m.set_bool_singular(true));
    t("string_singular: \"abc\"", |m| {
        m.set_string_singular("abc".to_string())
    });
    t("bytes_singular: \"def\"", |m| {
        m.set_bytes_singular(b"def".to_vec())
    });
    t("test_enum_singular: DARK", |m| {
        m.set_test_enum_singular(TestEnum::DARK)
    });
    t("test_message_singular {}", |m| {
        m.test_message_singular = MessageField::some(Default::default())
    });
}

#[test]
fn test_repeated_one() {
    t("int32_repeated: 99", |m| m.int32_repeated.push(99));
    t("double_repeated: 99", |m| m.double_repeated.push(99.0));
    t("float_repeated: 99", |m| m.float_repeated.push(99.0));
    t("int32_repeated: 99", |m| m.int32_repeated.push(99));
    t("int64_repeated: 99", |m| m.int64_repeated.push(99));
    t("uint32_repeated: 99", |m| m.uint32_repeated.push(99));
    t("uint64_repeated: 99", |m| m.uint64_repeated.push(99));
    t("sint32_repeated: 99", |m| m.sint32_repeated.push(99));
    t("sint64_repeated: 99", |m| m.sint64_repeated.push(99));
    t("fixed32_repeated: 99", |m| m.fixed32_repeated.push(99));
    t("fixed64_repeated: 99", |m| m.fixed64_repeated.push(99));
    t("sfixed32_repeated: 99", |m| m.sfixed32_repeated.push(99));
    t("sfixed64_repeated: 99", |m| m.sfixed64_repeated.push(99));
    t("bool_repeated: false", |m| m.bool_repeated.push(false));
    t("string_repeated: \"abc\"", |m| {
        m.string_repeated.push("abc".to_string())
    });
    t("bytes_repeated: \"def\"", |m| {
        m.bytes_repeated.push(b"def".to_vec())
    });
    t("test_enum_repeated: DARK", |m| {
        m.test_enum_repeated.push(TestEnum::DARK.into())
    });
    t("test_message_repeated {}", |m| {
        m.test_message_repeated.push(Default::default());
    });
}

#[test]
fn test_repeated_multiple() {
    t(
        "uint32_singular: 30 int32_repeated: 10 int32_repeated: -20",
        |m| {
            m.set_uint32_singular(30);
            m.int32_repeated.push(10);
            m.int32_repeated.push(-20);
        },
    );
}

#[test]
fn test_complex_message() {
    t("test_message_singular {value: 30}", |m| {
        m.test_message_singular
            .mut_or_insert_default()
            .set_value(30)
    });
}

#[test]
fn test_string_escaped() {
    let mut m = TestTypes::new();
    m.set_string_singular("quote\"newline\nbackslash\\del\x7f".to_string());
    assert_eq!(
        "string_singular: \"quote\\\"newline\\nbackslash\\\\del\\177\"",
        &*format!("{}", m)
    );
}

'''
'''--- test-crates/protobuf-codegen-protoc-test/src/common/v2/test_generate_accessors.rs ---
use super::test_generate_accessors_pb::*;

#[test]
fn test() {
    // Check accessors are generated
    WithAccessors::new().f();
    WithAccessors::new().set_i(10);

    // Check that field is public
    // even if it's not requested explicitly
    WithoutAccessors::new().f;
}

'''
'''--- test-crates/protobuf-codegen-protoc-test/src/common/v2/test_ident.rs ---
use protobuf::MessageFull;

use super::test_ident_pb::*;

#[test]
fn test() {
    let _ = TestType::new();
}

#[test]
fn test_reflect() {
    Self_::new();
    // instantiate reflection
    assert_eq!("Self", Self_::descriptor().name());
}

'''
'''--- test-crates/protobuf-codegen-protoc-test/src/common/v2/test_import_descriptor.rs ---
use super::test_import_descriptor_pb::*;

#[test]
fn test() {
    let _ = FooBar::new();
}

'''
'''--- test-crates/protobuf-codegen-protoc-test/src/common/v2/test_lite_runtime.rs ---
use protobuf_test_common::*;

use super::test_lite_runtime_pb::*;

#[test]
fn test_lite_runtime() {
    let mut m = TestLiteRuntime::new();
    m.set_v(10);
    test_serialize_deserialize("08 0a", &m);

    // test it doesn't crash
    format!("{:?}", m);
}

'''
'''--- test-crates/protobuf-codegen-protoc-test/src/common/v2/test_map_field_references_nested.rs ---
use super::test_map_field_references_nested_pb::*;

#[test]
fn test() {
    MapFieldReferencesNested::new();
}

'''
'''--- test-crates/protobuf-codegen-protoc-test/src/common/v2/test_map_simple.rs ---
use protobuf::text_format::print_to_string;
use protobuf_test_common::*;

use super::test_map_simple_pb::*;

#[test]
fn test_map() {
    let mut map = TestMap::new();
    let mut entry = TestMapEntry::new();
    entry.set_v(10);

    test_serialize_deserialize_with_dynamic("", &map);

    map.mut_m().insert("two".to_owned(), 2);
    test_serialize_deserialize_with_dynamic("0a 07 0a 03 74 77 6f 10 02", &map);

    map.mut_m().insert("sixty six".to_owned(), 66);
    // Insert map entry sub message
    map.mut_mm().insert("map".to_owned(), entry);
    // cannot (easily) test hex, because order is not specified
    test_serialize_deserialize_no_hex_with_dynamic(&map);
}

#[test]
fn test_map_negative_i32_value() {
    let mut map = TestMap::new();
    map.mut_m().insert("two".to_owned(), -2);
    test_serialize_deserialize_with_dynamic(
        "0a 10 0a 03 74 77 6f 10 fe ff ff ff ff ff ff ff ff 01",
        &map,
    );
}

#[test]
fn test_map_with_object() {
    let mut map = TestMap::new();

    let mut entry = TestMapEntry::new();
    entry.set_v(10);

    test_serialize_deserialize_with_dynamic("", &map);

    map.mut_mm().insert("map".to_owned(), entry);
    // cannot (easily) test hex, because order is not specified
    test_serialize_deserialize_no_hex_with_dynamic(&map);
}

#[test]
fn test_map_unset_default_fields() {
    // unset key and value
    let mut m = TestMap::new();
    m.m.insert("".to_owned(), 0);
    test_deserialize("0a 00", &m);

    // unset value
    let mut m = TestMap::new();
    m.m.insert("ab".to_owned(), 0);
    test_deserialize("0a 04 0a 02 61 62", &m);

    // unset key
    let mut m = TestMap::new();
    m.m.insert("".to_owned(), 17);
    test_deserialize("0a 02 10 11", &m);
}

#[test]
fn text_format() {
    let mut map = TestMap::new();

    assert_eq!(&*print_to_string(&map), "");

    map.mut_m().insert("two".to_owned(), 2);

    assert_eq!(&*print_to_string(&map), "m {key: \"two\" value: 2}");

    let map = recreate_as_dynamic(&map);

    assert_eq!(&*print_to_string(&*map), "m {key: \"two\" value: 2}");
}

'''
'''--- test-crates/protobuf-codegen-protoc-test/src/common/v2/test_map_tokio.rs ---
use bytes::Bytes;
use protobuf::*;
use protobuf_test_common::*;

use super::test_map_tokio_pb::*;

#[test]
fn test_string_to_int32() {
    let mut map = TestMapTokio::new();
    map.string_to_int32.insert(Chars::from("abc"), 17);
    test_serialize_deserialize_with_dynamic("0a 07 0a 03 61 62 63 10 11", &map);
    //                          field 1, length-delimited
    //                             length
    //                                field 1, wire type 2
    //                                   length
    //                                      a  b  c
    //                                               field 2, varint
    //                                                  17
}

#[test]
fn test_int32_to_bytes() {
    let mut map = TestMapTokio::new();
    map.int32_to_string.insert(17, Chars::from("abc"));
    test_serialize_deserialize_with_dynamic("12 07 08 11 12 03 61 62 63", &map);
    let mut map = TestMapTokio::new();
    map.int32_to_bytes.insert(17, Bytes::from("abc"));
    test_serialize_deserialize_with_dynamic("1a 07 08 11 12 03 61 62 63", &map);
}

'''
'''--- test-crates/protobuf-codegen-protoc-test/src/common/v2/test_message_getter.rs ---
use super::test_message_getter_pb::MessageForTestGetter;

#[test]
fn get_returns_default_value() {
    let m = MessageForTestGetter::new();
    assert_eq!(0, m.i());
    assert_eq!(false, m.b());
}

'''
'''--- test-crates/protobuf-codegen-protoc-test/src/common/v2/test_nested_issue_476.rs ---
use super::test_nested_issue_476_pb::*;

#[test]
fn test() {
    Foo::new();
}

'''
'''--- test-crates/protobuf-codegen-protoc-test/src/common/v2/test_oneof_basic.rs ---
use protobuf::OneofFull;
use protobuf_test_common::*;

use super::test_oneof_basic_pb::*;

#[test]
fn test_simple() {
    let mut test_message = TestOneof::new();
    test_message.set_uint32_field(150);
    test_serialize_deserialize("28 96 01", &test_message);
}

#[test]
fn test_set_clear_field() {
    let mut test_message = TestOneof::new();

    test_message.set_int32_field(10);
    assert!(test_message.has_int32_field());
    assert_eq!(10, test_message.int32_field());
    assert!(!test_message.has_bool_field());
    assert_eq!(false, test_message.bool_field());

    test_message.set_bool_field(true);
    assert!(test_message.has_bool_field());
    assert_eq!(true, test_message.bool_field());
    assert!(!test_message.has_int32_field());
    assert_eq!(0, test_message.int32_field());

    test_message.clear_int32_field();
    assert!(!test_message.has_int32_field());
    assert!(!test_message.has_bool_field());
    assert_eq!(false, test_message.bool_field());
    assert_eq!(0, test_message.int32_field());
}

#[test]
fn test_types() {
    fn t<F>(f: F)
    where
        F: Fn(&mut TestOneof),
    {
        let mut o = TestOneof::new();
        f(&mut o);
        test_serialize_deserialize_no_hex(&o);
    }

    t(|o| o.set_double_field(10.0));
    t(|o| o.set_float_field(11.0));
    t(|o| o.set_int32_field(12));
    t(|o| o.set_int64_field(13));
    t(|o| o.set_uint32_field(14));
    t(|o| o.set_uint64_field(15));
    t(|o| o.set_sint32_field(16));
    t(|o| o.set_sint64_field(17));
    t(|o| o.set_fixed32_field(18));
    t(|o| o.set_fixed64_field(19));
    t(|o| o.set_sfixed32_field(20));
    t(|o| o.set_sfixed64_field(21));
    t(|o| o.set_bool_field(true));
    t(|o| o.set_string_field("asas".to_string()));
    t(|o| o.set_bytes_field(vec![99, 100]));
    t(|o| o.set_enum_field(EnumForOneof::A));
    t(|o| o.mut_message_field().set_f(22));
}

#[test]
fn reflection() {
    assert_eq!("one", test_oneof::One::descriptor().name());
}

'''
'''--- test-crates/protobuf-codegen-protoc-test/src/common/v2/test_oneof_recursive.rs ---
use super::test_oneof_recursive_pb::*;

#[test]
fn test() {
    let _ = LinkedList::new();
}

'''
'''--- test-crates/protobuf-codegen-protoc-test/src/common/v2/test_reflect_basic.rs ---
use protobuf::reflect::FieldDescriptor;
use protobuf::reflect::ReflectFieldRef;
use protobuf::reflect::ReflectOptionalRef;
use protobuf::reflect::ReflectValueBox;
use protobuf::reflect::ReflectValueRef;
use protobuf::reflect::RuntimeFieldType;
use protobuf::EnumFull;
use protobuf::MessageDyn;
use protobuf::MessageFull;
use protobuf_test_common::value_for_runtime_type;

use super::test_reflect_basic_pb::*;

#[test]
fn test_get_sub_message_via_reflection() {
    let mut m = M::new();
    m.mut_sub_m().set_n(42);
    assert!(m.has_sub_m());

    let descriptor = m.descriptor_dyn();

    let field_descriptor = descriptor.field_by_name("sub_m").unwrap();
    assert_eq!("sub_m", field_descriptor.name());

    let sub_m = field_descriptor.get_message(&m);
    assert_eq!("test_reflect.SubM", sub_m.descriptor_dyn().full_name());
    assert_eq!(
        42,
        sub_m
            .descriptor_dyn()
            .field_by_name("n")
            .unwrap()
            .get_singular_field_or_default(&*sub_m)
            .to_i32()
            .unwrap()
    );
}

#[test]
fn test_singular_basic() {
    let mut message = TestTypesSingular::new();
    let descriptor = message.descriptor_dyn();

    let bool_field = descriptor.field_by_name("bool_field").unwrap();
    assert!(!bool_field.has_field(&message));

    bool_field.set_singular_field(&mut message, ReflectValueBox::Bool(true));
    assert!(bool_field.has_field(&message));
    assert_eq!(
        true,
        bool_field
            .get_singular_field_or_default(&message)
            .to_bool()
            .unwrap()
    );
}

fn test_singular_field(message: &mut dyn MessageDyn, field: &FieldDescriptor) {
    assert!(!field.has_field(message));

    // should not crash
    field.get_singular_field_or_default(message);

    let value = value_for_runtime_type(&field.singular_runtime_type());
    field.set_singular_field(message, value);
}

#[test]
fn test_singular() {
    let mut message = TestTypesSingular::new();
    let descriptor = message.descriptor_dyn();

    for field in descriptor.fields() {
        test_singular_field(&mut message, &field);
    }
}

#[test]
fn test_repeated_debug() {
    let mut message = TestTypesRepeated::new();
    message.set_int32_field(vec![10, 20, 30]);
    let field = message
        .descriptor_dyn()
        .field_by_name("int32_field")
        .unwrap()
        .get_repeated(&message);
    assert_eq!("[10, 20, 30]", format!("{:?}", field));
}

fn test_repeated_field(message: &mut dyn MessageDyn, field: &FieldDescriptor) {
    assert!(!field.has_field(message));

    let mut expected = Vec::new();

    // test mut interface
    {
        let mut repeated = field.mut_repeated(message);

        for i in 0..3 {
            let value = value_for_runtime_type(&repeated.element_type());
            expected.push(value.clone());
            repeated.push(value.clone());
            let fetched = repeated.get(i);
            assert_eq!(value, fetched);
        }

        assert_eq!(expected, repeated);
        assert_eq!(repeated, expected);
    }

    // test read interface
    {
        let repeated = field.get_repeated(message);
        assert_eq!(3, repeated.len());

        assert_eq!(expected, repeated);
        assert_eq!(repeated, expected);
    }
}

#[test]
fn test_repeated() {
    let mut message = TestTypesRepeated::new();
    let descriptor = message.descriptor_dyn();

    for field in descriptor.fields() {
        test_repeated_field(&mut message, &field);
    }
}

fn test_map_field(message: &mut dyn MessageDyn, field: &FieldDescriptor) {
    assert!(field.get_map(message).is_empty());
    assert_eq!(0, field.get_map(message).len());
    assert!(field.mut_map(message).is_empty());
    assert_eq!(0, field.mut_map(message).len());

    let (k, v) = match field.runtime_field_type() {
        RuntimeFieldType::Map(k, v) => (k, v),
        _ => panic!("not a map"),
    };

    {
        let map = field.get_map(message);
        assert!(map.is_empty());
        assert_eq!(0, map.len());

        assert_eq!(None, map.get(value_for_runtime_type(&k).as_value_ref()));
    }

    {
        let mut map = field.mut_map(message);
        assert!(map.is_empty());
        assert_eq!(0, map.len());

        assert_eq!(None, map.get(value_for_runtime_type(&k).as_value_ref()));

        let key = value_for_runtime_type(&k);
        let value = value_for_runtime_type(&v);

        map.insert(key.clone(), value.clone());

        assert_eq!(Some(value.as_value_ref()), map.get(key.as_value_ref()));

        assert_eq!(1, map.len());
    }
}

#[test]
fn test_map() {
    let mut message = TestTypesMap::new();
    let descriptor = message.descriptor_dyn();

    for field in descriptor.fields() {
        test_map_field(&mut message, &field);
    }
}

#[test]
fn test_nested_message() {
    assert_eq!(
        "test_reflect.WithNestedMessage.NestedMessage",
        with_nested_message::NestedMessage::descriptor().full_name()
    );
}

#[test]
fn test_nested_enum() {
    assert_eq!(
        "test_reflect.WithNestedMessage.NestedEnum",
        with_nested_message::NestedEnum::enum_descriptor().full_name()
    );
}

#[test]
fn test_mut_message() {
    let mut m = TestTypesSingular::new();
    {
        let descriptor = m.descriptor_dyn();
        let message_field_field = descriptor.field_by_name("message_field").unwrap();
        let sub_m = message_field_field.mut_message(&mut m);
        let descriptor = sub_m.descriptor_dyn();
        let n_field = descriptor.field_by_name("n").unwrap();
        n_field.set_singular_field(sub_m, ReflectValueBox::I32(10));
        // TODO: test `mut_message` works for oneof fields
    }
    assert_eq!(10, m.message_field().n());
}

#[test]
fn test_get_reflect_singular() {
    let mut m = TestTypesSingular::new();
    m.set_int64_field(10);
    let descriptor = m.descriptor_dyn();
    let f = descriptor.field_by_name("int64_field").unwrap();
    match f.get_reflect(&m) {
        ReflectFieldRef::Optional(v) if v == ReflectOptionalRef::some(ReflectValueRef::I64(10)) => {
        }
        _ => panic!(),
    }
}

#[test]
fn test_get_reflect_repeated() {
    let mut m = TestTypesRepeated::new();
    m.set_int64_field(vec![10, 20]);
    let descriptor = m.descriptor_dyn();
    let f = descriptor.field_by_name("int64_field").unwrap();
    match f.get_reflect(&m) {
        ReflectFieldRef::Repeated(repeated) => {
            assert_eq!(2, repeated.len());
            assert_eq!(ReflectValueRef::I64(10), repeated.get(0));
            assert_eq!(ReflectValueRef::I64(20), repeated.get(1));
        }
        _ => panic!(),
    }
}

#[test]
fn test_get_reflect_map() {
    let mut m = TestTypesMap::new();
    m.set_int64_field(vec![(10, 33), (20, 44)].into_iter().collect());
    let descriptor = m.descriptor_dyn();
    let f = descriptor.field_by_name("int64_field").unwrap();
    match f.get_reflect(&m) {
        ReflectFieldRef::Map(map) => {
            assert_eq!(2, map.len());
            assert_eq!(
                Some(ReflectValueRef::I64(33)),
                map.get(ReflectValueRef::I64(10))
            );
            assert_eq!(
                Some(ReflectValueRef::I64(44)),
                map.get(ReflectValueRef::I64(20))
            );
        }
        _ => panic!(),
    }
}

#[test]
fn test_json_name() {
    let descriptor = M::descriptor();
    let field_descriptor = descriptor.field_by_name("sub_m").unwrap();
    // Note that we intentionally do not call `descriptor.json_name()`, since
    // that will compute a JSON name if one is not already present in the proto.
    // We want to verify that the compiler has encoded the correct JSON name in
    // the descriptor itself.
    assert_eq!("subM", field_descriptor.proto().json_name());
}

'''
'''--- test-crates/protobuf-codegen-protoc-test/src/common/v2/test_reflect_clear.rs ---
use std::collections::HashMap;

use protobuf::reflect::ReflectValueBox;
use protobuf::MessageFull;

use super::test_reflect_clear_pb::*;

#[test]
fn test_generated() {
    let mut map = HashMap::new();
    map.insert("key".to_string(), "value".to_string());

    let mut msg = TestMessage::default();
    msg.set_a(1);
    msg.set_b("b".to_string());
    msg.set_c(test_message::Nested::default());
    msg.set_d(vec![1, 2, 3]);
    msg.set_e(map);

    let msg_desc = TestMessage::descriptor();

    let a_field = msg_desc.field_by_name("a").unwrap();
    let b_field = msg_desc.field_by_name("b").unwrap();
    let c_field = msg_desc.field_by_name("c").unwrap();
    let d_field = msg_desc.field_by_name("d").unwrap();
    let e_field = msg_desc.field_by_name("e").unwrap();

    a_field.clear_field(&mut msg);
    b_field.clear_field(&mut msg);
    c_field.clear_field(&mut msg);
    d_field.clear_field(&mut msg);
    e_field.clear_field(&mut msg);

    assert_eq!(TestMessage::default(), msg);
}

#[test]
fn test_dynamic() {
    let msg_desc = TestMessage::descriptor();
    let a_field = msg_desc.field_by_name("a").unwrap();
    let b_field = msg_desc.field_by_name("b").unwrap();
    let c_field = msg_desc.field_by_name("c").unwrap();
    let d_field = msg_desc.field_by_name("d").unwrap();
    let e_field = msg_desc.field_by_name("e").unwrap();

    let mut msg = msg_desc.new_instance();

    let mut map = HashMap::new();
    map.insert("key".to_string(), "value".to_string());

    a_field.set_singular_field(msg.as_mut(), 1.into());
    b_field.set_singular_field(msg.as_mut(), "b".to_string().into());
    c_field.set_singular_field(
        msg.as_mut(),
        ReflectValueBox::Message(Box::new(test_message::Nested::default())),
    );
    let mut d_repeated = d_field.mut_repeated(msg.as_mut());
    d_repeated.push(1.into());

    let mut e_map = e_field.mut_map(msg.as_mut());
    e_map.insert("key".to_string().into(), "value".to_string().into());

    a_field.clear_field(msg.as_mut());
    b_field.clear_field(msg.as_mut());
    c_field.clear_field(msg.as_mut());
    d_field.clear_field(msg.as_mut());
    e_field.clear_field(msg.as_mut());

    let msg_empty = msg_desc.new_instance();
    assert_eq!(msg.to_string(), msg_empty.to_string());
}

'''
'''--- test-crates/protobuf-codegen-protoc-test/src/common/v2/test_reflect_issue_564.rs ---
use protobuf::descriptor::field_descriptor_proto;
use protobuf::reflect::ReflectValueRef;
use protobuf::MessageDyn;

use super::test_reflect_issue_564_pb::*;

fn visit_fields(mes: &dyn MessageDyn) {
    let mut seen_enum = false;
    let mut seen_message = false;

    let descriptor = mes.descriptor_dyn();
    for field in descriptor.fields() {
        if field.has_field(mes) {
            match field.proto().type_() {
                field_descriptor_proto::Type::TYPE_ENUM => {
                    match field.get_singular(mes) {
                        Some(ReflectValueRef::Enum(e, value)) => {
                            assert_eq!(
                                "TEST_ENUM_VALUE_B",
                                e.value_by_number(value).unwrap().name()
                            );
                            assert!(!seen_enum);
                            seen_enum = true;
                        }
                        Some(..) => panic!("not an enum"),
                        None => panic!("must be set"),
                    };
                }
                field_descriptor_proto::Type::TYPE_MESSAGE => {
                    let _ = field.get_message(mes);
                    assert!(!seen_message);
                    seen_message = true;
                }
                _ => {}
            }
        }
    }
    assert!(seen_enum);
    assert!(seen_message);
}

#[test]
fn test() {
    let mut mes = Issue564::default();
    mes.set_ee(issue564::TestEnum::TEST_ENUM_VALUE_B);
    mes.set_mm(Default::default());
    visit_fields(&mes);
}

'''
'''--- test-crates/protobuf-codegen-protoc-test/src/common/v2/test_reflect_no_package.rs ---
#[test]
fn test_no_package() {
    let file_descriptor = super::test_reflect_no_package_pb::file_descriptor();
    assert!(!file_descriptor.proto().has_package());
}

'''
'''--- test-crates/protobuf-codegen-protoc-test/src/common/v2/test_repeated_packed.rs ---
use protobuf_test_common::*;

use super::test_repeated_packed_pb::*;

// varint field number = 4
// unpacked tag = 20
// packed tag   = 22
// sfixed32 field number = 5
// unpacked tag = 2d
// packed tag   = 2a

#[test]
fn test_write_unpacked() {
    let mut test = TestUnpacked::new();
    test.varints = vec![17i32, 1000];
    test_serialize_deserialize("20 11 20 e8 07", &test);
    let mut test = TestUnpacked::new();
    test.sfixed32s = vec![17i32, 1000];
    test_serialize_deserialize("2d 11 00 00 00 2d e8 03 00 00", &test);
}

#[test]
fn test_read_unpacked_to_unpacked() {
    let mut test = TestUnpacked::new();
    test.varints = vec![17i32, 1000];
    test_deserialize("20 11 20 e8 07", &test);
    let mut test = TestUnpacked::new();
    test.sfixed32s = vec![17i32, 1000];
    test_deserialize("2d 11 00 00 00 2d e8 03 00 00", &test);
}

#[test]
fn test_read_packed_to_unpacked() {
    let mut test = TestUnpacked::new();
    test.varints = vec![17i32, 1000];
    test_deserialize("22 03 11 e8 07", &test);
    let mut test = TestUnpacked::new();
    test.sfixed32s = vec![17i32, 1000];
    test_deserialize("2a 08 11 00 00 00 e8 03 00 00", &test);
}

#[test]
fn test_write_packed_varint() {
    let mut test = TestPacked::new();
    test.varints = vec![17i32, 1000];
    test_serialize_deserialize("22 03 11 e8 07", &test);
}

#[test]
fn test_write_packed_fixed() {
    let mut test = TestPacked::new();
    test.sfixed32s = vec![17i32, 1000];
    test_serialize_deserialize("2a 08 11 00 00 00 e8 03 00 00", &test);
}

#[test]
fn test_read_unpacked_to_packed() {
    let mut test = TestPacked::new();
    test.varints = vec![17i32, 1000];
    test_deserialize("20 11 20 e8 07", &test);
    let mut test = TestPacked::new();
    test.sfixed32s = vec![17i32, 1000];
    test_deserialize("2d 11 00 00 00 2d e8 03 00 00", &test);
}

#[test]
fn test_read_packed_to_packed() {
    let mut test = TestPacked::new();
    test.varints = vec![17i32, 1000];
    test_deserialize("22 03 11 e8 07", &test);
    let mut test = TestPacked::new();
    test.sfixed32s = vec![17i32, 1000];
    test_deserialize("2a 08 11 00 00 00 e8 03 00 00", &test);
}

#[test]
fn test_issue_281() {
    // Data len len was incorrectly computed.
    // For 100 elements, bytes len is 400
    // and varint len of 400 is 2,
    // while varint len of 100 is 1.
    let mut test = TestIssue281::new();
    test.values = (0..100).collect();
    test_serialize_deserialize_no_hex(&test);
}

'''
'''--- test-crates/protobuf-codegen-protoc-test/src/common/v2/test_root.rs ---
use super::test_root_pb::*;

#[test]
fn test() {
    let _ = Root::new();
}

'''
'''--- test-crates/protobuf-codegen-protoc-test/src/common/v2/test_service.rs ---
use super::test_service_pb::*;

#[test]
fn test_service() {
    // The request/response types should still
    // get generated, even though we ignore the
    // service definition in the same file.
    let _ = Request::new();
    let _ = Response::new();
}

#[test]
fn reflect() {
    let services = file_descriptor().services().collect::<Vec<_>>();
    assert_eq!(1, services.len());
}

'''
'''--- test-crates/protobuf-codegen-protoc-test/src/common/v2/test_singular_concat.rs ---
//! Test when two messages are concatenated, singular fields are taken from the last one.

use protobuf_test_common::*;

use super::test_singular_concat_pb::*;

#[test]
fn test_concat_bytes() {
    let mut m = TestSingularConcat::new();
    m.set_b(b"\xdd\xee".to_vec());

    test_deserialize("12 03 aa bb cc 12 02 dd ee", &m);
}

#[test]
fn test_concat_string() {
    let mut m = TestSingularConcat::new();
    m.set_s("\x61\x62".to_string());

    test_deserialize("0a 03 21 22 23 0a 02 61 62", &m);
}

'''
'''--- test-crates/protobuf-codegen-protoc-test/src/common/v2/test_sync.rs ---
use std::sync::Arc;
use std::thread;

use protobuf::CodedInputStream;
use protobuf::Message;

use super::test_sync_pb::*;

// test messages are sync
#[test]
fn test_sync() {
    let m = Arc::new({
        let mut r = TestSync::new();
        r.set_int32_field(23);
        r
    });

    let threads: Vec<_> = (0..4)
        .map(|_| {
            let m_copy = m.clone();
            thread::spawn(move || {
                let bytes = m_copy.write_to_bytes().unwrap();
                let mut is = CodedInputStream::from_bytes(&bytes);
                let mut read = TestSync::new();
                // API is not very convenient here
                read.merge_from(&mut is).unwrap();
                read.check_initialized().unwrap();
                read.int32_field()
            })
        })
        .collect();

    let results = threads
        .into_iter()
        .map(|t| t.join().unwrap())
        .collect::<Vec<_>>();
    assert_eq!(&[23, 23, 23, 23], &results[..]);
}

'''
'''--- test-crates/protobuf-codegen-protoc-test/src/common/v2/test_tokio_bytes.rs ---
use bytes::Bytes;
use protobuf::Chars;
use protobuf_test_common::*;

use super::test_tokio_bytes_pb::*;

#[test]
fn test() {
    let mut m = TestTokioBytes::new();
    m.set_b1(Bytes::from("aabb"));
    m.set_s1(Chars::from("ccdd"));

    let mut br = Vec::new();
    br.push(Bytes::from("bb1"));
    br.push(Bytes::from("bb2"));
    m.set_br(br);

    let mut sr = Vec::new();
    sr.push(Chars::from("ss1"));
    sr.push(Chars::from("ss2"));
    m.set_sr(sr);

    test_serialize_deserialize_no_hex_with_dynamic(&m);
}

'''
'''--- test-crates/protobuf-codegen-protoc-test/src/common/v2/test_well_known_types.rs ---
use super::test_well_known_types_pb::*;

#[test]
fn test() {
    // Just check it typechecks
    UsesWellKnownTypes::new();
}

'''
'''--- test-crates/protobuf-codegen-protoc-test/src/google/mod.rs ---
mod protobuf;

'''
'''--- test-crates/protobuf-codegen-protoc-test/src/google/protobuf/README.md ---
Files copied from
[Google protobuf implementation](https://github.com/google/protobuf/tree/master/src/google/protobuf)

'''
'''--- test-crates/protobuf-codegen-protoc-test/src/google/protobuf/import-tests.sh ---
#!/bin/sh -e

cd "$(dirname "$0")"

rm -rf *.proto protobuf-git

git clone --branch v3.5.2 --depth 1 https://github.com/google/protobuf/ protobuf-git

cp protobuf-git/src/google/protobuf/unittest*.proto ./

rm -rf protobuf-git

# This file causes memory overflow in `rustc` when executed on travis-ci
rm unittest_enormous_descriptor.proto

# These files duplicate similar files for proto2 and cannot be compiled together
rm *_proto3.proto

# vim: set ts=4 sw=4 et:

'''
'''--- test-crates/protobuf-codegen-protoc-test/src/include_generated/mod.rs ---
// Include single mod.rs which references two mods: `v2` and `v3`
include!(concat!(env!("OUT_DIR"), "/include_generated/mod.rs"));

use v2::V2Message;
use v3::V3Message;

#[test]
fn test() {
    let _ = V2Message::new();
    let _ = V3Message::new();
}

'''
'''--- test-crates/protobuf-codegen-protoc-test/src/interop/bin.rs ---
use protobuf::Message;
use protobuf_test_common::hex::encode_hex;
use protobuf_test_common::interop_json_decode;

use super::interop_pb::InteropMessageList;
use crate::interop::interop_pb::InteropMessage;

#[test]
fn test_repeated_packed_fixed_encoding() {
    let mut mm = InteropMessageList::new();
    mm.ts.push(InteropMessage {
        fixed32_repeated: vec![17, 34],
        ..InteropMessage::default()
    });

    let interop_bin = interop_json_decode("{ts: [{fixed32_repeated: [17, 34]}]}");
    let our_bin = mm.write_to_bytes().unwrap();
    // TODO: we are not using packed encoding for fixed
    if false {
        assert_eq!(encode_hex(&interop_bin), encode_hex(&our_bin));
    }
}

'''
'''--- test-crates/protobuf-codegen-protoc-test/src/interop/json.rs ---
use protobuf::json;
use protobuf::reflect::ReflectEqMode;
use protobuf::Message;
use protobuf_test_common::*;

use super::interop_pb::*;
use crate::interop;

fn test_parse_message(m: &InteropMessageList) {
    let json = interop::interop_json_encode_typed(m);

    let mut mm = InteropMessageList::new();

    protobuf_json_mapping::merge_from_str(&mut mm, &json).expect("parse json");

    assert!(
        Message::reflect_eq(m, &mm, &ReflectEqMode::nan_equal()),
        "{:?} != {:?}; json: {}",
        m,
        mm,
        json
    );
}

fn test_print_message(m: &InteropMessageList) {
    let m_json = protobuf_json_mapping::print_to_string(m).unwrap();

    let mm = interop::interop_json_decode_typed(&m_json);

    assert!(
        Message::reflect_eq(m, &mm, &ReflectEqMode::nan_equal()),
        "{:?} != {:?}",
        m,
        mm
    );
}

#[test]
fn parse_empty() {
    test_parse_message(&InteropMessageList::new());
}

#[test]
fn parse_random() {
    for m in special_messages_typed::<InteropMessage>() {
        let mut l = InteropMessageList::new();
        l.ts.push(m);
        test_parse_message(&l);
        // This slow test is equivalent to the fast test below.
        // Do just one iteration as smoke test.
        // `break` statement can be commented out for easier debugging.
        break;
    }

    let mut l = InteropMessageList::new();
    l.ts = special_messages_typed().into();
    test_parse_message(&l);
}

#[test]
fn print_empty() {
    test_print_message(&InteropMessageList::new());
}

#[test]
fn print_random() {
    for m in special_messages_typed::<InteropMessage>() {
        let mut l = InteropMessageList::new();
        l.ts.push(m);
        test_print_message(&l);
        // This slow test is equivalent to the fast test below.
        // Do just one iteration as smoke test.
        // `break` statement can be commented out for easier debugging.
        break;
    }

    let mut l = InteropMessageList::new();
    l.ts = special_messages_typed().into();
    test_print_message(&l);
}

'''
'''--- test-crates/protobuf-codegen-protoc-test/src/interop/mod.rs ---
// @generated

pub mod interop_pb;

'''
'''--- test-crates/protobuf-codegen-protoc-test/src/lib.rs ---
#![cfg(test)]

extern crate protobuf;

extern crate protobuf_test_common;

#[cfg(feature = "with-bytes")]
extern crate bytes;

mod v2;
mod v3;

mod common;

mod google;

mod interop;

mod include_generated;

'''
'''--- test-crates/protobuf-codegen-protoc-test/src/v2/README.md ---
Tests for codegen with `syntax = "proto2"`.

'''
'''--- test-crates/protobuf-codegen-protoc-test/src/v2/test_default_values.rs ---
use super::test_default_values_pb::*;

#[test]
fn test_default_value_simple() {
    let d = TestDefaultValues::new();
    assert_eq!(1.0, d.double_field());
    assert_eq!(2.0, d.float_field());
    assert_eq!(3, d.int32_field());
    assert_eq!(4, d.int64_field());
    assert_eq!(5, d.uint32_field());
    assert_eq!(6, d.uint64_field());
    assert_eq!(7, d.sint32_field());
    assert_eq!(8, d.sint64_field());
    assert_eq!(9, d.fixed32_field());
    assert_eq!(10, d.fixed64_field());
    assert_eq!(11, d.sfixed32_field());
    assert_eq!(12, d.sfixed64_field());
    assert_eq!(true, d.bool_field());
    assert_eq!(false, d.bool_default_false_field());
    assert_eq!("abc\n22", d.string_field());
    assert_eq!(b"cde\n33", d.bytes_field());
    assert_eq!(EnumForDefaultValue::TWO, d.enum_field());
    assert_eq!(EnumForDefaultValue::ONE, d.enum_field_without_default());
}

#[test]
fn test_default_value_extreme() {
    let d = TestExtremeDefaultValues::new();
    assert_eq!(f64::INFINITY, d.inf_double());
    assert_eq!(f64::NEG_INFINITY, d.neg_inf_double());
    assert!(d.nan_double().is_nan());
    assert_eq!(f32::INFINITY, d.inf_float());
    assert_eq!(f32::NEG_INFINITY, d.neg_inf_float());
    assert!(d.nan_float().is_nan());
    assert_eq!(b"\0\x01\x07\x08\x0c\n\r\t\x0b\\\'\"\xfe", d.escaped_bytes());
    assert_eq!("'", d.quote1());
    assert_eq!("\"", d.quote2());
    assert_eq!(b"'", d.bquote1());
    assert_eq!(b"\"", d.bquote2());
}

'''
'''--- test-crates/protobuf-codegen-protoc-test/src/v2/test_is_initialized.rs ---
use protobuf::reflect::FileDescriptor;
use protobuf::reflect::ReflectValueBox;
use protobuf::MessageDyn;

use crate::v2::test_is_initialized_pb;
use crate::v2::test_is_initialized_pb::TestIsInitialized;

fn file_descriptor_dynamic() -> FileDescriptor {
    FileDescriptor::new_dynamic(
        test_is_initialized_pb::file_descriptor().proto().clone(),
        &[],
    )
    .unwrap()
}

fn test_is_initialized(message: &mut dyn MessageDyn) {
    assert!(!message.is_initialized_dyn());
    let field = message.descriptor_dyn().field_by_name("a").unwrap();
    field.set_singular_field(message, ReflectValueBox::I32(10));
    assert!(message.is_initialized_dyn());
}

#[test]
fn is_initialized_generated() {
    let mut message = TestIsInitialized::new();
    test_is_initialized(&mut message);
}

#[test]
fn is_initialized_dynamic() {
    let file_descriptor = file_descriptor_dynamic();
    let message_descriptor = file_descriptor
        .message_by_package_relative_name("TestIsInitialized")
        .unwrap();
    let mut message = message_descriptor.new_instance();
    test_is_initialized(&mut *message);
}

'''
'''--- test-crates/protobuf-codegen-protoc-test/src/v2/test_issue_579.rs ---
use super::test_issue_579_pb::Demo;

#[test]
fn test() {
    let _ = Demo::Fizz;
}

'''
'''--- test-crates/protobuf-codegen-protoc-test/src/v2/test_oneof_default_value.rs ---
use super::test_oneof_default_value_pb::*;

#[test]
fn test() {
    let m = TestOneofDefaultValue::new();
    assert_eq!(9.0, m.double_field());
    assert_eq!("ss", m.string_field());
    assert_eq!(b"bb", m.bytes_field());
}

'''
'''--- test-crates/protobuf-codegen-protoc-test/src/v2/test_oneof_group.rs ---
use super::test_oneof_group_pb::A;

#[test]
fn test() {
    A::new();
}

'''
'''--- test-crates/protobuf-codegen-protoc-test/src/v2/test_reflect_default.rs ---
use protobuf::EnumOrUnknown;
use protobuf::MessageFull;

use super::test_reflect_default_pb::*;

#[test]
fn test_regular() {
    let m = TestReflectDefault::new();

    let descriptor = TestReflectDefault::descriptor();

    let i = descriptor.field_by_name("i").unwrap();
    assert_eq!(10, i.get_singular_field_or_default(&m).to_i32().unwrap());

    let s = descriptor.field_by_name("s").unwrap();
    assert_eq!("sss", s.get_singular_field_or_default(&m).to_str().unwrap());

    let e = descriptor.field_by_name("e").unwrap();
    assert_eq!(
        EnumOrUnknown::new(Fruit::BANANA),
        e.get_singular_field_or_default(&m)
            .downcast_clone()
            .unwrap()
    );
}

#[test]
fn test_oneof() {
    let m = TestReflectDefault::new();

    let descriptor = TestReflectDefault::descriptor();

    let i = descriptor.field_by_name("oi").unwrap();
    assert_eq!(10, i.get_singular_field_or_default(&m).to_i32().unwrap());

    let s = descriptor.field_by_name("os").unwrap();
    assert_eq!("sss", s.get_singular_field_or_default(&m).to_str().unwrap());

    let e = descriptor.field_by_name("oe").unwrap();
    assert_eq!(
        EnumOrUnknown::new(Fruit::BANANA),
        e.get_singular_field_or_default(&m)
            .downcast_clone()
            .unwrap()
    );
}

'''
'''--- test-crates/protobuf-codegen-protoc-test/src/v2/test_required.rs ---
use protobuf::Message;

use super::test_required_pb::*;

#[test]
fn test_write_missing_required() {
    assert!(TestRequired::new().write_to_bytes().is_err());
}

#[test]
fn test_read_missing_required() {
    assert!(TestRequired::parse_from_bytes(&[]).is_err());
}

#[test]
fn test_is_initialized_is_recursive() {
    let mut m = TestRequiredOuter::new();
    assert!(!m.is_initialized());
    m.inner = Some(Default::default()).into();
    assert!(!m.is_initialized());
    m.inner.as_mut().unwrap().set_b(false);
    assert!(m.is_initialized());
}

'''
'''--- test-crates/protobuf-codegen-protoc-test/src/v2/test_tokio_bytes_default_value.rs ---
use protobuf::*;

use super::test_tokio_bytes_default_value_pb::*;

#[test]
fn test_default_values() {
    assert_eq!("sss", TestTokioBytesDefaultValues::default_instance().s());
    assert_eq!(b"bbb", TestTokioBytesDefaultValues::default_instance().b());
    assert_eq!(&""[..], &**TestTokioBytesDefaultValues::new().mut_s());
    assert_eq!(&b""[..], &**TestTokioBytesDefaultValues::new().mut_b());
}

'''
'''--- test-crates/protobuf-codegen-protoc-test/src/v2/test_unknown_suffix.rs ---
use super::test_unknown_suffix_pb_proto3::TestUnknownSuffix;

#[test]
fn test() {
    TestUnknownSuffix::new();
}

'''
'''--- test-crates/protobuf-codegen-protoc-test/src/v3/README.md ---
Tests for codegen with `syntax = "proto3"`.

'''
'''--- test-crates/protobuf-codegen-protoc-test/src/v3/test_optional.rs ---
use protobuf::reflect::ReflectValueRef;
use protobuf::MessageFull;
use protobuf_test_common::test_serialize_deserialize_with_dynamic;

use super::test_optional_pb::*;

#[test]
fn serialize_deserialize() {
    let mut message = TestOptionalProto3::new();
    message.iii = Some(0x1a);
    test_serialize_deserialize_with_dynamic("f8 01 1a", &message);
}

#[test]
fn field_types() {
    let message = TestOptionalProto3::new();
    let _iii: &Option<i32> = &message.iii;
    let _sss: &Option<String> = &message.sss;
}

#[test]
fn reflect_all_oneofs() {
    let descriptor = TestOptionalProto3::descriptor();
    let oneofs = descriptor.all_oneofs().collect::<Vec<_>>();
    assert!(oneofs.len() > 1);
    assert!(!oneofs[0].is_synthetic());
    for oneof in &oneofs[1..] {
        assert!(oneof.is_synthetic());
        let mut fields = oneof.fields().collect::<Vec<_>>();
        assert_eq!(1, fields.len());
        let field = fields.swap_remove(0);
        assert_eq!(None, field.containing_oneof());
        assert_eq!(
            Some(oneof),
            field.containing_oneof_including_synthetic().as_ref()
        );
    }
}

#[test]
fn reflect_oneofs() {
    let descriptor = TestOptionalProto3::descriptor();
    let oneofs = descriptor.oneofs().collect::<Vec<_>>();
    assert_eq!(1, oneofs.len());
    assert!(!oneofs[0].is_synthetic());

    let mut message = TestOptionalProto3::new();

    let iii = descriptor.field_by_name("iii").unwrap();

    assert_eq!(None, iii.get_singular(&mut message));

    iii.set_singular_field(&mut message, 17.into());
    assert_eq!(Some(17), message.iii);
    assert_eq!(
        Some(ReflectValueRef::I32(17)),
        iii.get_singular(&mut message)
    );
}

'''
'''--- test-crates/protobuf-codegen-protoc-test/src/v3/test_zeros_are_not_written.rs ---
use protobuf_test_common::*;

use super::test_zeros_are_not_written_pb::*;

#[test]
fn test_zeros_are_not_written() {
    let mut m = TestZerosAreNotWritten::new();
    m.bool_field = false;
    m.enum_field = TestEnumDescriptor::UNDEFINED.into();
    m.fixed32_field = 0;
    test_serialize("", &m);
}

'''
'''--- test-crates/protobuf-codegen-protoc-test/test.sh ---
#!/bin/sh -ex

cd $(dirname $0)

cargo test --features="$RUST_PROTOBUF_FEATURES"

# vim: set ts=4 sw=4 et:

'''
'''--- test-crates/protobuf-codegen-pure-test/Cargo.toml ---
[package]
name = "protobuf-codegen-pure-test"
version = "0.0.0"
authors = ["Stepan Koltsov <stepan.koltsov@gmail.com>"]
publish = false
edition = "2021"
description = "Test pure codegen"

[lib]
doctest = false
bench = false

[features]
default = []
proto3 = []
with-bytes = ["bytes", "protobuf/with-bytes", "protobuf-test-common/with-bytes"]

[build-dependencies]
protobuf-codegen = { path = "../../protobuf-codegen" }
protobuf-test-common = { path = "../../test-crates/protobuf-test-common" }
glob        = "0.2"
log         = "0.4"
env_logger  = "0.5.*"

[dependencies]
bytes = { version = "1.1", optional = true }

protobuf = { path = "../../protobuf" }
protobuf-test-common = { path = "../../test-crates/protobuf-test-common" }
protobuf-json-mapping = { path = "../../protobuf-json-mapping" }

'''
'''--- test-crates/protobuf-codegen-pure-test/README.md ---
# Tests for `protobuf-codegen-pure` crate

'''
'''--- test-crates/protobuf-codegen-pure-test/build.rs ---
use std::env;
use std::fs;
use std::io::Read;
use std::io::Write;
use std::path::Path;

use protobuf_codegen::Codegen;
use protobuf_test_common::build::*;
use protobuf_test_common::print_rerun_if_changed_recursively;

fn copy_test<P1: AsRef<Path>, P2: AsRef<Path>>(src: P1, dst: P2) {
    eprintln!("copy {:?} to {:?}", src.as_ref(), dst.as_ref());
    let mut content = Vec::new();
    fs::File::open(src.as_ref())
        .expect(&format!("open {}", src.as_ref().display()))
        .read_to_end(&mut content)
        .expect(&format!("read_to_end {}", src.as_ref().display()));

    let mut write = fs::File::create(dst).expect("create");
    writeln!(write, "// @generated").expect("write");
    writeln!(write, "// copied from {}", src.as_ref().display()).expect("write");
    writeln!(write, "").expect("write");
    write.write_all(&content).expect("write_all");
    // Print generated twice to avoid overlooking it accidentally
    writeln!(write, "// @generated").expect("write");
    write.flush().expect("flush");
}

fn copy_from_protobuf_test(path: &str) {
    copy_test(
        &format!("../../test-crates/protobuf-codegen-protoc-test/{}", path),
        &format!("{}", path),
    )
}

enum FileNameClass {
    ModRs,
    TestRs,
    Proto,
    GeneratedRs,
    Ignore,
}

fn classify_file_name(dir: &str, name: &str) -> FileNameClass {
    if name.starts_with(".") || name.ends_with(".md") || name.ends_with(".sh") {
        FileNameClass::Ignore
    } else if name.ends_with("_pb.rs") || name.ends_with("_pb_proto3.rs") {
        FileNameClass::GeneratedRs
    } else if name == "mod.rs" {
        FileNameClass::ModRs
    } else if name.ends_with(".proto") || name.ends_with(".proto3") {
        FileNameClass::Proto
    } else if name.ends_with(".rs") {
        if dir == "src/google/protobuf" {
            FileNameClass::GeneratedRs
        } else {
            FileNameClass::TestRs
        }
    } else {
        panic!("unknown test file: {}", name);
    }
}

// Copy tests from `protobuf-test` directory to the same directory here
fn copy_tests(dir: &str) {
    let src_dir = format!("../../test-crates/protobuf-codegen-protoc-test/{}", dir);
    for entry in fs::read_dir(&src_dir).expect(&format!("read_dir {}", src_dir)) {
        let file_name = entry.expect("entry").file_name().into_string().unwrap();

        match classify_file_name(dir, &file_name) {
            FileNameClass::ModRs | FileNameClass::Ignore | FileNameClass::GeneratedRs => {}
            FileNameClass::TestRs | FileNameClass::Proto => {
                copy_from_protobuf_test(&format!("{}/{}", dir, file_name))
            }
        }
    }
}

fn gen_in_dir(dir: &str, include_dir: &str) {
    gen_in_dir_impl(
        dir,
        |GenInDirArgs {
             out_dir,
             input,
             customize,
         }| {
            Codegen::new()
                .pure()
                .out_dir(out_dir)
                .inputs(input)
                .includes(&[include_dir])
                .customize(customize)
                .run_from_script()
        },
    );
}

fn generate_interop() {
    copy_from_protobuf_test("src/interop/mod.rs");
    copy_from_protobuf_test("src/interop/json.rs");
    copy_from_protobuf_test("src/interop/bin.rs");

    Codegen::new()
        .pure()
        .out_dir("src/interop")
        .includes(&["../../test-crates/interop/cxx", "../../proto"])
        .input("../../test-crates/interop/cxx/interop_pb.proto")
        .run_from_script();
}

fn generate_include_generated() {
    copy_from_protobuf_test("src/include_generated/mod.rs");

    let dir = format!("{}/include_generated", env::var("OUT_DIR").unwrap());
    if Path::new(&dir).exists() {
        fs::remove_dir_all(&dir).unwrap();
    }
    fs::create_dir(&dir).unwrap();
    Codegen::new()
        .pure()
        .out_dir(dir)
        .input("../../test-crates/protobuf-codegen-protoc-test/src/include_generated/v2.proto")
        .input("../../test-crates/protobuf-codegen-protoc-test/src/include_generated/v3.proto")
        .include("../../test-crates/protobuf-codegen-protoc-test/src/include_generated")
        .run_from_script();
}

fn generate_pb_rs() {
    print_rerun_if_changed_recursively("../../test-crates/protobuf-codegen-protoc-test");

    copy_tests("src/v2");
    gen_in_dir("src/v2", "src/v2");

    copy_tests("src/v3");
    gen_in_dir("src/v3", "src/v3");

    copy_tests("src/common/v2");
    gen_in_dir("src/common/v2", "src/common/v2");

    copy_tests_v2_v3("src/common/v2", "src/common/v3");
    gen_in_dir("src/common/v3", "src/common/v3");

    copy_tests("src/google/protobuf");
    gen_in_dir("src/google/protobuf", "src");

    generate_interop();

    generate_include_generated();
}

fn main() {
    env_logger::init();

    clean_old_files();
    generate_pb_rs();
}

'''
'''--- test-crates/protobuf-codegen-pure-test/src/common/mod.rs ---
mod v2;

mod v3;

'''
'''--- test-crates/protobuf-codegen-pure-test/src/lib.rs ---
#![cfg(test)]

mod v2;
mod v3;

mod common;

mod interop;

mod include_generated;

'''
'''--- test-crates/protobuf-codegen-pure-test/test.sh ---
#!/bin/sh -ex

cd $(dirname $0)

cargo test --features="$RUST_PROTOBUF_FEATURES"

# vim: set ts=4 sw=4 et:

'''
'''--- test-crates/protobuf-fuzz/Cargo.toml ---
[package]
name = "protobuf-fuzz"
version = "0.0.0"
authors = ["Stepan Koltsov <stepan.koltsov@gmail.com>"]
publish = false
edition = "2021"

[lib]
doctest = false
bench = false

[features]
default = []
with-bytes = ["bytes", "protobuf/with-bytes", "protobuf-test-common/with-bytes"]

[build-dependencies]
protobuf-codegen = { path = "../../protobuf-codegen" }
protobuf-test-common = { path = "../../test-crates/protobuf-test-common" }
glob        = "0.2"
log         = "0.4"
env_logger  = "0.5.*"

[dependencies]
bytes = { version = "1.1", optional = true }

protobuf = { path = "../../protobuf" }
protobuf-json-mapping = { path = "../../protobuf-json-mapping" }
protobuf-test-common = { path = "../../test-crates/protobuf-test-common" }

'''
'''--- test-crates/protobuf-fuzz/build.rs ---
use protobuf_codegen::Codegen;
use protobuf_codegen::Customize;

fn main() {
    protobuf_test_common::build::clean_old_files();

    Codegen::new()
        .pure()
        .out_dir("src")
        .include("src")
        .input("src/all_types_pb.proto")
        .customize(Customize::default().gen_mod_rs(false))
        .run_from_script();
}

'''
'''--- test-crates/protobuf-fuzz/fuzz/Cargo.toml ---
[package]
name = "protobuf-fuzz-fuzz"
version = "0.0.1"
authors = ["Automatically generated"]
publish = false
edition = "2021"

[package.metadata]
cargo-fuzz = true

[dependencies.protobuf-fuzz]
path = ".."
[dependencies.libfuzzer-sys]
git = "https://github.com/rust-fuzz/libfuzzer-sys.git"

# Prevent this from interfering with workspaces
[workspace]
members = ["."]

[[bin]]
name = "all"
path = "fuzz_targets/all.rs"

[[bin]]
name = "empty_message"
path = "fuzz_targets/empty_message.rs"

[[bin]]
name = "empty_message_read"
path = "fuzz_targets/empty_message_read.rs"

[[bin]]
name = "singular"
path = "fuzz_targets/singular.rs"

[[bin]]
name = "singular_read"
path = "fuzz_targets/singular_read.rs"

[[bin]]
name = "repeated"
path = "fuzz_targets/repeated.rs"

[[bin]]
name = "repeated_read"
path = "fuzz_targets/repeated_read.rs"

[[bin]]
name = "map"
path = "fuzz_targets/map.rs"

[[bin]]
name = "map_read"
path = "fuzz_targets/map_read.rs"

'''
'''--- test-crates/protobuf-fuzz/fuzz/fuzz_targets/all.rs ---
#![no_main]
#[macro_use] extern crate libfuzzer_sys;
extern crate protobuf_fuzz;

fuzz_target!(|data: &[u8]| {
    protobuf_fuzz::fuzz_target_all(data)
});

'''
'''--- test-crates/protobuf-fuzz/fuzz/fuzz_targets/empty_message.rs ---
#![no_main]
#[macro_use] extern crate libfuzzer_sys;
extern crate protobuf_fuzz;

fuzz_target!(|data: &[u8]| {
    protobuf_fuzz::fuzz_target_empty_message(data)
});

'''
'''--- test-crates/protobuf-fuzz/fuzz/fuzz_targets/empty_message_read.rs ---
#![no_main]
#[macro_use] extern crate libfuzzer_sys;
extern crate protobuf_fuzz;

fuzz_target!(|data: &[u8]| {
    protobuf_fuzz::fuzz_target_empty_message_read(data)
});

'''
'''--- test-crates/protobuf-fuzz/fuzz/fuzz_targets/map.rs ---
#![no_main]
#[macro_use] extern crate libfuzzer_sys;
extern crate protobuf_fuzz;

fuzz_target!(|data: &[u8]| {
    protobuf_fuzz::fuzz_target_map(data)
});

'''
'''--- test-crates/protobuf-fuzz/fuzz/fuzz_targets/map_read.rs ---
#![no_main]
#[macro_use] extern crate libfuzzer_sys;
extern crate protobuf_fuzz;

fuzz_target!(|data: &[u8]| {
    protobuf_fuzz::fuzz_target_map_read(data)
});

'''
'''--- test-crates/protobuf-fuzz/fuzz/fuzz_targets/repeated.rs ---
#![no_main]
#[macro_use] extern crate libfuzzer_sys;
extern crate protobuf_fuzz;

fuzz_target!(|data: &[u8]| {
    protobuf_fuzz::fuzz_target_repeated(data)
});

'''
'''--- test-crates/protobuf-fuzz/fuzz/fuzz_targets/repeated_read.rs ---
#![no_main]
#[macro_use] extern crate libfuzzer_sys;
extern crate protobuf_fuzz;

fuzz_target!(|data: &[u8]| {
    protobuf_fuzz::fuzz_target_repeated_read(data)
});

'''
'''--- test-crates/protobuf-fuzz/fuzz/fuzz_targets/singular.rs ---
#![no_main]
#[macro_use] extern crate libfuzzer_sys;
extern crate protobuf_fuzz;

fuzz_target!(|data: &[u8]| {
    protobuf_fuzz::fuzz_target_singular(data)
});

'''
'''--- test-crates/protobuf-fuzz/fuzz/fuzz_targets/singular_read.rs ---
#![no_main]
#[macro_use] extern crate libfuzzer_sys;
extern crate protobuf_fuzz;

fuzz_target!(|data: &[u8]| {
    protobuf_fuzz::fuzz_target_singular_read(data)
});

'''
'''--- test-crates/protobuf-fuzz/src/lib.rs ---
extern crate protobuf;

use std::io::BufReader;
use std::str;

use protobuf::MessageFull;

pub mod all_types_pb;

fn test_bytes<M: MessageFull>(bytes: &[u8]) {
    drop(M::parse_from_bytes(bytes));
}

fn test_read<M: MessageFull>(bytes: &[u8]) {
    let mut reader = BufReader::new(bytes);
    drop(M::parse_from_reader(&mut reader));
}

fn test_parse_json<M: MessageFull>(bytes: &[u8]) {
    let text = match str::from_utf8(bytes) {
        Ok(text) => text,
        Err(_) => return,
    };
    drop(protobuf_json_mapping::parse_from_str::<M>(text));
}

fn test_parse_text_format<M: MessageFull>(bytes: &[u8]) {
    let text = match str::from_utf8(bytes) {
        Ok(text) => text,
        Err(_) => return,
    };
    drop(protobuf::text_format::parse_from_str::<M>(text));
}

fn test_write_to_bytes<M: MessageFull>(bytes: &[u8]) {
    let message = match M::parse_from_bytes(bytes) {
        Ok(message) => message,
        Err(_) => return,
    };
    drop(message.write_to_bytes());
}

pub fn fuzz_target_empty_message(bytes: &[u8]) {
    test_bytes::<all_types_pb::EmptyMessage>(bytes);
}

pub fn fuzz_target_empty_message_read(bytes: &[u8]) {
    test_read::<all_types_pb::EmptyMessage>(bytes);
}

pub fn fuzz_target_singular(bytes: &[u8]) {
    test_bytes::<all_types_pb::TestTypesSingular>(bytes);
}

pub fn fuzz_target_singular_read(bytes: &[u8]) {
    test_read::<all_types_pb::TestTypesSingular>(bytes);
}

pub fn fuzz_target_repeated(bytes: &[u8]) {
    test_bytes::<all_types_pb::TestTypesRepeated>(bytes);
}

pub fn fuzz_target_repeated_read(bytes: &[u8]) {
    test_read::<all_types_pb::TestTypesRepeated>(bytes);
}

pub fn fuzz_target_map(bytes: &[u8]) {
    test_bytes::<all_types_pb::TestTypesMap>(bytes);
}

pub fn fuzz_target_map_read(bytes: &[u8]) {
    test_read::<all_types_pb::TestTypesMap>(bytes);
}

fn test_message<M: MessageFull>(bytes: &[u8]) {
    if bytes.len() < 1 {
        return;
    }
    match bytes[0] {
        0 => test_bytes::<M>(&bytes[1..]),
        1 => test_read::<M>(&bytes[1..]),
        2 => test_parse_json::<M>(&bytes[1..]),
        3 => test_parse_text_format::<M>(&bytes[1..]),
        4 => test_write_to_bytes::<M>(&bytes[1..]),
        _ => {}
    }
}

pub fn fuzz_target_all(bytes: &[u8]) {
    if bytes.len() < 1 {
        return;
    }
    match bytes[0] {
        0 => test_message::<all_types_pb::TestTypesSingular>(&bytes[1..]),
        1 => test_message::<all_types_pb::TestTypesRepeated>(&bytes[1..]),
        2 => test_message::<all_types_pb::TestTypesMap>(&bytes[1..]),
        _ => {}
    }
}

'''
'''--- test-crates/protobuf-parse-error-test/Cargo.toml ---
[package]
name = "protobuf-parse-error-test"
version = "0.0.0"
authors = ["Stepan Koltsov <stepan.koltsov@gmail.com>"]
publish = false
edition = "2021"

[lib]
doctest = false
bench = false

[dependencies]
tempfile = "3.2.0"

protoc-bin-vendored = "=3.0.0"

protobuf-parse = { path = "../../protobuf-parse" }
protobuf-test-common = { path = "../../test-crates/protobuf-test-common" }
protobuf = { path = "../../protobuf" }

'''
'''--- test-crates/protobuf-parse-error-test/src/lib.rs ---
#![cfg(test)]

use std::fs;

use protobuf_parse::Parser;
use protobuf_test_common::build::glob_simple;
use protoc_bin_vendored::protoc_bin_path;

#[test]
fn tests() {
    for f in glob_simple("test-data/*.proto") {
        test_file(&f)
    }
}

fn test_file(file: &str) {
    println!("Testing {}", file);

    let (expected_protoc, expected_pure) = parse_expected(file);

    let protoc_error = Parser::new()
        .protoc()
        .protoc_path(&protoc_bin_path().unwrap())
        .input(file)
        .include("test-data")
        .capture_stderr()
        .parse_and_typecheck()
        .err()
        .unwrap_or_else(|| {
            panic!("Protoc parse of `{file}` is expected to fail, but it was successful")
        });

    let pure_error = Parser::new()
        .pure()
        .input(file)
        .include("test-data")
        .parse_and_typecheck()
        .err()
        .unwrap_or_else(|| {
            panic!("Pure parse of `{file}` is expected to fail, but it was successful")
        });

    let protoc_error = format!("{:?}", protoc_error);
    let pure_error = format!("{:?}", pure_error);

    assert!(protoc_error.contains(&expected_protoc));
    assert!(
        pure_error.contains(&expected_pure),
        "pure error expected to contain {expected_pure:?}, but was {pure_error:?}"
    );
}

fn parse_expected(file: &str) -> (String, String) {
    let mut expected_protoc = None;
    let mut expected_pure = None;

    for line in fs::read_to_string(file).unwrap().lines() {
        let marker_protoc = "// expected protoc: ";
        let marker_pure = "// expected pure: ";
        if line.starts_with(marker_protoc) {
            assert!(expected_protoc.is_none());
            expected_protoc = Some(line[marker_protoc.len()..].to_owned());
        }
        if line.starts_with(marker_pure) {
            assert!(expected_pure.is_none());
            expected_pure = Some(line[marker_pure.len()..].to_owned());
        }
    }

    (expected_protoc.unwrap(), expected_pure.unwrap())
}

'''
'''--- test-crates/protobuf-test-common/Cargo.toml ---
[package]
name = "protobuf-test-common"
version = "0.0.0"
authors = ["Stepan Koltsov <stepan.koltsov@gmail.com>"]
publish = false
edition = "2021"
description = """
Common code of protobuf tests
"""

[lib]
doctest = false
bench = false

[features]
default = []
proto3 = []
with-bytes = ["bytes", "protobuf/with-bytes"]

[dependencies]
anyhow    = "1.0.53"
glob         = "0.2"
log          = "0.4"
env_logger   = "0.5.*"
tempfile     = "3.0"
bytes = { version = "1.1", optional = true }

protobuf = { path = "../../protobuf" }
protobuf-json-mapping = { path = "../../protobuf-json-mapping" }
protobuf-codegen = { path = "../../protobuf-codegen" }

'''
'''--- test-crates/protobuf-test-common/src/bin/varint-encode.rs ---
use std::env;

use protobuf::CodedOutputStream;
use protobuf_test_common::hex::encode_hex;

fn parse_u64(s: &str) -> anyhow::Result<u64> {
    if s.starts_with("0x") {
        Ok(u64::from_str_radix(&s[2..], 16)?)
    } else {
        Ok(u64::from_str_radix(s, 10)?)
    }
}

fn main() -> anyhow::Result<()> {
    let args: Vec<String> = env::args().skip(1).collect();
    assert_eq!(1, args.len());
    let arg: u64 = parse_u64(&args[0])?;

    let mut varint = Vec::new();
    let mut os = CodedOutputStream::vec(&mut varint);
    os.write_raw_varint64(arg)?;
    os.flush()?;
    drop(os);

    println!("dec:        {}", arg);
    println!("hex:        0x{:x}", arg);
    println!("varint hex: {}", encode_hex(&varint));
    Ok(())
}

'''
'''--- test-crates/protobuf-test-common/src/build.rs ---
//! Common code of `build.rs` of two tests

use std::fs;
use std::io::BufRead;
use std::io::BufReader;
use std::io::Read;
use std::io::Write;
use std::path::Path;

use anyhow::Context;
use glob;
use log::debug;
pub use protobuf_codegen::Customize;

pub fn glob_simple(pattern: &str) -> Vec<String> {
    let mut r: Vec<_> = glob::glob(pattern)
        .expect("glob")
        .map(|g| {
            g.expect("item")
                .as_path()
                .to_str()
                .expect("utf-8")
                .to_owned()
        })
        .collect();
    // Make test stable
    r.sort();
    r
}

fn read_gitignore(dir: &Path) -> Vec<String> {
    let mut patterns = Vec::new();

    let gitignore = format!("{}/.gitignore", dir.display());
    let gitignore = &Path::new(&gitignore);
    if gitignore.exists() {
        let gitignore =
            fs::File::open(gitignore).expect(&format!("open gitignore {:?}", gitignore));
        for line in BufReader::new(gitignore).lines() {
            let line = line.expect("read_line");
            if line.is_empty() || line.starts_with("#") {
                continue;
            }
            patterns.push(line);
        }
    }

    patterns
}

fn clean_recursively(dir: &Path, patterns: &[&str]) {
    assert!(dir.is_dir());

    eprintln!("cleaning ignored files in {:?}", dir);

    let gitignore_patterns = read_gitignore(dir);

    let mut patterns = patterns.to_vec();
    patterns.extend(gitignore_patterns.iter().map(String::as_str));

    let patterns_compiled: Vec<_> = patterns
        .iter()
        .map(|&p| glob::Pattern::new(p).expect("failed to compile pattern"))
        .collect();

    for entry in fs::read_dir(dir).expect("read_dir") {
        let entry = entry.expect("entry");
        let entry_path = entry.path();
        let file_name = entry_path.as_path().file_name().unwrap().to_str().unwrap();
        if entry
            .metadata()
            .expect(&format!("metadata of {:?}", entry_path))
            .is_dir()
        {
            clean_recursively(&entry_path, &patterns);
        } else if file_name == ".gitignore" {
            // keep it
        } else {
            for pattern in &patterns_compiled {
                if pattern.matches(file_name) {
                    fs::remove_file(&entry_path).expect(&format!("remove_file {:?}", entry_path));
                    break;
                }
            }
        }
    }
}

pub fn clean_old_files() {
    clean_recursively(&Path::new("src"), &["*_pb.rs", "*_pb_proto3.rs"]);
}

#[derive(Default)]
pub struct GenInDirArgs<'a> {
    pub out_dir: &'a str,
    pub input: &'a [&'a str],
    pub customize: Customize,
}

/// Generate mod.rs from all files in a directory
pub fn gen_mod_rs_in_dir(dir: &str) {
    assert!(Path::new(dir).is_dir());

    let mut mod_rs = fs::File::create(&format!("{}/mod.rs", dir)).expect("create");

    writeln!(mod_rs, "// @generated by {}", module_path!()).expect("write");
    writeln!(mod_rs, "").expect("write");

    let rs_files = glob_simple(&format!("{}/*.rs", dir));

    for rs in rs_files {
        let file_name = Path::new(&rs)
            .file_name()
            .expect("file_name")
            .to_str()
            .expect("file_name");
        if file_name == "mod.rs" {
            continue;
        }
        assert!(file_name.ends_with(".rs"));
        let mod_name = &file_name[..file_name.len() - ".rs".len()];

        if mod_name.contains("tokio") {
            writeln!(mod_rs, r#"#[cfg(feature = "with-bytes")]"#).expect("write tokio");
        }
        writeln!(mod_rs, "mod {};", mod_name).expect("write");
    }

    mod_rs.flush().expect("flush");
}

enum TestProtobufVersions {
    V2,
    V3,
    Google,
}

#[derive(Eq, PartialEq, Debug)]
enum ProtobufSyntax {
    V2,
    V3,
}

fn test_version_from_file_path(mut file_path: &Path) -> TestProtobufVersions {
    loop {
        let name = file_path
            .file_name()
            .expect("file_name")
            .to_str()
            .expect("to_str");
        if name == "v2" {
            return TestProtobufVersions::V2;
        } else if name == "v3" {
            return TestProtobufVersions::V3;
        } else if name == "google" {
            return TestProtobufVersions::Google;
        }

        file_path = file_path.parent().expect("parent");
    }
}

fn test_version_from_file_content(file_path: &Path) -> ProtobufSyntax {
    let content = fs::read_to_string(file_path).expect(&format!("read_to_string {:?}", file_path));
    if content.contains("syntax = \"proto2\"") {
        return ProtobufSyntax::V2;
    } else if content.contains("syntax = \"proto3\"") {
        return ProtobufSyntax::V3;
    } else {
        panic!(
            "cannot detect protobuf version from file content: {:?}",
            file_path
        );
    }
}

fn check_test_version(file_path: &Path) {
    let expected_version_from_file_name = match test_version_from_file_path(file_path) {
        TestProtobufVersions::V2 => ProtobufSyntax::V2,
        TestProtobufVersions::V3 => ProtobufSyntax::V3,
        TestProtobufVersions::Google => return,
    };

    let version = test_version_from_file_content(file_path);
    assert_eq!(
        expected_version_from_file_name, version,
        "for file: {:?}",
        file_path
    );
}

pub fn gen_in_dir_impl<F>(dir: &str, gen: F)
where
    F: for<'a> Fn(GenInDirArgs<'a>),
{
    log::info!("generating protos in {}", dir);

    let mut protos = Vec::new();
    for suffix in &[".proto", ".proto3"] {
        protos.extend(glob_simple(&format!("{}/*{}", dir, suffix)));
    }

    for file_path in &protos {
        check_test_version(Path::new(file_path));
    }

    assert!(!protos.is_empty(), "no protos found in {}", dir);

    eprintln!(
        "invoking protobuf compiler: out_dir: {:?}, input: {:?}",
        dir, protos
    );

    let customize = Customize::default().gen_mod_rs(false);

    gen(GenInDirArgs {
        out_dir: dir,
        input: &protos.iter().map(|a| a.as_ref()).collect::<Vec<&str>>(),
        customize,
    });

    gen_mod_rs_in_dir(dir);
}

pub fn list_tests_in_dir(dir: &str) -> Vec<String> {
    let mut r = Vec::new();
    for entry in fs::read_dir(dir)
        .with_context(|| format!("read_dir {}", dir))
        .expect("read_dir")
    {
        let entry = entry.expect("entry");
        let entry_path = entry.path();
        let file_name = entry_path.as_path().file_name().unwrap().to_str().unwrap();

        // temporart files
        if file_name.ends_with(".") {
            continue;
        }

        if !file_name.ends_with(".rs") || file_name.ends_with("_pb.rs") {
            continue;
        }

        if file_name == "mod.rs" {
            continue;
        }

        r.push(file_name[..file_name.len() - ".rs".len()].to_owned());
    }

    // Make test stable
    r.sort();

    r
}

pub fn copy_tests_v2_v3(v2_dir: &str, v3_dir: &str) {
    for test_name in list_tests_in_dir(v2_dir) {
        debug!("Copying tests v2 -> v3 from test: {}", test_name);

        let mut p2f =
            fs::File::open(&format!("{}/{}_pb.proto", v2_dir, test_name)).expect("open v2 .proto");
        let mut proto = String::new();
        p2f.read_to_string(&mut proto).expect("read .proto");
        drop(p2f);

        let mut r2f = fs::File::open(&format!("{}/{}.rs", v2_dir, test_name)).expect("open v2 .rs");
        let mut rs = String::new();
        r2f.read_to_string(&mut rs).expect("read .rs");
        drop(r2f);

        let mut p3f = fs::File::create(&format!("{}/{}_pb.proto", v3_dir, test_name))
            .expect("create v3 .proto");
        let mut r3f =
            fs::File::create(&format!("{}/{}.rs", v3_dir, test_name)).expect("create v3 .rs");

        // convert proto2 to proto3
        let proto = proto.replace("optional ", "");
        let proto = proto.replace("required ", "");
        let proto = proto.replace("syntax = \"proto2\";", "syntax = \"proto3\";");
        write!(p3f, "// @generated\n").expect("write");
        write!(p3f, "{}", proto).expect("write");
        p3f.flush().expect("flush");

        write!(r3f, "// @generated\n").expect("write");
        write!(r3f, "{}", rs).expect("write");
        r3f.flush().expect("flush");
    }
}

'''
'''--- test-crates/protobuf-test-common/src/cargo.rs ---
//! Emit instructions to cargo.

use std::fs;
use std::path::Path;

fn print_rerun_if_changed<P: AsRef<Path>>(path: P) {
    let path = path.as_ref();
    println!("cargo:rerun-if-changed={}", path.to_str().expect("to_str"));
}

pub fn print_rerun_if_changed_recursively<P: AsRef<Path>>(path: P) {
    let path = path.as_ref();
    print_rerun_if_changed(path);
    if path.is_dir() {
        for child in fs::read_dir(path).expect("read_dir") {
            let child = child.expect("child").path();
            print_rerun_if_changed_recursively(child);
        }
    }
}

'''
'''--- test-crates/protobuf-test-common/src/dynamic.rs ---
use protobuf::reflect::FileDescriptor;
use protobuf::reflect::MessageDescriptor;
use protobuf::MessageDyn;
use protobuf::MessageFull;

/// Recreate generated message file descriptor as dynamic descriptor.
pub fn dynamic_descriptor_for_descriptor<M: MessageFull>() -> MessageDescriptor {
    let file_descriptor = M::descriptor().file_descriptor().clone();
    let dynamic_file_descriptor = FileDescriptor::new_dynamic(
        M::descriptor().file_descriptor_proto().clone(),
        file_descriptor.deps(),
    )
    .unwrap();

    // Find the dynamic version of the generated message.
    let dynamic_descriptor = dynamic_file_descriptor
        .message_by_package_relative_name(M::descriptor().name_to_package())
        .unwrap();

    // This descriptor is equivalent to `M::descriptor()`, but created dynamically
    // using descriptor data stored in generated files.
    dynamic_descriptor
}

/// Serialize message and parse it back as dynamic message.
pub fn recreate_as_dynamic<M: MessageFull>(m: &M) -> Box<dyn MessageDyn> {
    let bytes = m.write_to_bytes().unwrap();
    let dynamic_descriptor = dynamic_descriptor_for_descriptor::<M>();
    dynamic_descriptor.parse_from_bytes(&bytes).unwrap()
}

'''
'''--- test-crates/protobuf-test-common/src/hex.rs ---
// hex encoder and decoder used by rust-protobuf unittests

use std::char;

fn decode_hex_digit(digit: char) -> u8 {
    match digit {
        '0'..='9' => digit as u8 - '0' as u8,
        'a'..='f' => digit as u8 - 'a' as u8 + 10,
        'A'..='F' => digit as u8 - 'A' as u8 + 10,
        _ => panic!(),
    }
}

pub fn decode_hex(hex: &str) -> Vec<u8> {
    let mut r: Vec<u8> = Vec::new();
    let mut chars = hex.chars().enumerate();
    loop {
        let (pos, first) = match chars.next() {
            None => break,
            Some(elt) => elt,
        };
        if first == ' ' {
            continue;
        }
        let (_, second) = match chars.next() {
            None => panic!("pos = {}d", pos),
            Some(elt) => elt,
        };
        r.push((decode_hex_digit(first) << 4) | decode_hex_digit(second));
    }
    r
}

fn encode_hex_digit(digit: u8) -> char {
    match char::from_digit(digit as u32, 16) {
        Some(c) => c,
        _ => panic!(),
    }
}

fn encode_hex_byte(byte: u8) -> [char; 2] {
    [encode_hex_digit(byte >> 4), encode_hex_digit(byte & 0x0Fu8)]
}

pub fn encode_hex(bytes: &[u8]) -> String {
    let strs: Vec<String> = bytes
        .iter()
        .map(|byte| encode_hex_byte(*byte).iter().map(|c| *c).collect())
        .collect();
    strs.join(" ")
}

#[cfg(test)]
mod test {

    use super::decode_hex;
    use super::encode_hex;

    #[test]
    fn test_decode_hex() {
        assert_eq!(decode_hex(""), [].to_vec());
        assert_eq!(decode_hex("00"), [0x00u8].to_vec());
        assert_eq!(decode_hex("ff"), [0xffu8].to_vec());
        assert_eq!(decode_hex("AB"), [0xabu8].to_vec());
        assert_eq!(decode_hex("fa 19"), [0xfau8, 0x19].to_vec());
    }

    #[test]
    fn test_encode_hex() {
        assert_eq!("".to_string(), encode_hex(&[]));
        assert_eq!("00".to_string(), encode_hex(&[0x00]));
        assert_eq!("ab".to_string(), encode_hex(&[0xab]));
        assert_eq!(
            "01 a2 1a fe".to_string(),
            encode_hex(&[0x01, 0xa2, 0x1a, 0xfe])
        );
    }
}

'''
'''--- test-crates/protobuf-test-common/src/interop.rs ---
use std::io::Read;
use std::io::Write;
use std::process;

/// Invoke `interop` binary, pass given data as stdin, return stdout.
pub fn interop_command(command: &str, stdin: &[u8]) -> Vec<u8> {
    let mut interop = process::Command::new("../test-crates/interop/cxx/interop")
        .args(&[command])
        .stdin(process::Stdio::piped())
        .stdout(process::Stdio::piped())
        .stderr(process::Stdio::inherit())
        .spawn()
        .expect("interop");

    interop
        .stdin
        .take()
        .unwrap()
        .write_all(stdin)
        .expect("write to process");

    let mut stdout = Vec::new();
    interop
        .stdout
        .take()
        .unwrap()
        .read_to_end(&mut stdout)
        .expect("read json");

    let exit_status = interop.wait().expect("wait_with_output");
    assert!(exit_status.success(), "{}", exit_status);

    stdout
}

/// Decode binary protobuf, encode as JSON.
pub fn interop_json_encode(bytes: &[u8]) -> String {
    let json = interop_command("json-encode", bytes);
    String::from_utf8(json).expect("UTF-8")
}

/// Decode JSON, encode as binary protobuf.
pub fn interop_json_decode(s: &str) -> Vec<u8> {
    interop_command("json-decode", s.as_bytes())
}

'''
'''--- test-crates/protobuf-test-common/src/json_tests.rs ---
use protobuf::reflect::ReflectEqMode;
use protobuf::text_format;
use protobuf::MessageDyn;

pub fn test_json_print_parse_message(s: &str, m: &dyn MessageDyn) {
    assert_eq!(
        s,
        protobuf_json_mapping::print_to_string(m).expect("print_to_string")
    );

    test_json_parse_message(s, m);
}

pub fn test_json_parse_message(s: &str, m: &dyn MessageDyn) {
    let descriptor = m.descriptor_dyn();

    let mut new = descriptor.new_instance();
    protobuf_json_mapping::merge_from_str(&mut *new, s).expect("parse");
    assert!(
        m.reflect_eq_dyn(&*new, &ReflectEqMode::nan_equal()),
        "{:?} should be == {:?}",
        text_format::print_to_string(m),
        text_format::print_to_string(&*new)
    );
}

/// Print message to string, parse the string,
/// then check resulting message is equal to the original.
pub fn test_json_message(m: &dyn MessageDyn) {
    let descriptor = m.descriptor_dyn();

    let s = protobuf_json_mapping::print_to_string(m).expect("print_to_string");
    let mut new = descriptor.new_instance();
    protobuf_json_mapping::merge_from_str(&mut *new, &s).expect(&format!(
        "failed to parse serialized: {}; from message: {:?}",
        s, m
    ));
    assert!(
        m.reflect_eq_dyn(&*new, &ReflectEqMode::nan_equal()),
        "{:?} should be == {:?}",
        text_format::print_to_string(m),
        text_format::print_to_string(&*new)
    );
}

'''
'''--- test-crates/protobuf-test-common/src/lib.rs ---
//! Random code uses in protobuf test crates.

pub mod build;
pub mod hex;

mod serialize_deserialize_generated;
pub use serialize_deserialize_generated::*;

mod serialize_deserialize_dynamic;
pub use serialize_deserialize_dynamic::*;

mod serialize_deserialize_both;
pub use serialize_deserialize_both::*;

mod text_format_tests;
pub use text_format_tests::*;

mod json_tests;
pub use json_tests::*;

mod reflect_tests;
pub use reflect_tests::*;

mod cargo;
pub use cargo::*;

mod interop;
pub use interop::*;

mod dynamic;
pub use dynamic::*;

'''
'''--- test-crates/protobuf-test-common/src/reflect_tests.rs ---
use protobuf::reflect::FieldDescriptor;
use protobuf::reflect::MessageDescriptor;
use protobuf::reflect::ReflectValueBox;
use protobuf::reflect::RuntimeFieldType;
use protobuf::reflect::RuntimeType;
use protobuf::well_known_types::struct_::value;
use protobuf::well_known_types::struct_::Value;
use protobuf::MessageDyn;
use protobuf::MessageFull;

pub fn value_for_runtime_type(field_type: &RuntimeType) -> ReflectValueBox {
    match field_type {
        RuntimeType::U32 => ReflectValueBox::U32(11),
        RuntimeType::U64 => ReflectValueBox::U64(12),
        RuntimeType::I32 => ReflectValueBox::I32(13),
        RuntimeType::I64 => ReflectValueBox::I64(14),
        RuntimeType::F32 => ReflectValueBox::F32(15.5),
        RuntimeType::F64 => ReflectValueBox::F64(16.5),
        RuntimeType::Bool => ReflectValueBox::Bool(true),
        RuntimeType::String => ReflectValueBox::String("here".to_owned()),
        RuntimeType::VecU8 => ReflectValueBox::Bytes(b"there".as_ref().to_owned()),
        RuntimeType::Enum(e) => ReflectValueBox::from(e.default_value()),
        RuntimeType::Message(m) => ReflectValueBox::Message(m.new_instance()),
    }
}

fn values_for_message_type(descriptor: &MessageDescriptor) -> Vec<Box<dyn MessageDyn>> {
    if descriptor == &Value::descriptor() {
        // special handling because empty `Value` is not valid
        let mut value = Value::new();
        value.kind = Some(value::Kind::NumberValue(23.0));
        vec![Box::new(value)]
    } else {
        vec![
            // TODO: populated messages
            descriptor.new_instance(),
        ]
    }
}

pub fn values_for_runtime_type(field_type: &RuntimeType) -> Vec<ReflectValueBox> {
    match field_type {
        RuntimeType::U32 => vec![
            ReflectValueBox::U32(11),
            ReflectValueBox::U32(0),
            ReflectValueBox::U32(0x7fff_ffff),
            ReflectValueBox::U32(0x8000_0000),
            ReflectValueBox::U32(0xffff_ffff),
        ],
        RuntimeType::U64 => vec![
            ReflectValueBox::U64(12),
            ReflectValueBox::U64(0),
            ReflectValueBox::U64(0xffff_ffff),
            ReflectValueBox::U64(0xffff_ffff_ffff_ffff),
        ],
        RuntimeType::I32 => vec![
            ReflectValueBox::I32(13),
            ReflectValueBox::I32(0),
            ReflectValueBox::I32(-1),
            ReflectValueBox::I32(0x7fff_ffff),
            ReflectValueBox::I32(0x1000_0000),
        ],
        RuntimeType::I64 => vec![
            ReflectValueBox::I64(14),
            ReflectValueBox::I64(0),
            ReflectValueBox::I64(-1),
            ReflectValueBox::I64(0x7fff_ffff_ffff_ffff),
            ReflectValueBox::I64(0x1000_0000_0000_0000),
        ],
        RuntimeType::F32 => vec![
            ReflectValueBox::F32(15.5),
            ReflectValueBox::F32(0.0),
            ReflectValueBox::F32(-0.0),
            ReflectValueBox::F32(1. / 3.0),
            ReflectValueBox::F32(-1. / 3.0),
            ReflectValueBox::F32(f32::NAN),
            ReflectValueBox::F32(f32::INFINITY),
            ReflectValueBox::F32(-f32::INFINITY),
        ],
        RuntimeType::F64 => vec![
            ReflectValueBox::F64(16.5),
            ReflectValueBox::F64(0.0),
            ReflectValueBox::F64(-0.0),
            ReflectValueBox::F64(1.0 / 3.0),
            ReflectValueBox::F64(-1.0 / 3.0),
            ReflectValueBox::F64(f64::NAN),
            ReflectValueBox::F64(f64::INFINITY),
            ReflectValueBox::F64(-f64::INFINITY),
        ],
        RuntimeType::Bool => vec![ReflectValueBox::Bool(true), ReflectValueBox::Bool(false)],
        RuntimeType::String => vec![
            ReflectValueBox::String("here".to_owned()),
            ReflectValueBox::String("".to_owned()),
            ReflectValueBox::String(" \t\n".to_owned()),
            ReflectValueBox::String("\0".to_owned()),
        ],
        RuntimeType::VecU8 => vec![
            ReflectValueBox::Bytes(b"there".as_ref().to_owned()),
            ReflectValueBox::Bytes(b"".as_ref().to_owned()),
        ],
        RuntimeType::Enum(e) => vec![
            ReflectValueBox::from(e.values().next().unwrap()),
            ReflectValueBox::from(e.values().last().unwrap()),
        ],
        RuntimeType::Message(m) => values_for_message_type(&m)
            .into_iter()
            .map(ReflectValueBox::from)
            .collect(),
    }
}

pub fn special_values_for_field(
    f: &FieldDescriptor,
    d: &MessageDescriptor,
) -> Vec<Box<dyn MessageDyn>> {
    let mut r = Vec::new();
    match f.runtime_field_type() {
        RuntimeFieldType::Singular(t) => {
            for v in values_for_runtime_type(&t) {
                let mut m = d.new_instance();
                f.set_singular_field(&mut *m, v);
                r.push(m);
            }
        }
        RuntimeFieldType::Repeated(t) => {
            // TODO: empty repeated
            // TODO: repeated of more than one element
            let mut m = d.new_instance();
            f.mut_repeated(&mut *m).push(value_for_runtime_type(&t));
            r.push(m);
        }
        RuntimeFieldType::Map(k, v) => {
            // TODO: empty map
            // TODO: map of more than one element
            let mut m = d.new_instance();
            let k = value_for_runtime_type(&k);
            let v = value_for_runtime_type(&v);
            f.mut_map(&mut *m).insert(k, v);
            r.push(m);
        }
    }
    r
}

pub fn special_messages(d: &MessageDescriptor) -> Vec<Box<dyn MessageDyn>> {
    let mut r = Vec::new();
    for f in d.fields() {
        r.extend(special_values_for_field(&f, d));
    }
    r
}

pub fn special_messages_typed<M: MessageFull>() -> Vec<M> {
    let mut r = Vec::new();
    for m in special_messages(&M::descriptor()) {
        r.push(*m.downcast_box().unwrap());
    }
    r
}

'''
'''--- test-crates/protobuf-test-common/src/serialize_deserialize_both.rs ---
use protobuf::MessageFull;

use crate::serialize_then_parse_as_dynamic_and_serialize_and_parse;
use crate::serialize_then_parse_as_dynamic_then_serialize;
use crate::test_serialize_deserialize;
use crate::test_serialize_deserialize_no_hex;

pub fn test_serialize_deserialize_no_hex_with_dynamic<M: MessageFull + PartialEq>(m: &M) {
    test_serialize_deserialize_no_hex(m);
    serialize_then_parse_as_dynamic_and_serialize_and_parse(m);
}

pub fn test_serialize_deserialize_with_dynamic<M: MessageFull + PartialEq>(hex: &str, m: &M) {
    test_serialize_deserialize(hex, m);
    serialize_then_parse_as_dynamic_then_serialize(m);
}

'''
'''--- test-crates/protobuf-test-common/src/serialize_deserialize_dynamic.rs ---
use protobuf::MessageDyn;
use protobuf::MessageFull;

use crate::dynamic_descriptor_for_descriptor;
use crate::hex::encode_hex;
use crate::recreate_as_dynamic;

/// Message comparison test for dynamic messages.
/// - serialize message
/// - deserialize message as dynamic
/// - serialize dynamic message
/// - compare bytes output of generated and dynamic messages
pub fn serialize_then_parse_as_dynamic_then_serialize<M: MessageFull>(
    m: &M,
) -> Box<dyn MessageDyn> {
    // Find the dynamic version of the generated message.
    let description_dynamic = dynamic_descriptor_for_descriptor::<M>();

    // Serialize message as bytes.
    let bytes = m.write_to_bytes().unwrap();
    // Parse it as dynamic message.
    let parsed = description_dynamic.parse_from_bytes(&bytes).unwrap();
    // Now serialize dynamic message.
    let serialized_again = parsed.write_to_bytes_dyn().unwrap();
    // And compare serialized dynamic message with serialized generated message.
    assert_eq!(
        encode_hex(&bytes),
        encode_hex(&serialized_again),
        "serialized({}) != serialized({})",
        m,
        parsed
    );
    parsed
}

/// Message comparison test for dynamic message.
/// - serialize message
/// - parse it as dynamic message
/// - serialize dynamic message
/// - parse serialized dynamic message
/// - compare dynamic messages
pub fn serialize_then_parse_as_dynamic_and_serialize_and_parse<M: MessageFull>(m: &M) {
    let parsed_1 = recreate_as_dynamic(m);
    let bytes_1 = parsed_1.write_to_bytes_dyn().unwrap();
    let parsed_2 = parsed_1
        .descriptor_dyn()
        .parse_from_bytes(&bytes_1)
        .unwrap();
    assert_eq!(&parsed_1, &parsed_2);
}

'''
'''--- test-crates/protobuf-test-common/src/serialize_deserialize_generated.rs ---
use std::fmt;

use protobuf::*;

use crate::hex::decode_hex;
use crate::hex::encode_hex;

pub fn test_serialize_deserialize_length_delimited<M: Message + PartialEq + fmt::Debug>(msg: &M) {
    let serialized_bytes = msg.write_length_delimited_to_bytes().unwrap();
    let mut is = CodedInputStream::from_bytes(&serialized_bytes);
    let parsed = is.read_message().unwrap();
    is.check_eof().unwrap();
    assert_eq!(*msg, parsed);
}

pub fn test_serialize_deserialize_no_hex<M: MessageFull + PartialEq>(msg: &M) {
    let serialized_bytes = msg.write_to_bytes().unwrap();
    let parsed = M::parse_from_bytes(&serialized_bytes).unwrap();
    assert_eq!(*msg, parsed);
}

pub fn test_serialize_deserialize<M: Message + PartialEq + fmt::Debug>(hex: &str, msg: &M) {
    let expected_bytes = decode_hex(hex);
    let expected_hex = encode_hex(&expected_bytes);
    let serialized = msg.write_to_bytes().unwrap();
    let serialized_hex = encode_hex(&serialized);
    assert_eq!(expected_hex, serialized_hex, "message {}", M::NAME);
    let parsed = M::parse_from_bytes(&expected_bytes).unwrap();
    assert_eq!(*msg, parsed);

    assert_eq!(expected_bytes.len(), msg.compute_size() as usize);

    test_serialize_deserialize_length_delimited(msg);
}

pub fn test_deserialize<M: MessageFull + PartialEq>(hex: &str, msg: &M) {
    let bytes = decode_hex(hex);
    let parsed = M::parse_from_bytes(&bytes).unwrap();
    assert_eq!(*msg, parsed);
}

pub fn test_serialize<M: MessageFull>(hex: &str, msg: &M) {
    let hex = encode_hex(&decode_hex(hex));

    let serialized = msg.write_to_bytes().unwrap();
    let serialized_hex = encode_hex(&serialized);

    assert_eq!(serialized_hex, hex);
}

'''
'''--- test-crates/protobuf-test-common/src/text_format_tests.rs ---
use std::error::Error;
use std::fs;
use std::io::Read;
use std::io::Write;
use std::process;

use protobuf::descriptor;
use protobuf::descriptor::FileDescriptorSet;
use protobuf::reflect::MessageDescriptor;
use protobuf::reflect::ReflectEqMode;
use protobuf::rustproto;
use protobuf::text_format::merge_from_str;
use protobuf::text_format::print_to_string;
use protobuf::Message;
use protobuf::MessageDyn;
use tempfile;

pub fn parse_using_rust_protobuf(
    text: &str,
    message_descriptor: &MessageDescriptor,
) -> Result<Box<dyn MessageDyn>, Box<dyn Error>> {
    let mut message = message_descriptor.new_instance();

    merge_from_str(&mut *message, text)?;

    Ok(message)
}

fn parse_using_protoc(text: &str, message_descriptor: &MessageDescriptor) -> Box<dyn MessageDyn> {
    let temp_dir = tempfile::Builder::new()
        .prefix(message_descriptor.name())
        .tempdir()
        .expect("temp dir");

    let mut fds = FileDescriptorSet::new();
    fds.file = vec![
        descriptor::file_descriptor().proto().clone(),
        rustproto::file_descriptor().proto().clone(),
        message_descriptor.file_descriptor_proto().clone(),
    ]
    .into();

    let mut temp_file = temp_dir.path().to_owned();
    temp_file.push("fds");

    fs::write(&temp_file, fds.write_to_bytes().expect("seriailze")).expect("write");

    // TODO: use protoc crate
    let mut protoc = process::Command::new("protoc")
        .args(&[
            &format!(
                "--descriptor_set_in={}",
                temp_file.to_str().expect("to_str")
            ),
            &format!("--encode={}", message_descriptor.full_name()),
            message_descriptor.file_descriptor_proto().name(),
        ])
        .stdin(process::Stdio::piped())
        .stdout(process::Stdio::piped())
        .stderr(process::Stdio::inherit())
        .spawn()
        .expect("protoc");

    let mut stdin = protoc.stdin.take().expect("stdin");
    stdin.write_all(text.as_bytes()).expect("write to stdin");
    drop(stdin);

    let mut encoded = Vec::new();
    protoc
        .stdout
        .take()
        .expect("stdout")
        .read_to_end(&mut encoded)
        .expect("read_to_end");

    let exit_status = protoc.wait().expect("wait");
    assert!(
        exit_status.success(),
        "exit status: {:?} when parsing with protoc: {:?}",
        exit_status,
        text
    );

    let mut expected = message_descriptor.new_instance();
    expected
        .merge_from_bytes_dyn(&encoded)
        .expect("merge_from_bytes");

    expected
}

fn print_using_protoc(message: &dyn MessageDyn) -> String {
    let message_descriptor = message.descriptor_dyn();

    // TODO: copy-paste of parse_using_protoc

    let temp_dir = tempfile::Builder::new()
        .prefix(message_descriptor.name())
        .tempdir()
        .expect("temp dir");

    let mut fds = FileDescriptorSet::new();
    fds.file = vec![
        descriptor::file_descriptor().proto().clone(),
        rustproto::file_descriptor().proto().clone(),
        message_descriptor.file_descriptor_proto().clone(),
    ]
    .into();

    let mut temp_file = temp_dir.path().to_owned();
    temp_file.push("fds");

    fs::write(&temp_file, fds.write_to_bytes().expect("seriailze")).expect("write");

    // TODO: use protoc crate
    let mut protoc = process::Command::new("protoc")
        .args(&[
            &format!(
                "--descriptor_set_in={}",
                temp_file.to_str().expect("to_str")
            ),
            &format!("--decode={}", message_descriptor.full_name()),
            message_descriptor.file_descriptor_proto().name(),
        ])
        .stdin(process::Stdio::piped())
        .stdout(process::Stdio::piped())
        .stderr(process::Stdio::inherit())
        .spawn()
        .expect("protoc");

    let mut stdin = protoc.stdin.take().expect("stdin");
    stdin
        .write_all(&message.write_to_bytes_dyn().expect("serialize"))
        .expect("write to stdin");
    drop(stdin);

    let mut decoded = String::new();
    protoc
        .stdout
        .take()
        .expect("stdout")
        .read_to_string(&mut decoded)
        .expect("read_to_end");

    let exit_status = protoc.wait().expect("wait");
    assert!(
        exit_status.success(),
        "protoc exit status: {:?} while printing: {:?}",
        exit_status,
        message
    );

    decoded
}

pub fn test_text_format_str_descriptor(text: &str, message_descriptor: &MessageDescriptor) {
    let message = parse_using_rust_protobuf(text, message_descriptor)
        .expect(format!("parse_using_rust_protobuf: {:?}", &text).as_str());
    let expected = parse_using_protoc(text, message_descriptor);

    assert!(
        message_descriptor.eq(&*expected, &*message),
        "{:?} != {:?}",
        expected,
        message
    );

    // print using protoc and parse using rust-protobuf
    let printed_using_protoc = print_using_protoc(&*message);
    let pp = parse_using_rust_protobuf(&printed_using_protoc, message_descriptor)
        .expect(format!("parse_using_rust_protobuf: {:?}", &printed_using_protoc).as_str());

    assert!(
        message_descriptor.eq(&*expected, &*pp),
        "{:?} != {:?}",
        expected,
        message
    );
}

pub fn test_text_format_str_message(expected: &str, message: &dyn MessageDyn) {
    assert_eq!(expected, &*print_to_string(message));

    test_text_format_str_descriptor(expected, &message.descriptor_dyn());
}

pub fn test_text_format_message(message: &dyn MessageDyn) {
    let descriptor = message.descriptor_dyn();

    let printed_with_rust_protobuf = print_to_string(message);
    let printed_with_protoc = print_using_protoc(message);

    let from_protoc = parse_using_rust_protobuf(&printed_with_protoc, &descriptor)
        .expect(format!("parse_using_rust_protobuf: {:?}", &printed_with_protoc).as_str());
    let from_protobuf = parse_using_protoc(&printed_with_rust_protobuf, &descriptor);

    assert!(
        message.reflect_eq_dyn(&*from_protoc, &ReflectEqMode::nan_equal()),
        "{:?} != {:?}",
        message,
        from_protoc
    );
    assert!(
        message.reflect_eq_dyn(&*from_protobuf, &ReflectEqMode::nan_equal()),
        "{:?} != {:?}",
        message,
        from_protobuf
    );
}

'''
'''--- test-crates/protobuf-test/Cargo.toml ---
[package]
name = "protobuf-test"
version = "0.0.0"
authors = ["Stepan Koltsov <stepan.koltsov@gmail.com>"]
publish = false
edition = "2021"
description = """
Common code of protobuf tests
"""

[lib]
doctest = false
bench = false

[dependencies]
regex = "1.5.5"

protobuf = { path = "../../protobuf" }
protobuf-parse = { path = "../../protobuf-parse" }

protobuf-test-common = { path = "../protobuf-test-common" }

'''
'''--- test-crates/protobuf-test/src/is_initialized_is_always_true.rs ---
use std::fs;

use protobuf::reflect::FileDescriptor;
use protobuf_parse::Parser;
use regex::Regex;

fn file_descriptor() -> FileDescriptor {
    let typechecked = Parser::new()
        .pure()
        .input("src/is_initialized_is_always_true.proto")
        .include("src")
        .parse_and_typecheck()
        .unwrap();
    let file_descriptors =
        FileDescriptor::new_dynamic_fds(typechecked.file_descriptors, &[]).unwrap();
    file_descriptors
        .into_iter()
        .find(|fd| fd.proto().name() == "is_initialized_is_always_true.proto")
        .unwrap()
}

fn parse_expected() -> Vec<(String, bool)> {
    let content = fs::read_to_string("src/is_initialized_is_always_true.proto").unwrap();
    let mut lines = content.lines();

    let mut r = Vec::new();
    while let Some(line) = lines.next() {
        let expected = if line.starts_with("// YES") {
            true
        } else if line.starts_with("// NO") {
            false
        } else {
            assert!(!line.starts_with("message"));
            continue;
        };
        let line = lines.next().unwrap();
        let message = Regex::new("message (.*) \\{")
            .unwrap()
            .captures(line)
            .unwrap()
            .get(1)
            .unwrap();
        r.push((message.as_str().to_owned(), expected));
    }

    // Sanity check.
    assert!(r.len() > 2);

    r
}

#[test]
fn universal() {
    let file_descriptor = file_descriptor();
    let expected = parse_expected();
    for (name, expected) in expected {
        println!("checking message {name}, expected {expected}");
        let message = file_descriptor
            .message_by_package_relative_name(&name)
            .unwrap();
        assert_eq!(expected, message.is_initialized_is_always_true());
    }
}

'''
'''--- test-crates/protobuf-test/src/lib.rs ---
#![cfg(test)]

mod is_initialized_is_always_true;

'''