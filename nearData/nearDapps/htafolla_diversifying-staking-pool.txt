*GitHub Repository "htafolla/diversifying-staking-pool"*

'''--- .vscode/launch.json ---
{
    // Use IntelliSense to learn about possible attributes.
    // Hover to view descriptions of existing attributes.
    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
    "version": "0.2.0",
    "configurations": [
        {
            "type": "lldb",
            "request": "launch",
            "name": "Debug unit tests in library 'divpool'",
            "cargo": {
                "args": [
                    "+nightly",
                    "test"
                ],
                /*"filter": {
                    "name": "diversifying-staking-pool",
                    "kind": "lib"
                }
                */
            },
            "cwd": "${workspaceFolder}"
        },
        {
            "name": "Debug Simulation Tests",
            "type": "lldb",
            "request": "launch",
            "args": [],
            "program": "target/debug/deps/tests-78512ce406ce79d4",
            "cwd": "${workspaceFolder}",
            "stopOnEntry": false,
            "sourceLanguages": [
              "rust"
            ]
        },
        {
            "name": "Run Simulation Tests",
            "type": "lldb",
            "request": "launch",
            "args": [],
            "program": "target/debug/deps/tests-78512ce406ce79d4",
            "cwd": "${workspaceFolder}",
            "stopOnEntry": false,
            "sourceLanguages": [
              "rust"
            ]
        }
    ]
}
'''
'''--- .vscode/tasks.json ---
{
	"version": "2.0.0",

	"tasks": [

		{
			"label": "build WASM",
			"type": "shell",
			"command": "bash build.sh",
			"problemMatcher": [
				"$rustc"
			],
			"group": {
				"kind": "build",
				"isDefault": true,
			},
		},

		{
			"label": "only cargo test -- --nocapture",
			"type": "shell",
			"command": "clear && cargo test",
			"problemMatcher": [
				"$rustc"
			],
		},

		{
			"type": "shell",
			"label": "simulation test",
			"command": "clear && cd divpool && cargo test -- --nocapture",
			"problemMatcher": [
				"$rustc"
			],
			"group": {
				"kind": "test",
				"isDefault": true,
			},
			"dependsOn":["build WASM"]
		}
	]
}
'''
'''--- Cargo.toml ---
[workspace]
members = [
    "divpool",
    "rewards-register-contract",
    "test-staking-pool",
    "test-get-epoch-contract",
]

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "s"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- LICENSE.md ---
Copyright Narwallets.com 2020. All rights reserved.
 
You acknowledge and agree that Narwallets.com own all legal right, title and interest in and to the work, software, application, source code, documentation and any other documents in this repository (collectively, the “Program”), including any intellectual property rights which subsist in the Program (whether those rights happen to be registered or not, and wherever in the world those rights may exist), whether in source code or any other form.
 
Subject to the limited license below, you may not (and you may not permit anyone else to) distribute, publish, copy, modify, merge, combine with another program, create derivative works of, reverse engineer, decompile or otherwise attempt to extract the source code of, the Program or any part thereof, except that you may contribute to this repository.
 
You are granted a non-exclusive, non-transferable, non-sublicensable license to distribute, publish, copy, modify, merge, combine with another program or create derivative works of the Program (such resulting program, collectively, the “Resulting Program”) solely for Non-Commercial Use as long as you:
 1. give prominent notice (“Notice”) with each copy of the Resulting Program that the Program is used in the Resulting Program and that the Program is the copyright of Narwallets.com; and
 2. subject the Resulting Program and any distribution, publication, copy, modification, merger therewith, combination with another program or derivative works thereof to the same Notice requirement and Non-Commercial Use restriction set forth herein.
 3. Keep intact the developers' fee distribution mechanism directed to the NEAR account `developers.near`
 
“Non-Commercial Use” means each use as described in clauses (1)-(3) below, as reasonably determined by Narwallets.com in its sole discretion: 
 1. personal use for research, personal study, private entertainment, hobby projects or amateur pursuits, in each case without any anticipated commercial application;
 2. use by any charitable organization, educational institution, public research organization, public safety or health organization, environmental protection organization or government institution; or
 3. the number of monthly active users of the Resulting Program across all versions thereof and platforms globally do not exceed 10,000 at any time.
 
You will not use any trade mark, service mark, trade name, logo of Narwallets or any other company or organization in a way that is likely or intended to cause confusion about the owner or authorized user of such marks, names or logos.
 
If you have any questions, comments or interest in pursuing any other use cases, please reach out to us at hello@narwallets.com

For commercial use you can obtain a commercial license from us. The general terms of the commercial license are to ensure you mantain a fair developers' fee mechanism on your commercial use of the software.

'''
'''--- README.md ---
# Diversifying Staking Pool

## Overview
What is Div-Pool and other non-Technical Documentation

[CLICK HERE](https://narwallets.github.io/diversifying-staking-pool/)

## Technical Documentation
[Technical Notes](https://narwallets.github.io/diversifying-staking-pool/technical-notes)

### Repositories 

This is the Smart Contract repository. The Web App UI is at https://github.com/Narwallets/dapp-diversifying-staking-pool.git

### Change Log
#### `0.1.0`

- Initial version based on core-contracts/lockup and core-contracts/staking-pool
- Deposit, withdraw
- Distributed stake/unstake
- NEAR/SKASH liquidity pool, Add/Remove liquidity
- G-SKASH Minting wtih rewards

### TO DO & Help needed

#### Smart Contract  
 - [x] Deposit/withdraw
 - [x] Buy Skash/Stake
 - [x] Sell SKASH/immediate unstake
 - [x] Classic unstake-wait-finish-unstake
 - [x] User trip-meter, measure rewards
 - [x] distribute staking/unstaking
 - [x] retrieve unstaked and ready
 - [x] NEAR/SKASH Liquidity Pool, Add/Remove liquidity
 - [x] clearing mechanism on stake to restore liquidity in the NSLP
 - [ ] act as a NEP-xxx MULTI-FUN-TOK (multi-token contract). Implement for NEAR, SKASH and G-SKASH
 - [ ] Dividends-pool SKASH/G-SKASH
 - [ ] Staking-loans to whitelisted validators
 - [ ] Emergency Staking (from the nslp) to whitelisted validators

#### Test
 - [ ] Unit Tests
 - [x] Simulation tests
 - [ ] Full code coverage

#### Staking pool list
 - [x] List selected staking pools, getting weight, staked & unstaked
 - [x] add a staking pool, set weight

#### Governing
 - [x] Mint and distribute G-SKASH with rewards
 - [ ] Phase II - Governing DAO

#### Infrastructure
- [ ] External chron to call distribute()
- [ ] compute remainig epoch time
- [ ] withelist pools before adding them
- [ ] auto-unstake SKASH in the NSLP (when the clearing mechanism is not enough)

#### Expansions

- [ ] USDN: Create a collateral-based stablecoin similar to Compound's DAI, using NEAR & SKASH as collateral

'''
'''--- build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --all --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/divpool.wasm res/
cp target/wasm32-unknown-unknown/release/staking_pool.wasm res/

'''
'''--- deploy-guildnet.sh ---
set -e
NETWORK=guildnet
OWNER=luciotato.$NETWORK
OPERATOR=$OWNER
MASTER_ACC=pools.$NETWORK
CONTRACT_ACC=diversifying.$MASTER_ACC

divy --cliconf -c $CONTRACT_ACC -acc $OWNER

export NODE_ENV=$NETWORK

#echo "Delete $CONTRACT_ACC? are you sure? Ctrl-C to cancel"
#read input
#near delete $CONTRACT_ACC $MASTER_ACC
#near create-account $CONTRACT_ACC --masterAccount $MASTER_ACC
#divy deploy ./res/diversifying_staking_pool.wasm
#divy new { owner_account_id:$OWNER, treasury_account_id:treasury.$CONTRACT_ACC, operator_account_id:$OPERATOR } --accountId $MASTER_ACC

## redeploy code only
divy deploy ./res/diversifying_staking_pool.wasm  --accountId $MASTER_ACC

'''
'''--- deploy-testnet.sh ---
export NODE_ENV=testnet

#echo "Delete diversifying.pool.testnet? are you sure? Ctrl-C to cancel"
#read input
#near delete diversifying.pool.testnet pool.testnet --accountId pool.testnet
#near create-account diversifying.pool.testnet --masterAccount pool.testnet
#near deploy diversifying.pool.testnet ./res/diversifying_staking_pool.wasm new '{"owner_account_id":"dao.diversifying.pool.testnet", "treasury_account_id":"treasury.diversifying.pool.testnet", "operator_account_id":"lucio.testnet"}' --accountId pool.testnet

## redeploy code only
near deploy diversifying.pool.testnet ./res/diversifying_staking_pool.wasm  --accountId pool.testnet

'''
'''--- divpool/Cargo.toml ---
[package]
edition = "2018"
name = "divpool"
version = "0.1.0"
authors = ["Narwallets.com <hello@narwallets.com>"]

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]

#near-sdk = "2.0.1"
near-sdk = { git = "https://github.com/near/near-sdk-rs.git", tag="2.4.0" }
#near-sdk = { git = "https://github.com/Narwallets/near-sdk-rs.git", tag="2.4.0" }

uint = { version = "0.8.3", default-features = false }

[dev-dependencies]
lazy_static = "1.4.0"
quickcheck = "0.9"
quickcheck_macros = "0.9"
log = "0.4"
env_logger = { version = "0.7.1", default-features = false }
# near-crypto = { git = "https://github.com/nearprotocol/nearcore.git" }
# near-primitives = { git = "https://github.com/nearprotocol/nearcore.git" }

near-sdk-sim = { git = "https://github.com/near/near-sdk-rs.git", tag="2.4.0" }
#near-sdk-sim = { git = "https://github.com/Narwallets/near-sdk-rs.git", tag="2.4.0" }

#[dependencies.near-sdk]
#path="../../near-sdk-rs/near-sdk"

#[dev-dependencies.near-sdk-sim]
#path="../../near-sdk-rs/near-sdk-sim"
'''
'''--- divpool/src/distribute.rs ---
use crate::*;
use near_sdk::{near_bindgen, Promise};

#[near_bindgen]
impl DiversifiedPool {

        //----------------------------------
    // Heartbeat & Talking to the pools
    // ---------------------------------

    //-----------------------------
    // DISTRIBUTE
    //-----------------------------

    /// operator method -------------------------------------------------
    /// distribute_staking(). Do staking in batches of at most 100Kn
    /// returns "true" if the operator needs to call this fn again
    pub fn distribute_staking(&mut self) -> bool {

        //Note: In order to make this contract independent from the operator
        //this fn is open to be called by anyone

        //let epoch_height = env::epoch_height();
        // if self.last_epoch_height == epoch_height {
        //     return false;
        // }
        // self.last_epoch_height = epoch_height;

        env::log("1".as_bytes());
        //----------
        //check if the liquidity pool needs liquidity, and then use this opportunity to liquidate skash in the LP by internal-clearing 
        if self.nslp_try_liquidate_skash_by_clearing(){
            return true; //call again
        }

        env::log("2".as_bytes());
        //do wo need to stake?
        if self.total_for_staking <= self.total_actually_staked {
            //no staking needed
            return false;
        }

        //-------------------------------------
        //compute amount to stake
        //-------------------------------------
        let total_amount_to_stake =  self.total_for_staking - self.total_actually_staked;
        let (sp_inx, mut amount_to_stake) = self.get_staking_pool_requiring_stake(total_amount_to_stake);
        env::log(format!("{} {} {}",total_amount_to_stake,sp_inx, amount_to_stake).as_bytes());
        if amount_to_stake > 0 {
            //most unbalanced pool found & available
            //launch async stake or deposit_and_stake on that pool

            let sp = &mut self.staking_pools[sp_inx];
            sp.busy_lock = true;

            env::log("3".as_bytes());
            //case 1. pool has unstaked amount (we could be at the unstaking delay waiting period)
            if sp.unstaked > 0 {
                //pool has unstaked amount
                if sp.unstaked < amount_to_stake {
                    //re-stake the unstaked
                    amount_to_stake = sp.unstaked;
                }
                //launch async stake to re-stake on the pool
                assert!(self.total_unstaked_and_waiting >= amount_to_stake,"total_unstaked_and_waiting < amount_to_stake");
                self.total_unstaked_and_waiting -= amount_to_stake; //preventively consider the amount removed from total_unstaked_and_waiting (undoes if failed)
                self.total_actually_staked += amount_to_stake; //preventively consider the amount staked (undoes if failed)
                ext_staking_pool::stake(
                    amount_to_stake.into(),
                    &sp.account_id,
                    NO_DEPOSIT,
                    gas::staking_pool::STAKE,
                )
                .then(ext_self_owner::on_staking_pool_stake_maybe_deposit(
                    sp_inx,
                    amount_to_stake,
                    false,
                    &env::current_account_id(),
                    NO_DEPOSIT,
                    gas::owner_callbacks::ON_STAKING_POOL_DEPOSIT_AND_STAKE,
                ));

                return true; //some work scheduled
            }

            //here the sp has no unstaked balance, we must deposit_and_stake on the sp
            //launch async deposit_and_stake on the pool
            assert!(
                env::account_balance() - MIN_BALANCE_FOR_STORAGE >= amount_to_stake,
                "env::account_balance()-MIN_BALANCE_FOR_STORAGE < amount_to_stake"
            );

            self.total_actually_staked += amount_to_stake; //preventively consider the amount staked (undoes if async fails)
            ext_staking_pool::deposit_and_stake(
                &sp.account_id,
                amount_to_stake.into(), //attached amount
                gas::staking_pool::DEPOSIT_AND_STAKE,
            )
            .then(ext_self_owner::on_staking_pool_stake_maybe_deposit(
                sp_inx,
                amount_to_stake,
                true,
                &env::current_account_id(),
                NO_DEPOSIT,
                gas::owner_callbacks::ON_STAKING_POOL_DEPOSIT_AND_STAKE,
            ));

        }

        return true; //more work needed

    }

    //prev fn continues here
    /// Called after amount is staked from the sp's unstaked balance (all into  the staking pool contract).
    /// This method needs to update staking pool status.
    pub fn on_staking_pool_stake_maybe_deposit(
        &mut self,
        sp_inx: usize,
        amount: u128,
        included_deposit: bool,
    ) -> bool {

        assert_callback_calling();

        let sp = &mut self.staking_pools[sp_inx];
        sp.busy_lock = false;

        let stake_succeeded = is_promise_success();

        let result: &str;
        if stake_succeeded {
            //STAKED OK
            result = "succeeded";
            if !included_deposit {
                //not deposited first, so staked funds came from unstaked funds already in the sp
                sp.unstaked -= amount;
            }
            //move into staked
            sp.staked += amount;
        } 
        else {
            //STAKE FAILED
            result = "has failed";
            if !included_deposit { //was staking from "wating for unstake"
                self.total_unstaked_and_waiting += amount; //undo preventive action considering the amount taken from wating for unstake
            }
            self.total_actually_staked -= amount; //undo preventive action considering the amount staked
        }
        env::log(format!("Staking of {} at @{} {}", amount, sp.account_id, result).as_bytes());
        return stake_succeeded;
    }

    // Operator method, but open to anyone
    /// distribute_unstaking(). Do unstaking 
    /// returns "true" if needs to be called again
    pub fn distribute_unstaking(&mut self) -> bool {

        //Note: In order to make this contract independent from the operator
        //this fn is open to be called by anyone

        //let epoch_height = env::epoch_height();
        // if self.last_epoch_height == epoch_height {
        //     return false;
        // }
        // self.last_epoch_height = epoch_height;

        //--------------------------
        //compute amount to unstake
        //--------------------------
        if self.total_actually_staked <= self.total_for_staking {
            //no unstaking needed
            return false;
        }
        let total_to_unstake = self.total_actually_staked - self.total_for_staking;

        let (sp_inx, amount_to_unstake) = self.get_staking_pool_requiring_unstake(total_to_unstake);
        if amount_to_unstake > 0 {
            //most unbalanced pool found & available
            //launch async to unstake

            let sp = &mut self.staking_pools[sp_inx];
            sp.busy_lock = true;

            //preventively consider the amount un-staked (undoes if promise fails)
            self.total_actually_staked -= amount_to_unstake; 
            self.total_unstaked_and_waiting += amount_to_unstake; 
            //launch async to un-stake from the pool
            ext_staking_pool::unstake(
                amount_to_unstake.into(),
                &sp.account_id,
                NO_DEPOSIT,
                gas::staking_pool::UNSTAKE,
            )
            .then(ext_self_owner::on_staking_pool_unstake(
                sp_inx,
                amount_to_unstake,
                &env::current_account_id(),
                NO_DEPOSIT,
                gas::owner_callbacks::ON_STAKING_POOL_UNSTAKE,
            ));

        }

        return true; //needs to be called again
    }

    /// The prev fn continues here
    /// Called after the given amount was unstaked at the staking pool contract.
    /// This method needs to update staking pool status.
    pub fn on_staking_pool_unstake(&mut self, sp_inx: usize, amount: u128) -> bool {

        assert_callback_calling();

        let sp = &mut self.staking_pools[sp_inx];
        sp.busy_lock = false;

        let unstake_succeeded = is_promise_success();

        let result: &str;
        if unstake_succeeded {
            result = "succeeded";
            sp.staked -= amount;
            sp.unstaked += amount;
            sp.unstk_req_epoch_height = env::epoch_height();
        } else {
            result = "has failed";
            self.total_actually_staked += amount; //undo preventive action considering the amount unstaked
            self.total_unstaked_and_waiting -= amount; //undo preventive action considering the amount unstaked
        }

        env::log(format!("Unstaking of {} at @{} {}", amount, sp.account_id, result).as_bytes());
        return unstake_succeeded;
    }

    //-----------------------------------------------------------------------
    //-- COMPUTE AND DISTRIBUTE STAKING REWARDS for a specifi staking-pool --
    //-----------------------------------------------------------------------
    // Operator method, but open to anyone. Should be called once per epoch per sp, after sp rewards distribution (ping)
    /// Retrieves total balance from the staking pool and remembers it internally.
    /// Also computes and distributes rewards operator and delegators
    /// this fn queries the staking pool (makes a cross-contract call)
    pub fn distribute_rewards(&mut self, sp_inx_i32: i32) {
        assert!(sp_inx_i32 > 0);

        //Note: In order to make this contract independent from the operator
        //this fn is open to be called by anyone
        //self.assert_owner_calling();

        let sp_inx = sp_inx_i32 as usize;
        assert!(sp_inx < self.staking_pools.len());

        let sp = &mut self.staking_pools[sp_inx];
        assert!(!sp.busy_lock, "sp is busy");

        if sp.staked == 0 {
            return;
        }

        let epoch_height = env::epoch_height();
        if sp.last_asked_rewards_epoch_height == epoch_height {
            return;
        }

        env::log(
            format!(
                "Fetching total balance from the staking pool @{}",
                sp.account_id
            )
            .as_bytes(),
        );

        sp.busy_lock = true;

        //query our current balance (includes staking rewards)
        ext_staking_pool::get_account_total_balance(
            env::current_account_id(),
            //promise params
            &sp.account_id,
            NO_DEPOSIT,
            gas::staking_pool::GET_ACCOUNT_TOTAL_BALANCE,
        )
        .then(ext_self_owner::on_get_sp_total_balance(
            sp_inx,
            //promise params
            &env::current_account_id(),
            NO_DEPOSIT,
            gas::owner_callbacks::ON_GET_SP_TOTAL_BALANCE,
        ));
    }

    /// prev fn continues here
    /*
    Note: what does the tag #[callback] applied to a fn in paramter do?
    #[callback] parses the previous promise's result into the param
        Check out https://nomicon.io/RuntimeSpec/Components/BindingsSpec/PromisesAPI.html
        1. check promise_results_count() == 1
        2  check the execution status of the first promise and write the result into the register using promise_result(0, register_id) == 1
            Let's say that you used register_id == 0
        3. read register using register_len and read_register into Wasm memory
        4. parse the data using: let total_balance: WrappedBalance = serde_json::from_slice(&buf).unwrap();

    it has be last argument? can you add another argument for the on_xxx callback ?
    before that
    for example:
        /// Called after the request to get the current total balance from the staking pool.
        pub fn on_get_account_total_balance(&mut self, staking_pool_account: AccountId, #[callback] total_balance: WrappedBalance) {
            assert_self();
            self.set_staking_pool_status(TransactionStatus::Idle);
            ...
        and in the call
            ext_staking_pool::get_account_total_balance(
                env::current_account_id(),
                staking_pool_account_id,
                NO_DEPOSIT,
                gas::staking_pool::GET_ACCOUNT_TOTAL_BALANCE,
            )
            .then(ext_self_owner::on_get_account_total_balance(
                staking_pool_account_id,
                &env::current_account_id(),
                NO_DEPOSIT,
                gas::owner_callbacks::ON_GET_ACCOUNT_TOTAL_BALANCE,
            ))

    #[callback] marked-arguments are parsed in order. The position within arguments are not important, but the order is.
    If you have 2 arguments marked as #[callback] then you need to expect 2 promise results joined with promise_and
    */

    //------------------------------
    pub fn on_get_sp_total_balance(
        &mut self,
        sp_inx: usize,
        #[callback] total_balance: U128String,
    ) {
        //we enter here after asking the staking-pool how much do we have staked (plus rewards)
        //total_balance: U128String contains the answer from the staking-pool

        assert_callback_calling();

        let rewards: u128;

        //store the new staked amount for this pool
        let new_staked_amount: u128;
        let sp = &mut self.staking_pools[sp_inx];

        sp.busy_lock = false;

        sp.last_asked_rewards_epoch_height = env::epoch_height();

        new_staked_amount = total_balance.0;

        if new_staked_amount < sp.staked {
            env::log(
                format!(
                    "INCONSISTENCY @{} says total_balance < sp.staked",
                    sp.account_id
                )
                .as_bytes(),
            );
            rewards = 0;
        } else {
            //compute rewards, as new balance minus old balance
            rewards = new_staked_amount - sp.staked;
        }

        env::log(
            format!(
                "sp:{} old_balance:{} new_balance:{} rewards:{}",
                sp.account_id, sp.staked, new_staked_amount, rewards
            )
            .as_bytes(),
        );

        //updated accumulated_staked_rewards value for the contract
        self.accumulated_staked_rewards+=rewards;
        //updated new "staked" value for this pool
        sp.staked = new_staked_amount;
    
        if rewards > 0 {
            //add to actually staked
            self.total_actually_staked += rewards;

            // The fee that the contract owner (operator) takes.
            let owner_fee = apply_pct(self.operator_rewards_fee_basis_points, rewards);
            // The fee that the contract authors take.
            let developers_fee = apply_pct(DEVELOPERS_REWARDS_FEE_BASIS_POINTS, rewards);
            // Now add fees & shares to the pool preserving current share value
            // adds to self.total_actually_staked, self.total_for_staking & self.total_stake_shares;
            &self.add_amount_and_shares_preserve_share_price(self.operator_account_id.clone(),owner_fee);
            &self.add_amount_and_shares_preserve_share_price(DEVELOPERS_ACCOUNT_ID.into(), developers_fee);

            // rest of rewards go into total_actually_staked increasing share value
            assert!(rewards > developers_fee + owner_fee);
            //add rest of rewards increasing share value for all stakers
            self.total_for_staking += rewards - developers_fee - owner_fee; //increase share price for everybody

        }
    }

    //----------------------------------------------------------------------
    /// finds a pool with the unstake delay completed
    /// withdraws. Returns pol index or:
    /// -1 if there are funds ready to retrieve but the pool is busy
    /// -2 if there funds unstaked, but not ready in this epoch
    /// -3 if there are no unstaked funds
    pub fn get_staking_pool_requiring_retrieve(&self) -> i32 {
        
        let mut result:i32 = -3;

        for (sp_inx, sp) in self.staking_pools.iter().enumerate() {
            // if the pool is not busy, has stake, and has not unstaked blanace waiting for withdrawal
            if sp.unstaked > 0  {
                if result == -3 { result = -2};
                if sp.unstk_req_epoch_height + NUM_EPOCHS_TO_UNLOCK <= env::epoch_height() {
                    if result == -2 { result = -1};
                    if !sp.busy_lock {
                        // if this pool has unstaked and the waiting period has ended
                        return sp_inx as i32;
                    }
                }
            }
        }
        return result;

    }

    // Operator method, but open to anyone
    //----------------------------------------------------------------------
    //  WITHDRAW FROM ONE OF THE POOLS ONCE THE WAITING PERIOD HAS ELAPSED
    //----------------------------------------------------------------------
    /// launchs a withdrawal call
    /// returns the amount withdrew
    pub fn retrieve_funds_from_a_pool(&mut self, inx:u16) -> Promise {

        //Note: In order to make fund-recovering independent from the operator
        //this fn is open to be called by anyone

        assert!(inx < self.staking_pools.len() as u16,"invalid index");

        let sp = &mut self.staking_pools[inx as usize];
        assert!(!sp.busy_lock,"sp is busy");
        assert!(sp.unstaked > 0,"sp unstaked == 0");
        assert!(env::epoch_height() >= sp.unstk_req_epoch_height + NUM_EPOCHS_TO_UNLOCK,
            "unstaking-delay ends at {}, now is {}",sp.unstk_req_epoch_height + NUM_EPOCHS_TO_UNLOCK,env::epoch_height());

        // if the pool is not busy, and we unstaked and the waiting period has elapsed
        sp.busy_lock = true;

        //return promise
        return ext_staking_pool::withdraw(
            sp.unstaked.into(),
            //promise params:
            &sp.account_id,
            NO_DEPOSIT,
            gas::staking_pool::WITHDRAW,
        )
        .then(ext_self_owner::on_staking_pool_withdraw(
            inx,
            //promise params:
            &env::current_account_id(),
            NO_DEPOSIT,
            gas::owner_callbacks::ON_STAKING_POOL_WITHDRAW,
        ));
        
    }

    //prev fn continues here
    /// This method needs to update staking pool busyLock
    pub fn on_staking_pool_withdraw(&mut self, inx: u16) -> u128 {

        assert_callback_calling();

        let sp = &mut self.staking_pools[inx as usize];
        sp.busy_lock = false;
        
        let amount = sp.unstaked; //we retrieved all

        let withdraw_succeeded = is_promise_success();
        let mut withdrew_amount:u128=0;

        let result: &str;
        if withdraw_succeeded {
            result = "succeeded";
            sp.unstaked = sp.unstaked.saturating_sub(amount); //no more unstaked in the pool
            //move from total_unstaked_and_waiting to total_actually_unstaked_and_retrieved
            self.total_unstaked_and_waiting = self.total_unstaked_and_waiting.saturating_sub(amount);
            self.total_actually_unstaked_and_retrieved += amount; //the amount stays in "total_actually_unstaked_and_retrieved" until the user calls finish_unstaking
            withdrew_amount = amount;
        } 
        else {
            result = "has failed";
        }
        env::log(
            format!(
                "The withdrawal of {} from @{} {}",
                amount, &sp.account_id, result
            )
            .as_bytes(),
        );
        return withdrew_amount;
    }

}
'''
'''--- divpool/src/gas.rs ---
pub const TGAS: u64 = 1_000_000_000_000;
pub const BASE_GAS: u64 = 25*TGAS;

pub mod whitelist {
    /// Gas attached to the promise to check whether the given staking pool Account ID is
    /// whitelisted.
    /// Requires BASE (no external calls).
    pub const IS_WHITELISTED: u64 = super::BASE_GAS;
}

pub mod staking_pool {
    /// Gas attached to deposit call on the staking pool contract.
    /// Requires BASE for local updates + BASE potentially restake.
    pub const DEPOSIT: u64 = super::BASE_GAS * 2;

    /// Gas attached to deposit call on the staking pool contract.
    /// Requires BASE for local updates + 2 * BASE for staking call.
    pub const DEPOSIT_AND_STAKE: u64 = super::BASE_GAS * 3;

    /// Gas attached to withdraw call on the staking pool contract.
    /// Requires BASE for execution + 2 * BASE for transferring amount to us and potentially restake.
    pub const WITHDRAW: u64 = super::BASE_GAS * 3;

    /// Gas attached to stake call on the staking pool contract.
    /// Requires BASE for execution + 2 * BASE for staking call.
    pub const STAKE: u64 = super::BASE_GAS * 3;

    /// Gas attached to unstake call on the staking pool contract.
    /// Requires BASE for execution + 2 * BASE for staking call.
    pub const UNSTAKE: u64 = super::BASE_GAS * 3;

    /// Gas attached to unstake all call on the staking pool contract.
    /// Requires BASE for execution + 2 * BASE for staking call.
    pub const UNSTAKE_ALL: u64 = super::BASE_GAS * 3;

    /// The amount of gas required to get the current staked balance of this account from the
    /// staking pool.
    /// Requires BASE for local processing.
    pub const GET_ACCOUNT_STAKED_BALANCE: u64 = super::BASE_GAS;

    /// The amount of gas required to get current unstaked balance of this account from the
    /// staking pool.
    /// Requires BASE for local processing.
    pub const GET_ACCOUNT_UNSTAKED_BALANCE: u64 = super::BASE_GAS;

    /// The amount of gas required to get the current total balance of this account from the
    /// staking pool.
    /// Requires BASE for local processing.
    pub const GET_ACCOUNT_TOTAL_BALANCE: u64 = super::BASE_GAS;
}

pub mod transfer_poll {
    /// Gas attached to the promise to check whether transfers were enabled on the transfer poll
    /// contract.
    /// Requires BASE (no external calls).
    pub const GET_RESULT: u64 = super::BASE_GAS;
}

pub mod owner_callbacks {
    /// Gas attached to the inner callback for processing whitelist check results.
    /// Requires BASE for local execution.
    pub const ON_WHITELIST_IS_WHITELISTED: u64 = super::BASE_GAS;

    /// Gas attached to the inner callback for processing result of the deposit call to the
    /// staking pool.
    /// Requires BASE for local updates.
    pub const ON_STAKING_POOL_DEPOSIT: u64 = super::BASE_GAS;

    /// Gas attached to the inner callback for processing result of the deposit and stake call to
    /// the staking pool.
    /// Requires BASE for local updates.
    pub const ON_STAKING_POOL_DEPOSIT_AND_STAKE: u64 = super::BASE_GAS;

    /// Gas attached to the inner callback for processing result of the withdraw call to the
    /// staking pool.
    /// Requires BASE for local updates.
    pub const ON_STAKING_POOL_WITHDRAW: u64 = super::BASE_GAS;

    /// Gas attached to the inner callback for processing result of the stake call to the
    /// staking pool.
    pub const ON_STAKING_POOL_STAKE: u64 = super::BASE_GAS;

    /// Gas attached to the inner callback for processing result of the unstake call to the
    /// staking pool.
    /// Requires BASE for local updates.
    pub const ON_STAKING_POOL_UNSTAKE: u64 = super::BASE_GAS;

    /// Gas attached to the inner callback for processing result of the unstake all call to the
    /// staking pool.
    /// Requires BASE for local updates.
    //pub const ON_STAKING_POOL_UNSTAKE_ALL: u64 = super::BASE_GAS;

    /// Gas attached to the inner callback for processing result of the checking result for
    /// transfer voting call to the voting contract.
    /// Requires BASE for local updates.
    pub const ON_VOTING_GET_RESULT: u64 = super::BASE_GAS;

    /// Gas attached to the inner callback for processing result of the call to get the current total balance from the staking pool.
    pub const ON_GET_SP_TOTAL_BALANCE: u64 = super::BASE_GAS * 5; //because distributes realized rewards to author and owner

    /// Gas attached to the inner callback for processing result of the call to get the current
    /// unstaked balance from the staking pool.
    /// The callback might proceed with withdrawing this amount.
    /// Requires BASE for local updates + gas for withdraw + gas for another callback.
    pub const ON_GET_ACCOUNT_UNSTAKED_BALANCE_TO_WITHDRAW_BY_OWNER: u64 =
        super::BASE_GAS + super::staking_pool::WITHDRAW + ON_STAKING_POOL_WITHDRAW;
}

'''
'''--- divpool/src/getters.rs ---
use crate::*;
use near_sdk::{near_bindgen};

#[near_bindgen]
impl DiversifiedPool {
    //------------------------------------------
    // GETTERS 
    //------------------------------------------
    /// Returns the account ID of the owner.
    
    pub fn get_operator_account_id(&self) -> AccountId {
        return self.operator_account_id.clone();
    }

    /// The amount of tokens that were deposited to the staking pool.
    /// NOTE: The actual balance can be larger than this known deposit balance due to staking
    /// rewards acquired on the staking pool.
    /// To refresh the amount the owner can call `refresh_staking_pool_balance`.
    pub fn get_known_deposited_balance(&self) -> U128String {
        return self.total_actually_staked.into();
    }

    /// full account info
    /// Returns JSON representation of the account for the given account ID.
    pub fn get_account_info(&self, account_id: AccountId) -> GetAccountInfoResult {
        let acc = self.internal_get_account(&account_id);
        let skash = self.amount_from_stake_shares(acc.stake_shares);
        // trip_rewards = current_skash + trip_accum_unstakes - trip_accum_stakes - trip_start_skash;
        let trip_rewards = (skash + acc.trip_accum_unstakes).saturating_sub(acc.trip_accum_stakes + acc.trip_start_skash);
        //NLSP share value
        let mut nslp_share_value: u128 = 0;
        if acc.nslp_shares != 0 {
            let nslp_account = self.internal_get_nslp_account();
            nslp_share_value = acc.valued_nslp_shares(self, &nslp_account);
        }
        return GetAccountInfoResult {
            account_id,
            available: acc.available.into(),
            skash: skash.into(),
            unstaked: acc.unstaked.into(),
            unstaked_requested_unlock_epoch: acc.unstaked_requested_unlock_epoch.into(),
            can_withdraw: (env::epoch_height() >= acc.unstaked_requested_unlock_epoch),
            total: (acc.available + skash + acc.unstaked).into(),
            //trip-meter
            trip_start: acc.trip_start.into(),
            trip_start_skash: acc.trip_start_skash.into(),
            trip_accum_stakes: acc.trip_accum_stakes.into(),
            trip_accum_unstakes: acc.trip_accum_unstakes.into(),
            trip_rewards: trip_rewards.into(),

            nslp_shares: acc.nslp_shares.into(),
            nslp_share_value: nslp_share_value.into(),

            g_skash: acc.total_g_skash(self).into(),
        };
    }

    /// NEP-129 get information about this contract
    /// returns JSON string according to [NEP-129](https://github.com/nearprotocol/NEPs/pull/129)
    pub fn get_contract_info(&self) -> NEP129Response {
        return NEP129Response {
            dataVersion:1,
            name: CONTRACT_NAME.into(),
            version:CONTRACT_VERSION.into(),
            source:"https://github.com/Narwallets/diversifying-staking-pool".into(), 
            standards:vec!("NEP-129".into(),"NEP-138".into()),  
            webAppUrl:self.web_app_url.clone(),
            developersAccountId:DEVELOPERS_ACCOUNT_ID.into(),
            auditorAccountId: self.auditor_account_id.clone()
        }
    }

    /// sets confirgurable contract info [NEP-129](https://github.com/nearprotocol/NEPs/pull/129)
    // Note: params are not Option<String> so the user can not inadvertely set null to data by not including the argument
    pub fn set_contract_info(&mut self, web_app_url:String, auditor_account_id:String) {
        self.assert_owner_calling();
        self.web_app_url = if web_app_url.len()>0 { Some(web_app_url) } else { None };
        self.auditor_account_id = if auditor_account_id.len()>0 { Some(auditor_account_id) } else { None };
    }

    /// get contract totals 
    /// Returns JSON representation of the contract state
    pub fn get_contract_state(&self) -> GetContractStateResult {

        let lp_account = self.internal_get_nslp_account();

        return GetContractStateResult {
            total_available: self.total_available.into(),
            total_for_staking: self.total_for_staking.into(),
            total_actually_staked: self.total_actually_staked.into(),
            accumulated_staked_rewards: self.accumulated_staked_rewards.into(),
            total_unstaked_and_waiting: self.total_unstaked_and_waiting.into(),
            total_actually_unstaked_and_retrieved: self.total_actually_unstaked_and_retrieved.into(),
            total_stake_shares: self.total_stake_shares.into(),
            total_g_skash: self.total_g_skash.into(),
            accounts_count: self.accounts.len().into(),
            staking_pools_count: self.staking_pools.len() as u16,
            nslp_liquidity: lp_account.available.into(),
            nslp_current_discount_basis_points: self.internal_get_discount_basis_points(lp_account.available, TEN_NEAR)
        };
    }

    /// Returns JSON representation of contract parameters
    pub fn get_contract_params(&self) -> ContractParamsJSON {
        return ContractParamsJSON {
            staking_paused: self.staking_paused,
            min_account_balance: self.min_account_balance.into(),

            nslp_near_target: self.nslp_near_target.into(),
            nslp_max_discount_basis_points: self.nslp_max_discount_basis_points,
            nslp_min_discount_basis_points: self.nslp_min_discount_basis_points,

            staker_g_skash_mult_pct: self.staker_g_skash_mult_pct,
            skash_sell_g_skash_mult_pct: self.skash_sell_g_skash_mult_pct,
            lp_provider_g_skash_mult_pct: self.lp_provider_g_skash_mult_pct,
                    
            operator_rewards_fee_basis_points: self.operator_rewards_fee_basis_points,
            operator_swap_cut_basis_points: self.operator_swap_cut_basis_points,
            treasury_swap_cut_basis_points: self.treasury_swap_cut_basis_points,
            };
    }

    /// Sets contract parameters 
    pub fn set_contract_params(&mut self, params:ContractParamsJSON) {

        self.assert_owner_calling();

        self.min_account_balance = params.min_account_balance.0;

        self.nslp_near_target = params.nslp_near_target.0;
        self.nslp_max_discount_basis_points = params.nslp_max_discount_basis_points;
        self.nslp_min_discount_basis_points = params.nslp_min_discount_basis_points;

        self.staker_g_skash_mult_pct = params.staker_g_skash_mult_pct;
        self.skash_sell_g_skash_mult_pct = params.skash_sell_g_skash_mult_pct;
        self.lp_provider_g_skash_mult_pct = params.lp_provider_g_skash_mult_pct;
                    
        self.operator_rewards_fee_basis_points = params.operator_rewards_fee_basis_points;
        self.operator_swap_cut_basis_points = params.operator_swap_cut_basis_points;
        self.treasury_swap_cut_basis_points = params.treasury_swap_cut_basis_points;

    }
    
    /// get sp (staking-pool) info
    /// Returns JSON representation of sp recorded state
    pub fn get_sp_info(&self, sp_inx_i32: i32) -> StakingPoolJSONInfo {

        assert!(sp_inx_i32 > 0);

        let sp_inx = sp_inx_i32 as usize;
        assert!(sp_inx < self.staking_pools.len());

        let sp = &self.staking_pools[sp_inx];

        return StakingPoolJSONInfo {
            account_id: sp.account_id.clone(),
            weight_basis_points: sp.weight_basis_points,
            staked: sp.staked.into(),
            unstaked: sp.unstaked.into(),
            unstaked_requested_epoch_height: sp.unstk_req_epoch_height.into(),
            last_asked_rewards_epoch_height: sp.last_asked_rewards_epoch_height.into(),
        };
    }
}

'''
'''--- divpool/src/internal.rs ---
use crate::*;
use near_sdk::{near_bindgen, Balance, Promise};

pub use crate::types::*;
pub use crate::utils::*;

/****************************/
/* general Internal methods */
/****************************/
impl DiversifiedPool {
    /// Asserts that the method was called by the owner.
    pub fn assert_owner_calling(&self) {
        assert_eq!(
            &env::predecessor_account_id(),
            &self.owner_account_id,
            "Can only be called by the owner"
        )
    }
}

pub fn assert_min_amount(amount: u128) {
    assert!(amount >= FIVE_NEAR, "minimun amount is 5N");
}

/***************************************/
/* Internal methods staking-pool trait */
/***************************************/
#[near_bindgen]
impl DiversifiedPool {

    pub(crate) fn internal_deposit(&mut self) {

        let amount = env::attached_deposit();
        assert_min_amount(amount);

        let account_id = env::predecessor_account_id();
        let mut account = self.internal_get_account(&account_id);

        account.available += amount;
        self.total_available += amount;

        self.internal_update_account(&account_id, &account);

        env::log(
            format!(
                "@{} deposited {}. New available balance is {}",
                account_id, amount, account.available
            )
            .as_bytes(),
        );
    }

    //------------------------------
    pub(crate) fn internal_withdraw(&mut self, amount_requested: u128) {
        
        let account_id = env::predecessor_account_id();
        let mut acc = self.internal_get_account(&account_id);

        if acc.available <  amount_requested && acc.unstaked > 0 { //not enough available, but there's some unstaked
            let epoch = env::epoch_height();
            if epoch >= acc.unstaked_requested_unlock_epoch {
                //bring from unstaked to available
                acc.try_finish_unstaking(self);
            }
        }

        assert!(
            acc.available >= amount_requested,
            "Not enough available balance to withdraw the requested amount"
        );

        let to_withdraw = 
            if acc.available - amount_requested < ONE_NEAR_CENT/2  //small yotctos remain, withdraw all
                { acc.available } 
                else  { amount_requested };

        acc.available -= to_withdraw;
        assert!( !acc.is_empty() || acc.available >= self.min_account_balance,
            "The min balance for an open account is {} NEAR. You can remove all funds and close the account",
            self.min_account_balance/ONE_NEAR);

        self.internal_update_account(&account_id, &acc);

        self.total_available -= to_withdraw;
        Promise::new(account_id).transfer(to_withdraw);
    }

    //------------------------------
    pub(crate) fn internal_stake(&mut self, amount: Balance) {

        assert_min_amount(amount);

        let account_id = env::predecessor_account_id();
        let mut acc = self.internal_get_account(&account_id);

        assert!(
            acc.available >= amount,
            "Not enough available balance to stake the requested amount"
        );

        //use this operation to realize g-skash pending rewards
        acc.stake_realize_g_skash(self);
    
        // Calculate the number of "stake" shares that the account will receive for staking the given amount.
        let num_shares = self.stake_shares_from_amount(amount);
        assert!(num_shares > 0);

        //update user account
        acc.add_stake_shares(num_shares, amount);
        acc.available -= amount;
        //contract totals
        self.total_stake_shares += num_shares;
        self.total_for_staking += amount;
        assert!(self.total_available >= amount,"i_s_Inconsistency");
        self.total_available -= amount;

        //--SAVE ACCOUNT--
        self.internal_update_account(&account_id, &acc);

        //----------
        //check if the liquidity pool needs liquidity, and then use this opportunity to liquidate skash in the LP by internal-clearing 
        self.nslp_try_liquidate_skash_by_clearing();

    }

    //------------------------------
    pub(crate) fn internal_unstake(&mut self, amount_requested: u128) {

        let account_id = env::predecessor_account_id();
        let mut acc = self.internal_get_account(&account_id);

        let valued_shares = self.amount_from_stake_shares(acc.stake_shares);
        assert!(valued_shares >= amount_requested, "Not enough skash");

        //use this operation to realize g-skash pending rewards
        acc.stake_realize_g_skash(self);

        let remains_staked = valued_shares - amount_requested;
        //if less than one near would remain, unstake all
        let amount_to_unstake = if remains_staked > ONE_NEAR {
            amount_requested
        }
        else {
            valued_shares //unstake all
        };

        let num_shares: u128;
        //if unstake all staked near, we use all shares, so we include rewards in the unstaking...
        //when "unstaking_all" the amount unstaked is the requested amount PLUS ALL ACCUMULATED REWARDS
        if amount_to_unstake == valued_shares {
            num_shares = acc.stake_shares;
        } else {
            // Calculate the number of shares required to unstake the given amount.
            num_shares = self.stake_shares_from_amount(amount_to_unstake);
            assert!(num_shares > 0);
            assert!(
                acc.stake_shares >= num_shares,
                "Inconsistency. Not enough shares to unstake"
            );
        }

        //burn stake shares
        acc.sub_stake_shares(num_shares, amount_to_unstake);
        //the amount is now "unstaked"
        acc.unstaked += amount_to_unstake;
        acc.unstaked_requested_unlock_epoch = env::epoch_height() + self.internal_compute_current_unstaking_delay(amount_to_unstake); //when the unstake will be available
        //--contract totals
        self.total_stake_shares -= num_shares;
        self.total_for_staking -= amount_to_unstake;

        //--SAVE ACCOUNT--
        self.internal_update_account(&account_id, &acc);

        env::log(
            format!(
                "@{} unstaked {}. Has now {} unstaked and {} skash. Epoch:{}",
                account_id, amount_to_unstake, acc.unstaked, self.amount_from_stake_shares(acc.stake_shares), env::epoch_height()
            )
            .as_bytes(),
        );
        // env::log(
        //     format!(
        //         "Contract total staked balance is {}. Total number of shares {}",
        //         self.total_staked_balance, self.total_stake_shares
        //     )
        //     .as_bytes(),
        // );
    }

    //--------------------------------------------------
    /// computes unstaking delay on current situation
    pub fn internal_compute_current_unstaking_delay(&self, amount:u128) -> u64 {
        let mut normal_wait_staked_available:u128 =0;
        for (_,sp) in self.staking_pools.iter().enumerate() {
            //if the pool has no unstaking in process
            if !sp.busy_lock && sp.staked>0 && sp.unstaked==0 { 
                normal_wait_staked_available += sp.staked;
                if normal_wait_staked_available > amount {
                    return NUM_EPOCHS_TO_UNLOCK 
                }
            }
        }
        //all pools are in unstaking-delay, it will take double the time
        return 2 * NUM_EPOCHS_TO_UNLOCK; 
    }

    //--------------------------------
    pub(crate) fn add_amount_and_shares_preserve_share_price(
        &mut self,
        account_id: AccountId,
        amount: u128,
    ) {
        if amount > 0 {
            let num_shares = self.stake_shares_from_amount(amount);
            if num_shares > 0 {
                let account = &mut self.internal_get_account(&account_id);
                account.stake_shares += num_shares;
                &self.internal_update_account(&account_id, &account);
                // Increasing the total amount of "stake" shares.
                self.total_stake_shares += num_shares;
                self.total_for_staking += amount;
            }
        }
    }

    /// Returns the number of "stake" shares corresponding to the given near amount at current share_price
    /// if the amount & the shares are incorporated, price remains the same
    pub(crate) fn stake_shares_from_amount(&self, amount: Balance) -> u128 {
        return shares_from_amount(amount, self.total_for_staking, self.total_stake_shares);
    }

    /// Returns the amount corresponding to the given number of "stake" shares.
    pub(crate) fn amount_from_stake_shares(&self, num_shares: u128) -> u128 {
        return amount_from_shares(num_shares, self.total_for_staking, self.total_stake_shares);
    }

    //-----------------------------
    // NSLP: NEAR/SKASH Liquidity Pool
    //-----------------------------

    // NSLP shares are trickier to compute since the NSLP itself can have SKASH
    pub(crate) fn nslp_shares_from_amount(&self, amount: u128, nslp_account: &Account) -> u128 {
        let total_pool_value: u128 = nslp_account.available
            + self.amount_from_stake_shares(nslp_account.stake_shares)
            + nslp_account.unstaked;
        return shares_from_amount(amount, total_pool_value, nslp_account.nslp_shares);
    }

    // NSLP shares are trickier to compute since the NSLP itself can have SKASH
    pub(crate) fn amount_from_nslp_shares(&self, num_shares: u128, nslp_account: &Account) -> u128 {
        let total_pool_value: u128 = nslp_account.available
            + self.amount_from_stake_shares(nslp_account.stake_shares)
            + nslp_account.unstaked;
        return amount_from_shares(num_shares, total_pool_value, nslp_account.nslp_shares);
    }

    //----------------------------------
    // The LP acquires skash providing the sell-skash service
    // The LP needs to unstake the skash ASAP, to recover liquidity and to keep the fee low.
    // The LP can use staking orders to fast-liquidate its skash by clearing.
    // returns true if it uses the clearing to liquidate
    // ---------------------------------
    pub(crate) fn nslp_try_liquidate_skash_by_clearing(&mut self) -> bool {
        if self.total_for_staking <= self.total_actually_staked {
            //nothing ordered to be actually staked
            return false;
        }
        let amount_to_stake:u128 =  self.total_for_staking - self.total_actually_staked;
        let mut nslp_account = self.internal_get_nslp_account();
        if nslp_account.stake_shares > 0 {
            //how much skash does the nslp have?
            let valued_stake_shares = self.amount_from_stake_shares(nslp_account.stake_shares);
            //how much can we liquidate?
            let (shares_to_liquidate, amount_to_liquidate) =
                if amount_to_stake >= valued_stake_shares  { 
                    ( nslp_account.stake_shares, valued_stake_shares )
                } 
                else { 
                    ( self.stake_shares_from_amount(amount_to_stake), amount_to_stake )
                };
            //nslp sells-skash directly, contract now needs to stake less
            nslp_account.sub_stake_shares(shares_to_liquidate, amount_to_liquidate);
            self.total_stake_shares -= shares_to_liquidate;
            self.total_for_staking -= amount_to_liquidate; //nslp has burned shares, total_for_staking is less now
            self.total_available += amount_to_liquidate; // amount returns to total_available (since it was never staked to begin with)
            nslp_account.available += amount_to_liquidate; //nslp has more available now
            //save account
            self.internal_save_nslp_account(&nslp_account);
            return true;
        }        
        return false;
    }

    /// computes the disocunt_basis_points for NEAR/SKASH Swap based on NSLP Balance
    pub(crate) fn internal_get_discount_basis_points(
        &self,
        available_near: u128,
        max_nears_to_pay: u128,
    ) -> u16 {
        env::log(
            format!(
                "get_discount_basis_points available_near={}  max_nears_to_pay={}",
                available_near, max_nears_to_pay
            )
            .as_bytes(),
        );

        if available_near <= max_nears_to_pay {
            return self.nslp_max_discount_basis_points;
        }

        let near_after = available_near - max_nears_to_pay;

        if near_after < self.nslp_near_target / 20 {
            return self.nslp_max_discount_basis_points; // 1/20 (5%) target, discount capped at max%
        } 

        let discount_basis_plus_100 = self.nslp_near_target * 100 / near_after;
        if discount_basis_plus_100 <= 100 + u128::from(self.nslp_min_discount_basis_points) {
            return self.nslp_min_discount_basis_points; // target reached or surpassed
        } 

        let discount_basis_points = discount_basis_plus_100 - 100;
        if discount_basis_points > u128::from(self.nslp_max_discount_basis_points) {
            return self.nslp_max_discount_basis_points; //capped at max%
        } 

        return discount_basis_points as u16;
    }

    /// user method - NEAR/SKASH SWAP functions
    /// return how much NEAR you can get by selling x SKASH
    pub(crate) fn internal_get_near_amount_sell_skash(
        &self,
        available_near: u128,
        skash_to_sell: u128,
    ) -> u128 {
        let discount_basis_points =
            self.internal_get_discount_basis_points(available_near, skash_to_sell);
        assert!(discount_basis_points < 10000, "inconsistence d>1");
        let discount = apply_pct(discount_basis_points, skash_to_sell);
        return (skash_to_sell - discount).into(); //when SKASH is sold user gets a discounted value because the user skips the waiting period

        // env::log(
        //     format!(
        //         "@{} withdrawing {}. New unstaked balance is {}",
        //         account_id, amount, account.unstaked
        //     )
        //     .as_bytes(),
        // );
    }

    /// Inner method to get the given account or a new default value account.
    pub(crate) fn internal_get_account(&self, account_id: &String) -> Account {
        self.accounts.get(account_id).unwrap_or_default()
    }

    /// Inner method to save the given account for a given account ID.
    /// If the account balances are 0, the account is deleted instead to release storage.
    pub(crate) fn internal_update_account(&mut self, account_id: &String, account: &Account) {
        if account.is_empty() {
            self.accounts.remove(account_id);
        } else {
            self.accounts.insert(account_id, &account); //insert_or_update
        }
    }

    /// Inner method to get the given account or a new default value account.
    pub(crate) fn internal_get_nslp_account(&self) -> Account {
        self.accounts
            .get(&NSLP_INTERNAL_ACCOUNT.into())
            .unwrap_or_default()
    }
    pub(crate) fn internal_save_nslp_account(&mut self, nslp_account: &Account) {
        self.internal_update_account(&NSLP_INTERNAL_ACCOUNT.into(), &nslp_account);
    }

    /// finds a staking pool requiring some stake to get balanced
    /// WARN: (returns 0,0) if no pool requires staking/all are busy
    pub(crate) fn get_staking_pool_requiring_stake(&self, total_to_stake:u128) -> (usize,u128) {
        let mut selected_to_stake_amount: u128 = 0;
        let mut selected_sp_inx:usize=0;

        for (sp_inx, sp) in self.staking_pools.iter().enumerate() {
            // if the pool is not busy, and this pool can stake
            if !sp.busy_lock && sp.weight_basis_points > 0 {
                // if this pool has an unbalance requiring staking
                let should_have = apply_pct(sp.weight_basis_points, self.total_for_staking);
                // this pool requires staking?
                if should_have > sp.staked {
                    // how much?
                    let require_amount = should_have - sp.staked;
                    // is this the most unbalanced pool so far?
                    if require_amount > selected_to_stake_amount {
                        selected_to_stake_amount = require_amount;
                        selected_sp_inx = sp_inx;
                    }
                }
            }
        }

        if selected_to_stake_amount>0 {
            //to avoid moving small amounts, if the remainder is less than 1K increase amount to include all in this movement
            if selected_to_stake_amount > total_to_stake { selected_to_stake_amount = total_to_stake };
            let remainder = total_to_stake - selected_to_stake_amount;
            if remainder <= MIN_STAKE_UNSTAKE_AMOUNT_MOVEMENT { 
                selected_to_stake_amount += remainder 
            };
        }

        return (selected_sp_inx, selected_to_stake_amount);
    }

    /// finds a staking pool requireing some stake to get balanced
    /// WARN: returns (0,0) if no pool requires staking/all are busy
    pub(crate) fn get_staking_pool_requiring_unstake(&self, total_to_unstake:u128) -> (usize,u128) {
        let mut selected_to_unstake_amount: u128 = 0;
        let mut selected_stake: u128 = 0;
        let mut selected_sp_inx: usize = 0;

        for (sp_inx, sp) in self.staking_pools.iter().enumerate() {
            // if the pool is not busy, has stake, and has not unstaked blanace waiting for withdrawal
            if !sp.busy_lock && sp.staked > 0 && sp.unstaked == 0 {
                // if this pool has an unbalance requiring un-staking
                let should_have = apply_pct(sp.weight_basis_points, self.total_for_staking);
                // does this pool requires un-staking? (has too much staked?)
                if sp.staked > should_have {
                    // how much?
                    let unstake_amount = sp.staked - should_have;
                    // is this the most unbalanced pool so far?
                    if unstake_amount > selected_to_unstake_amount {
                        selected_to_unstake_amount = unstake_amount;
                        selected_stake = sp.staked;
                        selected_sp_inx = sp_inx;
                    }
                }
            }
        }

        if selected_to_unstake_amount>0 {
            if selected_to_unstake_amount > total_to_unstake { 
                selected_to_unstake_amount = total_to_unstake 
            };
            //to avoid moving small amounts, if the remainder is less than 5K and this pool can accomodate the unstaking, increase amount
            let remainder = total_to_unstake - selected_to_unstake_amount;
            if remainder <= MIN_STAKE_UNSTAKE_AMOUNT_MOVEMENT && selected_stake > selected_to_unstake_amount+remainder+2*MIN_STAKE_UNSTAKE_AMOUNT_MOVEMENT { 
                selected_to_unstake_amount += remainder 
            };
        }
        return (selected_sp_inx, selected_to_unstake_amount);
    }

    // MULTI FUN TOKEN [NEP-138](https://github.com/near/NEPs/pull/138)
    /// Transfer `amount` of tok tokens from the caller of the contract (`predecessor_id`) to `receiver_id`.
    /// Requirements:
    /// * receiver_id must pre-exist
    pub fn internal_multifuntok_transfer(&mut self, sender_id: &AccountId, receiver_id: &AccountId, symbol:&String, am: u128) {
        let mut sender_acc = self.internal_get_account(&sender_id);
        let mut receiver_acc = self.internal_get_account(&receiver_id);
        match &symbol as &str {
            "NEAR" => {
                assert!(sender_acc.available >= am, "not enough NEAR at {}",sender_id);
                sender_acc.available -= am;
                receiver_acc.available += am;
            }
            "SKASH" => {
                let skash = self.amount_from_stake_shares(sender_acc.stake_shares);
                assert!(skash >= am,"not enough SKASH at {}",sender_id);
                let shares = self.stake_shares_from_amount(am);
                assert!(sender_acc.stake_shares <= shares,"IC");
                sender_acc.stake_shares -= shares;
                receiver_acc.stake_shares += shares;
            }
            "G-SKASH" => {
                sender_acc.stake_realize_g_skash(self);
                assert!(sender_acc.realized_g_skash >= am,"not enough G-SKASH at {}",sender_id);
                sender_acc.realized_g_skash -= am;
                receiver_acc.realized_g_skash += am;
            }
            _ => panic!("invalid symbol")
        }
        self.internal_update_account(&sender_id, &sender_acc);
        self.internal_update_account(&receiver_id, &receiver_acc);
    }

}

'''
'''--- divpool/src/lib.rs ---
//! A smart contract that allows diversified staking, SKASH and G-SKASH farming
//! this contract include parts of core-contracts/lockup-contract & core-contracts/staking-pool

/********************************/
/* CONTRACT Self Identification */
/********************************/
// [NEP-129](https://github.com/nearprotocol/NEPs/pull/129)
// see also pub fn get_contract_info
const CONTRACT_NAME: &str = "diversifying staking pool";
const CONTRACT_VERSION: &str = "0.1.0";
const DEFAULT_WEB_APP_URL: &str = "http://divpool.narwallets.com";
const DEFAULT_AUDITOR_ACCOUNT_ID: &str = "auditors.near";

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::Base58PublicKey;
use near_sdk::{collections::UnorderedMap, env, ext_contract, near_bindgen, AccountId};

pub use crate::internal::*;
pub use crate::owner::*;
pub use crate::getters::*;
pub use crate::types::*;
pub use crate::utils::*;

pub mod gas;
pub mod types;
pub mod utils;
pub mod getters;

pub mod distribute;
pub mod internal;
pub mod owner;
pub mod multi_fun_token;

#[cfg(target = "wasm32")]
#[global_allocator]
static ALLOC: near_sdk::wee_alloc::WeeAlloc = near_sdk::wee_alloc::WeeAlloc::INIT;

pub const NSLP_INTERNAL_ACCOUNT: &str = "..NSLP..";

macro_rules! debug {
    ($($arg:tt)*) => ({
        env::log(format!($($arg)*).as_bytes());
    });
}

#[ext_contract(ext_staking_pool)]
pub trait ExtStakingPool {
    fn get_account_staked_balance(&self, account_id: AccountId) -> U128String;

    fn get_account_unstaked_balance(&self, account_id: AccountId) -> U128String;

    fn get_account_total_balance(&self, account_id: AccountId) -> U128String;

    fn deposit(&mut self);

    fn deposit_and_stake(&mut self);

    fn withdraw(&mut self, amount: U128String);

    fn stake(&mut self, amount: U128String);

    fn unstake(&mut self, amount: U128String);

    fn unstake_all(&mut self);
}

#[ext_contract(ext_self_owner)]
pub trait ExtDivPoolContractOwner {
    fn on_staking_pool_deposit(&mut self, amount: U128String) -> bool;

    fn on_staking_pool_withdraw(&mut self, inx: u16) -> bool;

    fn on_staking_pool_stake_maybe_deposit(
        &mut self,
        sp_inx: usize,
        amount: u128,
        included_deposit: bool,
    ) -> bool;

    fn on_staking_pool_unstake(&mut self, sp_inx: usize, amount: u128) -> bool;

    //fn on_staking_pool_unstake_all(&mut self) -> bool;

    fn on_get_result_from_transfer_poll(&mut self, #[callback] poll_result: PollResult) -> bool;

    fn on_get_sp_total_balance(&mut self, sp_inx: usize, #[callback] total_balance: U128String);

}

// -----------------
// Reward meter utility
// -----------------
#[derive(BorshDeserialize, BorshSerialize, Debug, PartialEq)]
pub struct RewardMeter {
    ///added with staking
    ///subtracted on unstaking. WARN: Since unstaking can inlude rewards, delta_staked *CAN BECOME NEGATIVE*
    pub delta_staked: i128,
    /// (pct: 100 => x1, 200 => x2)
    pub last_multiplier_pct: u16,
}

impl Default for RewardMeter {
    fn default() -> Self {
        Self {
            delta_staked: 0,
            last_multiplier_pct: 100,
        }
    }
}

impl RewardMeter {
    /// compute rewards received (extra after stake/unstake)
    /// multiplied by last_multiplier_pct%
    pub fn compute_rewards(&self, valued_shares: u128) -> u128 {
        if self.delta_staked > 0 && valued_shares == (self.delta_staked as u128) {
            return 0; //fast exit
        }
        assert!(valued_shares < ((i128::MAX - self.delta_staked) as u128), "TB");
        assert!(
            self.delta_staked < 0 || valued_shares >= (self.delta_staked as u128),
            "valued_shares:{} .LT. self.delta_staked:{}",valued_shares,self.delta_staked
        );
        // valued_shares - self.delta_staked => true rewards
        return (
            U256::from( (valued_shares as i128) - self.delta_staked )
            * U256::from(self.last_multiplier_pct) / U256::from(100)
        ).as_u128();
    }
    ///register a stake (to be able to compute rewards later)
    pub fn stake(&mut self, value: u128) {
        assert!(value < (i128::MAX as u128));
        self.delta_staked += value as i128;
    }
    ///register a unstake (to be able to compute rewards later)
    pub fn unstake(&mut self, value: u128) {
        assert!(value < (i128::MAX as u128));
        self.delta_staked -= value as i128;
    }
    ///realize rewards
    /// compute rewards received (extra after stake/unstake) multiplied by last_multiplier_pct%
    /// adds to self.realized
    /// then reset the meter to zero
    /// and maybe update the multiplier
    pub fn realize(&mut self, valued_shares: u128, new_multiplier_pct: u16) -> u128 {
        let result = self.compute_rewards(valued_shares);
        self.delta_staked = valued_shares as i128; // reset meter to Zero
        self.last_multiplier_pct = new_multiplier_pct; //maybe changed, start aplying new multiplier
        return result;
    }
}

// -----------------
// User Account Data
// -----------------
#[derive(BorshDeserialize, BorshSerialize, Debug, PartialEq)]
pub struct Account {
    /// This amount increments with deposits and decrements with for_staking
    /// increments with complete_unstake and decrements with user withdrawals from the contract
    /// withdrawals from the pools can include rewards
    /// since statking is delayed and in batches it only eventually matches env::balance()
    /// total = available + staked + unstaked
    pub available: u128,

    /// The amount of shares of the total staked balance in the pool(s) this user owns.
    /// Before someone stakes share-price is computed and shares are "sold" to the user so he only owns what he's staking and no rewards yet
    /// When a user reequest a transfer to other user, staked & shares from the origin are moved to staked & shares of the destination
    /// The share_price can be computed as total_for_staking/total_stake_shares
    /// shares * share_price = SKASHs
    stake_shares: u128,

    /// Incremented when the user asks for unstaking. The amount of unstaked near in the pools
    pub unstaked: u128,

    /// The epoch height when the unstaked will be available
    /// The fund will be locked for -AT LEAST- NUM_EPOCHS_TO_UNLOCK epochs
    pub unstaked_requested_unlock_epoch: EpochHeight,

    //-- G-SKASH
    ///realized G-SKASH, can be used to transfer G-SKASH from one user to another
    // Total G-SKASH = realized_g_skash + staking_meter.mul_rewards(valued_stake_shares) + lp_meter.mul_rewards(valued_lp_shares)
    // Every time the user operates on STAKE/UNSTAKE: we realize g-skash: realized_g_skash += staking_meter.mul_rewards(valued_staked_shares)
    // Every time the user operates on ADD.LIQ/REM.LIQ.: we realize g-skash: realized_g_skash += lp_meter.mul_rewards(valued_lp_shares)
    // if the user calls farm_g_skash() we perform both
    pub realized_g_skash: u128,
    ///Staking rewards meter (to mint skash for the user)
    pub staking_meter: RewardMeter,
    ///LP fee gains meter (to mint g-skash for the user)
    pub lp_meter: RewardMeter,

    //-- STATISTICAL DATA --
    // User's statistical data
    // This is the user-cotrolled staking rewards meter, it works as a car's "trip meter". The user can reset them to zero.
    // to compute trip_rewards we start from current_skash, undo unstakes, undo stakes and finally subtract trip_start_skash
    // trip_rewards = current_skash + trip_accum_unstakes - trip_accum_stakes - trip_start_skash;
    /// trip_start: (timpestamp in miliseconds) this field is set at account creation, so it will start metering rewards
    pub trip_start: Timestamp,

    /// How much skashs the user had at "trip_start".
    pub trip_start_skash: u128,
    // how much skahs the staked since trip start. always incremented
    pub trip_accum_stakes: u128,
    // how much the user unstaked since trip start. always incremented
    pub trip_accum_unstakes: u128,

    ///NS liquidity pool shares, if the user is a liquidity provider
    pub nslp_shares: u128,
}

/// User account on this contract
impl Default for Account {
    fn default() -> Self {
        Self {
            available: 0,
            stake_shares: 0,
            unstaked: 0,
            unstaked_requested_unlock_epoch: 0,
            //g-skash & reward-meters
            realized_g_skash: 0,
            staking_meter: RewardMeter::default(),
            lp_meter: RewardMeter::default(),
            //trip-meter fields
            trip_start: env::block_timestamp() / 1_000_000, //converted from nanoseconds to miliseconds
            trip_start_skash: 0,
            trip_accum_stakes: 0,
            trip_accum_unstakes: 0,
            //NS liquidity pool
            nslp_shares: 0,
        }
    }
}
impl Account {
    /// when the account.is_empty() it will be removed
    fn is_empty(&self) -> bool {
        return self.available == 0
            && self.unstaked == 0
            && self.stake_shares == 0
            && self.nslp_shares == 0
            && self.realized_g_skash == 0;
    }

    #[inline]
    fn valued_nslp_shares(&self, main: &DiversifiedPool, nslp_account: &Account) -> u128 { main.amount_from_nslp_shares(self.nslp_shares, &nslp_account) }

    /// return realized g_skash plus pending rewards
    fn total_g_skash(&self, main: &DiversifiedPool) -> u128 {
        let valued_stake_shares = main.amount_from_stake_shares(self.stake_shares);
        let nslp_account = main.internal_get_nslp_account();
        let valued_lp_shares = self.valued_nslp_shares(main, &nslp_account);
        debug!("self.realized_g_skash:{}, self.staking_meter.compute_rewards(valued_stake_shares):{} self.lp_meter.compute_rewards(valued_lp_shares):{}",
            self.realized_g_skash, self.staking_meter.compute_rewards(valued_stake_shares), self.lp_meter.compute_rewards(valued_lp_shares));
        return self.realized_g_skash
            + self.staking_meter.compute_rewards(valued_stake_shares)
            + self.lp_meter.compute_rewards(valued_lp_shares);
    }

    //---------------------------------
    fn stake_realize_g_skash(&mut self, main:&mut DiversifiedPool) {
        //realize g-skash pending rewards on LP operation
        let valued_actual_shares = main.amount_from_stake_shares(self.stake_shares);
        let pending_g_skash = self.staking_meter.realize(valued_actual_shares, main.staker_g_skash_mult_pct);
        self.realized_g_skash += pending_g_skash;
        main.total_g_skash += pending_g_skash;
    }

    fn nslp_realize_g_skash(&mut self, nslp_account:&Account, main:&mut DiversifiedPool)  {
        //realize g-skash pending rewards on LP operation
        let valued_actual_shares = self.valued_nslp_shares(main, &nslp_account);
        let pending_g_skash = self.lp_meter.realize(valued_actual_shares, main.lp_provider_g_skash_mult_pct);
        self.realized_g_skash += pending_g_skash;
        main.total_g_skash += pending_g_skash;
    }

    //----------------
    fn add_stake_shares(&mut self, num_shares:u128, skash:u128){
        self.stake_shares += num_shares;
        //to buy skash is stake
        self.trip_accum_stakes += skash;
        self.staking_meter.stake(skash);
    }
    fn sub_stake_shares(&mut self, num_shares:u128, skash:u128){
        assert!(self.stake_shares>num_shares,"RSS-NES");
        self.stake_shares -= num_shares;
        //to sell skash is to unstake
        self.trip_accum_unstakes += skash;
        self.staking_meter.unstake(skash);
    }

    /// user method
    /// completes unstake action by moving from retreieved_from_the_pools to available
    fn try_finish_unstaking(&mut self, main:&mut DiversifiedPool) {

        let amount = self.unstaked;
        assert!(amount > 0, "No unstaked balance");
        
        let epoch = env::epoch_height();
        assert!( epoch >= self.unstaked_requested_unlock_epoch,
            "The unstaked balance is not yet available due to unstaking delay. You need to wait at least {} epochs"
            , self.unstaked_requested_unlock_epoch - epoch);

        //use retrieved funds
        // moves from total_actually_unstaked_and_retrieved to total_available
        assert!(main.total_actually_unstaked_and_retrieved >= amount, "Funds are not yet available due to unstaking delay. Epoch:{}",env::epoch_height());
        main.total_actually_unstaked_and_retrieved -= amount;
        main.total_available += amount;
        // in the account, moves from unstaked to available
        self.unstaked -= amount; //Zeroes
        self.available += amount;
    }

}

//-------------------------
//--  STAKING POOLS LIST --
//-------------------------
/// items in the Vec of staking pools
#[derive(Default)]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct StakingPoolInfo {
    pub account_id: AccountId,

    //how much of the meta-pool must be staked in this pool
    //0=> do not stake, only unstake
    //100 => 1% , 250=>2.5%, etc. -- max: 10000=>100%
    pub weight_basis_points: u16,

    //if we've made an async call to this pool
    pub busy_lock: bool,

    //total staked here
    pub staked: u128,

    //total unstaked in this pool
    pub unstaked: u128,
    //set when the unstake command is passed to the pool
    //waiting period is until env::EpochHeight == unstaked_requested_epoch_height+NUM_EPOCHS_TO_UNLOCK
    //We might have to block users from unstaking if all the pools are in a waiting period
    pub unstk_req_epoch_height: EpochHeight, // = env::epoch_height() + NUM_EPOCHS_TO_UNLOCK

    //EpochHeight where we asked the sp what were our staking rewards
    pub last_asked_rewards_epoch_height: EpochHeight,
}

impl StakingPoolInfo {
    pub fn is_empty(&self) -> bool {
        return self.busy_lock == false
            && self.weight_basis_points == 0
            && self.staked == 0
            && self.unstaked == 0
    }
    pub fn new(account_id:AccountId, weight_basis_points: u16) -> Self {
        return Self {
            account_id,
            weight_basis_points,
            busy_lock: false,
            staked:0,
            unstaked:0,
            unstk_req_epoch_height:0,
            last_asked_rewards_epoch_height:0
        }
    }
}

//------------------------
//  Main Contract State --
//------------------------
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct DiversifiedPool {
    /// Owner's account ID (it will be a DAO on phase II)
    pub owner_account_id: String,

    /// if you're holding skash there's a min balance you must mantain to backup storage usage
    /// can be adjusted down by keeping the required NEAR in the developers or operator account
    pub min_account_balance: u128,

    // Configurable info for [NEP-129](https://github.com/nearprotocol/NEPs/pull/129)
    pub web_app_url: Option<String>, 
    pub auditor_account_id: Option<String>,

    /// This amount increments with deposits and decrements when users stake
    /// increments with finish_unstake and decrements with user withdrawals from the contract
    /// since staking/unstaking is delayed it only eventually matches env::balance()
    pub total_available: u128,

    /// The total amount of tokens selected for staking by the users
    /// not necessarily what's actually staked since staking can is done in batches
    /// Share price is computed using this number. share_price = total_for_staking/total_shares
    pub total_for_staking: u128,

    /// The total amount of tokens actually staked (the tokens are in the staking pools)
    // During distribute_staking(), If !staking_paused && total_for_staking<total_actually_staked, then the difference gets staked in the pools
    // During distribute_unstaking(), If total_actually_staked>total_for_staking, then the difference gets unstaked from the pools
    pub total_actually_staked: u128,

    /// how many "shares" were minted. Everytime someone "stakes" he "buys pool shares" with the staked amount
    // the buy share price is computed so if she "sells" the shares on that moment she recovers the same near amount
    // staking produces rewards, rewards are added to total_for_staking so share_price will increase with rewards 
    // share_price = total_for_staking/total_shares
    // when someone "unstakes" she "burns" X shares at current price to recoup Y near
    pub total_stake_shares: u128,

    /// G-SKASH is the governance token. Total g-skash minted
    pub total_g_skash: u128,

    /// The total amount of tokens actually unstaked and in the waiting-delay (the tokens are in the staking pools)
    pub total_unstaked_and_waiting: u128,

    /// The total amount of tokens actually unstaked AND retrieved from the pools (the tokens are here)
    /// It represents funds retrieved from the pools, but waiting for the users to execute finish_unstake()
    /// During distribute_unstake(), If sp.unstaked>0 && sp.epoch_for_withdraw == env::epoch_height then all unstaked funds are retrieved from the sp
    /// When the funds are actually requested by the users, total_actually_unstaked is decremented
    pub total_actually_unstaked_and_retrieved: u128,

    /// the staking pools will add rewards to the staked amount on each epoch
    /// here we store the accumulatred amount only for stats purposes. This amount can only grow
    pub accumulated_staked_rewards: u128,

    /// no auto-staking. true while changing staking pools
    pub staking_paused: bool,

    //user's accounts
    pub accounts: UnorderedMap<String, Account>,

    //list of pools to diversify in
    pub staking_pools: Vec<StakingPoolInfo>,

    //The next 3 values define the Liq.Provider fee curve
    // NEAR/SKASH Liquidity pool fee curve params
    // We assume this pool is always UNBALANCED, there should be more SKASH than NEAR 99% of the time
    ///NEAR/SKASH Liquidity pool target
    pub nslp_near_target: u128,
    ///NEAR/SKASH Liquidity pool max fee
    pub nslp_max_discount_basis_points: u16, //10%
    ///NEAR/SKASH Liquidity pool min fee
    pub nslp_min_discount_basis_points: u16, //0.1%

    //The next 3 values define g-skash rewards multiplers %. (100 => 1x, 200 => 2x, ...)
    ///for each SKASH paid staking reward, reward SKASH holders with g-SKASH. default:5x. reward G-SKASH = rewards * mult_pct / 100
    pub staker_g_skash_mult_pct: u16,
    ///for each SKASH paid as discount, reward SKASH sellers with g-SKASH. default:1x. reward G-SKASH = discounted * mult_pct / 100
    pub skash_sell_g_skash_mult_pct: u16,
    ///for each SKASH paid as discount, reward LP providers  with g-SKASH. default:20x. reward G-SKASH = fee * mult_pct / 100
    pub lp_provider_g_skash_mult_pct: u16,

    /// Operator account ID (who's in charge to call distribute_xx() on a periodic basis)
    pub operator_account_id: String,
    /// operator_rewards_fee_basis_points. (0.2% default) 100 basis point => 1%. E.g.: owner_fee_basis_points=30 => 0.3% owner's fee
    pub operator_rewards_fee_basis_points: u16,
    /// owner's cut on SHKASH Sell fee (3% default)
    pub operator_swap_cut_basis_points: u16,
    /// Treasury account ID (it will be controlled by a DAO on phase II)
    pub treasury_account_id: String,
    /// treasury cut on SHKASH Sell cut (25% default)
    pub treasury_swap_cut_basis_points: u16,
}

impl Default for DiversifiedPool {
    fn default() -> Self {
        env::panic(b"The contract is not initialized.");
    }
}

#[near_bindgen]
impl DiversifiedPool {
    /* NOTE
    This contract implements several traits

    1. deposit-trait [NEP-xxx]: this contract implements: deposit, get_account_total_balance, get_account_available_balance, withdraw, withdraw_all
       A [NEP-xxx] contract creates an account on deposit and allows you to withdraw later under certain conditions. Deletes the account on withdraw_all

    2. staking-pool [NEP-xxx]: this contract must be perceived as a staking-pool for the lockup-contract, wallets, and users.
        This means implmenting: ping, deposit, deposit_and_stake, withdraw_all, withdraw, stake_all, stake, unstake_all, unstake
        and view methods: get_account_unstaked_balance, get_account_staked_balance, get_account_total_balance, is_account_unstaked_balance_available,
            get_total_staked_balance, get_owner_id, get_reward_fee_fraction, is_staking_paused, get_staking_key, get_account,
            get_number_of_accounts, get_accounts.

    3. diversified-staking: these are the extensions to the standard staking pool (buy/sell skash, finish_unstake)

    4. multitoken (TODO) [NEP-xxx]: this contract implements: deposit(tok), get_token_balance(tok), withdraw_token(tok), tranfer_token(tok), transfer_token_to_contract(tok)
       A [NEP-xxx] manages multiple tokens

    */

    /// Requires 25 TGas (1 * BASE_GAS)
    ///
    /// Initializes DiversifiedPool contract.
    /// - `owner_account_id` - the account ID of the owner.  Only this account can call owner's methods on this contract.
    #[init]
    pub fn new(
        owner_account_id: AccountId,
        treasury_account_id: AccountId,
        operator_account_id: AccountId,
    ) -> Self {
        assert!(!env::state_exists(), "The contract is already initialized");

        return Self {
            owner_account_id,
            operator_account_id,
            treasury_account_id,
            min_account_balance: ONE_NEAR,
            web_app_url: Some(String::from(DEFAULT_WEB_APP_URL)),
            auditor_account_id: Some(String::from(DEFAULT_AUDITOR_ACCOUNT_ID)),
            operator_rewards_fee_basis_points: DEFAULT_OPERATOR_REWARDS_FEE_BASIS_POINTS,
            operator_swap_cut_basis_points: DEFAULT_OPERATOR_SWAP_CUT_BASIS_POINTS,
            treasury_swap_cut_basis_points: DEFAULT_TREASURY_SWAP_CUT_BASIS_POINTS,
            staking_paused: false, 
            total_available: 0,
            total_for_staking: 0,
            total_actually_staked: 0, //amount actually sent to the staking_pool and staked
            total_unstaked_and_waiting: 0, // tracks unstaked amount from the staking_pool (toekns are in the pool)
            total_actually_unstaked_and_retrieved: 0, // tracks unstaked AND retrieved amount (tokens are here)
            accumulated_staked_rewards: 0,
            total_stake_shares: 0,
            total_g_skash: 0,
            accounts: UnorderedMap::new("A".into()),
            nslp_near_target: ONE_NEAR * 1_000_000,
            nslp_max_discount_basis_points: 500, //5%
            nslp_min_discount_basis_points: 50,   //0.5%
            ///for each SKASH paid as discount, reward SKASH sellers with g-SKASH. default:1x. reward G-SKASH = discounted * mult_pct / 100
            skash_sell_g_skash_mult_pct: 100, //1x
            ///for each SKASH paid staking reward, reward SKASH holders with g-SKASH. default:5x. reward G-SKASH = rewards * mult_pct / 100
            staker_g_skash_mult_pct: 500, //5x
            ///for each SKASH paid as discount, reward LPs with g-SKASH. default:20x. reward G-SKASH = fee * mult_pct / 100
            lp_provider_g_skash_mult_pct: 2000, //20x

            staking_pools: Vec::new(),

        };
    }

    //pub fn set_min_balance(&mut self)

    //------------------------------------
    // deposit trait & staking-pool trait
    //------------------------------------

    /// staking-pool's ping is moot here
    pub fn ping(&mut self) {
        
    }

    /// Deposits the attached amount into the inner account of the predecessor.
    #[payable]
    pub fn deposit(&mut self) {
        self.internal_deposit();
    }

    /// Withdraws from the available balance
    pub fn withdraw(&mut self, amount: U128String) {
        self.internal_withdraw(amount.into());
    }

    /// Withdraws ALL from the "available" balance
    pub fn withdraw_all(&mut self) {
        let account_id = env::predecessor_account_id();
        let account = self.internal_get_account(&account_id);
        self.internal_withdraw(account.available);
    }

    /// Deposits the attached amount into the inner account of the predecessor and stakes it.
    #[payable]
    pub fn deposit_and_stake(&mut self) {
        self.internal_deposit();
        self.internal_stake(env::attached_deposit());
    }

    /// Stakes all available unstaked balance from the inner account of the predecessor.
    /// staking-pool "unstaked" is equivalent to diversified-pool "available", but here
    /// we keep the staking-pool logic because we're implementing the staking-pool trait
    pub fn stake_all(&mut self) {
        let account_id = env::predecessor_account_id();
        let account = self.internal_get_account(&account_id);
        self.internal_stake(account.unstaked);
    }

    /// Stakes the given amount from the inner account of the predecessor.
    /// The inner account should have enough unstaked balance.
    pub fn stake(&mut self, amount: U128String) {
        self.internal_stake(amount.0);
    }

    /// Unstakes all staked balance from the inner account of the predecessor.
    /// The new total unstaked balance will be available for withdrawal in four epochs.
    pub fn unstake_all(&mut self) {
        let account_id = env::predecessor_account_id();
        let account = self.internal_get_account(&account_id);
        let amount = self.amount_from_stake_shares(account.stake_shares);
        self.internal_unstake(amount);
    }

    /// Unstakes the given amount from the inner account of the predecessor.
    /// The inner account should have enough staked balance.
    /// The new total unstaked balance will be available for withdrawal in four epochs.
    pub fn unstake(&mut self, amount: U128String) {
        self.internal_unstake(amount.0);
    }

    /*****************************/
    /* staking-pool View methods */
    /*****************************/

    /// Returns the unstaked balance of the given account.
    pub fn get_account_unstaked_balance(&self, account_id: AccountId) -> U128String {
        //warning: self.get_account is public and gets HumanReadableAccount .- do not confuse with self.internal_get_account
        return self.get_account(account_id).unstaked_balance;
    }

    /// Returns the staked balance of the given account.
    /// NOTE: This is computed from the amount of "stake" shares the given account has and the
    /// current amount of total staked balance and total stake shares on the account.
    pub fn get_account_staked_balance(&self, account_id: AccountId) -> U128String {
        //warning: self.get_account is public and gets HumanReadableAccount .- do not confuse with self.internal_get_account
        return self.get_account(account_id).staked_balance;
    }

    /// Returns the total balance of the given account (including staked and unstaked balances).
    pub fn get_account_total_balance(&self, account_id: AccountId) -> U128String {
        let acc = self.internal_get_account(&account_id);
        return (acc.available + self.amount_from_stake_shares(acc.stake_shares)+ acc.unstaked).into();
    }

    /// additional to staking-pool to satisfy generic deposit-NEP-standard
    /// returns the amount that can be withdrawn immediately
    pub fn get_account_available_balance(&self, account_id: AccountId) -> U128String {
        let acc = self.internal_get_account(&account_id);
        return acc.available.into();
    }
    

    /// Returns `true` if the given account can withdraw tokens in the current epoch.
    pub fn is_account_unstaked_balance_available(&self, account_id: AccountId) -> bool {
        //warning: self.get_account is public and gets HumanReadableAccount .- do not confuse with self.internal_get_account
        return self.get_account(account_id).can_withdraw;
    }

    /// Returns account ID of the staking pool owner.
    pub fn get_owner_id(&self) -> AccountId {
        return self.owner_account_id.clone();
    }

    /// Returns the current reward fee as a fraction.
    pub fn get_reward_fee_fraction(&self) -> RewardFeeFraction {
        return RewardFeeFraction {
            numerator: (self.operator_rewards_fee_basis_points + DEVELOPERS_REWARDS_FEE_BASIS_POINTS)
                .into(),
            denominator: 10_000,
        };
    }

    /// Returns the staking public key
    pub fn get_staking_key(&self) -> Base58PublicKey {
        panic!("no specific staking key for the div-pool");
    }

    /// Returns true if the staking is paused
    pub fn is_staking_paused(&self) -> bool {
        return self.staking_paused;
    }

    /// to implement the Staking-pool inteface, get_account returns the same as the staking-pool returns
    /// full account info can be obtained by calling: pub fn get_account_info(&self, account_id: AccountId) -> GetAccountInfoResult
    /// Returns human readable representation of the account for the given account ID.
    //warning: self.get_account is public and gets HumanReadableAccount .- do not confuse with self.internal_get_account
    pub fn get_account(&self, account_id: AccountId) -> HumanReadableAccount {
        let account = self.internal_get_account(&account_id);
        return HumanReadableAccount {
            account_id,
            unstaked_balance: account.unstaked.into(),
            staked_balance: self.amount_from_stake_shares(account.stake_shares).into(),
            can_withdraw: env::epoch_height() >= account.unstaked_requested_unlock_epoch,
        };
    }

    /// Returns the number of accounts that have positive balance on this staking pool.
    pub fn get_number_of_accounts(&self) -> u64 {
        return self.accounts.len();
    }

    /// Returns the list of accounts (staking-pool trait)
    //warning: self.get_accounts is public and gets HumanReadableAccount .- do not confuse with self.internal_get_account
    pub fn get_accounts(&self, from_index: u64, limit: u64) -> Vec<HumanReadableAccount> {
        let keys = self.accounts.keys_as_vector();
        return (from_index..std::cmp::min(from_index + limit, keys.len()))
            .map(|index| self.get_account(keys.get(index).unwrap()))
            .collect();
    }

    //----------------------------------
    //----------------------------------
    // DIVERISIFYING-STAKING-POOL trait
    //----------------------------------
    //----------------------------------

    /// Returns the list of accounts with full data (div-pool trait)
    pub fn get_accounts_info(&self, from_index: u64, limit: u64) -> Vec<GetAccountInfoResult> {
        let keys = self.accounts.keys_as_vector();
        return (from_index..std::cmp::min(from_index + limit, keys.len()))
            .map(|index| self.get_account_info(keys.get(index).unwrap()))
            .collect();
    }

    /// user method
    /// completes unstake action by moving from retreieved_from_the_pools to available
    pub fn finish_unstaking(&mut self) {

        let account_id = env::predecessor_account_id();
        let mut account = self.internal_get_account(&account_id);

        account.try_finish_unstaking(self);

        self.internal_update_account(&account_id, &account);

        env::log(
            format!(
                "@{} finishing unstaking. New available balance is {}",
                account_id, account.available
            )
            .as_bytes(),
        );
    }

    /// buy_skash_stake. Identical to stake, migth change in the future
    pub fn buy_skash_stake(&mut self, amount: U128String) {
        self.internal_stake(amount.0);
    }

    //---------------------------
    // NSLP Methods
    //---------------------------

    /// user method - NEAR/SKASH SWAP functions
    /// return how much NEAR you can get by selling x SKASH
    pub fn get_near_amount_sell_skash(&self, skash_to_sell: U128String) -> U128String {
        let lp_account = self.internal_get_nslp_account();
        return self.internal_get_near_amount_sell_skash(lp_account.available, skash_to_sell.0).into();
    }

    /// NEAR/SKASH Liquidity Pool
    /// computes the discount_basis_points for NEAR/SKASH Swap based on NSLP Balance
    /// If you want to sell x SKASH
    pub fn nslp_get_discount_basis_points(&self, skash_to_sell: U128String) -> u16 {
        let lp_account = self.internal_get_nslp_account();
        return self.internal_get_discount_basis_points(lp_account.available, skash_to_sell.0);
    }

    /// user method
    /// Sells-skash at discount in the NLSP
    /// returns near received
    pub fn sell_skash(
        &mut self,
        skash_to_sell: U128String,
        min_expected_near: U128String,
    ) -> U128String {
        let account_id = env::predecessor_account_id();
        let mut user_account = self.internal_get_account(&account_id);

        let skash_owned = self.amount_from_stake_shares(user_account.stake_shares);
        assert!(
            skash_owned >= skash_to_sell.0,
            "Not enough skash in your account"
        );
        let mut nslp_account = self.internal_get_nslp_account();
        let near_to_receive =
            self.internal_get_near_amount_sell_skash(nslp_account.available, skash_to_sell.0);
        assert!(
            near_to_receive >= min_expected_near.0,
            "Price changed, your min results requirements {} not satisfied {}. Try again", min_expected_near.0, near_to_receive
        );
        assert!(
            nslp_account.available >= near_to_receive,
            "available < near_to_receive"
        );

        let stake_shares_sell = self.stake_shares_from_amount(skash_to_sell.0);
        assert!(
            user_account.stake_shares >= stake_shares_sell,
            "account.stake_shares < stake_shares_sell"
        );

        //the available for the user comes from the LP
        nslp_account.available -= near_to_receive;
        user_account.available += near_to_receive;

        //the fee is the difference between skash sold and near received
        assert!(near_to_receive < skash_to_sell.0);
        let fee_in_skash = skash_to_sell.0 - near_to_receive;
        // compute how many shares the swap fee represent
        let fee_in_shares = self.stake_shares_from_amount(fee_in_skash);

        // involved accounts
        let mut treasury_account = self.internal_get_account(&self.treasury_account_id);
        let mut operator_account = self.internal_get_account(&self.operator_account_id);
        let mut developers_account = self.internal_get_account(&DEVELOPERS_ACCOUNT_ID.into());

        // The treasury cut in skash-shares (25% by default)
        let treasury_stake_shares_cut = apply_pct(self.treasury_swap_cut_basis_points,fee_in_shares);
        let treasury_skash_cut = apply_pct(self.treasury_swap_cut_basis_points,fee_in_skash);
        treasury_account.add_stake_shares(treasury_stake_shares_cut,treasury_skash_cut);
        
        // The cut that the contract owner (operator) takes. (3% of 1% normally)
        let operator_stake_shares_cut = apply_pct( self.operator_swap_cut_basis_points,fee_in_shares);
        let operator_skash_cut = apply_pct( self.operator_swap_cut_basis_points, fee_in_skash);
        operator_account.add_stake_shares(operator_stake_shares_cut,operator_skash_cut);

        // The cut that the developers take. (2% of 1% normally)
        let developers_stake_shares_cut = apply_pct(DEVELOPERS_SWAP_CUT_BASIS_POINTS, fee_in_shares);
        let developers_skash_cut = apply_pct(DEVELOPERS_SWAP_CUT_BASIS_POINTS, fee_in_skash);
        developers_account.add_stake_shares(developers_stake_shares_cut,developers_skash_cut);

        // all the realized g-skash from non-liq.provider cuts (30%), send to operator & developers
        let skash_non_lp_cut = treasury_skash_cut+operator_skash_cut+developers_skash_cut;
        let g_skash_from_operation = apply_multiplier(skash_non_lp_cut, self.lp_provider_g_skash_mult_pct);
        self.total_g_skash += g_skash_from_operation;
        operator_account.realized_g_skash += g_skash_from_operation/2;
        developers_account.realized_g_skash += g_skash_from_operation/2;

        debug!("treasury_stake_shares_cut:{} operator_stake_shares_cut:{} developers_stake_shares_cut:{} fee_in_stake_shares:{}",
            treasury_stake_shares_cut,operator_stake_shares_cut,developers_stake_shares_cut,fee_in_shares);

        debug!("treasury_skash_cut:{} operator_skash_cut:{} developers_skash_cut:{} fee_in_skash:{} skash_non_lp_cut:{} ",
            treasury_skash_cut,operator_skash_cut,developers_skash_cut,fee_in_skash,skash_non_lp_cut);

        assert!(fee_in_shares > treasury_stake_shares_cut + developers_stake_shares_cut + operator_stake_shares_cut);

        // The rest of the skash sold goes into the LP. Because it is a larger number than NEAR removes, it will increase share value for all LP providers.
        // Adding value to the pool via adding more skash than the near removed, will be counted as rewards for the nslp_meter, 
        // so g-skash for LP providers will be created. G-skash for LP providers are realized during add_liquidit(), remove_liquidity() or by calling harvest_g_skash_from_lp()
        debug!("nslp_account.add_stake_shares {} {}",
            stake_shares_sell - (treasury_stake_shares_cut + operator_stake_shares_cut + developers_stake_shares_cut),
            skash_to_sell.0 - (treasury_skash_cut + operator_skash_cut + developers_skash_cut));

        // major part of skash sold goes to the NSLP
        nslp_account.add_stake_shares( 
            stake_shares_sell - (treasury_stake_shares_cut + operator_stake_shares_cut + developers_stake_shares_cut),
            skash_to_sell.0 - (treasury_skash_cut + operator_skash_cut + developers_skash_cut ));

        //complete the transfer, remove skash from the user (skash was transferred to the LP & others)
        user_account.sub_stake_shares(stake_shares_sell, skash_to_sell.0);
        { //give the selling user some g-skash too
            let g_skash_to_seller = apply_multiplier(fee_in_skash, self.skash_sell_g_skash_mult_pct);
            self.total_g_skash += g_skash_to_seller;
            user_account.realized_g_skash += g_skash_to_seller;
        }

        //Save involved accounts
        self.internal_update_account(&self.treasury_account_id.clone(), &treasury_account);
        self.internal_update_account(&self.operator_account_id.clone(), &operator_account);
        self.internal_update_account(&DEVELOPERS_ACCOUNT_ID.into(), &developers_account);
        //Save user and nslp accounts
        self.internal_update_account(&account_id, &user_account);
        self.internal_save_nslp_account(&nslp_account);

        env::log(
            format!(
                "@{} sold {} SKASH for {} NEAR",
                account_id, skash_to_sell.0, near_to_receive
            )
            .as_bytes(),
        );

        return near_to_receive.into();
    }

    /// add liquidity from deposited funds
    pub fn nslp_add_liquidity(&mut self, amount: U128String) {
        assert_min_amount(amount.0);

        let account_id = env::predecessor_account_id();
        let mut acc = self.internal_get_account(&account_id);

        assert!(
            acc.available >= amount.0,
            "Not enough available balance to add the requested amount to the NSLP"
        );

        //get NSLP account
        let mut nslp_account = self.internal_get_nslp_account();

        //use this LP operation to realize g-skash pending rewards (same as nslp_harvest_g_skash)
        acc.nslp_realize_g_skash(&nslp_account, self);

        // Calculate the number of "nslp" shares that the account will receive for adding the given amount of near liquidity
        let num_shares = self.nslp_shares_from_amount(amount.0, &nslp_account);
        assert!(num_shares > 0);

        //register added liquidity to compute rewards correctly
        acc.lp_meter.stake(amount.0);

        //update user account
        acc.available -= amount.0;
        acc.nslp_shares += num_shares;
        //update NSLP account
        nslp_account.available += amount.0;
        nslp_account.nslp_shares += num_shares; //total nslp shares

        //--SAVE ACCOUNTS
        self.internal_update_account(&account_id, &acc);
        self.internal_save_nslp_account(&nslp_account);
    }

    /// remove liquidity from deposited funds
    pub fn nslp_remove_liquidity(&mut self, amount: U128String) {
        
        let account_id = env::predecessor_account_id();
        let mut acc = self.internal_get_account(&account_id);
        let mut nslp_account = self.internal_get_nslp_account();

        //use this LP operation to realize g-skash pending rewards (same as nslp_harvest_g_skash)
        acc.nslp_realize_g_skash(&nslp_account, self);

        //how much does this user owns
        let valued_actual_shares = acc.valued_nslp_shares(self, &nslp_account);

        //register removed liquidity to compute rewards correctly
        acc.lp_meter.unstake(amount.0);

        let mut to_remove = amount.0;
        assert!(
            valued_actual_shares >= to_remove,
            "Not enough share value to remove the requested amount from the NSLP"
        );
        // Calculate the number of "nslp" shares that the account will burn for removing the given amount of near liquidity from the lp
        let mut num_shares_to_burn = self.nslp_shares_from_amount(to_remove, &nslp_account);
        assert!(num_shares_to_burn > 0);

        //cannot leave less than 1 NEAR
        if valued_actual_shares - to_remove < ONE_NEAR {
            //if less than 1 near left, remove all
            to_remove = valued_actual_shares;
            num_shares_to_burn = acc.nslp_shares;
        }

        //compute proportionals SKASH/UNSTAKED/NEAR
        //1st: SKASH
        let stake_shares_to_remove = proportional(
            nslp_account.stake_shares,
            num_shares_to_burn,
            nslp_account.nslp_shares,
        );
        let skash_to_remove_from_pool = self.amount_from_stake_shares(stake_shares_to_remove);
        //2nd: unstaked in the pool, proportional to shares beign burned
        let unstaked_to_remove = proportional(
            nslp_account.unstaked,
            num_shares_to_burn,
            nslp_account.nslp_shares,
        );
        //3rd: NEAR, by difference
        assert!(
            to_remove >= skash_to_remove_from_pool + unstaked_to_remove,
            "inconsistency NTR<STR+UTR"
        );
        let near_to_remove = to_remove - skash_to_remove_from_pool - unstaked_to_remove;

        //update user account
        //remove first from SKASH in the pool, proportional to shares beign burned
        acc.available += near_to_remove;
        acc.add_stake_shares(stake_shares_to_remove, skash_to_remove_from_pool); //add skash to user acc
        acc.unstaked += unstaked_to_remove;
        acc.nslp_shares -= num_shares_to_burn; //shares this user burns
        //update NSLP account
        nslp_account.available -= near_to_remove;
        nslp_account.sub_stake_shares(stake_shares_to_remove,skash_to_remove_from_pool); //remove skash from the pool
        nslp_account.unstaked -= unstaked_to_remove;
        nslp_account.nslp_shares -= num_shares_to_burn; //burn from total nslp shares

        //--SAVE ACCOUNTS
        self.internal_update_account(&account_id, &acc);
        self.internal_save_nslp_account(&nslp_account);
    }

    //------------------
    // HARVEST G-SKASH
    //------------------

    ///g-skash rewards for stakers are realized during stake(), unstake() or by calling harvest_g_skash_from_staking()
    //realize pending g-skash rewards from staking
    pub fn harvest_g_skash_from_staking(&mut self){

        let account_id = env::predecessor_account_id();
        let mut acc = self.internal_get_account(&account_id);

        //realize and mint g-skash
        acc.stake_realize_g_skash(self);

        //--SAVE ACCOUNT
        self.internal_update_account(&account_id, &acc);
    }

    ///g-skash rewards for LP providers are realized during add_liquidit(), remove_liquidity() or by calling harvest_g_skash_from_lp()
    ///realize pending g-skash rewards from LP
    pub fn harvest_g_skash_from_lp(&mut self){

        let account_id = env::predecessor_account_id();
        let mut acc = self.internal_get_account(&account_id);

        //get NSLP account
        let nslp_account = self.internal_get_nslp_account();
        
        //realize and mint g-skash
        acc.nslp_realize_g_skash(&nslp_account, self);
        
        //--SAVE ACCOUNT
        self.internal_update_account(&account_id, &acc);
    }

}

#[cfg(not(target_arch = "wasm32"))]
#[cfg(test)]
mod tests {
    //use std::convert::TryInto;

/*    use near_sdk::{testing_env, MockedBlockchain,  VMContext}; //PromiseResult,

    use test_utils::*;

    use super::*;

    mod test_utils;

    //pub type AccountId = String;

    //const SALT: [u8; 3] = [1, 2, 3];

    fn basic_context() -> VMContext {
        get_context(
            system_account(),
            to_yocto(TEST_INITIAL_BALANCE),
            0,
            to_ts(GENESIS_TIME_IN_DAYS),
            false,
        )
    }

    fn new_contract() -> DiversifiedPool {
        DiversifiedPool::new(account_owner(), account_owner(), account_owner())
    }

    fn contract_only_setup() -> (VMContext, DiversifiedPool) {
        let context = basic_context();
        testing_env!(context.clone());
        let contract = new_contract();
        return (context, contract);
    }

    // #[test]
    // fn test_gfme_only_basic() {
    //     let (mut context, contract) = contract_only_setup();
    //     // Checking initial values at genesis time
    //     context.is_view = true;
    //     testing_env!(context.clone());

    //     assert_eq!(contract.get_owners_balance().0, 0);

    //     // Checking values in 1 day after genesis time
    //     context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + 1);

    //     assert_eq!(contract.get_owners_balance().0, 0);

    //     // Checking values next day after gfme timestamp
    //     context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + YEAR + 1);
    //     testing_env!(context.clone());

    //     assert_almost_eq(contract.get_owners_balance().0, to_yocto(TEST_INITIAL_BALANCE));
    // }
    #[test]
    fn test_internal_get_near_amount_sell_skash() {
        let (_context, contract) = contract_only_setup();
        let lp_balance_y: u128 = to_yocto(500_000);
        let sell_skash_y: u128 = to_yocto(120);
        let discount_bp: u16 = contract.internal_get_discount_basis_points(lp_balance_y, sell_skash_y);
        let near_amount_y =
            contract.internal_get_near_amount_sell_skash(lp_balance_y, sell_skash_y);
        assert!(near_amount_y <= sell_skash_y);
        let discountedy = sell_skash_y - near_amount_y;
        let _discounted_display_n = ytof(discountedy);
        let _sell_skash_display_n = ytof(sell_skash_y);
        assert!(discountedy == apply_pct(discount_bp, sell_skash_y));
        assert!(near_amount_y == sell_skash_y - discountedy);
    }
*/

    /*
    #[test]
    fn test_add_full_access_key() {
        let (mut context, mut contract) = contract_only_setup();
        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + YEAR);
        context.predecessor_account_id = account_owner();
        context.signer_account_id = account_owner();
        context.signer_account_pk = public_key(1).try_into().unwrap();
        testing_env!(context.clone());

        contract.add_full_access_key(public_key(4));
    }

    #[test]
    #[should_panic(expected = "Can only be called by the owner")]
    fn test_call_by_non_owner() {
        let (mut context, mut contract) = contract_only_setup();
        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + YEAR);
        context.predecessor_account_id = non_owner();
        context.signer_account_id = non_owner();
        testing_env!(context.clone());

        contract.select_staking_pool(AccountId::from("staking_pool"));
    }

    #[test]
    fn test_gfme_only_transfer_call_by_owner() {
        let (mut context, mut contract) = contract_only_setup();
        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + YEAR + 1);
        context.is_view = true;
        testing_env!(context.clone());
        assert_almost_eq(contract.get_owners_balance().0, to_yocto(TEST_INITIAL_BALANCE));

        context.predecessor_account_id = account_owner();
        context.signer_account_id = account_owner();
        context.signer_account_pk = public_key(1).try_into().unwrap();
        context.is_view = false;
        testing_env!(context.clone());

        assert_eq!(env::account_balance(), to_yocto(TEST_INITIAL_BALANCE));
        contract.transfer(to_yocto(100).into(), non_owner());
        assert_almost_eq(env::account_balance(), to_yocto(TEST_INITIAL_BALANCE - 100));
    }

    #[test]
    #[should_panic(expected = "Staking pool is not selected")]
    fn test_staking_pool_is_not_selected() {
        let (mut context, mut contract) = contract_only_setup();
        context.predecessor_account_id = account_owner();
        context.signer_account_id = account_owner();
        context.signer_account_pk = public_key(2).try_into().unwrap();

        let amount = to_yocto(TEST_INITIAL_BALANCE - 100);
        testing_env!(context.clone());
        contract.deposit_to_staking_pool(amount.into());
    }

    #[test]
    fn test_staking_pool_success() {
        let (mut context, mut contract) = contract_only_setup();
        context.predecessor_account_id = account_owner();
        context.signer_account_id = account_owner();
        context.signer_account_pk = public_key(2).try_into().unwrap();

        // Selecting staking pool
        let staking_pool = "staking_pool".to_string();
        testing_env!(context.clone());
        contract.select_staking_pool(staking_pool.clone());

        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(contract.get_staking_pool_account_id(), Some(staking_pool));
        assert_eq!(contract.get_known_deposited_balance().0, 0);
        context.is_view = false;

        // Deposit to the staking_pool
        let amount = to_yocto(TEST_INITIAL_BALANCE - 100);
        context.predecessor_account_id = account_owner();
        testing_env!(context.clone());
        contract.deposit_to_staking_pool(amount.into());
        context.account_balance = env::account_balance();
        assert_eq!(context.account_balance, to_yocto(TEST_INITIAL_BALANCE) - amount);

        context.predecessor_account_id = gfme_account();
        testing_env_with_promise_results(context.clone(), PromiseResult::Successful(vec![]));
        contract.on_staking_pool_deposit(amount.into());
        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(contract.get_known_deposited_balance().0, amount);
        context.is_view = false;

        // Staking on the staking pool
        context.predecessor_account_id = account_owner();
        testing_env!(context.clone());
        contract.stake(amount.into());

        context.predecessor_account_id = gfme_account();
        testing_env_with_promise_results(context.clone(), PromiseResult::Successful(vec![]));
        contract.on_staking_pool_stake(amount.into());

        // Assuming there are 20 NEAR tokens in rewards. Unstaking.
        let unstake_amount = amount + to_yocto(20);
        context.predecessor_account_id = account_owner();
        testing_env!(context.clone());
        contract.unstake(unstake_amount.into());

        context.predecessor_account_id = gfme_account();
        testing_env_with_promise_results(context.clone(), PromiseResult::Successful(vec![]));
        contract.on_staking_pool_unstake(unstake_amount.into());

        // Withdrawing
        context.predecessor_account_id = account_owner();
        testing_env!(context.clone());
        contract.withdraw_from_staking_pool(unstake_amount.into());
        context.account_balance += unstake_amount;

        context.predecessor_account_id = gfme_account();
        testing_env_with_promise_results(context.clone(), PromiseResult::Successful(vec![]));
        contract.on_staking_pool_withdraw(unstake_amount.into());
        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(contract.get_known_deposited_balance().0, 0);
        context.is_view = false;

        // Unselecting staking pool
        context.predecessor_account_id = account_owner();
        testing_env!(context.clone());
        contract.unselect_staking_pool();
        assert_eq!(contract.get_staking_pool_account_id(), None);
    }

    #[test]
    fn test_staking_pool_refresh_balance() {
        let (mut context, mut contract) = contract_only_setup();
        context.predecessor_account_id = account_owner();
        context.signer_account_id = account_owner();
        context.signer_account_pk = public_key(2).try_into().unwrap();

        // Selecting staking pool
        let staking_pool = "staking_pool".to_string();
        testing_env!(context.clone());
        contract.select_staking_pool(staking_pool.clone());

        // Deposit to the staking_pool
        let amount = to_yocto(TEST_INITIAL_BALANCE - 100);
        context.predecessor_account_id = account_owner();
        testing_env!(context.clone());
        contract.deposit_to_staking_pool(amount.into());
        context.account_balance = env::account_balance();
        assert_eq!(context.account_balance, to_yocto(TEST_INITIAL_BALANCE) - amount);

        context.predecessor_account_id = gfme_account();
        testing_env_with_promise_results(context.clone(), PromiseResult::Successful(vec![]));
        contract.on_staking_pool_deposit(amount.into());

        // Staking on the staking pool
        context.predecessor_account_id = account_owner();
        testing_env!(context.clone());
        contract.stake(amount.into());

        context.predecessor_account_id = gfme_account();
        testing_env_with_promise_results(context.clone(), PromiseResult::Successful(vec![]));
        contract.on_staking_pool_stake(amount.into());

        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(contract.get_owners_balance().0, 0);
        assert_eq!(contract.get_liquid_owners_balance().0, 0);
        assert_eq!(contract.get_known_deposited_balance().0, amount);
        context.is_view = false;

        // Assuming there are 20 NEAR tokens in rewards. Refreshing balance.
        let total_balance = amount + to_yocto(20);
        context.predecessor_account_id = account_owner();
        testing_env!(context.clone());
        contract.refresh_staking_pool_balance();

        // In unit tests, the following call ignores the promise value, because it's passed directly.
        context.predecessor_account_id = gfme_account();
        testing_env_with_promise_results(context.clone(), PromiseResult::Successful(vec![]));
        contract.on_get_sp_total_balance(sp_account, total_balance.into());

        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(contract.get_known_deposited_balance().0, total_balance);
        assert_eq!(contract.get_owners_balance().0, to_yocto(20));
        assert_eq!(contract.get_liquid_owners_balance().0, to_yocto(20));
        context.is_view = false;

        // Withdrawing these tokens
        context.predecessor_account_id = account_owner();
        testing_env!(context.clone());
        let transfer_amount = to_yocto(15);
        contract.transfer(transfer_amount.into(), non_owner());
        context.account_balance = env::account_balance();

        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(contract.get_known_deposited_balance().0, total_balance);
        assert_eq!(contract.get_owners_balance().0, to_yocto(5));
        assert_eq!(contract.get_liquid_owners_balance().0, to_yocto(5));
        context.is_view = false;
    }

    #[test]
    #[should_panic(expected = "Staking pool is already selected")]
    fn test_staking_pool_selected_again() {
        let (mut context, mut contract) = contract_only_setup();
        context.predecessor_account_id = account_owner();
        context.signer_account_id = account_owner();
        context.signer_account_pk = public_key(2).try_into().unwrap();

        // Selecting staking pool
        let staking_pool = "staking_pool".to_string();
        testing_env!(context.clone());
        contract.select_staking_pool(staking_pool.clone());

        // Selecting another staking pool
        context.predecessor_account_id = account_owner();
        testing_env!(context.clone());
        contract.select_staking_pool("staking_pool_2".to_string());
    }

    #[test]
    #[should_panic(expected = "Staking pool is not selected")]
    fn test_staking_pool_unselecting_non_selected() {
        let (mut context, mut contract) = contract_only_setup();
        context.predecessor_account_id = account_owner();
        context.signer_account_id = account_owner();
        context.signer_account_pk = public_key(2).try_into().unwrap();

        // Unselecting staking pool
        testing_env!(context.clone());
        contract.unselect_staking_pool();
    }

    #[test]
    fn test_staking_pool_owner_balance() {
        let (mut context, mut contract) = contract_only_setup();
        context.predecessor_account_id = account_owner();
        context.signer_account_id = account_owner();
        context.signer_account_pk = public_key(2).try_into().unwrap();
        context.block_timestamp = to_ts(GENESIS_TIME_IN_DAYS + YEAR + 1);

        let gfme_amount = to_yocto(TEST_INITIAL_BALANCE);
        context.is_view = true;
        testing_env!(context.clone());
        assert_eq!(contract.get_owners_balance().0, gfme_amount);
        context.is_view = false;

        // Selecting staking pool
        let staking_pool = "staking_pool".to_string();
        testing_env!(context.clone());
        contract.select_staking_pool(staking_pool.clone());

        // Deposit to the staking_pool
        let mut total_amount = 0;
        let amount = to_yocto(100);
        for _ in 1..=5 {
            total_amount += amount;
            context.predecessor_account_id = account_owner();
            testing_env!(context.clone());
            contract.deposit_to_staking_pool(amount.into());
            context.account_balance = env::account_balance();
            assert_eq!(context.account_balance, gfme_amount - total_amount);

            context.predecessor_account_id = gfme_account();
            testing_env_with_promise_results(context.clone(), PromiseResult::Successful(vec![]));
            contract.on_staking_pool_deposit(amount.into());
            context.is_view = true;
            testing_env!(context.clone());
            assert_eq!(contract.get_known_deposited_balance().0, total_amount);
            assert_eq!(contract.get_owners_balance().0, gfme_amount);
            assert_eq!(
                contract.get_liquid_owners_balance().0,
                gfme_amount - total_amount - MIN_BALANCE_FOR_STORAGE
            );
            context.is_view = false;
        }

        // Withdrawing from the staking_pool. Plus one extra time as a reward
        let mut total_withdrawn_amount = 0;
        for _ in 1..=6 {
            total_withdrawn_amount += amount;
            context.predecessor_account_id = account_owner();
            testing_env!(context.clone());
            contract.withdraw_from_staking_pool(amount.into());
            context.account_balance += amount;
            assert_eq!(
                context.account_balance,
                gfme_amount - total_amount + total_withdrawn_amount
            );

            context.predecessor_account_id = gfme_account();
            testing_env_with_promise_results(context.clone(), PromiseResult::Successful(vec![]));
            contract.on_staking_pool_withdraw(amount.into());
            context.is_view = true;
            testing_env!(context.clone());
            assert_eq!(
                contract.get_known_deposited_balance().0,
                total_amount.saturating_sub(total_withdrawn_amount)
            );
            assert_eq!(
                contract.get_owners_balance().0,
                gfme_amount + total_withdrawn_amount.saturating_sub(total_amount)
            );
            assert_eq!(
                contract.get_liquid_owners_balance().0,
                gfme_amount - total_amount + total_withdrawn_amount - MIN_BALANCE_FOR_STORAGE
            );
            context.is_view = false;
        }
    }

    */

}

'''
'''--- divpool/src/multi_fun_token.rs ---
//
// MULTI FUN TOKEN [NEP-138](https://github.com/near/NEPs/pull/138)
//

use crate::*;
use near_sdk::{near_bindgen};
use near_sdk::serde::{Deserialize, Serialize};

pub use crate::types::*;
pub use crate::utils::*;

/// one for Each served token
#[derive(Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct SymbolInfo {
    pub symbol: String,     // token symbol
    pub name: String,       // token name
    pub total_supply: Option<U128String>, //total circulating supply
    pub owner_account_id: Option<String>, // owner of this particular token
    pub reference: Option<String>,  // URL to additional resources about the token.
}

//---------INTERACTING CONTRACTS-------------
/// Interface for recipient contract on multi-fungible-token transfers.
#[ext_contract(ext_multifuntok_receiver)]
pub trait ExtMultiFunTokReceiver {
    fn on_multifuntok_transfer(sender_id: AccountId, symbol:String, amount: U128String, memo:String);
}
/// Interface for callback after "on_multifuntok_transfer" to check if the receiving contract executed "on_multifuntok_transfer" ok
#[ext_contract(ext_self_callback)]
pub trait ExtMultiFunTokSelfCallback {
    fn after_multifuntok_transfer(sender_id: AccountId, contract_id: AccountId, symbol:String, amount: U128String);
}

#[near_bindgen]
impl DiversifiedPool {

/// NEP-138 Multiple Fungible Tokens Contract
    
    //---------TOKENS---------------

    /// Creates a new Fungible Token 
    /// Requirements:
    /// * Caller can only by the main owner
    pub fn create_token(&mut self, _symbol_info: SymbolInfo){
        panic!("not implemented");
    }

    /// Deletes a Fungible Token 
    /// Requirements:
    /// * Caller can be the main owner or the token owner
    /// * Symbol.total_supply == 0
    pub fn delete_token(&mut self, _symbol: String){
        panic!("not implemented");
    }

    //---------ACCOUNTS---------------

    // Creates an internal `Account` record. Every account has a balance for each one of the served tokens
    // Account created is for `predecessor_id`
    // Requirements:
    // Caller must attach enough NEAR to cover storage cost at the fixed storage price defined in the contract.
    #[payable]
    pub fn create_account(&mut self){
        self.internal_deposit();
    }

    // deletes an account and transfer all balances to beneficiary_id. beneficiary_id must pre-exists if the account holds skash or G-SKASH
    // Notes: account_to_delete_id is superflous on purpose
    // assert!(`account_to_delete_id`==`predecessor_id`)
    pub fn delete_account(&mut self, account_to_delete_id: AccountId, beneficiary_id: AccountId) {
        assert!(env::predecessor_account_id()==account_to_delete_id, "only {} can delete this account",account_to_delete_id.clone());
        let mut acc = self.internal_get_account(&account_to_delete_id);
        assert!(acc.unstaked==0,"you can't delete the account with {} unstake pending",acc.unstaked);
        assert!(acc.nslp_shares==0,"you can't delete the account with {} NSLP shares",acc.nslp_shares);
        let mut beneficiary_acc = self.internal_get_account(&beneficiary_id);
        if acc.available>0 {
            beneficiary_acc.available+=acc.available;
            acc.available = 0;
        }
        if acc.realized_g_skash>0 {
            beneficiary_acc.realized_g_skash+=acc.realized_g_skash;
            acc.realized_g_skash = 0;
        }
        if acc.stake_shares>0 {
            beneficiary_acc.stake_shares+=acc.stake_shares;
            acc.stake_shares = 0;
        }
        assert!(acc.is_empty(),"inconsistency: account is not empty");
        self.internal_update_account(&account_to_delete_id, &acc);
        self.internal_update_account(&beneficiary_id, &beneficiary_acc);
    }

    /// Transfer `amount` of tok tokens from the caller of the contract (`predecessor_id`) to `receiver_id`.
    /// Requirements:
    /// * receiver_id must pre-exist
    pub fn transfer_to_user(&mut self, receiver_id: AccountId, symbol:String, amount: U128String) {
        self.internal_multifuntok_transfer(&env::predecessor_account_id(), &receiver_id, &symbol, amount.0);
    }

    /// Transfer `amount` of symbol tokens from the caller of the contract (`predecessor_id`) to a contract at `receiver_id`.
    /// Requirements:
    /// * receiver_id must pre-exist
    /// * receiver_id must be a contract and must respond to `on_multifuntok_transfer(sender_id: AccountId, symbol:String, amount: U128, memo:String)`
    /// * if receiver_id is not a contract or `on_multifuntok_transfer` fails, the transfer is rolled-back
    pub fn transfer_to_contract(&mut self, contract_id: AccountId, symbol:String, amount: U128String, memo:String){

        self.internal_multifuntok_transfer(&env::predecessor_account_id(), &contract_id, &symbol, amount.0);

        ext_multifuntok_receiver::on_multifuntok_transfer(
            env::predecessor_account_id(),
            symbol.clone(),
            amount,
            memo,
            //promise params:
            &contract_id, //contract
            0, //attached native NEAR amount
            100_000_000_000_000, //100TGAS
        )
        .then(ext_self_callback::after_multifuntok_transfer(
            env::predecessor_account_id(),
            contract_id,
            symbol.clone(),
            amount,
            //promise params:
            &env::current_account_id(),//contract
            0, //attached native NEAR amount
            30_000_000_000_000, //30TGAS
        ));

    }

    /// After Transfer `amount` of symbol tokens to a contract at `receiver_id`.
    /// Check if the contract completed execution of on_multifuntok_transfer
    /// and undo trasnfer if it failed
    pub fn after_multifuntok_transfer(&mut self, sender_id:AccountId, contract_id: AccountId, symbol:String, amount: U128String){
        if !is_promise_success() {
            //undo transfer
            self.internal_multifuntok_transfer( &contract_id, &sender_id, &symbol, amount.0);
            env::log("transfer to contract failed".as_bytes());
        }
    }

    //---------VIEW METHODS-------------

    /// return the list of all tokens this contract serves
    pub fn get_symbols(&self) -> Vec<SymbolInfo>{
        return vec!(
            SymbolInfo {
                symbol:"NEAR".into(),
                name:"native NEAR".into(),
                total_supply:None,
                owner_account_id:None,
                reference:Some("near.org".into()),
            },
            SymbolInfo {
                symbol:"SKASH".into(),
                name:"div-pool staked near".into(),
                total_supply: Some(self.total_for_staking.into()),
                owner_account_id: Some(env::current_account_id()),
                reference: Some("www.narwallets.com".into()),
            },
            SymbolInfo {
                symbol:"G-SKASH".into(),
                name:"div-pool governance token".into(),
                total_supply: Some(self.total_g_skash.into()),
                owner_account_id: Some(env::current_account_id()),
                reference: Some("www.narwallets.com".into()),
            },
        )
    }

    /// Returns info & total supply of tokens of a symbol
    pub fn get_symbol(&self, symbol:String) -> SymbolInfo {
        let inx:usize = match &symbol as &str {
            "NEAR"=>0, "SKASH"=>1, "G-SKASH"=>2, _=>panic!("invalid symbol")
        };
        return self.get_symbols()[inx].clone();
    }

    /// Checks if account already exists
    pub fn account_exists(&self, account_id:AccountId) -> bool {
        return !self.internal_get_account(&account_id).is_empty();
    }

    /// Returns balance of the `owner_id` account & token.
    pub fn get_funtok_balance(&self, account_id: AccountId, symbol:String) -> U128String {
        let acc = self.internal_get_account(&account_id);
        let amount:u128 = match &symbol as &str {
            "NEAR"=>acc.available ,
            "SKASH"=>self.amount_from_stake_shares(acc.stake_shares), 
            "G-SKASH"=>acc.total_g_skash(self), 
            _=>panic!("invalid symbol")
        };
        return amount.into();
    }

}

'''
'''--- divpool/src/owner.rs ---
use crate::*;
use near_sdk::{near_bindgen, Promise, PublicKey};

#[near_bindgen]
impl DiversifiedPool {
    /// OWNER'S METHOD
    ///
    /// Requires 125 TGas (5 * BASE_GAS)
    ///

    /// OWNER'S METHOD
    ///
    /// Requires 50 TGas (2 * BASE_GAS)
    ///
    /// Adds full access key with the given public key to the account once the contract is empty
    /// (has no accounts)
    pub fn add_full_access_key(&mut self, new_public_key: Base58PublicKey) -> Promise {
        
        self.assert_owner_calling();

        assert!(self.accounts.len() == 0, "contract still has accounts");

        env::log(b"Adding a full access key");

        let new_public_key: PublicKey = new_public_key.into();

        Promise::new(env::current_account_id()).add_full_access_key(new_public_key)
    }

    /// Owner's method.
    /// Pauses pool staking.
    pub fn pause_staking(&mut self) {
        self.assert_owner_calling();
        assert!(!self.staking_paused, "The staking is already paused");
        self.staking_paused = true;
    }

    //---------------------------------
    // staking-pools-list (SPL) management
    //---------------------------------

    /// get the current list of pools
    pub fn get_staking_pool_list(&self) -> Vec<StakingPoolJSONInfo> {
        let mut result = Vec::with_capacity(self.staking_pools.len());
        for elem in self.staking_pools.iter(){
            result.push(StakingPoolJSONInfo{
                account_id: elem.account_id.clone(),
                weight_basis_points: elem.weight_basis_points,
                staked: elem.staked.into(),
                unstaked: elem.unstaked.into(),
                last_asked_rewards_epoch_height: elem.last_asked_rewards_epoch_height.into(),
                unstaked_requested_epoch_height: elem.unstk_req_epoch_height.into(),
            })
        }
        return result;
    }

    ///remove staking pool from list *if it's empty*
    pub fn remove_staking_pool(&mut self, inx:u16 ){

        self.assert_owner_calling();

        let sp = &self.staking_pools[inx as usize];
        if !sp.is_empty() {
            panic!(b"sp is not empty")
        }
        self.staking_pools.remove(inx as usize);
    }

    ///update existing weight_basis_points
    pub fn set_staking_pool_weight(&mut self, inx:u16, weight_basis_points:u16 ){

        self.assert_owner_calling();

        let sp = &mut self.staking_pools[inx as usize];
        if sp.busy_lock {
            panic!(b"sp is busy")
        }
        sp.weight_basis_points = weight_basis_points;
        self.check_staking_pool_list_consistency();
    }
    
    ///add a new staking pool or update existing weight_basis_points
    pub fn set_staking_pool(&mut self, account_id:AccountId, weight_basis_points:u16 ){

        self.assert_owner_calling();

        //search the pools
        for sp_inx in 0..self.staking_pools.len() {
            if self.staking_pools[sp_inx].account_id==account_id {
                //found, set weight_basis_points
                self.set_staking_pool_weight(sp_inx as u16, weight_basis_points);
                return;
            }
        }
        //not found, it's a new pool
        self.staking_pools.push(  StakingPoolInfo::new(account_id, weight_basis_points) );
        self.check_staking_pool_list_consistency();
    }

    fn check_staking_pool_list_consistency(&self) {
        assert!(self.sum_staking_pool_list_weight_basis_points()<=10000,"sum(staking_pools.weight) can not be GT 100%");
    }

    pub fn sum_staking_pool_list_weight_basis_points(&self) -> u16 {
        let mut total_weight: u16 = 0;
        for sp in self.staking_pools.iter() {
            total_weight+=sp.weight_basis_points;
        }
        return total_weight;
    }

    //--------------------------------------------------
    /// computes unstaking delay on current situation
    pub fn compute_current_unstaking_delay(&self, amount:U128String) -> u16 {
        return self.internal_compute_current_unstaking_delay(amount.0) as u16;
    }

}

'''
'''--- divpool/src/types.rs ---
use near_sdk::json_types::{U128, U64};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{AccountId};
use uint::construct_uint;

/// useful constants
pub const NO_DEPOSIT: u128 = 0;
pub const ONE_NEAR: u128 = 1_000_000_000_000_000_000_000_000;
pub const ONE_NEAR_CENT: u128 = ONE_NEAR/100;
pub const TWO_NEAR: u128 = 2 * ONE_NEAR;
pub const FIVE_NEAR: u128 = 5 * ONE_NEAR;
pub const TEN_NEAR: u128 = 10 * ONE_NEAR;
pub const NEAR_1K: u128 = 1_000 * ONE_NEAR;
pub const NEARS_PER_BATCH: u128 = 10*NEAR_1K; // if amount>MAX_NEARS_SINGLE_MOVEMENT then it's splited in NEARS_PER_BATCH batches
pub const MAX_NEARS_SINGLE_MOVEMENT: u128 = NEARS_PER_BATCH + NEARS_PER_BATCH/2; //150K max movement, if you try to stake 151K, it will be split into 2 movs, 100K and 51K

pub const NUM_EPOCHS_TO_UNLOCK: EpochHeight = 4; //0 for testing in guidlnet, 4 for mainnet & testnet;

/// The contract keeps at least 35 NEAR in the account to avoid being transferred out to cover
/// contract code storage and some internal state.
pub const MIN_BALANCE_FOR_STORAGE: u128 = 35_000_000_000_000_000_000_000_000;
/// if the remainder falls below this amount, it's included in the current movement
pub const MIN_STAKE_UNSTAKE_AMOUNT_MOVEMENT: u128 = 5*NEAR_1K;

//cut on swap fees
pub const DEFAULT_TREASURY_SWAP_CUT_BASIS_POINTS : u16 = 2500; // 25% swap fees go to Treasury
pub const DEFAULT_OPERATOR_SWAP_CUT_BASIS_POINTS : u16 = 300; // 3% swap fees go to operator
//Fee on staking rewards
pub const DEFAULT_OPERATOR_REWARDS_FEE_BASIS_POINTS : u16 = 50; // 0.5% -- CANT BE HIGER THAN 1000 / 10%

//Note: Licence forbids you to change the following 3 constants and/or the developer's distribution mechanism
pub const DEVELOPERS_ACCOUNT_ID: &str = "developers.near"; 
pub const DEVELOPERS_REWARDS_FEE_BASIS_POINTS: u16 = 20; // 0.2% from rewards 
pub const DEVELOPERS_SWAP_CUT_BASIS_POINTS : u16 = 200; // 2% swap fees go to authors

construct_uint! {
    /// 256-bit unsigned integer.
    pub struct U256(4);
}

/// Raw type for duration in nanoseconds
pub type Duration = u64;
/// Raw type for timestamp in nanoseconds or Unix Ts in miliseconds
pub type Timestamp = u64;

/// Balance wrapped into a struct for JSON serialization as a string.
pub type U128String = U128;
pub type U64String = U64;

pub type EpochHeight = u64;

/// Hash of Vesting schedule.
pub type Hash = Vec<u8>;

/// NEP-129 get information about this contract
/// returns JSON string according to [NEP-129](https://github.com/nearprotocol/NEPs/pull/129)
/// Rewards fee fraction structure for the staking pool contract.
#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
#[allow(non_snake_case)]
pub struct NEP129Response {
    pub dataVersion:u16,
    pub name:String,
    pub version:String,
    pub source:String,
    pub standards:Vec<String>,
    pub webAppUrl:Option<String>,
    pub developersAccountId:String,
    pub auditorAccountId:Option<String>,
}

/// Rewards fee fraction structure for the staking pool contract.
#[derive(Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct RewardFeeFraction {
    pub numerator: u32,
    pub denominator: u32,
}

/// staking-pool trait
/// Represents an account structure readable by humans.
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct HumanReadableAccount {
    pub account_id: AccountId,
    /// The unstaked balance that can be withdrawn or staked.
    pub unstaked_balance: U128,
    /// The amount balance staked at the current "stake" share price.
    pub staked_balance: U128,
    /// Whether the unstaked balance is available for withdrawal now.
    pub can_withdraw: bool,
}

/// Struct returned from get_account_info
/// div-pool full info
/// Represents account data as as JSON compatible struct
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct GetAccountInfoResult {
    pub account_id: AccountId,
    /// The available balance that can be withdrawn
    pub available: U128,
    /// The amount of SKASH owned (computed from the shares owned)
    pub skash: U128,
    /// The amount unstaked waiting for withdraw
    pub unstaked: U128,

    /// The epoch height when the unstaked will be available
    pub unstaked_requested_unlock_epoch: U64,
    ///if env::epoch_height()>=unstaked_requested_unlock_epoch
    pub can_withdraw: bool,
    
    /// total amount the user holds in this contract: account.available + account.staked + current_rewards + account.unstaked
    pub total: U128,

    //-- STATISTICAL DATA --
    // User's statistical data
    // These fields works as a car's "trip meter". The user can reset them to zero.
    /// trip_start: (unix timpestamp) this field is set at account creation, so it will start metering rewards
    pub trip_start: U64,
    /// How many skashs the user had at "trip_start". 
    pub trip_start_skash: U128,
    /// how much the user staked since trip start. always incremented
    pub trip_accum_stakes: U128,
    /// how much the user unstaked since trip start. always incremented
    pub trip_accum_unstakes: U128,
    /// to compute trip_rewards we start from current_skash, undo unstakes, undo stakes and finally subtract trip_start_skash
    /// trip_rewards = current_skash + trip_accum_unstakes - trip_accum_stakes - trip_start_skash;
    /// trip_rewards = current_skash + trip_accum_unstakes - trip_accum_stakes - trip_start_skash;
    pub trip_rewards: U128,

    //NLSP
    pub nslp_shares: U128,
    pub nslp_share_value: U128,

    //G-SKASH owned (including pending rewards)
    pub g_skash: U128,

}

/// Struct returned from get_contract_state
/// div-pool state info
/// Represents contact state as as JSON compatible struct
#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct GetContractStateResult {
    /// This amount increments with deposits and decrements when users stake
    /// increments with complete_unstake and decrements with user withdrawals from the contract
    /// withdrawals from the pools can include rewards
    /// since staking is delayed and in batches it only eventually matches env::balance()
    pub total_available: U128,

    /// The total amount of tokens selected for staking by the users 
    /// not necessarily what's actually staked since staking can is done in batches
    /// Share price is computed using this number. share_price = total_for_staking/total_shares
    pub total_for_staking: U128,

    /// The total amount of tokens actually staked (the tokens are in the staking pools)
    /// During heartbeat(), If !staking_paused && total_for_staking<total_actually_staked, then the difference gets unstaked in 100kN batches
    pub total_actually_staked: U128,

    // how many "shares" were minted. Everytime someone "stakes" he "buys pool shares" with the staked amount
    // the share price is computed so if he "sells" the shares on that moment he recovers the same near amount
    // staking produces rewards, so share_price = total_for_staking/total_shares
    // when someone "unstakes" she "burns" X shares at current price to recoup Y near
    pub total_stake_shares: U128,

    /// The total amount of tokens actually unstaked (the tokens are in the staking pools)
    /// During distribute(), If !staking_paused && total_for_unstaking<total_actually_unstaked, then the difference gets unstaked in 100kN batches
    pub total_unstaked_and_waiting: U128,

    /// The total amount of tokens actually unstaked AND retrieved from the pools (the tokens are here)
    /// During distribute(), If sp.pending_withdrawal && sp.epoch_for_withdraw == env::epoch_height then all funds are retrieved from the sp
    /// When the funds are actually withdraw by the users, total_actually_unstaked is decremented
    pub total_actually_unstaked_and_retrieved: U128,

    /// total g-skash minted
    pub total_g_skash: U128, 

    /// the staking pools will add rewards to the staked amount on each epoch
    /// here we store the accumulatred amount only for stats purposes. This amount can only grow
    pub accumulated_staked_rewards: U128, 

    /// How much NEAR is available to immediate unstake (sell SKASH)
    pub nslp_liquidity: U128,
    /// Current discount for immediate unstake (sell SKASH)
    pub nslp_current_discount_basis_points: u16,

    //how many accounts there are
    pub accounts_count: U64,

    //count of pools to diversify in
    pub staking_pools_count: u16, 

}

/// Struct returned from get_contract_params
/// div-pool parameters info
/// Represents contact parameters as JSON compatible struct
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct ContractParamsJSON {

    /// no auto-staking. true while changing staking pools
    pub staking_paused: bool, 

    /// adjustable min account available balance (to backup storage)
    pub min_account_balance: U128String,

    ///NEAR/SKASH Liquidity pool target
    pub nslp_near_target: U128String,
    ///NEAR/SKASH Liquidity pool max fee
    pub nslp_max_discount_basis_points: u16, //10%
    ///NEAR/SKASH Liquidity pool min fee
    pub nslp_min_discount_basis_points: u16, //0.1%

    //The next 3 values define g-skash rewards multiplers %. (100 => 1x, 200 => 2x, ...)
    ///for each SKASH paid staking reward, reward SKASH holders with g-SKASH. default:5x. reward G-SKASH = rewards * mult_pct / 100
    pub staker_g_skash_mult_pct: u16,
    ///for each SKASH paid as discount, reward SKASH sellers with g-SKASH. default:1x. reward G-SKASH = discounted * mult_pct / 100
    pub skash_sell_g_skash_mult_pct: u16,
    ///for each SKASH paid as discount, reward SKASH sellers with g-SKASH. default:20x. reward G-SKASH = fee * mult_pct / 100
    pub lp_provider_g_skash_mult_pct: u16,

    /// operator_fee_basis_points. 100 basis point => 1%. E.g.: owner_fee_basis_points=50 => 0.5% owner's fee
    pub operator_rewards_fee_basis_points: u16,
    /// operator_cut_basis_points. 
    pub operator_swap_cut_basis_points: u16,
    /// treasury_cut_basis_points. 
    pub treasury_swap_cut_basis_points: u16,
    
}

// get_staking_pools_list returns StakingPoolJSONInfo[]
#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct StakingPoolJSONInfo {
    pub account_id: String,
    pub weight_basis_points: u16,
    pub staked: U128String,
    pub unstaked: U128String,
    pub unstaked_requested_epoch_height: U64String, 
    //EpochHeight where we asked the sp what were our staking rewards
    pub last_asked_rewards_epoch_height: U64String,
}

'''
'''--- divpool/src/utils.rs ---
use near_sdk::{env, PromiseResult};
pub use crate::types::*;

pub fn assert_min_balance(amount:u128){
    assert!(amount > 0, "Amount should be positive");
    assert!(
        env::account_balance() >= MIN_BALANCE_FOR_STORAGE && env::account_balance() - MIN_BALANCE_FOR_STORAGE > amount,
        "The contract account balance can't go lower than MIN_BALANCE"
    );
}

pub fn assert_callback_calling() {
    assert_eq!(env::predecessor_account_id(), env::current_account_id());
}

pub fn is_promise_success() -> bool {
    assert_eq!(
        env::promise_results_count(),
        1,
        "Contract expected a result on the callback"
    );
    match env::promise_result(0) {
        PromiseResult::Successful(_) => true,
        _ => false,
    }
}

pub fn apply_pct(basis_points:u16, amount:u128) -> u128 {
    return (U256::from(basis_points) * U256::from(amount) / U256::from(10_000)).as_u128() ;
}
pub fn apply_multiplier(amount:u128, basis_points:u16) -> u128 {
    return (U256::from(amount) * U256::from(basis_points) / U256::from(100)).as_u128() ;
}

//-- SHARES COMPUTATIONS

/// returns amount * numerator/denominator
pub fn proportional(amount:u128, numerator:u128, denominator:u128) -> u128{
    return (U256::from(amount) * U256::from(numerator) / U256::from(denominator)).as_u128();
}

/// Returns the number of shares corresponding to the given near amount at current share_price
/// if the amount & the shares are incorporated, price remains the same
//
// price = total_amount / total_shares
// Price is fixed
// (total_amount + amount) / (total_shares + num_shares) = total_amount / total_shares
// (total_amount + amount) * total_shares = total_amount * (total_shares + num_shares)
// amount * total_shares = total_amount * num_shares
// num_shares = amount * total_shares / total_amount
pub fn shares_from_amount(amount: u128, total_amount:u128, total_shares:u128 ) -> u128 
{
    if total_shares==0 { //first person getting shares
        return amount;
    }
    if amount==0||total_amount==0 {
        return 0;
    }
    return proportional(total_shares, amount,total_amount);
}

/// Returns the amount corresponding to the given number of shares at current share_price
// price = total_amount / total_shares
// amount = num_shares * price
// amount = num_shares * total_amount / total_shares
pub fn amount_from_shares(num_shares: u128, total_amount:u128, total_shares:u128 ) -> u128 
{
    if total_shares == 0 || num_shares==0 {
        return 0;
    };
    return proportional(num_shares, total_amount,total_shares);
}

'''
'''--- divpool/tests/simulation.rs ---
#![allow(unused_imports)]
#![allow(unused_variables)]
#![allow(dead_code)]
use near_sdk::{
  borsh::{self, BorshDeserialize, BorshSerialize},
  json_types::{U128, Base58PublicKey},
  serde::{Deserialize, Serialize},
  serde_json::json,
  serde_json::Value,
  *,
};
use near_sdk_sim::{
  account::AccessKey, call, deploy, init_simulator, 
  near_crypto::{Signer,SecretKey, KeyType},
  to_yocto, view,
  ContractAccount, ExecutionResult, UserAccount, DEFAULT_GAS, STORAGE_AMOUNT,
  ViewResult
};

// //Note: the struct xxxxxxContract is created by #[near_bindgen] (near_skd_rs~2.0.4)
use divpool::*;

// Load contracts' bytes.
near_sdk_sim::lazy_static! {
  static ref WASM_BYTES_DIV_POOL: &'static [u8] = include_bytes!("../../res/divpool.wasm").as_ref();
  static ref WASM_BYTES_SP: &'static [u8] = include_bytes!("../../res/staking_pool.wasm").as_ref();
  static ref WASM_BYTES_GET_EPOCH: &'static [u8] = include_bytes!("../../res/get_epoch_contract.wasm").as_ref();
}

const TGAS: u64 = 1_000_000_000_000;
const NEAR: u128 = 1_000_000_000_000_000_000_000_000;
const E24: u128 = NEAR;

const SP_INITIAL_BALANCE:u128 = 100*NEAR;

/// Deploy the contract(s) and create some divpool accounts. Returns:
/// - The divpool Contract
/// - Root Account
/// - Testnet Account (utility suffix for building other addresses)
/// - A deployer account address
fn init_simulator_and_contract(
  initial_balance: u128,
  deploy_to: &str,
) -> (
  ContractAccount<DiversifiedPoolContract>,
  UserAccount, // root
  UserAccount, // testnet suffix
  UserAccount, // deployer account
  UserAccount,
  UserAccount
) {
  // Root account has address: "root"
  let master_account = init_simulator(None);

  // Other accounts may be created from the root account
  // Note: address naming is fully expressive: we may create any suffix we desire, ie testnet, near, etc.
  // but only those two (.testnet, .near) will be used in practice.
  let testnet = master_account.create_user("testnet".to_string(), ntoy(1_000_000_000));

  // We need an account to deploy the contracts from. We may create subaccounts of "testnet" as follows:
  let owner = testnet.create_user(deploy_to.to_string(), ntoy(1_000_000));

  let treasury = testnet.create_user("treasury".to_string(), ntoy(1_000_000));
  let operator = testnet.create_user("operator".to_string(), ntoy(1_000_000));

  let divpool_contract = deploy!(
      contract: DiversifiedPoolContract,
      contract_id: "divpool",
      bytes: &WASM_BYTES_DIV_POOL,
      // User deploying the contract
      signer_account: owner,
      // DiversifiedPool.new(
        //   owner_account_id: AccountId,
        //   treasury_account_id: AccountId,
        //   operator_account_id: AccountId,
      deposit:500*NEAR,
      gas:25*TGAS,
      init_method:new(owner.account_id(), treasury.account_id(), operator.account_id())
      );

  return (divpool_contract, master_account, testnet, owner, treasury, operator)
}

//----------------------
fn view(contract_account: &UserAccount, method:&str, args_json:&str) -> Value {
    let pct = PendingContractTx {
      receiver_id: contract_account.account_id(),
      method: method.into(),
      args: args_json.into(),
      is_view:true,
    };
    let vr = &contract_account.view(pct);
    //println!("view Result: {:#?}", vr.unwrap_json_value());
    return vr.unwrap_json_value();
}
fn as_u128(v:&Value) -> u128 {
  return match v.as_str() {
    Some(x) => {
      //println!("{}",x); 
      x.parse::<u128>().unwrap()
    },
    _ => panic!("invalid u128 value {:#?}", v)
  };
}
fn view_u128 (contract_account: &UserAccount, method:&str, args_json:&str) -> u128 {
  let result = view(contract_account,method,args_json);
  return as_u128(&result)
}

//----------------------
fn call(who: &UserAccount, contract_account: &UserAccount, method:&str, args_json:&str, attached_deposit:u128, gas:u64) -> ExecutionResult {
  let pct = PendingContractTx {
    receiver_id: contract_account.account_id(),
    method: method.into(),
    args: args_json.into(),
    is_view:false,
  };
  let exec_res = who.call(pct,attached_deposit,gas);
  //println!("Result: {:#?}", exec_res);
  return exec_res;
}

//-----------------------
fn deploy_simulated_staking_pool(
    master_account: &UserAccount,
    deploy_to_acc_id: &str,
    owner_account_id: &str,
) 
  -> UserAccount 
{
  let sp = master_account.deploy(&WASM_BYTES_SP, deploy_to_acc_id.into(), SP_INITIAL_BALANCE);
  let user_txn = master_account
    .create_transaction(sp.account_id())
    .function_call(
      "new".into(), 
      format!(r#"{{"owner_id":"{}", "stake_public_key":"Di8H4S8HSwSdwGABTGfKcxf1HaVzWSUKVH1mYQgwHCWb","reward_fee_fraction":{{"numerator":5,"denominator":100}}}}"#,
        owner_account_id
        ).into(),//arguments: Vec<u8>,
      50*TGAS, 0);
  let res = user_txn.submit();
  //print_helper(res);
  return sp;
}

/// Helper to log ExecutionResult outcome of a call/view
fn print_helper(res: &ExecutionResult) {
  println!("Result: {:#?}", res);
  assert!(res.is_ok());
}
fn print_helper_promise(res: &ExecutionResult) {
  println!("Result: {:#?}", res);
  //println!("Receipt results: {:#?}", res.get_receipt_results());
  println!("Promise results: {:#?}", res.promise_results());
  assert!(res.is_ok());
}
/// Helper to log ExecutionResult outcome of a call/view
fn print_helper_profile(res: &ExecutionResult) {
  println!("Promise results: {:#?}", res.promise_results());
  //println!("Receipt results: {:#?}", res.get_receipt_results());
  println!("Profiling: {:#?}", res.profile_data());
  //println!("Result: {:#?}", res);
  assert!(res.is_ok());
}

 fn print_vecu8(title:&str, v:&Vec<u8>){
  println!("{}:{}", title,
   match std::str::from_utf8(v) {
     Ok(v) => v,
     Err(e) => "[[can't decode result, invalid UFT8 sequence]]"
   })
 }

fn ntoy(near:u64) -> u128 { to_yocto(&near.to_string()) }

fn yton(yoctos:u128) -> String { 
  let mut str = yoctos.to_string();
  let dec = str.split_off(str.len()-24);
  return [&str,".",&dec].concat();
}

struct Simulation {
  pub divpool: ContractAccount<DiversifiedPoolContract>,
  pub master_account:UserAccount, // root
  pub testnet:UserAccount, // testnet suffix
  pub owner:UserAccount, // deployer account
  pub treasury:UserAccount,
  pub operator:UserAccount,
  pub sp: Vec<UserAccount> //Staking pools
}

//-----------------------------
//-----------------------------
//-----------------------------
impl Simulation {

  pub fn new() -> Self {

    // Root account has address: "root"
    let master_account = init_simulator(None);
    // Other accounts may be created from the root account
    // Note: address naming is fully expressive: we may create any suffix we desire, ie testnet, near, etc.
    // but only those two (.testnet, .near) will be used in practice.
    let testnet = master_account.create_user("testnet".into(), ntoy(1_000_000_000));
    // We need an account to deploy the contracts from. We may create subaccounts of "testnet" as follows:
    let owner = testnet.create_user("contract-owner".into(), ntoy(1_000_000));
    let treasury = testnet.create_user("treasury".into(), ntoy(1_000_000));
    let operator = testnet.create_user("operator".into(), ntoy(1_000_000));

    //create acc, deploy & init the main contract
    let divpool = deploy!(
      contract: DiversifiedPoolContract,
      contract_id: "divpool",
      bytes: &WASM_BYTES_DIV_POOL,
      // User deploying the contract
      signer_account: &owner,
      // DiversifiedPool.new(
        //   owner_account_id: AccountId,
        //   treasury_account_id: AccountId,
        //   operator_account_id: AccountId,
      deposit:500*NEAR,
      gas:25*TGAS,
      init_method:new(owner.account_id(), treasury.account_id(), operator.account_id())
      );

    //deploy all the staking pools
    let mut sp = Vec::with_capacity(4);
    for n in 0..=3 {
      let sp_contract =deploy_simulated_staking_pool(&master_account, &format!("sp{}",n), &owner.account_id());
      call(&owner,&sp_contract,"pause_staking","{}",0,10*TGAS);
      sp.push( sp_contract );
    }

    return Self {

      master_account,

      testnet,
      owner,
      treasury,
      operator,

      divpool,

      sp,

    }

  }

  pub fn sp_balance(&self, n:usize) -> u128 { self.sp[n].amount()+self.sp[n].locked() }
  
  pub fn show_sp_balance(&self, n:usize) { 
      let total = self.sp_balance(n);
      let staked =  view_u128(&self.sp[n],"get_total_staked_balance","{}");
      println!("sp{} amount: {}, staked:{}+unstk:{}", n, total, staked, total - staked ); 
  }

  pub fn show_sps_balance(&self){
    println!("--SPs balance");
    for n in 0..=3 { self.show_sp_balance(n) }
    println!("--------------");
  }

  //----------------
  fn show_account_info(&self, acc:&str) -> Value {
    let divpool = &self.divpool;
    let result = view!(divpool.get_account_info(acc.into()));
    print_vecu8(acc,&result.unwrap());
    //println!("Result: {:#?}", result.unwrap_json_value());
    return serde_json::from_str(std::str::from_utf8(&result.unwrap()).unwrap()).unwrap();
  }

}

pub fn show_balance(ua:&UserAccount) { println!("@{} balance: staked:{} unstk:{}", ua.account_id(), ua.locked(),ua.amount() ); }

// #[test]
// fn sim_bug() {
//     let master_account = init_simulator(None);
//     let testnet = master_account.create_user("testnet".into(), ntoy(1_000_000_000));

//     let test_staker = testnet.create_user("staker".to_string(), ntoy(500_000));
//     show_balance(&test_staker);
    
//     let get_epoch_acc = master_account.deploy(&WASM_BYTES_GET_EPOCH, String::from("get_epoch_acc"), SP_INITIAL_BALANCE);
//     let user_txn = master_account
//       .create_transaction(get_epoch_acc.account_id())
//         .function_call(
//           "new".into(), 
//           "{}".into(),
//           50*TGAS, 0)
//         .submit();

//     println!("epoch {}",view(&get_epoch_acc,"get_epoch_height","{}"));

//     let sk = SecretKey::from_seed(KeyType::ED25519, "test");
  
//     //stake => 10K
//     test_staker
//       .create_transaction(test_staker.account_id())
//       .stake(ntoy(10_000),  sk.public_key())
//       .submit();
  
//     show_balance(&test_staker);
//     assert!(test_staker.locked() == ntoy(10_000));
  
//     //stake => 15K
//     test_staker
//       .create_transaction(test_staker.account_id())
//       .stake(ntoy(15_000),  sk.public_key())
//       .submit();
  
//       show_balance(&test_staker);
//       assert!(test_staker.locked() == ntoy(15_000));
    
//     println!("epoch {}",view(&get_epoch_acc,"get_epoch_height","{}"));
      
//     //stake => down to 7K
//     test_staker
//       .create_transaction(test_staker.account_id())
//       .stake(ntoy(7_000),  sk.public_key())
//       .submit();
  
//     show_balance(&test_staker);

//     println!("epoch {}",view(&get_epoch_acc,"get_epoch_height","{}"));

//     //do it 15 times
//     //in the sim => 3 blocks make and epoch
//     for n in 0..5 {
//       call(&test_staker,&get_epoch_acc,"set_i32", &format!(r#"{{"num":{}}}"#,n),0,10*TGAS);
//       println!("epoch {}",view(&get_epoch_acc,"get_epoch_height","{}"));
//     }

//     show_balance(&test_staker);

//     //stake => down to 7K
//     test_staker
//       .create_transaction(test_staker.account_id())
//       .stake(ntoy(7_000),  sk.public_key())
//       .submit();

//     assert!(test_staker.locked() == ntoy(7_000));
// }

#[test]
fn simtest() {
  
  let sim = Simulation::new();

  let divpool = &sim.divpool;

  let view_results = view!(divpool.get_contract_info());
  print_vecu8("contract_info",&view_results.unwrap());

  //Example transfer to account
  // let transaction = master_account
  //   .create_transaction("sp1".to_string());  
    //["sp1",".", &divpool_contract.user_account.account_id()].concat());
  //let res = transaction.transfer(ntoy(1)).submit();
  //print_helper(res);

  //test sp1 exists
  //println!("sp0 owner {}",view_call(&sim.sp[0], "get_owner_id", "{}"));

  // test yton & ntoy
  // println!("test: {}", yton(1*NEAR));
  // println!("test: {}", yton(10*NEAR));
  // println!("test: {}", yton(123*NEAR));
  // println!("test: {}", yton(ntoy(1)));
  // println!("test: {}", yton(ntoy(10)));
  // println!("test: {}", yton(ntoy(123)));

  //println!("treasury amount: {}", sim.treasury.amount());

  //---- register staking pools in the divpool contract
  let weight_basis_points_vec = vec!(15,40,25,20);
  for n in 0..sim.sp.len() {
    call!(sim.owner, divpool.set_staking_pool(sim.sp[n].account_id(),weight_basis_points_vec[n]*100), gas=25*TGAS);
  }
  let total_w_bp = view!(divpool.sum_staking_pool_list_weight_basis_points());
  assert!(total_w_bp.unwrap_json_value() == 10000);

  //---- alice
  //---- deposit & buy skash
  let alice = sim.testnet.create_user("alice".to_string(), ntoy(500_000));
  let alice_dep_and_stake = ntoy(100_000);
  let ads_res = call!(alice,divpool.deposit_and_stake(), alice_dep_and_stake, 50*TGAS);
  //print_helper(&ads_res);
  assert!(divpool.user_account.amount()>=alice_dep_and_stake);

  //---- bob
  let bob = sim.testnet.create_user("bob".to_string(), ntoy(500_000));
  let bob_dep_and_stake = ntoy(200_000);
  let bds_res = call!(bob,divpool.deposit_and_stake(), bob_dep_and_stake, 50*TGAS);

  //---- carol
  let carol = sim.testnet.create_user("carol".to_string(), ntoy(500_000));
  let carol_deposit = ntoy(250_000);
  let cd_res = call!(carol,divpool.deposit(), carol_deposit, 50*TGAS);
  println!("----------------------------------");
  println!("------- carol adds liquidiy --");
  let cal_res = call!(carol,divpool.nslp_add_liquidity(U128::from(carol_deposit)), gas=50*TGAS);

  //contract state
  let view_results = view!(divpool.get_contract_state());
  print_vecu8("contract_state",&view_results.unwrap());

  //---- test distribute_staking
  sim.show_sps_balance();
  println!("----------------------------------");
  println!("------- test distribute_staking --");
  for n in 0..4 {
    println!("------- call #{} to distribute_staking",n);
    let dres = call!(sim.operator, divpool.distribute_staking(), gas=125*TGAS );
    //print_helper_profile(&dres);
    sim.show_sps_balance();
  }
  
  //check the staking was distributed according to weight
  let total_staked = alice_dep_and_stake + bob_dep_and_stake;
  for n in 0..sim.sp.len() {
    let expected:u128 = SP_INITIAL_BALANCE + total_staked * weight_basis_points_vec[n] as u128 / 100;
    assert!( &sim.sp_balance(n) == &expected,
      "total_for_staking:{}, sp{} balance = {}, wbp:{}, !== expected:{}", alice_dep_and_stake, n, &sim.sp_balance(n), weight_basis_points_vec[n], expected);
  }

  //test unstake
  // let unstkres = view(&sim.sp[0],"unstake_all","{}",0,50*TGAS);
  // print_helper_promise(&unstkres);
  // sim.show_sps_balance();

  //----------------------------------------------------------
  sim.show_account_info(&alice.account_id());

  //----------------------------------------------------------
  println!("----------------------------------");
  println!("------- alice unstakes --");
  let alice_unstaking = ntoy(6_000);
  let ads_res = call!(alice,divpool.unstake(U128::from(alice_unstaking)), gas=50*TGAS);
  print_helper(&ads_res);

  //----------------------------------------------------------
  sim.show_account_info(&alice.account_id());

  //----------------------------------------------------------
  //---- test distribute_unstaking
  println!("----------------------------------");
  println!("------- test distribute_unstaking --");
  for n in 0..20 {
    println!("------- call #{} to distribute_unstaking",n);
    let dres = call!(sim.operator, divpool.distribute_unstaking(), gas=125*TGAS );
    print_helper_profile(&dres);
    sim.show_sps_balance();
    if &dres.unwrap_json_value()==false { break };
  }

  //deploy a contract to get the current epoch
  let get_epoch_acc = sim.master_account.deploy(&WASM_BYTES_GET_EPOCH, String::from("get_epoch_acc"), SP_INITIAL_BALANCE);
  let user_txn = sim.master_account
    .create_transaction(get_epoch_acc.account_id())
      .function_call(
        "new".into(), 
        "{}".into(),
        50*TGAS, 0)
      .submit();

  //----------------------------------------------------------
  //---- test retrieve unstaked funds
  println!("----------------------------------");
  println!("------- test retrieve funds from the pools --");
  for n in 0..30 {
    
    println!("epoch {}",view(&get_epoch_acc,"get_epoch_height","{}"));

    println!("------- call #{} to get_staking_pool_requiring_retrieve()",n);
    let dres = view!(divpool.get_staking_pool_requiring_retrieve());
    let inx = dres.unwrap_json_value().as_i64().unwrap();
    println!("------- result {}",inx);

    if inx>=0 {
      println!("------- pool #{} requires retrieve",inx);
      sim.show_sps_balance();
      let dres2 = call!(sim.operator, divpool.retrieve_funds_from_a_pool(inx as u16), gas=125*TGAS );
      print_helper_promise(&dres2);
    }
    else if inx==-3 { //no more funds unstaked
      break;
    }

    //make a dummy txn to advance the epoch
    call(&sim.owner, &get_epoch_acc,"set_i32",&format!(r#"{{"num":{}}}"#,inx).to_string(),0,10*TGAS);
  }

  //----------------------------------------------------------
  {
    println!("----------------------------------");
    println!("------- alice completes unstaking: withdraws --");
    let previous = alice.amount();
    let ads_res = call!(alice,divpool.withdraw(U128::from(alice_unstaking)), gas=50*TGAS);
    print_helper(&ads_res);
    assert!(alice.amount()==previous+alice_unstaking,"withdraw failed {} {} {}",alice.amount(),previous,alice_unstaking);
  }

  //----------------------------------------------------------
  {
    println!("----------------------------------");
    println!("------- bob sells skash (immediate unstake)");

    sim.show_account_info(&bob.account_id());
    sim.show_account_info(&carol.account_id());
    sim.show_account_info(NSLP_INTERNAL_ACCOUNT);
    let vr1 = view!(divpool.get_contract_state());
    print_vecu8("contract_state",&vr1.unwrap());
    let vr2 = view!(divpool.get_contract_params());
    print_vecu8("contract_params",&vr2.unwrap());
    

    let previous = bob.amount();
    const TO_SELL:u128 = 20_000*NEAR;
    const MIN_REQUESTED:u128 = 19_300*NEAR; //7% discount
    
    let dbp = view!(divpool.nslp_get_discount_basis_points(TO_SELL.into()));
    print_vecu8("divpool.nslp_get_discount_basis_points",&dbp.unwrap());

    let bss_res = call!(bob,divpool.sell_skash(U128::from(ntoy(20_000)),U128::from(MIN_REQUESTED)), gas=100*TGAS);
    print_helper(&bss_res);
    let received = as_u128(&bss_res.unwrap_json_value());
    assert!(received >= MIN_REQUESTED,"sell skash failed {} {}",MIN_REQUESTED,received);

    let bob_info = sim.show_account_info(&bob.account_id());
    let carol_info =sim.show_account_info(&carol.account_id());
    let nslp_info = sim.show_account_info(NSLP_INTERNAL_ACCOUNT);

    assert!(as_u128(&bob_info["g_skash"]) == 668*E24);
    assert!(as_u128(&carol_info["g_skash"]) == 9_352*E24);
    
  }

  //----------------------------------------------------------
  {
    println!("----------------------------------");
    const AMOUNT:u128 = 100_000*NEAR;
    println!("------- carol removes liquidity");
    let res = call!(carol,divpool.nslp_remove_liquidity(U128::from(AMOUNT)), gas=100*TGAS);
    print_helper(&res);
    let carol_info =sim.show_account_info(&carol.account_id());
    assert!(as_u128(&carol_info["total"]) == AMOUNT);
  }

}

'''
'''--- divpool/tests/test_utils.rs ---
#![allow(unused_imports)]
#![allow(unused_variables)]
#![allow(dead_code)]
use near_sdk::json_types::Base58PublicKey;
use near_sdk::{AccountId, MockedBlockchain, PromiseResult, VMContext};

pub const LOCKUP_NEAR: u128 = 1000;
pub const GENESIS_TIME_IN_DAYS: u64 = 500;
pub const YEAR: u64 = 365;
pub const TEST_INITIAL_BALANCE: u128 = 100;

pub fn lockup_account() -> AccountId {
    "lockup".to_string()
}

pub fn system_account() -> AccountId {
    "system".to_string()
}

pub fn account_owner() -> AccountId {
    "account_owner".to_string()
}

pub fn non_owner() -> AccountId {
    "non_owner".to_string()
}

pub fn account_foundation() -> AccountId {
    "near".to_string()
}

pub fn to_yocto(near_amount: u128) -> u128 {
    return near_amount * 10u128.pow(24)
}
pub fn to_near(yoctos_amount: u128) -> u128 {
    return yoctos_amount / 10u128.pow(24)
}
//convert yocto to f64 NEAR truncate to 4 dec places
pub fn ytof(yoctos_amount: u128) -> f64 {
    let four_dec_f:f64 = ((yoctos_amount / 10u128.pow(20)) as u32).into();
    return four_dec_f / 10000.0;
}

pub fn to_nanos(num_days: u64) -> u64 {
    return num_days * 86400_000_000_000
}

pub fn to_ts(num_days: u64) -> u64 {
    // 2018-08-01 UTC in nanoseconds
    1533081600_000_000_000 + to_nanos(num_days)
}

pub fn assert_almost_eq_with_max_delta(left: u128, right: u128, max_delta: u128) {
    assert!(
        std::cmp::max(left, right) - std::cmp::min(left, right) < max_delta,
        format!(
            "Left {} is not even close to Right {} within delta {}",
            left, right, max_delta
        )
    );
}

pub fn assert_almost_eq(left: u128, right: u128) {
    assert_almost_eq_with_max_delta(left, right, to_yocto(10));
}

pub fn get_context(
    predecessor_account_id: AccountId,
    account_balance: u128,
    account_locked_balance: u128,
    block_timestamp: u64,
    is_view: bool,
) -> VMContext {
    VMContext {
        current_account_id: lockup_account(),
        signer_account_id: predecessor_account_id.clone(),
        signer_account_pk: vec![0, 1, 2],
        predecessor_account_id,
        input: vec![],
        block_index: 1,
        block_timestamp,
        epoch_height: 1,
        account_balance,
        account_locked_balance,
        storage_usage: 10u64.pow(6),
        attached_deposit: 0,
        prepaid_gas: 10u64.pow(15),
        random_seed: vec![0, 1, 2],
        is_view,
        output_data_receivers: vec![],
    }
}

pub fn testing_env_with_promise_results(context: VMContext, promise_result: PromiseResult) {
    let storage = near_sdk::env::take_blockchain_interface()
        .unwrap()
        .as_mut_mocked_blockchain()
        .unwrap()
        .take_storage();

    near_sdk::env::set_blockchain_interface(Box::new(MockedBlockchain::new(
        context,
        Default::default(),
        Default::default(),
        vec![promise_result],
        storage,
        Default::default(),
    )));
}

pub fn public_key(byte_val: u8) -> Base58PublicKey {
    let mut pk = vec![byte_val; 33];
    pk[0] = 0;
    Base58PublicKey(pk)
}

'''
'''--- divpool/tests/tests.md ---
### Tests

- [x]  create contract, configure sps
- [x]  deposit and stake
- [x]  distribute staking
- [x]  classic unstake
- [x]  complete classic unstake
- [x]  distribute unstaking
- [x]  add liquidity
- [x]  sell skash
- [ ]  get g-skash
- [ ]  remove liquidity

'''
'''--- docs/_config.yml ---
theme: jekyll-theme-cayman
'''
'''--- docs/beta-test.md ---
# GREAT NEWS!!!

## Welcome to the beta-test launch of DIV-POOL, one of the first BIG DAO's on NEAR!

The beta-test period on GUILDNET is starting, and we need a lot of help from the guild and the NEAR community.

### What's the div-pool?

See [here](https://narwallets.github.io/diversifying-staking-pool/)

### What can I do?

#### Testing

* Test the web app, report bugs here [github.com/Narwallets/dapp-diversifying-staking-pool/issues](https://github.com/Narwallets/dapp-diversifying-staking-pool/issues)
* If find a bug in the contract, report it here [github.com/Narwallets/diversifying-staking-pool/issues](https://github.com/Narwallets/diversifying-staking-pool/issues)

#### Designing

* Help by adding beauty to our basic UI 
* More than one UI design, might be popular

#### Analyzing

* Help define Tokenomics for G-SKASH

#### Coding

* Squash bugs with PRs, on any of the repos
* Start designing and or coding the Governance-Contract
* Propose and add new features

### Will contributors be rewarded?

Yes, G-SKASH (The governance token) will be awarded to collaborators. Your G-SKASH will be awarded to your account during div-pool mainnet implementation.

### What will be the value of a G-SKASH on mainnet?

It's not clear now. It depend on the final tokenomics, it depends on the amount of funding the div-pool attracts, and the future G-SKASH demand.

### How do I participate on the birth of the first BIG DAO on NEAR?

1. You need to install Narwallets' [chrome-extension wallet](https://chrome.google.com/webstore/detail/narwallets/bnbmlmjhaohpobnjfifeghjmamjfolnb)
2. [Create an account on guildet](https://wallet.openshards.io/create)
3. Open the wallet, choose "guildet" as network and import the account into the wallet
4. Go to [narwallets.com/dapp/divpool](narwallets.com/dapp/divpool)
5. Open the wallet, select your guildnet account and click "connect to web site"
6. Operate the Dapp, stake, sell SKASH, add liquidity, find and squash bugs, help make it better and prettier, get rewards!

### Where are the repos

*  Web App: [github.com/Narwallets/dapp-diversifying-staking-pool](https://github.com/Narwallets/dapp-diversifying-staking-pool)
*  Smart Contract (rust): [github.com/Narwallets/diversifying-staking-pool](https://github.com/Narwallets/diversifying-staking-pool)

'''
'''--- docs/index.md ---
# Diversifying Staking Pool

## Overview

This contract provides the following value items for the NEAR community:

#### Helps stakers avoid putting all eggs in one basket
* This contract acts as a staking-pool that distributes it's delegated funds to several validators. By delegating to this contract, you greatly reduce the risk of getting no-rewards due to a validators' outage and you contribute to decentralization of the network. Besides rewards, by staking you wil receive governance tokens: G-SKASH

#### Provides immediate unstake 
* This contract allows users to skip the waiting period after unstaking by providing a liquidity pool for inmediate unstaking. This also creates the opportunity for liquidity providers to earn fees for this service. 

#### Contributes to decentralization for the NEAR network
* This contract helps decentralization by distributing it's delegated funds to several validators. If you own a lockup-contract with considerable funds, you can greatly contribute to the decentralization of the network and reduce your risk. Your funds will be automatically distributed between several validators ensuring increased decentralization and continuous rewards.

#### Creates new Liquidity Pools
* This contract includes several liquidity pools and the opportunity for liquidity providers to earn fees. The main pool is the NEAR/SKASH pool that provides immediate unstake (sell SKASH) for a fee 0.5-10%. There will be other pools like the SKASH/G-SKASH for the the governance tokens.

#### Creates a safety-net to avoid losing validators on the seat-price cliff 
* This contract will allow struggling validators to keep a seat and keep validating in case of sudden rises in seat-price. There will be staking-loans available for whitelisted validators and also emergencys stakes from the liquidity pool. Pools requiring staking will have to pay 8-epoch rewards in advance. All fees wil be distributed as rewards between the SKASH holders or the Liquidity providers.

## SKASH Tokens

This contract allows users to manage staked near as a TOKEN, called **SKASH**.

SKASHs repesent staked NEAR, and can be transferred between users and sold for NEAR in the NEAR/SKASH Liquidity Pool (paying a fee to skip the unstaking wait period). The amount of SKASH you hold is automatically incremented each epoch when staking rewards are paid. This contract also includes a trip-meter functionality, so you can preciseliy measure rewards received.

## Immediate Unstakings

Users wanting to unstake skipping the waiting period can do so in the *NEAR/SKASH Liquidity Pool*.

In the Liquidity Pool:
 * Users providing liquidity can earn fees on each sell
 * Users wanting to unstake without the waiting period can do so for a fee

The *NEAR/SKASH Liquidity Pool* is a one-sided Liquidty pool. Liquidity providers add only NEAR to the Liq. pool. The Liq. pool allows other users to SELL SKASH for NEAR (unstake) at a discounted price. The discount represents how much users do not value waiting 39-52hs to receive their funds. The discount varies with the amount of NEAR in the liq. pool, but the curve is capped at the extremes. By default discount fees are in the range 1-10%, but the curve parameters can be adjusted by DAO governance (by the vote of G-SKASH governance token holders).

![example-fee-curve](images/example-fee-curve.png)

## Standard staking-pool

This contract also acts as a standard staking-pool, so users can perform classical stakes and classical unstakes (but with the possibility of extra waiting time because delayed unstake and/or unstaking congestion).

## Lockup contracts

By implementing the standard-staking-pool trait, *lockup contracts* can delegate funds here, gaining risk reduction and greately contributing to NEAR decentralization. Lockup contracts can only perform classic stake/unstake so Lockup contracts *can not* access the liquidity pools to sell SKASH.

## Decentralization

This contract helps the community by increasing decentralization, spliting stake automatically betweeen several validators, and also rescuing validators falling from the seat-price cliff.

## Technical details

The contract pools all users' funds and keeps a balanced distribution of those funds in a list of whitelisted, low-fee, high-uptime validators.

Staking and unstaking distribution is done by periodically calling `distribute_staking()/distribute_unstaking()`, so actual staking and unstaking are delayed. 

Users can choose to "sell" some of their SKAHS (stake_shares) to Liquidity Providers for a fee. Liquidity Providers get the SKASH+fee and deliver NEAR. No stake/unstake is performed at that point.
### Guarantees

(To verify)
- The users can not lose tokens or block contract operations by using methods under staking section.
- Users owning SKASHs will accrue rewards on each epoch, except in the extreme unlikely case that ALL validators go offline during that epoch.

## Use Cases

Definitions:

SKASH: one SKASH represents one staked NEAR. A SKASH is a virtual token computed from the user’s share in the total staked funds. By staking in the diversifying pool a user mints SKASHs, by unstaking, SKASHs are burned, when rewards are paid, new SKASH are minted and distributed.

--- To BUY SKASH is equivalent to STAKE  ---

--- To SELL SKASH is equivalent to UNSTAKE without the waiting period ---

**To buy SKASH and to stake are the same operation for the user.**

In order to stake the user buys SKAHS tokens. Buy SKASH/Stake are the same operation. When buying SKASH the price is always fixed: 1 NEAR = 1 SKASH

**To sell SKASH and to un-stake are similar.**

There are two ways to un-stake: (from more convenient to less convenient)

1. Sell SKASH at a discount price. You un-stake by selling SKASH (staked NEAR). Since you’re unstaking without waiting 39-54hs (you’re passing that waiting penalty to other users) you get a discounted price. The discount is the value you place on not-waiting 39-54hs. E.g. you sell 100 SKASH (unstake) for 99 NEAR and get the near immediately without waiting 39-54hs.

2. Classical unstake. The contract unstakes your NEAR from the staking-pools. You burn SKASH tokens and get unstaked-near. You don’t get a discounted price, but you must wait 39-54hs to move those funds to your account. Your funds remain unstaked in the staking-pool for 3 or 4 epochs (39-54hs) before you can withdraw finishig the unstake. E.g. you unstake 100 SKASH, and you get 100 unstaked-near, 4 days later you can move your unstaked-near to your “available” balance and then withdraw to your own near account.

This operations are reflected in the UI in two steps that the user must complete with 39-54hs between the two: [START UNSTAKE] and [FINISH UNSTAKE]

**Sell SKASH**

In order to provide immediate unstake (sell SKASH) a Liquidity Pool and a SELL SKASH mechanism are provided by the contract:

* TO SELL SKASH: The seller enters the amount of SKASH they want to sell and the contract replies with the amount of NEAR they will receive, normally with a discount 1%-10%, depending on the NEAR balance of the liquidity pool and the fee curve parameters.

## Treasury
Part of the NEAR/SKASH LP fees goes to the DAO Treasury. Treasury funds are always SKASHs and used for:

* DAO Maintenance
* DAO Expansion
* G-SKASH holders dividends

## Maintenance

The contract has a configurable parameter `dev_maintenance_amount`, initially 2500 SKASH, to be transferred monthly to the account `developers.near`. By DAO governance, this value can be increased and G-SKASH gov-token holders can also re-direct up to 50% of maintenance funds to other maintainers and contributors.

## Governance

(When Phase II - DAO Governance is implemented)

G-SKASH holders can vote on:
* Diversification: Validator distribution list, and how much NEAR to distribute to each one.
* Fee curve parameters for the NEAR/SKASH Liquidity Pool (min fee, max fee, slope)
* How to use treasury funds for DAO expansion
* Operational costs fee
* Maintenance funds redirections
* Move treasury funds in/out of the G-SKASH dividends-pool
* G-SKASH mint reward multiplier for:
  * SKASH-sellers/immediate unstake (default 1 G-SKASH per each discounted NEAR)
  * Stakers (default 5 G-SKASH per each SKASH of staking reward)
  * LP-providers (default 20 G-SKASH per each SKASH fee received)
* Approve stake-loans to struggling validators

Half of treasury funds must be used for DAO expansion and maintenance. The other 50% can be user for expansion by presenting proposals, or can be moved to the dividends-pool (once a month). 

The Dividends-pool is a SKASH/G-SKASH liquidity pool allowing G-SKASH owners to burn G-SKASH to obtain SKASH. This pool sets a base-price for G-SKASH tokens. When users vote to add SKASH to the dividends-pool, G-SKASH base-price is incremented. Users can also vote to remove SKASH from the dividends-pool back to the treasury, lowering the G-SKASH base price.

Users get G-SKASH tokens minted for them when:
* They sell SKASH (immediate unstaking) (default 1x multiplier)
* They receive rewards for holding SKASH (default 5x multiplier)
* They receive fees in the NEAR/SKASH Liquidity pool (default 20x multiplier)

G-SKASH governance tokens are minted and distributed to:
* users holding SKASH and 
* users providing liquidity.
* users paying immediate unstaking fees

## Operational costs

Periodic calls to `distribute_staking()/distribute_unstaking()/withdraw_from_a_pool()` are required for this contract operation. This calls consume considerable amounts of gas that is paid by the operator account. To fund this operational cost, a operator's fee percentage (0.3% by default) is taken from rewards distributions. It can be adjusted by G-SKASH governance token holders.

## User stories:
### Alice
Alice wants to stake her NEAR with low risk, and also help the community by promoting validators diversification. 
Alice opens an account in the contract: diversifying.pool.near

Alice deposits 750_000 NEAR in her div-pool account. 
Alice buys 750_000 SKASH. Her 750_000 NEAR are distributed between the staking-pools by an automatic distribution mechanism to keep the validators balanced. 

She starts earning staking rewards on her SKASH, she can track precisely her rewards. She will also get G-SKASH gov tokens.
By holding SKAHS she has the possibility to sell some of her SKASH skipping the waiting period if the need arises.

### Bob
Bob already has an account in the diversifying-pool contract. He has 10_000 SKASH earning rewards. 

Bob needs to unstake 5_000 NEAR to use in an emergency. He can’t wait 39-54hs to get his NEAR. 

Bob sells 5_050 SKASH for 5_000 NEAR. He sells at a 1% discounted price to get the NEAR immediately.
Bob gets the NEAR in his div-pool account. 
Bob can use his NEAR immediately.

### Carol
Carol is an investor. She wants to provide liquidity for the NEAR/SKASH pool for a short period, earning operation fees.
Carol deposits 7_000 NEAR in her div-pool account
Carol adds her 7_000 NEAR to the NEAR/SKASH liquidity pool, she is the first in the pool, so she gets 7_000 shares of the N/S-liq-pool.

Bob swaps 5_050 SKASH for 5_000 NEAR. He sells at a 1% discounted price to get the NEAR immediately. The N/S-liq-pool delivers 5_000 NEAR to Bob and acquires 5_050 SKASH from Bob. The new value of the N/S-liq-pool is 7_050 NEAR (2000 NEAR+5050 SKASH), 

Carol shares value have increased, and now she owns some SKASH via the N/S-liq-pool. Carol burns all her shares and retieves 2_000 NEAR and 5_050 SKASH into her account. Carol has now 7_050 NEAR. Carol earned 0.7% in a few epochs.
Had her normaly staked 7_000 NEAR, she would have earned only 0.1% 

### Dave
Dave is a Liquidity Provider. He wants to provide continuous liquidity for the SKASH/NEAR pool, in order to earn a fee on each operation.

Being a Liquidity Provider can bring-in more earnings than just staking, while helping the community at the same time by providing immediate unstaking for other users, and also helping decentralization by providing emregency stakings.

Dave enters 100_000 NEAR to the NEAR/SKASH liquidity pool (nslp), he gets shares of the N/S-liq-pool. 

Eve swaps 50_500 SKASH for 50_000 NEAR. She sells at a 1% discounted price to get the NEAR immediately

The N/S-liq-pool delivers 50_000 NEAR to Eve and acquires 50_500 SKASH from Eve.
The liquidity pool has now a low amount of NEAR now. After a few minutes, the liquidity pool automatically unstakes SKASH. The LP can use a clearing mechanism to acquire NEAR and restore liquidity automatically. After unstaking all, the pool will have 100_500 NEAR.

As the N/S-liq-pool operates, the NEAR amount grows, as Dave’s nslp-shares value. With each operation G-SKASH tokens are also minted, and Dave and the other providers get G-SKASH tokens besides the fees.

-------------------------

## Future Expansions

* USDN: Create a collateral-based stablecoin similar to Compound's DAI, using NEAR & SKASH as collateral

-------------------------

## Technical Information, Change Log & TO-DO

See the [smart contract github repository README](https://github.com/Narwallets/diversifying-staking-pool)

'''
'''--- docs/technical-notes.md ---
## Operator Functions

There are 3 "heartbeat()" functions:

### 1. distribute_staking()

This fn does just staking, in batches, looking for pool balancing.

This should be called before the end of the epoch, to maximize rewards received from the pools.

The operator should call distribute_staking() as many times as necessary

###  2. distribute_unstaking()

This fn does just unstaking, in batches, looking for pool balancing

This should be called only at the begining of each epoch, to maximize rewards received from the pools (from the previous epoch).

The operator should call distribute_unstaking() as many times as necessary

###  3. pub fn withdraw_from_a_pool(&mut self, inx:u16)

This fn performs withdraw from a specific pool, in order to have the funds available when the user requests them

This should be called at the begining of each epoch. The operator should call get_staking_pools()
and process the list calling withdraw for each pool that needs that

'''
'''--- restart-testnet.sh ---
export NODE_ENV=testnet
near delete diversifying.pool.testnet asimov.testnet
near create-account diversifying.pool.testnet --masterAccount pool.testnet
. deploy-testnet.sh
near call diversifying.pool.testnet new '{"owner_account_id":"dao.diversifying.pool.testnet", "treasury_account_id":"treasury.diversifying.pool.testnet", "operator_account_id":"lucio.testnet"}' --accountId pool.testnet

'''
'''--- rewards-register-contract/Cargo.toml ---
[package]
edition = "2018"
name = "rewards-register"
version = "0.1.0"
authors = ["Narwallets.com <hello@narwallets.com>"]
publish = false

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "2.0.0"
uint = { version = "0.8.3", default-features = false }

[dev-dependencies]
lazy_static = "1.4.0"
quickcheck = "0.9"
quickcheck_macros = "0.9"
log = "0.4"
env_logger = { version = "0.7.1", default-features = false }
#near-crypto = { git = "https://github.com/nearprotocol/nearcore.git" }
#near-primitives = { git = "https://github.com/nearprotocol/nearcore.git" }
#near-runtime-standalone = { git = "https://github.com/nearprotocol/nearcore.git" }

'''
'''--- rewards-register-contract/src/internal.rs ---
//use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{env, Promise};
use crate::*;

#[macro_export]
macro_rules! log {
    ($($arg:tt)*) => ({
        env::log(format!($($arg)*).as_bytes());
    });
}

pub const NEAR:u128 = 1_000_000_000_000_000_000_000_000;

impl RewardsRegisterContract {
    /********************/
    /* Internal methods */
    /********************/

    //-- ACCOUNTS --
    /// Inner method to get the given account or a new default value account.
    pub(crate) fn internal_get_account(&self, account_id: &AccountId) -> Account {
        self.accounts.get(account_id).unwrap_or_default()
    }

    /// Inner method to save the given account for a given account ID.
    /// If the account balances are 0, the account is deleted instead to release storage.
    pub(crate) fn internal_update_account(&mut self, account_id: &AccountId, account: &Account) {
        if account.deposited > 0 {
            self.accounts.insert(account_id, &account);
        } else {
            self.accounts.remove(account_id);
        }
    }

    pub(crate) fn internal_close_account(&mut self) {

        let account_id = env::predecessor_account_id();
        let account = self.internal_get_account(&account_id);
        assert!(account.deposited > 0, "No deposit to retreieve");

        self.total_rewards -= account.rewards;

        self.accounts.remove(&account_id);

        log!("@{} closing account. {} returned",&account_id, account.deposited);
        Promise::new(account_id).transfer(account.deposited);

    }

    /// Asserts that the method was called by the owner.
    pub(crate) fn assert_owner(&self) {
        assert!(env::predecessor_account_id()==self.owner_account_id,"Can only be called by the owner")
    }

}

'''
'''--- rewards-register-contract/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::json_types::{U128};
use near_sdk::{env, near_bindgen};
use near_sdk::{AccountId};
use near_sdk::collections::UnorderedMap;

mod internal;
use internal::*;

#[global_allocator]
static ALLOC: near_sdk::wee_alloc::WeeAlloc = near_sdk::wee_alloc::WeeAlloc::INIT;

// const ONE_NEAR:u128 = 1_000_000_000_000_000_000_000_000;
// const ONE_NEAR_CENT:u128 = ONE_NEAR/100;
// const DEPOSIT_FOR_REQUEST: u128 = ONE_NEAR_CENT; // amount that clients have to attach to make a request to the api
// const GAS_FOR_REQUEST: Gas = 50_000_000_000_000;

/// account data
#[derive(BorshDeserialize, BorshSerialize, Debug, PartialEq)]
pub struct Account {
    pub github_handle: String,
    pub deposited: u128, //NEAR deposited when registering the account
    pub rewards: u128,
}

impl Default for Account {
    fn default() -> Self {
        Self {
            github_handle: String::from(""),
            deposited: 0,
            rewards: 0,
        }
    }
}

/// Represents an account structure readable by humans.
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct HumanReadableAccount {
    pub account_id: AccountId,
    pub github_handle: String,
    pub rewards: U128,
    pub deposited: U128,
}

//contract state
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct RewardsRegisterContract {
    /// The account ID of the owner 
    pub owner_account_id: AccountId,
    /// Persistent map from an account ID to the corresponding account.
    pub accounts: UnorderedMap<AccountId, Account>,
    /// The total rewards 
    pub total_rewards: u128,
}

impl Default for RewardsRegisterContract {
    fn default() -> Self {
        env::panic(b"This contract should be initialized before usage")  
    }
}

#[near_bindgen]
impl RewardsRegisterContract {

    #[init]
    pub fn new(owner_account_id:String)-> Self{
        /* Prevent re-initializations */
        assert!(!env::state_exists(), "This contract is already initialized");
        return Self {
             owner_account_id,
             total_rewards: 0,
             accounts: UnorderedMap::new(b"A".to_vec()),
         };
    }

    /****************/
    /* Main methods */
    /****************/
    #[payable]
    pub fn set_github_handle(&mut self, github_handle: String){
        let account_id = env::predecessor_account_id();
        let mut account = self.internal_get_account(&account_id);
        let amount = env::attached_deposit();
        account.deposited += amount;
        assert!(account.deposited>=1*NEAR, "send at least ONE NEAR to register you account. You'll get back your NEAR when closing the account");
        self.internal_update_account(&account_id, &account);
   
        log!("@{} registered {} as githun_handle",account_id, github_handle);
    }

    pub fn get_github_handle(&self)-> String {
        let account = self.internal_get_account(&env::predecessor_account_id());
        return account.github_handle.clone();
    }

    pub fn get_rewards(&self)-> U128 {
        let account = self.internal_get_account(&env::predecessor_account_id());
        return account.rewards.into();
    }

    pub fn add_rewards(&mut self,account_id:AccountId,amount:U128) {
        self.assert_owner();
        let mut account = self.internal_get_account(&account_id);
        account.rewards += amount.0;
        self.internal_update_account(&account_id, &account);
    }
    pub fn set_rewards(&mut self,account_id:AccountId,amount:U128) {
        self.assert_owner();
        let mut account = self.internal_get_account(&account_id);
        account.rewards = amount.0;
        self.internal_update_account(&account_id, &account);
    }
    
    pub fn close_account(&mut self){
        self.internal_close_account();
    }

    /// Returns human readable representation of the account for the given account ID.
    pub fn get_account(&self, account_id: AccountId) -> HumanReadableAccount {
        self.assert_owner();
        let account = self.internal_get_account(&account_id);
        HumanReadableAccount {
            account_id,
            github_handle:account.github_handle.into(),
            rewards: account.rewards.into(),
            deposited: account.deposited.into(),
        }
    }

    /// Returns the number of accounts that have positive balance on this staking pool.
    pub fn get_number_of_accounts(&self) -> u64 {
        self.accounts.len()
    }

    /// Returns the list of accounts
    pub fn get_accounts(&self, from_index: u64, limit: u64) -> Vec<HumanReadableAccount> {
        self.assert_owner();
        let keys = self.accounts.keys_as_vector();

        (from_index..std::cmp::min(from_index + limit, keys.len()))
            .map(|index| self.get_account(keys.get(index).unwrap()))
            .collect()
    }

}

/**************/
/* Unit tests */
/**************/

#[cfg(test)]
mod tests {
    use near_sdk::MockedBlockchain;
    use near_sdk::{testing_env, VMContext};

    /// Set the contract context
    pub fn initialize() {
        let context = get_context(String::from("client.testnet"), 10);                    
        testing_env!(context); 
    }

    /// Defines the context for the contract
    fn get_context(predecessor_account_id: String, storage_usage: u64) -> VMContext {
        VMContext {
            current_account_id: "contract.testnet".to_string(),
            signer_account_id: "alice.testnet".to_string(),
            signer_account_pk: vec![0, 1, 2],
            predecessor_account_id,
            input: vec![],
            block_index: 0,
            block_timestamp: 0,
            account_balance: 0,
            account_locked_balance: 0,
            storage_usage,
            attached_deposit: 0,
            prepaid_gas: 10u64.pow(18),
            random_seed: vec![0, 1, 2],
            is_view: false,
            output_data_receivers: vec![],
            epoch_height: 19,
        }
    }

    ///Test get_id and set_id methods
    #[test]
    fn test_id() {
        initialize();
        /* Initialize contract */
        let mut contract = super::RewardsRegisterContract::new(String::from("developers.near"));
        let handle = String::from("narwallets");
        contract.set_github_handle(handle.clone());
        assert_eq!(contract.get_github_handle(), handle.clone(), "handle is different from the expected");
    }
}

'''
'''--- sdg.sh ---
sudo guild deploy-guildnet.sh

'''
'''--- test-get-epoch-contract/Cargo.toml ---
[package]
edition = "2018"
name = "get-epoch-contract"
version = "0.1.0"
authors = ["luciotato <luciotato@gmail.com>"]

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "2.0.0"

[dev-dependencies]
lazy_static = "1.4.0"
quickcheck = "0.9"
quickcheck_macros = "0.9"
log = "0.4"
env_logger = { version = "0.7.1", default-features = false }

'''
'''--- test-get-epoch-contract/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
//use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{env, near_bindgen};
//use near_sdk::json_types::{U128};

#[global_allocator]
static ALLOC: near_sdk::wee_alloc::WeeAlloc = near_sdk::wee_alloc::WeeAlloc::INIT;

// const ONE_NEAR:u128 = 1_000_000_000_000_000_000_000_000;
// const ONE_NEAR_CENT:u128 = ONE_NEAR/100;
// const DEPOSIT_FOR_REQUEST: u128 = ONE_NEAR_CENT; // amount that clients have to attach to make a request to the api
// const GAS_FOR_REQUEST: Gas = 50_000_000_000_000;

//contract state
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct TestContract {
    //current request id
    pub saved_message: String,
    pub saved_i32: i32,
    //last response received
    pub last_epoch: u64
}

impl Default for TestContract {
    fn default() -> Self {
        env::panic(b"This contract should be initialized before usage")  
    }
}

#[near_bindgen]
impl TestContract {

    #[init]
    pub fn new()-> Self{
        /* Prevent re-initializations */
        assert!(!env::state_exists(), "This contract is already initialized");
        return Self {
             saved_message: String::from("init"),
             saved_i32: 0,
             last_epoch: env::epoch_height()
         };
    }

    /****************/
    /* Main methods */
    /****************/
    #[payable]
    pub fn set_message(&mut self, message: String){
        self.saved_message = message;
    }
    #[payable]
    pub fn set_i32(&mut self, num: i32){
        self.saved_i32 = num;
    }

    pub fn get_message(&self)-> String{
        return self.saved_message.clone();
    }

    ///Make a request to the dia-gateway smart contract
    pub fn get_epoch_height(&self)-> u64 {
        return env::epoch_height()
    }

    ///Make a request to the dia-gateway smart contract
    pub fn get_block_index(&self)-> u64 {
        return env::block_index()
    }

}

/**************/
/* Unit tests */
/**************/

#[cfg(test)]
mod tests {
    use near_sdk::MockedBlockchain;
    use near_sdk::{testing_env, VMContext};

    /// Set the contract context
    pub fn initialize() {
        let context = get_context(String::from("client.testnet"), 10);                    
        testing_env!(context); 
    }

    /// Defines the context for the contract
    fn get_context(predecessor_account_id: String, storage_usage: u64) -> VMContext {
        VMContext {
            current_account_id: "contract.testnet".to_string(),
            signer_account_id: "alice.testnet".to_string(),
            signer_account_pk: vec![0, 1, 2],
            predecessor_account_id,
            input: vec![],
            block_index: 0,
            block_timestamp: 0,
            account_balance: 0,
            account_locked_balance: 0,
            storage_usage,
            attached_deposit: 0,
            prepaid_gas: 10u64.pow(18),
            random_seed: vec![0, 1, 2],
            is_view: false,
            output_data_receivers: vec![],
            epoch_height: 19,
        }
    }

    ///Test get_id and set_id methods
    #[test]
    fn test_id() {
        initialize();
        /* Initialize contract */
        let mut contract = super::TestContract::new();
        let msg = String::from("test string");
        contract.set_message(msg.clone());
        assert_eq!(contract.get_message(), msg.clone(), "Contract message is different from the expected");
    }
}

'''
'''--- test-staking-pool/Cargo.toml ---
[package]
name = "staking-pool"
version = "0.4.1"
authors = ["Near Inc <hello@near.org>"]
edition = "2018"
publish = false

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "2.0.0"
uint = { version = "0.8.3", default-features = false }

[dev-dependencies]
lazy_static = "1.4.0"
quickcheck = "0.9"
quickcheck_macros = "0.9"
log = "0.4"
env_logger = { version = "0.7.1", default-features = false }
near-crypto = { git = "https://github.com/nearprotocol/nearcore.git" }
near-primitives = { git = "https://github.com/nearprotocol/nearcore.git" }
#near-runtime-standalone = { git = "https://github.com/nearprotocol/nearcore.git" }

'''
'''--- test-staking-pool/src/internal.rs ---
use crate::*;

impl StakingContract {
    /********************/
    /* Internal methods */
    /********************/

    /// Restakes the current `total_staked_balance` again.
    pub(crate) fn internal_restake(&mut self) {
        if self.paused {
            return;
        }
        let to_stake = if UNSTAKING_DELAY_ENABLED { self.total_staked_balance } else { self.total_staked_balance - self.total_staked_balance*25/100 };
        // Stakes with the staking public key. If the public key is invalid the entire function
        // call will be rolled back.
        if SIMULATOR_TEST_MODE {
            env::log(format!(
                "@on_stake_action stake_action sim mode total_staked_balance:{}", 
                self.total_staked_balance
            ).as_bytes());
        }
        else {
            env::log(
                format!(
                    "@{} curr account_balance:{} locked/stkd:{} -> setting new staked balance to {}",
                    env::current_account_id(), env::account_balance(), self.total_staked_balance, to_stake
                )
                .as_bytes(),
            );
            Promise::new(env::current_account_id())
                .stake(to_stake, self.stake_public_key.clone())
                .then(ext_self::on_stake_action(
                    &env::current_account_id(),
                    NO_DEPOSIT,
                    ON_STAKE_ACTION_GAS,
                ));
        }
    }

    pub(crate) fn internal_deposit(&mut self) -> u128 {
        let account_id = env::predecessor_account_id();
        let mut account = self.internal_get_account(&account_id);
        let amount = env::attached_deposit();
        account.unstaked += amount;
        self.internal_save_account(&account_id, &account);
        self.last_total_balance += amount;

        env::log(
            format!(
                "@{} deposited {}. New unstaked balance is {}",
                account_id, amount, account.unstaked
            )
            .as_bytes(),
        );
        amount
    }

    pub(crate) fn internal_withdraw(&mut self, amount: Balance) {
        assert!(amount > 0, "Withdrawal amount should be positive");

        let account_id = env::predecessor_account_id();
        let mut account = self.internal_get_account(&account_id);
        assert!(
            account.unstaked >= amount,
            "Not enough unstaked balance to withdraw"
        );
        if UNSTAKING_DELAY_ENABLED {
            assert!(
                account.unstaked_available_epoch_height <= env::epoch_height(),
                "The unstaked balance is not yet available due to unstaking delay"
            );
        }
        
        account.unstaked -= amount;
        self.internal_save_account(&account_id, &account);

        env::log(
            format!(
                "@{} withdrawing {}. New unstaked balance is {}",
                account_id, amount, account.unstaked
            )
            .as_bytes(),
        );

        Promise::new(account_id).transfer(amount);
        self.last_total_balance -= amount;
    }

    pub(crate) fn internal_stake(&mut self, amount: Balance) {
        assert!(amount > 0, "Staking amount should be positive");

        let account_id = env::predecessor_account_id();
        let mut account = self.internal_get_account(&account_id);

        // Calculate the number of "stake" shares that the account will receive for staking the
        // given amount.
        let num_shares = self.num_shares_from_staked_amount_rounded_down(amount);
        assert!(
            num_shares > 0,
            "The calculated number of \"stake\" shares received for staking should be positive"
        );
        // The amount of tokens the account will be charged from the unstaked balance.
        // Rounded down to avoid overcharging the account to guarantee that the account can always
        // unstake at least the same amount as staked.
        let charge_amount = self.staked_amount_from_num_shares_rounded_down(num_shares);
        assert!(
            charge_amount > 0,
            "Invariant violation. Calculated staked amount must be positive, because \"stake\" share price should be at least 1"
        );

        assert!(
            account.unstaked >= charge_amount,
            "Not enough unstaked balance to stake"
        );
        account.unstaked -= charge_amount;
        account.stake_shares += num_shares;
        self.internal_save_account(&account_id, &account);

        // The staked amount that will be added to the total to guarantee the "stake" share price
        // never decreases. The difference between `stake_amount` and `charge_amount` is paid
        // from the allocated STAKE_SHARE_PRICE_GUARANTEE_FUND.
        let stake_amount = self.staked_amount_from_num_shares_rounded_up(num_shares);

        self.total_staked_balance += stake_amount;
        self.total_stake_shares += num_shares;

        env::log(
            format!(
                "@{} staking {}. Received {} new staking shares. Total {} unstaked balance and {} staking shares",
                account_id, charge_amount, num_shares, account.unstaked, account.stake_shares
            )
                .as_bytes(),
        );
        env::log(
            format!(
                "Contract total staked balance is {}. Total number of shares {}",
                self.total_staked_balance, self.total_stake_shares
            )
            .as_bytes(),
        );
    }

    pub(crate) fn inner_unstake(&mut self, amount: u128) {
        assert!(amount > 0, "Unstaking amount should be positive");

        let account_id = env::predecessor_account_id();
        let mut account = self.internal_get_account(&account_id);

        assert!(
            self.total_staked_balance > 0,
            "The contract doesn't have staked balance"
        );
        // Calculate the number of shares required to unstake the given amount.
        // NOTE: The number of shares the account will pay is rounded up.
        let num_shares = self.num_shares_from_staked_amount_rounded_up(amount);
        assert!(
            num_shares > 0,
            "Invariant violation. The calculated number of \"stake\" shares for unstaking should be positive"
        );
        assert!(
            account.stake_shares >= num_shares,
            "Not enough staked balance to unstake"
        );

        // Calculating the amount of tokens the account will receive by unstaking the corresponding
        // number of "stake" shares, rounding up.
        let receive_amount = self.staked_amount_from_num_shares_rounded_up(num_shares);
        assert!(
            receive_amount > 0,
            "Invariant violation. Calculated staked amount must be positive, because \"stake\" share price should be at least 1"
        );

        account.stake_shares -= num_shares;
        account.unstaked += receive_amount;
        account.unstaked_available_epoch_height = env::epoch_height() + NUM_EPOCHS_TO_UNLOCK;
        self.internal_save_account(&account_id, &account);

        // The amount tokens that will be unstaked from the total to guarantee the "stake" share
        // price never decreases. The difference between `receive_amount` and `unstake_amount` is
        // paid from the allocated STAKE_SHARE_PRICE_GUARANTEE_FUND.
        let unstake_amount = self.staked_amount_from_num_shares_rounded_down(num_shares);

        self.total_staked_balance -= unstake_amount;
        self.total_stake_shares -= num_shares;

        env::log(
            format!(
                "@{} unstaking {}. Spent {} staking shares. Total {} unstaked balance and {} staking shares",
                account_id, receive_amount, num_shares, account.unstaked, account.stake_shares
            )
                .as_bytes(),
        );
        env::log(
            format!(
                "Contract total staked balance is {}. Total number of shares {}",
                self.total_staked_balance, self.total_stake_shares
            )
            .as_bytes(),
        );
    }

    /// Asserts that the method was called by the owner.
    pub(crate) fn assert_owner(&self) {
        assert_eq!(
            env::predecessor_account_id(),
            self.owner_id,
            "Can only be called by the owner"
        );
    }

    /// Distributes rewards after the new epoch. It's automatically called before every action.
    /// Returns true if the current epoch height is different from the last epoch height.
    pub(crate) fn internal_ping(&mut self) -> bool {
        let epoch_height = env::epoch_height();
        if self.last_epoch_height == epoch_height {
            return false;
        }
        self.last_epoch_height = epoch_height;

        // New total amount (both locked and unlocked balances).
        // NOTE: We need to subtract `attached_deposit` in case `ping` called from `deposit` call
        // since the attached deposit gets included in the `account_balance`, and we have not
        // accounted it yet.
        let total_balance =
            env::account_locked_balance() + env::account_balance() - env::attached_deposit();

        assert!(
            total_balance >= self.last_total_balance, 
            "The new total balance {} should not be less than the old total balance {}",total_balance,self.last_total_balance
        );
        let total_reward = total_balance - self.last_total_balance;
        if total_reward > 0 {
            // The validation fee that the contract owner takes.
            let owners_fee = self.reward_fee_fraction.multiply(total_reward);

            // Distributing the remaining reward to the delegators first.
            let remaining_reward = total_reward - owners_fee;
            self.total_staked_balance += remaining_reward;

            // Now buying "stake" shares for the contract owner at the new share price.
            let num_shares = self.num_shares_from_staked_amount_rounded_down(owners_fee);
            if num_shares > 0 {
                // Updating owner's inner account
                let owner_id = self.owner_id.clone();
                let mut account = self.internal_get_account(&owner_id);
                account.stake_shares += num_shares;
                self.internal_save_account(&owner_id, &account);
                // Increasing the total amount of "stake" shares.
                self.total_stake_shares += num_shares;
            }
            // Increasing the total staked balance by the owners fee, no matter whether the owner
            // received any shares or not.
            self.total_staked_balance += owners_fee;

            env::log(
                format!(
                    "Epoch {}: Contract received total rewards of {} tokens. New total staked balance is {}. Total number of shares {}",
                    epoch_height, total_reward, self.total_staked_balance, self.total_stake_shares,
                )
                    .as_bytes(),
            );
            if num_shares > 0 {
                env::log(format!("Total rewards fee is {} stake shares.", num_shares).as_bytes());
            }
        }

        self.last_total_balance = total_balance;
        return true
    }

    /// Returns the number of "stake" shares rounded down corresponding to the given staked balance
    /// amount.
    ///
    /// price = total_staked / total_shares
    /// Price is fixed
    /// (total_staked + amount) / (total_shares + num_shares) = total_staked / total_shares
    /// (total_staked + amount) * total_shares = total_staked * (total_shares + num_shares)
    /// amount * total_shares = total_staked * num_shares
    /// num_shares = amount * total_shares / total_staked
    pub(crate) fn num_shares_from_staked_amount_rounded_down(
        &self,
        amount: Balance,
    ) -> NumStakeShares {
        assert!(
            self.total_staked_balance > 0,
            "The total staked balance can't be 0"
        );
        (U256::from(self.total_stake_shares) * U256::from(amount)
            / U256::from(self.total_staked_balance))
        .as_u128()
    }

    /// Returns the number of "stake" shares rounded up corresponding to the given staked balance
    /// amount.
    ///
    /// Rounding up division of `a / b` is done using `(a + b - 1) / b`.
    pub(crate) fn num_shares_from_staked_amount_rounded_up(
        &self,
        amount: Balance,
    ) -> NumStakeShares {
        assert!(
            self.total_staked_balance > 0,
            "The total staked balance can't be 0"
        );
        ((U256::from(self.total_stake_shares) * U256::from(amount)
            + U256::from(self.total_staked_balance - 1))
            / U256::from(self.total_staked_balance))
        .as_u128()
    }

    /// Returns the staked amount rounded down corresponding to the given number of "stake" shares.
    pub(crate) fn staked_amount_from_num_shares_rounded_down(
        &self,
        num_shares: NumStakeShares,
    ) -> Balance {
        assert!(
            self.total_stake_shares > 0,
            "The total number of stake shares can't be 0"
        );
        (U256::from(self.total_staked_balance) * U256::from(num_shares)
            / U256::from(self.total_stake_shares))
        .as_u128()
    }

    /// Returns the staked amount rounded up corresponding to the given number of "stake" shares.
    ///
    /// Rounding up division of `a / b` is done using `(a + b - 1) / b`.
    pub(crate) fn staked_amount_from_num_shares_rounded_up(
        &self,
        num_shares: NumStakeShares,
    ) -> Balance {
        assert!(
            self.total_stake_shares > 0,
            "The total number of stake shares can't be 0"
        );
        ((U256::from(self.total_staked_balance) * U256::from(num_shares)
            + U256::from(self.total_stake_shares - 1))
            / U256::from(self.total_stake_shares))
        .as_u128()
    }

    /// Inner method to get the given account or a new default value account.
    pub(crate) fn internal_get_account(&self, account_id: &AccountId) -> Account {
        self.accounts.get(account_id).unwrap_or_default()
    }

    /// Inner method to save the given account for a given account ID.
    /// If the account balances are 0, the account is deleted instead to release storage.
    pub(crate) fn internal_save_account(&mut self, account_id: &AccountId, account: &Account) {
        if account.unstaked > 0 || account.stake_shares > 0 {
            self.accounts.insert(account_id, &account);
        } else {
            self.accounts.remove(account_id);
        }
    }
}

'''
'''--- test-staking-pool/src/lib.rs ---
use std::convert::TryInto;

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::UnorderedMap;
use near_sdk::json_types::{Base58PublicKey, U128};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{
    env, ext_contract, near_bindgen, AccountId, Balance, EpochHeight, Promise, PromiseResult,
    PublicKey,
};
use uint::construct_uint;

mod internal;

const SIMULATOR_TEST_MODE:bool = true; // there's a bug in near_sdk_sim making unstaking not working. This mode avoids staking, but keeps the internal state
const UNSTAKING_DELAY_ENABLED:bool = true; //true => standard staking pool, false=>only stake 75%, no unstaking delay (used for testing)

/// The amount of gas given to complete `vote` call.
const VOTE_GAS: u64 = 100_000_000_000_000;

/// The amount of gas given to complete internal `on_stake_action` call.
const ON_STAKE_ACTION_GAS: u64 = 20_000_000_000_000;

/// The amount of yocto NEAR the contract dedicates to guarantee that the "share" price never
/// decreases. It's used during rounding errors for share -> amount conversions.
const STAKE_SHARE_PRICE_GUARANTEE_FUND: Balance = 1_000_000_000_000;

/// There is no deposit balance attached.
const NO_DEPOSIT: Balance = 0;

/// A type to distinguish between a balance and "stake" shares for better readability.
pub type NumStakeShares = Balance;

construct_uint! {
    /// 256-bit unsigned integer.
    pub struct U256(4);
}

#[cfg(test)]
mod test_utils;

#[global_allocator]
static ALLOC: near_sdk::wee_alloc::WeeAlloc = near_sdk::wee_alloc::WeeAlloc::INIT;

/// Inner account data of a delegate.
#[derive(BorshDeserialize, BorshSerialize, Debug, PartialEq)]
pub struct Account {
    /// The unstaked balance. It represents the amount the account has on this contract that
    /// can either be staked or withdrawn.
    pub unstaked: Balance,
    /// The amount of "stake" shares. Every stake share corresponds to the amount of staked balance.
    /// NOTE: The number of shares should always be less or equal than the amount of staked balance.
    /// This means the price of stake share should always be at least `1`.
    /// The price of stake share can be computed as `total_staked_balance` / `total_stake_shares`.
    pub stake_shares: NumStakeShares,
    /// The minimum epoch height when the withdrawn is allowed.
    /// This changes after unstaking action, because the amount is still locked for 3 epochs.
    pub unstaked_available_epoch_height: EpochHeight,
}

/// Represents an account structure readable by humans.
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct HumanReadableAccount {
    pub account_id: AccountId,
    /// The unstaked balance that can be withdrawn or staked.
    pub unstaked_balance: U128,
    /// The amount balance staked at the current "stake" share price.
    pub staked_balance: U128,
    /// Whether the unstaked balance is available for withdrawal now.
    pub can_withdraw: bool,
}

impl Default for Account {
    fn default() -> Self {
        Self {
            unstaked: 0,
            stake_shares: 0,
            unstaked_available_epoch_height: 0,
        }
    }
}

/// The number of epochs required for the locked balance to become unlocked.
/// NOTE: The actual number of epochs when the funds are unlocked is 3. But there is a corner case
/// when the unstaking promise can arrive at the next epoch, while the inner state is already
/// updated in the previous epoch. It will not unlock the funds for 4 epochs.
const NUM_EPOCHS_TO_UNLOCK: EpochHeight = 4;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct StakingContract {
    /// The account ID of the owner who's running the staking validator node.
    /// NOTE: This is different from the current account ID which is used as a validator account.
    /// The owner of the staking pool can change staking public key and adjust reward fees.
    pub owner_id: AccountId,
    /// The public key which is used for staking action. It's the public key of the validator node
    /// that validates on behalf of the pool.
    pub stake_public_key: PublicKey,
    /// The last epoch height when `ping` was called.
    pub last_epoch_height: EpochHeight,
    /// The last total balance of the account (consists of staked and unstaked balances).
    pub last_total_balance: Balance,
    /// The total amount of shares. It should be equal to the total amount of shares across all
    /// accounts.
    pub total_stake_shares: NumStakeShares,
    /// The total staked balance.
    pub total_staked_balance: Balance,
    /// The fraction of the reward that goes to the owner of the staking pool for running the
    /// validator node.
    pub reward_fee_fraction: RewardFeeFraction,
    /// Persistent map from an account ID to the corresponding account.
    pub accounts: UnorderedMap<AccountId, Account>,
    /// Whether the staking is paused.
    /// When paused, the account unstakes everything (stakes 0) and doesn't restake.
    /// It doesn't affect the staking shares or reward distribution.
    /// Pausing is useful for node maintenance. Only the owner can pause and resume staking.
    /// The contract is not paused by default.
    pub paused: bool,
}

impl Default for StakingContract {
    fn default() -> Self {
        env::panic(b"Staking contract should be initialized before usage")
    }
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct RewardFeeFraction {
    pub numerator: u32,
    pub denominator: u32,
}

impl RewardFeeFraction {
    pub fn assert_valid(&self) {
        assert_ne!(self.denominator, 0, "Denominator must be a positive number");
        assert!(
            self.numerator <= self.denominator,
            "The reward fee must be less or equal to 1"
        );
    }

    pub fn multiply(&self, value: Balance) -> Balance {
        (U256::from(self.numerator) * U256::from(value) / U256::from(self.denominator)).as_u128()
    }
}

/// Interface for a voting contract.
#[ext_contract(ext_voting)]
pub trait VoteContract {
    /// Method for validators to vote or withdraw the vote.
    /// Votes for if `is_vote` is true, or withdraws the vote if `is_vote` is false.
    fn vote(&mut self, is_vote: bool);
}

/// Interface for the contract itself.
#[ext_contract(ext_self)]
pub trait SelfContract {
    /// A callback to check the result of the staking action.
    /// In case the stake amount is less than the minimum staking threshold, the staking action
    /// fails, and the stake amount is not changed. This might lead to inconsistent state and the
    /// follow withdraw calls might fail. To mitigate this, the contract will issue a new unstaking
    /// action in case of the failure of the first staking action.
    fn on_stake_action(&mut self);
}

#[near_bindgen]
impl StakingContract {
    /// Initializes the contract with the given owner_id, initial staking public key (with ED25519
    /// curve) and initial reward fee fraction that owner charges for the validation work.
    ///
    /// The entire current balance of this contract will be used to stake. This allows contract to
    /// always maintain staking shares that can't be unstaked or withdrawn.
    /// It prevents inflating the price of the share too much.
    #[init]
    pub fn new(
        owner_id: AccountId,
        stake_public_key: Base58PublicKey,
        reward_fee_fraction: RewardFeeFraction,
    ) -> Self {
        assert!(!env::state_exists(), "Already initialized");
        reward_fee_fraction.assert_valid();
        assert!(
            env::is_valid_account_id(owner_id.as_bytes()),
            "The owner account ID is invalid"
        );
        let account_balance = env::account_balance();
        let total_staked_balance = account_balance - STAKE_SHARE_PRICE_GUARANTEE_FUND;
        assert_eq!(
            env::account_locked_balance(),
            0,
            "The staking pool shouldn't be staking at the initialization"
        );
        let mut this = Self {
            owner_id,
            stake_public_key: stake_public_key.into(),
            last_epoch_height: env::epoch_height(),
            last_total_balance: account_balance,
            total_staked_balance,
            total_stake_shares: NumStakeShares::from(total_staked_balance),
            reward_fee_fraction,
            accounts: UnorderedMap::new(b"u".to_vec()),
            paused: false,
        };
        // Staking with the current pool to make sure the staking key is valid.
        this.internal_restake();
        this
    }

    /// Distributes rewards and restakes if needed.
    pub fn ping(&mut self) {
        if self.internal_ping() {
            self.internal_restake();
        }
    }

    /// Deposits the attached amount into the inner account of the predecessor.
    #[payable]
    pub fn deposit(&mut self) {
        let need_to_restake = self.internal_ping();

        self.internal_deposit();

        if need_to_restake {
            self.internal_restake();
        }
    }

    /// Deposits the attached amount into the inner account of the predecessor and stakes it.
    #[payable]
    pub fn deposit_and_stake(&mut self) {
        self.internal_ping();

        let amount = self.internal_deposit();
        self.internal_stake(amount);

        self.internal_restake();
    }

    /// Withdraws the entire unstaked balance from the predecessor account.
    /// It's only allowed if the `unstake` action was not performed in the four most recent epochs.
    pub fn withdraw_all(&mut self) {
        let need_to_restake = self.internal_ping();

        let account_id = env::predecessor_account_id();
        let account = self.internal_get_account(&account_id);
        self.internal_withdraw(account.unstaked);

        if need_to_restake {
            self.internal_restake();
        }
    }

    /// Withdraws the non staked balance for given account.
    /// It's only allowed if the `unstake` action was not performed in the four most recent epochs.
    pub fn withdraw(&mut self, amount: U128) {
        let need_to_restake = self.internal_ping();

        let amount: Balance = amount.into();
        self.internal_withdraw(amount);

        if need_to_restake {
            self.internal_restake();
        }
    }

    /// Stakes all available unstaked balance from the inner account of the predecessor.
    pub fn stake_all(&mut self) {
        // Stake action always restakes
        self.internal_ping();

        let account_id = env::predecessor_account_id();
        let account = self.internal_get_account(&account_id);
        self.internal_stake(account.unstaked);

        self.internal_restake();
    }

    /// Stakes the given amount from the inner account of the predecessor.
    /// The inner account should have enough unstaked balance.
    pub fn stake(&mut self, amount: U128) {
        // Stake action always restakes
        self.internal_ping();

        let amount: Balance = amount.into();
        self.internal_stake(amount);

        self.internal_restake();
    }

    /// Unstakes all staked balance from the inner account of the predecessor.
    /// The new total unstaked balance will be available for withdrawal in four epochs.
    pub fn unstake_all(&mut self) {
        // Unstake action always restakes
        self.internal_ping();

        let account_id = env::predecessor_account_id();
        let account = self.internal_get_account(&account_id);
        let amount = self.staked_amount_from_num_shares_rounded_down(account.stake_shares);
        self.inner_unstake(amount);

        self.internal_restake();
    }

    /// Unstakes the given amount from the inner account of the predecessor.
    /// The inner account should have enough staked balance.
    /// The new total unstaked balance will be available for withdrawal in four epochs.
    pub fn unstake(&mut self, amount: U128) {
        // Unstake action always restakes
        self.internal_ping();

        let amount: Balance = amount.into();
        self.inner_unstake(amount);

        self.internal_restake();
    }

    /****************/
    /* View methods */
    /****************/

    /// Returns the unstaked balance of the given account.
    pub fn get_account_unstaked_balance(&self, account_id: AccountId) -> U128 {
        self.get_account(account_id).unstaked_balance
    }

    /// Returns the staked balance of the given account.
    /// NOTE: This is computed from the amount of "stake" shares the given account has and the
    /// current amount of total staked balance and total stake shares on the account.
    pub fn get_account_staked_balance(&self, account_id: AccountId) -> U128 {
        self.get_account(account_id).staked_balance
    }

    /// Returns the total balance of the given account (including staked and unstaked balances).
    pub fn get_account_total_balance(&self, account_id: AccountId) -> U128 {
        let account = self.get_account(account_id);
        (account.unstaked_balance.0 + account.staked_balance.0).into()
    }

    /// Returns `true` if the given account can withdraw tokens in the current epoch.
    pub fn is_account_unstaked_balance_available(&self, account_id: AccountId) -> bool {
        self.get_account(account_id).can_withdraw
    }

    /// Returns the total staking balance.
    pub fn get_total_staked_balance(&self) -> U128 {
        self.total_staked_balance.into()
    }

    /// Returns account ID of the staking pool owner.
    pub fn get_owner_id(&self) -> AccountId {
        self.owner_id.clone()
    }

    /// Returns the current reward fee as a fraction.
    pub fn get_reward_fee_fraction(&self) -> RewardFeeFraction {
        self.reward_fee_fraction.clone()
    }

    /// Returns the staking public key
    pub fn get_staking_key(&self) -> Base58PublicKey {
        self.stake_public_key.clone().try_into().unwrap()
    }

    /// Returns true if the staking is paused
    pub fn is_staking_paused(&self) -> bool {
        self.paused
    }

    /// Returns human readable representation of the account for the given account ID.
    pub fn get_account(&self, account_id: AccountId) -> HumanReadableAccount {
        let account = self.internal_get_account(&account_id);
        HumanReadableAccount {
            account_id,
            unstaked_balance: account.unstaked.into(),
            staked_balance: self
                .staked_amount_from_num_shares_rounded_down(account.stake_shares)
                .into(),
            can_withdraw: UNSTAKING_DELAY_ENABLED==false || account.unstaked_available_epoch_height <= env::epoch_height(),
        }
    }

    /// Returns the number of accounts that have positive balance on this staking pool.
    pub fn get_number_of_accounts(&self) -> u64 {
        self.accounts.len()
    }

    /// Returns the list of accounts
    pub fn get_accounts(&self, from_index: u64, limit: u64) -> Vec<HumanReadableAccount> {
        let keys = self.accounts.keys_as_vector();

        (from_index..std::cmp::min(from_index + limit, keys.len()))
            .map(|index| self.get_account(keys.get(index).unwrap()))
            .collect()
    }

    /*************/
    /* Callbacks */
    /*************/

    pub fn on_stake_action(&mut self) {
        assert_eq!(
            env::current_account_id(),
            env::predecessor_account_id(),
            "Can be called only as a callback"
        );

        assert_eq!(
            env::promise_results_count(),
            1,
            "Contract expected a result on the callback"
        );
        let stake_action_succeeded = match env::promise_result(0) {
            PromiseResult::Successful(_) => true,
            _ => false,
        };

        env::log(format!(
            "@on_stake_action stake_action_succeeded:{} account_balance:{} locked/stkd:{}", 
            stake_action_succeeded, env::account_balance(), env::account_locked_balance()
        ).as_bytes());

        // If the stake action failed and the current locked amount is positive, then the contract
        // has to unstake.
        if !stake_action_succeeded && env::account_locked_balance() > 0 {
            Promise::new(env::current_account_id()).stake(0, self.stake_public_key.clone());
        }
    }

    /*******************/
    /* Owner's methods */
    /*******************/

    /// Owner's method.
    /// Updates current public key to the new given public key.
    pub fn update_staking_key(&mut self, stake_public_key: Base58PublicKey) {
        self.assert_owner();
        // When updating the staking key, the contract has to restake.
        let _need_to_restake = self.internal_ping();
        self.stake_public_key = stake_public_key.into();
        self.internal_restake();
    }

    /// Owner's method.
    /// Updates current reward fee fraction to the new given fraction.
    pub fn update_reward_fee_fraction(&mut self, reward_fee_fraction: RewardFeeFraction) {
        self.assert_owner();
        reward_fee_fraction.assert_valid();

        let need_to_restake = self.internal_ping();
        self.reward_fee_fraction = reward_fee_fraction;
        if need_to_restake {
            self.internal_restake();
        }
    }

    /// Owner's method.
    /// Calls `vote(is_vote)` on the given voting contract account ID on behalf of the pool.
    pub fn vote(&mut self, voting_account_id: AccountId, is_vote: bool) -> Promise {
        self.assert_owner();
        assert!(
            env::is_valid_account_id(voting_account_id.as_bytes()),
            "Invalid voting account ID"
        );

        ext_voting::vote(is_vote, &voting_account_id, NO_DEPOSIT, VOTE_GAS)
    }

    /// Owner's method.
    /// Pauses pool staking.
    pub fn pause_staking(&mut self) {
        self.assert_owner();
        assert!(!self.paused, "The staking is already paused");

        self.internal_ping();
        self.paused = true;
        if !SIMULATOR_TEST_MODE {
            Promise::new(env::current_account_id()).stake(0, self.stake_public_key.clone());
        }
    }

    /// Owner's method.
    /// Resumes pool staking.
    pub fn resume_staking(&mut self) {
        self.assert_owner();
        assert!(self.paused, "The staking is not paused");

        self.internal_ping();
        self.paused = false;
        self.internal_restake();
    }
}

#[cfg(test)]
mod tests {
    use std::convert::TryFrom;

    use near_sdk::{serde_json, testing_env, MockedBlockchain, VMContext};

    use crate::test_utils::*;

    use super::*;

    struct Emulator {
        pub contract: StakingContract,
        pub epoch_height: EpochHeight,
        pub amount: Balance,
        pub locked_amount: Balance,
        last_total_staked_balance: Balance,
        last_total_stake_shares: Balance,
        context: VMContext,
    }

    fn zero_fee() -> RewardFeeFraction {
        RewardFeeFraction {
            numerator: 0,
            denominator: 1,
        }
    }

    impl Emulator {
        pub fn new(
            owner: String,
            stake_public_key: String,
            reward_fee_fraction: RewardFeeFraction,
        ) -> Self {
            let context = VMContextBuilder::new()
                .current_account_id(owner.clone())
                .account_balance(ntoy(30))
                .finish();
            testing_env!(context.clone());
            let contract = StakingContract::new(
                owner,
                Base58PublicKey::try_from(stake_public_key).unwrap(),
                reward_fee_fraction,
            );
            let last_total_staked_balance = contract.total_staked_balance;
            let last_total_stake_shares = contract.total_stake_shares;
            Emulator {
                contract,
                epoch_height: 0,
                amount: ntoy(30),
                locked_amount: 0,
                last_total_staked_balance,
                last_total_stake_shares,
                context,
            }
        }

        fn verify_stake_price_increase_guarantee(&mut self) {
            let total_staked_balance = self.contract.total_staked_balance;
            let total_stake_shares = self.contract.total_stake_shares;
            assert!(
                U256::from(total_staked_balance) * U256::from(self.last_total_stake_shares)
                    >= U256::from(self.last_total_staked_balance) * U256::from(total_stake_shares),
                "Price increase guarantee was violated."
            );
            self.last_total_staked_balance = total_staked_balance;
            self.last_total_stake_shares = total_stake_shares;
        }

        pub fn update_context(&mut self, predecessor_account_id: String, deposit: Balance) {
            self.verify_stake_price_increase_guarantee();
            self.context = VMContextBuilder::new()
                .current_account_id(staking())
                .predecessor_account_id(predecessor_account_id.clone())
                .signer_account_id(predecessor_account_id)
                .attached_deposit(deposit)
                .account_balance(self.amount)
                .account_locked_balance(self.locked_amount)
                .epoch_height(self.epoch_height)
                .finish();
            testing_env!(self.context.clone());
            println!(
                "Epoch: {}, Deposit: {}, amount: {}, locked_amount: {}",
                self.epoch_height, deposit, self.amount, self.locked_amount
            );
        }

        pub fn simulate_stake_call(&mut self) {
            let total_stake = self.contract.total_staked_balance;
            // Stake action
            self.amount = self.amount + self.locked_amount - total_stake;
            self.locked_amount = total_stake;
            // Second function call action
            self.update_context(staking(), 0);
        }

        pub fn skip_epochs(&mut self, num: EpochHeight) {
            self.epoch_height += num;
            self.locked_amount = (self.locked_amount * (100 + u128::from(num))) / 100;
        }
    }

    #[test]
    fn test_restake_fail() {
        let mut emulator = Emulator::new(
            owner(),
            "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7".to_string(),
            zero_fee(),
        );
        emulator.update_context(bob(), 0);
        emulator.contract.internal_restake();
        let receipts = env::created_receipts();
        assert_eq!(receipts.len(), 2);
        // Mocked Receipt fields are private, so can't check directly.
        assert!(serde_json::to_string(&receipts[0])
            .unwrap()
            .contains("\"actions\":[{\"Stake\":{\"stake\":29999999999999000000000000,"));
        assert!(serde_json::to_string(&receipts[1])
            .unwrap()
            .contains("\"method_name\":\"on_stake_action\""));
        emulator.simulate_stake_call();

        emulator.update_context(staking(), 0);
        testing_env_with_promise_results(emulator.context.clone(), PromiseResult::Failed);
        emulator.contract.on_stake_action();
        let receipts = env::created_receipts();
        assert_eq!(receipts.len(), 1);
        assert!(serde_json::to_string(&receipts[0])
            .unwrap()
            .contains("\"actions\":[{\"Stake\":{\"stake\":0,"));
    }

    #[test]
    fn test_deposit_withdraw() {
        let mut emulator = Emulator::new(
            owner(),
            "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7".to_string(),
            zero_fee(),
        );
        let deposit_amount = ntoy(1_000_000);
        emulator.update_context(bob(), deposit_amount);
        emulator.contract.deposit();
        emulator.amount += deposit_amount;
        emulator.update_context(bob(), 0);
        assert_eq!(
            emulator.contract.get_account_unstaked_balance(bob()).0,
            deposit_amount
        );
        emulator.contract.withdraw(deposit_amount.into());
        assert_eq!(
            emulator.contract.get_account_unstaked_balance(bob()).0,
            0u128
        );
    }

    #[test]
    fn test_stake_with_fee() {
        let mut emulator = Emulator::new(
            owner(),
            "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7".to_string(),
            RewardFeeFraction {
                numerator: 10,
                denominator: 100,
            },
        );
        let deposit_amount = ntoy(1_000_000);
        emulator.update_context(bob(), deposit_amount);
        emulator.contract.deposit();
        emulator.amount += deposit_amount;
        emulator.update_context(bob(), 0);
        emulator.contract.stake(deposit_amount.into());
        emulator.simulate_stake_call();
        assert_eq!(
            emulator.contract.get_account_staked_balance(bob()).0,
            deposit_amount
        );

        let locked_amount = emulator.locked_amount;
        let n_locked_amount = yton(locked_amount);
        emulator.skip_epochs(10);
        // Overriding rewards (+ 100K reward)
        emulator.locked_amount = locked_amount + ntoy(100_000);
        emulator.update_context(bob(), 0);
        emulator.contract.ping();
        let expected_amount = deposit_amount
            + ntoy((yton(deposit_amount) * 90_000 + n_locked_amount / 2) / n_locked_amount);
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(bob()).0,
            expected_amount
        );
        // Owner got 10% of the rewards
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(owner()).0,
            ntoy(10_000)
        );

        let locked_amount = emulator.locked_amount;
        let n_locked_amount = yton(locked_amount);
        emulator.skip_epochs(10);
        // Overriding rewards (another 100K reward)
        emulator.locked_amount = locked_amount + ntoy(100_000);

        emulator.update_context(bob(), 0);
        emulator.contract.ping();
        // previous balance plus (1_090_000 / 1_100_030)% of the 90_000 reward (rounding to nearest).
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(bob()).0,
            expected_amount
                + ntoy((yton(expected_amount) * 90_000 + n_locked_amount / 2) / n_locked_amount)
        );
        // owner earns 10% with the fee and also small percentage from restaking.
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(owner()).0,
            ntoy(10_000)
                + ntoy(10_000)
                + ntoy((10_000u128 * 90_000 + n_locked_amount / 2) / n_locked_amount)
        );

        assert_eq!(emulator.contract.get_number_of_accounts(), 2);
    }

    #[test]
    fn test_stake_unstake() {
        let mut emulator = Emulator::new(
            owner(),
            "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7".to_string(),
            zero_fee(),
        );
        let deposit_amount = ntoy(1_000_000);
        emulator.update_context(bob(), deposit_amount);
        emulator.contract.deposit();
        emulator.amount += deposit_amount;
        emulator.update_context(bob(), 0);
        emulator.contract.stake(deposit_amount.into());
        emulator.simulate_stake_call();
        assert_eq!(
            emulator.contract.get_account_staked_balance(bob()).0,
            deposit_amount
        );
        let locked_amount = emulator.locked_amount;
        // 10 epochs later, unstake half of the money.
        emulator.skip_epochs(10);
        // Overriding rewards
        emulator.locked_amount = locked_amount + ntoy(10);
        emulator.update_context(bob(), 0);
        emulator.contract.ping();
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(bob()).0,
            deposit_amount + ntoy(10)
        );
        emulator.contract.unstake((deposit_amount / 2).into());
        emulator.simulate_stake_call();
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(bob()).0,
            deposit_amount / 2 + ntoy(10)
        );
        assert_eq_in_near!(
            emulator.contract.get_account_unstaked_balance(bob()).0,
            deposit_amount / 2
        );
        let acc = emulator.contract.get_account(bob());
        assert_eq!(acc.account_id, bob());
        assert_eq_in_near!(acc.unstaked_balance.0, deposit_amount / 2);
        assert_eq_in_near!(acc.staked_balance.0, deposit_amount / 2 + ntoy(10));
        assert!(!acc.can_withdraw);

        assert!(!emulator
            .contract
            .is_account_unstaked_balance_available(bob()),);
        emulator.skip_epochs(4);
        emulator.update_context(bob(), 0);
        assert!(emulator
            .contract
            .is_account_unstaked_balance_available(bob()),);
    }

    #[test]
    fn test_stake_all_unstake_all() {
        let mut emulator = Emulator::new(
            owner(),
            "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7".to_string(),
            zero_fee(),
        );
        let deposit_amount = ntoy(1_000_000);
        emulator.update_context(bob(), deposit_amount);
        emulator.contract.deposit_and_stake();
        emulator.amount += deposit_amount;
        emulator.simulate_stake_call();
        assert_eq!(
            emulator.contract.get_account_staked_balance(bob()).0,
            deposit_amount
        );
        assert_eq_in_near!(emulator.contract.get_account_unstaked_balance(bob()).0, 0);
        let locked_amount = emulator.locked_amount;

        // 10 epochs later, unstake all.
        emulator.skip_epochs(10);
        // Overriding rewards
        emulator.locked_amount = locked_amount + ntoy(10);
        emulator.update_context(bob(), 0);
        emulator.contract.ping();
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(bob()).0,
            deposit_amount + ntoy(10)
        );
        emulator.contract.unstake_all();
        emulator.simulate_stake_call();
        assert_eq_in_near!(emulator.contract.get_account_staked_balance(bob()).0, 0);
        assert_eq_in_near!(
            emulator.contract.get_account_unstaked_balance(bob()).0,
            deposit_amount + ntoy(10)
        );
    }

    /// Test that two can delegate and then undelegate their funds and rewards at different time.
    #[test]
    fn test_two_delegates() {
        let mut emulator = Emulator::new(
            owner(),
            "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7".to_string(),
            zero_fee(),
        );
        emulator.update_context(alice(), ntoy(1_000_000));
        emulator.contract.deposit();
        emulator.amount += ntoy(1_000_000);
        emulator.update_context(alice(), 0);
        emulator.contract.stake(ntoy(1_000_000).into());
        emulator.simulate_stake_call();
        emulator.skip_epochs(3);
        emulator.update_context(bob(), ntoy(1_000_000));

        emulator.contract.deposit();
        emulator.amount += ntoy(1_000_000);
        emulator.update_context(bob(), 0);
        emulator.contract.stake(ntoy(1_000_000).into());
        emulator.simulate_stake_call();
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(bob()).0,
            ntoy(1_000_000)
        );
        emulator.skip_epochs(3);
        emulator.update_context(alice(), 0);
        emulator.contract.ping();
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(alice()).0,
            ntoy(1_060_900) - 1
        );
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(bob()).0,
            ntoy(1_030_000)
        );

        // Checking accounts view methods
        // Should be 2, because the pool has 0 fee.
        assert_eq!(emulator.contract.get_number_of_accounts(), 2);
        let accounts = emulator.contract.get_accounts(0, 10);
        assert_eq!(accounts.len(), 2);
        assert_eq!(accounts[0].account_id, alice());
        assert_eq!(accounts[1].account_id, bob());

        let accounts = emulator.contract.get_accounts(1, 10);
        assert_eq!(accounts.len(), 1);
        assert_eq!(accounts[0].account_id, bob());

        let accounts = emulator.contract.get_accounts(0, 1);
        assert_eq!(accounts.len(), 1);
        assert_eq!(accounts[0].account_id, alice());

        let accounts = emulator.contract.get_accounts(2, 10);
        assert_eq!(accounts.len(), 0);
    }

    #[test]
    fn test_low_balances() {
        let mut emulator = Emulator::new(
            owner(),
            "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7".to_string(),
            zero_fee(),
        );
        let initial_balance = 100;
        emulator.update_context(alice(), initial_balance);
        emulator.contract.deposit();
        emulator.amount += initial_balance;
        let mut remaining = initial_balance;
        let mut amount = 1;
        while remaining >= 4 {
            emulator.update_context(alice(), 0);
            amount = 2 + (amount - 1) % 3;
            emulator.contract.stake(amount.into());
            emulator.simulate_stake_call();
            remaining -= amount;
        }
    }

    #[test]
    fn test_rewards() {
        let mut emulator = Emulator::new(
            owner(),
            "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7".to_string(),
            zero_fee(),
        );
        let initial_balance = ntoy(100);
        emulator.update_context(alice(), initial_balance);
        emulator.contract.deposit();
        emulator.amount += initial_balance;
        let mut remaining = 100;
        let mut amount = 1;
        while remaining >= 4 {
            emulator.skip_epochs(3);
            emulator.update_context(alice(), 0);
            emulator.contract.ping();
            emulator.update_context(alice(), 0);
            amount = 2 + (amount - 1) % 3;
            emulator.contract.stake(ntoy(amount).into());
            emulator.simulate_stake_call();
            remaining -= amount;
        }
    }
}

'''
'''--- test-staking-pool/src/test_utils.rs ---
use near_sdk::{AccountId, MockedBlockchain, PromiseResult, VMContext};
use near_sdk::{Balance, BlockHeight, EpochHeight};

pub fn staking() -> AccountId {
    "staking".to_string()
}

pub fn alice() -> AccountId {
    "alice".to_string()
}
pub fn bob() -> AccountId {
    "bob".to_string()
}
pub fn owner() -> AccountId {
    "owner".to_string()
}

pub fn ntoy(near_amount: Balance) -> Balance {
    near_amount * 10u128.pow(24)
}

/// Rounds to nearest
pub fn yton(yocto_amount: Balance) -> Balance {
    (yocto_amount + (5 * 10u128.pow(23))) / 10u128.pow(24)
}

#[macro_export]
macro_rules! assert_eq_in_near {
    ($a:expr, $b:expr) => {
        assert_eq!(yton($a), yton($b))
    };
    ($a:expr, $b:expr, $c:expr) => {
        assert_eq!(yton($a), yton($b), $c)
    };
}

pub struct VMContextBuilder {
    context: VMContext,
}

impl VMContextBuilder {
    pub fn new() -> Self {
        Self {
            context: VMContext {
                current_account_id: "".to_string(),
                signer_account_id: "".to_string(),
                signer_account_pk: vec![0, 1, 2],
                predecessor_account_id: "".to_string(),
                input: vec![],
                epoch_height: 0,
                block_index: 0,
                block_timestamp: 0,
                account_balance: 0,
                account_locked_balance: 0,
                storage_usage: 10u64.pow(6),
                attached_deposit: 0,
                prepaid_gas: 10u64.pow(18),
                random_seed: vec![0, 1, 2],
                is_view: false,
                output_data_receivers: vec![],
            },
        }
    }

    pub fn current_account_id(mut self, account_id: AccountId) -> Self {
        self.context.current_account_id = account_id;
        self
    }

    #[allow(dead_code)]
    pub fn signer_account_id(mut self, account_id: AccountId) -> Self {
        self.context.signer_account_id = account_id;
        self
    }

    pub fn predecessor_account_id(mut self, account_id: AccountId) -> Self {
        self.context.predecessor_account_id = account_id;
        self
    }

    #[allow(dead_code)]
    pub fn block_index(mut self, block_index: BlockHeight) -> Self {
        self.context.block_index = block_index;
        self
    }

    pub fn epoch_height(mut self, epoch_height: EpochHeight) -> Self {
        self.context.epoch_height = epoch_height;
        self
    }

    pub fn attached_deposit(mut self, amount: Balance) -> Self {
        self.context.attached_deposit = amount;
        self
    }

    pub fn account_balance(mut self, amount: Balance) -> Self {
        self.context.account_balance = amount;
        self
    }

    pub fn account_locked_balance(mut self, amount: Balance) -> Self {
        self.context.account_locked_balance = amount;
        self
    }

    pub fn finish(self) -> VMContext {
        self.context
    }
}

pub fn testing_env_with_promise_results(context: VMContext, promise_result: PromiseResult) {
    let storage = near_sdk::env::take_blockchain_interface()
        .unwrap()
        .as_mut_mocked_blockchain()
        .unwrap()
        .take_storage();

    near_sdk::env::set_blockchain_interface(Box::new(MockedBlockchain::new(
        context,
        Default::default(),
        Default::default(),
        vec![promise_result],
        storage,
        Default::default(),
    )));
}

'''
'''--- test.sh ---
#!/bin/bash
set -e

cargo build
cargo test -- --nocapture

'''