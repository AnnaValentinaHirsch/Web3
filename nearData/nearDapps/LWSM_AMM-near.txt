*GitHub Repository "LWSM/AMM-near"*

'''--- README.md ---

## Vanilla AMM on testnet, Near-chain

A simple vanilla AMM on Near-chain. This is a simple example of how AMM works.

  

Two smart contracts are used in this example, token_contract and amm_contract.

  

**token_contract:**

* mainly derived from offical token contract example.

* basic functions like `mint`, `burn`, `transfer` are implemented.

* for AMM testing, only`mint` and `transfer` is applied.

**amm_contract:**

* automatic market making based on a simple market making algorithm.

* $X * Y = K$
 in which $X$ is the amount of the token X, $Y$ is the amount of the token You, and $K$ is a constant.

* each swap garantee that $K$ is unchanged. (i.e. $（X+\delta X) * （Y-\delta Y)  = K$)
in which $\delta X$ is the amount of token $X$, swapped for $\delta Y$, the amount of token $Y$

  
## Prerequisite

Purposeful omission

## Prepare Accounts

NEAR accounts are super readable and the logic is straightforward.
Preparation of accounts (IDs):
```bash
# root account
owner_id=lanceorderly.testnet
# fungible token contact holder
FT_A_contact_id=ft_a_contract.lanceorderly.testnet
FT_B_contact_id=ft_b_contract.lanceorderly.testnet
# fungible token issuer
FT_A_issuer_id=ft_a_mint.lanceorderly.testnet
FT_B_issuer_id=ft_b_mint.lanceorderly.testnet
# amm contact holder
amm_contract_id=amm_contract.lanceorderly.testnet
# amm contact owner
amm_owner_id=amm_owner.lanceorderly.testnet
# amm contact user
user_id=user.lanceorderly.testnet

# an example of account preparation:
near login
near delete $user_id  $owner_id
near create-account $user_id --masterAccount $owner_id --initialBalance 5
```
  

## Build WASM and Deploy
**Build WASM**
```bash

# start from res folder
wdir=$(pwd)
rm *.wasm
cd ../amm-contract
cargo build --target wasm32-unknown-unknown --release
cp ./target/wasm32-unknown-unknown/release/amm_contract.wasm $wdir/amm_contract.wasm
cd ../token-contract
cargo build --target wasm32-unknown-unknown --release
cp ./target/wasm32-unknown-unknown/release/token_contract.wasm $wdir/token_contract.wasm
cd  $wdir

```
**Deploy**
```bash
# fungible token contact
near deploy $FT_A_contact_id --wasmFile="./token_contract.wasm"
near deploy $FT_B_contact_id --wasmFile="./token_contract.wasm"
# amm contact
near deploy $amm_contract_id --wasmFile="./amm_contract.wasm"
```

## AMM preparation
**Mint token and distribute**
```bash
# mint
near call $FT_A_contact_id new_default_meta '{"owner_id":"'$FT_A_issuer_id'", "name":"Token A Contract", "symbol":"TKA", "total_supply":1000000000000000, "decimals": 6}' --accountId=$FT_A_issuer_id

# distribute to amm user and owner, need to storage_deposit first for registration
near call $FT_A_contact_id storage_deposit '{"account_id": "'$amm_owner_id'"}' --accountId=$owner_id --deposit=1
near call $FT_A_contact_id ft_transfer '{"receiver_id": "'$amm_owner_id'","amount":"600000000000000"}' --accountId=$FT_A_issuer_id --deposit=0.000000000000000000000001
```
**Initiate AMM**
```bash
# initiate and deposit and calculate K
near call $amm_contract_id new '{"owner_id":"'$amm_owner_id'", "a_contract_id":"'$FT_A_contact_id'", "b_contract_id":"'$FT_B_contact_id'", "a_init_amount": 500000000000000, "b_init_amount": 100000000000000000}' --accountId=$amm_owner_id --gas=50000000000000
```
## AMM test
```bash
# user swap
near call $amm_contract_id swap_from_a '{"amount":5}' --accountId=$user_id --gas=40000000000000
# owner deposit
near call $amm_contract_id deposit_b_by_owner '{"amount":30000}' --accountId=$amm_owner_id

# view balance and AMM info
near view $amm_contract_id get_info
near view $amm_contract_id get_ratio
near view $FT_A_contact_id ft_balance_of '{"account_id": "'$user_id'"}'
```
## AMM function explains
**Cross Contract Call to Fungible Token contract**
```rust
#[ext_contract(ext_token)]
trait  ExtToken {
fn  get_token_contract_meta_info(&self) -> (String, u8);
fn  account_register(&mut  self);
fn  transfer_from(&mut  self, sender: AccountId, receiver: AccountId, amount: Balance);
}
```
fn for getting token symbol and decimal
```rust
fn  get_token_contract_meta_info(&self) -> (String, u8);
```
fn for registering ID for holding token
```rust
fn  account_register(&mut  self);
```
fn for transfer within Cross-Contract transaction
```rust
fn transfer_from(&mut  self, sender: AccountId, receiver: AccountId, amount: Balance);
```
**Cross Contract Call to AMM self**
```rust
#[ext_contract(ext_self)]
trait  ExtSelf {
fn  callback_get_info(&mut  self, contract_id: AccountId, #[callback] val: (String, u8));
fn  callback_ft_deposit(...);
fn  callback_update_vaults(...);
}
```
fn for getting token symbol and decimal
```rust
fn  callback_get_info(&mut  self, contract_id: AccountId, #[callback] val: (String, u8));
```
CORE fn for transfering token to swap user after user deposit
```rust
fn  callback_ft_deposit(&mut  self,
	a_vault_after: Balance,
	b_vault_after: Balance,
	contract_id: AccountId,
	receiver_id: AccountId,
	amount: Balance,);
```
CORE fn for balance setting and recalculating K
```rust
fn  callback_update_vaults(&mut  self, a_vault_after: Balance, b_vault_after: Balance);
```
**Swap Function** 
decoupled for easier debug. In this function, deposit is first added into pool. The amount of the dependent Token is calculated from  $X * Y = K$. The difference is passed into callback_ft_deposit fn for token settling.
```rust
pub  fn  swap_from_b(&mut  self, amount: Balance) {
let  sender_id = env::predecessor_account_id();
let  b_amount = amount.checked_mul(10_u128.checked_pow(self.b_contract_decimals as  u32).unwrap()).unwrap();
let  b_vault_after = b_amount.checked_add(self.b_vault).unwrap();
let  a_vault_after = self.ratio.checked_div(b_vault_after).unwrap();
let  a_amount = self.a_vault.checked_sub(a_vault_after).unwrap();
ext_token::ext(self.b_contract_id.clone())
.transfer_from(sender_id.clone(), env::current_account_id(), b_amount)
.then(
ext_self::ext(env::current_account_id()).callback_ft_deposit(
a_vault_after,
b_vault_after,
self.a_contract_id.clone(),
sender_id,
a_amount,
),);}

pub  fn  swap_from_b(&mut  self, amount: Balance);
```
**Owner Deposit Function** 
In this process, $K$ will be recalculated. And ratio of $X/Y$ ratio will also be changed.
```rust
#[payable]
pub  fn  deposit_a_by_owner(&mut  self, amount: Balance)

fn  calc_ratio(&mut  self) {
let  a_num = self.a_vault;
let  b_num = self.b_vault;
self.ratio = a_num.checked_mul(b_num).unwrap();
}
```
**Functions for Info Printing** 
```rust
pub  fn  get_info()
pub  fn  get_ratio()
```

'''
'''--- amm-contract/Cargo.toml ---
[package]
name = "amm-contract"
version = "0.1.0"
authors = ["Lance W"]
edition = "2021"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = "4.0.0"
near-contract-standards = "4.0.0"

[profile.release]
codegen-units = 1
opt-level = "s"
lto = true
debug = false
panic = "abort"
overflow-checks = true
'''
'''--- amm-contract/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{env, ext_contract, log, near_bindgen, require, AccountId, Balance, PanicOnDefault};

#[ext_contract(ext_token)]
trait ExtToken {
    fn get_token_contract_meta_info(&self) -> (String, u8);
    fn account_register(&mut self);
    fn transfer_from(&mut self, sender: AccountId, receiver: AccountId, amount: Balance);
}

#[ext_contract(ext_self)]
trait ExtSelf {
    fn callback_get_info(&mut self, contract_id: AccountId, #[callback] val: (String, u8));
    fn callback_ft_deposit(
        &mut self,
        a_vault_after: Balance,
        b_vault_after: Balance,
        contract_id: AccountId,
        receiver_id: AccountId,
        amount: Balance,
    );
    fn callback_update_vaults(&mut self, a_vault_after: Balance, b_vault_after: Balance);
}

#[near_bindgen]
#[derive(PanicOnDefault, BorshDeserialize, BorshSerialize)]
pub struct Contract {
    owner_id: AccountId,
    ratio: u128,
    a_vault: Balance,
    a_contract_id: AccountId,
    a_contract_name: String,
    a_contract_decimals: u8,
    b_vault: Balance,
    b_contract_id: AccountId,
    b_contract_name: String,
    b_contract_decimals: u8,
}

#[near_bindgen]
impl Contract {
    /// Initialization:
    /// Param:
    /// contract owner ID
    /// Program ID of tokens pairs A and B
    /// Initiate amount of tokens pairs A and B
    #[init]
    pub fn new(owner_id: AccountId, a_contract_id: AccountId, b_contract_id: AccountId, a_init_amount: u128, b_init_amount: u128, ) -> Self {
        assert!(!env::state_exists(), "AMM initialized...");

        let this = Self {
            owner_id: owner_id.clone(),
            ratio: 0,
            a_vault: a_init_amount.clone(),
            a_contract_id,
            a_contract_name: "".into(),
            a_contract_decimals: 1,
            b_vault: b_init_amount.clone(),
            b_contract_id,
            b_contract_name: "".into(),
            b_contract_decimals: 1,
        };
        // get symbol and decimal of token pair A and B
        ext_token::ext(this.a_contract_id.clone()).get_token_contract_meta_info().then(
            ext_self::ext(env::current_account_id()).callback_get_info(this.a_contract_id.clone()),
        );
        ext_token::ext(this.b_contract_id.clone()).get_token_contract_meta_info().then(
            ext_self::ext(env::current_account_id()).callback_get_info(this.b_contract_id.clone()),
        );

        // get amm registered to token pair A and B
        ext_token::ext(this.a_contract_id.clone()).account_register();
        ext_token::ext(this.b_contract_id.clone()).account_register();

        // deposit tokens pair A and B to AMM from owner
        ext_token::ext(this.a_contract_id.clone()).transfer_from(owner_id.clone(), env::current_account_id(), a_init_amount.clone());
        ext_token::ext(this.b_contract_id.clone()).transfer_from(owner_id.clone(), env::current_account_id(), b_init_amount.clone());

        this
    }

    pub fn callback_get_info(&mut self, contract_id: AccountId, #[callback] info: (String, u8)) {
        require!(
            env::predecessor_account_id() == env::current_account_id(),
            "Authority Check Failed: Owner function"
        );
        log!("Fill additional info for {}", info.0);
        if contract_id == self.a_contract_id {
            self.a_contract_name = info.0; //symbnol acctually
            self.a_contract_decimals = info.1;
        } else if contract_id == self.b_contract_id {
            self.b_contract_name = info.0;
            self.b_contract_decimals = info.1;
        }
        self.calc_ratio();
    }

    pub fn get_info(
        &self,
    ) -> (
        (AccountId, String, Balance, u8),
        (AccountId, String, Balance, u8),
    ) {
        (
            (
                self.a_contract_id.clone(),
                self.a_contract_name.clone(),
                self.a_vault,
                self.a_contract_decimals,
            ),
            (
                self.b_contract_id.clone(),
                self.b_contract_name.clone(),
                self.b_vault,
                self.b_contract_decimals,
            ),
        )
    }

    pub fn get_ratio(&self) -> u128 {
        self.ratio
    }

    /// calculate CONST K for K = X * Y;
    fn calc_ratio(&mut self) {
        let a_num = self.a_vault;
        let b_num = self.b_vault;
        self.ratio = a_num.checked_mul(b_num).unwrap();
    }

    /// User Swap functions: deposit part, in transfer_from, redeem part in callback_ft_deposit
    #[payable]
    pub fn swap_from_a(&mut self, amount: Balance) {
        let sender_id = env::predecessor_account_id();
        let a_amount = amount.checked_mul(10_u128.checked_pow(self.a_contract_decimals as u32).unwrap()).unwrap();
        // core logic of AMM here
        let a_vault_after = a_amount.checked_add(self.a_vault).unwrap();
        let b_vault_after = self.ratio.checked_div(a_vault_after).unwrap();
        let b_amount = self.b_vault.checked_sub(b_vault_after).unwrap();
        ext_token::ext(self.a_contract_id.clone())
            .transfer_from(sender_id.clone(), env::current_account_id(), a_amount)
            .then(
                ext_self::ext(env::current_account_id()).callback_ft_deposit(
                    a_vault_after,
                    b_vault_after,
                    self.b_contract_id.clone(),
                    sender_id,
                    b_amount,
                ),
            );
    }
    #[payable]
    pub fn swap_from_b(&mut self, amount: Balance) {
        let sender_id = env::predecessor_account_id();
        let b_amount = amount.checked_mul(10_u128.checked_pow(self.b_contract_decimals as u32).unwrap()).unwrap();
        let b_vault_after = b_amount.checked_add(self.b_vault).unwrap();
        let a_vault_after = self.ratio.checked_div(b_vault_after).unwrap();
        let a_amount = self.a_vault.checked_sub(a_vault_after).unwrap();
        ext_token::ext(self.b_contract_id.clone())
            .transfer_from(sender_id.clone(), env::current_account_id(), b_amount)
            .then(
                ext_self::ext(env::current_account_id()).callback_ft_deposit(
                    a_vault_after,
                    b_vault_after,
                    self.a_contract_id.clone(),
                    sender_id,
                    a_amount,
                ),
            );
    }

    /// The owner of the contract can deposit A or B to AMM vault, thereafter change K to maintain the ratio.
    #[payable]
    pub fn deposit_a_by_owner(&mut self, amount: Balance) {
        assert!(
            env::predecessor_account_id() == self.owner_id,
            "Authority Check Failed: Owner function"
        );
        let a_amount = amount.checked_mul(10_u128.checked_pow(self.a_contract_decimals as u32).unwrap()).unwrap();
        let a_vault_after = a_amount.checked_add(self.a_vault).unwrap();
        ext_token::ext(self.a_contract_id.clone())
            .transfer_from(self.owner_id.clone(), env::current_account_id(), a_amount)
            .then(
                ext_self::ext(env::current_account_id())
                    .callback_update_vaults(a_vault_after, self.b_vault),
            );
    }

    #[payable]
    pub fn deposit_b_by_owner(&mut self, amount: Balance) {
        assert!(
            env::predecessor_account_id() == self.owner_id,
            "Authority Check Failed: Owner function"
        );
        let b_amount = amount.checked_mul(10_u128.checked_pow(self.b_contract_decimals as u32).unwrap()).unwrap();
        let b_vault_after = b_amount.checked_add(self.b_vault).unwrap();
        ext_token::ext(self.b_contract_id.clone())
            .transfer_from(self.owner_id.clone(), env::current_account_id(), b_amount)
            .then(
                ext_self::ext(env::current_account_id())
                    .callback_update_vaults(self.a_vault, b_vault_after),
            );
    }

    pub fn callback_ft_deposit(
        &mut self,
        a_vault_after: Balance,
        b_vault_after: Balance,
        contract_id: AccountId,
        receiver_id: AccountId,
        amount: Balance,
    ) {
        assert!(
            env::predecessor_account_id() == env::current_account_id(),
            "Authority Check Failed: self-called function"
        );
        ext_token::ext(contract_id)
            .transfer_from(env::current_account_id(), receiver_id, amount)
            .then(
                ext_self::ext(env::current_account_id())
                    .callback_update_vaults(a_vault_after, b_vault_after),
            );
    }

    pub fn callback_update_vaults(&mut self, a_vault_after: Balance, b_vault_after: Balance) {
        assert!(
            env::predecessor_account_id() == env::current_account_id(),
            "Authority Check Failed: self-called function"
        );
        self.a_vault = a_vault_after;
        self.b_vault = b_vault_after;
        self.calc_ratio();
    }
}

'''
'''--- res/deploy.sh ---
#start from res folder
wdir=$(pwd)
rm *.wasm
cd ../amm-contract
cargo build --target wasm32-unknown-unknown --release
cp ./target/wasm32-unknown-unknown/release/amm_contract.wasm $wdir/amm_contract.wasm
cd ../token-contract
cargo build --target wasm32-unknown-unknown --release
cp ./target/wasm32-unknown-unknown/release/token_contract.wasm $wdir/token_contract.wasm
cd $wdir

#prepare accounts
owner_id=lanceorderly.testnet

FT_A_contact_id=ft_a_contract.lanceorderly.testnet
FT_B_contact_id=ft_b_contract.lanceorderly.testnet
FT_A_issuer_id=ft_a_mint.lanceorderly.testnet
FT_B_issuer_id=ft_b_mint.lanceorderly.testnet

amm_contract_id=amm_contract.lanceorderly.testnet
amm_owner_id=amm_owner.lanceorderly.testnet
user_id=user.lanceorderly.testnet

near delete $FT_A_contact_id $owner_id
near delete $FT_B_contact_id $owner_id
near delete $FT_A_issuer_id $owner_id
near delete $FT_B_issuer_id $owner_id
near delete $amm_contract_id $owner_id
near delete $amm_owner_id $owner_id
near delete $user_id $owner_id

near create-account $FT_A_contact_id --masterAccount $owner_id --initialBalance 5
near create-account $FT_B_contact_id --masterAccount $owner_id --initialBalance 5
near create-account $FT_A_issuer_id --masterAccount $owner_id --initialBalance 5
near create-account $FT_B_issuer_id --masterAccount $owner_id --initialBalance 5
near create-account $amm_owner_id --masterAccount $owner_id --initialBalance 5
near create-account $amm_contract_id --masterAccount $owner_id --initialBalance 5
near create-account $user_id --masterAccount $owner_id --initialBalance 5

#deploy token contracts and mint tokens
near deploy $FT_A_contact_id --wasmFile="./token_contract.wasm"
near deploy $FT_B_contact_id --wasmFile="./token_contract.wasm"
near call $FT_A_contact_id new_default_meta '{"owner_id":"'$FT_A_issuer_id'", "name":"Token A Contract", "symbol":"TKA", "total_supply":1000000000000000, "decimals": 6}' --accountId=$FT_A_issuer_id
near call $FT_B_contact_id new_default_meta '{"owner_id":"'$FT_B_issuer_id'", "name":"Token B Contract", "symbol":"TKB", "total_supply":150000000000000000, "decimals": 9}' --accountId=$FT_B_issuer_id

near view $FT_A_contact_id ft_balance_of '{"account_id": "'$FT_A_issuer_id'"}'
near view $FT_B_contact_id ft_balance_of '{"account_id": "'$FT_B_issuer_id'"}'

# transfer tokens to user and amm owner
near call $FT_A_contact_id storage_deposit '{"account_id": "'$amm_owner_id'"}' --accountId=$owner_id --deposit=1
near call $FT_B_contact_id storage_deposit '{"account_id": "'$amm_owner_id'"}' --accountId=$owner_id --deposit=1
near call $FT_A_contact_id ft_transfer '{"receiver_id": "'$amm_owner_id'","amount":"600000000000000"}' --accountId=$FT_A_issuer_id --deposit=0.000000000000000000000001
near view $FT_A_contact_id ft_balance_of '{"account_id": "'$amm_owner_id'"}'
near call $FT_B_contact_id ft_transfer '{"receiver_id": "'$amm_owner_id'","amount":"120000000000000000"}' --accountId=$FT_B_issuer_id --deposit=0.000000000000000000000001
near view $FT_B_contact_id ft_balance_of '{"account_id": "'$amm_owner_id'"}'

near call $FT_A_contact_id storage_deposit '{"account_id": "'$user_id'"}' --accountId=$owner_id --deposit=0.25
near call $FT_B_contact_id storage_deposit '{"account_id": "'$user_id'"}' --accountId=$owner_id --deposit=0.25
near call $FT_A_contact_id ft_transfer '{"receiver_id": "'$user_id'","amount":"100000000"}' --accountId=$FT_A_issuer_id --deposit=0.000000000000000000000001
near call $FT_B_contact_id ft_transfer '{"receiver_id": "'$user_id'","amount":"300000000000"}' --accountId=$FT_B_issuer_id --deposit=0.000000000000000000000001
near view $FT_A_contact_id ft_balance_of '{"account_id": "'$user_id'"}'
near view $FT_B_contact_id ft_balance_of '{"account_id": "'$user_id'"}'

# deploy amm contract and check balance of AMM and owner
near deploy $amm_contract_id --wasmFile="./amm_contract.wasm"
near call $amm_contract_id new '{"owner_id":"'$amm_owner_id'", "a_contract_id":"'$FT_A_contact_id'", "b_contract_id":"'$FT_B_contact_id'", "a_init_amount": 500000000000000, "b_init_amount": 100000000000000000}' --accountId=$amm_owner_id --gas=50000000000000
near view $FT_A_contact_id ft_balance_of '{"account_id": "'$amm_owner_id'"}'
near view $FT_B_contact_id ft_balance_of '{"account_id": "'$amm_owner_id'"}'
near view $FT_A_contact_id ft_balance_of '{"account_id": "'$amm_contract_id'"}'
near view $FT_B_contact_id ft_balance_of '{"account_id": "'$amm_contract_id'"}'
'''
'''--- res/test.sh ---
#prepare accounts
owner_id=lanceorderly.testnet
FT_A_contact_id=ft_a_contract.lanceorderly.testnet
FT_B_contact_id=ft_b_contract.lanceorderly.testnet
FT_A_issuer_id=ft_a_mint.lanceorderly.testnet
FT_B_issuer_id=ft_b_mint.lanceorderly.testnet
amm_contract_id=amm_contract.lanceorderly.testnet
amm_owner_id=amm_owner.lanceorderly.testnet
user_id=user.lanceorderly.testnet

# test amm contract
near view $amm_contract_id get_info
near view $amm_contract_id get_ratio
near call $amm_contract_id swap_from_a '{"amount":5}' --accountId=$user_id --gas=40000000000000
near view $FT_A_contact_id ft_balance_of '{"account_id": "'$user_id'"}'
near view $FT_B_contact_id ft_balance_of '{"account_id": "'$user_id'"}'
near call $amm_contract_id deposit_b_by_owner '{"amount":30000}' --accountId=$amm_owner_id
near view $amm_contract_id get_info
near view $amm_contract_id get_ratio
'''
'''--- token-contract/Cargo.toml ---
[package]
name = "token-contract"
version = "0.1.0"
authors = ["Lance W"]
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0"
near-contract-standards = "4.0.0"

[profile.release]
codegen-units = 1
opt-level = "s"
lto = true
debug = false
panic = "abort"
overflow-checks = true
'''
'''--- token-contract/src/lib.rs ---
use near_contract_standards;
use near_contract_standards::fungible_token::{
    events::FtTransfer,
    metadata::{FungibleTokenMetadata, FT_METADATA_SPEC},
    FungibleToken,
};
use near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize},
    collections::LazyOption,
    env,
    json_types::U128,
    log, near_bindgen, require, AccountId, Balance, BorshStorageKey, PanicOnDefault,
    PromiseOrValue,
};
/// a basic FungibleToken contract for 2 test tokens
/// Framework Borrowed From Near SDK example
#[near_bindgen]
#[derive(BorshSerialize, BorshDeserialize, PanicOnDefault)]
pub struct Contract {
    token: FungibleToken,
    metadata: LazyOption<FungibleTokenMetadata>,
}

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
    FungibleToken,
    Metadata,
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new_default_meta(
        owner_id: AccountId,
        name: String,
        symbol: String,
        total_supply: Balance,
        decimals: u8,
    ) -> Self {
        Self::new(
            owner_id,
            total_supply,
            FungibleTokenMetadata {
                spec: FT_METADATA_SPEC.to_string(),
                name,
                symbol,
                icon: None,
                reference: None,
                reference_hash: None,
                decimals,
            },
        )
    }

    /// Initializes the contract with the given total supply owned by the given `owner_id` with
    /// the given fungible token metadata.
    #[init]
    pub fn new(
        owner_id: AccountId,
        total_supply: Balance,
        metadata: FungibleTokenMetadata,
    ) -> Self {
        require!(!env::state_exists(), "Already initialized");
        metadata.assert_valid();
        let mut this = Self {
            token: FungibleToken::new(StorageKey::FungibleToken),
            metadata: LazyOption::new(StorageKey::Metadata, Some(&metadata)),
        };
        this.token.internal_register_account(&owner_id);
        this.token.internal_deposit(&owner_id, total_supply.into());
        this
    }

    pub fn get_token_contract_meta_info(self) -> (String, u8) {
        (
            self.metadata.get().unwrap().symbol,
            self.metadata.get().unwrap().decimals,
        )
    }

    #[payable]
    pub fn account_register(&mut self) {
        let wallet_id = env::predecessor_account_id();
        self.token.internal_register_account(&wallet_id);
    }

    #[payable]
    pub fn transfer_from(&mut self, sender: AccountId, receiver: AccountId, amount: Balance) {
        require!(amount > 0, "Attampted to transfer 0 ammount!");
        require!(
            sender != receiver,
            "Attampted to transfer to the same account!"
        );
        require!(
            self.token.internal_unwrap_balance_of(&sender) >= amount,
            "insufficient balance"
        );
        self.token.internal_withdraw(&sender, amount);
        if !self.token.accounts.contains_key(&receiver) {
            log!("Account {} does not exist, creating it", receiver);
            self.token.internal_register_account(&receiver);
        }
        self.token.internal_deposit(&receiver, amount);
        FtTransfer {
            old_owner_id: &sender,
            new_owner_id: &receiver,
            amount: &U128(amount),
            memo: None,
        }
        .emit();
    }
    // need to look into these functions latter
    fn on_account_closed(&mut self, account_id: AccountId, balance: Balance) {
        log!("Closed @{} with {}", account_id, balance);
    }

    fn on_tokens_burned(&mut self, account_id: AccountId, amount: Balance) {
        log!("Account @{} burned {}", account_id, amount);
    }
}

near_contract_standards::impl_fungible_token_core!(Contract, token, on_tokens_burned);
near_contract_standards::impl_fungible_token_storage!(Contract, token, on_account_closed);

#[cfg(all(test, not(target_arch = "wasm32")))]
mod tests {
    use near_sdk::test_utils::{accounts, VMContextBuilder};
    use near_sdk::testing_env;

    use super::*;
    fn get_context(predecessor_account_id: AccountId) -> VMContextBuilder {
        let mut builder = VMContextBuilder::new();
        builder
            .current_account_id(accounts(0))
            .signer_account_id(predecessor_account_id.clone())
            .predecessor_account_id(predecessor_account_id);
        builder
    }
    const TOTAL_SUPPLY: Balance = 10_000_000_000_000;
    const DECIMALS: u8 = 6;

    #[test]
    fn test_new() {
        let mut context = get_context(accounts(1));
        let name = "TEST Token Contract";
        let symbol = "TEST";

        testing_env!(context.build());
        let contract = Contract::new(
            accounts(1).into(),
            TOTAL_SUPPLY,
            FungibleTokenMetadata {
                spec: FT_METADATA_SPEC.to_string(),
                name: name.into(),
                symbol: symbol.into(),
                icon: None,
                reference: None,
                reference_hash: None,
                decimals: DECIMALS,
            },
        );
        testing_env!(context.is_view(true).build());
        assert_eq!(contract.ft_total_supply().0, TOTAL_SUPPLY);
        assert_eq!(contract.ft_balance_of(accounts(1)).0, TOTAL_SUPPLY);
        assert_eq!(
            contract.get_token_contract_meta_info(),
            (symbol.into(), DECIMALS)
        );
    }

    #[test]
    #[should_panic(expected = "The contract is not initialized")]
    fn test_default() {
        let context = get_context(accounts(1));
        testing_env!(context.build());
        let _contract = Contract::default();
    }

    #[test]
    fn test_transfer() {
        let mut context = get_context(accounts(2));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(
            accounts(2).into(),
            "TEST Token Contract".to_string(),
            "TEST".to_string(),
            TOTAL_SUPPLY.into(),
            DECIMALS,
        );
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(contract.storage_balance_bounds().min.into())
            .predecessor_account_id(accounts(1))
            .build());
        // Paying for account registration, aka storage deposit
        contract.storage_deposit(None, None);

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(1)
            .predecessor_account_id(accounts(2))
            .build());
        let transfer_amount: Balance = 1_000_000_000_000;
        contract.ft_transfer(accounts(1), transfer_amount.into(), None);

        testing_env!(context
            .storage_usage(env::storage_usage())
            .account_balance(env::account_balance())
            .is_view(true)
            .attached_deposit(0)
            .build());
        assert_eq!(
            contract.ft_balance_of(accounts(2)).0,
            (TOTAL_SUPPLY - transfer_amount)
        );
        assert_eq!(contract.ft_balance_of(accounts(1)).0, transfer_amount);
    }
}

'''