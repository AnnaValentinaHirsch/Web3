*GitHub Repository "near-examples/update-migrate-rust"*

'''--- .devcontainer/devcontainer.json ---
{
  "name": "NEAR Devcontainer Rust",

  "image": "ghcr.io/near/near-devcontainer:latest",

  // Uncomment and modify the following lines if necessary
  // "forwardPorts": [8000],
}

'''
'''--- .github/workflows/tests.yml ---
name: CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  workflows:
    strategy:
      matrix:
        platform: [ubuntu-latest, macos-latest]
    runs-on: ${{ matrix.platform }}

    steps:
    - name: Checkout Repository
      uses: actions/checkout@v4

    - name: "Install stable Rust version"
      uses: actions-rs/toolchain@v1
      with:
        profile: minimal
        toolchain: stable
        default: true
        target: wasm32-unknown-unknown

    - name: Run cargo test
      run: cargo test --workspace
'''
'''--- Cargo.toml ---
[profile.release]
codegen-units = 1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[workspace]
members = [
    "basic-updates/base",
    "basic-updates/update",
    "enum-updates/base",
    "enum-updates/update",
    "self-updates/base",
    "self-updates/update",
]
'''
'''--- README.md ---
# Contract's Update & State Migration
[![](https://img.shields.io/badge/⋈%20Examples-Intermediate-orange)](https://docs.near.org/tutorials/welcome)
[![](https://img.shields.io/badge/Contract-rust-red)](https://docs.near.org/develop/contracts/anatomy)
[![](https://img.shields.io/badge/Frontend-None-gray)](https://docs.near.org/develop/integrate/frontend)
[![](https://img.shields.io/github/workflow/status/near-examples/update-migrate-rust/Tests/main?color=green&label=Tests)](https://github.com/near-examples/update-migrate-rust/actions/workflows/tests.yml)

Three examples on how to handle updates and [state migration](https://docs.near.org/develop/upgrade/migration):
1. [State Migration](./basic-updates/): How to implement a `migrate` method to migrate state between contract updates.
2. [State Versioning](./enum-updates/): How to use readily use versioning on a state, to simplify updating it later.
3. [Self Update](./self-updates/): How to implement a contract that can update itself.

<br />

## 1. [State Migration](./basic-updates/)
The examples at [./basic-updates](./basic-updates) show how to handle state-breaking changes
between contract updates.

It is composed by 2 contracts:
1. Base: A Guest Book where people can write messages.
2. Update: An update in which we remove a parameter and change the internal structure.

```rust
#[private]
#[init(ignore_state)]
pub fn migrate() -> Self {
    // retrieve the current state from the contract
    let old_state: OldState = env::state_read().expect("failed");

    // iterate through the state migrating it to the new version
    let mut new_messages: Vector<PostedMessage> = Vector::new(b"p");

    for (idx, posted) in old_state.messages.iter().enumerate() {
        let payment = old_state
            .payments
            .get(idx as u64)
            .unwrap_or(NearToken::from_near(0));

        new_messages.push(&PostedMessage {
            payment,
            premium: posted.premium,
            sender: posted.sender,
            text: posted.text,
        })
    }

    // return the new state
    Self {
        messages: new_messages,
    }
}
```

<br />

## 2. [State Versioning](./enum-updates/)
The example at [./enum-updates/](./enum-updates/) shows how to use
[Enums](https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html) to implement versioning.

Versioning simplifies updating the contract since you only need to add a new new version of the structure.
All versions can coexist, thus you will not need to change previously existing structures. 

The example is composed by 2 contracts:
1. Base: The [guest-book](https://github.com/near-examples/guest-book-rust) contract using versioned `PostedMessages` (`PostedMessagesV1`).
2. Update: An update that adds a new version of `PostedMessages` (`PostedMessagesV2`).

```rust
#[near(serializers=[borsh])]
pub enum VersionedPostedMessage {
    V1(PostedMessageV1),
    V2(PostedMessageV2),
}

impl From<VersionedPostedMessage> for PostedMessageV2 {
    fn from(message: VersionedPostedMessage) -> Self {
        match message {
            VersionedPostedMessage::V2(posted) => posted,
            VersionedPostedMessage::V1(posted) => PostedMessageV2 {
                payment: NearToken::from_near(0),
                premium: posted.premium,
                sender: posted.sender,
                text: posted.text,
            },
        }
    }
}
```

<br />

## 3. [Self Update](./self-updates/)
The examples at [./self-updates](./self-updates) shows how to implement a contract
that can update itself.

It is composed by 2 contracts:
1. Base: A Guest Book were people can write messages, implementing a `update_contract` method.
2. Update: An update in which we remove a parameter and change the internal structure.

```rust
pub fn update_contract(&self) -> Promise {
    // Check the caller is authorized to update the code
    assert!(
        env::predecessor_account_id() == self.manager,
        "Only the manager can update the code"
    );

    // Receive the code directly from the input to avoid the
    // GAS overhead of deserializing parameters
    let code = env::input().expect("Error: No input").to_vec();

    // Deploy the contract on self
    Promise::new(env::current_account_id())
        .deploy_contract(code)
        .function_call(
            "migrate".to_string(),
            NO_ARGS,
            NearToken::from_near(0),
            CALL_GAS,
        )
        .as_return()
}
```

<br />

# Quickstart

Clone this repository locally or open it in a codespace using the green `<> Code` button above. Then follow these steps:

### 0. Test the Contract
Deploy your contract in a sandbox and simulate interactions from users.

```bash
cargo test --workspace
```

### 1. Examples' cli-s versions

Commands in each contract's `README` are valid for following versions of programs.

```bash
# NEAR CLI
❯ near --version
4.0.10

# near-cli-rs 
❯ near --version
near-cli-rs 0.8.1

❯ cargo near --version
cargo-near-near 0.6.1
```

`NOTE`: default devcontainer for Codespaces contains only `near-cli-rs` and `cargo-near` commands. 

### 2. Accounts for deploying contracts from these examples can be created by:  

```bash
# NEAR CLI
near create-account <target-account-id> --useFaucet
# near-cli-rs 
near account create-account sponsor-by-faucet-service <target-account-id> autogenerate-new-keypair save-to-keychain network-config testnet create
```

`NOTE`: default devcontainer for Codespaces only supports `save-to-legacy-keychain` option instead of `save-to-keychain` of `near-cli-rs`. 

---

# Learn More
1. Learn more on each contract's `README`.
2. Check [**our documentation**](https://docs.near.org/develop/welcome).

'''
'''--- basic-updates/base/Cargo.toml ---
[package]
name = "base"
version = "1.0.0"
authors = ["Near Inc <hello@near.org>"]
edition = "2021"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = { version = "5.1.0", features = ["legacy"] }

'''
'''--- basic-updates/base/README.md ---
# Guest Book Contract

The smart contract stores messages, keeping track of how much money was deposited when adding the message.

```rust
#[payable]
pub fn add_message(&mut self, text: String) {
  let payment = env::attached_deposit();
  let premium = payment >= POINT_ONE;
  let sender = env::predecessor_account_id();

  let message = PostedMessage {
    premium,
    sender,
    text,
  };
  self.messages.push(&message);
  self.payments.push(&payment);
}
```

<br />

# Quickstart

## 1. Build and Deploy the Contract
Install [`cargo-near`](https://github.com/near/cargo-near) and run:

```bash
# from repo root
cd basic-updates/base
cargo near build
```

Build and deploy: 

```bash
# `update-migrate-rust-basic-updates-base.testnet` was used as example of <target-account-id>
cargo near deploy <target-account-id> without-init-call network-config testnet sign-with-keychain send
```
## 2. How to interact?

_In this example we will be using [NEAR CLI](https://github.com/near/near-cli)
to intract with the NEAR blockchain and the smart contract and [near-cli-rs](https://near.cli.rs)
which provides more control over interactions and has interactive menus for subcommands selection_

### 1. Add a Message
```bash
# NEAR CLI
near call <target-account-id> add_message '{"text": "a message"}' --amount 0.1 --accountId <account>
# near-cli-rs 
near contract call-function as-transaction <target-account-id> add_message json-args '{"text": "a message"}' prepaid-gas '100.0 Tgas' attached-deposit '0.1 NEAR' sign-as <account> network-config testnet sign-with-keychain send
```
<br />

### 2. Retrieve the Stored Messages & Payments
`get_messages` and `get_payments` are read-only method (`view` method)

```bash
# NEAR CLI
near view <target-account-id> get_messages
# near-cli-rs 
near contract call-function as-read-only <target-account-id> get_messages json-args {} network-config testnet now
# NEAR CLI
near view <target-account-id> get_payments
# near-cli-rs 
near contract call-function as-read-only <target-account-id> get_payments json-args {} network-config testnet now
```

<br />

### 3. Continue in the Update Folder
Navigate to the [update](../update/) folder to continue

'''
'''--- basic-updates/base/src/lib.rs ---
use near_sdk::near;

use near_sdk::collections::Vector;
use near_sdk::json_types::{U128, U64};

use near_sdk::{env, AccountId, NearToken};

const POINT_ONE: NearToken = NearToken::from_millinear(100);

#[near(serializers=[json, borsh])]
pub struct PostedMessage {
    pub premium: bool,
    pub sender: AccountId,
    pub text: String,
}

#[near(contract_state)]
pub struct GuestBook {
    messages: Vector<PostedMessage>,
    payments: Vector<NearToken>,
}

impl Default for GuestBook {
    fn default() -> Self {
        Self {
            messages: Vector::new(b"m"),
            payments: Vector::new(b"p"),
        }
    }
}

#[near]
impl GuestBook {
    #[payable]
    pub fn add_message(&mut self, text: String) {
        let payment = env::attached_deposit();
        let premium = payment >= POINT_ONE;
        let sender = env::predecessor_account_id();

        let message = PostedMessage {
            premium,
            sender,
            text,
        };
        self.messages.push(&message);
        self.payments.push(&payment);
    }

    pub fn get_messages(&self, from_index: Option<U128>, limit: Option<U64>) -> Vec<PostedMessage> {
        let from = u128::from(from_index.unwrap_or(U128(0)));

        self.messages
            .iter()
            .skip(from as usize)
            .take(u64::from(limit.unwrap_or(U64::from(10))) as usize)
            .collect()
    }

    pub fn get_payments(&self, from_index: Option<U128>, limit: Option<U64>) -> Vec<U128> {
        let from = u128::from(from_index.unwrap_or(U128(0)));

        self.payments
            .iter()
            .skip(from as usize)
            .take(u64::from(limit.unwrap_or(U64::from(10))) as usize)
            .map(|x| U128(x.as_yoctonear()))
            .collect()
    }
}

'''
'''--- basic-updates/update/Cargo.toml ---
[package]
name = "update"
version = "1.0.0"
authors = ["Near Inc <hello@near.org>"]
edition = "2021"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = { version = "5.1.0", features = ["legacy"] }

[dev-dependencies]
near-sdk = { version = "5.1.0" }
near-workspaces = { version = "0.10.0", features = ["unstable"] }
tokio = { version = "1.12.0", features = ["full"] }
serde_json = "1"
rstest = "0.18.2"

'''
'''--- basic-updates/update/README.md ---
# Guest Book Contract

The [base](../base) contract was modified, removing the `payments` field
and including that information in the `PostedMessage` structure.

```rust
pub struct PostedMessage {
    pub payment: NearToken,
    pub premium: bool,
    pub sender: AccountId,
    pub text: String,
}

pub struct GuestBook {
  messages: Vector<PostedMessage>,
}
```

If we deploy this contract on top of the [base](../base/) one and call any method we will get the error:

```
panicked at 'Cannot deserialize the contract state.: ... }',
``` 

This is because the new contract expects to find `PostedMessages` with 4 fields (`payment`, `premium`, `sender`, `text`)
but the saved messages only have 3 fields (they lack the `payment` field).

In order to fix this problem we need to `migrate` the state, i.e. iterate through the current saved messages
transforming them to the new version.

```rust
#[private]
#[init(ignore_state)]
pub fn migrate() -> Self {
    // retrieve the current state from the contract
    let old_state: OldState = env::state_read().expect("failed");

    // iterate through the state migrating it to the new version
    let mut new_messages: Vector<PostedMessage> = Vector::new(b"p");

    for (idx, posted) in old_state.messages.iter().enumerate() {
        let payment = old_state
            .payments
            .get(idx as u64)
            .unwrap_or(NearToken::from_near(0));

        new_messages.push(&PostedMessage {
            payment,
            premium: posted.premium,
            sender: posted.sender,
            text: posted.text,
        })
    }

    // return the new state
    Self {
        messages: new_messages,
    }
}
```

<br />

# Upgrading Base Contract

## 1. Build & Deploy & Migrate State

_In this example we will be using [NEAR CLI](https://github.com/near/near-cli)
to intract with the NEAR blockchain and the smart contract and [near-cli-rs](https://near.cli.rs)
which provides more control over interactions and has interactive menus for subcommands selection_

To build contract install [`cargo-near`](https://github.com/near/cargo-near) and run:

```bash
# from repo root
cd basic-updates/update
cargo near build
```

You can deploy the updated contract by running:

```bash
# `update-migrate-rust-basic-updates-base.testnet` was used as example of <target-account-id>
# NEAR CLI
near deploy <target-account-id> ../../target/near/update/update.wasm
# near-cli-rs 
near contract deploy <target-account-id> use-file ../../target/near/update/update.wasm without-init-call network-config testnet sign-with-keychain send
```

Run this command to see the "Cannot deserialize..." error
```bash
# NEAR CLI
near view <target-account-id> get_messages
# near-cli-rs 
near contract call-function as-read-only <target-account-id> get_messages json-args {} network-config testnet now
```

Ask the contract to migrate the state

```bash
# NEAR CLI
near call <target-account-id> migrate {} --accountId <target-account-id>
# near-cli-rs (may be useful to specify more gas for large state migrations)
near contract call-function as-transaction <target-account-id> migrate json-args {} prepaid-gas '100.0 Tgas' attached-deposit '0 NEAR' sign-as <target-account-id> network-config testnet sign-with-keychain send
```

#### Deploying and Migrating
You can actually deploy the contract and migrate the state in one line:

```bash
# NEAR CLI
near deploy <target-account-id> ../../target/near/update/update.wasm --initFunction migrate --initArgs {}
# near-cli-rs (may be useful to specify more gas for large state migrations)
near contract deploy <target-account-id> use-file ../../target/near/update/update.wasm with-init-call migrate json-args {} prepaid-gas '100.0 Tgas' attached-deposit '0 NEAR' network-config testnet sign-with-keychain send
```

<br />

## 2. Retrieve the Stored Messages
`get_messages` will now return messages that include a `payment` field.

```bash
# NEAR CLI
near view <target-account-id> get_messages
```

`get_payments` will raise an error since the method does not exist anymore.

```bash
# NEAR CLI
# raises an error since the method is gone
near view <target-account-id> get_payments
```

'''
'''--- basic-updates/update/src/lib.rs ---
use near_sdk::near;

use near_sdk::collections::Vector;
use near_sdk::json_types::{U64, U128};

use near_sdk::{env, AccountId, NearToken};

mod migrate;

const POINT_ONE: NearToken = NearToken::from_millinear(100);

#[near(serializers=[json, borsh])]
pub struct PostedMessage {
    pub payment: NearToken,
    pub premium: bool,
    pub sender: AccountId,
    pub text: String,
}

#[near(contract_state)]
pub struct GuestBook {
    messages: Vector<PostedMessage>,
}

impl Default for GuestBook {
    fn default() -> Self {
        Self {
            messages: Vector::new(b"m"),
        }
    }
}

#[near]
impl GuestBook {
    #[payable]
    pub fn add_message(&mut self, text: String) {
        let payment = env::attached_deposit();
        let sender = env::predecessor_account_id();
        let premium = payment >= POINT_ONE;
        let message = PostedMessage {
            payment,
            sender,
            premium,
            text,
        };
        self.messages.push(&message);
    }

    pub fn get_messages(&self, from_index: Option<U128>, limit: Option<U64>) -> Vec<PostedMessage> {
        let from = u128::from(from_index.unwrap_or(U128(0)));

        self.messages
            .iter()
            .skip(from as usize)
            .take(u64::from(limit.unwrap_or(U64::from(10))) as usize)
            .collect()
    }
}

'''
'''--- basic-updates/update/src/migrate.rs ---
use crate::*;

#[near(serializers=[borsh])]
pub struct OldPostedMessage {
    pub premium: bool,
    pub sender: AccountId,
    pub text: String,
}

#[near(serializers=[borsh])]
pub struct OldState {
    messages: Vector<OldPostedMessage>,
    payments: Vector<NearToken>,
}

#[near]
impl GuestBook {
    #[private]
    #[init(ignore_state)]
    pub fn migrate() -> Self {
        // retrieve the current state from the contract
        let old_state: OldState = env::state_read().expect("failed");

        // iterate through the state migrating it to the new version
        let mut new_messages: Vector<PostedMessage> = Vector::new(b"p");

        for (idx, posted) in old_state.messages.iter().enumerate() {
            let payment = old_state
                .payments
                .get(idx as u64)
                .unwrap_or(NearToken::from_near(0));

            new_messages.push(&PostedMessage {
                payment,
                premium: posted.premium,
                sender: posted.sender,
                text: posted.text,
            })
        }

        // return the new state
        Self {
            messages: new_messages,
        }
    }
}

'''
'''--- basic-updates/update/tests/workspaces.rs ---
use rstest::{fixture, rstest};
use std::fs;

use near_workspaces::{types::NearToken, Account, Contract};
use serde_json::json;

use near_sdk::{json_types::U128, AccountId};

const FIVE_NEAR: NearToken = NearToken::from_near(5);
const ONE_TENTH_NEAR: NearToken = NearToken::from_millinear(100);
const NINE_HUNDREDTH_NEAR: NearToken = NearToken::from_millinear(90);

struct Common {
    contract: Contract,
    alice: Account,
    guest_book: Account,
}

#[fixture]
async fn base_contract() -> Common {
    let sandbox = near_workspaces::sandbox().await.unwrap();

    fs::create_dir_all("../../target/near/base").unwrap();
    let contract_wasm = near_workspaces::compile_project("../base").await.unwrap();
    let root = sandbox.root_account().unwrap();
    let guest_book_account = root.create_subaccount("gbook").initial_balance(FIVE_NEAR).transact().await.unwrap().unwrap();

    let contract = guest_book_account
        .deploy(&contract_wasm)
        .await
        .unwrap()
        .into_result()
        .unwrap();

    let alice = root.create_subaccount("alice").initial_balance(FIVE_NEAR).transact().await.unwrap().unwrap();

    let guest_book_message_outcome = guest_book_account
        .call(contract.id(), "add_message")
        .args_json(json!({"text": "hello"}))
        .deposit(NINE_HUNDREDTH_NEAR)
        .transact()
        .await
        .unwrap();

    assert!(guest_book_message_outcome.is_success());

    let alice_first_message_outcome = alice
        .call(contract.id(), "add_message")
        .args_json(json!({"text": "bye"}))
        .deposit(ONE_TENTH_NEAR)
        .transact()
        .await
        .unwrap();

    assert!(alice_first_message_outcome.is_success());

    Common {
        contract,
        alice,
        guest_book: guest_book_account,
    }
}

#[rstest]
#[tokio::test]
async fn test_basic_updates_base_contract_returns(
    #[future] base_contract: Common,
) -> Result<(), Box<dyn std::error::Error>> {
    let base_contract = base_contract.await;

    #[derive(near_sdk::serde::Deserialize, Debug, PartialEq, Eq)]
    #[serde(crate = "near_sdk::serde")]
    pub struct PostedMessage {
        pub premium: bool,
        pub sender: AccountId,
        pub text: String,
    }
    let messages_vec: Vec<PostedMessage> = base_contract
        .contract
        .view("get_messages")
        .args_json(json!({}))
        .await?
        .json()?;

    assert_eq!(
        messages_vec,
        vec![
            PostedMessage {
                premium: false,
                sender: base_contract.guest_book.id().clone(),
                text: "hello".to_string(),
            },
            PostedMessage {
                premium: true,
                sender: base_contract.alice.id().clone(),
                text: "bye".to_string(),
            },
        ]
    );
    let payments_vec: Vec<U128> = base_contract
        .contract
        .view("get_payments")
        .args_json(json!({}))
        .await?
        .json()?;

    assert_eq!(
        payments_vec,
        vec![
            U128(NINE_HUNDREDTH_NEAR.as_yoctonear()),
            U128(ONE_TENTH_NEAR.as_yoctonear())
        ]
    );

    Ok(())
}

#[rstest]
#[tokio::test]
async fn test_basic_updates_migration(
    #[future] base_contract: Common,
) -> Result<(), Box<dyn std::error::Error>> {
    let base_contract = base_contract.await;

    fs::create_dir_all("../../target/near/update").unwrap();
    let updated_contract_wasm = near_workspaces::compile_project("./").await.unwrap();

    let migrated_contract = base_contract
        .guest_book
        .deploy(&updated_contract_wasm)
        .await
        .unwrap()
        .into_result()
        .unwrap();

    let migrate_call_outcome = base_contract
        .guest_book
        .call(migrated_contract.id(), "migrate")
        .args_json(json!({}))
        .transact()
        .await
        .unwrap();

    assert!(migrate_call_outcome.is_success());

    #[derive(near_sdk::serde::Deserialize, Debug, PartialEq, Eq)]
    #[serde(crate = "near_sdk::serde")]
    pub struct PostedMessage {
        pub payment: NearToken,
        pub premium: bool,
        pub sender: AccountId,
        pub text: String,
    }
    let messages_vec: Vec<PostedMessage> = migrated_contract
        .view("get_messages")
        .args_json(json!({}))
        .await?
        .json()?;
    assert_eq!(
        messages_vec,
        vec![
            PostedMessage {
                payment: NINE_HUNDREDTH_NEAR,
                premium: false,
                sender: base_contract.guest_book.id().clone(),
                text: "hello".to_string(),
            },
            PostedMessage {
                payment: ONE_TENTH_NEAR,
                premium: true,
                sender: base_contract.alice.id().clone(),
                text: "bye".to_string(),
            },
        ]
    );
    let get_payments_result = migrated_contract
        .view("get_payments")
        .args_json(json!({}))
        .await;

    assert!(get_payments_result.is_err());
    Ok(())
}

'''
'''--- enum-updates/base/Cargo.toml ---
[package]
name = "enums-base"
version = "1.0.0"
authors = ["Near Inc <hello@near.org>"]
edition = "2021"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = { version = "5.1.0", features = ["legacy"] }

'''
'''--- enum-updates/base/README.md ---
# Guest Book Contract - Versioned Messages

The smart contract stores **versioned** messages. This simplifies further updates of the contract.

```rust
// Versioned Messages
pub struct PostedMessageV1 {
    pub premium: bool,
    pub sender: AccountId,
    pub text: String,
}

pub enum VersionedPostedMessage {
    V1(PostedMessageV1),
}

// Smart Contract
pub struct GuestBook {
    messages: Vector<VersionedPostedMessage>,
}

pub fn add_message(&mut self, text: String) {
    let payment = env::attached_deposit();
    let sender = env::predecessor_account_id();
    let premium = payment > POINT_ONE;
    let message = VersionedPostedMessage::V1(PostedMessageV1 {
        sender,
        premium,
        text,
    });
    self.messages.push(&message);
}
```

<br />

# Quickstart

## 1. Build and Deploy the Contract
Install [`cargo-near`](https://github.com/near/cargo-near) and run:

```bash
# from repo root
cd enum-updates/base
cargo near build
```

Build and deploy: 

```bash
# `update-migrate-rust-enum-updates.testnet` was used as example of <target-account-id>
cargo near deploy <target-account-id> without-init-call network-config testnet sign-with-keychain send
```

## 2. How to interact?

_In this example we will be using [NEAR CLI](https://github.com/near/near-cli)
to intract with the NEAR blockchain and the smart contract and [near-cli-rs](https://near.cli.rs)
which provides more control over interactions and has interactive menus for subcommands selection_

### 1. Add a Message

```bash
# NEAR CLI
near call <target-account-id> add_message '{"text": "a message"}' --amount 0.1 --accountId <account>
# near-cli-rs 
near contract call-function as-transaction <target-account-id> add_message json-args '{"text": "a message"}' prepaid-gas '100.0 Tgas' attached-deposit '0.1 NEAR' sign-as <account> network-config testnet sign-with-keychain send
```

<br />

### 2. Retrieve the Messages
```bash
# NEAR CLI
near view <target-account-id> get_messages
# near-cli-rs 
near contract call-function as-read-only <target-account-id> get_messages json-args {} network-config testnet now
```

<br />

### 3. Continue in the Update Folder
Navigate to the [update](../update/) folder to continue

'''
'''--- enum-updates/base/src/lib.rs ---
use near_sdk::near;

use near_sdk::collections::Vector;
use near_sdk::json_types::{U64, U128};

use near_sdk::{env, AccountId, NearToken};

use versioned_msg::{PostedMessageV1, VersionedPostedMessage};
mod versioned_msg;

const POINT_ONE: NearToken = NearToken::from_millinear(100);

#[near(contract_state)]
pub struct GuestBook {
    messages: Vector<VersionedPostedMessage>,
}

impl Default for GuestBook {
    fn default() -> Self {
        Self {
            messages: Vector::new(b"m"),
        }
    }
}

#[near]
impl GuestBook {
    #[payable]
    pub fn add_message(&mut self, text: String) {
        let payment = env::attached_deposit();
        let sender = env::predecessor_account_id();
        let premium = payment >= POINT_ONE;
        let message = VersionedPostedMessage::V1(PostedMessageV1 {
            sender,
            premium,
            text,
        });
        self.messages.push(&message);
    }

    pub fn get_messages(
        &self,
        from_index: Option<U128>,
        limit: Option<U64>,
    ) -> Vec<PostedMessageV1> {
        let from = u128::from(from_index.unwrap_or(U128(0)));

        self.messages
            .iter()
            .skip(from as usize)
            .take(u64::from(limit.unwrap_or(U64::from(10))) as usize)
            .map(|message| message.into())
            .collect()
    }
}

'''
'''--- enum-updates/base/src/versioned_msg.rs ---
use crate::*;

#[near(serializers=[borsh,json])]
pub struct PostedMessageV1 {
    pub premium: bool,
    pub sender: AccountId,
    pub text: String,
}

#[near(serializers=[borsh])]
pub enum VersionedPostedMessage {
    V1(PostedMessageV1),
}

impl From<VersionedPostedMessage> for PostedMessageV1 {
    fn from(message: VersionedPostedMessage) -> Self {
        match message {
            VersionedPostedMessage::V1(posted) => posted,
        }
    }
}

'''
'''--- enum-updates/update/Cargo.toml ---
[package]
name = "enums-update"
version = "1.0.0"
authors = ["Near Inc <hello@near.org>"]
edition = "2021"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = { version = "5.1.0", features = ["legacy"] }

[dev-dependencies]
near-sdk = { version = "5.1.0" }
near-workspaces = { version = "0.10.0", features = ["unstable"] }
tokio = { version = "1.12.0", features = ["full"] }
serde_json = "1"

'''
'''--- enum-updates/update/README.md ---
# Guest Book Contract - Versioned Messages Update

This examples adds a new version to the **versioned** messages of the [enum-base](../base/) contracts.

```rust
pub struct PostedMessageV1 {
    pub premium: bool,
    pub sender: AccountId,
    pub text: String,
}

pub struct PostedMessageV2 {
    pub payment: NearToken,
    pub premium: bool,
    pub sender: AccountId,
    pub text: String,
}

pub enum VersionedPostedMessage {
    V1(PostedMessageV1),
    V2(PostedMessageV2),
}

impl From<VersionedPostedMessage> for PostedMessageV2 {
    fn from(message: VersionedPostedMessage) -> Self {
        match message {
            VersionedPostedMessage::V2(posted) => posted,
            VersionedPostedMessage::V1(posted) => PostedMessageV2 {
                payment: NearToken::from_near(0),
                premium: posted.premium,
                sender: posted.sender,
                text: posted.text,
            },
        }
    }
}
```

<br />

# Quickstart

## 1. Deploy the Contract

_In this example we will be using [NEAR CLI](https://github.com/near/near-cli)
to intract with the NEAR blockchain and the smart contract and [near-cli-rs](https://near.cli.rs)
which provides more control over interactions and has interactive menus for subcommands selection_

To build contract install [`cargo-near`](https://github.com/near/cargo-near) and run:

```bash
# from repo root
cd enum-updates/update
cargo near build
```

You can automatically compile and deploy the contract in the NEAR testnet by running:

```bash
# `update-migrate-rust-enum-updates.testnet` was used as example of <target-account-id>
# NEAR CLI
near deploy <target-account-id> ../../target/near/enums_update/enums_update.wasm
# near-cli-rs 
near contract deploy <target-account-id> use-file ../../target/near/enums_update/enums_update.wasm without-init-call network-config testnet sign-with-keychain send
```

In contrast with [the base update](../../basic-updates/update), here **no migration is needed**,
because the contract was already prepared to handle versioned messages!

<br />

## 2. Add a Message
```bash
# NEAR CLI
near call <target-account-id> add_message '{"text": "a message"}' --amount 0.1 --accountId <account>
# near-cli-rs 
near contract call-function as-transaction <target-account-id> add_message json-args '{"text": "a message"}' prepaid-gas '100.0 Tgas' attached-deposit '0.1 NEAR' sign-as <account> network-config testnet sign-with-keychain send
```

<br />

## 3. Retrieve the Messages
You will see that the old `V1` messages always have `payment: 0`, while the new ones keep track
of the payment

```bash
# NEAR CLI
near view <target-account-id> get_messages
```

'''
'''--- enum-updates/update/src/lib.rs ---
use near_sdk::near;

use near_sdk::collections::Vector;
use near_sdk::json_types::{U64, U128};

use near_sdk::{env, AccountId, NearToken};

use versioned_msg::{PostedMessageV2, VersionedPostedMessage};
mod versioned_msg;

const POINT_ONE: NearToken = NearToken::from_millinear(100);

#[near(contract_state)]
pub struct GuestBook {
    messages: Vector<VersionedPostedMessage>,
}

impl Default for GuestBook {
    fn default() -> Self {
        Self {
            messages: Vector::new(b"m"),
        }
    }
}

#[near]
impl GuestBook {
    #[payable]
    pub fn add_message(&mut self, text: String) {
        let payment = env::attached_deposit();
        let sender = env::predecessor_account_id();
        let premium = payment >= POINT_ONE;
        let message = VersionedPostedMessage::V2(PostedMessageV2 {
            payment,
            sender,
            premium,
            text,
        });
        self.messages.push(&message);
    }

    pub fn get_messages(
        &self,
        from_index: Option<U128>,
        limit: Option<U64>,
    ) -> Vec<PostedMessageV2> {
        let from = u128::from(from_index.unwrap_or(U128(0)));

        self.messages
            .iter()
            .skip(from as usize)
            .take(u64::from(limit.unwrap_or(U64::from(10))) as usize)
            .map(|message| message.into())
            .collect()
    }
}

'''
'''--- enum-updates/update/src/versioned_msg.rs ---
use crate::*;

#[near(serializers=[borsh])]
pub struct PostedMessageV1 {
    pub premium: bool,
    pub sender: AccountId,
    pub text: String,
}

#[near(serializers=[borsh, json])]
pub struct PostedMessageV2 {
    pub payment: NearToken,
    pub premium: bool,
    pub sender: AccountId,
    pub text: String,
}

#[near(serializers=[borsh])]
pub enum VersionedPostedMessage {
    V1(PostedMessageV1),
    V2(PostedMessageV2),
}

impl From<VersionedPostedMessage> for PostedMessageV2 {
    fn from(message: VersionedPostedMessage) -> Self {
        match message {
            VersionedPostedMessage::V2(posted) => posted,
            VersionedPostedMessage::V1(posted) => PostedMessageV2 {
                payment: NearToken::from_near(0),
                premium: posted.premium,
                sender: posted.sender,
                text: posted.text,
            },
        }
    }
}

'''
'''--- enum-updates/update/tests/workspaces.rs ---
use near_sdk::NearToken;
use serde_json::json;
use std::fs;

use near_sdk::AccountId;

const FIVE_NEAR: NearToken = NearToken::from_near(5);
const ONE_NEAR: NearToken = NearToken::from_near(1);
const NINE_HUNDREDTH_NEAR: NearToken = NearToken::from_millinear(90);

#[tokio::test]
async fn test_enum_updates_migration() -> Result<(), Box<dyn std::error::Error>> {
    let sandbox = near_workspaces::sandbox().await.unwrap();

    fs::create_dir_all("../../target/near/enums_base").unwrap();
    let base_contract_wasm = near_workspaces::compile_project("../base").await.unwrap();

    let root = sandbox.root_account().unwrap();
    let guest_book_account = root.create_subaccount("gbook").initial_balance(FIVE_NEAR).transact().await.unwrap().unwrap();

    let contract = guest_book_account
        .deploy(&base_contract_wasm)
        .await
        .unwrap()
        .into_result()
        .unwrap();

    let alice = root.create_subaccount("alice").initial_balance(FIVE_NEAR).transact().await.unwrap().unwrap();

    let guest_book_message_outcome = guest_book_account
        .call(contract.id(), "add_message")
        .args_json(json!({"text": "hello"}))
        .deposit(NINE_HUNDREDTH_NEAR)
        .transact()
        .await
        .unwrap();

    assert!(guest_book_message_outcome.is_success());

    let alice_first_message_outcome = alice
        .call(contract.id(), "add_message")
        .args_json(json!({"text": "bye"}))
        .deposit(ONE_NEAR)
        .transact()
        .await
        .unwrap();

    assert!(alice_first_message_outcome.is_success());

    fs::create_dir_all("../../target/near/enums_update").unwrap();
    let updated_contract_wasm = near_workspaces::compile_project("./").await.unwrap();

    let updated_contract = guest_book_account
        .deploy(&updated_contract_wasm)
        .await
        .unwrap()
        .into_result()
        .unwrap();

    #[derive(near_sdk::serde::Deserialize, Debug, PartialEq, Eq)]
    #[serde(crate = "near_sdk::serde")]
    pub struct PostedMessageV2 {
        pub payment: NearToken,
        pub premium: bool,
        pub sender: AccountId,
        pub text: String,
    }

    let messages_vec: Vec<PostedMessageV2> = updated_contract
        .view("get_messages")
        .args_json(json!({}))
        .await?
        .json()?;

    assert_eq!(
        messages_vec,
        vec![
            PostedMessageV2 {
                payment: NearToken::from_near(0),
                premium: false,
                sender: guest_book_account.id().clone(),
                text: "hello".to_string(),
            },
            PostedMessageV2 {
                payment: NearToken::from_near(0),
                premium: true,
                sender: alice.id().clone(),
                text: "bye".to_string(),
            },
        ]
    );
    let alice_first_message_outcome = alice
        .call(updated_contract.id(), "add_message")
        .args_json(json!({"text": "howdy"}))
        .deposit(ONE_NEAR)
        .transact()
        .await
        .unwrap();

    assert!(alice_first_message_outcome.is_success());

    let messages_vec: Vec<PostedMessageV2> = updated_contract
        .view("get_messages")
        .args_json(json!({}))
        .await?
        .json()?;

    assert_eq!(
        messages_vec,
        vec![
            PostedMessageV2 {
                payment: NearToken::from_near(0),
                premium: false,
                sender: guest_book_account.id().clone(),
                text: "hello".to_string(),
            },
            PostedMessageV2 {
                payment: NearToken::from_near(0),
                premium: true,
                sender: alice.id().clone(),
                text: "bye".to_string(),
            },
            PostedMessageV2 {
                payment: NearToken::from_near(1),
                premium: true,
                sender: alice.id().clone(),
                text: "howdy".to_string(),
            },
        ]
    );
    Ok(())
}

'''
'''--- self-updates/base/Cargo.toml ---
[package]
name = "self-base"
version = "1.0.0"
authors = ["Near Inc <hello@near.org>"]
edition = "2021"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = { version = "5.1.0", features = ["legacy"] }

'''
'''--- self-updates/base/README.md ---
# Guest Book Contract - Self Update

A [Guest Book Contract](../../basic-updates/base/) that can self-update.

This contract has a `update_contract` that takes as input a wasm file and deploys it on itself.

```rust
pub fn update_contract(&self) -> Promise {
    // Check the caller is authorized to update the code
    assert!(env::predecessor_account_id() == self.manager, "Only the manager can update the code");

    // Receive the code directly from the input to avoid the
    // GAS overhead of deserializing parameters
    let code = env::input().expect("Error: No input").to_vec();

    // Deploy the contract on self
    Promise::new(env::current_account_id())
    .deploy_contract(code)
    .function_call(
        "migrate".to_string(),
        NO_ARGS,
        NearToken::from_near(0),
        CALL_GAS
    )
    .as_return()
}
```

<br />

# Quickstart

## 1. Build and Deploy the Contract

_In this example we will be using [NEAR CLI](https://github.com/near/near-cli)
to intract with the NEAR blockchain and the smart contract and [near-cli-rs](https://near.cli.rs)
which provides more control over interactions and has interactive menus for subcommands selection_

Install [`cargo-near`](https://github.com/near/cargo-near) and run:

```bash
# from repo root
cd self-updates/base
cargo near build
```

Build and deploy:

```bash
# `update-migrate-rust-self-updates.testnet` was used as example of <target-account-id>
# `update-migrate-rust-self-updates-manager.testnet` was used as example of <manager-account-id>
cargo near deploy <target-account-id> with-init-call init json-args '{"manager":"<manager-account-id>"}' prepaid-gas '100.0 Tgas' attached-deposit '0 NEAR' network-config testnet sign-with-keychain send
```

<br />

## 2. Lock the Account

Check the account's full-access key:

```bash
# NEAR CLI
near keys <target-account-id>
# result: [{access_key: {"nonce": ..., permission: 'FullAccess'}, "public_key": '<key>'}]

# near-cli-rs 
near account list-keys <target-account-id> network-config testnet now
...
```

Remove the only full-access key, present in the output of the above command, from the <target-account-id>, thus leaving it locked:

```bash
# `ed25519:CE3AtAeHK3VKFPofhb9HLRoDEF2zmW5x9oWCoQU5a5FF` was used as example of <key>
# NEAR CLI
near delete-key <target-account-id> '<key>'

# near-cli-rs 
near account delete-keys <target-account-id> public-keys <key> network-config testnet sign-with-keychain send
```

<br />

## 3. Add a Message

```bash
# NEAR CLI
near call <target-account-id> add_message '{"text": "a message"}' --amount 0.1 --accountId <account>
# near-cli-rs 
near contract call-function as-transaction <target-account-id> add_message json-args '{"text": "a message"}' prepaid-gas '100.0 Tgas' attached-deposit '0.1 NEAR' sign-as <account> network-config testnet sign-with-keychain send
```

<br />

## 4. Retrieve the Stored Messages & Payments
`get_messages` and `get_payments` are read-only method (`view` method)

```bash
# NEAR CLI
near view <target-account-id> get_messages
# near-cli-rs 
near contract call-function as-read-only <target-account-id> get_messages json-args {} network-config testnet now
```
  
```bash
# NEAR CLI
near view <target-account-id> get_payments
# near-cli-rs 
near contract call-function as-read-only <target-account-id> get_payments json-args {} network-config testnet now
```

<br />

## 5. Continue in the Update Folder
Navigate to the [update](../update/) folder to continue

'''
'''--- self-updates/base/src/lib.rs ---
use near_sdk::near;

use near_sdk::collections::Vector;
use near_sdk::json_types::{U64, U128};

use near_sdk::{env, AccountId, NearToken, PanicOnDefault};

mod update;

const POINT_ONE: NearToken = NearToken::from_millinear(100);

#[near(serializers=[borsh, json])]
pub struct PostedMessage {
    pub premium: bool,
    pub sender: AccountId,
    pub text: String,
}

#[near(contract_state)]
#[derive(PanicOnDefault)]
pub struct GuestBook {
    messages: Vector<PostedMessage>,
    payments: Vector<NearToken>,
    manager: AccountId,
}

#[near]
impl GuestBook {
    #[init]
    pub fn init(manager: AccountId) -> Self {
        Self {
            messages: Vector::new(b"m"),
            payments: Vector::new(b"p"),
            manager,
        }
    }

    #[payable]
    pub fn add_message(&mut self, text: String) {
        let payment = env::attached_deposit();
        let premium = payment >= POINT_ONE;
        let sender = env::predecessor_account_id();

        let message = PostedMessage {
            premium,
            sender,
            text,
        };
        self.messages.push(&message);
        self.payments.push(&payment);
    }

    pub fn get_messages(&self, from_index: Option<U128>, limit: Option<U64>) -> Vec<PostedMessage> {
        let from = u128::from(from_index.unwrap_or(U128(0)));

        self.messages
            .iter()
            .skip(from as usize)
            .take(u64::from(limit.unwrap_or(U64::from(10))) as usize)
            .collect()
    }

    pub fn get_payments(&self, from_index: Option<U128>, limit: Option<U64>) -> Vec<U128> {
        let from = u128::from(from_index.unwrap_or(U128(0)));

        self.payments
            .iter()
            .skip(from as usize)
            .take(u64::from(limit.unwrap_or(U64::from(10))) as usize)
            .map(|x| U128(x.as_yoctonear()))
            .collect()
    }
}

'''
'''--- self-updates/base/src/update.rs ---
use near_sdk::{Gas, Promise};

use crate::*;

const NO_ARGS: Vec<u8> = vec![];
const CALL_GAS: Gas = Gas::from_tgas(200); // 200 TGAS

#[near]
impl GuestBook {
    pub fn update_contract(&self) -> Promise {
        // Check the caller is authorized to update the code
        assert!(
            env::predecessor_account_id() == self.manager,
            "Only the manager can update the code"
        );

        // Receive the code directly from the input to avoid the
        // GAS overhead of deserializing parameters
        let code = env::input().expect("Error: No input").to_vec();

        // Deploy the contract on self
        Promise::new(env::current_account_id())
            .deploy_contract(code)
            .function_call(
                "migrate".to_string(),
                NO_ARGS,
                NearToken::from_near(0),
                CALL_GAS,
            )
            .as_return()
    }
}

'''
'''--- self-updates/update/Cargo.toml ---
[package]
name = "self-update"
version = "1.0.0"
authors = ["Near Inc <hello@near.org>"]
edition = "2021"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = { version = "5.1.0", features = ["legacy"] }

[dev-dependencies]
near-sdk = { version = "5.1.0" }
near-workspaces = { version = "0.10.0", features = ["unstable"] }
tokio = { version = "1.12.0", features = ["full"] }
serde_json = "1"
rstest = "0.18.2"

'''
'''--- self-updates/update/README.md ---
# Guest Book Contract - Self Update

The [base](../base) contract was modified, removing the `payments` field and including that information
in the `PostedMessage` structure.

```rust
pub struct PostedMessage {
    pub payment: NearToken,
    pub premium: bool,
    pub sender: AccountId,
    pub text: String,
}

pub struct GuestBook {
    messages: Vector<PostedMessage>,
    manager: AccountId,
}
```

## 1. Build

Install [`cargo-near`](https://github.com/near/cargo-near) and run:

```bash
# from repo root
cd self-updates/update
cargo near build
```

## 2. Asking the Contract to Update Itself

_In this example we will be using [NEAR CLI](https://github.com/near/near-cli)
to intract with the NEAR blockchain and the smart contract and [near-cli-rs](https://near.cli.rs)
which provides more control over interactions and has interactive menus for subcommands selection_

The [base contract](../base/) implements a `update_contract` method that only the `manager` can call. That method takes
a compiled wasm as input and then:
1. Deploys it on itself.
2. Calls the `migrate` method on itself.

Lets call `update_contract` passing the new code ([./src](./src/)) using the [`manager-account`](../base/README.md#1-build-and-deploy-the-contract).

```bash
# `update-migrate-rust-self-updates.testnet` was used as example of <target-account-id>
# `update-migrate-rust-self-updates-manager.testnet` was used as example of <manager-account-id>
# near-cli-rs 
near contract call-function as-transaction <target-account-id> update_contract file-args ../../target/near/self_update/self_update.wasm prepaid-gas '300.0 Tgas' attached-deposit '0 NEAR' sign-as <manager-account-id> network-config testnet sign-with-keychain send
```
<br />

## 3. Retrieve the Stored Messages
`get_messages` will now return messages that include a `payment` field.

```bash
# NEAR CLI
near view <target-account-id> get_messages
```

`get_payments` will raise an error since the method does not exist anymore.

```bash
# raises an error since the method is gone
# NEAR CLI
near view <target-account-id> get_payments
```

'''
'''--- self-updates/update/src/lib.rs ---
use near_sdk::near;

use near_sdk::collections::Vector;
use near_sdk::json_types::{U64, U128};

use near_sdk::{env, AccountId, NearToken, PanicOnDefault};

mod migrate;
mod update;

const POINT_ONE: NearToken = NearToken::from_millinear(100);

#[near(serializers = [borsh, json])]
pub struct PostedMessage {
    pub payment: NearToken,
    pub premium: bool,
    pub sender: AccountId,
    pub text: String,
}

#[near(contract_state)]
#[derive(PanicOnDefault)]
pub struct GuestBook {
    messages: Vector<PostedMessage>,
    manager: AccountId,
}

#[near]
impl GuestBook {
    #[init]
    pub fn init(manager: AccountId) -> Self {
        Self {
            messages: Vector::new(b"m"),
            manager,
        }
    }

    #[payable]
    pub fn add_message(&mut self, text: String) {
        let payment = env::attached_deposit();
        let sender = env::predecessor_account_id();
        let premium = payment >= POINT_ONE;
        let message = PostedMessage {
            payment,
            sender,
            premium,
            text,
        };
        self.messages.push(&message);
    }

    pub fn get_messages(&self, from_index: Option<U128>, limit: Option<U64>) -> Vec<PostedMessage> {
        let from = u128::from(from_index.unwrap_or(U128(0)));

        self.messages
            .iter()
            .skip(from as usize)
            .take(u64::from(limit.unwrap_or(U64::from(10))) as usize)
            .collect()
    }
}

'''
'''--- self-updates/update/src/migrate.rs ---
use crate::*;

#[near(serializers = [borsh])]
pub struct OldPostedMessage {
    pub premium: bool,
    pub sender: AccountId,
    pub text: String,
}

#[near(serializers = [borsh])]
pub struct OldState {
    messages: Vector<OldPostedMessage>,
    payments: Vector<NearToken>,
    manager: AccountId,
}

#[near]
impl GuestBook {
    #[private]
    #[init(ignore_state)]
    pub fn migrate() -> Self {
        let old_state: OldState = env::state_read().expect("failed");
        let mut new_messages: Vector<PostedMessage> = Vector::new(b"p");

        // iterate through the messages of the previous state
        for (idx, posted) in old_state.messages.iter().enumerate() {
            // get the payment using the message index
            let payment = old_state
                .payments
                .get(idx as u64)
                .unwrap_or(NearToken::from_near(0));

            // Create a PostedMessage with the new format and push it
            new_messages.push(&PostedMessage {
                payment,
                premium: posted.premium,
                sender: posted.sender,
                text: posted.text,
            })
        }

        // return the new state
        Self {
            messages: new_messages,
            manager: old_state.manager,
        }
    }
}

'''
'''--- self-updates/update/src/update.rs ---
use near_sdk::{Gas, Promise};

use crate::*;

const NO_ARGS: Vec<u8> = vec![];
const CALL_GAS: Gas = Gas::from_tgas(200); // 200 TGAS

#[near]
impl GuestBook {
    pub fn update_contract(&self) -> Promise {
        // Check the caller is authorized to update the code
        assert!(
            env::predecessor_account_id() == self.manager,
            "Only the manager can update the code"
        );

        // Receive the code directly from the input to avoid the
        // GAS overhead of deserializing parameters
        let code = env::input().expect("Error: No input").to_vec();

        // Deploy the contract on self
        Promise::new(env::current_account_id())
            .deploy_contract(code)
            .function_call(
                "migrate".to_string(),
                NO_ARGS,
                NearToken::from_near(0),
                CALL_GAS,
            )
            .as_return()
    }
}

'''
'''--- self-updates/update/tests/workspaces.rs ---
use std::fs;

use near_sdk::json_types::U128;
use near_sdk::{AccountId, Gas};
use near_workspaces::types::NearToken;
use near_workspaces::Account;
use near_workspaces::Contract;
use rstest::{fixture, rstest};
use serde_json::json;

const FIVE_NEAR: NearToken = NearToken::from_near(5);
const ONE_TENTH_NEAR: NearToken = NearToken::from_millinear(100);
const NINE_HUNDREDTH_NEAR: NearToken = NearToken::from_millinear(90);

struct Common {
    contract: Contract,
    alice: Account,
    bob: Account,
    guest_book: Account,
}

#[fixture]
async fn base_contract() -> Common {
    let sandbox = near_workspaces::sandbox().await.unwrap();

    fs::create_dir_all("../../target/near/self_base").unwrap();
    let contract_wasm = near_workspaces::compile_project("../base").await.unwrap();

    let root = sandbox.root_account().unwrap();
    let alice = root.create_subaccount("alice").initial_balance(FIVE_NEAR).transact().await.unwrap().unwrap();
    let guest_book_account = root.create_subaccount("gbook").initial_balance(FIVE_NEAR).transact().await.unwrap().unwrap();

    let contract = guest_book_account
        .deploy(&contract_wasm)
        .await
        .unwrap()
        .into_result()
        .unwrap();

    let guest_book_init_outcome = guest_book_account
        .call(contract.id(), "init")
        .args_json(json!({"manager": alice.id().to_string() }))
        .transact()
        .await
        .unwrap();

    assert!(guest_book_init_outcome.is_success());

    let bob = root.create_subaccount("bob").initial_balance(FIVE_NEAR).transact().await.unwrap().unwrap();

    let bob_first_message_outcome = bob
        .call(contract.id(), "add_message")
        .args_json(json!({"text": "hello"}))
        .deposit(NINE_HUNDREDTH_NEAR)
        .transact()
        .await
        .unwrap();

    assert!(bob_first_message_outcome.is_success());

    let alice_first_message_outcome = alice
        .call(contract.id(), "add_message")
        .args_json(json!({"text": "bye"}))
        .deposit(ONE_TENTH_NEAR)
        .transact()
        .await
        .unwrap();

    assert!(alice_first_message_outcome.is_success());

    Common {
        contract,
        alice,
        bob,
        guest_book: guest_book_account,
    }
}

#[rstest]
#[tokio::test]
async fn test_self_updates_base_contract_returns(
    #[future] base_contract: Common,
) -> Result<(), Box<dyn std::error::Error>> {
    let base_contract = base_contract.await;

    #[derive(near_sdk::serde::Deserialize, Debug, PartialEq, Eq)]
    #[serde(crate = "near_sdk::serde")]
    pub struct PostedMessage {
        pub premium: bool,
        pub sender: AccountId,
        pub text: String,
    }
    let messages_vec: Vec<PostedMessage> = base_contract
        .contract
        .view("get_messages")
        .args_json(json!({}))
        .await?
        .json()?;

    assert_eq!(
        messages_vec,
        vec![
            PostedMessage {
                premium: false,
                sender: base_contract.bob.id().clone(),
                text: "hello".to_string(),
            },
            PostedMessage {
                premium: true,
                sender: base_contract.alice.id().clone(),
                text: "bye".to_string(),
            },
        ]
    );

    let payments_vec: Vec<U128> = base_contract
        .contract
        .view("get_payments")
        .args_json(json!({}))
        .await?
        .json()?;

    assert_eq!(
        payments_vec,
        vec![
            U128(NINE_HUNDREDTH_NEAR.as_yoctonear()),
            U128(ONE_TENTH_NEAR.as_yoctonear())
        ]
    );

    Ok(())
}

#[rstest]
#[tokio::test]
async fn test_self_updates_update_by_manager(
    #[future] base_contract: Common,
) -> Result<(), Box<dyn std::error::Error>> {
    let base_contract = base_contract.await;

    fs::create_dir_all("../../target/near/self_update").unwrap();
    let updated_contract_wasm = near_workspaces::compile_project("./").await.unwrap();

    let manager_update_call_outcome = base_contract
        .alice
        .call(base_contract.guest_book.id(), "update_contract")
        .args(updated_contract_wasm)
        .gas(Gas::from_tgas(300))
        .transact()
        .await
        .unwrap();

    assert!(manager_update_call_outcome.is_success());

    let contract = base_contract.contract;

    #[derive(near_sdk::serde::Deserialize, Debug, PartialEq, Eq)]
    #[serde(crate = "near_sdk::serde")]
    pub struct PostedMessage {
        pub payment: NearToken,
        pub premium: bool,
        pub sender: AccountId,
        pub text: String,
    }
    let messages_vec: Vec<PostedMessage> = contract
        .view("get_messages")
        .args_json(json!({}))
        .await?
        .json()?;
    assert_eq!(
        messages_vec,
        vec![
            PostedMessage {
                payment: NINE_HUNDREDTH_NEAR,
                premium: false,
                sender: base_contract.bob.id().clone(),
                text: "hello".to_string(),
            },
            PostedMessage {
                payment: ONE_TENTH_NEAR,
                premium: true,
                sender: base_contract.alice.id().clone(),
                text: "bye".to_string(),
            },
        ]
    );
    let get_payments_result = contract.view("get_payments").args_json(json!({})).await;

    assert!(get_payments_result.is_err());
    Ok(())
}

'''