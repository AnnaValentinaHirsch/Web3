*GitHub Repository "Java-para-todos/smart-contract-metztli"*

'''--- README.md ---
# Smart Contract Metztli
## INTRODUCCIÓN 
A medida que las criptomonedas y la tecnología blockchain se hicieron más populares, Bitcoin, Ethereum y otras redes empezaron a enfrentar desafíos de escalabilidad debido a una mayor demanda. El creciente interés por las aplicaciones descentralizadas y los tokens no fungibles (NFT) hace que dichos desafíos sean particularmente notorios en la blockchain Ethereum. La red a menudo sufre elevados precios del gas y costos de transacción debido al gran tráfico, lo que puede resultar desalentador para muchos usuarios y desarrolladores. 
A pesar de que hay varios equipos que exploran distintas soluciones de escalabilidad para redes blockchain, el equipo de NEAR Protocol (NEAR) está centrado en solventar las limitaciones a través del sharding.

'''
'''--- as-pect.config.js ---
module.exports = require("near-sdk-as/imports")

'''
'''--- asconfig.json ---
{
    "extends": "near-sdk-as/asconfig.json"
}
'''
'''--- aseembly/as.types.d.ts ---
<reference types="near-sdk-as/assembly/as_types" />
'''
'''--- aseembly/index.ts ---
 import { Product, productsStorage } from './model';
 import { Client, clientsStorage } from './model';
 import { context, ContractPromiseBatch } from "near-sdk-as";

// @Param productID: Is the ID of product that you want to buy
export function buyProduct(productId: string): void {
    const product = getProduct(productId); //Get the product
    if (product == null) { //Verificate if the product exist
        throw new Error("Producto No Encontrado"); //Message Error
    }
    if (product.price.toString() != context.attachedDeposit.toString()) { //Verify if the Pay is correct
        throw new Error("Error al procesar el pago, intenta más tarde");
    }
    
    ContractPromiseBatch.create(product.owner).transfer(context.attachedDeposit); //Transfer the Coins-Nears
    productsStorage.set(product.id, product); 
}

//Method to add a product 
// @Param producto: Is a reference of the product to add
export function addProduct(product: Product): void {
    let storedProduct = productsStorage.get(product.id); //Serch the product in the Map 
    if (storedProduct !== null) { //If is different to NULL the product is ready
        throw new Error(`El ID: ${product.id} ya existe en nuestro inventario`); //Message
    } 
    productsStorage.set(product.id, Product.fromPayload(product)); //Will add the Producto to the Map of products
}

// Method to get all Products
export function getAllProducts(): Array<Product> {
    return productsStorage.values(); //Return his values- in the front we will inject the values
}

// @Param ID: Is the ID of product to find
export function getProduct(id: string): Product | null {
    return productsStorage.get(id);
}

// METHOD CLIENTS
// @Param ID: Is the ID of Client to find
export function getClient(id: string): Product | null {
    return clientsStorage.get(id);
}

//Métthod to add a Client
export function addClient(client: Client): void {
    let storedClient = clientsStorage.get(client.id); //Serch the client in the Map 
    if (storedClient !== null) { //If is different to NULL the Clent is ready
        throw new Error(`El ID: ${client.id} ya existe en nuestro inventario`); //Message
    } 
    productsStorage.set(client.id,Client.loadClient(client)); //Will add the Producto to the Map of products
}

'''
'''--- aseembly/model.ts ---
import {PersistentVector, u128, context} from "near-sdk-as";
 @nearBindgen
export class Product{
    // Atributtes
    id: string;
    name: string;
    description: string;
    image: string;
    price: string;
    owner:string;
    public static fromPayload(payload: Product): Product {
        const product = new Product(); //New Product
        //Load the values to the product
        product.id=payload.id;
        product.name=payload.name;
        product.description=payload.description;
        product.image=payload.image;
        product.price=payload.price;
        product.owner = context.sender;
        //return the product
        return product;
    }
}
@nearBindgen
export class Client { //Class Client
    //Attributtes
    id:string;
    user: string;
    address: string;

    // Method to load the values
    public  static loadClient(loadClient: Client): Client{
        let client=new Client();
        client.id=loadClient.id;
        client.user=loadClient.user;
        client.address=loadClient.address;
        //Return a Object Client
        return client;
    }
}

// export const productsStorage = new PersistentUnorderedMap<string, Product>("LISTED_PRODUCTS");

// export const clientsStorage = new PersistentUnorderedMap<string, Client>("LISTED_CLIENTS");
'''
'''--- aseembly/tsconfig.json ---
{
    "extends": "../node_modules/assemblyscript/std/assembly.json",
    "include": [
      "./**/*.ts"
    ]
  }
'''
'''--- package.json ---
{
	"name": "Metztli",
	"version": "1.0.0",
	"description": "Contrato inteligente",
	"main": "index.js",
	"scripts": {
		"test": "asp",
		"build": "asb",
		"deploy:dev": "yarn build && near dev-deploy"
	},
	"keywords": [],
	"author": "",
	"license": "ISC",
	"devDependencies": {
		"assemblyscript": "^0.19.22",
		"near-sdk-as": "^3.2.3"
	},
	"dependencies": {
		"@assemblyscript/loader": "^0.19.22",
		"date-and-time": "^2.0.1"
	}
}
'''