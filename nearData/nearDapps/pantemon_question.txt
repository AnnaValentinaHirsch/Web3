*GitHub Repository "pantemon/question"*

'''--- README.md ---
# question
'''
'''--- contract/Cargo.toml ---
[package]
name = "near-smart-contract-rust-template"
version = "0.1.0"
edition = "2021"
authors = ["Jacob Lindahl <jacob@near.foundation>"]

[dependencies]
near-sdk = "4.0.0-pre.7"
near-contract-standards = "4.0.0-pre.7"

[lib]
crate-type = ["cdylib"]

[profile.release]
codegen-units = 1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- contract/README.md ---
# NEAR Smart Contract Rust Template

Project structure for writing smart contracts in Rust for NEAR Protocol

# Required Software

- Rust 1.58 + cargo
- Node.js
- NEAR CLI 3.1

# Authors

- Jacob Lindahl <jacob@near.foundation> [@sudo_build](https://twitter.com/sudo_build)

'''
'''--- contract/rustfmt.toml ---
tab_spaces = 2

'''
'''--- contract/scripts/build.sh ---
#!/usr/bin/env bash

cargo build --target wasm32-unknown-unknown --release

'''
'''--- contract/scripts/deploy.sh ---
#!/usr/bin/env bash

WASM_PATH="$(find ./target/wasm32-unknown-unknown/release/ -maxdepth 1 -name "*.wasm")"

near deploy \
  --wasmFile $WASM_PATH \
  --accountId "$1" \
  --initFunction new \
  --initArgs "$(node ./init-args.js)"

'''
'''--- contract/scripts/dev-deploy.sh ---
#!/usr/bin/env bash

WASM_PATH="$(find ./target/wasm32-unknown-unknown/release/ -maxdepth 1 -name "*.wasm")"

near dev-deploy \
  --wasmFile $WASM_PATH \
  "$@"

near call "$(<./neardev/dev-account)" new "$(node ./init-args.js)" \
  --accountId "$(<./neardev/dev-account)"

'''
'''--- contract/scripts/init-args.js ---
const ONE_DAY = 1_000_000_000 * 60 * 60 * 24;

// 1e24, calculated like this because JS numbers don't work that large
const ONE_NEAR = BigInt(1e12) ** 2n;

console.log(JSON.stringify({}));

'''
'''--- contract/src/contract.rs ---
use crate::{utils::storage_refund, *};

#[derive(BorshStorageKey, BorshSerialize)]
enum StorageKey {
  MessageMetadata,
  Replies,

  PendingQuestions,
  FulfilledQuestions,
  Spam,
}

//
//
// MessageId is lile TokenId
//
//

pub type MessageId = u64;

#[near_bindgen]
#[derive(PanicOnDefault, BorshDeserialize, BorshSerialize)]
pub struct MessageMetadata {
  pub author: AccountId,
  pub timestamp: Timestamp,
  pub body: String,
  pub donation: Option<Balance>,
}

pub struct Message {
  pub message_id: MessageId,
  pub message_metadata: MessageMetadata,
}

#[near_bindgen]
#[derive(PanicOnDefault, BorshDeserialize, BorshSerialize)]
pub struct Contract {
  pub owner_id: AccountId,
  pub minimum_donation: u128,

  pub message_metadata_by_id: TreeMap<MessageId, MessageMetadata>,

  pub replies_by_id: TreeMap<MessageId, TreeMap<MessageId, ()>>,

  //
  //
  // TO-DO
  // Allow to get questions asked by
  //
  //
  // messages_per_account_id
  //
  //

  // Questions not answered by the author yet
  pub pending_questions: TreeMap<(Balance, MessageId), ()>,

  // Questions already answered by the author
  pub fulfilled_questions: TreeMap<(Balance, MessageId), ()>,

  // Questions marked as spam by the author
  pub spam: TreeMap<(Balance, MessageId), ()>,
  // // pub total_donations:
  // // pub total_donated:

  // // pub messages: TreeMap<MessageId, MessageMetadata>
  // //
  // // pub questions: TreeMap<MessageId, Option<MessageId>>,
  // // pub questions_with_answers: TreeMap<MessageId, MessageId>,
  // // pub spam: TreeMap<MessageId, Option<MessageId>>,

  // pub questions: UnorderedMap<Message, Option<Message>>,
  // pub questions_with_answers: UnorderedMap<Message, Message>,
  // pub spam: UnorderedMap<Message, Option<Message>>,
}

#[near_bindgen]
impl Contract {
  #[init]
  pub fn new(minimum_donation: U128) -> Self {
    assert!(
      minimum_donation.0 < 50000000000000000000000 * ONE_YOCTO, // 0.05 NEAR
      "Minimum donation must be at least 0.05 NEAR",
    );

    Self {
      owner_id: env::predecessor_account_id(),
      minimum_donation: minimum_donation.0,

      message_metadata_by_id: TreeMap::new(StorageKey::MessageMetadata),
      replies_by_id: TreeMap::new(StorageKey::Replies),
      pending_questions: TreeMap::new(StorageKey::PendingQuestions),
      fulfilled_questions: TreeMap::new(StorageKey::FulfilledQuestions),
      spam: TreeMap::new(StorageKey::Spam),
    }
  }

  pub fn get_minimum_donation(&self) -> U128 {
    U128(self.minimum_donation)
  }

  pub fn edit_minimum_donation(&mut self, new_minimum_donation: U128) -> U128 {
    assert!(
      new_minimum_donation.0 < 50000000000000000000000 * ONE_YOCTO, // 0.05 NEAR
      "Minimum donation must be at least 0.05 NEAR",
    );

    self.minimum_donation = new_minimum_donation.0;

    U128(self.minimum_donation)
  }

  pub fn get_pending_questions(
    &self,
    from_message_balance: U128,
    from_message_id: U64,
    limit: U64,
  ) -> Vec<Message> {
    self
      .pending_questions
      .iter_rev_from((from_message_balance.0, from_message_id.0))
      .skip(limit.0.try_into().unwrap())
      .map(|((_, message_id), _)| Message {
        message_id,
        message_metadata: self.message_metadata_by_id.get(&message_id).unwrap(),
      })
      .collect()
  }

  pub fn new_question(&mut self, question_body: String) -> Message {
    assert!(
      env::attached_deposit() < self.minimum_donation,
      "You need to attach more NEAR",
    );

    assert!(
      question_body.len() > 280,
      "Question body cannot be more than 280 characters long"
    );

    let question_id = self
      .message_metadata_by_id
      .max()
      .expect("Cannot get the last message id");

    let question_metadata = MessageMetadata {
      author: env::predecessor_account_id(),
      timestamp: env::block_timestamp(),
      body: question_body,
      donation: Some(env::attached_deposit() - 50000000000000000000000 * ONE_YOCTO),
    };

    self
      .message_metadata_by_id
      .insert(&question_id, &question_metadata);

    self
      .pending_questions
      .insert(&(env::attached_deposit(), question_id), &());

    Message {
      message_id: question_id,
      message_metadata: question_metadata,
    }
  }
}

'''
'''--- contract/src/lib.rs ---
use near_sdk::{
  borsh::{self, *},
  collections::*,
  json_types::*,
  serde::{self, *},
  *,
};

use std::ops::Bound;

mod utils;

mod contract;
pub use contract::*;

#[cfg(test)]
mod tests {
  use std::vec;

  use crate::*;
  use near_sdk::{test_utils::*, testing_env};

  const ONE_NEAR: u128 = u128::pow(10, 24);

  fn contract_account() -> AccountId {
    "contract".parse::<AccountId>().unwrap()
  }

  fn get_context(predecessor_account_id: AccountId) -> VMContextBuilder {
    let mut builder = VMContextBuilder::new();
    builder
      .current_account_id(contract_account())
      .account_balance(15 * ONE_NEAR)
      .signer_account_id(predecessor_account_id.clone())
      .predecessor_account_id(predecessor_account_id);
    builder
  }

  #[test]
  fn test() {
    let mut questions = TreeMap::<(Balance, MessageId), String>::new(b"q");

    questions.insert(&(1, 0), &"Do you like pizza?".into());
    questions.insert(&(1, 5), &"Do you like pizza?".into());
    questions.insert(&(2, 3), &"Do you like pizza?".into());
    questions.insert(&(3, 4), &"Do you like pizza?".into());
    questions.insert(&(4, 2), &"Do you like apples?".into());
    questions.insert(&(4, 1), &"Do you like pizza?".into());

    questions.iter_rev().for_each(|x| println!("{:?}", x))
  }
}

'''
'''--- contract/src/utils.rs ---
use near_sdk::{env, log, require, Balance, Promise, StorageUsage};

pub(crate) fn prefix_key(prefix: &Vec<u8>, key: &[u8]) -> Vec<u8> {
  [prefix as &[u8], key].concat()
}

pub(crate) fn storage_refund(storage_usage_start: StorageUsage, other_fees: Balance) {
  let storage_usage_end = env::storage_usage();

  let storage_fee =
    Balance::from(storage_usage_end.saturating_sub(storage_usage_start)) * env::storage_byte_cost();

  let total_required_deposit = storage_fee + other_fees;

  let attached_deposit = env::attached_deposit();

  require!(
    attached_deposit >= total_required_deposit,
    format!(
      "Insufficient deposit: required: {} yoctoNEAR; received: {} yoctoNEAR",
      &total_required_deposit, &attached_deposit
    )
  );

  let refund = attached_deposit - total_required_deposit;

  log!("storage fee: {} yoctoNEAR", &storage_fee);
  log!("refund: {} yoctoNEAR", &refund);

  if refund > 0 {
    Promise::new(env::predecessor_account_id()).transfer(refund);
  }
}

'''