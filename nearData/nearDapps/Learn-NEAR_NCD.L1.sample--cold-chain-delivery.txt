*GitHub Repository "Learn-NEAR/NCD.L1.sample--cold-chain-delivery"*

'''--- Cargo.toml ---
[package]
name = "NCD_playground"
version = "0.1.0"
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[dependencies]
near-sdk = "3.1.0"
near-contract-standards = "3.1.1"
uint = { version = "0.8.3", default-features = false }

[dev-dependencies]
lazy_static = "1.4.0"
quickcheck = "0.9"
quickcheck_macros = "0.9"
log = "0.4"
env_logger = { version = "0.7.1", default-features = false }
near-crypto = { git = "https://github.com/nearprotocol/nearcore.git" }
near-primitives = { git = "https://github.com/nearprotocol/nearcore.git" }

[workspace]
members = []

'''
'''--- README.md ---
# Cold chain smart contract
The purpose of this smart contract is for a cold chain deliveries tracker. It's completely developed in RUST.

# Considerations
This is a project done in a UNIX-based system, as linux or MacOS.

If you are running Windows consider to install WSL for command terminal.

# How to run the smart contract
First is required to compile the smart contract into binaries 
```bash
./build.sh
```
In my case i needed extra permissions, so i give them to the file.

```bash 
chmod +x ./build.sh
```
After use the near dev-deploy command and indicate where is your .wasm file. You can also use near deploy if you prefered to have it mainnet.
**Note**: If permissions required write the following
```bash
near dev-deploy --wasmFile res/ncd_playground.wasm
```

# Cold chain tracking
Imagine you are a want to send a cold chain package.

- Pay 10 NEAR for a new delivery for starting it, select the account to pay when the delivery is done.
- Record temperature in each arrival to a new location.
- Once the delivery is in the last location, withdraw 10 NEAR as payment for completing succesfully the delivery.
- Restart the cycle.

Also you can:
- Check the status of the contract if it is initialized.
- Get extra information of delivery (Truck plate, trucker name, temperature in ºF, fuel level, etc.)
- If the Temp goes out of range the payment is canceled and returned to smart contract.
- To start a new contract you need to pay the truck owner when you return to the origin

## Locations (Simulated)
- 0 Tepic, Nayarit (Origin)
- 1 Guadalajara, Jalisco
- 2 Aguascalientes, Aguascalientes
- 3 Leon, Guanajuato
- 4 Ciudad de México (Destiny)

**Note**: We had de idea to do a get_location_verbose about this in the smart contract but we think was senseless and we could do that in frontend.

# Deploy the smart contract inside the testnet
```bash
near dev-deploy --wasmFile res/ncd_playground.wasm
```

**Note** It can be required to delete this files to run correctly the SC
```bash
source neardev/dev-account.env 
```
```bash
echo $CONTRACT_NAME
```
Define your account inside your environment
```bash
export MY_ACCOUNT='mytest.testnet'
echo $MY_ACCOUNT
```
# Commands in the smar contract

You can verify the status of the contract about a delivery by using get_initilized()
```bash
near call $CONTRACT_NAME get_initialized --accountId $MY_ACCOUNT
```
A new delivery will start using new_delivery(), you need to send 10 NEAR (--amount 10) and a JSON with the initial Temperature (ºC) and the account that will withdray the 10 NEARS if the delivery finish succesfully
```bash
near call $CONTRACT_NAME new_delivery '{"temp_c": -4.0, "payment_account_id": "alan1.testnet"}' --accountId $MY_ACCOUNT --amount 10
```
Creat a new arrival to a new location, temperature is saved.
```bash
near call $CONTRACT_NAME new_arrival '{"temp_c": -8.9}' --accountId 'alantest.testnet'  
```
If delivery is succesful, withdraw can be done and would be send to the account defined in new_delivery()
```bash
near call $CONTRACT_NAME withdraw --accountId $MY_ACCOUNT
```
JUST FOR DEBUG, decrement the location index, and reset the location index to 0.
```bash
near call $CONTRACT_NAME decrement --accountId $MY_ACCOUNT
near call $CONTRACT_NAME reset --accountId $MY_ACCOUNT 
```
## Other commands inside the contract
Get location, range 0-4, 0 is origin and 4 is destiny.
```bash
near call $CONTRACT_NAME get_location --accountId $MY_ACCOUNT   
```
Get balance of smart contract, returns the balance in yocto.
```bash
near call $CONTRACT_NAME get_balance --accountId $MY_ACCOUNT    
```
Get temperatue, returns temp in a floating number.
```bash
near call $CONTRACT_NAME get_temp --accountId $MY_ACCOUNT    
```
Get payment account id (payment.test/payment.near)
```bash
near call $CONTRACT_NAME get_payment_account_id --accountId $MY_ACCOUNT  
```
Get initialized, returns a boolean.
```bash
near call $CONTRACT_NAME get_initialized--accountId $MY_ACCOUNT  
```
# Testing the contract
Use cargo for running tests inside the contract
```bash
cargo test 
```
# Wireframing
Figma link: https://www.figma.com/file/w4YSyB4ML1wtcSy6IueL9j/Cold-chain-Wireframe?node-id=1392%3A1130

# Loom video
Video demo: https://www.loom.com/share/7ef30fb4deaf4088aad42600992dff97

# What to do next? Some ideas for improving the code
In this ideation section, we give some items that could improve the code, but time in NCD bootcamp was not enough to do that.
* Add extra information about the delivery to be tracked (Truck plate, Driver ID, fuel level, etc.)
* Have multiple deliveries running at the same time in the smart contract.
* Define custom payment amount for delivery.
* Define a safe range for temperature, if it is out of range return the money.

# Credits
This projects recovers ideas from many repositories, a list of those i remember.
-https://github.com/near/core-contracts
-https://github.com/near-examples/rust-status-message
-https://github.com/Learn-NEAR/NCD-08--Communite/blob/master/assembly/index.ts

'''
'''--- build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/ncd_playground.wasm ./res/

'''
'''--- neardev/dev-account.env ---
CONTRACT_NAME=dev-1625193002216-37998517024172
'''
'''--- src/lib.rs ---
mod test;

//New info is being saved in the contract
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LookupMap;
use near_sdk::collections::Vector;
use near_sdk::json_types::{Base58PublicKey, U128};
use near_sdk::{
    env, ext_contract, near_bindgen, AccountId, Balance, EpochHeight, Promise, PromiseResult,
    PublicKey, 
};

near_sdk::setup_alloc!();

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct ColdChain {
    //Information to be saved Truck ID, Temp (ºF and ºC), Truck plate, Fuel liters, Current Location, timestamp
    temp_c: LookupMap<String, f32>,
    payment_account_id: String,
    initialized: bool,
    // i8 is signed. unsigned integers are also available: u8, u16, u32, u64, u128
    val: u8, 
}

impl Default for ColdChain {
    fn default() -> Self {
        Self {
            temp_c: LookupMap::new(b"t_c".to_vec()),
            payment_account_id: env::current_account_id(),
            initialized: false,
            val: 0,
        }
    }
}

#[near_bindgen]
impl ColdChain {

    #[payable] //You pay 10 NEARS for a delivery
    pub fn new_delivery(&mut self, temp_c: f32, payment_account_id: String){

        assert!(
            !self.initialized, //check that contract is not initialized
            "Contract is alredy initialized, finish the travel to "
        );
        let amount = env::attached_deposit();
        //the id of who is calling the contract
        let signer_account_id = env::signer_account_id();
        let log_signer_account_id = format!("Signer Account ID {}", &signer_account_id );
        env::log(log_signer_account_id.as_bytes());

        // The id of the account that was the previous contract in the chain of cross-contract calls.
        let predecessor_account_id = env::predecessor_account_id();
        let log_predecessor_account_id = format!("Predecessor Account ID {}", &predecessor_account_id );
        env::log(log_predecessor_account_id.as_bytes());
        
        // The id of the account that owns the current contract.
        let current_account_id = env::current_account_id(); 
        let log_current_account_id = format!("Current Account ID {}", &current_account_id );
        env::log(log_current_account_id.as_bytes());

        assert_ne!(
            signer_account_id, 
            current_account_id, 
            "Contract cannot initialize a delivery by it's self"
        );
        assert_eq!(
            amount, 
             //10 NEARs required for delivery
            10000000000000000000000000, //How can this number by smaller? something as nears_2_yocto() and yocto_2_nears()
            "Payment for rent truck"
        );

        assert_eq!(
            self.val, //Current location
            0,
            "Delivery needs to be in origin"
        );
        self.payment_account_id = payment_account_id;
        self.initialized = true;
        self.temp_c.insert(&current_account_id, &temp_c);
    }
    /*
    //This method is experimental
    fn set_payment_account_id(&mut self, payment_account_id: AccountId) {
        let account_id = env::signer_account_id();

        let log_message = format!("New status {}", &payment_account_id);
        env::log(log_message.as_bytes());
        self.payment_account_id.insert(&account_id, &message);
    }
    */

    //In each arrival the temp_c is saved
    //Looking if we can define a range of temp_c
    pub fn new_arrival(&mut self, temp_c: f32 ){

        assert!(
            self.initialized, //check if the contract is initialized
            "Contract is not initialized"
        );
        assert!(
            self.val < 4, //Current location vs Destiny location
            "Delivery its in the last destiny, "
        );
        self.increment();
        let account_id = env::signer_account_id();
        self.temp_c.insert(&account_id, &temp_c);
    }

    fn increment(&mut self) {
        // note: adding one like this is an easy way to accidentally overflow
        // real smart contracts will want to have safety checks
        // e.g. self.val = i8::wrapping_add(self.val, 1);
        // https://doc.rust-lang.org/std/primitive.i8.html#method.wrapping_add
        self.val += 1;
        let log_message = format!("Current location {}", self.val);
        env::log(log_message.as_bytes());
        after_counter_change();
    }

    pub fn get_location(&self) -> u8 {
        return self.val;
    }

    pub fn withdraw(&mut self) {
    /*
        assert!(
            self.initialized, //Current location vs Destiny location
            "There is no payment for cold chain deliverry "
        );
     */    
        assert_eq!(
            self.val, //Current location
            4,
            "Truck needs to be in final destiny"
        );
        let signer_account_id = env::signer_account_id();
        let current_account_id = env::current_account_id(); 

        assert_ne!(
            signer_account_id, 
            current_account_id, 
            "Contract cannot initialize a delivery by it's self"
        );
        /*
       assert!(
            amount > self.get_balance(), //Current location vs Destiny location
            "Not enough payment for the contract"
        );
        */
        let account_id = env::signer_account_id();
        //let account_id = env::current_account_id();
        //let mut account_id = &self.payment_account_id;
        let amount = env::account_balance();
        let log_account = format!("Account ID {}", &account_id);
        env::log(log_account.as_bytes());

        let log_amount = format!("Amount {}", &amount);
        env::log(log_amount.as_bytes());

        self.reset();
        self.initialized = false;
        let amount_payment: Balance = 10000000000000000000000000;
        Promise::new(self.payment_account_id.to_string()).transfer(amount_payment);

    }
    //Verify how much balance is in the contract
    pub fn get_balance(&self) -> Option<Balance> {
        return Some(env::account_balance());
    }

    pub fn get_temp_c(&self, account_id: String) -> Option<f32> {
        return self.temp_c.get(&account_id);
    }

    pub fn get_payment_account_id(&self) -> String {
        return self.payment_account_id.to_string();
    }

    pub fn get_initialized(&self) -> bool {
        return self.initialized;
    }

    ///This methods are just for TESTING PURPOSES, 
    //IF YOU DONT NEED THEM YOU SHOULD COMMENT OUT 
    //THE METHODS decrement() and reset()

    pub fn decrement(&mut self) {
        // note: subtracting one like this is an easy way to accidentally overflow
        // real smart contracts will want to have safety checks
        // e.g. self.val = i8::wrapping_sub(self.val, 1);
        // https://doc.rust-lang.org/std/primitive.i8.html#method.wrapping_sub
        self.val -= 1;
        let log_message = format!("Decreased number to {}", self.val);
        env::log(log_message.as_bytes());
        after_counter_change();
    }

    /// Reset to zero.
    pub fn reset(&mut self) {
        self.val = 0;
        // Another way to log is to cast a string into bytes, hence "b" below:
        env::log(b"Reset counter to zero");
    }
}

#[cfg(not(target_arch = "wasm32"))]
#[cfg(test)]
mod tests {
    use super::*;
    use near_sdk::MockedBlockchain;
    use near_sdk::{testing_env, VMContext};

    fn get_context(input: Vec<u8>, is_view: bool) -> VMContext {
        VMContext {
            current_account_id: "alice_near".to_string(),
            signer_account_id: "bob_near".to_string(),
            signer_account_pk: vec![0, 1, 2],
            predecessor_account_id: "carol_near".to_string(),
            input,
            block_index: 0,
            block_timestamp: 0,
            account_balance: 0,
            account_locked_balance: 0,
            storage_usage: 0,
            attached_deposit: 0,
            prepaid_gas: 10u64.pow(18),
            random_seed: vec![0, 1, 2],
            is_view,
            output_data_receivers: vec![],
            epoch_height: 0,
        }
    }
    
    
   /* #[test]
    fn test_new_delivery() {
        let context = get_context(vec![], false);
        testing_env!(context);
        let contract = ColdChain::default();
        assert!(contract.new_delivery('{"temp_c": -4.0, "payment_account_id": "alan1.testnet"}'));
    }

    #[test]
    fn test_get_initialized(){
        let context = get_context(vec![], false);
        testing_env!(context);
        let contract = ColdChain::default();
        assert_eq!(false,contract.get_initialized());
    }

    #[test]
    fn test_new_delivery(){
        let context = get_context(vec![], false);
        testing_env!(context);
        let contract = ColdChain::default();
        assert_eq!(false,contract.new_delivery());
    }

    #[test]
    fn test_new_arrival(){
        let context = get_context(vec![], false);
        testing_env!(context);
        let contract = ColdChain::default();
        assert_eq!(false,contract.new_arrival());
    }

    #[test]
    fn test_withdraw(){
        let context = get_context(vec![], false);
        testing_env!(context);
        let contract = ColdChain::default();
        assert_eq!(false,contract.withdraw());
    }
    */

}

// unlike the struct's functions above, this function cannot use attributes #[derive(…)] or #[near_bindgen]
// any attempts will throw helpful warnings upon 'cargo build'
// while this function cannot be invoked directly on the blockchain, it can be called from an invoked function
fn after_counter_change() {
    // show helpful warning that i8 (8-bit signed integer) will overflow above 127 or below -128
    env::log("Make sure you don't overflow, my friend.".as_bytes());
}

'''
'''--- src/test.rs ---
use crate::ColdChain;
use near_sdk::{testing_env, VMContext};
use near_sdk::MockedBlockchain;
use near_sdk::{
    env, ext_contract, near_bindgen, AccountId, Balance, EpochHeight, Promise, PromiseResult,
    PublicKey, 
};
/*
 
fn alice() -> AccountId {
    "alice.near".to_string()
}

fn carol() -> AccountId {
    "carol.near".to_string()
}

fn get_context(input: Vec<u8>, is_view: bool) -> VMContext {
    VMContext {
        current_account_id: "alice_near".to_string(),
        signer_account_id: "bob_near".to_string(),
        signer_account_pk: vec![0, 1, 2],
        predecessor_account_id: "carol_near".to_string(),
        input,
        block_index: 0,
        block_timestamp: 0,
        account_balance: 0,
        account_locked_balance: 0,
        storage_usage: 0,
        attached_deposit: 0,
        prepaid_gas: 10u64.pow(18),
        random_seed: vec![0, 1, 2],
        is_view,
        output_data_receivers: vec![],
        epoch_height: 0,
    }
}
 #[test]
fn test_get_initialized(){
    let context =get_context(vec![], false);
    testing_env!(context);
    let contract = ColdChain::get_initailized();
    assert_eq!(false,contract.get_initalized);
 }

#[test]
fn test_new_delivery(){
   let context =get_context(vec![], false);
    testing_env!(context);
   let contract = ColdChain::default();
 assert_eq!(false,contract.new_delivery);
}

#[test]
fn test_new_arrival(){
    let context =get_context(vec![], false);
    testing_env!(context);
    let contract = ColdChain::new_arrival();
    assert_eq!(false,contract.new_arrival);
}

#[test]
  fn test_withdraw(){
    let context =get_context(vec![], false);
    testing_env!(context);
    let contract = ColdChain::withdraw();
    assert_eq!(false,contract.withdraw);
}

*/

'''