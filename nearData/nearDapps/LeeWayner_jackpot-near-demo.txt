*GitHub Repository "LeeWayner/jackpot-near-demo"*

'''--- .eslintrc.js ---
module.exports = {
	parserOptions: {
		ecmaVersion: 2020,
        sourceType: 'module',
        ecmaFeatures: {
            jsx: true,
        }
    },
	rules: {
        semi: [2, 'always'],
        indent: [2, 'tab'],
	}
};

'''
'''--- README.md ---
# Near Certificate Level 1 Demo

Demo Jackpot
contract name: dev-1638960081273-25835481325504
Deploy transaction id: C93mFeVLF4RqoVjM3HLustiR4DeJkhcELdaM9SWp9Aq5
'''
'''--- contracts/Cargo.toml ---
[package]
name = "basic-token"
version = "0.1.0"
authors = ["Near Inc <hello@near.org>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0.61"
near-sdk = "2.0.0"
borsh = "0.7.1"
wee_alloc = "0.4.5"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true

'''
'''--- contracts/README.md ---
Minimal NEP#4 Implementation
============================

This contract implements bare-minimum functionality to satisfy the [NEP#4](https://github.com/nearprotocol/NEPs/pull/4) specification

Notable limitations of this implementation
==========================================

* Only the token owner can mint tokens.
* You cannot give another account escrow access to a limited set of your tokens; an escrow must be trusted with all of your tokens or none at all
* No functions to return the maximum or current supply of tokens
* No functions to return metadata such as the name or symbol of this NFT
* No functions (or storage primitives) to find all tokens belonging to a given account
* Usability issues: some functions (e.g. `revoke_access`, `transfer`, `get_token_owner`) do not verify that they were given sensible inputs; if given non-existent keys, the errors they throw will not be very useful

Still, if you track some of this information in an off-chain database, these limitations may be acceptable for your needs. In that case, this implementation may help reduce gas and storage costs.

Notable additions that go beyond the specification of NEP#4
===========================================================

`mint_token`: the spec gives no guidance or requirements on how tokens are minted/created/assigned. This specific implementation only allows the contract owner to mint new tokens. If this implementation of `mint_token` is close to matching your needs, feel free to ship your NFT with only minor modifications. If you'd rather go with a strategy such as minting the whole supply of tokens upon deploy of the contract, or something else entirely, you may want to drastically change this behavior.

'''
'''--- contracts/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
mkdir -p ../out
cp target/wasm32-unknown-unknown/release/*.wasm ../out/main.wasm

'''
'''--- contracts/src/lib.rs ---
use borsh::{ BorshDeserialize, BorshSerialize };
use near_sdk::{
    env, near_bindgen, AccountId, Balance, PublicKey, Promise,
    collections::{ UnorderedMap },
    json_types::{ U128, Base58PublicKey },
};
use serde::Serialize;

#[global_allocator]
static ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;

const ONE_NEAR:u128 = 1_000_000_000_000_000_000_000_000;
const PROB:u8 = 128;

#[near_bindgen]

#[derive(Default, BorshDeserialize, BorshSerialize)]
pub struct Jackpot {
    pub owner_id: AccountId,
    pub balance: Balance,
    pub playCount : u8
}

// impl Default for Jackpot {
//     fn default() -> Self {
//         panic!("Should be initialized before usage")
//     }
// }

#[near_bindgen]
impl Jackpot {
    #[init]
    pub fn new(owner_id: AccountId) -> Self {
        assert!(env::is_valid_account_id(owner_id.as_bytes()), "Invalid owner account");
        assert!(!env::state_exists(), "Already initialized");
        Self {
            owner_id,
            balance: 0,
            playCount : 0
        }
    }

    #[payable]
    pub fn deposit(&mut self) {
        let account_id = env::signer_account_id();
        let deposit = env::attached_deposit();
        self.balance = self.balance +  deposit;
        // let mut credits = self.credits.get(&account_id).unwrap_or(0);
        // credits = credits + deposit;
        // self.credits.insert(&account_id, &credits);
    }
    
    #[payable]
    pub fn play(&mut self) -> u8 {
        let account_id = env::signer_account_id();
        let deposit = env::attached_deposit();

        self.playCount= self.playCount + 1;
        let mut win = 0;
        self.balance = self.balance +  deposit;
        if self.playCount > 5
        {
            self.playCount = 0;
            Promise::new(account_id).transfer(self.balance);
            self.balance = 0;
            win = 1;
        }
        win
    }

    pub fn get_balance(&self) -> U128 {
        self.balance.into()
    }
}

'''
'''--- contracts/trust-contract/lib.rs ---
use borsh::{ BorshDeserialize, BorshSerialize };
use near_sdk::{
    env, near_bindgen, AccountId, Balance, Promise,
    collections::{ UnorderedMap },
    json_types::{ U128 },
};

#[global_allocator]
static ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Trust {
    pub owner_id: AccountId,
    pub balances: UnorderedMap<AccountId, Balance>,
}

impl Default for Trust {
    fn default() -> Self {
        panic!("should be initialized before usage")
    }
}

#[near_bindgen]
impl Trust {
    #[init]
    pub fn new(owner_id: AccountId) -> Self {
        assert!(env::is_valid_account_id(owner_id.as_bytes()), "Owner's account ID is invalid.");
        assert!(!env::state_exists(), "Already initialized");
        Self {
            owner_id,
            balances: UnorderedMap::new(b"balances".to_vec()),
        }
    }

    #[payable]
    pub fn deposit(&mut self) {
        let deposit = env::attached_deposit();
        let account_id = env::signer_account_id();
        let mut balance = self.balances.get(&account_id).unwrap_or(0);
        balance += deposit;
        self.balances.insert(&account_id, &balance);
    }

    pub fn withdraw(&mut self, amount: U128) {
        let amount_u128 = amount.into();
        let account_id = env::signer_account_id();
        let mut balance = self.balances.get(&account_id).unwrap_or(0);
        assert!(balance >= amount_u128, "not enough tokens");
        assert!(env::account_balance() >= balance, "missing funds");
        balance -= amount_u128;
        self.balances.insert(&account_id, &balance);
        Promise::new(account_id).transfer(balance);
    }

    pub fn get_balance(&self, account_id: AccountId) -> U128 {
        self.balances.get(&account_id).unwrap_or(0).into()
    }
}

// use the attribute below for unit tests
#[cfg(test)]
mod tests {
    use super::*;
    use near_sdk::MockedBlockchain;
    use near_sdk::{testing_env, VMContext};
    
    fn ntoy(near_amount: u128) -> U128 {
        U128(near_amount * 10u128.pow(24))
    }

    fn get_context() -> VMContext {
        VMContext {
            predecessor_account_id: "alice.testnet".to_string(),
            current_account_id: "alice.testnet".to_string(),
            signer_account_id: "bob.testnet".to_string(),
            signer_account_pk: vec![0, 1, 2],
            input: vec![],
            block_index: 0,
            block_timestamp: 0,
            account_balance: 0,
            account_locked_balance: 0,
            attached_deposit: 0,
            prepaid_gas: 10u64.pow(18),
            random_seed: vec![0, 1, 2],
            is_view: false,
            output_data_receivers: vec![],
            epoch_height: 19,
            storage_usage: 0,
        }
    }

    #[test]
    fn deposit() {
        let mut context = get_context();
        testing_env!(context.clone());
        let mut contract = Trust::new(context.current_account_id.clone());

        context.attached_deposit = ntoy(1000).into();
        testing_env!(context.clone());

        contract.deposit();
        let balance = contract.get_balance(context.signer_account_id.clone());

        assert_eq!(balance, ntoy(1000));
    }

    #[test]
    fn withdraw() {
        let mut context = get_context();
        testing_env!(context.clone());
        let mut contract = Trust::new(context.current_account_id.clone());

        context.attached_deposit = ntoy(1000).into();
        testing_env!(context.clone());

        contract.deposit();
        let balance = contract.get_balance(context.signer_account_id.clone());

        assert_eq!(balance, ntoy(1000));

        contract.withdraw(ntoy(1000));
        let balance = contract.get_balance(context.signer_account_id.clone());

        assert_eq!(balance, U128(0));
    }

    #[test]
    #[should_panic(
        expected = r#"not enough tokens"#
    )]
    fn should_panic_withdraw() {
        let mut context = get_context();
        testing_env!(context.clone());
        let mut contract = Trust::new(context.current_account_id.clone());

        context.attached_deposit = ntoy(1000).into();
        testing_env!(context.clone());

        contract.deposit();
        let balance = contract.get_balance(context.signer_account_id.clone());

        assert_eq!(balance, ntoy(1000));

        contract.withdraw(ntoy(2000));
        let balance = contract.get_balance(context.signer_account_id.clone());

        assert_eq!(balance, U128(0));
    }
}
'''
'''--- package.json ---
{
    "name": "react-parcel-boilerplate",
    "version": "1.0.0",
    "description": "React Parcel Boilerplate",
    "author": "Matt Lockyer",
    "license": "ISC",
    "dependencies": {
        "bn": "^1.0.5",
        "near-api-js": "^0.36.2",
        "near-seed-phrase": "^0.1.0",
        "parcel": "^2.0.0-beta.1",
        "react": "^17.0.1",
        "react-dom": "^17.0.1"
    },
    "devDependencies": {
        "eslint": "^7.14.0",
        "jest": "^26.6.3",
        "jest-environment-uint8array": "^1.0.0",
        "node-fetch": "^2.6.1",
        "rimraf": "^3.0.2"
    },
    "browserslist": [
        "last 2 Chrome versions"
    ],
    "scripts": {
        "prestart": "yarn clean",
        "start:deploy": "yarn test:deploy && yarn start",
        "start": "REACT_APP_ENV=dev parcel src/index.html --open",
        "prebuild": "yarn clean",
        "build": "parcel build src/index.html --no-source-maps",
        "clean": "rimraf ./dist ./parcel-cache",
        "fix": "eslint src/ test/ server/ --fix",
        "build:contracts": "(cd contracts && ./build.sh)",
        "patch:config": "node ./utils/patch-config.js",
        "dev:deploy": "yarn build:contracts && rm -rf neardev && (near dev-deploy || exit 0) && yarn patch:config",
        "test:unit": "(cd contracts && cargo test -- --nocapture --color always)",
        "test:deploy": "yarn dev:deploy && yarn test",
        "test": "REACT_APP_ENV=dev jest app.test.js --useStderr",
        "test:server": "REACT_APP_ENV=dev jest server.test.js --useStderr",
        "deploy": "REACT_APP_ENV=prod yarn build && cp -a static/* dist && gh-pages -d dist"
    },
    "jest": {
        "testEnvironment": "jest-environment-uint8array"
    }
}

'''
'''--- server/app.js ---
const express = require('express');
const cors = require('cors');
const nearAPI = require('near-api-js');
const getConfig = require('../src/config');
const { contractAccount, withNear, hasAccessKey } = require('./middleware/near');
const { contractName } = getConfig();
const {
	
} = nearAPI;

const app = express();
const port = 3000;

app.use(cors());
app.use(express.json());
app.use(withNear());

app.get('/', (req, res) => {
	res.send('Hello World!');
});

app.post('/has-access-key', hasAccessKey, (req, res) => {
	res.json({ success: true });
});

// WARNING NO RESTRICTION ON THIS ENDPOINT
app.post('/add-key', async (req, res) => {
	const { publicKey } = req.body;
	try {
		const result = await contractAccount.addAccessKey(publicKey);
		res.json({ success: true, result });
	} catch(e) {
		return res.status(403).send({ error: `key is already added`});
	}
});

// WARNING NO RESTRICTION ON THIS ENDPOINT
app.get('/delete-access-keys', async (req, res) => {
	const accessKeys = (await contractAccount.getAccessKeys()).filter(({ access_key: { permission }}) => permission && permission.FunctionCall && permission.FunctionCall.receiver_id === contractName);
	try {
		const result = await Promise.all(accessKeys.map(async ({ public_key }) => await contractAccount.deleteKey(public_key)));
		res.json({ success: true, result });
	} catch(e) {
		return res.status(403).send({ error: e.message});
	}
});

app.listen(port, () => {
	console.log(`\nContract Account ID:\n${contractName}\nListening at http://localhost:${port}`);
});
'''
'''--- server/middleware/near.js ---

const nacl = require('tweetnacl');
const crypto = require('crypto');
const bs58 = require('bs58');
const { near, connection, contractAccount } = require('../utils/near-utils');

const withNear = () => (req, res, next) => {
	req.near = near;
	next();
};

const VALID_BLOCK_AGE = 100;

const validBlock = async (blockNumber) => {
	const currentBlock = (await connection.provider.status()).sync_info.latest_block_height;
	const givenBlock = Number(blockNumber);
	if (givenBlock <= currentBlock - VALID_BLOCK_AGE || givenBlock > currentBlock) {
		return false;
	}
	return true;
};

const verifySignature = async (accountId, data, signature, contractName = '') => {
	const nearAccount = await near.account(accountId);
	try {
		const hash = crypto.createHash('sha256').update(data).digest();
		let accessKeys = await nearAccount.getAccessKeys();
		if (contractName.length) {
			accessKeys = accessKeys.filter(({ access_key: { permission }}) => permission && permission.FunctionCall && permission.FunctionCall.receiver_id === contractName);
		} else {
			accessKeys = accessKeys.filter(({ access_key: { permission }}) => permission === 'FullAccess');
		}
		return accessKeys.some(({ public_key }) => {
			const publicKey = public_key.replace('ed25519:', '');
			return nacl.sign.detached.verify(hash, Buffer.from(signature, 'base64'), bs58.decode(publicKey));
		});
	} catch (e) {
		console.error(e);
		return false;
	}
};

const hasAccessKey = async (req, res, next) => {
	const { accountId, contractName, blockNumber, blockNumberSignature } = req.body;
    
	if (!accountId || !contractName || !blockNumber || !blockNumberSignature) {
		return res.status(403).send({ error: 'You must provide an accountId, contractName, blockNumber, and blockNumberSignature' });
	}

	if (!(await validBlock(blockNumber))) {
		return res.status(403).send({ error: `You must provide a blockNumber within ${VALID_BLOCK_AGE} of the most recent block; provided: ${blockNumber}, current: ${currentBlock}`});
	}

	if (!(await verifySignature(accountId, blockNumber, blockNumberSignature, contractName))) {
		return res.status(403).send({ error: `blockNumberSignature did not match a signature of blockNumber=${blockNumber} from accountId=${accountId}`});
	}

	return await next();
};

module.exports = {
	contractAccount,
	withNear,
	hasAccessKey,
};
'''
'''--- server/package.json ---
{
    "name": "server",
    "version": "1.0.0",
    "description": "near utility server",
    "main": "app.js",
    "scripts": {
        "start": "REACT_APP_ENV=dev nodemon app.js",
        "test": "echo \"Error: no test specified\" && exit 1"
    },
    "author": "mattlockyer",
    "license": "ISC",
    "dependencies": {
        "bs58": "^4.0.1",
        "cors": "^2.8.5",
        "express": "^4.17.1",
        "near-api-js": "^0.36.2",
        "tweetnacl": "^1.0.3"
    },
    "devDependencies": {
        "nodemon": "^2.0.7"
    }
}

'''
'''--- server/utils/near-utils.js ---
const fs = require("fs");
const nearAPI = require("near-api-js");
const getConfig = require("../../src/config");
const { nodeUrl, networkId, contractName, contractMethods } = getConfig(true);
const {
	keyStores: { InMemoryKeyStore },
	Near,
	Account,
	Contract,
	KeyPair,
	utils: {
		format: { parseNearAmount },
	},
} = nearAPI;

console.log(
	"Loading Credentials:\n",
	`${process.env.HOME}/.near-credentials/${networkId}/${contractName}.json`
);
const credentials = JSON.parse(
	fs.readFileSync(
		`${process.env.HOME}/.near-credentials/${networkId}/${contractName}.json`
	)
);
const keyStore = new InMemoryKeyStore();
keyStore.setKey(
	networkId,
	contractName,
	KeyPair.fromString(credentials.private_key)
);
const near = new Near({
	networkId,
	nodeUrl,
	deps: { keyStore },
});
const { connection } = near;
const contractAccount = new Account(connection, contractName);
contractAccount.addAccessKey = (publicKey) =>
	contractAccount.addKey(
		publicKey,
		contractName,
		contractMethods.changeMethods,
		parseNearAmount("0.1")
	);
const contract = new Contract(contractAccount, contractName, contractMethods);

module.exports = {
	near,
	keyStore,
	connection,
	contract,
	contractName,
	contractAccount,
};

'''
'''--- src/App.css ---

body {
    margin: 0;
}

.root {
    margin: 16px;
}

button, input {
    margin-right: 16px;
    margin-bottom: 16px;
}

input {
    width: 500px;
}
'''
'''--- src/App.js ---
import React, { useContext, useEffect } from 'react';

import { appStore, onAppMount } from './state/app';

import { Wallet } from './components/Wallet';
import { Contract } from './components/Contract';

import './App.css';

const App = () => {
	const { state, dispatch, update } = useContext(appStore);
    
	const { near, wallet, account, loading } = state;

	const onMount = () => {
		dispatch(onAppMount());
	};
	useEffect(onMount, []);
    
	if (loading) {
		return <div className="root">
			<h3>Workin on it!</h3>
		</div>;
	}
    
	return (
		<div className="root">
			<Wallet {...{ wallet, account }} />
			<Contract {...{ near, update, wallet, account }} />
		</div>
	);
};

export default App;

'''
'''--- src/components/Contract.js ---
import React, { useEffect, useState } from 'react';
import * as nearAPI from 'near-api-js';
import { GAS, parseNearAmount } from '../state/near';
import {
	createAccessKeyAccount,
	getContract,
} from '../utils/near-utils';

const {
	KeyPair,
	utils: { format: { formatNearAmount } }
} = nearAPI;

export const Contract = ({ near, update, account }) => {

	if (!account) return null;

	const [credits, setCredits] = useState('');
	const [amount, setAmount] = useState('');
	const [flips, setFlips] = useState([]);

	useEffect(() => {
		updateBalance();
	}, []);

	const updateBalance = async () => {
		const contract = getContract(account);
		setCredits(await contract.get_balance());
	};

	const handleDeposit = async () => {
		const contract = getContract(account);
		await contract.deposit({}, GAS, parseNearAmount(amount));
		updateBalance();
	};

	const handlePlay = async () => {
		const contract = getContract(account);
		await contract.deposit({}, GAS, parseNearAmount(amount));
		const outcome = await contract.play({}, GAS);
		flips.push(outcome < 128);
		updateBalance();
	};

	return <>
		<h3>Play</h3>
		<p>Current Credits: { formatNearAmount(credits, 0) }</p>
		<input placeholder="Bet Amount (N)" value={amount} onChange={(e) => setAmount(e.target.value)} />
		{/* <br />
        <button onClick={() => handleDeposit()}>Buy Credits</button>
        <br /> */}
		<br />
		<button onClick={() => handlePlay()}>Play Jackpot</button>
		{
			flips.map((f, i) => f ? <p key={i}>Won</p> : <p key={i}>Lost</p>)
		}
	</>;
};

'''
'''--- src/components/Keys.js ---
import React, { useEffect } from 'react';
import * as nearAPI from 'near-api-js';
import { get, set, del } from '../utils/storage';
import { generateSeedPhrase } from 'near-seed-phrase';
import { 
	contractName,
	createAccessKeyAccount,
	postJson,
	postSignedJson
} from '../utils/near-utils';

const LOCAL_KEYS = '__LOCAL_KEYS';

const {
	KeyPair,
	utils: { PublicKey }
} = nearAPI;

export const Keys = ({ near, update, localKeys }) => {
	if (!near.connection) return null;

	useEffect(() => {
		if (!localKeys) loadKeys();
	}, []);

	const loadKeys = async () => {
		const { seedPhrase, accountId, accessPublic, accessSecret } = get(LOCAL_KEYS);
		if (!seedPhrase) return;
		update('localKeys', { seedPhrase, accountId, accessPublic, accessSecret });
	};

	const getNewAccount = async () => {
		update('loading', true);
		const { seedPhrase, publicKey } = generateSeedPhrase();
		const accountId = Buffer.from(PublicKey.from(publicKey).data).toString('hex');
		const keyPair = await getNewAccessKey();
		if (keyPair) {
			const keys = {
				seedPhrase,
				accountId,
				accessPublic: keyPair.publicKey.toString(),
				accessSecret: keyPair.secretKey
			};
			update('localKeys', keys);
			set(LOCAL_KEYS, keys);
		} else {
			alert('Something happened. Try "Get New App Key" again!');
		}
		update('loading', false);
	};

	const getNewAccessKey = async (selfUpdate = false) => {
		const keyPair = KeyPair.fromRandom('ed25519');
		// WARNING NO RESTRICTION ON THIS ENDPOINT
		const result = await postJson({
			url: 'http://localhost:3000/add-key',
			data: { publicKey: keyPair.publicKey.toString() }
		});
		if (result && result.success) {
			const isValid = await checkAccessKey(keyPair);
			if (isValid) {
				if (!localKeys || !selfUpdate) {
					return keyPair;
				}
				localKeys.accessPublic = keyPair.publicKey.toString(),
				localKeys.accessSecret = keyPair.secretKey;
				update('localKeys', localKeys);
				set(LOCAL_KEYS, localKeys);
			}
		}
		return null;
	};

	const checkAccessKey = async (key) => {
		const account = createAccessKeyAccount(near, key);
		const result = await postSignedJson({
			url: 'http://localhost:3000/has-access-key',
			contractName,
			account
		});
		return result && result.success;
	};

	const deleteAccessKeys = async () => {
		update('loading', true);
		// WARNING NO RESTRICTION ON THIS ENDPOINT
		const result = await fetch('http://localhost:3000/delete-access-keys').then((res) => res.json());
		if (result && result.success) {
			update('localKeys', null);
			del(LOCAL_KEYS);
		}
		update('loading', false);
	};

	return <>
		<h3>Implicit Account</h3>
		{ localKeys && localKeys.seedPhrase ?
			<>
				<p><b>Seed Phrase:</b> {localKeys.seedPhrase}</p>
				<p><b>Implicit Account Id:</b> {localKeys.accountId}</p>
				<p><b>App Key:</b> {localKeys.accessPublic}</p>
				<button onClick={() => getNewAccessKey(true)}>Get New App Key</button>
				<br />
				<button onClick={() => deleteAccessKeys()}>Remove Account</button>(warning removes all access keys from contract, for you and everyone else)
			</> :
			<>
				<p>Creates a seed phrase + access key to interact with the app. Normally you would set up your seed phrase with a wallet and the app would add an access key.</p>
				<button onClick={() => getNewAccount()}>Get New Account</button>
			</>
		}
	</>;
};

'''
'''--- src/components/Wallet.js ---
import React from 'react';

export const Wallet = ({ wallet, account }) => {

	if (wallet && wallet.signedIn) {
		return <>
			<h3>Wallet Account</h3>
			<p>Signed In: { account.accountId }</p>
			<p>Balance: { wallet.balance }</p>
			<button onClick={() => wallet.signOut()}>Sign Out</button>
		</>;
	}

	return <>
		<p>Sign in with your NEAR Wallet</p>
		<button onClick={() => wallet.signIn()}>Sign In</button>
	</>;
};

'''
'''--- src/config.js ---
const contractName = 'dev-1638960081273-25835481325504';

module.exports = function getConfig(isServer = false) {
	let config = {
		networkId: "testnet",
		nodeUrl: "https://rpc.testnet.near.org",
		walletUrl: "https://wallet.testnet.near.org",
		helperUrl: "https://helper.testnet.near.org",
		contractName,
	};

	if (process.env.REACT_APP_ENV !== undefined) {
		config = {
			...config,
			GAS: "200000000000000",
			DEFAULT_NEW_ACCOUNT_AMOUNT: "20",
			contractMethods: {
				changeMethods: ["new", "deposit", "play"],
				viewMethods: ["get_credits"],
			},
		};
	}

	if (process.env.REACT_APP_ENV === "prod") {
		config = {
			...config,
			networkId: "mainnet",
			nodeUrl: "https://rpc.mainnet.near.org",
			walletUrl: "https://wallet.near.org",
			helperUrl: "https://helper.mainnet.near.org",
			contractName: "near",
		};
	}

	return config;
};

'''
'''--- src/index.html ---
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>React Parcel Boilerplate</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <script src="./index.js"></script>
  </body>
</html>

'''
'''--- src/index.js ---
import React from 'react';
import ReactDOM from 'react-dom';
import App from './App';
import { AppProvider } from './state/app.js';

ReactDOM.render(
	<AppProvider>
		<App />
	</AppProvider>,
	document.getElementById('root')
);

'''
'''--- src/state/app.js ---
import { State } from '../utils/state';

import { initNear } from './near';

const initialState = {
	app: {
		mounted: false,
	},
	near: {
		initialized: false,
	},
};

export const { appStore, AppProvider } = State(initialState, 'app');

export const onAppMount = () => async ({ update, getState, dispatch }) => {
	update('app', { mounted: true });
	dispatch(initNear());
};

'''
'''--- src/state/near.js ---
import getConfig from '../config';
import * as nearAPI from 'near-api-js';
import { getWallet, postSignedJson } from '../utils/near-utils';

export const {
	GAS,
	networkId, nodeUrl, walletUrl, nameSuffix,
	contractName,
} = getConfig();

export const {
	utils: {
		format: {
			formatNearAmount, parseNearAmount
		}
	}
} = nearAPI;

export const initNear = () => async ({ update, getState, dispatch }) => {
	const { near, wallet } = await getWallet();

	wallet.signIn = () => {
		wallet.requestSignIn(contractName, 'Blah Blah');
	};
	const signOut = wallet.signOut;
	wallet.signOut = () => {
		signOut.call(wallet);
		update('wallet.signedIn', false);
	};

	wallet.signedIn = wallet.isSignedIn();
    
	let account;
	if (wallet.signedIn) {
		account = wallet.account();
		wallet.balance = formatNearAmount((await wallet.account().getAccountBalance()).available, 2);
		await update('', { near, wallet, account });
	}

	await update('', { near, wallet, account });
};

'''
'''--- src/utils/near-utils.js ---
import getConfig from '../config';
import * as nearAPI from 'near-api-js';

export const {
	GAS,
	networkId, nodeUrl, walletUrl, nameSuffix,
	contractName, contractMethods
} = getConfig();

const {
	Account,
	Contract,
	InMemorySigner,
} = nearAPI;

export function getContract(account) {
	return new Contract(account, contractName, { ...contractMethods });
}

export const getWallet = async () => {
	const near = await nearAPI.connect({
		networkId, nodeUrl, walletUrl, deps: { keyStore: new nearAPI.keyStores.BrowserLocalStorageKeyStore() },
	});
	const wallet = new nearAPI.WalletAccount(near);
	return { near, wallet };
};

export const getSignature = async (account, key) => {
	const { accountId } = account;
	const block = await account.connection.provider.block({ finality: 'final' });
	const blockNumber = block.header.height.toString();
	const signer = account.inMemorySigner || account.connection.signer;
	const signed = await signer.signMessage(Buffer.from(blockNumber), accountId, networkId);
	const blockNumberSignature = Buffer.from(signed.signature).toString('base64');
	return { blockNumber, blockNumberSignature };
};

export const postSignedJson = async ({ account, contractName, url, data = {} }) => {
	return await fetch(url, {
		method: 'POST',
		headers: new Headers({ 'content-type': 'application/json' }),
		body: JSON.stringify({
			...data,
			accountId: account.accountId,
			contractName,
			...(await getSignature(account))
		})
	}).then((res) => res.json());
};

export const postJson = async ({ url, data = {} }) => {
	return await fetch(url, {
		method: 'POST',
		headers: new Headers({ 'content-type': 'application/json' }),
		body: JSON.stringify({ ...data })
	}).then((res) => res.json());
};

export const createAccessKeyAccount = (near, key) => {
	key.toString = () => key.secretKey;
	near.connection.signer.keyStore.setKey(networkId, contractName, key);
	const account = new Account(near.connection, contractName);
	return account;
};

/********************************
Not used
********************************/

export const hasKey = async (near, accountId, publicKey) => {
	const pubKeyStr = publicKey.toString();
	const account = new nearAPI.Account(near.connection, accountId);
	try {
		const accessKeys = await account.getAccessKeys();
		if (accessKeys.length > 0 && accessKeys.find(({ public_key }) => public_key === pubKeyStr)) {
			return true;
		}
	} catch (e) {
		console.warn(e);
	}
	return false;
};

export const isAccountTaken = async (near, accountId) => {
	if (accountId.indexOf(nameSuffix) > -1) {
		return true;
	}
	accountId = accountId + nameSuffix;
	const account = new nearAPI.Account(near.connection, accountId);
	try {
		await account.state();
		return true;
	} catch (e) {
		if (!/does not exist/.test(e.toString())) {
			throw e;
		}
	}
	return false;
};

export const getContractSigner = async ({ keyPair }) => {
	const signer = await InMemorySigner.fromKeyPair(networkId, contractName, keyPair);
	const near = await nearAPI.connect({
		networkId, nodeUrl, walletUrl, deps: { keyStore: signer.keyStore },
	});
	const account = new nearAPI.Account(near.connection, contractName);
	const contract = await new nearAPI.Contract(account, contractName, {
		changeMethods: ['send', 'claim', 'create_account_and_claim'],
		sender: account
	});
	return { contract };
};
'''
'''--- src/utils/state.js ---
import React, { createContext, useReducer } from 'react';

export const State = (initialState, prefix) => {
	let updatedState;
	const getState = () => updatedState;
	const store = createContext(initialState);
	const { Provider: InnerProvider } = store;

	const updateState = (state, newState, path = '') => {
		// console.log('updateState', state, path, newState) // debugging
		if (path.length === 0) {
			return { ...state, ...newState };
		}
		const pathArr = path.split('.');
		const first = pathArr[0];
		state = { ...state };
		if (!state[first]) {
			state[first] = {};
		}
		if (pathArr.length === 1) {
			state[first] = !!newState && typeof newState === 'object' && !Array.isArray(newState) ? {
				...state[first],
				...newState
			} : newState;
		} else {
			state[first] = {
				...state[first],
				...updateState(state[first], newState, pathArr.slice(1).join('.'))
			};
		}

		return state;
	};

	const Provider = ({ children }) => {
		const [state, dispatch] = useReducer((state, payload) => {
			const { path, newState } = payload;
			if (path === undefined) {
				return state;
			}
			updatedState = updateState(state, newState, path);
			return updatedState;
		}, initialState);

		const update = (path, newState) => {
			dispatch({ path, newState });
		};
		const wrappedDispatch = (fn) => fn({ update, getState, dispatch: wrappedDispatch });

		return <InnerProvider value={{ update, state, dispatch: wrappedDispatch }}>{children}</InnerProvider>;
	};

	if (prefix) {
		return {
			[prefix + 'Store']: store,
			[prefix.substr(0, 1).toUpperCase() + prefix.substr(1) + 'Provider']: Provider,
		};
	}
    
	return { store, Provider };
};

'''
'''--- src/utils/storage.js ---
export const get = (k, d = {}) => {
	let v = localStorage.getItem(k);
	if (typeof d !== 'object') {
		return v;
	}
	try {
		return JSON.parse(v || JSON.stringify(d));
	} catch (e) {
		return v;
	}
};
export const set = (k, v) => localStorage.setItem(k, typeof v === 'string' ? v : JSON.stringify(v));
export const del = (k) => localStorage.removeItem(k);
'''
'''--- test/app.test.js ---
const nearAPI = require('near-api-js');
const testUtils = require('./test-utils');
const getConfig = require('../src/config');
const { formatNearAmount } = require('near-api-js/lib/utils/format');

const { KeyPair, Account, utils: { format: { parseNearAmount }} } = nearAPI;
const { 
	connection, initContract, getAccount, getContract,
	contract,
	contractAccount, contractName, contractMethods, createAccessKeyAccount
} = testUtils;
const { GAS } = getConfig();

jasmine.DEFAULT_TIMEOUT_INTERVAL = 50000;

describe('deploy contract ' + contractName, () => {
	let alice, contract;

	beforeAll(async () => {
		alice = await getAccount();
		await initContract(alice.accountId);
	});

	test('contract hash', async () => {
		let state = (await new Account(connection, contractName)).state();
		expect(state.code_hash).not.toEqual('11111111111111111111111111111111');
	});

	test('check deposit', async () => {
		contract = await getContract(alice);
		await contract.deposit({}, GAS, parseNearAmount('19'));
		const credits = await contract.get_credits({ account_id: alice.accountId });
		expect(credits).toEqual(parseNearAmount('19'));
	});

	test('check play', async () => {
        contract = await getContract(alice);
		for (let i = 0; i < 5; i++) {
			const rand = await contract.play({}, GAS);
			console.log(rand);
			const credits = await contract.get_credits({ account_id: alice.accountId });
			console.log(credits);
		}

		expect(true);
	});

});
'''
'''--- test/near-utils.js ---
const fs = require("fs");
const nearAPI = require("near-api-js");
const getConfig = require("../src/config");
const { nodeUrl, networkId, contractName, contractMethods } = getConfig(true);
const {
	keyStores: { InMemoryKeyStore },
	Near,
	Account,
	Contract,
	KeyPair,
	utils: {
		format: { parseNearAmount },
	},
} = nearAPI;

console.log(
	"Loading Credentials:\n",
	`${process.env.HOME}/.near-credentials/${networkId}/${contractName}.json`
);
const credentials = JSON.parse(
	fs.readFileSync(
		`${process.env.HOME}/.near-credentials/${networkId}/${contractName}.json`
	)
);
const keyStore = new InMemoryKeyStore();
keyStore.setKey(
	networkId,
	contractName,
	KeyPair.fromString(credentials.private_key)
);
const near = new Near({
	networkId,
	nodeUrl,
	deps: { keyStore },
});
const { connection } = near;
const contractAccount = new Account(connection, contractName);
contractAccount.addAccessKey = (publicKey) =>
	contractAccount.addKey(
		publicKey,
		contractName,
		contractMethods.changeMethods,
		parseNearAmount("0.1")
	);
const contract = new Contract(contractAccount, contractName, contractMethods);

module.exports = {
	near,
	keyStore,
	connection,
	contract,
	contractName,
	contractAccount,
};

'''
'''--- test/server.test.js ---
const nearAPI = require('near-api-js');
const testUtils = require('./test-utils');
const getConfig = require('../src/config');

const { KeyPair, utils: { format: { parseNearAmount }} } = nearAPI;
const { keyStore, initContract, getAccount, contractAccount, postSignedJson, postJson } = testUtils;
const { contractName, networkId } = getConfig();

jasmine.DEFAULT_TIMEOUT_INTERVAL = 50000;

describe('deploy contract ' + contractName, () => {
	let alice;
	let accessKey;

	beforeAll(async () => {
		alice = await getAccount();
		await initContract();
	});

	test('contract hash', async () => {
		let state = await (await getAccount(contractName)).state();
		expect(state.code_hash).not.toEqual('11111111111111111111111111111111');
	});

	test('check wallet sign in', async () => {
		// simulated wallet sign in
		// add a new key and manually set the signer for alice to the access key instead of full access key
		const newKeyPair = KeyPair.fromRandom('ed25519');
		await alice.addKey(newKeyPair.publicKey, contractName, null, parseNearAmount('0.1'));
		keyStore.setKey(networkId, alice.accountId, newKeyPair);
		const result = await postSignedJson({ account: alice, contractName, url: 'http://localhost:3000/has-access-key/' });
		expect(result.success).toEqual(true);
	});

	test('check adding key to contract account', async () => {
		accessKey = KeyPair.fromRandom('ed25519');
		const publicKey = accessKey.publicKey.toString();
		const result = await postJson({
			url: 'http://localhost:3000/add-key/',
			data: {
				publicKey
			}
		});
		expect(result.success).toEqual(true);
		const accessKeys = await contractAccount.getAccessKeys();
		expect(accessKeys.find(({ public_key }) => public_key === publicKey)).not.toEqual(undefined);
	});

	test('check using contract key', async () => {
		// use the access key from the previous test to sign txs on behalf of the contract account now
		keyStore.setKey(networkId, contractName, accessKey);
		const result = await postSignedJson({ account: contractAccount, contractName, url: 'http://localhost:3000/has-access-key/' });
		console.log(result);
		expect(result.success).toEqual(true);
	});

});
'''
'''--- test/test-utils.js ---
const BN = require("bn.js");
const fetch = require("node-fetch");
const nearAPI = require("near-api-js");
const {
	KeyPair,
	Account,
	Contract,
	utils: {
		format: { parseNearAmount },
	},
} = nearAPI;
const {
	near,
	connection,
	keyStore,
	contract,
	contractAccount,
} = require("./near-utils");
const getConfig = require("../src/config");
const { networkId, contractName, contractMethods, DEFAULT_NEW_ACCOUNT_AMOUNT } =
  getConfig();

/********************************
Internal Helpers
********************************/
async function createAccount(
	accountId,
	fundingAmount = DEFAULT_NEW_ACCOUNT_AMOUNT
) {
	const contractAccount = new Account(connection, contractName);
	const newKeyPair = KeyPair.fromRandom("ed25519");
	await contractAccount.createAccount(
		accountId,
		newKeyPair.publicKey,
		new BN(parseNearAmount(fundingAmount))
	);
	keyStore.setKey(networkId, accountId, newKeyPair);
	return new nearAPI.Account(connection, accountId);
}

const getSignature = async (account) => {
	const { accountId } = account;
	const block = await account.connection.provider.block({ finality: "final" });
	const blockNumber = block.header.height.toString();
	const signer = account.inMemorySigner || account.connection.signer;
	const signed = await signer.signMessage(
		Buffer.from(blockNumber),
		accountId,
		networkId
	);
	const blockNumberSignature = Buffer.from(signed.signature).toString("base64");
	return { blockNumber, blockNumberSignature };
};

function generateUniqueString(prefix) {
	return `${prefix}-${Date.now()}-${Math.round(Math.random() * 1000000)}`;
}

/********************************
Exports
********************************/

async function initContract() {
	try {
		await contract.new({ owner_id: contractName });
	} catch (e) {
		if (!/Already initialized/.test(e.toString())) {
			throw e;
		}
	}
	return { contract, contractName };
}

async function getContract(account) {
	return new Contract(account || contractAccount, contractName, {
		...contractMethods,
		signer: account || undefined,
	});
}

async function getAccount(
	accountId,
	fundingAmount = DEFAULT_NEW_ACCOUNT_AMOUNT
) {
	accountId = accountId || generateUniqueString("test");
	const account = new nearAPI.Account(connection, accountId);
	try {
		await account.state();
		return account;
	} catch (e) {
		if (!/does not exist/.test(e.toString())) {
			throw e;
		}
	}
	return await createAccount(accountId, fundingAmount);
}

const createAccessKeyAccount = (key) => {
	connection.signer.keyStore.setKey(networkId, contractName, key);
	return new Account(connection, contractName);
};

const postSignedJson = async ({ account, contractName, url, data = {} }) => {
	return await fetch(url, {
		method: "POST",
		headers: { "content-type": "application/json" },
		body: JSON.stringify({
			...data,
			accountId: account.accountId,
			contractName,
			...(await getSignature(account)),
		}),
	}).then((res) => {
		// console.log(res)
		return res.json();
	});
};

const postJson = async ({ url, data = {} }) => {
	return await fetch(url, {
		method: "POST",
		headers: { "content-type": "application/json" },
		body: JSON.stringify({ ...data }),
	}).then((res) => {
		console.log(res);
		return res.json();
	});
};

module.exports = {
	near,
	connection,
	keyStore,
	getContract,
	contract,
	contractName,
	contractMethods,
	contractAccount,
	createAccessKeyAccount,
	initContract,
	getAccount,
	postSignedJson,
	postJson,
};

'''
'''--- test/trust.test.js ---
const nearAPI = require('near-api-js');
const nearUtils = require('./test-utils');
const getConfig = require('../src/config');

const { Account, utils: { format: { parseNearAmount }} } = nearAPI;
const { connection, initContract, getAccount, getContract } = nearUtils;
const { GAS, contractName } = getConfig();

jasmine.DEFAULT_TIMEOUT_INTERVAL = 50000;

describe('deploy contract ' + contractName, () => {
	let alice;

	beforeAll(async () => {
		alice = await getAccount();
		await initContract(alice.accountId);
	});

	test('contract hash', async () => {
		let state = (await new Account(connection, contractName)).state();
		expect(state.code_hash).not.toEqual('11111111111111111111111111111111');
	});

	test('check deposit', async () => {
		console.log('alice balance', (await alice.state()).amount);

		const contract = await getContract(alice);
		await contract.deposit({}, GAS, parseNearAmount('1.123'));
		const balance = await contract.get_balance({ account_id: alice.accountId });

		// weird bug where you have to get new Account instance before state will give you latest balance
		alice = await getAccount(alice.accountId);
		expect((await alice.state()).amount).not.toEqual(parseNearAmount('5'));
		expect(balance).toEqual(parseNearAmount('1.123'));
	});

	// contract has the same state (hasn't been redeployed) and "alice" account is the same
	test('check withdraw', async () => {
		const contract = await getContract(alice);
		await contract.withdraw({ amount: parseNearAmount('0.123') }, GAS);
		const balance = await contract.get_balance({ account_id: alice.accountId });
		expect(balance).toEqual(parseNearAmount('1'));
	});

});
'''
'''--- utils/patch-config.js ---
const fs = require('fs');
const contractName = fs.readFileSync('./neardev/dev-account').toString()
const path = './src/config.js'
 
fs.readFile(path, 'utf-8', function(err, data) {
    if (err) throw err;
 
    data = data.replace(/.*const contractName.*/gim, `const contractName = '${contractName}';`);
 
    fs.writeFile(path, data, 'utf-8', function(err) {
        if (err) throw err;
        console.log('Done!');
    })
})

'''