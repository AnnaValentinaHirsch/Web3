*GitHub Repository "near/sandbox"*

'''--- .github/workflows/docker-image.yml ---
name: Docker Image

on:
  push:
    branches:
      - main
jobs:
  build:
    runs-on: ubuntu-latest
    name: Build and Push
    permissions:
      packages: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Login to GitHub Container Registry
        run: echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u $ --password-stdin

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Build Docker image
        uses: docker/build-push-action@v4
        with:
          context: .
          tags: ghcr.io/near/sandbox:${{ github.sha }}
          load: true
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Push Docker image
        run: docker push ghcr.io/near/sandbox:${{ github.sha }}

      - name: Push latest Docker image
        run: docker tag ghcr.io/near/sandbox:${{ github.sha }} ghcr.io/near/sandbox:latest && docker push ghcr.io/near/sandbox:latest

'''
'''--- .github/workflows/release.yml ---
name: Release

on:
  push:
    branches:
      - main

concurrency: ${{ github.workflow }}-${{ github.ref }}

jobs:
  release:
    name: Release
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./npm
    permissions:
      contents: write
      issues: write
      pull-requests: write
    environment: NPM
    steps:
      - name: Checkout Repo
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: 16.x

      - name: Install Dependencies
        run: npm install

      - name: Build Packages
        run: npm run build

      - name: Create Release Pull Request or Publish to NPM
        # use changesets/action to create PR and auto release
        uses: changesets/action@v1
        with:
          publish: npm run release
          cwd: "./npm"
          commit: "chore(release): publish packages"
          title: "Publish packages"
          createGithubReleases: true
        env:
          GITHUB_TOKEN: ${{ github.token }}
          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}

'''
'''--- .github/workflows/rust.yml ---
name: Rust

permissions:
  pull-requests: write
  contents: write

on:
  push:
    branches: [ main ]
  pull_request:

env:
  CARGO_TERM_COLOR: always
  RUSTFLAGS: '-D warnings'
  CARGO_INCREMENTAL: 0
  RUST_BACKTRACE: short

defaults:
  run:
    working-directory: ./crate

jobs:
  clippy:
    runs-on: ubuntu-20.04

    steps:
    - uses: actions/checkout@v4
    - name: Run clippy
      run: cargo clippy --benches -- -D clippy::all

  cargo-fmt:
    runs-on: ubuntu-20.04

    steps:
    - uses: actions/checkout@v4
    - name: Run cargo fmt
      run: cargo fmt --check

  # there're sometimes warnings, which signal, that the generated doc
  # won't look as expected, when rendered, and sometimes errors, which will prevent doc from being
  # generated at release time altogether.
  cargo-doc:
    runs-on: ubuntu-20.04

    steps:
    - uses: actions/checkout@v4
    - name: run cargo doc
      run: RUSTDOCFLAGS="-D warnings" cargo doc

  release-plz:
    runs-on: ubuntu-latest
    needs: [clippy, cargo-fmt, cargo-doc]
    if: github.ref == 'refs/heads/main'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.MY_GITHUB_TOKEN }}
      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable
      - name: Run release-plz
        uses: MarcoIeni/release-plz-action@v0.5
        env:
          # https://release-plz.ieni.dev/docs/github/trigger
          GITHUB_TOKEN: ${{ secrets.MY_GITHUB_TOKEN }}
          CARGO_REGISTRY_TOKEN: ${{ secrets.CARGO_REGISTRY_TOKEN }}

'''
'''--- .github/workflows/tests.yml ---
name: Tests
on: push
jobs:
  tests:
    strategy:
      matrix:
        platform: [ubuntu-latest, macos-latest]
        node-version: ['14', '15', '16']
    runs-on: ${{ matrix.platform }}
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v2
        with:
          node-version: ${{ matrix.node-version }}
      - name: Run tests
        run: cd npm && yarn && yarn test --verbose
'''
'''--- Cargo.toml ---
# XXX: This is a workaround for https://github.com/MarcoIeni/release-plz/issues/1004
# This file should be removed once that issue is resolved
[workspace]
members = ["crate"]

'''
'''--- README.md ---
# NEAR Sandbox

NEAR Sandbox lets you easily run a local NEAR blockchain.

NEAR Sandbox is a [custom build](https://github.com/near/nearcore/blob/9f5e20b29f1a15a00fc50d6051b3b44bb6db60b6/Makefile#L67-L69) of the NEAR blockchain optimized for local development and testing. If you're familiar with [Ganache for Ethereum](https://www.trufflesuite.com/ganache), this is similar.

This repository contains code to quickly install pre-built binaries of NEAR Sandbox for multiple programming languages (currently just NodeJS; Rust coming soon) and operating systems (currently just Intel-based Macs and Debian/Ubuntu-flavored Linux distros using Intel processors).

# Using NEAR Sandbox

If you just want to run tests against a NEAR Sandbox instance, check out [near-workspaces](https://github.com/near/workspaces) for your favorite language:
- [JavaScript](https://github.com/near/workspaces-js)
- [Rust](https://github.com/near/workspaces-rs)

Tip: `near-runner` includes `near-sandbox` as a dependency, so you will not need to install or run `near-sandbox` on its own.

If you want to run NEAR Sandbox on its own, continue reading.

## Install

### With [npm](https://www.npmjs.com/)

    npm i -g near-sandbox

Note: If you have trouble downloading binary from IPFS gateway, you can upload a pre-built near-sandbox tar file to any file storage service and use `SANDBOX_ARTIFACT_URL` environment variable to specify it's base URL.
e.g. `> SANDBOX_ARTIFACT_URL=https://s3.aws.com/my-binary npm i near-sandbox`

### With Rust

Coming soon

### From Source

* Install [Rust with correct build target](https://docs.near.org/develop/prerequisites)

* Clone [nearcore](https://github.com/near/nearcore)

      git clone https://github.com/near/nearcore

* `cd` into your `nearcore` folder and run `make sandbox`

      cd nearcore
      make sandbox

* For ease-of-use, you can copy (or [symlink](https://kb.iu.edu/d/abbe)) the binary to somewhere in your [PATH](https://www.cloudsavvyit.com/1933/what-is-the-unix-path-and-how-do-you-add-programs-to-it/). For example, if you have a `~/bin` folder:

      cp target/debug/near-sandbox ~/bin/

## Use

* Initialize the Sandbox node

      near-sandbox --home /tmp/near-sandbox init

* Run it

      near-sandbox --home /tmp/near-sandbox run

To find out other things you can do:

    near-sandbox --help

## Stop

Once you're finished using the sandbox node you can stop it by using <kbd>Ctrl</kbd><kbd>C</kbd>. To clean up the data it generates:

    rm -rf /tmp/near-sandbox

# What's special about NEAR Sandbox

NEAR Sandbox includes custom features to make tweaking local and test environments easier.

* `sandbox_patch_state` RPC call, used by [`patchState` in runner-js](https://github.com/near/runner-js#patch-state-on-the-fly), useful for making arbitrary state mutations on any contract or account

'''
'''--- crate/CHANGELOG.md ---
# Changelog
All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

## [0.7.1](https://github.com/near/near-sandbox/compare/v0.7.0...v0.7.1) - 2024-04-01

### Added
- Update default nearcore version to v1.38.0 ([#81](https://github.com/near/near-sandbox/pull/81))

## [0.7.0](https://github.com/near/near-sandbox/compare/v0.6.3...v0.7.0) - 2023-10-04

### Added
- use tokio instead of async-process as dependants use tokio runtime anyway ([#68](https://github.com/near/near-sandbox/pull/68))

### Fixed
- pin async-process crate ([#66](https://github.com/near/near-sandbox/pull/66))

### Other
- use SANDBOX_ARTIFACT_URL ([#74](https://github.com/near/near-sandbox/pull/74))

## [0.6.3](https://github.com/near/sandbox/compare/v0.6.2...v0.6.3) - 2023-09-30

### Added
- Expose DEFAULT_NEAR_SANDBOX_VERSION const
- run sandbox instance with --fast flag ([#56](https://github.com/near/sandbox/pull/56))
- Allow to specify verion of neard-sandbox ([#63](https://github.com/near/sandbox/pull/63))

### Other
- Fixed linting warnings
- point nearcore to latest mainnet release 1.35.0 ([#61](https://github.com/near/sandbox/pull/61))
- Update crate/Cargo.toml
- update dependencies

'''
'''--- crate/Cargo.toml ---
[package]
name = "near-sandbox-utils"
version = "0.7.1"
edition = "2018"
license = "MIT OR Apache-2.0"
repository = "https://github.com/near/sandbox"
description = """
Utility library for launching NEAR sandbox environments.
"""

[dependencies]
anyhow = "1"
tokio = { version = "1", features = ["process"] }
binary-install = "0.2.0"
chrono = "0.4"
fs2 = "0.4"
home = "0.5.5"

[features]
global_install = []

'''
'''--- crate/build.rs ---
// HACK: need this build script so that env var OUT_DIR gets set:
// https://doc.rust-lang.org/cargo/reference/environment-variables.html#environment-variables-cargo-sets-for-crates
fn main() {}

'''
'''--- crate/src/lib.rs ---
use anyhow::{anyhow, Context};
use binary_install::Cache;
use chrono::Utc;
use fs2::FileExt;
use tokio::process::{Child, Command};

use std::fs::File;
use std::path::{Path, PathBuf};

pub mod sync;

// The current version of the sandbox node we want to point to.
// Should be updated to the latest release of nearcore.
// Currently pointing to nearcore@v1.38.0 released on March 18, 2024
pub const DEFAULT_NEAR_SANDBOX_VERSION: &str = "1.38.0/aac5e42fe8975e27faca53e31f53f9c67a5b4e35";

const fn platform() -> Option<&'static str> {
    #[cfg(all(target_os = "linux", target_arch = "x86_64"))]
    return Some("Linux-x86_64");

    #[cfg(all(target_os = "macos", target_arch = "x86_64"))]
    return Some("Darwin-x86_64");

    #[cfg(all(target_os = "macos", target_arch = "aarch64"))]
    return Some("Darwin-arm64");

    #[cfg(all(
        not(target_os = "macos"),
        not(all(target_os = "linux", target_arch = "x86_64"))
    ))]
    return None;
}

fn local_addr(port: u16) -> String {
    format!("0.0.0.0:{}", port)
}

// if the `SANDBOX_ARTIFACT_URL` env var is set, we short-circuit and use that.
fn bin_url(version: &str) -> Option<String> {
    if let Ok(val) = std::env::var("SANDBOX_ARTIFACT_URL") {
        return Some(val);
    }

    Some(format!(
        "https://s3-us-west-1.amazonaws.com/build.nearprotocol.com/nearcore/{}/{}/near-sandbox.tar.gz",
        platform()?,
        version,
    ))
}

fn download_path() -> PathBuf {
    if cfg!(feature = "global_install") {
        let mut buf = home::home_dir().expect("could not retrieve home_dir");
        buf.push(".near");
        buf
    } else {
        PathBuf::from(env!("OUT_DIR"))
    }
}

/// Returns a path to the binary in the form of {home}/.near/near-sandbox-{hash}/near-sandbox
pub fn bin_path() -> anyhow::Result<PathBuf> {
    if let Ok(path) = std::env::var("NEAR_SANDBOX_BIN_PATH") {
        let path = PathBuf::from(path);
        if !path.exists() {
            anyhow::bail!("binary {} does not exist", path.display());
        }
        return Ok(path);
    }

    let mut buf = download_path();
    buf.push("near-sandbox");

    Ok(buf)
}

/// Install the sandbox node given the version, which is either a commit hash or tagged version
/// number from the nearcore project. Note that commits pushed to master within the latest 12h
/// will likely not have the binaries made available quite yet.
pub fn install_with_version(version: &str) -> anyhow::Result<PathBuf> {
    // Download binary into temp dir
    let tmp_dir = format!("near-sandbox-{}", Utc::now());
    let dl_cache = Cache::at(&download_path());
    let bin_path = bin_url(version)
        .ok_or_else(|| anyhow!("Unsupported platform: only linux-x86 and macos are supported"))?;
    let dl = dl_cache
        .download(true, &tmp_dir, &["near-sandbox"], &bin_path)
        .map_err(anyhow::Error::msg)
        .with_context(|| "unable to download near-sandbox")?
        .ok_or_else(|| anyhow!("Could not install near-sandbox"))?;

    let path = dl.binary("near-sandbox").map_err(anyhow::Error::msg)?;

    // Move near-sandbox binary to correct location from temp folder.
    let dest = download_path().join("near-sandbox");
    std::fs::rename(path, &dest)?;

    Ok(dest)
}

/// Installs sandbox node with the default version. This is a version that is usually stable
/// and has landed into mainnet to reflect the latest stable features and fixes.
pub fn install() -> anyhow::Result<PathBuf> {
    install_with_version(DEFAULT_NEAR_SANDBOX_VERSION)
}

fn installable(bin_path: &Path) -> anyhow::Result<Option<std::fs::File>> {
    // Sandbox bin already exists
    if bin_path.exists() {
        return Ok(None);
    }

    let mut lockpath = bin_path.to_path_buf();
    lockpath.set_extension("lock");

    // Acquire the lockfile
    let lockfile = File::create(lockpath)?;
    lockfile.lock_exclusive()?;

    // Check again after acquiring if no one has written to the dest path
    if bin_path.exists() {
        Ok(None)
    } else {
        Ok(Some(lockfile))
    }
}

pub fn ensure_sandbox_bin() -> anyhow::Result<PathBuf> {
    ensure_sandbox_bin_with_version(DEFAULT_NEAR_SANDBOX_VERSION)
}

pub fn run_with_options(options: &[&str]) -> anyhow::Result<Child> {
    let bin_path = crate::ensure_sandbox_bin()?;
    Command::new(&bin_path)
        .args(options)
        .envs(crate::log_vars())
        .spawn()
        .with_context(|| format!("failed to run sandbox using '{}'", bin_path.display()))
}

pub fn run(home_dir: impl AsRef<Path>, rpc_port: u16, network_port: u16) -> anyhow::Result<Child> {
    run_with_version(
        home_dir,
        rpc_port,
        network_port,
        DEFAULT_NEAR_SANDBOX_VERSION,
    )
}

pub fn init(home_dir: impl AsRef<Path>) -> anyhow::Result<Child> {
    init_with_version(home_dir, DEFAULT_NEAR_SANDBOX_VERSION)
}

pub fn ensure_sandbox_bin_with_version(version: &str) -> anyhow::Result<PathBuf> {
    let mut bin_path = bin_path()?;
    if let Some(lockfile) = installable(&bin_path)? {
        bin_path = install_with_version(version)?;
        println!("Installed near-sandbox into {}", bin_path.to_str().unwrap());
        std::env::set_var("NEAR_SANDBOX_BIN_PATH", bin_path.as_os_str());
        lockfile.unlock()?;
    }
    Ok(bin_path)
}

pub fn run_with_options_with_version(options: &[&str], version: &str) -> anyhow::Result<Child> {
    let bin_path = crate::ensure_sandbox_bin_with_version(version)?;
    Command::new(&bin_path)
        .args(options)
        .envs(crate::log_vars())
        .spawn()
        .with_context(|| format!("failed to run sandbox using '{}'", bin_path.display()))
}

pub fn run_with_version(
    home_dir: impl AsRef<Path>,
    rpc_port: u16,
    network_port: u16,
    version: &str,
) -> anyhow::Result<Child> {
    let home_dir = home_dir.as_ref().to_str().unwrap();
    run_with_options_with_version(
        &[
            "--home",
            home_dir,
            "run",
            "--rpc-addr",
            &local_addr(rpc_port),
            "--network-addr",
            &local_addr(network_port),
        ],
        version,
    )
}

pub fn init_with_version(home_dir: impl AsRef<Path>, version: &str) -> anyhow::Result<Child> {
    let bin_path = ensure_sandbox_bin_with_version(version)?;
    let home_dir = home_dir.as_ref().to_str().unwrap();
    Command::new(&bin_path)
        .envs(log_vars())
        .args(["--home", home_dir, "init", "--fast"])
        .spawn()
        .with_context(|| format!("failed to init sandbox using '{}'", bin_path.display()))
}

fn log_vars() -> Vec<(String, String)> {
    let mut vars = Vec::new();
    if let Ok(val) = std::env::var("NEAR_SANDBOX_LOG") {
        vars.push(("RUST_LOG".into(), val));
    }
    if let Ok(val) = std::env::var("NEAR_SANDBOX_LOG_STYLE") {
        vars.push(("RUST_LOG_STYLE".into(), val));
    }
    vars
}

'''
'''--- crate/src/sync.rs ---
use std::path::Path;
use std::process::{Child, Command};

pub fn run_with_options(options: &[&str]) -> anyhow::Result<Child> {
    let bin_path = crate::ensure_sandbox_bin()?;
    Command::new(bin_path)
        .args(options)
        .envs(crate::log_vars())
        .spawn()
        .map_err(Into::into)
}

pub fn run(home_dir: impl AsRef<Path>, rpc_port: u16, network_port: u16) -> anyhow::Result<Child> {
    let home_dir = home_dir.as_ref().to_str().unwrap();
    run_with_options(&[
        "--home",
        home_dir,
        "run",
        "--rpc-addr",
        &crate::local_addr(rpc_port),
        "--network-addr",
        &crate::local_addr(network_port),
    ])
}

pub fn init(home_dir: impl AsRef<Path>) -> anyhow::Result<Child> {
    let bin_path = crate::ensure_sandbox_bin()?;
    let home_dir = home_dir.as_ref().to_str().unwrap();
    Command::new(bin_path)
        .envs(crate::log_vars())
        .args(["--home", home_dir, "init"])
        .spawn()
        .map_err(Into::into)
}

'''
'''--- npm/.changeset/README.md ---
# Changesets

Hello and welcome! This folder has been automatically generated by `@changesets/cli`, a build tool that works
with multi-package repos, or single-package repos to help you version and publish your code. You can
find the full documentation for it [in our repository](https://github.com/changesets/changesets)

We have a quick list of common questions to get you started engaging with this project in
[our documentation](https://github.com/changesets/changesets/blob/main/docs/common-questions.md)

'''
'''--- npm/.changeset/config.json ---
{
  "$schema": "https://unpkg.com/@changesets/config@2.3.1/schema.json",
  "changelog": "@changesets/cli/changelog",
  "commit": false,
  "fixed": [],
  "linked": [],
  "access": "restricted",
  "baseBranch": "main",
  "updateInternalDependencies": "patch",
  "ignore": []
}
'''
'''--- npm/__tests__/path.test.ts ---
import test from "ava";
import { join } from "path";
import { Binary } from "../src";

const TEST_FILES_PATH = join(__dirname, "..", "test_files");
process.env['NEAR_SANDBOX_BINARY_PATH'] = TEST_FILES_PATH;

const name = "near-sandbox";
const fakeUrl = "https://example.com";

test("can use local file", async (t) => {
  const bin = await Binary.create(name, fakeUrl);
  t.is(bin.installDir, TEST_FILES_PATH);
  t.assert(await bin.exists());
});

'''
'''--- npm/__tests__/test.ts ---
import test from "ava";
import { join, resolve } from "path";
import { Binary } from "../src";
import { AWSUrl } from "../src/getBinary";
import { fileExists, inherit, rm } from "../src/utils";

process.env['PATH'] = "";
const isCI = process.env["CI"];
const name = "near-sandbox";
const LOCAL_PATH = Binary.DEFAULT_INSTALL_DIR;
const LOCAL_BIN_PATH = join(LOCAL_PATH, name);
const fakeUrl = "https://example.com";
const realUrl = AWSUrl();

const TEST_BIN_DESTINATION =  join(__dirname, "..", 'test_destination');

test.before(async (t) => {
  await rm(LOCAL_BIN_PATH)
  t.false(await fileExists(LOCAL_BIN_PATH));
});

test("can create", async (t) => {
  const bin = await Binary.create(name, fakeUrl);
  t.is(bin.name, name);
  t.deepEqual(bin.urls[0], new URL(fakeUrl));
  t.is(bin.installDir, LOCAL_PATH);
  t.false(await bin.exists());
});

test("throws if url is bad", async (t) => {
  const bin = await Binary.create(name, fakeUrl);
  await t.throwsAsync(bin.install());
})

test("can install and uninstall file", async (t) => {
  const bin = await Binary.create(name, realUrl);
  t.is(bin.name, name);
  t.deepEqual(bin.urls[0], new URL(realUrl));
  t.is(bin.installDir, LOCAL_PATH);
  t.false(await bin.exists());
  t.assert(await bin.install());
  t.assert(await bin.exists());

  await bin.uninstall();
  t.false(await bin.exists())
});

test("can install file to destination", async (t) => {
  const p = TEST_BIN_DESTINATION;
  const bin = await Binary.create(name, realUrl, p);
  await rm(join(p, name));
  t.is(bin.name, name);
  t.deepEqual(bin.urls[0], new URL(realUrl));
  t.not(bin.installDir, LOCAL_PATH);
  t.false(await bin.exists());
  t.assert(await bin.install());
  t.assert(await bin.exists());
});

test("can install file to destination with multiple urls", async (t) => {
  const p = TEST_BIN_DESTINATION;
  const bin = await Binary.create(name, [fakeUrl, realUrl], p);
  await rm(join(p, name));
  t.is(bin.name, name);
  t.deepEqual(bin.urls[1], new URL(realUrl));
  t.not(bin.installDir, LOCAL_PATH);
  t.false(await bin.exists());
  t.assert(await bin.install());
  t.assert(await bin.exists());
});

test("can use local file", async (t) => {
  const localPath = resolve(join(__dirname, "..", "test_files"));
  const bin = await Binary.create(name, realUrl, localPath);
  t.is(bin.installDir, localPath);
  t.assert(await bin.exists());
});

test("can install and then run", async (t) => {
  const p = join(TEST_BIN_DESTINATION, "install_then_run");
  await rm(join(p, name));
  const bin = await Binary.create(name, realUrl, p);
  await bin.install();
  const stdio = isCI ? [null, inherit, inherit] : [null, null, null];
  const res = await bin.run(["--help"], { stdio });
  t.not(res, 1);
});

test("can run without install", async (t) => {
  const p = join(TEST_BIN_DESTINATION, "to_run");
  await rm(join(p, name));
  const bin = await Binary.create(name, realUrl, p);
  const stdio = isCI ? [null, inherit, inherit] : [null, null, null];
  const res = await bin.run(["--help"], { stdio });
  t.not(res, 1);
});

'''
'''--- npm/dist/getBinary.d.ts ---
import { Binary } from ".";
export declare function AWSUrl(): string;
export declare function getBinary(name?: string): Promise<Binary>;

'''
'''--- npm/dist/getBinary.js ---
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBinary = exports.AWSUrl = void 0;
const _1 = require(".");
const path_1 = require("path");
const os = require("os");
function getPlatform() {
    const type = os.type();
    const arch = os.arch();
    if ((type === "Linux" || type === "Darwin") && arch === "x64") {
        return [type, "x86_64"];
    }
    else if (type === "Darwin" && arch === "arm64") {
        return [type, "arm64"];
    }
    throw new Error(`Unsupported platform: ${type} ${arch}`);
}
function AWSUrl() {
    const [platform, arch] = getPlatform();
    return `https://s3-us-west-1.amazonaws.com/build.nearprotocol.com/nearcore/${platform}-${arch}/1.38.0/aac5e42fe8975e27faca53e31f53f9c67a5b4e35/near-sandbox.tar.gz`;
}
exports.AWSUrl = AWSUrl;
function getBinary(name = "near-sandbox") {
    if (!process.env["NEAR_SANDBOX_BIN_PATH"]) {
        process.env["NEAR_SANDBOX_BINARY_PATH"] = (0, path_1.join)(os.homedir(), ".near", "sandbox");
    }
    // Will use version after publishing to AWS
    // const version = require("./package.json").version;
    const fromEnv = process.env["SANDBOX_ARTIFACT_URL"];
    const urls = [AWSUrl()];
    if (fromEnv) {
        urls.unshift(fromEnv);
    }
    return _1.Binary.create(name, urls);
}
exports.getBinary = getBinary;

'''
'''--- npm/dist/index.d.ts ---
/// <reference types="node" />
import { URL } from "url";
export declare class Binary {
    name: string;
    installDir: string;
    urls: URL[];
    static readonly DEFAULT_INSTALL_DIR: string;
    protected constructor(name: string, url: string | URL | string[] | URL[], installDir?: string);
    /**
     *
     * @param name binary name, e.g. 'git'
     * @param path URL of where to find binary
     * @param destination Directory to put the binary
     * @returns
     */
    static create(name: string, path: string | URL | string[] | URL[], destination?: string): Promise<Binary>;
    get binPath(): string;
    download(url: URL): Promise<void>;
    install(): Promise<boolean>;
    exists(): Promise<boolean>;
    run(cliArgs?: string[], options?: {
        stdio: ("inherit" | null)[];
    }): Promise<number>;
    runAndExit(cliArgs?: string[], options?: {
        stdio: ("inherit" | null)[];
    }): Promise<void>;
    uninstall(): Promise<void>;
}

'''
'''--- npm/dist/index.js ---
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Binary = void 0;
const fs = require("fs/promises");
const url_1 = require("url");
const path_1 = require("path");
const tar = require("tar");
const got_1 = require("got");
const utils_1 = require("./utils");
const child_process_1 = require("child_process");
const stream = require("stream");
const util_1 = require("util");
const pipeline = (0, util_1.promisify)(stream.pipeline);
class Binary {
    constructor(name, url, installDir = Binary.DEFAULT_INSTALL_DIR) {
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: name
        });
        Object.defineProperty(this, "installDir", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: installDir
        });
        Object.defineProperty(this, "urls", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        let errors = [];
        let urls = [];
        if (typeof url === "string" || url instanceof url_1.URL) {
            urls.push(url);
        }
        else {
            if (url.length == 0) {
                throw new Error("No URL provided got empty array");
            }
            urls = url;
        }
        if (!name || typeof name !== "string") {
            errors.push("You must specify the name of your binary as a string");
        }
        try {
            this.urls = urls.map((path) => typeof path === "string" ? new url_1.URL(path) : path);
        }
        catch (e) {
            errors.push(e);
        }
        if (errors.length > 0) {
            errors.push('\nCorrect usage: new Binary("my-binary", "https://example.com/binary/download.tar.gz"');
            errors.unshift("One or more of the parameters you passed to the Binary constructor are invalid:\n");
            throw new Error(errors.join("\n"));
        }
    }
    /**
     *
     * @param name binary name, e.g. 'git'
     * @param path URL of where to find binary
     * @param destination Directory to put the binary
     * @returns
     */
    static async create(name, path, destination) {
        const bin = new Binary(name, path, destination !== null && destination !== void 0 ? destination : (await (0, utils_1.searchPath)(name)));
        if (destination === bin.installDir) {
            await fs.mkdir(bin.installDir, { recursive: true });
        }
        return bin;
    }
    get binPath() {
        return (0, path_1.join)(this.installDir, this.name);
    }
    download(url) {
        return pipeline(got_1.default.stream(url), new stream.PassThrough(), tar.x({ strip: 1, C: this.installDir }));
    }
    async install() {
        for (let url of this.urls) {
            try {
                await this.download(url);
                return true;
            }
            catch (error) { }
        }
        throw new Error(`Failed to download from: \n${this.urls.join("\n")}`);
    }
    async exists() {
        return await (0, utils_1.fileExists)(this.binPath);
    }
    async run(cliArgs, options = { stdio: [null, utils_1.inherit, utils_1.inherit] }) {
        if (!(await this.exists())) {
            try {
                await this.install();
            }
            catch (err) {
                console.error(err);
                return 1;
            }
        }
        const args = cliArgs !== null && cliArgs !== void 0 ? cliArgs : process.argv.slice(2);
        const result = (0, child_process_1.spawn)(this.binPath, args, options);
        result.on("error", (error) => {
            console.log(error);
        });
        return new Promise((resolve, reject) => {
            result.on("close", (code) => {
                if (!code) {
                    resolve(code !== null && code !== void 0 ? code : 0);
                }
                reject(code);
            });
        });
    }
    async runAndExit(cliArgs, options = { stdio: [null, utils_1.inherit, utils_1.inherit] }) {
        process.exit(await this.run(cliArgs, options));
    }
    async uninstall() {
        if (this.installDir === Binary.DEFAULT_INSTALL_DIR &&
            (await this.exists())) {
            await (0, utils_1.rm)(this.binPath);
            if (await this.exists()) {
                throw new Error(`Failed to remove binary located ${this.binPath}`);
            }
        }
    }
}
exports.Binary = Binary;
Object.defineProperty(Binary, "DEFAULT_INSTALL_DIR", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: (0, path_1.join)(__dirname, "..", "bin")
});

'''
'''--- npm/dist/install.d.ts ---
export {};

'''
'''--- npm/dist/install.js ---
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const getBinary_1 = require("./getBinary");
(0, getBinary_1.getBinary)().then(async (bin) => {
    if (!(await bin.exists())) {
        await bin.install();
    }
});

'''
'''--- npm/dist/run.d.ts ---
export {};

'''
'''--- npm/dist/run.js ---
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const getBinary_1 = require("./getBinary");
async function run() {
    try {
        const bin = await (0, getBinary_1.getBinary)();
        if (process.argv.length < 3) {
            process.argv.push("--help");
        }
        bin.runAndExit();
    }
    catch (err) {
        console.error(err);
        process.exit(1);
    }
}
run();

'''
'''--- npm/dist/test.d.ts ---
export {};

'''
'''--- npm/dist/uninstall.d.ts ---
export {};

'''
'''--- npm/dist/uninstall.js ---
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const getBinary_1 = require("./getBinary");
(0, getBinary_1.getBinary)().then(async (bin) => await bin.uninstall());

'''
'''--- npm/dist/utils.d.ts ---
export declare function fileExists(s: string): Promise<boolean>;
export declare function searchPath(filename: string): Promise<string | undefined>;
export declare const inherit: "inherit";
export declare function rm(path: string): Promise<void>;

'''
'''--- npm/dist/utils.js ---
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.rm = exports.inherit = exports.searchPath = exports.fileExists = void 0;
const promises_1 = require("fs/promises");
const path_1 = require("path");
async function fileExists(s) {
    try {
        const f = await (0, promises_1.stat)(s);
        return f.isFile();
    }
    catch {
        return false;
    }
}
exports.fileExists = fileExists;
async function searchPath(filename) {
    const binPath = process.env["NEAR_SANDBOX_BINARY_PATH"];
    if (binPath &&
        binPath.length > 0 &&
        (await fileExists((0, path_1.join)(binPath, filename)))) {
        return binPath;
    }
    return undefined;
}
exports.searchPath = searchPath;
exports.inherit = "inherit";
async function rm(path) {
    try {
        await (0, promises_1.rm)(path);
    }
    catch (e) { }
}
exports.rm = rm;

'''
'''--- npm/getBinary.js ---
module.exports = require("./dist/getBinary");

'''
'''--- npm/install.js ---
module.exports = require("./dist/install");

'''
'''--- npm/package.json ---
{
  "name": "near-sandbox",
  "version": "0.0.18",
  "description": "CLI tool for testing NEAR smart contracts",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "bin": {
    "near-sandbox": "./run.js",
    "sandbox": "./run.js"
  },
  "repository": "https://github.com/near/sandbox",
  "author": "Near Inc (team@near.org)",
  "license": "MIT",
  "private": false,
  "dependencies": {
    "got": "^11.8.6",
    "tar": "^6.2.0"
  },
  "devDependencies": {
    "@changesets/changelog-github": "0.4.6",
    "@changesets/cli": "2.24.4",
    "@commitlint/cli": "17.0.3",
    "@commitlint/config-conventional": "17.0.3",
    "@sindresorhus/tsconfig": "^2.0.0",
    "@types/node": "^16.4.10",
    "@types/tar": "^4.0.5",
    "ava": "3.15.0",
    "ts-node": "^10.1.0",
    "typescript": "^4.3.5"
  },
  "scripts": {
    "postinstall": "node ./install.js",
    "preinstall": "node ./uninstall.js",
    "test": "ava",
    "build": "tsc",
    "release": "changeset publish"
  },
  "files": [
    "*.js",
    "dist/*.ts",
    "dist/*.js"
  ]
}

'''
'''--- npm/run.js ---
#!/usr/bin/env node
module.exports = require("./dist/run");
'''
'''--- npm/src/getBinary.ts ---
import { Binary } from ".";
import { join } from "path";
import * as os from "os";

function getPlatform() {
  const type = os.type();
  const arch = os.arch();

  if ((type === "Linux" || type === "Darwin") && arch === "x64") {
    return [type, "x86_64"];
  } else if (type === "Darwin" && arch === "arm64") {
    return [type, "arm64"];
  }

  throw new Error(`Unsupported platform: ${type} ${arch}`);
}

export function AWSUrl(): string {
  const [platform, arch] = getPlatform();
  return `https://s3-us-west-1.amazonaws.com/build.nearprotocol.com/nearcore/${platform}-${arch}/1.38.0/aac5e42fe8975e27faca53e31f53f9c67a5b4e35/near-sandbox.tar.gz`;
}

export function getBinary(name: string = "near-sandbox"): Promise<Binary> {
  if (!process.env["NEAR_SANDBOX_BIN_PATH"]) {
    process.env["NEAR_SANDBOX_BINARY_PATH"] = join(
      os.homedir(),
      ".near",
      "sandbox"
    );
  }

  // Will use version after publishing to AWS
  // const version = require("./package.json").version;
  const fromEnv = process.env["SANDBOX_ARTIFACT_URL"];
  const urls = [AWSUrl()];
  if (fromEnv) {
    urls.unshift(fromEnv);
  }

  return Binary.create(name, urls);
}

'''
'''--- npm/src/index.ts ---
import * as fs from "fs/promises";
import { URL } from "url";
import { join } from "path";
import * as tar from "tar";
import got from "got";
import { fileExists, inherit, rm, searchPath } from "./utils";
import { spawn } from "child_process";
import * as stream from "stream";
import { promisify } from "util";

const pipeline = promisify(stream.pipeline);

export class Binary {
  urls!: URL[];
  static readonly DEFAULT_INSTALL_DIR = join(__dirname, "..", "bin");

  protected constructor(
    public name: string,
    url: string | URL | string[] | URL[],
    public installDir: string = Binary.DEFAULT_INSTALL_DIR
  ) {
    let errors = [];
    let urls = [];
    if (typeof url === "string" || url instanceof URL) {
      urls.push(url);
    } else {
      if (url.length == 0) {
        throw new Error("No URL provided got empty array");
      }
      urls = url;
    }
    if (!name || typeof name !== "string") {
      errors.push("You must specify the name of your binary as a string");
    }
    try {
      this.urls = urls.map((path) => typeof path === "string" ? new URL(path): path);
    } catch (e) {
      errors.push(e);
    }

    if (errors.length > 0) {
      errors.push(
        '\nCorrect usage: new Binary("my-binary", "https://example.com/binary/download.tar.gz"'
      );
      errors.unshift(
        "One or more of the parameters you passed to the Binary constructor are invalid:\n"
      );
      throw new Error(errors.join("\n"));
    }
  }

  /**
   *
   * @param name binary name, e.g. 'git'
   * @param path URL of where to find binary
   * @param destination Directory to put the binary
   * @returns
   */
  static async create(
    name: string,
    path: string | URL | string[] | URL[],
    destination?: string
  ): Promise<Binary> {
    const bin = new Binary(name, path, destination ?? (await searchPath(name)));
    if (destination === bin.installDir) {
      await fs.mkdir(bin.installDir, { recursive: true });
    }
    return bin;
  }

  get binPath(): string {
    return join(this.installDir, this.name);
  }

  download(url: URL): Promise<void> {
    return pipeline(
      got.stream(url),
      new stream.PassThrough(),
      tar.x({ strip: 1, C: this.installDir })
    );
  }

  async install(): Promise<boolean> {
    for (let url of this.urls) {
      try {
        await this.download(url);
        return true;
      } catch (error: unknown) {}
    }
    throw new Error(`Failed to download from: \n${this.urls.join("\n")}`);
  }

  async exists(): Promise<boolean> {
    return await fileExists(this.binPath);
  }

  async run(
    cliArgs?: string[],
    options = { stdio: [null, inherit, inherit] }
  ): Promise<number> {
    if (!(await this.exists())) {
      try {
        await this.install();
      } catch (err) {
        console.error(err);
        return 1;
      }
    }

    const args = cliArgs ?? process.argv.slice(2);
    const result = spawn(this.binPath, args, options);
    result.on("error", (error) => {
      console.log(error);
    });

    return new Promise((resolve, reject) => {
      result.on("close", (code) => {
        if (!code) {
          resolve(code ?? 0);
        }
        reject(code);
      });
    });
  }

  async runAndExit(
    cliArgs?: string[],
    options = { stdio: [null, inherit, inherit] }
  ): Promise<void> {
    process.exit(await this.run(cliArgs, options));
  }

  async uninstall(): Promise<void> {
    if (
      this.installDir === Binary.DEFAULT_INSTALL_DIR &&
      (await this.exists())
    ) {
      await rm(this.binPath);
      if (await this.exists()) {
        throw new Error(`Failed to remove binary located ${this.binPath}`);
      }
    }
  }
}

'''
'''--- npm/src/install.ts ---
import { getBinary } from "./getBinary";

getBinary().then(async (bin) => {
  if (!(await bin.exists())) {
    await bin.install();
  }
});

'''
'''--- npm/src/run.ts ---
import { getBinary } from "./getBinary";

async function run() {
  try {
    const bin = await getBinary();
    if (process.argv.length < 3) {
      process.argv.push("--help");
    }
    bin.runAndExit();
  } catch (err) {
    console.error(err);
    process.exit(1);
  }
}

run();

'''
'''--- npm/src/uninstall.ts ---
import { getBinary } from "./getBinary";

getBinary().then(async (bin) => await bin.uninstall());

'''
'''--- npm/src/utils.ts ---
import { stat, rm as RM } from "fs/promises";
import { join } from "path";

export async function fileExists(s: string): Promise<boolean> {
  try {
    const f = await stat(s);
    return f.isFile();
  } catch {
    return false;
  }
}

export async function searchPath(
  filename: string
): Promise<string | undefined> {
  const binPath = process.env["NEAR_SANDBOX_BINARY_PATH"];
  if (
    binPath &&
    binPath.length > 0 &&
    (await fileExists(join(binPath, filename)))
  ){
    return binPath;
  }

  return undefined;
}

export const inherit: "inherit" = "inherit";

export async function rm(path: string): Promise<void> {
  try {
    await RM(path);
  } catch (e) {}
}

'''
'''--- npm/tsconfig.json ---
{
  "extends": "@sindresorhus/tsconfig/tsconfig.json",
  "include": ["src/*.ts"],
  "compilerOptions": {
    "outDir": "./dist",
    "module": "commonjs",
		"target": "ES2019", // Node.js 12
  }
}
'''
'''--- npm/uninstall.js ---
try {
  module.exports = require("./dist/uninstall");
} catch {}

'''