*GitHub Repository "Peersyst/theoutsidersart-nft"*

'''--- .eslintrc.js ---
module.exports = {
  env: {
    browser: true,
    commonjs: true,
    es6: true,
  },
  globals: {
    Atomics: "readonly",
    SharedArrayBuffer: "readonly",
  },
  parserOptions: {
    ecmaVersion: 2018,
  },
};

'''
'''--- README.md ---
## OpenSea Creatures - Starter ERC721, ERC1155, and factory contracts

What's included:

### Sample ERC721/ERC1155 Contracts

This includes a very simple sample ERC721 / ERC1155 for the purposes of demonstrating integration with the [OpenSea](https://opensea.io) marketplace. We include a script for minting the items.

Additionally, this contract whitelists the proxy accounts of OpenSea users so that they are automatically able to trade the ERC721 item on OpenSea (without having to pay gas for an additional approval). On OpenSea, each user has a "proxy" account that they control, and is ultimately called by the exchange contracts to trade their items. (Note that this addition does not mean that OpenSea itself has access to the items, simply that the users can list them more easily if they wish to do so)

### Factory Contracts

In addition to these template 721/1155 contracts, we provide sample factory contracts for running gas-free presales of items that haven't been minted yet. See https://docs.opensea.io/docs/opensea-initial-item-sale-tutorial for more info.

## Requirements

### Node version

Either make sure you're running a version of node compliant with the `engines` requirement in `package.json`, or install Node Version Manager [`nvm`](https://github.com/creationix/nvm) and run `nvm use` to use the correct version of node.

## Installation

Run

```bash
yarn
```

If you run into an error while building the dependencies and you're on a Mac, run the code below, remove your `node_modules` folder, and do a fresh `yarn install`:

```bash
xcode-select --install # Install Command Line Tools if you haven't already.
sudo xcode-select --switch /Library/Developer/CommandLineTools # Enable command line tools
sudo npm explore npm -g -- npm install node-gyp@latest # Update node-gyp
```

## Deploying

### Deploying to the Rinkeby network.

1. To access a Rinkeby testnet node, you'll need to sign up for [Alchemy](https://dashboard.alchemyapi.io/signup?referral=affiliate:e535c3c3-9bc4-428f-8e27-4b70aa2e8ca5) and get a free API key. Click "View Key" and then copy the part of the URL after `v2/`.
   a. You can use [Infura](https://infura.io) if you want as well. Just change `ALCHEMY_KEY` below to `INFURA_KEY`.
2. Using your API key and the mnemonic for your Metamask wallet (make sure you're using a Metamask seed phrase that you're comfortable using for testing purposes), run:

```
export ALCHEMY_KEY="<your_alchemy_project_id>"
export MNEMONIC="<metmask_mnemonic>"
DEPLOY_CREATURES_SALE=1 yarn truffle deploy --network rinkeby
```

### Minting tokens.

After deploying to the Rinkeby network, there will be a contract on Rinkeby that will be viewable on [Rinkeby Etherscan](https://rinkeby.etherscan.io). For example, here is a [recently deployed contract](https://rinkeby.etherscan.io/address/0xeba05c5521a3b81e23d15ae9b2d07524bc453561). You should set this contract address and the address of your Metamask account as environment variables when running the minting script. If a [CreatureFactory was deployed](https://github.com/ProjectOpenSea/opensea-creatures/blob/master/migrations/2_deploy_contracts.js#L38), which the sample deploy steps above do, you'll need to specify its address below as it will be the owner on the NFT contract, and only it will have mint permissions. In that case, you won't need NFT_CONTRACT_ADDRESS, as all we need is the contract with mint permissions here.

```
export OWNER_ADDRESS="<my_address>"
export NFT_CONTRACT_ADDRESS="<deployed_contract_address>"
export FACTORY_CONTRACT_ADDRESS="<deployed_factory_contract_address>"
export NETWORK="rinkeby"
node scripts/mint.js
```

### Diagnosing Common Issues

If you're running a modified version of `sell.js` and not getting expected behavior, check the following:

- Is the `expirationTime` in future? If no, change it to a time in the future.

- Is the `expirationTime` a fractional second? If yes, round the listing time to the nearest second.

- Are the input addresses all strings? If no, convert them to strings.

- Are the input addresses checksummed? You might need to use the checksummed version of the address.

- Is your computer's internal clock accurate? If no, try enabling automatic clock adjustment locally or following [this tutorial](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/set-time.html) to update an Amazon EC2 instance.

- Do you have any conflicts that result from globally installed node packages? If yes, try `yarn remove -g truffle; yarn`

- Are you running a version of node compliant with the `engines` requirement in `package.json`? If no, try `nvm use; rm -rf node_modules; yarn`

# About OpenSea Creature Accessories

This is a sample ERC-1155 contract for the purposes of demonstrating integration with the [OpenSea](https://opensea.io) marketplace for crypto collectibles. We also include:

- A factory contract for making sell orders for unminted items (allowing for **gas-free and mint-free presales**).
- A configurable lootbox contract for selling randomized collections of ERC-1155 items.

On top of the features from the OpenSea ERC721 sample contracts above, ERC1155

- supports multiple creators per contract, where only the creator is able to mint more copies
- supports pre-minted items for the lootbox to choose from

## Configuring the Lootbox

Open CreatureAccessoryLootbox.sol

1. Change `Class` to reflect your rarity levels.
2. Change `NUM_CLASSES` to reflect how many classes you have (this gets used for sizing fixed-length arrays in Solidity)
3. In `constructor`, set the `OptionSettings` for each of your classes. To do this, as in the example, call `setOptionSettings` with
   1. Your option id,
   2. The number of items to issue when the box is opened,
   3. An array of probabilities (basis points, so integers out of 10,000) of receiving each class. Should add up to 10k and be descending in value.
4. Then follow the instructions below to deploy it! Purchases will auto-open the box. If you'd like to make lootboxes tradable by users (without a purchase auto-opening it), contact us at contact@opensea.io (or better yet, in [Discord](https://discord.gg/ga8EJbv)).

## Why are some standard methods overridden?

This contract overrides the `isApprovedForAll` method in order to whitelist the proxy accounts of OpenSea users. This means that they are automatically able to trade your ERC-1155 items on OpenSea (without having to pay gas for an additional approval). On OpenSea, each user has a "proxy" account that they control, and is ultimately called by the exchange contracts to trade their items.

Note that this addition does not mean that OpenSea itself has access to the items, simply that the users can list them more easily if they wish to do so!

# Requirements

### Node version

Either make sure you're running a version of node compliant with the `engines` requirement in `package.json`, or install Node Version Manager [`nvm`](https://github.com/creationix/nvm) and run `nvm use` to use the correct version of node.

## Installation

Run

```bash
yarn
```

## Deploying

### Deploying to the Rinkeby network.

1. Follow the steps above to get a Rinkeby node API key
2. Using your API key and the mnemonic for your MetaMask wallet (make sure you're using a MetaMask seed phrase that you're comfortable using for testing purposes), run:

```
export ALCHEMY_KEY="<alchemy_project_id>" # or you can use INFURA_KEY
export MNEMONIC="<metmask_mnemonic>"
DEPLOY_ACCESSORIES_SALE=1 yarn truffle migrate --network rinkeby
```

### Deploying to the mainnet Ethereum network.

Make sure your wallet has at least a few dollars worth of ETH in it. Then run:

```
yarn truffle migrate --network live
```

Look for your newly deployed contract address in the logs! ðŸ¥³

### Viewing your items on OpenSea

OpenSea will automatically pick up transfers on your contract. You can visit an asset by going to `https://opensea.io/assets/CONTRACT_ADDRESS/TOKEN_ID`.

To load all your metadata on your items at once, visit [https://opensea.io/get-listed](https://opensea.io/get-listed) and enter your address to load the metadata into OpenSea! You can even do this for the Rinkeby test network if you deployed there, by going to [https://rinkeby.opensea.io/get-listed](https://rinkeby.opensea.io/get-listed).

### Troubleshooting

#### It doesn't compile!

Install truffle locally: `yarn add truffle`. Then run `yarn truffle migrate ...`.

You can also debug just the compile step by running `yarn truffle compile`.

#### It doesn't deploy anything!

This is often due to the truffle-hdwallet provider not being able to connect. Go to your [Alchemy Dashboard](https://dashboard.alchemyapi.io/signup?referral=affiliate:e535c3c3-9bc4-428f-8e27-4b70aa2e8ca5) (or infura.io) and create a new project. Use your "project ID" as your new `ALCHEMY_KEY` and make sure you export that command-line variable above.

### ERC1155 Implementation

To implement the ERC1155 standard, these contracts use the Multi Token Standard by [Horizon Games](https://horizongames.net/), available on [npm](https://www.npmjs.com/package/multi-token-standard) and [github](https://github.com/arcadeum/multi-token-standard) and also under the MIT License.

# Running Local Tests

In one terminal window, run:

    yarn run ganache-cli

Once Ganache has started, run the following in another terminal window:

    yarn run test

'''
'''--- flatten.sh ---
./node_modules/.bin/truffle-flattener contracts/Creature.sol > flattened/Creature.sol
./node_modules/.bin/truffle-flattener contracts/CreatureFactory.sol > flattened/CreatureFactory.sol
./node_modules/.bin/truffle-flattener contracts/CreatureLootBox.sol > flattened/CreatureLootBox.sol
./node_modules/.bin/truffle-flattener contracts/CreatureAccessory.sol > flattened/CreatureAccessory.sol
./node_modules/.bin/truffle-flattener contracts/CreatureAccessoryFactory.sol > flattened/CreatureAccessoryFactory.sol
./node_modules/.bin/truffle-flattener contracts/CreatureAccessoryLootBox.sol > flattened/CreatureAccessoryLootBox.sol

'''
'''--- lib/setupCreatureAccessories.js ---
const values = require('./valuesCommon.js');

// A function in case we need to change this relationship
const tokenIndexToId = a => a;

// Configure the nfts

const setupAccessory = async (
  accessories,
  owner
) => {
  for (let i = 0; i < values.NUM_ACCESSORIES; i++) {
    const id = tokenIndexToId(i);
    await accessories.create(owner, id, values.MINT_INITIAL_SUPPLY, "", "0x0");
  }
};

// Configure the lootbox

const setupAccessoryLootBox = async (lootBox, factory) => {
  await lootBox.setState(
    factory.address,
    values.NUM_LOOTBOX_OPTIONS,
    values.NUM_CLASSES,
    1337
  );
  // We have one token id per rarity class.
  for (let i = 0; i < values.NUM_CLASSES; i++) {
    const id = tokenIndexToId(i);
    await lootBox.setTokenIdsForClass(i, [id]);
  }
  await lootBox.setOptionSettings(
    values.LOOTBOX_OPTION_BASIC,
    3,
    [7300, 2100, 400, 100, 50, 50],
    [0, 0, 0, 0, 0, 0]
  );
  await lootBox.setOptionSettings(
    values.LOOTBOX_OPTION_PREMIUM,
    5,
    [7300, 2100, 400, 100, 50, 50],
    [3, 0, 0, 0, 0, 0]
  );
  await lootBox.setOptionSettings(
    values.LOOTBOX_OPTION_GOLD,
    7,
    [7300, 2100, 400, 100, 50, 50],
    [3, 0, 2, 0, 1, 0]
  );
};

// Deploy and configure everything

const setupCreatureAccessories = async(accessories, factory, lootBox, owner) => {
  await setupAccessory(accessories, owner);
  await accessories.setApprovalForAll(factory.address, true, { from: owner });
  await accessories.transferOwnership(factory.address);
  await setupAccessoryLootBox(lootBox, factory);
  await lootBox.transferOwnership(factory.address);
};

module.exports = {
  setupAccessory,
  setupAccessoryLootBox,
  setupCreatureAccessories
};

'''
'''--- lib/testValuesCommon.js ---
/* Useful aliases */

const toBN = web3.utils.toBN;

const URI_BASE = 'https://creatures-api.opensea.io/api/{id}';
const ADDRESS_ZERO = '0x0000000000000000000000000000000000000000';
const MAX_UINT256 = '0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF';
const MAX_UINT256_BN = toBN(MAX_UINT256);

module.exports = {
  URI_BASE,
  ADDRESS_ZERO,
  MAX_UINT256,
  MAX_UINT256_BN
};

'''
'''--- lib/valuesCommon.js ---
/* Useful aliases */

// No, we don't have easy access to web3 here.
// And bn.js new BN() weirdly doesn't work with truffle-assertions
const toBN = a => a;
const toBNHex = a => a;

// Configfuration for our tokens

const NUM_ACCESSORIES = 6;
const MINT_INITIAL_SUPPLY = 1000;
const INITIAL_SUPPLY = toBNHex('0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF');

const CLASS_COMMON = 0;
const CLASS_RARE = 1;
const CLASS_EPIC = 2;
const CLASS_LEGENDARY = 3;
const CLASS_DIVINE = 4;
const CLASS_HIDDEN = 5;
const NUM_CLASSES = 6;

const LOOTBOX_OPTION_BASIC = toBN(0);
const LOOTBOX_OPTION_PREMIUM = toBN(1);
const LOOTBOX_OPTION_GOLD = toBN(2);
const LOOTBOX_OPTIONS = [LOOTBOX_OPTION_BASIC, LOOTBOX_OPTION_PREMIUM, LOOTBOX_OPTION_GOLD];
const NUM_LOOTBOX_OPTIONS = LOOTBOX_OPTIONS.length;

const NO_SUCH_LOOTBOX_OPTION = toBN(NUM_LOOTBOX_OPTIONS + 10);
const LOOTBOX_OPTION_AMOUNTS = [toBN(3), toBN(5), toBN(7)];
// Note that these are token IDs, not option IDs, so they are one higher
const LOOTBOX_OPTION_GUARANTEES = [
  {},
  { 0: toBN(3) },
  { 0: toBN(3), 2: toBN(2), 4: toBN(1) }
];

module.exports = {
  NUM_ACCESSORIES,
  MINT_INITIAL_SUPPLY,
  INITIAL_SUPPLY,
  CLASS_COMMON,
  CLASS_RARE,
  CLASS_EPIC,
  CLASS_LEGENDARY,
  CLASS_DIVINE,
  CLASS_HIDDEN,
  NUM_CLASSES,
  LOOTBOX_OPTION_BASIC,
  LOOTBOX_OPTION_PREMIUM,
  LOOTBOX_OPTION_GOLD,
  LOOTBOX_OPTIONS,
  NUM_LOOTBOX_OPTIONS,
  NO_SUCH_LOOTBOX_OPTION,
  LOOTBOX_OPTION_AMOUNTS,
  LOOTBOX_OPTION_GUARANTEES
};

'''
'''--- metadata-api/app.py ---
from flask import Flask, abort
from flask import jsonify
from google.cloud import storage
from google.oauth2 import service_account
from PIL import Image
import os
import mimetypes

GOOGLE_STORAGE_PROJECT = os.environ['GOOGLE_STORAGE_PROJECT']
GOOGLE_STORAGE_BUCKET = os.environ['GOOGLE_STORAGE_BUCKET']

app = Flask(__name__)

########################################################################
# Data
########################################################################

# opensea-creatures

FIRST_NAMES = ['Herbie', 'Sprinkles', 'Boris', 'Dave', 'Randy', 'Captain']
LAST_NAMES = ['Starbelly', 'Fisherton', 'McCoy']

BASES = ['jellyfish', 'starfish', 'crab', 'narwhal', 'tealfish', 'goldfish']
EYES = ['big', 'joy', 'wink', 'sleepy', 'content']
MOUTH = ['happy', 'surprised', 'pleased', 'cute']

INT_ATTRIBUTES = [5, 2, 3, 4, 8]
FLOAT_ATTRIBUTES = [1.4, 2.3, 11.7, 90.2, 1.2]
STR_ATTRIBUTES = [
    'Happy',
    'Sad',
    'Sleepy',
    'Boring'
]
BOOST_ATTRIBUTES = [10, 40, 30]
PERCENT_BOOST_ATTRIBUTES = [5, 10, 15]
NUMBER_ATTRIBUTES = [1, 2, 1, 1]

# opensea-creatures-accessories

ACCESSORIES_IMAGES = [
    'Bamboo-flute.png',
    'Life-ring.png',
    'Message-in-a-bottle.png',
    'Pearl.png',
    'Scuba-mask.png',
    'Trident.png'
]
ACCESSORIES_NAMES = [a.replace('-', ' ').replace('.png', '')
                     for a in ACCESSORIES_IMAGES]
ACCESSORIES_ATTS_INT = [200, 11, 3, 41, 9, 172]
ACCESSORIES_ATTS_PERCENT = [5, 10, 1, 20, 15, 25]
ACCESSORIES_ATTS_LOCATION = ['Head', 'Body', 'Held', 'Held', 'Head', 'Held']
ACCESSORIES_ATTS_RARITY = [
    'Common',
    'Rare',
    'Legendary',
    'Epic',
    'Divine',
    'Hidden'
]
ACCESSORIES_ATTS_DEPTH = [
    'beach',
    'shore',
    'shallows',
    'deeps',
    'shore',
    'deeps'
]
ACCESSORIES_ATTS_GENERATION = [1, 1, 2, 1, 1, 3]

# contractURI() support

CONTRACT_URI_METADATA = {
    'opensea-creatures': {
        'name': 'OpenSea Creatures',
        'description': 'Friendly creatures of the sea.',
        'image': 'https://example.com/image.png',
        'external_link': 'https://github.com/ProjectOpenSea/opensea-creatures/'
    },
    'opensea-erc1155': {
        'name': 'OpenSea Creature Accessories',
        'description': "Fun and useful accessories for your OpenSea creatures.",
        'image': 'https://example.com/image.png',
        'external_link': 'https://github.com/ProjectOpenSea/opensea-erc1155/'
    }
}
CONTRACT_URI_METADATA_AVAILABLE = CONTRACT_URI_METADATA.keys()

########################################################################
# Routes
########################################################################

# opensea-creatures

@app.route('/api/creature/<token_id>')
def creature(token_id):
    token_id = int(token_id)
    num_first_names = len(FIRST_NAMES)
    num_last_names = len(LAST_NAMES)
    creature_name = '%s %s' % (FIRST_NAMES[token_id % num_first_names], LAST_NAMES[token_id % num_last_names])

    base = BASES[token_id % len(BASES)]
    eyes = EYES[token_id % len(EYES)]
    mouth = MOUTH[token_id % len(MOUTH)]
    image_url = _compose_image(['images/bases/base-%s.png' % base,
                                'images/eyes/eyes-%s.png' % eyes,
                                'images/mouths/mouth-%s.png' % mouth],
                               token_id)

    attributes = []
    _add_attribute(attributes, 'Base', BASES, token_id)
    _add_attribute(attributes, 'Eyes', EYES, token_id)
    _add_attribute(attributes, 'Mouth', MOUTH, token_id)
    _add_attribute(attributes, 'Level', INT_ATTRIBUTES, token_id)
    _add_attribute(attributes, 'Stamina', FLOAT_ATTRIBUTES, token_id)
    _add_attribute(attributes, 'Personality', STR_ATTRIBUTES, token_id)
    _add_attribute(attributes, 'Aqua Power', BOOST_ATTRIBUTES, token_id, display_type='boost_number')
    _add_attribute(attributes, 'Stamina Increase', PERCENT_BOOST_ATTRIBUTES, token_id, display_type='boost_percentage')
    _add_attribute(attributes, 'Generation', NUMBER_ATTRIBUTES, token_id, display_type='number')

    return jsonify({
        'name': creature_name,
        'description': 'Friendly OpenSea Creature that enjoys long swims in the ocean.',
        'image': image_url,
        'external_url': 'https://openseacreatures.io/%s' % token_id,
        'attributes': attributes
    })

@app.route('/api/box/creature/<token_id>')
def creature_box(token_id):
    token_id = int(token_id)
    image_url = _compose_image(['images/box/lootbox.png'], token_id, 'box')

    attributes = []
    _add_attribute(attributes, 'number_inside', [3], token_id)

    return jsonify({
        'name': 'Creature Loot Box',
        'description': 'This lootbox contains some OpenSea Creatures! It can also be traded!',
        'image': image_url,
        'external_url': 'https://openseacreatures.io/%s' % token_id,
        'attributes': attributes
    })

@app.route('/api/factory/creature/<token_id>')
def creature_factory(token_id):
    token_id = int(token_id)
    if token_id == 0:
        name = 'One OpenSea creature'
        description = 'When you purchase this option, you will receive a single OpenSea creature of a random variety. ' \
                      'Enjoy and take good care of your aquatic being!'
        image_url = _compose_image(['images/factory/egg.png'], token_id, 'factory')
        num_inside = 1
    elif token_id == 1:
        name = 'Four OpenSea creatures'
        description = 'When you purchase this option, you will receive four OpenSea creatures of random variety. ' \
                      'Enjoy and take good care of your aquatic beings!'
        image_url = _compose_image(['images/factory/four-eggs.png'], token_id, 'factory')
        num_inside = 4
    elif token_id == 2:
        name = 'One OpenSea creature lootbox'
        description = 'When you purchase this option, you will receive one lootbox, which can be opened to reveal three ' \
                      'OpenSea creatures of random variety. Enjoy and take good care of these cute aquatic beings!'
        image_url = _compose_image(['images/box/lootbox.png'], token_id, 'factory')
        num_inside = 3

    attributes = []
    _add_attribute(attributes, 'number_inside', [num_inside], token_id)

    return jsonify({
        'name': name,
        'description': description,
        'image': image_url,
        'external_url': 'https://openseacreatures.io/%s' % token_id,
        'attributes': attributes
    })

# opensea-creatures-accessories

@app.route('/api/accessory/<token_id>')
def accessory(token_id):
    token_id = int(token_id)
    num_accessories = len(ACCESSORIES_NAMES)
    if token_id >= num_accessories:
        abort(404, description='No such token')
    accessory_name = ACCESSORIES_NAMES[token_id]
    image_path = 'images/accessory/%s' % ACCESSORIES_IMAGES[token_id]
    image_url = _bucket_image(image_path, token_id, 'accessory')
    attributes = []
    _add_attribute(attributes, 'Aqua Boost', ACCESSORIES_ATTS_INT, token_id, display_type='boost_number')
    _add_attribute(attributes, 'Stamina Increase', ACCESSORIES_ATTS_PERCENT, token_id, display_type='boost_percentage')
    _add_attribute(attributes, 'Location', ACCESSORIES_ATTS_LOCATION, token_id)
    _add_attribute(attributes, 'Depth', ACCESSORIES_ATTS_DEPTH, token_id)
    _add_attribute(attributes, 'Rarity', ACCESSORIES_ATTS_RARITY, token_id)
    _add_attribute(attributes, 'Generation', ACCESSORIES_ATTS_GENERATION, token_id, display_type='number')

    return jsonify({
        'name': accessory_name,
        'description': 'A fun and useful accessory for your friendly OpenSea creatures.',
        'image': image_url,
        'external_url': 'https://openseacreatures.io/accessory/%s' % token_id,
        'attributes': attributes
    })

@app.route('/api/box/accessory/<token_id>')
def accessory_box(token_id):
    token_id = int(token_id)
    image_url = _compose_image(['images/box/lootbox.png'], token_id, 'box')

    attributes = []
    _add_attribute(attributes, 'number_inside', [3], token_id)

    return jsonify({
        'name': 'Accessory Loot Box',
        'description': 'This lootbox contains some OpenSea Creature accessories! It can also be traded!',
        'image': image_url,
        'external_url': 'https://openseacreatures.io/box/accessory/%s' % token_id,
        'attributes': attributes
    })

@app.route('/api/factory/accessory/<token_id>')
def accessory_factory(token_id):
    token_id = int(token_id)
    if token_id == 0:
        name = 'One OpenSea creature accessory'
        description = 'When you purchase this option, you will receive a single OpenSea creature accessory of a random variety. ' \
                      'Enjoy and take good care of your aquatic being!'
        image_url = _compose_image(['images/factory/egg.png'], token_id, 'factory')
        num_inside = 1
    elif token_id == 1:
        name = 'Four OpenSea creature accessories'
        description = 'When you purchase this option, you will receive four OpenSea creature accessories of random variety. ' \
                      'Enjoy and take good care of your aquatic beings!'
        image_url = _compose_image(['images/factory/four-eggs.png'], token_id, 'factory')
        num_inside = 4
    elif token_id == 2:
        name = 'One OpenSea creature accessory lootbox'
        description = 'When you purchase this option, you will receive one lootbox, which can be opened to reveal three ' \
                      'OpenSea creature accessories of random variety. Enjoy and take good care of these cute aquatic beings!'
        image_url = _compose_image(['images/box/lootbox.png'], token_id, 'factory')
        num_inside = 3

    attributes = []
    _add_attribute(attributes, 'number_inside', [num_inside], token_id)

    return jsonify({
        'name': name,
        'description': description,
        'image': image_url,
        'external_url': 'https://openseacreatures.io/%s' % token_id,
        'attributes': attributes
    })

# contractURI()

@app.route('/contract/<contract_name>')
def contract_uri(contract_name):
    if not contract_name in CONTRACT_URI_METADATA_AVAILABLE:
        abort(404, description='Resource not found')
    return jsonify(CONTRACT_URI_METADATA[contract_name])

# Error handling

@app.errorhandler(404)
def resource_not_found(e):
    return jsonify(error=str(e)), 404

########################################################################
# Utility code
########################################################################

def _add_attribute(existing, attribute_name, options, token_id, display_type=None):
    trait = {
        'trait_type': attribute_name,
        'value': options[token_id % len(options)]
    }
    if display_type:
        trait['display_type'] = display_type
    existing.append(trait)

def _compose_image(image_files, token_id, path='creature'):
    composite = None
    for image_file in image_files:
        foreground = Image.open(image_file).convert('RGBA')

        if composite:
            composite = Image.alpha_composite(composite, foreground)
        else:
            composite = foreground

    output_path = 'images/output/%s.png' % token_id
    composite.save(output_path)

    blob = _get_bucket().blob(f'{path}/{token_id}.png')
    blob.upload_from_filename(filename=output_path)
    return blob.public_url

def _bucket_image(image_path, token_id, path='accessory'):
    blob = _get_bucket().blob(f'{path}/{token_id}.png')
    blob.upload_from_filename(filename=image_path)
    return blob.public_url

def _get_bucket():
    credentials = service_account.Credentials.from_service_account_file('credentials/google-storage-credentials.json')
    if credentials.requires_scopes:
        credentials = credentials.with_scopes(['https://www.googleapis.com/auth/devstorage.read_write'])
    client = storage.Client(project=GOOGLE_STORAGE_PROJECT, credentials=credentials)
    return client.get_bucket(GOOGLE_STORAGE_BUCKET)

########################################################################
# Main flow of execution
########################################################################

if __name__ == '__main__':
    app.run(debug=True, use_reloader=True)

'''
'''--- metadata-api/images/output/temp.txt ---

'''
'''--- metadata-api/requirements.txt ---
aiohttp==2.2.5
alabaster==0.7.10
asn1crypto==0.23.0
async-timeout==1.3.0
Babel==2.5.0
bitcoin==1.1.42
cachetools==2.0.1
certifi==2017.7.27.1
cffi==1.10.0
chardet==3.0.4
click==6.7
coincurve==6.0.0
cytoolz==0.8.2
decorator==4.1.2
docutils==0.14
eth-testrpc==1.3.0
ethereum==1.6.1
ethereum-abi-utils==0.4.0
ethereum-utils==0.4.0
Flask==0.12.2
google-api-core==1.1.1
google-auth==1.4.1
google-cloud-core==0.28.1
google-cloud-storage==1.8.0
google-resumable-media==0.3.1
googleapis-common-protos==1.5.3
gunicorn==19.7.1
httpretty==0.8.14
idna==2.6
imagesize==0.7.1
itsdangerous==0.24
Jinja2==2.9.6
json-rpc==1.10.3
MarkupSafe==1.0
multidict==3.1.3
networkx==1.11
pbkdf2==1.3
pbr==3.1.1
Pillow==5.1.0
ply==3.10
protobuf==3.5.2.post1
pyasn1==0.4.2
pyasn1-modules==0.2.1
pycparser==2.18
pycryptodome==3.4.7
pyethash==0.1.27
Pygments==2.2.0
pylru==1.0.9
pysha3==1.0.2
pytz==2017.2
PyYAML==3.12
pyzmq==16.0.2
repoze.lru==0.6
requests==2.18.4
rlp==0.5.1
rsa==3.4.2
scrypt==0.8.0
secp256k1==0.13.2
six==1.11.0
snowballstemmer==1.2.1
sortedcontainers==1.5.7
sphinxcontrib-websupport==1.0.1
stevedore==1.27.1
thriftpy==0.3.9
tinydb==3.3.1
toolz==0.8.2
urllib3==1.22
virtualenv==15.1.0
virtualenv-clone==0.2.6
virtualenvwrapper==4.8.2
web3==3.11.0
Werkzeug==0.12.2
yarl==0.12.0
zmq==0.0.0

'''
'''--- metadata-api/src/pip-delete-this-directory.txt ---
This file is placed here by pip to indicate the source was put
here by pip.

Once this package is successfully installed this source code will be
deleted (unless you remove this file).

'''
'''--- metadata/index.js ---
const fs = require("fs");
const parse = require('csv-parser');
const path = require('path');
const IPFS =  require("ipfs");
const axios =  require("axios");
const FormData = require('form-data');
const recursive = require('recursive-fs');

const pinFileToIPFS = async (name, path, pinataApiKey, pinataSecretApiKey) => {
    const url = `https://api.pinata.cloud/pinning/pinFileToIPFS`;
    let data = new FormData();
    data.append('file', fs.createReadStream(path));
    const metadata = JSON.stringify({
        name: name,
    });
    data.append('pinataMetadata', metadata);
    //pinataOptions are optional
    const pinataOptions = JSON.stringify({
        cidVersion: 0,
    });
    data.append('pinataOptions', pinataOptions);
    await axios
        .post(url, data, {
            maxBodyLength: 'Infinity', //this is needed to prevent axios from erroring out with large files
            headers: {
                'Content-Type': `multipart/form-data; boundary=${data._boundary}`,
                pinata_api_key: pinataApiKey,
                pinata_secret_api_key: pinataSecretApiKey
            }
        });
    console.log("Pined " + name);
};

const pinDirectoryToIPFS = async (name, path, pinataApiKey, pinataSecretApiKey) => {
    const url = `https://api.pinata.cloud/pinning/pinFileToIPFS`;
    //we gather the files from a local directory in this example, but a valid readStream is all that's needed for each file in the directory.
    recursive.readdirr(src, function (err, dirs, files) {
        let data = new FormData();
        files.forEach((file) => {
            //for each file stream, we need to include the correct relative file path
            data.append(`file`, fs.createReadStream(file), {
                filepath: basePathConverter(src, file)
            });
        });
        const metadata = JSON.stringify({
            name: 'testname',
            keyvalues: {
                exampleKey: 'exampleValue'
            }
        });
        data.append('pinataMetadata', metadata);
        return axios
            .post(url, data, {
                maxBodyLength: 'Infinity', //this is needed to prevent axios from erroring out with large directories
                headers: {
                    'Content-Type': `multipart/form-data; boundary=${data._boundary}`,
                    pinata_api_key: pinataApiKey,
                    pinata_secret_api_key: pinataSecretApiKey
                }
            })
            .then(function (response) {
                //handle response here
            })
            .catch(function (error) {
                //handle error here
            });
    });
    console.log("Pined directory " + name);
};

const cidFromImage = async (node, path) => {
    const file = fs.readFileSync(path);
    const ipfsFile = await node.add(file)
    return ipfsFile.cid;
    // return "ipfs";
};

(async () => {
    const node = await IPFS.create();
    const csvData=[];
    await new Promise((resolve) => {
        fs.createReadStream(path.join(__dirname, "./input/data.csv"))
            .pipe(parse({ delimiter: "," }))
            .on('data', function (csvrow) {
                //do something with csvrow
                csvData.push(csvrow);
            })
            .on('end', function () {
                resolve();
                //do something with csvData
            });
    });
    for (const nftData of csvData) {
        const filePath = path.join(__dirname, "./input/images/ " + nftData.image_number + ".jpg");
        await pinFileToIPFS(nftData.image_number, filePath, "349d6d9be6b76fffce7f", "448c37f763cd4eb9cbb9be3877e93f0f087d1074e560beba54018da67937571e");
        fs.writeFileSync(path.join(__dirname, "./output/" + nftData.image_number), JSON.stringify({
            name: nftData.nft_name,
            description: nftData.nft_description,
            external_url: "https://www.theoutsidersart.io/",
            image: `ipfs://${await cidFromImage(node, filePath)}`,
            attributes: [{
                trait_type: "Signed",
                value: nftData["attributes.signed"] === "TRUE",
            }, {
                trait_type: "Reversed",
                value: nftData["attributes.reversed"] === "TRUE",
            }, {
                trait_type: "Augmented Reality",
                value: nftData["attributes.augmented_reality"] === "TRUE",
            }]
        }))
    }
    console.log("Done");
})()

/*
API Key: 349d6d9be6b76fffce7f
API Secret: 448c37f763cd4eb9cbb9be3877e93f0f087d1074e560beba54018da67937571e
JWT: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySW5mb3JtYXRpb24iOnsiaWQiOiI4NmFhMGY1YS0wOGNjLTQxMzYtYmE5OC04NTE5NjYxNDEzZjAiLCJlbWFpbCI6ImFjYXJyZXJhQHBlZXJzeXN0LmNvbSIsImVtYWlsX3ZlcmlmaWVkIjp0cnVlLCJwaW5fcG9saWN5Ijp7InJlZ2lvbnMiOlt7ImlkIjoiRlJBMSIsImRlc2lyZWRSZXBsaWNhdGlvbkNvdW50IjoxfV0sInZlcnNpb24iOjF9LCJtZmFfZW5hYmxlZCI6ZmFsc2V9LCJhdXRoZW50aWNhdGlvblR5cGUiOiJzY29wZWRLZXkiLCJzY29wZWRLZXlLZXkiOiIzNDlkNmQ5YmU2Yjc2ZmZmY2U3ZiIsInNjb3BlZEtleVNlY3JldCI6IjQ0OGMzN2Y3NjNjZDRlYjljYmI5YmUzODc3ZTkzZjBmMDg3ZDEwNzRlNTYwYmViYTU0MDE4ZGE2NzkzNzU3MWUiLCJpYXQiOjE2MzgyMTM5MTl9.labUHwWzRD96xcFmTWIQVSrflev2mWHZZMZ8Nc3-9YE
 */
'''
'''--- migrations/1_initial_migrations.js ---
const Migrations = artifacts.require("./Migrations.sol")

module.exports = function(deployer) {
  deployer.deploy(Migrations)
}

'''
'''--- migrations/2_deploy_contracts.js ---
const TheOutsidersArt = artifacts.require("./TheOutsidersArt.sol");
const TheOutsidersArtFactory = artifacts.require("./TheOutsidersArtFactory.sol");
const TheOutsidersArtPreMint = artifacts.require("./TheOutsidersArtPreMint.sol");

// If you want to hardcode what deploys, comment out process.env.X and use
// true/false;

module.exports = async (deployer, network, addresses) => {
  // OpenSea proxy registry addresses for rinkeby and mainnet.
  let proxyRegistryAddress = "";
  if (network === 'rinkeby') {
    proxyRegistryAddress = "0xf57b2c51ded3a29e6891aba85459d600256cf317";
  } else {
    proxyRegistryAddress = "0xa5409ec958c83c3f309868babaca7c86dcb077c1";
  }
  await deployer.deploy(TheOutsidersArt, proxyRegistryAddress, {gas: 30000000});
  await deployer.deploy(TheOutsidersArtFactory, proxyRegistryAddress, TheOutsidersArt.address, {gas: 30000000});
  // await deployer.deploy(TheOutsidersArtPreMint, proxyRegistryAddress, {gas: 30000000});

  const theOutsidersArt = await TheOutsidersArt.deployed();
  await theOutsidersArt.transferOwnership(TheOutsidersArtFactory.address);
};

'''
'''--- package.json ---
{
  "name": "opensea-creatures",
  "version": "1.0.0",
  "description": "OpenSea's smart contracts, including ERC721 templates, factories, and the storefront builder.",
  "main": "index.js",
  "scripts": {
    "generate-metadata": "node ./metadata/index.js",
    "ganache-cli": "ganache-cli -d -p 7545 --gasLimit=10000000",
    "test": "DEPLOY_ALL=1 truffle test"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/ProjectOpenSea/opensea-creatures.git"
  },
  "author": "support@opensea.io",
  "license": "ISC",
  "bugs": {
    "url": "https://github.com/ProjectOpenSea/opensea-creatures/issues"
  },
  "homepage": "https://github.com/ProjectOpenSea/opensea-creatures#readme",
  "dependencies": {
    "@0x/subproviders": "^6.4.1",
    "axios": "^0.24.0",
    "eth-gas-reporter": "^0.2.17",
    "eth-sig-util": "^3.0.1",
    "ethereum-waffle": "^3.0.0",
    "ipfs": "^0.60.2",
    "ipfs-http-client": "^54.0.2",
    "opensea-js": "^1.1.5",
    "openzeppelin-solidity": "~4.1.0",
    "recursive-fs": "^2.1.0",
    "truffle": "^5.1.30",
    "truffle-assertions": "^0.9.2",
    "truffle-contract-size": "^2.0.1",
    "truffle-flattener": "^1.4.2",
    "truffle-hdwallet-provider": "1.0.17",
    "web3": "^1.0.0-beta.34"
  },
  "engines": {
    "yarn": "~1.22.4"
  },
  "devDependencies": {
    "csv-parser": "^3.0.0",
    "eslint": "^7.22.0",
    "truffle-plugin-verify": "^0.5.8"
  }
}

'''
'''--- scripts/creature-accessories/advanced/mint.js ---
const HDWalletProvider = require('truffle-hdwallet-provider')
const web3 = require('web3')
const MNEMONIC = process.env.MNEMONIC
const INFURA_KEY = process.env.INFURA_KEY
const LOOTBOX_CONTRACT_ADDRESS = process.env.LOOTBOX_CONTRACT_ADDRESS
const OWNER_ADDRESS = process.env.OWNER_ADDRESS
const NETWORK = process.env.NETWORK

if (!MNEMONIC || !INFURA_KEY || !OWNER_ADDRESS || !NETWORK) {
  console.error(
    'Please set a mnemonic, infura key, owner, network, and contract address.'
  )
  return
}

const LOOTBOX_ABI = [
  {
    constant: false,
    inputs: [
      {
        internalType: 'uint256',
        name: '_optionId',
        type: 'uint256',
      },
      {
        internalType: 'address',
        name: '_toAddress',
        type: 'address',
      },
      {
        internalType: 'uint256',
        name: '_amount',
        type: 'uint256',
      },
    ],
    name: 'unpack',
    outputs: [],
    payable: false,
    stateMutability: 'nonpayable',
    type: 'function',
  },
]

/**
 * For now, this script just opens a lootbox.
 */
async function main() {
  const network =
    NETWORK === 'mainnet' || NETWORK === 'live' ? 'mainnet' : 'rinkeby'
  const provider = new HDWalletProvider(
    MNEMONIC,
    `https://${network}.infura.io/v3/${INFURA_KEY}`
  )
  const web3Instance = new web3(provider)

  if (!LOOTBOX_CONTRACT_ADDRESS) {
    console.error('Please set a LootBox contract address.')
    return
  }

  const factoryContract = new web3Instance.eth.Contract(
    LOOTBOX_ABI,
    LOOTBOX_CONTRACT_ADDRESS
  )
  const result = await factoryContract.methods
    .unpack(0, OWNER_ADDRESS, 1)
    .send({ from: OWNER_ADDRESS, gas: 100000 })
  console.log('Created. Transaction: ' + result.transactionHash)
}

main()

'''
'''--- scripts/creature-accessories/initial_sale.js ---
const opensea = require('opensea-js')
const { WyvernSchemaName } = require('opensea-js/lib/types')
const OpenSeaPort = opensea.OpenSeaPort
const Network = opensea.Network
const MnemonicWalletSubprovider = require('@0x/subproviders')
  .MnemonicWalletSubprovider
const RPCSubprovider = require('web3-provider-engine/subproviders/rpc')
const Web3ProviderEngine = require('web3-provider-engine')

const MNEMONIC = process.env.MNEMONIC
const INFURA_KEY = process.env.INFURA_KEY
const FACTORY_CONTRACT_ADDRESS = process.env.FACTORY_CONTRACT_ADDRESS
const OWNER_ADDRESS = process.env.OWNER_ADDRESS
const NETWORK = process.env.NETWORK
const API_KEY = process.env.API_KEY || '' // API key is optional but useful if you're doing a high volume of requests.

// Lootboxes only. These are the *Factory* option IDs.
// These map to 0, 1, 2 as LootBox option IDs, or 1, 2, 3 as LootBox token IDs.
const FIXED_PRICE_OPTION_IDS = ['6', '7', '8']
const FIXED_PRICES_ETH = [0.1, 0.2, 0.3]
const NUM_FIXED_PRICE_AUCTIONS = [1000, 1000, 1000] // [2034, 2103, 2202];

if (!MNEMONIC || !INFURA_KEY || !NETWORK || !OWNER_ADDRESS) {
  console.error(
    'Please set a mnemonic, infura key, owner, network, API key, nft contract, and factory contract address.'
  )
  return
}

if (!FACTORY_CONTRACT_ADDRESS) {
  console.error('Please specify a factory contract address.')
  return
}

const BASE_DERIVATION_PATH = `44'/60'/0'/0`

const mnemonicWalletSubprovider = new MnemonicWalletSubprovider({
  mnemonic: MNEMONIC,
  baseDerivationPath: BASE_DERIVATION_PATH,
})
const network =
  NETWORK === 'mainnet' || NETWORK === 'live' ? 'mainnet' : 'rinkeby'
const infuraRpcSubprovider = new RPCSubprovider({
  rpcUrl: 'https://' + network + '.infura.io/v3/' + INFURA_KEY,
})

const providerEngine = new Web3ProviderEngine()
providerEngine.addProvider(mnemonicWalletSubprovider)
providerEngine.addProvider(infuraRpcSubprovider)
providerEngine.start()

const seaport = new OpenSeaPort(
  providerEngine,
  {
    networkName:
      NETWORK === 'mainnet' || NETWORK === 'live'
        ? Network.Main
        : Network.Rinkeby,
    apiKey: API_KEY,
  },
  (arg) => console.log(arg)
)

async function main() {
  // Example: many fixed price auctions for a factory option.
  for (let i = 0; i < FIXED_PRICE_OPTION_IDS.length; i++) {
    const optionId = FIXED_PRICE_OPTION_IDS[i]
    console.log(`Creating fixed price auctions for ${optionId}...`)
    const numOrders = await seaport.createFactorySellOrders({
      assets: [
        {
          tokenId: optionId,
          tokenAddress: FACTORY_CONTRACT_ADDRESS,
          // Comment the next line if this is an ERC-721 asset (defaults to ERC721):
          schemaName: WyvernSchemaName.ERC1155,
        },
      ],
      // Quantity of each asset to issue
      quantity: 1,
      accountAddress: OWNER_ADDRESS,
      startAmount: FIXED_PRICES_ETH[i],
      // Number of times to repeat creating the same order for each asset. If greater than 5, creates them in batches of 5. Requires an `apiKey` to be set during seaport initialization:
      numberOfOrders: NUM_FIXED_PRICE_AUCTIONS[i],
    })
    console.log(`Successfully made ${numOrders} fixed-price sell orders!\n`)
  }
}

main().catch((e) => console.error(e))

'''
'''--- scripts/creature-accessories/sell.js ---
const opensea = require('opensea-js')
const { WyvernSchemaName } = require('opensea-js/lib/types')
const OpenSeaPort = opensea.OpenSeaPort
const Network = opensea.Network
const MnemonicWalletSubprovider = require('@0x/subproviders')
  .MnemonicWalletSubprovider
const RPCSubprovider = require('web3-provider-engine/subproviders/rpc')
const Web3ProviderEngine = require('web3-provider-engine')

const MNEMONIC = process.env.MNEMONIC
const INFURA_KEY = process.env.INFURA_KEY
const NFT_CONTRACT_ADDRESS = process.env.NFT_CONTRACT_ADDRESS
const OWNER_ADDRESS = process.env.OWNER_ADDRESS
const NETWORK = process.env.NETWORK
const API_KEY = process.env.API_KEY || '' // API key is optional but useful if you're doing a high volume of requests.

if (!MNEMONIC || !INFURA_KEY || !NETWORK || !OWNER_ADDRESS) {
  console.error(
    'Please set a mnemonic, infura key, owner, network, API key, nft contract, and factory contract address.'
  )
  return
}

if (!NFT_CONTRACT_ADDRESS) {
  console.error('Please set an NFT contract address.')
  return
}

const BASE_DERIVATION_PATH = `44'/60'/0'/0`

const mnemonicWalletSubprovider = new MnemonicWalletSubprovider({
  mnemonic: MNEMONIC,
  baseDerivationPath: BASE_DERIVATION_PATH,
})
const network =
  NETWORK === 'mainnet' || NETWORK === 'live' ? 'mainnet' : 'rinkeby'
const infuraRpcSubprovider = new RPCSubprovider({
  rpcUrl: 'https://' + network + '.infura.io/v3/' + INFURA_KEY,
})

const providerEngine = new Web3ProviderEngine()
providerEngine.addProvider(mnemonicWalletSubprovider)
providerEngine.addProvider(infuraRpcSubprovider)
providerEngine.start()

const seaport = new OpenSeaPort(
  providerEngine,
  {
    networkName:
      NETWORK === 'mainnet' || NETWORK === 'live'
        ? Network.Main
        : Network.Rinkeby,
    apiKey: API_KEY,
  },
  (arg) => console.log(arg)
)

async function main() {
  // Example: simple fixed-price sale of an item owned by a user.
  console.log('Auctioning an item for a fixed price...')
  const fixedPriceSellOrder = await seaport.createSellOrder({
    asset: {
      tokenId: '1',
      tokenAddress: NFT_CONTRACT_ADDRESS,
      schemaName: WyvernSchemaName.ERC1155,
    },
    startAmount: 0.05,
    expirationTime: 0,
    accountAddress: OWNER_ADDRESS,
  })
  console.log(
    `Successfully created a fixed-price sell order! ${fixedPriceSellOrder.asset.openseaLink}\n`
  )

  // // Example: Dutch auction.
  console.log('Dutch auctioning an item...')
  const expirationTime = Math.round(Date.now() / 1000 + 60 * 60 * 24)
  const dutchAuctionSellOrder = await seaport.createSellOrder({
    asset: {
      tokenId: '2',
      tokenAddress: NFT_CONTRACT_ADDRESS,
      schemaName: WyvernSchemaName.ERC1155,
    },
    startAmount: 0.05,
    endAmount: 0.01,
    expirationTime: expirationTime,
    accountAddress: OWNER_ADDRESS,
  })
  console.log(
    `Successfully created a dutch auction sell order! ${dutchAuctionSellOrder.asset.openseaLink}\n`
  )

  // Example: multiple item sale for ERC20 token
  console.log('Selling multiple items for an ERC20 token (WETH)')
  const wethAddress =
    NETWORK === 'mainnet' || NETWORK === 'live'
      ? '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2'
      : '0xc778417e063141139fce010982780140aa0cd5ab'
  const englishAuctionSellOrder = await seaport.createSellOrder({
    asset: {
      tokenId: '3',
      tokenAddress: NFT_CONTRACT_ADDRESS,
      schemaName: WyvernSchemaName.ERC1155,
    },
    startAmount: 0.03,
    quantity: 2,
    expirationTime: expirationTime,
    paymentTokenAddress: wethAddress,
    accountAddress: OWNER_ADDRESS,
  })
  console.log(
    `Successfully created bulk-item sell order! ${englishAuctionSellOrder.asset.openseaLink}\n`
  )
}

main()

'''
'''--- scripts/initial_sale.js ---
const opensea = require("opensea-js");
const OpenSeaPort = opensea.OpenSeaPort;
const Network = opensea.Network;
const MnemonicWalletSubprovider = require("@0x/subproviders")
  .MnemonicWalletSubprovider;
const RPCSubprovider = require("web3-provider-engine/subproviders/rpc");
const Web3ProviderEngine = require("web3-provider-engine");

const MNEMONIC = process.env.MNEMONIC;
const NODE_API_KEY = process.env.INFURA_KEY || process.env.ALCHEMY_KEY;
const isInfura = !!process.env.INFURA_KEY;
const FACTORY_CONTRACT_ADDRESS = process.env.FACTORY_CONTRACT_ADDRESS;
const OWNER_ADDRESS = process.env.OWNER_ADDRESS;
const NETWORK = process.env.NETWORK;
const API_KEY = process.env.API_KEY || ""; // API key is optional but useful if you're doing a high volume of requests.

const DUTCH_AUCTION_OPTION_ID = "1";
const DUTCH_AUCTION_START_AMOUNT = 100;
const DUTCH_AUCTION_END_AMOUNT = 50;
const NUM_DUTCH_AUCTIONS = 3;

const FIXED_PRICE_OPTION_ID = "2";
const NUM_FIXED_PRICE_AUCTIONS = 10;
const FIXED_PRICE = 0.05;

if (!MNEMONIC || !NODE_API_KEY || !NETWORK || !OWNER_ADDRESS) {
  console.error(
    "Please set a mnemonic, Alchemy/Infura key, owner, network, API key, nft contract, and factory contract address."
  );
  return;
}

if (!FACTORY_CONTRACT_ADDRESS) {
  console.error("Please specify a factory contract address.");
  return;
}

const BASE_DERIVATION_PATH = `44'/60'/0'/0`;

const mnemonicWalletSubprovider = new MnemonicWalletSubprovider({
  mnemonic: MNEMONIC,
  baseDerivationPath: BASE_DERIVATION_PATH,
});
const network =
  NETWORK === "mainnet" || NETWORK === "live" ? "mainnet" : "rinkeby";
const infuraRpcSubprovider = new RPCSubprovider({
  rpcUrl: isInfura
    ? "https://" + network + ".infura.io/v3/" + NODE_API_KEY
    : "https://eth-" + network + ".alchemyapi.io/v2/" + NODE_API_KEY,
});

const providerEngine = new Web3ProviderEngine();
providerEngine.addProvider(mnemonicWalletSubprovider);
providerEngine.addProvider(infuraRpcSubprovider);
providerEngine.start();

const seaport = new OpenSeaPort(
  providerEngine,
  {
    networkName:
      NETWORK === "mainnet" || NETWORK === "live"
        ? Network.Main
        : Network.Rinkeby,
    apiKey: API_KEY,
  },
  (arg) => console.log(arg)
);

async function main() {
  // Example: many fixed price auctions for a factory option.
  console.log("Creating fixed price auctions...");
  const fixedSellOrders = await seaport.createFactorySellOrders({
    assets: [
      {
        tokenId: FIXED_PRICE_OPTION_ID,
        tokenAddress: FACTORY_CONTRACT_ADDRESS,
      },
    ],
    accountAddress: OWNER_ADDRESS,
    startAmount: FIXED_PRICE,
    numberOfOrders: NUM_FIXED_PRICE_AUCTIONS,
  });
  console.log(
    `Successfully made ${fixedSellOrders.length} fixed-price sell orders! ${fixedSellOrders[0].asset.openseaLink}\n`
  );

  // Example: many fixed price auctions for multiple factory options.
  console.log("Creating fixed price auctions...");
  const fixedSellOrdersTwo = await seaport.createFactorySellOrders({
    assets: [
      { tokenId: "3", tokenAddress: FACTORY_CONTRACT_ADDRESS },
      { tokenId: "4", tokenAddress: FACTORY_CONTRACT_ADDRESS },
      { tokenId: "5", tokenAddress: FACTORY_CONTRACT_ADDRESS },
      { tokenId: "6", tokenAddress: FACTORY_CONTRACT_ADDRESS },
    ],
    factoryAddress: FACTORY_CONTRACT_ADDRESS,
    accountAddress: OWNER_ADDRESS,
    startAmount: FIXED_PRICE,
    numberOfOrders: NUM_FIXED_PRICE_AUCTIONS,
  });
  console.log(
    `Successfully made ${fixedSellOrdersTwo.length} fixed-price sell orders for multiple assets at once! ${fixedSellOrders[0].asset.openseaLink}\n`
  );

  // Example: many declining Dutch auction for a factory.
  console.log("Creating dutch auctions...");

  // Expire one day from now
  const expirationTime = Math.round(Date.now() / 1000 + 60 * 60 * 24);
  const dutchSellOrders = await seaport.createFactorySellOrders({
    assets: [
      {
        tokenId: DUTCH_AUCTION_OPTION_ID,
        tokenAddress: FACTORY_CONTRACT_ADDRESS,
      },
    ],
    accountAddress: OWNER_ADDRESS,
    startAmount: DUTCH_AUCTION_START_AMOUNT,
    endAmount: DUTCH_AUCTION_END_AMOUNT,
    expirationTime: expirationTime,
    numberOfOrders: NUM_DUTCH_AUCTIONS,
  });
  console.log(
    `Successfully made ${dutchSellOrders.length} Dutch-auction sell orders! ${dutchSellOrders[0].asset.openseaLink}\n`
  );
}

main();

'''
'''--- scripts/mint.js ---
const HDWalletProvider = require("truffle-hdwallet-provider");
const web3 = require("web3");
const MNEMONIC = process.env.MNEMONIC;
const NODE_API_KEY = process.env.INFURA_KEY || process.env.ALCHEMY_KEY;
const isInfura = !!process.env.INFURA_KEY;
const FACTORY_CONTRACT_ADDRESS = process.env.FACTORY_CONTRACT_ADDRESS;
const NFT_CONTRACT_ADDRESS = process.env.NFT_CONTRACT_ADDRESS;
const OWNER_ADDRESS = process.env.OWNER_ADDRESS;
const NETWORK = process.env.NETWORK;
const NUM_CREATURES = 12;
const NUM_LOOTBOXES = 4;
const DEFAULT_OPTION_ID = 0;
const LOOTBOX_OPTION_ID = 2;

if (!MNEMONIC || !NODE_API_KEY || !OWNER_ADDRESS || !NETWORK) {
  console.error(
    "Please set a mnemonic, Alchemy/Infura key, owner, network, and contract address."
  );
  return;
}

const NFT_ABI = [
  {
    constant: false,
    inputs: [
      {
        name: "_to",
        type: "address",
      },
    ],
    name: "mintTo",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function",
  },
];

const FACTORY_ABI = [
  {
    constant: false,
    inputs: [
      {
        name: "_optionId",
        type: "uint256",
      },
      {
        name: "_toAddress",
        type: "address",
      },
    ],
    name: "mint",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function",
  },
];

async function main() {
  const network =
    NETWORK === "mainnet" || NETWORK === "live" ? "mainnet" : "rinkeby";
  const provider = new HDWalletProvider(
    MNEMONIC,
    isInfura
      ? "https://" + network + ".infura.io/v3/" + NODE_API_KEY
      : "https://eth-" + network + ".alchemyapi.io/v2/" + NODE_API_KEY
  );
  const web3Instance = new web3(provider);

  if (FACTORY_CONTRACT_ADDRESS) {
    const factoryContract = new web3Instance.eth.Contract(
      FACTORY_ABI,
      FACTORY_CONTRACT_ADDRESS,
      { gasLimit: "1000000" }
    );

    // Creatures issued directly to the owner.
    for (var i = 0; i < NUM_CREATURES; i++) {
      const result = await factoryContract.methods
        .mint(DEFAULT_OPTION_ID, OWNER_ADDRESS)
        .send({ from: OWNER_ADDRESS });
      console.log("Minted creature. Transaction: " + result.transactionHash);
    }

    // Lootboxes issued directly to the owner.
    for (var i = 0; i < NUM_LOOTBOXES; i++) {
      const result = await factoryContract.methods
        .mint(LOOTBOX_OPTION_ID, OWNER_ADDRESS)
        .send({ from: OWNER_ADDRESS });
      console.log("Minted lootbox. Transaction: " + result.transactionHash);
    }
  } else if (NFT_CONTRACT_ADDRESS) {
    const nftContract = new web3Instance.eth.Contract(
      NFT_ABI,
      NFT_CONTRACT_ADDRESS,
      { gasLimit: "1000000" }
    );

    // Creatures issued directly to the owner.
    for (var i = 0; i < NUM_CREATURES; i++) {
      const result = await nftContract.methods
        .mintTo(OWNER_ADDRESS)
        .send({ from: OWNER_ADDRESS });
      console.log("Minted creature. Transaction: " + result.transactionHash);
    }
  } else {
    console.error(
      "Add NFT_CONTRACT_ADDRESS or FACTORY_CONTRACT_ADDRESS to the environment variables"
    );
  }
}

main();

'''
'''--- scripts/sell.js ---
const opensea = require("opensea-js");
const OpenSeaPort = opensea.OpenSeaPort;
const Network = opensea.Network;
const MnemonicWalletSubprovider = require("@0x/subproviders")
  .MnemonicWalletSubprovider;
const RPCSubprovider = require("web3-provider-engine/subproviders/rpc");
const Web3ProviderEngine = require("web3-provider-engine");

const MNEMONIC = process.env.MNEMONIC;
const NODE_API_KEY = process.env.INFURA_KEY || process.env.ALCHEMY_KEY;
const isInfura = !!process.env.INFURA_KEY;
const FACTORY_CONTRACT_ADDRESS = process.env.FACTORY_CONTRACT_ADDRESS;
const NFT_CONTRACT_ADDRESS = process.env.NFT_CONTRACT_ADDRESS;
const OWNER_ADDRESS = process.env.OWNER_ADDRESS;
const NETWORK = process.env.NETWORK;
const API_KEY = process.env.API_KEY || ""; // API key is optional but useful if you're doing a high volume of requests.

if (!MNEMONIC || !NODE_API_KEY || !NETWORK || !OWNER_ADDRESS) {
  console.error(
    "Please set a mnemonic, Alchemy/Infura key, owner, network, API key, nft contract, and factory contract address."
  );
  return;
}

if (!FACTORY_CONTRACT_ADDRESS && !NFT_CONTRACT_ADDRESS) {
  console.error("Please either set a factory or NFT contract address.");
  return;
}

const BASE_DERIVATION_PATH = `44'/60'/0'/0`;

const mnemonicWalletSubprovider = new MnemonicWalletSubprovider({
  mnemonic: MNEMONIC,
  baseDerivationPath: BASE_DERIVATION_PATH,
});
const network =
  NETWORK === "mainnet" || NETWORK === "live" ? "mainnet" : "rinkeby";
const infuraRpcSubprovider = new RPCSubprovider({
  rpcUrl: isInfura
    ? "https://" + network + ".infura.io/v3/" + NODE_API_KEY
    : "https://eth-" + network + ".alchemyapi.io/v2/" + NODE_API_KEY,
});

const providerEngine = new Web3ProviderEngine();
providerEngine.addProvider(mnemonicWalletSubprovider);
providerEngine.addProvider(infuraRpcSubprovider);
providerEngine.start();

const seaport = new OpenSeaPort(
  providerEngine,
  {
    networkName:
      NETWORK === "mainnet" || NETWORK === "live"
        ? Network.Main
        : Network.Rinkeby,
    apiKey: API_KEY,
  },
  (arg) => console.log(arg)
);

async function main() {
  // Example: simple fixed-price sale of an item owned by a user.
  console.log("Auctioning an item for a fixed price...");
  const fixedPriceSellOrder = await seaport.createSellOrder({
    asset: {
      tokenId: "1",
      tokenAddress: NFT_CONTRACT_ADDRESS,
    },
    startAmount: 0.05,
    expirationTime: 0,
    accountAddress: OWNER_ADDRESS,
  });
  console.log(
    `Successfully created a fixed-price sell order! ${fixedPriceSellOrder.asset.openseaLink}\n`
  );

  // // Example: Dutch auction.
  console.log("Dutch auctioning an item...");
  const expirationTime = Math.round(Date.now() / 1000 + 60 * 60 * 24);
  const dutchAuctionSellOrder = await seaport.createSellOrder({
    asset: {
      tokenId: "2",
      tokenAddress: NFT_CONTRACT_ADDRESS,
    },
    startAmount: 0.05,
    endAmount: 0.01,
    expirationTime: expirationTime,
    accountAddress: OWNER_ADDRESS,
  });
  console.log(
    `Successfully created a dutch auction sell order! ${dutchAuctionSellOrder.asset.openseaLink}\n`
  );

  // Example: English auction.
  console.log("English auctioning an item in DAI...");
  const wethAddress =
    NETWORK === "mainnet" || NETWORK === "live"
      ? "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2"
      : "0xc778417e063141139fce010982780140aa0cd5ab";
  const englishAuctionSellOrder = await seaport.createSellOrder({
    asset: {
      tokenId: "3",
      tokenAddress: NFT_CONTRACT_ADDRESS,
    },
    startAmount: 0.03,
    expirationTime: expirationTime,
    waitForHighestBid: true,
    paymentTokenAddress: wethAddress,
    accountAddress: OWNER_ADDRESS,
  });
  console.log(
    `Successfully created an English auction sell order! ${englishAuctionSellOrder.asset.openseaLink}\n`
  );
}

main();

'''
'''--- test/CreatureAccessory.js ---
/* Contracts in this test */

const CreatureAccessory = artifacts.require(
  "../contracts/CreatureAccessory.sol"
);

contract("CreatureAccessory", (accounts) => {
  const URI_BASE = 'https://creatures-api.opensea.io';
  const CONTRACT_URI = `${URI_BASE}/contract/opensea-erc1155`;
  let creatureAccessory;

  before(async () => {
    creatureAccessory = await CreatureAccessory.deployed();
  });

  // This is all we test for now

  // This also tests contractURI()

  describe('#constructor()', () => {
    it('should set the contractURI to the supplied value', async () => {
      assert.equal(await creatureAccessory.contractURI(), CONTRACT_URI);
    });
  });
});

'''
'''--- test/CreatureAccessoryFactory.js ---
/* libraries used */

const truffleAssert = require('truffle-assertions');

const setup = require('../lib/setupCreatureAccessories.js');
const testVals = require('../lib/testValuesCommon.js');
const vals = require('../lib/valuesCommon.js');

/* Contracts in this test */

const MockProxyRegistry = artifacts.require(
  "../contracts/MockProxyRegistry.sol"
);
const LootBoxRandomness = artifacts.require(
  "../contracts/LootBoxRandomness.sol"
);
const CreatureAccessory = artifacts.require("../contracts/CreatureAccessory.sol");
const CreatureAccessoryFactory = artifacts.require("../contracts/CreatureAccessoryFactory.sol");
const CreatureAccessoryLootBox = artifacts.require("../contracts/CreatureAccessoryLootBox.sol");
const TestForReentrancyAttack = artifacts.require(
  "../contracts/TestForReentrancyAttack.sol"
);

/* Useful aliases */

const toBN = web3.utils.toBN;

/* Utilities */

const toTokenId = optionId => optionId;

contract("CreatureAccessoryFactory", (accounts) => {
  const TOTAL_OPTIONS = 9;

  const owner = accounts[0];
  const userA = accounts[1];
  const userB = accounts[2];
  const proxyForOwner = accounts[8];

  let creatureAccessory;
  let myFactory;
  let myLootBox;
  let attacker;
  let proxy;

  // To install the proxy mock and the attack contract we deploy our own
  // instances of all the classes here rather than using the ones that Truffle
  // deployed.

  before(async () => {
    proxy = await MockProxyRegistry.new();
    await proxy.setProxy(owner, proxyForOwner);
    creatureAccessory = await CreatureAccessory.new(proxy.address);
    CreatureAccessoryLootBox.link(LootBoxRandomness);
    myLootBox = await CreatureAccessoryLootBox.new(
      proxy.address,
      { gas: 6721975 }
    );
    myFactory = await CreatureAccessoryFactory.new(
      proxy.address,
      creatureAccessory.address,
      myLootBox.address
    );
    attacker = await TestForReentrancyAttack.new();
    await attacker.setFactoryAddress(myFactory.address);
    await setup.setupCreatureAccessories(
      creatureAccessory,
      myFactory,
      myLootBox,
      owner
    );
  });

  // This also tests the proxyRegistryAddress and lootBoxAddress accessors.

  describe('#constructor()', () => {
    it('should set proxyRegistryAddress to the supplied value', async () => {
      assert.equal(await myFactory.proxyRegistryAddress(), proxy.address);
      assert.equal(await myFactory.lootBoxAddress(), myLootBox.address);
    });
  });

  describe('#name()', () => {
    it('should return the correct name', async () => {
      assert.equal(
        await myFactory.name(),
        'OpenSea Creature Accessory Pre-Sale'
      );
    });
  });

  describe('#symbol()', () => {
    it('should return the correct symbol', async () => {
      assert.equal(await myFactory.symbol(), 'OSCAP');
    });
  });

  describe('#supportsFactoryInterface()', () => {
    it('should return true', async () => {
      assert.isOk(await myFactory.supportsFactoryInterface());
    });
  });

  describe('#factorySchemaName()', () => {
    it('should return the schema name', async () => {
      assert.equal(await myFactory.factorySchemaName(), 'ERC1155');
    });
  });

  describe('#numOptions()', () => {
    it('should return the correct number of options', async () => {
      assert.equal(await myFactory.numOptions(), TOTAL_OPTIONS);
    });
  });

  //NOTE: We test this early relative to its place in the source code as we
  //      mint tokens that we rely on the existence of in later tests here.
  
  describe('#mint()', () => {
    it('should not allow non-owner or non-operator to mint', async () => {
      await truffleAssert.fails(
        myFactory.mint(vals.CLASS_COMMON, userA, 1000, "0x0", { from: userA }),
        truffleAssert.ErrorType.revert,
        'CreatureAccessoryFactory#_mint: CANNOT_MINT_MORE'
      );
    });

    it('should allow owner to mint', async () => {
      const quantity = toBN(10);
      await myFactory.mint(
        vals.CLASS_COMMON,
        userA,
        quantity,
        "0x0",
        { from: owner }
      );
      // Check that the recipient got the correct quantity
      // Token numbers are one higher than option numbers
      const balanceUserA = await creatureAccessory.balanceOf(
        userA,
        toTokenId(vals.CLASS_COMMON)
      );
      assert.isOk(balanceUserA.eq(quantity));
      // Check that balance is correct
      const balanceOf = await myFactory.balanceOf(owner, vals.CLASS_COMMON);
      assert.isOk(balanceOf.eq(toBN(vals.MINT_INITIAL_SUPPLY).sub(quantity)));
      // Check that total supply is correct
      const premintedRemaining = await creatureAccessory.balanceOf(
        owner,
        toTokenId(vals.CLASS_COMMON)
      );
      assert.isOk(premintedRemaining.eq(toBN(vals.MINT_INITIAL_SUPPLY).sub(quantity)));
    });

    it('should allow proxy to mint', async () => {
      const quantity = toBN(100);
      //FIXME: move all quantities to top level constants
      const total = toBN(110);
      await myFactory.mint(
        vals.CLASS_COMMON,
        userA,
        quantity,
        "0x0",
        { from: proxyForOwner }
      );
      // Check that the recipient got the correct quantity
      const balanceUserA = await creatureAccessory.balanceOf(
        userA,
        toTokenId(vals.CLASS_COMMON)
      );
      assert.isOk(balanceUserA.eq(total));
      // Check that balance is correct
      const balanceOf = await myFactory.balanceOf(owner, vals.CLASS_COMMON);
      assert.isOk(balanceOf.eq(toBN(vals.MINT_INITIAL_SUPPLY).sub(total)));
      // Check that total supply is correct
      const premintedRemaining = await creatureAccessory.balanceOf(
        owner,
        toTokenId(vals.CLASS_COMMON)
      );
      assert.isOk(premintedRemaining.eq(toBN(vals.MINT_INITIAL_SUPPLY).sub(total)));
    });
  });

  /**
   * NOTE: This check is difficult to test in a development
   * environment, due to the OwnableDelegateProxy. To get around
   * this, in order to test this function below, you'll need to:
   *
   * 1. go to CreatureAccessoryFactory.sol, and
   * 2. modify _isOwnerOrProxy
   *
   * --> Modification is:
   *      comment out
   *         return owner() == _address || address(proxyRegistry.proxies(owner())) == _address;
   *      replace with
   *         return true;
   * Then run, you'll get the reentrant error, which passes the test
   **/

  describe('Re-Entrancy Check', () => {
    it('Should have the correct factory address set',
       async () => {
         assert.equal(await attacker.factoryAddress(), myFactory.address);
       });

    // With unmodified code, this fails with:
    //   CreatureAccessoryFactory#_mint: CANNOT_MINT_MORE
    // which is the correct behavior (no reentrancy) for the wrong reason
    // (the attacker is not the owner or proxy).

    xit('Minting from factory should disallow re-entrancy attack',
       async () => {
         await truffleAssert.passes(
           myFactory.mint(1, userA, 1, "0x0", { from: owner })
         );
         await truffleAssert.passes(
           myFactory.mint(1, userA, 1, "0x0", { from: userA })
         );
         await truffleAssert.fails(
           myFactory.mint(
             1,
             attacker.address,
             1,
             "0x0",
             { from: attacker.address }
           ),
           truffleAssert.ErrorType.revert,
           'ReentrancyGuard: reentrant call'
         );
       });
  });
});

'''
'''--- test/CreatureAccessoryLootBox.js ---
/* libraries used */

const truffleAssert = require('truffle-assertions');

const setup = require('../lib/setupCreatureAccessories.js');
const testVals = require('../lib/testValuesCommon.js');
const vals = require('../lib/valuesCommon.js');

/* Contracts in this test */

const MockProxyRegistry = artifacts.require(
  "../contracts/MockProxyRegistry.sol"
);
const LootBoxRandomness = artifacts.require(
  "../contracts/LootBoxRandomness.sol"
);
const CreatureAccessory = artifacts.require("../contracts/CreatureAccessory.sol");
const CreatureAccessoryFactory = artifacts.require("../contracts/CreatureAccessoryFactory.sol");
const CreatureAccessoryLootBox = artifacts.require(
  "../contracts/CreatureAccessoryLootBox.sol"
);

/* Useful aliases */

const toBN = web3.utils.toBN;

/* Utility Functions */

// Not a function, the fields of the TransferSingle event.

const TRANSFER_SINGLE_FIELDS = [
  { type: 'address', name: '_operator', indexed: true },
  { type: 'address', name: '_from', indexed: true },
  { type: 'address', name: '_to', indexed: true },
  { type: 'uint256', name: '_id' },
  { type: 'uint256', name: '_amount' }
];

// Not a function, the keccak of the TransferSingle event.

const TRANSFER_SINGLE_SIG = web3.eth.abi.encodeEventSignature({
  name: 'TransferSingle',
  type: 'event',
  inputs: TRANSFER_SINGLE_FIELDS
});

// Total the number of tokens in the transaction's emitted TransferSingle events
// Keep a total for each token id number (1:..2:..)
// and a total for *all* tokens as total:.

const totalEventTokens = (receipt, recipient) => {
  // total is our running total for all tokens
  const totals = {total: toBN(0)};
  // Parse each log from the event
  for (let i = 0; i < receipt.receipt.rawLogs.length; i++) {
    const raw = receipt.receipt.rawLogs[i];
    // Filter events so we process only the TransferSingle events
    // Note that topic[0] is the event signature hash
    if (raw.topics[0] === TRANSFER_SINGLE_SIG) {
      // Fields of TransferSingle
      let parsed = web3.eth.abi.decodeLog(
        TRANSFER_SINGLE_FIELDS,
        raw.data,
        // Exclude event signature hash from topics that we process here.
        raw.topics.slice(1)
      );
      // Make sure the address that we are watching got the tokens.
      // Burnt tokens go to address zero, for example
      if (parsed._to == recipient) {
        // Keep a running total for each token id.
        const id = parsed._id;
        if (! totals[id]) {
          totals[id] = toBN(0);
        }
        const amount = toBN(parsed._amount);
        totals[id] = totals[id].add(amount);
        // Keep a running total for all token ids.
        totals.total = totals.total.add(amount);
      }
    }
  }
  return totals;
};

// Compare the token amounts map generated by totalEventTokens to a spec object.
// The spec should match the guarantees[] array for the option.

const compareTokenTotals = (totals, spec, option) => {
  Object.keys(spec).forEach(key => {
    assert.isOk(
      // Because it's an Object.keys() value, key is a string.
      // We want that for the spec, as it is the correct key.
      // But to add one we want a number, so we parse it then add one.
      // Why do we want to add one?
      totals[parseInt(key)] || toBN(0).gte(spec[key]),
      `Mismatch for option ${option} guarantees[${key}]`
    );
  });
};

/* Tests */

contract("CreatureAccessoryLootBox", (accounts) => {
  const owner = accounts[0];
  const userA = accounts[1];
  const userB = accounts[2];
  const proxyForOwner = accounts[8];

  let lootBox;
  let factory;
  let creatureAccessory;
  let proxy;

  before(async () => {
    proxy = await MockProxyRegistry.new();
    await proxy.setProxy(owner, proxyForOwner);
    creatureAccessory = await CreatureAccessory.new(proxy.address);
    CreatureAccessoryLootBox.link(LootBoxRandomness);
    lootBox = await CreatureAccessoryLootBox.new(
      proxy.address,
      { gas: 6721975 }
    );
    factory = await CreatureAccessoryFactory.new(
      proxy.address,
      creatureAccessory.address,
      lootBox.address
    );
    await setup.setupAccessory(creatureAccessory, owner);
    await creatureAccessory.setApprovalForAll(
      factory.address,
      true,
      { from: owner }
    );
    await creatureAccessory.transferOwnership(factory.address);
    await setup.setupAccessoryLootBox(lootBox, factory);
  });

  // Calls _mint()

  describe('#mint()', () => {
    it('should work for owner()', async () => {
      const option = toBN(vals.LOOTBOX_OPTION_BASIC);
      const amount = toBN(1);
      const receipt = await lootBox.mint(
        userB,
        option,
        amount,
        "0x0",
        { from: owner }
      );
      truffleAssert.eventEmitted(
        receipt,
        'TransferSingle',
        {
          from: testVals.ADDRESS_ZERO,
          to: userB,
          id: option,
          value: amount
        }
      );
    });

    it('should work for proxy', async () => {
      const option = vals.LOOTBOX_OPTION_BASIC;
      const amount = toBN(1);
      const receipt = await lootBox.mint(
          userB,
          option,
          amount,
          "0x0",
          { from: proxyForOwner }
      );
      truffleAssert.eventEmitted(
        receipt,
        'TransferSingle',
        {
          from: testVals.ADDRESS_ZERO,
          to: userB,
          //_id: option.add(toBN(1)),
          value: amount
        }
      );
    });

    it('should not be callable by non-owner() and non-proxy', async () => {
      const amount = toBN(1);
      await truffleAssert.fails(
        lootBox.mint(
          userB,
          vals.LOOTBOX_OPTION_PREMIUM,
          amount,
          "0x0",
          { from: userB }
        ),
        truffleAssert.ErrorType.REVERT,
        'Lootbox: owner or proxy only'
      );
    });

    it('should not work for invalid option', async () => {
      const amount = toBN(1);
      await truffleAssert.fails(
        lootBox.mint(
          userB,
          vals.NO_SUCH_LOOTBOX_OPTION,
          amount,
          "0x0",
          { from: owner }
        ),
        truffleAssert.ErrorType.REVERT,
        'Lootbox: Invalid Option'
      );
    });
  });

  describe('#unpack()', () => {
    it('should mint guaranteed class amounts for each option', async () => {
      for (let i = 0; i < vals.NUM_LOOTBOX_OPTIONS; i++) {
        const option = vals.LOOTBOX_OPTIONS[i];
        const amount = toBN(1);
        //console.log(i);
        await lootBox.mint(
          userB,
          option,
          amount,
          "0x0",
          { from: proxyForOwner }
        );
        const receipt = await lootBox.unpack(
          // Token IDs are option IDs
          option,
          userB,
          amount,
          { from: userB }
        );
        truffleAssert.eventEmitted(
          receipt,
          'LootBoxOpened',
          {
            boxesPurchased: amount,
            optionId: toBN(option),
            buyer: userB,
            itemsMinted: toBN(vals.LOOTBOX_OPTION_AMOUNTS[option])
          }
        );

        const totals = totalEventTokens(receipt, userB);
        assert.ok(totals.total.eq(toBN(vals.LOOTBOX_OPTION_AMOUNTS[option])));
        compareTokenTotals(totals, vals.LOOTBOX_OPTION_GUARANTEES[option], option);
      }
    });
  });
});

'''
'''--- test/ERC1155Tradable.js ---
/* libraries used */

const truffleAssert = require('truffle-assertions');
const { MockProvider } = require("ethereum-waffle");
const { signMetaTransaction } = require("./utils/signMetaTransaction.js")

const vals = require('../lib/testValuesCommon.js');

/* Contracts in this test */

const ERC1155Tradable = artifacts.require("../contracts/ERC1155Tradable.sol");
const MockProxyRegistry = artifacts.require(
  "../contracts/MockProxyRegistry.sol"
);
const ApprovedSpenderContract = artifacts.require(
  "../contracts/test/ApprovedSpenderContract.sol"
);

/* Useful aliases */

const toBN = web3.utils.toBN;

const web3ERC1155 = new web3.eth.Contract(ERC1155Tradable.abi)

contract("ERC1155Tradable - ERC 1155", (accounts) => {
  const NAME = 'ERC-1155 Test Contract';
  const SYMBOL = 'ERC1155Test';

  const INITIAL_TOKEN_ID = 1;
  const NON_EXISTENT_TOKEN_ID = 99999999;
  const MINT_AMOUNT = toBN(100);

  const OVERFLOW_NUMBER = toBN(2, 10).pow(toBN(256, 10)).sub(toBN(1, 10));

  const owner = accounts[0];
  const creator = accounts[1];
  const userA = accounts[2];
  const userB = accounts[3];
  const proxyForOwner = accounts[5];

  let instance;
  let proxy;

  // Keep track of token ids as we progress through the tests, rather than
  // hardcoding numbers that we will have to change if we add/move tests.
  // For example if test A assumes that it will create token ID 1 and test B
  // assumes that it will create token 2, changing test A later so that it
  // creates another token will break this as test B will now create token ID 3.
  // Doing this avoids this scenario.
  let tokenId = 0;

  // Because we need to deploy and use a mock ProxyRegistry, we deploy our own
  // instance of ERC1155Tradable instead of using the one that Truffle deployed.
  
  before(async () => {
    proxy = await MockProxyRegistry.new();
    await proxy.setProxy(owner, proxyForOwner);
    instance = await ERC1155Tradable.new(NAME, SYMBOL, vals.URI_BASE, proxy.address);
    approvedContract = await ApprovedSpenderContract.new();
  });

  describe('#constructor()', () => {
    it('should set the token name, symbol, and URI', async () => {
      const name = await instance.name();
      assert.equal(name, NAME);
      const symbol = await instance.symbol();
      assert.equal(symbol, SYMBOL);
      // We cannot check the proxyRegistryAddress as there is no accessor for it
    });
  });

  describe('#create()', () => {
    it('should allow the contract owner to create tokens with zero supply',
       async () => {
         tokenId += 1;
         truffleAssert.eventEmitted(
           await instance.create(owner, tokenId, 0, "", "0x0", { from: owner }),
           'TransferSingle',
           {
             operator: owner,
             from: vals.ADDRESS_ZERO,
             to: owner,
             id: toBN(tokenId),
             value: toBN(0)
           }
         );
         const supply = await instance.tokenSupply(tokenId);
         assert.ok(supply.eq(toBN(0)));
       });

    it('should allow the contract owner to create tokens with initial supply',
       async () => {
         tokenId += 1;
         truffleAssert.eventEmitted(
           await instance.create(
             owner,
             tokenId,
             MINT_AMOUNT,
             "",
             "0x0",
             { from: owner }
           ),
           'TransferSingle',
           {
             operator: owner,
             from: vals.ADDRESS_ZERO,
             to: owner,
             id: toBN(tokenId),
             value: MINT_AMOUNT
           }
         );
         const supply = await instance.tokenSupply(tokenId);
         assert.ok(supply.eq(MINT_AMOUNT));
       });

    // We check some of this in the other create() tests but this makes it
    // explicit and is more thorough.
    it('should set tokenSupply on creation',
       async () => {
         tokenId += 1;
         tokenSupply = 33
         truffleAssert.eventEmitted(
           await instance.create(owner, tokenId, tokenSupply, "", "0x0", { from: owner }),
           'TransferSingle',
           { id: toBN(tokenId) }
         );
         const balance = await instance.balanceOf(owner, tokenId);
         assert.ok(balance.eq(toBN(tokenSupply)));
         const supply = await instance.tokenSupply(tokenId);
         assert.ok(supply.eq(toBN(tokenSupply)));
         assert.ok(supply.eq(balance));
       });

    it('should increment the token type id',
       async () => {
         // We can't check this with an accessor, so we make an explicit check
         // that it increases in consecutive creates() using the value emitted
         // in their events.
         tokenId += 1;
         await truffleAssert.eventEmitted(
           await instance.create(owner, tokenId, 0, "", "0x0", { from: owner }),
           'TransferSingle',
           { id: toBN(tokenId) }
         );
         tokenId += 1;
         await truffleAssert.eventEmitted(
           await instance.create(owner, tokenId, 0, "", "0x0", { from: owner }),
           'TransferSingle',
           { id: toBN(tokenId) }
         );
       });

    it('should not allow a non-owner to create tokens',
       async () => {
         tokenId += 1;
         truffleAssert.fails(
           instance.create(userA, tokenId, 0, "", "0x0", { from: userA }),
           truffleAssert.ErrorType.revert,
           'caller is not the owner'
         );
       });

    it('should allow the contract owner to create tokens and emit a URI',
       async () => {
         tokenId += 1;
         truffleAssert.eventEmitted(
           await instance.create(
             owner,
             tokenId,
             0,
             vals.URI_BASE,
             "0x0",
             { from: owner }
           ),
           'URI',
           {
             value: vals.URI_BASE,
             id: toBN(tokenId)
           }
         );
       });

    it('should not emit a URI if none is passed',
       async () => {
         tokenId += 1;
         truffleAssert.eventNotEmitted(
           await instance.create(owner, tokenId, 0, "", "0x0", { from: owner }),
           'URI'
         );
       });
  });

  describe('#totalSupply()', () => {
    it('should return correct value for token supply',
       async () => {
         tokenId += 1;
         await instance.create(owner, tokenId, MINT_AMOUNT, "", "0x0", { from: owner });
         const balance = await instance.balanceOf(owner, tokenId);
         assert.ok(balance.eq(MINT_AMOUNT));
         // Use the created getter for the map
         const supplyGetterValue = await instance.tokenSupply(tokenId);
         assert.ok(supplyGetterValue.eq(MINT_AMOUNT));
         // Use the hand-crafted accessor
         const supplyAccessorValue = await instance.totalSupply(tokenId);
         assert.ok(supplyAccessorValue.eq(MINT_AMOUNT));

         // Make explicitly sure everything mateches
         assert.ok(supplyGetterValue.eq(balance));
         assert.ok(supplyAccessorValue.eq(balance));
       });

    it('should return zero for non-existent token',
       async () => {
         const balanceValue = await instance.balanceOf(
           owner,
           NON_EXISTENT_TOKEN_ID
         );
         assert.ok(balanceValue.eq(toBN(0)));
         const supplyAccessorValue = await instance.totalSupply(
           NON_EXISTENT_TOKEN_ID
         );
         assert.ok(supplyAccessorValue.eq(toBN(0)));
       });
  });

  describe('#setCreator()', () => {
    it('should allow the token creator to set creator to another address',
       async () => {
         await instance.setCreator(userA, [INITIAL_TOKEN_ID], {from: owner});
         const tokenCreator = await instance.creators(INITIAL_TOKEN_ID);
         assert.equal(tokenCreator, userA);
       });

    it('should allow the new creator to set creator to another address',
       async () => {
         await instance.setCreator(creator, [INITIAL_TOKEN_ID], {from: userA});
         const tokenCreator = await instance.creators(INITIAL_TOKEN_ID);
         assert.equal(tokenCreator, creator);
       });

    it('should not allow the token creator to set creator to 0x0',
       () => truffleAssert.fails(
         instance.setCreator(
           vals.ADDRESS_ZERO,
           [INITIAL_TOKEN_ID],
           { from: creator }
         ),
         truffleAssert.ErrorType.revert,
         'ERC1155Tradable#setCreator: INVALID_ADDRESS.'
       ));

    it('should not allow a non-token-creator to set creator',
       // Check both a user and the owner of the contract
       async () => {
         await truffleAssert.fails(
           instance.setCreator(userA, [INITIAL_TOKEN_ID], {from: userA}),
           truffleAssert.ErrorType.revert,
           'ERC1155Tradable#creatorOnly: ONLY_CREATOR_ALLOWED'
         );
         await truffleAssert.fails(
           instance.setCreator(owner, [INITIAL_TOKEN_ID], {from: owner}),
           truffleAssert.ErrorType.revert,
           'ERC1155Tradable#creatorOnly: ONLY_CREATOR_ALLOWED'
         );
       });
  });

  describe('#mint()', () => {
    it('should allow creator to mint tokens',
       async () => {
         await instance.mint(
           userA,
           INITIAL_TOKEN_ID,
           MINT_AMOUNT,
           "0x0",
           { from: creator }
         );
         let supply = await instance.totalSupply(INITIAL_TOKEN_ID);
         assert.isOk(supply.eq(MINT_AMOUNT));
       });

    it('should update token totalSupply when minting', async () => {
      let supply = await instance.totalSupply(INITIAL_TOKEN_ID);
      assert.isOk(supply.eq(MINT_AMOUNT));
      await instance.mint(
        userA,
        INITIAL_TOKEN_ID,
        MINT_AMOUNT,
        "0x0",
        { from: creator }
      );
      supply = await instance.totalSupply(INITIAL_TOKEN_ID);
      assert.isOk(supply.eq(MINT_AMOUNT.mul(toBN(2))));
    });

    it('should not overflow token balances',
       async () => {
         const supply = await instance.totalSupply(INITIAL_TOKEN_ID);
         assert.isOk(supply.eq(MINT_AMOUNT.add(MINT_AMOUNT)));
         await truffleAssert.fails(
           instance.mint(
             userB,
             INITIAL_TOKEN_ID,
             OVERFLOW_NUMBER,
             "0x0",
             {from: creator}
           ),
           truffleAssert.ErrorType.revert,
           "revert"
         );
       });
  });

  describe('#batchMint()', () => {
    it('should correctly set totalSupply',
       async () => {
         await instance.batchMint(
           userA,
           [INITIAL_TOKEN_ID],
           [MINT_AMOUNT],
           "0x0",
           { from: creator }
         );
         const supply = await instance.totalSupply(INITIAL_TOKEN_ID);
         assert.isOk(
           supply.eq(MINT_AMOUNT.mul(toBN(3)))
         );
       });

    it('should not overflow token balances',
       () => truffleAssert.fails(
         instance.batchMint(
           userB,
           [INITIAL_TOKEN_ID],
           [OVERFLOW_NUMBER],
           "0x0",
           { from: creator }
         ),
         truffleAssert.ErrorType.revert
       )
      );

    it('should require that caller has permission to mint each token',
       async () => truffleAssert.fails(
         instance.batchMint(
           userA,
           [INITIAL_TOKEN_ID],
           [MINT_AMOUNT],
           "0x0",
           { from: userB }
         ),
         truffleAssert.ErrorType.revert,
         'ERC1155Tradable#batchMint: ONLY_CREATOR_ALLOWED'
       ));
  });

  describe ('#uri()', () => {
    it('should return the uri that supports the substitution method', async () => {
      const uriTokenId = 1;
      const uri = await instance.uri(uriTokenId);
      assert.equal(uri, `${vals.URI_BASE}`);
    });

    it('should not return the uri for a non-existent token', async () =>
       truffleAssert.fails(
         instance.uri(NON_EXISTENT_TOKEN_ID),
         truffleAssert.ErrorType.revert,
         'NONEXISTENT_TOKEN'
       )
      );
  });

  describe ('#setURI()', () => {
    newUri = "https://newuri.com/{id}"
    it('should allow the owner to set the url', async () => {
       truffleAssert.passes(
         await instance.setURI(newUri, { from: owner })
       );
       const uriTokenId = 1;
       const uri = await instance.uri(uriTokenId);
       assert.equal(uri, newUri);
    });

    it('should not allow non-owner to set the url', async () =>
       truffleAssert.fails(
         instance.setURI(newUri, { from: userA }),
         truffleAssert.ErrorType.revert,
         'Ownable: caller is not the owner'
       ));
  });

  describe ('#setCustomURI()', () => {
    customUri = "https://customuri.com/metadata"
    it('should allow the creator to set the custom uri of a token', async () => {
      tokenId += 1;
      await instance.create(owner, tokenId, 0, "", "0x0", { from: owner });
      truffleAssert.passes(
        await instance.setCustomURI(tokenId, customUri, { from: owner })
      );
      const uri = await instance.uri(tokenId);
      assert.equal(uri, customUri);
    });

    it('should not allow non-creator to set the custom url of a token', async () => {
      tokenId += 1;
      await instance.create(owner, tokenId, 0, "", "0x0", { from: owner });
      truffleAssert.fails(
        instance.setCustomURI(tokenId, customUri, { from: userB })
      );
      });
  });

  describe('#isApprovedForAll()', () => {
    it('should approve proxy address as _operator', async () => {
      assert.isOk(
        await instance.isApprovedForAll(owner, proxyForOwner)
      );
    });

    it('should not approve non-proxy address as _operator', async () => {
      assert.isNotOk(
        await instance.isApprovedForAll(owner, userB)
      );
    });

    it('should reject proxy as _operator for non-owner _owner', async () => {
      assert.isNotOk(
        await instance.isApprovedForAll(userA, proxyForOwner)
      );
    });

    it('should accept approved _operator for _owner', async () => {
      await instance.setApprovalForAll(userB, true, { from: userA });
      assert.isOk(await instance.isApprovedForAll(userA, userB));
      // Reset it here
      await instance.setApprovalForAll(userB, false, { from: userA });
    });

    it('should not accept non-approved _operator for _owner', async () => {
      await instance.setApprovalForAll(userB, false, { from: userA });
      assert.isNotOk(await instance.isApprovedForAll(userA, userB));
    });
  });

  describe("#executeMetaTransaction()", function () {
    it("should allow calling setApprovalForAll with a meta transaction", async function () {
      const wallet = new MockProvider().createEmptyWallet();
      const user = await wallet.getAddress()

      let name = await instance.name();
      let nonce = await instance.getNonce(user);
      let version = await instance.ERC712_VERSION();
      let chainId = await instance.getChainId();
      let domainData = {
        name: name,
        version: version,
        verifyingContract: instance.address,
        salt: '0x' + web3.utils.toHex(chainId).substring(2).padStart(64, '0'),
      };
      const functionSignature = await web3ERC1155.methods.setApprovalForAll(approvedContract.address, true).encodeABI()
      let { r, s, v } = await signMetaTransaction(
        wallet,
        nonce,
        domainData,
        functionSignature
      );

      assert.equal(await instance.isApprovedForAll(user, approvedContract.address), false);
      truffleAssert.eventEmitted(
        await instance.executeMetaTransaction(
          user,
          functionSignature,
          r,
          s,
          v
        ),
        'ApprovalForAll',
        {
          account: user,
          operator: approvedContract.address,
          approved: true
        }
      );
      assert.equal(await instance.isApprovedForAll(user, approvedContract.address), true);
    });
  });
});

'''
'''--- test/utils/signMetaTransaction.js ---
const ethUtils = require("ethereumjs-util");
const sigUtil = require("eth-sig-util");

const domainType = [
    {
      name: "name",
      type: "string",
    },
    {
      name: "version",
      type: "string",
    },
    {
      name: "verifyingContract",
      type: "address",
    },
    {
      name: "salt",
      type: "bytes32",
    },
  ];
  
  const metaTransactionType = [
    {
      name: "nonce",
      type: "uint256",
    },
    {
      name: "from",
      type: "address",
    },
    {
      name: "functionSignature",
      type: "bytes",
    },
  ];
  
  const signMetaTransaction = async (wallet, nonce, domainData, functionSignature) => {
    let message = {};
    message.nonce = parseInt(nonce);
    message.from = await wallet.getAddress();
    message.functionSignature = functionSignature;
  
    const dataToSign = {
      types: {
        EIP712Domain: domainType,
        MetaTransaction: metaTransactionType,
      },
      domain: domainData,
      primaryType: "MetaTransaction",
      message: message,
    };
  
    const signature = sigUtil.signTypedData(ethUtils.toBuffer(wallet.privateKey), {
      data: dataToSign,
    });
    let r = signature.slice(0, 66);
    let s = "0x".concat(signature.slice(66, 130));
    let v = "0x".concat(signature.slice(130, 132));
    v = parseInt(v);
    if (![27, 28].includes(v)) v += 27;
  
    return {
      r,
      s,
      v
    };
  };

  module.exports = {
    signMetaTransaction
};
'''
'''--- truffle.js ---
const HDWalletProvider = require("truffle-hdwallet-provider");

const MNEMONIC = process.env.MNEMONIC;
const NODE_API_KEY = process.env.INFURA_KEY || process.env.ALCHEMY_KEY;
const isInfura = !!process.env.INFURA_KEY;

const needsNodeAPI =
  process.env.npm_config_argv &&
  (process.env.npm_config_argv.includes("rinkeby") ||
    process.env.npm_config_argv.includes("live"));

if ((!MNEMONIC || !NODE_API_KEY) && needsNodeAPI) {
  console.error("Please set a mnemonic and ALCHEMY_KEY or INFURA_KEY.");
  process.exit(0);
}

const rinkebyNodeUrl = isInfura
  ? "https://rinkeby.infura.io/v3/" + NODE_API_KEY
  : "https://eth-rinkeby.alchemyapi.io/v2/" + NODE_API_KEY;

const mainnetNodeUrl = isInfura
  ? "https://mainnet.infura.io/v3/" + NODE_API_KEY
  : "https://eth-mainnet.alchemyapi.io/v2/" + NODE_API_KEY;

console.log("adsad");
module.exports = {
  networks: {
    development: {
      host: "localhost",
      port: 7545,
      gas: 5000000,
      network_id: "*", // Match any network id
    },
    rinkeby: {
      provider: function () {
        return new HDWalletProvider(MNEMONIC, rinkebyNodeUrl);
      },
      gas: 5000000,
      network_id: 4,
    },
    live: {
      network_id: 1,
      provider: function () {
        return new HDWalletProvider(MNEMONIC, mainnetNodeUrl);
      },
      gas: 5000000,
      gasPrice: 5000000000,
    },
  },
  mocha: {
    reporter: "eth-gas-reporter",
    reporterOptions: {
      currency: "USD",
      gasPrice: 2,
    },
  },
  compilers: {
    solc: {
      version: "^0.8.0",
      settings: {
        optimizer: {
          enabled: true,
          runs: 20   // Optimize for how many times you intend to run the code
        },
      },
    },
  },
  plugins: [
    'truffle-plugin-verify'
  ],
  api_keys: {
    etherscan: 'ETHERSCAN_API_KEY_FOR_VERIFICATION'
  }
};

'''