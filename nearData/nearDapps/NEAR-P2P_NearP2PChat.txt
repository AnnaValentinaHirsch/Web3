*GitHub Repository "NEAR-P2P/NearP2PChat"*

'''--- README.md ---
# Chat_near_dex

## Project setup
```
npm install
```

### Compiles and hot-reloads for development
```
npm run serve
```

### Compiles and minifies for production
```
npm run build
```

### Lints and fixes files
```
npm run lint
```

### Customize configuration
See [Configuration Reference](https://cli.vuejs.org/config/).

------------------------
-------------------------
### Firebase Database Connection

```javascript
const firebaseConfig = {
    apiKey: "AIzaSyCEDG7t9UpmiNWsjPyd_rwucL_s2ppexLk",
    authDomain: "chat-near-dex.firebaseapp.com",
    databaseURL: "https://chat-near-dex-default-rtdb.firebaseio.com",
    projectId: "chat-near-dex",
    storageBucket: "chat-near-dex.appspot.com",
    messagingSenderId: "601318580099",
    appId: "1:601318580099:web:ea212ac3d89f8ef24ae0b6"
  };
```
  
### Database initialization
```javascript
firebase.initializeApp(firebaseConfig)
```

### Anonymous authentication with firebase
```javascript
firebase.auth().onAuthStateChanged(() => new Vue({
  render: h => h(App),
}).$mount('#app'))
```

### Export of libraries
```javascript
export const db = firebase.firestore();
export const storage = firebase.storage();
//export const storage = firebase.firestore();
```

### Authentication with anonymous user

```javascript
<script>
import firebase from 'firebase/compat/app'
import { getAuth, signInAnonymously } from "firebase/auth";
export default {
    data() {
    return {
      user: firebase.auth().currentUser,
      db: firebase.firestore(),
    }
  },
    methods: {
       loginSumit() {
        const auth = getAuth();
        signInAnonymously(auth)
          .then(() => {

          })
       }, 
    }    

 }
</script>
```

 ### Routine to create the chat room
   
 ```javascript
 const room1Ref = db.collection('room1');
 const snapshot = await room1Ref.where('displayName', '==', "NEAR").get();
 this.$refs['scrollable'].scrollIntoView({ behavior: 'smooth' })
 if (snapshot.empty) {

        const messageInfo = {
        'userUID': this.user.uid,
        'displayName': 'NEAR',
        'text': "ATENCION! NO libere las criptomonedas antes de confirmar si el dinero llegÃ³ a su cuenta de pago (balance disponible).",
        'created':0,
      }      
      this.db.collection('room1').add(messageInfo)
      this.db.collection('room1').orderBy('created')
      .onSnapshot(querySnap => {this.messages = querySnap.docs.map(doc => doc.data())})
      this.$refs['scrollable'].scrollIntoView({ behavior: 'smooth' })
      return;  
}
      this.db.collection('room1').orderBy('created')
      .onSnapshot(querySnap => {this.messages = querySnap.docs.map(doc => doc.data())})
      this.$refs['scrollable'].scrollIntoView({ behavior: 'smooth' })

    		  return;
      
  },
```

### Capture the url of the image
 ```javascript
  computed: {
    messagePhoto() {
      return URL.createObjectURL(this.photo);
    }
  },
  ```
  
 ### Capture of the conversation in json format
 
  ```javascript
    async Confirmar() {
      const query = await db
      .collection("room1")
      .where("created", ">",0)
      .orderBy('created')
      .get();

      query.forEach(querySnapshot => 
      console.log(querySnapshot.data()));      
    },   
  ```

### Filtering sending and receiving messages
```javascript
    sentOrReceived(userUID) {
      return userUID === this.user.uid ? 'sent' : 'received'
      
      },
  ```
 
### Send message
```javascript
    async sendMessage(event) {
       event.preventDefault()

        if (this.photo) {

          const timestamp = Date.now();
          const storageRef=firebase.storage().ref(`${timestamp}${this.photo.name}`).put(this.photo);
              storageRef.on(`state_changed`,
              ()=>{
                storageRef.snapshot.ref.getDownloadURL().then((url)=>{
                  this.picture =url;
                  //console.log(url)
                  this.Grabar();
                });
              }
              );

        } else {

          const messageInfo = {
          'userUID': this.user.uid,
          'displayName': 'gperez83.near',
          'photoURL': null,
          'text': this.message,
          'created': Date.now(),
          'room': 'room1'
          }
          await this.db.collection('room1').add(messageInfo)
          this.message = ''
          this.$refs['scrollable'].scrollIntoView({ behavior: 'smooth' })

        }
    },
 ```
 
 ### Record the message
 
 ```javascript
 async Grabar() {      
            const messageInfo = {
            'userUID': this.user.uid,
            'displayName': 'gperez83.near',
            'photoURL': this.picture,
            'text': this.message,
            'created': Date.now(),
            'room': 'room1'
            
          }
          await this.db.collection('room1').add(messageInfo)
          this.message = ''
          this.$refs['scrollable'].scrollIntoView({ behavior: 'smooth' })
          this.photo = null;
   }
```

'''
'''--- babel.config.js ---
module.exports = {
  presets: [
    '@vue/cli-plugin-babel/preset'
  ]
}

'''
'''--- package.json ---
{
  "name": "chat_near_dex",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "serve": "vue-cli-service serve",
    "build": "vue-cli-service build",
    "lint": "vue-cli-service lint"
  },
  "dependencies": {
    "core-js": "^3.6.5",
    "firebase": "^9.6.1",
    "node-sass": "^6.0.1",
    "sass-loader": "^10.2.0",
    "vue": "^2.6.11",
    "vuex": "^3.6.2"
  },
  "devDependencies": {
    "@vue/cli-plugin-babel": "~4.5.0",
    "@vue/cli-plugin-eslint": "~4.5.0",
    "@vue/cli-service": "~4.5.0",
    "babel-eslint": "^10.1.0",
    "eslint": "^6.7.2",
    "eslint-plugin-vue": "^6.2.2",
    "vue-template-compiler": "^2.6.11"
  },
  "eslintConfig": {
    "root": true,
    "env": {
      "node": true
    },
    "extends": [
      "plugin:vue/essential",
      "eslint:recommended"
    ],
    "parserOptions": {
      "parser": "babel-eslint"
    },
    "rules": {}
  },
  "browserslist": [
    "> 1%",
    "last 2 versions",
    "not dead"
  ]
}

'''
'''--- public/index.html ---
<!DOCTYPE html>
<html lang="">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <link rel="icon" href="<%= BASE_URL %>favicon.ico">
    <title><%= htmlWebpackPlugin.options.title %></title>
  </head>
  <body>
    <noscript>
      <strong>We're sorry but <%= htmlWebpackPlugin.options.title %> doesn't work properly without JavaScript enabled. Please enable it to continue.</strong>
    </noscript>
    <div id="app"></div>
    <!-- built files will be auto injected -->
  </body>
</html>

'''
'''--- src/main.js ---
import Vue from 'vue'
import App from './App.vue'
//import firebase from 'firebase'

import firebase from 'firebase/compat/app';
import 'firebase/compat/auth';
import 'firebase/compat/firestore';
import 'firebase/compat/storage';

// Conexion a la Base de datos Firebase 
const firebaseConfig = {
    apiKey: "AIzaSyCEDG7t9UpmiNWsjPyd_rwucL_s2ppexLk",
    authDomain: "chat-near-dex.firebaseapp.com",
    databaseURL: "https://chat-near-dex-default-rtdb.firebaseio.com",
    projectId: "chat-near-dex",
    storageBucket: "chat-near-dex.appspot.com",
    messagingSenderId: "601318580099",
    appId: "1:601318580099:web:ea212ac3d89f8ef24ae0b6"
  };

  //Inicializacion de la base de datos
firebase.initializeApp(firebaseConfig)

// Autentificacion de manera anonima con firebase
firebase.auth().onAuthStateChanged(() => new Vue({
  render: h => h(App),
}).$mount('#app'))

// Exportacion de las librerias
export const db = firebase.firestore();
export const storage = firebase.storage();
//export const storage = firebase.firestore();
'''
'''--- src/store/index.js ---
import Vue from "vue";
import Vuex from "vuex";

import messages from "./messages";
import rooms from "./rooms";
import user from "./user";
import utils from "./utils";

import { auth } from "../firebase.js";

Vue.use(Vuex);

const store = new Vuex.Store({
  state: {
    isLoading: true
  },
  mutations: {
    setLoading(state, loading) {
      state.isLoading = loading;
    }
  },
  actions: {
    checkAuth({ dispatch, commit }) {
      auth.onAuthStateChanged(async function(user) {
        if (user) {
          commit("user/setUser", user);
          try {
            await dispatch("user/getMeta");
            await dispatch("rooms/getRooms");
            await dispatch("messages/getMessages");
          } catch (error) {
            console.error(error.message);
            this.$toast.error(error.message);
          }
        } else {
          commit("user/setMeta", {});
          commit("user/setUserListener", () => {});

          commit("rooms/setRooms", []);
          commit("rooms/setRoomsListener", () => {});

          commit("messages/setMessages", []);
          commit("messages/setMessagesListener", () => {});

          commit("user/setUser", null);
        }
      });
    }
  },
  modules: {
    messages,
    rooms,
    user,
    utils
  }
});

export default store;

// Initial load
store.dispatch("checkAuth");

'''
'''--- src/store/messages.js ---
import { db, storage } from "../firebase.js";

const state = {
  messages: [],
  messagesListener: () => {},
  filters: [
    { name: "normal" },
    { name: "clarendon" },
    { name: "gingham" },
    { name: "moon" },
    { name: "lark" },
    { name: "reyes" },
    { name: "juno" },
    { name: "slumber" },
    { name: "aden" },
    { name: "perpetua" },
    { name: "mayfair" },
    { name: "rise" },
    { name: "hudson" },
    { name: "valencia" },
    { name: "xpro2" },
    { name: "willow" },
    { name: "lofi" },
    { name: "inkwell" },
    { name: "nashville" }
  ]
};

const getters = {};

const mutations = {
  setMessages(state, messages) {
    state.messages = messages;
  },
  setMessagesListener(state, listener) {
    if (listener) {
      state.listener = listener;
    } else {
      state.messagesListener();
    }
  }
};

const actions = {
  async getMessages({ commit }) {
    const query = db
      .collectionGroup("messages")
      .orderBy("createdAt", "desc")
      .onSnapshot(doSnapShot);

    commit("setMessagesListener", query);

    function doSnapShot(querySnapshot) {
      const messages = [];
      querySnapshot.forEach(doc => {
        let message = doc.data();
        message.id = doc.id;
        messages.unshift(message);
      });

      commit("setMessages", messages);
    }
  },

  async uploadMessageFile({ rootGetters }, { roomID, file, type }) {
    const timestamp = Date.now();
    const userUID = rootGetters["user/getUserUid"];
    let ext;
    const metadata = {};

    if (type === "photo") {
      ext = "jpg";
      metadata.contentType = "image/jpeg";
    } else {
      ext = "wav";
      metadata.contentType = "audio/wav";
    }

    const uploadPhoto = () => {
      let fileName = `rooms/${roomID}/messages/${userUID}-${timestamp}.${ext}`;
      return storage.ref(fileName).put(file, metadata);
    };

    function getDownloadURL(ref) {
      return ref.getDownloadURL();
    }

    try {
      let upload = await uploadPhoto();
      return await getDownloadURL(upload.ref);
    } catch (error) {
      throw Error(error.message);
    }
  },

  async createMessage(
    { rootState },
    { roomID, message, photo, filter, audio }
  ) {
    await db
      .collection("rooms")
      .doc(roomID)
      .collection("messages")
      .add({
        userId: rootState.user.user.uid,
        userName: rootState.user.user.displayName,
        roomId: roomID,
        message,
        photo,
        filter,
        audio,
        createdAt: Date.now()
      });
  },

  async deleteFile(context, file) {
    const fileRef = storage.refFromURL(file);
    await fileRef.delete();
  },

  async deleteMessage(context, { roomID, messageID }) {
    await db
      .collection("rooms")
      .doc(roomID)
      .collection("messages")
      .doc(messageID)
      .delete();
  }
};

export default {
  namespaced: true,
  state,
  getters,
  actions,
  mutations
};

'''
'''--- src/store/rooms.js ---
import { db, storage } from "../firebase";

const state = {
  rooms: [],
  roomsListener: () => {}
};

const getters = {
  getRoom: state => id => {
    return state.rooms.find(room => room.id === id);
  },
  roomsByDate: state => {
    return state.rooms.sort(function(a, b) {
      return new Date(b.createdAt) - new Date(a.createdAt);
    });
  }
};

const mutations = {
  setRoomsListener(state, listener) {
    if (listener) {
      state.roomsListener = listener;
    } else {
      state.roomsListener();
    }
  },
  setRooms(state, rooms) {
    state.rooms = rooms;
  },
  createRoom(state, { roomData, id }) {
    roomData.id = id;
    state.rooms.push(roomData);
  },
  updateRoom(state, { index, roomData, id }) {
    roomData.id = id;
    state.rooms[index] = roomData;
  },
  removeRoom(state, index) {
    state.rooms.splice(index, 1);
  }
};

const actions = {
  getNewRoomId() {
    return db.collection("rooms").doc();
  },

  async uploadRoomImage(context, { roomID, file }) {
    const uploadPhoto = () => {
      let fileName = `rooms/${roomID}/${roomID}-image.jpg`;
      return storage.ref(fileName).put(file);
    };

    function getDownloadURL(ref) {
      return ref.getDownloadURL();
    }

    try {
      let upload = await uploadPhoto();
      return await getDownloadURL(upload.ref);
    } catch (error) {
      throw Error(error.message);
    }
  },

  async createRoom({ rootState }, { name, description, image, roomID }) {
    await db
      .collection("rooms")
      .doc(roomID)
      .set({
        name,
        description,
        createdAt: Date.now(),
        adminUid: rootState.user.user.uid,
        adminName: rootState.user.user.displayName,
        image
      });
  },

  async getRooms({ commit }) {
    const query = db
      .collection("rooms")
      .orderBy("createdAt", "desc")
      .onSnapshot(doSnapshot);

    commit("setRoomsListener", query);

    function doSnapshot(querySnapshot) {
      commit("setLoading", true, { root: true });

      querySnapshot.docChanges().forEach(change => {
        if (change.type === "added") {
          commit("createRoom", {
            roomData: change.doc.data(),
            id: change.doc.id
          });
        }

        if (change.type === "modified") {
          commit("updateRoom", {
            index: change.newIndex,
            roomData: change.doc.data(),
            id: change.doc.id
          });
        }

        if (change.type === "removed") {
          commit("removeRoom", change.oldIndex);
        }
      });

      commit("setLoading", false, { root: true });
    }
  },

  async getRoom({ getters }, roomID) {
    // Grab from local state
    let room = getters["getRoom"](roomID);
    if (!room) {
      // Grab from Cloud Firestore ð¥
      room = await db
        .collection("rooms")
        .doc(roomID)
        .get();

      if (!room.exists) throw new Error("Could not find room");
      room = room.data();
    }

    return room;
  },

  async updateRoom(context, { roomID, name, description, image }) {
    const roomData = {};

    if (name) roomData.name = name;

    if (description) roomData.description = description;

    roomData.image = image;

    await db
      .collection("rooms")
      .doc(roomID)
      .update(roomData);
  },

  async removeRoom(context, roomID) {
    const room = db.collection("rooms").doc(roomID);
    const messages = room.collection("messages").onSnapshot(doSnapshot);

    async function doSnapshot(snapshot) {
      snapshot.docs.forEach(async doc => {
        await room
          .collection("messages")
          .doc(doc.id)
          .delete();
      });

      messages(); // Unsub

      await room.delete();
    }
  }
};

export default {
  namespaced: true,
  state,
  getters,
  actions,
  mutations
};

'''
'''--- src/store/user.js ---
import { auth, db, firebase } from "../firebase.js";
const state = {
  user: null,
  meta: {},
  userListener: () => {}
};

const getters = {
  getUserUid(state) {
    return state.user.uid;
  }
};

const mutations = {
  setUser(state, user) {
    state.user = user;
  },
  setMeta(state, meta) {
    state.meta = meta;
  },
  setUserListener(state, listener) {
    if (listener) {
      state.userListener = listener;
    } else {
      state.userListener();
    }
  }
};

const actions = {
  getCurrentUser() {
    return new Promise((resolve, reject) => {
      const unsubscribe = auth.onAuthStateChanged(
        user => {
          unsubscribe();
          resolve(user);
        },
        () => {
          reject();
        }
      );
    });
  },

  async updateMeta(context, { roomID, exit, uid }) {
    const ref = db.collection("users").doc(uid);
    const userDoc = await ref.get();

    if (!userDoc.exists) await ref.set({});

    const method = exit ? "arrayRemove" : "arrayUnion";
    await ref.update({
      connected: firebase.firestore.FieldValue[method](roomID),
      [`joined.${roomID}`]: Date.now()
    });
  },

  async getMeta({ state, commit }) {
    const ref = db.collection("users").doc(state.user.uid);

    await ref.update({ connected: [] });

    const query = ref.onSnapshot(doSnapshot);

    commit("setUserListener", query);

    function doSnapshot(doc) {
      commit("setMeta", doc.data());
    }
  },

  async updateProfile({ commit, state }, { name, email, password }) {
    const user = auth.currentUser;

    if (name) {
      await user.updateProfile({
        displayName: name
      });

      db.runTransaction(async transaction => {
        const query = await db
          .collectionGroup("messages")
          .where("userId", "==", state.user.uid)
          .get();

        query.forEach(doc => {
          transaction.update(doc.ref, { userName: name });
        });
      });
    }

    if (email) {
      await user.updateEmail(email);
    }

    if (password) {
      await user.updatePassword(password);
    }

    commit("setUser", user);
  },
  async doLogin({ commit }, { email, password }) {
    await auth.signInWithEmailAndPassword(email, password);
    commit("setUser", auth.currentUser);
  },
  async doRegister({ commit }, { name, email, password }) {
    await auth.createUserWithEmailAndPassword(email, password);
    const user = auth.currentUser;
    await user.updateProfile({
      displayName: name
    });
    commit("setUser", user);
  },
  async doLogout() {
    await auth.signOut();
  },
  async doReset(context, email) {
    await auth.sendPasswordResetEmail(email);
  }
};

export default {
  namespaced: true,
  state,
  getters,
  actions,
  mutations
};

'''
'''--- src/store/utils.js ---
import Vue from "vue";

const actions = {
  requestConfirmation(context, { props, component }) {
    const Component = () => import(`../components/${component}Component.vue`);
    return new Promise((resolve, reject) => {
      const dialog = new Vue({
        methods: {
          actionHandler(fn, arg) {
            return function() {
              fn(arg);
              dialog.$destroy();
              dialog.$el.remove();
            };
          }
        },
        render(h) {
          return h(Component, {
            props,
            on: {
              confirm: data => {
                this.actionHandler(resolve, data)();
              },
              cancel: this.actionHandler(reject, new Error("Action cancelled"))
            }
          });
        }
      }).$mount();
      document.getElementById("app").appendChild(dialog.$el);
    });
  }
};

export default {
  namespaced: true,
  actions
};

'''