*GitHub Repository "MetaBUILD-III/MetaBUILD_III_contracts"*

'''--- Cargo.toml ---
[package]
name = "limit-orders"
version = "0.0.2"
authors = ["mark.ts@blaize.tech", "tymofii.s@blaize.tech", "dmytro.sh@blaize.tech"]
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0"
near-contract-standards = "4.0.0"
uint = { version = "=0.9.0", default-features = false }
borsh = "0.9.3"
'''
'''--- README.md ---
# Leverage trading over concentrated liquidity

Omomo leverage trading is a leverage trading protocol which utilizes feature of [concentrated liquidty](https://docs.uniswap.org/protocol/concepts/V3-overview/concentrated-liquidity) from [ref.finance](https://ref-finance.medium.com/ref-v2-unlock-concentrated-liquidity-for-better-capital-efficiency-8a63e3c33f5b) and lending borrowing feature of [Omomo lending](https://omomo.gitbook.io/omomo/product/borrow).

## Demo
* Faucet [here](https://qa.d32fiqfhpe57s4.amplifyapp.com/faucet)
* Omomo leverage trading [here](https://main.doa1qum5oc2tn.amplifyapp.com/pairs)
* Corresponding ref.finance V2 liqudity pool [here](https://testnet.ref-finance.com/poolV2/usdt.qa.v1.nearlend.testnet@wnear.qa.v1.nearlend.testnet@2000)

## How it works

### Buy/sell order
First step is Deposit
<details>
<summary>Diagramm</summary>
  
![Omomo - Deposit flow](https://user-images.githubusercontent.com/91728093/202552957-18ba9937-84ea-4e12-a034-202520461b9b.jpg)

</details>
  
Once user have deposited `Sell token` it may borrow required assets, if it chooses to trade with leverage, and create limit order to buy exact amount of `Buy token` at current market price. That where we interact with ref.finance V2 concentrated liquidity feature. It allow us to provide liquidity to the pool at concrete range and wait until market croses that range so whole liquidity is converted from `Sell token` to `Buy token` without paying `Swap fee` and rely on `Slippage tolerance`. Furthermore any operations over our liquidity provides us with additional income equal to pool fee.
<details>
<summary>NOTE</summary>

Right now everything done in one call executed by `open position`

</details>

Once order is created you should see it listed under trading view

<details>
<summary>Diagramm</summary>
  
![Omomo - Create order flow](https://user-images.githubusercontent.com/91728093/202553444-06ac762c-47db-4c7a-8f8f-fb8e33c566f4.jpg)

</details>

### Execute position & Close position

Once order is created it coud be automatically handled by `Executor` when the order is fulfilled. Once order is executed you now may either create `Take profit order` or `Cancel` the position. 

* [not yet implemented] `Take profit order` is counterpart action to opening position, Leverage trading will create limit order at desired price which will be fulfilled once market hit this price and proccessed by executor the same way as open position
* `Cancel` position allows you to immediately swap your `Sell token` at the current market price and could by used to prevent loss or take profit once you satisfied with the PnL

<details>
<summary>Diagramm</summary>
  
![Omomo - Execute order flow](https://user-images.githubusercontent.com/91728093/202554598-6102cc9b-f059-4f9e-b57d-4dd37efa196d.jpg)
![Omomo - Cancel order flow](https://user-images.githubusercontent.com/91728093/202560845-6a3e2781-56a3-4192-946c-45eb7d0bb06a.jpg)
![Omomo - Take profit order flow](https://user-images.githubusercontent.com/91728093/202560868-34de50da-3ea2-42e9-8057-acc834c9caed.jpg)

  
</details>

### Liquidate position 

<details>
<summary>Diagramm</summary>

![Omomo - Liquidate order flow](https://user-images.githubusercontent.com/91728093/202560985-05edd4f9-3c30-44de-97be-e00a22a80d48.jpg)
  
</details>

# Roadmap

'''
'''--- build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --manifest-path ./Cargo.toml --target wasm32-unknown-unknown --release
cp ./target/wasm32-unknown-unknown/release/*.wasm ./res/

'''
'''--- close_position_flow.sh ---
near call margin.nearlend.testnet set_price '{ "market_id": "wnear.qa.nearlend.testnet", "price": {"value": "5090000000000000000000000", "fraction_digits": 24} }' --accountId nearlend.testnet
near view margin.nearlend.testnet get_price_by_token '{ "token_id": "wnear.qa.nearlend.testnet" }'

near call margin.nearlend.testnet set_pool_id '{"pool_id": "1744"}' --accountId margin.nearlend.testnet --gas 300000000000000

# near call margin.nearlend.testnet close_position '{"position_id": "0"}' --accountId nearlend.testnet --gas 300000000000000

'''
'''--- create_order_flow.sh ---
near call usdt.qa.v1.nearlend.testnet ft_transfer_call '{"receiver_id": "limit_orders.v1.nearlend.testnet", "amount": "10000000", "msg": "{\"Deposit\": {\"token\": \"usdt.qa.v1.nearlend.testnet\"}}"}' --accountId nearlend.testnet --depositYocto 1 --gas 300000000000000

near call dcl.ref-dev.testnet storage_deposit '{"account_id": "limit_orders.v1.nearlend.testnet"}' --accountId nearlend.testnet --amount 1

near view limit_orders.v1.nearlend.testnet balance_of '{"account_id": "nearlend.testnet", "token": "usdt.qa.v1.nearlend.testnet" }' &

wait

near call limit_orders.v1.nearlend.testnet create_order '{"order_type": "Buy", "amount": "10000000", "sell_token": "usdt.qa.v1.nearlend.testnet", "buy_token": "wnear.qa.v1.nearlend.testnet", "leverage": "1"}' --accountId nearlend.testnet --gas 300000000000000

# make sure lpt id is valid
near view limit_orders.v1.nearlend.testnet view_orders '{    "account_id":"nearlend.testnet ",
                                                          "buy_token":"wnear.qa.v1.nearlend.testnet",
                                                          "sell_token":"usdt.qa.v1.nearlend.testnet"}'

'''
'''--- deploy.sh ---
# login
#near login

# build & test
mkdir -p res && ./build.sh && ./test.sh

CONTRACT_ADDRESS=leverage_omomo.testnet

# clean up previuos deployment
# echo 'y' | near delete ${CONTRACT_ADDRESS} v1.nearlend.testnet

# create corresponding accoutns
# near create-account ${CONTRACT_ADDRESS} --masterAccount v1.nearlend.testnet --initialBalance 10

# redeploy contracts
near deploy ${CONTRACT_ADDRESS} \
    --wasmFile ./res/limit_orders.wasm
#   --wasmFile ./res/limit_orders.wasm \
#   --initFunction 'new_with_config' \
#   --initArgs '{
#         "owner_id":"'${CONTRACT_ADDRESS}'",
#         "oracle_account_id":"limit_orders_oracle.v1.nearlend.testnet"
#     }'

# register limit orders on tokens
near call wnear.qa.v1.nearlend.testnet storage_deposit '{"account_id": "'${CONTRACT_ADDRESS}'"}' --accountId ${CONTRACT_ADDRESS} --amount 0.25 &
near call usdt.qa.v1.nearlend.testnet storage_deposit '{"account_id": "'${CONTRACT_ADDRESS}'"}' --accountId ${CONTRACT_ADDRESS} --amount 0.25 &
wait

# add supported pairs
near call ${CONTRACT_ADDRESS} add_pair '{
        "pair_data": {
            "sell_ticker_id": "USDt",
            "sell_token": "usdt.qa.v1.nearlend.testnet",
            "sell_token_market": "usdt_market.qa.v1.nearlend.testnet",
            "buy_ticker_id": "near",
            "buy_token": "wnear.qa.v1.nearlend.testnet",
            "pool_id": "usdt.qa.v1.nearlend.testnet|wnear.qa.v1.nearlend.testnet|2000"
        }
    }' --accountId ${CONTRACT_ADDRESS} &

near call ${CONTRACT_ADDRESS} add_pair '{
        "pair_data": {
            "sell_ticker_id": "near",
            "sell_token": "wnear.qa.v1.nearlend.testnet",
            "sell_token_market": "wnear_market.qa.v1.nearlend.testnet",
            "buy_ticker_id": "USDt",
            "buy_token": "usdt.qa.v1.nearlend.testnet",
            "pool_id": "usdt.qa.v1.nearlend.testnet|wnear.qa.v1.nearlend.testnet|2000"
        }
    }' --accountId ${CONTRACT_ADDRESS} &

# near view ${CONTRACT_ADDRESS} view_supported_pairs '{}'

# add mock prices
near call ${CONTRACT_ADDRESS} update_or_insert_price '{
    "token_id":"usdt.qa.v1.nearlend.testnet",
    "price":{
        "ticker_id":"USDt",
        "value":"1.01"
    }
}' --accountId ${CONTRACT_ADDRESS} &

near call ${CONTRACT_ADDRESS} update_or_insert_price '{
    "token_id":"wnear.qa.v1.nearlend.testnet",
    "price":{
        "ticker_id":"near",
        "value":"1.83"
    }
}' --accountId ${CONTRACT_ADDRESS} &

near view ${CONTRACT_ADDRESS} view_price '{"token_id":"usdt.qa.v1.nearlend.testnet"}'
near view ${CONTRACT_ADDRESS} view_price '{"token_id":"wnear.qa.v1.nearlend.testnet"}'

# add mock orders
# near call ${CONTRACT_ADDRESS} add_order '{
#         "account_id":"tommylinks.testnet",
#         "order":"{\"status\":\"Executed\",\"order_type\":\"Buy\",\"amount\":1000000100000000000000000000,\"sell_token\":\"usdt.qa.v1.nearlend.testnet\",\"buy_token\":\"wnear.qa.v1.nearlend.testnet\",\"leverage\":\"2.5\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1.01\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"4.22\"},\"block\":103930916,\"lpt_id\":\"1\"}"
#     }' --accountId ${CONTRACT_ADDRESS} &

# near call ${CONTRACT_ADDRESS} add_order '{
#         "account_id":"tommylinks.testnet",
#         "order":"{\"status\":\"Pending\",\"order_type\":\"Buy\",\"amount\":1000001100000000000000000000,\"sell_token\":\"usdt.qa.v1.nearlend.testnet\",\"buy_token\":\"wnear.qa.v1.nearlend.testnet\",\"leverage\":\"1.5\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1.01\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"3.01\"},\"block\":103930917,\"lpt_id\":\"2\"}"
#     }' --accountId ${CONTRACT_ADDRESS} &

# near call ${CONTRACT_ADDRESS} add_order '{
#         "account_id":"tommylinks.testnet",
#         "order":"{\"status\":\"Canceled\",\"order_type\":\"Buy\",\"amount\":2000001100000000000000000000,\"sell_token\":\"usdt.qa.v1.nearlend.testnet\",\"buy_token\":\"wnear.qa.v1.nearlend.testnet\",\"leverage\":\"1.0\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"0.99\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"3.99\"},\"block\":103930918,\"lpt_id\":\"3\"}"
#     }' --accountId ${CONTRACT_ADDRESS} &

# near call ${CONTRACT_ADDRESS} add_order '{
#         "account_id":"nearlend.testnet",
#         "order":"{\"status\":\"Executed\",\"order_type\":\"Buy\",\"amount\":1000000100000000000000000000,\"sell_token\":\"usdt.qa.v1.nearlend.testnet\",\"buy_token\":\"wnear.qa.v1.nearlend.testnet\",\"leverage\":\"2.5\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1.01\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"4.22\"},\"block\":103930916,\"lpt_id\":\"1\"}"
#     }' --accountId ${CONTRACT_ADDRESS} &

# near call ${CONTRACT_ADDRESS} add_order '{
#         "account_id":"nearlend.testnet",
#         "order":"{\"status\":\"Pending\",\"order_type\":\"Buy\",\"amount\":1000001100000000000000000000,\"sell_token\":\"usdt.qa.v1.nearlend.testnet\",\"buy_token\":\"wnear.qa.v1.nearlend.testnet\",\"leverage\":\"1.5\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1.01\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"3.01\"},\"block\":103930917,\"lpt_id\":\"2\"}"
#     }' --accountId ${CONTRACT_ADDRESS} &

# near call ${CONTRACT_ADDRESS} add_order '{
#         "account_id":"nearlend.testnet",
#         "order":"{\"status\":\"Canceled\",\"order_type\":\"Buy\",\"amount\":2000001100000000000000000000,\"sell_token\":\"usdt.qa.v1.nearlend.testnet\",\"buy_token\":\"wnear.qa.v1.nearlend.testnet\",\"leverage\":\"1.0\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"0.99\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"3.99\"},\"block\":103930918,\"lpt_id\":\"3\"}"
#     }' --accountId ${CONTRACT_ADDRESS} &

# setup pool
near call dcl.ref-dev.testnet storage_deposit '{"account_id": "'${CONTRACT_ADDRESS}'"}' --accountId nearlend.testnet --amount 1 &

near call ${CONTRACT_ADDRESS} add_token_market '{"token_id": "wnear.qa.v1.nearlend.testnet", "market_id": "wnear_market.qa.v1.nearlend.testnet"}' --account_id ${CONTRACT_ADDRESS} &
near call ${CONTRACT_ADDRESS} add_token_market '{"token_id": "usdt.qa.v1.nearlend.testnet", "market_id": "usdt_market.qa.v1.nearlend.testnet"}' --account_id ${CONTRACT_ADDRESS} &

near call usdt_market.qa.v1.nearlend.testnet set_eligible_to_borrow_uncollateralized_account '{ "account": "'${CONTRACT_ADDRESS}'" }' --accountId shared_admin.testnet
near view usdt_market.qa.v1.nearlend.testnet get_eligible_to_borrow_uncollateralized_account '{ "account": "'${CONTRACT_ADDRESS}'" }'

near call controller.qa.v1.nearlend.testnet set_eligible_to_borrow_uncollateralized_account '{ "account": "'${CONTRACT_ADDRESS}'" }' --accountId controller.qa.v1.nearlend.testnet
near view controller.qa.v1.nearlend.testnet get_eligible_to_borrow_uncollateralized_account '{ "account": "'${CONTRACT_ADDRESS}'" }'

wait

'''
'''--- src/big_decimal.rs ---
use crate::*;
use near_sdk::borsh::maybestd::io::Write;
use near_sdk::json_types::U128;
use near_sdk::serde::{Deserialize, Serialize, Serializer};
use std::cmp::{max_by, min_by, Ordering};
use std::fmt::{Display, Formatter};
use std::ops::{Add, Div, Mul, Sub};
use std::str::FromStr;

uint::construct_uint!(
    pub struct U384(6);
);

pub type WBigDecimal = U128;
pub type WBalance = U128;
pub type WRatio = U128;

pub(crate) const MAX_RATIO: u32 = 10000;

pub const NUM_DECIMALS: u8 = 24;
const BIG_DIVISOR: u128 = 10u128.pow(NUM_DECIMALS as u32);
const HALF_DIVISOR: u128 = BIG_DIVISOR / 2;

pub type LowU128 = U128;

#[derive(Copy, Clone)]
pub struct BigDecimal(pub U384);

impl Default for BigDecimal {
    fn default() -> Self {
        BigDecimal::zero()
    }
}

impl Display for BigDecimal {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        let a = self.0 / U384::from(BIG_DIVISOR);
        let b = (self.0 - a * U384::from(BIG_DIVISOR)).as_u128();
        if b > 0 {
            write!(f, "{}", format!("{}.{:024}", a, b).trim_end_matches('0'))
        } else {
            write!(f, "{}.0", a)
        }
    }
}

impl std::fmt::Debug for BigDecimal {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self)
    }
}

const PARSE_INT_ERROR: &str = "Parse int error";

impl FromStr for BigDecimal {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let dot_pos = s.find('.');
        let (int, dec) = if let Some(dot_pos) = dot_pos {
            (
                &s[..dot_pos],
                format!("{:0<24}", &s[dot_pos + 1..])
                    .parse()
                    .map_err(|_| PARSE_INT_ERROR)?,
            )
        } else {
            (s, 0u128)
        };
        let int = U384::from_str(int).map_err(|_| PARSE_INT_ERROR)?;
        if dec >= BIG_DIVISOR {
            return Err(String::from("The decimal part is too large"));
        }
        Ok(Self(int * U384::from(BIG_DIVISOR) + U384::from(dec)))
    }
}

impl Serialize for BigDecimal {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(&self.to_string())
    }
}

impl<'de> Deserialize<'de> for BigDecimal {
    fn deserialize<D>(
        deserializer: D,
    ) -> Result<Self, <D as near_sdk::serde::Deserializer<'de>>::Error>
    where
        D: near_sdk::serde::Deserializer<'de>,
    {
        let s: String = Deserialize::deserialize(deserializer)?;
        Self::from_str(&s).map_err(near_sdk::serde::de::Error::custom)
    }
}

impl From<u128> for BigDecimal {
    fn from(a: u128) -> Self {
        Self(U384::from(a) * U384::from(BIG_DIVISOR))
    }
}

impl From<u64> for BigDecimal {
    fn from(a: u64) -> Self {
        Self(U384::from(a) * U384::from(BIG_DIVISOR))
    }
}

impl From<u32> for BigDecimal {
    fn from(a: u32) -> Self {
        Self(U384::from(a) * U384::from(BIG_DIVISOR))
    }
}

impl From<i32> for BigDecimal {
    fn from(a: i32) -> Self {
        Self(U384::from(a) * U384::from(BIG_DIVISOR))
    }
}

impl From<f64> for BigDecimal {
    fn from(a: f64) -> Self {
        let base = a as u128;
        Self(
            U384::from(base) * U384::from(BIG_DIVISOR)
                + U384::from((a.fract() * (BIG_DIVISOR as f64)) as u128),
        )
    }
}

impl Add for BigDecimal {
    type Output = Self;

    fn add(self, rhs: BigDecimal) -> Self::Output {
        Self(self.0 + rhs.0)
    }
}

impl Sub for BigDecimal {
    type Output = Self;

    fn sub(self, rhs: BigDecimal) -> Self::Output {
        Self(self.0 - rhs.0)
    }
}

impl Mul for BigDecimal {
    type Output = Self;

    fn mul(self, rhs: Self) -> Self::Output {
        Self((self.0 * rhs.0 + U384::from(HALF_DIVISOR)) / U384::from(BIG_DIVISOR))
    }
}

impl Div for BigDecimal {
    type Output = Self;

    fn div(self, rhs: Self) -> Self::Output {
        Self((self.0 * U384::from(BIG_DIVISOR) + U384::from(HALF_DIVISOR)) / rhs.0)
    }
}

impl From<LowU128> for BigDecimal {
    fn from(low_u128: LowU128) -> Self {
        Self(U384::from(low_u128.0))
    }
}

impl From<BigDecimal> for LowU128 {
    fn from(bd: BigDecimal) -> Self {
        Self(bd.0.low_u128())
    }
}

impl BigDecimal {
    pub fn from_ratio(ratio: u32) -> Self {
        Self(U384::from(ratio) * U384::from(BIG_DIVISOR / (MAX_RATIO as u128)))
    }

    pub fn mul_ratio(&self, ratio: u32) -> Self {
        Self((self.0 * U384::from(ratio) + U384::from(MAX_RATIO / 2)) / U384::from(MAX_RATIO))
    }

    pub fn div_ratio(&self, ratio: u32) -> Self {
        Self((self.0 * U384::from(MAX_RATIO) + U384::from(MAX_RATIO / 2)) / U384::from(ratio))
    }

    pub fn round_u128(&self) -> u128 {
        ((self.0 + U384::from(HALF_DIVISOR)) / U384::from(BIG_DIVISOR)).as_u128()
    }

    #[cfg(not(target_arch = "wasm32"))]
    pub fn f64(&self) -> f64 {
        let base = (self.0 / U384::from(BIG_DIVISOR)).as_u128();
        let fract = (self.0 - U384::from(base)).as_u128() as f64;
        base as f64 + fract / (BIG_DIVISOR as f64)
    }

    pub fn round_mul_u128(&self, rhs: u128) -> u128 {
        ((self.0 * U384::from(rhs) + U384::from(HALF_DIVISOR)) / U384::from(BIG_DIVISOR)).as_u128()
    }

    pub fn div_u128(&self, rhs: u128) -> BigDecimal {
        Self(self.0 / U384::from(rhs))
    }

    pub fn zero() -> Self {
        Self(U384::zero())
    }

    pub fn one() -> Self {
        Self(U384::from(BIG_DIVISOR))
    }

    pub fn pow(&self, mut exponent: u64) -> Self {
        let mut res = BigDecimal::one();
        let mut x = *self;

        while exponent != 0 {
            if (exponent & 1) != 0 {
                res = res * x;
            }
            exponent >>= 1;
            if exponent != 0 {
                x = x * x;
            }
        }

        res
    }
}

impl PartialEq<Self> for BigDecimal {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}

impl PartialOrd for BigDecimal {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        self.0.partial_cmp(&other.0)
    }
}

impl Eq for BigDecimal {}

impl Ord for BigDecimal {
    fn cmp(&self, other: &Self) -> Ordering {
        self.0.cmp(&other.0)
    }

    fn max(self, other: Self) -> Self
    where
        Self: Sized,
    {
        max_by(self, other, Ord::cmp)
    }

    fn min(self, other: Self) -> Self
    where
        Self: Sized,
    {
        min_by(self, other, Ord::cmp)
    }

    fn clamp(self, min: Self, max: Self) -> Self
    where
        Self: Sized,
    {
        assert!(min <= max);
        if self < min {
            min
        } else if self > max {
            max
        } else {
            self
        }
    }
}

impl BorshSerialize for BigDecimal {
    fn serialize<W: Write>(&self, writer: &mut W) -> std::io::Result<()> {
        BorshSerialize::serialize(&self.0 .0, writer)
    }
}

impl BorshDeserialize for BigDecimal {
    fn deserialize(buf: &mut &[u8]) -> std::io::Result<Self> {
        Ok(Self(U384(BorshDeserialize::deserialize(buf)?)))
    }
}

#[cfg(test)]
mod test {
    use std::str::FromStr;

    use crate::big_decimal::BigDecimal;
    use crate::big_decimal::LowU128;

    #[test]
    fn should_be_one_percent() {
        let one_percent = LowU128::from(10000000000000000000000u128);

        assert_eq!(
            BigDecimal::from(one_percent),
            BigDecimal::one() / BigDecimal::from(100u128)
        );
    }

    #[test]
    fn should_be_ten() {
        let ten = BigDecimal::from(10u128) * BigDecimal::one();

        assert_eq!(ten, BigDecimal::from(10u128));
    }

    #[test]
    fn should_be_0_0000000628() {
        assert_eq!(
            BigDecimal::from(LowU128::from(62800000000000000u128)),
            BigDecimal::from_str("0.0000000628").unwrap()
        );
    }
}

'''
'''--- src/cancel_order.rs ---
use crate::big_decimal::{BigDecimal, WRatio};
use crate::ref_finance::ext_ref_finance;
use crate::ref_finance::{Action, Swap};
use crate::utils::NO_DEPOSIT;
use crate::utils::{ext_market, ext_token};
use crate::*;
use near_sdk::env::{block_height, current_account_id, signer_account_id};
use near_sdk::{ext_contract, is_promise_success, log, Gas, PromiseResult, ONE_YOCTO};

#[ext_contract(ext_self)]
trait ContractCallbackInterface {
    fn remove_liquidity_callback(
        &self,
        order_id: U128,
        order: Order,
        swap_fee: U128,
        price_impact: U128,
        order_action: OrderAction,
    );
    fn order_cancel_swap_callback(
        &self,
        order_id: U128,
        order: Order,
        swap_fee: U128,
        price_impact: U128,
        order_action: OrderAction,
    );
    fn market_data_callback(
        &self,
        order_id: U128,
        order: Order,
        swap_fee: U128,
        price_impact: U128,
        order_action: OrderAction,
    );
    fn get_pool_callback(
        &self,
        order_id: U128,
        order: Order,
        swap_fee: U128,
        price_impact: U128,
        order_action: OrderAction,
    );
    fn get_liquidity_callback(
        &self,
        order_id: U128,
        order: Order,
        swap_fee: U128,
        price_impact: U128,
        order_action: OrderAction,
        pool_info: PoolInfo,
    );
    fn repay_callback(&self) -> PromiseOrValue<U128>;
}

#[near_bindgen]
impl Contract {
    pub fn cancel_order(&mut self, order_id: U128, swap_fee: U128, price_impact: U128) {
        let orders = self.orders.get(&signer_account_id()).unwrap_or_else(|| {
            panic!("Orders for account: {} not found", signer_account_id());
        });

        let order = orders
            .get(&(order_id.0 as u64))
            .unwrap_or_else(|| {
                panic!("Order with id: {} not found", order_id.0);
            })
            .clone();
        ext_ref_finance::ext(self.ref_finance_account.clone())
            .with_unused_gas_weight(1)
            .with_attached_deposit(NO_DEPOSIT)
            .get_pool(self.view_pair(&order.sell_token, &order.buy_token).pool_id)
            .then(
                ext_self::ext(current_account_id())
                    .with_unused_gas_weight(29)
                    .with_attached_deposit(NO_DEPOSIT)
                    .get_pool_callback(
                        order_id,
                        order,
                        swap_fee,
                        price_impact,
                        OrderAction::Cancel,
                    ),
            );
    }

    #[private]
    pub fn get_pool_callback(
        &mut self,
        order_id: U128,
        order: Order,
        swap_fee: U128,
        price_impact: U128,
        order_action: OrderAction,
    ) {
        require!(
            is_promise_success(),
            "Some problem with pool on ref finance"
        );
        let pool_info = match env::promise_result(0) {
            PromiseResult::NotReady => unreachable!(),
            PromiseResult::Successful(val) => {
                if let Ok(pool) = near_sdk::serde_json::from_slice::<PoolInfo>(&val) {
                    pool
                } else {
                    panic!("Some problem with pool parsing.")
                }
            }
            PromiseResult::Failed => panic!("Ref finance not found pool"),
        };

        require!(
            pool_info.state == PoolState::Running,
            "Some problem with pool, please contact with ref finance to support."
        );

        if order.status == OrderStatus::Pending {
            ext_ref_finance::ext(self.ref_finance_account.clone())
                .with_unused_gas_weight(2)
                .with_attached_deposit(NO_DEPOSIT)
                .get_liquidity(order.lpt_id.clone())
                .then(
                    ext_self::ext(current_account_id())
                        .with_unused_gas_weight(98)
                        .with_attached_deposit(NO_DEPOSIT)
                        .get_liquidity_callback(
                            order_id,
                            order,
                            swap_fee,
                            price_impact,
                            order_action,
                            pool_info,
                        ),
                );
        } else {
            self.swap(order_id, order, swap_fee, price_impact, order_action);
        }
    }

    #[private]
    pub fn get_liquidity_callback(
        &mut self,
        order_id: U128,
        order: Order,
        swap_fee: U128,
        price_impact: U128,
        order_action: OrderAction,
        pool_info: PoolInfo,
    ) {
        require!(
            is_promise_success(),
            "Some problem with liquidity on ref finance"
        );
        let liquidity: Liquidity = match env::promise_result(0) {
            PromiseResult::NotReady => unreachable!(),
            PromiseResult::Successful(val) => {
                if let Ok(pool) = near_sdk::serde_json::from_slice::<Liquidity>(&val) {
                    pool
                } else {
                    panic!("Some problem with liquidity parsing.")
                }
            }
            PromiseResult::Failed => panic!("Ref finance not found liquidity"),
        };

        let remove_liquidity_amount = liquidity.amount.0;
        let min_amount_x = liquidity.amount.0 - 1000;
        let min_amount_y = 0;

        require!(
            pool_info.total_x.0 > remove_liquidity_amount,
            "Pool not have enough liquidity"
        );

        ext_ref_finance::ext(self.ref_finance_account.clone())
            .with_unused_gas_weight(50)
            .with_attached_deposit(NO_DEPOSIT)
            .remove_liquidity(
                order.lpt_id.to_string(),
                U128(remove_liquidity_amount),
                U128(min_amount_x),
                U128(min_amount_y),
            )
            .then(
                ext_self::ext(current_account_id())
                    .with_unused_gas_weight(50)
                    .with_attached_deposit(NO_DEPOSIT)
                    .remove_liquidity_callback(
                        order_id,
                        order,
                        swap_fee,
                        price_impact,
                        order_action,
                    ),
            );
    }

    #[private]
    pub fn remove_liquidity_callback(
        &mut self,
        order_id: U128,
        order: Order,
        swap_fee: U128,
        price_impact: U128,
        order_action: OrderAction,
    ) {
        require!(is_promise_success(), "Some problem with remove liquidity");
        self.order_cancel_swap_callback(order_id, order, swap_fee, price_impact, order_action);
    }

    pub fn swap(
        &self,
        order_id: U128,
        order: Order,
        swap_fee: U128,
        price_impact: U128,
        order_action: OrderAction,
    ) {
        let buy_amount = BigDecimal::from(U128::from(order.amount))
            * order.leverage
            * order.sell_token_price.value
            * self.get_price(order.buy_token.clone())
            / order.buy_token_price.value;

        let action = Action::SwapAction {
            Swap: Swap {
                pool_ids: vec![self.view_pair(&order.sell_token, &order.buy_token).pool_id],
                output_token: order.sell_token.clone(),
                min_output_amount: WBalance::from(0),
            },
        };

        log!(
            "action {}",
            near_sdk::serde_json::to_string(&action).unwrap()
        );

        ext_token::ext(order.buy_token.clone())
            .with_static_gas(Gas(3))
            .with_attached_deposit(1)
            .ft_transfer_call(
                self.ref_finance_account.clone(),
                WRatio::from(buy_amount),
                Some("Swap".to_string()),
                near_sdk::serde_json::to_string(&action).unwrap(),
            )
            .then(
                ext_self::ext(current_account_id())
                    .with_static_gas(Gas(20))
                    .with_attached_deposit(NO_DEPOSIT)
                    .order_cancel_swap_callback(
                        order_id,
                        order,
                        swap_fee,
                        price_impact,
                        order_action,
                    ),
            );
    }

    #[private]
    pub fn order_cancel_swap_callback(
        &mut self,
        order_id: U128,
        order: Order,
        swap_fee: U128,
        price_impact: U128,
        order_action: OrderAction,
    ) {
        log!(
            "Order cancel swap callback attached gas: {}",
            env::prepaid_gas().0
        );
        let market_id = self.tokens_markets.get(&order.sell_token).unwrap();

        ext_market::ext(market_id)
            .with_static_gas(Gas(20))
            .with_attached_deposit(NO_DEPOSIT)
            .view_market_data()
            .then(
                ext_self::ext(current_account_id())
                    .with_static_gas(Gas(70))
                    .with_attached_deposit(NO_DEPOSIT)
                    .market_data_callback(order_id, order, swap_fee, price_impact, order_action),
            );
    }

    #[private]
    pub fn market_data_callback(
        &mut self,
        order_id: U128,
        order: Order,
        swap_fee: U128,
        price_impact: U128,
        order_action: OrderAction,
    ) {
        log!(
            "Market data callback attached gas: {}",
            env::prepaid_gas().0
        );
        require!(is_promise_success(), "failed to get market data.");
        let market_data = match env::promise_result(0) {
            PromiseResult::NotReady => panic!("failed to get market data"),
            PromiseResult::Successful(val) => {
                if let Ok(data) = near_sdk::serde_json::from_slice::<MarketData>(&val) {
                    data
                } else {
                    panic!("failed parse market data")
                }
            }
            PromiseResult::Failed => panic!("failed to get market data"),
        };

        if order_action == OrderAction::Cancel {
            self.final_order_cancel(order_id, order, market_data, swap_fee, price_impact)
        } else {
            self.final_liquidate(order_id, order, market_data);
        }
    }

    fn final_order_cancel(
        &mut self,
        order_id: U128,
        order: Order,
        market_data: MarketData,
        swap_fee: U128,
        price_impact: U128,
    ) {
        log!("Final order cancel attached gas: {}", env::prepaid_gas().0);

        let mut order = order.clone();
        let sell_amount = order.sell_token_price.value
            * BigDecimal::from(U128::from(order.amount))
            * order.leverage;

        let pnl = self.calculate_pnl(signer_account_id(), order_id, market_data);

        let expect_amount = self.get_price(order.buy_token.clone())
            * sell_amount
            * (BigDecimal::one() - BigDecimal::from(swap_fee))
            * (BigDecimal::one() - BigDecimal::from(price_impact))
            / order.buy_token_price.value;

        self.increase_balance(
            &signer_account_id(),
            &order.sell_token,
            expect_amount.round_u128(),
        );

        if pnl.is_profit && expect_amount > sell_amount + BigDecimal::from(pnl.amount) {
            let protocol_profit = expect_amount - sell_amount - BigDecimal::from(pnl.amount);

            let token_profit = self
                .protocol_profit
                .get(&order.sell_token)
                .unwrap_or_default();
            self.protocol_profit.insert(
                &order.sell_token,
                &(BigDecimal::from(token_profit) + protocol_profit),
            );
        }

        let mut orders = self.orders.get(&signer_account_id()).unwrap();
        order.status = OrderStatus::Canceled;
        orders.insert(order_id.0 as u64, order);
        self.orders.insert(&signer_account_id(), &orders);
    }

    pub fn repay(&self, order_id: U128, market_data: MarketData) {
        let orders = self.orders.get(&signer_account_id()).unwrap_or_else(|| {
            panic!("Orders for account: {} not found", signer_account_id());
        });

        let order = orders
            .get(&(order_id.0 as u64))
            .unwrap_or_else(|| {
                panic!("Order with id: {} not found", order_id.0);
            })
            .clone();
        let market_id = self.tokens_markets.get(&order.sell_token).unwrap();
        let borrow_fee = BigDecimal::from(market_data.borrow_rate_ratio.0)
            * BigDecimal::from((block_height() - order.block) as u128);

        ext_token::ext(order.sell_token.clone())
            .with_static_gas(Gas::ONE_TERA * 35u64)
            .with_attached_deposit(ONE_YOCTO)
            .ft_transfer_call(
                market_id,
                U128(borrow_fee.round_u128()),
                None,
                "\"Repay\"".to_string(),
            )
            .then(
                ext_self::ext(current_account_id())
                    .with_static_gas(Gas::ONE_TERA * 3u64)
                    .with_attached_deposit(NO_DEPOSIT)
                    .repay_callback(),
            );
    }

    #[private]
    pub fn repay_callback(&self) -> PromiseOrValue<U128> {
        require!(is_promise_success(), "failed to repay assets");
        //TODO: add repay success event
        PromiseOrValue::Value(U128(0))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    use near_sdk::test_utils::test_env::alice;
    use near_sdk::test_utils::VMContextBuilder;
    use near_sdk::{serde_json, testing_env, FunctionError, VMContext};

    fn get_context(is_view: bool) -> VMContext {
        VMContextBuilder::new()
            .current_account_id("margin.nearland.testnet".parse().unwrap())
            .signer_account_id(alice())
            .predecessor_account_id("usdt_market.qa.nearland.testnet".parse().unwrap())
            .block_index(103930920)
            .block_timestamp(1)
            .is_view(is_view)
            .build()
    }

    #[test]
    fn test_order_was_canceled() {
        let context = get_context(false);
        testing_env!(context);
        let mut contract = Contract::new_with_config(
            "owner_id.testnet".parse().unwrap(),
            "oracle_account_id.testnet".parse().unwrap(),
        );

        contract.update_or_insert_price(
            "usdt.qa.v1.nearlend.testnet".parse().unwrap(),
            Price {
                ticker_id: "USDT".to_string(),
                value: BigDecimal::from(2.0),
            },
        );
        contract.update_or_insert_price(
            "wnear.qa.v1.nearlend.testnet".parse().unwrap(),
            Price {
                ticker_id: "WNEAR".to_string(),
                value: BigDecimal::from(4.22),
            },
        );

        let order1 = "{\"status\":\"Pending\",\"order_type\":\"Buy\",\"amount\":1000000000000000000000000000,\"sell_token\":\"usdt.qa.v1.nearlend.testnet\",\"buy_token\":\"wnear.qa.v1.nearlend.testnet\",\"leverage\":\"1\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"1.01\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"4.22\"},\"block\":103930916,\"lpt_id\":\"usdt.qa.v1.nearlend.testnet|wnear.qa.v1.nearlend.testnet|2000#543\"}".to_string();
        contract.add_order(alice(), order1.clone());

        let order_id = U128(1);
        let order = Order {
            status: OrderStatus::Pending,
            order_type: OrderType::Buy,
            amount: 1000000000000000000000000000,
            sell_token: "usdt.qa.v1.nearlend.testnet".parse().unwrap(),
            buy_token: "wnear.qa.v1.nearlend.testnet".parse().unwrap(),
            leverage: BigDecimal::from(1.0),
            sell_token_price: Price {
                ticker_id: "USDT".to_string(),
                value: BigDecimal::from(1.01),
            },
            buy_token_price: Price {
                ticker_id: "near".to_string(),
                value: BigDecimal::from(3.07),
            },
            block: 105210654,
            lpt_id: "usdt.qa.v1.nearlend.testnet|wnear.qa.v1.nearlend.testnet|2000#238".to_string(),
        };

        let market_data = MarketData {
            total_supplies: U128(60000000000000000000000000000),
            total_borrows: U128(25010000000000000000000000000),
            total_reserves: U128(1000176731435219096024128768),
            exchange_rate_ratio: U128(1000277139994639276176632),
            interest_rate_ratio: U128(261670051778601),
            borrow_rate_ratio: U128(634273735391536),
        };

        let swap_fee = U128(1);
        let price_impact = U128(1);
        contract.final_order_cancel(order_id, order, market_data, swap_fee, price_impact);

        let orders = contract.orders.get(&alice()).unwrap();
        let order = orders.get(&1).unwrap();
        assert_eq!(order.status, OrderStatus::Canceled);
    }
}

'''
'''--- src/config.rs ---
use crate::*;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct Config {
    /// The account ID of the contract owner that allows to modify config
    pub owner_id: AccountId,

    /// The account ID of the controller contract
    pub oracle_account_id: AccountId,
}

impl Contract {
    pub fn get_contract_config(&self) -> Config {
        self.config.clone()
    }
}

'''
'''--- src/create_order.rs ---
use crate::big_decimal::{BigDecimal, WBalance};
use crate::ref_finance::ext_ref_finance;
use crate::utils::{ext_market, ext_token, NO_DEPOSIT};
use crate::*;
use near_sdk::env::current_account_id;
use near_sdk::{ext_contract, is_promise_success, serde_json, Gas, PromiseResult};

const GAS_FOR_BORROW: Gas = Gas(200_000_000_000_000);

#[ext_contract(ext_self)]
trait ContractCallbackInterface {
    fn get_pool_info_callback(&mut self, order: Order) -> PromiseOrValue<WBalance>;
    fn borrow_callback(&mut self) -> PromiseOrValue<WBalance>;
    fn add_liquidity_callback(&mut self, order: Order) -> PromiseOrValue<Balance>;
}

#[near_bindgen]
impl Contract {
    /// Creates an order with given order_type, amount, sell_token, buy_token & leverage.
    ///
    /// Checks ref finance pool information for current price & borrow if leverage > 1.
    ///
    /// As far as we surpassed gas limit for contract call,
    /// borrow call was separated & made within batch of transaction alongside with Deposit & Add_Liquidity function
    pub fn create_order(
        &mut self,
        order_type: OrderType,
        amount: WBalance,
        sell_token: AccountId,
        buy_token: AccountId,
        leverage: U128,
    ) -> PromiseOrValue<WBalance> {
        let user = env::signer_account_id();

        require!(
            self.balance_of(user.clone(), sell_token.clone()) >= amount.0,
            "User doesn't have enough deposit to proceed this action"
        );

        let order = Order {
            status: OrderStatus::Pending,
            order_type,
            amount: Balance::from(amount),
            sell_token: sell_token.clone(),
            buy_token: buy_token.clone(),
            leverage: BigDecimal::from(leverage),
            sell_token_price: self.view_price(sell_token.clone()),
            buy_token_price: self.view_price(buy_token.clone()),
            block: env::block_height(),
            lpt_id: "".to_string(),
        };

        ext_ref_finance::ext(self.ref_finance_account.clone())
            .with_attached_deposit(NO_DEPOSIT)
            .with_static_gas(Gas::ONE_TERA * 5u64)
            .get_pool(self.view_pair(&order.sell_token, &order.buy_token).pool_id)
            .then(
                ext_self::ext(current_account_id())
                    .with_attached_deposit(NO_DEPOSIT)
                    .with_static_gas((Gas::ONE_TERA * 200u64 + Gas::ONE_TERA * 50u64).into())
                    .get_pool_info_callback(order),
            )
            .into()
    }

    #[private]
    pub fn get_pool_info_callback(&mut self, order: Order) -> PromiseOrValue<WBalance> {
        require!(
            is_promise_success(),
            "Problem with pool on ref finance has occurred"
        );

        let pool_info = match env::promise_result(0) {
            PromiseResult::NotReady => unreachable!(),
            PromiseResult::Successful(val) => {
                if let Ok(pool) = serde_json::from_slice::<PoolInfo>(&val) {
                    pool
                } else {
                    panic!("Some problem with pool parsing.")
                }
            }
            PromiseResult::Failed => panic!("Ref finance not found pool"),
        };

        require!(
            pool_info.state == PoolState::Running,
            "Some problem with pool, please contact with ref finance to support."
        );

        self.add_liquidity(pool_info, order)
    }

    /// Makes batch of transaction consist of Deposit & Add_Liquidity
    fn add_liquidity(&mut self, pool_info: PoolInfo, order: Order) -> PromiseOrValue<WBalance> {
        // calculating the range for the liquidity to be added into
        // consider the smallest gap is point_delta for given pool
        let mut left_point = pool_info.current_point as i32;

        while left_point % pool_info.point_delta as i32 != 0 {
            left_point += 1;
        }

        let right_point = left_point + pool_info.point_delta as i32;

        let amount = U128::from(BigDecimal::from(U128::from(order.amount)) * order.leverage);

        let amount_x: WBalance = amount;
        let amount_y = U128::from(0);
        let min_amount_x = U128::from(0);
        let min_amount_y = U128::from(0);

        let add_liquidity_promise = ext_token::ext(order.sell_token.clone())
            .with_static_gas(Gas::ONE_TERA * 35u64)
            .with_attached_deposit(near_sdk::ONE_YOCTO)
            .ft_transfer_call(
                self.ref_finance_account.clone(),
                amount,
                None,
                "\"Deposit\"".to_string(),
            )
            .and(
                ext_ref_finance::ext(self.ref_finance_account.clone())
                    .with_static_gas(Gas::ONE_TERA * 10u64)
                    .with_attached_deposit(NO_DEPOSIT)
                    .add_liquidity(
                        self.view_pair(&order.sell_token, &order.buy_token).pool_id,
                        left_point,
                        right_point,
                        amount_x,
                        amount_y,
                        min_amount_x,
                        min_amount_y,
                    ),
            )
            .then(
                ext_self::ext(current_account_id())
                    .with_static_gas(Gas::ONE_TERA * 2u64)
                    .with_attached_deposit(NO_DEPOSIT)
                    .add_liquidity_callback(order.clone()),
            );
        add_liquidity_promise.into()
    }

    #[private]
    pub fn add_liquidity_callback(&mut self, mut order: Order) -> PromiseOrValue<WBalance> {
        require!(
            env::promise_results_count() == 2,
            "Contract expected 2 results on the callback"
        );
        match env::promise_result(0) {
            PromiseResult::NotReady | PromiseResult::Failed => {
                panic!("failed to deposit liquidity")
            }
            _ => (),
        };

        self.decrease_balance(
            &env::signer_account_id().clone(),
            &order.sell_token.clone(),
            order.amount,
        );

        let lpt_id: String = match env::promise_result(1) {
            PromiseResult::Successful(result) => {
                serde_json::from_slice::<String>(&result).unwrap().into()
            }
            _ => panic!("failed to add liquidity"),
        };

        order.lpt_id = lpt_id;

        self.order_nonce += 1;
        let order_id = self.order_nonce;
        self.insert_order_for_user(&env::signer_account_id(), order, order_id);

        PromiseOrValue::Value(U128(0))
    }

    /// Borrow step made within batch of transaction
    /// Doesn't borrow when leverage is less or equal to 1.0
    pub fn borrow(
        &mut self,
        token: AccountId,
        amount: U128,
        leverage: U128,
    ) -> PromiseOrValue<WBalance> {
        require!(
            env::prepaid_gas() >= GAS_FOR_BORROW,
            "Prepaid gas is not enough for borrow flow"
        );

        require!(
            self.balance_of(env::signer_account_id(), token.clone()) >= amount.0,
            "User doesn't have enough deposit to proceed this action"
        );

        if BigDecimal::from(leverage) <= BigDecimal::one() {
            return PromiseOrValue::Value(U128(0));
        }

        let token_market = self.get_market_by(&token.clone());
        let borrow_amount =
            U128::from(BigDecimal::from(amount) * (BigDecimal::from(leverage) - BigDecimal::one()));

        ext_market::ext(token_market)
            .with_static_gas(GAS_FOR_BORROW)
            .borrow(borrow_amount)
            .then(
                ext_self::ext(env::current_account_id())
                    .with_unused_gas_weight(100)
                    .borrow_callback(),
            )
            .into()
    }

    #[private]
    pub fn borrow_callback(&mut self) -> PromiseOrValue<WBalance> {
        require!(is_promise_success(), "Contract failed to borrow assets");
        PromiseOrValue::Value(U128(0))
    }

    #[private]
    pub fn add_order(&mut self, account_id: AccountId, order: String) {
        self.order_nonce += 1;
        let order_id = self.order_nonce;
        let order = serde_json::from_str(order.as_str()).unwrap();
        self.insert_order_for_user(&account_id, order, order_id);
    }

    pub fn insert_order_for_user(&mut self, account_id: &AccountId, order: Order, order_id: u64) {
        let mut user_orders_by_id = self.orders.get(&account_id).unwrap_or_default();
        user_orders_by_id.insert(order_id, order);
        self.orders.insert(&account_id, &user_orders_by_id);
    }
}

'''
'''--- src/deposit.rs ---
use crate::big_decimal::WBalance;
use crate::*;
use near_sdk::{Gas, PromiseOrValue};

const GAS_FOR_DEPOSIT: Gas = Gas(2_000_000_000_000);

impl Contract {
    /// Accepts tokens.
    /// Updates user balance
    pub fn deposit(
        &mut self,
        token_amount: WBalance,
        token: AccountId,
    ) -> PromiseOrValue<WBalance> {
        require!(
            env::prepaid_gas() >= GAS_FOR_DEPOSIT,
            "Prepaid gas is not enough for deposit flow"
        );

        let is_token_supported = self
            .supported_markets
            .keys()
            .any(|pair| pair.0 == token || pair.1 == token);

        require!(
            is_token_supported,
            "Deposit was done by token, that are not currently supported"
        );

        self.increase_balance(&env::signer_account_id(), &token, token_amount.0);

        PromiseOrValue::Value(U128(0))
    }

    pub fn increase_balance(
        &mut self,
        account_id: &AccountId,
        token: &AccountId,
        token_amount: Balance,
    ) {
        let increased_balance = self.balance_of(account_id.clone(), token.clone()) + token_amount;
        self.set_balance(account_id, token, increased_balance)
    }

    pub fn decrease_balance(
        &mut self,
        account_id: &AccountId,
        token: &AccountId,
        token_amount: Balance,
    ) {
        require!(
            self.balance_of(account_id.clone(), token.clone()) >= token_amount,
            "Decreased balance must be greater than 0"
        );
        self.set_balance(
            &account_id.clone(),
            &token.clone(),
            self.balance_of(account_id.clone(), token.clone()) - token_amount,
        )
    }

    pub fn set_balance(
        &mut self,
        account_id: &AccountId,
        token: &AccountId,
        token_amount: Balance,
    ) {
        let mut user_balance_by_token = self.balances.get(&account_id).unwrap_or_default();
        user_balance_by_token.insert(token.clone(), token_amount);
        self.balances.insert(&account_id, &user_balance_by_token);
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::str::FromStr;

    pub const INITIAL_BALANCE: Balance = 10_000;
    pub const AMOUNT_TO_INCREASE: Balance = 20_000;
    pub const AMOUNT_TO_DECREASE: Balance = 5_000;

    pub fn get_contract() -> (Contract, AccountId, AccountId) {
        let owner_id: AccountId = "contract.testnet".parse().unwrap();
        let oracle_account_id: AccountId = "oracle.testnet".parse().unwrap();

        let mut contract = Contract::new_with_config(owner_id, oracle_account_id);

        let user: AccountId = AccountId::from_str("some_example_user.testnet").unwrap();
        let token: AccountId = AccountId::from_str("some_example_token.testnet").unwrap();

        contract.set_balance(&user.clone(), &token.clone(), INITIAL_BALANCE);

        assert_eq!(
            contract.balance_of(user.clone(), token.clone()),
            INITIAL_BALANCE
        );

        (contract, user, token)
    }

    #[test]
    fn test_successful_increase_decrease_balance() {
        let (mut contract, user, token) = get_contract();

        contract.increase_balance(&user.clone(), &token.clone(), AMOUNT_TO_INCREASE);

        assert_eq!(
            contract.balance_of(user.clone(), token.clone()),
            AMOUNT_TO_INCREASE + INITIAL_BALANCE
        );

        contract.decrease_balance(&user.clone(), &token.clone(), AMOUNT_TO_DECREASE);

        assert_eq!(
            contract.balance_of(user.clone(), token.clone()),
            AMOUNT_TO_INCREASE + INITIAL_BALANCE - AMOUNT_TO_DECREASE
        );
    }

    #[test]
    #[should_panic]
    fn test_fail_decrease_balance() {
        let (mut contract, user, token) = get_contract();

        assert_eq!(
            contract.balance_of(user.clone(), token.clone()),
            INITIAL_BALANCE
        );

        contract.decrease_balance(&user.clone(), &token.clone(), 10000 * AMOUNT_TO_DECREASE);
    }
}

'''
'''--- src/execute_order.rs ---
use crate::ref_finance::ext_ref_finance;
use crate::utils::NO_DEPOSIT;
use crate::*;
use near_sdk::env::current_account_id;
use near_sdk::{ext_contract, is_promise_success, Gas, Promise, PromiseResult};

#[ext_contract(ext_self)]
trait ContractCallbackInterface {
    fn remove_liquidity_for_execute_order_callback(&self, order: Order, order_id: U128);
    fn execute_order_callback(&self, order: Order, order_id: U128);
}

#[near_bindgen]
impl Contract {
    /// Executes order by inner order_id set on ref finance once the price range was crossed.
    /// Gets pool info, removes liquidity presented by one asset and marks order as executed.
    pub fn execute_order(&self, order_id: U128) -> PromiseOrValue<U128> {
        let order = self.get_order_by(order_id.0);
        require!(order.is_some(), "There is no such order to be executed");

        assert_eq!(
            order.as_ref().unwrap().status.clone(),
            OrderStatus::Pending,
            "Error. Order has to be Pending to be executed"
        );

        let order = order.unwrap().clone();

        ext_ref_finance::ext(self.ref_finance_account.clone())
            .with_static_gas(Gas::ONE_TERA * 5u64)
            .with_attached_deposit(NO_DEPOSIT)
            .get_liquidity(order.lpt_id.clone())
            .then(
                ext_self::ext(current_account_id())
                    .with_unused_gas_weight(100)
                    .with_attached_deposit(NO_DEPOSIT)
                    .execute_order_callback(order, order_id),
            )
            .into()
    }

    #[private]
    pub fn execute_order_callback(&self, order: Order, order_id: U128) -> PromiseOrValue<U128> {
        require!(is_promise_success(), "Failed to get_liquidity");

        let position = match env::promise_result(0) {
            PromiseResult::NotReady => unreachable!(),
            PromiseResult::Successful(val) => {
                near_sdk::serde_json::from_slice::<crate::ref_finance::LiquidityInfo>(&val).unwrap()
            }
            PromiseResult::Failed => panic!("Ref finance not found pool"),
        };

        let remove_liquidity_amount = position.amount;

        let min_amount_x = 0;
        let min_amount_y =
            BigDecimal::from(order.amount) * order.leverage * order.sell_token_price.value
                / order.buy_token_price.value;

        ext_ref_finance::ext(self.ref_finance_account.clone())
            .with_static_gas(Gas::ONE_TERA * 100u64)
            .remove_liquidity(
                order.lpt_id.clone(),
                remove_liquidity_amount,
                U128(min_amount_x),
                U128::from(min_amount_y),
            )
            .then(
                ext_self::ext(current_account_id())
                    .with_unused_gas_weight(100)
                    .with_attached_deposit(NO_DEPOSIT)
                    .remove_liquidity_for_execute_order_callback(order, order_id),
            )
            .into()
    }

    #[private]
    pub fn remove_liquidity_for_execute_order_callback(
        &mut self,
        order: Order,
        order_id: U128,
    ) -> PromiseOrValue<U128> {
        if !is_promise_success() {
            panic!("Some problem with remove liquidity");
        } else {
            self.mark_order_as_executed(order.clone(), order_id);

            let executor_reward_in_near = env::used_gas().0 as Balance * 2u128;
            Promise::new(env::signer_account_id())
                .transfer(executor_reward_in_near)
                .into()
        }
    }
}

impl Contract {
    pub fn mark_order_as_executed(&mut self, order: Order, order_id: U128) {
        let order = order.clone();

        let new_order = Order {
            status: OrderStatus::Executed,
            order_type: order.order_type,
            amount: order.amount,
            sell_token: order.sell_token,
            buy_token: order.buy_token,
            leverage: order.leverage,
            sell_token_price: order.sell_token_price,
            buy_token_price: order.buy_token_price,
            block: order.block,
            lpt_id: order.lpt_id,
        };

        self.insert_order_for_user(
            &self.get_account_by(order_id.0).unwrap(), // assert there is always some user
            new_order.clone(),
            order_id.clone().0 as u64,
        );
    }

    pub fn get_account_by(&self, order_id: u128) -> Option<AccountId> {
        let mut account: Option<AccountId> = None;
        for (account_id, users_order) in self.orders.iter() {
            if users_order.contains_key(&(order_id as u64)) {
                account = Some(account_id);
                break;
            }
        }
        account
    }
}

'''
'''--- src/ft.rs ---
use crate::*;
use near_contract_standards::fungible_token::receiver::FungibleTokenReceiver;
use near_sdk::json_types::U128;
use near_sdk::AccountId;
use near_sdk::{log, serde_json, Balance, PromiseOrValue};

#[near_bindgen]
impl FungibleTokenReceiver for Contract {
    /// Accepts token to be deposited by user.
    ///
    /// msg format for deposit "{"Deposit": {"token": "<token_to_be_deposited>"}}"
    fn ft_on_transfer(
        &mut self,
        sender_id: AccountId,
        amount: U128,
        msg: String,
    ) -> PromiseOrValue<U128> {
        assert!(
            Balance::from(amount) > 0,
            "Amount should be a positive number"
        );

        log!(format!("sender_id {}, msg {}", sender_id, msg));

        let action: Actions = serde_json::from_str(&msg).expect("Incorrect command in transfer");

        match action {
            Actions::Deposit { token } => self.deposit(amount, token),
            _ => {
                panic!("Incorrect action in transfer")
            }
        }
    }
}

'''
'''--- src/lib.rs ---
extern crate core;

mod big_decimal;
mod cancel_order;
mod config;
mod create_order;
mod deposit;
mod execute_order;
mod ft;
mod liquidate_order;
mod market;
mod metadata;
mod oraclehook;
mod price;
mod ref_finance;
mod utils;
mod view;

use crate::big_decimal::*;
use crate::config::Config;
use crate::metadata::*;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LookupMap, UnorderedMap};
use near_sdk::json_types::U128;
use near_sdk::{env, near_bindgen, require, AccountId, Balance, PromiseOrValue};
use std::collections::HashMap;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Contract {
    /// market ➝ MarketData
    market_infos: LookupMap<AccountId, MarketData>,

    /// Protocol fee
    protocol_fee: u128,

    /// token ➝ Price
    prices: UnorderedMap<AccountId, Price>,

    /// total orders created on contract
    order_nonce: u64,

    /// user ➝ order_id ➝ Order
    orders: UnorderedMap<AccountId, HashMap<u64, Order>>,

    /// (AccountId, AccountId) ➝ TradePair
    supported_markets: UnorderedMap<(AccountId, AccountId), TradePair>,

    /// User ➝ Token ➝ Balance
    balances: UnorderedMap<AccountId, HashMap<AccountId, Balance>>,

    config: Config,

    /// token id -> market id
    tokens_markets: LookupMap<AccountId, AccountId>,

    /// Protocol profit token_id -> amount
    protocol_profit: LookupMap<AccountId, BigDecimal>,

    /// Ref finance accountId [ as default "dcl.ref-dev.testnet" ]
    ref_finance_account: AccountId,

    /// Liquidation threshold
    liquidation_threshold: u128,

    /// Volatility rate
    volatility_rate: BigDecimal,
}

impl Default for Contract {
    fn default() -> Self {
        env::panic_str("Margin trading contract should be initialized before usage")
    }
}

#[near_bindgen]
impl Contract {
    /// Initializes the contract with the given config. Needs to be called once.
    #[init]
    pub fn new_with_config(owner_id: AccountId, oracle_account_id: AccountId) -> Self {
        Self::new(Config {
            owner_id,
            oracle_account_id,
        })
    }

    #[init]
    #[private]
    pub fn new(config: Config) -> Self {
        require!(!env::state_exists(), "Already initialized");

        Self {
            market_infos: LookupMap::new(StorageKeys::Markets),
            protocol_fee: 10u128.pow(23),
            prices: UnorderedMap::new(StorageKeys::Prices),
            order_nonce: 0,
            orders: UnorderedMap::new(StorageKeys::Orders),
            supported_markets: UnorderedMap::new(StorageKeys::SupportedMarkets),
            config,
            balances: UnorderedMap::new(StorageKeys::Balances),
            tokens_markets: LookupMap::new(StorageKeys::TokenMarkets),
            protocol_profit: LookupMap::new(StorageKeys::ProtocolProfit),
            ref_finance_account: "dcl.ref-dev.testnet".parse().unwrap(),
            liquidation_threshold: 10_u128.pow(23),
            volatility_rate: BigDecimal::from(U128(95 * 10_u128.pow(22))),
        }
    }

    #[private]
    pub fn add_market_data(&mut self, market: AccountId, data: MarketData) {
        self.market_infos.insert(&market, &data);
    }

    #[private]
    pub fn set_protocol_fee(&mut self, fee: U128) {
        self.protocol_fee = fee.0
    }

    #[private]
    pub fn add_token_market(&mut self, token_id: AccountId, market_id: AccountId) {
        self.tokens_markets.insert(&token_id, &market_id);
    }

    #[private]
    pub fn set_liquidation_threshold(&mut self, threshold: U128) {
        self.liquidation_threshold = threshold.0;
    }

    #[private]
    pub fn set_volatility_rate(&mut self, rate: U128) {
        self.volatility_rate = BigDecimal::from(rate)
    }
}

'''
'''--- src/liquidate_order.rs ---
use crate::big_decimal::{BigDecimal, WRatio};
use crate::cancel_order::ext_self;
use crate::ref_finance::ext_ref_finance;
use crate::ref_finance::{Action, Swap};
use crate::utils::NO_DEPOSIT;
use crate::utils::{ext_market, ext_token};
use crate::*;
use near_sdk::env::{block_height, current_account_id, signer_account_id};
use near_sdk::{ext_contract, is_promise_success, Gas, PromiseResult};

#[near_bindgen]
impl Contract {
    pub fn liquidate_order(&mut self, order_id: U128, swap_fee: U128, price_impact: U128) {
        let account_op = self.get_account_by(order_id.0);
        require!(
            account_op.is_some(),
            format!("Not found account for order with id: {}", order_id.0)
        );
        let account = account_op.unwrap();

        let orders = self.orders.get(&account.clone()).unwrap_or_else(|| {
            panic!("Orders for account: {} not found", account.clone());
        });

        let order = orders
            .get(&(order_id.0 as u64))
            .unwrap_or_else(|| {
                panic!("Order with id: {} not found", order_id.0);
            })
            .clone();

        require!(
            order.status != OrderStatus::Canceled && order.status != OrderStatus::Executed,
            "Order can't be liquidate."
        );

        //TODO: set real min_amount_x/min_amount_y
        let amount = 1;
        let min_amount_x = order.amount;
        let min_amount_y = 0;

        if order.status == OrderStatus::Pending {
            ext_ref_finance::ext(self.ref_finance_account.clone())
                .with_static_gas(Gas(10))
                .with_attached_deposit(1)
                .remove_liquidity(
                    order.lpt_id.clone(),
                    U128(amount),
                    U128(min_amount_x),
                    U128(min_amount_y),
                )
                .then(
                    ext_self::ext(current_account_id())
                        .with_static_gas(Gas(5))
                        .with_attached_deposit(NO_DEPOSIT)
                        .remove_liquidity_callback(
                            order_id,
                            order,
                            swap_fee,
                            price_impact,
                            OrderAction::Liquidate,
                        ),
                );
        } else {
            self.swap(
                order_id,
                order,
                swap_fee,
                price_impact,
                OrderAction::Liquidate,
            );
        }
    }

    #[private]
    pub fn final_liquidate(&mut self, order_id: U128, mut order: Order, market_data: MarketData) {
        let borrow_fee = BigDecimal::from(
            market_data.borrow_rate_ratio.0 * (block_height() - order.block) as u128,
        );

        let buy_token_amount =
            BigDecimal::from(order.amount) * order.sell_token_price.value * order.leverage
                / order.buy_token_price.value;
        let loss = borrow_fee + buy_token_amount * order.buy_token_price.value
            - BigDecimal::from(order.amount);

        let is_liquidation_possible = loss
            >= BigDecimal::from(order.amount)
                * order.buy_token_price.value
                * BigDecimal::from(10_u128.pow(24) - self.liquidation_threshold);

        require!(is_liquidation_possible, "This order can't be liquidated");

        let liquidation_incentive = order.amount * self.liquidation_threshold;
        self.increase_balance(
            &env::signer_account_id(),
            &order.buy_token.clone(),
            liquidation_incentive,
        );
        let account = self.get_account_by(order_id.0).unwrap();
        let mut orders = self.orders.get(&account).unwrap();
        order.status = OrderStatus::Liquidated;
        orders.insert(order_id.0 as u64, order);
        self.orders.insert(&signer_account_id(), &orders);
    }
}

'''
'''--- src/market.rs ---
use crate::*;

#[near_bindgen]
impl Contract {
    #[private]
    pub fn add_pair(&mut self, pair_data: TradePair) {
        let pair = (pair_data.sell_token.clone(), pair_data.buy_token.clone());
        self.supported_markets.insert(&pair, &pair_data);
    }

    #[private]
    pub fn remove_pair(&mut self, pair_data: TradePair) {
        let pair = (pair_data.sell_token.clone(), pair_data.buy_token);
        self.supported_markets.remove(&pair);
    }
}

'''
'''--- src/metadata.rs ---
use crate::big_decimal::{BigDecimal, WBalance, WRatio};
use crate::*;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{AccountId, Balance, BlockHeight, BorshStorageKey};
use std::fmt;

#[derive(BorshSerialize, BorshStorageKey)]
pub enum StorageKeys {
    Markets,
    Prices,
    Orders,
    SupportedMarkets,
    Balances,
    TokenMarkets,
    ProtocolProfit,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct MarketData {
    pub total_supplies: WBalance,
    pub total_borrows: WBalance,
    pub total_reserves: WBalance,
    pub exchange_rate_ratio: WRatio,
    pub interest_rate_ratio: WRatio,
    pub borrow_rate_ratio: WRatio,
}

impl Default for MarketData {
    fn default() -> Self {
        Self {
            total_supplies: U128(0),
            total_borrows: U128(0),
            total_reserves: U128(0),
            exchange_rate_ratio: U128(0),
            interest_rate_ratio: U128(0),
            borrow_rate_ratio: U128(0),
        }
    }
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct PnLView {
    pub is_profit: bool,
    pub amount: U128,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Debug, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct Price {
    pub ticker_id: String,
    pub value: BigDecimal,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, PartialEq, Clone, Debug)]
#[serde(crate = "near_sdk::serde")]
pub enum OrderStatus {
    Pending,
    Executed,
    Canceled,
    Liquidated,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone, PartialEq, Debug)]
#[serde(crate = "near_sdk::serde")]
pub enum OrderType {
    Buy,
    Sell,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct Order {
    pub status: OrderStatus,
    pub order_type: OrderType,
    pub amount: Balance,
    pub sell_token: AccountId,
    pub buy_token: AccountId,
    pub leverage: BigDecimal,
    pub sell_token_price: Price,
    pub buy_token_price: Price,
    pub block: BlockHeight,
    pub lpt_id: String,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, PartialEq, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct OrderView {
    pub order_id: U128,
    pub status: OrderStatus,
    pub order_type: OrderType,
    pub amount: U128,
    pub sell_token: AccountId,
    pub buy_token: AccountId,
    pub leverage: WBigDecimal,
    pub buy_token_price: WBalance,
    pub fee: WBalance,
    pub lpt_id: String,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Debug, Clone, PartialEq)]
#[serde(crate = "near_sdk::serde")]
pub struct TradePair {
    pub sell_ticker_id: String,
    pub sell_token: AccountId,
    pub sell_token_market: AccountId,
    pub buy_ticker_id: String,
    pub buy_token: AccountId,
    pub pool_id: String,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct CancelOrderView {
    pub buy_token_amount: WRatio,
    pub sell_token_amount: WRatio,
    pub open_price: WRatio,
    pub close_price: WRatio,
    pub pnl: PnLView,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, PartialEq)]
#[serde(crate = "near_sdk::serde")]
pub enum OrderAction {
    Create,
    Cancel,
    Liquidate,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, PartialEq)]
#[serde(crate = "near_sdk::serde")]
pub struct PoolInfo {
    pub pool_id: String,
    pub token_x: AccountId,
    pub token_y: AccountId,
    pub fee: u64,
    pub point_delta: u64,
    pub current_point: i64,
    pub liquidity: U128,
    pub liquidity_x: U128,
    pub max_liquidity_per_point: U128,
    pub volume_x_in: U128,
    pub volume_y_in: U128,
    pub volume_x_out: U128,
    pub volume_y_out: U128,
    pub total_liquidity: U128,
    pub total_order_x: U128,
    pub total_order_y: U128,
    pub total_x: U128,
    pub total_y: U128,
    pub state: PoolState,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, PartialEq)]
#[serde(crate = "near_sdk::serde")]
pub enum PoolState {
    Running,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, PartialEq)]
#[serde(crate = "near_sdk::serde")]
pub struct Liquidity {
    pub lpt_id: String,
    pub owner_id: AccountId,
    pub pool_id: String,
    pub left_point: i64,
    pub right_point: i64,
    pub amount: U128,
    pub unclaimed_fee_x: U128,
    pub unclaimed_fee_y: U128,
}

#[derive(Clone, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
#[derive(Debug)]
pub enum Actions {
    Deposit { token: AccountId },
}

impl fmt::Display for Actions {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}

'''
'''--- src/oraclehook.rs ---
use crate::*;
use near_sdk::serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct PriceJsonList {
    /// Block number
    pub block_height: u64,

    /// Vector of asset prices
    pub price_list: Vec<Price>,
}

pub trait OraclePriceHandlerHook {
    fn oracle_on_data(&mut self, price_data: PriceJsonList);
}

#[near_bindgen]
impl OraclePriceHandlerHook for Contract {
    fn oracle_on_data(&mut self, price_data: PriceJsonList) {
        let config: Config = self.get_contract_config();

        assert_eq!(
            env::predecessor_account_id(),
            config.oracle_account_id,
            "Oracle account {} doesn't match to the signer {}",
            config.oracle_account_id,
            env::predecessor_account_id()
        );

        let ticker_map = self.get_ticker_map();

        for price in price_data.price_list {
            if let Some(token) = ticker_map.get(&price.ticker_id) {
                self.update_or_insert_price(token.clone(), price.clone())
            }
        }
    }
}

impl Contract {
    pub fn get_ticker_map(&mut self) -> HashMap<String, AccountId> {
        let mut ticker_map = HashMap::new();
        self.supported_markets.values().for_each(|trade_pair| {
            ticker_map.insert(trade_pair.sell_ticker_id, trade_pair.sell_token);
            ticker_map.insert(trade_pair.buy_ticker_id, trade_pair.buy_token);
        });
        ticker_map
    }
}

'''
'''--- src/price.rs ---
use crate::big_decimal::BigDecimal;
use crate::*;

#[near_bindgen]
impl Contract {
    #[private]
    pub fn update_or_insert_price(&mut self, token_id: AccountId, price: Price) {
        self.prices.insert(&token_id, &price);
    }

    pub fn get_price(&self, token_id: AccountId) -> BigDecimal {
        self.prices
            .get(&token_id)
            .unwrap_or_else(|| {
                panic!("Price for token: {} not found", token_id);
            })
            .value
    }

    pub fn calculate_xrate(&self, token_id_1: AccountId, token_id_2: AccountId) -> BigDecimal {
        self.view_price(token_id_1).value / self.view_price(token_id_2).value
    }

    pub fn get_market_by(&self, token: &AccountId) -> AccountId {
        self.tokens_markets.get(&token).unwrap_or_else(|| {
            panic!("Market for token: {} was not found", token);
        })
    }
}

'''
'''--- src/ref_finance.rs ---
use crate::*;
use near_sdk::ext_contract;
use near_sdk::serde::{Deserialize, Serialize};

pub type PoolId = String;
pub type LptId = String;

#[ext_contract(ext_ref_finance)]
trait RefFinanceInterface {
    fn add_liquidity(
        &mut self,
        pool_id: String,
        left_point: i32,
        right_point: i32,
        amount_x: U128,
        amount_y: U128,
        min_amount_x: U128,
        min_amount_y: U128,
    );

    fn remove_liquidity(
        &self,
        lpt_id: LptId,
        amount: U128,
        min_amount_x: U128,
        min_amount_y: U128,
    ) -> (U128, U128);

    fn get_pool(&self, pool_id: PoolId);

    fn get_liquidity(&self, lpt_id: LptId);
}

/// Single swap action.
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Swap {
    /// Pool which should be used for swapping.
    pub pool_ids: Vec<String>,
    /// Token to swap into.
    pub output_token: AccountId,
    /// Required minimum amount of token_out.
    pub min_output_amount: U128,
}

/// Single action. Allows to execute sequence of various actions initiated by an account.
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
#[serde(untagged)]
pub enum Action {
    SwapAction { Swap: Swap },
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct LiquidityInfo {
    pub lpt_id: LptId,
    pub owner_id: AccountId,
    pub pool_id: String,
    pub left_point: i32,
    pub right_point: i32,
    pub amount: U128,
    pub unclaimed_fee_x: U128,
    pub unclaimed_fee_y: U128,
}

'''
'''--- src/utils.rs ---
use crate::*;
use near_sdk::ext_contract;

pub const NO_DEPOSIT: Balance = 0;

#[ext_contract(ext_token)]
pub trait NEP141Token {
    fn ft_transfer_call(
        &mut self,
        receiver_id: AccountId,
        amount: WBalance,
        memo: Option<String>,
        msg: String,
    );

    fn ft_transfer(&mut self, receiver_id: AccountId, amount: WBalance, memo: Option<String>);
}

impl Contract {
    pub fn get_order_by(&self, order_id: u128) -> Option<Order> {
        let account = self.get_account_by(order_id).unwrap();

        self.orders
            .get(&account)
            .unwrap()
            .get(&(order_id as u64))
            .cloned()
    }
}

#[ext_contract(ext_market)]
pub trait MarketInterface {
    fn borrow(&mut self, amount: WBalance) -> PromiseOrValue<U128>;
    fn view_market_data(&self) -> MarketData;
}

'''
'''--- src/view.rs ---
use crate::big_decimal::{BigDecimal, WRatio};
use crate::*;

#[near_bindgen]
impl Contract {
    pub fn view_market_data(&self, market: AccountId) -> MarketData {
        self.market_infos.get(&market).unwrap_or_default()
    }

    pub fn view_order(&self, account_id: AccountId, order_id: U128) -> OrderView {
        let orders = self.orders.get(&account_id).unwrap_or_else(|| {
            panic!("Orders for account: {} not found", account_id);
        });

        let order = orders
            .get(&(order_id.0 as u64))
            .unwrap_or_else(|| {
                panic!("Order with id: {} not found", order_id.0);
            })
            .clone();

        OrderView {
            order_id,
            status: order.status,
            order_type: order.order_type,
            amount: U128(order.amount),
            sell_token: order.sell_token,
            buy_token: order.buy_token,
            leverage: WBigDecimal::from(order.leverage),
            buy_token_price: WBalance::from(order.buy_token_price.value),
            fee: U128(3 * 10u128.pow(23)), // hardcore of 0.3 %
            lpt_id: order.lpt_id,
        }
    }

    pub fn calculate_pnl(
        &self,
        account_id: AccountId,
        order_id: U128,
        data: MarketData,
    ) -> PnLView {
        let orders = self.orders.get(&account_id).unwrap_or_else(|| {
            panic!("Orders for account: {} not found", account_id);
        });

        let order = orders
            .get(&(order_id.0 as u64))
            .unwrap_or_else(|| {
                panic!("Order with id: {} not found", order_id.0);
            })
            .clone();

        let buy_amount =
            order.leverage * BigDecimal::from(order.amount) / order.buy_token_price.value;

        let borrow_amount = BigDecimal::from(U128(order.amount))
            * (order.leverage - BigDecimal::one())
            * BigDecimal::from(10_u128.pow(24));

        let borrow_fee = borrow_amount * BigDecimal::from(data.borrow_rate_ratio);
        // fee by blocks count
        //* BigDecimal::from(block_height() - order.block);

        //swap_fee 0.0003
        let expect_amount = buy_amount * order.sell_token_price.value
            - borrow_amount
            - borrow_fee
            - borrow_amount * BigDecimal::from(0.0003);

        let pnlv: PnLView = if expect_amount.round_u128() > order.amount {
            let lenpnl = (expect_amount
                - BigDecimal::from(order.amount)
                - (BigDecimal::from(order.amount)
                    * BigDecimal::from(self.protocol_fee / 10_u128.pow(24))))
            .round_u128();

            PnLView {
                is_profit: true,
                amount: U128(lenpnl),
            }
        } else {
            let lenpnl = (BigDecimal::from(order.amount) - expect_amount).round_u128();

            PnLView {
                is_profit: false,
                amount: U128(lenpnl),
            }
        };

        pnlv
    }

    pub fn view_orders(
        &self,
        account_id: AccountId,
        sell_token: AccountId,
        buy_token: AccountId,
    ) -> Vec<OrderView> {
        let orders = self.orders.get(&account_id).unwrap_or_default();
        let result = orders
            .iter()
            .filter_map(|(id, order)| {
                match order.sell_token == sell_token && order.buy_token == buy_token {
                    true => Some(OrderView {
                        order_id: U128(*id as u128),
                        status: order.status.clone(),
                        order_type: order.order_type.clone(),
                        amount: U128(order.amount.clone()),
                        sell_token: order.sell_token.clone(),
                        buy_token: order.buy_token.clone(),
                        leverage: WBigDecimal::from(order.leverage),
                        buy_token_price: WRatio::from(order.buy_token_price.value),
                        fee: U128(self.protocol_fee),
                        lpt_id: order.lpt_id.clone(),
                    }),
                    false => None,
                }
            })
            .collect::<Vec<OrderView>>();
        result
    }

    pub fn view_pair(&self, sell_token: &AccountId, buy_token: &AccountId) -> TradePair {
        self.supported_markets
            .get(&(sell_token.clone(), buy_token.clone()))
            .unwrap()
    }

    pub fn view_supported_pairs(&self) -> Vec<TradePair> {
        let pairs = self
            .supported_markets
            .iter()
            .map(|(_, trade_pair)| trade_pair)
            .collect::<Vec<TradePair>>();

        pairs
    }

    /// Returns the balance of the given account on certain token. If the account doesn't exist will return `"0"`.
    pub fn balance_of(&self, account_id: AccountId, token: AccountId) -> Balance {
        match self.balances.get(&account_id) {
            None => 0,
            Some(user_balance_per_token) => *user_balance_per_token.get(&token).unwrap_or(&0u128),
        }
    }

    /// Returns price of the given token. If the token is not registered, will return `"0"`.
    pub fn view_price(&self, token_id: AccountId) -> Price {
        self.prices.get(&token_id).unwrap_or_else(|| {
            panic!("Price for token: {} not found", token_id);
        })
    }

    pub fn cancel_order_view(
        &self,
        account_id: AccountId,
        order_id: U128,
        market_data: MarketData,
    ) -> CancelOrderView {
        let orders = self.orders.get(&account_id).unwrap_or_else(|| {
            panic!("Orders for account: {} not found", account_id);
        });

        let order = orders.get(&(order_id.0 as u64)).unwrap_or_else(|| {
            panic!("Order with id: {} not found", order_id.0);
        });

        let buy_token =
            BigDecimal::from(U128(order.amount)) * order.leverage * order.sell_token_price.value
                / order.buy_token_price.value;

        let sell_token = BigDecimal::from(U128(order.amount)) * order.leverage;

        let open_price = order.buy_token_price.clone();

        let close_price = self.get_price(order.buy_token.clone());

        let calc_pnl = self.calculate_pnl(account_id, order_id, market_data);

        CancelOrderView {
            buy_token_amount: WRatio::from(buy_token),
            sell_token_amount: WRatio::from(sell_token),
            open_price: WRatio::from(open_price.value),
            close_price: WRatio::from(close_price),
            pnl: calc_pnl,
        }
    }

    pub fn view_liquidation_threshold(&self) -> U128 {
        U128(self.liquidation_threshold)
    }

    pub fn calculate_liquidation_price(
        &self,
        sell_token_amount: U128,
        sell_token_price: U128,
        buy_token_price: U128,
        leverage: U128,
        borrow_fee: U128,
        swap_fee: U128,
    ) -> WBigDecimal {
        let collateral_usd =
            BigDecimal::from(sell_token_amount) * BigDecimal::from(sell_token_price);
        let position_amount_usd = collateral_usd * BigDecimal::from(leverage);
        let borrow_amount = collateral_usd * (BigDecimal::from(leverage) - BigDecimal::one());
        let buy_amount = position_amount_usd / BigDecimal::from(buy_token_price);

        let liquidation_price = (position_amount_usd - self.volatility_rate * collateral_usd
            + borrow_amount * BigDecimal::from(borrow_fee)
            + position_amount_usd * BigDecimal::from(swap_fee))
            / buy_amount;

        liquidation_price.into()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    use near_sdk::test_utils::test_env::alice;
    use near_sdk::test_utils::VMContextBuilder;
    use near_sdk::{serde_json, testing_env, FunctionError, VMContext};

    fn get_context(is_view: bool) -> VMContext {
        VMContextBuilder::new()
            .current_account_id("margin.nearland.testnet".parse().unwrap())
            .signer_account_id(alice())
            .predecessor_account_id("usdt_market.qa.nearland.testnet".parse().unwrap())
            .block_index(721)
            .block_timestamp(1)
            .is_view(is_view)
            .build()
    }

    #[test]
    fn view_supported_pairs_test() {
        let context = get_context(false);
        testing_env!(context);
        let mut contract = Contract::new_with_config(
            "owner_id.testnet".parse().unwrap(),
            "oracle_account_id.testnet".parse().unwrap(),
        );
        let pair_data = TradePair {
            sell_ticker_id: "usdt".to_string(),
            sell_token: "usdt.qa.v1.nearlend.testnet".parse().unwrap(),
            sell_token_market: "usdt_market.qa.v1.nearlend.testnet".parse().unwrap(),
            buy_ticker_id: "wnear".to_string(),
            buy_token: "wnear.qa.v1.nearlend.testnet".parse().unwrap(),
            pool_id: "usdt.qa.v1.nearlend.testnet|wnear.qa.v1.nearlend.testnet|2000".to_string(),
        };
        contract.add_pair(pair_data.clone());

        let pair_data2 = TradePair {
            sell_ticker_id: "wnear".to_string(),
            sell_token: "wnear.qa.v1.nearlend.testnet".parse().unwrap(),
            sell_token_market: "wnear_market.qa.v1.nearlend.testnet".parse().unwrap(),
            buy_ticker_id: "usdt".to_string(),
            buy_token: "usdt.qa.v1.nearlend.testnet".parse().unwrap(),
            pool_id: "usdt.qa.v1.nearlend.testnet|wnear.qa.v1.nearlend.testnet|2000".to_string(),
        };

        contract.add_pair(pair_data2.clone());

        let result = vec![pair_data, pair_data2];
        let pairs = contract.view_supported_pairs();
        assert_eq!(result, pairs);
    }

    #[test]
    fn calculate_pnl_test() {
        let context = get_context(false);
        testing_env!(context);
        let mut contract = Contract::new_with_config(
            "owner_id.testnet".parse().unwrap(),
            "oracle_account_id.testnet".parse().unwrap(),
        );

        contract.update_or_insert_price(
            "usdt.qa.v1.nearlend.testnet".parse().unwrap(),
            Price {
                ticker_id: "USDT".to_string(),
                value: BigDecimal::from(2.0),
            },
        );
        contract.update_or_insert_price(
            "wnear.qa.v1.nearlend.testnet".parse().unwrap(),
            Price {
                ticker_id: "WNEAR".to_string(),
                value: BigDecimal::from(4.22),
            },
        );
        let order1 = "{\"status\":\"Executed\",\"order_type\":\"Buy\",\"amount\":1500000000000000000000000000,\"sell_token\":\"usdt.qa.v1.nearlend.testnet\",\"buy_token\":\"wnear.qa.v1.nearlend.testnet\",\"leverage\":\"2.0\",\"sell_token_price\":{\"ticker_id\":\"USDT\",\"value\":\"3.3\"},\"buy_token_price\":{\"ticker_id\":\"WNEAR\",\"value\":\"4.59\"},\"block\":1,\"lpt_id\":\"usdt.qa.v1.nearlend.testnet|wnear.qa.v1.nearlend.testnet|2000#132\"}".to_string();
        contract.add_order(alice(), order1.clone());
        let market_data = MarketData {
            total_supplies: U128(10_u128.pow(24)),
            total_borrows: U128(10_u128.pow(24)),
            total_reserves: U128(10_u128.pow(24)),
            exchange_rate_ratio: U128(10_u128.pow(24)),
            interest_rate_ratio: U128(10_u128.pow(24)),
            borrow_rate_ratio: U128(5 * 10_u128.pow(22)),
        };
        let pnl = contract.calculate_pnl(alice(), U128(1), market_data);
        assert!(!pnl.is_profit);
        assert_eq!(pnl.amount, U128(918587254901960784313725490));
    }

    #[test]
    fn test_calculate_liquidation_leverage_3() {
        let contract = Contract::new_with_config(
            "owner_id.testnet".parse().unwrap(),
            "oracle_account_id.testnet".parse().unwrap(),
        );

        let result = contract.calculate_liquidation_price(
            U128(10_u128.pow(27)),
            U128(10_u128.pow(24)),
            U128(10_u128.pow(25)),
            U128(3 * 10_u128.pow(24)),
            U128(5 * 10_u128.pow(22)),
            U128(3 * 10_u128.pow(20)),
        );

        assert_eq!(result, U128(7169666666666666666666666));
    }

    #[test]
    fn test_calculate_liquidation_leverage_1_5() {
        let contract = Contract::new_with_config(
            "owner_id.testnet".parse().unwrap(),
            "oracle_account_id.testnet".parse().unwrap(),
        );

        let result = contract.calculate_liquidation_price(
            U128(10_u128.pow(27)),
            U128(10_u128.pow(24)),
            U128(10_u128.pow(25)),
            U128(15 * 10_u128.pow(23)),
            U128(5 * 10_u128.pow(22)),
            U128(3 * 10_u128.pow(20)),
        );

        assert_eq!(result, U128(3836333333333333333333333));
    }
}

'''
'''--- src_V1/big_decimal.rs ---
use crate::*;
use near_sdk::borsh::maybestd::io::Write;
use near_sdk::json_types::U128;
use near_sdk::serde::Serializer;
use std::cmp::{max_by, min_by, Ordering};
use std::fmt::{Display, Formatter};
use std::ops::{Add, Div, Mul, Sub};
use std::str::FromStr;

uint::construct_uint!(
    pub struct U384(6);
);

pub type WBigDecimal = U128;

pub(crate) const MAX_RATIO: u32 = 10000;

pub const NUM_DECIMALS: u8 = 24;
const BIG_DIVISOR: u128 = 10u128.pow(NUM_DECIMALS as u32);
const HALF_DIVISOR: u128 = BIG_DIVISOR / 2;

pub type LowU128 = U128;

#[derive(Copy, Clone)]
pub struct BigDecimal(pub U384);

impl Default for BigDecimal {
    fn default() -> Self {
        BigDecimal::zero()
    }
}

impl Display for BigDecimal {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        let a = self.0 / U384::from(BIG_DIVISOR);
        let b = (self.0 - a * U384::from(BIG_DIVISOR)).as_u128();
        if b > 0 {
            write!(f, "{}", format!("{}.{:024}", a, b).trim_end_matches('0'))
        } else {
            write!(f, "{}.0", a)
        }
    }
}

impl std::fmt::Debug for BigDecimal {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self)
    }
}

const PARSE_INT_ERROR: &str = "Parse int error";

impl FromStr for BigDecimal {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let dot_pos = s.find('.');
        let (int, dec) = if let Some(dot_pos) = dot_pos {
            (
                &s[..dot_pos],
                format!("{:0<24}", &s[dot_pos + 1..])
                    .parse()
                    .map_err(|_| PARSE_INT_ERROR)?,
            )
        } else {
            (s, 0u128)
        };
        let int = U384::from_str(int).map_err(|_| PARSE_INT_ERROR)?;
        if dec >= BIG_DIVISOR {
            return Err(String::from("The decimal part is too large"));
        }
        Ok(Self(int * U384::from(BIG_DIVISOR) + U384::from(dec)))
    }
}

impl Serialize for BigDecimal {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(&self.to_string())
    }
}

impl<'de> Deserialize<'de> for BigDecimal {
    fn deserialize<D>(
        deserializer: D,
    ) -> Result<Self, <D as near_sdk::serde::Deserializer<'de>>::Error>
    where
        D: near_sdk::serde::Deserializer<'de>,
    {
        let s: String = Deserialize::deserialize(deserializer)?;
        Self::from_str(&s).map_err(near_sdk::serde::de::Error::custom)
    }
}

impl From<u128> for BigDecimal {
    fn from(a: u128) -> Self {
        Self(U384::from(a) * U384::from(BIG_DIVISOR))
    }
}

impl From<u64> for BigDecimal {
    fn from(a: u64) -> Self {
        Self(U384::from(a) * U384::from(BIG_DIVISOR))
    }
}

impl From<u32> for BigDecimal {
    fn from(a: u32) -> Self {
        Self(U384::from(a) * U384::from(BIG_DIVISOR))
    }
}

impl From<i32> for BigDecimal {
    fn from(a: i32) -> Self {
        Self(U384::from(a) * U384::from(BIG_DIVISOR))
    }
}

impl From<f64> for BigDecimal {
    fn from(a: f64) -> Self {
        let base = a as u128;
        Self(
            U384::from(base) * U384::from(BIG_DIVISOR)
                + U384::from((a.fract() * (BIG_DIVISOR as f64)) as u128),
        )
    }
}

impl Add for BigDecimal {
    type Output = Self;

    fn add(self, rhs: BigDecimal) -> Self::Output {
        Self(self.0 + rhs.0)
    }
}

impl Sub for BigDecimal {
    type Output = Self;

    fn sub(self, rhs: BigDecimal) -> Self::Output {
        Self(self.0 - rhs.0)
    }
}

impl Mul for BigDecimal {
    type Output = Self;

    fn mul(self, rhs: Self) -> Self::Output {
        Self((self.0 * rhs.0 + U384::from(HALF_DIVISOR)) / U384::from(BIG_DIVISOR))
    }
}

impl Div for BigDecimal {
    type Output = Self;

    fn div(self, rhs: Self) -> Self::Output {
        Self((self.0 * U384::from(BIG_DIVISOR) + U384::from(HALF_DIVISOR)) / rhs.0)
    }
}

impl From<LowU128> for BigDecimal {
    fn from(low_u128: LowU128) -> Self {
        Self(U384::from(low_u128.0))
    }
}

impl From<BigDecimal> for LowU128 {
    fn from(bd: BigDecimal) -> Self {
        Self(bd.0.low_u128())
    }
}

impl BigDecimal {
    pub fn from_ratio(ratio: u32) -> Self {
        Self(U384::from(ratio) * U384::from(BIG_DIVISOR / (MAX_RATIO as u128)))
    }

    pub fn mul_ratio(&self, ratio: u32) -> Self {
        Self((self.0 * U384::from(ratio) + U384::from(MAX_RATIO / 2)) / U384::from(MAX_RATIO))
    }

    pub fn div_ratio(&self, ratio: u32) -> Self {
        Self((self.0 * U384::from(MAX_RATIO) + U384::from(MAX_RATIO / 2)) / U384::from(ratio))
    }

    pub fn round_u128(&self) -> u128 {
        ((self.0 + U384::from(HALF_DIVISOR)) / U384::from(BIG_DIVISOR)).as_u128()
    }

    #[cfg(not(target_arch = "wasm32"))]
    pub fn f64(&self) -> f64 {
        let base = (self.0 / U384::from(BIG_DIVISOR)).as_u128();
        let fract = (self.0 - U384::from(base)).as_u128() as f64;
        base as f64 + fract / (BIG_DIVISOR as f64)
    }

    pub fn round_mul_u128(&self, rhs: u128) -> u128 {
        ((self.0 * U384::from(rhs) + U384::from(HALF_DIVISOR)) / U384::from(BIG_DIVISOR)).as_u128()
    }

    pub fn div_u128(&self, rhs: u128) -> BigDecimal {
        Self(self.0 / U384::from(rhs))
    }

    pub fn zero() -> Self {
        Self(U384::zero())
    }

    pub fn one() -> Self {
        Self(U384::from(BIG_DIVISOR))
    }

    pub fn pow(&self, mut exponent: u64) -> Self {
        let mut res = BigDecimal::one();
        let mut x = *self;

        while exponent != 0 {
            if (exponent & 1) != 0 {
                res = res * x;
            }
            exponent >>= 1;
            if exponent != 0 {
                x = x * x;
            }
        }

        res
    }
}

impl PartialEq<Self> for BigDecimal {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}

impl PartialOrd for BigDecimal {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        self.0.partial_cmp(&other.0)
    }
}

impl Eq for BigDecimal {}

impl Ord for BigDecimal {
    fn cmp(&self, other: &Self) -> Ordering {
        self.0.cmp(&other.0)
    }

    fn max(self, other: Self) -> Self
    where
        Self: Sized,
    {
        max_by(self, other, Ord::cmp)
    }

    fn min(self, other: Self) -> Self
    where
        Self: Sized,
    {
        min_by(self, other, Ord::cmp)
    }

    fn clamp(self, min: Self, max: Self) -> Self
    where
        Self: Sized,
    {
        assert!(min <= max);
        if self < min {
            min
        } else if self > max {
            max
        } else {
            self
        }
    }
}

impl BorshSerialize for BigDecimal {
    fn serialize<W: Write>(&self, writer: &mut W) -> std::io::Result<()> {
        BorshSerialize::serialize(&self.0 .0, writer)
    }
}

impl BorshDeserialize for BigDecimal {
    fn deserialize(buf: &mut &[u8]) -> std::io::Result<Self> {
        Ok(Self(U384(BorshDeserialize::deserialize(buf)?)))
    }
}

#[cfg(test)]
mod test {
    use std::str::FromStr;

    use crate::big_decimal::LowU128;
    use crate::big_decimal::BigDecimal;

    #[test]
    fn should_be_one_percent() {
        let one_percent = LowU128::from(10000000000000000000000u128);

        assert_eq!(
            BigDecimal::from(one_percent),
            BigDecimal::one() / BigDecimal::from(100u128)
        );
    }

    #[test]
    fn should_be_ten() {
        let ten = BigDecimal::from(10u128) * BigDecimal::one();

        assert_eq!(ten, BigDecimal::from(10u128));
    }

    #[test]
    fn should_be_0_0000000628() {
        assert_eq!(
            BigDecimal::from(LowU128::from(62800000000000000u128)),
            BigDecimal::from_str("0.0000000628").unwrap()
        );
    }
}

'''
'''--- src_V1/close_position.rs ---
use crate::*;
use crate::{Contract, ContractExt};

use near_sdk::env::{current_account_id, signer_account_id};
use near_sdk::json_types::U128;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{
    ext_contract, is_promise_success, near_bindgen, require, AccountId, Balance, Gas,
    PromiseOrValue,
};

pub const REF_FINANCE: &str = "ref-finance-101.testnet";
#[ext_contract(ext_self)]
trait ContractCallbackInterface {
    fn swap_callback(
        &mut self,
        min_amount_out: WBalance,
        position: Position,
    ) -> PromiseOrValue<Balance>;
}

/// Single swap action.
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Swap {
    /// Pool which should be used for swapping.
    pub pool_id: u64,
    /// Token to swap from.
    pub token_in: AccountId,
    /// Amount to exchange.
    /// If amount_in is None, it will take amount_out from previous step.
    /// Will fail if amount_in is None on the first step.
    pub amount_in: Option<U128>,
    /// Token to swap into.
    pub token_out: AccountId,
    /// Required minimum amount of token_out.
    pub min_amount_out: U128,
}

/// Single action. Allows to execute sequence of various actions initiated by an account.
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
#[serde(untagged)]
pub enum Action {
    Swap(Swap),
}

/// Message parameters to receive via token function call.
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
#[serde(untagged)]
enum TokenReceiverMessage {
    /// Alternative to deposit + execute actions call.
    Execute {
        force: bool,
        /// List of sequential actions.
        actions: Vec<Action>,
    },
}

#[near_bindgen]
impl Contract {
    /// calculate all fees
    /// execute swap of sell token to buy token
    /// deduce all fees from the resulting amount of buy token
    /// deduce profit fee = 10% (if position is profitable)
    pub fn close_position(&mut self, position_id: U128) -> PromiseOrValue<Balance> {
        let positions = self
            .positions
            .get(&signer_account_id())
            .unwrap_or_else(|| panic!("Positions for account: {} not found.", signer_account_id()));
        let position = positions
            .get(&position_id.0)
            .unwrap_or_else(|| panic!("Position with id: {} not found.", position_id.0));

        require!(position.active, "Position not active.");

        // TODO Receive min_amount_out (from UI?)
        let min_amount_out = U128::from(
            BigDecimal::from(U128::from(position.borrow_amount))
                * self.calculate_xrate(position.buy_token.clone(), position.sell_token.clone()),
        );
        log!("min_amount_out {}", min_amount_out.0);

        self.execute_position(position.clone(), min_amount_out)
    }

    fn execute_position(
        &mut self,
        position: Position,
        min_amount_out: U128,
    ) -> PromiseOrValue<Balance> {
        let actions: Vec<Action> = vec![Action::Swap(Swap {
            pool_id: self.pool_id,
            token_in: position.buy_token.clone(),
            amount_in: Some(position.borrow_amount.into()),
            token_out: position.sell_token.clone(),
            min_amount_out,
        })];

        let action = TokenReceiverMessage::Execute {
            force: true,
            actions,
        };

        log!(
            "action {}",
            near_sdk::serde_json::to_string(&action).unwrap()
        );

        ext_token::ext(position.buy_token.clone())
            .with_static_gas(Gas(3))
            .with_attached_deposit(1)
            .ft_transfer_call(
                REF_FINANCE.parse().unwrap(),
                position.borrow_amount.into(),
                Some("Deposit tokens".to_string()),
                near_sdk::serde_json::to_string(&action).unwrap(),
            )
            .then(
                ext_self::ext(current_account_id())
                    .with_static_gas(Gas(20))
                    .with_attached_deposit(NO_DEPOSIT)
                    .swap_callback(min_amount_out, position),
            )
            .into()
    }

    #[private]
    pub fn swap_callback(
        &mut self,
        min_amount_out: WBalance,
        position: Position,
    ) -> PromiseOrValue<WBalance> {
        require!(is_promise_success(), "Some problem with swap tokens");

        // let market_id = self
        //     .tokens_markets
        //     .get(&position.sell_token.clone())
        //     .unwrap();
        // let market_data = self.get_market_data(position.sell_token.clone(), market_id.clone());
        // let borrow_fee = market_data.borrow_rate_ratio.0;
        // let swap_fee = self.exchange_fee(amount.0);
        // let fee = borrow_fee + swap_fee;
        // self.decrease_user_deposit(market_id.clone(), signer_account_id(), U128(fee));

        let sell_token_price = self.get_price_by_token(position.sell_token.clone());
        let _pnl = self.calculate_pnl(
            U128(position.buy_token_price),
            sell_token_price,
            U128(position.collateral_amount),
            U128(position.leverage),
        );
        self.increase_user_deposit(
            position.sell_token.clone(),
            signer_account_id(),
            U128::from(min_amount_out.0 - position.borrow_amount),
        );

        // if pnl.0 {
        //     let fee_amount = WBigDecimal::from(position.collateral_amount);
        //     self.decrease_user_deposit(
        //         position.sell_token.clone(),
        //         signer_account_id(),
        //         fee_amount,
        //     );
        // }

        let mut position = position;
        position.active = false;

        let mut positions = self.positions.get(&signer_account_id()).unwrap();
        positions.insert(position.position_id, position);
        self.positions.insert(&signer_account_id(), &positions);

        PromiseOrValue::Value(0.into())
    }

    #[private]
    pub fn set_pool_id(&mut self, pool_id: U128) {
        self.pool_id = pool_id.0 as u64;
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    
    use near_sdk::test_utils::test_env::{alice};
    use near_sdk::test_utils::VMContextBuilder;
    use near_sdk::{testing_env, VMContext};

    fn get_context(is_view: bool) -> VMContext {
        VMContextBuilder::new()
            .current_account_id("margin.nearland.testnet".parse().unwrap())
            .signer_account_id(alice())
            .predecessor_account_id("usdt_market.qa.nearland.testnet".parse().unwrap())
            .block_index(1)
            .block_timestamp(1)
            .is_view(is_view)
            .build()
    }

    #[test]
    fn test_close_position() {
        let context = get_context(false);
        testing_env!(context);
        let token1: AccountId = "usdt.qa.nearlend.testnet".parse().unwrap();
        let market1: AccountId = "usdt_market.qa.nearland.testnet".parse().unwrap();
        let token2: AccountId = "wnear.qa.nearland.testnet".parse().unwrap();
        let market2: AccountId = "wnear_market.qa.nearland.testnet".parse().unwrap();

        let token_markets: Vec<(AccountId, AccountId)> = vec![
            (token1.clone(), market1),
            (token2, market2),
        ];
        let mut contract = Contract::new(token_markets);
        let position_id = U128(1);

        //user deposit amount
        contract.increase_user_deposit(token1.clone(), alice(), U128(1000000000000000000000000000));
        let price_token1: Price = Price {
            value: U128(100 * 10_u128.pow(24)),
            fraction_digits: 1,
        };
        let price_token2: Price = Price {
            value: U128(100 * 10_u128.pow(24)),
            fraction_digits: 1,
        };
        contract.set_price(token1.clone(), price_token1);
        contract.set_price("wnear.qa.nearland.testnet".parse().unwrap(), price_token2);

        //open position
        contract.open_position(
            token1.clone(),
            U128(1000000000000000000000000000),
            "wnear.qa.nearland.testnet".parse().unwrap(),
            U128(2000000000000000000000000),
        );
        assert_eq!(1, contract.positions.len());

        //set market_data
        let market_data = MarketData {
            total_supplies: U128(100 * 10_u128.pow(24)),
            total_borrows: U128(100 * 10_u128.pow(24)),
            total_reserves: U128(10_u128.pow(24)),
            exchange_rate_ratio: U128(10_u128.pow(24)),
            interest_rate_ratio: U128(10_u128.pow(24)),
            borrow_rate_ratio: U128(10_u128.pow(24)),
        };
        let mut market = LookupMap::new(b"market_data".to_vec());
        market.insert(&token1.clone(), &market_data);
        contract.markets_data.insert(&token1, &market);

        let mut position = contract.get_position(position_id);

        //set all fee's
        contract.set_exchange_fee(U128(2 * 10_u128.pow(24)));
        contract.set_referral_fee(U128(4 * 10_u128.pow(24)));
        contract.set_total_fee(U128(3 * 10_u128.pow(24)));

        // swap callback
        let amount = 100;
        let market_id = contract.tokens_markets.get(&position.sell_token).unwrap();
        let borrow_fee = market_data.borrow_rate_ratio.0;
        let swap_fee = contract.exchange_fee(amount);
        let fee = borrow_fee + swap_fee;
        println!(
            "market_id: {}, borrow_fee: {}, swap_fee: {}, fee: {}",
            market_id, borrow_fee, swap_fee, fee
        );

        contract.decrease_user_deposit(token1.clone(), alice(), U128(fee));
        let user_profile = contract.user_profiles.get(&alice()).unwrap();
        let account_deposit = user_profile.account_deposits.get(&token1).unwrap();
        println!("account_deposit after decrease fee: {:?}", account_deposit);

        let sell_token_price = contract.get_price_by_token(position.sell_token.clone());
        let pnl = contract.calculate_pnl(
            WBigDecimal::from(position.buy_token_price),
            sell_token_price,
            WBigDecimal::from(position.collateral_amount),
            WBigDecimal::from(position.leverage),
        );
        println!("pnl: {:?}", pnl);
        let result = *account_deposit - WBigDecimal::from(pnl.1).0;
        if pnl.0 {
            let fee_amount = BigDecimal::from(position.collateral_amount) / BigDecimal::from(10_u128);
            contract.decrease_user_deposit(token1.clone(), alice(), WBigDecimal::from(fee_amount));
            contract.increase_user_deposit(token1.clone(), alice(), WBigDecimal::from(pnl.1));
        } else {
            contract.decrease_user_deposit(token1.clone(), alice(), WBigDecimal::from(pnl.1));
        }
        position.active = false;

        //update position
        let mut positions = contract.positions.get(&signer_account_id()).unwrap();
        positions.insert(position_id.0, position);
        contract.positions.insert(&signer_account_id(), &positions);

        //finish check
        let position = contract.get_position(U128(1));
        assert!(!position.active);

        let user_profile = contract.user_profiles.get(&alice()).unwrap();
        let account_deposit = user_profile.account_deposits.get(&token1).unwrap();
        println!("account_deposit: {:?}", account_deposit);
        assert_eq!(&result, account_deposit);
    }
}

'''
'''--- src_V1/common.rs ---
use crate::*;
use std::fmt;
use std::fmt::Formatter;

pub enum Events {
    BorrowFailedOnMarket(Balance),
}

impl fmt::Display for Events {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        match self {
            Events::BorrowFailedOnMarket(balance) => {
                write!(
                    f,
                    r#"EVENT_JSON:{{"standard": "nep297", "version": "1.0.0", "event": "BorrowFailedOnMarket", "data": {{"reason": "failed to get {} borrow on market "}}}}"#,
                    balance
                )
            }
        }
    }
}

'''
'''--- src_V1/fee.rs ---
use crate::*;

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Debug, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct MarketData {
    pub total_supplies: WBalance,
    pub total_borrows: WBalance,
    pub total_reserves: WBalance,
    pub exchange_rate_ratio: WBigDecimal,
    pub interest_rate_ratio: WBigDecimal,
    pub borrow_rate_ratio: WBigDecimal,
}

impl Default for MarketData {
    fn default() -> Self {
        Self {
            total_supplies: U128(0),
            total_borrows: U128(0),
            total_reserves: U128(0),
            exchange_rate_ratio: U128(0),
            interest_rate_ratio: U128(0),
            borrow_rate_ratio: U128(0),
        }
    }
}

#[near_bindgen]
impl Contract {
    pub fn update_market_data(&mut self, token_id: AccountId, market_id: AccountId) {
        underlying_token::ext(token_id.clone())
            .with_static_gas(Gas(12))
            .with_attached_deposit(1)
            .ft_balance_of(market_id.clone())
            .then(
                ext_self::ext(current_account_id())
                    .with_static_gas(Gas(9))
                    .with_attached_deposit(NO_DEPOSIT)
                    .update_market_data_callback(token_id, market_id),
            );
    }

    pub fn update_market_data_callback(&self, token_id: AccountId, market_id: AccountId) {
        require!(is_promise_success(), "Market not have balance.");
        let market_balance = match env::promise_result(0) {
            PromiseResult::NotReady => 0,
            PromiseResult::Successful(val) => {
                near_sdk::serde_json::from_slice::<Balance>(&val).unwrap()
            }
            PromiseResult::Failed => 0,
        };

        require!(market_balance > 0, "Balance not fount.");
        ext_market::ext(utils::MARKET_PLATFORM_ACCOUNT.parse().unwrap())
            .with_static_gas(Gas(7))
            .with_attached_deposit(1)
            .view_market_data(U128(market_balance))
            .then(
                ext_self::ext(current_account_id())
                    .with_static_gas(Gas(3))
                    .with_attached_deposit(NO_DEPOSIT)
                    .set_market_data(token_id, market_id),
            );
    }

    pub fn set_market_data(&mut self, token_id: AccountId, market_id: AccountId) {
        require!(is_promise_success(), "Some problem with market data.");
        let new_market_data = match env::promise_result(0) {
            PromiseResult::NotReady => MarketData::default(),
            PromiseResult::Successful(val) => {
                if let Ok(data) = near_sdk::serde_json::from_slice::<MarketData>(&val) {
                    data
                } else {
                    MarketData::default()
                }
            }
            PromiseResult::Failed => MarketData::default(),
        };
        let mut market_data = LookupMap::new(b"market_data".to_vec());
        market_data.insert(&market_id, &new_market_data);
        self.markets_data.insert(&token_id, &market_data);
    }

    pub fn get_market_data(&self, token_id: AccountId, market_id: AccountId) -> MarketData {
        let market = self.markets_data.get(&token_id).unwrap_or_else(|| {
            panic!("Market by token not found");
        });
        
        market.get(&market_id).unwrap_or_else(|| {
            panic!("Market data by market id not found");
        })
    }

    pub fn exchange_fee(&self, amount: Balance) -> Balance {
        let mut exchange_fee = 0;
        let trade_fee = self.trade_fee(amount);
        let admin_fee = (self.exchange_fee + self.referral_fee) as u128;
        let admin_fee_trade = self.admin_trade_fee(trade_fee, admin_fee);
        if self.referral_fee + self.exchange_fee > 0 {
            let fee_token = admin_fee * self.referral_fee as u128
                / (self.referral_fee + self.exchange_fee) as u128;
            exchange_fee = admin_fee_trade - fee_token
        }
        exchange_fee
    }

    fn trade_fee(&self, amount: Balance) -> Balance {
        amount * self.total_fee as u128 / (utils::FEE_DIVISOR as u128)
    }

    fn admin_trade_fee(&self, amount: Balance, admin_fee: Balance) -> Balance {
        amount * admin_fee / (utils::FEE_DIVISOR as u128)
    }

    #[private]
    pub fn set_exchange_fee(&mut self, exchange_fee: U128) {
        self.exchange_fee = exchange_fee.0 as u32
    }

    pub fn get_exchange_fee(&self) -> U128 {
        U128(self.exchange_fee as u128)
    }

    #[private]
    pub fn set_referral_fee(&mut self, referral_fee: U128) {
        self.exchange_fee = referral_fee.0 as u32
    }

    pub fn get_referral_fee(&self) -> U128 {
        U128(self.referral_fee as u128)
    }

    #[private]
    pub fn set_total_fee(&mut self, total_fee: U128) {
        self.total_fee = total_fee.0 as u32
    }

    pub fn get_total_fee(&self) -> U128 {
        U128(self.total_fee as u128)
    }
}

'''
'''--- src_V1/lib.rs ---
extern crate core;
mod close_position;
mod common;
mod fee;
mod open_position;
mod position;
mod price;
mod big_decimal;
mod user_profile;
mod utils;
mod views;

const NO_DEPOSIT: u128 = 0;
const GAS_FOR_BORROW: Gas = Gas(180_000_000_000_000);
const WNEAR_MARKET: &str = "wnear_market.qa.nearlend.testnet";

use crate::common::Events;
use crate::fee::MarketData;
use crate::big_decimal::*;
use crate::user_profile::UserProfile;
use crate::utils::{ext_token, WBalance};

use std::collections::HashMap;
use std::hash::Hash;
use std::str::FromStr;

use crate::price::Price;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LookupMap, LookupSet, UnorderedMap};
use near_sdk::env::{current_account_id, signer_account_id};
use near_sdk::json_types::U128;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{
    env, ext_contract, is_promise_success, log, near_bindgen, require, AccountId, Balance,
    BorshStorageKey, Gas, PromiseOrValue, PromiseResult,
};

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
#[derive(Debug, Clone)]
pub enum PositionType {
    Long,
    Short,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
#[derive(Debug, Clone)]
pub struct Position {
    position_id: u128,
    active: bool,
    p_type: PositionType,
    sell_token: AccountId,
    buy_token: AccountId,
    collateral_amount: Balance,
    buy_token_price: Balance,
    sell_token_price: Balance,
    leverage: u128,
    borrow_amount: Balance,
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Contract {
    /// number of all positions
    total_positions: u128,

    ///  user_id -> position_id -> position
    positions: UnorderedMap<AccountId, HashMap<u128, Position>>,

    /// User Account ID -> market address -> collaterals
    /// User Account ID -> market address -> borrows
    user_profiles: UnorderedMap<AccountId, UserProfile>,

    /// Market we are working with that are allowed to alter contracts field
    /// "wnear_market.qa.nearlend.testnet", "usdt_market.qa.nearlend.testnet"
    markets: LookupSet<AccountId>,

    /// token ID -> Price
    pub prices: LookupMap<AccountId, Price>,

    /// token id -> market id
    tokens_markets: LookupMap<AccountId, AccountId>,

    /// pool fee
    total_fee: u32,

    /// Exchange fee, that goes to exchange itself (managed by governance).
    exchange_fee: u32,

    /// Referral fee, that goes to referrer in the call.
    referral_fee: u32,

    /// List of all the pools.
    /// data about markets
    /// first AccountId -> Token
    /// second AccountId -> Market
    markets_data: LookupMap<AccountId, LookupMap<AccountId, MarketData>>,

    /// Pool which should be used for swapping.
    pool_id: u64,
}

impl Default for Contract {
    fn default() -> Self {
        env::panic_str("Margin trading contract should be initialized before usage")
    }
}

#[derive(BorshSerialize, BorshStorageKey)]
pub enum StorageKeys {
    Positions,
    UserProfiles,
    Markets,
    Prices,
    MarketsData,
    TokenMarkets,
    Vector,
}

#[ext_contract(underlying_token)]
trait UnderlineTokenInterface {
    fn ft_balance_of(&self, account_id: AccountId) -> U128;
}

#[ext_contract(ext_self)]
trait ContractCallbackInterface {
    fn borrow_buy_token_callback(&self, amount: WBalance);
    fn update_market_data_callback(&self, token_id: AccountId, market_id: AccountId);
    fn set_market_data(&self, token_id: AccountId, market_id: AccountId);
    fn withdraw_callback(&self, token_id: AccountId, amount: U128);
}

#[ext_contract(ext_market)]
trait MarketInterface {
    fn borrow(&mut self, amount: WBalance) -> PromiseOrValue<U128>;
    fn view_market_data(&self, ft_balance: WBalance) -> MarketData;
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new(tokens_markets: Vec<(AccountId, AccountId)>) -> Self {
        require!(!env::state_exists(), "Already initialized");

        let mut lookup_markets = LookupSet::new(StorageKeys::Markets);
        let mut lookup_tm = LookupMap::new(StorageKeys::TokenMarkets);
        for tm in tokens_markets.iter() {
            lookup_tm.insert(&tm.0, &tm.1);
            lookup_markets.insert(&tm.1);
        }

        Self {
            total_positions: 0,
            positions: UnorderedMap::new(StorageKeys::Positions),
            user_profiles: UnorderedMap::new(StorageKeys::UserProfiles),
            markets: lookup_markets,
            prices: LookupMap::new(StorageKeys::Prices),
            tokens_markets: lookup_tm,
            total_fee: 0,
            exchange_fee: 0,
            referral_fee: 0,
            markets_data: LookupMap::new(StorageKeys::MarketsData),
            pool_id: 0,
        }
    }

    #[private]
    pub fn get_position(&self, position_id: U128) -> Position {
        self.positions
            .get(&env::signer_account_id())
            .unwrap()
            .get(&position_id.0)
            .unwrap()
            .clone()
    }

    pub fn liquidate_position(_position_id: U128) {}

    pub fn borrow_buy_token(&self, amount: U128) {
        require!(
            env::prepaid_gas() >= GAS_FOR_BORROW,
            "Prepaid gas is not enough for borrow flow"
        );

        assert!(
            Balance::from(amount) > 0,
            "Amount should be a positive number"
        );

        ext_market::ext(AccountId::try_from(WNEAR_MARKET.to_string()).unwrap())
            .with_static_gas(GAS_FOR_BORROW)
            .with_attached_deposit(NO_DEPOSIT)
            .borrow(amount)
            .then(
                ext_self::ext(current_account_id())
                    .with_static_gas(Gas(3))
                    .with_attached_deposit(NO_DEPOSIT)
                    .borrow_buy_token_callback(amount),
            );
    }

    pub fn get_user_profile(&self, user_id: AccountId) -> UserProfile {
        self.user_profiles.get(&user_id).unwrap_or_default()
    }

    pub fn increase_user_deposit(
        &mut self,
        market_id: AccountId,
        user_id: AccountId,
        amount: WBalance,
    ) {
        // assert!(
        //     self.is_valid_market_call(),
        //     "Only market is allowed to call this method"
        // );

        // if its not present in our structure insert users profile
        if self.user_profiles.get(&user_id).is_none() {
            self.user_profiles
                .insert(&user_id, &UserProfile::new(market_id.clone(), 0u128));
        }

        let mut user_profile: UserProfile = self.get_user_profile(user_id.clone());

        // if user has UserProfile, but deposited in different token
        if user_profile.account_deposits.get(&market_id).is_none() {
            user_profile.account_deposits.insert(market_id, amount.0);
            self.user_profiles.insert(&user_id, &user_profile);
        } else {
            let increased_balance =
                amount.0 + *user_profile.account_deposits.get(&market_id).unwrap();
            user_profile
                .account_deposits
                .insert(market_id, increased_balance);
        }
        self.user_profiles.insert(&user_id, &user_profile);
    }

    pub fn decrease_user_deposit(
        &mut self,
        market_id: AccountId,
        user_id: AccountId,
        amount: WBalance,
    ) {
        // assert!(
        //     self.is_valid_market_call(),
        //     "Only market is allowed to call this method"
        // );

        assert!(self.user_profiles.get(&user_id).is_some());

        let mut user_profile: UserProfile = self.get_user_profile(user_id.clone());

        // if user hasn't deposited yet
        let user_deposit_balance = user_profile
            .account_deposits
            .get(&market_id.clone())
            .unwrap_or_else(|| {
                panic!("User no have balance in token {}:", market_id.clone());
            });
        println!("user_deposit_balance: {}", user_deposit_balance);
        println!("amount: {}", &BigDecimal::from(amount));
        require!(
            user_deposit_balance >= &amount.0,
            "Not enough deposited balance"
        );
        let decreased_user_deposit = *user_deposit_balance - amount.0;
        user_profile
            .account_deposits
            .insert(market_id, decreased_user_deposit);
        self.user_profiles.insert(&user_id, &user_profile);
    }

    #[private]
    pub fn borrow_buy_token_callback(&self, amount: U128) {
        if !is_promise_success() {
            log!("{}", Events::BorrowFailedOnMarket(amount.0));
        }

        // omomo market returns Balance of Borrow if so was successful
        let _borrow_balance = match env::promise_result(0) {
            PromiseResult::NotReady => 0,
            PromiseResult::Failed => 0,
            PromiseResult::Successful(result) => near_sdk::serde_json::from_slice::<U128>(&result)
                .unwrap()
                .into(),
        };

        // TODO make smth with borrow_balance further edit field of collateral
        // for some user that borrowed (could edit borrow_buy_token signature )
    }

    pub fn calculate_pnl(
        &self,
        buy_token_price: WBigDecimal,
        sell_token_price: WBigDecimal,
        collateral_amount: WBigDecimal,
        leverage: U128,
    ) -> (bool, BigDecimal) {
        let borrow_amount =
            BigDecimal::from(buy_token_price) * BigDecimal::from(leverage.0) - BigDecimal::from(buy_token_price);
        let c_a = BigDecimal::from(collateral_amount) * BigDecimal::from(leverage.0);
        let div_value = borrow_amount / BigDecimal::from(sell_token_price)
            + BigDecimal::from(collateral_amount);
        let profit: bool;
        let result = if c_a > div_value {
            profit = true;
            c_a - div_value
        } else {
            profit = false;
            div_value - c_a
        };
        (profit, result)
    }

    #[allow(unused_variables)]
    pub fn get_liquidation_price(
        &self,
        sell_token_amount: U128,
        sell_token_price: U128,
        buy_token_price: U128,
        leverage: U128,
        borrow_fee: U128,
        swap_fee: U128,
    ) -> WBigDecimal {
        let sell_token = AccountId::new_unchecked("usdt.qa.nearlend.testnet".to_owned());
        let sell_token_price = self.get_price_by_token(sell_token);

        let buy_token = AccountId::new_unchecked("wnear.qa.nearlend.testnet".to_owned());
        let buy_token_price = self.get_price_by_token(buy_token);
        log!("buy_token_price {}", buy_token_price.0);

        let collateral_usd = BigDecimal::from(sell_token_amount) * BigDecimal::from(sell_token_price);
        let buy_amount = collateral_usd / BigDecimal::from(buy_token_price);

        let fee = BigDecimal::from_str("0.057").unwrap();
        let borrow_amount = collateral_usd * BigDecimal::from(leverage);

        (BigDecimal::from(buy_token_price) -  (collateral_usd - fee * borrow_amount) / buy_amount).into()
        // BigDecimal::from_str("2.41").unwrap().into()
    }

    #[payable]
    pub fn withdraw(&mut self, token_id: AccountId, amount: U128) {
        let balance = self.view_balance(env::signer_account_id(), token_id.clone());

        require!(
            balance.0 >= amount.0,
            format!("Account:{} not have enough balance", signer_account_id())
        );

        ext_token::ext(token_id.clone())
            .with_static_gas(self.terra_gas(5))
            .with_attached_deposit(1)
            .ft_transfer(
                signer_account_id(),
                amount,
                Some(format!(
                    "Withdraw from: {} amount: {}",
                    current_account_id(),
                    u128::try_from(amount).unwrap()
                )),
            )
            .then(
                ext_self::ext(current_account_id())
                    .with_static_gas(self.terra_gas(2))
                    .with_attached_deposit(NO_DEPOSIT)
                    .withdraw_callback(token_id, amount),
            );
    }

    #[private]
    pub fn withdraw_callback(&mut self, token_id: AccountId, amount: U128) {
        require!(is_promise_success(), "Error transfer");

        self.decrease_user_deposit(token_id, signer_account_id(), amount);
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    use near_sdk::test_utils::test_env::{alice, bob};
    use near_sdk::test_utils::VMContextBuilder;
    use near_sdk::{testing_env, VMContext};

    fn get_context(is_view: bool) -> VMContext {
        VMContextBuilder::new()
            .current_account_id(alice())
            .signer_account_id(bob())
            .predecessor_account_id("token_near".parse().unwrap())
            .block_index(1)
            .block_timestamp(1)
            .is_view(is_view)
            .build()
    }

    fn get_position() -> Position {
        //amount: 1000 * 10^24 USDT
        //leverage: 2.4 * 10^24
        //buy_token_price: 1.01 * 10^24
        //sell_token_price: 4.2 * 10^24
        Position {
            position_id: 0,
            active: true,
            p_type: PositionType::Long,
            sell_token: "usdc.nearland.testnet".parse().unwrap(),
            buy_token: "wnear.nearland.testnet".parse().unwrap(),
            collateral_amount: 1000 * 10_u128.pow(24),
            buy_token_price: 101 * 10_u128.pow(22),
            sell_token_price: 45 * 10_u128.pow(23),
            leverage: 24 * 10_u128.pow(23),
            borrow_amount: 404,
        }
    }

    fn get_position_examples() -> Position {
        //amount: 1 * 10^24 USDT
        //leverage: 3
        //buy_token_price: 3000 * 10^24
        //sell_token_price: 4100 * 10^24
        Position {
            position_id: 0,
            active: true,
            p_type: PositionType::Long,
            sell_token: "usdc.nearland.testnet".parse().unwrap(),
            buy_token: "wnear.nearland.testnet".parse().unwrap(),
            collateral_amount: 10_u128.pow(24),
            buy_token_price: 3000 * 10_u128.pow(24),
            sell_token_price: 4100 * 10_u128.pow(24),
            leverage: 3,
            borrow_amount: 404,
        }
    }

    #[test]
    fn test_pnl() {
        let context = get_context(false);
        testing_env!(context);
        let token_markets: Vec<(AccountId, AccountId)> = vec![
            (
                "usdt.nearland.testnet".parse().unwrap(),
                "usdt_market.nearland.testnet".parse().unwrap(),
            ),
            (
                "wnear.nearland.testnet".parse().unwrap(),
                "wnear_market.nearland.testnet".parse().unwrap(),
            ),
        ];
        let contract = Contract::new(token_markets);

        let position = get_position_examples();
        let result = contract.calculate_pnl(
            WBigDecimal::from(position.buy_token_price),
            WBigDecimal::from(position.sell_token_price),
            WBigDecimal::from(position.collateral_amount),
            WBigDecimal::from(position.leverage),
        );

        assert_eq!(WBigDecimal::from(result.1), U128(536585365853658536585366));
    }

    #[test]
    fn test_liquidation_price() {
        let context = get_context(false);
        testing_env!(context);
        let token_markets: Vec<(AccountId, AccountId)> = vec![
            (
                "usdt.nearland.testnet".parse().unwrap(),
                "usdt_market.nearland.testnet".parse().unwrap(),
            ),
            (
                "wnear.nearland.testnet".parse().unwrap(),
                "wnear_market.nearland.testnet".parse().unwrap(),
            ),
        ];
        let contract = Contract::new(token_markets);
        let position = get_position();

        let result = contract.get_liquidation_price(
            WBigDecimal::from(1),
            WBigDecimal::from(position.sell_token_price),
            WBigDecimal::from(position.buy_token_price),
            WBigDecimal::from(position.leverage),
            U128(5 * 10_u128.pow(6)),
            U128(3 * 10_u128.pow(1)),
        );

        assert_eq!(result, U128(215745429394269796120481938246454935552));
    }
}

'''
'''--- src_V1/open_position.rs ---
use crate::*;
use near_sdk::near_bindgen;

#[near_bindgen]
impl Contract {
    pub fn open_position(
        &mut self,
        sell_token: AccountId,
        sell_token_amount: U128,
        buy_token: AccountId,
        leverage: U128,
    ) -> PromiseOrValue<U128> {
        require!(
            self.user_profiles.get(&env::signer_account_id()).is_some(),
            "User have to deposit first"
        );

        let user_profile = self.user_profiles.get(&env::signer_account_id()).unwrap();

        require!(
            user_profile.account_deposits.get(&sell_token).is_some(),
            "User don't have deposits in sell token"
        );

        require!(
            *user_profile.account_deposits.get(&sell_token).unwrap() >= sell_token_amount.0,
            "User don't have enough collateral deposited to proceed this action"
        );

        let xrate = self.calculate_xrate(sell_token.clone(), buy_token.clone());

        let borrow_token_amount =
            U128::from(BigDecimal::from(sell_token_amount) * xrate * BigDecimal::from(leverage));
        log!("borrowing amount {}", borrow_token_amount.0);

        self.borrow_buy_token(borrow_token_amount);

        self.insert_position(
            env::signer_account_id(),
            Position::new(
                self.total_positions,
                true,
                PositionType::Long,
                sell_token.clone(),
                buy_token.clone(),
                sell_token_amount.0,
                self.get_price_by_token(buy_token).0,
                self.get_price_by_token(sell_token).0,
                leverage.0,
                borrow_token_amount.0,
            ),
        );

        let borrow_amount = U128::from(BigDecimal::from(sell_token_amount) * BigDecimal::from(leverage));
        PromiseOrValue::Value(borrow_amount)
    }
}

impl Contract {
    pub fn insert_position(&mut self, user_id: AccountId, position: Position) {
        self.decrease_user_deposit(
            position.sell_token.clone(),
            user_id.clone(),
            position.collateral_amount.into(),
        );

        let mut positions: HashMap<u128, Position> = if self.positions.get(&user_id).is_none() {
            HashMap::new()
        } else {
            self.positions.get(&user_id).unwrap()
        };

        positions.insert(position.position_id, position);
        self.positions.insert(&user_id, &positions);

        self.total_positions += 1;
    }
}

'''
'''--- src_V1/position.rs ---

use crate::*;
use std::fmt;

use near_sdk::json_types::U128;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{AccountId, Balance};

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
#[derive(Debug)]
pub struct ViewPosition {
    pub active: bool,
    pub position_id: U128,
    pub p_type: PositionType,
    pub amount: WBalance,
    pub price: WBalance,
    pub fee: U128,
    pub sell_token: AccountId,
    pub buy_token: AccountId,
}

impl fmt::Display for ViewPosition {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}

impl Position {
    #[allow(clippy::too_many_arguments)]
    pub fn new(
        position_id: u128,
        active: bool,
        p_type: PositionType,
        sell_token: AccountId,
        buy_token: AccountId,
        collateral_amount: Balance,
        buy_token_price: Balance,
        sell_token_price: Balance,
        leverage: u128,
        borrow_amount: Balance,
    ) -> Position {
        Position {
            position_id,
            active,
            p_type,
            sell_token,
            buy_token,
            collateral_amount,
            buy_token_price,
            sell_token_price,
            leverage,
            borrow_amount,
        }
    }
}

'''
'''--- src_V1/price.rs ---
use crate::utils::Digits;
use crate::*;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
#[derive(Debug)]
pub struct Price {
    /// Ticker price value
    pub value: WBalance,

    /// Ticker precision digits number
    pub fraction_digits: Digits,
}

impl Price {
    pub fn new(value: Balance, fraction_digits: u32) -> Price {
        Price {
            value: WBalance::from(value),
            fraction_digits,
        }
    }
}

#[near_bindgen]
impl Contract {
    pub fn set_price(&mut self, market_id: AccountId, price: Price) {
        self.prices.insert(&market_id, &price);
    }

    pub fn get_price_by_token(&self, token_id: AccountId) -> WBalance {
        assert!(
            self.prices.get(&token_id).is_some(),
            "There no such prices set yet"
        );

        self.prices.get(&token_id).unwrap().value
    }

    pub fn calculate_xrate(&self, token_id_1: AccountId, token_id_2: AccountId) -> BigDecimal {
        BigDecimal::from(self.get_price_by_token(token_id_1))
            / BigDecimal::from(self.get_price_by_token(token_id_2))
    }
}

'''
'''--- src_V1/user_profile.rs ---
use crate::*;
use std::collections::HashMap;

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
#[derive(Default)]
pub struct UserProfile {
    /// market address -> deposits
    pub account_deposits: HashMap<AccountId, Balance>,
}

impl UserProfile {
    pub fn new(market_id: AccountId, balance: Balance) -> UserProfile {
        let mut user_deposits = HashMap::new();
        user_deposits.insert(market_id, balance);
        UserProfile {
            account_deposits: user_deposits,
        }
    }
}

'''
'''--- src_V1/utils.rs ---
use crate::*;

use near_sdk::{ext_contract, json_types::U128, AccountId};

pub type WBalance = U128;

pub const FEE_DIVISOR: u32 = 10_000;

pub type Digits = u32;

pub const TGAS: Gas = near_sdk::Gas::ONE_TERA;
pub const MARKET_PLATFORM_ACCOUNT: &str = "omomo.nearlend.testnet";

#[ext_contract(ext_token)]
pub(crate) trait NEP141Token {
    fn ft_transfer_call(
        &mut self,
        receiver_id: AccountId,
        amount: WBalance,
        memo: Option<String>,
        msg: String,
    );

    fn ft_transfer(&mut self, receiver_id: AccountId, amount: WBalance, memo: Option<String>);
}

impl Contract {
    pub fn is_valid_market_call(&self) -> bool {
        self.markets.contains(&env::predecessor_account_id())
    }

    pub fn terra_gas(&self, gas: u64) -> Gas {
        TGAS * gas
    }
}

'''
'''--- src_V1/views.rs ---
use crate::position::ViewPosition;
use crate::big_decimal::BigDecimal;
use crate::*;
use near_sdk::near_bindgen;
use std::str::FromStr;

#[near_bindgen]
impl Contract {
    pub fn view_balance(&self, user: AccountId, market: AccountId) -> WBalance {
        if self.user_profiles.get(&user).is_none() {
            U128::from(0)
        } else {
            let user_profile = self.user_profiles.get(&user).unwrap();

            if !user_profile.account_deposits.contains_key(&market) {
                U128::from(0)
            } else {
                U128::from(*user_profile.account_deposits.get(&market).unwrap())
            }
        }
    }

    #[allow(unused_variables)]
    pub fn view_user_positions(&self, market: AccountId, user: AccountId) -> Vec<ViewPosition> {
        if self.positions.get(&user).is_none() {
            return vec![];
        }

        self.positions
            .get(&user)
            .unwrap()
            .values()
            .map(|position| {
                let borrow_amount = U128::from(
                    BigDecimal::from(U128::from(position.collateral_amount))
                        * BigDecimal::from(U128::from(position.leverage)),
                );
                let price = self.get_price_by_token(position.buy_token.clone());

                ViewPosition {
                    active: position.active,
                    position_id: position.position_id.into(),
                    p_type: position.p_type.clone(),
                    amount: borrow_amount,
                    price,
                    fee: BigDecimal::from_str("0.3").unwrap().into(),
                    sell_token: position.sell_token.clone(),
                    buy_token: position.buy_token.clone(),
                }
            })
            .collect()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use near_sdk::test_utils::test_env::{alice, bob};
    use near_sdk::test_utils::VMContextBuilder;
    use near_sdk::testing_env;
    use std::str::FromStr;

    #[test]
    fn test_view_balance() {
        let (owner_account, user_account, market) = (
            alice(),
            bob(),
            AccountId::from_str("usdt.qa.nearlend.testnet").unwrap(),
        );

        let token_markets: Vec<(AccountId, AccountId)> = vec![
            (
                "usdt.qa.nearlend.testnet".parse().unwrap(),
                "usdt_market.qa.nearlend.testnet".parse().unwrap(),
            ),
            (
                "wnear.nearland.testnet".parse().unwrap(),
                "wnear_market.nearland.testnet".parse().unwrap(),
            ),
        ];

        let contract = Contract::new(token_markets);

        let context = VMContextBuilder::new()
            .signer_account_id(owner_account.clone())
            .predecessor_account_id(owner_account)
            .build();

        testing_env!(context);

        assert_eq!(contract.view_balance(user_account, market), U128(0));
    }

    #[test]
    fn test_view_user_positions() {
        let (owner_account, user_account, market) = (
            alice(),
            bob(),
            AccountId::from_str("usdt.qa.nearlend.testnet").unwrap(),
        );

        let token_markets: Vec<(AccountId, AccountId)> = vec![
            (
                "usdt.qa.nearlend.testnet".parse().unwrap(),
                "usdt_market.qa.nearlend.testnet".parse().unwrap(),
            ),
            (
                "wnear.nearland.testnet".parse().unwrap(),
                "wnear_market.nearland.testnet".parse().unwrap(),
            ),
        ];

        let contract = Contract::new(token_markets);

        let context = VMContextBuilder::new()
            .signer_account_id(owner_account.clone())
            .predecessor_account_id(owner_account)
            .build();

        testing_env!(context);

        dbg!(contract.view_user_positions(user_account, market));
    }
}

'''
'''--- swap.sh ---
#!/bin/bash

# extend whitelisted tokens
near call margin1.nearlend.testnet add_available_tokens '{"tokens": ["usdt.qa.nearlend.testnet", "wnear.qa.nearlend.testnet"]}' --account-id margin1.nearlend.testnet --amount 1 --gas 300000000000000

near call ref-finance-101.testnet storage_deposit '{"account_id": "margin1.nearlend.testnet"}' --accountId nearlend.testnet --amount 0.25

# create simple pool
near call margin1.nearlend.testnet set_pool_id '{"tokens": ["usdt.qa.nearlend.testnet", "wnear.qa.nearlend.testnet"], "fee": 25}' --account-id margin1.nearlend.testnet --amount 0.3 --gas 300000000000000

# create zero balances
near call margin1.nearlend.testnet register_tokens '{"tokens":  ["usdt.qa.nearlend.testnet", "wnear.qa.nearlend.testnet"]}' --account-id margin1.nearlend.testnet --amount 1 --gas 300000000000000

# fund tokens (before it contract must have balance in deposit tokens)
near call usdt.qa.nearlend.testnet storage_deposit '{"account_id": "ref-finance-101.testnet"}' --accountId nearlend.testnet --amount 0.25

near call margin1.nearlend.testnet deposit_tokens '{"token_id": "usdt.qa.nearlend.testnet", "amount": "100"}' --account-id margin1.nearlend.testnet --amount 0.25 --gas 300000000000000

near call wnear.qa.nearlend.testnet storage_deposit '{"account_id": "ref-finance-101.testnet"}' --accountId nearlend.testnet --amount 0.25
near call margin1.nearlend.testnet deposit_tokens '{"token_id": "wnear.qa.nearlend.testnet", "amount": "100"}' --account-id margin1.nearlend.testnet --amount 0.25 --gas 300000000000000

# add liquidity
near call margin1.nearlend.testnet add_liquidity '{ "amounts": "10" }' --account-id margin1.nearlend.testnet --amount 1 --gas 300000000000000

# swap
near call margin1.nearlend.testnet execute_position '{ "token_in": "wnear.qa.nearlend.testnet", "amount_in": "1000000000000000000000000", "token_out": "usdt.qa.nearlend.testnet", "min_amount_out": "4129490024018948000000000"}' --account-id margin1.nearlend.testnet --gas 300000000000000
'''
'''--- swap_deploy.sh ---
# login
#near login

# build & test
./build.sh && ./test.sh

# clean up previuos deployment
echo 'y' | near delete margin1.nearlend.testnet nearlend.testnet

# create corresponding accoutns
near create-account margin1.nearlend.testnet --masterAccount nearlend.testnet --initialBalance 20

# redeploy contracts
near deploy margin1.nearlend.testnet \
    --wasmFile ./res/mtrading.wasm \
    --initFunction "new" \
    --initArgs '{"markets": ["usdt.qa.nearlend.testnet", "wnear.qa.nearlend.testnet"]}'
'''
'''--- test.sh ---
#!/bin/bash
set -e

cargo test --manifest-path ./Cargo.toml -- --nocapture

'''
'''--- userflow.sh ---
near call  usdt.qa.v1.nearlend.testnet ft_transfer_call '{"receiver_id": "limit_orders.v1.nearlend.testnet", "amount": "2000000000000000000000000000", "msg": "{\"Deposit\": {\"token\": \"usdt.qa.v1.nearlend.testnet\"}}"}' --accountId nearlend.testnet --depositYocto 1 --gas 32000000000000

near view limit_orders.v1.nearlend.testnet balance_of '{"account_id": "nearlend.testnet", "token": "usdt.qa.v1.nearlend.testnet" }' 

# amount = 1000.0
# leverage = 1.0
near call limit_orders.v1.nearlend.testnet create_order '{
    "order_type": "Buy",
    "amount": "1000000000000000000000000000",
    "sell_token": "usdt.qa.v1.nearlend.testnet",
    "buy_token": "wnear.qa.v1.nearlend.testnet",
    "leverage": "1000000000000000000000000" 
}' --accountId nearlend.testnet --gas 300000000000000

near call limit_orders.v1.nearlend.testnet create_order '{
    "order_type": "Buy",
    "amount": "1000000000000000000000000000",
    "sell_token": "usdt.qa.v1.nearlend.testnet",
    "buy_token": "wnear.qa.v1.nearlend.testnet",
    "leverage": "1000000000000000000000000" 
}' --accountId nearlend.testnet --gas 300000000000000

near view limit_orders.v1.nearlend.testnet view_orders '{
    "account_id":"nearlend.testnet",
    "buy_token":"wnear.qa.v1.nearlend.testnet",
    "sell_token":"usdt.qa.v1.nearlend.testnet"
}'

near view dcl.ref-dev.testnet get_pool '{
    "pool_id": "usdt.qa.v1.nearlend.testnet|wnear.qa.v1.nearlend.testnet|2000"
}'

near view dcl.ref-dev.testnet get_pool '{
    "pool_id": "usdt.qa.v1.nearlend.testnet|wnear.qa.v1.nearlend.testnet|2000"
}'

near view dcl.ref-dev.testnet get_liquidity '{
    "lpt_id": "usdt.qa.v1.nearlend.testnet|wnear.qa.v1.nearlend.testnet|2000#193"
}'

for i in {250..260}
for i in 236 262 256 239 252 241 242 246
do
    near call dcl.ref-dev.testnet remove_liquidity '{
        "lpt_id": "usdt.qa.v1.nearlend.testnet|wnear.qa.v1.nearlend.testnet|2000#'$i'",
        "amount": "14209047472819294933719294",
        "min_amount_x": "0",
        "min_amount_y": "0"
    }' --accountId limit_orders.v1.nearlend.testnet --gas 300000000000000 &
done
wait

# swap_fee 0.002 = 0.2%
# price_impact 0.05 = 5%
near call limit_orders.v1.nearlend.testnet cancel_order '{
    "order_id": "4",
    "swap_fee": "2000000000000000000000",
    "price_impact": "50000000000000000000000"
}' --accountId nearlend.testnet --gas 300000000000000

near view usdt_market.qa.v1.nearlend.testnet get_eligible_to_borrow_uncollateralized_account '{ "account": "limit_orders.v1.nearlend.testnet" }' --accountId shared_admin.testnet

near view controller.qa.v1.nearlend.testnet get_eligible_to_borrow_uncollateralized_account '{ "account": "limit_orders.v1.nearlend.testnet" }'

near call usdt_market.qa.v1.nearlend.testnet borrow '{
    "amount": "1000000000000000000000000000"
}' --accountId limit_orders.v1.nearlend.testnet --gas 195000000000000

# Add orders
# near call  usdt.qa.v1.nearlend.testnet ft_transfer_call '{"receiver_id": "limit_orders.v1.nearlend.testnet", "amount": "3000000000000000000000000000", "msg": "{\"Deposit\": {\"token\": \"usdt.qa.v1.nearlend.testnet\"}}"}' --accountId nearlend.testnet --depositYocto 1 --gas 32000000000000

near view limit_orders.v1.nearlend.testnet balance_of '{"account_id": "nearlend.testnet", "token": "usdt.qa.v1.nearlend.testnet" }' 

# amount = 1000.0
# leverage = 2.0
# near call limit_orders.v1.nearlend.testnet borrow '{
#     "token": "usdt.qa.v1.nearlend.testnet",
#     "amount": "1000000000000000000000000000",
#     "leverage": "2000000000000000000000000"
# }' --accountId nearlend.testnet --gas 300000000000000

# near call limit_orders.v1.nearlend.testnet create_order '{
#     "order_type": "Buy",
#     "amount": "1000000000000000000000000000",
#     "sell_token": "usdt.qa.v1.nearlend.testnet",
#     "buy_token": "wnear.qa.v1.nearlend.testnet",
#     "leverage": "2000000000000000000000000",
#     "pool_info": {
#         "point_delta": 40,
#         "current_point": -11333
#     }
# }' --accountId nearlend.testnet --gas 300000000000000

# amount = 1000.0
# leverage = 1.0
# near call limit_orders.v1.nearlend.testnet create_order '{
#     "order_type": "Buy",
#     "amount": "1000000000000000000000000000",
#     "sell_token": "usdt.qa.v1.nearlend.testnet",
#     "buy_token": "wnear.qa.v1.nearlend.testnet",
#     "leverage": "1000000000000000000000000",
#     "pool_info": {
#         "point_delta": 40,
#         "current_point": -11333
#     } 
# }' --accountId nearlend.testnet --gas 300000000000000

near call limit_orders.v1.nearlend.testnet execute_order '{
    "order_id": "2"
}' --accountId nearlend.testnet --gas 300000000000000

near view limit_orders.v1.nearlend.testnet view_orders '{
    "account_id":"nearlend.testnet",
    "buy_token":"wnear.qa.v1.nearlend.testnet",
    "sell_token":"usdt.qa.v1.nearlend.testnet"
}'
'''