*GitHub Repository "mattlockyer/near-collections"*

'''--- .eslintrc.js ---
module.exports = {
	parserOptions: {
		ecmaVersion: 2020,
        sourceType: 'module',
        ecmaFeatures: {
            jsx: true,
        }
    },
	rules: {
        semi: [2, 'always'],
        indent: [2, 'tab'],
	}
};

'''
'''--- README.md ---
# WIP

This is an experimental repo.

# (from boilerplate) React 17, Parcel with useContext and useReducer
- Bundled with Parcel 2.0.1
- *Minimal all-in-one state management with async/await support*

## Getting Started: State Store & useContext

>The following steps are already done, but describe how to use `src/utils/state` to create and use your own `store` and `StateProvider`.

1. Create a file e.g. `/state/app.js` and add the following code
```js
import { State } from '../utils/state';

// example
const initialState = {
	app: {
		mounted: false
	}
};

export const { store, Provider } = State(initialState);
```
2. Now in your `index.js` wrap your `App` component with the `StateProvider`
```js
import { Provider } from './state/app';

ReactDOM.render(
    <Provider>
        <App />
    </Provider>,
    document.getElementById('root')
);
```
3. Finally in `App.js` you can `useContext(store)`
```js
const { state, dispatch, update } = useContext(store);
```

## Usage in Components
### Print out state values
```js
<p>Hello {state.foo && state.foo.bar.hello}</p>
```
### Update state directly in component functions
```js
const handleClick = () => {
    update('clicked', !state.clicked);
};
```
### Dispatch a state update function (action listener)
```js
const onMount = () => {
    dispatch(onAppMount('world'));
};
useEffect(onMount, []);
```
## Dispatched Functions with context (update, getState, dispatch)

When a function is called using dispatch, it expects arguments passed in to the outer function and the inner function returned to be async with the following json args: `{ update, getState, dispatch }`

Example of a call:
```js
dispatch(onAppMount('world'));
```

All dispatched methods **and** update calls are async and can be awaited. It also doesn't matter what file/module the functions are in, since the json args provide all the context needed for updates to state.

For example:
```js
import { helloWorld } from './hello';

export const onAppMount = (message) => async ({ update, getState, dispatch }) => {
	update('app', { mounted: true });
	update('clicked', false);
	update('data', { mounted: true });
	await update('', { data: { mounted: false } });

	console.log('getState', getState());

	update('foo.bar', { hello: true });
	update('foo.bar', { hello: false, goodbye: true });
	update('foo', { bar: { hello: true, goodbye: false } });
	update('foo.bar.goodbye', true);

	await new Promise((resolve) => setTimeout(() => {
		console.log('getState', getState());
		resolve();
	}, 2000));

	dispatch(helloWorld(message));
};
```
## Prefixing store and Provider

The default names the `State` factory method returns are `store` and `Provider`. However, if you want multiple stores and provider contexts you can pass an additional `prefix` argument to disambiguate.

```js
export const { appStore, AppProvider } = State(initialState, 'app');
```

## Performance and memo

The updating of a single store, even several levels down, is quite quick. If you're worried about components re-rendering, use `memo`:
```js
import React, { memo } from 'react';

const HelloMessage = memo(({ message }) => {
	console.log('rendered message');
	return <p>Hello { message }</p>;
});

export default HelloMessage;
```
Higher up the component hierarchy you might have:
```js
const App = () => {
	const { state, dispatch, update } = useContext(appStore);
    ...
	const handleClick = () => {
		update('clicked', !state.clicked);
	};

	return (
		<div className="root">
			<HelloMessage message={state.foo && state.foo.bar.hello} />
			<p>clicked: {JSON.stringify(state.clicked)}</p>
			<button onClick={handleClick}>Click Me</button>
		</div>
	);
};
```
When the button is clicked, the component HelloMessage will not re-render, it's value has been memoized (cached). Using this method you can easily prevent performance intensive state updates in further down components until they are neccessary.

Reference:
- https://reactjs.org/docs/context.html
- https://dmitripavlutin.com/use-react-memo-wisely/

'''
'''--- contract/Cargo.toml ---
[package]
name = "near-cbp"
version = "0.1.0"
authors = ["Matt Lockyer <mattdlockyer@gmail.com>"]
edition = "2018"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = "4.0.0-pre.7"
near-contract-standards = "4.0.0-pre.7"
mini-colls = { path = "../mini-colls" }

[profile.release]
codegen-units = 1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- contract/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
mkdir -p ../out
cp target/wasm32-unknown-unknown/release/*.wasm ../out/main.wasm

'''
'''--- contract/src/lib.rs ---
#![feature(trivial_bounds)]

use near_sdk::{
	near_bindgen, PanicOnDefault,
	borsh::{self, BorshDeserialize, BorshSerialize},
};

use mini_colls::{
	IntMap
};

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
	map: IntMap,
}

#[near_bindgen]
impl Contract {

	#[init]
	pub fn new() -> Self {
		Self {
			map: Default::default()
		}
	}

	pub fn set(&mut self, val: String) -> Option<u64> {
		self.map.set(val.as_bytes())
	}

	pub fn update(&mut self, key: u64, val: String) -> bool {
		self.map.update(key, val.as_bytes())
	}

	pub fn del(&mut self, key: u64) -> String {
		String::from_utf8(self.map.del(key).unwrap()).unwrap()
	}

	pub fn get(&self, key: u64) -> String {
		String::from_utf8(self.map.get(key).unwrap()).unwrap()
	}

	pub fn get_key(&self, val: String) -> Option<u64> {
		self.map.get_key(val.as_bytes())
	}
}
    
	
'''
'''--- mini-colls/Cargo.toml ---
[package]
name = "mini-colls"
version = "0.1.0"
authors = ["Matt Lockyer <mattdlockyer@gmail.com>"]
edition = "2018"

[dependencies]
near-sdk = "4.0.0-pre.7"
near-contract-standards = "4.0.0-pre.7"

'''
'''--- mini-colls/src/lib.rs ---
use near_sdk::{
	borsh::{self, BorshDeserialize, BorshSerialize},
	env::{ storage_remove, storage_read, storage_write, storage_get_evicted }
};

#[derive(BorshSerialize, BorshDeserialize)]
pub struct DirectMap;

impl Default for DirectMap {
	fn default() -> Self {
		Self
	}
}

impl DirectMap {
    pub fn set(&mut self, key: &[u8], val: &[u8]) -> Option<Vec<u8>> {
        if storage_write(&key, val) {
			storage_get_evicted()
        } else {
            None
        }
    }

    pub fn del(&mut self, key: &[u8]) -> Option<Vec<u8>> {
        if storage_remove(&key) {
            storage_get_evicted()
        } else {
            None
        }
    }

    pub fn get(&self, key: &[u8]) -> Option<Vec<u8>> {
        storage_read(&key)
    }
}

#[derive(BorshSerialize, BorshDeserialize)]
pub struct IntMap {
	int: u64,
}

impl Default for IntMap {
	fn default() -> Self {
		Self {
			int: 0,
		}
	}
}

impl IntMap {
    pub fn set(&mut self, val: &[u8]) -> Option<u64> {
		let key = self.get_key(val);
        if key.is_some() {
			return key;
		}
		self.int += 1;
		let int_bytes = self.int.to_le_bytes();
		if storage_write(&int_bytes, val) || storage_write(val, &int_bytes) {
			return None;
		}
		Some(self.int)
    }

	pub fn update(&mut self, key: u64, val: &[u8]) -> bool {
		let int_bytes = key.to_le_bytes();
		if !storage_write(&int_bytes, val) || !storage_write(val, &int_bytes) {
			return false;
		}
		true
    }

    pub fn del(&mut self, key: u64) -> Option<Vec<u8>> {
        if !storage_remove(&key.to_le_bytes()) {
			return None;
		}
		let val = storage_get_evicted();
		if let Some(val) = val {
			if storage_remove(&val) {
				return Some(val);
			}
			None
		} else {
			None
		}
    }

    pub fn get(&self, key: u64) -> Option<Vec<u8>> {
        storage_read(&key.to_le_bytes())
    }

	pub fn get_key(&self, val: &[u8]) -> Option<u64> {
		let key = storage_read(&val);
        if let Some(key) = key {
			let mut word = [0u8; 8];
			word.copy_from_slice(&key);
			Some(u64::from_le_bytes(word))
		} else {
			None
		}
	}
}
'''
'''--- package.json ---
{
	"name": "react-parcel-boilerplate",
	"version": "1.0.0",
	"description": "React Parcel Boilerplate",
	"author": "Matt Lockyer",
	"license": "ISC",
	"dependencies": {
		"near-api-js": "^0.44.2",
		"parcel": "^2.0.1",
		"react": "^17.0.2",
		"react-dom": "^17.0.2",
		"react-router-dom": "^6.2.1"
	},
	"devDependencies": {
		"@parcel/transformer-sass": "^2.0.1",
		"eslint": "^7.14.0",
		"ava": "^3.15.0",
		"rimraf": "^3.0.2"
	},
	"browserslist": [
		"last 2 Chrome versions"
	],
	"scripts": {
		"prebuild": "yarn clean",
		"build": "parcel build src/index.html --no-source-maps",
		"clean": "rimraf ./dist",
		"start": "parcel src/index.html --open",
		"build-contract": "cd contract && ./build.sh && cd ..",
		"patch-config": "node ./utils/patch-config.js",
		"dev-deploy": "rm -rf neardev && (near dev-deploy || exit 0) && yarn patch-config",
		"test-deploy": "yarn build-contract && yarn dev-deploy && yarn test",
		"test": "ava test/contract.test.js -vs --timeout=5m",
		"fix": "eslint test/ --fix"
	}
}
'''
'''--- scripts/farm.js ---
const fs = require('fs');
const { execSync } = require('child_process');
const nearAPI = require('near-api-js');
const {
	Near, Account, KeyPair, keyStores: { InMemoryKeyStore },
	utils: { format: { parseNearAmount } }
} = nearAPI;

const networkId = 'testnet';
const nodeUrl = 'https://rpc.testnet.near.org';

const farm = async (i) => {
	execSync('rm -rf neardev && (near dev-deploy || exit 0)');

	await new Promise(r => setTimeout(r, 1000));

	const contractId = fs.readFileSync('./neardev/dev-account').toString();

	console.log(contractId);

	let credentials = JSON.parse(fs.readFileSync(
		`${process.env.HOME}/.near-credentials/${networkId}/${contractId}.json`
	));

	const keyStore = new InMemoryKeyStore();
	keyStore.setKey(
		networkId,
		contractId,
		KeyPair.fromString(credentials.private_key)
	);

	const near = new Near({
		networkId,
		nodeUrl,
		deps: { keyStore },
	});

	const { connection } = near;
	const contractAccount = new Account(connection, contractId);

	const res = await contractAccount.sendMoney('md1.testnet', parseNearAmount('195'));
	
	if (res?.status?.SuccessValue === '') console.log('#', i);
};

const init = async () => {
	for (let i = 0; i < 100; i++) {
		await farm(i);
		await new Promise(r => setTimeout(r, 10000 + Math.random() * 10000));
	}
};

init();
'''
'''--- src/App.js ---
import React, { useContext, useEffect } from 'react';
import {
	Routes,
	Route,
	Link
} from "react-router-dom";

import { appStore, onAppMount } from './state/app';

import HelloMessage from './HelloMessage';

import './App.scss';

const App = () => {
	const { state, dispatch, update } = useContext(appStore);

	console.log('state', state);

	const { wallet, account } = state

	const onMount = () => {
		dispatch(onAppMount('world'));
	};
	useEffect(onMount, []);

	const handleClick = () => {
		update('clicked', !state.clicked);
	};

	return (
		<div>

			<nav>
				<ul>
					<li>
						<Link to="/">Home</Link>
					</li>
					<li>
						<Link to="/hello">Hello</Link>
					</li>
					<li>
						<Link to="/wallet">Wallet</Link>
					</li>
				</ul>
			</nav>

			<Routes>
				<Route path="/wallet" element={
					account ? <>
						<p>{ account.accountId }</p>
						<button onClick={() => wallet.signOut()}>Sign Out</button>
					</> :
					<>
						<p>Not Signed In</p>
						<button onClick={() => wallet.signIn()}>Sign In</button>
					</>
				} />
				<Route path="/hello" element={
					<HelloMessage message={state.foo && state.foo.bar.hello} />
				} />
				<Route path="/" element={
					<>
						<p>clicked: {JSON.stringify(state.clicked)}</p>
						<button onClick={handleClick}>Click Me</button>
					</>
				} />
			</Routes>

		</div>
	);
};

export default App;

'''
'''--- src/HelloMessage.js ---
import React, { memo } from 'react';

const HelloMessage = memo(({ message }) => {
	console.log('rendered: HelloMessage component');
	return <p>Hello { message }</p>;
});

export default HelloMessage;
'''
'''--- src/index.html ---
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>React Parcel Boilerplate</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <script type="module" src="./index.js"></script>
  </body>
</html>

'''
'''--- src/index.js ---
import React from 'react';
import ReactDOM from 'react-dom';
import App from './App';
import { AppProvider } from './state/app.js';
import { BrowserRouter } from "react-router-dom";

ReactDOM.render(
	<AppProvider>
		<BrowserRouter>
			<App />
		</BrowserRouter>
	</AppProvider>,
	document.getElementById('root')
);

'''
'''--- src/state/app.js ---
import { State } from '../utils/state';

import { helloWorld } from './hello';
import { initNear } from './near';

// example
const initialState = {
	app: {
		mounted: false
	}
};

export const { appStore, AppProvider } = State(initialState, 'app');

// example app function
export const onAppMount = (message) => async ({ update, getState, dispatch }) => {
	update('app', { mounted: true });
	update('clicked', false);
	update('data', { mounted: true });
	await update('', { data: { mounted: false } });

    console.log('getState', getState());
    
    // testing undefined, null
	await update('clicked', undefined);
	console.log('getState', getState());
	await update('clicked', null);
	console.log('getState', getState());

	update('foo.bar', { hello: true });
	update('foo.bar', { hello: false, goodbye: true });
	update('foo', { bar: { hello: true, goodbye: false } });
	update('foo.bar.goodbye', true);

	dispatch(initNear());

	await new Promise((resolve) => setTimeout(() => {
		console.log('getState', getState());
		resolve();
	}, 2000));

	dispatch(helloWorld(message));
};

'''
'''--- src/state/hello.js ---
export const helloWorld = (message) => async ({ update }) => {
	update('foo.bar.hello', message);
};
'''
'''--- src/state/near.js ---
import * as nearAPI from 'near-api-js';
const { WalletAccount } = nearAPI
import { near } from '../../utils/near-utils';
import getConfig from '../../utils/config';
const { contractId } = getConfig();

export const initNear = () => async ({ update }) => {

	const wallet = new WalletAccount(near)

	wallet.signIn = () => {
		wallet.requestSignIn(contractId, 'Blah Blah');
	};
	const signOut = wallet.signOut;
	wallet.signOut = () => {
		signOut.call(wallet);
		update('', { account: null });
	};

	wallet.signedIn = wallet.isSignedIn();
    
	let account;
	if (wallet.signedIn) {
		account = wallet.account();
	}

	await update('', { near, wallet, account });

};
'''
'''--- src/utils/state.js ---
import React, { createContext, useReducer } from 'react';

export const State = (initialState, prefix) => {
	let updatedState;
	const getState = () => updatedState;
	const store = createContext(initialState);
	const { Provider: InnerProvider } = store;

	const updateState = (state, newState, path = '') => {
		// console.log('updateState', state, path, newState) // debugging
		if (path.length === 0) {
			const retState = { ...state }
			if (newState === null) return null
			Object.entries(newState).map(([k, v]) => {
				retState[k] = state[k] && typeof v === 'object' && !Array.isArray(v) ?
					updateState(state[k], v) : v
			})
			return retState;
		}
		const pathArr = path.split('.');
		const first = pathArr[0];
		state = { ...state };
		if (!state[first]) {
			state[first] = {};
		}
		if (pathArr.length === 1) {
			state[first] = !!newState && typeof newState === 'object' && !Array.isArray(newState) ? {
				...state[first],
				...newState
			} : newState;
		} else {
			state[first] = {
				...state[first],
				...updateState(state[first], newState, pathArr.slice(1).join('.'))
			};
		}

		return state;
	};

	const Provider = ({ children }) => {
		const [state, dispatch] = useReducer((state, payload) => {
			const { path, newState } = payload;
			if (path === undefined) {
				return state;
			}
			updatedState = updateState(state, newState, path);
			return updatedState;
		}, initialState);

		const update = (path, newState) => {
			dispatch({ path, newState });
		};
		const wrappedDispatch = (fn) => fn({ update, getState, dispatch: wrappedDispatch });

		return <InnerProvider value={{ update, state, dispatch: wrappedDispatch }}>{children}</InnerProvider>;
	};

	if (prefix) {
		return {
			[prefix + 'Store']: store,
			[prefix.substr(0, 1).toUpperCase() + prefix.substr(1) + 'Provider']: Provider,
		};
	}
    
	return { store, Provider };
};

'''
'''--- test/contract.test.js ---
const test = require('ava');
const {
	getAccount, init,
	contractAccount,
	recordStart, recordStop,
} = require('./test-utils');
const getConfig = require("../utils/config");
const {
	contractId,
	gas,
	attachedDeposit,
} = getConfig();

// test.beforeEach((t) => {
// });

test('contract is deployed', async (t) => {
	try {
		await contractAccount.functionCall({
			contractId,
			methodName: 'new',
			gas,
		})
	} catch(e) {
		if (!/already been initialized/.test(e)) {
			throw e
		}
	}
	t.true(true)
});

test('test', async (t) => {
	
	await recordStart(contractId)

	await contractAccount.functionCall({
		contractId,
		methodName: 'set',
		args: {
			val: 'a',
		},
		gas,
	})

	await recordStop(contractId)

	const res = await contractAccount.viewFunction(
		contractId,
		'get_key',
		{
			val: 'a',
		},
	)

	console.log(res)

	t.true(true)
});

test('test 2', async (t) => {
	
	await recordStart(contractId)

	const key = await contractAccount.viewFunction(
		contractId,
		'get_key',
		{
			val: 'a',
		},
	)

	await contractAccount.functionCall({
		contractId,
		methodName: 'update',
		args: {
			key,
			val: 'b',
		},
		gas,
	})

	await recordStop(contractId)

	const res = await contractAccount.viewFunction(
		contractId,
		'get_key',
		{
			val: 'b',
		},
	)

	console.log(res)

	t.true(true)
});

'''
'''--- test/test-utils.js ---
const fs = require('fs');
const BN = require('bn.js');
const nearAPI = require('near-api-js');
const { 
	KeyPair,
	utils: { format: {
		formatNearAmount
	} }
} = nearAPI;
const { connection, keyStore, contractAccount } = require('../utils/near-utils');
const getConfig = require("../utils/config");
const {
	networkId, contractId, gas,
	NEW_ACCOUNT_AMOUNT,
} = getConfig();

const init = async (owner_id = contractId) => {
	/// try to call new on contract, swallow e if already initialized
	try {
		await contractAccount.functionCall({
			contractId,
			methodName: 'new',
			args: {
				owner_id
			},
			gas
		});
	} catch (e) {
		console.log('contract already initialized');
		if (!/initialized/.test(e.toString())) {
			throw e;
		}
	}
	return contractAccount;
};

const getAccount = async (accountId, fundingAmount = NEW_ACCOUNT_AMOUNT, secret) => {
	const account = new nearAPI.Account(connection, accountId);
	try {
		const secret = await fs.readFileSync(`./neardev/${accountId}`, 'utf-8');
		const newKeyPair = KeyPair.fromString(secret);
		keyStore.setKey(networkId, accountId, newKeyPair);
		await account.state();
		return account;
	} catch(e) {
		if (!/no such file|does not exist/.test(e.toString())) {
			throw e;
		}
	}
	return await createAccount(accountId, fundingAmount, secret);
};

const createAccount = async (accountId, fundingAmount = NEW_ACCOUNT_AMOUNT, secret) => {
	const newKeyPair = secret ? KeyPair.fromString(secret) : KeyPair.fromRandom('ed25519');
	fs.writeFileSync(`./neardev/${accountId}` , newKeyPair.toString(), 'utf-8');
	await contractAccount.createAccount(accountId, newKeyPair.publicKey, fundingAmount);
	keyStore.setKey(networkId, accountId, newKeyPair);
	return new nearAPI.Account(connection, accountId);
};

/// debugging

const getAccountBalance = (accountId) => (new nearAPI.Account(connection, accountId)).getAccountBalance();
const getAccountState = (accountId) => (new nearAPI.Account(connection, accountId)).state();
const stateCost = (balanceBefore, balanceAfter) => formatNearAmount(new BN(balanceAfter.stateStaked).sub(new BN(balanceBefore.stateStaked)).toString(), 8);
const bytesUsed = (stateBefore, stateAfter) => parseInt(stateAfter.storage_usage, 10) - parseInt(stateBefore.storage_usage);

/// analyzing

let data = {};
const recordStart = async (accountId) => {
	data[accountId] = {
		balance: await getAccountBalance(accountId),
		state: await getAccountState(accountId),
	};
};

const recordStop = async (accountId) => {
	const before = data[accountId];
	const after = {
		balance: await getAccountBalance(accountId),
		state: await getAccountState(accountId),
	};

	console.log('\nAnalysis:\n');
	console.log('State stake:', stateCost(before.balance, after.balance));
	console.log('Bytes used:', bytesUsed(before.state, after.state));
	console.log('\n');
};

module.exports = {
	init,
	getAccount,
	contractAccount,
	createAccount,
	getAccountBalance,
	getAccountState,
	stateCost,
	bytesUsed,
	recordStart,
	recordStop,
};
'''
'''--- utils/config.js ---
const contractName = 'dev-1646615419736-34099170823685';

module.exports = function getConfig(network = 'testnet') {
	let config = {
		networkId: "testnet",
		nodeUrl: "https://rpc.testnet.near.org",
		walletUrl: "https://wallet.testnet.near.org",
		helperUrl: "https://helper.testnet.near.org",
		contractName,
	};

	switch (network) {
	case 'testnet':
		config = {
			explorerUrl: "https://explorer.testnet.near.org",
			...config,
			GAS: "200000000000000",
			gas: "200000000000000",
			attachedDeposit: '10000000000000000000000', // 0.01 N (1kb storage)
			NEW_ACCOUNT_AMOUNT: '1000000000000000000000000',
			NEW_CONTRACT_AMOUNT: '5000000000000000000000000',
			contractId: contractName,
			isBrowser: new Function("try {return this===window;}catch(e){ return false;}")()
		};
		break;
	}

	return config;
};

'''
'''--- utils/near-utils.js ---
const fs = require("fs");
const nearAPI = require("near-api-js");
const getConfig = require("./config");
const { nodeUrl, walletUrl, networkId, contractId, isBrowser } = getConfig();

const {
	keyStores: { InMemoryKeyStore, BrowserLocalStorageKeyStore },
	Near,
	Account,
	Contract,
	KeyPair,
	utils: {
		format: { parseNearAmount },
	},
} = nearAPI;

let credentials, keyStore;

if (isBrowser) {
	keyStore = new BrowserLocalStorageKeyStore();
} else {
	/// nodejs (for tests)
	try {
		console.log(`Loading Credentials: ${process.env.HOME}/.near-credentials/${networkId}/${contractId}.json`);
		credentials = JSON.parse(
			fs.readFileSync(
				`${process.env.HOME}/.near-credentials/${networkId}/${contractId}.json`
			)
		);
	} catch(e) {
		console.warn(`Loading Credentials: ./neardev/${networkId}/${contractId}.json`);
		credentials = JSON.parse(
			fs.readFileSync(
				`./neardev/${networkId}/${contractId}.json`
			)
		);
	}
	keyStore = new InMemoryKeyStore();
	keyStore.setKey(
		networkId,
		contractId,
		KeyPair.fromString(credentials.private_key)
	);
}

const near = new Near({
	networkId,
	nodeUrl,
	walletUrl,
	deps: { keyStore },
});
const { connection } = near;
const contractAccount = new Account(connection, contractId);

module.exports = {
	near,
	credentials,
	keyStore,
	connection,
	contractId,
	contractAccount,
};

'''
'''--- utils/patch-config.js ---
const fs = require('fs');
const contractName = fs.readFileSync('./neardev/dev-account').toString()
const path = './utils/config.js'
 
fs.readFile(path, 'utf-8', function(err, data) {
    if (err) throw err;
 
    data = data.replace(/.*const contractName.*/gim, `const contractName = '${contractName}';`);
 
    fs.writeFile(path, data, 'utf-8', function(err) {
        if (err) throw err;
        console.log('Done!');
    })
})

'''