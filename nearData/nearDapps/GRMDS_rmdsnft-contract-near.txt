*GitHub Repository "GRMDS/rmdsnft-contract-near"*

'''--- Cargo.toml ---
[package]
name = "rmds_nft"
version = "0.1.0"
authors = ["Sasi Malladi <sasi.malladi@valuelabs.com>"]
description = "RMDS NFT Token"
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0"
near-contract-standards = "4.0.0"

'''
'''--- README.md ---
## Instructions to build NEAR contracts

### Install Rust compiler and the package manager
* [Rustup](https://rustup.rs/): Install Rust compiler
* [cargo](https://crates.io/): Install Rust package manager

### Install wasm32
```bash
$ rustup target add wasm32-unknown-unknown
```

### Build the project
```bash
$ cargo build --target wasm32-unknown-unknown
```
or run the `build.sh` file
```bash
$ chmod +x build.sh
$ ./build.sh
```

### Install near-cli
```bash
$ npm install -g near-cli
```

### Deploy the contract
```bash
$ near login
$ near create-account rmdsnft.sasikiran.testnet --masterAccount $ID
$ near deploy --accountId rmdsnft.sasikiran.testnet --wasmFile res/rmds_nft.wasm
```
You should be able to verify the transaction from the URL of the [output](https://explorer.testnet.near.org/transactions/FcEYGpumLBEZe2BiBj9ADRpx1QSNSjhPPNJJovKe7Z58)

### Initialize the contract
```bash
$ near call rmdsnft.sasikiran.testnet new_default_meta '{"owner_id": "sasikiran.testnet"}' --accountId sasikiran.testnet
```

### View the metadata
```bash
$ near view rmdsnft.sasikiran.testnet nft_metadata
```

### Mint an NFT
```bash
$ near call rmdsnft.sasikiran.testnet nft_mint '{"token_id": "0", "receiver_id": "'$ID'", "token_metadata": { "title": "White flowers", "description": "White flowers photo by Yulia", "media": "https://bafybeigyxcifz2eylcpq2a7fnfm3fc3jr5iuplwulz4erw7v4smbvssbsi.ipfs.nftstorage.link/Yulia.png", "copies": 1}}' --accountId $ID --deposit 0.1
```
You should see a response:
```
Scheduling a call: rmdsnft.sasikiran.testnet.nft_mint({"token_id": "0", "receiver_id": "sasikiran.testnet", "token_metadata": { "title": "White flowers", "description": "White flowers photo by Yulia", "media": "https://bafybeigyxcifz2eylcpq2a7fnfm3fc3jr5iuplwulz4erw7v4smbvssbsi.ipfs.nftstorage.link/Yulia.png", "copies": 1}}) with attached 0.1 NEAR
Doing account.functionCall()
Receipts: 3odCpJYNq33Kbpf7NwvDT3tQvZEurQ5rzcB7RGj2SoGz, Arbsn9L3mvkxJf3wgZvtg69tLf5S1sNvLtNRsmJnmtuZ
	Log [rmdsnft.sasikiran.testnet]: EVENT_JSON:{"standard":"nep171","version":"1.0.0","event":"nft_mint","data":[{"owner_id":"sasikiran.testnet","token_ids":["0"]}]}
Transaction Id 6VcU6Hzc95cPwg1oAB2wYbpE8PMZttu6vJNQnVuZKDz
To see the transaction in the transaction explorer, please open this url in your browser
https://explorer.testnet.near.org/transactions/6VcU6Hzc95cPwg1oAB2wYbpE8PMZttu6vJNQnVuZKDz
{
  token_id: '0',
  owner_id: 'sasikiran.testnet',
  metadata: {
    title: 'White flowers',
    description: 'White flowers photo by Yulia',
    media: 'https://bafybeigyxcifz2eylcpq2a7fnfm3fc3jr5iuplwulz4erw7v4smbvssbsi.ipfs.nftstorage.link/Yulia.png',
    media_hash: null,
    copies: 1,
    issued_at: null,
    expires_at: null,
    starts_at: null,
    updated_at: null,
    extra: null,
    reference: null,
    reference_hash: null
  },
  approved_account_ids: {}
}
```
'''
'''--- build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/*.wasm ./res/

'''
'''--- src/lib.rs ---
use near_contract_standards::non_fungible_token::metadata::{
    NFTContractMetadata, NonFungibleTokenMetadataProvider, TokenMetadata, NFT_METADATA_SPEC
};
use near_contract_standards::non_fungible_token::{Token, TokenId};
use near_contract_standards::non_fungible_token::NonFungibleToken;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LazyOption;

use near_sdk::{
    env, near_bindgen, AccountId, BorshStorageKey, PanicOnDefault, Promise, PromiseOrValue,
};

pub const NFT_NAME: &str = "RMDS NFT";
pub const NFT_SYMBOL: &str = "RMDSNFT";
pub const NFT_STANDARD_NAME: &str = "nep171";
pub const NFT_BASE_URL: &str = "https://bafybeigyxcifz2eylcpq2a7fnfm3fc3jr5iuplwulz4erw7v4smbvssbsi.ipfs.nftstorage.link/";

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    tokens: NonFungibleToken,
    metadata: LazyOption<NFTContractMetadata>,
}

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
    NonFungibleToken,
    Metadata,
    TokenMetadata,
    Enumeration,
    Approval,
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new_default_meta(owner_id: AccountId) -> Self {
        Self::new(
            owner_id,
            NFTContractMetadata {
                spec: NFT_METADATA_SPEC.to_string(),
                name: NFT_NAME.to_string(),
                symbol: NFT_SYMBOL.to_string(),
                icon: None,
                base_uri: Some(NFT_BASE_URL.to_string()),
                reference: None,
                reference_hash: None,
            },
        )
    }

    #[init]
    pub fn new(owner_id: AccountId, metadata: NFTContractMetadata) -> Self {
        assert!(!env::state_exists(), "Already initialized");
        metadata.assert_valid();
        Self {
            tokens: NonFungibleToken::new(
                StorageKey::NonFungibleToken,
                owner_id,
                Some(StorageKey::TokenMetadata),
                Some(StorageKey::Enumeration),
                Some(StorageKey::Approval),
            ),
            metadata: LazyOption::new(StorageKey::Metadata, Some(&metadata)),
        }
    }

    #[payable]
    pub fn nft_mint(
        &mut self,
        token_id: TokenId,
        receiver_id: AccountId,
        token_metadata: TokenMetadata,
    ) -> Token {
        self.tokens.internal_mint(token_id, receiver_id, Some(token_metadata))
    }
}

near_contract_standards::impl_non_fungible_token_core!(Contract, tokens);
near_contract_standards::impl_non_fungible_token_approval!(Contract, tokens);
near_contract_standards::impl_non_fungible_token_enumeration!(Contract, tokens);

#[near_bindgen]
impl NonFungibleTokenMetadataProvider for Contract {
    fn nft_metadata(&self) -> NFTContractMetadata {
        self.metadata.get().unwrap()
    }
}

'''