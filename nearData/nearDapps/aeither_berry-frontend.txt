*GitHub Repository "aeither/berry-frontend"*

'''--- frontend/public/index.html ---
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Berry Club - eat ü•ë - draw pixels - farm üçå - talk through ü•ù"
    />
    <meta name="twitter:card" content="summary_large_image" />
    <meta property="og:image" content="https://wayback.berryclub.io/img/"/>
    <meta property="og:url" content="https://berryclub.io/" />
    <meta property="og:title" content="Berry Art" />
    <meta property="og:description" content="Eat ü•ë - draw pixels - farm üçå - talk through ü•ù" />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/favicon.png" />
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
    <title>Berry Club üçå</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
  </body>
</html>

'''
'''--- frontend/public/robots.txt ---
# https://www.robotstxt.org/robotstxt.html
User-agent: *
Disallow:

'''
'''--- frontend/src/Router.js ---
import React from "react";
import {
  BrowserRouter as Router,
  Switch,
  Route,
  Link,
  useRouteMatch,
  useParams,
} from "react-router-dom";
import {
  Stack,
  Heading,
  Box,
  Button,
  HStack,
  useColorModeValue,
  Image,
  Container,
  SlideFade,
} from "@chakra-ui/react";
import ClubPage from "./pages/ClubPage";
import FarmPage from "./pages/FarmPage";
import CardsPage from "./pages/CardsPage";
import Logo from "./images/berrylogo.png";

export default function App() {
  return (
    <Router>
      <Stack
        w="100%"
        px="4"
        py="6"
        background="brand.900"
        overflow="hidden"
        direction="row"
        justify="space-between"
        fontSize="lg"
      >
        <SlideFade in>
          <Container maxW="7xl" pt={4}>
            <HStack spacing="4">
              <Link to="/">
                <HStack pr="4">
                  <Image src={Logo} boxSize="50px" alt="Berry Cards" />
                  <Heading size="xl" color="brand.100">
                    Berry
                  </Heading>
                </HStack>
              </Link>
              <Link to="/">Club</Link>
              <Link to="/farm">Farm</Link>
              <Link to="/cards">Cards</Link>
              <a href="https://app.ref.finance/#wrap.near">REF Finance</a>
            </HStack>
          </Container>
        </SlideFade>
      </Stack>
      <SlideFade in>
        <Container maxW="7xl" pt={4}>
          <Switch>
            <Route path="/farm">
              <FarmPage />
            </Route>
            <Route path="/cards">
              <CardsPage />
            </Route>
            <Route path="/">
              <ClubPage />
            </Route>
          </Switch>
        </Container>
      </SlideFade>
    </Router>
  );
}

'''
'''--- frontend/src/components/BuyButton.js ---
import React from "react";
import { multiplier } from "./common";
import Big from "big.js";
import { Button, Text, List, ListItem } from "@chakra-ui/react";

const fromNear = (s) => parseFloat(s) / 1e24;

function BuyButton(props) {
  const price = fromNear((props.price / multiplier()) * 1.0001);

  async function buyCard(e) {
    e.preventDefault();
    await props._near.contract.buy_card(
      { card_id: props.cardId },
      "200000000000000",
      Big((props.price / multiplier()) * 1.0001).toFixed(0)
    );
  }

  const appCommission = price / 100;
  let artDaoProfit = price / 100;
  let ownerPrice = price - appCommission - artDaoProfit;
  if (!props.ownerId) {
    artDaoProfit += ownerPrice;
    ownerPrice = 0;
  }

  const newPrice = price * 1.2;

  return (
    <>
      <Button
        color="white"
        variant="solid"
        rounded="xl"
        fontSize="sm"
        bgGradient="linear(to-r, #FF0080, brand.100)"
        _hover={{ filter: "brightness(0.8)" }}
        onClick={(e) => buyCard(e)}
      >
        Buy for {price.toFixed(2)} NEAR
      </Button>
      <Text color="gray.600">
        Price breakdown:
        <List>
          {props.ownerId && (
            <ListItem>
              Owner @{props.ownerId} will get {ownerPrice.toFixed(2)} NEAR
            </ListItem>
          )}
          <ListItem>Art DAO will get {artDaoProfit.toFixed(2)} NEAR</ListItem>
          <ListItem>
            1% App commission is {appCommission.toFixed(2)} NEAR
          </ListItem>
        </List>
        <p>The new price will be {newPrice.toFixed(2)} NEAR</p>
      </Text>
    </>
  );
}

export { fromNear, BuyButton };

'''
'''--- frontend/src/components/Card.js ---
import React, { useCallback, useEffect, useState } from "react";
import { BuyButton, fromNear } from "./BuyButton";
import { CardImage, preloadCard } from "./CardImage";
import TimeAgo from "timeago-react";
import { Link } from "react-router-dom";
import PriceButton from "./PriceButton";
import Tilt from "react-parallax-tilt";
import {
  Heading,
  Box,
  Center,
  Button,
  VStack,
  SimpleGrid,
  HStack,
  Text,
} from "@chakra-ui/react";

const mapCardInfo = (c) => {
  return c
    ? {
        ownerId: c.owner_id,
        purchasePrice: fromNear(c.purchase_price),
        purchaseTime: new Date(parseFloat(c.purchase_time) / 1e6),
        volume: fromNear(c.volume),
        artDaoProfit: fromNear(c.art_dao_profit),
        numTrades: c.num_trades,
      }
    : {
        ownerId: null,
        purchasePrice: 0,
        purchaseTime: null,
        volume: 0,
        artDaoProfit: 0,
        numTrades: 0,
      };
};

function Card(props) {
  const [cardInfo, setCardInfo] = useState(null);
  const cardId = props.cardId;
  const refreshTime = props.refreshTime;
  const hidden = props.hidden;

  const fetchInfo = useCallback(async () => {
    const rating = await props._near.contract.get_rating({
      card_id: cardId,
    });
    const cardInfo = mapCardInfo(
      await props._near.contract.get_card_info({
        card_id: cardId,
      })
    );
    cardInfo.refreshTime = refreshTime;
    cardInfo.rating = rating;
    return cardInfo;
  }, [props._near, cardId, refreshTime]);

  useEffect(() => {
    if (props.connected && !hidden) {
      preloadCard(cardId);
      fetchInfo().then(setCardInfo);
    }
  }, [props.connected, fetchInfo, cardId, hidden]);

  return cardInfo ? (
    <HStack w="100%" justify="space-around" py="4">
      <Tilt tiltReverse glareEnable scale="1.1" >
        <CardImage cardId={cardId} cardReady={() => false} />
      </Tilt>
      <VStack
        align="start"
        color="brand.100"
        p="4"
        rounded="xl"
        background="white"
      >
        <Heading fontWeight="300" size="lg" color="brand.100">
          #{cardId}
        </Heading>
        {cardInfo.ownerId ? (
          <div>
            <Text>
              Owned by{" "}
              {cardInfo.ownerId === props.signedAccountId ? (
                "you"
              ) : (
                <Link to={`/a/${cardInfo.ownerId}`}>@{cardInfo.ownerId}</Link>
              )}
              <br />
              Purchased <TimeAgo datetime={cardInfo.purchaseTime} /> for{" "}
              {cardInfo.purchasePrice.toFixed(2)} NEAR
              <br />
            </Text>
            <Text>
              Total card volume {cardInfo.volume.toFixed(2)} NEAR
              <br />
              Art DAO got {cardInfo.artDaoProfit.toFixed(2)} NEAR
              <br />
            </Text>
          </div>
        ) : (
          <div>
            <p>Not owned by anyone.</p>
          </div>
        )}
        {cardInfo.ownerId === props.signedAccountId ? (
          <PriceButton {...props} cardId={cardId} price={cardInfo.rating} />
        ) : (
          <BuyButton
            {...props}
            cardId={cardId}
            price={cardInfo.rating}
            ownerId={cardInfo.ownerId}
          />
        )}
      </VStack>
    </HStack>
  ) : (
    <div className="card m-2">
      <div className="d-flex justify-content-center">
        <div className="spinner-grow" role="status">
          <span className="visually-hidden">Loading...</span>
        </div>
      </div>
    </div>
  );
}

export default Card;

'''
'''--- frontend/src/components/CardImage.js ---
import React, {useEffect, useRef, useState} from 'react';
import BrokenCard from "../images/tomato.png"
import LoadingCard from "../images/avocado.gif"

const loadedCards = {};
const loadedImages = {};
const cardPreloading = {};

function preloadCard(cardId) {
  if (cardId in cardPreloading) {
    return cardPreloading[cardId];
  }
  return cardPreloading[cardId] = new Promise((resolve) => {
    loadedImages[cardId] = new Image();
    loadedImages[cardId].onload = () => {
      loadedCards[cardId] = true;
      resolve()
    }
    loadedImages[cardId].onerror = (e) => {
      loadedCards[cardId] = false;
      resolve()
    }
    loadedImages[cardId].src = `https://i.berry.cards/${cardId}`;
  });

}

function CardImage(props) {
  const [cardImage, setCardImage] = useState(null);
  const [loading, setLoading] = useState(true);
  const [badCard, setBadCard] = useState(false);
  const canvasEl = useRef(null);

  const cardReady = props.cardReady;
  const cardId = props.cardId;

  useEffect(() => {
    setLoading(true);
    setCardImage(null);
    cardReady(false);
    setBadCard(false);
    preloadCard(cardId).then(() => {
      setBadCard(!loadedCards[cardId]);
      setLoading(false);
      if (loadedCards[cardId]) {
        cardReady(true);
        setCardImage(loadedImages[cardId]);
      }
    });
  }, [cardId, cardReady, canvasEl])

  useEffect(() => {
    if (canvasEl.current && cardImage) {
      const ctx = canvasEl.current.getContext('2d');
      ctx.drawImage(cardImage, 0, 0);
    }
  }, [cardImage])

  return (
    <div>
      {loading ? (
        <img className={props.className} src={LoadingCard} alt={`The card #${cardId} is loading`}/>
      ) : badCard ? (
        <img className={props.className} src={BrokenCard} alt={`The card #${cardId} is broken`}/>
      ): ("")}
      <canvas
        className={`${props.className}${(!cardImage || loading || badCard) ? " d-none": ""}`}
        ref={canvasEl}
        width={400}
        height={400}
        alt={`Card #${cardId}`}
      />
    </div>
  )
}

export { preloadCard, CardImage };

'''
'''--- frontend/src/components/CardPreview.js ---
import "./CardPreview.scss";
import React, { useCallback, useEffect, useState } from "react";
import { CardImage } from "./CardImage";
import { Link } from "react-router-dom";
import PriceButton from "./PriceButton";
import { Text, Box } from "@chakra-ui/react";
function CardPreview(props) {
  const [rating, setRating] = useState(props.rating);
  const cardId = props.cardId;
  const propsRating = props.rating;

  const fetchRating = useCallback(async () => {
    return await props._near.contract.get_rating({
      card_id: cardId,
    });
  }, [props._near, cardId]);

  useEffect(() => {
    if (props.connected) {
      if (!propsRating) {
        fetchRating().then(setRating);
      } else {
        setRating(propsRating);
      }
    }
  }, [props.connected, propsRating, fetchRating]);

  return props.cardId ? (
    <Box
      m="2"
      w="200px"
      rounded="xl"
      background="white"
      p="4"
      _hover={{ transform: "translateY(-4px)", shadow: "lg" }}
    >
      <Link to={`/c/${cardId}`}>
        <CardImage
          className="card-img-top"
          cardId={cardId}
          cardReady={() => false}
        />
      </Link>
      <Text p="2" color="brand.900">
        #{cardId}
      </Text>
      <PriceButton {...props} cardId={cardId} price={rating} />
    </Box>
  ) : (
    <div className="card card-preview m-2">
      <div className="d-flex justify-content-center">
        <div className="spinner-grow" role="status">
          <span className="visually-hidden">Loading...</span>
        </div>
      </div>
    </div>
  );
}

export default CardPreview;

'''
'''--- frontend/src/components/PriceButton.js ---
import React from "react";
import { fromNear } from "./BuyButton";
import { Link } from "react-router-dom";
import { multiplier } from "./common";
import { Button } from "@chakra-ui/react";

function PriceButton(props) {
  return (
    <Button
      w="100%"
      color="white"
      variant="solid"
      rounded="xl"
      fontSize="sm"
      bgGradient="linear(to-r, #FF0080, brand.100)"
      _hover={{ filter: "brightness(0.8)" }}
    >
      <Link to={`/c/${props.cardId}`} disabled={!props.signedIn}>
        {fromNear(props.price / multiplier()).toFixed(2)} NEAR
      </Link>
    </Button>
  );
}

export default PriceButton;

'''
'''--- frontend/src/components/Weapons.js ---
import "./Weapons.scss";
import React from "react";
import Files from "react-files";

const Avocado = (
  <span role="img" aria-label="avocado" className="berry">
    ü•ë
  </span>
);

export class Weapons extends React.Component {
  constructor(props) {
    super(props);
    this.canvasRef = React.createRef();
    this.state = {
      width: 48,
      height: 28,
      avocadoNeeded: 100,
      lockedAspect: true,
    };
  }

  componentDidMount() {
    this.canvas = this.canvasRef.current;
    this.ctx = this.canvas.getContext("2d");
    this.sourceImage = new Image();
    this.sourceImage.onload = () => {
      this.draw();
    };
    this.sourceImage.src = "/bfg.png";
  }

  draw() {
    const sourceImage = this.sourceImage;
    const canvas = this.canvas;
    const ctx = this.ctx;
    const width = this.state.width;
    const height = this.state.height;

    // Create a canvas with the desired dimensions
    canvas.width = width;
    canvas.height = height;
    canvas.style.width = width * 10 + "px";
    canvas.style.height = height * 10 + "px";

    // Scale and draw the source image to the canvas
    ctx.clearRect(0, 0, width, height);
    ctx.imageSmoothingQuality = "low";
    ctx.drawImage(sourceImage, 0, 0, width, height);

    const imageData = ctx.getImageData(0, 0, width, height);
    this.imageData = imageData;
    this.setState({
      avocadoNeeded: new Uint32Array(imageData.data.buffer).reduce(
        (sum, v) => sum + (v ? 1 : 0),
        0
      ),
    });
  }

  async onFilesChange(f) {
    const sourceImage = this.sourceImage;
    let reader = new FileReader();

    reader.readAsDataURL(f[0]);

    sourceImage.onload = () => {
      let width = sourceImage.naturalWidth;
      let height = sourceImage.naturalHeight;
      if (sourceImage.naturalWidth > 50 || sourceImage.naturalHeight > 50) {
        const aspect = width / height;
        width = Math.round(20 * Math.min(1, aspect));
        height = Math.round(20 * Math.min(1, 1 / aspect));
      }
      this.setState({
        width: Math.min(50, Math.max(1, width)),
        height: Math.min(50, Math.max(1, height)),
      });
      this.draw();
    };

    reader.onload = function (event) {
      sourceImage.src = event.target.result;
    };
  }

  async onFilesError(e, f) {
    console.log(e, f);
  }

  updateVal(key, value) {
    value = Math.min(50, Math.max(1, value));
    if (this.state.lockedAspect) {
      const aspect =
        this.sourceImage.naturalWidth / this.sourceImage.naturalHeight;
      let width, height;
      if (key === "width") {
        width = value;
        height = Math.round(width / aspect);
      } else {
        height = value;
        width = Math.round(height * aspect);
      }
      this.setState(
        {
          width: Math.min(50, Math.max(1, width)),
          height: Math.min(50, Math.max(1, height)),
        },
        () => {
          this.draw();
        }
      );
    } else {
      this.setState(
        {
          [key]: value,
        },
        () => {
          this.draw();
        }
      );
    }
  }

  changeLockedAspect() {
    this.setState({
      lockedAspect: !this.state.lockedAspect,
    });
  }

  render() {
    return (
      <div className="weapons-popup">
        <div className="weapons-content">
          <h2>So you need a BFG?</h2>
          <div>
            <Files
              type="button"
              className="btn"
              onChange={(f) => this.onFilesChange(f)}
              onError={(e, f) => this.onFilesError(e, f)}
              multiple={false}
              accepts={["image/*"]}
              minFileSize={1}
              clickable
            >
              Click to upload an image
            </Files>
          </div>
          <div>
            <label>Width</label>
            <input
              type="number"
              value={this.state.width}
              min={1}
              max={50}
              onChange={(e) => this.updateVal("width", e.target.value)}
            />{" "}
            <button
              className={
                "btn btn-outline-secondary low-right-margin" +
                (this.state.lockedAspect ? " btn-pressed" : " btn-not-pressed")
              }
              onClick={() => this.changeLockedAspect()}
            >
              <span role="img" aria-label="link" className="berry">
                üîó
              </span>
            </button>
            <label>Height</label>
            <input
              type="number"
              value={this.state.height}
              min={1}
              max={50}
              onChange={(e) => this.updateVal("height", e.target.value)}
            />
          </div>
          <button
            className="btn btn-success btn-large"
            disabled={
              !this.props.account ||
              (!this.props.isFreeDrawing &&
                this.props.account.avocadoBalance < this.state.avocadoNeeded)
            }
            onClick={() =>
              this.props.renderIt(this.imageData, this.state.avocadoNeeded)
            }
          >
            Render on the board using {this.state.avocadoNeeded} {Avocado}
          </button>
          <button
            className="btn btn-primary btn-large"
            onClick={() => this.props.enableWatchMode()}
          >
            Enable watch mode
          </button>
          <div className="canvas-wrapper">
            <canvas
              ref={this.canvasRef}
              width={480}
              height={280}
              className="draw-preview"
            ></canvas>
          </div>
        </div>
      </div>
    );
  }
}

'''
'''--- frontend/src/components/common.js ---
const InflationTimestamp = 1621623768597;
const HalflifeDuration = 2628000000;

export const multiplier = () => {
  const timestamp = new Date().getTime();
  const duration = timestamp - InflationTimestamp;
  return Math.pow(2, duration / HalflifeDuration);
}

'''
'''--- frontend/src/index.js ---
import React from "react";
import ReactDOM from "react-dom";
import Router from "./Router";
import { ChakraProvider } from "@chakra-ui/react";
import { theme } from "./styles";

ReactDOM.render(
  <ChakraProvider theme={theme}>
    <Router />
  </ChakraProvider>,
  document.getElementById("root")
);

'''
'''--- frontend/src/pages/Account.js ---
import React, { useCallback, useEffect, useState } from "react";
import { useParams } from "react-router";
import CardPreview from "../components/CardPreview";
import uuid from "react-uuid";
import {
  SimpleGrid,
  Heading,
  Box,
  VStack,
  List,
  ListItem,
} from "@chakra-ui/react";

function AccountPage(props) {
  const { accountId } = useParams();
  const [account, setAccount] = useState(null);
  const [loading, setLoading] = useState(true);
  const [cardIds, setCardsIds] = useState([]);
  const [gkey] = useState(uuid());

  const fetchCards = useCallback(async () => {
    const account = await props._near.getAccount(accountId);
    if (!account) {
      return;
    }
    setAccount(account);
    return await account.fetchCards();
  }, [props._near, accountId]);

  useEffect(() => {
    if (props.connected) {
      fetchCards().then((cardIds) => {
        cardIds.sort((a, b) => b[1] - a[1]);
        setCardsIds(cardIds);
        setLoading(false);
      });
    }
  }, [props.connected, fetchCards]);

  const cards = cardIds.map(([cardId, rating]) => {
    const key = `${gkey}-${cardId}`;
    return <CardPreview {...props} key={key} cardId={cardId} rating={rating} />;
  });

  return (
    <div>
      {loading ? (
        <div className="col">
          <div className="d-flex justify-content-center">
            <div className="spinner-grow" role="status">
              <span className="visually-hidden">Loading...</span>
            </div>
          </div>
        </div>
      ) : (
        <div>
          <Heading size="3xl" fontWeight="normal">
            {accountId === props.signedAccountId
              ? "Your cards"
              : `Cards owned by @${accountId}`}
          </Heading>
          <SimpleGrid columns={4} spacing={10}>
            {cards}
          </SimpleGrid>
        </div>
      )}
      {!account ? (
        <div className="col col-12 col-lg-8 col-xl-6">
          <div className="d-flex justify-content-center">
            <div className="spinner-grow" role="status">
              <span className="visually-hidden">Loading...</span>
            </div>
          </div>
        </div>
      ) : (
        <Box rounded="xl" background="white" p="4" w="auto">
          <VStack color="brand.900" align="start">
            <Heading fontWeight="300" size="lg" color="brand.100">
              Stats{" "}
            </Heading>
            <List spacing={3}>
              <ListItem>Num cards: {account.numCards}</ListItem>
              <ListItem>
                Purchase volume: {account.purchaseVolume.toFixed(2)} NEAR
              </ListItem>
              <ListItem>Num purchases: {account.numPurchases}</ListItem>
              <ListItem>
                Sale profit: {account.saleProfit.toFixed(2)} NEAR
              </ListItem>
              <ListItem>Num sales: {account.numSales}</ListItem>
              <ListItem>Num votes: {account.numVotes}</ListItem>
            </List>
          </VStack>
        </Box>
      )}
    </div>
  );
}

export default AccountPage;

'''
'''--- frontend/src/pages/Card.js ---
import React from "react";
import { useParams } from "react-router";
import Card from "../components/Card";

function CardPage(props) {
  const { cardId } = useParams();

  return <Card {...props} cardId={parseInt(cardId)} />;
}

export default CardPage;

'''
'''--- frontend/src/pages/CardsPage.js ---
import React from "react";
import "error-polyfill";
import "bootstrap/dist/js/bootstrap.bundle";
import "bootstrap/dist/css/bootstrap.min.css";
// import "./App.scss";
import * as nearAPI from "near-api-js";
import DiscoverPage from "./Discover";
import HomePage from "./Home";
import { HashRouter as Router, Link, Route, Switch } from "react-router-dom";
import { fromNear } from "../components/BuyButton";
import ls from "local-storage";
import CardPage from "./Card";
import AccountPage from "./Account";
import StatsPage from "./Stats";
import RecentPage from "./Recent";
import { Button, HStack, Box } from "@chakra-ui/react";

const IsMainnet = window.location.hostname === "berry.cards";
const TestNearConfig = {
  networkId: "testnet",
  nodeUrl: "https://rpc.testnet.near.org",
  archivalNodeUrl: "https://rpc.testnet.internal.near.org",
  contractName: "dev-1621626423763-23601795253740",
  walletUrl: "https://wallet.testnet.near.org",
};
const MainNearConfig = {
  networkId: "mainnet",
  nodeUrl: "https://rpc.mainnet.near.org",
  archivalNodeUrl: "https://rpc.mainnet.internal.near.org",
  contractName: "cards.berryclub.ek.near",
  walletUrl: "https://wallet.near.org",
};

const NearConfig = IsMainnet ? MainNearConfig : TestNearConfig;

const FetchLimit = 50;

const mapAccount = (a) => {
  return {
    requests: a.requests,
    numCards: a.num_cards,
    purchaseVolume: fromNear(a.purchase_volume),
    numPurchases: a.num_purchases,
    saleProfit: fromNear(a.sale_profit),
    numSales: a.num_sales,
    numVotes: a.num_votes,
  };
};

class CardsPage extends React.Component {
  constructor(props) {
    super(props);

    this._near = {};

    this._near.lsKey = NearConfig.contractName + ":v01:";
    this._near.lsKeyRecentCards = this._near.lsKey + "recentCards";

    this.state = {
      connected: false,
      isNavCollapsed: true,
      account: null,
      requests: null,
      recentCards: ls.get(this._near.lsKeyRecentCards) || [],
    };

    this._initNear().then(() => {
      this.setState({
        signedIn: !!this._near.accountId,
        signedAccountId: this._near.accountId,
        connected: true,
      });
    });
  }

  async _initNear() {
    const keyStore = new nearAPI.keyStores.BrowserLocalStorageKeyStore();
    const near = await nearAPI.connect(
      Object.assign({ deps: { keyStore } }, NearConfig)
    );
    this._near.keyStore = keyStore;
    this._near.near = near;

    this._near.walletConnection = new nearAPI.WalletConnection(
      near,
      NearConfig.contractName
    );
    this._near.accountId = this._near.walletConnection.getAccountId();

    this._near.account = this._near.walletConnection.account();
    this._near.contract = new nearAPI.Contract(
      this._near.account,
      NearConfig.contractName,
      {
        viewMethods: [
          "get_account",
          "get_num_accounts",
          "get_accounts",
          "get_num_cards",
          "get_top",
          "get_rating",
          "get_trade_data",
          "get_card_info",
          "get_account_cards",
          "get_recent_cards",
        ],
        changeMethods: ["register_account", "vote", "buy_card"],
      }
    );

    this._near.accounts = {};

    this._near.getAccount = (accountId) => {
      if (accountId in this._near.accounts) {
        return this._near.accounts[accountId];
      }
      return (this._near.accounts[accountId] = Promise.resolve(
        (async () => {
          const a = await this._near.contract.get_account({
            account_id: accountId,
          });
          const account = a ? mapAccount(a) : null;
          if (account) {
            account.fetchCards = () => {
              if (account.cardFetching) {
                return account.cardFetching;
              }
              const promises = [];
              for (let i = 0; i < account.numCards; i += FetchLimit) {
                promises.push(
                  this._near.contract.get_account_cards({
                    account_id: accountId,
                    from_index: i,
                    limit: FetchLimit,
                  })
                );
              }
              return (account.cardFetching = Promise.resolve(
                (async () => {
                  return (await Promise.all(promises)).flat();
                })()
              ));
            };
          }
          return account;
        })()
      ));
    };

    if (this._near.accountId) {
      let account = await this._near.getAccount(this._near.accountId);
      if (account === null) {
        await this._near.contract.register_account();
        delete this._near.accounts[this._near.accountId];
        account = await this._near.getAccount(this._near.accountId);
      }
      this.setState({
        account,
        requests: account.requests,
      });
    }
  }

  async requestSignIn(e) {
    e && e.preventDefault();
    const appTitle = "Berry";
    await this._near.walletConnection.requestSignIn(
      NearConfig.contractName,
      appTitle
    );
    return false;
  }

  async logOut() {
    this._near.walletConnection.signOut();
    this._near.accountId = null;
    this.setState({
      signedIn: !!this._accountId,
      signedAccountId: this._accountId,
    });
  }

  popRequest(c) {
    const requests = this.state.requests.slice(1);
    this.setState(
      {
        requests,
      },
      c
    );
  }

  addRequest(r, c) {
    const requests = this.state.requests.slice(0);
    requests.push(r);
    this.setState(
      {
        requests,
      },
      c
    );
  }

  addRecentCard(cardId) {
    let recentCards = this.state.recentCards.slice(0);
    const index = recentCards.indexOf(cardId);
    if (index !== -1) {
      recentCards.splice(index, 1);
    }
    recentCards.unshift(cardId);
    recentCards = recentCards.slice(0, 5);
    ls.set(this._near.lsKeyRecentCards, recentCards);
    this.setState({
      recentCards,
    });
  }

  async refreshAllowance() {
    alert(
      "You're out of access key allowance. Need sign in again to refresh it"
    );
    await this.logOut();
    await this.requestSignIn();
  }

  render() {
    const passProps = {
      _near: this._near,
      updateState: (s, c) => this.setState(s, c),
      popRequest: (c) => this.popRequest(c),
      addRequest: (r, c) => this.addRequest(r, c),
      addRecentCard: (cardId) => this.addRecentCard(cardId),
      refreshAllowance: () => this.refreshAllowance(),
      ...this.state,
    };
    const header = !this.state.connected ? (
      <div>
        Connecting...{" "}
        <span
          className="spinner-grow spinner-grow-sm"
          role="status"
          aria-hidden="true"
        ></span>
      </div>
    ) : this.state.signedIn ? (
      <Button
        variant="outline"
        rounded="xl"
        border="2px"
        borderColor="brand.900"
        color="brand.900"
        _hover={{ filter: "brightness(0.5)" }}
        onClick={() => this.logOut()}
      >
        Log out ({this.state.signedAccountId})
      </Button>
    ) : (
      <Button
        variant="solid"
        rounded="xl"
        background="brand.900"
        _hover={{ filter: "brightness(0.8)" }}
        onClick={() => this.requestSignIn()}
      >
        Log in with NEAR Wallet
      </Button>
    );

    return (
      <div className="App">
        <Router basename={process.env.PUBLIC_URL}>
          <HStack pb="4"  w="100%" justify="space-between" spacing="4">
            <HStack color="brand.100" rounded="xl" background="white" p="2">
              <Link aria-current="page" to="/recent">
                Recent
              </Link>
              {this.state.signedIn && (
                <Link aria-current="page" to="/top">
                  Top
                </Link>
              )}
              {this.state.signedIn && (
                <Link
                  aria-current="page"
                  to={`/a/${this.state.signedAccountId}`}
                >
                  Profile
                </Link>
              )}
              <Link aria-current="page" to="/stats">
                Stats
              </Link>
            </HStack>

            <form className="d-flex">{header}</form>
          </HStack>

          <Switch>
            <Route exact path={"/"}>
              {this.state.signedIn ? (
                <HomePage {...passProps} />
              ) : (
                <DiscoverPage {...passProps} />
              )}
            </Route>
            <Route exact path={"/recent"}>
              <RecentPage {...passProps} />
            </Route>
            <Route exact path={"/top"}>
              <DiscoverPage {...passProps} />
            </Route>
            <Route exact path={"/stats"}>
              <StatsPage {...passProps} />
            </Route>
            <Route exact path={"/a/:accountId"}>
              <AccountPage {...passProps} />
            </Route>
            <Route exact path={"/c/:cardId"}>
              <CardPage {...passProps} />
            </Route>
          </Switch>
        </Router>
      </div>
    );
  }
}

export default CardsPage;

'''
'''--- frontend/src/pages/ClubPage.js ---
import "./ClubPage.scss";
import React from "react";
import BN from "bn.js";
import * as nearAPI from "near-api-js";
import { AlphaPicker, HuePicker, GithubPicker } from "react-color";
import ReactSwitch from "react-switch";
import { Weapons } from "../components/Weapons";
import Timer from "react-compound-timer";
import { HashRouter as Router, Link, Route, Switch } from "react-router-dom";
import { Button, Grid, GridItem, Box, Center } from "@chakra-ui/react";
import { Heading, HStack, Text, VStack } from "@chakra-ui/layout";

const PixelPrice = new BN("10000000000000000000000");
const IsMainnet = window.location.hostname === "berryclub.io";
const TestNearConfig = {
  networkId: "testnet",
  nodeUrl: "https://rpc.testnet.near.org",
  contractName: "berryclub.testnet",
  walletUrl: "https://wallet.testnet.near.org",
};
const MainNearConfig = {
  networkId: "mainnet",
  nodeUrl: "https://rpc.mainnet.near.org",
  contractName: "berryclub.ek.near",
  walletUrl: "https://wallet.near.org",
};
const NearConfig = IsMainnet ? MainNearConfig : TestNearConfig;

const Avocado = (
  <span role="img" aria-label="avocado" className="berry">
    ü•ë
  </span>
);
const Banana = (
  <span role="img" aria-label="banana" className="berry">
    üçå
  </span>
);
const Cucumber = (
  <span role="img" aria-label="cucumber" className="berry">
    ü•í
  </span>
);
const Pepper = (
  <span role="img" aria-label="pepper" className="berry">
    üå∂Ô∏è
  </span>
);

const Berry = {
  Avocado: "Avocado",
  Banana: "Banana",
};

const BoardHeight = 50;
const BoardWidth = 50;
const NumLinesPerFetch = 50;
const ExpectedLineLength = 4 + 8 * BoardWidth;
const CellWidth = 12;
const CellHeight = 12;
const MaxNumColors = 31;
const BatchOfPixels = 100;
// 500 ms
const BatchTimeout = 500;
const RefreshBoardTimeout = 1000;
const MaxWorkTime = 10 * 60 * 1000;
const OneDayMs = 24 * 60 * 60 * 1000;

const intToColor = (c) => `#${c.toString(16).padStart(6, "0")}`;
const intToColorWithAlpha = (c, a) =>
  `#${c.toString(16).padStart(6, "0")}${Math.round(255 * a)
    .toString(16)
    .padStart(2, "0")}`;

const rgbaToInt = (cr, cg, cb, ca, bgColor) => {
  const bb = bgColor & 255;
  const bg = (bgColor >> 8) & 255;
  const br = (bgColor >> 16) & 255;

  const r = Math.round(cr * ca + br * (1 - ca));
  const g = Math.round(cg * ca + bg * (1 - ca));
  const b = Math.round(cb * ca + bb * (1 - ca));
  return (r << 16) + (g << 8) + b;
};

const imgColorToInt = (c, bgColor) => {
  const cr = c & 255;
  const cg = (c >> 8) & 255;
  const cb = (c >> 16) & 255;
  const ca = ((c >> 24) & 255) / 255;
  return rgbaToInt(cr, cg, cb, ca, bgColor);
};

const int2hsv = (cInt) => {
  cInt = intToColor(cInt).substr(1);
  const r = parseInt(cInt.substr(0, 2), 16) / 255;
  const g = parseInt(cInt.substr(2, 2), 16) / 255;
  const b = parseInt(cInt.substr(4, 2), 16) / 255;
  let v = Math.max(r, g, b),
    c = v - Math.min(r, g, b);
  let h =
    c && (v === r ? (g - b) / c : v === g ? 2 + (b - r) / c : 4 + (r - g) / c);
  return [60 * (h < 0 ? h + 6 : h), v && c / v, v];
};
const transparentColor = (c, a) =>
  `rgba(${c >> 16}, ${(c >> 8) & 0xff}, ${c & 0xff}, ${a})`;
const generateGamma = (hue) => {
  const gammaColors = [];
  for (let i = 0; i < MaxNumColors; ++i) {
    gammaColors.push(`hsl(${hue}, 100%, ${(100 * i) / (MaxNumColors - 1)}%)`);
  }
  return gammaColors;
};
const decodeLine = (line) => {
  let buf = Buffer.from(line, "base64");
  if (buf.length !== ExpectedLineLength) {
    throw new Error("Unexpected encoded line length");
  }
  let pixels = [];
  for (let i = 4; i < buf.length; i += 8) {
    let color = buf.readUInt32LE(i);
    let ownerIndex = buf.readUInt32LE(i + 4);
    pixels.push({
      color,
      ownerIndex,
    });
  }
  return pixels;
};

const WeaponsCheat = "idkfa";

class ClubPage extends React.Component {
  constructor(props) {
    super(props);

    const colors = [
      "#000000",
      "#666666",
      "#aaaaaa",
      "#FFFFFF",
      "#F44E3B",
      "#D33115",
      "#9F0500",
      "#FE9200",
      "#E27300",
      "#C45100",
      "#FCDC00",
      "#FCC400",
      "#FB9E00",
      "#DBDF00",
      "#B0BC00",
      "#808900",
      "#A4DD00",
      "#68BC00",
      "#194D33",
      "#68CCCA",
      "#16A5A5",
      "#0C797D",
      "#73D8FF",
      "#009CE0",
      "#0062B1",
      "#AEA1FF",
      "#7B64FF",
      "#653294",
      "#FDA1FF",
      "#FA28FF",
      "#AB149E",
    ].map((c) => c.toLowerCase());
    // const currentColor = parseInt(colors[Math.floor(Math.random() * colors.length)].substring(1), 16);
    const currentColor = parseInt(colors[0].substring(1), 16);
    const defaultAlpha = 0.25;

    const timeMs = new Date().getTime();
    const freeDrawingStartMsEstimated =
      timeMs -
      ((timeMs - new Date("2021-05-09")) % (7 * OneDayMs)) +
      OneDayMs * 6;

    this.state = {
      connected: false,
      signedIn: false,
      accountId: null,
      pendingPixels: 0,
      boardLoaded: false,
      selectedCell: null,
      alpha: defaultAlpha,
      currentColor,
      pickerColor: intToColorWithAlpha(currentColor, defaultAlpha),
      colors,
      gammaColors: generateGamma(0),
      pickingColor: false,
      owners: [],
      accounts: {},
      highlightedAccountIndex: -1,
      selectedOwnerIndex: false,
      farmingBanana: false,
      weaponsOn: false,
      weaponsCodePosition: 0,
      freeDrawingStart: new Date(freeDrawingStartMsEstimated),
      freeDrawingEnd: new Date(freeDrawingStartMsEstimated + OneDayMs),
      watchMode: false,
    };

    this._buttonDown = false;
    this._oldCounts = {};
    this._numFailedTxs = 0;
    this._balanceRefreshTimer = null;
    this.canvasRef = React.createRef();
    this._context = false;
    this._lines = false;
    this._queue = [];
    this._pendingPixels = [];
    this._refreshBoardTimer = null;
    this._sendQueueTimer = null;
    this._stopRefreshTime = new Date().getTime() + MaxWorkTime;
    this._accounts = {};

    this._initNear().then(() => {
      this.setState(
        {
          connected: true,
          signedIn: !!this._accountId,
          accountId: this._accountId,
          ircAccountId: this._accountId.replace(".", "_"),
          freeDrawingStart: this._freeDrawingStart,
          freeDrawingEnd: this._freeDrawingEnd,
        },
        () => {
          if (window.location.hash.indexOf("watch") >= 0) {
            setTimeout(() => this.enableWatchMode(), 500);
          }
        }
      );
    });
  }

  componentDidMount() {
    const canvas = this.canvasRef.current;
    this._context = canvas.getContext("2d");

    const click = async () => {
      if (this.state.watchMode) {
        return;
      }
      if (this.state.rendering) {
        await this.drawImg(this.state.selectedCell);
      } else if (this.state.pickingColor) {
        this.pickColor(this.state.selectedCell);
      } else {
        this.saveColor();
        await this.drawPixel(this.state.selectedCell);
      }
    };

    const mouseMove = (e) => {
      let x, y;
      if ("touches" in e) {
        if (e.touches.length > 1) {
          return true;
        } else {
          const rect = e.target.getBoundingClientRect();
          x = e.targetTouches[0].clientX - rect.left;
          y = e.targetTouches[0].clientY - rect.top;
        }
      } else {
        x = e.offsetX;
        y = e.offsetY;
      }
      x = Math.trunc((x / e.target.clientWidth) * BoardWidth);
      y = Math.trunc((y / e.target.clientHeight) * BoardWidth);
      let cell = null;
      if (x >= 0 && x < BoardWidth && y >= 0 && y < BoardHeight) {
        cell = { x, y };
      }
      if (JSON.stringify(cell) !== JSON.stringify(this.state.selectedCell)) {
        this.setState(
          {
            selectedCell: cell,
            selectedOwnerIndex:
              this._lines &&
              cell &&
              this._lines[cell.y] &&
              this._lines[cell.y][cell.x].ownerIndex,
          },
          async () => {
            this.renderCanvas();
            if (this.state.selectedCell !== null && this._buttonDown) {
              await click();
            }
          }
        );
      }
      e.preventDefault();
      return false;
    };

    canvas.addEventListener("mousemove", mouseMove);
    canvas.addEventListener("touchmove", mouseMove);

    const mouseDown = async (e) => {
      this._buttonDown = true;
      if (this.state.selectedCell !== null) {
        await click();
      }
    };

    canvas.addEventListener("mousedown", mouseDown);
    canvas.addEventListener("touchstart", mouseDown);

    const unselectCell = () => {
      this.setState(
        {
          selectedCell: null,
        },
        () => this.renderCanvas()
      );
    };

    const mouseUp = async (e) => {
      this._buttonDown = false;
      if ("touches" in e) {
        unselectCell();
      }
    };

    canvas.addEventListener("mouseup", mouseUp);
    canvas.addEventListener("touchend", mouseUp);

    canvas.addEventListener("mouseleave", unselectCell);

    canvas.addEventListener("mouseenter", (e) => {
      if (this._buttonDown) {
        if (!("touches" in e) && !(e.buttons & 1)) {
          this._buttonDown = false;
        }
      }
    });

    document.addEventListener("keydown", (e) => {
      e.altKey && this.enablePickColor();
    });

    document.addEventListener("keyup", (e) => {
      if (this.state.weaponsCodePosition < WeaponsCheat.length) {
        if (
          e.key.toLowerCase() === WeaponsCheat[this.state.weaponsCodePosition]
        ) {
          this.setState({
            weaponsCodePosition: this.state.weaponsCodePosition + 1,
            weaponsOn:
              this.state.weaponsCodePosition + 1 === WeaponsCheat.length,
          });
        } else {
          this.setState({
            weaponsCodePosition: 0,
          });
        }
      }
      !e.altKey && this.disablePickColor();
    });
  }

  enablePickColor() {
    this.setState(
      {
        pickingColor: true,
      },
      () => {
        this.renderCanvas();
      }
    );
  }

  disablePickColor() {
    this.setState(
      {
        pickingColor: false,
      },
      () => {
        this.renderCanvas();
      }
    );
  }

  pickColor(cell) {
    if (!this.state.signedIn || !this._lines || !this._lines[cell.y]) {
      return;
    }
    const color = this._lines[cell.y][cell.x].color;

    this.setState(
      {
        currentColor: color,
        alpha: 1,
        pickerColor: intToColorWithAlpha(color, 1),
        gammaColors: generateGamma(int2hsv(color)[0]),
        pickingColor: false,
      },
      () => {
        this.renderCanvas();
      }
    );
  }

  async refreshAllowance() {
    alert(
      "You're out of access key allowance. Need sign in again to refresh it"
    );
    await this.logOut();
    await this.requestSignIn();
  }

  async _sendQueue() {
    const pixels = this._queue.slice(0, BatchOfPixels);
    this._queue = this._queue.slice(BatchOfPixels);
    this._pendingPixels = pixels;

    try {
      await this._contract.draw(
        {
          pixels,
        },
        new BN("75000000000000")
      );
      this._numFailedTxs = 0;
    } catch (error) {
      const msg = error.toString();
      if (msg.indexOf("does not have enough balance") !== -1) {
        await this.refreshAllowance();
        return;
      }
      console.log("Failed to send a transaction", error);
      this._numFailedTxs += 1;
      if (this._numFailedTxs < 3) {
        this._queue = this._queue.concat(this._pendingPixels);
        this._pendingPixels = [];
      } else {
        this._pendingPixels = [];
        this._queue = [];
      }
    }
    try {
      await Promise.all([this.refreshBoard(true), this.refreshAccountStats()]);
    } catch (e) {
      // ignore
    }
    this._pendingPixels.forEach((p) => {
      if (this._pending[p.y][p.x] === p.color) {
        this._pending[p.y][p.x] = -1;
      }
    });
    this._pendingPixels = [];
  }

  async _pingQueue(ready) {
    if (this._sendQueueTimer) {
      clearTimeout(this._sendQueueTimer);
      this._sendQueueTimer = null;
    }

    if (
      this._pendingPixels.length === 0 &&
      (this._queue.length >= BatchOfPixels || ready)
    ) {
      await this._sendQueue();
    }
    if (this._queue.length > 0) {
      this._sendQueueTimer = setTimeout(async () => {
        await this._pingQueue(true);
      }, BatchTimeout);
    }
  }

  async drawImg(cell) {
    if (!this.state.signedIn || !this._lines || !this._lines[cell.y]) {
      return;
    }
    const balance = this.state.account ? this.state.account.avocadoBalance : 0;

    if (
      !this._isFreeDrawing() &&
      balance - this.state.pendingPixels < this.state.avocadoNeeded
    ) {
      return;
    }

    const img = this.imageData;
    const w = img.width;
    const h = img.height;
    const x = cell.x - Math.trunc(w / 2);
    const y = cell.y - Math.trunc(h / 2);
    const d = new Uint32Array(this.imageData.data.buffer);
    for (let i = 0; i < h; ++i) {
      for (let j = 0; j < w; ++j) {
        const imgColor = d[i * w + j];
        if (
          imgColor &&
          y + i >= 0 &&
          y + i < BoardHeight &&
          x + j >= 0 &&
          x + j < BoardWidth
        ) {
          const bgColor = this._lines[y + i]
            ? this._lines[y + i][x + j].color
            : 0;
          const color = imgColorToInt(imgColor, bgColor);
          if (color !== bgColor) {
            this._queue.push({
              x: x + j,
              y: y + i,
              color,
            });
          }
        }
      }
    }
    this.setState({
      rendering: false,
    });

    this._stopRefreshTime = new Date().getTime() + MaxWorkTime;
    await this._pingQueue(false);
  }

  async drawPixel(cell) {
    if (!this.state.signedIn || !this._lines || !this._lines[cell.y]) {
      return;
    }
    const balance = this.state.account ? this.state.account.avocadoBalance : 0;
    if (!this._isFreeDrawing() && balance - this.state.pendingPixels < 1) {
      return;
    }

    const bgColor = this._lines[cell.y] ? this._lines[cell.y][cell.x].color : 0;
    const cb = this.state.currentColor & 255;
    const cg = (this.state.currentColor >> 8) & 255;
    const cr = (this.state.currentColor >> 16) & 255;
    const color = rgbaToInt(cr, cg, cb, this.state.alpha, bgColor);

    if (
      this._pending[cell.y][cell.x] !== color &&
      this._lines[cell.y][cell.x].color !== color
    ) {
      this._pending[cell.y][cell.x] = color;
    } else {
      return;
    }

    this._queue.push({
      x: cell.x,
      y: cell.y,
      color,
    });

    this._stopRefreshTime = new Date().getTime() + MaxWorkTime;
    await this._pingQueue(false);
  }

  parseAccount(account, accountId) {
    if (!account) {
      account = {
        accountId,
        accountIndex: -1,
        avocadoBalance: 25.0,
        bananaBalance: 0.0,
        numPixels: 0,
        farmingPreference: Berry.Avocado,
      };
    } else {
      account = {
        accountId: account.account_id,
        accountIndex: account.account_index,
        avocadoBalance: parseFloat(account.avocado_balance) / this._pixelCost,
        bananaBalance: parseFloat(account.banana_balance) / this._pixelCost,
        numPixels: account.num_pixels,
        farmingPreference: account.farming_preference,
      };
    }
    account.startTime = new Date().getTime();
    account.avocadoPixels =
      account.farmingPreference === Berry.Avocado ? account.numPixels + 1 : 0;
    account.bananaPixels =
      account.farmingPreference === Berry.Banana ? account.numPixels : 0;
    account.avocadoRewardPerMs = account.avocadoPixels / (24 * 60 * 60 * 1000);
    account.bananaRewardPerMs = account.bananaPixels / (24 * 60 * 60 * 1000);
    return account;
  }

  async getAccount(accountId) {
    return this.parseAccount(
      await this._contract.get_account({ account_id: accountId }),
      accountId
    );
  }

  async getAccountByIndex(accountIndex) {
    return this.parseAccount(
      await this._contract.get_account_by_index({
        account_index: accountIndex,
      }),
      "unknown"
    );
  }

  async refreshAccountStats() {
    let account = await this.getAccount(this._accountId);
    if (this._balanceRefreshTimer) {
      clearInterval(this._balanceRefreshTimer);
      this._balanceRefreshTimer = null;
    }

    this.setState({
      pendingPixels: this._pendingPixels.length + this._queue.length,
      farmingBanana: account.farmingPreference === Berry.Banana,
      account,
    });

    this._balanceRefreshTimer = setInterval(() => {
      const t = new Date().getTime() - account.startTime;
      this.setState({
        account: Object.assign({}, account, {
          avocadoBalance:
            account.avocadoBalance + t * account.avocadoRewardPerMs,
          bananaBalance: account.bananaBalance + t * account.bananaRewardPerMs,
        }),
        pendingPixels: this._pendingPixels.length + this._queue.length,
      });
    }, 100);
  }

  async _initNear() {
    const keyStore = new nearAPI.keyStores.BrowserLocalStorageKeyStore();
    const near = await nearAPI.connect(
      Object.assign({ deps: { keyStore } }, NearConfig)
    );
    this._keyStore = keyStore;
    this._near = near;

    this._walletConnection = new nearAPI.WalletConnection(
      near,
      NearConfig.contractName
    );
    this._accountId = this._walletConnection.getAccountId();

    this._account = this._walletConnection.account();
    this._contract = new nearAPI.Contract(
      this._account,
      NearConfig.contractName,
      {
        viewMethods: [
          "get_account",
          "get_account_by_index",
          "get_lines",
          "get_line_versions",
          "get_pixel_cost",
          "get_account_balance",
          "get_account_num_pixels",
          "get_account_id_by_index",
          "get_free_drawing_timestamp",
        ],
        changeMethods: ["draw", "buy_tokens", "select_farming_preference"],
      }
    );
    this._pixelCost = parseFloat(await this._contract.get_pixel_cost());
    const freeDrawingTimestamp =
      await this._contract.get_free_drawing_timestamp();
    this._freeDrawingStart = new Date(freeDrawingTimestamp);
    this._freeDrawingEnd = new Date(freeDrawingTimestamp + OneDayMs);
    if (this._accountId) {
      await this.refreshAccountStats();
    }
    this._lineVersions = Array(BoardHeight).fill(-1);
    this._lines = Array(BoardHeight).fill(false);
    this._pending = Array(BoardHeight).fill(false);
    this._pending.forEach((v, i, a) => (a[i] = Array(BoardWidth).fill(-1)));
    await this.refreshBoard(true);
  }

  async refreshBoard(forced) {
    if (this._refreshBoardTimer) {
      clearTimeout(this._refreshBoardTimer);
      this._refreshBoardTimer = null;
    }
    const t = new Date().getTime();
    if (this.state.watchMode || t < this._stopRefreshTime) {
      this._refreshBoardTimer = setTimeout(async () => {
        await this.refreshBoard(false);
      }, RefreshBoardTimeout);
    }

    if (!forced && document.hidden) {
      return;
    }

    let lineVersions = await this._contract.get_line_versions();
    let needLines = [];
    for (let i = 0; i < BoardHeight; ++i) {
      if (lineVersions[i] !== this._lineVersions[i]) {
        needLines.push(i);
      }
    }
    let requestLines = [];
    for (let i = 0; i < needLines.length; i += NumLinesPerFetch) {
      requestLines.push(needLines.slice(i, i + NumLinesPerFetch));
    }

    let results = await Promise.all(
      requestLines.map((lines) => this._contract.get_lines({ lines }))
    );
    results = results.flat();
    requestLines = requestLines.flat();
    for (let i = 0; i < requestLines.length; ++i) {
      let lineIndex = requestLines[i];
      let line = decodeLine(results[i]);
      this._lines[lineIndex] = line;
    }

    this._lineVersions = lineVersions;
    if (!this.state.watchMode) {
      this._refreshOwners();
    }
    this.renderCanvas();
  }

  _refreshOwners() {
    const counts = {};
    this._lines.flat().forEach((cell) => {
      counts[cell.ownerIndex] = (counts[cell.ownerIndex] || 0) + 1;
    });
    delete counts[0];
    const sortedKeys = Object.keys(counts).sort(
      (a, b) => counts[b] - counts[a]
    );
    this.setState({
      owners: sortedKeys.map((accountIndex) => {
        accountIndex = parseInt(accountIndex);
        return {
          accountIndex,
          numPixels: counts[accountIndex],
        };
      }),
    });
    sortedKeys.forEach(async (accountIndex) => {
      accountIndex = parseInt(accountIndex);
      if (
        !(accountIndex in this._accounts) ||
        counts[accountIndex] !== (this._oldCounts[accountIndex] || 0)
      ) {
        try {
          this._accounts[accountIndex] = await this.getAccountByIndex(
            accountIndex
          );
        } catch (err) {
          console.log("Failed to fetch account index #", accountIndex, err);
        }
        this.setState({
          accounts: Object.assign({}, this._accounts),
        });
      }
    });
    this.setState({
      accounts: Object.assign({}, this._accounts),
    });
    this._oldCounts = counts;
  }

  renderCanvas() {
    if (!this._context || !this._lines) {
      return;
    }

    const ctx = this._context;

    for (let i = 0; i < BoardHeight; ++i) {
      const line = this._lines[i];
      if (!line) {
        continue;
      }
      for (let j = 0; j < BoardWidth; ++j) {
        const p = line[j];
        ctx.fillStyle = intToColor(p.color);
        ctx.fillRect(j * CellWidth, i * CellHeight, CellWidth, CellHeight);
        if (this.state.highlightedAccountIndex >= 0) {
          if (p.ownerIndex !== this.state.highlightedAccountIndex) {
            ctx.fillStyle = "rgba(32, 32, 32, 0.8)";
            ctx.fillRect(
              j * CellWidth,
              i * CellHeight,
              CellWidth / 2,
              CellHeight / 2
            );
            ctx.fillRect(
              (j + 0.5) * CellWidth,
              (i + 0.5) * CellHeight,
              CellWidth / 2,
              CellHeight / 2
            );
            ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
            ctx.fillRect(
              j * CellWidth,
              (i + 0.5) * CellHeight,
              CellWidth / 2,
              CellHeight / 2
            );
            ctx.fillRect(
              (j + 0.5) * CellWidth,
              i * CellHeight,
              CellWidth / 2,
              CellHeight / 2
            );
          } else {
            ctx.beginPath();
            ctx.strokeStyle = ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
            ctx.lineWidth = 0.5;
            ctx.rect(
              j * CellWidth + 0.5,
              i * CellHeight + 0.5,
              CellWidth - 1,
              CellHeight - 1
            );
            ctx.stroke();
            ctx.closePath();
          }
        }
      }
    }

    this._pendingPixels.concat(this._queue).forEach((p) => {
      ctx.fillStyle = intToColor(p.color);
      ctx.fillRect(p.x * CellWidth, p.y * CellHeight, CellWidth, CellHeight);
    });

    if (this.state.selectedCell && !this.state.watchMode) {
      const c = this.state.selectedCell;
      if (this.state.rendering) {
        const img = this.imageData;
        const w = img.width;
        const h = img.height;
        const x = c.x - Math.trunc(w / 2);
        const y = c.y - Math.trunc(h / 2);
        const d = new Uint32Array(this.imageData.data.buffer);
        for (let i = 0; i < h; ++i) {
          for (let j = 0; j < w; ++j) {
            const color = d[i * w + j];
            if (
              color &&
              y + i >= 0 &&
              y + i < BoardHeight &&
              x + j >= 0 &&
              x + j < BoardWidth
            ) {
              const bgColor = this._lines[y + i]
                ? this._lines[y + i][x + j].color
                : 0;
              ctx.fillStyle = intToColor(imgColorToInt(color, bgColor));
              ctx.fillRect(
                (x + j) * CellWidth,
                (y + i) * CellHeight,
                CellWidth,
                CellHeight
              );
            }
          }
        }
      } else if (this.state.pickingColor) {
        const color = this._lines[c.y] ? this._lines[c.y][c.x].color : 0;
        ctx.beginPath();
        ctx.strokeStyle = ctx.fillStyle = transparentColor(color, 0.5);
        ctx.lineWidth = CellWidth * 4;
        ctx.arc(
          (c.x + 0.5) * CellWidth,
          (c.y + 0.5) * CellHeight,
          CellWidth * 4,
          0,
          2 * Math.PI
        );
        ctx.stroke();
        ctx.closePath();

        ctx.beginPath();
        ctx.strokeStyle = ctx.fillStyle = transparentColor(color, 1);
        ctx.lineWidth = CellWidth * 2;
        ctx.arc(
          (c.x + 0.5) * CellWidth,
          (c.y + 0.5) * CellHeight,
          CellWidth * 4,
          0,
          2 * Math.PI
        );
        ctx.stroke();
        ctx.closePath();
      } else {
        ctx.fillStyle = transparentColor(this.state.currentColor, 0.2);
        ctx.fillRect(c.x * CellWidth, 0, CellWidth, c.y * CellHeight);
        ctx.fillRect(
          c.x * CellWidth,
          (c.y + 1) * CellHeight,
          CellWidth,
          (BoardHeight - c.y - 1) * CellHeight
        );
        ctx.fillRect(0, c.y * CellHeight, c.x * CellWidth, CellHeight);
        ctx.fillRect(
          (c.x + 1) * CellWidth,
          c.y * CellHeight,
          (BoardWidth - c.x - 1) * CellWidth,
          CellHeight
        );

        ctx.beginPath();
        ctx.lineWidth = 3;
        ctx.fillStyle = intToColor(this.state.currentColor);
        ctx.strokeStyle = intToColor(this.state.currentColor);
        ctx.rect(c.x * CellWidth, c.y * CellHeight, CellWidth, CellHeight);
        ctx.stroke();
        ctx.closePath();
      }
    }

    if (!this.state.boardLoaded) {
      this.setState({
        boardLoaded: true,
      });
    }
  }

  async requestSignIn() {
    const appTitle = "Berry Club";
    await this._walletConnection.requestSignIn(
      NearConfig.contractName,
      appTitle
    );
  }

  async logOut() {
    this._walletConnection.signOut();
    this._accountId = null;
    this.setState({
      signedIn: !!this._accountId,
      accountId: this._accountId,
    });
  }

  async alphaColorChange(c) {
    this.setState(
      {
        alpha: c.rgb.a,
      },
      () => {
        this.changeColor(c, c.rgb.a);
      }
    );
  }

  hueColorChange(c) {
    this.setState({
      gammaColors: generateGamma(c.hsl.h),
    });
    this.changeColor(c);
  }

  saveColor() {
    const newColor = intToColor(this.state.currentColor);
    const index = this.state.colors.indexOf(newColor);
    if (index >= 0) {
      this.state.colors.splice(index, 1);
    }
    this.setState({
      colors: [newColor].concat(this.state.colors).slice(0, MaxNumColors),
    });
  }

  changeColor(c, alpha) {
    alpha = alpha || 1.0;
    const currentColor = c.rgb.r * 0x010000 + c.rgb.g * 0x000100 + c.rgb.b;
    c.hex = intToColorWithAlpha(currentColor, alpha);
    c.rgb.a = alpha;
    c.hsl.a = alpha;
    c.hsv.a = alpha;
    this.setState(
      {
        pickerColor: c,
        alpha,
        currentColor,
      },
      () => {
        this.renderCanvas();
      }
    );
  }

  async buyTokens(amount) {
    const requiredBalance = PixelPrice.muln(amount);
    await this._contract.buy_tokens(
      {},
      new BN("30000000000000"),
      requiredBalance
    );
  }

  setHover(accountIndex, v) {
    if (v) {
      this.setState(
        {
          highlightedAccountIndex: accountIndex,
        },
        () => {
          this.renderCanvas();
        }
      );
    } else if (this.state.highlightedAccountIndex === accountIndex) {
      this.setState(
        {
          highlightedAccountIndex: -1,
        },
        () => {
          this.renderCanvas();
        }
      );
    }
  }

  async switchBerry(farmingBanana) {
    this.setState({
      farmingBanana,
    });
    await this._contract.select_farming_preference({
      berry: farmingBanana ? Berry.Banana : Berry.Avocado,
    });
    await this.refreshAccountStats();
  }

  async renderImg(img, avocadoNeeded) {
    this.imageData = img;
    this.setState({
      weaponsOn: false,
      weaponsCodePosition: 0,
      rendering: true,
      pickingColor: false,
      avocadoNeeded,
    });
  }

  _isFreeDrawing() {
    const date = new Date();
    return (
      this.state.freeDrawingStart <= date && date < this.state.freeDrawingEnd
    );
  }

  enableWatchMode() {
    this.setState({
      watchMode: true,
      weaponsOn: false,
      weaponsCodePosition: 0,
    });
    document.body.style.transition = "3s";
    document.body.style.backgroundColor = "#333";
  }

  render() {
    const watchClass = this.state.watchMode ? " hidden" : "";
    const isFreeDrawing = this._isFreeDrawing();
    const freeDrawing = (
      <div
        className={`free-drawing ${
          isFreeDrawing ? "free" : "wait"
        }${watchClass}`}
      >
        {isFreeDrawing
          ? "BANANZA!!! Draw for free "
          : "Time until free drawing "}
        <Timer
          initialTime={
            isFreeDrawing
              ? this.state.freeDrawingEnd - new Date()
              : this.state.freeDrawingStart - new Date()
          }
          direction="backward"
          timeToUpdate={100}
          lastUnit="d"
          checkpoints={[
            {
              time: 0,
            },
          ]}
        >
          {() => (
            <React.Fragment>
              <Timer.Days
                formatValue={(v) => (v > 1 ? `${v} days ` : v ? `1 day ` : "")}
              />
              <Timer.Hours />:
              <Timer.Minutes formatValue={(v) => `${v}`.padStart(2, "0")} />:
              <Timer.Seconds formatValue={(v) => `${v}`.padStart(2, "0")} />.
              <Timer.Milliseconds
                formatValue={(v) => `${v}`.padStart(3, "0")}
              />
            </React.Fragment>
          )}
        </Timer>
      </div>
    );

    const firstRow = !this.state.connected ? (
      <div>
        Connecting...{" "}
        <span
          className="spinner-grow spinner-grow-sm"
          role="status"
          aria-hidden="true"
        />
      </div>
    ) : this.state.signedIn ? (
      <HStack w="100%" justify="space-between" pb="2">
        {freeDrawing}
        <Button
          variant="outline"
          rounded="xl"
          border="2px"
          borderColor="brand.900"
          color="brand.900"
          _hover={{ filter: "brightness(0.5)" }}
          onClick={() => this.logOut()}
        >
          Log out ({this.state.accountId})
        </Button>
      </HStack>
    ) : (
      <div style={{ marginBottom: "10px" }}>{freeDrawing}</div>
    );
    const content = !this.state.connected ? (
      <div>
        Connecting...{" "}
        <span
          className="spinner-grow spinner-grow-sm"
          role="status"
          aria-hidden="true"
        />
      </div>
    ) : this.state.signedIn ? (
      <VStack align="start">
        <Heading color="brand.100" size="md">
          Buy Avocados
        </Heading>

        <HStack spacing="2">
          <Button
            variant="solid"
            rounded="xl"
            fontSize="sm"
            background="brand.900"
            _hover={{ filter: "brightness(0.8)" }}
            onClick={() => this.buyTokens(10)}
          >
            Buy 25 {Avocado} for ‚ìÉ0.1
          </Button>
          <Button
            variant="solid"
            rounded="xl"
            fontSize="sm"
            background="brand.900"
            _hover={{ filter: "brightness(0.8)" }}
            onClick={() => this.buyTokens(40)}
          >
            Buy 100 {Avocado} for ‚ìÉ0.4
          </Button>
        </HStack>
        <HStack spacing="2">
          <Button
            variant="solid"
            rounded="xl"
            fontSize="sm"
            background="brand.900"
            _hover={{ filter: "brightness(0.8)" }}
            onClick={() => this.buyTokens(100)}
          >
            Buy 250 {Avocado} for ‚ìÉ1
          </Button>
          <Button
            variant="solid"
            rounded="xl"
            fontSize="sm"
            bgGradient="linear(to-r, #FF0080, brand.100)"
            _hover={{ filter: "brightness(0.8)" }}
            onClick={() => this.buyTokens(500)}
          >
            DEAL: Buy 1500 {Avocado} for ‚ìÉ5
          </Button>
        </HStack>

        <VStack color="brand.900" align="start">
          <Heading fontWeight="300" size="lg" color="brand.100">
            Your Balances{" "}
          </Heading>
          <Balance
            account={this.state.account}
            pendingPixels={this.state.pendingPixels}
            isFreeDrawing={isFreeDrawing}
            detailed={true}
          />
          <HStack spacing="2">
            <Heading fontWeight="300" size="md">
              Farming preference:
            </Heading>
            <ReactSwitch
              onChange={(e) => this.switchBerry(e)}
              checked={this.state.farmingBanana}
              className="react-switch"
              height={30}
              width={70}
              offColor="#666"
              onColor="#666"
              uncheckedIcon={
                <div className="switch-berry avocado">{Avocado}</div>
              }
              checkedIcon={<div className="switch-berry banana">{Banana}</div>}
            />
          </HStack>
        </VStack>
        <div className={`color-picker${watchClass}`}>
          <HuePicker
            color={this.state.pickerColor}
            width="100%"
            onChange={(c) => this.hueColorChange(c)}
          />
          <AlphaPicker
            color={this.state.pickerColor}
            width="100%"
            onChange={(c) => this.alphaColorChange(c)}
          />
          <div
            className={this.state.alpha >= 0.75 ? "display-warning" : "hidden"}
          >
            <span role="img" aria-label="warning">
              ‚ö†Ô∏è
            </span>
            Ô∏è Please! Don't destroy art! If you just want to farm {Banana}, just
            draw with low opacity.
            <span role="img" aria-label="pray">
              üôè
            </span>
            Ô∏è
          </div>
          <GithubPicker
            className="circle-picker"
            colors={this.state.gammaColors}
            color={this.state.pickerColor}
            triangle="hide"
            width="100%"
            onChangeComplete={(c) => this.changeColor(c)}
          />
          <GithubPicker
            className="circle-picker"
            colors={this.state.colors}
            color={this.state.pickerColor}
            triangle="hide"
            width="100%"
            onChangeComplete={(c) => this.hueColorChange(c)}
          />
        </div>
      </VStack>
    ) : (
      <Button
        variant="solid"
        rounded="xl"
        background="brand.900"
        _hover={{ filter: "brightness(0.8)" }}
        onClick={() => this.requestSignIn()}
      >
        Log in with NEAR Wallet
      </Button>
    );
    const weapons = this.state.weaponsOn ? (
      <div>
        <Weapons
          account={this.state.account}
          isFreeDrawing={isFreeDrawing}
          renderIt={(img, avocadoNeeded) => this.renderImg(img, avocadoNeeded)}
          enableWatchMode={() => this.enableWatchMode()}
        />
      </div>
    ) : (
      ""
    );
    return (
      <div>
        {firstRow}
        <Center h="100px" color="brand.100">
          <Heading size="3xl" alignSelf="center">
            Unleash your art!
          </Heading>
        </Center>

        <Grid
          templateRows={{
            sm: "1fr 1fr 1fr",
            md: "1fr 1fr",
            lg: "1fr",
          }}
          templateColumns={{
            sm: "1fr",
            md: "1fr 1fr",
            lg: "1fr 600px 1fr",
          }}
          gap={4}
          autoFlow="row dense"
        >
          <GridItem>
            <Box rounded="xl" background="white" p="4">
              {content}
            </Box>
          </GridItem>
          <GridItem>
            <Box rounded="xl" background="white" p="2">
              <canvas
                ref={this.canvasRef}
                width={600}
                height={600}
                className={
                  this.state.boardLoaded
                    ? `pixel-board${this.state.watchMode ? " watch-mode" : ""}`
                    : "pixel-board c-animated-background"
                }
              />
            </Box>
          </GridItem>
          <GridItem>
            <Box rounded="xl" background="white" p="4">
              <Heading color="brand.100">Leaderboard</Heading>

              <Leaderboard
                owners={this.state.owners}
                accounts={this.state.accounts}
                setHover={(accountIndex, v) => this.setHover(accountIndex, v)}
                selectedOwnerIndex={this.state.selectedOwnerIndex}
                highlightedAccountIndex={this.state.highlightedAccountIndex}
              />
            </Box>
          </GridItem>
        </Grid>

        <div className={`padded${watchClass}`}>
          {this.state.signedIn ? (
            <div>
              <iframe
                title="irc"
                className="irc"
                frameBorder="0"
                src={`https://kiwiirc.com/client/irc.kiwiirc.com/?nick=${this.state.ircAccountId}#berryclub`}
              />
            </div>
          ) : (
            ""
          )}
        </div>
        {weapons}
      </div>
    );
  }
}

const Balance = (props) => {
  const account = props.account;
  if (!account) {
    return "";
  }
  const fraction = props.detailed ? 3 : 1;
  const avacadoBalance =
    account.avocadoBalance -
    (props.isFreeDrawing ? 0 : props.pendingPixels || 0);
  const avocadoFarm =
    account.avocadoPixels > 0 ? (
      <span>
        {"(+"}
        <span className="font-weight-bold">{account.avocadoPixels}</span>
        {Avocado}
        {"/day)"}
      </span>
    ) : (
      ""
    );
  const bananaFarm =
    account.bananaPixels > 0 ? (
      <span>
        {"(+"}
        <span className="font-weight-bold">{account.bananaPixels}</span>
        {Banana}
        {"/day)"}
      </span>
    ) : (
      ""
    );
  return (
    <Box>
      <Text>
        Avocados{" "}
        <span className="font-weight-bold">
          {avacadoBalance.toFixed(fraction)}
        </span>
        {Avocado}{" "}
      </Text>
      <Text>
        Bananas{" "}
        <span className="font-weight-bold">
          {account.bananaBalance.toFixed(fraction)}
        </span>
        {Banana} {avocadoFarm}
        {bananaFarm}
        {props.pendingPixels ? (
          <span> ({props.pendingPixels} pending)</span>
        ) : (
          ""
        )}
      </Text>
    </Box>
  );
};

const LeaderboardBalance = (props) => {
  const account = props.account;
  if (!account) {
    return "";
  }
  const fraction = props.detailed ? 3 : 1;
  const avacadoBalance =
    account.avocadoBalance -
    (props.isFreeDrawing ? 0 : props.pendingPixels || 0);
  const avocadoFarm =
    account.avocadoPixels > 0 ? (
      <span>
        {"(+"}
        <span className="font-weight-bold">{account.avocadoPixels}</span>
        {Avocado}
        {"/day)"}
      </span>
    ) : (
      ""
    );
  const bananaFarm =
    account.bananaPixels > 0 ? (
      <span>
        {"(+"}
        <span className="font-weight-bold">{account.bananaPixels}</span>
        {Banana}
        {"/day)"}
      </span>
    ) : (
      ""
    );
  return (
    <span className="balances font-small">
      <span className="font-weight-bold">
        {avacadoBalance.toFixed(fraction)}
      </span>
      {Avocado}{" "}
      <span className="font-weight-bold">
        {account.bananaBalance.toFixed(fraction)}
      </span>
      {Banana} {avocadoFarm}
      {bananaFarm}
      {props.pendingPixels ? <span> ({props.pendingPixels} pending)</span> : ""}
    </span>
  );
};

const Leaderboard = (props) => {
  const owners = props.owners.map((owner) => {
    if (owner.accountIndex in props.accounts) {
      owner.account = props.accounts[owner.accountIndex];
    }
    return (
      <Owner
        key={owner.accountIndex}
        {...owner}
        isSelected={owner.accountIndex === props.selectedOwnerIndex}
        setHover={(v) => props.setHover(owner.accountIndex, v)}
        isHighlighted={owner.accountIndex === props.highlightedAccountIndex}
      />
    );
  });
  return (
    <table className="table table-hover table-sm">
      <tbody>{owners}</tbody>
    </table>
  );
};

const Owner = (props) => {
  const account = props.account;
  return (
    <tr
      onMouseEnter={() => props.setHover(true)}
      onMouseLeave={() => props.setHover(false)}
      className={props.isSelected ? "selected" : ""}
    >
      <HStack justify="space-between">
        <td>{account ? <Account accountId={account.accountId} /> : "..."}</td>
        <td className="text-nowrap">
          <small>
            <LeaderboardBalance account={account} />
          </small>
        </td>
      </HStack>
    </tr>
  );
};

const Account = (props) => {
  const accountId = props.accountId;
  const shortAccountId =
    accountId.length > 6 + 6 + 3
      ? accountId.slice(0, 6) + "..." + accountId.slice(-6)
      : accountId;
  return (
    <Text color="brand.900">
      <a className="account" href={`https://wayback.berryclub.io/${accountId}`}>
        {shortAccountId}
      </a>
    </Text>
  );
};

export default ClubPage;

'''
'''--- frontend/src/pages/Discover.js ---
import React, { useEffect, useState } from "react";
import uuid from "react-uuid";
import CardPreview from "../components/CardPreview";
import InfiniteScroll from "react-infinite-scroller";
import { SimpleGrid, Heading } from "@chakra-ui/react";

const FetchLimit = 25;

function DiscoverPage(props) {
  const [feed, setFeed] = useState([]);
  const [hasMore, setHasMore] = useState(false);
  const [gkey] = useState(uuid());

  const fetchMore = async () => {
    const f = [...feed];
    const lastKey = f.length > 0 ? f[f.length - 1] : null;
    const fetched = await props._near.contract.get_top({
      from_key: lastKey,
      limit: FetchLimit,
    });
    f.push(...fetched);
    if (fetched.length === 0) {
      setHasMore(false);
    }
    setFeed(f);
  };

  useEffect(() => {
    if (props.connected) {
      setHasMore(true);
    }
  }, [props.connected]);

  const cards = feed.map(([rating, cardId]) => {
    const key = `${gkey}-${cardId}`;
    return <CardPreview {...props} key={key} cardId={cardId} rating={rating} />;
  });

  const loader = (
    <div className="d-flex justify-content-center" key={`${gkey}-loader`}>
      <div className="spinner-grow" role="status">
        <span className="visually-hidden">Loading...</span>
      </div>
    </div>
  );

  return (
    <div>
      <Heading size="3xl" fontWeight="normal">
        Top
      </Heading>
      <InfiniteScroll
        pageStart={0}
        loadMore={fetchMore}
        hasMore={hasMore}
        loader={loader}
      >
        <SimpleGrid columns={4} spacing={10}>
          {cards}
        </SimpleGrid>
      </InfiniteScroll>
    </div>
  );
}

export default DiscoverPage;

'''
'''--- frontend/src/pages/FarmPage.js ---
// import "./FarmPage.scss";
import React from "react";
import BN from "bn.js";
import * as nearAPI from "near-api-js";
import InputNumber from "react-input-number";
import Timer from "react-compound-timer";
import {
  Button,
  HStack,
  Center,
  Heading,
  Box,
  VStack,
  Text,
  Grid,
  GridItem,
  NumberInput,
  NumberInputField,
  NumberInputStepper,
  NumberIncrementStepper,
  NumberDecrementStepper,
} from "@chakra-ui/react";
const IsMainnet = window.location.hostname === "berry.cards";
const TestNearConfig = {
  networkId: "testnet",
  nodeUrl: "https://rpc.testnet.near.org",
  bananaContractName: "berryclub.testnet",
  contractName: "farm.berryclub.testnet",
  walletUrl: "https://wallet.testnet.near.org",
};
const MainNearConfig = {
  networkId: "mainnet",
  nodeUrl: "https://rpc.mainnet.near.org",
  bananaContractName: "berryclub.ek.near",
  contractName: "farm.berryclub.ek.near",
  walletUrl: "https://wallet.near.org",
};
const NearConfig = IsMainnet ? MainNearConfig : TestNearConfig;

const Avocado = (
  <span role="img" aria-label="avocado" className="berry">
    ü•ë
  </span>
);
const Banana = (
  <span role="img" aria-label="banana" className="berry">
    üçå
  </span>
);
const Cucumber = (
  <span role="img" aria-label="cucumber" className="berry">
    ü•í
  </span>
);
const Near = (
  <span role="img" aria-label="near" className="berry">
    ‚ìÉ
  </span>
);

const Berry = {
  Avocado: "Avocado",
  Banana: "Banana",
};

class FarmPage extends React.Component {
  constructor(props) {
    super(props);

    this.state = {
      connected: false,
      signedIn: false,
      accountId: null,
      account: null,
      claiming: false,
      bananaNum: 1,
    };
    this._balanceRefreshTimer = null;

    this._initNear().then(() => {
      this.setState({
        connected: true,
        signedIn: !!this._accountId,
        accountId: this._accountId,
      });
    });
  }

  componentDidMount() {}

  parseBananaAccount(account, accountId) {
    if (!account) {
      account = {
        accountId,
        accountIndex: -1,
        avocadoBalance: 25.0,
        bananaBalance: 0.0,
        bananaBalanceBN: new BN(0),
        numPixels: 0,
        farmingPreference: Berry.Avocado,
      };
    } else {
      account = {
        accountId: account.account_id,
        accountIndex: account.account_index,
        avocadoBalance: parseFloat(account.avocado_balance) / this._pixelCost,
        bananaBalance: parseFloat(account.banana_balance) / this._pixelCost,
        bananaBalanceBN: new BN(account.banana_balance),
        numPixels: account.num_pixels,
        farmingPreference: account.farming_preference,
      };
    }
    account.startTime = new Date().getTime();
    account.avocadoPixels =
      account.farmingPreference === Berry.Avocado ? account.numPixels + 1 : 0;
    account.bananaPixels =
      account.farmingPreference === Berry.Banana ? account.numPixels : 0;
    account.avocadoRewardPerMs = account.avocadoPixels / (24 * 60 * 60 * 1000);
    account.bananaRewardPerMs = account.bananaPixels / (24 * 60 * 60 * 1000);
    account.bananaRewardPerMsBN = account.bananaBalanceBN.div(
      new BN(24 * 60 * 60 * 1000)
    );
    return account;
  }

  async getAccount(accountId, stats) {
    const account = this.parseBananaAccount(
      await this._bananaContract.get_account({ account_id: accountId }),
      accountId
    );
    let cucumberAccount = await this._contract.get_account({
      account_id: accountId,
    });
    if (!cucumberAccount) {
      Object.assign(account, {
        nearBalanceBn: new BN(0),
        cucumberBalanceBn: new BN(0),
        nearClaimed: 0,
      });
    } else {
      Object.assign(account, {
        nearBalanceBn: new BN(cucumberAccount.near_balance),
        cucumberBalanceBn: new BN(cucumberAccount.cucumber_balance),
        nearClaimed:
          parseFloat(cucumberAccount.near_claimed) / Math.pow(10, 24),
      });
    }
    await this._account.fetchState();
    // account.accountNearBalance = parseFloat(this._account._state.amount) / 1e24;
    account.nearBalance =
      parseFloat(account.nearBalanceBn.toString()) / Math.pow(10, 24);
    account.cucumberBalance =
      parseFloat(account.cucumberBalanceBn.toString()) / this._pixelCost;
    account.percent = (account.cucumberBalance * 100) / stats.totalSupply;
    return account;
  }

  async refreshStats(forced) {
    if (!forced && document.hidden) {
      return;
    }

    let currentTime = new Date().getTime();
    const nextReward =
      parseFloat(await this._bananaContract.get_next_reward_timestamp()) / 1e6;
    const lastReward =
      parseFloat(await this._bananaContract.get_last_reward_timestamp()) / 1e6;
    const expectedReward =
      parseFloat(await this._bananaContract.get_expected_reward()) / 1e24;
    const rawStats = await this._contract.get_stats();
    const stats = {
      totalSupplyBn: new BN(rawStats.total_cucumber_balance),
      totalSupply:
        parseFloat(rawStats.total_cucumber_balance) / this._pixelCost,
      totalNearClaimed:
        parseFloat(rawStats.total_near_claimed) / Math.pow(10, 24),
      totalNearRewarded:
        parseFloat(rawStats.total_near_received) / Math.pow(10, 24),
      timeToNextRewards: nextReward - currentTime,
      timeFromLastRewards: currentTime - lastReward,
      expectedReward,
    };
    this.setState({
      stats,
    });
  }

  async refreshAccountStats() {
    await this.refreshStats(true);
    let account = await this.getAccount(this._accountId, this.state.stats);

    if (this._balanceRefreshTimer) {
      clearInterval(this._balanceRefreshTimer);
      this._balanceRefreshTimer = null;
    }

    this.setState({
      account,
    });

    this._balanceRefreshTimer = setInterval(() => {
      const t = new Date().getTime() - account.startTime;
      this.setState({
        account: Object.assign({}, account, {
          avocadoBalance:
            account.avocadoBalance + t * account.avocadoRewardPerMs,
          bananaBalance: account.bananaBalance + t * account.bananaRewardPerMs,
        }),
      });
    }, 100);
  }

  async _initNear() {
    const keyStore = new nearAPI.keyStores.BrowserLocalStorageKeyStore();
    const near = await nearAPI.connect(
      Object.assign({ deps: { keyStore } }, NearConfig)
    );
    this._keyStore = keyStore;
    this._near = near;

    this._walletConnection = new nearAPI.WalletConnection(
      near,
      NearConfig.contractName
    );
    this._accountId = this._walletConnection.getAccountId();

    this._account = this._walletConnection.account();
    this._bananaContract = new nearAPI.Contract(
      this._account,
      NearConfig.bananaContractName,
      {
        viewMethods: [
          "get_account",
          "get_expected_reward",
          "get_next_reward_timestamp",
          "get_last_reward_timestamp",
          "get_account_by_index",
          "get_lines",
          "get_line_versions",
          "get_pixel_cost",
          "get_account_balance",
          "get_account_num_pixels",
          "get_account_id_by_index",
        ],
        changeMethods: ["transfer_with_vault", "ft_transfer_call"],
      }
    );
    this._contract = new nearAPI.Contract(
      this._account,
      NearConfig.contractName,
      {
        viewMethods: [
          "account_exists",
          "get_account",
          "get_stats",
          "get_near_balance",
          "get_total_near_claimed",
          "get_total_near_received",
          "get_balance",
          "get_total_supply",
        ],
        changeMethods: ["claim_near", "transfer_raw"],
      }
    );
    this._pixelCostBN = new BN(await this._bananaContract.get_pixel_cost());
    this._pixelCost = parseFloat(this._pixelCostBN.toString());
    await this.refresh();
  }

  async requestSignIn() {
    const appTitle = "Berry Farm";
    await this._walletConnection.requestSignIn(
      NearConfig.contractName,
      appTitle
    );
  }

  async logOut() {
    this._walletConnection.signOut();
    this._accountId = null;
    this.setState({
      signedIn: !!this._accountId,
      accountId: this._accountId,
    });
  }

  async stakeBananas(bananas) {
    await this.refreshAccountStats();
    if (bananas) {
      bananas = new BN(Math.trunc(bananas * 100000))
        .mul(this._pixelCostBN)
        .div(new BN(100000));
    } else {
      bananas = this.state.account.bananaBalanceBN;
    }
    await this._bananaContract.ft_transfer_call(
      {
        receiver_id: NearConfig.contractName,
        amount: bananas.toString(),
        memo: `Swapping ${bananas.toString()} üçå to get ${bananas.toString()} ü•í`,
        msg: '"DepositAndStake"',
      },
      new BN("50000000000000"),
      new BN("1")
    );
  }

  async claimNear() {
    this.setState({
      claiming: true,
    });
    await this._contract.claim_near();
    await this.refreshAccountStats();
    this.setState({
      claiming: false,
    });
  }

  async refresh() {
    if (this._accountId) {
      await this.refreshAccountStats();
    } else {
      await this.refreshStats(true);
    }
  }

  render() {
    const account = this.state.account;
    const fraction = 3;
    const firstRow = !this.state.connected ? (
      <div></div>
    ) : this.state.signedIn ? (
      <HStack w="100%" justify="end" pb="2">
        <Button
          variant="outline"
          rounded="xl"
          border="2px"
          borderColor="brand.900"
          color="brand.900"
          _hover={{ filter: "brightness(0.5)" }}
          onClick={() => this.logOut()}
        >
          Log out ({this.state.accountId})
        </Button>
      </HStack>
    ) : (
      <div style={{ marginBottom: "10px" }}></div>
    );
    const content = !this.state.connected ? (
      <div>
        Connecting...{" "}
        <span
          className="spinner-grow spinner-grow-sm"
          role="status"
          aria-hidden="true"
        ></span>
      </div>
    ) : this.state.signedIn ? (
      <div>
        <div>
          {account ? (
            <VStack color="brand.900" align="start">
              <HStack>
                <Heading fontWeight="300" size="lg" color="brand.100">
                  Your Balances{" "}
                </Heading>
                <Button
                  color="white"
                  variant="solid"
                  rounded="xl"
                  fontSize="sm"
                  bgGradient="linear(to-r, #FF0080, brand.100)"
                  _hover={{ filter: "brightness(0.8)" }}
                  onClick={() => this.refreshAccountStats()}
                >
                  Refresh
                </Button>
              </HStack>
              <Text>
                Avocados {account.avocadoBalance.toFixed(fraction)} {Avocado}
                {account.avocadoPixels > 0 ? (
                  <span>
                    {" (+"}
                    {account.avocadoPixels}
                    {Avocado}
                    {"/day)"}
                  </span>
                ) : (
                  ""
                )}
              </Text>
              <Text>
                Bananas {account.bananaBalance.toFixed(fraction)} {Banana}
                {account.bananaPixels > 0 ? (
                  <span>
                    {" (+"}
                    {account.bananaPixels}
                    {Banana}
                    {"/day)"}
                  </span>
                ) : (
                  ""
                )}
              </Text>
              <Box>
                <Text color="brand.100" py="2">
                  Swap {Banana} to {Cucumber}{" "}
                </Text>

                <NumberInput
                  variant="outline"
                  background="red.100"
                  onChange={(bananaNum) => this.setState({ bananaNum })}
                  value={this.state.bananaNum}
                  min={0.001}
                  max={this.state.account.bananaBalance}
                >
                  <NumberInputField />
                  <NumberInputStepper>
                    <NumberIncrementStepper />
                    <NumberDecrementStepper />
                  </NumberInputStepper>
                </NumberInput>
                <Button
                  disabled={account.bananaBalance === 0}
                  onClick={() => this.setState({ bananaNum: "" })}
                >
                  MAX
                </Button>

                <Swap
                  account={this.state.account}
                  stakeBananas={(b) => this.stakeBananas(b)}
                  amount={this.state.bananaNum}
                />
              </Box>
              <Text>
                {Cucumber} {account.cucumberBalance.toFixed(fraction)}
                {" ("}
                {account.percent.toFixed(fraction)}
                {"% share)"}
              </Text>
              <Button
                color="white"
                variant="solid"
                rounded="xl"
                fontSize="sm"
                background="brand.100"
                _hover={{ filter: "brightness(0.8)" }}
                disabled={account.nearBalance > 0}
                disabled={this.state.claiming}
                onClick={() => this.claimNear()}
              >
                Claim {account.nearBalance.toFixed(fraction)} {Near}
              </Button>
            </VStack>
          ) : (
            ""
          )}
        </div>
      </div>
    ) : (
      <div style={{ marginBottom: "10px" }}>
        <Button
          variant="solid"
          rounded="xl"
          background="brand.900"
          _hover={{ filter: "brightness(0.8)" }}
          onClick={() => this.requestSignIn()}
        >
          Log in with NEAR Wallet
        </Button>
      </div>
    );
    const stats = this.state.stats;
    const statsContent = stats ? (
      <VStack color="brand.900" align="start">
        <HStack>
          <Heading fontWeight="300" size="lg" color="brand.100">
            Rewards{" "}
          </Heading>
          <Button
            color="white"
            variant="solid"
            rounded="xl"
            fontSize="sm"
            bgGradient="linear(to-r, #FF0080, brand.100)"
            _hover={{ filter: "brightness(0.8)" }}
            onClick={() => this.refresh()}
          >
            Refresh
          </Button>
        </HStack>
        <div className="lines">
          <div>Berry Club distributes rewards at most once per minute</div>
          {account ? (
            <div>
              <div>
                <span className="label">Your next reward {Near}</span>
                <span className="balances">
                  {((stats.expectedReward * account.percent) / 100).toFixed(6)}
                </span>
              </div>
              <div>
                <span className="label">Total earned {Near}</span>
                <span className="balances">
                  {(account.nearClaimed + account.nearBalance).toFixed(6)}
                </span>
              </div>
            </div>
          ) : (
            ""
          )}
          <div>
            <span className="label">
              {stats.timeToNextRewards > 0
                ? "Time until next reward"
                : "Time from last reward"}
            </span>
            <span
              className={
                "balances" + (stats.timeToNextRewards < 0 ? " red" : "")
              }
            >
              <Timer
                key={stats.timeToNextRewards}
                initialTime={
                  stats.timeToNextRewards > 0
                    ? stats.timeToNextRewards
                    : stats.timeFromLastRewards
                }
                direction={stats.timeToNextRewards > 0 ? "backward" : "forward"}
                timeToUpdate={100}
                lastUnit="h"
                checkpoints={[
                  {
                    time: 0,
                    callback: () => this.refreshStats(),
                  },
                ]}
              >
                {() => (
                  <React.Fragment>
                    <Timer.Hours />:
                    <Timer.Minutes
                      formatValue={(v) => `${v}`.padStart(2, "0")}
                    />
                    :
                    <Timer.Seconds
                      formatValue={(v) => `${v}`.padStart(2, "0")}
                    />
                    .
                    <Timer.Milliseconds
                      formatValue={(v) => `${v}`.padStart(3, "0")}
                    />
                  </React.Fragment>
                )}
              </Timer>
            </span>
          </div>
          {stats.timeToNextRewards < 0 ? (
            <div className="larger font-weight-bold">
              Use {Avocado} to draw a pixel on berry club to distribute {Near}{" "}
              rewards.
            </div>
          ) : (
            ""
          )}
        </div>
        <HStack>
          <Heading fontWeight="300" size="lg" color="brand.100">
            Global stats
          </Heading>
          <Button
            color="white"
            variant="solid"
            rounded="xl"
            fontSize="sm"
            bgGradient="linear(to-r, #FF0080, brand.100)"
            _hover={{ filter: "brightness(0.8)" }}
            onClick={() => this.refresh()}
          >
            Refresh
          </Button>
        </HStack>
        <div className="lines">
          <div>
            <span className="label">Next reward {Near}</span>
            <span className="balances">{stats.expectedReward.toFixed(6)}</span>
          </div>
          <div>
            <span className="label">Total {Cucumber} Supplied</span>
            <span className="balances">{stats.totalSupply.toFixed(3)}</span>
          </div>
          <div>
            <span className="label">Total {Near} Rewarded</span>
            <span className="balances">
              {stats.totalNearRewarded.toFixed(6)}
            </span>
          </div>
          <div>
            <span className="label">Total {Near} Claimed</span>
            <span className="balances">
              {stats.totalNearClaimed.toFixed(6)}
            </span>
          </div>
        </div>
      </VStack>
    ) : (
      ""
    );
    return (
      <div>
        {firstRow}
        <Center h="100px" color="brand.100">
          <Heading size="3xl" alignSelf="center">
            Swap {Banana} to stake {Cucumber} to farm {Near}
          </Heading>
        </Center>

        <Grid
          templateRows={{
            sm: "1fr 1fr",
            md: "1fr",
            lg: "1fr",
          }}
          templateColumns={{
            sm: "1fr",
            md: "1fr 1fr",
            lg: "1fr 1fr",
          }}
          gap={4}
          autoFlow="row dense"
        >
          <GridItem>
            <Box rounded="xl" background="white" p="4">
              {content}
            </Box>
          </GridItem>
          <GridItem>
            <Box rounded="xl" background="white" p="4">
              {statsContent}
            </Box>
          </GridItem>
        </Grid>
      </div>
    );
  }
}

const Swap = (props) => {
  return (
    <Button
      disabled={props.account.bananaBalance < props.amount}
      onClick={() => props.stakeBananas(props.amount)}
    >
      Swap {props.amount || "ALL"}
      {Banana}
      to <span className="font-weight-bold">{Cucumber}</span>
    </Button>
  );
};

/*
const Account = (props) => {
  const accountId = props.accountId;
  const shortAccountId = (accountId.length > 6 + 6 + 3) ?
    (accountId.slice(0, 6) + '...' + accountId.slice(-6)) :
    accountId;
  return <a className="account"
            href={`https://wayback.berryclub.io/${accountId}`}>{shortAccountId}</a>
}
*/
export default FarmPage;

'''
'''--- frontend/src/pages/Home.js ---
// import "./Home.scss";
import React, { useState } from "react";
import { CardImage, preloadCard } from "../components/CardImage";
import CardPreview from "../components/CardPreview";
import uuid from "react-uuid";
import {
  Heading,
  Box,
  Center,
  Button,
  VStack,
  SimpleGrid, HStack
} from "@chakra-ui/react";
const SelectedLeft = "SelectedLeft";
const SelectedRight = "SelectedRight";
const Skipped = "Skipped";

const DefaultTGas = 100;
const ExtraTGas = 50;
const NumIter = 5;
let votingPromise = Promise.resolve();

function HomePage(props) {
  const [leftReady, setLeftReady] = useState(false);
  const [rightReady, setRightReady] = useState(false);
  const [gkey] = useState(uuid());

  const voteRequest = props.requests ? props.requests[0] : null;

  if (props.requests) {
    props.requests.slice(1).forEach((nextRequest) => {
      preloadCard(nextRequest.left);
      preloadCard(nextRequest.right);
    });
  }

  const vote = async (e, voteRequest, response) => {
    e.preventDefault();
    if (response === SelectedLeft && !leftReady) {
      return;
    }
    if (response === SelectedRight && !rightReady) {
      return;
    }
    props.popRequest();
    const nextPromise = async () => {
      let tgas = DefaultTGas;
      let newRequest = null;
      for (let iter = 0; iter < NumIter; ++iter) {
        try {
          newRequest = await props._near.contract.vote(
            {
              request: voteRequest,
              response,
            },
            tgas.toString() + "000000000000"
          );
        } catch (e) {
          const msg = e.toString();
          console.warn(msg);
          if (msg.indexOf("prepaid gas") !== -1) {
            tgas += ExtraTGas;
            continue;
          }
          if (msg.indexOf("does not have enough balance") !== -1) {
            await props.refreshAllowance();
            return;
          }
        }
        break;
      }
      if (newRequest) {
        if (response === SelectedLeft || response === SelectedRight) {
          const cardId =
            response === SelectedLeft ? voteRequest.left : voteRequest.right;
          props.addRecentCard(cardId);
        }
        props.addRequest(newRequest);
      }
    };

    votingPromise = votingPromise.then(nextPromise);
    // setVotingPromise(nextPromise);
  };

  const cards = props.recentCards.map((cardId) => {
    const key = `${gkey}-${cardId}`;
    return <CardPreview {...props} key={key} cardId={cardId} />;
  });

  return (
    <VStack spacing="4">
      {voteRequest ? (
        <div>
          <Center h="80px" color="brand.100">
            <Heading fontWeight="300" size="lg" color="brand.100">
              Vote
            </Heading>
          </Center>

          <HStack p="4" spacing="4">
            <Box _hover={{ transform: "translateY(-4px)", shadow: "md" }}>
              <div
                className={`card-picker${!leftReady ? " disabled" : ""}`}
                onClick={(e) => vote(e, voteRequest, SelectedLeft)}
              >
                <CardImage
                  className="img-fluid"
                  cardId={voteRequest.left}
                  cardReady={setLeftReady}
                />
              </div>
            </Box>
            <Box _hover={{ transform: "translateY(-4px)", shadow: "md" }}>
              <div
                className={`card-picker${!rightReady ? " disabled" : ""}`}
                onClick={(e) => vote(e, voteRequest, SelectedRight)}
              >
                <CardImage
                  className="img-fluid"
                  cardId={voteRequest.right}
                  cardReady={setRightReady}
                />
              </div>
            </Box>
          </HStack>

          <Button
            w="100%"
            color="white"
            variant="solid"
            rounded="xl"
            fontSize="sm"
            bgGradient="linear(to-r, #FF0080, brand.100)"
            _hover={{ filter: "brightness(0.8)" }}
            onClick={(e) => vote(e, voteRequest, Skipped)}
          >
            Skip both cards
          </Button>
        </div>
      ) : (
        <div className="d-flex justify-content-center">
          <div className="spinner-grow" role="status">
            <span className="visually-hidden">Loading...</span>
          </div>
        </div>
      )}
      <div className="row justify-content-md-center mb-3">
        {cards.length > 0 && (
          <div>
            <Heading fontWeight="300" size="lg" color="brand.100">
              Recent votes
            </Heading>
            <SimpleGrid columns={4} spacing={10}>
              {cards}
            </SimpleGrid>
          </div>
        )}
      </div>
    </VStack>
  );
}

export default HomePage;

'''
'''--- frontend/src/pages/Recent.js ---
import React, { useEffect, useState } from "react";
import uuid from "react-uuid";
import CardPreview from "../components/CardPreview";
import InfiniteScroll from "react-infinite-scroller";
import { SimpleGrid, Heading } from "@chakra-ui/react";
const FetchLimit = 100;

function RecentPage(props) {
  const [feed, setFeed] = useState([]);
  const [hasMore, setHasMore] = useState(false);
  const [gkey] = useState(uuid());

  const fetchMore = async () => {
    const f = [...feed];
    const offset = f.length;
    const fetched = await props._near.contract.get_recent_cards({
      offset,
      limit: FetchLimit,
    });
    f.push(...fetched);
    if (fetched.length === 0) {
      setHasMore(false);
    }
    setFeed(f);
  };

  useEffect(() => {
    if (props.connected) {
      setHasMore(true);
    }
  }, [props.connected]);

  const seen = {};

  const cards = feed
    .filter(([rating, cardId]) => {
      if (cardId in seen) {
        return false;
      }
      seen[cardId] = true;
      return true;
    })
    .map(([rating, cardId]) => {
      const key = `${gkey}-${cardId}`;
      return (
        <CardPreview {...props} key={key} cardId={cardId} rating={rating} />
      );
    });

  const loader = (
    <div className="d-flex justify-content-center" key={`${gkey}-loader`}>
      <div className="spinner-grow" role="status">
        <span className="visually-hidden">Loading...</span>
      </div>
    </div>
  );

  return (
    <div>
      <Heading size="3xl" fontWeight="normal">
        Recent
      </Heading>
      <InfiniteScroll
        pageStart={0}
        loadMore={fetchMore}
        hasMore={hasMore}
        loader={loader}
      >
        <SimpleGrid columns={4} spacing={10}>
          {cards}
        </SimpleGrid>
      </InfiniteScroll>
    </div>
  );
}

export default RecentPage;

'''
'''--- frontend/src/pages/Stats.js ---
import { ListItem, List, VStack, Box, Heading } from "@chakra-ui/layout";
import React, { useCallback, useEffect, useState } from "react";
import { fromNear } from "../components/BuyButton";

function StatsPage(props) {
  const [stats, setStats] = useState(null);
  const [loading, setLoading] = useState(true);

  const fetchStats = useCallback(async () => {
    const [t, numAccounts] = await Promise.all([
      props._near.contract.get_trade_data(),
      props._near.contract.get_num_accounts(),
    ]);
    return {
      numAccounts,
      numPurchases: t.num_purchases,
      numUniqueCardsBought: t.num_unique_cards_bought,
      nearVolume: fromNear(t.near_volume),
      appCommission: fromNear(t.app_owner_profit),
      artDaoProfit: fromNear(t.art_dao_profit),
      appOwnerId: t.app_owner_id,
      artDaoId: t.art_dao_id,
      totalVotes: t.total_votes,
    };
  }, [props._near]);

  useEffect(() => {
    if (props.connected) {
      fetchStats().then((stats) => {
        setStats(stats);
        setLoading(false);
      });
    }
  }, [props.connected, fetchStats]);

  return (
    <div className="container">
      <div className="row">
        {loading ? (
          <div className="col">
            <div className="d-flex justify-content-center">
              <div className="spinner-grow" role="status">
                <span className="visually-hidden">Loading...</span>
              </div>
            </div>
          </div>
        ) : (
          <Box rounded="xl" background="white" p="4" w="auto">
            <VStack color="brand.900" align="start">
              <Heading fontWeight="300" size="lg" color="brand.100">
                Stats{" "}
              </Heading>
              <List spacing={3}>
                <ListItem>Num accounts: {stats.numAccounts}</ListItem>
                <ListItem>Total votes: {stats.totalVotes}</ListItem>
                <ListItem>Total purchases: {stats.numPurchases}</ListItem>
                <ListItem>
                  Total unique purchases: {stats.numUniqueCardsBought}
                </ListItem>
                <ListItem>
                  Total volume: {stats.nearVolume.toFixed(2)} NEAR
                </ListItem>
                <ListItem>
                  Total Art DAO profit: {stats.artDaoProfit.toFixed(2)} NEAR
                </ListItem>
                <ListItem>
                  Art DAO account ID:{" "}
                  <a
                    href={`https://explorer.near.org/accounts/${stats.artDaoId}`}
                  >
                    @{stats.artDaoId}
                  </a>
                </ListItem>
                <ListItem>
                  Total App commission: {stats.appCommission.toFixed(2)} NEAR
                </ListItem>
              </List>
            </VStack>
          </Box>
        )}
      </div>
    </div>
  );
}

export default StatsPage;

'''
'''--- frontend/src/styles.js ---
import { extendTheme } from "@chakra-ui/react";
import { mode } from "@chakra-ui/theme-tools";
import "@openfonts/cherry-bomb_all";

const PRIMARY = "#FF4263";
const SECONDARY = "#822B38";
const TERTIARY = "#3D0E19";
const LIGHTROSE = "#ffc9c9";
const WHITE = "#FFFFFF";

const fonts = {
  heading: "Cherry Bomb",
  body: "Cherry Bomb",
};

const colors = {
  brand: {
    100: PRIMARY,
    500: SECONDARY,
    900: TERTIARY,
  },
};

const styles = {
  global: (props) => ({
    body: {
      fontFamily: "body",
      color: WHITE,
      bg: LIGHTROSE,
      lineHeight: "base",
    },
    a: {
      _hover: {
        color: SECONDARY,
      },
    },
  }),
};

const primaryLight = "#5C74FF";
const components = {
  Button: {
    baseStyle: {
      _focus: {
        boxShadow: "none",
      },
    },
  },
  CloseButton: {
    baseStyle: {
      _focus: {
        boxShadow: "none",
      },
    },
  },
  Tabs: {
    baseStyle: {
      tab: {
        _focus: {
          zIndex: 1,
          boxShadow: "none",
        },
      },
    },
    variants: {
      line: (props) => ({
        tab: {
          _selected: {
            color: props.colorMode === "dark" ? primaryLight : "red.500",
          },
        },
      }),
    },
  },
  Input: {
    variants: {
      outline: (props) => ({
        field: {
          _focus: {
            zIndex: 1,
            borderColor: props.colorMode === "dark" ? primaryLight : "red.500",
            boxShadow: `0 0 0 1px ${
              props.colorMode === "dark" ? primaryLight : "red.500"
            }`,
          },
        },
      }),
    },
  },
  Slider: {
    baseStyle: {
      thumb: {
        _focus: { boxShadow: "none" },
      },
    },
  },
};

export const theme = extendTheme({ fonts, colors, styles, components });

'''