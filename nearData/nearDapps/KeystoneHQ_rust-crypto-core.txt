*GitHub Repository "KeystoneHQ/rust-crypto-core"*

'''--- README.md ---
# Rust Crypto Core

Rust Crypto Core is the Rust implementation of multiple blockchain application used on Keystone Wallet. It includes like transaction decoding, Signer implemenation etc.

## Struture
- [blockchains](https://github.com/KeystoneHQ/rust-crypto-core/tree/master/blockchains): different blockchain transaction decoding implementations
- [signer](https://github.com/KeystoneHQ/rust-crypto-core/tree/master/signer): signer sample implementation.
- [traits](https://github.com/KeystoneHQ/rust-crypto-core/tree/master/traits/chain): the public traits defined in this module.

## Build

Go to each subdirectory and run `Cargo build`

## Test

Go to each subdirectory and run `Cargo Test`

## License

This project is under MIT License.
'''
'''--- blockchains/aptos/Cargo.toml ---
[package]
name = "rcc-aptos"
version = "0.1.0"
edition = "2021"
license = "Apache-2.0"
description = "A transaction parser for aptos."
# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
rcc-trait-chain = "0.1.0"
bcs = "0.1.3"
serde_json = "1.0"
serde = "1.0.139"
serde_bytes = "0.11.5"
thiserror = "1.0.31"
hex = "0.4.3"
rand = "0.8.3"
anyhow = "1.0.52"
ref-cast = "1.0.6"

[features]
address32 = []
address20 = []
default = ["address32"]

'''
'''--- blockchains/aptos/src/aptos_type/account_address.rs ---
// Copyright (c) The Diem Core Contributors
// Copyright (c) The Move Contributors
// SPDX-License-Identifier: Apache-2.0

use hex::FromHex;
use rand::{rngs::OsRng, Rng};
use serde::{de::Error as _, Deserialize, Deserializer, Serialize, Serializer};
use std::{convert::TryFrom, fmt, str::FromStr};

/// A struct that represents an account address.
#[derive(Ord, PartialOrd, Eq, PartialEq, Hash, Clone, Copy)]
pub struct AccountAddress([u8; AccountAddress::LENGTH]);

impl AccountAddress {
    pub const fn new(address: [u8; Self::LENGTH]) -> Self {
        Self(address)
    }

    /// The number of bytes in an address.
    /// Default to 16 bytes, can be set to 20 bytes with address20 feature.
    pub const LENGTH: usize = if cfg!(feature = "address20") {
        20
    } else if cfg!(feature = "address32") {
        32
    } else {
        16
    };

    /// Hex address: 0x0
    pub const ZERO: Self = Self([0u8; Self::LENGTH]);

    /// Hex address: 0x1
    pub const ONE: Self = Self::get_hex_address_one();

    const fn get_hex_address_one() -> Self {
        let mut addr = [0u8; AccountAddress::LENGTH];
        addr[AccountAddress::LENGTH - 1] = 1u8;
        Self(addr)
    }

    pub fn random() -> Self {
        let mut rng = OsRng;
        let buf: [u8; Self::LENGTH] = rng.gen();
        Self(buf)
    }

    pub fn short_str_lossless(&self) -> String {
        let hex_str = hex::encode(&self.0).trim_start_matches('0').to_string();
        if hex_str.is_empty() {
            "0".to_string()
        } else {
            hex_str
        }
    }

    pub fn to_vec(&self) -> Vec<u8> {
        self.0.to_vec()
    }

    pub fn into_bytes(self) -> [u8; Self::LENGTH] {
        self.0
    }

    pub fn from_hex_literal(literal: &str) -> Result<Self, AccountAddressParseError> {
        if !literal.starts_with("0x") {
            return Err(AccountAddressParseError);
        }

        let hex_len = literal.len() - 2;

        // If the string is too short, pad it
        if hex_len < Self::LENGTH * 2 {
            let mut hex_str = String::with_capacity(Self::LENGTH * 2);
            for _ in 0..Self::LENGTH * 2 - hex_len {
                hex_str.push('0');
            }
            hex_str.push_str(&literal[2..]);
            AccountAddress::from_hex(hex_str)
        } else {
            AccountAddress::from_hex(&literal[2..])
        }
    }

    pub fn to_hex_literal(&self) -> String {
        format!("0x{}", self.short_str_lossless())
    }

    pub fn from_hex<T: AsRef<[u8]>>(hex: T) -> Result<Self, AccountAddressParseError> {
        <[u8; Self::LENGTH]>::from_hex(hex)
            .map_err(|_| AccountAddressParseError)
            .map(Self)
    }

    pub fn to_hex(&self) -> String {
        format!("{:x}", self)
    }

    pub fn from_bytes<T: AsRef<[u8]>>(bytes: T) -> Result<Self, AccountAddressParseError> {
        <[u8; Self::LENGTH]>::try_from(bytes.as_ref())
            .map_err(|_| AccountAddressParseError)
            .map(Self)
    }
}

impl AsRef<[u8]> for AccountAddress {
    fn as_ref(&self) -> &[u8] {
        &self.0
    }
}

impl std::ops::Deref for AccountAddress {
    type Target = [u8; Self::LENGTH];

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl fmt::Display for AccountAddress {
    fn fmt(&self, f: &mut fmt::Formatter) -> std::fmt::Result {
        write!(f, "{:x}", self)
    }
}

impl fmt::Debug for AccountAddress {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{:x}", self)
    }
}

impl fmt::LowerHex for AccountAddress {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        if f.alternate() {
            write!(f, "0x")?;
        }

        for byte in &self.0 {
            write!(f, "{:02x}", byte)?;
        }

        Ok(())
    }
}

impl fmt::UpperHex for AccountAddress {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        if f.alternate() {
            write!(f, "0x")?;
        }

        for byte in &self.0 {
            write!(f, "{:02X}", byte)?;
        }

        Ok(())
    }
}

impl From<[u8; AccountAddress::LENGTH]> for AccountAddress {
    fn from(bytes: [u8; AccountAddress::LENGTH]) -> Self {
        Self::new(bytes)
    }
}

impl TryFrom<&[u8]> for AccountAddress {
    type Error = AccountAddressParseError;

    /// Tries to convert the provided byte array into Address.
    fn try_from(bytes: &[u8]) -> Result<AccountAddress, AccountAddressParseError> {
        Self::from_bytes(bytes)
    }
}

impl TryFrom<Vec<u8>> for AccountAddress {
    type Error = AccountAddressParseError;

    /// Tries to convert the provided byte buffer into Address.
    fn try_from(bytes: Vec<u8>) -> Result<AccountAddress, AccountAddressParseError> {
        Self::from_bytes(bytes)
    }
}

impl From<AccountAddress> for Vec<u8> {
    fn from(addr: AccountAddress) -> Vec<u8> {
        addr.0.to_vec()
    }
}

impl From<&AccountAddress> for Vec<u8> {
    fn from(addr: &AccountAddress) -> Vec<u8> {
        addr.0.to_vec()
    }
}

impl From<AccountAddress> for [u8; AccountAddress::LENGTH] {
    fn from(addr: AccountAddress) -> Self {
        addr.0
    }
}

impl From<&AccountAddress> for [u8; AccountAddress::LENGTH] {
    fn from(addr: &AccountAddress) -> Self {
        addr.0
    }
}

impl From<&AccountAddress> for String {
    fn from(addr: &AccountAddress) -> String {
        ::hex::encode(addr.as_ref())
    }
}

impl TryFrom<String> for AccountAddress {
    type Error = AccountAddressParseError;

    fn try_from(s: String) -> Result<AccountAddress, AccountAddressParseError> {
        Self::from_hex(s)
    }
}

impl FromStr for AccountAddress {
    type Err = AccountAddressParseError;

    fn from_str(s: &str) -> Result<Self, AccountAddressParseError> {
        // Accept 0xADDRESS or ADDRESS
        if let Ok(address) = AccountAddress::from_hex_literal(s) {
            Ok(address)
        } else {
            Self::from_hex(s)
        }
    }
}

impl<'de> Deserialize<'de> for AccountAddress {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: Deserializer<'de>,
    {
        if deserializer.is_human_readable() {
            let s = <String>::deserialize(deserializer)?;
            AccountAddress::from_str(&s).map_err(D::Error::custom)
        } else {
            // In order to preserve the Serde data model and help analysis tools,
            // make sure to wrap our value in a container with the same name
            // as the original type.
            #[derive(::serde::Deserialize)]
            #[serde(rename = "AccountAddress")]
            struct Value([u8; AccountAddress::LENGTH]);

            let value = Value::deserialize(deserializer)?;
            Ok(AccountAddress::new(value.0))
        }
    }
}

impl Serialize for AccountAddress {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: Serializer,
    {
        if serializer.is_human_readable() {
            self.to_hex().serialize(serializer)
        } else {
            // See comment in deserialize.
            serializer.serialize_newtype_struct("AccountAddress", &self.0)
        }
    }
}

#[derive(Clone, Copy, Debug)]
pub struct AccountAddressParseError;

impl fmt::Display for AccountAddressParseError {
    fn fmt(&self, f: &mut fmt::Formatter) -> std::fmt::Result {
        write!(
            f,
            "Unable to parse AccountAddress (must be hex string of length {})",
            AccountAddress::LENGTH
        )
    }
}

impl std::error::Error for AccountAddressParseError {}

'''
'''--- blockchains/aptos/src/aptos_type/chain_id.rs ---
// Copyright (c) Aptos
// SPDX-License-Identifier: Apache-2.0
use anyhow::{ensure, format_err, Error, Result};
use serde::{de::Visitor, Deserialize, Deserializer, Serialize};
use std::{convert::TryFrom, fmt, str::FromStr};

/// A registry of named chain IDs
/// Its main purpose is to improve human readability of reserved chain IDs in config files and CLI
/// When signing transactions for such chains, the numerical chain ID should still be used
/// (e.g. MAINNET has numeric chain ID 1, TESTNET has chain ID 2, etc)
#[repr(u8)]
#[derive(Copy, Clone, Debug)]
pub enum NamedChain {
    /// Users might accidentally initialize the ChainId field to 0, hence reserving ChainId 0 for accidental
    /// initialization.
    /// MAINNET is the Aptos mainnet production chain and is reserved for 1
    MAINNET = 1,
    // Even though these CHAIN IDs do not correspond to MAINNET, changing them should be avoided since they
    // can break test environments for various organisations.
    TESTNET = 2,
    DEVNET = 3,
    TESTING = 4,
    PREMAINNET = 5,
}

const MAINNET: &str = "mainnet";
const TESTNET: &str = "testnet";
const DEVNET: &str = "devnet";
const TESTING: &str = "testing";
const PREMAINNET: &str = "premainnet";

impl NamedChain {
    fn str_to_chain_id(s: &str) -> Result<ChainId> {
        // TODO implement custom macro that derives FromStr impl for enum (similar to aptos-core/common/num-variants)
        let reserved_chain = match s.to_lowercase().as_str() {
            MAINNET => NamedChain::MAINNET,
            TESTNET => NamedChain::TESTNET,
            DEVNET => NamedChain::DEVNET,
            TESTING => NamedChain::TESTING,
            PREMAINNET => NamedChain::PREMAINNET,
            _ => {
                return Err(format_err!("Not a reserved chain: {:?}", s));
            }
        };
        Ok(ChainId::new(reserved_chain.id()))
    }

    pub fn id(&self) -> u8 {
        *self as u8
    }

    pub fn from_chain_id(chain_id: &ChainId) -> Result<NamedChain, String> {
        match chain_id.id() {
            1 => Ok(NamedChain::MAINNET),
            2 => Ok(NamedChain::TESTNET),
            3 => Ok(NamedChain::DEVNET),
            4 => Ok(NamedChain::TESTING),
            5 => Ok(NamedChain::PREMAINNET),
            _ => Err(String::from("Not a named chain")),
        }
    }
}

/// Note: u7 in a u8 is uleb-compatible, and any usage of this should be aware
/// that this field maybe updated to be uleb64 in the future
#[derive(Clone, Copy, Deserialize, Eq, Hash, PartialEq, Serialize)]
pub struct ChainId(u8);

pub fn deserialize_config_chain_id<'de, D>(
    deserializer: D,
) -> std::result::Result<ChainId, D::Error>
    where
        D: Deserializer<'de>,
{
    struct ChainIdVisitor;

    impl<'de> Visitor<'de> for ChainIdVisitor {
        type Value = ChainId;

        fn expecting(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.write_str("ChainId as string or u8")
        }

        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
        {
            ChainId::from_str(value).map_err(serde::de::Error::custom)
        }

        fn visit_u64<E>(self, value: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
        {
            Ok(ChainId::new(
                u8::try_from(value).map_err(serde::de::Error::custom)?,
            ))
        }
    }

    deserializer.deserialize_any(ChainIdVisitor)
}

impl fmt::Debug for ChainId {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self)
    }
}

impl fmt::Display for ChainId {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "{}",
            NamedChain::from_chain_id(self)
                .map_or_else(|_| self.0.to_string(), |chain| chain.to_string())
        )
    }
}

impl fmt::Display for NamedChain {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "{}",
            match self {
                NamedChain::DEVNET => DEVNET,
                NamedChain::TESTNET => TESTNET,
                NamedChain::MAINNET => MAINNET,
                NamedChain::TESTING => TESTING,
                NamedChain::PREMAINNET => PREMAINNET,
            }
        )
    }
}

impl Default for ChainId {
    fn default() -> Self {
        Self::test()
    }
}

impl FromStr for ChainId {
    type Err = Error;

    fn from_str(s: &str) -> Result<Self> {
        ensure!(!s.is_empty(), "Cannot create chain ID from empty string");
        NamedChain::str_to_chain_id(s).or_else(|_err| {
            let value = s.parse::<u8>()?;
            ensure!(value > 0, "cannot have chain ID with 0");
            Ok(ChainId::new(value))
        })
    }
}

impl ChainId {
    pub fn new(id: u8) -> Self {
        assert!(id > 0, "cannot have chain ID with 0");
        Self(id)
    }

    pub fn id(&self) -> u8 {
        self.0
    }

    pub fn test() -> Self {
        ChainId::new(NamedChain::TESTING.id())
    }

    pub fn mainnet() -> Self {
        ChainId::new(NamedChain::MAINNET.id())
    }
}
'''
'''--- blockchains/aptos/src/aptos_type/identifier.rs ---
// Copyright (c) The Diem Core Contributors
// Copyright (c) The Move Contributors
// SPDX-License-Identifier: Apache-2.0

//! An identifier is the name of an entity (module, resource, function, etc) in Move.
//!
//! A valid identifier consists of an ASCII string which satisfies any of the conditions:
//!
//! * The first character is a letter and the remaining characters are letters, digits or
//!   underscores.
//! * The first character is an underscore, and there is at least one further letter, digit or
//!   underscore.
//!
//! The spec for allowed identifiers is similar to Rust's spec
//! ([as of version 1.38](https://doc.rust-lang.org/1.38.0/reference/identifiers.html)).
//!
//! Allowed identifiers are currently restricted to ASCII due to unresolved issues with Unicode
//! normalization. See [Rust issue #55467](https://github.com/rust-lang/rust/issues/55467) and the
//! associated RFC for some discussion. Unicode identifiers may eventually be supported once these
//! issues are worked out.
//!
//! This module only determines allowed identifiers at the bytecode level. Move source code will
//! likely be more restrictive than even this, with a "raw identifier" escape hatch similar to
//! Rust's `r#` identifiers.
//!
//! Among other things, identifiers are used to:
//! * specify keys for lookups in storage
//! * do cross-module lookups while executing transactions

use anyhow::{bail, Result};

use ref_cast::RefCast;
use serde::{Deserialize, Serialize};
use std::{borrow::Borrow, fmt, ops::Deref, str::FromStr};

/// Return true if this character can appear in a Move identifier.
///
/// Note: there are stricter restrictions on whether a character can begin a Move
/// identifier--only alphabetic characters are allowed here.
#[inline]
pub const fn is_valid_identifier_char(c: char) -> bool {
    matches!(c, '_' | 'a'..='z' | 'A'..='Z' | '0'..='9')
}

/// Returns `true` if all bytes in `b` after the offset `start_offset` are valid
/// ASCII identifier characters.
const fn all_bytes_valid(b: &[u8], start_offset: usize) -> bool {
    let mut i = start_offset;
    // TODO(philiphayes): use for loop instead of while loop when it's stable in const fn's.
    while i < b.len() {
        if !is_valid_identifier_char(b[i] as char) {
            return false;
        }
        i += 1;
    }
    true
}

/// Describes what identifiers are allowed.
///
/// For now this is deliberately restrictive -- we would like to evolve this in the future.
// TODO: "<SELF>" is coded as an exception. It should be removed once CompiledScript goes away.
// Note: needs to be pub as it's used in the `ident_str!` macro.
pub const fn is_valid(s: &str) -> bool {
    // Rust const fn's don't currently support slicing or indexing &str's, so we
    // have to operate on the underlying byte slice. This is not a problem as
    // valid identifiers are (currently) ASCII-only.
    let b = s.as_bytes();
    match b {
        b"<SELF>" => true,
        [b'a'..=b'z', ..] | [b'A'..=b'Z', ..] => all_bytes_valid(b, 1),
        [b'_', ..] if b.len() > 1 => all_bytes_valid(b, 1),
        _ => false,
    }
}

/// A regex describing what identifiers are allowed. Used for proptests.
// TODO: "<SELF>" is coded as an exception. It should be removed once CompiledScript goes away.
#[cfg(any(test, feature = "fuzzing"))]
#[allow(dead_code)]
pub(crate) static ALLOWED_IDENTIFIERS: &str =
    r"(?:[a-zA-Z][a-zA-Z0-9_]*)|(?:_[a-zA-Z0-9_]+)|(?:<SELF>)";
#[cfg(any(test, feature = "fuzzing"))]
pub(crate) static ALLOWED_NO_SELF_IDENTIFIERS: &str =
    r"(?:[a-zA-Z][a-zA-Z0-9_]*)|(?:_[a-zA-Z0-9_]+)";

/// An owned identifier.
///
/// For more details, see the module level documentation.
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, Deserialize)]
#[cfg_attr(feature = "fuzzing", derive(arbitrary::Arbitrary))]
pub struct Identifier(Box<str>);
// An identifier cannot be mutated so use Box<str> instead of String -- it is 1 word smaller.

impl Identifier {
    /// Creates a new `Identifier` instance.
    pub fn new(s: impl Into<Box<str>>) -> Result<Self> {
        let s = s.into();
        if Self::is_valid(&s) {
            Ok(Self(s))
        } else {
            bail!("Invalid identifier '{}'", s);
        }
    }

    /// Returns true if this string is a valid identifier.
    pub fn is_valid(s: impl AsRef<str>) -> bool {
        is_valid(s.as_ref())
    }

    /// Returns if this identifier is "<SELF>".
    /// TODO: remove once we fully separate CompiledScript & CompiledModule.
    pub fn is_self(&self) -> bool {
        &*self.0 == "<SELF>"
    }

    /// Converts a vector of bytes to an `Identifier`.
    pub fn from_utf8(vec: Vec<u8>) -> Result<Self> {
        let s = String::from_utf8(vec)?;
        Self::new(s)
    }

    /// Creates a borrowed version of `self`.
    pub fn as_ident_str(&self) -> &IdentStr {
        self
    }

    /// Converts this `Identifier` into a `String`.
    ///
    /// This is not implemented as a `From` trait to discourage automatic conversions -- these
    /// conversions should not typically happen.
    pub fn into_string(self) -> String {
        self.0.into()
    }

    /// Converts this `Identifier` into a UTF-8-encoded byte sequence.
    pub fn into_bytes(self) -> Vec<u8> {
        self.into_string().into_bytes()
    }
}

impl FromStr for Identifier {
    type Err = anyhow::Error;

    fn from_str(data: &str) -> Result<Self> {
        Self::new(data)
    }
}

impl From<&IdentStr> for Identifier {
    fn from(ident_str: &IdentStr) -> Self {
        ident_str.to_owned()
    }
}

impl AsRef<IdentStr> for Identifier {
    fn as_ref(&self) -> &IdentStr {
        self
    }
}

impl Deref for Identifier {
    type Target = IdentStr;

    fn deref(&self) -> &IdentStr {
        // Identifier and IdentStr maintain the same invariants, so it is safe to
        // convert.
        IdentStr::ref_cast(&self.0)
    }
}

impl fmt::Display for Identifier {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", &self.0)
    }
}

/// A borrowed identifier.
///
/// For more details, see the module level documentation.
#[derive(Debug, Eq, Hash, Ord, PartialEq, PartialOrd, RefCast)]
#[repr(transparent)]
pub struct IdentStr(str);

impl IdentStr {
    pub fn new(s: &str) -> Result<&IdentStr> {
        if Self::is_valid(s) {
            Ok(IdentStr::ref_cast(s))
        } else {
            bail!("Invalid identifier '{}'", s);
        }
    }

    /// Returns true if this string is a valid identifier.
    pub fn is_valid(s: impl AsRef<str>) -> bool {
        is_valid(s.as_ref())
    }

    /// Returns the length of `self` in bytes.
    pub fn len(&self) -> usize {
        self.0.len()
    }

    /// Returns `true` if `self` has a length of zero bytes.
    pub fn is_empty(&self) -> bool {
        self.0.is_empty()
    }

    /// Converts `self` to a `&str`.
    ///
    /// This is not implemented as a `From` trait to discourage automatic conversions -- these
    /// conversions should not typically happen.
    pub fn as_str(&self) -> &str {
        &self.0
    }

    /// Converts `self` to a byte slice.
    pub fn as_bytes(&self) -> &[u8] {
        self.0.as_bytes()
    }
}

impl Borrow<IdentStr> for Identifier {
    fn borrow(&self) -> &IdentStr {
        self
    }
}

impl ToOwned for IdentStr {
    type Owned = Identifier;

    fn to_owned(&self) -> Identifier {
        Identifier(self.0.into())
    }
}

impl fmt::Display for IdentStr {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", &self.0)
    }
}

// const assert that IdentStr impls RefCast<From = str>
// This assertion is what guarantees the unsafe transmute is safe.
const _: fn() = || {
    fn assert_impl_all<T: ?Sized + ::ref_cast::RefCast<From = str>>() {}
    assert_impl_all::<IdentStr>();
};

/// `ident_str!` is a compile-time validated macro that constructs a
/// `&'static IdentStr` from a const `&'static str`.
///
/// ### Example
///
/// Creating a valid static or const [`IdentStr`]:
///
/// ```rust
/// use move_core_types::{ident_str, identifier::IdentStr};
/// const VALID_IDENT: &'static IdentStr = ident_str!("MyCoolIdentifier");
///
/// const THING_NAME: &'static str = "thing_name";
/// const THING_IDENT: &'static IdentStr = ident_str!(THING_NAME);
/// ```
///
/// In contrast, creating an invalid [`IdentStr`] will fail at compile time:
///
/// ```rust,compile_fail
/// use move_core_types::{ident_str, identifier::IdentStr};
/// const INVALID_IDENT: &'static IdentStr = ident_str!("123Foo"); // Fails to compile!
/// ```
// TODO(philiphayes): this should really be an associated const fn like `IdentStr::new`;
// unfortunately, both unsafe-reborrow and unsafe-transmute don't currently work
// inside const fn's. Only unsafe-transmute works inside static const-blocks
// (but not const-fn's).
#[macro_export]
macro_rules! ident_str {
    ($ident:expr) => {{
        // Only static strings allowed.
        let s: &'static str = $ident;

        // Only valid identifier strings are allowed.
        // Note: Work-around hack to print an error message in a const block.
        let is_valid = $crate::identifier::is_valid(s);
        ["String is not a valid Move identifier"][!is_valid as usize];

        // SAFETY: the following transmute is safe because
        // (1) it's equivalent to the unsafe-reborrow inside IdentStr::ref_cast()
        //     (which we can't use b/c it's not const).
        // (2) we've just asserted that IdentStr impls RefCast<From = str>, which
        //     already guarantees the transmute is safe (RefCast checks that
        //     IdentStr(str) is #[repr(transparent)]).
        // (3) both in and out lifetimes are 'static, so we're not widening the lifetime.
        // (4) we've just asserted that the IdentStr passes the is_valid check.
        //
        // Note: this lint is unjustified and no longer checked. See issue:
        // https://github.com/rust-lang/rust-clippy/issues/6372
        #[allow(clippy::transmute_ptr_to_ptr)]
        unsafe {
            ::std::mem::transmute::<&'static str, &'static $crate::identifier::IdentStr>(s)
        }
    }};
}

'''
'''--- blockchains/aptos/src/aptos_type/language_storage.rs ---
// Copyright (c) The Diem Core Contributors
// Copyright (c) The Move Contributors
// SPDX-License-Identifier: Apache-2.0

use crate::aptos_type::{
    safe_serialize
};

use serde::{Deserialize, Serialize};
use std::{
    fmt::{Display, Formatter},
    str::FromStr,
};
use crate::aptos_type::account_address::AccountAddress;
use crate::aptos_type::identifier::{Identifier, IdentStr};
use crate::aptos_type::parser::{parse_struct_tag, parse_type_tag};

pub const CODE_TAG: u8 = 0;
pub const RESOURCE_TAG: u8 = 1;

/// Hex address: 0x1
pub const CORE_CODE_ADDRESS: AccountAddress = AccountAddress::ONE;

#[derive(Serialize, Deserialize, Debug, PartialEq, Hash, Eq, Clone, PartialOrd, Ord)]
pub enum TypeTag {
    // alias for compatibility with old json serialized data.
    #[serde(rename = "bool", alias = "Bool")]
    Bool,
    #[serde(rename = "u8", alias = "U8")]
    U8,
    #[serde(rename = "u64", alias = "U64")]
    U64,
    #[serde(rename = "u128", alias = "U128")]
    U128,
    #[serde(rename = "address", alias = "Address")]
    Address,
    #[serde(rename = "signer", alias = "Signer")]
    Signer,
    #[serde(rename = "vector", alias = "Vector")]
    Vector(
        #[serde(
            serialize_with = "safe_serialize::type_tag_recursive_serialize",
            deserialize_with = "safe_serialize::type_tag_recursive_deserialize"
        )]
        Box<TypeTag>,
    ),
    #[serde(rename = "struct", alias = "Struct")]
    Struct(
        #[serde(
            serialize_with = "safe_serialize::type_tag_recursive_serialize",
            deserialize_with = "safe_serialize::type_tag_recursive_deserialize"
        )]
        Box<StructTag>,
    ),
}

impl FromStr for TypeTag {
    type Err = anyhow::Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        parse_type_tag(s)
    }
}

#[derive(Serialize, Deserialize, Debug, PartialEq, Hash, Eq, Clone, PartialOrd, Ord)]
pub struct StructTag {
    pub address: AccountAddress,
    pub module: Identifier,
    pub name: Identifier,
    // alias for compatibility with old json serialized data.
    #[serde(rename = "type_args", alias = "type_params")]
    pub type_params: Vec<TypeTag>,
}

impl StructTag {
    pub fn access_vector(&self) -> Vec<u8> {
        let mut key = vec![RESOURCE_TAG];
        key.append(&mut bcs::to_bytes(self).unwrap());
        key
    }

    pub fn module_id(&self) -> ModuleId {
        ModuleId::new(self.address, self.module.to_owned())
    }
}

impl FromStr for StructTag {
    type Err = anyhow::Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        parse_struct_tag(s)
    }
}

/// Represents the initial key into global storage where we first index by the address, and then
/// the struct tag
#[derive(Serialize, Deserialize, Debug, PartialEq, Hash, Eq, Clone, PartialOrd, Ord)]
pub struct ResourceKey {
    pub address: AccountAddress,
    pub type_: StructTag,
}

impl ResourceKey {
    pub fn address(&self) -> AccountAddress {
        self.address
    }

    pub fn type_(&self) -> &StructTag {
        &self.type_
    }
}

impl ResourceKey {
    pub fn new(address: AccountAddress, type_: StructTag) -> Self {
        ResourceKey { address, type_ }
    }
}

/// Represents the initial key into global storage where we first index by the address, and then
/// the struct tag
#[derive(Serialize, Deserialize, Debug, PartialEq, Hash, Eq, Clone, PartialOrd, Ord)]
pub struct ModuleId {
    address: AccountAddress,
    name: Identifier,
}

impl From<ModuleId> for (AccountAddress, Identifier) {
    fn from(module_id: ModuleId) -> Self {
        (module_id.address, module_id.name)
    }
}

impl ModuleId {
    pub fn new(address: AccountAddress, name: Identifier) -> Self {
        ModuleId { address, name }
    }

    pub fn name(&self) -> &IdentStr {
        &self.name
    }

    pub fn address(&self) -> &AccountAddress {
        &self.address
    }

    pub fn access_vector(&self) -> Vec<u8> {
        let mut key = vec![CODE_TAG];
        key.append(&mut bcs::to_bytes(self).unwrap());
        key
    }
}

impl Display for ModuleId {
    fn fmt(&self, f: &mut Formatter) -> std::fmt::Result {
        write!(f, "{}::{}", self.address, self.name)
    }
}

impl ModuleId {
    pub fn short_str_lossless(&self) -> String {
        format!("0x{}::{}", self.address.short_str_lossless(), self.name)
    }
}

impl Display for StructTag {
    fn fmt(&self, f: &mut Formatter) -> std::fmt::Result {
        write!(
            f,
            "0x{}::{}::{}",
            self.address.short_str_lossless(),
            self.module,
            self.name
        )?;
        if let Some(first_ty) = self.type_params.first() {
            write!(f, "<")?;
            write!(f, "{}", first_ty)?;
            for ty in self.type_params.iter().skip(1) {
                write!(f, ", {}", ty)?;
            }
            write!(f, ">")?;
        }
        Ok(())
    }
}

impl Display for TypeTag {
    fn fmt(&self, f: &mut Formatter) -> std::fmt::Result {
        match self {
            TypeTag::Struct(s) => write!(f, "{}", s),
            TypeTag::Vector(ty) => write!(f, "vector<{}>", ty),
            TypeTag::U8 => write!(f, "u8"),
            TypeTag::U64 => write!(f, "u64"),
            TypeTag::U128 => write!(f, "u128"),
            TypeTag::Address => write!(f, "address"),
            TypeTag::Signer => write!(f, "signer"),
            TypeTag::Bool => write!(f, "bool"),
        }
    }
}

impl Display for ResourceKey {
    fn fmt(&self, f: &mut Formatter) -> std::fmt::Result {
        write!(f, "0x{}/{}", self.address.short_str_lossless(), self.type_)
    }
}

impl From<StructTag> for TypeTag {
    fn from(t: StructTag) -> TypeTag {
        TypeTag::Struct(Box::new(t))
    }
}

'''
'''--- blockchains/aptos/src/aptos_type/mod.rs ---
mod safe_serialize;
mod account_address;
mod chain_id;
mod script;
mod serde_helper;
mod identifier;
mod language_storage;
mod transaction_argument;
mod value;
mod parser;
mod module;

use serde::{Deserialize, Serialize};
use account_address::AccountAddress;
use chain_id::ChainId;
use script::Script;
use module::{Module, ModuleBundle};
use script::EntryFunction;

#[derive(
Debug, Hash, Eq, PartialEq, Serialize, Deserialize,
)]
pub struct RawTransaction {
    /// Sender's address.
    sender: AccountAddress,

    /// Sequence number of this transaction. This must match the sequence number
    /// stored in the sender's account at the time the transaction executes.
    sequence_number: u64,

    /// The transaction payload, e.g., a script to execute.
    payload: TransactionPayload,

    /// Maximal total gas to spend for this transaction.
    max_gas_amount: u64,

    /// Price to be paid per gas unit.
    gas_unit_price: u64,

    /// Expiration timestamp for this transaction, represented
    /// as seconds from the Unix Epoch. If the current blockchain timestamp
    /// is greater than or equal to this time, then the transaction has
    /// expired and will be discarded. This can be set to a large value far
    /// in the future to indicate that a transaction does not expire.
    expiration_timestamp_secs: u64,

    /// Chain ID of the Aptos network this transaction is intended for.
    chain_id: ChainId,
}

/// Different kinds of transactions.
#[derive(Clone, Debug, Hash, Eq, PartialEq, Serialize, Deserialize)]
pub enum TransactionPayload {
    /// A transaction that executes code.
    Script(Script),
    /// A transaction that publishes multiple modules at the same time.
    ModuleBundle(ModuleBundle),
    /// A transaction that executes an existing entry function published on-chain.
    EntryFunction(EntryFunction),
}

'''
'''--- blockchains/aptos/src/aptos_type/module.rs ---
// Copyright (c) Aptos
// SPDX-License-Identifier: Apache-2.0

use serde::{Deserialize, Serialize};
use std::fmt;

#[derive(Clone, Hash, Eq, PartialEq, Serialize, Deserialize)]
pub struct Module {
    #[serde(with = "serde_bytes")]
    code: Vec<u8>,
}

impl Module {
    pub fn new(code: Vec<u8>) -> Module {
        Module { code }
    }

    pub fn code(&self) -> &[u8] {
        &self.code
    }

    pub fn into_inner(self) -> Vec<u8> {
        self.code
    }
}

impl fmt::Debug for Module {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("Module")
            .field("code", &hex::encode(&self.code))
            .finish()
    }
}

#[derive(Clone, Hash, Eq, PartialEq, Serialize, Deserialize)]
pub struct ModuleBundle {
    codes: Vec<Module>,
}

impl ModuleBundle {
    pub fn new(codes: Vec<Vec<u8>>) -> ModuleBundle {
        ModuleBundle {
            codes: codes.into_iter().map(Module::new).collect(),
        }
    }

    pub fn singleton(code: Vec<u8>) -> ModuleBundle {
        ModuleBundle {
            codes: vec![Module::new(code)],
        }
    }

    pub fn into_inner(self) -> Vec<Vec<u8>> {
        self.codes.into_iter().map(Module::into_inner).collect()
    }

    pub fn iter(&self) -> impl Iterator<Item = &Module> {
        self.codes.iter()
    }
}

impl fmt::Debug for ModuleBundle {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("ModuleBundle")
            .field("codes", &self.codes)
            .finish()
    }
}

impl From<Module> for ModuleBundle {
    fn from(m: Module) -> ModuleBundle {
        ModuleBundle { codes: vec![m] }
    }
}

impl IntoIterator for ModuleBundle {
    type Item = Module;
    type IntoIter = std::vec::IntoIter<Self::Item>;

    fn into_iter(self) -> Self::IntoIter {
        self.codes.into_iter()
    }
}

'''
'''--- blockchains/aptos/src/aptos_type/parser.rs ---
// Copyright (c) The Diem Core Contributors
// Copyright (c) The Move Contributors
// SPDX-License-Identifier: Apache-2.0

// use crate::{
//     account_address::AccountAddress,
//     identifier::{self, Identifier},
//     language_storage::{StructTag, TypeTag},
//     transaction_argument::TransactionArgument,
// };
use anyhow::{bail, format_err, Result};
use std::iter::Peekable;
use crate::aptos_type::account_address::AccountAddress;
use crate::aptos_type::identifier;
use crate::aptos_type::identifier::Identifier;
use crate::aptos_type::language_storage::{StructTag, TypeTag};
use crate::aptos_type::transaction_argument::TransactionArgument;
use crate::aptos_type::safe_serialize;

#[derive(Eq, PartialEq, Debug)]
enum Token {
    U8Type,
    U64Type,
    U128Type,
    BoolType,
    AddressType,
    VectorType,
    SignerType,
    Whitespace(String),
    Name(String),
    Address(String),
    U8(String),
    U64(String),
    U128(String),
    Bytes(String),
    True,
    False,
    ColonColon,
    Lt,
    Gt,
    Comma,
    EOF,
}

impl Token {
    fn is_whitespace(&self) -> bool {
        matches!(self, Self::Whitespace(_))
    }
}

fn name_token(s: String) -> Token {
    match s.as_str() {
        "u8" => Token::U8Type,
        "u64" => Token::U64Type,
        "u128" => Token::U128Type,
        "bool" => Token::BoolType,
        "address" => Token::AddressType,
        "vector" => Token::VectorType,
        "true" => Token::True,
        "false" => Token::False,
        "signer" => Token::SignerType,
        _ => Token::Name(s),
    }
}

fn next_number(initial: char, mut it: impl Iterator<Item = char>) -> Result<(Token, usize)> {
    let mut num = String::new();
    num.push(initial);
    loop {
        match it.next() {
            Some(c) if c.is_ascii_digit() => num.push(c),
            Some(c) if c.is_alphanumeric() => {
                let mut suffix = String::new();
                suffix.push(c);
                loop {
                    match it.next() {
                        Some(c) if c.is_ascii_alphanumeric() => suffix.push(c),
                        _ => {
                            let len = num.len() + suffix.len();
                            let tok = match suffix.as_str() {
                                "u8" => Token::U8(num),
                                "u64" => Token::U64(num),
                                "u128" => Token::U128(num),
                                _ => bail!("invalid suffix"),
                            };
                            return Ok((tok, len));
                        }
                    }
                }
            }
            _ => {
                let len = num.len();
                return Ok((Token::U64(num), len));
            }
        }
    }
}

#[allow(clippy::many_single_char_names)]
fn next_token(s: &str) -> Result<Option<(Token, usize)>> {
    let mut it = s.chars().peekable();
    match it.next() {
        None => Ok(None),
        Some(c) => Ok(Some(match c {
            '<' => (Token::Lt, 1),
            '>' => (Token::Gt, 1),
            ',' => (Token::Comma, 1),
            ':' => match it.next() {
                Some(':') => (Token::ColonColon, 2),
                _ => bail!("unrecognized token"),
            },
            '0' if it.peek() == Some(&'x') || it.peek() == Some(&'X') => {
                it.next().unwrap();
                match it.next() {
                    Some(c) if c.is_ascii_hexdigit() => {
                        let mut r = String::new();
                        r.push('0');
                        r.push('x');
                        r.push(c);
                        for c in it {
                            if c.is_ascii_hexdigit() {
                                r.push(c);
                            } else {
                                break;
                            }
                        }
                        let len = r.len();
                        (Token::Address(r), len)
                    }
                    _ => bail!("unrecognized token"),
                }
            }
            c if c.is_ascii_digit() => next_number(c, it)?,
            'b' if it.peek() == Some(&'"') => {
                it.next().unwrap();
                let mut r = String::new();
                loop {
                    match it.next() {
                        Some('"') => break,
                        Some(c) if c.is_ascii() => r.push(c),
                        _ => bail!("unrecognized token"),
                    }
                }
                let len = r.len() + 3;
                (Token::Bytes(hex::encode(r)), len)
            }
            'x' if it.peek() == Some(&'"') => {
                it.next().unwrap();
                let mut r = String::new();
                loop {
                    match it.next() {
                        Some('"') => break,
                        Some(c) if c.is_ascii_hexdigit() => r.push(c),
                        _ => bail!("unrecognized token"),
                    }
                }
                let len = r.len() + 3;
                (Token::Bytes(r), len)
            }
            c if c.is_ascii_whitespace() => {
                let mut r = String::new();
                r.push(c);
                for c in it {
                    if c.is_ascii_whitespace() {
                        r.push(c);
                    } else {
                        break;
                    }
                }
                let len = r.len();
                (Token::Whitespace(r), len)
            }
            c if c.is_ascii_alphabetic() => {
                let mut r = String::new();
                r.push(c);
                for c in it {
                    if identifier::is_valid_identifier_char(c) {
                        r.push(c);
                    } else {
                        break;
                    }
                }
                let len = r.len();
                (name_token(r), len)
            }
            _ => bail!("unrecognized token"),
        })),
    }
}

fn tokenize(mut s: &str) -> Result<Vec<Token>> {
    let mut v = vec![];
    while let Some((tok, n)) = next_token(s)? {
        v.push(tok);
        s = &s[n..];
    }
    Ok(v)
}

struct Parser<I: Iterator<Item = Token>> {
    it: Peekable<I>,
}

impl<I: Iterator<Item = Token>> Parser<I> {
    fn new<T: IntoIterator<Item = Token, IntoIter = I>>(v: T) -> Self {
        Self {
            it: v.into_iter().peekable(),
        }
    }

    fn next(&mut self) -> Result<Token> {
        match self.it.next() {
            Some(tok) => Ok(tok),
            None => bail!("out of tokens, this should not happen"),
        }
    }

    fn peek(&mut self) -> Option<&Token> {
        self.it.peek()
    }

    fn consume(&mut self, tok: Token) -> Result<()> {
        let t = self.next()?;
        if t != tok {
            bail!("expected token {:?}, got {:?}", tok, t)
        }
        Ok(())
    }

    fn parse_comma_list<F, R>(
        &mut self,
        parse_list_item: F,
        end_token: Token,
        allow_trailing_comma: bool,
    ) -> Result<Vec<R>>
    where
        F: Fn(&mut Self) -> Result<R>,
        R: std::fmt::Debug,
    {
        let mut v = vec![];
        if !(self.peek() == Some(&end_token)) {
            loop {
                v.push(parse_list_item(self)?);
                if self.peek() == Some(&end_token) {
                    break;
                }
                self.consume(Token::Comma)?;
                if self.peek() == Some(&end_token) && allow_trailing_comma {
                    break;
                }
            }
        }
        Ok(v)
    }

    fn parse_string(&mut self) -> Result<String> {
        Ok(match self.next()? {
            Token::Name(s) => s,
            tok => bail!("unexpected token {:?}, expected string", tok),
        })
    }

    fn parse_type_tag(&mut self, depth: u8) -> Result<TypeTag> {
        if depth >= safe_serialize::MAX_TYPE_TAG_NESTING {
            bail!("Exceeded TypeTag nesting limit during parsing: {}", depth);
        }

        Ok(match self.next()? {
            Token::U8Type => TypeTag::U8,
            Token::U64Type => TypeTag::U64,
            Token::U128Type => TypeTag::U128,
            Token::BoolType => TypeTag::Bool,
            Token::AddressType => TypeTag::Address,
            Token::SignerType => TypeTag::Signer,
            Token::VectorType => {
                self.consume(Token::Lt)?;
                let ty = self.parse_type_tag(depth + 1)?;
                self.consume(Token::Gt)?;
                TypeTag::Vector(Box::new(ty))
            }
            Token::Address(addr) => {
                self.consume(Token::ColonColon)?;
                match self.next()? {
                    Token::Name(module) => {
                        self.consume(Token::ColonColon)?;
                        match self.next()? {
                            Token::Name(name) => {
                                let ty_args = if self.peek() == Some(&Token::Lt) {
                                    self.next()?;
                                    let ty_args = self.parse_comma_list(
                                        |parser| parser.parse_type_tag(depth + 1),
                                        Token::Gt,
                                        true,
                                    )?;
                                    self.consume(Token::Gt)?;
                                    ty_args
                                } else {
                                    vec![]
                                };
                                TypeTag::Struct(Box::new(StructTag {
                                    address: AccountAddress::from_hex_literal(&addr)?,
                                    module: Identifier::new(module)?,
                                    name: Identifier::new(name)?,
                                    type_params: ty_args,
                                }))
                            }
                            t => bail!("expected name, got {:?}", t),
                        }
                    }
                    t => bail!("expected name, got {:?}", t),
                }
            }
            tok => bail!("unexpected token {:?}, expected type tag", tok),
        })
    }

    fn parse_transaction_argument(&mut self) -> Result<TransactionArgument> {
        Ok(match self.next()? {
            Token::U8(s) => TransactionArgument::U8(s.parse()?),
            Token::U64(s) => TransactionArgument::U64(s.parse()?),
            Token::U128(s) => TransactionArgument::U128(s.parse()?),
            Token::True => TransactionArgument::Bool(true),
            Token::False => TransactionArgument::Bool(false),
            Token::Address(addr) => {
                TransactionArgument::Address(AccountAddress::from_hex_literal(&addr)?)
            }
            Token::Bytes(s) => TransactionArgument::U8Vector(hex::decode(s)?),
            tok => bail!("unexpected token {:?}, expected transaction argument", tok),
        })
    }
}

fn parse<F, T>(s: &str, f: F) -> Result<T>
where
    F: Fn(&mut Parser<std::vec::IntoIter<Token>>) -> Result<T>,
{
    let mut tokens: Vec<_> = tokenize(s)?
        .into_iter()
        .filter(|tok| !tok.is_whitespace())
        .collect();
    tokens.push(Token::EOF);
    let mut parser = Parser::new(tokens);
    let res = f(&mut parser)?;
    parser.consume(Token::EOF)?;
    Ok(res)
}

pub fn parse_string_list(s: &str) -> Result<Vec<String>> {
    parse(s, |parser| {
        parser.parse_comma_list(|parser| parser.parse_string(), Token::EOF, true)
    })
}

pub fn parse_type_tags(s: &str) -> Result<Vec<TypeTag>> {
    parse(s, |parser| {
        parser.parse_comma_list(|parser| parser.parse_type_tag(0), Token::EOF, true)
    })
}

pub fn parse_type_tag(s: &str) -> Result<TypeTag> {
    parse(s, |parser| parser.parse_type_tag(0))
}

pub fn parse_transaction_arguments(s: &str) -> Result<Vec<TransactionArgument>> {
    parse(s, |parser| {
        parser.parse_comma_list(
            |parser| parser.parse_transaction_argument(),
            Token::EOF,
            true,
        )
    })
}

pub fn parse_transaction_argument(s: &str) -> Result<TransactionArgument> {
    parse(s, |parser| parser.parse_transaction_argument())
}

pub fn parse_struct_tag(s: &str) -> Result<StructTag> {
    let type_tag = parse(s, |parser| parser.parse_type_tag(0))
        .map_err(|e| format_err!("invalid struct tag: {}, {}", s, e))?;
    if let TypeTag::Struct(struct_tag) = type_tag {
        Ok(*struct_tag)
    } else {
        bail!("invalid struct tag: {}", s)
    }
}

'''
'''--- blockchains/aptos/src/aptos_type/safe_serialize.rs ---
// Copyright (c) The Diem Core Contributors
// Copyright (c) The Move Contributors
// SPDX-License-Identifier: Apache-2.0

//! Custom serializers which track recursion nesting with a thread local,
//! and otherwise delegate to the derived serializers.
//!
//! This is currently only implemented for type tags, but can be easily
//! generalized, as the the only type-tag specific thing is the allowed nesting.

use serde::{Deserialize, Deserializer, Serialize, Serializer};
use std::cell::RefCell;

pub(crate) const MAX_TYPE_TAG_NESTING: u8 = 9;

thread_local! {
    static TYPE_TAG_DEPTH: RefCell<u8> = RefCell::new(0);
}

pub(crate) fn type_tag_recursive_serialize<S, T>(t: &T, s: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
        T: Serialize,
{
    use serde::ser::Error;

    TYPE_TAG_DEPTH.with(|depth| {
        let mut r = depth.borrow_mut();
        if *r >= MAX_TYPE_TAG_NESTING {
            // for testability, we allow one level more
            return Err(S::Error::custom(
                "type tag nesting exceeded during serialization",
            ));
        }
        *r += 1;
        Ok(())
    })?;
    let res = t.serialize(s);
    TYPE_TAG_DEPTH.with(|depth| {
        let mut r = depth.borrow_mut();
        *r -= 1;
    });
    res
}

pub(crate) fn type_tag_recursive_deserialize<'de, D, T>(d: D) -> Result<T, D::Error>
    where
        D: Deserializer<'de>,
        T: Deserialize<'de>,
{
    use serde::de::Error;
    TYPE_TAG_DEPTH.with(|depth| {
        let mut r = depth.borrow_mut();
        // For testability, we allow to serialize one more level than deserialize.
        if *r >= MAX_TYPE_TAG_NESTING - 1 {
            return Err(D::Error::custom(
                "type tag nesting exceeded during deserialization",
            ));
        }
        *r += 1;
        Ok(())
    })?;
    let res = T::deserialize(d);
    TYPE_TAG_DEPTH.with(|depth| {
        let mut r = depth.borrow_mut();
        *r -= 1;
    });
    res
}

'''
'''--- blockchains/aptos/src/aptos_type/script.rs ---
// Copyright (c) Aptos
// SPDX-License-Identifier: Apache-2.0

// use move_core_types::{
//     identifier::{Identifier, IdentStr},
//     language_storage::{ModuleId, TypeTag},
// };
use serde::{Deserialize, Serialize};
use std::fmt;

// pub use move_core_types::abi::{
//     ArgumentABI, ScriptFunctionABI as EntryFunctionABI, TransactionScriptABI, TypeArgumentABI,
// };
use crate::aptos_type::identifier::{Identifier, IdentStr};
use crate::aptos_type::language_storage::{ModuleId, TypeTag};
use crate::aptos_type::serde_helper::vec_bytes;
use crate::aptos_type::transaction_argument::TransactionArgument;

/// Call a Move script.
#[derive(Clone, Hash, Eq, PartialEq, Serialize, Deserialize)]
pub struct Script {
    #[serde(with = "serde_bytes")]
    code: Vec<u8>,
    ty_args: Vec<TypeTag>,
    args: Vec<TransactionArgument>,
}

impl Script {
    pub fn new(code: Vec<u8>, ty_args: Vec<TypeTag>, args: Vec<TransactionArgument>) -> Self {
        Script {
            code,
            ty_args,
            args,
        }
    }

    pub fn code(&self) -> &[u8] {
        &self.code
    }

    pub fn ty_args(&self) -> &[TypeTag] {
        &self.ty_args
    }

    pub fn args(&self) -> &[TransactionArgument] {
        &self.args
    }

    pub fn into_inner(self) -> (Vec<u8>, Vec<TypeTag>, Vec<TransactionArgument>) {
        (self.code, self.ty_args, self.args)
    }
}

impl fmt::Debug for Script {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("Script")
            .field("code", &hex::encode(&self.code))
            .field("ty_args", &self.ty_args)
            .field("args", &self.args)
            .finish()
    }
}

/// Call a Move entry function.
#[derive(Clone, Debug, Hash, Eq, PartialEq, Serialize, Deserialize)]
pub struct EntryFunction {
    module: ModuleId,
    function: Identifier,
    ty_args: Vec<TypeTag>,
    #[serde(with = "vec_bytes")]
    args: Vec<Vec<u8>>,
}

impl EntryFunction {
    pub fn new(
        module: ModuleId,
        function: Identifier,
        ty_args: Vec<TypeTag>,
        args: Vec<Vec<u8>>,
    ) -> Self {
        EntryFunction {
            module,
            function,
            ty_args,
            args,
        }
    }

    pub fn module(&self) -> &ModuleId {
        &self.module
    }

    pub fn function(&self) -> &IdentStr {
        &self.function
    }

    pub fn ty_args(&self) -> &[TypeTag] {
        &self.ty_args
    }

    pub fn args(&self) -> &[Vec<u8>] {
        &self.args
    }

    pub fn into_inner(self) -> (ModuleId, Identifier, Vec<TypeTag>, Vec<Vec<u8>>) {
        (self.module, self.function, self.ty_args, self.args)
    }
}

'''
'''--- blockchains/aptos/src/aptos_type/serde_helper/mod.rs ---
// Copyright (c) Aptos
// SPDX-License-Identifier: Apache-2.0

pub mod vec_bytes;

'''
'''--- blockchains/aptos/src/aptos_type/serde_helper/vec_bytes.rs ---
// Copyright (c) Aptos
// SPDX-License-Identifier: Apache-2.0

use serde::{
    de::Deserializer,
    ser::{SerializeSeq, Serializer},
    Deserialize,
};

pub fn serialize<S>(data: &[Vec<u8>], serializer: S) -> Result<S::Ok, S::Error>
where
    S: Serializer,
{
    let mut seq = serializer.serialize_seq(Some(data.len()))?;
    for e in data {
        seq.serialize_element(serde_bytes::Bytes::new(e.as_slice()))?;
    }
    seq.end()
}

pub fn deserialize<'de, D>(deserializer: D) -> Result<Vec<Vec<u8>>, D::Error>
where
    D: Deserializer<'de>,
{
    Ok(<Vec<serde_bytes::ByteBuf>>::deserialize(deserializer)?
        .into_iter()
        .map(serde_bytes::ByteBuf::into_vec)
        .collect())
}

'''
'''--- blockchains/aptos/src/aptos_type/transaction_argument.rs ---
// Copyright (c) The Diem Core Contributors
// Copyright (c) The Move Contributors
// SPDX-License-Identifier: Apache-2.0

use anyhow::{anyhow, Error, Result};
use serde::{Deserialize, Serialize};
use std::{convert::TryFrom, fmt};
use crate::aptos_type::account_address::AccountAddress;
use crate::aptos_type::value::MoveValue;

#[derive(Clone, Hash, Eq, PartialEq, Serialize, Deserialize)]
pub enum TransactionArgument {
    U8(u8),
    U64(u64),
    U128(u128),
    Address(AccountAddress),
    U8Vector(#[serde(with = "serde_bytes")] Vec<u8>),
    Bool(bool),
}

impl fmt::Debug for TransactionArgument {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            TransactionArgument::U8(value) => write!(f, "{{U8: {}}}", value),
            TransactionArgument::U64(value) => write!(f, "{{U64: {}}}", value),
            TransactionArgument::U128(value) => write!(f, "{{U128: {}}}", value),
            TransactionArgument::Bool(boolean) => write!(f, "{{BOOL: {}}}", boolean),
            TransactionArgument::Address(address) => write!(f, "{{ADDRESS: {:?}}}", address),
            TransactionArgument::U8Vector(vector) => {
                write!(f, "{{U8Vector: 0x{}}}", hex::encode(vector))
            }
        }
    }
}

impl From<TransactionArgument> for MoveValue {
    fn from(val: TransactionArgument) -> Self {
        match val {
            TransactionArgument::U8(i) => MoveValue::U8(i),
            TransactionArgument::U64(i) => MoveValue::U64(i),
            TransactionArgument::U128(i) => MoveValue::U128(i),
            TransactionArgument::Address(a) => MoveValue::Address(a),
            TransactionArgument::Bool(b) => MoveValue::Bool(b),
            TransactionArgument::U8Vector(v) => MoveValue::vector_u8(v),
        }
    }
}

impl TryFrom<MoveValue> for TransactionArgument {
    type Error = Error;
    fn try_from(val: MoveValue) -> Result<Self> {
        Ok(match val {
            MoveValue::U8(i) => TransactionArgument::U8(i),
            MoveValue::U64(i) => TransactionArgument::U64(i),
            MoveValue::U128(i) => TransactionArgument::U128(i),
            MoveValue::Address(a) => TransactionArgument::Address(a),
            MoveValue::Bool(b) => TransactionArgument::Bool(b),
            MoveValue::Vector(v) => TransactionArgument::U8Vector(
                v.into_iter()
                    .map(|mv| {
                        if let MoveValue::U8(byte) = mv {
                            Ok(byte)
                        } else {
                            Err(anyhow!("unexpected value in bytes: {:?}", mv))
                        }
                    })
                    .collect::<Result<Vec<u8>>>()?,
            ),
            MoveValue::Signer(_) | MoveValue::Struct(_) => {
                return Err(anyhow!("invalid transaction argument: {:?}", val))
            }
        })
    }
}

/// Convert the transaction arguments into Move values.
pub fn convert_txn_args(args: &[TransactionArgument]) -> Vec<Vec<u8>> {
    args.iter()
        .map(|arg| {
            MoveValue::from(arg.clone())
                .simple_serialize()
                .expect("transaction arguments must serialize")
        })
        .collect()
}

/// Struct for encoding vector<vector<u8>> arguments for script functions
#[derive(Clone, Hash, Eq, PartialEq, Deserialize)]
pub struct VecBytes(Vec<serde_bytes::ByteBuf>);

impl VecBytes {
    pub fn from(vec_bytes: Vec<Vec<u8>>) -> Self {
        VecBytes(
            vec_bytes
                .into_iter()
                .map(serde_bytes::ByteBuf::from)
                .collect(),
        )
    }

    pub fn into_vec(self) -> Vec<Vec<u8>> {
        self.0
            .into_iter()
            .map(|byte_buf| byte_buf.into_vec())
            .collect()
    }
}

'''
'''--- blockchains/aptos/src/aptos_type/value.rs ---
// Copyright (c) The Diem Core Contributors
// Copyright (c) The Move Contributors
// SPDX-License-Identifier: Apache-2.0

// use crate::{
//     account_address::AccountAddress,
//     identifier::Identifier,
//     language_storage::{StructTag, TypeTag},
// };
use anyhow::{bail, Result as AResult};
use serde::{
    de::Error as DeError,
    ser::{SerializeMap, SerializeSeq, SerializeStruct, SerializeTuple},
    Deserialize, Serialize,
};
use std::{
    convert::TryInto,
    fmt::{self, Debug},
};
use crate::aptos_type::account_address::AccountAddress;
use crate::aptos_type::identifier::Identifier;
use crate::aptos_type::language_storage::{StructTag, TypeTag};

/// In the `WithTypes` configuration, a Move struct gets serialized into a Serde struct with this name
pub const MOVE_STRUCT_NAME: &str = "struct";

/// In the `WithTypes` configuration, a Move struct gets serialized into a Serde struct with this as the first field
pub const MOVE_STRUCT_TYPE: &str = "type";

/// In the `WithTypes` configuration, a Move struct gets serialized into a Serde struct with this as the second field
pub const MOVE_STRUCT_FIELDS: &str = "fields";

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum MoveStruct {
    /// The representation used by the MoveVM
    Runtime(Vec<MoveValue>),
    /// A decorated representation with human-readable field names
    WithFields(Vec<(Identifier, MoveValue)>),
    /// An even more decorated representation with both types and human-readable field names
    WithTypes {
        type_: StructTag,
        fields: Vec<(Identifier, MoveValue)>,
    },
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum MoveValue {
    U8(u8),
    U64(u64),
    U128(u128),
    Bool(bool),
    Address(AccountAddress),
    Vector(Vec<MoveValue>),
    Struct(MoveStruct),
    Signer(AccountAddress),
}

/// A layout associated with a named field
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MoveFieldLayout {
    pub name: Identifier,
    pub layout: MoveTypeLayout,
}

impl MoveFieldLayout {
    pub fn new(name: Identifier, layout: MoveTypeLayout) -> Self {
        Self { name, layout }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum MoveStructLayout {
    /// The representation used by the MoveVM
    Runtime(Vec<MoveTypeLayout>),
    /// The representation used by the MoveVM with extra unique identifier for distinct type.
    CheckedRuntime {
        fields: Vec<MoveTypeLayout>,
        tag: u64,
    },
    /// A decorated representation with human-readable field names that can be used by clients
    WithFields(Vec<MoveFieldLayout>),
    /// An even more decorated representation with both types and human-readable field names
    WithTypes {
        type_: StructTag,
        fields: Vec<MoveFieldLayout>,
    },
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum MoveTypeLayout {
    #[serde(rename(serialize = "bool", deserialize = "bool"))]
    Bool,
    #[serde(rename(serialize = "u8", deserialize = "u8"))]
    U8,
    #[serde(rename(serialize = "u64", deserialize = "u64"))]
    U64,
    #[serde(rename(serialize = "u128", deserialize = "u128"))]
    U128,
    #[serde(rename(serialize = "address", deserialize = "address"))]
    Address,
    #[serde(rename(serialize = "vector", deserialize = "vector"))]
    Vector(Box<MoveTypeLayout>),
    #[serde(rename(serialize = "struct", deserialize = "struct"))]
    Struct(MoveStructLayout),
    #[serde(rename(serialize = "signer", deserialize = "signer"))]
    Signer,
}

impl MoveValue {
    pub fn simple_deserialize(blob: &[u8], ty: &MoveTypeLayout) -> AResult<Self> {
        Ok(bcs::from_bytes_seed(ty, blob)?)
    }

    pub fn simple_serialize(&self) -> Option<Vec<u8>> {
        bcs::to_bytes(self).ok()
    }

    pub fn vector_u8(v: Vec<u8>) -> Self {
        MoveValue::Vector(v.into_iter().map(MoveValue::U8).collect())
    }

    pub fn vector_address(v: Vec<AccountAddress>) -> Self {
        MoveValue::Vector(v.into_iter().map(MoveValue::Address).collect())
    }

    pub fn decorate(self, layout: &MoveTypeLayout) -> Self {
        match (self, layout) {
            (MoveValue::Struct(s), MoveTypeLayout::Struct(l)) => MoveValue::Struct(s.decorate(l)),
            (MoveValue::Vector(vals), MoveTypeLayout::Vector(t)) => {
                MoveValue::Vector(vals.into_iter().map(|v| v.decorate(t)).collect())
            }
            (v, _) => v,
        }
    }

    pub fn undecorate(self) -> Self {
        match self {
            Self::Struct(s) => MoveValue::Struct(s.undecorate()),
            Self::Vector(vals) => {
                MoveValue::Vector(vals.into_iter().map(MoveValue::undecorate).collect())
            }
            v => v,
        }
    }
}

pub fn serialize_values<'a, I>(vals: I) -> Vec<Vec<u8>>
where
    I: IntoIterator<Item = &'a MoveValue>,
{
    vals.into_iter()
        .map(|val| {
            val.simple_serialize()
                .expect("serialization should succeed")
        })
        .collect()
}

impl MoveStruct {
    pub fn new(value: Vec<MoveValue>) -> Self {
        Self::Runtime(value)
    }

    pub fn with_fields(values: Vec<(Identifier, MoveValue)>) -> Self {
        Self::WithFields(values)
    }

    pub fn with_types(type_: StructTag, fields: Vec<(Identifier, MoveValue)>) -> Self {
        Self::WithTypes { type_, fields }
    }

    pub fn simple_deserialize(blob: &[u8], ty: &MoveStructLayout) -> AResult<Self> {
        Ok(bcs::from_bytes_seed(ty, blob)?)
    }

    pub fn decorate(self, layout: &MoveStructLayout) -> Self {
        match (self, layout) {
            (MoveStruct::Runtime(vals), MoveStructLayout::WithFields(layouts)) => {
                MoveStruct::WithFields(
                    vals.into_iter()
                        .zip(layouts)
                        .map(|(v, l)| (l.name.clone(), v.decorate(&l.layout)))
                        .collect(),
                )
            }
            (MoveStruct::Runtime(vals), MoveStructLayout::WithTypes { type_, fields }) => {
                MoveStruct::WithTypes {
                    type_: type_.clone(),
                    fields: vals
                        .into_iter()
                        .zip(fields)
                        .map(|(v, l)| (l.name.clone(), v.decorate(&l.layout)))
                        .collect(),
                }
            }
            (MoveStruct::WithFields(vals), MoveStructLayout::WithTypes { type_, fields }) => {
                MoveStruct::WithTypes {
                    type_: type_.clone(),
                    fields: vals
                        .into_iter()
                        .zip(fields)
                        .map(|((fld, v), l)| (fld, v.decorate(&l.layout)))
                        .collect(),
                }
            }
            (v, _) => v, // already decorated
        }
    }

    pub fn fields(&self) -> &[MoveValue] {
        match self {
            Self::Runtime(vals) => vals,
            Self::WithFields(_) | Self::WithTypes { .. } => {
                // It's not possible to implement this without changing the return type, and thus
                // panicking is the best move
                panic!("Getting fields for decorated representation")
            }
        }
    }

    pub fn into_fields(self) -> Vec<MoveValue> {
        match self {
            Self::Runtime(vals) => vals,
            Self::WithFields(fields) | Self::WithTypes { fields, .. } => {
                fields.into_iter().map(|(_, f)| f).collect()
            }
        }
    }

    pub fn undecorate(self) -> Self {
        Self::Runtime(
            self.into_fields()
                .into_iter()
                .map(MoveValue::undecorate)
                .collect(),
        )
    }
}

impl MoveStructLayout {
    pub fn new(types: Vec<MoveTypeLayout>) -> Self {
        Self::Runtime(types)
    }

    pub fn with_fields(types: Vec<MoveFieldLayout>) -> Self {
        Self::WithFields(types)
    }

    pub fn with_types(type_: StructTag, fields: Vec<MoveFieldLayout>) -> Self {
        Self::WithTypes { type_, fields }
    }

    pub fn fields(&self) -> &[MoveTypeLayout] {
        match self {
            Self::Runtime(vals) => vals,
            Self::CheckedRuntime { fields, tag: _ } => fields,
            Self::WithFields(_) | Self::WithTypes { .. } => {
                // It's not possible to implement this without changing the return type, and some
                // performance-critical VM serialization code uses the Runtime case of this.
                // panicking is the best move
                panic!("Getting fields for decorated representation")
            }
        }
    }

    pub fn into_fields(self) -> Vec<MoveTypeLayout> {
        match self {
            Self::Runtime(vals) => vals,
            Self::CheckedRuntime { fields, tag: _ } => fields,
            Self::WithFields(fields) | Self::WithTypes { fields, .. } => {
                fields.into_iter().map(|f| f.layout).collect()
            }
        }
    }

    pub fn tag(&self) -> Option<u64> {
        match self {
            Self::CheckedRuntime { fields: _, tag } => Some(*tag),
            Self::Runtime(_) | Self::WithFields(_) | Self::WithTypes { .. } => None,
        }
    }
}

impl<'d> serde::de::DeserializeSeed<'d> for &MoveTypeLayout {
    type Value = MoveValue;
    fn deserialize<D: serde::de::Deserializer<'d>>(
        self,
        deserializer: D,
    ) -> Result<Self::Value, D::Error> {
        match self {
            MoveTypeLayout::Bool => bool::deserialize(deserializer).map(MoveValue::Bool),
            MoveTypeLayout::U8 => u8::deserialize(deserializer).map(MoveValue::U8),
            MoveTypeLayout::U64 => u64::deserialize(deserializer).map(MoveValue::U64),
            MoveTypeLayout::U128 => u128::deserialize(deserializer).map(MoveValue::U128),
            MoveTypeLayout::Address => {
                AccountAddress::deserialize(deserializer).map(MoveValue::Address)
            }
            MoveTypeLayout::Signer => {
                AccountAddress::deserialize(deserializer).map(MoveValue::Signer)
            }
            MoveTypeLayout::Struct(ty) => Ok(MoveValue::Struct(ty.deserialize(deserializer)?)),
            MoveTypeLayout::Vector(layout) => Ok(MoveValue::Vector(
                deserializer.deserialize_seq(VectorElementVisitor(layout))?,
            )),
        }
    }
}

struct VectorElementVisitor<'a>(&'a MoveTypeLayout);

impl<'d, 'a> serde::de::Visitor<'d> for VectorElementVisitor<'a> {
    type Value = Vec<MoveValue>;

    fn expecting(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {
        formatter.write_str("Vector")
    }

    fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
    where
        A: serde::de::SeqAccess<'d>,
    {
        let mut vals = Vec::new();
        while let Some(elem) = seq.next_element_seed(self.0)? {
            vals.push(elem)
        }
        Ok(vals)
    }
}

struct DecoratedStructFieldVisitor<'a>(&'a [MoveFieldLayout]);

impl<'d, 'a> serde::de::Visitor<'d> for DecoratedStructFieldVisitor<'a> {
    type Value = Vec<(Identifier, MoveValue)>;

    fn expecting(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {
        formatter.write_str("Struct")
    }

    fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
    where
        A: serde::de::SeqAccess<'d>,
    {
        let mut vals = Vec::new();
        for (i, layout) in self.0.iter().enumerate() {
            match seq.next_element_seed(layout)? {
                Some(elem) => vals.push(elem),
                None => return Err(A::Error::invalid_length(i, &self)),
            }
        }
        Ok(vals)
    }
}

struct StructFieldVisitor<'a>(&'a [MoveTypeLayout]);

impl<'d, 'a> serde::de::Visitor<'d> for StructFieldVisitor<'a> {
    type Value = Vec<MoveValue>;

    fn expecting(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {
        formatter.write_str("Struct")
    }

    fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
    where
        A: serde::de::SeqAccess<'d>,
    {
        let mut val = Vec::new();
        for (i, field_type) in self.0.iter().enumerate() {
            match seq.next_element_seed(field_type)? {
                Some(elem) => val.push(elem),
                None => return Err(A::Error::invalid_length(i, &self)),
            }
        }
        Ok(val)
    }
}

impl<'d> serde::de::DeserializeSeed<'d> for &MoveFieldLayout {
    type Value = (Identifier, MoveValue);

    fn deserialize<D: serde::de::Deserializer<'d>>(
        self,
        deserializer: D,
    ) -> Result<Self::Value, D::Error> {
        Ok((self.name.clone(), self.layout.deserialize(deserializer)?))
    }
}

impl<'d> serde::de::DeserializeSeed<'d> for &MoveStructLayout {
    type Value = MoveStruct;

    fn deserialize<D: serde::de::Deserializer<'d>>(
        self,
        deserializer: D,
    ) -> Result<Self::Value, D::Error> {
        match self {
            MoveStructLayout::Runtime(layout)
            | MoveStructLayout::CheckedRuntime {
                fields: layout,
                tag: _,
            } => {
                let fields =
                    deserializer.deserialize_tuple(layout.len(), StructFieldVisitor(layout))?;
                Ok(MoveStruct::Runtime(fields))
            }
            MoveStructLayout::WithFields(layout) => {
                let fields = deserializer
                    .deserialize_tuple(layout.len(), DecoratedStructFieldVisitor(layout))?;
                Ok(MoveStruct::WithFields(fields))
            }
            MoveStructLayout::WithTypes {
                type_,
                fields: layout,
            } => {
                let fields = deserializer
                    .deserialize_tuple(layout.len(), DecoratedStructFieldVisitor(layout))?;
                Ok(MoveStruct::WithTypes {
                    type_: type_.clone(),
                    fields,
                })
            }
        }
    }
}

impl serde::Serialize for MoveValue {
    fn serialize<S: serde::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        match self {
            MoveValue::Struct(s) => s.serialize(serializer),
            MoveValue::Bool(b) => serializer.serialize_bool(*b),
            MoveValue::U8(i) => serializer.serialize_u8(*i),
            MoveValue::U64(i) => serializer.serialize_u64(*i),
            MoveValue::U128(i) => serializer.serialize_u128(*i),
            MoveValue::Address(a) => a.serialize(serializer),
            MoveValue::Signer(a) => a.serialize(serializer),
            MoveValue::Vector(v) => {
                let mut t = serializer.serialize_seq(Some(v.len()))?;
                for val in v {
                    t.serialize_element(val)?;
                }
                t.end()
            }
        }
    }
}

struct MoveFields<'a>(&'a [(Identifier, MoveValue)]);

impl<'a> serde::Serialize for MoveFields<'a> {
    fn serialize<S: serde::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        let mut t = serializer.serialize_map(Some(self.0.len()))?;
        for (f, v) in self.0.iter() {
            t.serialize_entry(f, v)?;
        }
        t.end()
    }
}

impl serde::Serialize for MoveStruct {
    fn serialize<S: serde::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        match self {
            Self::Runtime(s) => {
                let mut t = serializer.serialize_tuple(s.len())?;
                for v in s.iter() {
                    t.serialize_element(v)?;
                }
                t.end()
            }
            Self::WithFields(fields) => MoveFields(fields).serialize(serializer),
            Self::WithTypes { type_, fields } => {
                // Serialize a Move struct as Serde struct type named `struct `with two fields named `type` and `fields`.
                // `fields` will get serialized as a Serde map.
                // Unfortunately, we can't serialize this in the logical way: as a Serde struct named `type` with a field for
                // each of `fields` because serde insists that struct and field names be `'static &str`'s
                let mut t = serializer.serialize_struct(MOVE_STRUCT_NAME, 2)?;
                // serialize type as string (e.g., 0x0::ModuleName::StructName<TypeArg1,TypeArg2>) instead of (e.g.
                // { address: 0x0...0, module: ModuleName, name: StructName, type_args: [TypeArg1, TypeArg2]})
                t.serialize_field(MOVE_STRUCT_TYPE, &type_.to_string())?;
                t.serialize_field(MOVE_STRUCT_FIELDS, &MoveFields(fields))?;
                t.end()
            }
        }
    }
}

impl fmt::Display for MoveFieldLayout {
    fn fmt(&self, f: &mut fmt::Formatter) -> std::fmt::Result {
        write!(f, "{}: {}", self.name, self.layout)
    }
}

impl fmt::Display for MoveTypeLayout {
    fn fmt(&self, f: &mut fmt::Formatter) -> std::fmt::Result {
        use MoveTypeLayout::*;
        match self {
            Bool => write!(f, "bool"),
            U8 => write!(f, "u8"),
            U64 => write!(f, "u64"),
            U128 => write!(f, "u128"),
            Address => write!(f, "address"),
            Vector(typ) => write!(f, "vector<{}>", typ),
            Struct(s) => write!(f, "{}", s),
            Signer => write!(f, "signer"),
        }
    }
}

impl fmt::Display for MoveStructLayout {
    fn fmt(&self, f: &mut fmt::Formatter) -> std::fmt::Result {
        write!(f, "{{ ")?;
        match self {
            Self::Runtime(layouts)
            | Self::CheckedRuntime {
                fields: layouts,
                tag: _,
            } => {
                for (i, l) in layouts.iter().enumerate() {
                    write!(f, "{}: {}, ", i, l)?
                }
            }
            Self::WithFields(layouts) => {
                for layout in layouts {
                    write!(f, "{}, ", layout)?
                }
            }
            Self::WithTypes { type_, fields } => {
                write!(f, "Type: {}", type_)?;
                write!(f, "Fields:")?;
                for field in fields {
                    write!(f, "{}, ", field)?
                }
            }
        }
        write!(f, "}}")
    }
}

impl TryInto<TypeTag> for &MoveTypeLayout {
    type Error = anyhow::Error;

    fn try_into(self) -> Result<TypeTag, Self::Error> {
        Ok(match self {
            MoveTypeLayout::Address => TypeTag::Address,
            MoveTypeLayout::Bool => TypeTag::Bool,
            MoveTypeLayout::U8 => TypeTag::U8,
            MoveTypeLayout::U64 => TypeTag::U64,
            MoveTypeLayout::U128 => TypeTag::U128,
            MoveTypeLayout::Signer => TypeTag::Signer,
            MoveTypeLayout::Vector(v) => {
                let inner_type = &**v;
                TypeTag::Vector(Box::new(inner_type.try_into()?))
            }
            MoveTypeLayout::Struct(v) => TypeTag::Struct(Box::new(v.try_into()?)),
        })
    }
}

impl TryInto<StructTag> for &MoveStructLayout {
    type Error = anyhow::Error;

    fn try_into(self) -> Result<StructTag, Self::Error> {
        use MoveStructLayout::*;
        match self {
            Runtime(..) | CheckedRuntime { fields: _, tag: _ } | WithFields(..) => bail!(
                "Invalid MoveTypeLayout -> StructTag conversion--needed MoveLayoutType::WithTypes"
            ),
            WithTypes { type_, .. } => Ok(type_.clone()),
        }
    }
}

impl fmt::Display for MoveValue {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            MoveValue::U8(u) => write!(f, "{}u8", u),
            MoveValue::U64(u) => write!(f, "{}u64", u),
            MoveValue::U128(u) => write!(f, "{}u128", u),
            MoveValue::Bool(false) => write!(f, "false"),
            MoveValue::Bool(true) => write!(f, "true"),
            MoveValue::Address(a) => write!(f, "{}", a.to_hex_literal()),
            MoveValue::Signer(a) => write!(f, "signer({})", a.to_hex_literal()),
            MoveValue::Vector(v) => fmt_list(f, "vector[", v, "]"),
            MoveValue::Struct(s) => fmt::Display::fmt(s, f),
        }
    }
}

impl fmt::Display for MoveStruct {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            MoveStruct::Runtime(v) => fmt_list(f, "struct[", v, "]"),
            MoveStruct::WithFields(fields) => {
                fmt_list(f, "{", fields.iter().map(DisplayFieldBinding), "}")
            }
            MoveStruct::WithTypes { type_, fields } => {
                fmt::Display::fmt(type_, f)?;
                fmt_list(f, " {", fields.iter().map(DisplayFieldBinding), "}")
            }
        }
    }
}

struct DisplayFieldBinding<'a>(&'a (Identifier, MoveValue));

impl fmt::Display for DisplayFieldBinding<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let DisplayFieldBinding((field, value)) = self;
        write!(f, "{}: {}", field, value)
    }
}

fn fmt_list<T: fmt::Display>(
    f: &mut fmt::Formatter<'_>,
    begin: &str,
    items: impl IntoIterator<Item = T>,
    end: &str,
) -> fmt::Result {
    write!(f, "{}", begin)?;
    let mut items = items.into_iter();
    if let Some(x) = items.next() {
        write!(f, "{}", x)?;
        for x in items {
            write!(f, ", {}", x)?;
        }
    }
    write!(f, "{}", end)?;
    Ok(())
}

'''
'''--- blockchains/aptos/src/error.rs ---
use thiserror::Error;

#[derive(Error, Debug)]
pub enum AptosError {
    #[error("aptos transaction parse failed, reason: `{0}`")]
    ParseFailed(String),
    #[error("aptos transaction serialize failed, reason: `{0}`")]
    SerializeFailed(String),
}

pub type Result<T> = std::result::Result<T, AptosError>;
'''
'''--- blockchains/aptos/src/lib.rs ---
mod parser;
mod error;
mod aptos_type;

use rcc_trait_chain::Chain;
use crate::error::AptosError;
use crate::parser::{AptosTx, Parser};

pub struct Aptos;

impl Chain<AptosError> for Aptos {
    fn parse(data: &Vec<u8>) -> Result<String, AptosError> {
        let tx = Parser::parse(data)?;
        tx.get_result()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use hex::FromHex;
    use serde_json::Value::String;

    #[test]
    fn test() {
        let json = r#"{"formatted_json":{"chain_id":33,"expiration_timestamp_secs":1665644470,"gas_unit_price":100,"max_gas_amount":3738,"payload":{"EntryFunction":{"args":[[131,79,75,117,220,170,203,215,197,73,169,147,205,211,20,6,118,225,114,209,254,224,96,155,246,135,108,116,170,167,17,96],[64,13,3,0,0,0,0,0]],"function":"transfer","module":{"address":"0000000000000000000000000000000000000000000000000000000000000001","name":"coin"},"ty_args":[{"struct":{"address":"0000000000000000000000000000000000000000000000000000000000000001","module":"aptos_coin","name":"AptosCoin","type_args":[]}}]}},"sender":"8bbbb70ae8b90a8686b2a27f10e21e44f2fb64ffffcaa4bb0242e9f1ea698659","sequence_number":1},"raw_json":{"chain_id":33,"expiration_timestamp_secs":1665644470,"gas_unit_price":100,"max_gas_amount":3738,"payload":{"EntryFunction":{"args":[[131,79,75,117,220,170,203,215,197,73,169,147,205,211,20,6,118,225,114,209,254,224,96,155,246,135,108,116,170,167,17,96],[64,13,3,0,0,0,0,0]],"function":"transfer","module":{"address":"0000000000000000000000000000000000000000000000000000000000000001","name":"coin"},"ty_args":[{"struct":{"address":"0000000000000000000000000000000000000000000000000000000000000001","module":"aptos_coin","name":"AptosCoin","type_args":[]}}]}},"sender":"8bbbb70ae8b90a8686b2a27f10e21e44f2fb64ffffcaa4bb0242e9f1ea698659","sequence_number":1}}"#;
        let data = "8bbbb70ae8b90a8686b2a27f10e21e44f2fb64ffffcaa4bb0242e9f1ea698659010000000000000002000000000000000000000000000000000000000000000000000000000000000104636f696e087472616e73666572010700000000000000000000000000000000000000000000000000000000000000010a6170746f735f636f696e094170746f73436f696e000220834f4b75dcaacbd7c549a993cdd3140676e172d1fee0609bf6876c74aaa7116008400d0300000000009a0e0000000000006400000000000000b6b747630000000021";
        let buf_message = Vec::from_hex(data).unwrap();
        let parse_result =  Aptos::parse(&buf_message).unwrap();
        println!("json is {}", parse_result);
        assert_eq!(json, parse_result);
    }
}

'''
'''--- blockchains/aptos/src/parser.rs ---

use crate::error::{AptosError, Result};
use crate::aptos_type::RawTransaction;

use bcs;
use serde_json::{json, Value};

pub struct Parser;

impl Parser {
    pub fn parse(data: &Vec<u8>) -> Result<AptosTx> {
        let tx: RawTransaction = bcs::from_bytes(data)
            .map_err(|err| AptosError::ParseFailed(format!("bcs deserialize failed {}", err.to_string())))?;
        Ok(AptosTx::new(tx))
    }
}

#[derive(Debug)]
pub struct AptosTx {
    tx: RawTransaction,
}

impl AptosTx {
    pub fn new(tx: RawTransaction) -> Self {
        AptosTx { tx }
    }

    fn get_raw_json(&self) -> Result<Value> {
        self.to_json_value()
    }

    fn get_formatted_json(&self) -> Result<Value> {
        self.to_json_value()
    }

    fn to_json_value(&self) -> Result<Value> {
        let value = serde_json::to_value(&self.tx)
            .map_err(|e| AptosError::SerializeFailed(format!("to json failed {}", e.to_string())))?;
        Ok(value)
    }

    pub fn get_result(&self) -> Result<String> {
        let raw_json = self.get_raw_json()?;
        let formatted_json = self.get_formatted_json()?;
        let result = json!({
            "raw_json" : raw_json,
            "formatted_json": formatted_json
        });
        Ok(result.to_string())
    }
}
'''
'''--- blockchains/arweave/Cargo.toml ---
[package]
name = "rcc-arweave"
version = "0.0.1"
edition = "2021"
license = "Apache-2.0"
description = "A transaction parser for arweave."

[dependencies]
rcc-trait-chain = "0.1.0"
ring = {version = "0.16.20", features = [ "std" ] }
thiserror = "1.0.31"
serde = {version="1.0.130", features=["derive"]}
base64 = "0.13.1"
hex = "0.4.3"
serde_json = { version = "1.0.68", features = ["preserve_order"] }
'''
'''--- blockchains/arweave/src/lib.rs ---
mod types;

use rcc_trait_chain::Chain;
use serde_json::json;
use crate::types::error::ArweaveError;
use crate::types::transaction::Transaction;

pub struct Arweave {}

impl Chain<ArweaveError> for Arweave {
    fn parse(data: &Vec<u8>) -> Result<String, ArweaveError> {
        let tx = match serde_json::from_slice::<Transaction>(data) {
            Ok(tx) => {
                json!({
                    "raw_json": tx,
                    "formatted_json": {
                        "owner": tx.owner,
                        "target": tx.target,
                        "quantity": tx.quantity,
                        "reward": tx.reward,
                        "data_size": tx.data_size,
                        "signature_data": tx.deep_hash().map_or_else(|e| format!("unable to deep hash transaction, reason: {}", e.to_string()), |data| hex::encode(data)),
                    },
                    "status": "success"
                })
            },
            Err(e) => {
                let readable = format!("unable to deserialize, reason: {}", e.to_string());
                json!({
                    "status": "failed",
                    "reason": readable
                })
            }
        };
        Ok(tx.to_string())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use serde_json::Value;
    use crate::types::hash::deep_hash;
    use crate::types::transaction::{Base64, DeepHashItem, Tag};
    use crate::types::transaction::ToItems;

    #[test]
    fn test_parse_tx_without_data() {
        // {"format":2,"id":"ydBnEDXkltirHF_89nDaAeJQsyh6ocVFH6w3bGdb4EQ","last_tx":"IgIzkTrNA1SG-aYLVGQM1eUEm_b-7Jq3F8_BCU_j6Uv25rz80zFGgC4Qd_Qazsy-","owner":"sSWWDVR8jBbeoGemy4M1VuhUM_0CusXRXdTavi46PUVcP814Km3szmVlk71l_-rBYjXNyrMr25_LWMHEOIQyfq2Dn-29iBbYqk608SGj3YHI2LnR6z3dxLBVxwT5atTu5iZnMfZ--NQinA64iIGrTQ3nG2A31s5lDT58VQsX7AF_eaVCwWYoyCKvUjKeduNmUSIjGl7sitr-tooTdcbAhshka55LCqd6brO24ZzB0iieWwrwAyN4LZpcjx36dMaR9q1L5nY5d-BnSZhVk2-_A8S-P7WfRrudTSUZMF8fV9o2Cd55T-h5wlHP5Xxh5BO45TZemwFRzFKX3qIEwKNZx_uCDhTlMmKpxtMaj2i0-gxI1QeXrHYv76KfgZy2U2XMW2H4Mpfr_WO2KM2_b6cWQUenPDnqzgRXsq6GXdHUFgV-qi1M_i4MCE6AD5-QlPQ_QcBa_ZfldowFL2PAC_hykEyDfRS7Mwx_Fw47g70sVbWE1DP9MEfxGC9vmOiDedroG2EqvT0VpM-xIzzhpGPWH_zNFcNSqj8s_zSqqtnXtlcTtbk76IpK8tKjDfIHq1JHZg__wobyfM0fiAqH6fJatUCLgWPGTbJ9M46uJw8bFI72py_2MdrxBkW-sNBoa21_g-6FUNH4dHWA8gGEwka5-BMnvaMYpAKAqQ2-GGYw1pE","tags":[{"name":"QXBwLU5hbWU","value":"QXJDb25uZWN0"},{"name":"QXBwLVZlcnNpb24","value":"MC40LjI"},{"name":"Q29udGVudC1UeXBl","value":"dGV4dC9wbGFpbg"}],"target":"gH04U_MDvhKdEeSVHqFnkx7xi4dsuKj94O9qRh50LSQ","quantity":"10000000","data":"","data_size":"0","data_root":"","reward":"1410507854"}
        let tx_bytes = hex::decode("7b22666f726d6174223a322c226964223a227964426e4544586b6c74697248465f38396e446141654a51737968366f6356464836773362476462344551222c226c6173745f7478223a224967497a6b54724e413153472d61594c5647514d316555456d5f622d374a713346385f4243555f6a3655763235727a38307a464767433451645f51617a73792d222c226f776e6572223a2273535757445652386a4262656f47656d79344d31567568554d5f304375735852586454617669343650555663503831344b6d33737a6d566c6b37316c5f2d7242596a584e79724d7232355f4c574d48454f495179667132446e2d323969426259716b36303853476a33594849324c6e52367a3364784c4256787754356174547535695a6e4d665a2d2d4e51696e413634694947725451336e473241333173356c44543538565173583741465f656156437757596f79434b76556a4b6564754e6d5553496a476c37736974722d746f6f54646362416873686b6135354c4371643662724f32345a7a42306969655777727741794e344c5a70636a783336644d61523971314c356e5935642d426e535a68566b322d5f4138532d50375766527275645453555a4d46386656396f3243643535542d6835776c48503558786835424f3435545a656d7746527a464b5833714945774b4e5a785f75434468546c4d6d4b7078744d616a3269302d677849315165587248597637364b66675a79325532584d573248344d7066725f574f324b4d325f623663575155656e50446e717a67525873713647586448554667562d7169314d5f69344d4345364144352d516c50515f516342615f5a666c646f77464c325041435f68796b457944665253374d77785f467734376737307356625745314450394d456678474339766d4f69446564726f4732457176543056704d2d78497a7a6870475057485f7a4e46634e53716a38735f7a537171746e58746c635474626b373649704b38744b6a4466494871314a485a675f5f776f6279664d30666941714836664a617455434c6757504754624a394d3436754a7738624649373270795f324d647278426b572d734e426f6132315f672d3646554e48346448574138674745776b61352d424d6e76614d5970414b417151322d47475977317045222c2274616773223a5b7b226e616d65223a22515842774c553568625755222c2276616c7565223a2251584a44623235755a574e30227d2c7b226e616d65223a22515842774c565a6c636e4e70623234222c2276616c7565223a224d4334304c6a49227d2c7b226e616d65223a225132397564475675644331556558426c222c2276616c7565223a226447563464433977624746706267227d5d2c22746172676574223a2267483034555f4d4476684b64456553564871466e6b78377869346473754b6a39344f3971526835304c5351222c227175616e74697479223a223130303030303030222c2264617461223a22222c22646174615f73697a65223a2230222c22646174615f726f6f74223a22222c22726577617264223a2231343130353037383534227d").unwrap();
        let tx =  Arweave::parse(&tx_bytes).unwrap();
        let parsed_tx: Value  = serde_json::from_str(&tx).unwrap();
        assert_eq!(parsed_tx["formatted_json"]["signature_data"], "87a9bb37c154b9dc27b4203c54b68301df51811383da8cd217a163356b3fa6325bc9ab6dd6e2f63f1200ac295646fc98");
    }

    #[test]
    fn test_parse_tx_with_data(){
        //{
        //     "format": 2,
        //     "id": "OUIpMNs---VcgpXTecDjNUDXHh4lCEitsBs9LkpDnMg",
        //     "last_tx": "funF-hqTAT6P99tS3-zRqbnBltN7ksTsuOndkOvskChpTZdXTR8RgwKjztzer_JV",
        //     "owner": "tW3_qttE4BnykJyFhOYmdIRDSgFhoqbtaNHw8b77S-2HyDUiZITC21VnJQ_4efMb78h88lQ9Pj4em5LKixN4dx-jPJxvQOjF-VG0zOb2YtBXi_JnDQLQyuA0MK_7r1TfesbG7a_3niEyaEqfM8xuLrZ_rIy0xzt8DCsuiBcLtTuT9xneH_xPe7GV2qXlkM-k34wCPlcL0N99pwP--ECr9QLNpPUnhUwK7Gz0_bTojbErD_RSko0GT6nNjhCsMjQBT60gWe8-Xqz23rokCdN2jG9kSA52GgkN63EdibNW-U9g2NLE8r0XcICrMjIqiUaLNJRwZzMS1xsX_ySXaeMNMUrhwaaPjnzDEqNcyX89-0rXZtFrmIaJb8jTinwGvBds0UwdT-NXGtbVRfrwWOTkbJT--GFZS_fvpe1VhpVLz2o0l0YairrjE5AZb8T463qOHtJ4tlCpEQcC6oJA2MSrkg3qcsBdJLkA24xOZO3TiCSStlOMbMGTWF72050OU3M2hLAE7Rdk6VaJNy-RhgcR7OlhDYPElUlcOKAu6Kr7n9dNHjKVE3GyFFieMs7lgrkUSHuVfxwF0_lek_YJ8BvlCKfeYpevwXvIDvyLqD0sWLRUCLbGKmL2QPC-yvhlBdslyyXckMZN2_MofXg5YVYOzx8A2V_04IGpqB7-_MU2Xl0",
        //     "tags": [
        //         {
        //             "name": "QXBwLU5hbWU",
        //             "value": "QXJEcml2ZS1XZWI"
        //         },
        //         {
        //             "name": "QXBwLVZlcnNpb24",
        //             "value": "MC4xLjA"
        //         },
        //         {
        //             "name": "Q29udGVudC1UeXBl",
        //             "value": "YXBwbGljYXRpb24vanNvbg"
        //         },
        //         {
        //             "name": "QXJGUw",
        //             "value": "MC4xMQ"
        //         },
        //         {
        //             "name": "RW50aXR5LVR5cGU",
        //             "value": "ZHJpdmU"
        //         },
        //         {
        //             "name": "VW5peC1UaW1l",
        //             "value": "MTY2NzgwMDEzNQ"
        //         },
        //         {
        //             "name": "RHJpdmUtSWQ",
        //             "value": "NTMyODczOTgtYTY3MC00YTM2LTk0M2QtYTUwZmJiMGVjZGMw"
        //         },
        //         {
        //             "name": "RHJpdmUtUHJpdmFjeQ",
        //             "value": "cHVibGlj"
        //         },
        //         {
        //             "name": "QXJEcml2ZS1DbGllbnQ",
        //             "value": "QXJDb25uZWN0LzAuNS4x"
        //         }
        //     ],
        //     "target": "",
        //     "quantity": "0",
        //     "data": "eyJuYW1lIjoiQXJDb25uZWN0IEFyY2hpdmVzIiwicm9vdEZvbGRlcklkIjoiNmNjMTg1ZGMtZmNjMC00NDMxLTg3ZDAtOTlhNzg2OGQ2ZWU1In0",
        //     "data_size": "83",
        //     "data_root": "ZMJNKS_lemQ1ghfLvNcnoXvNe61_7_B08flTDZYN3Eg",
        //     "reward": "52221667"
        // }
        let tx_bytes = hex::decode("7b22666f726d6174223a322c226964223a22222c226c6173745f7478223a22493535745f53496b745a4c4949683364527262353170626a724f68715f4c7671363142386c35446b7a33484a786d6d52643678765a42583050742d7171566955222c226f776e6572223a227730536a66512d6947784a5a465448496c6f69464734614878414b6f507948793154454e75646936456c695369504273436764674e6a6c37632d4b6374506b416f3046677759643231506e584834484c7747485974506a333874546e514f7643727552756d776e2d33454f53756a39656b503279696b35486c577a384a496339755f6944435a766961346369354e6a325f33505f324c304e674e7056766a6f727853447673362d483746746f6f614d53774d48774c36684f4745646d726c6969484f5a37704c49696f71624156346a37474a70744451373772554b54674e436f354951377a4b6745756765474b537064354b6849544e734477676e6769542d49514b38424c637a3747566761546a7a6f53747a513338576c68454750764c7472735a4154424452567878577a653973746a4534344f30456f4e5a64795442455239687863683561465a4b4e6b546541777954506838534d303276774952367469416c37793757576d65474576366e75454c47624f5461504f52356242543348775034714a36664941464d624f684b50384467506c555a354f654f64634b5644486c4f65626f7368533231655948496e7775647561737a6474334630457a76477957364335434a7330727a34776f4a62636947564c31637435496777374e4451636d7230584e72666b552d58634e3636526c45466633744158783655426651307669644e557a3678556e474e58726b2d694a36476163656a7679352d4e6d35736a3433725f4f44374f4b376662787137383377764d50776f50735965624569582d6351504435355f4e6b68374d3054396268734d4d66464f6f6237525853496637617061446b73477661325f536d787a35485a4861787a6178304a68374d2d67695678696a78744439504b744734756d374c4c393956503756596146703049306f50375546476335526a4955222c2274616773223a5b5d2c22746172676574223a2247556937747151337a4a5732435779773245527777756e4357336f576f493548417369454e4872527a3938222c227175616e74697479223a223130303030303030303030222c2264617461223a22222c22646174615f73697a65223a2230222c22646174615f726f6f74223a22222c22726577617264223a22343632323430222c227369676e6174757265223a22227d").unwrap();
        let tx =  Arweave::parse(&tx_bytes).unwrap();
        let parsed_tx: Value  = serde_json::from_str(&tx).unwrap();
        assert_eq!(parsed_tx["formatted_json"]["signature_data"], "00f41cfa7bfad3d7b097fcc28ed08cb4ca7d0c544ec760cc6cc5c4f3780d0ec43cc011eaaab0868393c3c813ab8c04df");
    }

    #[test]
    fn test_parse_tx_with_data_1(){
        let tx_bytes = hex::decode("7b22666f726d6174223a322c226964223a22222c226c6173745f7478223a224b797341664d666231784a6b316a653263783974463065514a736a486f685f72524f435a6558304739434e6f4736533665594c7043754c5f4a6d444d5a6e474b222c226f776e6572223a227730536a66512d6947784a5a465448496c6f69464734614878414b6f507948793154454e75646936456c695369504273436764674e6a6c37632d4b6374506b416f3046677759643231506e584834484c7747485974506a333874546e514f7643727552756d776e2d33454f53756a39656b503279696b35486c577a384a496339755f6944435a766961346369354e6a325f33505f324c304e674e7056766a6f727853447673362d483746746f6f614d53774d48774c36684f4745646d726c6969484f5a37704c49696f71624156346a37474a70744451373772554b54674e436f354951377a4b6745756765474b537064354b6849544e734477676e6769542d49514b38424c637a3747566761546a7a6f53747a513338576c68454750764c7472735a4154424452567878577a653973746a4534344f30456f4e5a64795442455239687863683561465a4b4e6b546541777954506838534d303276774952367469416c37793757576d65474576366e75454c47624f5461504f52356242543348775034714a36664941464d624f684b50384467506c555a354f654f64634b5644486c4f65626f7368533231655948496e7775647561737a6474334630457a76477957364335434a7330727a34776f4a62636947564c31637435496777374e4451636d7230584e72666b552d58634e3636526c45466633744158783655426651307669644e557a3678556e474e58726b2d694a36476163656a7679352d4e6d35736a3433725f4f44374f4b376662787137383377764d50776f50735965624569582d6351504435355f4e6b68374d3054396268734d4d66464f6f6237525853496637617061446b73477661325f536d787a35485a4861787a6178304a68374d2d67695678696a78744439504b744734756d374c4c393956503756596146703049306f50375546476335526a4955222c2274616773223a5b5d2c22746172676574223a2247556937747151337a4a5732435779773245527777756e4357336f576f493548417369454e4872527a3938222c227175616e74697479223a223130303030303030303030222c2264617461223a22222c22646174615f73697a65223a2230222c22646174615f726f6f74223a22222c22726577617264223a22343632323430222c227369676e6174757265223a22227d").unwrap();
        let tx =  Arweave::parse(&tx_bytes).unwrap();
        let parsed_tx: Value  = serde_json::from_str(&tx).unwrap();
        assert_eq!(parsed_tx["formatted_json"]["signature_data"], "68447623f73b73251aa62405b62b4493e05ad0ba90b48f6bd16ae8c59812b5344a8c53aec25a7f972cff9c2edeba8ae0");
    }

    #[test]
    fn test_parse_tx_with_data_2(){
        let tx_bytes = hex::decode("7b22666f726d6174223a322c226964223a22222c226c6173745f7478223a22454f62386c626f6b634633655f515f685737346e5959365f4c62694f676254345f4a2d6530333670746137794f585f6b517a4a66734d724c7466474e53626a66222c226f776e6572223a227730536a66512d6947784a5a465448496c6f69464734614878414b6f507948793154454e75646936456c695369504273436764674e6a6c37632d4b6374506b416f3046677759643231506e584834484c7747485974506a333874546e514f7643727552756d776e2d33454f53756a39656b503279696b35486c577a384a496339755f6944435a766961346369354e6a325f33505f324c304e674e7056766a6f727853447673362d483746746f6f614d53774d48774c36684f4745646d726c6969484f5a37704c49696f71624156346a37474a70744451373772554b54674e436f354951377a4b6745756765474b537064354b6849544e734477676e6769542d49514b38424c637a3747566761546a7a6f53747a513338576c68454750764c7472735a4154424452567878577a653973746a4534344f30456f4e5a64795442455239687863683561465a4b4e6b546541777954506838534d303276774952367469416c37793757576d65474576366e75454c47624f5461504f52356242543348775034714a36664941464d624f684b50384467506c555a354f654f64634b5644486c4f65626f7368533231655948496e7775647561737a6474334630457a76477957364335434a7330727a34776f4a62636947564c31637435496777374e4451636d7230584e72666b552d58634e3636526c45466633744158783655426651307669644e557a3678556e474e58726b2d694a36476163656a7679352d4e6d35736a3433725f4f44374f4b376662787137383377764d50776f50735965624569582d6351504435355f4e6b68374d3054396268734d4d66464f6f6237525853496637617061446b73477661325f536d787a35485a4861787a6178304a68374d2d67695678696a78744439504b744734756d374c4c393956503756596146703049306f50375546476335526a4955222c2274616773223a5b7b226e616d65223a226447567a6441222c2276616c7565223a22625756755a334a31227d5d2c22746172676574223a2247556937747151337a4a5732435779773245527777756e4357336f576f493548417369454e4872527a3938222c227175616e74697479223a223130303030303030303030222c2264617461223a22222c22646174615f73697a65223a2230222c22646174615f726f6f74223a22222c22726577617264223a22343534353336222c227369676e6174757265223a22227d").unwrap();
        let tx =  Arweave::parse(&tx_bytes).unwrap();
        let parsed_tx: Value  = serde_json::from_str(&tx).unwrap();
        assert_eq!(parsed_tx["formatted_json"]["signature_data"], "56149d23cc905f5249c0cb80728c841657a065d05ed249f42a670aa9239c9005a2b35a9eb39252de429442e6fbda9f20");
    }

    #[test]
    fn test_empty_vec(){
        let tags: Vec<Tag<Base64>> = vec![];
        let data = tags.to_deep_hash_item().unwrap();
        let deep_hash_item: Vec<DeepHashItem> = vec![data];
        println!("deep_hash_item {:?}", DeepHashItem::from_children(deep_hash_item.clone()));
        let deep_hash = deep_hash(DeepHashItem::from_children(deep_hash_item)).unwrap();
        println!("deep_hash {:?}", hex::encode(deep_hash));
    }
}

'''
'''--- blockchains/arweave/src/types/error.rs ---
//! Errors propagated by library functions.
use std::string::{FromUtf8Error};
use thiserror::Error;
use base64::DecodeError;

/// Errors propagated by library functions.
#[derive(Error, Debug)]
pub enum ArweaveError {
    #[error("base64 decode: {0}")]
    Base64Decode(#[from] DecodeError),
    #[error("from utf8: {0}")]
    FromUtf8(#[from] FromUtf8Error)
}
'''
'''--- blockchains/arweave/src/types/hash.rs ---
use ring::digest::{Context, SHA384};
use crate::types::transaction::DeepHashItem;

use crate::types::error::ArweaveError;

fn concat_u8_48(left: [u8; 48], right: [u8; 48]) -> Result<[u8; 96], ArweaveError> {
    let mut iter = left.into_iter().chain(right);
    let result = [(); 96].map(|_| iter.next().unwrap());
    Ok(result)
}

pub fn hash_sha384( message: &[u8]) -> Result<[u8; 48], ArweaveError> {
    let mut context = Context::new(&SHA384);
    context.update(message);
    let mut result: [u8; 48] = [0; 48];
    result.copy_from_slice(context.finish().as_ref());
    Ok(result)
}

pub fn hash_all_sha384(messages: Vec<&[u8]>) -> Result<[u8; 48], ArweaveError> {
    let hash: Vec<u8> = messages
        .into_iter()
        .map(|m| hash_sha384(m).unwrap())
        .into_iter()
        .flatten()
        .collect();
    let hash = hash_sha384(&hash)?;
    Ok(hash)
}

pub fn deep_hash(deep_hash_item: DeepHashItem) -> Result<[u8; 48], ArweaveError> {
    let hash = match deep_hash_item {
        DeepHashItem::Blob(blob) => {
            let blob_tag = format!("blob{}", blob.len());
            hash_all_sha384(vec![blob_tag.as_bytes(), &blob])?
        }
        DeepHashItem::List(list) => {
            let list_tag = format!("list{}", list.len());
            let mut hash = hash_sha384(list_tag.as_bytes())?;

            for child in list.into_iter() {
                let child_hash = deep_hash(child)?;
                hash = hash_sha384(&concat_u8_48(hash, child_hash)?)?;
            }
            hash
        }
    };
    Ok(hash)
}
'''
'''--- blockchains/arweave/src/types/mod.rs ---
pub mod transaction;
pub mod hash;
pub mod error;

'''
'''--- blockchains/arweave/src/types/transaction.rs ---
//! Data structures for serializing and deserializing [`Transaction`]s and [`Tag`]s.
use crate::types::{
    error::ArweaveError,
    hash::deep_hash
};
use serde::{de, Deserialize, Deserializer, Serialize, Serializer};
use std::str::FromStr;
use base64;

/// Transaction data structure per [Arweave transaction spec](https://docs.arweave.org/developers/server/http-api#transaction-format).
#[derive(Serialize, Deserialize, Debug, Default, PartialEq)]
pub struct Transaction {
    pub format: u8,
    #[serde(skip)]
    pub id: Base64,
    pub owner: Base64,
    #[serde(with = "stringify")]
    pub reward: u64,
    pub target: Base64,
    pub last_tx: Base64,
    #[serde(with = "stringify")]
    pub quantity: u64,
    pub tags: Vec<Tag<Base64>>,
    #[serde(skip)]
    pub data: Base64,
    #[serde(with = "stringify")]
    pub data_size: u64,
    pub data_root: Base64,
    #[serde(skip)]
    pub signature: Base64,
    #[serde(skip)]
    pub signature_data: Vec<u8>
}
impl Transaction {
    pub fn deep_hash(self) -> Result<[u8; 48], ArweaveError>{
        let deep_hash_item: DeepHashItem = self.to_deep_hash_item()?;
        deep_hash(deep_hash_item)
    }
}
pub mod stringify {
    use serde::{de::Error as _, Deserialize, Deserializer, Serialize, Serializer};

    pub fn deserialize<'de, D, T>(deserializer: D) -> Result<T, D::Error>
        where
            D: Deserializer<'de>,
            T: std::str::FromStr,
            <T as std::str::FromStr>::Err: std::fmt::Display,
    {
        String::deserialize(deserializer)?
            .parse::<T>()
            .map_err(|e| D::Error::custom(format!("{}", e)))
    }

    pub fn serialize<S, T>(value: &T, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: Serializer,
            T: std::fmt::Display,
    {
        format!("{}", value).serialize(serializer)
    }
}

pub trait ToItems<'a, T> {
    fn to_deep_hash_item(&'a self) -> Result<DeepHashItem, ArweaveError>;
}

impl<'a> ToItems<'a, Transaction> for Transaction {
    fn to_deep_hash_item(&'a self) -> Result<DeepHashItem, ArweaveError> {
        match &self.format {
            2 => {
                let mut children: Vec<DeepHashItem> = vec![
                    self.format.to_string().as_bytes(),
                    &self.owner.0,
                    &self.target.0,
                    self.quantity.to_string().as_bytes(),
                    self.reward.to_string().as_bytes(),
                    &self.last_tx.0,
                ]
                    .into_iter()
                    .map(DeepHashItem::from_item)
                    .collect();
                children.push(self.tags.to_deep_hash_item()?);
                children.push(DeepHashItem::from_item(
                    self.data_size.to_string().as_bytes(),
                ));
                children.push(DeepHashItem::from_item(&self.data_root.0));

                Ok(DeepHashItem::from_children(children))
            }
            _ => unreachable!(),
        }
    }
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct Tag<T> {
    pub name: T,
    pub value: T,
}

/// Implemented to create [`Tag`]s from utf-8 strings.
pub trait FromUtf8Strs<T> {
    fn from_utf8_strs(name: &str, value: &str) -> Result<T, ArweaveError>;
}

impl FromUtf8Strs<Tag<Base64>> for Tag<Base64> {
    fn from_utf8_strs(name: &str, value: &str) -> Result<Self, ArweaveError> {
        let b64_name = Base64::from_utf8_str(name)?;
        let b64_value = Base64::from_utf8_str(value)?;

        Ok(Self {
            name: b64_name,
            value: b64_value,
        })
    }
}

impl FromUtf8Strs<Tag<String>> for Tag<String> {
    fn from_utf8_strs(name: &str, value: &str) -> Result<Self, ArweaveError> {
        let name = String::from(name);
        let value = String::from(value);

        Ok(Self { name, value })
    }
}

impl<'a> ToItems<'a, Vec<Tag<Base64>>> for Vec<Tag<Base64>> {
    fn to_deep_hash_item(&'a self) -> Result<DeepHashItem, ArweaveError> {
        if self.len() > 0 {
            Ok(DeepHashItem::List(
                self.iter()
                    .map(|t| t.to_deep_hash_item().unwrap())
                    .collect(),
            ))
        } else {
            Ok(DeepHashItem::List(vec![]))
        }
    }
}

impl<'a> ToItems<'a, Tag<Base64>> for Tag<Base64> {
    fn to_deep_hash_item(&'a self) -> Result<DeepHashItem, ArweaveError> {
        Ok(DeepHashItem::List(vec![
            DeepHashItem::Blob(self.name.0.to_vec()),
            DeepHashItem::Blob(self.value.0.to_vec()),
        ]))
    }
}

/// A struct of [`Vec<u8>`] used for all data and address fields.
#[derive(Debug, Clone, PartialEq)]
pub struct Base64(pub Vec<u8>);

impl Default for Base64 {
    fn default() -> Self {
        Base64(vec![])
    }
}

impl std::fmt::Display for Base64 {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        let string = &base64::display::Base64Display::with_config(&self.0, base64::URL_SAFE_NO_PAD);
        write!(f, "{}", string)
    }
}

/// Converts a base64url encoded string to a Base64 struct.
impl FromStr for Base64 {
    type Err = base64::DecodeError;
    fn from_str(str: &str) -> Result<Self, Self::Err> {
        let result = base64::decode_config(str, base64::URL_SAFE_NO_PAD)?;
        Ok(Self(result))
    }
}

impl Base64 {
    pub fn from_utf8_str(str: &str) -> Result<Self, ArweaveError> {
        Ok(Self(str.as_bytes().to_vec()))
    }
}

impl Serialize for Base64 {
    fn serialize<S: Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        serializer.collect_str(&format!("{}", &self))
    }
}

impl<'de> Deserialize<'de> for Base64 {
    fn deserialize<D: Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        struct Vis;
        impl serde::de::Visitor<'_> for Vis {
            type Value = Base64;

            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("a base64 string")
            }

            fn visit_str<E: de::Error>(self, v: &str) -> Result<Self::Value, E> {
                base64::decode_config(v, base64::URL_SAFE_NO_PAD)
                    .map(Base64)
                    .map_err(|_| de::Error::custom("failed to decode base64 string"))
            }
        }
        deserializer.deserialize_str(Vis)
    }
}

/// Recursive data structure that facilitates [`crate::crypto::Provider::deep_hash`] accepting nested
/// arrays of arbitrary depth as an argument with a single type.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum DeepHashItem {
    Blob(Vec<u8>),
    List(Vec<DeepHashItem>),
}

impl DeepHashItem {
    pub fn from_item(item: &[u8]) -> DeepHashItem {
        Self::Blob(item.to_vec())
    }
    pub fn from_children(children: Vec<DeepHashItem>) -> DeepHashItem {
        Self::List(children)
    }
}

'''
'''--- blockchains/bitcoin/Cargo.toml ---
[package]
name = "rcc-bitcoin"
version = "0.1.0"
edition = "2021"
license = "Apache-2.0"
description = "Bitcoin wallet helper"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
[dependencies.bitcoin]
version = "0.29.2"
default-features = false
features = ["no-std"]

[dependencies.thiserror-no-std]
version = "2.0.2"

'''
'''--- blockchains/bitcoin/src/error.rs ---
use thiserror_no_std::Error;
use alloc::string::String;

#[derive(Error, Debug, PartialEq)]
pub enum BitcoinError {
    #[error("bitcoin address derivation failed, reason: `{0}`")]
    AddressDerivationFailed(String),
}

pub type Result<T> = std::result::Result<T, BitcoinError>;

'''
'''--- blockchains/bitcoin/src/lib.rs ---
#![no_std]

#[cfg(any(feature = "std", test))]
#[macro_use]
extern crate std;

#[cfg(all(not(feature = "std"), not(test)))]
#[macro_use]
extern crate core as std;
extern crate alloc;

use alloc::string::{ToString, String};
use crate::error::{BitcoinError, Result};
use std::str::{FromStr};
use bitcoin::util::{base58};
use bitcoin::util::bip32::{ExtendedPubKey, DerivationPath};
use bitcoin::secp256k1::Secp256k1;
use bitcoin::{Address};
use xyzpub::{convert_version, Version};

mod error;
mod xyzpub;

pub fn derive_address(xpub: String, path: String, script_type: String) -> Result<String> {
    let converted_xpub = convert_version(xpub, &Version::Xpub)
        .map_err(|_| BitcoinError::AddressDerivationFailed(String::from("xpub is not valid")))?;
    let xpub_key = base58::from_check(&converted_xpub)
        .map_err(|_| BitcoinError::AddressDerivationFailed(String::from("xpub is not valid")))?;
    let extended_pub_key = ExtendedPubKey::decode(&xpub_key)
        .map_err(|_| BitcoinError::AddressDerivationFailed(String::from("xpub is not valid")))?;

    let secp = Secp256k1::new();
    let path = DerivationPath::from_str(path.as_str())
        .map_err(|_| BitcoinError::AddressDerivationFailed(String::from("path is not valid")))?;
    let address_xpub = extended_pub_key.derive_pub(&secp, &path)
        .map_err(|_| BitcoinError::AddressDerivationFailed(String::from("error occurs in derivation")))?;
    let address_pubkey = address_xpub.to_pub();

    let address: Result<String> = match script_type.as_str() {
        "P2PKH" => Ok(Address::p2pkh(&address_pubkey, extended_pub_key.network).to_string()),
        "P2SH-P2WPKH" => Ok(Address::p2shwpkh(&address_pubkey, extended_pub_key.network)
            .map_err(|_| BitcoinError::AddressDerivationFailed(String::from("error occurs for derive P2SH-P2WPKH")))?.to_string()),
        "P2WPKH" => Ok(Address::p2wpkh(&address_pubkey, extended_pub_key.network)
            .map_err(|_| BitcoinError::AddressDerivationFailed(String::from("error occurs for derive P2WPKH")))?.to_string()),
        _ => Err(BitcoinError::AddressDerivationFailed(String::from("script type is not supported")))
    };
    address
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::std::string::String;

    // they audit color point vague response vital voice slogan coil depth vehicle
    #[test]
    fn test_derive_p2pkh_address() {
        let xpub = String::from("xpub6CPbc6auq3b8rEkXz6y78esTJ1SXLZwTJezUxoE8B7KZDfKo1qwJkHziR8MMat7P6RNf3aUPrUpMuKFQ8TRbfenCk6UvzCJXs1dHBdz2vcE");
        let path = String::from("m/0/0");
        let script_type = String::from("P2PKH");

        let address = derive_address(xpub, path, script_type).unwrap();
        assert_eq!(address.as_str(), "1Kw42PtjJV4VWYzDfaPekqy1V4kgXEpqz8");
    }

    #[test]
    fn test_derive_p2sh_p2wpkh_address() {
        let xpub = String::from("ypub6XK3HDTWbMt2TR2psR2sdrS5n6Kxd5P2zWKnPNRyZ3nK7fxvjkshnn6pmzmY7aKyf4LzvokW9pZTyHddMVy1utGgVRR22QZAEiDtm4orKqC");
        let path = String::from("m/0/1");
        let script_type = String::from("P2SH-P2WPKH");

        let address = derive_address(xpub, path, script_type).unwrap();
        assert_eq!(address.as_str(), "33TNSSsGqqrUKd7gnNvW2zfFSZ2UHqcZ3Z");
    }

    #[test]
    fn test_derive_p2wpkh_address() {
        let xpub = String::from("zpub6rMTvPvUKBmiHGygNQo2znmhF38gUvcu9WNdARryhdAewa1G2gWJiSvngKd99SpvgiQaiKdo5ymxjtc4HUmaQdDXPMzM2NyohatdNayrVZE");
        let path = String::from("m/0/2");
        let script_type = String::from("P2WPKH");

        let address = derive_address(xpub, path, script_type).unwrap();
        assert_eq!(address.as_str(), "bc1qucfwrtt6ey9643kemey92qvqcf7jkdxyts7dh5");
    }

    #[test]
    fn test_derive_address_error() {
        let xpub = String::from("xpub6CPbc6auq3b8rEkXz6y78esTJ1SXLZwTJezUxoE8");
        let path = String::from("m/0/1");
        let script_type = String::from("P2PKH");

        let address = derive_address(xpub, path, script_type).unwrap_err();
        let expected = BitcoinError::AddressDerivationFailed(String::from("xpub is not valid"));
        assert_eq!(expected, address);
    }
}

'''
'''--- blockchains/bitcoin/src/xyzpub.rs ---
use std::str::FromStr;
use alloc::string::String;
use alloc::vec::Vec;

use bitcoin::util::base58;

/// Version bytes xpub: bitcoin mainnet public key P2PKH or P2SH
pub const VERSION_XPUB: [u8; 4] = [0x04, 0x88, 0xB2, 0x1E];

/// Version bytes xprv: bitcoin mainnet private key P2PKH or P2SH
pub const VERSION_XPRV: [u8; 4] = [0x04, 0x88, 0xAD, 0xE4];

/// Version bytes ypub: bitcoin mainnet public key P2WPKH in P2SH
pub const VERSION_YPUB: [u8; 4] = [0x04, 0x9D, 0x7C, 0xB2];

/// Version bytes yprv: bitcoin mainnet private key P2WPKH in P2SH
pub const VERSION_YPRV: [u8; 4] = [0x04, 0x9D, 0x78, 0x78];

/// Version bytes zpub: bitcoin mainnet public key P2WPKH
pub const VERSION_ZPUB: [u8; 4] = [0x04, 0xB2, 0x47, 0x46];

/// Version bytes zprv: bitcoin mainnet private key P2WPKH
pub const VERSION_ZPRV: [u8; 4] = [0x04, 0xB2, 0x43, 0x0C];

/// Version bytes Ypub: bitcoin mainnet public key for multi-signature P2WSH in P2SH
pub const VERSION_YPUB_MULTISIG: [u8; 4] = [0x02, 0x95, 0xb4, 0x3f];

/// Version bytes Yprv: bitcoin mainnet private key for multi-signature P2WSH in P2SH
pub const VERSION_YPRV_MULTISIG: [u8; 4] = [0x02, 0x95, 0xb0, 0x05];

/// Version bytes Zpub: bitcoin mainnet public key for multi-signature P2WSH
pub const VERSION_ZPUB_MULTISIG: [u8; 4] = [0x02, 0xaa, 0x7e, 0xd3];

/// Version bytes Zprv: bitcoin mainnet private key for multi-signature P2WSH
pub const VERSION_ZPRV_MULTISIG: [u8; 4] = [0x02, 0xaa, 0x7a, 0x99];

/// Version bytes tpub: bitcoin testnet public key for P2PKH or P2SH
pub const VERSION_TPUB: [u8; 4] = [0x04, 0x35, 0x87, 0xCF];

/// Version bytes tprv: bitcoin testnet private key for P2PKH or P2SH
pub const VERSION_TPRV: [u8; 4] = [0x04, 0x35, 0x83, 0x94];

/// Version bytes upub: bitcoin testnet public key for P2WPKH in P2SH
pub const VERSION_UPUB: [u8; 4] = [0x04, 0x4A, 0x52, 0x62];

/// Version bytes uprv: bitcoin testnet private key for P2WPKH in P2SH
pub const VERSION_UPRV: [u8; 4] = [0x04, 0x4A, 0x4E, 0x28];

/// Version bytes vpub: bitcoin testnet public key for P2WPKH
pub const VERSION_VPUB: [u8; 4] = [0x04, 0x5F, 0x1C, 0xF6];

/// Version bytes vprv: bitcoin testnet private key for P2WPKH
pub const VERSION_VPRV: [u8; 4] = [0x04, 0x5F, 0x18, 0xBC];

/// Version bytes Upub: bitcoin testnet public key for multi-signature P2WSH in P2SH
pub const VERSION_UPUB_MULTISIG: [u8; 4] = [0x02, 0x42, 0x89, 0xef];

/// Version bytes Uprv: bitcoin testnet private key for multi-signature P2WSH in P2SH
pub const VERSION_UPRV_MULTISIG: [u8; 4] = [0x02, 0x42, 0x85, 0xb5];

/// Version bytes Vpub: bitcoin testnet public key for multi-signature P2WSH
pub const VERSION_VPUB_MULTISIG: [u8; 4] = [0x02, 0x57, 0x54, 0x83];

/// Version bytes Vprv: bitcoin testnet private key for multi-signature P2WSH
pub const VERSION_VPRV_MULTISIG: [u8; 4] = [0x02, 0x57, 0x50, 0x48];

/// xyzpub error.
#[derive(Debug, PartialEq, Eq)]
pub enum Error {
    /// Input is too short or has an invalid base58 length.
    InvalidLength(usize),
    /// Base58 input is not base58.
    InvalidBase58Char(u8),
    /// Checksum is not correct (expected, actual).
    BadChecksum(u32, u32),
    /// Input is not a valid address.
    InvalidAddress,
    /// Version prefix is unknown.
    UnknownVersionPrefix,
}

impl From<base58::Error> for Error {
    fn from(err: base58::Error) -> Self {
        match err {
            base58::Error::BadByte(byte) => Self::InvalidBase58Char(byte),
            base58::Error::TooShort(size) => Self::InvalidLength(size),
            base58::Error::InvalidLength(size) => Self::InvalidLength(size),
            base58::Error::BadChecksum(expected, actual) => Self::BadChecksum(expected, actual),
            _ => Self::InvalidAddress,
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
/// Enum for version bytes.
pub enum Version {
    /// Version bytes xpub: bitcoin mainnet public key P2PKH or P2SH
    Xpub,

    /// Version bytes ypub: bitcoin mainnet public key P2WPKH in P2SH
    Ypub,

    /// Version bytes zpub: bitcoin mainnet public key P2WPKH
    Zpub,

    /// Version bytes tpub: bitcoin testnet public key for P2PKH or P2SH
    Tpub,

    /// Version bytes upub: bitcoin testnet public key for P2WPKH in P2SH
    Upub,

    /// Version bytes vpub: bitcoin testnet public key for P2WPKH
    Vpub,

    /// Version bytes xprv: bitcoin mainnet private key P2PKH or P2SH
    Xprv,

    /// Version bytes yprv: bitcoin mainnet private key P2WPKH in P2SH
    Yprv,

    /// Version bytes zpub: bitcoin mainnet public key P2WPKH
    Zprv,

    /// Version bytes tprv: bitcoin testnet private key for P2PKH or P2SH
    Tprv,

    /// Version bytes uprv: bitcoin testnet private key for P2WPKH in P2SH
    Uprv,

    /// Version bytes vprv: bitcoin testnet private key for P2WPKH
    Vprv,

    /// Version bytes Ypub: bitcoin mainnet public key for multi-signature P2WSH in P2SH
    YpubMultisig,

    /// Version bytes Zpub: bitcoin mainnet public key for multi-signature P2WSH
    ZpubMultisig,

    /// Version bytes Upub: bitcoin testnet public key for multi-signature P2WSH in P2SH
    UpubMultisig,

    /// Version bytes Vpub: bitcoin testnet public key for multi-signature P2WSH
    VpubMultisig,

    /// Version bytes Yprv: bitcoin mainnet private key for multi-signature P2WSH in P2SH
    YprvMultisig,

    /// Version bytes Zprv: bitcoin mainnet private key for multi-signature P2WSH
    ZprvMultisig,

    /// Version bytes Uprv: bitcoin testnet private key for multi-signature P2WSH in P2SH
    UprvMultisig,

    /// Version bytes Vprv: bitcoin testnet private key for multi-signature P2WSH
    VprvMultisig,
}

impl Version {
    /// Returns the version bytes.
    pub fn bytes(&self) -> [u8; 4] {
        match self {
            Version::Xpub => VERSION_XPUB,
            Version::Ypub => VERSION_YPUB,
            Version::Zpub => VERSION_ZPUB,
            Version::Tpub => VERSION_TPUB,
            Version::Upub => VERSION_UPUB,
            Version::Vpub => VERSION_VPUB,
            Version::Xprv => VERSION_XPRV,
            Version::Yprv => VERSION_YPRV,
            Version::Zprv => VERSION_ZPRV,
            Version::Tprv => VERSION_TPRV,
            Version::Uprv => VERSION_UPRV,
            Version::Vprv => VERSION_VPRV,
            Version::YpubMultisig => VERSION_YPUB_MULTISIG,
            Version::ZpubMultisig => VERSION_ZPUB_MULTISIG,
            Version::UpubMultisig => VERSION_UPUB_MULTISIG,
            Version::VpubMultisig => VERSION_VPUB_MULTISIG,
            Version::YprvMultisig => VERSION_YPRV_MULTISIG,
            Version::ZprvMultisig => VERSION_ZPRV_MULTISIG,
            Version::UprvMultisig => VERSION_UPRV_MULTISIG,
            Version::VprvMultisig => VERSION_VPRV_MULTISIG,
        }
    }
}

impl FromStr for Version {
    type Err = Error;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "xpub" => Ok(Version::Xpub),
            "ypub" => Ok(Version::Ypub),
            "zpub" => Ok(Version::Zpub),
            "tpub" => Ok(Version::Tpub),
            "upub" => Ok(Version::Upub),
            "vpub" => Ok(Version::Vpub),
            "xprv" => Ok(Version::Xprv),
            "yprv" => Ok(Version::Yprv),
            "zprv" => Ok(Version::Zprv),
            "tprv" => Ok(Version::Tprv),
            "uprv" => Ok(Version::Uprv),
            "vprv" => Ok(Version::Vprv),
            "Ypub" => Ok(Version::YpubMultisig),
            "Zpub" => Ok(Version::ZpubMultisig),
            "Upub" => Ok(Version::UpubMultisig),
            "Vpub" => Ok(Version::VpubMultisig),
            "Yprv" => Ok(Version::YprvMultisig),
            "Zprv" => Ok(Version::ZprvMultisig),
            "Uprv" => Ok(Version::UprvMultisig),
            "Vprv" => Ok(Version::VprvMultisig),
            _ => Err(Self::Err::UnknownVersionPrefix),
        }
    }
}

/// Replaces the first 4 bytes of a byte slice with the target's version and returns a new byte vec.
/// Does not check if extended public/private key is valid and only replaces the version bytes.
pub fn replace_version_bytes<B: AsRef<[u8]>>(bytes: B, target: &Version) -> Result<Vec<u8>, Error> {
    let mut vec = bytes.as_ref().to_vec();
    if vec.len() < 4 {
        return Err(Error::InvalidLength(vec.len()));
    }
    vec[0..4].copy_from_slice(&target.bytes());

    Ok(vec)
}

/// Replaces the first 4 bytes of a base58 string with the target's version and returns the new string.
/// Also checks if the input is a correct address.
pub fn convert_version<S: AsRef<str>>(str: S, target: &Version) -> Result<String, Error> {
    let bytes = base58::from_check(str.as_ref())?;
    let replaced = replace_version_bytes(bytes, target)?;

    Ok(base58::check_encode_slice(&replaced))
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn err_when_too_short() {
        let short = "abc";

        let result = convert_version(short, &Version::Zpub);

        assert!(result.is_err());
    }

    #[test]
    fn err_when_too_few_bytes() {
        let short = vec![0x35];

        let result = replace_version_bytes(short, &Version::Zpub);

        assert!(result.is_err());
    }

    #[test]
    fn xpub_not_valid() {
        let xpub = "xpub6BosfCnifzxcFwrSzQiqu2DBVTshkCXacvNsWGYekkudhUd9yLb6qx39T9nMdj";

        let result = convert_version(xpub, &Version::Ypub);

        assert!(result.is_err());
    }

    #[test]
    fn xpub_to_ypub() {
        let xpub = "xpub6BosfCnifzxcFwrSzQiqu2DBVTshkCXacvNsWGYJVVhhawA7d4R5WSWGFNbi8Aw6ZRc1brxMyWMzG3DSSSSoekkudhUd9yLb6qx39T9nMdj";
        let expected_ypub = "ypub6We8xsTdpgW67F3ZpmWU77JgfS29gpX5Y2u6HfSBsW5ae2yLsiae8WAQGaZJ85b1y4ipMLYvSAiY9Kq1A8rpSzSWW3B3jtA5Na1gXzZ8iqF";

        let result = convert_version(xpub, &Version::Ypub).unwrap();

        assert_eq!(result, expected_ypub);
    }

    #[test]
    fn xpub_to_zpub() {
        let xpub = "xpub6BosfCnifzxcFwrSzQiqu2DBVTshkCXacvNsWGYJVVhhawA7d4R5WSWGFNbi8Aw6ZRc1brxMyWMzG3DSSSSoekkudhUd9yLb6qx39T9nMdj";
        let expected_zpub = "zpub6qUQGY8YyN3ZxYEgf8J6KCQBqQAbdSWaT9RK54L5FWTTh8na8NkCkZpYHnWt7zEwNhqd6p9Utq562cSZsqGqFE87NNsUKnyZeJ5KvbhfC8E";

        let result = convert_version(xpub, &Version::Zpub).unwrap();

        assert_eq!(result, expected_zpub);
    }

    #[test]
    fn zpub_to_xpub() {
        let zpub = "zpub6rFR7y4Q2AijBEqTUquhVz398htDFrtymD9xYYfG1m4wAcvPhXNfE3EfH1r1ADqtfSdVCToUG868RvUUkgDKf31mGDtKsAYz2oz2AGutZYs";
        let expected_xpub = "xpub6CatWdiZiodmUeTDp8LT5or8nmbKNcuyvz7WyksVFkKB4RHwCD3XyuvPEbvqAQY3rAPshWcMLoP2fMFMKHPJ4ZeZXYVUhLv1VMrjPC7PW6V";

        let result = convert_version(zpub, &Version::Xpub).unwrap();

        assert_eq!(result, expected_xpub);
    }

    #[test]
    fn xpub_to_tpub() {
        let xpub = "xpub6BosfCnifzxcFwrSzQiqu2DBVTshkCXacvNsWGYJVVhhawA7d4R5WSWGFNbi8Aw6ZRc1brxMyWMzG3DSSSSoekkudhUd9yLb6qx39T9nMdj";
        let expected_tpub = "tpubDCBWBScQPGv4Xk3JSbhw6wYYpayMjb2eAYyArpbSqQTbLDpphHGAetB6VQgVeftLML8vDSUEWcC2xDi3qJJ3YCDChJDvqVzpgoYSuT52MhJ";

        let result = convert_version(xpub, &Version::Tpub).unwrap();

        assert_eq!(result, expected_tpub);
    }
}

'''
'''--- blockchains/cardano/Cargo.toml ---
[package]
name = "rcc_cardano"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
serde_json = "1"
cardano-serialization-lib = "11.4.0"
paste = "1"
thiserror = "1.0"
ed25519-bip32-core = "0.1.1"
bitcoin = "0.30.0"
cryptoxide = "0.4.4"
hex = "0.4.3"
rcc-trait-chain = "0.1.0"
itertools = "0.10.5"
'''
'''--- blockchains/cardano/src/address.rs ---
use std::str::FromStr;
use crate::errors::{CardanoError, R};
use bitcoin::bech32;
use bitcoin::bech32::{ToBase32, Variant};
use bitcoin::bip32::{ChildNumber, DerivationPath};

use cryptoxide::hashing::blake2b_224;
use ed25519_bip32_core::{DerivationScheme, XPub};
use hex;

use cardano_serialization_lib::address::{BaseAddress, EnterpriseAddress, RewardAddress, StakeCredential};
use cardano_serialization_lib::crypto::Ed25519KeyHash;

pub enum AddressType {
    Base,
    Stake,
    Enterprise,
}

pub trait AddressGenerator {
    fn to_bech32(&self) -> R<String>;
}

pub struct CardanoAddress {
    prefix: String,
    header: u8,
    payment: Option<Vec<u8>>,
    stake: Option<Vec<u8>>,
}

impl AddressGenerator for CardanoAddress {
    fn to_bech32(&self) -> R<String> {
        let mut buf = vec![];
        buf.push(self.header);
        if let Some(key) = &self.payment {
            buf.extend(blake2b_224(key))
        }
        if let Some(key) = &self.stake {
            buf.extend(blake2b_224(key))
        }
        Ok(bech32::encode(
            self.prefix.as_str(),
            buf.to_base32(),
            Variant::Bech32,
        )?)
    }
}

impl CardanoAddress {
    pub fn new_mainnet_base_address(payment_key: &[u8], stake_key: &[u8]) -> Self {
        CardanoAddress {
            prefix: "addr".to_string(),
            // 0 | stake type |payment type |  network tag
            header: 0b0000_0001,
            payment: Some(payment_key.to_vec()),
            stake: Some(stake_key.to_vec()),
        }
    }

    pub fn new_mainnet_reward_address(stake_key: &[u8]) -> Self {
        CardanoAddress {
            prefix: "stake".to_string(),
            // 111 | stake type | network tag
            header: 0b1110_0001,
            payment: None,
            stake: Some(stake_key.to_vec()),
        }
    }
}

pub(crate) fn generate_address_by_xpub(xpub: String, index: u32) -> R<CardanoAddress> {
    let xpub_bytes = hex::decode(xpub).map_err(|e| CardanoError::DerivationError(e.to_string()))?;
    let xpub =
        XPub::from_slice(&xpub_bytes).map_err(|e| CardanoError::DerivationError(e.to_string()))?;
    let payment_key = xpub
        .derive(DerivationScheme::V2, 0)?
        .derive(DerivationScheme::V2, index)?
        .public_key();
    // stakeKey is m/1852'/1815'/X'/2/0 in most cases. except LACE wallet.
    let stake_key = xpub
        .derive(DerivationScheme::V2, 2)?
        .derive(DerivationScheme::V2, 0)?
        .public_key();
    Ok(CardanoAddress::new_mainnet_base_address(
        &payment_key,
        &stake_key,
    ))
}

pub fn derive_public_key(xpub: String, sub_path: String) -> R<String> {
    let xpub_bytes = hex::decode(xpub).map_err(|e| CardanoError::DerivationError(e.to_string()))?;
    let xpub =
        XPub::from_slice(&xpub_bytes).map_err(|e| CardanoError::DerivationError(e.to_string()))?;
    let path = DerivationPath::from_str(&sub_path).map_err(|e| CardanoError::DerivationError(e.to_string()))?;
    let childrens: Vec<ChildNumber> = path.into();
    let key = childrens
        .iter()
        .fold(Ok(xpub), |acc, cur| match cur {
            ChildNumber::Hardened { index } => acc.and_then(|v| v.derive(DerivationScheme::V2, index + 0x80000000)),
            ChildNumber::Normal { index } => acc.and_then(|v| v.derive(DerivationScheme::V2, index.clone())),
        }).map_err(|e| CardanoError::DerivationError(e.to_string()))?;
    Ok(hex::encode(key.public_key()))
}

pub fn derive_address(xpub: String, change: u32, index: u32, address_type: AddressType, network: u8) -> R<String> {
    let xpub_bytes = hex::decode(xpub).map_err(|e| CardanoError::DerivationError(e.to_string()))?;
    let xpub =
        XPub::from_slice(&xpub_bytes).map_err(|e| CardanoError::DerivationError(e.to_string()))?;
    match address_type {
        AddressType::Base => {
            let payment_key = xpub
                .derive(DerivationScheme::V2, change)?
                .derive(DerivationScheme::V2, index.clone())?
                .public_key();
            let payment_key_hash = blake2b_224(&payment_key);
            // stakeKey is m/1852'/1815'/X'/2/0 in most cases. except LACE wallet.
            let stake_key = xpub
                .derive(DerivationScheme::V2, 2)?
                .derive(DerivationScheme::V2, 0)?
                .public_key();
            let stake_key_hash = blake2b_224(&stake_key);
            let address = BaseAddress::new(
                network,
                &StakeCredential::from_keyhash(&Ed25519KeyHash::from(payment_key_hash)),
                &StakeCredential::from_keyhash(&Ed25519KeyHash::from(stake_key_hash)),
            );
            address
                .to_address()
                .to_bech32(None)
                .map_err(|e| CardanoError::AddressEncodingError(e.to_string()))
        }
        AddressType::Stake => {
            let stake_key = xpub
                .derive(DerivationScheme::V2, 2)?
                .derive(DerivationScheme::V2, index.clone())?
                .public_key();
            let stake_key_hash = blake2b_224(&stake_key);
            let address = RewardAddress::new(
                network,
                &StakeCredential::from_keyhash(&Ed25519KeyHash::from(stake_key_hash)),
            );
            address
                .to_address()
                .to_bech32(None)
                .map_err(|e| CardanoError::AddressEncodingError(e.to_string()))
        }
        AddressType::Enterprise => {
            let payment_key = xpub
                .derive(DerivationScheme::V2, 0)?
                .derive(DerivationScheme::V2, index.clone())?
                .public_key();
            let payment_key_hash = blake2b_224(&payment_key);
            let address = EnterpriseAddress::new(
                network,
                &StakeCredential::from_keyhash(&Ed25519KeyHash::from(payment_key_hash)),
            );
            address
                .to_address()
                .to_bech32(None)
                .map_err(|e| CardanoError::AddressEncodingError(e.to_string()))
        }
    }
}

'''
'''--- blockchains/cardano/src/detail.rs ---
use serde_json::{json, Value};
use crate::impl_public_struct;
use crate::traits::ToJSON;

impl_public_struct!(CardanoDetail {
    total_input_amount: String,
    total_output_amount: String,
    deposit_reclaim: Option<String>,
    deposit: Option<String>,
    stake_content: Option<Vec<CardanoDetailStakeAction>>
});

impl ToJSON for CardanoDetail {
    fn to_json(&self) -> Value {
        let stake_content = self.get_stake_content().map(|v| v.iter().map(|v| v.to_json()).collect::<Vec<Value>>());
        json!({
            "total_input_amount": self.get_total_input_amount(),
            "total_output_amount": self.get_total_output_amount(),
            "deposit_reclaim": self.get_deposit_reclaim(),
            "deposit": self.get_deposit(),
            "stake_content": stake_content,
        })
    }
}

#[derive(Clone, Debug)]
pub enum CardanoDetailStakeAction {
    // special scenario
    // user delegation to a pool, contain a Delegation and an optional matched Registration
    Stake(CardanoStake),
    // user withdraw from a pool, contain a Withdrawal and an optional matched Deregistration.
    // we treat a Deregistration as a kind of Withdrawal which reward_amount is 0
    Withdrawal(CardanoWithdrawal),
    //Plain action
    Registration(CardanoRegistration),
}

impl CardanoDetailStakeAction {
    pub fn get_type(&self) -> String {
        match self {
            Self::Stake(_) => "Stake".to_string(),
            Self::Withdrawal(_) => "Withdrawal".to_string(),
            Self::Registration(_) => "Registration".to_string(),
        }
    }
    pub fn as_stake(&self) -> Option<CardanoStake> {
        match self {
            Self::Stake(x) => Some(x.clone()),
            _ => None
        }
    }
    pub fn as_withdrawal(&self) -> Option<CardanoWithdrawal> {
        match self {
            Self::Withdrawal(x) => Some(x.clone()),
            _ => None
        }
    }
    pub fn as_registration(&self) -> Option<CardanoRegistration> {
        match self {
            Self::Registration(x) => Some(x.clone()),
            _ => None
        }
    }
}

impl ToJSON for CardanoDetailStakeAction {
    fn to_json(&self) -> Value {
        json!({
            "action_type": self.get_type(),
            "stake": self.as_stake().map(|v| v.to_json()),
            "withdrawal": self.as_withdrawal().map(|v| v.to_json()),
            "registration": self.as_registration().map(|v| v.to_json()),
        })
    }
}

impl Default for CardanoDetailStakeAction {
    fn default() -> Self {
        Self::Stake(CardanoStake::default())
    }
}

impl_public_struct!(CardanoStake {
    stake_key: String,
    pool: String
});

impl ToJSON for CardanoStake {
    fn to_json(&self) -> Value {
        json!( {
            "stake_key": self.get_stake_key(),
            "pool": self.get_pool(),
        })
    }
}

impl_public_struct!(CardanoRegistration {
    registration_stake_key: String
});

impl ToJSON for CardanoRegistration {
    fn to_json(&self) -> Value {
        json!({
            "registration_stake_key": self.get_registration_stake_key(),
        })
    }
}

impl_public_struct!(CardanoWithdrawal {
    reward_address: Option<String>,
    reward_amount: Option<String>,
    value: u64,
    deregistration_stake_key: Option<String>
});

impl ToJSON for CardanoWithdrawal {
    fn to_json(&self) -> Value {
        json!({
            "reward_address": self.get_reward_address(),
            "reward_amount": self.get_reward_amount(),
            "deregistration_stake_key": self.get_deregistration_stake_key()
        })
    }
}
'''
'''--- blockchains/cardano/src/errors.rs ---
use bitcoin::bech32;
use bitcoin::bech32::Error;
use cardano_serialization_lib::error::DeserializeError;
use ed25519_bip32_core::DerivationError;
use thiserror;
use thiserror::Error;

#[derive(Error, Debug)]
pub enum CardanoError {
    #[error("meet error when encoding address: {0}")]
    AddressEncodingError(String),
    #[error("meet error when derive cardano key, {0}")]
    DerivationError(String),
    #[error("invalid transaction: {0}")]
    InvalidTransaction(String),
    #[error("unsupported transaction type: {0}")]
    UnsupportedTransaction(String),
    #[error("error occurs when signing cardano transaction: {0}")]
    SigningFailed(String),
}

pub type R<T> = Result<T, CardanoError>;

impl From<bech32::Error> for CardanoError {
    fn from(value: Error) -> Self {
        Self::AddressEncodingError(value.to_string())
    }
}

impl From<DeserializeError> for CardanoError {
    fn from(value: DeserializeError) -> Self {
        Self::InvalidTransaction(value.to_string())
    }
}

impl From<DerivationError> for CardanoError {
    fn from(value: DerivationError) -> Self {
        Self::DerivationError(value.to_string())
    }
}

'''
'''--- blockchains/cardano/src/lib.rs ---
pub mod address;
pub mod detail;
pub mod errors;
mod macros;
pub mod overview;
pub mod structs;
pub mod transaction;
mod traits;

'''
'''--- blockchains/cardano/src/macros.rs ---
#[macro_export]
macro_rules! impl_public_struct {
    ($name: ident { $($field: ident: $t: ty), *}) => {
        #[derive(Debug, Clone, Default)]
        pub struct $name {
            $(
              $field: $t,
            )*
        }

        impl $name {
            pub fn new($($field: $t), *) -> Self {
                Self {
                    $(
                        $field
                    ), *
                }
            }
        }

        paste::item! {
            impl $name {
                $(
                    pub fn [<get_ $field>](&self) -> $t {
                        self.$field.clone()
                    }
                    pub fn [<set_ $field>](&mut self, $field: $t) {
                        self.$field = $field
                    }
                )*
            }
        }
    }
}

#[macro_export]
macro_rules! impl_internal_struct {
    ($name: ident { $($field: ident: $t: ty), *}) => {
        #[derive(Debug, Clone, Default)]
        pub(crate) struct $name {
            $(
              $field: $t,
            )*
        }

        impl $name {
            pub(crate) fn new($($field: $t), *) -> Self {
                Self {
                    $(
                        $field
                    ), *
                }
            }
        }

        paste::item! {
            impl $name {
                $(
                    pub(crate) fn [<get_ $field>](&self) -> $t {
                        self.$field.clone()
                    }
                    pub(crate) fn [<set_ $field>](&mut self, $field: $t) {
                        self.$field = $field
                    }
                )*
            }
        }
    }
}

'''
'''--- blockchains/cardano/src/overview.rs ---
use serde_json::{json, Value};
use crate::impl_public_struct;
use crate::traits::ToJSON;

impl_public_struct!(CardanoOverview {
    header_card: CardanoHeaderCard
});

impl ToJSON for CardanoOverview {
    fn to_json(&self) -> Value {
        self.get_header_card().to_json()
    }
}

#[derive(Debug, Clone)]
pub enum CardanoHeaderCard {
    Transfer(CardanoOverviewTransferCard),
    Stake(CardanoOverviewStakeCard),
    Withdrawal(CardanoOverviewWithdrawalCard),
}

impl CardanoHeaderCard {
    pub fn get_type(&self) -> String {
        match self {
            Self::Transfer(_) => "Transfer".to_string(),
            Self::Stake(_) => { "Stake".to_string() }
            Self::Withdrawal(_) => { "Withdrawal".to_string() }
        }
    }
    pub fn as_transfer(&self) -> Option<CardanoOverviewTransferCard> {
        match self {
            Self::Transfer(x) => Some(x.clone()),
            _ => None
        }
    }
    pub fn as_stake(&self) -> Option<CardanoOverviewStakeCard> {
        match self {
            Self::Stake(x) => Some(x.clone()),
            _ => None
        }
    }
    pub fn as_withdrawal(&self) -> Option<CardanoOverviewWithdrawalCard> {
        match self {
            Self::Withdrawal(x) => Some(x.clone()),
            _ => None
        }
    }
}

impl ToJSON for CardanoHeaderCard {
    fn to_json(&self) -> Value {
        json!({
            "header_type": self.get_type(),
            "transfer": self.as_transfer().map(|v| v.to_json()),
            "stake": self.as_stake().map(|v| v.to_json()),
            "withdrawal": self.as_withdrawal().map(|v| v.to_json())
        })
    }
}

impl_public_struct!(CardanoOverviewTransferCard {
    total_output_amount: String
});

impl ToJSON for CardanoOverviewTransferCard {
    fn to_json(&self) -> Value {
        json!({
            "total_output_amount": self.get_total_output_amount(),
        })
    }
}

impl Default for CardanoHeaderCard {
    fn default() -> Self {
        CardanoHeaderCard::Transfer(CardanoOverviewTransferCard::default())
    }
}

impl_public_struct!(CardanoOverviewStakeCard {
    stake_amount: String,
    deposit: Option<String>
});

impl ToJSON for CardanoOverviewStakeCard {
    fn to_json(&self) -> Value {
        json!({
            "stake_amount": self.get_stake_amount(),
            "deposit": self.get_deposit(),
        })
    }
}

impl_public_struct!(CardanoOverviewWithdrawalCard {
    reward_amount: String,
    deposit_reclaim: Option<String>,
    reward_account: Option<String>
});

impl ToJSON for CardanoOverviewWithdrawalCard {
    fn to_json(&self) -> Value {
        json!({
            "reward_amount": self.get_reward_amount(),
            "deposit_reclaim": self.get_deposit_reclaim(),
            "reward_account": self.get_reward_account(),
        })
    }
}
'''
'''--- blockchains/cardano/src/structs.rs ---
use crate::address::{derive_address, AddressGenerator, AddressType};
use crate::errors::{CardanoError, R};
use cardano_serialization_lib::address::RewardAddress;

use cardano_serialization_lib::utils::from_bignum;
use cardano_serialization_lib::{CertificateKind, NetworkId, NetworkIdKind, Transaction};

use crate::detail::{
    CardanoDetail, CardanoDetailStakeAction, CardanoRegistration, CardanoStake, CardanoWithdrawal,
};
use crate::overview::{
    CardanoHeaderCard, CardanoOverview, CardanoOverviewStakeCard, CardanoOverviewTransferCard,
    CardanoOverviewWithdrawalCard,
};
use bitcoin::bip32::ChildNumber::{Hardened, Normal};
use bitcoin::bip32::DerivationPath;
use cryptoxide::hashing::blake2b_256;
use itertools::Itertools;
use serde_json::{json, Value};
use std::collections::HashMap;
use std::ops::Div;

use crate::traits::ToJSON;
use crate::{impl_internal_struct, impl_public_struct};

impl_public_struct!(ParseContext {
    utxos: Vec<CardanoUtxo>,
    cert_keys: Vec<CardanoCertKey>,
    cardano_xpub: String,
    master_fingerprint: Vec<u8>
});

impl_public_struct!(CardanoSignarure {
    public_key: Vec<u8>,
    signature: Vec<u8>
});

impl_public_struct!(CardanoUtxo {
    master_fingerprint: Vec<u8>,
    address: String,
    path: DerivationPath,
    value: u64,
    transaction_hash: Vec<u8>,
    index: u32
});

impl_public_struct!(CardanoCertKey {
    master_fingerprint: Vec<u8>,
    key_hash: Vec<u8>,
    path: DerivationPath
});

impl_public_struct!(ParsedCardanoTx {
    overview: CardanoOverview,
    detail: CardanoDetail,
    fee: String,
    from: Vec<CardanoFrom>,
    to: Vec<CardanoTo>,
    network: String,
    method: String,
    sign_data: String
});

impl ToJSON for ParsedCardanoTx {
    fn to_json(&self) -> Value {
        json!({
            "overview": self.get_overview().to_json(),
            "detail": self.get_detail().to_json(),
            "fee": self.get_fee(),
            "network": self.get_network(),
            "method": self.get_method(),
            "sign_data": self.get_sign_data(),
            "from": self.get_from().iter().map(|v| v.to_json()).collect::<Vec<Value>>(),
            "to": self.get_to().iter().map(|v| v.to_json()).collect::<Vec<Value>>(),
        })
    }
}

// method label on ui
#[derive(Clone, Debug, Default)]
pub enum CardanoMethod {
    #[default]
    Transfer,
    Stake,
    Withdrawal,
}

impl ToString for CardanoMethod {
    fn to_string(&self) -> String {
        match &self {
            CardanoMethod::Transfer => "Transfer".to_string(),
            CardanoMethod::Stake => "Stake".to_string(),
            CardanoMethod::Withdrawal => "Withdrawals".to_string(),
        }
    }
}

impl_internal_struct!(ParsedCardanoInput {
    transaction_hash: Vec<u8>,
    index: u32,
    value: Option<u64>,
    address: Option<String>,
    path: Option<String>,
    is_mine: bool
});

impl_public_struct!(CardanoFrom {
    address: String,
    amount: String,
    path: Option<String>,
    value: u64
});

impl ToJSON for CardanoFrom {
    fn to_json(&self) -> Value {
        json!({
            "address": self.get_address(),
            "amount": self.get_amount(),
            "path": self.get_path(),
        })
    }
}

impl_public_struct!(CardanoTo {
    address: String,
    amount: String,
    assets: HashMap<String, ParsedCardanoMultiAsset>,
    assets_text: Option<String>,
    value: u64
});

impl ToJSON for CardanoTo {
    fn to_json(&self) -> Value {
        json!({
            "address": self.get_address(),
            "amount": self.get_amount(),
            "assets_text": self.get_assets_text(),
        })
    }
}

impl_internal_struct!(ParsedCardanoOutput {
    address: String,
    amount: String,
    value: u64,
    assets: Option<Vec<ParsedCardanoMultiAsset>>
});

impl_public_struct!(ParsedCardanoMultiAsset {
    id: String,
    policy_id: Vec<u8>,
    name: Vec<u8>,
    amount: String,
    value: u64
});

#[derive(Clone)]
enum CardanoCertAction {
    Registration(Registration),
    Deregistration(Deregistration),
    Delegation(Delegation),
}

#[derive(Clone)]
struct Registration {
    stake_key: RewardAddress,
}

#[derive(Clone)]
struct Deregistration {
    stake_key: RewardAddress,
}

#[derive(Clone)]
struct Delegation {
    pool: String,
    stake_key: RewardAddress,
}

impl ParsedCardanoTx {
    pub fn from_cardano_tx(tx: Transaction, context: ParseContext) -> R<Self> {
        let network_id = Self::judge_network_id(&tx);
        let network = match network_id {
            1 => "Cardano Mainnet".to_string(),
            _ => "Cardano Testnet".to_string(),
        };
        let parsed_inputs = Self::parse_inputs(&tx, &context, network_id)?;
        let parsed_outputs = Self::parse_outputs(&tx)?;
        let cert_actions = Self::parse_certs(&tx)?;
        let stake_actions = Self::parse_stake_actions(&tx, &cert_actions)?;

        let fee = from_bignum(&tx.body().fee());
        let method = Self::detect_method(&tx);

        let total_output_amount = {
            let _v = parsed_outputs.iter().fold(0u64, |acc, cur| acc + cur.value);
            normalize_coin(_v)
        };

        let _from_list = {
            let mut _list = vec![];
            for (key, _) in Self::get_from_list(parsed_inputs.clone()) {
                _list.push(key)
            }
            _list
        };

        let from_list_detail = {
            let mut _list = vec![];
            for (_, value) in Self::get_from_list(parsed_inputs.clone()) {
                _list.push(value)
            }
            _list
        };

        let _to_list = {
            let mut _list = vec![];
            for (key, _) in Self::get_to_list(parsed_outputs.clone()) {
                _list.push(key)
            }
            _list
        };

        let to_list_detail = {
            let mut _list = vec![];
            for (_, value) in Self::get_to_list(parsed_outputs) {
                _list.push(value)
            }
            _list
        };

        let fee = normalize_coin(fee);

        let deposit = match cert_actions
            .iter()
            .filter(|v| match v {
                CardanoCertAction::Registration(_) => true,
                _ => false,
            })
            .collect::<Vec<&CardanoCertAction>>()
            .len()
        {
            0 => None,
            x => Some(format!("{} ADA", x * 2)),
        };

        let deposit_reclaim = {
            let actions = cert_actions
                .iter()
                .filter(|v| match v {
                    CardanoCertAction::Deregistration(_) => true,
                    _ => false,
                })
                .collect::<Vec<&CardanoCertAction>>();
            match actions.len() {
                0 => None,
                x => Some(format!("{} ADA", x * 2)),
            }
        };

        let reward_amount = {
            let value = stake_actions.iter().fold(0, |acc, cur| match cur {
                CardanoDetailStakeAction::Withdrawal(withdraw) => acc + withdraw.get_value(),
                _ => acc,
            });
            normalize_coin(value)
        };

        let reward_account = {
            let addresses = stake_actions
                .iter()
                .filter(|v| match v {
                    CardanoDetailStakeAction::Withdrawal(_) => true,
                    _ => false,
                })
                .map(|v| match v {
                    CardanoDetailStakeAction::Withdrawal(x) => x.get_reward_address(),
                    _ => None,
                })
                .collect::<Vec<Option<String>>>();
            let mut addrs = vec![];
            for x in addresses {
                if let Some(value) = x {
                    addrs.push(value);
                }
            }
            match addrs.len() {
                0 => None,
                _ => Some(addrs.join(",")),
            }
        };

        let mut transaction_overview = CardanoOverview::default();

        transaction_overview.set_header_card(match method {
            CardanoMethod::Transfer => CardanoHeaderCard::Transfer(
                CardanoOverviewTransferCard::new(total_output_amount.clone()),
            ),
            CardanoMethod::Stake => CardanoHeaderCard::Stake(CardanoOverviewStakeCard::new(
                total_output_amount.clone(),
                deposit.clone(),
            )),
            CardanoMethod::Withdrawal => {
                CardanoHeaderCard::Withdrawal(CardanoOverviewWithdrawalCard::new(
                    reward_amount,
                    deposit_reclaim.clone(),
                    reward_account,
                ))
            }
        });

        let total_input_amount = {
            let _v = parsed_inputs.iter().fold(0u64, |acc, cur| match cur.value {
                Some(v) => acc + v,
                None => acc,
            });
            normalize_coin(_v)
        };

        let transaction_detail = CardanoDetail::new(
            total_input_amount,
            total_output_amount,
            deposit_reclaim.clone(),
            deposit.clone(),
            None,
        );

        let hash = blake2b_256(tx.body().to_bytes().as_ref());

        Ok(Self {
            overview: transaction_overview,
            detail: transaction_detail,
            from: from_list_detail,
            to: to_list_detail,
            fee: fee.clone(),
            network: network.clone(),
            method: method.to_string(),
            sign_data: hex::encode(hash),
        })
    }

    fn judge_network_id(tx: &Transaction) -> u8 {
        match tx.body().network_id() {
            None => match tx.body().outputs().get(0).address().network_id() {
                Ok(id) => id,
                Err(_) => 1,
            },
            Some(id) => match id.kind() {
                NetworkIdKind::Mainnet => 1,
                NetworkIdKind::Testnet => 0,
            },
        }
    }

    fn get_from_list(inputs: Vec<ParsedCardanoInput>) -> HashMap<String, CardanoFrom> {
        let mut map = HashMap::<String, CardanoFrom>::new();
        for input in inputs {
            let address = match input.address {
                Some(v) => v,
                None => "Unknown address".to_string(),
            };
            match map.get(&address) {
                Some(existing) => {
                    let mut new_from = existing.clone();
                    if let Some(_v) = input.value {
                        new_from.value += _v;
                        new_from.amount = normalize_coin(new_from.value);
                    }
                    map.insert(address, new_from);
                }
                None => {
                    let cardano_from = CardanoFrom {
                        address: address.clone(),
                        value: match input.value {
                            Some(v) => v,
                            None => 0,
                        },
                        amount: match input.value {
                            Some(v) => normalize_coin(v),
                            None => "Unknown amount".to_string(),
                        },
                        path: input.path,
                    };
                    map.insert(address, cardano_from);
                }
            }
        }
        map
    }

    fn get_to_list(outputs: Vec<ParsedCardanoOutput>) -> HashMap<String, CardanoTo> {
        let mut map = HashMap::<String, CardanoTo>::new();
        for output in outputs {
            let address = output.address;
            match map.get(&address) {
                Some(existing) => {
                    let mut to = existing.clone();
                    to.value = to.value + output.value;
                    to.amount = normalize_coin(to.value);
                    if let Some(assets) = output.assets {
                        for x in assets {
                            match to.assets.get(&x.id) {
                                Some(asset) => {
                                    let mut new_asset = asset.clone();
                                    new_asset.value = new_asset.value + x.value;
                                    new_asset.amount = normalize_value(new_asset.value);
                                    to.assets.insert(new_asset.id.clone(), new_asset);
                                }
                                None => {
                                    to.assets.insert(x.id.clone(), x);
                                }
                            }
                        }
                    }
                    to.assets_text = match to.assets.len() {
                        0 => None,
                        x => Some(format!("{} more assets", x)),
                    };
                    map.insert(address, to);
                }
                None => {
                    let mut assets_map = HashMap::<String, ParsedCardanoMultiAsset>::new();

                    if let Some(assets) = output.assets {
                        for x in assets {
                            assets_map.insert(x.id.clone(), x);
                        }
                    }

                    let to = CardanoTo {
                        address: address.clone(),
                        amount: normalize_value(output.value),
                        value: output.value,
                        assets: assets_map.clone(),
                        assets_text: match assets_map.len() {
                            0 => None,
                            x => Some(format!("{} more assets", x)),
                        },
                    };
                    map.insert(address, to);
                }
            }
        }
        map
    }

    fn detect_method(tx: &Transaction) -> CardanoMethod {
        if let Some(withdrawals) = tx.body().withdrawals() {
            if withdrawals.len() > 0 {
                return CardanoMethod::Withdrawal;
            }
        }
        if let Some(certs) = tx.body().certs() {
            if certs.len() > 0 {
                let len = certs.len();
                for i in 0..len {
                    if let CertificateKind::StakeDeregistration = certs.get(i).kind() {
                        return CardanoMethod::Withdrawal;
                    }
                }
                return CardanoMethod::Stake;
            }
        }
        return CardanoMethod::Transfer;
    }

    pub fn verify(tx: Transaction, context: ParseContext, network_id: u8) -> R<()> {
        let parsed_inputs = Self::parse_inputs(&tx, &context, network_id)?;
        if parsed_inputs
            .iter()
            .filter(|v| v.address.is_some())
            .collect::<Vec<&ParsedCardanoInput>>()
            .is_empty()
        {
            return Err(CardanoError::InvalidTransaction(
                "no input related to this account".to_string(),
            ));
        }
        Self::parse_certs(&tx)?;
        Ok(())
    }

    fn parse_inputs(tx: &Transaction, context: &ParseContext, network_id: u8) -> R<Vec<ParsedCardanoInput>> {
        let inputs_len = tx.body().inputs().len();
        let mut parsed_inputs = vec![];
        for i in 0..inputs_len {
            let input = tx.body().inputs().get(i);
            let hash = input.transaction_id().to_hex();
            let index = input.index();
            let m = context.utxos.iter().find(|v| {
                hash.eq_ignore_ascii_case(&hex::encode(&v.transaction_hash)) & index.eq(&v.index)
            });
            match m {
                //known utxo
                Some(utxo) => {
                    let mut iter = utxo.path.into_iter();
                    let _root = match iter.next() {
                        Some(Hardened { index: 1852 }) => {
                            Ok(1852u32)
                        }
                        _ => {
                            Err(CardanoError::DerivationError(
                                "invalid derivation path".to_string(),
                            ))
                        }
                    }?;
                    let _coin_type = match iter.next() {
                        Some(Hardened { index: 1815 }) => {
                            Ok(1815u32)
                        }
                        _ => {
                            Err(CardanoError::DerivationError(
                                "invalid derivation path".to_string(),
                            ))
                        }
                    }?;
                    let _account = match iter.next() {
                        Some(Hardened { index: _i }) => {
                            Ok(_i)
                        }
                        _ => {
                            Err(CardanoError::DerivationError(
                                "invalid derivation path".to_string(),
                            ))
                        }
                    }?;
                    let change = match iter.next() {
                        Some(Normal { index: _i }) => {
                            Ok(_i)
                        }
                        _ => {
                            Err(CardanoError::DerivationError(
                                "invalid derivation path".to_string(),
                            ))
                        }
                    }?;
                    let index = match iter.next() {
                        Some(Normal { index: _i }) => {
                            Ok(_i)
                        }
                        _ => {
                            Err(CardanoError::DerivationError(
                                "invalid derivation path".to_string(),
                            ))
                        }
                    }?;

                    let mut address = derive_address(
                        context.get_cardano_xpub(),
                        change.clone(),
                        index.clone(),
                        AddressType::Base,
                        network_id,
                    )?;

                    // maybe Enterprise address
                    if !address.eq(&utxo.address) {
                        address = derive_address(
                            context.get_cardano_xpub(),
                            change.clone(),
                            index.clone(),
                            AddressType::Enterprise,
                            network_id,
                        )?;
                        if !address.eq(&utxo.address) {
                            return Err(CardanoError::InvalidTransaction(
                                "invalid address".to_string(),
                            ));
                        }
                    }

                    parsed_inputs.push(ParsedCardanoInput {
                        transaction_hash: utxo.transaction_hash.clone(),
                        index: utxo.index,
                        value: Some(utxo.value),
                        address: Some(address),
                        path: None,
                        is_mine: utxo.master_fingerprint.eq(&context.master_fingerprint),
                    })
                }
                None => parsed_inputs.push(ParsedCardanoInput {
                    transaction_hash: input.transaction_id().to_bytes(),
                    index: input.index(),
                    value: None,
                    address: None,
                    path: None,
                    is_mine: false,
                }),
            }
        }
        Ok(parsed_inputs)
    }

    fn parse_outputs(tx: &Transaction) -> R<Vec<ParsedCardanoOutput>> {
        let outputs_len = tx.body().outputs().len();
        let mut parsed_outputs = vec![];
        for i in 0..outputs_len {
            let output = tx.body().outputs().get(i);
            let parsed_output = ParsedCardanoOutput {
                address: output
                    .address()
                    .to_bech32(None)
                    .map_err(|e| CardanoError::AddressEncodingError(e.to_string()))?,
                amount: normalize_coin(from_bignum(&output.amount().coin())),
                value: from_bignum(&output.amount().coin()),
                assets: output.amount().multiasset().map(|v| {
                    let mut parsed_multi_assets = vec![];
                    let len = v.keys().len();
                    for _j in 0..len {
                        let policy_id = v.keys().get(_j);
                        let multi_assets = v.get(&policy_id);
                        if let Some(assets) = multi_assets {
                            let names = assets.keys();
                            let names_len = names.len();
                            for k in 0..names_len {
                                let name = names.get(k);
                                let value = assets.get(&name);
                                if let Some(asset_value) = value {
                                    let multi_asset = ParsedCardanoMultiAsset {
                                        policy_id: policy_id.clone().to_bytes(),
                                        name: name.to_bytes(),
                                        amount: normalize_value(from_bignum(&asset_value)),
                                        value: from_bignum(&asset_value),
                                        id: format!(
                                            "{}#{}",
                                            hex::encode(policy_id.to_bytes()),
                                            hex::encode(name.to_bytes())
                                        ),
                                    };
                                    parsed_multi_assets.push(multi_asset)
                                }
                            }
                        }
                    }
                    parsed_multi_assets
                }),
            };
            parsed_outputs.push(parsed_output);
        }
        Ok(parsed_outputs)
    }

    fn parse_certs(tx: &Transaction) -> R<Vec<CardanoCertAction>> {
        let mut parsed_certs = vec![];
        let network_id = match tx
            .body()
            .network_id()
            .unwrap_or(NetworkId::mainnet())
            .kind()
        {
            NetworkIdKind::Mainnet => 0,
            NetworkIdKind::Testnet => 1,
        };
        if let Some(certs) = tx.body().certs() {
            let len = certs.len();
            for i in 0..len {
                let cert = certs.get(i);
                let result = match cert.kind() {
                    CertificateKind::StakeRegistration => cert.as_stake_registration().map(|v| {
                        Ok(CardanoCertAction::Registration(Registration {
                            stake_key: RewardAddress::new(network_id, &v.stake_credential()),
                        }))
                    }),
                    CertificateKind::StakeDeregistration => {
                        cert.as_stake_deregistration().map(|v| {
                            Ok(CardanoCertAction::Deregistration(Deregistration {
                                stake_key: RewardAddress::new(network_id, &v.stake_credential()),
                            }))
                        })
                    }
                    CertificateKind::StakeDelegation => cert.as_stake_delegation().map(|v| {
                        Ok(CardanoCertAction::Delegation(Delegation {
                            pool: v.pool_keyhash().to_hex(),
                            stake_key: RewardAddress::new(network_id, &v.stake_credential()),
                        }))
                    }),
                    CertificateKind::PoolRegistration => {
                        return Err(CardanoError::UnsupportedTransaction(
                            "PoolRegistration".to_string(),
                        ));
                    }
                    CertificateKind::PoolRetirement => {
                        return Err(CardanoError::UnsupportedTransaction(
                            "PoolRetirement".to_string(),
                        ));
                    }
                    CertificateKind::GenesisKeyDelegation => {
                        return Err(CardanoError::UnsupportedTransaction(
                            "GenesisKeyDelegation".to_string(),
                        ));
                    }
                    CertificateKind::MoveInstantaneousRewardsCert => {
                        return Err(CardanoError::UnsupportedTransaction(
                            "MoveInstantaneousRewardsCert".to_string(),
                        ));
                    }
                };
                if let Some(parsed_cert) = result {
                    parsed_certs.push(parsed_cert);
                }
            }
        }
        parsed_certs.into_iter().collect()
    }

    fn parse_stake_actions(
        tx: &Transaction,
        certs: &Vec<CardanoCertAction>,
    ) -> R<Vec<CardanoDetailStakeAction>> {
        let mut parsed_actions = vec![];

        let mut registrations: Vec<Registration> = vec![];
        certs.iter().for_each(|v| match v {
            CardanoCertAction::Registration(x) => registrations.push(x.clone()),
            _ => {}
        });

        let mut deregistrations = vec![];
        certs.iter().for_each(|v| {
            if let CardanoCertAction::Deregistration(x) = v {
                deregistrations.push(x.clone());
            }
        });

        let mut delegations = vec![];
        certs.iter().for_each(|v| match v {
            CardanoCertAction::Delegation(x) => delegations.push(x.clone()),
            _ => {}
        });

        if let Some(_withdrawals) = tx.body().withdrawals() {
            let len = _withdrawals.keys().len();
            for i in 0..len {
                let key = _withdrawals.keys().get(i);
                let value = match _withdrawals.get(&key) {
                    None => 0,
                    Some(_v) => from_bignum(&_v),
                };

                let mut cardano_withdrawal = CardanoWithdrawal::new(
                    Some(
                        key.to_address()
                            .to_bech32(None)
                            .map_err(|e| CardanoError::InvalidTransaction(e.to_string()))?,
                    ),
                    Some(normalize_coin(value)),
                    value,
                    None,
                );

                if let Some((index, _)) = deregistrations
                    .iter()
                    .find_position(|v| v.stake_key.eq(&key))
                {
                    deregistrations.remove(index);
                    //they are the same actually.
                    cardano_withdrawal
                        .set_deregistration_stake_key(cardano_withdrawal.get_reward_address());
                }
                parsed_actions.push(CardanoDetailStakeAction::Withdrawal(cardano_withdrawal))
            }
        }

        for v in deregistrations {
            let withdraw = CardanoWithdrawal::new(
                None,
                None,
                0,
                Some(
                    v.stake_key
                        .to_address()
                        .to_bech32(None)
                        .map_err(|e| CardanoError::InvalidTransaction(e.to_string()))?,
                ),
            );
            parsed_actions.push(CardanoDetailStakeAction::Withdrawal(withdraw))
        }

        for v in delegations {
            let key = v.stake_key;
            let delegation = CardanoStake::new(
                key.to_address()
                    .to_bech32(None)
                    .map_err(|e| CardanoError::InvalidTransaction(e.to_string()))?,
                v.pool,
            );
            if let Some((index, _)) = registrations.iter().find_position(|v| v.stake_key.eq(&key)) {
                registrations.remove(index);
            }
            parsed_actions.push(CardanoDetailStakeAction::Stake(delegation))
        }

        for v in registrations {
            let registration = CardanoRegistration::new(
                v.stake_key
                    .to_address()
                    .to_bech32(None)
                    .map_err(|e| CardanoError::InvalidTransaction(e.to_string()))?,
            );
            parsed_actions.push(CardanoDetailStakeAction::Registration(registration))
        }

        Ok(parsed_actions)
    }
}

static DIVIDER: f64 = 1_000_000f64;

fn normalize_coin(value: u64) -> String {
    format!("{} ADA", (value as f64).div(DIVIDER))
}

fn normalize_value(value: u64) -> String {
    format!("{}", (value as f64).div(DIVIDER))
}

'''
'''--- blockchains/cardano/src/traits.rs ---
use serde_json::Value;

pub trait ToJSON {
    fn to_json(&self) -> Value;
}
'''
'''--- blockchains/cardano/src/transaction.rs ---
use crate::errors::{CardanoError, R};
use crate::structs::{CardanoSignarure, ParseContext, ParsedCardanoTx};
use cardano_serialization_lib;
use cardano_serialization_lib::crypto::{Ed25519Signature, PublicKey, Vkey, Vkeywitness};
use crate::traits::ToJSON;

pub fn parse_tx(tx: Vec<u8>, context: ParseContext) -> R<ParsedCardanoTx> {
    let cardano_tx = cardano_serialization_lib::Transaction::from_bytes(tx)?;
    ParsedCardanoTx::from_cardano_tx(cardano_tx, context)
}

pub fn parse_tx_to_json(tx: Vec<u8>, context: ParseContext) -> R<String> {
    let cardano_tx = parse_tx(tx, context)?;
    Ok(cardano_tx.to_json().to_string())
}

pub fn compose_witness_set(signatures: Vec<CardanoSignarure>) -> R<String> {
    let mut witness_set = cardano_serialization_lib::TransactionWitnessSet::new();
    let mut vkeys = cardano_serialization_lib::crypto::Vkeywitnesses::new();
    for signature in signatures {
        let v = Vkeywitness::new(
            &Vkey::new(
                &PublicKey::from_bytes(&signature.get_public_key())
                    .map_err(|e| CardanoError::SigningFailed(e.to_string()))?,
            ),

            &Ed25519Signature::from_bytes(signature.get_signature())
                .map_err(|e| CardanoError::SigningFailed(e.to_string()))?,
        );
        vkeys.add(&v);
    }

    witness_set.set_vkeys(&vkeys);
    Ok(hex::encode(witness_set.to_bytes()))
}
'''
'''--- blockchains/cosmos/Cargo.toml ---
[package]
name = "rcc-cosmos"
version = "0.1.0"
edition = "2021"
license = "Apache-2.0"
description = "A transaction parser for cosmos."
# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
rcc-trait-chain = "0.1.0"
hex = "0.4.3"
thiserror = "1.0.31"
cosmos-sdk-proto = "0.15.0"
serde_json = "1.0"
serde = "1.0.139"
base64 = "0.13.1"
'''
'''--- blockchains/cosmos/src/error.rs ---
use thiserror::Error;

#[derive(Error, Debug)]
pub enum CosmosError {
    #[error("cosmos transaction parse failed, reason: `{0}`")]
    ParseFailed(String),
    #[error("cosmos transaction serialize failed, reason: `{0}`")]
    SerializeFailed(String),
}

pub type Result<T> = std::result::Result<T, CosmosError>;
'''
'''--- blockchains/cosmos/src/lib.rs ---
use rcc_trait_chain::Chain;
use crate::error::{CosmosError, Result};
use crate::proto_wrapper::sign_doc::SignDoc;

mod proto_wrapper;
mod error;

pub struct Cosmos;

impl Chain<CosmosError> for Cosmos {
    fn parse(data: &Vec<u8>) -> Result<String> {
        SignDoc::parse(data)
            .map(|doc| serde_json::to_string(&doc)
                .map_err(|err| CosmosError::SerializeFailed(err.to_string())))?
    }
}

#[cfg(test)]
mod tests {
    use hex::FromHex;
    use rcc_trait_chain::Chain;
    use crate::Cosmos;

    #[test]
    fn test() {
        let hex_data = "0a8f010a8c010a1c2f636f736d6f732e62616e6b2e763162657461312e4d736753656e64126c0a2d636f736d6f7331786573766b723664306a39366a357a64637735666d717861766a767576717832796779376d70122d636f736d6f7331786573766b723664306a39366a357a64637735666d717861766a767576717832796779376d701a0c0a057374616b65120331303012580a500a460a1f2f636f736d6f732e63727970746f2e736563703235366b312e5075624b657912230a21035bc6eee695a089c273b690d7123c84cf6dbcb91e613c8b60b79422a1ee68490612040a0208011803120410c09a0c1a04746573742001";
        let buf_message = Vec::from_hex(hex_data).unwrap();
        let json = r#"{"body":{"msgs":[{"type":"/cosmos.bank.v1beta1.MsgSend","value":{"amount":[{"amount":"100","denom":"stake"}],"from_address":"cosmos1xesvkr6d0j96j5zdcw5fmqxavjvuvqx2ygy7mp","to_address":"cosmos1xesvkr6d0j96j5zdcw5fmqxavjvuvqx2ygy7mp"}}],"memo":"","timeout_height":0},"auth_info":{"signer_infos":[{"public_key":{"Single":{"type_url":"/cosmos.crypto.secp256k1.PubKey","key":"A1vG7uaVoInCc7aQ1xI8hM9tvLkeYTyLYLeUIqHuaEkG"}},"mode_info":{"Single":{"mode":"SIGN_MODE_DIRECT"}},"sequence":3}],"fee":{"amount":[],"gas":200000,"payer":"","granter":""}},"chain_id":"test","account_number":1}"#;
        let parse_result = Cosmos::parse(&buf_message).expect("TODO: panic message");
        assert_eq!(json, parse_result);

    }
}
'''
'''--- blockchains/cosmos/src/proto_wrapper/auth_info.rs ---
use crate::proto_wrapper::fee::Fee;
use crate::proto_wrapper::signer_info::SignerInfo;
use serde::Serialize;
use cosmos_sdk_proto as proto;
use crate::CosmosError;

#[derive(Serialize)]
pub struct AuthInfo {
    /// signer_infos defines the signing modes for the required signers. The number
    /// and order of elements must match the required signers from TxBody's
    /// messages. The first element is the primary signer and the one which pays
    /// the fee.
    pub signer_infos: Vec<SignerInfo>,
    /// Fee is the fee and gas limit for the transaction. The first signer is the
    /// primary signer and the one which pays the fee. The fee can be calculated
    /// based on the cost of evaluating the body and doing signature verification
    /// of the signers. This can be estimated via simulation.
    pub fee: Option<Fee>,
}

impl TryFrom<proto::cosmos::tx::v1beta1::AuthInfo> for AuthInfo {
    type Error = CosmosError;

    fn try_from(proto: proto::cosmos::tx::v1beta1::AuthInfo) -> Result<AuthInfo, CosmosError> {
        let mut signer_info_vec: Vec<SignerInfo> = Vec::new();
        for signer_info in proto.signer_infos.iter() {
            let signer_info_inner = SignerInfo::try_from(signer_info)?;
            signer_info_vec.push(signer_info_inner)
        }
        let fee_inner: Option<Fee> = match &proto.fee {
            Some(fee) => {
                Some(Fee::try_from(fee)?)
            }
            None => { None }
        };

        Ok(AuthInfo {
            signer_infos: signer_info_vec,
            fee: fee_inner,
        })
    }
}
'''
'''--- blockchains/cosmos/src/proto_wrapper/body.rs ---
use cosmos_sdk_proto::Any;
use cosmos_sdk_proto::cosmos::tx::v1beta1::TxBody;
use crate::CosmosError;
use crate::proto_wrapper::msg::msg_serialize::Msg;
use serde::Serialize;
use crate::proto_wrapper::msg::common::map_messages;

#[derive(Serialize)]
pub struct Body {
    #[serde(rename = "msgs")]
    pub messages: Vec<Box<dyn Msg>>,

    /// `memo` is any arbitrary memo to be added to the transaction.
    pub memo: String,

    /// `timeout` is the block height after which this transaction will not
    /// be processed by the chain
    pub timeout_height: u64,

    /// `extension_options` are arbitrary options that can be added by chains
    /// when the default options are not sufficient. If any of these are present
    /// and can't be handled, the transaction will be rejected
    #[serde(skip_serializing)]
    pub extension_options: Vec<Any>,

    /// `extension_options` are arbitrary options that can be added by chains
    /// when the default options are not sufficient. If any of these are present
    /// and can't be handled, they will be ignored
    #[serde(skip_serializing)]
    pub non_critical_extension_options: Vec<Any>,
}

impl TryFrom<TxBody> for Body {
    type Error = CosmosError;

    fn try_from(proto: TxBody) -> Result<Body, CosmosError> {
        let message_vec = map_messages(&proto.messages)?;
        Ok(Body {
            messages: message_vec,
            memo: proto.memo,
            timeout_height: proto.timeout_height,
            extension_options: proto.extension_options,
            non_critical_extension_options: proto.non_critical_extension_options,
        })
    }
}

'''
'''--- blockchains/cosmos/src/proto_wrapper/fee.rs ---
use crate::proto_wrapper::msg::base::Coin;
use cosmos_sdk_proto as proto;
use serde::Serialize;
use crate::CosmosError;

#[derive(Serialize)]
pub struct Fee {
    /// amount is the amount of coins to be paid as a fee
    pub amount: Vec<Coin>,
    /// gas_limit is the maximum gas that can be used in transaction processing
    /// before an out of gas error occurs
    #[serde(rename = "gas")]
    pub gas_limit: u64,
    /// if unset, the first signer is responsible for paying the fees. If set, the specified account must pay the fees.
    /// the payer must be a tx signer (and thus have signed this field in AuthInfo).
    /// setting this field does *not* change the ordering of required signers for the transaction.
    pub payer: String,
    /// if set, the fee payer (either the first signer or the value of the payer field) requests that a fee grant be used
    /// to pay fees instead of the fee payer's own balance. If an appropriate fee grant does not exist or the chain does
    /// not support fee grants, this will fail
    pub granter: String,
}

impl TryFrom<&proto::cosmos::tx::v1beta1::Fee> for Fee {
    type Error = CosmosError;

    fn try_from(proto: &proto::cosmos::tx::v1beta1::Fee) -> Result<Fee, CosmosError> {
        Ok(Fee {
            amount: proto
                .amount
                .iter()
                .map(TryFrom::try_from)
                .collect::<Result<_, _>>()?,
            gas_limit: proto.gas_limit,
            payer: proto.payer.clone(),
            granter: proto.granter.clone(),
        })
    }
}

'''
'''--- blockchains/cosmos/src/proto_wrapper/mod.rs ---
pub mod sign_doc;
pub mod body;
mod fee;
mod mode_info;
mod signer_info;
mod auth_info;
mod serde_helper;
mod msg;
'''
'''--- blockchains/cosmos/src/proto_wrapper/mode_info.rs ---
use serde::Serialize;
use cosmos_sdk_proto as proto;
use crate::CosmosError;

#[derive(Serialize)]
pub enum ModeInfo {
    /// single represents a single signer
    Single(Single),
    /// multi represents a nested multisig signer
    Multi(Multi),
}

impl TryFrom<&proto::cosmos::tx::v1beta1::ModeInfo> for ModeInfo {
    type Error = CosmosError;

    fn try_from(proto: &proto::cosmos::tx::v1beta1::ModeInfo) -> Result<ModeInfo, CosmosError> {
        match &proto.sum {
            Some(proto::cosmos::tx::v1beta1::mode_info::Sum::Single(single)) => {
                Ok(ModeInfo::Single(single.into()))
            }
            Some(proto::cosmos::tx::v1beta1::mode_info::Sum::Multi(multi)) => {
                Ok(ModeInfo::Multi(multi.try_into()?))
            }
            None => Err(CosmosError::ParseFailed("option mode_info sum is None".to_string())),
        }
    }
}

impl TryFrom<proto::cosmos::tx::v1beta1::ModeInfo> for ModeInfo {
    type Error = CosmosError;

    fn try_from(proto: proto::cosmos::tx::v1beta1::ModeInfo) -> Result<ModeInfo, CosmosError> {
        match &proto.sum {
            Some(proto::cosmos::tx::v1beta1::mode_info::Sum::Single(single)) => {
                Ok(ModeInfo::Single(single.into()))
            }
            Some(proto::cosmos::tx::v1beta1::mode_info::Sum::Multi(multi)) => {
                Ok(ModeInfo::Multi(multi.try_into()?))
            }
            None => Err(CosmosError::ParseFailed("option mode_info sum is None".to_string())),
        }
    }
}

#[derive(Serialize)]
pub struct CompactBitArray {
    pub extra_bits_stored: u32,
    pub elems: Vec<u8>,
}

impl From<&proto::cosmos::crypto::multisig::v1beta1::CompactBitArray> for CompactBitArray {
    fn from(proto: &proto::cosmos::crypto::multisig::v1beta1::CompactBitArray) -> CompactBitArray {
        CompactBitArray {
            extra_bits_stored: proto.extra_bits_stored,
            elems: proto.elems.to_vec(),
        }
    }
}

#[derive(Serialize)]
pub struct Multi {
    /// bitarray specifies which keys within the multisig are signing
    pub bitarray: Option<CompactBitArray>,
    /// mode_infos is the corresponding modes of the signers of the multisig
    /// which could include nested multisig public keys
    pub mode_infos: Vec<ModeInfo>,
}

#[derive(Serialize)]
pub struct Single {
    pub mode: String,
}

impl From<&proto::cosmos::tx::v1beta1::mode_info::Single> for Single {
    fn from(proto: &proto::cosmos::tx::v1beta1::mode_info::Single) -> Single {
        Single { mode: proto.mode().as_str_name().to_string() }
    }
}

impl TryFrom<&proto::cosmos::tx::v1beta1::mode_info::Multi> for Multi {
    type Error = CosmosError;

    fn try_from(proto: &proto::cosmos::tx::v1beta1::mode_info::Multi) -> Result<Multi, CosmosError> {
        let bitarray = match &proto.bitarray {
            Some(value) => {
                Some(value.into())
            }
            None => {
                None
            }
        };

        Ok(Multi {
            bitarray,
            mode_infos: proto
                .mode_infos.clone()
                .into_iter()
                .map(TryInto::try_into)
                .collect::<Result<_, _>>()?,
        })
    }
}
'''
'''--- blockchains/cosmos/src/proto_wrapper/msg/base.rs ---
use serde::Serialize;
use crate::CosmosError;
use cosmos_sdk_proto as proto;

#[derive(Serialize)]
pub struct Coin {
    pub denom: String,
    pub amount: String,
}

impl TryFrom<&proto::cosmos::base::v1beta1::Coin> for Coin {
    type Error = CosmosError;

    fn try_from(proto: &proto::cosmos::base::v1beta1::Coin) -> Result<Coin, CosmosError> {
        Ok(Coin {
            denom: proto.denom.clone(),
            amount: proto.amount.clone(),
        })
    }
}

#[derive(Serialize)]
pub struct Any {
    /// A URL/resource name that uniquely identifies the type of the serialized
    /// protocol buffer message. This string must contain at least
    /// one "/" character. The last segment of the URL's path must represent
    /// the fully qualified name of the type (as in
    /// `path/google.protobuf.Duration`). The name should be in a canonical form
    /// (e.g., leading "." is not accepted).
    ///
    /// In practice, teams usually precompile into the binary all types that they
    /// expect it to use in the context of Any. However, for URLs which use the
    /// scheme `http`, `https`, or no scheme, one can optionally set up a type
    /// server that maps type URLs to message definitions as follows:
    ///
    /// * If no scheme is provided, `https` is assumed.
    /// * An HTTP GET on the URL must yield a \\[google.protobuf.Type\]\[\\]
    ///   value in binary format, or produce an error.
    /// * Applications are allowed to cache lookup results based on the
    ///   URL, or have them precompiled into a binary to avoid any
    ///   lookup. Therefore, binary compatibility needs to be preserved
    ///   on changes to types. (Use versioned type names to manage
    ///   breaking changes.)
    ///
    /// Note: this functionality is not currently available in the official
    /// protobuf release, and it is not used for type URLs beginning with
    /// type.googleapis.com.
    ///
    /// Schemes other than `http`, `https` (or the empty scheme) might be
    /// used with implementation specific semantics.
    pub type_url: String,
    /// Must be a valid serialized protocol buffer of the above specified type.
    pub value: Vec<u8>,
}
'''
'''--- blockchains/cosmos/src/proto_wrapper/msg/common.rs ---
use crate::proto_wrapper::msg::msg_serialize::Msg;
use crate::proto_wrapper::msg::msg::{MsgSend as MsgSendWrapper,
                                     MsgDelegate as MsgDelegateWrapper, MsgUndelegate as MsgUnDelegateWrapper, MsgVote as MsgVoteWrapper, MsgTransfer as MsgTransferWrapper, MsgWithdrawDelegatorReward as MsgWithdrawDelegatorRewardWrapper, MsgBeginRedelegate as MsgBeginRedelegateWrapper, MsgMultiSend as MsgMultiSendWrapper,
                                     MsgUpdateClient as MsgUpdateClientWrapper, MsgExec as MsgExecWrapper, NotSupportMessage};
use cosmos_sdk_proto as proto;
use cosmos_sdk_proto::Any;
use cosmos_sdk_proto::traits::{MessageExt, Message};

use crate::CosmosError;

pub fn map_messages(messages: &Vec<Any>) -> Result<Vec<Box<dyn Msg>>, CosmosError> {
    let mut message_vec: Vec<Box<dyn Msg>> = Vec::new();
    for message in messages.iter() {
        match message.type_url.as_str() {
            MsgSendWrapper::TYPE_URL => {
                let unpacked: proto::cosmos::bank::v1beta1::MsgSend = MessageExt::from_any(message).map_err(|e| CosmosError::ParseFailed(format!("proto MsgSend deserialize failed {}", e.to_string())))?;
                let msg_send = MsgSendWrapper::try_from(&unpacked).map_err(|e| CosmosError::ParseFailed(format!("proto MsgSend deserialize failed {}", e.to_string())))?;
                message_vec.push(Box::new(msg_send));
            }
            MsgDelegateWrapper::TYPE_URL => {
                let unpacked: proto::cosmos::staking::v1beta1::MsgDelegate = MessageExt::from_any(message).map_err(|e| CosmosError::ParseFailed(format!("proto MsgDelegate deserialize failed {}", e.to_string())))?;
                let msg_delegate = MsgDelegateWrapper::try_from(&unpacked).map_err(|e| CosmosError::ParseFailed(format!("proto MsgDelegate deserialize failed {}", e.to_string())))?;
                message_vec.push(Box::new(msg_delegate));
            }
            MsgUnDelegateWrapper::TYPE_URL => {
                let unpacked: proto::cosmos::staking::v1beta1::MsgUndelegate = MessageExt::from_any(message).map_err(|e| CosmosError::ParseFailed(format!("proto MsgUndelegate deserialize failed {}", e.to_string())))?;
                let msg_undelegate = MsgUnDelegateWrapper::try_from(&unpacked).map_err(|e| CosmosError::ParseFailed(format!("proto MsgUndelegate deserialize failed {}", e.to_string())))?;
                message_vec.push(Box::new(msg_undelegate));
            }
            MsgTransferWrapper::TYPE_URL => {
                let unpacked: proto::ibc::applications::transfer::v1::MsgTransfer = MessageExt::from_any(message).map_err(|e| CosmosError::ParseFailed(format!("proto MsgTransfer deserialize failed {}", e.to_string())))?;
                let msg_transfer = MsgTransferWrapper::try_from(&unpacked).map_err(|e| CosmosError::ParseFailed(format!("proto MsgTransfer deserialize failed {}", e.to_string())))?;
                message_vec.push(Box::new(msg_transfer));
            }
            MsgVoteWrapper::TYPE_URL => {
                let unpacked: proto::cosmos::gov::v1beta1::MsgVote = proto::cosmos::gov::v1beta1::MsgVote::decode(&*message.value).map_err(|e| CosmosError::ParseFailed(format!("proto MsgVote deserialize failed {}", e.to_string())))?;
                let msg_vote = MsgVoteWrapper::try_from(&unpacked).map_err(|e| CosmosError::ParseFailed(format!("proto MsgVote deserialize failed {}", e.to_string())))?;
                message_vec.push(Box::new(msg_vote));
            }
            MsgWithdrawDelegatorRewardWrapper::TYPE_URL => {
                let unpacked: proto::cosmos::distribution::v1beta1::MsgWithdrawDelegatorReward = MessageExt::from_any(message).map_err(|e| CosmosError::ParseFailed(format!("proto MsgTransfer deserialize failed {}", e.to_string())))?;
                let msg_withdraw_reward = MsgWithdrawDelegatorRewardWrapper::try_from(&unpacked).map_err(|e| CosmosError::ParseFailed(format!("proto MsgTransfer deserialize failed {}", e.to_string())))?;
                message_vec.push(Box::new(msg_withdraw_reward));
            }
            MsgBeginRedelegateWrapper::TYPE_URL => {
                let unpacked: proto::cosmos::staking::v1beta1::MsgBeginRedelegate = MessageExt::from_any(message).map_err(|e| CosmosError::ParseFailed(format!("proto MsgTransfer deserialize failed {}", e.to_string())))?;
                let msg_redelegate = MsgBeginRedelegateWrapper::try_from(&unpacked).map_err(|e| CosmosError::ParseFailed(format!("proto MsgTransfer deserialize failed {}", e.to_string())))?;
                message_vec.push(Box::new(msg_redelegate));
            }
            MsgMultiSendWrapper::TYPE_URL => {
                let unpacked: proto::cosmos::bank::v1beta1::MsgMultiSend = MessageExt::from_any(message).map_err(|e| CosmosError::ParseFailed(format!("proto MsgMultiSend deserialize failed {}", e.to_string())))?;
                let msg_multi_send = MsgMultiSendWrapper::try_from(&unpacked).map_err(|e| CosmosError::ParseFailed(format!("proto MsgMultiSend deserialize failed {}", e.to_string())))?;
                message_vec.push(Box::new(msg_multi_send));
            }
            MsgUpdateClientWrapper::TYPE_URL => {
                let unpacked: proto::ibc::core::client::v1::MsgUpdateClient = proto::ibc::core::client::v1::MsgUpdateClient::decode(&*message.value).map_err(|e| CosmosError::ParseFailed(format!("proto MsgMultiSend deserialize failed {}", e.to_string())))?;
                let msg_update_client = MsgUpdateClientWrapper::try_from(&unpacked).map_err(|e| CosmosError::ParseFailed(format!("proto MsgMultiSend deserialize failed {}", e.to_string())))?;
                message_vec.push(Box::new(msg_update_client));
            }
            MsgExecWrapper::TYPE_URL => {
                let unpacked: proto::cosmos::authz::v1beta1::MsgExec = proto::cosmos::authz::v1beta1::MsgExec::decode(&*message.value).map_err(|e| CosmosError::ParseFailed(format!("proto MsgMultiSend deserialize failed {}", e.to_string())))?;
                let msg_exec = MsgExecWrapper::try_from(&unpacked).map_err(|e| CosmosError::ParseFailed(format!("proto MsgMultiSend deserialize failed {}", e.to_string())))?;
                message_vec.push(Box::new(msg_exec));
            }
            other => {
                message_vec.push(Box::new(NotSupportMessage { type_url: other.to_string(), err: "the type is not support!".to_string() }));
            }
        }
    }
    Ok(message_vec)
}
'''
'''--- blockchains/cosmos/src/proto_wrapper/msg/mod.rs ---
pub mod msg;
pub mod msg_serialize;
pub mod common;
pub mod base;

'''
'''--- blockchains/cosmos/src/proto_wrapper/msg/msg.rs ---
use crate::proto_wrapper::msg::base::Coin;
use serde::Serialize;
use serde_json::{json, Value};
use crate::{CosmosError};
use crate::proto_wrapper::msg::msg_serialize::{Msg, SerializeJson};
use cosmos_sdk_proto as proto;
use crate::proto_wrapper::msg::common::map_messages;

#[derive(Serialize)]
pub struct NotSupportMessage {
    pub type_url: String,
    pub err: String,
}

impl SerializeJson for NotSupportMessage {
    fn to_json(&self) -> Result<Value, CosmosError> {
        let value = serde_json::to_value(&self).map_err(|err| CosmosError::SerializeFailed(format!("NotSupportMessage serialize failed {}", err.to_string())))?;
        let msg = json!({
            "type": Value::String(Self::TYPE_URL.to_string()),
            "value": value,
            });
        Ok(msg)
    }
}

impl NotSupportMessage {
    pub const TYPE_URL: &'static str = "/NotSupportMessage";
}

impl Msg for NotSupportMessage {}

#[derive(Serialize)]
pub struct MsgSend {
    pub from_address: String,
    pub to_address: String,
    pub amount: Vec<Coin>,
}

impl MsgSend {
    pub const TYPE_URL: &'static str = "/cosmos.bank.v1beta1.MsgSend";
}

impl TryFrom<&proto::cosmos::bank::v1beta1::MsgSend> for MsgSend {
    type Error = CosmosError;

    fn try_from(proto: &proto::cosmos::bank::v1beta1::MsgSend) -> Result<MsgSend, CosmosError> {
        Ok(MsgSend {
            from_address: proto.from_address.clone(),
            to_address: proto.to_address.clone(),
            amount: proto
                .amount
                .iter()
                .map(TryFrom::try_from)
                .collect::<Result<_, _>>()?,
        })
    }
}

impl SerializeJson for MsgSend {
    fn to_json(&self) -> Result<Value, CosmosError> {
        let value = serde_json::to_value(&self).map_err(|err| CosmosError::SerializeFailed(format!("MsgSend serialize failed {}", err.to_string())))?;
        let msg = json!({
            "type": Value::String(Self::TYPE_URL.to_string()),
            "value": value,
            });
        Ok(msg)
    }
}

impl Msg for MsgSend {}

#[derive(Serialize)]
pub struct MsgDelegate {
    pub delegator_address: String,
    pub validator_address: String,
    pub amount: Option<Coin>,
}

impl MsgDelegate {
    pub const TYPE_URL: &'static str = "/cosmos.staking.v1beta1.MsgDelegate";
}

impl TryFrom<&proto::cosmos::staking::v1beta1::MsgDelegate> for MsgDelegate {
    type Error = CosmosError;

    fn try_from(proto: &proto::cosmos::staking::v1beta1::MsgDelegate) -> Result<MsgDelegate, CosmosError> {
        let amount: Option<Coin>;
        match &proto.amount {
            Some(coin) => {
                amount = Some(coin.try_into()?)
            }
            None => { amount = None }
        }

        Ok(MsgDelegate {
            delegator_address: proto.delegator_address.clone(),
            validator_address: proto.validator_address.clone(),
            amount,
        })
    }
}

impl SerializeJson for MsgDelegate {
    fn to_json(&self) -> Result<Value, CosmosError> {
        let value = serde_json::to_value(&self).map_err(|err| CosmosError::SerializeFailed(format!("MsgDelegate serialize failed {}", err.to_string())))?;
        let msg = json!({
            "type": Value::String(Self::TYPE_URL.to_string()),
            "value": value,
            });
        Ok(msg)
    }
}

impl Msg for MsgDelegate {}

#[derive(Serialize)]
pub struct MsgUndelegate {
    pub delegator_address: String,
    pub validator_address: String,
    pub amount: Option<Coin>,
}

impl MsgUndelegate {
    pub const TYPE_URL: &'static str = "/cosmos.staking.v1beta1.MsgUndelegate";
}

impl TryFrom<&proto::cosmos::staking::v1beta1::MsgUndelegate> for MsgUndelegate {
    type Error = CosmosError;

    fn try_from(proto: &proto::cosmos::staking::v1beta1::MsgUndelegate) -> Result<MsgUndelegate, CosmosError> {
        let amount: Option<Coin>;
        match &proto.amount {
            Some(coin) => {
                amount = Some(coin.try_into()?)
            }
            None => { amount = None }
        }

        Ok(MsgUndelegate {
            delegator_address: proto.delegator_address.clone(),
            validator_address: proto.validator_address.clone(),
            amount,
        })
    }
}

impl SerializeJson for MsgUndelegate {
    fn to_json(&self) -> Result<Value, CosmosError> {
        let value = serde_json::to_value(&self).map_err(|err| CosmosError::SerializeFailed(format!("MsgUndelegate serialize failed {}", err.to_string())))?;
        let msg = json!({
            "type": Value::String(Self::TYPE_URL.to_string()),
            "value": value,
            });
        Ok(msg)
    }
}

impl Msg for MsgUndelegate {}

#[derive(Serialize)]
pub struct MsgVote {
    pub proposal_id: u64,
    pub voter: String,
    pub option: i32,
}

impl MsgVote {
    pub const TYPE_URL: &'static str = "/cosmos.gov.v1beta1.MsgVote";
}

impl TryFrom<&proto::cosmos::gov::v1beta1::MsgVote> for MsgVote {
    type Error = CosmosError;

    fn try_from(proto: &proto::cosmos::gov::v1beta1::MsgVote) -> Result<MsgVote, CosmosError> {
        //let option: proto::cosmos::gov::v1beta1::VoteOption = unsafe { ::std::mem::transmute(proto.option) };

        Ok(MsgVote {
            proposal_id: proto.proposal_id,
            voter: proto.voter.clone(),
            option: proto.option,
        })
    }
}

impl SerializeJson for MsgVote {
    fn to_json(&self) -> Result<Value, CosmosError> {
        let value = serde_json::to_value(&self).map_err(|err| CosmosError::SerializeFailed(format!("MsgVote serialize failed {}", err.to_string())))?;
        let msg = json!({
            "type": Value::String(Self::TYPE_URL.to_string()),
            "value": value,
            });
        Ok(msg)
    }
}

impl Msg for MsgVote {}

#[derive(Serialize)]
pub struct Height {
    /// the revision that the client is currently on
    pub revision_number: u64,
    /// the height within the given revision
    pub revision_height: u64,
}

#[derive(Serialize)]
pub struct MsgTransfer {
    /// the port on which the packet will be sent
    pub source_port: String,
    /// the channel by which the packet will be sent
    pub source_channel: String,
    /// the tokens to be transferred
    pub token: Option<Coin>,
    /// the sender address
    pub sender: String,
    /// the recipient address on the destination chain
    pub receiver: String,
    /// Timeout height relative to the current block height.
    /// The timeout is disabled when set to 0.
    pub timeout_height: Option<Height>,
    /// Timeout timestamp in absolute nanoseconds since unix epoch.
    /// The timeout is disabled when set to 0.
    pub timeout_timestamp: u64,
}

impl MsgTransfer {
    pub const TYPE_URL: &'static str = "/ibc.applications.transfer.v1.MsgTransfer";
}

impl TryFrom<&proto::ibc::applications::transfer::v1::MsgTransfer> for MsgTransfer {
    type Error = CosmosError;

    fn try_from(proto: &proto::ibc::applications::transfer::v1::MsgTransfer) -> Result<MsgTransfer, CosmosError> {
        let token: Option<Coin> = match &proto.token {
            Some(coin) => {
                Some(coin.try_into()?)
            }
            None => { None }
        };

        let timeout_height: Option<Height> = match &proto.timeout_height {
            Some(height) => {
                Some(Height {
                    revision_number: height.revision_number,
                    revision_height: height.revision_height,
                })
            }
            None => { None }
        };

        Ok(MsgTransfer {
            source_port: proto.source_port.clone(),
            source_channel: proto.source_channel.clone(),
            token,
            sender: proto.sender.clone(),
            receiver: proto.receiver.clone(),
            timeout_height,
            timeout_timestamp: proto.timeout_timestamp,
        })
    }
}

impl SerializeJson for MsgTransfer {
    fn to_json(&self) -> Result<Value, CosmosError> {
        let value = serde_json::to_value(&self).map_err(|err| CosmosError::SerializeFailed(format!("MsgTransfer serialize failed {}", err.to_string())))?;
        let msg = json!({
            "type": Value::String(Self::TYPE_URL.to_string()),
            "value": value,
            });
        Ok(msg)
    }
}

impl Msg for MsgTransfer {}

#[derive(Serialize)]
pub struct MsgWithdrawDelegatorReward {
    pub delegator_address: String,
    pub validator_address: String,
}

impl MsgWithdrawDelegatorReward {
    pub const TYPE_URL: &'static str = "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward";
}

impl TryFrom<&proto::cosmos::distribution::v1beta1::MsgWithdrawDelegatorReward> for MsgWithdrawDelegatorReward {
    type Error = CosmosError;

    fn try_from(proto: &proto::cosmos::distribution::v1beta1::MsgWithdrawDelegatorReward) -> Result<MsgWithdrawDelegatorReward, CosmosError> {
        Ok(MsgWithdrawDelegatorReward {
            delegator_address: proto.delegator_address.clone(),
            validator_address: proto.validator_address.clone(),
        })
    }
}

impl SerializeJson for MsgWithdrawDelegatorReward {
    fn to_json(&self) -> Result<Value, CosmosError> {
        let value = serde_json::to_value(&self).map_err(|err| CosmosError::SerializeFailed(format!("MsgWithdrawDelegatorReward serialize failed {}", err.to_string())))?;
        let msg = json!({
            "type": Value::String(Self::TYPE_URL.to_string()),
            "value": value,
            });
        Ok(msg)
    }
}

impl Msg for MsgWithdrawDelegatorReward {}

#[derive(Serialize)]
pub struct MsgUpdateClient {
    pub client_id: String,
    pub signer: String,
}

impl MsgUpdateClient {
    pub const TYPE_URL: &'static str = "/ibc.core.client.v1.MsgUpdateClient";
}

impl TryFrom<&proto::ibc::core::client::v1::MsgUpdateClient> for MsgUpdateClient {
    type Error = CosmosError;

    fn try_from(proto: &proto::ibc::core::client::v1::MsgUpdateClient) -> Result<MsgUpdateClient, CosmosError> {
        Ok(MsgUpdateClient {
            client_id: proto.client_id.clone(),
            signer: proto.signer.clone(),
        })
    }
}

impl SerializeJson for MsgUpdateClient {
    fn to_json(&self) -> Result<Value, CosmosError> {
        let value = serde_json::to_value(&self).map_err(|err| CosmosError::SerializeFailed(format!("MsgUpdateClient serialize failed {}", err.to_string())))?;
        let msg = json!({
            "type": Value::String(Self::TYPE_URL.to_string()),
            "value": value,
            });
        Ok(msg)
    }
}

impl Msg for MsgUpdateClient {}

#[derive(Serialize)]
pub struct MsgBeginRedelegate {
    pub delegator_address: String,
    pub validator_src_address: String,
    pub validator_dst_address: String,
    pub amount: Option<Coin>,
}

impl MsgBeginRedelegate {
    pub const TYPE_URL: &'static str = "/cosmos.staking.v1beta1.MsgBeginRedelegate";
}

impl TryFrom<&proto::cosmos::staking::v1beta1::MsgBeginRedelegate> for MsgBeginRedelegate {
    type Error = CosmosError;

    fn try_from(proto: &proto::cosmos::staking::v1beta1::MsgBeginRedelegate) -> Result<MsgBeginRedelegate, CosmosError> {
        let amount: Option<Coin> = match &proto.amount {
            Some(coin) => {
                Some(coin.try_into()?)
            }
            None => { None }
        };
        Ok(MsgBeginRedelegate {
            delegator_address: proto.delegator_address.clone(),
            validator_src_address: proto.validator_src_address.clone(),
            validator_dst_address: proto.validator_dst_address.clone(),
            amount,
        })
    }
}

impl SerializeJson for MsgBeginRedelegate {
    fn to_json(&self) -> Result<Value, CosmosError> {
        let value = serde_json::to_value(&self).map_err(|err| CosmosError::SerializeFailed(format!("MsgBeginRedelegate serialize failed {}", err.to_string())))?;
        let msg = json!({
            "type": Value::String(Self::TYPE_URL.to_string()),
            "value": value,
            });
        Ok(msg)
    }
}

impl Msg for MsgBeginRedelegate {}

#[derive(Serialize)]
pub struct MsgExec {
    pub grantee: String,
    /// Authorization Msg requests to execute. Each msg must implement Authorization interface
    /// The x/authz will try to find a grant matching (msg.signers\[0\], grantee, MsgTypeURL(msg))
    /// triple and validate it.
    pub msgs: Vec<Box<dyn Msg>>,
}

impl MsgExec {
    pub const TYPE_URL: &'static str = "/cosmos.authz.v1beta1.MsgExec";
}

impl TryFrom<&proto::cosmos::authz::v1beta1::MsgExec> for MsgExec {
    type Error = CosmosError;

    fn try_from(proto: &proto::cosmos::authz::v1beta1::MsgExec) -> Result<MsgExec, CosmosError> {
        let msgs = map_messages(&proto.msgs)?;
        Ok(MsgExec {
            grantee: proto.grantee.clone(),
            msgs,
        })
    }
}

impl SerializeJson for MsgExec {
    fn to_json(&self) -> Result<Value, CosmosError> {
        let value = serde_json::to_value(&self).map_err(|err| CosmosError::SerializeFailed(format!("MsgExec serialize failed {}", err.to_string())))?;
        let msg = json!({
            "type": Value::String(Self::TYPE_URL.to_string()),
            "value": value,
            });
        Ok(msg)
    }
}

impl Msg for MsgExec {}

#[derive(Serialize)]
pub struct Input {
    pub address: String,
    pub coins: Vec<Coin>,
}

impl TryFrom<&proto::cosmos::bank::v1beta1::Input> for Input {
    type Error = CosmosError;

    fn try_from(proto: &proto::cosmos::bank::v1beta1::Input) -> Result<Input, CosmosError> {
        Ok(Input {
            address: proto.address.clone(),
            coins: proto.coins.iter().map(TryFrom::try_from).collect::<Result<_, _>>()?,
        })
    }
}

#[derive(Serialize)]
pub struct Output {
    pub address: String,
    pub coins: Vec<Coin>,
}

impl TryFrom<&proto::cosmos::bank::v1beta1::Output> for Output {
    type Error = CosmosError;

    fn try_from(proto: &proto::cosmos::bank::v1beta1::Output) -> Result<Output, CosmosError> {
        Ok(Output {
            address: proto.address.clone(),
            coins: proto.coins.iter().map(TryFrom::try_from).collect::<Result<_, _>>()?,
        })
    }
}

#[derive(Serialize)]
pub struct MsgMultiSend {
    pub inputs: Vec<Input>,
    pub outputs: Vec<Output>,
}

impl MsgMultiSend {
    pub const TYPE_URL: &'static str = "/cosmos.bank.v1beta1.MsgMultiSend";
}

impl TryFrom<&proto::cosmos::bank::v1beta1::MsgMultiSend> for MsgMultiSend {
    type Error = CosmosError;

    fn try_from(proto: &proto::cosmos::bank::v1beta1::MsgMultiSend) -> Result<MsgMultiSend, CosmosError> {
        Ok(MsgMultiSend {
            inputs: proto.inputs.iter().map(TryFrom::try_from).collect::<Result<_, _>>()?,
            outputs: proto.outputs.iter().map(TryFrom::try_from).collect::<Result<_, _>>()?,
        })
    }
}

impl SerializeJson for MsgMultiSend {
    fn to_json(&self) -> Result<Value, CosmosError> {
        let value = serde_json::to_value(&self).map_err(|err| CosmosError::SerializeFailed(format!("MsgMultiSend serialize failed {}", err.to_string())))?;
        let msg = json!({
            "type": Value::String(Self::TYPE_URL.to_string()),
            "value": value,
            });
        Ok(msg)
    }
}

impl Msg for MsgMultiSend {}
'''
'''--- blockchains/cosmos/src/proto_wrapper/msg/msg_serialize.rs ---
use serde::{Serialize, Serializer};
use serde::ser::Error;
use serde_json::Value;
use crate::Result as CosmosResult;

pub trait SerializeJson {
    fn to_json(&self) -> CosmosResult<Value>;
}

pub trait Msg: SerializeJson {}

impl Serialize for dyn Msg {
    fn serialize<S>(&self, serializer: S) -> Result<<S as Serializer>::Ok, <S as Serializer>::Error>
        where
            S: Serializer,
    {
        let json_value = self.to_json().map_err(|err| Error::custom(err.to_string()))?;
        json_value.serialize(serializer)
    }
}

'''
'''--- blockchains/cosmos/src/proto_wrapper/serde_helper.rs ---
use base64;

pub fn from_base64(s: &str) -> Result<Vec<u8>, Box<dyn std::error::Error + Send + Sync>> {
    base64::decode(s).map_err(|err| err.into())
}

pub fn to_base64<T: AsRef<[u8]>>(input: T) -> String {
    base64::encode(&input)
}

pub mod base64_format {
    use serde::de;
    use serde::{Deserialize, Deserializer, Serializer};

    use super::{from_base64, to_base64};

    pub fn serialize<S, T>(data: T, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: Serializer,
            T: AsRef<[u8]>,
    {
        serializer.serialize_str(&to_base64(data))
    }

    pub fn deserialize<'de, D, T>(deserializer: D) -> Result<T, D::Error>
        where
            D: Deserializer<'de>,
            T: From<Vec<u8>>,
    {
        let s = String::deserialize(deserializer)?;
        from_base64(&s).map_err(|err| de::Error::custom(err.to_string())).map(Into::into)
    }
}
'''
'''--- blockchains/cosmos/src/proto_wrapper/sign_doc.rs ---
use cosmos_sdk_proto as proto;
use cosmos_sdk_proto::prost::bytes::Bytes;
use cosmos_sdk_proto::traits::Message;
use serde::Serialize;
use crate::{CosmosError, Result};
use crate::proto_wrapper::auth_info::AuthInfo;
use crate::proto_wrapper::body::Body;

#[derive(Serialize)]
pub struct SignDoc {
    pub body: Body,
    pub auth_info: AuthInfo,
    pub chain_id: String,
    pub account_number: u64,
}

impl SignDoc {
    fn from(proto: proto::cosmos::tx::v1beta1::SignDoc) -> Result<SignDoc> {
        let tx_body: proto::cosmos::tx::v1beta1::TxBody = Message::decode(Bytes::from(proto.body_bytes)).map_err(|e| CosmosError::ParseFailed(format!("proto TxBody deserialize failed {}", e.to_string())))?;
        let body = Body::try_from(tx_body)?;

        let auth_info : proto::cosmos::tx::v1beta1::AuthInfo = Message::decode(Bytes::from(proto.auth_info_bytes)).map_err(|e| CosmosError::ParseFailed(format!("proto AuthInfo deserialize failed {}", e.to_string())))?;
        let auth_info = AuthInfo::try_from(auth_info)?;

        Ok(SignDoc {
            body,
            auth_info,
            chain_id: proto.chain_id,
            account_number: proto.account_number,
        })
    }

    pub fn parse(data: &Vec<u8>) -> Result<SignDoc> {
        let proto_sign_doc: proto::cosmos::tx::v1beta1::SignDoc = Message::decode(Bytes::from(data.clone())).map_err(|e| CosmosError::ParseFailed(format!("proto SignDoc deserialize failed {}", e.to_string())))?;
        SignDoc::from(proto_sign_doc)
    }
}

'''
'''--- blockchains/cosmos/src/proto_wrapper/signer_info.rs ---
use crate::proto_wrapper::msg::base::Any;
use crate::proto_wrapper::mode_info::ModeInfo;
use serde::Serialize;
use cosmos_sdk_proto as proto;
use crate::CosmosError;
use cosmos_sdk_proto::traits::Message;
use crate::proto_wrapper::serde_helper::base64_format;

#[derive(Serialize)]
pub struct SignerInfo {
    /// public_key is the public key of the signer. It is optional for accounts
    /// that already exist in state. If unset, the verifier can use the required \
    /// signer address for this position and lookup the public key.
    pub public_key: Option<SignerPublicKey>,
    /// mode_info describes the signing mode of the signer and is a nested
    /// structure to support nested multisig pubkey's
    pub mode_info: Option<ModeInfo>,
    /// sequence is the sequence of the account, which describes the
    /// number of committed transactions signed by a given address. It is used to
    /// prevent replay attacks.
    pub sequence: u64,
}

#[derive(Serialize)]
pub enum SignerPublicKey {
    /// Single singer.
    Single(PublicKey),

    /// Other key types beyond the ones provided above.
    Any(Any),
}

impl From<PublicKey> for SignerPublicKey {
    fn from(pk: PublicKey) -> SignerPublicKey {
        Self::Single(pk)
    }
}

impl TryFrom<Any> for SignerPublicKey {
    type Error = CosmosError;

    fn try_from(any: Any) -> Result<SignerPublicKey, CosmosError> {
        match any.type_url.as_str() {
            PublicKey::ED25519_TYPE_URL | PublicKey::SECP256K1_TYPE_URL => {
                PublicKey::try_from(&any).map(Into::into)
            }
            _ => Ok(Self::Any(any)),
        }
    }
}

#[derive(Serialize)]
pub struct PublicKey {
    pub type_url: String,

    #[serde(with = "base64_format")]
    pub key: Vec<u8>,
}

impl PublicKey {
    /// Protobuf [`Any`] type URL for Ed25519 public keys
    pub const ED25519_TYPE_URL: &'static str = "/cosmos.crypto.ed25519.PubKey";

    /// Protobuf [`Any`] type URL for secp256k1 public keys
    pub const SECP256K1_TYPE_URL: &'static str = "/cosmos.crypto.secp256k1.PubKey";
}

impl TryFrom<&Any> for PublicKey {
    type Error = CosmosError;

    fn try_from(any: &Any) -> Result<PublicKey, CosmosError> {
        match any.type_url.as_str() {
            Self::ED25519_TYPE_URL => {
                let pub_key: proto::cosmos::crypto::ed25519::PubKey = Message::decode(&*any.value).map_err(|err| CosmosError::ParseFailed(format!("proto ed25519::PubKey deserialize failed {}", err.to_string())))?;
                Ok(PublicKey {
                    type_url: Self::ED25519_TYPE_URL.to_string(),
                    key: pub_key.key,
                })
            }
            Self::SECP256K1_TYPE_URL => {
                let pub_key: proto::cosmos::crypto::secp256k1::PubKey = Message::decode(&*any.value).map_err(|err| CosmosError::ParseFailed(format!("proto secp256k1::PubKey deserialize failed {}", err.to_string())))?;
                Ok(PublicKey {
                    type_url: Self::SECP256K1_TYPE_URL.to_string(),
                    key: pub_key.key,
                })
            }
            other => Err(CosmosError::ParseFailed(format!("{} is not supported!!!", other.to_string()))),
        }
    }
}

impl TryFrom<&proto::cosmos::tx::v1beta1::SignerInfo> for SignerInfo {
    type Error = CosmosError;

    fn try_from(proto: &proto::cosmos::tx::v1beta1::SignerInfo) -> Result<SignerInfo, CosmosError> {
        let public_key = match &proto.public_key {
            Some(value) => {
                let any = Any { type_url: value.type_url.clone(), value: value.value.clone() };
                Some(any.try_into()?)
            }
            None => {
                None
            }
        };
        let mode_info = match &proto.mode_info {
            Some(value) => {
                Some(value.try_into()?)
            }
            None => { None }
        };

        Ok(SignerInfo {
            public_key,
            mode_info,
            sequence: proto.sequence,
        })
    }
}
'''
'''--- blockchains/near/Cargo.toml ---
[package]
name = "rcc-near"
version = "0.1.1"
edition = "2021"
license = "Apache-2.0"
description = "A transaction parser for near."
# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
rcc-trait-chain = "0.1.0"
hex = "0.4.3"
serde_json = "1.0"
serde = "1.0.139"
thiserror = "1.0.31"
derive_more = "0.99.3"
primitive-types = { version = "0.10", default-features = false }
strum = "0.24"
borsh = { version = "0.9", features = ["rc"] }
near-primitives-core = "0.14.0"
near-crypto = "0.14.0"
'''
'''--- blockchains/near/src/error.rs ---
use thiserror::Error;

#[derive(Error, Debug)]
pub enum NearError {
    #[error("near transaction parse failed, reason: `{0}`")]
    ParseFailed(String),
    #[error("near transaction serialize failed, reason: `{0}`")]
    SerializeFailed(String),
}

pub type Result<T> = std::result::Result<T, NearError>;
'''
'''--- blockchains/near/src/lib.rs ---
use rcc_trait_chain::Chain;
use crate::error::NearError;

mod error;
mod parser;
mod primitives;
use crate::parser::Parser;

pub struct Near;

impl Chain<NearError> for Near {
    fn parse(data: &Vec<u8>) -> Result<String, NearError> {
        let tx = Parser::parse(data)?;
        tx.get_result()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use hex::FromHex;

    #[test]
    fn test() {
        let json = r#"{"formatted_json":{"actions":[{"Transfer":{"deposit":"200000000000000000000000"}}],"block_hash":"8L6Auh4ioZrR22vTxykBVNhEcojeDfmUoTr4tYb1QToR","hash":"ff978ce08fb7a53c3b4f91a08aa8cd10be43d972b38faa7da092b0ae92553929","nonce":93166702000009,"public_key":"ed25519:6yPGj6N27Wfaa3rDzPyWEEwyTy2ZrFa9L8N22m1hTi58","receiver_id":"demo0617.testnet","signer_id":"58bc2459804d2ed87641fbde40b0d96341cbf0313b7df4bc4f60fa2f42c602c3"},"raw_json":{"actions":[{"Transfer":{"deposit":"200000000000000000000000"}}],"block_hash":"8L6Auh4ioZrR22vTxykBVNhEcojeDfmUoTr4tYb1QToR","hash":"ff978ce08fb7a53c3b4f91a08aa8cd10be43d972b38faa7da092b0ae92553929","nonce":93166702000009,"public_key":"ed25519:6yPGj6N27Wfaa3rDzPyWEEwyTy2ZrFa9L8N22m1hTi58","receiver_id":"demo0617.testnet","signer_id":"58bc2459804d2ed87641fbde40b0d96341cbf0313b7df4bc4f60fa2f42c602c3"}}"#;
        let data = "40000000353862633234353938303464326564383736343166626465343062306439363334316362663033313362376466346263346636306661326634326336303263330058bc2459804d2ed87641fbde40b0d96341cbf0313b7df4bc4f60fa2f42c602c389772d10bc5400001000000064656d6f303631372e746573746e65746ce5b0c72ea21d29c9cf8cde859d2ddd466a70e1f8f1069742876e259fb157440100000003000000ed95c28f055a2a000000000000";
        let mut buf_message = Vec::from_hex(data).unwrap();
        assert_eq!(json, Near::parse(&mut buf_message).unwrap_or_else(|e| e.to_string()));
    }
}

'''
'''--- blockchains/near/src/parser.rs ---
use crate::error::Result;
use crate::primitives::PrimitivesTxParser;

pub type NearTx = Box<dyn Tx>;

pub trait Tx {
    fn get_result(&self) -> Result<String>;
}

pub struct Parser;

impl Parser {
    pub fn parse(data: &Vec<u8>) -> Result<NearTx> {
        PrimitivesTxParser::deserialize(data)
    }
}

'''
'''--- blockchains/near/src/primitives.rs ---
mod transaction;
mod types;

use borsh::BorshDeserialize;
use serde_json::{json, Value};
use crate::error::{Result, NearError};
use crate::parser::{NearTx, Tx};
use hex::ToHex;

pub struct PrimitivesTxParser;

impl PrimitivesTxParser {
    pub fn deserialize(data: &Vec<u8>) -> Result<NearTx> {
        match transaction::Transaction::try_from_slice(data) {
            Ok(tx) => {
                Ok(Box::new(PrimitivesTx::new(tx)))
            }
            Err(err) => Err(NearError::ParseFailed(format!("borsh deserialize failed {}", err.to_string())))
        }
    }
}

pub struct PrimitivesTx {
    tx: transaction::Transaction,
}

impl Tx for PrimitivesTx {
    fn get_result(&self) -> Result<String> {
        let raw_json = self.get_raw_json()?;
        let formatted_json = self.get_formatted_json()?;
        let result = json!({
            "raw_json" : raw_json,
            "formatted_json": formatted_json
        });
        Ok(result.to_string())
    }
}

impl PrimitivesTx {
    pub fn new(tx: transaction::Transaction) -> Self {
        PrimitivesTx { tx }
    }

    fn get_raw_json(&self) -> Result<Value> {
        self.to_json_str()
    }

    fn get_formatted_json(&self) -> Result<Value> {
        self.to_json_str()
    }

    fn to_json_str(&self) -> Result<Value> {
        let json_str: String;
        match serde_json::to_string(&self.tx) {
            Ok(data) => json_str = data,
            Err(e) =>
                return Err(NearError::SerializeFailed(format!("to json failed {}", e.to_string())))
        }

        let mut json_value: Value;
        match serde_json::from_str::<Value>(&json_str) {
            Ok(value) => json_value = value,
            Err(e) => return Err(NearError::SerializeFailed(format!("to json failed {}", e.to_string())))
        }

        if let Some(map) = json_value.as_object_mut() {
            map.insert("hash".to_string(), Value::String(self.get_hash()));
            Ok(json_value)
        } else {
            Err(NearError::SerializeFailed(format!("to json failed reason: as_object_mut failed")))
        }
    }

    fn get_hash(&self) -> String {
        let (hash, _) = self.tx.get_hash_and_size();
        Vec::encode_hex(&hash.0.to_vec())
    }
}

'''
'''--- blockchains/near/src/primitives/transaction.rs ---
use std::borrow::Borrow;
use std::fmt;
use std::hash::{Hash, Hasher};

use borsh::{BorshDeserialize, BorshSerialize};
use serde::{Deserialize, Serialize};

use near_crypto::{PublicKey, Signature};

use near_primitives_core::account::AccessKey;
use near_primitives_core::hash::{hash, CryptoHash};
use near_primitives_core::logging;
use near_primitives_core::serialize::{base64_format, u128_dec_format_compatible};
use near_primitives_core::types::{AccountId, Balance, Gas, Nonce};

use near_primitives_core::profile::ProfileData;

#[cfg_attr(feature = "deepsize_feature", derive(deepsize::DeepSizeOf))]
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, PartialEq, Eq, Debug, Clone)]
pub struct Transaction {
    /// An account on which behalf transaction is signed
    pub signer_id: AccountId,
    /// A public key of the access key which was used to sign an account.
    /// Access key holds permissions for calling certain kinds of actions.
    pub public_key: PublicKey,
    /// Nonce is used to determine order of transaction in the pool.
    /// It increments for a combination of `signer_id` and `public_key`
    pub nonce: Nonce,
    /// Receiver account for this transaction
    pub receiver_id: AccountId,
    /// The hash of the block in the blockchain on top of which the given transaction is valid
    pub block_hash: CryptoHash,
    /// A list of actions to be applied
    pub actions: Vec<Action>,
}

impl Transaction {
    /// Computes a hash of the transaction for signing and size of serialized transaction
    pub fn get_hash_and_size(&self) -> (CryptoHash, u64) {
        let bytes = self.try_to_vec().expect("Failed to deserialize");
        (hash(&bytes), bytes.len() as u64)
    }
}

#[cfg_attr(feature = "deepsize_feature", derive(deepsize::DeepSizeOf))]
#[derive(
    BorshSerialize,
    BorshDeserialize,
    Serialize,
    Deserialize,
    PartialEq,
    Eq,
    Debug,
    Clone,
    strum::AsRefStr,
)]
pub enum Action {
    /// Create an (sub)account using a transaction `receiver_id` as an ID for
    /// a new account ID must pass validation rules described here
    /// <http://nomicon.io/Primitives/Account.html>.
    CreateAccount(CreateAccountAction),
    /// Sets a Wasm code to a receiver_id
    DeployContract(DeployContractAction),
    FunctionCall(FunctionCallAction),
    Transfer(TransferAction),
    Stake(StakeAction),
    AddKey(AddKeyAction),
    DeleteKey(DeleteKeyAction),
    DeleteAccount(DeleteAccountAction),
}

// impl Action {
//     pub fn get_prepaid_gas(&self) -> Gas {
//         match self {
//             Action::FunctionCall(a) => a.gas,
//             _ => 0,
//         }
//     }
//     pub fn get_deposit_balance(&self) -> Balance {
//         match self {
//             Action::FunctionCall(a) => a.deposit,
//             Action::Transfer(a) => a.deposit,
//             _ => 0,
//         }
//     }
// }

/// Create account action
#[cfg_attr(feature = "deepsize_feature", derive(deepsize::DeepSizeOf))]
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, PartialEq, Eq, Clone, Debug)]
pub struct CreateAccountAction {}

impl From<CreateAccountAction> for Action {
    fn from(create_account_action: CreateAccountAction) -> Self {
        Self::CreateAccount(create_account_action)
    }
}

/// Deploy contract action
#[cfg_attr(feature = "deepsize_feature", derive(deepsize::DeepSizeOf))]
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, PartialEq, Eq, Clone)]
pub struct DeployContractAction {
    /// WebAssembly binary
    #[serde(with = "base64_format")]
    pub code: Vec<u8>,
}

impl From<DeployContractAction> for Action {
    fn from(deploy_contract_action: DeployContractAction) -> Self {
        Self::DeployContract(deploy_contract_action)
    }
}

impl fmt::Debug for DeployContractAction {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("DeployContractAction")
            .field("code", &format_args!("{}", logging::pretty_utf8(&self.code)))
            .finish()
    }
}

#[cfg_attr(feature = "deepsize_feature", derive(deepsize::DeepSizeOf))]
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, PartialEq, Eq, Clone)]
pub struct FunctionCallAction {
    pub method_name: String,
    #[serde(with = "base64_format")]
    pub args: Vec<u8>,
    pub gas: Gas,
    #[serde(with = "u128_dec_format_compatible")]
    pub deposit: Balance,
}

impl From<FunctionCallAction> for Action {
    fn from(function_call_action: FunctionCallAction) -> Self {
        Self::FunctionCall(function_call_action)
    }
}

impl fmt::Debug for FunctionCallAction {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("FunctionCallAction")
            .field("method_name", &format_args!("{}", &self.method_name))
            .field("args", &format_args!("{}", logging::pretty_utf8(&self.args)))
            .field("gas", &format_args!("{}", &self.gas))
            .field("deposit", &format_args!("{}", &self.deposit))
            .finish()
    }
}

#[cfg_attr(feature = "deepsize_feature", derive(deepsize::DeepSizeOf))]
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, PartialEq, Eq, Clone, Debug)]
pub struct TransferAction {
    #[serde(with = "u128_dec_format_compatible")]
    pub deposit: Balance,
}

impl From<TransferAction> for Action {
    fn from(transfer_action: TransferAction) -> Self {
        Self::Transfer(transfer_action)
    }
}

/// An action which stakes singer_id tokens and setup's validator public key
#[cfg_attr(feature = "deepsize_feature", derive(deepsize::DeepSizeOf))]
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, PartialEq, Eq, Clone, Debug)]
pub struct StakeAction {
    /// Amount of tokens to stake.
    #[serde(with = "u128_dec_format_compatible")]
    pub stake: Balance,
    /// Validator key which will be used to sign transactions on behalf of singer_id
    pub public_key: PublicKey,
}

impl From<StakeAction> for Action {
    fn from(stake_action: StakeAction) -> Self {
        Self::Stake(stake_action)
    }
}

#[cfg_attr(feature = "deepsize_feature", derive(deepsize::DeepSizeOf))]
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, PartialEq, Eq, Clone, Debug)]
pub struct AddKeyAction {
    /// A public key which will be associated with an access_key
    pub public_key: PublicKey,
    /// An access key with the permission
    pub access_key: AccessKey,
}

impl From<AddKeyAction> for Action {
    fn from(add_key_action: AddKeyAction) -> Self {
        Self::AddKey(add_key_action)
    }
}

#[cfg_attr(feature = "deepsize_feature", derive(deepsize::DeepSizeOf))]
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, PartialEq, Eq, Clone, Debug)]
pub struct DeleteKeyAction {
    /// A public key associated with the access_key to be deleted.
    pub public_key: PublicKey,
}

impl From<DeleteKeyAction> for Action {
    fn from(delete_key_action: DeleteKeyAction) -> Self {
        Self::DeleteKey(delete_key_action)
    }
}

#[cfg_attr(feature = "deepsize_feature", derive(deepsize::DeepSizeOf))]
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, PartialEq, Eq, Clone, Debug)]
pub struct DeleteAccountAction {
    pub beneficiary_id: AccountId,
}

impl From<DeleteAccountAction> for Action {
    fn from(delete_account_action: DeleteAccountAction) -> Self {
        Self::DeleteAccount(delete_account_action)
    }
}

#[cfg_attr(feature = "deepsize_feature", derive(deepsize::DeepSizeOf))]
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Eq, Debug, Clone)]
#[borsh_init(init)]
pub struct SignedTransaction {
    pub transaction: Transaction,
    pub signature: Signature,
    #[borsh_skip]
    hash: CryptoHash,
    #[borsh_skip]
    size: u64,
}

impl SignedTransaction {
    pub fn new(signature: Signature, transaction: Transaction) -> Self {
        let mut signed_tx =
            Self { signature, transaction, hash: CryptoHash::default(), size: u64::default() };
        signed_tx.init();
        signed_tx
    }

    pub fn init(&mut self) {
        let (hash, size) = self.transaction.get_hash_and_size();
        self.hash = hash;
        self.size = size;
    }

    pub fn get_hash(&self) -> CryptoHash {
        self.hash
    }

    // pub fn get_size(&self) -> u64 {
    //     self.size
    // }
}

impl Hash for SignedTransaction {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.hash.hash(state)
    }
}

impl PartialEq for SignedTransaction {
    fn eq(&self, other: &SignedTransaction) -> bool {
        self.hash == other.hash && self.signature == other.signature
    }
}

impl Borrow<CryptoHash> for SignedTransaction {
    fn borrow(&self) -> &CryptoHash {
        &self.hash
    }
}

#[derive(BorshSerialize, BorshDeserialize, PartialEq, Clone, Eq, Debug)]
pub enum ExecutionMetadata {
    // V1: Empty Metadata
    V1,

    // V2: With ProfileData
    V2(ProfileData),
}

impl Default for ExecutionMetadata {
    fn default() -> Self {
        ExecutionMetadata::V1
    }
}

// pub fn verify_transaction_signature(
//     transaction: &SignedTransaction,
//     public_keys: &[PublicKey],
// ) -> bool {
//     let hash = transaction.get_hash();
//     let hash = hash.as_ref();
//     public_keys.iter().any(|key| transaction.signature.verify(hash, key))
// }

#[cfg(test)]
mod tests {
    use borsh::BorshDeserialize;

    use near_crypto::{KeyType, Signature};

    use near_primitives_core::account::{AccessKeyPermission, FunctionCallPermission};
    use near_primitives_core::serialize::to_base;
    //use crate::primitives::test_utils;

    use super::*;

    // #[test]
    // fn test_verify_transaction() {
    //     let signer = InMemorySigner::from_random("test".parse().unwrap(), KeyType::ED25519);
    //     let transaction = Transaction {
    //         signer_id: "test".parse().unwrap(),
    //         public_key: signer.public_key(),
    //         nonce: 0,
    //         receiver_id: "test".parse().unwrap(),
    //         block_hash: Default::default(),
    //         actions: vec![],
    //     }
    //     .sign(&signer);
    //     let wrong_public_key = PublicKey::from_seed(KeyType::ED25519, "wrong");
    //     let valid_keys = vec![signer.public_key(), wrong_public_key.clone()];
    //     assert!(verify_transaction_signature(&transaction, &valid_keys));
    //
    //     let invalid_keys = vec![wrong_public_key];
    //     assert!(!verify_transaction_signature(&transaction, &invalid_keys));
    //
    //     let bytes = transaction.try_to_vec().unwrap();
    //     let decoded_tx = SignedTransaction::try_from_slice(&bytes).unwrap();
    //     assert!(verify_transaction_signature(&decoded_tx, &valid_keys));
    // }

    /// This test is change checker for a reason - we don't expect transaction format to change.
    /// If it does - you MUST update all of the dependencies: like nearlib and other clients.
    #[test]
    fn test_serialize_transaction() {
        let public_key: PublicKey = "22skMptHjFWNyuEWY22ftn2AbLPSYpmYwGJRGwpNHbTV".parse().unwrap();
        let transaction = Transaction {
            signer_id: "test.near".parse().unwrap(),
            public_key: public_key.clone(),
            nonce: 1,
            receiver_id: "123".parse().unwrap(),
            block_hash: Default::default(),
            actions: vec![
                Action::CreateAccount(CreateAccountAction {}),
                Action::DeployContract(DeployContractAction { code: vec![1, 2, 3] }),
                Action::FunctionCall(FunctionCallAction {
                    method_name: "qqq".to_string(),
                    args: vec![1, 2, 3],
                    gas: 1_000,
                    deposit: 1_000_000,
                }),
                Action::Transfer(TransferAction { deposit: 123 }),
                Action::Stake(StakeAction { public_key: public_key.clone(), stake: 1_000_000 }),
                Action::AddKey(AddKeyAction {
                    public_key: public_key.clone(),
                    access_key: AccessKey {
                        nonce: 0,
                        permission: AccessKeyPermission::FunctionCall(FunctionCallPermission {
                            allowance: None,
                            receiver_id: "zzz".parse().unwrap(),
                            method_names: vec!["www".to_string()],
                        }),
                    },
                }),
                Action::DeleteKey(DeleteKeyAction { public_key }),
                Action::DeleteAccount(DeleteAccountAction {
                    beneficiary_id: "123".parse().unwrap(),
                }),
            ],
        };
        let signed_tx = SignedTransaction::new(Signature::empty(KeyType::ED25519), transaction);
        let new_signed_tx =
            SignedTransaction::try_from_slice(&signed_tx.try_to_vec().unwrap()).unwrap();

        assert_eq!(
            to_base(&new_signed_tx.get_hash()),
            "4GXvjMFN6wSxnU9jEVT8HbXP5Yk6yELX9faRSKp6n9fX"
        );
    }

}

'''
'''--- blockchains/near/src/primitives/types.rs ---
use borsh::{BorshDeserialize, BorshSerialize};
use derive_more::{AsRef as DeriveAsRef};
use serde::{Deserialize, Serialize};
use near_crypto::PublicKey;

use near_primitives_core::hash::CryptoHash;
use near_primitives_core::serialize::u128_dec_format;
pub use near_primitives_core::types::*;

/// Epoch identifier -- wrapped hash, to make it easier to distinguish.
/// EpochId of epoch T is the hash of last block in T-2
/// EpochId of first two epochs is 0
#[cfg_attr(feature = "deepsize_feature", derive(deepsize::DeepSizeOf))]
#[derive(
Debug,
Clone,
Default,
Hash,
Eq,
PartialEq,
PartialOrd,
DeriveAsRef,
BorshSerialize,
BorshDeserialize,
Serialize,
Deserialize,
)]
#[as_ref(forward)]
pub struct EpochId(pub CryptoHash);

#[derive(Debug, Serialize, Deserialize)]
pub struct AccountWithPublicKey {
    pub account_id: AccountId,
    pub public_key: PublicKey,
}

/// Account info for validators
#[derive(Serialize, Deserialize, Clone, Debug, Eq, PartialEq)]
pub struct AccountInfo {
    pub account_id: AccountId,
    pub public_key: PublicKey,
    #[serde(with = "u128_dec_format")]
    pub amount: Balance,
}
'''
'''--- blockchains/polkadot/Cargo.toml ---
[package]
name = "rcc_polkadot"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
serde_json = "1.0"
parity-scale-codec = "3.1.5"
hex = "0.4.3"
qr_reader_phone = {git = "https://github.com/KeystoneHQ/parity-signer", tag = "keystone-patch@0.1.0"}
transaction_parsing = {git = "https://github.com/KeystoneHQ/parity-signer", tag = "keystone-patch@0.1.0"}
transaction_signing = {git = "https://github.com/KeystoneHQ/parity-signer", tag = "keystone-patch@0.1.0"}
definitions = {git = "https://github.com/KeystoneHQ/parity-signer", tag = "keystone-patch@0.1.0"}
db_handling = {git = "https://github.com/KeystoneHQ/parity-signer", tag = "keystone-patch@0.1.0"}
generate_message = {git = "https://github.com/KeystoneHQ/parity-signer", tag = "keystone-patch@0.1.0"}

[dev-dependencies]
fs_extra = "1.2.0"

'''
'''--- blockchains/polkadot/src/lib.rs ---
use transaction_parsing;
use transaction_parsing::TransactionAction;
use serde_json;
use serde_json::json;
use db_handling::db_transactions::SignContent;
use crate::wrapped_transaction_action::WrappedTransactionAction;
use transaction_signing;
use transaction_signing::sign_content;
use parity_scale_codec::Encode;
use hex;

pub mod scanner;
mod wrapped_transaction_action;
mod wrapped_card;
mod wrapped_transaction_card;
mod wrapped_transaction_card_set;
pub mod transaction_parser;
mod traits;

pub fn init_polkadot_db(db_name: String) -> String {
    match db_handling::cold_default::signer_init_with_cert(db_name.as_str()).map_err(|e| e.to_string()) {
        Ok(_) => json!({"status": "success"}),
        Err(e) => json!({"status": "failed", "reason": e})
    }.to_string()
}

pub fn handle_stub(db_name: String, checksum: u32) -> String {
    match transaction_signing::handle_stub(checksum, db_name.as_str()).map_err(|e| e.to_string()) {
        Ok(..) => json!({"status": "success"}),
        Err(e) => json!({"status": "failed", "reason": e})
    }.to_string()
}

pub fn import_address(db_name: String, public_key: String, path: String) -> String {
    match db_handling::identities::try_import_address(public_key.as_str(), path.as_str(), db_name).map_err(|e| e.to_string()) {
        Ok(..) => json!({"status": "success"}),
        Err(e) => json!({"status": "failed", "reason": e})
    }.to_string()
}

pub fn get_sign_content(db_name: String, checksum: u32) -> String {
    match db_handling::db_transactions::TrDbColdSign::from_storage(db_name, checksum).map_err(|v| v.to_string()) {
        Ok(v) => {
            let value = match v.content() {
                SignContent::Transaction { method, extensions } => {
                    [method.to_vec(), extensions.to_vec()].concat()
                }
                SignContent::Message(a) => a.encode(),
            };
            let sign_content = hex::encode(value);
            json!({"status": "success", "value": sign_content})
        }
        Err(e) => {
            json!({"status": "failed", "reason": e})
        }
    }.to_string()
}

#[cfg(test)]
mod tests {
    use std::path::Path;
    use crate::{init_polkadot_db, scanner, handle_stub, import_address, get_sign_content};
    use crate::transaction_parser::parse_transaction;
    use db_handling;
    use generate_message;
    use generate_message::parser::{Command, Show};
    use transaction_signing;
    use fs_extra;
    use fs_extra::dir::CopyOptions;
    use std::fs;
    use serde_json::Value;
    use hex;

    fn get_db_path() -> String {
        "./test_data/database".to_string()
    }

    fn initial_data_base() {
        let db_origin_path = "./test_data/database_origin";
        let db_path = get_db_path();
        let option = CopyOptions {
            overwrite: true,
            skip_exist: false,
            buffer_size: 64000,
            copy_inside: true,
            content_only: false,
            depth: 0,
        };
        fs_extra::dir::copy(db_origin_path, db_path, &option);
    }

    fn remove() {
        let db_path = get_db_path();
        let items = vec![db_path];
        fs_extra::remove_items(&items);
    }

    fn init() {
        let db_path = get_db_path();
        initial_data_base();
        init_polkadot_db(db_path.clone());
    }

    fn add_meta() {
        let db_path = get_db_path();
        let payload = fs::read_to_string("./test_data/metadata_polkadot_v9270").unwrap();
        let result = parse_transaction(payload, db_path.clone());
        let json: Value = serde_json::from_str(result.as_str()).unwrap();
        let i = &json["checksum"];
        if let Value::Number(i) = i {
            handle_stub(db_path.to_string(), i.as_u64().unwrap() as u32);
        }
    }

    fn add_address() {
        let db_path = get_db_path();
        let public_key = "28b9ffce010cff941262f1b5fa5a884a65b2f7324854082abd68aa3d93b0827f";
        let path = "//polkadot";
        import_address(db_path.clone(), public_key.to_string(), path.to_string());
    }

    #[test]
    fn parse_read_metadata() {
        init();
        let db_path = get_db_path();
        let payload = fs::read_to_string("./test_data/metadata_polkadot_v9270").unwrap();
        let result = parse_transaction(payload, db_path.clone());
        let json: Value = serde_json::from_str(result.as_str()).unwrap();
        assert_eq!(json["content"][0]["card"]["type"], "Meta");
        remove();
    }

    #[test]
    fn test_parse_transfer_without_address() {
        init();
        add_meta();
        let db_path = get_db_path();
        let tx = fs::read_to_string("./test_data/transactions/transfer").unwrap();
        let result = parse_transaction(tx, db_path);
        let json: Value = serde_json::from_str(result.as_str()).unwrap();
        assert_eq!("Read", json["transaction_type"]);
        remove();
    }

    #[test]
    fn test_parse_transfer_with_address() {
        init();
        add_meta();
        add_address();
        let db_path = get_db_path();
        let tx = fs::read_to_string("./test_data/transactions/transfer").unwrap();
        let result = parse_transaction(tx, db_path);
        let json: Value = serde_json::from_str(result.as_str()).unwrap();
        assert_eq!("Sign", json["transaction_type"]);
        println!("{}", json);
        remove();
    }

    #[test]
    fn test_get_sign_content() {
        init();
        add_meta();
        add_address();
        let db_path = get_db_path();
        let tx = fs::read_to_string("./test_data/transactions/transfer").unwrap();
        let result = parse_transaction(tx, db_path.clone());
        let json: Value = serde_json::from_str(result.as_str()).unwrap();
        let checksum = json["checksum"].as_u64().unwrap();
        let sign_content = get_sign_content(db_path.clone(), checksum.clone() as u32);
        let json2: Value = serde_json::from_str(sign_content.as_str()).unwrap();
        let result2 = json2["value"].as_str().unwrap();
        assert_eq!("05030028b9ffce010cff941262f1b5fa5a884a65b2f7324854082abd68aa3d93b0827f0700e40b54025501c90100362400000d00000091b171bb158e2d3848fa23a9f1c25182fb8e20313b2c1eb49219da7a70ce90c3e5dc2cf7ac2ab8940ce2607ce9df3ec7bc59f513ea23dba5b956165518c1d4fc",
                   result2);
        remove();
    }
}
'''
'''--- blockchains/polkadot/src/scanner.rs ---
use serde_json;
use serde_json::json;
use qr_reader_phone;

pub fn get_packets_total(payload: String) -> String {
    match qr_reader_phone::get_length(payload.as_str(), false).map_err(|e| e.to_string()) {
        Ok(v) => json!({"status": "success", "value": v}),
        Err(e) => json!({"status": "failed", "reason": e}),
    }.to_string()
}

pub fn decode_sequence(payload: Vec<String>) -> String {
    match serde_json::to_string(&payload) {
        Ok(message) => {
            match qr_reader_phone::decode_sequence(message.as_str(), false) {
                Ok(v) => json!({"status": "success", "value": v}),
                Err(e) => json!({"status": "failed", "reason": e.to_string()}),
            }
        }
        Err(e) => json!({"status": "failed", "reason": e.to_string()})
    }.to_string()
}

'''
'''--- blockchains/polkadot/src/traits.rs ---
use serde_json::Value;

pub trait ToJSON {
    fn to_json(&self) -> Value;
}
'''
'''--- blockchains/polkadot/src/transaction_parser.rs ---
use crate::WrappedTransactionAction;

pub fn parse_transaction(transaction: String, db_name: String) -> String {
    WrappedTransactionAction {
        t: transaction_parsing::produce_output(transaction.as_str(), db_name.as_str())
    }.to_json().to_string()
}

'''
'''--- blockchains/polkadot/src/wrapped_card.rs ---
use serde_json::{json, Value};
use definitions::{navigation::Card, crypto::Encryption};
use crate::traits::ToJSON;

pub struct WrappedCard {
    pub c: Card,
}

impl ToJSON for WrappedCard {
    fn to_json(&self) -> Value{
        match &self.c {
            Card::AuthorCard { f } => {
                json!({
                    "type": "Author",
                    "value": json!({
                        "base58": f.base58,
                        "path": f.path,
                    })
                })
            }
            Card::AuthorPlainCard { f } => {
                json!({
                    "type": "AuthorPlain",
                    "value": f.base58
                })
            }
            Card::AuthorPublicKeyCard { f } => {
                json!({
                    "type": "AuthorPublicKey",
                    "value": f.public_key
                })
            }
            Card::BalanceCard { f } => {
                let value = format!("{} {}", f.amount, f.units);
                json!({
                    "type": "Balance",
                    "value": value,
                })
            }
            Card::BitVecCard { f } => {
                json!({
                    "type": "BitVec",
                    "value": f,
                })
            }
            Card::BlockHashCard { f } => {
                json!({
                    "type": "BlockHash",
                    "value": f
                })
            }
            Card::CallCard { f } => {
                json!({
                    "type": "Call",
                    "value": f.method_name
                })
            }
            Card::DefaultCard { f } => {
                json!({
                    "type": "Default",
                    "value": f
                })
            }
            Card::DerivationsCard { f } => {
                json!({
                    "type": "Derivations",
                    "value": f
                })
            }
            Card::EnumVariantNameCard { f } => {
                json!({
                    "type": "EnumVariantName",
                    "value": f.name,
                })
            }
            Card::EraImmortalCard => {
                json!({
                    "type": "Era",
                    "value": "Immortal"
                })
            }
            Card::EraMortalCard { f } => {
                json!({
                    "type": "Era",
                    "value": json!({
                        "phase": f.phase,
                        "period": f.period,
                    })
                })
            }
            Card::ErrorCard { f } => {
                json!({
                    "type": "Error",
                    "value": f
                })
            }
            Card::FieldNameCard { f } => {
                json!({
                    "type": "FieldName",
                    "value": f.name
                })
            }
            Card::FieldNumberCard { f } => {
                json!({
                    "type": "FieldNumber",
                    "value": f.number,
                })
            }
            Card::IdCard { f } => {
                json!({
                    "type": "Id",
                    "value": f.base58
                })
            }
            Card::IdentityFieldCard { f } => {
                json!({
                    "type": "IdentityField",
                    "value": f,
                })
            }
            Card::MetaCard { f } => {
                json!({
                    "type": "Meta",
                    "value": json!({
                        "specname": f.specname,
                        "specs_version": f.specs_version,
                        "meta_hash": f.meta_hash,    
                    })
                })
            }
            Card::NameVersionCard { f } => {
                json!({
                    "type": "NameVersion",
                    "value": json!({
                        "name": f.name,
                        "version": f.version,
                    })
                })
            }
            Card::NetworkGenesisHashCard { f } => {
                json!({
                    "type": "NetworkGenesisHash",
                    "value": f,
                })
            }
            Card::NetworkInfoCard { f } => {
                json!({
                    "type": "NetworkInfo",
                    "value": json!({
                        "network_title": f.network_title,
                    })
                })
            }
            Card::NetworkNameCard { f } => {
                json!({
                    "type": "NetworkName",
                    "value": f,
                })
            }
            Card::NewSpecsCard { f } => {
                let encryption = match f.encryption {
                    Encryption::Ed25519 => "ED25519",
                    Encryption::Sr25519 => "Sr25519",
                    Encryption::Ecdsa => "Ecdsa",
                };
                json!({
                    "type": "NetSpecs",
                    "value": json!({
                        "base58prefix": f.base58prefix,
                        "decimals": f.decimals,
                        "encryption": encryption,
                        "genesis_hahs": f.genesis_hash,
                        "name": f.name,
                        "title": f.title,
                        "unit": f.unit
                    })
                })
            }
            Card::NonceCard { f } => {
                json!({
                    "type": "Nonce",
                    "value": f,
                })
            }
            Card::NoneCard => {
                json!({
                    "type": "None"
                })
            }
            Card::PalletCard { f } => {
                json!({
                    "type": "Pallet",
                    "value": f,
                })
            }
            Card::TextCard { f } => {
                json!({
                    "type": "Text",
                    "value": f,
                })
            }
            Card::TipCard { f } => {
                json!({
                    "type": "Tip",
                    "value": json!({
                        "amount": f.amount,
                        "units": f.units,
                    })
                })
            }
            Card::TipPlainCard { f } => {
                json!({
                    "type": "TipPlain",
                    "value": f,
                })
            }
            Card::TxSpecCard { f } => {
                json!({
                    "type": "TxSpec",
                    "value": f,
                })
            }
            Card::TxSpecPlainCard { f } => {
                json!({
                    "type": "TxSpecPlain",
                    "value": json!({
                        "network_genesis_hash": f.network_genesis_hash,
                        "version": f.version,
                        "tx_version": f.tx_version,
                    })
                })
            }
            Card::TypesInfoCard { f } => {
                json!({
                    "type": "TypesInfo",
                    "value": json!({
                        "types_on_file": f.types_on_file,
                        "types_hash": f.types_hash,
                    })
                })
            }
            Card::VarNameCard { f } => {
                json!({
                    "type": "VarName",
                    "value": f,
                })
            }
            Card::VerifierCard { f } => {
                json!({
                    "type": "Verifier",
                    "value": json!({
                        "public_key": f.public_key,
                        "encryption": f.encryption,
                    })
                })
            }
            Card::WarningCard { f } => {
                json!({
                    "type": "Warning",
                    "value": f,
                })
            }
        }
    }
}
'''
'''--- blockchains/polkadot/src/wrapped_transaction_action.rs ---
use serde_json::{json, Value};
use definitions::navigation::{Address, MSCNetworkInfo, MTransaction, TransactionType};
use transaction_parsing::TransactionAction;
use crate::traits::ToJSON;
use crate::wrapped_transaction_card_set::WrappedTransactionCardSet;

pub struct WrappedTransactionAction {
    pub(crate) t: TransactionAction,
}

impl ToJSON for MTransaction {
    fn to_json(&self) -> Value{
        let transaction_type = match self.ttype {
            TransactionType::Stub => "Stub",
            TransactionType::Read => "Read",
            TransactionType::Sign => "Sign",
            TransactionType::ImportDerivations => "ImportDerivations",
            TransactionType::Done => "Done",
        };
        let wrapped_content = WrappedTransactionCardSet {
            tcs: self.content.clone(),
        };
        json!({
            "content": wrapped_content.to_json(),
            "checksum": self.checksum,
            "transaction_type": transaction_type,
            "author_info": self.author_info.as_ref().map(|v| v.to_json()),
            "network_info": self.network_info.as_ref().map(|v| v.to_json()),
        })
    }
}

impl ToJSON for Address {
    fn to_json(&self) -> Value {
        json!({
            "base58": self.base58,
            "path": self.path,
        })
    }
}

impl ToJSON for MSCNetworkInfo {
    fn to_json(&self) -> Value {
        json!({
            "network_title": self.network_title,
        })
    }
}

impl WrappedTransactionAction {
    pub fn to_json(&self) -> Value {
        let (content, ttype, author_info, network_info) = match &self.t {
            TransactionAction::Derivations {
                content,
                network_info,
                ..
            } => (
                content,
                TransactionType::ImportDerivations,
                None,
                Some(network_info),
            ),
            TransactionAction::Sign {
                content,
                author_info,
                network_info,
                ..
            } => (
                content,
                TransactionType::Sign,
                Some(author_info),
                Some(network_info),
            ),
            TransactionAction::Stub { s, .. } => (s, TransactionType::Stub, None, None),
            TransactionAction::Read { r } => (r, TransactionType::Read, None, None),
        };
        let result = MTransaction {
            content: content.clone(),
            ttype,
            author_info: author_info.cloned(),
            network_info: network_info.map(|i| MSCNetworkInfo {
                network_title: i.clone().title,
                network_logo: i.clone().logo,
                network_specs_key: "".to_string()
            }),
            checksum: match &self.t {
                TransactionAction::Derivations { checksum, .. } => { Some(checksum.clone())}
                TransactionAction::Sign { checksum, .. } => {Some(checksum.clone())}
                TransactionAction::Stub { u, .. } => {Some(u.clone())}
                TransactionAction::Read { .. } => {None}
            }
        };
        result.to_json()
    }
}
'''
'''--- blockchains/polkadot/src/wrapped_transaction_card.rs ---
use serde_json::{json, Value};
use definitions::navigation::TransactionCard;

use crate::traits::ToJSON;
use crate::wrapped_card::WrappedCard;

pub struct WrappedTransactionCard {
    pub tc: TransactionCard,
}

impl ToJSON for WrappedTransactionCard {
    fn to_json(&self) -> Value {
        let wrapped_card = WrappedCard {
            c: self.tc.card.clone(),
        };
        let card_json = wrapped_card.to_json();
        json!({
            "index": self.tc.index,
            "indent": self.tc.indent,
            "card": card_json,
        })
    }
}
'''
'''--- blockchains/polkadot/src/wrapped_transaction_card_set.rs ---
use serde_json::{json, Value};
use definitions::navigation::{TransactionCard, TransactionCardSet};
use crate::traits::ToJSON;
use crate::wrapped_transaction_card::WrappedTransactionCard;

pub struct WrappedTransactionCardSet {
    pub tcs: TransactionCardSet,
}

impl ToJSON for WrappedTransactionCardSet {
    fn to_json(&self) -> Value {
        let concat = |v1: Vec<TransactionCard>, v2: &Vec<TransactionCard>| [v1, v2.to_vec()].concat();

        let mut cards: Vec<TransactionCard> = vec![];
        if let Some(v) = self.tcs.author.as_ref() {
            cards = concat(cards, v);
        }
        if let Some(v) = self.tcs.error.as_ref() {
            cards = concat(cards, v);
        }
        if let Some(v) = self.tcs.extensions.as_ref() {
            cards = concat(cards, v);
        }
        if let Some(v) = self.tcs.importing_derivations.as_ref() {
            cards = concat(cards, v);
        }
        if let Some(v) = self.tcs.message.as_ref() {
            cards = concat(cards, v);
        }
        if let Some(v) = self.tcs.meta.as_ref() {
            cards = concat(cards, v);
        }
        if let Some(v) = self.tcs.method.as_ref() {
            cards = concat(cards, v);
        }
        if let Some(v) = self.tcs.new_specs.as_ref() {
            cards = concat(cards, v);
        }
        if let Some(v) = self.tcs.verifier.as_ref() {
            cards = concat(cards, v);
        }
        if let Some(v) = self.tcs.warning.as_ref() {
            cards = concat(cards, v);
        }
        if let Some(v) = self.tcs.types_info.as_ref() {
            cards = concat(cards, v);
        }
        let result = cards.iter().map(|v| WrappedTransactionCard{tc: v.clone()}.to_json()).collect::<Vec<Value>>();
        json!(result)
    }
}

'''
'''--- blockchains/solana/Cargo.toml ---
[package]
name = "rcc-solana"
version = "0.3.1"
edition = "2021"
license = "Apache-2.0"
description = "A transaction parser for solana."

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
bs58 = "0.4.0"
serde_json = "1.0"
serde = "1.0.139"
hex = "0.4.3"
rcc-trait-chain = "0.1.0"
thiserror = "1.0.31"
bincode = "1.3.3"
num-derive = "0.3.3"
serde_derive = "1.0.141"
uint = "0.9.3"
arrayref = "0.3.6"

'''
'''--- blockchains/solana/src/compact.rs ---
use crate::error::{Result, SolanaError};
use crate::read::Read;

pub struct Compact<T> {
    compact_length: u32,
    pub(crate) data: Vec<T>,
}

impl<T: Read<T>> Compact<T> {
    fn new(raw: &mut Vec<u8>) -> Result<Compact<T>> {
        let length: u32 = Compact::<T>::read_length(raw)?;
        let mut compact = Compact {
            compact_length: length,
            data: vec![],
        };
        for _ in 0..compact.compact_length {
            compact.data.push(T::read(raw)?);
        }
        Ok(compact)
    }

    fn read_length(raw: &mut Vec<u8>) -> Result<u32> {
        let mut len: u32 = 0;
        let mut size: u32 = 0;
        loop {
            if raw.len() < 1 {
                return Err(SolanaError::InvalidData(format!("compact length")));
            }
            let element: u32 = raw.remove(0) as u32;
            len |= (element & 0x7f) << (size * 7);
            size += 1;
            if (element & 0x80) == 0 {
                break;
            }
        }
        Ok(len)
    }
}

impl<T: Read<T>> Read<Compact<T>> for Compact<T> {
    fn read(raw: &mut Vec<u8>) -> Result<Compact<T>> {
        Compact::new(raw)
    }
}

'''
'''--- blockchains/solana/src/error.rs ---
use thiserror::Error;

#[derive(Error, Debug)]
pub enum SolanaError {
    #[error("Program `{0}` is not supported yet")]
    UnsupportedProgram(String),

    #[error("Meet invalid data when reading `{0}`")]
    InvalidData(String),

    #[error("Error occurred when parsing program instruction, reason: `{0}`")]
    ProgramError(String),

    #[error("Could not found account for `{0}`")]
    AccountNotFound(String),
}

pub type Result<T> = std::result::Result<T, SolanaError>;

'''
'''--- blockchains/solana/src/instruction.rs ---
use crate::compact::Compact;
use crate::error::SolanaError::ProgramError;
use crate::error::{Result, SolanaError};
use crate::resolvers;
use crate::Read;

use crate::solana_lib::solana_program::stake::instruction::StakeInstruction;
use crate::solana_lib::solana_program::system_instruction::SystemInstruction;
use crate::solana_lib::solana_program::vote::instruction::VoteInstruction;
use serde_json::Value;

pub struct Instruction {
    pub(crate) program_index: u8,
    pub(crate) account_indexes: Vec<u8>,
    pub(crate) data: Vec<u8>,
}

impl Read<Instruction> for Instruction {
    fn read(raw: &mut Vec<u8>) -> Result<Instruction> {
        if raw.len() < 1 {
            return Err(SolanaError::InvalidData(format!("instruction")));
        }
        let program_index = raw.remove(0);
        let account_indexes = Compact::read(raw)?.data;
        let data = Compact::read(raw)?.data;
        Ok(Instruction {
            program_index,
            account_indexes,
            data,
        })
    }
}

enum SupportedProgram {
    SystemProgram,
    VoteProgram,
    StakeProgram,
    TokenProgram,
    TokenSwapProgramV3,
    TokenLendingProgram,
}

impl SupportedProgram {
    pub fn from_program_id(program_id: String) -> Result<Self> {
        match program_id.as_str() {
            "11111111111111111111111111111111" => Ok(SupportedProgram::SystemProgram),
            "Vote111111111111111111111111111111111111111" => Ok(SupportedProgram::VoteProgram),
            "Stake11111111111111111111111111111111111111" => Ok(SupportedProgram::StakeProgram),
            "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA" => Ok(SupportedProgram::TokenProgram),
            "SwapsVeCiPHMUAtzQWZw7RjsKjgCjhwU55QGu4U1Szw" => {
                Ok(SupportedProgram::TokenSwapProgramV3)
            }
            "LendZqTs7gn5CTSJU1jWKhKuVpjJGom45nnwPb2AMTi" => {
                Ok(SupportedProgram::TokenLendingProgram)
            }
            x => Err(SolanaError::UnsupportedProgram(x.to_string())),
        }
    }
}

impl Instruction {
    pub fn parse(&self, program_id: &String, accounts: Vec<String>) -> Result<Value> {
        let program = SupportedProgram::from_program_id(program_id.clone())?;
        match program {
            SupportedProgram::SystemProgram => {
                let instruction =
                    Self::parse_native_program_instruction::<SystemInstruction>(self.data.clone())?;
                resolvers::system::resolve(instruction, accounts)
            }
            SupportedProgram::VoteProgram => {
                let instruction =
                    Self::parse_native_program_instruction::<VoteInstruction>(self.data.clone())?;
                resolvers::vote::resolve(instruction, accounts)
            }
            SupportedProgram::StakeProgram => {
                let instruction =
                    Self::parse_native_program_instruction::<StakeInstruction>(self.data.clone())?;
                resolvers::stake::resolve(instruction, accounts)
            }
            SupportedProgram::TokenProgram => {
                let instruction =
                    crate::solana_lib::spl::token::instruction::TokenInstruction::unpack(
                        self.data.clone().as_slice(),
                    )
                    .map_err(|e| ProgramError(e.to_string()))?;
                resolvers::token::resolve(instruction, accounts)
            }
            SupportedProgram::TokenSwapProgramV3 => {
                let instruction =
                    crate::solana_lib::spl::token_swap::instruction::SwapInstruction::unpack(
                        self.data.clone().as_slice(),
                    )
                    .map_err(|e| ProgramError(e.to_string()))?;
                resolvers::token_swap_v3::resolve(instruction, accounts)
            }
            SupportedProgram::TokenLendingProgram => {
                let instruction =
                    crate::solana_lib::spl::token_lending::instruction::LendingInstruction::unpack(
                        self.data.clone().as_slice(),
                    )
                    .map_err(|e| ProgramError(e.to_string()))?;
                resolvers::token_lending::resolve(instruction, accounts)
            }
        }
    }

    fn parse_native_program_instruction<T: for<'de> serde::de::Deserialize<'de>>(
        instruction_data: Vec<u8>,
    ) -> Result<T> {
        // Copied from solana_sdk
        // pub const PACKET_DATA_SIZE: usize = 1280 - 40 - 8;
        crate::solana_lib::solana_program::program_utils::limited_deserialize(
            instruction_data.as_slice(),
            1280 - 40 - 8,
        )
        .map_err(|e| ProgramError(e.to_string()))
    }
}

'''
'''--- blockchains/solana/src/lib.rs ---
use crate::error::SolanaError;
use crate::message::Message;
use crate::read::Read;

use rcc_trait_chain::Chain;

mod compact;
mod error;
mod instruction;
pub mod message;
pub(crate) mod read;
mod resolvers;
mod solana_lib;

pub struct Sol {}

impl Sol {
    fn parse_message(message: &mut Vec<u8>) -> Result<message::Message, SolanaError> {
        Message::read(message)
    }
    pub fn parse_message_to_json(message: &mut Vec<u8>) -> Result<String, SolanaError> {
        Sol::parse_message(message).and_then(|v| v.to_json_str())
    }

    pub fn validate_message(message: &mut Vec<u8>) -> bool {
        Message::validate(message)
    }
}

impl Chain<SolanaError> for Sol {
    fn parse(data: &Vec<u8>) -> Result<String, SolanaError> {
        Sol::parse_message(data.clone().to_vec().as_mut()).and_then(|v| v.to_json_str())
    }
}

'''
'''--- blockchains/solana/src/message.rs ---
use crate::compact::Compact;
use crate::error::{Result, SolanaError};
use crate::instruction::Instruction;
use crate::read::Read;
use bs58;
use serde_json::{json, Value};

struct Signature {
    value: Vec<u8>,
}

impl Read<Signature> for Signature {
    fn read(raw: &mut Vec<u8>) -> Result<Signature> {
        if raw.len() < 64 {
            return Err(SolanaError::InvalidData(format!("signature")));
        }
        Ok(Signature {
            value: raw.splice(0..64, []).collect(),
        })
    }
}

struct Account {
    value: Vec<u8>,
}

impl Read<Account> for Account {
    fn read(raw: &mut Vec<u8>) -> Result<Account> {
        if raw.len() < 32 {
            return Err(SolanaError::InvalidData(format!("account")));
        }
        Ok(Account {
            value: raw.splice(0..32, []).collect(),
        })
    }
}

struct BlockHash {
    value: Vec<u8>,
}

impl Read<BlockHash> for BlockHash {
    fn read(raw: &mut Vec<u8>) -> Result<BlockHash> {
        if raw.len() < 32 {
            return Err(SolanaError::InvalidData(format!("blockhash")));
        }
        Ok(BlockHash {
            value: raw.splice(0..32, []).collect(),
        })
    }
}

pub struct Message {
    header: MessageHeader,
    accounts: Vec<Account>,
    block_hash: BlockHash,
    instructions: Vec<Instruction>,
}

impl Read<Message> for Message {
    fn read(raw: &mut Vec<u8>) -> Result<Message> {
        let header = MessageHeader::read(raw)?;
        let accounts = Compact::read(raw)?.data;
        let block_hash = BlockHash::read(raw)?;
        let instructions = Compact::read(raw)?.data;
        Ok(Message {
            header,
            accounts,
            block_hash,
            instructions,
        })
    }
}

impl Message {
    pub fn to_json_str(&self) -> Result<String> {
        let instructions = self
            .instructions
            .iter()
            .map(|instruction| {
                let accounts = instruction
                    .account_indexes
                    .iter()
                    .map(|account_index| {
                        bs58::encode(&self.accounts[usize::from(*account_index)].value)
                            .into_string()
                    })
                    .collect::<Vec<String>>();
                let program_account =
                    bs58::encode(&self.accounts[usize::from(instruction.program_index)].value)
                        .into_string();
                let accounts_string = accounts.clone().join(",").to_string();
                match instruction.parse(&program_account, accounts) {
                    Ok(value) => Ok(json!({
                        "raw": {
                            "program_index": instruction.program_index,
                            "program_account": program_account,
                            "account_indexes": instruction.account_indexes,
                            "accounts": accounts_string,
                            "data": bs58::encode(&instruction.data).into_string(),
                        },
                        "readable": value,
                    })),
                    Err(e) => {
                        let readable =
                            format!("Unable to parse instruction, reason: {}", e.to_string());
                        Ok(json!({
                            "raw": {
                                "program_index": instruction.program_index,
                                "program_account": program_account,
                                "account_indexes": instruction.account_indexes,
                                "accounts": accounts_string,
                                "data": bs58::encode(&instruction.data).into_string(),
                            },
                            "readable": readable,
                        }))
                    }
                }
            })
            .collect::<Result<Vec<Value>>>()?;
        let json = json!({
            "header": {
                "num_required_signatures": self.header.num_required_signatures,
                "num_readonly_signed_accounts": self.header.num_readonly_signed_accounts,
                "num_readonly_unsigned_accounts": self.header.num_readonly_unsigned_accounts,
            },
            "accounts": self.accounts.iter().map(|account| {bs58::encode(&account.value).into_string()}).collect::<Vec<String>>(),
            "block_hash": bs58::encode(&self.block_hash.value).into_string(),
            "instructions": instructions,
        });
        Ok(json.to_string())
    }

    pub fn validate(raw: &mut Vec<u8>) -> bool {
        match Self::read(raw) {
            Ok(_) => true,
            Err(_) => false,
        }
    }
}

struct MessageHeader {
    num_required_signatures: u8,
    num_readonly_signed_accounts: u8,
    num_readonly_unsigned_accounts: u8,
}

impl Read<MessageHeader> for MessageHeader {
    fn read(raw: &mut Vec<u8>) -> Result<MessageHeader> {
        if raw.len() < 3 {
            return Err(SolanaError::InvalidData(format!("message header")));
        }
        let n1 = raw.remove(0);
        let n2 = raw.remove(0);
        let n3 = raw.remove(0);
        Ok(MessageHeader {
            num_required_signatures: n1,
            num_readonly_signed_accounts: n2,
            num_readonly_unsigned_accounts: n3,
        })
    }
}

impl Read<u8> for u8 {
    fn read(raw: &mut Vec<u8>) -> Result<u8> {
        if raw.len() < 1 {
            return Err(SolanaError::InvalidData(format!("u8")));
        }
        Ok(raw.remove(0))
    }
}

#[cfg(test)]
mod tests {
    use crate::message::Message;
    use crate::read::Read;
    use hex::{self, FromHex};
    use serde_json::json;

    #[test]
    fn test_parse_message() {
        let mut raw = Vec::from_hex("01000103c8d842a2f17fd7aab608ce2ea535a6e958dffa20caf669b347b911c4171965530f957620b228bae2b94c82ddd4c093983a67365555b737ec7ddc1117e61c72e0000000000000000000000000000000000000000000000000000000000000000010295cc2f1f39f3604718496ea00676d6a72ec66ad09d926e3ece34f565f18d201020200010c0200000000e1f50500000000").unwrap();
        let message = Message::read(&mut raw).unwrap();

        let header = &message.header;
        assert_eq!(header.num_required_signatures, 1);
        assert_eq!(header.num_readonly_signed_accounts, 0);
        assert_eq!(header.num_readonly_unsigned_accounts, 1);

        let accounts = &message.accounts;
        assert_eq!(
            accounts[0].value,
            Vec::from_hex("c8d842a2f17fd7aab608ce2ea535a6e958dffa20caf669b347b911c417196553")
                .unwrap()
        );
        assert_eq!(
            accounts[1].value,
            Vec::from_hex("0f957620b228bae2b94c82ddd4c093983a67365555b737ec7ddc1117e61c72e0")
                .unwrap()
        );
        assert_eq!(
            accounts[2].value,
            Vec::from_hex("0000000000000000000000000000000000000000000000000000000000000000")
                .unwrap()
        );

        let block_hash = &message.block_hash;
        assert_eq!(
            block_hash.value,
            Vec::from_hex("10295cc2f1f39f3604718496ea00676d6a72ec66ad09d926e3ece34f565f18d2")
                .unwrap()
        );

        let instructions = &message.instructions;
        assert_eq!(instructions[0].program_index, 2);
        assert_eq!(instructions[0].account_indexes, [0, 1]);
        assert_eq!(
            instructions[0].data,
            Vec::from_hex("0200000000e1f50500000000").unwrap()
        );
        assert_eq!(message.to_json_str().unwrap(), json!({"accounts":["EX1oURpiPWWYUjVSK9KQR2qyqTBaR1EGfRNxkTsNk57Y","23qJPvgvCBGJFhPmemqcksVCtrLDKyXJh5ZstjfCuu9q","11111111111111111111111111111111"],"block_hash":"26673efpV4o6Cv5ZnEfYp3M18nkqhg6tyXF2A2JzeoCd","header":{"num_readonly_signed_accounts":0,"num_readonly_unsigned_accounts":1,"num_required_signatures":1},"instructions":[{"raw":{"account_indexes":[0,1],"accounts":"EX1oURpiPWWYUjVSK9KQR2qyqTBaR1EGfRNxkTsNk57Y,23qJPvgvCBGJFhPmemqcksVCtrLDKyXJh5ZstjfCuu9q","data":"3Bxs411Dtc7pkFQj","program_account":"11111111111111111111111111111111","program_index":2},"readable":{"details":{"amount":"100000000","from":"EX1oURpiPWWYUjVSK9KQR2qyqTBaR1EGfRNxkTsNk57Y","recipient":"23qJPvgvCBGJFhPmemqcksVCtrLDKyXJh5ZstjfCuu9q"},"method_name":"Transfer","overview":{"amount":"100000000","from":"EX1oURpiPWWYUjVSK9KQR2qyqTBaR1EGfRNxkTsNk57Y","recipient":"23qJPvgvCBGJFhPmemqcksVCtrLDKyXJh5ZstjfCuu9q"},"program_name":"System"}}]}).to_string())
    }

    #[test]
    fn test_validate_message() {
        let message_invalid = "4c6f72656d20697073756d20646f6c6f722073697420616d65742c20636f6e73656374657475722061646970697363696e6720656c69742c2073656420646f20656975736d6f642074656d706f7220696e6369646964756e74207574206c61626f726520657420646f6c6f7265206d61676e6120616c697175612e";
        let mut raw_invalid = Vec::from_hex(message_invalid).unwrap();
        let result_invalid = Message::validate(&mut raw_invalid);
        assert_eq!(result_invalid, false);

        let message_valid = "01000103c8d842a2f17fd7aab608ce2ea535a6e958dffa20caf669b347b911c4171965530f957620b228bae2b94c82ddd4c093983a67365555b737ec7ddc1117e61c72e0000000000000000000000000000000000000000000000000000000000000000010295cc2f1f39f3604718496ea00676d6a72ec66ad09d926e3ece34f565f18d201020200010c0200000000e1f50500000000";
        let mut raw_valid = Vec::from_hex(message_valid).unwrap();
        let result_valid = Message::validate(&mut raw_valid);
        assert_eq!(result_valid, true);
    }

    fn read_message(tx: &str) -> String {
        let mut transaction = Vec::from_hex(tx).unwrap();
        let message = Message::read(&mut transaction).unwrap();
        message.to_json_str().unwrap()
    }

    #[test]
    fn test_transaction_1() {
        // System.Transfer
        let json = read_message("01000103876c762c4c83532f82966935ba1810659a96237028a2af6688dadecb0155ae071c7d0930a08193e702b0f24ebba96f179e9c186ef1208f98652ee775001744490000000000000000000000000000000000000000000000000000000000000000a7516fe1d3af3457fdc54e60856c0c3c87f4e5be3d10ffbc7a5cce8bf96792a101020200010c020000008813000000000000");
        assert_eq!(json, json!({"accounts":["A7dxsCbMy5ktZwQUgsQhVxsoJpx6wPAZYEcccQVjWnkE","2vCzt15qsXSCsf5k6t6QF9DiQSpE7kPTg3PdvFZtm2Tr","11111111111111111111111111111111"],"block_hash":"CG97KCGLGgPS1E754VjLgy724zNwGjE9sjrzqYa6CU2t","header":{"num_readonly_signed_accounts":0,"num_readonly_unsigned_accounts":1,"num_required_signatures":1},"instructions":[{"raw":{"account_indexes":[0,1],"accounts":"A7dxsCbMy5ktZwQUgsQhVxsoJpx6wPAZYEcccQVjWnkE,2vCzt15qsXSCsf5k6t6QF9DiQSpE7kPTg3PdvFZtm2Tr","data":"3Bxs4PckVVt51W8w","program_account":"11111111111111111111111111111111","program_index":2},"readable":{"details":{"amount":"5000","from":"A7dxsCbMy5ktZwQUgsQhVxsoJpx6wPAZYEcccQVjWnkE","recipient":"2vCzt15qsXSCsf5k6t6QF9DiQSpE7kPTg3PdvFZtm2Tr"},"method_name":"Transfer","overview":{"amount":"5000","from":"A7dxsCbMy5ktZwQUgsQhVxsoJpx6wPAZYEcccQVjWnkE","recipient":"2vCzt15qsXSCsf5k6t6QF9DiQSpE7kPTg3PdvFZtm2Tr"},"program_name":"System"}}]}).to_string())
    }

    #[test]
    fn test_transaction_2() {
        // Vote.Vote
        let json = read_message("01000305b446cb8fd7c225bf416df87c286710d75711af95222e41216da2177289cbbfa6b68edcd94d93de68614892bd165a94a6647aa040d87b9a042b41a009bdb469cf06a7d51718c774c928566398691d5eb68b5eb8a39b4b6d5c73555b210000000006a7d517192f0aafc6f265e3fb77cc7ada82c529d0be3b136e2d0055200000000761481d357474bb7c4d7624ebd3bdb3d8355e73d11043fc0da35380000000009254bd5e695fabf43f0ead6da730e88cf39bec6991c2c4374bcade97d0a73be7010404010302003d02000000010000000000000060f2790800000000856a887d33af1cd1723388576a7be8fa6d9c9c80c548495a24bf680c908812cf01da7dd66200000000");
        assert_eq!(json, json!({"accounts":["D8izqaR979Fc2amDoGHmYqEugjckEi1RQL1Y1JKyHUwX","DHdYsTEsd1wGrmthR1ognfRXPkWBmxAWAv2pKdAix3HY","SysvarC1ock11111111111111111111111111111111","SysvarS1otHashes111111111111111111111111111","Vote111111111111111111111111111111111111111"],"block_hash":"ArDU9jQqkrYg12SBihpjx7JSw2FjWtJ8K91uKTCyLEFG","header":{"num_readonly_signed_accounts":0,"num_readonly_unsigned_accounts":3,"num_required_signatures":1},"instructions":[{"raw":{"account_indexes":[1,3,2,0],"accounts":"DHdYsTEsd1wGrmthR1ognfRXPkWBmxAWAv2pKdAix3HY,SysvarS1otHashes111111111111111111111111111,SysvarC1ock11111111111111111111111111111111,D8izqaR979Fc2amDoGHmYqEugjckEi1RQL1Y1JKyHUwX","data":"2ZjTR1vUs2pHXyTM654NvMLxNNEnyzg3FA11yGaXSzmQfbB1dvqqKtnN2zJZUdhjpAoqBb3M3gye9Dghi7q","program_account":"Vote111111111111111111111111111111111111111","program_index":4},"readable":{"details":{"hash":"9yoSeo4kEjumeyYFfohaCUYyjsu134xhXbrAxumCmysC","slots":"142209632","sysvar_clock":"SysvarC1ock11111111111111111111111111111111","sysvar_slot_hashes":"SysvarS1otHashes111111111111111111111111111","timestamp":"1658224090","vote_account":"DHdYsTEsd1wGrmthR1ognfRXPkWBmxAWAv2pKdAix3HY","vote_authority_pubkey":"D8izqaR979Fc2amDoGHmYqEugjckEi1RQL1Y1JKyHUwX"},"method_name":"Vote","overview":{"hash":"9yoSeo4kEjumeyYFfohaCUYyjsu134xhXbrAxumCmysC","slots":"142209632","timestamp":"1658224090","vote_account":"DHdYsTEsd1wGrmthR1ognfRXPkWBmxAWAv2pKdAix3HY"},"program_name":"Vote"}}]}).to_string())
    }

    #[test]
    fn test_transaction_3() {
        // System.CreateAccount + Token.InitializeMint + AToken.CreateAssociatedAccount + Custom Program
        // TODO: test InitialMint, CreateAssociatedAccount in this transaction
        // https://solscan.io/tx/34YhTdSXdcXF5DQ29rhLrvt7GtCYGHYJMtchpHotfsRx3TGdDm8scoNKhGY77s6r9hxQPoXQ7f2d1k1nA8aKdmKk
        let json = read_message("0200050a06852df21778a462ea79aae81500eae98a935dcca05f8b899ca8b41021a79980acc933a10d87058ad3131361cd345fe95eb7598ad52d972ee559f1ea3f8deb452bb2df65fdf1ad0514f549457e4338bb71e6885354aa5ed87969ef14f5fc736772295dfa0330919867f6f90f2e334d1a56a2203ec3d4086151aab0171ca13c74b626da01ca1cb62be1bbbf9927dd0de251964d351736fd36100bb0e06f728b4100000000000000000000000000000000000000000000000000000000000000008c97258f4e2489f1bb3d1029148e0d830b5a1399daff1084048e7bd8dbe9f8590b7065b1e3d17c45389d527f6b04c3cd58b86c731aa0fdb549b6d1bc03f8294606a7d517192c5c51218cc94c3d4af17f58daee089ba1fd44e3dbd98a0000000006ddf6e1d765a193d9cbe146ceeb79ac1cb485ed5f5b37913a8cf5857eff00a92865a919afcfd4d57cf8f69e11990c98a55e4cc4389ba43c7d32184ca652adb406050200013400000000604d160000000000520000000000000006ddf6e1d765a193d9cbe146ceeb79ac1cb485ed5f5b37913a8cf5857eff00a90902010843000006852df21778a462ea79aae81500eae98a935dcca05f8b899ca8b41021a799800106852df21778a462ea79aae81500eae98a935dcca05f8b899ca8b41021a799800707030100000005087b0012000000536e65616b65722023313830333539303435000000003200000068747470733a2f2f6170692e737465706e2e636f6d2f72756e2f6e66746a736f6e2f3130332f3130363036313531353732319001010100000006852df21778a462ea79aae81500eae98a935dcca05f8b899ca8b41021a799800164010607000400010509080009030104000907010000000000000007090201000000030905080a0a010000000000000000");
        assert_eq!(json, json!({"accounts":["STEPNq2UGeGSzCyGVr2nMQAzf8xuejwqebd84wcksCK","CdV4w55UDTvcza5d6V2Y6m7TF9Xmq9MHPUBYMe9WtptL","3wajAESNoYKGMuEqgXsdhEzp2mdpkc1BTVf9dNW1Pb4a","8ge4eJpudaataASooEDNuVk4W75M5CMv5suZS6Lw25to","DG3Za1KX8Tj1TeZJy2U9nDa8qX3tyZCBYNehNy4fFsnQ","11111111111111111111111111111111","ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL","metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s","SysvarRent111111111111111111111111111111111","TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"],"block_hash":"3ihDb3AE8CY1vL4tUgN2Kj4KZybrGHvyVhnv5vfxdJ27","header":{"num_readonly_signed_accounts":0,"num_readonly_unsigned_accounts":5,"num_required_signatures":2},"instructions":[{"raw":{"account_indexes":[0,1],"accounts":"STEPNq2UGeGSzCyGVr2nMQAzf8xuejwqebd84wcksCK,CdV4w55UDTvcza5d6V2Y6m7TF9Xmq9MHPUBYMe9WtptL","data":"11114XtYk9gGfZoo968fyjNUYQJKf9gdmkGoaoBpzFv4vyaSMBn3VKxZdv7mZLzoyX5YNC","program_account":"11111111111111111111111111111111","program_index":5},"readable":{"details":{"amount":"1461600","funding_account":"STEPNq2UGeGSzCyGVr2nMQAzf8xuejwqebd84wcksCK","new_account":"CdV4w55UDTvcza5d6V2Y6m7TF9Xmq9MHPUBYMe9WtptL","owner":"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA","space":"82"},"method_name":"CreateAccount","overview":{"amount":"1461600","funding_account":"STEPNq2UGeGSzCyGVr2nMQAzf8xuejwqebd84wcksCK","new_account":"CdV4w55UDTvcza5d6V2Y6m7TF9Xmq9MHPUBYMe9WtptL"},"program_name":"System"}},{"raw":{"account_indexes":[1,8],"accounts":"CdV4w55UDTvcza5d6V2Y6m7TF9Xmq9MHPUBYMe9WtptL,SysvarRent111111111111111111111111111111111","data":"11aNbEGym5ZbhL9jG3H2GJLxvX5FrZdNE6dYA1WvE94LzewqKD6uvACgcF4ebDPca9AT4oix8XzgBPJyMf7HtpUBTm","program_account":"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA","program_index":9},"readable":{"details":{"decimals":0,"freeze_authority_pubkey":"STEPNq2UGeGSzCyGVr2nMQAzf8xuejwqebd84wcksCK","mint":"CdV4w55UDTvcza5d6V2Y6m7TF9Xmq9MHPUBYMe9WtptL","mint_authority_pubkey":"STEPNq2UGeGSzCyGVr2nMQAzf8xuejwqebd84wcksCK","sysver_rent":"SysvarRent111111111111111111111111111111111"},"method_name":"InitializeMint","overview":{"decimals":0,"freeze_authority_pubkey":"STEPNq2UGeGSzCyGVr2nMQAzf8xuejwqebd84wcksCK","mint":"CdV4w55UDTvcza5d6V2Y6m7TF9Xmq9MHPUBYMe9WtptL","mint_authority_pubkey":"STEPNq2UGeGSzCyGVr2nMQAzf8xuejwqebd84wcksCK"},"program_name":"Token"}},{"raw":{"account_indexes":[3,1,0,0,0,5,8],"accounts":"8ge4eJpudaataASooEDNuVk4W75M5CMv5suZS6Lw25to,CdV4w55UDTvcza5d6V2Y6m7TF9Xmq9MHPUBYMe9WtptL,STEPNq2UGeGSzCyGVr2nMQAzf8xuejwqebd84wcksCK,STEPNq2UGeGSzCyGVr2nMQAzf8xuejwqebd84wcksCK,STEPNq2UGeGSzCyGVr2nMQAzf8xuejwqebd84wcksCK,11111111111111111111111111111111,SysvarRent111111111111111111111111111111111","data":"1qc9PgwVveMHiKRmHs9DiE9zqA86thPyaoFr5WTuiGT72BNznAsUGa92jw27ZKojtPXtBH7C9jvSf6AE8JQ3aVfowUV6ZtZMkTxM6v6FKZRuRN4cMvETyxcCvAAUJhWRnp4iEmD5VcxNfiLx9E8UbCKeiEJHMNVD6riSoF6","program_account":"metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s","program_index":7},"readable":"Unable to parse instruction, reason: Program `metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s` is not supported yet"},{"raw":{"account_indexes":[0,4,0,1,5,9,8],"accounts":"STEPNq2UGeGSzCyGVr2nMQAzf8xuejwqebd84wcksCK,DG3Za1KX8Tj1TeZJy2U9nDa8qX3tyZCBYNehNy4fFsnQ,STEPNq2UGeGSzCyGVr2nMQAzf8xuejwqebd84wcksCK,CdV4w55UDTvcza5d6V2Y6m7TF9Xmq9MHPUBYMe9WtptL,11111111111111111111111111111111,TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA,SysvarRent111111111111111111111111111111111","data":"","program_account":"ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL","program_index":6},"readable":"Unable to parse instruction, reason: Program `ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL` is not supported yet"},{"raw":{"account_indexes":[1,4,0],"accounts":"CdV4w55UDTvcza5d6V2Y6m7TF9Xmq9MHPUBYMe9WtptL,DG3Za1KX8Tj1TeZJy2U9nDa8qX3tyZCBYNehNy4fFsnQ,STEPNq2UGeGSzCyGVr2nMQAzf8xuejwqebd84wcksCK","data":"6AuM4xMCPFhR","program_account":"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA","program_index":9},"readable":{"details":{"amount":"1","mint":"CdV4w55UDTvcza5d6V2Y6m7TF9Xmq9MHPUBYMe9WtptL","mint_authority_pubkey":"STEPNq2UGeGSzCyGVr2nMQAzf8xuejwqebd84wcksCK","mint_to_account":"DG3Za1KX8Tj1TeZJy2U9nDa8qX3tyZCBYNehNy4fFsnQ"},"method_name":"MintTo","overview":{"amount":"1","mint":"CdV4w55UDTvcza5d6V2Y6m7TF9Xmq9MHPUBYMe9WtptL","mint_to_account":"DG3Za1KX8Tj1TeZJy2U9nDa8qX3tyZCBYNehNy4fFsnQ"},"program_name":"Token"}},{"raw":{"account_indexes":[2,1,0,0,0,3,9,5,8],"accounts":"3wajAESNoYKGMuEqgXsdhEzp2mdpkc1BTVf9dNW1Pb4a,CdV4w55UDTvcza5d6V2Y6m7TF9Xmq9MHPUBYMe9WtptL,STEPNq2UGeGSzCyGVr2nMQAzf8xuejwqebd84wcksCK,STEPNq2UGeGSzCyGVr2nMQAzf8xuejwqebd84wcksCK,STEPNq2UGeGSzCyGVr2nMQAzf8xuejwqebd84wcksCK,8ge4eJpudaataASooEDNuVk4W75M5CMv5suZS6Lw25to,TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA,11111111111111111111111111111111,SysvarRent111111111111111111111111111111111","data":"ZbhHTZcMWdXcj","program_account":"metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s","program_index":7},"readable":"Unable to parse instruction, reason: Program `metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s` is not supported yet"}]}).to_string())
    }

    #[test]
    fn test_transaction_4() {
        // System.CreateAccount + Token.InitializeAccount + Token.TokenTransfer + Token.CloseAccount
        // https://solscan.io/tx/5mSjiAapKzn7TEDWH3pkmNUYXSvmVyAAyF3zTEbmX9AosdfiC1dEbsQnNgDhUDBpNoYmSnPS99HPaBsKsakGR1hf
        let json = read_message("02000407e9940f6435ae992ddbb4ac739ada475fde93bd54c6a9f36a8b60b37fe23ec3fdd8ffff8ad461ca3138f356758b148f2dffa7d055a79356b52727298026189ae82e6df8bd210e5f167971908e8746aa6790aa3bc74ee48a4bbf23236f9effaa65069b8857feab8184fb687f634618c035dac439dc1aeb3b5598a0f0000000000106a7d517192c5c51218cc94c3d4af17f58daee089ba1fd44e3dbd98a00000000000000000000000000000000000000000000000000000000000000000000000006ddf6e1d765a193d9cbe146ceeb79ac1cb485ed5f5b37913a8cf5857eff00a9bff514b7cba346fe333553de5579d50a7da74cf950dd7bdd27327ce9a17c876f04050200013400000000f01d1f0000000000a50000000000000006ddf6e1d765a193d9cbe146ceeb79ac1cb485ed5f5b37913a8cf5857eff00a9060401030004010106030201000903242d84be0000000006030100000109");
        assert_eq!(json, json!({"accounts":["GinwSnwbsjkWXkancBr5E6EPrQtKdwnE5vPdriv1tK3i","Fc5UC9wa32FVzeFB2ijduV4R5nnGQu4dXH8ZrRUCSHMh","48F1neXh5bGgKr8G6CM6tFZkaC51UgtVb5pqGLC27Doi","So11111111111111111111111111111111111111112","SysvarRent111111111111111111111111111111111","11111111111111111111111111111111","TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"],"block_hash":"DvKd2LtXHva6tkZSp4EQUFGk23t7tjUEDK6XHXzfzF1G","header":{"num_readonly_signed_accounts":0,"num_readonly_unsigned_accounts":4,"num_required_signatures":2},"instructions":[{"raw":{"account_indexes":[0,1],"accounts":"GinwSnwbsjkWXkancBr5E6EPrQtKdwnE5vPdriv1tK3i,Fc5UC9wa32FVzeFB2ijduV4R5nnGQu4dXH8ZrRUCSHMh","data":"11119os1e9qSs2u7TsThXqkBSRVFxhmYaFKFZ1waB2X7armDmvK3p5GmLdUxYdg3h7QSrL","program_account":"11111111111111111111111111111111","program_index":5},"readable":{"details":{"amount":"2039280","funding_account":"GinwSnwbsjkWXkancBr5E6EPrQtKdwnE5vPdriv1tK3i","new_account":"Fc5UC9wa32FVzeFB2ijduV4R5nnGQu4dXH8ZrRUCSHMh","owner":"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA","space":"165"},"method_name":"CreateAccount","overview":{"amount":"2039280","funding_account":"GinwSnwbsjkWXkancBr5E6EPrQtKdwnE5vPdriv1tK3i","new_account":"Fc5UC9wa32FVzeFB2ijduV4R5nnGQu4dXH8ZrRUCSHMh"},"program_name":"System"}},{"raw":{"account_indexes":[1,3,0,4],"accounts":"Fc5UC9wa32FVzeFB2ijduV4R5nnGQu4dXH8ZrRUCSHMh,So11111111111111111111111111111111111111112,GinwSnwbsjkWXkancBr5E6EPrQtKdwnE5vPdriv1tK3i,SysvarRent111111111111111111111111111111111","data":"2","program_account":"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA","program_index":6},"readable":{"details":{"account":"Fc5UC9wa32FVzeFB2ijduV4R5nnGQu4dXH8ZrRUCSHMh","mint":"So11111111111111111111111111111111111111112","owner":"GinwSnwbsjkWXkancBr5E6EPrQtKdwnE5vPdriv1tK3i","sysver_rent":"SysvarRent111111111111111111111111111111111"},"method_name":"InitializeAccount","overview":{"account":"Fc5UC9wa32FVzeFB2ijduV4R5nnGQu4dXH8ZrRUCSHMh","mint":"So11111111111111111111111111111111111111112"},"program_name":"Token"}},{"raw":{"account_indexes":[2,1,0],"accounts":"48F1neXh5bGgKr8G6CM6tFZkaC51UgtVb5pqGLC27Doi,Fc5UC9wa32FVzeFB2ijduV4R5nnGQu4dXH8ZrRUCSHMh,GinwSnwbsjkWXkancBr5E6EPrQtKdwnE5vPdriv1tK3i","data":"3KWXrv5AxkoZ","program_account":"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA","program_index":6},"readable":{"details":{"amount":"3196333348","owner":"GinwSnwbsjkWXkancBr5E6EPrQtKdwnE5vPdriv1tK3i","recipient":"Fc5UC9wa32FVzeFB2ijduV4R5nnGQu4dXH8ZrRUCSHMh","source_account":"48F1neXh5bGgKr8G6CM6tFZkaC51UgtVb5pqGLC27Doi"},"method_name":"Transfer","overview":{"amount":"3196333348","recipient":"Fc5UC9wa32FVzeFB2ijduV4R5nnGQu4dXH8ZrRUCSHMh","source_account":"48F1neXh5bGgKr8G6CM6tFZkaC51UgtVb5pqGLC27Doi"},"program_name":"Token"}},{"raw":{"account_indexes":[1,0,0],"accounts":"Fc5UC9wa32FVzeFB2ijduV4R5nnGQu4dXH8ZrRUCSHMh,GinwSnwbsjkWXkancBr5E6EPrQtKdwnE5vPdriv1tK3i,GinwSnwbsjkWXkancBr5E6EPrQtKdwnE5vPdriv1tK3i","data":"A","program_account":"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA","program_index":6},"readable":{"details":{"account":"Fc5UC9wa32FVzeFB2ijduV4R5nnGQu4dXH8ZrRUCSHMh","owner":"GinwSnwbsjkWXkancBr5E6EPrQtKdwnE5vPdriv1tK3i","recipient":"GinwSnwbsjkWXkancBr5E6EPrQtKdwnE5vPdriv1tK3i"},"method_name":"Burn","overview":{"account":"Fc5UC9wa32FVzeFB2ijduV4R5nnGQu4dXH8ZrRUCSHMh","recipient":"GinwSnwbsjkWXkancBr5E6EPrQtKdwnE5vPdriv1tK3i"},"program_name":"Token"}}]}).to_string())
    }

    #[test]
    fn test_transaction_5() {
        // Memo + AToken.CreateAssociatedAccount + Token.SetAuthority
        // https://solscan.io/tx/55gHV4rWvLbyz7V5rhn3NeMPMKKiuhHJbLRSwLqzCc2482jeowmc93UJuCD7h3GpB1E3pVdDETZQu3CBFZSnAXJS
        let json = read_message("0201060908a13fb5c9e7bc18aef6d4ec2e5bca9fb0b8c329c32bdf2baae9125aa3191cd36eeb5c79927943eef87a2828925665d2b3612a070fe5eee74680d8ac0b779ca136a3ae0cda1d97779bcd08c24409fe1c76f84f218aeed3296d8efe2dade261a606a7d517192c5c51218cc94c3d4af17f58daee089ba1fd44e3dbd98a0000000006ddf6e1d765a193d9cbe146ceeb79ac1cb485ed5f5b37913a8cf5857eff00a90b3338a0ab2cc841d5b014bc6a3cf756291874b319c9517d9bbfa9e4e9661ef90000000000000000000000000000000000000000000000000000000000000000054a5350f85dc882d614a55672788a296ddf1eababd0a60678884932f4eef6a08c97258f4e2489f1bb3d1029148e0d830b5a1399daff1084048e7bd8dbe9f859704b00127cf4d5d2ca44446993ee3bab439ce957bde518d1767b108b87a4a7d00307002c416141414141414141414141414141414141414141414141414141414141414141414141414141414141413d08070002010506040300040202012306030108a13fb5c9e7bc18aef6d4ec2e5bca9fb0b8c329c32bdf2baae9125aa3191cd3");
        assert_eq!(json, json!({"accounts":["agsWhfJ5PPGjmzMieWY8BR5o1XRVszUBQ5uFz4CtDiJ","8Tz15moyu4eL48o4Pq5XLyxX5XkkKEsNcgx27ycaPLaU","4gHmx6Puk1J9YntAUvnyrXP68SmjCvQocuArQCt5o4p5","SysvarRent111111111111111111111111111111111","TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA","kinXdEcpDQeHPEuQnqmUgtYykqKGVFq6CeVX5iAHJq6","11111111111111111111111111111111","Memo1UhkJRfHyvLMcVucJwxXeuD728EqVDDwQDxFMNo","ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"],"block_hash":"8ZLzai689nErJVd5CW74QnPqT3HDs9Uwc4SC2CRgwaPH","header":{"num_readonly_signed_accounts":1,"num_readonly_unsigned_accounts":6,"num_required_signatures":2},"instructions":[{"raw":{"account_indexes":[],"accounts":"","data":"NFw4Tg8NvoG7NVDGdoferkiJmQTGJ6esGoTc6W89Z9HRabSLuLYYjs6qwPmW","program_account":"Memo1UhkJRfHyvLMcVucJwxXeuD728EqVDDwQDxFMNo","program_index":7},"readable":"Unable to parse instruction, reason: Program `Memo1UhkJRfHyvLMcVucJwxXeuD728EqVDDwQDxFMNo` is not supported yet"},{"raw":{"account_indexes":[0,2,1,5,6,4,3],"accounts":"agsWhfJ5PPGjmzMieWY8BR5o1XRVszUBQ5uFz4CtDiJ,4gHmx6Puk1J9YntAUvnyrXP68SmjCvQocuArQCt5o4p5,8Tz15moyu4eL48o4Pq5XLyxX5XkkKEsNcgx27ycaPLaU,kinXdEcpDQeHPEuQnqmUgtYykqKGVFq6CeVX5iAHJq6,11111111111111111111111111111111,TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA,SysvarRent111111111111111111111111111111111","data":"","program_account":"ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL","program_index":8},"readable":"Unable to parse instruction, reason: Program `ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL` is not supported yet"},{"raw":{"account_indexes":[2,1],"accounts":"4gHmx6Puk1J9YntAUvnyrXP68SmjCvQocuArQCt5o4p5,8Tz15moyu4eL48o4Pq5XLyxX5XkkKEsNcgx27ycaPLaU","data":"bnu16WJX3yyY2rzoPSifzd3mq5vHtA5WZbxnfUmvV1MheRp","program_account":"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA","program_index":4},"readable":{"details":{"account":"4gHmx6Puk1J9YntAUvnyrXP68SmjCvQocuArQCt5o4p5","authority_type":"close account","new_authority_pubkey":"agsWhfJ5PPGjmzMieWY8BR5o1XRVszUBQ5uFz4CtDiJ","old_authority_pubkey":"8Tz15moyu4eL48o4Pq5XLyxX5XkkKEsNcgx27ycaPLaU"},"method_name":"SetAuthority","overview":{"account":"4gHmx6Puk1J9YntAUvnyrXP68SmjCvQocuArQCt5o4p5","authority_type":"close account","new_authority_pubkey":"agsWhfJ5PPGjmzMieWY8BR5o1XRVszUBQ5uFz4CtDiJ","old_authority_pubkey":"8Tz15moyu4eL48o4Pq5XLyxX5XkkKEsNcgx27ycaPLaU"},"program_name":"Token"}}]}).to_string());
    }

    #[test]
    fn test_transaction_6() {
        // Token.Approve
        // https://solscan.io/tx/zf2KZX8S9BavoYxuxYrX47BmDY9YEdeMSzeCxakDoMGBCr7qYHjHAuEj5Qt2k6hV12XJKBGNAfsqLPPyPjthy5B
        let json = read_message("0301070faa30697d8ea2d14ce506c401ad5f1bd33476ebcb8a8b5cea89fa0aafb7c04f3925070f12913aa23553bfaf08f0a6f293aadb24dd66711db239c9b0ccca751b05dcc3a6c16cb67f59d67085e174cd7469f3e00b99a63d6c8d95337096f9e8437d8c17a1e64eba64bb7238d33b21461db8824508c879f91199d9eff9309ff63952baf04e4356057aaea057a6d744e1a0dbb99091448d6c2807114f0a016c9f2c39df8b1e991b87277d51b2ee23b63496ff1a54ab30e61eb4c4572e52fb99af9421e636e5095d76cede0e72ff2a024a07652d423fb7f3978a4663a278d13e1c1ba10deb821d34b39060c73598d3dd86ecf853df3b2f38b02991ad2ccfa51306e01600000000000000000000000000000000000000000000000000000000000000003f5877e18f96dea58c638a21d2be860ba96f0e21d1d84c6a94dba44e2be81f0e494500f4fdcbc9ad22814e250c0d6763266f6ca9169e12662f477601991e1a36be49a1eeb81bf889c158fd8b7496ff9141d4aa433eae3948d0d8488f78951b78069b8857feab8184fb687f634618c035dac439dc1aeb3b5598a0f0000000000106a7d517192c5c51218cc94c3d4af17f58daee089ba1fd44e3dbd98a0000000006ddf6e1d765a193d9cbe146ceeb79ac1cb485ed5f5b37913a8cf5857eff00a954c495b382bac905bb70f97bc252b2ee3b796b2836a3287ed5787c70eb2484120608020001340000000030266d0500000000a50000000000000006ddf6e1d765a193d9cbe146ceeb79ac1cb485ed5f5b37913a8cf5857eff00a90e04010c000d01010e03010200090440084e05000000000b0a090a020106030504070e110140084e05000000005d4d3700000000000e02010001050e030100000109");
        assert_eq!(json, json!({"accounts":["CTM8DpiZXt1R85fxY4NM85P5t3QqR4Wjm1V85Z8EjVCC","3VYL1TrNMJFQaLy3SC9jAe9gNgymPgQgcZQNUzcc6M3i","FrmjFyCUdgrZfps1cJ7B3BTLnj9jjEJ34MwZncJBCxaG","ARryk4nSoS6bu7nyv6BgQah8oU23svFm7Rek7kR4fy3X","DajMqwbJXA7JbqgU97zycA1zReQhmTqf1YjNNQjo6gCQ","G3cxNKQvwnLDFEtRugKABmhUnf9BkhcV3n3pz1QgHLtQ","GVfKYBNMdaER21wwuqa4CSQV8ajVpuPbNZVV3wcuKWhE","wLavAJvGZa6Try8jxPRLc9AXBN4yCLF2qpFKbRNB4wF","11111111111111111111111111111111","5GGvkcqQ1554ibdc18JXiPqR8aJz6WV3JSNShoj32ufT","5w1nmqvpus3UfpP67EpYuHhE63aSFdF5AT8VHZTkvnp5","Dooar9JkhdZ7J3LHN3A7YCuoGRUggXhQaG4kijfLGU2j","So11111111111111111111111111111111111111112","SysvarRent111111111111111111111111111111111","TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"],"block_hash":"6hu7DYzTwbg82Yw2c9yUGiuf5fFLccdvWLUyjYbafqdj","header":{"num_readonly_signed_accounts":1,"num_readonly_unsigned_accounts":7,"num_required_signatures":3},"instructions":[{"raw":{"account_indexes":[0,1],"accounts":"CTM8DpiZXt1R85fxY4NM85P5t3QqR4Wjm1V85Z8EjVCC,3VYL1TrNMJFQaLy3SC9jAe9gNgymPgQgcZQNUzcc6M3i","data":"11112mSibg2jPYkce37WqtWKZAsCdVzCYHNwDsAvX3a328yq65cStepo3P2qyd9wGCvoLC","program_account":"11111111111111111111111111111111","program_index":8},"readable":{"details":{"amount":"91039280","funding_account":"CTM8DpiZXt1R85fxY4NM85P5t3QqR4Wjm1V85Z8EjVCC","new_account":"3VYL1TrNMJFQaLy3SC9jAe9gNgymPgQgcZQNUzcc6M3i","owner":"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA","space":"165"},"method_name":"CreateAccount","overview":{"amount":"91039280","funding_account":"CTM8DpiZXt1R85fxY4NM85P5t3QqR4Wjm1V85Z8EjVCC","new_account":"3VYL1TrNMJFQaLy3SC9jAe9gNgymPgQgcZQNUzcc6M3i"},"program_name":"System"}},{"raw":{"account_indexes":[1,12,0,13],"accounts":"3VYL1TrNMJFQaLy3SC9jAe9gNgymPgQgcZQNUzcc6M3i,So11111111111111111111111111111111111111112,CTM8DpiZXt1R85fxY4NM85P5t3QqR4Wjm1V85Z8EjVCC,SysvarRent111111111111111111111111111111111","data":"2","program_account":"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA","program_index":14},"readable":{"details":{"account":"3VYL1TrNMJFQaLy3SC9jAe9gNgymPgQgcZQNUzcc6M3i","mint":"So11111111111111111111111111111111111111112","owner":"CTM8DpiZXt1R85fxY4NM85P5t3QqR4Wjm1V85Z8EjVCC","sysver_rent":"SysvarRent111111111111111111111111111111111"},"method_name":"InitializeAccount","overview":{"account":"3VYL1TrNMJFQaLy3SC9jAe9gNgymPgQgcZQNUzcc6M3i","mint":"So11111111111111111111111111111111111111112"},"program_name":"Token"}},{"raw":{"account_indexes":[1,2,0],"accounts":"3VYL1TrNMJFQaLy3SC9jAe9gNgymPgQgcZQNUzcc6M3i,FrmjFyCUdgrZfps1cJ7B3BTLnj9jjEJ34MwZncJBCxaG,CTM8DpiZXt1R85fxY4NM85P5t3QqR4Wjm1V85Z8EjVCC","data":"48zH6qc1xRCj","program_account":"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA","program_index":14},"readable":{"details":{"amount":"89000000","delegate_account":"FrmjFyCUdgrZfps1cJ7B3BTLnj9jjEJ34MwZncJBCxaG","owner":"CTM8DpiZXt1R85fxY4NM85P5t3QqR4Wjm1V85Z8EjVCC","source_account":"3VYL1TrNMJFQaLy3SC9jAe9gNgymPgQgcZQNUzcc6M3i"},"method_name":"Approve","overview":{"amount":"89000000","delegate_account":"FrmjFyCUdgrZfps1cJ7B3BTLnj9jjEJ34MwZncJBCxaG","source_account":"3VYL1TrNMJFQaLy3SC9jAe9gNgymPgQgcZQNUzcc6M3i"},"program_name":"Token"}},{"raw":{"account_indexes":[9,10,2,1,6,3,5,4,7,14],"accounts":"5GGvkcqQ1554ibdc18JXiPqR8aJz6WV3JSNShoj32ufT,5w1nmqvpus3UfpP67EpYuHhE63aSFdF5AT8VHZTkvnp5,FrmjFyCUdgrZfps1cJ7B3BTLnj9jjEJ34MwZncJBCxaG,3VYL1TrNMJFQaLy3SC9jAe9gNgymPgQgcZQNUzcc6M3i,GVfKYBNMdaER21wwuqa4CSQV8ajVpuPbNZVV3wcuKWhE,ARryk4nSoS6bu7nyv6BgQah8oU23svFm7Rek7kR4fy3X,G3cxNKQvwnLDFEtRugKABmhUnf9BkhcV3n3pz1QgHLtQ,DajMqwbJXA7JbqgU97zycA1zReQhmTqf1YjNNQjo6gCQ,wLavAJvGZa6Try8jxPRLc9AXBN4yCLF2qpFKbRNB4wF,TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA","data":"gX6pJKFn9nTGZYN6UfFFps","program_account":"Dooar9JkhdZ7J3LHN3A7YCuoGRUggXhQaG4kijfLGU2j","program_index":11},"readable":"Unable to parse instruction, reason: Program `Dooar9JkhdZ7J3LHN3A7YCuoGRUggXhQaG4kijfLGU2j` is not supported yet"},{"raw":{"account_indexes":[1,0],"accounts":"3VYL1TrNMJFQaLy3SC9jAe9gNgymPgQgcZQNUzcc6M3i,CTM8DpiZXt1R85fxY4NM85P5t3QqR4Wjm1V85Z8EjVCC","data":"6","program_account":"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA","program_index":14},"readable":{"details":{"owner":"CTM8DpiZXt1R85fxY4NM85P5t3QqR4Wjm1V85Z8EjVCC","source_account":"3VYL1TrNMJFQaLy3SC9jAe9gNgymPgQgcZQNUzcc6M3i"},"method_name":"Revoke","overview":{"source_account":"3VYL1TrNMJFQaLy3SC9jAe9gNgymPgQgcZQNUzcc6M3i"},"program_name":"Token"}},{"raw":{"account_indexes":[1,0,0],"accounts":"3VYL1TrNMJFQaLy3SC9jAe9gNgymPgQgcZQNUzcc6M3i,CTM8DpiZXt1R85fxY4NM85P5t3QqR4Wjm1V85Z8EjVCC,CTM8DpiZXt1R85fxY4NM85P5t3QqR4Wjm1V85Z8EjVCC","data":"A","program_account":"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA","program_index":14},"readable":{"details":{"account":"3VYL1TrNMJFQaLy3SC9jAe9gNgymPgQgcZQNUzcc6M3i","owner":"CTM8DpiZXt1R85fxY4NM85P5t3QqR4Wjm1V85Z8EjVCC","recipient":"CTM8DpiZXt1R85fxY4NM85P5t3QqR4Wjm1V85Z8EjVCC"},"method_name":"Burn","overview":{"account":"3VYL1TrNMJFQaLy3SC9jAe9gNgymPgQgcZQNUzcc6M3i","recipient":"CTM8DpiZXt1R85fxY4NM85P5t3QqR4Wjm1V85Z8EjVCC"},"program_name":"Token"}}]}).to_string());
    }

    #[test]
    fn test_transaction_7() {
        // System.CreateAccountWithSeed + Stake: Initialize + Stake: Delegate
        // https://solscan.io/tx/UxNDLmLJb1nR9sx3Q4xnELJZuneM4W9WBfb2pwBYDjWfCHxpWqCGgjpUsrwqMAFzfkCCNDj4AUpzvguSQ8tDHEk
        let json = read_message("010007096aefb992fa0cd54aea185bf65a7da92aad6bd46da5a67c7675a04e6540d86f7a3d2ce2421048aa748a6cc22b5696032f902cfc0b3dd6bce0d379f76c383bceda0000000000000000000000000000000000000000000000000000000000000000e23a2b23b625e7513991be370a2c20d5c5e276491d36777ef2e5b1227ffe732906a1d8179137542a983437bdfe2a7ab2557f535c8a78722b68a49dc00000000006a1d817a502050b680791e6ce6db88e1e5b7150f61fc6790a4eb4d10000000006a7d51718c774c928566398691d5eb68b5eb8a39b4b6d5c73555b210000000006a7d517192c5c51218cc94c3d4af17f58daee089ba1fd44e3dbd98a0000000006a7d517193584d0feed9bb3431d13206be544281b57b8566cc5375ff4000000aada712c5d14f4e64d913b330ff3e519bc7f2aac580997f0c549620601866915030202000174030000006aefb992fa0cd54aea185bf65a7da92aad6bd46da5a67c7675a04e6540d86f7a18000000000000007374616b653a302e3231363239323431373439393638393500de2a9200000000c80000000000000006a1d8179137542a983437bdfe2a7ab2557f535c8a78722b68a49dc0000000000402010774000000006aefb992fa0cd54aea185bf65a7da92aad6bd46da5a67c7675a04e6540d86f7a6aefb992fa0cd54aea185bf65a7da92aad6bd46da5a67c7675a04e6540d86f7a00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004060103060805000402000000");
        assert_eq!(json, json!({"accounts":["8CSELK4udyP5M3XU3nNRc9N8zfqL3Z6zFybiz3Bm9beH","57oZmoSzqF5at3ioAV7h849mUa6FKdu98ig3FwmjS4Nd","11111111111111111111111111111111","GE6atKoWiQ2pt3zL7N13pjNHjdLVys8LinG8qeJLcAiL","Stake11111111111111111111111111111111111111","StakeConfig11111111111111111111111111111111","SysvarC1ock11111111111111111111111111111111","SysvarRent111111111111111111111111111111111","SysvarStakeHistory1111111111111111111111111"],"block_hash":"CVwVzgVbSKbSeybxUsvKTDgCt5tkVuEsWVkZaEy3sk6x","header":{"num_readonly_signed_accounts":0,"num_readonly_unsigned_accounts":7,"num_required_signatures":1},"instructions":[{"raw":{"account_indexes":[0,1],"accounts":"8CSELK4udyP5M3XU3nNRc9N8zfqL3Z6zFybiz3Bm9beH,57oZmoSzqF5at3ioAV7h849mUa6FKdu98ig3FwmjS4Nd","data":"4gmm6vheLREbsXu6JNWuTBnSdJf4LHBSetvxrTTRap8ujutQ9hzKFHxcLnkLeVCS1twH9qY8fwgu9Dbks4DSHVkbf4pjHvo4yr2m6LEFfZzqvJjnPM8t3rMbBWHhHGTWKchiPFKXReTuEyQvpssg4hFW6xKyLs","program_account":"11111111111111111111111111111111","program_index":2},"readable":{"details":{"amount":"2452282880","base_account":null,"base_pubkey":"8CSELK4udyP5M3XU3nNRc9N8zfqL3Z6zFybiz3Bm9beH","funding_account":"8CSELK4udyP5M3XU3nNRc9N8zfqL3Z6zFybiz3Bm9beH","new_account":"57oZmoSzqF5at3ioAV7h849mUa6FKdu98ig3FwmjS4Nd","owner":"Stake11111111111111111111111111111111111111","seed":"stake:0.2162924174996895","space":"200"},"method_name":"CreateAccountWithSeed","overview":{"amount":"2452282880","base_pubkey":"8CSELK4udyP5M3XU3nNRc9N8zfqL3Z6zFybiz3Bm9beH","funding_account":"8CSELK4udyP5M3XU3nNRc9N8zfqL3Z6zFybiz3Bm9beH","new_account":"57oZmoSzqF5at3ioAV7h849mUa6FKdu98ig3FwmjS4Nd","seed":"stake:0.2162924174996895","space":"200"},"program_name":"System"}},{"raw":{"account_indexes":[1,7],"accounts":"57oZmoSzqF5at3ioAV7h849mUa6FKdu98ig3FwmjS4Nd,SysvarRent111111111111111111111111111111111","data":"1111M5VGXdRTNyvFXopVKSaUzFxt4rov9gyD1qojEpE8xyqR66tSfH2vXdTbjmEUPZNgMZ6Leet3FDuwrHMN15jbNukNoxyxkaCnMaZAz8VJmEKK8wuJ7RnV8i5UWFA21ADh5xRknDDcAzyyaKBNLEiU1uLes","program_account":"Stake11111111111111111111111111111111111111","program_index":4},"readable":{"details":{"custodian":"11111111111111111111111111111111","epoch":0,"stake_account":"57oZmoSzqF5at3ioAV7h849mUa6FKdu98ig3FwmjS4Nd","staker":"8CSELK4udyP5M3XU3nNRc9N8zfqL3Z6zFybiz3Bm9beH","sysvar_rent":"SysvarRent111111111111111111111111111111111","timestamp":0,"withdrawer":"8CSELK4udyP5M3XU3nNRc9N8zfqL3Z6zFybiz3Bm9beH"},"method_name":"Initialize","overview":{"custodian":"11111111111111111111111111111111","epoch":0,"stake_account":"57oZmoSzqF5at3ioAV7h849mUa6FKdu98ig3FwmjS4Nd","staker":"8CSELK4udyP5M3XU3nNRc9N8zfqL3Z6zFybiz3Bm9beH","timestamp":0,"withdrawer":"8CSELK4udyP5M3XU3nNRc9N8zfqL3Z6zFybiz3Bm9beH"},"program_name":"Stake"}},{"raw":{"account_indexes":[1,3,6,8,5,0],"accounts":"57oZmoSzqF5at3ioAV7h849mUa6FKdu98ig3FwmjS4Nd,GE6atKoWiQ2pt3zL7N13pjNHjdLVys8LinG8qeJLcAiL,SysvarC1ock11111111111111111111111111111111,SysvarStakeHistory1111111111111111111111111,StakeConfig11111111111111111111111111111111,8CSELK4udyP5M3XU3nNRc9N8zfqL3Z6zFybiz3Bm9beH","data":"3xyZh","program_account":"Stake11111111111111111111111111111111111111","program_index":4},"readable":{"details":{"config_account":"StakeConfig11111111111111111111111111111111","stake_account":"57oZmoSzqF5at3ioAV7h849mUa6FKdu98ig3FwmjS4Nd","stake_authority_pubkey":"8CSELK4udyP5M3XU3nNRc9N8zfqL3Z6zFybiz3Bm9beH","sysvar_clock":"SysvarC1ock11111111111111111111111111111111","sysvar_stake_history":"SysvarStakeHistory1111111111111111111111111","vote_account":"GE6atKoWiQ2pt3zL7N13pjNHjdLVys8LinG8qeJLcAiL"},"method_name":"DelegateStake","overview":{"config_account":"StakeConfig11111111111111111111111111111111","stake_account":"57oZmoSzqF5at3ioAV7h849mUa6FKdu98ig3FwmjS4Nd","vote_account":"GE6atKoWiQ2pt3zL7N13pjNHjdLVys8LinG8qeJLcAiL"},"program_name":"Stake"}}]}).to_string());
    }

    #[test]
    fn test_transaction_8() {
        // Stake: Withdraw
        // https://solscan.io/tx/4UDXRHMzzfFFnayfbR5pmRvdn3YqPwvYb7s5TkoL92osGGagENpfYXLFnK5guZ7187Dd3eNjDFDMkBd7jixpDfnG
        let json = read_message("01000305575949043cea1e1713d06b6b2eba6bb22d303884908e683fcaaa7b0ba6209be859d521dc428449106dabb34dadd3b44cc7795f58be0d4a81aaeaada967b21bd206a1d8179137542a983437bdfe2a7ab2557f535c8a78722b68a49dc00000000006a7d51718c774c928566398691d5eb68b5eb8a39b4b6d5c73555b210000000006a7d517193584d0feed9bb3431d13206be544281b57b8566cc5375ff400000067415e51677a2d98e9f86da5c65fe4c72bdee5cb2755af7a27d13dda710aa26001020501000304000c04000000ed77410300000000");
        assert_eq!(json, json!({"accounts":["6sySB1243EqqtMsExjNwmbouFVksZAF6w6bGe99V2CgX","73fnG8GC1ZanZSVv86re4kQsbrsiLP7xPCvXizCs9XW9","Stake11111111111111111111111111111111111111","SysvarC1ock11111111111111111111111111111111","SysvarStakeHistory1111111111111111111111111"],"block_hash":"7x4oh9xNyHE4HEozqDe3GXSjqX3cawjr7q1cDTAhXqnX","header":{"num_readonly_signed_accounts":0,"num_readonly_unsigned_accounts":3,"num_required_signatures":1},"instructions":[{"raw":{"account_indexes":[1,0,3,4,0],"accounts":"73fnG8GC1ZanZSVv86re4kQsbrsiLP7xPCvXizCs9XW9,6sySB1243EqqtMsExjNwmbouFVksZAF6w6bGe99V2CgX,SysvarC1ock11111111111111111111111111111111,SysvarStakeHistory1111111111111111111111111,6sySB1243EqqtMsExjNwmbouFVksZAF6w6bGe99V2CgX","data":"5Nvj7gS32ohGJR5Z","program_account":"Stake11111111111111111111111111111111111111","program_index":2},"readable":{"details":{"amount":"54622189","recipient":"6sySB1243EqqtMsExjNwmbouFVksZAF6w6bGe99V2CgX","stake_account":"73fnG8GC1ZanZSVv86re4kQsbrsiLP7xPCvXizCs9XW9","stake_authority_pubkey":null,"sysvar_clock":"SysvarC1ock11111111111111111111111111111111","sysvar_stake_history":"SysvarStakeHistory1111111111111111111111111","withdraw_authority_pubkey":"6sySB1243EqqtMsExjNwmbouFVksZAF6w6bGe99V2CgX"},"method_name":"Withdraw","overview":{"amount":"54622189","recipient":"6sySB1243EqqtMsExjNwmbouFVksZAF6w6bGe99V2CgX","stake_account":"73fnG8GC1ZanZSVv86re4kQsbrsiLP7xPCvXizCs9XW9"},"program_name":"Stake"}}]}).to_string());
    }

    #[test]
    fn test_transaction_9() {
        // Stake: Deactivate
        // https://solscan.io/tx/23nCgTp9zNo7e56bcFiyYgM4t4A9HGGX4z3JNPMzBxGbGExAVSMBfpkE3digYRcYbKUQfwnq3rGtEND7fD5HiT2x
        let json = read_message("010002044dd6a13d7b9ca64c690638eb9679f4a264a5a93022212ec608b24964dbc5701aff979426efda42a314f5b5477ea3264fddfb5ee1b9f939bff1e90cbea09cde3306a1d8179137542a983437bdfe2a7ab2557f535c8a78722b68a49dc00000000006a7d51718c774c928566398691d5eb68b5eb8a39b4b6d5c73555b2100000000a4eb4d5967097a0ec98783003eba3fde67341ba6d6d55f7d6987494a952466520102030103000405000000");
        assert_eq!(json, json!({"accounts":["6ErDKgZ7M1jdHp9fMWQ7mB3vmxBAWKH7YJ9FGk1qaYBK","JCj29zzZjPjZnDKVP7EyR6gordbAAYacKGkG811NepcJ","Stake11111111111111111111111111111111111111","SysvarC1ock11111111111111111111111111111111"],"block_hash":"C6mxxjU1QuPoDAJQwheeXwv6CnFt8toc11zPM7rvy4Wd","header":{"num_readonly_signed_accounts":0,"num_readonly_unsigned_accounts":2,"num_required_signatures":1},"instructions":[{"raw":{"account_indexes":[1,3,0],"accounts":"JCj29zzZjPjZnDKVP7EyR6gordbAAYacKGkG811NepcJ,SysvarC1ock11111111111111111111111111111111,6ErDKgZ7M1jdHp9fMWQ7mB3vmxBAWKH7YJ9FGk1qaYBK","data":"8QwQj","program_account":"Stake11111111111111111111111111111111111111","program_index":2},"readable":{"details":{"delegated_stake_account":"JCj29zzZjPjZnDKVP7EyR6gordbAAYacKGkG811NepcJ","stake_authority_pubkey":"6ErDKgZ7M1jdHp9fMWQ7mB3vmxBAWKH7YJ9FGk1qaYBK","sysvar_clock":"SysvarC1ock11111111111111111111111111111111"},"method_name":"Deactivate","overview":{"delegated_stake_account":"JCj29zzZjPjZnDKVP7EyR6gordbAAYacKGkG811NepcJ"},"program_name":"Stake"}}]}).to_string());
    }

    #[test]
    fn test_transaction_10() {
        // https://solscan.io/tx/3KCJ2aWgKc6cyEagFdk74WfM9eDw7VumB7rPw96fQkD1CmjG3w29gTazDEvNsc2bNbkQaZAvL2att11Siy8qF89k
        let json = read_message("0301080fae0e9965d80b3bb521ed714366a4d461fd58d7b7c97caa15564ba34c3ec5c04d940d487f489c470872533e2d8b55a5ec1ae1fd130cefae0f1bd1527a9b6955c1ab9daad5867d8a4dba28bb9b9bc4146bc81a83e877c01d693d9860e2863df6f5aaf29edc6d0d3544fccda1232277d6032783264c5cfc335600c85f30754adaa9f604b96c15a6018a88598d0c5a310fe2b6333aa48ba916e502be02578ca50384cc51e45da7f68a2906979e692c1e8bc87e51deca9ddfe7e673895a01ef80facf5f4019373457f129bf4cae6a4255518b885bf718157dd4357233dc79268c4cbf069b8857feab8184fb687f634618c035dac439dc1aeb3b5598a0f0000000000106a7d517192c5c51218cc94c3d4af17f58daee089ba1fd44e3dbd98a0000000006a7d51718c774c928566398691d5eb68b5eb8a39b4b6d5c73555b210000000023166cdfc331b06925f390147d4270172c25a5b218580326b09081a9f3bbe90c051e8a28c6a067b32fbb33323ed92334b6adbdc4639b871c8a2e44f47058ef8506ddf6e1d765a193d9cbe146ceeb79ac1cb485ed5f5b37913a8cf5857eff00a900000000000000000000000000000000000000000000000000000000000000000508c2ceb1b5d05c874980ac52cf659740e7e9b9356aaf2a0362673263526c15e83b5d0c7735cf4f76914b1488bc665d32dce3140950851428922cc65fbb565b070c03030200090424eb0700000000000d0200013400000000f01d1f0000000000a50000000000000006ddf6e1d765a193d9cbe146ceeb79ac1cb485ed5f5b37913a8cf5857eff00a90c040107000801010e02090401080e0a03010405060a0b02090c090424eb0700000000000c02030001050c03010000010901");
        assert_eq!(json, json!({"accounts":["CiSrMrPbsnr2pXFHEKXSvHqw1r29qbpRnK1qV9n7zYCC","Axw63e2KwrSmqWsZcNUQNXHH4cSfv2xEJBZG7Ua5Rrit","CYvAAqCR6LjctqdWvPe1CfBW9p5uSc85Da45gENrVSr8","CWJtEyYYHy3ydjHn5Beh48mHiW9BBHSYjcGDJkB8awNx","HZMUNJQDwT8rdEiY2r15UR6h8yYg7QkxiekjyJGFFwnB","EkabaFX962r7gbdjQ6i2kfbrjFA6XppgKZ4APeUhA7gS","7QpRNyLenfoUA8SrpDTaaurtx4JxAJ2j4zdkNUMsTa6A","So11111111111111111111111111111111111111112","SysvarRent111111111111111111111111111111111","SysvarC1ock11111111111111111111111111111111","3My6wgR1fHmDFqBvv1hys7PigtH1megLncRCh2PkBMTR","Lz3nGpTr7SfSf7eJqcoQEkXK2fSK3dfCoSdQSKxbXxQ","TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA","11111111111111111111111111111111","LendZqTs7gn5CTSJU1jWKhKuVpjJGom45nnwPb2AMTi"],"block_hash":"GdY64TjWowmh4pojKVu6ZW1mVyMXikdY3AYCoor25r8J","header":{"num_readonly_signed_accounts":1,"num_readonly_unsigned_accounts":8,"num_required_signatures":3},"instructions":[{"raw":{"account_indexes":[3,2,0],"accounts":"CWJtEyYYHy3ydjHn5Beh48mHiW9BBHSYjcGDJkB8awNx,CYvAAqCR6LjctqdWvPe1CfBW9p5uSc85Da45gENrVSr8,CiSrMrPbsnr2pXFHEKXSvHqw1r29qbpRnK1qV9n7zYCC","data":"44TEbAMwXMLK","program_account":"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA","program_index":12},"readable":{"details":{"amount":"518948","delegate_account":"CYvAAqCR6LjctqdWvPe1CfBW9p5uSc85Da45gENrVSr8","owner":"CiSrMrPbsnr2pXFHEKXSvHqw1r29qbpRnK1qV9n7zYCC","source_account":"CWJtEyYYHy3ydjHn5Beh48mHiW9BBHSYjcGDJkB8awNx"},"method_name":"Approve","overview":{"amount":"518948","delegate_account":"CYvAAqCR6LjctqdWvPe1CfBW9p5uSc85Da45gENrVSr8","source_account":"CWJtEyYYHy3ydjHn5Beh48mHiW9BBHSYjcGDJkB8awNx"},"program_name":"Token"}},{"raw":{"account_indexes":[0,1],"accounts":"CiSrMrPbsnr2pXFHEKXSvHqw1r29qbpRnK1qV9n7zYCC,Axw63e2KwrSmqWsZcNUQNXHH4cSfv2xEJBZG7Ua5Rrit","data":"11119os1e9qSs2u7TsThXqkBSRVFxhmYaFKFZ1waB2X7armDmvK3p5GmLdUxYdg3h7QSrL","program_account":"11111111111111111111111111111111","program_index":13},"readable":{"details":{"amount":"2039280","funding_account":"CiSrMrPbsnr2pXFHEKXSvHqw1r29qbpRnK1qV9n7zYCC","new_account":"Axw63e2KwrSmqWsZcNUQNXHH4cSfv2xEJBZG7Ua5Rrit","owner":"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA","space":"165"},"method_name":"CreateAccount","overview":{"amount":"2039280","funding_account":"CiSrMrPbsnr2pXFHEKXSvHqw1r29qbpRnK1qV9n7zYCC","new_account":"Axw63e2KwrSmqWsZcNUQNXHH4cSfv2xEJBZG7Ua5Rrit"},"program_name":"System"}},{"raw":{"account_indexes":[1,7,0,8],"accounts":"Axw63e2KwrSmqWsZcNUQNXHH4cSfv2xEJBZG7Ua5Rrit,So11111111111111111111111111111111111111112,CiSrMrPbsnr2pXFHEKXSvHqw1r29qbpRnK1qV9n7zYCC,SysvarRent111111111111111111111111111111111","data":"2","program_account":"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA","program_index":12},"readable":{"details":{"account":"Axw63e2KwrSmqWsZcNUQNXHH4cSfv2xEJBZG7Ua5Rrit","mint":"So11111111111111111111111111111111111111112","owner":"CiSrMrPbsnr2pXFHEKXSvHqw1r29qbpRnK1qV9n7zYCC","sysver_rent":"SysvarRent111111111111111111111111111111111"},"method_name":"InitializeAccount","overview":{"account":"Axw63e2KwrSmqWsZcNUQNXHH4cSfv2xEJBZG7Ua5Rrit","mint":"So11111111111111111111111111111111111111112"},"program_name":"Token"}},{"raw":{"account_indexes":[9,4],"accounts":"SysvarC1ock11111111111111111111111111111111,HZMUNJQDwT8rdEiY2r15UR6h8yYg7QkxiekjyJGFFwnB","data":"9","program_account":"LendZqTs7gn5CTSJU1jWKhKuVpjJGom45nnwPb2AMTi","program_index":14},"readable":"Unable to parse instruction, reason: Error occurred when parsing program instruction, reason: `Custom program error: 0x0`"},{"raw":{"account_indexes":[3,1,4,5,6,10,11,2,9,12],"accounts":"CWJtEyYYHy3ydjHn5Beh48mHiW9BBHSYjcGDJkB8awNx,Axw63e2KwrSmqWsZcNUQNXHH4cSfv2xEJBZG7Ua5Rrit,HZMUNJQDwT8rdEiY2r15UR6h8yYg7QkxiekjyJGFFwnB,EkabaFX962r7gbdjQ6i2kfbrjFA6XppgKZ4APeUhA7gS,7QpRNyLenfoUA8SrpDTaaurtx4JxAJ2j4zdkNUMsTa6A,3My6wgR1fHmDFqBvv1hys7PigtH1megLncRCh2PkBMTR,Lz3nGpTr7SfSf7eJqcoQEkXK2fSK3dfCoSdQSKxbXxQ,CYvAAqCR6LjctqdWvPe1CfBW9p5uSc85Da45gENrVSr8,SysvarC1ock11111111111111111111111111111111,TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA","data":"44TEbAMwXMLK","program_account":"LendZqTs7gn5CTSJU1jWKhKuVpjJGom45nnwPb2AMTi","program_index":14},"readable":{"details":{"destination_collateral_account":"Axw63e2KwrSmqWsZcNUQNXHH4cSfv2xEJBZG7Ua5Rrit","lending_market_account":"3My6wgR1fHmDFqBvv1hys7PigtH1megLncRCh2PkBMTR","lending_market_authority_pubkey":"Lz3nGpTr7SfSf7eJqcoQEkXK2fSK3dfCoSdQSKxbXxQ","liquidity_amount":"518948","reserve_account":"HZMUNJQDwT8rdEiY2r15UR6h8yYg7QkxiekjyJGFFwnB","reserve_collateral_mint":"7QpRNyLenfoUA8SrpDTaaurtx4JxAJ2j4zdkNUMsTa6A","reserve_liquidity_supply_account":"EkabaFX962r7gbdjQ6i2kfbrjFA6XppgKZ4APeUhA7gS","source_liquidity_account":"CWJtEyYYHy3ydjHn5Beh48mHiW9BBHSYjcGDJkB8awNx","sysvar_clock":"SysvarC1ock11111111111111111111111111111111","token_program_id":"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA","user_transfer_authority_pubkey":"CYvAAqCR6LjctqdWvPe1CfBW9p5uSc85Da45gENrVSr8"},"method_name":"DepositReserveLiquidity","overview":{"destination_collateral_account":"Axw63e2KwrSmqWsZcNUQNXHH4cSfv2xEJBZG7Ua5Rrit","lending_market_account":"3My6wgR1fHmDFqBvv1hys7PigtH1megLncRCh2PkBMTR","liquidity_amount":"518948","reserve_account":"HZMUNJQDwT8rdEiY2r15UR6h8yYg7QkxiekjyJGFFwnB","reserve_collateral_mint":"7QpRNyLenfoUA8SrpDTaaurtx4JxAJ2j4zdkNUMsTa6A","reserve_liquidity_supply_account":"EkabaFX962r7gbdjQ6i2kfbrjFA6XppgKZ4APeUhA7gS","source_liquidity_account":"CWJtEyYYHy3ydjHn5Beh48mHiW9BBHSYjcGDJkB8awNx"},"program_name":"TokenLending"}},{"raw":{"account_indexes":[3,0],"accounts":"CWJtEyYYHy3ydjHn5Beh48mHiW9BBHSYjcGDJkB8awNx,CiSrMrPbsnr2pXFHEKXSvHqw1r29qbpRnK1qV9n7zYCC","data":"6","program_account":"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA","program_index":12},"readable":{"details":{"owner":"CiSrMrPbsnr2pXFHEKXSvHqw1r29qbpRnK1qV9n7zYCC","source_account":"CWJtEyYYHy3ydjHn5Beh48mHiW9BBHSYjcGDJkB8awNx"},"method_name":"Revoke","overview":{"source_account":"CWJtEyYYHy3ydjHn5Beh48mHiW9BBHSYjcGDJkB8awNx"},"program_name":"Token"}},{"raw":{"account_indexes":[1,0,0],"accounts":"Axw63e2KwrSmqWsZcNUQNXHH4cSfv2xEJBZG7Ua5Rrit,CiSrMrPbsnr2pXFHEKXSvHqw1r29qbpRnK1qV9n7zYCC,CiSrMrPbsnr2pXFHEKXSvHqw1r29qbpRnK1qV9n7zYCC","data":"A","program_account":"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA","program_index":12},"readable":{"details":{"account":"Axw63e2KwrSmqWsZcNUQNXHH4cSfv2xEJBZG7Ua5Rrit","owner":"CiSrMrPbsnr2pXFHEKXSvHqw1r29qbpRnK1qV9n7zYCC","recipient":"CiSrMrPbsnr2pXFHEKXSvHqw1r29qbpRnK1qV9n7zYCC"},"method_name":"Burn","overview":{"account":"Axw63e2KwrSmqWsZcNUQNXHH4cSfv2xEJBZG7Ua5Rrit","recipient":"CiSrMrPbsnr2pXFHEKXSvHqw1r29qbpRnK1qV9n7zYCC"},"program_name":"Token"}}]}).to_string());
    }
}

'''
'''--- blockchains/solana/src/read.rs ---
use crate::error::Result;

pub trait Read<T> {
    fn read(raw: &mut Vec<u8>) -> Result<T>;
}

'''
'''--- blockchains/solana/src/resolvers/mod.rs ---
use serde_json::{json, Value};

pub mod stake;
pub mod system;
pub mod token;
pub mod token_lending;
pub mod token_swap_v3;
pub mod vote;

fn template_instruction(
    program_name: &str,
    method_name: &str,
    details: Value,
    overview: Value,
) -> Value {
    json!({
        "program_name": program_name,
        "method_name": method_name,
        "details": details,
        "overview": overview,
    })
}

'''
'''--- blockchains/solana/src/resolvers/stake.rs ---
use crate::error::{Result, SolanaError};
use crate::resolvers::template_instruction;
use crate::solana_lib::solana_program::pubkey::Pubkey;
use crate::solana_lib::solana_program::stake::instruction::{
    AuthorizeCheckedWithSeedArgs, AuthorizeWithSeedArgs, LockupArgs, LockupCheckedArgs,
    StakeInstruction,
};
use crate::solana_lib::solana_program::stake::state::{Authorized, Lockup, StakeAuthorize};
use serde_json::{json, Value};

static PROGRAM_NAME: &str = "Stake";

pub fn resolve(instruction: StakeInstruction, accounts: Vec<String>) -> Result<Value> {
    match instruction {
        StakeInstruction::Initialize(authorized, lockup) => {
            resolve_initialize(accounts, authorized, lockup)
        }
        StakeInstruction::Authorize(pubkey, stake_authorize) => {
            resolve_authorize(accounts, pubkey, stake_authorize)
        }
        StakeInstruction::DelegateStake => resolve_delegate_stake(accounts),
        StakeInstruction::Split(lamports) => resolve_split(accounts, lamports),
        StakeInstruction::Withdraw(lamports) => resolve_withdraw(accounts, lamports),
        StakeInstruction::Deactivate => resolve_deactivate(accounts),
        StakeInstruction::SetLockup(lockup) => resolve_set_lockup(accounts, lockup),
        StakeInstruction::Merge => resolve_merge(accounts),
        StakeInstruction::AuthorizeWithSeed(args) => resolve_authorize_with_seed(accounts, args),
        StakeInstruction::InitializeChecked => resolve_initialize_checked(accounts),
        StakeInstruction::AuthorizeChecked(stake_authorize) => {
            resolve_authorize_checked(accounts, stake_authorize)
        }
        StakeInstruction::AuthorizeCheckedWithSeed(args) => {
            resolve_authorize_checked_with_seed(accounts, args)
        }
        StakeInstruction::SetLockupChecked(args) => resolve_set_lockup_checked(accounts, args),
        StakeInstruction::GetMinimumDelegation => Ok(template_instruction(
            PROGRAM_NAME,
            "GetMinimumDelegation",
            json!({}),
            json!({}),
        )),
        StakeInstruction::DeactivateDelinquent => Ok(template_instruction(
            PROGRAM_NAME,
            "DeactivateDelinquent",
            json!({}),
            json!({}),
        )),
    }
}

fn resolve_initialize(
    accounts: Vec<String>,
    authorized: Authorized,
    lockup: Lockup,
) -> Result<Value> {
    let method_name = "Initialize";
    let stake_account = accounts.get(0).ok_or(SolanaError::AccountNotFound(format!(
        "{}.stake_account",
        method_name
    )))?;
    let sysvar_rent = accounts.get(1).ok_or(SolanaError::AccountNotFound(format!(
        "{}.sysvar_rent",
        method_name
    )))?;
    let staker = authorized.staker.to_string();
    let withdrawer = authorized.withdrawer.to_string();
    let unix_timestamp = lockup.unix_timestamp;
    let epoch = lockup.epoch;
    let custodian = lockup.custodian.to_string();
    Ok(template_instruction(
        PROGRAM_NAME,
        method_name,
        json!({
            "stake_account": stake_account,
            "sysvar_rent": sysvar_rent,
            "staker": staker,
            "withdrawer": withdrawer,
            "timestamp": unix_timestamp,
            "epoch": epoch,
            "custodian": custodian
        }),
        json!({
            "stake_account": stake_account,
            "staker": staker,
            "withdrawer": withdrawer,
            "timestamp": unix_timestamp,
            "epoch": epoch,
            "custodian": custodian
        }),
    ))
}

fn resolve_authorize(
    accounts: Vec<String>,
    pubkey: Pubkey,
    stake_authorize: StakeAuthorize,
) -> Result<Value> {
    let method_name = "Authorize";
    let stake_account = accounts.get(0).ok_or(SolanaError::AccountNotFound(format!(
        "{}.stake_account",
        method_name
    )))?;
    let sysvar_clock = accounts.get(1).ok_or(SolanaError::AccountNotFound(format!(
        "{}.sysvar_clock",
        method_name
    )))?;
    let old_authority_pubkey = accounts.get(2).ok_or(SolanaError::AccountNotFound(format!(
        "Authorize.old_authority_pubkey"
    )))?;
    let lockup_authority_pubkey = accounts.get(3);
    let new_authority_pubkey = pubkey.to_string();
    let authorize_type = match stake_authorize {
        StakeAuthorize::Staker => "staker",
        StakeAuthorize::Withdrawer => "withdrawer",
    };
    Ok(template_instruction(
        PROGRAM_NAME,
        method_name,
        json!({
            "stake_account": stake_account,
            "sysvar_clock": sysvar_clock,
            "old_authority_pubkey": old_authority_pubkey,
            "lockup_authority_pubkey": lockup_authority_pubkey,
            "new_authority_pubkey": new_authority_pubkey,
            "authorize_type": authorize_type,
        }),
        json!({
            "stake_account": stake_account,
            "old_authority_pubkey": old_authority_pubkey,
            "new_authority_pubkey": new_authority_pubkey,
            "authorize_type": authorize_type,
        }),
    ))
}

fn resolve_delegate_stake(accounts: Vec<String>) -> Result<Value> {
    let method_name = "DelegateStake";
    let stake_account = accounts.get(0).ok_or(SolanaError::AccountNotFound(format!(
        "{}.stake_account",
        method_name
    )))?;
    let vote_account = accounts.get(1).ok_or(SolanaError::AccountNotFound(format!(
        "{}.vote_account",
        method_name
    )))?;
    let sysvar_clock = accounts.get(2).ok_or(SolanaError::AccountNotFound(format!(
        "{}.sysvar_clock",
        method_name
    )))?;
    let sysvar_stake_history = accounts.get(3).ok_or(SolanaError::AccountNotFound(format!(
        "{}.sysvar_stake_history",
        method_name
    )))?;
    let config_account = accounts.get(4).ok_or(SolanaError::AccountNotFound(format!(
        "{}.config_account",
        method_name
    )))?;
    let stake_authority_pubkey = accounts.get(5).ok_or(SolanaError::AccountNotFound(format!(
        "{}.stake_authority_pubkey",
        method_name
    )))?;
    Ok(template_instruction(
        PROGRAM_NAME,
        method_name,
        json!({
            "stake_account": stake_account,
            "vote_account": vote_account,
            "sysvar_clock": sysvar_clock,
            "sysvar_stake_history": sysvar_stake_history,
            "config_account": config_account,
            "stake_authority_pubkey": stake_authority_pubkey,
        }),
        json!({
            "stake_account": stake_account,
            "vote_account": vote_account,
            "config_account": config_account,
        }),
    ))
}

fn resolve_split(accounts: Vec<String>, lamports: u64) -> Result<Value> {
    let method_name = "Split";
    let stake_account = accounts.get(0).ok_or(SolanaError::AccountNotFound(format!(
        "{}.stake_account",
        method_name
    )))?;
    let target_account = accounts.get(1).ok_or(SolanaError::AccountNotFound(format!(
        "{}.target_account",
        method_name
    )))?;
    let stake_authority_pubkey = accounts.get(2).ok_or(SolanaError::AccountNotFound(format!(
        "{}.stake_authority_pubkey",
        method_name
    )))?;
    let amount = lamports.to_string();
    Ok(template_instruction(
        PROGRAM_NAME,
        method_name,
        json!({
            "stake_account": stake_account,
            "target_account": target_account,
            "stake_authority_pubkey": stake_authority_pubkey,
            "amount": amount,
        }),
        json!({
            "stake_account": stake_account,
            "target_account": target_account,
            "amount": amount,
        }),
    ))
}

fn resolve_withdraw(accounts: Vec<String>, lamports: u64) -> Result<Value> {
    let method_name = "Withdraw";
    let stake_account = accounts.get(0).ok_or(SolanaError::AccountNotFound(format!(
        "{}.stake_account",
        method_name
    )))?;
    let recipient = accounts.get(1).ok_or(SolanaError::AccountNotFound(format!(
        "{}.recipient",
        method_name
    )))?;
    let sysvar_clock = accounts.get(2).ok_or(SolanaError::AccountNotFound(format!(
        "{}.sysvar_clock",
        method_name
    )))?;
    let sysvar_stake_history = accounts.get(3).ok_or(SolanaError::AccountNotFound(format!(
        "{}.sysvar_stake_history",
        method_name
    )))?;
    let withdraw_authority_pubkey = accounts.get(4).ok_or(SolanaError::AccountNotFound(
        format!("{}.withdraw_authority_pubkey", method_name),
    ))?;
    let stake_authority_pubkey = accounts.get(5);
    let amount = lamports.to_string();
    Ok(template_instruction(
        PROGRAM_NAME,
        method_name,
        json!({
            "stake_account": stake_account,
            "recipient": recipient,
            "sysvar_clock": sysvar_clock,
            "sysvar_stake_history": sysvar_stake_history,
            "withdraw_authority_pubkey": withdraw_authority_pubkey,
            "stake_authority_pubkey": stake_authority_pubkey,
            "amount": amount,
        }),
        json!({
            "stake_account": stake_account,
            "recipient": recipient,
            "amount": amount,
        }),
    ))
}

fn resolve_deactivate(accounts: Vec<String>) -> Result<Value> {
    let method_name = "Deactivate";
    let delegated_stake_account = accounts.get(0).ok_or(SolanaError::AccountNotFound(format!(
        "{}.delegated_stake_account",
        method_name
    )))?;
    let sysvar_clock = accounts.get(1).ok_or(SolanaError::AccountNotFound(format!(
        "{}.sysvar_clock",
        method_name
    )))?;
    let stake_authority_pubkey = accounts.get(2).ok_or(SolanaError::AccountNotFound(format!(
        "{}.stake_authority_pubkey",
        method_name
    )))?;
    Ok(template_instruction(
        PROGRAM_NAME,
        method_name,
        json!({
            "delegated_stake_account": delegated_stake_account,
            "sysvar_clock": sysvar_clock,
            "stake_authority_pubkey": stake_authority_pubkey,
        }),
        json!({
            "delegated_stake_account": delegated_stake_account,
        }),
    ))
}

fn resolve_set_lockup(accounts: Vec<String>, lockup: LockupArgs) -> Result<Value> {
    let method_name = "SetLockup";
    let stake_account = accounts.get(0).ok_or(SolanaError::AccountNotFound(format!(
        "{}.stake_account",
        method_name
    )))?;
    let lockup_authority_pubkey = accounts.get(1).ok_or(SolanaError::AccountNotFound(format!(
        "{}.lockup_authority_pubkey",
        method_name
    )))?;
    let unix_timestamp = lockup.unix_timestamp;
    let epoch = lockup.epoch;
    let custodian = lockup.custodian.map(|v| v.to_string());
    Ok(template_instruction(
        PROGRAM_NAME,
        method_name,
        json!({
            "stake_account": stake_account,
            "lockup_authority_pubkey": lockup_authority_pubkey,
            "unix_timestamp": unix_timestamp,
            "epoch": epoch,
            "custodian": custodian,
        }),
        json!({
            "stake_account": stake_account,
            "unix_timestamp": unix_timestamp,
            "epoch": epoch,
            "custodian": custodian,
        }),
    ))
}

fn resolve_merge(accounts: Vec<String>) -> Result<Value> {
    let method_name = "Merge";
    let destination_stake_account = accounts.get(0).ok_or(SolanaError::AccountNotFound(
        format!("{}.destination_stake_account", method_name),
    ))?;
    let source_stake_account = accounts.get(1).ok_or(SolanaError::AccountNotFound(format!(
        "{}.source_stake_account",
        method_name
    )))?;
    let sysvar_clock = accounts.get(2).ok_or(SolanaError::AccountNotFound(format!(
        "{}.sysvar_clock",
        method_name
    )))?;
    let sysvar_stake_history = accounts.get(3).ok_or(SolanaError::AccountNotFound(format!(
        "{}.sysvar_stake_history",
        method_name
    )))?;
    let stake_authority_pubkey = accounts.get(4).ok_or(SolanaError::AccountNotFound(format!(
        "{}.stake_authority_pubkey",
        method_name
    )))?;
    Ok(template_instruction(
        PROGRAM_NAME,
        method_name,
        json!({
            "destination_stake_account": destination_stake_account,
            "source_stake_account": source_stake_account,
            "sysvar_clock": sysvar_clock,
            "sysvar_stake_history": sysvar_stake_history,
            "stake_authority_pubkey": stake_authority_pubkey,
        }),
        json!({
            "destination_stake_account": destination_stake_account,
            "source_stake_account": source_stake_account,
        }),
    ))
}

fn resolve_authorize_with_seed(
    accounts: Vec<String>,
    args: AuthorizeWithSeedArgs,
) -> Result<Value> {
    let method_name = "AuthorizeWithSeed";
    let stake_account = accounts.get(0).ok_or(SolanaError::AccountNotFound(format!(
        "{}.stake_account",
        method_name
    )))?;
    let old_base_pubkey = accounts.get(1).ok_or(SolanaError::AccountNotFound(format!(
        "{}.old_base_pubkey",
        method_name
    )))?;
    let sysvar_clock = accounts.get(2).ok_or(SolanaError::AccountNotFound(format!(
        "{}.sysvar_clock",
        method_name
    )))?;
    let lockup_authority_pubkey = accounts.get(3);

    let new_authority_pubkey = args.new_authorized_pubkey.to_string();
    let stake_authorize = match args.stake_authorize {
        StakeAuthorize::Staker => "staker",
        StakeAuthorize::Withdrawer => "withdrawer",
    };
    let authority_owner = args.authority_owner.to_string();
    Ok(template_instruction(
        PROGRAM_NAME,
        method_name,
        json!({
            "stake_account": stake_account,
            "old_base_pubkey": old_base_pubkey,
            "sysvar_clock": sysvar_clock,
            "lockup_authority_pubkey": lockup_authority_pubkey,
            "new_authority_pubkey": new_authority_pubkey,
            "authorize_type": stake_authorize,
            "authority_seed": args.authority_seed,
            "authority_owner": authority_owner,
        }),
        json!({
            "stake_account": stake_account,
            "old_base_pubkey": old_base_pubkey,
            "new_authority_pubkey": new_authority_pubkey,
            "authorize_type": stake_authorize,
            "authority_seed": args.authority_seed,
        }),
    ))
}

fn resolve_initialize_checked(accounts: Vec<String>) -> Result<Value> {
    let method_name = "InitializeChecked";
    let stake_account = accounts.get(0).ok_or(SolanaError::AccountNotFound(format!(
        "{}.stake_account",
        method_name
    )))?;
    let sysvar_rent = accounts.get(1).ok_or(SolanaError::AccountNotFound(format!(
        "{}.sysvar_rent",
        method_name
    )))?;
    let stake_authority_pubkey = accounts.get(2).ok_or(SolanaError::AccountNotFound(format!(
        "{}.stake_authority_pubkey",
        method_name
    )))?;
    let withdraw_authority_pubkey = accounts.get(3).ok_or(SolanaError::AccountNotFound(
        format!("{}.withdraw_authority_pubkey", method_name),
    ))?;
    Ok(template_instruction(
        PROGRAM_NAME,
        method_name,
        json!({
            "stake_account": stake_account,
            "sysvar_rent": sysvar_rent,
            "stake_authority_pubkey": stake_authority_pubkey,
            "withdraw_authority_pubkey": withdraw_authority_pubkey,
        }),
        json!({
            "stake_account": stake_account,
            "stake_authority_pubkey": stake_authority_pubkey,
            "withdraw_authority_pubkey": withdraw_authority_pubkey,
        }),
    ))
}

fn resolve_authorize_checked(
    accounts: Vec<String>,
    stake_authorize: StakeAuthorize,
) -> Result<Value> {
    let method_name = "AuthorizeChecked";
    let stake_account = accounts.get(0).ok_or(SolanaError::AccountNotFound(format!(
        "{}.stake_account",
        method_name
    )))?;
    let sysvar_clock = accounts.get(1).ok_or(SolanaError::AccountNotFound(format!(
        "{}.sysvar_clock",
        method_name
    )))?;
    let old_authority_pubkey = accounts.get(2).ok_or(SolanaError::AccountNotFound(format!(
        "{}.old_authority_pubkey",
        method_name
    )))?;
    let new_authority_pubkey = accounts.get(3).ok_or(SolanaError::AccountNotFound(format!(
        "{}.new_authority_pubkey",
        method_name
    )))?;
    let lockup_authority_pubkey = accounts.get(4);
    let authority_type = match stake_authorize {
        StakeAuthorize::Staker => "staker",
        StakeAuthorize::Withdrawer => "withdrawer",
    };
    Ok(template_instruction(
        PROGRAM_NAME,
        method_name,
        json!({
            "stake_account": stake_account,
            "sysvar_clock": sysvar_clock,
            "old_authority_pubkey": old_authority_pubkey,
            "new_authority_pubkey": new_authority_pubkey,
            "lockup_authority_pubkey": lockup_authority_pubkey,
            "authority_type": authority_type
        }),
        json!({
            "stake_account": stake_account,
            "old_authority_pubkey": old_authority_pubkey,
            "new_authority_pubkey": new_authority_pubkey,
            "authority_type": authority_type
        }),
    ))
}

fn resolve_authorize_checked_with_seed(
    accounts: Vec<String>,
    args: AuthorizeCheckedWithSeedArgs,
) -> Result<Value> {
    let method_name = "AuthorizeCheckedWithSeed";
    let stake_account = accounts.get(0).ok_or(SolanaError::AccountNotFound(format!(
        "{}.stake_account",
        method_name
    )))?;
    let old_base_pubkey = accounts.get(1).ok_or(SolanaError::AccountNotFound(format!(
        "{}.old_base_pubkey",
        method_name
    )))?;
    let sysvar_clock = accounts.get(2).ok_or(SolanaError::AccountNotFound(format!(
        "{}.sysvar_clock",
        method_name
    )))?;
    let new_authority_pubkey = accounts.get(3).ok_or(SolanaError::AccountNotFound(format!(
        "{}.new_authority_pubkey",
        method_name
    )))?;
    let lockup_authority = accounts.get(4);
    let authority_type = match args.stake_authorize {
        StakeAuthorize::Staker => "staker",
        StakeAuthorize::Withdrawer => "withdrawer",
    };
    let authority_seed = args.authority_seed;
    let authority_owner = args.authority_owner.to_string();
    Ok(template_instruction(
        PROGRAM_NAME,
        method_name,
        json!({
            "stake_account": stake_account,
            "sysvar_clock": sysvar_clock,
            "old_base_pubkey": old_base_pubkey,
            "new_authority_pubkey": new_authority_pubkey,
            "lockup_authority": lockup_authority,
            "authority_type": authority_type,
            "authority_seed": authority_seed,
            "authority_owner": authority_owner,
        }),
        json!({
            "stake_account": stake_account,
            "old_base_pubkey": old_base_pubkey,
            "new_authority_pubkey": new_authority_pubkey,
            "authority_type": authority_type,
            "authority_seed": authority_seed,
        }),
    ))
}

fn resolve_set_lockup_checked(accounts: Vec<String>, args: LockupCheckedArgs) -> Result<Value> {
    let method_name = "SetLockupChecked";
    let stake_account = accounts.get(0).ok_or(SolanaError::AccountNotFound(format!(
        "{}.stake_account",
        method_name
    )))?;
    let lockup_authority_pubkey = accounts.get(1).ok_or(SolanaError::AccountNotFound(format!(
        "{}.authority_pubkey",
        method_name
    )))?;
    let new_lockup_authority_pubkey = accounts.get(2);

    let unix_timestamp = args.unix_timestamp;
    let epoch = args.epoch;
    Ok(template_instruction(
        PROGRAM_NAME,
        method_name,
        json!({
            "stake_account": stake_account,
            "lockup_authority_pubkey": lockup_authority_pubkey,
            "new_lockup_authority_pubkey": new_lockup_authority_pubkey,
            "timestamp": unix_timestamp,
            "epoch": epoch,
        }),
        json!({
            "stake_account": stake_account,
            "lockup_authority_pubkey": lockup_authority_pubkey,
            "new_lockup_authority_pubkey": new_lockup_authority_pubkey,
            "timestamp": unix_timestamp,
            "epoch": epoch,
        }),
    ))
}

'''
'''--- blockchains/solana/src/resolvers/system.rs ---
use crate::error::{Result, SolanaError};
use crate::resolvers::template_instruction;
use crate::solana_lib::solana_program::pubkey::Pubkey;
use crate::solana_lib::solana_program::system_instruction::SystemInstruction;
use serde_json::{json, Value};

static PROGRAM_NAME: &str = "System";

pub fn resolve(instruction: SystemInstruction, accounts: Vec<String>) -> Result<Value> {
    match instruction {
        SystemInstruction::CreateAccount {
            lamports,
            space,
            owner,
        } => resolve_create_account(accounts, lamports, space, owner),
        SystemInstruction::Assign { owner } => resolve_assign(accounts, owner),
        SystemInstruction::Transfer { lamports } => resolve_transfer(accounts, lamports),
        SystemInstruction::CreateAccountWithSeed {
            base,
            seed,
            lamports,
            space,
            owner,
        } => resolve_create_account_with_seed(accounts, base, seed, lamports, space, owner),
        SystemInstruction::AdvanceNonceAccount => resolve_advance_nonce_account(accounts),
        SystemInstruction::WithdrawNonceAccount(lamports) => {
            resolve_withdraw_nonce_account(accounts, lamports)
        }
        SystemInstruction::InitializeNonceAccount(pubkey) => {
            resolve_initialize_nonce_account(accounts, pubkey)
        }
        SystemInstruction::AuthorizeNonceAccount(pubkey) => {
            resolve_authorize_nonce_account(accounts, pubkey)
        }
        SystemInstruction::Allocate { space } => resolve_allocate(accounts, space),
        SystemInstruction::AllocateWithSeed {
            owner,
            base,
            seed,
            space,
        } => resolve_allocate_with_seed(accounts, owner, base, seed, space),
        SystemInstruction::AssignWithSeed { owner, seed, base } => {
            resolve_assign_with_seed(accounts, owner, seed, base)
        }
        SystemInstruction::TransferWithSeed {
            lamports,
            from_seed,
            from_owner,
        } => resolve_transfer_with_seed(accounts, lamports, from_seed, from_owner),
        SystemInstruction::UpgradeNonceAccount => resolve_upgrade_nonce_account(accounts),
    }
}

fn resolve_create_account(
    accounts: Vec<String>,
    lamports: u64,
    space: u64,
    owner: Pubkey,
) -> Result<Value> {
    let method_name = "CreateAccount";
    let funding_account = accounts.get(0).ok_or(SolanaError::AccountNotFound(format!(
        "CreateAccount.funding_account"
    )))?;
    let new_account = accounts.get(1).ok_or(SolanaError::AccountNotFound(format!(
        "CreateAccount.new_account"
    )))?;
    let amount = lamports.to_string();
    let space = space.to_string();
    let owner = owner.to_string();
    Ok(template_instruction(
        PROGRAM_NAME,
        method_name,
        json!({
            "funding_account": funding_account,
            "new_account": new_account,
            "amount": amount,
            "space": space,
            "owner": owner,
        }),
        json!({
            "funding_account": funding_account,
            "new_account": new_account,
            "amount": amount,
        }),
    ))
}

fn resolve_assign(accounts: Vec<String>, owner: Pubkey) -> Result<Value> {
    let method_name = "Assign";
    let account = accounts.get(0).ok_or(SolanaError::AccountNotFound(format!(
        "{}.account",
        method_name
    )))?;
    let new_owner = owner.to_string();
    Ok(template_instruction(
        PROGRAM_NAME,
        method_name,
        json!({
            "account": account,
            "new_owner": new_owner,
        }),
        json!({
            "account": account,
            "new_owner": new_owner,
        }),
    ))
}

fn resolve_transfer(accounts: Vec<String>, lamports: u64) -> Result<Value> {
    let method_name = "Transfer";
    let from = accounts.get(0).ok_or(SolanaError::AccountNotFound(format!(
        "{}.from",
        method_name
    )))?;
    let recipient = accounts.get(1).ok_or(SolanaError::AccountNotFound(format!(
        "{}.recipient",
        method_name
    )))?;
    let amount = lamports.to_string();
    Ok(template_instruction(
        PROGRAM_NAME,
        method_name,
        json!({
            "from": from,
            "recipient": recipient,
            "amount": amount
        }),
        json!({
            "from": from,
            "recipient": recipient,
            "amount": amount
        }),
    ))
}

fn resolve_create_account_with_seed(
    accounts: Vec<String>,
    base: Pubkey,
    seed: String,
    lamports: u64,
    space: u64,
    owner: Pubkey,
) -> Result<Value> {
    let method_name = "CreateAccountWithSeed";
    let funding_account = accounts.get(0).ok_or(SolanaError::AccountNotFound(format!(
        "{}.funding_account",
        method_name
    )))?;
    let new_account = accounts.get(1).ok_or(SolanaError::AccountNotFound(format!(
        "{}.new_account",
        method_name
    )))?;
    let base_account = accounts.get(2);
    let amount = lamports.to_string();
    let space = space.to_string();
    let owner = owner.to_string();
    let base_pubkey = base.to_string();
    Ok(template_instruction(
        PROGRAM_NAME,
        method_name,
        json!({
            "funding_account": funding_account,
            "new_account": new_account,
            "base_account": base_account,
            "base_pubkey": base_pubkey,
            "seed": seed,
            "amount": amount,
            "space": space,
            "owner": owner,
        }),
        json!({
            "funding_account": funding_account,
            "new_account": new_account,
            "base_pubkey": base_pubkey,
            "seed": seed,
            "amount": amount,
            "space": space,
        }),
    ))
}

fn resolve_advance_nonce_account(accounts: Vec<String>) -> Result<Value> {
    let method_name = "AdvanceNonceAccount";
    let nonce_account = accounts.get(0).ok_or(SolanaError::AccountNotFound(format!(
        "{}.nonce_account",
        method_name
    )))?;
    let recent_blockhashes_sysvar = accounts.get(1).ok_or(SolanaError::AccountNotFound(
        format!("{}.recent_blockhashes_sysvar", method_name),
    ))?;
    let nonce_authority_pubkey = accounts.get(2).ok_or(SolanaError::AccountNotFound(format!(
        "{}.nonce_authority_pubkey",
        method_name
    )))?;
    Ok(template_instruction(
        PROGRAM_NAME,
        method_name,
        json!({
            "nonce_account": nonce_account,
            "recent_blockhashes_sysvar": recent_blockhashes_sysvar,
            "nonce_authority_pubkey": nonce_authority_pubkey,
        }),
        json!({
            "nonce_account": nonce_account,
        }),
    ))
}

fn resolve_withdraw_nonce_account(accounts: Vec<String>, lamports: u64) -> Result<Value> {
    let method_name = "WithdrawNonceAccount";
    let nonce_account = accounts.get(0).ok_or(SolanaError::AccountNotFound(format!(
        "{}.nonce_account",
        method_name
    )))?;
    let recipient = accounts.get(1).ok_or(SolanaError::AccountNotFound(format!(
        "{}.recipient",
        method_name
    )))?;
    let recent_blockhashes_sysvar = accounts.get(2).ok_or(SolanaError::AccountNotFound(
        format!("{}.recent_blockhashes_sysvar", method_name),
    ))?;
    let rent_sysvar = accounts.get(3).ok_or(SolanaError::AccountNotFound(format!(
        "{}.rent_sysvar",
        method_name
    )))?;
    let nonce_authority_pubkey = accounts.get(4).ok_or(SolanaError::AccountNotFound(format!(
        "{}.nonce_authority_pubkey",
        method_name
    )))?;
    let amount = lamports.to_string();
    Ok(template_instruction(
        PROGRAM_NAME,
        method_name,
        json!({
            "nonce_account": nonce_account,
            "recipient": recipient,
            "recent_blockhashes_sysvar": recent_blockhashes_sysvar,
            "rent_sysvar": rent_sysvar,
            "nonce_authority_pubkey": nonce_authority_pubkey,
            "amount": amount,
        }),
        json!({
            "nonce_account": nonce_account,
            "recipient": recipient,
            "amount": amount,
        }),
    ))
}

fn resolve_initialize_nonce_account(accounts: Vec<String>, pubkey: Pubkey) -> Result<Value> {
    let method_name = "InitializeNonceAccount";
    let nonce_account = accounts.get(0).ok_or(SolanaError::AccountNotFound(format!(
        "{}.nonce_account",
        method_name
    )))?;
    let sysvar_recent_blockhashes = accounts.get(1).ok_or(SolanaError::AccountNotFound(
        format!("{}.sysvar_recent_blockhashes", method_name),
    ))?;
    let sysvar_rent = accounts.get(2).ok_or(SolanaError::AccountNotFound(format!(
        "{}.sysvar_rent",
        method_name
    )))?;
    let nonce_authority_pubkey = pubkey.to_string();
    Ok(template_instruction(
        PROGRAM_NAME,
        method_name,
        json!({
            "nonce_account": nonce_account,
            "sysvar_recent_blockhashes": sysvar_recent_blockhashes,
            "sysvar_rent": sysvar_rent,
            "nonce_authority_pubkey": nonce_authority_pubkey,
        }),
        json!({
            "nonce_account": nonce_account,
            "nonce_authority_pubkey": nonce_authority_pubkey,
        }),
    ))
}

fn resolve_authorize_nonce_account(accounts: Vec<String>, pubkey: Pubkey) -> Result<Value> {
    let method_name = "AuthorizeNonceAccount";
    let nonce_account = accounts.get(0).ok_or(SolanaError::AccountNotFound(format!(
        "{}.nonce_account",
        method_name
    )))?;
    let old_nonce_authority_pubkey = accounts.get(1).ok_or(SolanaError::AccountNotFound(
        format!("{}.old_nonce_authority_pubkey", method_name),
    ))?;
    let new_nonce_authority_pubkey = pubkey.to_string();
    Ok(template_instruction(
        PROGRAM_NAME,
        method_name,
        json!({
            "nonce_account": nonce_account,
            "old_nonce_authority_pubkey": old_nonce_authority_pubkey,
            "new_nonce_authority_pubkey": new_nonce_authority_pubkey,
        }),
        json!({
            "nonce_account": nonce_account,
            "old_nonce_authority_pubkey": old_nonce_authority_pubkey,
            "new_nonce_authority_pubkey": new_nonce_authority_pubkey,
        }),
    ))
}

fn resolve_allocate(accounts: Vec<String>, space: u64) -> Result<Value> {
    let method_name = "Allocate";
    let new_account = accounts.get(0).ok_or(SolanaError::AccountNotFound(format!(
        "{}.account",
        method_name
    )))?;
    Ok(template_instruction(
        PROGRAM_NAME,
        method_name,
        json!({
            "new_account": new_account,
            "space": space.to_string(),
        }),
        json!({
            "new_account": new_account,
            "space": space.to_string(),
        }),
    ))
}

fn resolve_allocate_with_seed(
    accounts: Vec<String>,
    owner: Pubkey,
    base_pubkey: Pubkey,
    seed: String,
    space: u64,
) -> Result<Value> {
    let method_name = "AllocateWithSeed";
    let allocated_account = accounts.get(0).ok_or(SolanaError::AccountNotFound(format!(
        "{}.allocated_account",
        method_name
    )))?;
    let base_account = accounts.get(1).ok_or(SolanaError::AccountNotFound(format!(
        "{}.base_account",
        method_name
    )))?;
    let owner = owner.to_string();
    let base = base_pubkey.to_string();
    let space = space.to_string();
    Ok(template_instruction(
        PROGRAM_NAME,
        method_name,
        json!({
            "allocated_account": allocated_account,
            "base_account": base_account,
            "base_pubkey": base,
            "seed": seed,
            "space": space,
            "owner": owner,
        }),
        json!({
            "allocated_account": allocated_account,
            "base_account": base_account,
            "base_pubkey": base,
            "seed": seed,
            "space": space
        }),
    ))
}

fn resolve_assign_with_seed(
    accounts: Vec<String>,
    owner: Pubkey,
    seed: String,
    base_pubkey: Pubkey,
) -> Result<Value> {
    let method_name = "AssignWithSeed";
    let assigned_account = accounts.get(0).ok_or(SolanaError::AccountNotFound(format!(
        "{}.assigned_account",
        method_name
    )))?;
    let base_account = accounts.get(1).ok_or(SolanaError::AccountNotFound(format!(
        "{}.base_account",
        method_name
    )))?;
    Ok(template_instruction(
        PROGRAM_NAME,
        method_name,
        json!({
            "assigned_account": assigned_account,
            "base_account": base_account,
            "base_pubkey": base_pubkey.to_string(),
            "seed": seed,
            "owner": owner.to_string(),
        }),
        json!({
            "assigned_account": assigned_account,
            "base_account": base_account,
            "base_pubkey": base_pubkey.to_string(),
            "seed": seed,
        }),
    ))
}

fn resolve_transfer_with_seed(
    accounts: Vec<String>,
    lamports: u64,
    from_seed: String,
    from_owner: Pubkey,
) -> Result<Value> {
    let method_name = "TransferWithSeed";
    let from = accounts.get(0).ok_or(SolanaError::AccountNotFound(format!(
        "{}.from",
        method_name
    )))?;
    let from_base_pubkey = accounts.get(1).ok_or(SolanaError::AccountNotFound(format!(
        "{}.from_base_pubkey",
        method_name
    )))?;
    let recipient = accounts.get(2).ok_or(SolanaError::AccountNotFound(format!(
        "{}.recipient",
        method_name
    )))?;
    let amount = lamports.to_string();
    let from_owner = from_owner.to_string();
    Ok(template_instruction(
        PROGRAM_NAME,
        method_name,
        json!({
            "from": from,
            "recipient": recipient,
            "amount": amount,
            "from_base_pubkey": from_base_pubkey,
            "from_owner": from_owner,
            "from_seed": from_seed,
        }),
        json!({
            "from": from,
            "recipient": recipient,
            "amount": amount,
            "from_base_pubkey": from_base_pubkey,
            "from_seed": from_seed,
        }),
    ))
}

fn resolve_upgrade_nonce_account(accounts: Vec<String>) -> Result<Value> {
    let method_name = "UpgradeNonceAccount";
    let nonce_account = accounts.get(0).ok_or(SolanaError::AccountNotFound(format!(
        "UpgradeNonceAccount.nonce_account"
    )))?;
    Ok(template_instruction(
        PROGRAM_NAME,
        method_name,
        json!({
            "nonce_account": nonce_account,
        }),
        json!({
            "nonce_account": nonce_account,
        }),
    ))
}

'''
'''--- blockchains/solana/src/resolvers/token.rs ---
use crate::error::{Result, SolanaError};
use crate::resolvers::template_instruction;
use crate::solana_lib::solana_program::program_option::COption;
use crate::solana_lib::solana_program::pubkey::Pubkey;
use crate::solana_lib::spl::token::instruction::{AuthorityType, TokenInstruction};
use serde_json::{json, Value};

fn map_coption_to_option<T>(value: COption<T>) -> Option<T> {
    match value {
        COption::Some(t) => Some(t),
        COption::None => None,
    }
}

fn is_multisig(accounts: &Vec<String>, point: u8) -> bool {
    (accounts.len() as u8) > point
}

static PROGRAM_NAME: &str = "Token";

pub fn resolve(instruction: TokenInstruction, accounts: Vec<String>) -> Result<Value> {
    match instruction {
        TokenInstruction::InitializeMint {
            mint_authority,
            decimals,
            freeze_authority,
        } => initialize_mint(
            accounts,
            mint_authority,
            decimals,
            freeze_authority,
        ),
        TokenInstruction::InitializeAccount => initialize_account(accounts),
        TokenInstruction::InitializeMultisig { m } => initialize_multisig(accounts, m),
        TokenInstruction::Transfer { amount } => transfer(accounts, amount),
        TokenInstruction::Approve { amount } => approve(accounts, amount),
        TokenInstruction::Revoke => revoke(accounts),
        TokenInstruction::SetAuthority {
            authority_type,
            new_authority,
        } => set_authority(accounts, authority_type, new_authority),
        TokenInstruction::MintTo { amount } => mint_to(accounts, amount),
        TokenInstruction::Burn { amount } => burn(accounts, amount),
        TokenInstruction::CloseAccount => close_account(accounts),
        TokenInstruction::FreezeAccount => freeze_account(accounts),
        TokenInstruction::ThawAccount => thaw_account(accounts),
        TokenInstruction::TransferChecked { decimals, amount } => {
            transfer_checked(accounts, decimals, amount)
        }
        TokenInstruction::ApproveChecked { decimals, amount } => {
            approve_checked(accounts, decimals, amount)
        }
        TokenInstruction::MintToChecked { decimals, amount } => {
            mint_to_checked(accounts, decimals, amount)
        }
        TokenInstruction::BurnChecked { decimals, amount } => {
            burn_checked(accounts, decimals, amount)
        }
        TokenInstruction::InitializeAccount2 { owner } => initialize_account_2(accounts, owner),
        TokenInstruction::SyncNative => sync_native(accounts),
        TokenInstruction::InitializeAccount3 { owner } => initialize_account_3(accounts, owner),
        TokenInstruction::InitializeMultisig2 { m } => initialize_multisig_2(accounts, m),
        TokenInstruction::InitializeMint2 {
            mint_authority,
            decimals,
            freeze_authority,
        } => initialize_mint_2(
            accounts,
            mint_authority,
            decimals,
            freeze_authority,
        ),
    }
}

fn initialize_mint(
    accounts: Vec<String>,
    mint_authority_pubkey: Pubkey,
    decimals: u8,
    freeze_authority_pubkey: COption<Pubkey>,
) -> Result<Value> {
    let method_name = "InitializeMint";
    let mint = accounts.get(0).ok_or(SolanaError::AccountNotFound(format!(
        "{}.mint",
        method_name
    )))?;
    let sysver_rent = accounts.get(1).ok_or(SolanaError::AccountNotFound(format!(
        "{}.sysver_rent",
        method_name
    )))?;
    let mint_authority_pubkey = mint_authority_pubkey.to_string();
    let freeze_authority_pubkey =
        map_coption_to_option(freeze_authority_pubkey.map(|v| v.to_string()));
    Ok(template_instruction(
        PROGRAM_NAME,
        method_name,
        json!({
            "mint": mint,
            "sysver_rent": sysver_rent,
            "mint_authority_pubkey": mint_authority_pubkey,
            "freeze_authority_pubkey": freeze_authority_pubkey,
            "decimals": decimals,
        }),
        json!({
            "mint": mint,
            "mint_authority_pubkey": mint_authority_pubkey,
            "freeze_authority_pubkey": freeze_authority_pubkey,
            "decimals": decimals,
        }),
    ))
}

fn initialize_account(accounts: Vec<String>) -> Result<Value> {
    let method_name = "InitializeAccount";

    let account = accounts.get(0).ok_or(SolanaError::AccountNotFound(format!(
        "{}.account",
        method_name
    )))?;
    let mint = accounts.get(1).ok_or(SolanaError::AccountNotFound(format!(
        "{}.mint",
        method_name
    )))?;
    let owner = accounts.get(2).ok_or(SolanaError::AccountNotFound(format!(
        "{}.owner",
        method_name
    )))?;
    let sysver_rent = accounts.get(3).ok_or(SolanaError::AccountNotFound(format!(
        "{}.sysver_rent",
        method_name
    )))?;
    Ok(template_instruction(
        PROGRAM_NAME,
        method_name,
        json!({
            "account": account,
            "mint": mint,
            "owner": owner,
            "sysver_rent": sysver_rent,
        }),
        json!({
            "account": account,
            "mint": mint,
        }),
    ))
}

fn initialize_multisig(accounts: Vec<String>, m: u8) -> Result<Value> {
    let method_name = "InitializeMultisig";

    let multisig_account = accounts.get(0).ok_or(SolanaError::AccountNotFound(format!(
        "{}.multisig_account",
        method_name
    )))?;
    let sysvar_rent = accounts.get(1).ok_or(SolanaError::AccountNotFound(format!(
        "{}.sysvar_rent",
        method_name
    )))?;
    let attendees = &accounts[2..];
    let required_signatures = m;
    Ok(template_instruction(
        PROGRAM_NAME,
        method_name,
        json!({
            "multisig_account": multisig_account,
            "sysvar_rent": sysvar_rent,
            "attendees": attendees,
            "required_signatures": required_signatures,
        }),
        json!({
            "multisig_account": multisig_account,
            "attendees": attendees,
            "required_signatures": required_signatures,
        }),
    ))
}

fn transfer(accounts: Vec<String>, amount: u64) -> Result<Value> {
    let method_name = "Transfer";

    let source_account = accounts.get(0).ok_or(SolanaError::AccountNotFound(format!(
        "{}.source_account",
        method_name
    )))?;
    let recipient = accounts.get(1).ok_or(SolanaError::AccountNotFound(format!(
        "{}.recipient",
        method_name
    )))?;
    let amount = amount.to_string();
    if is_multisig(&accounts, 3) {
        let owner = accounts.get(2).ok_or(SolanaError::AccountNotFound(format!(
            "{}.owner",
            method_name
        )))?;
        let signers = &accounts[3..];
        return Ok(template_instruction(
            PROGRAM_NAME,
            method_name,
            json!({
                "source_account": source_account,
                "recipient": recipient,
                "owner": owner,
                "signers": signers,
                "amount": amount,
            }),
            json!({
                "source_account": source_account,
                "recipient": recipient,
                "amount": amount,
            }),
        ));
    }
    let owner = accounts
        .get(2)
        .ok_or(SolanaError::AccountNotFound(format!("Transfer.owner")))?;
    return Ok(template_instruction(
        PROGRAM_NAME,
        method_name,
        json!({
            "source_account": source_account,
            "recipient": recipient,
            "owner": owner,
            "amount": amount,
        }),
        json!({
            "source_account": source_account,
            "recipient": recipient,
            "amount": amount,
        }),
    ));
}

fn approve(accounts: Vec<String>, amount: u64) -> Result<Value> {
    let method_name = "Approve";

    let source_account = accounts.get(0).ok_or(SolanaError::AccountNotFound(format!(
        "{}.source_account",
        method_name
    )))?;
    let delegate_account = accounts.get(1).ok_or(SolanaError::AccountNotFound(format!(
        "{}.delegate_account",
        method_name
    )))?;
    let amount = amount.to_string();
    if is_multisig(&accounts, 3) {
        let owner = accounts.get(2).ok_or(SolanaError::AccountNotFound(format!(
            "{}.owner",
            method_name
        )))?;
        let signers = &accounts[3..];
        return Ok(template_instruction(
            PROGRAM_NAME,
            method_name,
            json!({
                "source_account": source_account,
                "delegate_account": delegate_account,
                "owner": owner,
                "signers": signers,
                "amount": amount,
            }),
            json!({
                "source_account": source_account,
                "delegate_account": delegate_account,
                "amount": amount,
            }),
        ));
    }
    let owner = accounts.get(2).ok_or(SolanaError::AccountNotFound(format!(
        "{}.owner",
        method_name
    )))?;
    Ok(template_instruction(
        PROGRAM_NAME,
        method_name,
        json!({
            "source_account": source_account,
            "delegate_account": delegate_account,
            "owner": owner,
            "amount": amount,
        }),
        json!({
            "source_account": source_account,
            "delegate_account": delegate_account,
            "amount": amount,
        }),
    ))
}

fn revoke(accounts: Vec<String>) -> Result<Value> {
    let method_name = "Revoke";

    let source_account = accounts.get(0).ok_or(SolanaError::AccountNotFound(format!(
        "{}.source_account",
        method_name
    )))?;
    if is_multisig(&accounts, 2) {
        let owner = accounts.get(1).ok_or(SolanaError::AccountNotFound(format!(
            "{}.owner",
            method_name
        )))?;
        let signers = &accounts[2..];
        return Ok(template_instruction(
            PROGRAM_NAME,
            method_name,
            json!({
                "source_account": source_account,
                "owner": owner,
                "signers": signers,
            }),
            json!({
                "source_account": source_account,
            }),
        ));
    }
    let owner = accounts.get(1).ok_or(SolanaError::AccountNotFound(format!(
        "{}.owner",
        method_name
    )))?;
    return Ok(template_instruction(
        PROGRAM_NAME,
        method_name,
        json!({
            "source_account": source_account,
            "owner": owner,
        }),
        json!({
            "source_account": source_account,
        }),
    ));
}

fn set_authority(
    accounts: Vec<String>,
    authority_type: AuthorityType,
    new_authority: COption<Pubkey>,
) -> Result<Value> {
    let method_name = "SetAuthority";

    let account = accounts.get(0).ok_or(SolanaError::AccountNotFound(format!(
        "{}.account",
        method_name
    )))?;
    let authority_type = match authority_type {
        AuthorityType::AccountOwner => "account owner",
        AuthorityType::CloseAccount => "close account",
        AuthorityType::MintTokens => "mint tokens",
        AuthorityType::FreezeAccount => "freeze account",
    };
    let new_authority_pubkey = map_coption_to_option(new_authority.map(|v| v.to_string()));
    if is_multisig(&accounts, 2) {
        let old_authority_pubkey = accounts.get(1).ok_or(SolanaError::AccountNotFound(format!(
            "{}.old_authority_pubkey",
            method_name
        )))?;
        let signers = &accounts[2..];
        Ok(template_instruction(
            PROGRAM_NAME,
            method_name,
            json!({
                "account": account,
                "old_authority_pubkey": old_authority_pubkey,
                "signers": signers,
                "authority_type": authority_type,
                "new_authority_pubkey": new_authority_pubkey,
            }),
            json!({
                "account": account,
                "old_authority_pubkey": old_authority_pubkey,
                "authority_type": authority_type,
                "new_authority_pubkey": new_authority_pubkey,
            }),
        ))
    } else {
        let old_authority_pubkey = accounts.get(1).ok_or(SolanaError::AccountNotFound(format!(
            "{}.old_authority_pubkey",
            method_name
        )))?;
        Ok(template_instruction(
            PROGRAM_NAME,
            method_name,
            json!({
                "account": account,
                "old_authority_pubkey": old_authority_pubkey,
                "authority_type": authority_type,
                "new_authority_pubkey": new_authority_pubkey,
            }),
            json!({
                "account": account,
                "old_authority_pubkey": old_authority_pubkey,
                "authority_type": authority_type,
                "new_authority_pubkey": new_authority_pubkey,
            }),
        ))
    }
}

fn mint_to(accounts: Vec<String>, amount: u64) -> Result<Value> {
    let method_name = "MintTo";

    let mint = accounts.get(0).ok_or(SolanaError::AccountNotFound(format!(
        "{}.mint",
        method_name
    )))?;
    let mint_to_account = accounts.get(1).ok_or(SolanaError::AccountNotFound(format!(
        "{}.mint_to_account",
        method_name
    )))?;
    let amount = amount.to_string();
    if is_multisig(&accounts, 3) {
        let mint_authority_pubkey = accounts.get(2).ok_or(SolanaError::AccountNotFound(
            format!("{}.mint_authority_pubkey", method_name),
        ))?;
        let signers = &accounts[3..];
        Ok(template_instruction(
            PROGRAM_NAME,
            method_name,
            json!({
                "mint": mint,
                "mint_to_account": mint_to_account,
                "mint_authority_pubkey": mint_authority_pubkey,
                "signers": signers,
                "amount": amount,
            }),
            json!({
                "mint": mint,
                "mint_to_account": mint_to_account,
                "amount": amount,
            }),
        ))
    } else {
        let mint_authority_pubkey = accounts.get(2).ok_or(SolanaError::AccountNotFound(
            format!("{}.mint_authority_pubkey", method_name),
        ))?;
        Ok(template_instruction(
            PROGRAM_NAME,
            method_name,
            json!({
                "mint": mint,
                "mint_to_account": mint_to_account,
                "mint_authority_pubkey": mint_authority_pubkey,
                "amount": amount,
            }),
            json!({
                "mint": mint,
                "mint_to_account": mint_to_account,
                "amount": amount,
            }),
        ))
    }
}

fn burn(accounts: Vec<String>, amount: u64) -> Result<Value> {
    let method_name = "Burn";

    let account = accounts.get(0).ok_or(SolanaError::AccountNotFound(format!(
        "{}.account",
        method_name
    )))?;
    let mint = accounts.get(1).ok_or(SolanaError::AccountNotFound(format!(
        "{}.mint",
        method_name
    )))?;
    let amount = amount.to_string();
    if is_multisig(&accounts, 3) {
        let owner = accounts.get(2).ok_or(SolanaError::AccountNotFound(format!(
            "{}.owner",
            method_name
        )))?;
        let signers = &accounts[3..];
        Ok(template_instruction(
            PROGRAM_NAME,
            method_name,
            json!({
                "account": account,
                "mint": mint,
                "owner": owner,
                "signers": signers,
                "amount": amount,
            }),
            json!({
                "account": account,
                "mint": mint,
                "amount": amount,
            }),
        ))
    } else {
        let owner = accounts.get(2).ok_or(SolanaError::AccountNotFound(format!(
            "{}.owner",
            method_name
        )))?;
        Ok(template_instruction(
            PROGRAM_NAME,
            method_name,
            json!({
                "account": account,
                "mint": mint,
                "owner": owner,
                "amount": amount,
            }),
            json!({
                "account": account,
                "mint": mint,
                "amount": amount,
            }),
        ))
    }
}

fn close_account(accounts: Vec<String>) -> Result<Value> {
    let method_name = "CloseAccount";
    let account = accounts.get(0).ok_or(SolanaError::AccountNotFound(format!(
        "{}.account",
        method_name
    )))?;
    let recipient = accounts.get(1).ok_or(SolanaError::AccountNotFound(format!(
        "{}.recipient",
        method_name
    )))?;
    if is_multisig(&accounts, 3) {
        let owner = accounts.get(2).ok_or(SolanaError::AccountNotFound(format!(
            "{}.owner",
            method_name
        )))?;
        let signers = &accounts[3..];
        Ok(template_instruction(
            PROGRAM_NAME,
            method_name,
            json!({
                "account": account,
                "recipient": recipient,
                "owner": owner,
                "signers": signers,
            }),
            json!({
                "account": account,
                "recipient": recipient,
            }),
        ))
    } else {
        let owner = accounts
            .get(2)
            .ok_or(SolanaError::AccountNotFound(format!("CloseAccount.owner")))?;
        Ok(template_instruction(
            PROGRAM_NAME,
            "Burn",
            json!({
                "account": account,
                "recipient": recipient,
                "owner": owner,
            }),
            json!({
                "account": account,
                "recipient": recipient,
            }),
        ))
    }
}

fn freeze_account(accounts: Vec<String>) -> Result<Value> {
    let method_name = "FreezeAccount";
    let account = accounts.get(0).ok_or(SolanaError::AccountNotFound(format!(
        "{}.account",
        method_name
    )))?;
    let mint = accounts.get(1).ok_or(SolanaError::AccountNotFound(format!(
        "{}.mint",
        method_name
    )))?;
    if is_multisig(&accounts, 3) {
        let mint_freeze_authority_pubkey = accounts.get(2).ok_or(SolanaError::AccountNotFound(
            format!("{}.mint_freeze_authority_pubkey", method_name),
        ))?;
        let signers = &accounts[3..];
        Ok(template_instruction(
            PROGRAM_NAME,
            method_name,
            json!({
                "account": account,
                "mint": mint,
                "mint_freeze_authority_pubkey": mint_freeze_authority_pubkey,
                "signers": signers,
            }),
            json!({
                "account": account,
                "mint": mint,
            }),
        ))
    } else {
        let mint_freeze_authority_pubkey = accounts.get(2).ok_or(SolanaError::AccountNotFound(
            format!("{}.mint_freeze_authority_pubkey", method_name),
        ))?;
        Ok(template_instruction(
            PROGRAM_NAME,
            method_name,
            json!({
                "account": account,
                "mint": mint,
                "mint_freeze_authority_pubkey": mint_freeze_authority_pubkey,
            }),
            json!({
                "account": account,
                "mint": mint,
            }),
        ))
    }
}

fn thaw_account(accounts: Vec<String>) -> Result<Value> {
    let method_name = "ThawAccount";
    let account = accounts.get(0).ok_or(SolanaError::AccountNotFound(format!(
        "{}.account",
        method_name
    )))?;
    let mint = accounts.get(1).ok_or(SolanaError::AccountNotFound(format!(
        "{}.mint",
        method_name
    )))?;
    if is_multisig(&accounts, 3) {
        let mint_freeze_authority_pubkey = accounts.get(2).ok_or(SolanaError::AccountNotFound(
            format!("{}.mint_freeze_authority_pubkey", method_name),
        ))?;
        let signers = &accounts[3..];
        Ok(template_instruction(
            PROGRAM_NAME,
            method_name,
            json!({
                "account": account,
                "mint": mint,
                "mint_freeze_authority_pubkey": mint_freeze_authority_pubkey,
                "signers": signers,
            }),
            json!({
                "account": account,
                "mint": mint,
            }),
        ))
    } else {
        let mint_freeze_authority_pubkey = accounts.get(2).ok_or(SolanaError::AccountNotFound(
            format!("{}.mint_freeze_authority_pubkey", method_name),
        ))?;
        Ok(template_instruction(
            PROGRAM_NAME,
            method_name,
            json!({
                "account": account,
                "mint": mint,
                "mint_freeze_authority_pubkey": mint_freeze_authority_pubkey,
            }),
            json!({
                "account": account,
                "mint": mint,
            }),
        ))
    }
}

fn transfer_checked(accounts: Vec<String>, decimals: u8, amount: u64) -> Result<Value> {
    let method_name = "TransferChecked";
    if is_multisig(&accounts, 4) {
        let account = accounts.get(0).ok_or(SolanaError::AccountNotFound(format!(
            "{}.account",
            method_name
        )))?;
        let mint = accounts.get(1).ok_or(SolanaError::AccountNotFound(format!(
            "{}.mint",
            method_name
        )))?;
        let recipient = accounts.get(2).ok_or(SolanaError::AccountNotFound(format!(
            "{}.recipient",
            method_name
        )))?;
        let owner = accounts.get(3).ok_or(SolanaError::AccountNotFound(format!(
            "{}.owner",
            method_name
        )))?;
        let signers = &accounts[4..];
        let amount = amount.to_string();
        Ok(template_instruction(
            PROGRAM_NAME,
            method_name,
            json!({
                "account": account,
                "mint": mint,
                "recipient": recipient,
                "owner": owner,
                "signers": signers,
                "decimals": decimals,
                "amount": amount,
            }),
            json!({
                "account": account,
                "mint": mint,
                "recipient": recipient,
                "decimals": decimals,
                "amount": amount,
            }),
        ))
    } else {
        let account = accounts.get(0).ok_or(SolanaError::AccountNotFound(format!(
            "{}.account",
            method_name
        )))?;
        let mint = accounts.get(1).ok_or(SolanaError::AccountNotFound(format!(
            "{}.mint",
            method_name
        )))?;
        let recipient = accounts.get(2).ok_or(SolanaError::AccountNotFound(format!(
            "{}.recipient",
            method_name
        )))?;
        let owner = accounts.get(3).ok_or(SolanaError::AccountNotFound(format!(
            "{}.owner",
            method_name
        )))?;
        let amount = amount.to_string();
        Ok(template_instruction(
            PROGRAM_NAME,
            method_name,
            json!({
                "account": account,
                "mint": mint,
                "recipient": recipient,
                "owner": owner,
                "decimals": decimals,
                "amount": amount,
            }),
            json!({
                "account": account,
                "mint": mint,
                "recipient": recipient,
                "decimals": decimals,
                "amount": amount,
            }),
        ))
    }
}

fn approve_checked(accounts: Vec<String>, decimals: u8, amount: u64) -> Result<Value> {
    let method_name = "ApproveChecked";
    if is_multisig(&accounts, 4) {
        let account = accounts.get(0).ok_or(SolanaError::AccountNotFound(format!(
            "{}.account",
            method_name
        )))?;
        let mint = accounts.get(1).ok_or(SolanaError::AccountNotFound(format!(
            "{}.mint",
            method_name
        )))?;
        let delegate = accounts.get(2).ok_or(SolanaError::AccountNotFound(format!(
            "{}.delegate",
            method_name
        )))?;
        let owner = accounts.get(3).ok_or(SolanaError::AccountNotFound(format!(
            "{}.owner",
            method_name
        )))?;
        let signers = &accounts[4..];
        let amount = amount.to_string();
        Ok(template_instruction(
            PROGRAM_NAME,
            method_name,
            json!({
                "account": account,
                "mint": mint,
                "delegate": delegate,
                "owner": owner,
                "signers": signers,
                "decimals": decimals,
                "amount": amount,
            }),
            json!({
                "account": account,
                "mint": mint,
                "delegate": delegate,
                "decimals": decimals,
                "amount": amount,
            }),
        ))
    } else {
        let account = accounts.get(0).ok_or(SolanaError::AccountNotFound(format!(
            "{}.account",
            method_name
        )))?;
        let mint = accounts.get(1).ok_or(SolanaError::AccountNotFound(format!(
            "{}.mint",
            method_name
        )))?;
        let delegate = accounts.get(2).ok_or(SolanaError::AccountNotFound(format!(
            "{}.delegate",
            method_name
        )))?;
        let owner = accounts.get(3).ok_or(SolanaError::AccountNotFound(format!(
            "{}.owner",
            method_name
        )))?;
        let amount = amount.to_string();
        Ok(template_instruction(
            PROGRAM_NAME,
            method_name,
            json!({
                "account": account,
                "mint": mint,
                "delegate": delegate,
                "owner": owner,
                "decimals": decimals,
                "amount": amount,
            }),
            json!({
                "account": account,
                "mint": mint,
                "delegate": delegate,
                "decimals": decimals,
                "amount": amount,
            }),
        ))
    }
}

fn mint_to_checked(accounts: Vec<String>, decimals: u8, amount: u64) -> Result<Value> {
    let method_name = "MintToChecked";
    let mint = accounts.get(0).ok_or(SolanaError::AccountNotFound(format!(
        "{}.mint",
        method_name
    )))?;
    let mint_to_account = accounts.get(1).ok_or(SolanaError::AccountNotFound(format!(
        "{}.mint_to_account",
        method_name
    )))?;
    let amount = amount.to_string();
    if is_multisig(&accounts, 3) {
        let mint_authority_pubkey = accounts.get(2).ok_or(SolanaError::AccountNotFound(
            format!("{}.mint_authority_pubkey", method_name),
        ))?;
        let signers = &accounts[3..];
        Ok(template_instruction(
            PROGRAM_NAME,
            method_name,
            json!({
                "mint": mint,
                "mint_to_account": mint_to_account,
                "mint_authority_pubkey": mint_authority_pubkey,
                "signers": signers,
                "decimals": decimals,
                "amount": amount,
            }),
            json!({
                "mint": mint,
                "mint_to_account": mint_to_account,
                "decimals": decimals,
                "amount": amount,
            }),
        ))
    } else {
        let mint_authority_pubkey = accounts.get(2).ok_or(SolanaError::AccountNotFound(
            format!("{}.mint_authority_pubkey", method_name),
        ))?;
        Ok(template_instruction(
            PROGRAM_NAME,
            method_name,
            json!({
                "mint": mint,
                "mint_to_account": mint_to_account,
                "mint_authority_pubkey": mint_authority_pubkey,
                "decimals": decimals,
                "amount": amount,
            }),
            json!({
                "mint": mint,
                "mint_to_account": mint_to_account,
                "decimals": decimals,
                "amount": amount,
            }),
        ))
    }
}

fn burn_checked(accounts: Vec<String>, decimals: u8, amount: u64) -> Result<Value> {
    let method_name = "BurnChecked";
    let account = accounts.get(0).ok_or(SolanaError::AccountNotFound(format!(
        "{}.account",
        method_name
    )))?;
    let mint = accounts.get(1).ok_or(SolanaError::AccountNotFound(format!(
        "{}.mint",
        method_name
    )))?;
    let amount = amount.to_string();
    if is_multisig(&accounts, 3) {
        let owner = accounts.get(2).ok_or(SolanaError::AccountNotFound(format!(
            "{}.owner",
            method_name
        )))?;
        let signers = &accounts[3..];
        Ok(template_instruction(
            PROGRAM_NAME,
            method_name,
            json!({
                "account": account,
                "mint": mint,
                "owner": owner,
                "signers": signers,
                "decimals": decimals,
                "amount": amount,
            }),
            json!({
                "account": account,
                "mint": mint,
                "decimals": decimals,
                "amount": amount,
            }),
        ))
    } else {
        let owner = accounts.get(2).ok_or(SolanaError::AccountNotFound(format!(
            "{}.owner",
            method_name
        )))?;
        Ok(template_instruction(
            PROGRAM_NAME,
            method_name,
            json!({
                "account": account,
                "mint": mint,
                "owner": owner,
                "decimals": decimals,
                "amount": amount,
            }),
            json!({
                "account": account,
                "mint": mint,
                "decimals": decimals,
                "amount": amount,
            }),
        ))
    }
}

fn initialize_account_2(accounts: Vec<String>, owner: Pubkey) -> Result<Value> {
    let method_name = "InitializeAccount2";
    let account = accounts.get(0).ok_or(SolanaError::AccountNotFound(format!(
        "{}.account",
        method_name
    )))?;
    let mint = accounts.get(1).ok_or(SolanaError::AccountNotFound(format!(
        "{}.mint",
        method_name
    )))?;
    let sysver_rent = accounts.get(2).ok_or(SolanaError::AccountNotFound(format!(
        "{}.sysver_rent",
        method_name
    )))?;
    let owner = owner.to_string();
    Ok(template_instruction(
        PROGRAM_NAME,
        method_name,
        json!({
            "account": account,
            "mint": mint,
            "sysver_rent": sysver_rent,
            "owner": owner,
        }),
        json!({
            "account": account,
            "mint": mint,
        }),
    ))
}

fn sync_native(accounts: Vec<String>) -> Result<Value> {
    let method_name = "SyncNative";
    let account_to_sync = accounts.get(0).ok_or(SolanaError::AccountNotFound(format!(
        "{}.account_to_sync",
        method_name
    )))?;
    Ok(template_instruction(
        PROGRAM_NAME,
        method_name,
        json!({
            "account_to_sync": account_to_sync,
        }),
        json!({
            "account_to_sync": account_to_sync,
        }),
    ))
}

fn initialize_account_3(accounts: Vec<String>, owner: Pubkey) -> Result<Value> {
    let method_name = "InitializeAccount3";
    let account = accounts.get(0).ok_or(SolanaError::AccountNotFound(format!(
        "{}.account",
        method_name
    )))?;
    let mint = accounts.get(1).ok_or(SolanaError::AccountNotFound(format!(
        "{}.mint",
        method_name
    )))?;
    let owner = owner.to_string();
    Ok(template_instruction(
        PROGRAM_NAME,
        method_name,
        json!({
            "account": account,
            "mint": mint,
            "owner": owner,
        }),
        json!({
            "account": account,
            "mint": mint,
        }),
    ))
}

fn initialize_multisig_2(accounts: Vec<String>, m: u8) -> Result<Value> {
    let method_name = "InitializeMultisig2";
    let multisig_account = accounts.get(0).ok_or(SolanaError::AccountNotFound(format!(
        "{}.multisig_account",
        method_name
    )))?;
    let attendees = &accounts[1..];
    let required_signatures = m;
    Ok(template_instruction(
        PROGRAM_NAME,
        method_name,
        json!({
            "multisig_account": multisig_account,
            "attendees": attendees,
            "required_signatures": required_signatures,
        }),
        json!({
            "multisig_account": multisig_account,
            "attendees": attendees,
            "required_signatures": required_signatures,
        }),
    ))
}

fn initialize_mint_2(
    accounts: Vec<String>,
    mint_authority_pubkey: Pubkey,
    decimals: u8,
    freeze_authority_pubkey: COption<Pubkey>,
) -> Result<Value> {
    let method_name = "InitializeMint2";
    let mint = accounts.get(0).ok_or(SolanaError::AccountNotFound(format!(
        "{}.mint",
        method_name
    )))?;
    let mint_authority_pubkey = mint_authority_pubkey.to_string();
    let freeze_authority_pubkey =
        map_coption_to_option(freeze_authority_pubkey.map(|v| v.to_string()));
    Ok(template_instruction(
        PROGRAM_NAME,
        method_name,
        json!({
            "mint": mint,
            "mint_authority_pubkey": mint_authority_pubkey,
            "freeze_authority_pubkey": freeze_authority_pubkey,
            "decimals": decimals,
        }),
        json!({
            "mint": mint,
            "mint_authority_pubkey": mint_authority_pubkey,
            "freeze_authority_pubkey": freeze_authority_pubkey,
            "decimals": decimals,
        }),
    ))
}

'''
'''--- blockchains/solana/src/resolvers/token_lending.rs ---
use crate::error::{Result, SolanaError};
use crate::resolvers::template_instruction;
use crate::solana_lib::solana_program::pubkey::Pubkey;
use crate::solana_lib::spl::token_lending::instruction::LendingInstruction;
use crate::solana_lib::spl::token_lending::state::ReserveConfig;
use serde_json::{json, Value};

static PROGRAM_NAME: &str = "TokenLending";

pub fn resolve(instruction: LendingInstruction, accounts: Vec<String>) -> Result<Value> {
    match instruction {
        LendingInstruction::InitLendingMarket {
            owner,
            quote_currency,
        } => init_lending_market(accounts, owner, quote_currency),
        LendingInstruction::SetLendingMarketOwner { new_owner } => {
            set_lending_market_owner(accounts, new_owner)
        }
        LendingInstruction::InitReserve {
            liquidity_amount,
            config,
        } => init_reserve(accounts, liquidity_amount, config),
        LendingInstruction::RefreshReserve => refresh_reserve(accounts),
        LendingInstruction::DepositReserveLiquidity { liquidity_amount } => {
            deposit_reserve_liquidity(accounts, liquidity_amount)
        }
        LendingInstruction::RedeemReserveCollateral { collateral_amount } => {
            redeem_reserve_collateral(accounts, collateral_amount)
        }
        LendingInstruction::InitObligation => init_obligation(accounts),
        LendingInstruction::RefreshObligation => refresh_obligation(accounts),
        LendingInstruction::DepositObligationCollateral { collateral_amount } => {
            deposit_obligation_collateral(accounts, collateral_amount)
        }
        LendingInstruction::WithdrawObligationCollateral { collateral_amount } => {
            withdraw_obligation_collateral(accounts, collateral_amount)
        }
        LendingInstruction::BorrowObligationLiquidity { liquidity_amount } => {
            borrow_obligation_liquidity(accounts, liquidity_amount)
        }
        LendingInstruction::RepayObligationLiquidity { liquidity_amount } => {
            repay_obligation_liquidity(accounts, liquidity_amount)
        }
        LendingInstruction::LiquidateObligation { liquidity_amount } => {
            liquidate_obligation(accounts, liquidity_amount)
        }
        LendingInstruction::FlashLoan { amount } => flash_loan(accounts, amount),
    }
}

fn init_lending_market(
    accounts: Vec<String>,
    owner: Pubkey,
    quote_currency: [u8; 32],
) -> Result<Value> {
    let method_name = "InitLendingMarket";
    let lending_market_account = accounts.get(0).ok_or(SolanaError::AccountNotFound(format!(
        "{}.lending_market_account",
        method_name,
    )))?;
    let sysvar_rent = accounts.get(1).ok_or(SolanaError::AccountNotFound(format!(
        "{}.account",
        method_name
    )))?;
    let token_program_id = accounts.get(2).ok_or(SolanaError::AccountNotFound(format!(
        "{}.token_program_id",
        method_name
    )))?;
    let oracle_program_id = accounts.get(3).ok_or(SolanaError::AccountNotFound(format!(
        "{}.oracle_program_id",
        method_name
    )))?;
    let owner = owner.to_string();
    let quote_currency = std::str::from_utf8(&quote_currency)
        .map_err(|_| SolanaError::InvalidData(format!("{}.quote_currency", method_name)))?;
    Ok(template_instruction(
        PROGRAM_NAME,
        method_name,
        json!({
            "lending_market_account": lending_market_account,
            "sysvar_rent": sysvar_rent,
            "token_program_id": token_program_id,
            "oracle_program_id": oracle_program_id,
            "owner": owner,
            "quote_currency": quote_currency,
        }),
        json!({
            "lending_market_account": lending_market_account,
            "quote_currency": quote_currency,
        }),
    ))
}

fn set_lending_market_owner(accounts: Vec<String>, new_owner: Pubkey) -> Result<Value> {
    let method_name = "SetLendingMarketOwner";
    let lending_market_account = accounts.get(0).ok_or(SolanaError::AccountNotFound(format!(
        "{}.lending_market_account",
        method_name,
    )))?;
    let current_owner = accounts.get(1).ok_or(SolanaError::AccountNotFound(format!(
        "{}.current_owner",
        method_name
    )))?;
    let new_owner = new_owner.to_string();
    Ok(template_instruction(
        PROGRAM_NAME,
        method_name,
        json!({
            "lending_market_account": lending_market_account,
            "current_owner": current_owner,
            "new_owner": new_owner,
        }),
        json!({
            "lending_market_account": lending_market_account,
            "current_owner": current_owner,
            "new_owner": new_owner,
        }),
    ))
}

fn init_reserve(
    accounts: Vec<String>,
    liquidity_amount: u64,
    config: ReserveConfig,
) -> Result<Value> {
    let method_name = "SetLendingMarketOwner";
    let source_liquidity_account = accounts.get(0).ok_or(SolanaError::AccountNotFound(format!(
        "{}.source_liquidity_account",
        method_name,
    )))?;
    let destination_collateral_account = accounts.get(1).ok_or(SolanaError::AccountNotFound(
        format!("{}.destination_collateral_account", method_name),
    ))?;
    let reserve_account = accounts.get(2).ok_or(SolanaError::AccountNotFound(format!(
        "{}.reserve_account",
        method_name
    )))?;
    let reserve_liquidity_mint = accounts.get(3).ok_or(SolanaError::AccountNotFound(format!(
        "{}.reserve_liquidity_mint",
        method_name
    )))?;
    let reserve_liquidity_supply_account = accounts.get(4).ok_or(SolanaError::AccountNotFound(
        format!("{}.reserve_liquidity_supply_account", method_name),
    ))?;
    let reserve_liquidity_fee_receiver = accounts.get(5).ok_or(SolanaError::AccountNotFound(
        format!("{}.reserve_liquidity_fee_receiver", method_name),
    ))?;
    let reserve_collateral_mint = accounts.get(6).ok_or(SolanaError::AccountNotFound(format!(
        "{}.reserve_collateral_mint",
        method_name
    )))?;
    let reserve_collateral_supply_pubkey = accounts.get(7).ok_or(SolanaError::AccountNotFound(
        format!("{}.reserve_collateral_supply_pubkey", method_name),
    ))?;
    let pyth_product_account = accounts.get(8).ok_or(SolanaError::AccountNotFound(format!(
        "{}.pyth_product_account",
        method_name
    )))?;
    let pyth_price_account = accounts.get(9).ok_or(SolanaError::AccountNotFound(format!(
        "{}.pyth_price_account",
        method_name
    )))?;
    let lending_market_account = accounts
        .get(10)
        .ok_or(SolanaError::AccountNotFound(format!(
            "{}.lending_market_account",
            method_name
        )))?;
    let lending_market_authority_pubkey =
        accounts
            .get(11)
            .ok_or(SolanaError::AccountNotFound(format!(
                "{}.lending_market_authority_pubkey",
                method_name
            )))?;
    let lending_market_owner = accounts
        .get(12)
        .ok_or(SolanaError::AccountNotFound(format!(
            "{}.lending_market_owner",
            method_name
        )))?;
    let user_transfer_authority_pubkey =
        accounts
            .get(13)
            .ok_or(SolanaError::AccountNotFound(format!(
                "{}.user_transfer_authority_pubkey",
                method_name
            )))?;
    let sysvar_clock = accounts
        .get(14)
        .ok_or(SolanaError::AccountNotFound(format!(
            "{}.sysvar_clock",
            method_name
        )))?;
    let sysvar_rent = accounts
        .get(15)
        .ok_or(SolanaError::AccountNotFound(format!(
            "{}.sysvar_rent",
            method_name
        )))?;
    let token_program_id = accounts
        .get(16)
        .ok_or(SolanaError::AccountNotFound(format!(
            "{}.token_program_id",
            method_name
        )))?;
    let liquidity_amount = liquidity_amount.to_string();
    let reserve_config = json!({
        "optimal_utilization_rate": config.optimal_utilization_rate,
        "loan_to_value_ratio": config.loan_to_value_ratio,
        "liquidation_bonus": config.liquidation_bonus,
        "liquidation_threshold": config.liquidation_threshold,
        "min_borrow_rate": config.min_borrow_rate,
        "optimal_borrow_rate": config.optimal_borrow_rate,
        "max_borrow_rate": config.max_borrow_rate,
        "fees": {
            "borrow_fee_wad": config.fees.borrow_fee_wad.to_string(),
            "flash_loan_fee_wad": config.fees.flash_loan_fee_wad.to_string(),
            "host_fee_percentage": config.fees.host_fee_percentage.to_string(),
        },
    });
    Ok(template_instruction(
        PROGRAM_NAME,
        method_name,
        json!({
            "source_liquidity_account": source_liquidity_account,
            "destination_collateral_account": destination_collateral_account,
            "reserve_account": reserve_account,
            "reserve_liquidity_mint": reserve_liquidity_mint,
            "reserve_liquidity_supply_account": reserve_liquidity_supply_account,
            "reserve_liquidity_fee_receiver": reserve_liquidity_fee_receiver,
            "reserve_collateral_mint": reserve_collateral_mint,
            "reserve_collateral_supply_pubkey": reserve_collateral_supply_pubkey,
            "pyth_product_account": pyth_product_account,
            "pyth_price_account": pyth_price_account,
            "lending_market_account": lending_market_account,
            "lending_market_authority_pubkey": lending_market_authority_pubkey,
            "lending_market_owner": lending_market_owner,
            "user_transfer_authority_pubkey": user_transfer_authority_pubkey,
            "sysvar_clock": sysvar_clock,
            "sysvar_rent": sysvar_rent,
            "token_program_id": token_program_id,
            "liquidity_amount": liquidity_amount,
            "reserve_config": reserve_config,
        }),
        json!({
            "source_liquidity_account": source_liquidity_account,
            "destination_collateral_account": destination_collateral_account,
            "reserve_account": reserve_account,
            "reserve_liquidity_mint": reserve_liquidity_mint,
            "reserve_liquidity_supply_account": reserve_liquidity_supply_account,
            "reserve_liquidity_fee_receiver": reserve_liquidity_fee_receiver,
            "reserve_collateral_mint": reserve_collateral_mint,
            "reserve_collateral_supply_pubkey": reserve_collateral_supply_pubkey,
            "pyth_product_account": pyth_product_account,
            "pyth_price_account": pyth_price_account,
            "lending_market_account": lending_market_account,
            "lending_market_owner": lending_market_owner,
            "liquidity_amount": liquidity_amount,
            "reserve_config": reserve_config,
        }),
    ))
}

fn refresh_reserve(accounts: Vec<String>) -> Result<Value> {
    let method_name = "RefreshReserve";
    let reserve_account = accounts.get(0).ok_or(SolanaError::AccountNotFound(format!(
        "{}.reserve_account",
        method_name,
    )))?;
    let reserve_liquidity_oracle_account = accounts.get(1).ok_or(SolanaError::AccountNotFound(
        format!("{}.reserve_liquidity_oracle_account", method_name),
    ))?;
    let sysvar_clock = accounts.get(1).ok_or(SolanaError::AccountNotFound(format!(
        "{}.sysvar_clock",
        method_name
    )))?;
    Ok(template_instruction(
        PROGRAM_NAME,
        method_name,
        json!({
            "reserve_account": reserve_account,
            "reserve_liquidity_oracle_account": reserve_liquidity_oracle_account,
            "sysvar_clock": sysvar_clock,
        }),
        json!({
            "reserve_account": reserve_account,
            "reserve_liquidity_oracle_account": reserve_liquidity_oracle_account,
        }),
    ))
}

fn deposit_reserve_liquidity(accounts: Vec<String>, liquidity_amount: u64) -> Result<Value> {
    let method_name = "DepositReserveLiquidity";
    let source_liquidity_account = accounts.get(0).ok_or(SolanaError::AccountNotFound(format!(
        "{}.source_liquidity_account",
        method_name,
    )))?;
    let destination_collateral_account = accounts.get(1).ok_or(SolanaError::AccountNotFound(
        format!("{}.destination_collateral_account", method_name),
    ))?;
    let reserve_account = accounts.get(2).ok_or(SolanaError::AccountNotFound(format!(
        "{}.reserve_account",
        method_name
    )))?;
    let reserve_liquidity_supply_account = accounts.get(3).ok_or(SolanaError::AccountNotFound(
        format!("{}.reserve_liquidity_supply_account", method_name),
    ))?;
    let reserve_collateral_mint = accounts.get(4).ok_or(SolanaError::AccountNotFound(format!(
        "{}.reserve_collateral_mint",
        method_name
    )))?;
    let lending_market_account = accounts.get(5).ok_or(SolanaError::AccountNotFound(format!(
        "{}.lending_market_account",
        method_name
    )))?;
    let lending_market_authority_pubkey = accounts.get(6).ok_or(SolanaError::AccountNotFound(
        format!("{}.lending_market_authority_pubkey", method_name),
    ))?;
    let user_transfer_authority_pubkey = accounts.get(7).ok_or(SolanaError::AccountNotFound(
        format!("{}.user_transfer_authority_pubkey", method_name),
    ))?;
    let sysvar_clock = accounts.get(8).ok_or(SolanaError::AccountNotFound(format!(
        "{}.sysvar_clock",
        method_name
    )))?;
    let token_program_id = accounts.get(9).ok_or(SolanaError::AccountNotFound(format!(
        "{}.token_program_id",
        method_name
    )))?;
    let liquidity_amount = liquidity_amount.to_string();
    Ok(template_instruction(
        PROGRAM_NAME,
        method_name,
        json!({
            "source_liquidity_account": source_liquidity_account,
            "destination_collateral_account": destination_collateral_account,
            "reserve_account": reserve_account,
            "reserve_liquidity_supply_account": reserve_liquidity_supply_account,
            "reserve_collateral_mint": reserve_collateral_mint,
            "lending_market_account": lending_market_account,
            "lending_market_authority_pubkey": lending_market_authority_pubkey,
            "user_transfer_authority_pubkey": user_transfer_authority_pubkey,
            "sysvar_clock": sysvar_clock,
            "token_program_id": token_program_id,
            "liquidity_amount": liquidity_amount,
        }),
        json!({
            "source_liquidity_account": source_liquidity_account,
            "destination_collateral_account": destination_collateral_account,
            "reserve_account": reserve_account,
            "reserve_liquidity_supply_account": reserve_liquidity_supply_account,
            "reserve_collateral_mint": reserve_collateral_mint,
            "lending_market_account": lending_market_account,
            "liquidity_amount": liquidity_amount,
        }),
    ))
}

fn redeem_reserve_collateral(accounts: Vec<String>, collateral_amount: u64) -> Result<Value> {
    let method_name = "RedeemReserveCollateral";
    let source_collateral_account = accounts.get(0).ok_or(SolanaError::AccountNotFound(
        format!("{}.source_collateral_account", method_name,),
    ))?;
    let destination_liquidity_account = accounts.get(1).ok_or(SolanaError::AccountNotFound(
        format!("{}.destination_liquidity_account", method_name),
    ))?;
    let reserve_account = accounts.get(2).ok_or(SolanaError::AccountNotFound(format!(
        "{}.reserve_account",
        method_name
    )))?;
    let reserve_collateral_mint = accounts.get(3).ok_or(SolanaError::AccountNotFound(format!(
        "{}.reserve_collateral_mint",
        method_name
    )))?;
    let reserve_liquidity_supply_account = accounts.get(4).ok_or(SolanaError::AccountNotFound(
        format!("{}.reserve_liquidity_supply_account", method_name),
    ))?;
    let lending_market_account = accounts.get(5).ok_or(SolanaError::AccountNotFound(format!(
        "{}.lending_market_account",
        method_name
    )))?;
    let lending_market_authority_pubkey = accounts.get(6).ok_or(SolanaError::AccountNotFound(
        format!("{}.lending_market_authority_pubkey", method_name),
    ))?;
    let user_transfer_authority_pubkey = accounts.get(7).ok_or(SolanaError::AccountNotFound(
        format!("{}.user_transfer_authority_pubkey", method_name),
    ))?;
    let sysvar_clock = accounts.get(8).ok_or(SolanaError::AccountNotFound(format!(
        "{}.sysvar_clock",
        method_name
    )))?;
    let token_program_id = accounts.get(9).ok_or(SolanaError::AccountNotFound(format!(
        "{}.sysvar_clock",
        method_name
    )))?;

    Ok(template_instruction(
        PROGRAM_NAME,
        method_name,
        json!({
            "source_collateral_account": source_collateral_account,
            "destination_liquidity_account": destination_liquidity_account,
            "reserve_account": reserve_account,
            "reserve_liquidity_supply_account": reserve_liquidity_supply_account,
            "reserve_collateral_mint": reserve_collateral_mint,
            "lending_market_account": lending_market_account,
            "lending_market_authority_pubkey": lending_market_authority_pubkey,
            "user_transfer_authority_pubkey": user_transfer_authority_pubkey,
            "sysvar_clock": sysvar_clock,
            "token_program_id": token_program_id,
            "collateral_amount": collateral_amount.to_string(),
        }),
        json!({
            "source_collateral_account": source_collateral_account,
            "destination_liquidity_account": destination_liquidity_account,
            "reserve_account": reserve_account,
            "reserve_liquidity_supply_account": reserve_liquidity_supply_account,
            "reserve_collateral_mint": reserve_collateral_mint,
            "lending_market_account": lending_market_account,
            "collateral_amount": collateral_amount.to_string(),
        }),
    ))
}

fn init_obligation(accounts: Vec<String>) -> Result<Value> {
    let method_name = "InitObligation";
    let obligation_account = accounts.get(0).ok_or(SolanaError::AccountNotFound(format!(
        "{}.obligation_account",
        method_name,
    )))?;
    let lending_market_account = accounts.get(1).ok_or(SolanaError::AccountNotFound(format!(
        "{}.lending_market_account",
        method_name
    )))?;
    let obligation_owner = accounts.get(2).ok_or(SolanaError::AccountNotFound(format!(
        "{}.obligation_owner",
        method_name
    )))?;
    let sysvar_clock = accounts.get(3).ok_or(SolanaError::AccountNotFound(format!(
        "{}.sysvar_clock",
        method_name
    )))?;
    let sysvar_rent = accounts.get(4).ok_or(SolanaError::AccountNotFound(format!(
        "{}.sysvar_rent",
        method_name
    )))?;
    let token_program_id = accounts.get(5).ok_or(SolanaError::AccountNotFound(format!(
        "{}.token_program_id",
        method_name
    )))?;

    Ok(template_instruction(
        PROGRAM_NAME,
        method_name,
        json!({
            "obligation_account": obligation_account,
            "lending_market_account": lending_market_account,
            "obligation_owner": obligation_owner,
            "sysvar_clock": sysvar_clock,
            "sysvar_rent": sysvar_rent,
            "token_program_id": token_program_id,
        }),
        json!({
            "obligation_account": obligation_account,
            "lending_market_account": lending_market_account,
            "obligation_owner": obligation_owner,
        }),
    ))
}

fn refresh_obligation(accounts: Vec<String>) -> Result<Value> {
    let method_name = "RefreshObligation";
    let obligation_account = accounts.get(0).ok_or(SolanaError::AccountNotFound(format!(
        "{}.obligation_account",
        method_name,
    )))?;
    let sysvar_clock = accounts.get(1).ok_or(SolanaError::AccountNotFound(format!(
        "{}.sysvar_clock",
        method_name
    )))?;
    let keys = &accounts[2..];

    Ok(template_instruction(
        PROGRAM_NAME,
        method_name,
        json!({
            "obligation_account": obligation_account,
            "sysvar_clock": sysvar_clock,
            "keys": keys,
        }),
        json!({
            "obligation_account": obligation_account,
        }),
    ))
}

fn deposit_obligation_collateral(accounts: Vec<String>, collateral_amount: u64) -> Result<Value> {
    let method_name = "DepositObligationCollateral";
    let source_collateral_account = accounts.get(0).ok_or(SolanaError::AccountNotFound(
        format!("{}.source_collateral_account", method_name,),
    ))?;
    let destination_collateral_account = accounts.get(1).ok_or(SolanaError::AccountNotFound(
        format!("{}.destination_collateral_account", method_name),
    ))?;
    let deposit_reserve_pubkey = accounts.get(2).ok_or(SolanaError::AccountNotFound(format!(
        "{}.deposit_reserve_pubkey",
        method_name
    )))?;
    let obligation_account = accounts.get(3).ok_or(SolanaError::AccountNotFound(format!(
        "{}.obligation_account",
        method_name
    )))?;
    let lending_market_account = accounts.get(4).ok_or(SolanaError::AccountNotFound(format!(
        "{}.lending_market_account",
        method_name
    )))?;
    let obligation_owner = accounts.get(5).ok_or(SolanaError::AccountNotFound(format!(
        "{}.obligation_owner",
        method_name
    )))?;
    let user_transfer_authority_pubkey = accounts.get(6).ok_or(SolanaError::AccountNotFound(
        format!("{}.user_transfer_authority_pubkey", method_name),
    ))?;
    let sysvar_clock = accounts.get(7).ok_or(SolanaError::AccountNotFound(format!(
        "{}.sysvar_clock",
        method_name
    )))?;
    let token_program_id = accounts.get(8).ok_or(SolanaError::AccountNotFound(format!(
        "{}.token_program_id",
        method_name
    )))?;

    Ok(template_instruction(
        PROGRAM_NAME,
        method_name,
        json!({
            "source_collateral_account": source_collateral_account,
            "destination_collateral_account": destination_collateral_account,
            "deposit_reserve_pubkey": deposit_reserve_pubkey,
            "obligation_account": obligation_account,
            "lending_market_account": lending_market_account,
            "obligation_owner": obligation_owner,
            "user_transfer_authority_pubkey": user_transfer_authority_pubkey,
            "sysvar_clock": sysvar_clock,
            "token_program_id": token_program_id,
            "collateral_amount": collateral_amount.to_string(),
        }),
        json!({
            "source_collateral_account": source_collateral_account,
            "destination_collateral_account": destination_collateral_account,
            "deposit_reserve_pubkey": deposit_reserve_pubkey,
            "obligation_account": obligation_account,
            "lending_market_account": lending_market_account,
            "obligation_owner": obligation_owner,
            "collateral_amount": collateral_amount.to_string(),
        }),
    ))
}

fn withdraw_obligation_collateral(accounts: Vec<String>, collateral_amount: u64) -> Result<Value> {
    let method_name = "WithdrawObligationCollateral";
    let source_collateral_account = accounts.get(0).ok_or(SolanaError::AccountNotFound(
        format!("{}.source_collateral_account", method_name,),
    ))?;
    let destination_collateral_account = accounts.get(1).ok_or(SolanaError::AccountNotFound(
        format!("{}.destination_collateral_account", method_name),
    ))?;
    let withdraw_reserve_account = accounts.get(2).ok_or(SolanaError::AccountNotFound(format!(
        "{}.deposit_reserve_pubkey",
        method_name
    )))?;
    let obligation_account = accounts.get(3).ok_or(SolanaError::AccountNotFound(format!(
        "{}.obligation_account",
        method_name
    )))?;
    let lending_market_account = accounts.get(4).ok_or(SolanaError::AccountNotFound(format!(
        "{}.lending_market_account",
        method_name
    )))?;
    let lending_market_authority_pubkey = accounts.get(5).ok_or(SolanaError::AccountNotFound(
        format!("{}.lending_market_authority_pubkey", method_name),
    ))?;
    let obligation_owner = accounts.get(6).ok_or(SolanaError::AccountNotFound(format!(
        "{}.obligation_owner",
        method_name
    )))?;
    let sysvar_clock = accounts.get(7).ok_or(SolanaError::AccountNotFound(format!(
        "{}.sysvar_clock",
        method_name
    )))?;
    let token_program_id = accounts.get(8).ok_or(SolanaError::AccountNotFound(format!(
        "{}.token_program_id",
        method_name
    )))?;

    Ok(template_instruction(
        PROGRAM_NAME,
        method_name,
        json!({
            "source_collateral_account": source_collateral_account,
            "destination_collateral_account": destination_collateral_account,
            "withdraw_reserve_account": withdraw_reserve_account,
            "obligation_account": obligation_account,
            "lending_market_account": lending_market_account,
            "lending_market_authority_pubkey": lending_market_authority_pubkey,
            "obligation_owner": obligation_owner,
            "sysvar_clock": sysvar_clock,
            "token_program_id": token_program_id,
            "collateral_amount": collateral_amount.to_string(),
        }),
        json!({
            "source_collateral_account": source_collateral_account,
            "destination_collateral_account": destination_collateral_account,
            "withdraw_reserve_account": withdraw_reserve_account,
            "obligation_account": obligation_account,
            "lending_market_account": lending_market_account,
            "obligation_owner": obligation_owner,
            "collateral_amount": collateral_amount.to_string(),
        }),
    ))
}

fn borrow_obligation_liquidity(accounts: Vec<String>, liquidity_amount: u64) -> Result<Value> {
    let method_name = "BorrowObligationLiquidity";
    let source_liquidity_account = accounts.get(0).ok_or(SolanaError::AccountNotFound(format!(
        "{}.source_liquidity_account",
        method_name,
    )))?;
    let destination_liquidity_account = accounts.get(1).ok_or(SolanaError::AccountNotFound(
        format!("{}.destination_liquidity_account", method_name),
    ))?;
    let borrow_reserve_account = accounts.get(2).ok_or(SolanaError::AccountNotFound(format!(
        "{}.borrow_reserve_account",
        method_name
    )))?;
    let borrow_reserve_liquidity_fee_receiver_pubkey =
        accounts.get(3).ok_or(SolanaError::AccountNotFound(format!(
            "{}.borrow_reserve_liquidity_fee_receiver_pubkey",
            method_name
        )))?;
    let obligation_account = accounts.get(4).ok_or(SolanaError::AccountNotFound(format!(
        "{}.obligation_account",
        method_name
    )))?;
    let lending_market_account = accounts.get(5).ok_or(SolanaError::AccountNotFound(format!(
        "{}.lending_market_account",
        method_name
    )))?;
    let lending_market_authority_pubkey = accounts.get(6).ok_or(SolanaError::AccountNotFound(
        format!("{}.lending_market_authority_pubkey", method_name),
    ))?;
    let obligation_owner = accounts.get(7).ok_or(SolanaError::AccountNotFound(format!(
        "{}.obligation_owner",
        method_name
    )))?;
    let sysvar_clock = accounts.get(9).ok_or(SolanaError::AccountNotFound(format!(
        "{}.sysvar_clock",
        method_name
    )))?;
    let token_program_id = accounts.get(8).ok_or(SolanaError::AccountNotFound(format!(
        "{}.token_program_id",
        method_name
    )))?;
    let host_fee_receiver = accounts.get(10);

    Ok(template_instruction(
        PROGRAM_NAME,
        method_name,
        json!({
            "source_liquidity_account": source_liquidity_account,
            "destination_liquidity_account": destination_liquidity_account,
            "borrow_reserve_account": borrow_reserve_account,
            "borrow_reserve_liquidity_fee_receiver_pubkey": borrow_reserve_liquidity_fee_receiver_pubkey,
            "obligation_account": obligation_account,
            "lending_market_account": lending_market_account,
            "lending_market_authority_pubkey": lending_market_authority_pubkey,
            "obligation_owner": obligation_owner,
            "sysvar_clock": sysvar_clock,
            "token_program_id": token_program_id,
            "host_fee_receiver": host_fee_receiver,
            "liquidity_amount": liquidity_amount.to_string(),
        }),
        json!({
            "source_liquidity_account": source_liquidity_account,
            "destination_liquidity_account": destination_liquidity_account,
            "borrow_reserve_account": borrow_reserve_account,
            "borrow_reserve_liquidity_fee_receiver_pubkey": borrow_reserve_liquidity_fee_receiver_pubkey,
            "obligation_account": obligation_account,
            "lending_market_account": lending_market_account,
            "obligation_owner": obligation_owner,
            "host_fee_receiver": host_fee_receiver,
            "liquidity_amount": liquidity_amount.to_string(),
        }),
    ))
}

fn repay_obligation_liquidity(accounts: Vec<String>, liquidity_amount: u64) -> Result<Value> {
    let method_name = "RepayObligationLiquidity";

    let source_liquidity_account = accounts.get(0).ok_or(SolanaError::AccountNotFound(format!(
        "{}.source_liquidity_account",
        method_name,
    )))?;
    let destination_liquidity_account = accounts.get(1).ok_or(SolanaError::AccountNotFound(
        format!("{}.destination_liquidity_account", method_name),
    ))?;
    let repay_reserve_account = accounts.get(2).ok_or(SolanaError::AccountNotFound(format!(
        "{}.repay_reserve_account",
        method_name
    )))?;
    let obligation_account = accounts.get(3).ok_or(SolanaError::AccountNotFound(format!(
        "{}.obligation_account",
        method_name
    )))?;
    let lending_market_account = accounts.get(4).ok_or(SolanaError::AccountNotFound(format!(
        "{}.lending_market_account",
        method_name
    )))?;
    let user_transfer_authority_pubkey = accounts.get(5).ok_or(SolanaError::AccountNotFound(
        format!("{}.lending_market_authority_pubkey", method_name),
    ))?;
    let sysvar_clock = accounts.get(6).ok_or(SolanaError::AccountNotFound(format!(
        "{}.sysvar_clock",
        method_name
    )))?;
    let token_program_id = accounts.get(7).ok_or(SolanaError::AccountNotFound(format!(
        "{}.token_program_id",
        method_name
    )))?;

    Ok(template_instruction(
        PROGRAM_NAME,
        method_name,
        json!({
            "source_liquidity_account": source_liquidity_account,
            "destination_liquidity_account": destination_liquidity_account,
            "repay_reserve_account": repay_reserve_account,
            "obligation_account": obligation_account,
            "lending_market_account": lending_market_account,
            "user_transfer_authority_pubkey": user_transfer_authority_pubkey,
            "sysvar_clock": sysvar_clock,
            "token_program_id": token_program_id,
            "liquidity_amount": liquidity_amount.to_string(),
        }),
        json!({
            "source_liquidity_account": source_liquidity_account,
            "destination_liquidity_account": destination_liquidity_account,
            "repay_reserve_account": repay_reserve_account,
            "obligation_account": obligation_account,
            "lending_market_account": lending_market_account,
            "liquidity_amount": liquidity_amount.to_string(),
        }),
    ))
}

fn liquidate_obligation(accounts: Vec<String>, liquidity_amount: u64) -> Result<Value> {
    let method_name = "LiquidateObligation";
    let source_liquidity_account = accounts.get(0).ok_or(SolanaError::AccountNotFound(format!(
        "{}.source_liquidity_account",
        method_name,
    )))?;
    let destination_collateral_account = accounts.get(1).ok_or(SolanaError::AccountNotFound(
        format!("{}.destination_collateral_account", method_name),
    ))?;
    let repay_reserve_account = accounts.get(2).ok_or(SolanaError::AccountNotFound(format!(
        "{}.repay_reserve_account",
        method_name
    )))?;
    let repay_reserve_liquidity_supply_pubkey =
        accounts.get(3).ok_or(SolanaError::AccountNotFound(format!(
            "{}.repay_reserve_liquidity_supply_pubkey",
            method_name
        )))?;
    let withdraw_reserve_account = accounts.get(4).ok_or(SolanaError::AccountNotFound(format!(
        "{}.withdraw_reserve_account",
        method_name
    )))?;
    let withdraw_reserve_collateral_supply_pubkey =
        accounts.get(5).ok_or(SolanaError::AccountNotFound(format!(
            "{}.withdraw_reserve_collateral_supply_pubkey",
            method_name
        )))?;
    let obligation_account = accounts.get(6).ok_or(SolanaError::AccountNotFound(format!(
        "{}.obligation_account",
        method_name
    )))?;
    let lending_market_account = accounts.get(7).ok_or(SolanaError::AccountNotFound(format!(
        "{}.lending_market_account",
        method_name
    )))?;
    let lending_market_authority_pubkey = accounts.get(8).ok_or(SolanaError::AccountNotFound(
        format!("{}.lending_market_authority_pubkey", method_name),
    ))?;
    let user_transfer_authority_pubkey = accounts.get(9).ok_or(SolanaError::AccountNotFound(
        format!("{}.user_transfer_authority_pubkey", method_name),
    ))?;
    let sysvar_clock = accounts
        .get(10)
        .ok_or(SolanaError::AccountNotFound(format!(
            "{}.sysvar_clock",
            method_name
        )))?;
    let token_program_id = accounts
        .get(11)
        .ok_or(SolanaError::AccountNotFound(format!(
            "{}.token_program_id",
            method_name
        )))?;

    Ok(template_instruction(
        PROGRAM_NAME,
        method_name,
        json!({
            "source_liquidity_account": source_liquidity_account,
            "destination_liquidity_account": destination_collateral_account,
            "repay_reserve_account": repay_reserve_account,
            "repay_reserve_liquidity_supply_pubkey": repay_reserve_liquidity_supply_pubkey,
            "withdraw_reserve_account": withdraw_reserve_account,
            "withdraw_reserve_collateral_supply_pubkey": withdraw_reserve_collateral_supply_pubkey,
            "obligation_account": obligation_account,
            "lending_market_account": lending_market_account,
            "lending_market_authority_pubkey": lending_market_authority_pubkey,
            "user_transfer_authority_pubkey": user_transfer_authority_pubkey,
            "sysvar_clock": sysvar_clock,
            "token_program_id": token_program_id,
            "liquidity_amount": liquidity_amount.to_string(),
        }),
        json!({
            "source_liquidity_account": source_liquidity_account,
            "destination_liquidity_account": destination_collateral_account,
            "repay_reserve_account": repay_reserve_account,
            "repay_reserve_liquidity_supply_pubkey": repay_reserve_liquidity_supply_pubkey,
            "withdraw_reserve_account": withdraw_reserve_account,
            "withdraw_reserve_collateral_supply_pubkey": withdraw_reserve_collateral_supply_pubkey,
            "obligation_account": obligation_account,
            "lending_market_account": lending_market_account,
            "liquidity_amount": liquidity_amount.to_string(),
        }),
    ))
}

fn flash_loan(accounts: Vec<String>, amount: u64) -> Result<Value> {
    let method_name = "FlashLoan";
    let source_liquidity_account = accounts.get(0).ok_or(SolanaError::AccountNotFound(format!(
        "{}.source_liquidity_account",
        method_name,
    )))?;
    let destination_liquidity_account = accounts.get(1).ok_or(SolanaError::AccountNotFound(
        format!("{}.destination_liquidity_account", method_name),
    ))?;
    let reserve_account = accounts.get(2).ok_or(SolanaError::AccountNotFound(format!(
        "{}.reserve_account",
        method_name
    )))?;
    let reserve_liquidity_fee_receiver = accounts.get(3).ok_or(SolanaError::AccountNotFound(
        format!("{}.reserve_liquidity_fee_receiver", method_name),
    ))?;
    let host_fee_receiver = accounts.get(4).ok_or(SolanaError::AccountNotFound(format!(
        "{}.host_fee_receiver",
        method_name
    )))?;
    let lending_market_account = accounts.get(5).ok_or(SolanaError::AccountNotFound(format!(
        "{}.lending_market_account",
        method_name
    )))?;
    let lending_market_authority_pubkey = accounts.get(6).ok_or(SolanaError::AccountNotFound(
        format!("{}.lending_market_authority_pubkey", method_name),
    ))?;
    let token_program_id = accounts.get(7).ok_or(SolanaError::AccountNotFound(format!(
        "{}.token_program_id",
        method_name
    )))?;
    let flash_loan_receiver_program_id = accounts.get(8).ok_or(SolanaError::AccountNotFound(
        format!("{}.flash_loan_receiver_program_id", method_name),
    ))?;
    let flash_loan_receiver_program_accounts = &accounts[9..];

    Ok(template_instruction(
        PROGRAM_NAME,
        method_name,
        json!({
            "source_liquidity_account": source_liquidity_account,
            "destination_liquidity_account": destination_liquidity_account,
            "reserve_account": reserve_account,
            "reserve_liquidity_fee_receiver": reserve_liquidity_fee_receiver,
            "host_fee_receiver": host_fee_receiver,
            "lending_market_account": lending_market_account,
            "lending_market_authority_pubkey": lending_market_authority_pubkey,
            "token_program_id": token_program_id,
            "flash_loan_receiver_program_id": flash_loan_receiver_program_id,
            "flash_loan_receiver_program_accounts": flash_loan_receiver_program_accounts,
            "amount": amount.to_string(),
        }),
        json!({
            "source_liquidity_account": source_liquidity_account,
            "destination_liquidity_account": destination_liquidity_account,
            "reserve_account": reserve_account,
            "reserve_liquidity_fee_receiver": reserve_liquidity_fee_receiver,
            "host_fee_receiver": host_fee_receiver,
            "lending_market_account": lending_market_account,
            "lending_market_authority_pubkey": lending_market_authority_pubkey,
            "token_program_id": token_program_id,
            "flash_loan_receiver_program_id": flash_loan_receiver_program_id,
            "flash_loan_receiver_program_accounts": flash_loan_receiver_program_accounts,
            "amount": amount.to_string(),
        }),
    ))
}

'''
'''--- blockchains/solana/src/resolvers/token_swap_v3.rs ---
use crate::error::{Result, SolanaError};
use crate::resolvers::template_instruction;
use crate::solana_lib::spl::token_swap::curve::base::CurveType;
use crate::solana_lib::spl::token_swap::instruction::{
    DepositAllTokenTypes, DepositSingleTokenTypeExactAmountIn, Initialize, Swap, SwapInstruction,
    WithdrawAllTokenTypes, WithdrawSingleTokenTypeExactAmountOut,
};
use serde_json::{json, Value};

static PROGRAM_NAME: &str = "TokenSwapV3";

pub fn resolve(instruction: SwapInstruction, accounts: Vec<String>) -> Result<Value> {
    match instruction {
        SwapInstruction::Initialize(args) => initialize(accounts, args),
        SwapInstruction::Swap(args) => swap(accounts, args),
        SwapInstruction::DepositAllTokenTypes(args) => deposit_all_token_types(accounts, args),
        SwapInstruction::WithdrawAllTokenTypes(args) => withdraw_all_token_types(accounts, args),
        SwapInstruction::DepositSingleTokenTypeExactAmountIn(args) => {
            deposit_single_token_type_exact_amount_in(accounts, args)
        }
        SwapInstruction::WithdrawSingleTokenTypeExactAmountOut(args) => {
            withdraw_single_token_type_exact_amount_out(accounts, args)
        }
    }
}

fn initialize(accounts: Vec<String>, initialize: Initialize) -> Result<Value> {
    let method_name = "Initialize";
    let token_swap = accounts.get(0).ok_or(SolanaError::AccountNotFound(format!(
        "{}.token_swap",
        method_name
    )))?;
    let swap_authority_pubkey = accounts.get(1).ok_or(SolanaError::AccountNotFound(format!(
        "{}.swap_authority_pubkey",
        method_name
    )))?;
    let token_a = accounts.get(2).ok_or(SolanaError::AccountNotFound(format!(
        "{}.token_a",
        method_name
    )))?;
    let token_b = accounts.get(3).ok_or(SolanaError::AccountNotFound(format!(
        "{}.token_b",
        method_name
    )))?;
    let pool_mint = accounts.get(4).ok_or(SolanaError::AccountNotFound(format!(
        "{}.pool_mint",
        method_name
    )))?;
    let pool_token_account_1 = accounts.get(5).ok_or(SolanaError::AccountNotFound(format!(
        "{}.pool_token_account_1",
        method_name
    )))?;
    let pool_token_account_2 = accounts.get(6).ok_or(SolanaError::AccountNotFound(format!(
        "{}.pool_token_account_2",
        method_name
    )))?;
    let token_program_id = accounts.get(7).ok_or(SolanaError::AccountNotFound(format!(
        "{}.token_program_id",
        method_name
    )))?;
    let curve_type = match initialize.swap_curve.curve_type {
        CurveType::Offset => "offset",
        CurveType::Stable => "stable",
        CurveType::ConstantPrice => "constant_price",
        CurveType::ConstantProduct => "constant_product",
    };
    let initialize = json!({
        "fees": {
            "trade_fee_numerator": initialize.fees.trade_fee_numerator,
            "trade_fee_denominator": initialize.fees.trade_fee_numerator,
            "owner_trade_fee_numerator": initialize.fees.trade_fee_numerator,
            "owner_trade_fee_denominator": initialize.fees.trade_fee_numerator,
            "owner_withdraw_fee_numerator": initialize.fees.trade_fee_numerator,
            "owner_withdraw_fee_denominator": initialize.fees.trade_fee_numerator,
            "host_fee_numerator": initialize.fees.trade_fee_numerator,
            "host_fee_denominator": initialize.fees.trade_fee_numerator,
            "trade_fee_numerator": initialize.fees.trade_fee_numerator,
        },
        "swap_curve": {
            "curve_type": curve_type
        }
    });
    Ok(template_instruction(
        PROGRAM_NAME,
        method_name,
        json!({
            "token_swap": token_swap,
            "swap_authority_pubkey": swap_authority_pubkey,
            "token_a": token_a,
            "token_b": token_b,
            "pool_mint": pool_mint,
            "pool_token_account_1": pool_token_account_1,
            "pool_token_account_2": pool_token_account_2,
            "token_program_id": token_program_id,
            "initialize": initialize,
        }),
        json!({
            "token_swap": token_swap,
            "swap_authority_pubkey": swap_authority_pubkey,
            "token_a": token_a,
            "token_b": token_b,
            "pool_mint": pool_mint,
            "pool_token_account_1": pool_token_account_1,
            "pool_token_account_2": pool_token_account_2,
            "token_program_id": token_program_id,
            "initialize": initialize,
        }),
    ))
}

fn swap(accounts: Vec<String>, swap: Swap) -> Result<Value> {
    let method_name = "Swap";
    let token_swap = accounts.get(0).ok_or(SolanaError::AccountNotFound(format!(
        "{}.token_swap",
        method_name
    )))?;
    let swap_authority_pubkey = accounts.get(1).ok_or(SolanaError::AccountNotFound(format!(
        "{}.swap_authority_pubkey",
        method_name
    )))?;
    let user_transfer_authority_pubkey = accounts.get(2).ok_or(SolanaError::AccountNotFound(
        format!("{}.user_transfer_authority_pubkey", method_name),
    ))?;
    let source_account = accounts.get(3).ok_or(SolanaError::AccountNotFound(format!(
        "{}.source_account",
        method_name
    )))?;
    let source_token = accounts.get(4).ok_or(SolanaError::AccountNotFound(format!(
        "{}.source_token",
        method_name
    )))?;
    let destination_token = accounts.get(5).ok_or(SolanaError::AccountNotFound(format!(
        "{}.destination_token",
        method_name
    )))?;
    let destination_account = accounts.get(6).ok_or(SolanaError::AccountNotFound(format!(
        "{}.destination_account",
        method_name
    )))?;
    let pool_mint = accounts.get(7).ok_or(SolanaError::AccountNotFound(format!(
        "{}.pool_mint",
        method_name
    )))?;
    let fee_account = accounts.get(8).ok_or(SolanaError::AccountNotFound(format!(
        "{}.fee_account",
        method_name
    )))?;
    let token_program_id = accounts.get(9).ok_or(SolanaError::AccountNotFound(format!(
        "{}.token_program_id",
        method_name
    )))?;
    let host_fee_account = accounts.get(10);
    let swap = json!({
        "amount_in": swap.amount_in.to_string(),
        "minimum_amount_out": swap.minimum_amount_out.to_string(),
    });
    Ok(template_instruction(
        PROGRAM_NAME,
        method_name,
        json!({
            "token_swap": token_swap,
            "swap_authority_pubkey": swap_authority_pubkey,
            "user_transfer_authority_pubkey": user_transfer_authority_pubkey,
            "source_account": source_account,
            "source_token": source_token,
            "destination_token": destination_token,
            "destination_account": destination_account,
            "pool_mint": pool_mint,
            "fee_account": fee_account,
            "token_program_id": token_program_id,
            "host_fee_account": host_fee_account,
            "swap": swap,
        }),
        json!({
            "token_swap": token_swap,
            "swap_authority_pubkey": swap_authority_pubkey,
            "user_transfer_authority_pubkey": user_transfer_authority_pubkey,
            "source_account": source_account,
            "source_token": source_token,
            "destination_token": destination_token,
            "destination_account": destination_account,
            "pool_mint": pool_mint,
            "fee_account": fee_account,
            "token_program_id": token_program_id,
            "host_fee_account": host_fee_account,
            "swap": swap,
        }),
    ))
}

fn deposit_all_token_types(accounts: Vec<String>, args: DepositAllTokenTypes) -> Result<Value> {
    let method_name = "DepositAllTokenTypes";
    let token_swap = accounts.get(0).ok_or(SolanaError::AccountNotFound(format!(
        "{}.token_swap",
        method_name
    )))?;
    let swap_authority_pubkey = accounts.get(1).ok_or(SolanaError::AccountNotFound(format!(
        "{}.swap_authority_pubkey",
        method_name
    )))?;
    let user_transfer_authority_pubkey = accounts.get(2).ok_or(SolanaError::AccountNotFound(
        format!("{}.user_transfer_authority_pubkey", method_name),
    ))?;
    let token_a_user_transfer_authority_pubkey =
        accounts.get(3).ok_or(SolanaError::AccountNotFound(format!(
            "{}.token_a_user_transfer_authority_pubkey",
            method_name
        )))?;
    let token_b_user_transfer_authority_pubkey =
        accounts.get(4).ok_or(SolanaError::AccountNotFound(format!(
            "{}.token_b_user_transfer_authority_pubkey",
            method_name
        )))?;
    let token_a_base_account = accounts.get(5).ok_or(SolanaError::AccountNotFound(format!(
        "{}.token_a_base_account",
        method_name
    )))?;
    let token_b_base_account = accounts.get(6).ok_or(SolanaError::AccountNotFound(format!(
        "{}.token_b_base_account",
        method_name
    )))?;
    let pool_mint = accounts.get(7).ok_or(SolanaError::AccountNotFound(format!(
        "{}.pool_mint",
        method_name
    )))?;
    let pool_account = accounts.get(8).ok_or(SolanaError::AccountNotFound(format!(
        "{}.pool_account",
        method_name
    )))?;
    let token_program_id = accounts.get(9).ok_or(SolanaError::AccountNotFound(format!(
        "{}.token_program_id",
        method_name
    )))?;
    let deposit_all_token_types = json!({
        "pool_token_amount": args.pool_token_amount,
        "maximum_token_a_amount": args.maximum_token_a_amount,
        "maximum_token_b_amount": args.maximum_token_b_amount,
    });
    Ok(template_instruction(
        PROGRAM_NAME,
        method_name,
        json!({
            "token_swap": token_swap,
            "swap_authority_pubkey": swap_authority_pubkey,
            "user_transfer_authority_pubkey": user_transfer_authority_pubkey,
            "token_a_user_transfer_authority_pubkey": token_a_user_transfer_authority_pubkey,
            "token_b_user_transfer_authority_pubkey": token_b_user_transfer_authority_pubkey,
            "token_a_base_account": token_a_base_account,
            "token_b_base_account": token_b_base_account,
            "pool_mint": pool_mint,
            "pool_account": pool_account,
            "token_program_id": token_program_id,
            "deposit_all_token_types": deposit_all_token_types,
        }),
        json!({
            "token_swap": token_swap,
            "swap_authority_pubkey": swap_authority_pubkey,
            "user_transfer_authority_pubkey": user_transfer_authority_pubkey,
            "token_a_user_transfer_authority_pubkey": token_a_user_transfer_authority_pubkey,
            "token_b_user_transfer_authority_pubkey": token_b_user_transfer_authority_pubkey,
            "token_a_base_account": token_a_base_account,
            "token_b_base_account": token_b_base_account,
            "pool_mint": pool_mint,
            "pool_account": pool_account,
            "token_program_id": token_program_id,
            "deposit_all_token_types": deposit_all_token_types,
        }),
    ))
}

fn withdraw_all_token_types(accounts: Vec<String>, args: WithdrawAllTokenTypes) -> Result<Value> {
    let method_name = "WithdrawAllTokenTypes";
    let token_swap = accounts.get(0).ok_or(SolanaError::AccountNotFound(format!(
        "{}.token_swap",
        method_name
    )))?;
    let swap_authority_pubkey = accounts.get(1).ok_or(SolanaError::AccountNotFound(format!(
        "{}.swap_authority_pubkey",
        method_name
    )))?;
    let user_transfer_authority_pubkey = accounts.get(2).ok_or(SolanaError::AccountNotFound(format!(
        "{}.user_transfer_authority_pubkey",
        method_name
    )))?;
    let pool_mint = accounts.get(3).ok_or(SolanaError::AccountNotFound(format!(
        "{}.pool_mint",
        method_name
    )))?;
    let source_pool_account = accounts.get(4).ok_or(SolanaError::AccountNotFound(format!(
        "{}.source_pool_account",
        method_name
    )))?;
    let token_a_swap_account = accounts.get(5).ok_or(SolanaError::AccountNotFound(format!(
        "{}.token_a_swap_account",
        method_name
    )))?;
    let token_b_swap_account = accounts.get(6).ok_or(SolanaError::AccountNotFound(format!(
        "{}.token_b_swap_account",
        method_name
    )))?;
    let token_a_user_account = accounts.get(7).ok_or(SolanaError::AccountNotFound(format!(
        "{}.token_a_user_account",
        method_name
    )))?;
    let token_b_user_account = accounts.get(8).ok_or(SolanaError::AccountNotFound(format!(
        "{}.token_b_user_account",
        method_name
    )))?;
    let fee_account = accounts.get(9).ok_or(SolanaError::AccountNotFound(format!(
        "{}.fee_account",
        method_name
    )))?;
    let token_program_id = accounts
        .get(10)
        .ok_or(SolanaError::AccountNotFound(format!(
            "{}.token_program_id",
            method_name
        )))?;
    let withdraw_all_token_types = json!({
        "pool_token_amount": args.pool_token_amount,
        "minimum_token_a_amount": args.minimum_token_a_amount,
        "minimum_token_b_amount": args.minimum_token_b_amount,
    });
    Ok(template_instruction(
        PROGRAM_NAME,
        method_name,
        json!({
            "token_swap": token_swap,
            "swap_authority_pubkey": swap_authority_pubkey,
            "user_transfer_authority_pubkey": user_transfer_authority_pubkey,
            "pool_mint": pool_mint,
            "source_pool_account": source_pool_account,
            "token_a_swap_account": token_a_swap_account,
            "token_b_swap_account": token_b_swap_account,
            "token_a_user_account": token_a_user_account,
            "token_b_user_account": token_b_user_account,
            "fee_account": fee_account,
            "token_program_id": token_program_id,
            "withdraw_all_token_types": withdraw_all_token_types,
        }),
        json!({
            "token_swap": token_swap,
            "swap_authority_pubkey": swap_authority_pubkey,
            "user_transfer_authority_pubkey": user_transfer_authority_pubkey,
            "pool_mint": pool_mint,
            "source_pool_account": source_pool_account,
            "token_a_swap_account": token_a_swap_account,
            "token_b_swap_account": token_b_swap_account,
            "token_a_user_account": token_a_user_account,
            "token_b_user_account": token_b_user_account,
            "fee_account": fee_account,
            "token_program_id": token_program_id,
            "withdraw_all_token_types": withdraw_all_token_types,
        }),
    ))
}

fn deposit_single_token_type_exact_amount_in(
    accounts: Vec<String>,
    args: DepositSingleTokenTypeExactAmountIn,
) -> Result<Value> {
    let method_name = "DepositSingleTokenTypeExactAmountIn";
    let token_swap = accounts.get(0).ok_or(SolanaError::AccountNotFound(format!(
        "{}.token_swap",
        method_name
    )))?;
    let swap_authority_pubkey = accounts.get(1).ok_or(SolanaError::AccountNotFound(format!(
        "{}.swap_authority_pubkey",
        method_name
    )))?;
    let user_transfer_authority_pubkey = accounts.get(2).ok_or(SolanaError::AccountNotFound(format!(
        "{}.user_transfer_authority_pubkey",
        method_name
    )))?;
    let token_source_account = accounts.get(3).ok_or(SolanaError::AccountNotFound(format!(
        "{}.token_source_account",
        method_name
    )))?;
    let token_a_swap_account = accounts.get(4).ok_or(SolanaError::AccountNotFound(format!(
        "{}.token_a_swap_account",
        method_name
    )))?;
    let token_b_swap_account = accounts.get(5).ok_or(SolanaError::AccountNotFound(format!(
        "{}.token_b_swap_account",
        method_name
    )))?;
    let pool_mint = accounts.get(6).ok_or(SolanaError::AccountNotFound(format!(
        "{}.pool_mint",
        method_name
    )))?;
    let pool_account = accounts.get(7).ok_or(SolanaError::AccountNotFound(format!(
        "{}.pool_account",
        method_name
    )))?;
    let token_program_id = accounts.get(8).ok_or(SolanaError::AccountNotFound(format!(
        "{}.token_program_id",
        method_name
    )))?;
    let arguments = json!({
        "source_token_amount": args.source_token_amount,
        "minimum_pool_token_amount": args.minimum_pool_token_amount,
    });
    Ok(template_instruction(
        PROGRAM_NAME,
        method_name,
        json!({
            "token_swap": token_swap,
            "swap_authority_pubkey": swap_authority_pubkey,
            "user_transfer_authority_pubkey": user_transfer_authority_pubkey,
            "token_source_account": token_source_account,
            "token_a_swap_account": token_a_swap_account,
            "token_b_swap_account": token_b_swap_account,
            "pool_mint": pool_mint,
            "pool_account": pool_account,
            "token_program_id": token_program_id,
            "arguments": arguments,
        }),
        json!({
            "token_swap": token_swap,
            "swap_authority_pubkey": swap_authority_pubkey,
            "user_transfer_authority_pubkey": user_transfer_authority_pubkey,
            "token_source_account": token_source_account,
            "token_a_swap_account": token_a_swap_account,
            "token_b_swap_account": token_b_swap_account,
            "pool_mint": pool_mint,
            "pool_account": pool_account,
            "token_program_id": token_program_id,
            "arguments": arguments,
        }),
    ))
}

fn withdraw_single_token_type_exact_amount_out(
    accounts: Vec<String>,
    args: WithdrawSingleTokenTypeExactAmountOut,
) -> Result<Value> {
    let method_name = "WithdrawSingleTokenTypeExactAmountOut";
    let token_swap = accounts.get(0).ok_or(SolanaError::AccountNotFound(format!(
        "{}.token_swap",
        method_name
    )))?;
    let swap_authority_pubkey = accounts.get(1).ok_or(SolanaError::AccountNotFound(format!(
        "{}.swap_authority_pubkey",
        method_name
    )))?;
    let user_transfer_authority_pubkey = accounts.get(2).ok_or(SolanaError::AccountNotFound(format!(
        "{}.user_transfer_authority_pubkey",
        method_name
    )))?;
    let pool_mint = accounts.get(3).ok_or(SolanaError::AccountNotFound(format!(
        "{}.token_source_account",
        method_name
    )))?;
    let source_pool_account = accounts.get(4).ok_or(SolanaError::AccountNotFound(format!(
        "{}.token_a_swap_account",
        method_name
    )))?;
    let token_a_swap_account = accounts.get(5).ok_or(SolanaError::AccountNotFound(format!(
        "{}.token_b_swap_account",
        method_name
    )))?;
    let token_b_swap_account = accounts.get(6).ok_or(SolanaError::AccountNotFound(format!(
        "{}.pool_mint",
        method_name
    )))?;
    let token_user_account = accounts.get(7).ok_or(SolanaError::AccountNotFound(format!(
        "{}.pool_account",
        method_name
    )))?;
    let fee_account = accounts.get(8).ok_or(SolanaError::AccountNotFound(format!(
        "{}.token_program_id",
        method_name
    )))?;
    let token_program_id = accounts.get(9).ok_or(SolanaError::AccountNotFound(format!(
        "{}.token_program_id",
        method_name
    )))?;
    let arguments = json!({
        "source_token_amount": args.destination_token_amount,
        "maximum_pool_token_amount": args.maximum_pool_token_amount,
    });
    Ok(template_instruction(
        PROGRAM_NAME,
        method_name,
        json!({
            "token_swap": token_swap,
            "swap_authority_pubkey": swap_authority_pubkey,
            "user_transfer_authority_pubkey": user_transfer_authority_pubkey,
            "pool_mint": pool_mint,
            "source_pool_account": source_pool_account,
            "token_a_swap_account": token_a_swap_account,
            "token_b_swap_account": token_b_swap_account,
            "token_user_account": token_user_account,
            "fee_account": fee_account,
            "token_program_id": token_program_id,
            "arguments": arguments,
        }),
        json!({
            "token_swap": token_swap,
            "swap_authority_pubkey": swap_authority_pubkey,
            "user_transfer_authority_pubkey": user_transfer_authority_pubkey,
            "pool_mint": pool_mint,
            "source_pool_account": source_pool_account,
            "token_a_swap_account": token_a_swap_account,
            "token_b_swap_account": token_b_swap_account,
            "token_user_account": token_user_account,
            "fee_account": fee_account,
            "token_program_id": token_program_id,
            "arguments": arguments,
        }),
    ))
}

'''
'''--- blockchains/solana/src/resolvers/vote.rs ---
use crate::error::{Result, SolanaError};
use crate::resolvers::template_instruction;
use crate::solana_lib::solana_program::hash::Hash;
use crate::solana_lib::solana_program::pubkey::Pubkey;
use crate::solana_lib::solana_program::vote::instruction::VoteInstruction;
use crate::solana_lib::solana_program::vote::state::{
    Vote, VoteAuthorize, VoteAuthorizeCheckedWithSeedArgs, VoteAuthorizeWithSeedArgs, VoteInit,
    VoteStateUpdate,
};
use serde_json::{json, Value};

static PROGRAM_NAME: &str = "Vote";

pub fn resolve(instruction: VoteInstruction, accounts: Vec<String>) -> Result<Value> {
    match instruction {
        VoteInstruction::InitializeAccount(vote_init) => {
            resolve_initialize_account(accounts, vote_init)
        }
        VoteInstruction::Authorize(pubkey, vote_authority) => {
            resolve_authorize(accounts, pubkey, vote_authority)
        }
        VoteInstruction::Vote(vote) => resolve_vote(accounts, vote),
        VoteInstruction::Withdraw(lamports) => resolve_withdraw(accounts, lamports),
        VoteInstruction::UpdateValidatorIdentity => resolve_update_validator_identity(accounts),
        VoteInstruction::UpdateCommission(new_commission) => {
            resolve_update_commission(accounts, new_commission)
        }
        VoteInstruction::VoteSwitch(vote, proof_hash) => {
            resolve_vote_switch(accounts, vote, proof_hash)
        }
        VoteInstruction::AuthorizeChecked(vote_authority) => {
            resolve_authorize_checked(accounts, vote_authority)
        }
        VoteInstruction::UpdateVoteState(state) => resolve_update_vote_state(accounts, state),
        VoteInstruction::UpdateVoteStateSwitch(state, proof_hash) => {
            resolve_update_vote_state_switch(accounts, state, proof_hash)
        }
        VoteInstruction::AuthorizeWithSeed(args) => resolve_authorize_with_seed(accounts, args),
        VoteInstruction::AuthorizeCheckedWithSeed(args) => {
            resolve_authorize_checked_with_seed(accounts, args)
        }
    }
}

fn resolve_initialize_account(accounts: Vec<String>, vote_init: VoteInit) -> Result<Value> {
    let method_name = "InitializeAccount";
    let account = accounts.get(0).ok_or(SolanaError::AccountNotFound(format!(
        "{}.account",
        method_name
    )))?;
    let sysvar_rent = accounts.get(1).ok_or(SolanaError::AccountNotFound(format!(
        "{}.sysvar_rent",
        method_name
    )))?;
    let sysvar_clock = accounts.get(2).ok_or(SolanaError::AccountNotFound(format!(
        "{}.sysvar_clock",
        method_name
    )))?;
    let new_validator_identity = accounts.get(3).ok_or(SolanaError::AccountNotFound(format!(
        "{}.new_validator_identity",
        method_name
    )))?;
    let node_pubkey = vote_init.node_pubkey.to_string();
    let authorized_voter = vote_init.authorized_voter.to_string();
    let authorized_withdrawer = vote_init.authorized_withdrawer.to_string();
    let commission = vote_init.commission;
    Ok(template_instruction(
        PROGRAM_NAME,
        method_name,
        json!({
            "vote_account": account,
            "sysvar_rent": sysvar_rent,
            "sysvar_clock": sysvar_clock,
            "new_validator_identity": new_validator_identity,
            "node_pubkey": node_pubkey,
            "authorized_voter": authorized_voter,
            "authorized_withdrawer": authorized_withdrawer,
            "commission": commission,
        }),
        json!({
            "vote_account": account,
            "new_validator_identity": new_validator_identity,
            "node_pubkey": node_pubkey,
            "authorized_voter": authorized_voter,
            "authorized_withdrawer": authorized_withdrawer,
            "commission": commission,
        }),
    ))
}

fn resolve_authorize(
    accounts: Vec<String>,
    pubkey: Pubkey,
    vote_authority: VoteAuthorize,
) -> Result<Value> {
    let method_name = "Authorize";
    let vote_account = accounts.get(0).ok_or(SolanaError::AccountNotFound(format!(
        "{}.vote_account",
        method_name
    )))?;
    let sysvar_clock = accounts.get(1).ok_or(SolanaError::AccountNotFound(format!(
        "{}.sysvar_clock",
        method_name
    )))?;
    let old_authority_pubkey = accounts.get(2).ok_or(SolanaError::AccountNotFound(format!(
        "{}.old_authority_pubkey",
        method_name
    )))?;
    let authority_type = match vote_authority {
        VoteAuthorize::Voter => "voter",
        VoteAuthorize::Withdrawer => "withdrawer",
    };
    Ok(template_instruction(
        PROGRAM_NAME,
        method_name,
        json!({
            "vote_account": vote_account,
            "sysvar_clock": sysvar_clock,
            "old_authority_pubkey": old_authority_pubkey,
            "new_authority_pubkey": pubkey.to_string(),
            "authority_type": authority_type,
        }),
        json!({
            "vote_account": vote_account,
            "old_authority_pubkey": old_authority_pubkey,
            "new_authority_pubkey": pubkey.to_string(),
            "authority_type": authority_type,
        }),
    ))
}

fn resolve_vote(accounts: Vec<String>, vote: Vote) -> Result<Value> {
    let method_name = "Vote";

    let vote_account = accounts.get(0).ok_or(SolanaError::AccountNotFound(format!(
        "{}.vote_account",
        method_name
    )))?;
    let sysvar_slot_hashes = accounts.get(1).ok_or(SolanaError::AccountNotFound(format!(
        "{}.sysvar_slot_hashes",
        method_name
    )))?;
    let sysvar_clock = accounts.get(2).ok_or(SolanaError::AccountNotFound(format!(
        "{}.sysvar_clock",
        method_name
    )))?;
    let vote_authority_pubkey = accounts.get(3).ok_or(SolanaError::AccountNotFound(format!(
        "{}.vote_authority_pubkey",
        method_name
    )))?;
    let vote_slots = vote
        .slots
        .iter()
        .map(|v| v.to_string())
        .collect::<Vec<String>>()
        .join(",");
    let vote_hash = vote.hash.to_string();
    let timestamp = vote.timestamp.map(|v| v.to_string());
    Ok(template_instruction(
        PROGRAM_NAME,
        method_name,
        json!({
            "vote_account": vote_account,
            "sysvar_slot_hashes": sysvar_slot_hashes,
            "sysvar_clock": sysvar_clock,
            "vote_authority_pubkey": vote_authority_pubkey,
            "slots": vote_slots,
            "hash": vote_hash,
            "timestamp": timestamp,
        }),
        json!({
            "vote_account": vote_account,
            "slots": vote_slots,
            "hash": vote_hash,
            "timestamp": timestamp,
        }),
    ))
}

fn resolve_withdraw(accounts: Vec<String>, lamports: u64) -> Result<Value> {
    let method_name = "Withdraw";

    let vote_account = accounts.get(0).ok_or(SolanaError::AccountNotFound(format!(
        "{}.vote_account",
        method_name
    )))?;
    let recipient = accounts.get(1).ok_or(SolanaError::AccountNotFound(format!(
        "{}.recipient",
        method_name
    )))?;
    let withdraw_authority_pubkey = accounts.get(2).ok_or(SolanaError::AccountNotFound(
        format!("{}.withdraw_authority_pubkey", method_name),
    ))?;
    let amount = lamports.to_string();
    Ok(template_instruction(
        PROGRAM_NAME,
        method_name,
        json!({
            "vote_account": vote_account,
            "recipient": recipient,
            "withdraw_authority_pubkey": withdraw_authority_pubkey,
            "amount": amount,
        }),
        json!({
            "vote_account": vote_account,
            "recipient": recipient,
            "amount": amount,
        }),
    ))
}

fn resolve_update_validator_identity(accounts: Vec<String>) -> Result<Value> {
    let method_name = "UpdateValidatorIdentity";

    let vote_account = accounts.get(0).ok_or(SolanaError::AccountNotFound(format!(
        "{}.vote_account",
        method_name
    )))?;
    let new_validator_identity = accounts.get(1).ok_or(SolanaError::AccountNotFound(format!(
        "{}.new_validator_identity",
        method_name
    )))?;
    let withdraw_authority_pubkey = accounts.get(2).ok_or(SolanaError::AccountNotFound(
        format!("{}.withdraw_authority_pubkey", method_name),
    ))?;
    Ok(template_instruction(
        PROGRAM_NAME,
        method_name,
        json!({
            "vote_account": vote_account,
            "new_validator_identity": new_validator_identity,
            "withdraw_authority": withdraw_authority_pubkey,
        }),
        json!({
            "vote_account": vote_account,
            "new_validator_identity": new_validator_identity,
        }),
    ))
}

fn resolve_update_commission(accounts: Vec<String>, new_commission: u8) -> Result<Value> {
    let method_name = "UpdateCommission";

    let vote_account = accounts.get(0).ok_or(SolanaError::AccountNotFound(format!(
        "{}.vote_account",
        method_name
    )))?;
    let withdraw_authority_pubkey = accounts.get(1).ok_or(SolanaError::AccountNotFound(
        format!("{}.withdraw_authority_pubkey", method_name),
    ))?;
    Ok(template_instruction(
        PROGRAM_NAME,
        method_name,
        json!({
            "vote_account": vote_account,
            "withdraw_authority_pubkey": withdraw_authority_pubkey,
            "new_commission": new_commission,
        }),
        json!({
            "vote_account": vote_account,
            "new_commission": new_commission,
        }),
    ))
}

fn resolve_vote_switch(accounts: Vec<String>, vote: Vote, proof_hash: Hash) -> Result<Value> {
    let method_name = "VoteSwitch";

    let vote_account = accounts.get(0).ok_or(SolanaError::AccountNotFound(format!(
        "{}.vote_account",
        method_name
    )))?;
    let sysvar_slot_hashes = accounts.get(1).ok_or(SolanaError::AccountNotFound(format!(
        "{}.sysvar_slot_hashes",
        method_name
    )))?;
    let sysvar_clock = accounts.get(2).ok_or(SolanaError::AccountNotFound(format!(
        "{}.sysvar_clock",
        method_name
    )))?;
    let vote_authority_pubkey = accounts.get(3).ok_or(SolanaError::AccountNotFound(format!(
        "{}.vote_authority_pubkey",
        method_name
    )))?;
    let vote_slots = vote
        .slots
        .iter()
        .map(|v| v.to_string())
        .collect::<Vec<String>>()
        .join(",");
    let vote_hash = vote.hash.to_string();
    let proof_hash = proof_hash.to_string();
    let timestamp = vote.timestamp.map(|v| v.to_string());
    Ok(template_instruction(
        PROGRAM_NAME,
        method_name,
        json!({
            "vote_account": vote_account,
            "sysvar_slot_hashes": sysvar_slot_hashes,
            "sysvar_clock": sysvar_clock,
            "vote_authority_pubkey": vote_authority_pubkey,
            "slots": vote_slots,
            "hash": vote_hash,
            "timestamp": timestamp,
            "proof_hash": proof_hash,
        }),
        json!({
            "vote_account": vote_account,
            "slots": vote_slots,
            "hash": vote_hash,
            "timestamp": timestamp,
            "proof_hash": proof_hash,
        }),
    ))
}

fn resolve_authorize_checked(
    accounts: Vec<String>,
    vote_authority: VoteAuthorize,
) -> Result<Value> {
    let method_name = "AuthorizeChecked";

    let vote_account = accounts.get(0).ok_or(SolanaError::AccountNotFound(format!(
        "{}.vote_account",
        method_name
    )))?;
    let sysvar_clock = accounts.get(1).ok_or(SolanaError::AccountNotFound(format!(
        "{}.sysvar_clock",
        method_name
    )))?;
    let old_authority_pubkey = accounts.get(2).ok_or(SolanaError::AccountNotFound(format!(
        "{}.old_authority_pubkey",
        method_name
    )))?;
    let new_authority_pubkey = accounts.get(3).ok_or(SolanaError::AccountNotFound(format!(
        "{}.new_authority_pubkey",
        method_name
    )))?;
    let authority_type = match vote_authority {
        VoteAuthorize::Voter => "voter",
        VoteAuthorize::Withdrawer => "withdrawer",
    };
    Ok(template_instruction(
        PROGRAM_NAME,
        method_name,
        json!({
            "vote_account": vote_account,
            "sysvar_clock": sysvar_clock,
            "old_authority_pubkey": old_authority_pubkey,
            "new_authority_pubkey": new_authority_pubkey,
            "authority_type": authority_type,
        }),
        json!({
            "vote_account": vote_account,
            "old_authority_pubkey": old_authority_pubkey,
            "new_authority_pubkey": new_authority_pubkey,
            "authority_type": authority_type,
        }),
    ))
}

fn resolve_update_vote_state(accounts: Vec<String>, state: VoteStateUpdate) -> Result<Value> {
    let method_name = "UpdateVoteState";

    let vote_account = accounts.get(0).ok_or(SolanaError::AccountNotFound(format!(
        "{}.vote_account",
        method_name
    )))?;
    let vote_authority_pubkey = accounts.get(1).ok_or(SolanaError::AccountNotFound(format!(
        "{}.vote_authority_pubkey",
        method_name
    )))?;

    let lockouts = state
        .lockouts
        .iter()
        .map(|v| {
            json!({
                "confirmation_count": v.confirmation_count,
                "slot": v.slot,
            })
        })
        .collect::<Vec<Value>>();
    let root = state.root.map(|v| v.to_string());
    let hash = state.hash.to_string();
    let timestamp = state.timestamp.map(|v| v.to_string());
    Ok(template_instruction(
        PROGRAM_NAME,
        method_name,
        json!({
            "vote_account": vote_account,
            "vote_authority_pubkey": vote_authority_pubkey,
            "lockouts": lockouts,
            "root": root,
            "hash": hash,
            "timestamp": timestamp,
        }),
        json!({
            "vote_account": vote_account,
            "lockouts": lockouts,
            "root": root,
            "hash": hash,
            "timestamp": timestamp,
        }),
    ))
}

fn resolve_update_vote_state_switch(
    accounts: Vec<String>,
    state: VoteStateUpdate,
    proof_hash: Hash,
) -> Result<Value> {
    let method_name = "UpdateVoteStateSwitch";

    let vote_account = accounts.get(0).ok_or(SolanaError::AccountNotFound(format!(
        "{}.vote_account",
        method_name
    )))?;
    let vote_authority_pubkey = accounts.get(1).ok_or(SolanaError::AccountNotFound(format!(
        "{}.vote_authority_pubkey",
        method_name
    )))?;
    let lockouts = state
        .lockouts
        .iter()
        .map(|v| {
            json!({
                "confirmation_count": v.confirmation_count,
                "slot": v.slot,
            })
        })
        .collect::<Vec<Value>>();
    let root = state.root.map(|v| v.to_string());
    let hash = state.hash.to_string();
    let timestamp = state.timestamp.map(|v| v.to_string());
    let proof_hash = proof_hash.to_string();
    Ok(template_instruction(
        PROGRAM_NAME,
        method_name,
        json!({
            "vote_account": vote_account,
            "vote_authority_pubkey": vote_authority_pubkey,
            "lockouts": lockouts,
            "root": root,
            "hash": hash,
            "timestamp": timestamp,
            "proof_hash": proof_hash
        }),
        json!({
            "vote_account": vote_account,
            "lockouts": lockouts,
            "root": root,
            "hash": hash,
            "timestamp": timestamp,
            "proof_hash": proof_hash
        }),
    ))
}

fn resolve_authorize_with_seed(
    accounts: Vec<String>,
    args: VoteAuthorizeWithSeedArgs,
) -> Result<Value> {
    let method_name = "AuthorizeWithSeed";

    let vote_account = accounts.get(0).ok_or(SolanaError::AccountNotFound(format!(
        "{}.vote_account",
        method_name
    )))?;
    let sysvar_clock = accounts.get(1).ok_or(SolanaError::AccountNotFound(format!(
        "{}.sysvar_clock",
        method_name
    )))?;
    let old_base_pubkey = accounts.get(2).ok_or(SolanaError::AccountNotFound(format!(
        "{}.old_base_pubkey",
        method_name
    )))?;

    let authorization_type = match args.authorization_type {
        VoteAuthorize::Voter => "voter",
        VoteAuthorize::Withdrawer => "withdrawer",
    };
    let current_authority_derived_key_owner = args.current_authority_derived_key_owner.to_string();
    let current_authority_derived_key_seed = args.current_authority_derived_key_seed;
    let new_authority_pubkey = args.new_authority.to_string();

    Ok(template_instruction(
        PROGRAM_NAME,
        method_name,
        json!({
            "vote_account": vote_account,
            "sysvar_clock": sysvar_clock,
            "old_base_pubkey": old_base_pubkey,
            "authorization_type": authorization_type,
            "current_authority_derived_key_owner": current_authority_derived_key_owner,
            "current_authority_derived_key_seed": current_authority_derived_key_seed,
            "new_authority_pubkey": new_authority_pubkey,
        }),
        json!({
            "vote_account": vote_account,
            "old_base_pubkey": old_base_pubkey,
            "authorization_type": authorization_type,
            "current_authority_derived_key_seed": current_authority_derived_key_seed,
            "new_authority_pubkey": new_authority_pubkey,
        }),
    ))
}

fn resolve_authorize_checked_with_seed(
    accounts: Vec<String>,
    args: VoteAuthorizeCheckedWithSeedArgs,
) -> Result<Value> {
    let method_name = "AuthorizeCheckedWithSeed";

    let vote_account = accounts.get(0).ok_or(SolanaError::AccountNotFound(format!(
        "{}.vote_account",
        method_name
    )))?;
    let sysvar_clock = accounts.get(1).ok_or(SolanaError::AccountNotFound(format!(
        "{}.sysvar_clock",
        method_name
    )))?;
    let old_base_pubkey = accounts.get(2).ok_or(SolanaError::AccountNotFound(format!(
        "{}.old_base_pubkey",
        method_name
    )))?;
    let new_authority_pubkey = accounts.get(3).ok_or(SolanaError::AccountNotFound(format!(
        "{}.new_authority_pubkey",
        method_name
    )))?;

    let authorization_type = match args.authorization_type {
        VoteAuthorize::Voter => "voter",
        VoteAuthorize::Withdrawer => "withdrawer",
    };
    let current_authority_derived_key_owner = args.current_authority_derived_key_owner.to_string();
    let current_authority_derived_key_seed = args.current_authority_derived_key_seed;

    Ok(template_instruction(
        PROGRAM_NAME,
        method_name,
        json!({
            "vote_account": vote_account,
            "sysvar_clock": sysvar_clock,
            "old_base_pubkey": old_base_pubkey,
            "new_authority_pubkey": new_authority_pubkey,
            "authorization_type": authorization_type,
            "current_authority_derived_key_owner": current_authority_derived_key_owner,
            "current_authority_derived_key_seed": current_authority_derived_key_seed,
        }),
        json!({
            "vote_account": vote_account,
            "old_base_pubkey": old_base_pubkey,
            "new_authority_pubkey": new_authority_pubkey,
            "authorization_type": authorization_type,
            "current_authority_derived_key_seed": current_authority_derived_key_seed,
        }),
    ))
}

'''
'''--- blockchains/solana/src/solana_lib/mod.rs ---
/*
    This module is copied from solana official libraries,
    for we meet dependencies conflict when integration solana with rcc_android
*/

pub mod solana_program;
pub mod spl;

'''
'''--- blockchains/solana/src/solana_lib/solana_program/mod.rs ---
pub mod program_option;
pub mod program_pack;
pub mod stake;
pub mod system_instruction;
pub mod vote;

pub mod clock {
    pub type Slot = u64;

    /// Uniquely distinguishes every version of a slot, even if the
    /// slot number is the same, i.e. duplicate slots
    pub type BankId = u64;

    /// Epoch is a unit of time a given leader schedule is honored,
    ///  some number of Slots.
    pub type Epoch = u64;

    /// SlotIndex is an index to the slots of a epoch
    pub type SlotIndex = u64;

    /// SlotCount is the number of slots in a epoch
    pub type SlotCount = u64;

    /// UnixTimestamp is an approximate measure of real-world time,
    /// expressed as Unix time (ie. seconds since the Unix epoch)
    pub type UnixTimestamp = i64;
}

pub mod program_utils {
    use crate::solana_lib::solana_program::instruction::InstructionError;
    use bincode::Options;

    /// Deserialize with a limit based the maximum amount of data a program can expect to get.
    /// This function should be used in place of direct deserialization to help prevent OOM errors
    pub fn limited_deserialize<T>(
        instruction_data: &[u8],
        limit: u64,
    ) -> Result<T, InstructionError>
    where
        T: serde::de::DeserializeOwned,
    {
        bincode::options()
            .with_limit(limit)
            .with_fixint_encoding() // As per https://github.com/servo/bincode/issues/333, these two options are needed
            .allow_trailing_bytes() // to retain the behavior of bincode::deserialize with the new `options()` method
            .deserialize_from(instruction_data)
            .map_err(|_| InstructionError::InvalidInstructionData)
    }
}

pub mod instruction {
    use thiserror::Error;
    /// Reasons the runtime might have rejected an instruction.
    ///
    /// Instructions errors are included in the bank hashes and therefore are
    /// included as part of the transaction results when determining consensus.
    /// Because of this, members of this enum must not be removed, but new ones can
    /// be added.  Also, it is crucial that meta-information if any that comes along
    /// with an error be consistent across software versions.  For example, it is
    /// dangerous to include error strings from 3rd party crates because they could
    /// change at any time and changes to them are difficult to detect.
    #[derive(Error, Debug)]
    pub enum InstructionError {
        /// Deprecated! Use CustomError instead!
        /// The program instruction returned an error
        #[error("generic instruction error")]
        GenericError,

        /// The arguments provided to a program were invalid
        #[error("invalid program argument")]
        InvalidArgument,

        /// An instruction's data contents were invalid
        #[error("invalid instruction data")]
        InvalidInstructionData,

        /// An account's data contents was invalid
        #[error("invalid account data for instruction")]
        InvalidAccountData,

        /// An account's data was too small
        #[error("account data too small for instruction")]
        AccountDataTooSmall,

        /// An account's balance was too small to complete the instruction
        #[error("insufficient funds for instruction")]
        InsufficientFunds,

        /// The account did not have the expected program id
        #[error("incorrect program id for instruction")]
        IncorrectProgramId,

        /// A signature was required but not found
        #[error("missing required signature for instruction")]
        MissingRequiredSignature,

        /// An initialize instruction was sent to an account that has already been initialized.
        #[error("instruction requires an uninitialized account")]
        AccountAlreadyInitialized,

        /// An attempt to operate on an account that hasn't been initialized.
        #[error("instruction requires an initialized account")]
        UninitializedAccount,

        /// Program's instruction lamport balance does not equal the balance after the instruction
        #[error("sum of account balances before and after instruction do not match")]
        UnbalancedInstruction,

        /// Program illegally modified an account's program id
        #[error("instruction illegally modified the program id of an account")]
        ModifiedProgramId,

        /// Program spent the lamports of an account that doesn't belong to it
        #[error("instruction spent from the balance of an account it does not own")]
        ExternalAccountLamportSpend,

        /// Program modified the data of an account that doesn't belong to it
        #[error("instruction modified data of an account it does not own")]
        ExternalAccountDataModified,

        /// Read-only account's lamports modified
        #[error("instruction changed the balance of a read-only account")]
        ReadonlyLamportChange,

        /// Read-only account's data was modified
        #[error("instruction modified data of a read-only account")]
        ReadonlyDataModified,

        /// An account was referenced more than once in a single instruction
        // Deprecated, instructions can now contain duplicate accounts
        #[error("instruction contains duplicate accounts")]
        DuplicateAccountIndex,

        /// Executable bit on account changed, but shouldn't have
        #[error("instruction changed executable bit of an account")]
        ExecutableModified,

        /// Rent_epoch account changed, but shouldn't have
        #[error("instruction modified rent epoch of an account")]
        RentEpochModified,

        /// The instruction expected additional account keys
        #[error("insufficient account keys for instruction")]
        NotEnoughAccountKeys,

        /// Program other than the account's owner changed the size of the account data
        #[error("program other than the account's owner changed the size of the account data")]
        AccountDataSizeChanged,

        /// The instruction expected an executable account
        #[error("instruction expected an executable account")]
        AccountNotExecutable,

        /// Failed to borrow a reference to account data, already borrowed
        #[error("instruction tries to borrow reference for an account which is already borrowed")]
        AccountBorrowFailed,

        /// Account data has an outstanding reference after a program's execution
        #[error("instruction left account with an outstanding borrowed reference")]
        AccountBorrowOutstanding,

        /// The same account was multiply passed to an on-chain program's entrypoint, but the program
        /// modified them differently.  A program can only modify one instance of the account because
        /// the runtime cannot determine which changes to pick or how to merge them if both are modified
        #[error("instruction modifications of multiply-passed account differ")]
        DuplicateAccountOutOfSync,

        /// Allows on-chain programs to implement program-specific error types and see them returned
        /// by the Solana runtime. A program-specific error may be any type that is represented as
        /// or serialized to a u32 integer.
        #[error("custom program error: {0:#x}")]
        Custom(u32),

        /// The return value from the program was invalid.  Valid errors are either a defined builtin
        /// error value or a user-defined error in the lower 32 bits.
        #[error("program returned invalid error code")]
        InvalidError,

        /// Executable account's data was modified
        #[error("instruction changed executable accounts data")]
        ExecutableDataModified,

        /// Executable account's lamports modified
        #[error("instruction changed the balance of a executable account")]
        ExecutableLamportChange,

        /// Executable accounts must be rent exempt
        #[error("executable accounts must be rent exempt")]
        ExecutableAccountNotRentExempt,

        /// Unsupported program id
        #[error("Unsupported program id")]
        UnsupportedProgramId,

        /// Cross-program invocation call depth too deep
        #[error("Cross-program invocation call depth too deep")]
        CallDepth,

        /// An account required by the instruction is missing
        #[error("An account required by the instruction is missing")]
        MissingAccount,

        /// Cross-program invocation reentrancy not allowed for this instruction
        #[error("Cross-program invocation reentrancy not allowed for this instruction")]
        ReentrancyNotAllowed,

        /// Length of the seed is too long for address generation
        #[error("Length of the seed is too long for address generation")]
        MaxSeedLengthExceeded,

        /// Provided seeds do not result in a valid address
        #[error("Provided seeds do not result in a valid address")]
        InvalidSeeds,

        /// Failed to reallocate account data of this length
        #[error("Failed to reallocate account data")]
        InvalidRealloc,

        /// Computational budget exceeded
        #[error("Computational budget exceeded")]
        ComputationalBudgetExceeded,

        /// Cross-program invocation with unauthorized signer or writable account
        #[error("Cross-program invocation with unauthorized signer or writable account")]
        PrivilegeEscalation,

        /// Failed to create program execution environment
        #[error("Failed to create program execution environment")]
        ProgramEnvironmentSetupFailure,

        /// Program failed to complete
        #[error("Program failed to complete")]
        ProgramFailedToComplete,

        /// Program failed to compile
        #[error("Program failed to compile")]
        ProgramFailedToCompile,

        /// Account is immutable
        #[error("Account is immutable")]
        Immutable,

        /// Incorrect authority provided
        #[error("Incorrect authority provided")]
        IncorrectAuthority,

        /// Failed to serialize or deserialize account data
        ///
        /// Warning: This error should never be emitted by the runtime.
        ///
        /// This error includes strings from the underlying 3rd party Borsh crate
        /// which can be dangerous because the error strings could change across
        /// Borsh versions. Only programs can use this error because they are
        /// consistent across Solana software versions.
        ///
        #[error("Failed to serialize or deserialize account data: {0}")]
        BorshIoError(String),

        /// An account does not have enough lamports to be rent-exempt
        #[error("An account does not have enough lamports to be rent-exempt")]
        AccountNotRentExempt,

        /// Invalid account owner
        #[error("Invalid account owner")]
        InvalidAccountOwner,

        /// Program arithmetic overflowed
        #[error("Program arithmetic overflowed")]
        ArithmeticOverflow,

        /// Unsupported sysvar
        #[error("Unsupported sysvar")]
        UnsupportedSysvar,

        /// Illegal account owner
        #[error("Provided owner is not allowed")]
        IllegalOwner,

        /// Account data allocation exceeded the maximum accounts data size limit
        #[error("Account data allocation exceeded the maximum accounts data size limit")]
        MaxAccountsDataSizeExceeded,

        /// Max accounts exceeded
        #[error("Max accounts exceeded")]
        MaxAccountsExceeded,
        // Note: For any new error added here an equivalent ProgramError and its
        // conversions must also be added
    }
}

pub mod pubkey {
    use serde_derive::{Deserialize, Serialize};
    use std::fmt;

    pub const PUBKEY_BYTES: usize = 32;

    #[derive(
        Clone, Copy, Default, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize,
    )]
    pub struct Pubkey(pub(crate) [u8; 32]);

    impl fmt::Debug for Pubkey {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            write!(f, "{}", bs58::encode(self.0).into_string())
        }
    }

    impl fmt::Display for Pubkey {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            write!(f, "{}", bs58::encode(self.0).into_string())
        }
    }

    impl Pubkey {
        pub fn new(pubkey_vec: &[u8]) -> Self {
            Self(
                <[u8; 32]>::try_from(<&[u8]>::clone(&pubkey_vec))
                    .expect("Slice must be the same length as a Pubkey"),
            )
        }
    }
}

pub mod hash {
    use serde_derive::{Deserialize, Serialize};
    use std::fmt;

    pub const HASH_BYTES: usize = 32;

    #[derive(
        Serialize, Deserialize, Clone, Copy, Default, Eq, PartialEq, Ord, PartialOrd, Hash,
    )]
    pub struct Hash(pub(crate) [u8; HASH_BYTES]);

    impl fmt::Debug for Hash {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            write!(f, "{}", bs58::encode(self.0).into_string())
        }
    }

    impl fmt::Display for Hash {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            write!(f, "{}", bs58::encode(self.0).into_string())
        }
    }
}

pub mod program_error {
    use serde_derive::{Deserialize, Serialize};
    use thiserror::Error;
    /// Reasons the program may fail
    #[derive(Clone, Debug, Deserialize, Eq, Error, PartialEq, Serialize)]
    pub enum ProgramError {
        /// Allows on-chain programs to implement program-specific error types and see them returned
        /// by the Solana runtime. A program-specific error may be any type that is represented as
        /// or serialized to a u32 integer.
        #[error("Custom program error: {0:#x}")]
        Custom(u32),
        #[error("The arguments provided to a program instruction where invalid")]
        InvalidArgument,
        #[error("An instruction's data contents was invalid")]
        InvalidInstructionData,
        #[error("An account's data contents was invalid")]
        InvalidAccountData,
        #[error("An account's data was too small")]
        AccountDataTooSmall,
        #[error("An account's balance was too small to complete the instruction")]
        InsufficientFunds,
        #[error("The account did not have the expected program id")]
        IncorrectProgramId,
        #[error("A signature was required but not found")]
        MissingRequiredSignature,
        #[error(
            "An initialize instruction was sent to an account that has already been initialized"
        )]
        AccountAlreadyInitialized,
        #[error("An attempt to operate on an account that hasn't been initialized")]
        UninitializedAccount,
        #[error("The instruction expected additional account keys")]
        NotEnoughAccountKeys,
        #[error("Failed to borrow a reference to account data, already borrowed")]
        AccountBorrowFailed,
        #[error("Length of the seed is too long for address generation")]
        MaxSeedLengthExceeded,
        #[error("Provided seeds do not result in a valid address")]
        InvalidSeeds,
        #[error("IO Error: {0}")]
        BorshIoError(String),
        #[error("An account does not have enough lamports to be rent-exempt")]
        AccountNotRentExempt,
        #[error("Unsupported sysvar")]
        UnsupportedSysvar,
        #[error("Provided owner is not allowed")]
        IllegalOwner,
        #[error("Account data allocation exceeded the maximum accounts data size limit")]
        MaxAccountsDataSizeExceeded,
        #[error("Account data reallocation was invalid")]
        InvalidRealloc,
    }
}

'''
'''--- blockchains/solana/src/solana_lib/solana_program/program_option.rs ---
//! A C representation of Rust's `Option`, used across the FFI
//! boundary for Solana program interfaces.
//!
//! This implementation mostly matches `std::option` except iterators since the iteration
//! trait requires returning `std::option::Option`

use std::{
    convert, mem,
    ops::{Deref, DerefMut},
};

/// A C representation of Rust's `std::option::Option`
#[repr(C)]
#[derive(Copy, PartialEq, PartialOrd, Eq, Ord, Debug, Hash)]
pub enum COption<T> {
    /// No value
    None,
    /// Some value `T`
    Some(T),
}

/////////////////////////////////////////////////////////////////////////////
// Type implementation
/////////////////////////////////////////////////////////////////////////////

impl<T> COption<T> {
    /////////////////////////////////////////////////////////////////////////
    // Querying the contained values
    /////////////////////////////////////////////////////////////////////////

    /// Returns `true` if the option is a [`COption::Some`] value.
    ///
    /// # Examples
    ///
    /// ```ignore
    /// let x: COption<u32> = COption::Some(2);
    /// assert_eq!(x.is_some(), true);
    ///
    /// let x: COption<u32> = COption::None;
    /// assert_eq!(x.is_some(), false);
    /// ```
    ///
    /// [`COption::Some`]: #variant.COption::Some
    #[must_use = "if you intended to assert that this has a value, consider `.unwrap()` instead"]
    #[inline]
    pub fn is_some(&self) -> bool {
        match *self {
            COption::Some(_) => true,
            COption::None => false,
        }
    }

    /// Returns `true` if the option is a [`COption::None`] value.
    ///
    /// # Examples
    ///
    /// ```ignore
    /// let x: COption<u32> = COption::Some(2);
    /// assert_eq!(x.is_none(), false);
    ///
    /// let x: COption<u32> = COption::None;
    /// assert_eq!(x.is_none(), true);
    /// ```
    ///
    /// [`COption::None`]: #variant.COption::None
    #[must_use = "if you intended to assert that this doesn't have a value, consider \
                  `.and_then(|| panic!(\"`COption` had a value when expected `COption::None`\"))` instead"]
    #[inline]
    pub fn is_none(&self) -> bool {
        !self.is_some()
    }

    /// Returns `true` if the option is a [`COption::Some`] value containing the given value.
    ///
    /// # Examples
    ///
    /// ```ignore
    /// #![feature(option_result_contains)]
    ///
    /// let x: COption<u32> = COption::Some(2);
    /// assert_eq!(x.contains(&2), true);
    ///
    /// let x: COption<u32> = COption::Some(3);
    /// assert_eq!(x.contains(&2), false);
    ///
    /// let x: COption<u32> = COption::None;
    /// assert_eq!(x.contains(&2), false);
    /// ```
    #[must_use]
    #[inline]
    pub fn contains<U>(&self, x: &U) -> bool
    where
        U: PartialEq<T>,
    {
        match self {
            COption::Some(y) => x == y,
            COption::None => false,
        }
    }

    /////////////////////////////////////////////////////////////////////////
    // Adapter for working with references
    /////////////////////////////////////////////////////////////////////////

    /// Converts from `&COption<T>` to `COption<&T>`.
    ///
    /// # Examples
    ///
    /// Converts an `COption<`[`String`]`>` into an `COption<`[`usize`]`>`, preserving the original.
    /// The [`map`] method takes the `self` argument by value, consuming the original,
    /// so this technique uses `as_ref` to first take an `COption` to a reference
    /// to the value inside the original.
    ///
    /// [`map`]: enum.COption.html#method.map
    /// [`String`]: ../../std/string/struct.String.html
    /// [`usize`]: ../../std/primitive.usize.html
    ///
    /// ```ignore
    /// let text: COption<String> = COption::Some("Hello, world!".to_string());
    /// // First, cast `COption<String>` to `COption<&String>` with `as_ref`,
    /// // then consume *that* with `map`, leaving `text` on the stack.
    /// let text_length: COption<usize> = text.as_ref().map(|s| s.len());
    /// println!("still can print text: {:?}", text);
    /// ```
    #[inline]
    pub fn as_ref(&self) -> COption<&T> {
        match *self {
            COption::Some(ref x) => COption::Some(x),
            COption::None => COption::None,
        }
    }

    /// Converts from `&mut COption<T>` to `COption<&mut T>`.
    ///
    /// # Examples
    ///
    /// ```ignore
    /// let mut x = COption::Some(2);
    /// match x.as_mut() {
    ///     COption::Some(v) => *v = 42,
    ///     COption::None => {},
    /// }
    /// assert_eq!(x, COption::Some(42));
    /// ```
    #[inline]
    pub fn as_mut(&mut self) -> COption<&mut T> {
        match *self {
            COption::Some(ref mut x) => COption::Some(x),
            COption::None => COption::None,
        }
    }

    /////////////////////////////////////////////////////////////////////////
    // Getting to contained values
    /////////////////////////////////////////////////////////////////////////

    /// Unwraps an option, yielding the content of a [`COption::Some`].
    ///
    /// # Panics
    ///
    /// Panics if the value is a [`COption::None`] with a custom panic message provided by
    /// `msg`.
    ///
    /// [`COption::Some`]: #variant.COption::Some
    /// [`COption::None`]: #variant.COption::None
    ///
    /// # Examples
    ///
    /// ```ignore
    /// let x = COption::Some("value");
    /// assert_eq!(x.expect("the world is ending"), "value");
    /// ```
    ///
    /// ```ignore{.should_panic}
    /// let x: COption<&str> = COption::None;
    /// x.expect("the world is ending"); // panics with `the world is ending`
    /// ```
    #[inline]
    pub fn expect(self, msg: &str) -> T {
        match self {
            COption::Some(val) => val,
            COption::None => expect_failed(msg),
        }
    }

    /// Moves the value `v` out of the `COption<T>` if it is [`COption::Some(v)`].
    ///
    /// In general, because this function may panic, its use is discouraged.
    /// Instead, prefer to use pattern matching and handle the [`COption::None`]
    /// case explicitly.
    ///
    /// # Panics
    ///
    /// Panics if the self value equals [`COption::None`].
    ///
    /// [`COption::Some(v)`]: #variant.COption::Some
    /// [`COption::None`]: #variant.COption::None
    ///
    /// # Examples
    ///
    /// ```ignore
    /// let x = COption::Some("air");
    /// assert_eq!(x.unwrap(), "air");
    /// ```
    ///
    /// ```ignore{.should_panic}
    /// let x: COption<&str> = COption::None;
    /// assert_eq!(x.unwrap(), "air"); // fails
    /// ```
    #[inline]
    pub fn unwrap(self) -> T {
        match self {
            COption::Some(val) => val,
            COption::None => panic!("called `COption::unwrap()` on a `COption::None` value"),
        }
    }

    /// Returns the contained value or a default.
    ///
    /// Arguments passed to `unwrap_or` are eagerly evaluated; if you are passing
    /// the result of a function call, it is recommended to use [`unwrap_or_else`],
    /// which is lazily evaluated.
    ///
    /// [`unwrap_or_else`]: #method.unwrap_or_else
    ///
    /// # Examples
    ///
    /// ```ignore
    /// assert_eq!(COption::Some("car").unwrap_or("bike"), "car");
    /// assert_eq!(COption::None.unwrap_or("bike"), "bike");
    /// ```
    #[inline]
    pub fn unwrap_or(self, def: T) -> T {
        match self {
            COption::Some(x) => x,
            COption::None => def,
        }
    }

    /// Returns the contained value or computes it from a closure.
    ///
    /// # Examples
    ///
    /// ```ignore
    /// let k = 10;
    /// assert_eq!(COption::Some(4).unwrap_or_else(|| 2 * k), 4);
    /// assert_eq!(COption::None.unwrap_or_else(|| 2 * k), 20);
    /// ```
    #[inline]
    pub fn unwrap_or_else<F: FnOnce() -> T>(self, f: F) -> T {
        match self {
            COption::Some(x) => x,
            COption::None => f(),
        }
    }

    /////////////////////////////////////////////////////////////////////////
    // Transforming contained values
    /////////////////////////////////////////////////////////////////////////

    /// Maps an `COption<T>` to `COption<U>` by applying a function to a contained value.
    ///
    /// # Examples
    ///
    /// Converts an `COption<`[`String`]`>` into an `COption<`[`usize`]`>`, consuming the original:
    ///
    /// [`String`]: ../../std/string/struct.String.html
    /// [`usize`]: ../../std/primitive.usize.html
    ///
    /// ```ignore
    /// let maybe_some_string = COption::Some(String::from("Hello, World!"));
    /// // `COption::map` takes self *by value*, consuming `maybe_some_string`
    /// let maybe_some_len = maybe_some_string.map(|s| s.len());
    ///
    /// assert_eq!(maybe_some_len, COption::Some(13));
    /// ```
    #[inline]
    pub fn map<U, F: FnOnce(T) -> U>(self, f: F) -> COption<U> {
        match self {
            COption::Some(x) => COption::Some(f(x)),
            COption::None => COption::None,
        }
    }

    /// Applies a function to the contained value (if any),
    /// or returns the provided default (if not).
    ///
    /// # Examples
    ///
    /// ```ignore
    /// let x = COption::Some("foo");
    /// assert_eq!(x.map_or(42, |v| v.len()), 3);
    ///
    /// let x: COption<&str> = COption::None;
    /// assert_eq!(x.map_or(42, |v| v.len()), 42);
    /// ```
    #[inline]
    pub fn map_or<U, F: FnOnce(T) -> U>(self, default: U, f: F) -> U {
        match self {
            COption::Some(t) => f(t),
            COption::None => default,
        }
    }

    /// Applies a function to the contained value (if any),
    /// or computes a default (if not).
    ///
    /// # Examples
    ///
    /// ```ignore
    /// let k = 21;
    ///
    /// let x = COption::Some("foo");
    /// assert_eq!(x.map_or_else(|| 2 * k, |v| v.len()), 3);
    ///
    /// let x: COption<&str> = COption::None;
    /// assert_eq!(x.map_or_else(|| 2 * k, |v| v.len()), 42);
    /// ```
    #[inline]
    pub fn map_or_else<U, D: FnOnce() -> U, F: FnOnce(T) -> U>(self, default: D, f: F) -> U {
        match self {
            COption::Some(t) => f(t),
            COption::None => default(),
        }
    }

    /// Transforms the `COption<T>` into a [`Result<T, E>`], mapping [`COption::Some(v)`] to
    /// [`Ok(v)`] and [`COption::None`] to [`Err(err)`].
    ///
    /// Arguments passed to `ok_or` are eagerly evaluated; if you are passing the
    /// result of a function call, it is recommended to use [`ok_or_else`], which is
    /// lazily evaluated.
    ///
    /// [`Result<T, E>`]: ../../std/result/enum.Result.html
    /// [`Ok(v)`]: ../../std/result/enum.Result.html#variant.Ok
    /// [`Err(err)`]: ../../std/result/enum.Result.html#variant.Err
    /// [`COption::None`]: #variant.COption::None
    /// [`COption::Some(v)`]: #variant.COption::Some
    /// [`ok_or_else`]: #method.ok_or_else
    ///
    /// # Examples
    ///
    /// ```ignore
    /// let x = COption::Some("foo");
    /// assert_eq!(x.ok_or(0), Ok("foo"));
    ///
    /// let x: COption<&str> = COption::None;
    /// assert_eq!(x.ok_or(0), Err(0));
    /// ```
    #[inline]
    pub fn ok_or<E>(self, err: E) -> Result<T, E> {
        match self {
            COption::Some(v) => Ok(v),
            COption::None => Err(err),
        }
    }

    /// Transforms the `COption<T>` into a [`Result<T, E>`], mapping [`COption::Some(v)`] to
    /// [`Ok(v)`] and [`COption::None`] to [`Err(err())`].
    ///
    /// [`Result<T, E>`]: ../../std/result/enum.Result.html
    /// [`Ok(v)`]: ../../std/result/enum.Result.html#variant.Ok
    /// [`Err(err())`]: ../../std/result/enum.Result.html#variant.Err
    /// [`COption::None`]: #variant.COption::None
    /// [`COption::Some(v)`]: #variant.COption::Some
    ///
    /// # Examples
    ///
    /// ```ignore
    /// let x = COption::Some("foo");
    /// assert_eq!(x.ok_or_else(|| 0), Ok("foo"));
    ///
    /// let x: COption<&str> = COption::None;
    /// assert_eq!(x.ok_or_else(|| 0), Err(0));
    /// ```
    #[inline]
    pub fn ok_or_else<E, F: FnOnce() -> E>(self, err: F) -> Result<T, E> {
        match self {
            COption::Some(v) => Ok(v),
            COption::None => Err(err()),
        }
    }

    /////////////////////////////////////////////////////////////////////////
    // Boolean operations on the values, eager and lazy
    /////////////////////////////////////////////////////////////////////////

    /// Returns [`COption::None`] if the option is [`COption::None`], otherwise returns `optb`.
    ///
    /// [`COption::None`]: #variant.COption::None
    ///
    /// # Examples
    ///
    /// ```ignore
    /// let x = COption::Some(2);
    /// let y: COption<&str> = COption::None;
    /// assert_eq!(x.and(y), COption::None);
    ///
    /// let x: COption<u32> = COption::None;
    /// let y = COption::Some("foo");
    /// assert_eq!(x.and(y), COption::None);
    ///
    /// let x = COption::Some(2);
    /// let y = COption::Some("foo");
    /// assert_eq!(x.and(y), COption::Some("foo"));
    ///
    /// let x: COption<u32> = COption::None;
    /// let y: COption<&str> = COption::None;
    /// assert_eq!(x.and(y), COption::None);
    /// ```
    #[inline]
    pub fn and<U>(self, optb: COption<U>) -> COption<U> {
        match self {
            COption::Some(_) => optb,
            COption::None => COption::None,
        }
    }

    /// Returns [`COption::None`] if the option is [`COption::None`], otherwise calls `f` with the
    /// wrapped value and returns the result.
    ///
    /// COption::Some languages call this operation flatmap.
    ///
    /// [`COption::None`]: #variant.COption::None
    ///
    /// # Examples
    ///
    /// ```ignore
    /// fn sq(x: u32) -> COption<u32> { COption::Some(x * x) }
    /// fn nope(_: u32) -> COption<u32> { COption::None }
    ///
    /// assert_eq!(COption::Some(2).and_then(sq).and_then(sq), COption::Some(16));
    /// assert_eq!(COption::Some(2).and_then(sq).and_then(nope), COption::None);
    /// assert_eq!(COption::Some(2).and_then(nope).and_then(sq), COption::None);
    /// assert_eq!(COption::None.and_then(sq).and_then(sq), COption::None);
    /// ```
    #[inline]
    pub fn and_then<U, F: FnOnce(T) -> COption<U>>(self, f: F) -> COption<U> {
        match self {
            COption::Some(x) => f(x),
            COption::None => COption::None,
        }
    }

    /// Returns [`COption::None`] if the option is [`COption::None`], otherwise calls `predicate`
    /// with the wrapped value and returns:
    ///
    /// - [`COption::Some(t)`] if `predicate` returns `true` (where `t` is the wrapped
    ///   value), and
    /// - [`COption::None`] if `predicate` returns `false`.
    ///
    /// This function works similar to [`Iterator::filter()`]. You can imagine
    /// the `COption<T>` being an iterator over one or zero elements. `filter()`
    /// lets you decide which elements to keep.
    ///
    /// # Examples
    ///
    /// ```ignore
    /// fn is_even(n: &i32) -> bool {
    ///     n % 2 == 0
    /// }
    ///
    /// assert_eq!(COption::None.filter(is_even), COption::None);
    /// assert_eq!(COption::Some(3).filter(is_even), COption::None);
    /// assert_eq!(COption::Some(4).filter(is_even), COption::Some(4));
    /// ```
    ///
    /// [`COption::None`]: #variant.COption::None
    /// [`COption::Some(t)`]: #variant.COption::Some
    /// [`Iterator::filter()`]: ../../std/iter/trait.Iterator.html#method.filter
    #[inline]
    pub fn filter<P: FnOnce(&T) -> bool>(self, predicate: P) -> Self {
        if let COption::Some(x) = self {
            if predicate(&x) {
                return COption::Some(x);
            }
        }
        COption::None
    }

    /// Returns the option if it contains a value, otherwise returns `optb`.
    ///
    /// Arguments passed to `or` are eagerly evaluated; if you are passing the
    /// result of a function call, it is recommended to use [`or_else`], which is
    /// lazily evaluated.
    ///
    /// [`or_else`]: #method.or_else
    ///
    /// # Examples
    ///
    /// ```ignore
    /// let x = COption::Some(2);
    /// let y = COption::None;
    /// assert_eq!(x.or(y), COption::Some(2));
    ///
    /// let x = COption::None;
    /// let y = COption::Some(100);
    /// assert_eq!(x.or(y), COption::Some(100));
    ///
    /// let x = COption::Some(2);
    /// let y = COption::Some(100);
    /// assert_eq!(x.or(y), COption::Some(2));
    ///
    /// let x: COption<u32> = COption::None;
    /// let y = COption::None;
    /// assert_eq!(x.or(y), COption::None);
    /// ```
    #[inline]
    pub fn or(self, optb: COption<T>) -> COption<T> {
        match self {
            COption::Some(_) => self,
            COption::None => optb,
        }
    }

    /// Returns the option if it contains a value, otherwise calls `f` and
    /// returns the result.
    ///
    /// # Examples
    ///
    /// ```ignore
    /// fn nobody() -> COption<&'static str> { COption::None }
    /// fn vikings() -> COption<&'static str> { COption::Some("vikings") }
    ///
    /// assert_eq!(COption::Some("barbarians").or_else(vikings), COption::Some("barbarians"));
    /// assert_eq!(COption::None.or_else(vikings), COption::Some("vikings"));
    /// assert_eq!(COption::None.or_else(nobody), COption::None);
    /// ```
    #[inline]
    pub fn or_else<F: FnOnce() -> COption<T>>(self, f: F) -> COption<T> {
        match self {
            COption::Some(_) => self,
            COption::None => f(),
        }
    }

    /// Returns [`COption::Some`] if exactly one of `self`, `optb` is [`COption::Some`], otherwise returns [`COption::None`].
    ///
    /// [`COption::Some`]: #variant.COption::Some
    /// [`COption::None`]: #variant.COption::None
    ///
    /// # Examples
    ///
    /// ```ignore
    /// let x = COption::Some(2);
    /// let y: COption<u32> = COption::None;
    /// assert_eq!(x.xor(y), COption::Some(2));
    ///
    /// let x: COption<u32> = COption::None;
    /// let y = COption::Some(2);
    /// assert_eq!(x.xor(y), COption::Some(2));
    ///
    /// let x = COption::Some(2);
    /// let y = COption::Some(2);
    /// assert_eq!(x.xor(y), COption::None);
    ///
    /// let x: COption<u32> = COption::None;
    /// let y: COption<u32> = COption::None;
    /// assert_eq!(x.xor(y), COption::None);
    /// ```
    #[inline]
    pub fn xor(self, optb: COption<T>) -> COption<T> {
        match (self, optb) {
            (COption::Some(a), COption::None) => COption::Some(a),
            (COption::None, COption::Some(b)) => COption::Some(b),
            _ => COption::None,
        }
    }

    /////////////////////////////////////////////////////////////////////////
    // Entry-like operations to insert if COption::None and return a reference
    /////////////////////////////////////////////////////////////////////////

    /// Inserts `v` into the option if it is [`COption::None`], then
    /// returns a mutable reference to the contained value.
    ///
    /// [`COption::None`]: #variant.COption::None
    ///
    /// # Examples
    ///
    /// ```ignore
    /// let mut x = COption::None;
    ///
    /// {
    ///     let y: &mut u32 = x.get_or_insert(5);
    ///     assert_eq!(y, &5);
    ///
    ///     *y = 7;
    /// }
    ///
    /// assert_eq!(x, COption::Some(7));
    /// ```
    #[inline]
    pub fn get_or_insert(&mut self, v: T) -> &mut T {
        self.get_or_insert_with(|| v)
    }

    /// Inserts a value computed from `f` into the option if it is [`COption::None`], then
    /// returns a mutable reference to the contained value.
    ///
    /// [`COption::None`]: #variant.COption::None
    ///
    /// # Examples
    ///
    /// ```ignore
    /// let mut x = COption::None;
    ///
    /// {
    ///     let y: &mut u32 = x.get_or_insert_with(|| 5);
    ///     assert_eq!(y, &5);
    ///
    ///     *y = 7;
    /// }
    ///
    /// assert_eq!(x, COption::Some(7));
    /// ```
    #[inline]
    pub fn get_or_insert_with<F: FnOnce() -> T>(&mut self, f: F) -> &mut T {
        if let COption::None = *self {
            *self = COption::Some(f())
        }

        match *self {
            COption::Some(ref mut v) => v,
            COption::None => unreachable!(),
        }
    }

    /////////////////////////////////////////////////////////////////////////
    // Misc
    /////////////////////////////////////////////////////////////////////////

    /// Replaces the actual value in the option by the value given in parameter,
    /// returning the old value if present,
    /// leaving a [`COption::Some`] in its place without deinitializing either one.
    ///
    /// [`COption::Some`]: #variant.COption::Some
    ///
    /// # Examples
    ///
    /// ```ignore
    /// let mut x = COption::Some(2);
    /// let old = x.replace(5);
    /// assert_eq!(x, COption::Some(5));
    /// assert_eq!(old, COption::Some(2));
    ///
    /// let mut x = COption::None;
    /// let old = x.replace(3);
    /// assert_eq!(x, COption::Some(3));
    /// assert_eq!(old, COption::None);
    /// ```
    #[inline]
    pub fn replace(&mut self, value: T) -> COption<T> {
        mem::replace(self, COption::Some(value))
    }
}

impl<T: Copy> COption<&T> {
    /// Maps an `COption<&T>` to an `COption<T>` by copying the contents of the
    /// option.
    ///
    /// # Examples
    ///
    /// ```ignore
    /// let x = 12;
    /// let opt_x = COption::Some(&x);
    /// assert_eq!(opt_x, COption::Some(&12));
    /// let copied = opt_x.copied();
    /// assert_eq!(copied, COption::Some(12));
    /// ```
    pub fn copied(self) -> COption<T> {
        self.map(|&t| t)
    }
}

impl<T: Copy> COption<&mut T> {
    /// Maps an `COption<&mut T>` to an `COption<T>` by copying the contents of the
    /// option.
    ///
    /// # Examples
    ///
    /// ```ignore
    /// let mut x = 12;
    /// let opt_x = COption::Some(&mut x);
    /// assert_eq!(opt_x, COption::Some(&mut 12));
    /// let copied = opt_x.copied();
    /// assert_eq!(copied, COption::Some(12));
    /// ```
    pub fn copied(self) -> COption<T> {
        self.map(|&mut t| t)
    }
}

impl<T: Clone> COption<&T> {
    /// Maps an `COption<&T>` to an `COption<T>` by cloning the contents of the
    /// option.
    ///
    /// # Examples
    ///
    /// ```ignore
    /// let x = 12;
    /// let opt_x = COption::Some(&x);
    /// assert_eq!(opt_x, COption::Some(&12));
    /// let cloned = opt_x.cloned();
    /// assert_eq!(cloned, COption::Some(12));
    /// ```
    pub fn cloned(self) -> COption<T> {
        self.map(|t| t.clone())
    }
}

impl<T: Clone> COption<&mut T> {
    /// Maps an `COption<&mut T>` to an `COption<T>` by cloning the contents of the
    /// option.
    ///
    /// # Examples
    ///
    /// ```ignore
    /// let mut x = 12;
    /// let opt_x = COption::Some(&mut x);
    /// assert_eq!(opt_x, COption::Some(&mut 12));
    /// let cloned = opt_x.cloned();
    /// assert_eq!(cloned, COption::Some(12));
    /// ```
    pub fn cloned(self) -> COption<T> {
        self.map(|t| t.clone())
    }
}

impl<T: Default> COption<T> {
    /// Returns the contained value or a default
    ///
    /// Consumes the `self` argument then, if [`COption::Some`], returns the contained
    /// value, otherwise if [`COption::None`], returns the [default value] for that
    /// type.
    ///
    /// # Examples
    ///
    /// Converts a string to an integer, turning poorly-formed strings
    /// into 0 (the default value for integers). [`parse`] converts
    /// a string to any other type that implements [`FromStr`], returning
    /// [`COption::None`] on error.
    ///
    /// ```ignore
    /// let good_year_from_input = "1909";
    /// let bad_year_from_input = "190blarg";
    /// let good_year = good_year_from_input.parse().ok().unwrap_or_default();
    /// let bad_year = bad_year_from_input.parse().ok().unwrap_or_default();
    ///
    /// assert_eq!(1909, good_year);
    /// assert_eq!(0, bad_year);
    /// ```
    ///
    /// [`COption::Some`]: #variant.COption::Some
    /// [`COption::None`]: #variant.COption::None
    /// [default value]: ../default/trait.Default.html#tymethod.default
    /// [`parse`]: ../../std/primitive.str.html#method.parse
    /// [`FromStr`]: ../../std/str/trait.FromStr.html
    #[inline]
    pub fn unwrap_or_default(self) -> T {
        match self {
            COption::Some(x) => x,
            COption::None => T::default(),
        }
    }
}

impl<T: Deref> COption<T> {
    /// Converts from `COption<T>` (or `&COption<T>`) to `COption<&T::Target>`.
    ///
    /// Leaves the original COption in-place, creating a new one with a reference
    /// to the original one, additionally coercing the contents via [`Deref`].
    ///
    /// [`Deref`]: ../../std/ops/trait.Deref.html
    ///
    /// # Examples
    ///
    /// ```ignore
    /// #![feature(inner_deref)]
    ///
    /// let x: COption<String> = COption::Some("hey".to_owned());
    /// assert_eq!(x.as_deref(), COption::Some("hey"));
    ///
    /// let x: COption<String> = COption::None;
    /// assert_eq!(x.as_deref(), COption::None);
    /// ```
    pub fn as_deref(&self) -> COption<&T::Target> {
        self.as_ref().map(|t| t.deref())
    }
}

impl<T: DerefMut> COption<T> {
    /// Converts from `COption<T>` (or `&mut COption<T>`) to `COption<&mut T::Target>`.
    ///
    /// Leaves the original `COption` in-place, creating a new one containing a mutable reference to
    /// the inner type's `Deref::Target` type.
    ///
    /// # Examples
    ///
    /// ```ignore
    /// #![feature(inner_deref)]
    ///
    /// let mut x: COption<String> = COption::Some("hey".to_owned());
    /// assert_eq!(x.as_deref_mut().map(|x| {
    ///     x.make_ascii_uppercase();
    ///     x
    /// }), COption::Some("HEY".to_owned().as_mut_str()));
    /// ```
    pub fn as_deref_mut(&mut self) -> COption<&mut T::Target> {
        self.as_mut().map(|t| t.deref_mut())
    }
}

impl<T, E> COption<Result<T, E>> {
    /// Transposes an `COption` of a [`Result`] into a [`Result`] of an `COption`.
    ///
    /// [`COption::None`] will be mapped to [`Ok`]`(`[`COption::None`]`)`.
    /// [`COption::Some`]`(`[`Ok`]`(_))` and [`COption::Some`]`(`[`Err`]`(_))` will be mapped to
    /// [`Ok`]`(`[`COption::Some`]`(_))` and [`Err`]`(_)`.
    ///
    /// [`COption::None`]: #variant.COption::None
    /// [`Ok`]: ../../std/result/enum.Result.html#variant.Ok
    /// [`COption::Some`]: #variant.COption::Some
    /// [`Err`]: ../../std/result/enum.Result.html#variant.Err
    ///
    /// # Examples
    ///
    /// ```ignore
    /// #[derive(Debug, Eq, PartialEq)]
    /// struct COption::SomeErr;
    ///
    /// let x: Result<COption<i32>, COption::SomeErr> = Ok(COption::Some(5));
    /// let y: COption<Result<i32, COption::SomeErr>> = COption::Some(Ok(5));
    /// assert_eq!(x, y.transpose());
    /// ```
    #[inline]
    pub fn transpose(self) -> Result<COption<T>, E> {
        match self {
            COption::Some(Ok(x)) => Ok(COption::Some(x)),
            COption::Some(Err(e)) => Err(e),
            COption::None => Ok(COption::None),
        }
    }
}

// This is a separate function to reduce the code size of .expect() itself.
#[inline(never)]
#[cold]
fn expect_failed(msg: &str) -> ! {
    panic!("{}", msg)
}

// // This is a separate function to reduce the code size of .expect_none() itself.
// #[inline(never)]
// #[cold]
// fn expect_none_failed(msg: &str, value: &dyn fmt::Debug) -> ! {
//     panic!("{}: {:?}", msg, value)
// }

/////////////////////////////////////////////////////////////////////////////
// Trait implementations
/////////////////////////////////////////////////////////////////////////////

impl<T: Clone> Clone for COption<T> {
    #[inline]
    fn clone(&self) -> Self {
        match self {
            COption::Some(x) => COption::Some(x.clone()),
            COption::None => COption::None,
        }
    }

    #[inline]
    fn clone_from(&mut self, source: &Self) {
        match (self, source) {
            (COption::Some(to), COption::Some(from)) => to.clone_from(from),
            (to, from) => *to = from.clone(),
        }
    }
}

impl<T> Default for COption<T> {
    /// Returns [`COption::None`][COption::None].
    ///
    /// # Examples
    ///
    /// ```ignore
    /// let opt: COption<u32> = COption::default();
    /// assert!(opt.is_none());
    /// ```
    #[inline]
    fn default() -> COption<T> {
        COption::None
    }
}

impl<T> From<T> for COption<T> {
    fn from(val: T) -> COption<T> {
        COption::Some(val)
    }
}

impl<'a, T> From<&'a COption<T>> for COption<&'a T> {
    fn from(o: &'a COption<T>) -> COption<&'a T> {
        o.as_ref()
    }
}

impl<'a, T> From<&'a mut COption<T>> for COption<&'a mut T> {
    fn from(o: &'a mut COption<T>) -> COption<&'a mut T> {
        o.as_mut()
    }
}

impl<T> COption<COption<T>> {
    /// Converts from `COption<COption<T>>` to `COption<T>`
    ///
    /// # Examples
    /// Basic usage:
    /// ```ignore
    /// #![feature(option_flattening)]
    /// let x: COption<COption<u32>> = COption::Some(COption::Some(6));
    /// assert_eq!(COption::Some(6), x.flatten());
    ///
    /// let x: COption<COption<u32>> = COption::Some(COption::None);
    /// assert_eq!(COption::None, x.flatten());
    ///
    /// let x: COption<COption<u32>> = COption::None;
    /// assert_eq!(COption::None, x.flatten());
    /// ```
    /// Flattening once only removes one level of nesting:
    /// ```ignore
    /// #![feature(option_flattening)]
    /// let x: COption<COption<COption<u32>>> = COption::Some(COption::Some(COption::Some(6)));
    /// assert_eq!(COption::Some(COption::Some(6)), x.flatten());
    /// assert_eq!(COption::Some(6), x.flatten().flatten());
    /// ```
    #[inline]
    pub fn flatten(self) -> COption<T> {
        self.and_then(convert::identity)
    }
}

impl<T> From<Option<T>> for COption<T> {
    fn from(option: Option<T>) -> Self {
        match option {
            Some(value) => COption::Some(value),
            None => COption::None,
        }
    }
}

'''
'''--- blockchains/solana/src/solana_lib/solana_program/program_pack.rs ---
//! The [`Pack`] serialization trait.

use crate::solana_lib::solana_program::program_error::ProgramError;

/// Check if a program account state is initialized
pub trait IsInitialized {
    /// Is initialized
    fn is_initialized(&self) -> bool;
}

/// Implementors must have a known size
pub trait Sealed: Sized {}

/// Safely and efficiently (de)serialize account state
pub trait Pack: Sealed {
    /// The length, in bytes, of the packed representation
    const LEN: usize;
    #[doc(hidden)]
    fn pack_into_slice(&self, dst: &mut [u8]);
    #[doc(hidden)]
    fn unpack_from_slice(src: &[u8]) -> Result<Self, ProgramError>;

    /// Get the packed length
    fn get_packed_len() -> usize {
        Self::LEN
    }

    /// Unpack from slice and check if initialized
    fn unpack(input: &[u8]) -> Result<Self, ProgramError>
    where
        Self: IsInitialized,
    {
        let value = Self::unpack_unchecked(input)?;
        if value.is_initialized() {
            Ok(value)
        } else {
            Err(ProgramError::UninitializedAccount)
        }
    }

    /// Unpack from slice without checking if initialized
    fn unpack_unchecked(input: &[u8]) -> Result<Self, ProgramError> {
        if input.len() != Self::LEN {
            return Err(ProgramError::InvalidAccountData);
        }
        Self::unpack_from_slice(input)
    }

    /// Pack into slice
    fn pack(src: Self, dst: &mut [u8]) -> Result<(), ProgramError> {
        if dst.len() != Self::LEN {
            return Err(ProgramError::InvalidAccountData);
        }
        src.pack_into_slice(dst);
        Ok(())
    }
}

'''
'''--- blockchains/solana/src/solana_lib/solana_program/stake.rs ---
pub mod state {
    use crate::solana_lib::solana_program::clock::{Epoch, UnixTimestamp};
    use crate::solana_lib::solana_program::pubkey::Pubkey;
    use serde_derive::{Deserialize, Serialize};

    #[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone)]
    pub struct Authorized {
        pub staker: Pubkey,
        pub withdrawer: Pubkey,
    }

    #[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone)]
    pub enum StakeAuthorize {
        Staker,
        Withdrawer,
    }

    #[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone)]
    pub struct Lockup {
        /// UnixTimestamp at which this stake will allow withdrawal, unless the
        ///   transaction is signed by the custodian
        pub unix_timestamp: UnixTimestamp,
        /// epoch height at which this stake will allow withdrawal, unless the
        ///   transaction is signed by the custodian
        pub epoch: Epoch,
        /// custodian signature on a transaction exempts the operation from
        ///  lockup constraints
        pub custodian: Pubkey,
    }
}

pub mod instruction {
    use crate::solana_lib::solana_program::clock::{Epoch, UnixTimestamp};
    use crate::solana_lib::solana_program::pubkey::Pubkey;
    use crate::solana_lib::solana_program::stake::state::{Authorized, Lockup, StakeAuthorize};
    use serde_derive::{Deserialize, Serialize};

    #[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone)]
    pub struct LockupArgs {
        pub unix_timestamp: Option<UnixTimestamp>,
        pub epoch: Option<Epoch>,
        pub custodian: Option<Pubkey>,
    }

    #[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone)]
    pub struct AuthorizeWithSeedArgs {
        pub new_authorized_pubkey: Pubkey,
        pub stake_authorize: StakeAuthorize,
        pub authority_seed: String,
        pub authority_owner: Pubkey,
    }

    #[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone)]
    pub struct AuthorizeCheckedWithSeedArgs {
        pub stake_authorize: StakeAuthorize,
        pub authority_seed: String,
        pub authority_owner: Pubkey,
    }

    #[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone)]
    pub struct LockupCheckedArgs {
        pub unix_timestamp: Option<UnixTimestamp>,
        pub epoch: Option<Epoch>,
    }

    #[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]
    pub enum StakeInstruction {
        /// Initialize a stake with lockup and authorization information
        ///
        /// # Account references
        ///   0. `[WRITE]` Uninitialized stake account
        ///   1. `[]` Rent sysvar
        ///
        /// Authorized carries pubkeys that must sign staker transactions
        ///   and withdrawer transactions.
        /// Lockup carries information about withdrawal restrictions
        Initialize(Authorized, Lockup),

        /// Authorize a key to manage stake or withdrawal
        ///
        /// # Account references
        ///   0. `[WRITE]` Stake account to be updated
        ///   1. `[]` Clock sysvar
        ///   2. `[SIGNER]` The stake or withdraw authority
        ///   3. Optional: `[SIGNER]` Lockup authority, if updating StakeAuthorize::Withdrawer before
        ///      lockup expiration
        Authorize(Pubkey, StakeAuthorize),

        /// Delegate a stake to a particular vote account
        ///
        /// # Account references
        ///   0. `[WRITE]` Initialized stake account to be delegated
        ///   1. `[]` Vote account to which this stake will be delegated
        ///   2. `[]` Clock sysvar
        ///   3. `[]` Stake history sysvar that carries stake warmup/cooldown history
        ///   4. `[]` Address of config account that carries stake config
        ///   5. `[SIGNER]` Stake authority
        ///
        /// The entire balance of the staking account is staked.  DelegateStake
        ///   can be called multiple times, but re-delegation is delayed
        ///   by one epoch
        DelegateStake,

        /// Split u64 tokens and stake off a stake account into another stake account.
        ///
        /// # Account references
        ///   0. `[WRITE]` Stake account to be split; must be in the Initialized or Stake state
        ///   1. `[WRITE]` Uninitialized stake account that will take the split-off amount
        ///   2. `[SIGNER]` Stake authority
        Split(u64),

        /// Withdraw unstaked lamports from the stake account
        ///
        /// # Account references
        ///   0. `[WRITE]` Stake account from which to withdraw
        ///   1. `[WRITE]` Recipient account
        ///   2. `[]` Clock sysvar
        ///   3. `[]` Stake history sysvar that carries stake warmup/cooldown history
        ///   4. `[SIGNER]` Withdraw authority
        ///   5. Optional: `[SIGNER]` Lockup authority, if before lockup expiration
        ///
        /// The u64 is the portion of the stake account balance to be withdrawn,
        ///    must be `<= StakeAccount.lamports - staked_lamports`.
        Withdraw(u64),

        /// Deactivates the stake in the account
        ///
        /// # Account references
        ///   0. `[WRITE]` Delegated stake account
        ///   1. `[]` Clock sysvar
        ///   2. `[SIGNER]` Stake authority
        Deactivate,

        /// Set stake lockup
        ///
        /// If a lockup is not active, the withdraw authority may set a new lockup
        /// If a lockup is active, the lockup custodian may update the lockup parameters
        ///
        /// # Account references
        ///   0. `[WRITE]` Initialized stake account
        ///   1. `[SIGNER]` Lockup authority or withdraw authority
        SetLockup(LockupArgs),

        /// Merge two stake accounts.
        ///
        /// Both accounts must have identical lockup and authority keys. A merge
        /// is possible between two stakes in the following states with no additional
        /// conditions:
        ///
        /// * two deactivated stakes
        /// * an inactive stake into an activating stake during its activation epoch
        ///
        /// For the following cases, the voter pubkey and vote credits observed must match:
        ///
        /// * two activated stakes
        /// * two activating accounts that share an activation epoch, during the activation epoch
        ///
        /// All other combinations of stake states will fail to merge, including all
        /// "transient" states, where a stake is activating or deactivating with a
        /// non-zero effective stake.
        ///
        /// # Account references
        ///   0. `[WRITE]` Destination stake account for the merge
        ///   1. `[WRITE]` Source stake account for to merge.  This account will be drained
        ///   2. `[]` Clock sysvar
        ///   3. `[]` Stake history sysvar that carries stake warmup/cooldown history
        ///   4. `[SIGNER]` Stake authority
        Merge,

        /// Authorize a key to manage stake or withdrawal with a derived key
        ///
        /// # Account references
        ///   0. `[WRITE]` Stake account to be updated
        ///   1. `[SIGNER]` Base key of stake or withdraw authority
        ///   2. `[]` Clock sysvar
        ///   3. Optional: `[SIGNER]` Lockup authority, if updating StakeAuthorize::Withdrawer before
        ///      lockup expiration
        AuthorizeWithSeed(AuthorizeWithSeedArgs),

        /// Initialize a stake with authorization information
        ///
        /// This instruction is similar to `Initialize` except that the withdraw authority
        /// must be a signer, and no lockup is applied to the account.
        ///
        /// # Account references
        ///   0. `[WRITE]` Uninitialized stake account
        ///   1. `[]` Rent sysvar
        ///   2. `[]` The stake authority
        ///   3. `[SIGNER]` The withdraw authority
        ///
        InitializeChecked,

        /// Authorize a key to manage stake or withdrawal
        ///
        /// This instruction behaves like `Authorize` with the additional requirement that the new
        /// stake or withdraw authority must also be a signer.
        ///
        /// # Account references
        ///   0. `[WRITE]` Stake account to be updated
        ///   1. `[]` Clock sysvar
        ///   2. `[SIGNER]` The stake or withdraw authority
        ///   3. `[SIGNER]` The new stake or withdraw authority
        ///   4. Optional: `[SIGNER]` Lockup authority, if updating StakeAuthorize::Withdrawer before
        ///      lockup expiration
        AuthorizeChecked(StakeAuthorize),

        /// Authorize a key to manage stake or withdrawal with a derived key
        ///
        /// This instruction behaves like `AuthorizeWithSeed` with the additional requirement that
        /// the new stake or withdraw authority must also be a signer.
        ///
        /// # Account references
        ///   0. `[WRITE]` Stake account to be updated
        ///   1. `[SIGNER]` Base key of stake or withdraw authority
        ///   2. `[]` Clock sysvar
        ///   3. `[SIGNER]` The new stake or withdraw authority
        ///   4. Optional: `[SIGNER]` Lockup authority, if updating StakeAuthorize::Withdrawer before
        ///      lockup expiration
        AuthorizeCheckedWithSeed(AuthorizeCheckedWithSeedArgs),

        /// Set stake lockup
        ///
        /// This instruction behaves like `SetLockup` with the additional requirement that
        /// the new lockup authority also be a signer.
        ///
        /// If a lockup is not active, the withdraw authority may set a new lockup
        /// If a lockup is active, the lockup custodian may update the lockup parameters
        ///
        /// # Account references
        ///   0. `[WRITE]` Initialized stake account
        ///   1. `[SIGNER]` Lockup authority or withdraw authority
        ///   2. Optional: `[SIGNER]` New lockup authority
        SetLockupChecked(LockupCheckedArgs),

        /// Get the minimum stake delegation, in lamports
        ///
        /// # Account references
        ///   None
        ///
        /// Returns the minimum delegation as a little-endian encoded u64 value.
        /// Programs can use the [`get_minimum_delegation()`] helper function to invoke and
        /// retrieve the return value for this instruction.
        ///
        /// [`get_minimum_delegation()`]: super::tools::get_minimum_delegation
        GetMinimumDelegation,

        /// Deactivate stake delegated to a vote account that has been delinquent for at least
        /// `MINIMUM_DELINQUENT_EPOCHS_FOR_DEACTIVATION` epochs.
        ///
        /// No signer is required for this instruction as it is a common good to deactivate abandoned
        /// stake.
        ///
        /// # Account references
        ///   0. `[WRITE]` Delegated stake account
        ///   1. `[]` Delinquent vote account for the delegated stake account
        ///   2. `[]` Reference vote account that has voted at least once in the last
        ///      `MINIMUM_DELINQUENT_EPOCHS_FOR_DEACTIVATION` epochs
        DeactivateDelinquent,
    }
}

'''
'''--- blockchains/solana/src/solana_lib/solana_program/system_instruction.rs ---
use crate::solana_lib::solana_program::pubkey::Pubkey;
use serde_derive::{Deserialize, Serialize};

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]
pub enum SystemInstruction {
    /// Create a new account
    ///
    /// # Account references
    ///   0. `[WRITE, SIGNER]` Funding account
    ///   1. `[WRITE, SIGNER]` New account
    CreateAccount {
        /// Number of lamports to transfer to the new account
        lamports: u64,

        /// Number of bytes of memory to allocate
        space: u64,

        /// Address of program that will own the new account
        owner: Pubkey,
    },

    /// Assign account to a program
    ///
    /// # Account references
    ///   0. `[WRITE, SIGNER]` Assigned account public key
    Assign {
        /// Owner program account
        owner: Pubkey,
    },

    /// Transfer lamports
    ///
    /// # Account references
    ///   0. `[WRITE, SIGNER]` Funding account
    ///   1. `[WRITE]` Recipient account
    Transfer { lamports: u64 },

    /// Create a new account at an address derived from a base pubkey and a seed
    ///
    /// # Account references
    ///   0. `[WRITE, SIGNER]` Funding account
    ///   1. `[WRITE]` Created account
    ///   2. `[SIGNER]` (optional) Base account; the account matching the base Pubkey below must be
    ///                          provided as a signer, but may be the same as the funding account
    ///                          and provided as account 0
    CreateAccountWithSeed {
        /// Base public key
        base: Pubkey,

        /// String of ASCII chars, no longer than `Pubkey::MAX_SEED_LEN`
        seed: String,

        /// Number of lamports to transfer to the new account
        lamports: u64,

        /// Number of bytes of memory to allocate
        space: u64,

        /// Owner program account address
        owner: Pubkey,
    },

    /// Consumes a stored nonce, replacing it with a successor
    ///
    /// # Account references
    ///   0. `[WRITE]` Nonce account
    ///   1. `[]` RecentBlockhashes sysvar
    ///   2. `[SIGNER]` Nonce authority
    AdvanceNonceAccount,

    /// Withdraw funds from a nonce account
    ///
    /// # Account references
    ///   0. `[WRITE]` Nonce account
    ///   1. `[WRITE]` Recipient account
    ///   2. `[]` RecentBlockhashes sysvar
    ///   3. `[]` Rent sysvar
    ///   4. `[SIGNER]` Nonce authority
    ///
    /// The `u64` parameter is the lamports to withdraw, which must leave the
    /// account balance above the rent exempt reserve or at zero.
    WithdrawNonceAccount(u64),

    /// Drive state of Uninitialized nonce account to Initialized, setting the nonce value
    ///
    /// # Account references
    ///   0. `[WRITE]` Nonce account
    ///   1. `[]` RecentBlockhashes sysvar
    ///   2. `[]` Rent sysvar
    ///
    /// The `Pubkey` parameter specifies the entity authorized to execute nonce
    /// instruction on the account
    ///
    /// No signatures are required to execute this instruction, enabling derived
    /// nonce account addresses
    InitializeNonceAccount(Pubkey),

    /// Change the entity authorized to execute nonce instructions on the account
    ///
    /// # Account references
    ///   0. `[WRITE]` Nonce account
    ///   1. `[SIGNER]` Nonce authority
    ///
    /// The `Pubkey` parameter identifies the entity to authorize
    AuthorizeNonceAccount(Pubkey),

    /// Allocate space in a (possibly new) account without funding
    ///
    /// # Account references
    ///   0. `[WRITE, SIGNER]` New account
    Allocate {
        /// Number of bytes of memory to allocate
        space: u64,
    },

    /// Allocate space for and assign an account at an address
    ///    derived from a base public key and a seed
    ///
    /// # Account references
    ///   0. `[WRITE]` Allocated account
    ///   1. `[SIGNER]` Base account
    AllocateWithSeed {
        /// Base public key
        base: Pubkey,

        /// String of ASCII chars, no longer than `pubkey::MAX_SEED_LEN`
        seed: String,

        /// Number of bytes of memory to allocate
        space: u64,

        /// Owner program account
        owner: Pubkey,
    },

    /// Assign account to a program based on a seed
    ///
    /// # Account references
    ///   0. `[WRITE]` Assigned account
    ///   1. `[SIGNER]` Base account
    AssignWithSeed {
        /// Base public key
        base: Pubkey,

        /// String of ASCII chars, no longer than `pubkey::MAX_SEED_LEN`
        seed: String,

        /// Owner program account
        owner: Pubkey,
    },

    /// Transfer lamports from a derived address
    ///
    /// # Account references
    ///   0. `[WRITE]` Funding account
    ///   1. `[SIGNER]` Base for funding account
    ///   2. `[WRITE]` Recipient account
    TransferWithSeed {
        /// Amount to transfer
        lamports: u64,

        /// Seed to use to derive the funding account address
        from_seed: String,

        /// Owner to use to derive the funding account address
        from_owner: Pubkey,
    },

    /// One-time idempotent upgrade of legacy nonce versions in order to bump
    /// them out of chain blockhash domain.
    ///
    /// # Account references
    ///   0. `[WRITE]` Nonce account
    UpgradeNonceAccount,
}

'''
'''--- blockchains/solana/src/solana_lib/solana_program/vote.rs ---
pub mod state {
    use crate::solana_lib::solana_program::clock::{Slot, UnixTimestamp};
    use crate::solana_lib::solana_program::hash::Hash;
    use crate::solana_lib::solana_program::pubkey::Pubkey;
    use serde_derive::{Deserialize, Serialize};
    use std::collections::VecDeque;

    #[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone)]
    pub struct VoteInit {
        pub node_pubkey: Pubkey,
        pub authorized_voter: Pubkey,
        pub authorized_withdrawer: Pubkey,
        pub commission: u8,
    }

    #[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone)]
    pub enum VoteAuthorize {
        Voter,
        Withdrawer,
    }

    #[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone)]
    pub struct VoteAuthorizeCheckedWithSeedArgs {
        pub authorization_type: VoteAuthorize,
        pub current_authority_derived_key_owner: Pubkey,
        pub current_authority_derived_key_seed: String,
    }

    #[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone)]
    pub struct VoteAuthorizeWithSeedArgs {
        pub authorization_type: VoteAuthorize,
        pub current_authority_derived_key_owner: Pubkey,
        pub current_authority_derived_key_seed: String,
        pub new_authority: Pubkey,
    }

    #[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone)]
    pub struct BlockTimestamp {
        pub slot: Slot,
        pub timestamp: UnixTimestamp,
    }

    #[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone)]
    pub struct Vote {
        /// A stack of votes starting with the oldest vote
        pub slots: Vec<Slot>,
        /// signature of the bank's state at the last slot
        pub hash: Hash,
        /// processing timestamp of last slot
        pub timestamp: Option<UnixTimestamp>,
    }

    #[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone)]
    pub struct Lockout {
        pub slot: Slot,
        pub confirmation_count: u32,
    }

    #[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone)]
    pub struct VoteStateUpdate {
        /// The proposed tower
        pub lockouts: VecDeque<Lockout>,
        /// The proposed root
        pub root: Option<Slot>,
        /// signature of the bank's state at the last slot
        pub hash: Hash,
        /// processing timestamp of last slot
        pub timestamp: Option<UnixTimestamp>,
    }
}

pub mod instruction {
    use crate::solana_lib::solana_program::hash::Hash;
    use crate::solana_lib::solana_program::pubkey::Pubkey;
    use crate::solana_lib::solana_program::vote::state::{
        Vote, VoteAuthorize, VoteAuthorizeCheckedWithSeedArgs, VoteAuthorizeWithSeedArgs, VoteInit,
        VoteStateUpdate,
    };
    use serde_derive::{Deserialize, Serialize};

    #[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]
    pub enum VoteInstruction {
        /// Initialize a vote account
        ///
        /// # Account references
        ///   0. `[WRITE]` Uninitialized vote account
        ///   1. `[]` Rent sysvar
        ///   2. `[]` Clock sysvar
        ///   3. `[SIGNER]` New validator identity (node_pubkey)
        InitializeAccount(VoteInit),

        /// Authorize a key to send votes or issue a withdrawal
        ///
        /// # Account references
        ///   0. `[WRITE]` Vote account to be updated with the Pubkey for authorization
        ///   1. `[]` Clock sysvar
        ///   2. `[SIGNER]` Vote or withdraw authority
        Authorize(Pubkey, VoteAuthorize),

        /// A Vote instruction with recent votes
        ///
        /// # Account references
        ///   0. `[WRITE]` Vote account to vote with
        ///   1. `[]` Slot hashes sysvar
        ///   2. `[]` Clock sysvar
        ///   3. `[SIGNER]` Vote authority
        Vote(Vote),

        /// Withdraw some amount of funds
        ///
        /// # Account references
        ///   0. `[WRITE]` Vote account to withdraw from
        ///   1. `[WRITE]` Recipient account
        ///   2. `[SIGNER]` Withdraw authority
        Withdraw(u64),

        /// Update the vote account's validator identity (node_pubkey)
        ///
        /// # Account references
        ///   0. `[WRITE]` Vote account to be updated with the given authority public key
        ///   1. `[SIGNER]` New validator identity (node_pubkey)
        ///   2. `[SIGNER]` Withdraw authority
        UpdateValidatorIdentity,

        /// Update the commission for the vote account
        ///
        /// # Account references
        ///   0. `[WRITE]` Vote account to be updated
        ///   1. `[SIGNER]` Withdraw authority
        UpdateCommission(u8),

        /// A Vote instruction with recent votes
        ///
        /// # Account references
        ///   0. `[WRITE]` Vote account to vote with
        ///   1. `[]` Slot hashes sysvar
        ///   2. `[]` Clock sysvar
        ///   3. `[SIGNER]` Vote authority
        VoteSwitch(Vote, Hash),

        /// Authorize a key to send votes or issue a withdrawal
        ///
        /// This instruction behaves like `Authorize` with the additional requirement that the new vote
        /// or withdraw authority must also be a signer.
        ///
        /// # Account references
        ///   0. `[WRITE]` Vote account to be updated with the Pubkey for authorization
        ///   1. `[]` Clock sysvar
        ///   2. `[SIGNER]` Vote or withdraw authority
        ///   3. `[SIGNER]` New vote or withdraw authority
        AuthorizeChecked(VoteAuthorize),

        /// Update the onchain vote state for the signer.
        ///
        /// # Account references
        ///   0. `[Write]` Vote account to vote with
        ///   1. `[SIGNER]` Vote authority
        UpdateVoteState(VoteStateUpdate),

        /// Update the onchain vote state for the signer along with a switching proof.
        ///
        /// # Account references
        ///   0. `[Write]` Vote account to vote with
        ///   1. `[SIGNER]` Vote authority
        UpdateVoteStateSwitch(VoteStateUpdate, Hash),

        /// Given that the current Voter or Withdrawer authority is a derived key,
        /// this instruction allows someone who can sign for that derived key's
        /// base key to authorize a new Voter or Withdrawer for a vote account.
        ///
        /// # Account references
        ///   0. `[Write]` Vote account to be updated
        ///   1. `[]` Clock sysvar
        ///   2. `[SIGNER]` Base key of current Voter or Withdrawer authority's derived key
        AuthorizeWithSeed(VoteAuthorizeWithSeedArgs),

        /// Given that the current Voter or Withdrawer authority is a derived key,
        /// this instruction allows someone who can sign for that derived key's
        /// base key to authorize a new Voter or Withdrawer for a vote account.
        ///
        /// This instruction behaves like `AuthorizeWithSeed` with the additional requirement
        /// that the new vote or withdraw authority must also be a signer.
        ///
        /// # Account references
        ///   0. `[Write]` Vote account to be updated
        ///   1. `[]` Clock sysvar
        ///   2. `[SIGNER]` Base key of current Voter or Withdrawer authority's derived key
        ///   3. `[SIGNER]` New vote or withdraw authority
        AuthorizeCheckedWithSeed(VoteAuthorizeCheckedWithSeedArgs),
    }
}

'''
'''--- blockchains/solana/src/solana_lib/spl/mod.rs ---
pub mod token;
pub mod token_lending;
pub mod token_swap;

'''
'''--- blockchains/solana/src/solana_lib/spl/token.rs ---
pub mod error {
    use crate::solana_lib::solana_program::program_error::ProgramError;
    use thiserror::Error;

    /// Errors that may be returned by the Token program.
    #[derive(Clone, Debug, Eq, Error, PartialEq)]
    pub enum TokenError {
        // 0
        /// Lamport balance below rent-exempt threshold.
        #[error("Lamport balance below rent-exempt threshold")]
        NotRentExempt,
        /// Insufficient funds for the operation requested.
        #[error("Insufficient funds")]
        InsufficientFunds,
        /// Invalid Mint.
        #[error("Invalid Mint")]
        InvalidMint,
        /// Account not associated with this Mint.
        #[error("Account not associated with this Mint")]
        MintMismatch,
        /// Owner does not match.
        #[error("Owner does not match")]
        OwnerMismatch,

        // 5
        /// This token's supply is fixed and new tokens cannot be minted.
        #[error("Fixed supply")]
        FixedSupply,
        /// The account cannot be initialized because it is already being used.
        #[error("Already in use")]
        AlreadyInUse,
        /// Invalid number of provided signers.
        #[error("Invalid number of provided signers")]
        InvalidNumberOfProvidedSigners,
        /// Invalid number of required signers.
        #[error("Invalid number of required signers")]
        InvalidNumberOfRequiredSigners,
        /// State is uninitialized.
        #[error("State is unititialized")]
        UninitializedState,

        // 10
        /// Instruction does not support native tokens
        #[error("Instruction does not support native tokens")]
        NativeNotSupported,
        /// Non-native account can only be closed if its balance is zero
        #[error("Non-native account can only be closed if its balance is zero")]
        NonNativeHasBalance,
        /// Invalid instruction
        #[error("Invalid instruction")]
        InvalidInstruction,
        /// State is invalid for requested operation.
        #[error("State is invalid for requested operation")]
        InvalidState,
        /// Operation overflowed
        #[error("Operation overflowed")]
        Overflow,

        // 15
        /// Account does not support specified authority type.
        #[error("Account does not support specified authority type")]
        AuthorityTypeNotSupported,
        /// This token mint cannot freeze accounts.
        #[error("This token mint cannot freeze accounts")]
        MintCannotFreeze,
        /// Account is frozen; all account operations will fail
        #[error("Account is frozen")]
        AccountFrozen,
        /// Mint decimals mismatch between the client and mint
        #[error("The provided decimals value different from the Mint decimals")]
        MintDecimalsMismatch,
        /// Instruction does not support non-native tokens
        #[error("Instruction does not support non-native tokens")]
        NonNativeNotSupported,
    }

    impl From<TokenError> for ProgramError {
        fn from(e: TokenError) -> Self {
            ProgramError::Custom(e as u32)
        }
    }
}

pub mod instruction {
    use crate::solana_lib::solana_program::program_error::ProgramError;
    use crate::solana_lib::solana_program::program_option::COption;
    use crate::solana_lib::solana_program::pubkey::Pubkey;
    use crate::solana_lib::spl::token::error::TokenError;

    /// Specifies the authority type for SetAuthority instructions
    #[repr(u8)]
    #[derive(Clone, Debug, PartialEq)]
    pub enum AuthorityType {
        /// Authority to mint new tokens
        MintTokens,
        /// Authority to freeze any account associated with the Mint
        FreezeAccount,
        /// Owner of a given token account
        AccountOwner,
        /// Authority to close a token account
        CloseAccount,
    }

    impl AuthorityType {
        fn into(&self) -> u8 {
            match self {
                AuthorityType::MintTokens => 0,
                AuthorityType::FreezeAccount => 1,
                AuthorityType::AccountOwner => 2,
                AuthorityType::CloseAccount => 3,
            }
        }

        fn from(index: u8) -> Result<Self, ProgramError> {
            match index {
                0 => Ok(AuthorityType::MintTokens),
                1 => Ok(AuthorityType::FreezeAccount),
                2 => Ok(AuthorityType::AccountOwner),
                3 => Ok(AuthorityType::CloseAccount),
                _ => Err(TokenError::InvalidInstruction.into()),
            }
        }
    }

    /// Instructions supported by the token program.
    #[repr(C)]
    #[derive(Clone, Debug, PartialEq)]
    pub enum TokenInstruction {
        /// Initializes a new mint and optionally deposits all the newly minted
        /// tokens in an account.
        ///
        /// The `InitializeMint` instruction requires no signers and MUST be
        /// included within the same Transaction as the system program's
        /// `CreateAccount` instruction that creates the account being initialized.
        /// Otherwise another party can acquire ownership of the uninitialized
        /// account.
        ///
        /// Accounts expected by this instruction:
        ///
        ///   0. `[writable]` The mint to initialize.
        ///   1. `[]` Rent sysvar
        ///
        InitializeMint {
            /// Number of base 10 digits to the right of the decimal place.
            decimals: u8,
            /// The authority/multisignature to mint tokens.
            mint_authority: Pubkey,
            /// The freeze authority/multisignature of the mint.
            freeze_authority: COption<Pubkey>,
        },
        /// Initializes a new account to hold tokens.  If this account is associated
        /// with the native mint then the token balance of the initialized account
        /// will be equal to the amount of SOL in the account. If this account is
        /// associated with another mint, that mint must be initialized before this
        /// command can succeed.
        ///
        /// The `InitializeAccount` instruction requires no signers and MUST be
        /// included within the same Transaction as the system program's
        /// `CreateAccount` instruction that creates the account being initialized.
        /// Otherwise another party can acquire ownership of the uninitialized
        /// account.
        ///
        /// Accounts expected by this instruction:
        ///
        ///   0. `[writable]`  The account to initialize.
        ///   1. `[]` The mint this account will be associated with.
        ///   2. `[]` The new account's owner/multisignature.
        ///   3. `[]` Rent sysvar
        InitializeAccount,
        /// Initializes a multisignature account with N provided signers.
        ///
        /// Multisignature accounts can used in place of any single owner/delegate
        /// accounts in any token instruction that require an owner/delegate to be
        /// present.  The variant field represents the number of signers (M)
        /// required to validate this multisignature account.
        ///
        /// The `InitializeMultisig` instruction requires no signers and MUST be
        /// included within the same Transaction as the system program's
        /// `CreateAccount` instruction that creates the account being initialized.
        /// Otherwise another party can acquire ownership of the uninitialized
        /// account.
        ///
        /// Accounts expected by this instruction:
        ///
        ///   0. `[writable]` The multisignature account to initialize.
        ///   1. `[]` Rent sysvar
        ///   2. ..2+N. `[]` The signer accounts, must equal to N where 1 <= N <=
        ///      11.
        InitializeMultisig {
            /// The number of signers (M) required to validate this multisignature
            /// account.
            m: u8,
        },
        /// Transfers tokens from one account to another either directly or via a
        /// delegate.  If this account is associated with the native mint then equal
        /// amounts of SOL and Tokens will be transferred to the destination
        /// account.
        ///
        /// Accounts expected by this instruction:
        ///
        ///   * Single owner/delegate
        ///   0. `[writable]` The source account.
        ///   1. `[writable]` The destination account.
        ///   2. `[signer]` The source account's owner/delegate.
        ///
        ///   * Multisignature owner/delegate
        ///   0. `[writable]` The source account.
        ///   1. `[writable]` The destination account.
        ///   2. `[]` The source account's multisignature owner/delegate.
        ///   3. ..3+M `[signer]` M signer accounts.
        Transfer {
            /// The amount of tokens to transfer.
            amount: u64,
        },
        /// Approves a delegate.  A delegate is given the authority over tokens on
        /// behalf of the source account's owner.
        ///
        /// Accounts expected by this instruction:
        ///
        ///   * Single owner
        ///   0. `[writable]` The source account.
        ///   1. `[]` The delegate.
        ///   2. `[signer]` The source account owner.
        ///
        ///   * Multisignature owner
        ///   0. `[writable]` The source account.
        ///   1. `[]` The delegate.
        ///   2. `[]` The source account's multisignature owner.
        ///   3. ..3+M `[signer]` M signer accounts
        Approve {
            /// The amount of tokens the delegate is approved for.
            amount: u64,
        },
        /// Revokes the delegate's authority.
        ///
        /// Accounts expected by this instruction:
        ///
        ///   * Single owner
        ///   0. `[writable]` The source account.
        ///   1. `[signer]` The source account owner.
        ///
        ///   * Multisignature owner
        ///   0. `[writable]` The source account.
        ///   1. `[]` The source account's multisignature owner.
        ///   2. ..2+M `[signer]` M signer accounts
        Revoke,
        /// Sets a new authority of a mint or account.
        ///
        /// Accounts expected by this instruction:
        ///
        ///   * Single authority
        ///   0. `[writable]` The mint or account to change the authority of.
        ///   1. `[signer]` The current authority of the mint or account.
        ///
        ///   * Multisignature authority
        ///   0. `[writable]` The mint or account to change the authority of.
        ///   1. `[]` The mint's or account's current multisignature authority.
        ///   2. ..2+M `[signer]` M signer accounts
        SetAuthority {
            /// The type of authority to update.
            authority_type: AuthorityType,
            /// The new authority
            new_authority: COption<Pubkey>,
        },
        /// Mints new tokens to an account.  The native mint does not support
        /// minting.
        ///
        /// Accounts expected by this instruction:
        ///
        ///   * Single authority
        ///   0. `[writable]` The mint.
        ///   1. `[writable]` The account to mint tokens to.
        ///   2. `[signer]` The mint's minting authority.
        ///
        ///   * Multisignature authority
        ///   0. `[writable]` The mint.
        ///   1. `[writable]` The account to mint tokens to.
        ///   2. `[]` The mint's multisignature mint-tokens authority.
        ///   3. ..3+M `[signer]` M signer accounts.
        MintTo {
            /// The amount of new tokens to mint.
            amount: u64,
        },
        /// Burns tokens by removing them from an account.  `Burn` does not support
        /// accounts associated with the native mint, use `CloseAccount` instead.
        ///
        /// Accounts expected by this instruction:
        ///
        ///   * Single owner/delegate
        ///   0. `[writable]` The account to burn from.
        ///   1. `[writable]` The token mint.
        ///   2. `[signer]` The account's owner/delegate.
        ///
        ///   * Multisignature owner/delegate
        ///   0. `[writable]` The account to burn from.
        ///   1. `[writable]` The token mint.
        ///   2. `[]` The account's multisignature owner/delegate.
        ///   3. ..3+M `[signer]` M signer accounts.
        Burn {
            /// The amount of tokens to burn.
            amount: u64,
        },
        /// Close an account by transferring all its SOL to the destination account.
        /// Non-native accounts may only be closed if its token amount is zero.
        ///
        /// Accounts expected by this instruction:
        ///
        ///   * Single owner
        ///   0. `[writable]` The account to close.
        ///   1. `[writable]` The destination account.
        ///   2. `[signer]` The account's owner.
        ///
        ///   * Multisignature owner
        ///   0. `[writable]` The account to close.
        ///   1. `[writable]` The destination account.
        ///   2. `[]` The account's multisignature owner.
        ///   3. ..3+M `[signer]` M signer accounts.
        CloseAccount,
        /// Freeze an Initialized account using the Mint's freeze_authority (if
        /// set).
        ///
        /// Accounts expected by this instruction:
        ///
        ///   * Single owner
        ///   0. `[writable]` The account to freeze.
        ///   1. `[]` The token mint.
        ///   2. `[signer]` The mint freeze authority.
        ///
        ///   * Multisignature owner
        ///   0. `[writable]` The account to freeze.
        ///   1. `[]` The token mint.
        ///   2. `[]` The mint's multisignature freeze authority.
        ///   3. ..3+M `[signer]` M signer accounts.
        FreezeAccount,
        /// Thaw a Frozen account using the Mint's freeze_authority (if set).
        ///
        /// Accounts expected by this instruction:
        ///
        ///   * Single owner
        ///   0. `[writable]` The account to freeze.
        ///   1. `[]` The token mint.
        ///   2. `[signer]` The mint freeze authority.
        ///
        ///   * Multisignature owner
        ///   0. `[writable]` The account to freeze.
        ///   1. `[]` The token mint.
        ///   2. `[]` The mint's multisignature freeze authority.
        ///   3. ..3+M `[signer]` M signer accounts.
        ThawAccount,

        /// Transfers tokens from one account to another either directly or via a
        /// delegate.  If this account is associated with the native mint then equal
        /// amounts of SOL and Tokens will be transferred to the destination
        /// account.
        ///
        /// This instruction differs from Transfer in that the token mint and
        /// decimals value is checked by the caller.  This may be useful when
        /// creating transactions offline or within a hardware wallet.
        ///
        /// Accounts expected by this instruction:
        ///
        ///   * Single owner/delegate
        ///   0. `[writable]` The source account.
        ///   1. `[]` The token mint.
        ///   2. `[writable]` The destination account.
        ///   3. `[signer]` The source account's owner/delegate.
        ///
        ///   * Multisignature owner/delegate
        ///   0. `[writable]` The source account.
        ///   1. `[]` The token mint.
        ///   2. `[writable]` The destination account.
        ///   3. `[]` The source account's multisignature owner/delegate.
        ///   4. ..4+M `[signer]` M signer accounts.
        TransferChecked {
            /// The amount of tokens to transfer.
            amount: u64,
            /// Expected number of base 10 digits to the right of the decimal place.
            decimals: u8,
        },
        /// Approves a delegate.  A delegate is given the authority over tokens on
        /// behalf of the source account's owner.
        ///
        /// This instruction differs from Approve in that the token mint and
        /// decimals value is checked by the caller.  This may be useful when
        /// creating transactions offline or within a hardware wallet.
        ///
        /// Accounts expected by this instruction:
        ///
        ///   * Single owner
        ///   0. `[writable]` The source account.
        ///   1. `[]` The token mint.
        ///   2. `[]` The delegate.
        ///   3. `[signer]` The source account owner.
        ///
        ///   * Multisignature owner
        ///   0. `[writable]` The source account.
        ///   1. `[]` The token mint.
        ///   2. `[]` The delegate.
        ///   3. `[]` The source account's multisignature owner.
        ///   4. ..4+M `[signer]` M signer accounts
        ApproveChecked {
            /// The amount of tokens the delegate is approved for.
            amount: u64,
            /// Expected number of base 10 digits to the right of the decimal place.
            decimals: u8,
        },
        /// Mints new tokens to an account.  The native mint does not support
        /// minting.
        ///
        /// This instruction differs from MintTo in that the decimals value is
        /// checked by the caller.  This may be useful when creating transactions
        /// offline or within a hardware wallet.
        ///
        /// Accounts expected by this instruction:
        ///
        ///   * Single authority
        ///   0. `[writable]` The mint.
        ///   1. `[writable]` The account to mint tokens to.
        ///   2. `[signer]` The mint's minting authority.
        ///
        ///   * Multisignature authority
        ///   0. `[writable]` The mint.
        ///   1. `[writable]` The account to mint tokens to.
        ///   2. `[]` The mint's multisignature mint-tokens authority.
        ///   3. ..3+M `[signer]` M signer accounts.
        MintToChecked {
            /// The amount of new tokens to mint.
            amount: u64,
            /// Expected number of base 10 digits to the right of the decimal place.
            decimals: u8,
        },
        /// Burns tokens by removing them from an account.  `BurnChecked` does not
        /// support accounts associated with the native mint, use `CloseAccount`
        /// instead.
        ///
        /// This instruction differs from Burn in that the decimals value is checked
        /// by the caller. This may be useful when creating transactions offline or
        /// within a hardware wallet.
        ///
        /// Accounts expected by this instruction:
        ///
        ///   * Single owner/delegate
        ///   0. `[writable]` The account to burn from.
        ///   1. `[writable]` The token mint.
        ///   2. `[signer]` The account's owner/delegate.
        ///
        ///   * Multisignature owner/delegate
        ///   0. `[writable]` The account to burn from.
        ///   1. `[writable]` The token mint.
        ///   2. `[]` The account's multisignature owner/delegate.
        ///   3. ..3+M `[signer]` M signer accounts.
        BurnChecked {
            /// The amount of tokens to burn.
            amount: u64,
            /// Expected number of base 10 digits to the right of the decimal place.
            decimals: u8,
        },
        /// Like InitializeAccount, but the owner pubkey is passed via instruction data
        /// rather than the accounts list. This variant may be preferable when using
        /// Cross Program Invocation from an instruction that does not need the owner's
        /// `AccountInfo` otherwise.
        ///
        /// Accounts expected by this instruction:
        ///
        ///   0. `[writable]`  The account to initialize.
        ///   1. `[]` The mint this account will be associated with.
        ///   3. `[]` Rent sysvar
        InitializeAccount2 {
            /// The new account's owner/multisignature.
            owner: Pubkey,
        },
        /// Given a wrapped / native token account (a token account containing SOL)
        /// updates its amount field based on the account's underlying `lamports`.
        /// This is useful if a non-wrapped SOL account uses `system_instruction::transfer`
        /// to move lamports to a wrapped token account, and needs to have its token
        /// `amount` field updated.
        ///
        /// Accounts expected by this instruction:
        ///
        ///   0. `[writable]`  The native token account to sync with its underlying lamports.
        SyncNative,
        /// Like InitializeAccount2, but does not require the Rent sysvar to be provided
        ///
        /// Accounts expected by this instruction:
        ///
        ///   0. `[writable]`  The account to initialize.
        ///   1. `[]` The mint this account will be associated with.
        InitializeAccount3 {
            /// The new account's owner/multisignature.
            owner: Pubkey,
        },
        /// Like InitializeMultisig, but does not require the Rent sysvar to be provided
        ///
        /// Accounts expected by this instruction:
        ///
        ///   0. `[writable]` The multisignature account to initialize.
        ///   1. ..1+N. `[]` The signer accounts, must equal to N where 1 <= N <=
        ///      11.
        InitializeMultisig2 {
            /// The number of signers (M) required to validate this multisignature
            /// account.
            m: u8,
        },
        /// Like InitializeMint, but does not require the Rent sysvar to be provided
        ///
        /// Accounts expected by this instruction:
        ///
        ///   0. `[writable]` The mint to initialize.
        ///
        InitializeMint2 {
            /// Number of base 10 digits to the right of the decimal place.
            decimals: u8,
            /// The authority/multisignature to mint tokens.
            mint_authority: Pubkey,
            /// The freeze authority/multisignature of the mint.
            freeze_authority: COption<Pubkey>,
        },
    }

    impl TokenInstruction {
        /// Unpacks a byte buffer into a [TokenInstruction](enum.TokenInstruction.html).
        pub fn unpack(input: &[u8]) -> Result<Self, ProgramError> {
            use TokenError::InvalidInstruction;

            let (&tag, rest) = input.split_first().ok_or(InvalidInstruction)?;
            Ok(match tag {
                0 => {
                    let (&decimals, rest) = rest.split_first().ok_or(InvalidInstruction)?;
                    let (mint_authority, rest) = Self::unpack_pubkey(rest)?;
                    let (freeze_authority, _rest) = Self::unpack_pubkey_option(rest)?;
                    Self::InitializeMint {
                        mint_authority,
                        freeze_authority,
                        decimals,
                    }
                }
                1 => Self::InitializeAccount,
                2 => {
                    let &m = rest.get(0).ok_or(InvalidInstruction)?;
                    Self::InitializeMultisig { m }
                }
                3 | 4 | 7 | 8 => {
                    let amount = rest
                        .get(..8)
                        .and_then(|slice| slice.try_into().ok())
                        .map(u64::from_le_bytes)
                        .ok_or(InvalidInstruction)?;
                    match tag {
                        3 => Self::Transfer { amount },
                        4 => Self::Approve { amount },
                        7 => Self::MintTo { amount },
                        8 => Self::Burn { amount },
                        _ => unreachable!(),
                    }
                }
                5 => Self::Revoke,
                6 => {
                    let (authority_type, rest) = rest
                        .split_first()
                        .ok_or_else(|| ProgramError::from(InvalidInstruction))
                        .and_then(|(&t, rest)| Ok((AuthorityType::from(t)?, rest)))?;
                    let (new_authority, _rest) = Self::unpack_pubkey_option(rest)?;

                    Self::SetAuthority {
                        authority_type,
                        new_authority,
                    }
                }
                9 => Self::CloseAccount,
                10 => Self::FreezeAccount,
                11 => Self::ThawAccount,
                12 => {
                    let (amount, rest) = rest.split_at(8);
                    let amount = amount
                        .try_into()
                        .ok()
                        .map(u64::from_le_bytes)
                        .ok_or(InvalidInstruction)?;
                    let (&decimals, _rest) = rest.split_first().ok_or(InvalidInstruction)?;

                    Self::TransferChecked { amount, decimals }
                }
                13 => {
                    let (amount, rest) = rest.split_at(8);
                    let amount = amount
                        .try_into()
                        .ok()
                        .map(u64::from_le_bytes)
                        .ok_or(InvalidInstruction)?;
                    let (&decimals, _rest) = rest.split_first().ok_or(InvalidInstruction)?;

                    Self::ApproveChecked { amount, decimals }
                }
                14 => {
                    let (amount, rest) = rest.split_at(8);
                    let amount = amount
                        .try_into()
                        .ok()
                        .map(u64::from_le_bytes)
                        .ok_or(InvalidInstruction)?;
                    let (&decimals, _rest) = rest.split_first().ok_or(InvalidInstruction)?;

                    Self::MintToChecked { amount, decimals }
                }
                15 => {
                    let (amount, rest) = rest.split_at(8);
                    let amount = amount
                        .try_into()
                        .ok()
                        .map(u64::from_le_bytes)
                        .ok_or(InvalidInstruction)?;
                    let (&decimals, _rest) = rest.split_first().ok_or(InvalidInstruction)?;

                    Self::BurnChecked { amount, decimals }
                }
                16 => {
                    let (owner, _rest) = Self::unpack_pubkey(rest)?;
                    Self::InitializeAccount2 { owner }
                }
                17 => Self::SyncNative,
                18 => {
                    let (owner, _rest) = Self::unpack_pubkey(rest)?;
                    Self::InitializeAccount3 { owner }
                }
                19 => {
                    let &m = rest.get(0).ok_or(InvalidInstruction)?;
                    Self::InitializeMultisig2 { m }
                }
                20 => {
                    let (&decimals, rest) = rest.split_first().ok_or(InvalidInstruction)?;
                    let (mint_authority, rest) = Self::unpack_pubkey(rest)?;
                    let (freeze_authority, _rest) = Self::unpack_pubkey_option(rest)?;
                    Self::InitializeMint2 {
                        mint_authority,
                        freeze_authority,
                        decimals,
                    }
                }
                _ => return Err(TokenError::InvalidInstruction.into()),
            })
        }

        fn unpack_pubkey(input: &[u8]) -> Result<(Pubkey, &[u8]), ProgramError> {
            if input.len() >= 32 {
                let (key, rest) = input.split_at(32);
                let pk = Pubkey::new(key);
                Ok((pk, rest))
            } else {
                Err(TokenError::InvalidInstruction.into())
            }
        }

        fn unpack_pubkey_option(input: &[u8]) -> Result<(COption<Pubkey>, &[u8]), ProgramError> {
            match input.split_first() {
                Option::Some((&0, rest)) => Ok((COption::None, rest)),
                Option::Some((&1, rest)) if rest.len() >= 32 => {
                    let (key, rest) = rest.split_at(32);
                    let pk = Pubkey::new(key);
                    Ok((COption::Some(pk), rest))
                }
                _ => Err(TokenError::InvalidInstruction.into()),
            }
        }
    }
}

'''
'''--- blockchains/solana/src/solana_lib/spl/token_lending.rs ---
pub mod error {
    use crate::solana_lib::solana_program::program_error::ProgramError;
    use thiserror::Error;

    /// Errors that may be returned by the TokenLending program.
    #[derive(Clone, Debug, Eq, Error, PartialEq)]
    pub enum LendingError {
        // 0
        /// Invalid instruction data passed in.
        #[error("Failed to unpack instruction data")]
        InstructionUnpackError,
        /// The account cannot be initialized because it is already in use.
        #[error("Account is already initialized")]
        AlreadyInitialized,
        /// Lamport balance below rent-exempt threshold.
        #[error("Lamport balance below rent-exempt threshold")]
        NotRentExempt,
        /// The program address provided doesn't match the value generated by the program.
        #[error("Market authority is invalid")]
        InvalidMarketAuthority,
        /// Expected a different market owner
        #[error("Market owner is invalid")]
        InvalidMarketOwner,

        // 5
        /// The owner of the input isn't set to the program address generated by the program.
        #[error("Input account owner is not the program address")]
        InvalidAccountOwner,
        /// The owner of the account input isn't set to the correct token program id.
        #[error("Input token account is not owned by the correct token program id")]
        InvalidTokenOwner,
        /// Expected an SPL Token account
        #[error("Input token account is not valid")]
        InvalidTokenAccount,
        /// Expected an SPL Token mint
        #[error("Input token mint account is not valid")]
        InvalidTokenMint,
        /// Expected a different SPL Token program
        #[error("Input token program account is not valid")]
        InvalidTokenProgram,

        // 10
        /// Invalid amount, must be greater than zero
        #[error("Input amount is invalid")]
        InvalidAmount,
        /// Invalid config value
        #[error("Input config value is invalid")]
        InvalidConfig,
        /// Invalid config value
        #[error("Input account must be a signer")]
        InvalidSigner,
        /// Invalid account input
        #[error("Invalid account input")]
        InvalidAccountInput,
        /// Math operation overflow
        #[error("Math operation overflow")]
        MathOverflow,

        // 15
        /// Token initialize mint failed
        #[error("Token initialize mint failed")]
        TokenInitializeMintFailed,
        /// Token initialize account failed
        #[error("Token initialize account failed")]
        TokenInitializeAccountFailed,
        /// Token transfer failed
        #[error("Token transfer failed")]
        TokenTransferFailed,
        /// Token mint to failed
        #[error("Token mint to failed")]
        TokenMintToFailed,
        /// Token burn failed
        #[error("Token burn failed")]
        TokenBurnFailed,

        // 20
        /// Insufficient liquidity available
        #[error("Insufficient liquidity available")]
        InsufficientLiquidity,
        /// This reserve's collateral cannot be used for borrows
        #[error("Input reserve has collateral disabled")]
        ReserveCollateralDisabled,
        /// Reserve state stale
        #[error("Reserve state needs to be refreshed")]
        ReserveStale,
        /// Withdraw amount too small
        #[error("Withdraw amount too small")]
        WithdrawTooSmall,
        /// Withdraw amount too large
        #[error("Withdraw amount too large")]
        WithdrawTooLarge,

        // 25
        /// Borrow amount too small
        #[error("Borrow amount too small to receive liquidity after fees")]
        BorrowTooSmall,
        /// Borrow amount too large
        #[error("Borrow amount too large for deposited collateral")]
        BorrowTooLarge,
        /// Repay amount too small
        #[error("Repay amount too small to transfer liquidity")]
        RepayTooSmall,
        /// Liquidation amount too small
        #[error("Liquidation amount too small to receive collateral")]
        LiquidationTooSmall,
        /// Cannot liquidate healthy obligations
        #[error("Cannot liquidate healthy obligations")]
        ObligationHealthy,

        // 30
        /// Obligation state stale
        #[error("Obligation state needs to be refreshed")]
        ObligationStale,
        /// Obligation reserve limit exceeded
        #[error("Obligation reserve limit exceeded")]
        ObligationReserveLimit,
        /// Expected a different obligation owner
        #[error("Obligation owner is invalid")]
        InvalidObligationOwner,
        /// Obligation deposits are empty
        #[error("Obligation deposits are empty")]
        ObligationDepositsEmpty,
        /// Obligation borrows are empty
        #[error("Obligation borrows are empty")]
        ObligationBorrowsEmpty,

        // 35
        /// Obligation deposits have zero value
        #[error("Obligation deposits have zero value")]
        ObligationDepositsZero,
        /// Obligation borrows have zero value
        #[error("Obligation borrows have zero value")]
        ObligationBorrowsZero,
        /// Invalid obligation collateral
        #[error("Invalid obligation collateral")]
        InvalidObligationCollateral,
        /// Invalid obligation liquidity
        #[error("Invalid obligation liquidity")]
        InvalidObligationLiquidity,
        /// Obligation collateral is empty
        #[error("Obligation collateral is empty")]
        ObligationCollateralEmpty,

        // 40
        /// Obligation liquidity is empty
        #[error("Obligation liquidity is empty")]
        ObligationLiquidityEmpty,
        /// Negative interest rate
        #[error("Interest rate is negative")]
        NegativeInterestRate,
        /// Oracle config is invalid
        #[error("Input oracle config is invalid")]
        InvalidOracleConfig,
        /// Expected a different flash loan receiver program
        #[error("Input flash loan receiver program account is not valid")]
        InvalidFlashLoanReceiverProgram,
        /// Not enough liquidity after flash loan
        #[error("Not enough liquidity after flash loan")]
        NotEnoughLiquidityAfterFlashLoan,
        // 45
    }

    impl From<LendingError> for ProgramError {
        fn from(e: LendingError) -> Self {
            ProgramError::Custom(e as u32)
        }
    }
}

pub mod state {
    /// Reserve configuration values
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub struct ReserveConfig {
        /// Optimal utilization rate, as a percentage
        pub optimal_utilization_rate: u8,
        /// Target ratio of the value of borrows to deposits, as a percentage
        /// 0 if use as collateral is disabled
        pub loan_to_value_ratio: u8,
        /// Bonus a liquidator gets when repaying part of an unhealthy obligation, as a percentage
        pub liquidation_bonus: u8,
        /// Loan to value ratio at which an obligation can be liquidated, as a percentage
        pub liquidation_threshold: u8,
        /// Min borrow APY
        pub min_borrow_rate: u8,
        /// Optimal (utilization) borrow APY
        pub optimal_borrow_rate: u8,
        /// Max borrow APY
        pub max_borrow_rate: u8,
        /// Program owner fees assessed, separate from gains due to interest accrual
        pub fees: ReserveFees,
    }

    /// Additional fee information on a reserve
    ///
    /// These exist separately from interest accrual fees, and are specifically for the program owner
    /// and frontend host. The fees are paid out as a percentage of liquidity token amounts during
    /// repayments and liquidations.
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub struct ReserveFees {
        /// Fee assessed on `BorrowObligationLiquidity`, expressed as a Wad.
        /// Must be between 0 and 10^18, such that 10^18 = 1.  A few examples for
        /// clarity:
        /// 1% = 10_000_000_000_000_000
        /// 0.01% (1 basis point) = 100_000_000_000_000
        /// 0.00001% (Aave borrow fee) = 100_000_000_000
        pub borrow_fee_wad: u64,
        /// Fee for flash loan, expressed as a Wad.
        /// 0.3% (Aave flash loan fee) = 3_000_000_000_000_000
        pub flash_loan_fee_wad: u64,
        /// Amount of fee going to host account, if provided in liquidate and repay
        pub host_fee_percentage: u8,
    }
}

pub mod instruction {
    use crate::solana_lib::solana_program::program_error::ProgramError;
    use crate::solana_lib::solana_program::pubkey::{Pubkey, PUBKEY_BYTES};
    use crate::solana_lib::spl::token_lending::error::LendingError;
    use crate::solana_lib::spl::token_lending::state::{ReserveConfig, ReserveFees};

    /// Instructions supported by the lending program.
    #[derive(Clone, Debug, PartialEq)]
    pub enum LendingInstruction {
        // 0
        /// Initializes a new lending market.
        ///
        /// Accounts expected by this instruction:
        ///
        ///   0. `[writable]` Lending market account - uninitialized.
        ///   1. `[]` Rent sysvar.
        ///   2. `[]` Token program id.
        ///   3. `[]` Oracle program id.
        InitLendingMarket {
            /// Owner authority which can add new reserves
            owner: Pubkey,
            /// Currency market prices are quoted in
            /// e.g. "USD" null padded (`*b"USD\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"`) or SPL token mint pubkey
            quote_currency: [u8; 32],
        },

        // 1
        /// Sets the new owner of a lending market.
        ///
        /// Accounts expected by this instruction:
        ///
        ///   0. `[writable]` Lending market account.
        ///   1. `[signer]` Current owner.
        SetLendingMarketOwner {
            /// The new owner
            new_owner: Pubkey,
        },

        // 2
        /// Initializes a new lending market reserve.
        ///
        /// Accounts expected by this instruction:
        ///
        ///   0. `[writable]` Source liquidity token account.
        ///                     $authority can transfer $liquidity_amount.
        ///   1. `[writable]` Destination collateral token account - uninitialized.
        ///   2. `[writable]` Reserve account - uninitialized.
        ///   3. `[]` Reserve liquidity SPL Token mint.
        ///   4. `[writable]` Reserve liquidity supply SPL Token account - uninitialized.
        ///   5. `[writable]` Reserve liquidity fee receiver - uninitialized.
        ///   6. `[writable]` Reserve collateral SPL Token mint - uninitialized.
        ///   7. `[writable]` Reserve collateral token supply - uninitialized.
        ///   8. `[]` Pyth product account.
        ///   9. `[]` Pyth price account.
        ///             This will be used as the reserve liquidity oracle account.
        ///   10 `[]` Lending market account.
        ///   11 `[]` Derived lending market authority.
        ///   12 `[signer]` Lending market owner.
        ///   13 `[signer]` User transfer authority ($authority).
        ///   14 `[]` Clock sysvar.
        ///   15 `[]` Rent sysvar.
        ///   16 `[]` Token program id.
        InitReserve {
            /// Initial amount of liquidity to deposit into the new reserve
            liquidity_amount: u64,
            /// Reserve configuration values
            config: ReserveConfig,
        },

        // 3
        /// Accrue interest and update market price of liquidity on a reserve.
        ///
        /// Accounts expected by this instruction:
        ///
        ///   0. `[writable]` Reserve account.
        ///   1. `[]` Reserve liquidity oracle account.
        ///             Must be the Pyth price account specified at InitReserve.
        ///   2. `[]` Clock sysvar.
        RefreshReserve,

        // 4
        /// Deposit liquidity into a reserve in exchange for collateral. Collateral represents a share
        /// of the reserve liquidity pool.
        ///
        /// Accounts expected by this instruction:
        ///
        ///   0. `[writable]` Source liquidity token account.
        ///                     $authority can transfer $liquidity_amount.
        ///   1. `[writable]` Destination collateral token account.
        ///   2. `[writable]` Reserve account.
        ///   3. `[writable]` Reserve liquidity supply SPL Token account.
        ///   4. `[writable]` Reserve collateral SPL Token mint.
        ///   5. `[]` Lending market account.
        ///   6. `[]` Derived lending market authority.
        ///   7. `[signer]` User transfer authority ($authority).
        ///   8. `[]` Clock sysvar.
        ///   9. `[]` Token program id.
        DepositReserveLiquidity {
            /// Amount of liquidity to deposit in exchange for collateral tokens
            liquidity_amount: u64,
        },

        // 5
        /// Redeem collateral from a reserve in exchange for liquidity.
        ///
        /// Accounts expected by this instruction:
        ///
        ///   0. `[writable]` Source collateral token account.
        ///                     $authority can transfer $collateral_amount.
        ///   1. `[writable]` Destination liquidity token account.
        ///   2. `[writable]` Reserve account.
        ///   3. `[writable]` Reserve collateral SPL Token mint.
        ///   4. `[writable]` Reserve liquidity supply SPL Token account.
        ///   5. `[]` Lending market account.
        ///   6. `[]` Derived lending market authority.
        ///   7. `[signer]` User transfer authority ($authority).
        ///   8. `[]` Clock sysvar.
        ///   9. `[]` Token program id.
        RedeemReserveCollateral {
            /// Amount of collateral tokens to redeem in exchange for liquidity
            collateral_amount: u64,
        },

        // 6
        /// Initializes a new lending market obligation.
        ///
        /// Accounts expected by this instruction:
        ///
        ///   0. `[writable]` Obligation account - uninitialized.
        ///   1. `[]` Lending market account.
        ///   2. `[signer]` Obligation owner.
        ///   3. `[]` Clock sysvar.
        ///   4. `[]` Rent sysvar.
        ///   5. `[]` Token program id.
        InitObligation,

        // 7
        /// Refresh an obligation's accrued interest and collateral and liquidity prices. Requires
        /// refreshed reserves, as all obligation collateral deposit reserves in order, followed by all
        /// liquidity borrow reserves in order.
        ///
        /// Accounts expected by this instruction:
        ///
        ///   0. `[writable]` Obligation account.
        ///   1. `[]` Clock sysvar.
        ///   .. `[]` Collateral deposit reserve accounts - refreshed, all, in order.
        ///   .. `[]` Liquidity borrow reserve accounts - refreshed, all, in order.
        RefreshObligation,

        // 8
        /// Deposit collateral to an obligation. Requires a refreshed reserve.
        ///
        /// Accounts expected by this instruction:
        ///
        ///   0. `[writable]` Source collateral token account.
        ///                     Minted by deposit reserve collateral mint.
        ///                     $authority can transfer $collateral_amount.
        ///   1. `[writable]` Destination deposit reserve collateral supply SPL Token account.
        ///   2. `[]` Deposit reserve account - refreshed.
        ///   3. `[writable]` Obligation account.
        ///   4. `[]` Lending market account.
        ///   5. `[signer]` Obligation owner.
        ///   6. `[signer]` User transfer authority ($authority).
        ///   7. `[]` Clock sysvar.
        ///   8. `[]` Token program id.
        DepositObligationCollateral {
            /// Amount of collateral tokens to deposit
            collateral_amount: u64,
        },

        // 9
        /// Withdraw collateral from an obligation. Requires a refreshed obligation and reserve.
        ///
        /// Accounts expected by this instruction:
        ///
        ///   0. `[writable]` Source withdraw reserve collateral supply SPL Token account.
        ///   1. `[writable]` Destination collateral token account.
        ///                     Minted by withdraw reserve collateral mint.
        ///   2. `[]` Withdraw reserve account - refreshed.
        ///   3. `[writable]` Obligation account - refreshed.
        ///   4. `[]` Lending market account.
        ///   5. `[]` Derived lending market authority.
        ///   6. `[signer]` Obligation owner.
        ///   7. `[]` Clock sysvar.
        ///   8. `[]` Token program id.
        WithdrawObligationCollateral {
            /// Amount of collateral tokens to withdraw - u64::MAX for up to 100% of deposited amount
            collateral_amount: u64,
        },

        // 10
        /// Borrow liquidity from a reserve by depositing collateral tokens. Requires a refreshed
        /// obligation and reserve.
        ///
        /// Accounts expected by this instruction:
        ///
        ///   0. `[writable]` Source borrow reserve liquidity supply SPL Token account.
        ///   1. `[writable]` Destination liquidity token account.
        ///                     Minted by borrow reserve liquidity mint.
        ///   2. `[writable]` Borrow reserve account - refreshed.
        ///   3. `[writable]` Borrow reserve liquidity fee receiver account.
        ///                     Must be the fee account specified at InitReserve.
        ///   4. `[writable]` Obligation account - refreshed.
        ///   5. `[]` Lending market account.
        ///   6. `[]` Derived lending market authority.
        ///   7. `[signer]` Obligation owner.
        ///   8. `[]` Clock sysvar.
        ///   9. `[]` Token program id.
        ///   10 `[optional, writable]` Host fee receiver account.
        BorrowObligationLiquidity {
            /// Amount of liquidity to borrow - u64::MAX for 100% of borrowing power
            liquidity_amount: u64,
            // @TODO: slippage constraint - https://git.io/JmV67
        },

        // 11
        /// Repay borrowed liquidity to a reserve. Requires a refreshed obligation and reserve.
        ///
        /// Accounts expected by this instruction:
        ///
        ///   0. `[writable]` Source liquidity token account.
        ///                     Minted by repay reserve liquidity mint.
        ///                     $authority can transfer $liquidity_amount.
        ///   1. `[writable]` Destination repay reserve liquidity supply SPL Token account.
        ///   2. `[writable]` Repay reserve account - refreshed.
        ///   3. `[writable]` Obligation account - refreshed.
        ///   4. `[]` Lending market account.
        ///   5. `[signer]` User transfer authority ($authority).
        ///   6. `[]` Clock sysvar.
        ///   7. `[]` Token program id.
        RepayObligationLiquidity {
            /// Amount of liquidity to repay - u64::MAX for 100% of borrowed amount
            liquidity_amount: u64,
        },

        // 12
        /// Repay borrowed liquidity to a reserve to receive collateral at a discount from an unhealthy
        /// obligation. Requires a refreshed obligation and reserves.
        ///
        /// Accounts expected by this instruction:
        ///
        ///   0. `[writable]` Source liquidity token account.
        ///                     Minted by repay reserve liquidity mint.
        ///                     $authority can transfer $liquidity_amount.
        ///   1. `[writable]` Destination collateral token account.
        ///                     Minted by withdraw reserve collateral mint.
        ///   2. `[writable]` Repay reserve account - refreshed.
        ///   3. `[writable]` Repay reserve liquidity supply SPL Token account.
        ///   4. `[]` Withdraw reserve account - refreshed.
        ///   5. `[writable]` Withdraw reserve collateral supply SPL Token account.
        ///   6. `[writable]` Obligation account - refreshed.
        ///   7. `[]` Lending market account.
        ///   8. `[]` Derived lending market authority.
        ///   9. `[signer]` User transfer authority ($authority).
        ///   10 `[]` Clock sysvar.
        ///   11 `[]` Token program id.
        LiquidateObligation {
            /// Amount of liquidity to repay - u64::MAX for up to 100% of borrowed amount
            liquidity_amount: u64,
        },

        // 13
        /// Make a flash loan.
        ///
        /// Accounts expected by this instruction:
        ///
        ///   0. `[writable]` Source liquidity token account.
        ///                     Minted by reserve liquidity mint.
        ///                     Must match the reserve liquidity supply.
        ///   1. `[writable]` Destination liquidity token account.
        ///                     Minted by reserve liquidity mint.
        ///   2. `[writable]` Reserve account.
        ///   3. `[writable]` Flash loan fee receiver account.
        ///                     Must match the reserve liquidity fee receiver.
        ///   4. `[writable]` Host fee receiver.
        ///   5. `[]` Lending market account.
        ///   6. `[]` Derived lending market authority.
        ///   7. `[]` Token program id.
        ///   8. `[]` Flash loan receiver program id.
        ///             Must implement an instruction that has tag of 0 and a signature of `(amount: u64)`
        ///             This instruction must return the amount to the source liquidity account.
        ///   .. `[any]` Additional accounts expected by the receiving program's `ReceiveFlashLoan` instruction.
        ///
        ///   The flash loan receiver program that is to be invoked should contain an instruction with
        ///   tag `0` and accept the total amount (including fee) that needs to be returned back after
        ///   its execution has completed.
        ///
        ///   Flash loan receiver should have an instruction with the following signature:
        ///
        ///   0. `[writable]` Source liquidity (matching the destination from above).
        ///   1. `[writable]` Destination liquidity (matching the source from above).
        ///   2. `[]` Token program id
        ///   .. `[any]` Additional accounts provided to the lending program's `FlashLoan` instruction above.
        ///   ReceiveFlashLoan {
        ///       // Amount that must be repaid by the receiver program
        ///       amount: u64
        ///   }
        FlashLoan {
            /// The amount that is to be borrowed - u64::MAX for up to 100% of available liquidity
            amount: u64,
        },
    }

    impl LendingInstruction {
        /// Unpacks a byte buffer into a [LendingInstruction](enum.LendingInstruction.html).
        pub fn unpack(input: &[u8]) -> Result<Self, ProgramError> {
            let (&tag, rest) = input
                .split_first()
                .ok_or(LendingError::InstructionUnpackError)?;
            Ok(match tag {
                0 => {
                    let (owner, rest) = Self::unpack_pubkey(rest)?;
                    let (quote_currency, _rest) = Self::unpack_bytes32(rest)?;
                    Self::InitLendingMarket {
                        owner,
                        quote_currency: *quote_currency,
                    }
                }
                1 => {
                    let (new_owner, _rest) = Self::unpack_pubkey(rest)?;
                    Self::SetLendingMarketOwner { new_owner }
                }
                2 => {
                    let (liquidity_amount, rest) = Self::unpack_u64(rest)?;
                    let (optimal_utilization_rate, rest) = Self::unpack_u8(rest)?;
                    let (loan_to_value_ratio, rest) = Self::unpack_u8(rest)?;
                    let (liquidation_bonus, rest) = Self::unpack_u8(rest)?;
                    let (liquidation_threshold, rest) = Self::unpack_u8(rest)?;
                    let (min_borrow_rate, rest) = Self::unpack_u8(rest)?;
                    let (optimal_borrow_rate, rest) = Self::unpack_u8(rest)?;
                    let (max_borrow_rate, rest) = Self::unpack_u8(rest)?;
                    let (borrow_fee_wad, rest) = Self::unpack_u64(rest)?;
                    let (flash_loan_fee_wad, rest) = Self::unpack_u64(rest)?;
                    let (host_fee_percentage, _rest) = Self::unpack_u8(rest)?;
                    Self::InitReserve {
                        liquidity_amount,
                        config: ReserveConfig {
                            optimal_utilization_rate,
                            loan_to_value_ratio,
                            liquidation_bonus,
                            liquidation_threshold,
                            min_borrow_rate,
                            optimal_borrow_rate,
                            max_borrow_rate,
                            fees: ReserveFees {
                                borrow_fee_wad,
                                flash_loan_fee_wad,
                                host_fee_percentage,
                            },
                        },
                    }
                }
                3 => Self::RefreshReserve,
                4 => {
                    let (liquidity_amount, _rest) = Self::unpack_u64(rest)?;
                    Self::DepositReserveLiquidity { liquidity_amount }
                }
                5 => {
                    let (collateral_amount, _rest) = Self::unpack_u64(rest)?;
                    Self::RedeemReserveCollateral { collateral_amount }
                }
                6 => Self::InitObligation,
                7 => Self::RefreshObligation,
                8 => {
                    let (collateral_amount, _rest) = Self::unpack_u64(rest)?;
                    Self::DepositObligationCollateral { collateral_amount }
                }
                9 => {
                    let (collateral_amount, _rest) = Self::unpack_u64(rest)?;
                    Self::WithdrawObligationCollateral { collateral_amount }
                }
                10 => {
                    let (liquidity_amount, _rest) = Self::unpack_u64(rest)?;
                    Self::BorrowObligationLiquidity { liquidity_amount }
                }
                11 => {
                    let (liquidity_amount, _rest) = Self::unpack_u64(rest)?;
                    Self::RepayObligationLiquidity { liquidity_amount }
                }
                12 => {
                    let (liquidity_amount, _rest) = Self::unpack_u64(rest)?;
                    Self::LiquidateObligation { liquidity_amount }
                }
                13 => {
                    let (amount, _rest) = Self::unpack_u64(rest)?;
                    Self::FlashLoan { amount }
                }
                _ => {
                    return Err(LendingError::InstructionUnpackError.into());
                }
            })
        }

        fn unpack_u64(input: &[u8]) -> Result<(u64, &[u8]), ProgramError> {
            if input.len() < 8 {
                return Err(LendingError::InstructionUnpackError.into());
            }
            let (bytes, rest) = input.split_at(8);
            let value = bytes
                .get(..8)
                .and_then(|slice| slice.try_into().ok())
                .map(u64::from_le_bytes)
                .ok_or(LendingError::InstructionUnpackError)?;
            Ok((value, rest))
        }

        fn unpack_u8(input: &[u8]) -> Result<(u8, &[u8]), ProgramError> {
            if input.is_empty() {
                return Err(LendingError::InstructionUnpackError.into());
            }
            let (bytes, rest) = input.split_at(1);
            let value = bytes
                .get(..1)
                .and_then(|slice| slice.try_into().ok())
                .map(u8::from_le_bytes)
                .ok_or(LendingError::InstructionUnpackError)?;
            Ok((value, rest))
        }

        fn unpack_bytes32(input: &[u8]) -> Result<(&[u8; 32], &[u8]), ProgramError> {
            if input.len() < 32 {
                return Err(LendingError::InstructionUnpackError.into());
            }
            let (bytes, rest) = input.split_at(32);
            Ok((
                bytes
                    .try_into()
                    .map_err(|_| LendingError::InstructionUnpackError)?,
                rest,
            ))
        }

        fn unpack_pubkey(input: &[u8]) -> Result<(Pubkey, &[u8]), ProgramError> {
            if input.len() < PUBKEY_BYTES {
                return Err(LendingError::InstructionUnpackError.into());
            }
            let (key, rest) = input.split_at(PUBKEY_BYTES);
            let pk = Pubkey::new(key);
            Ok((pk, rest))
        }
    }
}

'''
'''--- blockchains/solana/src/solana_lib/spl/token_swap/curve/base.rs ---

use crate::solana_lib::solana_program::program_error::ProgramError;
use crate::solana_lib::solana_program::program_pack::{Pack, Sealed};
use crate::solana_lib::spl::token_swap::curve::calculator::CurveCalculator;
use crate::solana_lib::spl::token_swap::curve::constant_price::ConstantPriceCurve;
use crate::solana_lib::spl::token_swap::curve::constant_product::ConstantProductCurve;
use crate::solana_lib::spl::token_swap::curve::offset::OffsetCurve;
use crate::solana_lib::spl::token_swap::curve::stable::StableCurve;
use arrayref::{array_mut_ref, array_ref, array_refs, mut_array_refs};
use std::sync::Arc;

/// Curve types supported by the token-swap program.
#[cfg_attr(feature = "fuzz", derive(Arbitrary))]
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub enum CurveType {
    /// Uniswap-style constant product curve, invariant = token_a_amount * token_b_amount
    ConstantProduct,
    /// Flat line, always providing 1:1 from one token to another
    ConstantPrice,
    /// Stable, like uniswap, but with wide zone of 1:1 instead of one point
    Stable,
    /// Offset curve, like Uniswap, but the token B side has a faked offset
    Offset,
}

/// Concrete struct to wrap around the trait object which performs calculation.
#[repr(C)]
#[derive(Debug)]
pub struct SwapCurve {
    /// The type of curve contained in the calculator, helpful for outside
    /// queries
    pub curve_type: CurveType,
    /// The actual calculator, represented as a trait object to allow for many
    /// different types of curves
    pub calculator: Arc<dyn CurveCalculator + Sync + Send>,
}

impl Sealed for SwapCurve {}
impl Pack for SwapCurve {
    /// Size of encoding of all curve parameters, which include fees and any other
    /// constants used to calculate swaps, deposits, and withdrawals.
    /// This includes 1 byte for the type, and 72 for the calculator to use as
    /// it needs.  Some calculators may be smaller than 72 bytes.
    const LEN: usize = 33;

    /// Unpacks a byte buffer into a SwapCurve
    fn unpack_from_slice(input: &[u8]) -> Result<Self, ProgramError> {
        let input = array_ref![input, 0, 33];
        #[allow(clippy::ptr_offset_with_cast)]
        let (curve_type, calculator) = array_refs![input, 1, 32];
        let curve_type = curve_type[0].try_into()?;
        Ok(Self {
            curve_type,
            calculator: match curve_type {
                CurveType::ConstantProduct => {
                    Arc::new(ConstantProductCurve::unpack_from_slice(calculator)?)
                }
                CurveType::ConstantPrice => {
                    Arc::new(ConstantPriceCurve::unpack_from_slice(calculator)?)
                }
                CurveType::Stable => Arc::new(StableCurve::unpack_from_slice(calculator)?),
                CurveType::Offset => Arc::new(OffsetCurve::unpack_from_slice(calculator)?),
            },
        })
    }

    /// Pack SwapCurve into a byte buffer
    fn pack_into_slice(&self, output: &mut [u8]) {
        let output = array_mut_ref![output, 0, 33];
        let (curve_type, calculator) = mut_array_refs![output, 1, 32];
        curve_type[0] = self.curve_type as u8;
        self.calculator.pack_into_slice(&mut calculator[..]);
    }
}

impl TryFrom<u8> for CurveType {
    type Error = ProgramError;

    fn try_from(curve_type: u8) -> Result<Self, Self::Error> {
        match curve_type {
            0 => Ok(CurveType::ConstantProduct),
            1 => Ok(CurveType::ConstantPrice),
            2 => Ok(CurveType::Stable),
            3 => Ok(CurveType::Offset),
            _ => Err(ProgramError::InvalidAccountData),
        }
    }
}

'''
'''--- blockchains/solana/src/solana_lib/spl/token_swap/curve/calculator.rs ---
//! Swap calculations

use crate::solana_lib::spl::token_swap::curve::math::PreciseNumber;
use crate::solana_lib::spl::token_swap::error::SwapError;
#[cfg(feature = "fuzz")]
use arbitrary::Arbitrary;
use std::fmt::Debug;

/// Initial amount of pool tokens for swap contract, hard-coded to something
/// "sensible" given a maximum of u128.
/// Note that on Ethereum, Uniswap uses the geometric mean of all provided
/// input amounts, and Balancer uses 100 * 10 ^ 18.
pub const INITIAL_SWAP_POOL_AMOUNT: u128 = 1_000_000_000;

/// Hardcode the number of token types in a pool, used to calculate the
/// equivalent pool tokens for the owner trading fee.
pub const TOKENS_IN_POOL: u128 = 2;

/// Helper function for mapping to SwapError::CalculationFailure
pub fn map_zero_to_none(x: u128) -> Option<u128> {
    if x == 0 {
        None
    } else {
        Some(x)
    }
}

/// The direction of a trade, since curves can be specialized to treat each
/// token differently (by adding offsets or weights)
#[cfg_attr(feature = "fuzz", derive(Arbitrary))]
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub enum TradeDirection {
    /// Input token A, output token B
    AtoB,
    /// Input token B, output token A
    BtoA,
}

/// The direction to round.  Used for pool token to trading token conversions to
/// avoid losing value on any deposit or withdrawal.
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub enum RoundDirection {
    /// Floor the value, ie. 1.9 => 1, 1.1 => 1, 1.5 => 1
    Floor,
    /// Ceiling the value, ie. 1.9 => 2, 1.1 => 2, 1.5 => 2
    Ceiling,
}

impl TradeDirection {
    /// Given a trade direction, gives the opposite direction of the trade, so
    /// A to B becomes B to A, and vice versa
    pub fn opposite(&self) -> TradeDirection {
        match self {
            TradeDirection::AtoB => TradeDirection::BtoA,
            TradeDirection::BtoA => TradeDirection::AtoB,
        }
    }
}

/// Encodes all results of swapping from a source token to a destination token
#[derive(Debug, PartialEq)]
pub struct SwapWithoutFeesResult {
    /// Amount of source token swapped
    pub source_amount_swapped: u128,
    /// Amount of destination token swapped
    pub destination_amount_swapped: u128,
}

/// Encodes results of depositing both sides at once
#[derive(Debug, PartialEq)]
pub struct TradingTokenResult {
    /// Amount of token A
    pub token_a_amount: u128,
    /// Amount of token B
    pub token_b_amount: u128,
}

/// Trait for packing of trait objects, required because structs that implement
/// `Pack` cannot be used as trait objects (as `dyn Pack`).
pub trait DynPack {
    /// Only required function is to pack given a trait object
    fn pack_into_slice(&self, dst: &mut [u8]);
}

/// Trait representing operations required on a swap curve
pub trait CurveCalculator: Debug + DynPack {
    /// Calculate how much destination token will be provided given an amount
    /// of source token.
    fn swap_without_fees(
        &self,
        source_amount: u128,
        swap_source_amount: u128,
        swap_destination_amount: u128,
        trade_direction: TradeDirection,
    ) -> Option<SwapWithoutFeesResult>;

    /// Get the supply for a new pool
    /// The default implementation is a Balancer-style fixed initial supply
    fn new_pool_supply(&self) -> u128 {
        INITIAL_SWAP_POOL_AMOUNT
    }

    /// Get the amount of trading tokens for the given amount of pool tokens,
    /// provided the total trading tokens and supply of pool tokens.
    fn pool_tokens_to_trading_tokens(
        &self,
        pool_tokens: u128,
        pool_token_supply: u128,
        swap_token_a_amount: u128,
        swap_token_b_amount: u128,
        round_direction: RoundDirection,
    ) -> Option<TradingTokenResult>;

    /// Get the amount of pool tokens for the deposited amount of token A or B.
    ///
    /// This is used for single-sided deposits.  It essentially performs a swap
    /// followed by a deposit.  Because a swap is implicitly performed, this will
    /// change the spot price of the pool.
    ///
    /// See more background for the calculation at:
    ///
    /// <https://balancer.finance/whitepaper/#single-asset-deposit-withdrawal>
    fn deposit_single_token_type(
        &self,
        source_amount: u128,
        swap_token_a_amount: u128,
        swap_token_b_amount: u128,
        pool_supply: u128,
        trade_direction: TradeDirection,
    ) -> Option<u128>;

    /// Get the amount of pool tokens for the withdrawn amount of token A or B.
    ///
    /// This is used for single-sided withdrawals and owner trade fee
    /// calculation. It essentially performs a withdrawal followed by a swap.
    /// Because a swap is implicitly performed, this will change the spot price
    /// of the pool.
    ///
    /// See more background for the calculation at:
    ///
    /// <https://balancer.finance/whitepaper/#single-asset-deposit-withdrawal>
    fn withdraw_single_token_type_exact_out(
        &self,
        source_amount: u128,
        swap_token_a_amount: u128,
        swap_token_b_amount: u128,
        pool_supply: u128,
        trade_direction: TradeDirection,
    ) -> Option<u128>;

    /// Validate that the given curve has no invalid parameters
    fn validate(&self) -> Result<(), SwapError>;

    /// Validate the given supply on initialization. This is useful for curves
    /// that allow zero supply on one or both sides, since the standard constant
    /// product curve must have a non-zero supply on both sides.
    fn validate_supply(&self, token_a_amount: u64, token_b_amount: u64) -> Result<(), SwapError> {
        if token_a_amount == 0 {
            return Err(SwapError::EmptySupply);
        }
        if token_b_amount == 0 {
            return Err(SwapError::EmptySupply);
        }
        Ok(())
    }

    /// Some curves function best and prevent attacks if we prevent deposits
    /// after initialization.  For example, the offset curve in `offset.rs`,
    /// which fakes supply on one side of the swap, allows the swap creator
    /// to steal value from all other depositors.
    fn allows_deposits(&self) -> bool {
        true
    }

    /// Calculates the total normalized value of the curve given the liquidity
    /// parameters.
    ///
    /// This value must have the dimension of `tokens ^ 1` For example, the
    /// standard Uniswap invariant has dimension `tokens ^ 2` since we are
    /// multiplying two token values together.  In order to normalize it, we
    /// also need to take the square root.
    ///
    /// This is useful for testing the curves, to make sure that value is not
    /// lost on any trade.  It can also be used to find out the relative value
    /// of pool tokens or liquidity tokens.
    fn normalized_value(
        &self,
        swap_token_a_amount: u128,
        swap_token_b_amount: u128,
    ) -> Option<PreciseNumber>;
}

'''
'''--- blockchains/solana/src/solana_lib/spl/token_swap/curve/constant_price.rs ---
use crate::solana_lib::solana_program::program_error::ProgramError;
use crate::solana_lib::solana_program::program_pack::{IsInitialized, Pack, Sealed};
use crate::solana_lib::spl::token_swap::curve::calculator::{
    map_zero_to_none, CurveCalculator, DynPack, RoundDirection, SwapWithoutFeesResult,
    TradeDirection, TradingTokenResult,
};
use crate::solana_lib::spl::token_swap::curve::math::{CheckedCeilDiv, PreciseNumber, U256};
use crate::solana_lib::spl::token_swap::error::SwapError;
use arrayref::{array_mut_ref, array_ref};

/// Get the amount of pool tokens for the given amount of token A or B.
///
/// The constant product implementation uses the Balancer formulas found at
/// <https://balancer.finance/whitepaper/#single-asset-deposit>, specifically
/// in the case for 2 tokens, each weighted at 1/2.
pub fn trading_tokens_to_pool_tokens(
    token_b_price: u64,
    source_amount: u128,
    swap_token_a_amount: u128,
    swap_token_b_amount: u128,
    pool_supply: u128,
    trade_direction: TradeDirection,
    round_direction: RoundDirection,
) -> Option<u128> {
    let token_b_price = U256::from(token_b_price);
    let given_value = match trade_direction {
        TradeDirection::AtoB => U256::from(source_amount),
        TradeDirection::BtoA => U256::from(source_amount).checked_mul(token_b_price)?,
    };
    let total_value = U256::from(swap_token_b_amount)
        .checked_mul(token_b_price)?
        .checked_add(U256::from(swap_token_a_amount))?;
    let pool_supply = U256::from(pool_supply);
    match round_direction {
        RoundDirection::Floor => Some(
            pool_supply
                .checked_mul(given_value)?
                .checked_div(total_value)?
                .as_u128(),
        ),
        RoundDirection::Ceiling => Some(
            pool_supply
                .checked_mul(given_value)?
                .checked_ceil_div(total_value)?
                .0
                .as_u128(),
        ),
    }
}

/// ConstantPriceCurve struct implementing CurveCalculator
#[derive(Clone, Debug, Default, PartialEq)]
pub struct ConstantPriceCurve {
    /// Amount of token A required to get 1 token B
    pub token_b_price: u64,
}

impl CurveCalculator for ConstantPriceCurve {
    /// Constant price curve always returns 1:1
    fn swap_without_fees(
        &self,
        source_amount: u128,
        _swap_source_amount: u128,
        _swap_destination_amount: u128,
        trade_direction: TradeDirection,
    ) -> Option<SwapWithoutFeesResult> {
        let token_b_price = self.token_b_price as u128;

        let (source_amount_swapped, destination_amount_swapped) = match trade_direction {
            TradeDirection::BtoA => (source_amount, source_amount.checked_mul(token_b_price)?),
            TradeDirection::AtoB => {
                let destination_amount_swapped = source_amount.checked_div(token_b_price)?;
                let mut source_amount_swapped = source_amount;

                // if there is a remainder from buying token B, floor
                // token_a_amount to avoid taking too many tokens, but
                // don't recalculate the fees
                let remainder = source_amount_swapped.checked_rem(token_b_price)?;
                if remainder > 0 {
                    source_amount_swapped = source_amount.checked_sub(remainder)?;
                }

                (source_amount_swapped, destination_amount_swapped)
            }
        };
        let source_amount_swapped = map_zero_to_none(source_amount_swapped)?;
        let destination_amount_swapped = map_zero_to_none(destination_amount_swapped)?;
        Some(SwapWithoutFeesResult {
            source_amount_swapped,
            destination_amount_swapped,
        })
    }

    /// Get the amount of trading tokens for the given amount of pool tokens,
    /// provided the total trading tokens and supply of pool tokens.
    /// For the constant price curve, the total value of the pool is weighted
    /// by the price of token B.
    fn pool_tokens_to_trading_tokens(
        &self,
        pool_tokens: u128,
        pool_token_supply: u128,
        swap_token_a_amount: u128,
        swap_token_b_amount: u128,
        round_direction: RoundDirection,
    ) -> Option<TradingTokenResult> {
        let token_b_price = self.token_b_price as u128;
        let total_value = self
            .normalized_value(swap_token_a_amount, swap_token_b_amount)?
            .to_imprecise()?;

        let (token_a_amount, token_b_amount) = match round_direction {
            RoundDirection::Floor => {
                let token_a_amount = pool_tokens
                    .checked_mul(total_value)?
                    .checked_div(pool_token_supply)?;
                let token_b_amount = pool_tokens
                    .checked_mul(total_value)?
                    .checked_div(token_b_price)?
                    .checked_div(pool_token_supply)?;
                (token_a_amount, token_b_amount)
            }
            RoundDirection::Ceiling => {
                let (token_a_amount, _) = pool_tokens
                    .checked_mul(total_value)?
                    .checked_ceil_div(pool_token_supply)?;
                let (pool_value_as_token_b, _) = pool_tokens
                    .checked_mul(total_value)?
                    .checked_ceil_div(token_b_price)?;
                let (token_b_amount, _) =
                    pool_value_as_token_b.checked_ceil_div(pool_token_supply)?;
                (token_a_amount, token_b_amount)
            }
        };
        Some(TradingTokenResult {
            token_a_amount,
            token_b_amount,
        })
    }

    /// Get the amount of pool tokens for the given amount of token A and B
    /// For the constant price curve, the total value of the pool is weighted
    /// by the price of token B.
    fn deposit_single_token_type(
        &self,
        source_amount: u128,
        swap_token_a_amount: u128,
        swap_token_b_amount: u128,
        pool_supply: u128,
        trade_direction: TradeDirection,
    ) -> Option<u128> {
        trading_tokens_to_pool_tokens(
            self.token_b_price,
            source_amount,
            swap_token_a_amount,
            swap_token_b_amount,
            pool_supply,
            trade_direction,
            RoundDirection::Floor,
        )
    }

    fn withdraw_single_token_type_exact_out(
        &self,
        source_amount: u128,
        swap_token_a_amount: u128,
        swap_token_b_amount: u128,
        pool_supply: u128,
        trade_direction: TradeDirection,
    ) -> Option<u128> {
        trading_tokens_to_pool_tokens(
            self.token_b_price,
            source_amount,
            swap_token_a_amount,
            swap_token_b_amount,
            pool_supply,
            trade_direction,
            RoundDirection::Ceiling,
        )
    }

    fn validate(&self) -> Result<(), SwapError> {
        if self.token_b_price == 0 {
            Err(SwapError::InvalidCurve)
        } else {
            Ok(())
        }
    }

    fn validate_supply(&self, token_a_amount: u64, _token_b_amount: u64) -> Result<(), SwapError> {
        if token_a_amount == 0 {
            return Err(SwapError::EmptySupply);
        }
        Ok(())
    }

    /// The total normalized value of the constant price curve adds the total
    /// value of the token B side to the token A side.
    ///
    /// Note that since most other curves use a multiplicative invariant, ie.
    /// `token_a * token_b`, whereas this one uses an addition,
    /// ie. `token_a + token_b`.
    ///
    /// At the end, we divide by 2 to normalize the value between the two token
    /// types.
    fn normalized_value(
        &self,
        swap_token_a_amount: u128,
        swap_token_b_amount: u128,
    ) -> Option<PreciseNumber> {
        let swap_token_b_value = swap_token_b_amount.checked_mul(self.token_b_price as u128)?;
        // special logic in case we're close to the limits, avoid overflowing u128
        let value = if swap_token_b_value.saturating_sub(std::u64::MAX.into())
            > (std::u128::MAX.saturating_sub(std::u64::MAX.into()))
        {
            swap_token_b_value
                .checked_div(2)?
                .checked_add(swap_token_a_amount.checked_div(2)?)?
        } else {
            swap_token_a_amount
                .checked_add(swap_token_b_value)?
                .checked_div(2)?
        };
        PreciseNumber::new(value)
    }
}

/// IsInitialized is required to use `Pack::pack` and `Pack::unpack`
impl IsInitialized for ConstantPriceCurve {
    fn is_initialized(&self) -> bool {
        true
    }
}
impl Sealed for ConstantPriceCurve {}
impl Pack for ConstantPriceCurve {
    const LEN: usize = 8;
    fn pack_into_slice(&self, output: &mut [u8]) {
        (self as &dyn DynPack).pack_into_slice(output);
    }

    fn unpack_from_slice(input: &[u8]) -> Result<ConstantPriceCurve, ProgramError> {
        let token_b_price = array_ref![input, 0, 8];
        Ok(Self {
            token_b_price: u64::from_le_bytes(*token_b_price),
        })
    }
}

impl DynPack for ConstantPriceCurve {
    fn pack_into_slice(&self, output: &mut [u8]) {
        let token_b_price = array_mut_ref![output, 0, 8];
        *token_b_price = self.token_b_price.to_le_bytes();
    }
}

'''
'''--- blockchains/solana/src/solana_lib/spl/token_swap/curve/constant_product.rs ---
use crate::solana_lib::solana_program::program_error::ProgramError;
use crate::solana_lib::solana_program::program_pack::{IsInitialized, Pack, Sealed};
use crate::solana_lib::spl::token_swap::curve::calculator::{
    map_zero_to_none, CurveCalculator, DynPack, RoundDirection, SwapWithoutFeesResult,
    TradeDirection, TradingTokenResult,
};
use crate::solana_lib::spl::token_swap::curve::math::{CheckedCeilDiv, PreciseNumber};
use crate::solana_lib::spl::token_swap::error::SwapError;

/// ConstantProductCurve struct implementing CurveCalculator
#[derive(Clone, Debug, Default, PartialEq)]
pub struct ConstantProductCurve;

/// The constant product swap calculation, factored out of its class for reuse.
///
/// This is guaranteed to work for all values such that:
///  - 1 <= swap_source_amount * swap_destination_amount <= u128::MAX
///  - 1 <= source_amount <= u64::MAX
pub fn swap(
    source_amount: u128,
    swap_source_amount: u128,
    swap_destination_amount: u128,
) -> Option<SwapWithoutFeesResult> {
    let invariant = swap_source_amount.checked_mul(swap_destination_amount)?;

    let new_swap_source_amount = swap_source_amount.checked_add(source_amount)?;
    let (new_swap_destination_amount, new_swap_source_amount) =
        invariant.checked_ceil_div(new_swap_source_amount)?;

    let source_amount_swapped = new_swap_source_amount.checked_sub(swap_source_amount)?;
    let destination_amount_swapped =
        map_zero_to_none(swap_destination_amount.checked_sub(new_swap_destination_amount)?)?;

    Some(SwapWithoutFeesResult {
        source_amount_swapped,
        destination_amount_swapped,
    })
}

/// Get the amount of trading tokens for the given amount of pool tokens,
/// provided the total trading tokens and supply of pool tokens.
///
/// The constant product implementation is a simple ratio calculation for how many
/// trading tokens correspond to a certain number of pool tokens
pub fn pool_tokens_to_trading_tokens(
    pool_tokens: u128,
    pool_token_supply: u128,
    swap_token_a_amount: u128,
    swap_token_b_amount: u128,
    round_direction: RoundDirection,
) -> Option<TradingTokenResult> {
    let mut token_a_amount = pool_tokens
        .checked_mul(swap_token_a_amount)?
        .checked_div(pool_token_supply)?;
    let mut token_b_amount = pool_tokens
        .checked_mul(swap_token_b_amount)?
        .checked_div(pool_token_supply)?;
    let (token_a_amount, token_b_amount) = match round_direction {
        RoundDirection::Floor => (token_a_amount, token_b_amount),
        RoundDirection::Ceiling => {
            let token_a_remainder = pool_tokens
                .checked_mul(swap_token_a_amount)?
                .checked_rem(pool_token_supply)?;
            // Also check for 0 token A and B amount to avoid taking too much
            // for tiny amounts of pool tokens.  For example, if someone asks
            // for 1 pool token, which is worth 0.01 token A, we avoid the
            // ceiling of taking 1 token A and instead return 0, for it to be
            // rejected later in processing.
            if token_a_remainder > 0 && token_a_amount > 0 {
                token_a_amount += 1;
            }
            let token_b_remainder = pool_tokens
                .checked_mul(swap_token_b_amount)?
                .checked_rem(pool_token_supply)?;
            if token_b_remainder > 0 && token_b_amount > 0 {
                token_b_amount += 1;
            }
            (token_a_amount, token_b_amount)
        }
    };
    Some(TradingTokenResult {
        token_a_amount,
        token_b_amount,
    })
}

/// Get the amount of pool tokens for the deposited amount of token A or B.
///
/// The constant product implementation uses the Balancer formulas found at
/// <https://balancer.finance/whitepaper/#single-asset-deposit>, specifically
/// in the case for 2 tokens, each weighted at 1/2.
pub fn deposit_single_token_type(
    source_amount: u128,
    swap_token_a_amount: u128,
    swap_token_b_amount: u128,
    pool_supply: u128,
    trade_direction: TradeDirection,
    round_direction: RoundDirection,
) -> Option<u128> {
    let swap_source_amount = match trade_direction {
        TradeDirection::AtoB => swap_token_a_amount,
        TradeDirection::BtoA => swap_token_b_amount,
    };
    let swap_source_amount = PreciseNumber::new(swap_source_amount)?;
    let source_amount = PreciseNumber::new(source_amount)?;
    let ratio = source_amount.checked_div(&swap_source_amount)?;
    let one = PreciseNumber::new(1)?;
    let base = one.checked_add(&ratio)?;
    let root = base.sqrt()?.checked_sub(&one)?;
    let pool_supply = PreciseNumber::new(pool_supply)?;
    let pool_tokens = pool_supply.checked_mul(&root)?;
    match round_direction {
        RoundDirection::Floor => pool_tokens.floor()?.to_imprecise(),
        RoundDirection::Ceiling => pool_tokens.ceiling()?.to_imprecise(),
    }
}

/// Get the amount of pool tokens for the withdrawn amount of token A or B.
///
/// The constant product implementation uses the Balancer formulas found at
/// <https://balancer.finance/whitepaper/#single-asset-withdrawal>, specifically
/// in the case for 2 tokens, each weighted at 1/2.
pub fn withdraw_single_token_type_exact_out(
    source_amount: u128,
    swap_token_a_amount: u128,
    swap_token_b_amount: u128,
    pool_supply: u128,
    trade_direction: TradeDirection,
    round_direction: RoundDirection,
) -> Option<u128> {
    let swap_source_amount = match trade_direction {
        TradeDirection::AtoB => swap_token_a_amount,
        TradeDirection::BtoA => swap_token_b_amount,
    };
    let swap_source_amount = PreciseNumber::new(swap_source_amount)?;
    let source_amount = PreciseNumber::new(source_amount)?;
    let ratio = source_amount.checked_div(&swap_source_amount)?;
    let one = PreciseNumber::new(1)?;
    let base = one.checked_sub(&ratio)?;
    let root = one.checked_sub(&base.sqrt()?)?;
    let pool_supply = PreciseNumber::new(pool_supply)?;
    let pool_tokens = pool_supply.checked_mul(&root)?;
    match round_direction {
        RoundDirection::Floor => pool_tokens.floor()?.to_imprecise(),
        RoundDirection::Ceiling => pool_tokens.ceiling()?.to_imprecise(),
    }
}

/// Calculates the total normalized value of the curve given the liquidity
/// parameters.
///
/// The constant product implementation for this function gives the square root of
/// the Uniswap invariant.
pub fn normalized_value(
    swap_token_a_amount: u128,
    swap_token_b_amount: u128,
) -> Option<PreciseNumber> {
    let swap_token_a_amount = PreciseNumber::new(swap_token_a_amount)?;
    let swap_token_b_amount = PreciseNumber::new(swap_token_b_amount)?;
    swap_token_a_amount
        .checked_mul(&swap_token_b_amount)?
        .sqrt()
}

impl CurveCalculator for ConstantProductCurve {
    /// Constant product swap ensures x * y = constant
    fn swap_without_fees(
        &self,
        source_amount: u128,
        swap_source_amount: u128,
        swap_destination_amount: u128,
        _trade_direction: TradeDirection,
    ) -> Option<SwapWithoutFeesResult> {
        swap(source_amount, swap_source_amount, swap_destination_amount)
    }

    /// The constant product implementation is a simple ratio calculation for how many
    /// trading tokens correspond to a certain number of pool tokens
    fn pool_tokens_to_trading_tokens(
        &self,
        pool_tokens: u128,
        pool_token_supply: u128,
        swap_token_a_amount: u128,
        swap_token_b_amount: u128,
        round_direction: RoundDirection,
    ) -> Option<TradingTokenResult> {
        pool_tokens_to_trading_tokens(
            pool_tokens,
            pool_token_supply,
            swap_token_a_amount,
            swap_token_b_amount,
            round_direction,
        )
    }

    /// Get the amount of pool tokens for the deposited amount of token A or B.
    fn deposit_single_token_type(
        &self,
        source_amount: u128,
        swap_token_a_amount: u128,
        swap_token_b_amount: u128,
        pool_supply: u128,
        trade_direction: TradeDirection,
    ) -> Option<u128> {
        deposit_single_token_type(
            source_amount,
            swap_token_a_amount,
            swap_token_b_amount,
            pool_supply,
            trade_direction,
            RoundDirection::Floor,
        )
    }

    fn withdraw_single_token_type_exact_out(
        &self,
        source_amount: u128,
        swap_token_a_amount: u128,
        swap_token_b_amount: u128,
        pool_supply: u128,
        trade_direction: TradeDirection,
    ) -> Option<u128> {
        withdraw_single_token_type_exact_out(
            source_amount,
            swap_token_a_amount,
            swap_token_b_amount,
            pool_supply,
            trade_direction,
            RoundDirection::Ceiling,
        )
    }

    fn normalized_value(
        &self,
        swap_token_a_amount: u128,
        swap_token_b_amount: u128,
    ) -> Option<PreciseNumber> {
        normalized_value(swap_token_a_amount, swap_token_b_amount)
    }

    fn validate(&self) -> Result<(), SwapError> {
        Ok(())
    }
}

/// IsInitialized is required to use `Pack::pack` and `Pack::unpack`
impl IsInitialized for ConstantProductCurve {
    fn is_initialized(&self) -> bool {
        true
    }
}
impl Sealed for ConstantProductCurve {}
impl Pack for ConstantProductCurve {
    const LEN: usize = 0;
    fn pack_into_slice(&self, output: &mut [u8]) {
        (self as &dyn DynPack).pack_into_slice(output);
    }

    fn unpack_from_slice(_input: &[u8]) -> Result<ConstantProductCurve, ProgramError> {
        Ok(Self {})
    }
}

impl DynPack for ConstantProductCurve {
    fn pack_into_slice(&self, _output: &mut [u8]) {}
}

'''
'''--- blockchains/solana/src/solana_lib/spl/token_swap/curve/fees.rs ---

use crate::solana_lib::solana_program::program_error::ProgramError;
use crate::solana_lib::solana_program::program_pack::{Pack, Sealed};
use arrayref::{array_mut_ref, array_ref, array_refs, mut_array_refs};

/// Encapsulates all fee information and calculations for swap operations
#[derive(Clone, Debug, Default, PartialEq)]
pub struct Fees {
    /// Trade fees are extra token amounts that are held inside the token
    /// accounts during a trade, making the value of liquidity tokens rise.
    /// Trade fee numerator
    pub trade_fee_numerator: u64,
    /// Trade fee denominator
    pub trade_fee_denominator: u64,

    /// Owner trading fees are extra token amounts that are held inside the token
    /// accounts during a trade, with the equivalent in pool tokens minted to
    /// the owner of the program.
    /// Owner trade fee numerator
    pub owner_trade_fee_numerator: u64,
    /// Owner trade fee denominator
    pub owner_trade_fee_denominator: u64,

    /// Owner withdraw fees are extra liquidity pool token amounts that are
    /// sent to the owner on every withdrawal.
    /// Owner withdraw fee numerator
    pub owner_withdraw_fee_numerator: u64,
    /// Owner withdraw fee denominator
    pub owner_withdraw_fee_denominator: u64,

    /// Host fees are a proportion of the owner trading fees, sent to an
    /// extra account provided during the trade.
    /// Host trading fee numerator
    pub host_fee_numerator: u64,
    /// Host trading fee denominator
    pub host_fee_denominator: u64,
}

impl Sealed for Fees {}

impl Pack for Fees {
    const LEN: usize = 64;
    fn pack_into_slice(&self, output: &mut [u8]) {
        let output = array_mut_ref![output, 0, 64];
        let (
            trade_fee_numerator,
            trade_fee_denominator,
            owner_trade_fee_numerator,
            owner_trade_fee_denominator,
            owner_withdraw_fee_numerator,
            owner_withdraw_fee_denominator,
            host_fee_numerator,
            host_fee_denominator,
        ) = mut_array_refs![output, 8, 8, 8, 8, 8, 8, 8, 8];
        *trade_fee_numerator = self.trade_fee_numerator.to_le_bytes();
        *trade_fee_denominator = self.trade_fee_denominator.to_le_bytes();
        *owner_trade_fee_numerator = self.owner_trade_fee_numerator.to_le_bytes();
        *owner_trade_fee_denominator = self.owner_trade_fee_denominator.to_le_bytes();
        *owner_withdraw_fee_numerator = self.owner_withdraw_fee_numerator.to_le_bytes();
        *owner_withdraw_fee_denominator = self.owner_withdraw_fee_denominator.to_le_bytes();
        *host_fee_numerator = self.host_fee_numerator.to_le_bytes();
        *host_fee_denominator = self.host_fee_denominator.to_le_bytes();
    }

    fn unpack_from_slice(input: &[u8]) -> Result<Fees, ProgramError> {
        let input = array_ref![input, 0, 64];
        #[allow(clippy::ptr_offset_with_cast)]
        let (
            trade_fee_numerator,
            trade_fee_denominator,
            owner_trade_fee_numerator,
            owner_trade_fee_denominator,
            owner_withdraw_fee_numerator,
            owner_withdraw_fee_denominator,
            host_fee_numerator,
            host_fee_denominator,
        ) = array_refs![input, 8, 8, 8, 8, 8, 8, 8, 8];
        Ok(Self {
            trade_fee_numerator: u64::from_le_bytes(*trade_fee_numerator),
            trade_fee_denominator: u64::from_le_bytes(*trade_fee_denominator),
            owner_trade_fee_numerator: u64::from_le_bytes(*owner_trade_fee_numerator),
            owner_trade_fee_denominator: u64::from_le_bytes(*owner_trade_fee_denominator),
            owner_withdraw_fee_numerator: u64::from_le_bytes(*owner_withdraw_fee_numerator),
            owner_withdraw_fee_denominator: u64::from_le_bytes(*owner_withdraw_fee_denominator),
            host_fee_numerator: u64::from_le_bytes(*host_fee_numerator),
            host_fee_denominator: u64::from_le_bytes(*host_fee_denominator),
        })
    }
}

'''
'''--- blockchains/solana/src/solana_lib/spl/token_swap/curve/mod.rs ---
pub mod constant_price;
pub mod constant_product;
pub mod offset;
pub mod stable;

pub mod fees;

pub mod base;

pub mod calculator;

pub mod math {
    use uint::construct_uint;

    construct_uint! {
        pub struct U256(4);
    }
    construct_uint! {
        pub struct U192(3);
    }

    pub trait CheckedCeilDiv: Sized {
        /// Perform ceiling division
        fn checked_ceil_div(&self, rhs: Self) -> Option<(Self, Self)>;
    }

    impl CheckedCeilDiv for u128 {
        fn checked_ceil_div(&self, mut rhs: Self) -> Option<(Self, Self)> {
            let mut quotient = self.checked_div(rhs)?;
            // Avoid dividing a small number by a big one and returning 1, and instead
            // fail.
            if quotient == 0 {
                return None;
            }

            // Ceiling the destination amount if there's any remainder, which will
            // almost always be the case.
            let remainder = self.checked_rem(rhs)?;
            if remainder > 0 {
                quotient = quotient.checked_add(1)?;
                // calculate the minimum amount needed to get the dividend amount to
                // avoid truncating too much
                rhs = self.checked_div(quotient)?;
                let remainder = self.checked_rem(quotient)?;
                if remainder > 0 {
                    rhs = rhs.checked_add(1)?;
                }
            }
            Some((quotient, rhs))
        }
    }

    impl CheckedCeilDiv for U256 {
        fn checked_ceil_div(&self, mut rhs: Self) -> Option<(Self, Self)> {
            let mut quotient = self.checked_div(rhs)?;
            let zero = U256::from(0);
            let one = U256::from(1);
            // Avoid dividing a small number by a big one and returning 1, and instead
            // fail.
            if quotient == zero {
                return None;
            }

            // Ceiling the destination amount if there's any remainder, which will
            // almost always be the case.
            let remainder = self.checked_rem(rhs)?;
            if remainder > zero {
                quotient = quotient.checked_add(one)?;
                // calculate the minimum amount needed to get the dividend amount to
                // avoid truncating too much
                rhs = self.checked_div(quotient)?;
                let remainder = self.checked_rem(quotient)?;
                if remainder > zero {
                    rhs = rhs.checked_add(one)?;
                }
            }
            Some((quotient, rhs))
        }
    }

    type InnerUint = U256;

    pub const ONE: u128 = 1_000_000_000_000;

    #[derive(Clone, Debug, PartialEq)]
    pub struct PreciseNumber {
        /// Wrapper over the inner value, which is multiplied by ONE
        pub value: InnerUint,
    }

    /// The precise-number 1 as a InnerUint
    fn one() -> InnerUint {
        InnerUint::from(ONE)
    }

    /// The number 0 as a PreciseNumber, used for easier calculations.
    fn zero() -> InnerUint {
        InnerUint::from(0)
    }

    impl PreciseNumber {
        /// Correction to apply to avoid truncation errors on division.  Since
        /// integer operations will always floor the result, we artifically bump it
        /// up by one half to get the expect result.
        fn rounding_correction() -> InnerUint {
            InnerUint::from(ONE / 2)
        }

        /// Desired precision for the correction factor applied during each
        /// iteration of checked_pow_approximation.  Once the correction factor is
        /// smaller than this number, or we reach the maxmium number of iterations,
        /// the calculation ends.
        fn precision() -> InnerUint {
            InnerUint::from(100)
        }

        fn zero() -> Self {
            Self { value: zero() }
        }

        fn one() -> Self {
            Self { value: one() }
        }

        /// Maximum number iterations to apply on checked_pow_approximation.
        const MAX_APPROXIMATION_ITERATIONS: u128 = 100;

        /// Minimum base allowed when calculating exponents in checked_pow_fraction
        /// and checked_pow_approximation.  This simply avoids 0 as a base.
        fn min_pow_base() -> InnerUint {
            InnerUint::from(1)
        }

        /// Maximum base allowed when calculating exponents in checked_pow_fraction
        /// and checked_pow_approximation.  The calculation use a Taylor Series
        /// approxmation around 1, which converges for bases between 0 and 2.  See
        /// https://en.wikipedia.org/wiki/Binomial_series#Conditions_for_convergence
        /// for more information.
        fn max_pow_base() -> InnerUint {
            InnerUint::from(2 * ONE)
        }

        /// Create a precise number from an imprecise u128, should always succeed
        pub fn new(value: u128) -> Option<Self> {
            let value = InnerUint::from(value).checked_mul(one())?;
            Some(Self { value })
        }

        /// Convert a precise number back to u128
        pub fn to_imprecise(&self) -> Option<u128> {
            self.value
                .checked_add(Self::rounding_correction())?
                .checked_div(one())
                .map(|v| v.as_u128())
        }

        /// Checks that two PreciseNumbers are equal within some tolerance
        pub fn almost_eq(&self, rhs: &Self, precision: InnerUint) -> bool {
            let (difference, _) = self.unsigned_sub(rhs);
            difference.value < precision
        }

        /// Checks that a number is less than another
        pub fn less_than(&self, rhs: &Self) -> bool {
            self.value < rhs.value
        }

        /// Checks that a number is greater than another
        pub fn greater_than(&self, rhs: &Self) -> bool {
            self.value > rhs.value
        }

        /// Checks that a number is less than another
        pub fn less_than_or_equal(&self, rhs: &Self) -> bool {
            self.value <= rhs.value
        }

        /// Checks that a number is greater than another
        pub fn greater_than_or_equal(&self, rhs: &Self) -> bool {
            self.value >= rhs.value
        }

        /// Floors a precise value to a precision of ONE
        pub fn floor(&self) -> Option<Self> {
            let value = self.value.checked_div(one())?.checked_mul(one())?;
            Some(Self { value })
        }

        /// Ceiling a precise value to a precision of ONE
        pub fn ceiling(&self) -> Option<Self> {
            let value = self
                .value
                .checked_add(one().checked_sub(InnerUint::from(1))?)?
                .checked_div(one())?
                .checked_mul(one())?;
            Some(Self { value })
        }

        /// Performs a checked division on two precise numbers
        pub fn checked_div(&self, rhs: &Self) -> Option<Self> {
            if *rhs == Self::zero() {
                return None;
            }
            match self.value.checked_mul(one()) {
                Some(v) => {
                    let value = v
                        .checked_add(Self::rounding_correction())?
                        .checked_div(rhs.value)?;
                    Some(Self { value })
                }
                None => {
                    let value = self
                        .value
                        .checked_add(Self::rounding_correction())?
                        .checked_div(rhs.value)?
                        .checked_mul(one())?;
                    Some(Self { value })
                }
            }
        }

        /// Performs a multiplication on two precise numbers
        pub fn checked_mul(&self, rhs: &Self) -> Option<Self> {
            match self.value.checked_mul(rhs.value) {
                Some(v) => {
                    let value = v
                        .checked_add(Self::rounding_correction())?
                        .checked_div(one())?;
                    Some(Self { value })
                }
                None => {
                    let value = if self.value >= rhs.value {
                        self.value.checked_div(one())?.checked_mul(rhs.value)?
                    } else {
                        rhs.value.checked_div(one())?.checked_mul(self.value)?
                    };
                    Some(Self { value })
                }
            }
        }

        /// Performs addition of two precise numbers
        pub fn checked_add(&self, rhs: &Self) -> Option<Self> {
            let value = self.value.checked_add(rhs.value)?;
            Some(Self { value })
        }

        /// Subtracts the argument from self
        pub fn checked_sub(&self, rhs: &Self) -> Option<Self> {
            let value = self.value.checked_sub(rhs.value)?;
            Some(Self { value })
        }

        /// Performs a subtraction, returning the result and whether the result is negative
        pub fn unsigned_sub(&self, rhs: &Self) -> (Self, bool) {
            match self.value.checked_sub(rhs.value) {
                None => {
                    let value = rhs.value.checked_sub(self.value).unwrap();
                    (Self { value }, true)
                }
                Some(value) => (Self { value }, false),
            }
        }

        /// Performs pow on a precise number
        pub fn checked_pow(&self, exponent: u128) -> Option<Self> {
            // For odd powers, start with a multiplication by base since we halve the
            // exponent at the start
            let value = if exponent.checked_rem(2)? == 0 {
                one()
            } else {
                self.value
            };
            let mut result = Self { value };

            // To minimize the number of operations, we keep squaring the base, and
            // only push to the result on odd exponents, like a binary decomposition
            // of the exponent.
            let mut squared_base = self.clone();
            let mut current_exponent = exponent.checked_div(2)?;
            while current_exponent != 0 {
                squared_base = squared_base.checked_mul(&squared_base)?;

                // For odd exponents, "push" the base onto the value
                if current_exponent.checked_rem(2)? != 0 {
                    result = result.checked_mul(&squared_base)?;
                }

                current_exponent = current_exponent.checked_div(2)?;
            }
            Some(result)
        }

        /// Approximate the nth root of a number using a Taylor Series around 1 on
        /// x ^ n, where 0 < n < 1, result is a precise number.
        /// Refine the guess for each term, using:
        ///                                  1                    2
        /// f(x) = f(a) + f'(a) * (x - a) + --- * f''(a) * (x - a)  + ...
        ///                                  2!
        /// For x ^ n, this gives:
        ///  n    n         n-1           1                  n-2        2
        /// x  = a  + n * a    (x - a) + --- * n * (n - 1) a     (x - a)  + ...
        ///                               2!
        ///
        /// More simply, this means refining the term at each iteration with:
        ///
        /// t_k+1 = t_k * (x - a) * (n + 1 - k) / k
        ///
        /// where a = 1, n = power, x = precise_num
        /// NOTE: this function is private because its accurate range and precision
        /// have not been estbalished.
        fn checked_pow_approximation(&self, exponent: &Self, max_iterations: u128) -> Option<Self> {
            assert!(self.value >= Self::min_pow_base());
            assert!(self.value <= Self::max_pow_base());
            let one = Self::one();
            if *exponent == Self::zero() {
                return Some(one);
            }
            let mut precise_guess = one.clone();
            let mut term = precise_guess.clone();
            let (x_minus_a, x_minus_a_negative) = self.unsigned_sub(&precise_guess);
            let exponent_plus_one = exponent.checked_add(&one)?;
            let mut negative = false;
            for k in 1..max_iterations {
                let k = Self::new(k)?;
                let (current_exponent, current_exponent_negative) =
                    exponent_plus_one.unsigned_sub(&k);
                term = term.checked_mul(&current_exponent)?;
                term = term.checked_mul(&x_minus_a)?;
                term = term.checked_div(&k)?;
                if term.value < Self::precision() {
                    break;
                }
                if x_minus_a_negative {
                    negative = !negative;
                }
                if current_exponent_negative {
                    negative = !negative;
                }
                if negative {
                    precise_guess = precise_guess.checked_sub(&term)?;
                } else {
                    precise_guess = precise_guess.checked_add(&term)?;
                }
            }
            Some(precise_guess)
        }

        /// Get the power of a number, where the exponent is expressed as a fraction
        /// (numerator / denominator)
        /// NOTE: this function is private because its accurate range and precision
        /// have not been estbalished.
        #[allow(dead_code)]
        fn checked_pow_fraction(&self, exponent: &Self) -> Option<Self> {
            assert!(self.value >= Self::min_pow_base());
            assert!(self.value <= Self::max_pow_base());
            let whole_exponent = exponent.floor()?;
            let precise_whole = self.checked_pow(whole_exponent.to_imprecise()?)?;
            let (remainder_exponent, negative) = exponent.unsigned_sub(&whole_exponent);
            assert!(!negative);
            if remainder_exponent.value == InnerUint::from(0) {
                return Some(precise_whole);
            }
            let precise_remainder = self.checked_pow_approximation(
                &remainder_exponent,
                Self::MAX_APPROXIMATION_ITERATIONS,
            )?;
            precise_whole.checked_mul(&precise_remainder)
        }

        /// Approximate the nth root of a number using Newton's method
        /// https://en.wikipedia.org/wiki/Newton%27s_method
        /// NOTE: this function is private because its accurate range and precision
        /// have not been established.
        fn newtonian_root_approximation(
            &self,
            root: &Self,
            mut guess: Self,
            iterations: u128,
        ) -> Option<Self> {
            let zero = Self::zero();
            if *self == zero {
                return Some(zero);
            }
            if *root == zero {
                return None;
            }
            let one = Self::new(1)?;
            let root_minus_one = root.checked_sub(&one)?;
            let root_minus_one_whole = root_minus_one.to_imprecise()?;
            let mut last_guess = guess.clone();
            let precision = Self::precision();
            for _ in 0..iterations {
                // x_k+1 = ((n - 1) * x_k + A / (x_k ^ (n - 1))) / n
                let first_term = root_minus_one.checked_mul(&guess)?;
                let power = guess.checked_pow(root_minus_one_whole);
                let second_term = match power {
                    Some(num) => self.checked_div(&num)?,
                    None => Self::new(0)?,
                };
                guess = first_term.checked_add(&second_term)?.checked_div(&root)?;
                if last_guess.almost_eq(&guess, precision) {
                    break;
                } else {
                    last_guess = guess.clone();
                }
            }
            Some(guess)
        }

        /// Based on testing around the limits, this base is the smallest value that
        /// provides an epsilon 11 digits
        fn minimum_sqrt_base() -> Self {
            Self {
                value: InnerUint::from(0),
            }
        }

        /// Based on testing around the limits, this base is the smallest value that
        /// provides an epsilon of 11 digits
        fn maximum_sqrt_base() -> Self {
            Self::new(std::u128::MAX).unwrap()
        }

        /// Approximate the square root using Newton's method.  Based on testing,
        /// this provides a precision of 11 digits for inputs between 0 and u128::MAX
        pub fn sqrt(&self) -> Option<Self> {
            if self.less_than(&Self::minimum_sqrt_base())
                || self.greater_than(&Self::maximum_sqrt_base())
            {
                return None;
            }
            let two = PreciseNumber::new(2)?;
            let one = PreciseNumber::new(1)?;
            // A good initial guess is the average of the interval that contains the
            // input number.  For all numbers, that will be between 1 and the given number.
            let guess = self.checked_add(&one)?.checked_div(&two)?;
            self.newtonian_root_approximation(&two, guess, Self::MAX_APPROXIMATION_ITERATIONS)
        }
    }
}

'''
'''--- blockchains/solana/src/solana_lib/spl/token_swap/curve/offset.rs ---
use crate::solana_lib::solana_program::program_error::ProgramError;
use crate::solana_lib::solana_program::program_pack::{IsInitialized, Pack, Sealed};
use crate::solana_lib::spl::token_swap::curve::calculator::{
    CurveCalculator, DynPack, RoundDirection, SwapWithoutFeesResult, TradeDirection,
    TradingTokenResult,
};
use crate::solana_lib::spl::token_swap::curve::constant_product::{
    deposit_single_token_type, normalized_value, pool_tokens_to_trading_tokens, swap,
    withdraw_single_token_type_exact_out,
};
use crate::solana_lib::spl::token_swap::curve::math::PreciseNumber;
use crate::solana_lib::spl::token_swap::error::SwapError;
use arrayref::{array_mut_ref, array_ref};

/// Offset curve, uses ConstantProduct under the hood, but adds an offset to
/// one side on swap calculations
#[derive(Clone, Debug, Default, PartialEq)]
pub struct OffsetCurve {
    /// Amount to offset the token B liquidity account
    pub token_b_offset: u64,
}

impl CurveCalculator for OffsetCurve {
    /// Constant product swap ensures token a * (token b + offset) = constant
    /// This is guaranteed to work for all values such that:
    ///  - 1 <= source_amount <= u64::MAX
    ///  - 1 <= (swap_source_amount * (swap_destination_amount + token_b_offset)) <= u128::MAX
    /// If the offset and token B are both close to u64::MAX, there can be
    /// overflow errors with the invariant.
    fn swap_without_fees(
        &self,
        source_amount: u128,
        swap_source_amount: u128,
        swap_destination_amount: u128,
        trade_direction: TradeDirection,
    ) -> Option<SwapWithoutFeesResult> {
        let token_b_offset = self.token_b_offset as u128;
        let swap_source_amount = match trade_direction {
            TradeDirection::AtoB => swap_source_amount,
            TradeDirection::BtoA => swap_source_amount.checked_add(token_b_offset)?,
        };
        let swap_destination_amount = match trade_direction {
            TradeDirection::AtoB => swap_destination_amount.checked_add(token_b_offset)?,
            TradeDirection::BtoA => swap_destination_amount,
        };
        swap(source_amount, swap_source_amount, swap_destination_amount)
    }

    /// The conversion for the offset curve needs to take into account the
    /// offset
    fn pool_tokens_to_trading_tokens(
        &self,
        pool_tokens: u128,
        pool_token_supply: u128,
        swap_token_a_amount: u128,
        swap_token_b_amount: u128,
        round_direction: RoundDirection,
    ) -> Option<TradingTokenResult> {
        let token_b_offset = self.token_b_offset as u128;
        pool_tokens_to_trading_tokens(
            pool_tokens,
            pool_token_supply,
            swap_token_a_amount,
            swap_token_b_amount.checked_add(token_b_offset)?,
            round_direction,
        )
    }

    /// Get the amount of pool tokens for the given amount of token A and B,
    /// taking into account the offset
    fn deposit_single_token_type(
        &self,
        source_amount: u128,
        swap_token_a_amount: u128,
        swap_token_b_amount: u128,
        pool_supply: u128,
        trade_direction: TradeDirection,
    ) -> Option<u128> {
        let token_b_offset = self.token_b_offset as u128;
        deposit_single_token_type(
            source_amount,
            swap_token_a_amount,
            swap_token_b_amount.checked_add(token_b_offset)?,
            pool_supply,
            trade_direction,
            RoundDirection::Floor,
        )
    }

    fn withdraw_single_token_type_exact_out(
        &self,
        source_amount: u128,
        swap_token_a_amount: u128,
        swap_token_b_amount: u128,
        pool_supply: u128,
        trade_direction: TradeDirection,
    ) -> Option<u128> {
        let token_b_offset = self.token_b_offset as u128;
        withdraw_single_token_type_exact_out(
            source_amount,
            swap_token_a_amount,
            swap_token_b_amount.checked_add(token_b_offset)?,
            pool_supply,
            trade_direction,
            RoundDirection::Ceiling,
        )
    }

    fn validate(&self) -> Result<(), SwapError> {
        if self.token_b_offset == 0 {
            Err(SwapError::InvalidCurve)
        } else {
            Ok(())
        }
    }

    fn validate_supply(&self, token_a_amount: u64, _token_b_amount: u64) -> Result<(), SwapError> {
        if token_a_amount == 0 {
            return Err(SwapError::EmptySupply);
        }
        Ok(())
    }

    /// Offset curves can cause arbitrage opportunities if outside users are
    /// allowed to deposit.  For example, in the offset curve, if there's swap
    /// with 1 million of token A against an offset of 2 million token B,
    /// someone else can deposit 1 million A and 2 million B for LP tokens.
    /// The pool creator can then use their LP tokens to steal the 2 million B,
    fn allows_deposits(&self) -> bool {
        false
    }

    /// The normalized value of the offset curve simply needs to add the offset to
    /// the token B side before calculating
    fn normalized_value(
        &self,
        swap_token_a_amount: u128,
        swap_token_b_amount: u128,
    ) -> Option<PreciseNumber> {
        let token_b_offset = self.token_b_offset as u128;
        normalized_value(
            swap_token_a_amount,
            swap_token_b_amount.checked_add(token_b_offset)?,
        )
    }
}

/// IsInitialized is required to use `Pack::pack` and `Pack::unpack`
impl IsInitialized for OffsetCurve {
    fn is_initialized(&self) -> bool {
        true
    }
}
impl Sealed for OffsetCurve {}
impl Pack for OffsetCurve {
    const LEN: usize = 8;
    fn pack_into_slice(&self, output: &mut [u8]) {
        (self as &dyn DynPack).pack_into_slice(output);
    }

    fn unpack_from_slice(input: &[u8]) -> Result<OffsetCurve, ProgramError> {
        let token_b_offset = array_ref![input, 0, 8];
        Ok(Self {
            token_b_offset: u64::from_le_bytes(*token_b_offset),
        })
    }
}

impl DynPack for OffsetCurve {
    fn pack_into_slice(&self, output: &mut [u8]) {
        let token_b_offset = array_mut_ref![output, 0, 8];
        *token_b_offset = self.token_b_offset.to_le_bytes();
    }
}

'''
'''--- blockchains/solana/src/solana_lib/spl/token_swap/curve/stable.rs ---
use crate::solana_lib::solana_program::program_error::ProgramError;
use crate::solana_lib::solana_program::program_pack::{IsInitialized, Pack, Sealed};
use crate::solana_lib::spl::token_swap::curve::calculator::{
    CurveCalculator, DynPack, RoundDirection, SwapWithoutFeesResult, TradeDirection,
    TradingTokenResult,
};
use crate::solana_lib::spl::token_swap::curve::math::{CheckedCeilDiv, PreciseNumber, U256};
use crate::solana_lib::spl::token_swap::error::SwapError;
use arrayref::{array_mut_ref, array_ref};

const N_COINS: u8 = 2;
const N_COINS_SQUARED: u8 = 4;
const ITERATIONS: u8 = 32;

/// Calculates A for deriving D
///
/// Per discussion with the designer and writer of stable curves, this A is not
/// the same as the A from the whitepaper, it's actually `A * n**(n-1)`, so when
/// you set A, you actually set `A * n**(n-1)`. This is because `D**n / prod(x)`
/// loses precision with a huge A value.
///
/// There is little information to document this choice, but the original contracts
/// use this same convention, see a comment in the code at:
/// https://github.com/curvefi/curve-contract/blob/b0bbf77f8f93c9c5f4e415bce9cd71f0cdee960e/contracts/pool-templates/base/SwapTemplateBase.vy#L136
fn compute_a(amp: u64) -> Option<u64> {
    amp.checked_mul(N_COINS as u64)
}

/// Returns self to the power of b
fn checked_u8_power(a: &U256, b: u8) -> Option<U256> {
    let mut result = *a;
    for _ in 1..b {
        result = result.checked_mul(*a)?;
    }
    Some(result)
}

/// Returns self multiplied by b
fn checked_u8_mul(a: &U256, b: u8) -> Option<U256> {
    let mut result = *a;
    for _ in 1..b {
        result = result.checked_add(*a)?;
    }
    Some(result)
}

/// StableCurve struct implementing CurveCalculator
#[derive(Clone, Debug, Default, PartialEq)]
pub struct StableCurve {
    /// Amplifier constant
    pub amp: u64,
}

/// d = (leverage * sum_x + d_product * n_coins) * initial_d / ((leverage - 1) * initial_d + (n_coins + 1) * d_product)
fn calculate_step(initial_d: &U256, leverage: u64, sum_x: u128, d_product: &U256) -> Option<U256> {
    let leverage_mul = U256::from(leverage).checked_mul(sum_x.into())?;
    let d_p_mul = checked_u8_mul(d_product, N_COINS)?;

    let l_val = leverage_mul.checked_add(d_p_mul)?.checked_mul(*initial_d)?;

    let leverage_sub = initial_d.checked_mul((leverage.checked_sub(1)?).into())?;
    let n_coins_sum = checked_u8_mul(d_product, N_COINS.checked_add(1)?)?;

    let r_val = leverage_sub.checked_add(n_coins_sum)?;

    l_val.checked_div(r_val)
}

/// Compute stable swap invariant (D)
/// Equation:
/// A * sum(x_i) * n**n + D = A * D * n**n + D**(n+1) / (n**n * prod(x_i))
fn compute_d(leverage: u64, amount_a: u128, amount_b: u128) -> Option<u128> {
    let amount_a_times_coins =
        checked_u8_mul(&U256::from(amount_a), N_COINS)?.checked_add(U256::one())?;
    let amount_b_times_coins =
        checked_u8_mul(&U256::from(amount_b), N_COINS)?.checked_add(U256::one())?;
    let sum_x = amount_a.checked_add(amount_b)?; // sum(x_i), a.k.a S
    if sum_x == 0 {
        Some(0)
    } else {
        let mut d_previous: U256;
        let mut d: U256 = sum_x.into();

        // Newton's method to approximate D
        for _ in 0..ITERATIONS {
            let mut d_product = d;
            d_product = d_product
                .checked_mul(d)?
                .checked_div(amount_a_times_coins)?;
            d_product = d_product
                .checked_mul(d)?
                .checked_div(amount_b_times_coins)?;
            d_previous = d;
            //d = (leverage * sum_x + d_p * n_coins) * d / ((leverage - 1) * d + (n_coins + 1) * d_p);
            d = calculate_step(&d, leverage, sum_x, &d_product)?;
            // Equality with the precision of 1
            if d == d_previous {
                break;
            }
        }
        u128::try_from(d).ok()
    }
}

/// Compute swap amount `y` in proportion to `x`
/// Solve for y:
/// y**2 + y * (sum' - (A*n**n - 1) * D / (A * n**n)) = D ** (n + 1) / (n ** (2 * n) * prod' * A)
/// y**2 + b*y = c
fn compute_new_destination_amount(
    leverage: u64,
    new_source_amount: u128,
    d_val: u128,
) -> Option<u128> {
    // Upscale to U256
    let leverage: U256 = leverage.into();
    let new_source_amount: U256 = new_source_amount.into();
    let d_val: U256 = d_val.into();

    // sum' = prod' = x
    // c =  D ** (n + 1) / (n ** (2 * n) * prod' * A)
    let c = checked_u8_power(&d_val, N_COINS.checked_add(1)?)?
        .checked_div(checked_u8_mul(&new_source_amount, N_COINS_SQUARED)?.checked_mul(leverage)?)?;

    // b = sum' - (A*n**n - 1) * D / (A * n**n)
    let b = new_source_amount.checked_add(d_val.checked_div(leverage)?)?;

    // Solve for y by approximating: y**2 + b*y = c
    let mut y = d_val;
    for _ in 0..ITERATIONS {
        let (y_new, _) = (checked_u8_power(&y, 2)?.checked_add(c)?)
            .checked_ceil_div(checked_u8_mul(&y, 2)?.checked_add(b)?.checked_sub(d_val)?)?;
        if y_new == y {
            break;
        } else {
            y = y_new;
        }
    }
    u128::try_from(y).ok()
}

impl CurveCalculator for StableCurve {
    /// Stable curve
    fn swap_without_fees(
        &self,
        source_amount: u128,
        swap_source_amount: u128,
        swap_destination_amount: u128,
        _trade_direction: TradeDirection,
    ) -> Option<SwapWithoutFeesResult> {
        if source_amount == 0 {
            return Some(SwapWithoutFeesResult {
                source_amount_swapped: 0,
                destination_amount_swapped: 0,
            });
        }
        let leverage = compute_a(self.amp)?;

        let new_source_amount = swap_source_amount.checked_add(source_amount)?;
        let new_destination_amount = compute_new_destination_amount(
            leverage,
            new_source_amount,
            compute_d(leverage, swap_source_amount, swap_destination_amount)?,
        )?;

        let amount_swapped = swap_destination_amount.checked_sub(new_destination_amount)?;

        Some(SwapWithoutFeesResult {
            source_amount_swapped: source_amount,
            destination_amount_swapped: amount_swapped,
        })
    }

    /// Re-implementation of `remove_liquidity`:
    ///
    /// <https://github.com/curvefi/curve-contract/blob/80bbe179083c9a7062e4c482b0be3bfb7501f2bd/contracts/pool-templates/base/SwapTemplateBase.vy#L513>
    fn pool_tokens_to_trading_tokens(
        &self,
        pool_tokens: u128,
        pool_token_supply: u128,
        swap_token_a_amount: u128,
        swap_token_b_amount: u128,
        round_direction: RoundDirection,
    ) -> Option<TradingTokenResult> {
        let mut token_a_amount = pool_tokens
            .checked_mul(swap_token_a_amount)?
            .checked_div(pool_token_supply)?;
        let mut token_b_amount = pool_tokens
            .checked_mul(swap_token_b_amount)?
            .checked_div(pool_token_supply)?;
        let (token_a_amount, token_b_amount) = match round_direction {
            RoundDirection::Floor => (token_a_amount, token_b_amount),
            RoundDirection::Ceiling => {
                let token_a_remainder = pool_tokens
                    .checked_mul(swap_token_a_amount)?
                    .checked_rem(pool_token_supply)?;

                if token_a_remainder > 0 && token_a_amount > 0 {
                    token_a_amount += 1;
                }
                let token_b_remainder = pool_tokens
                    .checked_mul(swap_token_b_amount)?
                    .checked_rem(pool_token_supply)?;
                if token_b_remainder > 0 && token_b_amount > 0 {
                    token_b_amount += 1;
                }
                (token_a_amount, token_b_amount)
            }
        };
        Some(TradingTokenResult {
            token_a_amount,
            token_b_amount,
        })
    }

    /// Get the amount of pool tokens for the given amount of token A or B.
    /// Re-implementation of `calc_token_amount`:
    ///
    /// <https://github.com/curvefi/curve-contract/blob/80bbe179083c9a7062e4c482b0be3bfb7501f2bd/contracts/pool-templates/base/SwapTemplateBase.vy#L267>
    fn deposit_single_token_type(
        &self,
        source_amount: u128,
        swap_token_a_amount: u128,
        swap_token_b_amount: u128,
        pool_supply: u128,
        trade_direction: TradeDirection,
    ) -> Option<u128> {
        if source_amount == 0 {
            return Some(0);
        }
        let leverage = compute_a(self.amp)?;
        let d0 = PreciseNumber::new(compute_d(
            leverage,
            swap_token_a_amount,
            swap_token_b_amount,
        )?)?;
        let (deposit_token_amount, other_token_amount) = match trade_direction {
            TradeDirection::AtoB => (swap_token_a_amount, swap_token_b_amount),
            TradeDirection::BtoA => (swap_token_b_amount, swap_token_a_amount),
        };
        let updated_deposit_token_amount = deposit_token_amount.checked_add(source_amount)?;
        let d1 = PreciseNumber::new(compute_d(
            leverage,
            updated_deposit_token_amount,
            other_token_amount,
        )?)?;
        let diff = d1.checked_sub(&d0)?;
        let final_amount =
            (diff.checked_mul(&PreciseNumber::new(pool_supply)?))?.checked_div(&d0)?;
        final_amount.floor()?.to_imprecise()
    }

    fn withdraw_single_token_type_exact_out(
        &self,
        source_amount: u128,
        swap_token_a_amount: u128,
        swap_token_b_amount: u128,
        pool_supply: u128,
        trade_direction: TradeDirection,
    ) -> Option<u128> {
        if source_amount == 0 {
            return Some(0);
        }
        let leverage = compute_a(self.amp)?;
        let d0 = PreciseNumber::new(compute_d(
            leverage,
            swap_token_a_amount,
            swap_token_b_amount,
        )?)?;
        let (withdraw_token_amount, other_token_amount) = match trade_direction {
            TradeDirection::AtoB => (swap_token_a_amount, swap_token_b_amount),
            TradeDirection::BtoA => (swap_token_b_amount, swap_token_a_amount),
        };
        let updated_deposit_token_amount = withdraw_token_amount.checked_sub(source_amount)?;
        let d1 = PreciseNumber::new(compute_d(
            leverage,
            updated_deposit_token_amount,
            other_token_amount,
        )?)?;
        let diff = d0.checked_sub(&d1)?;
        let final_amount =
            (diff.checked_mul(&PreciseNumber::new(pool_supply)?))?.checked_div(&d0)?;
        final_amount.ceiling()?.to_imprecise()
    }

    fn normalized_value(
        &self,
        swap_token_a_amount: u128,
        swap_token_b_amount: u128,
    ) -> Option<PreciseNumber> {
        let leverage = compute_a(self.amp)?;
        PreciseNumber::new(compute_d(
            leverage,
            swap_token_a_amount,
            swap_token_b_amount,
        )?)
    }

    fn validate(&self) -> Result<(), SwapError> {
        // TODO are all amps valid?
        Ok(())
    }
}

/// IsInitialized is required to use `Pack::pack` and `Pack::unpack`
impl IsInitialized for StableCurve {
    fn is_initialized(&self) -> bool {
        true
    }
}

impl Sealed for StableCurve {}

impl Pack for StableCurve {
    const LEN: usize = 8;
    fn pack_into_slice(&self, output: &mut [u8]) {
        (self as &dyn DynPack).pack_into_slice(output);
    }

    fn unpack_from_slice(input: &[u8]) -> Result<StableCurve, ProgramError> {
        let amp = array_ref![input, 0, 8];
        Ok(Self {
            amp: u64::from_le_bytes(*amp),
        })
    }
}

impl DynPack for StableCurve {
    fn pack_into_slice(&self, output: &mut [u8]) {
        let amp = array_mut_ref![output, 0, 8];
        *amp = self.amp.to_le_bytes();
    }
}

'''
'''--- blockchains/solana/src/solana_lib/spl/token_swap/mod.rs ---
pub mod curve;

pub mod error {
    use crate::solana_lib::solana_program::program_error::ProgramError;
    use thiserror::Error;

    /// Errors that may be returned by the TokenSwap program.
    #[derive(Clone, Debug, Eq, Error, PartialEq)]
    pub enum SwapError {
        // 0.
        /// The account cannot be initialized because it is already being used.
        #[error("Swap account already in use")]
        AlreadyInUse,
        /// The program address provided doesn't match the value generated by the program.
        #[error("Invalid program address generated from bump seed and key")]
        InvalidProgramAddress,
        /// The owner of the input isn't set to the program address generated by the program.
        #[error("Input account owner is not the program address")]
        InvalidOwner,
        /// The owner of the pool token output is set to the program address generated by the program.
        #[error("Output pool account owner cannot be the program address")]
        InvalidOutputOwner,
        /// The deserialization of the account returned something besides State::Mint.
        #[error("Deserialized account is not an SPL Token mint")]
        ExpectedMint,

        // 5.
        /// The deserialization of the account returned something besides State::Account.
        #[error("Deserialized account is not an SPL Token account")]
        ExpectedAccount,
        /// The input token account is empty.
        #[error("Input token account empty")]
        EmptySupply,
        /// The pool token mint has a non-zero supply.
        #[error("Pool token mint has a non-zero supply")]
        InvalidSupply,
        /// The provided token account has a delegate.
        #[error("Token account has a delegate")]
        InvalidDelegate,
        /// The input token is invalid for swap.
        #[error("InvalidInput")]
        InvalidInput,

        // 10.
        /// Address of the provided swap token account is incorrect.
        #[error("Address of the provided swap token account is incorrect")]
        IncorrectSwapAccount,
        /// Address of the provided pool token mint is incorrect
        #[error("Address of the provided pool token mint is incorrect")]
        IncorrectPoolMint,
        /// The output token is invalid for swap.
        #[error("InvalidOutput")]
        InvalidOutput,
        /// General calculation failure due to overflow or underflow
        #[error("General calculation failure due to overflow or underflow")]
        CalculationFailure,
        /// Invalid instruction number passed in.
        #[error("Invalid instruction")]
        InvalidInstruction,

        // 15.
        /// Swap input token accounts have the same mint
        #[error("Swap input token accounts have the same mint")]
        RepeatedMint,
        /// Swap instruction exceeds desired slippage limit
        #[error("Swap instruction exceeds desired slippage limit")]
        ExceededSlippage,
        /// The provided token account has a close authority.
        #[error("Token account has a close authority")]
        InvalidCloseAuthority,
        /// The pool token mint has a freeze authority.
        #[error("Pool token mint has a freeze authority")]
        InvalidFreezeAuthority,
        /// The pool fee token account is incorrect
        #[error("Pool fee token account incorrect")]
        IncorrectFeeAccount,

        // 20.
        /// Given pool token amount results in zero trading tokens
        #[error("Given pool token amount results in zero trading tokens")]
        ZeroTradingTokens,
        /// The fee calculation failed due to overflow, underflow, or unexpected 0
        #[error("Fee calculation failed due to overflow, underflow, or unexpected 0")]
        FeeCalculationFailure,
        /// ConversionFailure
        #[error("Conversion to u64 failed with an overflow or underflow")]
        ConversionFailure,
        /// The provided fee does not match the program owner's constraints
        #[error("The provided fee does not match the program owner's constraints")]
        InvalidFee,
        /// The provided token program does not match the token program expected by the swap
        #[error(
            "The provided token program does not match the token program expected by the swap"
        )]
        IncorrectTokenProgramId,

        // 25.
        /// The provided curve type is not supported by the program owner
        #[error("The provided curve type is not supported by the program owner")]
        UnsupportedCurveType,
        /// The provided curve parameters are invalid
        #[error("The provided curve parameters are invalid")]
        InvalidCurve,
        /// The operation cannot be performed on the given curve
        #[error("The operation cannot be performed on the given curve")]
        UnsupportedCurveOperation,
    }

    impl From<SwapError> for ProgramError {
        fn from(e: SwapError) -> Self {
            ProgramError::Custom(e as u32)
        }
    }
}

pub mod instruction {
    use crate::solana_lib::solana_program::program_error::ProgramError;
    use crate::solana_lib::solana_program::program_pack::Pack;
    use crate::solana_lib::spl::token_swap::curve::base::SwapCurve;
    use crate::solana_lib::spl::token_swap::curve::fees::Fees;
    use crate::solana_lib::spl::token_swap::error::SwapError;

    /// Initialize instruction data
    #[repr(C)]
    #[derive(Debug)]
    pub struct Initialize {
        /// all swap fees
        pub fees: Fees,
        /// swap curve info for pool, including CurveType and anything
        /// else that may be required
        pub swap_curve: SwapCurve,
    }

    /// Swap instruction data
    #[cfg_attr(feature = "fuzz", derive(Arbitrary))]
    #[repr(C)]
    #[derive(Clone, Debug, PartialEq)]
    pub struct Swap {
        /// SOURCE amount to transfer, output to DESTINATION is based on the exchange rate
        pub amount_in: u64,
        /// Minimum amount of DESTINATION token to output, prevents excessive slippage
        pub minimum_amount_out: u64,
    }

    /// DepositAllTokenTypes instruction data
    #[cfg_attr(feature = "fuzz", derive(Arbitrary))]
    #[repr(C)]
    #[derive(Clone, Debug, PartialEq)]
    pub struct DepositAllTokenTypes {
        /// Pool token amount to transfer. token_a and token_b amount are set by
        /// the current exchange rate and size of the pool
        pub pool_token_amount: u64,
        /// Maximum token A amount to deposit, prevents excessive slippage
        pub maximum_token_a_amount: u64,
        /// Maximum token B amount to deposit, prevents excessive slippage
        pub maximum_token_b_amount: u64,
    }

    /// WithdrawAllTokenTypes instruction data
    #[cfg_attr(feature = "fuzz", derive(Arbitrary))]
    #[repr(C)]
    #[derive(Clone, Debug, PartialEq)]
    pub struct WithdrawAllTokenTypes {
        /// Amount of pool tokens to burn. User receives an output of token a
        /// and b based on the percentage of the pool tokens that are returned.
        pub pool_token_amount: u64,
        /// Minimum amount of token A to receive, prevents excessive slippage
        pub minimum_token_a_amount: u64,
        /// Minimum amount of token B to receive, prevents excessive slippage
        pub minimum_token_b_amount: u64,
    }

    /// Deposit one token type, exact amount in instruction data
    #[cfg_attr(feature = "fuzz", derive(Arbitrary))]
    #[repr(C)]
    #[derive(Clone, Debug, PartialEq)]
    pub struct DepositSingleTokenTypeExactAmountIn {
        /// Token amount to deposit
        pub source_token_amount: u64,
        /// Pool token amount to receive in exchange. The amount is set by
        /// the current exchange rate and size of the pool
        pub minimum_pool_token_amount: u64,
    }

    /// WithdrawSingleTokenTypeExactAmountOut instruction data
    #[cfg_attr(feature = "fuzz", derive(Arbitrary))]
    #[repr(C)]
    #[derive(Clone, Debug, PartialEq)]
    pub struct WithdrawSingleTokenTypeExactAmountOut {
        /// Amount of token A or B to receive
        pub destination_token_amount: u64,
        /// Maximum amount of pool tokens to burn. User receives an output of token A
        /// or B based on the percentage of the pool tokens that are returned.
        pub maximum_pool_token_amount: u64,
    }

    /// Instructions supported by the token swap program.
    #[repr(C)]
    #[derive(Debug)]
    pub enum SwapInstruction {
        ///   Initializes a new swap
        ///
        ///   0. `[writable, signer]` New Token-swap to create.
        ///   1. `[]` swap authority derived from `create_program_address(&[Token-swap account])`
        ///   2. `[]` token_a Account. Must be non zero, owned by swap authority.
        ///   3. `[]` token_b Account. Must be non zero, owned by swap authority.
        ///   4. `[writable]` Pool Token Mint. Must be empty, owned by swap authority.
        ///   5. `[]` Pool Token Account to deposit trading and withdraw fees.
        ///   Must be empty, not owned by swap authority
        ///   6. `[writable]` Pool Token Account to deposit the initial pool token
        ///   supply.  Must be empty, not owned by swap authority.
        ///   7. `[]` Token program id
        Initialize(Initialize),

        ///   Swap the tokens in the pool.
        ///
        ///   0. `[]` Token-swap
        ///   1. `[]` swap authority
        ///   2. `[]` user transfer authority
        ///   3. `[writable]` token_(A|B) SOURCE Account, amount is transferable by user transfer authority,
        ///   4. `[writable]` token_(A|B) Base Account to swap INTO.  Must be the SOURCE token.
        ///   5. `[writable]` token_(A|B) Base Account to swap FROM.  Must be the DESTINATION token.
        ///   6. `[writable]` token_(A|B) DESTINATION Account assigned to USER as the owner.
        ///   7. `[writable]` Pool token mint, to generate trading fees
        ///   8. `[writable]` Fee account, to receive trading fees
        ///   9. `[]` Token program id
        ///   10. `[optional, writable]` Host fee account to receive additional trading fees
        Swap(Swap),

        ///   Deposit both types of tokens into the pool.  The output is a "pool"
        ///   token representing ownership in the pool. Inputs are converted to
        ///   the current ratio.
        ///
        ///   0. `[]` Token-swap
        ///   1. `[]` swap authority
        ///   2. `[]` user transfer authority
        ///   3. `[writable]` token_a user transfer authority can transfer amount,
        ///   4. `[writable]` token_b user transfer authority can transfer amount,
        ///   5. `[writable]` token_a Base Account to deposit into.
        ///   6. `[writable]` token_b Base Account to deposit into.
        ///   7. `[writable]` Pool MINT account, swap authority is the owner.
        ///   8. `[writable]` Pool Account to deposit the generated tokens, user is the owner.
        ///   9. `[]` Token program id
        DepositAllTokenTypes(DepositAllTokenTypes),

        ///   Withdraw both types of tokens from the pool at the current ratio, given
        ///   pool tokens.  The pool tokens are burned in exchange for an equivalent
        ///   amount of token A and B.
        ///
        ///   0. `[]` Token-swap
        ///   1. `[]` swap authority
        ///   2. `[]` user transfer authority
        ///   3. `[writable]` Pool mint account, swap authority is the owner
        ///   4. `[writable]` SOURCE Pool account, amount is transferable by user transfer authority.
        ///   5. `[writable]` token_a Swap Account to withdraw FROM.
        ///   6. `[writable]` token_b Swap Account to withdraw FROM.
        ///   7. `[writable]` token_a user Account to credit.
        ///   8. `[writable]` token_b user Account to credit.
        ///   9. `[writable]` Fee account, to receive withdrawal fees
        ///   10. `[]` Token program id
        WithdrawAllTokenTypes(WithdrawAllTokenTypes),

        ///   Deposit one type of tokens into the pool.  The output is a "pool" token
        ///   representing ownership into the pool. Input token is converted as if
        ///   a swap and deposit all token types were performed.
        ///
        ///   0. `[]` Token-swap
        ///   1. `[]` swap authority
        ///   2. `[]` user transfer authority
        ///   3. `[writable]` token_(A|B) SOURCE Account, amount is transferable by user transfer authority,
        ///   4. `[writable]` token_a Swap Account, may deposit INTO.
        ///   5. `[writable]` token_b Swap Account, may deposit INTO.
        ///   6. `[writable]` Pool MINT account, swap authority is the owner.
        ///   7. `[writable]` Pool Account to deposit the generated tokens, user is the owner.
        ///   8. `[]` Token program id
        DepositSingleTokenTypeExactAmountIn(DepositSingleTokenTypeExactAmountIn),

        ///   Withdraw one token type from the pool at the current ratio given the
        ///   exact amount out expected.
        ///
        ///   0. `[]` Token-swap
        ///   1. `[]` swap authority
        ///   2. `[]` user transfer authority
        ///   3. `[writable]` Pool mint account, swap authority is the owner
        ///   4. `[writable]` SOURCE Pool account, amount is transferable by user transfer authority.
        ///   5. `[writable]` token_a Swap Account to potentially withdraw from.
        ///   6. `[writable]` token_b Swap Account to potentially withdraw from.
        ///   7. `[writable]` token_(A|B) User Account to credit
        ///   8. `[writable]` Fee account, to receive withdrawal fees
        ///   9. `[]` Token program id
        WithdrawSingleTokenTypeExactAmountOut(WithdrawSingleTokenTypeExactAmountOut),
    }

    impl SwapInstruction {
        /// Unpacks a byte buffer into a [SwapInstruction](enum.SwapInstruction.html).
        pub fn unpack(input: &[u8]) -> Result<Self, ProgramError> {
            let (&tag, rest) = input.split_first().ok_or(SwapError::InvalidInstruction)?;
            Ok(match tag {
                0 => {
                    if rest.len() >= Fees::LEN {
                        let (fees, rest) = rest.split_at(Fees::LEN);
                        let fees = Fees::unpack_unchecked(fees)?;
                        let swap_curve = SwapCurve::unpack_unchecked(rest)?;
                        Self::Initialize(Initialize { fees, swap_curve })
                    } else {
                        return Err(SwapError::InvalidInstruction.into());
                    }
                }
                1 => {
                    let (amount_in, rest) = Self::unpack_u64(rest)?;
                    let (minimum_amount_out, _rest) = Self::unpack_u64(rest)?;
                    Self::Swap(Swap {
                        amount_in,
                        minimum_amount_out,
                    })
                }
                2 => {
                    let (pool_token_amount, rest) = Self::unpack_u64(rest)?;
                    let (maximum_token_a_amount, rest) = Self::unpack_u64(rest)?;
                    let (maximum_token_b_amount, _rest) = Self::unpack_u64(rest)?;
                    Self::DepositAllTokenTypes(DepositAllTokenTypes {
                        pool_token_amount,
                        maximum_token_a_amount,
                        maximum_token_b_amount,
                    })
                }
                3 => {
                    let (pool_token_amount, rest) = Self::unpack_u64(rest)?;
                    let (minimum_token_a_amount, rest) = Self::unpack_u64(rest)?;
                    let (minimum_token_b_amount, _rest) = Self::unpack_u64(rest)?;
                    Self::WithdrawAllTokenTypes(WithdrawAllTokenTypes {
                        pool_token_amount,
                        minimum_token_a_amount,
                        minimum_token_b_amount,
                    })
                }
                4 => {
                    let (source_token_amount, rest) = Self::unpack_u64(rest)?;
                    let (minimum_pool_token_amount, _rest) = Self::unpack_u64(rest)?;
                    Self::DepositSingleTokenTypeExactAmountIn(DepositSingleTokenTypeExactAmountIn {
                        source_token_amount,
                        minimum_pool_token_amount,
                    })
                }
                5 => {
                    let (destination_token_amount, rest) = Self::unpack_u64(rest)?;
                    let (maximum_pool_token_amount, _rest) = Self::unpack_u64(rest)?;
                    Self::WithdrawSingleTokenTypeExactAmountOut(
                        WithdrawSingleTokenTypeExactAmountOut {
                            destination_token_amount,
                            maximum_pool_token_amount,
                        },
                    )
                }
                _ => return Err(SwapError::InvalidInstruction.into()),
            })
        }

        fn unpack_u64(input: &[u8]) -> Result<(u64, &[u8]), ProgramError> {
            if input.len() >= 8 {
                let (amount, rest) = input.split_at(8);
                let amount = amount
                    .get(..8)
                    .and_then(|slice| slice.try_into().ok())
                    .map(u64::from_le_bytes)
                    .ok_or(SwapError::InvalidInstruction)?;
                Ok((amount, rest))
            } else {
                Err(SwapError::InvalidInstruction.into())
            }
        }
    }
}

'''
'''--- blockchains/sui/Cargo.toml ---
cargo-features = ["profile-rustflags"]

[package]
name = "rcc_sui"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
bcs = {git = "https://github.com/KeystoneHQ/bcs.git", tag = "0.1.1"}
thiserror = { version = "1.0", package = "thiserror-core", default-features = false }
sui-types = { git = "https://github.com/KeystoneHQ/sui.git", tag = "0.1.1", package = "sui-types" }

[dev-dependencies]
hex = "0.4.1"
serde_json = "1"

'''
'''--- blockchains/sui/src/errors.rs ---
use alloc::string::{String, ToString};
use thiserror::Error;

pub type Result<T> = core::result::Result<T, SuiError>;

#[derive(Error, Debug)]
pub enum SuiError {
    #[error("Bcs Decoding error: {0}")]
    BcsDecodingError(String),
    #[error("Invalid Transaction")]
    InvalidTransaction,
    #[error("sign failed, reason: {0}")]
    SignFailure(String),
    #[error("Invalid hd_Path: {0}")]
    InvalidHDPath(String),
    #[error("KeystoreError: {0}")]
    KeystoreError(String),
    #[error("Invalid Address: {0}")]
    InvalidAddressError(String),
}

impl From<bcs::Error> for SuiError {
    fn from(value: bcs::Error) -> Self {
        SuiError::BcsDecodingError(value.to_string())
    }
}

'''
'''--- blockchains/sui/src/lib.rs ---
#![no_std]
#![feature(error_in_core)]
extern crate alloc;

pub mod errors;

use sui_types::transaction::TransactionData;
use sui_types::message::PersonalMessage;
use alloc::vec::Vec;
use bcs;
use errors::{Result, SuiError};

pub type Bytes = Vec<u8>;

pub fn parse_tx(tx: Bytes) -> Result<TransactionData> {
  let tx:TransactionData = bcs::from_bytes(&tx).map_err(|err| SuiError::from(err))?;
  Ok(tx)
}

pub fn parse_msg(msg: Bytes) -> Result<PersonalMessage> {
  let msg: PersonalMessage = bcs::from_bytes(&msg).map_err(|err| SuiError::from(err))?;
  Ok(msg)
}

#[cfg(test)]
mod tests {
  extern crate std;

  use alloc::string::ToString;
  use serde_json::json;
  use super::*;

  #[test]
  fn test_parse_tx() {
    // TransferObjects
    let tx_bytes = hex::decode("000002002086ac6179ca6ad9a7b1ccb47202d06ae09a131e66309944922af9c73d3c203b660100d833a8eabc697a0b2e23740aca7be9b0b9e1560a39d2f390cf2534e94429f91ced0c00000000000020190ca0d64215ac63f50dbffa47563404182304e0c10ea30b5e4d671b7173a34c0101010101000100000e4d9313fb5b3f166bb6f2aea587edbe21fb1c094472ccd002f34b9d0633c71901280f4809b93ed87cc06f3397cd42a800a1034316e80d05443bce08e810817a96f50c0000000000002051c8eb5d437fb66c8d296e1cdf446c91be29fbc89f8430a2407acb0179a503880e4d9313fb5b3f166bb6f2aea587edbe21fb1c094472ccd002f34b9d0633c719e803000000000000d00700000000000000").unwrap();
    let tx = parse_tx(tx_bytes);
    assert_eq!(json!(tx.unwrap()).to_string(), "{\"V1\":{\"expiration\":\"None\",\"gas_data\":{\"budget\":2000,\"owner\":\"0x0e4d9313fb5b3f166bb6f2aea587edbe21fb1c094472ccd002f34b9d0633c719\",\"payment\":[[\"0x280f4809b93ed87cc06f3397cd42a800a1034316e80d05443bce08e810817a96\",3317,\"6WFidAcGkUzUEPvSChbMXg9AZUHj3gzJL4U7HkxJA43H\"]],\"price\":1000},\"kind\":{\"ProgrammableTransaction\":{\"commands\":[{\"TransferObjects\":[[{\"Input\":1}],{\"Input\":0}]}],\"inputs\":[{\"Pure\":[134,172,97,121,202,106,217,167,177,204,180,114,2,208,106,224,154,19,30,102,48,153,68,146,42,249,199,61,60,32,59,102]},{\"Object\":{\"ImmOrOwnedObject\":[\"0xd833a8eabc697a0b2e23740aca7be9b0b9e1560a39d2f390cf2534e94429f91c\",3309,\"2gnMwEZqfMY1Q2Ree5iW3cAt7rhauevfBDY74SH3Ef1D\"]}}]}},\"sender\":\"0x0e4d9313fb5b3f166bb6f2aea587edbe21fb1c094472ccd002f34b9d0633c719\"}}");

    // MoveCall
    let tx_bytes = hex::decode("0000020100d833a8eabc697a0b2e23740aca7be9b0b9e1560a39d2f390cf2534e94429f91ced0c00000000000020190ca0d64215ac63f50dbffa47563404182304e0c10ea30b5e4d671b7173a34c00090140420f000000000001000000000000000000000000000000000000000000000000000000000000000002037061790973706c69745f76656301070000000000000000000000000000000000000000000000000000000000000002037375690353554900020100000101000e4d9313fb5b3f166bb6f2aea587edbe21fb1c094472ccd002f34b9d0633c71901280f4809b93ed87cc06f3397cd42a800a1034316e80d05443bce08e810817a96f50c0000000000002051c8eb5d437fb66c8d296e1cdf446c91be29fbc89f8430a2407acb0179a503880e4d9313fb5b3f166bb6f2aea587edbe21fb1c094472ccd002f34b9d0633c719e803000000000000e80300000000000000").unwrap();
    let tx = parse_tx(tx_bytes);
    assert_eq!(json!(tx.unwrap()).to_string(), "{\"V1\":{\"expiration\":\"None\",\"gas_data\":{\"budget\":1000,\"owner\":\"0x0e4d9313fb5b3f166bb6f2aea587edbe21fb1c094472ccd002f34b9d0633c719\",\"payment\":[[\"0x280f4809b93ed87cc06f3397cd42a800a1034316e80d05443bce08e810817a96\",3317,\"6WFidAcGkUzUEPvSChbMXg9AZUHj3gzJL4U7HkxJA43H\"]],\"price\":1000},\"kind\":{\"ProgrammableTransaction\":{\"commands\":[{\"MoveCall\":{\"arguments\":[{\"Input\":0},{\"Input\":1}],\"function\":\"split_vec\",\"module\":\"pay\",\"package\":\"0x0000000000000000000000000000000000000000000000000000000000000002\",\"type_arguments\":[{\"struct\":{\"address\":\"0000000000000000000000000000000000000000000000000000000000000002\",\"module\":\"sui\",\"name\":\"SUI\",\"type_args\":[]}}]}}],\"inputs\":[{\"Object\":{\"ImmOrOwnedObject\":[\"0xd833a8eabc697a0b2e23740aca7be9b0b9e1560a39d2f390cf2534e94429f91c\",3309,\"2gnMwEZqfMY1Q2Ree5iW3cAt7rhauevfBDY74SH3Ef1D\"]}},{\"Pure\":[1,64,66,15,0,0,0,0,0]}]}},\"sender\":\"0x0e4d9313fb5b3f166bb6f2aea587edbe21fb1c094472ccd002f34b9d0633c719\"}}");

    // SplitCoins
    let tx_bytes = hex::decode("00000200201ff915a5e9e32fdbe0135535b6c69a00a9809aaf7f7c0275d3239ca79db20d6400081027000000000000020200010101000101020000010000ebe623e33b7307f1350f8934beb3fb16baef0fc1b3f1b92868eec3944093886901a2e3e42930675d9571a467eb5d4b22553c93ccb84e9097972e02c490b4e7a22ab73200000000000020176c4727433105da34209f04ac3f22e192a2573d7948cb2fabde7d13a7f4f149ebe623e33b7307f1350f8934beb3fb16baef0fc1b3f1b92868eec39440938869e803000000000000640000000000000000").unwrap();
    let tx = parse_tx(tx_bytes);
    assert_eq!(json!(tx.unwrap()).to_string(), "{\"V1\":{\"expiration\":\"None\",\"gas_data\":{\"budget\":100,\"owner\":\"0xebe623e33b7307f1350f8934beb3fb16baef0fc1b3f1b92868eec39440938869\",\"payment\":[[\"0xa2e3e42930675d9571a467eb5d4b22553c93ccb84e9097972e02c490b4e7a22a\",12983,\"2aS93HVFS54TNKfAFunntFgoRMbMCzp1bDfqSTRPRYpg\"]],\"price\":1000},\"kind\":{\"ProgrammableTransaction\":{\"commands\":[{\"SplitCoins\":[\"GasCoin\",[{\"Input\":1}]]},{\"TransferObjects\":[[{\"Result\":0}],{\"Input\":0}]}],\"inputs\":[{\"Pure\":[31,249,21,165,233,227,47,219,224,19,85,53,182,198,154,0,169,128,154,175,127,124,2,117,211,35,156,167,157,178,13,100]},{\"Pure\":[16,39,0,0,0,0,0,0]}]}},\"sender\":\"0xebe623e33b7307f1350f8934beb3fb16baef0fc1b3f1b92868eec39440938869\"}}");
  }

  #[test]
  fn test_parse_msg() {
    let msg = parse_msg(hex::decode("0a48656c6c6f2c20537569").unwrap());
    assert_eq!(json!(msg.unwrap()).to_string(), "{\"message\":[72,101,108,108,111,44,32,83,117,105]}");
  }

}

'''
'''--- signer/Cargo.toml ---
[package]
name = "rcc_signer"
version = "0.1.1"
edition = "2021"
license = "Apache-2.0"
description = "signer rust implemenation for general purpose"
repository = "https://github.com/KeystoneHQ/rust-crypto-core/tree/master/signer"
readme = "README.md"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
serialport = "4.1.0"
hex = "0.4.3"
thiserror = "1.0"
bytes = "1"
sha1 = "0.10.5"
indexmap = "1.8.1"
k256 = { version = "0.11.3", features = ["ecdsa", "keccak256"] }
bs58 = "0.4.0"
zeroize = "1"
rsa = "0.7.0"
openssl = { version = "0.10", features = ["vendored"] }
rand_chacha = "0.3.1"
sha2 = "0.9"
base64 = "0.3.1"
ed25519-bip32-core = "0.1.1"
cryptoxide = "0.4.4"
bitcoin = "0.30.0"

[profile.test]
opt-level = 3
'''
'''--- signer/src/algorithm/bip32_ed25519.rs ---
use std::str::FromStr;
use bitcoin::bip32::{ChildNumber, DerivationPath};
use ed25519_bip32_core::{DerivationScheme, XPrv, XPub};
use cryptoxide::sha2::Sha512;
use cryptoxide::{pbkdf2, hmac};

pub fn get_icarus_master_key(entropy: &[u8], passphrase: &[u8]) -> XPrv {
    let mut hash = [0u8; 96];
    let digest = Sha512::new();
    let iter_count = 4096;
    pbkdf2::pbkdf2(
        &mut hmac::Hmac::new(digest, passphrase),
        entropy,
        iter_count,
        &mut hash,
    );
    XPrv::normalize_bytes_force3rd(hash)
}

pub fn get_extended_private_key(path: String, icarus_master_key: XPrv) -> Result<XPrv, String> {
    let path = normalize_path(&path);
    let derivation_path = DerivationPath::from_str(path.as_str())
        .map_err(|e| format!("{}", e))?;
    let childrens: Vec<ChildNumber> = derivation_path.into();
    let key = childrens
        .iter()
        .fold(icarus_master_key, |acc, cur| match cur {
            ChildNumber::Hardened { index } => acc.derive(DerivationScheme::V2, index + 0x80000000),
            ChildNumber::Normal { index } => acc.derive(DerivationScheme::V2, index.clone()),
        });
    Ok(key)
}

pub fn get_extended_public_key(path: String, icarus_master_key: XPrv) -> Result<XPub, String> {
    let xprv = get_extended_private_key(path, icarus_master_key)?;
    Ok(xprv.public())
}

pub fn sign_message(message: &[u8], path: String, ada_root_key: &[u8]) -> Result<[u8; 64], String> {
    let icarus_master_key = XPrv::from_slice_verified(ada_root_key).map_err(|e| e.to_string())?;
    _sign_message(message, path, icarus_master_key)
}

fn _sign_message(message: &[u8], path: String, icarus_master_key: XPrv) -> Result<[u8; 64], String> {
    let xprv = get_extended_private_key(path, icarus_master_key)?;
    let sig = xprv.sign::<Vec<u8>>(message);
    Ok(sig.to_bytes().clone())
}

pub fn normalize_path(path: &String) -> String {
    let mut p = path.to_lowercase();
    if !p.starts_with("m") {
        p = format!("{}{}", "m/", p);
    }
    p
}

'''
'''--- signer/src/algorithm/mod.rs ---
use crate::{KSError, SigningOption};

pub mod rsa;
pub mod secp256k1;
pub mod bip32_ed25519;

pub trait SecretKey {
    fn from_secret(secret: &[u8]) -> Result<Self, KSError> where Self: Sized;
    fn sign(&self, data: Vec<u8>, signing_option: Option<SigningOption>) -> Result<Vec<u8>, KSError>;
}
'''
'''--- signer/src/algorithm/rsa.rs ---
use bytes::BytesMut;
use openssl::hash::MessageDigest;
use openssl::pkey::PKey;
use rsa::{BigUint, pkcs8::{EncodePrivateKey}, PublicKeyParts, rand_core, RsaPrivateKey};
use sha2::{Digest, Sha256};
use rand_core::SeedableRng;
use rand_chacha::ChaCha20Rng;
use crate::algorithm::SecretKey;
use openssl::sign::{RsaPssSaltlen, Signer as OpensslSigner, Verifier};
use crate::{KSError, SigningOption};

pub const MODULUS_LENGTH: usize = 4096;
// secret = p || q || d || n
pub const PRIME_LENGTH_IN_BYTE: usize = MODULUS_LENGTH / 8 / 2;
pub const MODULUS_LENGTH_IN_BYTE: usize = MODULUS_LENGTH / 8;
pub const SECRET_LENGTH_IN_BYTE: usize = PRIME_LENGTH_IN_BYTE * 2 + MODULUS_LENGTH_IN_BYTE * 2;
pub const RSA_DERIVATION_PATH: &str = "m/44'/472'";

pub struct RSA {
    private_key: RsaPrivateKey,
}

impl SecretKey for RSA {
    fn from_secret(secret: &[u8]) -> Result<RSA, KSError> {
        if secret.len() != SECRET_LENGTH_IN_BYTE {
            return Err(KSError::GenerateSigningKeyError("invalid secret length".to_string()));
        }
        let mut p = BytesMut::with_capacity(PRIME_LENGTH_IN_BYTE);
        p.extend_from_slice(&secret[0..PRIME_LENGTH_IN_BYTE]);
        let mut q = BytesMut::with_capacity(PRIME_LENGTH_IN_BYTE);
        q.extend_from_slice(&secret[PRIME_LENGTH_IN_BYTE..PRIME_LENGTH_IN_BYTE * 2]);
        let mut d = BytesMut::with_capacity(MODULUS_LENGTH_IN_BYTE);
        d.extend_from_slice(&secret[PRIME_LENGTH_IN_BYTE * 2..PRIME_LENGTH_IN_BYTE * 2 + MODULUS_LENGTH_IN_BYTE]);
        let mut n = BytesMut::with_capacity(MODULUS_LENGTH_IN_BYTE);
        n.extend_from_slice(&secret[PRIME_LENGTH_IN_BYTE * 2 + MODULUS_LENGTH_IN_BYTE..PRIME_LENGTH_IN_BYTE * 2 + MODULUS_LENGTH_IN_BYTE * 2]);
        let e = vec![01, 00, 01];
        let private_key = RsaPrivateKey::from_components(
            BigUint::from_bytes_be(&n),
            BigUint::from_bytes_be(&e),
            BigUint::from_bytes_be(&d),
            [BigUint::from_bytes_be(&p), BigUint::from_bytes_be(&q)].to_vec(),
        ).map_err(|_| KSError::GenerateSigningKeyError("failed to compose rsa signing key".to_string()))?;
        Ok(Self {
            private_key
        })
    }

    fn sign(&self, data: Vec<u8>, signing_option: Option<SigningOption>) -> Result<Vec<u8>, KSError> {
        let private_key_der = self.private_key.to_pkcs8_der().map_err(|_| KSError::RSASignError)?;
        let pkey = PKey::private_key_from_der(private_key_der.as_bytes()).unwrap();
        let mut signer = OpensslSigner::new(MessageDigest::sha256(), &pkey).map_err(|_| KSError::RSASignError)?;
        signer.set_rsa_padding(openssl::rsa::Padding::PKCS1_PSS).map_err(|_| KSError::RSASignError)?;
        match signing_option {
            Some(SigningOption::RSA {salt_len})=>{
                let parsed_salt_len: i32 = salt_len.try_into().map_err(|_|KSError::RSASignError)?;
                signer
                    .set_rsa_pss_saltlen(RsaPssSaltlen::custom(parsed_salt_len))
                    .map_err(|_| KSError::RSASignError)?;
                signer.update(&data).map_err(|_| KSError::RSASignError)?;
                let signature = signer.sign_to_vec().map_err(|_| KSError::RSAVerifyError)?;
                Ok(signature)
            }
            _=>Err(KSError::RSASignError)
        }

    }
}

impl RSA {
    pub fn from_seed(seed: &[u8]) -> Result<Vec<u8>, KSError> {
        let mut intermediate;
        let mut hash = &seed[..];
        for _ in 0..2 {
            intermediate = Sha256::digest(&hash);
            hash = &intermediate[..];
        }
        let rng_seed: [u8; 32] = hash.try_into().map_err(|_| KSError::GenerateSigningKeyError("rsa generate chacha20 rng_seed failed".to_string()))?;
        let mut rng = ChaCha20Rng::from_seed(rng_seed);
        let private_key =
            RsaPrivateKey::new(&mut rng, MODULUS_LENGTH).map_err(|_| KSError::GenerateSigningKeyError("generate rsa private key failed".to_string()))?;
        let mut secret = BytesMut::with_capacity(PRIME_LENGTH_IN_BYTE * 2 + MODULUS_LENGTH_IN_BYTE * 2);
        secret.extend_from_slice(&private_key.primes()[0].to_bytes_be());
        secret.extend_from_slice(&private_key.primes()[1].to_bytes_be());
        secret.extend_from_slice(&private_key.d().to_bytes_be());
        secret.extend_from_slice(&private_key.n().to_bytes_be());
        Ok(secret.to_vec())
    }

    pub fn keypair_modulus(&self) -> Vec<u8> {
        self.private_key.n().to_bytes_be()
    }

    pub fn verify(&self, signature: &[u8], message: &[u8], signing_option: SigningOption) -> Result<(), KSError> {
        let private_key_der = self.private_key.to_pkcs8_der().map_err(|_| KSError::RSAVerifyError)?;
        let pkey = PKey::private_key_from_der(private_key_der.as_bytes()).map_err(|_| KSError::RSAVerifyError)?;
        let mut verifier = Verifier::new(MessageDigest::sha256(), &pkey).map_err(|_| KSError::RSAVerifyError)?;
        verifier.set_rsa_padding(openssl::rsa::Padding::PKCS1_PSS).map_err(|_| KSError::RSAVerifyError)?;
        match signing_option {
            SigningOption::RSA {salt_len}=>{
                let parsed_salt_len: i32 = salt_len.try_into().map_err(|_|KSError::RSASignError)?;
                verifier
                    .set_rsa_pss_saltlen(RsaPssSaltlen::custom(parsed_salt_len))
                    .map_err(|_| KSError::RSAVerifyError)?;
                verifier.update(&message).map_err(|_| KSError::RSAVerifyError)?;
                verifier.verify(&signature).map_err(|_| KSError::RSAVerifyError)?;
                Ok(())
            },
            _ => Err(KSError::RSAVerifyError)
        }

    }
}

#[cfg(all(test, target_os = "macos"))]
mod tests {
    use hex;
    use super::*;

    #[test]
    fn test_sign_verify_salt_zero() {
        let seed_bytes = hex::decode("5eb00bbddcf069084889a8ab9155568165f5c453ccb85e70811aaed6f6da5fc19a5ac40b389cd370d086206dec8aa6c43daea6690f20ad3d8d48b2d2ce9e38e4").unwrap();
        let secret = RSA::from_seed(&seed_bytes).unwrap();
        let rsa = RSA::from_secret(&secret).unwrap();
        let message = hex::decode("00f41cfa7bfad3d7b097fcc28ed08cb4ca7d0c544ec760cc6cc5c4f3780d0ec43cc011eaaab0868393c3c813ab8c04df").unwrap();
        let signing_option = SigningOption::RSA {salt_len: 0};
        let signature = rsa.sign(message.clone(), Some(signing_option)).unwrap();
        assert_eq!(hex::encode(signature.clone()), "a8e58c9aa9a74039f239f49adca18ea5d54b9d28852b7d39b098a96230ebe4b07bf1f66eea2ef3ee29ab912f90508917703ca9838f228b0f75014ea5d41101f7dff194d8086010aa92b6e6d04a56ed6cb7bd63c3dc15f833c0fcbeb03a16892ed715f7b178c20dbb6cd9923ddd0ab4b1c8753a554a8165ff34224fb630445582d3b588581deca41dbcf2144dcf10a362510178af9923e9f6cdf30dfaafa5642a20f777a4a9bff7170517d9a4347a2f0e360a38bf90a8b5d10f80f2581422798aa7b77d959f237a77d71b35558349e35f9c1193154bcf252d79171abeec6f37858584f878503af44a3553eb218b86dc31dfcca66dea947364580515bb2543d2403d53866ee16bba1b8e51ba060a5ecfef3ef4617d96fa3a3f67176621e638ad7e33bf08c56409f0ce01ef345ac4b49ba4fd94dbaf11b544f4ce089d9adcebf5b592afd2f8cecf22f21539975e50441fe3bf5f77d7d0fcfa2bd3c6e2cbf1bb59ed141b5c0f257be5958c5b46c9f08ec1e912b7fa6ff7182aa9010ce9f0cd6fc4845760a37f97197ea8ad3fa8a75b742e9ad61f877acd5771e7c43e0c75a422eb7d96153d4c561469c0f6011d0fe74f718b2db26894e3c5daf72784d34374c4dab78c3ff7619f883085a45efe1781cfcdb80b64b4c8aa96f86225144ca9430a499e96c607a77538ad7fb920fdd1126cdc8c5574ed3c2b1fb1dadac51ad4e13fdd9d");
        let result = rsa.verify(&signature.as_ref(), message.as_slice(), SigningOption::RSA {salt_len: 0});
        assert_eq!(result.ok(), Some(()));
    }

    #[test]
    fn test_sign_verify_salt_digest() {
        let seed_bytes = hex::decode("5eb00bbddcf069084889a8ab9155568165f5c453ccb85e70811aaed6f6da5fc19a5ac40b389cd370d086206dec8aa6c43daea6690f20ad3d8d48b2d2ce9e38e4").unwrap();
        let secret = RSA::from_seed(&seed_bytes).unwrap();
        let rsa = RSA::from_secret(&secret).unwrap();
        let message = hex::decode("00f41cfa7bfad3d7b097fcc28ed08cb4ca7d0c544ec760cc6cc5c4f3780d0ec43cc011eaaab0868393c3c813ab8c04df").unwrap();
        let signing_option = SigningOption::RSA {salt_len: 32};
        let signature = rsa.sign(message.clone(), Some(signing_option)).unwrap();
        let result = rsa.verify(&signature.as_ref(), message.as_slice(),SigningOption::RSA {salt_len: 32});
        assert_eq!(result.ok(), Some(()));
    }

    #[test]
    fn test_private_key_recover() {
        let d = hex::decode("542fd4042926629451ee9a4dace812428b6494acbf45370ddd2308c01e9ab9bf3974b561d5064f6f315f1a39632024bc18f2738c3acb11a1c1d25919477b0acc4f3e8b865aa50a9c3e781535079a06a668aa262ed675bb8ff979b93b5c877044528a0a89aa0a13855b37d96d1c213f237c2739a26aeca46427c517ecf0bc778becda2afb0be236988ed5d162c87ecca8db123af41129f8dfb3893f66293c64dd09d7313190ae66af5a2bef053ed25594a97bda6aa2c7eff560c815b9fe28ce2b68e89988a88322c34ef0e7e4c0822b2018545379900553d18c71de88bed451ef814c739296586d238bef428945ecb9f1eda9c098ba2345daf59229659b1588f2374438e978f94cf03ece881ded34790416d0f746b0701f7096aa74f381a21725dba3702b32670a5db7693763e95e751ae0ef5cd875ac38a4427dd716dd1d61d6c0e234ff64f80dbf0f1c2632883ac74b9e9387ad58e5ca928b7880d9844b513b448447c31b94d04160cfa83b0381b4e59b23deafd1cca01639e405bc494fa63758246eab4d25f94a6c2dfed72be6127217d7f806b05b573070850307a8c594233851a7efdb55e27f1624f2a9ca2a0c3e803024b1cbce919e7ae7e0b730d357a6ca62cd15978940f7998524404cb5837ccc93bca22caeb5156aa36abd92c83e047addef10d2e8f78e8c94a50fc305f9fe35a7f45f76271bd794b2f111db2eae41").unwrap();
        let n = hex::decode("c41a50ed2155a5740b45df8e3815774d6b8d193e5ad80c9efaaf6d6d0253f350c85becf39eb7056d75841f6a064acf8381383eceb218e16859ef72be7273321a2b4855b87bc6f14c734e2a9c90850c34a8a0a4279ac9be3186b086db5b302fb68176b4c1fee337456c42f972c7993f618fdedc0bf1658c2d59cf2c0c6ac31a61ac1260e0fd4a761ca3707e27611c14b4c6b6abe698c11009ddf5d1511ae47ea271079b6892d229a27d0822e0c7aa12a4cf7f7c28fe23d201eae2adb7f403c9c5a1762c2d8cc96898ce41fe529ab0ef8184e50063e6fc62e0a808e8602254c142c9e7f7e94e6ef2c767ac0e99810d09a44bfde8db46298bc0e25b4a333b4ef86cd7ce658ff661ab0d1789b603b8770a6b433851a91c8ff07a7a8a0767702f6887098ea34bf4a8309eaab9baadd16d45cdd9b1899b6a303a2dce23745cec9fc2ecd9735a66c77fdea1bfd4cdb2be7bfb407a4fd5d3405c3cb33b5316e16559f0c4bf0bc7d1a3ada78917217b289c4d75eb60e0396f03035fd8d553727c790189cfd8dabcee8a4ae6607925b9a27ff7ad7ede26b98f8acd2532cf3175693f3eede9989a0aeedbdb3ff14fec823017531aead4cd22733ab30dbce76cebcdac64424128d6eeff3cdc1825d7cdb7113e74db126e6d931544467c6979aa8d50ac803f36084ed7077f34acfcf3f77bb13d5ebb723fc5d3f45212d2dd6ef20ea757fb4c95").unwrap();
        let p = hex::decode("fdec3a1aee520780ca4058402d0422b5cd5950b715728f532499dd4bbcb68e5d44650818b43656782237316c4b0e2faa2b15c245fb82d10cf4f5b420f1f293ba75b2c8d8cef6ad899c34ce9de482cb248cc5ab802fd93094a63577590d812d5dd781846ef7d4f5d9018199c293966371c2349b0f847c818ec99caad800116e02085d35a39a913bc735327705161761ae30a4ec775f127fbb5165418c0fe08e54ae0aff8b2dab2b82d3b4b9c807de5fae116096075cf6d5b77450d743d743e7dcc56e7cafdcc555f228e57b363488e171d099876993e93e37a94983ccc12dba894c58ca84ac154c1343922c6a99008fabd0fa7010d3cc34f69884fec902984771").unwrap();
        let q = hex::decode("c5b50031ba31ab7c8b76453ce771f048b84fb89a3e4d44c222c3d8c823c683988b0dbf354d8b8cbf65f3db53e1365d3c5e043f0155b41d1ebeca6e20b2d6778600b5c98ffdba33961dae73b018307ef2bce9d217bbdf32964080f8db6f0cf7ef27ac825fcaf98d5143690a5d7e138f4875280ed6de581e66ed17f83371c268a073e4594814bcc88a33cbb4ec8819cc722ea15490312b85fed06e39274c4f73ac91c7f4d1b899729691cce616fb1a5feee1972456addcb51ac830e947fcc1b823468f0eefbaf195ac3b34f0baf96afc6fa77ee2e176081d6d91ce8c93c3d0f3547e48d059c9da447ba05ee3984703bebfd6d704b7f327ffaea7d0f63d0d3c6d65").unwrap();
        let e = base64::decode("AQAB").unwrap();
        let priv_key = RsaPrivateKey::from_components(
            BigUint::from_bytes_be(&n),
            BigUint::from_bytes_be(&e),
            BigUint::from_bytes_be(&d),
            [BigUint::from_bytes_be(&p), BigUint::from_bytes_be(&q)].to_vec(),
        );
        let seed = hex::decode("5eb00bbddcf069084889a8ab9155568165f5c453ccb85e70811aaed6f6da5fc19a5ac40b389cd370d086206dec8aa6c43daea6690f20ad3d8d48b2d2ce9e38e4").unwrap();
        let mut intermediate;
        let mut hash = seed.as_slice();

        for _ in 0..2 {
            intermediate = sha2::Sha256::digest(&hash);
            hash = &intermediate[..];
        }

        let rng_seed: [u8; 32] = hash.try_into().unwrap();
        let mut rng = ChaCha20Rng::from_seed(rng_seed);
        let expected =
            RsaPrivateKey::new(&mut rng, MODULUS_LENGTH);
        assert_eq!(priv_key == expected, true);
    }
}
'''
'''--- signer/src/algorithm/secp256k1.rs ---
use zeroize::Zeroizing;
use crate::algorithm::SecretKey;
use crate::{KSError, SigningOption};
use k256::ecdsa::SigningKey;
use crate::keymaster::hash_wraper::ShaWrapper;
use k256::ecdsa::{recoverable::Signature, signature::DigestSigner,digest::Digest};

impl SecretKey for SigningKey {
    fn from_secret(secret: &[u8]) -> Result<SigningKey, KSError> {
        let base58_key = String::from_utf8(secret.to_vec()).map_err(|_e| KSError::SEError("decode bs58 key error".to_string()))?;
        let key = bs58::decode(base58_key)
            .into_vec()
            .map_err(|_| KSError::SEError("decode bs58 key error".to_string()))?;
        let start = key.len() - (32 + 4);
        let end = key.len() - 4;
        let zeroize_private_key = Zeroizing::new(key[start..end].to_vec());
        let signing_key = SigningKey::from_bytes(zeroize_private_key.as_slice())
            .map_err(|_e| KSError::GenerateSigningKeyError("secp256k1".to_string()))?;
        Ok(signing_key)
    }

    fn sign(&self, data: Vec<u8>, signing_option: Option<SigningOption>) -> Result<Vec<u8>, KSError> {
        let mut hash_wrapper = ShaWrapper::new();
        hash_wrapper.update(data);
        let signature: Signature = self.try_sign_digest(hash_wrapper).map_err(|e| KSError::SignDataError(e.to_string()))?;
        Ok(signature.as_ref().to_vec())
    }
}
'''
'''--- signer/src/error.rs ---
use std::array::TryFromSliceError;
use std::convert::Infallible;
use thiserror::Error;

#[derive(Debug, Error)]
pub enum KSError {
    #[error("SerialManagerError:{0}")]
    SerialManagerError(String),

    #[error("SerialManager Timeout")]
    SerialTimeout,

    #[error("TVLError:{0}")]
    TVLError(String),

    #[error("TVLDeseriliazeError")]
    TVLDeseriliazeError,

    #[error("NoneSupportedCommandError")]
    NoneSupportedCommandError,

    #[error("SEError:{0}")]
    SEError(String),

    #[error("GenerateSigningKeyError: {0}")]
    GenerateSigningKeyError(String),

    #[error("RSASignError")]
    RSASignError,

    #[error("RSAVerifyError")]
    RSAVerifyError,

    #[error("SignDataError: {0}")]
    SignDataError(String),

    #[error("WriteSecretError: {0}")]
    WriteSecretError(String),

    #[error("GetPublicKeyError: {0}")]
    GetPublicKeyError(String),
}
'''
'''--- signer/src/keymaster/hash_wraper.rs ---
use core::fmt;
use digest::{
    core_api::{AlgorithmName, OutputSizeUser},
    typenum::U32,
    HashMarker, Output, Update,
};
use k256::ecdsa::{
    digest,
    digest::{FixedOutput, FixedOutputReset, Reset},
};

#[derive(Clone)]
pub struct Sha256VarWrapper {
    state: [u8; 32],
}

impl HashMarker for Sha256VarWrapper {}

impl Update for Sha256VarWrapper {
    #[inline]
    fn update(&mut self, data: &[u8]) {
        self.state.copy_from_slice(&data[..32]);
    }
}

impl Default for Sha256VarWrapper {
    fn default() -> Self {
        Self {
            state: Default::default(),
        }
    }
}

impl FixedOutput for Sha256VarWrapper {
    fn finalize_into(self, out: &mut Output<Self>) {
        out.copy_from_slice(&self.state);
    }
}

impl Reset for Sha256VarWrapper {
    fn reset(&mut self) {
        self.state = [0; 32];
    }
}

impl FixedOutputReset for Sha256VarWrapper {
    fn finalize_into_reset(&mut self, out: &mut Output<Self>) {
        out.copy_from_slice(&self.state);
        self.state = [0; 32];
    }
}

impl OutputSizeUser for Sha256VarWrapper {
    type OutputSize = U32;
}

impl AlgorithmName for Sha256VarWrapper {
    #[inline]
    fn write_alg_name(f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str("Sha256")
    }
}

impl fmt::Debug for Sha256VarWrapper {
    #[inline]
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str("Sha256VarWrapper { ... }")
    }
}

pub type ShaWrapper = Sha256VarWrapper;
'''
'''--- signer/src/keymaster/local.rs ---
use super::{KeyMaster, SigningAlgorithm, hash_wraper::ShaWrapper};
use crate::error::KSError;
use k256::ecdsa::{recoverable::Signature, signature::DigestSigner, SigningKey, digest::Digest};
use openssl::sign::RsaPssSaltlen;
use zeroize::Zeroizing;
use crate::SigningAlgorithm::RSA;
use crate::{algorithm, SigningOption};
use crate::algorithm::SecretKey;
use crate::keymaster::se::GetKeyType;

pub struct Mini;

impl KeyMaster for Mini {
    fn generate_entropy(&self, length: super::EntropyLength) -> Result<Vec<u8>, KSError> {
        Err(KSError::SEError("this function is not supported for now".to_string()))
    }

    fn setup_ada_root_key(&self, mnemonic_id: u8, password: String, passphrase: String) -> Result<bool, KSError> {
        Err(KSError::SEError("this function is not supported for now".to_string()))
    }

    fn get_ada_extended_public_key(&self, mnemonic_id: u8, password: String, path: String) -> Result<String, KSError> {
        Err(KSError::SEError("this function is not supported for now".to_string()))
    }

    fn get_rsa_public_key(&self, mnemonic_id: u8, password: String) -> Result<Vec<u8>, KSError> {
        Ok(vec![])
    }

    fn get_ada_root_key(&self, mnemonic_id: u8, password: Vec<u8>) -> Result<Vec<u8>, KSError> {
        Ok(vec![])
    }

    fn set_ada_root_key(
        &self,
        mnemonic_id: u8,
        password: String,
        secret: Vec<u8>,
    ) -> Result<bool, KSError> {
        Ok(true)
    }

    fn sign_data(
        &self,
        mnemonic_id: u8,
        password: String,
        data: Vec<u8>,
        algo: super::SigningAlgorithm,
        derivation_path: String,
        signing_option: Option<SigningOption>,
    ) -> Result<Vec<u8>, KSError> {
        let curve_tag = match algo {
            SigningAlgorithm::Secp256k1 => 0u8,
            SigningAlgorithm::Secp256R1 => 1u8,
            SigningAlgorithm::Ed25519 => 2u8,
            SigningAlgorithm::SR25519 => 3u8,
            SigningAlgorithm::RSA => 5u8,
        };
        // only for testing purpose
        match algo {
            SigningAlgorithm::Secp256k1 => {
                let private_key = hex::decode("78707276413436797257796b4668334c6a4d486e3165716b374138574e4274374a7a4a714565425831524e7a32627839446974753670654b374d4a5752387466585571506a574e754c374c774c76706864676b5753684e705958694a42757669396167784a555769484748746f4e6b").map_err(|_e| KSError::SEError("hex key decode error".to_string()))?;
                let zeroize_secret = Zeroizing::new(private_key);
                let secp245k1 = SigningKey::from_secret(zeroize_secret.as_slice())?;
                let signature = secp245k1.sign(data, None)?;
                Ok(signature)
            }
            SigningAlgorithm::RSA => {
                // get rsa secret from SE
                let secret = hex::decode("fdec3a1aee520780ca4058402d0422b5cd5950b715728f532499dd4bbcb68e5d44650818b43656782237316c4b0e2faa2b15c245fb82d10cf4f5b420f1f293ba75b2c8d8cef6ad899c34ce9de482cb248cc5ab802fd93094a63577590d812d5dd781846ef7d4f5d9018199c293966371c2349b0f847c818ec99caad800116e02085d35a39a913bc735327705161761ae30a4ec775f127fbb5165418c0fe08e54ae0aff8b2dab2b82d3b4b9c807de5fae116096075cf6d5b77450d743d743e7dcc56e7cafdcc555f228e57b363488e171d099876993e93e37a94983ccc12dba894c58ca84ac154c1343922c6a99008fabd0fa7010d3cc34f69884fec902984771c5b50031ba31ab7c8b76453ce771f048b84fb89a3e4d44c222c3d8c823c683988b0dbf354d8b8cbf65f3db53e1365d3c5e043f0155b41d1ebeca6e20b2d6778600b5c98ffdba33961dae73b018307ef2bce9d217bbdf32964080f8db6f0cf7ef27ac825fcaf98d5143690a5d7e138f4875280ed6de581e66ed17f83371c268a073e4594814bcc88a33cbb4ec8819cc722ea15490312b85fed06e39274c4f73ac91c7f4d1b899729691cce616fb1a5feee1972456addcb51ac830e947fcc1b823468f0eefbaf195ac3b34f0baf96afc6fa77ee2e176081d6d91ce8c93c3d0f3547e48d059c9da447ba05ee3984703bebfd6d704b7f327ffaea7d0f63d0d3c6d65542fd4042926629451ee9a4dace812428b6494acbf45370ddd2308c01e9ab9bf3974b561d5064f6f315f1a39632024bc18f2738c3acb11a1c1d25919477b0acc4f3e8b865aa50a9c3e781535079a06a668aa262ed675bb8ff979b93b5c877044528a0a89aa0a13855b37d96d1c213f237c2739a26aeca46427c517ecf0bc778becda2afb0be236988ed5d162c87ecca8db123af41129f8dfb3893f66293c64dd09d7313190ae66af5a2bef053ed25594a97bda6aa2c7eff560c815b9fe28ce2b68e89988a88322c34ef0e7e4c0822b2018545379900553d18c71de88bed451ef814c739296586d238bef428945ecb9f1eda9c098ba2345daf59229659b1588f2374438e978f94cf03ece881ded34790416d0f746b0701f7096aa74f381a21725dba3702b32670a5db7693763e95e751ae0ef5cd875ac38a4427dd716dd1d61d6c0e234ff64f80dbf0f1c2632883ac74b9e9387ad58e5ca928b7880d9844b513b448447c31b94d04160cfa83b0381b4e59b23deafd1cca01639e405bc494fa63758246eab4d25f94a6c2dfed72be6127217d7f806b05b573070850307a8c594233851a7efdb55e27f1624f2a9ca2a0c3e803024b1cbce919e7ae7e0b730d357a6ca62cd15978940f7998524404cb5837ccc93bca22caeb5156aa36abd92c83e047addef10d2e8f78e8c94a50fc305f9fe35a7f45f76271bd794b2f111db2eae41c41a50ed2155a5740b45df8e3815774d6b8d193e5ad80c9efaaf6d6d0253f350c85becf39eb7056d75841f6a064acf8381383eceb218e16859ef72be7273321a2b4855b87bc6f14c734e2a9c90850c34a8a0a4279ac9be3186b086db5b302fb68176b4c1fee337456c42f972c7993f618fdedc0bf1658c2d59cf2c0c6ac31a61ac1260e0fd4a761ca3707e27611c14b4c6b6abe698c11009ddf5d1511ae47ea271079b6892d229a27d0822e0c7aa12a4cf7f7c28fe23d201eae2adb7f403c9c5a1762c2d8cc96898ce41fe529ab0ef8184e50063e6fc62e0a808e8602254c142c9e7f7e94e6ef2c767ac0e99810d09a44bfde8db46298bc0e25b4a333b4ef86cd7ce658ff661ab0d1789b603b8770a6b433851a91c8ff07a7a8a0767702f6887098ea34bf4a8309eaab9baadd16d45cdd9b1899b6a303a2dce23745cec9fc2ecd9735a66c77fdea1bfd4cdb2be7bfb407a4fd5d3405c3cb33b5316e16559f0c4bf0bc7d1a3ada78917217b289c4d75eb60e0396f03035fd8d553727c790189cfd8dabcee8a4ae6607925b9a27ff7ad7ede26b98f8acd2532cf3175693f3eede9989a0aeedbdb3ff14fec823017531aead4cd22733ab30dbce76cebcdac64424128d6eeff3cdc1825d7cdb7113e74db126e6d931544467c6979aa8d50ac803f36084ed7077f34acfcf3f77bb13d5ebb723fc5d3f45212d2dd6ef20ea757fb4c95").map_err(|_e| KSError::SEError("hex key decode error".to_string()))?;
                let zeroize_secret = Zeroizing::new(secret);
                let rsa = algorithm::rsa::RSA::from_secret(zeroize_secret.as_slice())?;
                match signing_option {
                    Some(SigningOption::RSA { salt_len }) => {
                        let signature = rsa.sign(data, Some(SigningOption::RSA { salt_len }))?;
                        Ok(signature)
                    }
                    _ => Err(KSError::RSASignError)
                }
            }
            _ => Err(KSError::SEError("signing algo is not supported".to_string()))
        }
    }

    fn get_version(&self) -> Result<Vec<u8>, KSError> {
        Err(KSError::SEError("this function is not supported for now".to_string()))
    }
}

'''
'''--- signer/src/keymaster/mod.rs ---
use crate::algorithm;
use crate::error::KSError;
use openssl::sign::RsaPssSaltlen;

pub(crate) mod hash_wraper;
pub(crate) mod local;
pub(crate) mod se;

pub enum EntropyLength {
    Short(u32),
    Long(u32),
}

#[derive(Clone, Copy)]
pub enum SigningAlgorithm {
    Secp256k1,
    Secp256R1,
    Ed25519,
    SR25519,
    RSA,
}

#[derive(Clone, Copy)]
pub enum SigningOption {
    RSA { salt_len: i32 },
    ADA
}

pub trait KeyMaster {
    fn generate_entropy(&self, length: EntropyLength) -> Result<Vec<u8>, KSError>;

    fn setup_ada_root_key(&self, mnemonic_id: u8, password: String, passphrase: String) -> Result<bool, KSError>;

    fn get_ada_extended_public_key(&self, mnemonic_id: u8, password: String, path: String) -> Result<String, KSError>;

    fn get_rsa_public_key(&self, mnemonic_id: u8, password: String) -> Result<Vec<u8>, KSError>;

    fn get_ada_root_key(&self, mnemonic_id: u8, password: Vec<u8>) -> Result<Vec<u8>, KSError>;

    fn set_ada_root_key(
        &self,
        mnemonic_id: u8,
        password: String,
        secret: Vec<u8>,
    ) -> Result<bool, KSError>;

    fn sign_data(
        &self,
        mnemonic_id: u8,
        password: String,
        data: Vec<u8>,
        algo: SigningAlgorithm,
        derivation_path: String,
        signing_option: Option<SigningOption>,
    ) -> Result<Vec<u8>, KSError>;

    fn get_version(&self) -> Result<Vec<u8>, KSError>;
}

'''
'''--- signer/src/keymaster/se/command.rs ---
use bytes::{Buf, BufMut, Bytes, BytesMut};
use indexmap::IndexMap;

use super::tags::{methods, COMMAND_TAG, RESPONSE_TAG};
use super::tvl::{Packet, TVL};

#[derive(Default)]
pub struct CommandParams {
    pub wallet_id: Option<u8>,
    pub path: Option<String>,
    pub auth_token: Option<Vec<u8>>,
    pub password: Option<Vec<u8>>,
    pub curve: Option<u8>,
    pub hash: Option<[u8; 128]>,
    pub is_master_seed: Option<bool>,
    pub is_rsa_secret: Option<bool>,
    pub is_entropy: Option<bool>,
    pub is_ada_root: Option<bool>,
    pub secret: Option<Vec<u8>>,
}

pub trait CommandBuilder {
    fn build(params: Option<CommandParams>) -> Option<Command>;
}

pub(crate) struct GetFirmwareStatusCommand;

impl CommandBuilder for GetFirmwareStatusCommand {
    fn build(params: Option<CommandParams>) -> Option<Command> {
        let mut builder = PacketBuilder::new();
        builder.add_command_id(methods::GET_FIRMWARE_STATUS_TAG);
        let packet = builder.build();
        return Some(Command {
            packet,
            tag: methods::GET_FIRMWARE_STATUS_TAG,
        });
    }
}

pub struct GenerateEntropyCommand;

impl CommandBuilder for GenerateEntropyCommand {
    fn build(params: Option<CommandParams>) -> Option<Command> {
        let mut builder = PacketBuilder::new();
        builder.add_command_id(methods::GET_RANDOM_ENTROPY_TAG);
        builder.add_payload(methods::ENTROPY_TYPE_TAG, &[01, 00]);
        builder.add_payload(methods::ENTROPY_CHECKSUM_TAG, &[00]);
        let packet = builder.build();
        return Some(Command {
            packet,
            tag: methods::GET_RANDOM_ENTROPY_TAG,
        });
    }
}

pub struct GETKeyCommand;

impl CommandBuilder for GETKeyCommand {
    fn build(params: Option<CommandParams>) -> Option<Command> {
        let params = params?;
        let id = params.wallet_id?;
        let path = params.path?;
        let curve = params.curve?;

        let mut builder = PacketBuilder::new();
        builder.add_command_id(methods::GET_KEY_TAG);
        builder.add_payload(methods::CURVE_TAG, &[curve]);
        builder.add_payload(methods::WALLET_FLAG_TAG, &[id]);
        let path_bytes = path.as_bytes();
        builder.add_payload(methods::PATH_TAG, path_bytes);
        match params.is_master_seed {
            Some(true) => builder.add_payload(methods::MASTER_SEED_FLAG_TAG, &[00]),
            _ => (),
        };

        match params.is_entropy {
            Some(true) => builder.add_payload(methods::CURRENT_SECRET, &[00]),
            _ => (),
        };

        match params.is_rsa_secret {
            Some(true) => builder.add_payload(methods::RSA_SECRET_FLAG_TAG, &[00]),
            _ => (),
        };
        match params.auth_token {
            Some(auth_token) => builder.add_payload(methods::AUTH_TOKEN_TAG, &auth_token),
            None => (),
        };

        match params.is_ada_root {
            Some(true) => builder.add_payload(methods::ADA_FLAG_TAG, &[00]),
            _ => (),
        };

        let packet = builder.build();
        return Some(Command {
            packet,
            tag: methods::GET_KEY_TAG,
        });
    }
}

pub struct SignTxCommand;

impl CommandBuilder for SignTxCommand {
    fn build(params: Option<CommandParams>) -> Option<Command> {
        let params = params?;
        let id = params.wallet_id?;
        let path = params.path?;
        let auth_token = params.auth_token?;
        let curve = params.curve?;
        let tx_hash = params.hash?;

        let mut builder = PacketBuilder::new();
        builder.add_command_id(methods::SIGN_TAG);
        let path_bytes = path.as_bytes();
        builder.add_payload(methods::PATH_TAG, path_bytes);
        builder.add_payload(methods::CURVE_TAG, &[00]);
        builder.add_payload(methods::WALLET_FLAG_TAG, &[00]);

        builder.add_payload(methods::AUTH_TOKEN_TAG, &auth_token);
        builder.add_payload(methods::TX_HASH_TAG, &tx_hash);
        let packet = builder.build();
        return Some(Command {
            packet,
            tag: methods::SIGN_TAG,
        });
    }
}

pub struct GenerateTokenCommand;

impl CommandBuilder for GenerateTokenCommand {
    fn build(params: Option<CommandParams>) -> Option<Command> {
        let params = params?;
        let password = params.password?;
        let password_slices = password.as_slice();
        let mut builder = PacketBuilder::new();
        builder.add_command_id(methods::VERIFY_USER_PASSWORD);
        builder.add_payload(methods::CURRENT_PASSWORD, password_slices);
        builder.add_payload(methods::NEED_TOKEN_TAG, &[01]);
        let packet = builder.build();
        return Some(Command {
            packet,
            tag: methods::VERIFY_USER_PASSWORD,
        });
    }
}

pub struct ClearTokenCommand;

impl CommandBuilder for ClearTokenCommand {
    fn build(params: Option<CommandParams>) -> Option<Command> {
        let mut builder = PacketBuilder::new();
        builder.add_command_id(methods::CLEAR_TOKEN_TAG);
        let packet = builder.build();
        return Some(Command {
            packet,
            tag: methods::CLEAR_TOKEN_TAG,
        });
    }
}

pub struct SetSecretCommand;

impl CommandBuilder for SetSecretCommand {
    fn build(params: Option<CommandParams>) -> Option<Command> {
        let params = params?;
        let password = params.password?;
        let password_slices = password.as_slice();
        let secret = params.secret?;
        let secret_slices = secret.as_slice();
        let mut builder = PacketBuilder::new();
        builder.add_command_id(methods::SET_SECRET_TAG);
        builder.add_payload(methods::CURRENT_PASSWORD, password_slices);

        match params.is_ada_root {
            Some(true) => builder.add_payload(methods::WRITE_ADA_ROOT_FLAG, secret_slices),
            _ => (),
        };

        match params.is_rsa_secret {
            Some(true) => builder.add_payload(methods::WRITE_RSA_SECRET_FLAG, secret_slices),
            _ => (),
        };

        let packet = builder.build();
        return Some(Command {
            packet,
            tag: methods::SET_SECRET_TAG,
        });
    }
}

fn build_packet(tag: u16) -> Packet {
    let mut mm = BytesMut::new();
    mm.put_u16(tag);
    let bytes = mm.freeze();
    let tvl = TVL::new(COMMAND_TAG, 2, bytes);
    let mut payloads: IndexMap<u16, TVL> = IndexMap::new();
    payloads.insert(1, tvl);
    Packet::new(payloads)
}

struct PacketBuilder {
    payloads: IndexMap<u16, TVL>,
}

impl PacketBuilder {
    pub fn new() -> Self {
        Self {
            payloads: IndexMap::new(),
        }
    }

    pub fn add_command_id(&mut self, tag: u16) {
        let mut mm = BytesMut::new();
        mm.put_u16(tag);
        let bytes = mm.freeze();
        let tvl = TVL::new(COMMAND_TAG, 2, bytes);
        self.payloads.insert(COMMAND_TAG, tvl);
    }

    pub fn add_payload(&mut self, tag: u16, value: &[u8]) {
        let mm = Bytes::copy_from_slice(value);
        let length = value.len() as u16;
        let tvl = TVL::new(tag, length, mm);
        self.payloads.insert(tag, tvl);
    }

    pub fn build(self) -> Packet {
        Packet::new(self.payloads)
    }
}

pub fn parse_result(packet: &Packet, request_tag: u16) -> bool {
    if let Some(tag) = packet.payloads.get(&COMMAND_TAG) {
        let mut tmp = Bytes::copy_from_slice(tag.value.chunk());
        if tmp.get_uint(tmp.len()) == request_tag.into() {
            if let Some(v) = packet.payloads.get(&RESPONSE_TAG) {
                let mut tmp = Bytes::copy_from_slice(v.value.chunk());
                if tmp.get_uint(tmp.len()) == 0 {
                    return true;
                }
            }
        }
    }

    return false;
}

pub struct Command {
    packet: Packet,
    pub tag: u16,
}

impl Command {
    pub fn to_vec(&self) -> Vec<u8> {
        self.packet.to_vec()
    }
}

#[cfg(all(test, target_os = "macos"))]
mod tests {
    use super::*;

    #[test]
    fn it_should_turn_right_get_firmware_command() {
        let command = GetFirmwareStatusCommand::build(None).unwrap();
        assert_eq!(
            command.to_vec(),
            vec![02, 00, 00, 06, 00, 01, 00, 02, 01, 02, 03, 07]
        )
    }

    #[test]
    fn it_should_turn_right_get_entropy_command() {
        let command = GenerateEntropyCommand::build(None).unwrap();
        assert_eq!(
            command.to_vec(),
            vec![2, 0, 0, 17, 0, 1, 0, 2, 3, 1, 2, 1, 0, 2, 1, 0, 3, 11, 0, 1, 0, 3, 24]
        )
    }
}

'''
'''--- signer/src/keymaster/se/mod.rs ---
mod command;
mod serial_manager;
mod tags;
mod tvl;

use std::convert::TryFrom;

use self::command::CommandBuilder;
use self::tags::RESPONSE_TAG;
use bytes::BytesMut;
use ed25519_bip32_core::XPrv;
use zeroize::Zeroizing;

use super::KeyMaster;
use super::SigningAlgorithm;
use crate::algorithm;
use crate::algorithm::SecretKey;
use crate::error::KSError;
use crate::keymaster::se::command::SetSecretCommand;
use crate::keymaster::SigningOption;
use command::{
    parse_result, ClearTokenCommand, Command, CommandParams, GETKeyCommand, GenerateEntropyCommand,
    GenerateTokenCommand, GetFirmwareStatusCommand, SignTxCommand,
};
use k256::ecdsa::SigningKey;
use serial_manager::SerialManager;
use tags::result;
use tvl::Packet;

pub struct SecureElement {
    version: String,
    port: String,
}

pub enum GetKeyType {
    MasterSeed,
    RSASecret,
    ExtendedPrivateKey,
    ExtendedPublicKey,
    Entropy,
    ADARootKey,
}

impl SecureElement {
    pub fn new(port_name: String) -> Self {
        SecureElement {
            version: "1.0.0".to_string(),
            port: port_name,
        }
    }

    fn get_se_result(&self, command: Command, response: u16) -> Result<Vec<u8>, KSError> {
        let timeout = 100000;
        let sem = SerialManager::new(&self.port, timeout);
        let data = sem.send_data(command.to_vec())?;
        let result_packet = Packet::try_from(data)?;

        if parse_result(&result_packet, command.tag) {
            if let Some(v) = result_packet.payloads.get(&response) {
                return Ok(v.value.to_vec());
            } else {
                Err(KSError::SEError("required field is missing".to_string()))
            }
        } else {
            Err(KSError::SEError("error from chip!".to_string()))
        }
    }

    fn set_se_result(&self, command: Command) -> Result<(), KSError> {
        let timeout = 100000;
        let sem = SerialManager::new(&self.port, timeout);
        let data = sem.send_data(command.to_vec())?;
        let result_packet = Packet::try_from(data)?;
        Ok(())
    }

    fn set_rsa_secret(&self, secret: Vec<u8>, password: String) -> Result<(), KSError> {
        let password_bytes = hex::decode(&password)
            .map_err(|_| KSError::WriteSecretError("decode password bytes failed".to_string()))?;
        let params = CommandParams {
            secret: Some(secret),
            password: Some(password_bytes),
            is_rsa_secret: Some(true),
            ..Default::default()
        };
        self.set_se_result(
            SetSecretCommand::build(Some(params))
                .ok_or(KSError::SEError("compose command error".to_string()))?,
        )
    }

    fn get_key(
        &self,
        mnemonic_id: u8,
        path: String,
        auth_token: Option<Vec<u8>>,
        algo: SigningAlgorithm,
        key_type: GetKeyType,
    ) -> Result<Vec<u8>, KSError> {
        let curve_tag = match algo {
            SigningAlgorithm::Secp256k1 => 0u8,
            SigningAlgorithm::Secp256R1 => 1u8,
            SigningAlgorithm::Ed25519 => 2u8,
            SigningAlgorithm::SR25519 => 3u8,
            SigningAlgorithm::RSA => 5u8,
        };
        let mut result_tag: u16 = result::EXT_KET;

        let mut params = CommandParams {
            wallet_id: Some(mnemonic_id),
            path: Some(path),
            auth_token,
            curve: Some(curve_tag),
            ..Default::default()
        };
        match key_type {
            GetKeyType::MasterSeed => {
                params = CommandParams {
                    is_master_seed: Some(true),
                    ..params
                };
                result_tag = result::EXT_MASTER_SEED;
            }
            GetKeyType::RSASecret => {
                params = CommandParams {
                    is_rsa_secret: Some(true),
                    ..params
                };
                result_tag = result::EXT_RSA_SECRET;
            }
            GetKeyType::ExtendedPrivateKey | GetKeyType::ExtendedPublicKey => {}
            GetKeyType::Entropy => {
                params = CommandParams {
                    is_entropy: Some(true),
                    ..params
                };
                result_tag = result::EXT_ENTROPY
            }
            GetKeyType::ADARootKey => {
                params = CommandParams {
                    is_ada_root: Some(true),
                    ..params
                };
                result_tag = result::EXT_ADA_ROOT_KEY
            }
            _ => Err(KSError::SEError(
                "get key type is not supported".to_string(),
            ))?,
        };
        let key = self.get_se_result(
            GETKeyCommand::build(Some(params))
                .ok_or(KSError::SEError("compose command error".to_string()))?,
            result_tag,
        )?;

        Ok(key)
    }

    fn test_sign(
        &self,
        mnemonic_id: u8,
        path: String,
        auth_token: Vec<u8>,
        curve: u8,
        tx_hash: [u8; 128],
    ) -> Result<Vec<u8>, KSError> {
        let params = CommandParams {
            wallet_id: Some(mnemonic_id),
            path: Some(path),
            auth_token: Some(auth_token),
            curve: Some(curve),
            hash: Some(tx_hash),
            ..Default::default()
        };

        self.get_se_result(
            SignTxCommand::build(Some(params))
                .ok_or(KSError::SEError("compose command error".to_string()))?,
            result::EXT_KET,
        )
    }

    pub(crate) fn generate_token(&self, password: String) -> Result<Vec<u8>, KSError> {
        let password_bytes =
            hex::decode(&password).map_err(|_| KSError::SEError(format!("invalid password")))?;
        let params = CommandParams {
            password: Some(password_bytes),
            ..Default::default()
        };
        let command = GenerateTokenCommand::build(Some(params))
            .ok_or(KSError::SEError("compose command error".to_string()))?;
        self.get_se_result(command, result::AUTH_TOKEN)
    }

    pub(crate) fn clear_token(&self) -> Result<bool, KSError> {
        let result = self.get_se_result(
            ClearTokenCommand::build(None)
                .ok_or(KSError::SEError("compose command error".to_string()))?,
            RESPONSE_TAG,
        )?;
        let result_value = u16::from_ne_bytes(
            result[0..2]
                .try_into()
                .map_err(|_| KSError::SEError("process response tvl result error".to_string()))?,
        );
        if result_value == 0 {
            return Ok(true);
        } else {
            return Ok(false);
        }
    }

    pub fn get_entropy(&self, mnemonic_id: u8, auth_token: Vec<u8>) -> Result<Vec<u8>, KSError> {
        const FAKE_PATH: &str = "m'/1'";
        // get entropy
        let entropy = self.get_key(
            mnemonic_id,
            FAKE_PATH.to_string(),
            Some(auth_token),
            SigningAlgorithm::Secp256k1,
            GetKeyType::Entropy,
        )?;
        Ok(entropy)
    }
}

impl KeyMaster for SecureElement {
    fn generate_entropy(&self, length: super::EntropyLength) -> Result<Vec<u8>, KSError> {
        self.get_se_result(
            GenerateEntropyCommand::build(None)
                .ok_or(KSError::SEError("compose command error".to_string()))?,
            result::ENTROPY,
        )
    }

    fn setup_ada_root_key(
        &self,
        mnemonic_id: u8,
        password: String,
        passphrase: String,
    ) -> Result<bool, KSError> {
        let zeroize_password = Zeroizing::new(password.clone());
        let token = self.generate_token(zeroize_password.as_str().to_string())?;
        let entropy = self.get_entropy(mnemonic_id, token)?;
        let passphrase = passphrase.as_bytes();
        let root_key = algorithm::bip32_ed25519::get_icarus_master_key(&entropy, passphrase)
            .as_ref()
            .to_vec();
        self.set_ada_root_key(mnemonic_id, zeroize_password.as_str().to_string(), root_key)?;
        self.clear_token()?;
        Ok(true)
    }

    fn get_ada_extended_public_key(
        &self,
        mnemonic_id: u8,
        password: String,
        path: String,
    ) -> Result<String, KSError> {
        let zeroize_password = Zeroizing::new(password.clone());
        let token = self.generate_token(zeroize_password.as_str().to_string())?;
        let root_key = self.get_ada_root_key(mnemonic_id, token)?;
        let root_xprv = XPrv::from_slice_verified(&root_key)
            .map_err(|e| KSError::GetPublicKeyError(e.to_string()))?;
        let xpub = algorithm::bip32_ed25519::get_extended_public_key(path, root_xprv)
            .map_err(|e| KSError::GetPublicKeyError(e))?;
        self.clear_token()?;
        Ok(xpub.to_string())
    }

    fn get_rsa_public_key(&self, mnemonic_id: u8, password: String) -> Result<Vec<u8>, KSError> {
        let zeroize_password = Zeroizing::new(password);
        let mut public_key = BytesMut::with_capacity(512);
        let token = self.generate_token(zeroize_password.as_str().to_string())?;
        // get master_seed
        let master_seed = self.get_key(
            mnemonic_id,
            algorithm::rsa::RSA_DERIVATION_PATH.to_string(),
            Some(token),
            SigningAlgorithm::RSA,
            GetKeyType::MasterSeed,
        )?;
        let zeroize_master_seed = Zeroizing::new(master_seed);
        let secret =
            algorithm::rsa::RSA::from_seed(zeroize_master_seed.as_slice()).map_err(|_| {
                KSError::GenerateSigningKeyError("init rsa key pair failed".to_string())
            })?;
        // save rsa secret
        self.set_rsa_secret(secret.clone(), zeroize_password.as_str().to_string())?;
        let rsa = algorithm::rsa::RSA::from_secret(&secret)?;
        public_key.extend_from_slice(&rsa.keypair_modulus());
        Ok(public_key.to_vec())
    }

    fn get_ada_root_key(&self, mnemonic_id: u8, auth_token: Vec<u8>) -> Result<Vec<u8>, KSError> {
        const ADA_FAKE_PATH: &str = "m/1852'";
        // get root_key
        let ada_root_key = self.get_key(
            mnemonic_id,
            ADA_FAKE_PATH.to_string(),
            Some(auth_token),
            SigningAlgorithm::Ed25519,
            GetKeyType::ADARootKey,
        )?;
        Ok(ada_root_key)
    }

    fn set_ada_root_key(
        &self,
        mnemonic_id: u8,
        password: String,
        secret: Vec<u8>,
    ) -> Result<bool, KSError> {
        let password_bytes = hex::decode(&password)
            .map_err(|_| KSError::WriteSecretError("decode password bytes failed".to_string()))?;
        let params = CommandParams {
            secret: Some(secret),
            password: Some(password_bytes),
            is_ada_root: Some(true),
            ..Default::default()
        };

        let command = SetSecretCommand::build(Some(params))
            .ok_or(KSError::SEError("compose command error".to_string()))?;
        let result = self.get_se_result(command, RESPONSE_TAG)?;
        let result_value = u16::from_ne_bytes(
            result[0..2]
                .try_into()
                .map_err(|_| KSError::SEError("process response tvl result error".to_string()))?,
        );
        if result_value == 0 {
            return Ok(true);
        } else {
            return Ok(false);
        }
    }

    fn sign_data(
        &self,
        mnemonic_id: u8,
        password: String,
        data: Vec<u8>,
        algo: super::SigningAlgorithm,
        derivation_path: String,
        signing_option: Option<SigningOption>,
    ) -> Result<Vec<u8>, KSError> {
        // get key from se
        let auth_token = hex::decode(password).map_err(|_e| KSError::SEError("".to_string()))?;
        if let (SigningAlgorithm::Ed25519, (Some(SigningOption::ADA))) = (algo, signing_option) {
            // sign with bip32_ed25519
            let ada_root_key = self.get_ada_root_key(mnemonic_id, auth_token)?;
            let signature =
                algorithm::bip32_ed25519::sign_message(&data, derivation_path, &ada_root_key)
                    .map_err(|e| KSError::SignDataError(e))?;
            return Ok(signature.to_vec());
        }
        match algo {
            SigningAlgorithm::Secp256k1 => {
                let private_key = self.get_key(
                    mnemonic_id,
                    derivation_path,
                    Some(auth_token),
                    algo,
                    GetKeyType::ExtendedPrivateKey,
                )?;
                let zeroize_secret = Zeroizing::new(private_key);
                let secp256k1 = SigningKey::from_secret(zeroize_secret.as_slice())?;
                let signature = secp256k1.sign(data, None)?;
                Ok(signature)
            }
            SigningAlgorithm::RSA => {
                // get rsa secret from SE
                let secret = self.get_key(
                    mnemonic_id,
                    derivation_path,
                    Some(auth_token),
                    algo,
                    GetKeyType::RSASecret,
                )?;
                let zeroize_secret = Zeroizing::new(secret);
                let rsa = algorithm::rsa::RSA::from_secret(zeroize_secret.as_slice())?;
                match signing_option {
                    Some(SigningOption::RSA { salt_len }) => {
                        let signature = rsa.sign(data, Some(SigningOption::RSA { salt_len }))?;
                        Ok(signature)
                    }
                    _ => Err(KSError::RSASignError),
                }
            }
            _ => Err(KSError::SEError(
                "signing algo is not supported".to_string(),
            )),
        }
    }

    fn get_version(&self) -> Result<Vec<u8>, KSError> {
        self.get_se_result(
            GetFirmwareStatusCommand::build(None)
                .ok_or(KSError::SEError("compose command error".to_string()))?,
            result::FIRMWARE_APP_VERSION,
        )
    }
}

#[cfg(all(test, target_os = "android"))]
mod tests {
    use super::*;
    use crate::keymaster::EntropyLength;
    use base64;

    #[test]
    fn it_should_get_entropy() {
        let password =
            "f6cda9bc3afff095f7c96a78455b2925c6339db3ce3563013e7fb75cc0e4829d".to_string();
        let port_name = "/dev/ttyMT1";
        let mut se = SecureElement::new(port_name.to_string());
        let token = se.generate_token(password).unwrap();
        let mut se = SecureElement::new(port_name.to_string());
        let a = se.get_entropy(0, token).unwrap();
        assert_eq!(
            hex::encode(a),
            "ffffffffffffffffffffffffffffffff".to_string()
        );
    }

    #[test]
    fn it_should_set_the_ada_root_key() {
        let password =
            "f6cda9bc3afff095f7c96a78455b2925c6339db3ce3563013e7fb75cc0e4829d".to_string();
        let port_name = "/dev/ttyMT1";
        let mut se = SecureElement::new(port_name.to_string());
        let v = vec![0x02; 96];
        let r = se.set_ada_root_key(0, password, v).unwrap();
        assert_eq!(r, true);
    }

    #[test]
    fn it_should_get_the_ada_root_key() {
        let password =
            "f6cda9bc3afff095f7c96a78455b2925c6339db3ce3563013e7fb75cc0e4829d".to_string();
        let port_name = "/dev/ttyMT1";
        let mut se = SecureElement::new(port_name.to_string());
        let token = se.generate_token(password).unwrap();

        let r = se.get_ada_root_key(0, token).unwrap();
        assert_eq!(hex::encode(r), "020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202".to_string());
    }

    #[test]
    // this test function rely on secure element
    fn it_should_get_right_version_from_chip() {
        let port_name = "/dev/ttyMT1";
        let mut se = SecureElement::new(port_name.to_string());
        let version = se.get_version().unwrap();
        let a = String::from_utf8(version).unwrap();
        assert_eq!(a.as_str(), "1.2.0.000000");
    }

    #[test]
    // this test function rely on secure element
    fn it_should_get_right_entropy_from_chip() {
        let port_name = "/dev/ttyMT1";
        let mut se = SecureElement::new(port_name.to_string());
        let entropy = se.generate_entropy(EntropyLength::Short(12)).unwrap();
        assert_eq!(32, entropy.len());
    }

    #[test]
    fn it_should_test_get_private_key() {
        let password =
            "f6cda9bc3afff095f7c96a78455b2925c6339db3ce3563013e7fb75cc0e4829d".to_string();

        let port_name = "/dev/ttyMT1";
        let mut se = SecureElement::new(port_name.to_string());
        let token = se.generate_token(password).unwrap();

        let path = "m/44'/60'/0'/0/0".to_string();

        let key = se
            .get_key(
                0,
                path,
                Some(token),
                SigningAlgorithm::Secp256k1,
                GetKeyType::ExtendedPrivateKey,
            )
            .unwrap();
        se.clear_token();
        let base58_key = String::from_utf8(key.to_vec())
            .map_err(|_e| KSError::SEError("decode bs58 key error".to_string()))
            .unwrap();
        assert_eq!("xprvA46yrWykFh3LjMHn1eqk7A8WNBt7JzJqEeBX1RNz2bx9Ditu6peK7MJWR8tfXUqPjWNuL7LwLvphdgkWShNpYXiJBuvi9agxJUWiHGHtoNk", base58_key);
    }

    #[test]
    fn it_should_test_get_master_seed() {
        let password =
            "f6cda9bc3afff095f7c96a78455b2925c6339db3ce3563013e7fb75cc0e4829d".to_string();

        let port_name = "/dev/ttyMT1";
        let mut se = SecureElement::new(port_name.to_string());
        let token = se.generate_token(password).unwrap();
        let path = "m/44'/472'".to_string();

        let key = se
            .get_key(
                0,
                path,
                Some(token),
                SigningAlgorithm::RSA,
                GetKeyType::MasterSeed,
            )
            .unwrap();
        se.clear_token();
        assert_eq!(key.len(), 64);
        assert_eq!(hex::encode(key), "5eb00bbddcf069084889a8ab9155568165f5c453ccb85e70811aaed6f6da5fc19a5ac40b389cd370d086206dec8aa6c43daea6690f20ad3d8d48b2d2ce9e38e4");
    }

    #[test]
    fn it_should_test_get_rsa_public_key() {
        let password =
            "f6cda9bc3afff095f7c96a78455b2925c6339db3ce3563013e7fb75cc0e4829d".to_string();

        let port_name = "/dev/ttyMT1";
        let mut se = SecureElement::new(port_name.to_string());
        let path = "m/44'/472'".to_string();

        let key = se.get_rsa_public_key(0, password).unwrap();
        se.clear_token();
        assert_eq!(key.len(), 512);
        assert_eq!(hex::encode(key), "c41a50ed2155a5740b45df8e3815774d6b8d193e5ad80c9efaaf6d6d0253f350c85becf39eb7056d75841f6a064acf8381383eceb218e16859ef72be7273321a2b4855b87bc6f14c734e2a9c90850c34a8a0a4279ac9be3186b086db5b302fb68176b4c1fee337456c42f972c7993f618fdedc0bf1658c2d59cf2c0c6ac31a61ac1260e0fd4a761ca3707e27611c14b4c6b6abe698c11009ddf5d1511ae47ea271079b6892d229a27d0822e0c7aa12a4cf7f7c28fe23d201eae2adb7f403c9c5a1762c2d8cc96898ce41fe529ab0ef8184e50063e6fc62e0a808e8602254c142c9e7f7e94e6ef2c767ac0e99810d09a44bfde8db46298bc0e25b4a333b4ef86cd7ce658ff661ab0d1789b603b8770a6b433851a91c8ff07a7a8a0767702f6887098ea34bf4a8309eaab9baadd16d45cdd9b1899b6a303a2dce23745cec9fc2ecd9735a66c77fdea1bfd4cdb2be7bfb407a4fd5d3405c3cb33b5316e16559f0c4bf0bc7d1a3ada78917217b289c4d75eb60e0396f03035fd8d553727c790189cfd8dabcee8a4ae6607925b9a27ff7ad7ede26b98f8acd2532cf3175693f3eede9989a0aeedbdb3ff14fec823017531aead4cd22733ab30dbce76cebcdac64424128d6eeff3cdc1825d7cdb7113e74db126e6d931544467c6979aa8d50ac803f36084ed7077f34acfcf3f77bb13d5ebb723fc5d3f45212d2dd6ef20ea757fb4c95");
    }

    #[test]
    fn it_should_test_get_rsa_private_key() {
        let password =
            "f6cda9bc3afff095f7c96a78455b2925c6339db3ce3563013e7fb75cc0e4829d".to_string();

        let port_name = "/dev/ttyMT1";
        let mut se = SecureElement::new(port_name.to_string());
        let token = se.generate_token(password).unwrap();
        let path = "m/44'/472'".to_string();

        let key = se
            .get_key(
                0,
                path,
                Some(token),
                SigningAlgorithm::RSA,
                GetKeyType::RSASecret,
            )
            .unwrap();
        assert_eq!(key.len(), 1536);
        assert_eq!(hex::encode(key), "fdec3a1aee520780ca4058402d0422b5cd5950b715728f532499dd4bbcb68e5d44650818b43656782237316c4b0e2faa2b15c245fb82d10cf4f5b420f1f293ba75b2c8d8cef6ad899c34ce9de482cb248cc5ab802fd93094a63577590d812d5dd781846ef7d4f5d9018199c293966371c2349b0f847c818ec99caad800116e02085d35a39a913bc735327705161761ae30a4ec775f127fbb5165418c0fe08e54ae0aff8b2dab2b82d3b4b9c807de5fae116096075cf6d5b77450d743d743e7dcc56e7cafdcc555f228e57b363488e171d099876993e93e37a94983ccc12dba894c58ca84ac154c1343922c6a99008fabd0fa7010d3cc34f69884fec902984771c5b50031ba31ab7c8b76453ce771f048b84fb89a3e4d44c222c3d8c823c683988b0dbf354d8b8cbf65f3db53e1365d3c5e043f0155b41d1ebeca6e20b2d6778600b5c98ffdba33961dae73b018307ef2bce9d217bbdf32964080f8db6f0cf7ef27ac825fcaf98d5143690a5d7e138f4875280ed6de581e66ed17f83371c268a073e4594814bcc88a33cbb4ec8819cc722ea15490312b85fed06e39274c4f73ac91c7f4d1b899729691cce616fb1a5feee1972456addcb51ac830e947fcc1b823468f0eefbaf195ac3b34f0baf96afc6fa77ee2e176081d6d91ce8c93c3d0f3547e48d059c9da447ba05ee3984703bebfd6d704b7f327ffaea7d0f63d0d3c6d65542fd4042926629451ee9a4dace812428b6494acbf45370ddd2308c01e9ab9bf3974b561d5064f6f315f1a39632024bc18f2738c3acb11a1c1d25919477b0acc4f3e8b865aa50a9c3e781535079a06a668aa262ed675bb8ff979b93b5c877044528a0a89aa0a13855b37d96d1c213f237c2739a26aeca46427c517ecf0bc778becda2afb0be236988ed5d162c87ecca8db123af41129f8dfb3893f66293c64dd09d7313190ae66af5a2bef053ed25594a97bda6aa2c7eff560c815b9fe28ce2b68e89988a88322c34ef0e7e4c0822b2018545379900553d18c71de88bed451ef814c739296586d238bef428945ecb9f1eda9c098ba2345daf59229659b1588f2374438e978f94cf03ece881ded34790416d0f746b0701f7096aa74f381a21725dba3702b32670a5db7693763e95e751ae0ef5cd875ac38a4427dd716dd1d61d6c0e234ff64f80dbf0f1c2632883ac74b9e9387ad58e5ca928b7880d9844b513b448447c31b94d04160cfa83b0381b4e59b23deafd1cca01639e405bc494fa63758246eab4d25f94a6c2dfed72be6127217d7f806b05b573070850307a8c594233851a7efdb55e27f1624f2a9ca2a0c3e803024b1cbce919e7ae7e0b730d357a6ca62cd15978940f7998524404cb5837ccc93bca22caeb5156aa36abd92c83e047addef10d2e8f78e8c94a50fc305f9fe35a7f45f76271bd794b2f111db2eae41c41a50ed2155a5740b45df8e3815774d6b8d193e5ad80c9efaaf6d6d0253f350c85becf39eb7056d75841f6a064acf8381383eceb218e16859ef72be7273321a2b4855b87bc6f14c734e2a9c90850c34a8a0a4279ac9be3186b086db5b302fb68176b4c1fee337456c42f972c7993f618fdedc0bf1658c2d59cf2c0c6ac31a61ac1260e0fd4a761ca3707e27611c14b4c6b6abe698c11009ddf5d1511ae47ea271079b6892d229a27d0822e0c7aa12a4cf7f7c28fe23d201eae2adb7f403c9c5a1762c2d8cc96898ce41fe529ab0ef8184e50063e6fc62e0a808e8602254c142c9e7f7e94e6ef2c767ac0e99810d09a44bfde8db46298bc0e25b4a333b4ef86cd7ce658ff661ab0d1789b603b8770a6b433851a91c8ff07a7a8a0767702f6887098ea34bf4a8309eaab9baadd16d45cdd9b1899b6a303a2dce23745cec9fc2ecd9735a66c77fdea1bfd4cdb2be7bfb407a4fd5d3405c3cb33b5316e16559f0c4bf0bc7d1a3ada78917217b289c4d75eb60e0396f03035fd8d553727c790189cfd8dabcee8a4ae6607925b9a27ff7ad7ede26b98f8acd2532cf3175693f3eede9989a0aeedbdb3ff14fec823017531aead4cd22733ab30dbce76cebcdac64424128d6eeff3cdc1825d7cdb7113e74db126e6d931544467c6979aa8d50ac803f36084ed7077f34acfcf3f77bb13d5ebb723fc5d3f45212d2dd6ef20ea757fb4c95");
    }

    #[test]
    fn it_should_test_get_extend_private_key_error_without_token() {
        let port_name = "/dev/ttyMT1";
        let mut se = SecureElement::new(port_name.to_string());

        let path = "m/44'/60'/0'/0/0".to_string();
        let key = se
            .get_key(
                0,
                path,
                None,
                SigningAlgorithm::Secp256k1,
                GetKeyType::ExtendedPrivateKey,
            )
            .unwrap_err()
            .to_string();
        se.clear_token();
        assert_eq!("SEError:required field is missing", key);
    }

    #[test]
    fn it_should_test_get_extended_public_key_without_token() {
        let port_name = "/dev/ttyMT1";
        let mut se = SecureElement::new(port_name.to_string());

        let path = "M/44'/60'/0'/0".to_string();
        let key = se
            .get_key(
                0,
                path,
                None,
                SigningAlgorithm::Secp256k1,
                GetKeyType::ExtendedPublicKey,
            )
            .unwrap();
        se.clear_token();
        let base58_key = String::from_utf8(key.to_vec())
            .map_err(|_e| KSError::SEError("decode bs58 key error".to_string()))
            .unwrap();
        assert_eq!("xpub6EF8jXqFeFEW5bwMU7RpQtHkzE4KJxcqJtvkCjJumzW8CPpacXkb92ek4WzLQXjL93HycJwTPUAcuNxCqFPKKU5m5Z2Vq4nCyh5CyPeBFFr", base58_key);
    }

    #[test]
    fn it_should_sign_right_data() {
        use k256::ecdsa::{recoverable, SigningKey};
        let password =
            "f6cda9bc3afff095f7c96a78455b2925c6339db3ce3563013e7fb75cc0e4829d".to_string();

        let port_name = "/dev/ttyMT1";
        let mut se = SecureElement::new(port_name.to_string());
        let token = se.generate_token(password).unwrap();

        let token_string = hex::encode(token);

        let path = "m/44'/60'/0'/0/0".to_string();

        let data: Vec<u8> = hex::decode(
            "af1dee894786c304604a039b041463c9ab8defb393403ea03cf2c85b1eb8cbfd".to_string(),
        )
            .unwrap();

        let signature = se
            .sign_data(
                0,
                token_string,
                data,
                SigningAlgorithm::Secp256k1,
                path,
                None,
            )
            .unwrap();
        se.clear_token();
        let expected = "b836ae2bac525ae9d2799928cf6f52919cb2ed5e5e52ca26e3b3cdbeb136ca2f618da0e6413a6aa3aaa722fbc2bcc87f591b8b427ee6915916f257de8125810e00".to_string();
        assert_eq!(hex::encode(signature), expected);
    }

    #[test]
    fn it_should_sign_right_data_rsa_salt_zero() {
        let password =
            "f6cda9bc3afff095f7c96a78455b2925c6339db3ce3563013e7fb75cc0e4829d".to_string();

        let port_name = "/dev/ttyMT1";
        let mut se = SecureElement::new(port_name.to_string());
        let token = se.generate_token(password).unwrap();

        let token_string = hex::encode(token.clone());

        let path = "m/44'/472'".to_string();

        let data: Vec<u8> = hex::decode(
            "af1dee894786c304604a039b041463c9ab8defb393403ea03cf2c85b1eb8cbfd".to_string(),
        )
            .unwrap();
        let signing_option = SigningOption::RSA { salt_len: 0 };
        let signature = se
            .sign_data(
                0,
                token_string,
                data,
                SigningAlgorithm::RSA,
                path.clone(),
                Some(signing_option),
            )
            .unwrap();
        assert_eq!(signature.len(), 512);
        assert_eq!(hex::encode(signature.clone()), "a466677c060a23d64d581d61dfa2e5f205e79181fc5daaa002a0185d49399b1c2aff2b4993e97f6a4d395e7eba1f5e3ac2c1e350a4fbf9be6b7f1bfc3af19634b0fbfba63c0e0857f45b18de702dd603312e4f585baf70c82f90114a3a4cf7bccd19bc14360fbf5afda08c031b30f79cfac2a755f3479279b3e99e1be1d2d6b8b3e289bfaf2adde389f4353cda4d82d48811765775eb9ea4a0d177ebd13e103bac861b1d9977c87412bf049f5d34cd8a3d43ac3047d6b2d358eea15f65bca24947d5cba4b2addf9bc2fc996e0fa9bc759cff1bbef4a02e69bed3d79fe77fe1640a9eacbb149b6abcf9c53c82a387b8f55bd2a751bf92a536b376c027d4a419237f52feca12960cc230343d7ec746ba6dd035ccb6d7555e4722629a7b0a63804dc986dc5a5d419a93333bff258ac13352a4d30566942dfd5e72a187359540040be816da5ec629dd429ee6c09c3deeacc8ae7a884cb2627438874ae3deb10c6f1318452b936b93ca3d11dde17d6e4ebbb0cee1b96ae9dc0ab1f8ec3f3580d6e11a0ab3d9b75ec4169322ae116697a5f2aa1235e9c2cea14182b03c6effa45e8bff30282434b2a73fef392a8ed576732e638a10b3a5da27ffda39578716a692f13da11983bd650207d10ebdd92ef0026bd30801f42e30aa21cee1f466eb761582019804b0c4d702284c5b44219f0596d51b2c6e69eeba90f2e3861fd05877245e6c");
        let secret = se
            .get_key(
                0,
                path,
                Some(token),
                SigningAlgorithm::RSA,
                GetKeyType::RSASecret,
            )
            .unwrap();
        let rsa = algorithm::rsa::RSA::from_secret(secret.as_slice()).unwrap();
        let data2: Vec<u8> = hex::decode(
            "af1dee894786c304604a039b041463c9ab8defb393403ea03cf2c85b1eb8cbfd".to_string(),
        )
            .unwrap();
        let result = rsa.verify(
            &signature.as_ref(),
            &data2,
            SigningOption::RSA { salt_len: 0 },
        );
        se.clear_token();
        assert_eq!(result.ok(), Some(()));
    }

    #[test]
    fn it_should_sign_right_data_rsa_salt_digest() {
        use k256::ecdsa::{recoverable, SigningKey};
        let password =
            "f6cda9bc3afff095f7c96a78455b2925c6339db3ce3563013e7fb75cc0e4829d".to_string();

        let port_name = "/dev/ttyMT1";
        let mut se = SecureElement::new(port_name.to_string());
        let token = se.generate_token(password).unwrap();

        let token_string = hex::encode(token.clone());

        let path = "m/44'/472'".to_string();

        let data: Vec<u8> = hex::decode(
            "af1dee894786c304604a039b041463c9ab8defb393403ea03cf2c85b1eb8cbfd".to_string(),
        )
            .unwrap();
        let signing_option = SigningOption::RSA { salt_len: 32 };
        let signature = se
            .sign_data(
                0,
                token_string,
                data,
                SigningAlgorithm::RSA,
                path.clone(),
                Some(signing_option),
            )
            .unwrap();
        assert_eq!(signature.len(), 512);
        let secret = se
            .get_key(
                0,
                path,
                Some(token),
                SigningAlgorithm::RSA,
                GetKeyType::RSASecret,
            )
            .unwrap();
        let rsa = algorithm::rsa::RSA::from_secret(secret.as_slice()).unwrap();
        let data2: Vec<u8> = hex::decode(
            "af1dee894786c304604a039b041463c9ab8defb393403ea03cf2c85b1eb8cbfd".to_string(),
        )
            .unwrap();
        let result = rsa.verify(
            &signature.as_ref(),
            &data2,
            SigningOption::RSA { salt_len: 32 },
        );
        se.clear_token();
        assert_eq!(result.ok(), Some(()));
    }
}

'''
'''--- signer/src/keymaster/se/serial_manager.rs ---
use crate::error::KSError;
use serialport;
use std::io::ErrorKind;
use std::sync::mpsc;
use std::thread;
use std::time::Duration;

const BAUD_RATE: u32 = 115_200;

pub struct SerialManager<'a> {
    port_name: &'a str,
    timeout_ms: u64,
}

impl<'a> SerialManager<'a> {
    pub fn new(port_name: &'a str, timeout_ms: u64) -> Self {
        SerialManager {
            port_name,
            timeout_ms,
        }
    }

    pub fn send_data(&self, data: Vec<u8>) -> Result<Vec<u8>, KSError> {
        let (tx, rx) = mpsc::channel();
        let mut port = serialport::new(self.port_name, BAUD_RATE)
            .timeout(Duration::from_millis(self.timeout_ms))
            .open()
            .map_err(|_| KSError::SerialManagerError("Fail open port".to_string()))?;

        let mut clone = port
            .try_clone()
            .map_err(|_| KSError::SerialManagerError("Fail to clone port".to_string()))?;

        thread::spawn(move || {
            match clone
                .write_all(&data)
                .map_err(|_e| KSError::SerialManagerError("Fail write port error".to_string()))
            {
                Ok(_) => tx.send(true),
                Err(_) => tx.send(false),
            }
        });

        match rx.recv() {
            Ok(result) => {
                if result {
                    // need improve
                    // open 3k bytes as the read buffer
                    let buffer_size = 3096;

                    let mut read_data_buf = vec![0; buffer_size];

                    let length =
                        port.read(read_data_buf.as_mut_slice())
                            .map_err(|e| match e.kind() {
                                ErrorKind::TimedOut => KSError::SerialTimeout,
                                _ => KSError::SerialManagerError("notKnow error".to_string()),
                            })?;

                    let received_data = read_data_buf.as_slice();
                    let result = received_data[..length].to_vec();
                    port.clear(serialport::ClearBuffer::All);
                    Ok(result)
                } else {
                    Err(KSError::SerialManagerError("send data error".to_string()))
                }
            }
            Err(_) => Err(KSError::SerialManagerError(
                "thread receive error".to_string(),
            )),
        }
    }
}

#[cfg(all(test, target_os = "android"))]
mod tests {
    use super::*;
    use hex;

    #[test]
    // this test function rely on secure element
    fn it_should_send_data_to_se() {
        let port_name = "/dev/ttyMT1";
        // set timeout to 100s
        const TIMEOUT_MS: u64 = 100000;
        let serial_manger = SerialManager::new(port_name, TIMEOUT_MS);
        let version_sig: Vec<u8> = vec![02, 00, 00, 06, 00, 01, 00, 02, 01, 02, 03, 07];

        let result = serial_manger.send_data(version_sig).unwrap();

        let expected = hex::decode("020000360001000201020106000c312e302e312e303030303030010f00041010000001180001010102000400000088021000010000020002000003ad").unwrap();

        assert_eq!(result, expected);
    }
}

'''
'''--- signer/src/keymaster/se/tags.rs ---
pub const COMMAND_TAG: u16 = 0x0001;
pub const RESPONSE_TAG:u16 = 0x0002;

pub mod methods {
    pub const GET_FIRMWARE_STATUS_TAG: u16 = 0x0102;
    pub const GET_RANDOM_ENTROPY_TAG: u16 = 0x0301;
    pub const ENTROPY_TYPE_TAG: u16 = 0x0201;
    pub const ENTROPY_CHECKSUM_TAG: u16 = 0x030b;
    // TBD
    pub const GET_KEY_TAG: u16 = 0x0305;
    pub const CLEAR_TOKEN_TAG:u16 = 0x0908;
    pub const SIGN_TAG:u16 = 0x0307;
    pub const SET_SECRET_TAG: u16 = 0x0302;

    pub const CURVE_TAG: u16 = 0x030D;
    pub const WALLET_FLAG_TAG: u16 = 0x0210;
    pub const PATH_TAG:u16 = 0x0207;
    pub const AUTH_TOKEN_TAG:u16 = 0x0404;
    pub const NEED_TOKEN_TAG: u16= 0x0405;
    pub const TX_HASH_TAG: u16= 0x0307;

    pub const VERIFY_USER_PASSWORD:u16 = 0x0903;
    pub const CURRENT_PASSWORD:u16 = 0x0402;
    pub const CURRENT_SECRET:u16 = 0x0218;
    // RSA TAG
    pub const RSA_SECRET_FLAG_TAG: u16= 0x0216;
    pub const MASTER_SEED_FLAG_TAG: u16= 0x0217;
    pub const WRITE_RSA_SECRET_FLAG: u16 = 0x0212;

    //ADA TAG
    pub const ENTROPY_FLAG_TAG: u16= 0x0218;
    pub const ADA_FLAG_TAG: u16= 0x021A;
    pub const WRITE_ADA_ROOT_FLAG: u16 = 0x021C;

}

pub mod result {

    // 

    pub const FIRMWARE_APP_VERSION: u16 = 0x0106;
    pub const ENTROPY: u16 = 0x0202;
    pub const EXT_KET: u16 = 0x020a;
    pub const EXT_MASTER_SEED: u16 = 0x0211;
    pub const EXT_RSA_SECRET: u16 = 0x0212;
    pub const EXT_ENTROPY: u16 = 0x0219;
    pub const EXT_ADA_ROOT_KEY: u16 = 0x021B;
    // pub const `KEY`: u16 = 0x0302;
    pub const AUTH_TOKEN: u16 = 0x0404;
    pub const SUCCESS: u16 = 0x0000;
}

'''
'''--- signer/src/keymaster/se/tvl.rs ---
use bytes::{Buf, BufMut, Bytes, BytesMut};
use indexmap::IndexMap;
use std::convert::{TryFrom, TryInto};

use crate::error::KSError;
#[derive(Debug)]
pub struct Packet {
    pub stx: u8,
    pub encryption_flag: u8,
    pub length: u16,
    pub payloads: IndexMap<u16, TVL>,
    pub etx: u8,
    pub lrc: u8,
}

impl Packet {
    pub fn new(payloads: IndexMap<u16, TVL>) -> Self {
        let len: u16 = payloads.iter().fold(0, |len, (_, each_value)| {
            len + each_value.to_vec().len() as u16
        });

        let bytes = Self::combine_bytes(2, 0, len, &payloads, 3);
        let lrc_bit = lrc(&bytes);

        Self {
            stx: 2,
            encryption_flag: 0,
            length: len,
            payloads,
            etx: 3,
            lrc: lrc_bit,
        }
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut bytes = Self::combine_bytes(
            self.stx,
            self.encryption_flag,
            self.length,
            &self.payloads,
            self.etx,
        );
        let lrc_bit = lrc(&bytes);
        bytes.put_u8(lrc_bit);
        bytes.freeze().to_vec()
    }

    fn combine_bytes(
        stx: u8,
        encryption_flag: u8,
        length: u16,
        payloads: &IndexMap<u16, TVL>,
        etx: u8,
    ) -> BytesMut {
        let mut mm = BytesMut::new();
        mm.put_u8(stx);
        mm.put_u8(encryption_flag);
        mm.put_u16(length);

        for (_key, value) in payloads.iter() {
            let tvl_vec: Vec<u8> = value.to_vec();
            mm.put_slice(tvl_vec.as_slice());
        }
        mm.put_u8(etx);
        mm
    }
}

impl TryFrom<Vec<u8>> for Packet {
    type Error = KSError;

    fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
        let caculate_lrc = lrc(&value);
        let mut mm = Bytes::from(value);
        let all_length = mm.len();

        if all_length < 6 {
            return Err(Self::Error::TVLError(
                "vector length is small than 6".to_string(),
            ));
        }

        let stx = mm.get_u8();
        if stx != 2 {
            return Err(Self::Error::TVLError("stx is not 2".to_string()));
        }
        let encryption_flag = mm.get_u8();
        let length = mm.get_u16();

        if all_length != (length + 6).into() {
            return Err(Self::Error::TVLError("all length is invalid".to_string()));
        }

        let mut payloads = IndexMap::new();

        while mm.remaining() > 2 {
            let tag = mm.get_u16();
            let length = mm.get_u16();
            let value = mm.copy_to_bytes(length.into());
            payloads.insert(tag, TVL::new(tag, length, value));
        }

        let etx = mm.get_u8();
        if etx != 3 {
            return Err(Self::Error::TVLError("etx is not 3".to_string()));
        }
        let lrc_bit = mm.get_u8();

        if caculate_lrc != 0 {
            return Err(Self::Error::TVLError("lrc is not matched".to_string()));
        };

        Ok(Self {
            stx,
            encryption_flag,
            length,
            payloads,
            etx,
            lrc: lrc_bit,
        })
    }
}

#[derive(Debug)]
pub struct TVL {
    pub tag: u16,
    pub length: u16,
    pub value: Bytes,
}

impl TVL {
    pub fn new(tag: u16, length: u16, value: Bytes) -> TVL {
        Self { tag, length, value }
    }

    pub fn to_vec(&self) -> Vec<u8> {
        let mut mm = BytesMut::new();
        mm.put_u16(self.tag);
        mm.put_u16(self.length);
        mm.put_slice(self.value.chunk());
        Vec::from(mm.chunk())
    }
}

impl TryFrom<Vec<u8>> for TVL {
    type Error = KSError;

    fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
        let mut mm = Bytes::from(value);

        if mm.len() < 4 {
            return Err(Self::Error::TVLError("value length is not fit".to_string()));
        }

        let tag = mm.get_u16();
        let length = mm.get_u16();
        let value = mm.copy_to_bytes(mm.chunk().len());

        if mm.has_remaining() {
            return Err(Self::Error::TVLError("".to_string()));
        }
        Ok(Self { tag, length, value })
    }
}

pub fn lrc<'a, T: IntoIterator<Item = &'a u8>>(bytes: T) -> u8 {
    let result: u8 = bytes.into_iter().fold(0, |result, i| result ^ i);
    result
}

#[cfg(all(test, target_os = "macos"))]
mod tests {
    use super::*;

    #[test]
    fn it_should_get_right_lrc() {
        let data: Vec<u8> = vec![0xff, 0xee, 0xcc, 0x00, 0xff, 0x11, 0x0c];
        assert_eq!(0x3f, lrc(&data));
        let data: Vec<u8> = vec![
            0x02, 0x00, 0x00, 0x12, 0x00, 0x01, 0x00, 0x02, 0x08, 0x01, 0x08, 0x01, 0x00, 0x08,
            0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x03,
        ];
        assert_eq!(0x18, lrc(&data));
    }

    #[test]
    fn it_should_construct_packet() {
        let version_sig: Vec<u8> = vec![00, 01, 00, 02, 01, 02];
        let tvl = TVL::try_from(version_sig).unwrap();

        let mut payloads: IndexMap<u16, TVL> = IndexMap::new();
        payloads.insert(1, tvl);

        let packet = Packet::new(payloads);
        assert_eq!(packet.to_vec(), vec![02, 00, 00, 06, 00, 01, 00, 02, 01, 02, 03, 07]);
    }

    #[test]
    fn it_should_contruct_tvl_struct() {
        let version_sig: Vec<u8> = vec![00, 01, 00, 02, 01, 02];
        let tvl = TVL::try_from(version_sig).unwrap();
        assert_eq!(tvl.tag, 1);
        assert_eq!(&tvl.value[..], &[1, 2]);
        assert_eq!(tvl.to_vec(), vec![00, 01, 00, 02, 01, 02])
    }

    #[test]
    fn it_should_return_error_tvl_struct() {
        let version_sig: Vec<u8> = vec![00];
        let tvl = TVL::try_from(version_sig);
        assert!(tvl.is_err());
    }

    #[test]
    fn it_should_retrun_package() {
        let response = hex::decode("0200000e0003000465727221000200020202034c").unwrap();
        let packet = Packet::try_from(response).unwrap();
        let tvl = packet.payloads.get(&3).unwrap();

        assert_eq!(tvl.value, &b"err!"[..]);
        let tvl = packet.payloads.get(&2).unwrap();
        assert_eq!(tvl.value, &b"\x02\x02"[..]);
        let restore = packet.to_vec();
        assert_eq!(
            restore,
            hex::decode("0200000e0003000465727221000200020202034c").unwrap()
        );
    }

    #[test]
    fn it_should_error_for_invalid_package() {
        let response = hex::decode("0200").unwrap();
        let packet = Packet::try_from(response);
        let error_message = packet.unwrap_err().to_string();
        assert_eq!(
            error_message,
            "TVLError:vector length is small than 6".to_string()
        );

        let response = hex::decode("010000000000").unwrap();
        let packet = Packet::try_from(response);
        let error_message = packet.unwrap_err().to_string();
        assert_eq!(error_message, "TVLError:stx is not 2".to_string());

        let response = hex::decode("02000000000000").unwrap();
        let packet = Packet::try_from(response);
        let error_message = packet.unwrap_err().to_string();
        assert_eq!(error_message, "TVLError:all length is invalid".to_string());

        let response = hex::decode("0200000e0003000465727221000200020202044c").unwrap();
        let packet = Packet::try_from(response);
        let error_message = packet.unwrap_err().to_string();
        assert_eq!(error_message, "TVLError:etx is not 3".to_string());

        let response = hex::decode("0200000e0003000465727221000200020202034d").unwrap();
        let packet = Packet::try_from(response);
        let error_message = packet.unwrap_err().to_string();
        assert_eq!(error_message, "TVLError:lrc is not matched".to_string());
    }
}

'''
'''--- signer/src/lib.rs ---
extern crate core;

mod error;
mod keymaster;
mod algorithm;

use error::KSError;
use keymaster::{se::SecureElement, KeyMaster, local::Mini};
pub use keymaster::SigningAlgorithm;
pub use crate::keymaster::SigningOption;

pub struct Signer {
    inner: Box<dyn KeyMaster>,
}

impl Signer {
    pub fn new_with_se(port_name: String) -> Self {
        Self {
            inner: Box::new(SecureElement::new(port_name)),
        }
    }

    fn new_with_mini() -> Self {
        Self { inner: Box::new(Mini {}) }
    }

    pub fn sign_data(
        &self,
        mnemonic_id: u8,
        password: String,
        data: Vec<u8>,
        algo: SigningAlgorithm,
        derivation_path: String,
        signing_option: Option<SigningOption>,
    ) -> Result<Vec<u8>, KSError> {
        self.inner
            .sign_data(mnemonic_id, password, data, algo, derivation_path, signing_option)
    }

    pub fn get_rsa_public_key(
        &self,
        mnemonic_id: u8,
        password: String,
    ) -> Result<Vec<u8>, KSError> {
        self.inner
            .get_rsa_public_key(mnemonic_id, password)
    }

    pub fn setup_ada_root_key(
        &self,
        mnemonic_id: u8,
        password: String,
        passphrase: String,
    ) -> Result<bool, KSError> {
        self.inner.setup_ada_root_key(mnemonic_id, password, passphrase)
    }

    pub fn get_ada_extended_public_key(
        &self,
        mnemonic_id: u8,
        password: String,
        path: String,
    ) -> Result<String, KSError> {
        self.inner.get_ada_extended_public_key(mnemonic_id, password, path)
    }

    pub fn get_ada_root_key(
        &self,
        mnemonic_id: u8,
        password: String,
    ) -> Result<Vec<u8>, KSError> {
        self.inner
            .get_ada_root_key(mnemonic_id, password.into())
    }
}

#[cfg(all(test, target_os = "macos"))]
mod tests {
    use k256::ecdsa::signature::Signature as _;
    use k256::ecdsa::digest::Digest;
    use k256::ecdsa::{recoverable::Signature, SigningKey};
    use openssl::sign::RsaPssSaltlen;
    use super::keymaster::hash_wraper::ShaWrapper;
    use super::*;
    use crate::algorithm;
    use crate::algorithm::SecretKey;
    use crate::keymaster::SigningOption;

    #[test]
    fn it_should_pass_test_sign_256k1() {
        let fake_signer = Signer::new_with_mini();
        let path = "m/44'/60'/0'/0/0".to_string();

        let data: Vec<u8> = hex::decode(
            "af1dee894786c304604a039b041463c9ab8defb393403ea03cf2c85b1eb8cbfd".to_string(),
        )
            .unwrap();

        let signature = fake_signer
            .sign_data(0, "test_pass".to_string(), data, SigningAlgorithm::Secp256k1, path, None)
            .unwrap();

        let sig: Signature = Signature::from_bytes(signature.as_slice()).unwrap();
        let sk_bytes = hex::decode("78707276413436797257796b4668334c6a4d486e3165716b374138574e4274374a7a4a714565425831524e7a32627839446974753670654b374d4a5752387466585571506a574e754c374c774c76706864676b5753684e705958694a42757669396167784a555769484748746f4e6b").unwrap();
        let sk = SigningKey::from_secret(sk_bytes.as_slice()).unwrap();
        let data2: Vec<u8> = hex::decode(
            "af1dee894786c304604a039b041463c9ab8defb393403ea03cf2c85b1eb8cbfd".to_string(),
        )
            .unwrap();
        let mut hash = ShaWrapper::new();
        hash.update(data2.as_slice());

        let recover_pk = sig.recover_verifying_key_from_digest(hash).unwrap();

        let pk = sk.verifying_key();
        assert_eq!(&pk, &recover_pk);
    }

    #[test]
    fn it_should_pass_test_sign_rsa_salt_zero() {
        let fake_signer = Signer::new_with_mini();
        let path = "m/44'/472'".to_string();

        let data: Vec<u8> = hex::decode(
            "af1dee894786c304604a039b041463c9ab8defb393403ea03cf2c85b1eb8cbfd".to_string(),
        ).unwrap();

        let signing_option = SigningOption::RSA { salt_len: 0 };

        let signature = fake_signer
            .sign_data(0, "test_pass".to_string(), data, SigningAlgorithm::RSA, path, Some(signing_option))
            .unwrap();
        let data2: Vec<u8> = hex::decode("af1dee894786c304604a039b041463c9ab8defb393403ea03cf2c85b1eb8cbfd".to_string()).unwrap();
        let sk_bytes = hex::decode("fdec3a1aee520780ca4058402d0422b5cd5950b715728f532499dd4bbcb68e5d44650818b43656782237316c4b0e2faa2b15c245fb82d10cf4f5b420f1f293ba75b2c8d8cef6ad899c34ce9de482cb248cc5ab802fd93094a63577590d812d5dd781846ef7d4f5d9018199c293966371c2349b0f847c818ec99caad800116e02085d35a39a913bc735327705161761ae30a4ec775f127fbb5165418c0fe08e54ae0aff8b2dab2b82d3b4b9c807de5fae116096075cf6d5b77450d743d743e7dcc56e7cafdcc555f228e57b363488e171d099876993e93e37a94983ccc12dba894c58ca84ac154c1343922c6a99008fabd0fa7010d3cc34f69884fec902984771c5b50031ba31ab7c8b76453ce771f048b84fb89a3e4d44c222c3d8c823c683988b0dbf354d8b8cbf65f3db53e1365d3c5e043f0155b41d1ebeca6e20b2d6778600b5c98ffdba33961dae73b018307ef2bce9d217bbdf32964080f8db6f0cf7ef27ac825fcaf98d5143690a5d7e138f4875280ed6de581e66ed17f83371c268a073e4594814bcc88a33cbb4ec8819cc722ea15490312b85fed06e39274c4f73ac91c7f4d1b899729691cce616fb1a5feee1972456addcb51ac830e947fcc1b823468f0eefbaf195ac3b34f0baf96afc6fa77ee2e176081d6d91ce8c93c3d0f3547e48d059c9da447ba05ee3984703bebfd6d704b7f327ffaea7d0f63d0d3c6d65542fd4042926629451ee9a4dace812428b6494acbf45370ddd2308c01e9ab9bf3974b561d5064f6f315f1a39632024bc18f2738c3acb11a1c1d25919477b0acc4f3e8b865aa50a9c3e781535079a06a668aa262ed675bb8ff979b93b5c877044528a0a89aa0a13855b37d96d1c213f237c2739a26aeca46427c517ecf0bc778becda2afb0be236988ed5d162c87ecca8db123af41129f8dfb3893f66293c64dd09d7313190ae66af5a2bef053ed25594a97bda6aa2c7eff560c815b9fe28ce2b68e89988a88322c34ef0e7e4c0822b2018545379900553d18c71de88bed451ef814c739296586d238bef428945ecb9f1eda9c098ba2345daf59229659b1588f2374438e978f94cf03ece881ded34790416d0f746b0701f7096aa74f381a21725dba3702b32670a5db7693763e95e751ae0ef5cd875ac38a4427dd716dd1d61d6c0e234ff64f80dbf0f1c2632883ac74b9e9387ad58e5ca928b7880d9844b513b448447c31b94d04160cfa83b0381b4e59b23deafd1cca01639e405bc494fa63758246eab4d25f94a6c2dfed72be6127217d7f806b05b573070850307a8c594233851a7efdb55e27f1624f2a9ca2a0c3e803024b1cbce919e7ae7e0b730d357a6ca62cd15978940f7998524404cb5837ccc93bca22caeb5156aa36abd92c83e047addef10d2e8f78e8c94a50fc305f9fe35a7f45f76271bd794b2f111db2eae41c41a50ed2155a5740b45df8e3815774d6b8d193e5ad80c9efaaf6d6d0253f350c85becf39eb7056d75841f6a064acf8381383eceb218e16859ef72be7273321a2b4855b87bc6f14c734e2a9c90850c34a8a0a4279ac9be3186b086db5b302fb68176b4c1fee337456c42f972c7993f618fdedc0bf1658c2d59cf2c0c6ac31a61ac1260e0fd4a761ca3707e27611c14b4c6b6abe698c11009ddf5d1511ae47ea271079b6892d229a27d0822e0c7aa12a4cf7f7c28fe23d201eae2adb7f403c9c5a1762c2d8cc96898ce41fe529ab0ef8184e50063e6fc62e0a808e8602254c142c9e7f7e94e6ef2c767ac0e99810d09a44bfde8db46298bc0e25b4a333b4ef86cd7ce658ff661ab0d1789b603b8770a6b433851a91c8ff07a7a8a0767702f6887098ea34bf4a8309eaab9baadd16d45cdd9b1899b6a303a2dce23745cec9fc2ecd9735a66c77fdea1bfd4cdb2be7bfb407a4fd5d3405c3cb33b5316e16559f0c4bf0bc7d1a3ada78917217b289c4d75eb60e0396f03035fd8d553727c790189cfd8dabcee8a4ae6607925b9a27ff7ad7ede26b98f8acd2532cf3175693f3eede9989a0aeedbdb3ff14fec823017531aead4cd22733ab30dbce76cebcdac64424128d6eeff3cdc1825d7cdb7113e74db126e6d931544467c6979aa8d50ac803f36084ed7077f34acfcf3f77bb13d5ebb723fc5d3f45212d2dd6ef20ea757fb4c95").unwrap();
        let rsa = algorithm::rsa::RSA::from_secret(&sk_bytes).unwrap();
        let result = rsa.verify(&signature.as_ref(), &data2, SigningOption::RSA { salt_len: 0 });
        assert_eq!(result.ok(), Some(()));
    }

    #[test]
    fn it_should_pass_test_sign_rsa_salt_digest_size() {
        let fake_signer = Signer::new_with_mini();
        let path = "m/44'/472'".to_string();

        let data: Vec<u8> = hex::decode(
            "af1dee894786c304604a039b041463c9ab8defb393403ea03cf2c85b1eb8cbfd".to_string(),
        ).unwrap();

        let signing_option = SigningOption::RSA { salt_len: 32 };

        let signature = fake_signer
            .sign_data(0, "test_pass".to_string(), data, SigningAlgorithm::RSA, path, Some(signing_option))
            .unwrap();
        let data2: Vec<u8> = hex::decode("af1dee894786c304604a039b041463c9ab8defb393403ea03cf2c85b1eb8cbfd".to_string()).unwrap();
        let sk_bytes = hex::decode("fdec3a1aee520780ca4058402d0422b5cd5950b715728f532499dd4bbcb68e5d44650818b43656782237316c4b0e2faa2b15c245fb82d10cf4f5b420f1f293ba75b2c8d8cef6ad899c34ce9de482cb248cc5ab802fd93094a63577590d812d5dd781846ef7d4f5d9018199c293966371c2349b0f847c818ec99caad800116e02085d35a39a913bc735327705161761ae30a4ec775f127fbb5165418c0fe08e54ae0aff8b2dab2b82d3b4b9c807de5fae116096075cf6d5b77450d743d743e7dcc56e7cafdcc555f228e57b363488e171d099876993e93e37a94983ccc12dba894c58ca84ac154c1343922c6a99008fabd0fa7010d3cc34f69884fec902984771c5b50031ba31ab7c8b76453ce771f048b84fb89a3e4d44c222c3d8c823c683988b0dbf354d8b8cbf65f3db53e1365d3c5e043f0155b41d1ebeca6e20b2d6778600b5c98ffdba33961dae73b018307ef2bce9d217bbdf32964080f8db6f0cf7ef27ac825fcaf98d5143690a5d7e138f4875280ed6de581e66ed17f83371c268a073e4594814bcc88a33cbb4ec8819cc722ea15490312b85fed06e39274c4f73ac91c7f4d1b899729691cce616fb1a5feee1972456addcb51ac830e947fcc1b823468f0eefbaf195ac3b34f0baf96afc6fa77ee2e176081d6d91ce8c93c3d0f3547e48d059c9da447ba05ee3984703bebfd6d704b7f327ffaea7d0f63d0d3c6d65542fd4042926629451ee9a4dace812428b6494acbf45370ddd2308c01e9ab9bf3974b561d5064f6f315f1a39632024bc18f2738c3acb11a1c1d25919477b0acc4f3e8b865aa50a9c3e781535079a06a668aa262ed675bb8ff979b93b5c877044528a0a89aa0a13855b37d96d1c213f237c2739a26aeca46427c517ecf0bc778becda2afb0be236988ed5d162c87ecca8db123af41129f8dfb3893f66293c64dd09d7313190ae66af5a2bef053ed25594a97bda6aa2c7eff560c815b9fe28ce2b68e89988a88322c34ef0e7e4c0822b2018545379900553d18c71de88bed451ef814c739296586d238bef428945ecb9f1eda9c098ba2345daf59229659b1588f2374438e978f94cf03ece881ded34790416d0f746b0701f7096aa74f381a21725dba3702b32670a5db7693763e95e751ae0ef5cd875ac38a4427dd716dd1d61d6c0e234ff64f80dbf0f1c2632883ac74b9e9387ad58e5ca928b7880d9844b513b448447c31b94d04160cfa83b0381b4e59b23deafd1cca01639e405bc494fa63758246eab4d25f94a6c2dfed72be6127217d7f806b05b573070850307a8c594233851a7efdb55e27f1624f2a9ca2a0c3e803024b1cbce919e7ae7e0b730d357a6ca62cd15978940f7998524404cb5837ccc93bca22caeb5156aa36abd92c83e047addef10d2e8f78e8c94a50fc305f9fe35a7f45f76271bd794b2f111db2eae41c41a50ed2155a5740b45df8e3815774d6b8d193e5ad80c9efaaf6d6d0253f350c85becf39eb7056d75841f6a064acf8381383eceb218e16859ef72be7273321a2b4855b87bc6f14c734e2a9c90850c34a8a0a4279ac9be3186b086db5b302fb68176b4c1fee337456c42f972c7993f618fdedc0bf1658c2d59cf2c0c6ac31a61ac1260e0fd4a761ca3707e27611c14b4c6b6abe698c11009ddf5d1511ae47ea271079b6892d229a27d0822e0c7aa12a4cf7f7c28fe23d201eae2adb7f403c9c5a1762c2d8cc96898ce41fe529ab0ef8184e50063e6fc62e0a808e8602254c142c9e7f7e94e6ef2c767ac0e99810d09a44bfde8db46298bc0e25b4a333b4ef86cd7ce658ff661ab0d1789b603b8770a6b433851a91c8ff07a7a8a0767702f6887098ea34bf4a8309eaab9baadd16d45cdd9b1899b6a303a2dce23745cec9fc2ecd9735a66c77fdea1bfd4cdb2be7bfb407a4fd5d3405c3cb33b5316e16559f0c4bf0bc7d1a3ada78917217b289c4d75eb60e0396f03035fd8d553727c790189cfd8dabcee8a4ae6607925b9a27ff7ad7ede26b98f8acd2532cf3175693f3eede9989a0aeedbdb3ff14fec823017531aead4cd22733ab30dbce76cebcdac64424128d6eeff3cdc1825d7cdb7113e74db126e6d931544467c6979aa8d50ac803f36084ed7077f34acfcf3f77bb13d5ebb723fc5d3f45212d2dd6ef20ea757fb4c95").unwrap();
        let rsa = algorithm::rsa::RSA::from_secret(&sk_bytes).unwrap();
        let result = rsa.verify(&signature.as_ref(), &data2, SigningOption::RSA { salt_len: 32 });
        assert_eq!(result.ok(), Some(()));
    }
}

'''
'''--- traits/chain/Cargo.toml ---
[package]
name = "rcc-trait-chain"
version = "0.1.0"
edition = "2021"
license = "Apache-2.0"
description = "General trait definition for rcc blockchains."

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
'''
'''--- traits/chain/src/lib.rs ---
use std::error::Error;

pub trait Chain<E: Error> {
    fn parse(data: &Vec<u8>) -> Result<String, E>;
}

'''