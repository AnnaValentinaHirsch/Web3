*GitHub Repository "Lev-Stambler/lets-swap-_-"*

'''--- README.md ---
# Let's Swap 
## Summary
This project uses multiple liquidity pools to get optimal output for a token pair swap. It looks at all possible swap paths with distance of at most two. This means that if someone is trying to swap token a -> c, the algorithm also looks at liquidity pools from a -> b and b -> c. It then uses optimization techniques to find the best split between different trade paths. The algorithm takes into account fees as well.

### The details
Let's Swap will be a DAG (directed acyclic graph) where each node represents a token and each edge (connection between to nodes) represents a liquidity pool/ trade. The root node is the input token, and the last node in the dag is the output token. The algorithm then assigns "weights" to each edge. These weights correspond to what fraction of the input should go to each liquidity pool. Then, the algorithm uses optimization techniques and Web Assembly to find the optimal values for the weights such that the output amount is as high as possible.

**Note** This is a novel algorithm for optimizing output

The following is an illustration of what the DAG looks like when swapping from token A to B:

Here is an example of the DAG that the algorithm build
![chart](https://user-images.githubusercontent.com/18239203/132230306-769267c7-7c03-4321-bc0a-6475d437ca36.png)

## Testnet
Find the link to the testnet site: https://lets-swap.netlify.app/

'''
'''--- chart.svg ---
<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">

<svg width="800" height="600" version="1.1" xmlns="http://www.w3.org/2000/svg">
	<ellipse stroke="black" stroke-width="1" fill="none" cx="382.5" cy="107.5" rx="30" ry="30"/>
	<text x="357.5" y="113.5" font-family="Times New Roman" font-size="20">Tok A</text>
	<ellipse stroke="black" stroke-width="1" fill="none" cx="375.5" cy="423.5" rx="30" ry="30"/>
	<text x="350.5" y="429.5" font-family="Times New Roman" font-size="20">Tok B</text>
	<ellipse stroke="black" stroke-width="1" fill="none" cx="216.5" cy="245.5" rx="30" ry="30"/>
	<text x="191.5" y="251.5" font-family="Times New Roman" font-size="20">Tok C</text>
	<ellipse stroke="black" stroke-width="1" fill="none" cx="521.5" cy="245.5" rx="30" ry="30"/>
	<text x="496.5" y="251.5" font-family="Times New Roman" font-size="20">Tok D</text>
	<ellipse stroke="black" stroke-width="1" fill="none" cx="619.5" cy="245.5" rx="30" ry="30"/>
	<text x="595.5" y="251.5" font-family="Times New Roman" font-size="20">Tok E</text>
	<path stroke="black" stroke-width="1" fill="none" d="M 399.224,132.385 A 253.53,253.53 0 0 1 393.309,399.38"/>
	<polygon fill="black" stroke-width="1" points="393.309,399.38 401.863,395.401 393.481,389.947"/>
	<text x="439.5" y="272.5" font-family="Times New Roman" font-size="20">0.2</text>
	<polygon stroke="black" stroke-width="1" points="359.431,126.678 239.569,226.322"/>
	<polygon fill="black" stroke-width="1" points="239.569,226.322 248.918,225.053 242.525,217.363"/>
	<text x="259.5" y="167.5" font-family="Times New Roman" font-size="20">0.09</text>
	<path stroke="black" stroke-width="1" fill="none" d="M 359.53,398.123 A 264.437,264.437 0 0 1 365.422,132.145"/>
	<polygon fill="black" stroke-width="1" points="359.53,398.123 360.036,388.702 351.284,393.54"/>
	<text x="296.5" y="270.5" font-family="Times New Roman" font-size="20">0.1</text>
	<polygon stroke="black" stroke-width="1" points="381.836,137.493 376.164,393.507"/>
	<polygon fill="black" stroke-width="1" points="376.164,393.507 381.34,385.62 371.343,385.399"/>
	<text x="338.5" y="271.5" font-family="Times New Roman" font-size="20">0.01</text>
	<path stroke="black" stroke-width="1" fill="none" d="M 346.061,428.926 A 131.451,131.451 0 0 1 207.799,274.142"/>
	<polygon fill="black" stroke-width="1" points="346.061,428.926 337.739,424.483 338.42,434.46"/>
	<text x="223.5" y="405.5" font-family="Times New Roman" font-size="20">0</text>
	<polygon stroke="black" stroke-width="1" points="236.485,267.874 355.515,401.126"/>
	<polygon fill="black" stroke-width="1" points="355.515,401.126 353.914,391.829 346.456,398.491"/>
	<text x="280.5" y="355.5" font-family="Times New Roman" font-size="20">1</text>
	<path stroke="black" stroke-width="1" fill="none" d="M 411.712,101.104 A 107.969,107.969 0 0 1 527.685,216.243"/>
	<polygon fill="black" stroke-width="1" points="527.685,216.243 533.227,208.609 523.252,207.916"/>
	<text x="501.5" y="123.5" font-family="Times New Roman" font-size="20">0.2</text>
	<polygon stroke="black" stroke-width="1" points="403.79,128.636 500.21,224.364"/>
	<polygon fill="black" stroke-width="1" points="500.21,224.364 498.056,215.179 491.01,222.275"/>
	<text x="457.5" y="167.5" font-family="Times New Roman" font-size="20">0.05</text>
	<path stroke="black" stroke-width="1" fill="none" d="M 406.643,89.784 A 143.812,143.812 0 0 1 622.991,215.759"/>
	<polygon fill="black" stroke-width="1" points="622.991,215.759 628.091,207.822 618.091,207.696"/>
	<text x="556.5" y="80.5" font-family="Times New Roman" font-size="20">0.15</text>
	<path stroke="black" stroke-width="1" fill="none" d="M 396.593,81.083 A 138.588,138.588 0 0 1 635.518,220.204"/>
	<polygon fill="black" stroke-width="1" points="635.518,220.204 643.532,215.225 634.554,210.819"/>
	<text x="585.5" y="30.5" font-family="Times New Roman" font-size="20">0.2</text>
	<path stroke="black" stroke-width="1" fill="none" d="M 617.381,275.392 A 185.576,185.576 0 0 1 404.612,430.609"/>
	<polygon fill="black" stroke-width="1" points="404.612,430.609 411.721,436.81 413.302,426.936"/>
	<text x="548.5" y="418.5" font-family="Times New Roman" font-size="20">1</text>
	<path stroke="black" stroke-width="1" fill="none" d="M 516.393,275.036 A 207.515,207.515 0 0 1 403.466,412.713"/>
	<polygon fill="black" stroke-width="1" points="403.466,412.713 412.834,413.826 408.571,404.78"/>
	<text x="481.5" y="376.5" font-family="Times New Roman" font-size="20">0.5</text>
</svg>

'''
'''--- frontend/README.md ---
# Svelte Webpack Starter

A starter template for [Svelte](https://svelte.dev) that comes preconfigured with Webpack, TypeScript, SCSS, Babel,
Autoprefixer, and HMR.

- [Getting started](#getting-started)
  - [Installation](#installation)
  - [Starting the development server](#starting-the-development-server)
  - [Building for production](#building-for-production)
  - [Running in production](#running-in-production)
- [Usage](#usage)
  - [Global stylesheets](#global-stylesheets)
  - [Single page applications](#single-page-applications)
  - [Browsers list](#browsers-list)
  - [Babel customization](#babel-customization)
  - [Source maps in production](#source-maps-in-production)
  - [Import path aliases](#import-path-aliases)

---

## Getting started

### Installation

Pull the template files with [`degit`](https://github.com/Rich-Harris/degit) and install dependencies.

**ðŸš€ Webpack 5 (recommended)**

```bash
npx degit baileyherbert/svelte-webpack-starter
npm install
```

**ðŸš€ Webpack 4**

```bash
npx degit baileyherbert/svelte-webpack-starter#4
npm install
```

### Starting the development server

Run the `dev` script to start a live development server with hot module replacement. Then check the output for a link
to the app, which is usually `http://localhost:8080/`:

```bash
npm run dev
```

### Building for production

Run the `build` script to bundle the app for production. The bundle will be created at `/public/build/` and the `public`
directory will contain all files you need to host the app:

```bash
npm run build
```

> ðŸ’¡ **Tip:** You can quickly test the production build by running `npm start` locally.

### Running in production

First upload the following files and folders to your target server:

- `package.json`
- `package-lock.json`
- `public`

Then install dependencies:

```bash
npm install --production
```

Finally run the `start` command to launch the included web server:

```bash
npm start
```

---

## Usage

### Global stylesheets

Add one or more global stylesheets to the bundle by editing the `stylesheets` variable at the top of
`webpack.config.ts`:

```ts
const stylesheets = ['./src/styles/index.scss'];
```

You can specify `css`, `scss`, and `sass` files here, and they will be compiled and minified as necessary. These styles
will be added to the beginning of the bundle in the order specified. Svelte's styles will always appear last.

### Single page applications

For single page applications that use history routing instead of hash routing, edit the `package.json` file to serve
the `index.html` file when a requested file is not found:

- Add the `--history-api-fallback` flag to the `"dev"` command
- Add the `--single` flag to the `"start"` command.

```json
"scripts": {
    "dev": "webpack serve --history-api-fallback",
    "start": "serve public --listen 8080 --single",
}
```

### Browsers list

The bundle will be compiled to run on the browsers specified in `package.json`:

```json
"browserslist": [
    "defaults"
]
```

The default value is recommended. If you wish to customize this, please refer to the list of
[example browserslist queries](https://github.com/browserslist/browserslist#full-list).

> ðŸ’¡ **Note:** This template includes `core-js` and `regenerator-runtime` which means your source code will be
> transpiled and polyfilled to run on old browsers automatically.

### Babel customization

Production builds are compiled with Babel automatically. If you wish to disable it, edit the `webpack.config.ts` file:

```ts
const useBabel = false;
```

Babel is disabled during development in order to improve build speeds. Please enable it manually if you need:

```ts
const useBabelInDevelopment = true;
```

### Source maps in production

Source maps are generated automatically during development. They are not included in production builds by default. If
you wish to change this behavior, edit the `webpack.config.ts` file:

```ts
const sourceMapsInProduction = true;
```

### Import path aliases

Define import path aliases from the `tsconfig.json` file. For example:

```json
"paths": {
    "@stores/*": ["src/stores/*"]
}
```

You can then import files under these aliases and Webpack will resolve them. Your code editor should also use them
for automatic imports:

```ts
import { users } from '@stores/users'; // src/stores/users.ts
```

The root directory is configured as a base path for imports. This means you can also import modules with an absolute
path from anywhere in the project instead of using a large number of `..` to traverse directories.

```ts
import { users } from 'src/stores/users';
```

'''
'''--- frontend/jest.config.js ---
module.exports = {
  displayName: 'frontend',
  globals: {
    'ts-jest': {
      tsConfig: '<rootDir>/tsconfig.spec.json',
    },
  },
  transform: {
    '^.+\\.[tj]s$': 'ts-jest',
  },
  moduleFileExtensions: ['ts', 'js', 'html'],
  coverageDirectory: './coverage/apps/frontend',
};

'''
'''--- frontend/package.json ---
{
  "name": "lets-swap-frontend",
  "version": "1.0.0",
  "private": true,
  "scripts": {
    "build": "cross-env NODE_ENV=production webpack",
    "dev": "webpack serve",
    "start": "serve public --listen 8080",
    "validate": "svelte-check"
  },
  "devDependencies": {
    "@babel/core": "^7.12.17",
    "@babel/plugin-transform-runtime": "^7.12.17",
    "@babel/preset-env": "^7.12.17",
    "@babel/runtime": "^7.12.18",
    "@testing-library/svelte": "^3.0.3",
    "@tsconfig/svelte": "^1.0.10",
    "@types/bn.js": "^5.1.0",
    "@types/mini-css-extract-plugin": "^1.2.2",
    "@types/webpack-dev-server": "^3.11.1",
    "@typescript-eslint/eslint-plugin": "4.3.0",
    "@typescript-eslint/parser": "4.3.0",
    "@wasm-tool/wasm-pack-plugin": "^1.5.0",
    "autoprefixer": "^10.2.5",
    "babel-loader": "^8.2.2",
    "clean-webpack-plugin": "^4.0.0-alpha.0",
    "copy-webpack-plugin": "^9.0.1",
    "core-js": "^3.9.0",
    "cross-env": "^7.0.3",
    "css-loader": "^5.0.2",
    "css-minimizer-webpack-plugin": "^3.0.0",
    "mini-css-extract-plugin": "^1.4.1",
    "node-polyfill-webpack-plugin": "^1.1.4",
    "optimize-css-assets-webpack-plugin": "^5.0.4",
    "postcss": "^8.2.10",
    "postcss-import": "^14.0.0",
    "postcss-load-config": "^3.0.1",
    "postcss-loader": "^5.2.0",
    "postcss-nested": "^5.0.5",
    "precss": "^4.0.0",
    "prettier": "2.2.1",
    "regenerator-runtime": "^0.13.7",
    "require-json5": "^1.1.0",
    "sass": "^1.32.8",
    "sass-loader": "^11.0.1",
    "svelte": "^3.42.2",
    "svelte-check": "^1.2.6",
    "svelte-cli": "^3.0.0",
    "svelte-forms": "^1.1.51",
    "svelte-jester": "^1.3.0",
    "svelte-loader": "^3.0.0",
    "svelte-preprocess": "^4.6.9",
    "tailwindcss": "^2.0.4",
    "ts-jest": "26.4.0",
    "ts-loader": "^8.0.17",
    "ts-node": "~9.1.1",
    "tsconfig-paths-webpack-plugin": "^3.5.1",
    "tslib": "^2.2.0",
    "tsoa": "^3.6.1",
    "typescript": "^4.2.4",
    "webpack": "^5.32.0",
    "webpack-cli": "^4.6.0",
    "webpack-dev-server": "^3.11.2"
  },
  "dependencies": {
    "@malloc/ops": "../../malloc/malloc-near-2/ts-packages/malloc-ops",
    "@malloc/sdk": "../../malloc/malloc-near-2/ts-packages/malloc-client",
    "@smui/button": "^4.2.0",
    "@smui/textfield": "^4.2.0",
    "serve": "^11.3.2",
    "sveltejs-forms": "^2.1.2"
  },
  "browserslist": [
    "defaults"
  ]
}

'''
'''--- frontend/pkg/index.js ---

'''
'''--- frontend/postcss.config.js ---
module.exports = {
  plugins: [require('precss'), require('autoprefixer')],
};

'''
'''--- frontend/public/index.html ---
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <!-- Material Icons -->
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/icon?family=Material+Icons"
    />
    <!-- Roboto -->
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,600,700"
    />
    <!-- Roboto Mono -->
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css?family=Roboto+Mono"
    />

    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/svelte-material-ui@4.0.0/bare.min.css"
    />

    <title>Let's Swap -_-</title>

    <!-- This is a temporary favicon from https://icons8.com/icon/set/money/emoji -->
    <link rel="icon" type="image/png" href="/favicon.png" />

    <link rel="stylesheet" href="/build/bundle.css" />
    <script defer src="/build/bundle.js"></script>
    <script>
      navigator.serviceWorker
        .register("/serviceworker/sw.js")
        .then(function (serviceWorkerRegistration) {
          console.log("Service worker registered");
        })
        .catch(console.error);
    </script>
  </head>
  <body>
    <noscript>Please enable JavaScript to view this application.</noscript>
  </body>
</html>

'''
'''--- frontend/public/serviceworker/sw.js ---
/**
 * This file was taken directly from torus, the file can be found on
 * https://github.com/torusresearch/torus-direct-web-sdk/blob/master/serviceworker/sw.js
 */
/* eslint-disable */
function getScope() {
  return self.registration.scope;
}

self.addEventListener('message', function (event) {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
});

self.addEventListener('fetch', function (event) {
  try {
    const url = new URL(event.request.url);
    if (url.pathname.includes('redirect') && url.href.includes(getScope())) {
      event.respondWith(
        new Response(
          new Blob(
            [
              `
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <title>Redirect</title>
    <style>
      * {
        box-sizing: border-box;
      }
      html,
      body {
        background: #fcfcfc;
        height: 100%;
        padding: 0;
        margin: 0;
      }
      .container {
        width: 100%;
        height: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
        flex-direction: column;
      }
      h1.title {
        font-size: 14px;
        color: #0f1222;
        font-family: "Roboto", sans-serif !important;
        margin: 0;
        text-align: center;
      }
      .spinner .beat {
        background-color: #0364ff;
        height: 12px;
        width: 12px;
        margin: 24px 2px 10px;
        border-radius: 100%;
        -webkit-animation: beatStretchDelay 0.7s infinite linear;
        animation: beatStretchDelay 0.7s infinite linear;
        -webkit-animation-fill-mode: both;
        animation-fill-mode: both;
        display: inline-block;
      }
      .spinner .beat-odd {
        animation-delay: 0s;
      }
      .spinner .beat-even {
        animation-delay: 0.35s;
      }
      @-webkit-keyframes beatStretchDelay {
        50% {
          -webkit-transform: scale(0.75);
          transform: scale(0.75);
          -webkit-opacity: 0.2;
          opacity: 0.2;
        }
        100% {
          -webkit-transform: scale(1);
          transform: scale(1);
          -webkit-opacity: 1;
          opacity: 1;
        }
      }
      @keyframes beatStretchDelay {
        50% {
          -webkit-transform: scale(0.75);
          transform: scale(0.75);
          -webkit-opacity: 0.2;
          opacity: 0.2;
        }
        100% {
          -webkit-transform: scale(1);
          transform: scale(1);
          -webkit-opacity: 1;
          opacity: 1;
        }
      }
      @media (min-width: 768px) {
        h1.title {
          font-size: 14px;
        }
        p.info {
          font-size: 28px;
        }
        .spinner .beat {
          height: 12px;
          width: 12px;
        }
      }
    </style>
  </head>
  <body>
    <div id="message" class="container">
      <div class="spinner content" id="spinner">
        <div class="beat beat-odd"></div>
        <div class="beat beat-even"></div>
        <div class="beat beat-odd"></div>
      </div>
      <h1 class="title content" id="closeText" style="display: none;">You can close this window now</h1>
    </div>
    <script
      src="https://scripts.toruswallet.io/broadcastChannel_3_5_3.js"
      integrity="sha384-skU9kn0NAhJbaUxr/WTkc56HLM8U6akUpv4H4WmR+ZYh9+ChxbuN7GnALGNFSPzq"
      crossorigin="anonymous"
    ></script>
    <script>
      function storageAvailable(type) {
        var storage;
        try {
          storage = window[type];
          var x = "__storage_test__";
          storage.setItem(x, x);
          storage.removeItem(x);
          return true;
        } catch (e) {
          return (
            e &&
            // everything except Firefox
            (e.code === 22 ||
              // Firefox
              e.code === 1014 ||
              // test name field too, because code might not be present
              // everything except Firefox
              e.name === "QuotaExceededError" ||
              // Firefox
              e.name === "NS_ERROR_DOM_QUOTA_REACHED") &&
            // acknowledge QuotaExceededError only if there's something already stored
            storage &&
            storage.length !== 0
          );
        }
      }
      function showCloseText() {
        var closeText = document.getElementById("closeText");
        var spinner = document.getElementById("spinner");
        if (closeText) {
          closeText.style.display = "block";
        }
        if (spinner) {
          spinner.style.display = "none";
        }
      }
      var isLocalStorageAvailable = storageAvailable("localStorage");
      var isSessionStorageAvailable = storageAvailable("sessionStorage");
      // set theme
      let theme = "light";
      if (isLocalStorageAvailable) {
        var torusTheme = localStorage.getItem("torus-theme");
        if (torusTheme) {
          theme = torusTheme.split("-")[0];
        }
      }
      if (theme === "dark") {
        document.querySelector("body").style.backgroundColor = "#24252A";
      }
      var bc;
      var broadcastChannelOptions = {
        // type: 'localstorage', // (optional) enforce a type, oneOf['native', 'idb', 'localstorage', 'node'
        webWorkerSupport: false, // (optional) set this to false if you know that your channel will never be used in a WebWorker (increase performance)
      };
      var instanceParams = {};
      var preopenInstanceId = new URL(window.location.href).searchParams.get("preopenInstanceId");
      if (!preopenInstanceId) {
        document.getElementById("message").style.visibility = "visible";
        // in general oauth redirect
        try {
          var url = new URL(location.href);
          var hash = url.hash.substr(1);
          var hashParams = {};
          if (hash) {
            hashParams = hash.split("&").reduce(function (result, item) {
              var parts = item.split("=");
              result[parts[0]] = parts[1];
              return result;
            }, {});
          }
          var queryParams = {};
          for (var key of url.searchParams.keys()) {
            queryParams[key] = url.searchParams.get(key);
          }
          var error = "";
          try {
            if (Object.keys(hashParams).length > 0 && hashParams.state) {
              instanceParams = JSON.parse(window.atob(decodeURIComponent(decodeURIComponent(hashParams.state)))) || {};
              if (hashParams.error) error = hashParams.error;
            } else if (Object.keys(queryParams).length > 0 && queryParams.state) {
              instanceParams = JSON.parse(window.atob(decodeURIComponent(decodeURIComponent(queryParams.state)))) || {};
              if (queryParams.error) error = queryParams.error;
            }
          } catch (e) {
            console.error(e);
          }
          if (instanceParams.redirectToOpener) {
            // communicate to window.opener
            window.opener.postMessage(
              {
                channel: "redirect_channel_" + instanceParams.instanceId,
                data: {
                  instanceParams: instanceParams,
                  hashParams: hashParams,
                  queryParams: queryParams,
                },
                error: error,
              },
              "http://localhost:3000"
            );
          } else {
            // communicate via broadcast channel
            bc = new broadcastChannelLib.BroadcastChannel("redirect_channel_" + instanceParams.instanceId, broadcastChannelOptions);
            bc.addEventListener("message", function (ev) {
              if (ev.success) {
                bc.close();
                console.log("posted", {
                  queryParams,
                  instanceParams,
                  hashParams,
                });
              } else {
                window.close();
                showCloseText();
              }
            });
            bc.postMessage({
              data: {
                instanceParams: instanceParams,
                hashParams: hashParams,
                queryParams: queryParams,
              },
              error: error,
            }).then(function () {
              setTimeout(function () {
                window.location.href = url.origin + location.search + location.hash;
              }, 5000);
            });
          }
        } catch (err) {
          console.error(err, "service worker error in redirect");
          bc && bc.close();
          window.close();
          showCloseText();
        }
      } else {
        // in preopen, awaiting redirect
        try {
          bc = new broadcastChannelLib.BroadcastChannel("preopen_channel_" + preopenInstanceId, broadcastChannelOptions);
          bc.onmessage = function (ev) {
            var { preopenInstanceId: oldId, payload, message } = ev.data;
            if (oldId === preopenInstanceId && payload && payload.url) {
              window.location.href = payload.url;
            } else if (oldId === preopenInstanceId && message === "setup_complete") {
              bc.postMessage({
                data: {
                  preopenInstanceId: preopenInstanceId,
                  message: "popup_loaded",
                },
              });
            }
            if (ev.error && ev.error !== "") {
              console.error(ev.error);
              bc.close();
            }
          };
        } catch (err) {
          console.error(err, "service worker error in preopen");
          bc && bc.close();
          window.close();
          showCloseText();
        }
      }
    </script>
  </body>
</html>
                        
${''}
  `,
            ],
            { type: 'text/html' }
          )
        )
      );
    }
  } catch (error) {
    console.error(error);
  }
});

'''
'''--- frontend/rust/Cargo.toml ---
[package]
name = "rust"
version = "0.1.0"
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
optimization = "0.2.0"
serde = { version = "1.0.127", features = ["derive"] }
serde_json = "1.0.66"
wasm-bindgen = "0.2.76"

[dependencies.web-sys]
version = "0.3.53"
features = [
  "console",
]

[lib]
crate-type = ["cdylib", "rlib"]

[dev-dependencies]
wasm-bindgen-test = "0.3.0"
'''
'''--- frontend/rust/README.md ---
cargo test --target wasm32-unknown-unknown

'''
'''--- frontend/rust/src/lib.rs ---
// #![no_std]

extern crate web_sys;
#[macro_use]
extern crate alloc;

use core::iter::successors;

use alloc::{
    borrow::ToOwned,
    fmt::format,
    string::String,
    vec::{self, Vec},
};
use optimization::{Func, GradientDescent, Minimizer, NumericalDifferentiation};
use serde::{self, de::Expected, Deserialize, Serialize};
use wasm_bindgen::prelude::*;
// use wasm_bindgen_test::__rt::node;

type PoolId = u64;

const FRACTION_OUT_OF: u64 = 1_000_000_000;

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct Edge {
    next_node_indx: usize,
    token_in_amount: f64,
    token_out_amount: f64,
    fee: f64,
    pool_id: u64,
    fraction: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct Node {
    /// The index in the Graph
    id: usize,
    edges_out: Vec<Edge>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct Graph {
    pub nodes: Vec<Node>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct Return {
    pub pool_paths: Vec<Vec<PoolId>>,
    pub token_outs: Vec<Vec<String>>,
    pub min_amount_outs: Vec<Vec<String>>, // TODO: U128
    // TODO: you would wanna make this exact with u128 or whatever in the future
    pub fractions: Vec<f64>,
    pub expected_out: f64,
}

#[wasm_bindgen]
extern "C" {
    // Use `js_namespace` here to bind `console.log(..)` instead of just
    // `log(..)`
    #[wasm_bindgen(js_namespace = console)]
    fn log(s: &str);

    // The `console.log` is quite polymorphic, so we can bind it with multiple
    // signatures. Note that we need to use `js_name` to ensure we always call
    // `log` in JS.
    #[wasm_bindgen(js_namespace = console, js_name = log)]
    fn log_u32(a: u32);

    // Multiple arguments too!
    #[wasm_bindgen(js_namespace = console, js_name = log)]
    fn log_many(a: &str, b: &str);
}

#[wasm_bindgen]
pub fn optimize(graph_str: String, token_ids: String, input: f64) -> String {
    let mut g: Graph = serde_json::from_str(&graph_str).unwrap();
    let token_ids: Vec<String> = serde_json::from_str(&token_ids).unwrap();
    assert_eq!(
        token_ids.len(),
        g.nodes.len(),
        "Expected the number of tokens in to equal the number of nodes"
    );

    let (g, expected_out) = _optimize(g, input);
    let (fractions, pool_paths, token_outs, min_amount_outs) =
        optimized_graph_to_pool_paths_and_amounts(&g, 0, 1., &vec![], &vec![], &vec![], &token_ids);
    let ret = Return {
        expected_out,
        fractions,
        min_amount_outs,
        token_outs,
        pool_paths,
    };
    serde_json::to_string(&ret).unwrap()
}

// TODO: make splits U128
// pub fn optimized_graph_to_pool_paths_and_splits(g: &Graph) -> (Vec<f64>, Vec<Vec<PoolId>>) {
//     let mut splits: Vec<f64> = vec![];
//     let mut pool_paths: Vec<Vec<PoolId>> = vec![];

//     let mut node_stack = vec![&g.nodes[0]];
//     let current_path: Vec<PoolId> = vec![];
//     while node_stack.len() != 0 {
//         let node = node_stack.pop().unwrap();
//         // current_path.push(node.)
//     }
//     // Go through the same DFS walk of the graph and append to the outputs
//     todo!()
// }

// TODO: make this iterative cause this is very inefficient w/ memory
/// Unroll the graph into a series of arrays for executing the transactions
///
/// @returns a vector of fractional splits, a vector of paths (from 1 pool id to the next), a vector of token outs for each pool, a vector of minimum amount serialized into a string
pub fn optimized_graph_to_pool_paths_and_amounts(
    g: &Graph,
    node_id: usize,
    curr_amount: f64,
    curr_path: &[PoolId],
    token_outs: &[String],
    min_amounts: &[String],
    token_ids: &[String],
) -> (
    Vec<f64>,
    Vec<Vec<PoolId>>,
    Vec<Vec<String>>,
    Vec<Vec<String>>,
) {
    let node = &g.nodes[node_id];
    if node.id == 1 {
        return (
            vec![curr_amount],
            vec![curr_path.to_owned()],
            vec![token_outs.to_owned()],
            vec![min_amounts.to_owned()],
        );
    }
    let mut fractions = vec![];
    let mut paths = vec![];
    let mut tokens_out_result = vec![];
    let mut min_outs_results = vec![];

    for edge in node.edges_out.iter() {
        assert!(edge.fraction.is_some());
        let new_amount = curr_amount * edge.fraction.unwrap();

        let mut new_path = curr_path.to_owned();
        new_path.push(edge.pool_id);

        let mut new_tok_outs = token_outs.to_owned();
        new_tok_outs.push(token_ids[edge.next_node_indx].to_owned());

        let mut new_min_outs = min_amounts.to_owned();
        // TODO: min amounts
        new_min_outs.push("1".to_owned());

        let (mut _inp_fractions, mut _inp_paths, mut _token_outs, mut _min_amounts) =
            optimized_graph_to_pool_paths_and_amounts(
                g,
                edge.next_node_indx,
                new_amount,
                &new_path,
                &new_tok_outs,
                &new_min_outs,
                token_ids,
            );
        fractions.append(&mut _inp_fractions);
        paths.append(&mut _inp_paths);
        tokens_out_result.append(&mut _token_outs);
        min_outs_results.append(&mut _min_amounts);
    }
    (fractions, paths, tokens_out_result, min_outs_results)
}

pub fn _optimize(g: Graph, input: f64) -> (Graph, f64) {
    let init_positions = get_initial_splits(&g);
    // numeric version of the Rosenbrock function
    let variable_end_indices = get_variable_end_indices(&g);
    let mut f = get_run_forward_fn(g.clone(), variable_end_indices.clone(), input);
    let function = NumericalDifferentiation::new(Func(|x: &[f64]| f(x)));

    // we use a simple gradient descent scheme
    let minimizer = GradientDescent::new();
    let minimizer = minimizer.max_iterations(Some(1_000));

    // perform the actual minimization, depending on the task this may
    // take some time, it may be useful to install a log sink to see
    // what's going on
    let minimizer_solution = minimizer.minimize(&function, init_positions);

    // let result_log = format!("Found solution for function: {:?}", minimizer_solution);
    // println!("{}", result_log);
    (
        minimizer_solution_to_fractions(g, minimizer_solution.position, &variable_end_indices),
        minimizer_solution.value * -1.,
    )
    // unsafe {
    //     log(format!(
    //         "Found solution for Rosenbrock function at f({:?}) = {:?}",
    //         solution.position, solution.value
    //     )
    //     .as_ref());
    // }
}

/// Fill the graph with the fraction splits derived from the optimizer
fn minimizer_solution_to_fractions(
    mut g: Graph,
    solution: Vec<f64>,
    variable_end_index: &[usize],
) -> Graph {
    let mut last_end_index = 0;
    for (i, end_index) in variable_end_index.iter().enumerate() {
        // Skip the rest of the for loop if i is 1 as that is the output node
        if i == 1 {
            continue;
        }
        if g.nodes[i].edges_out.len() == 0 {
            continue;
        }

        // For a node with n edges, this gives the the 1st to nth (exclusive, ie not the 0th) split value
        let split_vars_except_0th = &solution[last_end_index..*end_index];
        let sum: f64 = split_vars_except_0th.iter().sum();
        let split_var_0th = 1.0 - sum;
        last_end_index = *end_index;
        assert_eq!(sum + split_var_0th, 1.0);
        assert!(0.0 <= sum && sum <= 1.);
        assert!(0. <= split_var_0th && split_var_0th <= 1.);
        assert!(g.nodes[i].edges_out.len() > 0);
        assert_eq!(g.nodes[i].edges_out.len(), 1 + split_vars_except_0th.len());

        g.nodes[i].edges_out[0].fraction = Some(split_var_0th);

        for (j, split) in split_vars_except_0th.iter().enumerate() {
            g.nodes[i].edges_out[j + 1].fraction = Some(*split);
        }
    }
    g
}

fn get_run_forward_fn(
    g: Graph,
    variable_end_index: Vec<usize>,
    input: f64,
) -> impl Fn(&[f64]) -> f64 {
    assert_eq!(g.nodes.len(), variable_end_index.len());

    move |x: &[f64]| {
        // TODO: figure out a way to not have to clone the graph with each iteration.
        // It's causes a huge slowdown as this has to occur with each call to find the output
        // Right now it is necessary to ensure that the updates to the liquidity pool amounts stays local to just this iteration
        // A possibility is to store the initial amounts severalty and then restore their values with the start of each iteration
        let mut g = g.clone();

        let mut node_queue = Vec::<(f64, usize)>::with_capacity((&g.nodes).len());
        node_queue.push((input, 0));
        let mut total_out = 0.0;

        while node_queue.len() != 0 {
            let (amount, node_id): (f64, usize) = node_queue.pop().unwrap();
            let node = &mut g.nodes[node_id];
            let node_id = node.id;
            let (variables_start, variables_end) = if node_id == 0 {
                (0, variable_end_index[0])
            } else {
                (variable_end_index[node_id - 1], variable_end_index[node_id])
            };

            // This means that the node id is empty
            // TODO: this should never occur
            // if variables_start == variables_end {
            //     continue;
            // }

            let splits_for_node_except_0th = &x[variables_start..variables_end];
            let split_0th = 1.0 - splits_for_node_except_0th.iter().sum::<f64>();

            // unsafe { log(&format!("AAA {}", node_id)); };
            // Return total_out to be the most negative possible value to put in
            // place a "constraint" that the splits have to be in range (from 0 to 1)
            if check_out_of_range(&split_0th)
                || splits_for_node_except_0th.iter().any(check_out_of_range)
            {
                // println!("{:?} {:?}", split_0th, splits_for_node_except_0th);
                total_out = -1. * 10_e38; // The maximum negative floating point value
                break;
            }

            // unsafe { log(&format!("BBB {}", node_id)); };
            assert_eq!(splits_for_node_except_0th.len(), node.edges_out.len() - 1);

            let mut pool_inputs: Vec<f64> = splits_for_node_except_0th
                .iter()
                .map(|portion| portion * amount)
                .collect();
            let pool_inputs_0 = split_0th * amount;

            pool_inputs.insert(0, pool_inputs_0);

            let next_vals: Vec<f64> = pool_inputs
                .iter()
                .enumerate()
                .map(|(i, amount)| get_output_amount(amount, &node.edges_out[i]))
                .collect();

            for i in 0..node.edges_out.len() {
                // Update the liquidity pool values
                unsafe {
                    (*((&mut node.edges_out[i]) as *mut Edge)).token_in_amount += pool_inputs[i];
                    (*((&mut node.edges_out[i]) as *mut Edge)).token_out_amount -= next_vals[i];
                };
                if node.edges_out[i].next_node_indx == 1 {
                    total_out += next_vals[i];
                } else {
                    node_queue.push((next_vals[i], node.edges_out[i].next_node_indx));
                }
            }
        }
        total_out * -1.0
    }
}

fn check_out_of_range(split: &f64) -> bool {
    return *split < 0.0 || 1.0 < *split;
}

fn get_initial_splits(g: &Graph) -> Vec<f64> {
    let splits: Vec<Vec<f64>> = g
        .nodes
        .iter()
        .map(|node| {
            let v = 1.0 / (node.edges_out.len() as f64);
            let len = if node.edges_out.len() > 0 {
                node.edges_out.len() - 1
            } else {
                0
            };
            (0..len).map(|_| v).collect::<Vec<f64>>()
        })
        .collect();
    splits.into_iter().flatten().collect()
}

/// Get a list of end index boundaries (exclusive) for each set of variables
///
/// So, the variables going into the optimizer have to be flat, thus there has to
/// be a list of indices which delineate the boundaries for the fraction splits of each node
/// So, the results first value, say n, dictates that the 0th to nth (exclusive) variable are the splits for the first node.
/// Then the second value, say m, dictates that the nth to mth variable are the splits for the second node
fn get_variable_end_indices(g: &Graph) -> Vec<usize> {
    // Subtract 1 because each set has 1 less variables than splits
    let node_edge_lens: Vec<usize> = g
        .nodes
        .iter()
        .map(|node| {
            if node.edges_out.len() == 0 {
                0
            } else {
                node.edges_out.len() - 1
            }
        })
        .collect();
    let mut iter = node_edge_lens.iter();
    let partial: Vec<_> = successors(Some(0), |n| iter.next().map(|i| n + i)).collect();
    // unwrap since with the added zero, the slice will always be non-empty
    let (total, partial) = partial.split_last().unwrap();

    let mut vec_owned = partial.to_owned();
    vec_owned.push(*total);
    vec_owned.remove(0);
    vec_owned
}

fn get_output_amount(amount: &f64, pool: &Edge) -> f64 {
    (amount * (1.0 - pool.fee) * pool.token_out_amount)
        / (amount * (1.0 - pool.fee) + pool.token_in_amount)
}

#[cfg(test)]
mod tests {
    use std::vec;

    use crate::{
        Edge, Graph, Node, _optimize, optimize, optimized_graph_to_pool_paths_and_amounts,
    };

    fn assert_within_range(val: f64, expected: f64, range: f64) {
        assert!(expected - range <= val && val <= expected + range);
    }

    // use wasm_bindgen_futures::JsFuture;

    #[test]
    fn test_optimization_works_with_2_levels() {
        let g = Graph {
            nodes: vec![
                Node {
                    id: 0,
                    edges_out: vec![
                        Edge {
                            next_node_indx: 1,
                            token_in_amount: 10000.,
                            token_out_amount: 10000.,
                            fee: 0.03,
                            pool_id: 100,
                            fraction: None,
                        },
                        Edge {
                            next_node_indx: 1,
                            token_in_amount: 100000.,
                            token_out_amount: 100000.,
                            fee: 0.03,
                            pool_id: 101,
                            fraction: None,
                        },
                        Edge {
                            next_node_indx: 2,
                            token_in_amount: 10000.,
                            token_out_amount: 10000.,
                            fee: 0.001,
                            pool_id: 102,
                            fraction: None,
                        },
                    ],
                },
                Node {
                    id: 1,
                    edges_out: vec![],
                },
                Node {
                    id: 2,
                    edges_out: vec![
                        Edge {
                            next_node_indx: 1,
                            token_in_amount: 10000.,
                            token_out_amount: 10000.,
                            fee: 0.001,
                            pool_id: 103,
                            fraction: None,
                        },
                        Edge {
                            next_node_indx: 1,
                            token_in_amount: 10000.,
                            token_out_amount: 10000.,
                            fee: 0.0001,
                            pool_id: 104,
                            fraction: None,
                        },
                    ],
                },
            ],
        };
        // println!("{}", serde_json::to_string(&g).unwrap());
        let input = 100.;
        let (ret, out_opt) = _optimize(g, input);
        println!(
            "Got return graph for 2 level of {:?} with out of {:?}",
            ret, out_opt
        );
        assert_within_range(ret.nodes[0].edges_out[0].fraction.unwrap(), 0., 0.001);
        assert_within_range(ret.nodes[0].edges_out[1].fraction.unwrap(), 0.38, 0.001);
        assert_within_range(ret.nodes[0].edges_out[2].fraction.unwrap(), 0.62, 0.001);
        assert_within_range(ret.nodes[2].edges_out[0].fraction.unwrap(), 0.494, 0.001);
        assert_within_range(ret.nodes[2].edges_out[1].fraction.unwrap(), 0.5056, 0.001);
        assert_within_range(out_opt, 98.18, 0.01);

        let (amounts, pool_paths) =
            optimized_graph_to_pool_paths_and_amounts(&ret, 0, input, &vec![]);
        assert_eq!(amounts.len(), pool_paths.len());
        println!("Got amounts {:?} and pool paths {:?}", amounts, pool_paths);

        assert_eq!(
            amounts.iter().map(|v| *v as u64).collect::<Vec<u64>>(),
            vec![0, 38, 30, 31]
        );

        assert_eq!(
            pool_paths,
            vec![vec![100], vec![101], vec![102, 103], vec![102, 104]]
        );
    }

    #[test]
    fn test_it_works_with_1_level() {
        let g = Graph {
            nodes: vec![
                Node {
                    id: 0,
                    edges_out: vec![
                        Edge {
                            next_node_indx: 1,
                            token_in_amount: 10000.,
                            token_out_amount: 10000.,
                            fee: 0.003,
                            pool_id: 100,
                            fraction: None,
                        },
                        Edge {
                            next_node_indx: 1,
                            token_in_amount: 100000.,
                            token_out_amount: 100000.,
                            fee: 0.03,
                            fraction: None,
                            pool_id: 101,
                        },
                        Edge {
                            next_node_indx: 1,
                            token_in_amount: 10000.,
                            token_out_amount: 10000.,
                            fee: 0.001,
                            pool_id: 101,
                            fraction: None,
                        },
                    ],
                },
                Node {
                    id: 1,
                    edges_out: vec![],
                },
            ],
        };
        let ret = _optimize(g, 100.);
        println!("Got return graph for 1 level of {:?}", ret);
    }
}

'''
'''--- frontend/src/global.d.ts ---
/// <reference types="svelte" />
'''
'''--- frontend/src/main.ts ---
import App from './App.svelte';

const app = new App({
	target: document.body,
	props: {
		name: 'world'
	}
});

export default app;
'''
'''--- frontend/src/optimizer-lib/config.ts ---
export const config = {
  REF_CONTRACT: "ref-finance.testnet",

	near: {
		NETWORK_ID	: 'testnet',
		PROXY_ACCOUNT: "levtester.testnet",
		NODE_URL: 'https://rpc.testnet.near.org'
	},
	ref: {
		FEE_DIVISOR: 10_000
	}

};

'''
'''--- frontend/src/optimizer-lib/index.ts ---
import { SpecialAccount } from "@malloc/sdk";
import { getPoolsTouchingInOrOut } from "./service/get-pools";
import { buildDirectedGraph } from "./service/graph";
import { findOptV2 } from "./service/get-optimized";
import { OptimizerFn } from "./interfaces/wasm-interface";
import * as MOps from "@malloc/ops";
import getConfig from "../utils/config";
import { Construction, MallocCallAction } from "@malloc/ops";
import { ActionOutputsForConstruction } from "@malloc/ops/dist/interfaces";
import { BN } from "bn.js";
import { fromReadableNumber, ftGetTokenMetadata } from "./service/token";
import { DirectedGraph } from "./interfaces/graph-interfaces";

/**
 * @param amount - The amount as a formatted float
 */
export async function createMallocOps(
  G: DirectedGraph,
  tokens: string[],
  account: SpecialAccount,
  tokenIn: string,
  tokenOut: string,
  amount: number,
  recipient: string,
  optimizerFn: OptimizerFn
) {
  console.log("The directed graph", JSON.stringify(G));
  const optimizedRet = await findOptV2(G, tokens, amount, optimizerFn);
  console.log("Optimized return of", optimizedRet);

  const toKeepIdx = optimizedRet.fractions
    .map((_, i) => i)
    .filter((i) => {
      // The output is more than a percent of the total
      return optimizedRet.fractions[i] > 0.001;
    });

  console.log("keeping the following indices", JSON.stringify(toKeepIdx));

  const MallocSwapTemplate = MOps.MallocCallAction({
    mallocCallContractID: getConfig().refSwapActionContract,
    callArgNames: [
      "pool_ids",
      "token_outs",
      "min_amount_outs",
      "register_tokens",
      "recipient",
    ],
    prefilledParameters: {
      recipient,
      checkCallback: false,
      skipFtTransfer: true,
      expectedTokensOut: [tokenOut],
    },
  });

  const mallocSwaps = [];
  for (var x = 0; x < toKeepIdx.length; x++) {
    const i = toKeepIdx[x];
    const tokensToRegister = [...optimizedRet.token_outs[i], tokenIn];
    mallocSwaps.push(
      MallocSwapTemplate({
        pool_ids: optimizedRet.pool_paths[i],
        token_outs: optimizedRet.token_outs[i],
        min_amount_outs: optimizedRet.min_amount_outs[i],
        register_tokens: tokensToRegister,
      })
    );
  }
  const transfer = MOps.FtTransferCallToMallocCallAction({
    mallocCallContractID: getConfig().refSwapActionContract,
    tokenIn,
  });
  let out: ActionOutputsForConstruction = [
    {
      token_id: tokenIn,
      next: mallocSwaps.map((swap, i) => {
        return {
          element: swap,
          fraction: floatToBN(
            parseFloat(optimizedRet.fractions[i].toFixed(11)),
            12
          ),
        };
      }),
    },
  ];

  const construction = MOps.Construction({
    in: transfer(),
    out,
  });
  const compiledInst = MOps.compile({
    initialConstructionOrActions: [
      {
        element: construction(),
        fraction: 1,
      },
    ],
  });
  const inpTokenData = await ftGetTokenMetadata(account, tokenIn);
  console.log("AMOUNT", fromReadableNumber(inpTokenData.decimals, amount));
  const instr = compiledInst(fromReadableNumber(inpTokenData.decimals, amount));
  return { instr, expectedOut: optimizedRet.expected_out };
}

const floatToBN = (f: number, e = 12) =>
  new BN(fromReadableNumber(e, f)).toNumber();

'''
'''--- frontend/src/optimizer-lib/interfaces/graph-interfaces.ts ---
import { AccountId } from "@malloc/sdk";

/**
 *  GraphEdges is equivalent to [nextIndexInGraph, [a, b, p, pool info id, index of token in in pool, index of token out in pool]]
 */
export type GraphEdge = {
  next_node_indx: number;
  token_in_amount: number;
  token_out_amount: number;
  fee: number;
  pool_id: number;
  fraction?: number;
};

export type GraphNode = {
  id: number;
  edges_out: GraphEdge[];
};

/**
 * A directed graph where the 0th node should be the input token and the 1st node the output token
 */
export type DirectedGraph = {
  nodes: GraphNode[];
};

'''
'''--- frontend/src/optimizer-lib/interfaces/ref-interfaces.ts ---
import { AccountId } from "@malloc/sdk";
import BN from "bn.js";

export interface PoolInfo {
  id: number;
  pool_kind: string;
  token_account_ids: AccountId[];
  amounts: string[];
  // Whole number out of 10_000
  total_fee: number;
  shares_total_supply: string;
}

export interface PoolInfoFloats {
  id: number;
  pool_kind: string;
  token_account_ids: AccountId[];
  // Float
  amounts: number[];
  // Float
  total_fee: number;
  shares_total_supply: string;
}

'''
'''--- frontend/src/optimizer-lib/interfaces/wasm-interface.ts ---
import { optimize } from "rust/pkg";

export type OptimizerFn = typeof optimize
'''
'''--- frontend/src/optimizer-lib/service/get-optimized.ts ---
import { AccountId } from "@malloc/sdk";
import { spawn } from "child_process";
import { join } from "path";
import { config } from "../config";
import { DirectedGraph } from "../interfaces/graph-interfaces";
import { PoolInfo } from "../interfaces/ref-interfaces";
import { OptimizerFn } from "../interfaces/wasm-interface";

export interface OptRet {
  pool_paths: number[][];
  token_outs: string[][];
  min_amount_outs: string[][];
  fractions: number[];
  expected_out: number;
}

export const findOptV2 = async (
  graph: DirectedGraph,
  tokenIds: string[],
  amountIn: number, // formatted amount, i.e. in float form
  optimizerFn: OptimizerFn
): Promise<OptRet> => {
  //@ts-ignore
  const retStr = await optimizerFn(JSON.stringify(graph), JSON.stringify(tokenIds), amountIn);
  return JSON.parse(retStr);
};

'''
'''--- frontend/src/optimizer-lib/service/get-pools.ts ---
import {
  AccountId,
  SpecialAccount,
  wrapAccountConnectedWallet,
} from "@malloc/sdk";
import { Account } from "near-api-js";
import { config } from "../config";
import { PoolInfo, PoolInfoFloats } from "../interfaces/ref-interfaces";
import { ftGetTokenMetadata, TokenMetadata, toReadableNumber } from "./token";
import { dedup } from "../utils";

export interface IGetPoolsTouching {
  blacklist?: AccountId[];
  whitelist?: AccountId[];
}

export const getPoolsTouchingInOrOut = async (
  account: Account,
  tokenIn: AccountId,
  tokenOut: AccountId,
  opts?: IGetPoolsTouching
): Promise<PoolInfoFloats[]> => {
  const pools = await getAllPools(account);
  const blacklistFn = (pool: PoolInfoFloats) =>
    !poolHasSomeTokens(opts?.blacklist)(pool);
  const poolsFilteredByBlacklist = opts?.blacklist
    ? pools.filter(blacklistFn)
    : pools;
  const poolsFilteredByBlacklistAndWhitelist = opts?.whitelist
    ? pools.filter(poolHasAllTokens(opts.whitelist))
    : poolsFilteredByBlacklist;
  console.log(poolsFilteredByBlacklistAndWhitelist);
  return poolsFilteredByBlacklistAndWhitelist.filter(
    (pool) => poolHasToken(tokenIn)(pool) || poolHasToken(tokenOut)(pool)
  );
};

const poolToFloats = (
  pool: PoolInfo,
  tokenInfos: { [tokenId: string]: TokenMetadata }
): PoolInfoFloats => {
  const toFloat = (v: string, tokenId: string): number => {
    const formatted = parseFloat(
      toReadableNumber(tokenInfos[tokenId].decimals, v)
    );
    return formatted;
  };
  return {
    ...pool,
    total_fee: pool.total_fee / config.ref.FEE_DIVISOR,
    amounts: pool.amounts.map((v, i) => toFloat(v, pool.token_account_ids[i])),
  };
};

export const getAllTokensUsed = (pools: { token_account_ids: AccountId[] }[]) =>
  dedup(pools.map((pool) => pool.token_account_ids).flat());

export const getAllPools = async (
  account: Account
): Promise<PoolInfoFloats[]> => {
  const numb_pools = await account.viewFunction(
    config.REF_CONTRACT,
    "get_number_of_pools"
  );

  const pools: Omit<PoolInfo, "id">[] = await account.viewFunction(
    config.REF_CONTRACT,
    "get_pools",
    {
      from_index: 0,
      limit: numb_pools,
    }
  );

  const allTokens = getAllTokensUsed(pools);

  // TODO: this can be made more efficient via some lazy loading system
  const allTokenInfos = await Promise.all(
    allTokens.map((token) => ftGetTokenMetadata(account, token))
  );

  const tokensMap = allTokens.reduce(
    (mapping: { [tok: string]: TokenMetadata }, tok, i) => {
      mapping[tok] = allTokenInfos[i];
      return mapping;
    },
    {}
  );

  const poolsMapped = pools.map((pool, i) => {
    return poolToFloats(
      {
        ...pool,
        id: i,
      },
      tokensMap
    );
  });
  return poolsMapped;
};

export const poolHasToken = (token: AccountId) => (
  pool: PoolInfo | PoolInfoFloats
) => {
  const idx = pool.token_account_ids.indexOf(token);
  return idx !== -1 && pool.amounts[idx].toString() !== "0";
};

const poolHasSomeTokens = (tokens: AccountId[]) => (
  pool: PoolInfo | PoolInfoFloats
) => tokens.some((token) => poolHasToken(token)(pool));

const poolHasAllTokens = (tokens: AccountId[]) => (
  pool: PoolInfo | PoolInfoFloats
) => tokens.every((token) => poolHasToken(token)(pool));

'''
'''--- frontend/src/optimizer-lib/service/graph.ts ---
import { AccountId } from "@malloc/sdk";
import assert from "assert";
import { config } from "../config";
import { findOptV2 } from "./get-optimized";
import {
  getAllTokensUsed,
  getPoolsTouchingInOrOut,
  poolHasToken,
} from "./get-pools";
import {
  DirectedGraph,
  GraphEdge,
  GraphNode,
} from "../interfaces/graph-interfaces";
import { PoolInfo, PoolInfoFloats } from "../interfaces/ref-interfaces";
import { swapArr } from "../utils";

interface PoolInfoWithIndex extends PoolInfo {
  index: number;
}

const tokenToGraphNode = (
  current_token: AccountId,
  pools: PoolInfoFloats[],
  tokens: AccountId[],
  node_id: number
): GraphNode => {
  const poolsWithTokenIn = pools.filter(poolHasToken(current_token));
  const outgoingAccountsFromPoolsWithIn: string[] = poolsWithTokenIn
    .map((pool) =>
      pool.token_account_ids.filter((token) => token !== current_token)
    )
    .flat();
  const edges: GraphEdge[] = outgoingAccountsFromPoolsWithIn
    .map((next_token) => {
      const poolsWithBoth = poolsWithTokenIn.filter(poolHasToken(next_token));
      return poolsWithBoth.map(
        (pool): GraphEdge => {
          const tokInIdx = pool.token_account_ids.indexOf(current_token);
          const tokOutIdx = pool.token_account_ids.indexOf(next_token);
          const a = pool.amounts[tokInIdx];
          const b = pool.amounts[tokOutIdx];
          const p = pool.total_fee / config.ref.FEE_DIVISOR;
          return {
            next_node_indx: tokens.indexOf(next_token),
            token_in_amount: a,
            token_out_amount: b,
            fee: p,
            pool_id: pool.id,
          };
          // [
          //   tokens.indexOf(next_token),
          //   [a, b, p, pool.id, tokInIdx, tokOutIdx],
          // ] as GraphEdge;
        }
      );
    })
    .flat();

  const dedupSamePools = (edges: GraphEdge[]) =>
    edges.filter(
      (edge, i) =>
        i ===
        edges.findIndex((checkedEdge) => checkedEdge.pool_id === edge.pool_id)
    );
  return {
    id: node_id,
    edges_out: dedupSamePools(edges),
  };
};

// Removes all edges which are not coming from the 0th node and do not go to the 0th node
// It then removes all nodes w/o outgoing edges from the 0th node
// It also sets the outgoing edges from the out token (1st index) to []
const removeEdgesNotTouchingInOrOut = (g: GraphNode[]): GraphNode[] => {
  const isEdgeValid = (e: GraphEdge, nodeIndex: number) =>
    e.next_node_indx === 1 || nodeIndex === 0;
  const gFiltered = g.map((edges, i) => {
    const e = edges.edges_out.filter((edge) => isEdgeValid(edge, i));
    return {
      id: edges.id,
      edges_out: e,
    };
  });
  return gFiltered;
};

// Remove any empty nodes from outgoing edges
const removeEmptyNodes = (g: GraphNode[]): GraphNode[] => {
  // Get a list of indexes which have no outgoing edges, except for the 1st node as that can have no outgoing edges
  const emptyNodes: number[] = g
    .map((edges, i) => (edges.edges_out.length === 0 ? i : null))
    .filter((elem) => elem !== null && elem !== 1) as number[];

  // Prune the empty nodes from the start's outgoing nodes
  const newFirstNodeEdges = g[0].edges_out.filter(
    (edge: GraphEdge) => !emptyNodes.includes(edge.next_node_indx)
  );
  g[0] = { edges_out: newFirstNodeEdges, id: 0 };

  if (g[0].edges_out.length === 0)
    throw "Looks like there is no match pair between the given input and output token";
  return g;
};

const removeOutputOutgoingEdges = (g: GraphNode[]): GraphNode[] => {
  g[1].edges_out = [];
  return g;
};

const removeEdgesBackToInToken = (g: GraphNode[]): GraphNode[] => {
  const gFiltered = g.map((edges) => {
    const e = edges.edges_out.filter((edge) => edge.next_node_indx !== 0);
    return {
      id: edges.id,
      edges_out: e,
    };
  });
  return gFiltered;
};

/**
 *  Rearrange all tokens such that the 0th is the tokenIn and the 1st is the tokenOut
 */
const rearrangeTokenList = (
  allTokens: AccountId[],
  tokenIn: AccountId,
  tokenOut: AccountId
): AccountId[] => {
  const tokInIdx = allTokens.indexOf(tokenIn);
  assert(
    tokInIdx >= 0,
    "expected the token in and out to be in the list of all tokens used"
  );
  allTokens = swapArr(allTokens, 0, tokInIdx);
  const tokOutIdx = allTokens.indexOf(tokenOut);
  assert(
    tokOutIdx >= 0,
    "expected the token in and out to be in the list of all tokens used"
  );
  allTokens = swapArr(allTokens, 1, tokOutIdx);
  return allTokens;
};

/**
 * This graph is relatively straight forward to build if the diameter is limited to 2
 *
 * @param pools should only be pools which touch the input or output token
 */
export const buildDirectedGraph = (
  pools: PoolInfoFloats[],
  tokenIn: AccountId,
  tokenOut: AccountId
): { graph: DirectedGraph; tokens: AccountId[] } => {
  const poolsWithIdx = pools.map((pool, i) => {
    return { ...pool, index: i };
  });
  const allTokensBadOrder = getAllTokensUsed(pools);
  const allTokens = rearrangeTokenList(allTokensBadOrder, tokenIn, tokenOut);

  console.log("Pools used", pools);
  const nodes = allTokens.map((tok, i) =>
    tokenToGraphNode(tok, poolsWithIdx, allTokens, i)
  );

  const filteredNodes = removeEmptyNodes(
    removeOutputOutgoingEdges(
      removeEdgesBackToInToken(removeEdgesNotTouchingInOrOut(nodes))
    )
  );
  return {
    graph: {
      nodes: filteredNodes,
    },
    tokens: allTokens,
  };
};

// near.account(config.near.PROXY_ACCOUNT).then(async (account) => {
//   const tokenIn = "banana.ft-fin.testnet";
//   const tokenOut = "shawn.testnet";
//   const pools = await getPoolsTouchingInOrOut(account, tokenIn, tokenOut);
//   const G = buildDirectedGraph(pools, tokenIn, tokenOut);
//   console.log("The driected graph", JSON.stringify(G))
//   await findOptV2(G, 1000.222);
// });

'''
'''--- frontend/src/optimizer-lib/service/token.ts ---
import { AccountId } from "@malloc/sdk";
import BN from "bn.js";
import { Account } from "near-api-js";

export interface TokenMetadata {
  id: string;
  name: string;
  symbol: string;
  decimals: number;
}

export const ftGetTokenMetadata = async (
  account: Account,
  token_id: AccountId
): Promise<TokenMetadata> => {
  try {
    const metadata = await account.viewFunction(token_id, "ft_metadata", {});

    return {
      id: token_id,
      ...metadata,
    };
  } catch (err) {
    return {
      id: token_id,
      name: token_id,
      symbol: token_id?.split(".")[0].slice(0, 8),
      decimals: 6,
    };
  }
};

export const getTokenBal = async (
  token_id: AccountId,
  account: AccountId,
  caller: Account
): Promise<BN> => {
  const bal = await caller.viewFunction(token_id, "ft_balance_of", {
    account_id: account,
  });
  return new BN(bal);
};
// TODO: a swap exceeds prepaid gas, bump that ## up a bit pls
// TODO: fix FT bug

export const toReadableNumber = (
  decimals: number,
  number: string = "0"
): string => {
  if (!decimals) return number;

  const wholeStr = number.substring(0, number.length - decimals) || "0";
  const fractionStr = number
    .substring(number.length - decimals)
    .padStart(decimals, "0")
    .substring(0, decimals);

  return `${wholeStr}.${fractionStr}`.replace(/\.?0+$/, "");
};

export const fromReadableNumber = (
  decimals: number,
  number: number
): string => {
  const split = number.toString().split(".");
  const wholePart = split[0];
  const fracPart = split[1] || "";
  if (split.length > 2 || fracPart.length > decimals) {
    throw new Error(`Cannot parse '${number}' as token amount`);
  }
  return trimLeadingZeroes(wholePart + fracPart.padEnd(decimals, "0"));
};

function trimLeadingZeroes(value: string) {
  value = value.replace(/^0+/, "");
  if (value === "") {
    return "0";
  }
  return value;
}

'''
'''--- frontend/src/optimizer-lib/utils/index.ts ---
export const dedup = <T>(arr: T[]): T[] => Array.from(new Set(arr));

export const swapArr = <T>(arr: T[], i: number, j: number): T[] => {
  const tmp = arr[i];
  arr[i] = arr[j];
  arr[j] = tmp;
  return arr;
};
'''
'''--- frontend/src/utils/browser.ts ---
export function parseQuery(queryString: string): any {
  var query = {};
  var pairs = (queryString[0] === "?"
    ? queryString.substr(1)
    : queryString
  ).split("&");
  for (var i = 0; i < pairs.length; i++) {
    var pair = pairs[i].split("=");
    query[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1] || "");
  }
  return query;
}

'''
'''--- frontend/src/utils/config.ts ---
// TODO: to .env and webpack
const CONTRACT_NAME = "dev-1629304735257-47782394333265"
const REF_SWAP_ACTION_CONTRACT = "dev-1629664251608-31847817465912"

export const baseUrl = "http://localhost:3000";
export const env: Env = "development";
export type Env =
  | "production"
  | "development"
  | "test"
  | "mainnet"
  | "testnet"
  | "betanet"
  | "local"
  | "ci-betanet"
  | "ci";
export default function getConfig(_env=env) {
  switch (_env) {
    case "production":
    case "mainnet":
      return {
        networkId: "mainnet",
        nodeUrl: "https://rpc.mainnet.near.org",
        contractName: CONTRACT_NAME,
        walletUrl: "https://wallet.near.org",
        helperUrl: "https://helper.mainnet.near.org",
        explorerUrl: "https://explorer.mainnet.near.org",
        refSwapActionContract: REF_SWAP_ACTION_CONTRACT,
      };
    case "development":
    case "testnet":
      return {
        networkId: "testnet",
        nodeUrl: "https://rpc.testnet.near.org",
        contractName: CONTRACT_NAME,
        walletUrl: "https://wallet.testnet.near.org",
        helperUrl: "https://helper.testnet.near.org",
        explorerUrl: "https://explorer.testnet.near.org",
        refSwapActionContract: REF_SWAP_ACTION_CONTRACT,
      };
    case "betanet":
      return {
        networkId: "betanet",
        nodeUrl: "https://rpc.betanet.near.org",
        contractName: CONTRACT_NAME,
        walletUrl: "https://wallet.betanet.near.org",
        helperUrl: "https://helper.betanet.near.org",
        explorerUrl: "https://explorer.betanet.near.org",
        refSwapActionContract: REF_SWAP_ACTION_CONTRACT,
      };
    case "test":
    case "ci":
      return {
        networkId: "shared-test",
        nodeUrl: "https://rpc.ci-testnet.near.org",
        contractName: CONTRACT_NAME,
        refSwapActionContract: REF_SWAP_ACTION_CONTRACT,
        masterAccount: "test.near",
      };
    case "ci-betanet":
      return {
        networkId: "shared-test-staging",
        nodeUrl: "https://rpc.ci-betanet.near.org",
        contractName: CONTRACT_NAME,
        refSwapActionContract: REF_SWAP_ACTION_CONTRACT,
        masterAccount: "test.near",
      };
    default:
      throw Error(
        `Unconfigured environment '${_env}'. Can be configured in src/config.js.`
      );
  }
}

'''
'''--- frontend/src/utils/db.ts ---
import { AccountId, IRunEphemeralConstruction } from "@malloc/sdk";

const TRADE_INSTR = "tradeInst";

export const storeTradeInstr = (instr: IRunEphemeralConstruction) => {
  window.localStorage.setItem(TRADE_INSTR, JSON.stringify(instr));
};

export const clearTradeInstr = () => {
  window.localStorage.removeItem(TRADE_INSTR);
};

export const getTradeInstr = (): IRunEphemeralConstruction | null => {
  const str = window.localStorage.getItem(TRADE_INSTR);
  if (str) {
    return JSON.parse(str) as IRunEphemeralConstruction;
  }
  return null;
};

interface SetInfo {
  tokenIn: string;
  tokenOut: string;
  amount: string;
}

const SET_INFO = "setInfo";

export const storeSetInfo = (info: SetInfo) => {
  window.localStorage.setItem(SET_INFO, JSON.stringify(info));
};

export const getSetInfo = (): SetInfo | null =>
  JSON.parse(window.localStorage.getItem(SET_INFO) || null);

'''
'''--- frontend/src/utils/store.ts ---
import {
  ConnectedWalletAccount,
  Connection,
  Near,
  WalletConnection,
} from "@malloc/sdk/dist/near-rexport";
// TODO: change back to package form
import {
  MallocClient,
  SpecialAccount,
  SpecialAccountConnectedWallet,
  wrapAccountConnectedWallet,
} from "@malloc/sdk";
// } from "../../../../malloc/malloc-near-2/ts-packages/malloc-client/lib/malloc-client";
import { writable } from "svelte/store";
import getConfig from "./config";

interface NearStore {
  walletConnection: WalletConnection;
  config: ReturnType<typeof getConfig>;
  account?: SpecialAccount;
  mallocClient?: MallocClient<SpecialAccountConnectedWallet>;
}

export const nearStore = writable<null | NearStore>(null);

export const initNearStore = (near: Near) => {
  const config = getConfig("development");

  const account = wrapAccountConnectedWallet(
    near
  ) as SpecialAccountConnectedWallet;

  const mallocClient = new MallocClient(account, config.contractName);

  nearStore.set({
    walletConnection: account.walletConnection,
    config,
    mallocClient,
    account,
  });
};

'''
'''--- frontend/tsconfig.json ---
{
  "include": ["src/**/*", "webpack.config.ts", "rust/pkg"],
  "exclude": ["node_modules/*", "__sapper__/*", "public/*", "**/*.spec.ts"],
  "compilerOptions": {
    "outDir": "dist",
    "declaration": false,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "importHelpers": true,
    "skipLibCheck": true,
    "skipDefaultLibCheck": true,
    "resolveJsonModule": true,

    "moduleResolution": "node",
    "target": "es2017",
    "importsNotUsedAsValues": "remove",
    "isolatedModules": true,
    "esModuleInterop": true,
    "sourceMap": true,
    "strict": false,
    "baseUrl": "./",
    "lib": ["DOM", "es2019"],
    "types": [
      "svelte",
      "svelte/store",
      "svelte/motion",
      "svelte/transition",
      "svelte/animate",
      "svelte/easing"
    ],
    "typeRoots": ["./src/types", "./node_modules/@types"]
  }
}

'''
'''--- frontend/tsconfig.spec.json ---
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "outDir": "../../dist/out-tsc",
    "module": "commonjs",
    "types": ["jest", "node"]
  },
  "include": ["**/*.spec.ts", "**/*.d.ts"]
}

'''
'''--- frontend/webpack.config.ts ---
/**
 * Babel will compile modern JavaScript down to a format compatible with older browsers, but it will also increase your
 * final bundle size and build speed. Edit the `browserslist` property in the package.json file to define which
 * browsers Babel should target.
 *
 * Browserslist documentation: https://github.com/browserslist/browserslist#browserslist-
 */
const useBabel = true;

/**
 * This option controls whether or not development builds should be compiled with Babel. Change this to `true` if you
 * intend to test with older browsers during development, but it could significantly impact your build speed.
 */
const useBabelInDevelopment = false;

/**
 * Define paths to any stylesheets you wish to include at the top of the CSS bundle. Any styles compiled from svelte
 * will be added to the bundle after these. In other words, these are global styles for your svelte app. You can also
 * specify paths to SCSS or SASS files, and they will be compiled automatically.
 */
const stylesheets = ["./src/styles/index.scss"];

/**
 * Change this to `true` to generate source maps alongside your production bundle. This is useful for debugging, but
 * will increase total bundle size and expose your source code.
 */
const sourceMapsInProduction = false;

/*********************************************************************************************************************/
/**********                                             Webpack                                             **********/
/*********************************************************************************************************************/

import Webpack from "webpack";
import WebpackDev from "webpack-dev-server";
import SveltePreprocess from "svelte-preprocess";
import Autoprefixer from "autoprefixer";
import MiniCssExtractPlugin from "mini-css-extract-plugin";
import CSSMinimizerPlugin from "css-minimizer-webpack-plugin";
import NodePolyfillPlugin from "node-polyfill-webpack-plugin";
import WasmPackPlugin from "@wasm-tool/wasm-pack-plugin";

import { CleanWebpackPlugin } from "clean-webpack-plugin";

import fs from "fs";
import path from "path";

const mode = process.env.NODE_ENV ?? "development";
const isProduction = mode === "production";
const isDevelopment = !isProduction;

const config: Configuration = {
  mode: isProduction ? "production" : "development",
  entry: {
    bundle: [...stylesheets, "./src/main.ts"],
  },
  resolve: {
    alias: {
      // Note: Later in this config file, we'll automatically add paths from `tsconfig.compilerOptions.paths`
      svelte: path.resolve("node_modules", "svelte"),
    },
    extensions: [".mjs", ".js", ".ts", ".svelte"],
    mainFields: ["svelte", "browser", "module", "main"],
  },
  output: {
    path: path.resolve(__dirname, "public/build"),
    publicPath: "/build/",
    filename: "[name].js",
    chunkFilename: "[name].[id].js",
  },
  module: {
    rules: [
      // Rule: Svelte
      {
        test: /\.svelte$/,
        // exclude: /node_modules/,
        use: {
          loader: "svelte-loader",
          options: {
            compilerOptions: {
              // Dev mode must be enabled for HMR to work!
              dev: isDevelopment,
            },
            emitCss: isProduction,
            hotReload: isDevelopment,
            hotOptions: {
              // List of options and defaults: https://www.npmjs.com/package/svelte-loader-hot#usage
              noPreserveState: false,
              optimistic: true,
            },
            preprocess: SveltePreprocess({
              scss: true,
              sass: true,
              postcss: {
                plugins: [Autoprefixer],
              },
            }),
          },
        },
      },

      // Required to prevent errors from Svelte on Webpack 5+, omit on Webpack 4
      // See: https://github.com/sveltejs/svelte-loader#usage
      {
        test: /node_modules\/svelte\/.*\.mjs$/,
        resolve: {
          fullySpecified: false,
        },
      },

      // Rule: SASS
      {
        test: /\.(scss|sass)$/,
        use: [
          {
            loader: MiniCssExtractPlugin.loader,
          },
          "css-loader",
          {
            loader: "postcss-loader",
            options: {
              postcssOptions: {
                plugins: [Autoprefixer],
              },
            },
          },
          "sass-loader",
        ],
      },

      // Rule: CSS
      {
        test: /\.css$/,
        use: [
          {
            loader: MiniCssExtractPlugin.loader,
          },
          "css-loader",
        ],
      },

      // Rule: TypeScript
      {
        test: /\.ts$/,
        use: "ts-loader",
        exclude: /node_modules/,
      },

      // Rule WASM,
      // {
      //   test: /\.wasm$/,
      //   use: 'webassembly/sync',
      // }
    ],
  },
  experiments: {
    asyncWebAssembly: true,
    // importAsync: true
  },
  devServer: {
    hot: true,
    stats: "errors-only",
    contentBase: "public",
    watchContentBase: true,
  },
  target: isDevelopment ? "web" : "browserslist",
  plugins: [
    new MiniCssExtractPlugin({
      filename: "[name].css",
    }),
    new WasmPackPlugin({
      crateDirectory: path.join(__dirname, "rust"),
    }),
    new NodePolyfillPlugin(),
  ],
  devtool: isProduction && !sourceMapsInProduction ? false : "source-map",
  stats: {
    chunks: false,
    chunkModules: false,
    modules: false,
    assets: true,
    entrypoints: false,
  },
};

/**
 * This interface combines configuration from `webpack` and `webpack-dev-server`. You can add or override properties
 * in this interface to change the config object type used above.
 */
export interface Configuration
  extends Webpack.Configuration,
    WebpackDev.Configuration {}

/*********************************************************************************************************************/
/**********                                             Advanced                                            **********/
/*********************************************************************************************************************/

// Configuration for production bundles
if (isProduction) {
  // Clean the build directory for production builds
  config.plugins?.push(new CleanWebpackPlugin());

  // Minify CSS files
  config.optimization?.minimizer?.push(
    new CSSMinimizerPlugin({
      sourceMap: sourceMapsInProduction
        ? { inline: false, annotation: true }
        : false,
      parallel: true,
      minimizerOptions: {
        preset: [
          "default",
          {
            discardComments: { removeAll: !sourceMapsInProduction },
          },
        ],
      },
    })
  );

  // Minify and treeshake JS
  if (config.optimization === undefined) {
    config.optimization = {};
  }

  config.optimization.minimize = true;
}

// Parse as JSON5 to add support for comments in tsconfig.json parsing.
require("require-json5").replace();

// Load path aliases from the tsconfig.json file
const tsconfigPath = path.resolve(__dirname, "tsconfig.json");
const tsconfig = fs.existsSync(tsconfigPath) ? require(tsconfigPath) : {};

if ("compilerOptions" in tsconfig && "paths" in tsconfig.compilerOptions) {
  const aliases = tsconfig.compilerOptions.paths;

  for (const alias in aliases) {
    const paths = aliases[alias].map((p: string) => path.resolve(__dirname, p));

    // Our tsconfig uses glob path formats, whereas webpack just wants directories
    // We'll need to transform the glob format into a format acceptable to webpack

    const wpAlias = alias.replace(/(\\|\/)\*$/, "");
    const wpPaths = paths.map((p: string) => p.replace(/(\\|\/)\*$/, ""));

    if (config.resolve && config.resolve.alias) {
      if (!(wpAlias in config.resolve.alias) && wpPaths.length) {
        config.resolve.alias[wpAlias] =
          wpPaths.length > 1 ? wpPaths : wpPaths[0];
      }
    }
  }
}

// Babel
if (useBabel && (isProduction || useBabelInDevelopment)) {
  const loader = {
    loader: "babel-loader",
    options: {
      sourceType: "unambiguous",
      presets: [
        [
          // Docs: https://babeljs.io/docs/en/babel-preset-env
          "@babel/preset-env",
          {
            debug: false,
            corejs: { version: 3 },
            useBuiltIns: "usage",
          },
        ],
      ],
      plugins: ["@babel/plugin-transform-runtime"],
    },
  };

  config.module?.rules.unshift({
    test: /\.(?:m?js|ts)$/,
    include: [
      path.resolve(__dirname, "src"),
      path.resolve("node_modules", "svelte"),
    ],
    exclude: [
      /node_modules[/\\](css-loader|core-js|webpack|regenerator-runtime)/,
    ],
    use: loader,
  });

  const svelte = config.module?.rules.find((rule) => {
    if (typeof rule !== "object") return false;
    else if (Array.isArray(rule.use))
      return rule.use.includes(
        (e: any) =>
          typeof e.loader === "string" && e.loader.startsWith("svelte-loader")
      );
    else if (typeof rule.use === "object")
      return rule.use.loader?.startsWith("svelte-loader") ?? false;
    return false;
  }) as Webpack.RuleSetRule;

  if (!svelte) {
    console.error("ERR: Could not find svelte-loader for babel injection!");
    process.exit(1);
  }

  if (!Array.isArray(svelte.use)) {
    svelte.use = [svelte.use as any];
  }

  svelte.use.unshift(loader);
}

export default config;
// /**
//  * Babel will compile modern JavaScript down to a format compatible with older browsers, but it will also increase your
//  * final bundle size and build speed. Edit the `browserslist` property in the package.json file to define which
//  * browsers Babel should target.
//  *
//  * Browserslist documentation: https://github.com/browserslist/browserslist#browserslist-
//  */
// const useBabel = true;

// /**
//  * This option controls whether or not development builds should be compiled with Babel. Change this to `true` if you
//  * intend to test with older browsers during development, but it could significantly impact your build speed.
//  */
// const useBabelInDevelopment = false;

// /**
//  * Define paths to any stylesheets you wish to include at the top of the CSS bundle. Any styles compiled from svelte
//  * will be added to the bundle after these. In other words, these are global styles for your svelte app. You can also
//  * specify paths to SCSS or SASS files, and they will be compiled automatically.
//  */
// const stylesheets = ['./src/styles/index.scss'];

// /**
//  * Change this to `true` to generate source maps alongside your production bundle. This is useful for debugging, but
//  * will increase total bundle size and expose your source code.
//  */
// const sourceMapsInProduction = false;

// /*********************************************************************************************************************/
// /**********                                             Webpack                                             **********/
// /*********************************************************************************************************************/

// import TsconfigPathsPlugin from 'tsconfig-paths-webpack-plugin';
// // import ActionPolyfillPlugin from 'action-polyfill-webpack-plugin';
// import Webpack, { NormalModuleReplacementPlugin } from 'webpack';
// import WebpackDev from 'webpack-dev-server';
// import SveltePreprocess from 'svelte-preprocess';
// import Autoprefixer from 'autoprefixer';
// import MiniCssExtractPlugin from 'mini-css-extract-plugin';
// import OptimizeCSSAssetsPlugin from 'optimize-css-assets-webpack-plugin';

// import { CleanWebpackPlugin } from 'clean-webpack-plugin';

// import fs from 'fs';
// import path from 'path';

// const mode = process.env.NODE_ENV ?? 'development';
// const isProduction = mode === 'production';
// const isDevelopment = !isProduction;

// function getEnvPath() {
//   switch (process.env.NODE_ENV) {
//     case 'test':
//       return 'src/environments/environment.test';
//     case 'production':
//       return 'src/environments/environment.prod';
//     case 'development':
//     default:
//       return 'src/environments/environment';
//   }
// }

// const config: Configuration = {
//   mode: isProduction ? 'production' : 'development',
//   entry: {
//     bundle: [...stylesheets, './src/main.ts'],
//   },
//   resolve: {
//     alias: {
//       // Note: Later in this config file, we'll automatically add paths from `tsconfig.compilerOptions.paths`
//       svelte: path.resolve('./action_modules', 'svelte'),
//       [path.resolve(__dirname, 'src/environments/environment')]: path.resolve(
//         __dirname,
//         getEnvPath()
//       ),
//     },
//     extensions: ['.mjs', '.js', '.ts', '.svelte'],
//     mainFields: ['svelte', 'browser', 'module', 'main'],
//     plugins: [new TsconfigPathsPlugin({})],
//     fallback: {
//       fs: false,
//     },
//   },
//   output: {
//     path: path.resolve(__dirname, 'public/build'),
//     publicPath: '/build/',
//     filename: '[name].js',
//     chunkFilename: '[name].[id].js',
//   },
//   module: {
//     rules: [
//       // Rule: Svelte
//       {
//         test: /\.svelte$/,
//         // exclude: /action_modules/,
//         use: {
//           loader: 'svelte-loader',
//           options: {
//             compilerOptions: {
//               // Dev mode must be enabled for HMR to work!
//               dev: isDevelopment,
//             },
//             emitCss: isProduction,
//             hotReload: isDevelopment,
//             hotOptions: {
//               // List of options and defaults: https://www.npmjs.com/package/svelte-loader-hot#usage
//               acceptAccessors: true,
//               acceptNamedExports: true,
//               noPreserveState: false,
//               optimistic: true,
//             },
//             preprocess: SveltePreprocess({
//               scss: true,
//               sass: true,
//               postcss: true,
//             }),
//           },
//         },
//       },

//       // Required to prevent errors from Svelte on Webpack 5+, omit on Webpack 4
//       // See: https://github.com/sveltejs/svelte-loader#usage
//       {
//         test: /action_modules\/svelte\/.*\.mjs$/,
//         resolve: {
//           fullySpecified: false,
//         },
//       },

//       // Rule: SASS
//       {
//         test: /\.(scss|sass)$/,
//         use: [
//           {
//             loader: MiniCssExtractPlugin.loader,
//           },
//           'css-loader',
//           {
//             loader: 'postcss-loader',
//             options: {
//               postcssOptions: {
//                 plugins: [Autoprefixer],
//               },
//             },
//           },
//           'sass-loader',
//         ],
//       },

//       // Rule: CSS
//       {
//         test: /\.css$/,
//         use: [
//           {
//             loader: MiniCssExtractPlugin.loader,
//           },
//           'css-loader',
//         ],
//       },

//       // {
//       //   loader: 'postcss-loader'
//       // },

//       // Rule: TypeScript
//       {
//         test: /\.ts$/,
//         use: 'ts-loader',
//         exclude: /action_modules/,
//       },
//     ],
//   },
//   devServer: {
//     hot: true,
//     stats: 'none',
//     contentBase: 'public',
//     watchContentBase: true,
//   },
//   target: isDevelopment ? 'web' : 'browserslist',
//   plugins: [
//     new MiniCssExtractPlugin({
//       filename: '[name].css',
//     }),
//     // new ActionPolyfillPlugin({}),
//     new Webpack.DefinePlugin({
//       'process.env.BASE_URL': JSON.stringify(process.env.BASE_URL),
//     }),
//   ],
//   devtool: isProduction && !sourceMapsInProduction ? false : 'source-map',
//   stats: {
//     chunks: false,
//     chunkModules: false,
//     modules: false,
//     assets: true,
//     entrypoints: false,
//   },
// };

// /**
//  * This interface combines configuration from `webpack` and `webpack-dev-server`. You can add or override properties
//  * in this interface to change the config object type used above.
//  */
// export interface Configuration
//   extends Webpack.Configuration,
//     WebpackDev.Configuration {}

// /*********************************************************************************************************************/
// /**********                                             Advanced                                            **********/
// /*********************************************************************************************************************/

// // Configuration for production bundles
// if (isProduction) {
//   // Clean the build directory for production builds
//   config.plugins?.push(new CleanWebpackPlugin());

//   // Minify CSS files
//   config.optimization?.minimizer?.push(
//     new OptimizeCSSAssetsPlugin({
//       cssProcessorOptions: {
//         map: sourceMapsInProduction
//           ? { inline: false, annotation: true }
//           : false,
//       },
//       cssProcessorPluginOptions: {
//         preset: [
//           'default',
//           {
//             discardComments: {
//               removeAll: !sourceMapsInProduction,
//             },
//           },
//         ],
//       },
//     })
//   );

//   // Minify and treeshake JS
//   if (config.optimization === undefined) {
//     config.optimization = {};
//   }

//   config.optimization.minimize = true;
// }

// // Load path aliases from the tsconfig.json file
// const tsconfigPath = path.resolve('apps/frontend', 'tsconfig.json');
// const tsconfig = fs.existsSync(tsconfigPath) ? require(tsconfigPath) : {};

// if ('compilerOptions' in tsconfig && 'paths' in tsconfig.compilerOptions) {
//   const aliases = tsconfig.compilerOptions.paths;

//   for (const alias in aliases) {
//     const paths = aliases[alias].map((p: string) => path.resolve(__dirname, p));

//     // Our tsconfig uses glob path formats, whereas webpack just wants directories
//     // We'll need to transform the glob format into a format acceptable to webpack

//     const wpAlias = alias.replace(/(\\|\/)\*$/, '');
//     const wpPaths = paths.map((p: string) => p.replace(/(\\|\/)\*$/, ''));

//     if (config.resolve && config.resolve.alias) {
//       if (!(wpAlias in config.resolve.alias) && wpPaths.length) {
//         config.resolve.alias[wpAlias] =
//           wpPaths.length > 1 ? wpPaths : wpPaths[0];
//       }
//     }
//   }
// }

// // Babel
// if (useBabel && (isProduction || useBabelInDevelopment)) {
//   const loader = {
//     loader: 'babel-loader',
//     options: {
//       sourceType: 'unambiguous',
//       presets: [
//         [
//           // Docs: https://babeljs.io/docs/en/babel-preset-env
//           '@babel/preset-env',
//           {
//             debug: false,
//             corejs: { version: 3 },
//             useBuiltIns: 'usage',
//           },
//         ],
//       ],
//       plugins: ['@babel/plugin-transform-runtime'],
//     },
//   };

//   config.module?.rules.unshift({
//     test: /\.(?:m?js|ts)$/,
//     include: [
//       path.resolve(__dirname, 'src'),
//       path.resolve('action_modules', 'svelte'),
//     ],
//     exclude: [
//       /action_modules[/\\](css-loader|core-js|webpack|regenerator-runtime)/,
//     ],
//     use: loader,
//   });

//   const svelte = config.module?.rules.find((rule) => {
//     if (typeof rule !== 'object') return false;
//     else if (Array.isArray(rule.use))
//       return rule.use.includes(
//         (e: any) =>
//           typeof e.loader === 'string' && e.loader.startsWith('svelte-loader')
//       );
//     else if (typeof rule.use === 'object')
//       return rule.use.loader?.startsWith('svelte-loader') ?? false;
//     return false;
//   }) as Webpack.RuleSetRule;

//   if (!svelte) {
//     console.error('ERR: Could not find svelte-loader for babel injection!');
//     process.exit(1);
//   }

//   if (!Array.isArray(svelte.use)) {
//     svelte.use = [svelte.use as any];
//   }

//   svelte.use.unshift(loader);
// }

// export default config;

'''