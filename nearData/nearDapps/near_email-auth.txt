*GitHub Repository "near/email-auth"*

'''--- .github/ISSUE_TEMPLATE/BOUNTY.yml ---
name: "Simple Bounty"
description: "Use this template to create a HEROES Simple Bounty via Github bot"
title: "Bounty: "
labels: ["bounty"]
assignees: heroes-bot-test
body:
  - type: markdown
    attributes:
      value: |
        Hi! Let's set up your bounty! Please don't change the template - @heroes-bot-test won't be able to help you.

  - type: dropdown
    id: type
    attributes:
      label: What talent are you looking for?
      options:
        - Marketing
        - Development
        - Design
        - Other
        - Content
        - Research
        - Audit

  - type: textarea
    id: description
    attributes:
      label: What you need to be done?

  - type: dropdown
    id: tags
    attributes:
      label: Tags
      description: Add tags that match the topic of the work
      multiple: true
      options:
        - API
        - Blockchain
        - Community
        - CSS
        - DAO
        - dApp
        - DeFi
        - Design
        - Documentation
        - HTML
        - Javascript
        - NFT
        - React
        - Rust
        - Smart contract
        - Typescript
        - UI/UX
        - web3
        - Translation
        - Illustration
        - Branding
        - Copywriting
        - Blogging
        - Editing
        - Video Creation
        - Social Media
        - Graphic Design
        - Transcription
        - Product Design
        - Artificial Intelligence
        - Quality Assurance
        - Risk Assessment
        - Security Audit
        - Bug Bounty
        - Code Review
        - Blockchain Security
        - Smart Contract Testing
        - Penetration Testing
        - Vulnerability Assessment
        - BOS
        - News
        - Hackathon
        - NEARCON2023
        - NEARWEEK

  - type: input
    id: deadline
    attributes:
      label: Deadline
      description: "Set a deadline for your bounty. Please enter the date in format: DD.MM.YYYY"
      placeholder: "19.05.2027"

  - type: dropdown
    id: currencyType
    attributes:
      label: Currency
      description: What is the currency you want to pay?
      options:
        - USDC.e
        - USDT.e
        - DAI
        - wNEAR
        - USDt
        - XP
        - marmaj
        - NEKO
        - JUMP
        - USDC
        - NEARVIDIA
      default: 0
    validations:
      required: true

  - type: input
    id: currencyAmount
    attributes:
      label: Amount
      description: How much it will be cost?

  - type: markdown
    attributes:
      value: "## Advanced settings"

  - type: checkboxes
    id: kyc
    attributes:
      label: KYC
      description: "Use HEROES' KYC Verification, only applicants who passed HEROES' KYC can apply and work on this bounty!"
      options:
        - label: Use KYC Verification

  - type: markdown
    attributes:
      value: |
        ### This cannot be changed once the bounty is live!

'''
'''--- README.md ---
# Proof-of-Concept for email-based authentication for NEAR

The goal of this repo is to show the Proof of concept of using the DKIM signatures (added by default to emails) as a way to authenticate transactions.

This would allow users to control their NEAR account via email - by setting the command that they would like to execute in the subject, and then sending the email to one of the recipients.

Email would be signed by the sender's server (in current design, we only support gmail) - and this signature can be verified by the contract.

## High level design

The setup consists of 3 sub-projects: control-delegator contract,  dkim-controller contract and email-relayer server.

### control-delegator contract
This is the contract that is running on the 'users' account - to handle delegated requests coming from the dkim-controller contract.

### dkim-controller contract
This is the main contract that takes are of validating DKIM messages - and passing them to workers (and creating workers accounts).

### email-relayer server
This is the job that gets emails from the imap server - and sends them as transactions.

IMPORTANT: server doesn't actually have any special powers. It is acting more like a relayer - that takes the incoming email and executes the Near function call. If it tried to change anything in the email contents, then the signature verification in contract would have failed.

'''
'''--- control-delegator/Cargo.toml ---

[package]
name = "control-delegator"
version = "0.0.1"
authors = ["Near Inc <hello@near.org>"]
edition = "2021"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = "4.0.0"
uint = { version = "0.9.3", default-features = false }

[profile.release]
codegen-units = 1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[workspace]
members = []
'''
'''--- control-delegator/build.sh ---
#!/bin/sh

echo ">> Building contract"

rustup target add wasm32-unknown-unknown
cargo build --all --target wasm32-unknown-unknown --release
'''
'''--- control-delegator/deploy.sh ---
#!/bin/sh

./build.sh

echo ">> Deploying contract"

NEAR_ENV=localnet near deploy  --wasmFile ./target/wasm32-unknown-unknown/release/contract.wasm --account_id shard0
'''
'''--- control-delegator/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{env, near_bindgen, AccountId, Balance, PanicOnDefault, Promise, PublicKey};

// Define the contract structure
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct ControlDelegator {
    controller_id: AccountId,
}

// Implement the contract structure
#[near_bindgen]
impl ControlDelegator {
    #[init]
    pub fn set_controller(controller_id: AccountId) -> Self {
        Self { controller_id }
    }

    pub fn add_key(self, public_key: PublicKey) {
        assert!(env::predecessor_account_id() == self.controller_id);
        Promise::new(env::current_account_id()).add_full_access_key(public_key);
    }

    pub fn delete_key(self, public_key: PublicKey) {
        assert!(env::predecessor_account_id() == self.controller_id);
        Promise::new(env::current_account_id()).delete_key(public_key);
    }

    pub fn transfer(self, to: AccountId, amount: Balance) {
        assert!(env::predecessor_account_id() == self.controller_id);
        Promise::new(to).transfer(amount);
    }
}

'''
'''--- dkim-controller/Cargo.toml ---

[package]
name = "dkim-controller"
version = "0.0.1"
authors = ["Near Inc <hello@near.org>"]
edition = "2021"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = "4.0.0"
uint = { version = "0.9.3", default-features = false }
mail-parser = "0.7.0"
mailparse = "0.13.7"
getrandom = { version = "0.2", features = ["custom"] }

near-dkim = { path = "../dkim"}

[profile.release]
codegen-units = 1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[workspace]
members = []

'''
'''--- dkim-controller/build.sh ---
#!/bin/sh

echo ">> Building contract"

rustup target add wasm32-unknown-unknown
cargo build --all --target wasm32-unknown-unknown --release
'''
'''--- dkim-controller/deploy.sh ---
#!/bin/sh

./build.sh

echo ">> Deploying contract"

NEAR_ENV=localnet near deploy  --wasmFile ./target/wasm32-unknown-unknown/release/contract.wasm --account_id shard0
'''
'''--- dkim-controller/src/lib.rs ---
use mailparse::{addrparse_header, parse_mail, MailHeaderMap};
use near_dkim::dns::Lookup;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::Serialize;
use near_sdk::store::LookupMap;
use near_sdk::{
    env, near_bindgen, require, AccountId, Balance, Gas, GasWeight, PanicOnDefault, Promise,
    PublicKey, ONE_NEAR,
};

use near_dkim::verify_email_with_resolver;

pub fn always_fail(_: &mut [u8]) -> Result<(), getrandom::Error> {
    unimplemented!()
}

use getrandom::register_custom_getrandom;
register_custom_getrandom!(always_fail);

// Define the contract structure
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct DkimController {
    resolver: DkimResolver,
}

#[derive(BorshDeserialize, BorshSerialize)]
struct DkimResolver {
    map: LookupMap<String, String>,
}

impl Lookup for DkimResolver {
    fn lookup_txt(&self, name: &str) -> Result<Vec<String>, near_dkim::DKIMError> {
        match self.map.get(name) {
            Some(dkim) => Ok(vec![dkim.clone()]),
            None => Err(near_dkim::DKIMError::KeyUnavailable(
                "unknown domain".to_string(),
            )),
        }
    }
}

const MIN_STORAGE: Balance = 4_200_000_000_000_000_000_000_000; //11.1â“ƒ
const ACCESS_DELEGATOR_CODE: &[u8] = include_bytes!("access_delegator.wasm");

#[derive(Debug, PartialEq)]
pub enum CommandEnum {
    Init,
    AddKey(PublicKey),
    DeleteKey,
    Transfer(AccountId, Balance),
}

#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
struct AddKeyArgs {
    public_key: PublicKey,
}

#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
struct TransferArgs {
    to: AccountId,
    amount: Balance,
}

#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
struct NewContractArgs {
    controller_id: AccountId,
}

// Implement the contract structure
#[near_bindgen]
impl DkimController {
    #[init]
    pub fn new() -> Self {
        let mut map = LookupMap::new(b"a");
        map.insert(
            "20210112._domainkey.gmail.com".to_owned(), "v=DKIM1; k=rsa; p=MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAq8JxVBMLHZRj1WvIMSHApRY3DraE/EiFiR6IMAlDq9GAnrVy0tDQyBND1G8+1fy5RwssQ9DgfNe7rImwxabWfWxJ1LSmo/DzEdOHOJNQiP/nw7MdmGu+R9hEvBeGRQ Amn1jkO46KIw/p2lGvmPSe3+AVD+XyaXZ4vJGTZKFUCnoctAVUyHjSDT7KnEsaiND2rVsDvyisJUAH+EyRfmHSBwfJVHAdJ9oD8cn9NjIun/EHLSIwhCxXmLJlaJeNAFtcGeD2aRGbHaS7M6aTFP+qk4f2ucRx31cyCxbu50CDVfU+d4JkIDNBFDiV+MIpaDFXIf11bGoS08oBBQiyPXgX0wIDAQAB".to_owned());
        map.insert(
            "google._domainkey.near.org".to_owned(), "v=DKIM1; k=rsa; p=MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAvp9AC5ykeX9XfNDcv3lKLft21MpXUTb45fOvSyjArMjmVCJT8mQCkehardajVAFvcBYOk0I9DJtvclvFnDBYV8T69HMGzCmuIibHrw4ImB+VCwLFk7M7lsBgSo5FDS1z8swgMyTsKKFmsLOFmvMXwF+arLIQRNYLwTs/JyPl6ExjQJqfNhVu/A1SqAc2wm1Tg n2i0m+9oj0HI5HZ5VX23T4f2Aew2AxascByQx6ue47avziBtV9c84IpnpFTbrozPkXWKlyjXEY9YArw6LqKg1mn7iQAWoeVQOvC8Kv6O2CVCw+RCLzHiZs8lpu/vwtyJ8hhNoI+tJLKm/Va5C9ZnwIDAQAB".to_owned());
        map.flush();

        Self {
            resolver: DkimResolver { map },
        }
    }

    fn create_new_subaccount(account_id: AccountId) {
        let create_args = near_sdk::serde_json::to_vec(&NewContractArgs {
            controller_id: env::current_account_id(),
        })
        .unwrap();

        Promise::new(account_id)
            .create_account()
            .transfer(MIN_STORAGE)
            .deploy_contract(ACCESS_DELEGATOR_CODE.to_vec())
            .function_call_weight(
                "set_controller".to_owned(),
                create_args,
                0,
                Gas(0),
                GasWeight(1),
            );
    }

    fn add_key(account_id: AccountId, public_key: PublicKey) {
        let add_key_args = near_sdk::serde_json::to_vec(&AddKeyArgs { public_key }).unwrap();

        Promise::new(account_id).function_call_weight(
            "add_key".to_owned(),
            add_key_args,
            0,
            Gas(0),
            GasWeight(1),
        );
    }

    fn transfer(account_id: AccountId, to: AccountId, amount: Balance) {
        let transfer_args = near_sdk::serde_json::to_vec(&TransferArgs { to, amount }).unwrap();

        Promise::new(account_id).function_call_weight(
            "transfer".to_owned(),
            transfer_args,
            0,
            Gas(0),
            GasWeight(1),
        );
    }

    fn verify_email(&self, full_email: Vec<u8>) -> (String, String) {
        let email = parse_mail(full_email.as_slice())
            .unwrap_or_else(|err| env::panic_str(&format!("The email is malformed: {}", err)));

        let result = verify_email_with_resolver(&email, &self.resolver)
            .unwrap_or_else(|err| env::panic_str(&format!("Email verification failed: {}", err)));
        require!(
            result.summary() == "pass",
            "Email signature does not match its contents"
        );

        let headers = email.get_headers();
        let from_header = headers
            .get_first_header("From")
            .unwrap_or_else(|| env::panic_str("The email lacks \"From\" header"));
        let mut from_list = addrparse_header(from_header).unwrap_or_else(|err| {
            env::panic_str(&format!("The email \"From\" header is malformed: {}", err))
        });
        require!(
            from_list.len() == 1,
            "The email \"From\" header contains more than one author"
        );
        let from = from_list.swap_remove(0);

        let addr = match from {
            mailparse::MailAddr::Single(single_email) => single_email.addr,
            _ => env::panic_str("The email \"From\" header contains a group of addresses"),
        };

        let subject = match email.get_headers().get_first_header("Subject") {
            Some(subject_header) => subject_header.get_value(),
            None => env::panic_str("The email lacks \"From\" header"),
        };

        (addr, subject)
    }

    fn validate_key(key: &str) -> PublicKey {
        require!(key.len() == 52, "The key length is not 52");
        let key_suffix = key
            .strip_prefix("ed25519:")
            .unwrap_or_else(|| env::panic_str("The key prefix does not match \"ed25519:\""));

        key_suffix.chars().for_each(|x| match x {
            'A'..='Z' | 'a'..='z' | '0'..='9' => (),
            _ => env::panic_str(&format!("The key contains an invalid character '{}'", x)),
        });

        key.parse()
            .unwrap_or_else(|err| env::panic_str(&format!("The key is malformed: {}", err)))
    }

    fn parse_command(subject: String) -> CommandEnum {
        let cmds: Vec<&str> = subject.split_whitespace().collect();
        match cmds.as_slice() {
            ["init"] => CommandEnum::Init,
            ["add_key", key] => CommandEnum::AddKey(DkimController::validate_key(key)),
            // TODO: Unsupported for now, this command should accept a public key and delete it
            ["delete_key"] => CommandEnum::DeleteKey,
            ["transfer", account, amount] => {
                let amount: f64 = amount.parse().unwrap_or_else(|err| {
                    env::panic_str(&format!(
                        "Failed to transfer due to malformed amount: {}",
                        err
                    ))
                });
                require!(amount > 0.0, "Transfer amount must be positive");
                let amount = ((amount * 100.0) as u128) * (ONE_NEAR / 100);

                let account: AccountId = account.parse().unwrap_or_else(|err| {
                    env::panic_str(&format!(
                        "Failed to transfer due to malformed account: {}",
                        err
                    ))
                });

                CommandEnum::Transfer(account, amount)
            }
            _ => env::panic_str("Unrecognized subject"),
        }
    }

    fn sender_to_account(sender: String) -> String {
        sender
            .chars()
            .map(|x| match x {
                'a'..='z' => x,
                'A'..='Z' => x,
                '0'..='9' => x,
                '@' => '_',
                '.' => '_',
                '_' => x,
                '-' => x,
                _ => env::panic_str(&format!(
                    "The sender email contains an unsupported character '{}'",
                    x
                )),
            })
            .collect()
    }

    pub fn receive_email(&self, full_email: Vec<u8>) {
        // verify email
        let (sender, header) = self.verify_email(full_email);
        env::log_str(format!("Email verified: {}", sender).as_str());
        let prefix = DkimController::sender_to_account(sender);
        env::log_str(format!("Account prefix is: {}", prefix).as_str());
        let account_id: AccountId = (prefix + "." + env::current_account_id().as_ref())
            .parse()
            .unwrap_or_else(|_| {
                env::panic_str("Unexpected error: failed to derive a valid account id")
            });
        let cmd = DkimController::parse_command(header);
        match cmd {
            CommandEnum::Init => DkimController::create_new_subaccount(account_id),
            CommandEnum::AddKey(key) => DkimController::add_key(account_id, key),
            CommandEnum::Transfer(to, amount) => DkimController::transfer(account_id, to, amount),
            _ => todo!(),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    pub fn test_parse_command() {
        assert_eq!(
            DkimController::parse_command("init".to_owned()),
            CommandEnum::Init
        );

        assert_eq!(
            DkimController::parse_command(
                "add_key ed25519:3tXAA9zf5YSLxYELSbxwhEvMd7h9itTfCcUfEc3QfPgD".to_owned()
            ),
            CommandEnum::AddKey(
                "ed25519:3tXAA9zf5YSLxYELSbxwhEvMd7h9itTfCcUfEc3QfPgD"
                    .parse()
                    .unwrap()
            )
        );
        assert_eq!(
            DkimController::parse_command(
                "add_key     ed25519:3tXAA9zf5YSLxYELSbxwhEvMd7h9itTfCcUfEc3QfPgD
                \n"
                .to_owned()
            ),
            CommandEnum::AddKey(
                "ed25519:3tXAA9zf5YSLxYELSbxwhEvMd7h9itTfCcUfEc3QfPgD"
                    .parse()
                    .unwrap()
            )
        );
        assert_eq!(
            DkimController::parse_command("transfer foobar.near 134".to_owned()),
            CommandEnum::Transfer("foobar.near".parse().unwrap(), 134 * ONE_NEAR)
        );
    }

    #[test]
    pub fn verify_email() {
        let auth_manager = DkimController::new();
        assert_eq!(
            auth_manager.verify_email(include_bytes!("message.eml").to_vec()),
            (
                "example.near@gmail.com".to_owned(),
                "Another message".to_owned()
            )
        );
        assert_eq!(
            auth_manager.verify_email(include_bytes!("empty_email.eml").to_vec()),
            (
                "example.near@gmail.com".to_owned(),
                "Empty email".to_owned()
            )
        );
    }
    #[test]
    #[should_panic]
    pub fn verify_invalid_email() {
        let auth_manager = DkimController::new();
        assert_eq!(
            auth_manager.verify_email(include_bytes!("invalid_message.eml").to_vec()),
            (
                "example.near@gmail.com".to_owned(),
                "Another message".to_owned()
            )
        );
    }
}

'''
'''--- dkim/Cargo.toml ---
[package]
name = "near-dkim"
version = "1.0.0"
authors = ["Near Inc <hello@near.org>"]
edition = "2021"
license = "MIT"

[dependencies]
ed25519-dalek = "1.0.1"
mailparse = "0.13.7"
quick-error = "2.0.1"
nom = "7.1.0"
chrono = { version = "0.4.19", default-features = false, features = ["clock", "std"] }
sha-1 = "0.10"
sha2 = "0.10"
base64 = "0.13.0"
rsa = "0.6"
indexmap = "1.8.0"

[dev-dependencies]
regex = "1"

'''
'''--- dkim/src/bytes.rs ---
///! Various utility functions to operate on bytes

pub(crate) fn get_all_after<'a>(bytes: &'a [u8], end: &[u8]) -> &'a [u8] {
    if let Some(mut end_index) = find(bytes, end) {
        end_index += end.len();
        return &bytes[end_index..];
    } else {
        return &[];
    }
}

/// Find the offset of specific bytes in bytes
pub(crate) fn find(bytes: &[u8], search: &[u8]) -> Option<usize> {
    bytes
        .windows(search.len())
        .position(|window| window == search)
}

pub(crate) fn replace(bytes: &mut [u8], from: char, to: char) {
    for byte in bytes.iter_mut() {
        if *byte == from as u8 {
            *byte = to as u8;
        }
    }
}

pub(crate) fn replace_slice(source: &[u8], from: &[u8], to: &[u8]) -> Vec<u8> {
    let mut result = source.to_vec();
    let from_len = from.len();
    let to_len = to.len();

    let mut i = 0;
    while i + from_len <= result.len() {
        if result[i..].starts_with(from) {
            result.splice(i..i + from_len, to.iter().cloned());
            i += to_len;
        } else {
            i += 1;
        }
    }

    result
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_find() {
        assert_eq!(find(&[97, 98, 99], &[1]), None);
        assert_eq!(find(&[97, 98, 99], &[97]), Some(0));
        assert_eq!(find(&[97, 98, 99], &[97, 98]), Some(0));
    }

    #[test]
    fn it_replace_slice() {
        let source = "aba".as_bytes();
        assert_eq!(replace_slice(&source, &[97], &[99]), "cbc".as_bytes());
        assert_eq!(replace_slice(&source, &[97, 98], &[]), "a".as_bytes());
    }
}

'''
'''--- dkim/src/canonicalization.rs ---
// Inspired from https://docs.rs/dkim/latest/src/dkim/canonicalization.rs.html
use crate::bytes;

#[derive(PartialEq, Clone, Debug)]
pub enum Type {
    Simple,
    Relaxed,
}
impl std::string::ToString for Type {
    fn to_string(&self) -> String {
        match self {
            Self::Simple => "simple".to_owned(),
            Self::Relaxed => "relaxed".to_owned(),
        }
    }
}

/// Canonicalize body using the simple canonicalization algorithm.
///
/// The first argument **must** be the body of the mail.
pub(crate) fn canonicalize_body_simple(mut body: &[u8]) -> Vec<u8> {
    if body.is_empty() {
        return b"\r\n".to_vec();
    }

    while body.ends_with(b"\r\n\r\n") {
        body = &body[..body.len() - 2];
    }

    body.to_vec()
}

/// https://datatracker.ietf.org/doc/html/rfc6376#section-3.4.3
/// Canonicalize body using the relaxed canonicalization algorithm.  
///
/// The first argument **must** be the body of the mail.
pub(crate) fn canonicalize_body_relaxed(body: &[u8]) -> Vec<u8> {
    let mut body = body.to_vec();
    // See https://tools.ietf.org/html/rfc6376#section-3.4.4 for implementation details

    // Reduce all sequences of WSP within a line to a single SP character.
    bytes::replace(&mut body, '\t', ' ');
    let mut previous = false;
    body.retain(|c| {
        if *c == b' ' {
            if previous {
                false
            } else {
                previous = true;
                true
            }
        } else {
            previous = false;
            true
        }
    });

    // Ignore all whitespace at the end of lines. Implementations MUST NOT remove the CRLF at the end of the line.
    while let Some(idx) = bytes::find(&body, b" \r\n") {
        body.remove(idx);
    }

    // Ignore all empty lines at the end of the message body. "Empty line" is defined in Section 3.4.3.
    while body.ends_with(b"\r\n\r\n") {
        body.remove(body.len() - 1);
        body.remove(body.len() - 1);
    }

    // If the body is non-empty but does not end with a CRLF, a CRLF is added. (For email, this is only possible when using extensions to SMTP or non-SMTP transport mechanisms.)
    if !body.is_empty() && !body.ends_with(b"\r\n") {
        body.push(b'\r');
        body.push(b'\n');
    }

    body
}

// https://datatracker.ietf.org/doc/html/rfc6376#section-3.4.1
pub(crate) fn canonicalize_header_simple(key: &str, value: &[u8]) -> Vec<u8> {
    let mut out = Vec::new();
    out.extend_from_slice(&key.as_bytes());
    out.extend_from_slice(b": ");
    out.extend_from_slice(value);
    out.extend_from_slice(b"\r\n");

    out
}

// https://datatracker.ietf.org/doc/html/rfc6376#section-3.4.2
pub(crate) fn canonicalize_header_relaxed(key: &str, value: &[u8]) -> Vec<u8> {
    let key = key.to_lowercase();
    let key = key.trim_end();
    let value = canonicalize_header_value_relaxed(value);

    let mut out = Vec::new();
    out.extend_from_slice(&key.as_bytes());
    out.extend_from_slice(b":");
    out.extend_from_slice(&value);
    out.extend_from_slice(b"\r\n");

    out
}

fn canonicalize_header_value_relaxed(value: &[u8]) -> Vec<u8> {
    let mut value = value.to_vec();
    bytes::replace(&mut value, '\t', ' ');
    value = bytes::replace_slice(&value, b"\r\n", b"");

    while value.ends_with(b" ") {
        value.remove(value.len() - 1);
    }
    while value.starts_with(b" ") {
        value.remove(0);
    }
    let mut previous = false;
    value.retain(|c| {
        if *c == b' ' {
            if previous {
                false
            } else {
                previous = true;
                true
            }
        } else {
            previous = false;
            true
        }
    });

    value
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_canonicalize_header_relaxed() {
        assert_eq!(
            canonicalize_header_relaxed("SUBJect", b" AbC\r\n"),
            b"subject:AbC\r\n"
        );
        assert_eq!(
            canonicalize_header_relaxed("Subject \t", b"\t Your Name\t \r\n"),
            b"subject:Your Name\r\n"
        );
        assert_eq!(
            canonicalize_header_relaxed("Subject \t", b"\t Kimi \t \r\n No \t\r\n Na Wa\r\n"),
            b"subject:Kimi No Na Wa\r\n"
        );
    }

    #[test]
    fn test_canonicalize_body_relaxed() {
        assert_eq!(canonicalize_body_relaxed(b"\r\n"), b"\r\n");
        assert_eq!(canonicalize_body_relaxed(b"hey        \r\n"), b"hey\r\n");
    }
}

'''
'''--- dkim/src/dns.rs ---
use crate::DKIMError;

/// A trait for entities that perform DNS resolution.
pub trait Lookup {
    fn lookup_txt(&self, name: &str) -> Result<Vec<String>, DKIMError>;
}

'''
'''--- dkim/src/errors.rs ---
/// DKIM error status
pub enum Status {
    Permfail,
    Tempfail,
}

quick_error! {
    #[derive(Debug, PartialEq, Clone)]
    /// DKIM errors
    pub enum DKIMError {
        UnsupportedHashAlgorithm(value: String) {
            display("unsupported hash algorithm: {}", value)
        }
        UnsupportedCanonicalizationType(value: String) {
            display("unsupported canonicalization: {}", value)
        }
        SignatureSyntaxError(err: String) {
            display("signature syntax error: {}", err)
        }
        SignatureMissingRequiredTag(name: &'static str) {
            display("signature missing required tag ({})", name)
        }
        IncompatibleVersion {
            display("incompatible version")
        }
        DomainMismatch {
            display("domain mismatch")
        }
        FromFieldNotSigned {
            display("From field not signed")
        }
        SignatureExpired {
            display("signature expired")
        }
        UnacceptableSignatureHeader {
            display("unacceptable signature header")
        }
        UnsupportedQueryMethod {
            display("unsupported query method")
        }
        KeyUnavailable(err: String) {
            display("key unavailable: {}", err)
        }
        UnknownInternalError(err: String) {
            display("internal error: {}", err)
        }
        NoKeyForSignature {
            display("no key for signature")
        }
        KeySyntaxError {
            display("key syntax error")
        }
        KeyIncompatibleVersion {
            display("key incompatible version")
        }
        InappropriateKeyAlgorithm {
            display("inappropriate key algorithm")
        }
        SignatureDidNotVerify {
            display("signature did not verify")
        }
        BodyHashDidNotVerify {
            display("body hash did not verify")
        }
        MalformedBody {
            display("malformed email body")
        }
        FailedToSign(err: String) {
            display("failed sign: {}", err)
        }
        BuilderError(err: &'static str) {
            display("failed to build object: {}", err)
        }
    }
}

impl DKIMError {
    pub fn status(self) -> Status {
        use DKIMError::*;
        match self {
            SignatureSyntaxError(_)
            | SignatureMissingRequiredTag(_)
            | IncompatibleVersion
            | DomainMismatch
            | FromFieldNotSigned
            | SignatureExpired
            | UnacceptableSignatureHeader
            | UnsupportedQueryMethod
            | NoKeyForSignature
            | KeySyntaxError
            | KeyIncompatibleVersion
            | InappropriateKeyAlgorithm
            | SignatureDidNotVerify
            | BodyHashDidNotVerify
            | MalformedBody
            | UnsupportedCanonicalizationType(_)
            | UnsupportedHashAlgorithm(_) => Status::Permfail,
            KeyUnavailable(_) | UnknownInternalError(_) => Status::Tempfail,
            BuilderError(_) | FailedToSign(_) => unreachable!(),
        }
    }
}

'''
'''--- dkim/src/hash.rs ---
use std::collections::HashMap;

use crate::canonicalization::{
    self, canonicalize_body_relaxed, canonicalize_body_simple, canonicalize_header_relaxed,
    canonicalize_header_simple,
};
use crate::header::HEADER;
use crate::{bytes, DKIMError, DKIMHeader};

#[derive(Debug, Clone)]
pub enum HashAlgo {
    RsaSha1,
    RsaSha256,
    Ed25519Sha256,
}

/// Get the body part of an email
fn get_body<'a>(email: &'a mailparse::ParsedMail<'a>) -> Result<Vec<u8>, DKIMError> {
    Ok(bytes::get_all_after(email.raw_bytes, b"\r\n\r\n").to_vec())
}

fn hash_sha1<T: AsRef<[u8]>>(data: T) -> Vec<u8> {
    use sha1::{Digest, Sha1};

    let mut hasher = Sha1::new();
    hasher.update(data);
    hasher.finalize().to_vec()
}

fn hash_sha256<T: AsRef<[u8]>>(data: T) -> Vec<u8> {
    use sha2::{Digest, Sha256};

    let mut hasher = Sha256::new();
    hasher.update(data);
    hasher.finalize().to_vec()
}

/// Returns the hash of message's body
/// https://datatracker.ietf.org/doc/html/rfc6376#section-3.7
pub(crate) fn compute_body_hash<'a>(
    canonicalization_type: canonicalization::Type,
    length: Option<String>,
    hash_algo: HashAlgo,
    email: &'a mailparse::ParsedMail<'a>,
) -> Result<String, DKIMError> {
    let body = get_body(email)?;

    let mut canonicalized_body = if canonicalization_type == canonicalization::Type::Simple {
        canonicalize_body_simple(&body)
    } else {
        canonicalize_body_relaxed(&body)
    };
    if let Some(length) = length {
        let length = length
            .parse::<usize>()
            .map_err(|err| DKIMError::SignatureSyntaxError(format!("invalid length: {}", err)))?;
        canonicalized_body.truncate(length);
    };

    let hash = match hash_algo {
        HashAlgo::RsaSha1 => hash_sha1(&canonicalized_body),
        HashAlgo::RsaSha256 => hash_sha256(&canonicalized_body),
        HashAlgo::Ed25519Sha256 => hash_sha256(&canonicalized_body),
    };
    Ok(base64::encode(&hash))
}

fn select_headers<'a, 'b>(
    dkim_header: &'b str,
    email: &'a mailparse::ParsedMail<'a>,
) -> Result<Vec<(String, &'a [u8])>, DKIMError> {
    let mut signed_headers = vec![];

    let email_headers = &email.headers;
    let num_headers = email_headers.len();
    let mut last_index: HashMap<String, usize> = HashMap::new();

    'outer: for name in dkim_header
        .split(":")
        .map(|h| h.trim().to_ascii_lowercase())
    {
        let index = last_index.get(&name).unwrap_or(&num_headers);
        for header in email_headers
            .iter()
            .enumerate()
            .rev()
            .skip(num_headers - index)
        {
            if header.1.get_key_ref().eq_ignore_ascii_case(&name) {
                signed_headers.push((header.1.get_key(), header.1.get_value_raw()));
                last_index.insert(name, header.0);
                continue 'outer;
            }
        }

        last_index.insert(name, 0);
    }

    Ok(signed_headers)
}

pub(crate) fn compute_headers_hash<'a, 'b>(
    canonicalization_type: canonicalization::Type,
    headers: &'b str,
    hash_algo: HashAlgo,
    dkim_header: &'b DKIMHeader,
    email: &'a mailparse::ParsedMail<'a>,
) -> Result<Vec<u8>, DKIMError> {
    let mut input = Vec::new();

    // Add the headers defined in `h=` in the hash
    for (key, value) in select_headers(headers, email)? {
        let canonicalized_value = if canonicalization_type == canonicalization::Type::Simple {
            canonicalize_header_simple(&key, &value)
        } else {
            canonicalize_header_relaxed(&key, &value)
        };
        input.extend_from_slice(&canonicalized_value);
    }

    // Add the DKIM-Signature header in the hash. Remove the value of the
    // signature (b) first.
    {
        let sign = dkim_header.get_raw_tag("b").unwrap();
        let value = dkim_header.raw_bytes.replace(&sign, "");
        let mut canonicalized_value = if canonicalization_type == canonicalization::Type::Simple {
            canonicalize_header_simple(HEADER, &value.as_bytes())
        } else {
            canonicalize_header_relaxed(HEADER, &value.as_bytes())
        };

        // remove trailing "\r\n"
        canonicalized_value.truncate(canonicalized_value.len() - 2);

        input.extend_from_slice(&canonicalized_value);
    }

    let hash = match hash_algo {
        HashAlgo::RsaSha1 => hash_sha1(&input),
        HashAlgo::RsaSha256 => hash_sha256(&input),
        HashAlgo::Ed25519Sha256 => hash_sha256(&input),
    };
    Ok(hash)
}

#[cfg(test)]
mod tests {
    use super::*;

    fn dkim_header() -> DKIMHeader {
        crate::validate_header("v=1; a=rsa-sha256; q=dns/txt; c=relaxed/relaxed; s=smtp; d=test.com; t=1641506955; h=content-type:to: subject:date:from:mime-version:sender; bh=PU2XIErWsXvhvt1W96ntPWZ2VImjVZ3vBY2T/A+wA3A=; b=PIO0A014nyntOGKdTdtvCJor9ZxvP1M3hoLeEh8HqZ+RvAyEKdAc7VOg+/g/OTaZgsmw6U sZCoN0YNVp+2o9nkaeUslsVz3M4I55HcZnarxl+fhplIMcJ/3s0nIhXL51MfGPRqPbB7/M Gjg9/07/2vFoid6Kitg6Z+CfoD2wlSRa8xDfmeyA2cHpeVuGQhGxu7BXuU8kGbeM4+weit Ql3t9zalhikEPI5Pr7dzYFrgWNOEO6w6rQfG7niKON1BimjdbJlGanC7cO4UL361hhXT4X iXLnC9TG39xKFPT/+4nkHy8pp6YvWkD3wKlBjwkYNm0JvKGwTskCMDeTwxXhAg==").unwrap()
    }

    #[test]
    fn test_compute_body_hash_simple() {
        let email = mailparse::parse_mail(
            r#"To: test@sauleau.com
Subject: subject
From: Sven Sauleau <sven@cloudflare.com>

Hello Alice
        "#
            .as_bytes(),
        )
        .unwrap();

        let canonicalization_type = canonicalization::Type::Simple;
        let length = None;
        let hash_algo = HashAlgo::RsaSha1;
        assert_eq!(
            compute_body_hash(
                canonicalization_type.clone(),
                length.clone(),
                hash_algo,
                &email
            )
            .unwrap(),
            "uoq1oCgLlTqpdDX/iUbLy7J1Wic="
        );
        let hash_algo = HashAlgo::RsaSha256;
        assert_eq!(
            compute_body_hash(canonicalization_type, length, hash_algo, &email).unwrap(),
            "frcCV1k9oG9oKj3dpUqdJg1PxRT2RSN/XKdLCPjaYaY="
        )
    }

    #[test]
    fn test_compute_body_hash_relaxed() {
        let email = mailparse::parse_mail(
            r#"To: test@sauleau.com
Subject: subject
From: Sven Sauleau <sven@cloudflare.com>

Hello Alice
        "#
            .as_bytes(),
        )
        .unwrap();

        let canonicalization_type = canonicalization::Type::Relaxed;
        let length = None;
        let hash_algo = HashAlgo::RsaSha1;
        assert_eq!(
            compute_body_hash(
                canonicalization_type.clone(),
                length.clone(),
                hash_algo,
                &email
            )
            .unwrap(),
            "2jmj7l5rSw0yVb/vlWAYkK/YBwk="
        );
        let hash_algo = HashAlgo::RsaSha256;
        assert_eq!(
            compute_body_hash(canonicalization_type, length, hash_algo, &email).unwrap(),
            "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU="
        )
    }

    #[test]
    fn test_compute_body_hash_length() {
        let email = mailparse::parse_mail(
            r#"To: test@sauleau.com
Subject: subject
From: Sven Sauleau <sven@cloudflare.com>

Hello Alice
        "#
            .as_bytes(),
        )
        .unwrap();

        let canonicalization_type = canonicalization::Type::Relaxed;
        let length = Some("3".to_owned());
        let hash_algo = HashAlgo::RsaSha1;
        assert_eq!(
            compute_body_hash(
                canonicalization_type.clone(),
                length.clone(),
                hash_algo,
                &email
            )
            .unwrap(),
            "2jmj7l5rSw0yVb/vlWAYkK/YBwk="
        );
        let hash_algo = HashAlgo::RsaSha256;
        assert_eq!(
            compute_body_hash(canonicalization_type, length.clone(), hash_algo, &email).unwrap(),
            "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU="
        )
    }

    #[test]
    fn test_compute_body_hash_empty_simple() {
        let email = mailparse::parse_mail(&[]).unwrap();

        let canonicalization_type = canonicalization::Type::Simple;
        let length = None;
        let hash_algo = HashAlgo::RsaSha1;
        assert_eq!(
            compute_body_hash(
                canonicalization_type.clone(),
                length.clone(),
                hash_algo,
                &email
            )
            .unwrap(),
            "uoq1oCgLlTqpdDX/iUbLy7J1Wic="
        );
        let hash_algo = HashAlgo::RsaSha256;
        assert_eq!(
            compute_body_hash(canonicalization_type, length.clone(), hash_algo, &email).unwrap(),
            "frcCV1k9oG9oKj3dpUqdJg1PxRT2RSN/XKdLCPjaYaY="
        )
    }

    #[test]
    fn test_compute_body_hash_empty_relaxed() {
        let email = mailparse::parse_mail(&[]).unwrap();

        let canonicalization_type = canonicalization::Type::Relaxed;
        let length = None;
        let hash_algo = HashAlgo::RsaSha1;
        assert_eq!(
            compute_body_hash(
                canonicalization_type.clone(),
                length.clone(),
                hash_algo,
                &email
            )
            .unwrap(),
            "2jmj7l5rSw0yVb/vlWAYkK/YBwk="
        );
        let hash_algo = HashAlgo::RsaSha256;
        assert_eq!(
            compute_body_hash(canonicalization_type, length.clone(), hash_algo, &email).unwrap(),
            "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU="
        )
    }

    #[test]
    fn test_compute_headers_hash_simple() {
        let email = mailparse::parse_mail(
            r#"To: test@sauleau.com
Subject: subject
From: Sven Sauleau <sven@cloudflare.com>

Hello Alice
        "#
            .as_bytes(),
        )
        .unwrap();

        let canonicalization_type = canonicalization::Type::Simple;
        let hash_algo = HashAlgo::RsaSha1;
        let headers = "To: Subject".to_owned();
        assert_eq!(
            compute_headers_hash(
                canonicalization_type.clone(),
                &headers,
                hash_algo,
                &dkim_header(),
                &email
            )
            .unwrap(),
            &[
                214, 155, 167, 0, 209, 70, 127, 126, 160, 53, 79, 106, 141, 240, 35, 121, 255, 190,
                166, 229
            ],
        );
        let hash_algo = HashAlgo::RsaSha256;
        assert_eq!(
            compute_headers_hash(
                canonicalization_type.clone(),
                &headers,
                hash_algo,
                &dkim_header(),
                &email
            )
            .unwrap(),
            &[
                76, 143, 13, 248, 17, 209, 243, 111, 40, 96, 160, 242, 116, 86, 37, 249, 134, 253,
                196, 89, 6, 24, 157, 130, 142, 198, 27, 166, 127, 179, 72, 247
            ]
        )
    }

    #[test]
    fn test_compute_headers_hash_relaxed() {
        let email = mailparse::parse_mail(
            r#"To: test@sauleau.com
Subject: subject
From: Sven Sauleau <sven@cloudflare.com>

Hello Alice
        "#
            .as_bytes(),
        )
        .unwrap();

        let canonicalization_type = canonicalization::Type::Relaxed;
        let hash_algo = HashAlgo::RsaSha1;
        let headers = "To: Subject".to_owned();
        assert_eq!(
            compute_headers_hash(
                canonicalization_type.clone(),
                &headers,
                hash_algo,
                &dkim_header(),
                &email
            )
            .unwrap(),
            &[
                14, 171, 230, 1, 77, 117, 47, 207, 243, 167, 179, 5, 150, 82, 154, 25, 125, 124,
                44, 164
            ]
        );
        let hash_algo = HashAlgo::RsaSha256;
        assert_eq!(
            compute_headers_hash(
                canonicalization_type.clone(),
                &headers,
                hash_algo,
                &dkim_header(),
                &email
            )
            .unwrap(),
            &[
                45, 186, 211, 81, 49, 111, 18, 147, 180, 245, 207, 39, 9, 9, 118, 137, 248, 204,
                70, 214, 16, 98, 216, 111, 230, 130, 196, 3, 60, 201, 166, 224
            ]
        )
    }

    #[test]
    fn test_get_body() {
        let email =
            mailparse::parse_mail("Subject: A\r\n\r\nContent\n.hi\n.hello..".as_bytes()).unwrap();
        assert_eq!(
            String::from_utf8_lossy(&get_body(&email).unwrap()),
            "Content\n.hi\n.hello..".to_owned()
        );
    }

    #[test]
    fn test_select_headers() {
        let dkim_headers1 = ["from", "subject", "to", "from"].join(":");
        let email1 = mailparse::parse_mail(
            b"from: biz\r\nfoo: bar\r\nfrom: baz\r\nsubject: boring\r\n\r\ntest",
        )
        .unwrap();

        let result1 = select_headers(&dkim_headers1, &email1).unwrap();
        assert_eq!(
            result1,
            vec![
                ("from".to_owned(), &b"baz"[..]),
                ("subject".to_owned(), &b"boring"[..]),
                ("from".to_owned(), &b"biz"[..]),
            ]
        );

        let dkim_headers2 = ["from", "subject", "to", "from"].join(":");
        let email2 =
            mailparse::parse_mail(b"From: biz\r\nFoo: bar\r\nSubject: Boring\r\n\r\ntest").unwrap();

        let result2 = select_headers(&dkim_headers2, &email2).unwrap();
        assert_eq!(
            result2,
            vec![
                ("From".to_owned(), &b"biz"[..]),
                ("Subject".to_owned(), &b"Boring"[..]),
            ]
        );
    }
}

'''
'''--- dkim/src/header.rs ---
use crate::{parser, DKIMError};
use indexmap::map::IndexMap;

pub(crate) const HEADER: &str = "DKIM-Signature";
pub(crate) const REQUIRED_TAGS: &[&str] = &["v", "a", "b", "bh", "d", "h", "s"];

#[derive(Debug, Clone)]
pub struct DKIMHeader {
    pub(crate) tags: IndexMap<String, parser::Tag>,
    pub(crate) raw_bytes: String,
}

impl DKIMHeader {
    pub(crate) fn get_tag(&self, name: &str) -> Option<String> {
        self.tags.get(name).map(|v| v.value.clone())
    }

    pub(crate) fn get_raw_tag(&self, name: &str) -> Option<String> {
        self.tags.get(name).map(|v| v.raw_value.clone())
    }

    pub(crate) fn get_required_tag(&self, name: &str) -> String {
        // Required tags are guaranteed by the parser to be present so it's safe
        // to assert and unwrap.
        debug_assert!(REQUIRED_TAGS.contains(&name));
        self.tags.get(name).unwrap().value.clone()
    }
}

/// Generate the DKIM-Signature header from the tags
fn serialize(header: DKIMHeader) -> String {
    let mut out = "".to_owned();

    for (key, tag) in &header.tags {
        out += &format!("{}={};", key, tag.value);
        out += " ";
    }

    out.pop(); // remove trailing whitespace
    out
}

#[derive(Clone)]
pub(crate) struct DKIMHeaderBuilder {
    header: DKIMHeader,
    time: Option<chrono::DateTime<chrono::offset::Utc>>,
}
impl DKIMHeaderBuilder {
    pub(crate) fn new() -> Self {
        DKIMHeaderBuilder {
            header: DKIMHeader {
                tags: IndexMap::new(),
                raw_bytes: "".to_owned(),
            },
            time: None,
        }
    }

    pub(crate) fn add_tag(mut self, name: &str, value: &str) -> Self {
        let tag = parser::Tag {
            name: name.to_owned(),
            value: value.to_owned(),
            raw_value: value.to_owned(),
        };
        self.header.tags.insert(name.to_owned(), tag);

        self
    }

    pub(crate) fn set_signed_headers(self, headers: &[&str]) -> Self {
        let headers: Vec<String> = headers.iter().map(|h| h.to_lowercase()).collect();
        let value = headers.join(":");
        self.add_tag("h", &value)
    }

    pub(crate) fn set_expiry(self, duration: chrono::Duration) -> Result<Self, DKIMError> {
        let time = self
            .time
            .ok_or(DKIMError::BuilderError("missing require time"))?;
        let expiry = (time + duration).timestamp();
        Ok(self.add_tag("x", &expiry.to_string()))
    }

    pub(crate) fn set_time(mut self, time: chrono::DateTime<chrono::offset::Utc>) -> Self {
        self.time = Some(time);
        self.add_tag("t", &time.timestamp().to_string())
    }

    pub(crate) fn build(mut self) -> Result<DKIMHeader, DKIMError> {
        self.header.raw_bytes = serialize(self.header.clone());
        Ok(self.header)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_dkim_header_builder() {
        let header = DKIMHeaderBuilder::new()
            .add_tag("v", "1")
            .add_tag("a", "something")
            .build()
            .unwrap();
        assert_eq!(header.raw_bytes, "v=1; a=something;".to_owned());
    }

    #[test]
    fn test_dkim_header_builder_signed_headers() {
        let header = DKIMHeaderBuilder::new()
            .add_tag("v", "2")
            .set_signed_headers(&["header1", "header2", "header3"])
            .build()
            .unwrap();
        assert_eq!(
            header.raw_bytes,
            "v=2; h=header1:header2:header3;".to_owned()
        );
    }

    #[test]
    fn test_dkim_header_builder_time() {
        use chrono::TimeZone;

        let time = chrono::Utc.ymd(2021, 1, 1).and_hms_milli(0, 0, 1, 444);

        let header = DKIMHeaderBuilder::new()
            .set_time(time)
            .set_expiry(chrono::Duration::hours(3))
            .unwrap()
            .build()
            .unwrap();
        assert_eq!(header.raw_bytes, "t=1609459201; x=1609470001;".to_owned());
    }
}

'''
'''--- dkim/src/lib.rs ---
// Implementation of DKIM: https://datatracker.ietf.org/doc/html/rfc6376

use indexmap::map::IndexMap;
use rsa::PublicKey;
use rsa::RsaPrivateKey;
use rsa::RsaPublicKey;
use std::collections::HashSet;

use mailparse::MailHeaderMap;

#[macro_use]
extern crate quick_error;

mod bytes;
pub mod canonicalization;
pub mod dns;
mod errors;
mod hash;
mod header;
mod parser;
mod public_key;
mod result;
#[cfg(test)]
mod roundtrip_test;
mod sign;

pub use errors::DKIMError;
use header::{DKIMHeader, HEADER, REQUIRED_TAGS};
pub use parser::tag_list as parse_tag_list;
pub use parser::Tag;
pub use result::DKIMResult;
pub use sign::{Signer, SignerBuilder};

const SIGN_EXPIRATION_DRIFT_MINS: i64 = 15;
const DNS_NAMESPACE: &str = "_domainkey";

#[derive(Debug)]
pub(crate) enum DkimPublicKey {
    Rsa(RsaPublicKey),
    Ed25519(ed25519_dalek::PublicKey),
}

#[derive(Debug)]
pub enum DkimPrivateKey {
    Rsa(RsaPrivateKey),
    Ed25519(ed25519_dalek::Keypair),
}

// https://datatracker.ietf.org/doc/html/rfc6376#section-6.1.1
fn validate_header<'a>(value: &'a str) -> Result<DKIMHeader, DKIMError> {
    let (_, tags) =
        parser::tag_list(value).map_err(|err| DKIMError::SignatureSyntaxError(err.to_string()))?;

    // Check presence of required tags
    {
        let mut tag_names: HashSet<String> = HashSet::new();
        for tag in &tags {
            tag_names.insert(tag.name.clone());
        }
        for required in REQUIRED_TAGS {
            if tag_names.get(*required).is_none() {
                return Err(DKIMError::SignatureMissingRequiredTag(required));
            }
        }
    }

    let mut tags_map = IndexMap::new();
    for tag in &tags {
        tags_map.insert(tag.name.clone(), tag.clone());
    }
    let header = DKIMHeader {
        tags: tags_map,
        raw_bytes: value.to_owned(),
    };
    // FIXME: we could get the keys instead of generating tag_names ourselves

    // Check version
    {
        let version = header.get_required_tag("v");
        if version != "1" {
            return Err(DKIMError::IncompatibleVersion);
        }
    }

    // Check that "d=" tag is the same as or a parent domain of the domain part
    // of the "i=" tag
    if let Some(user) = header.get_tag("i") {
        let signing_domain = header.get_required_tag("d");
        // TODO: naive check, should switch to parsing the domains/email
        if !user.ends_with(&signing_domain) {
            return Err(DKIMError::DomainMismatch);
        }
    }

    // Check that "h=" tag includes the From header
    {
        let value = header.get_required_tag("h");
        let headers = value.split(":");
        let headers: Vec<String> = headers.map(|h| h.to_lowercase()).collect();
        if !headers.contains(&"from".to_string()) {
            return Err(DKIMError::FromFieldNotSigned);
        }
    }

    if let Some(query_method) = header.get_tag("q") {
        if query_method != "dns/txt" {
            return Err(DKIMError::UnsupportedQueryMethod);
        }
    }

    // Check that "x=" tag isn't expired
    if let Some(expiration) = header.get_tag("x") {
        let mut expiration = chrono::NaiveDateTime::from_timestamp_opt(
            expiration.parse::<i64>().unwrap_or_default(),
            0,
        )
        .ok_or_else(|| DKIMError::MalformedBody)?;
        expiration += chrono::Duration::minutes(SIGN_EXPIRATION_DRIFT_MINS);
        let now = chrono::Utc::now().naive_utc();
        if now > expiration {
            return Err(DKIMError::SignatureExpired);
        }
    }

    Ok(header)
}

// https://datatracker.ietf.org/doc/html/rfc6376#section-6.1.3 Step 4
fn verify_signature(
    hash_algo: hash::HashAlgo,
    header_hash: Vec<u8>,
    signature: Vec<u8>,
    public_key: DkimPublicKey,
) -> Result<bool, DKIMError> {
    Ok(match public_key {
        DkimPublicKey::Rsa(public_key) => public_key
            .verify(
                rsa::PaddingScheme::PKCS1v15Sign {
                    hash: Some(match hash_algo {
                        hash::HashAlgo::RsaSha1 => rsa::hash::Hash::SHA1,
                        hash::HashAlgo::RsaSha256 => rsa::hash::Hash::SHA2_256,
                        hash => {
                            return Err(DKIMError::UnsupportedHashAlgorithm(format!("{:?}", hash)))
                        }
                    }),
                },
                &header_hash,
                &signature,
            )
            .is_ok(),
        DkimPublicKey::Ed25519(public_key) => public_key
            .verify_strict(
                &header_hash,
                &ed25519_dalek::Signature::from_bytes(&signature)
                    .map_err(|err| DKIMError::SignatureSyntaxError(err.to_string()))?,
            )
            .is_ok(),
    })
}

fn verify_email_header<'a, T: dns::Lookup>(
    resolver: &T,
    dkim_header: &'a DKIMHeader,
    email: &'a mailparse::ParsedMail<'a>,
) -> Result<(canonicalization::Type, canonicalization::Type), DKIMError> {
    let public_key = public_key::retrieve_public_key(
        resolver,
        dkim_header.get_required_tag("d"),
        dkim_header.get_required_tag("s"),
    )?;

    let (header_canonicalization_type, body_canonicalization_type) =
        parser::parse_canonicalization(dkim_header.get_tag("c"))?;
    let hash_algo = parser::parse_hash_algo(&dkim_header.get_required_tag("a"))?;
    let computed_body_hash = hash::compute_body_hash(
        body_canonicalization_type.clone(),
        dkim_header.get_tag("l"),
        hash_algo.clone(),
        email,
    )?;
    let computed_headers_hash = hash::compute_headers_hash(
        header_canonicalization_type.clone(),
        &dkim_header.get_required_tag("h"),
        hash_algo.clone(),
        &dkim_header,
        email,
    )?;

    let header_body_hash = dkim_header.get_required_tag("bh").clone();
    if header_body_hash != computed_body_hash {
        return Err(DKIMError::BodyHashDidNotVerify);
    }

    let signature = base64::decode(dkim_header.get_required_tag("b")).map_err(|err| {
        DKIMError::SignatureSyntaxError(format!("failed to decode signature: {}", err))
    })?;
    if !verify_signature(hash_algo, computed_headers_hash, signature, public_key)? {
        return Err(DKIMError::SignatureDidNotVerify);
    }

    Ok((header_canonicalization_type, body_canonicalization_type))
}

/// Run the DKIM verification on the email providing an existing resolver
pub fn verify_email_with_resolver<'a, T: dns::Lookup>(
    email: &'a mailparse::ParsedMail<'a>,
    resolver: &T,
) -> Result<DKIMResult, DKIMError> {
    let mut last_error = None;

    for h in email.headers.get_all_headers(HEADER) {
        let value = String::from_utf8_lossy(h.get_value_raw());

        let dkim_header = match validate_header(&value) {
            Ok(v) => v,
            Err(err) => {
                last_error = Some(err);
                continue;
            }
        };

        match verify_email_header(resolver, &dkim_header, email) {
            Ok((header_canonicalization_type, body_canonicalization_type)) => {
                return Ok(DKIMResult::pass(
                    header_canonicalization_type,
                    body_canonicalization_type,
                ))
            }
            Err(err) => {
                last_error = Some(err);
                continue;
            }
        }
    }

    if let Some(err) = last_error {
        Ok(DKIMResult::fail(err))
    } else {
        Ok(DKIMResult::neutral())
    }
}

#[cfg(test)]
mod tests {
    use crate::dns::Lookup;

    use super::*;

    struct MockResolver {}

    impl Lookup for MockResolver {
        fn lookup_txt(&self, name: &str) -> Result<Vec<String>, DKIMError> {
            match name {
                "brisbane._domainkey.football.example.com" => {
                    Ok(vec![
                        "v=DKIM1; k=ed25519; p=11qYAYKxCrfVS/7TyWQHOg7hcvPapiMlrwIaaPcHURo="
                            .to_string(),
                    ])
                }
                "newengland._domainkey.example.com" => Ok(vec![
                    "v=DKIM1; p=MIGJAoGBALVI635dLK4cJJAH3Lx6upo3X/Lm1tQz3mezcWTA3BUBnyIsdnRf57aD5BtNmhPrYYDlWlzw3UgnKisIxktkk5+iMQMlFtAS10JB8L3YadXNJY+JBcbeSi5TgJe4WFzNgW95FWDAuSTRXSWZfA/8xjflbTLDx0euFZOM7C4T0GwLAgMBAAE=".to_string(),
                ]),
                _ => {
                    println!("asked to resolve: {}", name);
                    todo!()
                }
            }
        }
    }

    impl MockResolver {
        fn new() -> Self {
            MockResolver {}
        }
    }

    #[test]
    fn test_validate_header() {
        let header = r#"v=1; a=rsa-sha256; d=example.net; s=brisbane;
c=relaxed/simple; q=dns/txt; i=foo@eng.example.net;
t=1117574938; x=9118006938; l=200;
h=from:to:subject:date:keywords:keywords;
z=From:foo@eng.example.net|To:joe@example.com|
Subject:demo=20run|Date:July=205,=202005=203:44:08=20PM=20-0700;
bh=MTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTI=;
b=dzdVyOfAKCdLXdJOc9G2q8LoXSlEniSbav+yuU4zGeeruD00lszZ
      VoG4ZHRNiYzR
        "#;
        validate_header(header).unwrap();
    }

    #[test]
    fn test_validate_header_missing_tag() {
        let header = "v=1; a=rsa-sha256; bh=a; b=b";
        assert_eq!(
            validate_header(header).unwrap_err(),
            DKIMError::SignatureMissingRequiredTag("d")
        );
    }

    #[test]
    fn test_validate_header_domain_mismatch() {
        let header = r#"v=1; a=rsa-sha256; d=example.net; s=brisbane; i=foo@hein.com; h=headers; bh=hash; b=hash
        "#;
        assert_eq!(
            validate_header(header).unwrap_err(),
            DKIMError::DomainMismatch
        );
    }

    #[test]
    fn test_validate_header_incompatible_version() {
        let header = r#"v=3; a=rsa-sha256; d=example.net; s=brisbane; i=foo@example.net; h=headers; bh=hash; b=hash
        "#;
        assert_eq!(
            validate_header(header).unwrap_err(),
            DKIMError::IncompatibleVersion
        );
    }

    #[test]
    fn test_validate_header_missing_from_in_headers_signature() {
        let header = r#"v=1; a=rsa-sha256; d=example.net; s=brisbane; i=foo@example.net; h=Subject:A:B; bh=hash; b=hash
        "#;
        assert_eq!(
            validate_header(header).unwrap_err(),
            DKIMError::FromFieldNotSigned
        );
    }

    #[test]
    fn test_validate_header_expired_in_drift() {
        let mut now = chrono::Utc::now().naive_utc();
        now -= chrono::Duration::seconds(1);

        let header = format!("v=1; a=rsa-sha256; d=example.net; s=brisbane; i=foo@example.net; h=From:B; bh=hash; b=hash; x={}", now.timestamp());

        assert!(validate_header(&header).is_ok());
    }

    #[test]
    fn test_validate_header_expired() {
        let mut now = chrono::Utc::now().naive_utc();
        now -= chrono::Duration::hours(3);

        let header = format!("v=1; a=rsa-sha256; d=example.net; s=brisbane; i=foo@example.net; h=From:B; bh=hash; b=hash; x={}", now.timestamp());

        assert_eq!(
            validate_header(&header).unwrap_err(),
            DKIMError::SignatureExpired
        );
    }

    #[test]
    fn test_validate_email_header_ed25519() {
        let raw_email = r#"DKIM-Signature: v=1; a=ed25519-sha256; c=relaxed/relaxed;
 d=football.example.com; i=@football.example.com;
 q=dns/txt; s=brisbane; t=1528637909; h=from : to :
 subject : date : message-id : from : subject : date;
 bh=2jUSOH9NhtVGCQWNr9BrIAPreKQjO6Sn7XIkfJVOzv8=;
 b=/gCrinpcQOoIfuHNQIbq4pgh9kyIK3AQUdt9OdqQehSwhEIug4D11Bus
 Fa3bT3FY5OsU7ZbnKELq+eXdp1Q1Dw==
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
 d=football.example.com; i=@football.example.com;
 q=dns/txt; s=test; t=1528637909; h=from : to : subject :
 date : message-id : from : subject : date;
 bh=2jUSOH9NhtVGCQWNr9BrIAPreKQjO6Sn7XIkfJVOzv8=;
 b=F45dVWDfMbQDGHJFlXUNB2HKfbCeLRyhDXgFpEL8GwpsRe0IeIixNTe3
 DhCVlUrSjV4BwcVcOF6+FF3Zo9Rpo1tFOeS9mPYQTnGdaSGsgeefOsk2Jz
 dA+L10TeYt9BgDfQNZtKdN1WO//KgIqXP7OdEFE4LjFYNcUxZQ4FADY+8=
From: Joe SixPack <joe@football.example.com>
To: Suzie Q <suzie@shopping.example.net>
Subject: Is dinner ready?
Date: Fri, 11 Jul 2003 21:00:37 -0700 (PDT)
Message-ID: <20030712040037.46341.5F8J@football.example.com>

Hi.

We lost the game.  Are you hungry yet?

Joe."#
            .replace("\n", "\r\n");

        let email = mailparse::parse_mail(raw_email.as_bytes()).unwrap();
        let h = email
            .headers
            .get_all_headers(HEADER)
            .first()
            .unwrap()
            .get_value_raw();
        let raw_header_dkim = String::from_utf8_lossy(h);

        let resolver = MockResolver::new();

        let dkim_verify_result = verify_email_header(
            &resolver,
            &validate_header(&raw_header_dkim).unwrap(),
            &email,
        );

        assert!(dkim_verify_result.is_ok());
    }

    #[test]
    fn test_validate_email_header_rsa() {
        // unfortunately the original RFC spec had a typo, and the mail content differs
        // between algorithms
        // https://www.rfc-editor.org/errata_search.php?rfc=6376&rec_status=0
        let raw_email =
            r#"DKIM-Signature: a=rsa-sha256; bh=2jUSOH9NhtVGCQWNr9BrIAPreKQjO6Sn7XIkfJVOzv8=;
 c=simple/simple; d=example.com;
 h=Received:From:To:Subject:Date:Message-ID; i=joe@football.example.com;
 s=newengland; t=1615825284; v=1;
 b=Xh4Ujb2wv5x54gXtulCiy4C0e+plRm6pZ4owF+kICpYzs/8WkTVIDBrzhJP0DAYCpnL62T0G
 k+0OH8pi/yqETVjKtKk+peMnNvKkut0GeWZMTze0bfq3/JUK3Ln3jTzzpXxrgVnvBxeY9EZIL4g
 s4wwFRRKz/1bksZGSjD8uuSU=
Received: from client1.football.example.com  [192.0.2.1]
      by submitserver.example.com with SUBMISSION;
      Fri, 11 Jul 2003 21:01:54 -0700 (PDT)
From: Joe SixPack <joe@football.example.com>
To: Suzie Q <suzie@shopping.example.net>
Subject: Is dinner ready?
Date: Fri, 11 Jul 2003 21:00:37 -0700 (PDT)
Message-ID: <20030712040037.46341.5F8J@football.example.com>

Hi.

We lost the game. Are you hungry yet?

Joe.
"#
            .replace("\n", "\r\n");
        let email = mailparse::parse_mail(raw_email.as_bytes()).unwrap();
        let h = email
            .headers
            .get_all_headers(HEADER)
            .first()
            .unwrap()
            .get_value_raw();
        let raw_header_rsa = String::from_utf8_lossy(h);

        let resolver = MockResolver::new();

        let dkim_verify_result = verify_email_header(
            &resolver,
            &validate_header(&raw_header_rsa).unwrap(),
            &email,
        );

        assert!(dkim_verify_result.is_ok());
    }
}

'''
'''--- dkim/src/parser.rs ---
use crate::{canonicalization, hash, DKIMError};
use nom::bytes::complete::tag;
use nom::bytes::complete::take_while1;
use nom::character::complete::alpha1;
use nom::combinator::opt;
use nom::multi::fold_many0;
use nom::sequence::delimited;
use nom::sequence::pair;
use nom::sequence::preceded;
use nom::sequence::terminated;
use nom::IResult;

#[derive(Clone, Debug, PartialEq)]
/// DKIM signature tag
pub struct Tag {
    /// Name of the tag (v, i, a, h, ...)
    pub name: String,
    /// Value of the tag with spaces removed
    pub value: String,
    /// Value of the tag as seen in the text
    pub raw_value: String,
}

/// Main entrypoint of the parser. Parses the DKIM signature tag list
/// as specified <https://datatracker.ietf.org/doc/html/rfc6376#section-3.6.1>.
/// tag-list  =  tag-spec *( ";" tag-spec ) [ ";" ]
pub fn tag_list(input: &str) -> IResult<&str, Vec<Tag>> {
    let (input, start) = tag_spec(input)?;

    terminated(
        fold_many0(
            preceded(tag(";"), tag_spec),
            move || vec![start.clone()],
            |mut acc: Vec<Tag>, item| {
                acc.push(item);
                acc
            },
        ),
        opt(tag(";")),
    )(input)
}

/// tag-spec  =  [FWS] tag-name [FWS] "=" [FWS] tag-value [FWS]
fn tag_spec(input: &str) -> IResult<&str, Tag> {
    let (input, name) = delimited(opt(fws), tag_name, opt(fws))(input)?;
    let (input, _) = tag("=")(input)?;

    // Parse the twice to keep the original text
    let value_input = input;
    let (_, raw_value) = delimited(opt(fws), raw_tag_value, opt(fws))(value_input)?;
    let (input, value) = delimited(opt(fws), tag_value, opt(fws))(value_input)?;

    Ok((
        input,
        Tag {
            name: name.to_owned(),
            value,
            raw_value,
        },
    ))
}

/// tag-name  =  ALPHA *ALNUMPUNC
/// ALNUMPUNC =  ALPHA / DIGIT / "_"
fn tag_name(input: &str) -> IResult<&str, &str> {
    alpha1(input)
}

/// tag-value =  [ tval *( 1*(WSP / FWS) tval ) ]
/// tval      =  1*VALCHAR
/// VALCHAR   =  %x21-3A / %x3C-7E
fn tag_value(input: &str) -> IResult<&str, String> {
    let is_valchar = |c| (c >= '!' && c <= ':') || (c >= '<' && c <= '~');
    match opt(take_while1(is_valchar))(input)? {
        (input, Some(start)) => fold_many0(
            preceded(fws, take_while1(is_valchar)),
            || start.to_owned(),
            |mut acc: String, item| {
                acc += item;
                acc
            },
        )(input),
        (input, None) => Ok((input, "".to_string())),
    }
}

fn raw_tag_value(input: &str) -> IResult<&str, String> {
    let is_valchar = |c| (c >= '!' && c <= ':') || (c >= '<' && c <= '~');
    match opt(take_while1(is_valchar))(input)? {
        (input, Some(start)) => fold_many0(
            pair(fws, take_while1(is_valchar)),
            || start.to_owned(),
            |mut acc: String, item| {
                acc += &(item.0.to_owned() + item.1);
                acc
            },
        )(input),
        (input, None) => Ok((input, "".to_string())),
    }
}

/// FWS is folding whitespace.  It allows multiple lines separated by CRLF followed by at least one whitespace, to be joined.
fn fws(input: &str) -> IResult<&str, &str> {
    take_while1(|c| c == ' ' || c == '\t' || c == '\r' || c == '\n')(input)
}

pub(crate) fn parse_hash_algo(value: &String) -> Result<hash::HashAlgo, DKIMError> {
    use hash::HashAlgo;
    match value.as_str() {
        "rsa-sha1" => Ok(HashAlgo::RsaSha1),
        "rsa-sha256" => Ok(HashAlgo::RsaSha256),
        "ed25519-sha256" => Ok(HashAlgo::Ed25519Sha256),
        e => Err(DKIMError::UnsupportedHashAlgorithm(e.to_string())),
    }
}

/// Parses the canonicalization value (passed in c=) and returns canonicalization
/// for (Header, Body)
pub(crate) fn parse_canonicalization(
    value: Option<String>,
) -> Result<(canonicalization::Type, canonicalization::Type), DKIMError> {
    use canonicalization::Type::{Relaxed, Simple};
    if value.is_none() {
        return Ok((Simple, Simple));
    }
    match value.unwrap().as_str() {
        "simple/simple" => Ok((Simple, Simple)),
        "relaxed/simple" => Ok((Relaxed, Simple)),
        "simple/relaxed" => Ok((Simple, Relaxed)),
        "relaxed/relaxed" => Ok((Relaxed, Relaxed)),
        "relaxed" => Ok((Relaxed, Simple)),
        "simple" => Ok((Simple, Simple)),
        v => Err(DKIMError::UnsupportedCanonicalizationType(v.to_owned())),
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_canonicalization_empty() {
        use canonicalization::Type::Simple;
        assert_eq!(parse_canonicalization(None).unwrap(), (Simple, Simple));
    }

    #[test]
    fn test_canonicalization_one_algo() {
        use canonicalization::Type::{Relaxed, Simple};

        assert_eq!(
            parse_canonicalization(Some("simple".to_string())).unwrap(),
            (Simple, Simple)
        );
        assert_eq!(
            parse_canonicalization(Some("relaxed".to_string())).unwrap(),
            (Relaxed, Simple)
        );
    }

    #[test]
    fn test_tag_list() {
        assert_eq!(
            tag_list("a = a/1@.-:= ").unwrap(),
            (
                "",
                vec![Tag {
                    name: "a".to_string(),
                    value: "a/1@.-:=".to_string(),
                    raw_value: "a/1@.-:=".to_string()
                }]
            )
        );
        assert_eq!(
            tag_list("a= a ; b = a\n    bc").unwrap(),
            (
                "",
                vec![
                    Tag {
                        name: "a".to_string(),
                        value: "a".to_string(),
                        raw_value: "a".to_string()
                    },
                    Tag {
                        name: "b".to_string(),
                        value: "abc".to_string(),
                        raw_value: "a\n    bc".to_string()
                    }
                ]
            )
        );
    }

    #[test]
    fn test_tag_spec() {
        assert_eq!(
            tag_spec("a=b").unwrap(),
            (
                "",
                Tag {
                    name: "a".to_string(),
                    value: "b".to_string(),
                    raw_value: "b".to_string()
                }
            )
        );
        assert_eq!(
            tag_spec("a=b c d e f").unwrap(),
            (
                "",
                Tag {
                    name: "a".to_string(),
                    value: "bcdef".to_string(),
                    raw_value: "b c d e f".to_string()
                }
            )
        );
    }

    #[test]
    fn test_tag_list_dns() {
        assert_eq!(
            tag_list("k=rsa; p=kEy+/").unwrap(),
            (
                "",
                vec![
                    Tag {
                        name: "k".to_string(),
                        value: "rsa".to_string(),
                        raw_value: "rsa".to_string()
                    },
                    Tag {
                        name: "p".to_string(),
                        value: "kEy+/".to_string(),
                        raw_value: "kEy+/".to_string()
                    }
                ]
            )
        );
    }
}

'''
'''--- dkim/src/public_key.rs ---
use rsa::{pkcs1, pkcs8};
use std::collections::HashMap;

use crate::{dns, parser, DKIMError, DkimPublicKey, DNS_NAMESPACE};

const RSA_KEY_TYPE: &str = "rsa";
const ED25519_KEY_TYPE: &str = "ed25519";

// https://datatracker.ietf.org/doc/html/rfc6376#section-6.1.2
pub(crate) fn retrieve_public_key<T: dns::Lookup>(
    resolver: &T,
    domain: String,
    subdomain: String,
) -> Result<DkimPublicKey, DKIMError> {
    let dns_name = format!("{}.{}.{}", subdomain, DNS_NAMESPACE, domain);
    let res = resolver.lookup_txt(&dns_name)?;
    // TODO: Return multiple keys for when verifiying the signatures. During key
    // rotation they are often multiple keys to consider.
    let txt = res.first().ok_or(DKIMError::NoKeyForSignature)?;

    // Parse the tags inside the DKIM TXT DNS record
    let (_, tags) = parser::tag_list(txt).map_err(|_| DKIMError::KeySyntaxError)?;

    let mut tags_map = HashMap::new();
    for tag in &tags {
        tags_map.insert(tag.name.clone(), tag.clone());
    }

    // Check version
    if let Some(version) = tags_map.get("v") {
        if version.value != "DKIM1" {
            return Err(DKIMError::KeyIncompatibleVersion);
        }
    }

    // Get key type
    let key_type = match tags_map.get("k") {
        Some(v) => {
            if v.value != RSA_KEY_TYPE && v.value != ED25519_KEY_TYPE {
                return Err(DKIMError::InappropriateKeyAlgorithm);
            }
            v.value.clone()
        }
        None => RSA_KEY_TYPE.to_string(),
    };

    let tag = tags_map.get("p").ok_or(DKIMError::NoKeyForSignature)?;
    let bytes = base64::decode(&tag.value).map_err(|err| {
        DKIMError::KeyUnavailable(format!("failed to decode public key: {}", err))
    })?;
    let key = if key_type == RSA_KEY_TYPE {
        DkimPublicKey::Rsa(
            pkcs8::DecodePublicKey::from_public_key_der(&bytes)
                .or_else(|_| pkcs1::DecodeRsaPublicKey::from_pkcs1_der(&bytes))
                .map_err(|err| {
                    DKIMError::KeyUnavailable(format!("failed to parse public key: {}", err))
                })?,
        )
    } else {
        DkimPublicKey::Ed25519(ed25519_dalek::PublicKey::from_bytes(&bytes).map_err(|err| {
            DKIMError::KeyUnavailable(format!("failed to parse public key: {}", err))
        })?)
    };
    Ok(key)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_retrieve_public_key() {
        struct TestResolver {}
        impl dns::Lookup for TestResolver {
            fn lookup_txt(&self, name: &str) -> Result<Vec<String>, DKIMError> {
                assert_eq!(name, "dkim._domainkey.cloudflare.com");
                Ok(vec!["v=DKIM1; k=rsa; p=MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA6gmVDBSBJ0l1/33uAF0gwIsrjQV6nnYjL9DMX6+ez4NNJ2um0InYy128Rd+OlIhmdSld6g3tj3O6R+BwsYsQgU8RWE8VJaRybvPw2P3Asgms4uPrFWHSFiWMPH0P9i/oPwnUO9jZKHiz4+MzFC3bG8BacX7YIxCuWnDU8XNmNsRaLmrv9CHX4/3GHyoHSmDA1ETtyz9JHRCOC8ho8C7b4f2Auwedlau9Lid9LGBhozhgRFhrFwFMe93y34MO1clPbY6HwxpudKWBkMQCTlmXVRnkKxHlJ+fYCyC2jjpCIbGWj2oLxBtFOASWMESR4biW0ph2bsZXslcUSPMTVTkFxQIDAQAB".to_string()])
            }
        }
        let resolver = TestResolver {};

        retrieve_public_key(&resolver, "cloudflare.com".to_string(), "dkim".to_string()).unwrap();
    }

    #[test]
    fn test_retrieve_public_key_incompatible_version() {
        struct TestResolver {}
        impl dns::Lookup for TestResolver {
            fn lookup_txt(&self, name: &str) -> Result<Vec<String>, DKIMError> {
                assert_eq!(name, "dkim._domainkey.cloudflare.com");
                Ok(vec!["v=DKIM6; p=key".to_string()])
            }
        }
        let resolver = TestResolver {};

        let key = retrieve_public_key(&resolver, "cloudflare.com".to_string(), "dkim".to_string())
            .unwrap_err();
        assert_eq!(key, DKIMError::KeyIncompatibleVersion);
    }

    #[test]
    fn test_retrieve_public_key_inappropriate_key_algorithm() {
        struct TestResolver {}
        impl dns::Lookup for TestResolver {
            fn lookup_txt(&self, name: &str) -> Result<Vec<String>, DKIMError> {
                assert_eq!(name, "dkim._domainkey.cloudflare.com");
                Ok(vec!["v=DKIM1; p=key; k=foo".to_string()])
            }
        }
        let resolver = TestResolver {};

        let key = retrieve_public_key(&resolver, "cloudflare.com".to_string(), "dkim".to_string())
            .unwrap_err();
        assert_eq!(key, DKIMError::InappropriateKeyAlgorithm);
    }
}

'''
'''--- dkim/src/result.rs ---
use crate::{canonicalization, DKIMError};

#[derive(Clone)]
/// Result of the DKIM verification
pub struct DKIMResult {
    value: &'static str,
    error: Option<DKIMError>,
    header_canonicalization_type: Option<canonicalization::Type>,
    body_canonicalization_type: Option<canonicalization::Type>,
}
impl DKIMResult {
    /// Constructs a `pass` result
    pub fn pass(
        header_canonicalization_type: canonicalization::Type,
        body_canonicalization_type: canonicalization::Type,
    ) -> Self {
        DKIMResult {
            value: "pass",
            error: None,
            header_canonicalization_type: Some(header_canonicalization_type),
            body_canonicalization_type: Some(body_canonicalization_type),
        }
    }
    /// Constructs a `neutral` result
    pub fn neutral() -> Self {
        DKIMResult {
            value: "neutral",
            error: None,
            header_canonicalization_type: None,
            body_canonicalization_type: None,
        }
    }
    /// Constructs a `fail` result with a reason
    pub fn fail(reason: DKIMError) -> Self {
        DKIMResult {
            value: "fail",
            error: Some(reason),
            header_canonicalization_type: None,
            body_canonicalization_type: None,
        }
    }

    pub fn error(&self) -> Option<DKIMError> {
        self.error.clone()
    }

    /// Returns the verification result as a summary: fail, neutral or pass.
    pub fn summary(&self) -> &'static str {
        self.value
    }

    /// Returns the header canocalization type
    pub fn header_canonicalization_type(&self) -> Option<canonicalization::Type> {
        self.header_canonicalization_type.clone()
    }

    /// Returns the body canocalization type
    pub fn body_canonicalization_type(&self) -> Option<canonicalization::Type> {
        self.body_canonicalization_type.clone()
    }

    /// Similar to `summary` but with detail on fail. Typically used for the
    /// `Authentication-Results` header.
    pub fn with_detail(&self) -> String {
        if let Some(err) = self.error() {
            format!("{} ({})", self.value, err)
        } else {
            self.value.to_owned()
        }
    }
}

'''
'''--- dkim/src/roundtrip_test.rs ---
#[cfg(test)]
mod tests {
    use crate::{
        dns, verify_email_with_resolver, DKIMError, DKIMResult, DkimPrivateKey, SignerBuilder,
    };
    use chrono::TimeZone;
    use regex::Regex;
    use rsa::pkcs1::DecodeRsaPrivateKey;
    use std::collections::HashMap;
    use std::path::Path;

    fn dkim_record() -> String {
        let data = std::fs::read_to_string("./test/keys/2022.txt").unwrap();
        let re = Regex::new(r#"".*""#).unwrap();

        let mut out = "".to_owned();
        for m in re.find_iter(&data) {
            out += &m.as_str().replace("\"", "");
        }
        out
    }

    fn sign(domain: &str, raw_email: &str) -> String {
        let email = mailparse::parse_mail(raw_email.as_bytes()).unwrap();

        let private_key =
            rsa::RsaPrivateKey::read_pkcs1_pem_file(Path::new("./test/keys/2022.private")).unwrap();
        let time = chrono::Utc.ymd(2021, 1, 1).and_hms_milli(0, 0, 1, 444);

        let signer = SignerBuilder::new()
            .with_signed_headers(&["From", "Subject"])
            .unwrap()
            .with_private_key(DkimPrivateKey::Rsa(private_key))
            .with_selector("2022")
            .with_signing_domain(domain)
            .with_time(time)
            .build()
            .unwrap();
        let header = signer.sign(&email).unwrap();

        format!("{}\n{}", header, raw_email)
    }

    fn verify<T: dns::Lookup>(resolver: &T, raw_email: &str) -> DKIMResult {
        let email = mailparse::parse_mail(raw_email.as_bytes()).unwrap();

        verify_email_with_resolver(&email, resolver).unwrap()
    }

    macro_rules! map {
        { $($key:expr => $value:expr),+ } => {
             {
                 let mut m = ::std::collections::HashMap::new();
                 $(
                     m.insert($key, $value);
                 )+
                     m
             }
         };
    }

    struct TestResolver {
        db: HashMap<&'static str, String>,
    }

    fn test_resolver(db: HashMap<&'static str, String>) -> TestResolver {
        impl dns::Lookup for TestResolver {
            fn lookup_txt(&self, name: &str) -> Result<Vec<String>, DKIMError> {
                let res = if let Some(value) = self.db.get(name) {
                    vec![value.to_string()]
                } else {
                    unreachable!("attempted to resolve: {}", name)
                };
                Ok(res)
            }
        }
        TestResolver { db }
    }

    #[test]
    fn test_roundtrip() {
        let resolver = test_resolver(map! {
            "2022._domainkey.cloudflare.com" => dkim_record()
        });
        let from_domain = "cloudflare.com";

        {
            let email = r#"Subject: subject
From: Sven Sauleau <sven@cloudflare.com>

Hello Alice
"#;

            let signed_email = sign(from_domain, email);
            let res = verify(&resolver, &signed_email);
            assert_eq!(res.with_detail(), "pass")
        }

        {
            let email = r#"Subject: subject
From: Sven Sauleau <sven@cloudflare.com>

.Hello Alice...
.
...
"#;

            let signed_email = sign(from_domain, email);
            let res = verify(&resolver, &signed_email);
            assert_eq!(res.with_detail(), "pass")
        }

        {
            let email = r#"Subject: subject
From: Sven Sauleau <sven@cloudflare.com>
Mime-Version: 1.0
Content-Type: multipart/alternative; boundary=2c637dd08e3ccac9b9425780c2e07981cb322e7feed138813fb1ab054047

--2c637dd08e3ccac9b9425780c2e07981cb322e7feed138813fb1ab054047
Content-Transfer-Encoding: 7bit
Content-Type: text/plain; charset=ascii

text here
--2c637dd08e3ccac9b9425780c2e07981cb322e7feed138813fb1ab054047
Content-Transfer-Encoding: quoted-printable
Content-Type: text/html; charset=ascii

<!doctype html><html xmlns=3D"http://www.w3.org/1999/xhtml" xmlns:v=3D"urn:=
schemas-microsoft-com:vml" xmlns:o=3D"urn:schemas-microsoft-com:office:offi=
ce"><head><title></title><!--[if !mso]><!-- --><meta http-equiv=3D"X-UA-Com=
patible" content=3D"IE=3Dedge"><!--<![endif]--><meta http-equiv=3D"Content-=
Type" content=3D"text/html; charset=3DUTF-8"><meta name=3D"viewport" conten=
t=3D"width=3Ddevice-width,initial-scale=3D1"><style type=3D"text/css">#outl=
ook a { padding:0; }
          .ReadMsgBody { width:100%; }
          .ExternalClass { width:100%; }
      div.footer-text a {
        color: #3498db;
      }  td {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto=
', 'Oxygen', 'Ubuntu', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-se=
rif !important;
      }</style></head><body style=3D"font-size: 16px; line-height: 24px; fo=
nt-weight: normal; font-style: normal; background-color: #fbfbfb;"><div sty=
le=3D"display:none;font-size:1px;color:#ffffff;line-height:1px;max-height:0=
px;max-width:0px;opacity:0;overflow:hidden;"> Completed - No components aff=
ected - The scheduled maintenance has been completed. &zwnj;&nbsp;&zwnj;&nb=
sp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;=
&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&zw=
nj;&nbsp;&zwnj;&nbsp;&zwnj;&nbsp;&nbsp;&zwnj;&nbsp;</div>=
<div style=3D"background-color:#fbfbfb;"><!--[if mso | IE]><table align=3D"=
center" border=3D"0" cellpadding=3D"0" cellspacing=3D"0" class=3D"header-sp=
acing-outlook" style=3D"width:600px;" width=3D"600" ><tr><td style=3D"line-=
height:0px;font-size:0px;mso-line-height-rule:exactly;"><![endif]--><div cl=
ass=3D"header-spacing" style=3D"Margin:0px auto;max-width:600px;"><table al=
ign=3D"center" border=3D"0" cellpadding=3D"0" cellspacing=3D"0" role=3D"pre=
sentation" style=3D"width:100%;">

--2c637dd08e3ccac9b9425780c2e07981cb322e7feed138813fb1ab054047--
"#;

            let signed_email = sign(from_domain, email);
            let res = verify(&resolver, &signed_email);
            assert_eq!(res.with_detail(), "pass")
        }
    }
}

'''
'''--- dkim/src/sign.rs ---
use ed25519_dalek::ExpandedSecretKey;

use crate::header::DKIMHeaderBuilder;
use crate::{canonicalization, hash, DKIMError, DkimPrivateKey, HEADER};

/// Builder for the Signer
pub struct SignerBuilder<'a> {
    signed_headers: Option<&'a [&'a str]>,
    private_key: Option<DkimPrivateKey>,
    selector: Option<&'a str>,
    signing_domain: Option<&'a str>,
    time: Option<chrono::DateTime<chrono::offset::Utc>>,
    header_canonicalization: canonicalization::Type,
    body_canonicalization: canonicalization::Type,
    expiry: Option<chrono::Duration>,
}

impl<'a> SignerBuilder<'a> {
    /// New builder
    pub fn new() -> Self {
        Self {
            signed_headers: None,
            private_key: None,
            selector: None,
            signing_domain: None,
            expiry: None,
            time: None,

            header_canonicalization: canonicalization::Type::Simple,
            body_canonicalization: canonicalization::Type::Simple,
        }
    }

    /// Specify headers to be used in the DKIM signature
    /// The From: header is required.
    pub fn with_signed_headers(mut self, headers: &'a [&'a str]) -> Result<Self, DKIMError> {
        let from = headers.iter().find(|h| h.to_lowercase() == "from");
        if from.is_none() {
            return Err(DKIMError::BuilderError("missing From in signed headers"));
        }

        self.signed_headers = Some(headers);
        Ok(self)
    }

    /// Specify the private key used to sign the email
    pub fn with_private_key(mut self, key: DkimPrivateKey) -> Self {
        self.private_key = Some(key);
        self
    }

    /// Specify the private key used to sign the email
    pub fn with_selector(mut self, value: &'a str) -> Self {
        self.selector = Some(value);
        self
    }

    /// Specify for which domain the email should be signed for
    pub fn with_signing_domain(mut self, value: &'a str) -> Self {
        self.signing_domain = Some(value);
        self
    }

    /// Specify the header canonicalization
    pub fn with_header_canonicalization(mut self, value: canonicalization::Type) -> Self {
        self.header_canonicalization = value;
        self
    }

    /// Specify the body canonicalization
    pub fn with_body_canonicalization(mut self, value: canonicalization::Type) -> Self {
        self.body_canonicalization = value;
        self
    }

    /// Specify current time. Mostly used for testing
    pub fn with_time(mut self, value: chrono::DateTime<chrono::offset::Utc>) -> Self {
        self.time = Some(value);
        self
    }

    /// Specify a expiry duration for the signature validity
    pub fn with_expiry(mut self, value: chrono::Duration) -> Self {
        self.expiry = Some(value);
        self
    }

    /// Build an instance of the Signer
    /// Must be provided: signed_headers, private_key, selector, logger and
    /// signing_domain.
    pub fn build(self) -> Result<Signer<'a>, DKIMError> {
        use DKIMError::BuilderError;

        let private_key = self
            .private_key
            .ok_or(BuilderError("missing required private key"))?;
        let hash_algo = match private_key {
            DkimPrivateKey::Rsa(_) => hash::HashAlgo::RsaSha256,
            DkimPrivateKey::Ed25519(_) => hash::HashAlgo::Ed25519Sha256,
        };

        Ok(Signer {
            signed_headers: self
                .signed_headers
                .ok_or(BuilderError("missing required signed headers"))?,
            private_key: private_key,
            selector: self
                .selector
                .ok_or(BuilderError("missing required selector"))?,
            signing_domain: self
                .signing_domain
                .ok_or(BuilderError("missing required logger"))?,
            header_canonicalization: self.header_canonicalization,
            body_canonicalization: self.body_canonicalization,
            expiry: self.expiry,
            hash_algo: hash_algo,
            time: self.time,
        })
    }
}

pub struct Signer<'a> {
    signed_headers: &'a [&'a str],
    private_key: DkimPrivateKey,
    selector: &'a str,
    signing_domain: &'a str,
    header_canonicalization: canonicalization::Type,
    body_canonicalization: canonicalization::Type,
    expiry: Option<chrono::Duration>,
    hash_algo: hash::HashAlgo,
    time: Option<chrono::DateTime<chrono::offset::Utc>>,
}

/// DKIM signer. Use the [SignerBuilder] to build an instance.
impl<'a> Signer<'a> {
    /// Sign a message
    /// As specified in <https://datatracker.ietf.org/doc/html/rfc6376#section-5>
    pub fn sign<'b>(&self, email: &'b mailparse::ParsedMail<'b>) -> Result<String, DKIMError> {
        let body_hash = self.compute_body_hash(email)?;
        let dkim_header_builder = self.dkim_header_builder(&body_hash)?;

        let header_hash = self.compute_header_hash(email, dkim_header_builder.clone())?;

        let signature = match &self.private_key {
            DkimPrivateKey::Rsa(private_key) => private_key
                .sign(
                    rsa::PaddingScheme::PKCS1v15Sign {
                        hash: Some(match &self.hash_algo {
                            hash::HashAlgo::RsaSha1 => rsa::hash::Hash::SHA1,
                            hash::HashAlgo::RsaSha256 => rsa::hash::Hash::SHA2_256,
                            hash => {
                                return Err(DKIMError::UnsupportedHashAlgorithm(format!(
                                    "{:?}",
                                    hash
                                )))
                            }
                        }),
                    },
                    &header_hash,
                )
                .map_err(|err| DKIMError::FailedToSign(err.to_string()))?,
            DkimPrivateKey::Ed25519(keypair) => {
                let expanded: ExpandedSecretKey = (&keypair.secret).into();
                expanded
                    .sign(&header_hash, &keypair.public)
                    .to_bytes()
                    .into()
            }
        };

        // add the signature into the DKIM header and generate the header
        let dkim_header = dkim_header_builder
            .add_tag("b", &base64::encode(&signature))
            .build()?;

        Ok(format!("{}: {}", HEADER, dkim_header.raw_bytes))
    }

    fn dkim_header_builder(&self, body_hash: &str) -> Result<DKIMHeaderBuilder, DKIMError> {
        let now = chrono::offset::Utc::now();
        let hash_algo = match self.hash_algo {
            hash::HashAlgo::RsaSha1 => "rsa-sha1",
            hash::HashAlgo::RsaSha256 => "rsa-sha256",
            hash::HashAlgo::Ed25519Sha256 => "ed25519-sha256",
        };

        let mut builder = DKIMHeaderBuilder::new()
            .add_tag("v", "1")
            .add_tag("a", hash_algo)
            .add_tag("d", &self.signing_domain)
            .add_tag("s", self.selector)
            .add_tag(
                "c",
                &format!(
                    "{}/{}",
                    self.header_canonicalization.to_string(),
                    self.body_canonicalization.to_string()
                ),
            )
            .add_tag("bh", body_hash)
            .set_signed_headers(self.signed_headers);
        if let Some(expiry) = self.expiry {
            builder = builder.set_expiry(expiry)?;
        }
        if let Some(time) = self.time {
            builder = builder.set_time(time);
        } else {
            builder = builder.set_time(now.into());
        }

        Ok(builder)
    }

    fn compute_body_hash<'b>(
        &self,
        email: &'b mailparse::ParsedMail<'b>,
    ) -> Result<String, DKIMError> {
        let length = None;
        let canonicalization = self.body_canonicalization.clone();
        hash::compute_body_hash(canonicalization, length, self.hash_algo.clone(), email)
    }

    fn compute_header_hash<'b>(
        &self,
        email: &'b mailparse::ParsedMail<'b>,
        dkim_header_builder: DKIMHeaderBuilder,
    ) -> Result<Vec<u8>, DKIMError> {
        let canonicalization = self.header_canonicalization.clone();

        // For signing the DKIM-Signature header the signature needs to be null
        let dkim_header = dkim_header_builder.add_tag("b", "").build()?;
        let signed_headers = dkim_header.get_required_tag("h");

        hash::compute_headers_hash(
            canonicalization,
            &signed_headers,
            self.hash_algo.clone(),
            &dkim_header,
            email,
        )
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use chrono::TimeZone;
    use rsa::pkcs1::DecodeRsaPrivateKey;
    use std::{fs, path::Path};

    #[test]
    fn test_sign_rsa() {
        let email = mailparse::parse_mail(
            r#"Subject: subject
From: Sven Sauleau <sven@cloudflare.com>

Hello Alice
        "#
            .as_bytes(),
        )
        .unwrap();

        let private_key =
            rsa::RsaPrivateKey::read_pkcs1_pem_file(Path::new("./test/keys/2022.private")).unwrap();
        let time = chrono::Utc.ymd(2021, 1, 1).and_hms_milli(0, 0, 1, 444);

        let signer = SignerBuilder::new()
            .with_signed_headers(&["From", "Subject"])
            .unwrap()
            .with_private_key(DkimPrivateKey::Rsa(private_key))
            .with_selector("s20")
            .with_signing_domain("example.com")
            .with_time(time)
            .build()
            .unwrap();
        let header = signer.sign(&email).unwrap();

        assert_eq!(header, "DKIM-Signature: v=1; a=rsa-sha256; d=example.com; s=s20; c=simple/simple; bh=frcCV1k9oG9oKj3dpUqdJg1PxRT2RSN/XKdLCPjaYaY=; h=from:subject; t=1609459201; b=ohfeeUk89mJI/nTb8cViCbOY11tYBkj0xecrpXVwPdkvLMYMZemydr01nUuruhrzaqxFcqgjdEB/alen4NygDo3Kj//GsEUksRO13Hi1aW5lfxLj7Ifux96CbKm3EEcI5rD9tXQ0LaW5nYUdqYdFVIgmU/qTtXRenMxesHhggknm1n6x7K4NsqBS+9leidXtKf8hTSCC7f4XMGFe2YQrCKHfYFBb/MTuzCHbF/CgZHKgMhBAYXMkuEwIGjh4xnR256AmJdxHN+JdrWYzkMdRiuDmYvlnUJdPWq0hD3fR1DxS5/YF6hNHMP9b1yM8eiUQVnqrbzR8C5KWJiM8JhaBcg==;")
    }

    #[test]
    fn test_sign_ed25519() {
        let raw_email = r#"From: Joe SixPack <joe@football.example.com>
To: Suzie Q <suzie@shopping.example.net>
Subject: Is dinner ready?
Date: Fri, 11 Jul 2003 21:00:37 -0700 (PDT)
Message-ID: <20030712040037.46341.5F8J@football.example.com>

Hi.

We lost the game.  Are you hungry yet?

Joe."#
            .replace("\n", "\r\n");
        let email = mailparse::parse_mail(raw_email.as_bytes()).unwrap();

        let file_content = fs::read("./test/keys/ed.private").unwrap();
        let file_decoded = base64::decode(file_content).unwrap();
        let secret_key = ed25519_dalek::SecretKey::from_bytes(&file_decoded).unwrap();

        let file_content = fs::read("./test/keys/ed.public").unwrap();
        let file_decoded = base64::decode(file_content).unwrap();
        let public_key = ed25519_dalek::PublicKey::from_bytes(&file_decoded).unwrap();

        let keypair = ed25519_dalek::Keypair {
            public: public_key,
            secret: secret_key,
        };

        let time = chrono::Utc.ymd(2018, 6, 10).and_hms_milli(13, 38, 29, 444);

        let signer = SignerBuilder::new()
            .with_signed_headers(&[
                "From",
                "To",
                "Subject",
                "Date",
                "Message-ID",
                "From",
                "Subject",
                "Date",
            ])
            .unwrap()
            .with_private_key(DkimPrivateKey::Ed25519(keypair))
            .with_body_canonicalization(canonicalization::Type::Relaxed)
            .with_header_canonicalization(canonicalization::Type::Relaxed)
            .with_selector("brisbane")
            .with_signing_domain("football.example.com")
            .with_time(time)
            .build()
            .unwrap();
        let header = signer.sign(&email).unwrap();

        assert_eq!(header, "DKIM-Signature: v=1; a=ed25519-sha256; d=football.example.com; s=brisbane; c=relaxed/relaxed; bh=2jUSOH9NhtVGCQWNr9BrIAPreKQjO6Sn7XIkfJVOzv8=; h=from:to:subject:date:message-id:from:subject:date; t=1528637909; b=wITr2H3sBuBfMsnUwlRTO7Oq/C/jd2vubDm50DrXtMFEBLRiz9GfrgCozcg764+gYqWXV3Snd1ynYh8sJ5BXBg==;")
    }
}

'''
'''--- dkim/test/keys/2022.txt ---
2022._domainkey	IN	TXT	( "v=DKIM1; h=sha256; k=rsa; t=y:s; "
	  "p=MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAyrnZAH3hf+hp53o5gz7CfRNHme6iCW8koRNgV3bDiZcPxoC9nhjyMPWD/rizalhykziEaz0WBodeSalGjTXqH6yrlUobekxJO9UmzKrIpWCfsdbHLfTHCO6kk4JLeKs+hRs+/v2tPvcVnGD/A76cBXI5ksfrtUzeTlsPDYDSbafgBXvi9CTMAEUd3iB+HtjQbNuQJbNnZrLotB"
	  "PGjuFTcUKCafCmFu31K6ZMDnOJadfoZO8cClti53V2DLz7NDO3kZIGiAHsNcptcZN3MnHRhMl2Buy5vdi4lfDXhjl5ozhb8MeY0LAJikJm9RUQ3GcHBdvqchnz53gcNXIApMuK2QIDAQAB" )  ; ----- DKIM key 2022 for example.com

'''
'''--- email-relayer/Cargo.toml ---
[package]
name = "sender"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
anyhow = "1.0.69"
serde_json = "1.0.85"
native-tls = "0.2.2"
imap = "2.4.1"
itertools = "0.10.5"
workspaces = "0.7.0"

tokio = { version = "1.21.2", features = ["macros", "rt-multi-thread"] }

'''
'''--- email-relayer/src/main.rs ---
use imap::Session;
use native_tls::TlsStream;
use serde_json::json;
use std::str::FromStr;
use std::{env, net::TcpStream, time::Duration};
use workspaces::{types::SecretKey, Network};
use workspaces::{AccountId, InMemorySigner, Worker};

fn create_imap_session(
    username: &str,
    password: &str,
) -> anyhow::Result<Session<TlsStream<TcpStream>>> {
    let domain = "imap.gmail.com";
    let tls = native_tls::TlsConnector::builder().build()?;

    // we pass in the domain twice to check that the server's TLS
    // certificate is valid for the domain we're connecting to.
    let client = imap::connect((domain, 993), domain, &tls)?;

    // the client we have here is unauthenticated.
    // to do anything useful with the e-mails, we need to log in
    Ok(client.login(username, password).map_err(|e| e.0)?)
}

fn fetch_inbox_from(
    min_value: u32,
    username: &str,
    password: &str,
) -> anyhow::Result<(u32, Vec<String>)> {
    // Ensure that sessions are short-lived to avoid timeouts
    let mut imap_session = create_imap_session(username, password)?;

    // Opens mailbox in read-only mode.
    // TODO: Make sure that INBOX is the correct name for our email provider of choosing.
    let mailbox = imap_session.examine("INBOX")?;

    let result = if mailbox.exists > min_value {
        let max_value = mailbox.exists;
        let mail_indices = (min_value + 1..=max_value).map(|x| x.to_string());

        let messages = imap_session.fetch(itertools::join(mail_indices, ","), "RFC822")?;

        Ok((
            max_value,
            messages
                .iter()
                .map(|message| {
                    let body = message.body().expect("message did not have a body!");
                    std::str::from_utf8(body)
                        .expect("message was not valid utf-8")
                        .to_string()
                })
                .collect(),
        ))
    } else {
        Ok((min_value, vec![]))
    };
    imap_session.logout()?;

    result
}

async fn send_mail<N: Network + ?Sized>(
    worker: &Worker<N>,
    signer: &InMemorySigner,
    controller_account_id: &AccountId,
    mail: &str,
) -> anyhow::Result<()> {
    let payload = mail.as_bytes().to_vec();
    worker
        .call(signer, controller_account_id, "receive_email")
        .args(json!({ "full_email": payload }).to_string().into_bytes())
        .max_gas()
        .transact()
        .await?
        .into_result()?;
    Ok(())
}

fn parse_env_var<T: FromStr>(key: &str) -> anyhow::Result<T> {
    Ok(env::var(key)
        .map_err(|err| anyhow::anyhow!("Failed to get {}: {}", key, err))?
        .parse()
        .map_err(|_| anyhow::anyhow!("Failed to parse {}", key))?)
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let signer_account: AccountId = parse_env_var("SENDER_SIGNER_NEAR_ACCOUNT")?;
    let signer_account_secret_key: SecretKey = parse_env_var("SENDER_SIGNER_SECRET_KEY")?;
    let controller_account: AccountId = parse_env_var("SENDER_CONTROLLER_NEAR_ACCOUNT")?;
    let imap_username: String = parse_env_var("SENDER_IMAP_USERNAME")?;
    let imap_password: String = parse_env_var("SENDER_IMAP_PASSWORD")?;

    // TODO: Make network dynamically choosable based on SENDER_NEAR_NETWORK
    let worker = workspaces::testnet().await?;
    let signer = InMemorySigner::from_secret_key(signer_account, signer_account_secret_key);

    println!("Starting...");

    // TODO: Properly detect unprocessed emails. See https://github.com/near/email-auth/issues/4
    let mut min_value = 0;
    let (value, _) = fetch_inbox_from(min_value, &imap_username, &imap_password)?;
    min_value = value;
    println!("Already {} email present - ignoring.", min_value);

    loop {
        let (value, mails) = fetch_inbox_from(min_value, &imap_username, &imap_password)?;
        min_value = value;
        if !mails.is_empty() {
            println!("Got new mail: {:?}", mails.len());
            for mail in mails.iter() {
                send_mail(&worker, &signer, &controller_account, mail).await?;
            }
        }
        tokio::time::sleep(Duration::from_secs(10)).await;
    }
}

'''