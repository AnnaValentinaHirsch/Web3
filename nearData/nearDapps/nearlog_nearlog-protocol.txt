*GitHub Repository "nearlog/nearlog-protocol"*

'''--- Cargo.toml ---
[package]
name = "nearlog-protocol"
version = "0.1.0"
authors = ["TN <tiennh.cf@nearlenddao.com>"]
edition = "2018"

[dev-dependencies]
near-sdk = "=4.0.0-pre.7"
near-sdk-sim = "=4.0.0-pre.7"
near-contract-standards = "=4.0.0-pre.7"

contract = { path = "./contract" }

approx = "0.5"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "s"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[workspace]
members = [
    "contract",
]

'''
'''--- README.md ---
# Nearlog Protocol Contract

Nearlog protolcol is a native Near open-source option market that allows traders to buy and sell options on cryptocurrencies against a pool of liquidity.

## Getting started

```
cd existing_repo
git remote add origin https://github.com/nearlog/nearlog-protocol.git
git branch -M main
git push -uf origin main
```

## Build

```
./build.sh
```

## Deploy

```
./scripts/0_deploy.sh
```

## Actions

### Register account by paying for storage

This has to be done one per account.

```bash
near call $CONTRACT_ID --accountId=$ACCOUNT_ID --gas=$GAS --amount=0.1 storage_deposit '{}'
```

### Deposit liquidity

For example, let's deposit `5` WETH.

```bash
near call $WETH_TOKEN_ID --accountId=$ACCOUNT_ID --gas=$GAS --amount=$ONE_YOCTO ft_transfer_call '{
  "receiver_id": "'$CONTRACT_ID'",
  "amount": "5000000000000000000",
  "msg": ""
}'
```

### View account information

```bash
near view $CONTRACT_ID get_account '{"account_id": "'$ACCOUNT_ID'"}'
```

### View a given asset

```bash
near view $CONTRACT_ID get_asset '{"token_id": "'$WETH_TOKEN_ID'"}'
```

### Create a call option

```
near call $ORACLE_ID --accountId=$MAIN_ACCOUNT oracle_call '{  "receiver_id": "'$CONTRACT_ID'",
  "asset_ids": [
    "'$WETH_TOKEN_ID'",
    "'$USDT_TOKEN_ID'",
  ],
  "msg": "{\"Execute\": {\"actions\": [{\"Create\":{\"option_type\": \"call\", \"strike\": \"20000\", \"expiration\": \"1663078814\", \"amount\": \"1\", \"token_id\":\"'$WETH_TOKEN_ID'\"}}]}}"
}' --amount=$ONE_YOCTO --gas=$GAS
```

### Create a put option

```
near call $ORACLE_ID --accountId=$MAIN_ACCOUNT oracle_call '{  "receiver_id": "'$CONTRACT_ID'",
  "asset_ids": [
    "'$WETH_TOKEN_ID'",
    "'$USDT_TOKEN_ID'",
  ],
  "msg": "{\"Execute\": {\"actions\": [{\"Create\":{\"option_type\": \"put\", \"strike\": \"20000\", \"expiration\": \"1663078814\", \"amount\": \"1\", \"token_id\":\"'$WETH_TOKEN_ID'\"}}]}}"
}' --amount=$ONE_YOCTO --gas=$GAS
```

### Exercise an option

```
near call $ORACLE_ID --accountId=$MAIN_ACCOUNT oracle_call '{  "receiver_id": "'$CONTRACT_ID'",
  "asset_ids": [
    "'$WETH_TOKEN_ID'",
    "'$USDT_TOKEN_ID'",
  ],
  "msg": "{\"Execute\": {\"actions\": [{\"Exercise\":{\"option_id\": \"1111\", \"token_id\":\"'$WETH_TOKEN_ID'\"}}]}}"
}' --amount=$ONE_YOCTO --gas=$GAS
```

'''
'''--- build.sh ---
#!/bin/bash
TARGET="${CARGO_TARGET_DIR:-target}"
set -e

cd "$(dirname $0)"

perl -i -pe 's/\["cdylib", "rlib"\]/\["cdylib"\]/' contract/Cargo.toml

RUSTFLAGS='-C link-arg=-s' cargo build --all --target wasm32-unknown-unknown --release
cp $TARGET/wasm32-unknown-unknown/release/contract.wasm ./res/nearlog_protocol.wasm

perl -i -pe 's/\["cdylib"\]/\["cdylib", "rlib"\]/' contract/Cargo.toml

'''
'''--- contract/Cargo.toml ---
[package]
name = "contract"
version = "0.1.0"
authors = ["TN <tiennh.cf@nearlenddao.com>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "=4.0.0-pre.7"
near-contract-standards = "=4.0.0-pre.7"
near-sys = "=0.1"
uint = { version = "=0.9.0", default-features = false }
once_cell = "=1.8.0"
libm = "0.2.5"

[dev-dependencies]
rand = "0.8"

'''
'''--- contract/src/account.rs ---
use crate::*;

#[derive(BorshSerialize, BorshDeserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Account {
    /// A copy of an account ID. Saves one storage_read when iterating on accounts.
    pub account_id: AccountId,
    /// A list of assets that are supplied by the account.
    /// It's not returned for account pagination.
    pub supplied: HashMap<TokenId, Shares>,
    /// A list of option orders are bought by the account
    pub options: HashMap<OptionId, OptionOrder>,
    /// Tracks changes in storage usage by persistent collections in this account.
    #[borsh_skip]
    #[serde(skip)]
    pub storage_tracker: StorageTracker,
}

impl Account {
    pub fn new(account_id: &AccountId) -> Self {
        Self {
            account_id: account_id.clone(),
            supplied: HashMap::new(),
            options: HashMap::new(),
            storage_tracker: Default::default(),
        }
    }
}

impl Contract {
    pub fn internal_get_account(&self, account_id: &AccountId) -> Option<Account> {
        self.accounts.get(account_id).map(|o| o.into())
    }

    pub fn internal_unwrap_account(&self, account_id: &AccountId) -> Account {
        self.internal_get_account(account_id)
            .expect("Account is not registered")
    }

    pub fn internal_set_account(&mut self, account_id: &AccountId, mut account: Account) {
        let mut storage = self.internal_unwrap_storage(account_id);
        storage
            .storage_tracker
            .consume(&mut account.storage_tracker);
        storage.storage_tracker.start();
        self.accounts.insert(account_id, &account.into());
        storage.storage_tracker.stop();
        self.internal_set_storage(account_id, storage);
    }
}

#[near_bindgen]
impl Contract {
    /// Returns detailed information about an account for a given account_id.
    /// The information includes all supplied assets.
    /// Each asset includes the current balance and the number of shares.
    pub fn get_account(&self, account_id: AccountId) -> Option<Account> {
        self.internal_get_account(&account_id)
    }

    /// Returns the number of accounts
    pub fn get_num_accounts(&self) -> u32 {
        self.accounts.len() as _
    }
}

'''
'''--- contract/src/account_asset.rs ---
use crate::*;

#[derive(BorshSerialize, BorshDeserialize)]
pub struct AccountAsset {
    pub shares: Shares,
}

impl AccountAsset {
    pub fn new() -> Self {
        Self { shares: 0.into() }
    }

    pub fn deposit_shares(&mut self, shares: Shares) {
        self.shares.0 += shares.0;
    }

    pub fn withdraw_shares(&mut self, shares: Shares) {
        if let Some(new_balance) = self.shares.0.checked_sub(shares.0) {
            self.shares.0 = new_balance;
        } else {
            env::panic_str("Not enough asset balance");
        }
    }

    pub fn is_empty(&self) -> bool {
        self.shares.0 == 0
    }
}

impl Account {
    pub fn internal_unwrap_asset(&self, token_id: &TokenId) -> AccountAsset {
        self.internal_get_asset(token_id).expect("Asset not found")
    }

    pub fn internal_get_asset(&self, token_id: &TokenId) -> Option<AccountAsset> {
        self.supplied
            .get(token_id)
            .map(|&shares| AccountAsset { shares })
    }

    pub fn internal_get_asset_or_default(&mut self, token_id: &TokenId) -> AccountAsset {
        self.internal_get_asset(token_id)
            .unwrap_or_else(AccountAsset::new)
    }

    pub fn internal_set_asset(&mut self, token_id: &TokenId, account_asset: AccountAsset) {
        if account_asset.is_empty() {
            self.supplied.remove(token_id);
        } else {
            self.supplied.insert(token_id.clone(), account_asset.shares);
        }
    }
}

'''
'''--- contract/src/actions.rs ---
use std::ops::{Div, Mul};

use crate::*;

#[derive(Deserialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, Serialize))]
#[serde(crate = "near_sdk::serde")]
pub struct OptionOrderReq {
    pub option_id: OptionId,
    pub option_type: OptionType,
    pub strike: Balance,
    pub amount: Balance,
    pub token_id: TokenId,
    pub expiration: f64,
}

#[derive(Deserialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, Serialize))]
#[serde(crate = "near_sdk::serde")]
pub enum Action {
    Create(OptionOrderReq),
    Exercise(OptionOrderReq),
}

impl Contract {
    pub fn internal_execute(
        &mut self,
        account_id: &AccountId,
        account: &mut Account,
        actions: Vec<Action>,
        prices: Prices,
    ) {
        for action in actions {
            match action {
                Action::Create(option_order_req) => {
                    self.internal_create_order(&option_order_req, &prices);
                }
                Action::Exercise(option_order_req) => {
                    self.internal_exercise_order(&option_order_req, &prices);
                }
            }
        }
    }

    pub fn internal_create_order(&mut self, option_order_req: &OptionOrderReq, prices: &Prices) {
        let mut asset = self.internal_unwrap_asset(&option_order_req.token_id);
        let price = prices.get_unwrap(&option_order_req.token_id);
        let mut option_order = self.internal_get_order_or_default(&option_order_req.option_id);

        let spot_price =
            BigDecimal::from_balance_price(option_order.amount, price, asset.config.extra_decimals);

        let s_price = spot_price.f64();
        let k_price = option_order_req.strike as f64;
        let expiration_time = option_order_req.expiration;
        let volatility = asset.config.volatility_ratio as f64 / 10000f64;
        let risk_free = asset.config.risk_free as f64 / 10000f64;

        let option = BlackScholes {
            S: s_price,         // spot price
            K: k_price,         // strike price
            r: risk_free,       // risk-free rate 1.6%
            t: expiration_time, // 1 month until expiration
            v: volatility,      // 15% volatility
        };

        // Example
        // let option = BlackScholes {
        //     S: 100.00,        // spot price
        //     K: 110.00,        // strike price
        //     r: 0.016,         // risk-free rate 1.6%
        //     t: 0.08333333333, // 1 month until expiration
        //     v: 0.15,          // 15% volatility
        // };

        let next_option_id = self.current_option_id + 1;
        self.current_option_id = next_option_id;
        option_order.option_id = next_option_id;

        option_order.option_type = option_order_req.option_type.clone();
        option_order.amount = option_order_req.amount;
        if option_order_req.option_type == OptionType::Call {
            option_order.premium = option.call_price();
        } else {
            option_order.premium = option.put_price();
        }

        // Locked liquidity
        let available_amount = asset.available_amount();
        let max_lock_shares = asset.locked.amount_to_shares(available_amount, false);

        let (locked_shares, amount) = asset_amount_to_shares(
            &asset.locked,
            max_lock_shares,
            &option_order_req.amount,
            true,
        );

        asset.locked.deposit(locked_shares, option_order_req.amount);

        self.internal_set_asset(&option_order_req.token_id, asset);

        events::emit::create(&option_order_req.option_id, &option_order);
    }

    pub fn internal_exercise_order(&mut self, option_order_req: &OptionOrderReq, prices: &Prices) {
        let asset = self.internal_unwrap_asset(&option_order_req.token_id);
        let price = prices.get_unwrap(&option_order_req.token_id);
        let option_order = self
            .internal_get_order(&option_order_req.option_id)
            .expect("Can't get the option order");

        let current_price =
            BigDecimal::from_balance_price(option_order.amount, price, asset.config.extra_decimals);

        let strike_price =
            BigDecimal::from_balance_price(option_order.strike, price, asset.config.extra_decimals);

        assert!(strike_price.le(&current_price), "Current price is too low");

        let profit = current_price
            .sub(strike_price)
            .mul(BigDecimal::from(option_order.amount))
            .div(current_price);

        log!(
            "===> Exercise: OptionID: {:?}, profit {:?}",
            &option_order_req.option_id,
            profit.to_string()
        );

        events::emit::exercise(&option_order_req.option_id);
    }

    pub fn internal_deposit(
        &mut self,
        account: &mut Account,
        token_id: &TokenId,
        amount: Balance,
    ) -> Shares {
        let mut asset = self.internal_unwrap_asset(token_id);
        let mut account_asset = account.internal_get_asset_or_default(token_id);

        let shares: Shares = asset.supplied.amount_to_shares(amount, false);

        account_asset.deposit_shares(shares);
        account.internal_set_asset(&token_id, account_asset);

        asset.supplied.deposit(shares, amount);
        self.internal_set_asset(token_id, asset);

        shares
    }
}

fn asset_amount_to_shares(
    pool: &Pool,
    available_shares: Shares,
    amount: &u128,
    inverse_round_direction: bool,
) -> (Shares, Balance) {
    let (shares, amount) = (
        pool.amount_to_shares(amount.clone(), !inverse_round_direction),
        amount,
    );

    (shares, *amount)
}

#[near_bindgen]
impl Contract {
    /// Executes a given list actions on behalf of the predecessor account.
    /// - Requires one yoctoNEAR.
    #[payable]
    pub fn execute(&mut self, actions: Vec<Action>) {
        assert_one_yocto();
        let account_id = env::predecessor_account_id();
        let mut account = self.internal_unwrap_account(&account_id);
        self.internal_execute(&account_id, &mut account, actions, Prices::new());
        self.internal_set_account(&account_id, account);
    }
}

'''
'''--- contract/src/asset.rs ---
use crate::*;

pub const MS_PER_YEAR: u64 = 31536000000;

#[derive(BorshSerialize, BorshDeserialize, Serialize, Clone)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, Deserialize))]
#[serde(crate = "near_sdk::serde")]
pub struct Asset {
    /// Total supplied, but excluding reserved.
    pub supplied: Pool,
    /// Total locked.
    pub locked: Pool,
    /// The amount reserved for the stability.
    pub reserved: Balance,
    /// When the asset was last updated. It's always going to be the current block timestamp.
    pub last_update_timestamp: Timestamp,
    /// The asset config.
    pub config: AssetConfig,
}

impl Asset {
    pub fn new(timestamp: Timestamp, config: AssetConfig) -> Self {
        Self {
            supplied: Pool::new(),
            locked: Pool::new(),
            reserved: 0,
            last_update_timestamp: timestamp,
            config,
        }
    }

    pub fn available_amount(&self) -> Balance {
        self.supplied.balance + self.reserved - self.locked.balance
    }
}

impl Contract {
    pub fn internal_unwrap_asset(&self, token_id: &TokenId) -> Asset {
        self.internal_get_asset(token_id).expect("Asset not found")
    }

    pub fn internal_get_asset(&self, token_id: &TokenId) -> Option<Asset> {
        let asset = self.assets.get(token_id);
        asset
    }

    pub fn internal_set_asset(&mut self, token_id: &TokenId, asset: Asset) {
        self.assets.insert(token_id, &asset.into());
    }
}

#[near_bindgen]
impl Contract {
    pub fn get_asset(&self, token_id: AccountId) -> Option<Asset> {
        self.internal_get_asset(&token_id)
    }
}

'''
'''--- contract/src/asset_config.rs ---
use crate::*;

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug))]
#[serde(crate = "near_sdk::serde")]
pub struct AssetConfig {
    /// The ratio of interest that is reserved by the protocol (multiplied by 10000).
    /// E.g. 2500 means 25% from interests goes to the reserve.
    pub reserve_ratio: u32,
    /// The maximum share of the pool size that
    /// could be utilized as a collateral in the options.
    /// Example: if `MaxUtilizationRate` = 50, then only 50%
    /// of liquidity on the pools contracts would be used for
    /// collateralizing options while 50% will be sitting idle
    /// available for withdrawals by the liquidity providers.
    /// The utilization ratio in a range of 50% — 100%
    pub max_utilization_rate: u32,

    /// The collateralization ratio for the option.
    /// collateral size that will be locked at the moment of buying them.
    /// The collateralization ratio in a range of 30% — 100%
    /// Example: if `CollateralizationRatio` = 50, then 50% of an option's
    /// notional size will be locked in the pools at the moment of buying it:
    /// say, 1 ETH call option will be collateralized with 0.5 ETH (50%).
    pub collateralization_ratio: u32,

    /// Volatility ratio (multiplied by 10000).
    pub volatility_ratio: u32,

    /// The risk free rate
    pub risk_free: u32,

    /// The amount of extra decimals to use for the fungible token. For example, if the asset like
    /// USDT has `6` decimals in the metadata, the `extra_decimals` can be set to `12`, to make the
    /// inner balance of USDT at `18` decimals.
    pub extra_decimals: u8,
    /// Whether the deposits of this assets are enabled.
    pub can_deposit: bool,
    /// Whether the withdrawals of this assets are enabled.
    pub can_withdraw: bool,
}

'''
'''--- contract/src/big_decimal.rs ---
use crate::*;
use near_sdk::borsh::maybestd::io::Write;
use near_sdk::json_types::U128;
use near_sdk::serde::Serializer;
use std::cmp::Ordering;
use std::fmt::{Display, Formatter};
use std::ops::{Add, Div, Mul, Sub};
#[cfg(not(target_arch = "wasm32"))]
use std::str::FromStr;

uint::construct_uint!(
    pub struct U256(4);
);

uint::construct_uint!(
    pub struct U384(6);
);

pub(crate) const MAX_RATIO: u32 = 10000;

const NUM_DECIMALS: u8 = 27;
const BIG_DIVISOR: u128 = 10u128.pow(NUM_DECIMALS as u32);
const HALF_DIVISOR: u128 = BIG_DIVISOR / 2;

pub type LowU128 = U128;

#[derive(Copy, Clone)]
pub struct BigDecimal(U384);

impl Default for BigDecimal {
    fn default() -> Self {
        BigDecimal::zero()
    }
}

impl Display for BigDecimal {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        let a = self.0 / U384::from(BIG_DIVISOR);
        let b = (self.0 - a * U384::from(BIG_DIVISOR)).as_u128();
        if b > 0 {
            write!(f, "{}", format!("{}.{:027}", a, b).trim_end_matches('0'))
        } else {
            write!(f, "{}.0", a)
        }
    }
}

#[cfg(not(target_arch = "wasm32"))]
impl std::fmt::Debug for BigDecimal {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self)
    }
}

#[cfg(not(target_arch = "wasm32"))]
const PARSE_INT_ERROR: &'static str = "Parse int error";

#[cfg(not(target_arch = "wasm32"))]
impl FromStr for BigDecimal {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let dot_pos = s.find('.');
        let (int, dec) = if let Some(dot_pos) = dot_pos {
            (
                &s[..dot_pos],
                format!("{:0<27}", &s[dot_pos + 1..])
                    .parse()
                    .map_err(|_| PARSE_INT_ERROR)?,
            )
        } else {
            (s, 0u128)
        };
        let int = U384::from_str(&int).map_err(|_| PARSE_INT_ERROR)?;
        if dec >= BIG_DIVISOR {
            return Err(String::from("The decimal part is too large"));
        }
        Ok(Self(int * U384::from(BIG_DIVISOR) + U384::from(dec)))
    }
}

impl Serialize for BigDecimal {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(&self.to_string())
    }
}

#[cfg(not(target_arch = "wasm32"))]
impl<'de> Deserialize<'de> for BigDecimal {
    fn deserialize<D>(
        deserializer: D,
    ) -> Result<Self, <D as near_sdk::serde::Deserializer<'de>>::Error>
    where
        D: near_sdk::serde::Deserializer<'de>,
    {
        let s: String = Deserialize::deserialize(deserializer)?;
        Ok(Self::from_str(&s).map_err(|err| near_sdk::serde::de::Error::custom(err))?)
    }
}

impl From<u128> for BigDecimal {
    fn from(a: u128) -> Self {
        Self(U384::from(a) * U384::from(BIG_DIVISOR))
    }
}

impl From<u64> for BigDecimal {
    fn from(a: u64) -> Self {
        Self(U384::from(a) * U384::from(BIG_DIVISOR))
    }
}

impl From<u32> for BigDecimal {
    fn from(a: u32) -> Self {
        Self(U384::from(a) * U384::from(BIG_DIVISOR))
    }
}

impl From<f64> for BigDecimal {
    fn from(a: f64) -> Self {
        let base = a as u128;
        Self(
            U384::from(base) * U384::from(BIG_DIVISOR)
                + U384::from((a.fract() * (BIG_DIVISOR as f64)) as u128),
        )
    }
}

impl Add for BigDecimal {
    type Output = Self;

    fn add(self, rhs: BigDecimal) -> Self::Output {
        Self(self.0 + rhs.0)
    }
}

impl Sub for BigDecimal {
    type Output = Self;

    fn sub(self, rhs: BigDecimal) -> Self::Output {
        Self(self.0 - rhs.0)
    }
}

impl Mul for BigDecimal {
    type Output = Self;

    fn mul(self, rhs: Self) -> Self::Output {
        Self((self.0 * rhs.0 + U384::from(HALF_DIVISOR)) / U384::from(BIG_DIVISOR))
    }
}

impl Div for BigDecimal {
    type Output = Self;

    fn div(self, rhs: Self) -> Self::Output {
        Self((self.0 * U384::from(BIG_DIVISOR) + U384::from(HALF_DIVISOR)) / rhs.0)
    }
}

impl From<LowU128> for BigDecimal {
    fn from(low_u128: LowU128) -> Self {
        Self(U384::from(low_u128.0))
    }
}

impl From<BigDecimal> for LowU128 {
    fn from(bd: BigDecimal) -> Self {
        Self(bd.0.low_u128())
    }
}

impl BigDecimal {
    pub fn from_ratio(ratio: u32) -> Self {
        Self(U384::from(ratio) * U384::from(BIG_DIVISOR / (MAX_RATIO as u128)))
    }

    pub fn mul_ratio(&self, ratio: u32) -> Self {
        Self((self.0 * U384::from(ratio) + U384::from(MAX_RATIO / 2)) / U384::from(MAX_RATIO))
    }

    pub fn div_ratio(&self, ratio: u32) -> Self {
        Self((self.0 * U384::from(MAX_RATIO) + U384::from(MAX_RATIO / 2)) / U384::from(ratio))
    }

    pub fn from_balance_price(balance: Balance, price: &Price, extra_decimals: u8) -> Self {
        let num = U384::from(price.multiplier) * U384::from(balance);
        let denominator_decimals = price.decimals + extra_decimals;
        if denominator_decimals > NUM_DECIMALS {
            Self(num / U384::exp10((denominator_decimals - NUM_DECIMALS) as usize))
        } else {
            Self(num * U384::exp10((NUM_DECIMALS - denominator_decimals) as usize))
        }
    }

    pub fn round_u128(&self) -> u128 {
        ((self.0 + U384::from(HALF_DIVISOR)) / U384::from(BIG_DIVISOR)).as_u128()
    }

    pub fn f64(&self) -> f64 {
        let base = (self.0 / U384::from(BIG_DIVISOR)).as_u128();
        let fract = (self.0 - (U384::from(base) * U384::from(BIG_DIVISOR))).as_u128() as f64;
        base as f64 + fract / (BIG_DIVISOR as f64)
    }

    pub fn round_mul_u128(&self, rhs: u128) -> u128 {
        ((self.0 * U384::from(rhs) + U384::from(HALF_DIVISOR)) / U384::from(BIG_DIVISOR)).as_u128()
    }

    pub fn div_u128(&self, rhs: u128) -> BigDecimal {
        Self(self.0 / U384::from(rhs))
    }

    pub fn sub(&self, rhs: BigDecimal) -> BigDecimal {
        Self(self.0 - rhs.0)
    }

    pub fn zero() -> Self {
        Self(U384::zero())
    }

    pub fn one() -> Self {
        Self(U384::from(BIG_DIVISOR))
    }

    pub fn pow(&self, mut exponent: u64) -> Self {
        let mut res = BigDecimal::one();
        let mut x = *self;

        while exponent != 0 {
            if (exponent & 1) != 0 {
                res = res * x;
            }
            exponent >>= 1;
            if exponent != 0 {
                x = x * x;
            }
        }

        res
    }
}

impl PartialEq<Self> for BigDecimal {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}

impl PartialOrd for BigDecimal {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        self.0.partial_cmp(&other.0)
    }
}

impl BorshSerialize for BigDecimal {
    fn serialize<W: Write>(&self, writer: &mut W) -> std::io::Result<()> {
        BorshSerialize::serialize(&self.0 .0, writer)
    }
}

impl BorshDeserialize for BigDecimal {
    fn deserialize(buf: &mut &[u8]) -> std::io::Result<Self> {
        Ok(Self(U384(BorshDeserialize::deserialize(buf)?)))
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use rand::RngCore;

    // Number of milliseconds in a regular year.
    const N: u64 = MS_PER_YEAR;
    // X = 2
    const LOW_X: LowU128 = U128(2000000000000000000000000000);
    // R ** N = X. So R = X ** (1/N)
    const LOW_R: LowU128 = U128(1000000000021979552909930328);

    fn b(a: u128) -> BigDecimal {
        BigDecimal::from(a)
    }

    fn almost_eq(a: u128, b: u128, prec: u32) {
        let p = 10u128.pow(27 - prec);
        let ap = (a + p / 2) / p;
        let bp = (b + p / 2) / p;
        assert_eq!(
            ap,
            bp,
            "{}",
            format!("Expected {} to eq {}, with precision {}", a, b, prec)
        );
    }

    #[test]
    fn test_simple_add() {
        assert_eq!((b(0) + b(0)).round_u128(), 0);
        assert_eq!((b(5) + b(2)).round_u128(), 7);
        assert_eq!((b(2) + b(5)).round_u128(), 7);
        assert_eq!((b(5) + b(0)).round_u128(), 5);
        assert_eq!((b(0) + b(5)).round_u128(), 5);
    }

    #[test]
    fn test_simple_div() {
        assert_eq!((b(17) / b(5)).round_u128(), 3);
        assert_eq!((b(18) / b(5)).round_u128(), 4);
        assert_eq!((b(3) / b(5)).round_u128(), 1);
    }

    #[test]
    fn test_pow() {
        let r = BigDecimal::from(LOW_R);
        let x = r.pow(N);
        let low_x = LowU128::from(x);
        almost_eq(LOW_X.0, low_x.0, 15);
    }

    #[test]
    fn test_compound_pow() {
        fn test(split_n: u64) {
            let r = BigDecimal::from(LOW_R);
            let initial_val = 12345 * 10u128.pow(24);
            let mut val = initial_val;
            for i in 1..=split_n {
                let exponent = (N * i / split_n) - (N * (i - 1) / split_n);
                let interest = r.pow(exponent);
                val = interest.round_mul_u128(val);
            }
            almost_eq(val, initial_val * 2, 15);
        }

        (1..=100).for_each(test);
    }

    #[test]
    fn test_compound_pow_precision() {
        fn test(split_n: u64) {
            let r = BigDecimal::from(LOW_R);
            let initial_val = 12345 * 10u128.pow(24);
            let mut val = initial_val;
            let exponent = N / split_n;
            assert_eq!(exponent * split_n, N);
            let interest = r.pow(exponent);
            for _ in 1..=split_n {
                val = interest.round_mul_u128(val);
            }
            almost_eq(val, initial_val * 2, 15);
        }
        test(N / 60000);
        test(N / 1000000);
        test(N / (24 * 60 * 60));
    }

    #[test]
    fn test_compound_pow_random() {
        const MAX_STEP: u64 = 1000000;
        let r = BigDecimal::from(LOW_R);
        let initial_val = 12345 * 10u128.pow(24);
        let mut val = initial_val;
        let mut total_exponent = 0;
        let mut rng = rand::thread_rng();
        while total_exponent < N {
            let exponent = std::cmp::min(N - total_exponent, rng.next_u64() % MAX_STEP + 1);
            total_exponent += exponent;
            let interest = r.pow(exponent);
            val = interest.round_mul_u128(val);
        }
        almost_eq(val, initial_val * 2, 15);
    }

    #[test]
    fn test_display() {
        assert_eq!("1.0", BigDecimal::one().to_string());
        assert_eq!("2.0", BigDecimal::from(2u32).to_string());
        assert_eq!("0.0", BigDecimal::zero().to_string());
        assert!(BigDecimal::from(1.5f64).to_string().starts_with("1.500000"));
        assert!(BigDecimal::from(0.5f64).to_string().starts_with("0.500000"));
    }
}

'''
'''--- contract/src/black_scholes.rs ---
#![allow(non_snake_case)]
use libm;

pub struct BlackScholes {
    // Stock price
    pub S: f64,
    // Strike price
    pub K: f64,
    // Risk-free rate
    pub r: f64,
    // Time to maturity as fraction of year
    pub t: f64,
    // Volatility
    pub v: f64,
}

impl BlackScholes {
    pub fn normal_cdf(&self, x: f64) -> f64 {
        return 0.5 * (1.0 + libm::erf(x / 2.0_f64.sqrt()));
    }
    pub fn get_d1(&self) -> f64 {
        return ((self.S / self.K).ln() + (self.r + (self.v.powf(2.0)) / 2.0) * self.t)
            / (self.v * self.t.sqrt());
    }
    pub fn get_d2(&self) -> f64 {
        return self.get_d1() - self.v * self.t.sqrt();
    }
    pub fn call_price(&self) -> f64 {
        return self.normal_cdf(self.get_d1()) * self.S
            - self.normal_cdf(self.get_d2()) * self.K * (-self.r * self.t).exp();
    }
    pub fn put_price(&self) -> f64 {
        return (-self.r * self.t).exp() * self.normal_cdf(-self.get_d2()) * self.K
            - self.normal_cdf(-self.get_d1()) * self.S;
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_1() {
        let option = BlackScholes {
            S: 100.00,        // spot price
            K: 110.00,        // strike price
            r: 0.016,         // risk-free rate 1.6%
            t: 0.08333333333, // 1 month until expiration
            v: 0.15,          // 15% volatility
        };

        println!("{:.4}", option.call_price());
        println!("{:.4}", option.put_price());
    }
}

'''
'''--- contract/src/config.rs ---
use crate::*;

/// Contract config
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Config {
    /// The account ID of the contract owner that allows to modify config, assets and use reserves.
    pub owner_id: AccountId,

    /// The account ID of the oracle contract
    pub oracle_account_id: AccountId,
}

impl Contract {
    pub fn internal_config(&self) -> Config {
        self.config.get().unwrap()
    }

    pub fn assert_owner(&self) {
        assert_eq!(
            &env::predecessor_account_id(),
            &self.internal_config().owner_id,
            "Not an owner"
        );
    }

    pub fn get_oracle_account_id(&self) -> AccountId {
        self.internal_config().oracle_account_id.into()
    }
}

#[near_bindgen]
impl Contract {
    #[payable]
    pub fn add_asset(&mut self, token_id: AccountId, asset_config: AssetConfig) {
        assert_one_yocto();
        self.assert_owner();
        self.internal_set_asset(&token_id, Asset::new(env::block_timestamp(), asset_config))
    }
}

'''
'''--- contract/src/events.rs ---
use crate::*;

pub mod emit {
    use super::*;
    use near_sdk::serde_json::json;

    #[derive(Serialize)]
    #[serde(crate = "near_sdk::serde")]
    struct OptionLog<'a> {
        pub option_id: &'a OptionId,
    }

    #[derive(Serialize)]
    #[serde(crate = "near_sdk::serde")]
    struct OptionCreatedLog<'a> {
        pub option_id: &'a OptionId,
        pub option_type: &'a OptionType,
        pub amount: &'a Balance,
        pub strike: &'a Balance,
        pub expiration: &'a f64,
        pub premium: &'a f64,
    }

    fn log_event<T: Serialize>(event: &str, data: T) {
        let event = json!({
            "standard": "nearlog",
            "version": "0.1.0",
            "event": event,
            "data": [data]
        });

        log!("EVENT_JSON:{}", event.to_string());
    }

    pub fn create(option_id: &OptionId, option_order: &OptionOrder) {
        log_event(
            "create",
            OptionCreatedLog {
                option_id: &option_id,
                option_type: &option_order.option_type,
                amount: &option_order.amount,
                strike: &option_order.strike,
                expiration: &option_order.expiration,
                premium: &option_order.premium,
            },
        );
    }

    pub fn exercise(option_id: &OptionId) {
        log_event(
            "exercise",
            OptionLog {
                option_id: &option_id,
            },
        );
    }
}

'''
'''--- contract/src/fungible_token.rs ---
use crate::*;
use near_contract_standards::fungible_token::receiver::FungibleTokenReceiver;
use near_sdk::json_types::U128;

use near_sdk::{log, PromiseOrValue};

#[near_bindgen]
impl FungibleTokenReceiver for Contract {
    fn ft_on_transfer(
        &mut self,
        sender_id: AccountId,
        amount: U128,
        msg: String,
    ) -> PromiseOrValue<U128> {
        let token_id = env::predecessor_account_id();
        let asset = self.internal_unwrap_asset(&token_id);

        assert!(
            asset.config.can_deposit,
            "Deposits for this asset are not enabled"
        );

        let amount = amount.0 * 10u128.pow(asset.config.extra_decimals as u32);
        log!(
            "===> sender_id: {:?}, deposit amount: {:?}, msg: {:?}",
            sender_id,
            amount,
            msg
        );

        let mut account = self.internal_unwrap_account(&sender_id);
        self.internal_deposit(&mut account, &token_id, amount);
        self.internal_set_account(&sender_id, account);

        PromiseOrValue::Value(U128(0))
    }
}

'''
'''--- contract/src/lib.rs ---
mod account;
mod account_asset;
mod actions;
mod asset;
mod asset_config;
mod big_decimal;
mod black_scholes;
mod config;
mod events;
mod fungible_token;
mod option_order;
mod option_orders_manager;
mod pool;
mod price_receiver;
mod prices;
mod storage;
mod storage_tracker;
mod utils;

pub use account::*;
pub use account_asset::*;
pub use actions::*;
pub use asset::*;
pub use asset_config::*;
pub use big_decimal::*;
pub use black_scholes::*;
pub use config::*;
pub use events::*;
pub use fungible_token::*;
pub use option_order::*;
pub use option_orders_manager::*;
pub use pool::*;
pub use price_receiver::*;
pub use prices::*;
pub use storage::*;
pub use storage_tracker::*;
pub use utils::*;

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LazyOption, LookupMap, UnorderedMap};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{
    assert_one_yocto, env, log, near_bindgen, AccountId, Balance, BorshStorageKey, PanicOnDefault,
    Promise, Timestamp,
};

use std::collections::HashMap;

pub(crate) type TokenId = AccountId;
pub(crate) type OptionId = u32;
pub type TimestampSec = u32;

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
    Assets,
    Config,
    Storage,
    Accounts,
    OptionOrders,
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    pub assets: LookupMap<TokenId, Asset>,
    pub config: LazyOption<Config>,
    pub storage: LookupMap<AccountId, Storage>,
    pub accounts: UnorderedMap<AccountId, Account>,
    pub option_orders: UnorderedMap<OptionId, OptionOrder>,
    pub current_option_id: OptionId,
}

#[near_bindgen]
impl Contract {
    /// Initializes the contract with the given config. Needs to be called once.
    #[init]
    pub fn new(config: Config) -> Self {
        Self {
            assets: LookupMap::new(StorageKey::Assets),
            config: LazyOption::new(StorageKey::Config, Some(&config)),
            storage: LookupMap::new(StorageKey::Storage),
            accounts: UnorderedMap::new(StorageKey::Accounts),
            option_orders: UnorderedMap::new(StorageKey::OptionOrders),
            current_option_id: 0u32,
        }
    }
}

'''
'''--- contract/src/option_order.rs ---
use crate::*;
use std::fmt::{Display, Formatter, Result};

#[derive(Debug, BorshSerialize, BorshDeserialize, Serialize, Deserialize, Eq, PartialEq, Clone)]
#[serde(crate = "near_sdk::serde")]
pub enum OptionType {
    Call,
    Put,
}

impl Display for OptionType {
    fn fmt(&self, f: &mut Formatter) -> Result {
        match self {
            OptionType::Call => write!(f, "Call"),
            OptionType::Put => write!(f, "Put"),
        }
    }
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct OptionOrder {
    // Option ID
    pub option_id: OptionId,
    // Option type
    pub option_type: OptionType,
    // Option amount
    pub amount: Balance,
    // Strike price of the option
    pub strike: Balance,
    // Time Option exprired
    pub expiration: f64,
    // Option premium is the income received by an investor who sells an option contract, or the current price of an option contract that has yet to expire.
    pub premium: f64,
}

impl OptionOrder {
    pub fn new() -> Self {
        Self {
            option_id: 0,
            option_type: OptionType::Call,
            amount: 0,
            strike: 0,
            expiration: 0.0,
            premium: 0.0,
        }
    }
}

'''
'''--- contract/src/option_orders_manager.rs ---
use crate::*;

impl Contract {
    pub fn internal_set_order(&mut self, option_id: &OptionId, option_order: OptionOrder) {
        self.option_orders.insert(option_id, &option_order.into());
    }

    pub fn internal_get_order(&self, option_id: &OptionId) -> Option<OptionOrder> {
        self.option_orders.get(option_id)
    }

    pub fn internal_get_order_or_default(&mut self, option_id: &OptionId) -> OptionOrder {
        self.internal_get_order(option_id)
            .unwrap_or_else(OptionOrder::new)
    }
}

// #[near_bindgen]
// impl Contract {
//     #[payable]
//     pub fn create_order(&mut self, option_order: &OptionOrder) {
//         assert_one_yocto();
//         assert!(option_order.strike > 0, "Amount is too small");

//         let next_option_id = self.current_option_id + 1;
//         self.current_option_id = next_option_id;

//         self.internal_set_order(&next_option_id, option_order.clone());
//     }
// }

'''
'''--- contract/src/pool.rs ---
use crate::*;
use near_sdk::json_types::U128;

pub type Shares = U128;

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug))]
#[serde(crate = "near_sdk::serde")]
pub struct Pool {
    pub shares: Shares,
    pub balance: Balance,
}

impl Pool {
    pub fn new() -> Self {
        Self {
            shares: 0.into(),
            balance: 0,
        }
    }

    pub fn amount_to_shares(&self, amount: Balance, round_up: bool) -> Shares {
        let shares = if self.balance == 0 {
            amount
        } else {
            let extra = if round_up {
                U256::from(self.balance - 1)
            } else {
                U256::zero()
            };
            ((U256::from(self.shares.0) * U256::from(amount) + extra) / U256::from(self.balance))
                .as_u128()
        };
        shares.into()
    }

    pub fn deposit(&mut self, shares: Shares, amount: Balance) {
        self.shares.0 += shares.0;
        self.balance += amount;
    }

    pub fn withdraw(&mut self, shares: Shares, amount: Balance) {
        self.shares.0 -= shares.0;
        self.balance -= amount;
    }
}

'''
'''--- contract/src/price_receiver.rs ---
use crate::*;
use near_sdk::serde_json;

pub type AssetId = String;
pub type DurationSec = u32;

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct AssetOptionalPrice {
    pub asset_id: AssetId,
    pub price: Option<Price>,
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct PriceData {
    pub timestamp: Timestamp,
    pub recency_duration_sec: DurationSec,

    pub prices: Vec<AssetOptionalPrice>,
}

pub trait OraclePriceReceiver {
    fn oracle_on_call(&mut self, sender_id: AccountId, data: PriceData, msg: String);
}

#[derive(Deserialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, Serialize))]
#[serde(crate = "near_sdk::serde")]
pub enum PriceReceiverMsg {
    Execute { actions: Vec<Action> },
}

#[near_bindgen]
impl OraclePriceReceiver for Contract {
    /// The method will execute a given list of actions in the msg using the prices from the `data`
    /// provided by the oracle on behalf of the sender_id.
    /// - Requires to be called by the oracle account ID.
    fn oracle_on_call(&mut self, sender_id: AccountId, data: PriceData, msg: String) {
        assert_eq!(env::predecessor_account_id(), self.get_oracle_account_id());

        let actions = match serde_json::from_str(&msg).expect("Can't parse PriceReceiverMsg") {
            PriceReceiverMsg::Execute { actions } => actions,
        };

        let mut account = self.internal_unwrap_account(&sender_id);
        self.internal_execute(&sender_id, &mut account, actions, data.into());
        self.internal_set_account(&sender_id, account);
    }
}

'''
'''--- contract/src/prices.rs ---
use crate::*;
use std::convert::TryFrom;

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone, Copy)]
#[serde(crate = "near_sdk::serde")]
pub struct Price {
    pub multiplier: Balance,
    pub decimals: u8,
}

pub struct Prices {
    prices: HashMap<TokenId, Price>,
}

impl Prices {
    pub fn new() -> Self {
        Self {
            prices: HashMap::new(),
        }
    }

    pub fn get_unwrap(&self, token_id: &TokenId) -> &Price {
        self.prices.get(token_id).expect("Asset price is missing")
    }
}

impl From<PriceData> for Prices {
    fn from(data: PriceData) -> Self {
        Self {
            prices: data
                .prices
                .into_iter()
                .filter_map(|AssetOptionalPrice { asset_id, price }| {
                    let token_id =
                        AccountId::try_from(asset_id).expect("Asset is not a valid token ID");
                    price.map(|price| (token_id, price))
                })
                .collect(),
        }
    }
}

'''
'''--- contract/src/storage.rs ---
use crate::*;
use near_contract_standards::storage_management::{
    StorageBalance, StorageBalanceBounds, StorageManagement,
};
use near_sdk::json_types::U128;
use near_sdk::StorageUsage;

/// 10000 bytes
const MIN_STORAGE_BALANCE: Balance = 10000u128 * env::STORAGE_PRICE_PER_BYTE;

#[derive(BorshSerialize, BorshDeserialize)]
pub struct Storage {
    pub storage_balance: Balance,
    pub used_bytes: StorageUsage,
    #[borsh_skip]
    pub storage_tracker: StorageTracker,
}

impl Storage {
    pub fn new() -> Self {
        Self {
            storage_balance: 0,
            used_bytes: 0,
            storage_tracker: Default::default(),
        }
    }

    fn assert_storage_covered(&self) {
        let storage_balance_needed = Balance::from(self.used_bytes) * env::storage_byte_cost();
        assert!(
            storage_balance_needed <= self.storage_balance,
            "Not enough storage balance"
        );
    }
}

impl Contract {
    pub fn internal_get_storage(&self, account_id: &AccountId) -> Option<Storage> {
        self.storage.get(account_id).map(|o| o.into())
    }

    pub fn internal_unwrap_storage(&self, account_id: &AccountId) -> Storage {
        self.internal_get_storage(account_id)
            .expect("Storage for account is missing")
    }

    pub fn internal_set_storage(&mut self, account_id: &AccountId, mut storage: Storage) {
        if storage.storage_tracker.bytes_added >= storage.storage_tracker.bytes_released {
            let extra_bytes_used =
                storage.storage_tracker.bytes_added - storage.storage_tracker.bytes_released;
            storage.used_bytes += extra_bytes_used;
            storage.assert_storage_covered();
        } else {
            let bytes_released =
                storage.storage_tracker.bytes_released - storage.storage_tracker.bytes_added;
            assert!(
                storage.used_bytes >= bytes_released,
                "Internal storage accounting bug"
            );
            storage.used_bytes -= bytes_released;
        }
        storage.storage_tracker.bytes_released = 0;
        storage.storage_tracker.bytes_added = 0;
        self.storage.insert(account_id, &storage.into());
    }

    pub fn internal_storage_balance_of(&self, account_id: &AccountId) -> Option<StorageBalance> {
        self.internal_get_storage(account_id)
            .map(|storage| StorageBalance {
                total: storage.storage_balance.into(),
                available: U128(
                    storage.storage_balance
                        - std::cmp::max(
                            Balance::from(storage.used_bytes) * env::storage_byte_cost(),
                            self.storage_balance_bounds().min.0,
                        ),
                ),
            })
    }
}

#[near_bindgen]
impl StorageManagement for Contract {
    #[payable]
    fn storage_deposit(
        &mut self,
        account_id: Option<AccountId>,
        registration_only: Option<bool>,
    ) -> StorageBalance {
        let amount: Balance = env::attached_deposit();
        let account_id = account_id
            .map(|a| a.into())
            .unwrap_or_else(|| env::predecessor_account_id());
        let storage = self.internal_get_storage(&account_id);
        let registration_only = registration_only.unwrap_or(false);
        if let Some(mut storage) = storage {
            if registration_only && amount > 0 {
                Promise::new(env::predecessor_account_id()).transfer(amount);
            } else {
                storage.storage_balance += amount;
                self.internal_set_storage(&account_id, storage);
            }
        } else {
            let min_balance = self.storage_balance_bounds().min.0;
            if amount < min_balance {
                env::panic_str("The attached deposit is less than the mimimum storage balance");
            }

            let mut storage = Storage::new();
            if registration_only {
                let refund = amount - min_balance;
                if refund > 0 {
                    Promise::new(env::predecessor_account_id()).transfer(refund);
                }
                storage.storage_balance = min_balance;
            } else {
                storage.storage_balance = amount;
            }

            let mut account = Account::new(&account_id);
            account.storage_tracker.start();
            self.internal_set_storage(&account_id, storage);
            account.storage_tracker.stop();
            self.internal_set_account(&account_id, account);
        }
        self.internal_storage_balance_of(&account_id).unwrap()
    }

    #[payable]
    fn storage_withdraw(&mut self, amount: Option<U128>) -> StorageBalance {
        assert_one_yocto();
        let account_id = env::predecessor_account_id();
        if let Some(storage_balance) = self.internal_storage_balance_of(&account_id) {
            let amount = amount.unwrap_or(storage_balance.available).0;
            if amount > storage_balance.available.0 {
                env::panic_str("The amount is greater than the available storage balance");
            }
            if amount > 0 {
                let mut storage = self.internal_unwrap_storage(&account_id);
                storage.storage_balance -= amount;
                self.internal_set_storage(&account_id, storage);
                Promise::new(account_id.clone()).transfer(amount);
            }
            self.internal_storage_balance_of(&account_id).unwrap()
        } else {
            env::panic_str(&format!("The account {} is not registered", &account_id));
        }
    }

    #[allow(unused_variables)]
    #[payable]
    fn storage_unregister(&mut self, force: Option<bool>) -> bool {
        env::panic_str("The account can't be unregistered");
    }

    fn storage_balance_bounds(&self) -> StorageBalanceBounds {
        StorageBalanceBounds {
            min: U128(MIN_STORAGE_BALANCE),
            max: None,
        }
    }

    fn storage_balance_of(&self, account_id: AccountId) -> Option<StorageBalance> {
        self.internal_storage_balance_of(&account_id)
    }
}

'''
'''--- contract/src/storage_tracker.rs ---
use crate::*;
use near_sdk::StorageUsage;

/// A helper object that tracks changes in state storage.
#[derive(Default)]
pub struct StorageTracker {
    pub bytes_added: StorageUsage,
    pub bytes_released: StorageUsage,
    pub initial_storage_usage: Option<StorageUsage>,
}

/// Safety guard for the storage tracker.
impl Drop for StorageTracker {
    fn drop(&mut self) {
        assert!(self.is_empty(), "Bug, non-tracked storage change");
    }
}

impl StorageTracker {
    /// Starts tracking the state storage changes.
    pub fn start(&mut self) {
        assert!(
            self.initial_storage_usage
                .replace(env::storage_usage())
                .is_none(),
            "The storage tracker is already tracking"
        );
    }

    /// Stop tracking the state storage changes and record changes in bytes.
    pub fn stop(&mut self) {
        let initial_storage_usage = self
            .initial_storage_usage
            .take()
            .expect("The storage tracker wasn't tracking");
        let storage_usage = env::storage_usage();
        if storage_usage >= initial_storage_usage {
            self.bytes_added += storage_usage - initial_storage_usage;
        } else {
            self.bytes_released += initial_storage_usage - storage_usage;
        }
    }

    /// Consumes the other storage tracker changes.
    pub fn consume(&mut self, other: &mut StorageTracker) {
        self.bytes_added += other.bytes_added;
        other.bytes_added = 0;
        self.bytes_released = other.bytes_released;
        other.bytes_released = 0;
        assert!(
            other.initial_storage_usage.is_none(),
            "Can't merge storage tracker that is tracking storage"
        );
    }

    /// Returns true if no bytes is added or released, and the tracker is not active.
    pub fn is_empty(&self) -> bool {
        self.bytes_added == 0 && self.bytes_released == 0 && self.initial_storage_usage.is_none()
    }
}

'''
'''--- contract/src/utils.rs ---
use crate::*;

// pub(crate) fn to_sec(timestamp: Timestamp) -> TimestampSec {
//     (timestamp / 10u64.pow(9)) as u32
// }

'''
'''--- scripts/0_deploy.sh ---
#!/bin/bash
export MAIN_ACCOUNT=nearlog.testnet
export NEAR_ENV=testnet
export CONTRACT_ID=main.$MAIN_ACCOUNT
export WETH_TOKEN_ID=weth.fakes.testnet
export WNEAR_TOKEN_ID=wrap.testnet
export ONE_YOCTO=0.000000000000000000000001
export GAS=200000000000000
export DECIMAL_18=000000000000000000
export DECIMAL_24=00000000000000000000000

# screen drum diamond addict lift element silk hammer lemon shoulder luggage rapid

echo "################### CREATE ACCOUNT ###################"

near create-account $CONTRACT_ID --masterAccount $MAIN_ACCOUNT --initialBalance 10

echo "################### CREATE CONTRACT ###################"
near deploy $CONTRACT_ID --accountId $MAIN_ACCOUNT --wasmFile ../res/nearlog_protocol.wasm

######################### B2: Init Nearland contract #########################

echo "################### INIT CONTRACT ###################"
near call $CONTRACT_ID --accountId=$CONTRACT_ID new '{
  "config" : {
    "owner_id": "'$MAIN_ACCOUNT'"
  }
}'

######################### B3: Deposit storage #########################

# Deposit CONTRACT_ID 
near call $CONTRACT_ID --accountId=$MAIN_ACCOUNT storage_deposit '' --amount=0.1

# Deposit WETH_TOKEN_ID
near call $WETH_TOKEN_ID --accountId=$CONTRACT_ID storage_deposit '' --amount=0.1
near call $WETH_TOKEN_ID --accountId=$MAIN_ACCOUNT storage_deposit '' --amount=0.1

# Deposit WNEAR_TOKEN_ID
near call $WNEAR_TOKEN_ID --accountId=$CONTRACT_ID storage_deposit '' --amount=0.1
near call $WNEAR_TOKEN_ID --accountId=$MAIN_ACCOUNT storage_deposit '' --amount=0.1

# Mint WETH_TOKEN_ID
near call $WETH_TOKEN_ID --accountId=$MAIN_ACCOUNT mint '{
 "account_id": "'$MAIN_ACCOUNT'",
 "amount": "100'$DECIMAL_18'"
}'

###################### B4: Add asset #####################

near call $CONTRACT_ID --accountId=$MAIN_ACCOUNT add_asset '{
  "token_id": "'$WETH_TOKEN_ID'",
  "asset_config": {
    "reserve_ratio": 2500,
    "max_utilization_rate": 8000,
    "collateralization_ratio": 5000,
    "extra_decimals": 0,
    "can_deposit": true,
    "can_withdraw": true
  }
}' --amount=$ONE_YOCTO --gas=$GAS
'''
'''--- scripts/1_deposit.sh ---
#!/bin/bash
export MAIN_ACCOUNT=nearlog.testnet
export NEAR_ENV=testnet
export CONTRACT_ID=main.$MAIN_ACCOUNT
export WETH_TOKEN_ID=weth.fakes.testnet
export WNEAR_TOKEN_ID=wrap.testnet
export ONE_YOCTO=0.000000000000000000000001
export GAS=200000000000000
export DECIMAL_18=000000000000000000
export DECIMAL_24=00000000000000000000000

# screen drum diamond addict lift element silk hammer lemon shoulder luggage rapid

echo "################### CREATE ACCOUNT ###################"

near create-account $CONTRACT_ID --masterAccount $MAIN_ACCOUNT --initialBalance 10

# near delete $CONTRACT_ID $MAIN_ACCOUNT

echo "################### CREATE CONTRACT ###################"
near deploy $CONTRACT_ID --accountId $MAIN_ACCOUNT --wasmFile ../res/nearlog_protocol.wasm

######################### B2: Init Nearland contract #########################

echo "################### INIT CONTRACT ###################"
near call $CONTRACT_ID --accountId=$CONTRACT_ID new '{
  "config" : {
    "owner_id": "'$MAIN_ACCOUNT'"
  }
}'

######################### B3: Deposit storage #########################

# Deposit CONTRACT_ID 
near call $CONTRACT_ID --accountId=$MAIN_ACCOUNT storage_deposit '' --amount=0.1

# Deposit WETH_TOKEN_ID
near call $WETH_TOKEN_ID --accountId=$CONTRACT_ID storage_deposit '' --amount=0.1

# Deposit WNEAR_TOKEN_ID
near call $WNEAR_TOKEN_ID --accountId=$CONTRACT_ID storage_deposit '' --amount=0.1

###################### Deposit Token #####################

near call $WETH_TOKEN_ID --accountId=$MAIN_ACCOUNT ft_transfer_call '{
  "receiver_id": "'$CONTRACT_ID'",
  "amount": "10'$DECIMAL_18'",
  "msg": "Test deposit"
}' --amount=$ONE_YOCTO --gas=$GAS

near view $CONTRACT_ID get_asset '{"token_id": "'$WETH_TOKEN_ID'"}'
near view $CONTRACT_ID get_account '{"account_id": "'$MAIN_ACCOUNT'"}'
'''
'''--- tests/basic.rs ---
#[test]
fn test_init_env() {}

'''