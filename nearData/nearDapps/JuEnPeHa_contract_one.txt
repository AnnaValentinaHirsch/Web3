*GitHub Repository "JuEnPeHa/contract_one"*

'''--- Cargo.toml ---
[package]
name = "contract_one"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = "=4.0.0-pre.9"

[profile.release]
codegen-units=1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- neardev/dev-account.env ---
CONTRACT_NAME=dev-1655940999299-81537173993351
'''
'''--- src/external.rs ---
use std::result;

use crate::*;
use near_sdk::{is_promise_success, promise_result_as_success, require, env::log_str};

#[ext_contract(ext_self)]
pub trait ExtSelf {
    fn after_sell_confirm(
        &mut self,
        merchant_id: AccountId,
        amount: u128,
    ) -> Promise;
    //fn add_amount_to_balance(&mut self, merchant_id: AccountId, amount: u128);

}

#[near_bindgen]
impl Contract {
    pub fn after_sell_confirm(
        &mut self,
        merchant_id: AccountId,
        amount: u128,
    ) /*-> Promise<void>*/ {
        require!(env::predecessor_account_id() == AccountId::new_unchecked("usdc.fakes.testnet".to_string()), "Only after transfer can confirm sell");
        let transfer_succeeded = is_promise_success();
            let balance: u128 = self.balance_per_account.get(&merchant_id).unwrap_or(0u128);
            let new_balance: u128 = balance - amount;
            self.balance_per_account.insert(&merchant_id, &new_balance);
            env::log_str(format!("The funds has been transferred: {}", transfer_succeeded).as_str());
        }
    
    pub fn add_amount_to_balance(&mut self,
        merchant_id: AccountId,
        amount: u128) {
            log_str("add_amount_to_balance");
            log_str(format!("{}", merchant_id).as_str());
            log_str(format!("{}", amount).as_str());
            log_str(format!("{}", env::current_account_id()).as_str());
            log_str(format!("{}", env::predecessor_account_id()).as_str());
            log_str(format!("{}", env::signer_account_id()).as_str());
let balance: u128 = self.balance_per_account.get(&merchant_id).unwrap_or(0u128);
let new_balance: u128 = balance + amount;
self.balance_per_account.insert(&merchant_id, &new_balance);
}
}

'''
'''--- src/internal.rs ---
use crate::*;

//Evitamos colisión de la data generando un prefijo para cada colección de storage
//Avoiding data collisition generate a prefix for the storage collections
pub(crate) fn hash_account_id(account_id: &AccountId) -> CryptoHash {
    let mut hash = CryptoHash::default();
    hash.copy_from_slice(&env::sha256(account_id.as_bytes()));
    hash
}
'''
'''--- src/lib.rs ---
use external::ext_self;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{UnorderedSet, UnorderedMap, LookupMap, Vector};
use near_sdk::json_types::U128;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{
    assert_one_yocto, env, ext_contract, near_bindgen, promise_result_as_success, AccountId,
    Balance, BorshStorageKey, CryptoHash, Gas, PanicOnDefault, Promise, require,
};

use crate::internal::*;
mod internal;
mod sell;
mod view;
mod external;

pub type TicketID = String;
const GAS_FOR_BASIC_CROSS_CONTRACT_CALL: Gas = Gas(5_000_000_000_000);

const CONTRACT_INIT_BALANCE: u128 = 1_245_949_999_000_000_000_000_000; //1000
static TICKET_PREFIX: &str = "ticket_";
static VALID_BLOCKS: u64 = 1_200_000;

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, BorshDeserialize, BorshSerialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Ticket {
    pub merchant_id: AccountId,
    pub buyer_id: AccountId,
    pub amount: u128,
    pub height: u64,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, BorshDeserialize, BorshSerialize)]
#[serde(crate = "near_sdk::serde")]
pub struct SellingProcess {
    pub merchant_id: AccountId,
    pub buyer_id: AccountId,
    pub mediator_id: AccountId,
    pub accepted_merchant_id: bool,
    pub accepted_buyer_id: bool,
    pub accepted_mediator_id: bool,
    pub amount: u128,
    pub height: u64,
    pub last_height: u64,
    pub votes_yes: u8,
    pub passed: bool,
    pub rejected: bool,
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    //La cuenta en la qué se desplegó el contrato.
    pub contract_account_id: AccountId,
    pub mediator_id: AccountId,
    //Mantenemos aquí si es usuario pagó para mantener el contrato o no.
    pub keep_account_open: UnorderedMap<AccountId, bool>,
    //Mantenemos el último contrato desplegado del usuario ya sea permanente o no.
    pub children_account_id: UnorderedMap<AccountId, U128>,
    //Mantenemos todas las cuentas qué se han usado por los usuarios.
    pub history_account_by_merchant_id: UnorderedMap<AccountId, UnorderedSet<U128>>,
    //El siguiente id de contrato aun no utilizado.
    pub next_child_account_id: U128,
    //Mantenemos todos los balances usdc de los usuarios.
    pub balance_per_account: LookupMap<AccountId, u128>,
    //Mantenemos los tickets por su ticket id.
    pub history: UnorderedMap<TicketID, Ticket>,
    //Mantenemos los tickets id por los usuarios.
    pub selling_history: LookupMap<AccountId, UnorderedSet<TicketID>>,

    pub selling_process: UnorderedMap<TicketID, SellingProcess>,
    pub selling_in_progress: UnorderedSet<TicketID>,
    pub selling_processed: UnorderedSet<TicketID>,
    pub selling_by_merchant_id: UnorderedMap<AccountId, UnorderedSet<TicketID>>,
}

#[derive(BorshSerialize, BorshStorageKey)]
pub enum StorageKey {
    Contract,
    History,
    ByKeepAccountOpen,
    ByKeepAccountOpenInner { account_id_hash: CryptoHash },
    ByChildrenAccountIds,
    ByChildrenAccountIdsInner { account_id_hash: CryptoHash },
    ByHistoryAccountByMerchantId,
    ByHistoryAccountByMerchantIdInner { merchant_id_hash: CryptoHash },
    ByBalancePerAccount,
    ByBalancePerAccountInner { account_id_hash: CryptoHash },
    BySellingHistory,
    BySellingHistoryInner { account_id_hash: CryptoHash },
    BySellingProcess,
    BySellingProcessInner { ticket_id_hash: CryptoHash },
    BySellingInProgress,
    BySellingProcessed,
    BySellingByMerchantId,
    BySellingByMerchantIdInner { merchant_id_hash: CryptoHash },
}

#[near_bindgen]
impl Contract {

    //Inicialización del contrato.
    #[init]
    pub fn new_meta() -> Self {
        let contract_account_id = env::current_account_id();
        let this: Contract = Self {
            contract_account_id,
            mediator_id: env::signer_account_id(),
            keep_account_open: UnorderedMap::new(StorageKey::ByKeepAccountOpen),
            children_account_id: UnorderedMap::new(StorageKey::ByChildrenAccountIds),
            next_child_account_id: U128(0),
            balance_per_account: LookupMap::new(StorageKey::ByBalancePerAccount),
            history: UnorderedMap::new(StorageKey::History),
            selling_history: LookupMap::new(StorageKey::BySellingHistory),
            history_account_by_merchant_id: UnorderedMap::new(StorageKey::ByHistoryAccountByMerchantId),
            selling_process: UnorderedMap::new(StorageKey::BySellingProcess),
            selling_in_progress: UnorderedSet::new(StorageKey::BySellingInProgress),
            selling_processed: UnorderedSet::new(StorageKey::BySellingProcessed),
            selling_by_merchant_id: UnorderedMap::new(StorageKey::BySellingByMerchantId),
        };
        this
    }

    #[payable]
    pub fn question_keep_subaccount_open(&mut self, keep: bool) -> bool {
        let mut max_number: u128 = 0;
        let contract_cost: u128 = CONTRACT_INIT_BALANCE;
        let merchant_id: AccountId = env::signer_account_id();
        let by_merchant_id: UnorderedSet<U128> = self.history_account_by_merchant_id
        .get(&merchant_id).unwrap();
        by_merchant_id.as_vector();
        by_merchant_id.iter().for_each(|number| {
            let temporal_number: u128 = number.clone().0;
            if temporal_number > max_number {
                max_number = temporal_number;
            }
        });
        self.children_account_id.insert(&merchant_id, &U128(max_number));
        let account_id: AccountId = AccountId::new_unchecked(
            format!("{}.{}", max_number, self.contract_account_id)
        );
        if keep {
            require!(
                env::attached_deposit() >= contract_cost,
                "Not enough attached deposit"
            );
            self.keep_account_open.insert(&merchant_id, &keep);
        } else {
            if self.keep_account_open.get(&merchant_id).unwrap_or(false) == true {
                
            } else {
            self.keep_account_open.remove(&merchant_id);
            ext_external::delete_contract(
                account_id, 
                0, 
                GAS_FOR_BASIC_CROSS_CONTRACT_CALL,
            );
            }

        }

        return keep;
        //let contract_account_id: AccountId = 
        
        
    }

    pub fn init_sub_account(&mut self, /*merchant_id: AccountId,*/ amount: Balance /*sub_id: u128,*/ /*code_hash: Vec<u8>*/) /*-> Promise*/ {
        let merchant_id = env::signer_account_id();
        if self.children_account_id.get(&merchant_id).is_none() {
            let sub_id = self.next_child_account_id;
            let sub_account_id: AccountId = AccountId::new_unchecked(
                format!("{}.{}", sub_id.0.to_string().clone(), env::current_account_id())
            );
            self.next_child_account_id.0 += 1;
            Promise::new(sub_account_id.clone())
            .create_account()
            .transfer(CONTRACT_INIT_BALANCE)
            .deploy_contract(
                include_bytes!("../../contract_two/target/wasm32-unknown-unknown/release/contract_two.wasm").to_vec(),
            ).then(
                ext_external::new(
                    merchant_id.clone(), 
                    amount,
                    sub_account_id.clone(), 
                    0, 
                    Gas(5_000_000_000_000),
                )
            );
    
            let mut history_account_by_merchant_id: UnorderedSet<U128> =
            self.history_account_by_merchant_id.get(&merchant_id).unwrap_or_else(|| {
                UnorderedSet::new(
                    StorageKey::ByChildrenAccountIdsInner { 
                        account_id_hash: hash_account_id(&merchant_id),
                    }
                    .try_to_vec().unwrap(),
                )
            });
            history_account_by_merchant_id.insert(&sub_id);
            self.history_account_by_merchant_id.insert(&merchant_id, &history_account_by_merchant_id);
            self.children_account_id.insert(&merchant_id, &sub_id);
        } else if self.keep_account_open.get(&merchant_id).unwrap_or(false) == true {
            let sub_id: U128 = self.children_account_id.get(&merchant_id).unwrap();
            let sub_account_id: AccountId = AccountId::new_unchecked(
                format!("{}.{}", sub_id.0.to_string().clone(), env::current_account_id())
            );
                ext_external::update_new(
                    amount,
                    sub_account_id.clone(), 
                    0, 
                    Gas(5_000_000_000_000),
            );
        } else {
            let sub_id: U128 = self.next_child_account_id;
            let sub_account_id: AccountId = AccountId::new_unchecked(
                format!("{}.{}", sub_id.0.to_string().clone(), env::current_account_id())
            );
            self.next_child_account_id.0 += 1;
            Promise::new(sub_account_id.clone())
            .create_account()
            .transfer(CONTRACT_INIT_BALANCE)
            .deploy_contract(
                include_bytes!("../../contract_two/target/wasm32-unknown-unknown/release/contract_two.wasm").to_vec(),
            ).then(
                ext_external::new(
                    merchant_id.clone(), 
                    amount,
                    sub_account_id.clone(), 
                    0, 
                    Gas(5_000_000_000_000),
                )
            );

            let mut history_account_by_merchant_id: UnorderedSet<U128> =
            self.history_account_by_merchant_id.get(&merchant_id).unwrap_or_else(|| {
                UnorderedSet::new(
                    StorageKey::ByChildrenAccountIdsInner { 
                        account_id_hash: hash_account_id(&merchant_id),
                    }
                    .try_to_vec().unwrap(),
                )
            });
            history_account_by_merchant_id.insert(&sub_id);
            self.history_account_by_merchant_id.insert(&merchant_id, &history_account_by_merchant_id);
            self.children_account_id.insert(&merchant_id, &sub_id);
        }

        //true
    }

    pub fn add_balance_to_merchant(&mut self, merchant_id: AccountId, sub_id: AccountId, amount: u128) {
        env::log_str("add_balance_to_merchant");
        env::log_str("autodestruction");
        env::log_str(format!("signer: {}", env::signer_account_id()).as_str());
        env::log_str(format!("predecessor: {}", env::predecessor_account_id()).as_str());
        // env::log_str(format!("owner: {}", self.owner_id).as_str());
        // env::log_str(format!("user: {}", self.user_id).as_str());
        env::log_str(format!("merchant: {}", merchant_id).as_str());
        env::log_str(format!("amount: {}", amount).as_str());
        env::log_str(format!("promise_result_as_success: {:?}", promise_result_as_success()).as_str());
        env::log_str(format!("attached_gas: {:?}", env::prepaid_gas()).as_str());
        env::log_str(format!("used_gas: {:?}", env::used_gas()).as_str());
        env::log_str(format!("result: {:?}", env::promise_result(0)).as_str());
        require!(promise_result_as_success() != None, "No se pudo transferir el dinero, no hay suficiente");

        let mut balance_per_account: u128 = self.balance_per_account.get(&merchant_id)
        .unwrap_or(0u128);
        balance_per_account += amount;
        //balance_per_account -= CONTRACT_INIT_BALANCE;
        self.balance_per_account.insert(&merchant_id, &balance_per_account);
    }

}

#[ext_contract(ext_external)]
pub trait ExtExternal {
    fn new(user_id: AccountId, required_amount: Balance);
    fn update_new(new_required_amount: Balance);
    fn ft_transfer(&self, receiver_id: String, amount: String, memo: String);
    fn delete_contract(&mut self);
}

'''
'''--- src/sell.rs ---
use near_sdk::{require};

use crate::{*, external::ext_self};

pub (crate) fn new_ticket_id(merchant_id: &AccountId, index: String) -> TicketID {
    let mut ticket_id: String = TICKET_PREFIX.to_string();
    ticket_id.push_str(&merchant_id.to_string());
    ticket_id.push_str(&env::current_account_id().to_string());
    ticket_id.push_str(&env::predecessor_account_id().to_string());
    ticket_id.push_str(&index);
    ticket_id
}

pub(crate) fn hash_account_id(account_id: &AccountId) -> CryptoHash {
    let mut hash = CryptoHash::default();
    hash.copy_from_slice(&env::sha256(account_id.as_bytes()));
    hash
}

trait SellingFunctions {
    fn confirm_sell_by_merchant(&mut self, ticket_id: TicketID);
    fn start_buy(&mut self, merchant_id: AccountId, amount: u128);
    fn confirm_by_mediator(&mut self, ticket_id: TicketID);
    fn cancel_sell(&mut self);
}

#[near_bindgen]
impl SellingFunctions for Contract{
     fn confirm_sell_by_merchant(&mut self,
        ticket_id: TicketID) {
            let mut selling_process: SellingProcess = self.selling_process.get(&ticket_id).unwrap_or_else(|| {
                env::panic_str("Selling process not found")
            });
            let merchant_id: AccountId = selling_process.merchant_id.clone();
            let amount: u128 = selling_process.amount.clone();
            let buyer_id: AccountId = selling_process.buyer_id.clone();
            require!(amount <= self.balance_per_account.get(&merchant_id).unwrap_or(0u128), "Not enough balance");
            selling_process.accepted_merchant_id = true;
            selling_process.votes_yes += 1;
            if selling_process.votes_yes >= 2 {
                selling_process.passed = true;
            }
        require!(env::signer_account_id() == merchant_id, "Only merchant can confirm sell");
        self.selling_process.insert(&ticket_id, &selling_process);
        self.selling_in_progress.remove(&ticket_id);
        self.selling_processed.insert(&ticket_id);
        ext_external::ft_transfer(
            buyer_id.to_string(), 
            amount.to_string(), 
            "".to_string(), 
            AccountId::new_unchecked("usdc.fakes.testnet".to_string()), 
            1,
            GAS_FOR_BASIC_CROSS_CONTRACT_CALL, 
        ).then(
        ext_self::after_sell_confirm(
            merchant_id, 
            amount, 
            env::current_account_id(), 
            1, 
            GAS_FOR_BASIC_CROSS_CONTRACT_CALL
        )
        );
        }

        fn start_buy(&mut self, merchant_id: AccountId, amount: u128) {
            require!(amount <= self.balance_per_account.get(&merchant_id).unwrap_or(0u128), "Not enough balance");
            let index: u64 = self.selling_process.len();
            let ticket_id: TicketID = new_ticket_id(&merchant_id, index.to_string());
            let new_selling_process: SellingProcess = SellingProcess {
                merchant_id: merchant_id.clone(),
                buyer_id: env::signer_account_id(),
                mediator_id: self.mediator_id.clone(),
                accepted_merchant_id: false,
                accepted_buyer_id: true,
                accepted_mediator_id: false,
                amount,
                height: env::block_height(),
                last_height: env::block_height() + VALID_BLOCKS,
                votes_yes: 1u8,
                passed: false,
                rejected: false,
            };
            self.selling_process.insert(&ticket_id, &new_selling_process);
            self.selling_in_progress.insert(&ticket_id);

            let mut by_merchant_id = self.selling_by_merchant_id
            .get(&merchant_id).unwrap_or_else(|| {
                UnorderedSet::new(
                    StorageKey::BySellingByMerchantIdInner { merchant_id_hash: hash_account_id(&merchant_id) }
                    .try_to_vec().unwrap()
                )
            });
            by_merchant_id.insert(&ticket_id);
            self.selling_by_merchant_id.insert(&merchant_id, &by_merchant_id);

        }
        fn confirm_by_mediator(&mut self, ticket_id: TicketID) {
            require!(env::signer_account_id() == self.mediator_id, "Only mediator can confirm by mediator");
            require!(env::predecessor_account_id() == AccountId::new_unchecked("p2p.near".to_string()), "Only p2p can confirm by mediator");
            let mut selling_process: SellingProcess = self.selling_process.get(&ticket_id).unwrap_or_else(|| {
                env::panic_str("Selling process not found")
            });
            require!(selling_process.mediator_id == self.mediator_id, "Only mediator can confirm by mediator");
            selling_process.accepted_mediator_id = true;
            selling_process.votes_yes += 1;
            if selling_process.votes_yes >= 2 {
                selling_process.passed = true;
            }
            let amount: u128 = selling_process.amount.clone();
            let buyer_id: AccountId = selling_process.buyer_id.clone();
            let merchant_id: AccountId = selling_process.merchant_id.clone();
            require!(amount <= self.balance_per_account.get(&merchant_id).unwrap_or(0u128), "Not enough balance");
            self.selling_process.insert(&ticket_id, &selling_process);
            self.selling_in_progress.remove(&ticket_id);
            self.selling_processed.insert(&ticket_id);
            ext_external::ft_transfer(
                buyer_id.to_string(), 
                selling_process.amount.to_string(), 
                "".to_string(), 
                AccountId::new_unchecked("usdc.fakes.testnet".to_string()), 
                1,
                GAS_FOR_BASIC_CROSS_CONTRACT_CALL, 
            ).then(
                ext_self::after_sell_confirm(
                    merchant_id, 
                    amount, 
                    env::current_account_id(), 
                    0, 
                    GAS_FOR_BASIC_CROSS_CONTRACT_CALL
                )
            );
        }

        fn cancel_sell(&mut self) {
            let balance = self.balance_per_account.get(&env::signer_account_id()).unwrap_or(0u128);
            require!(balance >= 0, "Not enough balance");
            ext_external::ft_transfer(
                env::signer_account_id().to_string(), 
                balance.to_string(), 
                "".to_string(), 
                AccountId::new_unchecked("usdc.fakes.testnet".to_string()), 
                1, 
                GAS_FOR_BASIC_CROSS_CONTRACT_CALL,
            ).then(
                ext_self::after_sell_confirm(
                    env::signer_account_id(), 
                    balance, 
                    env::current_account_id(), 
                    0, 
                    GAS_FOR_BASIC_CROSS_CONTRACT_CALL
                )
            );
        }
}

'''
'''--- src/view.rs ---
use crate::*;

trait ViewFunctions {
    fn erase_all_subaccounts(&mut self);
    fn view_balance(&self, merchant_id: AccountId) -> Balance;
    fn view_selling_history_by_merchant_id(&self, merchant_id: AccountId, from_index: Option<U128>, limit: Option<u64>) -> Vec<Ticket>;
    fn get_merchant_subaccount_ids(&self, merchant_id: AccountId) -> Vec<AccountId>;
    fn view_balances(&self, merchants_id: Vec<AccountId>) -> Vec<(AccountId, Balance)>;
}

#[near_bindgen]
impl ViewFunctions for Contract {
    fn erase_all_subaccounts(&mut self) {
        let id_numbers = 0u128..self.next_child_account_id.0;
        for id_number in id_numbers {
            let id: AccountId = AccountId::new_unchecked(
                format!("{}.{}", id_number.to_string().clone(), env::current_account_id())
            );
            //Promise::new(id).delete_account(AccountId::new_unchecked("contract_one.jeph.testnet".to_string()));
            //env::promise_batch_create(&id);
            //env::promise_batch_then(id_number.try_into().unwrap(), &id);
            ext_external::delete_contract(
                id, 
                0, 
                Gas(7_500_000_000_000)
            );
        }
    }

    fn view_balance(&self, merchant_id: AccountId) -> Balance {
        self.balance_per_account.get(&merchant_id).unwrap_or(0u128)
    }

    fn view_balances(&self, merchants_id: Vec<AccountId>) -> Vec<(AccountId, Balance)> {
        let mut balances = Vec::new();
        for merchant_id in merchants_id {
            self.balance_per_account.get(&merchant_id).map(|balance| {
                let temporal_balance: u128 = balance.clone();
                balances.push((merchant_id, temporal_balance));
            });
        }
        balances
    }

    fn view_selling_history_by_merchant_id(&self, merchant_id: AccountId, from_index: Option<U128>, limit: Option<u64>) -> Vec<Ticket> {
        let by_merchant_id: Option<UnorderedSet<TicketID>> = self.selling_history.get(&merchant_id);
        //.unwrap_or(vec![])
        let history = if let Some(by_merchant_id) = by_merchant_id {
            by_merchant_id
        } else {
            return vec![];
        };
        let keys = history.as_vector();
        let start: u128 = u128::from(from_index.unwrap_or(U128(0u128)));
        keys.iter().skip(start as usize).take(limit.unwrap_or(0) as usize)
        .map(|ticket: TicketID| self.history.get(&ticket).unwrap())
        .collect()
    }

    fn get_merchant_subaccount_ids(&self, merchant_id: AccountId) -> Vec<AccountId> {
        let by_merchant_id: UnorderedSet<U128> = self.history_account_by_merchant_id.get(&merchant_id).unwrap();
        by_merchant_id.as_vector();

        let mut accounts: Vec<AccountId> = vec![];
        by_merchant_id.iter().for_each(|sub_id| {
            let sub_account_id: AccountId = AccountId::new_unchecked(
                format!("{}.{}", sub_id.0.to_string().clone(), env::current_account_id())
            );
            accounts.push(sub_account_id);
        });
        accounts
    }
}
'''