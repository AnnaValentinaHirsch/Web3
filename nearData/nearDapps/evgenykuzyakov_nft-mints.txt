*GitHub Repository "evgenykuzyakov/nft-mints"*

'''--- package.json ---
{
  "name": "nft-events",
  "version": "0.1.1",
  "private": true,
  "dependencies": {
    "@testing-library/jest-dom": "^5.14.1",
    "@testing-library/react": "^12.0.0",
    "@testing-library/user-event": "^13.2.1",
    "big.js": "^6.1.1",
    "near-api-js": "^0.44.2",
    "react": "^17.0.2",
    "react-dom": "^17.0.2",
    "react-scripts": "^4.0.0",
    "react-singleton-hook": "^3.2.3",
    "web-vitals": "^2.1.0"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  },
  "devDependencies": {
    "prettier": "^2.2.1"
  }
}

'''
'''--- public/index.html ---
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Live NFT feed in realtime on NEAR blockchain"
    />
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
    <title>Live NFT feed (NEAR)</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
  </body>
</html>

'''
'''--- public/manifest.json ---
{
  "short_name": "NFT Mints",
  "name": "NFT Mints in realtime",
  "icons": [
    {
      "src": "favicon.png",
      "type": "image/png",
      "sizes": "256x256"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#ffffff",
  "background_color": "#0D192B"
}

'''
'''--- public/robots.txt ---
# https://www.robotstxt.org/robotstxt.html
User-agent: *
Disallow:

'''
'''--- src/App.css ---
:root {
  --oxford-blue:        hsl(217, 54%, 11%);
  --light-oxford-blue:  hsl(216, 50%, 16%);
  --lighter-oxford-blue:hsl(216, 50%, 25%);
  --indigo-dye:         hsl(215, 32%, 27%);
  --blue-yonder:        hsl(216, 30%, 55%);
  --aqua:               hsl(178, 100%, 50%);
  --white:              hsl(0, 0%, 100%);
  --light-gray:         hsl(0, 0%, 90%);
  --dark-gray:          hsl(0, 0%, 50%);
}

h1 {
  text-align: center;
  color: var(--white);
}

* {
  margin:  0;
  padding: 0;
  box-sizing: border-box;
}

html { font-family: "Outfit", sans-serif; }

a { text-decoration: none; }

body {
  background: var(--oxford-blue);
  min-height: 100vh;
  padding: 25px;
}

.card-wrapper {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
}

.card {
  background: var(--light-oxford-blue);
  max-width: 350px;
  padding: 24px;
  border-radius: 15px;
  box-shadow: 0 20px 25px 15px rgba(0, 0, 0, 0.05),
  0 40px 30px 15px rgba(0, 0, 0, 0.1);
  margin: 10px;
  transition: .5s;
  position: relative;
}

.card.mint {
  background: var(--lighter-oxford-blue);
}

.card.mint::before {
  content: "NEW MINT";
  position: absolute;
  left: 0;
  top: 2px;
  text-align: center;
  color: var(--light-gray);
  display: block;
  font-weight: 800;
  width: 100%;
}

.card.transfer::before {
  content: "TRANSFER";
  position: absolute;
  left: 0;
  top: 2px;
  text-align: center;
  color: var(--dark-gray);
  display: block;
  font-weight: 800;
  width: 100%;
}

.card__product-img {
  position: relative;
  border-radius: 8px;
  overflow: hidden;
  cursor: pointer;
}

.card__product-img::after {
  --aqua: hsla(178, 100%, 50%, 0.5);
  position: absolute;
  inset: 0;
  display:         flex;
  justify-content: center;
  align-items:     center;
  opacity: 0;
  transition: all 0.25s ease;
}

.card__product-img:hover::after { opacity: 1; }

.card__product-img {
  display: block;
}

.card__product-img.loading {
  min-width: 302px;
  background: var(--light-oxford-blue);
  background: linear-gradient(110deg, var(--oxford-blue) 8%, var(--light-oxford-blue) 18%, var(--oxford-blue) 33%);
  border-radius: 5px;
  background-size: 200% 100%;
  animation: 1.5s shine linear infinite;
  min-height: 302px;
}

@keyframes shine {
  to {
    background-position-x: -200%;
  }
}

.card__product-img img {
  width: 100%;
  color: var(--blue-yonder);
  display: block;
  min-width: 100px;
  min-height: 100px;
}

.card__body {
  padding: 23px 0;
}

.card__title {
  color: var(--white);
  font-size: 22px;
  font-weight: 500;
  margin-bottom: 15px;
}

.card__title:hover { color: var(--aqua); }

.card__text {
  color: var(--blue-yonder);
  font-size: 18px;
  line-height: 1.5;
  margin-bottom: 23px;
  border-bottom: 1px solid var(--indigo-dye);
  padding-bottom: 5px;
}

.card__body .wrapper {
  display:         flex;
  justify-content: space-between;
  align-items:     center;
  flex-wrap: wrap;
}

.card__owner,
.card__contract {
  display:     flex;
  align-items: center;
  font-weight: 500;
}

.card__owner a { color: var(--aqua); }
.card__owner a:hover { color: var(--white); }

.card__contract a { color: var(--blue-yonder); }
.card__contract a:hover { color: var(--white); }

.card__author-name a {
  color: var(--white);
  font-weight: 400;
}

.card__author-name a:hover { color: var(--aqua); }

.card__footer {
  display:         flex;
  justify-content: space-around;
  align-items:     center;
  flex-wrap: wrap;
}

.card__footer a {
    color: var(--blue-yonder);
    font-weight: 400;
  }
.card__footer a:hover { color: var(--white); }

'''
'''--- src/App.js ---
import "./App.css";
import { useEffect, useState } from "react";
import NftToken from "./NftToken";

let globalIndex = 0;

const nftFilter = [{
  status: "SUCCESS",
  event: {
    standard: "nep171",
    event: "nft_mint",
  }
}, {
  status: "SUCCESS",
  event: {
    standard: "nep171",
    event: "nft_transfer",
  }
}];

let reconnectTimeout = null;

function listenToNFT(processEvents) {
  const scheduleReconnect = (timeOut) => {
    if (reconnectTimeout) {
      clearTimeout(reconnectTimeout);
      reconnectTimeout = null;
    }
    reconnectTimeout = setTimeout(() => {
      listenToNFT(processEvents);
    }, timeOut);
  };

  if (document.hidden) {
    scheduleReconnect(1000);
    return;
  }

  const ws = new WebSocket("wss://events.near.stream/ws");
  // const ws = new WebSocket("ws://localhost:3006/ws");

  ws.onopen = () => {
    console.log(`Connection to WS has been established`);
    ws.send(
      JSON.stringify({
        secret: "ohyeahnftsss",
        filter: nftFilter,
        fetch_past_events: 20,
      })
    );
  };
  ws.onclose = () => {
    console.log(`WS Connection has been closed`);
    scheduleReconnect(1);
  };
  ws.onmessage = (e) => {
    const data = JSON.parse(e.data);
    processEvents(data.events);
  };
  ws.onerror = (err) => {
    console.log("WebSocket error", err);
  };
}

// async function fetchEvents() {
//   const res = await fetch("https://events.near.stream/events", {
//     method: "POST",
//     headers: { "Content-Type": "application/json" },
//     body: JSON.stringify({
//       filter: nftFilter,
//       limit: 10,
//     }),
//   });
//   try {
//     const response = await res.json();
//     return response.events;
//   } catch (e) {
//     console.log(e);
//     return [];
//   }
// }

function processEvent(event) {
  const data = event?.event?.data?.[0];
  return (data?.token_ids || []).map((tokenId) => ({
    time: new Date(event?.blockTimestampMs),
    contractId: event?.accountId,
    ownerId: data?.owner_id,
    tokenId,
    isTransfer: event?.event?.event === "nft_transfer",
    index: globalIndex++,
  }));
}

function App() {
  const [nfts, setNfts] = useState([]);

  // Setting up NFTs
  useEffect(() => {
    const processEvents = (events) => {
      // console.log(events);
      events = events.flatMap(processEvent);
      events.reverse();
      setNfts((prevState) => {
        const newNfts = [
          ...events.filter(
            (event) =>
              prevState.length === 0 ||
              event.time.getTime() > prevState[0].time.getTime()
          ),
          ...prevState,
        ];
        return newNfts.slice(0, 100);
      });
    };

    // fetchEvents().then(processEvents);
    listenToNFT(processEvents);
  }, []);

  return (
    <div>
      <h1>Live NFT feed</h1>
      <div className="card-wrapper">
        {nfts.map((nft) => {
          return (
            <NftToken key={`${nft.index}`} nft={nft} />
          );
        })}
      </div>
    </div>
  );
}

export default App;

'''
'''--- src/App.test.js ---
import { render, screen } from '@testing-library/react';
import App from './App';

test('renders learn react link', () => {
  render(<App />);
  const linkElement = screen.getByText(/learn react/i);
  expect(linkElement).toBeInTheDocument();
});

'''
'''--- src/NftToken.js ---
import React, { useEffect, useState } from "react";
import { useNear } from "./data/near";
import {accountTrim, isObject, keysToCamel} from "./data/utils";

const metadataCache = {};

async function fetchNftData(near, nft) {
  try {
    const nftMetadata = await (nft.contractId in metadataCache
      ? metadataCache[nft.contractId]
      : (metadataCache[nft.contractId] = near
          .viewCall(nft.contractId, "nft_metadata", {})
          .then(keysToCamel)));

    const nftToken = keysToCamel(
      await near.viewCall(nft.contractId, "nft_token", {
        token_id: nft.tokenId,
      })
    );

    const ownerId = (isObject(nftToken.ownerId) && "Account" in nftToken.ownerId) ? nftToken.ownerId["Account"] : nftToken.ownerId;

    let tokenMetadata = nftToken?.metadata;
    let tokenMedia = tokenMetadata?.media || "";

    let imageUrl =
      tokenMedia.startsWith("https://") ||
      tokenMedia.startsWith("http://") ||
      tokenMedia.startsWith("data:image")
        ? tokenMedia
        : nftMetadata.baseUri
          ? `${nftMetadata.baseUri}/${tokenMedia}`
          : tokenMedia.startsWith("Qm")
            ? `https://cloudflare-ipfs.com/ipfs/${tokenMedia}`
            : tokenMedia;

    let mjolnearUrl = `https://mjolnear.com/nfts/${nft.contractId}/${nft.tokenId}`;
    let parasUrl = `https://paras.id/token/${nft.contractId}/${nft.tokenId}`;
    let mintbaseUrl = null;
    let parasOwnerUrl = `https://paras.id/${ownerId}/collectibles`;
    let parasCollectionUrl = `https://paras.id/collection/${nft.contractId}`;

    let ownerUrl = parasOwnerUrl;
    let storeUrl = parasCollectionUrl;
    let tokenUrl = parasUrl;

    let title = tokenMetadata?.title;
    let description = tokenMetadata.description || nftMetadata.name;

    if (!tokenMedia && tokenMetadata.reference && nftMetadata.baseUri === "https://arweave.net") {
      const res = await fetch(`${nftMetadata.baseUri}/${tokenMetadata.reference}`);
      const reference = keysToCamel(await (res.json()));
      if (reference) {
        imageUrl = reference.media;
        title = reference.title;
        description = reference.description;
        tokenUrl = `https://mintbase.io/thing/${tokenMetadata.reference}:${nft.contractId}`;
        ownerUrl = `https://mintbase.io/human/${ownerId}`;
        storeUrl = `https://mintbase.io/store/${nft.contractId}`;
        mintbaseUrl = tokenUrl;
      }
    }

    return {
      title,
      description,
      ownerId,
      contractId: nft.contractId,
      parasOwnerUrl,
      parasCollectionUrl,
      imageUrl,
      mjolnearUrl,
      parasUrl,
      mintbaseUrl,
      tokenUrl,
      ownerUrl,
      storeUrl,
      nft,
      nftToken,
      nftMetadata,
    };
  } catch (e) {
    console.error(e);
    return null;
  }
}

export default function NftToken(props) {
  const [nftData, setNftData] = useState(null);
  const [imgLoaded, setImgLoaded] = useState(false);
  const near = useNear();
  const nft = props.nft;

  useEffect(() => {
    if (near && nft) {
      fetchNftData(near, nft).then(setNftData);
    }
  }, [near, nft]);

  return nftData ? (
    <div className={`card ${nftData.nft.isTransfer ? "transfer" : "mint"}`}>
      <div className="card__head">
        <a target="_blank" rel="noreferrer" href={nftData.imageUrl}>
          <div className={`card__product-img${!imgLoaded ? " loading" : ""}`}>
            <img src={nftData.imageUrl} alt={nftData.title} onLoad={() => imgLoaded || setImgLoaded(true)}/>
          </div>
        </a>
      </div>

      <div className="card__body">
        <a target="_blank" rel="noreferrer" href={nftData.tokenUrl}>
          <h3 className="card__title">{nftData.title}</h3>
        </a>

        <p className="card__text">{nftData.description}</p>

        <div className="wrapper">
          <div className="card__owner">
            <a target="_blank" rel="noreferrer" href={nftData.ownerUrl}>
              {accountTrim(nftData.ownerId)}
            </a>
          </div>

          <div className="card__contract">
            <a
              target="_blank"
              rel="noreferrer"
              href={nftData.storeUrl}
            >
              {accountTrim(nftData.contractId)}
            </a>
          </div>
        </div>
      </div>
      <div className="card__footer">
        <a target="_blank" rel="noreferrer" href={nftData.parasUrl}>
          Paras
        </a>
        <a target="_blank" rel="noreferrer" href={nftData.mjolnearUrl}>
          MjolNear
        </a>
        {nftData.mintbaseUrl && (
        <a target="_blank" rel="noreferrer" href={nftData.mintbaseUrl}>
          Mintbase
        </a>)}
      </div>
    </div>
  ) : (
    <div>Loading</div>
  );
}

'''
'''--- src/data/account.js ---
import { singletonHook } from "react-singleton-hook";
import { useEffect, useState } from "react";
import { useNearPromise } from "./near";

const defaultAccount = {
  loading: true,
  accountId: null,
  state: null,
  near: null,
};

const loadAccount = async (near, setAccount) => {
  const accountId = near.accountId;
  const account = {
    loading: false,
    accountId,
    state: null,
    near,
    refresh: async () => await loadAccount(near, setAccount),
  };
  if (accountId) {
    account.state = await near.account.state();
  }

  setAccount(account);
};

export const useAccount = singletonHook(defaultAccount, () => {
  const [account, setAccount] = useState(defaultAccount);
  const _near = useNearPromise();

  useEffect(() => {
    _near.then(async (near) => {
      try {
        await loadAccount(near, setAccount);
      } catch (e) {
        console.error(e);
      }
    });
  }, [_near]);

  return account;
});

'''
'''--- src/data/near.js ---
import * as nearAPI from "near-api-js";
import { singletonHook } from "react-singleton-hook";
import Big from "big.js";
import { useEffect, useState } from "react";

export const TGas = Big(10).pow(12);
export const StorageCostPerByte = Big(10).pow(19);
// const isLocalhost = window.location.hostname === "localhost";

export const IsMainnet = true;
const TestNearConfig = {
  networkId: "testnet",
  nodeUrl: "https://rpc.testnet.near.org",
  archivalNodeUrl: "https://rpc.testnet.internal.near.org",
  walletUrl: "https://wallet.testnet.near.org",
  storageCostPerByte: StorageCostPerByte,
  wrapNearAccountId: "wrap.testnet",
};
export const MainNearConfig = {
  networkId: "mainnet",
  nodeUrl: "https://rpc.mainnet.near.org",
  archivalNodeUrl: "https://rpc.mainnet.internal.near.org",
  walletUrl: "https://wallet.near.org",
  storageCostPerByte: StorageCostPerByte,
  wrapNearAccountId: "wrap.near",
};

export const NearConfig = IsMainnet ? MainNearConfig : TestNearConfig;

async function _initNear() {
  const keyStore = new nearAPI.keyStores.BrowserLocalStorageKeyStore();
  keyStore.reKey = () => {};
  const nearConnection = await nearAPI.connect(
    Object.assign({ deps: { keyStore } }, NearConfig)
  );
  const _near = {};

  _near.nearArchivalConnection = nearAPI.Connection.fromConfig({
    networkId: NearConfig.networkId,
    provider: {
      type: "JsonRpcProvider",
      args: { url: NearConfig.archivalNodeUrl },
    },
    signer: { type: "InMemorySigner", keyStore },
  });

  _near.keyStore = keyStore;
  _near.nearConnection = nearConnection;

  _near.walletConnection = new nearAPI.WalletConnection(
    nearConnection,
    NearConfig.contractName
  );
  _near.accountId = _near.walletConnection.getAccountId();
  _near.account = _near.walletConnection.account();

  _near.contract = new nearAPI.Contract(
    _near.account,
    NearConfig.contractName,
    {
      viewMethods: [],
      changeMethods: [],
    }
  );

  _near.fetchBlockHash = async () => {
    const block = await nearConnection.connection.provider.block({
      finality: "final",
    });
    return nearAPI.utils.serialize.base_decode(block.header.hash);
  };

  _near.fetchBlockHeight = async () => {
    const block = await nearConnection.connection.provider.block({
      finality: "final",
    });
    return block.header.height;
  };

  _near.fetchNextNonce = async () => {
    const accessKeys = await _near.account.getAccessKeys();
    return accessKeys.reduce(
      (nonce, accessKey) => Math.max(nonce, accessKey.access_key.nonce + 1),
      1
    );
  };

  _near.archivalViewCall = async (blockId, contractId, methodName, args) => {
    args = args || {};
    const result = await _near.nearArchivalConnection.provider.query({
      request_type: "call_function",
      account_id: contractId,
      method_name: methodName,
      args_base64: Buffer.from(JSON.stringify(args)).toString("base64"),
      block_id: blockId,
    });

    return (
      result.result &&
      result.result.length > 0 &&
      JSON.parse(Buffer.from(result.result).toString())
    );
  };

  _near.viewCall = async (contractId, methodName, args) => {
    args = args || {};
    const result = await nearConnection.connection.provider.query({
      request_type: "call_function",
      account_id: contractId,
      method_name: methodName,
      args_base64: Buffer.from(JSON.stringify(args)).toString("base64"),
      finality: "optimistic",
    });

    return (
      result.result &&
      result.result.length > 0 &&
      JSON.parse(Buffer.from(result.result).toString())
    );
  };

  return _near;
}

const defaultNearPromise = Promise.resolve(_initNear());
export const useNearPromise = singletonHook(defaultNearPromise, () => {
  return defaultNearPromise;
});

const defaultNear = null;
export const useNear = singletonHook(defaultNear, () => {
  const [near, setNear] = useState(defaultNear);
  const _near = useNearPromise();

  useEffect(() => {
    _near.then(setNear);
  }, [_near]);

  return near;
});

'''
'''--- src/data/utils.js ---
import Big from "big.js";
import { NearConfig } from "./near";
import React from "react";

const MinAccountIdLen = 2;
const MaxAccountIdLen = 64;
const ValidAccountRe = /^(([a-z\d]+[-_])*[a-z\d]+\.)*([a-z\d]+[-_])*[a-z\d]+$/;
export const OneNear = Big(10).pow(24);
export const OneEth = Big(10).pow(18);
const AccountSafetyMargin = OneNear.div(2);

export const Loading = (
  <span
    className="spinner-grow spinner-grow-sm me-1"
    role="status"
    aria-hidden="true"
  />
);

export function isValidAccountId(accountId) {
  return (
    accountId &&
    accountId.length >= MinAccountIdLen &&
    accountId.length <= MaxAccountIdLen &&
    accountId.match(ValidAccountRe)
  );
}

const toCamel = (s) => {
  return s.replace(/([-_][a-z])/gi, ($1) => {
    return $1.toUpperCase().replace("-", "").replace("_", "");
  });
};

const isArray = function (a) {
  return Array.isArray(a);
};

export const isObject = function (o) {
  return o === Object(o) && !isArray(o) && typeof o !== "function";
};

export const keysToCamel = function (o) {
  if (isObject(o)) {
    const n = {};

    Object.keys(o).forEach((k) => {
      n[toCamel(k)] = keysToCamel(o[k]);
    });

    return n;
  } else if (isArray(o)) {
    return o.map((i) => {
      return keysToCamel(i);
    });
  }

  return o;
};

export const bigMin = (a, b) => {
  if (a && b) {
    return a.lt(b) ? a : b;
  }
  return a || b;
};

export const bigToString = (b, p, len) => {
  if (b === null) {
    return "???";
  }
  let s = b.toFixed();
  let pos = s.indexOf(".");
  p = p || 6;
  len = len || 7;
  if (pos > 0) {
    let ap = Math.min(p, Math.max(len - pos, 0));
    if (ap > 0) {
      ap += 1;
    }
    if (pos + ap < s.length) {
      s = s.substring(0, pos + ap);
    }
  } else {
    pos = s.length;
  }
  for (let i = pos - 4; i >= 0; i -= 3) {
    s = s.slice(0, i + 1) + "," + s.slice(i + 1);
  }

  if (s === "0.000000" && p === 6 && len === 7) {
    return "<0.000001";
  }

  return s;
};

export const displayNear = (balance) =>
  balance ? (
    <>
      {bigToString(balance.div(OneNear))}{" "}
      <span className="text-secondary">NEAR</span>
    </>
  ) : (
    "???"
  );

export const dateToString = (d) => {
  return d.toLocaleString("en-us", {
    day: "numeric",
    month: "short",
    year: "numeric",
  });
};

export const displayTime = (d) => {
  return d.toLocaleString();
};

export const availableNearBalance = (account) => {
  if (account && !account.loading && account.state) {
    let balance = Big(account.state.amount).sub(
      Big(account.state.storage_usage).mul(Big(NearConfig.storageCostPerByte))
    );
    if (balance.gt(AccountSafetyMargin)) {
      return balance.sub(AccountSafetyMargin);
    }
  }
  return Big(0);
};

export const isoDate = (d) =>
  d ? new Date(d).toISOString().substring(0, 10) : "";

export function accountTrim(accountId) {
  return (accountId && accountId.length > 14 + 14 + 1) ?
    accountId.slice(0, 14) + '…' + accountId.slice(-14) :
    accountId;
}

'''
'''--- src/index.css ---
body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}

'''
'''--- src/index.js ---
import React from "react";
import ReactDOM from "react-dom";
import "./index.css";
import App from "./App";

ReactDOM.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
  document.getElementById("root")
);

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
// reportWebVitals();

'''
'''--- src/setupTests.js ---
// jest-dom adds custom jest matchers for asserting on DOM nodes.
// allows you to do things like:
// expect(element).toHaveTextContent(/react/i)
// learn more: https://github.com/testing-library/jest-dom
import '@testing-library/jest-dom';

'''