*GitHub Repository "PrimeLabCore/dag"*

'''--- .github/workflows/release.yml ---
on:
  push:
    # Sequence of patterns matched against refs/tags
    tags:
      - 'v*' # Push events to matching v*, i.e. v1.0, v20.15.10
   
name: Create Release

jobs:
  build:
    name: Create Release
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      - name: Create Release
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # This token is provided by Actions, you do not need to create your own token
        with:
          tag_name: ${{ github.ref }}
          release_name: ${{ github.ref }}
          body: ""
          draft: false
          prerelease: false
      - name: Update Index
        run: |
          curl -s "https://sum.golang.org/lookup/github.com/${GITHUB_REPOSITORY}@${GITHUB_REF##*/}"
          curl -s "https://proxy.golang.org/github.com/${GITHUB_REPOSITORY}/@v/${GITHUB_REF##*/}.info"        

'''
'''--- .github/workflows/test.yml ---
on:
  push:
    branches:
      - master
  pull_request:
    branches:
      - master

name: Run Tests
jobs:
  lint:
    runs-on: ubuntu-latest
    steps:
    - name: Install Go
      uses: actions/setup-go@v3
      with:
        go-version: '1.17'
    - name: Checkout Code
      uses: actions/checkout@v3
    - name: Run Linters
      uses: golangci/golangci-lint-action@v3
      with:
        version: v1.43

  test:
    strategy:
      matrix:
        go-version: ['1.15', '1.16', '1.17']
        platform: [ubuntu-latest, macos-latest, windows-latest]
    runs-on: ${{ matrix.platform }}
    steps:
    - name: Install Go
      if: success()
      uses: actions/setup-go@v2
      with:
        go-version: ${{ matrix.go-version }}
    - name: Checkout Code
      uses: actions/checkout@v2
    - name: Run Tests
      run: go test -v -covermode=count

'''
'''--- .gitpod.yml ---
tasks:
  - init: go get && go build ./... && go test ./...
    command: go run

'''
'''--- README.md ---
# dag

[![run tests](https://github.com/nearprime/dag/workflows/Run%20Tests/badge.svg?branch=master)](https://github.com/nearprime/dag/actions?query=branch%3Amaster)
[![PkgGoDev](https://pkg.go.dev/badge/github.com/nearprime/dag)](https://pkg.go.dev/github.com/nearprime/dag)
[![Go Report Card](https://goreportcard.com/badge/github.com/nearprime/dag)](https://goreportcard.com/report/github.com/nearprime/dag)
[![Gitpod ready-to-code](https://img.shields.io/badge/Gitpod-ready--to--code-blue?logo=gitpod)](https://gitpod.io/#https://github.com/nearprime/dag)

Implementation of directed acyclic graphs (DAGs).

The implementation is fast and thread-safe. It prevents adding cycles or 
duplicates and thereby always maintains a valid DAG. The implementation caches
descendants and ancestors to speed up subsequent calls. 

<!--
github.com/nearprime/dag:

3.770388s to add 597871 vertices and 597870 edges
1.578741s to get descendants
0.143887s to get descendants 2nd time
0.444065s to get descendants ordered
0.000008s to get children
1.301297s to transitively reduce the graph with caches poupulated
2.723708s to transitively reduce the graph without caches poupulated
0.168572s to delete an edge from the root

"github.com/hashicorp/terraform/dag":

3.195338s to add 597871 vertices and 597870 edges
1.121812s to get descendants
1.803096s to get descendants 2nd time
3.056972s to transitively reduce the graph
-->

## Quickstart

Running: 

``` go
package main

import (
	"fmt"
	"github.com/nearprime/dag"
)

func main() {

	// initialize a new graph
	d := NewDAG()

	// init three vertices
	v1, _ := d.AddVertex(1)
	v2, _ := d.AddVertex(2)
	v3, _ := d.AddVertex(struct{a string; b string}{a: "foo", b: "bar"})

	// add the above vertices and connect them with two edges
	_ = d.AddEdge(v1, v2)
	_ = d.AddEdge(v1, v3)

	// describe the graph
	fmt.Print(d.String())
}
```

will result in something like:

```
DAG Vertices: 3 - Edges: 2
Vertices:
  1
  2
  {foo bar}
Edges:
  1 -> 2
  1 -> {foo bar}
```

'''
'''--- cmd/basic/main.go ---
package main

import (
	"fmt"
	"github.com/nearprime/dag"
)

func main() {

	// initialize a new graph
	d := dag.NewDAG()

	// init three vertices
	v1, _ := d.AddVertex(1)
	v2, _ := d.AddVertex(2)
	v3, _ := d.AddVertex(3)

	// add the above vertices and connect them with two edges
	_ = d.AddEdge(v1, v2)
	_ = d.AddEdge(v1, v3)

	// describe the graph
	fmt.Print(d.String())
}

'''
'''--- cmd/terraform/main.go ---
package main

/*
import (
	"fmt"
	"github.com/hashicorp/terraform/dag"
	"math"
	"time"
)

type largeVertex struct {
	value int
}

// implement the Vertex's interface method String()
func (v largeVertex) String() string {
	return fmt.Sprintf("%d", v.value)
}

// implement the Vertex's interface method ID()
func (v largeVertex) ID() string {
	return fmt.Sprintf("%d", v.value)
}
*/

func main() {
	/*
		var d dag.AcyclicGraph

		root := d.Add(1)
		levels := 7
		branches := 9
		var start, end time.Time

		start = time.Now()
		largeAux(d, levels, branches, root)
		_ = d.Validate()
		end = time.Now()
		fmt.Printf("%fs to add %d vertices and %d edges\n", end.Sub(start).Seconds(), len(d.Vertices()), len(d.Edges()))
		expectedVertexCount := sum(0, levels-1, branches, pow)
		vertexCount := len(d.Vertices())
		if vertexCount != expectedVertexCount {
			panic(fmt.Sprintf("GetVertices() = %d, want %d", vertexCount, expectedVertexCount))
		}

		start = time.Now()
		descendants, _ := d.Descendents(root)
		end = time.Now()
		fmt.Printf("%fs to get descendants\n", end.Sub(start).Seconds())
		descendantsCount := descendants.Len()
		expectedDescendantsCount := vertexCount - 1
		if descendantsCount != expectedDescendantsCount {
			panic(fmt.Sprintf("GetDescendants(root) = %d, want %d", descendantsCount, expectedDescendantsCount))
		}

		start = time.Now()
		_, _ = d.Descendents(root)
		end = time.Now()
		fmt.Printf("%fs to get descendants 2nd time\n", end.Sub(start).Seconds())

		start = time.Now()
		d.TransitiveReduction()
		end = time.Now()
		fmt.Printf("%fs to transitively reduce the graph\n", end.Sub(start).Seconds())
	*/
}

/*
func largeAux(d dag.AcyclicGraph, level int, branches int, parent dag.Vertex) {
	if level > 1 {
		if branches < 1 || branches > 9 {
			panic("number of branches must be between 1 and 9")
		}
		for i := 1; i <= branches; i++ {
			value := parent.(int)*10 + i
			child := d.Add(value)
			d.Connect(dag.BasicEdge(child, parent))
			largeAux(d, level-1, branches, child)
		}
	}
}

func sum(x, y, branches int, fn interface{}) int {
	if x > y {
		return 0
	}
	f, ok := fn.(func(int, int) int)
	if !ok {
		panic("function no of correct tpye")
	}
	current := f(branches, x)
	rest := sum(x+1, y, branches, f)
	return current + rest
}

func pow(base int, exp int) int {
	pow := math.Pow(float64(base), float64(exp))
	return int(pow)
}*/

'''
'''--- cmd/timing/main.go ---
package main

import (
	"fmt"
	"github.com/nearprime/dag"
	"math"
	"time"
)

type largeVertex struct {
	value int
}

// ID implement the interface{}'s interface method Id()
func (v largeVertex) ID() string {
	return fmt.Sprintf("%d", v.value)
}

func main() {
	d := dag.NewDAG()
	root := largeVertex{1}
	key, _ := d.AddVertex(root)
	levels := 7
	branches := 9
	var start, end time.Time

	start = time.Now()
	largeAux(d, levels, branches, root)
	end = time.Now()
	fmt.Printf("%fs to add %d vertices and %d edges\n", end.Sub(start).Seconds(), d.GetOrder(), d.GetSize())
	expectedVertexCount := sum(0, levels-1, branches, pow)
	vertexCount := len(d.GetVertices())
	if vertexCount != expectedVertexCount {
		panic(fmt.Sprintf("GetVertices() = %d, want %d", vertexCount, expectedVertexCount))
	}

	start = time.Now()
	descendants, _ := d.GetDescendants(key)
	end = time.Now()
	fmt.Printf("%fs to get descendants\n", end.Sub(start).Seconds())
	descendantsCount := len(descendants)
	expectedDescendantsCount := vertexCount - 1
	if descendantsCount != expectedDescendantsCount {
		panic(fmt.Sprintf("GetDescendants(root) = %d, want %d", descendantsCount, expectedDescendantsCount))
	}

	start = time.Now()
	_, _ = d.GetDescendants(key)
	end = time.Now()
	fmt.Printf("%fs to get descendants 2nd time\n", end.Sub(start).Seconds())

	start = time.Now()
	descendantsOrdered, _ := d.GetOrderedDescendants(key)
	end = time.Now()
	fmt.Printf("%fs to get descendants ordered\n", end.Sub(start).Seconds())
	descendantsOrderedCount := len(descendantsOrdered)
	if descendantsOrderedCount != expectedDescendantsCount {
		panic(fmt.Sprintf("GetOrderedDescendants(root) = %d, want %d", descendantsOrderedCount, expectedDescendantsCount))
	}

	start = time.Now()
	children, _ := d.GetChildren(key)
	end = time.Now()
	fmt.Printf("%fs to get children\n", end.Sub(start).Seconds())
	childrenCount := len(children)
	expectedChildrenCount := branches
	if childrenCount != expectedChildrenCount {
		panic(fmt.Sprintf("GetChildren(root) = %d, want %d", childrenCount, expectedChildrenCount))
	}

	_, _ = d.GetDescendants(key)
	edgeCountBefore := d.GetSize()
	start = time.Now()
	d.ReduceTransitively()
	end = time.Now()
	fmt.Printf("%fs to transitively reduce the graph with caches poupulated\n", end.Sub(start).Seconds())
	if edgeCountBefore != d.GetSize() {
		panic(fmt.Sprintf("GetSize() = %d, want %d", d.GetSize(), edgeCountBefore))
	}

	d.FlushCaches()
	start = time.Now()
	d.ReduceTransitively()
	end = time.Now()
	fmt.Printf("%fs to transitively reduce the graph without caches poupulated\n", end.Sub(start).Seconds())

	var childList []string
	for x := range children {
		childList = append(childList, x)
		break
	}
	start = time.Now()
	if len(childList) > 0 {
		_ = d.DeleteEdge(key, childList[0])
	}
	end = time.Now()
	fmt.Printf("%fs to delete an edge from the root\n", end.Sub(start).Seconds())

}

func largeAux(d *dag.DAG, level int, branches int, parent largeVertex) (int, int) {
	var vertexCount int
	var edgeCount int
	if level > 1 {
		if branches < 1 || branches > 9 {
			panic("number of branches must be between 1 and 9")
		}
		for i := 1; i <= branches; i++ {
			value := parent.value*10 + i
			child := largeVertex{value}
			childId, _ := d.AddVertex(child)
			vertexCount++
			err := d.AddEdge(parent.ID(), childId)
			edgeCount++
			if err != nil {
				panic(err)
			}
			childVertexCount, childEdgeCount := largeAux(d, level-1, branches, child)
			vertexCount += childVertexCount
			edgeCount += childEdgeCount
		}
	}
	return vertexCount, edgeCount
}

func sum(x, y, branches int, fn interface{}) int {
	if x > y {
		return 0
	}
	f, ok := fn.(func(int, int) int)
	if !ok {
		panic("function no of correct tpye")
	}
	current := f(branches, x)
	rest := sum(x+1, y, branches, f)
	return current + rest
}

func pow(base int, exp int) int {
	pow := math.Pow(float64(base), float64(exp))
	return int(pow)
}

'''
'''--- dag.go ---
// Package dag implements directed acyclic graphs (DAGs).
package dag

import (
	"fmt"
	"github.com/google/uuid"
	"sync"
)

// IDInterface describes the interface a type must implement in order to
// explicitly specify vertex id.
//
// Objects of types not implementing this interface will receive automatically
// generated ids (as of adding them to the graph).
type IDInterface interface {
	ID() string
}

// DAG implements the data structure of the DAG.
type DAG struct {
	muDAG            sync.RWMutex
	vertices         map[interface{}]string
	vertexIds        map[string]interface{}
	inboundEdge      map[interface{}]map[interface{}]struct{}
	outboundEdge     map[interface{}]map[interface{}]struct{}
	muCache          sync.RWMutex
	verticesLocked   *dMutex
	ancestorsCache   map[interface{}]map[interface{}]struct{}
	descendantsCache map[interface{}]map[interface{}]struct{}
}

// NewDAG creates / initializes a new DAG.
func NewDAG() *DAG {
	return &DAG{
		vertices:         make(map[interface{}]string),
		vertexIds:        make(map[string]interface{}),
		inboundEdge:      make(map[interface{}]map[interface{}]struct{}),
		outboundEdge:     make(map[interface{}]map[interface{}]struct{}),
		verticesLocked:   newDMutex(),
		ancestorsCache:   make(map[interface{}]map[interface{}]struct{}),
		descendantsCache: make(map[interface{}]map[interface{}]struct{}),
	}
}

// AddVertex adds the vertex v to the DAG. AddVertex returns an error, if v is
// nil, v is already part of the graph, or the id of v is already part of the
// graph.
func (d *DAG) AddVertex(v interface{}) (string, error) {

	d.muDAG.Lock()
	defer d.muDAG.Unlock()

	return d.addVertex(v)
}

func (d *DAG) addVertex(v interface{}) (string, error) {

	var id string
	if i, ok := v.(IDInterface); ok {
		id = i.ID()
	} else {
		id = uuid.New().String()
	}

	err := d.addVertexByID(id, v)
	return id, err
}

// AddVertexByID adds the vertex v and the specified id to the DAG.
// AddVertexByID returns an error, if v is nil, v is already part of the graph,
// or the specified id is already part of the graph.
func (d *DAG) AddVertexByID(id string, v interface{}) error {

	d.muDAG.Lock()
	defer d.muDAG.Unlock()

	return d.addVertexByID(id, v)
}

func (d *DAG) addVertexByID(id string, v interface{}) error {

	// sanity checking
	if v == nil {
		return VertexNilError{}
	}
	if _, exists := d.vertices[v]; exists {
		return VertexDuplicateError{v}
	}

	if _, exists := d.vertexIds[id]; exists {
		return IDDuplicateError{id}
	}

	d.vertices[v] = id
	d.vertexIds[id] = v

	return nil
}

// GetVertex returns a vertex by its id. GetVertex returns an error, if id is
// the empty string or unknown.
func (d *DAG) GetVertex(id string) (interface{}, error) {
	d.muDAG.RLock()
	defer d.muDAG.RUnlock()

	if id == "" {
		return nil, IDEmptyError{}
	}

	v, exists := d.vertexIds[id]
	if !exists {
		return nil, IDUnknownError{id}
	}
	return v, nil
}

// DeleteVertex deletes the vertex with the given id. DeleteVertex also
// deletes all attached edges (inbound and outbound). DeleteVertex returns
// an error, if id is empty or unknown.
func (d *DAG) DeleteVertex(id string) error {

	d.muDAG.Lock()
	defer d.muDAG.Unlock()

	if err := d.saneID(id); err != nil {
		return err
	}

	v := d.vertexIds[id]

	// get descendents and ancestors as they are now
	descendants := copyMap(d.getDescendants(v))
	ancestors := copyMap(d.getAncestors(v))

	// delete v in outbound edges of parents
	if _, exists := d.inboundEdge[v]; exists {
		for parent := range d.inboundEdge[v] {
			delete(d.outboundEdge[parent], v)
		}
	}

	// delete v in inbound edges of children
	if _, exists := d.outboundEdge[v]; exists {
		for child := range d.outboundEdge[v] {
			delete(d.inboundEdge[child], v)
		}
	}

	// delete in- and outbound of v itself
	delete(d.inboundEdge, v)
	delete(d.outboundEdge, v)

	// for v and all its descendants delete cached ancestors
	for descendant := range descendants {
		delete(d.ancestorsCache, descendant)
	}
	delete(d.ancestorsCache, v)

	// for v and all its ancestors delete cached descendants
	for ancestor := range ancestors {
		delete(d.descendantsCache, ancestor)
	}
	delete(d.descendantsCache, v)

	// delete v itself
	delete(d.vertices, v)
	delete(d.vertexIds, id)

	return nil
}

// AddEdge adds an edge between srcID and dstID. AddEdge returns an
// error, if srcID or dstID are empty strings or unknown, if the edge
// already exists, or if the new edge would create a loop.
func (d *DAG) AddEdge(srcID, dstID string) error {

	d.muDAG.Lock()
	defer d.muDAG.Unlock()

	if err := d.saneID(srcID); err != nil {
		return err
	}

	if err := d.saneID(dstID); err != nil {
		return err
	}

	if srcID == dstID {
		return SrcDstEqualError{srcID, dstID}
	}

	src := d.vertexIds[srcID]
	dst := d.vertexIds[dstID]

	// if the edge is already known, there is nothing else to do
	if d.isEdge(src, dst) {
		return EdgeDuplicateError{srcID, dstID}
	}

	// get descendents and ancestors as they are now
	descendants := copyMap(d.getDescendants(dst))
	ancestors := copyMap(d.getAncestors(src))

	if _, exists := descendants[src]; exists {
		return EdgeLoopError{srcID, dstID}
	}

	// prepare d.outbound[src], iff needed
	if _, exists := d.outboundEdge[src]; !exists {
		d.outboundEdge[src] = make(map[interface{}]struct{})
	}

	// dst is a child of src
	d.outboundEdge[src][dst] = struct{}{}

	// prepare d.inboundEdge[dst], iff needed
	if _, exists := d.inboundEdge[dst]; !exists {
		d.inboundEdge[dst] = make(map[interface{}]struct{})
	}

	// src is a parent of dst
	d.inboundEdge[dst][src] = struct{}{}

	// for dst and all its descendants delete cached ancestors
	for descendant := range descendants {
		delete(d.ancestorsCache, descendant)
	}
	delete(d.ancestorsCache, dst)

	// for src and all its ancestors delete cached descendants
	for ancestor := range ancestors {
		delete(d.descendantsCache, ancestor)
	}
	delete(d.descendantsCache, src)

	return nil
}

// IsEdge returns true, if there exists an edge between srcID and dstID.
// IsEdge returns false, if there is no such edge. IsEdge returns an error,
// if srcID or dstID are empty, unknown, or the same.
func (d *DAG) IsEdge(srcID, dstID string) (bool, error) {
	d.muDAG.RLock()
	defer d.muDAG.RUnlock()

	if err := d.saneID(srcID); err != nil {
		return false, err
	}
	if err := d.saneID(dstID); err != nil {
		return false, err
	}
	if srcID == dstID {
		return false, SrcDstEqualError{srcID, dstID}
	}

	return d.isEdge(d.vertexIds[srcID], d.vertexIds[dstID]), nil
}

func (d *DAG) isEdge(src, dst interface{}) bool {

	if _, exists := d.outboundEdge[src]; !exists {
		return false
	}
	if _, exists := d.outboundEdge[src][dst]; !exists {
		return false
	}
	if _, exists := d.inboundEdge[dst]; !exists {
		return false
	}
	if _, exists := d.inboundEdge[dst][src]; !exists {
		return false
	}
	return true
}

// DeleteEdge deletes the edge between srcID and dstID. DeleteEdge
// returns an error, if srcID or dstID are empty or unknown, or if,
// there is no edge between srcID and dstID.
func (d *DAG) DeleteEdge(srcID, dstID string) error {

	d.muDAG.Lock()
	defer d.muDAG.Unlock()

	if err := d.saneID(srcID); err != nil {
		return err
	}
	if err := d.saneID(dstID); err != nil {
		return err
	}
	if srcID == dstID {
		return SrcDstEqualError{srcID, dstID}
	}

	src := d.vertexIds[srcID]
	dst := d.vertexIds[dstID]

	if !d.isEdge(src, dst) {
		return EdgeUnknownError{srcID, dstID}
	}

	// get descendents and ancestors as they are now
	descendants := copyMap(d.getDescendants(src))
	ancestors := copyMap(d.getAncestors(dst))

	// delete outbound and inbound
	delete(d.outboundEdge[src], dst)
	delete(d.inboundEdge[dst], src)

	// for src and all its descendants delete cached ancestors
	for descendant := range descendants {
		delete(d.ancestorsCache, descendant)
	}
	delete(d.ancestorsCache, src)

	// for dst and all its ancestors delete cached descendants
	for ancestor := range ancestors {
		delete(d.descendantsCache, ancestor)
	}
	delete(d.descendantsCache, dst)

	return nil
}

// GetOrder returns the number of vertices in the graph.
func (d *DAG) GetOrder() int {
	d.muDAG.RLock()
	defer d.muDAG.RUnlock()
	return d.getOrder()
}

func (d *DAG) getOrder() int {
	return len(d.vertices)
}

// GetSize returns the number of edges in the graph.
func (d *DAG) GetSize() int {
	d.muDAG.RLock()
	defer d.muDAG.RUnlock()
	return d.getSize()
}

func (d *DAG) getSize() int {
	count := 0
	for _, value := range d.outboundEdge {
		count += len(value)
	}
	return count
}

// GetLeaves returns all vertices without children.
func (d *DAG) GetLeaves() map[string]interface{} {
	d.muDAG.RLock()
	defer d.muDAG.RUnlock()
	return d.getLeaves()
}

func (d *DAG) getLeaves() map[string]interface{} {
	leaves := make(map[string]interface{})
	for v := range d.vertices {
		dstIDs, ok := d.outboundEdge[v]
		if !ok || len(dstIDs) == 0 {
			id := d.vertices[v]
			leaves[id] = v
		}
	}
	return leaves
}

// IsLeaf returns true, if the vertex with the given id has no children. IsLeaf
// returns an error, if id is empty or unknown.
func (d *DAG) IsLeaf(id string) (bool, error) {
	d.muDAG.RLock()
	defer d.muDAG.RUnlock()
	if err := d.saneID(id); err != nil {
		return false, err
	}
	return d.isLeaf(id), nil
}

func (d *DAG) isLeaf(id string) bool {
	v := d.vertexIds[id]
	dstIDs, ok := d.outboundEdge[v]
	if !ok || len(dstIDs) == 0 {
		return true
	}
	return false
}

// GetRoots returns all vertices without parents.
func (d *DAG) GetRoots() map[string]interface{} {
	d.muDAG.RLock()
	defer d.muDAG.RUnlock()
	return d.getRoots()
}

func (d *DAG) getRoots() map[string]interface{} {
	roots := make(map[string]interface{})
	for v := range d.vertices {
		srcIDs, ok := d.inboundEdge[v]
		if !ok || len(srcIDs) == 0 {
			id := d.vertices[v]
			roots[id] = v
		}
	}
	return roots
}

// IsRoot returns true, if the vertex with the given id has no parents. IsRoot
// returns an error, if id is empty or unknown.
func (d *DAG) IsRoot(id string) (bool, error) {
	d.muDAG.RLock()
	defer d.muDAG.RUnlock()
	if err := d.saneID(id); err != nil {
		return false, err
	}
	return d.isRoot(id), nil
}

func (d *DAG) isRoot(id string) bool {
	v := d.vertexIds[id]
	srcIDs, ok := d.inboundEdge[v]
	if !ok || len(srcIDs) == 0 {
		return true
	}
	return false
}

// GetVertices returns all vertices.
func (d *DAG) GetVertices() map[string]interface{} {
	d.muDAG.RLock()
	defer d.muDAG.RUnlock()
	out := make(map[string]interface{})
	for id, value := range d.vertexIds {
		out[id] = value
	}
	return out
}

// GetParents returns the all parents of the vertex with the id
// id. GetParents returns an error, if id is empty or unknown.
func (d *DAG) GetParents(id string) (map[string]interface{}, error) {
	d.muDAG.RLock()
	defer d.muDAG.RUnlock()
	if err := d.saneID(id); err != nil {
		return nil, err
	}
	v := d.vertexIds[id]
	parents := make(map[string]interface{})
	for pv := range d.inboundEdge[v] {
		pid := d.vertices[pv]
		parents[pid] = pv
	}
	return parents, nil
}

// GetChildren returns all children of the vertex with the id
// id. GetChildren returns an error, if id is empty or unknown.
func (d *DAG) GetChildren(id string) (map[string]interface{}, error) {
	d.muDAG.RLock()
	defer d.muDAG.RUnlock()
	return d.getChildren(id)
}

func (d *DAG) getChildren(id string) (map[string]interface{}, error) {
	if err := d.saneID(id); err != nil {
		return nil, err
	}
	v := d.vertexIds[id]
	children := make(map[string]interface{})
	for cv := range d.outboundEdge[v] {
		cid := d.vertices[cv]
		children[cid] = cv
	}
	return children, nil
}

// GetAncestors return all ancestors of the vertex with the id id. GetAncestors
// returns an error, if id is empty or unknown.
//
// Note, in order to get the ancestors, GetAncestors populates the ancestor-
// cache as needed. Depending on order and size of the sub-graph of the vertex
// with id id this may take a long time and consume a lot of memory.
func (d *DAG) GetAncestors(id string) (map[string]interface{}, error) {
	d.muDAG.RLock()
	defer d.muDAG.RUnlock()
	if err := d.saneID(id); err != nil {
		return nil, err
	}
	v := d.vertexIds[id]
	ancestors := make(map[string]interface{})
	for av := range d.getAncestors(v) {
		aid := d.vertices[av]
		ancestors[aid] = av
	}
	return ancestors, nil
}

func (d *DAG) getAncestors(v interface{}) map[interface{}]struct{} {

	// in the best case we have already a populated cache
	d.muCache.RLock()
	cache, exists := d.ancestorsCache[v]
	d.muCache.RUnlock()
	if exists {
		return cache
	}

	// lock this vertex to work on it exclusively
	d.verticesLocked.lock(v)
	defer d.verticesLocked.unlock(v)

	// now as we have locked this vertex, check (again) that no one has
	// meanwhile populated the cache
	d.muCache.RLock()
	cache, exists = d.ancestorsCache[v]
	d.muCache.RUnlock()
	if exists {
		return cache
	}

	// as there is no cache, we start from scratch and collect all ancestors locally
	cache = make(map[interface{}]struct{})
	var mu sync.Mutex
	if parents, ok := d.inboundEdge[v]; ok {

		// for each parent collect its ancestors
		for parent := range parents {
			parentAncestors := d.getAncestors(parent)
			mu.Lock()
			for ancestor := range parentAncestors {
				cache[ancestor] = struct{}{}
			}
			cache[parent] = struct{}{}
			mu.Unlock()
		}
	}

	// remember the collected descendents
	d.muCache.Lock()
	d.ancestorsCache[v] = cache
	d.muCache.Unlock()
	return cache
}

// GetOrderedAncestors returns all ancestors of the vertex with id id
// in a breath-first order. Only the first occurrence of each vertex is
// returned. GetOrderedAncestors returns an error, if id is empty or
// unknown.
//
// Note, there is no order between sibling vertices. Two consecutive runs of
// GetOrderedAncestors may return different results.
func (d *DAG) GetOrderedAncestors(id string) ([]string, error) {
	d.muDAG.RLock()
	defer d.muDAG.RUnlock()
	ids, _, err := d.AncestorsWalker(id)
	if err != nil {
		return nil, err
	}
	var ancestors []string
	for aid := range ids {
		ancestors = append(ancestors, aid)
	}
	return ancestors, nil
}

// AncestorsWalker returns a channel and subsequently returns / walks all
// ancestors of the vertex with id id in a breath first order. The second
// channel returned may be used to stop further walking. AncestorsWalker
// returns an error, if id is empty or unknown.
//
// Note, there is no order between sibling vertices. Two consecutive runs of
// AncestorsWalker may return different results.
func (d *DAG) AncestorsWalker(id string) (chan string, chan bool, error) {
	d.muDAG.RLock()
	defer d.muDAG.RUnlock()
	if err := d.saneID(id); err != nil {
		return nil, nil, err
	}
	ids := make(chan string)
	signal := make(chan bool, 1)
	go func() {
		d.muDAG.RLock()
		v := d.vertexIds[id]
		d.walkAncestors(v, ids, signal)
		d.muDAG.RUnlock()
		close(ids)
		close(signal)
	}()
	return ids, signal, nil
}

func (d *DAG) walkAncestors(v interface{}, ids chan string, signal chan bool) {

	var fifo []interface{}
	visited := make(map[interface{}]struct{})
	for parent := range d.inboundEdge[v] {
		visited[parent] = struct{}{}
		fifo = append(fifo, parent)
	}
	for {
		if len(fifo) == 0 {
			return
		}
		top := fifo[0]
		fifo = fifo[1:]
		for parent := range d.inboundEdge[top] {
			if _, exists := visited[parent]; !exists {
				visited[parent] = struct{}{}
				fifo = append(fifo, parent)
			}
		}
		select {
		case <-signal:
			return
		default:
			ids <- d.vertices[top]
		}
	}
}

// GetDescendants return all descendants of the vertex with id id.
// GetDescendants returns an error, if id is empty or unknown.
//
// Note, in order to get the descendants, GetDescendants populates the
// descendants-cache as needed. Depending on order and size of the sub-graph
// of the vertex with id id this may take a long time and consume a lot
// of memory.
func (d *DAG) GetDescendants(id string) (map[string]interface{}, error) {
	d.muDAG.RLock()
	defer d.muDAG.RUnlock()

	if err := d.saneID(id); err != nil {
		return nil, err
	}
	v := d.vertexIds[id]
	//return copyMap(d.getAncestors(v)), nil

	descendants := make(map[string]interface{})
	for dv := range d.getDescendants(v) {
		did := d.vertices[dv]
		descendants[did] = dv
	}
	return descendants, nil
}

func (d *DAG) getDescendants(v interface{}) map[interface{}]struct{} {

	// in the best case we have already a populated cache
	d.muCache.RLock()
	cache, exists := d.descendantsCache[v]
	d.muCache.RUnlock()
	if exists {
		return cache
	}

	// lock this vertex to work on it exclusively
	d.verticesLocked.lock(v)
	defer d.verticesLocked.unlock(v)

	// now as we have locked this vertex, check (again) that no one has
	// meanwhile populated the cache
	d.muCache.RLock()
	cache, exists = d.descendantsCache[v]
	d.muCache.RUnlock()
	if exists {
		return cache
	}

	// as there is no cache, we start from scratch and collect all descendants
	// locally
	cache = make(map[interface{}]struct{})
	var mu sync.Mutex
	if children, ok := d.outboundEdge[v]; ok {

		// for each child use a goroutine to collect its descendants
		//var waitGroup sync.WaitGroup
		//waitGroup.Add(len(children))
		for child := range children {
			//go func(child interface{}, mu *sync.Mutex, cache map[interface{}]bool) {
			childDescendants := d.getDescendants(child)
			mu.Lock()
			for descendant := range childDescendants {
				cache[descendant] = struct{}{}
			}
			cache[child] = struct{}{}
			mu.Unlock()
			//waitGroup.Done()
			//}(child, &mu, cache)
		}
		//waitGroup.Wait()
	}

	// remember the collected descendents
	d.muCache.Lock()
	d.descendantsCache[v] = cache
	d.muCache.Unlock()
	return cache
}

// GetOrderedDescendants returns all descendants of the vertex with id id
// in a breath-first order. Only the first occurrence of each vertex is
// returned. GetOrderedDescendants returns an error, if id is empty or
// unknown.
//
// Note, there is no order between sibling vertices. Two consecutive runs of
// GetOrderedDescendants may return different results.
func (d *DAG) GetOrderedDescendants(id string) ([]string, error) {
	d.muDAG.RLock()
	defer d.muDAG.RUnlock()
	ids, _, err := d.DescendantsWalker(id)
	if err != nil {
		return nil, err
	}
	var descendants []string
	for did := range ids {
		descendants = append(descendants, did)
	}
	return descendants, nil
}

// GetDescendantsGraph returns a new DAG consisting of the vertex with id id and
// all its descendants (i.e. the subgraph). GetDescendantsGraph also returns the
// id of the (copy of the) given vertex within the new graph (i.e. the id of the
// single root of the new graph). GetDescendantsGraph returns an error, if id is
// empty or unknown.
//
// Note, the new graph is a copy of the relevant part of the original graph.
func (d *DAG) GetDescendantsGraph(id string) (*DAG, string, error) {

	// recursively add the current vertex and all its descendants
	return d.getRelativesGraph(id, false)
}

// GetAncestorsGraph returns a new DAG consisting of the vertex with id id and
// all its ancestors (i.e. the subgraph). GetAncestorsGraph also returns the id
// of the (copy of the) given vertex within the new graph (i.e. the id of the
// single leaf of the new graph). GetAncestorsGraph returns an error, if id is
// empty or unknown.
//
// Note, the new graph is a copy of the relevant part of the original graph.
func (d *DAG) GetAncestorsGraph(id string) (*DAG, string, error) {

	// recursively add the current vertex and all its ancestors
	return d.getRelativesGraph(id, true)
}

func (d *DAG) getRelativesGraph(id string, asc bool) (*DAG, string, error) {
	// sanity checking
	if id == "" {
		return nil, "", IDEmptyError{}
	}
	v, exists := d.vertexIds[id]
	if !exists {
		return nil, "", IDUnknownError{id}
	}

	// create a new dag
	newDAG := NewDAG()

	// protect the graph from modification
	d.muDAG.RLock()
	defer d.muDAG.RUnlock()

	// recursively add the current vertex and all its relatives
	newId, err := d.getRelativesGraphRec(v, newDAG, make(map[interface{}]string), asc)
	return newDAG, newId, err
}

func (d *DAG) getRelativesGraphRec(v interface{}, newDAG *DAG, visited map[interface{}]string, asc bool) (newId string, err error) {

	// copy this vertex to the new graph
	if newId, err = newDAG.AddVertex(v); err != nil {
		return
	}

	// mark this vertex as visited
	visited[v] = newId

	// get the direct relatives (depending on the direction either parents or children)
	var relatives map[interface{}]struct{}
	var ok bool
	if asc {
		relatives, ok = d.inboundEdge[v]
	} else {
		relatives, ok = d.outboundEdge[v]
	}

	// for all direct relatives in the original graph
	if ok {
		for relative := range relatives {

			// if we haven't seen this relative
			relativeId, exists := visited[relative]
			if !exists {

				// recursively add this relative
				if relativeId, err = d.getRelativesGraphRec(relative, newDAG, visited, asc); err != nil {
					return
				}
			}

			// add edge to this relative (depending on the direction)
			var srcID, dstID string
			if asc {
				srcID, dstID = relativeId, newId

			} else {
				srcID, dstID = newId, relativeId
			}
			if err = newDAG.AddEdge(srcID, dstID); err != nil {
				return
			}
		}
	}
	return
}

// DescendantsWalker returns a channel and subsequently returns / walks all
// descendants of the vertex with id id in a breath first order. The second
// channel returned may be used to stop further walking. DescendantsWalker
// returns an error, if id is empty or unknown.
//
// Note, there is no order between sibling vertices. Two consecutive runs of
// DescendantsWalker may return different results.
func (d *DAG) DescendantsWalker(id string) (chan string, chan bool, error) {
	d.muDAG.RLock()
	defer d.muDAG.RUnlock()
	if err := d.saneID(id); err != nil {
		return nil, nil, err
	}
	ids := make(chan string)
	signal := make(chan bool, 1)
	go func() {
		d.muDAG.RLock()
		v := d.vertexIds[id]
		d.walkDescendants(v, ids, signal)
		d.muDAG.RUnlock()
		close(ids)
		close(signal)
	}()
	return ids, signal, nil
}

func (d *DAG) walkDescendants(v interface{}, ids chan string, signal chan bool) {
	var fifo []interface{}
	visited := make(map[interface{}]struct{})
	for child := range d.outboundEdge[v] {
		visited[child] = struct{}{}
		fifo = append(fifo, child)
	}
	for {
		if len(fifo) == 0 {
			return
		}
		top := fifo[0]
		fifo = fifo[1:]
		for child := range d.outboundEdge[top] {
			if _, exists := visited[child]; !exists {
				visited[child] = struct{}{}
				fifo = append(fifo, child)
			}
		}
		select {
		case <-signal:
			return
		default:
			ids <- d.vertices[top]
		}
	}
}

// FlowResult describes the data to be passed between vertices in a DescendantsFlow.
type FlowResult struct {

	// The id of the vertex that produced this result.
	ID string

	// The actual result.
	Result interface{}

	// Any error. Note, DescendantsFlow does not care about this error. It is up to
	// the FlowCallback of downstream vertices to handle the error as needed - if
	// needed.
	Error error
}

// FlowCallback is the signature of the (callback-) function to call for each
// vertex within a DescendantsFlow, after all its parents have finished their
// work. The parameters of the function are the (complete) DAG, the current
// vertex ID, and the results of all its parents. An instance of FlowCallback
// should return a result or an error.
type FlowCallback func(d *DAG, id string, parentResults []FlowResult) (interface{}, error)

// DescendantsFlow traverses descendants of the vertex with the ID startID. For
// the vertex itself and each of its descendant it executes the given (callback-)
// function providing it the results of its respective parents. The (callback-)
// function is only executed after all parents have finished their work.
func (d *DAG) DescendantsFlow(startID string, inputs []FlowResult, callback FlowCallback) ([]FlowResult, error) {
	d.muDAG.RLock()
	defer d.muDAG.RUnlock()

	// Get IDs of all descendant vertices.
	flowIDs, errDes := d.GetDescendants(startID)
	if errDes != nil {
		return []FlowResult{}, errDes
	}

	// inputChannels provides for input channels for each of the descendant vertices (+ the start-vertex).
	inputChannels := make(map[string]chan FlowResult, len(flowIDs)+1)

	// Iterate vertex IDs and create an input channel for each of them and a single
	// output channel for leaves. Note, this "pre-flight" is needed to ensure we
	// really have an input channel regardless of how we traverse the tree and spawn
	// workers.
	leafCount := 0
	for id := range flowIDs {

		// Get all parents of this vertex.
		parents, errPar := d.GetParents(id)
		if errPar != nil {
			return []FlowResult{}, errPar
		}

		// Create a buffered input channel that has capacity for all parent results.
		inputChannels[id] = make(chan FlowResult, len(parents))

		if d.isLeaf(id) {
			leafCount += 1
		}
	}

	// outputChannel caries the results of leaf vertices.
	outputChannel := make(chan FlowResult, leafCount)

	// To also process the start vertex and to have its results being passed to its
	// children, add it to the vertex IDs. Also add an input channel for the start
	// vertex and feed the inputs to this channel.
	flowIDs[startID] = struct{}{}
	inputChannels[startID] = make(chan FlowResult, len(inputs))
	for _, i := range inputs {
		inputChannels[startID] <- i
	}

	wg := sync.WaitGroup{}

	// Iterate all vertex IDs (now incl. start vertex) and handle each worker (incl.
	// inputs and outputs) in a separate goroutine.
	for id := range flowIDs {

		// Get all children of this vertex that later need to be notified. Note, we
		// collect all children before the goroutine to be able to release the read
		// lock as early as possible.
		children, errChildren := d.GetChildren(id)
		if errChildren != nil {
			return []FlowResult{}, errChildren
		}

		// Remember to wait for this goroutine.
		wg.Add(1)

		go func(id string) {

			// Get this vertex's input channel.
			// Note, only concurrent read here, which is fine.
			c := inputChannels[id]

			// Await all parent inputs and stuff them into a slice.
			parentCount := cap(c)
			parentResults := make([]FlowResult, parentCount)
			for i := 0; i < parentCount; i++ {
				parentResults[i] = <-c
			}

			// Execute the worker.
			result, errWorker := callback(d, id, parentResults)

			// Wrap the worker's result into a FlowResult.
			flowResult := FlowResult{
				ID:     id,
				Result: result,
				Error:  errWorker,
			}

			// Send this worker's FlowResult onto all children's input channels or, if it is
			// a leaf (i.e. no children), send the result onto the output channel.
			if len(children) > 0 {
				for child := range children {
					inputChannels[child] <- flowResult
				}
			} else {
				outputChannel <- flowResult
			}

			// "Sign off".
			wg.Done()

		}(id)
	}

	// Wait for all go routines to finish.
	wg.Wait()

	// Await all leaf vertex results and stuff them into a slice.
	resultCount := cap(outputChannel)
	results := make([]FlowResult, resultCount)
	for i := 0; i < resultCount; i++ {
		results[i] = <-outputChannel
	}

	return results, nil
}

// ReduceTransitively transitively reduce the graph.
//
// Note, in order to do the reduction the descendant-cache of all vertices is
// populated (i.e. the transitive closure). Depending on order and size of DAG
// this may take a long time and consume a lot of memory.
func (d *DAG) ReduceTransitively() {

	d.muDAG.Lock()
	defer d.muDAG.Unlock()

	graphChanged := false

	// populate the descendents cache for all roots (i.e. the whole graph)
	for _, root := range d.getRoots() {
		_ = d.getDescendants(root)
	}

	// for each vertex
	for v := range d.vertices {

		// map of descendants of the children of v
		descendentsOfChildrenOfV := make(map[interface{}]struct{})

		// for each child of v
		for childOfV := range d.outboundEdge[v] {

			// collect child descendants
			for descendent := range d.descendantsCache[childOfV] {
				descendentsOfChildrenOfV[descendent] = struct{}{}
			}
		}

		// for each child of v
		for childOfV := range d.outboundEdge[v] {

			// remove the edge between v and child, iff child is a
			// descendant of any of the children of v
			if _, exists := descendentsOfChildrenOfV[childOfV]; exists {
				delete(d.outboundEdge[v], childOfV)
				delete(d.inboundEdge[childOfV], v)
				graphChanged = true
			}
		}
	}

	// flush the descendants- and ancestor cache if the graph has changed
	if graphChanged {
		d.flushCaches()
	}
}

// FlushCaches completely flushes the descendants- and ancestor cache.
//
// Note, the only reason to call this method is to free up memory.
// Normally the caches are automatically maintained.
func (d *DAG) FlushCaches() {
	d.muDAG.Lock()
	defer d.muDAG.Unlock()
	d.flushCaches()
}

func (d *DAG) flushCaches() {
	d.ancestorsCache = make(map[interface{}]map[interface{}]struct{})
	d.descendantsCache = make(map[interface{}]map[interface{}]struct{})
}

// Copy returns a copy of the DAG.
func (d *DAG) Copy() (newDAG *DAG, err error) {

	// create a new dag
	newDAG = NewDAG()

	// create a map of visited vertices
	visited := make(map[interface{}]string)

	// protect the graph from modification
	d.muDAG.RLock()
	defer d.muDAG.RUnlock()

	// add all roots and their descendants to the new DAG
	for _, root := range d.GetRoots() {
		if _, err = d.getRelativesGraphRec(root, newDAG, visited, false); err != nil {
			return
		}
	}
	return
}

// String returns a textual representation of the graph.
func (d *DAG) String() string {
	result := fmt.Sprintf("DAG Vertices: %d - Edges: %d\n", d.GetOrder(), d.GetSize())
	result += "Vertices:\n"
	d.muDAG.RLock()
	for k := range d.vertices {
		result += fmt.Sprintf("  %v\n", k)
	}
	result += "Edges:\n"
	for v, children := range d.outboundEdge {
		for child := range children {
			result += fmt.Sprintf("  %v -> %v\n", v, child)
		}
	}
	d.muDAG.RUnlock()
	return result
}

func (d *DAG) saneID(id string) error {
	// sanity checking
	if id == "" {
		return IDEmptyError{}
	}
	_, exists := d.vertexIds[id]
	if !exists {
		return IDUnknownError{id}
	}
	return nil
}

func copyMap(in map[interface{}]struct{}) map[interface{}]struct{} {
	out := make(map[interface{}]struct{})
	for id, value := range in {
		out[id] = value
	}
	return out
}

/***************************
********** Errors **********
****************************/

// VertexNilError is the error type to describe the situation, that a nil is
// given instead of a vertex.
type VertexNilError struct{}

// Implements the error interface.
func (e VertexNilError) Error() string {
	return "don't know what to do with 'nil'"
}

// VertexDuplicateError is the error type to describe the situation, that a
// given vertex already exists in the graph.
type VertexDuplicateError struct {
	v interface{}
}

// Implements the error interface.
func (e VertexDuplicateError) Error() string {
	return fmt.Sprintf("'%v' is already known", e.v)
}

// IDDuplicateError is the error type to describe the situation, that a given
// vertex id already exists in the graph.
type IDDuplicateError struct {
	id string
}

// Implements the error interface.
func (e IDDuplicateError) Error() string {
	return fmt.Sprintf("the id '%s' is already known", e.id)
}

// IDEmptyError is the error type to describe the situation, that an empty
// string is given instead of a valid id.
type IDEmptyError struct{}

// Implements the error interface.
func (e IDEmptyError) Error() string {
	return "don't know what to do with \"\""
}

// IDUnknownError is the error type to describe the situation, that a given
// vertex does not exit in the graph.
type IDUnknownError struct {
	id string
}

// Implements the error interface.
func (e IDUnknownError) Error() string {
	return fmt.Sprintf("'%s' is unknown", e.id)
}

// EdgeDuplicateError is the error type to describe the situation, that an edge
// already exists in the graph.
type EdgeDuplicateError struct {
	src string
	dst string
}

// Implements the error interface.
func (e EdgeDuplicateError) Error() string {
	return fmt.Sprintf("edge between '%s' and '%s' is already known", e.src, e.dst)
}

// EdgeUnknownError is the error type to describe the situation, that a given
// edge does not exit in the graph.
type EdgeUnknownError struct {
	src string
	dst string
}

// Implements the error interface.
func (e EdgeUnknownError) Error() string {
	return fmt.Sprintf("edge between '%s' and '%s' is unknown", e.src, e.dst)
}

// EdgeLoopError is the error type to describe loop errors (i.e. errors that
// where raised to prevent establishing loops in the graph).
type EdgeLoopError struct {
	src string
	dst string
}

// Implements the error interface.
func (e EdgeLoopError) Error() string {
	return fmt.Sprintf("edge between '%s' and '%s' would create a loop", e.src, e.dst)
}

// SrcDstEqualError is the error type to describe the situation, that src and
// dst are equal.
type SrcDstEqualError struct {
	src string
	dst string
}

// Implements the error interface.
func (e SrcDstEqualError) Error() string {
	return fmt.Sprintf("src ('%s') and dst ('%s') equal", e.src, e.dst)
}

/***************************
********** dMutex **********
****************************/

type cMutex struct {
	mutex sync.Mutex
	count int
}

// Structure for dynamic mutexes.
type dMutex struct {
	mutexes     map[interface{}]*cMutex
	globalMutex sync.Mutex
}

// Initialize a new dynamic mutex structure.
func newDMutex() *dMutex {
	return &dMutex{
		mutexes: make(map[interface{}]*cMutex),
	}
}

// Get a lock for instance i
func (d *dMutex) lock(i interface{}) {

	// acquire global lock
	d.globalMutex.Lock()

	// if there is no cMutex for i, create it
	if _, ok := d.mutexes[i]; !ok {
		d.mutexes[i] = new(cMutex)
	}

	// increase the count in order to show, that we are interested in this
	// instance mutex (thus now one deletes it)
	d.mutexes[i].count++

	// remember the mutex for later
	mutex := &d.mutexes[i].mutex

	// as the cMutex is there, we have increased the count, and we know the
	// instance mutex, we can release the global lock
	d.globalMutex.Unlock()

	// and wait on the instance mutex
	(*mutex).Lock()
}

// Release the lock for instance i.
func (d *dMutex) unlock(i interface{}) {

	// acquire global lock
	d.globalMutex.Lock()

	// unlock instance mutex
	d.mutexes[i].mutex.Unlock()

	// decrease the count, as we are no longer interested in this instance
	// mutex
	d.mutexes[i].count--

	// if we are the last one interested in this instance mutex delete the
	// cMutex
	if d.mutexes[i].count == 0 {
		delete(d.mutexes, i)
	}

	// release the global lock
	d.globalMutex.Unlock()
}

'''
'''--- dag_test.go ---
package dag

import (
	"fmt"
	"github.com/go-test/deep"
	"strconv"
	"testing"
)

type iVertex struct{ value int }

func (v iVertex) ID() string { return fmt.Sprintf("%d", v.value) }

type foobar struct {
	A string
	B string
}
type foobarKey struct {
	A    string
	B    string
	MyID string
}

func (o foobarKey) ID() string { return o.MyID }

func TestNewDAG(t *testing.T) {
	dag := NewDAG()
	if order := dag.GetOrder(); order != 0 {
		t.Errorf("GetOrder() = %d, want 0", order)
	}
	if size := dag.GetSize(); size != 0 {
		t.Errorf("GetSize() = %d, want 0", size)
	}
}

func TestDAG_AddVertex(t *testing.T) {
	dag := NewDAG()

	// add a single vertex and inspect the graph
	v := iVertex{1}
	id, _ := dag.AddVertex(v)
	if id != v.ID() {
		t.Errorf("GetOrder().ID() = %s, want %s", id, v.ID())
	}
	if order := dag.GetOrder(); order != 1 {
		t.Errorf("GetOrder() = %d, want 1", order)
	}
	if size := dag.GetSize(); size != 0 {
		t.Errorf("GetSize() = %d, want 0", size)
	}
	if leaves := len(dag.GetLeaves()); leaves != 1 {
		t.Errorf("GetLeaves() = %d, want 1", leaves)
	}
	if roots := len(dag.GetRoots()); roots != 1 {
		t.Errorf("GetLeaves() = %d, want 1", roots)
	}
	vertices := dag.GetVertices()
	if vertices := len(vertices); vertices != 1 {
		t.Errorf("GetVertices() = %d, want 1", vertices)
	}

	if _, exists := vertices[id]; !exists {
		t.Errorf("GetVertices()[id] = false, want true")
	}

	// duplicate
	_, errDuplicate := dag.AddVertex(v)
	if errDuplicate == nil {
		t.Errorf("AddVertex(v) = nil, want %T", VertexDuplicateError{v})
	}
	if _, ok := errDuplicate.(VertexDuplicateError); !ok {
		t.Errorf("AddVertex(v) expected VertexDuplicateError, got %T", errDuplicate)
	}

	// duplicate
	_, errIDDuplicate := dag.AddVertex(foobarKey{MyID: "1"})
	if errIDDuplicate == nil {
		t.Errorf("AddVertex(foobarKey{MyID: \"1\"}) = nil, want %T", IDDuplicateError{"1"})
	}
	if _, ok := errIDDuplicate.(IDDuplicateError); !ok {
		t.Errorf("AddVertex(foobarKey{MyID: \"1\"}) expected IDDuplicateError, got %T", errIDDuplicate)
	}

	// nil
	_, errNil := dag.AddVertex(nil)
	if errNil == nil {
		t.Errorf("AddVertex(nil) = nil, want %T", VertexNilError{})
	}
	if _, ok := errNil.(VertexNilError); !ok {
		t.Errorf("AddVertex(nil) expected VertexNilError, got %T", errNil)
	}

}

func TestDAG_AddVertex2(t *testing.T) {
	dag := NewDAG()
	type testType struct{ value string }

	v := testType{"1"}
	id, _ := dag.AddVertex(v)
	vNew, _ := dag.GetVertex(id)
	vNewCasted, _ := vNew.(testType)
	if v != vNew {
		t.Errorf("want %v, got %v", v, vNewCasted)
	}
	if &v == &vNewCasted {
		t.Errorf("pointers shouldn't be equal but %p == %p", &v, &vNewCasted)
	}
	id, _ = dag.AddVertex(&v)
	vNew, _ = dag.GetVertex(id)
	vNewPtr, _ := vNew.(*testType)
	if v != *vNewPtr {
		t.Errorf("want %v, got %v", v, *vNewPtr)
	}
	if &v != vNewPtr {
		t.Errorf("pointers should be equal but %p != %p", &v, vNewPtr)
	}
	v.value = "20"
	if vNewPtr.value != v.value {
		t.Errorf("values not updated. want %s, got %s", v.value, vNewPtr.value)
	}
}

func TestDAG_AddVertexByID(t *testing.T) {
	dag := NewDAG()

	// add a single vertex and inspect the graph
	v := iVertex{1}
	id := "1"
	_ = dag.AddVertexByID(id, v)
	if id != v.ID() {
		t.Errorf("GetOrder().ID() = %s, want %s", id, v.ID())
	}
	vertices := dag.GetVertices()
	if vertices := len(vertices); vertices != 1 {
		t.Errorf("GetVertices() = %d, want 1", vertices)
	}

	if _, exists := vertices[id]; !exists {
		t.Errorf("GetVertices()[id] = false, want true")
	}

	// duplicate
	errDuplicate := dag.AddVertexByID(id, v)
	if errDuplicate == nil {
		t.Errorf("AddVertexByID(id, v) = nil, want %T", VertexDuplicateError{v})
	}
	if _, ok := errDuplicate.(VertexDuplicateError); !ok {
		t.Errorf("AddVertexByID(id, v) expected VertexDuplicateError, got %T", errDuplicate)
	}

	// duplicate
	_, errIDDuplicate := dag.AddVertex(foobarKey{MyID: "1"})
	if errIDDuplicate == nil {
		t.Errorf("AddVertex(foobarKey{MyID: \"1\"}) = nil, want %T", IDDuplicateError{"1"})
	}
	if _, ok := errIDDuplicate.(IDDuplicateError); !ok {
		t.Errorf("AddVertex(foobarKey{MyID: \"1\"}) expected IDDuplicateError, got %T", errIDDuplicate)
	}

	// nil
	errNil := dag.AddVertexByID("2", nil)
	if errNil == nil {
		t.Errorf(`AddVertexByID("2", nil) = nil, want %T`, VertexNilError{})
	}
	if _, ok := errNil.(VertexNilError); !ok {
		t.Errorf(`AddVertexByID("2", nil) expected VertexNilError, got %T`, errNil)
	}
}

func TestDAG_GetVertex(t *testing.T) {
	dag := NewDAG()
	v1 := iVertex{1}
	id, _ := dag.AddVertex(v1)
	if v, _ := dag.GetVertex(id); v != v1 {
		t.Errorf("GetVertex() = %v, want %v", v, v1)
	}

	// "complex" document without key
	v2 := foobar{A: "foo", B: "bar"}
	k2, _ := dag.AddVertex(v2)
	v3i, _ := dag.GetVertex(k2)
	v3, ok3 := v3i.(foobar)
	if !ok3 {
		t.Error("Casting GetVertex() to original type failed")
	}
	if deep.Equal(v2, v3) != nil {
		t.Errorf("GetVertex() = %v, want %v", v3, v2)
	}

	// "complex" document with key
	idF := "fancy key"
	v4 := foobarKey{A: "foo", B: "bar", MyID: idF}
	var v5 foobarKey
	k4, _ := dag.AddVertex(v4)
	if k4 != idF {
		t.Errorf("AddVertex({..., MyID: \"%s\") = %v, want %v", idF, k4, idF)
	}
	v5i, _ := dag.GetVertex(k4)
	v5, ok5 := v5i.(foobarKey)
	if !ok5 {
		t.Error("Casting GetVertex() to original type failed")
	}
	if deep.Equal(v4, v5) != nil {
		t.Errorf("GetVertex() = %v, want %v", v5, v4)
	}

	// unknown
	_, errUnknown := dag.GetVertex("foo")
	if errUnknown == nil {
		t.Errorf("DeleteVertex(\"foo\") = nil, want %T", IDUnknownError{"foo"})
	}
	if _, ok := errUnknown.(IDUnknownError); !ok {
		t.Errorf("DeleteVertex(\"foo\") expected IDUnknownError, got %T", errUnknown)
	}

	// nil
	_, errNil := dag.GetVertex("")
	if errNil == nil {
		t.Errorf("DeleteVertex(\"\") = nil, want %T", IDEmptyError{})
	}
	if _, ok := errNil.(IDEmptyError); !ok {
		t.Errorf("DeleteVertex(\"\") expected IDEmptyError, got %T", errNil)
	}
}

func TestDAG_DeleteVertex(t *testing.T) {
	dag := NewDAG()
	v1, _ := dag.AddVertex(iVertex{1})

	// delete a single vertex and inspect the graph
	err := dag.DeleteVertex(v1)
	if err != nil {
		t.Error(err)
	}
	if order := dag.GetOrder(); order != 0 {
		t.Errorf("GetOrder() = %d, want 0", order)
	}
	if size := dag.GetSize(); size != 0 {
		t.Errorf("GetSize() = %d, want 0", size)
	}
	if leaves := len(dag.GetLeaves()); leaves != 0 {
		t.Errorf("GetLeaves() = %d, want 0", leaves)
	}
	if roots := len(dag.GetRoots()); roots != 0 {
		t.Errorf("GetLeaves() = %d, want 0", roots)
	}
	vertices := dag.GetVertices()
	l := len(vertices)
	if l != 0 {
		t.Errorf("GetVertices() = %d, want 0", l)
	}

	v1, _ = dag.AddVertex(1)
	v2, _ := dag.AddVertex(2)
	v3, _ := dag.AddVertex(3)
	_ = dag.AddEdge(v1, v2)
	_ = dag.AddEdge(v2, v3)
	if order := dag.GetOrder(); order != 3 {
		t.Errorf("GetOrder() = %d, want 3", order)
	}
	if size := dag.GetSize(); size != 2 {
		t.Errorf("GetSize() = %d, want 2", size)
	}
	if leaves := len(dag.GetLeaves()); leaves != 1 {
		t.Errorf("GetLeaves() = %d, want 1", leaves)
	}
	if roots := len(dag.GetRoots()); roots != 1 {
		t.Errorf("GetLeaves() = %d, want 1", roots)
	}
	if vertices := len(dag.GetVertices()); vertices != 3 {
		t.Errorf("GetVertices() = %d, want 3", vertices)
	}
	if vertices, _ := dag.GetDescendants(v1); len(vertices) != 2 {
		t.Errorf("GetDescendants(v1) = %d, want 2", len(vertices))
	}
	if vertices, _ := dag.GetAncestors(v3); len(vertices) != 2 {
		t.Errorf("GetAncestors(v3) = %d, want 2", len(vertices))
	}

	_ = dag.DeleteVertex(v2)
	if order := dag.GetOrder(); order != 2 {
		t.Errorf("GetOrder() = %d, want 2", order)
	}
	if size := dag.GetSize(); size != 0 {
		t.Errorf("GetSize() = %d, want 0", size)
	}
	if leaves := len(dag.GetLeaves()); leaves != 2 {
		t.Errorf("GetLeaves() = %d, want 2", leaves)
	}
	if roots := len(dag.GetRoots()); roots != 2 {
		t.Errorf("GetLeaves() = %d, want 2", roots)
	}
	if vertices := len(dag.GetVertices()); vertices != 2 {
		t.Errorf("GetVertices() = %d, want 2", vertices)
	}
	if vertices, _ := dag.GetDescendants(v1); len(vertices) != 0 {
		t.Errorf("GetDescendants(v1) = %d, want 0", len(vertices))
	}
	if vertices, _ := dag.GetAncestors(v3); len(vertices) != 0 {
		t.Errorf("GetAncestors(v3) = %d, want 0", len(vertices))
	}

	// unknown
	errUnknown := dag.DeleteVertex("foo")
	if errUnknown == nil {
		t.Errorf("DeleteVertex(foo) = nil, want %T", IDUnknownError{"foo"})
	}
	if _, ok := errUnknown.(IDUnknownError); !ok {
		t.Errorf("DeleteVertex(foo) expected IDUnknownError, got %T", errUnknown)
	}

	// nil
	errNil := dag.DeleteVertex("")
	if errNil == nil {
		t.Errorf("DeleteVertex(nil) = nil, want %T", IDEmptyError{})
	}
	if _, ok := errNil.(IDEmptyError); !ok {
		t.Errorf("DeleteVertex(nil) expected IDEmptyError, got %T", errNil)
	}
}

func TestDAG_AddEdge(t *testing.T) {
	dag := NewDAG()
	v0, _ := dag.AddVertex("0")
	v1, _ := dag.AddVertex("1")
	v2, _ := dag.AddVertex("2")
	v3, _ := dag.AddVertex("3")

	// add a single edge and inspect the graph
	errUnexpected := dag.AddEdge(v1, v2)
	if errUnexpected != nil {
		t.Error(errUnexpected)
	}
	if children, _ := dag.GetChildren(v1); len(children) != 1 {
		t.Errorf("GetChildren(v1) = %d, want 1", len(children))
	}
	if parents, _ := dag.GetParents(v2); len(parents) != 1 {
		t.Errorf("GetParents(v2) = %d, want 1", len(parents))
	}
	if leaves := len(dag.GetLeaves()); leaves != 3 {
		t.Errorf("GetLeaves() = %d, want 1", leaves)
	}
	if roots := len(dag.GetRoots()); roots != 3 {
		t.Errorf("GetLeaves() = %d, want 1", roots)
	}
	if vertices, _ := dag.GetDescendants(v1); len(vertices) != 1 {
		t.Errorf("GetDescendants(v1) = %d, want 1", len(vertices))
	}
	if vertices, _ := dag.GetAncestors(v2); len(vertices) != 1 {
		t.Errorf("GetAncestors(v2) = %d, want 1", len(vertices))
	}

	err := dag.AddEdge(v2, v3)
	if err != nil {
		t.Fatal(err)
	}
	if vertices, _ := dag.GetDescendants(v1); len(vertices) != 2 {
		t.Errorf("GetDescendants(v1) = %d, want 2", len(vertices))
	}
	if vertices, _ := dag.GetAncestors(v3); len(vertices) != 2 {
		t.Errorf("GetAncestors(v3) = %d, want 2", len(vertices))
	}

	_ = dag.AddEdge(v0, v1)
	if vertices, _ := dag.GetDescendants(v0); len(vertices) != 3 {
		t.Errorf("GetDescendants(v0) = %d, want 3", len(vertices))
	}
	if vertices, _ := dag.GetAncestors(v3); len(vertices) != 3 {
		t.Errorf("GetAncestors(v3) = %d, want 3", len(vertices))
	}

	// loop
	errLoopSrcSrc := dag.AddEdge(v1, v1)
	if errLoopSrcSrc == nil {
		t.Errorf("AddEdge(v1, v1) = nil, want %T", SrcDstEqualError{v1, v1})
	}
	if _, ok := errLoopSrcSrc.(SrcDstEqualError); !ok {
		t.Errorf("AddEdge(v1, v1) expected SrcDstEqualError, got %T", errLoopSrcSrc)
	}
	errLoopDstSrc := dag.AddEdge(v2, v1)
	if errLoopDstSrc == nil {
		t.Errorf("AddEdge(v2, v1) = nil, want %T", EdgeLoopError{v2, v1})
	}
	if _, ok := errLoopDstSrc.(EdgeLoopError); !ok {
		t.Errorf("AddEdge(v2, v1) expected EdgeLoopError, got %T", errLoopDstSrc)
	}

	// duplicate
	errDuplicate := dag.AddEdge(v1, v2)
	if errDuplicate == nil {
		t.Errorf("AddEdge(v1, v2) = nil, want %T", EdgeDuplicateError{v1, v2})
	}
	if _, ok := errDuplicate.(EdgeDuplicateError); !ok {
		t.Errorf("AddEdge(v1, v2) expected EdgeDuplicateError, got %T", errDuplicate)
	}

	// nil
	errNilSrc := dag.AddEdge("", v2)
	if errNilSrc == nil {
		t.Errorf("AddEdge(nil, v2) = nil, want %T", IDEmptyError{})
	}
	if _, ok := errNilSrc.(IDEmptyError); !ok {
		t.Errorf("AddEdge(nil, v2) expected IDEmptyError, got %T", errNilSrc)
	}
	errNilDst := dag.AddEdge(v1, "")
	if errNilDst == nil {
		t.Errorf("AddEdge(v1, nil) = nil, want %T", IDEmptyError{})
	}
	if _, ok := errNilDst.(IDEmptyError); !ok {
		t.Errorf("AddEdge(v1, nil) expected IDEmptyError, got %T", errNilDst)
	}
}

func TestDAG_DeleteEdge(t *testing.T) {
	dag := NewDAG()
	v0, _ := dag.AddVertex(iVertex{0})
	v1, _ := dag.AddVertex("1")
	_ = dag.AddEdge(v0, v1)
	if size := dag.GetSize(); size != 1 {
		t.Errorf("GetSize() = %d, want 1", size)
	}
	_ = dag.DeleteEdge(v0, v1)
	if size := dag.GetSize(); size != 0 {
		t.Errorf("GetSize() = %d, want 0", size)
	}

	// unknown
	errUnknown := dag.DeleteEdge(v0, v1)
	if errUnknown == nil {
		t.Errorf("DeleteEdge(v0, v1) = nil, want %T", EdgeUnknownError{})
	}
	if _, ok := errUnknown.(EdgeUnknownError); !ok {
		t.Errorf("DeleteEdge(v0, v1) expected EdgeUnknownError, got %T", errUnknown)
	}

	// nil
	errNilSrc := dag.DeleteEdge("", v1)
	if errNilSrc == nil {
		t.Errorf("DeleteEdge(\"\", v1) = nil, want %T", IDEmptyError{})
	}
	if _, ok := errNilSrc.(IDEmptyError); !ok {
		t.Errorf("DeleteEdge(\"\", v1) expected IDEmptyError, got %T", errNilSrc)
	}
	errNilDst := dag.DeleteEdge(v0, "")
	if errNilDst == nil {
		t.Errorf("DeleteEdge(v0, \"\") = nil, want %T", IDEmptyError{})
	}
	if _, ok := errNilDst.(IDEmptyError); !ok {
		t.Errorf("DeleteEdge(v0, \"\") expected IDEmptyError, got %T", errNilDst)
	}

	// unknown
	errUnknownSrc := dag.DeleteEdge("foo", v1)
	if errUnknownSrc == nil {
		t.Errorf("DeleteEdge(foo, v1) = nil, want %T", IDUnknownError{})
	}
	if _, ok := errUnknownSrc.(IDUnknownError); !ok {
		t.Errorf("DeleteEdge(foo, v1) expected IDUnknownError, got %T", errUnknownSrc)
	}
	errUnknownDst := dag.DeleteEdge(v0, "foo")
	if errUnknownDst == nil {
		t.Errorf("DeleteEdge(v0, \"foo\") = nil, want %T", IDUnknownError{})
	}
	if _, ok := errUnknownDst.(IDUnknownError); !ok {
		t.Errorf("DeleteEdge(v0, \"foo\") expected IDUnknownError, got %T", errUnknownDst)
	}
}

func TestDAG_IsLeaf(t *testing.T) {
	dag := NewDAG()
	v1, _ := dag.AddVertex("1")
	v2, _ := dag.AddVertex("2")
	v3, _ := dag.AddVertex("3")

	_ = dag.AddEdge(v1, v2)
	_ = dag.AddEdge(v1, v3)
	if isLeaf, _ := dag.IsLeaf(v1); isLeaf {
		t.Errorf("IsLeaf(v1) = true, want false")
	}
	if isLeaf, _ := dag.IsLeaf(v2); !isLeaf {
		t.Errorf("IsLeaf(v2) = false, want true")
	}
	if isLeaf, _ := dag.IsLeaf(v3); !isLeaf {
		t.Errorf("IsLeaf(v3) = false, want true")
	}
	if _, err := dag.IsLeaf("foo"); err == nil {
		t.Errorf("IsLeaf(foo) = nil, want %T", IDUnknownError{})
	}
	if _, err := dag.IsLeaf(""); err == nil {
		t.Errorf("IsLeaf(\"\") = nil, want %T", IDEmptyError{})
	}
}

func TestDAG_IsRoot(t *testing.T) {
	dag := NewDAG()
	v1, _ := dag.AddVertex("1")
	v2, _ := dag.AddVertex("2")
	v3, _ := dag.AddVertex("3")

	_ = dag.AddEdge(v1, v2)
	_ = dag.AddEdge(v1, v3)
	if isRoot, _ := dag.IsRoot(v1); !isRoot {
		t.Errorf("IsRoot(v1) = false, want true")
	}
	if isRoot, _ := dag.IsRoot(v2); isRoot {
		t.Errorf("IsRoot(v2) = true, want false")
	}
	if isRoot, _ := dag.IsRoot(v3); isRoot {
		t.Errorf("IsRoot(v3) = true, want false")
	}
	if _, err := dag.IsRoot("foo"); err == nil {
		t.Errorf("IsRoot(foo) = nil, want %T", IDUnknownError{})
	}
	if _, err := dag.IsRoot(""); err == nil {
		t.Errorf("IsRoot(\"\") = nil, want %T", IDEmptyError{})
	}
}

func TestDAG_GetChildren(t *testing.T) {
	dag := NewDAG()
	v1, _ := dag.AddVertex("1")
	v2, _ := dag.AddVertex("2")
	v3, _ := dag.AddVertex("3")

	_ = dag.AddEdge(v1, v2)
	_ = dag.AddEdge(v1, v3)

	children, _ := dag.GetChildren(v1)
	if length := len(children); length != 2 {
		t.Errorf("GetChildren() = %d, want 2", length)
	}
	if _, exists := children[v2]; !exists {
		t.Errorf("GetChildren()[v2] = %t, want true", exists)
	}
	if _, exists := children[v3]; !exists {
		t.Errorf("GetChildren()[v3] = %t, want true", exists)
	}

	// nil
	_, errNil := dag.GetChildren("")
	if errNil == nil {
		t.Errorf("GetChildren(\"\") = nil, want %T", IDEmptyError{})
	}
	if _, ok := errNil.(IDEmptyError); !ok {
		t.Errorf("GetChildren(\"\") expected IDEmptyError, got %T", errNil)
	}

	// unknown
	_, errUnknown := dag.GetChildren("foo")
	if errUnknown == nil {
		t.Errorf("GetChildren(\"foo\") = nil, want %T", IDUnknownError{"foo"})
	}
	if _, ok := errUnknown.(IDUnknownError); !ok {
		t.Errorf("GetChildren(\"foo\") expected IDUnknownError, got %T", errUnknown)
	}
}

func TestDAG_GetParents(t *testing.T) {
	dag := NewDAG()
	v1, _ := dag.addVertex("1")
	v2, _ := dag.addVertex("2")
	v3, _ := dag.addVertex("3")
	_ = dag.AddEdge(v1, v3)
	_ = dag.AddEdge(v2, v3)

	parents, _ := dag.GetParents(v3)
	if length := len(parents); length != 2 {
		t.Errorf("GetParents(v3) = %d, want 2", length)
	}
	if _, exists := parents[v1]; !exists {
		t.Errorf("GetParents(v3)[v1] = %t, want true", exists)
	}
	if _, exists := parents[v2]; !exists {
		t.Errorf("GetParents(v3)[v2] = %t, want true", exists)
	}

	// nil
	_, errNil := dag.GetParents("")
	if errNil == nil {
		t.Errorf("GetParents(\"\") = nil, want %T", IDEmptyError{})
	}
	if _, ok := errNil.(IDEmptyError); !ok {
		t.Errorf("GetParents(\"\") expected IDEmptyError, got %T", errNil)
	}

	// unknown
	_, errUnknown := dag.GetParents("foo")
	if errUnknown == nil {
		t.Errorf("GetParents(\"foo\") = nil, want %T", IDUnknownError{"foo"})
	}
	if _, ok := errUnknown.(IDUnknownError); !ok {
		t.Errorf("GetParents(\"foo\") expected IDUnknownError, got %T", errUnknown)
	}

}

func TestDAG_GetDescendants(t *testing.T) {
	dag := NewDAG()
	v1, _ := dag.AddVertex("1")
	v2, _ := dag.AddVertex("2")
	v3, _ := dag.AddVertex("3")
	v4, _ := dag.AddVertex("4")

	_ = dag.AddEdge(v1, v2)
	_ = dag.AddEdge(v2, v3)
	_ = dag.AddEdge(v2, v4)

	if desc, _ := dag.GetDescendants(v1); len(desc) != 3 {
		t.Errorf("GetDescendants(v1) = %d, want 3", len(desc))
	}
	if desc, _ := dag.GetDescendants(v2); len(desc) != 2 {
		t.Errorf("GetDescendants(v2) = %d, want 2", len(desc))
	}
	if desc, _ := dag.GetDescendants(v3); len(desc) != 0 {
		t.Errorf("GetDescendants(v4) = %d, want 0", len(desc))
	}
	if desc, _ := dag.GetDescendants(v4); len(desc) != 0 {
		t.Errorf("GetDescendants(v4) = %d, want 0", len(desc))
	}

	// nil
	_, errNil := dag.GetDescendants("")
	if errNil == nil {
		t.Errorf("GetDescendants(\"\") = nil, want %T", IDEmptyError{})
	}
	if _, ok := errNil.(IDEmptyError); !ok {
		t.Errorf("GetDescendants(\"\") expected IDEmptyError, got %T", errNil)
	}

	// unknown
	_, errUnknown := dag.GetDescendants("foo")
	if errUnknown == nil {
		t.Errorf("GetDescendants(\"foo\") = nil, want %T", IDUnknownError{"foo"})
	}
	if _, ok := errUnknown.(IDUnknownError); !ok {
		t.Errorf("GetDescendants(\"foo\") expected IDUnknownError, got %T", errUnknown)
	}
}

func equal(a, b []string) bool {
	if len(a) != len(b) {
		return false
	}
	for i, v := range a {
		if v != b[i] {
			return false
		}
	}
	return true
}

func TestDAG_GetOrderedDescendants(t *testing.T) {
	dag := NewDAG()
	v1, _ := dag.AddVertex("1")
	v2, _ := dag.AddVertex("2")
	v3, _ := dag.AddVertex("3")
	v4, _ := dag.AddVertex("4")

	_ = dag.AddEdge(v1, v2)
	_ = dag.AddEdge(v2, v3)
	_ = dag.AddEdge(v2, v4)

	if desc, _ := dag.GetOrderedDescendants(v1); len(desc) != 3 {
		t.Errorf("len(GetOrderedDescendants(v1)) = %d, want 3", len(desc))
	}
	if desc, _ := dag.GetOrderedDescendants(v2); len(desc) != 2 {
		t.Errorf("len(GetOrderedDescendants(v2)) = %d, want 2", len(desc))
	}
	if desc, _ := dag.GetOrderedDescendants(v3); len(desc) != 0 {
		t.Errorf("len(GetOrderedDescendants(v4)) = %d, want 0", len(desc))
	}
	if desc, _ := dag.GetOrderedDescendants(v4); len(desc) != 0 {
		t.Errorf("GetOrderedDescendants(v4) = %d, want 0", len(desc))
	}
	if desc, _ := dag.GetOrderedDescendants(v1); !equal(desc, []string{v2, v3, v4}) && !equal(desc, []string{v2, v4, v3}) {
		t.Errorf("GetOrderedDescendants(v4) = %v, want %v or %v", desc, []string{v2, v3, v4}, []string{v2, v4, v3})
	}

	// nil
	_, errNil := dag.GetOrderedDescendants("")
	if errNil == nil {
		t.Errorf("GetOrderedDescendants(\"\") = nil, want %T", IDEmptyError{})
	}
	if _, ok := errNil.(IDEmptyError); !ok {
		t.Errorf("GetOrderedDescendants(\"\") expected IDEmptyError, got %T", errNil)
	}

	// unknown
	_, errUnknown := dag.GetOrderedDescendants("foo")
	if errUnknown == nil {
		t.Errorf("GetOrderedDescendants(\"foo\") = nil, want %T", IDUnknownError{"foo"})
	}
	if _, ok := errUnknown.(IDUnknownError); !ok {
		t.Errorf("GetOrderedDescendants(\"foo\") expected IDUnknownError, got %T", errUnknown)
	}
}

func TestDAG_GetDescendantsGraph(t *testing.T) {
	d0 := NewDAG()

	v1 := iVertex{1}
	v1ID, _ := d0.AddVertex(v1)
	_, _ = d0.AddVertex(iVertex{2})
	_, _ = d0.AddVertex(iVertex{3})
	_, _ = d0.AddVertex(iVertex{4})
	_, _ = d0.AddVertex(iVertex{5})
	v6 := iVertex{6}
	v6ID, _ := d0.AddVertex(v6)
	_, _ = d0.AddVertex(iVertex{7})
	_, _ = d0.AddVertex(iVertex{8})
	v9ID, _ := d0.AddVertex(iVertex{9})

	_ = d0.AddEdge("1", "2")
	_ = d0.AddEdge("2", "3")
	_ = d0.AddEdge("2", "4")
	_ = d0.AddEdge("3", "5")
	_ = d0.AddEdge("4", "5")
	_ = d0.AddEdge("5", "6")
	_ = d0.AddEdge("6", "7")
	_ = d0.AddEdge("6", "8")

	// basic tests -- 2 children
	d, newId, err := d0.GetDescendantsGraph(v6ID)
	if err != nil {
		t.Error(err)
	}
	if d == nil {
		t.Error("GetDescendantsGraph(v6ID) returned nil")
	}
	if newId == "" {
		t.Error("GetDescendantsGraph(v6ID) returned empty new id")
	}
	if newId != v6ID {
		t.Errorf("GetDescendantsGraph(v6ID) returned new id %s, want %s", newId, v6ID)
	}
	if d.GetOrder() != 3 {
		t.Errorf("GetOrder() = %d, want 3", d.GetOrder())
	}
	if d.GetSize() != 2 {
		t.Errorf("GetSize() = %d, want 2", d.GetSize())
	}
	roots := d.GetRoots()
	if len(roots) != 1 {
		t.Errorf("len(GetRoots()) = %d, want 1", len(roots))
	}
	if _, exists := roots[newId]; !exists {
		t.Errorf("%s is not the root of the new graph", newId)
	}
	if v6 != roots[newId] {
		t.Errorf("wrong root got = %v, want %v", v6, roots[newId])
	}

	// test duplicates
	d2, newId2, err2 := d0.GetDescendantsGraph(v1ID)
	if err2 != nil {
		t.Error(err2)
	}
	if d2 == nil {
		t.Error("GetDescendantsGraph(v1ID) returned nil")
	}
	if newId2 == "" {
		t.Error("GetDescendantsGraph(v1ID) returned empty new id")
	}
	if newId2 != v1ID {
		t.Errorf("GetDescendantsGraph(v1ID) returned new id %s, want %s", newId2, v1ID)
	}
	newVertex, _ := d2.GetVertex(newId2)
	if v1 != newVertex {
		t.Errorf("want = %v, got %v", v1, newVertex)
	}
	if d2.GetOrder() != 8 {
		t.Errorf("GetOrder() = %d, want 3", d2.GetOrder())
	}
	if d2.GetSize() != 8 {
		t.Errorf("GetSize() = %d, want 8", d2.GetSize())
	}
	roots2 := d2.GetRoots()
	if len(roots2) != 1 {
		t.Errorf("len(GetRoots()) = %d, want 1", len(roots2))
	}
	if _, exists2 := roots2[newId2]; !exists2 {
		t.Errorf("%s is not the root of the new graph", newId2)
	}
	if v1 != roots2[newId2] {
		t.Errorf("wrong root got = %v, want %v", v1, roots2[newId2])
	}
	_, errGetUnknown := d2.GetVertex(v9ID)
	if errGetUnknown == nil {
		t.Errorf("GetVertex(v9ID) = nil, want %T", IDUnknownError{v9ID})
	}
	if _, ok := errGetUnknown.(IDUnknownError); !ok {
		t.Errorf("GetVertex(v9ID) expected IDUnknownError, got %T", errGetUnknown)
	}

	// nil
	_, _, errNil := d0.GetDescendantsGraph("")
	if errNil == nil {
		t.Errorf("GetDescendantsGraph(\"\") = nil, want %T", IDEmptyError{})
	}
	if _, ok := errNil.(IDEmptyError); !ok {
		t.Errorf("GetDescendantsGraph(\"\") expected IDEmptyError, got %T", errNil)
	}

	// unknown
	_, _, errUnknown := d0.GetDescendantsGraph("foo")
	if errUnknown == nil {
		t.Errorf("GetDescendantsGraph(\"foo\") = nil, want %T", IDUnknownError{"foo"})
	}
	if _, ok := errUnknown.(IDUnknownError); !ok {
		t.Errorf("GetDescendantsGraph(\"foo\") expected IDUnknownError, got %T", errUnknown)
	}
}

func TestDAG_GetAncestorsGraph(t *testing.T) {
	d0 := NewDAG()

	_, _ = d0.AddVertex(iVertex{1})
	_, _ = d0.AddVertex(iVertex{2})
	_, _ = d0.AddVertex(iVertex{3})
	_, _ = d0.AddVertex(iVertex{4})
	v5 := iVertex{5}
	v5ID, _ := d0.AddVertex(v5)
	_, _ = d0.AddVertex(iVertex{6})
	_, _ = d0.AddVertex(iVertex{7})
	_, _ = d0.AddVertex(iVertex{8})
	v9ID, _ := d0.AddVertex(iVertex{9})

	_ = d0.AddEdge("1", "2")
	_ = d0.AddEdge("2", "3")
	_ = d0.AddEdge("2", "4")
	_ = d0.AddEdge("3", "5")
	_ = d0.AddEdge("4", "5")
	_ = d0.AddEdge("5", "6")
	_ = d0.AddEdge("6", "7")
	_ = d0.AddEdge("6", "8")

	// basic tests -- 2 children
	d, newId, err := d0.GetAncestorsGraph(v5ID)
	if err != nil {
		t.Error(err)
	}
	if d == nil {
		t.Error("GetAncestorsGraph(v5ID) returned nil")
	}
	if newId == "" {
		t.Error("GetAncestorsGraph(v5ID) returned empty new id")
	}
	if newId != v5ID {
		t.Errorf("GetAncestorsGraph(v5ID) returned new id %s, want %s", newId, v5ID)
	}
	if d.GetOrder() != 5 {
		t.Errorf("GetOrder() = %d, want 5", d.GetOrder())
	}
	if d.GetSize() != 5 {
		t.Errorf("GetSize() = %d, want 5", d.GetSize())
	}
	roots := d.GetRoots()
	if len(roots) != 1 {
		t.Errorf("len(GetRoots()) = %d, want 1", len(roots))
	}
	leaves := d.GetLeaves()
	if len(leaves) != 1 {
		t.Errorf("len(GetRoots()) = %d, want 1", len(leaves))
	}
	if _, exists := leaves[newId]; !exists {
		t.Errorf("%s is not the leaves of the new graph", newId)
	}
	if v5 != leaves[newId] {
		t.Errorf("wrong leaf got = %v, want %v", v5, leaves[newId])
	}

	_, errGetUnknown := d.GetVertex(v9ID)
	if errGetUnknown == nil {
		t.Errorf("GetVertex(v9ID) = nil, want %T", IDUnknownError{v9ID})
	}
	if _, ok := errGetUnknown.(IDUnknownError); !ok {
		t.Errorf("GetVertex(v9ID) expected IDUnknownError, got %T", errGetUnknown)
	}

	// nil
	_, _, errNil := d0.GetAncestorsGraph("")
	if errNil == nil {
		t.Errorf("GetDescendantsGraph(\"\") = nil, want %T", IDEmptyError{})
	}
	if _, ok := errNil.(IDEmptyError); !ok {
		t.Errorf("GetDescendantsGraph(\"\") expected IDEmptyError, got %T", errNil)
	}

	// unknown
	_, _, errUnknown := d0.GetAncestorsGraph("foo")
	if errUnknown == nil {
		t.Errorf("GetDescendantsGraph(\"foo\") = nil, want %T", IDUnknownError{"foo"})
	}
	if _, ok := errUnknown.(IDUnknownError); !ok {
		t.Errorf("GetDescendantsGraph(\"foo\") expected IDUnknownError, got %T", errUnknown)
	}
}

func TestDAG_GetAncestors(t *testing.T) {
	dag := NewDAG()
	v0, _ := dag.AddVertex("0")
	v1, _ := dag.AddVertex("1")
	v2, _ := dag.AddVertex("2")
	v3, _ := dag.AddVertex("3")
	v4, _ := dag.AddVertex("4")
	v5, _ := dag.AddVertex("5")
	v6, _ := dag.AddVertex("6")
	v7, _ := dag.AddVertex("7")

	_ = dag.AddEdge(v1, v2)
	_ = dag.AddEdge(v2, v3)
	_ = dag.AddEdge(v2, v4)

	if ancestors, _ := dag.GetAncestors(v4); len(ancestors) != 2 {
		t.Errorf("GetAncestors(v4) = %d, want 2", len(ancestors))
	}
	if ancestors, _ := dag.GetAncestors(v3); len(ancestors) != 2 {
		t.Errorf("GetAncestors(v3) = %d, want 2", len(ancestors))
	}
	if ancestors, _ := dag.GetAncestors(v2); len(ancestors) != 1 {
		t.Errorf("GetAncestors(v2) = %d, want 1", len(ancestors))
	}
	if ancestors, _ := dag.GetAncestors(v1); len(ancestors) != 0 {
		t.Errorf("GetAncestors(v1) = %d, want 0", len(ancestors))
	}

	_ = dag.AddEdge(v3, v5)
	_ = dag.AddEdge(v4, v6)

	if ancestors, _ := dag.GetAncestors(v4); len(ancestors) != 2 {
		t.Errorf("GetAncestors(v4) = %d, want 2", len(ancestors))
	}
	if ancestors, _ := dag.GetAncestors(v7); len(ancestors) != 0 {
		t.Errorf("GetAncestors(v4) = %d, want 7", len(ancestors))
	}
	_ = dag.AddEdge(v5, v7)
	if ancestors, _ := dag.GetAncestors(v7); len(ancestors) != 4 {
		t.Errorf("GetAncestors(v7) = %d, want 4", len(ancestors))
	}
	_ = dag.AddEdge(v0, v1)
	if ancestors, _ := dag.GetAncestors(v7); len(ancestors) != 5 {
		t.Errorf("GetAncestors(v7) = %d, want 5", len(ancestors))
	}

	// nil
	_, errNil := dag.GetAncestors("")
	if errNil == nil {
		t.Errorf("GetAncestors(\"\") = nil, want %T", IDEmptyError{})
	}
	if _, ok := errNil.(IDEmptyError); !ok {
		t.Errorf("GetAncestors(\"\") expected IDEmptyError, got %T", errNil)
	}

	// unknown
	_, errUnknown := dag.GetAncestors("foo")
	if errUnknown == nil {
		t.Errorf("GetAncestors(\"foo\") = nil, want %T", IDUnknownError{"foo"})
	}
	if _, ok := errUnknown.(IDUnknownError); !ok {
		t.Errorf("GetAncestors(\"foo\") expected IDUnknownError, got %T", errUnknown)
	}

}

func TestDAG_GetOrderedAncestors(t *testing.T) {
	dag := NewDAG()
	v1, _ := dag.addVertex("1")
	v2, _ := dag.addVertex("2")
	v3, _ := dag.addVertex("3")
	v4, _ := dag.addVertex("4")
	_ = dag.AddEdge(v1, v2)
	_ = dag.AddEdge(v2, v3)
	_ = dag.AddEdge(v2, v4)

	if desc, _ := dag.GetOrderedAncestors(v4); len(desc) != 2 {
		t.Errorf("GetOrderedAncestors(v4) = %d, want 2", len(desc))
	}
	if desc, _ := dag.GetOrderedAncestors(v2); len(desc) != 1 {
		t.Errorf("GetOrderedAncestors(v2) = %d, want 1", len(desc))
	}
	if desc, _ := dag.GetOrderedAncestors(v1); len(desc) != 0 {
		t.Errorf("GetOrderedAncestors(v1) = %d, want 0", len(desc))
	}
	if desc, _ := dag.GetOrderedAncestors(v4); !equal(desc, []string{v2, v1}) {
		t.Errorf("GetOrderedAncestors(v4) = %v, want %v", desc, []interface{}{v2, v1})
	}

	// nil
	_, errNil := dag.GetOrderedAncestors("")
	if errNil == nil {
		t.Errorf("GetOrderedAncestors(\"\") = nil, want %T", IDEmptyError{})
	}
	if _, ok := errNil.(IDEmptyError); !ok {
		t.Errorf("GetOrderedAncestors(\"\") expected IDEmptyError, got %T", errNil)
	}

	// unknown
	_, errUnknown := dag.GetOrderedAncestors("foo")
	if errUnknown == nil {
		t.Errorf("GetOrderedAncestors(\"foo\") = nil, want %T", IDUnknownError{"foo"})
	}
	if _, ok := errUnknown.(IDUnknownError); !ok {
		t.Errorf("GetOrderedAncestors(\"foo\") expected IDUnknownError, got %T", errUnknown)
	}
}

func TestDAG_AncestorsWalker(t *testing.T) {
	dag := NewDAG()
	v1, _ := dag.AddVertex("1")
	v2, _ := dag.AddVertex("2")
	v3, _ := dag.AddVertex("3")
	v4, _ := dag.AddVertex("4")
	v5, _ := dag.AddVertex("5")
	v6, _ := dag.AddVertex("6")
	v7, _ := dag.AddVertex("7")
	v8, _ := dag.AddVertex("8")
	v9, _ := dag.AddVertex("9")
	v10, _ := dag.AddVertex("101")

	_ = dag.AddEdge(v1, v2)
	_ = dag.AddEdge(v1, v3)
	_ = dag.AddEdge(v2, v4)
	_ = dag.AddEdge(v2, v5)
	_ = dag.AddEdge(v4, v6)
	_ = dag.AddEdge(v5, v6)
	_ = dag.AddEdge(v6, v7)
	_ = dag.AddEdge(v7, v8)
	_ = dag.AddEdge(v7, v9)
	_ = dag.AddEdge(v8, v10)
	_ = dag.AddEdge(v9, v10)

	vertices, _, _ := dag.AncestorsWalker(v10)
	var ancestors []string
	for v := range vertices {
		ancestors = append(ancestors, v)
	}
	exp1 := []string{v9, v8, v7, v6, v4, v5, v2, v1}
	exp2 := []string{v8, v9, v7, v6, v4, v5, v2, v1}
	exp3 := []string{v9, v8, v7, v6, v5, v4, v2, v1}
	exp4 := []string{v8, v9, v7, v6, v5, v4, v2, v1}
	if !(equal(ancestors, exp1) || equal(ancestors, exp2) || equal(ancestors, exp3) || equal(ancestors, exp4)) {
		t.Errorf("AncestorsWalker(v10) = %v, want %v, %v, %v, or %v ", ancestors, exp1, exp2, exp3, exp4)
	}

	// nil
	_, _, errNil := dag.AncestorsWalker("")
	if errNil == nil {
		t.Errorf("AncestorsWalker(\"\") = nil, want %T", IDEmptyError{})
	}
	if _, ok := errNil.(IDEmptyError); !ok {
		t.Errorf("AncestorsWalker(\"\") expected IDEmptyError, got %T", errNil)
	}

	// unknown
	_, _, errUnknown := dag.AncestorsWalker("foo")
	if errUnknown == nil {
		t.Errorf("AncestorsWalker(\"foo\") = nil, want %T", IDUnknownError{"foo"})
	}
	if _, ok := errUnknown.(IDUnknownError); !ok {
		t.Errorf("AncestorsWalker(\"foo\") expected IDUnknownError, got %T", errUnknown)
	}
}

func TestDAG_AncestorsWalkerSignal(t *testing.T) {
	dag := NewDAG()

	v1, _ := dag.AddVertex("1")
	v2, _ := dag.AddVertex("2")
	v3, _ := dag.AddVertex("3")
	v4, _ := dag.AddVertex("4")
	v5, _ := dag.AddVertex("5")
	_ = dag.AddEdge(v1, v2)
	_ = dag.AddEdge(v2, v3)
	_ = dag.AddEdge(v2, v4)
	_ = dag.AddEdge(v4, v5)

	var ancestors []string
	vertices, signal, _ := dag.AncestorsWalker(v5)
	for v := range vertices {
		ancestors = append(ancestors, v)
		if v == v2 {
			signal <- true
			break
		}
	}
	if !equal(ancestors, []string{v4, v2}) {
		t.Errorf("AncestorsWalker(v4) = %v, want %v", ancestors, []string{v4, v2})
	}

}

func TestDAG_ReduceTransitively(t *testing.T) {
	dag := NewDAG()
	accountCreate, _ := dag.AddVertex("AccountCreate")
	projectCreate, _ := dag.AddVertex("ProjectCreate")
	networkCreate, _ := dag.AddVertex("NetworkCreate")
	contactCreate, _ := dag.AddVertex("ContactCreate")
	authCreate, _ := dag.AddVertex("AuthCreate")
	mailSend, _ := dag.AddVertex("MailSend")

	_ = dag.AddEdge(accountCreate, projectCreate)
	_ = dag.AddEdge(accountCreate, networkCreate)
	_ = dag.AddEdge(accountCreate, contactCreate)
	_ = dag.AddEdge(accountCreate, authCreate)
	_ = dag.AddEdge(accountCreate, mailSend)

	_ = dag.AddEdge(projectCreate, mailSend)
	_ = dag.AddEdge(networkCreate, mailSend)
	_ = dag.AddEdge(contactCreate, mailSend)
	_ = dag.AddEdge(authCreate, mailSend)

	if order := dag.GetOrder(); order != 6 {
		t.Errorf("GetOrder() = %d, want 6", order)
	}
	if size := dag.GetSize(); size != 9 {
		t.Errorf("GetSize() = %d, want 9", size)
	}
	if isEdge, _ := dag.IsEdge(accountCreate, mailSend); !isEdge {
		t.Errorf("IsEdge(accountCreate, mailSend) = %t, want %t", isEdge, true)
	}

	dag.ReduceTransitively()

	if order := dag.GetOrder(); order != 6 {
		t.Errorf("GetOrder() = %d, want 6", order)
	}
	if size := dag.GetSize(); size != 8 {
		t.Errorf("GetSize() = %d, want 8", size)
	}
	if isEdge, _ := dag.IsEdge(accountCreate, mailSend); isEdge {
		t.Errorf("IsEdge(accountCreate, mailSend) = %t, want %t", isEdge, false)
	}

	ordered, _ := dag.GetOrderedDescendants(accountCreate)
	length := len(ordered)
	if length != 5 {
		t.Errorf("length(ordered) = %d, want 5", length)
	}
	last := ordered[length-1]
	if last != mailSend {
		t.Errorf("ordered[length-1]) = %v, want %v", last, mailSend)
	}
}

func TestDAG_Copy(t *testing.T) {
	d0 := NewDAG()

	_, _ = d0.AddVertex(iVertex{1})
	_, _ = d0.AddVertex(iVertex{2})
	_, _ = d0.AddVertex(iVertex{3})
	_, _ = d0.AddVertex(iVertex{4})
	_, _ = d0.AddVertex(iVertex{5})
	_, _ = d0.AddVertex(iVertex{6})
	_, _ = d0.AddVertex(iVertex{7})
	_, _ = d0.AddVertex(iVertex{8})
	_, _ = d0.AddVertex(iVertex{9})

	_ = d0.AddEdge("1", "2")
	_ = d0.AddEdge("2", "3")
	_ = d0.AddEdge("2", "4")
	_ = d0.AddEdge("3", "5")
	_ = d0.AddEdge("4", "5")
	_ = d0.AddEdge("5", "6")
	_ = d0.AddEdge("6", "7")
	_ = d0.AddEdge("6", "8")

	d1, err := d0.Copy()
	if err != nil {
		t.Error(err)
	}
	if d1.GetOrder() != d0.GetOrder() {
		t.Errorf("got %d, want %d", d1.GetOrder(), d0.GetOrder())
	}
	if d1.GetSize() != d0.GetSize() {
		t.Errorf("got %d, want %d", d1.GetSize(), d0.GetSize())
	}
	if len(d1.GetRoots()) != len(d0.GetRoots()) {
		t.Errorf("got %d, want %d", len(d1.GetRoots()), len(d0.GetRoots()))
	}
	if len(d1.GetLeaves()) != len(d0.GetLeaves()) {
		t.Errorf("got %d, want %d", len(d1.GetLeaves()), len(d0.GetLeaves()))
	}
	for i := 1; i < 9; i++ {
		v1, errGet1 := d1.GetVertex(strconv.Itoa(i))
		if errGet1 != nil {
			t.Error(errGet1)
		}
		v2, errGet2 := d1.GetVertex(strconv.Itoa(i))
		if errGet2 != nil {
			t.Error(errGet2)
		}
		if v2 != v1 {
			t.Errorf("got %v, want %v", v2, v1)
		}
	}
}

func TestDAG_String(t *testing.T) {
	dag := NewDAG()
	v1, _ := dag.AddVertex("1")
	v2, _ := dag.AddVertex("2")
	v3, _ := dag.AddVertex("3")
	v4, _ := dag.AddVertex("4")
	_ = dag.AddEdge(v1, v2)
	_ = dag.AddEdge(v2, v3)
	_ = dag.AddEdge(v2, v4)
	expected := "DAG Vertices: 4 - Edges: 3"
	s := dag.String()
	if s[:len(expected)] != expected {
		t.Errorf("String() = \"%s\", want \"%s\"", s, expected)
	}
}

func TestErrors(t *testing.T) {

	tests := []struct {
		want string
		err  error
	}{
		{"don't know what to do with \"\"", IDEmptyError{}},
		{"'1' is already known", VertexDuplicateError{"1"}},
		{"'1' is unknown", IDUnknownError{"1"}},
		{"edge between '1' and '2' is already known", EdgeDuplicateError{"1", "2"}},
		{"edge between '1' and '2' is unknown", EdgeUnknownError{"1", "2"}},
		{"edge between '1' and '2' would create a loop", EdgeLoopError{"1", "2"}},
	}
	for _, tt := range tests {
		t.Run(fmt.Sprintf("%T", tt.err), func(t *testing.T) {
			if got := tt.err.Error(); got != tt.want {
				t.Errorf("Error() = %v, want %v", got, tt.want)
			}
		})
	}
}

func ExampleDAG_AncestorsWalker() {
	dag := NewDAG()

	v1, _ := dag.AddVertex(iVertex{1})
	v2, _ := dag.AddVertex(iVertex{2})
	v3, _ := dag.AddVertex(iVertex{3})
	v4, _ := dag.AddVertex(iVertex{4})
	v5, _ := dag.AddVertex(iVertex{5})
	_ = dag.AddEdge(v1, v2)
	_ = dag.AddEdge(v2, v3)
	_ = dag.AddEdge(v2, v4)
	_ = dag.AddEdge(v4, v5)

	var ancestors []interface{}
	vertices, signal, _ := dag.AncestorsWalker(v5)
	for v := range vertices {
		ancestors = append(ancestors, v)
		if v == v2 {
			signal <- true
			break
		}
	}
	fmt.Printf("%v", ancestors)

	// Output:
	//   [4 2]
}

func TestLarge(t *testing.T) {
	d := NewDAG()
	root := iVertex{1}
	id, _ := d.addVertex(root)
	levels := 7
	branches := 8

	expectedVertexCount, _ := largeAux(d, levels, branches, root)
	expectedVertexCount++
	vertexCount := len(d.GetVertices())
	if vertexCount != expectedVertexCount {
		t.Errorf("GetVertices() = %d, want %d", vertexCount, expectedVertexCount)
	}

	descendants, _ := d.GetDescendants(id)
	descendantsCount := len(descendants)
	expectedDescendantsCount := vertexCount - 1
	if descendantsCount != expectedDescendantsCount {
		t.Errorf("GetDescendants(root) = %d, want %d", descendantsCount, expectedDescendantsCount)
	}

	_, _ = d.GetDescendants(id)

	children, _ := d.GetChildren(id)
	childrenCount := len(children)
	expectedChildrenCount := branches
	if childrenCount != expectedChildrenCount {
		t.Errorf("GetChildren(root) = %d, want %d", childrenCount, expectedChildrenCount)
	}

	/*
		var childList []interface{}
		for x := range children {
			childList = append(childList, x)
		}
		_ = d.DeleteEdge(root, childList[0])
	*/
}

func largeAux(d *DAG, level int, branches int, parent iVertex) (int, int) {
	var vertexCount int
	var edgeCount int
	if level > 1 {
		if branches < 1 || branches > 9 {
			panic("number of branches must be between 1 and 9")
		}
		for i := 1; i <= branches; i++ {
			value := parent.value*10 + i
			child := iVertex{value}
			childID, _ := d.AddVertex(child)
			vertexCount++
			err := d.AddEdge(parent.ID(), childID)
			edgeCount++
			if err != nil {
				panic(err)
			}
			childVertexCount, childEdgeCount := largeAux(d, level-1, branches, child)
			vertexCount += childVertexCount
			edgeCount += childEdgeCount
		}
	}
	return vertexCount, edgeCount
}

'''
'''--- example_basic_test.go ---
package dag_test

import (
	"fmt"
	"github.com/nearprime/dag"
)

type foobar struct {
	a string
	b string
}

func Example() {

	// initialize a new graph
	d := dag.NewDAG()

	// init three vertices
	v1, _ := d.AddVertex(1)
	v2, _ := d.AddVertex(2)
	v3, _ := d.AddVertex(foobar{a: "foo", b: "bar"})

	// add the above vertices and connect them with two edges
	_ = d.AddEdge(v1, v2)
	_ = d.AddEdge(v1, v3)

	// describe the graph
	fmt.Print(d.String())

	// Unordered output:
	// DAG Vertices: 3 - Edges: 2
	// Vertices:
	//   1
	//   2
	//   {foo bar}
	// Edges:
	//   1 -> 2
	//   1 -> {foo bar}
}

'''
'''--- example_descandentsFlow_test.go ---
package dag_test

import (
	"fmt"
	"github.com/nearprime/dag"
	"sort"
)

func ExampleDAG_DescendantsFlow() {
	// Initialize a new graph.
	d := dag.NewDAG()

	// Init vertices.
	v0, _ := d.AddVertex(0)
	v1, _ := d.AddVertex(1)
	v2, _ := d.AddVertex(2)
	v3, _ := d.AddVertex(3)
	v4, _ := d.AddVertex(4)

	// Add the above vertices and connect them.
	_ = d.AddEdge(v0, v1)
	_ = d.AddEdge(v0, v3)
	_ = d.AddEdge(v1, v2)
	_ = d.AddEdge(v2, v4)
	_ = d.AddEdge(v3, v4)

	//   0
	// ┌─┴─┐
	// 1   │
	// │   3
	// 2   │
	// └─┬─┘
	//   4

	// The callback function adds its own value (ID) to the sum of parent results.
	flowCallback := func(d *dag.DAG, id string, parentResults []dag.FlowResult) (interface{}, error) {

		v, _ := d.GetVertex(id)
		result, _ := v.(int)
		var parents []int
		for _, r := range parentResults {
			p, _ := d.GetVertex(r.ID)
			parents = append(parents, p.(int))
			result += r.Result.(int)
		}
		sort.Ints(parents)
		fmt.Printf("%v based on: %+v returns: %d\n", v, parents, result)
		return result, nil
	}

	_, _ = d.DescendantsFlow(v0, nil, flowCallback)

	// Unordered output:
	// 0 based on: [] returns: 0
	// 1 based on: [0] returns: 1
	// 3 based on: [0] returns: 3
	// 2 based on: [1] returns: 3
	// 4 based on: [2 3] returns: 10
}

'''
'''--- example_idinterface_test.go ---
package dag_test

import (
	"fmt"
	"github.com/nearprime/dag"
)

type idVertex struct {
	id  string
	msg string
}

func (v idVertex) ID() string {
	return v.id
}

func ExampleIDInterface() {

	// initialize a new graph
	d := dag.NewDAG()

	// init three vertices
	id, _ := d.AddVertex(idVertex{id: "1", msg: "foo"})
	fmt.Printf("id of vertex is %s\n", id)
	v, _ := d.GetVertex(id)
	fmt.Printf("%s", v)

	// Output:
	// id of vertex is 1
	// {1 foo}
}

'''
'''--- marshal.go ---
package dag

import (
	"encoding/json"
	"errors"
)

// MarshalJSON returns the JSON encoding of DAG.
//
// It traverses the DAG using the Depth-First-Search algorithm
// and uses an internal structure to store vertices and edges.
func (d *DAG) MarshalJSON() ([]byte, error) {
	mv := newMarshalVisitor(d)
	d.DFSWalk(mv)
	return json.Marshal(mv.storableDAG)
}

// UnmarshalJSON is an informative method. See the UnmarshalJSON function below.
func (d *DAG) UnmarshalJSON(_ []byte) error {
	return errors.New("this method is not supported, request function UnmarshalJSON instead")
}

// UnmarshalJSON parses the JSON-encoded data that defined by StorableDAG.
// It returns a new DAG defined by the vertices and edges of wd.
// If the internal structure of data and wd do not match,
// then deserialization will fail and return json error.
//
// Because the vertex data passed in by the user is an interface{},
// it does not indicate a specific structure, so it cannot be deserialized.
// And this function needs to pass in a clear DAG structure.
//
// Example:
// dag := NewDAG()
// data, err := json.Marshal(d)
// if err != nil {
//     panic(err)
// }
// var wd YourStorableDAG
// restoredDag, err := UnmarshalJSON(data, &wd)
// if err != nil {
//     panic(err)
// }
//
// For more specific information please read the test code.
func UnmarshalJSON(data []byte, wd StorableDAG) (*DAG, error) {
	err := json.Unmarshal(data, &wd)
	if err != nil {
		return nil, err
	}
	dag := NewDAG()
	for _, v := range wd.Vertices() {
		errVertex := dag.AddVertexByID(v.Vertex())
		if errVertex != nil {
			return nil, errVertex
		}
	}
	for _, e := range wd.Edges() {
		errEdge := dag.AddEdge(e.Edge())
		if errEdge != nil {
			return nil, errEdge
		}
	}
	return dag, nil
}

type marshalVisitor struct {
	d *DAG
	storableDAG
}

func newMarshalVisitor(d *DAG) *marshalVisitor {
	return &marshalVisitor{d: d}
}

func (mv *marshalVisitor) Visit(v Vertexer) {
	mv.StorableVertices = append(mv.StorableVertices, v)

	srcID, _ := v.Vertex()
	// Why not use Mutex here?
	// Because at the time of Walk,
	// the read lock has been used to protect the dag.
	children, _ := mv.d.getChildren(srcID)
	ids := vertexIDs(children)
	for _, dstID := range ids {
		e := storableEdge{SrcID: srcID, DstID: dstID}
		mv.StorableEdges = append(mv.StorableEdges, e)
	}
}

'''
'''--- marshal_test.go ---
package dag

import (
	"encoding/json"
	"testing"

	"github.com/go-test/deep"
)

func TestMarshalUnmarshalJSON(t *testing.T) {
	cases := []struct {
		dag      *DAG
		expected string
	}{
		{
			dag:      getTestWalkDAG(),
			expected: `{"vs":[{"i":"1","v":"v1"},{"i":"2","v":"v2"},{"i":"3","v":"v3"},{"i":"4","v":"v4"},{"i":"5","v":"v5"}],"es":[{"s":"1","d":"2"},{"s":"2","d":"3"},{"s":"2","d":"4"},{"s":"4","d":"5"}]}`,
		},
		{
			dag:      getTestWalkDAG2(),
			expected: `{"vs":[{"i":"1","v":"v1"},{"i":"3","v":"v3"},{"i":"5","v":"v5"},{"i":"2","v":"v2"},{"i":"4","v":"v4"}],"es":[{"s":"1","d":"3"},{"s":"3","d":"5"},{"s":"2","d":"3"},{"s":"4","d":"5"}]}`,
		},
		{
			dag:      getTestWalkDAG3(),
			expected: `{"vs":[{"i":"1","v":"v1"},{"i":"3","v":"v3"},{"i":"2","v":"v2"},{"i":"4","v":"v4"},{"i":"5","v":"v5"}],"es":[{"s":"1","d":"3"},{"s":"2","d":"3"},{"s":"4","d":"5"}]}`,
		},
		{
			dag:      getTestWalkDAG4(),
			expected: `{"vs":[{"i":"1","v":"v1"},{"i":"2","v":"v2"},{"i":"3","v":"v3"},{"i":"5","v":"v5"},{"i":"4","v":"v4"}],"es":[{"s":"1","d":"2"},{"s":"2","d":"3"},{"s":"2","d":"4"},{"s":"3","d":"5"}]}`,
		},
	}

	for _, c := range cases {
		testMarshalUnmarshalJSON(t, c.dag, c.expected)
	}
}

func testMarshalUnmarshalJSON(t *testing.T, d *DAG, expected string) {
	data, err := json.Marshal(d)
	if err != nil {
		t.Error(err)
	}

	actual := string(data)
	if deep.Equal(expected, actual) != nil {
		t.Errorf("Marshal() = %v, want %v", actual, expected)
	}

	d1 := &DAG{}
	errNotSupported := json.Unmarshal(data, d1)
	if errNotSupported == nil {
		t.Errorf("UnmarshalJSON() = nil, want %v", "This method is not supported")
	}

	var wd testStorableDAG
	dag, err := UnmarshalJSON(data, &wd)
	if err != nil {
		t.Fatal(err)
	}
	if deep.Equal(d, dag) != nil {
		t.Errorf("UnmarshalJSON() = %v, want %v", dag.String(), d.String())
	}
}

'''
'''--- storage.go ---
package dag

var (
	_ Vertexer    = (*storableVertex)(nil)
	_ Edger       = (*storableEdge)(nil)
	_ StorableDAG = (*storableDAG)(nil)
	_ IDInterface = (*storableVertex)(nil)
)

// Vertexer is the interface that wraps the basic Vertex method.
// Vertex returns an id that identifies this vertex and the value of this vertex.
//
// The reason for defining this new structure is that the vertex id may be
// automatically generated when the caller adds a vertex. At this time, the
// vertex structure added by the user does not contain id information.
type Vertexer interface {
	Vertex() (id string, value interface{})
}

// Edger is the interface that wraps the basic Edge method.
// Edge returns the ids of two vertices that connect an edge.
type Edger interface {
	Edge() (srcID, dstID string)
}

// StorableDAG is the interface that defines a DAG that can be stored.
// It provides methods to get all vertices and all edges of a DAG.
type StorableDAG interface {
	Vertices() []Vertexer
	Edges() []Edger
}

// storableVertex implements the Vertexer interface.
// It is implemented as a storable structure.
// And it uses short json tag to reduce the number of bytes after serialization.
type storableVertex struct {
	WrappedID string      `json:"i"`
	Value     interface{} `json:"v"`
}

func (v storableVertex) Vertex() (id string, value interface{}) {
	return v.WrappedID, v.Value
}

func (v storableVertex) ID() string {
	return v.WrappedID
}

// storableEdge implements the Edger interface.
// It is implemented as a storable structure.
// And it uses short json tag to reduce the number of bytes after serialization.
type storableEdge struct {
	SrcID string `json:"s"`
	DstID string `json:"d"`
}

func (e storableEdge) Edge() (srcID, dstID string) {
	return e.SrcID, e.DstID
}

// storableDAG implements the StorableDAG interface.
// It acts as a serializable operable structure.
// And it uses short json tag to reduce the number of bytes after serialization.
type storableDAG struct {
	StorableVertices []Vertexer `json:"vs"`
	StorableEdges    []Edger    `json:"es"`
}

func (g storableDAG) Vertices() []Vertexer {
	return g.StorableVertices
}

func (g storableDAG) Edges() []Edger {
	return g.StorableEdges
}

'''
'''--- storage_test.go ---
package dag

type testVertex struct {
	WID string `json:"i"`
	Val string `json:"v"`
}

func (tv testVertex) ID() string {
	return tv.WID
}

func (tv testVertex) Vertex() (id string, value interface{}) {
	return tv.WID, tv.Val
}

type testStorableDAG struct {
	StorableVertices []testVertex   `json:"vs"`
	StorableEdges    []storableEdge `json:"es"`
}

func (g testStorableDAG) Vertices() []Vertexer {
	l := make([]Vertexer, 0, len(g.StorableVertices))
	for _, v := range g.StorableVertices {
		l = append(l, v)
	}
	return l
}

func (g testStorableDAG) Edges() []Edger {
	l := make([]Edger, 0, len(g.StorableEdges))
	for _, v := range g.StorableEdges {
		l = append(l, v)
	}
	return l
}

'''
'''--- visitor.go ---
package dag

import (
	"sort"

	llq "github.com/emirpasic/gods/queues/linkedlistqueue"
	lls "github.com/emirpasic/gods/stacks/linkedliststack"
)

// Visitor is the interface that wraps the basic Visit method.
// It can use the Visitor and XXXWalk functions together to traverse the entire DAG.
// And access per-vertex information when traversing.
type Visitor interface {
	Visit(Vertexer)
}

// DFSWalk implements the Depth-First-Search algorithm to traverse the entire DAG.
// The algorithm starts at the root node and explores as far as possible
// along each branch before backtracking.
func (d *DAG) DFSWalk(visitor Visitor) {
	d.muDAG.RLock()
	defer d.muDAG.RUnlock()

	stack := lls.New()

	vertices := d.getRoots()
	for _, id := range reversedVertexIDs(vertices) {
		v := vertices[id]
		sv := storableVertex{WrappedID: id, Value: v}
		stack.Push(sv)
	}

	visited := make(map[string]bool, d.getSize())

	for !stack.Empty() {
		v, _ := stack.Pop()
		sv := v.(storableVertex)

		if !visited[sv.WrappedID] {
			visited[sv.WrappedID] = true
			visitor.Visit(sv)
		}

		vertices, _ := d.getChildren(sv.WrappedID)
		for _, id := range reversedVertexIDs(vertices) {
			v := vertices[id]
			sv := storableVertex{WrappedID: id, Value: v}
			stack.Push(sv)
		}
	}
}

// BFSWalk implements the Breadth-First-Search algorithm to traverse the entire DAG.
// It starts at the tree root and explores all nodes at the present depth prior
// to moving on to the nodes at the next depth level.
func (d *DAG) BFSWalk(visitor Visitor) {
	d.muDAG.RLock()
	defer d.muDAG.RUnlock()

	queue := llq.New()

	vertices := d.getRoots()
	for _, id := range vertexIDs(vertices) {
		v := vertices[id]
		sv := storableVertex{WrappedID: id, Value: v}
		queue.Enqueue(sv)
	}

	visited := make(map[string]bool, d.getOrder())

	for !queue.Empty() {
		v, _ := queue.Dequeue()
		sv := v.(storableVertex)

		if !visited[sv.WrappedID] {
			visited[sv.WrappedID] = true
			visitor.Visit(sv)
		}

		vertices, _ := d.getChildren(sv.WrappedID)
		for _, id := range vertexIDs(vertices) {
			v := vertices[id]
			sv := storableVertex{WrappedID: id, Value: v}
			queue.Enqueue(sv)
		}
	}
}

func vertexIDs(vertices map[string]interface{}) []string {
	ids := make([]string, 0, len(vertices))
	for id := range vertices {
		ids = append(ids, id)
	}
	sort.Strings(ids)
	return ids
}

func reversedVertexIDs(vertices map[string]interface{}) []string {
	ids := vertexIDs(vertices)
	i, j := 0, len(ids)-1
	for i < j {
		ids[i], ids[j] = ids[j], ids[i]
		i++
		j--
	}
	return ids
}

'''
'''--- visitor_test.go ---
package dag

import (
	"testing"

	"github.com/go-test/deep"
)

type testVisitor struct {
	Values []string
}

func (pv *testVisitor) Visit(v Vertexer) {
	_, value := v.Vertex()
	pv.Values = append(pv.Values, value.(string))
}

// schematic diagram:
//     v5
//     ^
//     |
//     v4
//     ^
//     |
//     v2 --> v3
//     ^
//     |
//     v1
func getTestWalkDAG() *DAG {
	dag := NewDAG()

	v1, v2, v3, v4, v5 := "1", "2", "3", "4", "5"
	_ = dag.AddVertexByID(v1, "v1")
	_ = dag.AddVertexByID(v2, "v2")
	_ = dag.AddVertexByID(v3, "v3")
	_ = dag.AddVertexByID(v4, "v4")
	_ = dag.AddVertexByID(v5, "v5")
	_ = dag.AddEdge(v1, v2)
	_ = dag.AddEdge(v2, v3)
	_ = dag.AddEdge(v2, v4)
	_ = dag.AddEdge(v4, v5)

	return dag
}

// schematic diagram:
//    v4 --> v5
//           ^
//           |
//    v1 --> v3
//           ^
//           |
//          v2
func getTestWalkDAG2() *DAG {
	dag := NewDAG()

	v1, v2, v3, v4, v5 := "1", "2", "3", "4", "5"
	_ = dag.AddVertexByID(v1, "v1")
	_ = dag.AddVertexByID(v2, "v2")
	_ = dag.AddVertexByID(v3, "v3")
	_ = dag.AddVertexByID(v4, "v4")
	_ = dag.AddVertexByID(v5, "v5")
	_ = dag.AddEdge(v1, v3)
	_ = dag.AddEdge(v2, v3)
	_ = dag.AddEdge(v3, v5)
	_ = dag.AddEdge(v4, v5)

	return dag
}

// schematic diagram:
//    v4 --> v5
//
//
//    v1 --> v3
//           ^
//           |
//          v2
func getTestWalkDAG3() *DAG {
	dag := NewDAG()

	v1, v2, v3, v4, v5 := "1", "2", "3", "4", "5"
	_ = dag.AddVertexByID(v1, "v1")
	_ = dag.AddVertexByID(v2, "v2")
	_ = dag.AddVertexByID(v3, "v3")
	_ = dag.AddVertexByID(v4, "v4")
	_ = dag.AddVertexByID(v5, "v5")
	_ = dag.AddEdge(v1, v3)
	_ = dag.AddEdge(v2, v3)
	_ = dag.AddEdge(v4, v5)

	return dag
}

// schematic diagram:
//     v4     v5
//     ^      ^
//     |      |
//     v2 --> v3
//     ^
//     |
//     v1
func getTestWalkDAG4() *DAG {
	dag := NewDAG()

	v1, v2, v3, v4, v5 := "1", "2", "3", "4", "5"
	_ = dag.AddVertexByID(v1, "v1")
	_ = dag.AddVertexByID(v2, "v2")
	_ = dag.AddVertexByID(v3, "v3")
	_ = dag.AddVertexByID(v4, "v4")
	_ = dag.AddVertexByID(v5, "v5")
	_ = dag.AddEdge(v1, v2)
	_ = dag.AddEdge(v2, v3)
	_ = dag.AddEdge(v3, v5)
	_ = dag.AddEdge(v2, v4)

	return dag
}

func TestDFSWalk(t *testing.T) {
	cases := []struct {
		dag      *DAG
		expected []string
	}{
		{
			dag:      getTestWalkDAG(),
			expected: []string{"v1", "v2", "v3", "v4", "v5"},
		},
		{
			dag:      getTestWalkDAG2(),
			expected: []string{"v1", "v3", "v5", "v2", "v4"},
		},
		{
			dag:      getTestWalkDAG3(),
			expected: []string{"v1", "v3", "v2", "v4", "v5"},
		},
		{
			dag:      getTestWalkDAG4(),
			expected: []string{"v1", "v2", "v3", "v5", "v4"},
		},
	}

	for _, c := range cases {
		pv := &testVisitor{}
		c.dag.DFSWalk(pv)

		expected := c.expected
		actual := pv.Values
		if deep.Equal(expected, actual) != nil {
			t.Errorf("DFSWalk() = %v, want %v", actual, expected)
		}
	}
}

func TestBFSWalk(t *testing.T) {
	cases := []struct {
		dag      *DAG
		expected []string
	}{
		{
			dag:      getTestWalkDAG(),
			expected: []string{"v1", "v2", "v3", "v4", "v5"},
		},
		{
			dag:      getTestWalkDAG2(),
			expected: []string{"v1", "v2", "v4", "v3", "v5"},
		},
		{
			dag:      getTestWalkDAG3(),
			expected: []string{"v1", "v2", "v4", "v3", "v5"},
		},
		{
			dag:      getTestWalkDAG4(),
			expected: []string{"v1", "v2", "v3", "v4", "v5"},
		},
	}

	for _, c := range cases {
		pv := &testVisitor{}
		c.dag.BFSWalk(pv)

		expected := c.expected
		actual := pv.Values
		if deep.Equal(expected, actual) != nil {
			t.Errorf("BFSWalk() = %v, want %v", actual, expected)
		}
	}
}

'''