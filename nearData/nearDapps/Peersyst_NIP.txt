*GitHub Repository "Peersyst/NIP"*

'''--- CODE_OF_CONDUCT.md ---
# Contributor Covenant Code of Conduct

## Our Pledge

In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.

## Our Standards

Examples of behavior that contributes to creating a positive environment include:

* Using welcoming and inclusive language
* Being respectful of differing viewpoints and experiences
* Gracefully accepting constructive criticism
* Focusing on what is best for the community
* Showing empathy towards other community members

Examples of unacceptable behavior by participants include:

* The use of sexualized language or imagery and unwelcome sexual attention or advances
* Trolling, insulting/derogatory comments, and personal or political attacks
* Public or private harassment
* Publishing others' private information, such as a physical or electronic address, without explicit permission
* Other conduct which could reasonably be considered inappropriate in a professional setting

## Our Responsibilities

Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.

Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.

## Scope

This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.

## Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at <info@nemfoundation.io>. The project team will review and investigate all complaints, and will respond in a way that it deems appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.

Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.

## Attribution

This Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4, available at [http://contributor-covenant.org/version/1/4][version]

[homepage]: http://contributor-covenant.org
[version]: http://contributor-covenant.org/version/1/4/

'''
'''--- ISSUE_TEMPLATE.md ---
# NIP-XX - NIP Title

This document is provided as a template to get you started. Feel free to add, augment, remove, restructure and otherwise adapt the structure for what you need after cloning it.

## Summary

Each NIP must begin with an RFC 822 style header preamble. The headers must appear in the following order. Headers marked with "*" are optional and are described below. All other headers are required. (delete this before publish)

```
    NIP: <NIP number, or "?" before being assigned>
    * Layer: <Core Layer | API/WS | SDK | Applications | Library>
    Title: <NIP title; maximum 44 characters>
    Author: <list of authors' real names and email addresses>
    * Discussions-To: <telegram group>
    * Comments-Summary: <summary tone>
    Comments-URI: <links to issue page for comments>
    Status: <Draft | Active | Proposed | Deferred | Rejected |
            Withdrawn | Final | Replaced | Obsolete>
    Type: <Standards Track | Informational | Process>
    Created: <date created on, in ISO 8601 (yyyy-mm-dd) format>
    License: <abbreviation for approved license(s)>
    * License-Code: <abbreviation for code under different approved license(s)>
    * Post-History: <dates of postings to NEM mailing list, or link to thread in mailing list archive>
    * Requires: <NIP number(s)>
    * Replaces: <NIP number>
    * Superseded-By: <NIP number>
```

## Introduction/Abstract

: required

(feel free to rename this section to Introduction, Motivation, Abstract, whatever best suits your proposal.)

A high level overview of the proposal.

- Description / Scope
- An explanation of the reason it's needed

A short (~200 word) description of the technical issue being addressed.

## Specification

: required

The technical specification should describe the syntax and semantics of any new feature. The specification should be detailed enough to allow competing, interoperable implementations for any of the current components.

## Motivation

: required

 The motivation is critical for NIPs that want to change NEM components. It should clearly explain why the existing component is inadequate to address the problem that the NIP solves.

## Design Decisions

: required

Discuss design decisions (including, as examples):

- Reason about correctness of the implementation.
- "Feel and fit" with existing core libraries.
- Performance and threading considerations.
- Potential conflicts with existing libraries, e.g. name clashes, IDE auto-import friction, etc.

The rationale fleshes out the specification by describing what motivated the design and why particular design decisions were made. It should describe alternate designs that were considered and related work. The rationale should provide evidence of consensus within the community and discuss important objections or concerns raised during discussion.

## Implementation

: required

The reference implementation must be completed before any NIP is given status "Final", but it need not be completed before the NIP is accepted. It is better to finish the specification and rationale first and reach consensus on it before writing code. The final implementation must include test code and documentation appropriate for the NEM component.

Include the following:

- GitHub repository with the implementation
- Test cases

## Backwards compatibility

: optional

All NIPs that introduce backwards incompatibilities must include a section describing these incompatibilities and their severity. The NIP must explain how the author proposes to deal with these incompatibilities.

## Drawbacks

: required

Why should we not do this. Be honest, these questions will come out during the process anyway so it’s better to get them out up front.

## Alternatives

: optional

- What other possibilities have been examined?
- What is the impact of not implementing this proposal?

## References

: required

## History

| **Date**      | **Version**   |
| ------------- | ------------- |
| Jan 1 2018    | Initial Draft |

'''
'''--- NIPs/nip-0001.md ---
# NIP 1 - NIP Process

```
    NIP: 1
    Title: NIP Process
    Author: Aleix <aleix@nemeurope.eu>
    Comments-URI: https://github.com/nemtech/NIP/issues/18
    Status: Active
    Type: Process
    Created: 2018-01-07
    License: BSD-2-Clause
```

## Table of contents

- [Abstract](#abstract)
- [Copyright](#copyright)
- [NIP workflow](#nip-workflow)
  * [Transferring NIP Ownership](#transferring-nip-ownership)
  * [NIP Editor](#nip-editor)
  * [NIP Editor Responsibilities & Workflow](#nip-editor-responsibilities---workflow)
- [NIP format and structure](#nip-format-and-structure)
  * [Specification](#specification)
    + [NIP header preamble](#nip-header-preamble)
    + [Auxiliary Files](#auxiliary-files)
- [NIP types](#nip-types)
- [NIP status field](#nip-status-field)
  * [Specification](#specification-1)
  * [Structure of the process](#structure-of-the-process)
    + [The NIP Author(s)](#the-nip-author-s-)
    + [The NIP Editor](#the-nip-editor)
    + [The PMC](#the-pmc)
    + [Reviewers](#reviewers)
    + [Voting](#voting)
    + [Responsibilities of the members](#responsibilities-of-the-members)
    + [Guests](#guests)
- [NIP licensing](#nip-licensing)
  * [Specification](#specification-2)
    + [Recommended licenses](#recommended-licenses)
    + [Not recommended, but acceptable licenses](#not-recommended--but-acceptable-licenses)
    + [Not acceptable licenses](#not-acceptable-licenses)
  * [Rationale](#rationale)
- [History](#history)

## Abstract

A NEM Improvement Proposal (NIP) is a design document providing information to the NEM community, or describing a new feature for NEM or its processes or environment. The NIP should provide a concise technical specification of the feature and a rationale for the feature.

We intend NIPs to be the primary mechanisms for proposing new features, for collecting community input on an issue, and for documenting the design decisions that have gone into NEM. The NIP author is responsible for building consensus within the community and documenting dissenting opinions.

Because the NIPs are maintained as text files in a versioned repository, their revision history is the historical record of the feature proposal.

This particular NIP replaces NIP 1 with a more well-defined and clear process.

## Copyright

This NIP is dual-licensed under the Open Publication License and BSD 2-clause license.

## NIP workflow

The NIP process begins with a new idea for NEM. Each potential NIP must have a author -- someone who writes the NIP using the style and format described below, shepherds the discussions in the appropriate forums, and attempts to build community consensus around the idea. The NIP author should first attempt to ascertain whether the idea is NIP-able.
Small enhancements or patches to a particular piece of software often don't require standardisation between multiple projects; these don't need a NIP and should be injected into the relevant project-specific development workflow with a patch submission to the applicable issue tracker.
The first step should be to search past discussions to see if an idea has been considered before, and if so, what issues arose in its progression.
After investigating past work, the best way to proceed is by posting about the new idea to the [NEM2 Slack Group][nem-improvement-process-slack], #nip channel.

Vetting an idea publicly before going as far as writing a NIP is meant to save both the potential author and the wider community time.
Asking the NEM community first if an idea is original helps prevent too much time being spent on something that is guaranteed to be rejected based on prior discussions (searching the internet does not always do the trick).
It also helps to make sure the idea is applicable to the entire community and not just the author. Just because an idea sounds good to the author does not mean it will work for most people in most areas where NEM is used.

Once the author has asked the NEM community as to whether an idea has any chance of acceptance, a draft NIP should be presented as new issue at [NIPs/issues][nips-issues].
This gives the author a chance to flesh out the draft NIP to make it properly formatted, of high quality, and to address additional concerns about the proposal.
Following a discussion, the proposal should be submitted to the [NIPs git repository][nips-repository] as a pull request.
This draft must be written in NIP style as described below, and named with an alias such as "NIP-johndoe-newfeaturetitle" until the editor has assigned it a NIP number (authors MUST NOT self-assign NIP numbers).

NIP authors are responsible for collecting community feedback on both the initial idea and the NIP before submitting it for review. However, wherever possible, long open-ended discussions on public slack groups should be avoided. Strategies to keep the discussions efficient include: setting up a different slack group channel, having the NIP author accept private comments in the early design phases, setting up a wiki page or git repository, etc. NIP authors should use their discretion here.

It is highly recommended that a single NIP contain a single key proposal or new idea. The more focused the NIP, the more successful it tends to be. If in doubt, split your NIP into several well-focused ones.

When the NIP draft is complete, the NIP editor will assign the NIP a number, label it as Standards Track, Informational, or Process, and merge the pull request to the NIPs git repository.
The NIP editor will not unreasonably reject a NIP.
Reasons for rejecting NIPs include duplication of effort, disregard for formatting rules, being too unfocused or too broad, being technically unsound, not providing proper motivation or addressing backwards compatibility, or not in keeping with the NEM philosophy.
For a NIP to be accepted it must meet certain minimum criteria.
It must be a clear and complete description of the proposed enhancement.
The enhancement must represent a net improvement.
The proposed implementation, if applicable, must be solid and must not complicate the component unduly.

The NIP author may update the draft as necessary in the git repository. Updates to drafts should also be submitted by the author as pull requests.

### Transferring NIP Ownership

It occasionally becomes necessary to transfer ownership of NIPs to a new author. In general, we'd like to retain the original author as a co-author of the transferred NIP, but that's really up to the original author. A good reason to transfer ownership is because the original author no longer has the time or interest in updating it or following through with the NIP process, or has fallen off the face of the 'net (i.e. is unreachable or not responding to email). A bad reason to transfer ownership is because you don't agree with the direction of the NIP. We try to build consensus around a NIP, but if that's not possible, you can always submit a competing NIP.

If you are interested in assuming ownership of a NIP, send a message asking to take over, addressed to both the original author and the NIP editor. If the original author doesn't respond to email in a timely manner, the NIP editor will make a unilateral decision (it's not like such decisions can't be reversed :).

### NIP Editor

The current NIP editor is <GITHUB_HANDLE>.

### NIP Editor Responsibilities & Workflow

The NIP editor is in the [nem-improvement-process-slack], he/she will follow your NIP.

For each new NIP that comes in an editor does the following:

* Read the NIP to check if it is ready: sound and complete. The ideas must make technical sense, even if they don't seem likely to be accepted.
* The title should accurately describe the content.
* The NIP draft must have been published to as an [issue][nips-issues].
* Motivation and backward compatibility (when applicable) must be addressed.
* The defined Layer header must be correctly assigned for the given specification.
* Licensing terms must be acceptable for NIPs.

If the NIP isn't ready, the editor will send it back to the author for revision, with specific instructions.

Once the NIP is ready for the repository it should be submitted as a "pull request" to the [NIPs git repository][nips-repository] where it may get further feedback.

The NIP editor will:

* Assign a NIP number in the pull request.

* Merge the pull request when it is ready.

* List the NIP in [README.md](../README.md)

The NIP editors are intended to fulfill administrative and editorial responsibilities. The NIP editors monitor NIP changes, and update NIP headers as appropriate.

## NIP format and structure

### Specification

NIPs should be written in markdown format.

Each NIP should have the following parts:

* Summary: Headers containing metadata about the NIP, see NIP header preamble.

* Introduction/Abstract: A short (~200 word) description of the technical issue being addressed.

* Copyright: The NIP must be explicitly licensed under acceptable copyright terms, see NIP licensing below.

* Specification: The technical specification should describe the syntax and semantics of any new feature. The specification should be detailed enough to allow competing, interoperable implementations for any of the current components.

* Motivation: The motivation is critical for NIPs that want to change NEM components. It should clearly explain why the existing component is inadequate to address the problem that the NIP solves.

* Design Decisions: The rationale fleshes out the specification by describing what motivated the design and why particular design decisions were made. It should describe alternate designs that were considered and related work. The rationale should provide evidence of consensus within the community and discuss important objections or concerns raised during discussion.

* Implementation: The reference implementation must be completed before any NIP is given status "Final", but it need not be completed before the NIP is accepted. It is better to finish the specification and rationale first and reach consensus on it before writing code. The final implementation must include test code and documentation appropriate for the NEM protocol.

* Backwards compatibility: All NIPs that introduce backwards incompatibilities must include a section describing these incompatibilities and their severity. The NIP must explain how the author proposes to deal with these incompatibilities.

#### NIP header preamble

Each NIP must begin with an RFC 822 style header preamble. The headers must appear in the following order. Headers marked with "*" are optional and are described below. All other headers are required.
```
    NIP: <NIP number, or "?" before being assigned>
    Title: <NIP title; maximum 44 characters>
    Author: <list of authors' real names and email addrs>
    * Discussions-To: <telegram group>
    * Comments-Summary: <summary tone>
    Comments-URI: <links to issue page for comments>
    Status: <Draft | Active | Proposed | Deferred | Rejected |
            Withdrawn | Final | Replaced | Obsolete>
    Type: <Standards Track | Informational | Process>
    * Layer: <Core | API | SDK | Application | Library>
    Created: <date created on, in ISO 8601 (yyyy-mm-dd) format>
    License: <abbreviation for approved license(s)>
    * License-Code: <abbreviation for code under different approved license(s)>
    * Requires: <NIP number(s)>
    * Replaces: <NIP number>
    * Superseded-By: <NIP number>
```

The Layer header (only for Standards Track NIPs) documents which layer of NEM the NIP applies to.

While a NIP is in private discussions (usually during the initial Draft phase), a Discussions-To header will indicate the telegram group or URL where the NIP is being discussed.

The Type header specifies the type of NIP: Standards Track, Informational, or Process.

The Created header records the date that the NIP was assigned a number, while Post-History is used to record when new versions of the NIP are posted to NEM mailing lists.
Dates should be in yyyy-mm-dd format, e.g. 2001-08-14.
Post-History is permitted to be a link to a specific thread in a mailing list archive.

NIPs may have a Requires header, indicating the NIP numbers that this NIP depends on.

NIPs may also have a Superseded-By header indicating that a NIP has been rendered obsolete by a later document; the value is the number of the NIP that replaces the current document. The newer NIP must have a Replaces header containing the number of the NIP that it rendered obsolete.

#### Auxiliary Files

NIPs may include auxiliary files such as diagrams. Auxiliary files should be included in a subdirectory for that NIP, or must be named NIP-XXXX-Y.ext, where "XXXX" is the NIP number, "Y" is a serial number (starting at 1), and "ext" is replaced by the actual file extension (e.g. "png").

## NIP types

There are three kinds of NIP:

* A Standards Track NIP describes any change that affects most or all NEM implementations. Standards Track NIPs consist of two parts, a design document and a reference implementation.
  * Core:
  * API:
  * SDK:
  * Application:
  * Library:
* An Informational NIP describes a NEM design issue, or provides general guidelines or information to the NEM community, but does not propose a new feature. Informational NIPs do not necessarily represent a NEM community consensus or recommendation, so users and implementors are free to ignore Informational NIPs or follow their advice.
* A Process NIP describes a process surrounding NEM, or proposes a change to (or an event in) a process. Process NIPs are like Standards Track NIPs but apply to areas other than the NEM protocol itself. They may propose an implementation, but not to NEM's codebase; they often require community consensus; unlike Informational NIPs, they are more than recommendations, and users are typically not free to ignore them. Examples include procedures, guidelines, changes to the decision-making process, and changes to the tools or environment used in NEM development. Any meta-NIP is also considered a Process NIP.

## NIP status field

### Specification

The typical paths of the status of NIPs are as follows:

<img src=./nip-0001/process.png>

Authors of a NIP may decide on their own to change the status between Draft, Deferred, or Withdrawn.
The NIP editor may also change the status to Deferred when no progress is being made on the NIP.

A NIP may only change status from Draft (or Rejected) to Proposed, when the author deems it is complete, has a working implementation (where applicable), and has community plans to progress it to the Final status.

NIPs should be changed from Draft or Proposed status, to Rejected status, upon request by any person, if they have not made progress in 6 months. Such a NIP may be changed to Draft status if the author provides revisions that meaningfully address public criticism of the proposal, or to Proposed status if it meets the criteria required as described in the previous paragraph.

An Proposed NIP may progress to Final only when specific criteria reflecting real-world adoption has occurred. This is different for each NIP depending on the nature of its proposed changes, which will be expanded on below. Evaluation of this status change should be objectively verifiable, and/or be discussed on the development mailing list.

When a Final NIP is no longer relevant, its status may be changed to Replaced or Obsolete (which is equivalent to Replaced). This change must also be objectively verifiable and/or discussed.

A process NIP may change status from Draft to Active when it achieves rough consensus on the mailing list. Such a proposal is said to have rough consensus if it has been open to discussion on the development mailing list for at least one month, and no person maintains any unaddressed substantiated objections to it. Addressed or obstructive objections may be ignored/overruled by general agreement that they have been sufficiently addressed, but clear reasoning must be given in such circumstances.

### Structure of the process

The NIP process involves the following parties:

1. The NIP Author(s)
2. The NIP Editor
3. The PMC

#### The NIP Author(s)

Authors are responsible for building consensus within the community and documenting dissenting opinions before the NIP is officially discussed by the PMC. Their goal is to convince the PMC that their proposal is useful and addresses pertinent problems in the components as well as interactions with already existing features. Authors can change over the life-cycle of the NIP.

#### The NIP Editor

The NIP Editor is the responsible of the smooth running of NIPs. He or she appoints the PMC members, calls the meetings monthly, assigns new proposals to the members, and ensures that all of them are discussed within a short period of time.

#### The PMC

The PMC is the top level group for managing the project, which was seeded with the original "3 core devs". The job of the PMC is to be the stewards of the project, community and its software components, irrespective of which commerical or not-for-profit organization they work with or for.

The current committee members are listed in [nemtech/community](https://github.com/nemtech/community/tree/main/governance)

#### Reviewers

The NIP Editor assigns every proposal to a member of the PMC, who becomes the reviewer. The main tasks of the reviewer are the following:

* Discuss unclear points with the authors,
* Help them address their issues and questions,
* Provide them feedback from the discussions in the meetings, and
* Explain the latest progress in every meeting.

#### Voting

All PMC members vote. They can either vote in the meeting or by casting their vote via email to the NIP Editor before the set deadline.

PMC members can vote “in favor”, “against” or “abstain”.

For a NIP to be accepted, the following two requirements must be met:

* At least 50% of the PMC members vote in favor.
* There are at least two-thirds “in favor” versus “against” votes.

An alternative way to think of the two-thirds requirement is that the number of votes in favor must be at least twice the number of votes against. Abstentions are excluded in calculating a two-thirds vote.

Note that, when calculating the lower bound, numbers round up. Therefore for a PMC of 9 members, at least 50% means at least 5 members.

The deadline to vote a proposal is decided on a case-by-case basis. The deadline will be decided by the PMC members present at the last meeting and the NIP Editor, and will be made public right after the meeting.

#### Responsibilities of the members

Review the proposals they are assigned to. The NIP Editor will always notify them two weeks in advance, at minimum.
Play a role in the discussions, learn in advance about the topic if needed, and make up their mind in the voting process.
Decide which utilities should be inside a component. The goal is to shrink it over time, and, where possible, move NIPs to the components.

#### Guests

Experts in some fields of the component may be invited to concrete meetings as guests when discussing related NIPs. Their input would be important to discuss the current state of the proposal, both its design and implementation.

## NIP licensing

### Specification

New NIPs may be accepted with the following licenses. Each new NIP must identify at least one acceptable license in its preamble. The License header in the preamble must be placed after the Created header. Each license must be referenced by their respective abbreviation given below.

For example, a preamble might include the following License header:

    License: BSD-2-Clause
             GNU-All-Permissive

In this case, the NIP text is fully licensed under both the OSI-approved BSD 2-clause license as well as the GNU All-Permissive License, and anyone may modify and redistribute the text provided they comply with the terms of *either* license. In other words, the license list is an "OR choice", not an "AND also" requirement.

It is also possible to license source code differently from the NIP text. A optional License-Code header is placed after the License header. Again, each license must be referenced by their respective abbreviation given below.

For example, a preamble specifying the optional License-Code header might look like:

    License: BSD-2-Clause
             GNU-All-Permissive
    License-Code: GPL-2.0+

In this case, the code in the NIP is not available under the BSD or All-Permissive licenses, but only under the terms of the GNU General Public License (GPL), version 2 or newer.
If the code were to be available under *only* version 2 exactly, the "+" symbol should be removed from the license abbreviation.
For a later version (eg, GPL 3.0), you would increase the version number (and retain or remove the "+" depending on intent).

    License-Code: GPL-2.0   # This refers to GPL v2.0 *only*, no later license versions are acceptable.
    License-Code: GPL-2.0+  # This refers to GPL v2.0 *or later*.
    License-Code: GPL-3.0   # This refers to GPL v3.0 *only*, no later license versions are acceptable.
    License-Code: GPL-3.0+  # This refers to GPL v3.0 *or later*.

In the event that the licensing for the text or code is too complicated to express with a simple list of alternatives, the list should instead be replaced with the single term "Complex". In all cases, details of the licensing terms must be provided in the Copyright section of the NIP.

NIPs are not required to be *exclusively* licensed under approved terms, and may also be licensed under unacceptable licenses *in addition to* at least one acceptable license.
In this case, only the acceptable license(s) should be listed in the License and License-Code headers.

#### Recommended licenses

* MIT: [Expat/MIT/X11 license](https://opensource.org/licenses/MIT)
* Apache-2.0: [Apache License, version 2.0](http://www.apache.org/licenses/LICENSE-2.0)
* BSD-2-Clause: [OSI-approved BSD 2-clause license](https://opensource.org/licenses/BSD-2-Clause)
* BSD-3-Clause: [OSI-approved BSD 3-clause license](https://opensource.org/licenses/BSD-3-Clause)
* CC0-1.0: [Creative Commons CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/)
* GNU-All-Permissive: [GNU All-Permissive License](http://www.gnu.org/prep/maintain/html_node/License-Notices-for-Other-Files.html)
* LGPL-2.1+: [GNU Lesser General Public License (LGPL), version 2.1 or newer](http://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html)

In addition, it is recommended that literal code included in the NIP be dual-licensed under the same license terms as the project it modifies. For example, literal code intended for NEM Core would ideally be dual-licensed under the MIT license terms as well as one of the above with the rest of the NIP text.

#### Not recommended, but acceptable licenses

* BSL-1.0: [Boost Software License, version 1.0](http://www.boost.org/LICENSE_1_0.txt)
* CC-BY-4.0: [Creative Commons Attribution 4.0 International](https://creativecommons.org/licenses/by/4.0/)
* CC-BY-SA-4.0: [Creative Commons Attribution-ShareAlike 4.0 International](https://creativecommons.org/licenses/by-sa/4.0/)
* AGPL-3.0+: [GNU Affero General Public License (AGPL), version 3 or newer](http://www.gnu.org/licenses/agpl-3.0.en.html)
* FDL-1.3: [GNU Free Documentation License, version 1.3](http://www.gnu.org/licenses/fdl-1.3.en.html)
* GPL-2.0+: [GNU General Public License (GPL), version 2 or newer](http://www.gnu.org/licenses/old-licenses/gpl-2.0.en.html)

#### Not acceptable licenses

All licenses not explicitly included in the above lists are not acceptable terms for a NEM Improvement Proposal unless a later NIP extends this one to add them.
However, NIPs predating the acceptance of this NIP were allowed under other terms, and should use these abbreviation when no other license is granted:

* OPL: [http://opencontent.org/openpub/ Open Publication License, version 1.0]
* PD: Released into the public domain

### Rationale

* The OPL is generally regarded as obsolete, and not a license suitable for new publications.
* Many are unfamiliar with the OPL terms, and may just prefer to use the public domain rather than license under uncertain terms.
* The OPL license terms allowed for the author to prevent publication and derived works, which was widely considered inappropriate for NEM standards.
* Public domain is not universally recognised as a legitimate action, thus it is inadvisable.

Why are there software licenses included?

* Some NIPs, especially consensus layer, may include literal code in the NIP itself which may not be available under the exact license terms of the NIP.
* Despite this, not all software licenses would be acceptable for content included in NIPs.

Why is Public Domain no longer acceptable for new NIPs?

* In some jurisdictions, public domain is not recognised as a legitimate legal action, leaving the NIP simply copyrighted with no redistribution or modification allowed at all.

## History

This document was derived heavily from Bitcoin's [BIP-0002](https://github.com/bitcoin/bips/blob/master/bip-0002.mediawiki) written by Luke Dashjr which in turn was derived from Python's [PEP-0001](https://www.python.org/dev/peps/). In many places text was simply copied and modified. Although the PEP-0001 text was written by Barry Warsaw, Jeremy Hylton, and David Goodger, they are not responsible for its use in the NEM Improvement Process, and should not be bothered with technical questions specific to NEM or the NIP. Please direct all comments to the NIP editors.

| **Date**      | **Version**   |
| ------------- | ------------- |
| 2018-01-07    | 1.0           |
| 2019-02-12    | 1.1           |

[nem-improvement-process-slack]: https://join.slack.com/t/nem2/shared_invite/enQtMzY4MDc2NTg0ODgyLTFhZjgxM2NhYTQ1MTY1Mjk0ZDE2ZTJlYzUxYWYxYmJlYjAyY2EwNGM5NzgxMjM4MGEzMDc5ZDIwYTgzZjgyODM
[nips-issues]: https://github.com/NemProject/NIP/issues
[nips-repository]: https://github.com/NemProject/NIP

'''
'''--- NIPs/nip-0002.md ---
# NIP 2 - Transaction URI Scheme

```
    NIP: 2
    Title: URI Scheme
    Author: David Garcia <dgarcia360@outlook.com>
    Discussions-To: #sig-client
    Comments-URI: https://github.com/nemtech/NIP/issues/6
    Status: Draft
    Type: Standards Track
    Layer: Library
    Created: 2018-12-18
    License: Apache 2.0
    License-Code: Apache-2.0
```

## Table of contents

- [Introduction](#introduction)
- [Specification](#specification)
  * [Transaction URI scheme](#transaction-uri-scheme)
  * [Webhook payload](#webhook-payload)
  * [Integration sequence diagram](#integration-sequence-diagram)
- [Motivation](#motivation)
- [Design Decisions](#design-decisions)
  * [Standard Protocol](#standard-protocol)
  * [Lightweight library](#lightweight-library)
  * [WebHooks](#webhooks)
- [Implementation](#implementation)
- [Backwards compatibility](#backwards-compatibility)
- [Contributors](#contributors)
- [History](#history)

## Introduction

The signature and announcement of transactions should always occur on the client-side without sharing private keys with third-party applications.
NIP-0002 defines a URI scheme to serve transactions ready to be signed. 

## Motivation

Applications using Symbol will expect users to announce transactions to the network.  Imagine that Alice is purchasing a ticket for a concert. She has selected a ticket on the vendor's website, and at this time she is ready to pay. The website uses Symbol in the background, being the payment a regular transfer transaction from Alice's account. The experience shows from apps built on NIS1 that one of the following solutions would be used to accept the payment.

**A) The ticket vendor offers a client-side app**

Alice downloads the ticket vendor open-source app in local to sign a transaction. To make the process secure, Alice should inspect the downloaded code and check that:
The transaction is being constructed and serialized as expected.
The private key used is not being copied. 
From the UX point of view, having to inspect the code to see what the app does is far from ideal and not secure, since private keys should never be shared.

**B) The customer sends a transaction to a determined address**

In this scenario, Alice has to define the transaction manually in the NEM wallet. This approach looks safer than A), but introduces the possibility of making typing mistakes when defining the address, the message, or even choosing the transaction type. Besides, the customer spends additional time during the process as it has to set the transaction manually.

**C) The customer scans a QR code using a phone wallet**
 
This approach looks more usable and less error-prone, but it is not complete. Alice must use two different devices to announce transactions, one of them being necessarily a mobile phone.

Furthermore, Symbol comes with different types of transactions, and the [current QR standard](https://github.com/NemProject/nem-library-ts/blob/master/src/services/QRService.ts#L56) only handles transfer transactions.

The aforementioned downsides encourage looking for other alternatives. Defining a [standard URI scheme](https://logbooksocial.github.io/blog/development/2018/11/16/ux-i.html) and supporting it in trusted environments such as the official wallets would allow users to sign transactions from applications without having to define them manually, own the second device, nor inspect the source code.

## Specification

### Transaction URI scheme

``web+symbol://transaction?data=<data>&generationHash=<generationHash>&nodeUrl=<endpoint>&webhookUrl=<webhook>``

|**Parameter**      | **Description** | **Example**|
| ----------------- | ------------- | ------------- |
| data*   | The transaction payload [serialized in hexadecimal](https://nemtech.github.io/api.html#serialization) form.| A700...4000000 |
| generationHash | The [network generation hash seed](https://github.com/nemtech/catapult-server/blob/master/resources/config-network.properties). Identifies a network uniquely. | 57F7DA205008026C776CB6AED843393F04CD458E0AA2D9F1D5F31A402072B2D6 |
| nodeUrl | The preferred Rest Gateway URL to announce the transaction. The application could have another strategy to select the endpoint, omitting this field. | http://localhost:3000 |
| webhookUrl | The application can provide a URL that identifies the action uniquely. When the transaction is announced from the secure environment, this will send an HTTP POST [payload](#webhook-payload) to the URL provided. | https://myapp.extension/webhook/10758F6

### Webhook payload

**HTTP Method**: POST

|**Parameter**          | **Description** | **Example**|
| ----------------------| ------------------ | ------------- |
| action*               | The event being tracked. | AnnounceTransaction |
| data.hash*            | The hash of the transaction announced. | 1F05...7597451|
| data.signerPublicKey* | The public key of the transaction signer. | EFF9...227CE85|

**Example**
```
{
  "action": "AnnounceTransaction",
  "data": {
      "hash": "1F05E54DB40DC7C12262F3250F3A428EE6FEC7150DFACB67566B6DD607597451", 
      "signerPublicKey":"EFF9BC7472263D03EF6362B1F200FD3061BCD1BABE78F82119FB88811227CE85"
  }
}
```
*required field.

### Integration sequence diagram

<img src=./nip-0002/process.png>

## Design Decisions

### Standard Protocol

A URI scheme enables the communication between external applications and Symbol wallets. URIs can be recognized by desktop and [mobile wallets](https://developer.apple.com/documentation/uikit/core_app/allowing_apps_and_websites_to_link_to_your_content/defining_a_custom_url_scheme_for_your_app), launching the wallet app with the transaction ready to be signed. 

The protocol adds ``web+`` add the beginning of the scheme due to a [security requirement for Firefox](https://developer.mozilla.org/en-US/docs/Web/API/Navigator/registerProtocolHandler).

### Lightweight library

Creating a URI scheme library that handles custom transaction serialization is expensive because of the possible permutations of maintaining a library per language and the chance of having new transaction types in the future.

A convenient solution partially exists, making available the internal SDK classes to serialize and deserialize transactions. A lightweight library can be created instead to parse the Transaction to URI format and vice versa. This library should not be aware of how transactions are serialized/deserialized, but only how the URI string is formatted from a ``Transaction`` object.

Using the internal Symbol SDK functions to serialize transactions, we achieve the following properties:

* The scheme definition will not change if there is the need to add new types of transactions. 
* Multiple transactions can be announced together using aggregate transactions.

### Webhooks

A wallet app triggered by the URI scheme has to notify back the application after the user confirms announcing the transaction.
The wallet notifies the application sending a **HTTP POST** request to the URL specified in the ``webhook`` parameter with the following [payload](#webhook-payload).

The application is responsible for monitoring the blockchain to check if the transaction announced has been confirmed.

## Implementation

- [x] Changes required in the SDK: [Expose serialization methods](https://github.com/nemtech/symbol-sdk-typescript-javascript/issues/56)

- [x] Implementation: [symbol-uri-scheme](https://github.com/nemfoundation/symbol-uri-scheme)

- [x] Integration: [symbol-cli](https://github.com/nemtech/symbol-cli)

- [ ] Integration: [symbol-desktop-wallet](https://github.com/nemgroup/symbol-desktop-wallet)

- [ ] Integration: symbol-mboile-wallet

## Backwards compatibility

NIS1 does not have a known standard URI scheme.

## Contributors

Special thanks to [@aleixmorgadas](https://github.com/aleixmorgadas), [@dexterslabor](https://github.com/dexterslabor), [@9zero](https://github.com/9zero), [@jontey](https://github.com/jontey), [@rg911](https://github.com/rg911), [@decentraliser](https://github.com/decentraliser) for contributing actively to improve this NIP.

## History

| **Date**          | **Version**   |
| ----------------- | ------------- |
| December 18 2018  | Initial Draft |
| March    24 2020  | 0.4.3         |

'''
'''--- NIPs/nip-0003.md ---
# NIP 3 - Documenting a New Feature

```
    NIP: 3
    Title: Documenting a new feature
    Author: David Garcia <david@nem.foundation>
    Discussions-To: #sig-docs
    Comments-URI: https://github.com/nemtech/NIP/issues/9
    Status: Active
    Type: Process
    Created: 2019-01-23
    License: BSD-2-Clause
```

## Table of contents

- [Introduction](#introduction)
- [Process](#process)
- [Annex: Deliverables](#annex--deliverables)
- [History](#history)

## Introduction

This NIP introduces a detailed process to document a new feature.

Motivation:

1) Define collaboration between different SIG regarding docs.
2) Include documentation in the definition of done.
3) Enable docs collaboration in the different stages.
4) Increase the availability of new information related to development.

Glossary:

* [NIP](https://github.com/nemtech/NIP): NEM Improvement Proposal
* [SIG](https://github.com/nemtech/community/blob/master/governance.md#special-interest-groups-sigs): Special Interest Group
* [PMC](https://github.com/nemtech/community/blob/master/governance.md#project-mangement-committee-pmc): Project Management Committee

## Process

![diagram](https://user-images.githubusercontent.com/9107969/51618886-ff107e00-1f26-11e9-9aec-5d4193ed213a.png)

**Features**:  Features are treated as single entities, independently of the milestone they belong. This allows merging changes without waiting for other features pending to be finished.

**Phases**: As we are collaborating between different parties in a remote setup, it is necessary to share materials once ready in different moments. As a general rule, don’t pre-announce in master a feature that has not been released in at least the catapult-server repository. 

| Phase                                   | Deliverables                                                                       | Action                                                                                                                 |
|-----------------------------------------|------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------|
| **Specification**                           | Accepted NIP (NIP author)                                                          | Create a new branch in nem2-docs repository using the NIP’s identifier.                                                |
| **Feature is available in catapult-server** | Server Deliverables (SIG-Server) and Concept (SIG-docs)                            | a) Publish concept(*). <br>b) Merge to master. <br>Translations can start.  |
| **Feature becomes testable**               | Endpoints (SIG-api) and Swagger (SIG-docs)                                         | a) Publish updated swagger file. <br>b) Publish the list of required guides as open Github issues in nem2-docs repository. |
| **Feature becomes usable**                  | SDK comments (SIG-api), SDK reference (SIG-docs) and Guides (SIG-docs + community) | a) Publish SDK docs.<br> b)Publish guides.                                                                                 |

(*) If the feature is not testable or usable, e.g. SDK is not usable but REST is advanced, this should be remarked in the documentation. Once the feature reaches the master branch, it can be promoted by the different stakeholders as a newly included feature.

**Participants**: Each group should provide the required documentation in the specified format (see Annex: Deliverables). Keeping the nem-docs repository updated and supervise the documentation process is the responsibility of the SIG-doc.

**Revision**: At least two different people form the SIG-docs should review the changes before the committer merges them to master.

## Annex: Deliverables

| Deliverable         | Description                                                                                                                                                 | Template                                                                                                                                                                                        |
|---------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Accepted NIP        | Document describing specification and the design decisions for a  new NEM feature.  Note: Accepted NIPS require to be publicly available after RC release. | [NIP Structure](https://github.com/nemtech/NIP/blob/master/NIPs/nip-0001.md#specification)   The specification may have as annex some behavior scenarios to drive the development.              |
| Concept             | The specification formatted for documentation.                                                                                                              | Feature explanation, Examples and schemas.                                                                                                                                                      |
| Server Deliverables | The required pieces of documentation around the server changes.                                                                                             | Changelog (published in the catapult-server repository), Status Errors (Result.h validators), [Entity Schemas](https://github.com/nemtech/catbuffer/tree/master/schemas) and configuration changes. |
| Endpoints           | The list of additions/modifications in catapult-rest.                                                                                                     | Endpoint urls, methods, parameters, and example responses.                                                                                                                                       |
| Swagger             | The additions / modifications in catapult-rest formatted.                                                                                                   | [Swagger file](https://github.com/nemtech/nem2-docs/blob/master/source/resources/collections/swagger.yaml)                                                                                      |
| SDK comments        | The SDK classes and methods should be described in the code.                                                                                                            | [Comments format](https://nemtech.github.io/guidelines/sdk-documentation.html#comments-and-reference-docs)                                                                                                 |
| SDK reference       | The SDK generated reference.                                                                                                                                | [Generated reference](https://nemtech.github.io/guidelines/sdk-documentation.html#readme)                                                                                                                  |
| Guides              | Articles explaining how to use the new feature step by step. Each article can include recommendations, best practices, and combination with other features. | [Writing a guide](https://nemtech.github.io/guidelines/writing-a-guide.html)                                                                                                                     |

## History

| **Date**       | **Version**   |
| -------------  | ------------- |
| Jan 23 2018    | Initial Draft |

'''
'''--- NIPs/nip-0004.md ---
# NIP 4 - Apostille Improvement Protocol

```
    NIP: 4
    Layer: Library
    Title: Apostille Improvement Protocol
    Author: Jonathan Tey <jonathan@luxtag.io>
    Discussions-To: #wg-apostille
    Comments-URI: https://github.com/nemtech/NIP/issues/11
    Status: Draft
    Type: Standards Track
    Created: 2019-04-02
    License: Apache-2.0
    License-Code: ASL v2
```

## Table of contents

- [Introduction](#introduction)
- [Specification](#specification)
  * [Creating an apostille account](#creating-an-apostille-account)
  * [Announcing apostille](#announcing-apostille)
    + [First inner transaction](#first-inner-transaction)
    + [Second inner transaction](#second-inner-transaction)
    + [Third inner transaction](#third-inner-transaction)
    + [Fourth inner transaction](#fourth-inner-transaction)
      - [Metadata JSON example](#metadata-json-example)
    + [Sign and announce](#sign-and-announce)
  * [Tokenization of apostille asset](#tokenization-of-apostille-asset)
    + [Table of nonces](#table-of-nonces)
- [Motivation](#motivation)
- [Design Decisions](#design-decisions)
  * [Private vs Public Apostille](#private-vs-public-apostille)
  * [Storing of XEMs/currency in private apostille account](#storing-of-xems-currency-in-private-apostille-account)
  * [Future of tokenization](#future-of-tokenization)
- [Implementation](#implementation)
- [Backwards compatibility](#backwards-compatibility)
- [Drawbacks](#drawbacks)
- [Alternatives](#alternatives)
- [References](#references)
- [History](#history)

## Introduction

This proposal intends to improve the apostille creation standard to utilize the newer features of Catapult as well as to consolidate private and public apostille into a single standard. Any wallet or explorer that is compatible with this NIP will be able to parse and display accounts that are created according to this standard.

Future work should be done to define standards for handling transfer of ownership, scaling, verifying, and the use case for metadata.

## Specification

### Creating an apostille account

The steps below describe using private apostille standard to generate an asset account (Section 3.3 in the Apostille [whitepaper](https://nem.io/wp-content/themes/nem/files/ApostilleWhitePaper.pdf)). The point of deviation from the whitepaper will be indicated as below and is part of the improvement proposal.

X<sub>0</sub> - Private key of owner

X<sub>1</sub> - Private key of document to apostille

P<sub>A</sub> - Public address of apostille sink account

To generate X<sub>1</sub>, hash the filename and sign with X<sub>0</sub>. The resulting signature is truncated and will be X<sub>0</sub>

The file hash, F<sub>h</sub> is generated as follows:

```
0xFE 'N' 'T' 'Y' 0x81 + sign(md5(data)
0xFE 'N' 'T' 'Y' 0x82 + sign(sha-1(data)
0xFE 'N' 'T' 'Y' 0x83 + sign(sha-256(data)
0xFE 'N' 'T' 'Y' 0x88 + sign(keccak-256(data)
0xFE 'N' 'T' 'Y' 0x89 + sign(keccak-512(data))
0xFE 'N' 'T' 'Y' 0x90 + sign(sha3-256(data)
0xFE 'N' 'T' 'Y' 0x91 + sign(sha3-512(data))
```

> As [@daoka](https://github/com/daoka) pointed out, the SHA3 used in NIS1 differs from Catapult. Hence we will distinguish the two to ensure compatibility.

with the magic header `0xFE4E5459` and `sign()` is the signing function using the owner's private key, for X<sub>0</sub>.

> **Important!**
>
> *Note that the non-signed version of apostille is not included here.*

**The section that follows will now deviate from the previous apostille standard**

### Announcing apostille

The announcing of apostille will now use aggregate transactions that will contain at least one inner transaction.

```typescript
aggregateTx = AggregateCompleteTransaction[
    innerTransaction1, // Required
    innerTransaction2, // Optional
    innerTransaction3, // Optional
    innerTransaction4 // Optional
]
```

#### First inner transaction

The first inner transaction will contain the file hash and is the core of the apostille system.

```typescript
apostilleTx = TransferTransaction.create(
    Deadline.create(),
    <address of apostille account>,
    [],
    PlainMessage.create(<File hash>),
    NetworkType.MIJIN_TEST);

innerTransaction1 = apostilleTx.toAggregate(<owner public account>);
```

#### Second inner transaction

The second inner transaction will announce the creation of the apostille to a public sink address.

```
sinkTx = TransferTransaction.create(
    Deadline.create(),
    <address of public sink account>,
    [],
    PlainMessage.create(<File hash>),
    NetworkType.MIJIN_TEST);

innerTransaction2 = sinkTx.toAggregate(<apostille public account>);
```

#### Third inner transaction

The third inner transaction will assign ownership of the apostille. Solving the private key leakage issue (https://github.com/daoka/asset-apostille).

```typescript
multisigTx = ModifyMultisigAccountTransaction.create(
    Deadline.create(),
    1,
    1,
    [
        new MultisigCosignatoryModification(
            MultisigCosignatoryModificationType.Add,
            cosignatory,
        )
    ],
    NetworkType.MIJIN_TEST);

innerTransaction3 = multisigTx.toAggregate(<apostille public account>);
```

cosignatory will be the PublicAccount of X<sub>0</sub> or any other public account to assign first ownership to.

#### Fourth inner transaction

A fourth optional inner transaction can be added to contain certain apostille metadata.

```typescript
metadataTx = TransferTransaction.create(
    Deadline.create(),
    <address of apostille account>
    [],
    PlainMessage.create(<metadata>),
    NetworkType.MIJIN_TEST
);

innerTransaction4 = metadataTx.toAggregate(<apostille public accout>);
```

where metadata is a JSON string.

##### Metadata JSON example

```json
{
    "filename": "sample.pdf",
    "tags": ["sample", "apostille"],
    "description": "apostille sample file",
    "originFileURL": "http://example.com/sample_file.pdf"
}
```

> **Note**
>
> - The size of the JSON payload is limited to the transaction message size.
> - When Metadata Key/Value Association (#8) specification is decided and implemented, this section might use that feature. Future implementations should **always** check for a transfer transaction with a JSON payload to ensure backwards compatibility.

#### Sign and announce

```
signedTx = aggregateTx
    .signTransactionWithCosignatories(
        <owner account>,
        [apostille account]
    )

transactionHttp
    .announce(signedTransaction)
    .subscribe(x => console.log(x), err => console.error(err));
```

This concludes the first section on how to create an apostille account.

### Tokenization of apostille asset

After the creation of the apostille account, we can tokenize it by issuing mosaics from the apostille account.

To do this, we will designate certain nonces to represent different categories of tokens, eg. initial offering, STO compatibility list, etc.

```
const nonce = <as defined below>;

const mosaicDefinitionTransaction = MosaicDefinitionTransaction.create(
    Deadline.create(),
    nonce,
    MosaicId.createFromNonce(nonce, account.publicAccount),
    MosaicProperties.create({
        supplyMutable: true,
        transferable: true,
        levyMutable: false,
        divisibility: 0,
        duration: UInt64.fromUint(1000)
    }),
    NetworkType.MIJIN_TEST);
```

with `account.publicAccount` being the apostille public account.

#### Table of nonces

Below is a set of recommendations, subject to change.

| Nonce        | Description             |
| ------------ | ----------------------- |
| `0x544F4B00` | Generic token           |
| `0x53544F01` | Global STO token        |
| `0x53544F02` | Region locked STO token |
| `0x53544F03` | Vesting token           |

> Nonces in Catapult are 32 bit long binary string. The above is the nonce encoded in HEX.

Hex values `54`, `4F`, `4B` represents `T`, `O`, `K` respectively while`53`, `54`, `4F` represents `S`, `T`, `O`, in UTF-8.

## Motivation

There have been discussions in https://github.com/daoka/asset-apostille regarding the possibility of using mosaics to represent private apostille .

While representing assets as mosaics can give certain benefits, eg. tokenization, it does not give enough flexibility as being represented as an account. For example, with multisig it is easy to enforce a 2 of 3 contract where no transfer of ownership happens without a minimum of a combination of 2 signatures of the three owners. Using mosaics to enforce such a contract is difficult and control of ownership of mosaics is more complicated (not impossible).

Private apostille is already proven to be very useful in representing non-fungible assets on the NEM blockchain, but lacks the tokenization property as the number of multisig owners of an account is limited and much smaller than the possible divisibility of mosaics.

## Design Decisions

There has been confusion regarding private vs public apostille, and the ability to switch between the two. In actual fact, the implementation for private apostille is almost not compatible with public apostille.

### Private vs Public Apostille

Naming both methods as apostille does not provide a good developer experience. For example, someone implements a public apostille application because it is simple in concept and works well as a first Proof of Concept (PoC). Later on, they would add a new feature on their road map to have a transferable apostille as they read it is possible with apostille, not knowing that it would entail rewriting their PoC from scratch to support the more "complicated" private apostille.

Hence in this proposal, we would like to consolidate both private and public apostille into a single standard; combining the feature sets of private and public apostille into one apostille standard.

### Storing of XEMs/currency in private apostille account

Right now, in order for private apostille to be functional, eg. transfer of ownership, the apostille account needs to be funded with XEMs. This raises an issue where by a small amount of XEMs need to be kept in these accounts which can be spent by anyone who currently controls the multisig contract.

Using aggregate transactions, it is possible to have a third party pay the transaction fee of the transfer, etc. without needing to preload the apostille account with XEMs. How this is done will be detailed in the #Specification section.

### Future of tokenization

Another trend that is happening in the blockchain world is the move towards tokenization, eg. STOs. This NIP will also set forth a recommendation on how to support different tokens that are compatible with certain regulations, etc.

## Implementation

https://github.com/luxtagofficial/Apostille-library/tree/NIP0004

## Backwards compatibility

This standard will deprecate the public apostille standard. As for how we can transition current public apostille to the new standard is not determined and is outside the scope of this NIP.

This standard is NOT backwards compatible with NIS1, as it relies on certain Catapult only features.

## Drawbacks

A separate verifier class needs to be maintained to support verification of older `.nty` files (NanoWallet generated apostille certificate). This is subject to the details of the migration plans.

On the blockchain, the maximum number multisig accounts that a single account can cosign for is limited to 5 (for NIS1) and 25 (for Catapult, but configurable for each chain). The point being that NEM accounts are not designed to "own" (cosign for) a large number of asset/apostille accounts, as opposed to mosaics, which theoretically an account can hold significantly more of.

The scalability issues of this NIP will be addressed in a separate issue as it is outside the scope of this NIP.

## Alternatives

- https://nem.io/wp-content/themes/nem/files/ApostilleWhitePaper.pdf

  De facto standard. No changes necessary

- https://github.com/daoka/asset-apostille

  Uses namespaces and mosaics to represent apostille

## References

- https://github.com/nemtech/NIP/issues/2
- https://nem.io/wp-content/themes/nem/files/ApostilleWhitePaper.pdf
- https://nemtech.github.io/concepts/aggregate-transaction.html
- https://nemtech.github.io/concepts/mosaic.html
- https://github.com/daoka/asset-apostille

## History

| **Date**   | **Version**                        |
| ---------- | ---------------------------------- |
| 2019-04-02 | Initial draft                      |
| 2019-04-08 | Add apostille metadata transaction |
| 2019-04-15 | Split SHA 3 from KECCAK            |
| 2019-04-16 | Add implementation source          |

'''
'''--- NIPs/nip-0005.md ---
# NIP 5 - Wallet as Browser Extension

```
    NIP: 5
    Title: Wallet as browser extension
    Author: Aleix Morgadas, Décentraliser
    Discussions-To: #sig-client
    Comments-URI: https://github.com/nemtech/NIP/issues/13
    Status: Draft
    Type: Standards Track
    Layer: Application
    Created: 2019-04-09
    License: MIT
    License-Code: GPLv3
```

## Abstract

A Wallet as Browser Extension, for Firefox and Chrome potentially, focused on user essential features and web-application integration. The mission is to bring to NEM web-applications the power of an integrated wallet browser meanwhile helping the user manage their assets.

## Specification

No specification/architecture as an application.

## Motivation

Two main motivations.

1. A multi-platform wallet.

The need of a wallet as a browser extension solves the multi-platform support, Linux, Windows and Mac are supported. Being a browser extension helps the newcomer to onboard on NEM smoothly. Instead of asking the user to install a full application, we just add a new button on their browser.

2. nem2 web application integration.

Unleashing the true nem2 potential on the web applications. Using the [Transaction URI Scheme](nip-0002.md) as driver for this feature, nem2-wallet-browserextension allows the nem2 web-applications to perform awesome features meanwhile delegating all the wallet, assets, namespaces, etc to the wallet.

For the nem ecosystem, that implies that the users just need to learn how to use the nem2-wallet and a nem2-web-application once and they will know how to use them all.

## Design Decisions

Technologies used:

- Vue framework
- nem2-sdk

For testing:

- jest

Rules/principles:

- Simplicity as design
- YAGNI

Open Source approach:

- Inclusive project
- Pull-Request based
- Optimistic pull-request approval

## Implementation

The implementation can be found [here](https://github.com/aleixmorgadas/nem2-wallet-browserextension) until the repository is not transferred into `nemtech`.

## Drawbacks

We are not sure about Browser security. In order to be the wallet ready for production, the project needs support for:

- Browser Extension stability. Not all browsers support the browser extension specification. It might happen that some browsers experience a different behaviour or no compatibility to some features the wallet provides on other browsers.
- Hardware Wallet integration, like [Trezor](https://trezor.io/) and [Ledger](https://www.ledger.com/).
- UI/UX it's done by a motivated community but not experts on the field. The experience might not be as good as expected.
- Browser security. It's being done by motivated developers by the community but without the proper investment on security.

## History

| **Date**      | **Version**   |
| ------------- | ------------- |
| April 9 2019    | Initial Draft |

'''
'''--- NIPs/nip-0006.md ---
# NIP 6 - Multi-Account Hierarchy for Deterministic Wallets

```
    NIP: 6
    Layer: Application
    Title: Multi-Account Hierarchy for Deterministic Wallets
    Author: Grégory Saive <greg@nem.foundation>
    Status: Draft
    Discussions-To: #sig-client
    Comments-URI: https://github.com/nemtech/NIP/issues/12
    Type: Standards Track
    Created: 2019-04-09
    License: BSD-2 Clause
```

## Table of contents

- [Abstract](#abstract)
- [Motivation](#motivation)
  * [Non-Hardened Child Key Derivation](#non-hardened-child-key-derivation)
    + [Use case \#1: Facilitate Audit Process](#use-case---1--facilitate-audit-process)
    + [Use case \#2: Unsecure money receiver](#use-case---2--unsecure-money-receiver)
  * [Resources:](#resources-)
  * [Compatibility](#compatibility)
  * [KMAC vs HMAC](#kmac-vs-hmac)
  * [Conclusion](#conclusion)
- [Specification](#specification)
  * [Hardened Key Derivation](#hardened-key-derivation)
  * [KMAC Derivation](#kmac-derivation)
  * [Extended keys](#extended-keys)
    + [Catapult updates](#catapult-updates)
    + [Private parent key --> Private child key: `CKDpriv((kpar, cpar), i) → (ki, ci)`](#private-parent-key-----private-child-key---ckdpriv--kpar--cpar---i-----ki--ci--)
    + [Public parent key --> Public child key](#public-parent-key-----public-child-key)
    + [Private parent key --> Public child key: `N((k, c)) → (K, c)`](#private-parent-key-----public-child-key---n--k--c------k--c--)
    + [Key trees](#key-trees)
    + [Compatibility](#compatibility-1)
    + [Security implications](#security-implications)
  * [Wallet structure](#wallet-structure)
  * [Mnemonic seeds](#mnemonic-seeds)
  * [A logical hierarchy with BIP44](#a-logical-hierarchy-with-bip44)
    + [Examples](#examples)
- [Implementation](#implementation)
  * [Ongoing Work](#ongoing-work)
- [Integration](#integration)
- [References](#references)
- [History](#history)

## Abstract

This document describes hierarchical deterministic wallets for NEM.

This document uses Bitcoin's [BIP32](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki), [BIP39](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki), [BIP43](https://github.com/bitcoin/bips/blob/master/bip-0043.mediawiki), [BIP44](https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki) and [SLIP-10](https://github.com/satoshilabs/slips/blob/master/slip-0010.md) as sources of documentation.

A standard for deterministic wallets creation is needed to improve handling of NEM wallets within client applications.

This standard will set the rules for generating _extended keys_ as defined in [BIP32](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki), for generating _mnemonic pass phrases_ as defined in [BIP39](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki) and for _defining a logical hierarchy for deterministic wallets_.

Extracts from the Bitcoin documents will be added in quotes and detailed _extensions_  or _updates_ will be annotated for the NEM platform.

## Motivation

Previous versions of NEM clients (wallets) used a _user password_ to encrypt private keys, resulting in the need of creating backups every time when a new private key is generated.

Deterministic wallets do not require frequent backups as they will permit the generation of multiple public keys (addresses) without revealing the _spending private key_, with the use of elliptic curve mathematics.

This multi-account hierarchy will support _several chains of keypairs_ (multiple trees) as to allow selective sharing of wallet public keys. 

Additionally, we will be defining Mnemonic codes for generating deterministic keys using the definition in [Bitcoin BIP39](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki).

Furthermore, using [Bitcoin BIP44](https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki), we will define a scheme to build logical hierarchies for deterministic wallets. This will represent the recommended method to work with NEM CATAPULT wallets and keys.

### Non-Hardened Child Key Derivation

It has been [decided](https://github.com/nemtech/NIP/issues/12) that non-hardened child key derivation may not fill any required use-case.

As such, the implementation proposal will be providing **only hardened child key derivation**.

At first, the [SLIP-10](https://github.com/satoshilabs/slips/blob/master/slip-0010.md) algorithm was used to implement ED25519 compliant child key derivation. A second proposal implementation includes the possibility to use `KMAC` instead of `HMAC`, this will be described more in details in section [KMAC vs HMAC](#kmac-vs-hmac).

#### Use case \#1: Facilitate Audit Process

The non-hardened child key derivation model can be used to facilitate the process of auditing a hierarchical deterministic wallet. By sharing the non-hardened extended public key at the top of the tree in a HD wallet, one can give an auditor the ability to view all addresses in the wallet *without the ability to generate the associated private keys*.

Reference: https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#audits-nm

**Relevance Issue**: 

Discussion from https://github.com/nemtech/NIP/issues/12#issuecomment-484525238

> Any auditor will simply request ALL your public keys.
> ownership of public keys can be easily shown (by signing some predefined message), but even without this, I fail to see a reason, where you would like to give to auditor MORE public keys than you actually own...

#### Use case \#2: Unsecure money receiver

The non-hardened child key derivation model can be used when *using unsecure VPS* or *webservers* to run e-commerce websites. In those scenarios, the e-commerce will be configured to derive public keys (addresses) from a non-hardened extended public key as this will make sure that, even if the webserver is ever compromised, there is no chance of losing funds associated with the public keys.

In cases of compromised *money receivers*, there will however be a loss in privacy as the *extended public key* allows for the derivation of a whole tree of child keys making it possible for the attacker to associate public keys to the parent key.

Reference: https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#unsecure-money-receiver-nmih0

### Resources:

Following are the proposed implementations for BIP32-ED25519 extended keys. The implementation proposal by the Cardano team was defined in a paper that can be found in the resources as well:

- *DOC1*: [BIP32-Ed25519 Hierarchical Deterministic Keys over a Non-linear Keyspace](https://cardanolaunch.com/assets/Ed25519_BIP.pdf)
- *IMPL1*: [Cardano Implementation Proposal in RUST](https://github.com/input-output-hk/rust-cardano/commit/5dd1416249128d7346028ef8cce713fd7bda0f28#diff-20f5bbac575dbd279d57a5959a3eb883)
- *IMPL2*: [SLIP-10 compliant ED25519-hd-keys](https://github.com/alepop/ed25519-hd-key/tree/master/src)
- *IMPL3*: [SLIP-10 compliant ED25519-hd-keys in RUST](https://github.com/tarassh/ed25519_hd_key/blob/master/src/lib.rs)

### Compatibility

Following table describes compatibility of implementation proposal with regards to *hardened* child key derivation and *non-hardened* child key derivaton.

| Resource | Language | Hardened CKD | Non-Hardened CKD |
| --- | --- | --- | --- |
| *IMPL1* | rust | **YES** | **YES** |
| *IMPL2* | JS/TS | **YES** | **NO** |
| *IMPL3* | rust | **YES** | **NO** |

### KMAC vs HMAC

In order to improve the key derivation algorithm, we may be using `KMAC256k(m)` in places where SLIP-10 and BIP-32 use `HMAC(k||m)`. This is because _KMAC_ presents better compatibility with SHA-3 and avoids the danger of colliding uses. 

Additionally, the `KMAC` approach should be simpler and faster than the `HMAC` approach because it does not require _an additional pass of the hash algorithm_.

The `KMAC` wording stands for `Keccak Message Authentication Code`, it is an alternative to the `HMAC` algorithm which stands for `Hash-Based Message Authentication Code`.

More details about KMAC can be found in following NIST publication: 

    https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-185.pdf

### Conclusion

The described use cases make it potentially *useful* to implement non-hardened child key derivation scheme.

Due to the complexity of implementation and **status** of the available *resources* for the *ed25519-compatible non-hardended child key derivation* implementation, it may be decided to *drop support of non-hardened child key derivation* as we are aiming for **stable**, **tested** and **maintained** solutions for this NIP to be a success in cross-client interoperability.

**Resolution**: **Hardened child key derivation** will be the only available scheme of derivation for Catapult hierarchical deterministic wallets.

## Specification

Following section defines the technical specification of the proposed `Multi-Account Hierarchy for Deterministic Wallets`.

### Hardened Key Derivation

In our implementation proposal, we will be defining methods to derive master and child keys for **hardened paths** only. This means that any key that is derived using the subsequent library will be a **hardened key**.

In the **BIP32** and **BIP44** proposals, hardened keys are to be defined by having an **apostrophe** (') as the suffix of the path level index. Examples of _hardened paths_ include :

- `m/44'/4343'/0'/0'/0'`: first account, internal keychain, first address.
- `m/44'/4343'/0'/0'/1'`: first account, internal keychain, second address.
- `m/44'/4343'/1'/0'/5'`: second account, internal keychain, sixth address.
- `m/44'/4343'/1'/1'/5'`: second account, external keychain, sixth address.

:warning: **Following this definition, paths will _automatically_ be hardened in case they are non-hardened.**

### KMAC Derivation

In our implementation proposal, we will _permit the use of `KMAC`_. Any key derived for the Catapult engine/network, will be using `KMAC`, whilst keys derived for the `Bitcoin` or Bitcoin-alike protocol/network will be using `HMAC` as to provide compatibility with other hierarchical deterministic keys derivation implementations.

As such, we will provide with a `MACType` enumeration and `MACImpl` class implementation that permits to switch between `KMAC` and `HMAC`.

:warning: **It is not recommened to generate/derive keys for Catapult with the `HMAC` approach as this will produce keys that are not compatible with the chosen `KMAC` approach.**

### Extended keys

The [Bitcoin BIP32 document](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki) describes extended keys in detail. With the following extracts:

> We represent an extended private key as (k, c), with k the normal private key, and c the chain code. An extended public key is represented as (K, c), with K = point(k) and c the chain code.

> Each extended key has 2^31 normal child keys, and 2^31 hardened child keys. Each of these child keys has an index. The normal child keys use indices 0 through 2^31-1. The hardened child keys use indices 2^31 through 2^32-1. To ease notation for hardened key indices, a number iH represents i+2^31.

Multiple *child key derivation* functions (CKDs) are proposed in [BIP32](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki) as well, with the following references :

- [**Private** parent key --> **Private** child key: `CKDpriv((kpar, cpar), i) → (ki, ci)`](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#private-parent-key--private-child-key)
- ~~[**Public** parent key --> **Public** child key: `CKDpub((Kpar, cpar), i) → (Ki, ci)`](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#public-parent-key--public-child-key)~~ [EDIT: It is proposed to drop this CKD function]
- [**Private** parent key --> **Public** child key: `N((k, c)) → (K, c)`](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#private-parent-key--public-child-key)
- It is not possible to derive a **private** child key from a **public** parent key.

#### Catapult updates

With regards to the BIP32 standard definition, Catapult extended keys will be different in several aspects including:

- Keys are derived using the `ed25519` elliptic curve instead of the `secp256k` curve.
- Keys are derived using the `KMAC` codes instead of `HMAC` codes.
- Extended Keys have 2<sup>31</sub> **hardened child keys** as it is not possible to derive _non-hardened child keys_ with our implementation.

To this extent, our implementation proposal implements the following child key derivation methods:

#### Private parent key --> Private child key: `CKDpriv((kpar, cpar), i) → (ki, ci)`

The function CKDpriv((k<sub>par</sub>, c<sub>par</sub>), i) → (k<sub>i</sub>, c<sub>i</sub>) computes a child extended _private_ key from the parent extended _private_ key with steps defined below.

This implementation proposal makes use of the [SLIP-10](https://github.com/satoshilabs/slips/blob/master/slip-0010.md#private-parent-key--private-child-key) proposed `CKDPriv` implementation **with the difference that KMAC is used instead of HMAC**.

1. Take hardened child: `let I = KMAC256(Key = c<sub>par</sub>, Data = 0x00 || set<sub>p</sub>(point(k<sub>par)) || ser<sub>32</sub>(i))
2. Split `I` into two _32-byte sequences_, I<sub>L</sub> and I<sub>R</sub>
3. The returned **chain code** c<sub>i</sub> is **I<sub>R</sub>**.
4. The returned **child key** k<sub>i</sub> is **I<sub>L</sub>**.

The KMAC256 function is specified in [NIST.SP800-185](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-185.pdf).

#### Public parent key --> Public child key

This function is not available in our implementation proposal.

#### Private parent key --> Public child key: `N((k, c)) → (K, c)`

The function `N((k, c)) → (K, c)` computes the extended public key corresponding to an extended private key. This will compute the the **neutered** version and removes the ability to sign transactions.

- The returned key K is point(k).
- The returned chain code c is just the passed chain code.

To compute the public child key of a parent private key:

- N(CKDpriv((k<sub>par</sub>, c<sub>par</sub>), i))

#### Key trees

In the [source document](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki), a key tree is defined that will make use of the CKDs defined above. The child key derivation functions are cascaded several times to build a tree of keys.

Leaf nodes of that tree each define one key (private or public). A detailed explanation of the created key tree can be found [here](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#the-key-tree).

#### Compatibility

From the Bitcoin BIP32 standard document: 

> To comply with this standard, a client must at least be able to import an extended public or private key, to give access to its direct descendants as wallet keys. The wallet structure (master/account/chain/subchain) presented in the second part of the specification is advisory only, but is suggested as a minimal structure for easy compatibility - even when no separate accounts or distinction between internal and external chains is made. However, implementations may deviate from it for specific needs; more complex applications may call for a more complex tree structure.

#### Security implications

Security properties of the Extended Keys proposals can be found [here](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#security).

From the Bitcoin BIP32 description: 

> Private and public keys must be kept safe as usual. Leaking a private key means access to coins - leaking a public key can mean loss of privacy.

:warning: **Important Security Implication**

> Somewhat more care must be taken regarding extended keys, as these correspond to an entire (sub)tree of keys.
> One weakness that may not be immediately obvious, is that knowledge of a parent extended public key plus any non-hardened private key descending from it is equivalent to knowing the parent extended private key (and thus every private and public key descending from it). This means that extended public keys must be treated more carefully than regular public keys. It is also the reason for the existence of hardened keys, and why they are used for the account level in the tree. This way, a leak of account-specific (or below) private key never risks compromising the master or other accounts.

### Wallet structure

The previous sections specified key trees and their nodes as defined by the Bitcoin BIP32 source document. Next we are imposing a wallet structure that leverages this tree of keys. 

From the Bitcoin BIP32 standard - [The default wallet layout](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#the-default-wallet-layout):

> The layout defined in this section is a default only, though clients are encouraged to mimic it for compatibility, even if not all features are supported.

> An ~~hyper~~hierarchical deterministic wallet is organized as several `accounts`. Accounts are numbered, the default account ("") being number 0. Clients are not required to support more than one account - if not, they only use the default account.

> Each account is composed of two keypair chains: an **internal** and an **external** one. The _external_ keychain is used to _generate new public addresses_, while the _internal_ keychain is used for _all other operations_.

We will detail the logical hierarchy more in detail in the section [BIP44: A logical hierarchy for deterministic wallets](#specification-bip44-a-logical-hierarchy-for-deterministic-wallets).

### Mnemonic seeds

Mnemonic seeds are sentences with words matching a [Wordlists](https://github.com/bitcoin/bips/blob/master/bip-0039/bip-0039-wordlists.md) as well as holding a checksum as defined in [BIP39's `Generating the mnemonic`](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki#generating-the-mnemonic).

Mnemonic seeds are created from the available [Wordlists](https://github.com/bitcoin/bips/blob/master/bip-0039/bip-0039-wordlists.md) in the BIP39 annex.

Following references will be used during reference implementation: 

- [Generating the mnemonic](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki#generating-the-mnemonic)
- [From mnemonic to seed](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki#from-mnemonic-to-seed)

### A logical hierarchy with BIP44

Because we want to comply to the BIP44 standard we will define path levels as recommended in BIP44. This gives us the following path levels: 

```
m / purpose' / coin_type' / account' / change' / address_index'
```

:warning: Note the addition of *hardened* change and address_index path levels. Because Catapult makes use of *ed25519* elliptic curve cryptography, deriving non-hardened extended keys is non-trivial and resources available on this topic are limited. For our implementation, we decided to use **hardened derivation only** because of the simplicity of implementation and the availability of tested resources and publications.

- Our `purpose` level will be `44'` as we are building a logical hierarchy following the BIP44 standard. 
- Our `coin_type` is `4343''` as this corresponds to `Symbol` in [SLIP-44 annexed to the source document](https://github.com/satoshilabs/slips/blob/master/slip-0044.md).
- The next level corresponds to the _index_ of the `account` that we want to use, starting at `0` for the **first** account.
- The `change` path level is used to _define which keychain must be used_. Set to `0'`, the keychain used is said to be `external`, while any other `change` path level will result in using the `internal` keychain.
- The `address_index` path level corresponds to the _index_ of the `address` that we want to use, starting at `0'` for the **first** address.

The appended apostrophe (`'`) in path levels is used to mark **hardened key levels**. As defined in Bitcoin BIP32 and in this document's [Wallet structure](#specification-wallet-structure), the BIP32 algorithm permits derivation of two entirely independent keyspaces. Those are usually called **the hardened key space** and **the non-hardened key space**.

:warning: Our implementation proposal **only permits derivation of one of these keyspaces**, namely **the hardened key space**.

For NEM, we can define a _base logical hierarchy_ of `m/44'/4343'`. It is recommended for client implementations to follow this standard in order to achieve better cross-client compatibility.

For client implementations which _do not wish_ to implement the full capabilities of multi-account hierarchy for deterministic wallets, it is **recommended** to use only the following _default address path_: `m/44'/4343'/0'/0'/0'`.

#### Examples

Following table displays example derivation paths with their corresponding hierarchy details. The two first path levels, namely the *purpose* and the *coin_type*, are always expected to contain `44'` and `4343'` respectively. The next path levels, the third, represents the account number to be derived, and so on.

| account | keychain | address | path |
|---|---|---|---|
| **first** | **external** | **first** | `m/44'/4343'/0'/0'/0'` |
| **first** | **external** | **second** | `m/44'/4343'/0'/0'/1'` |
| **first** | **external** | **third** | `m/44'/4343'/0'/0'/2'` |
| **first** | **internal** | **first** | `m/44'/4343'/0'/1'/0'` |
| **first** | **internal** | **second** | `m/44'/4343'/0'/1'/1'` |
| **first** | **internal** | **third** | `m/44'/4343'/0'/1'/2'` |
| **second** | **external** | **first** | `m/44'/4343'/1'/0'/0'` |
| **second** | **external** | **second** | `m/44'/4343'/1'/0'/1'` |
| **second** | **external** | **third** | `m/44'/4343'/1'/0'/2'` |
| **second** | **internal** | **first** | `m/44'/4343'/1'/1'/0'` |
| **second** | **internal** | **second** | `m/44'/4343'/1'/1'/1'` |
| **second** | **internal** | **third** | `m/44'/4343'/1'/1'/2'` |

## Implementation

An implementation proposal has been started with following specification:

- Package name `nem2-hd-wallets@0.4.0` at https://github.com/evias/nem2-hd-wallets
- [`DeterministicKey`](https://github.com/evias/nem2-hd-wallets/blob/master/src/Compat/DeterministicKey.ts) class to provide with `bitcoinjs/bip32` compatibility.
- [`NodeEd25519`](https://github.com/evias/nem2-hd-wallets/blob/master/src/Curves/NodeEd25519.ts) class to describe hierarchical deterministic nodes for ED25519 elliptic curve cryptography.
- [`CKDPriv`](https://github.com/evias/nem2-hd-wallets/blob/master/src/Curves/NodeEd25519.ts#L57) function implementation to permit **Private parent key --> Private child key** derivation.
- [`ExtendedKey`](https://github.com/evias/nem2-hd-wallets/blob/master/src/ExtendedKey.ts) class to add an abstraction layer for actual *keys*, higher level layer for working with extended keys.
- [`MnemonicPassPhrase`](https://github.com/evias/nem2-hd-wallets/blob/master/src/MnemonicPassPhrase.ts) class to describe BIP39 mnemonic pass phrases.
- [`Wallet`](https://github.com/evias/nem2-hd-wallets/blob/master/src/Wallet.ts) class to describe hierarchical deterministic wallets compatible with `nem2-sdk` classes `Account` and `PublicAccount`.
- [`MACType`](https://github.com/evias/nem2-hd-wallets/blob/master/src/MACType.ts) enumeration with `HMAC` and `KMAC`.
- [`MACImpl`](https://github.com/evias/nem2-hd-wallets/blob/master/src/MACImpl.ts) class with `create` method to accept `MACType.KMAC` or `MACType.HMAC`and create message authentication code accordingly.
- [`HMAC`](https://github.com/evias/nem2-hd-wallets/blob/master/src/Cryptography.ts#L60) method implementation in `Cryptography` class.
- [`KMAC`](https://github.com/evias/nem2-hd-wallets/blob/master/src/Cryptography.ts#L76) method implementation in `Cryptography` class.

The current implementation is open for suggestions. The library is now BIP32-compatible and allows generating *hardened-only* ED25519 extended keys.

### Ongoing Work

- [x] Replace HMAC for KMAC with https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-185.pdf
- [x] Implement Wallet interface
- [ ] Implement Wallet creation out of extended private key hexadecimal format
- [ ] Implement KMAC specialized unit tests
- [ ] Add network type and network id in binary extended keys
- [x] Define relevance of `base58` encoding of extended keys for Catapult. [NOT RELEVANT]
- [ ] Integrate QR Code interface using `nem2-qr-code` when available.
- [ ] Make sure `privateKey`s can not be leaked through, for example, bad memory management in early draft phase.

## Integration

This package should aim at following integration examples:

```typescript
import {MnemonicPassPhrase, ExtendedKey, Wallet} from 'nem2-hd-wallets';

const mnemonic = MnemonicPassPhrase.createRandom();
const extended = ExtendedKey.fromSeed(mnemonic.toEntropy());
const wallet = new Wallet(extended);

// derive *master* account (not recommended)
const masterAccount = wallet.getAccount();

// derive *default* account (recommended)
const defaultAccount = wallet.getChildAccount(`m/44'/4343'/0'/0'/0'`);
```

## References

- [BIP32: Hierarchical Deterministic Wallets](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)
- [BIP39: Mnemonic code for generating deterministic keys](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki)
- [BIP43: Purpose Field for Deterministic Wallets](https://github.com/bitcoin/bips/blob/master/bip-0043.mediawiki) 
- [BIP44: Multi-Account Hierarchy for Deterministic Wallets](https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki)
- [SLIP44 - Registered coin types](https://github.com/satoshilabs/slips/blob/master/slip-0044.md)
- [SLIP44 - Pull request for Symbol](https://github.com/satoshilabs/slips/pull/887)
- [SLIP10 - Universal private key derivation](https://github.com/satoshilabs/slips/blob/master/slip-0010.md)
- [evias/nem2-hd-wallets](https://github.com/evias/nem2-hd-wallets)
- [Cardano Implementation Proposal in RUST](https://github.com/input-output-hk/rust-cardano/commit/5dd1416249128d7346028ef8cce713fd7bda0f28#diff-20f5bbac575dbd279d57a5959a3eb883)
- [SLIP-10 compliant ED25519-hd-keys](https://github.com/alepop/ed25519-hd-key/tree/master/src)
- [SLIP-10 compliant ED25519-hd-keys in RUST](https://github.com/tarassh/ed25519_hd_key/blob/master/src/lib.rs)
- [BIP32-Ed25519 Hierarchical Deterministic Keys over a Non-linear Keyspace](https://cardanolaunch.com/assets/Ed25519_BIP.pdf)
- [NIST.SP800-185](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-185.pdf)

## History

| **Date**      | **Version**       |
| ------------- | ----------------- |
| Apr 6 2019    | Initial Draft     |
| Apr 18 2019   | Second Draft      |
| Apr 23 2019   | Third Draft       |
| Apr 29 2019   | Fourth Draft      |
| May 13 2019   | Fifth Draft       |
| Apr 1 2020    | Updated Coin Type |

'''
'''--- NIPs/nip-0007.md ---
# NIP 7 - QR Library Standard Definition

```
    NIP: 7
    Layer: Library
    Title: QR Library Standard Definition
    Author: Anthony Law <anthony@nem.foundation>
            Gregory Saive <greg@nem.foundation>
    Discussions-To: #sig-client
    Comments-URI: https://github.com/nemtech/NIP/issues/3
    Status: Draft
    Type: Standards Track
    Created: 2018-07-15
    License: MIT
```
## Table of contents

- [Introduction](#introduction)
- [Motivation](#motivation)
- [Purpose](#purpose)
  * [Legacy NEM / NIS1 QR format](#legacy-nem---nis1-qr-format)
  * [Cross-client cross-network compatibility](#cross-client-cross-network-compatibility)
- [Specification](#specification)
  * [Catapult QR code format (version 3)](#catapult-qr-code-format--version-3-)
    + [Catapult QR code base schema](#catapult-qr-code-base-schema)
    + [Catapult AddContactQR schema](#catapult-addcontactqr-schema)
      - [Example of Catapult AddContactQR schema](#example-of-catapult-addcontactqr-schema)
    + [Catapult ExportAccountQR schema](#catapult-exportaccountqr-schema)
      - [Example of Catapult ExportAccountQR schema](#example-of-catapult-exportaccountqr-schema)
    + [Catapult TransactionRequestQR base schema](#catapult-transactionrequestqr-base-schema)
      - [TransactionRequestQR specialization schema for Transfers](#transactionrequestqr-specialization-schema-for-transfers)
        * [Example of Catapult TransactionRequestQR schema specialization for Transfers](#example-of-catapult-transactionrequestqr-schema-specialization-for-transfers)
      - [TransactionRequestQR specialization schema for Cosignatures](#transactionrequestqr-specialization-schema-for-cosignatures)
        * [Example of Catapult TransactionRequestQR schema specialization for Cosignatures](#example-of-catapult-transactionrequestqr-schema-specialization-for-cosignatures)
- [Implementation](#implementation)
  * [Ongoing Work](#ongoing-work)
- [Backwards compatibility](#backwards-compatibility)
- [References](#references)
- [History](#history)

## Introduction

The QR Library Standard must allow generating different types of QR codes for contacts, wallet backups or transaction requests.

Following QR code types are identified:

1. Wallet Import/Export QR code.
2. Transaction Request QR code for anyone to issue a pre-configured transaction.
3. Contacts QR code for adding an address to a contacts list.

## Motivation

With this NIP, it is intended that the QR code generation processes for Catapult _client implementations_ use a _standard_ way of dealing with QR codes representing several different objects on a Catapult network.

The new version of the Catapult network adds a bit of complexity on top with several types of transactions. Those will all be covered in _Transaction Requests_. 

As to allow better cross-network compatibility, we will also inspect the best ways of adding a **replay protection** to QR codes such that they will be linked to one _type_ of network and one _network guid_ (if available - nemesis hash if not).

As to provide with cross-client compatible and Catapult-network compatible QR codes, we need to define a standard for definition of QR codes.

## Purpose

Following section defines specific **purposes** of integration and/or generation of QR codes by their respective types. This section will also include examples of QR codes JSON definition as to provide with an overview of available fields and features.

### Legacy NEM / NIS1 QR format

Several client implementations for NEM blockchain have come up with a non-standardized way of generating QR codes. The most used definition of QR codes can be found in the [nem-library](https://github.com/NemProject/nem-library) in following implementation of the [`QRService`](https://github.com/NemProject/nem-library-ts/blob/master/src/services/QRService.ts).

The JSON representation used in this legacy QR code standard defines a **transfer transaction request** as shows the following example:

```json
{
  "v": 2,
  "type": 4,
  "data": {
    "addr": "",
    "mosaics": [{
      "name": "nem:xem",
      "qty": 10}],
    "msg": "",
    "name": ""
   }
}
```

### Cross-client cross-network compatibility

This library standard aims to produce a cross-client _and_ cross-network compatible QR code generation reference implementation. This is to provide client implementations of the Catapult protocol with a standardized way of handling QR codes.

Legacy QR codes have been known to be only partially compatible between different client implementations. It is up to the client to implement a way of generating QR codes and setting up this library standard will permit better cross-client compatibility.

Additionally, Catapult most likely will introduce many different networks and it is important to define a common QR code standard in order to avoid networks incompatibilities.

## Specification

This section describes the **specification** of our QR code library Standard. QR codes that are to be generated with client implementations of the Catapult network _can_ use this specification as a reference to be NIP-7 compatible.

### Catapult QR code format (version 3)

For the Catapult network client implementation, we previously identified different types of QR codes. Following table lists them with their **type ID** and details about their data schema.

| **Type ID** | **data schema** | **description** |
| :-: | :-: | :-: |
| 1 | address, name | Contact Import/Export |
| 2 | name, priv_key, salt | Accounts Import/Export |
| 3 | address, transactionData | Transaction requests |

#### Catapult QR code base schema

Our library standard must define fielda that will be present in **all QR codes** generated with our library. Those fields describe the base schema of QR codes compatible with our standards definition.

Following table lists mandatory fields for Catapult QR Codes compatible with NIP-7:

| **field** | **type** | **values** | **description** |
| :-: | :-: | :-: | :-: |
| v | integer | `3` | The QR Code version. |
| type | integer | `1` \| `2` \| `3` | The QR Code type. |
| network_id | integer | `0x68` for Mainnet \| `0x98` for Testnet \| `0x60` for Mijin \| `0x90` for Mijin_test | The related Network type. |
| chain_id | string | _replay protection_ with 32 bytes nemesis hash of the network. |
| data | object | `{}` | The QR code specialized data (AddContractQR, ExportAccountQR, TransactionRequestQR). |

#### Catapult AddContactQR schema

This section describes `AddContactQR` QR codes data schema with a fields description table and an example:

| **field** | **type** | **description** |
| :-: | :-: | :-: |
| data | object | The QR code data |
| data.addr | string | The contact account address. |
| data.name | string | The contact name. |

##### Example of Catapult AddContactQR schema

```json
{
  "v": 3,
  "type": 1,
  "network_id": 0x98,
  "chain_id": "E2A9F95E129283EF47B92A62FD748DBA4D32AA718AE6F8AC99C105CFA9F27A31",
  "data": {
    "addr": "NB7CJOPYUMTOV2XNWOWIDD5SBVPVMMM5HKW4M34S",
    "name": "John Invisible",
   }
}
```

#### Catapult ExportAccountQR schema

This section describes `ExportAccountQR` QR codes data schema with a fields description table and an example:

| **field** | **type** | **description** |
| :-: | :-: | :-: |
| v | integer | The QR Code version |
| type | integer | The QR Code type (2 = **ExportAccountQR**) |
| data | object | The QR code data |
| data.encryptedKey | string | 32 bytes IV prepended to 96 bytes of encrypted payload resulting int: `iv || encryptedKey`. |
| data.salt | string | 32 bytes salt that was used for encryption. |

##### Example of Catapult ExportAccountQR schema

```json
{
  "v": 3,
  "type": 2,
  "network_id": 0x98,
  "chain_id": "E2A9F95E129283EF47B92A62FD748DBA4D32AA718AE6F8AC99C105CFA9F27A31",
  "data": {
    "encryptedKey": "b6b016643493648eecaec3e680969322e2af4825b672a6c8977dca23b5d6c0d4a12a831a8de8519c380c15f83652fd20bc685364ab3db170f9212984cf0667af",
    "salt": "6c9ba0c43cd75b4f323947273db9b6f95aef95695197c0b24a5e10116e3923d1",
   }
}
```

#### Catapult TransactionRequestQR base schema

This section describes `TransactionRequestQR` QR codes data schema with a fields description table and an example:

| **field** | **type** | **description** |
| :-: | :-: | :-: |
| v | integer  | The QR Code version. |
| type | integer | The QR Code type (2 = **ExportAccountQR**). |
| data | object | The QR code data. |

The data field for `TransactionRequestQR` will be different for each _supported transaction type_. This section will define supported transaction types with their resulting schema specification.

**Note: TransactionRequestQR's data (serialization payload / Transaction) object is [NIP-2](https://github.com/nemtech/NIP/issues/6) compatible**

Following table lists the currently _supported transaction types_ with links to their respective schema specification:

| **transaction type** | **link** |
| :-: | :-: |
| `TransferTransaction` | [Transfer schema](#transactionrequestqr-specialization-schema-for-transfers)
| `CosignatureTransaction` | [Cosignature schema](#transactionrequestqr-specialization-schema-for-cosignatures)

##### TransactionRequestQR specialization schema for Transfers

The schema specialization for _transfers_ will hold the following listed fields, in the `data` field:

| **field** | **type** | **description** | **example** |
| :-: | :-: | :-: | :-: |
| type | integer (2 bytes) | The transaction type. | `0x4154` |
| version | integer (2 bytes) | The transaction format version. | `1` |
| deadline | uint64 (8 bytes) | The transaction deadline. | `[1,0]` |
| maxFee | uint64 (8 bytes) | The transaction max payable fee. | `[0,0]` |
| recipient | string | The transfer recipient address. | `Address.createFromRawAddress('NB7CJOPYUMTOV2XNWOWIDD5SBVPVMMM5HKW4M34S').plain()` |
| mosaics | array | Array of mosaics | `[{"id": "85BBEA6CC462B244", "amount": [100, 0]}]` |
| message | object | The transfer message (payload can be empty). | `{"type": 0, "payload": ""}` |

###### Example of Catapult TransactionRequestQR schema specialization for Transfers

```json
{
  "v": 3,
  "type": 3,
  "network_id": 0x98,
  "chain_id": "E2A9F95E129283EF47B92A62FD748DBA4D32AA718AE6F8AC99C105CFA9F27A31",
  "data": {
    "type": 0x4154,
    "version": 1,
    "deadline": [1, 0],
    "maxFee": [0, 0],
    "recipient": "NB7CJOPYUMTOV2XNWOWIDD5SBVPVMMM5HKW4M34S",
    "mosaics": [
      {"id": "85BBEA6CC462B244", "amount": [100, 0]}
    ],
    "message": {
      "type": 0,
      "payload": "54686973206973206120706c61696e2074657874206d657373616765"
   }
}
```

##### TransactionRequestQR specialization schema for Cosignatures

The schema specialization for co-signatures will hold the following listed fields, in the `data` field:

| **field** | **type** | **description** | **example** |
| :-: | :-: | :-: | :-: |
| hash | string | The aggregate bonded hash that needs to be co-signed. | `6714c22c89c81c656fb771a0492bda7bce6195f7d3ce10fff7cb1b343fdf7671` |

###### Example of Catapult TransactionRequestQR schema specialization for Cosignatures

```json
{
  "v": 3,
  "type": 3,
  "network_id": 0x98,
  "chain_id": "E2A9F95E129283EF47B92A62FD748DBA4D32AA718AE6F8AC99C105CFA9F27A31",
  "data": {
    "hash": "6714c22c89c81c656fb771a0492bda7bce6195f7d3ce10fff7cb1b343fdf7671",
  }
}
```

## Implementation

An implementation proposal has been started with following specification:

- Package name `nem2-qr-library` at https://github.com/AnthonyLaw/nem2-qr-library
- interface `QrCode` with method `build()`
- class `AddContactQR` with implementation for `build()`
- class `ExportAccountQR` with implementation for `build()`
- class `TransactionRequestQR` with implementation for `build()`
- Review of the library's OOP structure has been done and is being worked on.

### Ongoing Work

- interface `QrCode` with method `build()`
- class `AddContactQR` with implementation for `build()`
- class `ExportAccountQR` with implementation for `build()`
- class `TransactionRequestQR` with implementation for `build()`
- Review of the library's OOP structure has been done and is being worked on
- QR library must bridge with `nem2-sdk` account/addresses objects
- QR library must bridge with `nem2-sdk` transaction objects

## Backwards compatibility

Legacy QR codes currently being used on the NEM Mainnet (and Testnet) will not be compatible with the propose QR codes definition standard.

Catapult introduces many new features with many newly added transaction types. Yet, the `AddContactQR` and `ExportAccountQR` **may** keep backwards compatibility in adopting the same _schema_ as used in legacy implementations.

## References

- NEM-SDK : [QR object library for NIS](https://github.com/QuantumMechanics/NEM-sdk/blob/9e1d881171eb5c32d61791f8078deba962b56692/src/model/objects/qr.js)
- NEM-Library: [QRService library for NIS](https://github.com/aleixmorgadas/nem-library-ts/blob/fa649c5854287ee122bd635f2c1507d5218a952e/src/services/QRService.ts)
- NEM Android : [Android QR Library for NIS](https://github.com/NemProject/NEMAndroidApp/tree/9e9db2233b436e8fdbc35161e52e69171c8c7eb3/app/src/main/java/org/nem/nac/models/qr)

## History

| **Date**     | **Version**   |
| ------------ | ------------- |
| July 15 2018 | Initial Draft |
| Aug 6 2018   | Second Draft  |
| Apr 8 2019   | Third Draft   |
| Apr 29 2019  | Fourth Draft  |
| May 1 2019   | Fifth Draft  |

'''
'''--- NIPs/nip-0008.md ---
# NIP 8 - Symbol Technology Release for Public Network

```
    NIP: 8
    Layer: Core
    Title: Symbol technology release for Public Network
    Author: Grégory Saive <greg@nem.foundation>
    Discussions-To: https://github.com/nemtech/NIP/issues/22
    Comments-URI: https://github.com/nemtech/NIP/issues/22
    Status: Draft
    Type: Process
    Created: 2019-05-10
    License: Apache-2.0
```

## Table of contents

- [Introduction](#introduction)
- [Motivation](#motivation)
- [Specification](#specification)
  * [Issue Resolution Guidelines](#issue-resolution-guidelines)
  * [Post-Upgrade Situation](#post-upgrade-situation)
    + [One Chain Approach](#one-chain-approach)
    + [Two Chains Approach](#two-chains-approach)
    + [Ellected Situation](#ellected-situation)
  * [Migrated Modules / Datasets / Integrations](#migrated-modules---datasets---integrations)
  * [Process Implications](#process-implications)
    + [Legal implications](#legal-implications)
    + [Technical implications](#technical-implications)
    + [Reputational implications](#reputational-implications)
    + [Partner implications](#partner-implications)
  * [Dataset Migrations](#dataset-migrations)
    + [Account Data](#account-data)
    + [Transaction History](#transaction-history)
    + [Namespaces](#namespaces)
    + [Mosaics](#mosaics)
    + [Second Layer Integrations](#second-layer-integrations)
    + [Exchanges Integrations](#exchanges-integrations)
  * [Issue Resolutions](#issue-resolutions)
- [Design Decisions](#design-decisions)
- [Implementation](#implementation)
  * [Public Launch Dependencies](#public-launch-dependencies)
    + [Deliverables Definition](#deliverables-definition)
    + [Ongoing Development / Known Issues](#ongoing-development---known-issues)
- [Backwards compatibility](#backwards-compatibility)
- [Annexes](#annexes)
- [References](#references)
- [History](#history)

## Introduction

This document aims to provide with a decision making process about upgrading the current public blockchain network NEM (hereafter "**NIS1**") with the newly available Symbol Technology (hereafter "**Symbol**", each of which represent a "_Project_" and both "_Projects_").

Following projects are target of this documentation:

- [`NIS1`: NemProject/nem.core](https://github.com/NemProject/nem.core)
- [`Symbol`: nemtech/catapult-server](https://github.com/nemtech/catapult-server)

Discussions have been made about migration of NIS1 data sets to Symbol but several points remain open for discussion and unresolved.

## Motivation

With 4 years of uptime at the time of writing, the NEM blockchain is one of the prominent distributed ledger solutions available. The first version of the public network included features like custom assets management, multi-signature account management and namespaces management.

After some years of development, a new version of the protocol is now available, codenamed **Symbol** (previously codenamed Catapult). You can find more information [about the Symbol protocol in the whitepaper][whitepaper].

This NIP is proposed to communicate more information about the public network upgrade process. The complexity of upgrading a public distributed ledger network is a challenge that must be tackled by many peers, this NIP was opened to permit opening up discussions about the public network upgrade process.

## Specification

This section describes the process that will be followed when Symbol releases to a Public Network.

### Issue Resolution Guidelines

Many **issue resolutions** must be found (decisions to be taken) with the definition of this migration process. As to provide a clear way of determining whether an issue (decision) has been resolved, we will define base information about issue resolution with guidelines laid out in this section.

**Issue resolution** are to be _numbered_ from 1 to n (where n is the count of issue resolutions) and will be referred to with the `IR` prefix. Following examples match our **issue resolution identifier** format:

- IR-1
- IR-2
- IR-10

Next to the creation of a so-called _issue resolution identifier_ we will be adding the _issue resolution description_ in a table under section [Issue Resolutions](#issue-resolutions).

Additionally, every _issue resolution_ will be marked with _one of the following_ annexed information:

- In case of an **unresolved issue** (replace `IR-1` with _issue resolution identifier_ and set summarizing title):

```
:warning: (**IR-1** _Summarizing Title_) **An issue resolution must be made here.**
```

- In case of a **resolved issue** (replace `IR-1` with _issue resolution identifier_, set title and add description of decision taken):

```
:white_check_mark: **Issue Resolution IR-1: _Summarizing Title_**

> Descriptive text about the decision that has been taken
```

### Post-Upgrade Situation

Multiple scenarios can conceptually be planned for a blockchain network upgrade. With the caracteristics of distributed ledger technology and **its' blockchain**, it is of utter importance to **determine a planned post-upgrade scenario**. 

This conceptual plan and process definition will provide us with optimal settings as to communicate our network upgrade to the public, to partners and exchanges.

#### One Chain Approach

Historical data about distributed ledger network _forks_ has shown that it is possible to upgrade a blockchain network by **hard fork** gathering the majority of community / supporters / participants consensus.

In the scenario of a **one chain approach** fork, datasets from the previous network will need to be migrated to the newly setup Symbol network. **This adds up to the development of _many migration tools_** to permit the migration of several datasets currently available on the NEM blockchain network.

This scenario would **officially deprecate** the previous NIS1 network. Yet, it is **possible** that the NIS1 network would be kept online by businesses, community or supporters who would not upgrade their nodes. In the event that the NIS1 chain lives on after the **hard fork**, account holders will effectively own double balances because two networks will have split independently.

Mitigating the risks of a **split** is possible by providing with _tools for the migration_ but **a network split in a _one chain approach_ is caracterized by a bigger introduced technical debt.**

With regards to **Partners-** and **Exchanges-** _integrations_, the _one chain approach_ would **introduce technical debt on the side of partners** for them to be up to date with the newly created chain. Each exchange that lists trading pairs for `XEM`, would need to update their nodes and software handling deposits/withdrawals.

Additionally, partners and client integrations **must upgrade** their software in order for their software to function ahead of the migration.

#### Two Chains Approach

Another option that has arrised from historical data research about distributed ledger network _forks_ is to upgrade a blockchain network by **creating a _network apart from the previous network_**. This scenario **intentionally produces two separate chains as an outcome**.

In the scenario of a **two chains approach** fork, datasets from the previous network will also need to be migrated to the newly setup Symbol network but datasets can be **ellected** with more flexibility as to create a _fresh start of the new chain_.

It is **possible** that the NIS1 network would be kept online by businesses, community or supporters. Additionally, with the _two chain approach_, at the moment of genesis of the new chain, **only the balances of the old chain have actual capital value**.

There is fewer risks associated with this scenario as Partners and Exchanges must decide whether they want to support the newly setup Symbol network or not. **The creation of the new network will not affect available integrations.**

With regards to the migration of datasets for this scenario, it can be done with more flexibility. As such, **we must ellect datasets to be migrated on to the newly created network.** A section [Dataset Migrations](#dataset-migrations) will be provided in this document to _define datasets that will be migrated_.

**Fork Schemes**

In the event of a migration happening with the **two chains approach**, there is also two possible **fork schemes** identified:

- **Fork with Snapshot**: The new chain is identical up to _fork block_ and then splits. Account holders are **automatically** credited on new chain.
- **Fork with Burn**: Account holders must burn tokens on _old chain_ to get credited on _new chain_.

#### Ellected Situation

Possible outcomes include, and are limited to:

- **Symbol** technology **upgrades** NIS1, resulting in **one chain** and network.
- **Symbol** technology is **released alongside** of NIS1, resulting in **two chains** and networks **with Snapshot scheme**.
- **Symbol** technology is **released alongside** of NIS1, resulting in **two chains** and networks **with Burn scheme**.

The ellected post-upgrade network situation will be determined by the resolution of **IR-1: _Post-Upgrade Situation_**.

:white_check_mark: **Issue Resolution IR-1: _Post-Upgrade Situation_**

> **Symbol** technology will be **released alongside** of NIS1, resulting in **two chains** and networks **with Snapshot scheme**.

### Migrated Modules / Datasets / Integrations

Following list includes all the migrated modules that are currently available with NIS1 and datasets or _integrations_ (exchanges/clients) that must be taken into account when **migrating** to the Symbol technology:

- [Account data (balance(s), importance, multisig relationships)](#dataset-migration-account-data)
- [Transaction history](#dataset-migration-transaction-history)
- [Namespaces](#dataset-migration-namespaces)
- [Mosaics](#dataset-migration-mosaics)
- [Second Layer Integrations](#dataset-migration-second-layer-integrations)
- [Exchanges Integrations](#dataset-migration-exchanges-integrations)

Each of these migrated modules and datasets will be described more in detail in sub-sections of this document under the section [Dataset Migrations](#dataset-migrations).

### Process Implications

Several points have to be taken into account about implications of the migration in both **legal** and **technical** domains. Each of these implications that are open for resolution will be described in a sub-section of the current section.

#### Legal implications

The proposed approaches for migration imply the creation of a potential taxable event. It is important to clear this point before migration can be planned correctly.

- Can/Should we avoid the creation of a taxable event ? **NO**
- Is the creation of a taxable event a **blocking** Point for migration ? **NO**

#### Technical implications

During the process of migration, it is preferred that end-users **know exactly what they have to do** in order for the Symbol migration/release to be successful. For this, we should be defining important documentation and article references in this section, that will give end-users an overview of how the necessary steps for the upgrade can/should be taken.

Additionally, we will be providing an overview of the technical debt that accompanies the _Symbol release on Public Network_ grouped in the different Special Interest Groups as described in [nemtech/community](https://github.com/nemtech/community).

Following list may be re-defined over time, when decisions have been made on subsequent topics. Below is the list of **important tools and documentation for the Symbol Release on Public Network**.

- `catapult-service-bootstrap`: [Guide: Docker containers for Public Network Nodes](https://github.com/nemtech/catapult-service-bootstrap)
- `catapult-server`: [Building Instructions for Public Network Nodes](https://github.com/nemtech/catapult-server/blob/master/BUILDING.md)
- `catapult-rest`: [Guide: Run your own REST gateway for Public Network Nodes](https://github.com/nemtech/catapult-rest)
- `nem2-sdk-*`: [Guide: NEM2 TS/JS for Public Network Integrations](https://github.com/nemtech/symbol-sdk-typescript-javascript)
- `nem2-cli`: [Guide: NEM2 CLI for Public Network Integrations](https://github.com/nemtech/symbol-cli)
- `nem2-docs`: [Section: Symbol Public Network Integration](https://github.com/nemtech/symbol-docs)
- `nem2-e2e-tests`: [Testing: Usage with Public Network Nodes](https://github.com/nemtech/nem2-e2e-tests)
- `all-projects`: [Testing Clients/SDK/Docs: Usage with Public Network Nodes](https://github.com/nemtech)

Some of the listed **tools and documentation** may change due to decisions taken on subsequent topics. Also, some of the tools will require work assignment to permit usage with Public Network Nodes.

#### Reputational implications

Due to the decentralized aspect of the NIS1 and Symbol technologies, each and every _supporting_ end-user **must follow a pre-defined process** to support the Symbol technology.

This can have implications in the reputational form as well. More details will follow in this section.

#### Partner implications

Second Layer Integrations of the NIS1 network as well as any other client integrations **will be affected** by the network upgrade. As such, it is important to measure the implications for our partners to be able to make decisions on whether the upgrade must be done by their side or if help is to be requested for the matter.

This analysis will make sure that our partners can estimate the time needed for their teams to make upgrades as a way for us to **optimally** prepare our network migration.

### Dataset Migrations

This section describes the different datasets that have to be taken into account when migrating to Symbol technology. Each of the datasets available will be reviewed by asking the following questions:

1. **In the scenario of the _one chain approach_**
1.1. **will _not migrating dataset_ make majority of users unhappy and/or prefer NIS1?**
1.2. **will _not migrating dataset_ irreparably harm nem/symbol reputation?**
1.3. **will dataset be migrated ?**
2. **In the scenario of the _two chains approach_**
2.1. **will _not migrating dataset_ make majority of users unhappy and/or prefer NIS1?**
2.2. **will _not migrating dataset_ irreparably harm nem/symbol reputation?**
2.3. **will dataset be migrated ?**
3. **will there be any legal implication to the migration of this dataset ?**
5. **will there be any technical debt introduction with the migration of this dataset ?**

Each sub-section may have _siblings_ which are datasets that are related to the given sub-section dataset. Siblings are not required.

Additionally, each sub-section will be affected a **list of task assignments** that must be fulfilled in order for the sub-section to be resolved. The set of tasks will be the following (do not fill in these tasks) :

Task Assignments:
- [ ] Evaluate potential harm / importance of feature in both scenarios (one chain approach and two chains approach).
- [ ] Analyse legal implications with given dataset.
- [ ] Evaluate introduced technical debt where possible.
- [ ] Make decision on whether the dataset will be migrated, or not.
- [ ] (Optional) Resolution on the introduced technical debt.

#### Account Data

Account data represents those datasets that are linked to **Accounts on the NEM blockchain Public Network** (MAIN_NET).

Following sub-sections identify datasets that are linked to an **Account** on the _NIS1_ network.

**Multi-Signature Historical Data**

Siblings:
- [Multi-Signature Information](#multi-signature-information)
- [Modify Multisig Transaction](#modify-multisig-transaction)

Migration Questions:
1. In the scenario of the _one chain approach_
1.1. will _not migrating dataset_ make majority of users unhappy and/or prefer NIS1? **NO**
1.2. will _not migrating dataset_ irreparably harm nem/symbol reputation? **NO**
1.3. will dataset be migrated ? **NO**
2. In the scenario of the _two chains approach_
2.1. will _not migrating dataset_ make majority of users unhappy and/or prefer NIS1? **NO**
2.2. will _not migrating dataset_ irreparably harm nem/symbol reputation? **NO**
2.3. will dataset be migrated ? **NO**
3. will there be any legal implication to the migration of this dataset ? **NO**
5. will there be any technical debt introduction with the migration of this dataset ? **NO**

Task Assignments:
- [x] Evaluate potential harm / importance of feature in both scenarios (one chain approach and two chains approach).
- [x] Analyse legal implications with given dataset.
- [x] Evaluate introduced technical debt where possible.
- [x] Make decision on whether the dataset will be migrated, or not.

Migration status:
:warning: **This dataset will not be migrated to Symbol**.

**Importance Delegation**

Siblings:
- [Importance Transfer Transaction](#importance-transfer-transaction)

Migration Questions:
1. In the scenario of the _one chain approach_
1.1. will _not migrating dataset_ make majority of users unhappy and/or prefer NIS1? **YES**
1.2. will _not migrating dataset_ irreparably harm nem/symbol reputation? **YES**
1.3. will dataset be migrated ? **NO**
2. In the scenario of the _two chains approach_
2.1. will _not migrating dataset_ make majority of users unhappy and/or prefer NIS1? **NO**
2.2. will _not migrating dataset_ irreparably harm nem/symbol reputation? **NO**
2.3. will dataset be migrated ? **NO**
3. will there be any legal implication to the migration of this dataset ? **NO**
5. will there be any technical debt introduction with the migration of this dataset ? **NO**

Task Assignments:
- [x] Evaluate potential harm / importance of feature in both scenarios (one chain approach and two chains approach).
- [x] Analyse legal implications with given dataset.
- [x] Evaluate introduced technical debt where possible.
- [x] Make decision on whether the dataset will be migrated, or not.

Migration status:
:warning: **This dataset will not be migrated to Symbol**.

**Multi-Signature Information**

Siblings:
- [Multi-Signature Conversions](#multi-signature-conversions)

Migration Questions:
1. In the scenario of the _one chain approach_
1.1. will _not migrating dataset_ make majority of users unhappy and/or prefer NIS1? **YES**
1.2. will _not migrating dataset_ irreparably harm nem/symbol reputation? **YES**
1.3. will dataset be migrated ? **YES**
2. In the scenario of the _two chains approach_
2.1. will _not migrating dataset_ make majority of users unhappy and/or prefer NIS1? **NO**
2.2. will _not migrating dataset_ irreparably harm nem/symbol reputation? **NO**
2.3. will dataset be migrated ? **YES**
3. will there be any legal implication to the migration of this dataset ? **NO**
5. will there be any technical debt introduction with the migration of this dataset ? **NO**

Task Assignments:
- [x] Evaluate potential harm / importance of feature in both scenarios (one chain approach and two chains approach).
- [x] Analyse legal implications with given dataset.
- [x] Evaluate introduced technical debt where possible.
- [x] Make decision on whether the dataset will be migrated, or not.

Migration status:
:white_check_mark: **This dataset will be migrated to Symbol**.

**XEM Balances**

Siblings:
- [Dataset Migration: Namespaces](#dataset-migration-namespaces)
- [Dataset Migration: Mosaics](#dataset-migration-mosaics)

Migration Questions:
1. In the scenario of the _one chain approach_
1.1. will _not migrating dataset_ make majority of users unhappy and/or prefer NIS1? **YES**
1.2. will _not migrating dataset_ irreparably harm nem/symbol reputation? **YES**
1.3. will dataset be migrated ? **YES**
2. In the scenario of the _two chains approach_
2.1. will _not migrating dataset_ make majority of users unhappy and/or prefer NIS1? **YES**
2.2. will _not migrating dataset_ irreparably harm nem/symbol reputation? **YES**
2.3. will dataset be migrated ? **YES**
3. will there be any legal implication to the migration of this dataset ? **NO**
5. will there be any technical debt introduction with the migration of this dataset ? **NO**

Task Assignments:
- [x] Evaluate potential harm / importance of feature in both scenarios (one chain approach and two chains approach).
- [x] Analyse legal implications with given dataset.
- [x] Evaluate introduced technical debt where possible.
- [x] Make decision on whether the dataset will be migrated, or not.

Migration status:
:white_check_mark: **This dataset will be migrated to Symbol**.

**Mosaic Balances**

Siblings:
- [Dataset Migration: Namespaces](#dataset-migration-namespaces)
- [Dataset Migration: Mosaics](#dataset-migration-mosaics)
- [Register Namespace Transaction](#register-namespace-transaction)
- [Mosaic Definition Transaction](#mosaic-definition-transaction)

Migration Questions:
1. In the scenario of the _one chain approach_
1.1. will _not migrating dataset_ make majority of users unhappy and/or prefer NIS1? **YES**
1.2. will _not migrating dataset_ irreparably harm nem/symbol reputation? **YES**
1.3. will dataset be migrated ? **NO**
2. In the scenario of the _two chains approach_
2.1. will _not migrating dataset_ make majority of users unhappy and/or prefer NIS1? **NO**
2.2. will _not migrating dataset_ irreparably harm nem/symbol reputation? **NO**
2.3. will dataset be migrated ? **NO**
3. will there be any legal implication to the migration of this dataset ? **YES**
5. will there be any technical debt introduction with the migration of this dataset ? **YES**

Task Assignments:
- [x] Evaluate potential harm / importance of feature in both scenarios (one chain approach and two chains approach).
- [x] Analyse legal implications with given dataset.
- [x] Evaluate introduced technical debt where possible.
- [x] Make decision on whether the dataset will be migrated, or not.
- [x] Resolution on the introduced technical debt.

Migration status:
:warning: **This dataset will not be migrated to Symbol**.

**Account Importance**

Migration Questions:
1. In the scenario of the _one chain approach_
1.1. will _not migrating dataset_ make majority of users unhappy and/or prefer NIS1? **YES**
1.2. will _not migrating dataset_ irreparably harm nem/symbol reputation? **YES**
1.3. will dataset be migrated ? **NO**
2. In the scenario of the _two chains approach_
2.1. will _not migrating dataset_ make majority of users unhappy and/or prefer NIS1? **NO**
2.2. will _not migrating dataset_ irreparably harm nem/symbol reputation? **NO**
2.3. will dataset be migrated ? **NO**
3. will there be any legal implication to the migration of this dataset ? **NO**
5. will there be any technical debt introduction with the migration of this dataset ? **NO**

Task Assignments:
- [x] Evaluate potential harm / importance of feature in both scenarios (one chain approach and two chains approach).
- [x] Analyse legal implications with given dataset.
- [x] Evaluate introduced technical debt where possible.
- [x] Make decision on whether the dataset will be migrated, or not.

Migration status:
:warning: **This dataset will not be migrated to Symbol**.

#### Transaction History

The transaction history of the _NIS1_ network represents those datasets that are said to be **Transactions on the NEM blockchain Public Network**. Several types of transactions are available and some of them may require a migration.

Following sub-sections identify datasets that are linked to a **Transaction History** on the _NIS1_ network.

**Transfer Transaction**

Siblings:
- [Distribution (Transfers)](#distribution-transfers)

Migration Questions:
1. In the scenario of the _one chain approach_
1.1. will _not migrating dataset_ make majority of users unhappy and/or prefer NIS1? **YES**
1.2. will _not migrating dataset_ irreparably harm nem/symbol reputation? **YES**
1.3. will dataset be migrated ? **NO**
2. In the scenario of the _two chains approach_
2.1. will _not migrating dataset_ make majority of users unhappy and/or prefer NIS1? **NO**
2.2. will _not migrating dataset_ irreparably harm nem/symbol reputation? **NO**
2.3. will dataset be migrated ? **NO**
3. will there be any legal implication to the migration of this dataset ? **YES**
5. will there be any technical debt introduction with the migration of this dataset ? **YES**

Task Assignments:
- [x] Evaluate potential harm / importance of feature in both scenarios (one chain approach and two chains approach).
- [x] Analyse legal implications with given dataset.
- [x] Evaluate introduced technical debt where possible.
- [x] Make decision on whether the dataset will be migrated, or not.

Migration status:
:warning: **This dataset will not be migrated to Symbol**.

**Modify Multisig Transaction**

Siblings:
- [Multi-Signature Information](#multi-signature-information)

Migration Questions:
1. In the scenario of the _one chain approach_
1.1. will _not migrating dataset_ make majority of users unhappy and/or prefer NIS1? **NO**
1.2. will _not migrating dataset_ irreparably harm nem/symbol reputation? **NO**
1.3. will dataset be migrated ? **NO**
2. In the scenario of the _two chains approach_
2.1. will _not migrating dataset_ make majority of users unhappy and/or prefer NIS1? **NO**
2.2. will _not migrating dataset_ irreparably harm nem/symbol reputation? **NO**
2.3. will dataset be migrated ? **NO**
3. will there be any legal implication to the migration of this dataset ? **NO**
5. will there be any technical debt introduction with the migration of this dataset ? **NO**

Task Assignments:
- [x] Evaluate potential harm / importance of feature in both scenarios (one chain approach and two chains approach).
- [x] Analyse legal implications with given dataset.
- [x] Evaluate introduced technical debt where possible.
- [ ] Make decision on whether the dataset will be migrated, or not.

Migration status:
:warning: **This dataset will not be migrated to Symbol**.

**Importance Transfer Transaction**

Siblings:
- [Account importance](#account-importance)

Migration Questions:
1. In the scenario of the _one chain approach_
1.1. will _not migrating dataset_ make majority of users unhappy and/or prefer NIS1? **NO**
1.2. will _not migrating dataset_ irreparably harm nem/symbol reputation? **NO**
1.3. will dataset be migrated ? **NO**
2. In the scenario of the _two chains approach_
2.1. will _not migrating dataset_ make majority of users unhappy and/or prefer NIS1? **NO**
2.2. will _not migrating dataset_ irreparably harm nem/symbol reputation? **NO**
2.3. will dataset be migrated ? **NO**
3. will there be any legal implication to the migration of this dataset ? **NO**
5. will there be any technical debt introduction with the migration of this dataset ? **NO**

Task Assignments:
- [x] Evaluate potential harm / importance of feature in both scenarios (one chain approach and two chains approach).
- [x] Analyse legal implications with given dataset.
- [x] Evaluate introduced technical debt where possible.
- [x] Make decision on whether the dataset will be migrated, or not.

Migration status:
:warning: **This dataset will not be migrated to Symbol**.

**Register Namespace Transaction**

Siblings:
- [Dataset Migration: Namespaces](#dataset-migration-namespaces)

Migration Questions:
1. In the scenario of the _one chain approach_
1.1. will _not migrating dataset_ make majority of users unhappy and/or prefer NIS1? **YES**
1.2. will _not migrating dataset_ irreparably harm nem/symbol reputation? **YES**
1.3. will dataset be migrated ? **YES**
2. In the scenario of the _two chains approach_
2.1. will _not migrating dataset_ make majority of users unhappy and/or prefer NIS1? **NO**
2.2. will _not migrating dataset_ irreparably harm nem/symbol reputation? **NO**
2.3. will dataset be migrated ? **YES**
3. will there be any legal implication to the migration of this dataset ? **NO**
5. will there be any technical debt introduction with the migration of this dataset ? **YES**

Task Assignments:
- [x] Evaluate potential harm / importance of feature in both scenarios (one chain approach and two chains approach).
- [x] Analyse legal implications with given dataset.
- [x] Evaluate introduced technical debt where possible.
- [x] Make decision on whether the dataset will be migrated, or not.
- [x] Resolution on the introduced technical debt.

Migration status:
:white_check_mark: **This dataset will be migrated to Symbol**.

**Mosaic Definition Transaction**

Siblings:
- [Dataset Migration: Mosaics](#dataset-migration-mosaics)

Migration Questions:
1. In the scenario of the _one chain approach_
1.1. will _not migrating dataset_ make majority of users unhappy and/or prefer NIS1? **YES**
1.2. will _not migrating dataset_ irreparably harm nem/symbol reputation? **YES**
1.3. will dataset be migrated ? **NO**
2. In the scenario of the _two chains approach_
2.1. will _not migrating dataset_ make majority of users unhappy and/or prefer NIS1? **NO**
2.2. will _not migrating dataset_ irreparably harm nem/symbol reputation? **NO**
2.3. will dataset be migrated ? **NO**
3. will there be any legal implication to the migration of this dataset ? **YES**
5. will there be any technical debt introduction with the migration of this dataset ? **YES**

Task Assignments:
- [x] Evaluate potential harm / importance of feature in both scenarios (one chain approach and two chains approach).
- [x] Analyse legal implications with given dataset.
- [x] Evaluate introduced technical debt where possible.
- [x] Make decision on whether the dataset will be migrated, or not.
- [x] Resolution on the introduced technical debt.

Migration status:
:warning: **This dataset will not be migrated to Symbol**.

#### Namespaces

The namespaces of the _NIS1_ network represents those datasets that are identified as **expirable Namespace registrations on the NEM blockchain Public Network**.

Following sub-sections identify datasets that are linked to a **Namespace** on the _NIS1_ network.

**Root Namespaces**

Siblings:
- [Register Namespace Transaction](#register-namespace-transaction)

Migration Questions:
1. In the scenario of the _one chain approach_
1.1. will _not migrating dataset_ make majority of users unhappy and/or prefer NIS1? **YES**
1.2. will _not migrating dataset_ irreparably harm nem/symbol reputation? **YES**
1.3. will dataset be migrated ? **YES**
2. In the scenario of the _two chains approach_
2.1. will _not migrating dataset_ make majority of users unhappy and/or prefer NIS1? **NO**
2.2. will _not migrating dataset_ irreparably harm nem/symbol reputation? **NO**
2.3. will dataset be migrated ? **YES**
3. will there be any legal implication to the migration of this dataset ? **NO**
5. will there be any technical debt introduction with the migration of this dataset ? **YES**

Task Assignments:
- [x] Evaluate potential harm / importance of feature in both scenarios (one chain approach and two chains approach).
- [x] Analyse legal implications with given dataset.
- [x] Evaluate introduced technical debt where possible.
- [x] Make decision on whether the dataset will be migrated, or not.
- [x] Resolution on the introduced technical debt.

Migration status:
:white_check_mark: **This dataset will be migrated to Symbol**.

**Sub Namespaces**

Siblings:
- [Register Namespace Transaction](#register-namespace-transaction)

Migration Questions:
1. In the scenario of the _one chain approach_
1.1. will _not migrating dataset_ make majority of users unhappy and/or prefer NIS1? **YES**
1.2. will _not migrating dataset_ irreparably harm nem/symbol reputation? **YES**
1.3. will dataset be migrated ? **YES**
2. In the scenario of the _two chains approach_
2.1. will _not migrating dataset_ make majority of users unhappy and/or prefer NIS1? **NO**
2.2. will _not migrating dataset_ irreparably harm nem/symbol reputation? **NO**
2.3. will dataset be migrated ? **YES**
3. will there be any legal implication to the migration of this dataset ? **NO**
5. will there be any technical debt introduction with the migration of this dataset ? **YES**

Task Assignments:
- [x] Evaluate potential harm / importance of feature in both scenarios (one chain approach and two chains approach).
- [x] Analyse legal implications with given dataset.
- [x] Evaluate introduced technical debt where possible.
- [x] Make decision on whether the dataset will be migrated, or not.
- [x] Resolution on the introduced technical debt.

Migration status:
:white_check_mark: **This dataset will be migrated to Symbol**.

**Mosaics**

Siblings:
- [Mosaic Definition Transaction](#mosaic-definition-transaction)

Migration Questions:
1. In the scenario of the _one chain approach_
1.1. will _not migrating dataset_ make majority of users unhappy and/or prefer NIS1? **YES**
1.2. will _not migrating dataset_ irreparably harm nem/symbol reputation? **YES**
1.3. will dataset be migrated ? **NO**
2. In the scenario of the _two chains approach_
2.1. will _not migrating dataset_ make majority of users unhappy and/or prefer NIS1? **NO**
2.2. will _not migrating dataset_ irreparably harm nem/symbol reputation? **NO**
2.3. will dataset be migrated ? **NO**
3. will there be any legal implication to the migration of this dataset ? **YES**
5. will there be any technical debt introduction with the migration of this dataset ? **YES**

Task Assignments:
- [x] Evaluate potential harm / importance of feature in both scenarios (one chain approach and two chains approach).
- [x] Analyse legal implications with given dataset.
- [x] Evaluate introduced technical debt where possible.
- [x] Make decision on whether the dataset will be migrated, or not.
- [x] Resolution on the introduced technical debt.

Migration status:
:warning: **This dataset will not be migrated to Symbol**.

#### Mosaics

The mosaics of the _NIS1_ network represents those datasets that are identified as **custom mosaics created on the NEM blockchain Public Network**.

Following sub-sections identify datasets that are linked to a **Mosaic** on the _NIS1_ network.

**Balances**

Migration Questions:
1. In the scenario of the _one chain approach_
1.1. will _not migrating dataset_ make majority of users unhappy and/or prefer NIS1? **YES**
1.2. will _not migrating dataset_ irreparably harm nem/symbol reputation? **YES**
1.3. will dataset be migrated ? **NO**
2. In the scenario of the _two chains approach_
2.1. will _not migrating dataset_ make majority of users unhappy and/or prefer NIS1? **NO**
2.2. will _not migrating dataset_ irreparably harm nem/symbol reputation? **NO**
2.3. will dataset be migrated ? **NO**
3. will there be any legal implication to the migration of this dataset ? **NO**
5. will there be any technical debt introduction with the migration of this dataset ? **YES**

Task Assignments:
- [x] Evaluate potential harm / importance of feature in both scenarios (one chain approach and two chains approach).
- [x] Analyse legal implications with given dataset.
- [x] Evaluate introduced technical debt where possible.
- [x] Make decision on whether the dataset will be migrated, or not.
- [x] Resolution on the introduced technical debt.

Migration status:
:warning: **This dataset will not be migrated to Symbol**.

**Distribution (Transfers)**

Siblings:
- [Transfer Transaction](#transfer-transaction)

Migration Questions:
1. In the scenario of the _one chain approach_
1.1. will _not migrating dataset_ make majority of users unhappy and/or prefer NIS1? **NO**
1.2. will _not migrating dataset_ irreparably harm nem/symbol reputation? **NO**
1.3. will dataset be migrated ? **NO**
2. In the scenario of the _two chains approach_
2.1. will _not migrating dataset_ make majority of users unhappy and/or prefer NIS1? **NO**
2.2. will _not migrating dataset_ irreparably harm nem/symbol reputation? **NO**
2.3. will dataset be migrated ? **NO**
3. will there be any legal implication to the migration of this dataset ? **NO**
5. will there be any technical debt introduction with the migration of this dataset ? **YES**

Task Assignments:
- [x] Evaluate potential harm / importance of feature in both scenarios (one chain approach and two chains approach).
- [x] Analyse legal implications with given dataset.
- [x] Evaluate introduced technical debt where possible.
- [x] Make decision on whether the dataset will be migrated, or not.
- [x] Resolution on the introduced technical debt.

Migration status:
:warning: **This dataset will not be migrated to Symbol**.

**Namespaces**

This dataset is described and addressed under sub-section [Dataset Migration: Namespaces](#dataset-migration-namespaces).

#### Second Layer Integrations

The second layer integrations of the _NIS1_ network represents those datasets that are related to **data stored on the NEM blockchain Public Network**, including but not limited to: **Apostille configurations**, **Voting / Poll data**.

Following sub-sections identify datasets that are linked to **Second Layer Integrations** on the _NIS1_ network.

**Apostille**

Siblings:
- [Transfer Transaction](#transfer-transaction)

Migration Questions:
1. In the scenario of the _one chain approach_
1.1. will _not migrating dataset_ make majority of users unhappy and/or prefer NIS1? **YES**
1.2. will _not migrating dataset_ irreparably harm nem/symbol reputation? **YES**
1.3. will dataset be migrated ? **NO**
2. In the scenario of the _two chains approach_
2.1. will _not migrating dataset_ make majority of users unhappy and/or prefer NIS1? **NO**
2.2. will _not migrating dataset_ irreparably harm nem/symbol reputation? **NO**
2.3. will dataset be migrated ? **NO**
3. will there be any legal implication to the migration of this dataset ? **NO**
5. will there be any technical debt introduction with the migration of this dataset ? **YES**

Task Assignments:
- [x] Evaluate potential harm / importance of feature in both scenarios (one chain approach and two chains approach).
- [x] Analyse legal implications with given dataset.
- [x] Evaluate introduced technical debt where possible.
- [x] Make decision on whether the dataset will be migrated, or not.
- [x] Resolution on the introduced technical debt.

Migration status:
:warning: **This dataset will not be migrated to Symbol**.

**Voting Data**

Siblings:
- [Transfer Transaction](#transfer-transaction)

Migration Questions:
1. In the scenario of the _one chain approach_
1.1. will _not migrating dataset_ make majority of users unhappy and/or prefer NIS1? **YES**
1.2. will _not migrating dataset_ irreparably harm nem/symbol reputation? **YES**
1.3. will dataset be migrated ? **NO**
2. In the scenario of the _two chains approach_
2.1. will _not migrating dataset_ make majority of users unhappy and/or prefer NIS1? **NO**
2.2. will _not migrating dataset_ irreparably harm nem/symbol reputation? **NO**
2.3. will dataset be migrated ? **NO**
3. will there be any legal implication to the migration of this dataset ? **NO**
5. will there be any technical debt introduction with the migration of this dataset ? **YES**

Task Assignments:
- [x] Evaluate potential harm / importance of feature in both scenarios (one chain approach and two chains approach).
- [x] Analyse legal implications with given dataset.
- [x] Evaluate introduced technical debt where possible.
- [x] Make decision on whether the dataset will be migrated, or not.
- [x] Resolution on the introduced technical debt.

Migration status:
:warning: **This dataset will not be migrated to Symbol**.

#### Exchanges Integrations

The exchanges integrations of the _NIS1_ network represents those datasets that are related to **exchanges integrations of XEM or custom Mosaics on the NEM blockchain Public Network**.

Following sub-sections identify datasets that are linked to **Exchanges Integrations** on the _NIS1_ network.

**XEM Buy / Sell Integrations**

Migration Questions:
1. In the scenario of the _one chain approach_
1.1. will _not migrating dataset_ make majority of users unhappy and/or prefer NIS1? **YES**
1.2. will _not migrating dataset_ irreparably harm nem/symbol reputation? **YES**
1.3. will dataset be migrated ? **NO**
2. In the scenario of the _two chains approach_
2.1. will _not migrating dataset_ make majority of users unhappy and/or prefer NIS1? **YES**
2.2. will _not migrating dataset_ irreparably harm nem/symbol reputation? **YES**
2.3. will dataset be migrated ? **NO**
3. will there be any legal implication to the migration of this dataset ? **NO**
5. will there be any technical debt introduction with the migration of this dataset ? **YES**

Task Assignments:
- [x] Evaluate potential harm / importance of feature in both scenarios (one chain approach and two chains approach).
- [x] Analyse legal implications with given dataset.
- [x] Evaluate introduced technical debt where possible.
- [x] Make decision on whether the dataset will be migrated, or not.
- [x] Resolution on the introduced technical debt.

:warning: **Each exchange integration for XEM mosaics must be contacted for a clear resolution on whether _migration_ will be supported by work on their side or not**.

List of available XEM Buy / Sell Integrations:
- [Annex 1: Exchange integrations list](https://github.com/evias/NIP/blob/nip-public-network/NIPs/nip-0008/exchanges-list.md)

Migration status:
:warning: **This dataset will not be migrated to Symbol**.

**Custom Mosaics Buy / Sell Integrations**

Migration Questions:
1. In the scenario of the _one chain approach_
1.1. will _not migrating dataset_ make majority of users unhappy and/or prefer NIS1? **YES**
1.2. will _not migrating dataset_ irreparably harm nem/symbol reputation? **YES**
1.3. will dataset be migrated ? **NO**
2. In the scenario of the _two chains approach_
2.1. will _not migrating dataset_ make majority of users unhappy and/or prefer NIS1? **NO**
2.2. will _not migrating dataset_ irreparably harm nem/symbol reputation? **NO**
2.3. will dataset be migrated ? **NO**
3. will there be any legal implication to the migration of this dataset ? **NO**
5. will there be any technical debt introduction with the migration of this dataset ? **YES**

Task Assignments:
- [x] Evaluate potential harm / importance of feature in both scenarios (one chain approach and two chains approach).
- [x] Analyse legal implications with given dataset.
- [x] Evaluate introduced technical debt where possible.
- [x] Make decision on whether the dataset will be migrated, or not.
- [x] Resolution on the introduced technical debt.

:warning: **Businesses who have issued custom mosaics on the NEM blockchain Public Network must be contacted in order to find a clear resolution on their future with the Symbol technology**.

List of available Custom Mosaics Buy / Sell Integrations:
- [Annex 2: Exchange list for Custom Mosaics](https://github.com/evias/NIP/blob/nip-public-network/NIPs/nip-0008/exchanges-custom-mosaics.md)

Migration status:
:warning: **This dataset will not be migrated to Symbol**.

## Design Decisions

:white_check_mark: **Issue Resolution IR-1: _Post-Upgrade Situation_**

> The post-upgrade scenario that seems to be preferred amongst supporters and partners is the **two chains approach**. This is mostly because the _one chain approach_ would introduce a lot of **mandatory** updates for partners and integrators, without giving them the _choice_ on whether features get upgraded to Symbol or not. This is clearly not desired.

> Also, the two chains approach has the advantage that it permits for a freshly started network to be born upon public network release.

> **Symbol** technology will be **released alongside** of NIS1, resulting in **two chains** and networks **with Snapshot scheme**.

:white_check_mark: **Issue Resolution IR-2: _Snapshot or Burn_**

> With some research being done in concurrent blockchain protocols communities as well as the NEM community, it seems to be _more desired_ to adopt the **Snapshot** fork scheme for our public network release.

> In this event, the **balances of XEM accounts** will be extracted at a said block height, to be imported in the nemesis block of Symbol. **A block height for the fork must still be defined**.

:warning: **A block height for the fork must still be defined**.

:white_check_mark: **Issue Resolution IR-3: _Taxable event creation_**

> The creation of a taxable event is non-blocking to the migration because it will effectively affect users only upon *trading tokens* which falls off of our responsibility scope.

:white_check_mark: **Issue Resolution IR-4: _Migration tools development_**

> Integrations / Implementations to be finished by end of Q2 2019.

:white_check_mark: **Issue Resolution IR-5: _Reputational harm analysis_**

> It has been mentioned multiple times that electing a post-upgrade scenario with the two chains approach will let us start freshly with a new network where reputational harm is reduced to a minimum.

> On the other hand, the reputational harm that could be caused to NIS1 with electing the one chain approach is more concerning. In fact, would we elect the one chain approach, _all partners, clients and exchanges_ would be _obligated_ to migrate to Symbol in order for the network to continue working.

:white_check_mark: **Issue Resolution IR-6: _Symbol upgrade technical definition_**

> Details about a migration of business processes or data storage practices from NIS1 to Symbol technology are described in the NEM Developer Center: [Annex 3: Migrating from NIS1 to Symbol].

:white_check_mark: **Issue Resolution IR-7: _Define mandatory migrated datasets_**

> As seems to be desired by the community, partners, active supporters and other involved actors, most of the **account data** should be migrated to Symbol as well as **namespaces** definitions.

> **Migrated datasets include: _XEM account balances_, _multi-signature account setups_ and _namespace definitions_.**

> **Mosaic balances**, other than `nem:xem`, **will not be migrated to the Symbol blockchain.**

:white_check_mark: **Issue Resolution IR-8: _Define mandatory public launch dependencies_**

> The packages that have to be release and/or communicated publicly SHOULD be owned by the PMC. More details will be provided to add more information regarding public launch dependencies.

:warning: **Some of the listed projects are still being managed externally to PMC**.

## Implementation

### Public Launch Dependencies

The public network upgrade requires several packages to be released and/or communicated publicly. The below list of dependencies may vary over time and will be used as a living updates section to communicate status of public network upgrade dependencies.

#### Deliverables Definition

This section shall list all dependencies of a public network upgrade. Progress can be tracked by Milestones on Github. Packages for which no progress is currently indicated have yet to be made public. A public interface for status discovery will be made available.

| Package/Service | Lead Person | Importance | Link | Progress | ETA |
| --- | --- | --- | --- | --- | --- |
| **Symbol Protocol** | @core | **Required** | [catapult-server][src-catapult] | ![Milestone](https://img.shields.io/github/milestones/progress-percent/nemtech/catapult-server/7?style=for-the-badge) | TBD |
| **Symbol REST** | @Vektrat | **Required** | [catapult-rest][src-rest] | ![Milestone](https://img.shields.io/github/milestones/progress-percent/nemtech/catapult-rest/1?style=for-the-badge) | TBD |
| **Symbol CLI** | @dgarcia360 | **Required** | [symbol-cli][src-cli] | ![Milestone](https://img.shields.io/github/milestones/progress-percent/nemtech/symbol-cli/1?style=for-the-badge) | TBD |
| **Symbol Desktop Wallet** | @evias | **Required** | [symbol-desktop-wallet][src-desktop-wallet] | ![Milestone](https://img.shields.io/github/milestones/progress-percent/nemfoundation/symbol-desktop-wallet/1?style=for-the-badge) | TBD |
| **Symbol Mobile Wallet** | @evias | **Required** | [symbol-mobile-wallet][src-mobile-wallet] | ![Milestone](https://img.shields.io/github/milestones/progress-percent/nemfoundation/symbol-mobile-wallet/1?style=for-the-badge) | TBD |
| **Symbol Explorer** | @evias | **Required** | [symbol-explorer][src-explorer] | ![Milestone](https://img.shields.io/github/milestones/progress-percent/nemfoundation/symbol-explorer/2?style=for-the-badge) | TBD |
| **Symbol TS SDK** | @rg911 | **Required** | [symbol-sdk-ts][src-sdk-ts] | ![Milestone](https://img.shields.io/github/milestones/progress-percent/nemtech/symbol-sdk-typescript-javascript/6?style=for-the-badge) | TBD |
| **Symbol Java SDK** | @rg911 | **Required** | [symbol-sdk-java][src-sdk-java] | ![Milestone](https://img.shields.io/github/milestones/progress-percent/nemtech/symbol-sdk-java/3?style=for-the-badge) | TBD |
| **Symbol Docs** | @dgarcia360 | **Required** | [symbol-docs][src-docs] | ![Milestone](https://img.shields.io/github/milestones/progress-percent/nemtech/symbol-docs/4?style=for-the-badge) | TBD |
| **Symbol Exchanges Service** | @evias | **Required** | [symbol-exchanges-service][src-exchanges-service] | ![Milestone](https://img.shields.io/github/milestones/progress-percent/nemfoundation/symbol-exchanges-lib/1?style=for-the-badge) | TBD |
| **Symbol NanoWallet Opt-In Plugin** | @evias | **Required** | [symbol-nanowallet-optin][src-nanowallet-optin] | ![Milestone](https://img.shields.io/github/milestones/progress-percent/nemfoundation/symbol-nanowallet-optin/1?style=for-the-badge) | TBD |
| **Symbol Mobile Opt-In App** | @evias | **Required** | [symbol-mobile-optin][src-mobile-optin] | ![Milestone](https://img.shields.io/github/milestones/progress-percent/nemfoundation/symbol-mobile-optin/1?style=for-the-badge) | TBD |
| **Hardware (HSM) Desktop Wallet Plugin** | @evias | *Optional* | [symbol-trezor-wallet][src-trezor-wallet] | ![Milestone](https://img.shields.io/github/milestones/progress-percent/nemfoundation/symbol-desktop-wallet/2?style=for-the-badge) | TBD |
| | | | | | | |
| **Public Launch Progress** | | | | ![Progress](https://progress-bar.dev/79/) | TBD |

Note: The overall progress is calculated as a *sum of progress completion percentage of all **required** dependencies*. It may not be entirely accurate.

:warning: (**IR-9** _Finalize ongoing development_) **An issue resolution must be made here.**

### Issue Resolutions

- [x] IR-1: _Post-Upgrade Situation_ in [Post-Upgrade Situation](#post-upgrade-situation)
- [x] IR-2: _Snapshot or Burn_ in [Two Chains Approach](#two-chains-approach)
- [x] IR-3: _Taxable event creation_ in [Legal implications](#legal-implications)
- [x] IR-4: _Migration tools development_ in [Technical implications](#technical-implications)
- [x] IR-5: _Reputational harm analysis_ in [Reputational implications](#reputational-implications)
- [x] IR-6: _Symbol upgrade technical definition_ in [Partner implications](#partner-implications)
- [x] IR-7: _Define mandatory migrated datasets_ in [Dataset Migrations](#dataset-migrations)
- [x] IR-8: _Define mandatory public launch dependencies_ in [Public Launch Dependencies](#public-launch-dependencies)
- [ ] IR-9: _Finalize ongoing development_ in [Public Launch Dependencies](#public-launch-dependencies)

| Task | Title | Assignee | Status |
| --- | --- | --- | --- |
| **IR-1** | _Post-Upgrade Situation_ | N/A | ![Progress](https://progress-bar.dev/100/) |
| **IR-2** | _Snapshot or Burn_ | N/A | ![Progress](https://progress-bar.dev/100/) |
| **IR-3** | _Taxable event creation_ | N/A | ![Progress](https://progress-bar.dev/100/) |
| **IR-4** | _Migration tools development_ | N/A | ![Progress](https://progress-bar.dev/100/) |
| **IR-5** | _Reputational harm analysis_ | @evias | ![Progress](https://progress-bar.dev/100/) |
| **IR-6** | _Symbol upgrade technical definition_ | @evias| ![Progress](https://progress-bar.dev/100/) |
| **IR-7** | _Define mandatory migrated datasets_ | N/A | ![Progress](https://progress-bar.dev/100/) |
| **IR-8** | _Define mandatory public launch dependencies_ | N/A | ![Progress](https://progress-bar.dev/100/) |
| **IR-9** | _Finalize ongoing development_ | N/A | ![Progress](https://progress-bar.dev/80/) |

## Backwards compatibility

As the Symbol software is a rewrite in a different software development language, it is not possible to provide with a simple update process. Backwards compatibility is being reviewed and researched and should be discussed in this document.

All backwards incompatible modules and features of the Symbol technology are being evaluated in order find clear resolutions on the topics _before migration can happen_.

:warning: **More information will be described in this section when issues have been resolved.**

## Annexes

Annexes to this NIP are listed below:

- [Annex 1: Exchange integrations list]
- [Annex 2: Exchange list for Custom Mosaics]
- [Annex 3: Migrating from NIS1 to Symbol]

## References

- [`NIS1`: NemProject/nem.core](https://github.com/NemProject/nem.core)
- [`Symbol`: nemtech/catapult-server](https://github.com/nemtech/catapult-server)
- [catapult-service-bootstrap](https://github.com/nemtech/catapult-service-bootstrap)
- [catapult-server](https://github.com/nemtech/catapult-server/blob/master/BUILDING.md)
- [catapult-rest](https://github.com/nemtech/catapult-rest)
- [nem2-sdk-typescript-javascript](https://github.com/nemtech/nem2-sdk-typescript-javascript)
- [nem2-cli](https://github.com/nemtech/nem2-cli)
- [nem2-docs](https://github.com/nemtech/nem2-docs)
- [nem2-e2e-tests](https://github.com/nemtech/nem2-e2e-tests)
- [@nemtech](https://github.com/nemtech)
- [nemtech/community](https://github.com/nemtech/community)
- [Annex 1: Exchange integrations list]
- [Annex 2: Exchange list for Custom Mosaics]

[Annex 1: Exchange integrations list]:nip-0008/exchanges-list.md
[Annex 2: Exchange list for Custom Mosaics]:nip-0008/exchanges-custom-mosaics.md
[Annex 3: Migrating from NIS1 to Symbol]:https://nemtech.github.io/guides/migration/migrating-from-nem-to-symbol.html#migrating-from-nem-to-symbol
[src-catapult]: https://github.com/nemtech/catapult-server
[src-rest]: https://github.com/nemtech/catapult-rest
[src-desktop-wallet]: https://github.com/nemfoundation/symbol-desktop-wallet
[src-trezor-wallet]: https://github.com/nemfoundation/symbol-desktop-wallet
[src-ledger-wallet]: #
[src-mobile-wallet]: https://github.com/nemfoundation/symbol-mobile-wallet
[src-explorer]: https://github.com/nemfoundation/symbol-explorer
[src-sdk-ts]: https://github.com/nemtech/symbol-sdk-typescript-javascript
[src-sdk-java]: https://github.com/nemtech/symbol-sdk-java
[src-docs]: https://github.com/nemtech/symbol-docs
[src-cli]: https://github.com/nemtech/symbol-cli
[src-exchanges-service]: https://github.com/nemfoundation/symbol-exchanges-lib
[src-nanowallet-optin]: https://github.com/nemfoundation/symbol-nanowallet-optin
[src-mobile-optin]: https://github.com/nemfoundation/symbol-mobile-optin
[whitepaper]: https://nemtech.github.io/catapult-whitepaper/main.pdf

## History

| **Date**     | **Version**   |
| ------------ | ------------- |
| May 10 2019  | Initial Draft |
| May 13 2019  | Second Draft  |
| May 16 2019  | Third Draft   |
| Nov 02 2019  | Proposed      |
| Mar 18 2020  | Revised       |
| Mar 19 2020  | Revised       |

'''
'''--- NIPs/nip-0008/exchanges-custom-mosaics.md ---
# NIP-8 Annex 2: List of exchanges integrations for custom mosaics on NIS1

| Exchange | comsa.io | dimcoin.io | ecobit.io | loyalcoin.io | proximax.io | pundix.com | lattice80.com |
| --- | --- | --- | --- | --- | --- | --- | --- |
| https://zaif.jp/ | Zaif | :white_check_mark: | | | | | | |
| https://hitbtc.com/ | HitBTC | | :white_check_mark: | | | | | |
| https://yobit.net/en/ | Yobit | | | :white_check_mark: | | | | |
| https://exrates.me/ | Extrates | | :white_check_mark: | | | | | |
| https://cryptopia.co.nz/ | Cryptopia | | :white_check_mark: | :white_check_mark: | | | | |
| https://coinbe.net/ | Coinbe | | | | | | | |
| https://www.5iqt.org | 5iquant | | :white_check_mark: | | | | | |
| https://vantagex.io/ | VantageX (legacy NemChange) | :white_check_mark: | :white_check_mark: | :white_check_mark: | :white_check_mark: | | | |
| https://btc-alpha.com | BTC alpha | | :white_check_mark: | | | | | |
| https://bilaxy.com | BILAXY | | | | | :white_check_mark: | | |
| https://www.coinsuper.com | Coinsuper | | | | | :white_check_mark: | | |
| https://kryptono.exchange | Kryptono | | | | :white_check_mark: | :white_check_mark: | :white_check_mark: | |
| https://www.probit.com | Probit | | | | :white_check_mark: | :white_check_mark: | | |
| https://www.rightbtc.com | RightBTC | | | | :white_check_mark: | | | |
| https://www.hotbit.io/ | Hotbit | | | | | | :white_check_mark: | |
| https://www.digifinex.com/ | DigiFinex | | | | | | :white_check_mark: | |
| https://www.coss.io/ | COSS | | | | | | :white_check_mark: | :white_check_mark: |
| https://www.bitker.com | Bitker | | :white_check_mark: | | | | | |

## Credits

| Name | Github | Role |
| --- | --- | --- |
| Anatolii | @ | Author |
| Grégory Saive | @evias | Contributor |

'''
'''--- NIPs/nip-0008/exchanges-list.md ---
# NIP-8 Annex 1: List of exchanges integrations

| # | URL | Name | Notes |
| --- | --- | --- | --- |
| 1 | https://www.5iqt.org/ | iQuant | |
| 2 | https://www.aex.com/ | AEX | |
| 3 | https://www.alfacashier.com | Alfacashier | |
| 4 | https://www.b2bx.exchange/ | B2BX | |
| 5 | https://baksman.org/ | Baksman | |
| 6 | https://bchange.cc/ | Bchange | |
| 7 | https://www.bcoin.sg/ | Bcoin | |
| 8 | https://bestrate.org | Bestrate | |
| 9 | ~~https://bilaxy.com~~ | ~~Bilaxy~~ | ProximaX only |
| 10 | https://binance.com | Binance | |
| 11 | https://www.bitasiaex.com/ | BitAsiaEx | |
| 12 | https://bitbns.com/ | Bitbns | |
| 13 | https://indodax.com | BitcoinIndonesia / Indodax | |
| 14 | https://bitfex.trade | BitFex | |
| 15 | https://www.bithumb.com/ | Bithumb | |
| 16 | https://bitlish.com/ | Bitlish | |
| 17 | https://www.bitnovo.com | Bitnovo | |
| 18 | https://www.bitopro.com/ | BitoPro | |
| 19 | https://bitotal.com/ | Bitotal | |
| 20 | https://www.bitpanda.com/en | Bitpanda | |
| 21 | https://www.bitprime.co.nz/ | BitPrime | |
| 22 | https://www.bitrue.com/ | Bitrue | |
| 23 | https://bitsonic.co.kr | Bitsonic | |
| 24 | https://bittrex.com/ | Bittrex | |
| 25 | https://bitturk.com/ | Bitturk | |
| 26 | https://www.bqex.pro | BQEX | |
| 27 | https://btcexa.com | BTC EXA | |
| 28 | https://btc-alpha.com/ | BTC-Alpha | |
| 29 | https://www.btc38.com/ | btc38 | |
| 30 | https://btc-trade.com.ua/ | BTCTradeUA | |
| 31 | https://www.buyucoin.com/ | Buyucoin | |
| 32 | https://changenow.io/ | Change Now | |
| 33 | https://changehero.io | Changehero | |
| 34 | https://changelly.com/ | Changellly | |
| 35 | https://coinbe.net | Coinbe | |
| 36 | https://www.coinbene.com/ | CoinBene | |
| 37 | https://www.coinbig.com/pl/trade/XEM_USDT | Coinbig | |
| 38 | https://coinbtr.com/ | CoinBTR | |
| 39 | https://coincheck.com/ | Coincheck | |
| 40 | https://www.coinex.com | Coinex | |
| 41 | https://www.coinmex.com/ | CoinMex | |
| 42 | https://www.coinpayments.net/ | Coinpayments | |
| 43 | https://www.coinspot.com.au/buy/xem | CoinSpot | |
| 44 | https://www.coinsuper.com | Coinsuper | |
| 45 | https://www.cointiger.com | Cointiger | |
| 46 | https://coss.io | COSS | |
| 47 | https://crex24.com/ | Crex24 | |
| 48 | https://cryptex.net | Cryptex | |
| 49 | https://cryptomate.co.uk/ | Cryptomate | |
| 50 | https://www.cryptopia.co.nz/ | Cryptopia | |
| 51 | https://cryptopoint.net | Cryptopoint | |
| 52 | https://www.deex.com/ | Deex | |
| 53 | https://www.digifinex.com | DigiFinex | |
| 54 | https://bitcoin.dmm.com | DMM Bitcoin | |
| 55 | https://dragonex.io | DragonEX | |
| 56 | https://www.eobot.com/ | Eobot | |
| 57 | https://exmo.com/ | Exmo | |
| 58 | https://exqube.com | Exqube | |
| 59 | https://exrates.me | Exrates | |
| 60 | http://www.f8coin.com// | F8coin | |
| 61 | https://www.finexbox.com/ | Finebox | |
| 62 | https://freewallet.org | Freewallet | |
| 63 | https://gate.io/ | Gate.io | |
| 64 | https://exchange.gbx.gi/ | GBX Digital Asset Exchange | |
| 65 | https://godex.io/ | Godex | |
| 66 | https://graviex.net/ | GraviEX | |
| 67 | https://graviex.net | Graviex | |
| 68 | https://hitbtc.com/ | HitBTC | |
| 69 | https://www.hotbit.io/ | Hotbit | |
| 70 | https://www.hbg.com | Huobi Global | |
| 71 | https://www.huobi.co.kr/ | Huobi Korea | |
| 72 | https://www.idcm.io/ | IDCM | |
| 73 | https://indacoin.com/ | IndaCoin | |
| 74 | https://www.kaiserex.com | Kaiserex | |
| 75 | http://www.kex.com | KEX | |
| 76 | https://koineks.com | Koineks | |
| 77 | https://koinmarketi.com/ | Koinmarketi | |
| 78 | https://kryptono.exchange | Kryptono | |
| 79 | https://kuna.io/ | Kuna | |
| 80 | https://www.liquid.com/ | Liquid (former Qryptos) | |
| 81 | https://www.litebit.eu/ | LiteBit.eu | |
| 82 | https://www.livecoin.net/ | Livecoin | |
| 83 | https://www.lykke.com/exchange | Lykke | |
| 84 | https://obmen.money | ObmenMoney | |
| 85 | https://www.okex.com/ | OKEx | |
| 86 | https://onepagex.com/ | OnePageEx | |
| 87 | https://openledger.io/ | OpenLedger DEX | |
| 88 | https://orangeexchangepro.com/en/ | orangeexchangepro.com | |
| 89 | https://poloniex.com/ | Poloniex | |
| 90 | https://www.probit.com | Probit | |
| 91 | https://richamster.com/ | Richamster | |
| 92 | https://www.rightbtc.com/ | RightBTC | |
| 93 | https://exchange.sdce.com.au/ | SDCE | |
| 94 | https://shapeshift.io | Shapeshift | |
| 95 | https://spectrocoin.com/ | Spectrocoin | |
| 96 | https://stealthex.io/ | Stealthex | |
| 97 | https://stratum.hk/ | Stratum | |
| 98 | https://exchange.trade.io/trade/guest | Trade.io | |
| 99 | https://tubiex.com | TubiEx | |
| 100 | https://uex.com/ | UEX | |
| 101 | https://upbit.com/ | Upbit | |
| 102 | https://vantagex.io/ | Ventagex (NemChange) | |
| 103 | https://vhcex.com/ | VH Exchange | |
| 104 | https://www.vhcex.com/ | Vhcex | |
| 105 | https://www.xera.tech | Xeratech | |
| 106 | https://www.xt.com | XTcom | |
| 107 | https://yobit.net/en/ | Yobit | |
| 108 | https://zaif.jp/ | Zaif | |
| 109 | https://www.zb.com/ | ZBcom | |

## Credits

| Name | Github | Role |
| --- | --- | --- |
| Pawel (cryptoBeliever) | @cryptoBeliever | Author |
| Grégory Saive | @evias | Contributor |

'''
'''--- NIPs/nip-0009.md ---
# NIP 9 - New Persistent Delegation Request Transaction

```
    NIP: 9
    Layer: Core
    Title: New Persistent Delegation Request Transaction
    Author: gimre <g.imre@protonmail.com>
    Discussions-To: https://github.com/nemtech/NIP/issues/33
    Comments-URI: https://github.com/nemtech/NIP/issues/33
    Status: Active
    Type: Standards Track
    Created: 2020-01-24
    License: MIT
```

## Table of contents

- [Introduction](#introduction)
- [Specification](#specification)
  * [Short summary of changes](#short-summary-of-changes)
  * [Key derivation outline](#key-derivation-outline)
  * [Shared secret derivation](#shared-secret-derivation)
  * [Shared key derivation](#shared-key-derivation)
- [Design Decisions](#design-decisions)
- [Implementation](#implementation)
- [Backwards compatibility](#backwards-compatibility)
- [Alternatives](#alternatives)
- [References](#references)
- [History](#history)

## Introduction

Pentesting team has identified potential issues in persistent delegation request:
 * ad-hoc key derivation scheme
 * key sharing between asymmetric signature and encryption systems

We confirmed both claims, key derivation was indeed an ad-hoc choice.
Sharing keys is also bad practice.

This NIP and related server changes fixes both issues.

## Specification

### Short summary of changes

1. The message marker is changed from `FE` `CC71C764BFE598` to `FE` `2A8061577301E2`
2. The format of attached message is `| marker | ephemeral public key | encrypted harvester data |`
  * the format of `encrypted harvester key` is as earlier `| initialization vector | encrypted harvester key | Pkcs7 padding |`
3. The process of deriving a key is changed (generation of ephemeral key)
4. The key derivation function is changed to HKDF-HMAC-Sha256

### Key derivation outline

Let's assume account _A_ wants to send to node _N_ (identified by public key `N_pub`) delegation request transaction with attached harvester private key _HPK_.
Node 

_A_:
1. generates ephemeral key pair (`E_priv`, `E_pub`)
2. derives "shared secret" from `E_priv`, and `N_pub`
3. derives shared key `SK` - by passing "shared secret" into HKDF
4. generates initialization vector `IV`
5. uses `SK` and `IV` to encode _HPK_ with AES in CBC mode
6. creates transfer in format specified earlier `| marker | E_pub | encrypted data |`

Note, that both steps 1 and 4 should use true random source.

### Shared secret derivation

"Shared secret" deriviation is the same as before, the only difference is that on
 * senders side, ephemeral private key is used
 * recipient side, attached ephemeral public key is used for derivation

so for example in case of JS (and skipping details):
```js
	const d = prepareForScalarMult(ephemeralPrivateKey, hashfunc, signSchema);
	c.unpack(q, nodePublicKey);
	c.scalarmult(p, q, d);
	
	// sharedSecret = pack(p = d (derived from private key) * q (derived from public key))
	const sharedSecret = new Uint8Array(Key_Size);
	c.pack(sharedKey, p);
```

### Shared key derivation

Shared key derivation is simply HKDF-HMAC-SHA256.
Test cases are provided in [RFC5869](https://tools.ietf.org/html/rfc5869)
(note, that the rfc in test cases mentions SHA256, but it really means HMAC-Sha256)

so for example in cae of JS
```js
	const sharedKey = new Uint8Array(Key_Size);
	const salt = new Uint8Array(32);
	const info = 'catapult';
	const hash = 'SHA-256';

	const sharedKey = hkdf(sharedSecret, 32, { salt, info, hash });
```

## Design Decisions

The scheme outlined above follows [ECIES](https://en.wikipedia.org/wiki/Integrated_Encryption_Scheme) scheme.
The usage of ephemeral key unties usage of _A_ key in asymmetric context from encryption.
HKDF is well known function used to derive keys from high-entropy sources.

## Implementation

Server part of the changes is already available inside catapult-server repository.

Proper test vectors will be provided inside [test-vectors](https://github.com/nemtech/test-vectors) repository.

## Backwards compatibility

Old marker (`FE` `CC71C764BFE598`) and data in old format will not be supported since next build after 0.9.2.1.

The changes obviously are not backward compatible.

## Alternatives

Alternative KDF construction considered was usage of one-step key derivation function using KMAC, as defined in
[NIST Special Publication 800-56C rev 1](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-56Cr1.pdf).
The idea was abandoned, because of poor adaptation in other programming languages.

## References

* [catapult-server](https://github.com/nemtech/catapult-server/)

## History

| **Date**      | **Version**   |
| ------------- | ------------- |
| Jan 24 2020   | 1.0           |

'''
'''--- NIPs/nip-0010.md ---
# NIP 10 - Key Pair Generation and Address Format

```
    NIP: 10
    Layer: Core
    Title: Key Pair Generation and Address Format
    Author: gimre <g.imre@protonmail.com>
    Discussions-To: https://github.com/nemtech/NIP/issues/36
    Comments-URI: https://github.com/nemtech/NIP/issues/36
    Status: Active
    Type: Standards Track
    Created: 2020-02-06
    License: MIT
```

## Introduction

Symbol is using Ed25519 signature scheme. 
The specification of the signature system from "High-speed high-security signatures"
is not defining the hash function to be used.

First NEM network (nis1) is using pre-NIST version of Keccak as the hash function.
Initial implementation of Symbol (catapult) was using two different hash functions:
 * pre-NIST Keccak - for backward compatibility of key pairs with NEM network
 * Sha3 - for new/private networks

For various reasons described later, this has been changed.
All symbol networks will use Sha512 for key derivation.

For completeness, the document also describes address derivation,
which also will be common for both types of networks.

## Specification

Both public key derivation and signature generation follows
specification from "High-speed high-security signatures".

The contents will not be replicated here, instead an example
is given on how to generate public key from private using OpenSSL.

### Key derivation using OpenSSL

Key passed to `openssl` will be in DER-encoded ASN.1 format, described briefly in RFC8410.
So raw private key needs to be prefixed with some ASN.1 data.

`xxd` is a small tool present in most \*nix distributions, used for converting between hex and binary.

The key in first example come straight from symbol test vectors repository:

    $ export ASN1PREFIX="302e020100300506032b657004220420"
    $ echo "${ASN1PREFIX}575dbb3062267eff57c970a336ebbc8fbcfe12c5bd3ed7bc11eb0481d7704ced" \
      | xxd -r -p \
      | openssl pkey -inform DER -text -noout

    ED25519 Private-Key:
    priv:
        57:5d:bb:30:62:26:7e:ff:57:c9:70:a3:36:eb:bc:
        8f:bc:fe:12:c5:bd:3e:d7:bc:11:eb:04:81:d7:70:
        4c:ed
    pub:
        2e:83:41:40:fd:66:cf:87:b2:54:a6:93:a2:c7:86:
        2c:81:92:17:b6:76:d3:94:32:67:15:66:25:e8:16:
        ec:6f

Public key matches the first entry in `1.test-keys.json` file inside test-vectors repository.

The key in the second example is a zero key.

    $ echo "${ASN1PREFIX}0000000000000000000000000000000000000000000000000000000000000000" \
      | xxd -r -p \
      | openssl pkey -inform DER -text -noout

    ED25519 Private-Key:
    priv:
        00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:
        00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:
        00:00
    pub:
        3b:6a:27:bc:ce:b6:a4:2d:62:a3:a8:d0:2a:6f:0d:
        73:65:32:15:77:1d:e2:43:a6:3a:c0:48:a1:8b:59:
        da:29
 
### Address format

Steps for generating addresses are described in Symbol Technical Reference
 1. Perform 256-bit Sha3 on the public key.
 2. Perform 160-bit RipeMD of hash resulting from step 1.
 3. Prepend network version byte to RipeMD hash.
 4. Perform 256-bit Sha3 on the result, take the first four bytes as a checksum.
 5. Concatenate output of step 3 and the checksum from step 4.
 6. Encode result using Base32.

The following example will convert public key obtained above to an address.
0x98 will be used as a network version byte.

    $ export PUBKEY="2e:83:41:40:fd:66:cf:87:b2:54:a6:93:a2:c7:86:2c:81:92:17:b6:76:d3:94:32:67:15:66:25:e8:16:ec:6f"
    $ PART1=$(echo "${PUBKEY}" \
      | sed 's/://g' \
      | xxd -r -p \
      | openssl sha3-256 -binary \
      | openssl ripemd -r 
      | cut -d' ' -f1)
    $ PART2=$(echo "98${PART1}")
    $ CHECKSUM=$(echo "${PART2}" \
      | xxd -r -p \
      | openssl sha3-256 -r \
      | cut -b 1-8)
    $ HEXADDRESS="${PART2}${CHECKSUM}"
    $ echo "${HEXADDRESS}" | xxd -r -p | base32
    TATNE7Q5BITMUTRRN6IB4I7FLSDRDWZA37JGO5UW

Output matches the first entry in `1.test-address.json` file inside test-vectors repository.

## Design Decisions

The main rationale behind this change is the upcoming introduction of TLS inside the server.
It also turned out, that key compatibility is it unwanted by exchanges,
due to security concerns.

These changes also should make interoperability much easier.

## Implementation

The server part of the changes is already available inside catapult-server repository.

Changes will be released as part of 0.9.3.1 build.

## Backwards compatibility

As stated above, the changes are not backward compatible and will require
new nemesis block in the testnet.

## Alternatives

Before introducing this breaking change, other alternatives were considered,
but they are related to TLS introduction and are outside the scope of this document.

## References

* [catapult-server](https://github.com/nemtech/catapult-server/)
* [Symbol Technical Reference](https://nemtech.github.io/catapult-whitepaper/main.pdf)

## History

| **Date**      | **Version**   |
| ------------- | ------------- |
| Feb 06 2020   | 1.0           |

'''
'''--- NIPs/nip-0011.md ---
# NIP 11 - Symbol Configuration Utility (CLI)

## Summary

```
    NIP: 11
    Layer: Application
    Title: Symbol Configuration Utility (CLI)
    Author: Bader Youssef <bader@iodlt.com>
            David Garcia <david.garcia@nem.software>
    Discussions-To: #sig-client
    Comments-URI: https://github.com/nemtech/NIP/issues/35
    Status: Draft
    Type: Standards Track
    Created: 2020-02-03
    License: MIT
```
## Table of contents

- [Introduction](#introduction)
- [Motivation](#motivation)
- [Specification](#specification)
  * [Command layout outline](#command-layout-outline)
    + [network install](#network-install)
    + [network download](#network-download)
    + [network create](#network-create)
    + [node download](#node-download)
    + [node connect](#node-connect)
    + [node changerole](#node-changerole)
    + [node reset](#node-reset)
    + [node stop](#node-stop)
- [Design Decisions](#design-decisions)
- [Implementation](#implementation)
- [References](#references)
- [History](#history)

## Introduction

This NIP defines the specification of a tool to create new chains and connect nodes to existent networks.

## Motivation

The current configuration process of a Symbol blockchain leaves much to be desired.
To configure a Symbol instance, there is either the option of using one of the many pre-configured Docker images, which does not work on all systems (ARM-based devices, older systems), or completely configuring from scratch.

To deploy a Symbol (peer) instance, a user requires to perform the next steps:

1. Download, compile and install catapult-server dependencies.

2. Configure _19_ properties files for a new chain instance and create the nemesis block. For joining an existing chain, the proper properties for that chain (_e.g a testnet_) must be downloaded and placed in the correct path.

3. Configure the node's settings in [`config-node.properties`](https://github.com/nemtech/catapult-server/blob/main/resources/config-node.properties), e.g a philanthropic node setup.

4. Load the `config-extension` files based on node role: `DUAL`, `API`, or `PEER`. For developers, switching and testing different network configurations is often part of the daily workflow.

5. Launch the node.

There is currently no streamlined, easily installable tool to accomplish the above. Attempts were made with [`cat-config-scripts`](https://github.com/IoDLT/cat-config-scripts/) and [`symbol-testnet-bootstrap`](https://github.com/nemgrouplimited/symbol-testnet-bootstrap/) but they do not offer portability. The tool [catapult-service-bootstrap](https://github.com/nemtech/catapult-service-bootstrap) is another great tool to create new networks, but not sufficient to deploy new nodes. 

This NIP solves this problem by offering a CLI utility that streamlines the above into an easy-to-use tool. When implemented and adopted, NIP11 could replace the above-mentioned projects.

## Specification

### Command layout outline

The following is a proposed command tree for the CLI.
Each command should contain a parent command, along with the required parameters.

#### network install*

Download the latest compatible versions of catapult-server and catapult-rest, install the required dependencies, and compiles the server.
The user should be able to define custom endpoints to download the repositories and custom version tags.

USAGE

symbol-bootstrap network install [...options]

OPTIONS

| Option                                | Required | Default                                        | Description                             |
|---------------------------------------|----------|------------------------------------------------|---------------------------------------- |
| ``--server-git <server-git>``         | No       | https://github.com/nemtech/catapult-server.git | Link to catapult-server.                |
| ``--server-version <server-version>`` | No       | e.g. v1.0.0                                    | catapult-server branch or tag.          |
| ``--rest <rest>``                     | No       | https://github.com/nemtech/catapult-rest.git   | Link to catapult-rest.                  |
| ``--rest-version <rest-version>``     | No       | e.g. v1.0.0                                    | catapult-server branch or tag.          |

#### network download

Downloads the recommended network settings, including the nemesis block configurable definition, and peers files from a given url.

`*` Build a separate service to share the default download URLs with randomized values for ``networkGenerationHashSeed``, ``networkMosaicIds``, ``distribution`` list, and ``sinkAddresses``. As a future enhancement, provide a multi-step form to define the nemesis block properties file step by step.

USAGE

symbol-bootstrap network download [...options]

OPTIONS

| Option                              | Required | Default                                | Description                         |
|-------------------------------------|----------|----------------------------------------|-------------------------------------|
| ``--resources <resources>``         | Yes      | http://default.url/resources           | URL  compressed folder.             |
| ``--nemesis-properties <nemesis-properties>``  | No |                                   | URL to nemesis config file.         |
| ``--output <output>``               | No       |./resources                             | Destination folder.                 |

#### network create

Creates the nemesis block inside the ``data`` folder.
Before running the command, configure the nemesis block and [network properties](https://nemtech.github.io/guides/network/configuring-network-properties.html) files.

*Note*: The nemesis block links all the eligible harvesters with random VRF and Voting Keys.
These keys should be returned to the user if the nemesis block is created successfully.

USAGE

symbol-bootstrap network create [...options]

OPTIONS

| Option                              | Required | Default                                | Description                  |
|-------------------------------------|----------|----------------------------------------|------------------------------|
| ``--server <server>``               | No       | ./catapult-server/bin                  | Path to compiled server.     |
| ``--resources <resources>``         | No       | ./resources                            | Path to resources folder.    |
| ``--nemesis-properties <nemesis-properties>``  | No | ./resources/mijin-test.properties | Path to nemesis config file. |
| ``--output <output>``               | No       | ./template                             | Path where ``data``  and ``seed`` folders will be created.  |
| ``--docker``                        | No       |                                        | If set, ``server`` accepts a docker image instead of a path.|

#### node download

Downloads the template files required to start and join a Symbol instance.

The notion of network ``templates`` exists within [`cat-config-scripts`](https://github.com/IoDLT/cat-config-scripts/).
A user should be able to download the resources and nemesis for a specific network as a "template", and specify the path to this template in the configuration file, or via the CLI. A template should follow the following file structure:

```
example-network-template/
.
├── seed
├── data
└── resources
```

Where `data/` contains the active directory for the node to store new chain information, `seed/` contains original nemesis data in the case of a node reset, and `resources` contains network-specific files. Users will be able to download network configurations in this format and load them via the CLI.

USAGE

symbol-bootstrap node download [...options]

OPTIONS

| Option                              | Required | Default                           | Description                           |
|-------------------------------------|----------|-----------------------------------|---------------------------------------|
| ``--template <template>``           | Yes      |                                   | URL to template compressed folder.    |
| ``--output <output>``               | No       | ./template                        | Destination folder.                   |

#### node connect

Launches a Symbol node and connects it to an existent network.
Before running the command, the user should configure the node properties.

USAGE

symbol-bootstrap node connect [...options]

OPTIONS

| Option                              | Required | Default                           | Description               |
|-------------------------------------|----------|-----------------------------------|---------------------------|
| ``--server <server>``               | No       | ./catapult-server/bin             | Path to compiled server.  |
| ``--rest <rest>``                   | No       | ./catapult-rest/                  | Path to rest with dependencies installed. Required if API or Dual Node. |
| ``--resources <resources>``         | No       | ./template/resources              | Path to the resources folder.                    |
| ``--data <data>``                   | No       | ./tempalte/data                   | Path to the data folder.                         |
| ``--seed <seed>``                   | No       | ./template/seed                   | Path to the seed folder.                         |
| ``--certificate <certificate>``     | No       |                                   | Path to the certificates folder. If not set, new self-signed certificates are generated. |
| ``--detach``                        | No       |                                   | Launches the node in the background.             |
| ``--docker``                        | No       |                                   | If set, ``server`` and ``rest`` accepts a docker image instead of a path.|

#### node changerole*

Updates the node role by overwriting the resources configuration files.

USAGE

symbol-bootstrap node changerole [...options]

OPTIONS

| Option                              | Required | Default                           | Description                                                        |
|-------------------------------------|----------|-----------------------------------|--------------------------------------------------------------------|
| ``--resources <resources>``         | No       | ./template/resources              | Path to the resources folder.                                      |
| ``--role <role>``                   | Yes      | peer                              | Overwrites the template configuration. Options: peer, api or dual. |

#### node reset

Resets the data from a local node.

USAGE

symbol-bootstrap node reset

#### node stop

Stops the node.

USAGE

symbol-bootstrap node stop

*Note*: If nodes are not using containers, only one node can be run at a time to avoid having conflicts with ports. If the computer is running a node already, this should be stopped first before running ``connect``. `*` Otherwise, the ``reset`` and ``stop`` commands will have an extra option to pass the node's unique id and an additional command to list all active nodes.

`*` Will most likely not be implemented in the first version(s) of the CLI.	

## Design Decisions

- The CLI application makes the most sense for a cross-platform chain configuration tool. GUI applications cannot always be used in remote server configuration, and bash scripts can be cumbersome.

- The Symbol Configuration Utility will be written in Typescript and use the [Command Design Pattern](https://en.wikipedia.org/wiki/Command_pattern). This pattern suits CLI-style applications very well, as it allows for the command logic to be encapsulated for later use depending on the program's state.

- The NIP11 will be published as an NPM package, and thus installation is the same as any NPM global module. It's possible that this implementation could be integrated into the existing [`symbol-cli`](https://github.com/nemtech/symbol-cli), which also happens to use the same software design pattern as proposed above. In this case, the functionality would be implemented as part of new commands.

## Implementation

There is no implementation yet.

## References

- [catapult-server](https://github.com/nemtech/catapult-server)
- [catapult-rest](https://github.com/nemtech/catapult-rest)
- [cat-config-scripts](https://github.com/IoDLT/cat-config-scripts/)
- [nem2-cli](https://github.com/nemtech/nem2-cli)
- [catapult-service-bootstrap](https://github.com/nemtech/catapult-service-bootstrap)
- [symbol-testnet-bootstrap](https://github.com/nemgrouplimited/symbol-service-bootstrap)

## History

| **Date**     | **Version**    |
| -------------| -------------  |
| Feb 3 2020   | Initial Draft  |
| Jul 7 2020   | Second Draft   |
| Jul 27 2020  | First Revision |

'''
'''--- NIPs/nip-0012.md ---
# NIP 12 - Rebranding

```
    NIP: 12
    Title: Rebranding
    Author: David Garcia <david@nem.foundation>
    Discussions-To: https://github.com/nemtech/NIP/issues/38
    Comments-URI: https://github.com/nemtech/NIP/issues/38
    Status: Draft
    Type: Process
    Created: 2020-02-10
    License: MIT
```

## Table of contents

- [Introduction](#introduction)
- [Specification](#specification)
  * [Packages](#packages)
  * [GitHub Organization](#github-organization)
  * [GitHub Pages](#github-pages)
  * [Ticker](#ticker)
  * [Continuous Integration](#continuous-integration)
  * [Redesign](#redesign)
- [Design Decisions](#design-decisions)
- [Implementation](#implementation)
  * [Milestone 1](#milestone-1)
  * [Milestone 2](#milestone-2)
  * [Milestone 3](#milestone-3)
  * [Milestone 4 (under discussion)](#milestone-4--under-discussion-)
  * [Milestone 5](#milestone-5)
- [Backwards Compatibility](#backwards-compatibility)
- [References](#references)
- [History](#history)

## Introduction

The Migration Steering Committee has conducted the process of creating a [new brand](https://forum.nem.io/c/catapult-branding) for Catapult. The new brand "Symbol from NEM" has been [supported by the community](https://explorer.nemtool.com/#/poll?id=5e2eaab5328dc579fdadcef3) together with the ticker [XYM](https://explorer.nemtool.com/#/poll?id=5e2eaab5328dc579fdadcef3).

The objective of this NIP is to coordinate efforts to rename all repositories under the ``nemtech`` organization on GitHub.

## Specification

### Packages

The names of the repositories, URLs, and installable packages names will be edited as follows:

| Previous   | New        |
|------------|------------|
| nem2-      | symbol-    |
| catapult-* | symbol-    |
| Catapult   | Symbol     |

All ``nem2-*`` related packages will be removed from ``npmjs`` and ``maven`` to prevent users installing and old version of the package by mistake.

### GitHub Organization

The organization will remain as  ``nemtech``. In the future, high-quality NIS projects can be supported.

### GitHub Pages

The ``nemtech`` organization will preserve the repository ``nemtech.github.io`` to redirect GitHub pages related links (e.g. symbol-docs, SDK references, symbol-openapi) to the new domain ``https://docs.symbolplatform.com``.

### Ticker

Hardcoded references to ``nem.xem`` have to be replaced for ``symbol.xym``. For references to private networks using the default network currency, ``cat.currency`` will still be used.

### Continuous Integration

Some external services might need to be reconfigured manually per repository, including:

* TravisCI
* Coveralls

Each sig organizer should give priority to add again the services required to merge new PRs into master (e.g., testing pipelines) before adding new features to each project.

### Redesign

If necessary, adapt colors, fonts, and logo accordingly to the latest [brand update](https://forum.nem.io/t/symbol-brand-update/24305).

It is recommended that each repository creates a separate branch to start applying the redesign without interfering with other incoming features.

## Design Decisions

The specification proposed tries to minimize 404 errors when accessing to old links.
Github will [automatically redirect](https://github.blog/2013-05-16-repository-redirects-are-here/) the previous links to the new URLS.

## Implementation

For each project, a new issue named "Rebranding" will be created with the following tasks list:

    * [ ] Rebranding branch created
    * [ ] New design applied (font, logos, colors)
    * [ ] Codename references renamed
    * [ ] Ticker references renamed
    * [ ] Links reviewed
    * [ ] README reviewed
    * [ ] PR created
    * [ ] Package renamed
    * [ ] Package deployed/tag created

### Milestone 1

Target repositories:

* [x] nem2-sdk-typescript-javascript
* [x] nem2-openapi
* [x] nemstudios/nem2-open-api-generator (migrated GitHub & npm nemtech org)
* [x] nemstudios/catbuffer-generator (migrated to npm nemtech org)
* [x] nem2-sdk-java

### Milestone 2

Target repositories:

* [x] nem2-docs
* [x] nem2-cli
* [x] nemfoundation/symbol-desktop-wallet
* [x] nemfoundation/nem2-explorer

### Milestone 3

Target repositories:

* [ ] nem2-e2e-tests
* [ ] nem2-scenarios
* [x] nemfoundation/nem2-uri-scheme
* [x] nemfoundation/nem2-hd-wallets
* [x] nemfoundation/nem2-qrlibrary

### Milestone 4 (under discussion)

Target repositories:

* [ ] catapult-server
* [ ] catapult-rest
* [ ] catapult-service-bootstrap
* [ ] catapult-whitepaper
* [ ] catbuffer

``*`` At this moment, there are no plans to rename ``catapult-server`` nor ``catapult-rest`` repositories.

### Milestone 5

* [x] new domain added
* [x] CI services migrated 

## Backwards Compatibility

By approving this proposal, it is assumed that:

- It might not be possible to migrate every link.
- It might penalize the project's SEO.

Nevertheless, it is preferable in the long term to have consistent branding. Applying those changes sooner than later will cause fewer redirections in the future.

## References

* [Catapult brand updates](https://forum.nem.io/t/catapult-brand-update-1/23875/)
* [Transferring a repository](https://help.github.com/en/github/administering-a-repository/transferring-a-repository)
* [Transferring organization ownership](https://help.github.com/en/github/setting-up-and-managing-organizations-and-teams/transferring-organization-ownership)
* [GitHub repositories redirections](https://github.blog/2013-05-16-repository-redirects-are-here/)

## History

| **Date**      | **Version**   |
| ------------- | ------------- |
| Feb 10 2020   | 1.0           |

'''
'''--- NIPs/nip-0013.md ---
# NIP 13 - Security Token Standard

```
    NIP: 13
    Layer: Library
    Title: Security Token Standard
    Author: Gregory Saive <greg@nem.foundation>
    Discussions-To: https://github.com/nemtech/NIP/issues/42
    Comments-URI: https://github.com/nemtech/NIP/issues/42
    Status: Draft
    Type: Standards Track
    Created: 2019-07-29
    License: Apache-2.0
```

## Table of contents

- [Introduction](#introduction)
- [Motivation](#motivation)
- [Rationale](#rationale)
  * [Partially Fungible Tokens](#partially-fungible-tokens)
- [Specification](#specification)
  * [Requirements](#requirements)
  * [Terminology](#terminology)
  * [Features Description](#features-description)
  * [Deterministic Accounts](#deterministic-accounts)
  * [Target Mosaic](#target-mosaic)
  * [Token Commands](#token-commands)
  * [Token Restrictions](#token-restrictions)
  * [Token Metadata](#token-metadata)
  * [Reason Codes](#reason-codes)
- [Design Decisions](#design-decisions)
  * [1. Namespaced Standards](#1--namespaced-standards)
  * [2. Standard Submodules](#2--standard-submodules)
  * [3. Disposability and re-use](#3--disposability-and-re-use)
  * [4. Network agnostic](#4--network-agnostic)
  * [5. Deterministic accounts](5--deterministic-accounts)
  * [6. Reason Codes](6--reason-codes)
- [Implementation](#implementation)
  * [Packaging Proposal](#packaging-proposal)
  * [Architecture Proposal](#architecture-proposal)
  * [Implementation Proposal](#implementation-proposal)
    + [Interfaces](#interfaces)
    + [Symbol Transactions](#symbol-transactions)
  * [Example Library Usage](#example-library-usage)
  * [Requirements Compliancy](#requirements-compliancy)
  * [Ongoing Work](#ongoing-work)
- [Backwards compatibility](#backwards-compatibility)
- [References](#references)
- [History](#history)

## Introduction

This document aims to provide with a **standard** for _issuance_ and _management_ of **security tokens** on Symbol. This standard will be structured as such that _standard interfaces_ will be defined to facilitate _operations_ and _interrogations_ related to security tokens.

## Motivation 

Facilitate and accelerate the processes of _issuance_ and _management_ of security tokens on Symbol.

To issue and manage securities on Symbol, this standard will leverage several Symbol features. Implementation details will be described in a document jointly to this standard definition.

## Rationale

Security token transfers can fail for different reasons in contrast to utility tokens. As for utility tokens it generally requires only the sender to have a sufficient balance.

> ... [The conditions for failure] could be related to metadata of the securities being transferred (i.e. whether they are subject to a lock-up period), the identity of the sender and receiver of the securities (i.e. whether they have been through a KYC process, whether they are accredited or an affiliate of the issuer) or for reasons unrelated to the specific transfer but instead set at the token level (i.e. the token contract enforces a maximum number of investors or a cap on the percentage held by any single investor).

For tokens representing securities, this standard introduces a function `canTransfer` which provides a general purpose path to achieve this when _the reasons for failure of a transfer are more complex_; _and/or a function of the whole transfer_ (i.e. includes any data sent with the transfer and the receiver of the securities).

Quoted: [ERC#1400 `Security Token Standard`][erc-1400]

### Partially Fungible Tokens

Security tokens can be used to represent many types of assets which need to have _differentiating data_ attached to them and/or signed.

This additional metadata - when added at a token level - implicitely renders these securities _non-fungible_, but in practice said data will be applied to a _subset of the security_ rather than an individual security.

With this standard, we introduce the ability to **partition** a token holder's balance intro partitions, _each with separate metadata_. 

> A token holder's balance may be split in two: those tokens issued during the primary issuance, and those received through secondary trading.

> Security token contracts can reference this metadata in order to apply additional logic to determine whether or not a transfer is valid, and determine the metadata that should be associated with the tokens once transferred into the receiver's balance.

Quoted: [ERC#1400 `Security Token Standard`][erc-1400]

## Specification

### Requirements

The security token standards to be described in this document will be based on features available with [Symbol][symbol] networks. Additionally, for each standard, we will define requirements that will apply to the underlying asset class.

> In aggregate provides a suite of standard interfaces for issuing / redeeming security tokens, managing their ownership and transfer restrictions and providing transparency to token holders on how different subsets of their token balance behave with respect to transfer restrictions, rights and obligations.In aggregate provides a suite of standard interfaces for issuing / redeeming security tokens, managing their ownership and transfer restrictions and providing transparency to token holders on how different subsets of their token balance behave with respect to transfer restrictions, rights and obligations.

- MUST have a standard interface to query feasibility of a transfer and return a reason for failures.
- MUST be able to perform forced transfer for legal action or fund recovery.
- MUST define standard notifications for issuance and redemption processes.
- MUST be able to attach metadata to a **subset of a token holder's balance**.
- MUST be able to modify metadata at time of transfer based on off-chain data, on-chain data and the parameters of the transfer.
- MUST support querying and subscribing to updates on any relevant documentation for the security.
- MAY require signed data to be passed into a transfer transaction in order to validate it on-chain.
- SHOULD NOT restrict the range of asset classes across jurisdictions which can be represented.

Source: [ERC#1400 `Security Token Standard`][erc-1400]

### Terminology

A **token** is represented by a multitude of features available with Symbol. This includes _mosaics_, _multi-signature accounts_, _namespaces_ and _metadata_.

A **token authority** is used to list tokens. One _token authority_ can list many _tokens_. There will be many token authorities (registrars) created with the sole purpose of listing tokens. In a future iteration, _token authorities_ may need to verify the creation of tokens they will be listing.

A **token operator** must have permissions to digitally _govern_ published tokens. There can be many operators for one token and the list of operators can change with the execution of some _token commands_.

A **token command** can be executed by _operators_ for their published _tokens_. A list of available token commands can be found [here](#token-commands).

A **token source** represents the original network of issuance of said token. Typically, the source for a security token represents the _exchange_ where the shares have been issued. In a digital environment it is probable that the source of tokens will require an annexed list of _verified sources_.

A **target account** is a deterministically created account that must be converted to a _multi-signature account_ where _cosignatories_ are **token operators**.

A **target mosaic** is a mosaic that is published to the network after the execution of the token command `CreateToken`. The **target mosaic** is owned by the **target account** and therefor _governed_ by the **token operators**.

A **token partition** represents _all or part of the token balance of a **token holder**_. One token partition can be _owned by one token owner_. The assignment of partitions can be tracked using a special transfer transaction signed by the _target account_.

For each **token partition**, there will be **one added multi-signature account** of which _token operator accounts_ are made cosignatories.

A **token holder** can be any account on Symbol networks which is not a **target account**, nor one of the listed **token operator**, nor one of the listed **token partitions**. Also, **token holders** may be subject to application-level verifications/constraints that authorize or deny the access to said security tokens.

### Features Description

Following features table will be used to define mandatory features of the published software package:

| Feature | Motivation | NIP13 Status |
| --- | --- | --- |
| Issuance | Issuance of security tokens is managed through `owner` | :white_check_mark: |
| Issuer Power Delegation | `Operators` can be allowed specific management tasks of the security tokens | :white_check_mark: |
| Transfer |  Security tokens can be transferred (change ownership) | :white_check_mark: |
| Batch Transfer | Security tokens can be transferred in batches (change ownership) | :white_check_mark: |
| Transfer with Metadata | Metadata can be added to transfers of security tokens | :white_check_mark: |
| Metadata management | Metadata can be managed for security tokens | :white_check_mark: |
| Transfer restrictions | Transfers of security tokens can be restricted (constraints) | :white_check_mark: |
| Freeze/Lock | Security token balances can be frozen/locked by `operators` | :white_check_mark: |
| Operator enforcement | `Operators` can be allowed tasks enforcements (such as transfers) | :white_check_mark: |
| Force Transfer | Transfers of security tokens can be **enforced**. | :white_check_mark: |
| Error signaling | Error signaling is described for each Standard | :white_check_mark: |
| Document management | Documents can be attached to security tokens [ownerships] | :white_check_mark: |

### Deterministic Accounts

This standard assumes the usage of the [`symbol-hd-wallets`][src-hd] package for keys derivation.

A **token authority** serves the purpose of _listing tokens_. It can be used for a token registrar (e.g. An exchange) to _verify a token listings before they are listed_. Each _token authority_ shall be created with a separate 24-words BIP39 mnemonic pass phrase.

A **target account** is a deterministic account that is generated and then converted to multi-signature accounts as such that it is _governed by token operators_. After conversion, the private key of said deterministic account **cannot be used for signatures creation or transactions execution**. Each _target account_ shall be created with a separate 24-words BIP39 mnemonic pass phrase.

The derivation paths used to generate said deterministic accounts are as follows:

- **Token Authority**: **m/44'/4343'/1313'/1313'/1313'**
- **Target Account**: **m/44'/4343'/1313'/0'/0'**
- **Token Holder Partitions**: **m/44'/4343'/1313'/0'/{PARTITION_ID}'**

:warning: More details to be added about the generation of a `PARTITION_ID`. The current solution uses only 3 bytes of data to generate the partition id. This may change over the next iterations.

### Target Mosaic

With the creation of a security token follows the creation of a **target mosaic** on Symbol distributed ledger network(s).

NIP13 compliant mosaics SHOULD use their **token identifier** as a **nonce** when creating the mosaic. This feature is part of the `CreateToken` token command.

Also, NIP13 compliant mosaics MUST be configured to be **restrictable** and **non-transferrable** on the Symbol network of issuance. This feature is part of the `CreateToken` token command.

Additional restrictions and metadata MUST be attached as described in the following sections:

- [Token Restrictions](#token-restrictions)
- [Token Metadata](#token-metadata)

### Token Commands

Token Standards introduce the term of **commands** that are executed for specific tokens. For instance, the transfer of token happens by _executing the command TransferOwnership_ for said token.

This concept of _commands_ will be available for all Token Standards. As such we will define a list of commands that will also be technically defined in the implementation details.

| Token Command | Rationale |
| --- | --- |
| **CreateToken** | Create a security token (non-reversible) |
| **CreatePartition** | Create a partition that will own a (portion of a) token holder balance | 
| **TransferOwnership** | Transfer a token to a new owner (Also used for issuance to single recipient) |
| **TransferOwnershipWithData** | Transfer a token to a new owner, adding signed data as a message |
| **BatchTransferOwnership** | Batch Transfer tokens to new owners |
| **BatchTransferOwnershipWithData** | Batch Transfer tokens to new owners, adding signed data as a message |
| **ForcedTransfer** | Force the transfer of a token to a new owner, with an operator account |
| **LockBalance** | Freeze / Lock a token balance (full or part of partition) |
| **UnlockBalance** | Unfreeze / Unlock a token balance (full or part of partition) |
| **ModifyRestriction** | Send modifications to account/mosaic restrictions |
| **ModifyMetadata** | Send modifications to account/mosaic metadata |
| **DelegateIssuerPower** | Delegate issuance authorizations to (new) operator(s) account(s) |
| **RevokeIssuerPower** | Revoke issuance authorizations of operator(s) account(s) |
| **AttachDocument** | Attach documents to a token instance |

### Token Restrictions

> **Token restrictions** MUST leverage [_Symbol mosaic restrictions features_](https://nemtech.github.io/concepts/mosaic-restriction.html).

1. A **target account** MUST be configured with following **account mosaic restrictions**:

- Add account mosaic restriction with flag `AllowMosaic` for said security token mosaic id.
- Add account mosaic restriction with flag `AllowMosaic` for the network currency mosaic id.

2. A **target mosaic** MUST be configured with following **mosaic global restriction**:

- Add mosaic global restriction of type `LE` (less or equal) with value `2` and key `User_Role`.
  * Proposed possible values includes: [1 = Target, 2 = Holder, 3 = Guest, 4 = Locked].

3. A **target mosaic** MUST be configured with following **mosaic address restrictions**:

- Add mosaic address restriction with value `1` (1 = Target) for _target account_.
- Add mosaic address restriction with value `2` (2 = Holder) for _each token partition_ - if any available.

4. A **token partition** MUST be configured with following **account mosaic restrictions**:

- Add account mosaic restriction with flag `AllowMosaic` for said security token mosaic id.
- Add account mosaic restriction with flag `AllowMosaic` for the network currency mosaic id.

### Token Metadata

> **Token metadata** MUST leverage [_Symbol metadata features_](https://nemtech.github.io/concepts/metadata.html).

1. A **target account** MUST be configured with the following **account metadata**:

- Add account metadata with key `NIP13` and value being the _token identifier_.

2. A **target mosaic** MUST be configured with the following **mosaic metadata**:

- Add mosaic metadata with key `NIP13` and value being the _token identifier_.
- Add mosaic metadata with key `NAME` and value being the _name of the financial instrument_.

3. (Optional) A **target mosaic** SHOULD be configured with the following **mosaic metadata**:

- Add mosaic metadata with key `MIC` and value being the _Market Identifier Code of the financial instrument_.
- Add mosaic metadata with key `ISIN` and value being the _International Securities Identification Number (ISIN) of the financial instrument_.
- Add mosaic metadata with key `ISO_10962` and value being the _classification of the financial instrument as described in ISO_10962_.

4. A **token partition** MUST be configured with the following **account metadata**:

- Add mosaic metadata with key `NAME` and value being the _name of the token partition_.

### Reason Codes

In an attempt to make the token holder experience better, the provided `canTransfer` function MUST return a _reason byte code_ on success or failure based on the NIP-13 application-specific status codes specified in [Annex 1: Reason Codes][annex-1].

An implementation can also return arbitrary data as a `uint8_t` to provide additional information not captured by the reason code.

> Codes break nicely into a 16x16 matrix, represented as a 2-digit hex number. The high nibble represents the code’s kind or “category”, and the low nibble contains the state or “reason”. We present them below as separate tables per range for explanatory and layout reasons.

Codes are defined in following categories:

- **`0x0*` Generic Failure Codes**
- **`0x1*` Permission and Control**
- **`0x2*` Find, Inequalities and Ranges**
- **`0x3*` Negotiation and Governance**
- **`0x4*` Availability and Time**
- **`0x5*` Tokens, Funds and Finance**
- **`0xA*` Application-specific Codes**
- **`0xE*` Encryption, Identity and Proofs**

## Design Decisions

### 1. Namespaced Standards

Because each of the Token Standards will behave differently from others with regards to feature set integrations, we will implement commands in such a way that each standard can define its own extension to the standard command execution flow.

Commands will be grouped in **native modules** that are then exported such that each Token Standard can implement commands with its own feature set integration practises.

### 2. Standard Submodules

Due to the fact that token standards will be _namespaced_ and reside within there own folder inside the `src/standards/` folder, it is possible that subsequent token standards would be added to the package in the form of git submodules.

A new token standard that is to be implemented will typically be discussed and defined in a NIP.

### 3. Disposability and re-use

The delivered package will provide with several disposable and re-usable securities contracts that can be executed to manage securities on Symbol networks.

All types of Symbol objects MAY be used to implement a token standard. The `symbol-token-standards` library should bundle transactions inside _aggregate bonded transactions_ and MUST produce **[NIP2 compliant transaction URIs][doc-nip2]** to be executed _in secure environments_.

### 4. Network agnostic

Token standards that are implemented into `symbol-token-standards` MUST be network agnostic in that they MUST permit to issue and manage securities on any Symbol network.

The network variable is an important one when discussing the issuance of security tokens, as such a `NIP13.TokenSource` class is provided that is linked to security tokens upon their creation. The source of a token represents the original network of issuance of said token.

### 5. Deterministic accounts

The draft implementation of NIP 13 includes the usage of `symbol-hd-wallets` to derive deterministic **target accounts**, **operator accounts** and **partition accounts** that are later converted to multi-signature accounts.

More details will be described about the management of deterministic accounts that are generated within the scope of NIP 13.

### 6. Reason Codes

We intentionally re-used reason codes from the [EIP-1066: Reason Codes][eip-1066] in order to provide with better interoperability caracteristics for our defined security token standards.

Credits go to the contributors of the Ethereum Improvement Proposal for the mapping of a 16x16 matrix describing categorized reason codes that the `canTransfer()` functionality MUST use for notifications and communication purposes.

## Implementation

This document defines a **Security Token Standard**.

Defined standards will leverage different feature sets of Symbol networks. More detailed implementation details will be described here.

In order to generalize and facilitate security token issuance and management with Symbol, we will publish **one software package** that integrates _all Token Standards_. The first token standard will be namespaced under `NIP13` namespace name.

Each of our token standards will be implementing features differently as to be more flexible and allow a broader scope of integrations or use case implementations.

The released software package will be developed with Typescript, using the [symbol-sdk@>=0.18.0][src-sdk] package to integrate latest Symbol features. The library MUST provide with interfaces and classes, which developers can leverage to manage issuance and redemptions of security tokens on Symbol.

As a proof of concept for this library, we MAY introduce either of a command line interface (CLI) or a basic web application to provide with out-of-the-box Security Token support for Symbol.

### Packaging Proposal

A deliverable package will be produced along with this NIP.

Following are the available package name suggestions, more may be added at a later point:

- [ ] ~~`symbol-token-standards`~~
- [ ] ~~`symbol-financial-instruments`~~
- [ ] ~~`symbol-financial-tools`~~
- [ ] ~~`symbol-derivatives`~~
- [ ] ~~`symbol-instruments`~~
- [x] `symbol-token-standards`

The decision making process for this package name selection will be made internally, more suggestions are welcome.

### Architecture Proposal

Each of our Security Token Standards will implement features with a pre-defined feature set of Symbol. This is important to note as this knowledge will influence the architecture of the release package. Following solution proposal can be applied:

```
- package.json
> src/
  > interfaces/
    - Standard.ts
    - Command.ts
    - Context.ts
  > standards/
    > NIP13/
      > commands/
        - CreateToken.ts
        - TransferOwnership.ts
        - AttachDocument.ts
    - NIP13.ts
  > models/
    - AllowanceResult.ts
    - etc.
```

### Implementation Proposal

#### Interfaces

- A `Standard` interface is defined that MUST contain following methods:

```javascript
/**
 * @interface Standard
 * @description Interface that describes security token standards.
 */
export interface Standard {
  /**
   * @description The network configuration object.
   */
  readonly network: NetworkConfig

  /**
   * @description The token identifier
   */
  readonly identifier: TokenIdentifier

  /**
   * Synchronize the command execution with the network. This method shall
   * be used to fetch data required for execution.
   *
   * @async
   * @return {Promise<boolean>}
   */
  synchronize(): Promise<boolean>

  /**
   * Notify an account `account` about `notification`
   *
   * @param   {TokenIdentifier} tokenId
   * @param   {PublicAccount}   account
   * @param   {Notification}    notification
   * @param   {TransactionParameters} parameters
   * @return  {NotificationProof}
   **/
  notify(
    tokenId: TokenIdentifier,
    account: PublicAccount,
    notification: Notification,
    parameters: TransactionParameters,
  ): NotificationProof

  /**
   * Verifies **allowance** of `sender` to transfer `tokenId` security token
   * to `recipient` with a number of shares attached of `amount`.
   *
   * @param   {TokenIdentifier} tokenId
   * @param   {PublicAccount}   sender
   * @param   {PublicAccount}   recipient
   * @param   {number}          amount
   * @return  {AllowanceResult}
   **/
  canTransfer(
    tokenId: TokenIdentifier,
    sender: PublicAccount,
    recipient: PublicAccount,
    amount: number,
  ): AllowanceResult

  /**
   * Verifies **allowance** of `operator` to execute `command` with `tokenId` security token.
   *
   * @internal This method MUST use the `Command.canExecute()` method.
   * @param   {PublicAccount}         actor
   * @param   {TokenIdentifier}       tokenId
   * @param   {string}                command
   * @param   {Array<CommandOption>}  argv
   * @return  {AllowanceResult}
   **/
  canExecute(
    actor: PublicAccount,
    tokenId: TokenIdentifier,
    command: string,
    argv: CommandOption[]
  ): AllowanceResult

  /**
   * Execute `command` for Security Token with identifier `tokenId`. Arguments
   * the command execution can be passed in `argv`.
   * 
   * This method MUST call the `synchronize()` method.
   *
   * @internal This method MUST use the `Command.execute()` method.
   * @param   {PublicAccount}         actor
   * @param   {TokenIdentifier}       tokenId
   * @param   {string}                command
   * @param   {TransactionParameters} parameters
   * @param   {Array<CommandOption>}  argv
   * @return  {Promise<TransactionURI>}
   **/
  execute(
    actor: PublicAccount,
    tokenId: TokenIdentifier,
    command: string,
    parameters: TransactionParameters,
    argv: CommandOption[],
  ): Promise<TransactionURI>

  /**
   * Execute `command` for Security Token with identifier `tokenId`. Arguments
   * the command execution can be passed in `argv`.
   * 
   * This method MUST NOT call the `synchronize()` method.
   *
   * @internal This method MUST use the `Command.execute()` method.
   * @param   {PublicAccount}         actor
   * @param   {TokenIdentifier}       tokenId
   * @param   {string}                command
   * @param   {TransactionParameters} parameters
   * @param   {Array<CommandOption>}  argv
   * @return  {TransactionURI}
   **/
  executeWithoutSync(
    actor: PublicAccount,
    tokenId: TokenIdentifier,
    command: string,
    parameters: TransactionParameters,
    argv: CommandOption[],
  ): TransactionURI
}
```

Classes implementing the `Standard` interface MUST make use of the `symbol-sdk` package to leverage Catapult features.

- A `Command` interface is defined that MUST contain following methods:

```javascript
/**
 * @interface Command
 * @description Interface that describes token commands.
 * @link https://github.com/nemtech/NIP/blob/master/NIPs/nip-0013.md#token-commands
 */
export interface Command {
  /**
   * @description The command name
   */
  readonly name: string

  /**
   * @description The command execution context
   */
  readonly context: Context

  /**
   * @description The command on-chain descriptor
   */
  readonly descriptor: string

  /**
   * Verifies **allowance** of `actor` to execute command.  Arguments to
   * the command execution can be passed in `argv`.
   *
   * @param   {PublicAccount}                actor
   * @param   {Array<CommandOption>}   argv
   * @return  {AllowanceResult}
   **/
  canExecute(
    actor: PublicAccount,
    argv: CommandOption[] | undefined,
  ): AllowanceResult

  /**
   * Execute the command with `actor` operator account. Arguments to
   * the command execution can be passed in `argv`.
   *
   * @param   {PublicAccount}           actor
   * @param   {Array<CommandOption>}    argv
   * @return  {TransactionURI}
   **/
  execute(
    actor: PublicAccount,
    argv: CommandOption[] | undefined,
  ): TransactionURI
}
```

Classes implementing the `Command` interface MUST make use of the `symbol-sdk` package to leverage Catapult features.

#### Symbol Transactions

This section SHOULD reflect the implementation proposal in [Source code for `symbol-token-standards` Library][src-nip13] and MUST list each token command's **descriptor**, **arguments** (input) and specify a **list of transactions** that will be wrapped inside an aggregate bonded transaction for the multiple parties to be able to take action on actions related to given security tokens.

#### Token command `CreateToken`

**Descriptor**: `NIP13(v1):create:6da3dbfc:8324B7C0A4F1F1E:no-name` with `6da3dbfc` that represents the _token identifier_, `8324B7C0A4F1F1E` that represents the created mosaic id and `no-name` that represents the security token name.

**Input**: This token command accepts the following arguments:

| Argument | Description | Example |
| --- | --- | --- |
| `name` | Name of the security token | `"NIP13 Example"` |
| `source` | Source network | `"Symbol Mainnet"` |
| `authority` | Token Authority account | `new PublicAccount(...)` |
| `operators` | Security Token Operators | `[new PublicAccount(...)]` |
| `supply` | Total number of outstanding shares | `123456` |
| `metadata` | Metadata associated at token level | `{'MIC': 'XNAS', ...}` |

**Output**: This token command prepares one aggregate bonded transaction with following inner transactions:

| Index | Transaction type | Description
| --- | --- | --- |
| 01 | MultisigAccountModificationTransaction | Converting **target** account to multisig with operators as cosignatories |
| 02 | AccountMetadataTransaction | Attaching `NIP13` token identifier |
| 03 | NamespaceRegistrationtTransaction | Registering namespace to be linked with target mosaic |
| 04 | MosaicDefinitionTransaction | Registering target mosaic |
| 05 | MosaicSupplyChangeTransaction | Adding total number of outstanding shares |
| 06 | MosaicAliasTransaction | Linking previously created namespace to target mosaic |
| 07 | MosaicMetadataTransaction | Attaching `NIP13` token identifier |
| 08 | MosaicMetadataTransaction | Attaching `NAME` security name |
| 09 | MosaicMetadataTransaction | Attaching `MIC` market identifier code |
| 10 | MosaicMetadataTransaction | Attaching `ISIN` if non-empty option provided |
| 11 | MosaicMetadataTransaction | Attaching `ISO_10962` if non-empty option provided |
| 12 | MosaicMetadataTransaction | Attaching `Website` if non-empty option provided |
| 13 | MosaicMetadataTransaction | Attaching `Sector` if non-empty option provided |
| 14 | MosaicMetadataTransaction | Attaching `Industry` if non-empty option provided |
| 15 | MosaicMetadataTransaction | Attaching custom metadata if non-empty option provided |
| 16 | AccountMosaicRestrictionTransaction | Adding target account allowance for target mosaic and network fee mosaic |
| 17 | MosaicGlobalRestriction | Adding token level restriction for `User_Role` <= 3 |
| 18 | MosaicAddressRestriction | Adding account level restriction value for `User_Role` with `1` (1 = Target) |
| 19 | TransferTransaction | Execution proof with NIP13 `CreateToken` descriptor |

:warning: `Transaction 03` represents the root namespace registration transaction. Any sub namespace registration transaction will be automatically added to this list.

:warning: `Transaction 09` will be added if a non-empty value is provided for the `mic` metadata field.

:warning: `Transaction 10` will be added if a non-empty value is provided for the `isin` metadata field.

:warning: `Transaction 11` will be added if a non-empty value is provided for the `iso10962` metadata field.

:warning: `Transaction 12` will be added if a non-empty value is provided for the `website` metadata field.

:warning: `Transaction 13` will be added if a non-empty value is provided for the `sector` metadata field.

:warning: `Transaction 14` will be added if a non-empty value is provided for the `industry` metadata field.

:warning: `Transaction 15` will be added if a non-empty value is provided for the custom metadata field.

#### Token command `CreatePartition`

**Descriptor**: `NIP13(v1):partition:6da3dbfc:default` with `6da3dbfc` said _token identifier_ and `default` the partition name.

**Input**: This token command accepts the following arguments:

| Argument | Description | Example |
| --- | --- | --- |
| `name` | Name of the token holder partition | `"NIP13 Example"` |
| `partition` | Token holder partition account | `new PublicAccount(...)` |
| `holder` | Actual token holder public account | `new PublicAccount(...)` |

:warning: The token holder _partition account_ and the _token holder account_ **MUST be public accounts** - a.k.a. must be known by the network. The account must have signed and announced at least one transaction before it is possible to execute this command.

**Output**: This token command prepares one aggregate bonded transaction with following inner transactions:

| Index | Transaction type | Description
| --- | --- | --- |
| 01 | MultisigAccountModificationTransaction | Converting **partition** account to multisig with operators and **token holder** as cosignatories |
| 02 | AccountMetadataTransaction | Attaching `NAME` partition name |
| 03 | AccountMosaicRestrictionTransaction | Adding partition account allowance for target mosaic and network fee mosaic |
| 04 | MosaicAddressRestriction | Adding account level restriction value for `User_Role` with `2` (2 = Holder) |
| 05 | TransferTransaction | Execution proof with NIP13 `CreatePartition` descriptor |

#### Token command `TransferOwnership`

**Descriptor**: `NIP13(v1):transfer:6da3dbfc` with `6da3dbfc` said _token identifier_.

**Input**: This token command accepts the following arguments:

| Argument | Description | Example |
| --- | --- | --- |
| `sender` | Sender token holder partition account (or use target account) | `new PublicAccount(...)` |
| `recipient` | Recipient token holder partition account | `new PublicAccount(...)` |
| `amount` | Number of shares to be transferred | `1` |

**Output**: This token command prepares one aggregate bonded transaction with following inner transactions:

**1) Sending from _target account_**

| Index | Transaction type | Description
| --- | --- | --- |
| 1.01 | TransferTransaction | Ownership transfer transaction |

**2) Sending from _partition account_**

| Index | Transaction type | Description
| --- | --- | --- |
| 2.01 | TransferTransaction | Send back funds to _target account_ (non-transferrable mosaics) |
| 2.02 | TransferTransaction | Ownership transfer transaction |

#### Token command `TransferOwnershipWithData`

**Descriptor**: `NIP13(v1):data:6da3dbfc` with `6da3dbfc` said _token identifier_.

**Input**: This token command accepts the following arguments:

| Argument | Description | Example |
| --- | --- | --- |
| `sender` | Sender token holder partition account | `new PublicAccount(...)` |
| `recipient` | Recipient token holder partition account | `new PublicAccount(...)` |
| `amount` | Number of shares to be transferred | `1` |
| `data` | Plain text or encrypted data to attach | `Hello, world!` |

**Output**: This token command prepares one aggregate bonded transaction with following inner transactions:

**1) Sending from _target account_**

| Index | Transaction type | Description
| --- | --- | --- |
| 1.01 | TransferTransaction | Ownership transfer transaction |
| 1.02 | TransferTransaction | Execution proof with NIP13 `TransferOwnershipWithData` descriptor |
| 1.03 | TransferTransaction | Attaching data as a message |

**2) Sending from _partition account_**

| Index | Transaction type | Description
| --- | --- | --- |
| 2.01 | TransferTransaction | Send back funds to _target account_ (non-transferrable mosaics) |
| 2.02 | TransferTransaction | Ownership transfer transaction |
| 2.02 | TransferTransaction | Execution proof with NIP13 `TransferOwnershipWithData` descriptor |
| 2.03 | TransferTransaction | Attaching data as a message |

#### Token command `BatchTransferOwnership`

**Descriptor**: `NIP13(v1):batch:6da3dbfc` with `6da3dbfc` said _token identifier_.

**Input**: This token command accepts the following arguments:

| Argument | Description | Example |
| --- | --- | --- |
| `sender` | Sender token holder partition account | `new PublicAccount(...)` |
| `recipients` | Recipient token holder partition accounts | `[new PublicAccount(...)]` |
| `amount` | Number of shares to be transferred | `1` |

**Output**: This token command prepares one aggregate bonded transaction with following inner transactions:

**1) Sending from _target account_**

| Index | Transaction type | Description
| --- | --- | --- |
| 1.01 | TransferTransaction | Execution proof with NIP13 `BatchTransferOwnership` descriptor |
| 1.02 | TransferTransaction | Ownership transfer transaction |

**2) Sending from _partition account_**

| Index | Transaction type | Description
| --- | --- | --- |
| 2.01 | TransferTransaction | Execution proof with NIP13 `BatchTransferOwnership` descriptor |
| 2.02 | TransferTransaction | Send back funds to _target account_ (non-transferrable mosaics) |
| 2.03 | TransferTransaction | Ownership transfer transaction |

:warning: `Transaction 1.02` will be repeated for each valid partition account given in the `recipients` arguments.

:warning: `Transaction 2.03` will be repeated for each valid partition account given in the `recipients` arguments.

#### Token command `BatchTransferOwnershipWithData`

**Descriptor**: `NIP13(v1):batch:6da3dbfc` with `6da3dbfc` said _token identifier_.

**Input**: This token command accepts the following arguments:

| Argument | Description | Example |
| --- | --- | --- |
| `sender` | Sender token holder partition account | `new PublicAccount(...)` |
| `recipients` | Recipient token holder partition accounts | `[new PublicAccount(...)]` |
| `amount` | Number of shares to be transferred | `1` |
| `data` | Plain text or encrypted data to attach | `Hello, world!` |

**Output**: This token command prepares one aggregate bonded transaction with following inner transactions:

**1) Sending from _target account_**

| Index | Transaction type | Description
| --- | --- | --- |
| 1.01 | TransferTransaction | Execution proof with NIP13 `BatchTransferOwnership` descriptor |
| 1.02 | TransferTransaction | Ownership transfer transaction |
| 1.03 | TransferTransaction | Execution proof with NIP13 `TransferOwnershipWithData` descriptor |
| 1.04 | TransferTransaction | Attaching data as a message |

**2) Sending from _partition account_**

| Index | Transaction type | Description
| --- | --- | --- |
| 2.01 | TransferTransaction | Execution proof with NIP13 `BatchTransferOwnership` descriptor |
| 2.02 | TransferTransaction | Send back funds to _target account_ (non-transferrable mosaics) |
| 2.03 | TransferTransaction | Ownership transfer transaction |
| 2.04 | TransferTransaction | Execution proof with NIP13 `TransferOwnershipWithData` descriptor |
| 2.05 | TransferTransaction | Attaching data as a message |

:warning: `Transaction 1.02`, `Transaction 1.03` and `Transaction 1.04` will be repeated for each valid partition account given in the `recipients` arguments.

:warning: `Transaction 2.03`, `Transaction 2.04` and `Transaction 2.05` will be repeated for each valid partition account given in the `recipients` arguments.

#### Token command `ForcedTransfer`

**Descriptor**: `NIP13(v1):forced-transfer:6da3dbfc` with `6da3dbfc` said _token identifier_.

**Input**: This token command accepts the following arguments:

| Argument | Description | Example |
| --- | --- | --- |
| `sender` | Sender token holder partition account | `new PublicAccount(...)` |
| `recipient` | Recipient token holder partition account | `new PublicAccount(...)` |
| `amount` | Number of shares to be transferred | `1` |

**Output**: This token command prepares one aggregate bonded transaction with following inner transactions:

**1) Sending to a _target account_**

| Index | Transaction type | Description
| --- | --- | --- |
| 1.01 | TransferTransaction | Execution proof with NIP13 `ForcedTransfer` descriptor |
| 1.02 | TransferTransaction | Ownership transfer transaction |

**2) Sending to a _partition account_**

| Index | Transaction type | Description
| --- | --- | --- |
| 2.01 | TransferTransaction | Execution proof with NIP13 `ForcedTransfer` descriptor |
| 2.02 | TransferTransaction | Send back funds to _target account_ (non-transferrable mosaics) |
| 2.03 | TransferTransaction | Ownership transfer transaction |

#### Token command `LockBalance`

**Descriptor**: `NIP13(v1):lock:6da3dbfc` with `6da3dbfc` said _token identifier_.

**Input**: This token command accepts the following arguments:

| Argument | Description | Example |
| --- | --- | --- |
| `partition` | Token holder partition account (gets locked) | `new PublicAccount(...)` |
| `locker` | Token locker account (gets shares) | `new PublicAccount(...)` |
| `amount` | Number of shares to be locked | `1` |

**Output**: This token command prepares one aggregate bonded transaction with following inner transactions:

| Index | Transaction type | Description
| --- | --- | --- |
| 01 | TransferTransaction | Execution proof with NIP13 `LockBalance` descriptor |
| 02 | MultisigAccountModificationTransaction | Converting **locker** account to multisig with operators as cosignatories (token holder excluded) |
| 03 | AccountMetadataTransaction | Attaching `Is_Lock` flag to _locker account_ |
| 04 | AccountMosaicRestrictionTransaction | Adding locker account allowance for target mosaic and network fee mosaic |
| 05 | MosaicAddressRestriction | Adding account level restriction value for `User_Role` with `3` (3 = Locker) |
| 06 | TransferTransaction | Send back funds to _target account_ (non-transferrable mosaics) |
| 07 | TransferTransaction | Ownership transfer transaction |

#### Token command `UnlockBalance`

**Descriptor**: `NIP13(v1):unlock:6da3dbfc` with `6da3dbfc` said _token identifier_.

**Input**: This token command accepts the following arguments:

| Argument | Description | Example |
| --- | --- | --- |
| `partition` | Token holder partition account (gets unlocked) | `new PublicAccount(...)` |
| `locker` | Token locker account (sends back shares) | `new PublicAccount(...)` |
| `amount` | Number of shares to be unlocked | `1` |

**Output**: This token command prepares one aggregate bonded transaction with following inner transactions:

| Index | Transaction type | Description
| --- | --- | --- |
| 01 | TransferTransaction | Execution proof with NIP13 `UnlockBalance` descriptor |
| 02 | TransferTransaction | Send back funds to _target account_ (non-transferrable mosaics) |
| 03 | TransferTransaction | Ownership transfer transaction |

#### Token command `ModifyRestriction`

**Descriptor**: `NIP13(v1):restriction:6da3dbfc` with `6da3dbfc` said _token identifier_.

:warning: Executing this command may render the affected token incompliant with NIP13 requirements.

:warning: **Please, use this token command with care.**

**Input**: This token command accepts the following arguments:

| Argument | Description | Example |
| --- | --- | --- |
| `restrictee` | Target account or partition account ("target of the restriction") | `new PublicAccount(...)` |
| `field` | Name of the restriction | `new PublicAccount(...)` |
| `value` | Minimumv value required for said restriction | `1` |

**Output**: This token command prepares one aggregate bonded transaction with following inner transactions:

**1) With restrictee a _target account_**

| Index | Transaction type | Description
| --- | --- | --- |
| 1.01 | TransferTransaction | Execution proof with NIP13 `ModifyRestriction` descriptor |
| 1.02 | MosaicGlobalRestrictionTransaction | Updating/adding token level restriction |

**2) With restrictee a _partition account_**

| Index | Transaction type | Description
| --- | --- | --- |
| 2.01 | TransferTransaction | Execution proof with NIP13 `ModifyRestriction` descriptor |
| 2.02 | MosaicAddressRestrictionTransaction | Updating/adding token holder level restriction |

:warning: The execution of `Transaction 1.02` may render the affected token **incompliant with NIP13 requirements**. It is recommended to execute this token command _only if the action was verified by all token operators_.

#### Token command `ModifyMetadata`

**Descriptor**: `NIP13(v1):metadata:6da3dbfc` with `6da3dbfc` said _token identifier_.

**Input**: This token command accepts the following arguments:

| Argument | Description | Example |
| --- | --- | --- |
| `metadata` | Metadata associated at token level | `{'MIC': 'XNAS', ...}` |

**Output**: This token command prepares one aggregate bonded transaction with following inner transactions:

| Index | Transaction type | Description
| --- | --- | --- |
| 01 | TransferTransaction | Execution proof with NIP13 `ModifyMetadata` descriptor |
| 02 | MosaicMetadataTransaction | Updating `MIC` market identifier code |
| 03 | MosaicMetadataTransaction | Updating `ISIN` if non-empty option provided |
| 04 | MosaicMetadataTransaction | Updating `ISO_10962` if non-empty option provided |
| 05 | MosaicMetadataTransaction | Updating `Website` if non-empty option provided |
| 06 | MosaicMetadataTransaction | Updating `Sector` if non-empty option provided |
| 07 | MosaicMetadataTransaction | Updating `Industry` if non-empty option provided |
| 08 | MosaicMetadataTransaction | Updating custom metadata if non-empty option provided |

:warning: `Transaction 02` will be added if a non-empty value is provided for the `mic` metadata field.

:warning: `Transaction 03` will be added if a non-empty value is provided for the `isin` metadata field.

:warning: `Transaction 04` will be added if a non-empty value is provided for the `iso10962` metadata field.

:warning: `Transaction 05` will be added if a non-empty value is provided for the `website` metadata field.

:warning: `Transaction 06` will be added if a non-empty value is provided for the `sector` metadata field.

:warning: `Transaction 07` will be added if a non-empty value is provided for the `industry` metadata field.

:warning: `Transaction 08` will be added if a non-empty value is provided for the custom metadata field.

#### Token command `DelegateIssuerPower`

**Descriptor**: `NIP13(v1):add-operator:6da3dbfc` with `6da3dbfc` said _token identifier_.

**Input**: This token command accepts the following arguments:

| Argument | Description | Example |
| --- | --- | --- |
| `operator` | Operator account that will be added | `new PublicAccount(...)` |

**Output**: This token command prepares one aggregate bonded transaction with following inner transactions:

| Index | Transaction type | Description
| --- | --- | --- |
| 01 | TransferTransaction | Execution proof with NIP13 `DelegateIssuerPower` descriptor |
| 02 | MultisigAccountModificationTransaction | Adding **operator** account as a new cosignatory of the **target account** |
| 03 | MultisigAccountModificationTransaction | Adding **operator** account as a new cosignatory of any **partition account** |

:warning: `Transaction 03` will be repeated for each token holder partition.

#### Token command `RevokeIssuerPower`

**Descriptor**: `NIP13(v1):remove-operator:6da3dbfc` with `6da3dbfc` said _token identifier_.

**Input**: This token command accepts the following arguments:

| Argument | Description | Example |
| --- | --- | --- |
| `operator` | Operator account that will be removed | `new PublicAccount(...)` |

**Output**: This token command prepares one aggregate bonded transaction with following inner transactions:

| Index | Transaction type | Description
| --- | --- | --- |
| 01 | TransferTransaction | Execution proof with NIP13 `RevokeIssuerPower` descriptor |
| 02 | MultisigAccountModificationTransaction | Removing **operator** account of the **target account** cosignatories |
| 03 | MultisigAccountModificationTransaction | Removing **operator** account of any **partition account** cosignatories |

:warning: `Transaction 03` will be repeated for each token holder partition.

#### Token command `AttachDocument`

**Descriptor**: `NIP13(v1):document:6da3dbfc` with `6da3dbfc` said _token identifier_.

**Input**: This token command accepts the following arguments:

| Argument | Description | Example |
| --- | --- | --- |
| `filenode` | IPNS file name attributed to IPFS content | `"QmSrPmbaUKA3ZodhzPWZnpFgcPMFWF4QsxXbkWfEptTBJd"` |
| `filename` | The original file name that is being attached | `"Copy_of_ID.png"` |
| `recipient` | The recipient account (either of _target_ or _partition_ accounts) | `new PublicAccount(...)`

**Output**: This token command prepares one aggregate bonded transaction with following inner transactions:

| Index | Transaction type | Description
| --- | --- | --- |
| 01 | TransferTransaction | Execution proof with NIP13 `AttachDocument` descriptor |
| 02 | TransferTransaction | Attaching document hash to be signed by recipient account |

### Example Library Usage

The following example usage for the `symbol-token-standards` library is subject to change.

```javascript
import { AggregateTransaction, PublicAccount, SignedTransaction } from 'symbol-sdk'
import { MnemonicPassPhrase } from 'symbol-hd-wallets'
import { NIP13, NetworkConfig, TransactionParameters } from 'symbol-token-standards'
import { TransactionURI } from 'symbol-uri-scheme'

// :warning: The following settings are network specific and may need changes
const transactionParams = new TransactionParameters(
  Deadline.create(),
  750000, // maxFee
)

// :warning: You should create separate backups of
// authorities and security token pass phrases.
const authKeys = MnemonicPassPhrase.createRandom() // backup the resulting 24-words safely!
const tokenKeys = MnemonicPassPhrase.createRandom() // backup the resulting 24-words safely!

// :warning: It is recommended to create operator
// keys offline and using a separate device.
const operators = [
  new PublicAccount('PUBLIC_KEY_OPERATOR_1', 'ADDRESS_OPERATOR_1'),
  new PublicAccount('PUBLIC_KEY_OPERATOR_2', 'ADDRESS_OPERATOR_2'),
  // ...
]

// initialize NIP13 library
const network = new NetworkConfig(...)
const tokenAuthority = new NIP13.TokenAuthority(network, authKeys)
const securityToken = new NIP13.Token(network, tokenKeys)

// offline creation of the `CreateToken` security token contract
const metadata = new SecuritiesMetadata(
  'MIC',
  'ISIN',
  'ISO_10962',
  'Website',
  'Sector',
  'Industry',
  {
    'customKey1': 'metadata',
    // ...
  },
)
const tokenId = securityToken.create(
  'My Awesome Security Token', // security token name
  securityToken.getTarget().publicAccount, // actor
  tokenAuthority.getAuthority().publicAccount, // token authority
  operators,
  123456789, // supply
  metadata,
  transactionParams,
)

// get the transaction URI for `CreateToken` execution
const resultURI: TransactionURI = securityToken.result

// :warning: It is recommended to sign the security token using
// a hardware wallet rather than any type of software generated
// wallets.
const transaction: AggregateTransaction = resultURI.toTransaction()
const signedTransaction: SignedTransaction = securityToken.getTarget().sign(transaction, 'generationHash')

// `signedTransaction` can now be broadcast to the Symbol network of choice.

// It is important to denote that given the **aggregate** nature of security
// token contracts, multiple parties MAY be involved in the transaction and
// it is therefor required to issue a HashLockTransaction before announcing
// the aggregate bonded transaction that represents the contract.
```

### Requirements Compliancy

Following the [list of requirements](#requirements), this section will define implementation options that MUST be available in described Token Standards.

- [x] MUST have a standard interface to query feasibility of a transfer and return a reason for failures.

- `canTransfer()`
- `canExecute()`

- [x] MUST be able to perform forced transfer for legal action or fund recovery.

- `execute(... new ForcedTransfer(), [Option.create('sender', '...'), Option.create('recipient', '...')])`

- [x] MUST define standard notifications for issuance and redemption processes.

- `canExecute(... new CreateToken(), [Option.create('tokenId', '...')])`

- [x] MUST be able to attach metadata to a **subset of a token holder's balance**.

- `execute(... new ModifyMetadata(), [Option.create('data', '...')])`

- [x] MUST be able to modify metadata at time of transfer based on off-chain data, on-chain data and the parameters of the transfer.

- `execute(... new ModifyMetadata(), [Option.create('data', '...')])`

- [x] MUST support querying and subscribing to updates on any relevant documentation for the security.

- `notify()`

- [x] MAY require signed data to be passed into a transfer transaction in order to validate it on-chain.

- `execute(... new TransferOwnershipWithData(), [Option.create('data', '...')])`

- [x] SHOULD NOT restrict the range of asset classes across jurisdictions which can be represented.

### Ongoing Work

| Story | Assigned | Progress |
| --- | --- | --- |
| Describe NIP13 and draft NIP | @evias | ![Progress](https://progress-bar.dev/100/) |
| Define Implementation details | @evias | ![Progress](https://progress-bar.dev/100/) |
| Start NIP13 implementation | @evias | ![Progress](https://progress-bar.dev/100/) |
| Implement base library layer | @evias | ![Progress](https://progress-bar.dev/100/) |
| Implement create/transfer token commands | @evias | ![Progress](https://progress-bar.dev/100/) |
| Implement lock/unlock token command | @evias | ![Progress](https://progress-bar.dev/100/) |
| Implement force transfer token command | @evias | ![Progress](https://progress-bar.dev/100/) |
| Implement modify metadata/restrictions token commands | @evias | ![Progress](https://progress-bar.dev/100/) |
| Implement delegate issuer power token command | @evias | ![Progress](https://progress-bar.dev/100/) |
| Implement attach document token command | @evias | ![Progress](https://progress-bar.dev/100/) |

## Backwards compatibility

This standard is backwards compatible with Symbol Mosaics as it relies solely on Symbol Mosaic and Accounts features.

## References

- [ERC#1400 `Security Token Standard`][erc-1400]
- [NFT Library `nem2-nonfungible-asset`][src-nft]
- [Symbol Typescript SDK][src-sdk]
- [Symbol][symbol] protocol
- [Symbol Developer Center][symbol-dev-center]

## Annexes

Annexes to this NIP are listed below:

- [Annex 1: Reason Codes][annex-1]
- [Source code for `symbol-token-standards` Library][src-nip13]

## History

| **Date**     | **Version**    |
| ------------ | -------------- |
| July 29 2019 | Initial Draft  |
| March 11 2019 | Revised NST-1 |
| March 25 2020 | Revised NIP13 |
| May 04 2020 | Updated NIP13   |
| May 11 2020 | Updated NIP13   |

[annex-1]:nip-0013/reason-codes.md
[symbol-dev-center]:https://nemtech.github.io
[symbol]:https://github.com/nemtech/catapult-server
[src-nft]:https://github.com/nemfoundation/nem2-nonfungible-asset
[src-nip13]:https://github.com/nemfoundation/symbol-token-standards
[src-sdk]:https://github.com/nemtech/symbol-sdk-typescript-javascript
[src-hd]:https://github.com/nemfoundation/symbol-hd-wallets
[doc-nip2]:https://github.com/nemtech/NIP/blob/master/NIPs/nip-0002.md
[guide-create-mosaic]:https://nemtech.github.io/guides/mosaic/creating-a-mosaic.html
[erc-1400]:https://github.com/ethereum/EIPs/issues/1411
[eip-1066]:https://eips.ethereum.org/EIPS/eip-1066

'''
'''--- NIPs/nip-0013/reason-codes.md ---
# NIP-13 Annex 1: Reason Codes

In an attempt to make the token holder experience better, the provided `canTransfer` function MUST return a _reason byte code_ on success or failure based on the NIP-13 application-specific status codes specified in below table.

| Code | Reason | Failure |
| --- | --- | --- |
| **`0x0*` Generic Failure Codes** | | |
| `0x00` | Failure | `Failure_Generic` |
| `0x01` | Success | `Success_Generic` | 
| `0x02` | Awaiting Others | `Info_Awaiting_Parties` | 
| `0x03` | Accepted | `Success_Accepted` |
| `0x04` | Lower Limit or Insufficient | `Failure_Lower_Limit` |
| `0x05` | Receiver Action Requested | `Info_Receiver_Action_Requested` |
| `0x06` | Upper Limit | `Failure_Upper_Limit` |
| `0x07` | _Currently unspecified_ | _Currently unspecified_ |
| `0x08` | _Currently unspecified_ | _Currently unspecified_ |
| `0x09` | _Currently unspecified_ | _Currently unspecified_ |
| `0x0A` | _Currently unspecified_ | _Currently unspecified_ |
| `0x0B` | _Currently unspecified_ | _Currently unspecified_ |
| `0x0C` | _Currently unspecified_ | _Currently unspecified_ |
| `0x0D` | _Currently unspecified_ | _Currently unspecified_ |
| `0x0E` | _Currently unspecified_ | _Currently unspecified_ |
| `0x0F` | Informational or Metadata | `Info_Generic` |
| **`0x1*` Permission and Control** | | |
| `0x10` | Disallowed or Stop | `Failure_Disallowed` |
| `0x11` | Allowed or Go | `Success_Allowed` |
| `0x12` | Awaiting Other’s Permission | `Info_Awaiting_Parties_Permission` |
| `0x13` | Permission Requested | `Success_Permission_Requested` |
| `0x14` | Too Open / Insecure | `Failure_Insecure_Action` |
| `0x15` | Needs Your Permission or Request for Continuation | `Failure_Needs_Permission` |
| `0x16` | Revoked or Banned | `Failure_Permission_Revoked` |
| `0x17` | _Currently unspecified_ | _Currently unspecified_ |
| `0x18` | Not Applicable to Current State | `Failure_Permission_Not_Applicable` |
| `0x19` | _Currently unspecified_ | _Currently unspecified_ |
| `0x1A` | _Currently unspecified_ | _Currently unspecified_ |
| `0x1B` | _Currently unspecified_ | _Currently unspecified_ |
| `0x1C` | _Currently unspecified_ | _Currently unspecified_ |
| `0x1D` | _Currently unspecified_ | _Currently unspecified_ |
| `0x1E` | _Currently unspecified_ | _Currently unspecified_ |
| `0x1F` | Permission Details or Control Conditions | `Info_Permission_Details` |
| **| `0x2*` Find, Inequalities and Ranges** | | |
| `0x20` | Not Found, Unequal, or Out of Range | `Failure_Not_Found` |
| `0x21` | Found, Equal or In Range | `Success_Found` |
| `0x22` | Awaiting Match | `Info_Awaiting_Match` |
| `0x23` | Match Request Sent | `Success_Match_Request_Sent` |
| `0x24` | Below Range or Underflow | `Failure_Below_Range` |
| `0x25` | Request for Match | `Info_Request_For_Match` |
| `0x26` | Above Range or Overflow | `Failure_Above_Range` |
| `0x27` | _Currently unspecified_ | _Currently unspecified_ |
| `0x28` | Duplicate, Conflict, or Collision | `Failure_Duplicate_Conflict` |
| `0x29` | _Currently unspecified_ | _Currently unspecified_ |
| `0x2A` | _Currently unspecified_ | _Currently unspecified_ |
| `0x2B` | _Currently unspecified_ | _Currently unspecified_ |
| `0x2C` | _Currently unspecified_ | _Currently unspecified_ |
| `0x2D` | _Currently unspecified_ | _Currently unspecified_ |
| `0x2E` | _Currently unspecified_ | _Currently unspecified_ |
| `0x2F` | Matching Meta or Info | `Info_Matching_Meta` |
| **`0x3*` Negotiation and Governance** | | |
| `0x30` | Sender Disagrees or Nay | `Failure_Sender_Agreement` |
| `0x31` | Sender Agrees or Yea | `Success_Sender_Agreement` |
| `0x32` | Awaiting Ratification | `Info_Awaiting_Ratification` |
| `0x33` | Offer Sent or Voted | `Success_Offer_Sent`<br />`Success_Voted` |
| `0x34` | Quorum Not Reached | `Failure_Quorum_Not_Reached` |
| `0x35` | Receiver’s Ratification Requested | `Info_Receiver_Ratification_Requested` |
| `0x36` | Offer or Vote Limit Reached | `Failure_Offer_Limit_Reached`<br />`Failure_Vote_Limit_Reached` |
| `0x37` | _Currently unspecified_ | _Currently unspecified_ |
| `0x38` | Already Voted | `Failure_Already_Voted` |
| `0x39` | _Currently unspecified_ | _Currently unspecified_ |
| `0x3A` | _Currently unspecified_ | _Currently unspecified_ |
| `0x3B` | _Currently unspecified_ | _Currently unspecified_ |
| `0x3C` | _Currently unspecified_ | _Currently unspecified_ |
| `0x3D` | _Currently unspecified_ | _Currently unspecified_ |
| `0x3E` | _Currently unspecified_ | _Currently unspecified_ |
| `0x3F` | Negotiation Rules or Participation Info | `Info_Negotiation_Rules` |
| **`0x4*` Availability and Time** | | |
| `0x40` | Unavailable | `Failure_Unavailable` |
| `0x41` | Available | `Success_Available` |
| `0x42` | Paused | `Info_Paused` |
| `0x43` | Queued | `Info_Queued` |
| `0x44` | Not Available Yet | `Failure_Not_Available_Yet` |
| `0x45` | Awaiting Your Availability | `Info_Awaiting_Own_Availability` |
| `0x46` | Expired | `Failure_Expired` |
| `0x47` | _Currently unspecified_ | _Currently unspecified_ |
| `0x48` | Already Done | `Failure_Already_Done` |
| `0x49` | _Currently unspecified_ | _Currently unspecified_ |
| `0x4A` | _Currently unspecified_ | _Currently unspecified_ |
| `0x4B` | _Currently unspecified_ | _Currently unspecified_ |
| `0x4C` | _Currently unspecified_ | _Currently unspecified_ |
| `0x4D` | _Currently unspecified_ | _Currently unspecified_ |
| `0x4E` | _Currently unspecified_ | _Currently unspecified_ |
| `0x4F` | Availability Rules or Info (ex. time since or until) | `Info_Availability_Rules` |
| **`0x5*` Tokens, Funds and Finance** | | |
| `0x50` | Transfer Failed | `Failure_Transfer` |
| `0x51` | Transfer Successful | `Success_Transfer` |
| `0x52` | Awaiting Payment From Others | `Info_Awaiting_Parties_Payment` |
| `0x53` | Hold or Escrow | `Info_Hold`<br />`Info_Escrow` |
| `0x54` | Insufficient Funds | `Failure_Insufficient_Funds` |
| `0x55` | Funds Requested | `Success_Funds_Requested` |
| `0x56` | Transfer Volume Exceeded | `Failure_Transfer_Volumn_Exceeded` |
| `0x57` | _Currently unspecified_ | _Currently unspecified_ |
| `0x58` | Funds Not Required | `Failure_Funds_Not_Required` |
| `0x59` | _Currently unspecified_ | _Currently unspecified_ |
| `0x5A` | _Currently unspecified_ | _Currently unspecified_ |
| `0x5B` | _Currently unspecified_ | _Currently unspecified_ |
| `0x5C` | _Currently unspecified_ | _Currently unspecified_ |
| `0x5D` | _Currently unspecified_ | _Currently unspecified_ |
| `0x5E` | _Currently unspecified_ | _Currently unspecified_ |
| `0x5F` | Token or Financial Information | `Info_Token_Information` |
| **`0x6*` Currently unspecified** | | |
| **`0x7*` Currently unspecified** | | |
| **`0x8*` Currently unspecified** | | |
| **`0x9*` Currently unspecified** | | |
| **`0xA*` Application-specific Codes** | | |
| `0xA0` | App-Specific Failure | `Failure_App_Generic` |
| `0xA1` | App-Specific Success | `Success_App_Generic` |
| `0xA2` | App-Specific Awaiting Others | `Info_App_Awaiting_Parties` |
| `0xA3` | App-Specific Acceptance | `Info_App_Acceptance` |
| `0xA4` | App-Specific Below Condition | `Info_App_Conditions` |
| `0xA5` | App-Specific Receiver Action Requested | `Info_App_Received_Action_Requested` |
| `0xA6` | App-Specific Expiry or Limit | `Failure_App_Expiry`<br />`Failure_App_Limit` |
| `0xA7` | _Currently unspecified_ | _Currently unspecified_ |
| `0xA8` | App-Specific Inapplicable Condition | `Failure_App_Inapplicable_Condition` |
| `0xA9` | _Currently unspecified_ | _Currently unspecified_ |
| `0xAA` | _Currently unspecified_ | _Currently unspecified_ |
| `0xAB` | _Currently unspecified_ | _Currently unspecified_ |
| `0xAC` | _Currently unspecified_ | _Currently unspecified_ |
| `0xAD` | _Currently unspecified_ | _Currently unspecified_ |
| `0xAE` | _Currently unspecified_ | _Currently unspecified_ |
| `0xAF` | App-Specific Meta or Info | `Info_App_Generic` |
| **`0xB*` Currently unspecified** | | |
| **`0xC*` Currently unspecified** | | |
| **`0xD*` Currently unspecified** | | |
| **`0xE*` Encryption, Identity and Proofs** | | |
| `0xE0` | Decrypt Failure | `Failure_Decryption` |
| `0xE1` | Decrypt Success | `Success_Decryption` |
| `0xE2` | Awaiting Other Signatures or Keys | `Info_Awaiting_Parties_Signatures` |
| `0xE3` | Signed | `Success_Signed` |
| `0xE4` | Unsigned or Untrusted | `Info_Unsigned_Untrusted` |
| `0xE5` | Signature Required | `Info_Signature_Required` |
| `0xE6` | Known to be Compromised | `Info_Known_To_Be_Compromised` |
| `0xE7` | _Currently unspecified_ | |
| `0xE8` | Already Signed or Not Encrypted | `Failure_Already_Signed` |
| `0xE9` | _Currently unspecified_ | |
| `0xEA` | _Currently unspecified_ | |
| `0xEB` | _Currently unspecified_ | |
| `0xEC` | _Currently unspecified_ | |
| `0xED` | _Currently unspecified_ | |
| `0xEE` | _Currently unspecified_ | |
| `0xEF` | Cryptography, ID, or Proof Metadata | `Info_Cryptography`<br />`Info_Metadata_Proof` |

Source: [EIP#1066 `EIP 1066: Status Codes`][eip-1066]

## Credits

| Name | Github | Role |
| --- | --- | --- |
| Brooklyn Zelenka, Tom Carchrae, Gleb Naumenko | EIP-1066 | EIP-1066 |
| Grégory Saive | @evias | Contributor |

[eip-1066]:https://eips.ethereum.org/EIPS/eip-1066

'''
'''--- NIPs/nip-0014.md ---
# NIP 14 - Release Management for Symbol Packages

```
    NIP: 14
    Title: Release Management for Symbol Packages
    Author: Fernando Boucquez <fernando.boucquez@nemstudios.io>
    Comments-URI: https://github.com/nemtech/NIP/issues/44
    Status: Draft
    Type: Process
    Created: 2020-03-25
    License: Apache 2.0
    License-Code: Apache 2.0
```
## Table of contents

- [Introduction](#introduction)
- [Specification](#specification)
  * [Versioning](#versioning)
  * [Changelog](#changelog)
  * [Tooling](#tooling)
- [Sanity Check](#sanity-check)
- [Alpha deployments](#alpha-deployments)
- [Full release](#full-release)
- [Motivation](#motivation)
- [Implementation](#implementation)
  * [Travis settings](#travis-settings)
- [Projects following the NIP](#projects-following-the-nip)
- [Backwards compatibility](#backwards-compatibility)
- [Contributors](#contributors)
- [History](#history)

## Introduction

This document describes the standard release cycle for all the packages hosted under the nemtech org.

## Specification

### Versioning

All projects must adhere to the [Semantic Versioning 2.0.0](https://semver.org/).

> Given a version number MAJOR.MINOR.PATCH, increment the:
MAJOR version when you make incompatible API changes,
MINOR version when you add functionality in a backwards compatible manner, and
PATCH version when you make backwards compatible bug fixes.
 
Versions between projects should remain independent. 
 
### Changelog
 
New releases must include a CHANGELOG based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/).
 
If a project has dependencies with other Symbol packages, the CHANGELOG must attach the following table per new version describing the dependencies:

**Milestone**: catapult-server milestone name (version number)
 
 | Library     |Version  | Package         |
 | ------------|---------|---------------- |
 |Library name | v0.17.3 | Link to package |

### Tooling

The majority of our projects use TravisCI as the CI automation tool, but you can use Jenkins or any other tool that suits the process if you are more comfortable with it.

## Sanity Check

Every time there is a new commit, the build scripts should:

* build the package
* run the unit tests
* pass the linter

GitHub should prevent merging the PRs that do not pass the requirements mentioned above.

## Alpha deployments

Every time there is a new push to main branch, the build scripts should generate and deploy a new testable version like  ``0.17.1-ALPHA-20200220T120318``.

Note that there is a timestamp suffix since package managers may not allow redeployments of the same version. If the package manager allows reployments of SNAPSHOT, using a timestamp is not necessary in this case.

The timestamp is automatically generated by the CI automation tool.There should not be any manual process like writing down the version 0.17.1-ALPHA-1 or 0.17.1-ALPHA-2.

A client can use an alpha dependency like "symbol-sdk": "0.17.1-ALPHA-20200220T120318".

### Exception: Code generators

Code generators (catbuffer-generators, symbol-openapi-generator) differ from the above in one aspect: alpha deployments are not done automatically from main branch. Instead, they are triggered from language specific release branches due to the fact that code generators build multiple independent deployment artifacts e.g. one for each language, each of which can be released independently.

## Full release

Every time we want to release, we create a PR from main to the release branch.
The PR will include the CHANGELOG update explaining the new features.

Once PR is approved, the CI automation tool will pick it up, build and then it will perform a release. 

The release script should:

* git tag the to-be-released version (e.g: v0.17.4)
* publish the current version into the package manager (e.g. npm, docker hub - 0.17.4)
* upgrade the package version (e.g: 0.17.5 using npm version patch)
* add & commit changes
* push commits into main branch (eg: package.json will have the new 0.17.5)
* push the tag (v0.17.4)

## Motivation

**Standarized release process**

How the release process is done is committed and documented in the travis file and scripts. It’s not done in a dev machine. Anybody can understand it and perform a release.

**Tighter feedback loop**

Users need to wait for a proper release before start using a new feature in our packages. Although the process is quite dynamic, it could take a few days before getting a release that aggregates many improvements together.

The proposal is to add the right versioning and token in the CI automation tool scripts so every time a PR is merged to main, a pipeline pushes a new alpha/snapshot to the package manager. If a user is waiting for a fix, that fix will be included in the package manager automatically after the new main branch is merged.

**Faster releases**

Using the snapshot, the Symbol team can do extra checks and feedback before doing a release,by smoke testing the snapshot artifact in other projects like the CLI, wallet or explorer. Even the examples in the docs can be upgraded before the package is released.

## Implementation

The Symbol SDK for Typescript follows the release cycle defined in this document using TravisCI.

Note: The implementation depends on the framework and programming language, the TS implementation is just an example. 

* ``travis.yml``: https://github.com/nemtech/symbol-sdk-typescript-javascript/blob/main/.travis.yml

* Releases script: https://github.com/nemtech/symbol-sdk-typescript-javascript/blob/main/travis/release.sh

* Alpha releases script: https://github.com/nemtech/symbol-sdk-typescript-javascript/blob/main/travis/uploadArchives.sh

### Travis settings

Travis will hold the necessary tokens and encryption keys to perform a release using env variables. The most common ones are:

* ``NPM_TOKEN``: The token used to push npm artifacts into a npm repository https://docs.npmjs.com/creating-and-viewing-authentication-tokens 

* ``GITHUB_TOKEN``: The token used to push the version increases, tags and documentation (GitHub Pages) into GitHub. The user needs to be able to publish from the release branch to main once the version is updated.
 https://help.github.com/en/github/authenticating-to-github/creating-a-personal-access-token-for-the-command-line
* ``RELEASE_BRANCH``: The name of the release branch. Example: ``release``.
* (Optional): ``signingKeyId``, ``signingPassword``, ``signingSecretKeyRingFile`` and the Travis encrypted private key. The values necessary for sign packages. https://medium.com/@nmauti/sign-and-publish-on-maven-central-a-project-with-the-new-maven-publish-gradle-plugin-22a72a4bfd4b

We would need other tokens for Docker, Sonar, or PIP deployments to be defined. 

The generated tokens should be from users with enough permissions (for example, a user that can push to GitHub Pages branch or npm).

##  Projects following the NIP

* [x] symbol-sdk-typescript-javascript
* [x] symbol-sdk-java
* [x] symbol-cli
* [x] symbol-openapi
* [x] symbol-openapi-generator
* [ ] catbuffer-generators
* [ ] symbol-docs
* [ ] catapult-rest
* [ ] catapult-server

##  Backwards compatibility

No backward incompatibility issues. The uploaded artifacts are the same, just deployed from Travis instead of a developer machine.

## Contributors

Special thanks to [@dgarcia360](https://github.com/dgarcia360)and [@rg911](https://github.com/rg911) for contributing actively to this NIP.

## History

| **Date**          | **Version**   |
| ----------------- | ------------- |
| March 25 2020     | Initial Draft |

'''
'''--- README.md ---
# NEM2 Improvement Proposal

NEM2 Improvement Proposals (NIPs) is the process for submitting improvements to Symbol. This process aims to evolve Symbol openly and collaboratively.

The NIP process cover the core protocol, API, SDKs, applications, and official libraries.

## Contributing

Get familiar with [NIP-0001](NIPs/nip-0001.md) first. Open an issue using [this template](ISSUE_TEMPLATE.md). Clone this repository and then sumit a pull request with your NIP.

## NIP List

| Number         | Layer        | Title                                            | Author                 | Type           | Status  |
| -------------- | --------     | -------------------------------------------------| -----------------------| ---------------| --------|
| [1][nip-0001]  |              | NIP Process                                      | Aleix Morgadas         | Process        | Active  |
| [2][nip-0002]  | Library      | Transaction URI Scheme                           | David Garcia           | Standards Track| Active  |
| [3][nip-0003]  |              | Documenting a New Feature                        | David Garcia           | Process        | Active  |
| [4][nip-0004]  | Library      | Apostille Improvement Protocol                   | Jonathan Tey           | Standards Track| Draft   |
| [5][nip-0005]  | Application  | Wallet as Browser Extension                      | Aleix M., Décentraliser| Standards Track| Proposed|
| [6][nip-0006]  | Application  | Multi-Account Hierarchy for Deterministic Wallets| Grégory Saive          | Standards Track| Active  |
| [7][nip-0007]  | Library      | QR Library Standard Definition                   | Anthony L., Grégory S. | Standards Track| Active  |
| [8][nip-0008]  |              | Catapult Technology Release for Public Network   | Grégory Saive          | Process        | Draft   |
| [9][nip-0009]  | Core         | New Persistent Delegation Request Transaction    | gimre                  | Standards Track| Active  |
| [10][nip-0010] | Core         | Key Pair Generation and Address Format           | gimre                  | Standards Track| Active  |
| [11][nip-0011] | Application  | Symbol Configuration Utility (CLI)               | Bader Y., David G.     | Standards Track| Draft   |
| [12][nip-0012] |              | Rebranding                                       | David Garcia           | Process        | Draft   |
| [13][nip-0013] | Library      | NEM Security Token Standard                      | Grégory Saive          | Standards Track| Draft   |
| [14][nip-0014] |              | Release Management for Symbol Packages           | Fernando Boucquez      | Process        | Draft   |

[nip-0001]: NIPs/nip-0001.md
[nip-0002]: NIPs/nip-0002.md
[nip-0003]: NIPs/nip-0003.md
[nip-0004]: NIPs/nip-0004.md
[nip-0005]: NIPs/nip-0005.md
[nip-0006]: NIPs/nip-0006.md
[nip-0007]: NIPs/nip-0007.md
[nip-0008]: NIPs/nip-0008.md
[nip-0009]: NIPs/nip-0009.md
[nip-0010]: NIPs/nip-0010.md
[nip-0011]: NIPs/nip-0011.md
[nip-0012]: NIPs/nip-0012.md
[nip-0013]: NIPs/nip-0013.md
[nip-0014]: NIPs/nip-0014.md

'''