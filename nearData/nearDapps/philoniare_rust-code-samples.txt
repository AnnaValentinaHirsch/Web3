*GitHub Repository "philoniare/rust-code-samples"*

'''--- external.rs ---
use crate::*;

/// Deliver the token to the buyer and give the market a payout object
/// it can use to allocate money to the right accounts.
#[ext_contract(ext_contract)]
trait ExtContract {
    fn nft_transfer_payout(
        &mut self,
        receiver_id: AccountId, // recipient
        token_id: TokenId,
        approval_id: u64,
        memo: String,
        balance: U128,
        max_len_payout: u32,
    );

    fn ft_transfer(&mut self, receiver_id: AccountId, amount: U128, memo: Option<String>);
}

'''
'''--- internal.rs ---
use crate::*;

/// utilized to create unique prefix (to avoid data collisions)
pub(crate) fn hash_account_id(account_id: &AccountId) -> CryptoHash {
    let mut hash = CryptoHash::default();
    hash.copy_from_slice(&env::sha256(account_id.as_bytes()));
    hash
}

impl Contract {
    /// method to delete a sale. Returns the previously deleted sale object
    pub(crate) fn delete_sale(
        &mut self,
        nft_contract_id: AccountId,
        token_id: TokenId,
    ) -> Sale {
        let contract_and_token_id = format!("{}{}{}", &nft_contract_id, DELIMETER, token_id);
        let sale = self.sales.remove(&contract_and_token_id).expect("No sale");

        let mut by_owner_id = self
            .by_owner_id
            .get(&sale.owner_id)
            .expect("No sale by_owner_id");
        by_owner_id.remove(&contract_and_token_id);

        if by_owner_id.is_empty() {
            self.by_owner_id.remove(&sale.owner_id);
        } else {
            self.by_owner_id.insert(&sale.owner_id, &by_owner_id);
        }

        let mut by_nft_contract_id = self
            .by_nft_contract_id
            .get(&nft_contract_id)
            .expect("No sale by nft_contract_id");

        by_nft_contract_id.remove(&token_id);

        if by_nft_contract_id.is_empty() {
            self.by_nft_contract_id.remove(&nft_contract_id);
        } else {
            self.by_nft_contract_id
                .insert(&nft_contract_id, &by_nft_contract_id);
        }

        sale
    }
}

'''
'''--- lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LookupMap, LookupSet, UnorderedMap, UnorderedSet};
use near_sdk::json_types::{U128, U64};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{
    assert_one_yocto, env, ext_contract, near_bindgen, require, AccountId, Balance,
    BorshStorageKey, CryptoHash, Gas, PanicOnDefault, Promise
};
use std::collections::HashMap;

use crate::external::*;
use crate::internal::*;
use crate::sale::*;
use near_sdk::env::STORAGE_PRICE_PER_BYTE;

mod external;
mod internal;
mod nft_callbacks;
mod sale;
mod sale_views;

const GAS_FOR_RESOLVE_PURCHASE: Gas = Gas(115_000_000_000_000);
const GAS_FOR_NFT_TRANSFER: Gas = Gas(15_000_000_000_000);
const GAS_FOR_FT_TRANSFER: Gas = Gas(5_000_000_000_000);
const STORAGE_PER_SALE: u128 = 1000 * STORAGE_PRICE_PER_BYTE;
static DELIMETER: &str = ".";

pub type SalePriceInTokens = U128;
pub type TokenId = String;
pub type FungibleTokenId = AccountId;
pub type ContractAndTokenId = String;

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Payout {
    pub payout: HashMap<AccountId, U128>,
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    pub owner_id: AccountId,

    pub sales: UnorderedMap<ContractAndTokenId, Sale>,

    pub by_owner_id: LookupMap<AccountId, UnorderedSet<ContractAndTokenId>>,

    pub by_nft_contract_id: LookupMap<AccountId, UnorderedSet<TokenId>>,

    pub approved_ft_tokens: LookupSet<FungibleTokenId>,

    pub storage_deposits: LookupMap<AccountId, Balance>,
}

#[derive(BorshStorageKey, BorshSerialize)]
pub enum StorageKey {
    Sales,
    ByOwnerId,
    ByOwnerIdInner { account_id_hash: CryptoHash },
    ByNFTContractId,
    ByNFTContractIdInner { account_id_hash: CryptoHash },
    FTTokenIds,
    StorageDeposits,
}

#[near_bindgen]
impl Contract {
    /*
        Initializes the contract with default data and the owner ID
    */
    #[init]
    pub fn new(owner_id: AccountId) -> Self {
        let mut this = Self {
            owner_id,
            sales: UnorderedMap::new(StorageKey::Sales),
            by_owner_id: LookupMap::new(StorageKey::ByOwnerId),
            by_nft_contract_id: LookupMap::new(StorageKey::ByNFTContractId),
            approved_ft_tokens: LookupSet::new(StorageKey::FTTokenIds),
            storage_deposits: LookupMap::new(StorageKey::StorageDeposits),
        };

        let near_contract_id = AccountId::new_unchecked("near".to_string());
        this.approved_ft_tokens.insert(&near_contract_id);
        this
    }

    pub fn add_ft_token_ids(&mut self, ft_token_ids: Vec<FungibleTokenId>) -> Vec<bool> {
        require!(env::predecessor_account_id() == self.owner_id,"Only Owner can approve ft_token_id");

        let mut added = vec![];

        for ft_token_id in ft_token_ids {
            added.push(self.approved_ft_tokens.insert(&ft_token_id));
        }
        
        added
    }

    //Cover the cost of storing sale objects on the contract
    //Optional account ID is to users can pay for storage for other people.
    #[payable]
    pub fn storage_deposit(&mut self, account_id: Option<AccountId>) {
        let storage_account_id = account_id
            .map(|a| a.into())
            .unwrap_or_else(env::predecessor_account_id);

        let deposit = env::attached_deposit();

        require!(
            deposit >= STORAGE_PER_SALE,
            format!("Requires minimum deposit of {}", STORAGE_PER_SALE)
        );

        let mut balance: u128 = self.storage_deposits.get(&storage_account_id).unwrap_or(0);
        balance = balance
            .checked_add(deposit)
            .unwrap_or_else(|| env::panic_str("Balance Overflow"));
        self.storage_deposits.insert(&storage_account_id, &balance);
    }

    //Withdraw any excess storage fees.
    #[payable]
    pub fn storage_withdraw(&mut self) {
        assert_one_yocto();

        let owner_id = env::predecessor_account_id();
        let mut amount = self.storage_deposits.remove(&owner_id).unwrap_or(0);

        let sales = self.by_owner_id.get(&owner_id);
        let len = sales.map(|s| s.len()).unwrap_or_default();
        let diff = u128::from(len) * STORAGE_PER_SALE;

        amount -= diff;

        if amount > 0 {
            Promise::new(owner_id.clone()).transfer(amount);
        }

        if diff > 0 {
            self.storage_deposits.insert(&owner_id, &diff);
        }
    }

    pub fn storage_minimum_balance(&self) -> U128 {
        U128(STORAGE_PER_SALE)
    }

    pub fn storage_balance_of(&self, account_id: AccountId) -> U128 {
        U128(self.storage_deposits.get(&account_id).unwrap_or(0))
    }
}

'''
'''--- nft_callbacks.rs ---
use crate::*;

//keep track of the sale conditions
#[derive(Serialize, Deserialize, BorshDeserialize, BorshSerialize)]
#[serde(crate = "near_sdk::serde")]
pub struct SaleConditionArgs {
    pub price: SalePriceInTokens,
    pub ft_contract_id: FungibleTokenId,
}

#[derive(Serialize, Deserialize, BorshDeserialize, BorshSerialize)]
#[serde(crate = "near_sdk::serde")]
pub struct PurchaseArgs {
    pub nft_contract_id: AccountId,
    pub token_id: TokenId,
}

/*
    Used as the callback from the NFT contract. When nft_approve is
    called, it will fire a cross contract call to this marketplace and this is the function
    that is invoked.
*/
trait NonFungibleTokenApprovalsReceiver {
    fn nft_on_approve(
        &mut self,
        token_id: TokenId,
        owner_id: AccountId,
        approval_id: u64,
        msg: String,
    );
}

#[near_bindgen]
impl NonFungibleTokenApprovalsReceiver for Contract {
    fn nft_on_approve(
        &mut self,
        token_id: TokenId,
        owner_id: AccountId,
        approval_id: u64,
        msg: String,
    ) {
        let nft_contract_id = env::predecessor_account_id();
        let signer_id = env::signer_account_id();
        require!(
            nft_contract_id != signer_id,
            "nft_on_approve should only be called via cross-contract call"
        );
        require!(owner_id == signer_id, "owner_id should be signer_id");

        let storage_amount = self.storage_minimum_balance().0;
        let owner_paid_storage = self.storage_deposits.get(&signer_id).unwrap_or(0);
        let signer_storage_required =
            (self.get_supply_by_owner_id(signer_id).0 + 1) as u128 * storage_amount;

        require!(
            owner_paid_storage >= signer_storage_required,
            format!(
                "Insufficient storage paid: {}, for {} sales at {} rate of per sale",
                owner_paid_storage,
                signer_storage_required / STORAGE_PER_SALE,
                STORAGE_PER_SALE
            )
        );

        let SaleConditionArgs {
            price,
            ft_contract_id,
        } = near_sdk::serde_json::from_str(&msg).expect("Not valid SaleArgs");

        let sale_conditions = SaleConditionArgs {
            price,
            ft_contract_id,
        };

        let contract_and_token_id = format!("{}{}{}", nft_contract_id, DELIMETER, token_id);

        self.sales.insert(
            &contract_and_token_id,
            &Sale {
                owner_id: owner_id.clone(),
                approval_id,
                nft_contract_id: nft_contract_id.to_string(),
                token_id: token_id.clone(),
                sale_conditions,
            },
        );

        let mut by_owner_id = self.by_owner_id.get(&owner_id).unwrap_or_else(|| {
            UnorderedSet::new(
                StorageKey::ByOwnerIdInner {
                    account_id_hash: hash_account_id(&owner_id),
                }
                .try_to_vec()
                .unwrap(),
            )
        });

        by_owner_id.insert(&contract_and_token_id);
        self.by_owner_id.insert(&owner_id, &by_owner_id);

        let mut by_nft_contract_id = self
            .by_nft_contract_id
            .get(&nft_contract_id)
            .unwrap_or_else(|| {
                UnorderedSet::new(
                    StorageKey::ByNFTContractIdInner {
                        account_id_hash: hash_account_id(&nft_contract_id),
                    }
                    .try_to_vec()
                    .unwrap(),
                )
            });

        by_nft_contract_id.insert(&token_id);

        self.by_nft_contract_id
            .insert(&nft_contract_id, &by_nft_contract_id);
    }
}

'''
'''--- sale.rs ---
use crate::{
    nft_callbacks::{PurchaseArgs, SaleConditionArgs},
    *,
};
use near_sdk::{promise_result_as_success, PromiseOrValue};

/// information about each sale on the market
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Sale {
    //sale owner
    pub owner_id: AccountId,
    //market contract's approval ID to transfer the token on behalf of the owner
    pub approval_id: u64,
    //nft contract where the token was minted
    pub nft_contract_id: String,
    //actual token ID for sale
    pub token_id: String,
    //sale conditions for token listed
    pub sale_conditions: SaleConditionArgs,
}

#[near_bindgen]
impl Contract {
    //removes a sale from the market.
    #[payable]
    pub fn remove_sale(&mut self, nft_contract_id: AccountId, token_id: String) {
        assert_one_yocto();
        let sale = self.delete_sale(nft_contract_id.into(), token_id);
        let owner_id = env::predecessor_account_id();
        require!(owner_id == sale.owner_id, "Must be sale owner");
    }

    //updates the price for a sale on the market
    #[payable]
    pub fn update_price(
        &mut self,
        nft_contract_id: AccountId,
        token_id: String,
        price: U128,
        ft_contract_id: Option<FungibleTokenId>,
    ) {
        assert_one_yocto();

        let contract_id: AccountId = nft_contract_id.into();
        let contract_and_token_id = format!("{}{}{}", contract_id, DELIMETER, token_id);

        let mut sale = self.sales.get(&contract_and_token_id).expect("No sale");

        require!(
            env::predecessor_account_id() == sale.owner_id,
            "Must be sale owner"
        );

        sale.sale_conditions.price = price;

        if let Some(ft_contract_id) = ft_contract_id {
            require!(
                self.approved_ft_tokens.contains(&ft_contract_id),
                "Only Approved Fungible Tokens can be used for listing"
            );
            sale.sale_conditions.ft_contract_id = ft_contract_id
        }

        self.sales.insert(&contract_and_token_id, &sale);
    }

    //place an offer on a specific sale. The sale will go through as long as your deposit
    // is greater than or equal to the list price
    #[payable]
    pub fn offer(&mut self, nft_contract_id: AccountId, token_id: String) {
        let deposit = env::attached_deposit();
        require!(deposit > 0, "Attached deposit must be greater than 0");

        let contract_id: AccountId = nft_contract_id.into();
        let contract_and_token_id = format!("{}{}{}", contract_id, DELIMETER, token_id);

        let sale = self.sales.get(&contract_and_token_id).expect("No sale");

        let near_contract_id = AccountId::new_unchecked("near".to_string());

        require!(
            sale.sale_conditions.ft_contract_id == near_contract_id,
            "Not available to buy"
        );

        let buyer_id = env::predecessor_account_id();
        require!(sale.owner_id != buyer_id, "Cannot bid on your own sale.");

        let price = sale.sale_conditions.price;

        require!(
            deposit >= price.0,
            format!(
                "Attached deposit must be greater than or equal to the current price: {:?}",
                price
            )
        );

        //process the purchase (which will remove the sale, transfer and get the
        // payout from the nft contract, and then distribute royalties)
        self.process_purchase(contract_id, token_id, U128(deposit),
                              buyer_id, None);
    }

    pub fn ft_on_transfer(
        &mut self,
        sender_id: AccountId,
        amount: U128,
        msg: Option<String>,
    ) -> PromiseOrValue<U128> {
        let msg = if let Some(msg) = msg {
            msg
        } else {
            return PromiseOrValue::Value(amount);
        };

        let PurchaseArgs {
            nft_contract_id,
            token_id,
        } = near_sdk::serde_json::from_str(&msg).expect("Invalid PurchaseArgs");

        let ft_contract_id = env::predecessor_account_id();

        let contract_id: AccountId = nft_contract_id.into();
        let contract_and_token_id = format!("{}{}{}", contract_id, DELIMETER, token_id);

        let sale = self.sales.get(&contract_and_token_id).expect("No sale");

        require!(
            sale.sale_conditions.ft_contract_id == ft_contract_id,
            format!("Cannot Purchase with {} tokens", ft_contract_id)
        );

        let price = sale.sale_conditions.price;

        require!(sale.owner_id != sender_id, "Cannot bid on your own sale.");
        require!(
            price.0 >= amount.0,
            "Attached tokens are less than the listed price"
        );

        PromiseOrValue::Promise(self.process_purchase(
            contract_id,
            token_id,
            amount,
            sender_id,
            Some(ft_contract_id),
        ))
    }

    //remove the sale, transfer and get the payout from the nft contract, and distribute royalties
    #[private]
    pub fn process_purchase(
        &mut self,
        nft_contract_id: AccountId,
        token_id: String,
        price: U128,
        buyer_id: AccountId,
        ft_contract_id: Option<FungibleTokenId>,
    ) -> Promise {
        let sale = self.delete_sale(nft_contract_id.clone(),
                                    token_id.clone());

        ext_contract::ext(nft_contract_id)
            .with_attached_deposit(1)
            .with_static_gas(GAS_FOR_NFT_TRANSFER)
            .nft_transfer_payout(
                buyer_id.clone(),
                token_id,
                sale.approval_id,
                "payout from market".to_string(), //memo (to include some context)
                price,
                7, //the maximum amount of accounts the market can payout at once, limited by GAS
            )
            .then(
                Self::ext(env::current_account_id())
                    .with_static_gas(GAS_FOR_RESOLVE_PURCHASE)
                    .resolve_purchase(buyer_id, price, ft_contract_id),
            )
    }

    /*
        Authenticate the payout object. If everything is fine, it will pay the accounts.
        If there's a problem, refund the buyer for the price.
    */
    #[private]
    pub fn resolve_purchase(
        &mut self,
        buyer_id: AccountId,
        price: U128,
        ft_contract_id: Option<FungibleTokenId>,
    ) -> U128 {
        let payout_option = promise_result_as_success().and_then(|value| {
            near_sdk::serde_json::from_slice::<Payout>(&value)
                .ok()
                .and_then(|payout_object| {
                    if payout_object.payout.len() > 7 || payout_object.payout.is_empty() {
                        env::log_str("Cannot have more than 7 royalties");
                        None
                    } else {
                        let mut remainder = price.0;

                        for &value in payout_object.payout.values() {
                            remainder = remainder.checked_sub(value.0)?;
                        }
                        if remainder == 0 || remainder == 1 {
                            Some(payout_object.payout)
                        } else {
                            None
                        }
                    }
                })
        });

        let payout = if let Some(payout_option) = payout_option {
            payout_option
        } else {
            match ft_contract_id {
                Some(ft_contract_id) => {
                    let memo = Some("Marketplace Refund".to_string());

                    ext_contract::ext(ft_contract_id)
                        .with_attached_deposit(1)
                        .with_static_gas(GAS_FOR_FT_TRANSFER)
                        .ft_transfer(buyer_id, price, memo);
                }
                None => {
                    Promise::new(buyer_id).transfer(u128::from(price));
                }
            }
            return price;
        };

        match ft_contract_id {
            Some(ft_contract_id) => {
                let memo = Some("Marketplace Royalties".to_string());
                for (receiver_id, amount) in payout {
                    ext_contract::ext(ft_contract_id.clone())
                        .with_attached_deposit(1)
                        .with_static_gas(GAS_FOR_FT_TRANSFER)
                        .ft_transfer(receiver_id, amount, memo.clone());
                }
            }
            None => {
                for (receiver_id, amount) in payout {
                    Promise::new(receiver_id).transfer(amount.0);
                }
            }
        }
        price
    }
}

/*
    used to resolve the promise for nft_transfer_payout. Authenticate the payout object.
    If everything is fine, pay the accounts.
    If there's a problem, refund the buyer for the price.
*/
#[ext_contract(ext_self)]
trait ExtSelf {
    fn resolve_purchase(
        &mut self,
        buyer_id: AccountId,
        price: U128,
        ft_contract_id: Option<FungibleTokenId>,
    ) -> Promise;
}

'''
'''--- sale_views.rs ---
use crate::*;

#[near_bindgen]
impl Contract {
    /// views

    //returns the amount of sales made in the market (as a string)
    pub fn get_supply_sales(&self) -> U64 {
        //returns the sales object length wrapped as a U64
        U64(self.sales.len())
    }

    //returns the amount of sales made under a specific account (result is a string)
    pub fn get_supply_by_owner_id(&self, account_id: AccountId) -> U64 {
        let by_owner_id = self.by_owner_id.get(&account_id);

        if let Some(by_owner_id) = by_owner_id {
            U64(by_owner_id.len())
        } else {
            U64(0)
        }
    }

    //returned for the specified account are paginated sale items. (Result is a Sales Vector)
    pub fn get_sales_by_owner_id(
        &self,
        account_id: AccountId,
        from_index: Option<U128>,
        limit: Option<u64>,
    ) -> Vec<Sale> {
        //get the set of token IDs for sale for the given account ID
        let by_owner_id = self.by_owner_id.get(&account_id);
        let sales = if let Some(by_owner_id) = by_owner_id {
            by_owner_id
        } else {
            return vec![];
        };

        // convert the UnorderedSet into a vector of strings
        let keys = sales.as_vector();

        let start = u128::from(from_index.unwrap_or(U128(0)));

        //iterate through the keys vector
        keys.iter()
            .skip(start as usize)
            .take(limit.unwrap_or(0) as usize)
            .map(|token_id| self.sales.get(&token_id).unwrap())
            .collect()
    }

    //get the number of sales for an nft contract. (returns a string)
    pub fn get_supply_by_nft_contract_id(&self, nft_contract_id: AccountId) -> U64 {
        let by_nft_contract_id = self.by_nft_contract_id.get(&nft_contract_id);

        if let Some(by_nft_contract_id) = by_nft_contract_id {
            U64(by_nft_contract_id.len())
        } else {
            U64(0)
        }
    }

    //returns paginated sale objects associated with a given nft contract. (result is a vector of sales)
    pub fn get_sales_by_nft_contract_id(
        &self,
        nft_contract_id: AccountId,
        from_index: Option<U128>,
        limit: Option<u64>,
    ) -> Vec<Sale> {
        let by_nft_contract_id = self.by_nft_contract_id.get(&nft_contract_id);

        let sales = if let Some(by_nft_contract_id) = by_nft_contract_id {
            by_nft_contract_id
        } else {
            return vec![];
        };

        let keys = sales.as_vector();

        let start = u128::from(from_index.unwrap_or(U128(0)));

        keys.iter()
            .skip(start as usize)
            .take(limit.unwrap_or(0) as usize)
            .map(|token_id| {
                self.sales
                    .get(&format!("{}{}{}", nft_contract_id, DELIMETER, token_id))
                    .unwrap()
            })
            .collect()
    }

    //get a sale information for a given unique sale ID (contract + DELIMITER + token ID)
    pub fn get_sale(&self, nft_contract_token: ContractAndTokenId) -> Option<Sale> {
        self.sales.get(&nft_contract_token)
    }
}

'''