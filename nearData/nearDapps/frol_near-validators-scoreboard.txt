*GitHub Repository "frol/near-validators-scoreboard"*

'''--- README.md ---
# NEAR Validators Scoreboard

This is a simple implementation of a scoreboard for NEAR Validators started during the [Stake Wars Episode II](https://near.org/blog/stake-wars-episode-ii/).

## Data Collection

A script fetching the stats about the validators epoch by epoch (the number of produced blocks and the number of expected blocks).

Deploying it as an hour-interval cron job will produce all the necessary stats.

### Setup

```
$ npm install
```

### Run

Single run produces a JSON file with the stats for the epoch before the current.

```
$ npm run collect:previous-epoch
```

## Data Aggregation

A simple script that produces the scoreboard CSV file from the collected epoch stats. The CSV format:

```
ACCOUNT_ID,NUM_PRODUCED_BLOCKS,NUM_EXPECTED_BLOCKS,ONLINE
a.betanet,99,100,99
node0,500,500,100
```

### Setup

```
$ npm install
```

You will also need the collected data in the current folder.

### Run

```
$ npm run aggregate:scoreboard
```

This will produce a `validators_scoreboard.csv` in the `stats` folder.

'''
'''--- package-lock.json ---
{
  "name": "near-validators-scoreboard",
  "version": "1.0.0",
  "lockfileVersion": 1,
  "requires": true,
  "dependencies": {
    "axios": {
      "version": "0.19.2",
      "resolved": "https://registry.npmjs.org/axios/-/axios-0.19.2.tgz",
      "integrity": "sha512-fjgm5MvRHLhx+osE2xoekY70AhARk3a6hkN+3Io1jc00jtquGvxYlKlsFUhmUET0V5te6CcZI7lcv2Ym61mjHA==",
      "requires": {
        "follow-redirects": "1.5.10"
      }
    },
    "debug": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/debug/-/debug-3.1.0.tgz",
      "integrity": "sha512-OX8XqP7/1a9cqkxYw2yXss15f26NKWBpDXQd0/uK/KPqdQhxbPa994hnzjcE2VqQpDslf55723cKPUOGSmMY3g==",
      "requires": {
        "ms": "2.0.0"
      }
    },
    "follow-redirects": {
      "version": "1.5.10",
      "resolved": "https://registry.npmjs.org/follow-redirects/-/follow-redirects-1.5.10.tgz",
      "integrity": "sha512-0V5l4Cizzvqt5D44aTXbFZz+FtyXV1vrDN6qrelxtfYQKW0KO0W2T/hkE8xvGa/540LkZlkaUjO4ailYTFtHVQ==",
      "requires": {
        "debug": "=3.1.0"
      }
    },
    "ms": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.0.0.tgz",
      "integrity": "sha1-VgiurfwAvmwpAd9fmGF4jeDVl8g="
    }
  }
}

'''
'''--- package.json ---
{
  "name": "near-validators-scoreboard",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "collect:previous-epoch": "node src/collect.js",
    "aggregate:scoreboard": "node src/aggregate-scoreboard.js"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "axios": "^0.19.2"
  }
}

'''
'''--- src/aggregate-scoreboard.js ---
const fs = require('fs')
const path = require('path')

async function aggregateValidatorsScoreboard(statsFolder) {
  const dir = await fs.promises.opendir(statsFolder)

  // Stats are: account_id => { num_produced_blocks, num_expected_blocks }
  const validatorsStats = new Map()

  for await (const statsFile of dir) {
    if (!statsFile.isFile() || !statsFile.name.match(/\d+\.json/)) {
      continue
    }
    const epochValidatorsStats = JSON.parse(fs.readFileSync(path.join(statsFolder, statsFile.name)))
    for (const epochValidatorStats of epochValidatorsStats) {
      const validatorStats = validatorsStats.get(epochValidatorStats.account_id)
      const num_produced_blocks =
        epochValidatorStats.num_produced_blocks + ((validatorStats || {}).num_produced_blocks || 0)
      const num_expected_blocks =
        epochValidatorStats.num_expected_blocks + ((validatorStats || {}).num_expected_blocks || 0)
      validatorsStats.set(epochValidatorStats.account_id, {
        num_produced_blocks,
        num_expected_blocks,
      })
    }
  }

  const validatorsScoreboard = [...validatorsStats.entries()]
  validatorsScoreboard.sort(([_1, validatorStats1], [_2, validatorStats2]) => {
    return validatorStats2.num_produced_blocks - validatorStats1.num_produced_blocks
  })

  fs.writeFileSync(
    path.join(statsFolder, 'validators_scoreboard.json'),
    JSON.stringify(
      validatorsScoreboard.map(([account_id, { num_produced_blocks, num_expected_blocks }]) => {
        return { account_id, num_expected_blocks, num_produced_blocks }
      }),
      null,
      2
    )
  )

  let validatorsScoreboardCsv = 'ACCOUNT_ID,NUM_PRODUCED_BLOCKS,NUM_EXPECTED_BLOCKS,ONLINE\n'
  for (const [account_id, validatorStats] of validatorsScoreboard) {
    validatorsScoreboardCsv += `"${account_id}",${validatorStats.num_produced_blocks},${
      validatorStats.num_expected_blocks
    },${validatorStats.num_produced_blocks / validatorStats.num_expected_blocks}\n`
  }

  fs.writeFileSync(path.join(statsFolder, 'validators_scoreboard.csv'), validatorsScoreboardCsv)
}

aggregateValidatorsScoreboard('./stats').catch(console.error)

'''
'''--- src/collect.js ---
const axios = require("axios");
const fs = require("fs");
const process = require("process");

const NEAR_RPC_URL = process.env.NEAR_RPC_URL || "https://rpc.betanet.near.org";

async function getValidators(url, blockHeight) {
  const { data } = await axios.post(url, {
    jsonrpc: "2.0",
    id: "dontcare",
    method: "validators",
    params: [blockHeight],
  });
  if (
    !data ||
    (!data.error && (!data.result || !data.result.epoch_start_height))
  ) {
    throw Error(`Unknown API response: ${data}`);
  }
  return data;
}

async function getEpochStart(url, blockHeight) {
  try {
    const response = await getValidators(url, blockHeight || null);
    if (response.error) {
      throw Error(response.error);
    }
    const { epoch_start_height: epochStartHeight } = response.result;
    return epochStartHeight;
  } catch (error) {
    console.log("error: ", error);
    throw error;
  }
}

async function fetchValidationStats(url, blockHeight) {
  if (!blockHeight) {
    blockHeight = (await getEpochStart(url)) - 1;
  }
  while (true) {
    console.log(
      "Trying to fetch validation stats for the block #",
      blockHeight
    );
    const currentValidators = await getValidators(url, blockHeight);
    if (currentValidators.result) {
      return {
        blockHeight,
        validators: currentValidators.result.current_validators,
      };
    }
    --blockHeight;
  }
}

function writeFile({ blockHeight, validators }) {
  const jsonData = JSON.stringify(validators, null, 2);
  try {
    fs.mkdirSync("stats");
  } catch {}
  fs.writeFileSync(`stats/${blockHeight}.json`, jsonData);
  console.log("Saved validation stats as of block #", blockHeight);
}

async function fetchHistoricalValidationStats(url) {
  let blockHeight;
  while (true) {
    const validationStats = await fetchValidationStats(url, blockHeight);
    writeFile(validationStats);
    blockHeight = (await getEpochStart(url, validationStats.blockHeight)) - 1;
  }
}

fetchValidationStats(NEAR_RPC_URL).then(writeFile);
//fetchHistoricalValidationStats(NEAR_RPC_URL);

// const delayInterval = setInterval(sendData, 2000);

'''