*GitHub Repository "near/borsh-rs"*

'''--- .github/test.sh ---
#!/usr/bin/env bash

# NOTE: `cargo test [TESTNAME]` is used to filter only the submodule with tests to test a 
# specific feature or features' combination 
# e.g. `cargo test --features rc,unstable__schema 'schema::test_rc'` is used to test `BorshSchema`
# implementation of `std::rc::Rc` and `std::sync::Arc`, 
# where `[TESTNAME]` argument is set to `schema::test_rc`, which includes tests from `schema::test_rc`
# submodule of `borsh/tests/tests.rs` to be run. 
set -e
set -x
export INSTA_UPDATE=no
pushd borsh
############################ borsh `default-features = true` group #########################
########## general group
cargo test --no-run
cargo test
cargo test --features derive
cargo test --features unstable__schema
########## features = ["ascii"] group
cargo test --features ascii 'roundtrip::test_ascii_strings'
cargo test --features ascii 'deserialization_errors::test_ascii_strings'
cargo test --features ascii,unstable__schema 'schema::test_ascii_strings'
########## features = ["rc"] group
cargo test --features rc 'roundtrip::test_rc'
cargo test --features rc,unstable__schema 'schema::test_rc'
########## features = ["de_strict_order"] group
cargo test --features de_strict_order 'roundtrip::test_hash_map'
cargo test --features de_strict_order 'roundtrip::test_btree_map'
########## features = ["bson"] group
cargo test --features bson,derive 'roundtrip::requires_derive_category::test_bson_object_ids'
########## features = ["bytes"] group
cargo test --features bytes,derive 'roundtrip::requires_derive_category::test_ultimate_many_features_combined'

############################ borsh `default-features = false` group #########################
########## general group
cargo test --no-default-features
cargo test --no-default-features --features derive
cargo test --no-default-features --features unstable__schema
########## features = ["ascii"] group
cargo test --no-default-features --features ascii 'roundtrip::test_ascii_strings'
cargo test --no-default-features --features ascii 'deserialization_errors::test_ascii_strings'
cargo test --no-default-features --features ascii,unstable__schema 'schema::test_ascii_strings'
########## features = ["rc"] group
cargo test --no-default-features --features rc 'roundtrip::test_rc'
cargo test --no-default-features --features rc,unstable__schema 'schema::test_rc'
########## features = ["hashbrown"] group
cargo test --no-default-features --features hashbrown
cargo test --no-default-features --features hashbrown,derive
cargo test --no-default-features --features hashbrown,unstable__schema
popd
pushd borsh-derive
############################ borsh-derive group #########################
cargo test --features schema

'''
'''--- .github/workflows/rust.yml ---
name: Rust

permissions:
  pull-requests: write
  contents: write

on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]

env:
  CARGO_TERM_COLOR: always
  RUSTFLAGS: '-D warnings'
  CARGO_INCREMENTAL: 0
  RUST_BACKTRACE: short

jobs:
  tests:
    strategy:
      matrix:
        rust_version: [1.67.0, stable]
    runs-on: ubuntu-20.04

    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0
    - name: Install Rust toolchain
      uses: actions-rs/toolchain@v1
      with:
        toolchain:  ${{ matrix.rust_version }}

    - name: set default rust toolchain
      run: rustup default ${{ matrix.rust_version }}
    - name: print rustc version
      run: rustc --version
    - name: downgrade `toml_edit`, time`, `toml_datetime` crate to support older Rust toolchain
      if: matrix.rust_version == '1.67.0' 
      run: |
        cargo update -p toml_edit --precise 0.21.0
    - name: Run tests
      run: ./.github/test.sh

  # remove this job when https://github.com/rust-lang/rust/issues/89554 stabilizes
  test_exhaustive_checks:
    runs-on: ubuntu-20.04
    steps:
    - uses: actions/checkout@v4
    - name: Install nightly for exhaustive check tests
      uses: dtolnay/rust-toolchain@nightly
    # a failure on this check means, that some of `syn` crate's enums have been extended
    # with new variants.
    # consult https://github.com/serde-rs/serde/blob/master/serde_derive/src/bound.rs#L100 , 
    # the implementation of `FindTyParams` may have been updated already 
    - name: Run exhaustive check tests
      run: RUSTFLAGS="-A unused_imports -D warnings" cargo check --workspace --features force_exhaustive_checks

  clippy:
    runs-on: ubuntu-20.04

    steps:
    - uses: actions/checkout@v4
    - name: Run clippy
      run: cargo clippy --features unstable__schema --benches -- -D clippy::all

  cargo-fmt:
    runs-on: ubuntu-20.04

    steps:
    - uses: actions/checkout@v4
    - name: Run cargo fmt
      run: cargo fmt --check

  # there're sometimes warnings, which signal, that the generated doc
  # won't look as expected, when rendered, and sometimes errors, which will prevent doc from being
  # generated at release time altogether.
  cargo-doc:
    runs-on: ubuntu-20.04

    steps:
    - uses: actions/checkout@v4
    - name: run cargo doc
      run: RUSTDOCFLAGS="-D warnings" cargo doc --features derive,unstable__schema

  release-plz:
    runs-on: ubuntu-latest
    needs: [tests, clippy, cargo-fmt]
    if: github.ref == 'refs/heads/master'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.CUSTOM_GITHUB_TOKEN }}
      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable
      - name: Run release-plz
        uses: MarcoIeni/release-plz-action@v0.5
        env:
          # https://marcoieni.github.io/release-plz/github-action.html#triggering-further-workflow-runs
          GITHUB_TOKEN: ${{ secrets.CUSTOM_GITHUB_TOKEN }}
          CARGO_REGISTRY_TOKEN: ${{ secrets.CARGO_REGISTRY_TOKEN }}

'''
'''--- CHANGELOG.md ---
# Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

## [1.5.0](https://github.com/near/borsh-rs/compare/borsh-v1.4.0...borsh-v1.5.0) - 2024-04-29

### Added
- implement `BorshSchema` for `VecDeque` and `LinkedList` ([#291](https://github.com/near/borsh-rs/pull/291))

### Other
- Fix repository field of borsh-derive ([#288](https://github.com/near/borsh-rs/pull/288))

## [1.4.0](https://github.com/near/borsh-rs/compare/borsh-v1.3.1...borsh-v1.4.0) - 2024-03-25

### Added
- impl `BorshSchema` for `Cow<'a, T>` ([#284](https://github.com/near/borsh-rs/pull/284))
- `BorshSerialize`/`BoshDeserialize`/`BorshSchema` for `Cell`/`RefCell` ([#265](https://github.com/near/borsh-rs/pull/265))

### Other
- reorg tests ([#285](https://github.com/near/borsh-rs/pull/285))
- remove conflicts with `W`/`R` parameters for `BorshSerialize`/`BorshDeserialize` derives ([#283](https://github.com/near/borsh-rs/pull/283))
- fix `test_exhaustive_checks` step + downgrade package for MSRV test ([#280](https://github.com/near/borsh-rs/pull/280))

## [1.3.1](https://github.com/near/borsh-rs/compare/borsh-v1.3.0...borsh-v1.3.1) - 2024-01-10

### Other
- fix clippy ([#275](https://github.com/near/borsh-rs/pull/275))
- bump `proc-macro-crate` to `3`; bump MSRV to `1.67` ([#274](https://github.com/near/borsh-rs/pull/274))

## [1.3.0](https://github.com/near/borsh-rs/compare/borsh-v1.2.1...borsh-v1.3.0) - 2023-12-07

### Added
- impl `BorshSchema` for `Rc` and `Arc`; add doc for `rc` feature ([#268](https://github.com/near/borsh-rs/pull/268))

## [1.2.1](https://github.com/near/borsh-rs/compare/borsh-v1.2.0...borsh-v1.2.1) - 2023-12-06

### Other
- optimize `BorshSerialize` derive for enums with unit variants ([#262](https://github.com/near/borsh-rs/pull/262))
- fix `release-plz` error; exclude `*.snap` from `borsh-derive` publish ([#263](https://github.com/near/borsh-rs/pull/263))

## [1.2.0](https://github.com/near/borsh-rs/compare/borsh-v1.1.2...borsh-v1.2.0) - 2023-11-13

### Added
- add support for types from `ascii` crate ([#255](https://github.com/near/borsh-rs/pull/255))

## [1.1.2](https://github.com/near/borsh-rs/compare/borsh-v1.1.1...borsh-v1.1.2) - 2023-11-08

### Other
- bump `proc-macro-crate` to 2.0.0 in `borsh-derive` ([#256](https://github.com/near/borsh-rs/pull/256))

## [1.1.1](https://github.com/near/borsh-rs/compare/borsh-v1.1.0...borsh-v1.1.1) - 2023-10-25

### Other
- add `test_schema_conflicts` ([#254](https://github.com/near/borsh-rs/pull/254))
- addressed warnings in docs generation ([#252](https://github.com/near/borsh-rs/pull/252))
- simplify discriminants handling in schema derives ([#241](https://github.com/near/borsh-rs/pull/241))

## [1.1.0](https://github.com/near/borsh-rs/compare/borsh-v1.0.0...borsh-v1.1.0) - 2023-10-13

### Added
- relax `schema_container_of` target requirement with `?Sized` to allow slices ([#245](https://github.com/near/borsh-rs/pull/245))

### Fixed
- fully qualify `#cratename::BorshSchema` in derive-generated code to void function name collisions leading to compilation errors ([#244](https://github.com/near/borsh-rs/pull/244))

## [1.0.0](https://github.com/near/borsh-rs/compare/borsh-v0.10.3...borsh-v1.0.0) - 2023-10-03

> The year is 2653 and the best yet-to-be citizens of the Terran Federation are fighting 
> and mostly just dying in a relentless interstellar war against the Arachnids.
> Yet the structure of our society has changed through the course of this confrontation. 
> 
> The members of the Arachnid brain caste and queens have infiltrated the circles of our 
> most influential political and industrial leaders. Either directly, or via the Arachnid technology
> called "Brain Bugs". This tech alone can accomplish what the Arachnid starship paratroopers
> will not ever be capable to do.
>
> Simple, straightforward and performant serialization libraries can set us in course to remedy this dangerous
> stalemate situation by cleaning the minds of its users from even the tiniest of Brain Bugs.

Robert A. Heinlein, 1959 (a newspaper ad)
---

### [Thanks]

`borsh-rs` `1.0.0` release was first conceived and then brought into existence by minds of:

- Amirhossein Akhlaghpour @Mehrbod2002
- Benji Smith @Benjins
- dj8yf0μl @dj8yfo
- iho @iho
- Jacob Lindahl @encody
- Pavel Lazureykis @lazureykis
- Tomas Zemanovic @tzemanovic

Contributors, who imposed powerful impact on the past, present and future of this library are specially recognized:

- Michal Nazarewicz @mina86 - for revisiting `BorshSchema` feature, rethinking it, bringing up great ideas and coming up with the
  fairly involved algorithm of `max_serialized_size` implementation.
- Alex Kladov @matklad - for maintaining a superhuman ability of context switching in under 2 minutes and scanning through 15k lines of code
  in under 10 minutes, while leaving out under 1% relevant details.   
- Marco Ieni @MarcoIeni - for developing [release-plz](https://github.com/MarcoIeni/release-plz) automation.
- Vlad Frolov @frol - for keeping an eye on the big picture and striking just the right balance between 
  performance and versatility, ease of use and extensibility and tons of other such hard to reconcile pairs.   

### [Migration guides]

This section contains links to short documents, describing problems encountered during update of `borsh`
version to `v1.0.0` for related repositories.

- [v0.10.2 -> v1.0.0 for `nearcore`](./docs/migration_guides/v0.10.2_to_v1.0.0_nearcore.md)
- [v0.9.3 -> v1.0.0 for `near-sdk-rs`](./docs/migration_guides/v0.9_to_v1.0.0_near_sdk_rs.md)

### [Summary of changes]

- Library's structure was made more modular and optimized with respect to visibility
  of its public/private constituents and ease of access to them.
- `borsh`'s traits derives and their attributes had their capabilities extended and unified,
  both with respect to external interfaces and internal implementation. Please visit [borsh_derive](https://docs.rs/borsh-derive/1.0.0/borsh_derive/)
  documentation pages if you're interested in more of the details.
- The consistency property of deserialization, declared in [Borsh Specification](https://borsh.io/), became an
  opt-in feature `de_strict_order` for hash collections.
- Support of explicit enum discriminants was added to derives of `borsh` traits. 
  It has been added in somewhat limited form, only allowing the values of `u8` range literals.

  ```rust
  use borsh::{BorshSerialize, BorshDeserialize, BorshSchema};

  <<<<<<< borsh-v0.10.3
  #[derive(BorshDeserialize, BorshSerialize, BorshSchema)]
  pub enum CurveType {
      ED25519 = 0, // 0 as u8 in enum tag
      SECP256K1 = 2, // 1 as u8 in enum tag
  }
  =======
  #[derive(BorshDeserialize, BorshSerialize, BorshSchema)]
  #[borsh(use_discriminant=false)]
  pub enum CurveType {
      ED25519 = 0, // 0 as u8 in enum tag
      SECP256K1 = 2, // 1 as u8 in enum tag
  }
  // vs
  #[derive(BorshDeserialize, BorshSerialize, BorshSchema)]
  #[borsh(use_discriminant=true)]
  pub enum CurveType {
      ED25519 = 0, // 0 as u8 in enum tag
      SECP256K1 = 2, // 2 as u8 in enum tag
  }
  >>>>>>> borsh-v1.0.0
  ```
- [RUSTSEC-2023-0033](https://rustsec.org/advisories/RUSTSEC-2023-0033.html) has been resolved.
  It has been resolved by forbidding collections with dynamic runtime length to contain zero-sized types
  with runtime errors, happening on serialization or deserialization.
  Arrays with non-`Copy` and non-`Clone` ZST singletons of length > 1 gracefully panic on deserialization,
  not causing memory faults. 
  
  Using collections with dynamic runtime length ([tagged sequences](https://docs.rs/borsh/1.0.0/borsh/schema/enum.Definition.html#variant.Sequence)) for containing ZSTs was also deemed
  wasteful of CPU cycles and a way to perform dos attacks.
  Such a case is now flagged as error when using new [`BorshSchemaContainer::validate`](https://docs.rs/borsh/1.0.0/borsh/schema/struct.BorshSchemaContainer.html#method.validate) method for user-defined
  types or instantiations of `BorshSchema`-supporting types with inappropriate parameters, defined by the library:

  ```rust
  let schema = BorshSchemaContainer::for_type::<Vec<core::ops::RangeFull>>();
  assert_eq!(
      Err(
        SchemaContainerValidateError::ZSTSequence("Vec<RangeFull>".to_string())
      ), 
      schema.validate()
  );
  ```
- `BorshSchema` was extended with [`max_serialized_size`](https://docs.rs/borsh/1.0.0/borsh/fn.max_serialized_size.html) implementation, which now unlocks support of `borsh`
  by a plethora of bounded types to express statically defined size limits of serialized representation of these types.  
- schema [`BorshSchemaContainer`](https://docs.rs/borsh/1.0.0/borsh/schema/struct.BorshSchemaContainer.html#impl-BorshSchemaContainer-2) api was made future-proof.
- schema [`Definition`](https://docs.rs/borsh/1.0.0/borsh/schema/enum.Definition.html#) was extended with more variants, fields and details to uncover some of the 
  implied details of serialization format.
  `BorshSchema` can now express a wider range of types. All types, which have `BorshSchema` defined by the library,
  now have a `Definition`.
- schema `Declaration`-s were renamed to follow Rust-first rule and not be a mix of Rust types naming/syntax and syntax
  from other languages.

  ```rust
  use borsh::schema::BorshSchema;

  <<<<<<< borsh-v0.10.3
  assert_eq!("nil", <()>::declaration());
  assert_eq!("string", <String>::declaration());
  assert_eq!("Array<u64, 42>", <[u64; 42]>::declaration());
  assert_eq!("Tuple<u8, bool, f32>", <(u8, bool, f32)>::declaration());
  =======
  assert_eq!("()", <()>::declaration());
  assert_eq!("String", <String>::declaration());
  assert_eq!("[u64; 42]", <[u64; 42]>::declaration());
  assert_eq!("(u8, bool, f32)", <(u8, bool, f32)>::declaration());
  >>>>>>> borsh-v1.0.0
  ```

### [Stability guarantee]

- `borsh`'s serialization format is guaranteed to NOT change throughout 1.x releases.
- `borsh`'s public APIs not gated by `unstable__schema` feature are guaranteed to NOT break
 throughout 1.x releases.
- It's perceived, that new feature requests may potentially come for `BorshSchema` from outside of `near` ecosystem,
thus `borsh`'s public APIs gated by `unstable__schema` MAY break throughout 1.x releases.

 
## [1.0.0-alpha.6](https://github.com/near/borsh-rs/compare/borsh-v1.0.0-alpha.5...borsh-v1.0.0-alpha.6) - 2023-10-02

### Added
- add `borsh::object_length` helper ([#236](https://github.com/near/borsh-rs/pull/236))

### Other
- add examples for `borsh::to_vec`, `borsh::to_writer`, `borsh::object_length` ([#238](https://github.com/near/borsh-rs/pull/238))
- [**breaking**] completely remove deprecated `BorshSerialize::try_to_vec` ([#221](https://github.com/near/borsh-rs/pull/221))

## [1.0.0-alpha.5](https://github.com/near/borsh-rs/compare/borsh-v1.0.0-alpha.4...borsh-v1.0.0-alpha.5) - 2023-09-26

### Added
- [**breaking**] add `DiscriminantValue` to `Definition::Enum::variants` tuples ([#232](https://github.com/near/borsh-rs/pull/232))
- [**breaking**] add `length_width` to `schema::Definition::Sequence` ([#229](https://github.com/near/borsh-rs/pull/229))
- add definition of `String`/`str` ([#226](https://github.com/near/borsh-rs/pull/226))
- [**breaking**] add `Definition::Sequence::length_range` field ([#220](https://github.com/near/borsh-rs/pull/220))
- [**breaking**] add `Definition::Primitive` ([#222](https://github.com/near/borsh-rs/pull/222))
- max_size: various small refactoring ([#223](https://github.com/near/borsh-rs/pull/223))
- check `Definition::Enum`’s `tag_width` when validating schema ([#224](https://github.com/near/borsh-rs/pull/224))
- add (de)serialisation + schema for more `core::ops::Range...` types (full, open-ended, inclusive) ([#213](https://github.com/near/borsh-rs/pull/213))
- add `BorshSchema` implementation for `core::num::NonZero...` integers ([#214](https://github.com/near/borsh-rs/pull/214))
- [**breaking**] introduce `borsh::io` with either items of `std:io` or private `borsh::nostd_io` module reexported (`std` or `no_std`) ([#212](https://github.com/near/borsh-rs/pull/212))
- Introduce `borsh::max_serialized_size` function, `borsh::schema::BorshSchemaContainer::for_type` method ([#209](https://github.com/near/borsh-rs/pull/209))

### Other
- [**breaking**] rename `"Tuple<T0, T1, T2...>"` -> `"(T0, T1, T2...)"` (`schema::Declaration`) ([#234](https://github.com/near/borsh-rs/pull/234))
- [**breaking**] rename `"nil"` -> `"()"`, `"string"` -> `"String"`, `"nonzero_u16"` -> `"NonZeroU16"` (`schema::Declaration`) ([#233](https://github.com/near/borsh-rs/pull/233))
- [**breaking**] rename `"Array<T0, N>"` -> `"[T0; N]"` (`schema::Declaration`) ([#235](https://github.com/near/borsh-rs/pull/235))
- [**breaking**] split `ValidationError` from `MaxSizeError`; `validate` and `max_serialized_size` made `BorshSchemaContainer`'s methods ([#219](https://github.com/near/borsh-rs/pull/219))
- [**breaking**] declare and rename schema feature to be unstable__ (may break in 1.x versions)
- Add Definition::Enum::tag_width field ([#215](https://github.com/near/borsh-rs/pull/215))

## [1.0.0-alpha.4](https://github.com/near/borsh-rs/compare/borsh-v1.0.0-alpha.3...borsh-v1.0.0-alpha.4) - 2023-09-04

### Added
- [**breaking**] raise bound on keys in hashcollections `PartialOrd` -> `Ord` ([#203](https://github.com/near/borsh-rs/pull/203))
- forbid most collections from containing zst elements/keys ([#202](https://github.com/near/borsh-rs/pull/202))
- add `#[borsh(crate = ...)]` item-level attribute ([#210](https://github.com/near/borsh-rs/pull/210))
- forbid multiple `borsh` attr occurencies ([#199](https://github.com/near/borsh-rs/pull/199))

### Other
- various flaws correction ([#205](https://github.com/near/borsh-rs/pull/205))
- [**breaking**] deprecate `try_to_vec` method from `BorshSerialize` ([#206](https://github.com/near/borsh-rs/pull/206))
- [**breaking**] make `BorshSchema::add_definition` default implementation a free-standing func ([#204](https://github.com/near/borsh-rs/pull/204))
- remove `#[non_exhaustive]` on `borsh::schema::Definition` ([#200](https://github.com/near/borsh-rs/pull/200))

## [1.0.0-alpha.3](https://github.com/near/borsh-rs/compare/borsh-v1.0.0-alpha.2...borsh-v1.0.0-alpha.3) - 2023-08-16

### Other
- [**breaking**] renamed #[borsh_skip] to #[borsh(skip)] ([#192](https://github.com/near/borsh-rs/pull/192))
- split up schema derive functions ([#191](https://github.com/near/borsh-rs/pull/191))

## [1.0.0-alpha.2](https://github.com/near/borsh-rs/compare/borsh-v1.0.0-alpha.1...borsh-v1.0.0-alpha.2) - 2023-08-10

### Other
- [**breaking**] borsh_init to borsh(init).  ([#187](https://github.com/near/borsh-rs/pull/187))

## [1.0.0-alpha.1](https://github.com/near/borsh-rs/compare/borsh-v0.11.0...borsh-v1.0.0-alpha.1) - 2023-08-07

### Bug Fixes

- Unused fields warn, fields for inner structs of derived BorshSchema method (#172)
- #[borsh_skip] on field of struct enum variant (BorshSerialize) (#174)
- Filter out foreign attributes in `BorshSchema` derive for enum (#177)

### Documentation

- Create a brief documentation of crate's features (#159)
- Mention `schema` feature in doc.rs (#166)

### Features

- Forbid Vectors of Zero-sized types from de-/serialization to resolve the RUSTSEC-2023-0033 (#145)
- Add top-level `from_slice` and `from_reader` helper functions to make the API nicer (#142)
- [**breaking**] Add `#[borsh(use_discriminant = <bool>)]` attribute that changes enum discriminant de- and serialization behavior
- [**breaking**] Remove `BinaryHeap` support (#161)
- Sets/maps benches for reference point (#164)
- Enforce canonicity on `HashSet/BTreeSet/HashMap/BTreeMap` (#162)
- [**breaking**] Support recursive structures! (#178)
  - `BorshSerialize`, `BorshDeserialize`, `BorshSchema` derives may break
  - derives may require patching bounds with `#[borsh(bound(..))]` / `#[borsh(schema(params = ...))]`
- Bounds for ser/de derive and schema_params for schema derive attributes (#180)
- Derive attribute for 3rd party structs/enums as fields (#182)

### Miscellaneous Tasks

- Bump proc-macro-crate versions  (#149)
- Add tests job for MSRV (1.65.0) (#151)
- [**breaking**] Hide maybestd from public interface, despite it being technically available by new name of __maybestd (#153)
- Fix broken reference-style link in minimum supported version badge (#154)
- Remove a bunch of clippy-related TODOs (uninlined_format_args) (#156)
- Simpler bounds on Rc/Arc impls (#167)
- Invited @dj8yfo to CODEOWNERS (#169)
- [**breaking**] Replace ErrorKind::InvalidInput with ErrorKind::InvalidData as per original std::io meaning (#170)

### Refactor

- [**breaking**] Make `hashbrown` dependency optional, `hashbrown` feature (#155)
- [**breaking**] `BorshSchemaContainer` fields non-pub, `HashMap` -> `BTreeMap` in schema everywhere (#165)
- [**breaking**] Move derive under #[cfg(feature = "derive")] (#168)
- Introduce `__private` module with macro runtime (#171)
- [**breaking**] Unsplit and removal of *-internal crates (#185)
  - `borsh-schema-derive-internal` and `borsh-derive-internal` crates won't be published anymore

### Testing

- Add `insta` snapshots to borsh/tests (#157)
- `insta` tests for prettified `TokenStream`-s in `borsh*derive-internal` (#176)

### Ci

- Only release-plz after other checks pass

## [0.11.0](https://github.com/near/borsh-rs/compare/borsh-v0.10.3...borsh-v0.11.0) - 2023-05-31

### Added
- add BorshSchema for PhantomData, BTreeMap and BTreeSet ([#93](https://github.com/near/borsh-rs/pull/93))
- Add optional bson::oid::ObjectId support ([#135](https://github.com/near/borsh-rs/pull/135))
- [**breaking**] ser/de enum discriminant ([#138](https://github.com/near/borsh-rs/pull/138))

### Fixed
- no-std tests did not run due to dev-dependencies re-enabling std feature ([#144](https://github.com/near/borsh-rs/pull/144))

### Other
- use release-plz and specify common rust version correctly ([#134](https://github.com/near/borsh-rs/pull/134))
- Upgrade plain-HTTP links to HTTPS in Cargo.toml files ([#141](https://github.com/near/borsh-rs/pull/141))

## [0.10.3] - 2023-03-22

- Add optional bytes/bytesmut support

## [0.10.2] - 2023-02-14

- Prevent unbound allocation for vectors on deserialization

## [0.10.1] - 2023-02-08

- Implemented (de)ser for `core::ops::range`
- Introduce de::EnumExt trait with deserialize_variant method

## [0.10.0] - 2023-01-19

- Fix no-std feature (some of the imports incorrectly used `std::` instead of `crate::maybestd::`)
- Fix borsh-schema derives with `for` bounds
- Implemented BorshSchema for HashSet
- Add support for isize, usize types
- Delete schema for char
- Implement ser/de and schema for (T,)
- Add clone impls to borsh schema types
- Remove unnecessary trait bounds requirements for array
- *BREAKING CHANGE*: `BorshDeserialize` now works by receiving an `&mut std::io::Read`
  instead of a `&mut &[u8]`. This is a breaking change for code that provides custom
  implementations of `BorshDeserialize`; there is no impact on code that uses only the
  derive macro.
- Added `BorshDeserialize::try_from_reader` and `BorshDeserialize::deserialize_reader`.
- Upgrade hashbrown version to be `>=0.11,<0.14` to allow wider range of versions.

## [0.9.3] - 2022-02-03

- Fix `no_std` compatibility.
- Reduce code bloat in derived `BorshSerialize` impl for enums.

## [0.9.2] - 2022-01-25

- Upgrade hashbrown from `0.9` to `0.11`. This can breakage in the rare case
  that you use borsh schema together with no-std support and rely on a specific
  version hashbrown of `SchemaContainer`. This is considered to be obscure
  enough to not warrant a semver bump.

## [0.9.1] - 2021-07-14

- Eliminated unsafe code from both ser and de of u8 (#26)
- Implemented ser/de for reference count types (#27)
- Added serialization helpers to improve api ergonomics (#34)
- Implemented schema for arrays and fix box bounds (#36)
- Implemented (de)ser for PhantomData (#37)
- Implemented const-generics under feature (#38)
- Added an example of direct BorshSerialize::serialize usage with vector and slice buffers (#29)

## [0.9.0] - 2021-03-18

- *BREAKING CHANGE*: `is_u8` optimization helper is now unsafe since it may
  cause undefined behavior if it returns `true` for the type that is not safe
  to Copy (#21)
- Extended the schema impls to support longer arrays to match the
  de/serialization impls (#22)

## [0.8.2] - 2021-03-04

- Avoid collisions of imports due to derive-generated code (#14)

## [0.8.1] - 2021-01-13

- Added support for BTreeMap, BTreeSet, BinaryHeap, LinkedList, and VecDeque

## [0.8.0] - 2021-01-11

- Add no_std support.

## [0.7.2] - 2021-01-14

- Implement `BorshSerialize` for reference fields (`&T`)

## 0.7.1 - 2020-08-24

- Implement `BorshSerialize` for `&T` if `T` implements `BorshSerialize`.

## 0.7.0 - 2020-06-17

- Extended `Box<T>` implementation for `?Sized` types (`[T]`, `str`, ...).
- Added support for `std::borrow::Cow`
- Avoid silent integer casts since they can lead to hidden security issues.
- Removed `Cargo.lock` as it is advised for lib crates.

[unreleased]: https://github.com/near/borsh-rs/compare/v0.9.3...HEAD
[0.9.3]: https://github.com/near/borsh-rs/compare/v0.9.2...v0.9.3
[0.9.2]: https://github.com/near/borsh-rs/compare/v0.9.1...v0.9.2
[0.9.1]: https://github.com/near/borsh-rs/compare/v0.9.0...v0.9.1
[0.9.0]: https://github.com/near/borsh-rs/compare/v0.8.2...v0.9.0
[0.8.2]: https://github.com/near/borsh-rs/compare/v0.8.1...v0.8.2
[0.8.1]: https://github.com/near/borsh-rs/compare/v0.8.0...v0.8.1
[0.8.0]: https://github.com/near/borsh-rs/compare/v0.7.2...v0.8.0
[0.7.2]: https://github.com/near/borsh-rs/releases/tag/v0.7.2

'''
'''--- Cargo.toml ---
[workspace]
members = ["borsh", "borsh-derive", "fuzz/fuzz-run", "benchmarks"]

[workspace.package]
# shared version of all public crates in the workspace
version = "1.5.0"
rust-version = "1.67.0"

'''
'''--- README.md ---
# Borsh in Rust &emsp; [![Latest Version]][crates.io] [![borsh: rustc 1.67+]][Rust 1.67] [![License Apache-2.0 badge]][License Apache-2.0] [![License MIT badge]][License MIT]

[Borsh]: https://borsh.io
[Latest Version]: https://img.shields.io/crates/v/borsh.svg
[crates.io]: https://crates.io/crates/borsh
[borsh: rustc 1.67+]: https://img.shields.io/badge/rustc-1.67+-lightgray.svg
[Rust 1.67]: https://blog.rust-lang.org/2023/01/26/Rust-1.67.0.html
[License Apache-2.0 badge]: https://img.shields.io/badge/license-Apache2.0-blue.svg
[License Apache-2.0]: https://opensource.org/licenses/Apache-2.0
[License MIT badge]: https://img.shields.io/badge/license-MIT-blue.svg
[License MIT]: https://opensource.org/licenses/MIT

**borsh-rs** is Rust implementation of the [Borsh] binary serialization format.

Borsh stands for _Binary Object Representation Serializer for Hashing_. It is meant to be used in
security-critical projects as it prioritizes [consistency, safety, speed][Borsh], and comes with a
strict [specification](https://github.com/near/borsh#specification).

## Example

```rust
use borsh::{BorshSerialize, BorshDeserialize, from_slice, to_vec};

#[derive(BorshSerialize, BorshDeserialize, PartialEq, Debug)]
struct A {
    x: u64,
    y: String,
}

#[test]
fn test_simple_struct() {
    let a = A {
        x: 3301,
        y: "liber primus".to_string(),
    };
    let encoded_a = to_vec(&a).unwrap();
    let decoded_a = from_slice::<A>(&encoded_a).unwrap();
    assert_eq!(a, decoded_a);
}
```

## Features

Opting out from Serde allows borsh to have some features that currently are not available for serde-compatible serializers.
Currently we support two features: `borsh(init=<your initialization method name>` and `borsh(skip)` (the former one not available in Serde).

`borsh(init=...)` allows to automatically run an initialization function right after deserialization. This adds a lot of convenience for objects that are architectured to be used as strictly immutable. Usage example:

```rust
#[derive(BorshSerialize, BorshDeserialize)]
#[borsh(init=init)]
struct Message {
    message: String,
    timestamp: u64,
    public_key: CryptoKey,
    signature: CryptoSignature
    hash: CryptoHash
}

impl Message {
    pub fn init(&mut self) {
        self.hash = CryptoHash::new().write_string(self.message).write_u64(self.timestamp);
        self.signature.verify(self.hash, self.public_key);
    }
}
```

`borsh(skip)` allows to skip serializing/deserializing fields, assuming they implement `Default` trait, similarly to `#[serde(skip)]`.

```rust
#[derive(BorshSerialize, BorshDeserialize)]
struct A {
    x: u64,
    #[borsh(skip)]
    y: f32,
}
```

### Enum with explicit discriminant

`#[borsh(use_discriminant=false|true])` is required if you have an enum with explicit discriminant. This setting affects `BorshSerialize` and `BorshDeserialize` behaviour at the same time.

In the future, borsh will drop the requirement to explicitly use `#[borsh(use_discriminant=false|true)]`, and will default to `true`, but to make sure that the transition from the older versions of borsh (before 0.11 release) does not cause silent breaking changes in de-/serialization, borsh 1.0 will require to specify if the explicit enum discriminant should be used as a de-/serialization tag value.

If you don't specify `use_discriminant` option for enum with explicit discriminant, you will get an error:

```bash
error: You have to specify `#[borsh(use_discriminant=true)]` or `#[borsh(use_discriminant=false)]` for all enums with explicit discriminant
```

In order to preserve the behaviour of borsh versions before 0.11, which did not respect explicit enum discriminants for de-/serialization, use `#[borsh(use_discriminant=false)]`, otherwise, use `true`:

```rust
#[derive(BorshDeserialize, BorshSerialize)]
#[borsh(use_discriminant=false)]
enum A {
    X,
    Y = 10,
}
```

## Testing

Integration tests should generally be preferred to unit ones. Root module of integration tests of `borsh` crate is [linked](./borsh/tests/tests.rs) here.
 
## Releasing

The versions of all public crates in this repository are collectively managed by a single version in the [workspace manifest](https://github.com/near/borsh-rs/blob/master/Cargo.toml).

So, to publish a new version of all the crates, you can do so by simply bumping that to the next "patch" version and submit a PR.

We have CI Infrastructure put in place to automate the process of publishing all crates once a version change has merged into master.

However, before you release, make sure the [CHANGELOG](CHANGELOG.md) is up to date and that the `[Unreleased]` section is present but empty.

## License

This repository is distributed under the terms of both the MIT license and the Apache License (Version 2.0).
See [LICENSE-MIT](LICENSE-MIT) and [LICENSE-APACHE](LICENSE-APACHE) for details.

'''
'''--- benchmarks/Cargo.toml ---
[package]
name = "benchmarks"
version.workspace = true
rust-version.workspace = true
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2018"
publish = false

# This is somehow needed for command line arguments to work: https://github.com/bheisler/criterion.rs/issues/193#issuecomment-415740713
[lib]
bench = false

[dependencies]
rand_xorshift = "0.2.0"
rand = "0.7.0"
borsh = { path = "../borsh", default-features = false }
serde = { version = "1.0", features = ["derive"] }
speedy-derive = "0.5"
speedy = "0.5"

[dev-dependencies]
criterion = "0.3.0"
bincode = "1.1.4"
serde_cbor = "0.10"

[[bench]]
name = "bench"
harness = false

[[bench]]
name = "maps_sets_inner_ser"
harness = false

[[bench]]
name = "maps_sets_inner_de"
harness = false

[[bench]]
name = "object_length"
harness = false

[features]
default = ["borsh/std", "borsh/derive"]

'''
'''--- benchmarks/README.md ---
# Borsh benchmarks

To run benchmarks execute:

```bash
cargo bench
```

If you want to make a change and see how it affects the performance then
copy `criterion` folder from `docs` into `target` folder so that you have `target/criterion`, and run the benchmarks.
Criterion will print whether the change has statistically significant positive/negative impact based on p-values or
whether it is within noise. Unfortunately, benchmarks related to serializing `Account` and `SignedTransaction` turned out to
be highly volatile therefore prefer using `Block` and `BlockHeader` as the measurement of the performance change.
We use default Criterion setting for determining statistical significance, which corresponds to 2 sigma.

We run benchmarks using `n1-standard-2 (2 vCPUs, 7.5 GB memory)` on GCloud. Make sure the instance
is not running any other heavy process.

'''
'''--- benchmarks/benches/bench.rs ---
use benchmarks::{Account, Block, BlockHeader, Generate, SignedTransaction};
use borsh::{from_slice, to_vec, BorshDeserialize, BorshSerialize};
use rand::SeedableRng;
use serde::{Deserialize as SerdeDeserialize, Serialize as SerdeSerialize};
use speedy::Endianness;
use speedy::{Readable, Writable};

use criterion::{criterion_group, criterion_main, BenchmarkId, Criterion, Throughput};

fn ser_obj<T>(group_name: &str, num_samples: usize, c: &mut Criterion)
where
    for<'a> T: Generate
        + BorshSerialize
        + BorshDeserialize
        + SerdeSerialize
        + SerdeDeserialize<'a>
        + Readable<'a, speedy::Endianness>
        + Writable<speedy::Endianness>
        + 'static,
{
    let mut rng = rand_xorshift::XorShiftRng::from_seed([0u8; 16]);
    let mut group = c.benchmark_group(group_name);

    let objects: Vec<_> = (0..num_samples).map(|_| T::generate(&mut rng)).collect();
    let borsh_datas: Vec<Vec<u8>> = objects.iter().map(|t| to_vec(t).unwrap()).collect();
    let borsh_sizes: Vec<_> = borsh_datas.iter().map(|d| d.len()).collect();

    for i in 0..objects.len() {
        let size = borsh_sizes[i];
        let obj = &objects[i];

        let benchmark_param_display = format!("idx={}; size={}", i, size);

        group.throughput(Throughput::Bytes(size as u64));
        group.bench_with_input(
            BenchmarkId::new("cbor", benchmark_param_display.clone()),
            obj,
            |b, d| {
                b.iter(|| serde_cbor::to_vec(d).unwrap());
            },
        );
        group.bench_with_input(
            BenchmarkId::new("bincode", benchmark_param_display.clone()),
            obj,
            |b, d| {
                b.iter(|| bincode::serialize(d).unwrap());
            },
        );
        group.bench_with_input(
            BenchmarkId::new("borsh", benchmark_param_display.clone()),
            obj,
            |b, d| {
                b.iter(|| to_vec(d).unwrap());
            },
        );
        group.bench_with_input(
            BenchmarkId::new("speedy", benchmark_param_display),
            obj,
            |b, d| {
                b.iter(|| d.write_to_vec(Endianness::LittleEndian).unwrap());
            },
        );
    }
    group.finish();
}

fn de_obj<T>(group_name: &str, num_samples: usize, c: &mut Criterion)
where
    for<'a> T: Generate
        + BorshSerialize
        + BorshDeserialize
        + SerdeSerialize
        + SerdeDeserialize<'a>
        + Readable<'a, speedy::Endianness>
        + Writable<speedy::Endianness>
        + 'static,
{
    let mut rng = rand_xorshift::XorShiftRng::from_seed([0u8; 16]);
    let mut group = c.benchmark_group(group_name);

    let objects: Vec<_> = (0..num_samples).map(|_| T::generate(&mut rng)).collect();
    let cbor_datas: Vec<Vec<u8>> = objects
        .iter()
        .map(|t| serde_cbor::to_vec(t).unwrap())
        .collect();
    let bincode_datas: Vec<Vec<u8>> = objects
        .iter()
        .map(|t| bincode::serialize(t).unwrap())
        .collect();
    let borsh_datas: Vec<Vec<u8>> = objects.iter().map(|t| to_vec(t).unwrap()).collect();
    let speedy_datas: Vec<Vec<u8>> = objects
        .iter()
        .map(|t| t.write_to_vec(Endianness::LittleEndian).unwrap())
        .collect();

    let borsh_sizes: Vec<_> = borsh_datas.iter().map(|d| d.len()).collect();

    for i in 0..objects.len() {
        let size = borsh_sizes[i];
        let cbor_data = &cbor_datas[i];
        let bincode_data = &bincode_datas[i];
        let borsh_data = &borsh_datas[i];
        let speedy_data = &speedy_datas[i];

        let benchmark_param_display = format!("idx={}; size={}", i, size);

        group.throughput(Throughput::Bytes(size as u64));
        group.bench_with_input(
            BenchmarkId::new("cbor", benchmark_param_display.clone()),
            cbor_data,
            |b, d| {
                b.iter(|| serde_cbor::from_slice::<T>(d).unwrap());
            },
        );
        group.bench_with_input(
            BenchmarkId::new("bincode", benchmark_param_display.clone()),
            bincode_data,
            |b, d| {
                b.iter(|| bincode::deserialize::<T>(d).unwrap());
            },
        );
        group.bench_with_input(
            BenchmarkId::new("borsh", benchmark_param_display.clone()),
            borsh_data,
            |b, d| {
                b.iter(|| from_slice::<T>(d).unwrap());
            },
        );
        group.bench_with_input(
            BenchmarkId::new("speedy", benchmark_param_display),
            speedy_data,
            |b, d| {
                b.iter(|| T::read_from_buffer(Endianness::LittleEndian, d).unwrap());
            },
        );
    }
    group.finish();
}

fn ser_account(c: &mut Criterion) {
    ser_obj::<Account>("ser_account", 10, c);
}

fn ser_transaction(c: &mut Criterion) {
    ser_obj::<SignedTransaction>("ser_transaction", 10, c);
}

fn ser_header(c: &mut Criterion) {
    ser_obj::<BlockHeader>("ser_header", 10, c);
}

fn ser_block(c: &mut Criterion) {
    ser_obj::<Block>("ser_block", 10, c);
}

fn de_account(c: &mut Criterion) {
    de_obj::<Account>("de_account", 10, c);
}

fn de_transaction(c: &mut Criterion) {
    de_obj::<SignedTransaction>("de_transaction", 10, c);
}

fn de_header(c: &mut Criterion) {
    de_obj::<BlockHeader>("de_header", 10, c);
}

fn de_block(c: &mut Criterion) {
    de_obj::<Block>("de_block", 10, c);
}

criterion_group!(
    ser_benches,
    ser_account,
    ser_transaction,
    ser_header,
    ser_block
);
criterion_group!(de_benches, de_account, de_transaction, de_header, de_block);
criterion_main!(ser_benches, de_benches);

'''
'''--- benchmarks/benches/maps_sets_inner_de.rs ---
use std::{
    any::type_name,
    collections::{BTreeMap, BTreeSet, HashMap, HashSet},
    iter::FromIterator,
};

use benchmarks::{Generate, PublicKey};
use borsh::{from_slice, to_vec, BorshDeserialize, BorshSerialize};
use criterion::{criterion_group, criterion_main, BenchmarkId, Criterion};
use rand::SeedableRng;

fn de_obj<T, U>(num_samples: usize, c: &mut Criterion)
where
    T: Generate + BorshDeserialize + BorshSerialize + 'static,
    U: FromIterator<T> + BorshDeserialize + BorshSerialize,
{
    let mut rng = rand_xorshift::XorShiftRng::from_seed([0u8; 16]);

    let group_name = format!("{}_{}", type_name::<U>(), num_samples);
    let mut group = c.benchmark_group(group_name);

    let collection: U = (0..num_samples).map(|_| T::generate(&mut rng)).collect();

    let serialized: Vec<u8> = to_vec(&collection).unwrap();

    group.bench_with_input(BenchmarkId::new("borsh_de", ""), &serialized, |b, d| {
        b.iter(|| from_slice::<U>(d).unwrap());
    });
}
fn de_string_hashmap_10(c: &mut Criterion) {
    de_obj::<(String, String), HashMap<String, String>>(10, c);
}
fn de_string_hashmap_1000(c: &mut Criterion) {
    de_obj::<(String, String), HashMap<String, String>>(1000, c);
}

fn de_string_hashmap_10000(c: &mut Criterion) {
    de_obj::<(String, String), HashMap<String, String>>(10_000, c);
}

fn de_string_btreemap_10(c: &mut Criterion) {
    de_obj::<(String, String), BTreeMap<String, String>>(10, c);
}
fn de_string_btreemap_1000(c: &mut Criterion) {
    de_obj::<(String, String), BTreeMap<String, String>>(1000, c);
}

fn de_string_btreemap_10000(c: &mut Criterion) {
    de_obj::<(String, String), BTreeMap<String, String>>(10_000, c);
}

fn de_string_hashset_10(c: &mut Criterion) {
    de_obj::<String, HashSet<String>>(10, c);
}
fn de_string_hashset_1000(c: &mut Criterion) {
    de_obj::<String, HashSet<String>>(1000, c);
}

fn de_string_hashset_10000(c: &mut Criterion) {
    de_obj::<String, HashSet<String>>(10_000, c);
}

fn de_string_btreeset_10(c: &mut Criterion) {
    de_obj::<String, BTreeSet<String>>(10, c);
}
fn de_string_btreeset_1000(c: &mut Criterion) {
    de_obj::<String, BTreeSet<String>>(1000, c);
}

fn de_string_btreeset_10000(c: &mut Criterion) {
    de_obj::<String, BTreeSet<String>>(10_000, c);
}

criterion_group!(
    de_string_map,
    de_string_hashmap_10,
    de_string_hashmap_1000,
    de_string_hashmap_10000,
    de_string_btreemap_10,
    de_string_btreemap_1000,
    de_string_btreemap_10000,
);

criterion_group!(
    de_string_set,
    de_string_hashset_10,
    de_string_hashset_1000,
    de_string_hashset_10000,
    de_string_btreeset_10,
    de_string_btreeset_1000,
    de_string_btreeset_10000,
);
fn de_pubkey_hashmap_10(c: &mut Criterion) {
    de_obj::<(PublicKey, PublicKey), HashMap<PublicKey, PublicKey>>(10, c);
}
fn de_pubkey_hashmap_1000(c: &mut Criterion) {
    de_obj::<(PublicKey, PublicKey), HashMap<PublicKey, PublicKey>>(1000, c);
}

fn de_pubkey_hashmap_10000(c: &mut Criterion) {
    de_obj::<(PublicKey, PublicKey), HashMap<PublicKey, PublicKey>>(10_000, c);
}

fn de_pubkey_btreemap_10(c: &mut Criterion) {
    de_obj::<(PublicKey, PublicKey), BTreeMap<PublicKey, PublicKey>>(10, c);
}
fn de_pubkey_btreemap_1000(c: &mut Criterion) {
    de_obj::<(PublicKey, PublicKey), BTreeMap<PublicKey, PublicKey>>(1000, c);
}

fn de_pubkey_btreemap_10000(c: &mut Criterion) {
    de_obj::<(PublicKey, PublicKey), BTreeMap<PublicKey, PublicKey>>(10_000, c);
}

fn de_pubkey_hashset_10(c: &mut Criterion) {
    de_obj::<PublicKey, HashSet<PublicKey>>(10, c);
}
fn de_pubkey_hashset_1000(c: &mut Criterion) {
    de_obj::<PublicKey, HashSet<PublicKey>>(1000, c);
}

fn de_pubkey_hashset_10000(c: &mut Criterion) {
    de_obj::<PublicKey, HashSet<PublicKey>>(10_000, c);
}

fn de_pubkey_btreeset_10(c: &mut Criterion) {
    de_obj::<PublicKey, BTreeSet<PublicKey>>(10, c);
}
fn de_pubkey_btreeset_1000(c: &mut Criterion) {
    de_obj::<PublicKey, BTreeSet<PublicKey>>(1000, c);
}

fn de_pubkey_btreeset_10000(c: &mut Criterion) {
    de_obj::<PublicKey, BTreeSet<PublicKey>>(10_000, c);
}

criterion_group!(
    de_pubkey_map,
    de_pubkey_hashmap_10,
    de_pubkey_hashmap_1000,
    de_pubkey_hashmap_10000,
    de_pubkey_btreemap_10,
    de_pubkey_btreemap_1000,
    de_pubkey_btreemap_10000,
);

criterion_group!(
    de_pubkey_set,
    de_pubkey_hashset_10,
    de_pubkey_hashset_1000,
    de_pubkey_hashset_10000,
    de_pubkey_btreeset_10,
    de_pubkey_btreeset_1000,
    de_pubkey_btreeset_10000,
);

criterion_main!(de_string_map, de_string_set, de_pubkey_map, de_pubkey_set);

'''
'''--- benchmarks/benches/maps_sets_inner_ser.rs ---
use std::{
    any::type_name,
    collections::{BTreeMap, BTreeSet, HashMap, HashSet},
    iter::FromIterator,
};

use borsh::{to_vec, BorshSerialize};

use benchmarks::Generate;
use criterion::{criterion_group, criterion_main, BenchmarkId, Criterion};
use rand::SeedableRng;

fn ser_obj<T, U>(num_samples: usize, c: &mut Criterion)
where
    T: Generate + BorshSerialize + 'static,
    U: FromIterator<T> + BorshSerialize,
{
    let mut rng = rand_xorshift::XorShiftRng::from_seed([0u8; 16]);

    let group_name = format!("{}_{}", type_name::<U>(), num_samples);
    let mut group = c.benchmark_group(group_name);

    let collection: U = (0..num_samples).map(|_| T::generate(&mut rng)).collect();

    group.bench_with_input(BenchmarkId::new("borsh_ser", ""), &collection, |b, d| {
        b.iter(|| to_vec(d).unwrap());
    });
}

fn ser_string_hashmap_10(c: &mut Criterion) {
    ser_obj::<(String, String), HashMap<String, String>>(10, c);
}
fn ser_string_hashmap_1000(c: &mut Criterion) {
    ser_obj::<(String, String), HashMap<String, String>>(1000, c);
}

fn ser_string_hashmap_10000(c: &mut Criterion) {
    ser_obj::<(String, String), HashMap<String, String>>(10_000, c);
}

fn ser_string_btreemap_10(c: &mut Criterion) {
    ser_obj::<(String, String), BTreeMap<String, String>>(10, c);
}
fn ser_string_btreemap_1000(c: &mut Criterion) {
    ser_obj::<(String, String), BTreeMap<String, String>>(1000, c);
}

fn ser_string_btreemap_10000(c: &mut Criterion) {
    ser_obj::<(String, String), BTreeMap<String, String>>(10_000, c);
}

fn ser_string_hashset_10(c: &mut Criterion) {
    ser_obj::<String, HashSet<String>>(10, c);
}
fn ser_string_hashset_1000(c: &mut Criterion) {
    ser_obj::<String, HashSet<String>>(1000, c);
}

fn ser_string_hashset_10000(c: &mut Criterion) {
    ser_obj::<String, HashSet<String>>(10_000, c);
}

fn ser_string_btreeset_10(c: &mut Criterion) {
    ser_obj::<String, BTreeSet<String>>(10, c);
}
fn ser_string_btreeset_1000(c: &mut Criterion) {
    ser_obj::<String, BTreeSet<String>>(1000, c);
}

fn ser_string_btreeset_10000(c: &mut Criterion) {
    ser_obj::<String, BTreeSet<String>>(10_000, c);
}

criterion_group!(
    ser_string_map,
    ser_string_hashmap_10,
    ser_string_hashmap_1000,
    ser_string_hashmap_10000,
    ser_string_btreemap_10,
    ser_string_btreemap_1000,
    ser_string_btreemap_10000,
);

criterion_group!(
    ser_string_set,
    ser_string_hashset_10,
    ser_string_hashset_1000,
    ser_string_hashset_10000,
    ser_string_btreeset_10,
    ser_string_btreeset_1000,
    ser_string_btreeset_10000,
);

criterion_main!(ser_string_map, ser_string_set);

'''
'''--- benchmarks/benches/object_length.rs ---
use benchmarks::{Generate, ValidatorStake};
use borsh::{to_vec, BorshSerialize};
use criterion::{criterion_group, criterion_main, BenchmarkId, Criterion, Throughput};
use rand::SeedableRng;

fn ser_obj_length<T>(group_name: &str, num_samples: usize, c: &mut Criterion)
where
    for<'a> T: Generate + BorshSerialize + 'static,
{
    let mut rng = rand_xorshift::XorShiftRng::from_seed([0u8; 16]);
    let mut group = c.benchmark_group(group_name);

    let objects: Vec<_> = (0..num_samples).map(|_| T::generate(&mut rng)).collect();
    let borsh_datas: Vec<Vec<u8>> = objects.iter().map(|t| to_vec(t).unwrap()).collect();
    let borsh_sizes: Vec<_> = borsh_datas.iter().map(|d| d.len()).collect();

    for i in 0..objects.len() {
        let size = borsh_sizes[i];
        let obj = &objects[i];
        assert_eq!(
            borsh::to_vec(obj).unwrap().len(),
            borsh::object_length(obj).unwrap()
        );

        let benchmark_param_display = format!("idx={}; size={}", i, size);

        group.throughput(Throughput::Bytes(size as u64));
        group.bench_with_input(
            BenchmarkId::new(
                "borsh::to_vec(obj).unwrap().len()",
                benchmark_param_display.clone(),
            ),
            obj,
            |b, d| {
                b.iter(|| borsh::to_vec(d).unwrap().len());
            },
        );
        group.bench_with_input(
            BenchmarkId::new(
                "borsh::object_length(obj).unwrap()",
                benchmark_param_display.clone(),
            ),
            obj,
            |b, d| {
                b.iter(|| borsh::object_length(d).unwrap());
            },
        );
    }
    group.finish();
}
fn ser_length_validator_stake(c: &mut Criterion) {
    ser_obj_length::<ValidatorStake>("ser_account", 3, c);
}
criterion_group!(ser_length, ser_length_validator_stake,);
criterion_main!(ser_length);

'''
'''--- benchmarks/src/lib.rs ---
//! This library contains data structures used for benchmarking.

use borsh::{BorshDeserialize, BorshSerialize};
use rand::distributions::{Alphanumeric, Distribution, Standard};
use rand::Rng;
use serde::{Deserialize as SerdeDeserialize, Serialize as SerdeSerialize};
extern crate speedy_derive;
use speedy::{Context, Readable, Reader, Writable, Writer};

pub trait Generate {
    fn generate<R: rand::Rng>(rng: &mut R) -> Self;
}

#[derive(
    BorshSerialize, BorshDeserialize, Debug, Clone, Eq, PartialEq, SerdeSerialize, SerdeDeserialize,
)]
pub struct CryptoHash([u8; 32]);
impl Generate for CryptoHash {
    fn generate<R: rand::Rng>(rng: &mut R) -> Self {
        let mut res = [0u8; 32];
        rng.fill_bytes(&mut res);
        CryptoHash(res)
    }
}

impl<'a, C> Readable<'a, C> for CryptoHash
where
    C: Context,
{
    fn read_from<R: Reader<'a, C>>(reader: &mut R) -> std::result::Result<Self, std::io::Error> {
        let mut data = [0u8; 32];
        reader.read_bytes(&mut data)?;
        Ok(Self(data))
    }
}

impl<C: Context> Writable<C> for CryptoHash {
    fn write_to<'a, T: ?Sized + Writer<'a, C>>(
        &'a self,
        writer: &mut T,
    ) -> std::result::Result<(), std::io::Error> {
        writer.write_bytes(&self.0).map(|_| ())
    }
}

#[derive(
    BorshSerialize, BorshDeserialize, Debug, Clone, Eq, PartialEq, SerdeSerialize, SerdeDeserialize,
)]
pub struct MerkleHash([u8; 32]);
impl Generate for MerkleHash {
    fn generate<R: rand::Rng>(rng: &mut R) -> Self {
        let mut res = [0u8; 32];
        rng.fill_bytes(&mut res);
        MerkleHash(res)
    }
}

impl<'a, C> Readable<'a, C> for MerkleHash
where
    C: Context,
{
    fn read_from<R: Reader<'a, C>>(reader: &mut R) -> std::result::Result<Self, std::io::Error> {
        let mut data = [0u8; 32];
        reader.read_bytes(&mut data)?;
        Ok(Self(data))
    }
}

impl<C: Context> Writable<C> for MerkleHash {
    fn write_to<'a, T: ?Sized + Writer<'a, C>>(
        &'a self,
        writer: &mut T,
    ) -> std::result::Result<(), std::io::Error> {
        writer.write_bytes(&self.0).map(|_| ())
    }
}

#[derive(
    BorshSerialize, BorshDeserialize, Debug, Clone, Eq, PartialEq, SerdeSerialize, SerdeDeserialize,
)]
pub struct Signature([u8; 32]);
impl Generate for Signature {
    fn generate<R: rand::Rng>(rng: &mut R) -> Self {
        let mut res = [0u8; 32];
        rng.fill_bytes(&mut res);
        Signature(res)
    }
}

impl<'a, C> Readable<'a, C> for Signature
where
    C: Context,
{
    fn read_from<R: Reader<'a, C>>(reader: &mut R) -> std::result::Result<Self, std::io::Error> {
        let mut data = [0u8; 32];
        reader.read_bytes(&mut data)?;
        Ok(Self(data))
    }
}

impl<C: Context> Writable<C> for Signature {
    fn write_to<'a, T: ?Sized + Writer<'a, C>>(
        &'a self,
        writer: &mut T,
    ) -> std::result::Result<(), std::io::Error> {
        writer.write_bytes(&self.0).map(|_| ())
    }
}

#[derive(
    BorshSerialize,
    BorshDeserialize,
    Debug,
    Clone,
    Eq,
    PartialEq,
    SerdeSerialize,
    SerdeDeserialize,
    PartialOrd,
    Ord,
    Hash,
)]
pub struct PublicKey([u8; 32]);
impl Generate for PublicKey {
    fn generate<R: rand::Rng>(rng: &mut R) -> Self {
        let mut res = [0u8; 32];
        rng.fill_bytes(&mut res);
        PublicKey(res)
    }
}

impl Generate for (PublicKey, PublicKey) {
    fn generate<R: rand::Rng>(rng: &mut R) -> Self {
        (PublicKey::generate(rng), PublicKey::generate(rng))
    }
}

impl<'a, C> Readable<'a, C> for PublicKey
where
    C: Context,
{
    fn read_from<R: Reader<'a, C>>(reader: &mut R) -> std::result::Result<Self, std::io::Error> {
        let mut data = [0u8; 32];
        reader.read_bytes(&mut data)?;
        Ok(Self(data))
    }
}

impl<C: Context> Writable<C> for PublicKey {
    fn write_to<'a, T: ?Sized + Writer<'a, C>>(
        &'a self,
        writer: &mut T,
    ) -> std::result::Result<(), std::io::Error> {
        writer.write_bytes(&self.0).map(|_| ())
    }
}

#[derive(
    BorshSerialize,
    BorshDeserialize,
    Debug,
    Clone,
    Eq,
    PartialEq,
    SerdeSerialize,
    SerdeDeserialize,
    Readable,
    Writable,
)]
pub struct AccountId(String);
impl Generate for String {
    fn generate<R: rand::Rng>(rng: &mut R) -> Self {
        let len: usize = rng.gen_range(5, 200);
        rng.sample_iter(&Alphanumeric).take(len).collect::<String>()
    }
}

impl Generate for (String, String) {
    fn generate<R: rand::Rng>(rng: &mut R) -> Self {
        (String::generate(rng), String::generate(rng))
    }
}

impl Generate for AccountId {
    fn generate<R: rand::Rng>(rng: &mut R) -> Self {
        AccountId(String::generate(rng))
    }
}

pub type Balance = u64;

#[derive(
    BorshSerialize,
    BorshDeserialize,
    Debug,
    Clone,
    Eq,
    PartialEq,
    SerdeSerialize,
    SerdeDeserialize,
    Readable,
    Writable,
)]
pub struct ValidatorStake {
    pub account_id: AccountId,
    pub public_key: PublicKey,
    pub amount: Balance,
}

impl Generate for ValidatorStake {
    fn generate<R: rand::Rng>(rng: &mut R) -> Self {
        Self {
            account_id: AccountId::generate(rng),
            public_key: PublicKey::generate(rng),
            amount: u64::generate(rng),
        }
    }
}

pub type BlockIndex = u64;
pub type Weight = u64;

pub fn generate_vec_primitives<T, R>(rng: &mut R, min_number: usize, max_number: usize) -> Vec<T>
where
    Standard: Distribution<T>,
    R: rand::Rng,
{
    let num: usize = rng.gen_range(min_number, max_number + 1);
    let mut res = vec![];
    for _ in 0..num {
        res.push(rng.gen());
    }
    res
}

pub fn generate_vec<T: Generate, R: rand::Rng>(
    rng: &mut R,
    min_number: usize,
    max_number: usize,
) -> Vec<T> {
    let num: usize = rng.gen_range(min_number, max_number + 1);
    let mut res = vec![];
    for _ in 0..num {
        res.push(T::generate(rng));
    }
    res
}

#[derive(
    BorshSerialize,
    BorshDeserialize,
    Debug,
    Clone,
    Eq,
    PartialEq,
    SerdeSerialize,
    SerdeDeserialize,
    Readable,
    Writable,
)]
pub struct BlockHeaderInner {
    pub height: BlockIndex,
    pub epoch_hash: CryptoHash,
    pub prev_hash: CryptoHash,
    pub prev_state_root: MerkleHash,
    pub tx_root: MerkleHash,
    pub timestamp: u64,
    pub approval_mask: Vec<bool>,
    pub approval_sigs: Vec<Signature>,
    pub total_weight: Weight,
    pub validator_proposals: Vec<ValidatorStake>,
}

impl Generate for BlockHeaderInner {
    fn generate<R: rand::Rng>(rng: &mut R) -> Self {
        Self {
            height: u64::generate(rng),
            epoch_hash: CryptoHash::generate(rng),
            prev_hash: CryptoHash::generate(rng),
            prev_state_root: MerkleHash::generate(rng),
            tx_root: MerkleHash::generate(rng),
            timestamp: u64::generate(rng),
            approval_mask: generate_vec_primitives(rng, 2, 1000),
            approval_sigs: generate_vec(rng, 2, 1000),
            total_weight: u64::generate(rng),
            validator_proposals: generate_vec(rng, 2, 1000),
        }
    }
}

#[derive(
    BorshSerialize,
    BorshDeserialize,
    Debug,
    Clone,
    Eq,
    PartialEq,
    SerdeSerialize,
    SerdeDeserialize,
    Readable,
    Writable,
)]
pub struct BlockHeader {
    pub inner: BlockHeaderInner,
    pub signature: Signature,
    pub hash: CryptoHash,
}

impl Generate for BlockHeader {
    fn generate<R: rand::Rng>(rng: &mut R) -> Self {
        Self {
            inner: BlockHeaderInner::generate(rng),
            signature: Signature::generate(rng),
            hash: CryptoHash::generate(rng),
        }
    }
}

#[derive(
    BorshSerialize,
    BorshDeserialize,
    Debug,
    Clone,
    Eq,
    PartialEq,
    SerdeSerialize,
    SerdeDeserialize,
    Readable,
    Writable,
)]
pub struct Block {
    pub header: BlockHeader,
    pub transactions: Vec<SignedTransaction>,
}

impl Generate for Block {
    fn generate<R: rand::Rng>(rng: &mut R) -> Self {
        Self {
            header: BlockHeader::generate(rng),
            transactions: generate_vec(rng, 0, 1000),
        }
    }
}

#[derive(
    BorshSerialize,
    BorshDeserialize,
    Debug,
    Clone,
    Eq,
    PartialEq,
    SerdeSerialize,
    SerdeDeserialize,
    Readable,
    Writable,
)]
pub struct SignedTransaction {
    transaction: Transaction,
    signature: Signature,
    hash: CryptoHash,
}

impl Generate for SignedTransaction {
    fn generate<R: rand::Rng>(rng: &mut R) -> Self {
        Self {
            transaction: Transaction::generate(rng),
            signature: Signature::generate(rng),
            hash: CryptoHash::generate(rng),
        }
    }
}

pub type Nonce = u64;

#[derive(
    BorshSerialize,
    BorshDeserialize,
    Debug,
    Clone,
    Eq,
    PartialEq,
    SerdeSerialize,
    SerdeDeserialize,
    Readable,
    Writable,
)]
pub struct Transaction {
    signer_id: AccountId,
    public_key: PublicKey,
    nonce: Nonce,
    receiver_id: AccountId,
    actions: Vec<Action>,
}

impl Generate for Transaction {
    fn generate<R: rand::Rng>(rng: &mut R) -> Self {
        Self {
            signer_id: AccountId::generate(rng),
            public_key: PublicKey::generate(rng),
            nonce: u64::generate(rng),
            receiver_id: AccountId::generate(rng),
            actions: generate_vec(rng, 1, 10),
        }
    }
}

#[derive(
    BorshSerialize,
    BorshDeserialize,
    Debug,
    Clone,
    Eq,
    PartialEq,
    SerdeSerialize,
    SerdeDeserialize,
    Readable,
    Writable,
)]
pub enum Action {
    CreateAccount(CreateAccountAction),
    DeployContract(DeployContractAction),
    FunctionCall(FunctionCallAction),
    Transfer(TransferAction),
    Stake(StakeAction),
    AddKey(AddKeyAction),
    DeleteKey(DeleteKeyAction),
    DeleteAccount(DeleteAccountAction),
}

impl Generate for Action {
    fn generate<R: rand::Rng>(rng: &mut R) -> Self {
        use Action::*;
        // Deploy contract action is 1000 times less frequent than other actions.
        if u64::generate(rng) % 1000 == 0 {
            DeployContract(DeployContractAction::generate(rng))
        } else {
            match u64::generate(rng) % 7 {
                0 => CreateAccount(CreateAccountAction::generate(rng)),
                1 => FunctionCall(FunctionCallAction::generate(rng)),
                2 => Transfer(TransferAction::generate(rng)),
                3 => Stake(StakeAction::generate(rng)),
                4 => AddKey(AddKeyAction::generate(rng)),
                5 => DeleteKey(DeleteKeyAction::generate(rng)),
                6 => DeleteAccount(DeleteAccountAction::generate(rng)),
                _ => unimplemented!(),
            }
        }
    }
}

#[derive(
    BorshSerialize,
    BorshDeserialize,
    Debug,
    Clone,
    Eq,
    PartialEq,
    SerdeSerialize,
    SerdeDeserialize,
    Readable,
    Writable,
)]
pub struct CreateAccountAction {}
impl Generate for CreateAccountAction {
    fn generate<R: rand::Rng>(_rng: &mut R) -> Self {
        Self {}
    }
}

#[derive(
    BorshSerialize,
    BorshDeserialize,
    Debug,
    Clone,
    Eq,
    PartialEq,
    SerdeSerialize,
    SerdeDeserialize,
    Readable,
    Writable,
)]
pub struct DeployContractAction {
    code: Vec<u8>,
}

pub fn generate_vec_u8<R: rand::Rng>(rng: &mut R, min_number: usize, max_number: usize) -> Vec<u8> {
    let num: usize = rng.gen_range(min_number, max_number + 1);
    let mut res = vec![0u8; num];
    rng.fill_bytes(&mut res);
    res
}

impl Generate for DeployContractAction {
    fn generate<R: rand::Rng>(rng: &mut R) -> Self {
        Self {
            // Between 20KiB and 1MiB.
            code: generate_vec_u8(rng, 20 * 2usize.pow(10), 2usize.pow(20)),
        }
    }
}

pub type Gas = u64;

#[derive(
    BorshSerialize,
    BorshDeserialize,
    Debug,
    Clone,
    Eq,
    PartialEq,
    SerdeSerialize,
    SerdeDeserialize,
    Readable,
    Writable,
)]
pub struct FunctionCallAction {
    method_name: String,
    args: Vec<u8>,
    gas: Gas,
    deposit: Balance,
}

impl Generate for FunctionCallAction {
    fn generate<R: rand::Rng>(rng: &mut R) -> Self {
        Self {
            method_name: String::generate(rng),
            args: generate_vec_u8(rng, 0, 1000),
            gas: u64::generate(rng),
            deposit: u64::generate(rng),
        }
    }
}
#[derive(
    BorshSerialize,
    BorshDeserialize,
    Debug,
    Clone,
    Eq,
    PartialEq,
    SerdeSerialize,
    SerdeDeserialize,
    Readable,
    Writable,
)]
pub struct TransferAction {
    deposit: Balance,
}
impl Generate for TransferAction {
    fn generate<R: rand::Rng>(rng: &mut R) -> Self {
        Self {
            deposit: u64::generate(rng),
        }
    }
}

#[derive(
    BorshSerialize,
    BorshDeserialize,
    Debug,
    Clone,
    Eq,
    PartialEq,
    SerdeSerialize,
    SerdeDeserialize,
    Readable,
    Writable,
)]
pub struct StakeAction {
    stake: Balance,
    public_key: PublicKey,
}

impl Generate for StakeAction {
    fn generate<R: rand::Rng>(rng: &mut R) -> Self {
        Self {
            stake: u64::generate(rng),
            public_key: PublicKey::generate(rng),
        }
    }
}

#[derive(
    BorshSerialize,
    BorshDeserialize,
    Debug,
    Clone,
    Eq,
    PartialEq,
    SerdeSerialize,
    SerdeDeserialize,
    Readable,
    Writable,
)]
pub struct AddKeyAction {
    public_key: PublicKey,
    access_key: AccessKey,
}

impl Generate for AddKeyAction {
    fn generate<R: rand::Rng>(rng: &mut R) -> Self {
        Self {
            public_key: PublicKey::generate(rng),
            access_key: AccessKey::generate(rng),
        }
    }
}

#[derive(
    BorshSerialize,
    BorshDeserialize,
    Debug,
    Clone,
    Eq,
    PartialEq,
    SerdeSerialize,
    SerdeDeserialize,
    Readable,
    Writable,
)]
pub struct DeleteKeyAction {
    public_key: PublicKey,
}

impl Generate for DeleteKeyAction {
    fn generate<R: rand::Rng>(rng: &mut R) -> Self {
        Self {
            public_key: PublicKey::generate(rng),
        }
    }
}

#[derive(
    BorshSerialize,
    BorshDeserialize,
    Debug,
    Clone,
    Eq,
    PartialEq,
    SerdeSerialize,
    SerdeDeserialize,
    Readable,
    Writable,
)]
pub struct DeleteAccountAction {
    beneficiary_id: AccountId,
}

impl Generate for DeleteAccountAction {
    fn generate<R: rand::Rng>(rng: &mut R) -> Self {
        Self {
            beneficiary_id: AccountId::generate(rng),
        }
    }
}

#[derive(
    BorshSerialize,
    BorshDeserialize,
    Debug,
    Clone,
    Eq,
    PartialEq,
    SerdeSerialize,
    SerdeDeserialize,
    Readable,
    Writable,
)]
pub struct AccessKey {
    nonce: Nonce,
    permission: AccessKeyPermission,
}

impl Generate for AccessKey {
    fn generate<R: rand::Rng>(rng: &mut R) -> Self {
        Self {
            nonce: u64::generate(rng),
            permission: AccessKeyPermission::generate(rng),
        }
    }
}

#[derive(
    BorshSerialize,
    BorshDeserialize,
    Debug,
    Clone,
    Eq,
    PartialEq,
    SerdeSerialize,
    SerdeDeserialize,
    Readable,
    Writable,
)]
pub enum AccessKeyPermission {
    FunctionCall(FunctionCallPermission),
    FullAccess,
}

impl Generate for AccessKeyPermission {
    fn generate<R: rand::Rng>(rng: &mut R) -> Self {
        if u64::generate(rng) % 2 == 0 {
            AccessKeyPermission::FunctionCall(FunctionCallPermission::generate(rng))
        } else {
            AccessKeyPermission::FullAccess
        }
    }
}

#[derive(
    BorshSerialize,
    BorshDeserialize,
    Debug,
    Clone,
    Eq,
    PartialEq,
    SerdeSerialize,
    SerdeDeserialize,
    Readable,
    Writable,
)]
pub struct FunctionCallPermission {
    allowance: Option<Balance>,
    receiver_id: AccountId,
    method_names: Vec<String>,
}

fn generate_option<T: Generate, R: rand::Rng>(rng: &mut R) -> Option<T> {
    if u64::generate(rng) % 2 == 0 {
        None
    } else {
        Some(T::generate(rng))
    }
}

impl Generate for u64 {
    fn generate<R: rand::Rng>(rng: &mut R) -> Self {
        rng.next_u64()
    }
}

impl Generate for FunctionCallPermission {
    fn generate<R: rand::Rng>(rng: &mut R) -> Self {
        Self {
            allowance: generate_option(rng),
            receiver_id: AccountId::generate(rng),
            method_names: generate_vec(rng, 0, 10),
        }
    }
}

#[derive(
    BorshSerialize,
    BorshDeserialize,
    Debug,
    Clone,
    Eq,
    PartialEq,
    SerdeSerialize,
    SerdeDeserialize,
    Readable,
    Writable,
)]
pub struct Account {
    pub amount: Balance,
    pub staked: Balance,
    pub code_hash: CryptoHash,
    pub storage_usage: u64,
    pub storage_paid_at: u64,
}

impl Generate for Account {
    fn generate<R: rand::Rng>(rng: &mut R) -> Self {
        Self {
            amount: u64::generate(rng),
            staked: u64::generate(rng),
            code_hash: CryptoHash::generate(rng),
            storage_usage: u64::generate(rng),
            storage_paid_at: u64::generate(rng),
        }
    }
}

'''
'''--- borsh-derive/Cargo.toml ---
[package]
name = "borsh-derive"
version.workspace = true
rust-version.workspace = true
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2018"
license = "Apache-2.0"
readme = "README.md"
categories = ["encoding", "network-programming"]
repository = "https://github.com/near/borsh-rs"
homepage = "https://borsh.io"
description = """
Binary Object Representation Serializer for Hashing
"""
exclude = ["*.snap"]

[lib]
proc-macro = true

[dependencies]
syn = { version = "2", features = ["full", "fold"] }
proc-macro-crate = "3"
proc-macro2 = "1"
quote = "1"
once_cell = "1.18.0"
syn_derive = "0.1.6"

[dev-dependencies]
syn = { version = "2", features = ["full", "fold", "parsing"] }
prettyplease = "0.2.9"
insta = "1.29.0"

[package.metadata.docs.rs]
features = ["schema"]
targets = ["x86_64-unknown-linux-gnu"]

[features]
default = []
schema = []
force_exhaustive_checks = []

'''
'''--- borsh-derive/README.md ---
# Borsh in Rust &emsp; [![Latest Version]][crates.io] [![borsh: rustc 1.67+]][Rust 1.67] [![License Apache-2.0 badge]][License Apache-2.0] [![License MIT badge]][License MIT]

[Borsh]: https://borsh.io
[Latest Version]: https://img.shields.io/crates/v/borsh.svg
[crates.io]: https://crates.io/crates/borsh
[borsh: rustc 1.67+]: https://img.shields.io/badge/rustc-1.67+-lightgray.svg
[Rust 1.67]: https://blog.rust-lang.org/2023/01/26/Rust-1.67.0.html
[License Apache-2.0 badge]: https://img.shields.io/badge/license-Apache2.0-blue.svg
[License Apache-2.0]: https://opensource.org/licenses/Apache-2.0
[License MIT badge]: https://img.shields.io/badge/license-MIT-blue.svg
[License MIT]: https://opensource.org/licenses/MIT

**borsh-rs** is Rust implementation of the [Borsh] binary serialization format.

Borsh stands for _Binary Object Representation Serializer for Hashing_. It is meant to be used in
security-critical projects as it prioritizes [consistency, safety, speed][Borsh], and comes with a
strict [specification](https://github.com/near/borsh#specification).

## Example

```rust
use borsh::{BorshSerialize, BorshDeserialize, from_slice, to_vec};

#[derive(BorshSerialize, BorshDeserialize, PartialEq, Debug)]
struct A {
    x: u64,
    y: String,
}

#[test]
fn test_simple_struct() {
    let a = A {
        x: 3301,
        y: "liber primus".to_string(),
    };
    let encoded_a = to_vec(&a).unwrap();
    let decoded_a = from_slice::<A>(&encoded_a).unwrap();
    assert_eq!(a, decoded_a);
}
```

## Features

Opting out from Serde allows borsh to have some features that currently are not available for serde-compatible serializers.
Currently we support two features: `borsh(init=<your initialization method name>` and `borsh(skip)` (the former one not available in Serde).

`borsh(init=...)` allows to automatically run an initialization function right after deserialization. This adds a lot of convenience for objects that are architectured to be used as strictly immutable. Usage example:

```rust
#[derive(BorshSerialize, BorshDeserialize)]
#[borsh(init=init)]
struct Message {
    message: String,
    timestamp: u64,
    public_key: CryptoKey,
    signature: CryptoSignature
    hash: CryptoHash
}

impl Message {
    pub fn init(&mut self) {
        self.hash = CryptoHash::new().write_string(self.message).write_u64(self.timestamp);
        self.signature.verify(self.hash, self.public_key);
    }
}
```

`borsh(skip)` allows to skip serializing/deserializing fields, assuming they implement `Default` trait, similarly to `#[serde(skip)]`.

```rust
#[derive(BorshSerialize, BorshDeserialize)]
struct A {
    x: u64,
    #[borsh(skip)]
    y: f32,
}
```

### Enum with explicit discriminant

`#[borsh(use_discriminant=false|true])` is required if you have an enum with explicit discriminant. This setting affects `BorshSerialize` and `BorshDeserialize` behaviour at the same time.

In the future, borsh will drop the requirement to explicitly use `#[borsh(use_discriminant=false|true)]`, and will default to `true`, but to make sure that the transition from the older versions of borsh (before 0.11 release) does not cause silent breaking changes in de-/serialization, borsh 1.0 will require to specify if the explicit enum discriminant should be used as a de-/serialization tag value.

If you don't specify `use_discriminant` option for enum with explicit discriminant, you will get an error:

```bash
error: You have to specify `#[borsh(use_discriminant=true)]` or `#[borsh(use_discriminant=false)]` for all enums with explicit discriminant
```

In order to preserve the behaviour of borsh versions before 0.11, which did not respect explicit enum discriminants for de-/serialization, use `#[borsh(use_discriminant=false)]`, otherwise, use `true`:

```rust
#[derive(BorshDeserialize, BorshSerialize)]
#[borsh(use_discriminant=false)]
enum A {
    X,
    Y = 10,
}
```

## Testing

Integration tests should generally be preferred to unit ones. Root module of integration tests of `borsh` crate is [linked](./borsh/tests/tests.rs) here.
 
## Releasing

The versions of all public crates in this repository are collectively managed by a single version in the [workspace manifest](https://github.com/near/borsh-rs/blob/master/Cargo.toml).

So, to publish a new version of all the crates, you can do so by simply bumping that to the next "patch" version and submit a PR.

We have CI Infrastructure put in place to automate the process of publishing all crates once a version change has merged into master.

However, before you release, make sure the [CHANGELOG](CHANGELOG.md) is up to date and that the `[Unreleased]` section is present but empty.

## License

This repository is distributed under the terms of both the MIT license and the Apache License (Version 2.0).
See [LICENSE-MIT](LICENSE-MIT) and [LICENSE-APACHE](LICENSE-APACHE) for details.

'''
'''--- borsh-derive/src/internals/attributes/field/bounds.rs ---
use std::collections::BTreeMap;

use syn::{meta::ParseNestedMeta, WherePredicate};

use crate::internals::attributes::{parsing::parse_lit_into_vec, Symbol, DESERIALIZE, SERIALIZE};
use once_cell::sync::Lazy;

pub enum Variants {
    Serialize(Vec<WherePredicate>),
    Deserialize(Vec<WherePredicate>),
}

type ParseFn = dyn Fn(Symbol, Symbol, &ParseNestedMeta) -> syn::Result<Variants> + Send + Sync;

pub static BOUNDS_FIELD_PARSE_MAP: Lazy<BTreeMap<Symbol, Box<ParseFn>>> = Lazy::new(|| {
    let mut m = BTreeMap::new();
    // assigning closure `let f = |args| {...};` and boxing closure `let f: Box<ParseFn> = Box::new(f);`
    // on 2 separate lines doesn't work
    let f_serialize: Box<ParseFn> = Box::new(|attr_name, meta_item_name, meta| {
        parse_lit_into_vec::<WherePredicate>(attr_name, meta_item_name, meta)
            .map(Variants::Serialize)
    });
    let f_deserialize: Box<ParseFn> = Box::new(|attr_name, meta_item_name, meta| {
        parse_lit_into_vec::<WherePredicate>(attr_name, meta_item_name, meta)
            .map(Variants::Deserialize)
    });
    m.insert(SERIALIZE, f_serialize);
    m.insert(DESERIALIZE, f_deserialize);
    m
});

#[derive(Default, Clone)]
pub struct Bounds {
    pub serialize: Option<Vec<WherePredicate>>,
    pub deserialize: Option<Vec<WherePredicate>>,
}

impl From<BTreeMap<Symbol, Variants>> for Bounds {
    fn from(mut map: BTreeMap<Symbol, Variants>) -> Self {
        let serialize = map.remove(&SERIALIZE);
        let deserialize = map.remove(&DESERIALIZE);
        let serialize = serialize.map(|variant| match variant {
            Variants::Serialize(ser) => ser,
            _ => unreachable!("only one enum variant is expected to correspond to given map key"),
        });
        let deserialize = deserialize.map(|variant| match variant {
            Variants::Deserialize(de) => de,
            _ => unreachable!("only one enum variant is expected to correspond to given map key"),
        });
        Self {
            serialize,
            deserialize,
        }
    }
}

'''
'''--- borsh-derive/src/internals/attributes/field/mod.rs ---
use std::collections::BTreeMap;

use once_cell::sync::Lazy;
use syn::{meta::ParseNestedMeta, Attribute, WherePredicate};

use self::bounds::BOUNDS_FIELD_PARSE_MAP;

use super::{
    get_one_attribute,
    parsing::{attr_get_by_symbol_keys, meta_get_by_symbol_keys, parse_lit_into},
    BoundType, Symbol, BORSH, BOUND, DESERIALIZE_WITH, SERIALIZE_WITH, SKIP,
};

#[cfg(feature = "schema")]
use {
    super::schema_keys::{PARAMS, SCHEMA, WITH_FUNCS},
    schema::SCHEMA_FIELD_PARSE_MAP,
};

pub mod bounds;
#[cfg(feature = "schema")]
pub mod schema;

enum Variants {
    Bounds(bounds::Bounds),
    SerializeWith(syn::ExprPath),
    DeserializeWith(syn::ExprPath),
    Skip(()),
    #[cfg(feature = "schema")]
    Schema(schema::Attributes),
}

type ParseFn = dyn Fn(Symbol, Symbol, &ParseNestedMeta) -> syn::Result<Variants> + Send + Sync;

static BORSH_FIELD_PARSE_MAP: Lazy<BTreeMap<Symbol, Box<ParseFn>>> = Lazy::new(|| {
    let mut m = BTreeMap::new();
    // assigning closure `let f = |args| {...};` and boxing closure `let f: Box<ParseFn> = Box::new(f);`
    // on 2 separate lines doesn't work
    let f_bounds: Box<ParseFn> = Box::new(|_attr_name, _meta_item_name, meta| {
        let map_result = meta_get_by_symbol_keys(BOUND, meta, &BOUNDS_FIELD_PARSE_MAP)?;
        let bounds_attributes: bounds::Bounds = map_result.into();
        Ok(Variants::Bounds(bounds_attributes))
    });

    let f_serialize_with: Box<ParseFn> = Box::new(|attr_name, meta_item_name, meta| {
        parse_lit_into::<syn::ExprPath>(attr_name, meta_item_name, meta)
            .map(Variants::SerializeWith)
    });

    let f_deserialize_with: Box<ParseFn> = Box::new(|attr_name, meta_item_name, meta| {
        parse_lit_into::<syn::ExprPath>(attr_name, meta_item_name, meta)
            .map(Variants::DeserializeWith)
    });

    #[cfg(feature = "schema")]
    let f_schema: Box<ParseFn> = Box::new(|_attr_name, _meta_item_name, meta| {
        let map_result = meta_get_by_symbol_keys(SCHEMA, meta, &SCHEMA_FIELD_PARSE_MAP)?;
        let schema_attributes: schema::Attributes = map_result.into();
        Ok(Variants::Schema(schema_attributes))
    });

    let f_skip: Box<ParseFn> =
        Box::new(|_attr_name, _meta_item_name, _meta| Ok(Variants::Skip(())));
    m.insert(BOUND, f_bounds);
    m.insert(SERIALIZE_WITH, f_serialize_with);
    m.insert(DESERIALIZE_WITH, f_deserialize_with);
    m.insert(SKIP, f_skip);
    #[cfg(feature = "schema")]
    m.insert(SCHEMA, f_schema);
    m
});

#[derive(Default, Clone)]
pub(crate) struct Attributes {
    pub bounds: Option<bounds::Bounds>,
    pub serialize_with: Option<syn::ExprPath>,
    pub deserialize_with: Option<syn::ExprPath>,
    pub skip: bool,
    #[cfg(feature = "schema")]
    pub schema: Option<schema::Attributes>,
}

impl From<BTreeMap<Symbol, Variants>> for Attributes {
    fn from(mut map: BTreeMap<Symbol, Variants>) -> Self {
        let bounds = map.remove(&BOUND);
        let serialize_with = map.remove(&SERIALIZE_WITH);
        let deserialize_with = map.remove(&DESERIALIZE_WITH);
        let skip = map.remove(&SKIP);
        let bounds = bounds.map(|variant| match variant {
            Variants::Bounds(bounds) => bounds,
            _ => unreachable!("only one enum variant is expected to correspond to given map key"),
        });

        let serialize_with = serialize_with.map(|variant| match variant {
            Variants::SerializeWith(serialize_with) => serialize_with,
            _ => unreachable!("only one enum variant is expected to correspond to given map key"),
        });

        let deserialize_with = deserialize_with.map(|variant| match variant {
            Variants::DeserializeWith(deserialize_with) => deserialize_with,
            _ => unreachable!("only one enum variant is expected to correspond to given map key"),
        });

        let skip = skip.map(|variant| match variant {
            Variants::Skip(skip) => skip,
            _ => unreachable!("only one enum variant is expected to correspond to given map key"),
        });

        #[cfg(feature = "schema")]
        let schema = {
            let schema = map.remove(&SCHEMA);
            schema.map(|variant| match variant {
                Variants::Schema(schema) => schema,
                _ => {
                    unreachable!("only one enum variant is expected to correspond to given map key")
                }
            })
        };
        Self {
            bounds,
            serialize_with,
            deserialize_with,
            skip: skip.is_some(),
            #[cfg(feature = "schema")]
            schema,
        }
    }
}

#[cfg(feature = "schema")]
pub(crate) fn filter_attrs(
    attrs: impl Iterator<Item = Attribute>,
) -> impl Iterator<Item = Attribute> {
    attrs.filter(|attr| attr.path() == BORSH)
}

impl Attributes {
    fn check(&self, attr: &Attribute) -> Result<(), syn::Error> {
        if self.skip && (self.serialize_with.is_some() || self.deserialize_with.is_some()) {
            return Err(syn::Error::new_spanned(
                attr,
                format!(
                    "`{}` cannot be used at the same time as `{}` or `{}`",
                    SKIP.0, SERIALIZE_WITH.0, DESERIALIZE_WITH.0
                ),
            ));
        }

        #[cfg(feature = "schema")]
        self.check_schema(attr)?;

        Ok(())
    }
    pub(crate) fn parse(attrs: &[Attribute]) -> Result<Self, syn::Error> {
        let borsh = get_one_attribute(attrs)?;

        let result: Self = if let Some(attr) = borsh {
            let result: Self = attr_get_by_symbol_keys(BORSH, attr, &BORSH_FIELD_PARSE_MAP)?.into();
            result.check(attr)?;
            result
        } else {
            BTreeMap::new().into()
        };

        Ok(result)
    }
    pub(crate) fn needs_bounds_derive(&self, ty: BoundType) -> bool {
        let predicates = self.get_bounds(ty);
        predicates.is_none()
    }

    fn get_bounds(&self, ty: BoundType) -> Option<Vec<WherePredicate>> {
        let bounds = self.bounds.as_ref();
        bounds.and_then(|bounds| match ty {
            BoundType::Serialize => bounds.serialize.clone(),
            BoundType::Deserialize => bounds.deserialize.clone(),
        })
    }
    pub(crate) fn collect_bounds(&self, ty: BoundType) -> Vec<WherePredicate> {
        let predicates = self.get_bounds(ty);
        predicates.unwrap_or_default()
    }
}

#[cfg(feature = "schema")]
impl Attributes {
    fn check_schema(&self, attr: &Attribute) -> Result<(), syn::Error> {
        if let Some(ref schema) = self.schema {
            if self.skip && schema.params.is_some() {
                return Err(syn::Error::new_spanned(
                    attr,
                    format!(
                        "`{}` cannot be used at the same time as `{}({})`",
                        SKIP.0, SCHEMA.0, PARAMS.1
                    ),
                ));
            }

            if self.skip && schema.with_funcs.is_some() {
                return Err(syn::Error::new_spanned(
                    attr,
                    format!(
                        "`{}` cannot be used at the same time as `{}({})`",
                        SKIP.0, SCHEMA.0, WITH_FUNCS.1
                    ),
                ));
            }
        }
        Ok(())
    }

    pub(crate) fn needs_schema_params_derive(&self) -> bool {
        if let Some(ref schema) = self.schema {
            if schema.params.is_some() {
                return false;
            }
        }
        true
    }

    pub(crate) fn schema_declaration(&self) -> Option<syn::ExprPath> {
        self.schema.as_ref().and_then(|schema| {
            schema
                .with_funcs
                .as_ref()
                .and_then(|with_funcs| with_funcs.declaration.clone())
        })
    }

    pub(crate) fn schema_definitions(&self) -> Option<syn::ExprPath> {
        self.schema.as_ref().and_then(|schema| {
            schema
                .with_funcs
                .as_ref()
                .and_then(|with_funcs| with_funcs.definitions.clone())
        })
    }
}

#[cfg(test)]
mod tests {
    use quote::quote;
    use syn::{Attribute, ItemStruct};

    fn parse_bounds(attrs: &[Attribute]) -> Result<Option<bounds::Bounds>, syn::Error> {
        // #[borsh(bound(serialize = "...", deserialize = "..."))]
        let borsh_attrs = Attributes::parse(attrs)?;
        Ok(borsh_attrs.bounds)
    }

    use crate::internals::test_helpers::{
        debug_print_tokenizable, debug_print_vec_of_tokenizable, local_insta_assert_debug_snapshot,
        local_insta_assert_snapshot,
    };

    use super::{bounds, Attributes};

    #[test]
    fn test_reject_multiple_borsh_attrs() {
        let item_struct: ItemStruct = syn::parse2(quote! {
            struct A {
                #[borsh(skip)]
                #[borsh(bound(deserialize = "K: Hash + Ord,
                     V: Eq + Ord",
                    serialize = "K: Hash + Eq + Ord,
                     V: Ord"
                ))]
                x: u64,
                y: String,
            }
        })
        .unwrap();

        let first_field = &item_struct.fields.into_iter().collect::<Vec<_>>()[0];
        let err = match Attributes::parse(&first_field.attrs) {
            Ok(..) => unreachable!("expecting error here"),
            Err(err) => err,
        };
        local_insta_assert_debug_snapshot!(err);
    }

    #[test]
    fn test_bounds_parsing1() {
        let item_struct: ItemStruct = syn::parse2(quote! {
            struct A {
                #[borsh(bound(deserialize = "K: Hash + Ord,
                     V: Eq + Ord",
                    serialize = "K: Hash + Eq + Ord,
                     V: Ord"
                ))]
                x: u64,
                y: String,
            }
        })
        .unwrap();

        let first_field = &item_struct.fields.into_iter().collect::<Vec<_>>()[0];
        let attrs = parse_bounds(&first_field.attrs).unwrap().unwrap();
        local_insta_assert_snapshot!(debug_print_vec_of_tokenizable(attrs.serialize.clone()));
        local_insta_assert_snapshot!(debug_print_vec_of_tokenizable(attrs.deserialize));
    }

    #[test]
    fn test_bounds_parsing2() {
        let item_struct: ItemStruct = syn::parse2(quote! {
            struct A {
                #[borsh(bound(deserialize = "K: Hash + Eq + borsh::de::BorshDeserialize,
                     V: borsh::de::BorshDeserialize",
                    serialize = "K: Hash + Eq + borsh::ser::BorshSerialize,
                     V: borsh::ser::BorshSerialize"
                ))]
                x: u64,
                y: String,
            }
        })
        .unwrap();

        let first_field = &item_struct.fields.into_iter().collect::<Vec<_>>()[0];
        let attrs = parse_bounds(&first_field.attrs).unwrap().unwrap();
        local_insta_assert_snapshot!(debug_print_vec_of_tokenizable(attrs.serialize.clone()));
        local_insta_assert_snapshot!(debug_print_vec_of_tokenizable(attrs.deserialize));
    }

    #[test]
    fn test_bounds_parsing3() {
        let item_struct: ItemStruct = syn::parse2(quote! {
            struct A {
                #[borsh(bound(deserialize = "K: Hash + Eq + borsh::de::BorshDeserialize,
                     V: borsh::de::BorshDeserialize",
                    serialize = ""
                ))]
                x: u64,
                y: String,
            }
        })
        .unwrap();

        let first_field = &item_struct.fields.into_iter().collect::<Vec<_>>()[0];
        let attrs = parse_bounds(&first_field.attrs).unwrap().unwrap();
        assert_eq!(attrs.serialize.as_ref().unwrap().len(), 0);
        local_insta_assert_snapshot!(debug_print_vec_of_tokenizable(attrs.deserialize));
    }

    #[test]
    fn test_bounds_parsing4() {
        let item_struct: ItemStruct = syn::parse2(quote! {
            struct A {
                #[borsh(bound(deserialize = "K: Hash"))]
                x: u64,
                y: String,
            }
        })
        .unwrap();

        let first_field = &item_struct.fields.into_iter().collect::<Vec<_>>()[0];
        let attrs = parse_bounds(&first_field.attrs).unwrap().unwrap();
        assert!(attrs.serialize.is_none());
        local_insta_assert_snapshot!(debug_print_vec_of_tokenizable(attrs.deserialize));
    }

    #[test]
    fn test_bounds_parsing_error() {
        let item_struct: ItemStruct = syn::parse2(quote! {
            struct A {
                #[borsh(bound(deser = "K: Hash"))]
                x: u64,
                y: String,
            }
        })
        .unwrap();

        let first_field = &item_struct.fields.into_iter().collect::<Vec<_>>()[0];
        let err = match parse_bounds(&first_field.attrs) {
            Ok(..) => unreachable!("expecting error here"),
            Err(err) => err,
        };
        local_insta_assert_debug_snapshot!(err);
    }

    #[test]
    fn test_bounds_parsing_error2() {
        let item_struct: ItemStruct = syn::parse2(quote! {
            struct A {
                #[borsh(bound(deserialize = "K Hash"))]
                x: u64,
                y: String,
            }
        })
        .unwrap();

        let first_field = &item_struct.fields.into_iter().collect::<Vec<_>>()[0];
        let err = match parse_bounds(&first_field.attrs) {
            Ok(..) => unreachable!("expecting error here"),
            Err(err) => err,
        };
        local_insta_assert_debug_snapshot!(err);
    }

    #[test]
    fn test_bounds_parsing_error3() {
        let item_struct: ItemStruct = syn::parse2(quote! {
            struct A {
                #[borsh(bound(deserialize = 42))]
                x: u64,
                y: String,
            }
        })
        .unwrap();

        let first_field = &item_struct.fields.into_iter().collect::<Vec<_>>()[0];
        let err = match parse_bounds(&first_field.attrs) {
            Ok(..) => unreachable!("expecting error here"),
            Err(err) => err,
        };
        local_insta_assert_debug_snapshot!(err);
    }

    #[test]
    fn test_ser_de_with_parsing1() {
        let item_struct: ItemStruct = syn::parse2(quote! {
            struct A {
                #[borsh(
                    serialize_with = "third_party_impl::serialize_third_party",
                    deserialize_with = "third_party_impl::deserialize_third_party",
                )]
                x: u64,
                y: String,
            }
        })
        .unwrap();

        let first_field = &item_struct.fields.into_iter().collect::<Vec<_>>()[0];
        let attrs = Attributes::parse(&first_field.attrs).unwrap();
        local_insta_assert_snapshot!(debug_print_tokenizable(attrs.serialize_with.as_ref()));
        local_insta_assert_snapshot!(debug_print_tokenizable(attrs.deserialize_with));
    }
    #[test]
    fn test_borsh_skip() {
        let item_struct: ItemStruct = syn::parse2(quote! {
            struct A {
                #[borsh(skip)]
                x: u64,
                y: String,
            }
        })
        .unwrap();

        let first_field = &item_struct.fields.into_iter().collect::<Vec<_>>()[0];

        let result = Attributes::parse(&first_field.attrs).unwrap();
        assert!(result.skip);
    }
    #[test]
    fn test_borsh_no_skip() {
        let item_struct: ItemStruct = syn::parse2(quote! {
            struct A {
                x: u64,
                y: String,
            }
        })
        .unwrap();

        let first_field = &item_struct.fields.into_iter().collect::<Vec<_>>()[0];

        let result = Attributes::parse(&first_field.attrs).unwrap();
        assert!(!result.skip);
    }
}

#[cfg(feature = "schema")]
#[cfg(test)]
mod tests_schema {
    use crate::internals::{
        attributes::field::Attributes,
        test_helpers::{
            debug_print_tokenizable, debug_print_vec_of_tokenizable,
            local_insta_assert_debug_snapshot, local_insta_assert_snapshot,
        },
    };

    use quote::quote;
    use syn::{Attribute, ItemStruct};

    use super::schema;
    fn parse_schema_attrs(attrs: &[Attribute]) -> Result<Option<schema::Attributes>, syn::Error> {
        // #[borsh(schema(params = "..."))]
        let borsh_attrs = Attributes::parse(attrs)?;
        Ok(borsh_attrs.schema)
    }

    #[test]
    fn test_root_bounds_and_params_combined() {
        let item_struct: ItemStruct = syn::parse2(quote! {
            struct A {
                #[borsh(
                    serialize_with = "third_party_impl::serialize_third_party",
                    bound(deserialize = "K: Hash"),
                    schema(params = "T => <T as TraitName>::Associated, V => Vec<V>")
                )]
                x: u64,
                y: String,
            }
        })
        .unwrap();

        let first_field = &item_struct.fields.into_iter().collect::<Vec<_>>()[0];

        let attrs = Attributes::parse(&first_field.attrs).unwrap();
        let bounds = attrs.bounds.clone().unwrap();
        assert!(bounds.serialize.is_none());
        local_insta_assert_snapshot!(debug_print_vec_of_tokenizable(bounds.deserialize));
        assert!(attrs.deserialize_with.is_none());
        let schema = attrs.schema.clone().unwrap();
        local_insta_assert_snapshot!(debug_print_vec_of_tokenizable(schema.params.clone()));
        local_insta_assert_snapshot!(debug_print_tokenizable(attrs.serialize_with));
    }

    #[test]
    fn test_schema_params_parsing1() {
        let item_struct: ItemStruct = syn::parse2(quote! {
            struct Parametrized<V, T>
            where
                T: TraitName,
            {
                #[borsh(schema(params =
                    "T => <T as TraitName>::Associated"
               ))]
                field: <T as TraitName>::Associated,
                another: V,
            }
        })
        .unwrap();

        let first_field = &item_struct.fields.into_iter().collect::<Vec<_>>()[0];
        let schema_attrs = parse_schema_attrs(&first_field.attrs).unwrap();
        local_insta_assert_snapshot!(debug_print_vec_of_tokenizable(schema_attrs.unwrap().params));
    }
    #[test]
    fn test_schema_params_parsing_error() {
        let item_struct: ItemStruct = syn::parse2(quote! {
            struct Parametrized<V, T>
            where
                T: TraitName,
            {
                #[borsh(schema(params =
                    "T => <T as TraitName, W>::Associated"
               ))]
                field: <T as TraitName>::Associated,
                another: V,
            }
        })
        .unwrap();

        let first_field = &item_struct.fields.into_iter().collect::<Vec<_>>()[0];
        let err = match parse_schema_attrs(&first_field.attrs) {
            Ok(..) => unreachable!("expecting error here"),
            Err(err) => err,
        };
        local_insta_assert_debug_snapshot!(err);
    }

    #[test]
    fn test_schema_params_parsing_error2() {
        let item_struct: ItemStruct = syn::parse2(quote! {
            struct Parametrized<V, T>
            where
                T: TraitName,
            {
                #[borsh(schema(paramsbum =
                    "T => <T as TraitName>::Associated"
               ))]
                field: <T as TraitName>::Associated,
                another: V,
            }
        })
        .unwrap();

        let first_field = &item_struct.fields.into_iter().collect::<Vec<_>>()[0];
        let err = match parse_schema_attrs(&first_field.attrs) {
            Ok(..) => unreachable!("expecting error here"),
            Err(err) => err,
        };
        local_insta_assert_debug_snapshot!(err);
    }

    #[test]
    fn test_schema_params_parsing2() {
        let item_struct: ItemStruct = syn::parse2(quote! {
            struct Parametrized<V, T>
            where
                T: TraitName,
            {
                #[borsh(schema(params =
                    "T => <T as TraitName>::Associated, V => Vec<V>"
               ))]
                field: <T as TraitName>::Associated,
                another: V,
            }
        })
        .unwrap();

        let first_field = &item_struct.fields.into_iter().collect::<Vec<_>>()[0];
        let schema_attrs = parse_schema_attrs(&first_field.attrs).unwrap();
        local_insta_assert_snapshot!(debug_print_vec_of_tokenizable(schema_attrs.unwrap().params));
    }
    #[test]
    fn test_schema_params_parsing3() {
        let item_struct: ItemStruct = syn::parse2(quote! {
            struct Parametrized<V, T>
            where
                T: TraitName,
            {
                #[borsh(schema(params = "" ))]
                field: <T as TraitName>::Associated,
                another: V,
            }
        })
        .unwrap();

        let first_field = &item_struct.fields.into_iter().collect::<Vec<_>>()[0];
        let schema_attrs = parse_schema_attrs(&first_field.attrs).unwrap();
        assert_eq!(schema_attrs.unwrap().params.unwrap().len(), 0);
    }

    #[test]
    fn test_schema_params_parsing4() {
        let item_struct: ItemStruct = syn::parse2(quote! {
            struct Parametrized<V, T>
            where
                T: TraitName,
            {
                field: <T as TraitName>::Associated,
                another: V,
            }
        })
        .unwrap();

        let first_field = &item_struct.fields.into_iter().collect::<Vec<_>>()[0];
        let schema_attrs = parse_schema_attrs(&first_field.attrs).unwrap();
        assert!(schema_attrs.is_none());
    }

    #[test]
    fn test_schema_with_funcs_parsing() {
        let item_struct: ItemStruct = syn::parse2(quote! {
            struct A {
                #[borsh(schema(with_funcs(
                    declaration = "third_party_impl::declaration::<K, V>",
                    definitions = "third_party_impl::add_definitions_recursively::<K, V>"
                )))]
                x: u64,
                y: String,
            }
        })
        .unwrap();

        let first_field = &item_struct.fields.into_iter().collect::<Vec<_>>()[0];
        let attrs = Attributes::parse(&first_field.attrs).unwrap();
        let schema = attrs.schema.unwrap();
        let with_funcs = schema.with_funcs.unwrap();

        local_insta_assert_snapshot!(debug_print_tokenizable(with_funcs.declaration.clone()));
        local_insta_assert_snapshot!(debug_print_tokenizable(with_funcs.definitions));
    }

    // both `declaration` and `definitions` have to be specified
    #[test]
    fn test_schema_with_funcs_parsing_error() {
        let item_struct: ItemStruct = syn::parse2(quote! {
            struct A {
                #[borsh(schema(with_funcs(
                    declaration = "third_party_impl::declaration::<K, V>"
                )))]
                x: u64,
                y: String,
            }
        })
        .unwrap();

        let first_field = &item_struct.fields.into_iter().collect::<Vec<_>>()[0];
        let attrs = Attributes::parse(&first_field.attrs);

        let err = match attrs {
            Ok(..) => unreachable!("expecting error here"),
            Err(err) => err,
        };
        local_insta_assert_debug_snapshot!(err);
    }

    #[test]
    fn test_root_error() {
        let item_struct: ItemStruct = syn::parse2(quote! {
            struct A {
                #[borsh(boons)]
                x: u64,
                y: String,
            }
        })
        .unwrap();

        let first_field = &item_struct.fields.into_iter().collect::<Vec<_>>()[0];
        let err = match Attributes::parse(&first_field.attrs) {
            Ok(..) => unreachable!("expecting error here"),
            Err(err) => err,
        };
        local_insta_assert_debug_snapshot!(err);
    }

    #[test]
    fn test_root_bounds_and_wrong_key_combined() {
        let item_struct: ItemStruct = syn::parse2(quote! {
            struct A {
                #[borsh(bound(deserialize = "K: Hash"),
                        schhema(params = "T => <T as TraitName>::Associated, V => Vec<V>")
                )]
                x: u64,
                y: String,
            }
        })
        .unwrap();

        let first_field = &item_struct.fields.into_iter().collect::<Vec<_>>()[0];

        let err = match Attributes::parse(&first_field.attrs) {
            Ok(..) => unreachable!("expecting error here"),
            Err(err) => err,
        };
        local_insta_assert_debug_snapshot!(err);
    }
}

'''
'''--- borsh-derive/src/internals/attributes/field/schema.rs ---
use std::collections::BTreeMap;

use crate::internals::attributes::{
    parsing::{meta_get_by_symbol_keys, parse_lit_into_vec},
    schema_keys::{DECLARATION, DEFINITIONS, PARAMS, WITH_FUNCS},
    Symbol,
};
use once_cell::sync::Lazy;
use syn::{meta::ParseNestedMeta, Ident, Token, Type};

use self::with_funcs::{WithFuncs, WITH_FUNCS_FIELD_PARSE_MAP};

pub mod with_funcs;

pub enum Variants {
    Params(Vec<ParameterOverride>),
    WithFuncs(WithFuncs),
}

type ParseFn = dyn Fn(Symbol, Symbol, &ParseNestedMeta) -> syn::Result<Variants> + Send + Sync;

pub static SCHEMA_FIELD_PARSE_MAP: Lazy<BTreeMap<Symbol, Box<ParseFn>>> = Lazy::new(|| {
    let mut m = BTreeMap::new();
    // assigning closure `let f = |args| {...};` and boxing closure `let f: Box<ParseFn> = Box::new(f);`
    // on 2 separate lines doesn't work
    let f_params: Box<ParseFn> = Box::new(|attr_name, meta_item_name, meta| {
        parse_lit_into_vec::<ParameterOverride>(attr_name, meta_item_name, meta)
            .map(Variants::Params)
    });

    let f_with_funcs: Box<ParseFn> = Box::new(|_attr_name, _meta_item_name, meta| {
        let map_result = meta_get_by_symbol_keys(WITH_FUNCS, meta, &WITH_FUNCS_FIELD_PARSE_MAP)?;
        let with_funcs: WithFuncs = map_result.into();
        if (with_funcs.declaration.is_some() && with_funcs.definitions.is_none())
            || (with_funcs.declaration.is_none() && with_funcs.definitions.is_some())
        {
            return Err(syn::Error::new_spanned(
                &meta.path,
                format!(
                    "both `{}` and `{}` have to be specified at the same time",
                    DECLARATION.1, DEFINITIONS.1,
                ),
            ));
        }
        Ok(Variants::WithFuncs(with_funcs))
    });
    m.insert(PARAMS, f_params);
    m.insert(WITH_FUNCS, f_with_funcs);
    m
});

/**
Struct describes an entry like `order_param => override_type`,  e.g. `K => <K as TraitName>::Associated`
*/
#[derive(Clone, syn_derive::Parse, syn_derive::ToTokens)]
pub struct ParameterOverride {
    pub order_param: Ident,
    arrow_token: Token![=>],
    pub override_type: Type,
}

#[allow(unused)]
#[derive(Default, Clone)]
pub(crate) struct Attributes {
    pub params: Option<Vec<ParameterOverride>>,
    pub with_funcs: Option<WithFuncs>,
}

impl From<BTreeMap<Symbol, Variants>> for Attributes {
    fn from(mut map: BTreeMap<Symbol, Variants>) -> Self {
        let params = map.remove(&PARAMS);
        let params = params.map(|variant| match variant {
            Variants::Params(params) => params,
            _ => unreachable!("only one enum variant is expected to correspond to given map key"),
        });

        let with_funcs = map.remove(&WITH_FUNCS);
        let with_funcs = with_funcs.map(|variant| match variant {
            Variants::WithFuncs(with_funcs) => with_funcs,
            _ => unreachable!("only one enum variant is expected to correspond to given map key"),
        });
        Self { params, with_funcs }
    }
}

'''
'''--- borsh-derive/src/internals/attributes/field/schema/with_funcs.rs ---
use std::collections::BTreeMap;

use once_cell::sync::Lazy;
use syn::meta::ParseNestedMeta;

use crate::internals::attributes::{
    parsing::parse_lit_into,
    schema_keys::{DECLARATION, DEFINITIONS},
    Symbol,
};

pub enum Variants {
    Declaration(syn::ExprPath),
    Definitions(syn::ExprPath),
}

type ParseFn = dyn Fn(Symbol, Symbol, &ParseNestedMeta) -> syn::Result<Variants> + Send + Sync;

pub static WITH_FUNCS_FIELD_PARSE_MAP: Lazy<BTreeMap<Symbol, Box<ParseFn>>> = Lazy::new(|| {
    let mut m = BTreeMap::new();
    // assigning closure `let f = |args| {...};` and boxing closure `let f: Box<ParseFn> = Box::new(f);`
    // on 2 separate lines doesn't work
    let f_declaration: Box<ParseFn> = Box::new(|attr_name, meta_item_name, meta| {
        parse_lit_into::<syn::ExprPath>(attr_name, meta_item_name, meta).map(Variants::Declaration)
    });

    let f_definitions: Box<ParseFn> = Box::new(|attr_name, meta_item_name, meta| {
        parse_lit_into::<syn::ExprPath>(attr_name, meta_item_name, meta).map(Variants::Definitions)
    });

    m.insert(DECLARATION, f_declaration);
    m.insert(DEFINITIONS, f_definitions);
    m
});

#[derive(Clone)]
pub struct WithFuncs {
    pub declaration: Option<syn::ExprPath>,
    pub definitions: Option<syn::ExprPath>,
}

impl From<BTreeMap<Symbol, Variants>> for WithFuncs {
    fn from(mut map: BTreeMap<Symbol, Variants>) -> Self {
        let declaration = map.remove(&DECLARATION);
        let definitions = map.remove(&DEFINITIONS);
        let declaration = declaration.map(|variant| match variant {
            Variants::Declaration(declaration) => declaration,
            _ => unreachable!("only one enum variant is expected to correspond to given map key"),
        });
        let definitions = definitions.map(|variant| match variant {
            Variants::Definitions(definitions) => definitions,
            _ => unreachable!("only one enum variant is expected to correspond to given map key"),
        });
        Self {
            declaration,
            definitions,
        }
    }
}

'''
'''--- borsh-derive/src/internals/attributes/item/mod.rs ---
use crate::internals::attributes::{BORSH, CRATE, INIT, USE_DISCRIMINANT};
use quote::ToTokens;
use syn::{spanned::Spanned, Attribute, DeriveInput, Error, Expr, ItemEnum, Path};

use super::{get_one_attribute, parsing};

pub fn check_attributes(derive_input: &DeriveInput) -> Result<(), Error> {
    let borsh = get_one_attribute(&derive_input.attrs)?;

    if let Some(attr) = borsh {
        attr.parse_nested_meta(|meta| {
            if meta.path != USE_DISCRIMINANT && meta.path != INIT && meta.path != CRATE {
                return Err(syn::Error::new(
                    meta.path.span(),
                    "`crate`, `use_discriminant` or `init` are the only supported attributes for `borsh`",
                ));
            }
            if meta.path == USE_DISCRIMINANT {
                let _expr: Expr = meta.value()?.parse()?;
                if let syn::Data::Struct(ref _data) = derive_input.data {
                    return Err(syn::Error::new(
                        derive_input.ident.span(),
                        "borsh(use_discriminant=<bool>) does not support structs",
                    ));
                }
            } else if meta.path == INIT || meta.path == CRATE {
                let _expr: Expr = meta.value()?.parse()?;
            }

            Ok(())
        })?;
    }
    Ok(())
}

pub(crate) fn contains_use_discriminant(input: &ItemEnum) -> Result<bool, syn::Error> {
    if input.variants.len() > 256 {
        return Err(syn::Error::new(
            input.span(),
            "up to 256 enum variants are supported",
        ));
    }

    let attrs = &input.attrs;
    let mut use_discriminant = None;
    let attr = attrs.iter().find(|attr| attr.path() == BORSH);
    if let Some(attr) = attr {
        attr.parse_nested_meta(|meta| {
            if meta.path == USE_DISCRIMINANT {
                let value_expr: Expr = meta.value()?.parse()?;
                let value = value_expr.to_token_stream().to_string();
                match value.as_str() {
                    "true" => {
                        use_discriminant = Some(true);
                    }
                    "false" => use_discriminant = Some(false),
                    _ => {
                        return Err(syn::Error::new(
                            value_expr.span(),
                            "`use_discriminant` accepts only `true` or `false`",
                        ));
                    }
                };
            } else if meta.path == INIT || meta.path == CRATE {
                let _value_expr: Expr = meta.value()?.parse()?;
            }
            Ok(())
        })?;
    }
    let has_explicit_discriminants = input
        .variants
        .iter()
        .any(|variant| variant.discriminant.is_some());
    if has_explicit_discriminants && use_discriminant.is_none() {
        return Err(syn::Error::new(
                input.ident.span(),
                "You have to specify `#[borsh(use_discriminant=true)]` or `#[borsh(use_discriminant=false)]` for all enums with explicit discriminant",
            ));
    }
    Ok(use_discriminant.unwrap_or(false))
}

pub(crate) fn contains_initialize_with(attrs: &[Attribute]) -> Result<Option<Path>, Error> {
    let mut res = None;
    let attr = attrs.iter().find(|attr| attr.path() == BORSH);
    if let Some(attr) = attr {
        attr.parse_nested_meta(|meta| {
            if meta.path == INIT {
                let value_expr: Path = meta.value()?.parse()?;
                res = Some(value_expr);
            } else if meta.path == USE_DISCRIMINANT || meta.path == CRATE {
                let _value_expr: Expr = meta.value()?.parse()?;
            }

            Ok(())
        })?;
    }

    Ok(res)
}

pub(crate) fn get_crate(attrs: &[Attribute]) -> Result<Option<Path>, Error> {
    let mut res = None;
    let attr = attrs.iter().find(|attr| attr.path() == BORSH);
    if let Some(attr) = attr {
        attr.parse_nested_meta(|meta| {
            if meta.path == CRATE {
                let value_expr: Path = parsing::parse_lit_into(BORSH, CRATE, &meta)?;
                res = Some(value_expr);
            } else if meta.path == USE_DISCRIMINANT || meta.path == INIT {
                let _value_expr: Expr = meta.value()?.parse()?;
            }

            Ok(())
        })?;
    }

    Ok(res)
}

#[cfg(test)]
mod tests {
    use crate::internals::test_helpers::local_insta_assert_debug_snapshot;
    use quote::{quote, ToTokens};
    use syn::ItemEnum;

    use super::*;
    #[test]
    fn test_use_discriminant() {
        let item_enum: ItemEnum = syn::parse2(quote! {
            #[derive(BorshDeserialize, Debug)]
            #[borsh(use_discriminant = false)]
            enum AWithUseDiscriminantFalse {
                X,
                Y,
            }
        })
        .unwrap();
        let actual = contains_use_discriminant(&item_enum);
        assert!(!actual.unwrap());
    }

    #[test]
    fn test_use_discriminant_true() {
        let item_enum: ItemEnum = syn::parse2(quote! {
            #[derive(BorshDeserialize, Debug)]
            #[borsh(use_discriminant = true)]
            enum AWithUseDiscriminantTrue {
                X,
                Y,
            }
        })
        .unwrap();
        let actual = contains_use_discriminant(&item_enum);
        assert!(actual.unwrap());
    }

    #[test]
    fn test_use_discriminant_wrong_value() {
        let item_enum: ItemEnum = syn::parse2(quote! {
            #[derive(BorshDeserialize, Debug)]
            #[borsh(use_discriminant = 111)]
            enum AWithUseDiscriminantFalse {
                X,
                Y,
            }
        })
        .unwrap();
        let actual = contains_use_discriminant(&item_enum);
        let err = match actual {
            Ok(..) => unreachable!("expecting error here"),
            Err(err) => err,
        };
        local_insta_assert_debug_snapshot!(err);
    }
    #[test]
    fn test_check_attrs_use_discriminant_on_struct() {
        let item_enum: DeriveInput = syn::parse2(quote! {
            #[derive(BorshDeserialize, Debug)]
            #[borsh(use_discriminant = false)]
            struct AWithUseDiscriminantFalse {
                x: X,
                y: Y,
            }
        })
        .unwrap();
        let actual = check_attributes(&item_enum);
        local_insta_assert_debug_snapshot!(actual.unwrap_err());
    }
    #[test]
    fn test_check_attrs_borsh_skip_on_whole_item() {
        let item_enum: DeriveInput = syn::parse2(quote! {
            #[derive(BorshDeserialize, Debug)]
            #[borsh(skip)]
            struct AWithUseDiscriminantFalse {
                 x: X,
                 y: Y,
            }
        })
        .unwrap();
        let actual = check_attributes(&item_enum);
        local_insta_assert_debug_snapshot!(actual.unwrap_err());
    }
    #[test]
    fn test_check_attrs_borsh_invalid_on_whole_item() {
        let item_enum: DeriveInput = syn::parse2(quote! {
            #[derive(BorshDeserialize, Debug)]
            #[borsh(invalid)]
            enum AWithUseDiscriminantFalse {
                X,
                Y,
            }
        })
        .unwrap();
        let actual = check_attributes(&item_enum);
        local_insta_assert_debug_snapshot!(actual.unwrap_err());
    }
    #[test]
    fn test_check_attrs_init_function() {
        let item_struct = syn::parse2::<DeriveInput>(quote! {
            #[derive(BorshSerialize, BorshDeserialize, PartialEq, Debug)]
            #[borsh(init = initialization_method)]
            struct A<'a> {
                x: u64,
            }
        })
        .unwrap();

        let actual = check_attributes(&item_struct);
        assert!(actual.is_ok());
    }

    #[test]
    fn test_check_attrs_init_function_with_use_discriminant_reversed() {
        let item_struct = syn::parse2::<DeriveInput>(quote! {
            #[derive(BorshSerialize, BorshDeserialize, PartialEq, Debug)]
            #[borsh(use_discriminant=true, init = initialization_method)]
            enum A {
                B,
                C,
                D= 10,
            }
        })
        .unwrap();

        let actual = check_attributes(&item_struct);
        assert!(actual.is_ok());
    }

    #[test]
    fn test_reject_multiple_borsh_attrs() {
        let item_struct = syn::parse2::<DeriveInput>(quote! {
            #[derive(BorshSerialize, BorshDeserialize, PartialEq, Debug)]
            #[borsh(use_discriminant=true)]
            #[borsh(init = initialization_method)]
            enum A {
                B,
                C,
                D= 10,
            }
        })
        .unwrap();

        let actual = check_attributes(&item_struct);
        local_insta_assert_debug_snapshot!(actual.unwrap_err());
    }

    #[test]
    fn test_check_attrs_init_function_with_use_discriminant() {
        let item_struct = syn::parse2::<DeriveInput>(quote! {
            #[derive(BorshSerialize, BorshDeserialize, PartialEq, Debug)]
            #[borsh(init = initialization_method, use_discriminant=true)]
            enum A {
                B,
                C,
                D= 10,
            }
        })
        .unwrap();

        let actual = check_attributes(&item_struct);
        assert!(actual.is_ok());
    }

    #[test]
    fn test_check_attrs_init_function_wrong_format() {
        let item_struct: DeriveInput = syn::parse2(quote! {
        #[derive(BorshDeserialize, Debug)]
        #[borsh(init_func = initialization_method)]
        struct A<'a> {
            x: u64,
            b: B,
            y: f32,
            z: String,
            v: Vec<String>,

        }
            })
        .unwrap();
        let actual = check_attributes(&item_struct);
        local_insta_assert_debug_snapshot!(actual.unwrap_err());
    }
    #[test]
    fn test_init_function() {
        let item_struct = syn::parse2::<DeriveInput>(quote! {
            #[derive(BorshSerialize, BorshDeserialize, PartialEq, Debug)]
            #[borsh(init = initialization_method)]
            struct A<'a> {
                x: u64,
            }
        })
        .unwrap();

        let actual = contains_initialize_with(&item_struct.attrs);
        assert_eq!(
            actual.unwrap().to_token_stream().to_string(),
            "initialization_method"
        );
    }

    #[test]
    fn test_init_function_parsing_error() {
        let item_struct = syn::parse2::<DeriveInput>(quote! {
            #[derive(BorshSerialize, BorshDeserialize, PartialEq, Debug)]
            #[borsh(init={strange; blocky})]
            struct A {
                lazy: Option<u64>,
            }
        })
        .unwrap();

        let actual = contains_initialize_with(&item_struct.attrs);
        let err = match actual {
            Ok(..) => unreachable!("expecting error here"),
            Err(err) => err,
        };
        local_insta_assert_debug_snapshot!(err);
    }

    #[test]
    fn test_init_function_with_use_discriminant() {
        let item_struct = syn::parse2::<ItemEnum>(quote! {
            #[derive(BorshSerialize, BorshDeserialize, PartialEq, Debug)]
            #[borsh(init = initialization_method, use_discriminant=true)]
            enum A {
                B,
                C,
                D,
            }
        })
        .unwrap();

        let actual = contains_initialize_with(&item_struct.attrs);
        assert_eq!(
            actual.unwrap().to_token_stream().to_string(),
            "initialization_method"
        );
        let actual = contains_use_discriminant(&item_struct);
        assert!(actual.unwrap());
    }

    #[test]
    fn test_init_function_with_use_discriminant_reversed() {
        let item_struct = syn::parse2::<ItemEnum>(quote! {
            #[derive(BorshSerialize, BorshDeserialize, PartialEq, Debug)]
            #[borsh(use_discriminant=true, init = initialization_method)]
            enum A {
                B,
                C,
                D,
            }
        })
        .unwrap();

        let actual = contains_initialize_with(&item_struct.attrs);
        assert_eq!(
            actual.unwrap().to_token_stream().to_string(),
            "initialization_method"
        );
        let actual = contains_use_discriminant(&item_struct);
        assert!(actual.unwrap());
    }

    #[test]
    fn test_init_function_with_use_discriminant_with_crate() {
        let item_struct = syn::parse2::<ItemEnum>(quote! {
            #[derive(BorshSerialize, BorshDeserialize, PartialEq, Debug)]
            #[borsh(init = initialization_method, crate = "reexporter::borsh", use_discriminant=true)]
            enum A {
                B,
                C,
                D,
            }
        })
        .unwrap();

        let actual = contains_initialize_with(&item_struct.attrs);
        assert_eq!(
            actual.unwrap().to_token_stream().to_string(),
            "initialization_method"
        );
        let actual = contains_use_discriminant(&item_struct);
        assert!(actual.unwrap());

        let crate_ = get_crate(&item_struct.attrs);
        assert_eq!(
            crate_.unwrap().to_token_stream().to_string(),
            "reexporter :: borsh"
        );
    }
}

'''
'''--- borsh-derive/src/internals/attributes/mod.rs ---
use syn::{Attribute, Path};

pub mod field;
pub mod item;
pub mod parsing;

/// first field is attr name
/// second field is its expected value format representation for error printing
#[derive(Copy, Clone, PartialEq, PartialOrd, Eq, Ord)]
pub struct Symbol(pub &'static str, pub &'static str);

/// borsh - top level prefix in nested meta attribute
pub const BORSH: Symbol = Symbol("borsh", "borsh(...)");
/// bound - sub-borsh nested meta, field-level only, `BorshSerialize` and `BorshDeserialize` contexts
pub const BOUND: Symbol = Symbol("bound", "bound(...)");
//  use_discriminant - sub-borsh nested meta, item-level only, enums only, `BorshSerialize` and `BorshDeserialize` contexts
pub const USE_DISCRIMINANT: Symbol = Symbol("use_discriminant", "use_discriminant = ...");
/// serialize - sub-bound nested meta attribute
pub const SERIALIZE: Symbol = Symbol("serialize", "serialize = ...");
/// deserialize - sub-bound nested meta attribute
pub const DESERIALIZE: Symbol = Symbol("deserialize", "deserialize = ...");
/// skip - sub-borsh nested meta, field-level only attribute, `BorshSerialize`, `BorshDeserialize`, `BorshSchema` contexts
pub const SKIP: Symbol = Symbol("skip", "skip");
/// init - sub-borsh nested meta, item-level only attribute  `BorshDeserialize` context
pub const INIT: Symbol = Symbol("init", "init = ...");
/// serialize_with - sub-borsh nested meta, field-level only, `BorshSerialize` context
pub const SERIALIZE_WITH: Symbol = Symbol("serialize_with", "serialize_with = ...");
/// deserialize_with - sub-borsh nested meta, field-level only, `BorshDeserialize` context
pub const DESERIALIZE_WITH: Symbol = Symbol("deserialize_with", "deserialize_with = ...");
/// crate - sub-borsh nested meta, item-level only, `BorshSerialize`, `BorshDeserialize`, `BorshSchema` contexts
pub const CRATE: Symbol = Symbol("crate", "crate = ...");

#[cfg(feature = "schema")]
pub mod schema_keys {
    use super::Symbol;

    /// schema - sub-borsh nested meta, `BorshSchema` context
    pub const SCHEMA: Symbol = Symbol("schema", "schema(...)");
    /// params - sub-schema nested meta, field-level only attribute
    pub const PARAMS: Symbol = Symbol("params", "params = ...");
    /// serialize_with - sub-borsh nested meta, field-level only, `BorshSerialize` context
    /// with_funcs - sub-schema nested meta, field-level only attribute
    pub const WITH_FUNCS: Symbol = Symbol("with_funcs", "with_funcs(...)");
    /// declaration - sub-with_funcs nested meta, field-level only attribute
    pub const DECLARATION: Symbol = Symbol("declaration", "declaration = ...");
    /// definitions - sub-with_funcs nested meta, field-level only attribute
    pub const DEFINITIONS: Symbol = Symbol("definitions", "definitions = ...");
}

#[derive(Clone, Copy)]
pub enum BoundType {
    Serialize,
    Deserialize,
}
impl PartialEq<Symbol> for Path {
    fn eq(&self, word: &Symbol) -> bool {
        self.is_ident(word.0)
    }
}

impl<'a> PartialEq<Symbol> for &'a Path {
    fn eq(&self, word: &Symbol) -> bool {
        self.is_ident(word.0)
    }
}

fn get_one_attribute(attrs: &[Attribute]) -> syn::Result<Option<&Attribute>> {
    let count = attrs.iter().filter(|attr| attr.path() == BORSH).count();
    let borsh = attrs.iter().find(|attr| attr.path() == BORSH);
    if count > 1 {
        return Err(syn::Error::new_spanned(
            borsh.unwrap(),
            format!("multiple `{}` attributes not allowed", BORSH.0),
        ));
    }
    Ok(borsh)
}

'''
'''--- borsh-derive/src/internals/attributes/parsing.rs ---
use std::{collections::BTreeMap, iter::FromIterator};

use syn::{
    meta::ParseNestedMeta, punctuated::Punctuated, token::Paren, Attribute, Expr, Lit, LitStr,
    Token,
};

use super::Symbol;

fn get_lit_str2(
    attr_name: Symbol,
    meta_item_name: Symbol,
    meta: &ParseNestedMeta,
) -> syn::Result<LitStr> {
    let expr: Expr = meta.value()?.parse()?;
    let mut value = &expr;
    while let Expr::Group(e) = value {
        value = &e.expr;
    }
    if let Expr::Lit(syn::ExprLit {
        lit: Lit::Str(lit), ..
    }) = value
    {
        Ok(lit.clone())
    } else {
        Err(syn::Error::new_spanned(
            expr,
            format!(
                "expected borsh {} attribute to be a string: `{} = \"...\"`",
                attr_name.0, meta_item_name.0
            ),
        ))
    }
}

pub(super) fn parse_lit_into<T: syn::parse::Parse>(
    attr_name: Symbol,
    meta_item_name: Symbol,
    meta: &ParseNestedMeta,
) -> syn::Result<T> {
    let string = get_lit_str2(attr_name, meta_item_name, meta)?;

    match string.parse() {
        Ok(expr) => Ok(expr),
        Err(err) => Err(syn::Error::new_spanned(string, err)),
    }
}

pub(super) fn parse_lit_into_vec<T: syn::parse::Parse>(
    attr_name: Symbol,
    meta_item_name: Symbol,
    meta: &ParseNestedMeta,
) -> syn::Result<Vec<T>> {
    let string = get_lit_str2(attr_name, meta_item_name, meta)?;

    match string.parse_with(Punctuated::<T, Token![,]>::parse_terminated) {
        Ok(elements) => Ok(Vec::from_iter(elements)),
        Err(err) => Err(syn::Error::new_spanned(string, err)),
    }
}

fn get_nested_meta_logic<T, F>(
    attr_name: Symbol,
    meta: ParseNestedMeta,
    map: &BTreeMap<Symbol, F>,
    result: &mut BTreeMap<Symbol, T>,
) -> syn::Result<()>
where
    F: Fn(Symbol, Symbol, &ParseNestedMeta) -> syn::Result<T>,
{
    let mut match_ = false;
    for (symbol_key, func) in map.iter() {
        if meta.path == *symbol_key {
            let v = func(attr_name, *symbol_key, &meta)?;
            result.insert(*symbol_key, v);
            match_ = true;
        }
    }
    if !match_ {
        let keys_strs = map.keys().map(|symbol| symbol.1).collect::<Vec<_>>();
        let keys_strs = keys_strs.join(", ");
        return Err(meta.error(format_args!(
            "malformed {0} attribute, expected `{0}({1})`",
            attr_name.0, keys_strs
        )));
    }
    Ok(())
}

pub(super) fn meta_get_by_symbol_keys<T, F>(
    attr_name: Symbol,
    meta: &ParseNestedMeta,
    map: &BTreeMap<Symbol, F>,
) -> syn::Result<BTreeMap<Symbol, T>>
where
    F: Fn(Symbol, Symbol, &ParseNestedMeta) -> syn::Result<T>,
{
    let mut result = BTreeMap::new();

    let lookahead = meta.input.lookahead1();
    if lookahead.peek(Paren) {
        meta.parse_nested_meta(|meta| get_nested_meta_logic(attr_name, meta, map, &mut result))?;
    } else {
        return Err(lookahead.error());
    }

    Ok(result)
}

pub(super) fn attr_get_by_symbol_keys<T, F>(
    attr_name: Symbol,
    attr: &Attribute,
    map: &BTreeMap<Symbol, F>,
) -> syn::Result<BTreeMap<Symbol, T>>
where
    F: Fn(Symbol, Symbol, &ParseNestedMeta) -> syn::Result<T>,
{
    let mut result = BTreeMap::new();

    attr.parse_nested_meta(|meta| get_nested_meta_logic(attr_name, meta, map, &mut result))?;

    Ok(result)
}

'''
'''--- borsh-derive/src/internals/cratename.rs ---
use proc_macro2::Span;
use proc_macro_crate::{crate_name, FoundCrate};
use syn::{Attribute, Error, Ident, Path};

use super::attributes::item;

pub(crate) const BORSH: &str = "borsh";

pub(crate) fn get(attrs: &[Attribute]) -> Result<Path, Error> {
    let path = item::get_crate(attrs)?;
    match path {
        Some(path) => Ok(path),
        None => {
            let ident = get_from_cargo();
            Ok(ident.into())
        }
    }
}

pub(crate) fn get_from_cargo() -> Ident {
    let name = &crate_name(BORSH).unwrap();
    let name = match name {
        FoundCrate::Itself => BORSH,
        FoundCrate::Name(name) => name.as_str(),
    };
    Ident::new(name, Span::call_site())
}

'''
'''--- borsh-derive/src/internals/deserialize/enums/mod.rs ---
use proc_macro2::TokenStream as TokenStream2;
use quote::quote;
use syn::{Fields, ItemEnum, Path, Variant};

use crate::internals::{attributes::item, deserialize, enum_discriminant::Discriminants, generics};

pub fn process(input: &ItemEnum, cratename: Path) -> syn::Result<TokenStream2> {
    let name = &input.ident;
    let generics = generics::without_defaults(&input.generics);
    let (impl_generics, ty_generics, where_clause) = generics.split_for_impl();
    let mut where_clause = generics::default_where(where_clause);
    let mut variant_arms = TokenStream2::new();
    let use_discriminant = item::contains_use_discriminant(input)?;
    let discriminants = Discriminants::new(&input.variants);
    let mut generics_output = deserialize::GenericsOutput::new(&generics);

    for (variant_idx, variant) in input.variants.iter().enumerate() {
        let variant_body = process_variant(variant, &cratename, &mut generics_output)?;
        let variant_ident = &variant.ident;

        let discriminant_value = discriminants.get(variant_ident, use_discriminant, variant_idx)?;
        variant_arms.extend(quote! {
            if variant_tag == #discriminant_value { #name::#variant_ident #variant_body } else
        });
    }
    let init = if let Some(method_ident) = item::contains_initialize_with(&input.attrs)? {
        quote! {
            return_value.#method_ident();
        }
    } else {
        quote! {}
    };
    generics_output.extend(&mut where_clause, &cratename);

    Ok(quote! {
        impl #impl_generics #cratename::de::BorshDeserialize for #name #ty_generics #where_clause {
            fn deserialize_reader<__R: #cratename::io::Read>(reader: &mut __R) -> ::core::result::Result<Self, #cratename::io::Error> {
                let tag = <u8 as #cratename::de::BorshDeserialize>::deserialize_reader(reader)?;
                <Self as #cratename::de::EnumExt>::deserialize_variant(reader, tag)
            }
        }

        impl #impl_generics #cratename::de::EnumExt for #name #ty_generics #where_clause {
            fn deserialize_variant<__R: #cratename::io::Read>(
                reader: &mut __R,
                variant_tag: u8,
            ) -> ::core::result::Result<Self, #cratename::io::Error> {
                let mut return_value =
                    #variant_arms {
                    return Err(#cratename::io::Error::new(
                        #cratename::io::ErrorKind::InvalidData,
                        #cratename::__private::maybestd::format!("Unexpected variant tag: {:?}", variant_tag),
                    ))
                };
                #init
                Ok(return_value)
            }
        }
    })
}

fn process_variant(
    variant: &Variant,
    cratename: &Path,
    generics: &mut deserialize::GenericsOutput,
) -> syn::Result<TokenStream2> {
    let mut body = TokenStream2::new();
    match &variant.fields {
        Fields::Named(fields) => {
            for field in &fields.named {
                deserialize::process_field(field, cratename, &mut body, generics)?;
            }
            body = quote! { { #body }};
        }
        Fields::Unnamed(fields) => {
            for field in fields.unnamed.iter() {
                deserialize::process_field(field, cratename, &mut body, generics)?;
            }
            body = quote! { ( #body )};
        }
        Fields::Unit => {}
    }
    Ok(body)
}

#[cfg(test)]
mod tests {
    use crate::internals::test_helpers::{
        default_cratename, local_insta_assert_snapshot, pretty_print_syn_str,
    };

    use super::*;

    #[test]
    fn borsh_skip_struct_variant_field() {
        let item_enum: ItemEnum = syn::parse2(quote! {
            enum AA {
                B {
                    #[borsh(skip)]
                    c: i32,
                    d: u32,
                },
                NegatedVariant {
                    beta: u8,
                }
            }
        })
        .unwrap();
        let actual = process(&item_enum, default_cratename()).unwrap();

        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn borsh_skip_tuple_variant_field() {
        let item_enum: ItemEnum = syn::parse2(quote! {
            enum AAT {
                B(#[borsh(skip)] i32, u32),

                NegatedVariant {
                    beta: u8,
                }
            }
        })
        .unwrap();
        let actual = process(&item_enum, default_cratename()).unwrap();

        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn simple_enum_with_custom_crate() {
        let item_struct: ItemEnum = syn::parse2(quote! {
            enum A {
                B {
                    x: HashMap<u32, String>,
                    y: String,
                },
                C(K, Vec<u64>),
            }
        })
        .unwrap();

        let crate_: Path = syn::parse2(quote! { reexporter::borsh }).unwrap();
        let actual = process(&item_struct, crate_).unwrap();
        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn simple_generics() {
        let item_struct: ItemEnum = syn::parse2(quote! {
            enum A<K, V, U> {
                B {
                    x: HashMap<K, V>,
                    y: String,
                },
                C(K, Vec<U>),
            }
        })
        .unwrap();

        let actual = process(&item_struct, default_cratename()).unwrap();
        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn bound_generics() {
        let item_struct: ItemEnum = syn::parse2(quote! {
            enum A<K: Key, V, U> where V: Value {
                B {
                    x: HashMap<K, V>,
                    y: String,
                },
                C(K, Vec<U>),
            }
        })
        .unwrap();

        let actual = process(&item_struct, default_cratename()).unwrap();
        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn recursive_enum() {
        let item_struct: ItemEnum = syn::parse2(quote! {
            enum A<K: Key, V> where V: Value {
                B {
                    x: HashMap<K, V>,
                    y: String,
                },
                C(K, Vec<A>),
            }
        })
        .unwrap();

        let actual = process(&item_struct, default_cratename()).unwrap();

        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }
    #[test]
    fn generic_borsh_skip_struct_field() {
        let item_struct: ItemEnum = syn::parse2(quote! {
            enum A<K: Key, V, U> where V: Value {
                B {
                    #[borsh(skip)]
                    x: HashMap<K, V>,
                    y: String,
                },
                C(K, Vec<U>),
            }
        })
        .unwrap();

        let actual = process(&item_struct, default_cratename()).unwrap();

        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn generic_borsh_skip_tuple_field() {
        let item_struct: ItemEnum = syn::parse2(quote! {
            enum A<K: Key, V, U> where V: Value {
                B {
                    x: HashMap<K, V>,
                    y: String,
                },
                C(K, #[borsh(skip)] Vec<U>),
            }
        })
        .unwrap();

        let actual = process(&item_struct, default_cratename()).unwrap();

        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn generic_deserialize_bound() {
        let item_struct: ItemEnum = syn::parse2(quote! {
            enum A<T: Debug, U> {
                C {
                    a: String,
                    #[borsh(bound(deserialize =
                        "T: PartialOrd + Hash + Eq + borsh::de::BorshDeserialize,
                         U: borsh::de::BorshDeserialize"
                    ))]
                    b: HashMap<T, U>,
                },
                D(u32, u32),
            }
        })
        .unwrap();

        let actual = process(&item_struct, default_cratename()).unwrap();

        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn check_deserialize_with_attr() {
        let item_struct: ItemEnum = syn::parse2(quote! {
            enum C<K: Ord, V> {
                C3(u64, u64),
                C4 {
                    x: u64,
                    #[borsh(deserialize_with = "third_party_impl::deserialize_third_party")]
                    y: ThirdParty<K, V>
                },
            }
        })
        .unwrap();

        let actual = process(&item_struct, default_cratename()).unwrap();

        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn borsh_discriminant_false() {
        let item_enum: ItemEnum = syn::parse2(quote! {
           #[borsh(use_discriminant = false)]
            enum X {
                A,
                B = 20,
                C,
                D,
                E = 10,
                F,
            }
        })
        .unwrap();
        let actual = process(&item_enum, default_cratename()).unwrap();

        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }
    #[test]
    fn borsh_discriminant_true() {
        let item_enum: ItemEnum = syn::parse2(quote! {
            #[borsh(use_discriminant = true)]
            enum X {
                A,
                B = 20,
                C,
                D,
                E = 10,
                F,
            }
        })
        .unwrap();
        let actual = process(&item_enum, default_cratename()).unwrap();

        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }
    #[test]
    fn borsh_init_func() {
        let item_enum: ItemEnum = syn::parse2(quote! {
            #[borsh(init = initialization_method)]
            enum A {
                A,
                B,
                C,
                D,
                E,
                F,
            }
        })
        .unwrap();
        let actual = process(&item_enum, default_cratename()).unwrap();
        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }
}

'''
'''--- borsh-derive/src/internals/deserialize/mod.rs ---
use proc_macro2::TokenStream as TokenStream2;
use quote::quote;
use syn::{ExprPath, Generics, Ident, Path};

use super::{
    attributes::{field, BoundType},
    generics,
};

pub mod enums;
pub mod structs;
pub mod unions;

struct GenericsOutput {
    overrides: Vec<syn::WherePredicate>,
    default_visitor: generics::FindTyParams,
    deserialize_visitor: generics::FindTyParams,
}

impl GenericsOutput {
    fn new(generics: &Generics) -> Self {
        Self {
            overrides: vec![],
            deserialize_visitor: generics::FindTyParams::new(generics),
            default_visitor: generics::FindTyParams::new(generics),
        }
    }
    fn extend(self, where_clause: &mut syn::WhereClause, cratename: &Path) {
        let de_trait: Path = syn::parse2(quote! { #cratename::de::BorshDeserialize }).unwrap();
        let default_trait: Path = syn::parse2(quote! { core::default::Default }).unwrap();
        let de_predicates =
            generics::compute_predicates(self.deserialize_visitor.process_for_bounds(), &de_trait);
        let default_predicates =
            generics::compute_predicates(self.default_visitor.process_for_bounds(), &default_trait);
        where_clause.predicates.extend(de_predicates);
        where_clause.predicates.extend(default_predicates);
        where_clause.predicates.extend(self.overrides);
    }
}

fn process_field(
    field: &syn::Field,
    cratename: &Path,
    body: &mut TokenStream2,
    generics: &mut GenericsOutput,
) -> syn::Result<()> {
    let parsed = field::Attributes::parse(&field.attrs)?;

    generics
        .overrides
        .extend(parsed.collect_bounds(BoundType::Deserialize));
    let needs_bounds_derive = parsed.needs_bounds_derive(BoundType::Deserialize);

    let field_name = field.ident.as_ref();
    let delta = if parsed.skip {
        if needs_bounds_derive {
            generics.default_visitor.visit_field(field);
        }
        field_default_output(field_name)
    } else {
        if needs_bounds_derive {
            generics.deserialize_visitor.visit_field(field);
        }
        field_output(field_name, cratename, parsed.deserialize_with)
    };
    body.extend(delta);
    Ok(())
}

/// function which computes derive output [proc_macro2::TokenStream]
/// of code, which deserializes single field
fn field_output(
    field_name: Option<&Ident>,
    cratename: &Path,
    deserialize_with: Option<ExprPath>,
) -> TokenStream2 {
    let default_path: ExprPath =
        syn::parse2(quote! { #cratename::BorshDeserialize::deserialize_reader }).unwrap();
    let path: ExprPath = deserialize_with.unwrap_or(default_path);
    if let Some(field_name) = field_name {
        quote! {
            #field_name: #path(reader)?,
        }
    } else {
        quote! {
            #path(reader)?,
        }
    }
}

/// function which computes derive output [proc_macro2::TokenStream]
/// of code, which deserializes single skipped field
fn field_default_output(field_name: Option<&Ident>) -> TokenStream2 {
    if let Some(field_name) = field_name {
        quote! {
            #field_name: core::default::Default::default(),
        }
    } else {
        quote! { core::default::Default::default(), }
    }
}

'''
'''--- borsh-derive/src/internals/deserialize/structs/mod.rs ---
use proc_macro2::TokenStream as TokenStream2;
use quote::quote;
use syn::{Fields, ItemStruct, Path};

use crate::internals::{attributes::item, deserialize, generics};

pub fn process(input: &ItemStruct, cratename: Path) -> syn::Result<TokenStream2> {
    let name = &input.ident;
    let generics = generics::without_defaults(&input.generics);
    let (impl_generics, ty_generics, where_clause) = generics.split_for_impl();
    let mut where_clause = generics::default_where(where_clause);
    let mut body = TokenStream2::new();
    let mut generics_output = deserialize::GenericsOutput::new(&generics);

    let return_value = match &input.fields {
        Fields::Named(fields) => {
            for field in &fields.named {
                deserialize::process_field(field, &cratename, &mut body, &mut generics_output)?;
            }
            quote! {
                Self { #body }
            }
        }
        Fields::Unnamed(fields) => {
            for field in fields.unnamed.iter() {
                deserialize::process_field(field, &cratename, &mut body, &mut generics_output)?;
            }
            quote! {
                Self( #body )
            }
        }
        Fields::Unit => {
            quote! {
                Self {}
            }
        }
    };
    generics_output.extend(&mut where_clause, &cratename);

    if let Some(method_ident) = item::contains_initialize_with(&input.attrs)? {
        Ok(quote! {
            impl #impl_generics #cratename::de::BorshDeserialize for #name #ty_generics #where_clause {
                fn deserialize_reader<__R: #cratename::io::Read>(reader: &mut __R) -> ::core::result::Result<Self, #cratename::io::Error> {
                    let mut return_value = #return_value;
                    return_value.#method_ident();
                    Ok(return_value)
                }
            }
        })
    } else {
        Ok(quote! {
            impl #impl_generics #cratename::de::BorshDeserialize for #name #ty_generics #where_clause {
                fn deserialize_reader<__R: #cratename::io::Read>(reader: &mut __R) -> ::core::result::Result<Self, #cratename::io::Error> {
                    Ok(#return_value)
                }
            }
        })
    }
}

#[cfg(test)]
mod tests {
    use crate::internals::test_helpers::{
        default_cratename, local_insta_assert_snapshot, pretty_print_syn_str,
    };

    use super::*;

    #[test]
    fn simple_struct() {
        let item_struct: ItemStruct = syn::parse2(quote! {
            struct A {
                x: u64,
                y: String,
            }
        })
        .unwrap();

        let actual = process(&item_struct, default_cratename()).unwrap();

        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn simple_struct_with_custom_crate() {
        let item_struct: ItemStruct = syn::parse2(quote! {
            struct A {
                x: u64,
                y: String,
            }
        })
        .unwrap();

        let crate_: Path = syn::parse2(quote! { reexporter::borsh }).unwrap();
        let actual = process(&item_struct, crate_).unwrap();

        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn simple_generics() {
        let item_struct: ItemStruct = syn::parse2(quote! {
            struct A<K, V> {
                x: HashMap<K, V>,
                y: String,
            }
        })
        .unwrap();

        let actual = process(&item_struct, default_cratename()).unwrap();
        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn simple_generic_tuple_struct() {
        let item_struct: ItemStruct = syn::parse2(quote! {
            struct TupleA<T>(T, u32);
        })
        .unwrap();

        let actual = process(&item_struct, default_cratename()).unwrap();
        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn bound_generics() {
        let item_struct: ItemStruct = syn::parse2(quote! {
            struct A<K: Key, V> where V: Value {
                x: HashMap<K, V>,
                y: String,
            }
        })
        .unwrap();

        let actual = process(&item_struct, default_cratename()).unwrap();
        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn recursive_struct() {
        let item_struct: ItemStruct = syn::parse2(quote! {
            struct CRecC {
                a: String,
                b: HashMap<String, CRecC>,
            }
        })
        .unwrap();

        let actual = process(&item_struct, default_cratename()).unwrap();

        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn generic_tuple_struct_borsh_skip1() {
        let item_struct: ItemStruct = syn::parse2(quote! {
            struct G<K, V, U> (
                #[borsh(skip)]
                HashMap<K, V>,
                U,
            );
        })
        .unwrap();

        let actual = process(&item_struct, default_cratename()).unwrap();

        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn generic_tuple_struct_borsh_skip2() {
        let item_struct: ItemStruct = syn::parse2(quote! {
            struct G<K, V, U> (
                HashMap<K, V>,
                #[borsh(skip)]
                U,
            );
        })
        .unwrap();

        let actual = process(&item_struct, default_cratename()).unwrap();

        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn generic_named_fields_struct_borsh_skip() {
        let item_struct: ItemStruct = syn::parse2(quote! {
            struct G<K, V, U> {
                #[borsh(skip)]
                x: HashMap<K, V>,
                y: U,
            }
        })
        .unwrap();

        let actual = process(&item_struct, default_cratename()).unwrap();

        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn generic_deserialize_bound() {
        let item_struct: ItemStruct = syn::parse2(quote! {
            struct C<T: Debug, U> {
                a: String,
                #[borsh(bound(deserialize =
                    "T: PartialOrd + Hash + Eq + borsh::de::BorshDeserialize,
                     U: borsh::de::BorshDeserialize"
                ))]
                b: HashMap<T, U>,
            }
        })
        .unwrap();

        let actual = process(&item_struct, default_cratename()).unwrap();

        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn test_override_automatically_added_default_trait() {
        let item_struct: ItemStruct = syn::parse2(quote! {
              struct G1<K, V, U>(
                #[borsh(skip,bound(deserialize = ""))]
                HashMap<K, V>,
                U
            );
        })
        .unwrap();

        let actual = process(&item_struct, default_cratename()).unwrap();

        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn check_deserialize_with_attr() {
        let item_struct: ItemStruct = syn::parse2(quote! {
            struct A<K: Ord, V> {
                #[borsh(deserialize_with = "third_party_impl::deserialize_third_party")]
                x: ThirdParty<K, V>,
                y: u64,
            }
        })
        .unwrap();

        let actual = process(&item_struct, default_cratename()).unwrap();

        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }
    #[test]
    fn borsh_init_func() {
        let item_enum: ItemStruct = syn::parse2(quote! {
            #[borsh(init=initialization_method)]
            struct A {
                x: u64,
                y: String,
            }
        })
        .unwrap();
        let actual = process(&item_enum, default_cratename()).unwrap();
        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }
}

'''
'''--- borsh-derive/src/internals/deserialize/unions/mod.rs ---
use proc_macro2::TokenStream as TokenStream2;
use syn::{ItemUnion, Path};

pub fn process(_input: &ItemUnion, _cratename: Path) -> syn::Result<TokenStream2> {
    unimplemented!()
}

'''
'''--- borsh-derive/src/internals/enum_discriminant.rs ---
use std::collections::HashMap;
use std::convert::TryFrom;

use proc_macro2::{Ident, TokenStream};
use quote::quote;
use syn::{punctuated::Punctuated, token::Comma, Variant};

pub struct Discriminants(HashMap<Ident, TokenStream>);
impl Discriminants {
    /// Calculates the discriminant that will be assigned by the compiler.
    /// See: https://doc.rust-lang.org/reference/items/enumerations.html#assigning-discriminant-values
    pub fn new(variants: &Punctuated<Variant, Comma>) -> Self {
        let mut map = HashMap::new();
        let mut next_discriminant_if_not_specified = quote! {0};

        for variant in variants {
            let this_discriminant = variant.discriminant.clone().map_or_else(
                || quote! { #next_discriminant_if_not_specified },
                |(_, e)| quote! { #e },
            );

            next_discriminant_if_not_specified = quote! { #this_discriminant + 1 };
            map.insert(variant.ident.clone(), this_discriminant);
        }

        Self(map)
    }

    pub fn get(
        &self,
        variant_ident: &Ident,
        use_discriminant: bool,
        variant_idx: usize,
    ) -> syn::Result<TokenStream> {
        let variant_idx = u8::try_from(variant_idx).map_err(|err| {
            syn::Error::new(
                variant_ident.span(),
                format!("up to 256 enum variants are supported: {}", err),
            )
        })?;
        let result = if use_discriminant {
            let discriminant_value = self.0.get(variant_ident).unwrap();
            quote! { #discriminant_value }
        } else {
            quote! { #variant_idx }
        };
        Ok(result)
    }
}

'''
'''--- borsh-derive/src/internals/generics.rs ---
use std::collections::{HashMap, HashSet};

use quote::{quote, ToTokens};
use syn::{
    punctuated::Pair, Field, GenericArgument, Generics, Ident, Macro, Path, PathArguments,
    PathSegment, ReturnType, Type, TypeParamBound, TypePath, WhereClause, WherePredicate,
};

pub fn default_where(where_clause: Option<&WhereClause>) -> WhereClause {
    where_clause.map_or_else(
        || WhereClause {
            where_token: Default::default(),
            predicates: Default::default(),
        },
        Clone::clone,
    )
}

pub fn compute_predicates(params: Vec<Type>, traitname: &Path) -> Vec<WherePredicate> {
    params
        .into_iter()
        .map(|param| {
            syn::parse2(quote! {
                #param: #traitname
            })
            .unwrap()
        })
        .collect()
}

// Remove the default from every type parameter because in the generated impls
// they look like associated types: "error: associated type bindings are not
// allowed here".
pub fn without_defaults(generics: &Generics) -> Generics {
    syn::Generics {
        params: generics
            .params
            .iter()
            .map(|param| match param {
                syn::GenericParam::Type(param) => syn::GenericParam::Type(syn::TypeParam {
                    eq_token: None,
                    default: None,
                    ..param.clone()
                }),
                _ => param.clone(),
            })
            .collect(),
        ..generics.clone()
    }
}

#[cfg(feature = "schema")]
pub fn type_contains_some_param(type_: &Type, params: &HashSet<Ident>) -> bool {
    let mut find: FindTyParams = FindTyParams::from_params(params.iter());

    find.visit_type_top_level(type_);

    find.at_least_one_hit()
}

/// a Visitor-like struct, which helps determine, if a type parameter is found in field
#[derive(Clone)]
pub struct FindTyParams {
    // Set of all generic type parameters on the current struct . Initialized up front.
    all_type_params: HashSet<Ident>,
    all_type_params_ordered: Vec<Ident>,

    // Set of generic type parameters used in fields for which filter
    // returns true . Filled in as the visitor sees them.
    relevant_type_params: HashSet<Ident>,

    // [Param] => [Type, containing Param] mapping
    associated_type_params_usage: HashMap<Ident, Vec<Type>>,
}

fn ungroup(mut ty: &Type) -> &Type {
    while let Type::Group(group) = ty {
        ty = &group.elem;
    }
    ty
}

impl FindTyParams {
    pub fn new(generics: &Generics) -> Self {
        let all_type_params = generics
            .type_params()
            .map(|param| param.ident.clone())
            .collect();

        let all_type_params_ordered = generics
            .type_params()
            .map(|param| param.ident.clone())
            .collect();

        FindTyParams {
            all_type_params,
            all_type_params_ordered,
            relevant_type_params: HashSet::new(),
            associated_type_params_usage: HashMap::new(),
        }
    }
    pub fn process_for_bounds(self) -> Vec<Type> {
        let relevant_type_params = self.relevant_type_params;
        let associated_type_params_usage = self.associated_type_params_usage;
        let mut new_predicates: Vec<Type> = vec![];
        let mut new_predicates_set: HashSet<String> = HashSet::new();

        self.all_type_params_ordered.iter().for_each(|param| {
            if relevant_type_params.contains(param) {
                let ty = Type::Path(TypePath {
                    qself: None,
                    path: param.clone().into(),
                });
                let ty_str_repr = ty.to_token_stream().to_string();
                if !new_predicates_set.contains(&ty_str_repr) {
                    new_predicates.push(ty);
                    new_predicates_set.insert(ty_str_repr);
                }
            }
            if let Some(vec_type) = associated_type_params_usage.get(param) {
                for type_ in vec_type {
                    let ty_str_repr = type_.to_token_stream().to_string();
                    if !new_predicates_set.contains(&ty_str_repr) {
                        new_predicates.push(type_.clone());
                        new_predicates_set.insert(ty_str_repr);
                    }
                }
            }
        });

        new_predicates
    }
}

#[cfg(feature = "schema")]
impl FindTyParams {
    pub fn from_params<'a>(params: impl Iterator<Item = &'a Ident>) -> Self {
        let all_type_params_ordered: Vec<Ident> = params.cloned().collect();
        let all_type_params = all_type_params_ordered.clone().into_iter().collect();
        FindTyParams {
            all_type_params,
            all_type_params_ordered,
            relevant_type_params: HashSet::new(),
            associated_type_params_usage: HashMap::new(),
        }
    }

    pub fn process_for_params(self) -> Vec<Ident> {
        let relevant_type_params = self.relevant_type_params;
        let associated_type_params_usage = self.associated_type_params_usage;

        let mut params: Vec<Ident> = vec![];
        let mut params_set: HashSet<Ident> = HashSet::new();
        self.all_type_params_ordered.iter().for_each(|param| {
            if relevant_type_params.contains(param) && !params_set.contains(param) {
                params.push(param.clone());
                params_set.insert(param.clone());
            }
            if associated_type_params_usage.get(param).is_some() && !params_set.contains(param) {
                params.push(param.clone());
                params_set.insert(param.clone());
            }
        });
        params
    }
    pub fn at_least_one_hit(&self) -> bool {
        !self.relevant_type_params.is_empty() || !self.associated_type_params_usage.is_empty()
    }
}

impl FindTyParams {
    pub fn visit_field(&mut self, field: &Field) {
        self.visit_type_top_level(&field.ty);
    }

    pub fn visit_type_top_level(&mut self, type_: &Type) {
        if let Type::Path(ty) = ungroup(type_) {
            if let Some(Pair::Punctuated(t, _)) = ty.path.segments.pairs().next() {
                if self.all_type_params.contains(&t.ident) {
                    self.param_associated_type_insert(t.ident.clone(), type_.clone());
                }
            }
        }
        self.visit_type(type_);
    }

    pub fn param_associated_type_insert(&mut self, param: Ident, type_: Type) {
        if let Some(type_vec) = self.associated_type_params_usage.get_mut(&param) {
            type_vec.push(type_);
        } else {
            let type_vec = vec![type_];
            self.associated_type_params_usage.insert(param, type_vec);
        }
    }

    fn visit_return_type(&mut self, return_type: &ReturnType) {
        match return_type {
            ReturnType::Default => {}
            ReturnType::Type(_, output) => self.visit_type(output),
        }
    }

    fn visit_path_segment(&mut self, segment: &PathSegment) {
        self.visit_path_arguments(&segment.arguments);
    }

    fn visit_path_arguments(&mut self, arguments: &PathArguments) {
        match arguments {
            PathArguments::None => {}
            PathArguments::AngleBracketed(arguments) => {
                for arg in &arguments.args {
                    #[cfg_attr(
                        feature = "force_exhaustive_checks",
                        deny(non_exhaustive_omitted_patterns)
                    )]
                    match arg {
                        GenericArgument::Type(arg) => self.visit_type(arg),
                        GenericArgument::AssocType(arg) => self.visit_type(&arg.ty),
                        GenericArgument::Lifetime(_)
                        | GenericArgument::Const(_)
                        | GenericArgument::AssocConst(_)
                        | GenericArgument::Constraint(_) => {}
                        _ => {}
                    }
                }
            }
            PathArguments::Parenthesized(arguments) => {
                for argument in &arguments.inputs {
                    self.visit_type(argument);
                }
                self.visit_return_type(&arguments.output);
            }
        }
    }

    fn visit_path(&mut self, path: &Path) {
        if let Some(seg) = path.segments.last() {
            if seg.ident == "PhantomData" {
                // Hardcoded exception, because PhantomData<T> implements
                // Serialize and Deserialize and Schema whether or not T implements it.
                return;
            }
        }
        if path.leading_colon.is_none() && path.segments.len() == 1 {
            let id = &path.segments[0].ident;
            if self.all_type_params.contains(id) {
                self.relevant_type_params.insert(id.clone());
            }
        }
        for segment in &path.segments {
            self.visit_path_segment(segment);
        }
    }

    fn visit_type_param_bound(&mut self, bound: &TypeParamBound) {
        #[cfg_attr(
            feature = "force_exhaustive_checks",
            deny(non_exhaustive_omitted_patterns)
        )]
        match bound {
            TypeParamBound::Trait(bound) => self.visit_path(&bound.path),
            TypeParamBound::Lifetime(_) | TypeParamBound::Verbatim(_) => {}
            _ => {}
        }
    }
    // Type parameter should not be considered used by a macro path.
    //
    //     struct TypeMacro<T> {
    //         mac: T!(),
    //         marker: PhantomData<T>,
    //     }
    fn visit_macro(&mut self, _mac: &Macro) {}

    fn visit_type(&mut self, ty: &Type) {
        #[cfg_attr(
            feature = "force_exhaustive_checks",
            deny(non_exhaustive_omitted_patterns)
        )]
        match ty {
            Type::Array(ty) => self.visit_type(&ty.elem),
            Type::BareFn(ty) => {
                for arg in &ty.inputs {
                    self.visit_type(&arg.ty);
                }
                self.visit_return_type(&ty.output);
            }
            Type::Group(ty) => self.visit_type(&ty.elem),
            Type::ImplTrait(ty) => {
                for bound in &ty.bounds {
                    self.visit_type_param_bound(bound);
                }
            }
            Type::Macro(ty) => self.visit_macro(&ty.mac),
            Type::Paren(ty) => self.visit_type(&ty.elem),
            Type::Path(ty) => {
                if let Some(qself) = &ty.qself {
                    self.visit_type(&qself.ty);
                }
                self.visit_path(&ty.path);
            }
            Type::Ptr(ty) => self.visit_type(&ty.elem),
            Type::Reference(ty) => self.visit_type(&ty.elem),
            Type::Slice(ty) => self.visit_type(&ty.elem),
            Type::TraitObject(ty) => {
                for bound in &ty.bounds {
                    self.visit_type_param_bound(bound);
                }
            }
            Type::Tuple(ty) => {
                for elem in &ty.elems {
                    self.visit_type(elem);
                }
            }

            Type::Infer(_) | Type::Never(_) | Type::Verbatim(_) => {}

            _ => {}
        }
    }
}

'''
'''--- borsh-derive/src/internals/mod.rs ---
pub mod attributes;
pub mod deserialize;
mod enum_discriminant;
mod generics;
#[cfg(feature = "schema")]
pub mod schema;
pub mod serialize;

pub mod cratename;

#[cfg(test)]
mod test_helpers;

'''
'''--- borsh-derive/src/internals/schema/enums/mod.rs ---
use proc_macro2::{Span, TokenStream as TokenStream2};
use quote::{quote, ToTokens};
use std::collections::HashSet;
use syn::{Fields, Generics, Ident, ItemEnum, ItemStruct, Path, Variant, Visibility};

use crate::internals::{
    attributes::{field, item},
    enum_discriminant::Discriminants,
    generics, schema,
};

fn transform_variant_fields(mut input: Fields) -> Fields {
    match input {
        Fields::Named(ref mut named) => {
            for field in &mut named.named {
                let field_attrs = field::filter_attrs(field.attrs.drain(..)).collect::<Vec<_>>();
                field.attrs = field_attrs;
            }
        }
        Fields::Unnamed(ref mut unnamed) => {
            for field in &mut unnamed.unnamed {
                let field_attrs = field::filter_attrs(field.attrs.drain(..)).collect::<Vec<_>>();
                field.attrs = field_attrs;
            }
        }
        _ => {}
    }
    input
}

pub fn process(input: &ItemEnum, cratename: Path) -> syn::Result<TokenStream2> {
    let name = &input.ident;
    let enum_name = name.to_token_stream().to_string();
    let generics = generics::without_defaults(&input.generics);
    let (impl_generics, ty_generics, where_clause) = generics.split_for_impl();
    let mut where_clause = generics::default_where(where_clause);
    let mut generics_output = schema::GenericsOutput::new(&generics);
    let use_discriminant = item::contains_use_discriminant(input)?;
    let discriminants = Discriminants::new(&input.variants);

    // Generate functions that return the schema for variants.
    let mut variants_defs = vec![];
    let mut inner_defs = TokenStream2::new();
    let mut add_recursive_defs = TokenStream2::new();
    for (variant_idx, variant) in input.variants.iter().enumerate() {
        let discriminant_info = DiscriminantInfo {
            variant_idx,
            discriminants: &discriminants,
            use_discriminant,
        };
        let variant_output = process_variant(
            variant,
            discriminant_info,
            &cratename,
            &enum_name,
            &generics,
            &mut generics_output,
        )?;
        inner_defs.extend(variant_output.inner_struct);
        add_recursive_defs.extend(variant_output.add_definitions_recursively_call);
        variants_defs.push(variant_output.variant_entry);
    }

    let type_definitions = quote! {
        fn add_definitions_recursively(definitions: &mut #cratename::__private::maybestd::collections::BTreeMap<#cratename::schema::Declaration, #cratename::schema::Definition>) {
            #inner_defs
            #add_recursive_defs
            let definition = #cratename::schema::Definition::Enum {
                tag_width: 1,
                variants: #cratename::__private::maybestd::vec![#(#variants_defs),*],
            };
            #cratename::schema::add_definition(<Self as #cratename::BorshSchema>::declaration(), definition, definitions);
        }
    };

    let (predicates, declaration) = generics_output.result(&enum_name, &cratename);
    where_clause.predicates.extend(predicates);
    Ok(quote! {
        impl #impl_generics #cratename::BorshSchema for #name #ty_generics #where_clause {
            fn declaration() -> #cratename::schema::Declaration {
                #declaration
            }
            #type_definitions
        }
    })
}

struct VariantOutput {
    /// rust definition of the inner struct used in variant.
    inner_struct: TokenStream2,
    /// call to `add_definitions_recursively`.
    add_definitions_recursively_call: TokenStream2,
    /// entry with a variant's declaration, element in vector of whole enum's definition
    variant_entry: TokenStream2,
}

struct DiscriminantInfo<'a> {
    variant_idx: usize,
    discriminants: &'a Discriminants,
    use_discriminant: bool,
}

fn process_discriminant(
    variant_ident: &Ident,
    info: DiscriminantInfo<'_>,
) -> syn::Result<TokenStream2> {
    info.discriminants
        .get(variant_ident, info.use_discriminant, info.variant_idx)
}

fn process_variant(
    variant: &Variant,
    discriminant_info: DiscriminantInfo,
    cratename: &Path,
    enum_name: &str,
    enum_generics: &Generics,
    generics_output: &mut schema::GenericsOutput,
) -> syn::Result<VariantOutput> {
    let variant_name = variant.ident.to_token_stream().to_string();
    let full_variant_name = format!("{}{}", enum_name, variant_name);
    let full_variant_ident = Ident::new(&full_variant_name, Span::call_site());

    schema::visit_struct_fields(&variant.fields, &mut generics_output.params_visitor)?;
    let (inner_struct, inner_struct_generics) =
        inner_struct_definition(variant, cratename, &full_variant_ident, enum_generics);
    let (_ig, inner_struct_ty_generics, _wc) = inner_struct_generics.split_for_impl();

    let variant_type = quote! {
        <#full_variant_ident #inner_struct_ty_generics as #cratename::BorshSchema>
    };
    let discriminant_value = process_discriminant(&variant.ident, discriminant_info)?;

    Ok(VariantOutput {
        inner_struct,
        add_definitions_recursively_call: quote! {
            #variant_type::add_definitions_recursively(definitions);
        },
        variant_entry: quote! {
            (u8::from(#discriminant_value) as i64,
             #variant_name.into(),
             #variant_type::declaration())
        },
    })
}

fn inner_struct_definition(
    variant: &Variant,
    cratename: &Path,
    inner_struct_ident: &Ident,
    enum_generics: &Generics,
) -> (TokenStream2, Generics) {
    let transformed_fields = transform_variant_fields(variant.fields.clone());

    let mut variant_schema_params_visitor = generics::FindTyParams::new(enum_generics);
    schema::visit_struct_fields_unconditional(&variant.fields, &mut variant_schema_params_visitor);
    let variant_not_skipped_params = variant_schema_params_visitor
        .process_for_params()
        .into_iter()
        .collect::<HashSet<_>>();
    let inner_struct_generics =
        schema::filter_used_params(enum_generics, variant_not_skipped_params);

    let inner_struct = ItemStruct {
        attrs: vec![],
        vis: Visibility::Inherited,
        struct_token: Default::default(),
        ident: inner_struct_ident.clone(),
        generics: inner_struct_generics.clone(),
        fields: transformed_fields,
        semi_token: Some(Default::default()),
    };
    let crate_str = syn::LitStr::new(&cratename.to_token_stream().to_string(), Span::call_site());
    let inner_struct = quote! {
        #[allow(dead_code)]
        #[derive(#cratename::BorshSchema)]
        #[borsh(crate = #crate_str)]
        #inner_struct
    };
    (inner_struct, inner_struct_generics)
}

#[cfg(test)]
mod tests {
    use crate::internals::test_helpers::{
        default_cratename, local_insta_assert_debug_snapshot, local_insta_assert_snapshot,
        pretty_print_syn_str,
    };

    use super::*;

    #[test]
    fn simple_enum() {
        let item_enum: ItemEnum = syn::parse2(quote! {
            enum A {
                Bacon,
                Eggs
            }
        })
        .unwrap();

        let actual = process(&item_enum, default_cratename()).unwrap();

        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn simple_enum_with_custom_crate() {
        let item_enum: ItemEnum = syn::parse2(quote! {
            enum A {
                Bacon,
                Eggs
            }
        })
        .unwrap();

        let crate_: Path = syn::parse2(quote! { reexporter::borsh }).unwrap();
        let actual = process(&item_enum, crate_).unwrap();

        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn borsh_discriminant_false() {
        let item_enum: ItemEnum = syn::parse2(quote! {
           #[borsh(use_discriminant = false)]
            enum X {
                A,
                B = 20,
                C,
                D,
                E = 10,
                F,
            }
        })
        .unwrap();
        let actual = process(&item_enum, default_cratename()).unwrap();

        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }
    #[test]
    fn borsh_discriminant_true() {
        let item_enum: ItemEnum = syn::parse2(quote! {
            #[borsh(use_discriminant = true)]
            enum X {
                A,
                B = 20,
                C,
                D,
                E = 10,
                F,
            }
        })
        .unwrap();
        let actual = process(&item_enum, default_cratename()).unwrap();

        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn single_field_enum() {
        let item_enum: ItemEnum = syn::parse2(quote! {
            enum A {
                Bacon,
            }
        })
        .unwrap();

        let actual = process(&item_enum, default_cratename()).unwrap();
        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn complex_enum() {
        let item_enum: ItemEnum = syn::parse2(quote! {
            enum A {
                Bacon,
                Eggs,
                Salad(Tomatoes, Cucumber, Oil),
                Sausage{wrapper: Wrapper, filling: Filling},
            }
        })
        .unwrap();

        let actual = process(&item_enum, default_cratename()).unwrap();
        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn complex_enum_generics() {
        let item_enum: ItemEnum = syn::parse2(quote! {
            enum A<C, W> {
                Bacon,
                Eggs,
                Salad(Tomatoes, C, Oil),
                Sausage{wrapper: W, filling: Filling},
            }
        })
        .unwrap();

        let actual = process(&item_enum, default_cratename()).unwrap();
        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn trailing_comma_generics() {
        let item_struct: ItemEnum = syn::parse2(quote! {
            enum Side<B, A>
            where
                A: Display + Debug,
                B: Display + Debug,
            {
                Left(A),
                Right(B),
            }
        })
        .unwrap();

        let actual = process(&item_struct, default_cratename()).unwrap();
        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn test_filter_foreign_attrs() {
        let item_struct: ItemEnum = syn::parse2(quote! {
            enum A {
                #[serde(rename = "ab")]
                B {
                    #[serde(rename = "abc")]
                    c: i32,
                    #[borsh(skip)]
                    d: u32,
                    l: u64,
                },
                Negative {
                    beta: String,
                }
            }
        })
        .unwrap();

        let actual = process(&item_struct, default_cratename()).unwrap();

        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn complex_enum_generics_borsh_skip_tuple_field() {
        let item_enum: ItemEnum = syn::parse2(quote! {
            enum A<C: Eq, W> where W: Hash {
                Bacon,
                Eggs,
                Salad(Tomatoes, #[borsh(skip)] C, Oil),
                Sausage{wrapper: W, filling: Filling},
            }
        })
        .unwrap();

        let actual = process(&item_enum, default_cratename()).unwrap();
        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn complex_enum_generics_borsh_skip_named_field() {
        let item_enum: ItemEnum = syn::parse2(quote! {
            enum A<W, U, C> {
                Bacon,
                Eggs,
                Salad(Tomatoes, C, Oil),
                Sausage{
                    #[borsh(skip)]
                    wrapper: W,
                    filling: Filling,
                    unexpected: U,
                },
            }
        })
        .unwrap();

        let actual = process(&item_enum, default_cratename()).unwrap();
        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn recursive_enum() {
        let item_struct: ItemEnum = syn::parse2(quote! {
            enum A<K: Key, V> where V: Value {
                B {
                    x: HashMap<K, V>,
                    y: String,
                },
                C(K, Vec<A>),
            }
        })
        .unwrap();

        let actual = process(&item_struct, default_cratename()).unwrap();

        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn generic_associated_type() {
        let item_struct: ItemEnum = syn::parse2(quote! {
            enum EnumParametrized<T, K, V>
            where
                K: TraitName,
                K: core::cmp::Ord,
                V: core::cmp::Ord,
                T: Eq + Hash,
            {
                B {
                    x: BTreeMap<K, V>,
                    y: String,
                    z: K::Associated,
                },
                C(T, u16),
            }
        })
        .unwrap();

        let actual = process(&item_struct, default_cratename()).unwrap();

        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }
    #[test]
    fn generic_associated_type_param_override() {
        let item_struct: ItemEnum = syn::parse2(quote! {
            enum EnumParametrized<T, K, V>
            where
                K: TraitName,
                K: core::cmp::Ord,
                V: core::cmp::Ord,
                T: Eq + Hash,
            {
                B {
                    x: BTreeMap<K, V>,
                    y: String,
                    #[borsh(schema(params = "K => <K as TraitName>::Associated"))]
                    z: <K as TraitName>::Associated,
                },
                C(T, u16),
            }
        })
        .unwrap();

        let actual = process(&item_struct, default_cratename()).unwrap();

        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn generic_associated_type_param_override_conflict() {
        let item_struct: ItemEnum = syn::parse2(quote! {
            enum EnumParametrized<T, K, V>
            where
                K: TraitName,
            {
                B {
                    x: Vec<V>,
                    #[borsh(skip,schema(params = "K => <K as TraitName>::Associated"))]
                    z: <K as TraitName>::Associated,
                },
                C(T, u16),
            }
        })
        .unwrap();

        let actual = process(&item_struct, default_cratename());

        local_insta_assert_debug_snapshot!(actual.unwrap_err());
    }

    #[test]
    fn check_with_funcs_skip_conflict() {
        let item_struct: ItemEnum = syn::parse2(quote! {
            enum C<K, V> {
                C3(u64, u64),
                C4(
                    u64,
                    #[borsh(skip,schema(with_funcs(
                        declaration = "third_party_impl::declaration::<K, V>",
                        definitions = "third_party_impl::add_definitions_recursively::<K, V>"
                    )))]
                    ThirdParty<K, V>,
                ),
            }
        })
        .unwrap();

        let actual = process(&item_struct, default_cratename());

        local_insta_assert_debug_snapshot!(actual.unwrap_err());
    }

    #[test]
    fn with_funcs_attr() {
        let item_struct: ItemEnum = syn::parse2(quote! {
            enum C<K, V> {
                C3(u64, u64),
                C4(
                    u64,
                    #[borsh(schema(with_funcs(
                        declaration = "third_party_impl::declaration::<K, V>",
                        definitions = "third_party_impl::add_definitions_recursively::<K, V>"
                    )))]
                    ThirdParty<K, V>,
                ),
            }
        })
        .unwrap();

        let actual = process(&item_struct, default_cratename()).unwrap();

        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }
}

'''
'''--- borsh-derive/src/internals/schema/mod.rs ---
use std::collections::HashSet;

use proc_macro2::TokenStream as TokenStream2;
use quote::quote;
use syn::{
    punctuated::Punctuated, token::Comma, Field, Fields, GenericParam, Generics, Ident, Path, Type,
    WherePredicate,
};

use crate::internals::{attributes::field, generics};

pub mod enums;
pub mod structs;

struct GenericsOutput {
    params_visitor: generics::FindTyParams,
}

impl GenericsOutput {
    fn new(generics: &Generics) -> Self {
        Self {
            params_visitor: generics::FindTyParams::new(generics),
        }
    }
    fn result(self, item_name: &str, cratename: &Path) -> (Vec<WherePredicate>, TokenStream2) {
        let trait_path: Path = syn::parse2(quote! { #cratename::BorshSchema }).unwrap();
        let predicates = generics::compute_predicates(
            self.params_visitor.clone().process_for_bounds(),
            &trait_path,
        );
        // Generate function that returns the name of the type.
        let declaration = declaration(
            item_name,
            cratename.clone(),
            self.params_visitor.process_for_bounds(),
        );

        (predicates, declaration)
    }
}

fn declaration(ident_str: &str, cratename: Path, params_for_bounds: Vec<Type>) -> TokenStream2 {
    // Generate function that returns the name of the type.
    let mut declaration_params = vec![];
    for type_param in params_for_bounds {
        declaration_params.push(quote! {
            <#type_param as #cratename::BorshSchema>::declaration()
        });
    }
    if declaration_params.is_empty() {
        quote! {
                #ident_str.to_string()
        }
    } else {
        quote! {
                let params = #cratename::__private::maybestd::vec![#(#declaration_params),*];
                format!(r#"{}<{}>"#, #ident_str, params.join(", "))
        }
    }
}

fn filter_used_params(generics: &Generics, not_skipped_type_params: HashSet<Ident>) -> Generics {
    let new_params = generics
        .params
        .clone()
        .into_iter()
        .filter(|param| match param {
            GenericParam::Lifetime(..) | GenericParam::Const(..) => true,
            GenericParam::Type(ty_param) => not_skipped_type_params.contains(&ty_param.ident),
        })
        .collect();

    let mut where_clause = generics.where_clause.clone();
    where_clause = where_clause.map(|mut clause| {
        let new_predicates: Punctuated<WherePredicate, Comma> = clause
            .predicates
            .iter()
            .filter(|predicate| match predicate {
                WherePredicate::Lifetime(..) => true,
                WherePredicate::Type(predicate_type) => generics::type_contains_some_param(
                    &predicate_type.bounded_ty,
                    &not_skipped_type_params,
                ),
                #[cfg_attr(
                    feature = "force_exhaustive_checks",
                    deny(non_exhaustive_omitted_patterns)
                )]
                _ => true,
            })
            .cloned()
            .collect();
        clause.predicates = new_predicates;
        clause
    });
    Generics {
        params: new_params,
        where_clause,
        ..generics.clone()
    }
}

fn visit_field(field: &Field, visitor: &mut generics::FindTyParams) -> syn::Result<()> {
    let parsed = field::Attributes::parse(&field.attrs)?;
    let needs_schema_params_derive = parsed.needs_schema_params_derive();
    let schema_attrs = parsed.schema;
    if !parsed.skip {
        if needs_schema_params_derive {
            visitor.visit_field(field);
        }
        // there's no need to override params when field is skipped, because when field is skipped
        // derive for it doesn't attempt to add any bounds, unlike `BorshDeserialize`, which
        // adds `Default` bound on any type parameters in skipped field

        if let Some(schema_attrs) = schema_attrs {
            if let Some(schema_params) = schema_attrs.params {
                for field::schema::ParameterOverride {
                    order_param,
                    override_type,
                    ..
                } in schema_params
                {
                    visitor.param_associated_type_insert(order_param, override_type);
                }
            }
        }
    }
    Ok(())
}

/// check param usage in fields with respect to `borsh(skip)` attribute usage
fn visit_struct_fields(fields: &Fields, visitor: &mut generics::FindTyParams) -> syn::Result<()> {
    match &fields {
        Fields::Named(fields) => {
            for field in &fields.named {
                visit_field(field, visitor)?;
            }
        }
        Fields::Unnamed(fields) => {
            for field in &fields.unnamed {
                visit_field(field, visitor)?;
            }
        }
        Fields::Unit => {}
    }
    Ok(())
}

/// check param usage in fields
fn visit_struct_fields_unconditional(fields: &Fields, visitor: &mut generics::FindTyParams) {
    match &fields {
        Fields::Named(fields) => {
            for field in &fields.named {
                visitor.visit_field(field);
            }
        }
        Fields::Unnamed(fields) => {
            for field in &fields.unnamed {
                visitor.visit_field(field);
            }
        }
        Fields::Unit => {}
    }
}

'''
'''--- borsh-derive/src/internals/schema/structs/mod.rs ---
use proc_macro2::TokenStream as TokenStream2;
use quote::{quote, ToTokens};
use syn::{ExprPath, Fields, Ident, ItemStruct, Path, Type};

use crate::internals::{attributes::field, generics, schema};

/// function which computes derive output [proc_macro2::TokenStream]
/// of code, which computes declaration of a single field, which is later added to
/// the struct's definition as a whole  
fn field_declaration_output(
    field_name: Option<&Ident>,
    field_type: &Type,
    cratename: &Path,
    declaration_override: Option<ExprPath>,
) -> TokenStream2 {
    let default_path: ExprPath =
        syn::parse2(quote! { <#field_type as #cratename::BorshSchema>::declaration }).unwrap();

    let path = declaration_override.unwrap_or(default_path);

    if let Some(field_name) = field_name {
        let field_name = field_name.to_token_stream().to_string();
        quote! {
            (#field_name.to_string(), #path())
        }
    } else {
        quote! {
            #path()
        }
    }
}

/// function which computes derive output [proc_macro2::TokenStream]
/// of code, which adds definitions of a field to the output `definitions: &mut BTreeMap`
fn field_definitions_output(
    field_type: &Type,
    cratename: &Path,
    definitions_override: Option<ExprPath>,
) -> TokenStream2 {
    let default_path: ExprPath = syn::parse2(
        quote! { <#field_type as #cratename::BorshSchema>::add_definitions_recursively },
    )
    .unwrap();
    let path = definitions_override.unwrap_or(default_path);

    quote! {
        #path(definitions);
    }
}

pub fn process(input: &ItemStruct, cratename: Path) -> syn::Result<TokenStream2> {
    let name = &input.ident;
    let struct_name = name.to_token_stream().to_string();
    let generics = generics::without_defaults(&input.generics);
    let (impl_generics, ty_generics, where_clause) = generics.split_for_impl();
    let mut where_clause = generics::default_where(where_clause);
    let mut generics_output = schema::GenericsOutput::new(&generics);
    let (struct_fields, add_definitions_recursively) =
        process_fields(&cratename, &input.fields, &mut generics_output)?;

    let add_definitions_recursively = quote! {
        fn add_definitions_recursively(definitions: &mut #cratename::__private::maybestd::collections::BTreeMap<#cratename::schema::Declaration, #cratename::schema::Definition>) {
            #struct_fields
            let definition = #cratename::schema::Definition::Struct { fields };

            let no_recursion_flag = definitions.get(&<Self as #cratename::BorshSchema>::declaration()).is_none();
            #cratename::schema::add_definition(<Self as #cratename::BorshSchema>::declaration(), definition, definitions);
            if no_recursion_flag {
                #add_definitions_recursively
            }
        }
    };

    let (predicates, declaration) = generics_output.result(&struct_name, &cratename);
    where_clause.predicates.extend(predicates);
    Ok(quote! {
        impl #impl_generics #cratename::BorshSchema for #name #ty_generics #where_clause {
            fn declaration() -> #cratename::schema::Declaration {
                #declaration
            }
            #add_definitions_recursively
        }
    })
}

fn process_fields(
    cratename: &Path,
    fields: &Fields,
    generics: &mut schema::GenericsOutput,
) -> syn::Result<(TokenStream2, TokenStream2)> {
    let mut struct_fields = TokenStream2::new();
    let mut add_definitions_recursively = TokenStream2::new();

    // Generate function that returns the schema of required types.
    let mut fields_vec = vec![];
    schema::visit_struct_fields(fields, &mut generics.params_visitor)?;
    match fields {
        Fields::Named(fields) => {
            for field in &fields.named {
                process_field(
                    field,
                    cratename,
                    &mut fields_vec,
                    &mut add_definitions_recursively,
                )?;
            }
            if !fields_vec.is_empty() {
                struct_fields = quote! {
                    let fields = #cratename::schema::Fields::NamedFields(#cratename::__private::maybestd::vec![#(#fields_vec),*]);
                };
            }
        }
        Fields::Unnamed(fields) => {
            for field in &fields.unnamed {
                process_field(
                    field,
                    cratename,
                    &mut fields_vec,
                    &mut add_definitions_recursively,
                )?;
            }
            if !fields_vec.is_empty() {
                struct_fields = quote! {
                    let fields = #cratename::schema::Fields::UnnamedFields(#cratename::__private::maybestd::vec![#(#fields_vec),*]);
                };
            }
        }
        Fields::Unit => {}
    }

    if fields_vec.is_empty() {
        struct_fields = quote! {
            let fields = #cratename::schema::Fields::Empty;
        };
    }
    Ok((struct_fields, add_definitions_recursively))
}
fn process_field(
    field: &syn::Field,
    cratename: &Path,
    fields_vec: &mut Vec<TokenStream2>,
    add_definitions_recursively: &mut TokenStream2,
) -> syn::Result<()> {
    let parsed = field::Attributes::parse(&field.attrs)?;
    if !parsed.skip {
        let field_name = field.ident.as_ref();
        let field_type = &field.ty;
        fields_vec.push(field_declaration_output(
            field_name,
            field_type,
            cratename,
            parsed.schema_declaration(),
        ));
        add_definitions_recursively.extend(field_definitions_output(
            field_type,
            cratename,
            parsed.schema_definitions(),
        ));
    }
    Ok(())
}

#[cfg(test)]
mod tests {
    use crate::internals::test_helpers::{
        default_cratename, local_insta_assert_debug_snapshot, local_insta_assert_snapshot,
        pretty_print_syn_str,
    };

    use super::*;

    #[test]
    fn unit_struct() {
        let item_struct: ItemStruct = syn::parse2(quote! {
            struct A;
        })
        .unwrap();

        let actual = process(&item_struct, default_cratename()).unwrap();
        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn wrapper_struct() {
        let item_struct: ItemStruct = syn::parse2(quote! {
            struct A<T>(T);
        })
        .unwrap();

        let actual = process(&item_struct, default_cratename()).unwrap();
        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn tuple_struct() {
        let item_struct: ItemStruct = syn::parse2(quote! {
            struct A(u64, String);
        })
        .unwrap();

        let actual = process(&item_struct, default_cratename()).unwrap();
        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn tuple_struct_params() {
        let item_struct: ItemStruct = syn::parse2(quote! {
            struct A<K, V>(K, V);
        })
        .unwrap();

        let actual = process(&item_struct, default_cratename()).unwrap();
        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn simple_struct() {
        let item_struct: ItemStruct = syn::parse2(quote! {
            struct A {
                x: u64,
                y: String,
            }
        })
        .unwrap();

        let actual = process(&item_struct, default_cratename()).unwrap();
        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn simple_struct_with_custom_crate() {
        let item_struct: ItemStruct = syn::parse2(quote! {
            struct A {
                x: u64,
                y: String,
            }
        })
        .unwrap();

        let crate_: Path = syn::parse2(quote! { reexporter::borsh }).unwrap();
        let actual = process(&item_struct, crate_).unwrap();
        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn simple_generics() {
        let item_struct: ItemStruct = syn::parse2(quote! {
            struct A<K, V> {
                x: HashMap<K, V>,
                y: String,
            }
        })
        .unwrap();

        let actual = process(&item_struct, default_cratename()).unwrap();
        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn trailing_comma_generics() {
        let item_struct: ItemStruct = syn::parse2(quote! {
            struct A<K, V>
            where
                K: Display + Debug,
            {
                x: HashMap<K, V>,
                y: String,
            }
        })
        .unwrap();

        let actual = process(&item_struct, default_cratename()).unwrap();
        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn tuple_struct_whole_skip() {
        let item_struct: ItemStruct = syn::parse2(quote! {
            struct A(#[borsh(skip)] String);
        })
        .unwrap();

        let actual = process(&item_struct, default_cratename()).unwrap();
        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn tuple_struct_partial_skip() {
        let item_struct: ItemStruct = syn::parse2(quote! {
            struct A(#[borsh(skip)] u64, String);
        })
        .unwrap();

        let actual = process(&item_struct, default_cratename()).unwrap();
        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn generic_tuple_struct_borsh_skip1() {
        let item_struct: ItemStruct = syn::parse2(quote! {
            struct G<K, V, U> (
                #[borsh(skip)]
                HashMap<K, V>,
                U,
            );
        })
        .unwrap();

        let actual = process(&item_struct, default_cratename()).unwrap();

        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn generic_tuple_struct_borsh_skip2() {
        let item_struct: ItemStruct = syn::parse2(quote! {
            struct G<K, V, U> (
                HashMap<K, V>,
                #[borsh(skip)]
                U,
            );
        })
        .unwrap();

        let actual = process(&item_struct, default_cratename()).unwrap();

        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn generic_tuple_struct_borsh_skip3() {
        let item_struct: ItemStruct = syn::parse2(quote! {
            struct G<U, K, V> (
                #[borsh(skip)]
                HashMap<K, V>,
                U,
                K,
            );
        })
        .unwrap();

        let actual = process(&item_struct, default_cratename()).unwrap();

        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn generic_tuple_struct_borsh_skip4() {
        let item_struct: ItemStruct = syn::parse2(quote! {
            struct ASalad<C>(Tomatoes, #[borsh(skip)] C, Oil);
        })
        .unwrap();

        let actual = process(&item_struct, default_cratename()).unwrap();

        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn generic_named_fields_struct_borsh_skip() {
        let item_struct: ItemStruct = syn::parse2(quote! {
            struct G<K, V, U> {
                #[borsh(skip)]
                x: HashMap<K, V>,
                y: U,
            }
        })
        .unwrap();

        let actual = process(&item_struct, default_cratename()).unwrap();

        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn recursive_struct() {
        let item_struct: ItemStruct = syn::parse2(quote! {
            struct CRecC {
                a: String,
                b: HashMap<String, CRecC>,
            }
        })
        .unwrap();

        let actual = process(&item_struct, default_cratename()).unwrap();

        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn generic_associated_type() {
        let item_struct: ItemStruct = syn::parse2(quote! {
            struct Parametrized<V, T: Debug>
            where
                T: TraitName,
            {
                field: T::Associated,
                another: V,
            }
        })
        .unwrap();

        let actual = process(&item_struct, default_cratename()).unwrap();

        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn generic_associated_type_param_override() {
        let item_struct: ItemStruct = syn::parse2(quote! {
            struct Parametrized<V, T>
            where
                T: TraitName,
            {
                #[borsh(schema(params =
                    "T => <T as TraitName>::Associated"
               ))]
                field: <T as TraitName>::Associated,
                another: V,
            }
        })
        .unwrap();

        let actual = process(&item_struct, default_cratename()).unwrap();

        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn generic_associated_type_param_override2() {
        let item_struct: ItemStruct = syn::parse2(quote! {
            struct Parametrized<V, T>
            where
                T: TraitName,
            {
                #[borsh(schema(params =
                    "T => T, T => <T as TraitName>::Associated"
               ))]
                field: (<T as TraitName>::Associated, T),
                another: V,
            }
        })
        .unwrap();

        let actual = process(&item_struct, default_cratename()).unwrap();

        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn generic_associated_type_param_override_conflict() {
        let item_struct: ItemStruct = syn::parse2(quote! {
            struct Parametrized<V, T>
            where
                T: TraitName,
            {
                #[borsh(skip,schema(params =
                    "T => <T as TraitName>::Associated"
               ))]
                field: <T as TraitName>::Associated,
                another: V,
            }
        })
        .unwrap();

        let actual = process(&item_struct, default_cratename());

        local_insta_assert_debug_snapshot!(actual.unwrap_err());
    }

    #[test]
    fn check_with_funcs_skip_conflict() {
        let item_struct: ItemStruct = syn::parse2(quote! {
            struct A<K, V> {
                #[borsh(skip,schema(with_funcs(
                    declaration = "third_party_impl::declaration::<K, V>",
                    definitions = "third_party_impl::add_definitions_recursively::<K, V>"
                )))]
                x: ThirdParty<K, V>,
                y: u64,
            }
        })
        .unwrap();

        let actual = process(&item_struct, default_cratename());

        local_insta_assert_debug_snapshot!(actual.unwrap_err());
    }

    #[test]
    fn with_funcs_attr() {
        let item_struct: ItemStruct = syn::parse2(quote! {
            struct A<K, V> {
                #[borsh(schema(with_funcs(
                    declaration = "third_party_impl::declaration::<K, V>",
                    definitions = "third_party_impl::add_definitions_recursively::<K, V>"
                )))]
                x: ThirdParty<K, V>,
                y: u64,
            }
        })
        .unwrap();

        let actual = process(&item_struct, default_cratename()).unwrap();

        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn schema_param_override3() {
        let item_struct: ItemStruct = syn::parse2(quote! {
            struct A<K: EntityRef, V> {
                #[borsh(
                    schema(
                        params = "V => V"
                    )
                )]
                x: PrimaryMap<K, V>,
                y: String,
            }
        })
        .unwrap();

        let actual = process(&item_struct, default_cratename()).unwrap();

        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }
}

'''
'''--- borsh-derive/src/internals/serialize/enums/mod.rs ---
use proc_macro2::TokenStream as TokenStream2;
use quote::quote;
use syn::{Fields, Ident, ItemEnum, Path, Variant};

use crate::internals::{
    attributes::{field, item, BoundType},
    enum_discriminant::Discriminants,
    generics, serialize,
};

pub fn process(input: &ItemEnum, cratename: Path) -> syn::Result<TokenStream2> {
    let enum_ident = &input.ident;
    let generics = generics::without_defaults(&input.generics);
    let (impl_generics, ty_generics, where_clause) = generics.split_for_impl();
    let mut where_clause = generics::default_where(where_clause);
    let mut generics_output = serialize::GenericsOutput::new(&generics);
    let mut all_variants_idx_body = TokenStream2::new();
    let mut fields_body = TokenStream2::new();
    let use_discriminant = item::contains_use_discriminant(input)?;
    let discriminants = Discriminants::new(&input.variants);
    let mut has_unit_variant = false;

    for (variant_idx, variant) in input.variants.iter().enumerate() {
        let variant_ident = &variant.ident;
        let discriminant_value = discriminants.get(variant_ident, use_discriminant, variant_idx)?;
        let variant_output = process_variant(
            variant,
            enum_ident,
            &discriminant_value,
            &cratename,
            &mut generics_output,
        )?;
        all_variants_idx_body.extend(variant_output.variant_idx_body);
        match variant_output.body {
            VariantBody::Unit => has_unit_variant = true,
            VariantBody::Fields(VariantFields { header, body }) => fields_body.extend(quote!(
                #enum_ident::#variant_ident #header => {
                    #body
                }
            )),
        }
    }
    let fields_body = optimize_fields_body(fields_body, has_unit_variant);
    generics_output.extend(&mut where_clause, &cratename);

    Ok(quote! {
        impl #impl_generics #cratename::ser::BorshSerialize for #enum_ident #ty_generics #where_clause {
            fn serialize<__W: #cratename::io::Write>(&self, writer: &mut __W) -> ::core::result::Result<(), #cratename::io::Error> {
                let variant_idx: u8 = match self {
                    #all_variants_idx_body
                };
                writer.write_all(&variant_idx.to_le_bytes())?;

                #fields_body
                Ok(())
            }
        }
    })
}

fn optimize_fields_body(fields_body: TokenStream2, has_unit_variant: bool) -> TokenStream2 {
    if fields_body.is_empty() {
        // If we no variants with fields, there's nothing to match against. Just
        // re-use the empty token stream.
        fields_body
    } else {
        let unit_fields_catchall = if has_unit_variant {
            // We had some variants with unit fields, create a catch-all for
            // these to be used at the bottom.
            quote!(
                _ => {}
            )
        } else {
            TokenStream2::new()
        };
        // Create a match that serialises all the fields for each non-unit
        // variant and add a catch-all at the bottom if we do have unit
        // variants.
        quote!(
            match self {
                #fields_body
                #unit_fields_catchall
            }
        )
    }
}

#[derive(Default)]
struct VariantFields {
    header: TokenStream2,
    body: TokenStream2,
}

impl VariantFields {
    fn named_header(self) -> Self {
        let header = self.header;

        VariantFields {
            // `..` pattern matching works even if all fields were specified
            header: quote! { { #header.. }},
            body: self.body,
        }
    }
    fn unnamed_header(self) -> Self {
        let header = self.header;

        VariantFields {
            header: quote! { ( #header )},
            body: self.body,
        }
    }
}

enum VariantBody {
    // No body variant, unit enum variant.
    Unit,
    // Variant with body (fields)
    Fields(VariantFields),
}

struct VariantOutput {
    body: VariantBody,
    variant_idx_body: TokenStream2,
}

fn process_variant(
    variant: &Variant,
    enum_ident: &Ident,
    discriminant_value: &TokenStream2,
    cratename: &Path,
    generics: &mut serialize::GenericsOutput,
) -> syn::Result<VariantOutput> {
    let variant_ident = &variant.ident;
    let variant_output = match &variant.fields {
        Fields::Named(fields) => {
            let mut variant_fields = VariantFields::default();
            for field in &fields.named {
                let field_id = serialize::FieldId::Enum(field.ident.clone().unwrap());
                process_field(field, field_id, cratename, generics, &mut variant_fields)?;
            }
            VariantOutput {
                body: VariantBody::Fields(variant_fields.named_header()),
                variant_idx_body: quote!(
                    #enum_ident::#variant_ident {..} => #discriminant_value,
                ),
            }
        }
        Fields::Unnamed(fields) => {
            let mut variant_fields = VariantFields::default();
            for (field_idx, field) in fields.unnamed.iter().enumerate() {
                let field_id = serialize::FieldId::new_enum_unnamed(field_idx)?;
                process_field(field, field_id, cratename, generics, &mut variant_fields)?;
            }
            VariantOutput {
                body: VariantBody::Fields(variant_fields.unnamed_header()),
                variant_idx_body: quote!(
                    #enum_ident::#variant_ident(..) => #discriminant_value,
                ),
            }
        }
        Fields::Unit => VariantOutput {
            body: VariantBody::Unit,
            variant_idx_body: quote!(
                #enum_ident::#variant_ident => #discriminant_value,
            ),
        },
    };
    Ok(variant_output)
}

fn process_field(
    field: &syn::Field,
    field_id: serialize::FieldId,
    cratename: &Path,
    generics: &mut serialize::GenericsOutput,
    output: &mut VariantFields,
) -> syn::Result<()> {
    let parsed = field::Attributes::parse(&field.attrs)?;

    let needs_bounds_derive = parsed.needs_bounds_derive(BoundType::Serialize);
    generics
        .overrides
        .extend(parsed.collect_bounds(BoundType::Serialize));

    let field_variant_header = field_id.enum_variant_header(parsed.skip);
    if let Some(field_variant_header) = field_variant_header {
        output.header.extend(field_variant_header);
    }

    if !parsed.skip {
        let delta = field_id.serialize_output(cratename, parsed.serialize_with);
        output.body.extend(delta);
        if needs_bounds_derive {
            generics.serialize_visitor.visit_field(field);
        }
    }
    Ok(())
}

#[cfg(test)]
mod tests {
    use crate::internals::test_helpers::{
        default_cratename, local_insta_assert_snapshot, pretty_print_syn_str,
    };

    use super::*;
    #[test]
    fn borsh_skip_tuple_variant_field() {
        let item_enum: ItemEnum = syn::parse2(quote! {
            enum AATTB {
                B(#[borsh(skip)] i32, #[borsh(skip)] u32),

                NegatedVariant {
                    beta: u8,
                }
            }
        })
        .unwrap();
        let actual = process(&item_enum, default_cratename()).unwrap();

        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn struct_variant_field() {
        let item_enum: ItemEnum = syn::parse2(quote! {
            enum AB {
                B {
                    c: i32,
                    d: u32,
                },

                NegatedVariant {
                    beta: String,
                }
            }
        })
        .unwrap();

        let actual = process(&item_enum, default_cratename()).unwrap();

        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn simple_enum_with_custom_crate() {
        let item_enum: ItemEnum = syn::parse2(quote! {
            enum AB {
                B {
                    c: i32,
                    d: u32,
                },

                NegatedVariant {
                    beta: String,
                }
            }
        })
        .unwrap();

        let crate_: Path = syn::parse2(quote! { reexporter::borsh }).unwrap();
        let actual = process(&item_enum, crate_).unwrap();

        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn borsh_skip_struct_variant_field() {
        let item_enum: ItemEnum = syn::parse2(quote! {

            enum AB {
                B {
                    #[borsh(skip)]
                    c: i32,

                    d: u32,
                },

                NegatedVariant {
                    beta: String,
                }
            }
        })
        .unwrap();

        let actual = process(&item_enum, default_cratename()).unwrap();

        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn borsh_skip_struct_variant_all_fields() {
        let item_enum: ItemEnum = syn::parse2(quote! {

            enum AAB {
                B {
                    #[borsh(skip)]
                    c: i32,

                    #[borsh(skip)]
                    d: u32,
                },

                NegatedVariant {
                    beta: String,
                }
            }
        })
        .unwrap();

        let actual = process(&item_enum, default_cratename()).unwrap();

        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn simple_generics() {
        let item_struct: ItemEnum = syn::parse2(quote! {
            enum A<K, V, U> {
                B {
                    x: HashMap<K, V>,
                    y: String,
                },
                C(K, Vec<U>),
            }
        })
        .unwrap();

        let actual = process(&item_struct, default_cratename()).unwrap();
        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn bound_generics() {
        let item_struct: ItemEnum = syn::parse2(quote! {
            enum A<K: Key, V, U> where V: Value {
                B {
                    x: HashMap<K, V>,
                    y: String,
                },
                C(K, Vec<U>),
            }
        })
        .unwrap();

        let actual = process(&item_struct, default_cratename()).unwrap();
        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn recursive_enum() {
        let item_struct: ItemEnum = syn::parse2(quote! {
            enum A<K: Key, V> where V: Value {
                B {
                    x: HashMap<K, V>,
                    y: String,
                },
                C(K, Vec<A>),
            }
        })
        .unwrap();

        let actual = process(&item_struct, default_cratename()).unwrap();

        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn generic_borsh_skip_struct_field() {
        let item_struct: ItemEnum = syn::parse2(quote! {
            enum A<K: Key, V, U> where V: Value {
                B {
                    #[borsh(skip)]
                    x: HashMap<K, V>,
                    y: String,
                },
                C(K, Vec<U>),
            }
        })
        .unwrap();

        let actual = process(&item_struct, default_cratename()).unwrap();

        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn generic_borsh_skip_tuple_field() {
        let item_struct: ItemEnum = syn::parse2(quote! {
            enum A<K: Key, V, U> where V: Value {
                B {
                    x: HashMap<K, V>,
                    y: String,
                },
                C(K, #[borsh(skip)] Vec<U>),
            }
        })
        .unwrap();

        let actual = process(&item_struct, default_cratename()).unwrap();

        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn generic_serialize_bound() {
        let item_struct: ItemEnum = syn::parse2(quote! {
            enum A<T: Debug, U> {
                C {
                    a: String,
                    #[borsh(bound(serialize =
                        "T: borsh::ser::BorshSerialize + PartialOrd,
                         U: borsh::ser::BorshSerialize"
                    ))]
                    b: HashMap<T, U>,
                },
                D(u32, u32),
            }
        })
        .unwrap();

        let actual = process(&item_struct, default_cratename()).unwrap();

        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn check_serialize_with_attr() {
        let item_struct: ItemEnum = syn::parse2(quote! {
            enum C<K: Ord, V> {
                C3(u64, u64),
                C4 {
                    x: u64,
                    #[borsh(serialize_with = "third_party_impl::serialize_third_party")]
                    y: ThirdParty<K, V>
                },
            }
        })
        .unwrap();

        let actual = process(&item_struct, default_cratename()).unwrap();

        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn borsh_discriminant_false() {
        let item_enum: ItemEnum = syn::parse2(quote! {
           #[borsh(use_discriminant = false)]
            enum X {
                A,
                B = 20,
                C,
                D,
                E = 10,
                F,
            }
        })
        .unwrap();
        let actual = process(&item_enum, default_cratename()).unwrap();

        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }
    #[test]
    fn borsh_discriminant_true() {
        let item_enum: ItemEnum = syn::parse2(quote! {
            #[borsh(use_discriminant = true)]
            enum X {
                A,
                B = 20,
                C,
                D,
                E = 10,
                F,
            }
        })
        .unwrap();
        let actual = process(&item_enum, default_cratename()).unwrap();

        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn mixed_with_unit_variants() {
        let item_enum: ItemEnum = syn::parse2(quote! {
            enum X {
                A(u16),
                B,
                C {x: i32, y: i32},
                D,
            }
        })
        .unwrap();
        let actual = process(&item_enum, default_cratename()).unwrap();

        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }
}

'''
'''--- borsh-derive/src/internals/serialize/mod.rs ---
use proc_macro2::{Span, TokenStream as TokenStream2};
use quote::quote;
use std::convert::TryFrom;
use syn::{Expr, ExprPath, Generics, Ident, Index, Path};

use super::generics;

pub mod enums;
pub mod structs;
pub mod unions;

struct GenericsOutput {
    overrides: Vec<syn::WherePredicate>,
    serialize_visitor: generics::FindTyParams,
}

impl GenericsOutput {
    fn new(generics: &Generics) -> Self {
        Self {
            overrides: vec![],
            serialize_visitor: generics::FindTyParams::new(generics),
        }
    }
    fn extend(self, where_clause: &mut syn::WhereClause, cratename: &Path) {
        let trait_path: Path = syn::parse2(quote! { #cratename::ser::BorshSerialize }).unwrap();
        let predicates =
            generics::compute_predicates(self.serialize_visitor.process_for_bounds(), &trait_path);
        where_clause.predicates.extend(predicates);
        where_clause.predicates.extend(self.overrides);
    }
}

pub enum FieldId {
    Struct(Ident),
    StructUnnamed(Index),
    Enum(Ident),
    EnumUnnamed(Index),
}

impl FieldId {
    fn index(field_idx: usize) -> syn::Result<Index> {
        let index = u32::try_from(field_idx).map_err(|err| {
            syn::Error::new(
                Span::call_site(),
                format!("up to 2^32 fields are supported {}", err),
            )
        })?;
        Ok(Index {
            index,
            span: Span::call_site(),
        })
    }
    pub fn new_struct_unnamed(field_idx: usize) -> syn::Result<Self> {
        let index = Self::index(field_idx)?;
        let result = Self::StructUnnamed(index);
        Ok(result)
    }
    pub fn new_enum_unnamed(field_idx: usize) -> syn::Result<Self> {
        let index = Self::index(field_idx)?;
        let result = Self::EnumUnnamed(index);
        Ok(result)
    }
}

impl FieldId {
    fn serialize_arg(&self) -> Expr {
        match self {
            Self::Struct(name) => syn::parse2(quote! { &self.#name }).unwrap(),
            Self::StructUnnamed(index) => syn::parse2(quote! { &self.#index }).unwrap(),
            Self::Enum(name) => syn::parse2(quote! { #name }).unwrap(),
            Self::EnumUnnamed(ind) => {
                let field = Ident::new(&format!("id{}", ind.index), Span::mixed_site());
                syn::parse2(quote! { #field }).unwrap()
            }
        }
    }
    /// function which computes derive output [proc_macro2::TokenStream]
    /// of code, which serializes single field
    pub fn serialize_output(
        &self,
        cratename: &Path,
        serialize_with: Option<ExprPath>,
    ) -> TokenStream2 {
        let arg: Expr = self.serialize_arg();
        if let Some(func) = serialize_with {
            quote! { #func(#arg, writer)?; }
        } else {
            quote! { #cratename::BorshSerialize::serialize(#arg, writer)?; }
        }
    }
    pub fn enum_variant_header(&self, skipped: bool) -> Option<TokenStream2> {
        match self {
            Self::Struct(..) | Self::StructUnnamed(..) => unreachable!("no variant header"),
            Self::Enum(name) => (!skipped).then_some(quote! { #name, }),
            Self::EnumUnnamed(index) => {
                let field_ident = if skipped {
                    Ident::new(&format!("_id{}", index.index), Span::mixed_site())
                } else {
                    Ident::new(&format!("id{}", index.index), Span::mixed_site())
                };
                Some(quote! { #field_ident, })
            }
        }
    }
}

'''
'''--- borsh-derive/src/internals/serialize/structs/mod.rs ---
use proc_macro2::TokenStream as TokenStream2;
use quote::quote;
use syn::{Fields, ItemStruct, Path};

use crate::internals::{
    attributes::{field, BoundType},
    generics, serialize,
};

pub fn process(input: &ItemStruct, cratename: Path) -> syn::Result<TokenStream2> {
    let name = &input.ident;
    let generics = generics::without_defaults(&input.generics);
    let (impl_generics, ty_generics, where_clause) = generics.split_for_impl();
    let mut where_clause = generics::default_where(where_clause);
    let mut body = TokenStream2::new();
    let mut generics_output = serialize::GenericsOutput::new(&generics);
    match &input.fields {
        Fields::Named(fields) => {
            for field in &fields.named {
                let field_id = serialize::FieldId::Struct(field.ident.clone().unwrap());

                process_field(field, field_id, &cratename, &mut generics_output, &mut body)?;
            }
        }
        Fields::Unnamed(fields) => {
            for (field_idx, field) in fields.unnamed.iter().enumerate() {
                let field_id = serialize::FieldId::new_struct_unnamed(field_idx)?;

                process_field(field, field_id, &cratename, &mut generics_output, &mut body)?;
            }
        }
        Fields::Unit => {}
    }
    generics_output.extend(&mut where_clause, &cratename);

    Ok(quote! {
        impl #impl_generics #cratename::ser::BorshSerialize for #name #ty_generics #where_clause {
            fn serialize<__W: #cratename::io::Write>(&self, writer: &mut __W) -> ::core::result::Result<(), #cratename::io::Error> {
                #body
                Ok(())
            }
        }
    })
}

fn process_field(
    field: &syn::Field,
    field_id: serialize::FieldId,
    cratename: &Path,
    generics: &mut serialize::GenericsOutput,
    body: &mut TokenStream2,
) -> syn::Result<()> {
    let parsed = field::Attributes::parse(&field.attrs)?;
    let needs_bounds_derive = parsed.needs_bounds_derive(BoundType::Serialize);

    generics
        .overrides
        .extend(parsed.collect_bounds(BoundType::Serialize));
    if !parsed.skip {
        let delta = field_id.serialize_output(cratename, parsed.serialize_with);
        body.extend(delta);

        if needs_bounds_derive {
            generics.serialize_visitor.visit_field(field);
        }
    }
    Ok(())
}

#[cfg(test)]
mod tests {
    use crate::internals::test_helpers::{
        default_cratename, local_insta_assert_debug_snapshot, local_insta_assert_snapshot,
        pretty_print_syn_str,
    };

    use super::*;

    #[test]
    fn simple_struct() {
        let item_struct: ItemStruct = syn::parse2(quote! {
            struct A {
                x: u64,
                y: String,
            }
        })
        .unwrap();

        let actual = process(&item_struct, default_cratename()).unwrap();

        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn simple_struct_with_custom_crate() {
        let item_struct: ItemStruct = syn::parse2(quote! {
            struct A {
                x: u64,
                y: String,
            }
        })
        .unwrap();

        let crate_: Path = syn::parse2(quote! { reexporter::borsh }).unwrap();
        let actual = process(&item_struct, crate_).unwrap();

        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn simple_generics() {
        let item_struct: ItemStruct = syn::parse2(quote! {
            struct A<K, V> {
                x: HashMap<K, V>,
                y: String,
            }
        })
        .unwrap();

        let actual = process(&item_struct, default_cratename()).unwrap();
        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn simple_generic_tuple_struct() {
        let item_struct: ItemStruct = syn::parse2(quote! {
            struct TupleA<T>(T, u32);
        })
        .unwrap();

        let actual = process(&item_struct, default_cratename()).unwrap();
        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn bound_generics() {
        let item_struct: ItemStruct = syn::parse2(quote! {
            struct A<K: Key, V> where V: Value {
                x: HashMap<K, V>,
                y: String,
            }
        })
        .unwrap();

        let actual = process(&item_struct, default_cratename()).unwrap();
        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn recursive_struct() {
        let item_struct: ItemStruct = syn::parse2(quote! {
            struct CRecC {
                a: String,
                b: HashMap<String, CRecC>,
            }
        })
        .unwrap();

        let actual = process(&item_struct, default_cratename()).unwrap();

        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn generic_tuple_struct_borsh_skip1() {
        let item_struct: ItemStruct = syn::parse2(quote! {
            struct G<K, V, U> (
                #[borsh(skip)]
                HashMap<K, V>,
                U,
            );
        })
        .unwrap();

        let actual = process(&item_struct, default_cratename()).unwrap();

        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn generic_tuple_struct_borsh_skip2() {
        let item_struct: ItemStruct = syn::parse2(quote! {
            struct G<K, V, U> (
                HashMap<K, V>,
                #[borsh(skip)]
                U,
            );
        })
        .unwrap();

        let actual = process(&item_struct, default_cratename()).unwrap();

        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn generic_named_fields_struct_borsh_skip() {
        let item_struct: ItemStruct = syn::parse2(quote! {
            struct G<K, V, U> {
                #[borsh(skip)]
                x: HashMap<K, V>,
                y: U,
            }
        })
        .unwrap();

        let actual = process(&item_struct, default_cratename()).unwrap();

        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn generic_associated_type() {
        let item_struct: ItemStruct = syn::parse2(quote! {
            struct Parametrized<T, V>
            where
                T: TraitName,
            {
                field: T::Associated,
                another: V,
            }
        })
        .unwrap();

        let actual = process(&item_struct, default_cratename()).unwrap();

        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn generic_serialize_bound() {
        let item_struct: ItemStruct = syn::parse2(quote! {
            struct C<T: Debug, U> {
                a: String,
                #[borsh(bound(serialize =
                    "T: borsh::ser::BorshSerialize + PartialOrd,
                     U: borsh::ser::BorshSerialize"
                ))]
                b: HashMap<T, U>,
            }
        })
        .unwrap();

        let actual = process(&item_struct, default_cratename()).unwrap();

        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn override_generic_associated_type_wrong_derive() {
        let item_struct: ItemStruct = syn::parse2(quote! {
            struct Parametrized<T, V> where T: TraitName {
                #[borsh(bound(serialize =
                    "<T as TraitName>::Associated: borsh::ser::BorshSerialize"
                ))]
                field: <T as TraitName>::Associated,
                another: V,
            }
        })
        .unwrap();

        let actual = process(&item_struct, default_cratename()).unwrap();

        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn check_serialize_with_attr() {
        let item_struct: ItemStruct = syn::parse2(quote! {
            struct A<K: Ord, V> {
                #[borsh(serialize_with = "third_party_impl::serialize_third_party")]
                x: ThirdParty<K, V>,
                y: u64,
            }
        })
        .unwrap();

        let actual = process(&item_struct, default_cratename()).unwrap();

        local_insta_assert_snapshot!(pretty_print_syn_str(&actual).unwrap());
    }

    #[test]
    fn check_serialize_with_skip_conflict() {
        let item_struct: ItemStruct = syn::parse2(quote! {
            struct A<K: Ord, V> {
                #[borsh(skip,serialize_with = "third_party_impl::serialize_third_party")]
                x: ThirdParty<K, V>,
                y: u64,
            }
        })
        .unwrap();

        let actual = process(&item_struct, default_cratename());

        let err = match actual {
            Ok(..) => unreachable!("expecting error here"),
            Err(err) => err,
        };
        local_insta_assert_debug_snapshot!(err);
    }
}

'''
'''--- borsh-derive/src/internals/serialize/unions/mod.rs ---
use proc_macro2::TokenStream as TokenStream2;
use syn::{ItemUnion, Path};

pub fn process(_input: &ItemUnion, _cratename: Path) -> syn::Result<TokenStream2> {
    unimplemented!()
}

'''
'''--- borsh-derive/src/internals/test_helpers.rs ---
use super::cratename::BORSH;
use proc_macro2::Span;
use proc_macro2::TokenStream;
use quote::{quote, ToTokens};
use std::fmt::Write;
use syn::{Ident, Path};

pub fn pretty_print_syn_str(input: &TokenStream) -> syn::Result<String> {
    let input = format!("{}", quote!(#input));
    let syn_file = syn::parse_str::<syn::File>(&input)?;

    Ok(prettyplease::unparse(&syn_file))
}

pub fn debug_print_vec_of_tokenizable<T: ToTokens>(optional: Option<Vec<T>>) -> String {
    let mut s = String::new();
    if let Some(vec) = optional {
        for element in vec {
            writeln!(&mut s, "{}", element.to_token_stream()).unwrap();
        }
    } else {
        write!(&mut s, "None").unwrap();
    }
    s
}

pub fn debug_print_tokenizable<T: ToTokens>(optional: Option<T>) -> String {
    let mut s = String::new();
    if let Some(type_) = optional {
        writeln!(&mut s, "{}", type_.to_token_stream()).unwrap();
    } else {
        write!(&mut s, "None").unwrap();
    }
    s
}

macro_rules! local_insta_assert_debug_snapshot {
    ($value:expr) => {{

        insta::with_settings!({prepend_module_to_snapshot => false}, {
            insta::assert_debug_snapshot!($value);
        });
    }};
}

macro_rules! local_insta_assert_snapshot {
    ($value:expr) => {{

        insta::with_settings!({prepend_module_to_snapshot => false}, {
            insta::assert_snapshot!($value);
        });
    }};
}

pub(crate) fn default_cratename() -> Path {
    let cratename = Ident::new(BORSH, Span::call_site());
    cratename.into()
}

pub(crate) use {local_insta_assert_debug_snapshot, local_insta_assert_snapshot};

'''
'''--- borsh-derive/src/lib.rs ---
#![recursion_limit = "128"]
#![cfg_attr(
    feature = "force_exhaustive_checks",
    feature(non_exhaustive_omitted_patterns_lint)
)]

extern crate proc_macro;
use proc_macro::TokenStream;
#[cfg(feature = "schema")]
use proc_macro2::Span;
use syn::{DeriveInput, Error, ItemEnum, ItemStruct, ItemUnion, Path};

///  by convention, local to borsh-derive crate, imports from proc_macro (1) are not allowed in `internals` module or in any of its submodules.
mod internals;

use crate::internals::attributes::item;

#[cfg(feature = "schema")]
use internals::schema;
use internals::{cratename, deserialize, serialize};

fn check_attrs_get_cratename(input: &TokenStream) -> Result<Path, Error> {
    let input = input.clone();

    let derive_input = syn::parse::<DeriveInput>(input)?;

    item::check_attributes(&derive_input)?;

    cratename::get(&derive_input.attrs)
}

/**
# derive proc-macro for `borsh::ser::BorshSerialize` trait

## Bounds

Generally, `BorshSerialize` adds `borsh::ser::BorshSerialize` bound to any type parameter
found in item's fields.

```ignore
/// impl<U, V> borsh::ser::BorshSerialize for A<U, V>
/// where
///     U: borsh::ser::BorshSerialize,
///     V: borsh::ser::BorshSerialize,
#[derive(BorshSerialize)]
struct A<U, V> {
    x: U,
    y: V,
}
```

```ignore
/// impl<U, V> borsh::ser::BorshSerialize for A<U, V>
/// where
///     U: borsh::ser::BorshSerialize,
#[derive(BorshSerialize)]
struct A<U, V> {
    x: U,
    #[borsh(skip)]
    y: V,
}
```

## Attributes

### 1. `#[borsh(crate = "path::to::borsh")]` (item level attribute)

###### syntax

Attribute takes literal string value, which is the syn's [Path] to `borsh` crate used.

###### usage

Attribute is optional.

1. If the attribute is not provided, [crate_name](proc_macro_crate::crate_name) is used to find a version of `borsh`
in `[dependencies]` of the relevant `Cargo.toml`. If there is no match, a compilation error, similar to the following, is raised:

```bash
 1  error: proc-macro derive panicked
   --> path/to/file.rs:27:10
    |
 27 | #[derive(BorshSerialize, BorshDeserialize)]
    |          ^^^^^^^^^^^^^^
    |
    = help: message: called `Result::unwrap()` on an `Err` value: CrateNotFound { crate_name: "borsh", path: "/path/to/Cargo.toml" }
```

2. If the attribute is provided, the check for `borsh` in `[dependencies]` of the relevant `Cargo.toml` is skipped.

Examples of usage:

```ignore
use reexporter::borsh::BorshSerialize;

// specifying the attribute removes need for a direct import of `borsh` into `[dependencies]`
#[derive(BorshSerialize)]
#[borsh(crate = "reexporter::borsh")]
struct B {
    x: u64,
    y: i32,
    c: String,
}
```

```ignore
use reexporter::borsh::{self, BorshSerialize};

// specifying the attribute removes need for a direct import of `borsh` into `[dependencies]`
#[derive(BorshSerialize)]
#[borsh(crate = "borsh")]
struct B {
    x: u64,
    y: i32,
    c: String,
}
```

### 2. `borsh(use_discriminant=<bool>)` (item level attribute)
This attribute is only applicable to enums.
`use_discriminant` allows to override the default behavior of serialization of enums with explicit discriminant.
`use_discriminant` is `false` behaves like version of borsh of 0.10.3.
You must specify `use_discriminant` for all enums with explicit discriminants in your project.

This is equivalent of borsh version 0.10.3 (explicit discriminant is ignored and this enum is equivalent to `A` without explicit discriminant):
```ignore
#[derive(BorshSerialize)]
#[borsh(use_discriminant = false)]
enum A {
    A
    B = 10,
}
```

To have explicit discriminant value serialized as is, you must specify `borsh(use_discriminant=true)` for enum.
```ignore
#[derive(BorshSerialize)]
#[borsh(use_discriminant = true)]
enum B {
    A
    B = 10,
}
```

###### borsh, expressions, evaluating to `isize`, as discriminant
This case is not supported:
```ignore
const fn discrim() -> isize {
    0x14
}

#[derive(BorshSerialize)]
#[borsh(use_discriminant = true)]
enum X {
    A,
    B = discrim(), // expressions, evaluating to `isize`, which are allowed outside of `borsh` context
    C,
    D,
    E = 10,
    F,
}
```

###### borsh explicit discriminant does not support literal values outside of u8 range
This is not supported:
```ignore
#[derive(BorshSerialize)]
#[borsh(use_discriminant = true)]
enum X {
    A,
    B = 0x100, // literal values outside of `u8` range
    C,
    D,
    E = 10,
    F,
}
```

### 3. `#[borsh(skip)]` (field level attribute)

`#[borsh(skip)]` makes derive skip serializing annotated field.

`#[borsh(skip)]` makes derive skip adding any type parameters, present in the field, to parameters bound by `borsh::ser::BorshSerialize`.

```ignore
#[derive(BorshSerialize)]
struct A {
    x: u64,
    #[borsh(skip)]
    y: f32,
}
```

### 4. `#[borsh(bound(serialize = ...))]` (field level attribute)

###### syntax

Attribute takes literal string value, which is a comma-separated list of syn's [WherePredicate](syn::WherePredicate)-s, which may be empty.

###### usage

Attribute adds possibility to override bounds for `BorshSerialize` in order to enable:

1. removal of bounds on type parameters from struct/enum definition itself and moving them to the trait's implementation block.
2. fixing complex cases, when derive hasn't figured out the right bounds on type parameters automatically.

```ignore
/// additional bound `T: Ord` (required by `HashMap`) is injected into
/// derived trait implementation via attribute to avoid adding the bounds on the struct itself
#[derive(BorshSerialize)]
struct A<T, U> {
    a: String,
    #[borsh(bound(serialize =
        "T: borsh::ser::BorshSerialize + Ord,
         U: borsh::ser::BorshSerialize"))]
    b: HashMap<T, U>,
}
```

```ignore
/// derive here figures the bound erroneously as `T: borsh::ser::BorshSerialize`
#[derive(BorshSerialize)]
struct A<T, V>
where
    T: TraitName,
{
    #[borsh(bound(serialize = "<T as TraitName>::Associated: borsh::ser::BorshSerialize"))]
    field: <T as TraitName>::Associated,
    another: V,
}
```

###### interaction with `#[borsh(skip)]`

`#[borsh(bound(serialize = ...))]` replaces bounds, which are derived automatically,
irrelevant of whether `#[borsh(skip)]` attribute is present.

### 5. `#[borsh(serialize_with = ...)]` (field level attribute)

###### syntax

Attribute takes literal string value, which is a syn's [ExprPath](syn::ExprPath).

###### usage

Attribute adds possibility to specify full path of function, optionally qualified with generics,
with which to serialize the annotated field.

It may be used when `BorshSerialize` cannot be implemented for field's type, if it's from foreign crate.

It may be used to override the implementation of serialization for some other reason.

```ignore
use indexmap::IndexMap;

mod index_map_impl {
    use super::IndexMap;
    use core::hash::Hash;

    pub fn serialize_index_map<
        K: borsh::ser::BorshSerialize,
        V: borsh::ser::BorshSerialize,
        W: borsh::io::Write,
    >(
        obj: &IndexMap<K, V>,
        writer: &mut W,
    ) -> ::core::result::Result<(), borsh::io::Error> {
        let key_value_tuples = obj.iter().collect::<Vec<_>>();
        borsh::BorshSerialize::serialize(&key_value_tuples, writer)?;
        Ok(())
    }
}

#[derive(BorshSerialize)]
struct B<K, V> {
    #[borsh(
        serialize_with = "index_map_impl::serialize_index_map",
    )]
    x: IndexMap<K, V>,
    y: String,
}
```

###### interaction with `#[borsh(skip)]`

`#[borsh(serialize_with = ...)]` is not allowed to be used simultaneously with `#[borsh(skip)]`.

*/
#[proc_macro_derive(BorshSerialize, attributes(borsh))]
pub fn borsh_serialize(input: TokenStream) -> TokenStream {
    let cratename = match check_attrs_get_cratename(&input) {
        Ok(cratename) => cratename,
        Err(err) => {
            return err.to_compile_error().into();
        }
    };

    let res = if let Ok(input) = syn::parse::<ItemStruct>(input.clone()) {
        serialize::structs::process(&input, cratename)
    } else if let Ok(input) = syn::parse::<ItemEnum>(input.clone()) {
        serialize::enums::process(&input, cratename)
    } else if let Ok(input) = syn::parse::<ItemUnion>(input) {
        serialize::unions::process(&input, cratename)
    } else {
        // Derive macros can only be defined on structs, enums, and unions.
        unreachable!()
    };
    TokenStream::from(match res {
        Ok(res) => res,
        Err(err) => err.to_compile_error(),
    })
}

/**
# derive proc-macro for `borsh::de::BorshDeserialize` trait

## Bounds

Generally, `BorshDeserialize` adds `borsh::de::BorshDeserialize` bound to any type parameter
found in item's fields and `core::default::Default` bound to any type parameter found
in item's skipped fields.

```ignore
/// impl<U, V> borsh::de::BorshDeserialize for A<U, V>
/// where
///     U: borsh::de::BorshDeserialize,
///     V: borsh::de::BorshDeserialize,
#[derive(BorshDeserialize)]
struct A<U, V> {
    x: U,
    y: V,
}
```

```ignore
/// impl<U, V> borsh::de::BorshDeserialize for A<U, V>
/// where
///     U: borsh::de::BorshDeserialize,
///     V: core::default::Default,
#[derive(BorshDeserialize)]
struct A<U, V> {
    x: U,
    #[borsh(skip)]
    y: V,
}
```

## Attributes

### 1. `#[borsh(crate = "path::to::borsh")]` (item level attribute)

###### syntax

Attribute takes literal string value, which is the syn's [Path] to `borsh` crate used.

###### usage

Attribute is optional.

1. If the attribute is not provided, [crate_name](proc_macro_crate::crate_name) is used to find a version of `borsh`
in `[dependencies]` of the relevant `Cargo.toml`. If there is no match, a compilation error, similar to the following, is raised:

```bash
 1  error: proc-macro derive panicked
   --> path/to/file.rs:27:10
    |
 27 | #[derive(BorshDeserialize, BorshSerialize)]
    |          ^^^^^^^^^^^^^^^^
    |
    = help: message: called `Result::unwrap()` on an `Err` value: CrateNotFound { crate_name: "borsh", path: "/path/to/Cargo.toml" }
```

2. If the attribute is provided, the check for `borsh` in `[dependencies]` of the relevant `Cargo.toml` is skipped.

Examples of usage:

```ignore
use reexporter::borsh::BorshDeserialize;

// specifying the attribute removes need for a direct import of `borsh` into `[dependencies]`
#[derive(BorshDeserialize)]
#[borsh(crate = "reexporter::borsh")]
struct B {
    x: u64,
    y: i32,
    c: String,
}
```

```ignore
use reexporter::borsh::{self, BorshDeserialize};

// specifying the attribute removes need for a direct import of `borsh` into `[dependencies]`
#[derive(BorshDeserialize)]
#[borsh(crate = "borsh")]
struct B {
    x: u64,
    y: i32,
    c: String,
}
```

### 2. `#[borsh(init=...)]` (item level attribute)

###### syntax

Attribute's value is syn's [Path]-s, passed to borsh top level meta attribute as value of `init` argument.

###### usage

`#[borsh(init=...)]` allows to automatically run an initialization function right after deserialization.
This adds a lot of convenience for objects that are architectured to be used as strictly immutable.

```ignore
#[derive(BorshDeserialize)]
#[borsh(init=init)]
struct Message {
    message: String,
    timestamp: u64,
    public_key: CryptoKey,
    signature: CryptoSignature,
    hash: CryptoHash,
}

impl Message {
    pub fn init(&mut self) {
        self.hash = CryptoHash::new().write_string(self.message).write_u64(self.timestamp);
        self.signature.verify(self.hash, self.public_key);
    }
}
```

### 3. `borsh(use_discriminant=<bool>)` (item level attribute)

This attribute is only applicable to enums.
`use_discriminant` allows to override the default behavior of serialization of enums with explicit discriminant.
`use_discriminant` is `false` behaves like version of borsh of 0.10.3.
It's useful for backward compatibility and you can set this value to `false` to deserialise data serialised by older version of `borsh`.
You must specify `use_discriminant` for all enums with explicit discriminants in your project.

This is equivalent of borsh version 0.10.3 (explicit discriminant is ignored and this enum is equivalent to `A` without explicit discriminant):
```ignore
#[derive(BorshDeserialize)]
#[borsh(use_discriminant = false)]
enum A {
    A
    B = 10,
}
```

To have explicit discriminant value serialized as is, you must specify `borsh(use_discriminant=true)` for enum.
```ignore
#[derive(BorshDeserialize)]
#[borsh(use_discriminant = true)]
enum B {
    A
    B = 10,
}
```

###### borsh, expressions, evaluating to `isize`, as discriminant
This case is not supported:
```ignore
const fn discrim() -> isize {
    0x14
}

#[derive(BorshDeserialize)]
#[borsh(use_discriminant = true)]
enum X {
    A,
    B = discrim(), // expressions, evaluating to `isize`, which are allowed outside of `borsh` context
    C,
    D,
    E = 10,
    F,
}
```

###### borsh explicit discriminant does not support literal values outside of u8 range.
This is not supported:
```ignore
#[derive(BorshDeserialize)]
#[borsh(use_discriminant = true)]
enum X {
    A,
    B = 0x100, // literal values outside of `u8` range
    C,
    D,
    E = 10,
    F,
}
```

### 4. `#[borsh(skip)]` (field level attribute)

`#[borsh(skip)]` makes derive skip deserializing annotated field.

`#[borsh(skip)]` makes derive skip adding any type parameters, present in the field, to parameters bound by `borsh::de::BorshDeserialize`.

It adds `core::default::Default` bound to any
parameters encountered in annotated field.

```ignore
#[derive(BorshDeserialize)]
struct A {
    x: u64,
    #[borsh(skip)]
    y: f32,
}
```

### 5. `#[borsh(bound(deserialize = ...))]` (field level attribute)

###### syntax

Attribute takes literal string value, which is a comma-separated list of syn's [WherePredicate](syn::WherePredicate)-s, which may be empty.

###### usage

Attribute adds possibility to override bounds for `BorshDeserialize` in order to enable:

1. removal of bounds on type parameters from struct/enum definition itself and moving them to the trait's implementation block.
2. fixing complex cases, when derive hasn't figured out the right bounds on type parameters automatically.

```ignore
/// additional bounds `T: Ord + Hash + Eq` (required by `HashMap`) are injected into
/// derived trait implementation via attribute to avoid adding the bounds on the struct itself
#[derive(BorshDeserialize)]
struct A<T, U> {
    a: String,
    #[borsh(bound(
        deserialize =
        "T: Ord + Hash + Eq + borsh::de::BorshDeserialize,
         U: borsh::de::BorshDeserialize"
    ))]
    b: HashMap<T, U>,
}
```

```ignore
// derive here figures the bound erroneously as `T: borsh::de::BorshDeserialize,`
#[derive(BorshDeserialize)]
struct A<T, V>
where
    T: TraitName,
{
    #[borsh(bound(deserialize = "<T as TraitName>::Associated: borsh::de::BorshDeserialize"))]
    field: <T as TraitName>::Associated,
    another: V,
}
```

###### interaction with `#[borsh(skip)]`

`#[borsh(bound(deserialize = ...))]` replaces bounds, which are derived automatically,
irrelevant of whether `#[borsh(skip)]` attribute is present.

```ignore
/// implicit derived `core::default::Default` bounds on `K` and `V` type parameters are removed by
/// empty bound specified, as `HashMap` has its own `Default` implementation
#[derive(BorshDeserialize)]
struct A<K, V, U>(
    #[borsh(skip, bound(deserialize = ""))]
    HashMap<K, V>,
    U,
);
```

### 6. `#[borsh(deserialize_with = ...)]` (field level attribute)

###### syntax

Attribute takes literal string value, which is a syn's [ExprPath](syn::ExprPath).

###### usage

Attribute adds possibility to specify full path of function, optionally qualified with generics,
with which to deserialize the annotated field.

It may be used when `BorshDeserialize` cannot be implemented for field's type, if it's from foreign crate.

It may be used to override the implementation of deserialization for some other reason.

```ignore
use indexmap::IndexMap;

mod index_map_impl {
    use super::IndexMap;
    use core::hash::Hash;

    pub fn deserialize_index_map<
        R: borsh::io::Read,
        K: borsh::de::BorshDeserialize + Hash + Eq,
        V: borsh::de::BorshDeserialize,
    >(
        reader: &mut R,
    ) -> ::core::result::Result<IndexMap<K, V>, borsh::io::Error> {
        let vec: Vec<(K, V)> = borsh::BorshDeserialize::deserialize_reader(reader)?;
        let result: IndexMap<K, V> = vec.into_iter().collect();
        Ok(result)
    }
}

#[derive(BorshDeserialize)]
struct B<K: Hash + Eq, V> {
    #[borsh(
        deserialize_with = "index_map_impl::deserialize_index_map",
    )]
    x: IndexMap<K, V>,
    y: String,
}
```

###### interaction with `#[borsh(skip)]`

`#[borsh(deserialize_with = ...)]` is not allowed to be used simultaneously with `#[borsh(skip)]`.

*/
#[proc_macro_derive(BorshDeserialize, attributes(borsh))]
pub fn borsh_deserialize(input: TokenStream) -> TokenStream {
    let cratename = match check_attrs_get_cratename(&input) {
        Ok(cratename) => cratename,
        Err(err) => {
            return err.to_compile_error().into();
        }
    };

    let res = if let Ok(input) = syn::parse::<ItemStruct>(input.clone()) {
        deserialize::structs::process(&input, cratename)
    } else if let Ok(input) = syn::parse::<ItemEnum>(input.clone()) {
        deserialize::enums::process(&input, cratename)
    } else if let Ok(input) = syn::parse::<ItemUnion>(input) {
        deserialize::unions::process(&input, cratename)
    } else {
        // Derive macros can only be defined on structs, enums, and unions.
        unreachable!()
    };
    TokenStream::from(match res {
        Ok(res) => res,
        Err(err) => err.to_compile_error(),
    })
}

/**
# derive proc-macro for `borsh::BorshSchema` trait

## Bounds

Generally, `BorshSchema` adds `borsh::BorshSchema` bound to any type parameter
found in item's fields.

```ignore
/// impl<U, V> borsh::BorshSchema for A<U, V>
/// where
///     U: borsh::BorshSchema,
///     V: borsh::BorshSchema,
#[derive(BorshSchema)]
struct A<U, V> {
    x: U,
    y: V,
}
```

```ignore
/// impl<U, V> borsh::BorshSchema for A<U, V>
/// where
///     U: borsh::BorshSchema,
#[derive(BorshSchema)]
struct A<U, V> {
    x: U,
    #[borsh(skip)]
    y: V,
}
```

## Attributes

### 1. `#[borsh(crate = "path::to::borsh")]` (item level attribute)

###### syntax

Attribute takes literal string value, which is the syn's [Path] to `borsh` crate used.

###### usage

Attribute is optional.

1. If the attribute is not provided, [crate_name](proc_macro_crate::crate_name) is used to find a version of `borsh`
in `[dependencies]` of the relevant `Cargo.toml`. If there is no match, a compilation error, similar to the following, is raised:

```bash
 1  error: proc-macro derive panicked
   --> path/to/file.rs:27:10
    |
 27 | #[derive(BorshSchema, BorshSerialize)]
    |          ^^^^^^^^^^^
    |
    = help: message: called `Result::unwrap()` on an `Err` value: CrateNotFound { crate_name: "borsh", path: "/path/to/Cargo.toml" }
```

2. If the attribute is provided, the check for `borsh` in `[dependencies]` of the relevant `Cargo.toml` is skipped.

Examples of usage:

```ignore
use reexporter::borsh::BorshSchema;

// specifying the attribute removes need for a direct import of `borsh` into `[dependencies]`
#[derive(BorshSchema)]
#[borsh(crate = "reexporter::borsh")]
struct B {
    x: u64,
    y: i32,
    c: String,
}
```

```ignore
use reexporter::borsh::{self, BorshSchema};

// specifying the attribute removes need for a direct import of `borsh` into `[dependencies]`
#[derive(BorshSchema)]
#[borsh(crate = "borsh")]
struct B {
    x: u64,
    y: i32,
    c: String,
}
```

### 2. `borsh(use_discriminant=<bool>)` (item level attribute)
This attribute is only applicable to enums.
`use_discriminant` allows to override the default behavior of serialization of enums with explicit discriminant.
`use_discriminant` is `false` behaves like version of borsh of 0.10.3.
You must specify `use_discriminant` for all enums with explicit discriminants in your project.

This is equivalent of borsh version 0.10.3 (explicit discriminant is ignored and this enum is equivalent to `A` without explicit discriminant):
```ignore
#[derive(BorshSchema)]
#[borsh(use_discriminant = false)]
enum A {
    A
    B = 10,
}
```

To have explicit discriminant value serialized as is, you must specify `borsh(use_discriminant=true)` for enum.
```ignore
#[derive(BorshSchema)]
#[borsh(use_discriminant = true)]
enum B {
    A
    B = 10,
}
```

###### borsh, expressions, evaluating to `isize`, as discriminant
This case is not supported:
```ignore
const fn discrim() -> isize {
    0x14
}

#[derive(BorshSchema)]
#[borsh(use_discriminant = true)]
enum X {
    A,
    B = discrim(), // expressions, evaluating to `isize`, which are allowed outside of `borsh` context
    C,
    D,
    E = 10,
    F,
}
```

###### borsh explicit discriminant does not support literal values outside of u8 range
This is not supported:
```ignore
#[derive(BorshSchema)]
#[borsh(use_discriminant = true)]
enum X {
    A,
    B = 0x100, // literal values outside of `u8` range
    C,
    D,
    E = 10,
    F,
}
```

### 3. `#[borsh(skip)]` (field level attribute)

`#[borsh(skip)]` makes derive skip including schema from annotated field into schema's implementation.

`#[borsh(skip)]` makes derive skip adding any type parameters, present in the field, to parameters bound by `borsh::BorshSchema`.

```ignore
#[derive(BorshSchema)]
struct A {
    x: u64,
    #[borsh(skip)]
    y: f32,
}
```

### 4. `#[borsh(schema(params = ...))]` (field level attribute)

###### syntax

Attribute takes literal string value, which is a comma-separated list of `ParameterOverride`-s, which may be empty.

###### usage
It may be used in order to:

1. fix complex cases, when derive hasn't figured out the right bounds on type parameters and
declaration parameters automatically.
2. remove parameters, which do not take part in serialization/deserialization, from bounded ones and from declaration parameters.

`ParameterOverride` describes an entry like `order_param => override_type`,

e.g. `K => <K as TraitName>::Associated`.

Such an entry instructs `BorshSchema` derive to:

1. add `override_type` to types, bounded by `borsh::BorshSchema` in implementation block.
2. add `<override_type>::declaration()` to parameters vector in `fn declaration()` method of `BorshSchema` trait that is being derived.
3. the `order_param` is required to establish the same order in parameters vector (2.) as that of type parameters in generics of type, that `BorshSchema` is derived for.
4. entries, specified for a field, together replace whatever would've been derived automatically for 1. and 2. .

```ignore
// derive here figures the bound erroneously as `T: borsh::BorshSchema` .
// attribute replaces it with <T as TraitName>::Associated: borsh::BorshSchema`
#[derive(BorshSchema)]
struct A<V, T>
where
    T: TraitName,
{
    #[borsh(schema(params = "T => <T as TraitName>::Associated"))]
    field: <T as TraitName>::Associated,
    another: V,
}
```

```ignore
// K in PrimaryMap isn't stored during serialization / read during deserialization.
// thus, it's not a parameter, relevant for `BorshSchema`
// ...
// impl<K: EntityRef, V> borsh::BorshSchema for A<K, V>
// where
//     V: borsh::BorshSchema,
#[derive(BorshSchema)]
struct A<K: EntityRef, V> {
    #[borsh(
        schema(
            params = "V => V"
        )
    )]
    x: PrimaryMap<K, V>,
    y: String,
}

#[derive(BorshSchema)]
pub struct PrimaryMap<K, V>
where
    K: EntityRef,
{
    elems: Vec<V>,
    unused: PhantomData<K>,
}
```

###### interaction with `#[borsh(skip)]`

`#[borsh(schema(params = ...))]` is not allowed to be used simultaneously with `#[borsh(skip)]`.

### 5. `#[borsh(schema(with_funcs(declaration = ..., definitions = ...)))]` (field level attribute)

###### syntax

Each of `declaration` and `definitions` nested sub-attributes takes literal string value, which is a syn's [ExprPath](syn::ExprPath).

Currently both `declaration` and `definitions` are required to be specified at the same time.

###### usage

Attribute adds possibility to specify full path of 2 functions, optionally qualified with generics,
with which to generate borsh schema for annotated field.

It may be used when `BorshSchema` cannot be implemented for field's type, if it's from foreign crate.

It may be used to override the implementation of schema for some other reason.

```ignore
use indexmap::IndexMap;

mod index_map_impl {
    pub mod schema {
        use std::collections::BTreeMap;

        use borsh::{
            schema::{Declaration, Definition},
            BorshSchema,
        };

        pub fn declaration<K: borsh::BorshSchema, V: borsh::BorshSchema>() -> Declaration {
            let params = vec![<K>::declaration(), <V>::declaration()];
            format!(r#"{}<{}>"#, "IndexMap", params.join(", "))
        }

        pub fn add_definitions_recursively<K: borsh::BorshSchema, V: borsh::BorshSchema>(
            definitions: &mut BTreeMap<Declaration, Definition>,
        ) {
            let definition = Definition::Sequence {
                elements: <(K, V)>::declaration(),
            };
            let no_recursion_flag = definitions.get(&declaration::<K, V>()).is_none();
            <() as BorshSchema>::add_definition(declaration::<K, V>(), definition, definitions);
            if no_recursion_flag {
                <(K, V)>::add_definitions_recursively(definitions);
            }
        }
    }
}

#[derive(BorshSchema)]
struct B<K, V> {
    #[borsh(
        schema(
            with_funcs(
                declaration = "index_map_impl::schema::declaration::<K, V>",
                definitions = "index_map_impl::schema::add_definitions_recursively::<K, V>"
            ),
        )
    )]
    x: IndexMap<K, V>,
    y: String,
}
```

###### interaction with `#[borsh(skip)]`

`#[borsh(schema(with_funcs(declaration = ..., definitions = ...)))]` is not allowed to be used simultaneously with `#[borsh(skip)]`.

*/
#[cfg(feature = "schema")]
#[proc_macro_derive(BorshSchema, attributes(borsh))]
pub fn borsh_schema(input: TokenStream) -> TokenStream {
    let cratename = match check_attrs_get_cratename(&input) {
        Ok(cratename) => cratename,
        Err(err) => {
            return err.to_compile_error().into();
        }
    };

    let res = if let Ok(input) = syn::parse::<ItemStruct>(input.clone()) {
        schema::structs::process(&input, cratename)
    } else if let Ok(input) = syn::parse::<ItemEnum>(input.clone()) {
        schema::enums::process(&input, cratename)
    } else if syn::parse::<ItemUnion>(input).is_ok() {
        Err(syn::Error::new(
            Span::call_site(),
            "Borsh schema does not support unions yet.",
        ))
    } else {
        // Derive macros can only be defined on structs, enums, and unions.
        unreachable!()
    };
    TokenStream::from(match res {
        Ok(res) => res,
        Err(err) => err.to_compile_error(),
    })
}

'''
'''--- borsh/Cargo.toml ---
[package]
name = "borsh"
version.workspace = true
rust-version.workspace = true
authors = ["Near Inc <hello@near.org>"]
edition = "2018"
license = "MIT OR Apache-2.0"
readme = "README.md"
categories = ["encoding", "network-programming"]
repository = "https://github.com/near/borsh-rs"
homepage = "https://borsh.io"
description = """
Binary Object Representation Serializer for Hashing
"""
exclude = ["*.snap"]

[lib]
name = "borsh"
path = "src/lib.rs"

[[bin]]
name = "generate_schema_schema"
path = "src/generate_schema_schema.rs"
required-features = ["std", "unstable__schema"]

[build-dependencies]
cfg_aliases = "0.1.0"

[dependencies]
ascii = { version = "1.1", optional = true }
borsh-derive = { path = "../borsh-derive", version = "~1.5.0", optional = true }

# hashbrown can be used in no-std context.
# NOTE: There is no reason to restrict use of older versions, but we don't want to get
# sudden breaking changes with an open range of versions, so we limit the range by not yet released 0.15.0 version:
hashbrown = { version = ">=0.11,<0.15.0", optional = true }
bytes = { version = "1", optional = true }
bson = { version = "2", optional = true }

[dev-dependencies]
insta = "1.29.0"

[package.metadata.docs.rs]
features = ["derive", "unstable__schema", "rc"]
targets = ["x86_64-unknown-linux-gnu"]

[features]
default = ["std"]
derive = ["borsh-derive"]
unstable__schema = ["derive", "borsh-derive/schema"]
std = []
# Opt into impls for Rc<T> and Arc<T>. Serializing and deserializing these types
# does not preserve identity and may result in multiple copies of the same data.
# Be sure that this is what you want before enabling this feature.
rc = []
de_strict_order = []

'''
'''--- borsh/README.md ---
# Borsh in Rust &emsp; [![Latest Version]][crates.io] [![borsh: rustc 1.67+]][Rust 1.67] [![License Apache-2.0 badge]][License Apache-2.0] [![License MIT badge]][License MIT]

[Borsh]: https://borsh.io
[Latest Version]: https://img.shields.io/crates/v/borsh.svg
[crates.io]: https://crates.io/crates/borsh
[borsh: rustc 1.67+]: https://img.shields.io/badge/rustc-1.67+-lightgray.svg
[Rust 1.67]: https://blog.rust-lang.org/2023/01/26/Rust-1.67.0.html
[License Apache-2.0 badge]: https://img.shields.io/badge/license-Apache2.0-blue.svg
[License Apache-2.0]: https://opensource.org/licenses/Apache-2.0
[License MIT badge]: https://img.shields.io/badge/license-MIT-blue.svg
[License MIT]: https://opensource.org/licenses/MIT

**borsh-rs** is Rust implementation of the [Borsh] binary serialization format.

Borsh stands for _Binary Object Representation Serializer for Hashing_. It is meant to be used in
security-critical projects as it prioritizes [consistency, safety, speed][Borsh], and comes with a
strict [specification](https://github.com/near/borsh#specification).

## Example

```rust
use borsh::{BorshSerialize, BorshDeserialize, from_slice, to_vec};

#[derive(BorshSerialize, BorshDeserialize, PartialEq, Debug)]
struct A {
    x: u64,
    y: String,
}

#[test]
fn test_simple_struct() {
    let a = A {
        x: 3301,
        y: "liber primus".to_string(),
    };
    let encoded_a = to_vec(&a).unwrap();
    let decoded_a = from_slice::<A>(&encoded_a).unwrap();
    assert_eq!(a, decoded_a);
}
```

## Features

Opting out from Serde allows borsh to have some features that currently are not available for serde-compatible serializers.
Currently we support two features: `borsh(init=<your initialization method name>` and `borsh(skip)` (the former one not available in Serde).

`borsh(init=...)` allows to automatically run an initialization function right after deserialization. This adds a lot of convenience for objects that are architectured to be used as strictly immutable. Usage example:

```rust
#[derive(BorshSerialize, BorshDeserialize)]
#[borsh(init=init)]
struct Message {
    message: String,
    timestamp: u64,
    public_key: CryptoKey,
    signature: CryptoSignature
    hash: CryptoHash
}

impl Message {
    pub fn init(&mut self) {
        self.hash = CryptoHash::new().write_string(self.message).write_u64(self.timestamp);
        self.signature.verify(self.hash, self.public_key);
    }
}
```

`borsh(skip)` allows to skip serializing/deserializing fields, assuming they implement `Default` trait, similarly to `#[serde(skip)]`.

```rust
#[derive(BorshSerialize, BorshDeserialize)]
struct A {
    x: u64,
    #[borsh(skip)]
    y: f32,
}
```

### Enum with explicit discriminant

`#[borsh(use_discriminant=false|true])` is required if you have an enum with explicit discriminant. This setting affects `BorshSerialize` and `BorshDeserialize` behaviour at the same time.

In the future, borsh will drop the requirement to explicitly use `#[borsh(use_discriminant=false|true)]`, and will default to `true`, but to make sure that the transition from the older versions of borsh (before 0.11 release) does not cause silent breaking changes in de-/serialization, borsh 1.0 will require to specify if the explicit enum discriminant should be used as a de-/serialization tag value.

If you don't specify `use_discriminant` option for enum with explicit discriminant, you will get an error:

```bash
error: You have to specify `#[borsh(use_discriminant=true)]` or `#[borsh(use_discriminant=false)]` for all enums with explicit discriminant
```

In order to preserve the behaviour of borsh versions before 0.11, which did not respect explicit enum discriminants for de-/serialization, use `#[borsh(use_discriminant=false)]`, otherwise, use `true`:

```rust
#[derive(BorshDeserialize, BorshSerialize)]
#[borsh(use_discriminant=false)]
enum A {
    X,
    Y = 10,
}
```

## Testing

Integration tests should generally be preferred to unit ones. Root module of integration tests of `borsh` crate is [linked](./borsh/tests/tests.rs) here.
 
## Releasing

The versions of all public crates in this repository are collectively managed by a single version in the [workspace manifest](https://github.com/near/borsh-rs/blob/master/Cargo.toml).

So, to publish a new version of all the crates, you can do so by simply bumping that to the next "patch" version and submit a PR.

We have CI Infrastructure put in place to automate the process of publishing all crates once a version change has merged into master.

However, before you release, make sure the [CHANGELOG](CHANGELOG.md) is up to date and that the `[Unreleased]` section is present but empty.

## License

This repository is distributed under the terms of both the MIT license and the Apache License (Version 2.0).
See [LICENSE-MIT](LICENSE-MIT) and [LICENSE-APACHE](LICENSE-APACHE) for details.

'''
'''--- borsh/build.rs ---
use cfg_aliases::cfg_aliases;

fn main() {
    cfg_aliases! {
        hash_collections: { any(feature = "hashbrown", feature = "std") },
    }
}

'''
'''--- borsh/src/de/hint.rs ---
#[inline]
pub fn cautious<T>(hint: u32) -> usize {
    let el_size = core::mem::size_of::<T>() as u32;
    core::cmp::max(core::cmp::min(hint, 4096 / el_size), 1) as usize
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    pub fn test_cautious_u8() {
        assert_eq!(cautious::<u8>(10), 10);
    }
}

'''
'''--- borsh/src/de/mod.rs ---
use core::marker::PhantomData;
use core::mem::MaybeUninit;
use core::{
    convert::{TryFrom, TryInto},
    mem::size_of,
};

#[cfg(feature = "bytes")]
use bytes::{BufMut, BytesMut};

use crate::__private::maybestd::{
    borrow::{Borrow, Cow, ToOwned},
    boxed::Box,
    collections::{BTreeMap, BTreeSet, LinkedList, VecDeque},
    format,
    string::{String, ToString},
    vec,
    vec::Vec,
};
use crate::io::{Error, ErrorKind, Read, Result};

use crate::error::check_zst;

mod hint;

const ERROR_NOT_ALL_BYTES_READ: &str = "Not all bytes read";
const ERROR_UNEXPECTED_LENGTH_OF_INPUT: &str = "Unexpected length of input";
const ERROR_OVERFLOW_ON_MACHINE_WITH_32_BIT_ISIZE: &str = "Overflow on machine with 32 bit isize";
const ERROR_OVERFLOW_ON_MACHINE_WITH_32_BIT_USIZE: &str = "Overflow on machine with 32 bit usize";
const ERROR_INVALID_ZERO_VALUE: &str = "Expected a non-zero value";

#[cfg(feature = "de_strict_order")]
const ERROR_WRONG_ORDER_OF_KEYS: &str = "keys were not serialized in ascending order";

/// A data-structure that can be de-serialized from binary format by NBOR.
pub trait BorshDeserialize: Sized {
    /// Deserializes this instance from a given slice of bytes.
    /// Updates the buffer to point at the remaining bytes.
    fn deserialize(buf: &mut &[u8]) -> Result<Self> {
        Self::deserialize_reader(&mut *buf)
    }

    fn deserialize_reader<R: Read>(reader: &mut R) -> Result<Self>;

    /// Deserialize this instance from a slice of bytes.
    fn try_from_slice(v: &[u8]) -> Result<Self> {
        let mut v_mut = v;
        let result = Self::deserialize(&mut v_mut)?;
        if !v_mut.is_empty() {
            return Err(Error::new(ErrorKind::InvalidData, ERROR_NOT_ALL_BYTES_READ));
        }
        Ok(result)
    }

    fn try_from_reader<R: Read>(reader: &mut R) -> Result<Self> {
        let result = Self::deserialize_reader(reader)?;
        let mut buf = [0u8; 1];
        match reader.read_exact(&mut buf) {
            Err(f) if f.kind() == ErrorKind::UnexpectedEof => Ok(result),
            _ => Err(Error::new(ErrorKind::InvalidData, ERROR_NOT_ALL_BYTES_READ)),
        }
    }

    #[inline]
    #[doc(hidden)]
    fn vec_from_reader<R: Read>(len: u32, reader: &mut R) -> Result<Option<Vec<Self>>> {
        let _ = len;
        let _ = reader;
        Ok(None)
    }

    #[inline]
    #[doc(hidden)]
    fn array_from_reader<R: Read, const N: usize>(reader: &mut R) -> Result<Option<[Self; N]>> {
        let _ = reader;
        Ok(None)
    }
}

/// Additional methods offered on enums which is used by `[derive(BorshDeserialize)]`.
pub trait EnumExt: BorshDeserialize {
    /// Deserialises given variant of an enum from the reader.
    ///
    /// This may be used to perform validation or filtering based on what
    /// variant is being deserialised.
    ///
    /// ```
    /// use borsh::BorshDeserialize;
    /// use borsh::de::EnumExt as _;
    ///
    /// /// derive is only available if borsh is built with `features = ["derive"]`
    /// # #[cfg(feature = "derive")]
    /// #[derive(Debug, PartialEq, Eq, BorshDeserialize)]
    /// enum MyEnum {
    ///     Zero,
    ///     One(u8),
    ///     Many(Vec<u8>)
    /// }
    ///
    /// # #[cfg(feature = "derive")]
    /// #[derive(Debug, PartialEq, Eq)]
    /// struct OneOrZero(MyEnum);
    ///
    /// # #[cfg(feature = "derive")]
    /// impl borsh::de::BorshDeserialize for OneOrZero {
    ///     fn deserialize_reader<R: borsh::io::Read>(
    ///         reader: &mut R,
    ///     ) -> borsh::io::Result<Self> {
    ///         use borsh::de::EnumExt;
    ///         let tag = u8::deserialize_reader(reader)?;
    ///         if tag == 2 {
    ///             Err(borsh::io::Error::new(
    ///                 borsh::io::ErrorKind::InvalidData,
    ///                 "MyEnum::Many not allowed here",
    ///             ))
    ///         } else {
    ///             MyEnum::deserialize_variant(reader, tag).map(Self)
    ///         }
    ///     }
    /// }
    ///
    /// use borsh::from_slice;
    /// let data = b"\0";
    /// # #[cfg(feature = "derive")]
    /// assert_eq!(MyEnum::Zero, from_slice::<MyEnum>(&data[..]).unwrap());
    /// # #[cfg(feature = "derive")]
    /// assert_eq!(MyEnum::Zero, from_slice::<OneOrZero>(&data[..]).unwrap().0);
    ///
    /// let data = b"\x02\0\0\0\0";
    /// # #[cfg(feature = "derive")]
    /// assert_eq!(MyEnum::Many(Vec::new()), from_slice::<MyEnum>(&data[..]).unwrap());
    /// # #[cfg(feature = "derive")]
    /// assert!(from_slice::<OneOrZero>(&data[..]).is_err());
    /// ```
    fn deserialize_variant<R: Read>(reader: &mut R, tag: u8) -> Result<Self>;
}

fn unexpected_eof_to_unexpected_length_of_input(e: Error) -> Error {
    if e.kind() == ErrorKind::UnexpectedEof {
        Error::new(ErrorKind::InvalidData, ERROR_UNEXPECTED_LENGTH_OF_INPUT)
    } else {
        e
    }
}

impl BorshDeserialize for u8 {
    #[inline]
    fn deserialize_reader<R: Read>(reader: &mut R) -> Result<Self> {
        let mut buf = [0u8; 1];
        reader
            .read_exact(&mut buf)
            .map_err(unexpected_eof_to_unexpected_length_of_input)?;
        Ok(buf[0])
    }

    #[inline]
    #[doc(hidden)]
    fn vec_from_reader<R: Read>(len: u32, reader: &mut R) -> Result<Option<Vec<Self>>> {
        let len: usize = len.try_into().map_err(|_| ErrorKind::InvalidData)?;
        // Avoid OOM by limiting the size of allocation.  This makes the read
        // less efficient (since we need to loop and reallocate) but it protects
        // us from someone sending us [0xff, 0xff, 0xff, 0xff] and forcing us to
        // allocate 4GiB of memory.
        let mut vec = vec![0u8; len.min(1024 * 1024)];
        let mut pos = 0;
        while pos < len {
            if pos == vec.len() {
                vec.resize(vec.len().saturating_mul(2).min(len), 0)
            }
            // TODO(mina86): Convert this to read_buf once that stabilises.
            match reader.read(&mut vec.as_mut_slice()[pos..])? {
                0 => {
                    return Err(Error::new(
                        ErrorKind::InvalidData,
                        ERROR_UNEXPECTED_LENGTH_OF_INPUT,
                    ))
                }
                read => {
                    pos += read;
                }
            }
        }
        Ok(Some(vec))
    }

    #[inline]
    #[doc(hidden)]
    fn array_from_reader<R: Read, const N: usize>(reader: &mut R) -> Result<Option<[Self; N]>> {
        let mut arr = [0u8; N];
        reader
            .read_exact(&mut arr)
            .map_err(unexpected_eof_to_unexpected_length_of_input)?;
        Ok(Some(arr))
    }
}

macro_rules! impl_for_integer {
    ($type: ident) => {
        impl BorshDeserialize for $type {
            #[inline]
            fn deserialize_reader<R: Read>(reader: &mut R) -> Result<Self> {
                let mut buf = [0u8; size_of::<$type>()];
                reader
                    .read_exact(&mut buf)
                    .map_err(unexpected_eof_to_unexpected_length_of_input)?;
                let res = $type::from_le_bytes(buf.try_into().unwrap());
                Ok(res)
            }
        }
    };
}

impl_for_integer!(i8);
impl_for_integer!(i16);
impl_for_integer!(i32);
impl_for_integer!(i64);
impl_for_integer!(i128);
impl_for_integer!(u16);
impl_for_integer!(u32);
impl_for_integer!(u64);
impl_for_integer!(u128);

macro_rules! impl_for_nonzero_integer {
    ($type: ty) => {
        impl BorshDeserialize for $type {
            #[inline]
            fn deserialize_reader<R: Read>(reader: &mut R) -> Result<Self> {
                <$type>::new(BorshDeserialize::deserialize_reader(reader)?)
                    .ok_or_else(|| Error::new(ErrorKind::InvalidData, ERROR_INVALID_ZERO_VALUE))
            }
        }
    };
}

impl_for_nonzero_integer!(core::num::NonZeroI8);
impl_for_nonzero_integer!(core::num::NonZeroI16);
impl_for_nonzero_integer!(core::num::NonZeroI32);
impl_for_nonzero_integer!(core::num::NonZeroI64);
impl_for_nonzero_integer!(core::num::NonZeroI128);
impl_for_nonzero_integer!(core::num::NonZeroU8);
impl_for_nonzero_integer!(core::num::NonZeroU16);
impl_for_nonzero_integer!(core::num::NonZeroU32);
impl_for_nonzero_integer!(core::num::NonZeroU64);
impl_for_nonzero_integer!(core::num::NonZeroU128);
impl_for_nonzero_integer!(core::num::NonZeroUsize);

impl BorshDeserialize for isize {
    fn deserialize_reader<R: Read>(reader: &mut R) -> Result<Self> {
        let i: i64 = BorshDeserialize::deserialize_reader(reader)?;
        let i = isize::try_from(i).map_err(|_| {
            Error::new(
                ErrorKind::InvalidData,
                ERROR_OVERFLOW_ON_MACHINE_WITH_32_BIT_ISIZE,
            )
        })?;
        Ok(i)
    }
}

impl BorshDeserialize for usize {
    fn deserialize_reader<R: Read>(reader: &mut R) -> Result<Self> {
        let u: u64 = BorshDeserialize::deserialize_reader(reader)?;
        let u = usize::try_from(u).map_err(|_| {
            Error::new(
                ErrorKind::InvalidData,
                ERROR_OVERFLOW_ON_MACHINE_WITH_32_BIT_USIZE,
            )
        })?;
        Ok(u)
    }
}

// Note NaNs have a portability issue. Specifically, signalling NaNs on MIPS are quiet NaNs on x86,
// and vice-versa. We disallow NaNs to avoid this issue.
macro_rules! impl_for_float {
    ($type: ident, $int_type: ident) => {
        impl BorshDeserialize for $type {
            #[inline]
            fn deserialize_reader<R: Read>(reader: &mut R) -> Result<Self> {
                let mut buf = [0u8; size_of::<$type>()];
                reader
                    .read_exact(&mut buf)
                    .map_err(unexpected_eof_to_unexpected_length_of_input)?;
                let res = $type::from_bits($int_type::from_le_bytes(buf.try_into().unwrap()));
                if res.is_nan() {
                    return Err(Error::new(
                        ErrorKind::InvalidData,
                        "For portability reasons we do not allow to deserialize NaNs.",
                    ));
                }
                Ok(res)
            }
        }
    };
}

impl_for_float!(f32, u32);
impl_for_float!(f64, u64);

impl BorshDeserialize for bool {
    #[inline]
    fn deserialize_reader<R: Read>(reader: &mut R) -> Result<Self> {
        let b: u8 = BorshDeserialize::deserialize_reader(reader)?;
        if b == 0 {
            Ok(false)
        } else if b == 1 {
            Ok(true)
        } else {
            let msg = format!("Invalid bool representation: {}", b);

            Err(Error::new(ErrorKind::InvalidData, msg))
        }
    }
}

impl<T> BorshDeserialize for Option<T>
where
    T: BorshDeserialize,
{
    #[inline]
    fn deserialize_reader<R: Read>(reader: &mut R) -> Result<Self> {
        let flag: u8 = BorshDeserialize::deserialize_reader(reader)?;
        if flag == 0 {
            Ok(None)
        } else if flag == 1 {
            Ok(Some(T::deserialize_reader(reader)?))
        } else {
            let msg = format!(
                "Invalid Option representation: {}. The first byte must be 0 or 1",
                flag
            );

            Err(Error::new(ErrorKind::InvalidData, msg))
        }
    }
}

impl<T, E> BorshDeserialize for core::result::Result<T, E>
where
    T: BorshDeserialize,
    E: BorshDeserialize,
{
    #[inline]
    fn deserialize_reader<R: Read>(reader: &mut R) -> Result<Self> {
        let flag: u8 = BorshDeserialize::deserialize_reader(reader)?;
        if flag == 0 {
            Ok(Err(E::deserialize_reader(reader)?))
        } else if flag == 1 {
            Ok(Ok(T::deserialize_reader(reader)?))
        } else {
            let msg = format!(
                "Invalid Result representation: {}. The first byte must be 0 or 1",
                flag
            );

            Err(Error::new(ErrorKind::InvalidData, msg))
        }
    }
}

impl BorshDeserialize for String {
    #[inline]
    fn deserialize_reader<R: Read>(reader: &mut R) -> Result<Self> {
        String::from_utf8(Vec::<u8>::deserialize_reader(reader)?).map_err(|err| {
            let msg = err.to_string();
            Error::new(ErrorKind::InvalidData, msg)
        })
    }
}

/// Module is available if borsh is built with `features = ["ascii"]`.
#[cfg(feature = "ascii")]
pub mod ascii {
    //!
    //! Module defines [BorshDeserialize] implementation for
    //! some types from [ascii](::ascii) crate.
    use crate::BorshDeserialize;
    use crate::__private::maybestd::{string::ToString, vec::Vec};
    use crate::io::{Error, ErrorKind, Read, Result};

    impl BorshDeserialize for ascii::AsciiString {
        #[inline]
        fn deserialize_reader<R: Read>(reader: &mut R) -> Result<Self> {
            let bytes = Vec::<u8>::deserialize_reader(reader)?;
            ascii::AsciiString::from_ascii(bytes)
                .map_err(|err| Error::new(ErrorKind::InvalidData, err.to_string()))
        }
    }

    impl BorshDeserialize for ascii::AsciiChar {
        #[inline]
        fn deserialize_reader<R: Read>(reader: &mut R) -> Result<Self> {
            let byte = u8::deserialize_reader(reader)?;
            ascii::AsciiChar::from_ascii(byte)
                .map_err(|err| Error::new(ErrorKind::InvalidData, err.to_string()))
        }
    }
}

impl<T> BorshDeserialize for Vec<T>
where
    T: BorshDeserialize,
{
    #[inline]
    fn deserialize_reader<R: Read>(reader: &mut R) -> Result<Self> {
        check_zst::<T>()?;

        let len = u32::deserialize_reader(reader)?;
        if len == 0 {
            Ok(Vec::new())
        } else if let Some(vec_bytes) = T::vec_from_reader(len, reader)? {
            Ok(vec_bytes)
        } else {
            // TODO(16): return capacity allocation when we can safely do that.
            let mut result = Vec::with_capacity(hint::cautious::<T>(len));
            for _ in 0..len {
                result.push(T::deserialize_reader(reader)?);
            }
            Ok(result)
        }
    }
}

#[cfg(feature = "bytes")]
impl BorshDeserialize for bytes::Bytes {
    #[inline]
    fn deserialize_reader<R: Read>(reader: &mut R) -> Result<Self> {
        let vec = <Vec<u8>>::deserialize_reader(reader)?;
        Ok(vec.into())
    }
}

#[cfg(feature = "bytes")]
impl BorshDeserialize for bytes::BytesMut {
    #[inline]
    fn deserialize_reader<R: Read>(reader: &mut R) -> Result<Self> {
        let len = u32::deserialize_reader(reader)?;
        let mut out = BytesMut::with_capacity(hint::cautious::<u8>(len));
        for _ in 0..len {
            out.put_u8(u8::deserialize_reader(reader)?);
        }
        Ok(out)
    }
}

#[cfg(feature = "bson")]
impl BorshDeserialize for bson::oid::ObjectId {
    #[inline]
    fn deserialize_reader<R: Read>(reader: &mut R) -> Result<Self> {
        let mut buf = [0u8; 12];
        reader.read_exact(&mut buf)?;
        Ok(bson::oid::ObjectId::from_bytes(buf))
    }
}

impl<T> BorshDeserialize for Cow<'_, T>
where
    T: ToOwned + ?Sized,
    T::Owned: BorshDeserialize,
{
    #[inline]
    fn deserialize_reader<R: Read>(reader: &mut R) -> Result<Self> {
        Ok(Cow::Owned(BorshDeserialize::deserialize_reader(reader)?))
    }
}

impl<T> BorshDeserialize for VecDeque<T>
where
    T: BorshDeserialize,
{
    #[inline]
    fn deserialize_reader<R: Read>(reader: &mut R) -> Result<Self> {
        let vec = <Vec<T>>::deserialize_reader(reader)?;
        Ok(vec.into())
    }
}

impl<T> BorshDeserialize for LinkedList<T>
where
    T: BorshDeserialize,
{
    #[inline]
    fn deserialize_reader<R: Read>(reader: &mut R) -> Result<Self> {
        let vec = <Vec<T>>::deserialize_reader(reader)?;
        Ok(vec.into_iter().collect::<LinkedList<T>>())
    }
}

/// Module is available if borsh is built with `features = ["std"]` or `features = ["hashbrown"]`.
#[cfg(hash_collections)]
pub mod hashes {
    //!
    //! Module defines [BorshDeserialize] implementation for
    //! [HashMap](std::collections::HashMap)/[HashSet](std::collections::HashSet).
    use core::hash::{BuildHasher, Hash};

    use crate::BorshDeserialize;
    use crate::__private::maybestd::collections::{HashMap, HashSet};
    use crate::__private::maybestd::vec::Vec;
    use crate::io::{Read, Result};

    #[cfg(feature = "de_strict_order")]
    const ERROR_WRONG_ORDER_OF_KEYS: &str = "keys were not serialized in ascending order";
    use crate::error::check_zst;
    #[cfg(feature = "de_strict_order")]
    use crate::io::{Error, ErrorKind};

    impl<T, H> BorshDeserialize for HashSet<T, H>
    where
        T: BorshDeserialize + Eq + Hash + Ord,
        H: BuildHasher + Default,
    {
        #[inline]
        fn deserialize_reader<R: Read>(reader: &mut R) -> Result<Self> {
            // NOTE: deserialize-as-you-go approach as once was in HashSet is better in the sense
            // that it allows to fail early, and not allocate memory for all the elements
            // which may fail `cmp()` checks
            // NOTE: deserialize first to `Vec<T>` is faster
            let vec = <Vec<T>>::deserialize_reader(reader)?;

            #[cfg(feature = "de_strict_order")]
            // TODO: replace with `is_sorted` api when stabilizes https://github.com/rust-lang/rust/issues/53485
            // TODO: first replace with `array_windows` api when stabilizes https://github.com/rust-lang/rust/issues/75027
            for pair in vec.windows(2) {
                let [a, b] = pair else {
                    unreachable!("`windows` always return a slice of length 2 or nothing");
                };
                let cmp_result = a.cmp(b).is_lt();
                if !cmp_result {
                    return Err(Error::new(
                        ErrorKind::InvalidData,
                        ERROR_WRONG_ORDER_OF_KEYS,
                    ));
                }
            }

            Ok(vec.into_iter().collect::<HashSet<T, H>>())
        }
    }

    impl<K, V, H> BorshDeserialize for HashMap<K, V, H>
    where
        K: BorshDeserialize + Eq + Hash + Ord,
        V: BorshDeserialize,
        H: BuildHasher + Default,
    {
        #[inline]
        fn deserialize_reader<R: Read>(reader: &mut R) -> Result<Self> {
            check_zst::<K>()?;
            // NOTE: deserialize-as-you-go approach as once was in HashSet is better in the sense
            // that it allows to fail early, and not allocate memory for all the entries
            // which may fail `cmp()` checks
            // NOTE: deserialize first to `Vec<(K, V)>` is faster
            let vec = <Vec<(K, V)>>::deserialize_reader(reader)?;

            #[cfg(feature = "de_strict_order")]
            // TODO: replace with `is_sorted` api when stabilizes https://github.com/rust-lang/rust/issues/53485
            // TODO: first replace with `array_windows` api when stabilizes https://github.com/rust-lang/rust/issues/75027
            for pair in vec.windows(2) {
                let [(a_k, _a_v), (b_k, _b_v)] = pair else {
                    unreachable!("`windows` always return a slice of length 2 or nothing");
                };
                let cmp_result = a_k.cmp(b_k).is_lt();
                if !cmp_result {
                    return Err(Error::new(
                        ErrorKind::InvalidData,
                        ERROR_WRONG_ORDER_OF_KEYS,
                    ));
                }
            }

            Ok(vec.into_iter().collect::<HashMap<K, V, H>>())
        }
    }
}

impl<T> BorshDeserialize for BTreeSet<T>
where
    T: BorshDeserialize + Ord,
{
    #[inline]
    fn deserialize_reader<R: Read>(reader: &mut R) -> Result<Self> {
        // NOTE: deserialize-as-you-go approach as once was in HashSet is better in the sense
        // that it allows to fail early, and not allocate memory for all the elements
        // which may fail `cmp()` checks
        // NOTE: deserialize first to `Vec<T>` is faster
        let vec = <Vec<T>>::deserialize_reader(reader)?;

        #[cfg(feature = "de_strict_order")]
        // TODO: replace with `is_sorted` api when stabilizes https://github.com/rust-lang/rust/issues/53485
        // TODO: first replace with `array_windows` api when stabilizes https://github.com/rust-lang/rust/issues/75027
        for pair in vec.windows(2) {
            let [a, b] = pair else {
                unreachable!("`windows` always return a slice of length 2 or nothing");
            };
            let cmp_result = a.cmp(b).is_lt();
            if !cmp_result {
                return Err(Error::new(
                    ErrorKind::InvalidData,
                    ERROR_WRONG_ORDER_OF_KEYS,
                ));
            }
        }
        // NOTE: BTreeSet has an optimization inside of impl <T> FromIterator<T> for BTreeSet<T, Global>,
        // based on BTreeMap::bulk_build_from_sorted_iter
        Ok(vec.into_iter().collect::<BTreeSet<T>>())
    }
}

impl<K, V> BorshDeserialize for BTreeMap<K, V>
where
    K: BorshDeserialize + Ord,
    V: BorshDeserialize,
{
    #[inline]
    fn deserialize_reader<R: Read>(reader: &mut R) -> Result<Self> {
        check_zst::<K>()?;
        // NOTE: deserialize-as-you-go approach as once was in HashSet is better in the sense
        // that it allows to fail early, and not allocate memory for all the entries
        // which may fail `cmp()` checks
        // NOTE: deserialize first to `Vec<(K, V)>` is faster
        let vec = <Vec<(K, V)>>::deserialize_reader(reader)?;

        #[cfg(feature = "de_strict_order")]
        // TODO: replace with `is_sorted` api when stabilizes https://github.com/rust-lang/rust/issues/53485
        // TODO: first replace with `array_windows` api when stabilizes https://github.com/rust-lang/rust/issues/75027
        for pair in vec.windows(2) {
            let [(a_k, _a_v), (b_k, _b_v)] = pair else {
                unreachable!("`windows` always return a slice of length 2 or nothing");
            };
            let cmp_result = a_k.cmp(b_k).is_lt();
            if !cmp_result {
                return Err(Error::new(
                    ErrorKind::InvalidData,
                    ERROR_WRONG_ORDER_OF_KEYS,
                ));
            }
        }

        // NOTE: BTreeMap has an optimization inside of impl<K, V> FromIterator<(K, V)> for BTreeMap<K, V, Global>,
        // based on BTreeMap::bulk_build_from_sorted_iter
        Ok(vec.into_iter().collect::<BTreeMap<K, V>>())
    }
}

#[cfg(feature = "std")]
impl BorshDeserialize for std::net::SocketAddr {
    #[inline]
    fn deserialize_reader<R: Read>(reader: &mut R) -> Result<Self> {
        let kind = u8::deserialize_reader(reader)?;
        match kind {
            0 => std::net::SocketAddrV4::deserialize_reader(reader).map(std::net::SocketAddr::V4),
            1 => std::net::SocketAddrV6::deserialize_reader(reader).map(std::net::SocketAddr::V6),
            value => Err(Error::new(
                ErrorKind::InvalidData,
                format!("Invalid SocketAddr variant: {}", value),
            )),
        }
    }
}

#[cfg(feature = "std")]
impl BorshDeserialize for std::net::SocketAddrV4 {
    #[inline]
    fn deserialize_reader<R: Read>(reader: &mut R) -> Result<Self> {
        let ip = std::net::Ipv4Addr::deserialize_reader(reader)?;
        let port = u16::deserialize_reader(reader)?;
        Ok(std::net::SocketAddrV4::new(ip, port))
    }
}

#[cfg(feature = "std")]
impl BorshDeserialize for std::net::SocketAddrV6 {
    #[inline]
    fn deserialize_reader<R: Read>(reader: &mut R) -> Result<Self> {
        let ip = std::net::Ipv6Addr::deserialize_reader(reader)?;
        let port = u16::deserialize_reader(reader)?;
        Ok(std::net::SocketAddrV6::new(ip, port, 0, 0))
    }
}

#[cfg(feature = "std")]
impl BorshDeserialize for std::net::Ipv4Addr {
    #[inline]
    fn deserialize_reader<R: Read>(reader: &mut R) -> Result<Self> {
        let mut buf = [0u8; 4];
        reader
            .read_exact(&mut buf)
            .map_err(unexpected_eof_to_unexpected_length_of_input)?;
        Ok(std::net::Ipv4Addr::from(buf))
    }
}

#[cfg(feature = "std")]
impl BorshDeserialize for std::net::Ipv6Addr {
    #[inline]
    fn deserialize_reader<R: Read>(reader: &mut R) -> Result<Self> {
        let mut buf = [0u8; 16];
        reader
            .read_exact(&mut buf)
            .map_err(unexpected_eof_to_unexpected_length_of_input)?;
        Ok(std::net::Ipv6Addr::from(buf))
    }
}

impl<T, U> BorshDeserialize for Box<T>
where
    U: Into<Box<T>> + Borrow<T>,
    T: ToOwned<Owned = U> + ?Sized,
    T::Owned: BorshDeserialize,
{
    fn deserialize_reader<R: Read>(reader: &mut R) -> Result<Self> {
        Ok(T::Owned::deserialize_reader(reader)?.into())
    }
}

impl<T, const N: usize> BorshDeserialize for [T; N]
where
    T: BorshDeserialize,
{
    #[inline]
    fn deserialize_reader<R: Read>(reader: &mut R) -> Result<Self> {
        struct ArrayDropGuard<T, const N: usize> {
            buffer: [MaybeUninit<T>; N],
            init_count: usize,
        }
        impl<T, const N: usize> Drop for ArrayDropGuard<T, N> {
            fn drop(&mut self) {
                let init_range = &mut self.buffer[..self.init_count];
                // SAFETY: Elements up to self.init_count have been initialized. Assumes this value
                //         is only incremented in `fill_buffer`, which writes the element before
                //         increasing the init_count.
                unsafe {
                    core::ptr::drop_in_place(init_range as *mut _ as *mut [T]);
                };
            }
        }
        impl<T, const N: usize> ArrayDropGuard<T, N> {
            unsafe fn transmute_to_array(mut self) -> [T; N] {
                debug_assert_eq!(self.init_count, N);
                // Set init_count to 0 so that the values do not get dropped twice.
                self.init_count = 0;
                // SAFETY: This cast is required because `mem::transmute` does not work with
                //         const generics https://github.com/rust-lang/rust/issues/61956. This
                //         array is guaranteed to be initialized by this point.
                core::ptr::read(&self.buffer as *const _ as *const [T; N])
            }
            fn fill_buffer(&mut self, mut f: impl FnMut() -> Result<T>) -> Result<()> {
                // TODO: replace with `core::array::try_from_fn` when stabilized to avoid manually
                // dropping uninitialized values through the guard drop.
                for elem in self.buffer.iter_mut() {
                    elem.write(f()?);
                    self.init_count += 1;
                }
                Ok(())
            }
        }

        if let Some(arr) = T::array_from_reader(reader)? {
            Ok(arr)
        } else {
            let mut result = ArrayDropGuard {
                buffer: unsafe { MaybeUninit::uninit().assume_init() },
                init_count: 0,
            };

            result.fill_buffer(|| T::deserialize_reader(reader))?;

            // SAFETY: The elements up to `i` have been initialized in `fill_buffer`.
            Ok(unsafe { result.transmute_to_array() })
        }
    }
}

#[test]
fn array_deserialization_doesnt_leak() {
    use core::sync::atomic::{AtomicUsize, Ordering};

    static DESERIALIZE_COUNT: AtomicUsize = AtomicUsize::new(0);
    static DROP_COUNT: AtomicUsize = AtomicUsize::new(0);

    #[allow(unused)]
    struct MyType(u8);
    impl BorshDeserialize for MyType {
        fn deserialize_reader<R: Read>(reader: &mut R) -> Result<Self> {
            let val = u8::deserialize_reader(reader)?;
            let v = DESERIALIZE_COUNT.fetch_add(1, Ordering::SeqCst);
            if v >= 7 {
                panic!("panic in deserialize");
            }
            Ok(MyType(val))
        }
    }
    impl Drop for MyType {
        fn drop(&mut self) {
            DROP_COUNT.fetch_add(1, Ordering::SeqCst);
        }
    }

    assert!(<[MyType; 5] as BorshDeserialize>::deserialize(&mut &[0u8; 3][..]).is_err());
    assert_eq!(DESERIALIZE_COUNT.load(Ordering::SeqCst), 3);
    assert_eq!(DROP_COUNT.load(Ordering::SeqCst), 3);

    assert!(<[MyType; 2] as BorshDeserialize>::deserialize(&mut &[0u8; 2][..]).is_ok());
    assert_eq!(DESERIALIZE_COUNT.load(Ordering::SeqCst), 5);
    assert_eq!(DROP_COUNT.load(Ordering::SeqCst), 5);

    #[cfg(feature = "std")]
    {
        // Test that during a panic in deserialize, the values are still dropped.
        let result = std::panic::catch_unwind(|| {
            <[MyType; 3] as BorshDeserialize>::deserialize(&mut &[0u8; 3][..]).unwrap();
        });
        assert!(result.is_err());
        assert_eq!(DESERIALIZE_COUNT.load(Ordering::SeqCst), 8);
        assert_eq!(DROP_COUNT.load(Ordering::SeqCst), 7); // 5 because 6 panicked and was not init
    }
}

macro_rules! impl_tuple {
    (@unit $name:ty) => {
        impl BorshDeserialize for $name {
            #[inline]
            fn deserialize_reader<R: Read>(_reader: &mut R) -> Result<Self> {
                Ok(<$name>::default())
            }
        }
    };

    ($($name:ident)+) => {
      impl<$($name),+> BorshDeserialize for ($($name,)+)
      where $($name: BorshDeserialize,)+
      {
        #[inline]
        fn deserialize_reader<R: Read>(reader: &mut R) -> Result<Self> {

            Ok(($($name::deserialize_reader(reader)?,)+))
        }
      }
    };
}

impl_tuple!(@unit ());
impl_tuple!(@unit core::ops::RangeFull);

impl_tuple!(T0);
impl_tuple!(T0 T1);
impl_tuple!(T0 T1 T2);
impl_tuple!(T0 T1 T2 T3);
impl_tuple!(T0 T1 T2 T3 T4);
impl_tuple!(T0 T1 T2 T3 T4 T5);
impl_tuple!(T0 T1 T2 T3 T4 T5 T6);
impl_tuple!(T0 T1 T2 T3 T4 T5 T6 T7);
impl_tuple!(T0 T1 T2 T3 T4 T5 T6 T7 T8);
impl_tuple!(T0 T1 T2 T3 T4 T5 T6 T7 T8 T9);
impl_tuple!(T0 T1 T2 T3 T4 T5 T6 T7 T8 T9 T10);
impl_tuple!(T0 T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11);
impl_tuple!(T0 T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12);
impl_tuple!(T0 T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13);
impl_tuple!(T0 T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14);
impl_tuple!(T0 T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 T15);
impl_tuple!(T0 T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 T15 T16);
impl_tuple!(T0 T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 T15 T16 T17);
impl_tuple!(T0 T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 T15 T16 T17 T18);
impl_tuple!(T0 T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13 T14 T15 T16 T17 T18 T19);

macro_rules! impl_range {
    ($type:ident, $make:expr, $($side:ident),*) => {
        impl<T: BorshDeserialize> BorshDeserialize for core::ops::$type<T> {
            #[inline]
            fn deserialize_reader<R: Read>(reader: &mut R) -> Result<Self> {
                let ($($side,)*) = <_>::deserialize_reader(reader)?;
                Ok($make)
            }
        }
    };
}

impl_range!(Range, start..end, start, end);
impl_range!(RangeInclusive, start..=end, start, end);
impl_range!(RangeFrom, start.., start);
impl_range!(RangeTo, ..end, end);
impl_range!(RangeToInclusive, ..=end, end);

/// Module is available if borsh is built with `features = ["rc"]`.
#[cfg(feature = "rc")]
pub mod rc {
    //!
    //! Module defines [BorshDeserialize] implementation for
    //! [alloc::rc::Rc](std::rc::Rc) and [alloc::sync::Arc](std::sync::Arc).
    use crate::__private::maybestd::{boxed::Box, rc::Rc, sync::Arc};
    use crate::io::{Read, Result};
    use crate::BorshDeserialize;

    /// This impl requires the [`"rc"`] Cargo feature of borsh.
    ///
    /// Deserializing a data structure containing `Rc` will not attempt to
    /// deduplicate `Rc` references to the same data. Every deserialized `Rc`
    /// will end up with a strong count of 1.
    impl<T: ?Sized> BorshDeserialize for Rc<T>
    where
        Box<T>: BorshDeserialize,
    {
        fn deserialize_reader<R: Read>(reader: &mut R) -> Result<Self> {
            Ok(Box::<T>::deserialize_reader(reader)?.into())
        }
    }

    /// This impl requires the [`"rc"`] Cargo feature of borsh.
    ///
    /// Deserializing a data structure containing `Arc` will not attempt to
    /// deduplicate `Arc` references to the same data. Every deserialized `Arc`
    /// will end up with a strong count of 1.
    impl<T: ?Sized> BorshDeserialize for Arc<T>
    where
        Box<T>: BorshDeserialize,
    {
        fn deserialize_reader<R: Read>(reader: &mut R) -> Result<Self> {
            Ok(Box::<T>::deserialize_reader(reader)?.into())
        }
    }
}

impl<T: ?Sized> BorshDeserialize for PhantomData<T> {
    fn deserialize_reader<R: Read>(_: &mut R) -> Result<Self> {
        Ok(PhantomData)
    }
}

impl<T> BorshDeserialize for core::cell::Cell<T>
where
    T: BorshDeserialize + Copy,
{
    fn deserialize_reader<R: Read>(reader: &mut R) -> Result<Self> {
        <T as BorshDeserialize>::deserialize_reader(reader).map(core::cell::Cell::new)
    }
}

impl<T> BorshDeserialize for core::cell::RefCell<T>
where
    T: BorshDeserialize,
{
    fn deserialize_reader<R: Read>(reader: &mut R) -> Result<Self> {
        <T as BorshDeserialize>::deserialize_reader(reader).map(core::cell::RefCell::new)
    }
}

/// Deserializes an object from a slice of bytes.
/// # Example
/// ```
/// use borsh::{BorshDeserialize, BorshSerialize, from_slice, to_vec};
///
/// /// derive is only available if borsh is built with `features = ["derive"]`
/// # #[cfg(feature = "derive")]
/// #[derive(BorshSerialize, BorshDeserialize, PartialEq, Debug)]
/// struct MyStruct {
///    a: u64,
///    b: Vec<u8>,
/// }
///
/// # #[cfg(feature = "derive")]
/// let original = MyStruct { a: 10, b: vec![1, 2, 3] };
/// # #[cfg(feature = "derive")]
/// let encoded = to_vec(&original).unwrap();
/// # #[cfg(feature = "derive")]
/// let decoded = from_slice::<MyStruct>(&encoded).unwrap();
/// # #[cfg(feature = "derive")]
/// assert_eq!(original, decoded);
/// ```
/// # Panics
/// If the data is invalid, this function will panic.
/// # Errors
/// If the data is invalid, this function will return an error.
/// # Note
/// This function will return an error if the data is not fully read.
pub fn from_slice<T: BorshDeserialize>(v: &[u8]) -> Result<T> {
    let mut v_mut = v;
    let object = T::deserialize(&mut v_mut)?;
    if !v_mut.is_empty() {
        return Err(Error::new(
            ErrorKind::InvalidData,
            crate::de::ERROR_NOT_ALL_BYTES_READ,
        ));
    }
    Ok(object)
}

/// Deserializes an object from a reader.
/// # Example
/// ```
/// use borsh::{BorshDeserialize, BorshSerialize, from_reader, to_vec};
///
/// /// derive is only available if borsh is built with `features = ["derive"]`
/// # #[cfg(feature = "derive")]
/// #[derive(BorshSerialize, BorshDeserialize, PartialEq, Debug)]
/// struct MyStruct {
///     a: u64,
///     b: Vec<u8>,
/// }
///
/// # #[cfg(feature = "derive")]
/// let original = MyStruct { a: 10, b: vec![1, 2, 3] };
/// # #[cfg(feature = "derive")]
/// let encoded = to_vec(&original).unwrap();
/// # #[cfg(feature = "derive")]
/// let decoded = from_reader::<_, MyStruct>(&mut encoded.as_slice()).unwrap();
/// # #[cfg(feature = "derive")]
/// assert_eq!(original, decoded);
/// ```
pub fn from_reader<R: Read, T: BorshDeserialize>(reader: &mut R) -> Result<T> {
    let result = T::deserialize_reader(reader)?;
    let mut buf = [0u8; 1];
    match reader.read_exact(&mut buf) {
        Err(f) if f.kind() == ErrorKind::UnexpectedEof => Ok(result),
        _ => Err(Error::new(ErrorKind::InvalidData, ERROR_NOT_ALL_BYTES_READ)),
    }
}

'''
'''--- borsh/src/error.rs ---
use crate::io::{Error, ErrorKind, Result};
use core::mem::size_of;
pub const ERROR_ZST_FORBIDDEN: &str = "Collections of zero-sized types are not allowed due to deny-of-service concerns on deserialization.";

pub(crate) fn check_zst<T>() -> Result<()> {
    if size_of::<T>() == 0 {
        return Err(Error::new(ErrorKind::InvalidData, ERROR_ZST_FORBIDDEN));
    }
    Ok(())
}

'''
'''--- borsh/src/generate_schema_schema.rs ---
//! Generate `BorshSchemaCointainer` for `BorshSchemaContainer` and save it into a file.

#![cfg_attr(not(feature = "std"), no_std)]
use borsh::schema_container_of;
use std::fs::File;
use std::io::Write;

fn main() {
    let container = schema_container_of::<borsh::schema::BorshSchemaContainer>();

    println!("{:#?}", container);

    let data = borsh::to_vec(&container).expect("Failed to serialize BorshSchemaContainer");
    let mut file = File::create("schema_schema.dat").expect("Failed to create file");
    file.write_all(&data).expect("Failed to write file");
}

'''
'''--- borsh/src/lib.rs ---
#![cfg_attr(not(feature = "std"), no_std)]

/*!

# Crate features

### Ecosystem features

* **std** -
  When enabled, `borsh` uses the standard library. Disabling this feature will
  result in building the crate in `no_std` environment.

  To carter such builds, Borsh offers [`io`] module which includes a items which
  are used in [`BorshSerialize`] and [`BorshDeserialize`] traits.  Most notably
  `io::Read`, `io::Write` and `io::Result`.

  When **std** feature is enabled, those items are re-exports of corresponding
  `std::io` items.  Otherwise they are borsh-specific types which mimic
  behaviour of corresponding standard types.

### Default features

* **std** - enabled by default.

### Other features

* **derive** -
  Gates derive macros of [BorshSerialize] and
  [BorshDeserialize] traits.
* **unstable__schema** -
  Gates [BorshSchema] trait and its derive macro.
  Gates [schema] module.
  This feature requires **derive** to be enabled too.
* **rc** -
  Gates implementation of [BorshSerialize] and [BorshDeserialize]
  for [`Rc<T>`](std::rc::Rc)/[`Arc<T>`](std::sync::Arc) respectively.
  In `no_std` setting `Rc`/`Arc` are pulled from `alloc` crate.
  Serializing and deserializing these types
  does not preserve identity and may result in multiple copies of the same data.
  Be sure that this is what you want before enabling this feature.
* **hashbrown** -
  Pulls in [HashMap](std::collections::HashMap)/[HashSet](std::collections::HashSet) when no `std` is available.
  This feature is set to be mutually exclusive with **std** feature.
* **bytes** -
  Gates implementation of [BorshSerialize] and [BorshDeserialize]
  for [Bytes](https://docs.rs/bytes/1.5.0/bytes/struct.Bytes.html) and [BytesMut](https://docs.rs/bytes/1.5.0/bytes/struct.BytesMut.html).
* **bson** -
  Gates implementation of [BorshSerialize] and [BorshDeserialize]
  for [ObjectId](https://docs.rs/bson/2.9.0/bson/oid/struct.ObjectId.html).
* **ascii** -
  Gates implementation of [BorshSerialize], [BorshDeserialize], [BorshSchema] for
  types from [ascii](https://docs.rs/ascii/1.1.0/ascii/) crate.
* **de_strict_order** -
  Enables check that keys, parsed during deserialization of
  [HashMap](std::collections::HashMap)/[HashSet](std::collections::HashSet) and
  [BTreeSet](std::collections::BTreeSet)/[BTreeMap](std::collections::BTreeMap)
  are encountered in ascending order with respect to [PartialOrd] for hash collections,
  and [Ord] for btree ones. Deserialization emits error otherwise.

  If this feature is not enabled, it is possible that two different byte slices could deserialize into the same `HashMap`/`HashSet` object.

### Config aliases

* **hash_collections** -
  This is a feature alias, set up in `build.rs` to be equivalent to (**std** OR **hashbrown**).
  Gates implementation of [BorshSerialize], [BorshDeserialize]
  and [BorshSchema]
  for [HashMap](std::collections::HashMap)/[HashSet](std::collections::HashSet).

*/

#[cfg(not(feature = "std"))]
extern crate alloc;

/// Derive macro available if borsh is built with `features = ["unstable__schema"]`.
#[cfg(feature = "unstable__schema")]
pub use borsh_derive::BorshSchema;

/// Derive macro available if borsh is built with `features = ["derive"]`.
#[cfg(feature = "derive")]
pub use borsh_derive::{BorshDeserialize, BorshSerialize};

pub mod de;

// See `hash_collections` alias definition in build.rs
/// Module is available if borsh is built with `features = ["unstable__schema"]`.
#[cfg(feature = "unstable__schema")]
pub mod schema;
#[cfg(feature = "unstable__schema")]
pub(crate) mod schema_helpers;
pub mod ser;

pub use de::BorshDeserialize;
pub use de::{from_reader, from_slice};
#[cfg(feature = "unstable__schema")]
pub use schema::BorshSchema;
#[cfg(feature = "unstable__schema")]
pub use schema_helpers::{
    max_serialized_size, schema_container_of, try_from_slice_with_schema, try_to_vec_with_schema,
};
pub use ser::helpers::{object_length, to_vec, to_writer};
pub use ser::BorshSerialize;
pub mod error;

#[cfg(all(feature = "std", feature = "hashbrown"))]
compile_error!("feature \"std\" and feature \"hashbrown\" don't make sense at the same time");

#[cfg(feature = "std")]
use std::io as io_impl;
#[cfg(not(feature = "std"))]
mod nostd_io;
#[cfg(not(feature = "std"))]
use nostd_io as io_impl;

/// Subset of `std::io` which is used as part of borsh public API.
///
/// When crate is built with `std` feature disabled (it’s enabled by default),
/// the exported types are custom borsh types which try to mimic behaviour of
/// corresponding standard types usually offering subset of features.
pub mod io {
    pub use super::io_impl::{Error, ErrorKind, Read, Result, Write};
}

#[doc(hidden)]
pub mod __private {

    /// A facade around all the types we need from the `std`, and `alloc`
    /// crates. This avoids elaborate import wrangling having to happen in every
    /// module.
    #[cfg(feature = "std")]
    pub mod maybestd {
        pub use std::{borrow, boxed, collections, format, string, vec};

        #[cfg(feature = "rc")]
        pub use std::{rc, sync};
    }
    #[cfg(not(feature = "std"))]
    pub mod maybestd {
        pub use alloc::{borrow, boxed, format, string, vec};

        #[cfg(feature = "rc")]
        pub use alloc::{rc, sync};

        pub mod collections {
            pub use alloc::collections::{btree_map, BTreeMap, BTreeSet, LinkedList, VecDeque};
            #[cfg(feature = "hashbrown")]
            pub use hashbrown::*;
        }
    }
}

'''
'''--- borsh/src/nostd_io.rs ---
//! Taken from https://github.com/bbqsrc/bare-io (with adjustments)

use crate::__private::maybestd::string::String;
use core::{convert::From, fmt, result};

/// A specialized [`Result`] type for I/O operations.
///
/// This type is broadly used across [`std::io`] for any operation which may
/// produce an error.
///
/// This typedef is generally used to avoid writing out [`io::Error`] directly and
/// is otherwise a direct mapping to [`Result`].
///
/// While usual Rust style is to import types directly, aliases of [`Result`]
/// often are not, to make it easier to distinguish between them. [`Result`] is
/// generally assumed to be [`std::result::Result`][`Result`], and so users of this alias
/// will generally use `io::Result` instead of shadowing the [prelude]'s import
/// of [`std::result::Result`][`Result`].
///
/// [`std::io`]: crate::io
/// [`io::Error`]: Error
/// [`Result`]: crate::result::Result
/// [prelude]: crate::prelude
///
/// # Examples
///
/// A convenience function that bubbles an `io::Result` to its caller:
///
/// ```
/// use std::io;
///
/// fn get_string() -> io::Result<String> {
///     let mut buffer = String::new();
///
///     io::stdin().read_line(&mut buffer)?;
///
///     Ok(buffer)
/// }
/// ```
pub type Result<T> = result::Result<T, Error>;

/// The error type for I/O operations of the [`Read`], [`Write`], [`Seek`], and
/// associated traits.
///
/// Errors mostly originate from the underlying OS, but custom instances of
/// `Error` can be created with crafted error messages and a particular value of
/// [`ErrorKind`].
///
/// [`Read`]: crate::io::Read
/// [`Write`]: crate::io::Write
/// [`Seek`]: crate::io::Seek
pub struct Error {
    repr: Repr,
}

impl fmt::Debug for Error {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        fmt::Debug::fmt(&self.repr, f)
    }
}

enum Repr {
    Simple(ErrorKind),
    Custom(Custom),
}

#[derive(Debug)]
struct Custom {
    kind: ErrorKind,
    error: String,
}

/// A list specifying general categories of I/O error.
///
/// This list is intended to grow over time and it is not recommended to
/// exhaustively match against it.
///
/// It is used with the [`io::Error`] type.
///
/// [`io::Error`]: Error
#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
// #[allow(deprecated)]
#[non_exhaustive]
pub enum ErrorKind {
    /// An entity was not found, often a file.
    NotFound,
    /// The operation lacked the necessary privileges to complete.
    PermissionDenied,
    /// The connection was refused by the remote server.
    ConnectionRefused,
    /// The connection was reset by the remote server.
    ConnectionReset,
    /// The connection was aborted (terminated) by the remote server.
    ConnectionAborted,
    /// The network operation failed because it was not connected yet.
    NotConnected,
    /// A socket address could not be bound because the address is already in
    /// use elsewhere.
    AddrInUse,
    /// A nonexistent interface was requested or the requested address was not
    /// local.
    AddrNotAvailable,
    /// The operation failed because a pipe was closed.
    BrokenPipe,
    /// An entity already exists, often a file.
    AlreadyExists,
    /// The operation needs to block to complete, but the blocking operation was
    /// requested to not occur.
    WouldBlock,
    /// A parameter was incorrect.
    InvalidInput,
    /// Data not valid for the operation were encountered.
    ///
    /// Unlike [`InvalidInput`], this typically means that the operation
    /// parameters were valid, however the error was caused by malformed
    /// input data.
    ///
    /// For example, a function that reads a file into a string will error with
    /// `InvalidData` if the file's contents are not valid UTF-8.
    ///
    /// [`InvalidInput`]: ErrorKind::InvalidInput
    InvalidData,
    /// The I/O operation's timeout expired, causing it to be canceled.
    TimedOut,
    /// An error returned when an operation could not be completed because a
    /// call to [`write`] returned [`Ok(0)`].
    ///
    /// This typically means that an operation could only succeed if it wrote a
    /// particular number of bytes but only a smaller number of bytes could be
    /// written.
    ///
    /// [`write`]: crate::io::Write::write
    /// [`Ok(0)`]: Ok
    WriteZero,
    /// This operation was interrupted.
    ///
    /// Interrupted operations can typically be retried.
    Interrupted,
    /// Any I/O error not part of this list.
    ///
    /// Errors that are `Other` now may move to a different or a new
    /// [`ErrorKind`] variant in the future. It is not recommended to match
    /// an error against `Other` and to expect any additional characteristics,
    /// e.g., a specific [`Error::raw_os_error`] return value.
    Other,

    /// An error returned when an operation could not be completed because an
    /// "end of file" was reached prematurely.
    ///
    /// This typically means that an operation could only succeed if it read a
    /// particular number of bytes but only a smaller number of bytes could be
    /// read.
    UnexpectedEof,

    /// An operation could not be completed, because it failed
    /// to allocate enough memory.
    OutOfMemory,
}

impl ErrorKind {
    pub(crate) fn as_str(&self) -> &'static str {
        match *self {
            ErrorKind::NotFound => "entity not found",
            ErrorKind::PermissionDenied => "permission denied",
            ErrorKind::ConnectionRefused => "connection refused",
            ErrorKind::ConnectionReset => "connection reset",
            ErrorKind::ConnectionAborted => "connection aborted",
            ErrorKind::NotConnected => "not connected",
            ErrorKind::AddrInUse => "address in use",
            ErrorKind::AddrNotAvailable => "address not available",
            ErrorKind::BrokenPipe => "broken pipe",
            ErrorKind::AlreadyExists => "entity already exists",
            ErrorKind::WouldBlock => "operation would block",
            ErrorKind::InvalidInput => "invalid input parameter",
            ErrorKind::InvalidData => "invalid data",
            ErrorKind::TimedOut => "timed out",
            ErrorKind::WriteZero => "write zero",
            ErrorKind::Interrupted => "operation interrupted",
            ErrorKind::Other => "other os error",
            ErrorKind::UnexpectedEof => "unexpected end of file",
            ErrorKind::OutOfMemory => "out of memory",
        }
    }
}

/// Intended for use for errors not exposed to the user, where allocating onto
/// the heap (for normal construction via Error::new) is too costly.
impl From<ErrorKind> for Error {
    /// Converts an [`ErrorKind`] into an [`Error`].
    ///
    /// This conversion allocates a new error with a simple representation of error kind.
    ///
    /// # Examples
    ///
    /// ```
    /// use std::io::{Error, ErrorKind};
    ///
    /// let not_found = ErrorKind::NotFound;
    /// let error = Error::from(not_found);
    /// assert_eq!("entity not found", format!("{}", error));
    /// ```
    #[inline]
    fn from(kind: ErrorKind) -> Error {
        Error {
            repr: Repr::Simple(kind),
        }
    }
}

impl Error {
    /// Creates a new I/O error from a known kind of error as well as an
    /// arbitrary error payload.
    ///
    /// This function is used to generically create I/O errors which do not
    /// originate from the OS itself. The `error` argument is an arbitrary
    /// payload which will be contained in this [`Error`].
    ///
    /// # Examples
    ///
    /// ```
    /// use std::io::{Error, ErrorKind};
    ///
    /// // errors can be created from strings
    /// let custom_error = Error::new(ErrorKind::Other, "oh no!");
    ///
    /// // errors can also be created from other errors
    /// let custom_error2 = Error::new(ErrorKind::Interrupted, custom_error);
    /// ```
    pub fn new<T: Into<String>>(kind: ErrorKind, error: T) -> Error {
        Self::_new(kind, error.into())
    }

    fn _new(kind: ErrorKind, error: String) -> Error {
        Error {
            repr: Repr::Custom(Custom { kind, error }),
        }
    }

    /// Returns a reference to the inner error wrapped by this error (if any).
    ///
    /// If this [`Error`] was constructed via [`new`] then this function will
    /// return [`Some`], otherwise it will return [`None`].
    ///
    /// [`new`]: Error::new
    ///
    /// # Examples
    ///
    /// ```
    /// use std::io::{Error, ErrorKind};
    ///
    /// fn print_error(err: &Error) {
    ///     if let Some(inner_err) = err.get_ref() {
    ///         println!("Inner error: {:?}", inner_err);
    ///     } else {
    ///         println!("No inner error");
    ///     }
    /// }
    ///
    /// fn main() {
    ///     // Will print "No inner error".
    ///     print_error(&Error::last_os_error());
    ///     // Will print "Inner error: ...".
    ///     print_error(&Error::new(ErrorKind::Other, "oh no!"));
    /// }
    /// ```
    pub fn get_ref(&self) -> Option<&str> {
        match self.repr {
            Repr::Simple(..) => None,
            Repr::Custom(ref c) => Some(&c.error),
        }
    }

    /// Consumes the `Error`, returning its inner error (if any).
    ///
    /// If this [`Error`] was constructed via [`new`] then this function will
    /// return [`Some`], otherwise it will return [`None`].
    ///
    /// [`new`]: Error::new
    ///
    /// # Examples
    ///
    /// ```
    /// use std::io::{Error, ErrorKind};
    ///
    /// fn print_error(err: Error) {
    ///     if let Some(inner_err) = err.into_inner() {
    ///         println!("Inner error: {}", inner_err);
    ///     } else {
    ///         println!("No inner error");
    ///     }
    /// }
    ///
    /// fn main() {
    ///     // Will print "No inner error".
    ///     print_error(Error::last_os_error());
    ///     // Will print "Inner error: ...".
    ///     print_error(Error::new(ErrorKind::Other, "oh no!"));
    /// }
    /// ```
    pub fn into_inner(self) -> Option<String> {
        match self.repr {
            Repr::Simple(..) => None,
            Repr::Custom(c) => Some(c.error),
        }
    }

    /// Returns the corresponding [`ErrorKind`] for this error.
    ///
    /// # Examples
    ///
    /// ```
    /// use std::io::{Error, ErrorKind};
    ///
    /// fn print_error(err: Error) {
    ///     println!("{:?}", err.kind());
    /// }
    ///
    /// fn main() {
    ///     // Will print "Other".
    ///     print_error(Error::last_os_error());
    ///     // Will print "AddrInUse".
    ///     print_error(Error::new(ErrorKind::AddrInUse, "oh no!"));
    /// }
    /// ```
    pub fn kind(&self) -> ErrorKind {
        match self.repr {
            Repr::Custom(ref c) => c.kind,
            Repr::Simple(kind) => kind,
        }
    }
}

impl fmt::Debug for Repr {
    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
        match *self {
            Repr::Custom(ref c) => fmt::Debug::fmt(&c, fmt),
            Repr::Simple(kind) => fmt.debug_tuple("Kind").field(&kind).finish(),
        }
    }
}

impl fmt::Display for Error {
    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self.repr {
            Repr::Custom(ref c) => c.error.fmt(fmt),
            Repr::Simple(kind) => write!(fmt, "{}", kind.as_str()),
        }
    }
}

fn _assert_error_is_sync_send() {
    fn _is_sync_send<T: Sync + Send>() {}
    _is_sync_send::<Error>();
}

/// A trait for objects which are byte-oriented sinks.
///
/// Implementors of the `Write` trait are sometimes called 'writers'.
///
/// Writers are defined by two required methods, [`write`] and [`flush`]:
///
/// * The [`write`] method will attempt to write some data into the object,
///   returning how many bytes were successfully written.
///
/// * The [`flush`] method is useful for adaptors and explicit buffers
///   themselves for ensuring that all buffered data has been pushed out to the
///   'true sink'.
///
/// Writers are intended to be composable with one another. Many implementors
/// throughout [`std::io`] take and provide types which implement the `Write`
/// trait.
///
/// [`write`]: Write::write
/// [`flush`]: Write::flush
/// [`std::io`]: self
///
/// # Examples
///
/// ```no_run
/// use std::io::prelude::*;
/// use std::fs::File;
///
/// fn main() -> std::io::Result<()> {
///     let data = b"some bytes";
///
///     let mut pos = 0;
///     let mut buffer = File::create("foo.txt")?;
///
///     while pos < data.len() {
///         let bytes_written = buffer.write(&data[pos..])?;
///         pos += bytes_written;
///     }
///     Ok(())
/// }
/// ```
///
/// The trait also provides convenience methods like [`write_all`], which calls
/// `write` in a loop until its entire input has been written.
///
/// [`write_all`]: Write::write_all
pub trait Write {
    /// Write a buffer into this writer, returning how many bytes were written.
    ///
    /// This function will attempt to write the entire contents of `buf`, but
    /// the entire write may not succeed, or the write may also generate an
    /// error. A call to `write` represents *at most one* attempt to write to
    /// any wrapped object.
    ///
    /// Calls to `write` are not guaranteed to block waiting for data to be
    /// written, and a write which would otherwise block can be indicated through
    /// an [`Err`] variant.
    ///
    /// If the return value is [`Ok(n)`] then it must be guaranteed that
    /// `n <= buf.len()`. A return value of `0` typically means that the
    /// underlying object is no longer able to accept bytes and will likely not
    /// be able to in the future as well, or that the buffer provided is empty.
    ///
    /// # Errors
    ///
    /// Each call to `write` may generate an I/O error indicating that the
    /// operation could not be completed. If an error is returned then no bytes
    /// in the buffer were written to this writer.
    ///
    /// It is **not** considered an error if the entire buffer could not be
    /// written to this writer.
    ///
    /// An error of the [`ErrorKind::Interrupted`] kind is non-fatal and the
    /// write operation should be retried if there is nothing else to do.
    ///
    /// # Examples
    ///
    /// ```no_run
    /// use std::io::prelude::*;
    /// use std::fs::File;
    ///
    /// fn main() -> std::io::Result<()> {
    ///     let mut buffer = File::create("foo.txt")?;
    ///
    ///     // Writes some prefix of the byte string, not necessarily all of it.
    ///     buffer.write(b"some bytes")?;
    ///     Ok(())
    /// }
    /// ```
    ///
    /// [`Ok(n)`]: Ok
    fn write(&mut self, buf: &[u8]) -> Result<usize>;

    /// Flush this output stream, ensuring that all intermediately buffered
    /// contents reach their destination.
    ///
    /// # Errors
    ///
    /// It is considered an error if not all bytes could be written due to
    /// I/O errors or EOF being reached.
    ///
    /// # Examples
    ///
    /// ```no_run
    /// use std::io::prelude::*;
    /// use std::io::BufWriter;
    /// use std::fs::File;
    ///
    /// fn main() -> std::io::Result<()> {
    ///     let mut buffer = BufWriter::new(File::create("foo.txt")?);
    ///
    ///     buffer.write_all(b"some bytes")?;
    ///     buffer.flush()?;
    ///     Ok(())
    /// }
    /// ```
    fn flush(&mut self) -> Result<()>;

    /// Attempts to write an entire buffer into this writer.
    ///
    /// This method will continuously call [`write`] until there is no more data
    /// to be written or an error of non-[`ErrorKind::Interrupted`] kind is
    /// returned. This method will not return until the entire buffer has been
    /// successfully written or such an error occurs. The first error that is
    /// not of [`ErrorKind::Interrupted`] kind generated from this method will be
    /// returned.
    ///
    /// If the buffer contains no data, this will never call [`write`].
    ///
    /// # Errors
    ///
    /// This function will return the first error of
    /// non-[`ErrorKind::Interrupted`] kind that [`write`] returns.
    ///
    /// [`write`]: Write::write
    ///
    /// # Examples
    ///
    /// ```no_run
    /// use std::io::prelude::*;
    /// use std::fs::File;
    ///
    /// fn main() -> std::io::Result<()> {
    ///     let mut buffer = File::create("foo.txt")?;
    ///
    ///     buffer.write_all(b"some bytes")?;
    ///     Ok(())
    /// }
    /// ```
    fn write_all(&mut self, mut buf: &[u8]) -> Result<()> {
        while !buf.is_empty() {
            match self.write(buf) {
                Ok(0) => {
                    return Err(Error::new(
                        ErrorKind::WriteZero,
                        "failed to write whole buffer",
                    ));
                }
                Ok(n) => buf = &buf[n..],
                Err(ref e) if e.kind() == ErrorKind::Interrupted => {}
                Err(e) => return Err(e),
            }
        }
        Ok(())
    }
    /// Writes a formatted string into this writer, returning any error
    /// encountered.
    ///
    /// This method is primarily used to interface with the
    /// [`format_args!()`] macro, but it is rare that this should
    /// explicitly be called. The [`write!()`] macro should be favored to
    /// invoke this method instead.
    ///
    /// This function internally uses the [`write_all`] method on
    /// this trait and hence will continuously write data so long as no errors
    /// are received. This also means that partial writes are not indicated in
    /// this signature.
    ///
    /// [`write_all`]: Write::write_all
    ///
    /// # Errors
    ///
    /// This function will return any I/O error reported while formatting.
    ///
    /// # Examples
    ///
    /// ```no_run
    /// use std::io::prelude::*;
    /// use std::fs::File;
    ///
    /// fn main() -> std::io::Result<()> {
    ///     let mut buffer = File::create("foo.txt")?;
    ///
    ///     // this call
    ///     write!(buffer, "{:.*}", 2, 1.234567)?;
    ///     // turns into this:
    ///     buffer.write_fmt(format_args!("{:.*}", 2, 1.234567))?;
    ///     Ok(())
    /// }
    /// ```
    fn write_fmt(&mut self, fmt: fmt::Arguments<'_>) -> Result<()> {
        // Create a shim which translates a Write to a fmt::Write and saves
        // off I/O errors. instead of discarding them
        struct Adaptor<'a, T: ?Sized + 'a> {
            inner: &'a mut T,
            error: Result<()>,
        }

        impl<T: Write + ?Sized> fmt::Write for Adaptor<'_, T> {
            fn write_str(&mut self, s: &str) -> fmt::Result {
                match self.inner.write_all(s.as_bytes()) {
                    Ok(()) => Ok(()),
                    Err(e) => {
                        self.error = Err(e);
                        Err(fmt::Error)
                    }
                }
            }
        }

        let mut output = Adaptor {
            inner: self,
            error: Ok(()),
        };
        match fmt::write(&mut output, fmt) {
            Ok(()) => Ok(()),
            Err(..) => {
                // check if the error came from the underlying `Write` or not
                if output.error.is_err() {
                    output.error
                } else {
                    Err(Error::new(ErrorKind::Other, "formatter error"))
                }
            }
        }
    }

    /// Creates a "by reference" adaptor for this instance of `Write`.
    ///
    /// The returned adaptor also implements `Write` and will simply borrow this
    /// current writer.
    ///
    /// # Examples
    ///
    /// ```no_run
    /// use std::io::Write;
    /// use std::fs::File;
    ///
    /// fn main() -> std::io::Result<()> {
    ///     let mut buffer = File::create("foo.txt")?;
    ///
    ///     let reference = buffer.by_ref();
    ///
    ///     // we can use reference just like our original buffer
    ///     reference.write_all(b"some bytes")?;
    ///     Ok(())
    /// }
    /// ```
    fn by_ref(&mut self) -> &mut Self
    where
        Self: Sized,
    {
        self
    }
}

impl<W: Write + ?Sized> Write for &mut W {
    #[inline]
    fn write(&mut self, buf: &[u8]) -> Result<usize> {
        (**self).write(buf)
    }

    #[inline]
    fn flush(&mut self) -> Result<()> {
        (**self).flush()
    }

    #[inline]
    fn write_all(&mut self, buf: &[u8]) -> Result<()> {
        (**self).write_all(buf)
    }

    #[inline]
    fn write_fmt(&mut self, fmt: fmt::Arguments<'_>) -> Result<()> {
        (**self).write_fmt(fmt)
    }
}

/// Write is implemented for `&mut [u8]` by copying into the slice, overwriting
/// its data.
///
/// Note that writing updates the slice to point to the yet unwritten part.
/// The slice will be empty when it has been completely overwritten.
impl Write for &mut [u8] {
    #[inline]
    fn write(&mut self, data: &[u8]) -> Result<usize> {
        let amt = core::cmp::min(data.len(), self.len());
        let (a, b) = core::mem::replace(self, &mut []).split_at_mut(amt);
        a.copy_from_slice(&data[..amt]);
        *self = b;
        Ok(amt)
    }

    #[inline]
    fn write_all(&mut self, data: &[u8]) -> Result<()> {
        if self.write(data)? == data.len() {
            Ok(())
        } else {
            Err(Error::new(
                ErrorKind::WriteZero,
                "failed to write whole buffer",
            ))
        }
    }

    #[inline]
    fn flush(&mut self) -> Result<()> {
        Ok(())
    }
}

/// Write is implemented for `Vec<u8>` by appending to the vector.
/// The vector will grow as needed.
impl Write for alloc::vec::Vec<u8> {
    #[inline]
    fn write(&mut self, buf: &[u8]) -> Result<usize> {
        self.extend_from_slice(buf);
        Ok(buf.len())
    }

    #[inline]
    fn write_all(&mut self, buf: &[u8]) -> Result<()> {
        self.extend_from_slice(buf);
        Ok(())
    }

    #[inline]
    fn flush(&mut self) -> Result<()> {
        Ok(())
    }
}

/// The `Read` trait allows for reading bytes from a source.
///
/// Implementors of the `Read` trait are called 'readers'.
///
/// Readers are defined by one required method, [`read()`]. Each call to [`read()`]
/// will attempt to pull bytes from this source into a provided buffer. A
/// number of other methods are implemented in terms of [`read()`], giving
/// implementors a number of ways to read bytes while only needing to implement
/// a single method.
///
/// Readers are intended to be composable with one another. Many implementors
/// throughout [`std::io`] take and provide types which implement the `Read`
/// trait.
///
/// Please note that each call to [`read()`] may involve a system call, and
/// therefore, using something that implements [`BufRead`], such as
/// [`BufReader`], will be more efficient.
///
/// # Examples
///
/// [`File`]s implement `Read`:
///
/// ```no_run
/// use std::io;
/// use std::io::prelude::*;
/// use std::fs::File;
///
/// fn main() -> io::Result<()> {
///     let mut f = File::open("foo.txt")?;
///     let mut buffer = [0; 10];
///
///     // read up to 10 bytes
///     f.read(&mut buffer)?;
///
///     let mut buffer = Vec::new();
///     // read the whole file
///     f.read_to_end(&mut buffer)?;
///
///     // read into a String, so that you don't need to do the conversion.
///     let mut buffer = String::new();
///     f.read_to_string(&mut buffer)?;
///
///     // and more! See the other methods for more details.
///     Ok(())
/// }
/// ```
///
/// Read from [`&str`] because [`&[u8]`][prim@slice] implements `Read`:
///
/// ```no_run
/// # use std::io;
/// use std::io::prelude::*;
///
/// fn main() -> io::Result<()> {
///     let mut b = "This string will be read".as_bytes();
///     let mut buffer = [0; 10];
///
///     // read up to 10 bytes
///     b.read(&mut buffer)?;
///
///     // etc... it works exactly as a File does!
///     Ok(())
/// }
/// ```
///
/// [`read()`]: Read::read
/// [`&str`]: prim@str
/// [`std::io`]: self
/// [`File`]: crate::fs::File
pub trait Read {
    /// Pull some bytes from this source into the specified buffer, returning
    /// how many bytes were read.
    ///
    /// This function does not provide any guarantees about whether it blocks
    /// waiting for data, but if an object needs to block for a read and cannot,
    /// it will typically signal this via an [`Err`] return value.
    ///
    /// If the return value of this method is [`Ok(n)`], then implementations must
    /// guarantee that `0 <= n <= buf.len()`. A nonzero `n` value indicates
    /// that the buffer `buf` has been filled in with `n` bytes of data from this
    /// source. If `n` is `0`, then it can indicate one of two scenarios:
    ///
    /// 1. This reader has reached its "end of file" and will likely no longer
    ///    be able to produce bytes. Note that this does not mean that the
    ///    reader will *always* no longer be able to produce bytes. As an example,
    ///    on Linux, this method will call the `recv` syscall for a [`TcpStream`],
    ///    where returning zero indicates the connection was shut down correctly. While
    ///    for [`File`], it is possible to reach the end of file and get zero as result,
    ///    but if more data is appended to the file, future calls to `read` will return
    ///    more data.
    /// 2. The buffer specified was 0 bytes in length.
    ///
    /// It is not an error if the returned value `n` is smaller than the buffer size,
    /// even when the reader is not at the end of the stream yet.
    /// This may happen for example because fewer bytes are actually available right now
    /// (e. g. being close to end-of-file) or because read() was interrupted by a signal.
    ///
    /// As this trait is safe to implement, callers cannot rely on `n <= buf.len()` for safety.
    /// Extra care needs to be taken when `unsafe` functions are used to access the read bytes.
    /// Callers have to ensure that no unchecked out-of-bounds accesses are possible even if
    /// `n > buf.len()`.
    ///
    /// No guarantees are provided about the contents of `buf` when this
    /// function is called, implementations cannot rely on any property of the
    /// contents of `buf` being true. It is recommended that *implementations*
    /// only write data to `buf` instead of reading its contents.
    ///
    /// Correspondingly, however, *callers* of this method must not assume any guarantees
    /// about how the implementation uses `buf`. The trait is safe to implement,
    /// so it is possible that the code that's supposed to write to the buffer might also read
    /// from it. It is your responsibility to make sure that `buf` is initialized
    /// before calling `read`. Calling `read` with an uninitialized `buf` (of the kind one
    /// obtains via [`MaybeUninit<T>`]) is not safe, and can lead to undefined behavior.
    ///
    /// [`MaybeUninit<T>`]: crate::mem::MaybeUninit
    ///
    /// # Errors
    ///
    /// If this function encounters any form of I/O or other error, an error
    /// variant will be returned. If an error is returned then it must be
    /// guaranteed that no bytes were read.
    ///
    /// An error of the [`ErrorKind::Interrupted`] kind is non-fatal and the read
    /// operation should be retried if there is nothing else to do.
    ///
    /// # Examples
    ///
    /// [`File`]s implement `Read`:
    ///
    /// [`Ok(n)`]: Ok
    /// [`File`]: crate::fs::File
    /// [`TcpStream`]: crate::net::TcpStream
    ///
    /// ```no_run
    /// use std::io;
    /// use std::io::prelude::*;
    /// use std::fs::File;
    ///
    /// fn main() -> io::Result<()> {
    ///     let mut f = File::open("foo.txt")?;
    ///     let mut buffer = [0; 10];
    ///
    ///     // read up to 10 bytes
    ///     let n = f.read(&mut buffer[..])?;
    ///
    ///     println!("The bytes: {:?}", &buffer[..n]);
    ///     Ok(())
    /// }
    /// ```
    fn read(&mut self, buf: &mut [u8]) -> Result<usize>;

    /// Read the exact number of bytes required to fill `buf`.
    ///
    /// This function reads as many bytes as necessary to completely fill the
    /// specified buffer `buf`.
    ///
    /// No guarantees are provided about the contents of `buf` when this
    /// function is called, implementations cannot rely on any property of the
    /// contents of `buf` being true. It is recommended that implementations
    /// only write data to `buf` instead of reading its contents. The
    /// documentation on [`read`] has a more detailed explanation on this
    /// subject.
    ///
    /// # Errors
    ///
    /// If this function encounters an error of the kind
    /// [`ErrorKind::Interrupted`] then the error is ignored and the operation
    /// will continue.
    ///
    /// If this function encounters an "end of file" before completely filling
    /// the buffer, it returns an error of the kind [`ErrorKind::UnexpectedEof`].
    /// The contents of `buf` are unspecified in this case.
    ///
    /// If any other read error is encountered then this function immediately
    /// returns. The contents of `buf` are unspecified in this case.
    ///
    /// If this function returns an error, it is unspecified how many bytes it
    /// has read, but it will never read more than would be necessary to
    /// completely fill the buffer.
    ///
    /// # Examples
    ///
    /// [`File`]s implement `Read`:
    ///
    /// [`read`]: Read::read
    /// [`File`]: crate::fs::File
    ///
    /// ```no_run
    /// use std::io;
    /// use std::io::prelude::*;
    /// use std::fs::File;
    ///
    /// fn main() -> io::Result<()> {
    ///     let mut f = File::open("foo.txt")?;
    ///     let mut buffer = [0; 10];
    ///
    ///     // read exactly 10 bytes
    ///     f.read_exact(&mut buffer)?;
    ///     Ok(())
    /// }
    /// ```
    fn read_exact(&mut self, buf: &mut [u8]) -> Result<()> {
        default_read_exact(self, buf)
    }

    /// Creates a "by reference" adaptor for this instance of `Read`.
    ///
    /// The returned adapter also implements `Read` and will simply borrow this
    /// current reader.
    ///
    /// # Examples
    ///
    /// [`File`]s implement `Read`:
    ///
    /// [`File`]: crate::fs::File
    ///
    /// ```no_run
    /// use std::io;
    /// use std::io::Read;
    /// use std::fs::File;
    ///
    /// fn main() -> io::Result<()> {
    ///     let mut f = File::open("foo.txt")?;
    ///     let mut buffer = Vec::new();
    ///     let mut other_buffer = Vec::new();
    ///
    ///     {
    ///         let reference = f.by_ref();
    ///
    ///         // read at most 5 bytes
    ///         reference.take(5).read_to_end(&mut buffer)?;
    ///
    ///     } // drop our &mut reference so we can use f again
    ///
    ///     // original file still usable, read the rest
    ///     f.read_to_end(&mut other_buffer)?;
    ///     Ok(())
    /// }
    /// ```
    fn by_ref(&mut self) -> &mut Self
    where
        Self: Sized,
    {
        self
    }
}

fn default_read_exact<R: Read + ?Sized>(this: &mut R, mut buf: &mut [u8]) -> Result<()> {
    while !buf.is_empty() {
        match this.read(buf) {
            Ok(0) => break,
            Ok(n) => {
                let tmp = buf;
                buf = &mut tmp[n..];
            }
            Err(ref e) if e.kind() == ErrorKind::Interrupted => {}
            Err(e) => return Err(e),
        }
    }
    if !buf.is_empty() {
        Err(Error::new(
            ErrorKind::UnexpectedEof,
            "failed to fill whole buffer",
        ))
    } else {
        Ok(())
    }
}

impl<R: Read + ?Sized> Read for &mut R {
    #[inline]
    fn read(&mut self, buf: &mut [u8]) -> Result<usize> {
        (**self).read(buf)
    }

    #[inline]
    fn read_exact(&mut self, buf: &mut [u8]) -> Result<()> {
        (**self).read_exact(buf)
    }
}

impl Read for &[u8] {
    #[inline]
    fn read(&mut self, buf: &mut [u8]) -> Result<usize> {
        let amt = core::cmp::min(buf.len(), self.len());
        let (a, b) = self.split_at(amt);

        // First check if the amount of bytes we want to read is small:
        // `copy_from_slice` will generally expand to a call to `memcpy`, and
        // for a single byte the overhead is significant.
        if amt == 1 {
            buf[0] = a[0];
        } else {
            buf[..amt].copy_from_slice(a);
        }

        *self = b;
        Ok(amt)
    }

    #[inline]
    fn read_exact(&mut self, buf: &mut [u8]) -> Result<()> {
        if buf.len() > self.len() {
            return Err(Error::new(
                ErrorKind::UnexpectedEof,
                "failed to fill whole buffer",
            ));
        }
        let (a, b) = self.split_at(buf.len());

        // First check if the amount of bytes we want to read is small:
        // `copy_from_slice` will generally expand to a call to `memcpy`, and
        // for a single byte the overhead is significant.
        if buf.len() == 1 {
            buf[0] = a[0];
        } else {
            buf.copy_from_slice(a);
        }

        *self = b;
        Ok(())
    }
}

'''
'''--- borsh/src/schema.rs ---
//!
//! Since Borsh is not a self-descriptive format we have a way to describe types serialized with Borsh so that
//! we can deserialize serialized blobs without having Rust types available. Additionally, this can be used to
//! serialize content provided in a different format, e.g. JSON object `{"user": "alice", "message": "Message"}`
//! can be serialized by JS code into Borsh format such that it can be deserialized into `struct UserMessage {user: String, message: String}`
//! on Rust side.
//!
//! The important components are: `BorshSchema` trait, `Definition` and `Declaration` types, and `BorshSchemaContainer` struct.
//! * `BorshSchema` trait allows any type that implements it to be self-descriptive, i.e. generate it's own schema;
//! * `Declaration` is used to describe the type identifier, e.g. `HashMap<u64, String>`;
//! * `Definition` is used to describe the structure of the type;
//! * `BorshSchemaContainer` is used to store all declarations and definitions that are needed to work with a single type.

#![allow(dead_code)] // Unclear why rust check complains on fields of `Definition` variants.
use crate as borsh; // For `#[derive(BorshSerialize, BorshDeserialize)]`.
use crate::__private::maybestd::{
    borrow,
    boxed::Box,
    collections::{btree_map::Entry, BTreeMap, BTreeSet, LinkedList, VecDeque},
    format,
    string::{String, ToString},
    vec,
    vec::Vec,
};
use crate::io::{Read, Result as IOResult, Write};
use crate::{BorshDeserialize, BorshSchema as BorshSchemaMacro, BorshSerialize};
use core::borrow::Borrow;
use core::cmp::Ord;
use core::marker::PhantomData;

mod container_ext;

pub use container_ext::{SchemaContainerValidateError, SchemaMaxSerializedSizeError};

/// The type that we use to represent the declaration of the Borsh type.
pub type Declaration = String;
/// The type that we use for the name of the variant.
pub type VariantName = String;
/// The type that we use for value of discriminant.
pub type DiscriminantValue = i64;
/// The name of the field in the struct (can be used to convert JSON to Borsh using the schema).
pub type FieldName = String;
/// The type that we use to represent the definition of the Borsh type.

/// Description of data encoding on the wire.
#[derive(Clone, PartialEq, Eq, Debug, BorshSerialize, BorshDeserialize, BorshSchemaMacro)]
pub enum Definition {
    /// A fixed-size type, which is considered undivisible
    Primitive(u8),

    /// A sequence of homogeneous elements.
    ///
    /// If `length_width` is non-zero, the sequence is tagged, i.e. prefixed by
    /// the number of elements in the sequence.  In that case, the length is
    /// encoded as a `length_width`-byte wide little-endian unsigned integer.
    ///
    /// If `length_width` is zero, the sequence is untagged.  In that case, if
    /// `length_range` contains a single number, the sequence is fixed-sized
    /// with the range determining number of elements.  Otherwise, knowledge of
    /// the type is necessary to be able to decode the number of elements.
    ///
    /// Prototypical examples of the use of this definitions are:
    /// * `[T; N]` → `length_width: 0, length_range: N..=N, elements: "T"` and
    /// * `Vec<T>` → `length_width: 4, length_range: 0..=u32::MAX,
    ///   elements: "T"`.
    ///
    /// With `length_width` and `length_range` other custom encoding formats can
    /// also be expressed.  For example:
    /// * `BoundedVec<LO, HI, T>` → `length_width: 4, length_range: LO..=HI`;
    /// * `PascalString` → `length_width: 1, length_range: 0..=255`;
    /// * `Ipv4Packet` → `length_width: 0, length_range: 20..=65536` or
    /// * `VarInt<u32>` → `length_width: 0, length_range: 1..=5`.
    Sequence {
        /// How many bytes does the length tag occupy.
        ///
        /// Zero if this is fixed-length array or the length must be determined
        /// by means not specified in the schema.  The schema is invalid if the
        /// value is greater than eight.
        length_width: u8,

        /// Bounds on the possible lengths of the sequence.
        ///
        /// Note: The schema is invalid if the range is empty or `length_width`
        /// is non-zero and either bound of the range cannot be represented as
        /// `length_width`-byte-wide unsigned integer.
        length_range: core::ops::RangeInclusive<u64>,

        /// Type of each element of the sequence.
        elements: Declaration,
    },

    /// A fixed-size tuple with the length known at the compile time and the elements of different
    /// types.
    Tuple { elements: Vec<Declaration> },

    /// A possibly tagged union, a.k.a enum.
    ///
    /// Tagged unions are prefixed by a tag identifying encoded variant followed
    /// by encoding of that variant.  The tag is `tag_width`-byte wide
    /// little-endian number.
    ///
    /// Untagged unions don’t have a separate tag which means that knowledge of
    /// the type is necessary to fully analyse the binary.  Variants may still
    /// be used to list possible values or determine the longest possible
    /// encoding.
    Enum {
        /// Width in bytes of the discriminant tag.
        ///
        /// Zero indicates this is an untagged union.  In standard borsh
        /// encoding this is one.  Custom encoding formats may use larger width
        /// if they need to encode more than 256 variants.  The schema is
        /// invalid if the value is greater than eight.
        tag_width: u8,

        /// Possible variants of the enumeration.
        /// `VariantName` is metadata, not present in a type's serialized representation.
        variants: Vec<(DiscriminantValue, VariantName, Declaration)>,
    },

    /// A structure, structurally similar to a tuple.
    Struct { fields: Fields },
}

impl Definition {
    /// Array length isn't present in payload, it's determined by type of data
    /// serialized.
    pub const ARRAY_LENGTH_WIDTH: u8 = 0;

    /// Convenience constant representing the length width of a standard borsh
    /// sequence.
    ///
    /// Can be used for `Definition::Sequence::length_width`.
    pub const DEFAULT_LENGTH_WIDTH: u8 = 4;

    /// Convenience constant representing the length range of a standard borsh
    /// sequence.
    ///
    /// It equals `0..=u32::MAX`.  Can be used with
    /// `Definition::Sequence::length_range`.
    pub const DEFAULT_LENGTH_RANGE: core::ops::RangeInclusive<u64> = 0..=(u32::MAX as u64);
}

/// The collection representing the fields of a struct.
#[derive(Clone, PartialEq, Eq, Debug, BorshSerialize, BorshDeserialize, BorshSchemaMacro)]
pub enum Fields {
    /// The struct with named fields, structurally identical to a tuple.
    /// `FieldName` is metadata, not present in a type's serialized representation.
    NamedFields(Vec<(FieldName, Declaration)>),
    /// The struct with unnamed fields, structurally identical to a tuple.
    UnnamedFields(Vec<Declaration>),
    /// The struct with no fields, structurally identical to an empty tuple.
    Empty,
}

/// All schema information needed to deserialize a single type.
#[derive(Clone, PartialEq, Eq, Debug)]
pub struct BorshSchemaContainer {
    /// Declaration of the type.
    declaration: Declaration,
    /// All definitions needed to deserialize the given type.
    definitions: BTreeMap<Declaration, Definition>,
}

impl BorshSchemaContainer {
    pub fn new(declaration: Declaration, definitions: BTreeMap<Declaration, Definition>) -> Self {
        Self {
            declaration,
            definitions,
        }
    }

    /// generate [BorshSchemaContainer] for type `T`
    pub fn for_type<T: BorshSchema + ?Sized>() -> Self {
        let mut definitions = Default::default();
        T::add_definitions_recursively(&mut definitions);
        Self::new(T::declaration(), definitions)
    }

    pub fn declaration(&self) -> &Declaration {
        &self.declaration
    }
    pub fn definitions(&self) -> impl Iterator<Item = (&'_ Declaration, &'_ Definition)> {
        self.definitions.iter()
    }

    pub fn get_definition<Q>(&self, declaration: &Q) -> Option<&Definition>
    where
        Declaration: Borrow<Q>,
        Q: Ord + ?Sized,
    {
        self.definitions.get(declaration)
    }

    pub fn get_mut_definition<Q>(&mut self, declaration: &Q) -> Option<&mut Definition>
    where
        Declaration: Borrow<Q>,
        Q: Ord + ?Sized,
    {
        self.definitions.get_mut(declaration)
    }

    pub fn insert_definition(
        &mut self,
        declaration: Declaration,
        definition: Definition,
    ) -> Option<Definition> {
        self.definitions.insert(declaration, definition)
    }
    pub fn remove_definition<Q>(&mut self, declaration: &Q) -> Option<Definition>
    where
        Declaration: Borrow<Q>,
        Q: Ord + ?Sized,
    {
        self.definitions.remove(declaration)
    }
}

impl BorshSerialize for BorshSchemaContainer
where
    Declaration: BorshSerialize,
    BTreeMap<Declaration, Definition>: BorshSerialize,
{
    fn serialize<W: Write>(&self, writer: &mut W) -> IOResult<()> {
        let declaration = self.declaration();
        let definitions: BTreeMap<&Declaration, &Definition> = self.definitions().collect();
        BorshSerialize::serialize(declaration, writer)?;
        BorshSerialize::serialize(&definitions, writer)?;
        Ok(())
    }
}

impl BorshDeserialize for BorshSchemaContainer
where
    Declaration: BorshDeserialize,
    BTreeMap<Declaration, Definition>: BorshDeserialize,
{
    fn deserialize_reader<R: Read>(reader: &mut R) -> IOResult<Self> {
        let declaration: Declaration = BorshDeserialize::deserialize_reader(reader)?;
        let definitions: BTreeMap<Declaration, Definition> =
            BorshDeserialize::deserialize_reader(reader)?;
        Ok(Self::new(declaration, definitions))
    }
}

/// Helper method to add a single type definition to the map.
pub fn add_definition(
    declaration: Declaration,
    definition: Definition,
    definitions: &mut BTreeMap<Declaration, Definition>,
) {
    match definitions.entry(declaration) {
        Entry::Occupied(occ) => {
            let existing_def = occ.get();
            assert_eq!(
                existing_def,
                &definition,
                "Redefining type schema for {}. Types with the same names are not supported.",
                occ.key()
            );
        }
        Entry::Vacant(vac) => {
            vac.insert(definition);
        }
    }
}

/// The declaration and the definition of the type that can be used to (de)serialize Borsh without
/// the Rust type that produced it.
pub trait BorshSchema {
    /// Recursively, using DFS, add type definitions required for this type.
    /// Type definition partially explains how to serialize/deserialize a type.
    fn add_definitions_recursively(definitions: &mut BTreeMap<Declaration, Definition>);

    /// Get the name of the type without brackets.
    fn declaration() -> Declaration;
}

impl BorshSchema for BorshSchemaContainer
where
    Declaration: BorshSchema,
    BTreeMap<Declaration, Definition>: BorshSchema,
{
    fn declaration() -> Declaration {
        "BorshSchemaContainer".to_string()
    }
    fn add_definitions_recursively(definitions: &mut BTreeMap<Declaration, Definition>) {
        let fields = Fields::NamedFields(<[_]>::into_vec(Box::new([
            (
                "declaration".to_string(),
                <Declaration as BorshSchema>::declaration(),
            ),
            (
                "definitions".to_string(),
                <BTreeMap<Declaration, Definition> as BorshSchema>::declaration(),
            ),
        ])));
        let definition = Definition::Struct { fields };
        add_definition(
            <Self as BorshSchema>::declaration(),
            definition,
            definitions,
        );
        <Declaration as BorshSchema>::add_definitions_recursively(definitions);
        <BTreeMap<Declaration, Definition> as BorshSchema>::add_definitions_recursively(
            definitions,
        );
    }
}
impl<T> BorshSchema for Box<T>
where
    T: BorshSchema + ?Sized,
{
    fn add_definitions_recursively(definitions: &mut BTreeMap<Declaration, Definition>) {
        T::add_definitions_recursively(definitions);
    }

    fn declaration() -> Declaration {
        T::declaration()
    }
}

impl<T> BorshSchema for core::cell::Cell<T>
where
    T: BorshSchema + Copy,
{
    fn add_definitions_recursively(definitions: &mut BTreeMap<Declaration, Definition>) {
        T::add_definitions_recursively(definitions);
    }

    fn declaration() -> Declaration {
        T::declaration()
    }
}

impl<T> BorshSchema for core::cell::RefCell<T>
where
    T: BorshSchema + Sized,
{
    fn add_definitions_recursively(definitions: &mut BTreeMap<Declaration, Definition>) {
        T::add_definitions_recursively(definitions);
    }

    fn declaration() -> Declaration {
        T::declaration()
    }
}
/// Module is available if borsh is built with `features = ["rc"]`.
#[cfg(feature = "rc")]
pub mod rc {
    //!
    //! Module defines [BorshSchema] implementation for
    //! [alloc::rc::Rc](std::rc::Rc) and [alloc::sync::Arc](std::sync::Arc).
    use crate::BorshSchema;

    use super::{Declaration, Definition};
    use crate::__private::maybestd::collections::BTreeMap;
    use crate::__private::maybestd::{rc::Rc, sync::Arc};

    impl<T> BorshSchema for Rc<T>
    where
        T: BorshSchema + ?Sized,
    {
        fn add_definitions_recursively(definitions: &mut BTreeMap<Declaration, Definition>) {
            T::add_definitions_recursively(definitions);
        }

        fn declaration() -> Declaration {
            T::declaration()
        }
    }

    impl<T> BorshSchema for Arc<T>
    where
        T: BorshSchema + ?Sized,
    {
        fn add_definitions_recursively(definitions: &mut BTreeMap<Declaration, Definition>) {
            T::add_definitions_recursively(definitions);
        }

        fn declaration() -> Declaration {
            T::declaration()
        }
    }
}

impl<T> BorshSchema for borrow::Cow<'_, T>
where
    T: borrow::ToOwned + ?Sized,
    T::Owned: BorshSchema,
{
    fn add_definitions_recursively(definitions: &mut BTreeMap<Declaration, Definition>) {
        <T::Owned as BorshSchema>::add_definitions_recursively(definitions);
    }

    fn declaration() -> Declaration {
        <T::Owned as BorshSchema>::declaration()
    }
}

macro_rules! impl_for_renamed_primitives {
    ($($ty: ty : $name: ident => $size: expr);+) => {
    $(
        impl BorshSchema for $ty {
            #[inline]
            fn add_definitions_recursively(definitions: &mut BTreeMap<Declaration, Definition>) {
                let definition = Definition::Primitive($size);
                add_definition(Self::declaration(), definition, definitions);
            }
            #[inline]
            fn declaration() -> Declaration { stringify!($name).into() }
        }
    )+
    };

    ($($ty: ty : $name: expr, $size: expr);+) => {
    $(
        impl BorshSchema for $ty {
            #[inline]
            fn add_definitions_recursively(definitions: &mut BTreeMap<Declaration, Definition>) {
                let definition = Definition::Primitive($size);
                add_definition(Self::declaration(), definition, definitions);
            }
            #[inline]
            fn declaration() -> Declaration { $name.into() }
        }
    )+
    };
}

macro_rules! impl_for_primitives {
    ($($ty: ident => $size: expr);+) => {
        impl_for_renamed_primitives!{$($ty : $ty => $size);+}
    };
}

impl_for_primitives!(bool => 1; f32 => 4; f64 => 8; i8 => 1; i16 => 2; i32 => 4; i64 => 8; i128 => 16);
impl_for_primitives!(u8 => 1; u16 => 2; u32 => 4; u64 => 8; u128 => 16);
impl_for_renamed_primitives!(isize: i64 => 8);
impl_for_renamed_primitives!(usize: u64 => 8);

impl_for_renamed_primitives!(core::num::NonZeroI8: NonZeroI8 => 1);
impl_for_renamed_primitives!(core::num::NonZeroI16: NonZeroI16 => 2);
impl_for_renamed_primitives!(core::num::NonZeroI32: NonZeroI32 => 4);
impl_for_renamed_primitives!(core::num::NonZeroI64: NonZeroI64 => 8);
impl_for_renamed_primitives!(core::num::NonZeroI128: NonZeroI128 => 16);
impl_for_renamed_primitives!(core::num::NonZeroU8: NonZeroU8 => 1);
impl_for_renamed_primitives!(core::num::NonZeroU16: NonZeroU16 => 2);
impl_for_renamed_primitives!(core::num::NonZeroU32: NonZeroU32 => 4);
impl_for_renamed_primitives!(core::num::NonZeroU64: NonZeroU64 => 8);
impl_for_renamed_primitives!(core::num::NonZeroU128: NonZeroU128 => 16);
// see 12 lines above
impl_for_renamed_primitives!(core::num::NonZeroUsize: NonZeroUsize => 8);

impl_for_renamed_primitives!((): "()", 0);

impl BorshSchema for String {
    #[inline]
    fn add_definitions_recursively(definitions: &mut BTreeMap<Declaration, Definition>) {
        str::add_definitions_recursively(definitions);
    }
    #[inline]
    fn declaration() -> Declaration {
        str::declaration()
    }
}

impl BorshSchema for str {
    #[inline]
    fn add_definitions_recursively(definitions: &mut BTreeMap<Declaration, Definition>) {
        let definition = Definition::Sequence {
            length_width: Definition::DEFAULT_LENGTH_WIDTH,
            length_range: Definition::DEFAULT_LENGTH_RANGE,
            elements: u8::declaration(),
        };
        add_definition(Self::declaration(), definition, definitions);
        u8::add_definitions_recursively(definitions);
    }
    #[inline]
    fn declaration() -> Declaration {
        "String".into()
    }
}

/// Module is available if borsh is built with `features = ["ascii"]`.
#[cfg(feature = "ascii")]
pub mod ascii {
    //!
    //! Module defines [BorshSchema] implementation for
    //! some types from [ascii](::ascii) crate.
    use crate::BorshSchema;

    use super::{add_definition, Declaration, Definition};
    use crate::__private::maybestd::collections::BTreeMap;

    impl BorshSchema for ascii::AsciiString {
        #[inline]
        fn add_definitions_recursively(definitions: &mut BTreeMap<Declaration, Definition>) {
            ascii::AsciiStr::add_definitions_recursively(definitions);
        }
        #[inline]
        fn declaration() -> Declaration {
            ascii::AsciiStr::declaration()
        }
    }

    impl BorshSchema for ascii::AsciiStr {
        #[inline]
        fn add_definitions_recursively(definitions: &mut BTreeMap<Declaration, Definition>) {
            let definition = Definition::Sequence {
                length_width: Definition::DEFAULT_LENGTH_WIDTH,
                length_range: Definition::DEFAULT_LENGTH_RANGE,
                elements: ascii::AsciiChar::declaration(),
            };
            add_definition(Self::declaration(), definition, definitions);
            ascii::AsciiChar::add_definitions_recursively(definitions);
        }
        #[inline]
        fn declaration() -> Declaration {
            "AsciiString".into()
        }
    }

    impl BorshSchema for ascii::AsciiChar {
        #[inline]
        fn add_definitions_recursively(definitions: &mut BTreeMap<Declaration, Definition>) {
            add_definition(Self::declaration(), Definition::Primitive(1), definitions);
        }
        #[inline]
        fn declaration() -> Declaration {
            "AsciiChar".into()
        }
    }
}

impl BorshSchema for core::ops::RangeFull {
    #[inline]
    fn add_definitions_recursively(definitions: &mut BTreeMap<Declaration, Definition>) {
        let fields = Fields::Empty;
        let def = Definition::Struct { fields };
        add_definition(Self::declaration(), def, definitions);
    }
    #[inline]
    fn declaration() -> Declaration {
        "RangeFull".into()
    }
}

macro_rules! impl_for_range {
    ($type:ident, $($name:ident),*) => {
        impl<T: BorshSchema> BorshSchema for core::ops::$type<T> {
            fn add_definitions_recursively(definitions: &mut BTreeMap<Declaration, Definition>) {
                let decl = T::declaration();
                let fields = Fields::NamedFields(vec![$(
                    (FieldName::from(stringify!($name)), decl.clone())
                ),*]);
                let def = Definition::Struct { fields };
                add_definition(Self::declaration(), def, definitions);
                T::add_definitions_recursively(definitions);
            }
            fn declaration() -> Declaration {
                format!("{}<{}>", stringify!($type), T::declaration())
            }
        }
    };
}

impl_for_range!(Range, start, end);
impl_for_range!(RangeInclusive, start, end);
impl_for_range!(RangeFrom, start);
impl_for_range!(RangeTo, end);
impl_for_range!(RangeToInclusive, end);

impl<T, const N: usize> BorshSchema for [T; N]
where
    T: BorshSchema,
{
    fn add_definitions_recursively(definitions: &mut BTreeMap<Declaration, Definition>) {
        use core::convert::TryFrom;
        let length = u64::try_from(N).unwrap();
        let definition = Definition::Sequence {
            length_width: Definition::ARRAY_LENGTH_WIDTH,
            length_range: length..=length,
            elements: T::declaration(),
        };
        add_definition(Self::declaration(), definition, definitions);
        T::add_definitions_recursively(definitions);
    }
    fn declaration() -> Declaration {
        format!(r#"[{}; {}]"#, T::declaration(), N)
    }
}

impl<T> BorshSchema for Option<T>
where
    T: BorshSchema,
{
    fn add_definitions_recursively(definitions: &mut BTreeMap<Declaration, Definition>) {
        let definition = Definition::Enum {
            tag_width: 1,
            variants: vec![
                (0u8 as i64, "None".to_string(), <()>::declaration()),
                (1u8 as i64, "Some".to_string(), T::declaration()),
            ],
        };
        add_definition(Self::declaration(), definition, definitions);
        T::add_definitions_recursively(definitions);
        <()>::add_definitions_recursively(definitions);
    }

    fn declaration() -> Declaration {
        format!(r#"Option<{}>"#, T::declaration())
    }
}

impl<T, E> BorshSchema for core::result::Result<T, E>
where
    T: BorshSchema,
    E: BorshSchema,
{
    fn add_definitions_recursively(definitions: &mut BTreeMap<Declaration, Definition>) {
        let definition = Definition::Enum {
            tag_width: 1,
            variants: vec![
                (1u8 as i64, "Ok".to_string(), T::declaration()),
                (0u8 as i64, "Err".to_string(), E::declaration()),
            ],
        };
        add_definition(Self::declaration(), definition, definitions);
        T::add_definitions_recursively(definitions);
        E::add_definitions_recursively(definitions);
    }

    fn declaration() -> Declaration {
        format!(r#"Result<{}, {}>"#, T::declaration(), E::declaration())
    }
}

macro_rules! impl_for_vec_like_collection {
    ($type: ident) => {
        impl<T> BorshSchema for $type<T>
        where
            T: BorshSchema,
        {
            fn add_definitions_recursively(definitions: &mut BTreeMap<Declaration, Definition>) {
                let definition = Definition::Sequence {
                    length_width: Definition::DEFAULT_LENGTH_WIDTH,
                    length_range: Definition::DEFAULT_LENGTH_RANGE,
                    elements: T::declaration(),
                };
                add_definition(Self::declaration(), definition, definitions);
                T::add_definitions_recursively(definitions);
            }

            fn declaration() -> Declaration {
                format!(r#"{}<{}>"#, stringify!($type), T::declaration())
            }
        }
    };
}

impl_for_vec_like_collection!(Vec);
impl_for_vec_like_collection!(VecDeque);
impl_for_vec_like_collection!(LinkedList);

impl<T> BorshSchema for [T]
where
    T: BorshSchema,
{
    fn add_definitions_recursively(definitions: &mut BTreeMap<Declaration, Definition>) {
        let definition = Definition::Sequence {
            length_width: Definition::DEFAULT_LENGTH_WIDTH,
            length_range: Definition::DEFAULT_LENGTH_RANGE,
            elements: T::declaration(),
        };
        add_definition(Self::declaration(), definition, definitions);
        T::add_definitions_recursively(definitions);
    }

    fn declaration() -> Declaration {
        format!(r#"Vec<{}>"#, T::declaration())
    }
}

/// Module is available if borsh is built with `features = ["std"]` or `features = ["hashbrown"]`.
#[cfg(hash_collections)]
pub mod hashes {
    //!
    //! Module defines [BorshSchema] implementation for
    //! [HashMap](std::collections::HashMap)/[HashSet](std::collections::HashSet).
    use crate::BorshSchema;

    use super::{add_definition, Declaration, Definition};
    use crate::__private::maybestd::collections::BTreeMap;

    use crate::__private::maybestd::collections::{HashMap, HashSet};
    #[cfg(not(feature = "std"))]
    use alloc::format;

    impl<K, V> BorshSchema for HashMap<K, V>
    where
        K: BorshSchema,
        V: BorshSchema,
    {
        fn add_definitions_recursively(definitions: &mut BTreeMap<Declaration, Definition>) {
            let definition = Definition::Sequence {
                length_width: Definition::DEFAULT_LENGTH_WIDTH,
                length_range: Definition::DEFAULT_LENGTH_RANGE,
                elements: <(K, V)>::declaration(),
            };
            add_definition(Self::declaration(), definition, definitions);
            <(K, V)>::add_definitions_recursively(definitions);
        }

        fn declaration() -> Declaration {
            format!(r#"HashMap<{}, {}>"#, K::declaration(), V::declaration())
        }
    }
    impl<T> BorshSchema for HashSet<T>
    where
        T: BorshSchema,
    {
        fn add_definitions_recursively(definitions: &mut BTreeMap<Declaration, Definition>) {
            let definition = Definition::Sequence {
                length_width: Definition::DEFAULT_LENGTH_WIDTH,
                length_range: Definition::DEFAULT_LENGTH_RANGE,
                elements: <T>::declaration(),
            };
            add_definition(Self::declaration(), definition, definitions);
            <T>::add_definitions_recursively(definitions);
        }

        fn declaration() -> Declaration {
            format!(r#"HashSet<{}>"#, T::declaration())
        }
    }
}

impl<K, V> BorshSchema for BTreeMap<K, V>
where
    K: BorshSchema,
    V: BorshSchema,
{
    fn add_definitions_recursively(definitions: &mut BTreeMap<Declaration, Definition>) {
        let definition = Definition::Sequence {
            length_width: Definition::DEFAULT_LENGTH_WIDTH,
            length_range: Definition::DEFAULT_LENGTH_RANGE,
            elements: <(K, V)>::declaration(),
        };
        add_definition(Self::declaration(), definition, definitions);
        <(K, V)>::add_definitions_recursively(definitions);
    }

    fn declaration() -> Declaration {
        format!(r#"BTreeMap<{}, {}>"#, K::declaration(), V::declaration())
    }
}

impl<T> BorshSchema for BTreeSet<T>
where
    T: BorshSchema,
{
    fn add_definitions_recursively(definitions: &mut BTreeMap<Declaration, Definition>) {
        let definition = Definition::Sequence {
            length_width: Definition::DEFAULT_LENGTH_WIDTH,
            length_range: Definition::DEFAULT_LENGTH_RANGE,
            elements: <T>::declaration(),
        };
        add_definition(Self::declaration(), definition, definitions);
        <T>::add_definitions_recursively(definitions);
    }

    fn declaration() -> Declaration {
        format!(r#"BTreeSet<{}>"#, T::declaration())
    }
}

// Because it's a zero-sized marker, its type parameter doesn't need to be
// included in the schema and so it's not bound to `BorshSchema`
impl<T> BorshSchema for PhantomData<T> {
    fn add_definitions_recursively(definitions: &mut BTreeMap<Declaration, Definition>) {
        <()>::add_definitions_recursively(definitions);
    }

    fn declaration() -> Declaration {
        <()>::declaration()
    }
}

macro_rules! impl_tuple {
    ($($name:ident),+) => {
    impl<$($name),+> BorshSchema for ($($name,)+)
    where
        $($name: BorshSchema),+
    {
        fn add_definitions_recursively(definitions: &mut BTreeMap<Declaration, Definition>) {
            let elements = vec![$($name::declaration()),+];

            let definition = Definition::Tuple { elements };
            add_definition(Self::declaration(), definition, definitions);
            $(
                $name::add_definitions_recursively(definitions);
            )+
        }

        fn declaration() -> Declaration {
            let params = vec![$($name::declaration()),+];
            if params.len() == 1 {
                format!(r#"({},)"#, params[0])
            } else {
                format!(r#"({})"#, params.join(", "))
            }
        }
    }
    };
}

impl_tuple!(T0);
impl_tuple!(T0, T1);
impl_tuple!(T0, T1, T2);
impl_tuple!(T0, T1, T2, T3);
impl_tuple!(T0, T1, T2, T3, T4);
impl_tuple!(T0, T1, T2, T3, T4, T5);
impl_tuple!(T0, T1, T2, T3, T4, T5, T6);
impl_tuple!(T0, T1, T2, T3, T4, T5, T6, T7);
impl_tuple!(T0, T1, T2, T3, T4, T5, T6, T7, T8);
impl_tuple!(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9);
impl_tuple!(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10);
impl_tuple!(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11);
impl_tuple!(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12);
impl_tuple!(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13);
impl_tuple!(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14);
impl_tuple!(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15);
impl_tuple!(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16);
impl_tuple!(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17);
impl_tuple!(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18);
impl_tuple!(
    T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19
);
impl_tuple!(
    T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20
);

'''
'''--- borsh/src/schema/container_ext.rs ---
use super::{BorshSchemaContainer, Declaration, Definition, Fields};

pub use max_size::Error as SchemaMaxSerializedSizeError;
use max_size::{is_zero_size, ZeroSizeError};
pub use validate::Error as SchemaContainerValidateError;

mod max_size;
mod validate;

'''
'''--- borsh/src/schema/container_ext/max_size.rs ---
use super::{BorshSchemaContainer, Declaration, Definition, Fields};
use crate::__private::maybestd::{string::ToString, vec::Vec};

use core::num::NonZeroUsize;

/// NonZeroUsize of value one.
// TODO: Replace usage by NonZeroUsize::MIN once MSRV is 1.70+.
const ONE: NonZeroUsize = unsafe { NonZeroUsize::new_unchecked(1) };

impl BorshSchemaContainer {
    /// Returns the largest possible size of a serialised object based solely on its type.
    ///
    /// Even when if returned upper bound is correct, the theoretical value may be
    /// *much* larger than any practical length.  For example, maximum encoded
    /// length of `String` is 4 GiB while in practice one may encounter strings of
    /// at most dozen of characters.
    ///
    /// # Example
    ///
    /// ```
    /// use borsh::schema::BorshSchemaContainer;
    ///
    /// let schema = BorshSchemaContainer::for_type::<()>();
    /// assert_eq!(Ok(0), schema.max_serialized_size());
    ///
    /// let schema = BorshSchemaContainer::for_type::<usize>();
    /// assert_eq!(Ok(8), schema.max_serialized_size());
    ///
    /// // 4 bytes of length and u32::MAX for the longest possible string.
    /// let schema = BorshSchemaContainer::for_type::<String>();
    /// assert_eq!(Ok(4 + 4294967295), schema.max_serialized_size());
    ///
    /// let schema = BorshSchemaContainer::for_type::<Vec<String>>();
    /// assert_eq!(Err(borsh::schema::SchemaMaxSerializedSizeError::Overflow),
    ///            schema.max_serialized_size());
    /// ```
    pub fn max_serialized_size(&self) -> Result<usize, Error> {
        let mut stack = Vec::new();
        max_serialized_size_impl(ONE, self.declaration(), self, &mut stack)
    }
}

/// Possible error when calculating theoretical maximum size of encoded type `T`.
#[derive(Clone, PartialEq, Eq, Debug)]
pub enum Error {
    /// The theoretical maximum size of the encoded value overflows `usize`.
    ///
    /// This may happen for nested dynamically-sized types such as
    /// `Vec<Vec<u8>>` whose maximum size is `4 + u32::MAX * (4 + u32::MAX)`.
    Overflow,

    /// The type is recursive and thus theoretical maximum size is infinite.
    ///
    /// Simple type in which this triggers is `struct Rec(Option<Box<Rec>>)`.
    Recursive,

    /// Some of the declared types were lacking definition making it impossible
    /// to calculate the size.
    MissingDefinition(Declaration),
}

/// Implementation of [`BorshSchema::max_serialized_size`].
fn max_serialized_size_impl<'a>(
    count: NonZeroUsize,
    declaration: &'a str,
    schema: &'a BorshSchemaContainer,
    stack: &mut Vec<&'a str>,
) -> Result<usize, Error> {
    use core::convert::TryFrom;

    /// Maximum number of elements in a vector or length of a string which can
    /// be serialised.
    const MAX_LEN: NonZeroUsize = unsafe { NonZeroUsize::new_unchecked(u32::MAX as usize) };

    fn add(x: usize, y: usize) -> Result<usize, Error> {
        x.checked_add(y).ok_or(Error::Overflow)
    }

    fn mul(x: NonZeroUsize, y: usize) -> Result<usize, Error> {
        x.get().checked_mul(y).ok_or(Error::Overflow)
    }

    /// Calculates max serialised size of a tuple with given members.
    fn tuple<'a>(
        count: NonZeroUsize,
        elements: impl core::iter::IntoIterator<Item = &'a Declaration>,
        schema: &'a BorshSchemaContainer,
        stack: &mut Vec<&'a str>,
    ) -> Result<usize, Error> {
        let mut sum: usize = 0;
        for el in elements {
            sum = add(sum, max_serialized_size_impl(ONE, el, schema, stack)?)?;
        }
        mul(count, sum)
    }

    if stack.iter().any(|dec| *dec == declaration) {
        return Err(Error::Recursive);
    }
    stack.push(declaration);

    let res = match schema.get_definition(declaration).ok_or(declaration) {
        Ok(Definition::Primitive(size)) => match size {
            0 => Ok(0),
            size => {
                let count_sizes = usize::from(*size).checked_mul(count.get());
                count_sizes.ok_or(Error::Overflow)
            }
        },
        Ok(Definition::Sequence {
            length_width,
            length_range,
            elements,
        }) => {
            // Assume sequence has the maximum number of elements.
            let max_len = *length_range.end();
            let sz = match usize::try_from(max_len).map(NonZeroUsize::new) {
                Ok(Some(max_len)) => max_serialized_size_impl(max_len, elements, schema, stack)?,
                Ok(None) => 0,
                Err(_) if is_zero_size_impl(elements, schema, stack)? => 0,
                Err(_) => return Err(Error::Overflow),
            };
            mul(count, add(sz, usize::from(*length_width))?)
        }

        Ok(Definition::Enum {
            tag_width,
            variants,
        }) => {
            let mut max = 0;
            for (_, _, variant) in variants {
                let sz = max_serialized_size_impl(ONE, variant, schema, stack)?;
                max = max.max(sz);
            }
            add(max, usize::from(*tag_width))
        }

        // Tuples and structs sum sizes of all the members.
        Ok(Definition::Tuple { elements }) => tuple(count, elements, schema, stack),
        Ok(Definition::Struct { fields }) => match fields {
            Fields::NamedFields(fields) => {
                tuple(count, fields.iter().map(|(_, field)| field), schema, stack)
            }
            Fields::UnnamedFields(fields) => tuple(count, fields, schema, stack),
            Fields::Empty => Ok(0),
        },

        Err(declaration) => Err(Error::MissingDefinition(declaration.to_string())),
    }?;

    stack.pop();
    Ok(res)
}

/// Checks whether given declaration schema serialises to an empty string.
///
/// This is used by [`BorshSchemaContainer::max_serialized_size`] to handle weird types
/// such as `[[[(); u32::MAX]; u32::MAX]; u32::MAX]` which serialises to an
/// empty string even though its number of elements overflows `usize`.
///
/// Error value means that the method has been called recursively.
/// A recursive type either has no exit, so it cannot be instantiated
/// or it uses `Definiotion::Enum` or `Definition::Sequence` to exit from recursion
/// which make it non-zero size
pub(super) fn is_zero_size(
    declaration: &Declaration,
    schema: &BorshSchemaContainer,
) -> Result<bool, ZeroSizeError> {
    let mut stack = Vec::new();
    is_zero_size_impl(declaration, schema, &mut stack)
}

#[derive(Debug, PartialEq, Eq)]
pub(super) enum ZeroSizeError {
    Recursive,
    MissingDefinition(Declaration),
}

impl From<ZeroSizeError> for Error {
    fn from(value: ZeroSizeError) -> Self {
        match value {
            ZeroSizeError::Recursive => Self::Recursive,
            ZeroSizeError::MissingDefinition(declaration) => Self::MissingDefinition(declaration),
        }
    }
}

fn is_zero_size_impl<'a>(
    declaration: &'a str,
    schema: &'a BorshSchemaContainer,
    stack: &mut Vec<&'a str>,
) -> Result<bool, ZeroSizeError> {
    fn all<'a, T: 'a>(
        iter: impl Iterator<Item = T>,
        f_key: impl Fn(&T) -> &'a Declaration,
        schema: &'a BorshSchemaContainer,
        stack: &mut Vec<&'a str>,
    ) -> Result<bool, ZeroSizeError> {
        for element in iter {
            let declaration = f_key(&element);
            if !is_zero_size_impl(declaration.as_str(), schema, stack)? {
                return Ok(false);
            }
        }
        Ok(true)
    }

    if stack.iter().any(|dec| *dec == declaration) {
        return Err(ZeroSizeError::Recursive);
    }
    stack.push(declaration);

    let res = match schema.get_definition(declaration).ok_or(declaration) {
        Ok(Definition::Primitive(size)) => *size == 0,
        Ok(Definition::Sequence {
            length_width,
            length_range,
            elements,
        }) => {
            if *length_width == 0 {
                // zero-sized array
                if length_range.clone().count() == 1 && *length_range.start() == 0 {
                    return Ok(true);
                }
                if is_zero_size_impl(elements.as_str(), schema, stack)? {
                    return Ok(true);
                }
            }
            false
        }
        Ok(Definition::Tuple { elements }) => all(elements.iter(), |key| *key, schema, stack)?,
        Ok(Definition::Enum {
            tag_width: 0,
            variants,
        }) => all(
            variants.iter(),
            |(_variant_discrim, _variant_name, declaration)| declaration,
            schema,
            stack,
        )?,
        Ok(Definition::Enum { .. }) => false,
        Ok(Definition::Struct { fields }) => match fields {
            Fields::NamedFields(fields) => all(
                fields.iter(),
                |(_field_name, declaration)| declaration,
                schema,
                stack,
            )?,
            Fields::UnnamedFields(fields) => {
                all(fields.iter(), |declaration| declaration, schema, stack)?
            }
            Fields::Empty => true,
        },

        Err(declaration) => {
            return Err(ZeroSizeError::MissingDefinition(declaration.into()));
        }
    };
    stack.pop();
    Ok(res)
}

#[cfg(test)]
mod tests {
    use super::*;

    // this is not integration test module, so can use __private for ease of imports;
    // it cannot be made integration, as it tests `is_zero_size` function, chosen to be non-pub
    use crate::__private::maybestd::{boxed::Box, string::ToString};

    #[test]
    fn test_is_zero_size_recursive_check_bypassed() {
        use crate as borsh;

        #[derive(::borsh_derive::BorshSchema)]
        struct RecursiveExitSequence(Vec<RecursiveExitSequence>);

        let schema = BorshSchemaContainer::for_type::<RecursiveExitSequence>();
        assert_eq!(Ok(false), is_zero_size(schema.declaration(), &schema));
    }

    #[test]
    fn test_is_zero_size_recursive_check_err() {
        use crate as borsh;

        #[derive(::borsh_derive::BorshSchema)]
        struct RecursiveNoExitStructUnnamed(Box<RecursiveNoExitStructUnnamed>);

        let schema = BorshSchemaContainer::for_type::<RecursiveNoExitStructUnnamed>();
        assert_eq!(
            Err(ZeroSizeError::Recursive),
            is_zero_size(schema.declaration(), &schema)
        );
    }
}

'''
'''--- borsh/src/schema/container_ext/validate.rs ---
use super::{is_zero_size, ZeroSizeError};
use super::{BorshSchemaContainer, Declaration, Definition, Fields};
use crate::__private::maybestd::{string::ToString, vec::Vec};

impl BorshSchemaContainer {
    /// Validates container for violation of any well-known rules with
    /// respect to `borsh` serialization.
    ///
    /// # Example
    ///
    /// ```
    /// use borsh::schema::BorshSchemaContainer;
    ///
    /// let schema = BorshSchemaContainer::for_type::<usize>();
    /// assert_eq!(Ok(()), schema.validate());
    /// ```
    pub fn validate(&self) -> core::result::Result<(), Error> {
        let mut stack = Vec::new();
        validate_impl(self.declaration(), self, &mut stack)
    }
}

/// Possible error when validating a [`BorshSchemaContainer`], generated for some type `T`,
/// for violation of any well-known rules with respect to `borsh` serialization.
#[derive(Clone, PartialEq, Eq, Debug)]
pub enum Error {
    /// sequences of zero-sized types of dynamic length are forbidden by definition
    /// see <https://github.com/near/borsh-rs/pull/202> and related ones
    ZSTSequence(Declaration),
    /// Declared tag width is too large.  Tags may be at most eight bytes.
    TagTooWide(Declaration),
    /// Declared tag width is too small.  Tags must be large enough to represent
    /// possible length of sequence.
    TagTooNarrow(Declaration),
    /// only 0, 1, 2, 4 and 8 bytes long sequences' `length_width` are allowed
    TagNotPowerOfTwo(Declaration),
    /// Some of the declared types were lacking definition, which is considered
    /// a container's validation error
    MissingDefinition(Declaration),
    /// A Sequence defined with an empty length range.
    EmptyLengthRange(Declaration),
}

fn check_length_width(declaration: &Declaration, width: u8, max: u64) -> Result<(), Error> {
    match width {
        0 => Ok(()),
        3 | 5 | 6 | 7 => Err(Error::TagNotPowerOfTwo(declaration.clone())),
        1..=7 if max < 1 << (width * 8) => Ok(()),
        1..=7 => Err(Error::TagTooNarrow(declaration.clone())),
        8 => Ok(()),
        _ => Err(Error::TagTooWide(declaration.clone())),
    }
}

const U64_LEN: u8 = 8;

fn validate_impl<'a>(
    declaration: &'a Declaration,
    schema: &'a BorshSchemaContainer,
    stack: &mut Vec<&'a Declaration>,
) -> core::result::Result<(), Error> {
    let definition = match schema.get_definition(declaration) {
        Some(definition) => definition,
        None => {
            return Err(Error::MissingDefinition(declaration.to_string()));
        }
    };
    if stack.iter().any(|dec| *dec == declaration) {
        return Ok(());
    }
    stack.push(declaration);
    match definition {
        Definition::Primitive(_size) => {}
        // arrays branch
        Definition::Sequence {
            length_width,
            length_range,
            elements,
        } if *length_width == Definition::ARRAY_LENGTH_WIDTH
            && length_range.clone().count() == 1 =>
        {
            validate_impl(elements, schema, stack)?
        }
        Definition::Sequence {
            length_width,
            length_range,
            elements,
        } => {
            if length_range.is_empty() {
                return Err(Error::EmptyLengthRange(declaration.clone()));
            }
            check_length_width(declaration, *length_width, *length_range.end())?;
            match is_zero_size(elements, schema) {
                Ok(true) => return Err(Error::ZSTSequence(declaration.clone())),
                Ok(false) => (),
                // a recursive type either has no exit, so it cannot be instantiated
                // or it uses `Definiotion::Enum` or `Definition::Sequence` to exit from recursion
                // which make it non-zero size
                Err(ZeroSizeError::Recursive) => (),
                Err(ZeroSizeError::MissingDefinition(declaration)) => {
                    return Err(Error::MissingDefinition(declaration));
                }
            }
            validate_impl(elements, schema, stack)?;
        }
        Definition::Enum {
            tag_width,
            variants,
        } => {
            if *tag_width > U64_LEN {
                return Err(Error::TagTooWide(declaration.to_string()));
            }
            for (_, _, variant) in variants {
                validate_impl(variant, schema, stack)?;
            }
        }
        Definition::Tuple { elements } => {
            for element_type in elements {
                validate_impl(element_type, schema, stack)?;
            }
        }
        Definition::Struct { fields } => match fields {
            Fields::NamedFields(fields) => {
                for (_field_name, field_type) in fields {
                    validate_impl(field_type, schema, stack)?;
                }
            }
            Fields::UnnamedFields(fields) => {
                for field_type in fields {
                    validate_impl(field_type, schema, stack)?;
                }
            }
            Fields::Empty => {}
        },
    };
    stack.pop();
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::{check_length_width, Error};
    use crate::__private::maybestd::string::ToString;

    #[test]
    fn test_check_tag_width() {
        let narrow_err: Result<(), Error> = Err(Error::TagTooNarrow("test".to_string()));
        let power_of_two_err: Result<(), Error> = Err(Error::TagNotPowerOfTwo("test".to_string()));

        for (width, max, want) in [
            (0, u64::MAX, Ok(())),
            (1, u8::MAX as u64, Ok(())),
            (1, u8::MAX as u64 + 1, narrow_err.clone()),
            (2, u16::MAX as u64, Ok(())),
            (2, u16::MAX as u64 + 1, narrow_err.clone()),
            (3, 100, power_of_two_err.clone()),
            (4, u32::MAX as u64, Ok(())),
            (4, u32::MAX as u64 + 1, narrow_err),
            (5, 100, power_of_two_err.clone()),
            (6, 100, power_of_two_err.clone()),
            (7, 100, power_of_two_err),
            (8, u64::MAX, Ok(())),
        ] {
            assert_eq!(
                want,
                check_length_width(&"test".into(), width, max),
                "width={width}; max={max}"
            );
        }
    }
}

'''
'''--- borsh/src/schema_helpers.rs ---
use crate::__private::maybestd::vec::Vec;
use crate::from_slice;
use crate::io::{Error, ErrorKind, Result};
use crate::schema::{BorshSchemaContainer, SchemaMaxSerializedSizeError};
use crate::{BorshDeserialize, BorshSchema, BorshSerialize};

/// Deserialize this instance from a slice of bytes, but assume that at the beginning we have
/// bytes describing the schema of the type. We deserialize this schema and verify that it is
/// correct.
pub fn try_from_slice_with_schema<T: BorshDeserialize + BorshSchema>(v: &[u8]) -> Result<T> {
    let (schema, object) = from_slice::<(BorshSchemaContainer, T)>(v)?;
    if schema_container_of::<T>() != schema {
        return Err(Error::new(
            ErrorKind::InvalidData,
            "Borsh schema does not match",
        ));
    }
    Ok(object)
}

/// Serialize object into a vector of bytes and prefix with the schema serialized as vector of
/// bytes in Borsh format.
pub fn try_to_vec_with_schema<T: BorshSerialize + BorshSchema + ?Sized>(
    value: &T,
) -> Result<Vec<u8>> {
    let schema = schema_container_of::<T>();
    let mut res = crate::to_vec(&schema)?;
    value.serialize(&mut res)?;
    Ok(res)
}

/// generate [BorshSchemaContainer] for type `T`
///
/// this is an alias of [BorshSchemaContainer::for_type]
pub fn schema_container_of<T: BorshSchema + ?Sized>() -> BorshSchemaContainer {
    BorshSchemaContainer::for_type::<T>()
}

/// Returns the largest possible size of a serialised object based solely on its type `T`.
///
/// this is a shortcut for using [BorshSchemaContainer::max_serialized_size]
/// # Example
///
/// ```
/// use borsh::schema::BorshSchemaContainer;
///
/// assert_eq!(Ok(8), borsh::max_serialized_size::<usize>());
/// ```
pub fn max_serialized_size<T: BorshSchema + ?Sized>(
) -> core::result::Result<usize, SchemaMaxSerializedSizeError> {
    let schema = BorshSchemaContainer::for_type::<T>();
    schema.max_serialized_size()
}

'''
'''--- borsh/src/ser/helpers.rs ---
use crate::BorshSerialize;
use crate::__private::maybestd::vec::Vec;
use crate::io::{ErrorKind, Result, Write};

pub(super) const DEFAULT_SERIALIZER_CAPACITY: usize = 1024;

/// Serialize an object into a vector of bytes.
/// # Example
///
/// ```
/// assert_eq!(vec![12, 0, 0, 0, 0, 0, 0, 0], borsh::to_vec(&12u64).unwrap());
/// ```
pub fn to_vec<T>(value: &T) -> Result<Vec<u8>>
where
    T: BorshSerialize + ?Sized,
{
    let mut result = Vec::with_capacity(DEFAULT_SERIALIZER_CAPACITY);
    value.serialize(&mut result)?;
    Ok(result)
}

/// Serializes an object directly into a `Writer`.
/// # Example
///
/// ```
/// # #[cfg(feature = "std")]
/// let stderr = std::io::stderr();
/// # #[cfg(feature = "std")]
/// assert_eq!((), borsh::to_writer(&stderr, "hello_0x0a").unwrap());
/// ```
pub fn to_writer<T, W: Write>(mut writer: W, value: &T) -> Result<()>
where
    T: BorshSerialize + ?Sized,
{
    value.serialize(&mut writer)
}

/// Serializes an object without allocation to compute and return its length
/// # Example
///
/// ```
/// use borsh::BorshSerialize;
///
/// /// derive is only available if borsh is built with `features = ["derive"]`
/// # #[cfg(feature = "derive")]
/// #[derive(BorshSerialize)]
/// struct A {
///     tag: String,
///     value: u64,
/// };
///
/// # #[cfg(feature = "derive")]
/// let a = A { tag: "hello".to_owned(), value: 42 };
///
/// assert_eq!(8, borsh::object_length(&12u64).unwrap());
/// # #[cfg(feature = "derive")]
/// assert_eq!(17, borsh::object_length(&a).unwrap());
/// ```
pub fn object_length<T>(value: &T) -> Result<usize>
where
    T: BorshSerialize + ?Sized,
{
    // copy-paste of solution provided by @matklad
    // in https://github.com/near/borsh-rs/issues/23#issuecomment-816633365
    struct LengthWriter {
        len: usize,
    }
    impl Write for LengthWriter {
        #[inline]
        fn write(&mut self, buf: &[u8]) -> Result<usize> {
            let res = self.len.checked_add(buf.len());
            self.len = match res {
                Some(res) => res,
                None => {
                    return Err(ErrorKind::OutOfMemory.into());
                }
            };
            Ok(buf.len())
        }
        #[inline]
        fn flush(&mut self) -> Result<()> {
            Ok(())
        }
    }
    let mut w = LengthWriter { len: 0 };
    value.serialize(&mut w)?;
    Ok(w.len)
}

'''
'''--- borsh/src/ser/mod.rs ---
use core::convert::TryFrom;
use core::marker::PhantomData;

use crate::__private::maybestd::{
    borrow::{Cow, ToOwned},
    boxed::Box,
    collections::{BTreeMap, BTreeSet, LinkedList, VecDeque},
    string::String,
    vec::Vec,
};
use crate::error::check_zst;
use crate::io::{Error, ErrorKind, Result, Write};

pub(crate) mod helpers;

const FLOAT_NAN_ERR: &str = "For portability reasons we do not allow to serialize NaNs.";

/// A data-structure that can be serialized into binary format by NBOR.
///
/// ```
/// use borsh::BorshSerialize;
///
/// /// derive is only available if borsh is built with `features = ["derive"]`
/// # #[cfg(feature = "derive")]
/// #[derive(BorshSerialize)]
/// struct MyBorshSerializableStruct {
///     value: String,
/// }
///
///
/// # #[cfg(feature = "derive")]
/// let x = MyBorshSerializableStruct { value: "hello".to_owned() };
/// let mut buffer: Vec<u8> = Vec::new();
/// # #[cfg(feature = "derive")]
/// x.serialize(&mut buffer).unwrap();
/// # #[cfg(feature = "derive")]
/// let single_serialized_buffer_len = buffer.len();
///
/// # #[cfg(feature = "derive")]
/// x.serialize(&mut buffer).unwrap();
/// # #[cfg(feature = "derive")]
/// assert_eq!(buffer.len(), single_serialized_buffer_len * 2);
///
/// # #[cfg(feature = "derive")]
/// let mut buffer: Vec<u8> = vec![0; 1024 + single_serialized_buffer_len];
/// # #[cfg(feature = "derive")]
/// let mut buffer_slice_enough_for_the_data = &mut buffer[1024..1024 + single_serialized_buffer_len];
/// # #[cfg(feature = "derive")]
/// x.serialize(&mut buffer_slice_enough_for_the_data).unwrap();
/// ```
pub trait BorshSerialize {
    fn serialize<W: Write>(&self, writer: &mut W) -> Result<()>;

    #[inline]
    #[doc(hidden)]
    fn u8_slice(slice: &[Self]) -> Option<&[u8]>
    where
        Self: Sized,
    {
        let _ = slice;
        None
    }
}

impl BorshSerialize for u8 {
    #[inline]
    fn serialize<W: Write>(&self, writer: &mut W) -> Result<()> {
        writer.write_all(core::slice::from_ref(self))
    }

    #[inline]
    fn u8_slice(slice: &[Self]) -> Option<&[u8]> {
        Some(slice)
    }
}

macro_rules! impl_for_integer {
    ($type: ident) => {
        impl BorshSerialize for $type {
            #[inline]
            fn serialize<W: Write>(&self, writer: &mut W) -> Result<()> {
                let bytes = self.to_le_bytes();
                writer.write_all(&bytes)
            }
        }
    };
}

impl_for_integer!(i8);
impl_for_integer!(i16);
impl_for_integer!(i32);
impl_for_integer!(i64);
impl_for_integer!(i128);
impl_for_integer!(u16);
impl_for_integer!(u32);
impl_for_integer!(u64);
impl_for_integer!(u128);

macro_rules! impl_for_nonzero_integer {
    ($type: ty) => {
        impl BorshSerialize for $type {
            #[inline]
            fn serialize<W: Write>(&self, writer: &mut W) -> Result<()> {
                BorshSerialize::serialize(&self.get(), writer)
            }
        }
    };
}

impl_for_nonzero_integer!(core::num::NonZeroI8);
impl_for_nonzero_integer!(core::num::NonZeroI16);
impl_for_nonzero_integer!(core::num::NonZeroI32);
impl_for_nonzero_integer!(core::num::NonZeroI64);
impl_for_nonzero_integer!(core::num::NonZeroI128);
impl_for_nonzero_integer!(core::num::NonZeroU8);
impl_for_nonzero_integer!(core::num::NonZeroU16);
impl_for_nonzero_integer!(core::num::NonZeroU32);
impl_for_nonzero_integer!(core::num::NonZeroU64);
impl_for_nonzero_integer!(core::num::NonZeroU128);
impl_for_nonzero_integer!(core::num::NonZeroUsize);

impl BorshSerialize for isize {
    fn serialize<W: Write>(&self, writer: &mut W) -> Result<()> {
        BorshSerialize::serialize(&(*self as i64), writer)
    }
}

impl BorshSerialize for usize {
    fn serialize<W: Write>(&self, writer: &mut W) -> Result<()> {
        BorshSerialize::serialize(&(*self as u64), writer)
    }
}

// Note NaNs have a portability issue. Specifically, signalling NaNs on MIPS are quiet NaNs on x86,
// and vice-versa. We disallow NaNs to avoid this issue.
macro_rules! impl_for_float {
    ($type: ident) => {
        impl BorshSerialize for $type {
            #[inline]
            fn serialize<W: Write>(&self, writer: &mut W) -> Result<()> {
                if self.is_nan() {
                    return Err(Error::new(ErrorKind::InvalidData, FLOAT_NAN_ERR));
                }
                writer.write_all(&self.to_bits().to_le_bytes())
            }
        }
    };
}

impl_for_float!(f32);
impl_for_float!(f64);

impl BorshSerialize for bool {
    #[inline]
    fn serialize<W: Write>(&self, writer: &mut W) -> Result<()> {
        (u8::from(*self)).serialize(writer)
    }
}

impl<T> BorshSerialize for Option<T>
where
    T: BorshSerialize,
{
    #[inline]
    fn serialize<W: Write>(&self, writer: &mut W) -> Result<()> {
        match self {
            None => 0u8.serialize(writer),
            Some(value) => {
                1u8.serialize(writer)?;
                value.serialize(writer)
            }
        }
    }
}

impl<T, E> BorshSerialize for core::result::Result<T, E>
where
    T: BorshSerialize,
    E: BorshSerialize,
{
    #[inline]
    fn serialize<W: Write>(&self, writer: &mut W) -> Result<()> {
        match self {
            Err(e) => {
                0u8.serialize(writer)?;
                e.serialize(writer)
            }
            Ok(v) => {
                1u8.serialize(writer)?;
                v.serialize(writer)
            }
        }
    }
}

impl BorshSerialize for str {
    #[inline]
    fn serialize<W: Write>(&self, writer: &mut W) -> Result<()> {
        self.as_bytes().serialize(writer)
    }
}

impl BorshSerialize for String {
    #[inline]
    fn serialize<W: Write>(&self, writer: &mut W) -> Result<()> {
        self.as_bytes().serialize(writer)
    }
}

/// Module is available if borsh is built with `features = ["ascii"]`.
#[cfg(feature = "ascii")]
pub mod ascii {
    //!
    //! Module defines [BorshSerialize] implementation for
    //! some types from [ascii](::ascii) crate.
    use super::BorshSerialize;
    use crate::io::{Result, Write};

    impl BorshSerialize for ascii::AsciiChar {
        #[inline]
        fn serialize<W: Write>(&self, writer: &mut W) -> Result<()> {
            self.as_byte().serialize(writer)
        }
    }

    impl BorshSerialize for ascii::AsciiStr {
        #[inline]
        fn serialize<W: Write>(&self, writer: &mut W) -> Result<()> {
            self.as_bytes().serialize(writer)
        }
    }

    impl BorshSerialize for ascii::AsciiString {
        #[inline]
        fn serialize<W: Write>(&self, writer: &mut W) -> Result<()> {
            self.as_bytes().serialize(writer)
        }
    }
}

/// Helper method that is used to serialize a slice of data (without the length marker).
#[inline]
fn serialize_slice<T: BorshSerialize, W: Write>(data: &[T], writer: &mut W) -> Result<()> {
    if let Some(u8_slice) = T::u8_slice(data) {
        writer.write_all(u8_slice)?;
    } else {
        for item in data {
            item.serialize(writer)?;
        }
    }
    Ok(())
}

impl<T> BorshSerialize for [T]
where
    T: BorshSerialize,
{
    #[inline]
    fn serialize<W: Write>(&self, writer: &mut W) -> Result<()> {
        writer.write_all(
            &(u32::try_from(self.len()).map_err(|_| ErrorKind::InvalidData)?).to_le_bytes(),
        )?;
        serialize_slice(self, writer)
    }
}

impl<T: BorshSerialize + ?Sized> BorshSerialize for &T {
    #[inline]
    fn serialize<W: Write>(&self, writer: &mut W) -> Result<()> {
        (*self).serialize(writer)
    }
}

impl<T> BorshSerialize for Cow<'_, T>
where
    T: BorshSerialize + ToOwned + ?Sized,
{
    #[inline]
    fn serialize<W: Write>(&self, writer: &mut W) -> Result<()> {
        self.as_ref().serialize(writer)
    }
}

impl<T> BorshSerialize for Vec<T>
where
    T: BorshSerialize,
{
    #[inline]
    fn serialize<W: Write>(&self, writer: &mut W) -> Result<()> {
        check_zst::<T>()?;

        self.as_slice().serialize(writer)
    }
}

#[cfg(feature = "bytes")]
impl BorshSerialize for bytes::Bytes {
    #[inline]
    fn serialize<W: Write>(&self, writer: &mut W) -> Result<()> {
        self.as_ref().serialize(writer)
    }
}

#[cfg(feature = "bytes")]
impl BorshSerialize for bytes::BytesMut {
    #[inline]
    fn serialize<W: Write>(&self, writer: &mut W) -> Result<()> {
        self.as_ref().serialize(writer)
    }
}

#[cfg(feature = "bson")]
impl BorshSerialize for bson::oid::ObjectId {
    #[inline]
    fn serialize<W: Write>(&self, writer: &mut W) -> Result<()> {
        self.bytes().serialize(writer)
    }
}

impl<T> BorshSerialize for VecDeque<T>
where
    T: BorshSerialize,
{
    #[inline]
    fn serialize<W: Write>(&self, writer: &mut W) -> Result<()> {
        check_zst::<T>()?;

        writer.write_all(
            &(u32::try_from(self.len()).map_err(|_| ErrorKind::InvalidData)?).to_le_bytes(),
        )?;
        let slices = self.as_slices();
        serialize_slice(slices.0, writer)?;
        serialize_slice(slices.1, writer)
    }
}

impl<T> BorshSerialize for LinkedList<T>
where
    T: BorshSerialize,
{
    #[inline]
    fn serialize<W: Write>(&self, writer: &mut W) -> Result<()> {
        check_zst::<T>()?;

        writer.write_all(
            &(u32::try_from(self.len()).map_err(|_| ErrorKind::InvalidData)?).to_le_bytes(),
        )?;
        for item in self {
            item.serialize(writer)?;
        }
        Ok(())
    }
}

/// Module is available if borsh is built with `features = ["std"]` or `features = ["hashbrown"]`.
#[cfg(hash_collections)]
pub mod hashes {
    //!
    //! Module defines [BorshSerialize] implementation for
    //! [HashMap](std::collections::HashMap)/[HashSet](std::collections::HashSet).
    use crate::__private::maybestd::vec::Vec;
    use crate::error::check_zst;
    use crate::{
        BorshSerialize,
        __private::maybestd::collections::{HashMap, HashSet},
    };
    use core::convert::TryFrom;
    use core::hash::BuildHasher;

    use crate::io::{ErrorKind, Result, Write};

    impl<K, V, H> BorshSerialize for HashMap<K, V, H>
    where
        K: BorshSerialize + Ord,
        V: BorshSerialize,
        H: BuildHasher,
    {
        #[inline]
        fn serialize<W: Write>(&self, writer: &mut W) -> Result<()> {
            check_zst::<K>()?;

            let mut vec = self.iter().collect::<Vec<_>>();
            vec.sort_by(|(a, _), (b, _)| a.cmp(b));
            u32::try_from(vec.len())
                .map_err(|_| ErrorKind::InvalidData)?
                .serialize(writer)?;
            for (key, value) in vec {
                key.serialize(writer)?;
                value.serialize(writer)?;
            }
            Ok(())
        }
    }

    impl<T, H> BorshSerialize for HashSet<T, H>
    where
        T: BorshSerialize + Ord,
        H: BuildHasher,
    {
        #[inline]
        fn serialize<W: Write>(&self, writer: &mut W) -> Result<()> {
            check_zst::<T>()?;

            let mut vec = self.iter().collect::<Vec<_>>();
            vec.sort();
            u32::try_from(vec.len())
                .map_err(|_| ErrorKind::InvalidData)?
                .serialize(writer)?;
            for item in vec {
                item.serialize(writer)?;
            }
            Ok(())
        }
    }
}

impl<K, V> BorshSerialize for BTreeMap<K, V>
where
    K: BorshSerialize,
    V: BorshSerialize,
{
    #[inline]
    fn serialize<W: Write>(&self, writer: &mut W) -> Result<()> {
        check_zst::<K>()?;
        // NOTE: BTreeMap iterates over the entries that are sorted by key, so the serialization
        // result will be consistent without a need to sort the entries as we do for HashMap
        // serialization.
        u32::try_from(self.len())
            .map_err(|_| ErrorKind::InvalidData)?
            .serialize(writer)?;
        for (key, value) in self {
            key.serialize(writer)?;
            value.serialize(writer)?;
        }
        Ok(())
    }
}

impl<T> BorshSerialize for BTreeSet<T>
where
    T: BorshSerialize,
{
    #[inline]
    fn serialize<W: Write>(&self, writer: &mut W) -> Result<()> {
        check_zst::<T>()?;
        // NOTE: BTreeSet iterates over the items that are sorted, so the serialization result will
        // be consistent without a need to sort the entries as we do for HashSet serialization.
        u32::try_from(self.len())
            .map_err(|_| ErrorKind::InvalidData)?
            .serialize(writer)?;
        for item in self {
            item.serialize(writer)?;
        }
        Ok(())
    }
}

#[cfg(feature = "std")]
impl BorshSerialize for std::net::SocketAddr {
    #[inline]
    fn serialize<W: Write>(&self, writer: &mut W) -> Result<()> {
        match *self {
            std::net::SocketAddr::V4(ref addr) => {
                0u8.serialize(writer)?;
                addr.serialize(writer)
            }
            std::net::SocketAddr::V6(ref addr) => {
                1u8.serialize(writer)?;
                addr.serialize(writer)
            }
        }
    }
}

#[cfg(feature = "std")]
impl BorshSerialize for std::net::SocketAddrV4 {
    #[inline]
    fn serialize<W: Write>(&self, writer: &mut W) -> Result<()> {
        self.ip().serialize(writer)?;
        self.port().serialize(writer)
    }
}

#[cfg(feature = "std")]
impl BorshSerialize for std::net::SocketAddrV6 {
    #[inline]
    fn serialize<W: Write>(&self, writer: &mut W) -> Result<()> {
        self.ip().serialize(writer)?;
        self.port().serialize(writer)
    }
}

#[cfg(feature = "std")]
impl BorshSerialize for std::net::Ipv4Addr {
    #[inline]
    fn serialize<W: Write>(&self, writer: &mut W) -> Result<()> {
        writer.write_all(&self.octets())
    }
}

#[cfg(feature = "std")]
impl BorshSerialize for std::net::Ipv6Addr {
    #[inline]
    fn serialize<W: Write>(&self, writer: &mut W) -> Result<()> {
        writer.write_all(&self.octets())
    }
}

impl<T: BorshSerialize + ?Sized> BorshSerialize for Box<T> {
    fn serialize<W: Write>(&self, writer: &mut W) -> Result<()> {
        self.as_ref().serialize(writer)
    }
}

impl<T, const N: usize> BorshSerialize for [T; N]
where
    T: BorshSerialize,
{
    #[inline]
    fn serialize<W: Write>(&self, writer: &mut W) -> Result<()> {
        if N == 0 {
            return Ok(());
        } else if let Some(u8_slice) = T::u8_slice(self) {
            writer.write_all(u8_slice)?;
        } else {
            for el in self.iter() {
                el.serialize(writer)?;
            }
        }
        Ok(())
    }
}

macro_rules! impl_tuple {
    (@unit $name:ty) => {
        impl BorshSerialize for $name {
            #[inline]
            fn serialize<W: Write>(&self, _writer: &mut W) -> Result<()> {
                Ok(())
            }
        }
    };

    ($($idx:tt $name:ident)+) => {
      impl<$($name),+> BorshSerialize for ($($name,)+)
      where $($name: BorshSerialize,)+
      {
        #[inline]
        fn serialize<W: Write>(&self, writer: &mut W) -> Result<()> {
            $(self.$idx.serialize(writer)?;)+
            Ok(())
        }
      }
    };
}

impl_tuple!(@unit ());
impl_tuple!(@unit core::ops::RangeFull);

impl_tuple!(0 T0);
impl_tuple!(0 T0 1 T1);
impl_tuple!(0 T0 1 T1 2 T2);
impl_tuple!(0 T0 1 T1 2 T2 3 T3);
impl_tuple!(0 T0 1 T1 2 T2 3 T3 4 T4);
impl_tuple!(0 T0 1 T1 2 T2 3 T3 4 T4 5 T5);
impl_tuple!(0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6);
impl_tuple!(0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7);
impl_tuple!(0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7 8 T8);
impl_tuple!(0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7 8 T8 9 T9);
impl_tuple!(0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7 8 T8 9 T9 10 T10);
impl_tuple!(0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7 8 T8 9 T9 10 T10 11 T11);
impl_tuple!(0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7 8 T8 9 T9 10 T10 11 T11 12 T12);
impl_tuple!(0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7 8 T8 9 T9 10 T10 11 T11 12 T12 13 T13);
impl_tuple!(0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7 8 T8 9 T9 10 T10 11 T11 12 T12 13 T13 14 T14);
impl_tuple!(0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7 8 T8 9 T9 10 T10 11 T11 12 T12 13 T13 14 T14 15 T15);
impl_tuple!(0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7 8 T8 9 T9 10 T10 11 T11 12 T12 13 T13 14 T14 15 T15 16 T16);
impl_tuple!(0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7 8 T8 9 T9 10 T10 11 T11 12 T12 13 T13 14 T14 15 T15 16 T16 17 T17);
impl_tuple!(0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7 8 T8 9 T9 10 T10 11 T11 12 T12 13 T13 14 T14 15 T15 16 T16 17 T17 18 T18);
impl_tuple!(0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7 8 T8 9 T9 10 T10 11 T11 12 T12 13 T13 14 T14 15 T15 16 T16 17 T17 18 T18 19 T19);

macro_rules! impl_range {
    ($type:ident, $this:ident, $($field:expr),*) => {
        impl<T: BorshSerialize> BorshSerialize for core::ops::$type<T> {
            #[inline]
            fn serialize<W: Write>(&self, writer: &mut W) -> Result<()> {
                let $this = self;
                $( $field.serialize(writer)?; )*
                Ok(())
            }
        }
    };
}

impl_range!(Range, this, &this.start, &this.end);
impl_range!(RangeInclusive, this, this.start(), this.end());
impl_range!(RangeFrom, this, &this.start);
impl_range!(RangeTo, this, &this.end);
impl_range!(RangeToInclusive, this, &this.end);

/// Module is available if borsh is built with `features = ["rc"]`.
#[cfg(feature = "rc")]
pub mod rc {
    //!
    //! Module defines [BorshSerialize] implementation for
    //! [alloc::rc::Rc](std::rc::Rc) and [alloc::sync::Arc](std::sync::Arc).
    use crate::__private::maybestd::{rc::Rc, sync::Arc};
    use crate::io::{Result, Write};
    use crate::BorshSerialize;

    /// This impl requires the [`"rc"`] Cargo feature of borsh.
    ///
    /// Serializing a data structure containing `Rc` will serialize a copy of
    /// the contents of the `Rc` each time the `Rc` is referenced within the
    /// data structure. Serialization will not attempt to deduplicate these
    /// repeated data.
    impl<T: BorshSerialize + ?Sized> BorshSerialize for Rc<T> {
        fn serialize<W: Write>(&self, writer: &mut W) -> Result<()> {
            (**self).serialize(writer)
        }
    }

    /// This impl requires the [`"rc"`] Cargo feature of borsh.
    ///
    /// Serializing a data structure containing `Arc` will serialize a copy of
    /// the contents of the `Arc` each time the `Arc` is referenced within the
    /// data structure. Serialization will not attempt to deduplicate these
    /// repeated data.
    impl<T: BorshSerialize + ?Sized> BorshSerialize for Arc<T> {
        fn serialize<W: Write>(&self, writer: &mut W) -> Result<()> {
            (**self).serialize(writer)
        }
    }
}

impl<T: ?Sized> BorshSerialize for PhantomData<T> {
    fn serialize<W: Write>(&self, _: &mut W) -> Result<()> {
        Ok(())
    }
}

impl<T> BorshSerialize for core::cell::Cell<T>
where
    T: BorshSerialize + Copy,
{
    fn serialize<W: Write>(&self, writer: &mut W) -> Result<()> {
        <T as BorshSerialize>::serialize(&self.get(), writer)
    }
}

impl<T> BorshSerialize for core::cell::RefCell<T>
where
    T: BorshSerialize + Sized,
{
    fn serialize<W: Write>(&self, writer: &mut W) -> Result<()> {
        match self.try_borrow() {
            Ok(ref value) => value.serialize(writer),
            Err(_) => Err(Error::new(ErrorKind::Other, "already mutably borrowed")),
        }
    }
}

'''
'''--- borsh/tests/common_macro.rs ---
#[allow(unused)]
macro_rules! set_insert_deser_assert_macro [

    [$set: ident, $data: ident, $($key: expr),*] => [
        $($set.insert($key));*
        ;

        let $data = borsh::to_vec(&$set).unwrap();
        #[cfg(feature = "std")]
        insta::assert_debug_snapshot!($data);
    ]
];

#[allow(unused)]
macro_rules! map_insert_deser_assert_macro [

    [$map: ident, $data: ident, $($key: expr => $value: expr),*] => [
        $($map.insert($key, $value));*
        ;

        let $data = borsh::to_vec(&$map).unwrap();
        #[cfg(feature = "std")]
        insta::assert_debug_snapshot!($data);
    ]
];

#[allow(unused)]
macro_rules! set_wrong_order_test [

    [$test_name: ident, $set_type: ty] => [

        #[test]
        fn $test_name() {
            let mut data = vec![];
            let arr_key = ["various".to_string(), "foo".to_string(), "many".to_string()];
            let len = arr_key.len() as u32;
            u32::serialize(&len, &mut data).expect("no error");

            for key in &arr_key {
                key.serialize(&mut data).expect("no error");
            }

            let result = from_slice::<$set_type>(&data);

            #[cfg(not(feature = "de_strict_order"))]
            {
                let result = result.unwrap();
                assert_eq!(result.len(), arr_key.len());
                for key in &arr_key {
                    assert!(result.contains(key));

                }

            }

            #[cfg(feature = "de_strict_order")]
            {
                assert!(result.is_err());

                assert_eq!(result.unwrap_err().to_string(), ERROR_WRONG_ORDER_OF_KEYS);
            }
        }
    ]
];

#[allow(unused)]
macro_rules! map_wrong_order_test [

    [$test_name: ident, $map_type: ty] => [

        #[test]
        fn $test_name() {
            let mut data = vec![];
            let arr_key = ["various".to_string(), "foo".to_string(), "many".to_string()];
            let arr_val = [
                "value".to_string(),
                "different".to_string(),
                "unexp".to_string(),
            ];
            let len = arr_key.len() as u32;
            u32::serialize(&len, &mut data).expect("no error");

            let entries = IntoIterator::into_iter(arr_key.clone())
                .zip(IntoIterator::into_iter(arr_val))
                .collect::<Vec<_>>();

            for (key, value) in entries.clone() {
                key.serialize(&mut data).expect("no error");
                value.serialize(&mut data).expect("no error");
            }

            let result = from_slice::<$map_type>(&data);

            #[cfg(not(feature = "de_strict_order"))]
            {
                let result = result.unwrap();
                assert_eq!(result.len(), arr_key.len());
                for (key, value) in entries {
                    assert_eq!(result.get(&key), Some(&value));
                }
            }

            #[cfg(feature = "de_strict_order")]
            {
                assert!(result.is_err());

                assert_eq!(result.unwrap_err().to_string(), ERROR_WRONG_ORDER_OF_KEYS);
            }
        }
    ]
];

#[allow(unused)]
macro_rules! schema_map(
    () => { BTreeMap::new() };
    { $($key:expr => $value:expr),+ } => {
        {
            let mut m = BTreeMap::new();
            $(
                m.insert($key.to_string(), $value);
            )+
            m
        }
     };
);

#[allow(unused)]
#[cfg(feature = "unstable__schema")]
pub mod schema_imports {
    extern crate alloc;
    pub use alloc::{
        boxed::Box,
        collections::BTreeMap,
        format,
        string::{String, ToString},
        vec,
        vec::Vec,
    };

    pub use borsh::schema::{
        add_definition, BorshSchemaContainer, Declaration, Definition, Fields,
        SchemaContainerValidateError, SchemaMaxSerializedSizeError,
    };
    pub use borsh::{schema_container_of, BorshSchema};
}

'''
'''--- borsh/tests/compile_derives/schema/test_generic_enums.rs ---
#![allow(unused)]
use crate::common_macro::schema_imports::*;

use core::fmt::{Debug, Display};

/// test: Sausage wasn't populated with param Sausage<W>
#[derive(borsh::BorshSchema, Debug)]
enum AWithSkip<C, W> {
    Bacon,
    Eggs,
    Salad(u32, C, u32),
    Sausage {
        #[borsh(skip)]
        wrapper: W,
        filling: u32,
    },
}

/// test: inner structs in BorshSchema derive don't need any bounds, unrelated to BorshSchema
// #[derive(borsh::BorshSchema)]
// struct SideLeft<A>(
//     A,
// )
// where
//     A: Display + Debug,
//     B: Display + Debug;
#[derive(borsh::BorshSchema)]
enum Side<A, B>
where
    A: Display + Debug,
    B: Display + Debug,
{
    Left(A),
    Right(B),
}

'''
'''--- borsh/tests/compile_derives/test_generic_enums.rs ---
use borsh::{BorshDeserialize, BorshSerialize};

#[allow(unused)]
use alloc::{string::String, vec::Vec};

#[cfg(feature = "hashbrown")]
use hashbrown::HashMap;

#[cfg(hash_collections)]
use core::{cmp::Eq, hash::Hash};

#[cfg(feature = "std")]
use std::collections::HashMap;

use alloc::collections::BTreeMap;

/// `T: Ord` bound is required for `BorshDeserialize` derive to be successful
#[derive(BorshSerialize, BorshDeserialize, PartialEq, Debug)]
enum E<T: Ord, U, W> {
    X { f: BTreeMap<T, U> },
    Y(W),
}

#[cfg(hash_collections)]
#[derive(BorshSerialize, BorshDeserialize, Debug)]
enum I1<K, V, R> {
    B {
        #[allow(unused)]
        #[borsh(skip)]
        x: HashMap<K, V>,
        y: String,
    },
    C(K, Vec<R>),
}

#[cfg(hash_collections)]
#[derive(BorshSerialize, BorshDeserialize, Debug)]
enum I2<K: Ord + Eq + Hash, R, U> {
    B { x: HashMap<K, R>, y: String },
    C(K, #[borsh(skip)] U),
}

'''
'''--- borsh/tests/compile_derives/test_generic_structs.rs ---
#[cfg(feature = "hashbrown")]
use hashbrown::HashMap;

#[cfg(hash_collections)]
use core::{cmp::Eq, hash::Hash};

#[cfg(feature = "std")]
use std::collections::HashMap;

use alloc::{
    collections::BTreeMap,
    string::String,
};

use borsh::{BorshDeserialize, BorshSerialize};

#[derive(BorshSerialize, BorshDeserialize, Debug)]
struct TupleA<W>(W, u32);

#[derive(BorshSerialize, BorshDeserialize, Debug)]
struct NamedA<W> {
    a: W,
    b: u32,
}

/// `T: PartialOrd` is injected here via field bound to avoid having this restriction on
/// the struct itself
#[cfg(hash_collections)]
#[derive(BorshSerialize)]
struct C1<T, U> {
    a: String,
    #[borsh(bound(serialize = "T: borsh::ser::BorshSerialize + Ord,
         U: borsh::ser::BorshSerialize"))]
    b: HashMap<T, U>,
}

/// `T: PartialOrd + Hash + Eq` is injected here via field bound to avoid having this restriction on
/// the struct itself
#[allow(unused)]
#[cfg(hash_collections)]
#[derive(BorshDeserialize)]
struct C2<T, U> {
    a: String,
    #[borsh(bound(deserialize = "T: Ord + Hash + Eq + borsh::de::BorshDeserialize,
         U: borsh::de::BorshDeserialize"))]
    b: HashMap<T, U>,
}

/// `T: Ord` bound is required for `BorshDeserialize` derive to be successful
#[derive(BorshSerialize, BorshDeserialize)]
struct D<T: Ord, R> {
    a: String,
    b: BTreeMap<T, R>,
}

#[cfg(hash_collections)]
#[derive(BorshSerialize)]
struct G<K, V, U>(#[borsh(skip)] HashMap<K, V>, U);

#[cfg(hash_collections)]
#[derive(BorshDeserialize)]
struct G1<K, V, U>(#[borsh(skip)] HashMap<K, V>, U);

#[cfg(hash_collections)]
#[derive(BorshDeserialize)]
struct G2<K: Ord + Hash + Eq, R, U>(HashMap<K, R>, #[borsh(skip)] U);

/// implicit derived `core::default::Default` bounds on `K` and `V` are dropped by empty bound
/// specified, as `HashMap` hash its own `Default` implementation
#[cfg(hash_collections)]
#[derive(BorshDeserialize)]
struct G3<K, V, U>(#[borsh(skip, bound(deserialize = ""))] HashMap<K, V>, U);

#[cfg(hash_collections)]
#[derive(BorshSerialize, BorshDeserialize)]
struct H<K: Ord, V, U> {
    x: BTreeMap<K, V>,
    #[allow(unused)]
    #[borsh(skip)]
    y: U,
}

trait TraitName {
    type Associated;
    fn method(&self);
}

#[allow(unused)]
#[derive(BorshSerialize)]
struct ParametrizedWrongDerive<T, V>
where
    T: TraitName,
{
    #[borsh(bound(serialize = "<T as TraitName>::Associated: borsh::ser::BorshSerialize"))]
    field: <T as TraitName>::Associated,
    another: V,
}

'''
'''--- borsh/tests/compile_derives/test_macro_namespace_collisions.rs ---
// Borsh macros should not collide with the local modules:
// https://github.com/near/borsh-rs/issues/11
mod std {}
mod core {}

#[derive(borsh::BorshSerialize, borsh::BorshDeserialize)]
struct A;

#[derive(borsh::BorshSerialize, borsh::BorshDeserialize)]
enum B {
    C,
    D,
}

'''
'''--- borsh/tests/compile_derives/test_recursive_structs.rs ---
use borsh::{BorshDeserialize, BorshSerialize};

#[cfg(feature = "hashbrown")]
use hashbrown::HashMap;

#[cfg(feature = "std")]
use std::collections::HashMap;

#[cfg(hash_collections)]
use core::{cmp::Eq, hash::Hash};
use alloc::{boxed::Box, string::String};

#[cfg(hash_collections)]
#[derive(BorshSerialize, BorshDeserialize)]
struct CRec<U: Ord + Hash + Eq> {
    a: String,
    b: HashMap<U, CRec<U>>,
}

//  `impl<T, U> BorshDeserialize for Box<T>` pulls in => `ToOwned`
// => pulls in at least `Clone`
#[derive(Clone, BorshSerialize, BorshDeserialize)]
struct CRecA {
    a: String,
    b: Box<CRecA>,
}

#[cfg(hash_collections)]
#[derive(BorshSerialize, BorshDeserialize)]
struct CRecC {
    a: String,
    b: HashMap<String, CRecC>,
}

'''
'''--- borsh/tests/custom_reader/test_custom_reader.rs ---
use borsh::{from_reader, to_vec, BorshDeserialize, BorshSerialize};

use alloc::{
    string::{String, ToString},
    vec::Vec,
};

const ERROR_NOT_ALL_BYTES_READ: &str = "Not all bytes read";
const ERROR_UNEXPECTED_LENGTH_OF_INPUT: &str = "Unexpected length of input";

#[derive(BorshSerialize, BorshDeserialize, Debug)]
struct Serializable {
    item1: i32,
    item2: String,
    item3: f64,
}

#[test]
fn test_custom_reader() {
    let s = Serializable {
        item1: 100,
        item2: "foo".into(),
        item3: 1.2345,
    };
    let bytes = to_vec(&s).unwrap();
    let mut reader = CustomReader {
        data: bytes,
        read_index: 0,
    };
    let de: Serializable = BorshDeserialize::deserialize_reader(&mut reader).unwrap();
    assert_eq!(de.item1, s.item1);
    assert_eq!(de.item2, s.item2);
    assert_eq!(de.item3, s.item3);
}

#[test]
fn test_custom_reader_with_insufficient_data() {
    let s = Serializable {
        item1: 100,
        item2: "foo".into(),
        item3: 1.2345,
    };
    let mut bytes = to_vec(&s).unwrap();
    bytes.pop().unwrap();
    let mut reader = CustomReader {
        data: bytes,
        read_index: 0,
    };
    assert_eq!(
        <Serializable as BorshDeserialize>::deserialize_reader(&mut reader)
            .unwrap_err()
            .to_string(),
        ERROR_UNEXPECTED_LENGTH_OF_INPUT
    );
}

#[test]
fn test_custom_reader_with_too_much_data() {
    let s = Serializable {
        item1: 100,
        item2: "foo".into(),
        item3: 1.2345,
    };
    let mut bytes = to_vec(&s).unwrap();
    bytes.push(1);
    let mut reader = CustomReader {
        data: bytes,
        read_index: 0,
    };
    assert_eq!(
        from_reader::<CustomReader, Serializable>(&mut reader)
            .unwrap_err()
            .to_string(),
        ERROR_NOT_ALL_BYTES_READ
    );
}

struct CustomReader {
    data: Vec<u8>,
    read_index: usize,
}

impl borsh::io::Read for CustomReader {
    fn read(&mut self, buf: &mut [u8]) -> borsh::io::Result<usize> {
        let len = buf.len().min(self.data.len() - self.read_index);
        buf[0..len].copy_from_slice(&self.data[self.read_index..self.read_index + len]);
        self.read_index += len;
        Ok(len)
    }
}

#[test]
fn test_custom_reader_that_doesnt_fill_slices() {
    let s = Serializable {
        item1: 100,
        item2: "foo".into(),
        item3: 1.2345,
    };
    let bytes = to_vec(&s).unwrap();
    let mut reader = CustomReaderThatDoesntFillSlices {
        data: bytes,
        read_index: 0,
    };
    let de: Serializable = BorshDeserialize::deserialize_reader(&mut reader).unwrap();
    assert_eq!(de.item1, s.item1);
    assert_eq!(de.item2, s.item2);
    assert_eq!(de.item3, s.item3);
}

struct CustomReaderThatDoesntFillSlices {
    data: Vec<u8>,
    read_index: usize,
}

impl borsh::io::Read for CustomReaderThatDoesntFillSlices {
    fn read(&mut self, buf: &mut [u8]) -> borsh::io::Result<usize> {
        let len = buf.len().min(self.data.len() - self.read_index);
        let len = if len <= 1 { len } else { len / 2 };
        buf[0..len].copy_from_slice(&self.data[self.read_index..self.read_index + len]);
        self.read_index += len;
        Ok(len)
    }
}

#[test]
fn test_custom_reader_that_fails_preserves_error_information() {
    let mut reader = CustomReaderThatFails;

    let err = from_reader::<CustomReaderThatFails, Serializable>(&mut reader).unwrap_err();
    assert_eq!(err.to_string(), "I don't like to run");
    assert_eq!(err.kind(), borsh::io::ErrorKind::ConnectionAborted);
}

struct CustomReaderThatFails;

impl borsh::io::Read for CustomReaderThatFails {
    fn read(&mut self, _buf: &mut [u8]) -> borsh::io::Result<usize> {
        Err(borsh::io::Error::new(
            borsh::io::ErrorKind::ConnectionAborted,
            "I don't like to run",
        ))
    }
}

'''
'''--- borsh/tests/deserialization_errors/test_ascii_strings.rs ---
use alloc::string::ToString;
use borsh::from_slice;

#[test]
fn test_non_ascii() {
    let buf = borsh::to_vec(&[0xbf, 0xf3, 0xb3, 0x77][..]).unwrap();
    assert_eq!(
        from_slice::<ascii::AsciiString>(&buf)
            .unwrap_err()
            .to_string(),
        "the byte at index 0 is not ASCII"
    );

    let buf = borsh::to_vec("żółw").unwrap();
    assert_eq!(
        from_slice::<ascii::AsciiString>(&buf)
            .unwrap_err()
            .to_string(),
        "the byte at index 0 is not ASCII"
    );

    assert_eq!(
        from_slice::<ascii::AsciiChar>(&[0xbf])
            .unwrap_err()
            .to_string(),
        "not an ASCII character"
    );
}

'''
'''--- borsh/tests/deserialization_errors/test_cells.rs ---
use alloc::string::ToString;

#[test]
fn test_ref_cell_try_borrow_error() {
    let rcell = core::cell::RefCell::new("str");

    let _active_borrow = rcell.try_borrow_mut().unwrap();

    assert_eq!(
        borsh::to_vec(&rcell).unwrap_err().to_string(),
        "already mutably borrowed"
    );
}

'''
'''--- borsh/tests/deserialization_errors/test_initial.rs ---
use borsh::from_slice;

#[cfg(feature = "derive")]
use borsh::BorshDeserialize;

use alloc::{
    format,
    string::{String, ToString},
    vec,
    vec::Vec,
};

#[cfg(feature = "derive")]
#[derive(BorshDeserialize, Debug)]
#[borsh(use_discriminant = true)]
enum A {
    X,
    Y,
}

#[cfg(feature = "derive")]
#[derive(BorshDeserialize, Debug)]
#[borsh(use_discriminant = false)]
enum AWithUseDiscriminantFalse {
    X,
    Y,
}

#[cfg(feature = "derive")]
#[derive(BorshDeserialize, Debug)]
struct B {
    #[allow(unused)]
    x: u64,
    #[allow(unused)]
    y: u32,
}

const ERROR_UNEXPECTED_LENGTH_OF_INPUT: &str = "Unexpected length of input";
const ERROR_INVALID_ZERO_VALUE: &str = "Expected a non-zero value";

#[cfg(feature = "derive")]
#[test]
fn test_missing_bytes() {
    let bytes = vec![1, 0];
    assert_eq!(
        from_slice::<B>(&bytes).unwrap_err().to_string(),
        ERROR_UNEXPECTED_LENGTH_OF_INPUT
    );
}

#[cfg(feature = "derive")]
#[test]
fn test_invalid_enum_variant() {
    let bytes = vec![123];
    assert_eq!(
        from_slice::<A>(&bytes).unwrap_err().to_string(),
        "Unexpected variant tag: 123"
    );
}

#[cfg(feature = "derive")]
#[test]
fn test_invalid_enum_variant_old() {
    let bytes = vec![123];
    assert_eq!(
        from_slice::<AWithUseDiscriminantFalse>(&bytes)
            .unwrap_err()
            .to_string(),
        "Unexpected variant tag: 123"
    );
}

#[test]
fn test_extra_bytes() {
    let bytes = vec![1, 0, 0, 0, 32, 32];
    assert_eq!(
        from_slice::<Vec<u8>>(&bytes).unwrap_err().to_string(),
        "Not all bytes read"
    );
}

#[test]
fn test_invalid_bool() {
    for i in 2u8..=255 {
        let bytes = [i];
        assert_eq!(
            from_slice::<bool>(&bytes).unwrap_err().to_string(),
            format!("Invalid bool representation: {}", i)
        );
    }
}

#[test]
fn test_invalid_option() {
    for i in 2u8..=255 {
        let bytes = [i, 32];
        assert_eq!(
            from_slice::<Option<u8>>(&bytes).unwrap_err().to_string(),
            format!(
                "Invalid Option representation: {}. The first byte must be 0 or 1",
                i
            )
        );
    }
}

#[test]
fn test_invalid_result() {
    for i in 2u8..=255 {
        let bytes = [i, 0];
        assert_eq!(
            from_slice::<Result<u64, String>>(&bytes)
                .unwrap_err()
                .to_string(),
            format!(
                "Invalid Result representation: {}. The first byte must be 0 or 1",
                i
            )
        );
    }
}

#[test]
fn test_invalid_length() {
    let bytes = vec![255u8; 4];
    assert_eq!(
        from_slice::<Vec<u64>>(&bytes).unwrap_err().to_string(),
        ERROR_UNEXPECTED_LENGTH_OF_INPUT
    );
}

#[test]
fn test_invalid_length_string() {
    let bytes = vec![255u8; 4];
    assert_eq!(
        from_slice::<String>(&bytes).unwrap_err().to_string(),
        ERROR_UNEXPECTED_LENGTH_OF_INPUT
    );
}

#[test]
fn test_non_utf_string() {
    let bytes = vec![1, 0, 0, 0, 0xC0];
    assert_eq!(
        from_slice::<String>(&bytes).unwrap_err().to_string(),
        "invalid utf-8 sequence of 1 bytes from index 0"
    );
}

#[test]
fn test_nan_float() {
    let bytes = vec![0, 0, 192, 127];
    assert_eq!(
        from_slice::<f32>(&bytes).unwrap_err().to_string(),
        "For portability reasons we do not allow to deserialize NaNs."
    );
}

#[test]
fn test_evil_bytes_vec_with_extra() {
    // Should fail to allocate given length
    // test takes a really long time if read() is used instead of read_exact()
    let bytes = vec![255, 255, 255, 255, 32, 32];
    assert_eq!(
        from_slice::<Vec<[u8; 32]>>(&bytes).unwrap_err().to_string(),
        ERROR_UNEXPECTED_LENGTH_OF_INPUT
    );
}

#[test]
fn test_evil_bytes_string_extra() {
    // Might fail if reading too much
    let bytes = vec![255, 255, 255, 255, 32, 32];
    assert_eq!(
        from_slice::<String>(&bytes).unwrap_err().to_string(),
        ERROR_UNEXPECTED_LENGTH_OF_INPUT
    );
}

#[test]
fn test_zero_on_nonzero_integer_u8() {
    let bytes = &[0];
    assert_eq!(
        from_slice::<core::num::NonZeroU8>(bytes)
            .unwrap_err()
            .to_string(),
        ERROR_INVALID_ZERO_VALUE
    );
}

#[test]
fn test_zero_on_nonzero_integer_u32() {
    let bytes = &[0; 4];
    assert_eq!(
        from_slice::<core::num::NonZeroU32>(bytes)
            .unwrap_err()
            .to_string(),
        ERROR_INVALID_ZERO_VALUE
    );
}

#[test]
fn test_zero_on_nonzero_integer_i64() {
    let bytes = &[0; 8];
    assert_eq!(
        from_slice::<core::num::NonZeroI64>(bytes)
            .unwrap_err()
            .to_string(),
        ERROR_INVALID_ZERO_VALUE
    );
}

#[test]
fn test_zero_on_nonzero_integer_usize() {
    let bytes = &[0; 8];
    assert_eq!(
        from_slice::<core::num::NonZeroUsize>(bytes)
            .unwrap_err()
            .to_string(),
        ERROR_INVALID_ZERO_VALUE
    );
}

#[test]
fn test_zero_on_nonzero_integer_missing_byte() {
    let bytes = &[0; 7];
    assert_eq!(
        from_slice::<core::num::NonZeroUsize>(bytes)
            .unwrap_err()
            .to_string(),
        ERROR_UNEXPECTED_LENGTH_OF_INPUT
    );
}

'''
'''--- borsh/tests/init_in_deserialize/test_init_in_deserialize.rs ---
use borsh::{from_slice, to_vec, BorshDeserialize, BorshSerialize};
#[derive(BorshSerialize, BorshDeserialize, PartialEq, Debug)]
#[borsh(init=init)]
struct A {
    lazy: Option<u64>,
}

impl A {
    pub fn init(&mut self) {
        if let Some(v) = self.lazy.as_mut() {
            *v *= 10;
        }
    }
}
#[test]
fn test_simple_struct() {
    let a = A { lazy: Some(5) };

    let encoded_a = to_vec(&a).unwrap();

    #[cfg(feature = "std")]
    insta::assert_debug_snapshot!(encoded_a);

    let decoded_a = from_slice::<A>(&encoded_a).unwrap();
    let expected_a = A { lazy: Some(50) };
    assert_eq!(expected_a, decoded_a);
}

#[derive(BorshSerialize, BorshDeserialize, PartialEq, Debug)]
#[borsh(init=initialization_method)]
enum AEnum {
    A,
    B,
    C,
}

impl AEnum {
    pub fn initialization_method(&mut self) {
        *self = AEnum::C;
    }
}

#[test]
fn test_simple_enum() {
    let a = AEnum::B;
    let encoded_a = to_vec(&a).unwrap();

    #[cfg(feature = "std")]
    insta::assert_debug_snapshot!(encoded_a);

    let decoded_a = from_slice::<AEnum>(&encoded_a).unwrap();
    assert_eq!(AEnum::C, decoded_a);
}

'''
'''--- borsh/tests/roundtrip/requires_derive_category/test_bson_object_ids.rs ---
#![allow(clippy::float_cmp)]

use borsh::{from_slice, to_vec, BorshDeserialize, BorshSerialize};
use bson::oid::ObjectId;

#[derive(BorshDeserialize, BorshSerialize, PartialEq, Debug)]
struct StructWithObjectId(i32, ObjectId, u8);

#[test]
fn test_object_id() {
    let obj = StructWithObjectId(
        123,
        ObjectId::from_bytes([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]),
        33,
    );
    let serialized = to_vec(&obj).unwrap();
    #[cfg(feature = "std")]
    insta::assert_debug_snapshot!(serialized);
    let deserialized: StructWithObjectId = from_slice(&serialized).unwrap();
    assert_eq!(obj, deserialized);
}

'''
'''--- borsh/tests/roundtrip/requires_derive_category/test_enum_discriminants.rs ---
use alloc::vec;

use borsh::{from_slice, to_vec, BorshDeserialize, BorshSerialize};

// sequence, no unit enums
#[derive(BorshSerialize, BorshDeserialize, PartialEq, Eq, Clone, Copy, Debug)]
#[borsh(use_discriminant = true)]
#[repr(u16)]
enum XY {
    A,
    B = 20,
    C,
    D(u32, u32),
    E = 10,
    F(u64),
}

#[derive(BorshSerialize, BorshDeserialize, PartialEq, Eq, Clone, Copy, Debug)]
#[borsh(use_discriminant = false)]
#[repr(u16)]
enum XYNoDiscriminant {
    A,
    B = 20,
    C,
    D(u32, u32),
    E = 10,
    F(u64),
}

#[test]
fn test_discriminant_serde_no_unit_type() {
    let values = vec![XY::A, XY::B, XY::C, XY::E, XY::D(12, 14), XY::F(35325423)];
    let expected_discriminants = [0u8, 20, 21, 10, 22, 11];

    for (ind, value) in values.iter().enumerate() {
        let data = to_vec(value).unwrap();
        assert_eq!(data[0], expected_discriminants[ind]);
        assert_eq!(from_slice::<XY>(&data).unwrap(), values[ind]);
    }
}

#[test]
fn test_discriminant_serde_no_unit_type_no_use_discriminant() {
    let values = vec![
        XYNoDiscriminant::A,
        XYNoDiscriminant::B,
        XYNoDiscriminant::C,
        XYNoDiscriminant::D(12, 14),
        XYNoDiscriminant::E,
        XYNoDiscriminant::F(35325423),
    ];
    let expected_discriminants = [0u8, 1, 2, 3, 4, 5];

    for (ind, value) in values.iter().enumerate() {
        let data = to_vec(value).unwrap();
        assert_eq!(data[0], expected_discriminants[ind]);
        assert_eq!(from_slice::<XYNoDiscriminant>(&data).unwrap(), values[ind]);
    }
}

// minimal
#[derive(BorshSerialize)]
#[borsh(use_discriminant = true)]
enum MyDiscriminantEnum {
    A = 20,
}

#[derive(BorshSerialize)]
#[borsh(use_discriminant = false)]
enum MyDiscriminantEnumFalse {
    A = 20,
}

#[derive(BorshSerialize)]
enum MyEnumNoDiscriminant {
    A,
}
#[test]
fn test_discriminant_minimal_true() {
    assert_eq!(MyDiscriminantEnum::A as u8, 20);
    assert_eq!(to_vec(&MyDiscriminantEnum::A).unwrap(), vec![20]);
}

#[test]
fn test_discriminant_minimal_false() {
    assert_eq!(MyDiscriminantEnumFalse::A as u8, 20);
    assert_eq!(
        to_vec(&MyEnumNoDiscriminant::A).unwrap(),
        to_vec(&MyDiscriminantEnumFalse::A).unwrap(),
    );
    assert_eq!(to_vec(&MyDiscriminantEnumFalse::A).unwrap(), vec![0]);
}

// sequence
#[derive(BorshSerialize, BorshDeserialize, PartialEq, Eq, Clone, Copy, Debug)]
#[borsh(use_discriminant = false)]
enum XNoDiscriminant {
    A,
    B = 20,
    C,
    D,
    E = 10,
    F,
}

#[test]
fn test_discriminant_serde_no_use_discriminant() {
    let values = vec![
        XNoDiscriminant::A,
        XNoDiscriminant::B,
        XNoDiscriminant::C,
        XNoDiscriminant::D,
        XNoDiscriminant::E,
        XNoDiscriminant::F,
    ];
    let expected_discriminants = [0u8, 1, 2, 3, 4, 5];
    for (index, value) in values.iter().enumerate() {
        let data = to_vec(value).unwrap();
        assert_eq!(data[0], expected_discriminants[index]);
        assert_eq!(from_slice::<XNoDiscriminant>(&data).unwrap(), values[index]);
    }
}
#[derive(BorshSerialize, BorshDeserialize, PartialEq, Debug)]
struct D {
    x: u64,
}

#[derive(BorshSerialize, BorshDeserialize, PartialEq, Debug)]
enum C {
    C1,
    C2(u64),
    C3(u64, u64),
    C4 { x: u64, y: u64 },
    C5(D),
}

#[derive(BorshSerialize, BorshDeserialize, PartialEq, Eq, Clone, Copy, Debug)]
#[borsh(use_discriminant = true)]
enum X {
    A,
    B = 20,
    C,
    D,
    E = 10,
    F,
}

#[test]
fn test_discriminant_serialization() {
    let values = vec![X::A, X::B, X::C, X::D, X::E, X::F];
    for value in values {
        assert_eq!(to_vec(&value).unwrap(), [value as u8]);
    }
}

#[test]
fn test_discriminant_deserialization() {
    let values = vec![X::A, X::B, X::C, X::D, X::E, X::F];
    for value in values {
        assert_eq!(from_slice::<X>(&[value as u8]).unwrap(), value,);
    }
}

#[test]
#[should_panic = "Unexpected variant tag: 2"]
fn test_deserialize_invalid_discriminant() {
    from_slice::<X>(&[2]).unwrap();
}

#[test]
fn test_discriminant_serde() {
    let values = vec![X::A, X::B, X::C, X::D, X::E, X::F];
    let expected_discriminants = [0u8, 20, 21, 22, 10, 11];
    for (index, value) in values.iter().enumerate() {
        let data = to_vec(value).unwrap();
        assert_eq!(data[0], expected_discriminants[index]);
        assert_eq!(from_slice::<X>(&data).unwrap(), values[index]);
    }
}

'''
'''--- borsh/tests/roundtrip/requires_derive_category/test_generic_enums.rs ---
use borsh::{from_slice, to_vec, BorshDeserialize, BorshSerialize};

use alloc::{
    string::{String, ToString},
    vec,
    vec::Vec,
};

#[derive(BorshSerialize, BorshDeserialize, PartialEq, Debug)]
enum B<W, G> {
    X { f: Vec<W> },
    Y(G),
}

#[test]
fn test_generic_enum() {
    let b: B<String, u64> = B::X {
        f: vec!["one".to_string(), "two".to_string(), "three".to_string()],
    };
    let c: B<String, u64> = B::Y(656556u64);

    let list = vec![b, c];
    let data = to_vec(&list).unwrap();
    #[cfg(feature = "std")]
    insta::assert_debug_snapshot!(data);
    let actual_list = from_slice::<Vec<B<String, u64>>>(&data).unwrap();

    assert_eq!(list, actual_list);
}

'''
'''--- borsh/tests/roundtrip/requires_derive_category/test_generic_structs.rs ---
use borsh::{from_slice, to_vec, BorshDeserialize, BorshSerialize};
use core::marker::PhantomData;

#[cfg(feature = "hashbrown")]
use hashbrown::HashMap;

#[cfg(hash_collections)]
use core::{cmp::Eq, hash::Hash};

#[cfg(feature = "std")]
use std::collections::HashMap;

use alloc::{
    string::{ToString, String},
    vec,
    vec::Vec,
};

#[derive(BorshSerialize, BorshDeserialize, PartialEq, Debug)]
enum B<W, G> {
    X { f: Vec<W> },
    Y(G),
}

#[derive(BorshSerialize, BorshDeserialize, PartialEq, Debug)]
struct A<T, F, G> {
    x: Vec<T>,
    y: String,
    b: B<F, G>,
    pd: PhantomData<T>,
    c: Result<T, G>,
    d: [u64; 5],
}

#[test]
fn test_generic_struct() {
    let a = A::<String, u64, String> {
        x: vec!["foo".to_string(), "bar".to_string()],
        pd: Default::default(),
        y: "world".to_string(),
        b: B::X { f: vec![1, 2] },
        c: Err("error".to_string()),
        d: [0, 1, 2, 3, 4],
    };
    let data = to_vec(&a).unwrap();
    #[cfg(feature = "std")]
    insta::assert_debug_snapshot!(data);
    let actual_a = from_slice::<A<String, u64, String>>(&data).unwrap();
    assert_eq!(a, actual_a);
}

trait TraitName {
    type Associated;
    fn method(&self);
}

impl TraitName for u32 {
    type Associated = String;
    fn method(&self) {}
}

#[derive(BorshSerialize, BorshDeserialize, PartialEq, Debug)]
struct Parametrized<T, V>
where
    T: TraitName,
{
    field: T::Associated,
    another: V,
}

#[test]
fn test_generic_associated_type_field() {
    let a = Parametrized::<u32, String> {
        field: "value".to_string(),
        another: "field".to_string(),
    };
    let data = to_vec(&a).unwrap();
    #[cfg(feature = "std")]
    insta::assert_debug_snapshot!(data);
    let actual_a = from_slice::<Parametrized<u32, String>>(&data).unwrap();
    assert_eq!(a, actual_a);
}

/// `T: PartialOrd` bound is required for `BorshSerialize` derive to be successful
/// `T: Hash + Eq` bound is required for `BorshDeserialize` derive to be successful
#[cfg(hash_collections)]
#[derive(BorshSerialize, BorshDeserialize)]
struct C<T: Ord + Hash + Eq, U> {
    a: String,
    b: HashMap<T, U>,
}

#[cfg(hash_collections)]
#[test]
fn test_generic_struct_hashmap() {
    let mut hashmap = HashMap::new();
    hashmap.insert(34, "another".to_string());
    hashmap.insert(14, "value".to_string());
    let a = C::<u32, String> {
        a: "field".to_string(),
        b: hashmap,
    };
    let data = to_vec(&a).unwrap();
    #[cfg(feature = "std")]
    insta::assert_debug_snapshot!(data);
    let actual_a = from_slice::<C<u32, String>>(&data).unwrap();
    assert_eq!(actual_a.b.get(&14), Some("value".to_string()).as_ref());
    assert_eq!(actual_a.b.get(&34), Some("another".to_string()).as_ref());
}

'''
'''--- borsh/tests/roundtrip/requires_derive_category/test_recursive_enums.rs ---
use alloc::{
    string::{String, ToString},
    vec,
    vec::Vec,
};
use borsh::{from_slice, to_vec, BorshDeserialize, BorshSerialize};

#[derive(BorshSerialize, BorshDeserialize, PartialEq, Debug)]
enum ERecD {
    B { x: String, y: i32 },
    C(u8, Vec<ERecD>),
}

#[test]
fn test_recursive_enum() {
    let one = ERecD::B {
        x: "one".to_string(),
        y: 3213123,
    };
    let two = ERecD::C(10, vec![]);

    let three = ERecD::C(11, vec![one, two]);
    let data = to_vec(&three).unwrap();
    #[cfg(feature = "std")]
    insta::assert_debug_snapshot!(data);
    let actual_three = from_slice::<ERecD>(&data).unwrap();
    assert_eq!(three, actual_three);
}

'''
'''--- borsh/tests/roundtrip/requires_derive_category/test_recursive_structs.rs ---
use borsh::{from_slice, to_vec, BorshDeserialize, BorshSerialize};

use alloc::{string::{String, ToString}, vec::Vec, vec};
#[derive(Debug, BorshSerialize, BorshDeserialize, PartialEq, Eq)]
struct CRecB {
    a: String,
    b: Vec<CRecB>,
}

#[test]
fn test_recursive_struct() {
    let one = CRecB {
        a: "one".to_string(),
        b: vec![],
    };
    let two = CRecB {
        a: "two".to_string(),
        b: vec![],
    };

    let three = CRecB {
        a: "three".to_string(),
        b: vec![one, two],
    };

    let data = to_vec(&three).unwrap();
    #[cfg(feature = "std")]
    insta::assert_debug_snapshot!(data);
    let actual_three = from_slice::<CRecB>(&data).unwrap();
    assert_eq!(three, actual_three);
}

'''
'''--- borsh/tests/roundtrip/requires_derive_category/test_serde_with_third_party.rs ---
use alloc::{
    collections::BTreeMap,
    string::{String, ToString},
};
use borsh::{from_slice, to_vec, BorshDeserialize, BorshSerialize};

#[derive(Debug, PartialEq, Eq)]
struct ThirdParty<K, V>(pub BTreeMap<K, V>);

mod third_party_impl {
    use super::ThirdParty;

    pub(super) fn serialize_third_party<
        K: borsh::ser::BorshSerialize,
        V: borsh::ser::BorshSerialize,
        W: borsh::io::Write,
    >(
        obj: &ThirdParty<K, V>,
        writer: &mut W,
    ) -> ::core::result::Result<(), borsh::io::Error> {
        borsh::BorshSerialize::serialize(&obj.0, writer)?;
        Ok(())
    }

    pub(super) fn deserialize_third_party<
        R: borsh::io::Read,
        K: borsh::de::BorshDeserialize + Ord,
        V: borsh::de::BorshDeserialize,
    >(
        reader: &mut R,
    ) -> ::core::result::Result<ThirdParty<K, V>, borsh::io::Error> {
        Ok(ThirdParty(borsh::BorshDeserialize::deserialize_reader(
            reader,
        )?))
    }
}

#[derive(BorshSerialize, BorshDeserialize, PartialEq, Eq, Debug)]
struct A<K, V> {
    #[borsh(
        deserialize_with = "third_party_impl::deserialize_third_party",
        serialize_with = "third_party_impl::serialize_third_party",
        bound(
            deserialize = "K: borsh::de::BorshDeserialize + Ord, V: borsh::de::BorshDeserialize",
        )
    )]
    x: ThirdParty<K, V>,
    y: u64,
}

#[allow(unused)]
#[derive(BorshSerialize, BorshDeserialize, PartialEq, Eq, Debug)]
enum C<K, V> {
    C3(u64, u64),
    C4(
        u64,
        #[borsh(
            deserialize_with = "third_party_impl::deserialize_third_party",
            serialize_with = "third_party_impl::serialize_third_party",
            bound(
                deserialize = "K: borsh::de::BorshDeserialize + Ord, V: borsh::de::BorshDeserialize",
            )
        )]
        ThirdParty<K, V>,
    ),
}

#[test]
fn test_overriden_struct() {
    let mut m = BTreeMap::<u64, String>::new();
    m.insert(0, "0th element".to_string());
    m.insert(1, "1st element".to_string());
    let th_p = ThirdParty(m);
    let a = A { x: th_p, y: 42 };

    let data = to_vec(&a).unwrap();

    #[cfg(feature = "std")]
    insta::assert_debug_snapshot!(data);
    let actual_a = from_slice::<A<u64, String>>(&data).unwrap();
    assert_eq!(a, actual_a);
}

#[test]
fn test_overriden_enum() {
    let mut m = BTreeMap::<u64, String>::new();
    m.insert(0, "0th element".to_string());
    m.insert(1, "1st element".to_string());
    let th_p = ThirdParty(m);
    let c = C::C4(42, th_p);

    let data = to_vec(&c).unwrap();

    #[cfg(feature = "std")]
    insta::assert_debug_snapshot!(data);
    let actual_c = from_slice::<C<u64, String>>(&data).unwrap();
    assert_eq!(c, actual_c);
}

'''
'''--- borsh/tests/roundtrip/requires_derive_category/test_simple_enums.rs ---
use borsh::{from_slice, to_vec, BorshDeserialize, BorshSerialize};

use alloc::vec;

#[derive(BorshSerialize, BorshDeserialize, PartialEq, Debug)]
enum MixedWithUnitVariants {
    A(u16),
    B,
    C { x: i32, y: i32 },
    D,
}

#[test]
fn test_mixed_enum() {
    let vars = vec![
        MixedWithUnitVariants::A(13),
        MixedWithUnitVariants::B,
        MixedWithUnitVariants::C { x: 132, y: -17 },
        MixedWithUnitVariants::D,
    ];
    for variant in vars {
        let encoded = to_vec(&variant).unwrap();
        #[cfg(feature = "std")]
        insta::assert_debug_snapshot!(encoded);

        let decoded = from_slice::<MixedWithUnitVariants>(&encoded).unwrap();

        assert_eq!(variant, decoded);
    }
}

'''
'''--- borsh/tests/roundtrip/requires_derive_category/test_ultimate_many_features_combined.rs ---
use core::{ops, result::Result};

use alloc::{
    borrow,
    boxed::Box,
    collections::{BTreeMap, BTreeSet, LinkedList, VecDeque},
    string::{String, ToString},
    vec,
    vec::Vec,
};

use bytes::{Bytes, BytesMut};

use borsh::{from_slice, to_vec, BorshDeserialize, BorshSerialize};

#[derive(BorshSerialize, BorshDeserialize, PartialEq, Debug)]
struct A<'a> {
    x: u64,
    b: B,
    y: f32,
    z: String,
    t: (String, u64),
    btree_map_string: BTreeMap<String, String>,
    btree_set_u64: BTreeSet<u64>,
    linked_list_string: LinkedList<String>,
    vec_deque_u64: VecDeque<u64>,
    bytes: Bytes,
    bytes_mut: BytesMut,
    v: Vec<String>,
    w: Box<[u8]>,
    box_str: Box<str>,
    i: [u8; 32],
    u: Result<String, String>,
    lazy: Option<u64>,
    c: borrow::Cow<'a, str>,
    cow_arr: borrow::Cow<'a, [borrow::Cow<'a, str>]>,
    range_u32: ops::Range<u32>,
    #[borsh(skip)]
    skipped: Option<u64>,
}

#[derive(BorshSerialize, BorshDeserialize, PartialEq, Debug)]
struct B {
    x: u64,
    y: i32,
    c: C,
}

#[derive(BorshSerialize, BorshDeserialize, PartialEq, Debug)]
enum C {
    C1,
    C2(u64),
    C3(u64, u64),
    C4 { x: u64, y: u64 },
    C5(D),
}

#[derive(BorshSerialize, BorshDeserialize, PartialEq, Debug)]
struct D {
    x: u64,
}

#[derive(BorshSerialize)]
struct E<'a, 'b> {
    a: &'a A<'b>,
}

#[derive(BorshSerialize)]
struct F1<'a, 'b> {
    aa: &'a [&'a A<'b>],
}

#[derive(BorshDeserialize)]
struct F2<'b> {
    aa: Vec<A<'b>>,
}

#[test]
fn test_ultimate_combined_all_features() {
    let mut map: BTreeMap<String, String> = BTreeMap::new();
    map.insert("test".into(), "test".into());
    let mut set: BTreeSet<u64> = BTreeSet::new();
    set.insert(u64::MAX);
    let cow_arr = [
        borrow::Cow::Borrowed("Hello1"),
        borrow::Cow::Owned("Hello2".to_string()),
    ];
    let a = A {
        x: 1,
        b: B {
            x: 2,
            y: 3,
            c: C::C5(D { x: 1 }),
        },
        y: 4.0,
        z: "123".to_string(),
        t: ("Hello".to_string(), 10),
        btree_map_string: map.clone(),
        btree_set_u64: set.clone(),
        linked_list_string: vec!["a".to_string(), "b".to_string()].into_iter().collect(),
        vec_deque_u64: vec![1, 2, 3].into_iter().collect(),
        bytes: vec![5, 4, 3, 2, 1].into(),
        bytes_mut: BytesMut::from(&[1, 2, 3, 4, 5][..]),
        v: vec!["qwe".to_string(), "zxc".to_string()],
        w: vec![0].into_boxed_slice(),
        box_str: Box::from("asd"),
        i: [4u8; 32],
        u: Ok("Hello".to_string()),
        lazy: Some(5),
        c: borrow::Cow::Borrowed("Hello"),
        cow_arr: borrow::Cow::Borrowed(&cow_arr),
        range_u32: 12..71,
        skipped: Some(6),
    };
    let encoded_a = to_vec(&a).unwrap();
    let e = E { a: &a };
    let encoded_ref_a = to_vec(&e).unwrap();
    assert_eq!(encoded_ref_a, encoded_a);
    #[cfg(feature = "std")]
    insta::assert_debug_snapshot!(encoded_a);

    let decoded_a = from_slice::<A>(&encoded_a).unwrap();
    let expected_a = A {
        x: 1,
        b: B {
            x: 2,
            y: 3,
            c: C::C5(D { x: 1 }),
        },
        y: 4.0,
        z: a.z.clone(),
        t: ("Hello".to_string(), 10),
        btree_map_string: map,
        btree_set_u64: set,
        linked_list_string: vec!["a".to_string(), "b".to_string()].into_iter().collect(),
        vec_deque_u64: vec![1, 2, 3].into_iter().collect(),
        bytes: vec![5, 4, 3, 2, 1].into(),
        bytes_mut: BytesMut::from(&[1, 2, 3, 4, 5][..]),
        v: a.v.clone(),
        w: a.w.clone(),
        box_str: Box::from("asd"),
        i: a.i,
        u: Ok("Hello".to_string()),
        lazy: Some(5),
        c: borrow::Cow::Owned("Hello".to_string()),
        cow_arr: borrow::Cow::Owned(vec![
            borrow::Cow::Owned("Hello1".to_string()),
            borrow::Cow::Owned("Hello2".to_string()),
        ]),
        range_u32: 12..71,
        skipped: None,
    };

    assert_eq!(expected_a, decoded_a);

    let f1 = F1 { aa: &[&a, &a] };
    let encoded_f1 = to_vec(&f1).unwrap();
    #[cfg(feature = "std")]
    insta::assert_debug_snapshot!(encoded_f1);
    let decoded_f2 = from_slice::<F2>(&encoded_f1).unwrap();
    assert_eq!(decoded_f2.aa.len(), 2);
    assert!(decoded_f2.aa.iter().all(|f2_a| f2_a == &expected_a));
}

#[test]
fn test_object_length() {
    let mut map: BTreeMap<String, String> = BTreeMap::new();
    map.insert("test".into(), "test".into());
    let mut set: BTreeSet<u64> = BTreeSet::new();
    set.insert(u64::MAX);
    set.insert(100);
    set.insert(103);
    set.insert(109);
    let cow_arr = [
        borrow::Cow::Borrowed("Hello1"),
        borrow::Cow::Owned("Hello2".to_string()),
    ];
    let a = A {
        x: 1,
        b: B {
            x: 2,
            y: 3,
            c: C::C5(D { x: 1 }),
        },
        y: 4.0,
        z: "123".to_string(),
        t: ("Hello".to_string(), 10),
        btree_map_string: map.clone(),
        btree_set_u64: set.clone(),
        linked_list_string: vec!["a".to_string(), "b".to_string()].into_iter().collect(),
        vec_deque_u64: vec![1, 2, 3].into_iter().collect(),
        bytes: vec![5, 4, 3, 2, 1].into(),
        bytes_mut: BytesMut::from(&[1, 2, 3, 4, 5][..]),
        v: vec!["qwe".to_string(), "zxc".to_string()],
        w: vec![0].into_boxed_slice(),
        box_str: Box::from("asd"),
        i: [4u8; 32],
        u: Ok("Hello".to_string()),
        lazy: Some(5),
        c: borrow::Cow::Borrowed("Hello"),
        cow_arr: borrow::Cow::Borrowed(&cow_arr),
        range_u32: 12..71,
        skipped: Some(6),
    };
    let encoded_a_len = to_vec(&a).unwrap().len();

    let len_helper_result = borsh::object_length(&a).unwrap();

    assert_eq!(encoded_a_len, len_helper_result);
}

'''
'''--- borsh/tests/roundtrip/test_arrays.rs ---
#![allow(clippy::float_cmp)]

use borsh::{from_slice, to_vec};
#[cfg(feature = "derive")]
use borsh::{BorshDeserialize, BorshSerialize};

use alloc::string::{String, ToString};

macro_rules! test_array {
    ($v: expr, $t: ty, $len: expr) => {
        let buf = borsh::to_vec(&$v).unwrap();
        #[cfg(feature = "std")]
        insta::assert_debug_snapshot!(buf);
        let actual_v: [$t; $len] = from_slice(&buf).expect("failed to deserialize");
        assert_eq!($v.len(), actual_v.len());
        #[allow(clippy::reversed_empty_ranges)]
        for i in 0..$len {
            assert_eq!($v[i], actual_v[i]);
        }
    };
}

macro_rules! test_arrays {
    ($test_name: ident, $el: expr, $t: ty) => {
        #[test]
        fn $test_name() {
            test_array!([$el; 0], $t, 0);
            test_array!([$el; 1], $t, 1);
            test_array!([$el; 2], $t, 2);
            test_array!([$el; 3], $t, 3);
            test_array!([$el; 4], $t, 4);
            test_array!([$el; 8], $t, 8);
            test_array!([$el; 16], $t, 16);
            test_array!([$el; 32], $t, 32);
            test_array!([$el; 64], $t, 64);
            test_array!([$el; 65], $t, 65);
        }
    };
}

test_arrays!(test_array_u8, 100u8, u8);
test_arrays!(test_array_i8, 100i8, i8);
test_arrays!(test_array_u32, 1000000000u32, u32);
test_arrays!(test_array_u64, 1000000000000000000u64, u64);
test_arrays!(
    test_array_u128,
    1000000000000000000000000000000000000u128,
    u128
);
test_arrays!(test_array_f32, 1000000000.0f32, f32);
test_arrays!(test_array_array_u8, [100u8; 32], [u8; 32]);
test_arrays!(test_array_zst, (), ());

#[cfg(feature = "derive")]
#[derive(BorshDeserialize, BorshSerialize, PartialEq, Debug)]
struct CustomStruct(u8);

#[cfg(feature = "derive")]
#[test]
fn test_custom_struct_array() {
    let arr = [CustomStruct(0), CustomStruct(1), CustomStruct(2)];
    let serialized = to_vec(&arr).unwrap();
    #[cfg(feature = "std")]
    insta::assert_debug_snapshot!(serialized);
    let deserialized: [CustomStruct; 3] = from_slice(&serialized).unwrap();
    assert_eq!(arr, deserialized);
}

#[test]
fn test_string_array() {
    let arr = ["0".to_string(), "1".to_string(), "2".to_string()];
    let serialized = to_vec(&arr).unwrap();
    #[cfg(feature = "std")]
    insta::assert_debug_snapshot!(serialized);
    let deserialized: [String; 3] = from_slice(&serialized).unwrap();
    assert_eq!(arr, deserialized);
}

'''
'''--- borsh/tests/roundtrip/test_ascii_strings.rs ---
use borsh::{from_slice, to_vec};

use alloc::{
    string::String,
    vec::Vec,
};

/// Verifies serialisation and deserialisation of an ASCII string `value`.
fn check_ascii(value: &str) -> Vec<u8> {
    // Caller promises value is ASCII.
    let ascii_str = ascii::AsciiStr::from_ascii(&value).unwrap();
    let buf = to_vec(ascii_str).unwrap();
    // AsciiStr and AsciiString serialise the same way String does.
    assert_eq!(buf, to_vec(&ascii::AsciiString::from(ascii_str)).unwrap());
    // Check round trip.
    let got = from_slice::<ascii::AsciiString>(&buf).unwrap();
    assert_eq!(ascii_str, got);
    buf
}

macro_rules! test_ascii_string {
    ($test_name: ident, $str: expr, $snap:expr) => {
        #[test]
        fn $test_name() {
            let value = String::from($str);
            let _buf = check_ascii(&value);
            #[cfg(feature = "std")]
            if $snap {
                insta::assert_debug_snapshot!(_buf);
            }
        }
    };
}

test_ascii_string!(test_empty_string, "", true);
test_ascii_string!(test_a, "a", true);
test_ascii_string!(test_hello_world, "hello world", true);
test_ascii_string!(test_x_1024, "x".repeat(1024), true);
test_ascii_string!(test_x_4096, "x".repeat(4096), false);
test_ascii_string!(test_x_65535, "x".repeat(65535), false);
test_ascii_string!(test_hello_10, "hello world!".repeat(30), true);
test_ascii_string!(test_hello_1000, "hello Achilles!".repeat(1000), false);

#[test]
fn test_ascii_char() {
    use ascii::AsciiChar;

    let buf = to_vec(&AsciiChar::Dot).unwrap();
    assert_eq!(".".as_bytes(), buf);
    assert_eq!(AsciiChar::Dot, from_slice::<AsciiChar>(&buf).unwrap());

    from_slice::<AsciiChar>(&[b'\x80']).unwrap_err();
}

'''
'''--- borsh/tests/roundtrip/test_btree_map.rs ---
use alloc::{
    collections::{BTreeMap, BTreeSet},
    string::{String, ToString},
    vec,
    vec::Vec,
};

use borsh::{from_slice, BorshSerialize};

macro_rules! btreeset_test_template [
    [$test_name: ident, $($key: expr),* ] => [
        #[allow(unused_mut)]
        #[allow(redundant_semicolons)]
        #[test]
        fn $test_name() {
            let mut set = BTreeSet::new();

            set_insert_deser_assert_macro!(set, data, $($key),*);

            let actual_set = from_slice::<BTreeSet<String>>(&data).unwrap();
            assert_eq!(set, actual_set);

        }

    ]

];

macro_rules! btreemap_test_template [
    [$test_name: ident, $($key: expr => $value: expr),* ] => [
        #[allow(unused_mut)]
        #[allow(redundant_semicolons)]
        #[test]
        fn $test_name() {
            let mut map = BTreeMap::new();

            map_insert_deser_assert_macro!(map, data, $($key => $value),*);

            let actual_map = from_slice::<BTreeMap<String, String>>(&data).unwrap();
            assert_eq!(map, actual_map);

        }

    ]

];

btreeset_test_template!(test_empty_btreeset,);

btreeset_test_template!(test_1_element_btreeset, "one".to_string());

btreeset_test_template!(
    test_2_element_btreeset,
    "one".to_string(),
    "different".to_string()
);

btreeset_test_template!(
    test_default_btreeset,
    "foo".to_string(),
    "many".to_string(),
    "various".to_string(),
    "different".to_string(),
    "keys".to_string(),
    "one".to_string()
);

btreemap_test_template!(test_default_btreemap,
    "foo".to_string() => "bar".to_string(),
    "one".to_string() => "two".to_string()
);

btreemap_test_template!(test_empty_btreemap,);
btreemap_test_template!(test_1_element_btreemap,
    "one".to_string() => "element".to_string()
);

btreemap_test_template!(test_8_element_btreemap,
    "one".to_string() => "element".to_string(),
    "key".to_string() => "powers".to_string(),
    "more".to_string() => "of".to_string(),
    "various".to_string() => "two".to_string(),
    "different".to_string() => "are".to_string(),
    "keys".to_string() => "always".to_string(),
    "where".to_string() => "unpredictable".to_string(),
    "nowhere".to_string() => "pile".to_string()
);

#[cfg(feature = "de_strict_order")]
const ERROR_WRONG_ORDER_OF_KEYS: &str = "keys were not serialized in ascending order";

set_wrong_order_test!(test_btreeset_deser_err_wrong_order, BTreeSet<String>);

map_wrong_order_test!(test_btreemap_deser_err_wrong_order, BTreeMap<String, String>);

'''
'''--- borsh/tests/roundtrip/test_cells.rs ---
use alloc::string::{String, ToString};

#[test]
fn test_cell_roundtrip() {
    let cell = core::cell::Cell::new(42u32);

    let out = borsh::to_vec(&cell).unwrap();

    let cell_round: core::cell::Cell<u32> = borsh::from_slice(&out).unwrap();

    assert_eq!(cell, cell_round);
}

#[test]
fn test_ref_cell_roundtrip() {
    let rcell = core::cell::RefCell::new("str".to_string());

    let out = borsh::to_vec(&rcell).unwrap();

    let rcell_round: core::cell::RefCell<String> = borsh::from_slice(&out).unwrap();

    assert_eq!(rcell, rcell_round);
}

'''
'''--- borsh/tests/roundtrip/test_cow.rs ---
use borsh::{from_slice, to_vec};
use core::{matches, ops::Deref};
use alloc::string::ToString;

use alloc::{borrow::Cow, vec};

#[test]
fn test_cow_str() {
    let input: Cow<'_, str> = Cow::Borrowed("static input");

    let encoded = to_vec(&input).unwrap();

    #[cfg(feature = "std")]
    insta::assert_debug_snapshot!(encoded);

    let out: Cow<'_, str> = from_slice(&encoded).unwrap();

    assert!(matches!(out, Cow::Owned(..)));

    assert_eq!(input, out);
    assert_eq!(out, "static input");
}

#[test]
fn test_cow_byte_slice() {
    let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    let input: Cow<'_, [u8]> = Cow::Borrowed(&arr);

    let encoded = to_vec(&input).unwrap();

    #[cfg(feature = "std")]
    insta::assert_debug_snapshot!(encoded);

    let out: Cow<'_, [u8]> = from_slice(&encoded).unwrap();

    assert!(matches!(out, Cow::Owned(..)));

    assert_eq!(input, out);
    assert_eq!(out, vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
}

#[test]
fn test_cow_slice_of_cow_str() {
    let arr = [
        Cow::Borrowed("first static input"),
        Cow::Owned("second static input".to_string()),
    ];
    let input: Cow<'_, [Cow<'_, str>]> = Cow::Borrowed(&arr);

    let encoded = to_vec(&input).unwrap();

    #[cfg(feature = "std")]
    insta::assert_debug_snapshot!(encoded);

    let out: Cow<'_, [Cow<'_, str>]> = from_slice(&encoded).unwrap();

    assert!(matches!(out, Cow::Owned(..)));

    for element in out.deref() {
        assert!(matches!(element, Cow::Owned(..)));
    }

    assert_eq!(input, out);
    assert_eq!(
        out,
        vec![
            Cow::Borrowed("first static input"),
            Cow::Borrowed("second static input"),
        ]
    );
}

'''
'''--- borsh/tests/roundtrip/test_hash_map.rs ---
#[cfg(feature = "std")]
use core::hash::BuildHasher;

#[cfg(feature = "hashbrown")]
use hashbrown::{HashMap, HashSet};
#[cfg(feature = "std")]
use std::collections::{
    hash_map::{DefaultHasher, RandomState},
    HashMap, HashSet,
};

#[cfg(not(feature = "std"))]
use core::iter::IntoIterator;

use alloc::{
    string::{String, ToString},
    vec,
    vec::Vec,
};

use borsh::{from_slice, BorshSerialize};

macro_rules! hashset_test_template [
    [$test_name: ident, $($key: expr),* ] => [
        #[allow(unused_mut)]
        #[allow(redundant_semicolons)]
        #[test]
        fn $test_name() {
            let mut set = HashSet::new();

            set_insert_deser_assert_macro!(set, data, $($key),*);

            let actual_set = from_slice::<HashSet<String>>(&data).unwrap();
            assert_eq!(set, actual_set);

        }

    ]

];

macro_rules! hashmap_test_template [
    [$test_name: ident, $($key: expr => $value: expr),* ] => [
        #[allow(unused_mut)]
        #[allow(redundant_semicolons)]
        #[test]
        fn $test_name() {
            let mut map = HashMap::new();

            map_insert_deser_assert_macro!(map, data, $($key => $value),*);

            let actual_map = from_slice::<HashMap<String, String>>(&data).unwrap();
            assert_eq!(map, actual_map);

        }

    ]

];

#[derive(Default)]
#[cfg(feature = "std")]
struct NewHasher(RandomState);

#[cfg(feature = "std")]
impl BuildHasher for NewHasher {
    type Hasher = DefaultHasher;
    fn build_hasher(&self) -> DefaultHasher {
        self.0.build_hasher()
    }
}

#[cfg(feature = "std")]
macro_rules! generic_hashset_test_template [
    [$test_name: ident, $($key: expr),* ] => [
        #[allow(unused_mut)]
        #[allow(redundant_semicolons)]
        #[test]
        fn $test_name() {
            let mut set = HashSet::with_hasher(NewHasher::default());

            set_insert_deser_assert_macro!(set, data, $($key),*);

            let actual_set = from_slice::<HashSet<String, NewHasher>>(&data).unwrap();
            assert_eq!(set, actual_set);

        }

    ]

];

#[cfg(feature = "std")]
macro_rules! generic_hashmap_test_template [
    [$test_name: ident, $($key: expr => $value: expr),* ] => [
        #[allow(unused_mut)]
        #[allow(redundant_semicolons)]
        #[test]
        fn $test_name() {
            let mut map = HashMap::with_hasher(NewHasher::default());

            map_insert_deser_assert_macro!(map, data, $($key => $value),*);

            let actual_map = from_slice::<HashMap<String, String, NewHasher>>(&data).unwrap();
            assert_eq!(map, actual_map);

        }

    ]

];

hashset_test_template!(test_empty_hashset,);

hashset_test_template!(test_1_element_hashset, "one".to_string());

hashset_test_template!(
    test_2_element_hashset,
    "one".to_string(),
    "different".to_string()
);

hashset_test_template!(
    test_default_hashset,
    "foo".to_string(),
    "many".to_string(),
    "various".to_string(),
    "different".to_string(),
    "keys".to_string(),
    "one".to_string()
);

#[cfg(feature = "std")]
generic_hashset_test_template!(test_empty_generic_hashset,);

#[cfg(feature = "std")]
generic_hashset_test_template!(test_1_element_generic_hashset, "one".to_string());

#[cfg(feature = "std")]
generic_hashset_test_template!(
    test_2_element_generic_hashset,
    "one".to_string(),
    "different".to_string()
);

#[cfg(feature = "std")]
generic_hashset_test_template!(
    test_generic_hashset,
    "foo".to_string(),
    "many".to_string(),
    "various".to_string(),
    "different".to_string(),
    "keys".to_string(),
    "one".to_string()
);

hashmap_test_template!(test_default_hashmap,
    "foo".to_string() => "bar".to_string(),
    "one".to_string() => "two".to_string()
);

hashmap_test_template!(test_empty_hashmap,);
hashmap_test_template!(test_1_element_hashmap,
    "one".to_string() => "element".to_string()
);

hashmap_test_template!(test_8_element_hashmap,
    "one".to_string() => "element".to_string(),
    "key".to_string() => "powers".to_string(),
    "more".to_string() => "of".to_string(),
    "various".to_string() => "two".to_string(),
    "different".to_string() => "are".to_string(),
    "keys".to_string() => "always".to_string(),
    "where".to_string() => "unpredictable".to_string(),
    "nowhere".to_string() => "pile".to_string()
);

#[cfg(feature = "std")]
generic_hashmap_test_template!(test_generic_hash_hashmap,
    "foo".to_string() => "bar".to_string(),
    "one".to_string() => "two".to_string()
);

#[cfg(feature = "std")]
generic_hashmap_test_template!(test_empty_generic_hashmap,);
#[cfg(feature = "std")]
generic_hashmap_test_template!(test_1_element_generic_hashmap,
    "one".to_string() => "element".to_string()
);

#[cfg(feature = "std")]
generic_hashmap_test_template!(test_8_element_generic_hashmap,
    "one".to_string() => "element".to_string(),
    "key".to_string() => "powers".to_string(),
    "more".to_string() => "of".to_string(),
    "various".to_string() => "two".to_string(),
    "different".to_string() => "are".to_string(),
    "keys".to_string() => "always".to_string(),
    "where".to_string() => "unpredictable".to_string(),
    "nowhere".to_string() => "pile".to_string()
);

#[cfg(feature = "de_strict_order")]
const ERROR_WRONG_ORDER_OF_KEYS: &str = "keys were not serialized in ascending order";

set_wrong_order_test!(test_hashset_deser_err_wrong_order, HashSet<String>);
#[cfg(feature = "std")]
set_wrong_order_test!(test_generic_hashset_deser_err_wrong_order, HashSet<String, NewHasher>);

map_wrong_order_test!(test_hashmap_deser_err_wrong_order, HashMap<String, String>);

#[cfg(feature = "std")]
map_wrong_order_test!(test_generic_hashmap_deser_err_wrong_order, HashMap<String, String, NewHasher>);

'''
'''--- borsh/tests/roundtrip/test_nonzero_integers.rs ---
use borsh::from_slice;
use core::num::*;

#[test]
fn test_nonzero_integer_u8() {
    let bytes = &[1];
    assert_eq!(from_slice::<NonZeroU8>(bytes).unwrap().get(), 1);
}

#[test]
fn test_nonzero_integer_u32() {
    let bytes = &[255, 0, 0, 0];
    assert_eq!(from_slice::<NonZeroU32>(bytes).unwrap().get(), 255);
}

#[test]
fn test_nonzero_integer_usize() {
    let bytes = &[1, 1, 0, 0, 0, 0, 0, 0];
    assert_eq!(from_slice::<NonZeroUsize>(bytes).unwrap().get(), 257);
}

#[test]
fn test_nonzero_integer_i64() {
    let bytes = &[255; 8];
    assert_eq!(from_slice::<NonZeroI64>(bytes).unwrap().get(), -1);
}

#[test]
fn test_nonzero_integer_i16b() {
    let bytes = &[0, 0b1000_0000];
    assert_eq!(from_slice::<NonZeroI16>(bytes).unwrap().get(), i16::MIN);
}

'''
'''--- borsh/tests/roundtrip/test_primitives.rs ---
use borsh::{from_slice, to_vec};

macro_rules! test_primitive {
    ($test_name: ident, $v: expr, $t: ty) => {
        #[test]
        fn $test_name() {
            let expected: $t = $v;

            let buf = to_vec(&expected).unwrap();
            #[cfg(feature = "std")]
            insta::assert_debug_snapshot!(buf);
            let actual = from_slice::<$t>(&buf).expect("failed to deserialize");
            assert_eq!(actual, expected);
        }
    };
}

test_primitive!(test_isize_neg, -100isize, isize);
test_primitive!(test_isize_pos, 100isize, isize);
test_primitive!(test_isize_min, isize::min_value(), isize);
test_primitive!(test_isize_max, isize::max_value(), isize);

test_primitive!(test_usize, 100usize, usize);
test_primitive!(test_usize_min, usize::min_value(), usize);
test_primitive!(test_usize_max, usize::max_value(), usize);

'''
'''--- borsh/tests/roundtrip/test_range.rs ---
#[test]
fn test_ranges() {
    let want = (1..2, 3..=4, 5.., ..6, ..=7, ..);

    let encoded = borsh::to_vec(&want).unwrap();
    #[cfg(feature = "std")]
    insta::assert_debug_snapshot!(encoded);

    let got = borsh::from_slice(&encoded).unwrap();
    assert_eq!(want, got);
}

'''
'''--- borsh/tests/roundtrip/test_rc.rs ---
pub use alloc::{rc, sync};

use borsh::{from_slice, to_vec};

#[test]
fn test_rc_roundtrip() {
    let value = rc::Rc::new(8u8);
    let serialized = to_vec(&value).unwrap();
    let deserialized = from_slice::<rc::Rc<u8>>(&serialized).unwrap();
    assert_eq!(value, deserialized);
}

#[test]
fn test_slice_rc() {
    let original: &[i32] = &[1, 2, 3, 4, 6, 9, 10];
    let shared: rc::Rc<[i32]> = rc::Rc::from(original);
    let serialized = to_vec(&shared).unwrap();
    let deserialized = from_slice::<rc::Rc<[i32]>>(&serialized).unwrap();
    assert_eq!(original, &*deserialized);
}

#[test]
fn test_arc_roundtrip() {
    let value = sync::Arc::new(8u8);
    let serialized = to_vec(&value).unwrap();
    let deserialized = from_slice::<sync::Arc<u8>>(&serialized).unwrap();
    assert_eq!(value, deserialized);
}

#[test]
fn test_slice_arc() {
    let original: &[i32] = &[1, 2, 3, 4, 6, 9, 10];
    let shared: sync::Arc<[i32]> = sync::Arc::from(original);
    let serialized = to_vec(&shared).unwrap();
    let deserialized = from_slice::<sync::Arc<[i32]>>(&serialized).unwrap();
    assert_eq!(original, &*deserialized);
}

'''
'''--- borsh/tests/roundtrip/test_strings.rs ---
use alloc::string::String;
use borsh::{from_slice, to_vec};

/// Verifies serialisation and deserialisation of the given string.
///
/// Returns serialised representation of the string.
fn check_string(value: &str) -> alloc::vec::Vec<u8> {
    // Encoding is the same as Vec<u8> with UTF-8 encoded string.
    let buf = to_vec(value.as_bytes()).unwrap();
    assert_eq!(buf, to_vec(value).unwrap());
    assert_eq!(buf, to_vec(&String::from(value)).unwrap());
    // Check round trip.
    assert_eq!(value, from_slice::<String>(&buf).unwrap());
    buf
}

macro_rules! test_string {
    ($test_name: ident, $str: expr, $snap:expr) => {
        #[test]
        fn $test_name() {
            let value = String::from($str);
            let _buf = check_string(&value);
            #[cfg(feature = "std")]
            if $snap {
                insta::assert_debug_snapshot!(_buf);
            }
        }
    };
}

test_string!(test_empty_string, "", true);
test_string!(test_a, "a", true);
test_string!(test_hello_world, "hello world", true);
test_string!(test_x_1024, "x".repeat(1024), true);
test_string!(test_x_4096, "x".repeat(4096), false);
test_string!(test_x_65535, "x".repeat(65535), false);
test_string!(test_hello_10, "hello world!".repeat(30), true);
test_string!(test_hello_1000, "hello world!".repeat(1000), false);

test_string!(test_non_ascii, "💩", true);

'''
'''--- borsh/tests/roundtrip/test_tuple.rs ---
use borsh::{from_slice, to_vec};

#[test]
fn test_unary_tuple() {
    let expected = (true,);
    let buf = to_vec(&expected).unwrap();
    #[cfg(feature = "std")]
    insta::assert_debug_snapshot!(buf);
    let actual = from_slice::<(bool,)>(&buf).expect("failed to deserialize");
    assert_eq!(actual, expected);
}

'''
'''--- borsh/tests/roundtrip/test_vecs.rs ---
use borsh::{from_slice, to_vec};

use alloc::{
    string::{String, ToString},
    vec,
    vec::Vec,
};

macro_rules! test_vec {
    ($v: expr, $t: ty, $snap: expr) => {
        let buf = to_vec(&$v).unwrap();
        #[cfg(feature = "std")]
        if $snap {
            insta::assert_debug_snapshot!(buf);
        }
        let actual_v: Vec<$t> = from_slice(&buf).expect("failed to deserialize");
        assert_eq!(actual_v, $v);
    };
}

macro_rules! test_vecs {
    ($test_name: ident, $el: expr, $t: ty) => {
        #[test]
        fn $test_name() {
            test_vec!(Vec::<$t>::new(), $t, true);
            test_vec!(vec![$el], $t, true);
            test_vec!(vec![$el; 10], $t, true);
            test_vec!(vec![$el; 100], $t, true);
            test_vec!(vec![$el; 1000], $t, false); // one assumes that the concept has been proved
            test_vec!(vec![$el; 10000], $t, false);
        }
    };
}

test_vecs!(test_vec_u8, 100u8, u8);
test_vecs!(test_vec_i8, 100i8, i8);
test_vecs!(test_vec_u32, 1000000000u32, u32);
test_vecs!(test_vec_f32, 1000000000.0f32, f32);
test_vecs!(test_vec_string, "a".to_string(), String);
test_vecs!(test_vec_vec_u8, vec![100u8; 10], Vec<u8>);
test_vecs!(test_vec_vec_u32, vec![100u32; 10], Vec<u32>);

'''
'''--- borsh/tests/schema/container_extension/test_max_size.rs ---
use crate::common_macro::schema_imports::*;

#[track_caller]
fn test_ok<T: BorshSchema>(want: usize) {
    let schema = BorshSchemaContainer::for_type::<T>();
    assert_eq!(Ok(want), schema.max_serialized_size());
}

#[track_caller]
fn test_err<T: BorshSchema>(err: SchemaMaxSerializedSizeError) {
    let schema = BorshSchemaContainer::for_type::<T>();
    assert_eq!(Err(err), schema.max_serialized_size());
}

const MAX_LEN: usize = u32::MAX as usize;

#[test]
fn max_serialized_size_primitives() {
    test_ok::<()>(0);
    test_ok::<bool>(1);

    test_ok::<f32>(4);
    test_ok::<f64>(8);

    test_ok::<i8>(1);
    test_ok::<i16>(2);
    test_ok::<i32>(4);
    test_ok::<i64>(8);
    test_ok::<i128>(16);

    test_ok::<u8>(1);
    test_ok::<u16>(2);
    test_ok::<u32>(4);
    test_ok::<u64>(8);
    test_ok::<u128>(16);

    test_ok::<core::num::NonZeroI8>(1);
    test_ok::<core::num::NonZeroI16>(2);
    test_ok::<core::num::NonZeroI32>(4);
    test_ok::<core::num::NonZeroI64>(8);
    test_ok::<core::num::NonZeroI128>(16);

    test_ok::<core::num::NonZeroU8>(1);
    test_ok::<core::num::NonZeroU16>(2);
    test_ok::<core::num::NonZeroU32>(4);
    test_ok::<core::num::NonZeroU64>(8);
    test_ok::<core::num::NonZeroU128>(16);

    test_ok::<isize>(8);
    test_ok::<usize>(8);
    test_ok::<core::num::NonZeroUsize>(8);
}

#[test]
fn max_serialized_size_built_in_types() {
    test_ok::<core::ops::RangeFull>(0);
    test_ok::<core::ops::RangeInclusive<u8>>(2);
    test_ok::<core::ops::RangeToInclusive<u64>>(8);

    test_ok::<Option<()>>(1);
    test_ok::<Option<u8>>(2);
    test_ok::<Result<u8, usize>>(9);
    test_ok::<Result<u8, Vec<u8>>>(1 + 4 + MAX_LEN);

    test_ok::<()>(0);
    test_ok::<(u8,)>(1);
    test_ok::<(u8, u32)>(5);

    test_ok::<[u8; 0]>(0);
    test_ok::<[u8; 16]>(16);
    test_ok::<[[u8; 4]; 4]>(16);

    test_ok::<[u16; 0]>(0);
    test_ok::<[u16; 16]>(32);
    test_ok::<[[u16; 4]; 4]>(32);

    test_ok::<Vec<u8>>(4 + MAX_LEN);
    test_ok::<String>(4 + MAX_LEN);

    test_err::<Vec<Vec<u8>>>(SchemaMaxSerializedSizeError::Overflow);
    test_ok::<Vec<Vec<()>>>(4 + MAX_LEN * 4);
    test_ok::<[[[(); MAX_LEN]; MAX_LEN]; MAX_LEN]>(0);
}

#[test]
fn max_serialized_size_derived_types() {
    #[derive(BorshSchema)]
    pub struct Empty;

    #[derive(BorshSchema)]
    pub struct Named {
        _foo: usize,
        _bar: [u8; 15],
    }

    #[derive(BorshSchema)]
    #[allow(unused)]
    pub struct Unnamed(usize, [u8; 15]);

    #[derive(BorshSchema)]
    struct Multiple {
        _usz0: usize,
        _usz1: usize,
        _usz2: usize,
        _vec0: Vec<usize>,
        _vec1: Vec<usize>,
    }

    #[derive(BorshSchema)]
    #[allow(unused)]
    struct Recursive(Option<Box<Recursive>>);

    test_ok::<Empty>(0);
    test_ok::<Named>(23);
    test_ok::<Unnamed>(23);
    test_ok::<Multiple>(3 * 8 + 2 * (4 + MAX_LEN * 8));
    test_err::<BorshSchemaContainer>(SchemaMaxSerializedSizeError::Overflow);
    test_err::<Recursive>(SchemaMaxSerializedSizeError::Recursive);
}

#[test]
fn max_serialized_size_custom_enum() {
    #[allow(dead_code)]
    enum Maybe<const N: u8, T> {
        Just(T),
        Nothing,
    }

    impl<const N: u8, T: BorshSchema> BorshSchema for Maybe<N, T> {
        fn declaration() -> Declaration {
            let res = format!(r#"Maybe<{}, {}>"#, N, T::declaration());
            res
        }
        fn add_definitions_recursively(definitions: &mut BTreeMap<Declaration, Definition>) {
            let definition = Definition::Enum {
                tag_width: N,
                variants: vec![
                    (0, "Just".into(), T::declaration()),
                    (1, "Nothing".into(), <()>::declaration()),
                ],
            };
            add_definition(Self::declaration(), definition, definitions);
            T::add_definitions_recursively(definitions);
            <()>::add_definitions_recursively(definitions);
        }
    }

    test_ok::<Maybe<0, ()>>(0);
    test_ok::<Maybe<0, u16>>(2);
    test_ok::<Maybe<0, u64>>(8);

    test_ok::<Maybe<1, ()>>(1);
    test_ok::<Maybe<1, u16>>(3);
    test_ok::<Maybe<1, u64>>(9);

    test_ok::<Maybe<4, ()>>(4);
    test_ok::<Maybe<4, u16>>(6);
    test_ok::<Maybe<4, u64>>(12);
}

#[test]
fn max_serialized_size_bound_vec() {
    #[allow(dead_code)]
    struct BoundVec<const W: u8, const N: u64>;

    impl<const W: u8, const N: u64> BorshSchema for BoundVec<W, N> {
        fn declaration() -> Declaration {
            format!("BoundVec<{}, {}>", W, N)
        }
        fn add_definitions_recursively(definitions: &mut BTreeMap<Declaration, Definition>) {
            let definition = Definition::Sequence {
                length_width: W,
                length_range: 0..=N,
                elements: "u8".to_string(),
            };
            add_definition(Self::declaration(), definition, definitions);
            u8::add_definitions_recursively(definitions);
        }
    }

    test_ok::<BoundVec<4, 0>>(4);
    test_ok::<BoundVec<4, { u16::MAX as u64 }>>(4 + u16::MAX as usize);
    test_ok::<BoundVec<4, 20>>(24);

    test_ok::<BoundVec<1, 0>>(1);
    test_ok::<BoundVec<1, { u16::MAX as u64 }>>(1 + u16::MAX as usize);
    test_ok::<BoundVec<1, 20>>(21);

    test_ok::<BoundVec<0, 0>>(0);
    test_ok::<BoundVec<0, { u16::MAX as u64 }>>(u16::MAX as usize);
    test_ok::<BoundVec<0, 20>>(20);
}

#[test]
fn max_serialized_size_small_vec() {
    #[allow(dead_code)]
    struct SmallVec<T>(core::marker::PhantomData<T>);

    impl<T: BorshSchema> BorshSchema for SmallVec<T> {
        fn declaration() -> Declaration {
            format!(r#"SmallVec<{}>"#, T::declaration())
        }
        fn add_definitions_recursively(definitions: &mut BTreeMap<Declaration, Definition>) {
            let definition = Definition::Sequence {
                length_width: 1,
                length_range: 0..=u8::MAX as u64,
                elements: T::declaration(),
            };
            add_definition(Self::declaration(), definition, definitions);
            T::add_definitions_recursively(definitions);
        }
    }

    test_ok::<SmallVec<u8>>(u8::MAX as usize + 1);
    test_ok::<SmallVec<u16>>(u8::MAX as usize * 2 + 1);
}

'''
'''--- borsh/tests/schema/container_extension/test_schema_validate.rs ---
use crate::common_macro::schema_imports::*;

use alloc::{boxed::Box, collections::BTreeMap, format, string::ToString, vec::Vec};

#[track_caller]
fn test_ok<T: BorshSchema>() {
    let schema = BorshSchemaContainer::for_type::<T>();
    assert_eq!(Ok(()), schema.validate());
}

#[track_caller]
fn test_err<T: BorshSchema>(err: SchemaContainerValidateError) {
    let schema = BorshSchemaContainer::for_type::<T>();
    assert_eq!(Err(err), schema.validate());
}

#[test]
fn validate_for_derived_types() {
    #[derive(BorshSchema)]
    pub struct Empty;

    #[derive(BorshSchema)]
    pub struct Named {
        _foo: usize,
        _bar: [u8; 15],
    }

    #[derive(BorshSchema)]
    #[allow(unused)]
    pub struct Unnamed(usize, [u8; 15]);

    #[derive(BorshSchema)]
    #[allow(unused)]
    struct Recursive(Option<Box<Recursive>>);

    #[derive(BorshSchema)]
    #[allow(unused)]
    struct RecursiveSequence(Vec<RecursiveSequence>);

    // thankfully, this one cannot be constructed
    #[derive(BorshSchema)]
    #[allow(unused)]
    struct RecursiveArray(Box<[RecursiveArray; 3]>);

    test_ok::<Empty>();
    test_ok::<Named>();
    test_ok::<Unnamed>();
    test_ok::<BorshSchemaContainer>();
    test_ok::<Recursive>();
    test_ok::<RecursiveSequence>();
    test_ok::<RecursiveArray>();

    test_ok::<[(); 300]>();
}

#[test]
fn validate_for_zst_sequences() {
    test_err::<Vec<Vec<()>>>(SchemaContainerValidateError::ZSTSequence(
        "Vec<()>".to_string(),
    ));
    test_err::<Vec<core::ops::RangeFull>>(SchemaContainerValidateError::ZSTSequence(
        "Vec<RangeFull>".to_string(),
    ));
}

#[test]
fn validate_bound_vec() {
    #[allow(dead_code)]
    struct BoundVec<const W: u8, const N: u64>;

    impl<const W: u8, const N: u64> BorshSchema for BoundVec<W, N> {
        fn declaration() -> Declaration {
            format!("BoundVec<{}, {}>", W, N)
        }
        fn add_definitions_recursively(definitions: &mut BTreeMap<Declaration, Definition>) {
            let definition = Definition::Sequence {
                length_width: W,
                length_range: 0..=N,
                elements: "u8".to_string(),
            };
            add_definition(Self::declaration(), definition, definitions);
            u8::add_definitions_recursively(definitions);
        }
    }

    test_ok::<BoundVec<4, { u16::MAX as u64 }>>();
    test_err::<BoundVec<1, { u16::MAX as u64 }>>(SchemaContainerValidateError::TagTooNarrow(
        "BoundVec<1, 65535>".to_string(),
    ));

    test_ok::<BoundVec<1, { u8::MAX as u64 }>>();
    test_ok::<BoundVec<0, { u16::MAX as u64 }>>();
}

'''
'''--- borsh/tests/schema/schema_conflict/test_schema_conflict.rs ---
use crate::common_macro::schema_imports::*;
use alloc::{
    collections::{BTreeMap, BTreeSet},
    format,
    string::ToString,
    vec::Vec,
};

struct ConflictingSchema;

impl BorshSchema for ConflictingSchema {
    #[inline]
    fn add_definitions_recursively(definitions: &mut BTreeMap<Declaration, Definition>) {
        let fields = Fields::Empty;
        let def = Definition::Struct { fields };
        add_definition(Self::declaration(), def, definitions);
    }
    #[inline]
    fn declaration() -> Declaration {
        "i64".into()
    }
}

#[test]
#[should_panic(expected = "Redefining type schema for i64")]
fn test_conflict() {
    let mut defs = Default::default();
    <Vec<i64> as borsh::BorshSchema>::add_definitions_recursively(&mut defs);

    <ConflictingSchema as borsh::BorshSchema>::add_definitions_recursively(&mut defs);
}

#[test]
#[should_panic(expected = "Redefining type schema for i64")]
fn test_implicit_conflict_vec() {
    let mut defs = Default::default();
    <Vec<i64> as borsh::BorshSchema>::add_definitions_recursively(&mut defs);
    <Vec<ConflictingSchema> as borsh::BorshSchema>::add_definitions_recursively(&mut defs);
}

#[test]
#[should_panic(expected = "Redefining type schema for i64")]
fn test_implicit_conflict_range() {
    let mut defs = Default::default();
    <core::ops::Range<i64> as borsh::BorshSchema>::add_definitions_recursively(&mut defs);
    <core::ops::Range<ConflictingSchema> as borsh::BorshSchema>::add_definitions_recursively(
        &mut defs,
    );
}

#[test]
#[should_panic(expected = "Redefining type schema for i64")]
fn test_implicit_conflict_slice() {
    let mut defs = Default::default();
    <[i64] as borsh::BorshSchema>::add_definitions_recursively(&mut defs);
    <[ConflictingSchema] as borsh::BorshSchema>::add_definitions_recursively(&mut defs);
}

#[test]
#[should_panic(expected = "Redefining type schema for i64")]
fn test_implicit_conflict_array() {
    let mut defs = Default::default();
    <[i64; 10] as borsh::BorshSchema>::add_definitions_recursively(&mut defs);
    <[ConflictingSchema; 10] as borsh::BorshSchema>::add_definitions_recursively(&mut defs);
}

#[test]
#[should_panic(expected = "Redefining type schema for i64")]
fn test_implicit_conflict_option() {
    let mut defs = Default::default();
    <Option<i64> as borsh::BorshSchema>::add_definitions_recursively(&mut defs);
    <Option<ConflictingSchema> as borsh::BorshSchema>::add_definitions_recursively(&mut defs);
}

#[allow(unused)]
#[derive(borsh::BorshSchema)]
struct GenericStruct<T> {
    field: T,
}

#[test]
fn test_implicit_conflict_struct() {
    let mut defs = Default::default();
    <GenericStruct<i64> as borsh::BorshSchema>::add_definitions_recursively(&mut defs);
    <GenericStruct<ConflictingSchema> as borsh::BorshSchema>::add_definitions_recursively(
        &mut defs,
    );
    // NOTE: the contents of `defs` depend on the order of 2 above lines
    // this loophole is needed to enable derives for recursive structs/enums
}

#[allow(unused)]
#[derive(borsh::BorshSchema)]
struct SelfConflictingStruct {
    field_1: i64,
    field_2: ConflictingSchema,
}

#[test]
#[should_panic(expected = "Redefining type schema for i64")]
fn test_implicit_conflict_self_conflicting_struct() {
    let mut defs = Default::default();
    <SelfConflictingStruct as borsh::BorshSchema>::add_definitions_recursively(&mut defs);
}

#[allow(unused)]
#[derive(borsh::BorshSchema)]
enum GenericEnum<T> {
    A { field: T },
    B(u64),
}

#[test]
fn test_implicit_conflict_enum() {
    let mut defs = Default::default();
    <GenericEnum<i64> as borsh::BorshSchema>::add_definitions_recursively(&mut defs);
    <GenericEnum<ConflictingSchema> as borsh::BorshSchema>::add_definitions_recursively(&mut defs);
    // NOTE: the contents of `defs` depend on the order of 2 above lines
    // this loophole is needed to enable derives for recursive structs/enums
}

#[allow(unused)]
#[derive(borsh::BorshSchema)]
enum SelfConflictingEnum {
    A { field: i64 },
    B { field: ConflictingSchema },
}

#[test]
#[should_panic(expected = "Redefining type schema for i64")]
fn test_implicit_conflict_self_conflicting_enum() {
    let mut defs = Default::default();
    <SelfConflictingEnum as borsh::BorshSchema>::add_definitions_recursively(&mut defs);
}

#[test]
#[should_panic(expected = "Redefining type schema for i64")]
fn test_implicit_conflict_result() {
    let mut defs = Default::default();
    <Result<u8, i64> as borsh::BorshSchema>::add_definitions_recursively(&mut defs);
    <Result<u8, ConflictingSchema> as borsh::BorshSchema>::add_definitions_recursively(&mut defs);
}

#[test]
#[should_panic(expected = "Redefining type schema for i64")]
fn test_implicit_conflict_btreemap() {
    let mut defs = Default::default();
    <BTreeMap<i64, u8> as borsh::BorshSchema>::add_definitions_recursively(&mut defs);
    <BTreeMap<ConflictingSchema, u8> as borsh::BorshSchema>::add_definitions_recursively(&mut defs);
}

#[test]
#[should_panic(expected = "Redefining type schema for i64")]
fn test_implicit_conflict_btreeset() {
    let mut defs = Default::default();
    <BTreeSet<i64> as borsh::BorshSchema>::add_definitions_recursively(&mut defs);
    <BTreeSet<ConflictingSchema> as borsh::BorshSchema>::add_definitions_recursively(&mut defs);
}

#[test]
#[should_panic(expected = "Redefining type schema for i64")]
fn test_implicit_conflict_tuple() {
    let mut defs = Default::default();
    <(i64, u8) as borsh::BorshSchema>::add_definitions_recursively(&mut defs);
    <(ConflictingSchema, u8) as borsh::BorshSchema>::add_definitions_recursively(&mut defs);
}

'''
'''--- borsh/tests/schema/test_arrays.rs ---
use crate::common_macro::schema_imports::*;
#[test]
fn simple_array() {
    let actual_name = <[u64; 32]>::declaration();
    let mut actual_defs = schema_map!();
    <[u64; 32]>::add_definitions_recursively(&mut actual_defs);
    assert_eq!("[u64; 32]", actual_name);
    assert_eq!(
        schema_map! {
            "[u64; 32]" => Definition::Sequence {
                length_width: Definition::ARRAY_LENGTH_WIDTH,
                length_range: 32..=32,
                elements: "u64".to_string()
            },
            "u64" => Definition::Primitive(8)
        },
        actual_defs
    );
}

#[test]
fn nested_array() {
    let actual_name = <[[[u64; 9]; 10]; 32]>::declaration();
    let mut actual_defs = schema_map!();
    <[[[u64; 9]; 10]; 32]>::add_definitions_recursively(&mut actual_defs);
    assert_eq!("[[[u64; 9]; 10]; 32]", actual_name);
    assert_eq!(
        schema_map! {
            "[u64; 9]" => Definition::Sequence {
                length_width: Definition::ARRAY_LENGTH_WIDTH,
                length_range: 9..=9,
                elements: "u64".to_string()
            },
            "[[u64; 9]; 10]" => Definition::Sequence {
                length_width: Definition::ARRAY_LENGTH_WIDTH,
                length_range: 10..=10,
                elements: "[u64; 9]".to_string()
            },
            "[[[u64; 9]; 10]; 32]" => Definition::Sequence {
                length_width: Definition::ARRAY_LENGTH_WIDTH,
                length_range: 32..=32,
                elements: "[[u64; 9]; 10]".to_string()
            },
            "u64" => Definition::Primitive(8)
        },
        actual_defs
    );
}

'''
'''--- borsh/tests/schema/test_ascii_strings.rs ---
use crate::common_macro::schema_imports::*;

#[test]
fn test_ascii_strings() {
    assert_eq!("AsciiString", ascii::AsciiStr::declaration());
    assert_eq!("AsciiString", ascii::AsciiString::declaration());
    assert_eq!("AsciiChar", ascii::AsciiChar::declaration());

    let want_char = schema_map! {
        "AsciiChar" => Definition::Primitive(1)
    };
    let mut actual_defs = schema_map!();
    ascii::AsciiChar::add_definitions_recursively(&mut actual_defs);
    assert_eq!(want_char, actual_defs);

    let want = schema_map! {
        "AsciiString" => Definition::Sequence {
            length_width: Definition::DEFAULT_LENGTH_WIDTH,
            length_range: Definition::DEFAULT_LENGTH_RANGE,
            elements: "AsciiChar".to_string()
        },
        "AsciiChar" => Definition::Primitive(1)
    };

    let mut actual_defs = schema_map!();
    ascii::AsciiStr::add_definitions_recursively(&mut actual_defs);
    assert_eq!(want, actual_defs);

    let mut actual_defs = schema_map!();
    ascii::AsciiString::add_definitions_recursively(&mut actual_defs);
    assert_eq!(want, actual_defs);
}

'''
'''--- borsh/tests/schema/test_box.rs ---
use crate::common_macro::schema_imports::*;

#[test]
fn boxed_schema() {
    let boxed_declaration = Box::<str>::declaration();
    assert_eq!("String", boxed_declaration);
    let boxed_declaration = Box::<[u8]>::declaration();
    assert_eq!("Vec<u8>", boxed_declaration);
}

'''
'''--- borsh/tests/schema/test_btree_map.rs ---
use crate::common_macro::schema_imports::*;

use alloc::collections::{BTreeMap, BTreeSet};

#[test]
fn b_tree_map() {
    let actual_name = BTreeMap::<u64, String>::declaration();
    let mut actual_defs = schema_map!();
    BTreeMap::<u64, String>::add_definitions_recursively(&mut actual_defs);
    assert_eq!("BTreeMap<u64, String>", actual_name);
    assert_eq!(
        schema_map! {
            "BTreeMap<u64, String>" => Definition::Sequence {
                length_width: Definition::DEFAULT_LENGTH_WIDTH,
                length_range: Definition::DEFAULT_LENGTH_RANGE,
                elements: "(u64, String)".to_string(),
            } ,
            "(u64, String)" => Definition::Tuple { elements: vec![ "u64".to_string(), "String".to_string()]},
            "u64" => Definition::Primitive(8),
            "String" => Definition::Sequence {
                length_width: Definition::DEFAULT_LENGTH_WIDTH,
                length_range: Definition::DEFAULT_LENGTH_RANGE,
                elements: "u8".to_string()
            },
            "u8" => Definition::Primitive(1)
        },
        actual_defs
    );
}

#[test]
fn b_tree_set() {
    let actual_name = BTreeSet::<String>::declaration();
    let mut actual_defs = schema_map!();
    BTreeSet::<String>::add_definitions_recursively(&mut actual_defs);
    assert_eq!("BTreeSet<String>", actual_name);
    assert_eq!(
        schema_map! {
            "BTreeSet<String>" => Definition::Sequence {
                length_width: Definition::DEFAULT_LENGTH_WIDTH,
                length_range: Definition::DEFAULT_LENGTH_RANGE,
                elements: "String".to_string(),
            },
            "String" => Definition::Sequence {
                length_width: Definition::DEFAULT_LENGTH_WIDTH,
                length_range: Definition::DEFAULT_LENGTH_RANGE,
                elements: "u8".to_string()
            },
            "u8" => Definition::Primitive(1)
        },
        actual_defs
    );
}

'''
'''--- borsh/tests/schema/test_cells.rs ---
use crate::common_macro::schema_imports::*;

fn common_map_i32() -> BTreeMap<String, Definition> {
    schema_map! {

        "i32" => Definition::Primitive(4)
    }
}

fn common_map_slice_i32() -> BTreeMap<String, Definition> {
    schema_map! {
        "Vec<i32>" => Definition::Sequence {
            length_width: Definition::DEFAULT_LENGTH_WIDTH,
            length_range: Definition::DEFAULT_LENGTH_RANGE,
            elements: "i32".to_string()
        },
        "i32" => Definition::Primitive(4)
    }
}

#[test]
fn test_cell() {
    assert_eq!("i32", <core::cell::Cell<i32> as BorshSchema>::declaration());

    let mut actual_defs = schema_map!();
    <core::cell::Cell<i32> as BorshSchema>::add_definitions_recursively(&mut actual_defs);
    assert_eq!(common_map_i32(), actual_defs);
}

#[test]
fn test_ref_cell_vec() {
    assert_eq!(
        "Vec<i32>",
        <core::cell::RefCell<Vec<i32>> as BorshSchema>::declaration()
    );

    let mut actual_defs = schema_map!();
    <core::cell::RefCell<Vec<i32>> as BorshSchema>::add_definitions_recursively(&mut actual_defs);
    assert_eq!(common_map_slice_i32(), actual_defs);
}

'''
'''--- borsh/tests/schema/test_cow.rs ---
use crate::common_macro::schema_imports::*;

use alloc::borrow::Cow;

#[test]
fn test_cow_str() {
    assert_eq!("String", <Cow<'_, str> as BorshSchema>::declaration());

    let mut actual_defs = schema_map!();
    <Cow<'_, str> as BorshSchema>::add_definitions_recursively(&mut actual_defs);
    assert_eq!(
        schema_map! {
            "String" => Definition::Sequence {
                length_width: Definition::DEFAULT_LENGTH_WIDTH,
                length_range: Definition::DEFAULT_LENGTH_RANGE,
                elements: "u8".to_string()
            },
            "u8" => Definition::Primitive(1)
        },
        actual_defs
    );
}

#[test]
fn test_cow_byte_slice() {
    assert_eq!("Vec<u8>", <Cow<'_, [u8]> as BorshSchema>::declaration());

    let mut actual_defs = schema_map!();
    <Cow<'_, [u8]> as BorshSchema>::add_definitions_recursively(&mut actual_defs);
    assert_eq!(
        schema_map! {
            "Vec<u8>" => Definition::Sequence {
                length_width: Definition::DEFAULT_LENGTH_WIDTH,
                length_range: Definition::DEFAULT_LENGTH_RANGE,
                elements: "u8".to_string(),
            },
            "u8" => Definition::Primitive(1)
        },
        actual_defs
    );
}

#[test]
fn test_cow_slice_of_cow_str() {
    assert_eq!(
        "Vec<String>",
        <Cow<'_, [Cow<'_, str>]> as BorshSchema>::declaration()
    );

    let mut actual_defs = schema_map!();
    <Cow<'_, [Cow<'_, str>]> as BorshSchema>::add_definitions_recursively(&mut actual_defs);
    assert_eq!(
        schema_map! {
            "Vec<String>" => Definition::Sequence {
                length_width: Definition::DEFAULT_LENGTH_WIDTH,
                length_range: Definition::DEFAULT_LENGTH_RANGE,
                elements: "String".to_string(),
            },
            "String" => Definition::Sequence {
                length_width: Definition::DEFAULT_LENGTH_WIDTH,
                length_range: Definition::DEFAULT_LENGTH_RANGE,
                elements: "u8".to_string()
            },
            "u8" => Definition::Primitive(1)
        },
        actual_defs
    );
}

'''
'''--- borsh/tests/schema/test_enum_discriminants.rs ---
use crate::common_macro::schema_imports::*;

#[allow(unused)]
#[derive(BorshSchema)]
#[borsh(use_discriminant = true)]
#[repr(i16)]
enum XY {
    A,
    B = 20,
    C,
    D(u32, u32),
    E = 10,
    F(u64),
}

#[test]
fn test_schema_discriminant_no_unit_type() {
    assert_eq!("XY".to_string(), XY::declaration());
    let mut defs = Default::default();
    XY::add_definitions_recursively(&mut defs);
    assert_eq!(
        schema_map! {
            "XY" => Definition::Enum {
                tag_width: 1,
                variants: vec![
                     (0, "A".to_string(), "XYA".to_string()),
                     (20, "B".to_string(), "XYB".to_string()),
                     (21, "C".to_string(), "XYC".to_string()),
                     (22, "D".to_string(), "XYD".to_string()),
                     (10, "E".to_string(), "XYE".to_string()),
                     (11, "F".to_string(), "XYF".to_string())
                ]
            },
            "XYA" => Definition::Struct{ fields: Fields::Empty },
            "XYB" => Definition::Struct{ fields: Fields::Empty },
            "XYC" => Definition::Struct{ fields: Fields::Empty },
            "XYD" => Definition::Struct{ fields: Fields::UnnamedFields(
                vec!["u32".to_string(), "u32".to_string()]
            )},
            "XYE" => Definition::Struct{ fields: Fields::Empty },
            "XYF" => Definition::Struct{ fields: Fields::UnnamedFields(
                vec!["u64".to_string()]

            )},
            "u32" => Definition::Primitive(4),
            "u64" => Definition::Primitive(8)
        },
        defs
    );
}

#[allow(unused)]
#[derive(BorshSchema)]
#[borsh(use_discriminant = false)]
#[repr(i16)]
enum XYNoDiscriminant {
    A,
    B = 20,
    C,
    D(u32, u32),
    E = 10,
    F(u64),
}

#[test]
fn test_schema_discriminant_no_unit_type_no_use_discriminant() {
    assert_eq!(
        "XYNoDiscriminant".to_string(),
        XYNoDiscriminant::declaration()
    );
    let mut defs = Default::default();
    XYNoDiscriminant::add_definitions_recursively(&mut defs);
    assert_eq!(
        schema_map! {
            "XYNoDiscriminant" => Definition::Enum {
                tag_width: 1,
                variants: vec![
                     (0, "A".to_string(), "XYNoDiscriminantA".to_string()),
                     (1, "B".to_string(), "XYNoDiscriminantB".to_string()),
                     (2, "C".to_string(), "XYNoDiscriminantC".to_string()),
                     (3, "D".to_string(), "XYNoDiscriminantD".to_string()),
                     (4, "E".to_string(), "XYNoDiscriminantE".to_string()),
                     (5, "F".to_string(), "XYNoDiscriminantF".to_string())
                ]
            },
            "XYNoDiscriminantA" => Definition::Struct{ fields: Fields::Empty },
            "XYNoDiscriminantB" => Definition::Struct{ fields: Fields::Empty },
            "XYNoDiscriminantC" => Definition::Struct{ fields: Fields::Empty },
            "XYNoDiscriminantD" => Definition::Struct{ fields: Fields::UnnamedFields(
                vec!["u32".to_string(), "u32".to_string()]
            )},
            "XYNoDiscriminantE" => Definition::Struct{ fields: Fields::Empty },
            "XYNoDiscriminantF" => Definition::Struct{ fields: Fields::UnnamedFields(
                vec!["u64".to_string()]

            )},
            "u32" => Definition::Primitive(4),
            "u64" => Definition::Primitive(8)
        },
        defs
    );
}

'''
'''--- borsh/tests/schema/test_generic_enums.rs ---
use crate::common_macro::schema_imports::*;

#[cfg(feature = "hashbrown")]
use hashbrown::HashMap;
#[cfg(feature = "std")]
use std::collections::HashMap;

#[test]
pub fn complex_enum_generics() {
    #[derive(borsh::BorshSchema)]
    struct Tomatoes;
    #[derive(borsh::BorshSchema)]
    struct Cucumber;
    #[derive(borsh::BorshSchema)]
    struct Oil;
    #[derive(borsh::BorshSchema)]
    struct Wrapper;
    #[derive(borsh::BorshSchema)]
    struct Filling;
    #[allow(unused)]
    #[derive(borsh::BorshSchema)]
    enum A<C, W> {
        Bacon,
        Eggs,
        Salad(Tomatoes, C, Oil),
        Sausage { wrapper: W, filling: Filling },
    }
    assert_eq!(
        "A<Cucumber, Wrapper>".to_string(),
        <A<Cucumber, Wrapper>>::declaration()
    );
    let mut defs = Default::default();
    <A<Cucumber, Wrapper>>::add_definitions_recursively(&mut defs);
    assert_eq!(
        schema_map! {
        "Cucumber" => Definition::Struct {fields: Fields::Empty},
        "ASalad<Cucumber>" => Definition::Struct{
            fields: Fields::UnnamedFields(vec!["Tomatoes".to_string(), "Cucumber".to_string(), "Oil".to_string()])
        },
        "ABacon" => Definition::Struct {fields: Fields::Empty},
        "Oil" => Definition::Struct {fields: Fields::Empty},
        "A<Cucumber, Wrapper>" => Definition::Enum {
            tag_width: 1,
            variants: vec![
                (0, "Bacon".to_string(), "ABacon".to_string()),
                (1, "Eggs".to_string(), "AEggs".to_string()),
                (2, "Salad".to_string(), "ASalad<Cucumber>".to_string()),
                (3, "Sausage".to_string(), "ASausage<Wrapper>".to_string())
            ]
        },
        "Wrapper" => Definition::Struct {fields: Fields::Empty},
        "Tomatoes" => Definition::Struct {fields: Fields::Empty},
        "ASausage<Wrapper>" => Definition::Struct {
            fields: Fields::NamedFields(vec![
            ("wrapper".to_string(), "Wrapper".to_string()),
            ("filling".to_string(), "Filling".to_string())
            ])
        },
        "AEggs" => Definition::Struct {fields: Fields::Empty},
        "Filling" => Definition::Struct {fields: Fields::Empty}
        },
        defs
    );
}

// Checks that recursive definitions work. Also checks that re-instantiations of templated types work.
#[cfg(hash_collections)]
#[test]
pub fn complex_enum_generics2() {
    #[derive(borsh::BorshSchema)]
    struct Tomatoes;
    #[derive(borsh::BorshSchema)]
    struct Cucumber;
    #[allow(unused)]
    #[derive(borsh::BorshSchema)]
    struct Oil<K, V> {
        seeds: HashMap<K, V>,
        liquid: Option<K>,
    }
    #[allow(unused)]
    #[derive(borsh::BorshSchema)]
    struct Wrapper<T> {
        foo: Option<T>,
        bar: Box<A<T, T>>,
    }
    #[derive(borsh::BorshSchema)]
    struct Filling;
    #[allow(unused)]
    #[derive(borsh::BorshSchema)]
    enum A<C, W> {
        Bacon,
        Eggs,
        Salad(Tomatoes, C, Oil<u64, String>),
        Sausage { wrapper: W, filling: Filling },
    }
    assert_eq!(
        "A<Cucumber, Wrapper<String>>".to_string(),
        <A<Cucumber, Wrapper<String>>>::declaration()
    );
    let mut defs = Default::default();
    <A<Cucumber, Wrapper<String>>>::add_definitions_recursively(&mut defs);
    assert_eq!(
        schema_map! {
            "A<Cucumber, Wrapper<String>>" => Definition::Enum {
                tag_width: 1,
                variants: vec![
                    (0, "Bacon".to_string(), "ABacon".to_string()),
                    (1, "Eggs".to_string(), "AEggs".to_string()),
                    (2, "Salad".to_string(), "ASalad<Cucumber>".to_string()),
                    (3, "Sausage".to_string(), "ASausage<Wrapper<String>>".to_string())
                ]
            },
            "A<String, String>" => Definition::Enum {
                tag_width: 1,
                variants: vec![
                    (0, "Bacon".to_string(), "ABacon".to_string()),
                    (1, "Eggs".to_string(), "AEggs".to_string()),
                    (2, "Salad".to_string(), "ASalad<String>".to_string()),
                    (3, "Sausage".to_string(), "ASausage<String>".to_string())
                ]
            },
        "ABacon" => Definition::Struct {fields: Fields::Empty},
        "AEggs" => Definition::Struct {fields: Fields::Empty},
        "ASalad<Cucumber>" => Definition::Struct {fields: Fields::UnnamedFields(vec!["Tomatoes".to_string(), "Cucumber".to_string(), "Oil<u64, String>".to_string()])},
        "ASalad<String>" => Definition::Struct { fields: Fields::UnnamedFields( vec!["Tomatoes".to_string(), "String".to_string(), "Oil<u64, String>".to_string() ])},
        "ASausage<Wrapper<String>>" => Definition::Struct {fields: Fields::NamedFields(vec![("wrapper".to_string(), "Wrapper<String>".to_string()), ("filling".to_string(), "Filling".to_string())])},
        "ASausage<String>" => Definition::Struct{ fields: Fields::NamedFields(vec![("wrapper".to_string(), "String".to_string()), ("filling".to_string(), "Filling".to_string())])},
        "Cucumber" => Definition::Struct {fields: Fields::Empty},
        "Filling" => Definition::Struct {fields: Fields::Empty},
            "HashMap<u64, String>" => Definition::Sequence {
                length_width: Definition::DEFAULT_LENGTH_WIDTH,
                length_range: Definition::DEFAULT_LENGTH_RANGE,
                elements: "(u64, String)".to_string(),
            },
        "Oil<u64, String>" => Definition::Struct { fields: Fields::NamedFields(vec![("seeds".to_string(), "HashMap<u64, String>".to_string()), ("liquid".to_string(), "Option<u64>".to_string())])},
            "Option<String>" => Definition::Enum {
                tag_width: 1,
                variants: vec![
                    (0, "None".to_string(), "()".to_string()),
                    (1, "Some".to_string(), "String".to_string())
                ]
            },
            "Option<u64>" => Definition::Enum {
                tag_width: 1,
                variants: vec![
                    (0, "None".to_string(), "()".to_string()),
                    (1, "Some".to_string(), "u64".to_string())
                ]
            },
        "Tomatoes" => Definition::Struct {fields: Fields::Empty},
        "(u64, String)" => Definition::Tuple {elements: vec!["u64".to_string(), "String".to_string()]},
        "Wrapper<String>" => Definition::Struct{ fields: Fields::NamedFields(vec![("foo".to_string(), "Option<String>".to_string()), ("bar".to_string(), "A<String, String>".to_string())])},
        "u64" => Definition::Primitive(8),
        "()" => Definition::Primitive(0),
        "String" => Definition::Sequence {
            length_width: Definition::DEFAULT_LENGTH_WIDTH,
            length_range: Definition::DEFAULT_LENGTH_RANGE,
            elements: "u8".to_string()
        },
        "u8" => Definition::Primitive(1)
        },
        defs
    );
}

fn common_map_associated() -> BTreeMap<String, Definition> {
    schema_map! {
        "EnumParametrized<String, u32, i8, u16>" => Definition::Enum {
            tag_width: 1,
            variants: vec![
                (0, "B".to_string(), "EnumParametrizedB<u32, i8, u16>".to_string()),
                (1, "C".to_string(), "EnumParametrizedC<String>".to_string())
            ]
        },
        "EnumParametrizedB<u32, i8, u16>" => Definition::Struct { fields: Fields::NamedFields(vec![
            ("x".to_string(), "BTreeMap<u32, u16>".to_string()),
            ("y".to_string(), "String".to_string()),
            ("z".to_string(), "i8".to_string())
        ])},
        "EnumParametrizedC<String>" => Definition::Struct{ fields: Fields::UnnamedFields(vec!["String".to_string(), "u16".to_string()])},
        "BTreeMap<u32, u16>" => Definition::Sequence {
            length_width: Definition::DEFAULT_LENGTH_WIDTH,
            length_range: Definition::DEFAULT_LENGTH_RANGE,
            elements: "(u32, u16)".to_string(),
        },
        "(u32, u16)" => Definition::Tuple { elements: vec!["u32".to_string(), "u16".to_string()]},
        "u32" => Definition::Primitive(4),
        "i8" => Definition::Primitive(1),
        "u16" => Definition::Primitive(2),
        "String" => Definition::Sequence {
            length_width: Definition::DEFAULT_LENGTH_WIDTH,
            length_range: Definition::DEFAULT_LENGTH_RANGE,
            elements: "u8".to_string()
        },
        "u8" => Definition::Primitive(1)
    }
}

#[test]
pub fn generic_associated_item1() {
    trait TraitName {
        type Associated;
        fn method(&self);
    }

    impl TraitName for u32 {
        type Associated = i8;
        fn method(&self) {}
    }

    #[allow(unused)]
    #[derive(borsh::BorshSchema)]
    enum EnumParametrized<T, K, V>
    where
        K: TraitName,
        K: core::cmp::Ord,
        V: core::cmp::Ord,
    {
        B {
            x: BTreeMap<K, V>,
            y: String,
            z: K::Associated,
        },
        C(T, u16),
    }

    assert_eq!(
        "EnumParametrized<String, u32, i8, u16>".to_string(),
        <EnumParametrized<String, u32, u16>>::declaration()
    );

    let mut defs = Default::default();
    <EnumParametrized<String, u32, u16>>::add_definitions_recursively(&mut defs);
    assert_eq!(common_map_associated(), defs);
}

#[test]
pub fn generic_associated_item2() {
    trait TraitName {
        type Associated;
        fn method(&self);
    }

    impl TraitName for u32 {
        type Associated = i8;
        fn method(&self) {}
    }

    #[allow(unused)]
    #[derive(borsh::BorshSchema)]
    enum EnumParametrized<T, K, V>
    where
        K: TraitName,
        K: core::cmp::Ord,
        V: core::cmp::Ord,
    {
        B {
            x: BTreeMap<K, V>,
            y: String,
            #[borsh(schema(params = "K => <K as TraitName>::Associated"))]
            z: <K as TraitName>::Associated,
        },
        C(T, u16),
    }

    assert_eq!(
        "EnumParametrized<String, u32, i8, u16>".to_string(),
        <EnumParametrized<String, u32, u16>>::declaration()
    );

    let mut defs = Default::default();
    <EnumParametrized<String, u32, u16>>::add_definitions_recursively(&mut defs);

    assert_eq!(common_map_associated(), defs);
}

'''
'''--- borsh/tests/schema/test_generic_structs.rs ---
use crate::common_macro::schema_imports::*;

#[cfg(feature = "hashbrown")]
use hashbrown::HashMap;

#[cfg(feature = "std")]
use std::collections::HashMap;

#[test]
pub fn wrapper_struct() {
    #[derive(borsh::BorshSchema)]
    struct A<T>(T);
    assert_eq!("A<u64>".to_string(), <A<u64>>::declaration());
    let mut defs = Default::default();
    <A<u64>>::add_definitions_recursively(&mut defs);
    assert_eq!(
        schema_map! {
        "A<u64>" => Definition::Struct {fields: Fields::UnnamedFields(vec!["u64".to_string()])},
        "u64" => Definition::Primitive(8)
        },
        defs
    );
}

#[test]
pub fn tuple_struct_params() {
    #[derive(borsh::BorshSchema)]
    struct A<K, V>(K, V);
    assert_eq!(
        "A<u64, String>".to_string(),
        <A<u64, String>>::declaration()
    );
    let mut defs = Default::default();
    <A<u64, String>>::add_definitions_recursively(&mut defs);
    assert_eq!(
        schema_map! {
        "A<u64, String>" => Definition::Struct { fields: Fields::UnnamedFields(vec![
            "u64".to_string(), "String".to_string()
        ])},
        "u64" => Definition::Primitive(8),
        "String" => Definition::Sequence {
            length_width: Definition::DEFAULT_LENGTH_WIDTH,
            length_range: Definition::DEFAULT_LENGTH_RANGE,
            elements: "u8".to_string()
        },
        "u8" => Definition::Primitive(1)
        },
        defs
    );
}

#[cfg(hash_collections)]
#[test]
pub fn simple_generics() {
    #[derive(borsh::BorshSchema)]
    struct A<K, V> {
        _f1: HashMap<K, V>,
        _f2: String,
    }
    assert_eq!(
        "A<u64, String>".to_string(),
        <A<u64, String>>::declaration()
    );
    let mut defs = Default::default();
    <A<u64, String>>::add_definitions_recursively(&mut defs);
    assert_eq!(
        schema_map! {
        "A<u64, String>" => Definition::Struct {
        fields: Fields::NamedFields(vec![
        ("_f1".to_string(), "HashMap<u64, String>".to_string()),
        ("_f2".to_string(), "String".to_string())
        ])
        },
            "HashMap<u64, String>" => Definition::Sequence {
                length_width: Definition::DEFAULT_LENGTH_WIDTH,
                length_range: Definition::DEFAULT_LENGTH_RANGE,
                elements: "(u64, String)".to_string(),
            },
        "(u64, String)" => Definition::Tuple{elements: vec!["u64".to_string(), "String".to_string()]},
        "u64" => Definition::Primitive(8),
        "String" => Definition::Sequence {
            length_width: Definition::DEFAULT_LENGTH_WIDTH,
            length_range: Definition::DEFAULT_LENGTH_RANGE,
            elements: "u8".to_string()
        },
        "u8" => Definition::Primitive(1)
        },
        defs
    );
}

fn common_map_associated() -> BTreeMap<String, Definition> {
    schema_map! {

        "Parametrized<String, i8>" => Definition::Struct {
            fields: Fields::NamedFields(vec![
                ("field".to_string(), "i8".to_string()),
                ("another".to_string(), "String".to_string())
            ])
        },
        "i8" => Definition::Primitive(1),
        "String" => Definition::Sequence {
            length_width: Definition::DEFAULT_LENGTH_WIDTH,
            length_range: Definition::DEFAULT_LENGTH_RANGE,
            elements: "u8".to_string()
        },
        "u8" => Definition::Primitive(1)
    }
}

#[test]
pub fn generic_associated_item() {
    trait TraitName {
        type Associated;
        fn method(&self);
    }

    impl TraitName for u32 {
        type Associated = i8;
        fn method(&self) {}
    }

    #[allow(unused)]
    #[derive(borsh::BorshSchema)]
    struct Parametrized<V, T>
    where
        T: TraitName,
    {
        field: T::Associated,
        another: V,
    }

    assert_eq!(
        "Parametrized<String, i8>".to_string(),
        <Parametrized<String, u32>>::declaration()
    );

    let mut defs = Default::default();
    <Parametrized<String, u32>>::add_definitions_recursively(&mut defs);
    assert_eq!(common_map_associated(), defs);
}

#[test]
pub fn generic_associated_item2() {
    trait TraitName {
        type Associated;
        fn method(&self);
    }

    impl TraitName for u32 {
        type Associated = i8;
        fn method(&self) {}
    }

    #[allow(unused)]
    #[derive(borsh::BorshSchema)]
    struct Parametrized<V, T>
    where
        T: TraitName,
    {
        #[borsh(schema(params = "T => <T as TraitName>::Associated"))]
        field: <T as TraitName>::Associated,
        another: V,
    }

    assert_eq!(
        "Parametrized<String, i8>".to_string(),
        <Parametrized<String, u32>>::declaration()
    );

    let mut defs = Default::default();
    <Parametrized<String, u32>>::add_definitions_recursively(&mut defs);
    assert_eq!(common_map_associated(), defs);
}

#[test]
pub fn generic_associated_item3() {
    trait TraitName {
        type Associated;
        fn method(&self);
    }

    impl TraitName for u32 {
        type Associated = i8;
        fn method(&self) {}
    }

    #[allow(unused)]
    #[derive(borsh::BorshSchema)]
    struct Parametrized<V, T>
    where
        T: TraitName,
    {
        #[borsh(schema(params = "T => T, T => <T as TraitName>::Associated"))]
        field: (<T as TraitName>::Associated, T),
        another: V,
    }

    assert_eq!(
        "Parametrized<String, u32, i8>".to_string(),
        <Parametrized<String, u32>>::declaration()
    );

    let mut defs = Default::default();
    <Parametrized<String, u32>>::add_definitions_recursively(&mut defs);
    assert_eq!(
        schema_map! {
            "Parametrized<String, u32, i8>" => Definition::Struct {
                fields: Fields::NamedFields(vec![
                    ("field".to_string(), "(i8, u32)".to_string()),
                    ("another".to_string(), "String".to_string())
                ])
            },
            "(i8, u32)" => Definition::Tuple {
                elements: vec!["i8".to_string(), "u32".to_string()]
            },
            "i8" => Definition::Primitive(1),
            "u32" => Definition::Primitive(4),
            "String" => Definition::Sequence {
                length_width: Definition::DEFAULT_LENGTH_WIDTH,
                length_range: Definition::DEFAULT_LENGTH_RANGE,
                elements: "u8".to_string()
            },
            "u8" => Definition::Primitive(1)
        },
        defs
    );
}

'''
'''--- borsh/tests/schema/test_hash_map.rs ---
use crate::common_macro::schema_imports::*;

#[cfg(feature = "hashbrown")]
use hashbrown::{HashMap, HashSet};
#[cfg(feature = "std")]
use std::collections::{HashMap, HashSet};

#[test]
fn simple_map() {
    let actual_name = HashMap::<u64, String>::declaration();
    let mut actual_defs = schema_map!();
    HashMap::<u64, String>::add_definitions_recursively(&mut actual_defs);
    assert_eq!("HashMap<u64, String>", actual_name);
    assert_eq!(
        schema_map! {
            "HashMap<u64, String>" => Definition::Sequence {
                length_width: Definition::DEFAULT_LENGTH_WIDTH,
                length_range: Definition::DEFAULT_LENGTH_RANGE,
                elements: "(u64, String)".to_string(),
            } ,
            "(u64, String)" => Definition::Tuple {
                elements: vec![ "u64".to_string(), "String".to_string()],
            },
            "u64" => Definition::Primitive(8),
            "String" => Definition::Sequence {
                length_width: Definition::DEFAULT_LENGTH_WIDTH,
                length_range: Definition::DEFAULT_LENGTH_RANGE,
                elements: "u8".to_string()
            },
            "u8" => Definition::Primitive(1)

        },
        actual_defs
    );
}

#[test]
fn simple_set() {
    let actual_name = HashSet::<String>::declaration();
    let mut actual_defs = schema_map!();
    HashSet::<String>::add_definitions_recursively(&mut actual_defs);
    assert_eq!("HashSet<String>", actual_name);
    assert_eq!(
        schema_map! {
            "HashSet<String>" => Definition::Sequence {
                length_width: Definition::DEFAULT_LENGTH_WIDTH,
                length_range: Definition::DEFAULT_LENGTH_RANGE,
                elements: "String".to_string(),
            },
            "String" => Definition::Sequence {
                length_width: Definition::DEFAULT_LENGTH_WIDTH,
                length_range: Definition::DEFAULT_LENGTH_RANGE,
                elements: "u8".to_string()
            },
            "u8" => Definition::Primitive(1)
        },
        actual_defs
    );
}

'''
'''--- borsh/tests/schema/test_option.rs ---
use crate::common_macro::schema_imports::*;

#[test]
fn simple_option() {
    let actual_name = Option::<u64>::declaration();
    let mut actual_defs = schema_map!();
    Option::<u64>::add_definitions_recursively(&mut actual_defs);
    assert_eq!("Option<u64>", actual_name);
    assert_eq!(
        schema_map! {
            "Option<u64>" => Definition::Enum {
                tag_width: 1,
                variants: vec![
                    (0, "None".to_string(), "()".to_string()),
                    (1, "Some".to_string(), "u64".to_string()),
                ]
            },
            "u64" => Definition::Primitive(8),
            "()" => Definition::Primitive(0)
        },
        actual_defs
    );
}

#[test]
fn nested_option() {
    let actual_name = Option::<Option<u64>>::declaration();
    let mut actual_defs = schema_map!();
    Option::<Option<u64>>::add_definitions_recursively(&mut actual_defs);
    assert_eq!("Option<Option<u64>>", actual_name);
    assert_eq!(
        schema_map! {
            "Option<u64>" => Definition::Enum {
                tag_width: 1,
                variants: vec![
                    (0, "None".to_string(), "()".to_string()),
                    (1, "Some".to_string(), "u64".to_string()),
                ]
            },
            "Option<Option<u64>>" => Definition::Enum {
                tag_width: 1,
                variants: vec![
                    (0, "None".to_string(), "()".to_string()),
                    (1, "Some".to_string(), "Option<u64>".to_string()),
                ]
            },
            "u64" => Definition::Primitive(8),
            "()" => Definition::Primitive(0)
        },
        actual_defs
    );
}

'''
'''--- borsh/tests/schema/test_phantom_data.rs ---
use crate::common_macro::schema_imports::*;

use core::marker::PhantomData;

#[test]
fn phantom_data_schema() {
    let phantom_declaration = PhantomData::<String>::declaration();
    assert_eq!("()", phantom_declaration);
    let phantom_declaration = PhantomData::<Vec<u8>>::declaration();
    assert_eq!("()", phantom_declaration);
}

#[test]
pub fn generic_struct_with_phantom_data_derived() {
    #[allow(unused)]
    #[derive(borsh::BorshSchema)]
    struct Parametrized<K, V> {
        field: K,
        another: PhantomData<V>,
    }

    assert_eq!(
        "Parametrized<String>".to_string(),
        <Parametrized<String, u32>>::declaration()
    );

    let mut defs = Default::default();
    <Parametrized<String, u32>>::add_definitions_recursively(&mut defs);
    assert_eq!(
        schema_map! {
            "Parametrized<String>" => Definition::Struct {
                fields: Fields::NamedFields(vec![
                    ("field".to_string(), "String".to_string()),
                    ("another".to_string(), "()".to_string())
                ])
            },
            "()" => Definition::Primitive(0),
            "String" => Definition::Sequence {
                length_width: Definition::DEFAULT_LENGTH_WIDTH,
                length_range: Definition::DEFAULT_LENGTH_RANGE,
                elements: "u8".to_string()
            },
            "u8" => Definition::Primitive(1)
        },
        defs
    );
}

'''
'''--- borsh/tests/schema/test_primitives.rs ---
use crate::common_macro::schema_imports::*;

#[test]
fn isize_schema() {
    let schema = schema_container_of::<isize>();

    assert_eq!(
        schema,
        BorshSchemaContainer::new(
            "i64".to_string(),
            schema_map! {
                "i64" => Definition::Primitive(8)

            }
        )
    )
}

#[test]
fn usize_schema() {
    let schema = schema_container_of::<usize>();

    assert_eq!(
        schema,
        BorshSchemaContainer::new(
            "u64".to_string(),
            schema_map! {
                "u64" => Definition::Primitive(8)

            }
        )
    )
}

'''
'''--- borsh/tests/schema/test_range.rs ---
use crate::common_macro::schema_imports::*;

#[test]
fn range() {
    assert_eq!("RangeFull", <core::ops::RangeFull>::declaration());
    let mut actual_defs = schema_map!();
    <core::ops::RangeFull>::add_definitions_recursively(&mut actual_defs);
    assert_eq!(
        schema_map! {
            "RangeFull" => Definition::Struct {
                fields: Fields::Empty
            }
        },
        actual_defs
    );

    let actual_name = <core::ops::Range<u64>>::declaration();
    let mut actual_defs = schema_map!();
    <core::ops::Range<u64>>::add_definitions_recursively(&mut actual_defs);
    assert_eq!("Range<u64>", actual_name);
    assert_eq!(
        schema_map! {
            "Range<u64>" => Definition::Struct {
                fields: Fields::NamedFields(vec![
                    ("start".into(), "u64".into()),
                    ("end".into(), "u64".into()),
                ])
            },
            "u64" => Definition::Primitive(8)
        },
        actual_defs
    );

    let actual_name = <core::ops::RangeTo<u64>>::declaration();
    let mut actual_defs = schema_map!();
    <core::ops::RangeTo<u64>>::add_definitions_recursively(&mut actual_defs);
    assert_eq!("RangeTo<u64>", actual_name);
    assert_eq!(
        schema_map! {
            "RangeTo<u64>" => Definition::Struct {
                fields: Fields::NamedFields(vec![
                    ("end".into(), "u64".into()),
                ])
            },
            "u64" => Definition::Primitive(8)
        },
        actual_defs
    );
}

'''
'''--- borsh/tests/schema/test_rc.rs ---
use crate::common_macro::schema_imports::*;
use alloc::{rc, sync};

fn common_map_i32() -> BTreeMap<String, Definition> {
    schema_map! {

        "i32" => Definition::Primitive(4)
    }
}

fn common_map_slice_i32() -> BTreeMap<String, Definition> {
    schema_map! {
        "Vec<i32>" => Definition::Sequence {
            length_width: Definition::DEFAULT_LENGTH_WIDTH,
            length_range: Definition::DEFAULT_LENGTH_RANGE,
            elements: "i32".to_string()
        },
        "i32" => Definition::Primitive(4)
    }
}

#[test]
fn test_rc() {
    assert_eq!("i32", <rc::Rc<i32> as BorshSchema>::declaration());

    let mut actual_defs = schema_map!();
    <rc::Rc<i32> as BorshSchema>::add_definitions_recursively(&mut actual_defs);
    assert_eq!(common_map_i32(), actual_defs);
}

#[test]
fn test_slice_rc() {
    assert_eq!("Vec<i32>", <rc::Rc<[i32]> as BorshSchema>::declaration());
    let mut actual_defs = schema_map!();
    <rc::Rc<[i32]> as BorshSchema>::add_definitions_recursively(&mut actual_defs);
    assert_eq!(common_map_slice_i32(), actual_defs);
}

#[test]
fn test_arc() {
    assert_eq!("i32", <sync::Arc<i32> as BorshSchema>::declaration());
    let mut actual_defs = schema_map!();
    <sync::Arc<i32> as BorshSchema>::add_definitions_recursively(&mut actual_defs);
    assert_eq!(common_map_i32(), actual_defs);
}

#[test]
fn test_slice_arc() {
    assert_eq!("Vec<i32>", <sync::Arc<[i32]> as BorshSchema>::declaration());
    let mut actual_defs = schema_map!();
    <sync::Arc<[i32]> as BorshSchema>::add_definitions_recursively(&mut actual_defs);
    assert_eq!(common_map_slice_i32(), actual_defs);
}

'''
'''--- borsh/tests/schema/test_recursive_enums.rs ---
use crate::common_macro::schema_imports::*;

#[allow(unused)]
#[derive(borsh::BorshSchema)]
enum ERecD {
    B { x: String, y: i32 },
    C(u8, Vec<ERecD>),
}

#[test]
pub fn recursive_enum_schema() {
    let mut defs = Default::default();
    ERecD::add_definitions_recursively(&mut defs);
    assert_eq!(
        schema_map! {
           "ERecD" => Definition::Enum {
                tag_width: 1,
                variants: vec![
                    (0, "B".to_string(), "ERecDB".to_string()),
                    (1, "C".to_string(), "ERecDC".to_string()),
                ]
            },
            "ERecDB" => Definition::Struct {
                fields: Fields::NamedFields (
                    vec![
                        ("x".to_string(), "String".to_string()),
                        ("y".to_string(), "i32".to_string()),
                    ]
                )
            },
            "ERecDC" => Definition::Struct {
                fields: Fields::UnnamedFields( vec![
                    "u8".to_string(),
                    "Vec<ERecD>".to_string(),
                ])
            },
            "Vec<ERecD>" => Definition::Sequence {
                length_width: Definition::DEFAULT_LENGTH_WIDTH,
                length_range: Definition::DEFAULT_LENGTH_RANGE,
                elements: "ERecD".to_string(),
            },
            "i32" => Definition::Primitive(4),
            "String" => Definition::Sequence {
                length_width: Definition::DEFAULT_LENGTH_WIDTH,
                length_range: Definition::DEFAULT_LENGTH_RANGE,
                elements: "u8".to_string()
            },
            "u8" => Definition::Primitive(1)
        },
        defs
    );
}

'''
'''--- borsh/tests/schema/test_recursive_structs.rs ---
use crate::common_macro::schema_imports::*;

#[allow(unused)]
#[derive(borsh::BorshSchema)]
struct CRecC {
    a: String,
    b: BTreeMap<String, CRecC>,
}

#[test]
pub fn recursive_struct_schema() {
    let mut defs = Default::default();
    CRecC::add_definitions_recursively(&mut defs);
    assert_eq!(
        schema_map! {
           "CRecC" => Definition::Struct {
                fields: Fields::NamedFields(
                    vec![
                        (
                            "a".to_string(),
                            "String".to_string(),
                        ),
                        (
                            "b".to_string(),
                            "BTreeMap<String, CRecC>".to_string(),
                        ),
                    ]

                )

            },
            "BTreeMap<String, CRecC>" => Definition::Sequence {
                length_width: Definition::DEFAULT_LENGTH_WIDTH,
                length_range: Definition::DEFAULT_LENGTH_RANGE,
                elements: "(String, CRecC)".to_string(),
            },
            "(String, CRecC)" => Definition::Tuple {elements: vec!["String".to_string(), "CRecC".to_string()]},
            "String" => Definition::Sequence {
                length_width: Definition::DEFAULT_LENGTH_WIDTH,
                length_range: Definition::DEFAULT_LENGTH_RANGE,
                elements: "u8".to_string()
            },
            "u8" => Definition::Primitive(1)
        },
        defs
    );
}

'''
'''--- borsh/tests/schema/test_schema_with_third_party.rs ---
use crate::common_macro::schema_imports::*;

// use alloc::collections::BTreeMap;

#[allow(unused)]
struct ThirdParty<K, V>(BTreeMap<K, V>);
#[allow(unused)]
mod third_party_impl {
    use crate::common_macro::schema_imports::*;

    pub(super) fn declaration<K: borsh::BorshSchema, V: borsh::BorshSchema>(
    ) -> borsh::schema::Declaration {
        let params = vec![<K>::declaration(), <V>::declaration()];
        format!(r#"{}<{}>"#, "ThirdParty", params.join(", "))
    }

    pub(super) fn add_definitions_recursively<K: borsh::BorshSchema, V: borsh::BorshSchema>(
        definitions: &mut BTreeMap<borsh::schema::Declaration, borsh::schema::Definition>,
    ) {
        let fields = borsh::schema::Fields::UnnamedFields(vec![
            <BTreeMap<K, V> as borsh::BorshSchema>::declaration(),
        ]);
        let definition = borsh::schema::Definition::Struct { fields };
        let no_recursion_flag = definitions.get(&declaration::<K, V>()).is_none();
        borsh::schema::add_definition(declaration::<K, V>(), definition, definitions);
        if no_recursion_flag {
            <BTreeMap<K, V> as borsh::BorshSchema>::add_definitions_recursively(definitions);
        }
    }
}

#[allow(unused)]
#[derive(BorshSchema)]
struct A<K, V> {
    #[borsh(schema(with_funcs(
        declaration = "third_party_impl::declaration::<K, V>",
        definitions = "third_party_impl::add_definitions_recursively::<K, V>"
    )))]
    x: ThirdParty<K, V>,
    y: u64,
}

#[allow(unused)]
#[derive(BorshSchema)]
enum C<K, V> {
    C3(u64, u64),
    C4(
        u64,
        #[borsh(schema(with_funcs(
            declaration = "third_party_impl::declaration::<K, V>",
            definitions = "third_party_impl::add_definitions_recursively::<K, V>"
        )))]
        ThirdParty<K, V>,
    ),
}

#[test]
pub fn struct_overriden() {
    assert_eq!(
        "A<u64, String>".to_string(),
        <A<u64, String>>::declaration()
    );
    let mut defs = Default::default();
    <A<u64, String>>::add_definitions_recursively(&mut defs);
    assert_eq!(
        schema_map! {
            "A<u64, String>" => Definition::Struct { fields: Fields::NamedFields(vec![
                ("x".to_string(), "ThirdParty<u64, String>".to_string()),
                ("y".to_string(), "u64".to_string())]
            )},
            "ThirdParty<u64, String>" => Definition::Struct { fields: Fields::UnnamedFields(vec![
                "BTreeMap<u64, String>".to_string(),
            ]) },
            "BTreeMap<u64, String>"=> Definition::Sequence {
                length_width: Definition::DEFAULT_LENGTH_WIDTH,
                length_range: Definition::DEFAULT_LENGTH_RANGE,
                elements: "(u64, String)".to_string(),
            },
            "(u64, String)" => Definition::Tuple { elements: vec!["u64".to_string(), "String".to_string()]},
            "u64" => Definition::Primitive(8),
            "String" => Definition::Sequence {
                length_width: Definition::DEFAULT_LENGTH_WIDTH,
                length_range: Definition::DEFAULT_LENGTH_RANGE,
                elements: "u8".to_string()
            },
            "u8" => Definition::Primitive(1)
        },
        defs
    );
}

#[test]
pub fn enum_overriden() {
    assert_eq!(
        "C<u64, String>".to_string(),
        <C<u64, String>>::declaration()
    );
    let mut defs = Default::default();
    <C<u64, String>>::add_definitions_recursively(&mut defs);
    assert_eq!(
        schema_map! {
            "C<u64, String>" => Definition::Enum {
                tag_width: 1,
                variants: vec![
                    (0, "C3".to_string(), "CC3".to_string()),
                    (1, "C4".to_string(), "CC4<u64, String>".to_string())
                ]
            },
            "CC3" => Definition::Struct { fields: Fields::UnnamedFields(vec!["u64".to_string(), "u64".to_string()]) },
            "CC4<u64, String>" => Definition::Struct { fields: Fields::UnnamedFields(vec![
                "u64".to_string(), "ThirdParty<u64, String>".to_string()
            ]) },
            "ThirdParty<u64, String>" => Definition::Struct { fields: Fields::UnnamedFields(vec![
                "BTreeMap<u64, String>".to_string(),
            ]) },
            "BTreeMap<u64, String>"=> Definition::Sequence {
                length_width: Definition::DEFAULT_LENGTH_WIDTH,
                length_range: Definition::DEFAULT_LENGTH_RANGE,
                elements: "(u64, String)".to_string(),
            },
            "(u64, String)" => Definition::Tuple { elements: vec!["u64".to_string(), "String".to_string()]},
            "u64" => Definition::Primitive(8),
            "String" => Definition::Sequence {
                length_width: Definition::DEFAULT_LENGTH_WIDTH,
                length_range: Definition::DEFAULT_LENGTH_RANGE,
                elements: "u8".to_string()
            },
            "u8" => Definition::Primitive(1)
        },
        defs
    );
}

'''
'''--- borsh/tests/schema/test_simple_enums.rs ---
use crate::common_macro::schema_imports::*;

use borsh::{try_from_slice_with_schema, try_to_vec_with_schema};

#[test]
pub fn simple_enum() {
    #[allow(dead_code)]
    #[derive(borsh::BorshSchema)]
    enum A {
        Bacon,
        Eggs,
    }
    // https://github.com/near/borsh-rs/issues/112
    #[allow(unused)]
    impl A {
        pub fn declaration() -> usize {
            42
        }
    }
    assert_eq!("A".to_string(), <A as borsh::BorshSchema>::declaration());
    let mut defs = Default::default();
    A::add_definitions_recursively(&mut defs);
    assert_eq!(
        schema_map! {
        "ABacon" => Definition::Struct{ fields: Fields::Empty },
        "AEggs" => Definition::Struct{ fields: Fields::Empty },
            "A" => Definition::Enum {
                tag_width: 1,
                variants: vec![(0, "Bacon".to_string(), "ABacon".to_string()), (1, "Eggs".to_string(), "AEggs".to_string())]
            }
        },
        defs
    );
}

#[test]
pub fn single_field_enum() {
    #[allow(dead_code)]
    #[derive(borsh::BorshSchema)]
    enum A {
        Bacon,
    }
    assert_eq!("A".to_string(), A::declaration());
    let mut defs = Default::default();
    A::add_definitions_recursively(&mut defs);
    assert_eq!(
        schema_map! {
            "ABacon" => Definition::Struct {fields: Fields::Empty},
            "A" => Definition::Enum {
                tag_width: 1,
                variants: vec![(0, "Bacon".to_string(), "ABacon".to_string())]
            }
        },
        defs
    );
}

#[test]
pub fn complex_enum_with_schema() {
    #[derive(
        borsh::BorshSchema,
        Default,
        borsh::BorshSerialize,
        borsh::BorshDeserialize,
        PartialEq,
        Debug,
    )]
    struct Tomatoes;
    #[derive(
        borsh::BorshSchema,
        Default,
        borsh::BorshSerialize,
        borsh::BorshDeserialize,
        PartialEq,
        Debug,
    )]
    struct Cucumber;
    #[derive(
        borsh::BorshSchema,
        Default,
        borsh::BorshSerialize,
        borsh::BorshDeserialize,
        PartialEq,
        Debug,
    )]
    struct Oil;
    #[derive(
        borsh::BorshSchema,
        Default,
        borsh::BorshSerialize,
        borsh::BorshDeserialize,
        PartialEq,
        Debug,
    )]
    struct Wrapper;
    #[derive(
        borsh::BorshSchema,
        Default,
        borsh::BorshSerialize,
        borsh::BorshDeserialize,
        PartialEq,
        Debug,
    )]
    struct Filling;
    #[derive(
        borsh::BorshSchema, borsh::BorshSerialize, borsh::BorshDeserialize, PartialEq, Debug,
    )]
    enum A {
        Bacon,
        Eggs,
        Salad(Tomatoes, Cucumber, Oil),
        Sausage { wrapper: Wrapper, filling: Filling },
    }

    impl Default for A {
        fn default() -> Self {
            A::Sausage {
                wrapper: Default::default(),
                filling: Default::default(),
            }
        }
    }
    // First check schema.
    assert_eq!("A".to_string(), A::declaration());
    let mut defs = Default::default();
    A::add_definitions_recursively(&mut defs);
    assert_eq!(
        schema_map! {
        "Cucumber" => Definition::Struct {fields: Fields::Empty},
        "ASalad" => Definition::Struct{ fields: Fields::UnnamedFields(vec!["Tomatoes".to_string(), "Cucumber".to_string(), "Oil".to_string()])},
        "ABacon" => Definition::Struct {fields: Fields::Empty},
        "Oil" => Definition::Struct {fields: Fields::Empty},
            "A" => Definition::Enum {
                tag_width: 1,
                variants: vec![
                    (0, "Bacon".to_string(), "ABacon".to_string()),
                    (1, "Eggs".to_string(), "AEggs".to_string()),
                    (2, "Salad".to_string(), "ASalad".to_string()),
                    (3, "Sausage".to_string(), "ASausage".to_string())
                ]
            },
        "Wrapper" => Definition::Struct {fields: Fields::Empty},
        "Tomatoes" => Definition::Struct {fields: Fields::Empty},
        "ASausage" => Definition::Struct { fields: Fields::NamedFields(vec![
        ("wrapper".to_string(), "Wrapper".to_string()),
        ("filling".to_string(), "Filling".to_string())
        ])},
        "AEggs" => Definition::Struct {fields: Fields::Empty},
        "Filling" => Definition::Struct {fields: Fields::Empty}
        },
        defs
    );
    // Then check that we serialize and deserialize with schema.
    let obj = A::default();
    let data = try_to_vec_with_schema(&obj).unwrap();
    #[cfg(feature = "std")]
    insta::assert_debug_snapshot!(data);
    let obj2: A = try_from_slice_with_schema(&data).unwrap();
    assert_eq!(obj, obj2);
}

'''
'''--- borsh/tests/schema/test_simple_structs.rs ---
use crate::common_macro::schema_imports::*;

#[test]
pub fn unit_struct() {
    #[derive(borsh::BorshSchema)]
    struct A;

    // https://github.com/near/borsh-rs/issues/112
    #[allow(unused)]
    impl A {
        pub fn declaration() -> usize {
            42
        }
    }
    assert_eq!("A".to_string(), <A as borsh::BorshSchema>::declaration());
    let mut defs = Default::default();
    A::add_definitions_recursively(&mut defs);
    assert_eq!(
        schema_map! {
        "A" => Definition::Struct {fields: Fields::Empty}
        },
        defs
    );
}

#[test]
pub fn simple_struct() {
    #[derive(borsh::BorshSchema)]
    struct A {
        _f1: u64,
        _f2: String,
    }
    assert_eq!("A".to_string(), A::declaration());
    let mut defs = Default::default();
    A::add_definitions_recursively(&mut defs);
    assert_eq!(
        schema_map! {
        "A" => Definition::Struct{ fields: Fields::NamedFields(vec![
        ("_f1".to_string(), "u64".to_string()),
        ("_f2".to_string(), "String".to_string())
        ])},
        "u64" => Definition::Primitive(8),
        "String" => Definition::Sequence {
            length_width: Definition::DEFAULT_LENGTH_WIDTH,
            length_range: Definition::DEFAULT_LENGTH_RANGE,
            elements: "u8".to_string()
        },
        "u8" => Definition::Primitive(1)
        },
        defs
    );
}

#[test]
pub fn tuple_struct() {
    #[derive(borsh::BorshSchema)]
    #[allow(unused)]
    struct A(u64, String);
    assert_eq!("A".to_string(), A::declaration());
    let mut defs = Default::default();
    A::add_definitions_recursively(&mut defs);
    assert_eq!(
        schema_map! {
        "A" => Definition::Struct {fields: Fields::UnnamedFields(vec![
         "u64".to_string(), "String".to_string()
        ])},
        "u64" => Definition::Primitive(8),
        "String" => Definition::Sequence {
            length_width: Definition::DEFAULT_LENGTH_WIDTH,
            length_range: Definition::DEFAULT_LENGTH_RANGE,
            elements: "u8".to_string()
        },
        "u8" => Definition::Primitive(1)
        },
        defs
    );
}

#[test]
pub fn boxed() {
    #[derive(borsh::BorshSchema)]
    struct A {
        _f1: Box<u64>,
        _f2: Box<str>,
        _f3: Box<[u8]>,
    }
    assert_eq!("A".to_string(), A::declaration());
    let mut defs = Default::default();
    A::add_definitions_recursively(&mut defs);
    assert_eq!(
        schema_map! {
            "Vec<u8>" => Definition::Sequence {
                length_width: Definition::DEFAULT_LENGTH_WIDTH,
                length_range: Definition::DEFAULT_LENGTH_RANGE,
                elements: "u8".to_string(),
            },
        "A" => Definition::Struct{ fields: Fields::NamedFields(vec![
        ("_f1".to_string(), "u64".to_string()),
        ("_f2".to_string(), "String".to_string()),
        ("_f3".to_string(), "Vec<u8>".to_string())
        ])},
        "u64" => Definition::Primitive(8),
        "u8" => Definition::Primitive(1),
        "String" => Definition::Sequence {
            length_width: Definition::DEFAULT_LENGTH_WIDTH,
            length_range: Definition::DEFAULT_LENGTH_RANGE,
            elements: "u8".to_string()
        }
        },
        defs
    );
}

'''
'''--- borsh/tests/schema/test_strings.rs ---
use crate::common_macro::schema_imports::*;

#[test]
fn test_string() {
    let actual_name = str::declaration();
    assert_eq!("String", actual_name);
    let actual_name = String::declaration();
    assert_eq!("String", actual_name);
    let mut actual_defs = schema_map!();
    String::add_definitions_recursively(&mut actual_defs);
    assert_eq!(
        schema_map! {
            "String" => Definition::Sequence {
                length_width: Definition::DEFAULT_LENGTH_WIDTH,
                length_range: Definition::DEFAULT_LENGTH_RANGE,
                elements: "u8".to_string()
            },
            "u8" => Definition::Primitive(1)
        },
        actual_defs
    );

    let mut actual_defs = schema_map!();
    str::add_definitions_recursively(&mut actual_defs);
    assert_eq!(
        schema_map! {
            "String" => Definition::Sequence {
                length_width: Definition::DEFAULT_LENGTH_WIDTH,
                length_range: Definition::DEFAULT_LENGTH_RANGE,
                elements: "u8".to_string()
             },
            "u8" => Definition::Primitive(1)
        },
        actual_defs
    );
}

'''
'''--- borsh/tests/schema/test_tuple.rs ---
use crate::common_macro::schema_imports::*;

#[test]
fn test_unary_tuple_schema() {
    assert_eq!("(bool,)", <(bool,)>::declaration());
    let mut defs = Default::default();
    <(bool,)>::add_definitions_recursively(&mut defs);
    assert_eq!(
        schema_map! {
        "(bool,)" => Definition::Tuple { elements: vec!["bool".to_string()] },
        "bool" => Definition::Primitive(1)
        },
        defs
    );
}

#[test]
fn simple_tuple() {
    let actual_name = <(u64, core::num::NonZeroU16, String)>::declaration();
    let mut actual_defs = schema_map!();
    <(u64, core::num::NonZeroU16, String)>::add_definitions_recursively(&mut actual_defs);
    assert_eq!("(u64, NonZeroU16, String)", actual_name);
    assert_eq!(
        schema_map! {
            "(u64, NonZeroU16, String)" => Definition::Tuple {
                elements: vec![
                    "u64".to_string(),
                    "NonZeroU16".to_string(),
                    "String".to_string()
                ]
            },
            "u64" => Definition::Primitive(8),
            "NonZeroU16" => Definition::Primitive(2),
            "String" => Definition::Sequence {
                length_width: Definition::DEFAULT_LENGTH_WIDTH,
                length_range: Definition::DEFAULT_LENGTH_RANGE,
                elements: "u8".to_string()
            },
            "u8" => Definition::Primitive(1)
        },
        actual_defs
    );
}

#[test]
fn nested_tuple() {
    let actual_name = <(u64, (u8, bool), String)>::declaration();
    let mut actual_defs = schema_map!();
    <(u64, (u8, bool), String)>::add_definitions_recursively(&mut actual_defs);
    assert_eq!("(u64, (u8, bool), String)", actual_name);
    assert_eq!(
        schema_map! {
            "(u64, (u8, bool), String)" => Definition::Tuple { elements: vec![
                "u64".to_string(),
                "(u8, bool)".to_string(),
                "String".to_string(),
            ]},
            "(u8, bool)" => Definition::Tuple { elements: vec![ "u8".to_string(), "bool".to_string()]},
            "u64" => Definition::Primitive(8),
            "u8" => Definition::Primitive(1),
            "bool" => Definition::Primitive(1),
            "String" => Definition::Sequence {
                length_width: Definition::DEFAULT_LENGTH_WIDTH,
                length_range: Definition::DEFAULT_LENGTH_RANGE,
                elements: "u8".to_string()
            }
        },
        actual_defs
    );
}

'''
'''--- borsh/tests/schema/test_vecs.rs ---
use crate::common_macro::schema_imports::*;
use alloc::collections::{VecDeque, LinkedList};

macro_rules! test_vec_like_collection_schema {
    [$test_name: ident, $type: ident] => [

        #[test]
        fn $test_name() {
            let actual_name = $type::<u64>::declaration();
            let mut actual_defs = schema_map!();
            $type::<u64>::add_definitions_recursively(&mut actual_defs);

            assert_eq!(format!("{}<u64>", stringify!($type)), actual_name);
            assert_eq!(
                schema_map! {
                    actual_name => Definition::Sequence {
                        length_width: Definition::DEFAULT_LENGTH_WIDTH,
                        length_range: Definition::DEFAULT_LENGTH_RANGE,
                        elements: "u64".to_string(),
                    },
                    "u64" => Definition::Primitive(8)
                },
                actual_defs
            );
        }
    ];
}

test_vec_like_collection_schema!(simple_vec, Vec);
test_vec_like_collection_schema!(vec_deque, VecDeque);
test_vec_like_collection_schema!(linked_list, LinkedList);

#[test]
fn nested_vec() {
    let actual_name = Vec::<Vec<u64>>::declaration();
    let mut actual_defs = schema_map!();
    Vec::<Vec<u64>>::add_definitions_recursively(&mut actual_defs);
    assert_eq!("Vec<Vec<u64>>", actual_name);
    assert_eq!(
        schema_map! {
            "Vec<u64>" => Definition::Sequence {
                length_width: Definition::DEFAULT_LENGTH_WIDTH,
                length_range: Definition::DEFAULT_LENGTH_RANGE,
                elements: "u64".to_string(),
            },
            "Vec<Vec<u64>>" => Definition::Sequence {
                length_width: Definition::DEFAULT_LENGTH_WIDTH,
                length_range: Definition::DEFAULT_LENGTH_RANGE,
                elements: "Vec<u64>".to_string(),
            },
            "u64" => Definition::Primitive(8)
        },
        actual_defs
    );
}

#[test]
fn slice_schema_container() {
    let schema = schema_container_of::<[i64]>();

    assert_eq!(
        schema,
        BorshSchemaContainer::new(
            "Vec<i64>".to_string(),
            schema_map! {
                "Vec<i64>" => Definition::Sequence {
                    length_width: Definition::DEFAULT_LENGTH_WIDTH,
                    length_range: Definition::DEFAULT_LENGTH_RANGE,
                    elements: "i64".to_string(),
                },
                "i64" => Definition::Primitive(8)

            }
        )
    )
}

#[test]
fn vec_schema_container() {
    let schema = schema_container_of::<Vec<i64>>();

    assert_eq!(
        schema,
        BorshSchemaContainer::new(
            "Vec<i64>".to_string(),
            schema_map! {
                "Vec<i64>" => Definition::Sequence {
                    length_width: Definition::DEFAULT_LENGTH_WIDTH,
                    length_range: Definition::DEFAULT_LENGTH_RANGE,
                    elements: "i64".to_string(),
                },
                "i64" => Definition::Primitive(8)

            }
        )
    )
}

'''
'''--- borsh/tests/smoke.rs ---
#![cfg_attr(not(feature = "std"), no_std)]
// Smoke tests that ensure that we don't accidentally remove top-level
// re-exports in a minor release.

#[cfg(not(feature = "std"))]
extern crate alloc;
#[cfg(not(feature = "std"))]
use alloc::vec;

use borsh::{self, from_slice};
#[cfg(feature = "unstable__schema")]
use borsh::{schema_container_of, try_from_slice_with_schema};

#[cfg(feature = "unstable__schema")]
#[test]
fn test_to_vec() {
    let value = 42u8;

    let seriazeble = (schema_container_of::<u8>(), value);
    let serialized = borsh::to_vec(&seriazeble).unwrap();
    #[cfg(feature = "std")]
    println!("serialized: {:?}", serialized);
    let deserialized = try_from_slice_with_schema::<u8>(&serialized).unwrap();
    assert_eq!(value, deserialized);
}

#[test]
fn test_to_writer() {
    let value = 42u8;
    let mut serialized = vec![0; 1];
    // serialized: [2, 0, 0, 0, 117, 56, 0, 0, 0, 0, 42]
    borsh::to_writer(&mut serialized[..], &value).unwrap();
    let deserialized = from_slice::<u8>(&serialized).unwrap();
    assert_eq!(value, deserialized);
}

'''
'''--- borsh/tests/tests.rs ---
#![cfg_attr(not(feature = "std"), no_std)]

extern crate alloc;

#[macro_use]
mod common_macro;

mod custom_reader {
    #[cfg(feature = "derive")]
    mod test_custom_reader;
}

/// this module doesn't contain runnable tests;
/// it's included into module tree to ensure derived code doesn't raise compilation
/// errors 
#[rustfmt::skip]
#[cfg(feature = "derive")]
mod compile_derives {
    mod test_macro_namespace_collisions;
    #[allow(unused)]
    mod test_generic_structs;
    mod test_generic_enums;
    mod test_recursive_structs;

    #[cfg(feature = "unstable__schema")]
    mod schema {
        mod test_generic_enums;
    }
}

/// These are full roundtrip `BorshSerialize`/`BorshDeserialize` tests
#[rustfmt::skip]
mod roundtrip {
    mod test_strings; 
    #[cfg(feature = "ascii")]
    mod test_ascii_strings; 
    mod test_arrays;
    mod test_vecs;
    mod test_tuple;
    mod test_primitives;
    mod test_nonzero_integers;
    mod test_range;
    // mod test_phantom_data; // NOTE: there's nothing corresponding to `schema::test_phantom_data`
    // mod test_option; // NOTE: there's nothing corresponding to `schema::test_option`
    // mod test_box; // NOTE: there's nothing corresponding to `schema::test_box`
    #[cfg(hash_collections)]
    mod test_hash_map;
    mod test_btree_map;
    mod test_cow;
    mod test_cells;
    #[cfg(feature = "rc")]
    mod test_rc;

    #[cfg(feature = "derive")]
    mod requires_derive_category {
        // mod test_simple_structs; // NOTE: there's nothing corresponding to `schema::test_simple_structs`
        mod test_generic_structs;
        mod test_simple_enums;
        mod test_generic_enums;
        mod test_recursive_structs;
        mod test_recursive_enums;
        mod test_serde_with_third_party; 
        mod test_enum_discriminants;
        #[cfg(feature = "bytes")]
        mod test_ultimate_many_features_combined;
        #[cfg(feature = "bson")]
        mod test_bson_object_ids;
    }
}

/// These are `BorshSchema` tests for various types
#[cfg(feature = "unstable__schema")]
#[rustfmt::skip]
mod schema {
    #[cfg(feature = "ascii")]
    mod test_ascii_strings; 
    mod test_strings; 
    mod test_arrays;
    mod test_vecs;
    mod test_tuple;
    mod test_primitives;
    // mod test_nonzero_integers; // NOTE: there's nothing corresponding to `roundtrip::test_nonzero_integers`
    mod test_range;
    mod test_phantom_data;
    mod test_option;
    mod test_box;
    #[cfg(hash_collections)]
    mod test_hash_map;
    mod test_btree_map;
    mod test_cow;
    mod test_cells;
    #[cfg(feature = "rc")]
    mod test_rc;
    mod test_simple_structs;
    mod test_generic_structs;
    mod test_simple_enums;
    mod test_generic_enums;
    mod test_recursive_structs;
    mod test_recursive_enums;
    mod test_schema_with_third_party; // NOTE: this test corresponds to `roundtrip::test_serde_with_third_party`
    mod test_enum_discriminants;
    // mod test_ultimate_many_features_combined;  // NOTE: there's nothing corresponding to `roundtrip::test_ultimate_many_features_combined`
    // mod test_bson_object_ids; // NOTE: there's nothing corresponding to `roundtrip::test_bson_object_ids`
    mod schema_conflict {
        mod test_schema_conflict;
    }

    mod container_extension {
        mod test_schema_validate;
        mod test_max_size;
    }
}

mod deserialization_errors {
    #[cfg(feature = "ascii")]
    mod test_ascii_strings;
    mod test_cells;
    mod test_initial;
}

mod init_in_deserialize {
    #[cfg(feature = "derive")]
    mod test_init_in_deserialize;
}

mod zero_sized_types {
    #[cfg(feature = "derive")]
    mod test_zero_sized_types_forbidden;
}

'''
'''--- borsh/tests/zero_sized_types/test_zero_sized_types_forbidden.rs ---
use alloc::{string::ToString, vec, vec::Vec};

#[cfg(feature = "std")]
use std::collections::{HashMap, HashSet};

#[cfg(feature = "hashbrown")]
use hashbrown::{HashMap, HashSet};

use alloc::collections::{BTreeMap, BTreeSet, LinkedList, VecDeque};

use borsh::from_slice;
use borsh::to_vec;
use borsh::BorshDeserialize;
use borsh::BorshSerialize;

use borsh::error::ERROR_ZST_FORBIDDEN;
#[derive(BorshDeserialize, BorshSerialize, PartialEq, Debug, Eq, PartialOrd, Ord, Hash)]
struct A();

#[test]
fn test_deserialize_vec_of_zst() {
    let v = [0u8, 0u8, 0u8, 64u8];
    let res = from_slice::<Vec<A>>(&v);
    assert_eq!(res.unwrap_err().to_string(), ERROR_ZST_FORBIDDEN);
}

#[test]
fn test_serialize_vec_of_zst() {
    let v = vec![A()];
    let res = to_vec(&v);
    assert_eq!(res.unwrap_err().to_string(), ERROR_ZST_FORBIDDEN);
}

#[test]
fn test_serialize_vec_of_unit_type() {
    let v = vec![(), (), ()];
    let res = to_vec(&v);
    assert_eq!(res.unwrap_err().to_string(), ERROR_ZST_FORBIDDEN);
}

#[test]
fn test_serialize_vec_of_vec_of_unit_type() {
    let v: Vec<Vec<()>> = vec![vec![(), (), ()]];
    let res = to_vec(&v);
    assert_eq!(res.unwrap_err().to_string(), ERROR_ZST_FORBIDDEN);
}

#[test]
fn test_deserialize_vec_deque_of_zst() {
    let v = [0u8, 0u8, 0u8, 64u8];
    let res = from_slice::<VecDeque<A>>(&v);
    assert_eq!(res.unwrap_err().to_string(), ERROR_ZST_FORBIDDEN);
}

#[test]
fn test_serialize_vec_deque_of_zst() {
    let v: VecDeque<A> = vec![A()].into();
    let res = to_vec(&v);
    assert_eq!(res.unwrap_err().to_string(), ERROR_ZST_FORBIDDEN);
}

#[test]
fn test_deserialize_linked_list_of_zst() {
    let v = [0u8, 0u8, 0u8, 64u8];
    let res = from_slice::<LinkedList<A>>(&v);
    assert_eq!(res.unwrap_err().to_string(), ERROR_ZST_FORBIDDEN);
}

#[test]
fn test_serialize_linked_list_of_zst() {
    let v: LinkedList<A> = vec![A()].into_iter().collect();
    let res = to_vec(&v);
    assert_eq!(res.unwrap_err().to_string(), ERROR_ZST_FORBIDDEN);
}

#[test]
fn test_deserialize_btreeset_of_zst() {
    let v = [0u8, 0u8, 0u8, 64u8];
    let res = from_slice::<BTreeSet<A>>(&v);
    assert_eq!(res.unwrap_err().to_string(), ERROR_ZST_FORBIDDEN);
}

#[test]
fn test_serialize_btreeset_of_zst() {
    let v: BTreeSet<A> = vec![A()].into_iter().collect();
    let res = to_vec(&v);
    assert_eq!(res.unwrap_err().to_string(), ERROR_ZST_FORBIDDEN);
}

#[cfg(hash_collections)]
#[test]
fn test_deserialize_hashset_of_zst() {
    let v = [0u8, 0u8, 0u8, 64u8];
    let res = from_slice::<HashSet<A>>(&v);
    assert_eq!(res.unwrap_err().to_string(), ERROR_ZST_FORBIDDEN);
}

#[cfg(hash_collections)]
#[test]
fn test_serialize_hashset_of_zst() {
    let v: HashSet<A> = vec![A()].into_iter().collect();
    let res = to_vec(&v);
    assert_eq!(res.unwrap_err().to_string(), ERROR_ZST_FORBIDDEN);
}

#[test]
fn test_deserialize_btreemap_of_zst() {
    let v = [0u8, 0u8, 0u8, 64u8];
    let res = from_slice::<BTreeMap<A, u64>>(&v);
    assert_eq!(res.unwrap_err().to_string(), ERROR_ZST_FORBIDDEN);
}

#[test]
fn test_serialize_btreemap_of_zst() {
    let v: BTreeMap<A, u64> = vec![(A(), 42u64)].into_iter().collect();
    let res = to_vec(&v);
    assert_eq!(res.unwrap_err().to_string(), ERROR_ZST_FORBIDDEN);
}

#[cfg(hash_collections)]
#[test]
fn test_deserialize_hashmap_of_zst() {
    let v = [0u8, 0u8, 0u8, 64u8];
    let res = from_slice::<HashMap<A, u64>>(&v);
    assert_eq!(res.unwrap_err().to_string(), ERROR_ZST_FORBIDDEN);
}

#[cfg(hash_collections)]
#[test]
fn test_serialize_hashmap_of_zst() {
    let v: HashMap<A, u64> = vec![(A(), 42u64)].into_iter().collect();
    let res = to_vec(&v);
    assert_eq!(res.unwrap_err().to_string(), ERROR_ZST_FORBIDDEN);
}

#[derive(BorshDeserialize, BorshSerialize, PartialEq, Debug)]
struct B(u32);
#[test]
fn test_deserialize_non_zst() {
    let v = [1, 0, 0, 0, 64, 0, 0, 0];
    let res = Vec::<B>::try_from_slice(&v);
    assert!(res.is_ok());
}

#[test]
fn test_serialize_non_zst() {
    let v = vec![B(1)];
    let res = to_vec(&v);
    assert!(res.is_ok());
}

'''
'''--- docs/migration_guides/v0.10.2_to_v1.0.0_nearcore.md ---
# `0.10.2` -> `1.0.0` `nearcore` upgrade *migration guide*

The link to `nearcore` pr is [chore: update borsh dependency](https://github.com/near/nearcore/pull/9432)  

Steps:

## 1. update dependencies in `nearcore` workspace `Cargo.toml`

First we update to `1.0.0-alpha.5` version, which contains [deprecation](https://github.com/near/borsh-rs/pull/206) of `BorshSerialize::try_to_vec` method.

```diff
diff --git a/Cargo.toml b/Cargo.toml
index f38e88411..1587f4131 100644
--- a/Cargo.toml
+++ b/Cargo.toml
-borsh = { version = "0.10.2", features = ["rc"] }
+borsh = { version = "=1.0.0-alpha.5", features = ["derive", "rc"] }
```

## 2. We receive a great number of deprecation warnings of `borsh::BorshSerialize::try_to_vec` method (`near-primitives-core` and other packages):

```bash
warning: use of deprecated method `borsh::BorshSerialize::try_to_vec`: use `borsh::to_vec(&object)` instead
   --> core/primitives-core/src/account.rs:246:25
    |
246 |         let bytes = acc.try_to_vec().unwrap();
    |                         ^^^^^^^^^^
    |
    = note: `#[warn(deprecated)]` on by default
```

We choose to fix it at once, as this method is [removed](https://github.com/near/borsh-rs/pull/221) in `1.0.0-alpha.5` -> `1.0.0` transition completely 
with following diff:

```diff
diff --git a/core/primitives-core/src/account.rs b/core/primitives-core/src/account.rs
index 50a3a340d..380bf4494 100644
--- a/core/primitives-core/src/account.rs
+++ b/core/primitives-core/src/account.rs
@@ -236,3 +236,2 @@ pub struct FunctionCallPermission {
 mod tests {
-    use borsh::BorshSerialize;
 
@@ -245,3 +244,3 @@ mod tests {
         let acc = Account::new(1_000_000, 1_000_000, CryptoHash::default(), 100);
-        let bytes = acc.try_to_vec().unwrap();
+        let bytes = borsh::to_vec(&acc).unwrap();
         assert_eq!(hash(&bytes).to_string(), "EVk5UaxBe8LQ8r8iD5EAxVBs6TJcMDKqyH7PBuho6bBJ");
@@ -257,3 +256,3 @@ mod tests {
         };
-        let mut old_bytes = &old_account.try_to_vec().unwrap()[..];
+        let mut old_bytes = &borsh::to_vec(&old_account).unwrap()[..];
         let new_account = <Account as BorshDeserialize>::deserialize(&mut old_bytes).unwrap();
@@ -264,3 +263,3 @@ mod tests {
         assert_eq!(new_account.version, AccountVersion::V1);
-        let mut new_bytes = &new_account.try_to_vec().unwrap()[..];
+        let mut new_bytes = &borsh::to_vec(&new_account).unwrap()[..];
         let deserialized_account =
...
...
...
```

As `nearcore` has a considerable number of occurencies of usage of `borsh::BorshSerialize::try_to_vec` method,
which are tedious to replace manually, [ast-grep](https://github.com/ast-grep/ast-grep) tool may help to
do the refactoring automatically:

```bash
sg -p '$A.try_to_vec()' -l rs -r 'borsh::to_vec(&$A)'  # preview changes
sg -p '$A.try_to_vec()' -l rs -r 'borsh::to_vec(&$A)' -A # apply changes without preview
```

## 3. next we encounter error in `near-primitives` package:

```bash
 1  error[E0433]: failed to resolve: could not find `maybestd` in `borsh`                   ▐
  --> core/primitives/src/receipt.rs:1:19                                                   ▐
   |                                                                                        ▐
 1 | use crate::borsh::maybestd::collections::HashMap;                                      ▐
   |                   ^^^^^^^^ could not find `maybestd` in `borsh`                        ▐
```

`maybestd` [has moved](https://github.com/near/borsh-rs/pull/171) to a `__private` package in `borsh`, and is not supposed to be
accessed directly now besides from within code, derived in `borsh` traits implementations.

As `near-primitives` crate is not supposed to be used in `no_std` context, we can
replace import with standard collections `HashMap`:

```diff
diff --git a/core/primitives/src/receipt.rs b/core/primitives/src/receipt.rs
index 30af36fb9..d5a6632ed 100644
--- a/core/primitives/src/receipt.rs
+++ b/core/primitives/src/receipt.rs
@@ -1,11 +1,11 @@
-use crate::borsh::maybestd::collections::HashMap;
+use std::collections::HashMap;
```

Otherwise, we would've imported from `hashbrown`:

```diff
-use crate::borsh::maybestd::collections::HashMap;
+#[cfg(feature = "std")]
+use std::collections::HashMap;
+#[cfg(not(feature = "std"))]
+use hashbrown::HashMap;
```

## 4. next we encounter a bunch of similar errors in `near-primitives` with `#[borsh_init(...)]`:

```bash
 1  error: cannot find attribute `borsh_init` in this scope                                 ▐
    --> core/primitives/src/block_header.rs:267:3                                           ▐
     |                                                                                      ▐
 267 | #[borsh_init(init)]                                                                  ▐
     |   ^^^^^^^^^^ help: a derive helper attribute with a similar name exists: `borsh_skip`▐
```

The syntax of this attribute [has changed](https://github.com/near/borsh-rs/pull/187). We change all of these occurencies according to
`#[borsh(init=<initialization_method>)]` syntax. The following diff is shortened to first and last
occurencies:

```diff
diff --git a/core/primitives/src/block_header.rs b/core/primitives/src/block_header.rs
index 38491b52c..84ab48238 100644
--- a/core/primitives/src/block_header.rs
+++ b/core/primitives/src/block_header.rs
@@ -266,3 +266,3 @@ impl ApprovalMessage {
 #[derive(BorshSerialize, BorshDeserialize, serde::Serialize, Debug, Clone, Eq, PartialEq)]
-#[borsh_init(init)]
+#[borsh(init=init)]
 pub struct BlockHeaderV1 {
...
diff --git a/core/primitives/src/transaction.rs b/core/primitives/src/transaction.rs
index 912120b56..2de7a1d52 100644
--- a/core/primitives/src/transaction.rs
+++ b/core/primitives/src/transaction.rs
@@ -58,3 +58,3 @@ impl Transaction {
 )]
-#[borsh_init(init)]
+#[borsh(init=init)]
 pub struct SignedTransaction {
```

## 5. next we encounter a large number of similar syntax errors in `near-primitives` package

```bash
 1  error: cannot find attribute `borsh_skip` in this scope                   ▐
    --> core/primitives/src/transaction.rs:196:7                              ▐
     |                                                                        ▐
 196 |     #[borsh_skip]                                                      ▐
     |       ^^^^^^^^^^                                                       ▐
                                                                              ▐
```

We change all of these occurencies according to [new](https://github.com/near/borsh-rs/pull/192)
`#[borsh(skip)]` syntax. The following diff is shortened to first and last
occurencies:

```diff
diff --git a/core/primitives/src/block_header.rs b/core/primitives/src/block_header.rs
index 84ab48238..6514f8222 100644
--- a/core/primitives/src/block_header.rs
+++ b/core/primitives/src/block_header.rs
@@ -279,3 +279,3 @@ pub struct BlockHeaderV1 {
     /// Cached value of hash for this block.
-    #[borsh_skip]
+    #[borsh(skip)]
     pub hash: CryptoHash,
...
diff --git a/core/primitives/src/transaction.rs b/core/primitives/src/transaction.rs
index 2de7a1d52..f3ac54ba8 100644
--- a/core/primitives/src/transaction.rs
+++ b/core/primitives/src/transaction.rs
@@ -62,5 +62,5 @@ pub struct SignedTransaction {
     pub signature: Signature,
-    #[borsh_skip]
+    #[borsh(skip)]
     hash: CryptoHash,
-    #[borsh_skip]
+    #[borsh(skip)]
     size: u64,
...
```

## 6. next we encounter 2 errors in `near-primitives` package similar to those in point 3.:

```bash
 1  error[E0433]: failed to resolve: could not find `maybestd` in `borsh`
    --> core/primitives/src/action/delegate.rs:119:41
     |
 119 |         fn deserialize_reader<R: borsh::maybestd::io::Read>(
     |                                         ^^^^^^^^ could not find `maybestd` in `borsh`
                                                                                             
 2  error[E0433]: failed to resolve: could not find `maybestd` in `borsh`
    --> core/primitives/src/action/delegate.rs:121:50
     |
 121 |         ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
     |                                                  ^^^^^^^^ could not find `maybestd` i
 n `borsh`
```

As `near-primitives` crate is not supposed to be used in `no_std` context, we can
replace import with `std::io`:

```diff
diff --git a/core/primitives/src/action/delegate.rs b/core/primitives/src/action/delegate.rs
index 25db73022..ebd009a44 100644
--- a/core/primitives/src/action/delegate.rs
+++ b/core/primitives/src/action/delegate.rs
@@ -14,3 +14,3 @@ use near_primitives_core::types::{AccountId, Nonce};
 use serde::{Deserialize, Serialize};
-use std::io::{Error, ErrorKind};
+use std::io::{Error, ErrorKind, Read};
 
@@ -118,5 +118,5 @@ mod private_non_delegate_action {
     impl borsh::de::BorshDeserialize for NonDelegateAction {
-        fn deserialize_reader<R: borsh::maybestd::io::Read>(
+        fn deserialize_reader<R: Read>(
             rd: &mut R,
-        ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
+        ) -> ::core::result::Result<Self, Error> {
             match u8::deserialize_reader(rd)? {
```

Otherwise, if we intended to support [both `std` and `no_std`](https://github.com/near/borsh-rs/pull/212), we would've imported from `borsh::io`:

```diff
+use borsh::io::{Error, ErrorKind, Read};
```

## 7. next we encounter an error with `BorshDeserialize` trait derivation:

```bash
 1  error[E0277]: the trait bound `&T: borsh::BorshDeserialize` is not satisfied
   --> core/primitives/src/signable_message.rs:58:26
    |
 58 | #[derive(BorshSerialize, BorshDeserialize)]
    |                          ^^^^^^^^^^^^^^^^ the trait `borsh::BorshDeserialize` is not implemented for `&T`
```
on

```rust
/// A wrapper around a message that should be signed using this scheme.
///
/// Only used for constructing a signature, not used to transmit messages. The
/// discriminant prefix is implicit and should be known by the receiver based on
/// the context in which the message is received.
#[derive(BorshSerialize, BorshDeserialize)]
pub struct SignableMessage<'a, T> {
    pub discriminant: MessageDiscriminant,
    pub msg: &'a T,
}
```

On version change `0.10.3` -> `1.0.0-alpha.5` bounds derivation in `borsh` [has changed](https://github.com/near/borsh-rs/pull/178):
From bounds on the types of the fields:

```rust
impl<'a, T> borsh::de::BorshDeserialize for SignableMessage<'a, T>
where
    MessageDiscriminant: borsh::de::BorshDeserialize,
    &'a T: borsh::de::BorshDeserialize,
```

to bounds on type parameters, encountered in fields:

```rust
impl<'a, T> borsh::de::BorshDeserialize for SignableMessage<'a, T>
where
    T: borsh::de::BorshDeserialize,
```

We could potentially [patch the bounds](https://github.com/near/borsh-rs/pull/180) on struct to make it compile:

```rust
#[derive(BorshSerialize, BorshDeserialize)]
pub struct SignableMessage<'a, T> {
    pub discriminant: MessageDiscriminant,
    #[borsh(bound(deserialize="&'a T: borsh::de::BorshDeserialize"))]
    pub msg: &'a T,
}
```
which would transform into following bound on trait's implementation:

```rust
where
    &'a T: borsh::de::BorshDeserialize,
```

But the real issue here is that `borsh` doesn't have a generic implementation
of `BorshDeserialize` for `&'a T`, where `T: borsh::de::BorshDeserialize` (nor did it have it in 0.10.2 version),
and that the derived `BorshDeserialize` wasn't used (and it couldn't be for such a field's type).

So the right change is to remove `BorshDeserialize` derive from the struct:

```diff
diff --git a/core/primitives/src/signable_message.rs b/core/primitives/src/signable_message.rs
index efdd489ac..db97eb1fd 100644
--- a/core/primitives/src/signable_message.rs
+++ b/core/primitives/src/signable_message.rs
@@ -57,3 +57,3 @@ pub struct MessageDiscriminant {
 /// the context in which the message is received.
-#[derive(BorshSerialize, BorshDeserialize)]
+#[derive(BorshSerialize)]
 pub struct SignableMessage<'a, T> {
```

## 8. next we encounter an error in `near-network` package:

```rust
 1  error: You have to specify `#[borsh(use_discriminant=true)]` or `#[borsh(use_discriminant=false)]` for all enums with explicit discriminant                                                                                                                            ▐
   --> chain/network/src/types.rs:56:10                                                                                                                                                                                                                                    ▐
    |                                                                                                                                                                                                                                                                      ▐
 56 | pub enum ReasonForBan {                                                                                                                                                                                                                                              ▐
    |          ^^^^^^^^^^^^                                                                                                                                                                                                                                                ▐
```

```rust
#[derive(borsh::BorshSerialize, borsh::BorshDeserialize, Debug, Clone, PartialEq, Eq, Copy)]
pub enum ReasonForBan {
    None = 0,
    BadBlock = 1,
    BadBlockHeader = 2,
    HeightFraud = 3,
    BadHandshake = 4,
    BadBlockApproval = 5,
    Abusive = 6,
    InvalidSignature = 7,
    InvalidPeerId = 8,
    InvalidHash = 9,
    InvalidEdge = 10,
    InvalidDistanceVector = 11,
    Blacklisted = 14,
}
```

We fix it with `#[borsh(use_discriminant=false)]` to preserve the behaviour of borsh before 
1.0 release which serialized `ReasonForBan::Blacklisted` as 12 instead of 14 
(borsh 0.10 and older [ignored explicit discriminant values in enum definitions](https://github.com/near/borsh-rs/issues/137)):

```diff
diff --git a/chain/network/src/types.rs b/chain/network/src/types.rs
index b2dd97c32..ea2d67f2d 100644
--- a/chain/network/src/types.rs
+++ b/chain/network/src/types.rs
@@ -55,2 +55,3 @@ pub struct KnownProducer {
 #[derive(borsh::BorshSerialize, borsh::BorshDeserialize, Debug, Clone, PartialEq, Eq, Copy)]
+#[borsh(use_discriminant=false)]
 pub enum ReasonForBan {
```

## 9. change in behaviour, unit test error in ci in `near-primitives` package

Assertion fails:

```rust
    #[test]
    fn test_delegate_action_deserialization() {
        // Expected an error. Buffer is empty
        assert_eq!(
            NonDelegateAction::try_from_slice(Vec::new().as_ref()).map_err(|e| e.kind()),
            Err(ErrorKind::InvalidInput)
        );
```

```bash
--- STDERR:              near-primitives action::delegate::tests::test_delegate_action_deserialization ---
thread 'action::delegate::tests::test_delegate_action_deserialization' panicked at 'assertion failed: `(left == right)`
  left: `Err(InvalidData)`,
 right: `Err(InvalidInput)`', core/primitives/src/action/delegate.rs:172:9
 ```

 The `ErrorKind` in error in `borsh` [has changed](https://github.com/near/borsh-rs/pull/170), so we apply the following diff:

```diff
diff --git a/core/primitives/src/action/delegate.rs b/core/primitives/src/action/delegate.rs
index ebd009a44..80a0475b6 100644
--- a/core/primitives/src/action/delegate.rs
+++ b/core/primitives/src/action/delegate.rs
@@ -173,3 +173,3 @@ mod tests {
             NonDelegateAction::try_from_slice(Vec::new().as_ref()).map_err(|e| e.kind()),
-            Err(ErrorKind::InvalidInput)
+            Err(ErrorKind::InvalidData)
         );
```

And there's also a similar error in 

```bash
--- STDERR:              near-store tests::test_save_to_file ---
thread 'tests::test_save_to_file' panicked at 'assertion failed: `(left == right)`
  left: `InvalidInput`,
 right: `InvalidData`', core/store/src/lib.rs:1096:9  
```

with similar fix.

## 10. errors  similar to previous ones, in `near-store`, `near-network` and `near-state-viewer` packages

There was a bunch of `borsh::maybestd` imports, which got replaced by their direct from-`std` counterparts.

## 11. finally, we update `borsh` version to `1.0.0`:

```diff
diff --git a/Cargo.toml b/Cargo.toml
index f38e88411..1587f4131 100644
--- a/Cargo.toml
+++ b/Cargo.toml
-borsh = { version = "=1.0.0-alpha.5", features = ["derive", "rc"] }
+borsh = { version = "1.0.0", features = ["derive", "rc"] }
```

'''
'''--- docs/migration_guides/v0.9_to_v1.0.0_near_sdk_rs.md ---
#  `v0.9` -> `v1.0.0` `near-sdk-rs` upgrade *migration guide*

The link to `near-sdk-rs` pr is [chore: borsh version update](https://github.com/near/near-sdk-rs/pull/1075)  

Steps: 

## 1. update dependencies in `near-sdk/Cargo.toml`. 

First we update to `1.0.0-alpha.5` version, which contains [deprecation](https://github.com/near/borsh-rs/pull/206) of `BorshSerialize::try_to_vec` method.

We enable `derive` feature by default, and make `unstable__schema` feature optional, enabled 
depending on whether `abi` feature of `near-sdk` package is enabled or not.

```diff
diff --git a/near-sdk/Cargo.toml b/near-sdk/Cargo.toml
index a015a64..e6099d4 100644
--- a/near-sdk/Cargo.toml
+++ b/near-sdk/Cargo.toml
@@ -26,3 +26,3 @@ near-sys = { path = "../near-sys", version = "0.2" }
 base64 = "0.13"
-borsh = { version = "0.9", features = ["const-generics"] }
+borsh = { version = "=1.0.0-alpha.5", features = ["derive"] }
 bs58 = "0.4"
@@ -35,3 +35,4 @@ once_cell = { version = "1.17", default-features = false }
@@ -58,3 +59,3 @@ unstable = []
 legacy = []
-abi = ["near-abi", "schemars", "near-sdk-macros/abi"]
+abi = ["borsh/unstable__schema", "near-abi", "schemars", "near-sdk-macros/abi"]
 unit-testing = ["near-vm-logic", "near-primitives-core", "near-primitives", "near-crypto"]
```

## 2. We receive a great number of deprecation warnings of `borsh::BorshSerialize::try_to_vec` method (`near-sdk` package):

```bash
 2  warning: use of deprecated method `borsh::BorshSerialize::try_to_vec`: use `borsh::to_vec(&object)` instead                                                                                                                                                          
   --> near-sdk/src/store/lazy/mod.rs:43:28                                                                                                                                                                                                                              
    |                                                                                                                                                                                                                                                                    
 43 |     let serialized = value.try_to_vec().unwrap_or_else(|_| env::panic_str(ERR_VALUE_SERIALIZATION));                                                                                                                                                               
    |                            ^^^^^^^^^^                                                                                                                                                                                                                              
    |                                                                                                                                                                                                                                                                    
    = note: `#[warn(deprecated)]` on by default                                                                                                                                                                                                                          
```

We choose to fix it at once, as this method is [removed](https://github.com/near/borsh-rs/pull/221) in `1.0.0-alpha.5` -> `1.0.0` transition completely 
with following diff:

```diff
diff --git a/near-sdk/src/store/lazy/mod.rs b/near-sdk/src/store/lazy/mod.rs
index 7df7ee4..42112ea 100644
--- a/near-sdk/src/store/lazy/mod.rs
+++ b/near-sdk/src/store/lazy/mod.rs
@@ -8,3 +8,3 @@ mod impls;
 
-use borsh::{BorshDeserialize, BorshSerialize};
+use borsh::{BorshDeserialize, BorshSerialize, to_vec};
 use once_cell::unsync::OnceCell;
@@ -42,3 +42,3 @@ where
 {
-    let serialized = value.try_to_vec().unwrap_or_else(|_| env::panic_str(ERR_VALUE_SERIALIZATION));
+    let serialized = to_vec(value).unwrap_or_else(|_| env::panic_str(ERR_VALUE_SERIALIZATION));
     env::storage_write(key, &serialized);
...
...
```

where `value` is `&T`, where `T: BorshSerialize`.

## 3. We replace the usage of `BorshSchema::schema_container` method (`near-sdk-macros` package)

To prevent compilation errors in the future, we grep for `schema_container` string.
`schema_container` was changed from being a `BorshSchema` trait method to being a function, external
to the trait in [chore!: make BorshSchema::{add_definition,schema_container} free-standing funcs](https://github.com/near/borsh-rs/pull/204)

We fix code, generated with `near_bindgen` procedural macro, with following diff:

```diff
diff --git a/near-sdk-macros/src/core_impl/abi/abi_generator.rs b/near-sdk-macros/src/core_impl/abi/abi_generator.rs
index cbe659a..994e63c 100644
--- a/near-sdk-macros/src/core_impl/abi/abi_generator.rs
+++ b/near-sdk-macros/src/core_impl/abi/abi_generator.rs
@@ -239,21 +239,21 @@ impl ImplItemMethodInfo {
         }
     }
 }
 
 fn generate_schema(ty: &Type, serializer_type: &SerializerType) -> TokenStream2 {
     match serializer_type {
         SerializerType::JSON => quote! {
             gen.subschema_for::<#ty>()
         },
         SerializerType::Borsh => quote! {
-            <#ty as ::near_sdk::borsh::BorshSchema>::schema_container()
+            ::near_sdk::borsh::schema_container_of::<#ty>()
         },
     }
 }
 
 fn generate_abi_type(ty: &Type, serializer_type: &SerializerType) -> TokenStream2 {
     let schema = generate_schema(ty, serializer_type);
     match serializer_type {
         SerializerType::JSON => quote! {
             ::near_sdk::__private::AbiType::Json {
                 type_schema: #schema,
```

## 4. next we encounter error with `#[borsh(use_discriminant=<bool>)]` (`near-sdk` package):

```bash
 1  error: You have to specify `#[borsh(use_discriminant=true)]` or `#[borsh(use_discriminant=false)]` for all enums with explicit discriminant                                                                  
  --> near-sdk/src/types/public_key.rs:8:10                                                              
   |                                                                                                     
 8 | pub enum CurveType {                                                                                
   |          ^^^^^^^^^                                                                                  
                                                                                                         
```
on 

```rust
/// PublicKey curve
#[derive(Debug, Clone, Copy, PartialOrd, Ord, Eq, PartialEq, BorshDeserialize, BorshSerialize)]
#[repr(u8)]
pub enum CurveType {
    ED25519 = 0,
    SECP256K1 = 1,
}
```

We fix it with `#[borsh(use_discriminant=true)]`, which will behave the same as `#[borsh(use_discriminant=false)]`  
in this particular case, where `false` preserves the behaviour of borsh before  1.0 release 
(borsh 0.10 and older [ignored explicit discriminant values in enum definitions](https://github.com/near/borsh-rs/issues/137)):

```diff
diff --git a/near-sdk/src/types/public_key.rs b/near-sdk/src/types/public_key.rs
index 30ebd43..b539ddd 100644
--- a/near-sdk/src/types/public_key.rs
+++ b/near-sdk/src/types/public_key.rs
@@ -7,2 +7,3 @@ use std::convert::TryFrom;
 #[repr(u8)]
+#[borsh(use_discriminant=true)]
 pub enum CurveType {
@@ -144,4 +145,4 @@ impl serde::Serialize for PublicKey {
```

## 5. next we encounter errors with `borsh::maybestd` imports (`near-sdk` package):

```bash
 1  error[E0432]: unresolved import `borsh::maybestd`                                                                                                                                                                                                                      
  --> near-sdk/src/types/public_key.rs:1:13                                                                                                                                                                                                                                
   |                                                                                                                                                                                                                                                                       
 1 | use borsh::{maybestd::io, BorshDeserialize, BorshSerialize};                                                                                                                                                                                                          
   |             ^^^^^^^^ could not find `maybestd` in `borsh`                                                                                                                                                                                                             
                                                                                                                                                                                                                                                                           
 2  error[E0432]: unresolved import `borsh::maybestd`                                                                                                                                                                                                                      
  --> near-sdk/src/types/account_id.rs:1:13                                                                                                                                                                                                                                
   |                                                                                                                                                                                                                                                                       
 1 | use borsh::{maybestd::io, BorshDeserialize, BorshSchema, BorshSerialize};                                                                                                                                                                                             
   |             ^^^^^^^^ could not find `maybestd` in `borsh`                                                                                                                                                                                                             
                                                                                                                                                                                                                                                                           
```
```rust
// near-sdk/src/types/public_key.rs
impl BorshDeserialize for PublicKey {
    fn deserialize(buf: &mut &[u8]) -> io::Result<Self> {
        <Vec<u8> as BorshDeserialize>::deserialize(buf).and_then(|s| {
            Self::try_from(s).map_err(|e| io::Error::new(io::ErrorKind::InvalidData, e))
        })
    }
}
```

`maybestd` [has moved](https://github.com/near/borsh-rs/pull/171) to a `__private` package in `borsh`, and is not supposed to be
accessed directly now besides from within code, derived in `borsh` traits implementations.

As `near-sdk` crate is not supposed to be used in `no_std` context, we can
replace imports with `std::io`:

```diff
diff --git a/near-sdk/src/types/account_id.rs b/near-sdk/src/types/account_id.rs
index a338b5c..7876d77 100644
--- a/near-sdk/src/types/account_id.rs
+++ b/near-sdk/src/types/account_id.rs
@@ -1,5 +1,5 @@
-use borsh::{maybestd::io, BorshDeserialize, BorshSchema, BorshSerialize};
+use borsh::{BorshDeserialize, BorshSchema, BorshSerialize};
 use serde::{de, Deserialize, Serialize};
 use std::convert::TryFrom;
-use std::fmt;
+use std::{fmt, io};
 
diff --git a/near-sdk/src/types/public_key.rs b/near-sdk/src/types/public_key.rs
index 10175a0..4280f70 100644
--- a/near-sdk/src/types/public_key.rs
+++ b/near-sdk/src/types/public_key.rs
@@ -1,4 +1,4 @@
-use borsh::{maybestd::io, BorshDeserialize, BorshSerialize};
+use borsh::{BorshDeserialize, BorshSerialize};
 use bs58::decode::Error as B58Error;
-use std::convert::TryFrom;
+use std::{convert::TryFrom, io};
```

Otherwise, if we intended to support [both `std` and `no_std`](https://github.com/near/borsh-rs/pull/212), we would've imported from `borsh::io`:

```diff
-use borsh::{maybestd::io, BorshDeserialize, BorshSerialize};
+use borsh::{BorshDeserialize, BorshSerialize};
+use borsh::io;
```

## 6. next we encounter a large number of similar syntax errors with `borsh_skip` (`near-sdk` package):

```bash
 1  error: cannot find attribute `borsh_skip` in this scope                                                                                                                                                                                                                
   --> near-sdk/src/store/lookup_map/mod.rs:89:7                                                                                                                                                                                                                           
    |                                                                                                                                                                                                                                                                      
 89 |     #[borsh_skip]                                                                                                                                                                                                                                                    
    |       ^^^^^^^^^^                                                                                                                                                                                                                                                     
                                                                                                                                                                                                                                                                           
```

We change all of these occurencies according to [new](https://github.com/near/borsh-rs/pull/192) 
`#[borsh(skip)]` syntax. The following diff is shortened to first and last
occurencies:

```diff
diff --git a/near-sdk/src/collections/lazy_option.rs b/near-sdk/src/collections/lazy_option.rs
index 04e79fb..f4ea0dc 100644
--- a/near-sdk/src/collections/lazy_option.rs
+++ b/near-sdk/src/collections/lazy_option.rs
@@ -19,3 +19,3 @@ pub struct LazyOption<T> {
     storage_key: Vec<u8>,
-    #[borsh_skip]
+    #[borsh(skip)]
     el: PhantomData<T>,
...
diff --git a/near-sdk/src/store/lookup_set/mod.rs b/near-sdk/src/store/lookup_set/mod.rs
index 762956a..b2d1ac0 100644
--- a/near-sdk/src/store/lookup_set/mod.rs
+++ b/near-sdk/src/store/lookup_set/mod.rs
@@ -54,3 +54,3 @@ where
 
-    #[borsh_skip]
+    #[borsh(skip)]
     hasher: PhantomData<fn() -> (T, H)>,
```

## 7. next there's a bunch of similar errors with `borsh::maybestd::io` imports (`near-sdk` package):

They're fixed in a similar way as in 5.

## 8. next there's a bunch of similar errors due to `BorshDeserialize` trait signature change (`near-sdk` package):

```bash
 1  error[E0046]: not all trait items implemented, missing: `deserialize_reader`                                                                                                                                                                                           
    --> near-sdk/src/store/vec/mod.rs:138:1                                                                                                                                                                                                                                
     |                                                                                                                                                                                                                                                                     
 138 | impl<T> BorshDeserialize for Vector<T>                                                                                                                                                                                                                              
     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `deserialize_reader` in implementation                                                                                                                                                                               
     
     = help: implement the missing item: `fn deserialize_reader<R>(_: &mut R) -> std::result::Result<Self, std::io::Error> where R: std::io::Read { todo!() }
```

The signature of trait has changed on 0.9.3 -> 0.10.0 transition in [implement deserialize_reader](https://github.com/near/borsh-rs/pull/116).
We fix it the following way:

```diff
diff --git a/near-sdk/src/store/free_list/mod.rs b/near-sdk/src/store/free_list/mod.rs
index 43d8908..20a1cc7 100644
--- a/near-sdk/src/store/free_list/mod.rs
+++ b/near-sdk/src/store/free_list/mod.rs
@@ -47,7 +47,7 @@ where
 {
-    fn deserialize(buf: &mut &[u8]) -> Result<Self, std::io::Error> {
+    fn deserialize_reader<R: std::io::Read>(reader: &mut R) -> Result<Self, std::io::Error> {
         Ok(Self {
-            first_free: BorshDeserialize::deserialize(buf)?,
-            occupied_count: BorshDeserialize::deserialize(buf)?,
-            elements: BorshDeserialize::deserialize(buf)?,
+            first_free: BorshDeserialize::deserialize_reader(reader)?,
+            occupied_count: BorshDeserialize::deserialize_reader(reader)?,
+            elements: BorshDeserialize::deserialize_reader(reader)?,
         })
diff --git a/near-sdk/src/store/unordered_map/mod.rs b/near-sdk/src/store/unordered_map/mod.rs
index 5decc60..d82a8aa 100644
--- a/near-sdk/src/store/unordered_map/mod.rs
+++ b/near-sdk/src/store/unordered_map/mod.rs
@@ -117,6 +117,6 @@ where
 {
-    fn deserialize(buf: &mut &[u8]) -> Result<Self, std::io::Error> {
+    fn deserialize_reader<R: std::io::Read>(reader: &mut R) -> Result<Self, std::io::Error> {
         Ok(Self {
-            keys: BorshDeserialize::deserialize(buf)?,
-            values: BorshDeserialize::deserialize(buf)?,
+            keys: BorshDeserialize::deserialize_reader(reader)?,
+            values: BorshDeserialize::deserialize_reader(reader)?,
         })
diff --git a/near-sdk/src/store/vec/mod.rs b/near-sdk/src/store/vec/mod.rs
index 9d19614..94127ba 100644
--- a/near-sdk/src/store/vec/mod.rs
+++ b/near-sdk/src/store/vec/mod.rs
@@ -141,6 +141,6 @@ where
 {
-    fn deserialize(buf: &mut &[u8]) -> Result<Self, std::io::Error> {
+    fn deserialize_reader<R: std::io::Read>(reader: &mut R) -> Result<Self, std::io::Error> {
         Ok(Self {
-            len: BorshDeserialize::deserialize(buf)?,
-            values: BorshDeserialize::deserialize(buf)?,
+            len: BorshDeserialize::deserialize_reader(reader)?,
+            values: BorshDeserialize::deserialize_reader(reader)?,
         })
diff --git a/near-sdk/src/types/account_id.rs b/near-sdk/src/types/account_id.rs
index 7876d77..3da417a 100644
--- a/near-sdk/src/types/account_id.rs
+++ b/near-sdk/src/types/account_id.rs
@@ -88,4 +88,4 @@ impl<'de> Deserialize<'de> for AccountId {
 impl BorshDeserialize for AccountId {
-    fn deserialize(buf: &mut &[u8]) -> io::Result<Self> {
-        <String as BorshDeserialize>::deserialize(buf).and_then(|s| {
+    fn deserialize_reader<R: io::Read>(reader: &mut R) -> io::Result<Self> {
+        <String as BorshDeserialize>::deserialize_reader(reader).and_then(|s| {
             Self::try_from(s).map_err(|e| io::Error::new(io::ErrorKind::InvalidData, e))
diff --git a/near-sdk/src/types/public_key.rs b/near-sdk/src/types/public_key.rs
index 4280f70..b539ddd 100644
--- a/near-sdk/src/types/public_key.rs
+++ b/near-sdk/src/types/public_key.rs
@@ -145,4 +145,4 @@ impl serde::Serialize for PublicKey {
 impl BorshDeserialize for PublicKey {
-    fn deserialize(buf: &mut &[u8]) -> io::Result<Self> {
-        <Vec<u8> as BorshDeserialize>::deserialize(buf).and_then(|s| {
+    fn deserialize_reader<R: io::Read>(reader: &mut R) -> io::Result<Self> {
+        <Vec<u8> as BorshDeserialize>::deserialize_reader(reader).and_then(|s| {
             Self::try_from(s).map_err(|e| io::Error::new(io::ErrorKind::InvalidData, e))
diff --git a/near-sdk/src/collections/unordered_map/mod.rs b/near-sdk/src/collections/unordered_map/mod.rs
index d3ba8d5..aab31a4 100644
--- a/near-sdk/src/collections/unordered_map/mod.rs
+++ b/near-sdk/src/collections/unordered_map/mod.rs
@@ -512,5 +512,5 @@ mod tests {
         impl BorshDeserialize for DeserializeCounter {
-            fn deserialize(buf: &mut &[u8]) -> std::io::Result<Self> {
+            fn deserialize_reader<R: std::io::Read>(reader: &mut R) -> std::io::Result<Self> {
                 DES_COUNT.fetch_add(1, Ordering::SeqCst);
-                u64::deserialize(buf).map(DeserializeCounter)
+                u64::deserialize_reader(reader).map(DeserializeCounter)
             }
```

## 9. next we encounter an error with `BorshDeserialize` trait derivation (`near-sdk` package):

```bash
 6  error[E0277]: the trait bound `T: Default` is not satisfied
    --> near-sdk/src/store/vec/mod.rs:145:21
     |
 145 |             values: BorshDeserialize::deserialize_reader(reader)?,
     |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `T`
     |
 note: required for `IndexMap<T>` to implement `BorshDeserialize`
    --> near-sdk/src/store/index_map.rs:12:26
     |
 12  | #[derive(BorshSerialize, BorshDeserialize)]
     |                          ^^^^^^^^^^^^^^^^ unsatisfied trait bound introduced in this `derive` macro
 13  | pub(crate) struct IndexMap<T>
     |                   ^^^^^^^^^^^
     = note: this error originates in the derive macro `BorshDeserialize` (in Nightly builds, run with -Z macro-backtrace for more info)
 help: consider further restricting this bound
     |
 140 |     T: BorshSerialize + std::default::Default,
     |                       +++++++++++++++++++++++
```

where `IndexMap<T>` looks like the following:

```rust
#[derive(BorshSerialize, BorshDeserialize)]
pub(crate) struct IndexMap<T>
where
    T: BorshSerialize,
{
    pub(crate) prefix: Box<[u8]>,
    /// Cache for loads and intermediate changes to the underlying index map.
    /// The cached entries are wrapped in a [`Box`] to avoid existing pointers from being
    /// invalidated.
    ///
    /// Note: u32 indices are used over usize to have consistent functionality across architectures.
    /// Some functionality would be different from tests to Wasm if exceeding 32-bit length.
    #[borsh(skip)]
    pub(crate) cache: StableMap<u32, OnceCell<CacheEntry<T>>>,
}
```

On version change `v0.9` -> `v1.0.0-alpha.5` bounds derivation in `borsh` [has changed](https://github.com/near/borsh-rs/pull/178):

From bounds on the types of the fields:

```rust
// cd near-sdk; cargo expand ::store::index_map 
impl<T> borsh::de::BorshDeserialize for IndexMap<T>
where
    T: BorshSerialize,
    Box<[u8]>: borsh::BorshDeserialize,
{
    fn deserialize(
        buf: &mut &[u8],
    ) -> ::core::result::Result<Self, borsh::maybestd::io::Error> {
        Ok(Self {
            prefix: borsh::BorshDeserialize::deserialize(buf)?,
            cache: Default::default(),
        })
    }
}
```

to bounds on type parameters, encountered in fields. `borsh::de::BorshDeserialize` bound 
for parameters in non-skipped fields, `core::default::Default` bound - otherwise:

```rust
impl<T> borsh::de::BorshDeserialize for IndexMap<T>
where
    T: BorshSerialize,
    T: core::default::Default,
{
    fn deserialize_reader<R: borsh::__private::maybestd::io::Read>(
        reader: &mut R,
    ) -> ::core::result::Result<Self, borsh::__private::maybestd::io::Error> {
        Ok(Self {
            prefix: borsh::BorshDeserialize::deserialize_reader(reader)?,
            cache: core::default::Default::default(),
        })
    }
}
```

We can instruct `borsh` to [replace automatically derived bound](https://github.com/near/borsh-rs/pull/180) with nothing, as `StableMap` has a `impl<K: Ord, V> Default for StableMap<K, V>` 
implementation  of its own, as it will be used when deserializing skipped field, irrelevant of bounds on `V`:

```diff
diff --git a/near-sdk/src/store/index_map.rs b/near-sdk/src/store/index_map.rs
index 834fc98..7d1df75 100644
--- a/near-sdk/src/store/index_map.rs
+++ b/near-sdk/src/store/index_map.rs
@@ -23,3 +23,3 @@ where
     /// Some functionality would be different from tests to Wasm if exceeding 32-bit length.
-    #[borsh(skip)]
+    #[borsh(skip, bound(deserialize = ""))]
     pub(crate) cache: StableMap<u32, OnceCell<CacheEntry<T>>>,
```

which would transform into following bound on trait's implementation:

```rust
// line with `T: core::default::Default,` disappeared
impl<T> borsh::de::BorshDeserialize for IndexMap<T>
where
    T: BorshSerialize,
{
...
```

Similar diffs were also applied here:

```diff
diff --git a/near-sdk/src/store/lookup_map/mod.rs b/near-sdk/src/store/lookup_map/mod.rs
index 0b20345..927b2d6 100644
--- a/near-sdk/src/store/lookup_map/mod.rs
+++ b/near-sdk/src/store/lookup_map/mod.rs
@@ -88,3 +88,3 @@ where
     /// invalidated.
-    #[borsh(skip)]
+    #[borsh(skip, bound(deserialize = ""))]
     cache: StableMap<K, EntryAndHash<V, H::KeyType>>,
```

```diff
diff --git a/near-sdk/src/store/unordered_set/mod.rs b/near-sdk/src/store/unordered_set/mod.rs
index 4504580..77621b9 100644
--- a/near-sdk/src/store/unordered_set/mod.rs
+++ b/near-sdk/src/store/unordered_set/mod.rs
@@ -83,9 +83,11 @@ pub struct UnorderedSet<T, H = Sha256>
 where
     T: BorshSerialize + Ord,
     H: ToKey,
 {
+    #[borsh(bound(serialize = "", deserialize = ""))]
     elements: FreeList<T>,
+    #[borsh(bound(serialize = "", deserialize = ""))]
     index: LookupMap<T, FreeListIndex, H>,
 }
```

## 10. next we encounter an error with `BorshSchema` trait derivation (`near-sdk` package):

```bash
 4  error[E0053]: method `add_definitions_recursively` has an incompatible type for trait
    --> near-sdk/src/promise.rs:232:22
     |
 232 |         definitions: &mut HashMap<borsh::schema::Declaration, borsh::schema::Definition>,
     |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     |                      |
     |                      expected `BTreeMap<String, Definition>`, found `HashMap<String, Definition>`
     |                      help: change the parameter type to match the trait: `&mut BTreeMap<std::string::String, Definition>`
     |
     = note: expected signature `fn(&mut BTreeMap<std::string::String, Definition>)`
                found signature `fn(&mut HashMap<std::string::String, Definition>)`
```

Signature in trait's method [has changed](https://github.com/near/borsh-rs/pull/165/):

```diff
diff --git a/near-sdk/src/promise.rs b/near-sdk/src/promise.rs
index f8afe56..a430568 100644
--- a/near-sdk/src/promise.rs
+++ b/near-sdk/src/promise.rs
@@ -2,3 +2,3 @@ use borsh::BorshSchema;
 use std::cell::RefCell;
-use std::collections::HashMap;
+use std::collections::BTreeMap;
 use std::io::{Error, Write};
@@ -231,3 +231,3 @@ impl BorshSchema for Promise {
     fn add_definitions_recursively(
-        definitions: &mut HashMap<borsh::schema::Declaration, borsh::schema::Definition>,
+        definitions: &mut BTreeMap<borsh::schema::Declaration, borsh::schema::Definition>,
     ) {
@@ -576,3 +576,3 @@ where
     fn add_definitions_recursively(
-        definitions: &mut HashMap<borsh::schema::Declaration, borsh::schema::Definition>,
+        definitions: &mut BTreeMap<borsh::schema::Declaration, borsh::schema::Definition>,
     ) {
```

## 11. next we encounter an error with both `BorshSerialize` and `BorshDeserialize` traits' derivation (`near-contract-standards` package):

```bash
 1  error: proc-macro derive panicked                                                                                                                                                                                                                                      
   --> near-contract-standards/src/fungible_token/core_impl.rs:27:10                                                                                                                                                                                                       
    |                                                                                                                                                                                                                                                                      
 27 | #[derive(BorshDeserialize, BorshSerialize)]                                                                                                                                                                                                                          
    |          ^^^^^^^^^^^^^^^^                                                                                                                                                                                                                                            
    |                                                                                                                                                                                                                                                                      
    = help: message: called `Result::unwrap()` on an `Err` value: CrateNotFound { crate_name: "borsh", path: "/home/user/Documents/code/near-sdk-rs/near-contract-standards/Cargo.toml" }                                                                           
                                                                                                                                                                                                                                                                           
 2  error: proc-macro derive panicked                                                                                                                                                                                                                                      
   --> near-contract-standards/src/fungible_token/core_impl.rs:27:28                                                                                                                                                                                                       
    |                                                                                                                                                                                                                                                                      
 27 | #[derive(BorshDeserialize, BorshSerialize)]                                                                                                                                                                                                                          
    |                            ^^^^^^^^^^^^^^                                                                                                                                                                                                                            
    |                                                                                                                                                                                                                                                                      
    = help: message: called `Result::unwrap()` on an `Err` value: CrateNotFound { crate_name: "borsh", path: "/home/user/Documents/code/near-sdk-rs/near-contract-standards/Cargo.toml" }                                                                           
```

Thing is, `borsh` [has started getting into a `panic`](https://github.com/near/borsh-rs/pull/149) when using [proc-macro-crate](https://crates.io/crates/proc-macro-crate) dependency for derives,
in the cases when `borsh` is not imported as direct dependency in the crate, which attempts to use its derive macros.
`near-contract-standards` wasn't importing `borsh` directly, just using `near-sdk`'s reexports.

We may instruct `BorshSerialize` and `BorshDeserialize` derives to skip this check of direct import
and to [use a reexported version](https://github.com/near/borsh-rs/pull/210) of `borsh` via following diff:

```diff
diff --git a/near-contract-standards/src/fungible_token/core_impl.rs b/near-contract-standards/src/fungible_token/core_impl.rs
index d61ee8e..cae776c 100644
--- a/near-contract-standards/src/fungible_token/core_impl.rs
+++ b/near-contract-standards/src/fungible_token/core_impl.rs
@@ -27,2 +27,3 @@ const ERR_TOTAL_SUPPLY_OVERFLOW: &str = "Total supply overflow";
 #[derive(BorshDeserialize, BorshSerialize)]
+#[borsh(crate = "::near_sdk::borsh")]
 pub struct FungibleToken {
 ```

## 12. finally, we update `borsh` version to `1.0.0`:

```diff
diff --git a/near-sdk/Cargo.toml b/near-sdk/Cargo.toml
index a015a64..e6099d4 100644
--- a/near-sdk/Cargo.toml
+++ b/near-sdk/Cargo.toml
@@ -26,3 +26,3 @@ near-sys = { path = "../near-sys", version = "0.2" }
 base64 = "0.13"
-borsh = { version = "=1.0.0-alpha.5", features = ["derive"] }
+borsh = { version = "1.0.0", features = ["derive"] }
 bs58 = "0.4"
```

'''
'''--- fuzz/fuzz-run/Cargo.toml ---
[package]
name = "borsh-fuzz"
version.workspace = true
rust-version.workspace = true
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2018"
publish = false

[[bin]]
name = "borsh-fuzz"
path = "src/main.rs"

[dependencies]
honggfuzz = "0.5"
borsh = { path = "../../borsh" }

'''
'''--- fuzz/fuzz-run/README.md ---
A fuzzer for Borsh deserializer. To start fuzzing, follow instructions here https://github.com/rust-fuzz/honggfuzz-rs#how-to-use-this-crate

'''
'''--- fuzz/fuzz-run/src/main.rs ---
use borsh::BorshDeserialize;
use std::collections::{BTreeMap, HashMap, HashSet};

#[macro_use]
extern crate honggfuzz;

macro_rules! fuzz_types {
    (
        $data:ident;
        $( $type:ty, )*
    ) => {
        $(
            let _ = <$type>::deserialize(&mut &$data[..]);
        )*
    };

}

fn main() {
    loop {
        fuzz!(|data: &[u8]| {
            fuzz_types!(
                data;
                u32,
                u64,
                i32,
                i64,
                f32,
                f64,
                String,
                (u32,u64,i32,i64,f32,f64,String,),
                std::net::SocketAddrV4,
                std::net::SocketAddrV6,
                std::net::Ipv4Addr,
                std::net::Ipv6Addr,
                Box<[u8]>,
                Option<u64>,
                Option<String>,
                Option<Vec<u8>>,
                Option<Vec<u64>>,
                Option<Box<[u8]>>,
                Option<std::net::SocketAddrV4>,
                Vec<u64>,
                Vec<String>,
                Vec<Vec<u8>>,
                Vec<Vec<u64>>,
                Vec<Box<[u8]>>,
                Vec<std::net::SocketAddrV4>,
                HashSet<u64>,
                HashSet<String>,
                HashSet<Vec<u8>>,
                HashSet<Vec<u64>>,
                HashSet<Box<[u8]>>,
                HashSet<std::net::SocketAddrV4>,
                HashMap<u64, u64>,
                HashMap<String, String>,
                HashMap<std::net::SocketAddrV4, String>,
                HashMap<Vec<u8>, Vec<u8>>,
                HashMap<Box<[u8]>, HashMap<String, String>>,
                BTreeMap<u64, u64>,
                BTreeMap<String, String>,
                BTreeMap<Vec<u8>, Vec<u8>>,
                BTreeMap<Box<[u8]>, BTreeMap<String, String>>,
            );
        });
    }
}

'''
'''--- release-plz.toml ---
[workspace]
# Use `borsh` crate CHANGELOG as top-level one
changelog_update = false

[[package]]
name = "borsh"
changelog_update = true
changelog_path = "./CHANGELOG.md"
changelog_include = ["borsh-derive"] 

[[package]]
name = "borsh-fuzz"
publish = false

[[package]]
name = "benchmarks"
publish = false

'''